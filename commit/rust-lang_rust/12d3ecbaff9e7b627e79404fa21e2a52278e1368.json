{"sha": "12d3ecbaff9e7b627e79404fa21e2a52278e1368", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEyZDNlY2JhZmY5ZTdiNjI3ZTc5NDA0ZmEyMWUyYTUyMjc4ZTEzNjg=", "commit": {"author": {"name": "Alexander Regueiro", "email": "alexreg@me.com", "date": "2019-02-16T01:29:38Z"}, "committer": {"name": "Alexander Regueiro", "email": "alexreg@me.com", "date": "2019-02-26T18:37:46Z"}, "message": "Various cosmetic improvements.", "tree": {"sha": "bb102d5c17a15cedd8cedd7acdb54e6f1a362bfc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bb102d5c17a15cedd8cedd7acdb54e6f1a362bfc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/12d3ecbaff9e7b627e79404fa21e2a52278e1368", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/12d3ecbaff9e7b627e79404fa21e2a52278e1368", "html_url": "https://github.com/rust-lang/rust/commit/12d3ecbaff9e7b627e79404fa21e2a52278e1368", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/12d3ecbaff9e7b627e79404fa21e2a52278e1368/comments", "author": {"login": "alexreg", "id": 67036, "node_id": "MDQ6VXNlcjY3MDM2", "avatar_url": "https://avatars.githubusercontent.com/u/67036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexreg", "html_url": "https://github.com/alexreg", "followers_url": "https://api.github.com/users/alexreg/followers", "following_url": "https://api.github.com/users/alexreg/following{/other_user}", "gists_url": "https://api.github.com/users/alexreg/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexreg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexreg/subscriptions", "organizations_url": "https://api.github.com/users/alexreg/orgs", "repos_url": "https://api.github.com/users/alexreg/repos", "events_url": "https://api.github.com/users/alexreg/events{/privacy}", "received_events_url": "https://api.github.com/users/alexreg/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexreg", "id": 67036, "node_id": "MDQ6VXNlcjY3MDM2", "avatar_url": "https://avatars.githubusercontent.com/u/67036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexreg", "html_url": "https://github.com/alexreg", "followers_url": "https://api.github.com/users/alexreg/followers", "following_url": "https://api.github.com/users/alexreg/following{/other_user}", "gists_url": "https://api.github.com/users/alexreg/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexreg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexreg/subscriptions", "organizations_url": "https://api.github.com/users/alexreg/orgs", "repos_url": "https://api.github.com/users/alexreg/repos", "events_url": "https://api.github.com/users/alexreg/events{/privacy}", "received_events_url": "https://api.github.com/users/alexreg/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a478bfebd2aef26287268fd0c0e255184a24a7a1", "url": "https://api.github.com/repos/rust-lang/rust/commits/a478bfebd2aef26287268fd0c0e255184a24a7a1", "html_url": "https://github.com/rust-lang/rust/commit/a478bfebd2aef26287268fd0c0e255184a24a7a1"}], "stats": {"total": 869, "additions": 466, "deletions": 403}, "files": [{"sha": "c11cb46b31df4e9d1a0603480570fcf157cb4614", "filename": "README.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12d3ecbaff9e7b627e79404fa21e2a52278e1368/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/12d3ecbaff9e7b627e79404fa21e2a52278e1368/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=12d3ecbaff9e7b627e79404fa21e2a52278e1368", "patch": "@@ -23,7 +23,7 @@ Miri has already discovered some [real-world bugs](#bugs-found-by-miri).\n [`copy_nonoverlapping`]: https://doc.rust-lang.org/stable/std/ptr/fn.copy_nonoverlapping.html\n \n \n-## Running Miri on your own project('s test suite)\n+## Running Miri on your own project (and its test suite)\n \n Install Miri as a cargo subcommand:\n "}, {"sha": "c88912c83d78695a8d457841ee345111953f5c01", "filename": "src/bin/cargo-miri.rs", "status": "modified", "additions": 53, "deletions": 48, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/12d3ecbaff9e7b627e79404fa21e2a52278e1368/src%2Fbin%2Fcargo-miri.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12d3ecbaff9e7b627e79404fa21e2a52278e1368/src%2Fbin%2Fcargo-miri.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Fcargo-miri.rs?ref=12d3ecbaff9e7b627e79404fa21e2a52278e1368", "patch": "@@ -2,10 +2,10 @@\n \n extern crate cargo_metadata;\n \n-use std::path::{PathBuf, Path};\n+use std::fs::{self, File};\n use std::io::{self, Write, BufRead};\n+use std::path::{PathBuf, Path};\n use std::process::Command;\n-use std::fs::{self, File};\n \n const CARGO_MIRI_HELP: &str = r#\"Interprets bin crates and tests in Miri\n \n@@ -55,15 +55,15 @@ fn show_error(msg: String) -> ! {\n     std::process::exit(1)\n }\n \n-// Determines whether a --flag is present\n+// Determines whether a `--flag` is present.\n fn has_arg_flag(name: &str) -> bool {\n     let mut args = std::env::args().take_while(|val| val != \"--\");\n     args.any(|val| val == name)\n }\n \n-/// Gets the value of a --flag\n+/// Gets the value of a `--flag`.\n fn get_arg_flag_value(name: &str) -> Option<String> {\n-    // stop searching at `--`\n+    // Stop searching at `--`.\n     let mut args = std::env::args().take_while(|val| val != \"--\");\n     loop {\n         let arg = match args.next() {\n@@ -73,13 +73,15 @@ fn get_arg_flag_value(name: &str) -> Option<String> {\n         if !arg.starts_with(name) {\n             continue;\n         }\n-        let suffix = &arg[name.len()..]; // strip leading `name`\n+        // Strip leading `name`.\n+        let suffix = &arg[name.len()..];\n         if suffix.is_empty() {\n-            // This argument is exactly `name`, the next one is the value\n+            // This argument is exactly `name`; the next one is the value.\n             return args.next();\n         } else if suffix.starts_with('=') {\n-            // This argument is `name=value`, get the value\n-            return Some(suffix[1..].to_owned()); // strip leading `=`\n+            // This argument is `name=value`; get the value.\n+            // Strip leading `=`.\n+            return Some(suffix[1..].to_owned());\n         }\n     }\n }\n@@ -96,7 +98,7 @@ fn list_targets() -> impl Iterator<Item=cargo_metadata::Target> {\n     {\n         metadata\n     } else {\n-        show_error(format!(\"error: Could not obtain cargo metadata.\"));\n+        show_error(format!(\"Could not obtain Cargo metadata\"));\n     };\n \n     let current_dir = std::env::current_dir();\n@@ -167,20 +169,22 @@ fn ask(question: &str) {\n     io::stdout().flush().unwrap();\n     io::stdin().read_line(&mut buf).unwrap();\n     match buf.trim().to_lowercase().as_ref() {\n-        \"\" | \"y\" | \"yes\" => {}, // proceed\n+        // Proceed.\n+        \"\" | \"y\" | \"yes\" => {},\n         \"n\" | \"no\" => show_error(format!(\"Aborting as per your request\")),\n         a => show_error(format!(\"I do not understand `{}`\", a))\n     };\n }\n \n-/// Perform the setup requires to make `cargo miri` work: Getting a custom-built libstd. Then sets MIRI_SYSROOT.\n-/// Skipped if MIRI_SYSROOT is already set, in that case we expect the user has done all this already.\n+/// Performs the setup required to make `cargo miri` work: Getting a custom-built libstd. Then sets\n+/// `MIRI_SYSROOT`. Skipped if `MIRI_SYSROOT` is already set, in which case we expect the user has\n+/// done all this already.\n fn setup(ask_user: bool) {\n     if std::env::var(\"MIRI_SYSROOT\").is_ok() {\n         return;\n     }\n \n-    // First, we need xargo\n+    // First, we need xargo.\n     let xargo = xargo_version();\n     if xargo.map_or(true, |v| v < (0, 3, 13)) {\n         if ask_user {\n@@ -193,7 +197,7 @@ fn setup(ask_user: bool) {\n         }\n     }\n \n-    // Then, unless XARGO_RUST_SRC is set, we also need rust-src.\n+    // Then, unless `XARGO_RUST_SRC` is set, we also need rust-src.\n     // Let's see if it is already installed.\n     if std::env::var(\"XARGO_RUST_SRC\").is_err() {\n         let sysroot = Command::new(\"rustc\").args(&[\"--print\", \"sysroot\"]).output().unwrap().stdout;\n@@ -229,7 +233,7 @@ features = [\"panic_unwind\"]\n [dependencies.test]\n stage = 1\n         \"#).unwrap();\n-    // The boring bits: A dummy project for xargo\n+    // The boring bits: a dummy project for xargo.\n     File::create(dir.join(\"Cargo.toml\")).unwrap()\n         .write_all(br#\"\n [package]\n@@ -241,7 +245,7 @@ version = \"0.0.0\"\n path = \"lib.rs\"\n         \"#).unwrap();\n     File::create(dir.join(\"lib.rs\")).unwrap();\n-    // Run xargo\n+    // Run xargo.\n     let target = get_arg_flag_value(\"--target\");\n     let mut command = Command::new(\"xargo\");\n     command.arg(\"build\").arg(\"-q\")\n@@ -256,7 +260,7 @@ path = \"lib.rs\"\n         show_error(format!(\"Failed to run xargo\"));\n     }\n \n-    // That should be it!  But we need to figure out where xargo built stuff.\n+    // That should be it! But we need to figure out where xargo built stuff.\n     // Unfortunately, it puts things into a different directory when the\n     // architecture matches the host.\n     let is_host = match target {\n@@ -271,7 +275,7 @@ path = \"lib.rs\"\n }\n \n fn main() {\n-    // Check for version and help flags even when invoked as 'cargo-miri'\n+    // Check for version and help flags even when invoked as `cargo-miri`.\n     if std::env::args().any(|a| a == \"--help\" || a == \"-h\") {\n         show_help();\n         return;\n@@ -282,17 +286,16 @@ fn main() {\n     }\n \n     if let Some(\"miri\") = std::env::args().nth(1).as_ref().map(AsRef::as_ref) {\n-        // this arm is when `cargo miri` is called.  We call `cargo rustc` for\n-        // each applicable target, but with the RUSTC env var set to the `cargo-miri`\n-        // binary so that we come back in the other branch, and dispatch\n-        // the invocations to rustc and miri, respectively.\n+        // This arm is for when `cargo miri` is called. We call `cargo rustc` for each applicable target,\n+        // but with the `RUSTC` env var set to the `cargo-miri` binary so that we come back in the other branch,\n+        // and dispatch the invocations to `rustc` and `miri`, respectively.\n         in_cargo_miri();\n     } else if let Some(\"rustc\") = std::env::args().nth(1).as_ref().map(AsRef::as_ref) {\n-        // This arm is executed when cargo-miri runs `cargo rustc` with the `RUSTC_WRAPPER` env var set to itself:\n-        // Dependencies get dispatched to rustc, the final test/binary to miri.\n+        // This arm is executed when `cargo-miri` runs `cargo rustc` with the `RUSTC_WRAPPER` env var set to itself:\n+        // dependencies get dispatched to `rustc`, the final test/binary to `miri`.\n         inside_cargo_rustc();\n     } else {\n-        show_error(format!(\"Must be called with either `miri` or `rustc` as first argument.\"))\n+        show_error(format!(\"must be called with either `miri` or `rustc` as first argument.\"))\n     }\n }\n \n@@ -301,17 +304,17 @@ fn in_cargo_miri() {\n         Some(\"test\") => (MiriCommand::Test, 3),\n         Some(\"run\") => (MiriCommand::Run, 3),\n         Some(\"setup\") => (MiriCommand::Setup, 3),\n-        // Default command, if there is an option or nothing\n+        // Default command, if there is an option or nothing.\n         Some(s) if s.starts_with(\"-\") => (MiriCommand::Run, 2),\n         None => (MiriCommand::Run, 2),\n-        // Unvalid command\n+        // Invalid command.\n         Some(s) => {\n             show_error(format!(\"Unknown command `{}`\", s))\n         }\n     };\n     let verbose = has_arg_flag(\"-v\");\n \n-    // We always setup\n+    // We always setup.\n     let ask = subcommand != MiriCommand::Setup;\n     setup(ask);\n     if subcommand == MiriCommand::Setup {\n@@ -326,41 +329,41 @@ fn in_cargo_miri() {\n             \"badly formatted cargo metadata: target::kind is an empty array\",\n         );\n         // Now we run `cargo rustc $FLAGS $ARGS`, giving the user the\n-        // change to add additional flags.  \"FLAGS\" is set to identify\n+        // change to add additional flags. `FLAGS` is set to identify\n         // this target.  The user gets to control what gets actually passed to Miri.\n         // However, we need to add a flag to what gets passed to rustc for the finaly\n         // binary, so that we know to interpret that with Miri.\n-        // So after the first \"--\", we add \"-Zcargo-miri-marker\".\n+        // So after the first `--`, we add `-Zcargo-miri-marker`.\n         let mut cmd = Command::new(\"cargo\");\n         cmd.arg(\"rustc\");\n         match (subcommand, &kind[..]) {\n             (MiriCommand::Run, \"bin\") => {\n-                // FIXME: We just run all the binaries here.\n+                // FIXME: we just run all the binaries here.\n                 // We should instead support `cargo miri --bin foo`.\n                 cmd.arg(\"--bin\").arg(target.name);\n             }\n             (MiriCommand::Test, \"test\") => {\n                 cmd.arg(\"--test\").arg(target.name);\n             }\n             (MiriCommand::Test, \"lib\") => {\n-                // There can be only one lib\n+                // There can be only one lib.\n                 cmd.arg(\"--lib\").arg(\"--profile\").arg(\"test\");\n             }\n             (MiriCommand::Test, \"bin\") => {\n                 cmd.arg(\"--bin\").arg(target.name).arg(\"--profile\").arg(\"test\");\n             }\n-            // The remaining targets we do not even want to build\n+            // The remaining targets we do not even want to build.\n             _ => continue,\n         }\n-        // add user-defined args until first \"--\"\n+        // Add user-defined args until first `--`.\n         while let Some(arg) = args.next() {\n             if arg == \"--\" {\n                 break;\n             }\n             cmd.arg(arg);\n         }\n-        // Add \"--\" (to end the cargo flags), and then the user flags.  We add markers around the user flags\n-        // to be able to identify them later.\n+        // Add `--` (to end the `cargo` flags), and then the user flags. We add markers around the\n+        // user flags to be able to identify them later.\n         cmd\n             .arg(\"--\")\n             .arg(\"cargo-miri-marker-begin\")\n@@ -403,11 +406,11 @@ fn inside_cargo_rustc() {\n                     .and_then(|out| String::from_utf8(out.stdout).ok())\n                     .map(|s| s.trim().to_owned())\n             })\n-            .expect(\"need to specify RUST_SYSROOT env var during miri compilation, or use rustup or multirust\")\n+            .expect(\"need to specify `RUST_SYSROOT` env var during miri compilation, or use rustup or multirust\")\n     };\n \n-    // this conditional check for the --sysroot flag is there so users can call `cargo-miri` directly\n-    // without having to pass --sysroot or anything\n+    // This conditional check for the `--sysroot` flag is there so that users can call `cargo-miri`\n+    // directly without having to pass `--sysroot` or anything.\n     let rustc_args = std::env::args().skip(2);\n     let mut args: Vec<String> = if std::env::args().any(|s| s == \"--sysroot\") {\n         rustc_args.collect()\n@@ -419,25 +422,27 @@ fn inside_cargo_rustc() {\n     };\n     args.splice(0..0, miri::miri_default_args().iter().map(ToString::to_string));\n \n-    // See if we can find the cargo-miri markers.  Those only get added to the binary we want to\n-    // run.  They also serve to mark the user-defined arguments, which we have to move all the way to the\n-    // end (they get added somewhere in the middle).\n+    // See if we can find the `cargo-miri` markers. Those only get added to the binary we want to\n+    // run. They also serve to mark the user-defined arguments, which we have to move all the way\n+    // to the end (they get added somewhere in the middle).\n     let needs_miri = if let Some(begin) = args.iter().position(|arg| arg == \"cargo-miri-marker-begin\") {\n-        let end = args.iter().position(|arg| arg == \"cargo-miri-marker-end\").expect(\"Cannot find end marker\");\n-        // These mark the user arguments.  We remove the first and last as they are the markers.\n+        let end = args\n+            .iter()\n+            .position(|arg| arg == \"cargo-miri-marker-end\")\n+            .expect(\"cannot find end marker\");\n+        // These mark the user arguments. We remove the first and last as they are the markers.\n         let mut user_args = args.drain(begin..=end);\n         assert_eq!(user_args.next().unwrap(), \"cargo-miri-marker-begin\");\n         assert_eq!(user_args.next_back().unwrap(), \"cargo-miri-marker-end\");\n-        // Collect the rest and add it back at the end\n+        // Collect the rest and add it back at the end.\n         let mut user_args = user_args.collect::<Vec<String>>();\n         args.append(&mut user_args);\n-        // Run this in Miri\n+        // Run this in Miri.\n         true\n     } else {\n         false\n     };\n \n-\n     let mut command = if needs_miri {\n         let mut path = std::env::current_exe().expect(\"current executable path invalid\");\n         path.set_file_name(\"miri\");"}, {"sha": "0f1501d5913b20032a73cea78d9a374881ad1467", "filename": "src/bin/miri.rs", "status": "modified", "additions": 23, "deletions": 25, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/12d3ecbaff9e7b627e79404fa21e2a52278e1368/src%2Fbin%2Fmiri.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12d3ecbaff9e7b627e79404fa21e2a52278e1368/src%2Fbin%2Fmiri.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Fmiri.rs?ref=12d3ecbaff9e7b627e79404fa21e2a52278e1368", "patch": "@@ -1,23 +1,23 @@\n #![feature(rustc_private)]\n \n+extern crate env_logger;\n extern crate getopts;\n+#[macro_use]\n+extern crate log;\n+extern crate log_settings;\n extern crate miri;\n extern crate rustc;\n extern crate rustc_metadata;\n extern crate rustc_driver;\n extern crate rustc_errors;\n extern crate rustc_codegen_utils;\n-extern crate env_logger;\n-extern crate log_settings;\n extern crate syntax;\n \n-#[macro_use]\n-extern crate log;\n-\n use std::path::PathBuf;\n use std::str::FromStr;\n use std::env;\n \n+use miri::MiriConfig;\n use rustc::session::Session;\n use rustc_metadata::cstore::CStore;\n use rustc_driver::{Compilation, CompilerCalls, RustcDefaultCalls};\n@@ -27,8 +27,6 @@ use rustc_codegen_utils::codegen_backend::CodegenBackend;\n use rustc::hir::def_id::LOCAL_CRATE;\n use syntax::ast;\n \n-use miri::MiriConfig;\n-\n struct MiriCompilerCalls {\n     default: Box<RustcDefaultCalls>,\n     miri_config: MiriConfig,\n@@ -79,7 +77,7 @@ impl<'a> CompilerCalls<'a> for MiriCompilerCalls {\n         odir: &Option<PathBuf>,\n         ofile: &Option<PathBuf>,\n     ) -> Compilation {\n-        // Called *before* build_controller. Add filename to miri arguments.\n+        // Called *before* `build_controller`. Add filename to `miri` arguments.\n         self.miri_config.args.insert(0, input.filestem().to_string());\n         self.default.late_callback(codegen_backend, matches, sess, cstore, input, odir, ofile)\n     }\n@@ -125,27 +123,27 @@ fn after_analysis<'a, 'tcx>(\n }\n \n fn init_early_loggers() {\n-    // Notice that our `extern crate log` is NOT the same as rustc's!  So we have to initialize\n-    // them both.  We always initialize miri early.\n+    // Note that our `extern crate log` is *not* the same as rustc's; as a result, we have to\n+    // initialize them both, and we always initialize `miri`'s first.\n     let env = env_logger::Env::new().filter(\"MIRI_LOG\").write_style(\"MIRI_LOG_STYLE\");\n     env_logger::init_from_env(env);\n-    // We only initialize rustc if the env var is set (so the user asked for it).\n+    // We only initialize `rustc` if the env var is set (so the user asked for it).\n     // If it is not set, we avoid initializing now so that we can initialize\n-    // later with our custom settings, and NOT log anything for what happens before\n-    // miri gets started.\n+    // later with our custom settings, and *not* log anything for what happens before\n+    // `miri` gets started.\n     if env::var(\"RUST_LOG\").is_ok() {\n         rustc_driver::init_rustc_env_logger();\n     }\n }\n \n fn init_late_loggers() {\n-    // Initializing loggers right before we start evaluation.  We overwrite the RUST_LOG\n-    // env var if it is not set, control it based on MIRI_LOG.\n+    // We initialize loggers right before we start evaluation. We overwrite the `RUST_LOG`\n+    // env var if it is not set, control it based on `MIRI_LOG`.\n     if let Ok(var) = env::var(\"MIRI_LOG\") {\n         if env::var(\"RUST_LOG\").is_err() {\n-            // We try to be a bit clever here: If MIRI_LOG is just a single level\n+            // We try to be a bit clever here: if `MIRI_LOG` is just a single level\n             // used for everything, we only apply it to the parts of rustc that are\n-            // CTFE-related.  Otherwise, we use it verbatim for RUST_LOG.\n+            // CTFE-related. Otherwise, we use it verbatim for `RUST_LOG`.\n             // This way, if you set `MIRI_LOG=trace`, you get only the right parts of\n             // rustc traced, but you can also do `MIRI_LOG=miri=trace,rustc_mir::interpret=debug`.\n             if log::Level::from_str(&var).is_ok() {\n@@ -158,7 +156,7 @@ fn init_late_loggers() {\n         }\n     }\n \n-    // If MIRI_BACKTRACE is set and RUST_CTFE_BACKTRACE is not, set RUST_CTFE_BACKTRACE.\n+    // If `MIRI_BACKTRACE` is set and `RUST_CTFE_BACKTRACE` is not, set `RUST_CTFE_BACKTRACE`.\n     // Do this late, so we really only apply this to miri's errors.\n     if let Ok(var) = env::var(\"MIRI_BACKTRACE\") {\n         if env::var(\"RUST_CTFE_BACKTRACE\") == Err(env::VarError::NotPresent) {\n@@ -172,16 +170,16 @@ fn find_sysroot() -> String {\n         return sysroot;\n     }\n \n-    // Taken from https://github.com/Manishearth/rust-clippy/pull/911.\n+    // Taken from PR <https://github.com/Manishearth/rust-clippy/pull/911>.\n     let home = option_env!(\"RUSTUP_HOME\").or(option_env!(\"MULTIRUST_HOME\"));\n     let toolchain = option_env!(\"RUSTUP_TOOLCHAIN\").or(option_env!(\"MULTIRUST_TOOLCHAIN\"));\n     match (home, toolchain) {\n         (Some(home), Some(toolchain)) => format!(\"{}/toolchains/{}\", home, toolchain),\n         _ => {\n             option_env!(\"RUST_SYSROOT\")\n                 .expect(\n-                    \"Could not find sysroot. Either set MIRI_SYSROOT at run-time, or at \\\n-                     build-time specify RUST_SYSROOT env var or use rustup or multirust\",\n+                    \"could not find sysroot. either set `MIRI_SYSROOT` at run-time, or at \\\n+                     build-time specify `RUST_SYSROOT` env var or use rustup or multirust\",\n                 )\n                 .to_owned()\n         }\n@@ -191,18 +189,18 @@ fn find_sysroot() -> String {\n fn main() {\n     init_early_loggers();\n \n-    // Parse our arguments and split them across rustc and miri\n+    // Parse our arguments and split them across `rustc` and `miri`.\n     let mut validate = true;\n     let mut rustc_args = vec![];\n     let mut miri_args = vec![];\n     let mut after_dashdash = false;\n     for arg in std::env::args() {\n         if rustc_args.is_empty() {\n-            // Very first arg: for rustc\n+            // Very first arg: for `rustc`.\n             rustc_args.push(arg);\n         }\n         else if after_dashdash {\n-            // Everything that comes is Miri args\n+            // Everything that comes after are `miri` args.\n             miri_args.push(arg);\n         } else {\n             match arg.as_str() {\n@@ -219,7 +217,7 @@ fn main() {\n         }\n     }\n \n-    // Determine sysroot and let rustc know about it\n+    // Determine sysroot and let rustc know about it.\n     let sysroot_flag = String::from(\"--sysroot\");\n     if !rustc_args.contains(&sysroot_flag) {\n         rustc_args.push(sysroot_flag);"}, {"sha": "fa8c61e678bebe90f4dfa8615fb023c688856ea9", "filename": "src/fn_call.rs", "status": "modified", "additions": 99, "deletions": 73, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/12d3ecbaff9e7b627e79404fa21e2a52278e1368/src%2Ffn_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12d3ecbaff9e7b627e79404fa21e2a52278e1368/src%2Ffn_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffn_call.rs?ref=12d3ecbaff9e7b627e79404fa21e2a52278e1368", "patch": "@@ -7,7 +7,7 @@ use syntax::attr;\n use crate::*;\n \n impl<'a, 'mir, 'tcx> EvalContextExt<'a, 'mir, 'tcx> for crate::MiriEvalContext<'a, 'mir, 'tcx> {}\n-pub trait EvalContextExt<'a, 'mir, 'tcx: 'a+'mir>: crate::MiriEvalContextExt<'a, 'mir, 'tcx> {\n+pub trait EvalContextExt<'a, 'mir, 'tcx: 'a + 'mir>: crate::MiriEvalContextExt<'a, 'mir, 'tcx> {\n     fn find_fn(\n         &mut self,\n         instance: ty::Instance<'tcx>,\n@@ -18,15 +18,15 @@ pub trait EvalContextExt<'a, 'mir, 'tcx: 'a+'mir>: crate::MiriEvalContextExt<'a,\n         let this = self.eval_context_mut();\n         trace!(\"eval_fn_call: {:#?}, {:?}\", instance, dest.map(|place| *place));\n \n-        // first run the common hooks also supported by CTFE\n+        // First, run the common hooks also supported by CTFE.\n         if this.hook_fn(instance, args, dest)? {\n             this.goto_block(ret)?;\n             return Ok(None);\n         }\n-        // there are some more lang items we want to hook that CTFE does not hook (yet)\n+        // There are some more lang items we want to hook that CTFE does not hook (yet).\n         if this.tcx.lang_items().align_offset_fn() == Some(instance.def.def_id()) {\n             // FIXME: return a real value in case the target allocation has an\n-            // alignment bigger than the one requested\n+            // alignment bigger than the one requested.\n             let n = u128::max_value();\n             let dest = dest.unwrap();\n             let n = this.truncate(n, dest.layout);\n@@ -35,20 +35,20 @@ pub trait EvalContextExt<'a, 'mir, 'tcx: 'a+'mir>: crate::MiriEvalContextExt<'a,\n             return Ok(None);\n         }\n \n-        // Try to see if we can do something about foreign items\n+        // Try to see if we can do something about foreign items.\n         if this.tcx.is_foreign_item(instance.def_id()) {\n             // An external function that we cannot find MIR for, but we can still run enough\n             // of them to make miri viable.\n             this.emulate_foreign_item(instance.def_id(), args, dest, ret)?;\n-            // `goto_block` already handled\n+            // `goto_block` already handled.\n             return Ok(None);\n         }\n \n-        // Otherwise, load the MIR\n+        // Otherwise, load the MIR.\n         Ok(Some(this.load_mir(instance.def)?))\n     }\n \n-    /// Emulate calling a foreign item, fail if the item is not supported.\n+    /// Emulates calling a foreign item, failing if the item is not supported.\n     /// This function will handle `goto_block` if needed.\n     fn emulate_foreign_item(\n         &mut self,\n@@ -63,11 +63,11 @@ pub trait EvalContextExt<'a, 'mir, 'tcx: 'a+'mir>: crate::MiriEvalContextExt<'a,\n             Some(name) => name.as_str(),\n             None => this.tcx.item_name(def_id).as_str(),\n         };\n-        // Strip linker suffixes (seen on 32bit macOS)\n+        // Strip linker suffixes (seen on 32-bit macOS).\n         let link_name = link_name.trim_end_matches(\"$UNIX2003\");\n         let tcx = &{this.tcx.tcx};\n \n-        // first: functions that could diverge\n+        // First: functions that could diverge.\n         match &link_name[..] {\n             \"__rust_start_panic\" | \"panic_impl\" => {\n                 return err!(MachineError(\"the evaluated program panicked\".to_string()));\n@@ -79,9 +79,9 @@ pub trait EvalContextExt<'a, 'mir, 'tcx: 'a+'mir>: crate::MiriEvalContextExt<'a,\n             }\n         }\n \n-        // now: functions that assume a ret and dest\n+        // Next: functions that assume a ret and dest.\n         let dest = dest.expect(\"we already checked for a dest\");\n-        let ret = ret.expect(\"dest is Some but ret is None\");\n+        let ret = ret.expect(\"dest is `Some` but ret is `None`\");\n         match &link_name[..] {\n             \"malloc\" => {\n                 let size = this.read_scalar(args[0])?.to_usize(this)?;\n@@ -97,7 +97,7 @@ pub trait EvalContextExt<'a, 'mir, 'tcx: 'a+'mir>: crate::MiriEvalContextExt<'a,\n                 let ret = this.deref_operand(args[0])?;\n                 let align = this.read_scalar(args[1])?.to_usize(this)?;\n                 let size = this.read_scalar(args[2])?.to_usize(this)?;\n-                // align must be a power of 2, and also at least ptr-sized (wtf, POSIX)\n+                // Align must be power of 2, and also at least ptr-sized (POSIX rules).\n                 if !align.is_power_of_two() {\n                     return err!(HeapAllocNonPowerOfTwoAlignment(align));\n                 }\n@@ -209,10 +209,10 @@ pub trait EvalContextExt<'a, 'mir, 'tcx: 'a+'mir>: crate::MiriEvalContextExt<'a,\n             }\n \n             \"syscall\" => {\n-                // TODO: read `syscall` ids like `sysconf` ids and\n-                // figure out some way to actually process some of them\n+                // TODO: read `syscall` IDs like `sysconf` IDs and\n+                // figure out some way to actually process some of them.\n                 //\n-                // libc::syscall(NR_GETRANDOM, buf.as_mut_ptr(), buf.len(), GRND_NONBLOCK)\n+                // `libc::syscall(NR_GETRANDOM, buf.as_mut_ptr(), buf.len(), GRND_NONBLOCK)`\n                 // is called if a `HashMap` is created the regular way.\n                 match this.read_scalar(args[0])?.to_usize(this)? {\n                     318 | 511 => {\n@@ -222,7 +222,7 @@ pub trait EvalContextExt<'a, 'mir, 'tcx: 'a+'mir>: crate::MiriEvalContextExt<'a,\n                     }\n                     id => {\n                         return err!(Unimplemented(\n-                            format!(\"miri does not support syscall id {}\", id),\n+                            format!(\"miri does not support syscall ID {}\", id),\n                         ))\n                     }\n                 }\n@@ -241,24 +241,31 @@ pub trait EvalContextExt<'a, 'mir, 'tcx: 'a+'mir>: crate::MiriEvalContextExt<'a,\n             }\n \n             \"__rust_maybe_catch_panic\" => {\n-                // fn __rust_maybe_catch_panic(f: fn(*mut u8), data: *mut u8, data_ptr: *mut usize, vtable_ptr: *mut usize) -> u32\n-                // We abort on panic, so not much is going on here, but we still have to call the closure\n+                // fn __rust_maybe_catch_panic(\n+                //     f: fn(*mut u8),\n+                //     data: *mut u8,\n+                //     data_ptr: *mut usize,\n+                //     vtable_ptr: *mut usize,\n+                // ) -> u32\n+                // We abort on panic, so not much is going on here, but we still have to call the closure.\n                 let f = this.read_scalar(args[0])?.to_ptr()?;\n                 let data = this.read_scalar(args[1])?.not_undef()?;\n                 let f_instance = this.memory().get_fn(f)?;\n                 this.write_null(dest)?;\n                 trace!(\"__rust_maybe_catch_panic: {:?}\", f_instance);\n \n-                // Now we make a function call.  TODO: Consider making this re-usable?  EvalContext::step does sth. similar for the TLS dtors,\n-                // and of course eval_main.\n+                // Now we make a function call.\n+                // TODO: consider making this reusable? `EvalContext::step` does something similar\n+                // for the TLS destructors, and of course `eval_main`.\n                 let mir = this.load_mir(f_instance.def)?;\n                 let ret_place = MPlaceTy::dangling(this.layout_of(this.tcx.mk_unit())?, this).into();\n                 this.push_stack_frame(\n                     f_instance,\n                     mir.span,\n                     mir,\n                     Some(ret_place),\n-                    StackPopCleanup::Goto(Some(ret)), // directly return to caller\n+                    // Directly return to caller.\n+                    StackPopCleanup::Goto(Some(ret)),\n                 )?;\n                 let mut args = this.frame().mir.args_iter();\n \n@@ -273,10 +280,10 @@ pub trait EvalContextExt<'a, 'mir, 'tcx: 'a+'mir>: crate::MiriEvalContextExt<'a,\n \n                 assert!(args.next().is_none(), \"__rust_maybe_catch_panic argument has more arguments than expected\");\n \n-                // We ourselves will return 0, eventually (because we will not return if we paniced)\n+                // We ourselves will return `0`, eventually (because we will not return if we paniced).\n                 this.write_null(dest)?;\n \n-                // Don't fall through, we do NOT want to `goto_block`!\n+                // Don't fall through, we do *not* want to `goto_block`!\n                 return Ok(());\n             }\n \n@@ -321,10 +328,12 @@ pub trait EvalContextExt<'a, 'mir, 'tcx: 'a+'mir>: crate::MiriEvalContextExt<'a,\n                 let ptr = this.read_scalar(args[0])?.not_undef()?;\n                 let val = this.read_scalar(args[1])?.to_i32()? as u8;\n                 let num = this.read_scalar(args[2])?.to_usize(this)?;\n-                if let Some(idx) = this.memory().read_bytes(ptr, Size::from_bytes(num))?.iter().position(\n-                    |&c| c == val,\n-                )\n-                {\n+                let idx = this\n+                    .memory()\n+                    .read_bytes(ptr, Size::from_bytes(num))?\n+                    .iter()\n+                    .position(|&c| c == val);\n+                if let Some(idx) = idx {\n                     let new_ptr = ptr.ptr_offset(Size::from_bytes(idx as u64), this)?;\n                     this.write_scalar(new_ptr, dest)?;\n                 } else {\n@@ -350,7 +359,11 @@ pub trait EvalContextExt<'a, 'mir, 'tcx: 'a+'mir>: crate::MiriEvalContextExt<'a,\n                     let name_ptr = this.read_scalar(args[0])?.not_undef()?;\n                     if !name_ptr.is_null_ptr(this) {\n                         let name_ptr = name_ptr.to_ptr()?;\n-                        let name = this.memory().get(name_ptr.alloc_id)?.read_c_str(tcx, name_ptr)?.to_owned();\n+                        let name = this\n+                            .memory()\n+                            .get(name_ptr.alloc_id)?\n+                            .read_c_str(tcx, name_ptr)?\n+                            .to_owned();\n                         if !name.is_empty() && !name.contains(&b'=') {\n                             success = Some(this.machine.env_vars.remove(&name));\n                         }\n@@ -381,7 +394,7 @@ pub trait EvalContextExt<'a, 'mir, 'tcx: 'a+'mir>: crate::MiriEvalContextExt<'a,\n                     }\n                 }\n                 if let Some((name, value)) = new {\n-                    // +1 for the null terminator\n+                    // `+1` for the null terminator.\n                     let value_copy = this.memory_mut().allocate(\n                         Size::from_bytes((value.len() + 1) as u64),\n                         Align::from_bytes(1).unwrap(),\n@@ -390,7 +403,10 @@ pub trait EvalContextExt<'a, 'mir, 'tcx: 'a+'mir>: crate::MiriEvalContextExt<'a,\n                     {\n                         let alloc = this.memory_mut().get_mut(value_copy.alloc_id)?;\n                         alloc.write_bytes(tcx, value_copy, &value)?;\n-                        let trailing_zero_ptr = value_copy.offset(Size::from_bytes(value.len() as u64), tcx)?;\n+                        let trailing_zero_ptr = value_copy.offset(\n+                            Size::from_bytes(value.len() as u64),\n+                            tcx,\n+                        )?;\n                         alloc.write_bytes(tcx, trailing_zero_ptr, &[0])?;\n                     }\n                     if let Some(var) = this.machine.env_vars.insert(\n@@ -435,8 +451,10 @@ pub trait EvalContextExt<'a, 'mir, 'tcx: 'a+'mir>: crate::MiriEvalContextExt<'a,\n                     }\n                 } else {\n                     eprintln!(\"Miri: Ignored output to FD {}\", fd);\n-                    n as i64 // pretend it all went well\n-                }; // now result is the value we return back to the program\n+                    // Pretend it all went well.\n+                    n as i64\n+                };\n+                // Now, `result` is the value we return back to the program.\n                 this.write_scalar(\n                     Scalar::from_int(result, dest.layout.size),\n                     dest,\n@@ -449,7 +467,7 @@ pub trait EvalContextExt<'a, 'mir, 'tcx: 'a+'mir>: crate::MiriEvalContextExt<'a,\n                 this.write_scalar(Scalar::from_uint(n as u64, dest.layout.size), dest)?;\n             }\n \n-            // Some things needed for sys::thread initialization to go through\n+            // Some things needed for `sys::thread` initialization to go through.\n             \"signal\" | \"sigaction\" | \"sigaltstack\" => {\n                 this.write_scalar(Scalar::from_int(0, dest.layout.size), dest)?;\n             }\n@@ -458,7 +476,7 @@ pub trait EvalContextExt<'a, 'mir, 'tcx: 'a+'mir>: crate::MiriEvalContextExt<'a,\n                 let name = this.read_scalar(args[0])?.to_i32()?;\n \n                 trace!(\"sysconf() called with name {}\", name);\n-                // cache the sysconf integers via miri's global cache\n+                // Cache the sysconf integers via Miri's global cache.\n                 let paths = &[\n                     (&[\"libc\", \"_SC_PAGESIZE\"], Scalar::from_int(4096, dest.layout.size)),\n                     (&[\"libc\", \"_SC_GETPW_R_SIZE_MAX\"], Scalar::from_int(-1, dest.layout.size)),\n@@ -493,11 +511,11 @@ pub trait EvalContextExt<'a, 'mir, 'tcx: 'a+'mir>: crate::MiriEvalContextExt<'a,\n                 this.write_null(dest)?;\n             }\n \n-            // Hook pthread calls that go to the thread-local storage memory subsystem\n+            // Hook pthread calls that go to the thread-local storage memory subsystem.\n             \"pthread_key_create\" => {\n                 let key_ptr = this.read_scalar(args[0])?.to_ptr()?;\n \n-                // Extract the function type out of the signature (that seems easier than constructing it ourselves...)\n+                // Extract the function type out of the signature (that seems easier than constructing it ourselves).\n                 let dtor = match this.read_scalar(args[1])?.not_undef()? {\n                     Scalar::Ptr(dtor_ptr) => Some(this.memory().get_fn(dtor_ptr)?),\n                     Scalar::Bits { bits: 0, size } => {\n@@ -507,12 +525,15 @@ pub trait EvalContextExt<'a, 'mir, 'tcx: 'a+'mir>: crate::MiriEvalContextExt<'a,\n                     Scalar::Bits { .. } => return err!(ReadBytesAsPointer),\n                 };\n \n-                // Figure out how large a pthread TLS key actually is. This is libc::pthread_key_t.\n-                let key_type = args[0].layout.ty.builtin_deref(true)\n-                                   .ok_or_else(|| EvalErrorKind::AbiViolation(\"Wrong signature used for pthread_key_create: First argument must be a raw pointer.\".to_owned()))?.ty;\n+                // Figure out how large a pthread TLS key actually is.\n+                // This is `libc::pthread_key_t`.\n+                let key_type = args[0].layout.ty\n+                    .builtin_deref(true)\n+                    .ok_or_else(|| EvalErrorKind::AbiViolation(\"wrong signature used for `pthread_key_create`: first argument must be a raw pointer.\".to_owned()))?\n+                    .ty;\n                 let key_layout = this.layout_of(key_type)?;\n \n-                // Create key and write it into the memory where key_ptr wants it\n+                // Create key and write it into the memory where `key_ptr` wants it.\n                 let key = this.machine.tls.create_tls_key(dtor, tcx) as u128;\n                 if key_layout.size.bits() < 128 && key >= (1u128 << key_layout.size.bits() as u128) {\n                     return err!(OutOfTls);\n@@ -526,7 +547,7 @@ pub trait EvalContextExt<'a, 'mir, 'tcx: 'a+'mir>: crate::MiriEvalContextExt<'a,\n                     key_layout.size,\n                 )?;\n \n-                // Return success (0)\n+                // Return success (`0`).\n                 this.write_null(dest)?;\n             }\n             \"pthread_key_delete\" => {\n@@ -545,29 +566,31 @@ pub trait EvalContextExt<'a, 'mir, 'tcx: 'a+'mir>: crate::MiriEvalContextExt<'a,\n                 let new_ptr = this.read_scalar(args[1])?.not_undef()?;\n                 this.machine.tls.store_tls(key, new_ptr)?;\n \n-                // Return success (0)\n+                // Return success (`0`).\n                 this.write_null(dest)?;\n             }\n \n-            // Determining stack base address\n+            // Determine stack base address.\n             \"pthread_attr_init\" | \"pthread_attr_destroy\" | \"pthread_attr_get_np\" |\n             \"pthread_getattr_np\" | \"pthread_self\" | \"pthread_get_stacksize_np\" => {\n                 this.write_null(dest)?;\n             }\n             \"pthread_attr_getstack\" => {\n-                // second argument is where we are supposed to write the stack size\n+                // Second argument is where we are supposed to write the stack size.\n                 let ptr = this.deref_operand(args[1])?;\n-                let stackaddr = Scalar::from_int(0x80000, args[1].layout.size); // just any address\n-                this.write_scalar(stackaddr, ptr.into())?;\n-                // return 0\n+                // Just any address.\n+                let stack_addr = Scalar::from_int(0x80000, args[1].layout.size);\n+                this.write_scalar(stack_addr, ptr.into())?;\n+                // Return success (`0`).\n                 this.write_null(dest)?;\n             }\n             \"pthread_get_stackaddr_np\" => {\n-                let stackaddr = Scalar::from_int(0x80000, dest.layout.size); // just any address\n-                this.write_scalar(stackaddr, dest)?;\n+                // Just any address.\n+                let stack_addr = Scalar::from_int(0x80000, dest.layout.size);\n+                this.write_scalar(stack_addr, dest)?;\n             }\n \n-            // Stub out calls for condvar, mutex and rwlock to just return 0\n+            // Stub out calls for condvar, mutex and rwlock, to just return `0`.\n             \"pthread_mutexattr_init\" | \"pthread_mutexattr_settype\" | \"pthread_mutex_init\" |\n             \"pthread_mutexattr_destroy\" | \"pthread_mutex_lock\" | \"pthread_mutex_unlock\" |\n             \"pthread_mutex_destroy\" | \"pthread_rwlock_rdlock\" | \"pthread_rwlock_unlock\" |\n@@ -578,17 +601,17 @@ pub trait EvalContextExt<'a, 'mir, 'tcx: 'a+'mir>: crate::MiriEvalContextExt<'a,\n             }\n \n             \"mmap\" => {\n-                // This is a horrible hack, but well... the guard page mechanism calls mmap and expects a particular return value, so we give it that value\n+                // This is a horrible hack, but since the guard page mechanism calls mmap and expects a particular return value, we just give it that value.\n                 let addr = this.read_scalar(args[0])?.not_undef()?;\n                 this.write_scalar(addr, dest)?;\n             }\n             \"mprotect\" => {\n                 this.write_null(dest)?;\n             }\n \n-            // macOS API stubs\n+            // macOS API stubs.\n             \"_tlv_atexit\" => {\n-                // FIXME: Register the dtor\n+                // FIXME: register the destructor.\n             },\n             \"_NSGetArgc\" => {\n                 this.write_scalar(Scalar::Ptr(this.machine.argc.unwrap()), dest)?;\n@@ -597,7 +620,7 @@ pub trait EvalContextExt<'a, 'mir, 'tcx: 'a+'mir>: crate::MiriEvalContextExt<'a,\n                 this.write_scalar(Scalar::Ptr(this.machine.argv.unwrap()), dest)?;\n             },\n \n-            // Windows API stubs\n+            // Windows API stubs.\n             \"SetLastError\" => {\n                 let err = this.read_scalar(args[0])?.to_u32()?;\n                 this.machine.last_error = err;\n@@ -607,30 +630,30 @@ pub trait EvalContextExt<'a, 'mir, 'tcx: 'a+'mir>: crate::MiriEvalContextExt<'a,\n             }\n \n             \"AddVectoredExceptionHandler\" => {\n-                // any non zero value works for the stdlib. This is just used for stackoverflows anyway\n+                // Any non zero value works for the stdlib. This is just used for stack overflows anyway.\n                 this.write_scalar(Scalar::from_int(1, dest.layout.size), dest)?;\n             },\n             \"InitializeCriticalSection\" |\n             \"EnterCriticalSection\" |\n             \"LeaveCriticalSection\" |\n             \"DeleteCriticalSection\" => {\n-                // Nothing to do, not even a return value\n+                // Nothing to do, not even a return value.\n             },\n             \"GetModuleHandleW\" |\n             \"GetProcAddress\" |\n             \"TryEnterCriticalSection\" |\n             \"GetConsoleScreenBufferInfo\" |\n             \"SetConsoleTextAttribute\" => {\n-                // pretend these do not exist/nothing happened, by returning zero\n+                // Pretend these do not exist / nothing happened, by returning zero.\n                 this.write_null(dest)?;\n             },\n             \"GetSystemInfo\" => {\n                 let system_info = this.deref_operand(args[0])?;\n                 let system_info_ptr = system_info.ptr.to_ptr()?;\n-                // initialize with 0\n+                // Initialize with `0`.\n                 this.memory_mut().get_mut(system_info_ptr.alloc_id)?\n                     .write_repeat(tcx, system_info_ptr, 0, system_info.layout.size)?;\n-                // set number of processors to 1\n+                // Set number of processors to `1`.\n                 let dword_size = Size::from_bytes(4);\n                 let offset = 2*dword_size + 3*tcx.pointer_size();\n                 this.memory_mut().get_mut(system_info_ptr.alloc_id)?\n@@ -643,13 +666,14 @@ pub trait EvalContextExt<'a, 'mir, 'tcx: 'a+'mir>: crate::MiriEvalContextExt<'a,\n             }\n \n             \"TlsAlloc\" => {\n-                // This just creates a key; Windows does not natively support TLS dtors.\n+                // This just creates a key; Windows does not natively support TLS destructors.\n \n-                // Create key and return it\n+                // Create key and return it.\n                 let key = this.machine.tls.create_tls_key(None, tcx) as u128;\n \n-                // Figure out how large a TLS key actually is. This is c::DWORD.\n-                if dest.layout.size.bits() < 128 && key >= (1u128 << dest.layout.size.bits() as u128) {\n+                // Figure out how large a TLS key actually is. This is `c::DWORD`.\n+                if dest.layout.size.bits() < 128\n+                        && key >= (1u128 << dest.layout.size.bits() as u128) {\n                     return err!(OutOfTls);\n                 }\n                 this.write_scalar(Scalar::from_uint(key, dest.layout.size), dest)?;\n@@ -664,12 +688,12 @@ pub trait EvalContextExt<'a, 'mir, 'tcx: 'a+'mir>: crate::MiriEvalContextExt<'a,\n                 let new_ptr = this.read_scalar(args[1])?.not_undef()?;\n                 this.machine.tls.store_tls(key, new_ptr)?;\n \n-                // Return success (1)\n+                // Return success (`1`).\n                 this.write_scalar(Scalar::from_int(1, dest.layout.size), dest)?;\n             }\n             \"GetStdHandle\" => {\n                 let which = this.read_scalar(args[0])?.to_i32()?;\n-                // We just make this the identity function, so we know later in \"WriteFile\"\n+                // We just make this the identity function, so we know later in `WriteFile`\n                 // which one it is.\n                 this.write_scalar(Scalar::from_int(which, this.pointer_size()), dest)?;\n             }\n@@ -678,7 +702,8 @@ pub trait EvalContextExt<'a, 'mir, 'tcx: 'a+'mir>: crate::MiriEvalContextExt<'a,\n                 let buf = this.read_scalar(args[1])?.not_undef()?;\n                 let n = this.read_scalar(args[2])?.to_u32()?;\n                 let written_place = this.deref_operand(args[3])?;\n-                this.write_null(written_place.into())?; // spec says we always write 0 first\n+                // Spec says to always write `0` first.\n+                this.write_null(written_place.into())?;\n                 let written = if handle == -11 || handle == -12 {\n                     // stdout/stderr\n                     use std::io::{self, Write};\n@@ -692,32 +717,33 @@ pub trait EvalContextExt<'a, 'mir, 'tcx: 'a+'mir>: crate::MiriEvalContextExt<'a,\n                     res.ok().map(|n| n as u32)\n                 } else {\n                     eprintln!(\"Miri: Ignored output to handle {}\", handle);\n-                    Some(n) // pretend it all went well\n+                    // Pretend it all went well.\n+                    Some(n)\n                 };\n-                // If there was no error, write back how much was written\n+                // If there was no error, write back how much was written.\n                 if let Some(n) = written {\n                     this.write_scalar(Scalar::from_uint(n, Size::from_bits(32)), written_place.into())?;\n                 }\n-                // Return whether this was a success\n+                // Return whether this was a success.\n                 this.write_scalar(\n                     Scalar::from_int(if written.is_some() { 1 } else { 0 }, dest.layout.size),\n                     dest,\n                 )?;\n             }\n             \"GetConsoleMode\" => {\n-                // Everything is a pipe\n+                // Everything is a pipe.\n                 this.write_null(dest)?;\n             }\n             \"GetEnvironmentVariableW\" => {\n-                // This is not the env var you are looking for\n+                // This is not the env var you are looking for.\n                 this.machine.last_error = 203; // ERROR_ENVVAR_NOT_FOUND\n                 this.write_null(dest)?;\n             }\n             \"GetCommandLineW\" => {\n                 this.write_scalar(Scalar::Ptr(this.machine.cmd_line.unwrap()), dest)?;\n             }\n \n-            // We can't execute anything else\n+            // We can't execute anything else.\n             _ => {\n                 return err!(Unimplemented(\n                     format!(\"can't call foreign function: {}\", link_name),"}, {"sha": "cdef224b3e990e58649ac50340503fa627b2c92a", "filename": "src/helpers.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/12d3ecbaff9e7b627e79404fa21e2a52278e1368/src%2Fhelpers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12d3ecbaff9e7b627e79404fa21e2a52278e1368/src%2Fhelpers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fhelpers.rs?ref=12d3ecbaff9e7b627e79404fa21e2a52278e1368", "patch": "@@ -6,8 +6,9 @@ use rustc::hir::def_id::{DefId, CRATE_DEF_INDEX};\n use crate::*;\n \n impl<'a, 'mir, 'tcx> EvalContextExt<'a, 'mir, 'tcx> for crate::MiriEvalContext<'a, 'mir, 'tcx> {}\n-pub trait EvalContextExt<'a, 'mir, 'tcx: 'a+'mir>: crate::MiriEvalContextExt<'a, 'mir, 'tcx> {\n-    /// Get an instance for a path.\n+\n+pub trait EvalContextExt<'a, 'mir, 'tcx: 'a + 'mir>: crate::MiriEvalContextExt<'a, 'mir, 'tcx> {\n+    /// Gets an instance for a path.\n     fn resolve_path(&self, path: &[&str]) -> EvalResult<'tcx, ty::Instance<'tcx>> {\n         let this = self.eval_context_ref();\n         this.tcx\n@@ -42,7 +43,7 @@ pub trait EvalContextExt<'a, 'mir, 'tcx: 'a+'mir>: crate::MiriEvalContextExt<'a,\n             })\n     }\n \n-    /// Visit the memory covered by `place`, sensitive to freezing:  The 3rd parameter\n+    /// Visits the memory covered by `place`, sensitive to freezing: the 3rd parameter\n     /// will be true if this is frozen, false if this is in an `UnsafeCell`.\n     fn visit_freeze_sensitive(\n         &self,\n@@ -57,7 +58,7 @@ pub trait EvalContextExt<'a, 'mir, 'tcx: 'a+'mir>: crate::MiriEvalContextExt<'a,\n             .map(|(size, _)| size)\n             .unwrap_or_else(|| place.layout.size)\n         );\n-        // Store how far we proceeded into the place so far.  Everything to the left of\n+        // Store how far we proceeded into the place so far. Everything to the left of\n         // this offset has already been handled, in the sense that the frozen parts\n         // have had `action` called on them.\n         let mut end_ptr = place.ptr;\n@@ -139,7 +140,7 @@ pub trait EvalContextExt<'a, 'mir, 'tcx: 'a+'mir>: crate::MiriEvalContextExt<'a,\n                 &self.ecx\n             }\n \n-            // Hook to detect `UnsafeCell`\n+            // Hook to detect `UnsafeCell`.\n             fn visit_value(&mut self, v: MPlaceTy<'tcx, Borrow>) -> EvalResult<'tcx>\n             {\n                 trace!(\"UnsafeCellVisitor: {:?} {:?}\", *v, v.layout.ty);\n@@ -159,7 +160,7 @@ pub trait EvalContextExt<'a, 'mir, 'tcx: 'a+'mir>: crate::MiriEvalContextExt<'a,\n                 }\n             }\n \n-            // Make sure we visit aggregrates in increasing offset order\n+            // Make sure we visit aggregrates in increasing offset order.\n             fn visit_aggregate(\n                 &mut self,\n                 place: MPlaceTy<'tcx, Borrow>,\n@@ -179,17 +180,17 @@ pub trait EvalContextExt<'a, 'mir, 'tcx: 'a+'mir>: crate::MiriEvalContextExt<'a,\n                     }\n                     layout::FieldPlacement::Union { .. } => {\n                         // Uh, what?\n-                        bug!(\"A union is not an aggregate we should ever visit\")\n+                        bug!(\"a union is not an aggregate we should ever visit\")\n                     }\n                 }\n             }\n \n-            // We have to do *something* for unions\n+            // We have to do *something* for unions.\n             fn visit_union(&mut self, v: MPlaceTy<'tcx, Borrow>) -> EvalResult<'tcx>\n             {\n                 // With unions, we fall back to whatever the type says, to hopefully be consistent\n                 // with LLVM IR.\n-                // FIXME Are we consistent?  And is this really the behavior we want?\n+                // FIXME: are we consistent, and is this really the behavior we want?\n                 let frozen = self.ecx.type_is_freeze(v.layout.ty);\n                 if frozen {\n                     Ok(())\n@@ -198,10 +199,10 @@ pub trait EvalContextExt<'a, 'mir, 'tcx: 'a+'mir>: crate::MiriEvalContextExt<'a,\n                 }\n             }\n \n-            // We should never get to a primitive, but always short-circuit somewhere above\n+            // We should never get to a primitive, but always short-circuit somewhere above.\n             fn visit_primitive(&mut self, _v: MPlaceTy<'tcx, Borrow>) -> EvalResult<'tcx>\n             {\n-                bug!(\"We should always short-circit before coming to a primitive\")\n+                bug!(\"we should always short-circuit before coming to a primitive\")\n             }\n         }\n     }"}, {"sha": "70880c4f7da82cfbd46aeddfeeb377b50f6936fe", "filename": "src/intrinsic.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/12d3ecbaff9e7b627e79404fa21e2a52278e1368/src%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12d3ecbaff9e7b627e79404fa21e2a52278e1368/src%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsic.rs?ref=12d3ecbaff9e7b627e79404fa21e2a52278e1368", "patch": "@@ -1,9 +1,8 @@\n use rustc::mir;\n+use rustc::mir::interpret::{EvalResult, PointerArithmetic};\n use rustc::ty::layout::{self, LayoutOf, Size};\n use rustc::ty;\n \n-use rustc::mir::interpret::{EvalResult, PointerArithmetic};\n-\n use crate::{\n     PlaceTy, OpTy, ImmTy, Immediate, Scalar, ScalarMaybeUndef, Borrow,\n     OperatorEvalContextExt\n@@ -268,7 +267,7 @@ pub trait EvalContextExt<'a, 'mir, 'tcx: 'a+'mir>: crate::MiriEvalContextExt<'a,\n                 // However, this only affects direct calls of the intrinsic; calls to the stable\n                 // functions wrapping them do get their validation.\n                 // FIXME: should we check that the destination pointer is aligned even for ZSTs?\n-                if !dest.layout.is_zst() { // nothing to do for ZST\n+                if !dest.layout.is_zst() {\n                     match dest.layout.abi {\n                         layout::Abi::Scalar(ref s) => {\n                             let x = Scalar::from_int(0, s.value.size(this));\n@@ -443,7 +442,7 @@ pub trait EvalContextExt<'a, 'mir, 'tcx: 'a+'mir>: crate::MiriEvalContextExt<'a,\n                 // However, this only affects direct calls of the intrinsic; calls to the stable\n                 // functions wrapping them do get their validation.\n                 // FIXME: should we check alignment for ZSTs?\n-                if !dest.layout.is_zst() { // nothing to do for ZST\n+                if !dest.layout.is_zst() {\n                     match dest.layout.abi {\n                         layout::Abi::Scalar(..) => {\n                             let x = ScalarMaybeUndef::Undef;"}, {"sha": "df118ea09828f5011386fc3182c580a4dc26d4fc", "filename": "src/lib.rs", "status": "modified", "additions": 70, "deletions": 66, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/12d3ecbaff9e7b627e79404fa21e2a52278e1368/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12d3ecbaff9e7b627e79404fa21e2a52278e1368/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=12d3ecbaff9e7b627e79404fa21e2a52278e1368", "patch": "@@ -4,7 +4,6 @@\n \n #[macro_use]\n extern crate log;\n-\n // From rustc.\n extern crate syntax;\n #[macro_use]\n@@ -13,58 +12,58 @@ extern crate rustc_data_structures;\n extern crate rustc_mir;\n extern crate rustc_target;\n \n+mod fn_call;\n+mod operator;\n+mod intrinsic;\n+mod helpers;\n+mod tls;\n+mod range_map;\n+mod mono_hash_map;\n+mod stacked_borrows;\n+\n use std::collections::HashMap;\n use std::borrow::Cow;\n \n use rustc::ty::{self, TyCtxt, query::TyCtxtAt};\n use rustc::ty::layout::{LayoutOf, Size, Align};\n use rustc::hir::{self, def_id::DefId};\n use rustc::mir;\n-\n+pub use rustc_mir::interpret::*;\n+// Resolve ambiguity.\n+pub use rustc_mir::interpret::{self, AllocMap, PlaceTy};\n use syntax::attr;\n use syntax::source_map::DUMMY_SP;\n \n-pub use rustc_mir::interpret::*;\n-pub use rustc_mir::interpret::{self, AllocMap, PlaceTy}; // resolve ambiguity\n-\n-mod fn_call;\n-mod operator;\n-mod intrinsic;\n-mod helpers;\n-mod tls;\n-mod range_map;\n-mod mono_hash_map;\n-mod stacked_borrows;\n-\n pub use crate::fn_call::EvalContextExt as MissingFnsEvalContextExt;\n pub use crate::operator::EvalContextExt as OperatorEvalContextExt;\n pub use crate::intrinsic::EvalContextExt as IntrinsicEvalContextExt;\n pub use crate::tls::{EvalContextExt as TlsEvalContextExt, TlsData};\n use crate::range_map::RangeMap;\n-#[allow(unused_imports)] // FIXME rustc bug https://github.com/rust-lang/rust/issues/53682\n+// FIXME: rustc bug, issue <https://github.com/rust-lang/rust/issues/53682>.\n+#[allow(unused_imports)]\n pub use crate::helpers::{EvalContextExt as HelpersEvalContextExt};\n use crate::mono_hash_map::MonoHashMap;\n pub use crate::stacked_borrows::{EvalContextExt as StackedBorEvalContextExt};\n \n-// Used by priroda\n+// Used by priroda.\n pub use crate::stacked_borrows::{Borrow, Stack, Stacks, BorStackItem};\n \n-/// Insert rustc arguments at the beginning of the argument list that miri wants to be\n+/// Insert rustc arguments at the beginning of the argument list that Miri wants to be\n /// set per default, for maximal validation power.\n pub fn miri_default_args() -> &'static [&'static str] {\n     // The flags here should be kept in sync with what bootstrap adds when `test-miri` is\n     // set, which happens in `bootstrap/bin/rustc.rs` in the rustc sources.\n     &[\"-Zalways-encode-mir\", \"-Zmir-emit-retag\", \"-Zmir-opt-level=0\", \"--cfg=miri\"]\n }\n \n-/// Configuration needed to spawn a Miri instance\n+/// Configuration needed to spawn a Miri instance.\n #[derive(Clone)]\n pub struct MiriConfig {\n     pub validate: bool,\n     pub args: Vec<String>,\n }\n \n-// Used by priroda\n+// Used by priroda.\n pub fn create_ecx<'a, 'mir: 'a, 'tcx: 'mir>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     main_id: DefId,\n@@ -105,53 +104,55 @@ pub fn create_ecx<'a, 'mir: 'a, 'tcx: 'mir>(\n         )));\n     }\n \n-    // Return value (in static memory so that it does not count as leak)\n+    // Return value (in static memory so that it does not count as leak).\n     let ret = ecx.layout_of(start_mir.return_ty())?;\n     let ret_ptr = ecx.allocate(ret, MiriMemoryKind::MutStatic.into());\n \n-    // Push our stack frame\n+    // Push our stack frame.\n     ecx.push_stack_frame(\n         start_instance,\n-        DUMMY_SP, // there is no call site, we want no span\n+        // There is no call site.\n+        DUMMY_SP,\n         start_mir,\n         Some(ret_ptr.into()),\n         StackPopCleanup::None { cleanup: true },\n     )?;\n \n     let mut args = ecx.frame().mir.args_iter();\n \n-    // First argument: pointer to main()\n+    // First argument: pointer to `main()`.\n     let main_ptr = ecx.memory_mut().create_fn_alloc(main_instance).with_default_tag();\n     let dest = ecx.eval_place(&mir::Place::Local(args.next().unwrap()))?;\n     ecx.write_scalar(Scalar::Ptr(main_ptr), dest)?;\n \n-    // Second argument (argc): 1\n+    // Second argument (argc): `1`.\n     let dest = ecx.eval_place(&mir::Place::Local(args.next().unwrap()))?;\n     let argc = Scalar::from_uint(config.args.len() as u128, dest.layout.size);\n     ecx.write_scalar(argc, dest)?;\n-    // Store argc for macOS _NSGetArgc\n+    // Store argc for macOS: `_NSGetArgc`.\n     {\n         let argc_place = ecx.allocate(dest.layout, MiriMemoryKind::Env.into());\n         ecx.write_scalar(argc, argc_place.into())?;\n         ecx.machine.argc = Some(argc_place.ptr.to_ptr()?);\n     }\n \n-    // FIXME: extract main source file path\n-    // Third argument (argv): Created from config.args\n+    // FIXME: extract main source file path.\n+    // Third argument (`argv`): created from `config.args`.\n     let dest = ecx.eval_place(&mir::Place::Local(args.next().unwrap()))?;\n-    // For Windows, construct a command string with all the aguments\n+    // For Windows, construct a command string with all the aguments.\n     let mut cmd = String::new();\n     for arg in config.args.iter() {\n         if !cmd.is_empty() {\n             cmd.push(' ');\n         }\n         cmd.push_str(&*shell_escape::windows::escape(arg.as_str().into()));\n     }\n-    cmd.push(std::char::from_u32(0).unwrap()); // don't forget 0 terminator\n+    // Don't forget `0` terminator.\n+    cmd.push(std::char::from_u32(0).unwrap());\n     // Collect the pointers to the individual strings.\n     let mut argvs = Vec::<Pointer<Borrow>>::new();\n     for arg in config.args {\n-        // Add 0 terminator\n+        // Add `0` terminator.\n         let mut arg = arg.into_bytes();\n         arg.push(0);\n         argvs.push(ecx.memory_mut().allocate_static_bytes(arg.as_slice()).with_default_tag());\n@@ -164,16 +165,16 @@ pub fn create_ecx<'a, 'mir: 'a, 'tcx: 'mir>(\n         ecx.write_scalar(Scalar::Ptr(arg), place.into())?;\n     }\n     ecx.memory_mut().mark_immutable(argvs_place.to_ptr()?.alloc_id)?;\n-    // Write a pointe to that place as the argument.\n+    // Write a pointer to that place as the argument.\n     let argv = argvs_place.ptr;\n     ecx.write_scalar(argv, dest)?;\n-    // Store argv for macOS _NSGetArgv\n+    // Store `argv` for macOS `_NSGetArgv`.\n     {\n         let argv_place = ecx.allocate(dest.layout, MiriMemoryKind::Env.into());\n         ecx.write_scalar(argv, argv_place.into())?;\n         ecx.machine.argv = Some(argv_place.ptr.to_ptr()?);\n     }\n-    // Store cmdline as UTF-16 for Windows GetCommandLineW\n+    // Store command line as UTF-16 for Windows `GetCommandLineW`.\n     {\n         let tcx = &{ecx.tcx.tcx};\n         let cmd_utf16: Vec<u16> = cmd.encode_utf16().collect();\n@@ -183,7 +184,7 @@ pub fn create_ecx<'a, 'mir: 'a, 'tcx: 'mir>(\n             MiriMemoryKind::Env.into(),\n         ).with_default_tag();\n         ecx.machine.cmd_line = Some(cmd_ptr);\n-        // store the UTF-16 string\n+        // Store the UTF-16 string.\n         let char_size = Size::from_bytes(2);\n         let cmd_alloc = ecx.memory_mut().get_mut(cmd_ptr.alloc_id)?;\n         let mut cur_ptr = cmd_ptr;\n@@ -208,9 +209,9 @@ pub fn eval_main<'a, 'tcx: 'a>(\n     main_id: DefId,\n     config: MiriConfig,\n ) {\n-    let mut ecx = create_ecx(tcx, main_id, config).expect(\"Couldn't create ecx\");\n+    let mut ecx = create_ecx(tcx, main_id, config).expect(\"couldn't create ecx\");\n \n-    // Run! The main execution.\n+    // Perform the main execution.\n     let res: EvalResult = (|| {\n         ecx.run()?;\n         ecx.run_tls_dtors()\n@@ -243,7 +244,7 @@ pub fn eval_main<'a, 'tcx: 'a>(\n                 let mut err = struct_error(ecx.tcx.tcx.at(span), msg.as_str());\n                 let frames = ecx.generate_stacktrace(None);\n                 err.span_label(span, e);\n-                // we iterate with indices because we need to look at the next frame (the caller)\n+                // We iterate with indices because we need to look at the next frame (the caller).\n                 for idx in 0..frames.len() {\n                     let frame_info = &frames[idx];\n                     let call_site_is_local = frames.get(idx+1).map_or(false,\n@@ -273,16 +274,15 @@ pub fn eval_main<'a, 'tcx: 'a>(\n     }\n }\n \n-\n #[derive(Debug, Copy, Clone, PartialEq, Eq)]\n pub enum MiriMemoryKind {\n-    /// `__rust_alloc` memory\n+    /// `__rust_alloc` memory.\n     Rust,\n-    /// `malloc` memory\n+    /// `malloc` memory.\n     C,\n-    /// Part of env var emulation\n+    /// Part of env var emulation.\n     Env,\n-    /// mutable statics\n+    /// Mutable statics.\n     MutStatic,\n }\n \n@@ -305,27 +305,27 @@ impl MayLeak for MiriMemoryKind {\n }\n \n pub struct Evaluator<'tcx> {\n-    /// Environment variables set by `setenv`\n-    /// Miri does not expose env vars from the host to the emulated program\n+    /// Environment variables set by `setenv`.\n+    /// Miri does not expose env vars from the host to the emulated program.\n     pub(crate) env_vars: HashMap<Vec<u8>, Pointer<Borrow>>,\n \n     /// Program arguments (`Option` because we can only initialize them after creating the ecx).\n     /// These are *pointers* to argc/argv because macOS.\n-    /// We also need the full cmdline as one string because Window.\n+    /// We also need the full command line as one string because of Windows.\n     pub(crate) argc: Option<Pointer<Borrow>>,\n     pub(crate) argv: Option<Pointer<Borrow>>,\n     pub(crate) cmd_line: Option<Pointer<Borrow>>,\n \n-    /// Last OS error\n+    /// Last OS error.\n     pub(crate) last_error: u32,\n \n-    /// TLS state\n+    /// TLS state.\n     pub(crate) tls: TlsData<'tcx>,\n \n-    /// Whether to enforce the validity invariant\n+    /// Whether to enforce the validity invariant.\n     pub(crate) validate: bool,\n \n-    /// Stacked Borrows state\n+    /// Stacked Borrows state.\n     pub(crate) stacked_borrows: stacked_borrows::State,\n }\n \n@@ -344,10 +344,11 @@ impl<'tcx> Evaluator<'tcx> {\n     }\n }\n \n-#[allow(dead_code)] // FIXME https://github.com/rust-lang/rust/issues/47131\n+// FIXME: rustc issue <https://github.com/rust-lang/rust/issues/47131>.\n+#[allow(dead_code)]\n type MiriEvalContext<'a, 'mir, 'tcx> = EvalContext<'a, 'mir, 'tcx, Evaluator<'tcx>>;\n \n-// A little trait that's useful to be inherited by extension traits\n+// A little trait that's useful to be inherited by extension traits.\n pub trait MiriEvalContextExt<'a, 'mir, 'tcx> {\n     fn eval_context_ref(&self) -> &MiriEvalContext<'a, 'mir, 'tcx>;\n     fn eval_context_mut(&mut self) -> &mut MiriEvalContext<'a, 'mir, 'tcx>;\n@@ -380,7 +381,7 @@ impl<'a, 'mir, 'tcx> Machine<'a, 'mir, 'tcx> for Evaluator<'tcx> {\n         ecx.machine.validate\n     }\n \n-    /// Returns Ok() when the function was handled, fail otherwise\n+    /// Returns `Ok()` when the function was handled; fail otherwise.\n     #[inline(always)]\n     fn find_fn(\n         ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n@@ -417,7 +418,7 @@ impl<'a, 'mir, 'tcx> Machine<'a, 'mir, 'tcx> for Evaluator<'tcx> {\n         dest: PlaceTy<'tcx, Borrow>,\n     ) -> EvalResult<'tcx> {\n         trace!(\"box_alloc for {:?}\", dest.layout.ty);\n-        // Call the `exchange_malloc` lang item\n+        // Call the `exchange_malloc` lang item.\n         let malloc = ecx.tcx.lang_items().exchange_malloc_fn().unwrap();\n         let malloc = ty::Instance::mono(ecx.tcx.tcx, malloc);\n         let malloc_mir = ecx.load_mir(malloc.def)?;\n@@ -426,28 +427,31 @@ impl<'a, 'mir, 'tcx> Machine<'a, 'mir, 'tcx> for Evaluator<'tcx> {\n             malloc_mir.span,\n             malloc_mir,\n             Some(dest),\n-            // Don't do anything when we are done.  The statement() function will increment\n+            // Don't do anything when we are done. The `statement()` function will increment\n             // the old stack frame's stmt counter to the next statement, which means that when\n-            // exchange_malloc returns, we go on evaluating exactly where we want to be.\n+            // `exchange_malloc` returns, we go on evaluating exactly where we want to be.\n             StackPopCleanup::None { cleanup: true },\n         )?;\n \n         let mut args = ecx.frame().mir.args_iter();\n         let layout = ecx.layout_of(dest.layout.ty.builtin_deref(false).unwrap().ty)?;\n \n-        // First argument: size\n-        // (0 is allowed here, this is expected to be handled by the lang item)\n+        // First argument: `size`.\n+        // (`0` is allowed here -- this is expected to be handled by the lang item).\n         let arg = ecx.eval_place(&mir::Place::Local(args.next().unwrap()))?;\n         let size = layout.size.bytes();\n         ecx.write_scalar(Scalar::from_uint(size, arg.layout.size), arg)?;\n \n-        // Second argument: align\n+        // Second argument: `align`.\n         let arg = ecx.eval_place(&mir::Place::Local(args.next().unwrap()))?;\n         let align = layout.align.abi.bytes();\n         ecx.write_scalar(Scalar::from_uint(align, arg.layout.size), arg)?;\n \n-        // No more arguments\n-        assert!(args.next().is_none(), \"exchange_malloc lang item has more arguments than expected\");\n+        // No more arguments.\n+        assert!(\n+            args.next().is_none(),\n+            \"`exchange_malloc` lang item has more arguments than expected\"\n+        );\n         Ok(())\n     }\n \n@@ -464,7 +468,7 @@ impl<'a, 'mir, 'tcx> Machine<'a, 'mir, 'tcx> for Evaluator<'tcx> {\n \n         let alloc = match &link_name[..] {\n             \"__cxa_thread_atexit_impl\" => {\n-                // This should be all-zero, pointer-sized\n+                // This should be all-zero, pointer-sized.\n                 let size = tcx.data_layout.pointer_size;\n                 let data = vec![0; size.bytes() as usize];\n                 let extra = AllocationExtra::memory_allocated(size, memory_extra);\n@@ -480,7 +484,7 @@ impl<'a, 'mir, 'tcx> Machine<'a, 'mir, 'tcx> for Evaluator<'tcx> {\n     #[inline(always)]\n     fn before_terminator(_ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>) -> EvalResult<'tcx>\n     {\n-        // We are not interested in detecting loops\n+        // We are not interested in detecting loops.\n         Ok(())\n     }\n \n@@ -513,16 +517,16 @@ impl<'a, 'mir, 'tcx> Machine<'a, 'mir, 'tcx> for Evaluator<'tcx> {\n         mutability: Option<hir::Mutability>,\n     ) -> EvalResult<'tcx, Scalar<Borrow>> {\n         let size = ecx.size_and_align_of_mplace(place)?.map(|(size, _)| size)\n-            // for extern types, just cover what we can\n+            // For extern types, just cover what we can.\n             .unwrap_or_else(|| place.layout.size);\n         if !ecx.tcx.sess.opts.debugging_opts.mir_emit_retag ||\n             !Self::enforce_validity(ecx) || size == Size::ZERO\n         {\n-            // No tracking\n+            // No tracking.\n             Ok(place.ptr)\n         } else {\n             ecx.ptr_dereference(place, size, mutability.into())?;\n-            // We never change the pointer\n+            // We never change the pointer.\n             Ok(place.ptr)\n         }\n     }\n@@ -534,7 +538,7 @@ impl<'a, 'mir, 'tcx> Machine<'a, 'mir, 'tcx> for Evaluator<'tcx> {\n         kind: MemoryKind<Self::MemoryKinds>,\n     ) -> Pointer<Borrow> {\n         if !ecx.machine.validate {\n-            // No tracking\n+            // No tracking.\n             ptr.with_default_tag()\n         } else {\n             let tag = ecx.tag_new_allocation(ptr.alloc_id, kind);"}, {"sha": "f2abe4217306cb2ff1e195988488e77876746dee", "filename": "src/mono_hash_map.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/12d3ecbaff9e7b627e79404fa21e2a52278e1368/src%2Fmono_hash_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12d3ecbaff9e7b627e79404fa21e2a52278e1368/src%2Fmono_hash_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmono_hash_map.rs?ref=12d3ecbaff9e7b627e79404fa21e2a52278e1368", "patch": "@@ -1,6 +1,6 @@\n-//! This is a \"monotonic HashMap\": A HashMap that, when shared, can be pushed to but not\n-//! otherwise mutated.  We also Box items in the map. This means we can safely provide\n-//! shared references into existing items in the HashMap, because they will not be dropped\n+//! This is a \"monotonic `HashMap`\": A `HashMap` that, when shared, can be pushed to but not\n+//! otherwise mutated. We also box items in the map. This means we can safely provide\n+//! shared references into existing items in the `HashMap`, because they will not be dropped\n //! (from being removed) or moved (because they are boxed).\n //! The API is is completely tailored to what `memory.rs` needs. It is still in\n //! a separate file to minimize the amount of code that has to care about the unsafety.\n@@ -18,7 +18,7 @@ use crate::AllocMap;\n pub struct MonoHashMap<K: Hash + Eq, V>(RefCell<FxHashMap<K, Box<V>>>);\n \n impl<K: Hash + Eq, V> MonoHashMap<K, V> {\n-    /// This function exists for priroda to be able to iterate over all evaluator memory\n+    /// This function exists for priroda to be able to iterate over all evaluator memory.\n     ///\n     /// The function is somewhat roundabout with the closure argument because internally the\n     /// `MonoHashMap` uses a `RefCell`. When iterating over the `HashMap` inside the `RefCell`,"}, {"sha": "0cba240a7d0fe084fc1cc3c310731bd406374490", "filename": "src/operator.rs", "status": "modified", "additions": 43, "deletions": 28, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/12d3ecbaff9e7b627e79404fa21e2a52278e1368/src%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12d3ecbaff9e7b627e79404fa21e2a52278e1368/src%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Foperator.rs?ref=12d3ecbaff9e7b627e79404fa21e2a52278e1368", "patch": "@@ -60,7 +60,7 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'a, 'mir, '\n             _ => {},\n         }\n \n-        // Now we expect no more fat pointers\n+        // Now we expect no more fat pointers.\n         let left_layout = left.layout;\n         let left = left.to_scalar()?;\n         let right_layout = right.layout;\n@@ -149,27 +149,27 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'a, 'mir, '\n                 if left.alloc_id == right.alloc_id {\n                     left.offset == right.offset\n                 } else {\n-                    // This accepts one-past-the end.  So technically there is still\n+                    // This accepts one-past-the end. Thus, there is still technically\n                     // some non-determinism that we do not fully rule out when two\n-                    // allocations sit right next to each other.  The C/C++ standards are\n+                    // allocations sit right next to each other. The C/C++ standards are\n                     // somewhat fuzzy about this case, so I think for now this check is\n                     // \"good enough\".\n                     // Dead allocations in miri cannot overlap with live allocations, but\n                     // on read hardware this can easily happen. Thus for comparisons we require\n                     // both pointers to be live.\n                     self.memory().check_bounds_ptr(left, InboundsCheck::Live)?;\n                     self.memory().check_bounds_ptr(right, InboundsCheck::Live)?;\n-                    // Two in-bounds pointers, we can compare across allocations\n+                    // Two in-bounds pointers, we can compare across allocations.\n                     left == right\n                 }\n             }\n-            // Comparing ptr and integer\n+            // Comparing ptr and integer.\n             (Scalar::Ptr(ptr), Scalar::Bits { bits, size }) |\n             (Scalar::Bits { bits, size }, Scalar::Ptr(ptr)) => {\n                 assert_eq!(size as u64, self.pointer_size().bytes());\n                 let bits = bits as u64;\n \n-                // Case I: Comparing with NULL\n+                // Case I: Comparing with NULL.\n                 if bits == 0 {\n                     // Test if the ptr is in-bounds. Then it cannot be NULL.\n                     // Even dangling pointers cannot be NULL.\n@@ -186,7 +186,7 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'a, 'mir, '\n                 if ptr.offset.bytes() % alloc_align.bytes() == 0 {\n                     // The offset maintains the allocation alignment, so we know `base+offset`\n                     // is aligned by `alloc_align`.\n-                    // FIXME: We could be even more general, e.g. offset 2 into a 4-aligned\n+                    // FIXME: We could be even more general, e.g., offset 2 into a 4-aligned\n                     // allocation cannot equal 3.\n                     if bits % alloc_align.bytes() != 0 {\n                         // The integer is *not* aligned. So they cannot be equal.\n@@ -198,7 +198,7 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'a, 'mir, '\n                 {\n                     // Compute the highest address at which this allocation could live.\n                     // Substract one more, because it must be possible to add the size\n-                    // to the base address without overflowing -- IOW, the very last address\n+                    // to the base address without overflowing; that is, the very last address\n                     // of the address space is never dereferencable (but it can be in-bounds, i.e.,\n                     // one-past-the-end).\n                     let max_base_addr =\n@@ -208,7 +208,7 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'a, 'mir, '\n                         ) as u64;\n                     if let Some(max_addr) = max_base_addr.checked_add(ptr.offset.bytes()) {\n                         if bits > max_addr {\n-                            // The integer is too big, this cannot possibly be equal\n+                            // The integer is too big, this cannot possibly be equal.\n                             return Ok(false)\n                         }\n                     }\n@@ -235,7 +235,8 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'a, 'mir, '\n \n         Ok(match bin_op {\n             Sub =>\n-                // The only way this can overflow is by underflowing, so signdeness of the right operands does not matter\n+                // The only way this can overflow is by underflowing, so signdeness of the right\n+                // operands does not matter.\n                 map_to_primval(left.overflowing_signed_offset(-(right as i128), self)),\n             Add if signed =>\n                 map_to_primval(left.overflowing_signed_offset(right as i128, self)),\n@@ -245,17 +246,17 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'a, 'mir, '\n             BitAnd if !signed => {\n                 let ptr_base_align = self.memory().get(left.alloc_id)?.align.bytes();\n                 let base_mask = {\n-                    // FIXME: Use interpret::truncate, once that takes a Size instead of a Layout\n+                    // FIXME: use `interpret::truncate`, once that takes a `Size` instead of a `Layout`.\n                     let shift = 128 - self.memory().pointer_size().bits();\n                     let value = !(ptr_base_align as u128 - 1);\n-                    // truncate (shift left to drop out leftover values, shift right to fill with zeroes)\n+                    // Truncate (shift left to drop out leftover values, shift right to fill with zeroes).\n                     (value << shift) >> shift\n                 };\n                 let ptr_size = self.memory().pointer_size().bytes() as u8;\n-                trace!(\"Ptr BitAnd, align {}, operand {:#010x}, base_mask {:#010x}\",\n+                trace!(\"ptr BitAnd, align {}, operand {:#010x}, base_mask {:#010x}\",\n                     ptr_base_align, right, base_mask);\n                 if right & base_mask == base_mask {\n-                    // Case 1: The base address bits are all preserved, i.e., right is all-1 there\n+                    // Case 1: the base address bits are all preserved, i.e., right is all-1 there.\n                     let offset = (left.offset.bytes() as u128 & right) as u64;\n                     (\n                         Scalar::Ptr(Pointer::new_with_tag(\n@@ -266,7 +267,7 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'a, 'mir, '\n                         false,\n                     )\n                 } else if right & base_mask == 0 {\n-                    // Case 2: The base address bits are all taken away, i.e., right is all-0 there\n+                    // Case 2: the base address bits are all taken away, i.e., right is all-0 there.\n                     (Scalar::Bits { bits: (left.offset.bytes() as u128) & right, size: ptr_size }, false)\n                 } else {\n                     return err!(ReadPointerAsBytes);\n@@ -275,43 +276,57 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'a, 'mir, '\n \n             Rem if !signed => {\n                 // Doing modulo a divisor of the alignment is allowed.\n-                // (Intuition: Modulo a divisor leaks less information.)\n+                // (Intuition: modulo a divisor leaks less information.)\n                 let ptr_base_align = self.memory().get(left.alloc_id)?.align.bytes();\n                 let right = right as u64;\n                 let ptr_size = self.memory().pointer_size().bytes() as u8;\n                 if right == 1 {\n-                    // modulo 1 is always 0\n+                    // Modulo 1 is always 0.\n                     (Scalar::Bits { bits: 0, size: ptr_size }, false)\n                 } else if ptr_base_align % right == 0 {\n-                    // the base address would be cancelled out by the modulo operation, so we can\n-                    // just take the modulo of the offset\n-                    (Scalar::Bits { bits: (left.offset.bytes() % right) as u128, size: ptr_size }, false)\n+                    // The base address would be cancelled out by the modulo operation, so we can\n+                    // just take the modulo of the offset.\n+                    (\n+                        Scalar::Bits {\n+                            bits: (left.offset.bytes() % right) as u128,\n+                            size: ptr_size\n+                        },\n+                        false,\n+                    )\n                 } else {\n                     return err!(ReadPointerAsBytes);\n                 }\n             }\n \n             _ => {\n-                let msg = format!(\"unimplemented binary op on pointer {:?}: {:?}, {:?} ({})\", bin_op, left, right, if signed { \"signed\" } else { \"unsigned\" });\n+                let msg = format!(\n+                    \"unimplemented binary op on pointer {:?}: {:?}, {:?} ({})\",\n+                    bin_op,\n+                    left,\n+                    right,\n+                    if signed { \"signed\" } else { \"unsigned\" }\n+                );\n                 return err!(Unimplemented(msg));\n             }\n         })\n     }\n \n-    /// This function raises an error if the offset moves the pointer outside of its allocation.  We consider\n-    /// ZSTs their own huge allocation that doesn't overlap with anything (and nothing moves in there because the size is 0).\n-    /// We also consider the NULL pointer its own separate allocation, and all the remaining integers pointers their own\n-    /// allocation.\n+    /// Raises an error if the offset moves the pointer outside of its allocation.\n+    /// We consider ZSTs their own huge allocation that doesn't overlap with anything (and nothing\n+    /// moves in there because the size is 0). We also consider the NULL pointer its own separate\n+    /// allocation, and all the remaining integers pointers their own allocation.\n     fn pointer_offset_inbounds(\n         &self,\n         ptr: Scalar<Borrow>,\n         pointee_ty: Ty<'tcx>,\n         offset: i64,\n     ) -> EvalResult<'tcx, Scalar<Borrow>> {\n-        // FIXME: assuming here that type size is < i64::max_value()\n+        // FIXME: assuming here that type size is less than `i64::max_value()`.\n         let pointee_size = self.layout_of(pointee_ty)?.size.bytes() as i64;\n-        let offset = offset.checked_mul(pointee_size).ok_or_else(|| EvalErrorKind::Overflow(mir::BinOp::Mul))?;\n-        // Now let's see what kind of pointer this is\n+        let offset = offset\n+            .checked_mul(pointee_size)\n+            .ok_or_else(|| EvalErrorKind::Overflow(mir::BinOp::Mul))?;\n+        // Now let's see what kind of pointer this is.\n         if let Scalar::Ptr(ptr) = ptr {\n             // Both old and new pointer must be in-bounds of a *live* allocation.\n             // (Of the same allocation, but that part is trivial with our representation.)"}, {"sha": "f94917e612a8f96feb2f4f592d0c44c155d45a7e", "filename": "src/range_map.rs", "status": "modified", "additions": 34, "deletions": 31, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/12d3ecbaff9e7b627e79404fa21e2a52278e1368/src%2Frange_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12d3ecbaff9e7b627e79404fa21e2a52278e1368/src%2Frange_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frange_map.rs?ref=12d3ecbaff9e7b627e79404fa21e2a52278e1368", "patch": "@@ -3,7 +3,7 @@\n //! Implements a map from integer indices to data.\n //! Rather than storing data for every index, internally, this maps entire ranges to the data.\n //! To this end, the APIs all work on ranges, not on individual integers. Ranges are split as\n-//! necessary (e.g. when [0,5) is first associated with X, and then [1,2) is mutated).\n+//! necessary (e.g., when [0,5) is first associated with X, and then [1,2) is mutated).\n //! Users must not depend on whether a range is coalesced or not, even though this is observable\n //! via the iteration APIs.\n \n@@ -14,7 +14,8 @@ use rustc::ty::layout::Size;\n \n #[derive(Clone, Debug)]\n struct Elem<T> {\n-    range: ops::Range<u64>, // the range covered by this element, never empty\n+    /// The range covered by this element, never empty.\n+    range: ops::Range<u64>,\n     data: T,\n }\n #[derive(Clone, Debug)]\n@@ -23,7 +24,7 @@ pub struct RangeMap<T> {\n }\n \n impl<T> RangeMap<T> {\n-    /// Create a new RangeMap for the given size, and with the given initial value used for\n+    /// Creates a new `RangeMap` for the given size, and with the given initial value used for\n     /// the entire range.\n     #[inline(always)]\n     pub fn new(size: Size, init: T) -> RangeMap<T> {\n@@ -38,9 +39,9 @@ impl<T> RangeMap<T> {\n         map\n     }\n \n-    /// Find the index containing the given offset.\n+    /// Finds the index containing the given offset.\n     fn find_offset(&self, offset: u64) -> usize {\n-        // We do a binary search\n+        // We do a binary search.\n         let mut left = 0usize; // inclusive\n         let mut right = self.v.len(); // exclusive\n         loop {\n@@ -62,22 +63,23 @@ impl<T> RangeMap<T> {\n         }\n     }\n \n-    /// Provide read-only iteration over everything in the given range.  This does\n-    /// *not* split items if they overlap with the edges.  Do not use this to mutate\n+    /// Provides read-only iteration over everything in the given range. This does\n+    /// *not* split items if they overlap with the edges. Do not use this to mutate\n     /// through interior mutability.\n     pub fn iter<'a>(&'a self, offset: Size, len: Size) -> impl Iterator<Item = &'a T> + 'a {\n         let offset = offset.bytes();\n         let len = len.bytes();\n-        // Compute a slice starting with the elements we care about\n+        // Compute a slice starting with the elements we care about.\n         let slice: &[Elem<T>] = if len == 0 {\n-                // We just need any empty iterator.  We don't even want to\n+                // We just need any empty iterator. We don't even want to\n                 // yield the element that surrounds this position.\n                 &[]\n             } else {\n                 let first_idx = self.find_offset(offset);\n                 &self.v[first_idx..]\n             };\n-        let end = offset + len; // the first offset that is not included any more\n+        // The first offset that is not included any more.\n+        let end = offset + len;\n         slice.iter()\n             .take_while(move |elem| elem.range.start < end)\n             .map(|elem| &elem.data)\n@@ -87,25 +89,25 @@ impl<T> RangeMap<T> {\n         self.v.iter_mut().map(|elem| &mut elem.data)\n     }\n \n-    // Split the element situated at the given `index`, such that the 2nd one starts at offset `split_offset`.\n-    // Do nothing if the element already starts there.\n-    // Return whether a split was necessary.\n+    // Splits the element situated at the given `index`, such that the 2nd one starts at offset\n+    // `split_offset`. Do nothing if the element already starts there.\n+    // Returns whether a split was necessary.\n     fn split_index(&mut self, index: usize, split_offset: u64) -> bool\n     where\n         T: Clone,\n     {\n         let elem = &mut self.v[index];\n         if split_offset == elem.range.start || split_offset == elem.range.end {\n-            // Nothing to do\n+            // Nothing to do.\n             return false;\n         }\n         debug_assert!(elem.range.contains(&split_offset),\n-            \"The split_offset is not in the element to be split\");\n+            \"the `split_offset` is not in the element to be split\");\n \n-        // Now we really have to split.  Reduce length of first element.\n+        // Now we really have to split. Reduce length of first element.\n         let second_range = split_offset..elem.range.end;\n         elem.range.end = split_offset;\n-        // Copy the data, and insert 2nd element\n+        // Copy the data, and insert second element.\n         let second = Elem {\n             range: second_range,\n             data: elem.data.clone(),\n@@ -114,7 +116,7 @@ impl<T> RangeMap<T> {\n         return true;\n     }\n \n-    /// Provide mutable iteration over everything in the given range.  As a side-effect,\n+    /// Provides mutable iteration over everything in the given range. As a side-effect,\n     /// this will split entries in the map that are only partially hit by the given range,\n     /// to make sure that when they are mutated, the effect is constrained to the given range.\n     /// Moreover, this will opportunistically merge neighbouring equal blocks.\n@@ -130,7 +132,7 @@ impl<T> RangeMap<T> {\n         let len = len.bytes();\n         // Compute a slice containing exactly the elements we care about\n         let slice: &mut [Elem<T>] = if len == 0 {\n-                // We just need any empty iterator.  We don't even want to\n+                // We just need any empty iterator. We don't even want to\n                 // yield the element that surrounds this position, nor do\n                 // any splitting.\n                 &mut []\n@@ -142,15 +144,15 @@ impl<T> RangeMap<T> {\n                     first_idx += 1;\n                 }\n                 let first_idx = first_idx; // no more mutation\n-                // Find our end.  Linear scan, but that's okay because the iteration\n+                // Find our end. Linear scan, but that's ok because the iteration\n                 // is doing the same linear scan anyway -- no increase in complexity.\n                 // We combine this scan with a scan for duplicates that we can merge, to reduce\n                 // the number of elements.\n                 // We stop searching after the first \"block\" of size 1, to avoid spending excessive\n                 // amounts of time on the merging.\n                 let mut equal_since_idx = first_idx;\n                 // Once we see too many non-mergeable blocks, we stop.\n-                // The initial value is chosen via... magic.  Benchmarking and magic.\n+                // The initial value is chosen via... magic. Benchmarking and magic.\n                 let mut successful_merge_count = 3usize;\n                 let mut end_idx = first_idx; // when the loop is done, this is the first excluded element.\n                 loop {\n@@ -162,7 +164,7 @@ impl<T> RangeMap<T> {\n                     // see if we want to merge everything in `equal_since..end` (exclusive at the end!)\n                     if successful_merge_count > 0 {\n                         if done || self.v[end_idx].data != self.v[equal_since_idx].data {\n-                            // Everything in `equal_since..end` was equal.  Make them just one element covering\n+                            // Everything in `equal_since..end` was equal. Make them just one element covering\n                             // the entire range.\n                             let removed_elems = end_idx - equal_since_idx - 1; // number of elements that we would remove\n                             if removed_elems > 0 {\n@@ -173,10 +175,10 @@ impl<T> RangeMap<T> {\n                                 self.v.splice(equal_since_idx+1..end_idx, std::iter::empty());\n                                 // Adjust `end_idx` because we made the list shorter.\n                                 end_idx -= removed_elems;\n-                                // adjust the count for the cutoff\n+                                // Adjust the count for the cutoff.\n                                 successful_merge_count += removed_elems;\n                             } else {\n-                                // adjust the count for the cutoff\n+                                // Adjust the count for the cutoff.\n                                 successful_merge_count -= 1;\n                             }\n                             // Go on scanning for the next block starting here.\n@@ -188,8 +190,9 @@ impl<T> RangeMap<T> {\n                         break;\n                     }\n                 }\n-                let end_idx = end_idx-1; // Move to last included instead of first excluded index.\n-                // We need to split the end as well.  Even if this performs a\n+                // Move to last included instead of first excluded index.\n+                let end_idx = end_idx-1;\n+                // We need to split the end as well. Even if this performs a\n                 // split, we don't have to adjust our index as we only care about\n                 // the first part of the split.\n                 self.split_index(end_idx, offset+len);\n@@ -220,15 +223,15 @@ mod tests {\n     #[test]\n     fn basic_insert() {\n         let mut map = RangeMap::<i32>::new(Size::from_bytes(20), -1);\n-        // Insert\n+        // Insert.\n         for x in map.iter_mut(Size::from_bytes(10), Size::from_bytes(1)) {\n             *x = 42;\n         }\n-        // Check\n+        // Check.\n         assert_eq!(to_vec(&map, 10, 1), vec![42]);\n         assert_eq!(map.v.len(), 3);\n \n-        // Insert with size 0\n+        // Insert with size 0.\n         for x in map.iter_mut(Size::from_bytes(10), Size::from_bytes(0)) {\n             *x = 19;\n         }\n@@ -275,11 +278,11 @@ mod tests {\n             to_vec(&map, 10, 10),\n             vec![23, 42, 23, 23, 23, 19, 19, 19, 19, 19]\n         );\n-        // Should be seeing two blocks with 19\n+        // Should be seeing two blocks with 19.\n         assert_eq!(map.iter(Size::from_bytes(15), Size::from_bytes(2))\n             .map(|&t| t).collect::<Vec<_>>(), vec![19, 19]);\n \n-        // a NOP iter_mut should trigger merging\n+        // A NOP `iter_mut` should trigger merging.\n         for x in map.iter_mut(Size::from_bytes(15), Size::from_bytes(5)) { }\n         assert_eq!(map.v.len(), 5);\n         assert_eq!("}, {"sha": "c9ca1c84e0f70531fdacb9665b1d6ae0e0ee5a37", "filename": "src/stacked_borrows.rs", "status": "modified", "additions": 115, "deletions": 96, "changes": 211, "blob_url": "https://github.com/rust-lang/rust/blob/12d3ecbaff9e7b627e79404fa21e2a52278e1368/src%2Fstacked_borrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12d3ecbaff9e7b627e79404fa21e2a52278e1368/src%2Fstacked_borrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstacked_borrows.rs?ref=12d3ecbaff9e7b627e79404fa21e2a52278e1368", "patch": "@@ -15,16 +15,15 @@ use crate::{\n pub type Timestamp = u64;\n pub type CallId = u64;\n \n-/// Information about which kind of borrow was used to create the reference this is tagged\n-/// with.\n+/// Information about which kind of borrow was used to create the reference this is tagged with.\n #[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n pub enum Borrow {\n     /// A unique (mutable) reference.\n     Uniq(Timestamp),\n-    /// An aliasing reference.  This is also used by raw pointers, which do not track details\n+    /// An aliasing reference. This is also used by raw pointers, which do not track details\n     /// of how or when they were created, hence the timestamp is optional.\n-    /// Shr(Some(_)) does NOT mean that the destination of this reference is frozen;\n-    /// that depends on the type!  Only those parts outside of an `UnsafeCell` are actually\n+    /// `Shr(Some(_))` does *not* mean that the destination of this reference is frozen;\n+    /// that depends on the type! Only those parts outside of an `UnsafeCell` are actually\n     /// frozen.\n     Alias(Option<Timestamp>),\n }\n@@ -53,23 +52,25 @@ impl Default for Borrow {\n     }\n }\n \n-/// An item in the per-location borrow stack\n+/// An item in the per-location borrow stack.\n #[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n pub enum BorStackItem {\n     /// Indicates the unique reference that may mutate.\n     Uniq(Timestamp),\n-    /// Indicates that the location has been mutably shared.  Used for raw pointers as\n+    /// Indicates that the location has been mutably shared. Used for raw pointers as\n     /// well as for unfrozen shared references.\n     Raw,\n-    /// A barrier, tracking the function it belongs to by its index on the call stack\n+    /// A barrier, tracking the function it belongs to by its index on the call stack.\n     FnBarrier(CallId)\n }\n \n-/// Extra per-location state\n+/// Extra per-location state.\n #[derive(Clone, Debug, PartialEq, Eq)]\n pub struct Stack {\n-    borrows: Vec<BorStackItem>, // used as a stack; never empty\n-    frozen_since: Option<Timestamp>, // virtual frozen \"item\" on top of the stack\n+    /// Used as the stack; never empty.\n+    borrows: Vec<BorStackItem>,\n+    /// A virtual frozen \"item\" on top of the stack.\n+    frozen_since: Option<Timestamp>,\n }\n \n impl Stack {\n@@ -79,26 +80,26 @@ impl Stack {\n     }\n }\n \n-/// What kind of reference is being used?\n+/// Indicates which kind of reference is being used.\n #[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n pub enum RefKind {\n-    /// &mut\n+    /// `&mut`.\n     Unique,\n-    /// & without interior mutability\n+    /// `&` without interior mutability.\n     Frozen,\n-    /// * (raw pointer) or & to `UnsafeCell`\n+    /// `*` (raw pointer) or `&` to `UnsafeCell`.\n     Raw,\n }\n \n-/// What kind of access is being performed?\n+/// Indicates which kind of access is being performed.\n #[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n pub enum AccessKind {\n     Read,\n     Write,\n     Dealloc,\n }\n \n-/// Extra global state in the memory, available to the memory access hooks\n+/// Extra global state in the memory, available to the memory access hooks.\n #[derive(Debug)]\n pub struct BarrierTracking {\n     next_id: CallId,\n@@ -133,7 +134,7 @@ impl BarrierTracking {\n     }\n }\n \n-/// Extra global machine state\n+/// Extra global machine state.\n #[derive(Clone, Debug)]\n pub struct State {\n     clock: Timestamp\n@@ -153,7 +154,7 @@ impl State {\n     }\n }\n \n-/// Extra per-allocation state\n+/// Extra per-allocation state.\n #[derive(Clone, Debug)]\n pub struct Stacks {\n     // Even reading memory can have effects on the stack, so we need a `RefCell` here.\n@@ -164,18 +165,19 @@ pub struct Stacks {\n /// Core per-location operations: deref, access, create.\n /// We need to make at least the following things true:\n ///\n-/// U1: After creating a Uniq, it is at the top (+unfrozen).\n-/// U2: If the top is Uniq (+unfrozen), accesses must be through that Uniq or pop it.\n-/// U3: If an access (deref sufficient?) happens with a Uniq, it requires the Uniq to be in the stack.\n+/// U1: After creating a `Uniq`, it is at the top (and unfrozen).\n+/// U2: If the top is `Uniq` (and unfrozen), accesses must be through that `Uniq` or pop it.\n+/// U3: If an access (deref sufficient?) happens with a `Uniq`, it requires the `Uniq` to be in the stack.\n ///\n-/// F1: After creating a &, the parts outside `UnsafeCell` are frozen.\n+/// F1: After creating a `&`, the parts outside `UnsafeCell` are frozen.\n /// F2: If a write access happens, it unfreezes.\n-/// F3: If an access (well, a deref) happens with an & outside `UnsafeCell`, it requires the location to still be frozen.\n+/// F3: If an access (well, a deref) happens with an `&` outside `UnsafeCell`,\n+///     it requires the location to still be frozen.\n impl<'tcx> Stack {\n-    /// Deref `bor`: Check if the location is frozen and the tag in the stack.\n-    /// This dos *not* constitute an access!  \"Deref\" refers to the `*` operator\n+    /// Deref `bor`: check if the location is frozen and the tag in the stack.\n+    /// This dos *not* constitute an access! \"Deref\" refers to the `*` operator\n     /// in Rust, and includs cases like `&*x` or `(*x).foo` where no or only part\n-    /// of the memory actually gets accessed.  Also we cannot know if we are\n+    /// of the memory actually gets accessed. Also we cannot know if we are\n     /// going to read or write.\n     /// Returns the index of the item we matched, `None` if it was the frozen one.\n     /// `kind` indicates which kind of reference is being dereferenced.\n@@ -186,44 +188,46 @@ impl<'tcx> Stack {\n     ) -> Result<Option<usize>, String> {\n         // Exclude unique ref with frozen tag.\n         if let (RefKind::Unique, Borrow::Alias(Some(_))) = (kind, bor) {\n-            return Err(format!(\"Encountered mutable reference with frozen tag ({:?})\", bor));\n+            return Err(format!(\"encountered mutable reference with frozen tag ({:?})\", bor));\n         }\n-        // Checks related to freezing\n+        // Checks related to freezing.\n         match bor {\n             Borrow::Alias(Some(bor_t)) if kind == RefKind::Frozen => {\n                 // We need the location to be frozen. This ensures F3.\n                 let frozen = self.frozen_since.map_or(false, |itm_t| itm_t <= bor_t);\n                 return if frozen { Ok(None) } else {\n-                    Err(format!(\"Location is not frozen long enough\"))\n+                    Err(format!(\"location is not frozen long enough\"))\n                 }\n             }\n             Borrow::Alias(_) if self.frozen_since.is_some() => {\n-                return Ok(None) // Shared deref to frozen location, looking good\n+                // Shared deref to frozen location; looking good.\n+                return Ok(None)\n             }\n-            _ => {} // Not sufficient, go on looking.\n+            // Not sufficient; go on looking.\n+            _ => {}\n         }\n         // If we got here, we have to look for our item in the stack.\n         for (idx, &itm) in self.borrows.iter().enumerate().rev() {\n             match (itm, bor) {\n                 (BorStackItem::Uniq(itm_t), Borrow::Uniq(bor_t)) if itm_t == bor_t => {\n-                    // Found matching unique item.  This satisfies U3.\n+                    // Found matching unique item. This satisfies U3.\n                     return Ok(Some(idx))\n                 }\n                 (BorStackItem::Raw, Borrow::Alias(_)) => {\n                     // Found matching aliasing/raw item.\n                     return Ok(Some(idx))\n                 }\n-                // Go on looking.  We ignore barriers!  When an `&mut` and an `&` alias,\n+                // Go on looking. We ignore barriers! When an `&mut` and an `&` alias,\n                 // dereferencing the `&` is still possible (to reborrow), but doing\n                 // an access is not.\n                 _ => {}\n             }\n         }\n-        // If we got here, we did not find our item.  We have to error to satisfy U3.\n+        // If we got here, we did not find our item. We have to error to satisfy U3.\n         Err(format!(\"Borrow being dereferenced ({:?}) does not exist on the borrow stack\", bor))\n     }\n \n-    /// Perform an actual memory access using `bor`.  We do not know any types here\n+    /// Performs an actual memory access using `bor`. We do not know any types here\n     /// or whether things should be frozen, but we *do* know if this is reading\n     /// or writing.\n     fn access(\n@@ -236,65 +240,64 @@ impl<'tcx> Stack {\n         // Not possible on writes!\n         if self.is_frozen() {\n             if kind == AccessKind::Read {\n-                // When we are frozen, we just accept all reads.  No harm in this.\n+                // When we are frozen, we just accept all reads. No harm in this.\n                 // The deref already checked that `Uniq` items are in the stack, and that\n                 // the location is frozen if it should be.\n                 return Ok(());\n             }\n-            trace!(\"access: Unfreezing\");\n+            trace!(\"access: unfreezing\");\n         }\n-        // Unfreeze on writes.  This ensures F2.\n+        // Unfreeze on writes. This ensures F2.\n         self.frozen_since = None;\n         // Pop the stack until we have something matching.\n         while let Some(&itm) = self.borrows.last() {\n             match (itm, bor) {\n                 (BorStackItem::FnBarrier(call), _) if barrier_tracking.is_active(call) => {\n                     return err!(MachineError(format!(\n-                        \"Stopping looking for borrow being accessed ({:?}) because of barrier ({})\",\n+                        \"stopping looking for borrow being accessed ({:?}) because of barrier ({})\",\n                         bor, call\n                     )))\n                 }\n                 (BorStackItem::Uniq(itm_t), Borrow::Uniq(bor_t)) if itm_t == bor_t => {\n-                    // Found matching unique item.  Continue after the match.\n+                    // Found matching unique item. Continue after the match.\n                 }\n                 (BorStackItem::Raw, _) if kind == AccessKind::Read => {\n                     // When reading, everything can use a raw item!\n                     // We do not want to do this when writing: Writing to an `&mut`\n                     // should reaffirm its exclusivity (i.e., make sure it is\n-                    // on top of the stack).\n-                    // Continue after the match.\n+                    // on top of the stack). Continue after the match.\n                 }\n                 (BorStackItem::Raw, Borrow::Alias(_)) => {\n-                    // Found matching raw item.  Continue after the match.\n+                    // Found matching raw item. Continue after the match.\n                 }\n                 _ => {\n-                    // Pop this, go on.  This ensures U2.\n+                    // Pop this, go on. This ensures U2.\n                     let itm = self.borrows.pop().unwrap();\n                     trace!(\"access: Popping {:?}\", itm);\n                     continue\n                 }\n             }\n-            // If we got here, we found a matching item.  Congratulations!\n+            // If we got here, we found a matching item. Congratulations!\n             // However, we are not done yet: If this access is deallocating, we must make sure\n             // there are no active barriers remaining on the stack.\n             if kind == AccessKind::Dealloc {\n                 for &itm in self.borrows.iter().rev() {\n                     match itm {\n                         BorStackItem::FnBarrier(call) if barrier_tracking.is_active(call) => {\n                             return err!(MachineError(format!(\n-                                \"Deallocating with active barrier ({})\", call\n+                                \"deallocating with active barrier ({})\", call\n                             )))\n                         }\n                         _ => {},\n                     }\n                 }\n             }\n-            // NOW we are done.\n+            // Now we are done.\n             return Ok(())\n         }\n         // If we got here, we did not find our item.\n         err!(MachineError(format!(\n-            \"Borrow being accessed ({:?}) does not exist on the borrow stack\",\n+            \"borrow being accessed ({:?}) does not exist on the borrow stack\",\n             bor\n         )))\n     }\n@@ -304,26 +307,32 @@ impl<'tcx> Stack {\n     /// is met: We cannot push `Uniq` onto frozen stacks.\n     /// `kind` indicates which kind of reference is being created.\n     fn create(&mut self, bor: Borrow, kind: RefKind) {\n-        // When creating a frozen reference, freeze.  This ensures F1.\n+        // When creating a frozen reference, freeze. This ensures F1.\n         // We also do *not* push anything else to the stack, making sure that no nother kind\n         // of access (like writing through raw pointers) is permitted.\n         if kind == RefKind::Frozen {\n             let bor_t = match bor {\n                 Borrow::Alias(Some(t)) => t,\n                 _ => bug!(\"Creating illegal borrow {:?} for frozen ref\", bor),\n             };\n-            // It is possible that we already are frozen (e.g. if we just pushed a barrier,\n+            // It is possible that we already are frozen (e.g., if we just pushed a barrier,\n             // the redundancy check would not have kicked in).\n             match self.frozen_since {\n-                Some(loc_t) => assert!(loc_t <= bor_t, \"Trying to freeze location for longer than it was already frozen\"),\n+                Some(loc_t) => assert!(\n+                    loc_t <= bor_t,\n+                    \"trying to freeze location for longer than it was already frozen\"\n+                ),\n                 None => {\n                     trace!(\"create: Freezing\");\n                     self.frozen_since = Some(bor_t);\n                 }\n             }\n             return;\n         }\n-        assert!(self.frozen_since.is_none(), \"Trying to create non-frozen reference to frozen location\");\n+        assert!(\n+            self.frozen_since.is_none(),\n+            \"trying to create non-frozen reference to frozen location\"\n+        );\n \n         // Push new item to the stack.\n         let itm = match bor {\n@@ -334,33 +343,33 @@ impl<'tcx> Stack {\n             // This is just an optimization, no functional change: Avoid stacking\n             // multiple `Shr` on top of each other.\n             assert!(bor.is_aliasing());\n-            trace!(\"create: Sharing a shared location is a NOP\");\n+            trace!(\"create: sharing a shared location is a NOP\");\n         } else {\n             // This ensures U1.\n-            trace!(\"create: Pushing {:?}\", itm);\n+            trace!(\"create: pushing {:?}\", itm);\n             self.borrows.push(itm);\n         }\n     }\n \n-    /// Add a barrier\n+    /// Adds a barrier.\n     fn barrier(&mut self, call: CallId) {\n         let itm = BorStackItem::FnBarrier(call);\n         if *self.borrows.last().unwrap() == itm {\n             // This is just an optimization, no functional change: Avoid stacking\n             // multiple identical barriers on top of each other.\n             // This can happen when a function receives several shared references\n             // that overlap.\n-            trace!(\"barrier: Avoiding redundant extra barrier\");\n+            trace!(\"barrier: avoiding redundant extra barrier\");\n         } else {\n-            trace!(\"barrier: Pushing barrier for call {}\", call);\n+            trace!(\"barrier: pushing barrier for call {}\", call);\n             self.borrows.push(itm);\n         }\n     }\n }\n \n /// Higher-level per-location operations: deref, access, reborrow.\n impl<'tcx> Stacks {\n-    /// Check that this stack is fine with being dereferenced\n+    /// Checks that this stack is fine with being dereferenced.\n     fn deref(\n         &self,\n         ptr: Pointer<Borrow>,\n@@ -406,14 +415,15 @@ impl<'tcx> Stacks {\n         new_kind: RefKind,\n     ) -> EvalResult<'tcx> {\n         assert_eq!(new_bor.is_unique(), new_kind == RefKind::Unique);\n-        trace!(\"reborrow for tag {:?} to {:?} as {:?}: {:?}, size {}\",\n-            ptr.tag, new_bor, new_kind, ptr, size.bytes());\n+        trace!(\n+            \"reborrow for tag {:?} to {:?} as {:?}: {:?}, size {}\",\n+            ptr.tag, new_bor, new_kind, ptr, size.bytes(),\n+        );\n         if new_kind == RefKind::Raw {\n-            // No barrier for raw, including `&UnsafeCell`.  They can rightfully\n-            // alias with `&mut`.\n-            // FIXME: This means that the `dereferencable` attribute on non-frozen shared\n-            // references is incorrect!  They are dereferencable when the function is\n-            // called, but might become non-dereferencable during the course of execution.\n+            // No barrier for raw, including `&UnsafeCell`. They can rightfully alias with `&mut`.\n+            // FIXME: This means that the `dereferencable` attribute on non-frozen shared references\n+            // is incorrect! They are dereferencable when the function is called, but might become\n+            // non-dereferencable during the course of execution.\n             // Also see [1], [2].\n             //\n             // [1]: <https://internals.rust-lang.org/t/\n@@ -428,19 +438,19 @@ impl<'tcx> Stacks {\n             let ptr_idx = stack.deref(ptr.tag, new_kind).map_err(EvalErrorKind::MachineError)?;\n             // If we can deref the new tag already, and if that tag lives higher on\n             // the stack than the one we come from, just use that.\n-            // IOW, we check if `new_bor` *already* is \"derived from\" `ptr.tag`.\n+            // That is, we check if `new_bor` *already* is \"derived from\" `ptr.tag`.\n             // This also checks frozenness, if required.\n             let bor_redundant = barrier.is_none() &&\n                 match (ptr_idx, stack.deref(new_bor, new_kind)) {\n                     // If the new borrow works with the frozen item, or else if it lives\n                     // above the old one in the stack, our job here is done.\n                     (_, Ok(None)) => true,\n                     (Some(ptr_idx), Ok(Some(new_idx))) if new_idx >= ptr_idx => true,\n-                    // Otherwise we need to create a new borrow.\n+                    // Otherwise, we need to create a new borrow.\n                     _ => false,\n                 };\n             if bor_redundant {\n-                assert!(new_bor.is_aliasing(), \"A unique reborrow can never be redundant\");\n+                assert!(new_bor.is_aliasing(), \"a unique reborrow can never be redundant\");\n                 trace!(\"reborrow is redundant\");\n                 continue;\n             }\n@@ -460,7 +470,7 @@ impl<'tcx> Stacks {\n     }\n }\n \n-/// Hooks and glue\n+/// Hooks and glue.\n impl AllocationExtra<Borrow, MemoryState> for Stacks {\n     #[inline(always)]\n     fn memory_allocated<'tcx>(size: Size, extra: &MemoryState) -> Self {\n@@ -529,10 +539,10 @@ trait EvalContextPrivExt<'a, 'mir, 'tcx: 'a+'mir>: crate::MiriEvalContextExt<'a,\n         let this = self.eval_context_mut();\n         let ptr = place.ptr.to_ptr()?;\n         let barrier = if fn_barrier { Some(this.frame().extra) } else { None };\n-        trace!(\"reborrow: Creating new reference for {:?} (pointee {}): {:?}\",\n+        trace!(\"reborrow: creating new reference for {:?} (pointee {}): {:?}\",\n             ptr, place.layout.ty, new_bor);\n \n-        // Get the allocation.  It might not be mutable, so we cannot use `get_mut`.\n+        // Get the allocation. It might not be mutable, so we cannot use `get_mut`.\n         let alloc = this.memory().get(ptr.alloc_id)?;\n         alloc.check_bounds(this, ptr, size)?;\n         // Update the stacks.\n@@ -550,7 +560,7 @@ trait EvalContextPrivExt<'a, 'mir, 'tcx: 'a+'mir>: crate::MiriEvalContextExt<'a,\n         Ok(())\n     }\n \n-    /// Retag an indidual pointer, returning the retagged version.\n+    /// Retags an indidual pointer, returning the retagged version.\n     /// `mutbl` can be `None` to make this a raw pointer.\n     fn retag_reference(\n         &mut self,\n@@ -587,10 +597,10 @@ trait EvalContextPrivExt<'a, 'mir, 'tcx: 'a+'mir>: crate::MiriEvalContextExt<'a,\n             // We immediately share it, to allow read accesses\n             let two_phase_time = this.machine.stacked_borrows.increment_clock();\n             let two_phase_bor = Borrow::Alias(Some(two_phase_time));\n-            this.reborrow(new_place, size, /*fn_barrier*/false, two_phase_bor)?;\n+            this.reborrow(new_place, size, false /* fn_barrier */, two_phase_bor)?;\n         }\n \n-        // Return new ptr.\n+        // Return new pointer.\n         Ok(new_place.to_ref())\n     }\n }\n@@ -607,29 +617,32 @@ pub trait EvalContextExt<'a, 'mir, 'tcx: 'a+'mir>: crate::MiriEvalContextExt<'a,\n             MemoryKind::Stack => {\n                 // New unique borrow. This `Uniq` is not accessible by the program,\n                 // so it will only ever be used when using the local directly (i.e.,\n-                // not through a pointer).  IOW, whenever we directly use a local this will pop\n-                // everything else off the stack, invalidating all previous pointers\n-                // and, in particular, *all* raw pointers.  This subsumes the explicit\n+                // not through a pointer). That is, whenever we directly use a local, this will pop\n+                // everything else off the stack, invalidating all previous pointers,\n+                // and in particular, *all* raw pointers. This subsumes the explicit\n                 // `reset` which the blog post [1] says to perform when accessing a local.\n                 //\n-                // [1] https://www.ralfj.de/blog/2018/08/07/stacked-borrows.html\n+                // [1]: <https://www.ralfj.de/blog/2018/08/07/stacked-borrows.html>\n                 this.machine.stacked_borrows.increment_clock()\n             }\n             _ => {\n-                // Nothing to do for everything else\n+                // Nothing to do for everything else.\n                 return Borrow::default()\n             }\n         };\n-        // Make this the active borrow for this allocation\n-        let alloc = this.memory_mut().get_mut(id).expect(\"This is a new allocation, it must still exist\");\n+        // Make this the active borrow for this allocation.\n+        let alloc = this\n+            .memory_mut()\n+            .get_mut(id)\n+            .expect(\"this is a new allocation; it must still exist\");\n         let size = Size::from_bytes(alloc.bytes.len() as u64);\n         alloc.extra.first_item(BorStackItem::Uniq(time), size);\n         Borrow::Uniq(time)\n     }\n \n-    /// Called for value-to-place conversion.  `mutability` is `None` for raw pointers.\n+    /// Called for value-to-place conversion. `mutability` is `None` for raw pointers.\n     ///\n-    /// Note that this does NOT mean that all this memory will actually get accessed/referenced!\n+    /// Note that this does *not* mean that all this memory will actually get accessed/referenced!\n     /// We could be in the middle of `&(*var).1`.\n     fn ptr_dereference(\n         &self,\n@@ -638,9 +651,15 @@ pub trait EvalContextExt<'a, 'mir, 'tcx: 'a+'mir>: crate::MiriEvalContextExt<'a,\n         mutability: Option<Mutability>,\n     ) -> EvalResult<'tcx> {\n         let this = self.eval_context_ref();\n-        trace!(\"ptr_dereference: Accessing {} reference for {:?} (pointee {})\",\n-            if let Some(mutability) = mutability { format!(\"{:?}\", mutability) } else { format!(\"raw\") },\n-            place.ptr, place.layout.ty);\n+        trace!(\n+            \"ptr_dereference: Accessing {} reference for {:?} (pointee {})\",\n+            if let Some(mutability) = mutability {\n+                format!(\"{:?}\", mutability)\n+            } else {\n+                format!(\"raw\")\n+            },\n+            place.ptr, place.layout.ty\n+        );\n         let ptr = place.ptr.to_ptr()?;\n         if mutability.is_none() {\n             // No further checks on raw derefs -- only the access itself will be checked.\n@@ -653,18 +672,18 @@ pub trait EvalContextExt<'a, 'mir, 'tcx: 'a+'mir>: crate::MiriEvalContextExt<'a,\n         // If we got here, we do some checking, *but* we leave the tag unchanged.\n         if let Borrow::Alias(Some(_)) = ptr.tag {\n             assert_eq!(mutability, Some(MutImmutable));\n-            // We need a frozen-sensitive check\n+            // We need a frozen-sensitive check.\n             this.visit_freeze_sensitive(place, size, |cur_ptr, size, frozen| {\n                 let kind = if frozen { RefKind::Frozen } else { RefKind::Raw };\n                 alloc.extra.deref(cur_ptr, size, kind)\n             })?;\n         } else {\n-            // Just treat this as one big chunk\n+            // Just treat this as one big chunk.\n             let kind = if mutability == Some(MutMutable) { RefKind::Unique } else { RefKind::Raw };\n             alloc.extra.deref(ptr, size, kind)?;\n         }\n \n-        // All is good\n+        // All is good.\n         Ok(())\n     }\n \n@@ -679,22 +698,22 @@ pub trait EvalContextExt<'a, 'mir, 'tcx: 'a+'mir>: crate::MiriEvalContextExt<'a,\n         // making it useless.\n         fn qualify(ty: ty::Ty<'_>, kind: RetagKind) -> Option<(Option<Mutability>, bool)> {\n             match ty.sty {\n-                // References are simple\n+                // References are simple.\n                 ty::Ref(_, _, mutbl) => Some((Some(mutbl), kind == RetagKind::FnEntry)),\n-                // Raw pointers need to be enabled\n+                // Raw pointers need to be enabled.\n                 ty::RawPtr(..) if kind == RetagKind::Raw => Some((None, false)),\n-                // Boxes do not get a barrier: Barriers reflect that references outlive the call\n+                // Boxes do not get a barrier: barriers reflect that references outlive the call\n                 // they were passed in to; that's just not the case for boxes.\n                 ty::Adt(..) if ty.is_box() => Some((Some(MutMutable), false)),\n                 _ => None,\n             }\n         }\n \n-        // We need a visitor to visit all references.  However, that requires\n+        // We need a visitor to visit all references. However, that requires\n         // a `MemPlace`, so we have a fast path for reference types that\n         // avoids allocating.\n         if let Some((mutbl, barrier)) = qualify(place.layout.ty, kind) {\n-            // fast path\n+            // Fast path.\n             let val = this.read_immediate(this.place_to_op(place)?)?;\n             let val = this.retag_reference(val, mutbl, barrier, kind == RetagKind::TwoPhase)?;\n             this.write_immediate(val, place)?;\n@@ -705,7 +724,7 @@ pub trait EvalContextExt<'a, 'mir, 'tcx: 'a+'mir>: crate::MiriEvalContextExt<'a,\n         let mut visitor = RetagVisitor { ecx: this, kind };\n         visitor.visit_value(place)?;\n \n-        // The actual visitor\n+        // The actual visitor.\n         struct RetagVisitor<'ecx, 'a, 'mir, 'tcx> {\n             ecx: &'ecx mut MiriEvalContext<'a, 'mir, 'tcx>,\n             kind: RetagKind,"}, {"sha": "b2f1c824f1b45e8c7c7512916417c493510e4f1a", "filename": "tests/compile-fail/stacked_borrows/deallocate_against_barrier.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12d3ecbaff9e7b627e79404fa21e2a52278e1368/tests%2Fcompile-fail%2Fstacked_borrows%2Fdeallocate_against_barrier.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12d3ecbaff9e7b627e79404fa21e2a52278e1368/tests%2Fcompile-fail%2Fstacked_borrows%2Fdeallocate_against_barrier.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Fdeallocate_against_barrier.rs?ref=12d3ecbaff9e7b627e79404fa21e2a52278e1368", "patch": "@@ -1,4 +1,4 @@\n-// error-pattern: Deallocating with active barrier\n+// error-pattern: deallocating with active barrier\n \n fn inner(x: &mut i32, f: fn(&mut i32)) {\n     // `f` may mutate, but it may not deallocate!"}, {"sha": "9b6c6fcc32efd0f34eb8c46199ae280385d6afdc", "filename": "tests/run-pass/const-vec-of-fns.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/12d3ecbaff9e7b627e79404fa21e2a52278e1368/tests%2Frun-pass%2Fconst-vec-of-fns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12d3ecbaff9e7b627e79404fa21e2a52278e1368/tests%2Frun-pass%2Fconst-vec-of-fns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fconst-vec-of-fns.rs?ref=12d3ecbaff9e7b627e79404fa21e2a52278e1368", "patch": "@@ -1,13 +1,3 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n /*!\n  * Try to double-check that static fns have the right size (with or\n  * without dummy env ptr, as appropriate) by iterating a size-2 array."}, {"sha": "bfed725a497ccafb248985fabe2ebe91a25e1383", "filename": "tests/run-pass/heap_allocator.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/12d3ecbaff9e7b627e79404fa21e2a52278e1368/tests%2Frun-pass%2Fheap_allocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12d3ecbaff9e7b627e79404fa21e2a52278e1368/tests%2Frun-pass%2Fheap_allocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fheap_allocator.rs?ref=12d3ecbaff9e7b627e79404fa21e2a52278e1368", "patch": "@@ -1,13 +1,16 @@\n-//ignore-windows: Inspects allocation base address on Windows\n+//ignore-windows: inspects allocation base address on Windows\n+\n #![feature(allocator_api)]\n \n use std::ptr::NonNull;\n use std::alloc::{Global, Alloc, Layout, System};\n \n fn check_overalign_requests<T: Alloc>(mut allocator: T) {\n     let size = 8;\n-    let align = 16; // greater than size\n-    let iterations = 1; // Miri is deterministic, no need to try many times\n+    // Greater than `size`.\n+    let align = 16;\n+    // Miri is deterministic; no need to try many times.\n+    let iterations = 1;\n     unsafe {\n         let pointers: Vec<_> = (0..iterations).map(|_| {\n             allocator.alloc(Layout::from_size_align(size, align).unwrap()).unwrap()\n@@ -17,7 +20,7 @@ fn check_overalign_requests<T: Alloc>(mut allocator: T) {\n                        \"Got a pointer less aligned than requested\")\n         }\n \n-        // Clean up\n+        // Clean up.\n         for &ptr in &pointers {\n             allocator.dealloc(ptr, Layout::from_size_align(size, align).unwrap())\n         }"}, {"sha": "ebd6dbb61ee4e745338b276caf3d3ce23ea2e038", "filename": "tests/run-pass/too-large-primval-write-problem.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12d3ecbaff9e7b627e79404fa21e2a52278e1368/tests%2Frun-pass%2Ftoo-large-primval-write-problem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12d3ecbaff9e7b627e79404fa21e2a52278e1368/tests%2Frun-pass%2Ftoo-large-primval-write-problem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Ftoo-large-primval-write-problem.rs?ref=12d3ecbaff9e7b627e79404fa21e2a52278e1368", "patch": "@@ -1,4 +1,4 @@\n-// PrimVals in Miri are represented with 8 bytes (u64) and at the time of writing, the `-x`\n+// `PrimVal`s in Miri are represented with 8 bytes (u64) and at the time of writing, the `-x`\n // will sign extend into the entire 8 bytes. Then, if you tried to write the `-x` into\n // something smaller than 8 bytes, like a 4 byte pointer, it would crash in byteorder crate\n // code that assumed only the low 4 bytes would be set. Actually, we were masking properly for"}]}