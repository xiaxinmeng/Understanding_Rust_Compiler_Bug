{"sha": "6d4e2042f9dae20266292c45b2789962873b1d01", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZkNGUyMDQyZjlkYWUyMDI2NjI5MmM0NWIyNzg5OTYyODczYjFkMDE=", "commit": {"author": {"name": "Dylan MacKenzie", "email": "ecstaticmorse@gmail.com", "date": "2019-10-29T04:25:51Z"}, "committer": {"name": "Dylan MacKenzie", "email": "ecstaticmorse@gmail.com", "date": "2019-11-15T18:33:52Z"}, "message": "Remove `qualify_consts` completely", "tree": {"sha": "bc335f85e411b61787e8cc22547e2e7062f51fcd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bc335f85e411b61787e8cc22547e2e7062f51fcd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6d4e2042f9dae20266292c45b2789962873b1d01", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6d4e2042f9dae20266292c45b2789962873b1d01", "html_url": "https://github.com/rust-lang/rust/commit/6d4e2042f9dae20266292c45b2789962873b1d01", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6d4e2042f9dae20266292c45b2789962873b1d01/comments", "author": {"login": "ecstatic-morse", "id": 29463364, "node_id": "MDQ6VXNlcjI5NDYzMzY0", "avatar_url": "https://avatars.githubusercontent.com/u/29463364?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ecstatic-morse", "html_url": "https://github.com/ecstatic-morse", "followers_url": "https://api.github.com/users/ecstatic-morse/followers", "following_url": "https://api.github.com/users/ecstatic-morse/following{/other_user}", "gists_url": "https://api.github.com/users/ecstatic-morse/gists{/gist_id}", "starred_url": "https://api.github.com/users/ecstatic-morse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ecstatic-morse/subscriptions", "organizations_url": "https://api.github.com/users/ecstatic-morse/orgs", "repos_url": "https://api.github.com/users/ecstatic-morse/repos", "events_url": "https://api.github.com/users/ecstatic-morse/events{/privacy}", "received_events_url": "https://api.github.com/users/ecstatic-morse/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ecstatic-morse", "id": 29463364, "node_id": "MDQ6VXNlcjI5NDYzMzY0", "avatar_url": "https://avatars.githubusercontent.com/u/29463364?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ecstatic-morse", "html_url": "https://github.com/ecstatic-morse", "followers_url": "https://api.github.com/users/ecstatic-morse/followers", "following_url": "https://api.github.com/users/ecstatic-morse/following{/other_user}", "gists_url": "https://api.github.com/users/ecstatic-morse/gists{/gist_id}", "starred_url": "https://api.github.com/users/ecstatic-morse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ecstatic-morse/subscriptions", "organizations_url": "https://api.github.com/users/ecstatic-morse/orgs", "repos_url": "https://api.github.com/users/ecstatic-morse/repos", "events_url": "https://api.github.com/users/ecstatic-morse/events{/privacy}", "received_events_url": "https://api.github.com/users/ecstatic-morse/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "55da0c03680f9ce30423cb640256b11ed6c8cabd", "url": "https://api.github.com/repos/rust-lang/rust/commits/55da0c03680f9ce30423cb640256b11ed6c8cabd", "html_url": "https://github.com/rust-lang/rust/commit/55da0c03680f9ce30423cb640256b11ed6c8cabd"}], "stats": {"total": 1491, "additions": 3, "deletions": 1488}, "files": [{"sha": "6d19cd63bc32ea1ef24a9bd83d0b949d75f7ed22", "filename": "src/librustc_mir/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6d4e2042f9dae20266292c45b2789962873b1d01/src%2Flibrustc_mir%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d4e2042f9dae20266292c45b2789962873b1d01/src%2Flibrustc_mir%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Flib.rs?ref=6d4e2042f9dae20266292c45b2789962873b1d01", "patch": "@@ -32,7 +32,6 @@ Rust MIR: a lowered representation of Rust. Also: an experiment!\n \n #[macro_use] extern crate log;\n #[macro_use] extern crate rustc;\n-#[macro_use] extern crate rustc_data_structures;\n #[macro_use] extern crate syntax;\n \n mod borrow_check;"}, {"sha": "5773d850fbc77ee1e86dfdf2a26ca920cf15883f", "filename": "src/librustc_mir/transform/mod.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/6d4e2042f9dae20266292c45b2789962873b1d01/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d4e2042f9dae20266292c45b2789962873b1d01/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fmod.rs?ref=6d4e2042f9dae20266292c45b2789962873b1d01", "patch": "@@ -25,7 +25,6 @@ pub mod rustc_peek;\n pub mod elaborate_drops;\n pub mod add_call_guards;\n pub mod promote_consts;\n-pub mod qualify_consts;\n pub mod qualify_min_const_fn;\n pub mod remove_noop_landing_pads;\n pub mod dump_mir;\n@@ -238,18 +237,14 @@ fn mir_validated(\n     tcx: TyCtxt<'tcx>,\n     def_id: DefId,\n ) -> (&'tcx Steal<Body<'tcx>>, &'tcx Steal<IndexVec<Promoted, Body<'tcx>>>) {\n-    let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n-    if let hir::BodyOwnerKind::Const = tcx.hir().body_owner_kind(hir_id) {\n-        // Ensure that we compute the `mir_const_qualif` for constants at\n-        // this point, before we steal the mir-const result.\n-        let _ = tcx.mir_const_qualif(def_id);\n-    }\n+    // Ensure that we compute the `mir_const_qualif` for constants at\n+    // this point, before we steal the mir-const result.\n+    let _ = tcx.mir_const_qualif(def_id);\n \n     let mut body = tcx.mir_const(def_id).steal();\n     let promote_pass = promote_consts::PromoteTemps::default();\n     run_passes(tcx, &mut body, InstanceDef::Item(def_id), None, MirPhase::Validated, &[\n         // What we need to run borrowck etc.\n-        &qualify_consts::QualifyAndPromoteConstants::default(),\n         &promote_pass,\n         &simplify::SimplifyCfg::new(\"qualify-consts\"),\n     ]);"}, {"sha": "ee5dfae6ce2512276f7cef70a5247bfe2cef38c4", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "removed", "additions": 0, "deletions": 1479, "changes": 1479, "blob_url": "https://github.com/rust-lang/rust/blob/55da0c03680f9ce30423cb640256b11ed6c8cabd/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55da0c03680f9ce30423cb640256b11ed6c8cabd/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=55da0c03680f9ce30423cb640256b11ed6c8cabd", "patch": "@@ -1,1479 +0,0 @@\n-//! A pass that qualifies constness of temporaries in constants,\n-//! static initializers and functions and also drives promotion.\n-//!\n-//! The Qualif flags below can be used to also provide better\n-//! diagnostics as to why a constant rvalue wasn't promoted.\n-\n-use rustc_index::bit_set::BitSet;\n-use rustc_index::vec::IndexVec;\n-use rustc_target::spec::abi::Abi;\n-use rustc::hir;\n-use rustc::hir::def_id::DefId;\n-use rustc::traits::{self, TraitEngine};\n-use rustc::ty::{self, TyCtxt, Ty, TypeFoldable};\n-use rustc::ty::cast::CastTy;\n-use rustc::ty::query::Providers;\n-use rustc::mir::*;\n-use rustc::mir::visit::{PlaceContext, Visitor, MutatingUseContext, NonMutatingUseContext};\n-use rustc::middle::lang_items;\n-use rustc::session::config::nightly_options;\n-use syntax::feature_gate::{emit_feature_err, GateIssue};\n-use syntax::symbol::sym;\n-use syntax_pos::{Span, DUMMY_SP};\n-\n-use std::borrow::Cow;\n-use std::cell::Cell;\n-use std::fmt;\n-use std::ops::{Deref, Index, IndexMut};\n-use std::usize;\n-\n-use rustc::hir::HirId;\n-use crate::transform::{MirPass, MirSource};\n-use crate::transform::check_consts::ops::{self, NonConstOp};\n-\n-use rustc_error_codes::*;\n-\n-/// What kind of item we are in.\n-#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n-enum Mode {\n-    /// A `static` item.\n-    Static,\n-    /// A `static mut` item.\n-    StaticMut,\n-    /// A `const fn` item.\n-    ConstFn,\n-    /// A `const` item or an anonymous constant (e.g. in array lengths).\n-    Const,\n-    /// Other type of `fn`.\n-    NonConstFn,\n-}\n-\n-impl Mode {\n-    /// Determine whether we have to do full const-checking because syntactically, we\n-    /// are required to be \"const\".\n-    #[inline]\n-    fn requires_const_checking(self) -> bool {\n-        self != Mode::NonConstFn\n-    }\n-}\n-\n-impl fmt::Display for Mode {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match *self {\n-            Mode::Const => write!(f, \"constant\"),\n-            Mode::Static | Mode::StaticMut => write!(f, \"static\"),\n-            Mode::ConstFn => write!(f, \"constant function\"),\n-            Mode::NonConstFn => write!(f, \"function\")\n-        }\n-    }\n-}\n-\n-const QUALIF_COUNT: usize = 2;\n-\n-// FIXME(eddyb) once we can use const generics, replace this array with\n-// something like `IndexVec` but for fixed-size arrays (`IndexArray`?).\n-#[derive(Copy, Clone, Default)]\n-struct PerQualif<T>([T; QUALIF_COUNT]);\n-\n-impl<T: Clone> PerQualif<T> {\n-    fn new(x: T) -> Self {\n-        PerQualif([x.clone(), x])\n-    }\n-}\n-\n-impl<T> PerQualif<T> {\n-    fn as_mut(&mut self) -> PerQualif<&mut T> {\n-        let [x0, x1] = &mut self.0;\n-        PerQualif([x0, x1])\n-    }\n-\n-    fn zip<U>(self, other: PerQualif<U>) -> PerQualif<(T, U)> {\n-        let [x0, x1] = self.0;\n-        let [y0, y1] = other.0;\n-        PerQualif([(x0, y0), (x1, y1)])\n-    }\n-}\n-\n-impl PerQualif<bool> {\n-    fn encode_to_bits(self) -> u8 {\n-        self.0.iter().enumerate().fold(0, |bits, (i, &qualif)| {\n-            bits | ((qualif as u8) << i)\n-        })\n-    }\n-\n-    fn decode_from_bits(bits: u8) -> Self {\n-        let mut qualifs = Self::default();\n-        for (i, qualif) in qualifs.0.iter_mut().enumerate() {\n-            *qualif = (bits & (1 << i)) != 0;\n-        }\n-        qualifs\n-    }\n-}\n-\n-impl<Q: Qualif, T> Index<Q> for PerQualif<T> {\n-    type Output = T;\n-\n-    fn index(&self, _: Q) -> &T {\n-        &self.0[Q::IDX]\n-    }\n-}\n-\n-impl<Q: Qualif, T> IndexMut<Q> for PerQualif<T> {\n-    fn index_mut(&mut self, _: Q) -> &mut T {\n-        &mut self.0[Q::IDX]\n-    }\n-}\n-\n-struct ConstCx<'a, 'tcx> {\n-    tcx: TyCtxt<'tcx>,\n-    param_env: ty::ParamEnv<'tcx>,\n-    mode: Mode,\n-    body: &'a Body<'tcx>,\n-\n-    per_local: PerQualif<BitSet<Local>>,\n-}\n-\n-impl<'a, 'tcx> ConstCx<'a, 'tcx> {\n-    fn is_const_panic_fn(&self, def_id: DefId) -> bool {\n-        Some(def_id) == self.tcx.lang_items().panic_fn() ||\n-        Some(def_id) == self.tcx.lang_items().begin_panic_fn()\n-    }\n-}\n-\n-#[derive(Copy, Clone, Debug)]\n-enum ValueSource<'a, 'tcx> {\n-    Rvalue(&'a Rvalue<'tcx>),\n-    DropAndReplace(&'a Operand<'tcx>),\n-    Call {\n-        callee: &'a Operand<'tcx>,\n-        args: &'a [Operand<'tcx>],\n-        return_ty: Ty<'tcx>,\n-    },\n-}\n-\n-/// A \"qualif\"(-ication) is a way to look for something \"bad\" in the MIR that would disqualify some\n-/// code for promotion or prevent it from evaluating at compile time. So `return true` means\n-/// \"I found something bad, no reason to go on searching\". `false` is only returned if we\n-/// definitely cannot find anything bad anywhere.\n-///\n-/// The default implementations proceed structurally.\n-trait Qualif {\n-    const IDX: usize;\n-\n-    /// Return the qualification that is (conservatively) correct for any value\n-    /// of the type, or `None` if the qualification is not value/type-based.\n-    fn in_any_value_of_ty(_cx: &ConstCx<'_, 'tcx>, _ty: Ty<'tcx>) -> Option<bool> {\n-        None\n-    }\n-\n-    /// Return a mask for the qualification, given a type. This is `false` iff\n-    /// no value of that type can have the qualification.\n-    fn mask_for_ty(cx: &ConstCx<'_, 'tcx>, ty: Ty<'tcx>) -> bool {\n-        Self::in_any_value_of_ty(cx, ty).unwrap_or(true)\n-    }\n-\n-    fn in_local(cx: &ConstCx<'_, '_>, local: Local) -> bool {\n-        cx.per_local.0[Self::IDX].contains(local)\n-    }\n-\n-    fn in_static(_cx: &ConstCx<'_, 'tcx>, _static: &Static<'tcx>) -> bool {\n-        // FIXME(eddyb) should we do anything here for value properties?\n-        false\n-    }\n-\n-    fn in_projection_structurally(\n-        cx: &ConstCx<'_, 'tcx>,\n-        place: PlaceRef<'_, 'tcx>,\n-    ) -> bool {\n-        if let [proj_base @ .., elem] = place.projection {\n-            let base_qualif = Self::in_place(cx, PlaceRef {\n-                base: place.base,\n-                projection: proj_base,\n-            });\n-            let qualif = base_qualif && Self::mask_for_ty(\n-                cx,\n-                Place::ty_from(place.base, proj_base, cx.body, cx.tcx)\n-                    .projection_ty(cx.tcx, elem)\n-                    .ty,\n-            );\n-            match elem {\n-                ProjectionElem::Deref |\n-                ProjectionElem::Subslice { .. } |\n-                ProjectionElem::Field(..) |\n-                ProjectionElem::ConstantIndex { .. } |\n-                ProjectionElem::Downcast(..) => qualif,\n-\n-                // FIXME(eddyb) shouldn't this be masked *after* including the\n-                // index local? Then again, it's `usize` which is neither\n-                // `HasMutInterior` nor `NeedsDrop`.\n-                ProjectionElem::Index(local) => qualif || Self::in_local(cx, *local),\n-            }\n-        } else {\n-            bug!(\"This should be called if projection is not empty\");\n-        }\n-    }\n-\n-    fn in_projection(\n-        cx: &ConstCx<'_, 'tcx>,\n-        place: PlaceRef<'_, 'tcx>,\n-    ) -> bool {\n-        Self::in_projection_structurally(cx, place)\n-    }\n-\n-    fn in_place(cx: &ConstCx<'_, 'tcx>, place: PlaceRef<'_, 'tcx>) -> bool {\n-        match place {\n-            PlaceRef {\n-                base: PlaceBase::Local(local),\n-                projection: [],\n-            } => Self::in_local(cx, *local),\n-            PlaceRef {\n-                base: PlaceBase::Static(box Static {\n-                    kind: StaticKind::Promoted(..),\n-                    ..\n-                }),\n-                projection: [],\n-            } => bug!(\"qualifying already promoted MIR\"),\n-            PlaceRef {\n-                base: PlaceBase::Static(static_),\n-                projection: [],\n-            } => {\n-                Self::in_static(cx, static_)\n-            },\n-            PlaceRef {\n-                base: _,\n-                projection: [.., _],\n-            } => Self::in_projection(cx, place),\n-        }\n-    }\n-\n-    fn in_operand(cx: &ConstCx<'_, 'tcx>, operand: &Operand<'tcx>) -> bool {\n-        match *operand {\n-            Operand::Copy(ref place) |\n-            Operand::Move(ref place) => Self::in_place(cx, place.as_ref()),\n-\n-            Operand::Constant(ref constant) => {\n-                if let ty::ConstKind::Unevaluated(def_id, _) = constant.literal.val {\n-                    // Don't peek inside trait associated constants.\n-                    if cx.tcx.trait_of_item(def_id).is_some() {\n-                        Self::in_any_value_of_ty(cx, constant.literal.ty).unwrap_or(false)\n-                    } else {\n-                        let bits = cx.tcx.at(constant.span).mir_const_qualif(def_id);\n-\n-                        let qualif = PerQualif::decode_from_bits(bits).0[Self::IDX];\n-\n-                        // Just in case the type is more specific than\n-                        // the definition, e.g., impl associated const\n-                        // with type parameters, take it into account.\n-                        qualif && Self::mask_for_ty(cx, constant.literal.ty)\n-                    }\n-                } else {\n-                    false\n-                }\n-            }\n-        }\n-    }\n-\n-    fn in_rvalue_structurally(cx: &ConstCx<'_, 'tcx>, rvalue: &Rvalue<'tcx>) -> bool {\n-        match *rvalue {\n-            Rvalue::NullaryOp(..) => false,\n-\n-            Rvalue::Discriminant(ref place) |\n-            Rvalue::Len(ref place) => Self::in_place(cx, place.as_ref()),\n-\n-            Rvalue::Use(ref operand) |\n-            Rvalue::Repeat(ref operand, _) |\n-            Rvalue::UnaryOp(_, ref operand) |\n-            Rvalue::Cast(_, ref operand, _) => Self::in_operand(cx, operand),\n-\n-            Rvalue::BinaryOp(_, ref lhs, ref rhs) |\n-            Rvalue::CheckedBinaryOp(_, ref lhs, ref rhs) => {\n-                Self::in_operand(cx, lhs) || Self::in_operand(cx, rhs)\n-            }\n-\n-            Rvalue::Ref(_, _, ref place) => {\n-                // Special-case reborrows to be more like a copy of the reference.\n-                if let &[ref proj_base @ .., elem] = place.projection.as_ref() {\n-                    if ProjectionElem::Deref == elem {\n-                        let base_ty = Place::ty_from(&place.base, proj_base, cx.body, cx.tcx).ty;\n-                        if let ty::Ref(..) = base_ty.kind {\n-                            return Self::in_place(cx, PlaceRef {\n-                                base: &place.base,\n-                                projection: proj_base,\n-                            });\n-                        }\n-                    }\n-                }\n-\n-                Self::in_place(cx, place.as_ref())\n-            }\n-\n-            Rvalue::Aggregate(_, ref operands) => {\n-                operands.iter().any(|o| Self::in_operand(cx, o))\n-            }\n-        }\n-    }\n-\n-    fn in_rvalue(cx: &ConstCx<'_, 'tcx>, rvalue: &Rvalue<'tcx>) -> bool {\n-        Self::in_rvalue_structurally(cx, rvalue)\n-    }\n-\n-    fn in_call(\n-        cx: &ConstCx<'_, 'tcx>,\n-        _callee: &Operand<'tcx>,\n-        _args: &[Operand<'tcx>],\n-        return_ty: Ty<'tcx>,\n-    ) -> bool {\n-        // Be conservative about the returned value of a const fn.\n-        Self::in_any_value_of_ty(cx, return_ty).unwrap_or(false)\n-    }\n-\n-    fn in_value(cx: &ConstCx<'_, 'tcx>, source: ValueSource<'_, 'tcx>) -> bool {\n-        match source {\n-            ValueSource::Rvalue(rvalue) => Self::in_rvalue(cx, rvalue),\n-            ValueSource::DropAndReplace(source) => Self::in_operand(cx, source),\n-            ValueSource::Call { callee, args, return_ty } => {\n-                Self::in_call(cx, callee, args, return_ty)\n-            }\n-        }\n-    }\n-}\n-\n-/// Constant containing interior mutability (`UnsafeCell<T>`).\n-/// This must be ruled out to make sure that evaluating the constant at compile-time\n-/// and at *any point* during the run-time would produce the same result. In particular,\n-/// promotion of temporaries must not change program behavior; if the promoted could be\n-/// written to, that would be a problem.\n-struct HasMutInterior;\n-\n-impl Qualif for HasMutInterior {\n-    const IDX: usize = 0;\n-\n-    fn in_any_value_of_ty(cx: &ConstCx<'_, 'tcx>, ty: Ty<'tcx>) -> Option<bool> {\n-        Some(!ty.is_freeze(cx.tcx, cx.param_env, DUMMY_SP))\n-    }\n-\n-    fn in_rvalue(cx: &ConstCx<'_, 'tcx>, rvalue: &Rvalue<'tcx>) -> bool {\n-        match *rvalue {\n-            // Returning `true` for `Rvalue::Ref` indicates the borrow isn't\n-            // allowed in constants (and the `Checker` will error), and/or it\n-            // won't be promoted, due to `&mut ...` or interior mutability.\n-            Rvalue::Ref(_, kind, ref place) => {\n-                let ty = place.ty(cx.body, cx.tcx).ty;\n-\n-                if let BorrowKind::Mut { .. } = kind {\n-                    // In theory, any zero-sized value could be borrowed\n-                    // mutably without consequences. However, only &mut []\n-                    // is allowed right now, and only in functions.\n-                    if cx.mode == Mode::StaticMut {\n-                        // Inside a `static mut`, &mut [...] is also allowed.\n-                        match ty.kind {\n-                            ty::Array(..) | ty::Slice(_) => {}\n-                            _ => return true,\n-                        }\n-                    } else if let ty::Array(_, len) = ty.kind {\n-                        // FIXME(eddyb) the `cx.mode == Mode::NonConstFn` condition\n-                        // seems unnecessary, given that this is merely a ZST.\n-                        match len.try_eval_usize(cx.tcx, cx.param_env) {\n-                            Some(0) if cx.mode == Mode::NonConstFn => {},\n-                            _ => return true,\n-                        }\n-                    } else {\n-                        return true;\n-                    }\n-                }\n-            }\n-\n-            Rvalue::Aggregate(ref kind, _) => {\n-                if let AggregateKind::Adt(def, ..) = **kind {\n-                    if Some(def.did) == cx.tcx.lang_items().unsafe_cell_type() {\n-                        let ty = rvalue.ty(cx.body, cx.tcx);\n-                        assert_eq!(Self::in_any_value_of_ty(cx, ty), Some(true));\n-                        return true;\n-                    }\n-                }\n-            }\n-\n-            _ => {}\n-        }\n-\n-        Self::in_rvalue_structurally(cx, rvalue)\n-    }\n-}\n-\n-/// Constant containing an ADT that implements `Drop`.\n-/// This must be ruled out (a) because we cannot run `Drop` during compile-time\n-/// as that might not be a `const fn`, and (b) because implicit promotion would\n-/// remove side-effects that occur as part of dropping that value.\n-struct NeedsDrop;\n-\n-impl Qualif for NeedsDrop {\n-    const IDX: usize = 1;\n-\n-    fn in_any_value_of_ty(cx: &ConstCx<'_, 'tcx>, ty: Ty<'tcx>) -> Option<bool> {\n-        Some(ty.needs_drop(cx.tcx, cx.param_env))\n-    }\n-\n-    fn in_rvalue(cx: &ConstCx<'_, 'tcx>, rvalue: &Rvalue<'tcx>) -> bool {\n-        if let Rvalue::Aggregate(ref kind, _) = *rvalue {\n-            if let AggregateKind::Adt(def, ..) = **kind {\n-                if def.has_dtor(cx.tcx) {\n-                    return true;\n-                }\n-            }\n-        }\n-\n-        Self::in_rvalue_structurally(cx, rvalue)\n-    }\n-}\n-\n-// Ensure the `IDX` values are sequential (`0..QUALIF_COUNT`).\n-macro_rules! static_assert_seq_qualifs {\n-    ($i:expr => $first:ident $(, $rest:ident)*) => {\n-        static_assert!({\n-            static_assert_seq_qualifs!($i + 1 => $($rest),*);\n-\n-            $first::IDX == $i\n-        });\n-    };\n-    ($i:expr =>) => {\n-        static_assert!(QUALIF_COUNT == $i);\n-    };\n-}\n-static_assert_seq_qualifs!(\n-    0 => HasMutInterior, NeedsDrop\n-);\n-\n-impl ConstCx<'_, 'tcx> {\n-    fn qualifs_in_any_value_of_ty(&self, ty: Ty<'tcx>) -> PerQualif<bool> {\n-        let mut qualifs = PerQualif::default();\n-        qualifs[HasMutInterior] = HasMutInterior::in_any_value_of_ty(self, ty).unwrap_or(false);\n-        qualifs[NeedsDrop] = NeedsDrop::in_any_value_of_ty(self, ty).unwrap_or(false);\n-        qualifs\n-    }\n-\n-    fn qualifs_in_local(&self, local: Local) -> PerQualif<bool> {\n-        let mut qualifs = PerQualif::default();\n-        qualifs[HasMutInterior] = HasMutInterior::in_local(self, local);\n-        qualifs[NeedsDrop] = NeedsDrop::in_local(self, local);\n-        qualifs\n-    }\n-\n-    fn qualifs_in_value(&self, source: ValueSource<'_, 'tcx>) -> PerQualif<bool> {\n-        let mut qualifs = PerQualif::default();\n-        qualifs[HasMutInterior] = HasMutInterior::in_value(self, source);\n-        qualifs[NeedsDrop] = NeedsDrop::in_value(self, source);\n-        qualifs\n-    }\n-}\n-\n-/// Checks MIR for being admissible as a compile-time constant, using `ConstCx`\n-/// for value qualifications, and accumulates writes of\n-/// rvalue/call results to locals, in `local_qualif`.\n-/// It also records candidates for promotion in `promotion_candidates`,\n-/// both in functions and const/static items.\n-struct Checker<'a, 'tcx> {\n-    cx: ConstCx<'a, 'tcx>,\n-\n-    span: Span,\n-    def_id: DefId,\n-\n-    /// If `true`, do not emit errors to the user, merely collect them in `errors`.\n-    suppress_errors: bool,\n-    errors: Vec<(Span, String)>,\n-}\n-\n-macro_rules! unleash_miri {\n-    ($this:expr) => {{\n-        if $this.tcx.sess.opts.debugging_opts.unleash_the_miri_inside_of_you {\n-            if $this.mode.requires_const_checking() && !$this.suppress_errors {\n-                $this.tcx.sess.span_warn($this.span, \"skipping const checks\");\n-            }\n-            return;\n-        }\n-    }}\n-}\n-\n-impl Deref for Checker<'a, 'tcx> {\n-    type Target = ConstCx<'a, 'tcx>;\n-\n-    fn deref(&self) -> &Self::Target {\n-        &self.cx\n-    }\n-}\n-\n-impl<'a, 'tcx> Checker<'a, 'tcx> {\n-    fn new(tcx: TyCtxt<'tcx>, def_id: DefId, body: &'a Body<'tcx>, mode: Mode) -> Self {\n-        assert!(def_id.is_local());\n-\n-        let param_env = tcx.param_env(def_id);\n-\n-        let mut cx = ConstCx {\n-            tcx,\n-            param_env,\n-            mode,\n-            body,\n-            per_local: PerQualif::new(BitSet::new_empty(body.local_decls.len())),\n-        };\n-\n-        for (local, decl) in body.local_decls.iter_enumerated() {\n-            if let LocalKind::Arg = body.local_kind(local) {\n-                let qualifs = cx.qualifs_in_any_value_of_ty(decl.ty);\n-                for (per_local, qualif) in &mut cx.per_local.as_mut().zip(qualifs).0 {\n-                    if *qualif {\n-                        per_local.insert(local);\n-                    }\n-                }\n-            }\n-        }\n-\n-        Checker {\n-            cx,\n-            span: body.span,\n-            def_id,\n-            errors: vec![],\n-            suppress_errors: false,\n-        }\n-    }\n-\n-    // FIXME(eddyb) we could split the errors into meaningful\n-    // categories, but enabling full miri would make that\n-    // slightly pointless (even with feature-gating).\n-    fn not_const(&mut self, op: impl NonConstOp) {\n-        unleash_miri!(self);\n-        if self.mode.requires_const_checking() && !self.suppress_errors {\n-            self.record_error(op);\n-            let mut err = struct_span_err!(\n-                self.tcx.sess,\n-                self.span,\n-                E0019,\n-                \"{} contains unimplemented expression type\",\n-                self.mode\n-            );\n-            if self.tcx.sess.teach(&err.get_code().unwrap()) {\n-                err.note(\"A function call isn't allowed in the const's initialization expression \\\n-                          because the expression's value must be known at compile-time.\");\n-                err.note(\"Remember: you can't use a function call inside a const's initialization \\\n-                          expression! However, you can use it anywhere else.\");\n-            }\n-            err.emit();\n-        }\n-    }\n-\n-    fn record_error(&mut self, op: impl NonConstOp) {\n-        self.record_error_spanned(op, self.span);\n-    }\n-\n-    fn record_error_spanned(&mut self, op: impl NonConstOp, span: Span) {\n-        self.errors.push((span, format!(\"{:?}\", op)));\n-    }\n-\n-    /// Assigns an rvalue/call qualification to the given destination.\n-    fn assign(&mut self, dest: &Place<'tcx>, source: ValueSource<'_, 'tcx>, location: Location) {\n-        trace!(\"assign: {:?} <- {:?}\", dest, source);\n-\n-        let mut qualifs = self.qualifs_in_value(source);\n-\n-        match source {\n-            ValueSource::Rvalue(&Rvalue::Ref(_, kind, _)) => {\n-                // Getting `true` from `HasMutInterior::in_rvalue` means\n-                // the borrowed place is disallowed from being borrowed,\n-                // due to either a mutable borrow (with some exceptions),\n-                // or an shared borrow of a value with interior mutability.\n-                // Then `HasMutInterior` is cleared\n-                // to avoid duplicate errors (e.g. from reborrowing).\n-                if qualifs[HasMutInterior] {\n-                    qualifs[HasMutInterior] = false;\n-\n-                    debug!(\"suppress_errors: {}\", self.suppress_errors);\n-                    if self.mode.requires_const_checking() && !self.suppress_errors {\n-                        if !self.tcx.sess.opts.debugging_opts.unleash_the_miri_inside_of_you {\n-                            self.record_error(ops::MutBorrow(kind));\n-                            if let BorrowKind::Mut { .. } = kind {\n-                                let mut err = struct_span_err!(self.tcx.sess,  self.span, E0017,\n-                                                               \"references in {}s may only refer \\\n-                                                                to immutable values\", self.mode);\n-                                err.span_label(self.span, format!(\"{}s require immutable values\",\n-                                                                    self.mode));\n-                                if self.tcx.sess.teach(&err.get_code().unwrap()) {\n-                                    err.note(\"References in statics and constants may only refer \\\n-                                              to immutable values.\\n\\n\\\n-                                              Statics are shared everywhere, and if they refer to \\\n-                                              mutable data one might violate memory safety since \\\n-                                              holding multiple mutable references to shared data \\\n-                                              is not allowed.\\n\\n\\\n-                                              If you really want global mutable state, try using \\\n-                                              static mut or a global UnsafeCell.\");\n-                                }\n-                                err.emit();\n-                            } else {\n-                                span_err!(self.tcx.sess, self.span, E0492,\n-                                          \"cannot borrow a constant which may contain \\\n-                                           interior mutability, create a static instead\");\n-                            }\n-                        }\n-                    }\n-                }\n-            },\n-            _ => {},\n-        }\n-\n-        let mut dest_projection = &dest.projection[..];\n-        let index = loop {\n-            match (&dest.base, dest_projection) {\n-                // We treat all locals equal in constants\n-                (&PlaceBase::Local(index), []) => break index,\n-                // projections are transparent for assignments\n-                // we qualify the entire destination at once, even if just a field would have\n-                // stricter qualification\n-                (base, [proj_base @ .., _]) => {\n-                    // Catch more errors in the destination. `visit_place` also checks various\n-                    // projection rules like union field access and raw pointer deref\n-                    let context = PlaceContext::MutatingUse(MutatingUseContext::Store);\n-                    self.visit_place_base(base, context, location);\n-                    self.visit_projection(base, dest_projection, context, location);\n-                    dest_projection = proj_base;\n-                },\n-                (&PlaceBase::Static(box Static {\n-                    kind: StaticKind::Promoted(..),\n-                    ..\n-                }), []) => bug!(\"promoteds don't exist yet during promotion\"),\n-                (&PlaceBase::Static(box Static{ kind: _, .. }), []) => {\n-                    // Catch more errors in the destination. `visit_place` also checks that we\n-                    // do not try to access statics from constants or try to mutate statics\n-                    let context = PlaceContext::MutatingUse(MutatingUseContext::Store);\n-                    self.visit_place_base(&dest.base, context, location);\n-                    return;\n-                }\n-            }\n-        };\n-\n-        let kind = self.body.local_kind(index);\n-        debug!(\"store to {:?} {:?}\", kind, index);\n-\n-        // this is overly restrictive, because even full assignments do not clear the qualif\n-        // While we could special case full assignments, this would be inconsistent with\n-        // aggregates where we overwrite all fields via assignments, which would not get\n-        // that feature.\n-        for (per_local, qualif) in &mut self.cx.per_local.as_mut().zip(qualifs).0 {\n-            if *qualif {\n-                per_local.insert(index);\n-            }\n-        }\n-    }\n-\n-    /// Check a whole const, static initializer or const fn.\n-    fn check_const(&mut self) -> u8 {\n-        use crate::transform::check_consts as new_checker;\n-\n-        debug!(\"const-checking {} {:?}\", self.mode, self.def_id);\n-\n-        // FIXME: Also use the new validator when features that require it (e.g. `const_if`) are\n-        // enabled.\n-        let use_new_validator = self.tcx.sess.opts.debugging_opts.unleash_the_miri_inside_of_you;\n-        if use_new_validator {\n-            debug!(\"Using dataflow-based const validator\");\n-        }\n-\n-        let item = new_checker::Item::new(self.tcx, self.def_id, self.body);\n-        let mut validator = new_checker::validation::Validator::new(&item);\n-\n-        validator.suppress_errors = !use_new_validator;\n-        self.suppress_errors = use_new_validator;\n-\n-        let body = self.body;\n-\n-        let mut seen_blocks = BitSet::new_empty(body.basic_blocks().len());\n-        let mut bb = START_BLOCK;\n-        loop {\n-            seen_blocks.insert(bb.index());\n-\n-            self.visit_basic_block_data(bb, &body[bb]);\n-            validator.visit_basic_block_data(bb, &body[bb]);\n-\n-            let target = match body[bb].terminator().kind {\n-                TerminatorKind::Goto { target } |\n-                TerminatorKind::FalseUnwind { real_target: target, .. } |\n-                TerminatorKind::Drop { target, .. } |\n-                TerminatorKind::DropAndReplace { target, .. } |\n-                TerminatorKind::Assert { target, .. } |\n-                TerminatorKind::Call { destination: Some((_, target)), .. } => {\n-                    Some(target)\n-                }\n-\n-                // Non-terminating calls cannot produce any value.\n-                TerminatorKind::Call { destination: None, .. } => {\n-                    break;\n-                }\n-\n-                TerminatorKind::SwitchInt {..} |\n-                TerminatorKind::Resume |\n-                TerminatorKind::Abort |\n-                TerminatorKind::GeneratorDrop |\n-                TerminatorKind::Yield { .. } |\n-                TerminatorKind::Unreachable |\n-                TerminatorKind::FalseEdges { .. } => None,\n-\n-                TerminatorKind::Return => {\n-                    break;\n-                }\n-            };\n-\n-            match target {\n-                // No loops allowed.\n-                Some(target) if !seen_blocks.contains(target.index()) => {\n-                    bb = target;\n-                }\n-                _ => {\n-                    if !self.tcx.sess.opts.debugging_opts.unleash_the_miri_inside_of_you {\n-                        self.tcx.sess.delay_span_bug(\n-                            self.span,\n-                            \"complex control flow is forbidden in a const context\",\n-                        );\n-                    }\n-                    break;\n-                }\n-            }\n-        }\n-\n-        // The new validation pass should agree with the old when running on simple const bodies\n-        // (e.g. no `if` or `loop`).\n-        if !use_new_validator {\n-            let mut new_errors = validator.take_errors();\n-\n-            // FIXME: each checker sometimes emits the same error with the same span twice in a row.\n-            self.errors.dedup();\n-            new_errors.dedup();\n-\n-            if self.errors != new_errors {\n-                validator_mismatch(\n-                    self.tcx,\n-                    body,\n-                    std::mem::replace(&mut self.errors, vec![]),\n-                    new_errors,\n-                );\n-            }\n-        }\n-\n-        self.qualifs_in_local(RETURN_PLACE).encode_to_bits()\n-    }\n-}\n-\n-impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n-    fn visit_place_base(\n-        &mut self,\n-        place_base: &PlaceBase<'tcx>,\n-        context: PlaceContext,\n-        location: Location,\n-    ) {\n-        self.super_place_base(place_base, context, location);\n-        match place_base {\n-            PlaceBase::Local(_) => {}\n-            PlaceBase::Static(box Static{ kind: StaticKind::Promoted(_, _), .. }) => {\n-                unreachable!()\n-            }\n-            PlaceBase::Static(box Static{ kind: StaticKind::Static, def_id, .. }) => {\n-                if self.tcx\n-                        .get_attrs(*def_id)\n-                        .iter()\n-                        .any(|attr| attr.check_name(sym::thread_local)) {\n-                    if self.mode.requires_const_checking() && !self.suppress_errors {\n-                        self.record_error(ops::ThreadLocalAccess);\n-                        span_err!(self.tcx.sess, self.span, E0625,\n-                                    \"thread-local statics cannot be \\\n-                                    accessed at compile-time\");\n-                    }\n-                    return;\n-                }\n-\n-                // Only allow statics (not consts) to refer to other statics.\n-                if self.mode == Mode::Static || self.mode == Mode::StaticMut {\n-                    return;\n-                }\n-                unleash_miri!(self);\n-\n-                if self.mode.requires_const_checking() && !self.suppress_errors {\n-                    self.record_error(ops::StaticAccess);\n-                    let mut err = struct_span_err!(self.tcx.sess, self.span, E0013,\n-                                                    \"{}s cannot refer to statics, use \\\n-                                                    a constant instead\", self.mode);\n-                    if self.tcx.sess.teach(&err.get_code().unwrap()) {\n-                        err.note(\n-                            \"Static and const variables can refer to other const variables. \\\n-                                But a const variable cannot refer to a static variable.\"\n-                        );\n-                        err.help(\n-                            \"To fix this, the value can be extracted as a const and then used.\"\n-                        );\n-                    }\n-                    err.emit()\n-                }\n-            }\n-        }\n-    }\n-\n-    fn visit_projection_elem(\n-        &mut self,\n-        place_base: &PlaceBase<'tcx>,\n-        proj_base: &[PlaceElem<'tcx>],\n-        elem: &PlaceElem<'tcx>,\n-        context: PlaceContext,\n-        location: Location,\n-    ) {\n-        debug!(\n-            \"visit_projection_elem: place_base={:?} proj_base={:?} elem={:?} \\\n-            context={:?} location={:?}\",\n-            place_base,\n-            proj_base,\n-            elem,\n-            context,\n-            location,\n-        );\n-\n-        self.super_projection_elem(place_base, proj_base, elem, context, location);\n-\n-        match elem {\n-            ProjectionElem::Deref => {\n-                if context.is_mutating_use() {\n-                    // `not_const` errors out in const contexts\n-                    self.not_const(ops::MutDeref)\n-                }\n-                let base_ty = Place::ty_from(place_base, proj_base, self.body, self.tcx).ty;\n-                match self.mode {\n-                    Mode::NonConstFn => {}\n-                    _ if self.suppress_errors => {}\n-                    _ => {\n-                        if let ty::RawPtr(_) = base_ty.kind {\n-                            if !self.tcx.features().const_raw_ptr_deref {\n-                                self.record_error(ops::RawPtrDeref);\n-                                emit_feature_err(\n-                                    &self.tcx.sess.parse_sess, sym::const_raw_ptr_deref,\n-                                    self.span, GateIssue::Language,\n-                                    &format!(\n-                                        \"dereferencing raw pointers in {}s is unstable\",\n-                                        self.mode,\n-                                    ),\n-                                );\n-                            }\n-                        }\n-                    }\n-                }\n-            }\n-\n-            ProjectionElem::ConstantIndex {..} |\n-            ProjectionElem::Subslice {..} |\n-            ProjectionElem::Field(..) |\n-            ProjectionElem::Index(_) => {\n-                let base_ty = Place::ty_from(place_base, proj_base, self.body, self.tcx).ty;\n-                if let Some(def) = base_ty.ty_adt_def() {\n-                    if def.is_union() {\n-                        match self.mode {\n-                            Mode::ConstFn => {\n-                                if !self.tcx.features().const_fn_union\n-                                    && !self.suppress_errors\n-                                {\n-                                    self.record_error(ops::UnionAccess);\n-                                    emit_feature_err(\n-                                        &self.tcx.sess.parse_sess, sym::const_fn_union,\n-                                        self.span, GateIssue::Language,\n-                                        \"unions in const fn are unstable\",\n-                                    );\n-                                }\n-                            },\n-\n-                            | Mode::NonConstFn\n-                            | Mode::Static\n-                            | Mode::StaticMut\n-                            | Mode::Const\n-                            => {},\n-                        }\n-                    }\n-                }\n-            }\n-\n-            ProjectionElem::Downcast(..) => {\n-                self.not_const(ops::Downcast)\n-            }\n-        }\n-    }\n-\n-    fn visit_operand(&mut self, operand: &Operand<'tcx>, location: Location) {\n-        debug!(\"visit_operand: operand={:?} location={:?}\", operand, location);\n-        self.super_operand(operand, location);\n-\n-        match *operand {\n-            Operand::Move(ref place) => {\n-                // Mark the consumed locals to indicate later drops are noops.\n-                if let Some(local) = place.as_local() {\n-                    self.cx.per_local[NeedsDrop].remove(local);\n-                }\n-            }\n-            Operand::Copy(_) |\n-            Operand::Constant(_) => {}\n-        }\n-    }\n-\n-    fn visit_rvalue(&mut self, rvalue: &Rvalue<'tcx>, location: Location) {\n-        debug!(\"visit_rvalue: rvalue={:?} location={:?}\", rvalue, location);\n-\n-        // Check nested operands and places.\n-        if let Rvalue::Ref(_, kind, ref place) = *rvalue {\n-            // Special-case reborrows.\n-            let mut reborrow_place = None;\n-            if let &[ref proj_base @ .., elem] = place.projection.as_ref() {\n-                if elem == ProjectionElem::Deref {\n-                    let base_ty = Place::ty_from(&place.base, proj_base, self.body, self.tcx).ty;\n-                    if let ty::Ref(..) = base_ty.kind {\n-                        reborrow_place = Some(proj_base);\n-                    }\n-                }\n-            }\n-\n-            if let Some(proj) = reborrow_place {\n-                let ctx = match kind {\n-                    BorrowKind::Shared => PlaceContext::NonMutatingUse(\n-                        NonMutatingUseContext::SharedBorrow,\n-                    ),\n-                    BorrowKind::Shallow => PlaceContext::NonMutatingUse(\n-                        NonMutatingUseContext::ShallowBorrow,\n-                    ),\n-                    BorrowKind::Unique => PlaceContext::NonMutatingUse(\n-                        NonMutatingUseContext::UniqueBorrow,\n-                    ),\n-                    BorrowKind::Mut { .. } => PlaceContext::MutatingUse(\n-                        MutatingUseContext::Borrow,\n-                    ),\n-                };\n-                self.visit_place_base(&place.base, ctx, location);\n-                self.visit_projection(&place.base, proj, ctx, location);\n-            } else {\n-                self.super_rvalue(rvalue, location);\n-            }\n-        } else {\n-            self.super_rvalue(rvalue, location);\n-        }\n-\n-        match *rvalue {\n-            Rvalue::Use(_) |\n-            Rvalue::Repeat(..) |\n-            Rvalue::UnaryOp(UnOp::Neg, _) |\n-            Rvalue::UnaryOp(UnOp::Not, _) |\n-            Rvalue::NullaryOp(NullOp::SizeOf, _) |\n-            Rvalue::CheckedBinaryOp(..) |\n-            Rvalue::Cast(CastKind::Pointer(_), ..) |\n-            Rvalue::Discriminant(..) |\n-            Rvalue::Len(_) |\n-            Rvalue::Ref(..) |\n-            Rvalue::Aggregate(..) => {}\n-\n-            Rvalue::Cast(CastKind::Misc, ref operand, cast_ty) => {\n-                let operand_ty = operand.ty(self.body, self.tcx);\n-                let cast_in = CastTy::from_ty(operand_ty).expect(\"bad input type for cast\");\n-                let cast_out = CastTy::from_ty(cast_ty).expect(\"bad output type for cast\");\n-                match (cast_in, cast_out) {\n-                    (CastTy::Ptr(_), CastTy::Int(_)) |\n-                    (CastTy::FnPtr, CastTy::Int(_)) if self.mode != Mode::NonConstFn => {\n-                        unleash_miri!(self);\n-                        if !self.tcx.features().const_raw_ptr_to_usize_cast\n-                            && !self.suppress_errors\n-                        {\n-                            // in const fn and constants require the feature gate\n-                            // FIXME: make it unsafe inside const fn and constants\n-                            self.record_error(ops::RawPtrToIntCast);\n-                            emit_feature_err(\n-                                &self.tcx.sess.parse_sess, sym::const_raw_ptr_to_usize_cast,\n-                                self.span, GateIssue::Language,\n-                                &format!(\n-                                    \"casting pointers to integers in {}s is unstable\",\n-                                    self.mode,\n-                                ),\n-                            );\n-                        }\n-                    }\n-                    _ => {}\n-                }\n-            }\n-\n-            Rvalue::BinaryOp(op, ref lhs, _) => {\n-                if let ty::RawPtr(_) | ty::FnPtr(..) = lhs.ty(self.body, self.tcx).kind {\n-                    assert!(op == BinOp::Eq || op == BinOp::Ne ||\n-                            op == BinOp::Le || op == BinOp::Lt ||\n-                            op == BinOp::Ge || op == BinOp::Gt ||\n-                            op == BinOp::Offset);\n-\n-                    unleash_miri!(self);\n-                    if self.mode.requires_const_checking() &&\n-                        !self.tcx.features().const_compare_raw_pointers &&\n-                        !self.suppress_errors\n-                    {\n-                        self.record_error(ops::RawPtrComparison);\n-                        // require the feature gate inside constants and const fn\n-                        // FIXME: make it unsafe to use these operations\n-                        emit_feature_err(\n-                            &self.tcx.sess.parse_sess,\n-                            sym::const_compare_raw_pointers,\n-                            self.span,\n-                            GateIssue::Language,\n-                            &format!(\"comparing raw pointers inside {}\", self.mode),\n-                        );\n-                    }\n-                }\n-            }\n-\n-            Rvalue::NullaryOp(NullOp::Box, _) => {\n-                unleash_miri!(self);\n-                if self.mode.requires_const_checking() && !self.suppress_errors {\n-                    self.record_error(ops::HeapAllocation);\n-                    let mut err = struct_span_err!(self.tcx.sess, self.span, E0010,\n-                                                   \"allocations are not allowed in {}s\", self.mode);\n-                    err.span_label(self.span, format!(\"allocation not allowed in {}s\", self.mode));\n-                    if self.tcx.sess.teach(&err.get_code().unwrap()) {\n-                        err.note(\n-                            \"The value of statics and constants must be known at compile time, \\\n-                             and they live for the entire lifetime of a program. Creating a boxed \\\n-                             value allocates memory on the heap at runtime, and therefore cannot \\\n-                             be done at compile time.\"\n-                        );\n-                    }\n-                    err.emit();\n-                }\n-            }\n-        }\n-    }\n-\n-    fn visit_terminator_kind(&mut self,\n-                             kind: &TerminatorKind<'tcx>,\n-                             location: Location) {\n-        debug!(\"visit_terminator_kind: kind={:?} location={:?}\", kind, location);\n-        if let TerminatorKind::Call { ref func, ref args, ref destination, .. } = *kind {\n-            if let Some((ref dest, _)) = *destination {\n-                self.assign(dest, ValueSource::Call {\n-                    callee: func,\n-                    args,\n-                    return_ty: dest.ty(self.body, self.tcx).ty,\n-                }, location);\n-            }\n-\n-            let fn_ty = func.ty(self.body, self.tcx);\n-            match fn_ty.kind {\n-                ty::FnDef(def_id, _) => {\n-                    match self.tcx.fn_sig(def_id).abi() {\n-                        Abi::RustIntrinsic |\n-                        Abi::PlatformIntrinsic => {\n-                            assert!(!self.tcx.is_const_fn(def_id));\n-                            match &*self.tcx.item_name(def_id).as_str() {\n-                                // special intrinsic that can be called diretly without an intrinsic\n-                                // feature gate needs a language feature gate\n-                                \"transmute\" => {\n-                                    if self.mode.requires_const_checking()\n-                                        && !self.suppress_errors\n-                                    {\n-                                        // const eval transmute calls only with the feature gate\n-                                        if !self.tcx.features().const_transmute {\n-                                            self.record_error(ops::Transmute);\n-                                            emit_feature_err(\n-                                                &self.tcx.sess.parse_sess, sym::const_transmute,\n-                                                self.span, GateIssue::Language,\n-                                                &format!(\"The use of std::mem::transmute() \\\n-                                                is gated in {}s\", self.mode));\n-                                        }\n-                                    }\n-                                }\n-\n-                                // no need to check feature gates, intrinsics are only callable\n-                                // from the libstd or with forever unstable feature gates\n-                                _ => {}\n-                            }\n-                        }\n-                        _ => {\n-                            // In normal functions no calls are feature-gated.\n-                            if self.mode.requires_const_checking() {\n-                                let unleash_miri = self\n-                                    .tcx\n-                                    .sess\n-                                    .opts\n-                                    .debugging_opts\n-                                    .unleash_the_miri_inside_of_you;\n-                                if self.tcx.is_const_fn(def_id)\n-                                    || unleash_miri\n-                                    || self.suppress_errors\n-                                {\n-                                    // stable const fns or unstable const fns\n-                                    // with their feature gate active\n-                                    // FIXME(eddyb) move stability checks from `is_const_fn` here.\n-                                } else if self.is_const_panic_fn(def_id) {\n-                                    // Check the const_panic feature gate.\n-                                    // FIXME: cannot allow this inside `allow_internal_unstable`\n-                                    // because that would make `panic!` insta stable in constants,\n-                                    // since the macro is marked with the attribute.\n-                                    if !self.tcx.features().const_panic {\n-                                        // Don't allow panics in constants without the feature gate.\n-                                        self.record_error(ops::Panic);\n-                                        emit_feature_err(\n-                                            &self.tcx.sess.parse_sess,\n-                                            sym::const_panic,\n-                                            self.span,\n-                                            GateIssue::Language,\n-                                            &format!(\"panicking in {}s is unstable\", self.mode),\n-                                        );\n-                                    }\n-                                } else if let Some(feature)\n-                                              = self.tcx.is_unstable_const_fn(def_id) {\n-                                    // Check `#[unstable]` const fns or `#[rustc_const_unstable]`\n-                                    // functions without the feature gate active in this crate in\n-                                    // order to report a better error message than the one below.\n-                                    if !self.span.allows_unstable(feature) {\n-                                        self.record_error(ops::FnCallUnstable(def_id, feature));\n-                                        let mut err = self.tcx.sess.struct_span_err(self.span,\n-                                            &format!(\"`{}` is not yet stable as a const fn\",\n-                                                    self.tcx.def_path_str(def_id)));\n-                                        if nightly_options::is_nightly_build() {\n-                                            help!(&mut err,\n-                                                  \"add `#![feature({})]` to the \\\n-                                                   crate attributes to enable\",\n-                                                  feature);\n-                                        }\n-                                        err.emit();\n-                                    }\n-                                } else {\n-                                    self.record_error(ops::FnCallNonConst(def_id));\n-                                    let mut err = struct_span_err!(\n-                                        self.tcx.sess,\n-                                        self.span,\n-                                        E0015,\n-                                        \"calls in {}s are limited to constant functions, \\\n-                                         tuple structs and tuple variants\",\n-                                        self.mode,\n-                                    );\n-                                    err.emit();\n-                                }\n-                            }\n-                        }\n-                    }\n-                }\n-                ty::FnPtr(_) => {\n-                    unleash_miri!(self);\n-                    if self.mode.requires_const_checking() && !self.suppress_errors {\n-                        self.record_error(ops::FnCallIndirect);\n-                        let mut err = self.tcx.sess.struct_span_err(\n-                            self.span,\n-                            \"function pointers are not allowed in const fn\"\n-                        );\n-                        err.emit();\n-                    }\n-                }\n-                _ => {\n-                    self.not_const(ops::FnCallOther);\n-                }\n-            }\n-\n-            // Check callee and argument operands.\n-            self.visit_operand(func, location);\n-            for arg in args {\n-                self.visit_operand(arg, location);\n-            }\n-        } else if let TerminatorKind::Drop {\n-            location: ref place, ..\n-        } | TerminatorKind::DropAndReplace {\n-            location: ref place, ..\n-        } = *kind {\n-            match *kind {\n-                TerminatorKind::DropAndReplace { .. } => {}\n-                _ => self.super_terminator_kind(kind, location),\n-            }\n-\n-            // Deny *any* live drops anywhere other than functions.\n-            if self.mode.requires_const_checking() && !self.suppress_errors {\n-                unleash_miri!(self);\n-                // HACK(eddyb): emulate a bit of dataflow analysis,\n-                // conservatively, that drop elaboration will do.\n-                let needs_drop = if let Some(local) = place.as_local() {\n-                    if NeedsDrop::in_local(self, local) {\n-                        Some(self.body.local_decls[local].source_info.span)\n-                    } else {\n-                        None\n-                    }\n-                } else {\n-                    Some(self.span)\n-                };\n-\n-                if let Some(span) = needs_drop {\n-                    // Double-check the type being dropped, to minimize false positives.\n-                    let ty = place.ty(self.body, self.tcx).ty;\n-                    if ty.needs_drop(self.tcx, self.param_env) {\n-                        self.record_error_spanned(ops::LiveDrop, span);\n-                        struct_span_err!(self.tcx.sess, span, E0493,\n-                                         \"destructors cannot be evaluated at compile-time\")\n-                            .span_label(span, format!(\"{}s cannot evaluate destructors\",\n-                                                      self.mode))\n-                            .emit();\n-                    }\n-                }\n-            }\n-\n-            match *kind {\n-                TerminatorKind::DropAndReplace { ref value, .. } => {\n-                    self.assign(place, ValueSource::DropAndReplace(value), location);\n-                    self.visit_operand(value, location);\n-                }\n-                _ => {}\n-            }\n-        } else {\n-            // Qualify any operands inside other terminators.\n-            self.super_terminator_kind(kind, location);\n-        }\n-    }\n-\n-    fn visit_assign(&mut self,\n-                    dest: &Place<'tcx>,\n-                    rvalue: &Rvalue<'tcx>,\n-                    location: Location) {\n-        debug!(\"visit_assign: dest={:?} rvalue={:?} location={:?}\", dest, rvalue, location);\n-        self.assign(dest, ValueSource::Rvalue(rvalue), location);\n-\n-        self.visit_rvalue(rvalue, location);\n-    }\n-\n-    fn visit_source_info(&mut self, source_info: &SourceInfo) {\n-        debug!(\"visit_source_info: source_info={:?}\", source_info);\n-        self.span = source_info.span;\n-    }\n-\n-    fn visit_statement(&mut self, statement: &Statement<'tcx>, location: Location) {\n-        debug!(\"visit_statement: statement={:?} location={:?}\", statement, location);\n-        match statement.kind {\n-            StatementKind::Assign(..) => {\n-                self.super_statement(statement, location);\n-            }\n-            StatementKind::FakeRead(FakeReadCause::ForMatchedPlace, _) => {\n-                if !self.tcx.sess.opts.debugging_opts.unleash_the_miri_inside_of_you {\n-                    self.tcx.sess.delay_span_bug(\n-                        self.span,\n-                        \"complex control flow is forbidden in a const context\",\n-                    );\n-                }\n-            }\n-            // FIXME(eddyb) should these really do nothing?\n-            StatementKind::FakeRead(..) |\n-            StatementKind::SetDiscriminant { .. } |\n-            StatementKind::StorageLive(_) |\n-            StatementKind::StorageDead(_) |\n-            StatementKind::InlineAsm {..} |\n-            StatementKind::Retag { .. } |\n-            StatementKind::AscribeUserType(..) |\n-            StatementKind::Nop => {}\n-        }\n-    }\n-}\n-\n-pub fn provide(providers: &mut Providers<'_>) {\n-    *providers = Providers {\n-        mir_const_qualif,\n-        ..*providers\n-    };\n-}\n-\n-// FIXME(eddyb) this is only left around for the validation logic\n-// in `promote_consts`, see the comment in `validate_operand`.\n-pub(super) const QUALIF_ERROR_BIT: u8 = 1 << 2;\n-\n-fn mir_const_qualif(tcx: TyCtxt<'_>, def_id: DefId) -> u8 {\n-    // N.B., this `borrow()` is guaranteed to be valid (i.e., the value\n-    // cannot yet be stolen), because `mir_validated()`, which steals\n-    // from `mir_const(), forces this query to execute before\n-    // performing the steal.\n-    let body = &tcx.mir_const(def_id).borrow();\n-\n-    if body.return_ty().references_error() {\n-        tcx.sess.delay_span_bug(body.span, \"mir_const_qualif: MIR had errors\");\n-        return 0;\n-    }\n-\n-    Checker::new(tcx, def_id, body, Mode::Const).check_const()\n-}\n-\n-pub struct QualifyAndPromoteConstants<'tcx> {\n-    pub promoted: Cell<IndexVec<Promoted, Body<'tcx>>>,\n-}\n-\n-impl<'tcx> Default for QualifyAndPromoteConstants<'tcx> {\n-    fn default() -> Self {\n-        QualifyAndPromoteConstants {\n-            promoted: Cell::new(IndexVec::new()),\n-        }\n-    }\n-}\n-\n-impl<'tcx> MirPass<'tcx> for QualifyAndPromoteConstants<'tcx> {\n-    fn run_pass(&self, tcx: TyCtxt<'tcx>, src: MirSource<'tcx>, body: &mut Body<'tcx>) {\n-        // There's not really any point in promoting errorful MIR.\n-        if body.return_ty().references_error() {\n-            tcx.sess.delay_span_bug(body.span, \"QualifyAndPromoteConstants: MIR had errors\");\n-            return;\n-        }\n-\n-        if src.promoted.is_some() {\n-            return;\n-        }\n-\n-        let def_id = src.def_id();\n-        let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n-\n-        let mode = determine_mode(tcx, hir_id, def_id);\n-\n-        debug!(\"run_pass: mode={:?}\", mode);\n-        if let Mode::NonConstFn = mode {\n-            // No need to const-check a non-const `fn` now that we don't do promotion here.\n-            return;\n-        } else if let Mode::ConstFn = mode {\n-            let mut checker = Checker::new(tcx, def_id, body, mode);\n-            let use_min_const_fn_checks =\n-                !tcx.sess.opts.debugging_opts.unleash_the_miri_inside_of_you &&\n-                tcx.is_min_const_fn(def_id);\n-            if use_min_const_fn_checks {\n-                // Enforce `min_const_fn` for stable `const fn`s.\n-                use super::qualify_min_const_fn::is_min_const_fn;\n-                if let Err((span, err)) = is_min_const_fn(tcx, def_id, body) {\n-                    error_min_const_fn_violation(tcx, span, err);\n-                    return;\n-                }\n-            }\n-\n-            // `check_const` should not produce any errors, but better safe than sorry\n-            // FIXME(#53819)\n-            // Enforce a constant-like CFG for `const fn`.\n-            checker.check_const();\n-        } else {\n-            check_short_circuiting_in_const_local(tcx, body, mode);\n-\n-            match mode {\n-                Mode::Const => tcx.mir_const_qualif(def_id),\n-                _ => Checker::new(tcx, def_id, body, mode).check_const(),\n-            };\n-        }\n-\n-        if mode == Mode::Static && !tcx.has_attr(def_id, sym::thread_local) {\n-            // `static`s (not `static mut`s) which are not `#[thread_local]` must be `Sync`.\n-            check_static_is_sync(tcx, body, hir_id);\n-        }\n-    }\n-}\n-\n-fn determine_mode(tcx: TyCtxt<'_>, hir_id: HirId, def_id: DefId) -> Mode {\n-    match tcx.hir().body_owner_kind(hir_id) {\n-        hir::BodyOwnerKind::Closure => Mode::NonConstFn,\n-        hir::BodyOwnerKind::Fn if tcx.is_const_fn(def_id) => Mode::ConstFn,\n-        hir::BodyOwnerKind::Fn => Mode::NonConstFn,\n-        hir::BodyOwnerKind::Const => Mode::Const,\n-        hir::BodyOwnerKind::Static(hir::Mutability::Immutable) => Mode::Static,\n-        hir::BodyOwnerKind::Static(hir::Mutability::Mutable) => Mode::StaticMut,\n-    }\n-}\n-\n-fn error_min_const_fn_violation(tcx: TyCtxt<'_>, span: Span, msg: Cow<'_, str>) {\n-    struct_span_err!(tcx.sess, span, E0723, \"{}\", msg)\n-        .note(\"for more information, see issue https://github.com/rust-lang/rust/issues/57563\")\n-        .help(\"add `#![feature(const_fn)]` to the crate attributes to enable\")\n-        .emit();\n-}\n-\n-fn check_short_circuiting_in_const_local(tcx: TyCtxt<'_>, body: &mut Body<'tcx>, mode: Mode) {\n-    if body.control_flow_destroyed.is_empty() {\n-        return;\n-    }\n-\n-    let mut locals = body.vars_iter();\n-    if let Some(local) = locals.next() {\n-        let span = body.local_decls[local].source_info.span;\n-        let mut error = tcx.sess.struct_span_err(\n-            span,\n-            &format!(\n-                \"new features like let bindings are not permitted in {}s \\\n-                which also use short circuiting operators\",\n-                mode,\n-            ),\n-        );\n-        for (span, kind) in body.control_flow_destroyed.iter() {\n-            error.span_note(\n-                *span,\n-                &format!(\"use of {} here does not actually short circuit due to \\\n-                the const evaluator presently not being able to do control flow. \\\n-                See https://github.com/rust-lang/rust/issues/49146 for more \\\n-                information.\", kind),\n-            );\n-        }\n-        for local in locals {\n-            let span = body.local_decls[local].source_info.span;\n-            error.span_note(span, \"more locals defined here\");\n-        }\n-        error.emit();\n-    }\n-}\n-\n-fn check_static_is_sync(tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>, hir_id: HirId) {\n-    let ty = body.return_ty();\n-    tcx.infer_ctxt().enter(|infcx| {\n-        let cause = traits::ObligationCause::new(body.span, hir_id, traits::SharedStatic);\n-        let mut fulfillment_cx = traits::FulfillmentContext::new();\n-        let sync_def_id = tcx.require_lang_item(lang_items::SyncTraitLangItem, Some(body.span));\n-        fulfillment_cx.register_bound(&infcx, ty::ParamEnv::empty(), ty, sync_def_id, cause);\n-        if let Err(err) = fulfillment_cx.select_all_or_error(&infcx) {\n-            infcx.report_fulfillment_errors(&err, None, false);\n-        }\n-    });\n-}\n-\n-fn validator_mismatch(\n-    tcx: TyCtxt<'tcx>,\n-    body: &Body<'tcx>,\n-    mut old_errors: Vec<(Span, String)>,\n-    mut new_errors: Vec<(Span, String)>,\n-) {\n-    error!(\"old validator: {:?}\", old_errors);\n-    error!(\"new validator: {:?}\", new_errors);\n-\n-    // ICE on nightly if the validators do not emit exactly the same errors.\n-    // Users can supress this panic with an unstable compiler flag (hopefully after\n-    // filing an issue).\n-    let opts = &tcx.sess.opts;\n-    let strict_validation_enabled = opts.unstable_features.is_nightly_build()\n-        && !opts.debugging_opts.suppress_const_validation_back_compat_ice;\n-\n-    if !strict_validation_enabled {\n-        return;\n-    }\n-\n-    // If this difference would cause a regression from the old to the new or vice versa, trigger\n-    // the ICE.\n-    if old_errors.is_empty() || new_errors.is_empty() {\n-        span_bug!(body.span, \"{}\", VALIDATOR_MISMATCH_ERR);\n-    }\n-\n-    // HACK: Borrows that would allow mutation are forbidden in const contexts, but they cause the\n-    // new validator to be more conservative about when a dropped local has been moved out of.\n-    //\n-    // Supress the mismatch ICE in cases where the validators disagree only on the number of\n-    // `LiveDrop` errors and both observe the same sequence of `MutBorrow`s.\n-\n-    let is_live_drop = |(_, s): &mut (_, String)| s.starts_with(\"LiveDrop\");\n-    let is_mut_borrow = |(_, s): &&(_, String)| s.starts_with(\"MutBorrow\");\n-\n-    let old_live_drops: Vec<_> = old_errors.drain_filter(is_live_drop).collect();\n-    let new_live_drops: Vec<_> = new_errors.drain_filter(is_live_drop).collect();\n-\n-    let only_live_drops_differ = old_live_drops != new_live_drops && old_errors == new_errors;\n-\n-    let old_mut_borrows = old_errors.iter().filter(is_mut_borrow);\n-    let new_mut_borrows = new_errors.iter().filter(is_mut_borrow);\n-\n-    let at_least_one_mut_borrow = old_mut_borrows.clone().next().is_some();\n-\n-    if only_live_drops_differ && at_least_one_mut_borrow && old_mut_borrows.eq(new_mut_borrows) {\n-        return;\n-    }\n-\n-    span_bug!(body.span, \"{}\", VALIDATOR_MISMATCH_ERR);\n-}\n-\n-const VALIDATOR_MISMATCH_ERR: &str =\n-    r\"Disagreement between legacy and dataflow-based const validators.\n-    After filing an issue, use `-Zsuppress-const-validation-back-compat-ice` to compile your code.\";"}]}