{"sha": "5fb1140688ae9e8a0cfc9d90a00f7dad4935e029", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVmYjExNDA2ODhhZTllOGEwY2ZjOWQ5MGEwMGY3ZGFkNDkzNWUwMjk=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2017-03-27T22:14:47Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2017-03-27T22:14:47Z"}, "message": "fallout - source reformatting", "tree": {"sha": "861133499fd946915cfd2c49dbaa3e4976ea46a9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/861133499fd946915cfd2c49dbaa3e4976ea46a9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5fb1140688ae9e8a0cfc9d90a00f7dad4935e029", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5fb1140688ae9e8a0cfc9d90a00f7dad4935e029", "html_url": "https://github.com/rust-lang/rust/commit/5fb1140688ae9e8a0cfc9d90a00f7dad4935e029", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5fb1140688ae9e8a0cfc9d90a00f7dad4935e029/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a079b87e7c7a937bd689e51af5c2c2b4ba690ca7", "url": "https://api.github.com/repos/rust-lang/rust/commits/a079b87e7c7a937bd689e51af5c2c2b4ba690ca7", "html_url": "https://github.com/rust-lang/rust/commit/a079b87e7c7a937bd689e51af5c2c2b4ba690ca7"}], "stats": {"total": 1184, "additions": 752, "deletions": 432}, "files": [{"sha": "ae40ffc16c9180b4027cc68f62ded0a7e77ad578", "filename": "src/bin/cargo-fmt.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5fb1140688ae9e8a0cfc9d90a00f7dad4935e029/src%2Fbin%2Fcargo-fmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fb1140688ae9e8a0cfc9d90a00f7dad4935e029/src%2Fbin%2Fcargo-fmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Fcargo-fmt.rs?ref=5fb1140688ae9e8a0cfc9d90a00f7dad4935e029", "patch": "@@ -110,7 +110,10 @@ fn format_crate(verbosity: Verbosity) -> Result<ExitStatus, std::io::Error> {\n \n fn get_fmt_args() -> Vec<String> {\n     // All arguments after -- are passed to rustfmt\n-    env::args().skip_while(|a| a != \"--\").skip(1).collect()\n+    env::args()\n+        .skip_while(|a| a != \"--\")\n+        .skip(1)\n+        .collect()\n }\n \n #[derive(Debug)]\n@@ -143,7 +146,9 @@ pub struct Target {\n // Returns a vector of all compile targets of a crate\n fn get_targets() -> Result<Vec<Target>, std::io::Error> {\n     let mut targets: Vec<Target> = vec![];\n-    let output = try!(Command::new(\"cargo\").arg(\"read-manifest\").output());\n+    let output = try!(Command::new(\"cargo\")\n+                          .arg(\"read-manifest\")\n+                          .output());\n     if output.status.success() {\n         // None of the unwraps should fail if output of `cargo read-manifest` is correct\n         let data = &String::from_utf8(output.stdout).unwrap();"}, {"sha": "a108f9ba8d06e4ee7dfded46bbc7c2a513c2a458", "filename": "src/bin/rustfmt.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5fb1140688ae9e8a0cfc9d90a00f7dad4935e029/src%2Fbin%2Frustfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fb1140688ae9e8a0cfc9d90a00f7dad4935e029/src%2Fbin%2Frustfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Frustfmt.rs?ref=5fb1140688ae9e8a0cfc9d90a00f7dad4935e029", "patch": "@@ -311,7 +311,10 @@ fn main() {\n fn print_usage(opts: &Options, reason: &str) {\n     let reason = format!(\"{}\\nusage: {} [options] <file>...\",\n                          reason,\n-                         env::args_os().next().unwrap().to_string_lossy());\n+                         env::args_os()\n+                             .next()\n+                             .unwrap()\n+                             .to_string_lossy());\n     println!(\"{}\", opts.usage(&reason));\n }\n "}, {"sha": "568f23e5d7245ac7838d18b3465117f9f8fdc876", "filename": "src/chains.rs", "status": "modified", "additions": 39, "deletions": 25, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/5fb1140688ae9e8a0cfc9d90a00f7dad4935e029/src%2Fchains.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fb1140688ae9e8a0cfc9d90a00f7dad4935e029/src%2Fchains.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fchains.rs?ref=5fb1140688ae9e8a0cfc9d90a00f7dad4935e029", "patch": "@@ -141,7 +141,10 @@ pub fn rewrite_chain(expr: &ast::Expr, context: &RewriteContext, shape: Shape) -\n         match context.config.chain_indent {\n             IndentStyle::Visual => other_child_shape,\n             IndentStyle::Block => {\n-                shape.offset = shape.offset.checked_sub(context.config.tab_spaces).unwrap_or(0);\n+                shape.offset = shape\n+                    .offset\n+                    .checked_sub(context.config.tab_spaces)\n+                    .unwrap_or(0);\n                 shape.indent.block_indent += context.config.tab_spaces;\n                 shape\n             }\n@@ -154,29 +157,39 @@ pub fn rewrite_chain(expr: &ast::Expr, context: &RewriteContext, shape: Shape) -\n            other_child_shape);\n \n     let child_shape_iter =\n-        Some(first_child_shape).into_iter().chain(::std::iter::repeat(other_child_shape)\n-                                                      .take(subexpr_list.len() - 1));\n-    let iter = subexpr_list.iter().rev().zip(child_shape_iter);\n+        Some(first_child_shape)\n+            .into_iter()\n+            .chain(::std::iter::repeat(other_child_shape).take(subexpr_list.len() - 1));\n+    let iter = subexpr_list\n+        .iter()\n+        .rev()\n+        .zip(child_shape_iter);\n     let mut rewrites =\n         try_opt!(iter.map(|(e, shape)| rewrite_chain_subexpr(e, total_span, context, shape))\n                      .collect::<Option<Vec<_>>>());\n \n     // Total of all items excluding the last.\n-    let almost_total = rewrites[..rewrites.len() - 1].iter().fold(0, |a, b| {\n-        a + first_line_width(b)\n-    }) + parent_rewrite.len();\n+    let almost_total = rewrites[..rewrites.len() - 1]\n+        .iter()\n+        .fold(0, |a, b| a + first_line_width(b)) + parent_rewrite.len();\n     let one_line_len = rewrites.iter().fold(0, |a, r| a + r.len() + 1) + parent_rewrite.len();\n \n-    let veto_single_line = if one_line_len > context.config.chain_one_line_max - 1 && rewrites.len() > 1 {\n+    let veto_single_line = if one_line_len > context.config.chain_one_line_max - 1 &&\n+                              rewrites.len() > 1 {\n         true\n     } else if context.config.take_source_hints && subexpr_list.len() > 1 {\n         // Look at the source code. Unless all chain elements start on the same\n         // line, we won't consider putting them on a single line either.\n         let last_span = context.snippet(mk_sp(subexpr_list[1].span.hi, total_span.hi));\n         let first_span = context.snippet(subexpr_list[1].span);\n-        let last_iter = last_span.chars().take_while(|c| c.is_whitespace());\n-\n-        first_span.chars().chain(last_iter).any(|c| c == '\\n')\n+        let last_iter = last_span\n+            .chars()\n+            .take_while(|c| c.is_whitespace());\n+\n+        first_span\n+            .chars()\n+            .chain(last_iter)\n+            .any(|c| c == '\\n')\n     } else {\n         false\n     };\n@@ -228,11 +241,13 @@ pub fn rewrite_chain(expr: &ast::Expr, context: &RewriteContext, shape: Shape) -\n \n // True if the chain is only `?`s.\n fn chain_only_try(exprs: &[ast::Expr]) -> bool {\n-    exprs.iter().all(|e| if let ast::ExprKind::Try(_) = e.node {\n-                         true\n-                     } else {\n-                         false\n-                     })\n+    exprs\n+        .iter()\n+        .all(|e| if let ast::ExprKind::Try(_) = e.node {\n+                 true\n+             } else {\n+                 false\n+             })\n }\n \n pub fn rewrite_try(expr: &ast::Expr,\n@@ -243,7 +258,9 @@ pub fn rewrite_try(expr: &ast::Expr,\n     let sub_expr = try_opt!(expr.rewrite(context, try_opt!(shape.sub_width(try_count))));\n     Some(format!(\"{}{}\",\n                  sub_expr,\n-                 iter::repeat(\"?\").take(try_count).collect::<String>()))\n+                 iter::repeat(\"?\")\n+                     .take(try_count)\n+                     .collect::<String>()))\n }\n \n fn join_rewrites(rewrites: &[String], subexps: &[ast::Expr], connector: &str) -> String {\n@@ -417,21 +434,18 @@ fn rewrite_method_call(method_name: ast::Ident,\n     let (lo, type_str) = if types.is_empty() {\n         (args[0].span.hi, String::new())\n     } else {\n-        let type_list: Vec<_> =\n-            try_opt!(types.iter().map(|ty| ty.rewrite(context, shape)).collect());\n+        let type_list: Vec<_> = try_opt!(types\n+                                             .iter()\n+                                             .map(|ty| ty.rewrite(context, shape))\n+                                             .collect());\n \n         let type_str = if context.config.spaces_within_angle_brackets && type_list.len() > 0 {\n             format!(\"::< {} >\", type_list.join(\", \"))\n         } else {\n             format!(\"::<{}>\", type_list.join(\", \"))\n         };\n \n-        (types\n-             .last()\n-             .unwrap()\n-             .span\n-             .hi,\n-         type_str)\n+        (types.last().unwrap().span.hi, type_str)\n     };\n \n     let callee_str = format!(\".{}{}\", method_name, type_str);"}, {"sha": "d04169c936e0f25e27f9ccd242000e36a54fda7b", "filename": "src/codemap.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5fb1140688ae9e8a0cfc9d90a00f7dad4935e029/src%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fb1140688ae9e8a0cfc9d90a00f7dad4935e029/src%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcodemap.rs?ref=5fb1140688ae9e8a0cfc9d90a00f7dad4935e029", "patch": "@@ -26,10 +26,7 @@ pub struct LineRange {\n \n impl LineRange {\n     pub fn file_name(&self) -> &str {\n-        self.file\n-            .as_ref()\n-            .name\n-            .as_str()\n+        self.file.as_ref().name.as_str()\n     }\n }\n "}, {"sha": "3973c7fc048e69a1405ffc55aa6f68b019567fdd", "filename": "src/comment.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5fb1140688ae9e8a0cfc9d90a00f7dad4935e029/src%2Fcomment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fb1140688ae9e8a0cfc9d90a00f7dad4935e029/src%2Fcomment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomment.rs?ref=5fb1140688ae9e8a0cfc9d90a00f7dad4935e029", "patch": "@@ -84,7 +84,10 @@ pub fn rewrite_comment(orig: &str,\n             (\"// \", \"\", \"// \")\n         };\n \n-    let max_chars = shape.width.checked_sub(closer.len() + opener.len()).unwrap_or(1);\n+    let max_chars = shape\n+        .width\n+        .checked_sub(closer.len() + opener.len())\n+        .unwrap_or(1);\n     let indent_str = shape.indent.to_string(config);\n     let fmt = StringFormat {\n         opener: \"\",\n@@ -597,9 +600,9 @@ fn changed_comment_content(orig: &str, new: &str) -> bool {\n     // Cannot write this as a fn since we cannot return types containing closures\n     let code_comment_content = |code| {\n         let slices = UngroupedCommentCodeSlices::new(code);\n-        slices.filter(|&(ref kind, _, _)| *kind == CodeCharKind::Comment).flat_map(|(_, _, s)| {\n-            CommentReducer::new(s)\n-        })\n+        slices\n+            .filter(|&(ref kind, _, _)| *kind == CodeCharKind::Comment)\n+            .flat_map(|(_, _, s)| CommentReducer::new(s))\n     };\n     let res = code_comment_content(orig).ne(code_comment_content(new));\n     debug!(\"comment::changed_comment_content: {}\\norig: '{}'\\nnew: '{}'\\nraw_old: {}\\nraw_new: {}\","}, {"sha": "6d05b757d06ef48f5ad785833ddaaa8dd8b3a76b", "filename": "src/expr.rs", "status": "modified", "additions": 148, "deletions": 60, "changes": 208, "blob_url": "https://github.com/rust-lang/rust/blob/5fb1140688ae9e8a0cfc9d90a00f7dad4935e029/src%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fb1140688ae9e8a0cfc9d90a00f7dad4935e029/src%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fexpr.rs?ref=5fb1140688ae9e8a0cfc9d90a00f7dad4935e029", "patch": "@@ -272,8 +272,10 @@ pub fn rewrite_pair<LHS, RHS>(lhs: &LHS,\n             if let Some(lhs_result) = lhs_result {\n                 let mut result = format!(\"{}{}{}\", prefix, lhs_result, infix);\n \n-                let remaining_width =\n-                    shape.width.checked_sub(last_line_width(&result)).unwrap_or(0);\n+                let remaining_width = shape\n+                    .width\n+                    .checked_sub(last_line_width(&result))\n+                    .unwrap_or(0);\n \n                 if rhs_result.len() <= remaining_width {\n                     result.push_str(&rhs_result);\n@@ -301,9 +303,11 @@ pub fn rewrite_pair<LHS, RHS>(lhs: &LHS,\n \n     // Re-evaluate the rhs because we have more space now:\n     let infix = infix.trim_right();\n-    let lhs_budget = try_opt!(context.config.max_width.checked_sub(shape.used_width() +\n-                                                                   prefix.len() +\n-                                                                   infix.len()));\n+    let lhs_budget = try_opt!(context\n+                                  .config\n+                                  .max_width\n+                                  .checked_sub(shape.used_width() + prefix.len() +\n+                                               infix.len()));\n     let rhs_shape = try_opt!(shape.sub_width(suffix.len() + prefix.len()))\n         .visual_indent(prefix.len());\n \n@@ -336,9 +340,15 @@ pub fn rewrite_array<'a, I>(expr_iter: I,\n     };\n \n     let nested_shape = match context.config.array_layout {\n-        IndentStyle::Block => shape.block().block_indent(context.config.tab_spaces),\n+        IndentStyle::Block => {\n+            shape\n+                .block()\n+                .block_indent(context.config.tab_spaces)\n+        }\n         IndentStyle::Visual => {\n-            try_opt!(shape.visual_indent(bracket_size).sub_width(bracket_size * 2))\n+            try_opt!(shape\n+                         .visual_indent(bracket_size)\n+                         .sub_width(bracket_size * 2))\n         }\n     };\n \n@@ -450,7 +460,10 @@ fn rewrite_closure(capture: ast::CaptureBy,\n                                  body.span.lo);\n     let item_vec = arg_items.collect::<Vec<_>>();\n     // 1 = space between arguments and return type.\n-    let horizontal_budget = nested_shape.width.checked_sub(ret_str.len() + 1).unwrap_or(0);\n+    let horizontal_budget = nested_shape\n+        .width\n+        .checked_sub(ret_str.len() + 1)\n+        .unwrap_or(0);\n     let tactic = definitive_tactic(&item_vec, ListTactic::HorizontalVertical, horizontal_budget);\n     let arg_shape = match tactic {\n         DefinitiveListTactic::Horizontal => try_opt!(arg_shape.sub_width(ret_str.len() + 1)),\n@@ -579,7 +592,9 @@ fn and_one_line(x: Option<String>) -> Option<String> {\n fn nop_block_collapse(block_str: Option<String>, budget: usize) -> Option<String> {\n     debug!(\"nop_block_collapse {:?} {}\", block_str, budget);\n     block_str.map(|block_str| if block_str.starts_with('{') && budget >= 2 &&\n-                                 (block_str[1..].find(|c: char| !c.is_whitespace()).unwrap() ==\n+                                 (block_str[1..]\n+                                      .find(|c: char| !c.is_whitespace())\n+                                      .unwrap() ==\n                                   block_str.len() - 2) {\n                       \"{}\".to_owned()\n                   } else {\n@@ -887,7 +902,10 @@ impl<'a> Rewrite for ControlFlow<'a> {\n             label_string.len() + self.keyword.len() + pat_expr_string.len() + 2\n         };\n \n-        let block_width = shape.width.checked_sub(used_width).unwrap_or(0);\n+        let block_width = shape\n+            .width\n+            .checked_sub(used_width)\n+            .unwrap_or(0);\n         // This is used only for the empty block case: `{}`. So, we use 1 if we know\n         // we should avoid the single line case.\n         let block_width = if self.else_block.is_some() || self.nested_if {\n@@ -910,11 +928,16 @@ impl<'a> Rewrite for ControlFlow<'a> {\n \n         // for event in event\n         let between_kwd_cond =\n-            mk_sp(context.codemap.span_after(self.span, self.keyword.trim()),\n-                  self.pat.map_or(cond_span.lo, |p| if self.matcher.is_empty() {\n+            mk_sp(context\n+                      .codemap\n+                      .span_after(self.span, self.keyword.trim()),\n+                  self.pat\n+                      .map_or(cond_span.lo, |p| if self.matcher.is_empty() {\n                 p.span.lo\n             } else {\n-                context.codemap.span_before(self.span, self.matcher.trim())\n+                context\n+                    .codemap\n+                    .span_before(self.span, self.matcher.trim())\n             }));\n \n         let between_kwd_cond_comment = extract_comment(between_kwd_cond, context, shape);\n@@ -923,7 +946,10 @@ impl<'a> Rewrite for ControlFlow<'a> {\n             extract_comment(mk_sp(cond_span.hi, self.block.span.lo), context, shape);\n \n         let alt_block_sep = String::from(\"\\n\") +\n-                            &shape.indent.block_only().to_string(context.config);\n+                            &shape\n+                                 .indent\n+                                 .block_only()\n+                                 .to_string(context.config);\n         let block_sep = if self.cond.is_none() && between_kwd_cond_comment.is_some() {\n             \"\"\n         } else if context.config.control_brace_style ==\n@@ -936,15 +962,19 @@ impl<'a> Rewrite for ControlFlow<'a> {\n         let mut result = format!(\"{}{}{}{}{}{}\",\n                                  label_string,\n                                  self.keyword,\n-                                 between_kwd_cond_comment.as_ref().map_or(if\n-            pat_expr_string.is_empty() || pat_expr_string.starts_with('\\n') {\n-                                                                              \"\"\n-                                                                          } else {\n-                                                                              \" \"\n-                                                                          },\n-                                                                          |s| &**s),\n+                                 between_kwd_cond_comment\n+                                     .as_ref()\n+                                     .map_or(if pat_expr_string.is_empty() ||\n+                                                pat_expr_string.starts_with('\\n') {\n+                                                 \"\"\n+                                             } else {\n+                                                 \" \"\n+                                             },\n+                                             |s| &**s),\n                                  pat_expr_string,\n-                                 after_cond_comment.as_ref().map_or(block_sep, |s| &**s),\n+                                 after_cond_comment\n+                                     .as_ref()\n+                                     .map_or(block_sep, |s| &**s),\n                                  block_str);\n \n         if let Some(else_block) = self.else_block {\n@@ -991,15 +1021,17 @@ impl<'a> Rewrite for ControlFlow<'a> {\n \n             let between_kwd_else_block =\n                 mk_sp(self.block.span.hi,\n-                      context.codemap.span_before(mk_sp(self.block.span.hi, else_block.span.lo),\n-                                                  \"else\"));\n+                      context\n+                          .codemap\n+                          .span_before(mk_sp(self.block.span.hi, else_block.span.lo), \"else\"));\n             let between_kwd_else_block_comment =\n                 extract_comment(between_kwd_else_block, context, shape);\n \n-            let after_else = mk_sp(context.codemap.span_after(mk_sp(self.block.span.hi,\n-                                                                    else_block.span.lo),\n-                                                              \"else\"),\n-                                   else_block.span.lo);\n+            let after_else =\n+                mk_sp(context\n+                          .codemap\n+                          .span_after(mk_sp(self.block.span.hi, else_block.span.lo), \"else\"),\n+                      else_block.span.lo);\n             let after_else_comment = extract_comment(after_else, context, shape);\n \n             let between_sep = match context.config.control_brace_style {\n@@ -1013,8 +1045,12 @@ impl<'a> Rewrite for ControlFlow<'a> {\n             };\n             try_opt!(write!(&mut result,\n                             \"{}else{}\",\n-                            between_kwd_else_block_comment.as_ref().map_or(between_sep, |s| &**s),\n-                            after_else_comment.as_ref().map_or(after_sep, |s| &**s))\n+                            between_kwd_else_block_comment\n+                                .as_ref()\n+                                .map_or(between_sep, |s| &**s),\n+                            after_else_comment\n+                                .as_ref()\n+                                .map_or(after_sep, |s| &**s))\n                              .ok());\n             result.push_str(&try_opt!(rewrite));\n         }\n@@ -1096,12 +1132,19 @@ fn rewrite_match_arm_comment(context: &RewriteContext,\n \n     let mut result = String::new();\n     // any text not preceeded by a newline is pushed unmodified to the block\n-    let first_brk = missed_str.find(|c: char| c == '\\n').unwrap_or(0);\n+    let first_brk = missed_str\n+        .find(|c: char| c == '\\n')\n+        .unwrap_or(0);\n     result.push_str(&missed_str[..first_brk]);\n     let missed_str = &missed_str[first_brk..]; // If missed_str had one newline, it starts with it\n \n-    let first = missed_str.find(|c: char| !c.is_whitespace()).unwrap_or(missed_str.len());\n-    if missed_str[..first].chars().filter(|c| c == &'\\n').count() >= 2 {\n+    let first = missed_str\n+        .find(|c: char| !c.is_whitespace())\n+        .unwrap_or(missed_str.len());\n+    if missed_str[..first]\n+           .chars()\n+           .filter(|c| c == &'\\n')\n+           .count() >= 2 {\n         // Excessive vertical whitespace before comment should be preserved\n         // FIXME handle vertical whitespace better\n         result.push('\\n');\n@@ -1131,7 +1174,11 @@ fn rewrite_match(context: &RewriteContext,\n     let cond_shape = try_opt!(shape.shrink_left(6));\n     let cond_shape = try_opt!(cond_shape.sub_width(2));\n     let cond_str = try_opt!(cond.rewrite(context, cond_shape));\n-    let alt_block_sep = String::from(\"\\n\") + &shape.indent.block_only().to_string(context.config);\n+    let alt_block_sep = String::from(\"\\n\") +\n+                        &shape\n+                             .indent\n+                             .block_only()\n+                             .to_string(context.config);\n     let block_sep = match context.config.control_brace_style {\n         ControlBraceStyle::AlwaysSameLine => \" \",\n         _ => alt_block_sep.as_str(),\n@@ -1146,8 +1193,9 @@ fn rewrite_match(context: &RewriteContext,\n \n     let arm_indent_str = arm_shape.indent.to_string(context.config);\n \n-    let open_brace_pos = context.codemap.span_after(mk_sp(cond.span.hi, arm_start_pos(&arms[0])),\n-                                                    \"{\");\n+    let open_brace_pos = context\n+        .codemap\n+        .span_after(mk_sp(cond.span.hi, arm_start_pos(&arms[0])), \"{\");\n \n     for (i, arm) in arms.iter().enumerate() {\n         // Make sure we get the stuff between arms.\n@@ -1257,7 +1305,10 @@ impl Rewrite for ast::Arm {\n                                     .collect::<Option<Vec<_>>>());\n \n         let all_simple = pat_strs.iter().all(|p| pat_is_simple(p));\n-        let items: Vec<_> = pat_strs.into_iter().map(ListItem::from_str).collect();\n+        let items: Vec<_> = pat_strs\n+            .into_iter()\n+            .map(ListItem::from_str)\n+            .collect();\n         let fmt = ListFormatting {\n             tactic: if all_simple {\n                 DefinitiveListTactic::Mixed\n@@ -1303,7 +1354,10 @@ impl Rewrite for ast::Arm {\n \n         let comma = arm_comma(&context.config, body);\n         let alt_block_sep = String::from(\"\\n\") +\n-                            &shape.indent.block_only().to_string(context.config);\n+                            &shape\n+                                 .indent\n+                                 .block_only()\n+                                 .to_string(context.config);\n \n         let pat_width = extra_offset(&pats_str, shape);\n         // Let's try and get the arm body on the same line as the condition.\n@@ -1347,7 +1401,10 @@ impl Rewrite for ast::Arm {\n             .block_indent(context.config.tab_spaces);\n         let next_line_body = try_opt!(nop_block_collapse(body.rewrite(context, body_shape),\n                                                          body_shape.width));\n-        let indent_str = shape.indent.block_indent(context.config).to_string(context.config);\n+        let indent_str = shape\n+            .indent\n+            .block_indent(context.config)\n+            .to_string(context.config);\n         let (body_prefix, body_suffix) = if context.config.wrap_match_arms {\n             if context.config.match_block_trailing_comma {\n                 (\"{\", \"},\")\n@@ -1390,7 +1447,10 @@ impl Rewrite for ast::Arm {\n // E.g. `Foo::Bar` is simple, but `Foo(..)` is not.\n fn pat_is_simple(pat_str: &str) -> bool {\n     pat_str.len() <= 16 ||\n-    (pat_str.len() <= 24 && pat_str.chars().all(|c| c.is_alphabetic() || c == ':'))\n+    (pat_str.len() <= 24 &&\n+     pat_str\n+         .chars()\n+         .all(|c| c.is_alphabetic() || c == ':'))\n }\n \n // The `if ...` guard on a match arm.\n@@ -1418,7 +1478,10 @@ fn rewrite_guard(context: &RewriteContext,\n         }\n \n         // Not enough space to put the guard after the pattern, try a newline.\n-        let overhead = shape.indent.block_indent(context.config).width() + 4 + 5;\n+        let overhead = shape\n+            .indent\n+            .block_indent(context.config)\n+            .width() + 4 + 5;\n         if overhead < shape.width {\n             let cond_str = guard.rewrite(context,\n                                          Shape::legacy(shape.width - overhead,\n@@ -1493,7 +1556,10 @@ fn rewrite_pat_expr(context: &RewriteContext,\n         }\n     }\n \n-    let nested_indent = shape.indent.block_only().block_indent(context.config);\n+    let nested_indent = shape\n+        .indent\n+        .block_only()\n+        .block_indent(context.config);\n \n     // The expression won't fit on the current line, jump to next.\n     result.push('\\n');\n@@ -1621,7 +1687,11 @@ fn rewrite_call_inner<R>(context: &RewriteContext,\n                 .sub_width(context.config.tab_spaces)\n         }\n         // 1 = (, 2 = ().\n-        IndentStyle::Visual => shape.visual_indent(used_width + 1).sub_width(used_width + 2),\n+        IndentStyle::Visual => {\n+            shape\n+                .visual_indent(used_width + 1)\n+                .sub_width(used_width + 2)\n+        }\n     };\n     let nested_shape = match nested_shape {\n         Some(s) => s,\n@@ -1658,7 +1728,9 @@ fn rewrite_call_inner<R>(context: &RewriteContext,\n             indent: nested_shape.indent.block_only(),\n             ..nested_shape\n         };\n-        let rewrite = args.last().unwrap().rewrite(context, nested_shape);\n+        let rewrite = args.last()\n+            .unwrap()\n+            .rewrite(context, nested_shape);\n \n         if let Some(rewrite) = rewrite {\n             let rewrite_first_line = Some(rewrite[..first_line_width(&rewrite)].to_owned());\n@@ -1749,7 +1821,10 @@ fn rewrite_index(expr: &ast::Expr,\n         (\"[\", \"]\")\n     };\n \n-    let budget = shape.width.checked_sub(expr_str.len() + lbr.len() + rbr.len()).unwrap_or(0);\n+    let budget = shape\n+        .width\n+        .checked_sub(expr_str.len() + lbr.len() + rbr.len())\n+        .unwrap_or(0);\n     let index_str = index.rewrite(context, Shape::legacy(budget, shape.indent));\n     if let Some(index_str) = index_str {\n         return Some(format!(\"{}{}{}{}\", expr_str, lbr, index_str, rbr));\n@@ -1759,8 +1834,10 @@ fn rewrite_index(expr: &ast::Expr,\n     let indent = indent.to_string(&context.config);\n     // FIXME this is not right, since we don't take into account that shape.width\n     // might be reduced from max_width by something on the right.\n-    let budget = try_opt!(context.config.max_width.checked_sub(indent.len() + lbr.len() +\n-                                                               rbr.len()));\n+    let budget = try_opt!(context\n+                              .config\n+                              .max_width\n+                              .checked_sub(indent.len() + lbr.len() + rbr.len()));\n     let index_str = try_opt!(index.rewrite(context, Shape::legacy(budget, shape.indent)));\n     Some(format!(\"{}\\n{}{}{}{}\", expr_str, indent, lbr, index_str, rbr))\n }\n@@ -1787,17 +1864,20 @@ fn rewrite_struct_lit<'a>(context: &RewriteContext,\n         return Some(format!(\"{} {{}}\", path_str));\n     }\n \n-    let field_iter =\n-        fields.into_iter().map(StructLitField::Regular).chain(base.into_iter()\n-                                                                  .map(StructLitField::Base));\n+    let field_iter = fields\n+        .into_iter()\n+        .map(StructLitField::Regular)\n+        .chain(base.into_iter().map(StructLitField::Base));\n \n     // Foo { a: Foo } - indent is +3, width is -5.\n     let (h_shape, v_shape) = try_opt!(struct_lit_shape(shape, context, path_str.len() + 3, 2));\n \n     let span_lo = |item: &StructLitField| match *item {\n         StructLitField::Regular(field) => field.span.lo,\n         StructLitField::Base(expr) => {\n-            let last_field_hi = fields.last().map_or(span.lo, |field| field.span.hi);\n+            let last_field_hi = fields\n+                .last()\n+                .map_or(span.lo, |field| field.span.hi);\n             let snippet = context.snippet(mk_sp(last_field_hi, expr.span.lo));\n             let pos = snippet.find_uncommented(\"..\").unwrap();\n             last_field_hi + BytePos(pos as u32)\n@@ -1814,7 +1894,8 @@ fn rewrite_struct_lit<'a>(context: &RewriteContext,\n         }\n         StructLitField::Base(expr) => {\n             // 2 = ..\n-            expr.rewrite(context, try_opt!(v_shape.shrink_left(2))).map(|s| format!(\"..{}\", s))\n+            expr.rewrite(context, try_opt!(v_shape.shrink_left(2)))\n+                .map(|s| format!(\"..{}\", s))\n         }\n     };\n \n@@ -1876,11 +1957,14 @@ fn rewrite_field(context: &RewriteContext, field: &ast::Field, shape: Shape) ->\n             Some(e) => Some(format!(\"{}{}{}\", name, separator, e)),\n             None => {\n                 let expr_offset = shape.indent.block_indent(context.config);\n-                let expr = field.expr.rewrite(context,\n-                                              Shape::legacy(try_opt!(context.config\n+                let expr = field\n+                    .expr\n+                    .rewrite(context,\n+                             Shape::legacy(try_opt!(context\n+                                                        .config\n                                                         .max_width\n                                                         .checked_sub(expr_offset.width())),\n-                                                            expr_offset));\n+                                           expr_offset));\n                 expr.map(|s| format!(\"{}:\\n{}{}\", name, expr_offset.to_string(&context.config), s))\n             }\n         }\n@@ -1937,7 +2021,9 @@ pub fn rewrite_unary_prefix<R: Rewrite>(context: &RewriteContext,\n                                         shape: Shape)\n                                         -> Option<String> {\n     let shape = try_opt!(shape.shrink_left(prefix.len())).visual_indent(0);\n-    rewrite.rewrite(context, shape).map(|r| format!(\"{}{}\", prefix, r))\n+    rewrite\n+        .rewrite(context, shape)\n+        .map(|r| format!(\"{}{}\", prefix, r))\n }\n \n // FIXME: this is probably not correct for multi-line Rewrites. we should\n@@ -1947,10 +2033,12 @@ pub fn rewrite_unary_suffix<R: Rewrite>(context: &RewriteContext,\n                                         rewrite: &R,\n                                         shape: Shape)\n                                         -> Option<String> {\n-    rewrite.rewrite(context, try_opt!(shape.sub_width(suffix.len()))).map(|mut r| {\n-                                                                              r.push_str(suffix);\n-                                                                              r\n-                                                                          })\n+    rewrite\n+        .rewrite(context, try_opt!(shape.sub_width(suffix.len())))\n+        .map(|mut r| {\n+                 r.push_str(suffix);\n+                 r\n+             })\n }\n \n fn rewrite_unary_op(context: &RewriteContext,"}, {"sha": "664d101a4831dfccf40c1cd5a671862db6c329ca", "filename": "src/file_lines.rs", "status": "modified", "additions": 23, "deletions": 5, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/5fb1140688ae9e8a0cfc9d90a00f7dad4935e029/src%2Ffile_lines.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fb1140688ae9e8a0cfc9d90a00f7dad4935e029/src%2Ffile_lines.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffile_lines.rs?ref=5fb1140688ae9e8a0cfc9d90a00f7dad4935e029", "patch": "@@ -89,7 +89,10 @@ pub struct FileLines(Option<MultiMap<String, Range>>);\n fn normalize_ranges(map: &mut MultiMap<String, Range>) {\n     for (_, ranges) in map.iter_all_mut() {\n         ranges.sort_by_key(|x| x.lo);\n-        let merged = ranges.drain(..).coalesce(|x, y| x.merge(y).ok_or((x, y))).collect();\n+        let merged = ranges\n+            .drain(..)\n+            .coalesce(|x, y| x.merge(y).ok_or((x, y)))\n+            .collect();\n         *ranges = merged;\n     }\n }\n@@ -124,7 +127,11 @@ impl FileLines {\n                                                                        map.get_vec(&canonical)\n                                                                            .ok_or(())\n                                                                    }) {\n-            Ok(ranges) => ranges.iter().any(|r| r.contains(Range::from(range))),\n+            Ok(ranges) => {\n+                ranges\n+                    .iter()\n+                    .any(|r| r.contains(Range::from(range)))\n+            }\n             Err(_) => false,\n         }\n     }\n@@ -139,7 +146,11 @@ impl FileLines {\n \n         match map.get_vec(range.file_name()) {\n             None => false,\n-            Some(ranges) => ranges.iter().any(|r| r.intersects(Range::from(range))),\n+            Some(ranges) => {\n+                ranges\n+                    .iter()\n+                    .any(|r| r.intersects(Range::from(range)))\n+            }\n         }\n     }\n }\n@@ -157,7 +168,12 @@ impl<'a> iter::Iterator for Files<'a> {\n \n fn canonicalize_path_string(s: &str) -> Result<String, ()> {\n     match path::PathBuf::from(s).canonicalize() {\n-        Ok(canonicalized) => canonicalized.to_str().map(|s| s.to_string()).ok_or(()),\n+        Ok(canonicalized) => {\n+            canonicalized\n+                .to_str()\n+                .map(|s| s.to_string())\n+                .ok_or(())\n+        }\n         _ => Err(()),\n     }\n }\n@@ -168,7 +184,9 @@ impl str::FromStr for FileLines {\n \n     fn from_str(s: &str) -> Result<FileLines, String> {\n         let v: Vec<JsonSpan> = try!(json::decode(s).map_err(|e| e.to_string()));\n-        let m = try!(v.into_iter().map(JsonSpan::into_tuple).collect());\n+        let m = try!(v.into_iter()\n+                         .map(JsonSpan::into_tuple)\n+                         .collect());\n         Ok(FileLines::from_multimap(m))\n     }\n }"}, {"sha": "e99afea9c6ff2f6c48cc71b16fb1ab8a913f2e40", "filename": "src/imports.rs", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/5fb1140688ae9e8a0cfc9d90a00f7dad4935e029/src%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fb1140688ae9e8a0cfc9d90a00f7dad4935e029/src%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fimports.rs?ref=5fb1140688ae9e8a0cfc9d90a00f7dad4935e029", "patch": "@@ -46,14 +46,8 @@ fn compare_paths(a: &ast::Path, b: &ast::Path) -> Ordering {\n }\n \n fn compare_path_list_items(a: &ast::PathListItem, b: &ast::PathListItem) -> Ordering {\n-    let a_name_str = &*a.node\n-                           .name\n-                           .name\n-                           .as_str();\n-    let b_name_str = &*b.node\n-                           .name\n-                           .name\n-                           .as_str();\n+    let a_name_str = &*a.node.name.name.as_str();\n+    let b_name_str = &*b.node.name.name.as_str();\n     let name_ordering = if a_name_str == \"self\" {\n         if b_name_str == \"self\" {\n             Ordering::Equal\n@@ -71,7 +65,12 @@ fn compare_path_list_items(a: &ast::PathListItem, b: &ast::PathListItem) -> Orde\n         match a.node.rename {\n             Some(a_rename) => {\n                 match b.node.rename {\n-                    Some(b_rename) => a_rename.name.as_str().cmp(&b_rename.name.as_str()),\n+                    Some(b_rename) => {\n+                        a_rename\n+                            .name\n+                            .as_str()\n+                            .cmp(&b_rename.name.as_str())\n+                    }\n                     None => Ordering::Greater,\n                 }\n             }\n@@ -174,10 +173,7 @@ impl Rewrite for ast::ViewPath {\n                 let prefix_shape = try_opt!(shape.sub_width(ident_str.len() + 4));\n                 let path_str = try_opt!(rewrite_view_path_prefix(path, context, prefix_shape));\n \n-                Some(if path.segments\n-                            .last()\n-                            .unwrap()\n-                            .identifier == ident {\n+                Some(if path.segments.last().unwrap().identifier == ident {\n                          path_str\n                      } else {\n                          format!(\"{} as {}\", path_str, ident_str)\n@@ -328,7 +324,10 @@ pub fn rewrite_use_list(shape: Shape,\n     let colons_offset = if path_str.is_empty() { 0 } else { 2 };\n \n     // 2 = \"{}\"\n-    let remaining_width = shape.width.checked_sub(path_str.len() + 2 + colons_offset).unwrap_or(0);\n+    let remaining_width = shape\n+        .width\n+        .checked_sub(path_str.len() + 2 + colons_offset)\n+        .unwrap_or(0);\n \n     let mut items = {\n         // Dummy value, see explanation below.\n@@ -381,7 +380,9 @@ pub fn rewrite_use_list(shape: Shape,\n \n // Returns true when self item was found.\n fn move_self_to_front(items: &mut Vec<ListItem>) -> bool {\n-    match items.iter().position(|item| item.item.as_ref().map(|x| &x[..]) == Some(\"self\")) {\n+    match items\n+              .iter()\n+              .position(|item| item.item.as_ref().map(|x| &x[..]) == Some(\"self\")) {\n         Some(pos) => {\n             items[0] = items.remove(pos);\n             true"}, {"sha": "968faedd7c41c013cb05264ddfe577d8b72caf0b", "filename": "src/issues.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5fb1140688ae9e8a0cfc9d90a00f7dad4935e029/src%2Fissues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fb1140688ae9e8a0cfc9d90a00f7dad4935e029/src%2Fissues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fissues.rs?ref=5fb1140688ae9e8a0cfc9d90a00f7dad4935e029", "patch": "@@ -225,12 +225,15 @@ fn find_unnumbered_issue() {\n     fn check_fail(text: &str, failing_pos: usize) {\n         let mut seeker = BadIssueSeeker::new(ReportTactic::Unnumbered, ReportTactic::Unnumbered);\n         assert_eq!(Some(failing_pos),\n-                   text.chars().position(|c| seeker.inspect(c).is_some()));\n+                   text.chars()\n+                       .position(|c| seeker.inspect(c).is_some()));\n     }\n \n     fn check_pass(text: &str) {\n         let mut seeker = BadIssueSeeker::new(ReportTactic::Unnumbered, ReportTactic::Unnumbered);\n-        assert_eq!(None, text.chars().position(|c| seeker.inspect(c).is_some()));\n+        assert_eq!(None,\n+                   text.chars()\n+                       .position(|c| seeker.inspect(c).is_some()));\n     }\n \n     check_fail(\"TODO\\n\", 4);\n@@ -250,7 +253,8 @@ fn find_unnumbered_issue() {\n fn find_issue() {\n     fn is_bad_issue(text: &str, report_todo: ReportTactic, report_fixme: ReportTactic) -> bool {\n         let mut seeker = BadIssueSeeker::new(report_todo, report_fixme);\n-        text.chars().any(|c| seeker.inspect(c).is_some())\n+        text.chars()\n+            .any(|c| seeker.inspect(c).is_some())\n     }\n \n     assert!(is_bad_issue(\"TODO(@maintainer, #1222, hello)\\n\","}, {"sha": "cd5e4b485d3754d6ac48d14b9f735ac0e579326e", "filename": "src/items.rs", "status": "modified", "additions": 172, "deletions": 82, "changes": 254, "blob_url": "https://github.com/rust-lang/rust/blob/5fb1140688ae9e8a0cfc9d90a00f7dad4935e029/src%2Fitems.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fb1140688ae9e8a0cfc9d90a00f7dad4935e029/src%2Fitems.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fitems.rs?ref=5fb1140688ae9e8a0cfc9d90a00f7dad4935e029", "patch": "@@ -139,7 +139,8 @@ impl<'a> FmtVisitor<'a> {\n                 self.format_missing_no_indent(item.span.hi - BytePos(1));\n                 self.block_indent = self.block_indent.block_unindent(self.config);\n \n-                self.buffer.push_str(&self.block_indent.to_string(self.config));\n+                self.buffer\n+                    .push_str(&self.block_indent.to_string(self.config));\n             } else {\n                 for item in &item.body {\n                     self.format_body_element(item);\n@@ -241,7 +242,9 @@ impl<'a> FmtVisitor<'a> {\n         let context = self.get_context();\n \n         let block_snippet = self.snippet(codemap::mk_sp(block.span.lo, block.span.hi));\n-        let has_body = !block_snippet[1..block_snippet.len() - 1].trim().is_empty() ||\n+        let has_body = !block_snippet[1..block_snippet.len() - 1]\n+                            .trim()\n+                            .is_empty() ||\n                        !context.config.fn_empty_single_line;\n \n         let (mut result, force_newline_brace) = try_opt!(rewrite_fn_base(&context,\n@@ -277,7 +280,8 @@ impl<'a> FmtVisitor<'a> {\n             result.push(' ');\n         }\n \n-        self.single_line_fn(&result, block).or_else(|| Some(result))\n+        self.single_line_fn(&result, block)\n+            .or_else(|| Some(result))\n     }\n \n     pub fn rewrite_required_fn(&mut self,\n@@ -366,7 +370,8 @@ impl<'a> FmtVisitor<'a> {\n                       enum_def: &ast::EnumDef,\n                       generics: &ast::Generics,\n                       span: Span) {\n-        self.buffer.push_str(&format_header(\"enum \", ident, vis));\n+        self.buffer\n+            .push_str(&format_header(\"enum \", ident, vis));\n \n         let enum_snippet = self.snippet(span);\n         let brace_pos = enum_snippet.find_uncommented(\"{\").unwrap();\n@@ -400,7 +405,8 @@ impl<'a> FmtVisitor<'a> {\n         self.block_indent = self.block_indent.block_unindent(self.config);\n \n         if variant_list.is_some() || contains_comment(&enum_snippet[brace_pos..]) {\n-            self.buffer.push_str(&self.block_indent.to_string(self.config));\n+            self.buffer\n+                .push_str(&self.block_indent.to_string(self.config));\n         }\n         self.buffer.push_str(\"}\");\n         self.last_pos = span.hi;\n@@ -458,10 +464,13 @@ impl<'a> FmtVisitor<'a> {\n         }\n \n         let indent = self.block_indent;\n-        let mut result = try_opt!(field.node.attrs.rewrite(&self.get_context(),\n-                                                           Shape::legacy(self.config.max_width -\n-                                                                         indent.width(),\n-                                                                         indent)));\n+        let mut result = try_opt!(field\n+                                      .node\n+                                      .attrs\n+                                      .rewrite(&self.get_context(),\n+                                               Shape::legacy(self.config.max_width -\n+                                                             indent.width(),\n+                                                             indent)));\n         if !result.is_empty() {\n             result.push('\\n');\n             result.push_str(&indent.to_string(self.config));\n@@ -518,7 +527,10 @@ pub fn format_impl(context: &RewriteContext, item: &ast::Item, offset: Indent) -\n         }\n         result.push_str(&ref_and_type);\n \n-        let where_budget = try_opt!(context.config.max_width.checked_sub(last_line_width(&result)));\n+        let where_budget = try_opt!(context\n+                                        .config\n+                                        .max_width\n+                                        .checked_sub(last_line_width(&result)));\n         let where_clause_str = try_opt!(rewrite_where_clause(context,\n                                                              &generics.where_clause,\n                                                              context.config.item_brace_style,\n@@ -572,7 +584,9 @@ pub fn format_impl(context: &RewriteContext, item: &ast::Item, offset: Indent) -\n \n         if !items.is_empty() || contains_comment(&snippet[open_pos..]) {\n             let mut visitor = FmtVisitor::from_codemap(context.parse_session, context.config);\n-            visitor.block_indent = offset.block_only().block_indent(context.config);\n+            visitor.block_indent = offset\n+                .block_only()\n+                .block_indent(context.config);\n             visitor.last_pos = item.span.lo + BytePos(open_pos as u32);\n \n             for item in items {\n@@ -651,7 +665,10 @@ fn format_impl_ref_and_type(context: &RewriteContext,\n                 result.push_str(\" \");\n             }\n             let used_space = last_line_width(&result);\n-            let budget = try_opt!(context.config.max_width.checked_sub(used_space));\n+            let budget = try_opt!(context\n+                                      .config\n+                                      .max_width\n+                                      .checked_sub(used_space));\n             let indent = offset + used_space;\n             result.push_str(&*try_opt!(trait_ref.rewrite(context, Shape::legacy(budget, indent))));\n \n@@ -681,7 +698,10 @@ fn format_impl_ref_and_type(context: &RewriteContext,\n         }\n \n         // 1 = space before the type.\n-        let budget = try_opt!(context.config.max_width.checked_sub(used_space + 1));\n+        let budget = try_opt!(context\n+                                  .config\n+                                  .max_width\n+                                  .checked_sub(used_space + 1));\n         let indent = offset + result.len() + 1;\n         let self_ty_str = self_ty.rewrite(context, Shape::legacy(budget, indent));\n         if let Some(self_ty_str) = self_ty_str {\n@@ -693,7 +713,10 @@ fn format_impl_ref_and_type(context: &RewriteContext,\n         // Can't fit the self type on what's left of the line, so start a new one.\n         let indent = offset.block_indent(context.config);\n         result.push_str(&format!(\"\\n{}\", indent.to_string(context.config)));\n-        let budget = try_opt!(context.config.max_width.checked_sub(indent.width()));\n+        let budget = try_opt!(context\n+                                  .config\n+                                  .max_width\n+                                  .checked_sub(indent.width()));\n         result.push_str(&*try_opt!(self_ty.rewrite(context, Shape::legacy(budget, indent))));\n         Some(result)\n     } else {\n@@ -767,7 +790,9 @@ pub fn format_trait(context: &RewriteContext, item: &ast::Item, offset: Indent)\n         if offset.width() + last_line_width(&result) + trait_bound_str.len() >\n            context.config.comment_width {\n             result.push('\\n');\n-            let trait_indent = offset.block_only().block_indent(context.config);\n+            let trait_indent = offset\n+                .block_only()\n+                .block_indent(context.config);\n             result.push_str(&trait_indent.to_string(context.config));\n         }\n         result.push_str(&trait_bound_str);\n@@ -785,7 +810,10 @@ pub fn format_trait(context: &RewriteContext, item: &ast::Item, offset: Indent)\n                 Density::Tall\n             };\n \n-        let where_budget = try_opt!(context.config.max_width.checked_sub(last_line_width(&result)));\n+        let where_budget = try_opt!(context\n+                                        .config\n+                                        .max_width\n+                                        .checked_sub(last_line_width(&result)));\n         let where_clause_str = try_opt!(rewrite_where_clause(context,\n                                                              &generics.where_clause,\n                                                              context.config.item_brace_style,\n@@ -832,7 +860,9 @@ pub fn format_trait(context: &RewriteContext, item: &ast::Item, offset: Indent)\n \n         if !trait_items.is_empty() || contains_comment(&snippet[open_pos..]) {\n             let mut visitor = FmtVisitor::from_codemap(context.parse_session, context.config);\n-            visitor.block_indent = offset.block_only().block_indent(context.config);\n+            visitor.block_indent = offset\n+                .block_only()\n+                .block_indent(context.config);\n             visitor.last_pos = item.span.lo + BytePos(open_pos as u32);\n \n             for item in trait_items {\n@@ -908,7 +938,9 @@ fn format_struct_struct(context: &RewriteContext,\n         let snippet = context.snippet(mk_sp(body_lo, span.hi - BytePos(1)));\n         if snippet.trim().is_empty() {\n             // `struct S {}`\n-        } else if snippet.trim_right_matches(&[' ', '\\t'][..]).ends_with('\\n') {\n+        } else if snippet\n+                      .trim_right_matches(&[' ', '\\t'][..])\n+                      .ends_with('\\n') {\n             // fix indent\n             result.push_str(&snippet.trim_right());\n             result.push('\\n');\n@@ -922,7 +954,10 @@ fn format_struct_struct(context: &RewriteContext,\n \n     let item_indent = offset.block_indent(context.config);\n     // 1 = \",\"\n-    let item_budget = try_opt!(context.config.max_width.checked_sub(item_indent.width() + 1));\n+    let item_budget = try_opt!(context\n+                                   .config\n+                                   .max_width\n+                                   .checked_sub(item_indent.width() + 1));\n \n     let items =\n         itemize_list(context.codemap,\n@@ -963,7 +998,9 @@ fn format_struct_struct(context: &RewriteContext,\n     } else {\n         Some(format!(\"{}\\n{}{}\\n{}}}\",\n                      result,\n-                     offset.block_indent(context.config).to_string(context.config),\n+                     offset\n+                         .block_indent(context.config)\n+                         .to_string(context.config),\n                      items_str,\n                      offset.to_string(context.config)))\n     }\n@@ -1000,8 +1037,10 @@ fn format_tuple_struct(context: &RewriteContext,\n                                                          mk_sp(span.lo, body_lo)));\n             result.push_str(&generics_str);\n \n-            let where_budget =\n-                try_opt!(context.config.max_width.checked_sub(last_line_width(&result)));\n+            let where_budget = try_opt!(context\n+                                            .config\n+                                            .max_width\n+                                            .checked_sub(last_line_width(&result)));\n             try_opt!(rewrite_where_clause(context,\n                                           &generics.where_clause,\n                                           context.config.item_brace_style,\n@@ -1021,11 +1060,17 @@ fn format_tuple_struct(context: &RewriteContext,\n             (ListTactic::HorizontalVertical, offset.block_only() + result.len() + 1)\n         }\n         IndentStyle::Block => {\n-            (ListTactic::HorizontalVertical, offset.block_only().block_indent(&context.config))\n+            (ListTactic::HorizontalVertical,\n+             offset\n+                 .block_only()\n+                 .block_indent(&context.config))\n         }\n     };\n     // 3 = `();`\n-    let item_budget = try_opt!(context.config.max_width.checked_sub(item_indent.width() + 3));\n+    let item_budget = try_opt!(context\n+                                   .config\n+                                   .max_width\n+                                   .checked_sub(item_indent.width() + 3));\n \n     let items =\n         itemize_list(context.codemap,\n@@ -1043,9 +1088,11 @@ fn format_tuple_struct(context: &RewriteContext,\n                      |field| field.rewrite(context, Shape::legacy(item_budget, item_indent)),\n                      context.codemap.span_after(span, \"(\"),\n                      span.hi);\n-    let body_budget = try_opt!(context.config.max_width.checked_sub(offset.block_only().width() +\n-                                                                    result.len() +\n-                                                                    3));\n+    let body_budget = try_opt!(context\n+                                   .config\n+                                   .max_width\n+                                   .checked_sub(offset.block_only().width() + result.len() +\n+                                                3));\n     let body = try_opt!(list_helper(items,\n                                     // TODO budget is wrong in block case\n                                     Shape::legacy(body_budget, item_indent),\n@@ -1113,7 +1160,10 @@ pub fn rewrite_type_alias(context: &RewriteContext,\n \n     result.push_str(&generics_str);\n \n-    let where_budget = try_opt!(context.config.max_width.checked_sub(last_line_width(&result)));\n+    let where_budget = try_opt!(context\n+                                    .config\n+                                    .max_width\n+                                    .checked_sub(last_line_width(&result)));\n     let where_clause_str = try_opt!(rewrite_where_clause(context,\n                                                          &generics.where_clause,\n                                                          context.config.item_brace_style,\n@@ -1136,16 +1186,19 @@ pub fn rewrite_type_alias(context: &RewriteContext,\n         .unwrap_or(0);\n     let type_indent = indent + line_width;\n     // Try to fit the type on the same line\n-    let ty_str = try_opt!(ty.rewrite(context, Shape::legacy(budget, type_indent)).or_else(|| {\n+    let ty_str = try_opt!(ty.rewrite(context, Shape::legacy(budget, type_indent))\n+                              .or_else(|| {\n         // The line was too short, try to put the type on the next line\n \n         // Remove the space after '='\n         result.pop();\n         let type_indent = indent.block_indent(context.config);\n         result.push('\\n');\n         result.push_str(&type_indent.to_string(context.config));\n-        let budget = try_opt!(context.config.max_width.checked_sub(type_indent.width() +\n-                                                                   \";\".len()));\n+        let budget = try_opt!(context\n+                                  .config\n+                                  .max_width\n+                                  .checked_sub(type_indent.width() + \";\".len()));\n         ty.rewrite(context, Shape::legacy(budget, type_indent))\n     }));\n     result.push_str(&ty_str);\n@@ -1175,10 +1228,11 @@ impl Rewrite for ast::StructField {\n \n         let name = self.ident;\n         let vis = format_visibility(&self.vis);\n-        let mut attr_str = try_opt!(self.attrs.rewrite(context,\n-                                                       Shape::legacy(context.config.max_width -\n-                                                                     shape.indent.width(),\n-                                                                     shape.indent)));\n+        let mut attr_str = try_opt!(self.attrs\n+                                        .rewrite(context,\n+                                                 Shape::legacy(context.config.max_width -\n+                                                               shape.indent.width(),\n+                                                               shape.indent)));\n         if !attr_str.is_empty() {\n             attr_str.push('\\n');\n             attr_str.push_str(&shape.indent.to_string(context.config));\n@@ -1199,9 +1253,10 @@ impl Rewrite for ast::StructField {\n \n         let last_line_width = last_line_width(&result);\n         let budget = try_opt!(shape.width.checked_sub(last_line_width));\n-        let rewrite = try_opt!(self.ty.rewrite(context,\n-                                               Shape::legacy(budget,\n-                                                             shape.indent + last_line_width)));\n+        let rewrite = try_opt!(self.ty\n+                                   .rewrite(context,\n+                                            Shape::legacy(budget,\n+                                                          shape.indent + last_line_width)));\n         Some(result + &rewrite)\n     }\n }\n@@ -1305,9 +1360,8 @@ impl Rewrite for ast::FunctionRetTy {\n             ast::FunctionRetTy::Default(_) => Some(String::new()),\n             ast::FunctionRetTy::Ty(ref ty) => {\n                 let inner_width = try_opt!(shape.width.checked_sub(3));\n-                ty.rewrite(context, Shape::legacy(inner_width, shape.indent + 3)).map(|r| {\n-                    format!(\"-> {}\", r)\n-                })\n+                ty.rewrite(context, Shape::legacy(inner_width, shape.indent + 3))\n+                    .map(|r| format!(\"-> {}\", r))\n             }\n         }\n     }\n@@ -1316,21 +1370,25 @@ impl Rewrite for ast::FunctionRetTy {\n impl Rewrite for ast::Arg {\n     fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n         if is_named_arg(self) {\n-            let mut result = try_opt!(self.pat.rewrite(context,\n-                                                       Shape::legacy(shape.width, shape.indent)));\n+            let mut result = try_opt!(self.pat\n+                                          .rewrite(context,\n+                                                   Shape::legacy(shape.width, shape.indent)));\n \n             if self.ty.node != ast::TyKind::Infer {\n                 if context.config.space_before_type_annotation {\n                     result.push_str(\" \");\n                 }\n                 result.push_str(\":\");\n-                if context.config.space_after_type_annotation_colon {\n+                if context\n+                       .config\n+                       .space_after_type_annotation_colon {\n                     result.push_str(\" \");\n                 }\n                 let max_width = try_opt!(shape.width.checked_sub(result.len()));\n-                let ty_str = try_opt!(self.ty.rewrite(context,\n-                                                      Shape::legacy(max_width,\n-                                                                    shape.indent + result.len())));\n+                let ty_str = try_opt!(self.ty\n+                                          .rewrite(context,\n+                                                   Shape::legacy(max_width,\n+                                                                 shape.indent + result.len())));\n                 result.push_str(&ty_str);\n             }\n \n@@ -1497,10 +1555,11 @@ fn rewrite_fn_base(context: &RewriteContext,\n \n     // Note that the width and indent don't really matter, we'll re-layout the\n     // return type later anyway.\n-    let ret_str = try_opt!(fd.output.rewrite(&context,\n-                                             Shape::legacy(context.config.max_width -\n-                                                           indent.width(),\n-                                                           indent)));\n+    let ret_str = try_opt!(fd.output\n+                               .rewrite(&context,\n+                                        Shape::legacy(context.config.max_width -\n+                                                      indent.width(),\n+                                                      indent)));\n \n     let multi_line_ret_str = ret_str.contains('\\n');\n     let ret_str_len = if multi_line_ret_str { 0 } else { ret_str.len() };\n@@ -1547,8 +1606,13 @@ fn rewrite_fn_base(context: &RewriteContext,\n     }\n \n     // A conservative estimation, to goal is to be over all parens in generics\n-    let args_start = generics.ty_params.last().map_or(span.lo, |tp| end_typaram(tp));\n-    let args_span = mk_sp(context.codemap.span_after(mk_sp(args_start, span.hi), \"(\"),\n+    let args_start = generics\n+        .ty_params\n+        .last()\n+        .map_or(span.lo, |tp| end_typaram(tp));\n+    let args_span = mk_sp(context\n+                              .codemap\n+                              .span_after(mk_sp(args_start, span.hi), \"(\"),\n                           span_for_return(&fd.output).lo);\n     let arg_str = try_opt!(rewrite_args(context,\n                                         &fd.inputs,\n@@ -1631,8 +1695,12 @@ fn rewrite_fn_base(context: &RewriteContext,\n         if multi_line_ret_str || ret_should_indent {\n             // Now that we know the proper indent and width, we need to\n             // re-layout the return type.\n-            let budget = try_opt!(context.config.max_width.checked_sub(ret_indent.width()));\n-            let ret_str = try_opt!(fd.output.rewrite(context, Shape::legacy(budget, ret_indent)));\n+            let budget = try_opt!(context\n+                                      .config\n+                                      .max_width\n+                                      .checked_sub(ret_indent.width()));\n+            let ret_str = try_opt!(fd.output\n+                                       .rewrite(context, Shape::legacy(budget, ret_indent)));\n             result.push_str(&ret_str);\n         } else {\n             result.push_str(&ret_str);\n@@ -1662,7 +1730,10 @@ fn rewrite_fn_base(context: &RewriteContext,\n     } || (put_args_in_block && ret_str.is_empty());\n \n     if where_clause.predicates.len() == 1 && should_compress_where {\n-        let budget = try_opt!(context.config.max_width.checked_sub(last_line_width(&result)));\n+        let budget = try_opt!(context\n+                                  .config\n+                                  .max_width\n+                                  .checked_sub(last_line_width(&result)));\n         if let Some(where_clause_str) =\n             rewrite_where_clause(context,\n                                  where_clause,\n@@ -1685,7 +1756,10 @@ fn rewrite_fn_base(context: &RewriteContext,\n         }\n     }\n \n-    let budget = try_opt!(context.config.max_width.checked_sub(indent.block_indent));\n+    let budget = try_opt!(context\n+                              .config\n+                              .max_width\n+                              .checked_sub(indent.block_indent));\n     let where_clause_str = try_opt!(rewrite_where_clause(context,\n                                                          where_clause,\n                                                          context.config.fn_brace_style,\n@@ -1747,7 +1821,9 @@ fn rewrite_args(context: &RewriteContext,\n             };\n             let reduced_span = mk_sp(span.lo, second_arg_start);\n \n-            context.codemap.span_after_last(reduced_span, \",\")\n+            context\n+                .codemap\n+                .span_after_last(reduced_span, \",\")\n         } else {\n             span.lo\n         };\n@@ -1758,13 +1834,10 @@ fn rewrite_args(context: &RewriteContext,\n         }\n \n         let variadic_arg = if variadic {\n-            let variadic_span = mk_sp(args.last()\n-                                          .unwrap()\n-                                          .ty\n-                                          .span\n-                                          .hi,\n-                                      span.hi);\n-            let variadic_start = context.codemap.span_after(variadic_span, \"...\") - BytePos(3);\n+            let variadic_span = mk_sp(args.last().unwrap().ty.span.hi, span.hi);\n+            let variadic_start = context\n+                .codemap\n+                .span_after(variadic_span, \"...\") - BytePos(3);\n             Some(ArgumentKind::Variadic(variadic_start))\n         } else {\n             None\n@@ -1806,7 +1879,10 @@ fn rewrite_args(context: &RewriteContext,\n     };\n \n     let tactic = definitive_tactic(&arg_items,\n-                                   context.config.fn_args_density.to_list_tactic(),\n+                                   context\n+                                       .config\n+                                       .fn_args_density\n+                                       .to_list_tactic(),\n                                    one_line_budget);\n     let budget = match tactic {\n         DefinitiveListTactic::Horizontal => one_line_budget,\n@@ -1861,8 +1937,11 @@ fn compute_budgets_for_args(context: &RewriteContext,\n \n         if one_line_budget > 0 {\n             // 4 = \"() {\".len()\n-            let multi_line_budget =\n-                try_opt!(context.config.max_width.checked_sub(indent.width() + result.len() + 4));\n+            let multi_line_budget = try_opt!(context\n+                                                 .config\n+                                                 .max_width\n+                                                 .checked_sub(indent.width() + result.len() +\n+                                                              4));\n \n             return Some((one_line_budget, multi_line_budget, indent + result.len() + 1));\n         }\n@@ -1909,27 +1988,35 @@ fn rewrite_generics(context: &RewriteContext,\n         IndentStyle::Visual => generics_offset + 1,\n     };\n \n-    let h_budget = try_opt!(shape.width.checked_sub(generics_offset.width() + 2));\n+    let h_budget = try_opt!(shape\n+                                .width\n+                                .checked_sub(generics_offset.width() + 2));\n     // FIXME: might need to insert a newline if the generics are really long.\n \n     // Strings for the generics.\n-    let lt_strs = lifetimes.iter().map(|lt| lt.rewrite(context, Shape::legacy(h_budget, offset)));\n-    let ty_strs =\n-        tys.iter().map(|ty_param| ty_param.rewrite(context, Shape::legacy(h_budget, offset)));\n+    let lt_strs = lifetimes\n+        .iter()\n+        .map(|lt| lt.rewrite(context, Shape::legacy(h_budget, offset)));\n+    let ty_strs = tys.iter()\n+        .map(|ty_param| ty_param.rewrite(context, Shape::legacy(h_budget, offset)));\n \n     // Extract comments between generics.\n-    let lt_spans = lifetimes.iter().map(|l| {\n-                                            let hi = if l.bounds.is_empty() {\n-                                                l.lifetime.span.hi\n-                                            } else {\n-                                                l.bounds[l.bounds.len() - 1].span.hi\n-                                            };\n-                                            mk_sp(l.lifetime.span.lo, hi)\n-                                        });\n+    let lt_spans = lifetimes\n+        .iter()\n+        .map(|l| {\n+                 let hi = if l.bounds.is_empty() {\n+                     l.lifetime.span.hi\n+                 } else {\n+                     l.bounds[l.bounds.len() - 1].span.hi\n+                 };\n+                 mk_sp(l.lifetime.span.lo, hi)\n+             });\n     let ty_spans = tys.iter().map(span_for_ty_param);\n \n     let items = itemize_list(context.codemap,\n-                             lt_spans.chain(ty_spans).zip(lt_strs.chain(ty_strs)),\n+                             lt_spans\n+                                 .chain(ty_spans)\n+                                 .zip(lt_strs.chain(ty_strs)),\n                              \">\",\n                              |&(sp, _)| sp.lo,\n                              |&(sp, _)| sp.hi,\n@@ -2157,7 +2244,10 @@ fn format_generics(context: &RewriteContext,\n                                                span));\n \n     if !generics.where_clause.predicates.is_empty() || result.contains('\\n') {\n-        let budget = try_opt!(context.config.max_width.checked_sub(last_line_width(&result)));\n+        let budget = try_opt!(context\n+                                  .config\n+                                  .max_width\n+                                  .checked_sub(last_line_width(&result)));\n         let where_clause_str =\n             try_opt!(rewrite_where_clause(context,\n                                           &generics.where_clause,"}, {"sha": "f63829c9199910c4604eb7627fc3771d0c10267f", "filename": "src/lib.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5fb1140688ae9e8a0cfc9d90a00f7dad4935e029/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fb1140688ae9e8a0cfc9d90a00f7dad4935e029/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=5fb1140688ae9e8a0cfc9d90a00f7dad4935e029", "patch": "@@ -536,7 +536,9 @@ fn format_lines(text: &mut StringBuffer, name: &str, config: &Config, report: &m\n                     });\n     }\n \n-    report.file_error_map.insert(name.to_owned(), errors);\n+    report\n+        .file_error_map\n+        .insert(name.to_owned(), errors);\n }\n \n fn parse_input(input: Input,"}, {"sha": "a5c5d2c0aad4e792455f7bce7ce34e98c0e41e36", "filename": "src/lists.rs", "status": "modified", "additions": 142, "deletions": 110, "changes": 252, "blob_url": "https://github.com/rust-lang/rust/blob/5fb1140688ae9e8a0cfc9d90a00f7dad4935e029/src%2Flists.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fb1140688ae9e8a0cfc9d90a00f7dad4935e029/src%2Flists.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flists.rs?ref=5fb1140688ae9e8a0cfc9d90a00f7dad4935e029", "patch": "@@ -118,12 +118,18 @@ pub struct ListItem {\n \n impl ListItem {\n     pub fn is_multiline(&self) -> bool {\n-        self.item.as_ref().map_or(false, |s| s.contains('\\n')) || self.pre_comment.is_some() ||\n-        self.post_comment.as_ref().map_or(false, |s| s.contains('\\n'))\n+        self.item\n+            .as_ref()\n+            .map_or(false, |s| s.contains('\\n')) || self.pre_comment.is_some() ||\n+        self.post_comment\n+            .as_ref()\n+            .map_or(false, |s| s.contains('\\n'))\n     }\n \n     pub fn has_line_pre_comment(&self) -> bool {\n-        self.pre_comment.as_ref().map_or(false, |comment| comment.starts_with(\"//\"))\n+        self.pre_comment\n+            .as_ref()\n+            .map_or(false, |comment| comment.starts_with(\"//\"))\n     }\n \n     pub fn from_str<S: Into<String>>(s: S) -> ListItem {\n@@ -148,8 +154,10 @@ pub fn definitive_tactic<I, T>(items: I, tactic: ListTactic, width: usize) -> De\n     where I: IntoIterator<Item = T> + Clone,\n           T: AsRef<ListItem>\n {\n-    let pre_line_comments =\n-        items.clone().into_iter().any(|item| item.as_ref().has_line_pre_comment());\n+    let pre_line_comments = items\n+        .clone()\n+        .into_iter()\n+        .any(|item| item.as_ref().has_line_pre_comment());\n \n     let limit = match tactic {\n         _ if pre_line_comments => return DefinitiveListTactic::Vertical,\n@@ -166,7 +174,9 @@ pub fn definitive_tactic<I, T>(items: I, tactic: ListTactic, width: usize) -> De\n     let real_total = total_width + total_sep_len;\n \n     if real_total <= limit && !pre_line_comments &&\n-       !items.into_iter().any(|item| item.as_ref().is_multiline()) {\n+       !items\n+            .into_iter()\n+            .any(|item| item.as_ref().is_multiline()) {\n         DefinitiveListTactic::Horizontal\n     } else {\n         DefinitiveListTactic::Vertical\n@@ -189,7 +199,10 @@ pub fn write_list<I, T>(items: I, formatting: &ListFormatting) -> Option<String>\n     let mut iter = items.into_iter().enumerate().peekable();\n \n     let mut line_len = 0;\n-    let indent_str = &formatting.shape.indent.to_string(formatting.config);\n+    let indent_str = &formatting\n+                          .shape\n+                          .indent\n+                          .to_string(formatting.config);\n     while let Some((i, item)) = iter.next() {\n         let item = item.as_ref();\n         let inner_item = try_opt!(item.item.as_ref());\n@@ -331,109 +344,119 @@ impl<'a, T, I, F1, F2, F3> Iterator for ListItems<'a, I, F1, F2, F3>\n     fn next(&mut self) -> Option<Self::Item> {\n         let white_space: &[_] = &[' ', '\\t'];\n \n-        self.inner.next().map(|item| {\n-            let mut new_lines = false;\n-            // Pre-comment\n-            let pre_snippet = self.codemap\n-                .span_to_snippet(codemap::mk_sp(self.prev_span_end, (self.get_lo)(&item)))\n-                .unwrap();\n-            let trimmed_pre_snippet = pre_snippet.trim();\n-            let pre_comment = if !trimmed_pre_snippet.is_empty() {\n-                Some(trimmed_pre_snippet.to_owned())\n-            } else {\n-                None\n-            };\n-\n-            // Post-comment\n-            let next_start = match self.inner.peek() {\n-                Some(next_item) => (self.get_lo)(next_item),\n-                None => self.next_span_start,\n-            };\n-            let post_snippet = self.codemap\n-                .span_to_snippet(codemap::mk_sp((self.get_hi)(&item), next_start))\n-                .unwrap();\n-\n-            let comment_end = match self.inner.peek() {\n-                Some(..) => {\n-                    let mut block_open_index = post_snippet.find(\"/*\");\n-                    // check if it realy is a block comment (and not //*)\n-                    if let Some(i) = block_open_index {\n-                        if i > 0 && &post_snippet[i - 1..i] == \"/\" {\n-                            block_open_index = None;\n-                        }\n-                    }\n-                    let newline_index = post_snippet.find('\\n');\n-                    let separator_index = post_snippet.find_uncommented(\",\").unwrap();\n-\n-                    match (block_open_index, newline_index) {\n-                        // Separator before comment, with the next item on same line.\n-                        // Comment belongs to next item.\n-                        (Some(i), None) if i > separator_index => separator_index + 1,\n-                        // Block-style post-comment before the separator.\n-                        (Some(i), None) => {\n-                            cmp::max(find_comment_end(&post_snippet[i..]).unwrap() + i,\n-                                     separator_index + 1)\n+        self.inner\n+            .next()\n+            .map(|item| {\n+                let mut new_lines = false;\n+                // Pre-comment\n+                let pre_snippet = self.codemap\n+                    .span_to_snippet(codemap::mk_sp(self.prev_span_end, (self.get_lo)(&item)))\n+                    .unwrap();\n+                let trimmed_pre_snippet = pre_snippet.trim();\n+                let pre_comment = if !trimmed_pre_snippet.is_empty() {\n+                    Some(trimmed_pre_snippet.to_owned())\n+                } else {\n+                    None\n+                };\n+\n+                // Post-comment\n+                let next_start = match self.inner.peek() {\n+                    Some(next_item) => (self.get_lo)(next_item),\n+                    None => self.next_span_start,\n+                };\n+                let post_snippet = self.codemap\n+                    .span_to_snippet(codemap::mk_sp((self.get_hi)(&item), next_start))\n+                    .unwrap();\n+\n+                let comment_end = match self.inner.peek() {\n+                    Some(..) => {\n+                        let mut block_open_index = post_snippet.find(\"/*\");\n+                        // check if it realy is a block comment (and not //*)\n+                        if let Some(i) = block_open_index {\n+                            if i > 0 && &post_snippet[i - 1..i] == \"/\" {\n+                                block_open_index = None;\n+                            }\n                         }\n-                        // Block-style post-comment. Either before or after the separator.\n-                        (Some(i), Some(j)) if i < j => {\n-                            cmp::max(find_comment_end(&post_snippet[i..]).unwrap() + i,\n-                                     separator_index + 1)\n+                        let newline_index = post_snippet.find('\\n');\n+                        let separator_index = post_snippet.find_uncommented(\",\").unwrap();\n+\n+                        match (block_open_index, newline_index) {\n+                            // Separator before comment, with the next item on same line.\n+                            // Comment belongs to next item.\n+                            (Some(i), None) if i > separator_index => separator_index + 1,\n+                            // Block-style post-comment before the separator.\n+                            (Some(i), None) => {\n+                                cmp::max(find_comment_end(&post_snippet[i..]).unwrap() + i,\n+                                         separator_index + 1)\n+                            }\n+                            // Block-style post-comment. Either before or after the separator.\n+                            (Some(i), Some(j)) if i < j => {\n+                                cmp::max(find_comment_end(&post_snippet[i..]).unwrap() + i,\n+                                         separator_index + 1)\n+                            }\n+                            // Potential *single* line comment.\n+                            (_, Some(j)) if j > separator_index => j + 1,\n+                            _ => post_snippet.len(),\n                         }\n-                        // Potential *single* line comment.\n-                        (_, Some(j)) if j > separator_index => j + 1,\n-                        _ => post_snippet.len(),\n+                    }\n+                    None => {\n+                        post_snippet\n+                            .find_uncommented(self.terminator)\n+                            .unwrap_or(post_snippet.len())\n+                    }\n+                };\n+\n+                if !post_snippet.is_empty() && comment_end > 0 {\n+                    // Account for extra whitespace between items. This is fiddly\n+                    // because of the way we divide pre- and post- comments.\n+\n+                    // Everything from the separator to the next item.\n+                    let test_snippet = &post_snippet[comment_end - 1..];\n+                    let first_newline = test_snippet\n+                        .find('\\n')\n+                        .unwrap_or(test_snippet.len());\n+                    // From the end of the first line of comments.\n+                    let test_snippet = &test_snippet[first_newline..];\n+                    let first = test_snippet\n+                        .find(|c: char| !c.is_whitespace())\n+                        .unwrap_or(test_snippet.len());\n+                    // From the end of the first line of comments to the next non-whitespace char.\n+                    let test_snippet = &test_snippet[..first];\n+\n+                    if test_snippet\n+                           .chars()\n+                           .filter(|c| c == &'\\n')\n+                           .count() > 1 {\n+                        // There were multiple line breaks which got trimmed to nothing.\n+                        new_lines = true;\n                     }\n                 }\n-                None => {\n-                    post_snippet.find_uncommented(self.terminator).unwrap_or(post_snippet.len())\n-                }\n-            };\n-\n-            if !post_snippet.is_empty() && comment_end > 0 {\n-                // Account for extra whitespace between items. This is fiddly\n-                // because of the way we divide pre- and post- comments.\n-\n-                // Everything from the separator to the next item.\n-                let test_snippet = &post_snippet[comment_end - 1..];\n-                let first_newline = test_snippet.find('\\n').unwrap_or(test_snippet.len());\n-                // From the end of the first line of comments.\n-                let test_snippet = &test_snippet[first_newline..];\n-                let first =\n-                    test_snippet.find(|c: char| !c.is_whitespace()).unwrap_or(test_snippet.len());\n-                // From the end of the first line of comments to the next non-whitespace char.\n-                let test_snippet = &test_snippet[..first];\n-\n-                if test_snippet.chars().filter(|c| c == &'\\n').count() > 1 {\n-                    // There were multiple line breaks which got trimmed to nothing.\n-                    new_lines = true;\n-                }\n-            }\n \n-            // Cleanup post-comment: strip separators and whitespace.\n-            self.prev_span_end = (self.get_hi)(&item) + BytePos(comment_end as u32);\n-            let post_snippet = post_snippet[..comment_end].trim();\n-\n-            let post_snippet_trimmed = if post_snippet.starts_with(',') {\n-                post_snippet[1..].trim_matches(white_space)\n-            } else if post_snippet.ends_with(',') {\n-                post_snippet[..(post_snippet.len() - 1)].trim_matches(white_space)\n-            } else {\n-                post_snippet\n-            };\n-\n-            let post_comment = if !post_snippet_trimmed.is_empty() {\n-                Some(post_snippet_trimmed.to_owned())\n-            } else {\n-                None\n-            };\n-\n-            ListItem {\n-                pre_comment: pre_comment,\n-                item: (self.get_item_string)(&item),\n-                post_comment: post_comment,\n-                new_lines: new_lines,\n-            }\n-        })\n+                // Cleanup post-comment: strip separators and whitespace.\n+                self.prev_span_end = (self.get_hi)(&item) + BytePos(comment_end as u32);\n+                let post_snippet = post_snippet[..comment_end].trim();\n+\n+                let post_snippet_trimmed = if post_snippet.starts_with(',') {\n+                    post_snippet[1..].trim_matches(white_space)\n+                } else if post_snippet.ends_with(',') {\n+                    post_snippet[..(post_snippet.len() - 1)].trim_matches(white_space)\n+                } else {\n+                    post_snippet\n+                };\n+\n+                let post_comment = if !post_snippet_trimmed.is_empty() {\n+                    Some(post_snippet_trimmed.to_owned())\n+                } else {\n+                    None\n+                };\n+\n+                ListItem {\n+                    pre_comment: pre_comment,\n+                    item: (self.get_item_string)(&item),\n+                    post_comment: post_comment,\n+                    new_lines: new_lines,\n+                }\n+            })\n     }\n }\n \n@@ -479,9 +502,10 @@ fn calculate_width<I, T>(items: I) -> (usize, usize)\n     where I: IntoIterator<Item = T>,\n           T: AsRef<ListItem>\n {\n-    items.into_iter().map(|item| total_item_width(item.as_ref())).fold((0, 0), |acc, l| {\n-        (acc.0 + 1, acc.1 + l)\n-    })\n+    items\n+        .into_iter()\n+        .map(|item| total_item_width(item.as_ref()))\n+        .fold((0, 0), |acc, l| (acc.0 + 1, acc.1 + l))\n }\n \n fn total_item_width(item: &ListItem) -> usize {\n@@ -518,7 +542,10 @@ pub fn struct_lit_shape(shape: Shape,\n         IndentStyle::Block => {\n             let shape = shape.block_indent(context.config.tab_spaces);\n             Shape {\n-                width: try_opt!(context.config.max_width.checked_sub(shape.indent.width())),\n+                width: try_opt!(context\n+                                    .config\n+                                    .max_width\n+                                    .checked_sub(shape.indent.width())),\n                 ..shape\n             }\n         }\n@@ -535,7 +562,12 @@ pub fn struct_lit_tactic(h_shape: Option<Shape>,\n     if let Some(h_shape) = h_shape {\n         let mut prelim_tactic = match (context.config.struct_lit_style, items.len()) {\n             (IndentStyle::Visual, 1) => ListTactic::HorizontalVertical,\n-            _ => context.config.struct_lit_multiline_style.to_list_tactic(),\n+            _ => {\n+                context\n+                    .config\n+                    .struct_lit_multiline_style\n+                    .to_list_tactic()\n+            }\n         };\n \n         if prelim_tactic == ListTactic::HorizontalVertical && items.len() > 1 {"}, {"sha": "034ddc15d15656d1e159c92373848f0b101635b7", "filename": "src/macros.rs", "status": "modified", "additions": 22, "deletions": 11, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/5fb1140688ae9e8a0cfc9d90a00f7dad4935e029/src%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fb1140688ae9e8a0cfc9d90a00f7dad4935e029/src%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmacros.rs?ref=5fb1140688ae9e8a0cfc9d90a00f7dad4935e029", "patch": "@@ -109,7 +109,10 @@ pub fn rewrite_macro(mac: &ast::Mac,\n             let expr = match parser.parse_expr() {\n                 Ok(expr) => {\n                     // Recovered errors.\n-                    if context.parse_session.span_diagnostic.has_errors() {\n+                    if context\n+                           .parse_session\n+                           .span_diagnostic\n+                           .has_errors() {\n                         return None;\n                     }\n \n@@ -156,13 +159,15 @@ pub fn rewrite_macro(mac: &ast::Mac,\n             // Format macro invocation as array literal.\n             let extra_offset = macro_name.len();\n             let shape = try_opt!(shape.shrink_left(extra_offset));\n-            let rewrite =\n-                try_opt!(rewrite_array(expr_vec.iter().map(|x| &**x),\n-                                       mk_sp(context.codemap.span_after(mac.span,\n-                                                                        original_style.opener()),\n-                                             mac.span.hi - BytePos(1)),\n-                                       context,\n-                                       shape));\n+            let rewrite = try_opt!(rewrite_array(expr_vec.iter().map(|x| &**x),\n+                                                 mk_sp(context\n+                                                           .codemap\n+                                                           .span_after(mac.span,\n+                                                                       original_style\n+                                                                           .opener()),\n+                                                       mac.span.hi - BytePos(1)),\n+                                                 context,\n+                                                 shape));\n \n             Some(format!(\"{}{}\", macro_name, rewrite))\n         }\n@@ -193,9 +198,15 @@ pub fn convert_try_mac(mac: &ast::Mac, context: &RewriteContext) -> Option<ast::\n \n fn macro_style(mac: &ast::Mac, context: &RewriteContext) -> MacroStyle {\n     let snippet = context.snippet(mac.span);\n-    let paren_pos = snippet.find_uncommented(\"(\").unwrap_or(usize::max_value());\n-    let bracket_pos = snippet.find_uncommented(\"[\").unwrap_or(usize::max_value());\n-    let brace_pos = snippet.find_uncommented(\"{\").unwrap_or(usize::max_value());\n+    let paren_pos = snippet\n+        .find_uncommented(\"(\")\n+        .unwrap_or(usize::max_value());\n+    let bracket_pos = snippet\n+        .find_uncommented(\"[\")\n+        .unwrap_or(usize::max_value());\n+    let brace_pos = snippet\n+        .find_uncommented(\"{\")\n+        .unwrap_or(usize::max_value());\n \n     if paren_pos < bracket_pos && paren_pos < brace_pos {\n         MacroStyle::Parens"}, {"sha": "8b8a3424008929cdada2bec9a7340253bd140fb3", "filename": "src/missed_spans.rs", "status": "modified", "additions": 20, "deletions": 19, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/5fb1140688ae9e8a0cfc9d90a00f7dad4935e029/src%2Fmissed_spans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fb1140688ae9e8a0cfc9d90a00f7dad4935e029/src%2Fmissed_spans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmissed_spans.rs?ref=5fb1140688ae9e8a0cfc9d90a00f7dad4935e029", "patch": "@@ -83,12 +83,7 @@ impl<'a> FmtVisitor<'a> {\n         let local_end = self.codemap.lookup_byte_offset(span.hi);\n         let start_index = local_begin.pos.to_usize();\n         let end_index = local_end.pos.to_usize();\n-        let big_snippet = &local_begin\n-                               .fm\n-                               .src\n-                               .as_ref()\n-                               .unwrap()\n-                               [start_index..end_index];\n+        let big_snippet = &local_begin.fm.src.as_ref().unwrap()[start_index..end_index];\n \n         let big_diff = (span.lo - big_span_lo).to_usize();\n         let snippet = self.snippet(span);\n@@ -113,7 +108,10 @@ impl<'a> FmtVisitor<'a> {\n         let mut rewrite_next_comment = true;\n \n         fn replace_chars(string: &str) -> String {\n-            string.chars().map(|ch| if ch.is_whitespace() { ch } else { 'X' }).collect()\n+            string\n+                .chars()\n+                .map(|ch| if ch.is_whitespace() { ch } else { 'X' })\n+                .collect()\n         }\n \n         let replaced = match self.config.write_mode {\n@@ -139,7 +137,8 @@ impl<'a> FmtVisitor<'a> {\n                         if let Some('{') = last_char {\n                             self.buffer.push_str(\"\\n\");\n                         }\n-                        self.buffer.push_str(&self.block_indent.to_string(self.config));\n+                        self.buffer\n+                            .push_str(&self.block_indent.to_string(self.config));\n                     } else {\n                         self.buffer.push_str(\" \");\n                     }\n@@ -148,22 +147,23 @@ impl<'a> FmtVisitor<'a> {\n                                                         self.config.max_width -\n                                                         self.block_indent.width());\n \n-                    self.buffer.push_str(&rewrite_comment(subslice,\n-                                                          false,\n-                                                          Shape::legacy(comment_width,\n-                                                                        self.block_indent),\n-                                                          self.config)\n-                                                  .unwrap());\n+                    self.buffer\n+                        .push_str(&rewrite_comment(subslice,\n+                                                   false,\n+                                                   Shape::legacy(comment_width,\n+                                                                 self.block_indent),\n+                                                   self.config)\n+                                           .unwrap());\n \n                     last_wspace = None;\n                     line_start = offset + subslice.len();\n \n                     if let Some('/') = subslice.chars().skip(1).next() {\n                         // check that there are no contained block comments\n-                        if !subslice.split('\\n').map(|s| s.trim_left()).any(|s| {\n-                                                                                s.len() > 2 &&\n-                                                                                &s[0..2] == \"/*\"\n-                                                                            }) {\n+                        if !subslice\n+                                .split('\\n')\n+                                .map(|s| s.trim_left())\n+                                .any(|s| s.len() > 2 && &s[0..2] == \"/*\") {\n                             // Add a newline after line comments\n                             self.buffer.push_str(\"\\n\");\n                         }\n@@ -189,7 +189,8 @@ impl<'a> FmtVisitor<'a> {\n                         self.buffer.push_str(&snippet[line_start..lw]);\n                         self.buffer.push_str(\"\\n\");\n                     } else {\n-                        self.buffer.push_str(&snippet[line_start..i + 1]);\n+                        self.buffer\n+                            .push_str(&snippet[line_start..i + 1]);\n                     }\n \n                     line_start = i + 1;"}, {"sha": "ebbb84a895ee4de40e2a7c6063f52252703ad6ac", "filename": "src/patterns.rs", "status": "modified", "additions": 33, "deletions": 19, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/5fb1140688ae9e8a0cfc9d90a00f7dad4935e029/src%2Fpatterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fb1140688ae9e8a0cfc9d90a00f7dad4935e029/src%2Fpatterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fpatterns.rs?ref=5fb1140688ae9e8a0cfc9d90a00f7dad4935e029", "patch": "@@ -38,10 +38,11 @@ impl Rewrite for Pat {\n                 let sub_pat = match *sub_pat {\n                     Some(ref p) => {\n                         // 3 - ` @ `.\n-                        let width = try_opt!(shape.width.checked_sub(prefix.len() +\n-                                                                     mut_infix.len() +\n-                                                                     id_str.len() +\n-                                                                     3));\n+                        let width = try_opt!(shape\n+                                                 .width\n+                                                 .checked_sub(prefix.len() + mut_infix.len() +\n+                                                              id_str.len() +\n+                                                              3));\n                         format!(\" @ {}\",\n                                 try_opt!(p.rewrite(context, Shape::legacy(width, shape.indent))))\n                     }\n@@ -91,16 +92,22 @@ impl Rewrite for Pat {\n             PatKind::Lit(ref expr) => expr.rewrite(context, shape),\n             PatKind::Slice(ref prefix, ref slice_pat, ref suffix) => {\n                 // Rewrite all the sub-patterns.\n-                let prefix = prefix.iter().map(|p| p.rewrite(context, shape));\n-                let slice_pat = slice_pat.as_ref().map(|p| {\n-                                                           Some(format!(\"{}..\",\n-                                                            try_opt!(p.rewrite(context, shape))))\n-                                                       });\n-                let suffix = suffix.iter().map(|p| p.rewrite(context, shape));\n+                let prefix = prefix\n+                    .iter()\n+                    .map(|p| p.rewrite(context, shape));\n+                let slice_pat =\n+                    slice_pat\n+                        .as_ref()\n+                        .map(|p| Some(format!(\"{}..\", try_opt!(p.rewrite(context, shape)))));\n+                let suffix = suffix\n+                    .iter()\n+                    .map(|p| p.rewrite(context, shape));\n \n                 // Munge them together.\n-                let pats: Option<Vec<String>> =\n-                    prefix.chain(slice_pat.into_iter()).chain(suffix).collect();\n+                let pats: Option<Vec<String>> = prefix\n+                    .chain(slice_pat.into_iter())\n+                    .chain(suffix)\n+                    .collect();\n \n                 // Check that all the rewrites succeeded, and if not return None.\n                 let pats = try_opt!(pats);\n@@ -239,7 +246,9 @@ fn rewrite_tuple_pat(pats: &[ptr::P<ast::Pat>],\n                      context: &RewriteContext,\n                      shape: Shape)\n                      -> Option<String> {\n-    let mut pat_vec: Vec<_> = pats.into_iter().map(|x| TuplePatField::Pat(x)).collect();\n+    let mut pat_vec: Vec<_> = pats.into_iter()\n+        .map(|x| TuplePatField::Pat(x))\n+        .collect();\n \n     if let Some(pos) = dotdot_pos {\n         let prev = if pos == 0 {\n@@ -271,7 +280,10 @@ fn rewrite_tuple_pat(pats: &[ptr::P<ast::Pat>],\n     // add comma if `(x,)`\n     let add_comma = path_str.is_none() && pat_vec.len() == 1 && dotdot_pos.is_none();\n \n-    let path_len = path_str.as_ref().map(|p| p.len()).unwrap_or(0);\n+    let path_len = path_str\n+        .as_ref()\n+        .map(|p| p.len())\n+        .unwrap_or(0);\n     // 2 = \"()\".len(), 3 = \"(,)\".len()\n     let nested_shape = try_opt!(shape.sub_width(path_len + if add_comma { 3 } else { 2 }));\n     // 1 = \"(\".len()\n@@ -321,11 +333,13 @@ fn rewrite_tuple_pat(pats: &[ptr::P<ast::Pat>],\n fn count_wildcard_suffix_len(items: &[ListItem]) -> usize {\n     let mut suffix_len = 0;\n \n-    for item in items.iter().rev().take_while(|i| match i.item {\n-                                                  Some(ref internal_string) if internal_string ==\n-                                                                               \"_\" => true,\n-                                                  _ => false,\n-                                              }) {\n+    for item in items\n+            .iter()\n+            .rev()\n+            .take_while(|i| match i.item {\n+                            Some(ref internal_string) if internal_string == \"_\" => true,\n+                            _ => false,\n+                        }) {\n         suffix_len += 1;\n \n         if item.pre_comment.is_some() || item.post_comment.is_some() {"}, {"sha": "4d05f544290ea96dc53635b045cb502f75025f48", "filename": "src/rustfmt_diff.rs", "status": "modified", "additions": 15, "deletions": 5, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/5fb1140688ae9e8a0cfc9d90a00f7dad4935e029/src%2Frustfmt_diff.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fb1140688ae9e8a0cfc9d90a00f7dad4935e029/src%2Frustfmt_diff.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustfmt_diff.rs?ref=5fb1140688ae9e8a0cfc9d90a00f7dad4935e029", "patch": "@@ -42,10 +42,14 @@ pub fn make_diff(expected: &str, actual: &str, context_size: usize) -> Vec<Misma\n                 }\n \n                 while let Some(line) = context_queue.pop_front() {\n-                    mismatch.lines.push(DiffLine::Context(line.to_owned()));\n+                    mismatch\n+                        .lines\n+                        .push(DiffLine::Context(line.to_owned()));\n                 }\n \n-                mismatch.lines.push(DiffLine::Resulting(str.to_owned()));\n+                mismatch\n+                    .lines\n+                    .push(DiffLine::Resulting(str.to_owned()));\n                 lines_since_mismatch = 0;\n             }\n             diff::Result::Right(str) => {\n@@ -55,10 +59,14 @@ pub fn make_diff(expected: &str, actual: &str, context_size: usize) -> Vec<Misma\n                 }\n \n                 while let Some(line) = context_queue.pop_front() {\n-                    mismatch.lines.push(DiffLine::Context(line.to_owned()));\n+                    mismatch\n+                        .lines\n+                        .push(DiffLine::Context(line.to_owned()));\n                 }\n \n-                mismatch.lines.push(DiffLine::Expected(str.to_owned()));\n+                mismatch\n+                    .lines\n+                    .push(DiffLine::Expected(str.to_owned()));\n                 line_number += 1;\n                 lines_since_mismatch = 0;\n             }\n@@ -68,7 +76,9 @@ pub fn make_diff(expected: &str, actual: &str, context_size: usize) -> Vec<Misma\n                 }\n \n                 if lines_since_mismatch < context_size {\n-                    mismatch.lines.push(DiffLine::Context(str.to_owned()));\n+                    mismatch\n+                        .lines\n+                        .push(DiffLine::Context(str.to_owned()));\n                 } else {\n                     context_queue.push_back(str);\n                 }"}, {"sha": "e1e0681ba562abbcde854da742f1d5e80dba4897", "filename": "src/string.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5fb1140688ae9e8a0cfc9d90a00f7dad4935e029/src%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fb1140688ae9e8a0cfc9d90a00f7dad4935e029/src%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstring.rs?ref=5fb1140688ae9e8a0cfc9d90a00f7dad4935e029", "patch": "@@ -51,7 +51,10 @@ pub fn rewrite_string<'a>(orig: &str, fmt: &StringFormat<'a>) -> Option<String>\n     let ender_length = fmt.line_end.len();\n     // If we cannot put at least a single character per line, the rewrite won't\n     // succeed.\n-    let max_chars = try_opt!(shape.width.checked_sub(fmt.opener.len() + ender_length + 1)) + 1;\n+    let max_chars = try_opt!(shape\n+                                 .width\n+                                 .checked_sub(fmt.opener.len() + ender_length + 1)) +\n+                    1;\n \n     // Snip a line at a time from `orig` until it is used up. Push the snippet\n     // onto result."}, {"sha": "3a9335f39e57d3ee367e02e739feca950548f217", "filename": "src/types.rs", "status": "modified", "additions": 60, "deletions": 49, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/5fb1140688ae9e8a0cfc9d90a00f7dad4935e029/src%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fb1140688ae9e8a0cfc9d90a00f7dad4935e029/src%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftypes.rs?ref=5fb1140688ae9e8a0cfc9d90a00f7dad4935e029", "patch": "@@ -163,10 +163,11 @@ impl<'a> Rewrite for SegmentParam<'a> {\n                     TypeDensity::Compressed => format!(\"{}=\", binding.ident),\n                 };\n                 let budget = try_opt!(shape.width.checked_sub(result.len()));\n-                let rewrite = try_opt!(binding.ty.rewrite(context,\n-                                                          Shape::legacy(budget,\n-                                                                        shape.indent +\n-                                                                        result.len())));\n+                let rewrite =\n+                    try_opt!(binding\n+                                 .ty\n+                                 .rewrite(context,\n+                                          Shape::legacy(budget, shape.indent + result.len())));\n                 result.push_str(&rewrite);\n                 Some(result)\n             }\n@@ -202,16 +203,18 @@ fn rewrite_segment(path_context: PathContext,\n                 let param_list = data.lifetimes\n                     .iter()\n                     .map(SegmentParam::LifeTime)\n-                    .chain(data.types.iter().map(|x| SegmentParam::Type(&*x)))\n-                    .chain(data.bindings.iter().map(|x| SegmentParam::Binding(&*x)))\n+                    .chain(data.types\n+                               .iter()\n+                               .map(|x| SegmentParam::Type(&*x)))\n+                    .chain(data.bindings\n+                               .iter()\n+                               .map(|x| SegmentParam::Binding(&*x)))\n                     .collect::<Vec<_>>();\n \n-                let next_span_lo = param_list\n-                    .last()\n-                    .unwrap()\n-                    .get_span()\n-                    .hi + BytePos(1);\n-                let list_lo = context.codemap.span_after(codemap::mk_sp(*span_lo, span_hi), \"<\");\n+                let next_span_lo = param_list.last().unwrap().get_span().hi + BytePos(1);\n+                let list_lo = context\n+                    .codemap\n+                    .span_after(codemap::mk_sp(*span_lo, span_hi), \"<\");\n                 let separator = if path_context == PathContext::Expr {\n                     \"::\"\n                 } else {\n@@ -298,28 +301,29 @@ fn format_function_type<'a, I>(inputs: I,\n     // 1 for (\n     let offset = shape.indent + 1;\n     let list_lo = context.codemap.span_after(span, \"(\");\n-    let items =\n-        itemize_list(context.codemap,\n-                     // FIXME Would be nice to avoid this allocation,\n-                     // but I couldn't get the types to work out.\n-                     inputs.map(|i| ArgumentKind::Regular(Box::new(i))).chain(variadic_arg),\n-                     \")\",\n-                     |arg| match *arg {\n-                         ArgumentKind::Regular(ref ty) => ty.span().lo,\n-                         ArgumentKind::Variadic(start) => start,\n-                     },\n-                     |arg| match *arg {\n-                         ArgumentKind::Regular(ref ty) => ty.span().hi,\n-                         ArgumentKind::Variadic(start) => start + BytePos(3),\n-                     },\n-                     |arg| match *arg {\n-                         ArgumentKind::Regular(ref ty) => {\n-                             ty.rewrite(context, Shape::legacy(budget, offset))\n-                         }\n-                         ArgumentKind::Variadic(_) => Some(\"...\".to_owned()),\n-                     },\n-                     list_lo,\n-                     span.hi);\n+    let items = itemize_list(context.codemap,\n+                             // FIXME Would be nice to avoid this allocation,\n+                             // but I couldn't get the types to work out.\n+                             inputs\n+                                 .map(|i| ArgumentKind::Regular(Box::new(i)))\n+                                 .chain(variadic_arg),\n+                             \")\",\n+                             |arg| match *arg {\n+                                 ArgumentKind::Regular(ref ty) => ty.span().lo,\n+                                 ArgumentKind::Variadic(start) => start,\n+                             },\n+                             |arg| match *arg {\n+                                 ArgumentKind::Regular(ref ty) => ty.span().hi,\n+                                 ArgumentKind::Variadic(start) => start + BytePos(3),\n+                             },\n+                             |arg| match *arg {\n+                                 ArgumentKind::Regular(ref ty) => {\n+                                     ty.rewrite(context, Shape::legacy(budget, offset))\n+                                 }\n+                                 ArgumentKind::Variadic(_) => Some(\"...\".to_owned()),\n+                             },\n+                             list_lo,\n+                             span.hi);\n \n     let list_str = try_opt!(format_fn_args(items, Shape::legacy(budget, offset), context.config));\n \n@@ -455,8 +459,10 @@ fn rewrite_bounded_lifetime<'b, I>(lt: &ast::Lifetime,\n     if bounds.len() == 0 {\n         Some(result)\n     } else {\n-        let appendix: Vec<_> =\n-            try_opt!(bounds.into_iter().map(|b| b.rewrite(context, shape)).collect());\n+        let appendix: Vec<_> = try_opt!(bounds\n+                                            .into_iter()\n+                                            .map(|b| b.rewrite(context, shape))\n+                                            .collect());\n         let colon = type_bound_colon(context);\n         let result = format!(\"{}{}{}\", result, colon, appendix.join(\" + \"));\n         wrap_str(result, context.config.max_width, shape)\n@@ -494,7 +500,9 @@ impl Rewrite for ast::TyParamBounds {\n             TypeDensity::Compressed => \"+\",\n             TypeDensity::Wide => \" + \",\n         };\n-        let strs: Vec<_> = try_opt!(self.iter().map(|b| b.rewrite(context, shape)).collect());\n+        let strs: Vec<_> = try_opt!(self.iter()\n+                                        .map(|b| b.rewrite(context, shape))\n+                                        .collect());\n         wrap_str(strs.join(joiner), context.config.max_width, shape)\n     }\n }\n@@ -550,10 +558,10 @@ impl Rewrite for ast::PolyTraitRef {\n             // 6 is \"for<> \".len()\n             let extra_offset = lifetime_str.len() + 6;\n             let max_path_width = try_opt!(shape.width.checked_sub(extra_offset));\n-            let path_str = try_opt!(self.trait_ref.rewrite(context,\n-                                                           Shape::legacy(max_path_width,\n-                                                                         shape.indent +\n-                                                                         extra_offset)));\n+            let path_str = try_opt!(self.trait_ref\n+                                        .rewrite(context,\n+                                                 Shape::legacy(max_path_width,\n+                                                               shape.indent + extra_offset)));\n \n             Some(if context.config.spaces_within_angle_brackets && lifetime_str.len() > 0 {\n                      format!(\"for< {} > {}\", lifetime_str, path_str)\n@@ -599,18 +607,20 @@ impl Rewrite for ast::Ty {\n                     format!(\"&{} {}{}\",\n                             lt_str,\n                             mut_str,\n-                            try_opt!(mt.ty.rewrite(context,\n-                                                   Shape::legacy(budget,\n-                                                                 shape.indent + 2 + mut_len +\n-                                                                 lt_len))))\n+                            try_opt!(mt.ty\n+                                         .rewrite(context,\n+                                                  Shape::legacy(budget,\n+                                                                shape.indent + 2 + mut_len +\n+                                                                lt_len))))\n                 }\n                          None => {\n                     let budget = try_opt!(shape.width.checked_sub(1 + mut_len));\n                     format!(\"&{}{}\",\n                             mut_str,\n-                            try_opt!(mt.ty.rewrite(context,\n-                                                   Shape::legacy(budget,\n-                                                                 shape.indent + 1 + mut_len))))\n+                            try_opt!(mt.ty\n+                                         .rewrite(context,\n+                                                  Shape::legacy(budget,\n+                                                                shape.indent + 1 + mut_len))))\n                 }\n                      })\n             }\n@@ -662,7 +672,8 @@ impl Rewrite for ast::Ty {\n             ast::TyKind::Mac(..) => None,\n             ast::TyKind::ImplicitSelf => Some(String::from(\"\")),\n             ast::TyKind::ImplTrait(ref it) => {\n-                it.rewrite(context, shape).map(|it_str| format!(\"impl {}\", it_str))\n+                it.rewrite(context, shape)\n+                    .map(|it_str| format!(\"impl {}\", it_str))\n             }\n             ast::TyKind::Typeof(..) => unreachable!(),\n         }"}, {"sha": "84722cc9b322a0147192ff33c1dcf0cfd918b4af", "filename": "src/utils.rs", "status": "modified", "additions": 15, "deletions": 10, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/5fb1140688ae9e8a0cfc9d90a00f7dad4935e029/src%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fb1140688ae9e8a0cfc9d90a00f7dad4935e029/src%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils.rs?ref=5fb1140688ae9e8a0cfc9d90a00f7dad4935e029", "patch": "@@ -27,7 +27,11 @@ use SKIP_ANNOTATION;\n pub fn extra_offset(text: &str, shape: Shape) -> usize {\n     match text.rfind('\\n') {\n         // 1 for newline character\n-        Some(idx) => text.len().checked_sub(idx + 1 + shape.used_width()).unwrap_or(0),\n+        Some(idx) => {\n+            text.len()\n+                .checked_sub(idx + 1 + shape.used_width())\n+                .unwrap_or(0)\n+        }\n         None => text.len(),\n     }\n }\n@@ -40,9 +44,13 @@ pub fn format_visibility(vis: &Visibility) -> Cow<'static, str> {\n         Visibility::Crate(_) => Cow::from(\"pub(crate) \"),\n         Visibility::Restricted { ref path, .. } => {\n             let Path { ref segments, .. } = **path;\n-            let mut segments_iter = segments.iter().map(|seg| seg.identifier.name.as_str());\n+            let mut segments_iter = segments\n+                .iter()\n+                .map(|seg| seg.identifier.name.as_str());\n             if path.is_global() {\n-                segments_iter.next().expect(\"Non-global path in pub(restricted)?\");\n+                segments_iter\n+                    .next()\n+                    .expect(\"Non-global path in pub(restricted)?\");\n             }\n \n             Cow::from(format!(\"pub({}) \", segments_iter.join(\"::\")))\n@@ -176,7 +184,9 @@ pub fn stmt_expr(stmt: &ast::Stmt) -> Option<&ast::Expr> {\n pub fn trim_newlines(input: &str) -> &str {\n     match input.find(|c| c != '\\n' && c != '\\r') {\n         Some(start) => {\n-            let end = input.rfind(|c| c != '\\n' && c != '\\r').unwrap_or(0) + 1;\n+            let end = input\n+                .rfind(|c| c != '\\n' && c != '\\r')\n+                .unwrap_or(0) + 1;\n             &input[start..end]\n         }\n         None => \"\",\n@@ -279,12 +289,7 @@ pub fn wrap_str<S: AsRef<str>>(s: S, max_width: usize, shape: Shape) -> Option<S\n             // indentation.\n             // A special check for the last line, since the caller may\n             // place trailing characters on this line.\n-            if snippet\n-                   .lines()\n-                   .rev()\n-                   .next()\n-                   .unwrap()\n-                   .len() > shape.indent.width() + shape.width {\n+            if snippet.lines().rev().next().unwrap().len() > shape.indent.width() + shape.width {\n                 return None;\n             }\n         }"}, {"sha": "e3d1505fd1ebaa3f4d0cf9d7fdcc1ce096d974f9", "filename": "src/visitor.rs", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/5fb1140688ae9e8a0cfc9d90a00f7dad4935e029/src%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fb1140688ae9e8a0cfc9d90a00f7dad4935e029/src%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvisitor.rs?ref=5fb1140688ae9e8a0cfc9d90a00f7dad4935e029", "patch": "@@ -48,7 +48,9 @@ impl<'a> FmtVisitor<'a> {\n                self.codemap.lookup_char_pos(stmt.span.hi));\n \n         // FIXME(#434): Move this check to somewhere more central, eg Rewrite.\n-        if !self.config.file_lines.contains(&self.codemap.lookup_line_range(stmt.span)) {\n+        if !self.config\n+                .file_lines\n+                .contains(&self.codemap.lookup_line_range(stmt.span)) {\n             return;\n         }\n \n@@ -116,7 +118,8 @@ impl<'a> FmtVisitor<'a> {\n         } else {\n             self.config.tab_spaces\n         };\n-        self.buffer.truncate(total_len - chars_too_many);\n+        self.buffer\n+            .truncate(total_len - chars_too_many);\n         self.buffer.push_str(\"}\");\n         self.block_indent = self.block_indent.block_unindent(self.config);\n     }\n@@ -187,7 +190,9 @@ impl<'a> FmtVisitor<'a> {\n         // the AST lumps them all together.\n         match item.node {\n             ast::ItemKind::Mod(ref m) => {\n-                let outer_file = self.codemap.lookup_char_pos(item.span.lo).file;\n+                let outer_file = self.codemap\n+                    .lookup_char_pos(item.span.lo)\n+                    .file;\n                 let inner_file = self.codemap.lookup_char_pos(m.inner.lo).file;\n                 if outer_file.name == inner_file.name {\n                     // Module is inline, in this case we treat modules like any\n@@ -506,8 +511,10 @@ impl<'a> FmtVisitor<'a> {\n             // to be potentially reordered within `format_imports`. Otherwise, just format the\n             // next item for output.\n             if self.config.reorder_imports && is_use_item(&*items_left[0]) {\n-                let use_item_length =\n-                    items_left.iter().take_while(|ppi| is_use_item(&***ppi)).count();\n+                let use_item_length = items_left\n+                    .iter()\n+                    .take_while(|ppi| is_use_item(&***ppi))\n+                    .count();\n                 let (use_items, rest) = items_left.split_at(use_item_length);\n                 self.format_imports(use_items);\n                 items_left = rest;\n@@ -528,7 +535,8 @@ impl<'a> FmtVisitor<'a> {\n         let is_internal = !(inner_span.lo.0 == 0 && inner_span.hi.0 == 0) &&\n                           local_file_name == self.codemap.span_to_filename(inner_span);\n \n-        self.buffer.push_str(&*utils::format_visibility(vis));\n+        self.buffer\n+            .push_str(&*utils::format_visibility(vis));\n         self.buffer.push_str(\"mod \");\n         self.buffer.push_str(&ident.to_string());\n "}]}