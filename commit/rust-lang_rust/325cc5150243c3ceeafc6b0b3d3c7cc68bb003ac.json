{"sha": "325cc5150243c3ceeafc6b0b3d3c7cc68bb003ac", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMyNWNjNTE1MDI0M2MzY2VlYWZjNmIwYjNkM2M3Y2M2OGJiMDAzYWM=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-05-13T04:30:48Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-05-14T06:59:03Z"}, "message": "core: Inherit the atomics module", "tree": {"sha": "4353558650cbeaca585ea872b1fad4a7d3842ef9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4353558650cbeaca585ea872b1fad4a7d3842ef9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/325cc5150243c3ceeafc6b0b3d3c7cc68bb003ac", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/325cc5150243c3ceeafc6b0b3d3c7cc68bb003ac", "html_url": "https://github.com/rust-lang/rust/commit/325cc5150243c3ceeafc6b0b3d3c7cc68bb003ac", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/325cc5150243c3ceeafc6b0b3d3c7cc68bb003ac/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e4414739a5897ff2a4b35de5f7e1436b6e3f3f10", "url": "https://api.github.com/repos/rust-lang/rust/commits/e4414739a5897ff2a4b35de5f7e1436b6e3f3f10", "html_url": "https://github.com/rust-lang/rust/commit/e4414739a5897ff2a4b35de5f7e1436b6e3f3f10"}], "stats": {"total": 1608, "additions": 813, "deletions": 795}, "files": [{"sha": "9edce3bd6756edf5c8fbb4eba2b86cfa8ba6cb69", "filename": "src/libcore/atomics.rs", "status": "added", "additions": 791, "deletions": 0, "changes": 791, "blob_url": "https://github.com/rust-lang/rust/blob/325cc5150243c3ceeafc6b0b3d3c7cc68bb003ac/src%2Flibcore%2Fatomics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/325cc5150243c3ceeafc6b0b3d3c7cc68bb003ac/src%2Flibcore%2Fatomics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fatomics.rs?ref=325cc5150243c3ceeafc6b0b3d3c7cc68bb003ac", "patch": "@@ -0,0 +1,791 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Core atomic primitives\n+\n+use intrinsics;\n+use std::kinds::marker;\n+use ty::Unsafe;\n+\n+/// An atomic boolean type.\n+pub struct AtomicBool {\n+    v: Unsafe<uint>,\n+    nocopy: marker::NoCopy\n+}\n+\n+/// A signed atomic integer type, supporting basic atomic arithmetic operations\n+pub struct AtomicInt {\n+    v: Unsafe<int>,\n+    nocopy: marker::NoCopy\n+}\n+\n+/// An unsigned atomic integer type, supporting basic atomic arithmetic operations\n+pub struct AtomicUint {\n+    v: Unsafe<uint>,\n+    nocopy: marker::NoCopy\n+}\n+\n+/// An unsafe atomic pointer. Only supports basic atomic operations\n+pub struct AtomicPtr<T> {\n+    p: Unsafe<uint>,\n+    nocopy: marker::NoCopy\n+}\n+\n+/// Atomic memory orderings\n+///\n+/// Memory orderings limit the ways that both the compiler and CPU may reorder\n+/// instructions around atomic operations. At its most restrictive,\n+/// \"sequentially consistent\" atomics allow neither reads nor writes\n+/// to be moved either before or after the atomic operation; on the other end\n+/// \"relaxed\" atomics allow all reorderings.\n+///\n+/// Rust's memory orderings are the same as in C++[1].\n+///\n+/// 1: http://gcc.gnu.org/wiki/Atomic/GCCMM/AtomicSync\n+pub enum Ordering {\n+    /// No ordering constraints, only atomic operations\n+    Relaxed,\n+    /// When coupled with a store, all previous writes become visible\n+    /// to another thread that performs a load with `Acquire` ordering\n+    /// on the same value\n+    Release,\n+    /// When coupled with a load, all subsequent loads will see data\n+    /// written before a store with `Release` ordering on the same value\n+    /// in another thread\n+    Acquire,\n+    /// When coupled with a load, uses `Acquire` ordering, and with a store\n+    /// `Release` ordering\n+    AcqRel,\n+    /// Like `AcqRel` with the additional guarantee that all threads see all\n+    /// sequentially consistent operations in the same order.\n+    SeqCst\n+}\n+\n+/// An `AtomicBool` initialized to `false`\n+pub static INIT_ATOMIC_BOOL : AtomicBool = AtomicBool { v: Unsafe{value: 0,\n+                                                                  marker1: marker::InvariantType},\n+                                                        nocopy: marker::NoCopy };\n+/// An `AtomicInt` initialized to `0`\n+pub static INIT_ATOMIC_INT  : AtomicInt  = AtomicInt  { v: Unsafe{value: 0,\n+                                                                  marker1: marker::InvariantType},\n+                                                        nocopy: marker::NoCopy };\n+/// An `AtomicUint` initialized to `0`\n+pub static INIT_ATOMIC_UINT : AtomicUint = AtomicUint { v: Unsafe{value: 0,\n+                                                                  marker1: marker::InvariantType},\n+                                                        nocopy: marker::NoCopy };\n+\n+// NB: Needs to be -1 (0b11111111...) to make fetch_nand work correctly\n+static UINT_TRUE: uint = -1;\n+\n+impl AtomicBool {\n+    /// Create a new `AtomicBool`\n+    pub fn new(v: bool) -> AtomicBool {\n+        let val = if v { UINT_TRUE } else { 0 };\n+        AtomicBool { v: Unsafe::new(val), nocopy: marker::NoCopy }\n+    }\n+\n+    /// Load the value\n+    #[inline]\n+    pub fn load(&self, order: Ordering) -> bool {\n+        unsafe { atomic_load(self.v.get() as *uint, order) > 0 }\n+    }\n+\n+    /// Store the value\n+    #[inline]\n+    pub fn store(&self, val: bool, order: Ordering) {\n+        let val = if val { UINT_TRUE } else { 0 };\n+\n+        unsafe { atomic_store(self.v.get(), val, order); }\n+    }\n+\n+    /// Store a value, returning the old value\n+    #[inline]\n+    pub fn swap(&self, val: bool, order: Ordering) -> bool {\n+        let val = if val { UINT_TRUE } else { 0 };\n+\n+        unsafe { atomic_swap(self.v.get(), val, order) > 0 }\n+    }\n+\n+    /// If the current value is the same as expected, store a new value\n+    ///\n+    /// Compare the current value with `old`; if they are the same then\n+    /// replace the current value with `new`. Return the previous value.\n+    /// If the return value is equal to `old` then the value was updated.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```ignore\n+    /// # // FIXME: Needs PR #12430\n+    /// extern crate sync;\n+    ///\n+    /// use sync::Arc;\n+    /// use std::sync::atomics::{AtomicBool, SeqCst};\n+    ///\n+    /// fn main() {\n+    ///     let spinlock = Arc::new(AtomicBool::new(false));\n+    ///     let spinlock_clone = spin_lock.clone();\n+    ///\n+    ///     spawn(proc() {\n+    ///         with_lock(&spinlock, || println!(\"task 1 in lock\"));\n+    ///     });\n+    ///\n+    ///     spawn(proc() {\n+    ///         with_lock(&spinlock_clone, || println!(\"task 2 in lock\"));\n+    ///     });\n+    /// }\n+    ///\n+    /// fn with_lock(spinlock: &Arc<AtomicBool>, f: || -> ()) {\n+    ///     // CAS loop until we are able to replace `false` with `true`\n+    ///     while spinlock.compare_and_swap(false, true, SeqCst) == false {\n+    ///         // Since tasks may not be preemptive (if they are green threads)\n+    ///         // yield to the scheduler to let the other task run. Low level\n+    ///         // concurrent code needs to take into account Rust's two threading\n+    ///         // models.\n+    ///         deschedule();\n+    ///     }\n+    ///\n+    ///     // Now we have the spinlock\n+    ///     f();\n+    ///\n+    ///     // Release the lock\n+    ///     spinlock.store(false);\n+    /// }\n+    /// ```\n+    #[inline]\n+    pub fn compare_and_swap(&self, old: bool, new: bool, order: Ordering) -> bool {\n+        let old = if old { UINT_TRUE } else { 0 };\n+        let new = if new { UINT_TRUE } else { 0 };\n+\n+        unsafe { atomic_compare_and_swap(self.v.get(), old, new, order) > 0 }\n+    }\n+\n+    /// A logical \"and\" operation\n+    ///\n+    /// Performs a logical \"and\" operation on the current value and the\n+    /// argument `val`, and sets the new value to the result.\n+    /// Returns the previous value.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::atomics::{AtomicBool, SeqCst};\n+    ///\n+    /// let foo = AtomicBool::new(true);\n+    /// assert_eq!(true, foo.fetch_and(false, SeqCst));\n+    /// assert_eq!(false, foo.load(SeqCst));\n+    ///\n+    /// let foo = AtomicBool::new(true);\n+    /// assert_eq!(true, foo.fetch_and(true, SeqCst));\n+    /// assert_eq!(true, foo.load(SeqCst));\n+    ///\n+    /// let foo = AtomicBool::new(false);\n+    /// assert_eq!(false, foo.fetch_and(false, SeqCst));\n+    /// assert_eq!(false, foo.load(SeqCst));\n+    /// ```\n+    #[inline]\n+    pub fn fetch_and(&self, val: bool, order: Ordering) -> bool {\n+        let val = if val { UINT_TRUE } else { 0 };\n+\n+        unsafe { atomic_and(self.v.get(), val, order) > 0 }\n+    }\n+\n+    /// A logical \"nand\" operation\n+    ///\n+    /// Performs a logical \"nand\" operation on the current value and the\n+    /// argument `val`, and sets the new value to the result.\n+    /// Returns the previous value.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::atomics::{AtomicBool, SeqCst};\n+    ///\n+    /// let foo = AtomicBool::new(true);\n+    /// assert_eq!(true, foo.fetch_nand(false, SeqCst));\n+    /// assert_eq!(true, foo.load(SeqCst));\n+    ///\n+    /// let foo = AtomicBool::new(true);\n+    /// assert_eq!(true, foo.fetch_nand(true, SeqCst));\n+    /// assert_eq!(0, foo.load(SeqCst) as int);\n+    /// assert_eq!(false, foo.load(SeqCst));\n+    ///\n+    /// let foo = AtomicBool::new(false);\n+    /// assert_eq!(false, foo.fetch_nand(false, SeqCst));\n+    /// assert_eq!(true, foo.load(SeqCst));\n+    /// ```\n+    #[inline]\n+    pub fn fetch_nand(&self, val: bool, order: Ordering) -> bool {\n+        let val = if val { UINT_TRUE } else { 0 };\n+\n+        unsafe { atomic_nand(self.v.get(), val, order) > 0 }\n+    }\n+\n+    /// A logical \"or\" operation\n+    ///\n+    /// Performs a logical \"or\" operation on the current value and the\n+    /// argument `val`, and sets the new value to the result.\n+    /// Returns the previous value.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::atomics::{AtomicBool, SeqCst};\n+    ///\n+    /// let foo = AtomicBool::new(true);\n+    /// assert_eq!(true, foo.fetch_or(false, SeqCst));\n+    /// assert_eq!(true, foo.load(SeqCst));\n+    ///\n+    /// let foo = AtomicBool::new(true);\n+    /// assert_eq!(true, foo.fetch_or(true, SeqCst));\n+    /// assert_eq!(true, foo.load(SeqCst));\n+    ///\n+    /// let foo = AtomicBool::new(false);\n+    /// assert_eq!(false, foo.fetch_or(false, SeqCst));\n+    /// assert_eq!(false, foo.load(SeqCst));\n+    /// ```\n+    #[inline]\n+    pub fn fetch_or(&self, val: bool, order: Ordering) -> bool {\n+        let val = if val { UINT_TRUE } else { 0 };\n+\n+        unsafe { atomic_or(self.v.get(), val, order) > 0 }\n+    }\n+\n+    /// A logical \"xor\" operation\n+    ///\n+    /// Performs a logical \"xor\" operation on the current value and the\n+    /// argument `val`, and sets the new value to the result.\n+    /// Returns the previous value.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::atomics::{AtomicBool, SeqCst};\n+    ///\n+    /// let foo = AtomicBool::new(true);\n+    /// assert_eq!(true, foo.fetch_xor(false, SeqCst));\n+    /// assert_eq!(true, foo.load(SeqCst));\n+    ///\n+    /// let foo = AtomicBool::new(true);\n+    /// assert_eq!(true, foo.fetch_xor(true, SeqCst));\n+    /// assert_eq!(false, foo.load(SeqCst));\n+    ///\n+    /// let foo = AtomicBool::new(false);\n+    /// assert_eq!(false, foo.fetch_xor(false, SeqCst));\n+    /// assert_eq!(false, foo.load(SeqCst));\n+    /// ```\n+    #[inline]\n+    pub fn fetch_xor(&self, val: bool, order: Ordering) -> bool {\n+        let val = if val { UINT_TRUE } else { 0 };\n+\n+        unsafe { atomic_xor(self.v.get(), val, order) > 0 }\n+    }\n+}\n+\n+impl AtomicInt {\n+    /// Create a new `AtomicInt`\n+    pub fn new(v: int) -> AtomicInt {\n+        AtomicInt {v: Unsafe::new(v), nocopy: marker::NoCopy}\n+    }\n+\n+    /// Load the value\n+    #[inline]\n+    pub fn load(&self, order: Ordering) -> int {\n+        unsafe { atomic_load(self.v.get() as *int, order) }\n+    }\n+\n+    /// Store the value\n+    #[inline]\n+    pub fn store(&self, val: int, order: Ordering) {\n+        unsafe { atomic_store(self.v.get(), val, order); }\n+    }\n+\n+    /// Store a value, returning the old value\n+    #[inline]\n+    pub fn swap(&self, val: int, order: Ordering) -> int {\n+        unsafe { atomic_swap(self.v.get(), val, order) }\n+    }\n+\n+    /// If the current value is the same as expected, store a new value\n+    ///\n+    /// Compare the current value with `old`; if they are the same then\n+    /// replace the current value with `new`. Return the previous value.\n+    /// If the return value is equal to `old` then the value was updated.\n+    #[inline]\n+    pub fn compare_and_swap(&self, old: int, new: int, order: Ordering) -> int {\n+        unsafe { atomic_compare_and_swap(self.v.get(), old, new, order) }\n+    }\n+\n+    /// Add to the current value, returning the previous\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::atomics::{AtomicInt, SeqCst};\n+    ///\n+    /// let foo = AtomicInt::new(0);\n+    /// assert_eq!(0, foo.fetch_add(10, SeqCst));\n+    /// assert_eq!(10, foo.load(SeqCst));\n+    /// ```\n+    #[inline]\n+    pub fn fetch_add(&self, val: int, order: Ordering) -> int {\n+        unsafe { atomic_add(self.v.get(), val, order) }\n+    }\n+\n+    /// Subtract from the current value, returning the previous\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::atomics::{AtomicInt, SeqCst};\n+    ///\n+    /// let foo = AtomicInt::new(0);\n+    /// assert_eq!(0, foo.fetch_sub(10, SeqCst));\n+    /// assert_eq!(-10, foo.load(SeqCst));\n+    /// ```\n+    #[inline]\n+    pub fn fetch_sub(&self, val: int, order: Ordering) -> int {\n+        unsafe { atomic_sub(self.v.get(), val, order) }\n+    }\n+\n+    /// Bitwise and with the current value, returning the previous\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::atomics::{AtomicUint, SeqCst};\n+    ///\n+    /// let foo = AtomicUint::new(0b101101);\n+    /// assert_eq!(0b101101, foo.fetch_and(0b110011, SeqCst));\n+    /// assert_eq!(0b100001, foo.load(SeqCst));\n+    #[inline]\n+    pub fn fetch_and(&self, val: int, order: Ordering) -> int {\n+        unsafe { atomic_and(self.v.get(), val, order) }\n+    }\n+\n+    /// Bitwise or with the current value, returning the previous\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::atomics::{AtomicUint, SeqCst};\n+    ///\n+    /// let foo = AtomicUint::new(0b101101);\n+    /// assert_eq!(0b101101, foo.fetch_or(0b110011, SeqCst));\n+    /// assert_eq!(0b111111, foo.load(SeqCst));\n+    #[inline]\n+    pub fn fetch_or(&self, val: int, order: Ordering) -> int {\n+        unsafe { atomic_or(self.v.get(), val, order) }\n+    }\n+\n+    /// Bitwise xor with the current value, returning the previous\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::atomics::{AtomicUint, SeqCst};\n+    ///\n+    /// let foo = AtomicUint::new(0b101101);\n+    /// assert_eq!(0b101101, foo.fetch_xor(0b110011, SeqCst));\n+    /// assert_eq!(0b011110, foo.load(SeqCst));\n+    #[inline]\n+    pub fn fetch_xor(&self, val: int, order: Ordering) -> int {\n+        unsafe { atomic_xor(self.v.get(), val, order) }\n+    }\n+}\n+\n+impl AtomicUint {\n+    /// Create a new `AtomicUint`\n+    pub fn new(v: uint) -> AtomicUint {\n+        AtomicUint { v: Unsafe::new(v), nocopy: marker::NoCopy }\n+    }\n+\n+    /// Load the value\n+    #[inline]\n+    pub fn load(&self, order: Ordering) -> uint {\n+        unsafe { atomic_load(self.v.get() as *uint, order) }\n+    }\n+\n+    /// Store the value\n+    #[inline]\n+    pub fn store(&self, val: uint, order: Ordering) {\n+        unsafe { atomic_store(self.v.get(), val, order); }\n+    }\n+\n+    /// Store a value, returning the old value\n+    #[inline]\n+    pub fn swap(&self, val: uint, order: Ordering) -> uint {\n+        unsafe { atomic_swap(self.v.get(), val, order) }\n+    }\n+\n+    /// If the current value is the same as expected, store a new value\n+    ///\n+    /// Compare the current value with `old`; if they are the same then\n+    /// replace the current value with `new`. Return the previous value.\n+    /// If the return value is equal to `old` then the value was updated.\n+    #[inline]\n+    pub fn compare_and_swap(&self, old: uint, new: uint, order: Ordering) -> uint {\n+        unsafe { atomic_compare_and_swap(self.v.get(), old, new, order) }\n+    }\n+\n+    /// Add to the current value, returning the previous\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::atomics::{AtomicUint, SeqCst};\n+    ///\n+    /// let foo = AtomicUint::new(0);\n+    /// assert_eq!(0, foo.fetch_add(10, SeqCst));\n+    /// assert_eq!(10, foo.load(SeqCst));\n+    /// ```\n+    #[inline]\n+    pub fn fetch_add(&self, val: uint, order: Ordering) -> uint {\n+        unsafe { atomic_add(self.v.get(), val, order) }\n+    }\n+\n+    /// Subtract from the current value, returning the previous\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::atomics::{AtomicUint, SeqCst};\n+    ///\n+    /// let foo = AtomicUint::new(10);\n+    /// assert_eq!(10, foo.fetch_sub(10, SeqCst));\n+    /// assert_eq!(0, foo.load(SeqCst));\n+    /// ```\n+    #[inline]\n+    pub fn fetch_sub(&self, val: uint, order: Ordering) -> uint {\n+        unsafe { atomic_sub(self.v.get(), val, order) }\n+    }\n+\n+    /// Bitwise and with the current value, returning the previous\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::atomics::{AtomicUint, SeqCst};\n+    ///\n+    /// let foo = AtomicUint::new(0b101101);\n+    /// assert_eq!(0b101101, foo.fetch_and(0b110011, SeqCst));\n+    /// assert_eq!(0b100001, foo.load(SeqCst));\n+    #[inline]\n+    pub fn fetch_and(&self, val: uint, order: Ordering) -> uint {\n+        unsafe { atomic_and(self.v.get(), val, order) }\n+    }\n+\n+    /// Bitwise or with the current value, returning the previous\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::atomics::{AtomicUint, SeqCst};\n+    ///\n+    /// let foo = AtomicUint::new(0b101101);\n+    /// assert_eq!(0b101101, foo.fetch_or(0b110011, SeqCst));\n+    /// assert_eq!(0b111111, foo.load(SeqCst));\n+    #[inline]\n+    pub fn fetch_or(&self, val: uint, order: Ordering) -> uint {\n+        unsafe { atomic_or(self.v.get(), val, order) }\n+    }\n+\n+    /// Bitwise xor with the current value, returning the previous\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::atomics::{AtomicUint, SeqCst};\n+    ///\n+    /// let foo = AtomicUint::new(0b101101);\n+    /// assert_eq!(0b101101, foo.fetch_xor(0b110011, SeqCst));\n+    /// assert_eq!(0b011110, foo.load(SeqCst));\n+    #[inline]\n+    pub fn fetch_xor(&self, val: uint, order: Ordering) -> uint {\n+        unsafe { atomic_xor(self.v.get(), val, order) }\n+    }\n+}\n+\n+impl<T> AtomicPtr<T> {\n+    /// Create a new `AtomicPtr`\n+    pub fn new(p: *mut T) -> AtomicPtr<T> {\n+        AtomicPtr { p: Unsafe::new(p as uint), nocopy: marker::NoCopy }\n+    }\n+\n+    /// Load the value\n+    #[inline]\n+    pub fn load(&self, order: Ordering) -> *mut T {\n+        unsafe {\n+            atomic_load(self.p.get() as **mut T, order) as *mut T\n+        }\n+    }\n+\n+    /// Store the value\n+    #[inline]\n+    pub fn store(&self, ptr: *mut T, order: Ordering) {\n+        unsafe { atomic_store(self.p.get(), ptr as uint, order); }\n+    }\n+\n+    /// Store a value, returning the old value\n+    #[inline]\n+    pub fn swap(&self, ptr: *mut T, order: Ordering) -> *mut T {\n+        unsafe { atomic_swap(self.p.get(), ptr as uint, order) as *mut T }\n+    }\n+\n+    /// If the current value is the same as expected, store a new value\n+    ///\n+    /// Compare the current value with `old`; if they are the same then\n+    /// replace the current value with `new`. Return the previous value.\n+    /// If the return value is equal to `old` then the value was updated.\n+    #[inline]\n+    pub fn compare_and_swap(&self, old: *mut T, new: *mut T, order: Ordering) -> *mut T {\n+        unsafe {\n+            atomic_compare_and_swap(self.p.get(), old as uint,\n+                                    new as uint, order) as *mut T\n+        }\n+    }\n+}\n+\n+#[inline]\n+unsafe fn atomic_store<T>(dst: *mut T, val: T, order:Ordering) {\n+    match order {\n+        Release => intrinsics::atomic_store_rel(dst, val),\n+        Relaxed => intrinsics::atomic_store_relaxed(dst, val),\n+        _       => intrinsics::atomic_store(dst, val)\n+    }\n+}\n+\n+#[inline]\n+unsafe fn atomic_load<T>(dst: *T, order:Ordering) -> T {\n+    match order {\n+        Acquire => intrinsics::atomic_load_acq(dst),\n+        Relaxed => intrinsics::atomic_load_relaxed(dst),\n+        _       => intrinsics::atomic_load(dst)\n+    }\n+}\n+\n+#[inline]\n+unsafe fn atomic_swap<T>(dst: *mut T, val: T, order: Ordering) -> T {\n+    match order {\n+        Acquire => intrinsics::atomic_xchg_acq(dst, val),\n+        Release => intrinsics::atomic_xchg_rel(dst, val),\n+        AcqRel  => intrinsics::atomic_xchg_acqrel(dst, val),\n+        Relaxed => intrinsics::atomic_xchg_relaxed(dst, val),\n+        _       => intrinsics::atomic_xchg(dst, val)\n+    }\n+}\n+\n+/// Returns the old value (like __sync_fetch_and_add).\n+#[inline]\n+unsafe fn atomic_add<T>(dst: *mut T, val: T, order: Ordering) -> T {\n+    match order {\n+        Acquire => intrinsics::atomic_xadd_acq(dst, val),\n+        Release => intrinsics::atomic_xadd_rel(dst, val),\n+        AcqRel  => intrinsics::atomic_xadd_acqrel(dst, val),\n+        Relaxed => intrinsics::atomic_xadd_relaxed(dst, val),\n+        _       => intrinsics::atomic_xadd(dst, val)\n+    }\n+}\n+\n+/// Returns the old value (like __sync_fetch_and_sub).\n+#[inline]\n+unsafe fn atomic_sub<T>(dst: *mut T, val: T, order: Ordering) -> T {\n+    match order {\n+        Acquire => intrinsics::atomic_xsub_acq(dst, val),\n+        Release => intrinsics::atomic_xsub_rel(dst, val),\n+        AcqRel  => intrinsics::atomic_xsub_acqrel(dst, val),\n+        Relaxed => intrinsics::atomic_xsub_relaxed(dst, val),\n+        _       => intrinsics::atomic_xsub(dst, val)\n+    }\n+}\n+\n+#[inline]\n+unsafe fn atomic_compare_and_swap<T>(dst: *mut T, old:T, new:T, order: Ordering) -> T {\n+    match order {\n+        Acquire => intrinsics::atomic_cxchg_acq(dst, old, new),\n+        Release => intrinsics::atomic_cxchg_rel(dst, old, new),\n+        AcqRel  => intrinsics::atomic_cxchg_acqrel(dst, old, new),\n+        Relaxed => intrinsics::atomic_cxchg_relaxed(dst, old, new),\n+        _       => intrinsics::atomic_cxchg(dst, old, new),\n+    }\n+}\n+\n+#[inline]\n+unsafe fn atomic_and<T>(dst: *mut T, val: T, order: Ordering) -> T {\n+    match order {\n+        Acquire => intrinsics::atomic_and_acq(dst, val),\n+        Release => intrinsics::atomic_and_rel(dst, val),\n+        AcqRel  => intrinsics::atomic_and_acqrel(dst, val),\n+        Relaxed => intrinsics::atomic_and_relaxed(dst, val),\n+        _       => intrinsics::atomic_and(dst, val)\n+    }\n+}\n+\n+#[inline]\n+unsafe fn atomic_nand<T>(dst: *mut T, val: T, order: Ordering) -> T {\n+    match order {\n+        Acquire => intrinsics::atomic_nand_acq(dst, val),\n+        Release => intrinsics::atomic_nand_rel(dst, val),\n+        AcqRel  => intrinsics::atomic_nand_acqrel(dst, val),\n+        Relaxed => intrinsics::atomic_nand_relaxed(dst, val),\n+        _       => intrinsics::atomic_nand(dst, val)\n+    }\n+}\n+\n+\n+#[inline]\n+unsafe fn atomic_or<T>(dst: *mut T, val: T, order: Ordering) -> T {\n+    match order {\n+        Acquire => intrinsics::atomic_or_acq(dst, val),\n+        Release => intrinsics::atomic_or_rel(dst, val),\n+        AcqRel  => intrinsics::atomic_or_acqrel(dst, val),\n+        Relaxed => intrinsics::atomic_or_relaxed(dst, val),\n+        _       => intrinsics::atomic_or(dst, val)\n+    }\n+}\n+\n+\n+#[inline]\n+unsafe fn atomic_xor<T>(dst: *mut T, val: T, order: Ordering) -> T {\n+    match order {\n+        Acquire => intrinsics::atomic_xor_acq(dst, val),\n+        Release => intrinsics::atomic_xor_rel(dst, val),\n+        AcqRel  => intrinsics::atomic_xor_acqrel(dst, val),\n+        Relaxed => intrinsics::atomic_xor_relaxed(dst, val),\n+        _       => intrinsics::atomic_xor(dst, val)\n+    }\n+}\n+\n+\n+/// An atomic fence.\n+///\n+/// A fence 'A' which has `Release` ordering semantics, synchronizes with a\n+/// fence 'B' with (at least) `Acquire` semantics, if and only if there exists\n+/// atomic operations X and Y, both operating on some atomic object 'M' such\n+/// that A is sequenced before X, Y is synchronized before B and Y observers\n+/// the change to M. This provides a happens-before dependence between A and B.\n+///\n+/// Atomic operations with `Release` or `Acquire` semantics can also synchronize\n+/// with a fence.\n+///\n+/// A fence with has `SeqCst` ordering, in addition to having both `Acquire` and\n+/// `Release` semantics, participates in the global program order of the other\n+/// `SeqCst` operations and/or fences.\n+///\n+/// Accepts `Acquire`, `Release`, `AcqRel` and `SeqCst` orderings.\n+///\n+/// # Failure\n+///\n+/// Fails if `order` is `Relaxed`\n+#[inline]\n+pub fn fence(order: Ordering) {\n+    unsafe {\n+        match order {\n+            Acquire => intrinsics::atomic_fence_acq(),\n+            Release => intrinsics::atomic_fence_rel(),\n+            AcqRel  => intrinsics::atomic_fence_acqrel(),\n+            SeqCst  => intrinsics::atomic_fence(),\n+            Relaxed => fail!(\"there is no such thing as a relaxed fence\")\n+        }\n+    }\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    use super::*;\n+\n+    #[test]\n+    fn bool_() {\n+        let a = AtomicBool::new(false);\n+        assert_eq!(a.compare_and_swap(false, true, SeqCst), false);\n+        assert_eq!(a.compare_and_swap(false, true, SeqCst), true);\n+\n+        a.store(false, SeqCst);\n+        assert_eq!(a.compare_and_swap(false, true, SeqCst), false);\n+    }\n+\n+    #[test]\n+    fn bool_and() {\n+        let a = AtomicBool::new(true);\n+        assert_eq!(a.fetch_and(false, SeqCst),true);\n+        assert_eq!(a.load(SeqCst),false);\n+    }\n+\n+    #[test]\n+    fn uint_and() {\n+        let x = AtomicUint::new(0xf731);\n+        assert_eq!(x.fetch_and(0x137f, SeqCst), 0xf731);\n+        assert_eq!(x.load(SeqCst), 0xf731 & 0x137f);\n+    }\n+\n+    #[test]\n+    fn uint_or() {\n+        let x = AtomicUint::new(0xf731);\n+        assert_eq!(x.fetch_or(0x137f, SeqCst), 0xf731);\n+        assert_eq!(x.load(SeqCst), 0xf731 | 0x137f);\n+    }\n+\n+    #[test]\n+    fn uint_xor() {\n+        let x = AtomicUint::new(0xf731);\n+        assert_eq!(x.fetch_xor(0x137f, SeqCst), 0xf731);\n+        assert_eq!(x.load(SeqCst), 0xf731 ^ 0x137f);\n+    }\n+\n+    #[test]\n+    fn int_and() {\n+        let x = AtomicInt::new(0xf731);\n+        assert_eq!(x.fetch_and(0x137f, SeqCst), 0xf731);\n+        assert_eq!(x.load(SeqCst), 0xf731 & 0x137f);\n+    }\n+\n+    #[test]\n+    fn int_or() {\n+        let x = AtomicInt::new(0xf731);\n+        assert_eq!(x.fetch_or(0x137f, SeqCst), 0xf731);\n+        assert_eq!(x.load(SeqCst), 0xf731 | 0x137f);\n+    }\n+\n+    #[test]\n+    fn int_xor() {\n+        let x = AtomicInt::new(0xf731);\n+        assert_eq!(x.fetch_xor(0x137f, SeqCst), 0xf731);\n+        assert_eq!(x.load(SeqCst), 0xf731 ^ 0x137f);\n+    }\n+\n+    static mut S_BOOL : AtomicBool = INIT_ATOMIC_BOOL;\n+    static mut S_INT  : AtomicInt  = INIT_ATOMIC_INT;\n+    static mut S_UINT : AtomicUint = INIT_ATOMIC_UINT;\n+\n+    #[test]\n+    fn static_init() {\n+        unsafe {\n+            assert!(!S_BOOL.load(SeqCst));\n+            assert!(S_INT.load(SeqCst) == 0);\n+            assert!(S_UINT.load(SeqCst) == 0);\n+        }\n+    }\n+\n+    #[test]\n+    fn different_sizes() {\n+        unsafe {\n+            let mut slot = 0u16;\n+            assert_eq!(super::atomic_swap(&mut slot, 1, SeqCst), 0);\n+\n+            let mut slot = 0u8;\n+            assert_eq!(super::atomic_compare_and_swap(&mut slot, 1, 2, SeqCst), 0);\n+\n+            let slot = 0u32;\n+            assert_eq!(super::atomic_load(&slot, SeqCst), 0);\n+\n+            let mut slot = 0u64;\n+            super::atomic_store(&mut slot, 2, SeqCst);\n+        }\n+    }\n+}"}, {"sha": "89ce07a35cf5b396401bd864239c62e388a799f7", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/325cc5150243c3ceeafc6b0b3d3c7cc68bb003ac/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/325cc5150243c3ceeafc6b0b3d3c7cc68bb003ac/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=325cc5150243c3ceeafc6b0b3d3c7cc68bb003ac", "patch": "@@ -81,6 +81,7 @@ pub mod container;\n mod unicode;\n mod unit;\n pub mod any;\n+pub mod atomics;\n pub mod bool;\n pub mod cell;\n pub mod char;"}, {"sha": "b2565a6a449e3c2c3e93cc378d31a0254196f373", "filename": "src/libstd/sync/atomics.rs", "status": "modified", "additions": 21, "deletions": 795, "changes": 816, "blob_url": "https://github.com/rust-lang/rust/blob/325cc5150243c3ceeafc6b0b3d3c7cc68bb003ac/src%2Flibstd%2Fsync%2Fatomics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/325cc5150243c3ceeafc6b0b3d3c7cc68bb003ac/src%2Flibstd%2Fsync%2Fatomics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fatomics.rs?ref=325cc5150243c3ceeafc6b0b3d3c7cc68bb003ac", "patch": "@@ -105,584 +105,42 @@\n //! }\n //! ```\n \n-#![allow(missing_doc)]\n-\n-use intrinsics;\n use mem;\n use ops::Drop;\n use option::{Option,Some,None};\n use owned::Box;\n-use std::kinds::marker;\n-use ty::Unsafe;\n \n-/// An atomic boolean type.\n-pub struct AtomicBool {\n-    v: Unsafe<uint>,\n-    nocopy: marker::NoCopy\n-}\n-\n-/// A signed atomic integer type, supporting basic atomic arithmetic operations\n-pub struct AtomicInt {\n-    v: Unsafe<int>,\n-    nocopy: marker::NoCopy\n-}\n-\n-/// An unsigned atomic integer type, supporting basic atomic arithmetic operations\n-pub struct AtomicUint {\n-    v: Unsafe<uint>,\n-    nocopy: marker::NoCopy\n-}\n-\n-/// An unsafe atomic pointer. Only supports basic atomic operations\n-pub struct AtomicPtr<T> {\n-    p: Unsafe<uint>,\n-    nocopy: marker::NoCopy\n-}\n+pub use core::atomics::{AtomicBool, AtomicInt, AtomicUint, AtomicPtr};\n+pub use core::atomics::{Ordering, Relaxed, Release, Acquire, AcqRel, SeqCst};\n+pub use core::atomics::{INIT_ATOMIC_BOOL, INIT_ATOMIC_INT, INIT_ATOMIC_UINT};\n+pub use core::atomics::fence;\n \n /// An atomic, nullable unique pointer\n ///\n /// This can be used as the concurrency primitive for operations that transfer\n /// owned heap objects across tasks.\n #[unsafe_no_drop_flag]\n pub struct AtomicOption<T> {\n-    p: Unsafe<uint>,\n-}\n-\n-/// Atomic memory orderings\n-///\n-/// Memory orderings limit the ways that both the compiler and CPU may reorder\n-/// instructions around atomic operations. At its most restrictive,\n-/// \"sequentially consistent\" atomics allow neither reads nor writes\n-/// to be moved either before or after the atomic operation; on the other end\n-/// \"relaxed\" atomics allow all reorderings.\n-///\n-/// Rust's memory orderings are the same as in C++[1].\n-///\n-/// 1: http://gcc.gnu.org/wiki/Atomic/GCCMM/AtomicSync\n-pub enum Ordering {\n-    /// No ordering constraints, only atomic operations\n-    Relaxed,\n-    /// When coupled with a store, all previous writes become visible\n-    /// to another thread that performs a load with `Acquire` ordering\n-    /// on the same value\n-    Release,\n-    /// When coupled with a load, all subsequent loads will see data\n-    /// written before a store with `Release` ordering on the same value\n-    /// in another thread\n-    Acquire,\n-    /// When coupled with a load, uses `Acquire` ordering, and with a store\n-    /// `Release` ordering\n-    AcqRel,\n-    /// Like `AcqRel` with the additional guarantee that all threads see all\n-    /// sequentially consistent operations in the same order.\n-    SeqCst\n-}\n-\n-/// An `AtomicBool` initialized to `false`\n-pub static INIT_ATOMIC_BOOL : AtomicBool = AtomicBool { v: Unsafe{value: 0,\n-                                                                  marker1: marker::InvariantType},\n-                                                        nocopy: marker::NoCopy };\n-/// An `AtomicInt` initialized to `0`\n-pub static INIT_ATOMIC_INT  : AtomicInt  = AtomicInt  { v: Unsafe{value: 0,\n-                                                                  marker1: marker::InvariantType},\n-                                                        nocopy: marker::NoCopy };\n-/// An `AtomicUint` initialized to `0`\n-pub static INIT_ATOMIC_UINT : AtomicUint = AtomicUint { v: Unsafe{value: 0,\n-                                                                  marker1: marker::InvariantType},\n-                                                        nocopy: marker::NoCopy };\n-\n-// NB: Needs to be -1 (0b11111111...) to make fetch_nand work correctly\n-static UINT_TRUE: uint = -1;\n-\n-impl AtomicBool {\n-    /// Create a new `AtomicBool`\n-    pub fn new(v: bool) -> AtomicBool {\n-        let val = if v { UINT_TRUE } else { 0 };\n-        AtomicBool { v: Unsafe::new(val), nocopy: marker::NoCopy }\n-    }\n-\n-    /// Load the value\n-    #[inline]\n-    pub fn load(&self, order: Ordering) -> bool {\n-        unsafe { atomic_load(self.v.get() as *uint, order) > 0 }\n-    }\n-\n-    /// Store the value\n-    #[inline]\n-    pub fn store(&self, val: bool, order: Ordering) {\n-        let val = if val { UINT_TRUE } else { 0 };\n-\n-        unsafe { atomic_store(self.v.get(), val, order); }\n-    }\n-\n-    /// Store a value, returning the old value\n-    #[inline]\n-    pub fn swap(&self, val: bool, order: Ordering) -> bool {\n-        let val = if val { UINT_TRUE } else { 0 };\n-\n-        unsafe { atomic_swap(self.v.get(), val, order) > 0 }\n-    }\n-\n-    /// If the current value is the same as expected, store a new value\n-    ///\n-    /// Compare the current value with `old`; if they are the same then\n-    /// replace the current value with `new`. Return the previous value.\n-    /// If the return value is equal to `old` then the value was updated.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```ignore\n-    /// # // FIXME: Needs PR #12430\n-    /// extern crate sync;\n-    ///\n-    /// use sync::Arc;\n-    /// use std::sync::atomics::{AtomicBool, SeqCst};\n-    ///\n-    /// fn main() {\n-    ///     let spinlock = Arc::new(AtomicBool::new(false));\n-    ///     let spinlock_clone = spin_lock.clone();\n-    ///\n-    ///     spawn(proc() {\n-    ///         with_lock(&spinlock, || println!(\"task 1 in lock\"));\n-    ///     });\n-    ///\n-    ///     spawn(proc() {\n-    ///         with_lock(&spinlock_clone, || println!(\"task 2 in lock\"));\n-    ///     });\n-    /// }\n-    ///\n-    /// fn with_lock(spinlock: &Arc<AtomicBool>, f: || -> ()) {\n-    ///     // CAS loop until we are able to replace `false` with `true`\n-    ///     while spinlock.compare_and_swap(false, true, SeqCst) == false {\n-    ///         // Since tasks may not be preemptive (if they are green threads)\n-    ///         // yield to the scheduler to let the other task run. Low level\n-    ///         // concurrent code needs to take into account Rust's two threading\n-    ///         // models.\n-    ///         deschedule();\n-    ///     }\n-    ///\n-    ///     // Now we have the spinlock\n-    ///     f();\n-    ///\n-    ///     // Release the lock\n-    ///     spinlock.store(false);\n-    /// }\n-    /// ```\n-    #[inline]\n-    pub fn compare_and_swap(&self, old: bool, new: bool, order: Ordering) -> bool {\n-        let old = if old { UINT_TRUE } else { 0 };\n-        let new = if new { UINT_TRUE } else { 0 };\n-\n-        unsafe { atomic_compare_and_swap(self.v.get(), old, new, order) > 0 }\n-    }\n-\n-    /// A logical \"and\" operation\n-    ///\n-    /// Performs a logical \"and\" operation on the current value and the\n-    /// argument `val`, and sets the new value to the result.\n-    /// Returns the previous value.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::sync::atomics::{AtomicBool, SeqCst};\n-    ///\n-    /// let foo = AtomicBool::new(true);\n-    /// assert_eq!(true, foo.fetch_and(false, SeqCst));\n-    /// assert_eq!(false, foo.load(SeqCst));\n-    ///\n-    /// let foo = AtomicBool::new(true);\n-    /// assert_eq!(true, foo.fetch_and(true, SeqCst));\n-    /// assert_eq!(true, foo.load(SeqCst));\n-    ///\n-    /// let foo = AtomicBool::new(false);\n-    /// assert_eq!(false, foo.fetch_and(false, SeqCst));\n-    /// assert_eq!(false, foo.load(SeqCst));\n-    /// ```\n-    #[inline]\n-    pub fn fetch_and(&self, val: bool, order: Ordering) -> bool {\n-        let val = if val { UINT_TRUE } else { 0 };\n-\n-        unsafe { atomic_and(self.v.get(), val, order) > 0 }\n-    }\n-\n-    /// A logical \"nand\" operation\n-    ///\n-    /// Performs a logical \"nand\" operation on the current value and the\n-    /// argument `val`, and sets the new value to the result.\n-    /// Returns the previous value.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::sync::atomics::{AtomicBool, SeqCst};\n-    ///\n-    /// let foo = AtomicBool::new(true);\n-    /// assert_eq!(true, foo.fetch_nand(false, SeqCst));\n-    /// assert_eq!(true, foo.load(SeqCst));\n-    ///\n-    /// let foo = AtomicBool::new(true);\n-    /// assert_eq!(true, foo.fetch_nand(true, SeqCst));\n-    /// assert_eq!(0, foo.load(SeqCst) as int);\n-    /// assert_eq!(false, foo.load(SeqCst));\n-    ///\n-    /// let foo = AtomicBool::new(false);\n-    /// assert_eq!(false, foo.fetch_nand(false, SeqCst));\n-    /// assert_eq!(true, foo.load(SeqCst));\n-    /// ```\n-    #[inline]\n-    pub fn fetch_nand(&self, val: bool, order: Ordering) -> bool {\n-        let val = if val { UINT_TRUE } else { 0 };\n-\n-        unsafe { atomic_nand(self.v.get(), val, order) > 0 }\n-    }\n-\n-    /// A logical \"or\" operation\n-    ///\n-    /// Performs a logical \"or\" operation on the current value and the\n-    /// argument `val`, and sets the new value to the result.\n-    /// Returns the previous value.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::sync::atomics::{AtomicBool, SeqCst};\n-    ///\n-    /// let foo = AtomicBool::new(true);\n-    /// assert_eq!(true, foo.fetch_or(false, SeqCst));\n-    /// assert_eq!(true, foo.load(SeqCst));\n-    ///\n-    /// let foo = AtomicBool::new(true);\n-    /// assert_eq!(true, foo.fetch_or(true, SeqCst));\n-    /// assert_eq!(true, foo.load(SeqCst));\n-    ///\n-    /// let foo = AtomicBool::new(false);\n-    /// assert_eq!(false, foo.fetch_or(false, SeqCst));\n-    /// assert_eq!(false, foo.load(SeqCst));\n-    /// ```\n-    #[inline]\n-    pub fn fetch_or(&self, val: bool, order: Ordering) -> bool {\n-        let val = if val { UINT_TRUE } else { 0 };\n-\n-        unsafe { atomic_or(self.v.get(), val, order) > 0 }\n-    }\n-\n-    /// A logical \"xor\" operation\n-    ///\n-    /// Performs a logical \"xor\" operation on the current value and the\n-    /// argument `val`, and sets the new value to the result.\n-    /// Returns the previous value.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::sync::atomics::{AtomicBool, SeqCst};\n-    ///\n-    /// let foo = AtomicBool::new(true);\n-    /// assert_eq!(true, foo.fetch_xor(false, SeqCst));\n-    /// assert_eq!(true, foo.load(SeqCst));\n-    ///\n-    /// let foo = AtomicBool::new(true);\n-    /// assert_eq!(true, foo.fetch_xor(true, SeqCst));\n-    /// assert_eq!(false, foo.load(SeqCst));\n-    ///\n-    /// let foo = AtomicBool::new(false);\n-    /// assert_eq!(false, foo.fetch_xor(false, SeqCst));\n-    /// assert_eq!(false, foo.load(SeqCst));\n-    /// ```\n-    #[inline]\n-    pub fn fetch_xor(&self, val: bool, order: Ordering) -> bool {\n-        let val = if val { UINT_TRUE } else { 0 };\n-\n-        unsafe { atomic_xor(self.v.get(), val, order) > 0 }\n-    }\n-}\n-\n-impl AtomicInt {\n-    /// Create a new `AtomicInt`\n-    pub fn new(v: int) -> AtomicInt {\n-        AtomicInt {v: Unsafe::new(v), nocopy: marker::NoCopy}\n-    }\n-\n-    /// Load the value\n-    #[inline]\n-    pub fn load(&self, order: Ordering) -> int {\n-        unsafe { atomic_load(self.v.get() as *int, order) }\n-    }\n-\n-    /// Store the value\n-    #[inline]\n-    pub fn store(&self, val: int, order: Ordering) {\n-        unsafe { atomic_store(self.v.get(), val, order); }\n-    }\n-\n-    /// Store a value, returning the old value\n-    #[inline]\n-    pub fn swap(&self, val: int, order: Ordering) -> int {\n-        unsafe { atomic_swap(self.v.get(), val, order) }\n-    }\n-\n-    /// If the current value is the same as expected, store a new value\n-    ///\n-    /// Compare the current value with `old`; if they are the same then\n-    /// replace the current value with `new`. Return the previous value.\n-    /// If the return value is equal to `old` then the value was updated.\n-    #[inline]\n-    pub fn compare_and_swap(&self, old: int, new: int, order: Ordering) -> int {\n-        unsafe { atomic_compare_and_swap(self.v.get(), old, new, order) }\n-    }\n-\n-    /// Add to the current value, returning the previous\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::sync::atomics::{AtomicInt, SeqCst};\n-    ///\n-    /// let foo = AtomicInt::new(0);\n-    /// assert_eq!(0, foo.fetch_add(10, SeqCst));\n-    /// assert_eq!(10, foo.load(SeqCst));\n-    /// ```\n-    #[inline]\n-    pub fn fetch_add(&self, val: int, order: Ordering) -> int {\n-        unsafe { atomic_add(self.v.get(), val, order) }\n-    }\n-\n-    /// Subtract from the current value, returning the previous\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::sync::atomics::{AtomicInt, SeqCst};\n-    ///\n-    /// let foo = AtomicInt::new(0);\n-    /// assert_eq!(0, foo.fetch_sub(10, SeqCst));\n-    /// assert_eq!(-10, foo.load(SeqCst));\n-    /// ```\n-    #[inline]\n-    pub fn fetch_sub(&self, val: int, order: Ordering) -> int {\n-        unsafe { atomic_sub(self.v.get(), val, order) }\n-    }\n-\n-    /// Bitwise and with the current value, returning the previous\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::sync::atomics::{AtomicUint, SeqCst};\n-    ///\n-    /// let foo = AtomicUint::new(0b101101);\n-    /// assert_eq!(0b101101, foo.fetch_and(0b110011, SeqCst));\n-    /// assert_eq!(0b100001, foo.load(SeqCst));\n-    #[inline]\n-    pub fn fetch_and(&self, val: int, order: Ordering) -> int {\n-        unsafe { atomic_and(self.v.get(), val, order) }\n-    }\n-\n-    /// Bitwise or with the current value, returning the previous\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::sync::atomics::{AtomicUint, SeqCst};\n-    ///\n-    /// let foo = AtomicUint::new(0b101101);\n-    /// assert_eq!(0b101101, foo.fetch_or(0b110011, SeqCst));\n-    /// assert_eq!(0b111111, foo.load(SeqCst));\n-    #[inline]\n-    pub fn fetch_or(&self, val: int, order: Ordering) -> int {\n-        unsafe { atomic_or(self.v.get(), val, order) }\n-    }\n-\n-    /// Bitwise xor with the current value, returning the previous\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::sync::atomics::{AtomicUint, SeqCst};\n-    ///\n-    /// let foo = AtomicUint::new(0b101101);\n-    /// assert_eq!(0b101101, foo.fetch_xor(0b110011, SeqCst));\n-    /// assert_eq!(0b011110, foo.load(SeqCst));\n-    #[inline]\n-    pub fn fetch_xor(&self, val: int, order: Ordering) -> int {\n-        unsafe { atomic_xor(self.v.get(), val, order) }\n-    }\n-}\n-\n-impl AtomicUint {\n-    /// Create a new `AtomicUint`\n-    pub fn new(v: uint) -> AtomicUint {\n-        AtomicUint { v: Unsafe::new(v), nocopy: marker::NoCopy }\n-    }\n-\n-    /// Load the value\n-    #[inline]\n-    pub fn load(&self, order: Ordering) -> uint {\n-        unsafe { atomic_load(self.v.get() as *uint, order) }\n-    }\n-\n-    /// Store the value\n-    #[inline]\n-    pub fn store(&self, val: uint, order: Ordering) {\n-        unsafe { atomic_store(self.v.get(), val, order); }\n-    }\n-\n-    /// Store a value, returning the old value\n-    #[inline]\n-    pub fn swap(&self, val: uint, order: Ordering) -> uint {\n-        unsafe { atomic_swap(self.v.get(), val, order) }\n-    }\n-\n-    /// If the current value is the same as expected, store a new value\n-    ///\n-    /// Compare the current value with `old`; if they are the same then\n-    /// replace the current value with `new`. Return the previous value.\n-    /// If the return value is equal to `old` then the value was updated.\n-    #[inline]\n-    pub fn compare_and_swap(&self, old: uint, new: uint, order: Ordering) -> uint {\n-        unsafe { atomic_compare_and_swap(self.v.get(), old, new, order) }\n-    }\n-\n-    /// Add to the current value, returning the previous\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::sync::atomics::{AtomicUint, SeqCst};\n-    ///\n-    /// let foo = AtomicUint::new(0);\n-    /// assert_eq!(0, foo.fetch_add(10, SeqCst));\n-    /// assert_eq!(10, foo.load(SeqCst));\n-    /// ```\n-    #[inline]\n-    pub fn fetch_add(&self, val: uint, order: Ordering) -> uint {\n-        unsafe { atomic_add(self.v.get(), val, order) }\n-    }\n-\n-    /// Subtract from the current value, returning the previous\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::sync::atomics::{AtomicUint, SeqCst};\n-    ///\n-    /// let foo = AtomicUint::new(10);\n-    /// assert_eq!(10, foo.fetch_sub(10, SeqCst));\n-    /// assert_eq!(0, foo.load(SeqCst));\n-    /// ```\n-    #[inline]\n-    pub fn fetch_sub(&self, val: uint, order: Ordering) -> uint {\n-        unsafe { atomic_sub(self.v.get(), val, order) }\n-    }\n-\n-    /// Bitwise and with the current value, returning the previous\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::sync::atomics::{AtomicUint, SeqCst};\n-    ///\n-    /// let foo = AtomicUint::new(0b101101);\n-    /// assert_eq!(0b101101, foo.fetch_and(0b110011, SeqCst));\n-    /// assert_eq!(0b100001, foo.load(SeqCst));\n-    #[inline]\n-    pub fn fetch_and(&self, val: uint, order: Ordering) -> uint {\n-        unsafe { atomic_and(self.v.get(), val, order) }\n-    }\n-\n-    /// Bitwise or with the current value, returning the previous\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::sync::atomics::{AtomicUint, SeqCst};\n-    ///\n-    /// let foo = AtomicUint::new(0b101101);\n-    /// assert_eq!(0b101101, foo.fetch_or(0b110011, SeqCst));\n-    /// assert_eq!(0b111111, foo.load(SeqCst));\n-    #[inline]\n-    pub fn fetch_or(&self, val: uint, order: Ordering) -> uint {\n-        unsafe { atomic_or(self.v.get(), val, order) }\n-    }\n-\n-    /// Bitwise xor with the current value, returning the previous\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::sync::atomics::{AtomicUint, SeqCst};\n-    ///\n-    /// let foo = AtomicUint::new(0b101101);\n-    /// assert_eq!(0b101101, foo.fetch_xor(0b110011, SeqCst));\n-    /// assert_eq!(0b011110, foo.load(SeqCst));\n-    #[inline]\n-    pub fn fetch_xor(&self, val: uint, order: Ordering) -> uint {\n-        unsafe { atomic_xor(self.v.get(), val, order) }\n-    }\n-}\n-\n-impl<T> AtomicPtr<T> {\n-    /// Create a new `AtomicPtr`\n-    pub fn new(p: *mut T) -> AtomicPtr<T> {\n-        AtomicPtr { p: Unsafe::new(p as uint), nocopy: marker::NoCopy }\n-    }\n-\n-    /// Load the value\n-    #[inline]\n-    pub fn load(&self, order: Ordering) -> *mut T {\n-        unsafe {\n-            atomic_load(self.p.get() as **mut T, order) as *mut T\n-        }\n-    }\n-\n-    /// Store the value\n-    #[inline]\n-    pub fn store(&self, ptr: *mut T, order: Ordering) {\n-        unsafe { atomic_store(self.p.get(), ptr as uint, order); }\n-    }\n-\n-    /// Store a value, returning the old value\n-    #[inline]\n-    pub fn swap(&self, ptr: *mut T, order: Ordering) -> *mut T {\n-        unsafe { atomic_swap(self.p.get(), ptr as uint, order) as *mut T }\n-    }\n-\n-    /// If the current value is the same as expected, store a new value\n-    ///\n-    /// Compare the current value with `old`; if they are the same then\n-    /// replace the current value with `new`. Return the previous value.\n-    /// If the return value is equal to `old` then the value was updated.\n-    #[inline]\n-    pub fn compare_and_swap(&self, old: *mut T, new: *mut T, order: Ordering) -> *mut T {\n-        unsafe {\n-            atomic_compare_and_swap(self.p.get(), old as uint,\n-                                    new as uint, order) as *mut T\n-        }\n-    }\n+    p: AtomicUint,\n }\n \n impl<T> AtomicOption<T> {\n     /// Create a new `AtomicOption`\n     pub fn new(p: Box<T>) -> AtomicOption<T> {\n-        unsafe { AtomicOption { p: Unsafe::new(mem::transmute(p)) } }\n+        unsafe { AtomicOption { p: AtomicUint::new(mem::transmute(p)) } }\n     }\n \n     /// Create a new `AtomicOption` that doesn't contain a value\n-    pub fn empty() -> AtomicOption<T> { AtomicOption { p: Unsafe::new(0) } }\n+    pub fn empty() -> AtomicOption<T> { AtomicOption { p: AtomicUint::new(0) } }\n \n     /// Store a value, returning the old value\n     #[inline]\n     pub fn swap(&self, val: Box<T>, order: Ordering) -> Option<Box<T>> {\n-        unsafe {\n-            let val = mem::transmute(val);\n+        let val = unsafe { mem::transmute(val) };\n \n-            let p = atomic_swap(self.p.get(), val, order);\n-            if p as uint == 0 {\n-                None\n-            } else {\n-                Some(mem::transmute(p))\n-            }\n+        match self.p.swap(val, order) {\n+            0 => None,\n+            n => Some(unsafe { mem::transmute(n) }),\n         }\n     }\n \n@@ -702,7 +160,7 @@ impl<T> AtomicOption<T> {\n         unsafe {\n             let val = mem::transmute(val);\n             let expected = mem::transmute(0);\n-            let oldval = atomic_compare_and_swap(self.p.get(), expected, val, order);\n+            let oldval = self.p.compare_and_swap(expected, val, order);\n             if oldval == expected {\n                 None\n             } else {\n@@ -717,7 +175,7 @@ impl<T> AtomicOption<T> {\n     /// result does not get invalidated by another task after this returns.\n     #[inline]\n     pub fn is_empty(&self, order: Ordering) -> bool {\n-        unsafe { atomic_load(self.p.get() as *uint, order) as uint == 0 }\n+        self.p.load(order) as uint == 0\n     }\n }\n \n@@ -728,165 +186,11 @@ impl<T> Drop for AtomicOption<T> {\n     }\n }\n \n-#[inline]\n-unsafe fn atomic_store<T>(dst: *mut T, val: T, order:Ordering) {\n-    match order {\n-        Release => intrinsics::atomic_store_rel(dst, val),\n-        Relaxed => intrinsics::atomic_store_relaxed(dst, val),\n-        _       => intrinsics::atomic_store(dst, val)\n-    }\n-}\n-\n-#[inline]\n-unsafe fn atomic_load<T>(dst: *T, order:Ordering) -> T {\n-    match order {\n-        Acquire => intrinsics::atomic_load_acq(dst),\n-        Relaxed => intrinsics::atomic_load_relaxed(dst),\n-        _       => intrinsics::atomic_load(dst)\n-    }\n-}\n-\n-#[inline]\n-unsafe fn atomic_swap<T>(dst: *mut T, val: T, order: Ordering) -> T {\n-    match order {\n-        Acquire => intrinsics::atomic_xchg_acq(dst, val),\n-        Release => intrinsics::atomic_xchg_rel(dst, val),\n-        AcqRel  => intrinsics::atomic_xchg_acqrel(dst, val),\n-        Relaxed => intrinsics::atomic_xchg_relaxed(dst, val),\n-        _       => intrinsics::atomic_xchg(dst, val)\n-    }\n-}\n-\n-/// Returns the old value (like __sync_fetch_and_add).\n-#[inline]\n-unsafe fn atomic_add<T>(dst: *mut T, val: T, order: Ordering) -> T {\n-    match order {\n-        Acquire => intrinsics::atomic_xadd_acq(dst, val),\n-        Release => intrinsics::atomic_xadd_rel(dst, val),\n-        AcqRel  => intrinsics::atomic_xadd_acqrel(dst, val),\n-        Relaxed => intrinsics::atomic_xadd_relaxed(dst, val),\n-        _       => intrinsics::atomic_xadd(dst, val)\n-    }\n-}\n-\n-/// Returns the old value (like __sync_fetch_and_sub).\n-#[inline]\n-unsafe fn atomic_sub<T>(dst: *mut T, val: T, order: Ordering) -> T {\n-    match order {\n-        Acquire => intrinsics::atomic_xsub_acq(dst, val),\n-        Release => intrinsics::atomic_xsub_rel(dst, val),\n-        AcqRel  => intrinsics::atomic_xsub_acqrel(dst, val),\n-        Relaxed => intrinsics::atomic_xsub_relaxed(dst, val),\n-        _       => intrinsics::atomic_xsub(dst, val)\n-    }\n-}\n-\n-#[inline]\n-unsafe fn atomic_compare_and_swap<T>(dst: *mut T, old:T, new:T, order: Ordering) -> T {\n-    match order {\n-        Acquire => intrinsics::atomic_cxchg_acq(dst, old, new),\n-        Release => intrinsics::atomic_cxchg_rel(dst, old, new),\n-        AcqRel  => intrinsics::atomic_cxchg_acqrel(dst, old, new),\n-        Relaxed => intrinsics::atomic_cxchg_relaxed(dst, old, new),\n-        _       => intrinsics::atomic_cxchg(dst, old, new),\n-    }\n-}\n-\n-#[inline]\n-unsafe fn atomic_and<T>(dst: *mut T, val: T, order: Ordering) -> T {\n-    match order {\n-        Acquire => intrinsics::atomic_and_acq(dst, val),\n-        Release => intrinsics::atomic_and_rel(dst, val),\n-        AcqRel  => intrinsics::atomic_and_acqrel(dst, val),\n-        Relaxed => intrinsics::atomic_and_relaxed(dst, val),\n-        _       => intrinsics::atomic_and(dst, val)\n-    }\n-}\n-\n-#[inline]\n-unsafe fn atomic_nand<T>(dst: *mut T, val: T, order: Ordering) -> T {\n-    match order {\n-        Acquire => intrinsics::atomic_nand_acq(dst, val),\n-        Release => intrinsics::atomic_nand_rel(dst, val),\n-        AcqRel  => intrinsics::atomic_nand_acqrel(dst, val),\n-        Relaxed => intrinsics::atomic_nand_relaxed(dst, val),\n-        _       => intrinsics::atomic_nand(dst, val)\n-    }\n-}\n-\n-\n-#[inline]\n-unsafe fn atomic_or<T>(dst: *mut T, val: T, order: Ordering) -> T {\n-    match order {\n-        Acquire => intrinsics::atomic_or_acq(dst, val),\n-        Release => intrinsics::atomic_or_rel(dst, val),\n-        AcqRel  => intrinsics::atomic_or_acqrel(dst, val),\n-        Relaxed => intrinsics::atomic_or_relaxed(dst, val),\n-        _       => intrinsics::atomic_or(dst, val)\n-    }\n-}\n-\n-\n-#[inline]\n-unsafe fn atomic_xor<T>(dst: *mut T, val: T, order: Ordering) -> T {\n-    match order {\n-        Acquire => intrinsics::atomic_xor_acq(dst, val),\n-        Release => intrinsics::atomic_xor_rel(dst, val),\n-        AcqRel  => intrinsics::atomic_xor_acqrel(dst, val),\n-        Relaxed => intrinsics::atomic_xor_relaxed(dst, val),\n-        _       => intrinsics::atomic_xor(dst, val)\n-    }\n-}\n-\n-\n-/// An atomic fence.\n-///\n-/// A fence 'A' which has `Release` ordering semantics, synchronizes with a\n-/// fence 'B' with (at least) `Acquire` semantics, if and only if there exists\n-/// atomic operations X and Y, both operating on some atomic object 'M' such\n-/// that A is sequenced before X, Y is synchronized before B and Y observers\n-/// the change to M. This provides a happens-before dependence between A and B.\n-///\n-/// Atomic operations with `Release` or `Acquire` semantics can also synchronize\n-/// with a fence.\n-///\n-/// A fence with has `SeqCst` ordering, in addition to having both `Acquire` and\n-/// `Release` semantics, participates in the global program order of the other\n-/// `SeqCst` operations and/or fences.\n-///\n-/// Accepts `Acquire`, `Release`, `AcqRel` and `SeqCst` orderings.\n-///\n-/// # Failure\n-///\n-/// Fails if `order` is `Relaxed`\n-#[inline]\n-pub fn fence(order: Ordering) {\n-    unsafe {\n-        match order {\n-            Acquire => intrinsics::atomic_fence_acq(),\n-            Release => intrinsics::atomic_fence_rel(),\n-            AcqRel  => intrinsics::atomic_fence_acqrel(),\n-            SeqCst  => intrinsics::atomic_fence(),\n-            Relaxed => fail!(\"there is no such thing as a relaxed fence\")\n-        }\n-    }\n-}\n-\n #[cfg(test)]\n mod test {\n     use option::*;\n     use super::*;\n \n-    #[test]\n-    fn bool_() {\n-        let a = AtomicBool::new(false);\n-        assert_eq!(a.compare_and_swap(false, true, SeqCst), false);\n-        assert_eq!(a.compare_and_swap(false, true, SeqCst), true);\n-\n-        a.store(false, SeqCst);\n-        assert_eq!(a.compare_and_swap(false, true, SeqCst), false);\n-    }\n-\n     #[test]\n     fn option_empty() {\n         let option: AtomicOption<()> = AtomicOption::empty();\n@@ -900,109 +204,31 @@ mod test {\n \n         let b = p.swap(a, SeqCst);\n \n-        assert_eq!(b, Some(box 1));\n-        assert_eq!(p.take(SeqCst), Some(box 2));\n+        assert!(b == Some(box 1));\n+        assert!(p.take(SeqCst) == Some(box 2));\n     }\n \n     #[test]\n     fn option_take() {\n         let p = AtomicOption::new(box 1);\n \n-        assert_eq!(p.take(SeqCst), Some(box 1));\n-        assert_eq!(p.take(SeqCst), None);\n+        assert!(p.take(SeqCst) == Some(box 1));\n+        assert!(p.take(SeqCst) == None);\n \n         let p2 = box 2;\n         p.swap(p2, SeqCst);\n \n-        assert_eq!(p.take(SeqCst), Some(box 2));\n+        assert!(p.take(SeqCst) == Some(box 2));\n     }\n \n     #[test]\n     fn option_fill() {\n         let p = AtomicOption::new(box 1);\n         assert!(p.fill(box 2, SeqCst).is_some()); // should fail; shouldn't leak!\n-        assert_eq!(p.take(SeqCst), Some(box 1));\n+        assert!(p.take(SeqCst) == Some(box 1));\n \n         assert!(p.fill(box 2, SeqCst).is_none()); // shouldn't fail\n-        assert_eq!(p.take(SeqCst), Some(box 2));\n-    }\n-\n-    #[test]\n-    fn bool_and() {\n-        let a = AtomicBool::new(true);\n-        assert_eq!(a.fetch_and(false, SeqCst),true);\n-        assert_eq!(a.load(SeqCst),false);\n-    }\n-\n-    #[test]\n-    fn uint_and() {\n-        let x = AtomicUint::new(0xf731);\n-        assert_eq!(x.fetch_and(0x137f, SeqCst), 0xf731);\n-        assert_eq!(x.load(SeqCst), 0xf731 & 0x137f);\n-    }\n-\n-    #[test]\n-    fn uint_or() {\n-        let x = AtomicUint::new(0xf731);\n-        assert_eq!(x.fetch_or(0x137f, SeqCst), 0xf731);\n-        assert_eq!(x.load(SeqCst), 0xf731 | 0x137f);\n-    }\n-\n-    #[test]\n-    fn uint_xor() {\n-        let x = AtomicUint::new(0xf731);\n-        assert_eq!(x.fetch_xor(0x137f, SeqCst), 0xf731);\n-        assert_eq!(x.load(SeqCst), 0xf731 ^ 0x137f);\n-    }\n-\n-    #[test]\n-    fn int_and() {\n-        let x = AtomicInt::new(0xf731);\n-        assert_eq!(x.fetch_and(0x137f, SeqCst), 0xf731);\n-        assert_eq!(x.load(SeqCst), 0xf731 & 0x137f);\n-    }\n-\n-    #[test]\n-    fn int_or() {\n-        let x = AtomicInt::new(0xf731);\n-        assert_eq!(x.fetch_or(0x137f, SeqCst), 0xf731);\n-        assert_eq!(x.load(SeqCst), 0xf731 | 0x137f);\n-    }\n-\n-    #[test]\n-    fn int_xor() {\n-        let x = AtomicInt::new(0xf731);\n-        assert_eq!(x.fetch_xor(0x137f, SeqCst), 0xf731);\n-        assert_eq!(x.load(SeqCst), 0xf731 ^ 0x137f);\n-    }\n-\n-    static mut S_BOOL : AtomicBool = INIT_ATOMIC_BOOL;\n-    static mut S_INT  : AtomicInt  = INIT_ATOMIC_INT;\n-    static mut S_UINT : AtomicUint = INIT_ATOMIC_UINT;\n-\n-    #[test]\n-    fn static_init() {\n-        unsafe {\n-            assert!(!S_BOOL.load(SeqCst));\n-            assert!(S_INT.load(SeqCst) == 0);\n-            assert!(S_UINT.load(SeqCst) == 0);\n-        }\n-    }\n-\n-    #[test]\n-    fn different_sizes() {\n-        unsafe {\n-            let mut slot = 0u16;\n-            assert_eq!(super::atomic_swap(&mut slot, 1, SeqCst), 0);\n-\n-            let mut slot = 0u8;\n-            assert_eq!(super::atomic_compare_and_swap(&mut slot, 1, 2, SeqCst), 0);\n-\n-            let slot = 0u32;\n-            assert_eq!(super::atomic_load(&slot, SeqCst), 0);\n-\n-            let mut slot = 0u64;\n-            super::atomic_store(&mut slot, 2, SeqCst);\n-        }\n+        assert!(p.take(SeqCst) == Some(box 2));\n     }\n }\n+"}]}