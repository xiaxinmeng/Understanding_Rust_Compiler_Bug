{"sha": "16871f6f932d5669cd7c8b8affebb4ef35b9cdad", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE2ODcxZjZmOTMyZDU2NjljZDdjOGI4YWZmZWJiNGVmMzViOWNkYWQ=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-07-02T12:49:34Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-07-02T12:49:34Z"}, "message": "Merge #9428\n\n9428: fix: Fix deduction of `dyn Fn` closure parameter types r=flodiebold a=jonas-schievink\n\n\n\nCo-authored-by: Jonas Schievink <jonasschievink@gmail.com>", "tree": {"sha": "12c121f63c43c52c740f5a0fedd9d26f229e4f62", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/12c121f63c43c52c740f5a0fedd9d26f229e4f62"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/16871f6f932d5669cd7c8b8affebb4ef35b9cdad", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJg3wteCRBK7hj4Ov3rIwAAsnsIAD5pCpWFtdOCjYd+yjnOVoeq\n4eKE83UCFEUZ0qG9lPeBxKrhyEMZtEW2lLprbo1V2mOQ6tRvw/qgSgB+ykaFoqa3\n9SRtRaGi3zGSOD7VIxbC0mfRNqSjVnUVm4aOxrk2PI3HFHUZ774kY8M1D9K7TLW9\nkM0cCL+1wMXzgbY4FQLwi2Q47fVdZGOyFzK7+Sg0cnfrb5KAz/ub47nMhbiTtZPU\nMA6VaOFyWKkQeLhbH/Tu9Vcqa+FRbAHI2YAyYZXL8cAsvYHh1gIAZBLn4g+wgzeB\np+L4Y1FZAJhmp8iZi33y5xHKgvBdMo+96lBQ5Ry88r06KjL+otyTMUJoH+5pJaM=\n=4wmR\n-----END PGP SIGNATURE-----\n", "payload": "tree 12c121f63c43c52c740f5a0fedd9d26f229e4f62\nparent d18cfd4467efeeca319504ca40d8b34d36ab3f14\nparent 835d1cec5905edf722a75fd369cdbbccb1cc414e\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1625230174 +0000\ncommitter GitHub <noreply@github.com> 1625230174 +0000\n\nMerge #9428\n\n9428: fix: Fix deduction of `dyn Fn` closure parameter types r=flodiebold a=jonas-schievink\n\n\n\nCo-authored-by: Jonas Schievink <jonasschievink@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/16871f6f932d5669cd7c8b8affebb4ef35b9cdad", "html_url": "https://github.com/rust-lang/rust/commit/16871f6f932d5669cd7c8b8affebb4ef35b9cdad", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/16871f6f932d5669cd7c8b8affebb4ef35b9cdad/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d18cfd4467efeeca319504ca40d8b34d36ab3f14", "url": "https://api.github.com/repos/rust-lang/rust/commits/d18cfd4467efeeca319504ca40d8b34d36ab3f14", "html_url": "https://github.com/rust-lang/rust/commit/d18cfd4467efeeca319504ca40d8b34d36ab3f14"}, {"sha": "835d1cec5905edf722a75fd369cdbbccb1cc414e", "url": "https://api.github.com/repos/rust-lang/rust/commits/835d1cec5905edf722a75fd369cdbbccb1cc414e", "html_url": "https://github.com/rust-lang/rust/commit/835d1cec5905edf722a75fd369cdbbccb1cc414e"}], "stats": {"total": 159, "additions": 138, "deletions": 21}, "files": [{"sha": "2748faa6f84c3307f23fbfde4809ab163aa3b8c3", "filename": "crates/hir_ty/src/display.rs", "status": "modified", "additions": 12, "deletions": 16, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/16871f6f932d5669cd7c8b8affebb4ef35b9cdad/crates%2Fhir_ty%2Fsrc%2Fdisplay.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16871f6f932d5669cd7c8b8affebb4ef35b9cdad/crates%2Fhir_ty%2Fsrc%2Fdisplay.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdisplay.rs?ref=16871f6f932d5669cd7c8b8affebb4ef35b9cdad", "patch": "@@ -2,10 +2,7 @@\n //! HIR back into source code, and just displaying them for debugging/testing\n //! purposes.\n \n-use std::{\n-    array,\n-    fmt::{self, Debug},\n-};\n+use std::fmt::{self, Debug};\n \n use chalk_ir::BoundVar;\n use hir_def::{\n@@ -24,12 +21,16 @@ use hir_expand::{hygiene::Hygiene, name::Name};\n use itertools::Itertools;\n \n use crate::{\n-    const_from_placeholder_idx, db::HirDatabase, from_assoc_type_id, from_foreign_def_id,\n-    from_placeholder_idx, lt_from_placeholder_idx, mapping::from_chalk, primitive, subst_prefix,\n-    to_assoc_type_id, utils::generics, AdtId, AliasEq, AliasTy, CallableDefId, CallableSig, Const,\n-    ConstValue, DomainGoal, GenericArg, ImplTraitId, Interner, Lifetime, LifetimeData,\n-    LifetimeOutlives, Mutability, OpaqueTy, ProjectionTy, ProjectionTyExt, QuantifiedWhereClause,\n-    Scalar, TraitRef, TraitRefExt, Ty, TyExt, TyKind, WhereClause,\n+    const_from_placeholder_idx,\n+    db::HirDatabase,\n+    from_assoc_type_id, from_foreign_def_id, from_placeholder_idx, lt_from_placeholder_idx,\n+    mapping::from_chalk,\n+    primitive, subst_prefix, to_assoc_type_id,\n+    utils::{self, generics},\n+    AdtId, AliasEq, AliasTy, CallableDefId, CallableSig, Const, ConstValue, DomainGoal, GenericArg,\n+    ImplTraitId, Interner, Lifetime, LifetimeData, LifetimeOutlives, Mutability, OpaqueTy,\n+    ProjectionTy, ProjectionTyExt, QuantifiedWhereClause, Scalar, TraitRef, TraitRefExt, Ty, TyExt,\n+    TyKind, WhereClause,\n };\n \n pub struct HirFormatter<'a> {\n@@ -707,12 +708,7 @@ impl HirDisplay for CallableSig {\n \n fn fn_traits(db: &dyn DefDatabase, trait_: TraitId) -> impl Iterator<Item = TraitId> {\n     let krate = trait_.lookup(db).container.krate();\n-    let fn_traits = [\n-        db.lang_item(krate, \"fn\".into()),\n-        db.lang_item(krate, \"fn_mut\".into()),\n-        db.lang_item(krate, \"fn_once\".into()),\n-    ];\n-    array::IntoIter::new(fn_traits).into_iter().flatten().flat_map(|it| it.as_trait())\n+    utils::fn_traits(db, krate)\n }\n \n pub fn write_bounds_like_dyn_trait_with_prefix("}, {"sha": "1ca7105f245c5fcc53250fc209e7e36fa32c030d", "filename": "crates/hir_ty/src/infer.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/16871f6f932d5669cd7c8b8affebb4ef35b9cdad/crates%2Fhir_ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16871f6f932d5669cd7c8b8affebb4ef35b9cdad/crates%2Fhir_ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer.rs?ref=16871f6f932d5669cd7c8b8affebb4ef35b9cdad", "patch": "@@ -52,6 +52,7 @@ mod path;\n mod expr;\n mod pat;\n mod coerce;\n+mod closure;\n \n /// The entry point of type inference.\n pub(crate) fn infer_query(db: &dyn HirDatabase, def: DefWithBodyId) -> Arc<InferenceResult> {"}, {"sha": "2de4c0f5db0da666e65caeab0384a5adfe7e2914", "filename": "crates/hir_ty/src/infer/closure.rs", "status": "added", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/16871f6f932d5669cd7c8b8affebb4ef35b9cdad/crates%2Fhir_ty%2Fsrc%2Finfer%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16871f6f932d5669cd7c8b8affebb4ef35b9cdad/crates%2Fhir_ty%2Fsrc%2Finfer%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Fclosure.rs?ref=16871f6f932d5669cd7c8b8affebb4ef35b9cdad", "patch": "@@ -0,0 +1,92 @@\n+//! Inference of closure parameter types based on the closure's expected type.\n+\n+use chalk_ir::{cast::Cast, AliasTy, FnSubst, WhereClause};\n+use hir_def::HasModule;\n+use smallvec::SmallVec;\n+\n+use crate::{\n+    to_chalk_trait_id, utils, ChalkTraitId, DynTy, FnPointer, FnSig, Interner, Substitution, Ty,\n+    TyExt, TyKind,\n+};\n+\n+use super::{Expectation, InferenceContext};\n+\n+impl InferenceContext<'_> {\n+    pub(super) fn deduce_closure_type_from_expectations(\n+        &mut self,\n+        closure_ty: &Ty,\n+        sig_ty: &Ty,\n+        expectation: &Expectation,\n+    ) {\n+        let expected_ty = match expectation.to_option(&mut self.table) {\n+            Some(ty) => ty,\n+            None => return,\n+        };\n+\n+        // Deduction from where-clauses in scope, as well as fn-pointer coercion are handled here.\n+        self.coerce(closure_ty, &expected_ty);\n+\n+        // Deduction based on the expected `dyn Fn` is done separately.\n+        if let TyKind::Dyn(dyn_ty) = expected_ty.kind(&Interner) {\n+            if let Some(sig) = self.deduce_sig_from_dyn_ty(dyn_ty) {\n+                let expected_sig_ty = TyKind::Function(sig).intern(&Interner);\n+\n+                self.unify(sig_ty, &expected_sig_ty);\n+            }\n+        }\n+    }\n+\n+    fn deduce_sig_from_dyn_ty(&self, dyn_ty: &DynTy) -> Option<FnPointer> {\n+        // Search for a predicate like `<$self as FnX<Args>>::Output == Ret`\n+\n+        let fn_traits: SmallVec<[ChalkTraitId; 3]> =\n+            utils::fn_traits(self.db.upcast(), self.owner.module(self.db.upcast()).krate())\n+                .map(|tid| to_chalk_trait_id(tid))\n+                .collect();\n+\n+        let self_ty = TyKind::Error.intern(&Interner);\n+        let bounds = dyn_ty.bounds.clone().substitute(&Interner, &[self_ty.cast(&Interner)]);\n+        for bound in bounds.iter(&Interner) {\n+            // NOTE(skip_binders): the extracted types are rebound by the returned `FnPointer`\n+            match bound.skip_binders() {\n+                WhereClause::AliasEq(eq) => match &eq.alias {\n+                    AliasTy::Projection(projection) => {\n+                        let assoc_data = self.db.associated_ty_data(projection.associated_ty_id);\n+                        if !fn_traits.contains(&assoc_data.trait_id) {\n+                            return None;\n+                        }\n+\n+                        // Skip `Self`, get the type argument.\n+                        let arg = projection.substitution.as_slice(&Interner).get(1)?;\n+                        if let Some(subst) = arg.ty(&Interner)?.as_tuple() {\n+                            let generic_args = subst.as_slice(&Interner);\n+                            let mut sig_tys = Vec::new();\n+                            for arg in generic_args {\n+                                sig_tys.push(arg.ty(&Interner)?.clone());\n+                            }\n+                            sig_tys.push(eq.ty.clone());\n+\n+                            cov_mark::hit!(dyn_fn_param_informs_call_site_closure_signature);\n+                            return Some(FnPointer {\n+                                num_binders: bound.len(&Interner),\n+                                sig: FnSig {\n+                                    abi: (),\n+                                    safety: chalk_ir::Safety::Safe,\n+                                    variadic: false,\n+                                },\n+                                substitution: FnSubst(Substitution::from_iter(\n+                                    &Interner,\n+                                    sig_tys.clone(),\n+                                )),\n+                            });\n+                        }\n+                    }\n+                    AliasTy::Opaque(_) => {}\n+                },\n+                _ => {}\n+            }\n+        }\n+\n+        None\n+    }\n+}"}, {"sha": "2f109297b5549ec7dbc3ddf7a6a48d687f76446d", "filename": "crates/hir_ty/src/infer/expr.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/16871f6f932d5669cd7c8b8affebb4ef35b9cdad/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16871f6f932d5669cd7c8b8affebb4ef35b9cdad/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs?ref=16871f6f932d5669cd7c8b8affebb4ef35b9cdad", "patch": "@@ -278,15 +278,13 @@ impl<'a> InferenceContext<'a> {\n                 .intern(&Interner);\n                 let closure_id = self.db.intern_closure((self.owner, tgt_expr)).into();\n                 let closure_ty =\n-                    TyKind::Closure(closure_id, Substitution::from1(&Interner, sig_ty))\n+                    TyKind::Closure(closure_id, Substitution::from1(&Interner, sig_ty.clone()))\n                         .intern(&Interner);\n \n                 // Eagerly try to relate the closure type with the expected\n                 // type, otherwise we often won't have enough information to\n                 // infer the body.\n-                if let Some(t) = expected.only_has_type(&mut self.table) {\n-                    self.coerce(&closure_ty, &t);\n-                }\n+                self.deduce_closure_type_from_expectations(&closure_ty, &sig_ty, expected);\n \n                 // Now go through the argument patterns\n                 for (arg_pat, arg_ty) in args.iter().zip(sig_tys) {"}, {"sha": "9db30d9f98becc269c36be626de533a8ecc3b2b0", "filename": "crates/hir_ty/src/tests/traits.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/16871f6f932d5669cd7c8b8affebb4ef35b9cdad/crates%2Fhir_ty%2Fsrc%2Ftests%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16871f6f932d5669cd7c8b8affebb4ef35b9cdad/crates%2Fhir_ty%2Fsrc%2Ftests%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftests%2Ftraits.rs?ref=16871f6f932d5669cd7c8b8affebb4ef35b9cdad", "patch": "@@ -2829,6 +2829,26 @@ fn foo() {\n     );\n }\n \n+#[test]\n+fn dyn_fn_param_informs_call_site_closure_signature() {\n+    cov_mark::check!(dyn_fn_param_informs_call_site_closure_signature);\n+    check_types(\n+        r#\"\n+//- minicore: fn, coerce_unsized\n+struct S;\n+impl S {\n+    fn inherent(&self) -> u8 { 0 }\n+}\n+fn take_dyn_fn(f: &dyn Fn(S)) {}\n+\n+fn f() {\n+    take_dyn_fn(&|x| { x.inherent(); });\n+                     //^^^^^^^^^^^^ u8\n+}\n+        \"#,\n+    );\n+}\n+\n #[test]\n fn infer_fn_trait_arg() {\n     check_infer_with_mismatches("}, {"sha": "076b2c8cba3352626eba287884eca2d17c8a02da", "filename": "crates/hir_ty/src/utils.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/16871f6f932d5669cd7c8b8affebb4ef35b9cdad/crates%2Fhir_ty%2Fsrc%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16871f6f932d5669cd7c8b8affebb4ef35b9cdad/crates%2Fhir_ty%2Fsrc%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Futils.rs?ref=16871f6f932d5669cd7c8b8affebb4ef35b9cdad", "patch": "@@ -1,8 +1,9 @@\n //! Helper functions for working with def, which don't need to be a separate\n //! query, but can't be computed directly from `*Data` (ie, which need a `db`).\n \n-use std::iter;\n+use std::{array, iter};\n \n+use base_db::CrateId;\n use chalk_ir::{fold::Shift, BoundVar, DebruijnIndex};\n use hir_def::{\n     db::DefDatabase,\n@@ -23,6 +24,15 @@ use crate::{\n     WhereClause,\n };\n \n+pub(crate) fn fn_traits(db: &dyn DefDatabase, krate: CrateId) -> impl Iterator<Item = TraitId> {\n+    let fn_traits = [\n+        db.lang_item(krate, \"fn\".into()),\n+        db.lang_item(krate, \"fn_mut\".into()),\n+        db.lang_item(krate, \"fn_once\".into()),\n+    ];\n+    array::IntoIter::new(fn_traits).into_iter().flatten().flat_map(|it| it.as_trait())\n+}\n+\n fn direct_super_traits(db: &dyn DefDatabase, trait_: TraitId) -> Vec<TraitId> {\n     let resolver = trait_.resolver(db);\n     // returning the iterator directly doesn't easily work because of"}]}