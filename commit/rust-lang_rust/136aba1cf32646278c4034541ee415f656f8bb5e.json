{"sha": "136aba1cf32646278c4034541ee415f656f8bb5e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEzNmFiYTFjZjMyNjQ2Mjc4YzQwMzQ1NDFlZTQxNWY2NTZmOGJiNWU=", "commit": {"author": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2019-01-05T15:32:07Z"}, "committer": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2019-01-05T21:41:12Z"}, "message": "Add HIR Expr machinery", "tree": {"sha": "c15e7be7bfdae8074aa42f0c216e315bf8d7db49", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c15e7be7bfdae8074aa42f0c216e315bf8d7db49"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/136aba1cf32646278c4034541ee415f656f8bb5e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/136aba1cf32646278c4034541ee415f656f8bb5e", "html_url": "https://github.com/rust-lang/rust/commit/136aba1cf32646278c4034541ee415f656f8bb5e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/136aba1cf32646278c4034541ee415f656f8bb5e/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a6f33b4ca5e70a056c60b24cb8cb3283d8209624", "url": "https://api.github.com/repos/rust-lang/rust/commits/a6f33b4ca5e70a056c60b24cb8cb3283d8209624", "html_url": "https://github.com/rust-lang/rust/commit/a6f33b4ca5e70a056c60b24cb8cb3283d8209624"}], "stats": {"total": 546, "additions": 542, "deletions": 4}, "files": [{"sha": "074a7a7f678fd9cd37c5b6949d47ee57b52ddf80", "filename": "crates/ra_analysis/src/db.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/136aba1cf32646278c4034541ee415f656f8bb5e/crates%2Fra_analysis%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/136aba1cf32646278c4034541ee415f656f8bb5e/crates%2Fra_analysis%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fdb.rs?ref=136aba1cf32646278c4034541ee415f656f8bb5e", "patch": "@@ -106,6 +106,8 @@ salsa::database_storage! {\n             fn struct_data() for hir::db::StructDataQuery;\n             fn enum_data() for hir::db::EnumDataQuery;\n             fn impls_in_module() for hir::db::ImplsInModuleQuery;\n+            fn body_hir() for hir::db::BodyHirQuery;\n+            fn body_syntax_mapping() for hir::db::BodySyntaxMappingQuery;\n         }\n     }\n }"}, {"sha": "5bfcedf2bb5825c26fea4106a9771d0311d2c51d", "filename": "crates/ra_db/src/syntax_ptr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/136aba1cf32646278c4034541ee415f656f8bb5e/crates%2Fra_db%2Fsrc%2Fsyntax_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/136aba1cf32646278c4034541ee415f656f8bb5e/crates%2Fra_db%2Fsrc%2Fsyntax_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_db%2Fsrc%2Fsyntax_ptr.rs?ref=136aba1cf32646278c4034541ee415f656f8bb5e", "patch": "@@ -1,6 +1,6 @@\n use ra_syntax::{SourceFileNode, SyntaxKind, SyntaxNode, SyntaxNodeRef, TextRange};\n \n-/// A pionter to a syntax node inside a file.\n+/// A pointer to a syntax node inside a file.\n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub struct LocalSyntaxPtr {\n     range: TextRange,"}, {"sha": "188b968729f6c2b8f44d4cd2258bc16bcdfca85d", "filename": "crates/ra_hir/src/db.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/136aba1cf32646278c4034541ee415f656f8bb5e/crates%2Fra_hir%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/136aba1cf32646278c4034541ee415f656f8bb5e/crates%2Fra_hir%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fdb.rs?ref=136aba1cf32646278c4034541ee415f656f8bb5e", "patch": "@@ -93,6 +93,16 @@ pub trait HirDatabase: SyntaxDatabase\n         type ImplsInModuleQuery;\n         use fn crate::impl_block::impls_in_module;\n     }\n+\n+    fn body_hir(def_id: DefId) -> Cancelable<Arc<crate::expr::Body>> {\n+        type BodyHirQuery;\n+        use fn crate::expr::body_hir;\n+    }\n+\n+    fn body_syntax_mapping(def_id: DefId) -> Cancelable<Arc<crate::expr::BodySyntaxMapping>> {\n+        type BodySyntaxMappingQuery;\n+        use fn crate::expr::body_syntax_mapping;\n+    }\n }\n \n }"}, {"sha": "5cdcca082f6fa154c3e603cd7754e7412b6abb82", "filename": "crates/ra_hir/src/expr.rs", "status": "added", "additions": 507, "deletions": 0, "changes": 507, "blob_url": "https://github.com/rust-lang/rust/blob/136aba1cf32646278c4034541ee415f656f8bb5e/crates%2Fra_hir%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/136aba1cf32646278c4034541ee415f656f8bb5e/crates%2Fra_hir%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fexpr.rs?ref=136aba1cf32646278c4034541ee415f656f8bb5e", "patch": "@@ -0,0 +1,507 @@\n+use std::sync::Arc;\n+\n+use rustc_hash::FxHashMap;\n+\n+use ra_arena::{Arena, RawId, impl_arena_id};\n+use ra_db::{LocalSyntaxPtr, Cancelable};\n+use ra_syntax::ast::{self, AstNode, LoopBodyOwner, ArgListOwner};\n+\n+use crate::{Path, type_ref::{Mutability, TypeRef}, Name, HirDatabase, DefId, Def, name::AsName};\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+pub struct ExprId(RawId);\n+impl_arena_id!(ExprId);\n+\n+/// The body of an item (function, const etc.).\n+#[derive(Debug, Eq, PartialEq)]\n+pub struct Body {\n+    exprs: Arena<ExprId, Expr>,\n+    pats: Arena<PatId, Pat>,\n+    /// The patterns for the function's arguments. While the argument types are\n+    /// part of the function signature, the patterns are not (they don't change\n+    /// the external type of the function).\n+    ///\n+    /// If this `ExprTable` is for the body of a constant, this will just be\n+    /// empty.\n+    args: Vec<PatId>,\n+    /// The `ExprId` of the actual body expression.\n+    body_expr: ExprId,\n+}\n+\n+/// An item body together with the mapping from syntax nodes to HIR expression\n+/// IDs. This is needed to go from e.g. a position in a file to the HIR\n+/// expression containing it; but for type inference etc., we want to operate on\n+/// a structure that is agnostic to the actual positions of expressions in the\n+/// file, so that we don't recompute the type inference whenever some whitespace\n+/// is typed.\n+#[derive(Debug, Eq, PartialEq)]\n+pub struct BodySyntaxMapping {\n+    body: Arc<Body>,\n+    expr_syntax_mapping: FxHashMap<LocalSyntaxPtr, ExprId>,\n+    expr_syntax_mapping_back: FxHashMap<ExprId, LocalSyntaxPtr>,\n+    pat_syntax_mapping: FxHashMap<LocalSyntaxPtr, PatId>,\n+    pat_syntax_mapping_back: FxHashMap<PatId, LocalSyntaxPtr>,\n+}\n+\n+#[derive(Debug, Clone, Eq, PartialEq)]\n+pub enum Expr {\n+    /// This is produced if syntax tree does not have a required expression piece.\n+    Missing,\n+    Path(Path),\n+    If {\n+        condition: ExprId,\n+        then_branch: ExprId,\n+        else_branch: Option<ExprId>,\n+    },\n+    Block {\n+        statements: Vec<Statement>,\n+        tail: Option<ExprId>,\n+    },\n+    Loop {\n+        body: ExprId,\n+    },\n+    While {\n+        condition: ExprId,\n+        body: ExprId,\n+    },\n+    For {\n+        iterable: ExprId,\n+        pat: PatId,\n+        body: ExprId,\n+    },\n+    Call {\n+        callee: ExprId,\n+        args: Vec<ExprId>,\n+    },\n+    MethodCall {\n+        receiver: ExprId,\n+        method_name: Name,\n+        args: Vec<ExprId>,\n+    },\n+    Match {\n+        expr: ExprId,\n+        arms: Vec<MatchArm>,\n+    },\n+    Continue,\n+    Break {\n+        expr: Option<ExprId>,\n+    },\n+    Return {\n+        expr: Option<ExprId>,\n+    },\n+    StructLit {\n+        path: Option<Path>,\n+        fields: Vec<StructLitField>,\n+        spread: Option<ExprId>,\n+    },\n+    Field {\n+        expr: ExprId,\n+        name: Name,\n+    },\n+    Try {\n+        expr: ExprId,\n+    },\n+    Cast {\n+        expr: ExprId,\n+        type_ref: TypeRef,\n+    },\n+    Ref {\n+        expr: ExprId,\n+        mutability: Mutability,\n+    },\n+    UnaryOp {\n+        expr: ExprId,\n+        op: Option<UnaryOp>,\n+    },\n+}\n+\n+pub type UnaryOp = ast::PrefixOp;\n+\n+#[derive(Debug, Clone, Eq, PartialEq)]\n+pub struct MatchArm {\n+    pats: Vec<PatId>,\n+    // guard: Option<ExprId>, // TODO\n+    expr: ExprId,\n+}\n+\n+#[derive(Debug, Clone, Eq, PartialEq)]\n+pub struct StructLitField {\n+    name: Name,\n+    expr: ExprId,\n+}\n+\n+#[derive(Debug, Clone, Eq, PartialEq)]\n+pub enum Statement {\n+    Let {\n+        pat: PatId,\n+        type_ref: Option<TypeRef>,\n+        initializer: Option<ExprId>,\n+    },\n+    Expr(ExprId),\n+}\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+pub struct PatId(RawId);\n+impl_arena_id!(PatId);\n+\n+#[derive(Debug, Clone, Eq, PartialEq)]\n+pub struct Pat;\n+\n+// Queries\n+\n+pub(crate) fn body_hir(db: &impl HirDatabase, def_id: DefId) -> Cancelable<Arc<Body>> {\n+    Ok(Arc::clone(&body_syntax_mapping(db, def_id)?.body))\n+}\n+\n+struct ExprCollector {\n+    exprs: Arena<ExprId, Expr>,\n+    pats: Arena<PatId, Pat>,\n+    expr_syntax_mapping: FxHashMap<LocalSyntaxPtr, ExprId>,\n+    expr_syntax_mapping_back: FxHashMap<ExprId, LocalSyntaxPtr>,\n+    pat_syntax_mapping: FxHashMap<LocalSyntaxPtr, PatId>,\n+    pat_syntax_mapping_back: FxHashMap<PatId, LocalSyntaxPtr>,\n+}\n+\n+impl ExprCollector {\n+    fn alloc_expr(&mut self, expr: Expr, syntax_ptr: LocalSyntaxPtr) -> ExprId {\n+        let id = self.exprs.alloc(expr);\n+        self.expr_syntax_mapping.insert(syntax_ptr, id);\n+        self.expr_syntax_mapping_back.insert(id, syntax_ptr);\n+        id\n+    }\n+\n+    fn alloc_pat(&mut self, pat: Pat, syntax_ptr: LocalSyntaxPtr) -> PatId {\n+        let id = self.pats.alloc(pat);\n+        self.pat_syntax_mapping.insert(syntax_ptr, id);\n+        self.pat_syntax_mapping_back.insert(id, syntax_ptr);\n+        id\n+    }\n+\n+    fn collect_expr(&mut self, expr: ast::Expr) -> ExprId {\n+        let syntax_ptr = LocalSyntaxPtr::new(expr.syntax());\n+        match expr {\n+            ast::Expr::IfExpr(e) => {\n+                let condition = if let Some(condition) = e.condition() {\n+                    if condition.pat().is_none() {\n+                        self.collect_expr_opt(condition.expr())\n+                    } else {\n+                        // TODO handle if let\n+                        return self.alloc_expr(Expr::Missing, syntax_ptr);\n+                    }\n+                } else {\n+                    self.exprs.alloc(Expr::Missing)\n+                };\n+                let then_branch = self.collect_block_opt(e.then_branch());\n+                let else_branch = e.else_branch().map(|e| self.collect_block(e));\n+                self.alloc_expr(\n+                    Expr::If {\n+                        condition,\n+                        then_branch,\n+                        else_branch,\n+                    },\n+                    syntax_ptr,\n+                )\n+            }\n+            ast::Expr::BlockExpr(e) => self.collect_block_opt(e.block()),\n+            ast::Expr::LoopExpr(e) => {\n+                let body = self.collect_block_opt(e.loop_body());\n+                self.alloc_expr(Expr::Loop { body }, syntax_ptr)\n+            }\n+            ast::Expr::WhileExpr(e) => {\n+                let condition = if let Some(condition) = e.condition() {\n+                    if condition.pat().is_none() {\n+                        self.collect_expr_opt(condition.expr())\n+                    } else {\n+                        // TODO handle while let\n+                        return self.alloc_expr(Expr::Missing, syntax_ptr);\n+                    }\n+                } else {\n+                    self.exprs.alloc(Expr::Missing)\n+                };\n+                let body = self.collect_block_opt(e.loop_body());\n+                self.alloc_expr(Expr::While { condition, body }, syntax_ptr)\n+            }\n+            ast::Expr::ForExpr(e) => {\n+                let iterable = self.collect_expr_opt(e.iterable());\n+                let pat = self.collect_pat_opt(e.pat());\n+                let body = self.collect_block_opt(e.loop_body());\n+                self.alloc_expr(\n+                    Expr::For {\n+                        iterable,\n+                        pat,\n+                        body,\n+                    },\n+                    syntax_ptr,\n+                )\n+            }\n+            ast::Expr::CallExpr(e) => {\n+                let callee = self.collect_expr_opt(e.expr());\n+                let args = if let Some(arg_list) = e.arg_list() {\n+                    arg_list.args().map(|e| self.collect_expr(e)).collect()\n+                } else {\n+                    Vec::new()\n+                };\n+                self.alloc_expr(Expr::Call { callee, args }, syntax_ptr)\n+            }\n+            ast::Expr::MethodCallExpr(e) => {\n+                let receiver = self.collect_expr_opt(e.expr());\n+                let args = if let Some(arg_list) = e.arg_list() {\n+                    arg_list.args().map(|e| self.collect_expr(e)).collect()\n+                } else {\n+                    Vec::new()\n+                };\n+                let method_name = e\n+                    .name_ref()\n+                    .map(|nr| nr.as_name())\n+                    .unwrap_or_else(Name::missing);\n+                self.alloc_expr(\n+                    Expr::MethodCall {\n+                        receiver,\n+                        method_name,\n+                        args,\n+                    },\n+                    syntax_ptr,\n+                )\n+            }\n+            ast::Expr::MatchExpr(e) => {\n+                let expr = self.collect_expr_opt(e.expr());\n+                let arms = if let Some(match_arm_list) = e.match_arm_list() {\n+                    match_arm_list\n+                        .arms()\n+                        .map(|arm| MatchArm {\n+                            pats: arm.pats().map(|p| self.collect_pat(p)).collect(),\n+                            expr: self.collect_expr_opt(arm.expr()),\n+                        })\n+                        .collect()\n+                } else {\n+                    Vec::new()\n+                };\n+                self.alloc_expr(Expr::Match { expr, arms }, syntax_ptr)\n+            }\n+            ast::Expr::PathExpr(e) => {\n+                let path = e\n+                    .path()\n+                    .and_then(Path::from_ast)\n+                    .map(Expr::Path)\n+                    .unwrap_or(Expr::Missing);\n+                self.alloc_expr(path, syntax_ptr)\n+            }\n+            ast::Expr::ContinueExpr(_e) => {\n+                // TODO: labels\n+                self.alloc_expr(Expr::Continue, syntax_ptr)\n+            }\n+            ast::Expr::BreakExpr(e) => {\n+                let expr = e.expr().map(|e| self.collect_expr(e));\n+                self.alloc_expr(Expr::Break { expr }, syntax_ptr)\n+            }\n+            ast::Expr::ParenExpr(e) => {\n+                let inner = self.collect_expr_opt(e.expr());\n+                // make the paren expr point to the inner expression as well\n+                self.expr_syntax_mapping.insert(syntax_ptr, inner);\n+                inner\n+            }\n+            ast::Expr::ReturnExpr(e) => {\n+                let expr = e.expr().map(|e| self.collect_expr(e));\n+                self.alloc_expr(Expr::Return { expr }, syntax_ptr)\n+            }\n+            ast::Expr::StructLit(e) => {\n+                let path = e.path().and_then(Path::from_ast);\n+                let fields = if let Some(nfl) = e.named_field_list() {\n+                    nfl.fields()\n+                        .map(|field| StructLitField {\n+                            name: field\n+                                .name_ref()\n+                                .map(|nr| nr.as_name())\n+                                .unwrap_or_else(Name::missing),\n+                            expr: if let Some(e) = field.expr() {\n+                                self.collect_expr(e)\n+                            } else if let Some(nr) = field.name_ref() {\n+                                // field shorthand\n+                                let id = self.exprs.alloc(Expr::Path(Path::from_name_ref(nr)));\n+                                self.expr_syntax_mapping\n+                                    .insert(LocalSyntaxPtr::new(nr.syntax()), id);\n+                                self.expr_syntax_mapping_back\n+                                    .insert(id, LocalSyntaxPtr::new(nr.syntax()));\n+                                id\n+                            } else {\n+                                self.exprs.alloc(Expr::Missing)\n+                            },\n+                        })\n+                        .collect()\n+                } else {\n+                    Vec::new()\n+                };\n+                let spread = e.spread().map(|s| self.collect_expr(s));\n+                self.alloc_expr(\n+                    Expr::StructLit {\n+                        path,\n+                        fields,\n+                        spread,\n+                    },\n+                    syntax_ptr,\n+                )\n+            }\n+            ast::Expr::FieldExpr(e) => {\n+                let expr = self.collect_expr_opt(e.expr());\n+                let name = e\n+                    .name_ref()\n+                    .map(|nr| nr.as_name())\n+                    .unwrap_or_else(Name::missing);\n+                self.alloc_expr(Expr::Field { expr, name }, syntax_ptr)\n+            }\n+            ast::Expr::TryExpr(e) => {\n+                let expr = self.collect_expr_opt(e.expr());\n+                self.alloc_expr(Expr::Try { expr }, syntax_ptr)\n+            }\n+            ast::Expr::CastExpr(e) => {\n+                let expr = self.collect_expr_opt(e.expr());\n+                let type_ref = TypeRef::from_ast_opt(e.type_ref());\n+                self.alloc_expr(Expr::Cast { expr, type_ref }, syntax_ptr)\n+            }\n+            ast::Expr::RefExpr(e) => {\n+                let expr = self.collect_expr_opt(e.expr());\n+                let mutability = Mutability::from_mutable(e.is_mut());\n+                self.alloc_expr(Expr::Ref { expr, mutability }, syntax_ptr)\n+            }\n+            ast::Expr::PrefixExpr(e) => {\n+                let expr = self.collect_expr_opt(e.expr());\n+                let op = e.op();\n+                self.alloc_expr(Expr::UnaryOp { expr, op }, syntax_ptr)\n+            }\n+\n+            // We should never get to these because they're handled in MatchExpr resp. StructLit:\n+            ast::Expr::MatchArmList(_) | ast::Expr::MatchArm(_) | ast::Expr::MatchGuard(_) => {\n+                panic!(\"collect_expr called on {:?}\", expr)\n+            }\n+            ast::Expr::NamedFieldList(_) | ast::Expr::NamedField(_) => {\n+                panic!(\"collect_expr called on {:?}\", expr)\n+            }\n+\n+            // TODO implement HIR for these:\n+            ast::Expr::Label(_e) => self.alloc_expr(Expr::Missing, syntax_ptr),\n+            ast::Expr::LambdaExpr(_e) => self.alloc_expr(Expr::Missing, syntax_ptr),\n+            ast::Expr::IndexExpr(_e) => self.alloc_expr(Expr::Missing, syntax_ptr),\n+            ast::Expr::TupleExpr(_e) => self.alloc_expr(Expr::Missing, syntax_ptr),\n+            ast::Expr::ArrayExpr(_e) => self.alloc_expr(Expr::Missing, syntax_ptr),\n+            ast::Expr::RangeExpr(_e) => self.alloc_expr(Expr::Missing, syntax_ptr),\n+            ast::Expr::BinExpr(_e) => self.alloc_expr(Expr::Missing, syntax_ptr),\n+            ast::Expr::Literal(_e) => self.alloc_expr(Expr::Missing, syntax_ptr),\n+        }\n+    }\n+\n+    fn collect_expr_opt(&mut self, expr: Option<ast::Expr>) -> ExprId {\n+        if let Some(expr) = expr {\n+            self.collect_expr(expr)\n+        } else {\n+            self.exprs.alloc(Expr::Missing)\n+        }\n+    }\n+\n+    fn collect_block(&mut self, block: ast::Block) -> ExprId {\n+        let statements = block\n+            .statements()\n+            .map(|s| match s {\n+                ast::Stmt::LetStmt(stmt) => {\n+                    let pat = self.collect_pat_opt(stmt.pat());\n+                    let type_ref = stmt.type_ref().map(TypeRef::from_ast);\n+                    let initializer = stmt.initializer().map(|e| self.collect_expr(e));\n+                    Statement::Let {\n+                        pat,\n+                        type_ref,\n+                        initializer,\n+                    }\n+                }\n+                ast::Stmt::ExprStmt(stmt) => Statement::Expr(self.collect_expr_opt(stmt.expr())),\n+            })\n+            .collect();\n+        let tail = block.expr().map(|e| self.collect_expr(e));\n+        self.alloc_expr(\n+            Expr::Block { statements, tail },\n+            LocalSyntaxPtr::new(block.syntax()),\n+        )\n+    }\n+\n+    fn collect_block_opt(&mut self, block: Option<ast::Block>) -> ExprId {\n+        if let Some(block) = block {\n+            self.collect_block(block)\n+        } else {\n+            self.exprs.alloc(Expr::Missing)\n+        }\n+    }\n+\n+    fn collect_pat(&mut self, pat: ast::Pat) -> PatId {\n+        let syntax_ptr = LocalSyntaxPtr::new(pat.syntax());\n+        // TODO\n+        self.alloc_pat(Pat, syntax_ptr)\n+    }\n+\n+    fn collect_pat_opt(&mut self, pat: Option<ast::Pat>) -> PatId {\n+        if let Some(pat) = pat {\n+            self.collect_pat(pat)\n+        } else {\n+            // TODO\n+            self.pats.alloc(Pat)\n+        }\n+    }\n+\n+    fn into_body_syntax_mapping(self, args: Vec<PatId>, body_expr: ExprId) -> BodySyntaxMapping {\n+        let body = Body {\n+            exprs: self.exprs,\n+            pats: self.pats,\n+            args,\n+            body_expr,\n+        };\n+        BodySyntaxMapping {\n+            body: Arc::new(body),\n+            expr_syntax_mapping: self.expr_syntax_mapping,\n+            expr_syntax_mapping_back: self.expr_syntax_mapping_back,\n+            pat_syntax_mapping: self.pat_syntax_mapping,\n+            pat_syntax_mapping_back: self.pat_syntax_mapping_back,\n+        }\n+    }\n+}\n+\n+pub(crate) fn body_syntax_mapping(\n+    db: &impl HirDatabase,\n+    def_id: DefId,\n+) -> Cancelable<Arc<BodySyntaxMapping>> {\n+    let def = def_id.resolve(db)?;\n+    let mut collector = ExprCollector {\n+        exprs: Arena::default(),\n+        pats: Arena::default(),\n+        expr_syntax_mapping: FxHashMap::default(),\n+        expr_syntax_mapping_back: FxHashMap::default(),\n+        pat_syntax_mapping: FxHashMap::default(),\n+        pat_syntax_mapping_back: FxHashMap::default(),\n+    };\n+\n+    let (body, args) = match def {\n+        Def::Function(f) => {\n+            let node = f.syntax(db);\n+            let node = node.borrowed();\n+\n+            let args = if let Some(param_list) = node.param_list() {\n+                let mut args = Vec::new();\n+                // TODO self param\n+                for param in param_list.params() {\n+                    let pat = if let Some(pat) = param.pat() {\n+                        pat\n+                    } else {\n+                        continue;\n+                    };\n+                    args.push(collector.collect_pat(pat));\n+                }\n+                args\n+            } else {\n+                Vec::new()\n+            };\n+\n+            let body = collector.collect_block_opt(node.body());\n+            (body, args)\n+        }\n+        // TODO: consts, etc.\n+        _ => panic!(\"Trying to get body for item type without body\"),\n+    };\n+\n+    Ok(Arc::new(collector.into_body_syntax_mapping(args, body)))\n+}"}, {"sha": "fea9e141b21eb45662ff670635176033dd1ca604", "filename": "crates/ra_hir/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/136aba1cf32646278c4034541ee415f656f8bb5e/crates%2Fra_hir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/136aba1cf32646278c4034541ee415f656f8bb5e/crates%2Fra_hir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Flib.rs?ref=136aba1cf32646278c4034541ee415f656f8bb5e", "patch": "@@ -32,6 +32,7 @@ mod adt;\n mod type_ref;\n mod ty;\n mod impl_block;\n+mod expr;\n \n use crate::{\n     db::HirDatabase,"}, {"sha": "661a5a26b68993fc2683b6b19b111f912649299c", "filename": "crates/ra_hir/src/mock.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/136aba1cf32646278c4034541ee415f656f8bb5e/crates%2Fra_hir%2Fsrc%2Fmock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/136aba1cf32646278c4034541ee415f656f8bb5e/crates%2Fra_hir%2Fsrc%2Fmock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fmock.rs?ref=136aba1cf32646278c4034541ee415f656f8bb5e", "patch": "@@ -208,6 +208,8 @@ salsa::database_storage! {\n             fn struct_data() for db::StructDataQuery;\n             fn enum_data() for db::EnumDataQuery;\n             fn impls_in_module() for db::ImplsInModuleQuery;\n+            fn body_hir() for db::BodyHirQuery;\n+            fn body_syntax_mapping() for db::BodySyntaxMappingQuery;\n         }\n     }\n }"}, {"sha": "2e42caffe80a788d69ce7450616e22d4f594f10b", "filename": "crates/ra_hir/src/path.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/136aba1cf32646278c4034541ee415f656f8bb5e/crates%2Fra_hir%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/136aba1cf32646278c4034541ee415f656f8bb5e/crates%2Fra_hir%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fpath.rs?ref=136aba1cf32646278c4034541ee415f656f8bb5e", "patch": "@@ -65,6 +65,14 @@ impl Path {\n         }\n     }\n \n+    /// Converts an `ast::NameRef` into a single-identifier `Path`.\n+    pub fn from_name_ref(name_ref: ast::NameRef) -> Path {\n+        Path {\n+            kind: PathKind::Plain,\n+            segments: vec![name_ref.as_name()],\n+        }\n+    }\n+\n     /// `true` is this path is a single identifier, like `foo`\n     pub fn is_ident(&self) -> bool {\n         self.kind == PathKind::Plain && self.segments.len() == 1"}, {"sha": "deb4dea88bb6f513f957a49e333779b4c16718e3", "filename": "crates/ra_syntax/src/ast/generated.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/136aba1cf32646278c4034541ee415f656f8bb5e/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/136aba1cf32646278c4034541ee415f656f8bb5e/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs?ref=136aba1cf32646278c4034541ee415f656f8bb5e", "patch": "@@ -378,7 +378,11 @@ impl<R: TreeRoot<RaTypes>> BreakExprNode<R> {\n }\n \n \n-impl<'a> BreakExpr<'a> {}\n+impl<'a> BreakExpr<'a> {\n+    pub fn expr(self) -> Option<Expr<'a>> {\n+        super::child_opt(self)\n+    }\n+}\n \n // Byte\n #[derive(Debug, Clone, Copy,)]\n@@ -3880,6 +3884,10 @@ impl<'a> StructLit<'a> {\n     pub fn named_field_list(self) -> Option<NamedFieldList<'a>> {\n         super::child_opt(self)\n     }\n+\n+    pub fn spread(self) -> Option<Expr<'a>> {\n+        super::child_opt(self)\n+    }\n }\n \n // StructPat"}, {"sha": "5bcdf3f1d6b8f04d175bfc4e334a2a11759dc17c", "filename": "crates/ra_syntax/src/grammar.ron", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/136aba1cf32646278c4034541ee415f656f8bb5e/crates%2Fra_syntax%2Fsrc%2Fgrammar.ron", "raw_url": "https://github.com/rust-lang/rust/raw/136aba1cf32646278c4034541ee415f656f8bb5e/crates%2Fra_syntax%2Fsrc%2Fgrammar.ron", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fgrammar.ron?ref=136aba1cf32646278c4034541ee415f656f8bb5e", "patch": "@@ -384,7 +384,7 @@ Grammar(\n             options: [ \"Condition\" ]\n         ),\n         \"ContinueExpr\": (),\n-        \"BreakExpr\": (),\n+        \"BreakExpr\": (options: [\"Expr\"]),\n         \"Label\": (),\n         \"BlockExpr\": (\n             options: [ \"Block\" ]\n@@ -404,7 +404,7 @@ Grammar(\n             collections: [ [ \"pats\", \"Pat\" ] ]\n         ),\n         \"MatchGuard\": (),\n-        \"StructLit\": (options: [\"Path\", \"NamedFieldList\"]),\n+        \"StructLit\": (options: [\"Path\", \"NamedFieldList\", [\"spread\", \"Expr\"]]),\n         \"NamedFieldList\": (collections: [ [\"fields\", \"NamedField\"] ]),\n         \"NamedField\": (options: [\"NameRef\", \"Expr\"]),\n         \"CallExpr\": ("}]}