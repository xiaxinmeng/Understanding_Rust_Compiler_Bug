{"sha": "09825de61bb4e9a339b3c6759d73ebb4c0b6c7b1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA5ODI1ZGU2MWJiNGU5YTMzOWIzYzY3NTlkNzNlYmI0YzBiNmM3YjE=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2017-02-06T16:27:09Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2017-02-08T21:23:21Z"}, "message": "emit \"align 1\" metadata on loads/stores of packed structs\n\nAccording to the LLVM reference:\n> A value of 0 or an omitted align argument means that the operation has\nthe ABI alignment for the target.\n\nSo loads/stores of fields of packed structs need to have their align set\nto 1. Implement that by tracking the alignment of `LvalueRef`s.\n\nFixes #39376.", "tree": {"sha": "dcd15d3a30889c8f05fa4ceb2e457454a5131bf9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dcd15d3a30889c8f05fa4ceb2e457454a5131bf9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/09825de61bb4e9a339b3c6759d73ebb4c0b6c7b1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/09825de61bb4e9a339b3c6759d73ebb4c0b6c7b1", "html_url": "https://github.com/rust-lang/rust/commit/09825de61bb4e9a339b3c6759d73ebb4c0b6c7b1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/09825de61bb4e9a339b3c6759d73ebb4c0b6c7b1/comments", "author": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3", "url": "https://api.github.com/repos/rust-lang/rust/commits/4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3", "html_url": "https://github.com/rust-lang/rust/commit/4379e2fa08bf31125efa1a9d8bc3c85b16e2c2f3"}], "stats": {"total": 586, "additions": 363, "deletions": 223}, "files": [{"sha": "59f2104ec146471a05aaa0f7ce98100a7b1a8c52", "filename": "src/librustc_trans/adt.rs", "status": "modified", "additions": 16, "deletions": 9, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/09825de61bb4e9a339b3c6759d73ebb4c0b6c7b1/src%2Flibrustc_trans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09825de61bb4e9a339b3c6759d73ebb4c0b6c7b1/src%2Flibrustc_trans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fadt.rs?ref=09825de61bb4e9a339b3c6759d73ebb4c0b6c7b1", "patch": "@@ -56,6 +56,8 @@ use monomorphize;\n use type_::Type;\n use type_of;\n \n+use mir::lvalue::Alignment;\n+\n /// Given an enum, struct, closure, or tuple, extracts fields.\n /// Treats closures as a struct with one variant.\n /// `empty_if_no_variants` is a switch to deal with empty enums.\n@@ -279,6 +281,7 @@ pub fn trans_get_discr<'a, 'tcx>(\n     bcx: &Builder<'a, 'tcx>,\n     t: Ty<'tcx>,\n     scrutinee: ValueRef,\n+    alignment: Alignment,\n     cast_to: Option<Type>,\n     range_assert: bool\n ) -> ValueRef {\n@@ -292,11 +295,12 @@ pub fn trans_get_discr<'a, 'tcx>(\n \n     let val = match *l {\n         layout::CEnum { discr, min, max, .. } => {\n-            load_discr(bcx, discr, scrutinee, min, max, range_assert)\n+            load_discr(bcx, discr, scrutinee, alignment, min, max, range_assert)\n         }\n         layout::General { discr, .. } => {\n             let ptr = bcx.struct_gep(scrutinee, 0);\n-            load_discr(bcx, discr, ptr, 0, def.variants.len() as u64 - 1,\n+            load_discr(bcx, discr, ptr, alignment,\n+                       0, def.variants.len() as u64 - 1,\n                        range_assert)\n         }\n         layout::Univariant { .. } | layout::UntaggedUnion { .. } => C_u8(bcx.ccx, 0),\n@@ -305,10 +309,10 @@ pub fn trans_get_discr<'a, 'tcx>(\n             let llptrty = type_of::sizing_type_of(bcx.ccx,\n                 monomorphize::field_ty(bcx.tcx(), substs,\n                 &def.variants[nndiscr as usize].fields[0]));\n-            bcx.icmp(cmp, bcx.load(scrutinee), C_null(llptrty))\n+            bcx.icmp(cmp, bcx.load(scrutinee, alignment.to_align()), C_null(llptrty))\n         }\n         layout::StructWrappedNullablePointer { nndiscr, ref discrfield, .. } => {\n-            struct_wrapped_nullable_bitdiscr(bcx, nndiscr, discrfield, scrutinee)\n+            struct_wrapped_nullable_bitdiscr(bcx, nndiscr, discrfield, scrutinee, alignment)\n         },\n         _ => bug!(\"{} is not an enum\", t)\n     };\n@@ -322,17 +326,19 @@ fn struct_wrapped_nullable_bitdiscr(\n     bcx: &Builder,\n     nndiscr: u64,\n     discrfield: &layout::FieldPath,\n-    scrutinee: ValueRef\n+    scrutinee: ValueRef,\n+    alignment: Alignment,\n ) -> ValueRef {\n     let llptrptr = bcx.gepi(scrutinee,\n         &discrfield.iter().map(|f| *f as usize).collect::<Vec<_>>()[..]);\n-    let llptr = bcx.load(llptrptr);\n+    let llptr = bcx.load(llptrptr, alignment.to_align());\n     let cmp = if nndiscr == 0 { IntEQ } else { IntNE };\n     bcx.icmp(cmp, llptr, C_null(val_ty(llptr)))\n }\n \n /// Helper for cases where the discriminant is simply loaded.\n-fn load_discr(bcx: &Builder, ity: layout::Integer, ptr: ValueRef, min: u64, max: u64,\n+fn load_discr(bcx: &Builder, ity: layout::Integer, ptr: ValueRef,\n+              alignment: Alignment, min: u64, max: u64,\n               range_assert: bool)\n     -> ValueRef {\n     let llty = Type::from_integer(bcx.ccx, ity);\n@@ -348,11 +354,12 @@ fn load_discr(bcx: &Builder, ity: layout::Integer, ptr: ValueRef, min: u64, max:\n         // rejected by the LLVM verifier (it would mean either an\n         // empty set, which is impossible, or the entire range of the\n         // type, which is pointless).\n-        bcx.load(ptr)\n+        bcx.load(ptr, alignment.to_align())\n     } else {\n         // llvm::ConstantRange can deal with ranges that wrap around,\n         // so an overflow on (max + 1) is fine.\n-        bcx.load_range_assert(ptr, min, max.wrapping_add(1), /* signed: */ True)\n+        bcx.load_range_assert(ptr, min, max.wrapping_add(1), /* signed: */ True,\n+                              alignment.to_align())\n     }\n }\n "}, {"sha": "12e4e57964f985e47c9ba31226693965c73b4dd7", "filename": "src/librustc_trans/asm.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/09825de61bb4e9a339b3c6759d73ebb4c0b6c7b1/src%2Flibrustc_trans%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09825de61bb4e9a339b3c6759d73ebb4c0b6c7b1/src%2Flibrustc_trans%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fasm.rs?ref=09825de61bb4e9a339b3c6759d73ebb4c0b6c7b1", "patch": "@@ -20,6 +20,8 @@ use builder::Builder;\n use rustc::hir;\n use rustc::ty::Ty;\n \n+use mir::lvalue::Alignment;\n+\n use std::ffi::CString;\n use syntax::ast::AsmDialect;\n use libc::{c_uint, c_char};\n@@ -38,7 +40,7 @@ pub fn trans_inline_asm<'a, 'tcx>(\n     let mut indirect_outputs = vec![];\n     for (i, (out, &(val, ty))) in ia.outputs.iter().zip(&outputs).enumerate() {\n         let val = if out.is_rw || out.is_indirect {\n-            Some(base::load_ty(bcx, val, ty))\n+            Some(base::load_ty(bcx, val, Alignment::Packed, ty))\n         } else {\n             None\n         };"}, {"sha": "5312cc60b09167b82e3dbc607b9e3043816756bb", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 41, "deletions": 36, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/09825de61bb4e9a339b3c6759d73ebb4c0b6c7b1/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09825de61bb4e9a339b3c6759d73ebb4c0b6c7b1/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=09825de61bb4e9a339b3c6759d73ebb4c0b6c7b1", "patch": "@@ -90,6 +90,8 @@ use rustc::hir;\n use rustc::ty::layout::{self, Layout};\n use syntax::ast;\n \n+use mir::lvalue::Alignment;\n+\n pub struct StatRecorder<'a, 'tcx: 'a> {\n     ccx: &'a CrateContext<'a, 'tcx>,\n     name: Option<String>,\n@@ -250,25 +252,25 @@ pub fn unsize_thin_ptr<'a, 'tcx>(\n /// Coerce `src`, which is a reference to a value of type `src_ty`,\n /// to a value of type `dst_ty` and store the result in `dst`\n pub fn coerce_unsized_into<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n-                                     src: ValueRef,\n-                                     src_ty: Ty<'tcx>,\n-                                     dst: ValueRef,\n-                                     dst_ty: Ty<'tcx>) {\n+                                     src: &LvalueRef<'tcx>,\n+                                     dst: &LvalueRef<'tcx>) {\n+    let src_ty = src.ty.to_ty(bcx.tcx());\n+    let dst_ty = dst.ty.to_ty(bcx.tcx());\n     let coerce_ptr = || {\n         let (base, info) = if common::type_is_fat_ptr(bcx.ccx, src_ty) {\n             // fat-ptr to fat-ptr unsize preserves the vtable\n             // i.e. &'a fmt::Debug+Send => &'a fmt::Debug\n             // So we need to pointercast the base to ensure\n             // the types match up.\n-            let (base, info) = load_fat_ptr(bcx, src, src_ty);\n+            let (base, info) = load_fat_ptr(bcx, src.llval, src.alignment, src_ty);\n             let llcast_ty = type_of::fat_ptr_base_ty(bcx.ccx, dst_ty);\n             let base = bcx.pointercast(base, llcast_ty);\n             (base, info)\n         } else {\n-            let base = load_ty(bcx, src, src_ty);\n+            let base = load_ty(bcx, src.llval, src.alignment, src_ty);\n             unsize_thin_ptr(bcx, base, src_ty, dst_ty)\n         };\n-        store_fat_ptr(bcx, base, info, dst, dst_ty);\n+        store_fat_ptr(bcx, base, info, dst.llval, dst.alignment, dst_ty);\n     };\n     match (&src_ty.sty, &dst_ty.sty) {\n         (&ty::TyRef(..), &ty::TyRef(..)) |\n@@ -290,21 +292,22 @@ pub fn coerce_unsized_into<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n                 monomorphize::field_ty(bcx.tcx(), substs_b, f)\n             });\n \n-            let src = LvalueRef::new_sized_ty(src, src_ty);\n-            let dst = LvalueRef::new_sized_ty(dst, dst_ty);\n-\n             let iter = src_fields.zip(dst_fields).enumerate();\n             for (i, (src_fty, dst_fty)) in iter {\n                 if type_is_zero_size(bcx.ccx, dst_fty) {\n                     continue;\n                 }\n \n-                let src_f = src.trans_field_ptr(bcx, i);\n-                let dst_f = dst.trans_field_ptr(bcx, i);\n+                let (src_f, src_f_align) = src.trans_field_ptr(bcx, i);\n+                let (dst_f, dst_f_align) = dst.trans_field_ptr(bcx, i);\n                 if src_fty == dst_fty {\n                     memcpy_ty(bcx, dst_f, src_f, src_fty, None);\n                 } else {\n-                    coerce_unsized_into(bcx, src_f, src_fty, dst_f, dst_fty);\n+                    coerce_unsized_into(\n+                        bcx,\n+                        &LvalueRef::new_sized_ty(src_f, src_fty, src_f_align),\n+                        &LvalueRef::new_sized_ty(dst_f, dst_fty, dst_f_align)\n+                    );\n                 }\n             }\n         }\n@@ -399,7 +402,8 @@ pub fn call_assume<'a, 'tcx>(b: &Builder<'a, 'tcx>, val: ValueRef) {\n /// Helper for loading values from memory. Does the necessary conversion if the in-memory type\n /// differs from the type used for SSA values. Also handles various special cases where the type\n /// gives us better information about what we are loading.\n-pub fn load_ty<'a, 'tcx>(b: &Builder<'a, 'tcx>, ptr: ValueRef, t: Ty<'tcx>) -> ValueRef {\n+pub fn load_ty<'a, 'tcx>(b: &Builder<'a, 'tcx>, ptr: ValueRef,\n+                         alignment: Alignment, t: Ty<'tcx>) -> ValueRef {\n     let ccx = b.ccx;\n     if type_is_zero_size(ccx, t) {\n         return C_undef(type_of::type_of(ccx, t));\n@@ -419,54 +423,57 @@ pub fn load_ty<'a, 'tcx>(b: &Builder<'a, 'tcx>, ptr: ValueRef, t: Ty<'tcx>) -> V\n     }\n \n     if t.is_bool() {\n-        b.trunc(b.load_range_assert(ptr, 0, 2, llvm::False), Type::i1(ccx))\n+        b.trunc(b.load_range_assert(ptr, 0, 2, llvm::False, alignment.to_align()),\n+                Type::i1(ccx))\n     } else if t.is_char() {\n         // a char is a Unicode codepoint, and so takes values from 0\n         // to 0x10FFFF inclusive only.\n-        b.load_range_assert(ptr, 0, 0x10FFFF + 1, llvm::False)\n+        b.load_range_assert(ptr, 0, 0x10FFFF + 1, llvm::False, alignment.to_align())\n     } else if (t.is_region_ptr() || t.is_box()) && !common::type_is_fat_ptr(ccx, t) {\n-        b.load_nonnull(ptr)\n+        b.load_nonnull(ptr, alignment.to_align())\n     } else {\n-        b.load(ptr)\n+        b.load(ptr, alignment.to_align())\n     }\n }\n \n /// Helper for storing values in memory. Does the necessary conversion if the in-memory type\n /// differs from the type used for SSA values.\n-pub fn store_ty<'a, 'tcx>(cx: &Builder<'a, 'tcx>, v: ValueRef, dst: ValueRef, t: Ty<'tcx>) {\n+pub fn store_ty<'a, 'tcx>(cx: &Builder<'a, 'tcx>, v: ValueRef, dst: ValueRef,\n+                          dst_align: Alignment, t: Ty<'tcx>) {\n     debug!(\"store_ty: {:?} : {:?} <- {:?}\", Value(dst), t, Value(v));\n \n     if common::type_is_fat_ptr(cx.ccx, t) {\n         let lladdr = cx.extract_value(v, abi::FAT_PTR_ADDR);\n         let llextra = cx.extract_value(v, abi::FAT_PTR_EXTRA);\n-        store_fat_ptr(cx, lladdr, llextra, dst, t);\n+        store_fat_ptr(cx, lladdr, llextra, dst, dst_align, t);\n     } else {\n-        cx.store(from_immediate(cx, v), dst, None);\n+        cx.store(from_immediate(cx, v), dst, dst_align.to_align());\n     }\n }\n \n pub fn store_fat_ptr<'a, 'tcx>(cx: &Builder<'a, 'tcx>,\n                                data: ValueRef,\n                                extra: ValueRef,\n                                dst: ValueRef,\n+                               dst_align: Alignment,\n                                _ty: Ty<'tcx>) {\n     // FIXME: emit metadata\n-    cx.store(data, get_dataptr(cx, dst), None);\n-    cx.store(extra, get_meta(cx, dst), None);\n+    cx.store(data, get_dataptr(cx, dst), dst_align.to_align());\n+    cx.store(extra, get_meta(cx, dst), dst_align.to_align());\n }\n \n pub fn load_fat_ptr<'a, 'tcx>(\n-    b: &Builder<'a, 'tcx>, src: ValueRef, t: Ty<'tcx>\n+    b: &Builder<'a, 'tcx>, src: ValueRef, alignment: Alignment, t: Ty<'tcx>\n ) -> (ValueRef, ValueRef) {\n     let ptr = get_dataptr(b, src);\n     let ptr = if t.is_region_ptr() || t.is_box() {\n-        b.load_nonnull(ptr)\n+        b.load_nonnull(ptr, alignment.to_align())\n     } else {\n-        b.load(ptr)\n+        b.load(ptr, alignment.to_align())\n     };\n \n     // FIXME: emit metadata on `meta`.\n-    let meta = b.load(get_meta(b, src));\n+    let meta = b.load(get_meta(b, src), alignment.to_align());\n \n     (ptr, meta)\n }\n@@ -633,7 +640,7 @@ pub fn trans_ctor_shim<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n             bcx.alloca(fn_ty.ret.memory_ty(ccx), \"sret_slot\")\n         };\n         // Can return unsized value\n-        let mut dest_val = LvalueRef::new_sized_ty(dest, sig.output());\n+        let mut dest_val = LvalueRef::new_sized_ty(dest, sig.output(), Alignment::AbiAligned);\n         dest_val.ty = LvalueTy::Downcast {\n             adt_def: sig.output().ty_adt_def().unwrap(),\n             substs: substs,\n@@ -642,7 +649,7 @@ pub fn trans_ctor_shim<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         let mut llarg_idx = fn_ty.ret.is_indirect() as usize;\n         let mut arg_idx = 0;\n         for (i, arg_ty) in sig.inputs().iter().enumerate() {\n-            let lldestptr = dest_val.trans_field_ptr(&bcx, i);\n+            let (lldestptr, _) = dest_val.trans_field_ptr(&bcx, i);\n             let arg = &fn_ty.args[arg_idx];\n             arg_idx += 1;\n             if common::type_is_fat_ptr(bcx.ccx, arg_ty) {\n@@ -662,14 +669,12 @@ pub fn trans_ctor_shim<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         }\n \n         if let Some(cast_ty) = fn_ty.ret.cast {\n-            let load = bcx.load(bcx.pointercast(dest, cast_ty.ptr_to()));\n-            let llalign = llalign_of_min(ccx, fn_ty.ret.ty);\n-            unsafe {\n-                llvm::LLVMSetAlignment(load, llalign);\n-            }\n-            bcx.ret(load)\n+            bcx.ret(bcx.load(\n+                bcx.pointercast(dest, cast_ty.ptr_to()),\n+                Some(llalign_of_min(ccx, fn_ty.ret.ty))\n+            ));\n         } else {\n-            bcx.ret(bcx.load(dest))\n+            bcx.ret(bcx.load(dest, None))\n         }\n     } else {\n         bcx.ret_void();"}, {"sha": "89aaa8b66306ffeafd653259e73d723e74aba242", "filename": "src/librustc_trans/builder.rs", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/09825de61bb4e9a339b3c6759d73ebb4c0b6c7b1/src%2Flibrustc_trans%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09825de61bb4e9a339b3c6759d73ebb4c0b6c7b1/src%2Flibrustc_trans%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbuilder.rs?ref=09825de61bb4e9a339b3c6759d73ebb4c0b6c7b1", "patch": "@@ -19,9 +19,8 @@ use machine::llalign_of_pref;\n use type_::Type;\n use value::Value;\n use libc::{c_uint, c_char};\n-use rustc::ty::{Ty, TyCtxt, TypeFoldable};\n+use rustc::ty::TyCtxt;\n use rustc::session::Session;\n-use type_of;\n \n use std::borrow::Cow;\n use std::ffi::CString;\n@@ -486,11 +485,6 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         builder.dynamic_alloca(ty, name)\n     }\n \n-    pub fn alloca_ty(&self, ty: Ty<'tcx>, name: &str) -> ValueRef {\n-        assert!(!ty.has_param_types());\n-        self.alloca(type_of::type_of(self.ccx, ty), name)\n-    }\n-\n     pub fn dynamic_alloca(&self, ty: Type, name: &str) -> ValueRef {\n         self.count_insn(\"alloca\");\n         unsafe {\n@@ -511,10 +505,14 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         }\n     }\n \n-    pub fn load(&self, ptr: ValueRef) -> ValueRef {\n+    pub fn load(&self, ptr: ValueRef, align: Option<u32>) -> ValueRef {\n         self.count_insn(\"load\");\n         unsafe {\n-            llvm::LLVMBuildLoad(self.llbuilder, ptr, noname())\n+            let load = llvm::LLVMBuildLoad(self.llbuilder, ptr, noname());\n+            if let Some(align) = align {\n+                llvm::LLVMSetAlignment(load, align as c_uint);\n+            }\n+            load\n         }\n     }\n \n@@ -539,8 +537,9 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n \n     pub fn load_range_assert(&self, ptr: ValueRef, lo: u64,\n-                             hi: u64, signed: llvm::Bool) -> ValueRef {\n-        let value = self.load(ptr);\n+                             hi: u64, signed: llvm::Bool,\n+                             align: Option<u32>) -> ValueRef {\n+        let value = self.load(ptr, align);\n \n         unsafe {\n             let t = llvm::LLVMGetElementType(llvm::LLVMTypeOf(ptr));\n@@ -558,8 +557,8 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         value\n     }\n \n-    pub fn load_nonnull(&self, ptr: ValueRef) -> ValueRef {\n-        let value = self.load(ptr);\n+    pub fn load_nonnull(&self, ptr: ValueRef, align: Option<u32>) -> ValueRef {\n+        let value = self.load(ptr, align);\n         unsafe {\n             llvm::LLVMSetMetadata(value, llvm::MD_nonnull as c_uint,\n                                   llvm::LLVMMDNodeInContext(self.ccx.llcx(), ptr::null(), 0));"}, {"sha": "4a8658dd2e308a86d2bec71d3c0a890102c6979a", "filename": "src/librustc_trans/callee.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/09825de61bb4e9a339b3c6759d73ebb4c0b6c7b1/src%2Flibrustc_trans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09825de61bb4e9a339b3c6759d73ebb4c0b6c7b1/src%2Flibrustc_trans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcallee.rs?ref=09825de61bb4e9a339b3c6759d73ebb4c0b6c7b1", "patch": "@@ -41,6 +41,8 @@ use std::iter;\n \n use syntax_pos::DUMMY_SP;\n \n+use mir::lvalue::Alignment;\n+\n #[derive(Debug)]\n pub enum CalleeData {\n     /// Constructor for enum variant/tuple-like-struct.\n@@ -358,29 +360,27 @@ fn trans_fn_once_adapter_shim<'a, 'tcx>(\n     let fn_ty = callee.direct_fn_type(bcx.ccx, &[]);\n     let self_idx = fn_ty.ret.is_indirect() as usize;\n     let env_arg = &orig_fn_ty.args[0];\n-    let llenv = if env_arg.is_indirect() {\n-        llargs[self_idx]\n+    let env = if env_arg.is_indirect() {\n+        LvalueRef::new_sized_ty(llargs[self_idx], closure_ty, Alignment::AbiAligned)\n     } else {\n-        let scratch = bcx.alloca_ty(closure_ty, \"self\");\n+        let scratch = LvalueRef::alloca(&bcx, closure_ty, \"self\");\n         let mut llarg_idx = self_idx;\n-        env_arg.store_fn_arg(&bcx, &mut llarg_idx, scratch);\n+        env_arg.store_fn_arg(&bcx, &mut llarg_idx, scratch.llval);\n         scratch\n     };\n \n-    debug!(\"trans_fn_once_adapter_shim: env={:?}\", Value(llenv));\n+    debug!(\"trans_fn_once_adapter_shim: env={:?}\", env);\n     // Adjust llargs such that llargs[self_idx..] has the call arguments.\n     // For zero-sized closures that means sneaking in a new argument.\n     if env_arg.is_ignore() {\n-        llargs.insert(self_idx, llenv);\n+        llargs.insert(self_idx, env.llval);\n     } else {\n-        llargs[self_idx] = llenv;\n+        llargs[self_idx] = env.llval;\n     }\n \n     // Call the by-ref closure body with `self` in a cleanup scope,\n     // to drop `self` when the body returns, or in case it unwinds.\n-    let self_scope = CleanupScope::schedule_drop_mem(\n-        &bcx, LvalueRef::new_sized_ty(llenv, closure_ty)\n-    );\n+    let self_scope = CleanupScope::schedule_drop_mem(&bcx, env);\n \n     let llfn = callee.reify(bcx.ccx);\n     let llret;\n@@ -512,7 +512,7 @@ fn trans_fn_pointer_shim<'a, 'tcx>(\n     let llfnpointer = llfnpointer.unwrap_or_else(|| {\n         // the first argument (`self`) will be ptr to the fn pointer\n         if is_by_ref {\n-            bcx.load(self_arg)\n+            bcx.load(self_arg, None)\n         } else {\n             self_arg\n         }"}, {"sha": "ba7558b8acfa72af9fcc7933d80ac154ed6738e1", "filename": "src/librustc_trans/glue.rs", "status": "modified", "additions": 30, "deletions": 25, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/09825de61bb4e9a339b3c6759d73ebb4c0b6c7b1/src%2Flibrustc_trans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09825de61bb4e9a339b3c6759d73ebb4c0b6c7b1/src%2Flibrustc_trans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fglue.rs?ref=09825de61bb4e9a339b3c6759d73ebb4c0b6c7b1", "patch": "@@ -13,7 +13,6 @@\n // Code relating to drop glue.\n \n use std;\n-use std::ptr;\n use std::iter;\n \n use llvm;\n@@ -41,6 +40,7 @@ use Disr;\n use builder::Builder;\n \n use syntax_pos::DUMMY_SP;\n+use mir::lvalue::Alignment;\n \n pub fn trans_exchange_free_ty<'a, 'tcx>(bcx: &Builder<'a, 'tcx>, ptr: LvalueRef<'tcx>) {\n     let content_ty = ptr.ty.to_ty(bcx.tcx());\n@@ -199,9 +199,9 @@ pub fn implement_drop_glue<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, g: DropGlueKi\n \n     let value = get_param(llfn, 0);\n     let ptr = if ccx.shared().type_is_sized(t) {\n-        LvalueRef::new_sized_ty(value, t)\n+        LvalueRef::new_sized_ty(value, t, Alignment::AbiAligned)\n     } else {\n-        LvalueRef::new_unsized_ty(value, get_param(llfn, 1), t)\n+        LvalueRef::new_unsized_ty(value, get_param(llfn, 1), t, Alignment::AbiAligned)\n     };\n \n     let skip_dtor = match g {\n@@ -216,11 +216,13 @@ pub fn implement_drop_glue<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, g: DropGlueKi\n             assert!(!skip_dtor);\n             let content_ty = t.boxed_ty();\n             let ptr = if !bcx.ccx.shared().type_is_sized(content_ty) {\n-                let llbox = bcx.load(get_dataptr(&bcx, ptr.llval));\n-                let info = bcx.load(get_meta(&bcx, ptr.llval));\n-                LvalueRef::new_unsized_ty(llbox, info, content_ty)\n+                let llbox = bcx.load(get_dataptr(&bcx, ptr.llval), None);\n+                let info = bcx.load(get_meta(&bcx, ptr.llval), None);\n+                LvalueRef::new_unsized_ty(llbox, info, content_ty, Alignment::AbiAligned)\n             } else {\n-                LvalueRef::new_sized_ty(bcx.load(ptr.llval), content_ty)\n+                LvalueRef::new_sized_ty(\n+                    bcx.load(ptr.llval, None),\n+                    content_ty, Alignment::AbiAligned)\n             };\n             drop_ty(&bcx, ptr);\n             trans_exchange_free_ty(&bcx, ptr);\n@@ -231,7 +233,7 @@ pub fn implement_drop_glue<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, g: DropGlueKi\n             // versus without calling Drop::drop. Assert caller is\n             // okay with always calling the Drop impl, if any.\n             assert!(!skip_dtor);\n-            let dtor = bcx.load(ptr.llextra);\n+            let dtor = bcx.load(ptr.llextra, None);\n             bcx.call(dtor, &[ptr.llval], None);\n             bcx\n         }\n@@ -384,7 +386,7 @@ pub fn size_and_align_of_dst<'a, 'tcx>(bcx: &Builder<'a, 'tcx>, t: Ty<'tcx>, inf\n             let info = bcx.pointercast(info, Type::int(bcx.ccx).ptr_to());\n             let size_ptr = bcx.gepi(info, &[1]);\n             let align_ptr = bcx.gepi(info, &[2]);\n-            (bcx.load(size_ptr), bcx.load(align_ptr))\n+            (bcx.load(size_ptr, None), bcx.load(align_ptr, None))\n         }\n         ty::TySlice(_) | ty::TyStr => {\n             let unit_ty = t.sequence_element_type(bcx.tcx());\n@@ -416,8 +418,8 @@ fn drop_structural_ty<'a, 'tcx>(\n         let tcx = cx.tcx();\n         for (i, field) in variant.fields.iter().enumerate() {\n             let arg = monomorphize::field_ty(tcx, substs, field);\n-            let field_ptr = av.trans_field_ptr(&cx, i);\n-            drop_ty(&cx, LvalueRef::new_sized_ty(field_ptr, arg));\n+            let (field_ptr, align) = av.trans_field_ptr(&cx, i);\n+            drop_ty(&cx, LvalueRef::new_sized_ty(field_ptr, arg, align));\n         }\n     }\n \n@@ -426,38 +428,38 @@ fn drop_structural_ty<'a, 'tcx>(\n     match t.sty {\n         ty::TyClosure(def_id, substs) => {\n             for (i, upvar_ty) in substs.upvar_tys(def_id, cx.tcx()).enumerate() {\n-                let llupvar = ptr.trans_field_ptr(&cx, i);\n-                drop_ty(&cx, LvalueRef::new_sized_ty(llupvar, upvar_ty));\n+                let (llupvar, align) = ptr.trans_field_ptr(&cx, i);\n+                drop_ty(&cx, LvalueRef::new_sized_ty(llupvar, upvar_ty, align));\n             }\n         }\n         ty::TyArray(_, n) => {\n             let base = get_dataptr(&cx, ptr.llval);\n             let len = C_uint(cx.ccx, n);\n             let unit_ty = t.sequence_element_type(cx.tcx());\n             cx = tvec::slice_for_each(&cx, base, unit_ty, len,\n-                |bb, vv| drop_ty(bb, LvalueRef::new_sized_ty(vv, unit_ty)));\n+                |bb, vv| drop_ty(bb, LvalueRef::new_sized_ty(vv, unit_ty, ptr.alignment)));\n         }\n         ty::TySlice(_) | ty::TyStr => {\n             let unit_ty = t.sequence_element_type(cx.tcx());\n             cx = tvec::slice_for_each(&cx, ptr.llval, unit_ty, ptr.llextra,\n-                |bb, vv| drop_ty(bb, LvalueRef::new_sized_ty(vv, unit_ty)));\n+                |bb, vv| drop_ty(bb, LvalueRef::new_sized_ty(vv, unit_ty, ptr.alignment)));\n         }\n         ty::TyTuple(ref args, _) => {\n             for (i, arg) in args.iter().enumerate() {\n-                let llfld_a = ptr.trans_field_ptr(&cx, i);\n-                drop_ty(&cx, LvalueRef::new_sized_ty(llfld_a, *arg));\n+                let (llfld_a, align) = ptr.trans_field_ptr(&cx, i);\n+                drop_ty(&cx, LvalueRef::new_sized_ty(llfld_a, *arg, align));\n             }\n         }\n         ty::TyAdt(adt, substs) => match adt.adt_kind() {\n             AdtKind::Struct => {\n                 for (i, field) in adt.variants[0].fields.iter().enumerate() {\n                     let field_ty = monomorphize::field_ty(cx.tcx(), substs, field);\n-                    let mut field_ptr = ptr.clone();\n-                    field_ptr.llval = ptr.trans_field_ptr(&cx, i);\n-                    field_ptr.ty = LvalueTy::from_ty(field_ty);\n-                    if cx.ccx.shared().type_is_sized(field_ty) {\n-                        field_ptr.llextra = ptr::null_mut();\n-                    }\n+                    let (llval, align) = ptr.trans_field_ptr(&cx, i);\n+                    let field_ptr = if cx.ccx.shared().type_is_sized(field_ty) {\n+                        LvalueRef::new_sized_ty(llval, field_ty, align)\n+                    } else {\n+                        LvalueRef::new_unsized_ty(llval, ptr.llextra, field_ty, align)\n+                    };\n                     drop_ty(&cx, field_ptr);\n                 }\n             }\n@@ -490,9 +492,12 @@ fn drop_structural_ty<'a, 'tcx>(\n                     layout::General { .. } |\n                     layout::RawNullablePointer { .. } |\n                     layout::StructWrappedNullablePointer { .. } => {\n-                        let lldiscrim_a = adt::trans_get_discr(&cx, t, ptr.llval, None, false);\n+                        let lldiscrim_a = adt::trans_get_discr(\n+                            &cx, t, ptr.llval, ptr.alignment, None, false);\n                         let tcx = cx.tcx();\n-                        drop_ty(&cx, LvalueRef::new_sized_ty(lldiscrim_a, tcx.types.isize));\n+                        // FIXME: why are dropping an isize?\n+                        drop_ty(&cx, LvalueRef::new_sized_ty(lldiscrim_a, tcx.types.isize,\n+                                                             ptr.alignment));\n \n                         // Create a fall-through basic block for the \"else\" case of\n                         // the switch instruction we're about to generate. Note that"}, {"sha": "1335a87b0b7b2db17243baf44a6642227406a7e1", "filename": "src/librustc_trans/intrinsic.rs", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/09825de61bb4e9a339b3c6759d73ebb4c0b6c7b1/src%2Flibrustc_trans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09825de61bb4e9a339b3c6759d73ebb4c0b6c7b1/src%2Flibrustc_trans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fintrinsic.rs?ref=09825de61bb4e9a339b3c6759d73ebb4c0b6c7b1", "patch": "@@ -36,6 +36,8 @@ use syntax_pos::Span;\n use std::cmp::Ordering;\n use std::iter;\n \n+use mir::lvalue::Alignment;\n+\n fn get_simple_intrinsic(ccx: &CrateContext, name: &str) -> Option<ValueRef> {\n     let llvm_name = match name {\n         \"sqrtf32\" => \"llvm.sqrt.f32\",\n@@ -243,7 +245,7 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n                 bcx.volatile_store(llargs[2], get_meta(bcx, llargs[0]));\n             } else {\n                 let val = if fn_ty.args[1].is_indirect() {\n-                    bcx.load(llargs[1])\n+                    bcx.load(llargs[1], None) // FIXME: this is incorrect\n                 } else {\n                     from_immediate(bcx, llargs[1])\n                 };\n@@ -348,7 +350,7 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n             let val_ty = substs.type_at(0);\n             match val_ty.sty {\n                 ty::TyAdt(adt, ..) if adt.is_enum() => {\n-                    adt::trans_get_discr(bcx, val_ty, llargs[0],\n+                    adt::trans_get_discr(bcx, val_ty, llargs[0], Alignment::AbiAligned,\n                                          Some(llret_ty), true)\n                 }\n                 _ => C_null(llret_ty)\n@@ -547,8 +549,11 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n                         // destructors, and the contents are SIMD\n                         // etc.\n                         assert!(!bcx.ccx.shared().type_needs_drop(arg_type));\n-                        let arg = LvalueRef::new_sized_ty(llarg, arg_type);\n-                        (0..contents.len()).map(|i| bcx.load(arg.trans_field_ptr(bcx, i))).collect()\n+                        let arg = LvalueRef::new_sized_ty(llarg, arg_type, Alignment::AbiAligned);\n+                        (0..contents.len()).map(|i| {\n+                            let (ptr, align) = arg.trans_field_ptr(bcx, i);\n+                            bcx.load(ptr, align.to_align())\n+                        }).collect()\n                     }\n                     intrinsics::Type::Pointer(_, Some(ref llvm_elem), _) => {\n                         let llvm_elem = one(ty_to_type(bcx.ccx, llvm_elem, &mut false));\n@@ -624,7 +629,7 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n             let ptr = bcx.pointercast(llresult, ty.ptr_to());\n             bcx.store(llval, ptr, Some(type_of::align_of(ccx, ret_ty)));\n         } else {\n-            store_ty(bcx, llval, llresult, ret_ty);\n+            store_ty(bcx, llval, llresult, Alignment::AbiAligned, ret_ty);\n         }\n     }\n }\n@@ -780,10 +785,10 @@ fn trans_msvc_try<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n             None => bug!(\"msvc_try_filter not defined\"),\n         };\n         let tok = catchpad.catch_pad(cs, &[tydesc, C_i32(ccx, 0), slot]);\n-        let addr = catchpad.load(slot);\n-        let arg1 = catchpad.load(addr);\n+        let addr = catchpad.load(slot, None);\n+        let arg1 = catchpad.load(addr, None);\n         let val1 = C_i32(ccx, 1);\n-        let arg2 = catchpad.load(catchpad.inbounds_gep(addr, &[val1]));\n+        let arg2 = catchpad.load(catchpad.inbounds_gep(addr, &[val1]), None);\n         let local_ptr = catchpad.bitcast(local_ptr, i64p);\n         catchpad.store(arg1, local_ptr, None);\n         catchpad.store(arg2, catchpad.inbounds_gep(local_ptr, &[val1]), None);"}, {"sha": "3033ae61d20c80ded2e4101210084e57e825e862", "filename": "src/librustc_trans/meth.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/09825de61bb4e9a339b3c6759d73ebb4c0b6c7b1/src%2Flibrustc_trans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09825de61bb4e9a339b3c6759d73ebb4c0b6c7b1/src%2Flibrustc_trans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmeth.rs?ref=09825de61bb4e9a339b3c6759d73ebb4c0b6c7b1", "patch": "@@ -36,7 +36,7 @@ pub fn get_virtual_method<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n     debug!(\"get_virtual_method(vtable_index={}, llvtable={:?})\",\n            vtable_index, Value(llvtable));\n \n-    bcx.load(bcx.gepi(llvtable, &[vtable_index + VTABLE_OFFSET]))\n+    bcx.load(bcx.gepi(llvtable, &[vtable_index + VTABLE_OFFSET]), None)\n }\n \n /// Generate a shim function that allows an object type like `SomeTrait` to"}, {"sha": "356d3e7372b9fec5be955b10deba9def7b2ae255", "filename": "src/librustc_trans/mir/block.rs", "status": "modified", "additions": 52, "deletions": 43, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/09825de61bb4e9a339b3c6759d73ebb4c0b6c7b1/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09825de61bb4e9a339b3c6759d73ebb4c0b6c7b1/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fblock.rs?ref=09825de61bb4e9a339b3c6759d73ebb4c0b6c7b1", "patch": "@@ -37,7 +37,7 @@ use std::cmp;\n use super::{MirContext, LocalRef};\n use super::analyze::CleanupKind;\n use super::constant::Const;\n-use super::lvalue::LvalueRef;\n+use super::lvalue::{Alignment, LvalueRef};\n use super::operand::OperandRef;\n use super::operand::OperandValue::{Pair, Ref, Immediate};\n \n@@ -120,7 +120,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                     bcx.cleanup_ret(cleanup_pad, None);\n                 } else {\n                     let ps = self.get_personality_slot(&bcx);\n-                    let lp = bcx.load(ps);\n+                    let lp = bcx.load(ps, None);\n                     Lifetime::End.call(&bcx, ps);\n                     if !bcx.sess().target.target.options.custom_unwind_resume {\n                         bcx.resume(lp);\n@@ -147,7 +147,8 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n             mir::TerminatorKind::Switch { ref discr, ref adt_def, ref targets } => {\n                 let discr_lvalue = self.trans_lvalue(&bcx, discr);\n                 let ty = discr_lvalue.ty.to_ty(bcx.tcx());\n-                let discr = adt::trans_get_discr(&bcx, ty, discr_lvalue.llval, None, true);\n+                let discr = adt::trans_get_discr(&bcx, ty, discr_lvalue.llval, discr_lvalue.alignment,\n+                                                 None, true);\n \n                 let mut bb_hist = FxHashMap();\n                 for target in targets {\n@@ -179,7 +180,8 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n \n             mir::TerminatorKind::SwitchInt { ref discr, switch_ty, ref values, ref targets } => {\n                 let (otherwise, targets) = targets.split_last().unwrap();\n-                let discr = bcx.load(self.trans_lvalue(&bcx, discr).llval);\n+                let lv = self.trans_lvalue(&bcx, discr);\n+                let discr = bcx.load(lv.llval, lv.alignment.to_align());\n                 let discr = base::to_immediate(&bcx, discr, switch_ty);\n                 let switch = bcx.switch(discr, llblock(self, *otherwise), values.len());\n                 for (value, target) in values.iter().zip(targets) {\n@@ -202,29 +204,30 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                         LocalRef::Operand(None) => bug!(\"use of return before def\"),\n                         LocalRef::Lvalue(tr_lvalue) => {\n                             OperandRef {\n-                                val: Ref(tr_lvalue.llval),\n+                                val: Ref(tr_lvalue.llval, tr_lvalue.alignment),\n                                 ty: tr_lvalue.ty.to_ty(bcx.tcx())\n                             }\n                         }\n                     };\n                     let llslot = match op.val {\n                         Immediate(_) | Pair(..) => {\n                             let llscratch = bcx.alloca(ret.original_ty, \"ret\");\n-                            self.store_operand(&bcx, llscratch, op, None);\n+                            self.store_operand(&bcx, llscratch, None, op);\n                             llscratch\n                         }\n-                        Ref(llval) => llval\n+                        Ref(llval, align) => {\n+                            assert_eq!(align, Alignment::AbiAligned, \"return pointer is unaligned!\");\n+                            llval\n+                        }\n                     };\n-                    let load = bcx.load(bcx.pointercast(llslot, cast_ty.ptr_to()));\n-                    let llalign = llalign_of_min(bcx.ccx, ret.ty);\n-                    unsafe {\n-                        llvm::LLVMSetAlignment(load, llalign);\n-                    }\n+                    let load = bcx.load(\n+                        bcx.pointercast(llslot, cast_ty.ptr_to()),\n+                        Some(llalign_of_min(bcx.ccx, ret.ty)));\n                     load\n                 } else {\n                     let op = self.trans_consume(&bcx, &mir::Lvalue::Local(mir::RETURN_POINTER));\n-                    if let Ref(llval) = op.val {\n-                        base::load_ty(&bcx, llval, op.ty)\n+                    if let Ref(llval, align) = op.val {\n+                        base::load_ty(&bcx, llval, align, op.ty)\n                     } else {\n                         op.pack_if_pair(&bcx).immediate()\n                     }\n@@ -425,7 +428,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                     // The first argument is a thin destination pointer.\n                     let llptr = self.trans_operand(&bcx, &args[0]).immediate();\n                     let val = self.trans_operand(&bcx, &args[1]);\n-                    self.store_operand(&bcx, llptr, val, None);\n+                    self.store_operand(&bcx, llptr, None, val);\n                     funclet_br(self, bcx, target);\n                     return;\n                 }\n@@ -550,7 +553,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                         if let ReturnDest::IndirectOperand(dst, _) = ret_dest {\n                             // Make a fake operand for store_return\n                             let op = OperandRef {\n-                                val: Ref(dst),\n+                                val: Ref(dst, Alignment::AbiAligned),\n                                 ty: sig.output(),\n                             };\n                             self.store_return(&bcx, ret_dest, fn_ty.ret, op);\n@@ -652,33 +655,39 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n         }\n \n         // Force by-ref if we have to load through a cast pointer.\n-        let (mut llval, by_ref) = match op.val {\n+        let (mut llval, align, by_ref) = match op.val {\n             Immediate(_) | Pair(..) => {\n                 if arg.is_indirect() || arg.cast.is_some() {\n                     let llscratch = bcx.alloca(arg.original_ty, \"arg\");\n-                    self.store_operand(bcx, llscratch, op, None);\n-                    (llscratch, true)\n+                    self.store_operand(bcx, llscratch, None, op);\n+                    (llscratch, Alignment::AbiAligned, true)\n                 } else {\n-                    (op.pack_if_pair(bcx).immediate(), false)\n+                    (op.pack_if_pair(bcx).immediate(), Alignment::AbiAligned, false)\n                 }\n             }\n-            Ref(llval) => (llval, true)\n+            Ref(llval, Alignment::Packed) if arg.is_indirect() => {\n+                // `foo(packed.large_field)`. We can't pass the (unaligned) field directly. I\n+                // think that ATM (Rust 1.16) we only pass temporaries, but we shouldn't\n+                // have scary latent bugs around.\n+\n+                let llscratch = bcx.alloca(arg.original_ty, \"arg\");\n+                base::memcpy_ty(bcx, llscratch, llval, op.ty, Some(1));\n+                (llscratch, Alignment::AbiAligned, true)\n+            }\n+            Ref(llval, align) => (llval, align, true)\n         };\n \n         if by_ref && !arg.is_indirect() {\n             // Have to load the argument, maybe while casting it.\n             if arg.original_ty == Type::i1(bcx.ccx) {\n                 // We store bools as i8 so we need to truncate to i1.\n-                llval = bcx.load_range_assert(llval, 0, 2, llvm::False);\n+                llval = bcx.load_range_assert(llval, 0, 2, llvm::False, None);\n                 llval = bcx.trunc(llval, arg.original_ty);\n             } else if let Some(ty) = arg.cast {\n-                llval = bcx.load(bcx.pointercast(llval, ty.ptr_to()));\n-                let llalign = llalign_of_min(bcx.ccx, arg.ty);\n-                unsafe {\n-                    llvm::LLVMSetAlignment(llval, llalign);\n-                }\n+                llval = bcx.load(bcx.pointercast(llval, ty.ptr_to()),\n+                                 align.min_with(llalign_of_min(bcx.ccx, arg.ty)));\n             } else {\n-                llval = bcx.load(llval);\n+                llval = bcx.load(llval, align.to_align());\n             }\n         }\n \n@@ -702,16 +711,16 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n \n         // Handle both by-ref and immediate tuples.\n         match tuple.val {\n-            Ref(llval) => {\n+            Ref(llval, align) => {\n                 for (n, &ty) in arg_types.iter().enumerate() {\n-                    let ptr = LvalueRef::new_sized_ty(llval, tuple.ty);\n-                    let ptr = ptr.trans_field_ptr(bcx, n);\n+                    let ptr = LvalueRef::new_sized_ty(llval, tuple.ty, align);\n+                    let (ptr, align) = ptr.trans_field_ptr(bcx, n);\n                     let val = if common::type_is_fat_ptr(bcx.ccx, ty) {\n-                        let (lldata, llextra) = base::load_fat_ptr(bcx, ptr, ty);\n+                        let (lldata, llextra) = base::load_fat_ptr(bcx, ptr, align, ty);\n                         Pair(lldata, llextra)\n                     } else {\n                         // trans_argument will load this if it needs to\n-                        Ref(ptr)\n+                        Ref(ptr, align)\n                     };\n                     let op = OperandRef {\n                         val: val,\n@@ -839,15 +848,15 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                     return if fn_ret_ty.is_indirect() {\n                         // Odd, but possible, case, we have an operand temporary,\n                         // but the calling convention has an indirect return.\n-                        let tmp = bcx.alloca_ty(ret_ty, \"tmp_ret\");\n-                        llargs.push(tmp);\n-                        ReturnDest::IndirectOperand(tmp, index)\n+                        let tmp = LvalueRef::alloca(bcx, ret_ty, \"tmp_ret\");\n+                        llargs.push(tmp.llval);\n+                        ReturnDest::IndirectOperand(tmp.llval, index)\n                     } else if is_intrinsic {\n                         // Currently, intrinsics always need a location to store\n                         // the result. so we create a temporary alloca for the\n                         // result\n-                        let tmp = bcx.alloca_ty(ret_ty, \"tmp_ret\");\n-                        ReturnDest::IndirectOperand(tmp, index)\n+                        let tmp = LvalueRef::alloca(bcx, ret_ty, \"tmp_ret\");\n+                        ReturnDest::IndirectOperand(tmp.llval, index)\n                     } else {\n                         ReturnDest::DirectOperand(index)\n                     };\n@@ -892,7 +901,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n         let in_type = val.ty;\n         let out_type = dst.ty.to_ty(bcx.tcx());;\n         let llalign = cmp::min(align_of(bcx.ccx, in_type), align_of(bcx.ccx, out_type));\n-        self.store_operand(bcx, cast_ptr, val, Some(llalign));\n+        self.store_operand(bcx, cast_ptr, Some(llalign), val);\n     }\n \n \n@@ -908,15 +917,15 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n             Nothing => (),\n             Store(dst) => ret_ty.store(bcx, op.immediate(), dst),\n             IndirectOperand(tmp, index) => {\n-                let op = self.trans_load(bcx, tmp, op.ty);\n+                let op = self.trans_load(bcx, tmp, Alignment::AbiAligned, op.ty);\n                 self.locals[index] = LocalRef::Operand(Some(op));\n             }\n             DirectOperand(index) => {\n                 // If there is a cast, we have to store and reload.\n                 let op = if ret_ty.cast.is_some() {\n-                    let tmp = bcx.alloca_ty(op.ty, \"tmp_ret\");\n-                    ret_ty.store(bcx, op.immediate(), tmp);\n-                    self.trans_load(bcx, tmp, op.ty)\n+                    let tmp = LvalueRef::alloca(bcx, op.ty, \"tmp_ret\");\n+                    ret_ty.store(bcx, op.immediate(), tmp.llval);\n+                    self.trans_load(bcx, tmp.llval, tmp.alignment, op.ty)\n                 } else {\n                     op.unpack_if_pair(bcx)\n                 };"}, {"sha": "11668e792e3f98faa503c0c88f1bc44837d54096", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/09825de61bb4e9a339b3c6759d73ebb4c0b6c7b1/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09825de61bb4e9a339b3c6759d73ebb4c0b6c7b1/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=09825de61bb4e9a339b3c6759d73ebb4c0b6c7b1", "patch": "@@ -40,6 +40,7 @@ use syntax_pos::Span;\n use std::fmt;\n use std::ptr;\n \n+use super::lvalue::Alignment;\n use super::operand::{OperandRef, OperandValue};\n use super::MirContext;\n \n@@ -140,7 +141,7 @@ impl<'tcx> Const<'tcx> {\n             // a constant LLVM global and cast its address if necessary.\n             let align = type_of::align_of(ccx, self.ty);\n             let ptr = consts::addr_of(ccx, self.llval, align, \"const\");\n-            OperandValue::Ref(consts::ptrcast(ptr, llty.ptr_to()))\n+            OperandValue::Ref(consts::ptrcast(ptr, llty.ptr_to()), Alignment::AbiAligned)\n         };\n \n         OperandRef {"}, {"sha": "6800fa341524e7e63692bd84accddcea6c6521c3", "filename": "src/librustc_trans/mir/lvalue.rs", "status": "modified", "additions": 93, "deletions": 29, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/09825de61bb4e9a339b3c6759d73ebb4c0b6c7b1/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09825de61bb4e9a339b3c6759d73ebb4c0b6c7b1/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Flvalue.rs?ref=09825de61bb4e9a339b3c6759d73ebb4c0b6c7b1", "patch": "@@ -25,10 +25,52 @@ use value::Value;\n use glue;\n \n use std::ptr;\n+use std::ops;\n \n use super::{MirContext, LocalRef};\n use super::operand::OperandValue;\n \n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+pub enum Alignment {\n+    Packed,\n+    AbiAligned,\n+}\n+\n+impl ops::BitOr for Alignment {\n+    type Output = Self;\n+\n+    fn bitor(self, rhs: Self) -> Self {\n+        match (self, rhs) {\n+            (Alignment::Packed, _) => Alignment::Packed,\n+            (Alignment::AbiAligned, a) => a,\n+        }\n+    }\n+}\n+\n+impl Alignment {\n+    pub fn from_packed(packed: bool) -> Self {\n+        if packed {\n+            Alignment::Packed\n+        } else {\n+            Alignment::AbiAligned\n+        }\n+    }\n+\n+    pub fn to_align(self) -> Option<u32> {\n+        match self {\n+            Alignment::Packed => Some(1),\n+            Alignment::AbiAligned => None,\n+        }\n+    }\n+\n+    pub fn min_with(self, align: u32) -> Option<u32> {\n+        match self {\n+            Alignment::Packed => Some(1),\n+            Alignment::AbiAligned => Some(align),\n+        }\n+    }\n+}\n+\n #[derive(Copy, Clone, Debug)]\n pub struct LvalueRef<'tcx> {\n     /// Pointer to the contents of the lvalue\n@@ -39,25 +81,38 @@ pub struct LvalueRef<'tcx> {\n \n     /// Monomorphized type of this lvalue, including variant information\n     pub ty: LvalueTy<'tcx>,\n+\n+    /// Whether this lvalue is known to be aligned according to its layout\n+    pub alignment: Alignment,\n }\n \n impl<'a, 'tcx> LvalueRef<'tcx> {\n-    pub fn new_sized(llval: ValueRef, lvalue_ty: LvalueTy<'tcx>) -> LvalueRef<'tcx> {\n-        LvalueRef { llval: llval, llextra: ptr::null_mut(), ty: lvalue_ty }\n+    pub fn new_sized(llval: ValueRef, lvalue_ty: LvalueTy<'tcx>,\n+                     alignment: Alignment) -> LvalueRef<'tcx> {\n+        LvalueRef { llval: llval, llextra: ptr::null_mut(), ty: lvalue_ty, alignment: alignment }\n     }\n \n-    pub fn new_sized_ty(llval: ValueRef, ty: Ty<'tcx>) -> LvalueRef<'tcx> {\n-        LvalueRef::new_sized(llval, LvalueTy::from_ty(ty))\n+    pub fn new_sized_ty(llval: ValueRef, ty: Ty<'tcx>, alignment: Alignment) -> LvalueRef<'tcx> {\n+        LvalueRef::new_sized(llval, LvalueTy::from_ty(ty), alignment)\n     }\n \n-    pub fn new_unsized_ty(llval: ValueRef, llextra: ValueRef, ty: Ty<'tcx>) -> LvalueRef<'tcx> {\n+    pub fn new_unsized_ty(llval: ValueRef, llextra: ValueRef, ty: Ty<'tcx>, alignment: Alignment)\n+                          -> LvalueRef<'tcx> {\n         LvalueRef {\n             llval: llval,\n             llextra: llextra,\n             ty: LvalueTy::from_ty(ty),\n+            alignment: alignment,\n         }\n     }\n \n+    pub fn alloca(bcx: &Builder<'a, 'tcx>, ty: Ty<'tcx>, name: &str) -> LvalueRef<'tcx> {\n+        debug!(\"alloca({:?}: {:?})\", name, ty);\n+        let tmp = bcx.alloca(type_of::type_of(bcx.ccx, ty), name);\n+        assert!(!ty.has_param_types());\n+        Self::new_sized_ty(tmp, ty, Alignment::AbiAligned)\n+    }\n+\n     pub fn len(&self, ccx: &CrateContext<'a, 'tcx>) -> ValueRef {\n         let ty = self.ty.to_ty(ccx.tcx());\n         match ty.sty {\n@@ -81,10 +136,12 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n         fields: &Vec<Ty<'tcx>>,\n         ix: usize,\n         needs_cast: bool\n-    ) -> ValueRef {\n+    ) -> (ValueRef, Alignment) {\n         let fty = fields[ix];\n         let ccx = bcx.ccx;\n \n+        let alignment = self.alignment | Alignment::from_packed(st.packed);\n+\n         let ptr_val = if needs_cast {\n             let fields = st.field_index_by_increasing_offset().map(|i| {\n                 type_of::in_memory_type_of(ccx, fields[i])\n@@ -101,14 +158,14 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n         //   * Field is sized - pointer is properly aligned already\n         if st.offsets[ix] == layout::Size::from_bytes(0) || st.packed ||\n             bcx.ccx.shared().type_is_sized(fty) {\n-                return bcx.struct_gep(ptr_val, st.memory_index[ix] as usize);\n+                return (bcx.struct_gep(ptr_val, st.memory_index[ix] as usize), alignment);\n             }\n \n         // If the type of the last field is [T] or str, then we don't need to do\n         // any adjusments\n         match fty.sty {\n             ty::TySlice(..) | ty::TyStr => {\n-                return bcx.struct_gep(ptr_val, st.memory_index[ix] as usize);\n+                return (bcx.struct_gep(ptr_val, st.memory_index[ix] as usize), alignment);\n             }\n             _ => ()\n         }\n@@ -117,7 +174,7 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n         if !self.has_extra() {\n             debug!(\"Unsized field `{}`, of `{:?}` has no metadata for adjustment\",\n                 ix, Value(ptr_val));\n-            return bcx.struct_gep(ptr_val, ix);\n+            return (bcx.struct_gep(ptr_val, ix), alignment);\n         }\n \n         // We need to get the pointer manually now.\n@@ -163,11 +220,11 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n         // Finally, cast back to the type expected\n         let ll_fty = type_of::in_memory_type_of(bcx.ccx, fty);\n         debug!(\"struct_field_ptr: Field type is {:?}\", ll_fty);\n-        bcx.pointercast(byte_ptr, ll_fty.ptr_to())\n+        (bcx.pointercast(byte_ptr, ll_fty.ptr_to()), alignment)\n     }\n \n     /// Access a field, at a point when the value's case is known.\n-    pub fn trans_field_ptr(self, bcx: &Builder<'a, 'tcx>, ix: usize) -> ValueRef {\n+    pub fn trans_field_ptr(self, bcx: &Builder<'a, 'tcx>, ix: usize) -> (ValueRef, Alignment) {\n         let discr = match self.ty {\n             LvalueTy::Ty { .. } => 0,\n             LvalueTy::Downcast { variant_index, .. } => variant_index,\n@@ -186,17 +243,18 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n             layout::Vector { count, .. } => {\n                 assert_eq!(discr, 0);\n                 assert!((ix as u64) < count);\n-                bcx.struct_gep(self.llval, ix)\n+                (bcx.struct_gep(self.llval, ix), self.alignment)\n             }\n             layout::General { discr: d, ref variants, .. } => {\n                 let mut fields = adt::compute_fields(bcx.ccx, t, discr, false);\n                 fields.insert(0, d.to_ty(&bcx.tcx(), false));\n                 self.struct_field_ptr(bcx, &variants[discr], &fields, ix + 1, true)\n             }\n-            layout::UntaggedUnion { .. } => {\n+            layout::UntaggedUnion { ref variants } => {\n                 let fields = adt::compute_fields(bcx.ccx, t, 0, false);\n                 let ty = type_of::in_memory_type_of(bcx.ccx, fields[ix]);\n-                bcx.pointercast(self.llval, ty.ptr_to())\n+                (bcx.pointercast(self.llval, ty.ptr_to()),\n+                 self.alignment | Alignment::from_packed(variants.packed))\n             }\n             layout::RawNullablePointer { nndiscr, .. } |\n             layout::StructWrappedNullablePointer { nndiscr,  .. } if discr as u64 != nndiscr => {\n@@ -205,19 +263,19 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n                 // (e.d., Result of Either with (), as one side.)\n                 let ty = type_of::type_of(bcx.ccx, nullfields[ix]);\n                 assert_eq!(machine::llsize_of_alloc(bcx.ccx, ty), 0);\n-                bcx.pointercast(self.llval, ty.ptr_to())\n+                (bcx.pointercast(self.llval, ty.ptr_to()), Alignment::Packed)\n             }\n             layout::RawNullablePointer { nndiscr, .. } => {\n                 let nnty = adt::compute_fields(bcx.ccx, t, nndiscr as usize, false)[0];\n                 assert_eq!(ix, 0);\n                 assert_eq!(discr as u64, nndiscr);\n                 let ty = type_of::type_of(bcx.ccx, nnty);\n-                bcx.pointercast(self.llval, ty.ptr_to())\n+                (bcx.pointercast(self.llval, ty.ptr_to()), self.alignment)\n             }\n             layout::StructWrappedNullablePointer { ref nonnull, nndiscr, .. } => {\n                 assert_eq!(discr as u64, nndiscr);\n                 self.struct_field_ptr(bcx, &nonnull,\n-                    &adt::compute_fields(bcx.ccx, t, discr, false), ix, false)\n+                     &adt::compute_fields(bcx.ccx, t, discr, false), ix, false)\n             }\n             _ => bug!(\"element access in type without elements: {} represented as {:#?}\", t, l)\n         }\n@@ -250,7 +308,8 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n             mir::Lvalue::Static(def_id) => {\n                 let const_ty = self.monomorphized_lvalue_ty(lvalue);\n                 LvalueRef::new_sized(consts::get_static(ccx, def_id),\n-                                     LvalueTy::from_ty(const_ty))\n+                                     LvalueTy::from_ty(const_ty),\n+                                     Alignment::AbiAligned)\n             },\n             mir::Lvalue::Projection(box mir::Projection {\n                 ref base,\n@@ -264,18 +323,20 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 let (llptr, llextra) = match ptr.val {\n                     OperandValue::Immediate(llptr) => (llptr, ptr::null_mut()),\n                     OperandValue::Pair(llptr, llextra) => (llptr, llextra),\n-                    OperandValue::Ref(_) => bug!(\"Deref of by-Ref type {:?}\", ptr.ty)\n+                    OperandValue::Ref(..) => bug!(\"Deref of by-Ref type {:?}\", ptr.ty)\n                 };\n                 LvalueRef {\n                     llval: llptr,\n                     llextra: llextra,\n                     ty: projected_ty,\n+                    alignment: Alignment::AbiAligned,\n                 }\n             }\n             mir::Lvalue::Projection(ref projection) => {\n                 let tr_base = self.trans_lvalue(bcx, &projection.base);\n                 let projected_ty = tr_base.ty.projection_ty(tcx, &projection.elem);\n                 let projected_ty = self.monomorphize(&projected_ty);\n+                let align = tr_base.alignment;\n \n                 let project_index = |llindex| {\n                     let element = if let ty::TySlice(_) = tr_base.ty.to_ty(tcx).sty {\n@@ -285,10 +346,10 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                         let zero = common::C_uint(bcx.ccx, 0u64);\n                         bcx.inbounds_gep(tr_base.llval, &[zero, llindex])\n                     };\n-                    element\n+                    (element, align)\n                 };\n \n-                let (llprojected, llextra) = match projection.elem {\n+                let ((llprojected, align), llextra) = match projection.elem {\n                     mir::ProjectionElem::Deref => bug!(),\n                     mir::ProjectionElem::Field(ref field, _) => {\n                         let llextra = if self.ccx.shared().type_is_sized(projected_ty.to_ty(tcx)) {\n@@ -318,7 +379,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                     }\n                     mir::ProjectionElem::Subslice { from, to } => {\n                         let llindex = C_uint(bcx.ccx, from);\n-                        let llbase = project_index(llindex);\n+                        let (llbase, align) = project_index(llindex);\n \n                         let base_ty = tr_base.ty.to_ty(bcx.tcx());\n                         match base_ty.sty {\n@@ -328,25 +389,26 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                                 let base_ty = self.monomorphized_lvalue_ty(lvalue);\n                                 let llbasety = type_of::type_of(bcx.ccx, base_ty).ptr_to();\n                                 let llbase = bcx.pointercast(llbase, llbasety);\n-                                (llbase, ptr::null_mut())\n+                                ((llbase, align), ptr::null_mut())\n                             }\n                             ty::TySlice(..) => {\n                                 assert!(tr_base.llextra != ptr::null_mut());\n                                 let lllen = bcx.sub(tr_base.llextra,\n                                                     C_uint(bcx.ccx, from+to));\n-                                (llbase, lllen)\n+                                ((llbase, align), lllen)\n                             }\n                             _ => bug!(\"unexpected type {:?} in Subslice\", base_ty)\n                         }\n                     }\n                     mir::ProjectionElem::Downcast(..) => {\n-                        (tr_base.llval, tr_base.llextra)\n+                        ((tr_base.llval, align), tr_base.llextra)\n                     }\n                 };\n                 LvalueRef {\n                     llval: llprojected,\n                     llextra: llextra,\n                     ty: projected_ty,\n+                    alignment: align,\n                 }\n             }\n         };\n@@ -357,6 +419,8 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n     // Perform an action using the given Lvalue.\n     // If the Lvalue is an empty LocalRef::Operand, then a temporary stack slot\n     // is created first, then used as an operand to update the Lvalue.\n+    //\n+    // FIXME: this is only called from transmute; please remove it.\n     pub fn with_lvalue_ref<F, U>(&mut self, bcx: &Builder<'a, 'tcx>,\n                                  lvalue: &mir::Lvalue<'tcx>, f: F) -> U\n     where F: FnOnce(&mut Self, LvalueRef<'tcx>) -> U\n@@ -367,10 +431,9 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 LocalRef::Operand(None) => {\n                     let lvalue_ty = self.monomorphized_lvalue_ty(lvalue);\n                     assert!(!lvalue_ty.has_erasable_regions());\n-                    let lltemp = bcx.alloca_ty(lvalue_ty, \"lvalue_temp\");\n-                    let lvalue = LvalueRef::new_sized(lltemp, LvalueTy::from_ty(lvalue_ty));\n+                    let lvalue = LvalueRef::alloca(bcx, lvalue_ty, \"lvalue_temp\");\n                     let ret = f(self, lvalue);\n-                    let op = self.trans_load(bcx, lvalue.llval, lvalue_ty);\n+                    let op = self.trans_load(bcx, lvalue.llval, lvalue.alignment, lvalue_ty);\n                     self.locals[index] = LocalRef::Operand(Some(op));\n                     ret\n                 }\n@@ -381,7 +444,8 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                     if common::type_is_zero_size(bcx.ccx, ty) {\n                         // Pass an undef pointer as no stores can actually occur.\n                         let llptr = C_undef(type_of(bcx.ccx, ty).ptr_to());\n-                        f(self, LvalueRef::new_sized(llptr, LvalueTy::from_ty(ty)))\n+                        f(self, LvalueRef::new_sized(llptr, LvalueTy::from_ty(ty),\n+                                                     Alignment::AbiAligned))\n                     } else {\n                         bug!(\"Lvalue local already set\");\n                     }"}, {"sha": "e017c8f2532e4a98591f8d74c6248a0461e6361f", "filename": "src/librustc_trans/mir/mod.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/09825de61bb4e9a339b3c6759d73ebb4c0b6c7b1/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09825de61bb4e9a339b3c6759d73ebb4c0b6c7b1/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fmod.rs?ref=09825de61bb4e9a339b3c6759d73ebb4c0b6c7b1", "patch": "@@ -38,7 +38,7 @@ use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n pub use self::constant::trans_static_initializer;\n \n use self::analyze::CleanupKind;\n-use self::lvalue::LvalueRef;\n+use self::lvalue::{Alignment, LvalueRef};\n use rustc::mir::traversal;\n \n use self::operand::{OperandRef, OperandValue};\n@@ -269,8 +269,7 @@ pub fn trans_mir<'a, 'tcx: 'a>(\n \n                 debug!(\"alloc: {:?} ({}) -> lvalue\", local, name);\n                 assert!(!ty.has_erasable_regions());\n-                let lltemp = bcx.alloca_ty(ty, &name.as_str());\n-                let lvalue = LvalueRef::new_sized(lltemp, LvalueTy::from_ty(ty));\n+                let lvalue = LvalueRef::alloca(&bcx, ty, &name.as_str());\n                 if dbg {\n                     let (scope, span) = mircx.debug_loc(source_info);\n                     declare_local(&bcx, &mircx.debug_context, name, ty, scope,\n@@ -283,12 +282,12 @@ pub fn trans_mir<'a, 'tcx: 'a>(\n                 if local == mir::RETURN_POINTER && mircx.fn_ty.ret.is_indirect() {\n                     debug!(\"alloc: {:?} (return pointer) -> lvalue\", local);\n                     let llretptr = llvm::get_param(llfn, 0);\n-                    LocalRef::Lvalue(LvalueRef::new_sized(llretptr, LvalueTy::from_ty(ty)))\n+                    LocalRef::Lvalue(LvalueRef::new_sized(llretptr, LvalueTy::from_ty(ty),\n+                                                          Alignment::AbiAligned))\n                 } else if lvalue_locals.contains(local.index()) {\n                     debug!(\"alloc: {:?} -> lvalue\", local);\n                     assert!(!ty.has_erasable_regions());\n-                    let lltemp = bcx.alloca_ty(ty, &format!(\"{:?}\", local));\n-                    LocalRef::Lvalue(LvalueRef::new_sized(lltemp, LvalueTy::from_ty(ty)))\n+                    LocalRef::Lvalue(LvalueRef::alloca(&bcx, ty,  &format!(\"{:?}\", local)))\n                 } else {\n                     // If this is an immediate local, we do not create an\n                     // alloca in advance. Instead we wait until we see the\n@@ -388,9 +387,9 @@ fn arg_local_refs<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n                 _ => bug!(\"spread argument isn't a tuple?!\")\n             };\n \n-            let lltemp = bcx.alloca_ty(arg_ty, &format!(\"arg{}\", arg_index));\n+            let lvalue = LvalueRef::alloca(bcx, arg_ty, &format!(\"arg{}\", arg_index));\n             for (i, &tupled_arg_ty) in tupled_arg_tys.iter().enumerate() {\n-                let dst = bcx.struct_gep(lltemp, i);\n+                let dst = bcx.struct_gep(lvalue.llval, i);\n                 let arg = &mircx.fn_ty.args[idx];\n                 idx += 1;\n                 if common::type_is_fat_ptr(bcx.ccx, tupled_arg_ty) {\n@@ -409,7 +408,7 @@ fn arg_local_refs<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n             // we can create one debuginfo entry for the argument.\n             arg_scope.map(|scope| {\n                 let variable_access = VariableAccess::DirectVariable {\n-                    alloca: lltemp\n+                    alloca: lvalue.llval\n                 };\n                 declare_local(\n                     bcx,\n@@ -422,7 +421,7 @@ fn arg_local_refs<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n                 );\n             });\n \n-            return LocalRef::Lvalue(LvalueRef::new_sized(lltemp, LvalueTy::from_ty(arg_ty)));\n+            return LocalRef::Lvalue(lvalue);\n         }\n \n         let arg = &mircx.fn_ty.args[idx];\n@@ -469,21 +468,21 @@ fn arg_local_refs<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n             };\n             return LocalRef::Operand(Some(operand.unpack_if_pair(bcx)));\n         } else {\n-            let lltemp = bcx.alloca_ty(arg_ty, &format!(\"arg{}\", arg_index));\n+            let lltemp = LvalueRef::alloca(bcx, arg_ty, &format!(\"arg{}\", arg_index));\n             if common::type_is_fat_ptr(bcx.ccx, arg_ty) {\n                 // we pass fat pointers as two words, but we want to\n                 // represent them internally as a pointer to two words,\n                 // so make an alloca to store them in.\n                 let meta = &mircx.fn_ty.args[idx];\n                 idx += 1;\n-                arg.store_fn_arg(bcx, &mut llarg_idx, base::get_dataptr(bcx, lltemp));\n-                meta.store_fn_arg(bcx, &mut llarg_idx, base::get_meta(bcx, lltemp));\n+                arg.store_fn_arg(bcx, &mut llarg_idx, base::get_dataptr(bcx, lltemp.llval));\n+                meta.store_fn_arg(bcx, &mut llarg_idx, base::get_meta(bcx, lltemp.llval));\n             } else  {\n                 // otherwise, arg is passed by value, so make a\n                 // temporary and store it there\n-                arg.store_fn_arg(bcx, &mut llarg_idx, lltemp);\n+                arg.store_fn_arg(bcx, &mut llarg_idx, lltemp.llval);\n             }\n-            lltemp\n+            lltemp.llval\n         };\n         arg_scope.map(|scope| {\n             // Is this a regular argument?\n@@ -573,7 +572,8 @@ fn arg_local_refs<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n                 );\n             }\n         });\n-        LocalRef::Lvalue(LvalueRef::new_sized(llval, LvalueTy::from_ty(arg_ty)))\n+        LocalRef::Lvalue(LvalueRef::new_sized(llval, LvalueTy::from_ty(arg_ty),\n+                                              Alignment::AbiAligned))\n     }).collect()\n }\n "}, {"sha": "cb77fcbbff85dbea7f015394b73f77cc494d202f", "filename": "src/librustc_trans/mir/operand.rs", "status": "modified", "additions": 26, "deletions": 15, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/09825de61bb4e9a339b3c6759d73ebb4c0b6c7b1/src%2Flibrustc_trans%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09825de61bb4e9a339b3c6759d73ebb4c0b6c7b1/src%2Flibrustc_trans%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Foperand.rs?ref=09825de61bb4e9a339b3c6759d73ebb4c0b6c7b1", "patch": "@@ -10,6 +10,7 @@\n \n use llvm::ValueRef;\n use rustc::ty::Ty;\n+use rustc::ty::layout::Layout;\n use rustc::mir;\n use rustc_data_structures::indexed_vec::Idx;\n \n@@ -23,6 +24,7 @@ use type_::Type;\n use std::fmt;\n \n use super::{MirContext, LocalRef};\n+use super::lvalue::Alignment;\n \n /// The representation of a Rust value. The enum variant is in fact\n /// uniquely determined by the value's type, but is kept as a\n@@ -31,7 +33,7 @@ use super::{MirContext, LocalRef};\n pub enum OperandValue {\n     /// A reference to the actual operand. The data is guaranteed\n     /// to be valid for the operand's lifetime.\n-    Ref(ValueRef),\n+    Ref(ValueRef, Alignment),\n     /// A single LLVM value.\n     Immediate(ValueRef),\n     /// A pair of immediate LLVM values. Used by fat pointers too.\n@@ -58,9 +60,9 @@ pub struct OperandRef<'tcx> {\n impl<'tcx> fmt::Debug for OperandRef<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match self.val {\n-            OperandValue::Ref(r) => {\n-                write!(f, \"OperandRef(Ref({:?}) @ {:?})\",\n-                       Value(r), self.ty)\n+            OperandValue::Ref(r, align) => {\n+                write!(f, \"OperandRef(Ref({:?}, {:?}) @ {:?})\",\n+                       Value(r), align, self.ty)\n             }\n             OperandValue::Immediate(i) => {\n                 write!(f, \"OperandRef(Immediate({:?}) @ {:?})\",\n@@ -137,27 +139,33 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n     pub fn trans_load(&mut self,\n                       bcx: &Builder<'a, 'tcx>,\n                       llval: ValueRef,\n+                      align: Alignment,\n                       ty: Ty<'tcx>)\n                       -> OperandRef<'tcx>\n     {\n         debug!(\"trans_load: {:?} @ {:?}\", Value(llval), ty);\n \n         let val = if common::type_is_fat_ptr(bcx.ccx, ty) {\n-            let (lldata, llextra) = base::load_fat_ptr(bcx, llval, ty);\n+            let (lldata, llextra) = base::load_fat_ptr(bcx, llval, align, ty);\n             OperandValue::Pair(lldata, llextra)\n         } else if common::type_is_imm_pair(bcx.ccx, ty) {\n+            let f_align = match *bcx.ccx.layout_of(ty) {\n+                Layout::Univariant { ref variant, .. } =>\n+                    Alignment::from_packed(variant.packed) | align,\n+                _ => align\n+            };\n             let [a_ty, b_ty] = common::type_pair_fields(bcx.ccx, ty).unwrap();\n             let a_ptr = bcx.struct_gep(llval, 0);\n             let b_ptr = bcx.struct_gep(llval, 1);\n \n             OperandValue::Pair(\n-                base::load_ty(bcx, a_ptr, a_ty),\n-                base::load_ty(bcx, b_ptr, b_ty)\n+                base::load_ty(bcx, a_ptr, f_align, a_ty),\n+                base::load_ty(bcx, b_ptr, f_align, b_ty)\n             )\n         } else if common::type_is_immediate(bcx.ccx, ty) {\n-            OperandValue::Immediate(base::load_ty(bcx, llval, ty))\n+            OperandValue::Immediate(base::load_ty(bcx, llval, align, ty))\n         } else {\n-            OperandValue::Ref(llval)\n+            OperandValue::Ref(llval, align)\n         };\n \n         OperandRef { val: val, ty: ty }\n@@ -212,7 +220,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n         // out from their home\n         let tr_lvalue = self.trans_lvalue(bcx, lvalue);\n         let ty = tr_lvalue.ty.to_ty(bcx.tcx());\n-        self.trans_load(bcx, tr_lvalue.llval, ty)\n+        self.trans_load(bcx, tr_lvalue.llval, tr_lvalue.alignment, ty)\n     }\n \n     pub fn trans_operand(&mut self,\n@@ -230,9 +238,9 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n             mir::Operand::Constant(ref constant) => {\n                 let val = self.trans_constant(bcx, constant);\n                 let operand = val.to_operand(bcx.ccx);\n-                if let OperandValue::Ref(ptr) = operand.val {\n+                if let OperandValue::Ref(ptr, align) = operand.val {\n                     // If this is a OperandValue::Ref to an immediate constant, load it.\n-                    self.trans_load(bcx, ptr, operand.ty)\n+                    self.trans_load(bcx, ptr, align, operand.ty)\n                 } else {\n                     operand\n                 }\n@@ -243,16 +251,19 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n     pub fn store_operand(&mut self,\n                          bcx: &Builder<'a, 'tcx>,\n                          lldest: ValueRef,\n-                         operand: OperandRef<'tcx>,\n-                         align: Option<u32>) {\n+                         align: Option<u32>,\n+                         operand: OperandRef<'tcx>) {\n         debug!(\"store_operand: operand={:?}, align={:?}\", operand, align);\n         // Avoid generating stores of zero-sized values, because the only way to have a zero-sized\n         // value is through `undef`, and store itself is useless.\n         if common::type_is_zero_size(bcx.ccx, operand.ty) {\n             return;\n         }\n         match operand.val {\n-            OperandValue::Ref(r) => base::memcpy_ty(bcx, lldest, r, operand.ty, align),\n+            OperandValue::Ref(r, Alignment::Packed) =>\n+                base::memcpy_ty(bcx, lldest, r, operand.ty, Some(1)),\n+            OperandValue::Ref(r, Alignment::AbiAligned) =>\n+                base::memcpy_ty(bcx, lldest, r, operand.ty, align),\n             OperandValue::Immediate(s) => {\n                 bcx.store(base::from_immediate(bcx, s), lldest, align);\n             }"}, {"sha": "be74e30ec741d99a90f040422e43cba8579274e7", "filename": "src/librustc_trans/mir/rvalue.rs", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/09825de61bb4e9a339b3c6759d73ebb4c0b6c7b1/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09825de61bb4e9a339b3c6759d73ebb4c0b6c7b1/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Frvalue.rs?ref=09825de61bb4e9a339b3c6759d73ebb4c0b6c7b1", "patch": "@@ -33,7 +33,7 @@ use Disr;\n use super::MirContext;\n use super::constant::const_scalar_checked_binop;\n use super::operand::{OperandRef, OperandValue};\n-use super::lvalue::{LvalueRef};\n+use super::lvalue::LvalueRef;\n \n impl<'a, 'tcx> MirContext<'a, 'tcx> {\n     pub fn trans_rvalue(&mut self,\n@@ -50,7 +50,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                let tr_operand = self.trans_operand(&bcx, operand);\n                // FIXME: consider not copying constants through stack. (fixable by translating\n                // constants into OperandValue::Ref, why don\u2019t we do that yet if we don\u2019t?)\n-               self.store_operand(&bcx, dest.llval, tr_operand, None);\n+               self.store_operand(&bcx, dest.llval, dest.alignment.to_align(), tr_operand);\n                bcx\n            }\n \n@@ -61,7 +61,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                     // into-coerce of a thin pointer to a fat pointer - just\n                     // use the operand path.\n                     let (bcx, temp) = self.trans_rvalue_operand(bcx, rvalue);\n-                    self.store_operand(&bcx, dest.llval, temp, None);\n+                    self.store_operand(&bcx, dest.llval, dest.alignment.to_align(), temp);\n                     return bcx;\n                 }\n \n@@ -81,13 +81,15 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                         // index into the struct, and this case isn't\n                         // important enough for it.\n                         debug!(\"trans_rvalue: creating ugly alloca\");\n-                        let lltemp = bcx.alloca_ty(operand.ty, \"__unsize_temp\");\n-                        base::store_ty(&bcx, llval, lltemp, operand.ty);\n-                        lltemp\n+                        let scratch = LvalueRef::alloca(&bcx, operand.ty, \"__unsize_temp\");\n+                        base::store_ty(&bcx, llval, scratch.llval, scratch.alignment, operand.ty);\n+                        scratch\n+                    }\n+                    OperandValue::Ref(llref, align) => {\n+                        LvalueRef::new_sized_ty(llref, operand.ty, align)\n                     }\n-                    OperandValue::Ref(llref) => llref\n                 };\n-                base::coerce_unsized_into(&bcx, llref, operand.ty, dest.llval, cast_ty);\n+                base::coerce_unsized_into(&bcx, &llref, &dest);\n                 bcx\n             }\n \n@@ -97,7 +99,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 let size = C_uint(bcx.ccx, size);\n                 let base = base::get_dataptr(&bcx, dest.llval);\n                 tvec::slice_for_each(&bcx, base, tr_elem.ty, size, |bcx, llslot| {\n-                    self.store_operand(bcx, llslot, tr_elem, None);\n+                    self.store_operand(bcx, llslot, dest.alignment.to_align(), tr_elem);\n                 })\n             }\n \n@@ -111,15 +113,15 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                             let op = self.trans_operand(&bcx, operand);\n                             // Do not generate stores and GEPis for zero-sized fields.\n                             if !common::type_is_zero_size(bcx.ccx, op.ty) {\n-                                let mut val = LvalueRef::new_sized(dest.llval, dest.ty);\n+                                let mut val = LvalueRef::new_sized(dest.llval, dest.ty, dest.alignment);\n                                 let field_index = active_field_index.unwrap_or(i);\n                                 val.ty = LvalueTy::Downcast {\n                                     adt_def: adt_def,\n                                     substs: self.monomorphize(&substs),\n                                     variant_index: disr.0 as usize,\n                                 };\n-                                let lldest_i = val.trans_field_ptr(&bcx, field_index);\n-                                self.store_operand(&bcx, lldest_i, op, None);\n+                                let (lldest_i, align) = val.trans_field_ptr(&bcx, field_index);\n+                                self.store_operand(&bcx, lldest_i, align.to_align(), op);\n                             }\n                         }\n                     },\n@@ -131,6 +133,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                         } else {\n                             None\n                         };\n+                        let alignment = dest.alignment;\n                         for (i, operand) in operands.iter().enumerate() {\n                             let op = self.trans_operand(&bcx, operand);\n                             // Do not generate stores and GEPis for zero-sized fields.\n@@ -144,7 +147,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                                     i\n                                 };\n                                 let dest = bcx.gepi(dest.llval, &[0, i]);\n-                                self.store_operand(&bcx, dest, op, None);\n+                                self.store_operand(&bcx, dest, alignment.to_align(), op);\n                             }\n                         }\n                     }\n@@ -169,7 +172,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n             _ => {\n                 assert!(rvalue_creates_operand(rvalue));\n                 let (bcx, temp) = self.trans_rvalue_operand(bcx, rvalue);\n-                self.store_operand(&bcx, dest.llval, temp, None);\n+                self.store_operand(&bcx, dest.llval, dest.alignment.to_align(), temp);\n                 bcx\n             }\n         }\n@@ -228,7 +231,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                                     operand.ty, cast_ty);\n                                 OperandValue::Pair(lldata, llextra)\n                             }\n-                            OperandValue::Ref(_) => {\n+                            OperandValue::Ref(..) => {\n                                 bug!(\"by-ref operand {:?} in trans_rvalue_operand\",\n                                      operand);\n                             }"}, {"sha": "db2cd3b41656d3026d310bb08051d4073209475a", "filename": "src/test/codegen/packed.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/09825de61bb4e9a339b3c6759d73ebb4c0b6c7b1/src%2Ftest%2Fcodegen%2Fpacked.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09825de61bb4e9a339b3c6759d73ebb4c0b6c7b1/src%2Ftest%2Fcodegen%2Fpacked.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fpacked.rs?ref=09825de61bb4e9a339b3c6759d73ebb4c0b6c7b1", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags: -C no-prepopulate-passes\n+\n+#![crate_type = \"lib\"]\n+\n+#[repr(packed)]\n+pub struct Packed {\n+    dealign: u8,\n+    data: u32\n+}\n+\n+// CHECK-LABEL: @write_pkd\n+#[no_mangle]\n+pub fn write_pkd(pkd: &mut Packed) -> u32 {\n+// CHECK: %{{.*}} = load i32, i32* %{{.*}}, align 1\n+// CHECK: store i32 42, i32* %{{.*}}, align 1\n+    let result = pkd.data;\n+    pkd.data = 42;\n+    result\n+}"}]}