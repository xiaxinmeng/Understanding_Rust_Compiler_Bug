{"sha": "ed02b156c5599c827de9d4fe04fa08b0a3fee102", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVkMDJiMTU2YzU1OTljODI3ZGU5ZDRmZTA0ZmEwOGIwYTNmZWUxMDI=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-06-03T15:41:16Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-06-10T11:08:13Z"}, "message": "replace some mode comparisons by more readable function call, rename some Mode, and more comments", "tree": {"sha": "cf63e9eea155509314f786fb831b5c3614d8ffa8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cf63e9eea155509314f786fb831b5c3614d8ffa8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ed02b156c5599c827de9d4fe04fa08b0a3fee102", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ed02b156c5599c827de9d4fe04fa08b0a3fee102", "html_url": "https://github.com/rust-lang/rust/commit/ed02b156c5599c827de9d4fe04fa08b0a3fee102", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ed02b156c5599c827de9d4fe04fa08b0a3fee102/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ea21a8a38f4a9e6b820524e9e908adc3ba16dc99", "url": "https://api.github.com/repos/rust-lang/rust/commits/ea21a8a38f4a9e6b820524e9e908adc3ba16dc99", "html_url": "https://github.com/rust-lang/rust/commit/ea21a8a38f4a9e6b820524e9e908adc3ba16dc99"}], "stats": {"total": 118, "additions": 72, "deletions": 46}, "files": [{"sha": "53f3f226b24bc1769c946081a081957855f909c1", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 72, "deletions": 46, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/ed02b156c5599c827de9d4fe04fa08b0a3fee102/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed02b156c5599c827de9d4fe04fa08b0a3fee102/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=ed02b156c5599c827de9d4fe04fa08b0a3fee102", "patch": "@@ -35,11 +35,26 @@ use super::promote_consts::{self, Candidate, TempState};\n /// What kind of item we are in.\n #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n enum Mode {\n-    Const,\n+    /// A `static` item.\n     Static,\n+    /// A `static mut` item.\n     StaticMut,\n+    /// A `const fn` item.\n     ConstFn,\n-    Fn\n+    /// A `const` item or an anonymous constant (e.g. in array lengths).\n+    Const,\n+    /// Other type of `fn`.\n+    NonConstFn,\n+}\n+\n+impl Mode {\n+    /// Determine whether we are running in \"const context\".  \"const context\" refers\n+    /// to code type-checked according to the rules of the \"const type system\":\n+    /// the bodies of const/static items and `const fn`.\n+    #[inline]\n+    fn requires_const_checking(self) -> bool {\n+        self != Mode::NonConstFn\n+    }\n }\n \n impl fmt::Display for Mode {\n@@ -48,7 +63,7 @@ impl fmt::Display for Mode {\n             Mode::Const => write!(f, \"constant\"),\n             Mode::Static | Mode::StaticMut => write!(f, \"static\"),\n             Mode::ConstFn => write!(f, \"constant function\"),\n-            Mode::Fn => write!(f, \"function\")\n+            Mode::NonConstFn => write!(f, \"function\")\n         }\n     }\n }\n@@ -135,10 +150,10 @@ enum ValueSource<'a, 'tcx> {\n     },\n }\n \n-/// A \"qualif\" is a way to lookg for something \"bad\" in the MIR that would prevent\n-/// proper const evaluation.  So `return true` means \"I found something bad, no reason\n-/// to go on searching\".  `false` is only returned if we definitely cannot find anything\n-/// bad anywhere.\n+/// A \"qualif\"(-ication) is a way to look for something \"bad\" in the MIR that would disqualify some\n+/// code for promotion or prevent it from evaluating at compile time. So `return true` means\n+/// \"I found something bad, no reason to go on searching\". `false` is only returned if we\n+/// definitely cannot find anything bad anywhere.\n ///\n /// The default implementations proceed structurally.\n trait Qualif {\n@@ -291,9 +306,11 @@ trait Qualif {\n     }\n }\n \n-/// Constant containing interior mutability (UnsafeCell).\n+/// Constant containing interior mutability (`UnsafeCell<T>`).\n /// This must be ruled out to make sure that evaluating the constant at compile-time\n-/// and run-time would produce the same result.\n+/// and run-time would produce the same result. In particular, promotion of temporaries\n+/// must not change program behavior; if the promoted could be written to, that would\n+/// be a problem.\n struct HasMutInterior;\n \n impl Qualif for HasMutInterior {\n@@ -322,10 +339,10 @@ impl Qualif for HasMutInterior {\n                             _ => return true,\n                         }\n                     } else if let ty::Array(_, len) = ty.sty {\n-                        // FIXME(eddyb) the `cx.mode == Mode::Fn` condition\n+                        // FIXME(eddyb) the `cx.mode == Mode::NonConstFn` condition\n                         // seems unnecessary, given that this is merely a ZST.\n                         match len.assert_usize(cx.tcx) {\n-                            Some(0) if cx.mode == Mode::Fn => {},\n+                            Some(0) if cx.mode == Mode::NonConstFn => {},\n                             _ => return true,\n                         }\n                     } else {\n@@ -351,9 +368,10 @@ impl Qualif for HasMutInterior {\n     }\n }\n \n-/// Constant containing an ADT that implements Drop.\n-/// This must be ruled out because we cannot run `Drop` during compile-time\n-/// as that might not be a `const fn`.\n+/// Constant containing an ADT that implements `Drop`.\n+/// This must be ruled out (a) because we cannot run `Drop` during compile-time\n+/// as that might not be a `const fn`, and (b) because implicit promotion would\n+/// remove side-effects that occur as part of dropping that value.\n struct NeedsDrop;\n \n impl Qualif for NeedsDrop {\n@@ -376,11 +394,12 @@ impl Qualif for NeedsDrop {\n     }\n }\n \n-/// Not promotable at all - non-`const fn` calls, asm!,\n+/// Not promotable at all - non-`const fn` calls, `asm!`,\n /// pointer comparisons, ptr-to-int casts, etc.\n /// Inside a const context all constness rules apply, so promotion simply has to follow the regular\n /// constant rules (modulo interior mutability or `Drop` rules which are handled `HasMutInterior`\n-/// and `NeedsDrop` respectively).\n+/// and `NeedsDrop` respectively). Basically this duplicates the checks that the const-checking\n+/// visitor enforces by emitting errors when working in const context.\n struct IsNotPromotable;\n \n impl Qualif for IsNotPromotable {\n@@ -411,9 +430,10 @@ impl Qualif for IsNotPromotable {\n             ProjectionElem::Index(_) => {}\n \n             ProjectionElem::Field(..) => {\n-                if cx.mode == Mode::Fn {\n+                if cx.mode == Mode::NonConstFn {\n                     let base_ty = proj.base.ty(cx.body, cx.tcx).ty;\n                     if let Some(def) = base_ty.ty_adt_def() {\n+                        // No promotion of union field accesses.\n                         if def.is_union() {\n                             return true;\n                         }\n@@ -427,7 +447,7 @@ impl Qualif for IsNotPromotable {\n \n     fn in_rvalue(cx: &ConstCx<'_, 'tcx>, rvalue: &Rvalue<'tcx>) -> bool {\n         match *rvalue {\n-            Rvalue::Cast(CastKind::Misc, ref operand, cast_ty) if cx.mode == Mode::Fn => {\n+            Rvalue::Cast(CastKind::Misc, ref operand, cast_ty) if cx.mode == Mode::NonConstFn => {\n                 let operand_ty = operand.ty(cx.body, cx.tcx);\n                 let cast_in = CastTy::from_ty(operand_ty).expect(\"bad input type for cast\");\n                 let cast_out = CastTy::from_ty(cast_ty).expect(\"bad output type for cast\");\n@@ -441,7 +461,7 @@ impl Qualif for IsNotPromotable {\n                 }\n             }\n \n-            Rvalue::BinaryOp(op, ref lhs, _) if cx.mode == Mode::Fn => {\n+            Rvalue::BinaryOp(op, ref lhs, _) if cx.mode == Mode::NonConstFn => {\n                 if let ty::RawPtr(_) | ty::FnPtr(..) = lhs.ty(cx.body, cx.tcx).sty {\n                     assert!(op == BinOp::Eq || op == BinOp::Ne ||\n                             op == BinOp::Le || op == BinOp::Lt ||\n@@ -524,9 +544,9 @@ impl Qualif for IsNotPromotable {\n \n /// Refers to temporaries which cannot be promoted *implicitly*.\n /// Explicit promotion happens e.g. for constant arguments declared via `rustc_args_required_const`.\n-/// Implicit promotion has almost the same rules, except that it does not happen if `const fn`\n-/// calls are involved. The call may be perfectly alright at runtime, but fail at compile time\n-/// e.g. due to addresses being compared inside the function.\n+/// Implicit promotion has almost the same rules, except that disallows `const fn` except for\n+/// those marked `#[rustc_promotable]`. This is to avoid changing a legitimate run-time operation\n+/// into a failing compile-time operation e.g. due to addresses being compared inside the function.\n struct IsNotImplicitlyPromotable;\n \n impl Qualif for IsNotImplicitlyPromotable {\n@@ -538,7 +558,7 @@ impl Qualif for IsNotImplicitlyPromotable {\n         args: &[Operand<'tcx>],\n         _return_ty: Ty<'tcx>,\n     ) -> bool {\n-        if cx.mode == Mode::Fn {\n+        if cx.mode == Mode::NonConstFn {\n             if let ty::FnDef(def_id, _) = callee.ty(cx.body, cx.tcx).sty {\n                 // Never promote runtime `const fn` calls of\n                 // functions without `#[rustc_promotable]`.\n@@ -602,8 +622,8 @@ impl ConstCx<'_, 'tcx> {\n /// Checks MIR for const-correctness, using `ConstCx`\n /// for value qualifications, and accumulates writes of\n /// rvalue/call results to locals, in `local_qualif`.\n-/// For functions (constant or not), it also records\n-/// candidates for promotion in `promotion_candidates`.\n+/// It also records candidates for promotion in `promotion_candidates`,\n+/// both in functions and const/static items.\n struct Checker<'a, 'tcx> {\n     cx: ConstCx<'a, 'tcx>,\n \n@@ -687,7 +707,7 @@ impl<'a, 'tcx> Checker<'a, 'tcx> {\n     // slightly pointless (even with feature-gating).\n     fn not_const(&mut self) {\n         unleash_miri!(self);\n-        if self.mode != Mode::Fn {\n+        if self.mode.requires_const_checking() {\n             let mut err = struct_span_err!(\n                 self.tcx.sess,\n                 self.span,\n@@ -722,7 +742,7 @@ impl<'a, 'tcx> Checker<'a, 'tcx> {\n                 qualifs[HasMutInterior] = false;\n                 qualifs[IsNotPromotable] = true;\n \n-                if self.mode != Mode::Fn {\n+                if self.mode.requires_const_checking() {\n                     if let BorrowKind::Mut { .. } = kind {\n                         let mut err = struct_span_err!(self.tcx.sess,  self.span, E0017,\n                                                        \"references in {}s may only refer \\\n@@ -752,7 +772,7 @@ impl<'a, 'tcx> Checker<'a, 'tcx> {\n \n                 // We might have a candidate for promotion.\n                 let candidate = Candidate::Ref(location);\n-                // We can only promote interior borrows of promotable temps.\n+                // Start by traversing to the \"base\", with non-deref projections removed.\n                 let mut place = place;\n                 while let Place::Projection(ref proj) = *place {\n                     if proj.elem == ProjectionElem::Deref {\n@@ -761,6 +781,10 @@ impl<'a, 'tcx> Checker<'a, 'tcx> {\n                     place = &proj.base;\n                 }\n                 debug!(\"qualify_consts: promotion candidate: place={:?}\", place);\n+                // We can only promote interior borrows of promotable temps (non-temps\n+                // don't get promoted anyway).\n+                // (If we bailed out of the loop due to a `Deref` above, we will definitely\n+                // not enter the conditional here.)\n                 if let Place::Base(PlaceBase::Local(local)) = *place {\n                     if self.body.local_kind(local) == LocalKind::Temp {\n                         debug!(\"qualify_consts: promotion candidate: local={:?}\", local);\n@@ -771,10 +795,11 @@ impl<'a, 'tcx> Checker<'a, 'tcx> {\n                         // `HasMutInterior`, from a type that does, e.g.:\n                         // `let _: &'static _ = &(Cell::new(1), 2).1;`\n                         let mut local_qualifs = self.qualifs_in_local(local);\n-                        local_qualifs[HasMutInterior] = false;\n-                        // Make sure there is no reason to prevent promotion.\n+                        // Any qualifications, except HasMutInterior (see above), disqualify\n+                        // from promotion.\n                         // This is, in particular, the \"implicit promotion\" version of\n                         // the check making sure that we don't run drop glue during const-eval.\n+                        local_qualifs[HasMutInterior] = false;\n                         if !local_qualifs.0.iter().any(|&qualif| qualif) {\n                             debug!(\"qualify_consts: promotion candidate: {:?}\", candidate);\n                             self.promotion_candidates.push(candidate);\n@@ -821,7 +846,7 @@ impl<'a, 'tcx> Checker<'a, 'tcx> {\n         debug!(\"store to {:?} {:?}\", kind, index);\n \n         // Only handle promotable temps in non-const functions.\n-        if self.mode == Mode::Fn {\n+        if self.mode == Mode::NonConstFn {\n             if kind != LocalKind::Temp ||\n                !self.temp_promotion_state[index].is_promotable() {\n                 return;\n@@ -956,7 +981,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n                         .get_attrs(*def_id)\n                         .iter()\n                         .any(|attr| attr.check_name(sym::thread_local)) {\n-                    if self.mode != Mode::Fn {\n+                    if self.mode.requires_const_checking() {\n                         span_err!(self.tcx.sess, self.span, E0625,\n                                     \"thread-local statics cannot be \\\n                                     accessed at compile-time\");\n@@ -980,7 +1005,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n                 }\n                 unleash_miri!(self);\n \n-                if self.mode != Mode::Fn {\n+                if self.mode.requires_const_checking() {\n                     let mut err = struct_span_err!(self.tcx.sess, self.span, E0013,\n                                                     \"{}s cannot refer to statics, use \\\n                                                     a constant instead\", self.mode);\n@@ -1018,7 +1043,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n                 }\n                 let base_ty = proj.base.ty(self.body, self.tcx).ty;\n                 match self.mode {\n-                    Mode::Fn => {},\n+                    Mode::NonConstFn => {},\n                     _ => {\n                         if let ty::RawPtr(_) = base_ty.sty {\n                             if !self.tcx.features().const_raw_ptr_deref {\n@@ -1054,7 +1079,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n                                 }\n                             },\n \n-                            | Mode::Fn\n+                            | Mode::NonConstFn\n                             | Mode::Static\n                             | Mode::StaticMut\n                             | Mode::Const\n@@ -1144,7 +1169,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n                 let cast_out = CastTy::from_ty(cast_ty).expect(\"bad output type for cast\");\n                 match (cast_in, cast_out) {\n                     (CastTy::Ptr(_), CastTy::Int(_)) |\n-                    (CastTy::FnPtr, CastTy::Int(_)) if self.mode != Mode::Fn => {\n+                    (CastTy::FnPtr, CastTy::Int(_)) if self.mode != Mode::NonConstFn => {\n                         unleash_miri!(self);\n                         if !self.tcx.features().const_raw_ptr_to_usize_cast {\n                             // in const fn and constants require the feature gate\n@@ -1171,7 +1196,9 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n                             op == BinOp::Offset);\n \n                     unleash_miri!(self);\n-                    if self.mode != Mode::Fn && !self.tcx.features().const_compare_raw_pointers {\n+                    if self.mode.requires_const_checking() &&\n+                        !self.tcx.features().const_compare_raw_pointers\n+                    {\n                         // require the feature gate inside constants and const fn\n                         // FIXME: make it unsafe to use these operations\n                         emit_feature_err(\n@@ -1187,7 +1214,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n \n             Rvalue::NullaryOp(NullOp::Box, _) => {\n                 unleash_miri!(self);\n-                if self.mode != Mode::Fn {\n+                if self.mode.requires_const_checking() {\n                     let mut err = struct_span_err!(self.tcx.sess, self.span, E0010,\n                                                    \"allocations are not allowed in {}s\", self.mode);\n                     err.span_label(self.span, format!(\"allocation not allowed in {}s\", self.mode));\n@@ -1232,8 +1259,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n                                 // special intrinsic that can be called diretly without an intrinsic\n                                 // feature gate needs a language feature gate\n                                 \"transmute\" => {\n-                                    // never promote transmute calls\n-                                    if self.mode != Mode::Fn {\n+                                    if self.mode.requires_const_checking() {\n                                         // const eval transmute calls only with the feature gate\n                                         if !self.tcx.features().const_transmute {\n                                             emit_feature_err(\n@@ -1256,7 +1282,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n                         }\n                         _ => {\n                             // In normal functions no calls are feature-gated.\n-                            if self.mode != Mode::Fn {\n+                            if self.mode.requires_const_checking() {\n                                 let unleash_miri = self\n                                     .tcx\n                                     .sess\n@@ -1315,7 +1341,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n                     }\n                 }\n                 ty::FnPtr(_) => {\n-                    if self.mode != Mode::Fn {\n+                    if self.mode.requires_const_checking() {\n                         let mut err = self.tcx.sess.struct_span_err(\n                             self.span,\n                             &format!(\"function pointers are not allowed in const fn\"));\n@@ -1374,7 +1400,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n             self.super_terminator_kind(kind, location);\n \n             // Deny *any* live drops anywhere other than functions.\n-            if self.mode != Mode::Fn {\n+            if self.mode.requires_const_checking() {\n                 unleash_miri!(self);\n                 // HACK(eddyb): emulate a bit of dataflow analysis,\n                 // conservatively, that drop elaboration will do.\n@@ -1485,12 +1511,12 @@ impl MirPass for QualifyAndPromoteConstants {\n         let id = tcx.hir().as_local_hir_id(def_id).unwrap();\n         let mut const_promoted_temps = None;\n         let mode = match tcx.hir().body_owner_kind_by_hir_id(id) {\n-            hir::BodyOwnerKind::Closure => Mode::Fn,\n+            hir::BodyOwnerKind::Closure => Mode::NonConstFn,\n             hir::BodyOwnerKind::Fn => {\n                 if tcx.is_const_fn(def_id) {\n                     Mode::ConstFn\n                 } else {\n-                    Mode::Fn\n+                    Mode::NonConstFn\n                 }\n             }\n             hir::BodyOwnerKind::Const => {\n@@ -1502,7 +1528,7 @@ impl MirPass for QualifyAndPromoteConstants {\n         };\n \n         debug!(\"run_pass: mode={:?}\", mode);\n-        if mode == Mode::Fn || mode == Mode::ConstFn {\n+        if mode == Mode::NonConstFn || mode == Mode::ConstFn {\n             // This is ugly because Checker holds onto mir,\n             // which can't be mutated until its scope ends.\n             let (temps, candidates) = {"}]}