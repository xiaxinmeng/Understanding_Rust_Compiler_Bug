{"sha": "967c3880d8f4e458cbad83f5df580e00c142aca4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk2N2MzODgwZDhmNGU0NThjYmFkODNmNWRmNTgwZTAwYzE0MmFjYTQ=", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2016-05-27T08:50:03Z"}, "committer": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2016-05-27T08:50:03Z"}, "message": "Rollup merge of #33815 - carols10cents:trait-documentation-clarifications, r=steveklabnik\n\nTrait documentation clarifications\n\nHi! I've felt a bit of friction lately in figuring out how to write custom implementations of the `derive`able traits, so I decided to add to the docs :)\n\nThe docs for `Copy` are already excellent-- clear, useful sections that I only reordered a bit-- they're now:\n\n* General explanation\n* When can my type be `Copy`?\n* When can my type _not_ be `Copy`?\n* When should my type be `Copy`?\n* Derivable\n* How can I implement `Copy`?\n\nI didn't add all these sections for all the traits, but I did make sure all the derivable traits had a consistent \"Derivable\" section that explained what the derived implementation does and a \"How can I implement\" section that has an example.\n\nPlease check me for correctness-- I tried to do research to make sure I was saying accurate things but I'm still learning! \u2764\ufe0f I'd also love suggestions on information to add that is still missing-- I think these traits are important and deserve to have awesome docs!", "tree": {"sha": "6c72bc365984919dabfd56ced7f99e2ac4bee0b5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6c72bc365984919dabfd56ced7f99e2ac4bee0b5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/967c3880d8f4e458cbad83f5df580e00c142aca4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/967c3880d8f4e458cbad83f5df580e00c142aca4", "html_url": "https://github.com/rust-lang/rust/commit/967c3880d8f4e458cbad83f5df580e00c142aca4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/967c3880d8f4e458cbad83f5df580e00c142aca4/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "575149561e863a37b1a123851d1906684a49368d", "url": "https://api.github.com/repos/rust-lang/rust/commits/575149561e863a37b1a123851d1906684a49368d", "html_url": "https://github.com/rust-lang/rust/commit/575149561e863a37b1a123851d1906684a49368d"}, {"sha": "1e809f57a45a187a2a8c49d4d93ec64c089873ca", "url": "https://api.github.com/repos/rust-lang/rust/commits/1e809f57a45a187a2a8c49d4d93ec64c089873ca", "html_url": "https://github.com/rust-lang/rust/commit/1e809f57a45a187a2a8c49d4d93ec64c089873ca"}], "stats": {"total": 413, "additions": 313, "deletions": 100}, "files": [{"sha": "e8cd36f3cd70bf13d751790bcbefdb2e9a16a937", "filename": "src/libcore/clone.rs", "status": "modified", "additions": 30, "deletions": 2, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/967c3880d8f4e458cbad83f5df580e00c142aca4/src%2Flibcore%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/967c3880d8f4e458cbad83f5df580e00c142aca4/src%2Flibcore%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fclone.rs?ref=967c3880d8f4e458cbad83f5df580e00c142aca4", "patch": "@@ -46,14 +46,42 @@\n \n use marker::Sized;\n \n-/// A common trait for cloning an object.\n+/// A common trait for the ability to explicitly duplicate an object.\n ///\n-/// This trait can be used with `#[derive]`.\n+/// Differs from `Copy` in that `Copy` is implicit and extremely inexpensive, while\n+/// `Clone` is always explicit and may or may not be expensive. In order to enforce\n+/// these characteristics, Rust does not allow you to reimplement `Copy`, but you\n+/// may reimplement `Clone` and run arbitrary code.\n+///\n+/// Since `Clone` is more general than `Copy`, you can automatically make anything\n+/// `Copy` be `Clone` as well.\n+///\n+/// ## Derivable\n+///\n+/// This trait can be used with `#[derive]` if all fields are `Clone`. The `derive`d\n+/// implementation of `clone()` calls `clone()` on each field.\n+///\n+/// ## How can I implement `Clone`?\n ///\n /// Types that are `Copy` should have a trivial implementation of `Clone`. More formally:\n /// if `T: Copy`, `x: T`, and `y: &T`, then `let x = y.clone();` is equivalent to `let x = *y;`.\n /// Manual implementations should be careful to uphold this invariant; however, unsafe code\n /// must not rely on it to ensure memory safety.\n+///\n+/// An example is an array holding more than 32 elements of a type that is `Clone`; the standard\n+/// library only implements `Clone` up until arrays of size 32. In this case, the implementation of\n+/// `Clone` cannot be `derive`d, but can be implemented as:\n+///\n+/// ```\n+/// #[derive(Copy)]\n+/// struct Stats {\n+///    frequencies: [i32; 100],\n+/// }\n+///\n+/// impl Clone for Stats {\n+///     fn clone(&self) -> Stats { *self }\n+/// }\n+/// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Clone : Sized {\n     /// Returns a copy of the value."}, {"sha": "8764766b2ef8675a04ea69be0b5bc3209fa162c1", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 164, "deletions": 4, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/967c3880d8f4e458cbad83f5df580e00c142aca4/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/967c3880d8f4e458cbad83f5df580e00c142aca4/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=967c3880d8f4e458cbad83f5df580e00c142aca4", "patch": "@@ -53,12 +53,43 @@ use option::Option::{self, Some};\n /// symmetrically and transitively: if `T: PartialEq<U>` and `U: PartialEq<V>`\n /// then `U: PartialEq<T>` and `T: PartialEq<V>`.\n ///\n+/// ## Derivable\n+///\n+/// This trait can be used with `#[derive]`. When `derive`d on structs, two\n+/// instances are equal if all fields are equal, and not equal if any fields\n+/// are not equal. When `derive`d on enums, each variant is equal to itself\n+/// and not equal to the other variants.\n+///\n+/// ## How can I implement `PartialEq`?\n+///\n /// PartialEq only requires the `eq` method to be implemented; `ne` is defined\n /// in terms of it by default. Any manual implementation of `ne` *must* respect\n /// the rule that `eq` is a strict inverse of `ne`; that is, `!(a == b)` if and\n /// only if `a != b`.\n ///\n-/// This trait can be used with `#[derive]`.\n+/// An example implementation for a domain in which two books are considered\n+/// the same book if their ISBN matches, even if the formats differ:\n+///\n+/// ```\n+/// enum BookFormat { Paperback, Hardback, Ebook }\n+/// struct Book {\n+///     isbn: i32,\n+///     format: BookFormat,\n+/// }\n+///\n+/// impl PartialEq for Book {\n+///     fn eq(&self, other: &Book) -> bool {\n+///         self.isbn == other.isbn\n+///     }\n+/// }\n+///\n+/// let b1 = Book { isbn: 3, format: BookFormat::Paperback };\n+/// let b2 = Book { isbn: 3, format: BookFormat::Ebook };\n+/// let b3 = Book { isbn: 10, format: BookFormat::Paperback };\n+///\n+/// assert!(b1 == b2);\n+/// assert!(b1 != b3);\n+/// ```\n ///\n /// # Examples\n ///\n@@ -96,7 +127,32 @@ pub trait PartialEq<Rhs: ?Sized = Self> {\n /// This property cannot be checked by the compiler, and therefore `Eq` implies\n /// `PartialEq`, and has no extra methods.\n ///\n-/// This trait can be used with `#[derive]`.\n+/// ## Derivable\n+///\n+/// This trait can be used with `#[derive]`. When `derive`d, because `Eq` has\n+/// no extra methods, it is only informing the compiler that this is an\n+/// equivalence relation rather than a partial equivalence relation. Note that\n+/// the `derive` strategy requires all fields are `PartialEq`, which isn't\n+/// always desired.\n+///\n+/// ## How can I implement `Eq`?\n+///\n+/// If you cannot use the `derive` strategy, specify that your type implements\n+/// `Eq`, which has no methods:\n+///\n+/// ```\n+/// enum BookFormat { Paperback, Hardback, Ebook }\n+/// struct Book {\n+///     isbn: i32,\n+///     format: BookFormat,\n+/// }\n+/// impl PartialEq for Book {\n+///     fn eq(&self, other: &Book) -> bool {\n+///         self.isbn == other.isbn\n+///     }\n+/// }\n+/// impl Eq for Book {}\n+/// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Eq: PartialEq<Self> {\n     // FIXME #13101: this method is used solely by #[deriving] to\n@@ -190,8 +246,49 @@ impl Ordering {\n /// - total and antisymmetric: exactly one of `a < b`, `a == b` or `a > b` is true; and\n /// - transitive, `a < b` and `b < c` implies `a < c`. The same must hold for both `==` and `>`.\n ///\n+/// ## Derivable\n+///\n /// This trait can be used with `#[derive]`. When `derive`d, it will produce a lexicographic\n /// ordering based on the top-to-bottom declaration order of the struct's members.\n+///\n+/// ## How can I implement `Ord`?\n+///\n+/// `Ord` requires that the type also be `PartialOrd` and `Eq` (which requires `PartialEq`).\n+///\n+/// Then you must define an implementation for `cmp()`. You may find it useful to use\n+/// `cmp()` on your type's fields.\n+///\n+/// Here's an example where you want to sort people by height only, disregarding `id`\n+/// and `name`:\n+///\n+/// ```\n+/// use std::cmp::Ordering;\n+///\n+/// #[derive(Eq)]\n+/// struct Person {\n+///     id: u32,\n+///     name: String,\n+///     height: u32,\n+/// }\n+///\n+/// impl Ord for Person {\n+///     fn cmp(&self, other: &Person) -> Ordering {\n+///         self.height.cmp(&other.height)\n+///     }\n+/// }\n+///\n+/// impl PartialOrd for Person {\n+///     fn partial_cmp(&self, other: &Person) -> Option<Ordering> {\n+///         Some(self.cmp(other))\n+///     }\n+/// }\n+///\n+/// impl PartialEq for Person {\n+///     fn eq(&self, other: &Person) -> bool {\n+///         self.height == other.height\n+///     }\n+/// }\n+/// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Ord: Eq + PartialOrd<Self> {\n     /// This method returns an `Ordering` between `self` and `other`.\n@@ -242,15 +339,78 @@ impl PartialOrd for Ordering {\n /// transitively: if `T: PartialOrd<U>` and `U: PartialOrd<V>` then `U: PartialOrd<T>` and `T:\n /// PartialOrd<V>`.\n ///\n+/// ## Derivable\n+///\n+/// This trait can be used with `#[derive]`. When `derive`d, it will produce a lexicographic\n+/// ordering based on the top-to-bottom declaration order of the struct's members.\n+///\n+/// ## How can I implement `Ord`?\n+///\n /// PartialOrd only requires implementation of the `partial_cmp` method, with the others generated\n /// from default implementations.\n ///\n /// However it remains possible to implement the others separately for types which do not have a\n /// total order. For example, for floating point numbers, `NaN < 0 == false` and `NaN >= 0 ==\n /// false` (cf. IEEE 754-2008 section 5.11).\n ///\n-/// This trait can be used with `#[derive]`. When `derive`d, it will produce an ordering\n-/// based on the top-to-bottom declaration order of the struct's members.\n+/// `PartialOrd` requires your type to be `PartialEq`.\n+///\n+/// If your type is `Ord`, you can implement `partial_cmp()` by using `cmp()`:\n+///\n+/// ```\n+/// use std::cmp::Ordering;\n+///\n+/// #[derive(Eq)]\n+/// struct Person {\n+///     id: u32,\n+///     name: String,\n+///     height: u32,\n+/// }\n+///\n+/// impl PartialOrd for Person {\n+///     fn partial_cmp(&self, other: &Person) -> Option<Ordering> {\n+///         Some(self.cmp(other))\n+///     }\n+/// }\n+///\n+/// impl Ord for Person {\n+///     fn cmp(&self, other: &Person) -> Ordering {\n+///         self.height.cmp(&other.height)\n+///     }\n+/// }\n+///\n+/// impl PartialEq for Person {\n+///     fn eq(&self, other: &Person) -> bool {\n+///         self.height == other.height\n+///     }\n+/// }\n+/// ```\n+///\n+/// You may also find it useful to use `partial_cmp()` on your type`s fields. Here\n+/// is an example of `Person` types who have a floating-point `height` field that\n+/// is the only field to be used for sorting:\n+///\n+/// ```\n+/// use std::cmp::Ordering;\n+///\n+/// struct Person {\n+///     id: u32,\n+///     name: String,\n+///     height: f64,\n+/// }\n+///\n+/// impl PartialOrd for Person {\n+///     fn partial_cmp(&self, other: &Person) -> Option<Ordering> {\n+///         self.height.partial_cmp(&other.height)\n+///     }\n+/// }\n+///\n+/// impl PartialEq for Person {\n+///     fn eq(&self, other: &Person) -> bool {\n+///         self.height == other.height\n+///     }\n+/// }\n+/// ```\n ///\n /// # Examples\n ///"}, {"sha": "485ddae07fbff93b4723c3b9ffe8c45f93028e6c", "filename": "src/libcore/default.rs", "status": "modified", "additions": 66, "deletions": 72, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/967c3880d8f4e458cbad83f5df580e00c142aca4/src%2Flibcore%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/967c3880d8f4e458cbad83f5df580e00c142aca4/src%2Flibcore%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fdefault.rs?ref=967c3880d8f4e458cbad83f5df580e00c142aca4", "patch": "@@ -9,85 +9,79 @@\n // except according to those terms.\n \n //! The `Default` trait for types which may have meaningful default values.\n-//!\n-//! Sometimes, you want to fall back to some kind of default value, and\n-//! don't particularly care what it is. This comes up often with `struct`s\n-//! that define a set of options:\n-//!\n-//! ```\n-//! # #[allow(dead_code)]\n-//! struct SomeOptions {\n-//!     foo: i32,\n-//!     bar: f32,\n-//! }\n-//! ```\n-//!\n-//! How can we define some default values? You can use `Default`:\n-//!\n-//! ```\n-//! # #[allow(dead_code)]\n-//! #[derive(Default)]\n-//! struct SomeOptions {\n-//!     foo: i32,\n-//!     bar: f32,\n-//! }\n-//!\n-//!\n-//! fn main() {\n-//!     let options: SomeOptions = Default::default();\n-//! }\n-//! ```\n-//!\n-//! Now, you get all of the default values. Rust implements `Default` for various primitives types.\n-//! If you have your own type, you need to implement `Default` yourself:\n-//!\n-//! ```\n-//! # #![allow(dead_code)]\n-//! enum Kind {\n-//!     A,\n-//!     B,\n-//!     C,\n-//! }\n-//!\n-//! impl Default for Kind {\n-//!     fn default() -> Kind { Kind::A }\n-//! }\n-//!\n-//! #[derive(Default)]\n-//! struct SomeOptions {\n-//!     foo: i32,\n-//!     bar: f32,\n-//!     baz: Kind,\n-//! }\n-//!\n-//!\n-//! fn main() {\n-//!     let options: SomeOptions = Default::default();\n-//! }\n-//! ```\n-//!\n-//! If you want to override a particular option, but still retain the other defaults:\n-//!\n-//! ```\n-//! # #[allow(dead_code)]\n-//! # #[derive(Default)]\n-//! # struct SomeOptions {\n-//! #     foo: i32,\n-//! #     bar: f32,\n-//! # }\n-//! fn main() {\n-//!     let options = SomeOptions { foo: 42, ..Default::default() };\n-//! }\n-//! ```\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use marker::Sized;\n \n /// A trait for giving a type a useful default value.\n ///\n-/// A struct can derive default implementations of `Default` for basic types using\n-/// `#[derive(Default)]`.\n+/// Sometimes, you want to fall back to some kind of default value, and\n+/// don't particularly care what it is. This comes up often with `struct`s\n+/// that define a set of options:\n+///\n+/// ```\n+/// # #[allow(dead_code)]\n+/// struct SomeOptions {\n+///     foo: i32,\n+///     bar: f32,\n+/// }\n+/// ```\n+///\n+/// How can we define some default values? You can use `Default`:\n+///\n+/// ```\n+/// # #[allow(dead_code)]\n+/// #[derive(Default)]\n+/// struct SomeOptions {\n+///     foo: i32,\n+///     bar: f32,\n+/// }\n+///\n+///\n+/// fn main() {\n+///     let options: SomeOptions = Default::default();\n+/// }\n+/// ```\n+///\n+/// Now, you get all of the default values. Rust implements `Default` for various primitives types.\n+///\n+/// If you want to override a particular option, but still retain the other defaults:\n+///\n+/// ```\n+/// # #[allow(dead_code)]\n+/// # #[derive(Default)]\n+/// # struct SomeOptions {\n+/// #     foo: i32,\n+/// #     bar: f32,\n+/// # }\n+/// fn main() {\n+///     let options = SomeOptions { foo: 42, ..Default::default() };\n+/// }\n+/// ```\n+///\n+/// ## Derivable\n+///\n+/// This trait can be used with `#[derive]` if all of the type's fields implement\n+/// `Default`. When `derive`d, it will use the default value for each field's type.\n+///\n+/// ## How can I implement `Default`?\n+///\n+/// Provide an implementation for the `default()` method that returns the value of\n+/// your type that should be the default:\n+///\n+/// ```\n+/// # #![allow(dead_code)]\n+/// enum Kind {\n+///     A,\n+///     B,\n+///     C,\n+/// }\n+///\n+/// impl Default for Kind {\n+///     fn default() -> Kind { Kind::A }\n+/// }\n+/// ```\n ///\n /// # Examples\n ///"}, {"sha": "6579e5dab543245ccd56934ec787974880d00adf", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/967c3880d8f4e458cbad83f5df580e00c142aca4/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/967c3880d8f4e458cbad83f5df580e00c142aca4/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=967c3880d8f4e458cbad83f5df580e00c142aca4", "patch": "@@ -318,7 +318,11 @@ impl<'a> Display for Arguments<'a> {\n ///\n /// [module]: ../../std/fmt/index.html\n ///\n-/// This trait can be used with `#[derive]`.\n+/// This trait can be used with `#[derive]` if all fields implement `Debug`. When\n+/// `derive`d for structs, it will use the name of the `struct`, then `{`, then a\n+/// comma-separated list of each field's name and `Debug` value, then `}`. For\n+/// `enum`s, it will use the name of the variant and, if applicable, `(`, then the\n+/// `Debug` values of the fields, then `)`.\n ///\n /// # Examples\n ///"}, {"sha": "051eb974895ce7a59031e36c1edd33bc677050eb", "filename": "src/libcore/hash/mod.rs", "status": "modified", "additions": 28, "deletions": 2, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/967c3880d8f4e458cbad83f5df580e00c142aca4/src%2Flibcore%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/967c3880d8f4e458cbad83f5df580e00c142aca4/src%2Flibcore%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash%2Fmod.rs?ref=967c3880d8f4e458cbad83f5df580e00c142aca4", "patch": "@@ -38,7 +38,7 @@\n //! ```\n //!\n //! If you need more control over how a value is hashed, you need to implement\n-//! the trait `Hash`:\n+//! the `Hash` trait:\n //!\n //! ```rust\n //! use std::hash::{Hash, Hasher, SipHasher};\n@@ -97,7 +97,33 @@ mod sip;\n /// In other words, if two keys are equal, their hashes should also be equal.\n /// `HashMap` and `HashSet` both rely on this behavior.\n ///\n-/// This trait can be used with `#[derive]`.\n+/// ## Derivable\n+///\n+/// This trait can be used with `#[derive]` if all fields implement `Hash`.\n+/// When `derive`d, the resulting hash will be the combination of the values\n+/// from calling `.hash()` on each field.\n+///\n+/// ## How can I implement `Hash`?\n+///\n+/// If you need more control over how a value is hashed, you need to implement\n+/// the `Hash` trait:\n+///\n+/// ```\n+/// use std::hash::{Hash, Hasher};\n+///\n+/// struct Person {\n+///     id: u32,\n+///     name: String,\n+///     phone: u64,\n+/// }\n+///\n+/// impl Hash for Person {\n+///     fn hash<H: Hasher>(&self, state: &mut H) {\n+///         self.id.hash(state);\n+///         self.phone.hash(state);\n+///     }\n+/// }\n+/// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Hash {\n     /// Feeds this value into the state given, updating the hasher as necessary."}, {"sha": "c18d230be31af9db758feb8e6f6de9f439d80ba3", "filename": "src/libcore/marker.rs", "status": "modified", "additions": 20, "deletions": 19, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/967c3880d8f4e458cbad83f5df580e00c142aca4/src%2Flibcore%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/967c3880d8f4e458cbad83f5df580e00c142aca4/src%2Flibcore%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmarker.rs?ref=967c3880d8f4e458cbad83f5df580e00c142aca4", "patch": "@@ -136,6 +136,26 @@ pub trait Unsize<T: ?Sized> {\n /// the trait `Copy` may not be implemented for this type; field `points` does not implement `Copy`\n /// ```\n ///\n+/// ## When can my type _not_ be `Copy`?\n+///\n+/// Some types can't be copied safely. For example, copying `&mut T` would create an aliased\n+/// mutable reference, and copying `String` would result in two attempts to free the same buffer.\n+///\n+/// Generalizing the latter case, any type implementing `Drop` can't be `Copy`, because it's\n+/// managing some resource besides its own `size_of::<T>()` bytes.\n+///\n+/// ## When should my type be `Copy`?\n+///\n+/// Generally speaking, if your type _can_ implement `Copy`, it should. There's one important thing\n+/// to consider though: if you think your type may _not_ be able to implement `Copy` in the future,\n+/// then it might be prudent to not implement `Copy`. This is because removing `Copy` is a breaking\n+/// change: that second example would fail to compile if we made `Foo` non-`Copy`.\n+///\n+/// ## Derivable\n+///\n+/// This trait can be used with `#[derive]` if all of its components implement `Copy` and the type\n+/// implements `Clone`. The implementation will copy the bytes of each field using `memcpy`.\n+///\n /// ## How can I implement `Copy`?\n ///\n /// There are two ways to implement `Copy` on your type:\n@@ -155,25 +175,6 @@ pub trait Unsize<T: ?Sized> {\n ///\n /// There is a small difference between the two: the `derive` strategy will also place a `Copy`\n /// bound on type parameters, which isn't always desired.\n-///\n-/// ## When can my type _not_ be `Copy`?\n-///\n-/// Some types can't be copied safely. For example, copying `&mut T` would create an aliased\n-/// mutable reference, and copying `String` would result in two attempts to free the same buffer.\n-///\n-/// Generalizing the latter case, any type implementing `Drop` can't be `Copy`, because it's\n-/// managing some resource besides its own `size_of::<T>()` bytes.\n-///\n-/// ## When should my type be `Copy`?\n-///\n-/// Generally speaking, if your type _can_ implement `Copy`, it should. There's one important thing\n-/// to consider though: if you think your type may _not_ be able to implement `Copy` in the future,\n-/// then it might be prudent to not implement `Copy`. This is because removing `Copy` is a breaking\n-/// change: that second example would fail to compile if we made `Foo` non-`Copy`.\n-///\n-/// # Derivable\n-///\n-/// This trait can be used with `#[derive]`.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[lang = \"copy\"]\n pub trait Copy : Clone {"}]}