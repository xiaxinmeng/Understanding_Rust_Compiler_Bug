{"sha": "00bb15bf726e0aa440557131224bdab77dd46682", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAwYmIxNWJmNzI2ZTBhYTQ0MDU1NzEzMTIyNGJkYWI3N2RkNDY2ODI=", "commit": {"author": {"name": "Vadim Chugunov", "email": "vadimcn@gmail.com", "date": "2013-06-11T01:34:51Z"}, "committer": {"name": "Vadim Chugunov", "email": "vadimcn@gmail.com", "date": "2013-06-17T15:41:24Z"}, "message": "Removed extraneous string allocations.\nMisc refactoring.", "tree": {"sha": "834ed9e3d8383e0d84bddaa18581bbbbfe4e352f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/834ed9e3d8383e0d84bddaa18581bbbbfe4e352f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/00bb15bf726e0aa440557131224bdab77dd46682", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/00bb15bf726e0aa440557131224bdab77dd46682", "html_url": "https://github.com/rust-lang/rust/commit/00bb15bf726e0aa440557131224bdab77dd46682", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/00bb15bf726e0aa440557131224bdab77dd46682/comments", "author": {"login": "vadimcn", "id": 3203809, "node_id": "MDQ6VXNlcjMyMDM4MDk=", "avatar_url": "https://avatars.githubusercontent.com/u/3203809?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vadimcn", "html_url": "https://github.com/vadimcn", "followers_url": "https://api.github.com/users/vadimcn/followers", "following_url": "https://api.github.com/users/vadimcn/following{/other_user}", "gists_url": "https://api.github.com/users/vadimcn/gists{/gist_id}", "starred_url": "https://api.github.com/users/vadimcn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vadimcn/subscriptions", "organizations_url": "https://api.github.com/users/vadimcn/orgs", "repos_url": "https://api.github.com/users/vadimcn/repos", "events_url": "https://api.github.com/users/vadimcn/events{/privacy}", "received_events_url": "https://api.github.com/users/vadimcn/received_events", "type": "User", "site_admin": false}, "committer": {"login": "vadimcn", "id": 3203809, "node_id": "MDQ6VXNlcjMyMDM4MDk=", "avatar_url": "https://avatars.githubusercontent.com/u/3203809?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vadimcn", "html_url": "https://github.com/vadimcn", "followers_url": "https://api.github.com/users/vadimcn/followers", "following_url": "https://api.github.com/users/vadimcn/following{/other_user}", "gists_url": "https://api.github.com/users/vadimcn/gists{/gist_id}", "starred_url": "https://api.github.com/users/vadimcn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vadimcn/subscriptions", "organizations_url": "https://api.github.com/users/vadimcn/orgs", "repos_url": "https://api.github.com/users/vadimcn/repos", "events_url": "https://api.github.com/users/vadimcn/events{/privacy}", "received_events_url": "https://api.github.com/users/vadimcn/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6db3302b354c47dba4463752e21c37049860b761", "url": "https://api.github.com/repos/rust-lang/rust/commits/6db3302b354c47dba4463752e21c37049860b761", "html_url": "https://github.com/rust-lang/rust/commit/6db3302b354c47dba4463752e21c37049860b761"}], "stats": {"total": 126, "additions": 50, "deletions": 76}, "files": [{"sha": "c0e7f6472a6b6c1291c2f1c1bdd152d878a941a8", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 50, "deletions": 76, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/00bb15bf726e0aa440557131224bdab77dd46682/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00bb15bf726e0aa440557131224bdab77dd46682/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=00bb15bf726e0aa440557131224bdab77dd46682", "patch": "@@ -75,11 +75,11 @@ struct _DebugContext {\n }\n \n /** Create new DebugContext */\n-pub fn mk_ctxt(llmod: ModuleRef, crate: ~str, intr: @ident_interner) -> DebugContext {\n+pub fn mk_ctxt(llmod: ModuleRef, crate: ~str) -> DebugContext {\n     debug!(\"mk_ctxt\");\n     let builder = unsafe { llvm::LLVMDIBuilderCreate(llmod) };\n     let dcx = @mut _DebugContext {\n-        names: new_namegen(intr),\n+        names: new_namegen(),\n         crate_file: crate,\n         builder: builder,\n         curr_loc: (0, 0),\n@@ -114,33 +114,9 @@ pub fn finalize(cx: @CrateContext) {\n     };\n }\n \n-fn filename_from_span(cx: @CrateContext, sp: codemap::span) -> ~str {\n-    /*bad*/copy cx.sess.codemap.lookup_char_pos(sp.lo).file.name\n-}\n-\n-//fn filename_from_span<'cx>(cx: &'cx CrateContext, sp: codemap::span) -> &'cx str {\n-//    let fname: &str = cx.sess.codemap.lookup_char_pos(sp.lo).file.name;\n-//  return fname;\n-//}\n-\n-fn get_file_path_and_dir(work_dir: &str, full_path: &str) -> (~str, ~str) {\n-    let full_path = \n-        if str::starts_with(full_path, work_dir) {\n-            str::slice(full_path, str::len(work_dir) + 1u,\n-                       str::len(full_path)).to_owned()\n-        } else {\n-            full_path.to_owned()\n-        };\n-    \n-    return (full_path, work_dir.to_owned());\n-}\n-\n fn create_compile_unit(cx: @CrateContext) {\n     let crate_name: &str = dbg_cx(cx).crate_file;\n-\n-    let (_, work_dir) = get_file_path_and_dir(\n-        cx.sess.working_dir.to_str(), crate_name);\n-        \n+    let work_dir = cx.sess.working_dir.to_str();\n     let producer = fmt!(\"rustc version %s\", env!(\"CFG_VERSION\"));\n     \n     do as_c_str(crate_name) |crate_name| {\n@@ -158,29 +134,33 @@ fn create_compile_unit(cx: @CrateContext) {\n fn create_file(cx: @CrateContext, full_path: &str) -> DIFile {\n     let dcx = dbg_cx(cx);\n     \n-    match dcx.created_files.find(&full_path.to_owned()) {\n+    match dcx.created_files.find_equiv(&full_path) {\n         Some(file_md) => return *file_md,\n         None => ()\n     }\n \n     debug!(\"create_file: %s\", full_path);\n     \n-    let (file_path, work_dir) =\n-        get_file_path_and_dir(cx.sess.working_dir.to_str(),\n-                              full_path);\n-\n+    let work_dir = cx.sess.working_dir.to_str();\n+    let file_name = \n+        if full_path.starts_with(work_dir) {\n+            full_path.slice(work_dir.len() + 1u, full_path.len())\n+        } else {\n+            full_path\n+        };\n+        \n     let file_md = \n-        do as_c_str(file_path) |file_path| {\n+        do as_c_str(file_name) |file_name| {\n         do as_c_str(work_dir) |work_dir| { unsafe {\n-            llvm::LLVMDIBuilderCreateFile(dcx.builder, file_path, work_dir)\n+            llvm::LLVMDIBuilderCreateFile(dcx.builder, file_name, work_dir)\n         }}};\n         \n     dcx.created_files.insert(full_path.to_owned(), file_md);\n     return file_md;\n }\n \n-fn line_from_span(cm: @codemap::CodeMap, sp: span) -> uint {\n-    cm.lookup_char_pos(sp.lo).line\n+fn span_start(cx: @CrateContext, span: span) -> codemap::Loc {\n+    return cx.sess.codemap.lookup_char_pos(span.lo);\n }\n \n fn create_block(bcx: block) -> DILexicalBlock {\n@@ -194,31 +174,29 @@ fn create_block(bcx: block) -> DILexicalBlock {\n           None => fail!()\n         }\n     }\n-    let sp = bcx.node_info.get().span;\n+    let span = bcx.node_info.get().span;\n     let id = bcx.node_info.get().id;\n     \n     match dcx.created_blocks.find(&id) {\n         Some(block) => return *block,\n         None => ()\n     }\n     \n-    debug!(\"create_block: %s\", bcx.sess().codemap.span_to_str(sp));\n-    \n-    let start = bcx.sess().codemap.lookup_char_pos(sp.lo);\n-    //let end = bcx.sess().codemap.lookup_char_pos(sp.hi);\n+    debug!(\"create_block: %s\", bcx.sess().codemap.span_to_str(span));\n     \n     let parent = match bcx.parent {\n         None => create_function(bcx.fcx),\n         Some(b) => create_block(b)\n     };\n-    \n-    let file_md = create_file(bcx.ccx(), start.file.name);\n+    let cx = bcx.ccx();\n+    let loc = span_start(cx, span);\n+    let file_md = create_file(cx, loc.file.name);\n     \n     let block_md = unsafe { \n         llvm::LLVMDIBuilderCreateLexicalBlock(\n             dcx.builder, \n             parent, file_md, \n-            start.line.to_int() as c_uint, start.col.to_int() as c_uint) \n+            loc.line as c_uint, loc.col.to_uint() as c_uint) \n     };\n     \n     dcx.created_blocks.insert(id, block_md);\n@@ -342,18 +320,16 @@ impl StructContext {\n }\n \n fn create_struct(cx: @CrateContext, t: ty::t, fields: ~[ty::field], span: span) -> DICompositeType {\n-    let fname = filename_from_span(cx, span);\n-    let file_md = create_file(cx, fname);\n-    let line = line_from_span(cx.sess.codemap, span);\n+    let loc = span_start(cx, span);\n+    let file_md = create_file(cx, loc.file.name);\n     \n-    let mut scx = StructContext::create(cx, file_md, ty_to_str(cx.tcx, t), line);\n+    let mut scx = StructContext::create(cx, file_md, ty_to_str(cx.tcx, t), loc.line);\n     for fields.each |field| {\n         let field_t = field.mt.ty;\n         let ty_md = create_ty(cx, field_t, span);\n         let (size, align) = size_and_align_of(cx, field_t);\n         scx.add_member(cx.sess.str_of(field.ident),\n-                   line_from_span(cx.sess.codemap, span),\n-                   size, align, ty_md);\n+                   loc.line, size, align, ty_md);\n     }\n     return scx.finalize();\n }\n@@ -371,25 +347,24 @@ fn voidptr(cx: @CrateContext) -> (DIDerivedType, uint, uint) {\n \n fn create_tuple(cx: @CrateContext, t: ty::t, elements: &[ty::t], span: span) -> DICompositeType {\n     let dcx = dbg_cx(cx);\n-    let fname = filename_from_span(cx, span);\n-    let file_md = create_file(cx, fname);\n+    let loc = span_start(cx, span);\n+    let file_md = create_file(cx, loc.file.name);\n \n     let name = (cx.sess.str_of((dcx.names)(\"tuple\"))).to_owned();\n     let mut scx = StructContext::create(cx, file_md, name, loc.line);\n            \n     for elements.each |element| {\n         let ty_md = create_ty(cx, *element, span);\n         let (size, align) = size_and_align_of(cx, *element);\n-        scx.add_member(\"\", line_from_span(cx.sess.codemap, span),\n-                   size, align, ty_md);\n+        scx.add_member(\"\", loc.line, size, align, ty_md);\n     }\n     return scx.finalize();\n }\n \n fn create_boxed_type(cx: @CrateContext, contents: ty::t,\n                      span: span, boxed: DIType) -> DICompositeType {\n-    let fname = filename_from_span(cx, span);\n-    let file_md = create_file(cx, fname);\n+    let loc = span_start(cx, span);\n+    let file_md = create_file(cx, loc.file.name);\n     let int_t = ty::mk_int();\n     let refcount_type = create_basic_type(cx, int_t, span);\n     let name = ty_to_str(cx.tcx, contents);\n@@ -412,8 +387,8 @@ fn create_fixed_vec(cx: @CrateContext, vec_t: ty::t, elem_t: ty::t,\n                     len: uint, span: span) -> DIType {\n     let dcx = dbg_cx(cx);\n     let elem_ty_md = create_ty(cx, elem_t, span);\n-    let fname = filename_from_span(cx, span);\n-    let file_md = create_file(cx, fname);\n+    let loc = span_start(cx, span);\n+    let file_md = create_file(cx, loc.file.name);\n     let (size, align) = size_and_align_of(cx, elem_t);\n \n     let subrange = unsafe { \n@@ -427,10 +402,10 @@ fn create_fixed_vec(cx: @CrateContext, vec_t: ty::t, elem_t: ty::t,\n }\n \n fn create_boxed_vec(cx: @CrateContext, vec_t: ty::t, elem_t: ty::t,\n-                    vec_ty_span: codemap::span) -> DICompositeType {\n+                    vec_ty_span: span) -> DICompositeType {\n     let dcx = dbg_cx(cx);\n-    let fname = filename_from_span(cx, vec_ty_span);\n-    let file_md = create_file(cx, fname);\n+    let loc = span_start(cx, vec_ty_span);\n+    let file_md = create_file(cx, loc.file.name);\n     let elem_ty_md = create_ty(cx, elem_t, vec_ty_span);\n     \n     let mut vec_scx = StructContext::create(cx, file_md, ty_to_str(cx.tcx, vec_t), 0);\n@@ -468,8 +443,8 @@ fn create_boxed_vec(cx: @CrateContext, vec_t: ty::t, elem_t: ty::t,\n }\n \n fn create_vec_slice(cx: @CrateContext, vec_t: ty::t, elem_t: ty::t, span: span) -> DICompositeType {\n-    let fname = filename_from_span(cx, span);\n-    let file_md = create_file(cx, fname);\n+    let loc = span_start(cx, span);\n+    let file_md = create_file(cx, loc.file.name);\n     let elem_ty_md = create_ty(cx, elem_t, span);\n     let uint_type = create_basic_type(cx, ty::mk_uint(), span);\n     let elem_ptr = create_pointer_type(cx, elem_t, span, elem_ty_md);\n@@ -485,8 +460,8 @@ fn create_vec_slice(cx: @CrateContext, vec_t: ty::t, elem_t: ty::t, span: span)\n fn create_fn_ty(cx: @CrateContext, fn_ty: ty::t, inputs: ~[ty::t], output: ty::t,\n                 span: span) -> DICompositeType {\n     let dcx = dbg_cx(cx);\n-    let fname = filename_from_span(cx, span);\n-    let file_md = create_file(cx, fname);\n+    let loc = span_start(cx, span);\n+    let file_md = create_file(cx, loc.file.name);\n     let (vp, _, _) = voidptr(cx);\n     let output_md = create_ty(cx, output, span);\n     let output_ptr_md = create_pointer_type(cx, output, span, output_md);\n@@ -593,7 +568,7 @@ pub fn create_local_var(bcx: block, local: @ast::local) -> DIVariable {\n     };\n     let name: &str = cx.sess.str_of(ident);\n     debug!(\"create_local_var: %s\", name);\n-\n+    \n     let loc = span_start(cx, local.span);\n     let ty = node_id_type(bcx, local.node.id);\n     let tymd = create_ty(cx, ty, local.node.ty.span);\n@@ -629,12 +604,12 @@ pub fn create_local_var(bcx: block, local: @ast::local) -> DIVariable {\n     return var_md;\n }\n \n-pub fn create_arg(bcx: block, arg: ast::arg, sp: span) -> Option<DIVariable> {\n+pub fn create_arg(bcx: block, arg: ast::arg, span: span) -> Option<DIVariable> {\n     debug!(\"create_arg\");\n     let fcx = bcx.fcx, cx = *fcx.ccx;\n     let dcx = dbg_cx(cx);\n \n-    let loc = cx.sess.codemap.lookup_char_pos(sp.lo);\n+    let loc = span_start(cx, span);\n     if \"<intrinsic>\" == loc.file.name {\n         return None;\n     }\n@@ -654,7 +629,7 @@ pub fn create_arg(bcx: block, arg: ast::arg, sp: span) -> Option<DIVariable> {\n             let ident = path.idents.last();\n             let name: &str = cx.sess.str_of(*ident);\n             let mdnode = do as_c_str(name) |name| { unsafe {\n-                llvm::LLVMDIBuilderCreateLocalVariable(dcx.builder,\n+                llvm::LLVMDIBuilderCreateLocalVariable(dcx.builder, \n                     ArgVariableTag as u32, context, name, \n                     filemd, loc.line as c_uint, tymd, false, 0, 0)\n                     // FIXME need to pass a real argument number\n@@ -681,16 +656,15 @@ fn set_debug_location(bcx: block, line: uint, col: uint) {\n     }\n }\n \n-pub fn update_source_pos(bcx: block, sp: span) {\n-    if !bcx.sess().opts.debuginfo || (*sp.lo == 0 && *sp.hi == 0) {\n+pub fn update_source_pos(bcx: block, span: span) {\n+    if !bcx.sess().opts.debuginfo || (*span.lo == 0 && *span.hi == 0) {\n         return;\n     }\n     \n-    debug!(\"update_source_pos: %s\", bcx.sess().codemap.span_to_str(sp));\n+    debug!(\"update_source_pos: %s\", bcx.sess().codemap.span_to_str(span));\n \n-    let cm = bcx.sess().codemap;\n-    let loc = cm.lookup_char_pos(sp.lo);\n     let cx = bcx.ccx();\n+    let loc = span_start(cx, span);\n     let mut dcx = dbg_cx(cx);\n     \n     let loc = (loc.line, loc.col.to_uint());\n@@ -706,7 +680,7 @@ pub fn create_function(fcx: fn_ctxt) -> DISubprogram {\n     let cx = *fcx.ccx;\n     let mut dcx = dbg_cx(cx);\n     let fcx = &mut *fcx;\n-    let sp = fcx.span.get();\n+    let span = fcx.span.get();\n \n     let (ident, ret_ty, id) = match cx.tcx.items.get_copy(&fcx.id) {\n       ast_map::node_item(item, _) => {\n@@ -739,7 +713,7 @@ pub fn create_function(fcx: fn_ctxt) -> DISubprogram {\n \n     debug!(\"create_function: %s, %s\", cx.sess.str_of(ident), cx.sess.codemap.span_to_str(span));\n \n-    let loc = cx.sess.codemap.lookup_char_pos(sp.lo);\n+    let loc = span_start(cx, span);\n     let file_md = create_file(cx, loc.file.name);\n \n     let ret_ty_md = if cx.sess.opts.extra_debuginfo {"}]}