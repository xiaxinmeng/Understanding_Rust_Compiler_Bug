{"sha": "d2ea3f25b53deac5785485ab5dfe5e6b3b893bf5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQyZWEzZjI1YjUzZGVhYzU3ODU0ODVhYjVkZmU1ZTZiM2I4OTNiZjU=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-03-30T10:19:02Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-03-30T10:19:02Z"}, "message": "Merge #3761\n\n3761: Append new match arms rather than replacing all of them r=matklad a=mattyhall\n\nThis means we now retain comments when filling in match arms. This fixes #3687. This is my first contribution so apologies if it needs a rethink! I think in particular the way I find the position to append to and remove_if_only_whitespace are a little hairy.\n\nCo-authored-by: Matthew Hall <matthew@quickbeam.me.uk>", "tree": {"sha": "b979afc6883c973d4b95765a292e6e5c8b819e96", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b979afc6883c973d4b95765a292e6e5c8b819e96"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d2ea3f25b53deac5785485ab5dfe5e6b3b893bf5", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJegceWCRBK7hj4Ov3rIwAAdHIIAITzPf7uLqudZBmPn1UR/3M+\n7R9M03m26mJGoE7TmyC2SkRYRbuvYNkd4OzOPYumgoKae8pR4h/dRgMSQN/r3Z+o\nXNkxBtLcXVgbGQ7z2KcaqlNEJKyy9G//bTQYB9Batk3z9y6UmvMITKJ561Y2Ymal\nH8bmZs1KZKOQpg5Q7jOtPRdfn4Wu2u1zNz0/xGJJghCrAiN8k3bz+qaihkmW05FJ\n0B57AGly/M971wGacdZIiED7op53yLXTCGkplx5q28F/WO5fJJwza5q4JnXRwEG3\nvq2OpjekWaE0JkN18quq9J/YUIy9fv9V8Lo8hvjr4fFAylX809NLVkZ+u0bGjtc=\n=PnVj\n-----END PGP SIGNATURE-----\n", "payload": "tree b979afc6883c973d4b95765a292e6e5c8b819e96\nparent 3901198e87df9c85b4a2e996240ca05c6950900f\nparent ddb9cc47d17204e5d52529ca04a4093f8ed8ec08\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1585563542 +0000\ncommitter GitHub <noreply@github.com> 1585563542 +0000\n\nMerge #3761\n\n3761: Append new match arms rather than replacing all of them r=matklad a=mattyhall\n\nThis means we now retain comments when filling in match arms. This fixes #3687. This is my first contribution so apologies if it needs a rethink! I think in particular the way I find the position to append to and remove_if_only_whitespace are a little hairy.\n\nCo-authored-by: Matthew Hall <matthew@quickbeam.me.uk>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d2ea3f25b53deac5785485ab5dfe5e6b3b893bf5", "html_url": "https://github.com/rust-lang/rust/commit/d2ea3f25b53deac5785485ab5dfe5e6b3b893bf5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d2ea3f25b53deac5785485ab5dfe5e6b3b893bf5/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3901198e87df9c85b4a2e996240ca05c6950900f", "url": "https://api.github.com/repos/rust-lang/rust/commits/3901198e87df9c85b4a2e996240ca05c6950900f", "html_url": "https://github.com/rust-lang/rust/commit/3901198e87df9c85b4a2e996240ca05c6950900f"}, {"sha": "ddb9cc47d17204e5d52529ca04a4093f8ed8ec08", "url": "https://api.github.com/repos/rust-lang/rust/commits/ddb9cc47d17204e5d52529ca04a4093f8ed8ec08", "html_url": "https://github.com/rust-lang/rust/commit/ddb9cc47d17204e5d52529ca04a4093f8ed8ec08"}], "stats": {"total": 199, "additions": 164, "deletions": 35}, "files": [{"sha": "5f279d25ad3abd4fc9314011ba50b7497140bdb8", "filename": "crates/ra_assists/src/handlers/fill_match_arms.rs", "status": "modified", "additions": 68, "deletions": 5, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/d2ea3f25b53deac5785485ab5dfe5e6b3b893bf5/crates%2Fra_assists%2Fsrc%2Fhandlers%2Ffill_match_arms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2ea3f25b53deac5785485ab5dfe5e6b3b893bf5/crates%2Fra_assists%2Fsrc%2Fhandlers%2Ffill_match_arms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Ffill_match_arms.rs?ref=d2ea3f25b53deac5785485ab5dfe5e6b3b893bf5", "patch": "@@ -7,7 +7,7 @@ use itertools::Itertools;\n use ra_ide_db::RootDatabase;\n \n use crate::{Assist, AssistCtx, AssistId};\n-use ra_syntax::ast::{self, edit::IndentLevel, make, AstNode, NameOwner};\n+use ra_syntax::ast::{self, make, AstNode, NameOwner};\n \n use ast::{MatchArm, Pat};\n \n@@ -97,10 +97,8 @@ pub(crate) fn fill_match_arms(ctx: AssistCtx) -> Option<Assist> {\n     }\n \n     ctx.add_assist(AssistId(\"fill_match_arms\"), \"Fill match arms\", |edit| {\n-        arms.extend(missing_arms);\n-\n-        let indent_level = IndentLevel::from_node(match_arm_list.syntax());\n-        let new_arm_list = indent_level.increase_indent(make::match_arm_list(arms));\n+        let new_arm_list =\n+            match_arm_list.remove_placeholder().append_arms(missing_arms.into_iter());\n \n         edit.target(match_expr.syntax().text_range());\n         edit.set_cursor(expr.syntax().text_range().start());\n@@ -655,4 +653,69 @@ mod tests {\n             \"#,\n         );\n     }\n+\n+    #[test]\n+    fn fill_match_arms_preserves_comments() {\n+        check_assist(\n+            fill_match_arms,\n+            r#\"\n+            enum A {\n+                One,\n+                Two,\n+            }\n+            fn foo(a: A) {\n+                match a {\n+                    // foo bar baz<|>\n+                    A::One => {}\n+                    // This is where the rest should be\n+                }\n+            }\n+            \"#,\n+            r#\"\n+            enum A {\n+                One,\n+                Two,\n+            }\n+            fn foo(a: A) {\n+                match <|>a {\n+                    // foo bar baz\n+                    A::One => {}\n+                    // This is where the rest should be\n+                    A::Two => {}\n+                }\n+            }\n+            \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn fill_match_arms_preserves_comments_empty() {\n+        check_assist(\n+            fill_match_arms,\n+            r#\"\n+            enum A {\n+                One,\n+                Two,\n+            }\n+            fn foo(a: A) {\n+                match a {\n+                    // foo bar baz<|>\n+                }\n+            }\n+            \"#,\n+            r#\"\n+            enum A {\n+                One,\n+                Two,\n+            }\n+            fn foo(a: A) {\n+                match <|>a {\n+                    // foo bar baz\n+                    A::One => {}\n+                    A::Two => {}\n+                }\n+            }\n+            \"#,\n+        );\n+    }\n }"}, {"sha": "baf9a1b4b20db31f4ce7b631c0fa279d4944b519", "filename": "crates/ra_syntax/src/ast/edit.rs", "status": "modified", "additions": 96, "deletions": 30, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/d2ea3f25b53deac5785485ab5dfe5e6b3b893bf5/crates%2Fra_syntax%2Fsrc%2Fast%2Fedit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2ea3f25b53deac5785485ab5dfe5e6b3b893bf5/crates%2Fra_syntax%2Fsrc%2Fast%2Fedit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fedit.rs?ref=d2ea3f25b53deac5785485ab5dfe5e6b3b893bf5", "patch": "@@ -46,12 +46,44 @@ impl ast::FnDef {\n     }\n }\n \n+fn make_multiline<N>(node: N) -> N\n+where\n+    N: AstNode + Clone,\n+{\n+    let l_curly = match node.syntax().children_with_tokens().find(|it| it.kind() == T!['{']) {\n+        Some(it) => it,\n+        None => return node,\n+    };\n+    let sibling = match l_curly.next_sibling_or_token() {\n+        Some(it) => it,\n+        None => return node,\n+    };\n+    let existing_ws = match sibling.as_token() {\n+        None => None,\n+        Some(tok) if tok.kind() != WHITESPACE => None,\n+        Some(ws) => {\n+            if ws.text().contains('\\n') {\n+                return node;\n+            }\n+            Some(ws.clone())\n+        }\n+    };\n+\n+    let indent = leading_indent(node.syntax()).unwrap_or_default();\n+    let ws = tokens::WsBuilder::new(&format!(\"\\n{}\", indent));\n+    let to_insert = iter::once(ws.ws().into());\n+    match existing_ws {\n+        None => node.insert_children(InsertPosition::After(l_curly), to_insert),\n+        Some(ws) => node.replace_children(single_node(ws), to_insert),\n+    }\n+}\n+\n impl ast::ItemList {\n     #[must_use]\n     pub fn append_items(&self, items: impl Iterator<Item = ast::ImplItem>) -> ast::ItemList {\n         let mut res = self.clone();\n         if !self.syntax().text().contains_char('\\n') {\n-            res = res.make_multiline();\n+            res = make_multiline(res);\n         }\n         items.for_each(|it| res = res.append_item(it));\n         res\n@@ -81,35 +113,6 @@ impl ast::ItemList {\n     fn l_curly(&self) -> Option<SyntaxElement> {\n         self.syntax().children_with_tokens().find(|it| it.kind() == T!['{'])\n     }\n-\n-    fn make_multiline(&self) -> ast::ItemList {\n-        let l_curly = match self.syntax().children_with_tokens().find(|it| it.kind() == T!['{']) {\n-            Some(it) => it,\n-            None => return self.clone(),\n-        };\n-        let sibling = match l_curly.next_sibling_or_token() {\n-            Some(it) => it,\n-            None => return self.clone(),\n-        };\n-        let existing_ws = match sibling.as_token() {\n-            None => None,\n-            Some(tok) if tok.kind() != WHITESPACE => None,\n-            Some(ws) => {\n-                if ws.text().contains('\\n') {\n-                    return self.clone();\n-                }\n-                Some(ws.clone())\n-            }\n-        };\n-\n-        let indent = leading_indent(self.syntax()).unwrap_or_default();\n-        let ws = tokens::WsBuilder::new(&format!(\"\\n{}\", indent));\n-        let to_insert = iter::once(ws.ws().into());\n-        match existing_ws {\n-            None => self.insert_children(InsertPosition::After(l_curly), to_insert),\n-            Some(ws) => self.replace_children(single_node(ws), to_insert),\n-        }\n-    }\n }\n \n impl ast::RecordFieldList {\n@@ -334,6 +337,69 @@ impl ast::UseTree {\n     }\n }\n \n+impl ast::MatchArmList {\n+    #[must_use]\n+    pub fn append_arms(&self, items: impl Iterator<Item = ast::MatchArm>) -> ast::MatchArmList {\n+        let mut res = self.clone();\n+        res = res.strip_if_only_whitespace();\n+        if !res.syntax().text().contains_char('\\n') {\n+            res = make_multiline(res);\n+        }\n+        items.for_each(|it| res = res.append_arm(it));\n+        res\n+    }\n+\n+    fn strip_if_only_whitespace(&self) -> ast::MatchArmList {\n+        let mut iter = self.syntax().children_with_tokens().skip_while(|it| it.kind() != T!['{']);\n+        iter.next(); // Eat the curly\n+        let mut inner = iter.take_while(|it| it.kind() != T!['}']);\n+        if !inner.clone().all(|it| it.kind() == WHITESPACE) {\n+            return self.clone();\n+        }\n+        let start = match inner.next() {\n+            Some(s) => s,\n+            None => return self.clone(),\n+        };\n+        let end = match inner.last() {\n+            Some(s) => s,\n+            None => start.clone(),\n+        };\n+        self.replace_children(start..=end, &mut iter::empty())\n+    }\n+\n+    #[must_use]\n+    pub fn remove_placeholder(&self) -> ast::MatchArmList {\n+        let placeholder = self.arms().find(|arm| {\n+            if let Some(ast::Pat::PlaceholderPat(_)) = arm.pat() {\n+                return true;\n+            }\n+            false\n+        });\n+        if let Some(placeholder) = placeholder {\n+            let s: SyntaxElement = placeholder.syntax().clone().into();\n+            let e = s.clone();\n+            self.replace_children(s..=e, &mut iter::empty())\n+        } else {\n+            self.clone()\n+        }\n+    }\n+\n+    #[must_use]\n+    pub fn append_arm(&self, item: ast::MatchArm) -> ast::MatchArmList {\n+        let r_curly = match self.syntax().children_with_tokens().find(|it| it.kind() == T!['}']) {\n+            Some(t) => t,\n+            None => return self.clone(),\n+        };\n+        let position = InsertPosition::Before(r_curly.into());\n+        let arm_ws = tokens::WsBuilder::new(\"    \");\n+        let match_indent = &leading_indent(self.syntax()).unwrap_or_default();\n+        let match_ws = tokens::WsBuilder::new(&format!(\"\\n{}\", match_indent));\n+        let to_insert: ArrayVec<[SyntaxElement; 3]> =\n+            [arm_ws.ws().into(), item.syntax().clone().into(), match_ws.ws().into()].into();\n+        self.insert_children(position, to_insert)\n+    }\n+}\n+\n #[must_use]\n pub fn remove_attrs_and_docs<N: ast::AttrsOwner>(node: &N) -> N {\n     N::cast(remove_attrs_and_docs_inner(node.syntax().clone())).unwrap()"}]}