{"sha": "8a55cd988f272ec70fc7d5adf6e61ed8ee6a8e78", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhhNTVjZDk4OGYyNzJlYzcwZmM3ZDVhZGY2ZTYxZWQ4ZWU2YThlNzg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-03-05T19:11:42Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-03-05T19:11:42Z"}, "message": "auto merge of #12711 : edwardw/rust/mtwt, r=pcwalton\n\n- Moves mtwt hygiene code into its own file\r\n- Fixes FIXME's which leads to ~2x speed gain in expansion pass\r\n- It is now @-free", "tree": {"sha": "b486444019a55cb1981e2547fc83dedec186eafc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b486444019a55cb1981e2547fc83dedec186eafc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8a55cd988f272ec70fc7d5adf6e61ed8ee6a8e78", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8a55cd988f272ec70fc7d5adf6e61ed8ee6a8e78", "html_url": "https://github.com/rust-lang/rust/commit/8a55cd988f272ec70fc7d5adf6e61ed8ee6a8e78", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8a55cd988f272ec70fc7d5adf6e61ed8ee6a8e78/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "db4f757367fcb0ad6e9644dc93218cf4a662e862", "url": "https://api.github.com/repos/rust-lang/rust/commits/db4f757367fcb0ad6e9644dc93218cf4a662e862", "html_url": "https://github.com/rust-lang/rust/commit/db4f757367fcb0ad6e9644dc93218cf4a662e862"}, {"sha": "2302ce903d8e5a3b9fad345a3942c1a9c191cf17", "url": "https://api.github.com/repos/rust-lang/rust/commits/2302ce903d8e5a3b9fad345a3942c1a9c191cf17", "html_url": "https://github.com/rust-lang/rust/commit/2302ce903d8e5a3b9fad345a3942c1a9c191cf17"}], "stats": {"total": 1120, "additions": 558, "deletions": 562}, "files": [{"sha": "0d3586266e869520326fc5199f25a851e14cc140", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/8a55cd988f272ec70fc7d5adf6e61ed8ee6a8e78/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a55cd988f272ec70fc7d5adf6e61ed8ee6a8e78/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=8a55cd988f272ec70fc7d5adf6e61ed8ee6a8e78", "patch": "@@ -19,8 +19,9 @@ use middle::pat_util::pat_bindings;\n \n use syntax::ast::*;\n use syntax::ast;\n-use syntax::ast_util::{def_id_of_def, local_def, mtwt_resolve};\n+use syntax::ast_util::{def_id_of_def, local_def};\n use syntax::ast_util::{path_to_ident, walk_pat, trait_method_to_ty_method};\n+use syntax::ext::mtwt;\n use syntax::parse::token::special_idents;\n use syntax::parse::token;\n use syntax::print::pprust::path_to_str;\n@@ -4176,7 +4177,7 @@ impl Resolver {\n     fn binding_mode_map(&mut self, pat: @Pat) -> BindingMap {\n         let mut result = HashMap::new();\n         pat_bindings(self.def_map, pat, |binding_mode, _id, sp, path| {\n-            let name = mtwt_resolve(path_to_ident(path));\n+            let name = mtwt::resolve(path_to_ident(path));\n             result.insert(name,\n                           binding_info {span: sp,\n                                         binding_mode: binding_mode});\n@@ -4411,7 +4412,7 @@ impl Resolver {\n                     // what you want).\n \n                     let ident = path.segments.get(0).identifier;\n-                    let renamed = mtwt_resolve(ident);\n+                    let renamed = mtwt::resolve(ident);\n \n                     match self.resolve_bare_identifier_pattern(ident) {\n                         FoundStructOrEnumVariant(def, lp)\n@@ -4965,7 +4966,7 @@ impl Resolver {\n         let search_result;\n         match namespace {\n             ValueNS => {\n-                let renamed = mtwt_resolve(ident);\n+                let renamed = mtwt::resolve(ident);\n                 let mut value_ribs = self.value_ribs.borrow_mut();\n                 search_result = self.search_ribs(value_ribs.get(),\n                                                  renamed,\n@@ -5213,7 +5214,7 @@ impl Resolver {\n                         let rib = label_ribs.get()[label_ribs.get().len() -\n                                                    1];\n                         let mut bindings = rib.bindings.borrow_mut();\n-                        let renamed = mtwt_resolve(label);\n+                        let renamed = mtwt::resolve(label);\n                         bindings.get().insert(renamed, def_like);\n                     }\n \n@@ -5225,7 +5226,7 @@ impl Resolver {\n \n             ExprBreak(Some(label)) | ExprAgain(Some(label)) => {\n                 let mut label_ribs = self.label_ribs.borrow_mut();\n-                let renamed = mtwt_resolve(label);\n+                let renamed = mtwt::resolve(label);\n                 match self.search_ribs(label_ribs.get(), renamed, expr.span) {\n                     None =>\n                         self.resolve_error(expr.span,"}, {"sha": "544d9f2d66935224c2be1c24720bbc6686f84399", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 4, "deletions": 37, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/8a55cd988f272ec70fc7d5adf6e61ed8ee6a8e78/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a55cd988f272ec70fc7d5adf6e61ed8ee6a8e78/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=8a55cd988f272ec70fc7d5adf6e61ed8ee6a8e78", "patch": "@@ -19,8 +19,6 @@ use parse::token;\n \n use std::fmt;\n use std::fmt::Show;\n-use std::cell::RefCell;\n-use collections::HashMap;\n use std::option::Option;\n use std::rc::Rc;\n use std::vec_ng::Vec;\n@@ -42,7 +40,10 @@ pub fn P<T: 'static>(value: T) -> P<T> {\n // macro expansion per Flatt et al., \"Macros\n // That Work Together\"\n #[deriving(Clone, Hash, TotalEq, TotalOrd, Show)]\n-pub struct Ident { name: Name, ctxt: SyntaxContext }\n+pub struct Ident {\n+    name: Name,\n+    ctxt: SyntaxContext\n+}\n \n impl Ident {\n     /// Construct an identifier with the given name and an empty context:\n@@ -88,43 +89,9 @@ impl Eq for Ident {\n // this uint is a reference to a table stored in thread-local\n // storage.\n pub type SyntaxContext = u32;\n-\n-// the SCTable contains a table of SyntaxContext_'s. It\n-// represents a flattened tree structure, to avoid having\n-// managed pointers everywhere (that caused an ICE).\n-// the mark_memo and rename_memo fields are side-tables\n-// that ensure that adding the same mark to the same context\n-// gives you back the same context as before. This shouldn't\n-// change the semantics--everything here is immutable--but\n-// it should cut down on memory use *a lot*; applying a mark\n-// to a tree containing 50 identifiers would otherwise generate\n-pub struct SCTable {\n-    table: RefCell<Vec<SyntaxContext_> >,\n-    mark_memo: RefCell<HashMap<(SyntaxContext,Mrk),SyntaxContext>>,\n-    rename_memo: RefCell<HashMap<(SyntaxContext,Ident,Name),SyntaxContext>>,\n-}\n-\n-// NB: these must be placed in any SCTable...\n pub static EMPTY_CTXT : SyntaxContext = 0;\n pub static ILLEGAL_CTXT : SyntaxContext = 1;\n \n-#[deriving(Eq, Encodable, Decodable, Hash)]\n-pub enum SyntaxContext_ {\n-    EmptyCtxt,\n-    Mark (Mrk,SyntaxContext),\n-    // flattening the name and syntaxcontext into the rename...\n-    // HIDDEN INVARIANTS:\n-    // 1) the first name in a Rename node\n-    // can only be a programmer-supplied name.\n-    // 2) Every Rename node with a given Name in the\n-    // \"to\" slot must have the same name and context\n-    // in the \"from\" slot. In essence, they're all\n-    // pointers to a single \"rename\" event node.\n-    Rename (Ident,Name,SyntaxContext),\n-    // actually, IllegalCtxt may not be necessary.\n-    IllegalCtxt\n-}\n-\n /// A name is a part of an identifier, representing a string or gensym. It's\n /// the result of interning.\n pub type Name = u32;"}, {"sha": "3899731b250089634fbf6e8573d9be21923352d4", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 1, "deletions": 457, "changes": 458, "blob_url": "https://github.com/rust-lang/rust/blob/8a55cd988f272ec70fc7d5adf6e61ed8ee6a8e78/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a55cd988f272ec70fc7d5adf6e61ed8ee6a8e78/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=8a55cd988f272ec70fc7d5adf6e61ed8ee6a8e78", "patch": "@@ -18,11 +18,9 @@ use print::pprust;\n use visit::Visitor;\n use visit;\n \n-use std::cell::{Cell, RefCell};\n+use std::cell::Cell;\n use std::cmp;\n-use collections::HashMap;\n use std::u32;\n-use std::local_data;\n use std::vec_ng::Vec;\n \n pub fn path_name_i(idents: &[Ident]) -> ~str {\n@@ -651,251 +649,6 @@ pub fn pat_is_ident(pat: @ast::Pat) -> bool {\n     }\n }\n \n-// HYGIENE FUNCTIONS\n-\n-/// Extend a syntax context with a given mark\n-pub fn new_mark(m:Mrk, tail:SyntaxContext) -> SyntaxContext {\n-    new_mark_internal(m,tail,get_sctable())\n-}\n-\n-// Extend a syntax context with a given mark and table\n-// FIXME #8215 : currently pub to allow testing\n-pub fn new_mark_internal(m: Mrk, tail: SyntaxContext, table: &SCTable)\n-                         -> SyntaxContext {\n-    let key = (tail,m);\n-    // FIXME #5074 : can't use more natural style because we're missing\n-    // flow-sensitivity. Results in two lookups on a hash table hit.\n-    // also applies to new_rename_internal, below.\n-    // let try_lookup = table.mark_memo.find(&key);\n-    let mut mark_memo = table.mark_memo.borrow_mut();\n-    match mark_memo.get().contains_key(&key) {\n-        false => {\n-            let new_idx = {\n-                let mut table = table.table.borrow_mut();\n-                idx_push(table.get(), Mark(m,tail))\n-            };\n-            mark_memo.get().insert(key,new_idx);\n-            new_idx\n-        }\n-        true => {\n-            match mark_memo.get().find(&key) {\n-                None => fail!(\"internal error: key disappeared 2013042901\"),\n-                Some(idxptr) => {*idxptr}\n-            }\n-        }\n-    }\n-}\n-\n-/// Extend a syntax context with a given rename\n-pub fn new_rename(id:Ident, to:Name, tail:SyntaxContext) -> SyntaxContext {\n-    new_rename_internal(id, to, tail, get_sctable())\n-}\n-\n-// Extend a syntax context with a given rename and sctable\n-// FIXME #8215 : currently pub to allow testing\n-pub fn new_rename_internal(id: Ident,\n-                           to: Name,\n-                           tail: SyntaxContext,\n-                           table: &SCTable)\n-                           -> SyntaxContext {\n-    let key = (tail,id,to);\n-    // FIXME #5074\n-    //let try_lookup = table.rename_memo.find(&key);\n-    let mut rename_memo = table.rename_memo.borrow_mut();\n-    match rename_memo.get().contains_key(&key) {\n-        false => {\n-            let new_idx = {\n-                let mut table = table.table.borrow_mut();\n-                idx_push(table.get(), Rename(id,to,tail))\n-            };\n-            rename_memo.get().insert(key,new_idx);\n-            new_idx\n-        }\n-        true => {\n-            match rename_memo.get().find(&key) {\n-                None => fail!(\"internal error: key disappeared 2013042902\"),\n-                Some(idxptr) => {*idxptr}\n-            }\n-        }\n-    }\n-}\n-\n-/// Make a fresh syntax context table with EmptyCtxt in slot zero\n-/// and IllegalCtxt in slot one.\n-// FIXME #8215 : currently pub to allow testing\n-pub fn new_sctable_internal() -> SCTable {\n-    SCTable {\n-        table: RefCell::new(vec!(EmptyCtxt,IllegalCtxt)),\n-        mark_memo: RefCell::new(HashMap::new()),\n-        rename_memo: RefCell::new(HashMap::new()),\n-    }\n-}\n-\n-// fetch the SCTable from TLS, create one if it doesn't yet exist.\n-pub fn get_sctable() -> @SCTable {\n-    local_data_key!(sctable_key: @@SCTable)\n-    match local_data::get(sctable_key, |k| k.map(|k| *k)) {\n-        None => {\n-            let new_table = @@new_sctable_internal();\n-            local_data::set(sctable_key,new_table);\n-            *new_table\n-        },\n-        Some(intr) => *intr\n-    }\n-}\n-\n-/// print out an SCTable for debugging\n-pub fn display_sctable(table : &SCTable) {\n-    error!(\"SC table:\");\n-    let table = table.table.borrow();\n-    for (idx,val) in table.get().iter().enumerate() {\n-        error!(\"{:4u} : {:?}\",idx,val);\n-    }\n-}\n-\n-\n-/// Add a value to the end of a vec, return its index\n-fn idx_push<T>(vec: &mut Vec<T> , val: T) -> u32 {\n-    vec.push(val);\n-    (vec.len() - 1) as u32\n-}\n-\n-/// Resolve a syntax object to a name, per MTWT.\n-pub fn mtwt_resolve(id : Ident) -> Name {\n-    let resolve_table = get_resolve_table();\n-    let mut resolve_table = resolve_table.borrow_mut();\n-    resolve_internal(id, get_sctable(), resolve_table.get())\n-}\n-\n-// FIXME #8215: must be pub for testing\n-pub type ResolveTable = HashMap<(Name,SyntaxContext),Name>;\n-\n-// okay, I admit, putting this in TLS is not so nice:\n-// fetch the SCTable from TLS, create one if it doesn't yet exist.\n-pub fn get_resolve_table() -> @RefCell<ResolveTable> {\n-    local_data_key!(resolve_table_key: @@RefCell<ResolveTable>)\n-    match local_data::get(resolve_table_key, |k| k.map(|k| *k)) {\n-        None => {\n-            let new_table = @@RefCell::new(HashMap::new());\n-            local_data::set(resolve_table_key, new_table);\n-            *new_table\n-        },\n-        Some(intr) => *intr\n-    }\n-}\n-\n-// Resolve a syntax object to a name, per MTWT.\n-// adding memoization to possibly resolve 500+ seconds in resolve for librustc (!)\n-// FIXME #8215 : currently pub to allow testing\n-pub fn resolve_internal(id : Ident,\n-                        table : &SCTable,\n-                        resolve_table : &mut ResolveTable) -> Name {\n-    let key = (id.name,id.ctxt);\n-    match resolve_table.contains_key(&key) {\n-        false => {\n-            let resolved = {\n-                let result = {\n-                    let table = table.table.borrow();\n-                    *table.get().get(id.ctxt as uint)\n-                };\n-                match result {\n-                    EmptyCtxt => id.name,\n-                    // ignore marks here:\n-                    Mark(_,subctxt) =>\n-                        resolve_internal(Ident{name:id.name, ctxt: subctxt},table,resolve_table),\n-                    // do the rename if necessary:\n-                    Rename(Ident{name,ctxt},toname,subctxt) => {\n-                        let resolvedfrom =\n-                            resolve_internal(Ident{name:name,ctxt:ctxt},table,resolve_table);\n-                        let resolvedthis =\n-                            resolve_internal(Ident{name:id.name,ctxt:subctxt},table,resolve_table);\n-                        if (resolvedthis == resolvedfrom)\n-                            && (marksof(ctxt,resolvedthis,table)\n-                                == marksof(subctxt,resolvedthis,table)) {\n-                            toname\n-                        } else {\n-                            resolvedthis\n-                        }\n-                    }\n-                    IllegalCtxt() => fail!(\"expected resolvable context, got IllegalCtxt\")\n-                }\n-            };\n-            resolve_table.insert(key,resolved);\n-            resolved\n-        }\n-        true => {\n-            // it's guaranteed to be there, because we just checked that it was\n-            // there and we never remove anything from the table:\n-            *(resolve_table.find(&key).unwrap())\n-        }\n-    }\n-}\n-\n-/// Compute the marks associated with a syntax context.\n-pub fn mtwt_marksof(ctxt: SyntaxContext, stopname: Name) -> Vec<Mrk> {\n-    marksof(ctxt, stopname, get_sctable())\n-}\n-\n-// the internal function for computing marks\n-// it's not clear to me whether it's better to use a [] mutable\n-// vector or a cons-list for this.\n-pub fn marksof(ctxt: SyntaxContext, stopname: Name, table: &SCTable) -> Vec<Mrk> {\n-    let mut result = Vec::new();\n-    let mut loopvar = ctxt;\n-    loop {\n-        let table_entry = {\n-            let table = table.table.borrow();\n-            *table.get().get(loopvar as uint)\n-        };\n-        match table_entry {\n-            EmptyCtxt => {\n-                return result;\n-            },\n-            Mark(mark, tl) => {\n-                xorPush(&mut result, mark);\n-                loopvar = tl;\n-            },\n-            Rename(_,name,tl) => {\n-                // see MTWT for details on the purpose of the stopname.\n-                // short version: it prevents duplication of effort.\n-                if name == stopname {\n-                    return result;\n-                } else {\n-                    loopvar = tl;\n-                }\n-            }\n-            IllegalCtxt => fail!(\"expected resolvable context, got IllegalCtxt\")\n-        }\n-    }\n-}\n-\n-/// Return the outer mark for a context with a mark at the outside.\n-/// FAILS when outside is not a mark.\n-pub fn mtwt_outer_mark(ctxt: SyntaxContext) -> Mrk {\n-    let sctable = get_sctable();\n-    let table = sctable.table.borrow();\n-    match *table.get().get(ctxt as uint) {\n-        ast::Mark(mrk,_) => mrk,\n-        _ => fail!(\"can't retrieve outer mark when outside is not a mark\")\n-    }\n-}\n-\n-/// Push a name... unless it matches the one on top, in which\n-/// case pop and discard (so two of the same marks cancel)\n-pub fn xorPush(marks: &mut Vec<Mrk> , mark: Mrk) {\n-    if (marks.len() > 0) && (getLast(marks) == mark) {\n-        marks.pop().unwrap();\n-    } else {\n-        marks.push(mark);\n-    }\n-}\n-\n-// get the last element of a mutable array.\n-// FIXME #4903: , must be a separate procedure for now.\n-pub fn getLast(arr: &Vec<Mrk> ) -> Mrk {\n-    *arr.last().unwrap()\n-}\n-\n // are two paths equal when compared unhygienically?\n // since I'm using this to replace ==, it seems appropriate\n // to compare the span, global, etc. fields as well.\n@@ -937,9 +690,6 @@ mod test {\n     use ast::*;\n     use super::*;\n     use opt_vec;\n-    use collections::HashMap;\n-\n-    use std::vec_ng::Vec;\n \n     fn ident_to_segment(id : &Ident) -> PathSegment {\n         PathSegment {identifier:id.clone(),\n@@ -957,210 +707,4 @@ mod test {\n                                   [Ident{name:3,ctxt:104},\n                                     Ident{name:77,ctxt:182}].map(ident_to_segment)));\n     }\n-\n-    #[test] fn xorpush_test () {\n-        let mut s = Vec::new();\n-        xorPush(&mut s, 14);\n-        assert_eq!(s.clone(), vec!(14));\n-        xorPush(&mut s, 14);\n-        assert_eq!(s.clone(), Vec::new());\n-        xorPush(&mut s, 14);\n-        assert_eq!(s.clone(), vec!(14));\n-        xorPush(&mut s, 15);\n-        assert_eq!(s.clone(), vec!(14, 15));\n-        xorPush(&mut s, 16);\n-        assert_eq!(s.clone(), vec!(14, 15, 16));\n-        xorPush(&mut s, 16);\n-        assert_eq!(s.clone(), vec!(14, 15));\n-        xorPush(&mut s, 15);\n-        assert_eq!(s.clone(), vec!(14));\n-    }\n-\n-    fn id(n: Name, s: SyntaxContext) -> Ident {\n-        Ident {name: n, ctxt: s}\n-    }\n-\n-    // because of the SCTable, I now need a tidy way of\n-    // creating syntax objects. Sigh.\n-    #[deriving(Clone, Eq, Show)]\n-    enum TestSC {\n-        M(Mrk),\n-        R(Ident,Name)\n-    }\n-\n-    // unfold a vector of TestSC values into a SCTable,\n-    // returning the resulting index\n-    fn unfold_test_sc(tscs : Vec<TestSC> , tail: SyntaxContext, table: &SCTable)\n-        -> SyntaxContext {\n-        tscs.rev_iter().fold(tail, |tail : SyntaxContext, tsc : &TestSC|\n-                  {match *tsc {\n-                      M(mrk) => new_mark_internal(mrk,tail,table),\n-                      R(ident,name) => new_rename_internal(ident,name,tail,table)}})\n-    }\n-\n-    // gather a SyntaxContext back into a vector of TestSCs\n-    fn refold_test_sc(mut sc: SyntaxContext, table : &SCTable) -> Vec<TestSC> {\n-        let mut result = Vec::new();\n-        loop {\n-            let table = table.table.borrow();\n-            match *table.get().get(sc as uint) {\n-                EmptyCtxt => {return result;},\n-                Mark(mrk,tail) => {\n-                    result.push(M(mrk));\n-                    sc = tail;\n-                    continue;\n-                },\n-                Rename(id,name,tail) => {\n-                    result.push(R(id,name));\n-                    sc = tail;\n-                    continue;\n-                }\n-                IllegalCtxt => fail!(\"expected resolvable context, got IllegalCtxt\")\n-            }\n-        }\n-    }\n-\n-    #[test] fn test_unfold_refold(){\n-        let mut t = new_sctable_internal();\n-\n-        let test_sc = vec!(M(3),R(id(101,0),14),M(9));\n-        assert_eq!(unfold_test_sc(test_sc.clone(),EMPTY_CTXT,&mut t),4);\n-        {\n-            let table = t.table.borrow();\n-            assert!(*table.get().get(2) == Mark(9,0));\n-            assert!(*table.get().get(3) == Rename(id(101,0),14,2));\n-            assert!(*table.get().get(4) == Mark(3,3));\n-        }\n-        assert_eq!(refold_test_sc(4,&t),test_sc);\n-    }\n-\n-    // extend a syntax context with a sequence of marks given\n-    // in a vector. v[0] will be the outermost mark.\n-    fn unfold_marks(mrks: Vec<Mrk> , tail: SyntaxContext, table: &SCTable)\n-                    -> SyntaxContext {\n-        mrks.rev_iter().fold(tail, |tail:SyntaxContext, mrk:&Mrk|\n-                   {new_mark_internal(*mrk,tail,table)})\n-    }\n-\n-    #[test] fn unfold_marks_test() {\n-        let mut t = new_sctable_internal();\n-\n-        assert_eq!(unfold_marks(vec!(3,7),EMPTY_CTXT,&mut t),3);\n-        {\n-            let table = t.table.borrow();\n-            assert!(*table.get().get(2) == Mark(7,0));\n-            assert!(*table.get().get(3) == Mark(3,2));\n-        }\n-    }\n-\n-    #[test] fn test_marksof () {\n-        let stopname = 242;\n-        let name1 = 243;\n-        let mut t = new_sctable_internal();\n-        assert_eq!(marksof (EMPTY_CTXT,stopname,&t),Vec::new());\n-        // FIXME #5074: ANF'd to dodge nested calls\n-        { let ans = unfold_marks(vec!(4,98),EMPTY_CTXT,&mut t);\n-         assert_eq! (marksof (ans,stopname,&t),vec!(4,98));}\n-        // does xoring work?\n-        { let ans = unfold_marks(vec!(5,5,16),EMPTY_CTXT,&mut t);\n-         assert_eq! (marksof (ans,stopname,&t), vec!(16));}\n-        // does nested xoring work?\n-        { let ans = unfold_marks(vec!(5,10,10,5,16),EMPTY_CTXT,&mut t);\n-         assert_eq! (marksof (ans, stopname,&t), vec!(16));}\n-        // rename where stop doesn't match:\n-        { let chain = vec!(M(9),\n-                        R(id(name1,\n-                             new_mark_internal (4, EMPTY_CTXT,&mut t)),\n-                          100101102),\n-                        M(14));\n-         let ans = unfold_test_sc(chain,EMPTY_CTXT,&mut t);\n-         assert_eq! (marksof (ans, stopname, &t), vec!(9,14));}\n-        // rename where stop does match\n-        { let name1sc = new_mark_internal(4, EMPTY_CTXT, &mut t);\n-         let chain = vec!(M(9),\n-                       R(id(name1, name1sc),\n-                         stopname),\n-                       M(14));\n-         let ans = unfold_test_sc(chain,EMPTY_CTXT,&mut t);\n-         assert_eq! (marksof (ans, stopname, &t), vec!(9)); }\n-    }\n-\n-\n-    #[test] fn resolve_tests () {\n-        let a = 40;\n-        let mut t = new_sctable_internal();\n-        let mut rt = HashMap::new();\n-        // - ctxt is MT\n-        assert_eq!(resolve_internal(id(a,EMPTY_CTXT),&mut t, &mut rt),a);\n-        // - simple ignored marks\n-        { let sc = unfold_marks(vec!(1,2,3),EMPTY_CTXT,&mut t);\n-         assert_eq!(resolve_internal(id(a,sc),&mut t, &mut rt),a);}\n-        // - orthogonal rename where names don't match\n-        { let sc = unfold_test_sc(vec!(R(id(50,EMPTY_CTXT),51),M(12)),EMPTY_CTXT,&mut t);\n-         assert_eq!(resolve_internal(id(a,sc),&mut t, &mut rt),a);}\n-        // - rename where names do match, but marks don't\n-        { let sc1 = new_mark_internal(1,EMPTY_CTXT,&mut t);\n-         let sc = unfold_test_sc(vec!(R(id(a,sc1),50),\n-                                   M(1),\n-                                   M(2)),\n-                                 EMPTY_CTXT,&mut t);\n-        assert_eq!(resolve_internal(id(a,sc),&mut t, &mut rt), a);}\n-        // - rename where names and marks match\n-        { let sc1 = unfold_test_sc(vec!(M(1),M(2)),EMPTY_CTXT,&mut t);\n-         let sc = unfold_test_sc(vec!(R(id(a,sc1),50),M(1),M(2)),EMPTY_CTXT,&mut t);\n-         assert_eq!(resolve_internal(id(a,sc),&mut t, &mut rt), 50); }\n-        // - rename where names and marks match by literal sharing\n-        { let sc1 = unfold_test_sc(vec!(M(1),M(2)),EMPTY_CTXT,&mut t);\n-         let sc = unfold_test_sc(vec!(R(id(a,sc1),50)),sc1,&mut t);\n-         assert_eq!(resolve_internal(id(a,sc),&mut t, &mut rt), 50); }\n-        // - two renames of the same var.. can only happen if you use\n-        // local-expand to prevent the inner binding from being renamed\n-        // during the rename-pass caused by the first:\n-        println!(\"about to run bad test\");\n-        { let sc = unfold_test_sc(vec!(R(id(a,EMPTY_CTXT),50),\n-                                    R(id(a,EMPTY_CTXT),51)),\n-                                  EMPTY_CTXT,&mut t);\n-         assert_eq!(resolve_internal(id(a,sc),&mut t, &mut rt), 51); }\n-        // the simplest double-rename:\n-        { let a_to_a50 = new_rename_internal(id(a,EMPTY_CTXT),50,EMPTY_CTXT,&mut t);\n-         let a50_to_a51 = new_rename_internal(id(a,a_to_a50),51,a_to_a50,&mut t);\n-         assert_eq!(resolve_internal(id(a,a50_to_a51),&mut t, &mut rt),51);\n-         // mark on the outside doesn't stop rename:\n-         let sc = new_mark_internal(9,a50_to_a51,&mut t);\n-         assert_eq!(resolve_internal(id(a,sc),&mut t, &mut rt),51);\n-         // but mark on the inside does:\n-         let a50_to_a51_b = unfold_test_sc(vec!(R(id(a,a_to_a50),51),\n-                                              M(9)),\n-                                           a_to_a50,\n-                                           &mut t);\n-         assert_eq!(resolve_internal(id(a,a50_to_a51_b),&mut t, &mut rt),50);}\n-    }\n-\n-    #[test] fn mtwt_resolve_test(){\n-        let a = 40;\n-        assert_eq!(mtwt_resolve(id(a,EMPTY_CTXT)),a);\n-    }\n-\n-\n-    #[test] fn hashing_tests () {\n-        let mut t = new_sctable_internal();\n-        assert_eq!(new_mark_internal(12,EMPTY_CTXT,&mut t),2);\n-        assert_eq!(new_mark_internal(13,EMPTY_CTXT,&mut t),3);\n-        // using the same one again should result in the same index:\n-        assert_eq!(new_mark_internal(12,EMPTY_CTXT,&mut t),2);\n-        // I'm assuming that the rename table will behave the same....\n-    }\n-\n-    #[test] fn resolve_table_hashing_tests() {\n-        let mut t = new_sctable_internal();\n-        let mut rt = HashMap::new();\n-        assert_eq!(rt.len(),0);\n-        resolve_internal(id(30,EMPTY_CTXT),&mut t, &mut rt);\n-        assert_eq!(rt.len(),1);\n-        resolve_internal(id(39,EMPTY_CTXT),&mut t, &mut rt);\n-        assert_eq!(rt.len(),2);\n-        resolve_internal(id(30,EMPTY_CTXT),&mut t, &mut rt);\n-        assert_eq!(rt.len(),2);\n-    }\n-\n }"}, {"sha": "79068d4046965ad519f26332812f1144129b318a", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8a55cd988f272ec70fc7d5adf6e61ed8ee6a8e78/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a55cd988f272ec70fc7d5adf6e61ed8ee6a8e78/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=8a55cd988f272ec70fc7d5adf6e61ed8ee6a8e78", "patch": "@@ -146,9 +146,9 @@ pub enum SyntaxExtension {\n \n pub struct BlockInfo {\n     // should macros escape from this scope?\n-    macros_escape : bool,\n+    macros_escape: bool,\n     // what are the pending renames?\n-    pending_renames : RenameList,\n+    pending_renames: RenameList,\n }\n \n impl BlockInfo {\n@@ -161,7 +161,7 @@ impl BlockInfo {\n }\n \n // a list of ident->name renamings\n-pub type RenameList = Vec<(ast::Ident,Name)> ;\n+pub type RenameList = Vec<(ast::Ident, Name)>;\n \n // The base map of methods for expanding syntax extension\n // AST nodes into full ASTs"}, {"sha": "8b23de235b80480500fa8ecf201b0831d17c700a", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 56, "deletions": 56, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/8a55cd988f272ec70fc7d5adf6e61ed8ee6a8e78/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a55cd988f272ec70fc7d5adf6e61ed8ee6a8e78/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=8a55cd988f272ec70fc7d5adf6e61ed8ee6a8e78", "patch": "@@ -11,9 +11,9 @@\n use ast::{P, Block, Crate, DeclLocal, ExprMac};\n use ast::{Local, Ident, MacInvocTT};\n use ast::{ItemMac, Mrk, Stmt, StmtDecl, StmtMac, StmtExpr, StmtSemi};\n-use ast::{TokenTree};\n+use ast::TokenTree;\n use ast;\n-use ast_util::{new_rename, new_mark};\n+use ext::mtwt;\n use ext::build::AstBuilder;\n use attr;\n use attr::AttrMetaMethods;\n@@ -140,9 +140,7 @@ pub fn expand_expr(e: @ast::Expr, fld: &mut MacroExpander) -> @ast::Expr {\n             // Expand any interior macros etc.\n             // NB: we don't fold pats yet. Curious.\n             let src_expr = fld.fold_expr(src_expr).clone();\n-            // Rename label before expansion.\n-            let (opt_ident, src_loop_block) = rename_loop_label(opt_ident, src_loop_block, fld);\n-            let src_loop_block = fld.fold_block(src_loop_block);\n+            let (src_loop_block, opt_ident) = expand_loop_block(src_loop_block, opt_ident, fld);\n \n             let span = e.span;\n \n@@ -205,32 +203,46 @@ pub fn expand_expr(e: @ast::Expr, fld: &mut MacroExpander) -> @ast::Expr {\n         }\n \n         ast::ExprLoop(loop_block, opt_ident) => {\n-            let (opt_ident, loop_block) =\n-                rename_loop_label(opt_ident, loop_block, fld);\n-            let loop_block = fld.fold_block(loop_block);\n+            let (loop_block, opt_ident) = expand_loop_block(loop_block, opt_ident, fld);\n             fld.cx.expr(e.span, ast::ExprLoop(loop_block, opt_ident))\n         }\n \n         _ => noop_fold_expr(e, fld)\n     }\n }\n \n-// Rename loop label and its all occurrences inside the loop body\n-fn rename_loop_label(opt_ident: Option<Ident>,\n-                     loop_block: P<Block>,\n-                     fld: &mut MacroExpander) -> (Option<Ident>, P<Block>) {\n+// Rename loop label and expand its loop body\n+//\n+// The renaming procedure for loop is different in the sense that the loop\n+// body is in a block enclosed by loop head so the renaming of loop label\n+// must be propagated to the enclosed context.\n+fn expand_loop_block(loop_block: P<Block>,\n+                     opt_ident: Option<Ident>,\n+                     fld: &mut MacroExpander) -> (P<Block>, Option<Ident>) {\n     match opt_ident {\n         Some(label) => {\n-            // Generate fresh label and add to the existing pending renames\n             let new_label = fresh_name(&label);\n             let rename = (label, new_label);\n+\n+            // The rename *must not* be added to the pending list of current\n+            // syntax context otherwise an unrelated `break` or `continue` in\n+            // the same context will pick that up in the deferred renaming pass\n+            // and be renamed incorrectly.\n+            let mut rename_list = vec!(rename);\n+            let mut rename_fld = renames_to_fold(&mut rename_list);\n+            let renamed_ident = rename_fld.fold_ident(label);\n+\n+            // The rename *must* be added to the enclosed syntax context for\n+            // `break` or `continue` to pick up because by definition they are\n+            // in a block enclosed by loop head.\n+            fld.extsbox.push_frame();\n             fld.extsbox.info().pending_renames.push(rename);\n-            let mut pending_renames = vec!(rename);\n-            let mut rename_fld = renames_to_fold(&mut pending_renames);\n-            (Some(rename_fld.fold_ident(label)),\n-             rename_fld.fold_block(loop_block))\n+            let expanded_block = expand_block_elts(loop_block, fld);\n+            fld.extsbox.pop_frame();\n+\n+            (expanded_block, Some(renamed_ident))\n         }\n-        None => (None, loop_block)\n+        None => (fld.fold_block(loop_block), opt_ident)\n     }\n }\n \n@@ -628,9 +640,7 @@ fn expand_non_macro_stmt(s: &Stmt, fld: &mut MacroExpander)\n                         rename_fld.fold_pat(expanded_pat)\n                     };\n                     // add them to the existing pending renames:\n-                    for pr in new_pending_renames.iter() {\n-                        fld.extsbox.info().pending_renames.push(*pr)\n-                    }\n+                    fld.extsbox.info().pending_renames.push_all_move(new_pending_renames);\n                     // also, don't forget to expand the init:\n                     let new_init_opt = init.map(|e| fld.fold_expr(e));\n                     let rewritten_local =\n@@ -754,11 +764,11 @@ pub struct IdentRenamer<'a> {\n }\n \n impl<'a> Folder for IdentRenamer<'a> {\n-    fn fold_ident(&mut self, id: ast::Ident) -> ast::Ident {\n+    fn fold_ident(&mut self, id: Ident) -> Ident {\n         let new_ctxt = self.renames.iter().fold(id.ctxt, |ctxt, &(from, to)| {\n-            new_rename(from, to, ctxt)\n+            mtwt::new_rename(from, to, ctxt)\n         });\n-        ast::Ident {\n+        Ident {\n             name: id.name,\n             ctxt: new_ctxt,\n         }\n@@ -839,18 +849,18 @@ pub fn expand_crate(parse_sess: @parse::ParseSess,\n struct Marker { mark: Mrk }\n \n impl Folder for Marker {\n-    fn fold_ident(&mut self, id: ast::Ident) -> ast::Ident {\n+    fn fold_ident(&mut self, id: Ident) -> Ident {\n         ast::Ident {\n             name: id.name,\n-            ctxt: new_mark(self.mark, id.ctxt)\n+            ctxt: mtwt::new_mark(self.mark, id.ctxt)\n         }\n     }\n     fn fold_mac(&mut self, m: &ast::Mac) -> ast::Mac {\n         let macro = match m.node {\n             MacInvocTT(ref path, ref tts, ctxt) => {\n                 MacInvocTT(self.fold_path(path),\n                            fold_tts(tts.as_slice(), self),\n-                           new_mark(self.mark, ctxt))\n+                           mtwt::new_mark(self.mark, ctxt))\n             }\n         };\n         Spanned {\n@@ -906,11 +916,10 @@ mod test {\n     use super::*;\n     use ast;\n     use ast::{Attribute_, AttrOuter, MetaWord};\n-    use ast_util::{get_sctable, mtwt_marksof, mtwt_resolve};\n-    use ast_util;\n     use codemap;\n     use codemap::Spanned;\n     use ext::base::{CrateLoader, MacroCrate};\n+    use ext::mtwt;\n     use parse;\n     use parse::token;\n     use util::parser_testing::{string_to_crate_and_sess};\n@@ -1139,8 +1148,8 @@ mod test {\n         // must be one check clause for each binding:\n         assert_eq!(bindings.len(),bound_connections.len());\n         for (binding_idx,shouldmatch) in bound_connections.iter().enumerate() {\n-            let binding_name = mtwt_resolve(*bindings.get(binding_idx));\n-            let binding_marks = mtwt_marksof(bindings.get(binding_idx).ctxt,invalid_name);\n+            let binding_name = mtwt::resolve(*bindings.get(binding_idx));\n+            let binding_marks = mtwt::marksof(bindings.get(binding_idx).ctxt, invalid_name);\n             // shouldmatch can't name varrefs that don't exist:\n             assert!((shouldmatch.len() == 0) ||\n                     (varrefs.len() > *shouldmatch.iter().max().unwrap()));\n@@ -1149,19 +1158,19 @@ mod test {\n                     // it should be a path of length 1, and it should\n                     // be free-identifier=? or bound-identifier=? to the given binding\n                     assert_eq!(varref.segments.len(),1);\n-                    let varref_name = mtwt_resolve(varref.segments\n-                                                         .get(0)\n-                                                         .identifier);\n-                    let varref_marks = mtwt_marksof(varref.segments\n+                    let varref_name = mtwt::resolve(varref.segments\n                                                           .get(0)\n-                                                          .identifier\n-                                                          .ctxt,\n-                                                    invalid_name);\n+                                                          .identifier);\n+                    let varref_marks = mtwt::marksof(varref.segments\n+                                                           .get(0)\n+                                                           .identifier\n+                                                           .ctxt,\n+                                                     invalid_name);\n                     if !(varref_name==binding_name) {\n                         println!(\"uh oh, should match but doesn't:\");\n                         println!(\"varref: {:?}\",varref);\n                         println!(\"binding: {:?}\", *bindings.get(binding_idx));\n-                        ast_util::display_sctable(get_sctable());\n+                        mtwt::with_sctable(|x| mtwt::display_sctable(x));\n                     }\n                     assert_eq!(varref_name,binding_name);\n                     if bound_ident_check {\n@@ -1171,8 +1180,8 @@ mod test {\n                     }\n                 } else {\n                     let fail = (varref.segments.len() == 1)\n-                        && (mtwt_resolve(varref.segments.get(0).identifier) ==\n-                                         binding_name);\n+                        && (mtwt::resolve(varref.segments.get(0).identifier)\n+                            == binding_name);\n                     // temp debugging:\n                     if fail {\n                         println!(\"failure on test {}\",test_idx);\n@@ -1188,7 +1197,7 @@ mod test {\n                                  varref.segments.get(0).identifier.name,\n                                  string.get());\n                         println!(\"binding: {:?}\", *bindings.get(binding_idx));\n-                        ast_util::display_sctable(get_sctable());\n+                        mtwt::with_sctable(|x| mtwt::display_sctable(x));\n                     }\n                     assert!(!fail);\n                 }\n@@ -1218,7 +1227,7 @@ foo_module!()\n             [b] => b,\n             _ => fail!(\"expected just one binding for ext_cx\")\n         };\n-        let resolved_binding = mtwt_resolve(*cxbind);\n+        let resolved_binding = mtwt::resolve(*cxbind);\n         // find all the xx varrefs:\n         let mut path_finder = new_path_finder(Vec::new());\n         visit::walk_crate(&mut path_finder, &cr, ());\n@@ -1229,26 +1238,17 @@ foo_module!()\n             p.segments.len() == 1\n             && \"xx\" == token::get_ident(p.segments.get(0).identifier).get()\n         }).enumerate() {\n-            if mtwt_resolve(v.segments.get(0).identifier) !=\n-                    resolved_binding {\n+            if mtwt::resolve(v.segments.get(0).identifier) != resolved_binding {\n                 println!(\"uh oh, xx binding didn't match xx varref:\");\n                 println!(\"this is xx varref \\\\# {:?}\",idx);\n                 println!(\"binding: {:?}\",cxbind);\n                 println!(\"resolves to: {:?}\",resolved_binding);\n                 println!(\"varref: {:?}\",v.segments.get(0).identifier);\n                 println!(\"resolves to: {:?}\",\n-                         mtwt_resolve(v.segments.get(0).identifier));\n-                let table = get_sctable();\n-                println!(\"SC table:\");\n-\n-                {\n-                    let table = table.table.borrow();\n-                    for (idx,val) in table.get().iter().enumerate() {\n-                        println!(\"{:4u}: {:?}\",idx,val);\n-                    }\n-                }\n+                         mtwt::resolve(v.segments.get(0).identifier));\n+                mtwt::with_sctable(|x| mtwt::display_sctable(x));\n             }\n-            assert_eq!(mtwt_resolve(v.segments.get(0).identifier),\n+            assert_eq!(mtwt::resolve(v.segments.get(0).identifier),\n                        resolved_binding);\n         };\n     }"}, {"sha": "b0ed215f3e1036cbd258fa849265fdd790221af4", "filename": "src/libsyntax/ext/mtwt.rs", "status": "added", "additions": 482, "deletions": 0, "changes": 482, "blob_url": "https://github.com/rust-lang/rust/blob/8a55cd988f272ec70fc7d5adf6e61ed8ee6a8e78/src%2Flibsyntax%2Fext%2Fmtwt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a55cd988f272ec70fc7d5adf6e61ed8ee6a8e78/src%2Flibsyntax%2Fext%2Fmtwt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fmtwt.rs?ref=8a55cd988f272ec70fc7d5adf6e61ed8ee6a8e78", "patch": "@@ -0,0 +1,482 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Machinery for hygienic macros, as described in the MTWT[1] paper.\n+//!\n+//! [1] Matthew Flatt, Ryan Culpepper, David Darais, and Robert Bruce Findler.\n+//! 2012. *Macros that work together: Compile-time bindings, partial expansion,\n+//! and definition contexts*. J. Funct. Program. 22, 2 (March 2012), 181-216.\n+//! DOI=10.1017/S0956796812000093 http://dx.doi.org/10.1017/S0956796812000093\n+\n+use ast::{Ident, Mrk, Name, SyntaxContext};\n+\n+use std::cell::RefCell;\n+use std::local_data;\n+use std::rc::Rc;\n+use std::vec_ng::Vec;\n+\n+use collections::HashMap;\n+\n+// the SCTable contains a table of SyntaxContext_'s. It\n+// represents a flattened tree structure, to avoid having\n+// managed pointers everywhere (that caused an ICE).\n+// the mark_memo and rename_memo fields are side-tables\n+// that ensure that adding the same mark to the same context\n+// gives you back the same context as before. This shouldn't\n+// change the semantics--everything here is immutable--but\n+// it should cut down on memory use *a lot*; applying a mark\n+// to a tree containing 50 identifiers would otherwise generate\n+pub struct SCTable {\n+    table: RefCell<Vec<SyntaxContext_>>,\n+    mark_memo: RefCell<HashMap<(SyntaxContext,Mrk),SyntaxContext>>,\n+    rename_memo: RefCell<HashMap<(SyntaxContext,Ident,Name),SyntaxContext>>,\n+}\n+\n+#[deriving(Eq, Encodable, Decodable, Hash)]\n+pub enum SyntaxContext_ {\n+    EmptyCtxt,\n+    Mark (Mrk,SyntaxContext),\n+    // flattening the name and syntaxcontext into the rename...\n+    // HIDDEN INVARIANTS:\n+    // 1) the first name in a Rename node\n+    // can only be a programmer-supplied name.\n+    // 2) Every Rename node with a given Name in the\n+    // \"to\" slot must have the same name and context\n+    // in the \"from\" slot. In essence, they're all\n+    // pointers to a single \"rename\" event node.\n+    Rename (Ident,Name,SyntaxContext),\n+    // actually, IllegalCtxt may not be necessary.\n+    IllegalCtxt\n+}\n+\n+/// Extend a syntax context with a given mark\n+pub fn new_mark(m: Mrk, tail: SyntaxContext) -> SyntaxContext {\n+    with_sctable(|table| new_mark_internal(m, tail, table))\n+}\n+\n+// Extend a syntax context with a given mark and table\n+fn new_mark_internal(m: Mrk, tail: SyntaxContext, table: &SCTable) -> SyntaxContext {\n+    let key = (tail, m);\n+    let mut mark_memo = table.mark_memo.borrow_mut();\n+    let new_ctxt = |_: &(SyntaxContext, Mrk)|\n+                   idx_push(table.table.borrow_mut().get(), Mark(m, tail));\n+\n+    *mark_memo.get().find_or_insert_with(key, new_ctxt)\n+}\n+\n+/// Extend a syntax context with a given rename\n+pub fn new_rename(id: Ident, to:Name,\n+                  tail: SyntaxContext) -> SyntaxContext {\n+    with_sctable(|table| new_rename_internal(id, to, tail, table))\n+}\n+\n+// Extend a syntax context with a given rename and sctable\n+fn new_rename_internal(id: Ident,\n+                       to: Name,\n+                       tail: SyntaxContext,\n+                       table: &SCTable) -> SyntaxContext {\n+    let key = (tail,id,to);\n+    let mut rename_memo = table.rename_memo.borrow_mut();\n+    let new_ctxt = |_: &(SyntaxContext, Ident, Mrk)|\n+                   idx_push(table.table.borrow_mut().get(), Rename(id, to, tail));\n+\n+    *rename_memo.get().find_or_insert_with(key, new_ctxt)\n+}\n+\n+/// Fetch the SCTable from TLS, create one if it doesn't yet exist.\n+pub fn with_sctable<T>(op: |&SCTable| -> T) -> T {\n+    local_data_key!(sctable_key: Rc<SCTable>)\n+\n+    local_data::get(sctable_key, |opt_ts| {\n+        let table = match opt_ts {\n+            None => {\n+                let ts = Rc::new(new_sctable_internal());\n+                local_data::set(sctable_key, ts.clone());\n+                ts\n+            }\n+            Some(ts) => ts.clone()\n+        };\n+        op(table.borrow())\n+    })\n+}\n+\n+// Make a fresh syntax context table with EmptyCtxt in slot zero\n+// and IllegalCtxt in slot one.\n+fn new_sctable_internal() -> SCTable {\n+    SCTable {\n+        table: RefCell::new(vec!(EmptyCtxt, IllegalCtxt)),\n+        mark_memo: RefCell::new(HashMap::new()),\n+        rename_memo: RefCell::new(HashMap::new()),\n+    }\n+}\n+\n+/// Print out an SCTable for debugging\n+pub fn display_sctable(table: &SCTable) {\n+    error!(\"SC table:\");\n+    let table = table.table.borrow();\n+    for (idx,val) in table.get().iter().enumerate() {\n+        error!(\"{:4u} : {:?}\",idx,val);\n+    }\n+}\n+\n+\n+// Add a value to the end of a vec, return its index\n+fn idx_push<T>(vec: &mut Vec<T> , val: T) -> u32 {\n+    vec.push(val);\n+    (vec.len() - 1) as u32\n+}\n+\n+/// Resolve a syntax object to a name, per MTWT.\n+pub fn resolve(id: Ident) -> Name {\n+    with_sctable(|sctable| {\n+        with_resolve_table_mut(|resolve_table| {\n+            resolve_internal(id, sctable, resolve_table)\n+        })\n+    })\n+}\n+\n+type ResolveTable = HashMap<(Name,SyntaxContext),Name>;\n+\n+// okay, I admit, putting this in TLS is not so nice:\n+// fetch the SCTable from TLS, create one if it doesn't yet exist.\n+fn with_resolve_table_mut<T>(op: |&mut ResolveTable| -> T) -> T {\n+    local_data_key!(resolve_table_key: Rc<RefCell<ResolveTable>>)\n+\n+    local_data::get(resolve_table_key, |opt_ts| {\n+        let table = match opt_ts {\n+            None => {\n+                let ts = Rc::new(RefCell::new(HashMap::new()));\n+                local_data::set(resolve_table_key, ts.clone());\n+                ts\n+            }\n+            Some(ts) => ts.clone()\n+        };\n+        op(table.borrow().borrow_mut().get())\n+    })\n+}\n+\n+// Resolve a syntax object to a name, per MTWT.\n+// adding memorization to possibly resolve 500+ seconds in resolve for librustc (!)\n+fn resolve_internal(id: Ident,\n+                    table: &SCTable,\n+                    resolve_table: &mut ResolveTable) -> Name {\n+    let key = (id.name, id.ctxt);\n+\n+    match resolve_table.find(&key) {\n+        Some(&name) => return name,\n+        None => {}\n+    }\n+\n+    let resolved = {\n+        let result = *table.table.borrow().get().get(id.ctxt as uint);\n+        match result {\n+            EmptyCtxt => id.name,\n+            // ignore marks here:\n+            Mark(_,subctxt) =>\n+                resolve_internal(Ident{name:id.name, ctxt: subctxt},\n+                                 table, resolve_table),\n+            // do the rename if necessary:\n+            Rename(Ident{name, ctxt}, toname, subctxt) => {\n+                let resolvedfrom =\n+                    resolve_internal(Ident{name:name, ctxt:ctxt},\n+                                     table, resolve_table);\n+                let resolvedthis =\n+                    resolve_internal(Ident{name:id.name, ctxt:subctxt},\n+                                     table, resolve_table);\n+                if (resolvedthis == resolvedfrom)\n+                    && (marksof_internal(ctxt, resolvedthis, table)\n+                        == marksof_internal(subctxt, resolvedthis, table)) {\n+                    toname\n+                } else {\n+                    resolvedthis\n+                }\n+            }\n+            IllegalCtxt() => fail!(\"expected resolvable context, got IllegalCtxt\")\n+        }\n+    };\n+    resolve_table.insert(key, resolved);\n+    resolved\n+}\n+\n+/// Compute the marks associated with a syntax context.\n+pub fn marksof(ctxt: SyntaxContext, stopname: Name) -> Vec<Mrk> {\n+    with_sctable(|table| marksof_internal(ctxt, stopname, table))\n+}\n+\n+// the internal function for computing marks\n+// it's not clear to me whether it's better to use a [] mutable\n+// vector or a cons-list for this.\n+fn marksof_internal(ctxt: SyntaxContext,\n+                    stopname: Name,\n+                    table: &SCTable) -> Vec<Mrk> {\n+    let mut result = Vec::new();\n+    let mut loopvar = ctxt;\n+    loop {\n+        let table_entry = {\n+            let table = table.table.borrow();\n+            *table.get().get(loopvar as uint)\n+        };\n+        match table_entry {\n+            EmptyCtxt => {\n+                return result;\n+            },\n+            Mark(mark, tl) => {\n+                xorPush(&mut result, mark);\n+                loopvar = tl;\n+            },\n+            Rename(_,name,tl) => {\n+                // see MTWT for details on the purpose of the stopname.\n+                // short version: it prevents duplication of effort.\n+                if name == stopname {\n+                    return result;\n+                } else {\n+                    loopvar = tl;\n+                }\n+            }\n+            IllegalCtxt => fail!(\"expected resolvable context, got IllegalCtxt\")\n+        }\n+    }\n+}\n+\n+/// Return the outer mark for a context with a mark at the outside.\n+/// FAILS when outside is not a mark.\n+pub fn outer_mark(ctxt: SyntaxContext) -> Mrk {\n+    with_sctable(|sctable| {\n+        match *sctable.table.borrow().get().get(ctxt as uint) {\n+            Mark(mrk, _) => mrk,\n+            _ => fail!(\"can't retrieve outer mark when outside is not a mark\")\n+        }\n+    })\n+}\n+\n+// Push a name... unless it matches the one on top, in which\n+// case pop and discard (so two of the same marks cancel)\n+fn xorPush(marks: &mut Vec<Mrk>, mark: Mrk) {\n+    if (marks.len() > 0) && (*marks.last().unwrap() == mark) {\n+        marks.pop().unwrap();\n+    } else {\n+        marks.push(mark);\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use ast::*;\n+    use super::{resolve, xorPush, new_mark_internal, new_sctable_internal};\n+    use super::{new_rename_internal, marksof_internal, resolve_internal};\n+    use super::{SCTable, EmptyCtxt, Mark, Rename, IllegalCtxt};\n+    use std::vec_ng::Vec;\n+    use collections::HashMap;\n+\n+    #[test] fn xorpush_test () {\n+        let mut s = Vec::new();\n+        xorPush(&mut s, 14);\n+        assert_eq!(s.clone(), vec!(14));\n+        xorPush(&mut s, 14);\n+        assert_eq!(s.clone(), Vec::new());\n+        xorPush(&mut s, 14);\n+        assert_eq!(s.clone(), vec!(14));\n+        xorPush(&mut s, 15);\n+        assert_eq!(s.clone(), vec!(14, 15));\n+        xorPush(&mut s, 16);\n+        assert_eq!(s.clone(), vec!(14, 15, 16));\n+        xorPush(&mut s, 16);\n+        assert_eq!(s.clone(), vec!(14, 15));\n+        xorPush(&mut s, 15);\n+        assert_eq!(s.clone(), vec!(14));\n+    }\n+\n+    fn id(n: Name, s: SyntaxContext) -> Ident {\n+        Ident {name: n, ctxt: s}\n+    }\n+\n+    // because of the SCTable, I now need a tidy way of\n+    // creating syntax objects. Sigh.\n+    #[deriving(Clone, Eq, Show)]\n+    enum TestSC {\n+        M(Mrk),\n+        R(Ident,Name)\n+    }\n+\n+    // unfold a vector of TestSC values into a SCTable,\n+    // returning the resulting index\n+    fn unfold_test_sc(tscs : Vec<TestSC> , tail: SyntaxContext, table: &SCTable)\n+        -> SyntaxContext {\n+        tscs.rev_iter().fold(tail, |tail : SyntaxContext, tsc : &TestSC|\n+                  {match *tsc {\n+                      M(mrk) => new_mark_internal(mrk,tail,table),\n+                      R(ident,name) => new_rename_internal(ident,name,tail,table)}})\n+    }\n+\n+    // gather a SyntaxContext back into a vector of TestSCs\n+    fn refold_test_sc(mut sc: SyntaxContext, table : &SCTable) -> Vec<TestSC> {\n+        let mut result = Vec::new();\n+        loop {\n+            let table = table.table.borrow();\n+            match *table.get().get(sc as uint) {\n+                EmptyCtxt => {return result;},\n+                Mark(mrk,tail) => {\n+                    result.push(M(mrk));\n+                    sc = tail;\n+                    continue;\n+                },\n+                Rename(id,name,tail) => {\n+                    result.push(R(id,name));\n+                    sc = tail;\n+                    continue;\n+                }\n+                IllegalCtxt => fail!(\"expected resolvable context, got IllegalCtxt\")\n+            }\n+        }\n+    }\n+\n+    #[test] fn test_unfold_refold(){\n+        let mut t = new_sctable_internal();\n+\n+        let test_sc = vec!(M(3),R(id(101,0),14),M(9));\n+        assert_eq!(unfold_test_sc(test_sc.clone(),EMPTY_CTXT,&mut t),4);\n+        {\n+            let table = t.table.borrow();\n+            assert!(*table.get().get(2) == Mark(9,0));\n+            assert!(*table.get().get(3) == Rename(id(101,0),14,2));\n+            assert!(*table.get().get(4) == Mark(3,3));\n+        }\n+        assert_eq!(refold_test_sc(4,&t),test_sc);\n+    }\n+\n+    // extend a syntax context with a sequence of marks given\n+    // in a vector. v[0] will be the outermost mark.\n+    fn unfold_marks(mrks: Vec<Mrk> , tail: SyntaxContext, table: &SCTable)\n+                    -> SyntaxContext {\n+        mrks.rev_iter().fold(tail, |tail:SyntaxContext, mrk:&Mrk|\n+                   {new_mark_internal(*mrk,tail,table)})\n+    }\n+\n+    #[test] fn unfold_marks_test() {\n+        let mut t = new_sctable_internal();\n+\n+        assert_eq!(unfold_marks(vec!(3,7),EMPTY_CTXT,&mut t),3);\n+        {\n+            let table = t.table.borrow();\n+            assert!(*table.get().get(2) == Mark(7,0));\n+            assert!(*table.get().get(3) == Mark(3,2));\n+        }\n+    }\n+\n+    #[test] fn test_marksof () {\n+        let stopname = 242;\n+        let name1 = 243;\n+        let mut t = new_sctable_internal();\n+        assert_eq!(marksof_internal (EMPTY_CTXT,stopname,&t),Vec::new());\n+        // FIXME #5074: ANF'd to dodge nested calls\n+        { let ans = unfold_marks(vec!(4,98),EMPTY_CTXT,&mut t);\n+         assert_eq! (marksof_internal (ans,stopname,&t),vec!(4,98));}\n+        // does xoring work?\n+        { let ans = unfold_marks(vec!(5,5,16),EMPTY_CTXT,&mut t);\n+         assert_eq! (marksof_internal (ans,stopname,&t), vec!(16));}\n+        // does nested xoring work?\n+        { let ans = unfold_marks(vec!(5,10,10,5,16),EMPTY_CTXT,&mut t);\n+         assert_eq! (marksof_internal (ans, stopname,&t), vec!(16));}\n+        // rename where stop doesn't match:\n+        { let chain = vec!(M(9),\n+                        R(id(name1,\n+                             new_mark_internal (4, EMPTY_CTXT,&mut t)),\n+                          100101102),\n+                        M(14));\n+         let ans = unfold_test_sc(chain,EMPTY_CTXT,&mut t);\n+         assert_eq! (marksof_internal (ans, stopname, &t), vec!(9,14));}\n+        // rename where stop does match\n+        { let name1sc = new_mark_internal(4, EMPTY_CTXT, &mut t);\n+         let chain = vec!(M(9),\n+                       R(id(name1, name1sc),\n+                         stopname),\n+                       M(14));\n+         let ans = unfold_test_sc(chain,EMPTY_CTXT,&mut t);\n+         assert_eq! (marksof_internal (ans, stopname, &t), vec!(9)); }\n+    }\n+\n+\n+    #[test] fn resolve_tests () {\n+        let a = 40;\n+        let mut t = new_sctable_internal();\n+        let mut rt = HashMap::new();\n+        // - ctxt is MT\n+        assert_eq!(resolve_internal(id(a,EMPTY_CTXT),&mut t, &mut rt),a);\n+        // - simple ignored marks\n+        { let sc = unfold_marks(vec!(1,2,3),EMPTY_CTXT,&mut t);\n+         assert_eq!(resolve_internal(id(a,sc),&mut t, &mut rt),a);}\n+        // - orthogonal rename where names don't match\n+        { let sc = unfold_test_sc(vec!(R(id(50,EMPTY_CTXT),51),M(12)),EMPTY_CTXT,&mut t);\n+         assert_eq!(resolve_internal(id(a,sc),&mut t, &mut rt),a);}\n+        // - rename where names do match, but marks don't\n+        { let sc1 = new_mark_internal(1,EMPTY_CTXT,&mut t);\n+         let sc = unfold_test_sc(vec!(R(id(a,sc1),50),\n+                                   M(1),\n+                                   M(2)),\n+                                 EMPTY_CTXT,&mut t);\n+        assert_eq!(resolve_internal(id(a,sc),&mut t, &mut rt), a);}\n+        // - rename where names and marks match\n+        { let sc1 = unfold_test_sc(vec!(M(1),M(2)),EMPTY_CTXT,&mut t);\n+         let sc = unfold_test_sc(vec!(R(id(a,sc1),50),M(1),M(2)),EMPTY_CTXT,&mut t);\n+         assert_eq!(resolve_internal(id(a,sc),&mut t, &mut rt), 50); }\n+        // - rename where names and marks match by literal sharing\n+        { let sc1 = unfold_test_sc(vec!(M(1),M(2)),EMPTY_CTXT,&mut t);\n+         let sc = unfold_test_sc(vec!(R(id(a,sc1),50)),sc1,&mut t);\n+         assert_eq!(resolve_internal(id(a,sc),&mut t, &mut rt), 50); }\n+        // - two renames of the same var.. can only happen if you use\n+        // local-expand to prevent the inner binding from being renamed\n+        // during the rename-pass caused by the first:\n+        println!(\"about to run bad test\");\n+        { let sc = unfold_test_sc(vec!(R(id(a,EMPTY_CTXT),50),\n+                                    R(id(a,EMPTY_CTXT),51)),\n+                                  EMPTY_CTXT,&mut t);\n+         assert_eq!(resolve_internal(id(a,sc),&mut t, &mut rt), 51); }\n+        // the simplest double-rename:\n+        { let a_to_a50 = new_rename_internal(id(a,EMPTY_CTXT),50,EMPTY_CTXT,&mut t);\n+         let a50_to_a51 = new_rename_internal(id(a,a_to_a50),51,a_to_a50,&mut t);\n+         assert_eq!(resolve_internal(id(a,a50_to_a51),&mut t, &mut rt),51);\n+         // mark on the outside doesn't stop rename:\n+         let sc = new_mark_internal(9,a50_to_a51,&mut t);\n+         assert_eq!(resolve_internal(id(a,sc),&mut t, &mut rt),51);\n+         // but mark on the inside does:\n+         let a50_to_a51_b = unfold_test_sc(vec!(R(id(a,a_to_a50),51),\n+                                              M(9)),\n+                                           a_to_a50,\n+                                           &mut t);\n+         assert_eq!(resolve_internal(id(a,a50_to_a51_b),&mut t, &mut rt),50);}\n+    }\n+\n+    #[test] fn mtwt_resolve_test(){\n+        let a = 40;\n+        assert_eq!(resolve(id(a,EMPTY_CTXT)),a);\n+    }\n+\n+\n+    #[test] fn hashing_tests () {\n+        let mut t = new_sctable_internal();\n+        assert_eq!(new_mark_internal(12,EMPTY_CTXT,&mut t),2);\n+        assert_eq!(new_mark_internal(13,EMPTY_CTXT,&mut t),3);\n+        // using the same one again should result in the same index:\n+        assert_eq!(new_mark_internal(12,EMPTY_CTXT,&mut t),2);\n+        // I'm assuming that the rename table will behave the same....\n+    }\n+\n+    #[test] fn resolve_table_hashing_tests() {\n+        let mut t = new_sctable_internal();\n+        let mut rt = HashMap::new();\n+        assert_eq!(rt.len(),0);\n+        resolve_internal(id(30,EMPTY_CTXT),&mut t, &mut rt);\n+        assert_eq!(rt.len(),1);\n+        resolve_internal(id(39,EMPTY_CTXT),&mut t, &mut rt);\n+        assert_eq!(rt.len(),2);\n+        resolve_internal(id(30,EMPTY_CTXT),&mut t, &mut rt);\n+        assert_eq!(rt.len(),2);\n+    }\n+}"}, {"sha": "0d7e54bb69d36226f1fe2c9e4b539ae5ae22fd74", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8a55cd988f272ec70fc7d5adf6e61ed8ee6a8e78/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a55cd988f272ec70fc7d5adf6e61ed8ee6a8e78/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=8a55cd988f272ec70fc7d5adf6e61ed8ee6a8e78", "patch": "@@ -87,6 +87,7 @@ pub mod ext {\n         pub mod macro_rules;\n     }\n \n+    pub mod mtwt;\n \n     pub mod cfg;\n     pub mod fmt;"}, {"sha": "71ee32b4aade7e434f112bf5977a013a66099a07", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8a55cd988f272ec70fc7d5adf6e61ed8ee6a8e78/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a55cd988f272ec70fc7d5adf6e61ed8ee6a8e78/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=8a55cd988f272ec70fc7d5adf6e61ed8ee6a8e78", "patch": "@@ -11,6 +11,7 @@\n use ast;\n use ast::{P, Ident, Name, Mrk};\n use ast_util;\n+use ext::mtwt;\n use parse::token;\n use util::interner::{RcStr, StrInterner};\n use util::interner;\n@@ -722,7 +723,7 @@ pub fn is_reserved_keyword(tok: &Token) -> bool {\n pub fn mtwt_token_eq(t1 : &Token, t2 : &Token) -> bool {\n     match (t1,t2) {\n         (&IDENT(id1,_),&IDENT(id2,_)) | (&LIFETIME(id1),&LIFETIME(id2)) =>\n-            ast_util::mtwt_resolve(id1) == ast_util::mtwt_resolve(id2),\n+            mtwt::resolve(id1) == mtwt::resolve(id2),\n         _ => *t1 == *t2\n     }\n }\n@@ -732,10 +733,10 @@ pub fn mtwt_token_eq(t1 : &Token, t2 : &Token) -> bool {\n mod test {\n     use super::*;\n     use ast;\n-    use ast_util;\n+    use ext::mtwt;\n \n     fn mark_ident(id : ast::Ident, m : ast::Mrk) -> ast::Ident {\n-        ast::Ident{name:id.name,ctxt:ast_util::new_mark(m,id.ctxt)}\n+        ast::Ident{name:id.name,ctxt:mtwt::new_mark(m,id.ctxt)}\n     }\n \n     #[test] fn mtwt_token_eq_test() {"}]}