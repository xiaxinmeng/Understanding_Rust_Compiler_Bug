{"sha": "4ccf374b4a2ef24862d365783b70217bbfbf3bc7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRjY2YzNzRiNGEyZWYyNDg2MmQzNjU3ODNiNzAyMTdiYmZiZjNiYzc=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-03-24T18:14:35Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-03-24T20:42:19Z"}, "message": "std: Zero memory when calling `read_to_end()`\n\nThis commit alters the behavior of the `Read::read_to_end()` method to zero all\nmemory instead of passing an uninitialized buffer to `read`. This change is\nmotivated by the [discussion on the internals forum][discuss] where the\nconclusion has been that the standard library will not expose uninitialized\nmemory.\n\n[discuss]: http://internals.rust-lang.org/t/uninitialized-memory/1652\n\nCloses #20314", "tree": {"sha": "60c3123cc35450231bbb7a8b4efc4bce6ef192d8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/60c3123cc35450231bbb7a8b4efc4bce6ef192d8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4ccf374b4a2ef24862d365783b70217bbfbf3bc7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4ccf374b4a2ef24862d365783b70217bbfbf3bc7", "html_url": "https://github.com/rust-lang/rust/commit/4ccf374b4a2ef24862d365783b70217bbfbf3bc7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4ccf374b4a2ef24862d365783b70217bbfbf3bc7/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "28a0b25f424090255966273994748a9f9901059f", "url": "https://api.github.com/repos/rust-lang/rust/commits/28a0b25f424090255966273994748a9f9901059f", "html_url": "https://github.com/rust-lang/rust/commit/28a0b25f424090255966273994748a9f9901059f"}], "stats": {"total": 44, "additions": 14, "deletions": 30}, "files": [{"sha": "33c4156fc0ce799608567afa1ab37d30bb443632", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 14, "deletions": 30, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/4ccf374b4a2ef24862d365783b70217bbfbf3bc7/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ccf374b4a2ef24862d365783b70217bbfbf3bc7/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=4ccf374b4a2ef24862d365783b70217bbfbf3bc7", "patch": "@@ -16,13 +16,12 @@ use cmp;\n use unicode::str as core_str;\n use error as std_error;\n use fmt;\n-use iter::Iterator;\n+use iter::{self, Iterator, IteratorExt, Extend};\n use marker::Sized;\n use ops::{Drop, FnOnce};\n use option::Option::{self, Some, None};\n use result::Result::{Ok, Err};\n use result;\n-use slice;\n use string::String;\n use str;\n use vec::Vec;\n@@ -50,41 +49,26 @@ mod stdio;\n const DEFAULT_BUF_SIZE: usize = 64 * 1024;\n \n // Acquires a slice of the vector `v` from its length to its capacity\n-// (uninitialized data), reads into it, and then updates the length.\n+// (after initializing the data), reads into it, and then updates the length.\n //\n // This function is leveraged to efficiently read some bytes into a destination\n // vector without extra copying and taking advantage of the space that's already\n // in `v`.\n-//\n-// The buffer we're passing down, however, is pointing at uninitialized data\n-// (the end of a `Vec`), and many operations will be *much* faster if we don't\n-// have to zero it out. In order to prevent LLVM from generating an `undef`\n-// value when reads happen from this uninitialized memory, we force LLVM to\n-// think it's initialized by sending it through a black box. This should prevent\n-// actual undefined behavior after optimizations.\n fn with_end_to_cap<F>(v: &mut Vec<u8>, f: F) -> Result<usize>\n     where F: FnOnce(&mut [u8]) -> Result<usize>\n {\n-    unsafe {\n-        let n = try!(f({\n-            let base = v.as_mut_ptr().offset(v.len() as isize);\n-            black_box(slice::from_raw_parts_mut(base,\n-                                                v.capacity() - v.len()))\n-        }));\n-\n-        // If the closure (typically a `read` implementation) reported that it\n-        // read a larger number of bytes than the vector actually has, we need\n-        // to be sure to clamp the vector to at most its capacity.\n-        let new_len = cmp::min(v.capacity(), v.len() + n);\n-        v.set_len(new_len);\n-        return Ok(n);\n-    }\n-\n-    // Semi-hack used to prevent LLVM from retaining any assumptions about\n-    // `dummy` over this function call\n-    unsafe fn black_box<T>(mut dummy: T) -> T {\n-        asm!(\"\" :: \"r\"(&mut dummy) : \"memory\");\n-        dummy\n+    let len = v.len();\n+    let new_area = v.capacity() - len;\n+    v.extend(iter::repeat(0).take(new_area));\n+    match f(&mut v[len..]) {\n+        Ok(n) => {\n+            v.truncate(len + n);\n+            Ok(n)\n+        }\n+        Err(e) => {\n+            v.truncate(len);\n+            Err(e)\n+        }\n     }\n }\n "}]}