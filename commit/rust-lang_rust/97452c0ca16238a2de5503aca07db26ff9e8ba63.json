{"sha": "97452c0ca16238a2de5503aca07db26ff9e8ba63", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk3NDUyYzBjYTE2MjM4YTJkZTU1MDNhY2EwN2RiMjZmZjllOGJhNjM=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-08-02T22:42:56Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-08-02T22:53:28Z"}, "message": "Remove modes from map API and replace with regions.\n\nAPI is (for now) mostly by value, there are options to use it by\nreference if you like.  Hash and equality functions must be pure\nand by reference (forward looking to the day when something\nlike send_map becomes the standard map).", "tree": {"sha": "47ef430d1671ab297bc192009aa74a23723a42fc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/47ef430d1671ab297bc192009aa74a23723a42fc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/97452c0ca16238a2de5503aca07db26ff9e8ba63", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/97452c0ca16238a2de5503aca07db26ff9e8ba63", "html_url": "https://github.com/rust-lang/rust/commit/97452c0ca16238a2de5503aca07db26ff9e8ba63", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/97452c0ca16238a2de5503aca07db26ff9e8ba63/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "476ce459bd3b687658e566c75d0fb73281450d67", "url": "https://api.github.com/repos/rust-lang/rust/commits/476ce459bd3b687658e566c75d0fb73281450d67", "html_url": "https://github.com/rust-lang/rust/commit/476ce459bd3b687658e566c75d0fb73281450d67"}], "stats": {"total": 1053, "additions": 579, "deletions": 474}, "files": [{"sha": "8478afc7ea2588b315341d87f44129cbbf8e9aa7", "filename": "doc/rust.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/97452c0ca16238a2de5503aca07db26ff9e8ba63/doc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/97452c0ca16238a2de5503aca07db26ff9e8ba63/doc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frust.md?ref=97452c0ca16238a2de5503aca07db26ff9e8ba63", "patch": "@@ -734,7 +734,7 @@ An example of imports:\n ~~~~\n import foo = core::info;\n import core::float::sin;\n-import core::str::{slice, hash};\n+import core::str::{slice, to_upper};\n import core::option::some;\n \n fn main() {\n@@ -745,8 +745,8 @@ fn main() {\n     log(info, some(1.0));\n \n     // Equivalent to 'log(core::info,\n-    //                    core::str::hash(core::str::slice(~\"foo\", 0u, 1u)));'\n-    log(info, hash(slice(~\"foo\", 0u, 1u)));\n+    //                    core::str::to_upper(core::str::slice(~\"foo\", 0u, 1u)));'\n+    log(info, to_upper(slice(~\"foo\", 0u, 1u)));\n }\n ~~~~\n "}, {"sha": "4e836aad569551dfa5777cce545bfb089667794e", "filename": "src/cargo/cargo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/97452c0ca16238a2de5503aca07db26ff9e8ba63/src%2Fcargo%2Fcargo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97452c0ca16238a2de5503aca07db26ff9e8ba63/src%2Fcargo%2Fcargo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcargo%2Fcargo.rs?ref=97452c0ca16238a2de5503aca07db26ff9e8ba63", "patch": "@@ -1472,7 +1472,7 @@ fn print_pkg(s: source, p: package) {\n fn print_source(s: source) {\n     info(s.name + ~\" (\" + s.url + ~\")\");\n \n-    let pks = sort::merge_sort(|a, b| a < b, copy s.packages);\n+    let pks = sort::merge_sort(sys::shape_lt, copy s.packages);\n     let l = vec::len(pks);\n \n     print(io::with_str_writer(|writer| {"}, {"sha": "a336e18a63de7bf1346702ec35866b4c7ee44531", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/97452c0ca16238a2de5503aca07db26ff9e8ba63/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97452c0ca16238a2de5503aca07db26ff9e8ba63/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=97452c0ca16238a2de5503aca07db26ff9e8ba63", "patch": "@@ -8,3 +8,14 @@ trait eq {\n     pure fn eq(&&other: self) -> bool;\n }\n \n+pure fn lt<T: ord>(v1: &T, v2: &T) -> bool {\n+    v1.lt(*v2)\n+}\n+\n+pure fn le<T: ord eq>(v1: &T, v2: &T) -> bool {\n+    v1.lt(*v2) || v1.eq(*v2)\n+}\n+\n+pure fn eq<T: eq>(v1: &T, v2: &T) -> bool {\n+    v1.eq(*v2)\n+}"}, {"sha": "49313295edc07101c245102644f4fd6efe557f9f", "filename": "src/libcore/extfmt.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/97452c0ca16238a2de5503aca07db26ff9e8ba63/src%2Flibcore%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97452c0ca16238a2de5503aca07db26ff9e8ba63/src%2Flibcore%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fextfmt.rs?ref=97452c0ca16238a2de5503aca07db26ff9e8ba63", "patch": "@@ -96,13 +96,13 @@ mod ct {\n         while i < lim {\n             let size = str::utf8_char_width(s[i]);\n             let curr = str::slice(s, i, i+size);\n-            if str::eq(curr, ~\"%\") {\n+            if curr == ~\"%\" {\n                 i += 1u;\n                 if i >= lim {\n                     error(~\"unterminated conversion at end of string\");\n                 }\n                 let curr2 = str::slice(s, i, i+1u);\n-                if str::eq(curr2, ~\"%\") {\n+                if curr2 == ~\"%\" {\n                     buf += curr2;\n                     i += 1u;\n                 } else {\n@@ -232,27 +232,27 @@ mod ct {\n         // FIXME (#2249): Do we really want two signed types here?\n         // How important is it to be printf compatible?\n         let t =\n-            if str::eq(tstr, ~\"b\") {\n+            if tstr == ~\"b\" {\n                 ty_bool\n-            } else if str::eq(tstr, ~\"s\") {\n+            } else if tstr == ~\"s\" {\n                 ty_str\n-            } else if str::eq(tstr, ~\"c\") {\n+            } else if tstr == ~\"c\" {\n                 ty_char\n-            } else if str::eq(tstr, ~\"d\") || str::eq(tstr, ~\"i\") {\n+            } else if tstr == ~\"d\" || tstr == ~\"i\" {\n                 ty_int(signed)\n-            } else if str::eq(tstr, ~\"u\") {\n+            } else if tstr == ~\"u\" {\n                 ty_int(unsigned)\n-            } else if str::eq(tstr, ~\"x\") {\n+            } else if tstr == ~\"x\" {\n                 ty_hex(case_lower)\n-            } else if str::eq(tstr, ~\"X\") {\n+            } else if tstr == ~\"X\" {\n                 ty_hex(case_upper)\n-            } else if str::eq(tstr, ~\"t\") {\n+            } else if tstr == ~\"t\" {\n                 ty_bits\n-            } else if str::eq(tstr, ~\"o\") {\n+            } else if tstr == ~\"o\" {\n                 ty_octal\n-            } else if str::eq(tstr, ~\"f\") {\n+            } else if tstr == ~\"f\" {\n                 ty_float\n-            } else if str::eq(tstr, ~\"?\") {\n+            } else if tstr == ~\"?\" {\n                 ty_poly\n             } else { error(~\"unknown type in conversion: \" + tstr) };\n         return {ty: t, next: i + 1u};"}, {"sha": "82b6d00d9093c38c651638a496b3ce223dc1feef", "filename": "src/libcore/int-template.rs", "status": "modified", "additions": 17, "deletions": 18, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/97452c0ca16238a2de5503aca07db26ff9e8ba63/src%2Flibcore%2Fint-template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97452c0ca16238a2de5503aca07db26ff9e8ba63/src%2Flibcore%2Fint-template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fint-template.rs?ref=97452c0ca16238a2de5503aca07db26ff9e8ba63", "patch": "@@ -19,18 +19,18 @@ const max_value: T = min_value - 1 as T;\n pure fn min(&&x: T, &&y: T) -> T { if x < y { x } else { y } }\n pure fn max(&&x: T, &&y: T) -> T { if x > y { x } else { y } }\n \n-pure fn add(&&x: T, &&y: T) -> T { x + y }\n-pure fn sub(&&x: T, &&y: T) -> T { x - y }\n-pure fn mul(&&x: T, &&y: T) -> T { x * y }\n-pure fn div(&&x: T, &&y: T) -> T { x / y }\n-pure fn rem(&&x: T, &&y: T) -> T { x % y }\n-\n-pure fn lt(&&x: T, &&y: T) -> bool { x < y }\n-pure fn le(&&x: T, &&y: T) -> bool { x <= y }\n-pure fn eq(&&x: T, &&y: T) -> bool { x == y }\n-pure fn ne(&&x: T, &&y: T) -> bool { x != y }\n-pure fn ge(&&x: T, &&y: T) -> bool { x >= y }\n-pure fn gt(&&x: T, &&y: T) -> bool { x > y }\n+pure fn add(x: &T, y: &T) -> T { *x + *y }\n+pure fn sub(x: &T, y: &T) -> T { *x - *y }\n+pure fn mul(x: &T, y: &T) -> T { *x * *y }\n+pure fn div(x: &T, y: &T) -> T { *x / *y }\n+pure fn rem(x: &T, y: &T) -> T { *x % *y }\n+\n+pure fn lt(x: &T, y: &T) -> bool { *x < *y }\n+pure fn le(x: &T, y: &T) -> bool { *x <= *y }\n+pure fn eq(x: &T, y: &T) -> bool { *x == *y }\n+pure fn ne(x: &T, y: &T) -> bool { *x != *y }\n+pure fn ge(x: &T, y: &T) -> bool { *x >= *y }\n+pure fn gt(x: &T, y: &T) -> bool { *x > *y }\n \n pure fn is_positive(x: T) -> bool { x > 0 as T }\n pure fn is_negative(x: T) -> bool { x < 0 as T }\n@@ -221,12 +221,11 @@ fn test_parse_buf() {\n \n #[test]\n fn test_to_str() {\n-    import str::eq;\n-    assert (eq(to_str(0 as T, 10u), ~\"0\"));\n-    assert (eq(to_str(1 as T, 10u), ~\"1\"));\n-    assert (eq(to_str(-1 as T, 10u), ~\"-1\"));\n-    assert (eq(to_str(127 as T, 16u), ~\"7f\"));\n-    assert (eq(to_str(100 as T, 10u), ~\"100\"));\n+    assert (to_str(0 as T, 10u) == ~\"0\");\n+    assert (to_str(1 as T, 10u) == ~\"1\");\n+    assert (to_str(-1 as T, 10u) == ~\"-1\");\n+    assert (to_str(127 as T, 16u) == ~\"7f\");\n+    assert (to_str(100 as T, 10u) == ~\"100\");\n }\n \n #[test]"}, {"sha": "2ed6155edc0155d5f44294f29a73d8552121043f", "filename": "src/libcore/int-template/int.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/97452c0ca16238a2de5503aca07db26ff9e8ba63/src%2Flibcore%2Fint-template%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97452c0ca16238a2de5503aca07db26ff9e8ba63/src%2Flibcore%2Fint-template%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fint-template%2Fint.rs?ref=97452c0ca16238a2de5503aca07db26ff9e8ba63", "patch": "@@ -7,7 +7,7 @@ const bits: T = 32 as T;\n const bits: T = 64 as T;\n \n /// Produce a uint suitable for use in a hash table\n-pure fn hash(&&x: int) -> uint { return x as uint; }\n+pure fn hash(x: &int) -> uint { *x as uint }\n \n /// Returns `base` raised to the power of `exponent`\n fn pow(base: int, exponent: uint) -> int {"}, {"sha": "4b5898279dd609a35cfb7cc2095da5e62a314510", "filename": "src/libcore/io.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/97452c0ca16238a2de5503aca07db26ff9e8ba63/src%2Flibcore%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97452c0ca16238a2de5503aca07db26ff9e8ba63/src%2Flibcore%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fio.rs?ref=97452c0ca16238a2de5503aca07db26ff9e8ba63", "patch": "@@ -811,7 +811,7 @@ mod tests {\n         let inp: io::reader = result::get(io::file_reader(tmpfile));\n         let frood2: ~str = inp.read_c_str();\n         log(debug, frood2);\n-        assert (str::eq(frood, frood2));\n+        assert frood == frood2;\n     }\n \n     #[test]"}, {"sha": "a2e3ca02bc373d3ea3c960a742ea9987c0c6e86c", "filename": "src/libcore/os.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/97452c0ca16238a2de5503aca07db26ff9e8ba63/src%2Flibcore%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97452c0ca16238a2de5503aca07db26ff9e8ba63/src%2Flibcore%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fos.rs?ref=97452c0ca16238a2de5503aca07db26ff9e8ba63", "patch": "@@ -579,7 +579,7 @@ fn list_dir(p: path) -> ~[~str] {\n     }\n \n     do rustrt::rust_list_files(star(p)).filter |filename| {\n-        !str::eq(filename, ~\".\") && !str::eq(filename, ~\"..\")\n+        filename != ~\".\" && filename != ~\"..\"\n     }\n }\n "}, {"sha": "9b76f64bcc56da107aef9001ee4446f68f10f879", "filename": "src/libcore/str.rs", "status": "modified", "additions": 34, "deletions": 30, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/97452c0ca16238a2de5503aca07db26ff9e8ba63/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97452c0ca16238a2de5503aca07db26ff9e8ba63/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=97452c0ca16238a2de5503aca07db26ff9e8ba63", "patch": "@@ -637,8 +637,8 @@ pure fn replace(s: &str, from: &str, to: &str) -> ~str {\n Section: Comparing strings\n */\n \n-/// Bytewise string equality\n-pure fn eq(&&a: ~str, &&b: ~str) -> bool {\n+/// Bytewise slice equality\n+pure fn eq_slice(a: &str, b: &str) -> bool {\n     // FIXME (#2627): This should just be \"a == b\" but that calls into the\n     // shape code.\n     let a_len = a.len();\n@@ -655,12 +655,17 @@ pure fn eq(&&a: ~str, &&b: ~str) -> bool {\n     return true;\n }\n \n+/// Bytewise string equality\n+pure fn eq(a: &~str, b: &~str) -> bool {\n+    eq_slice(*a, *b)\n+}\n+\n /// Bytewise less than or equal\n-pure fn le(&&a: ~str, &&b: ~str) -> bool { a <= b }\n+pure fn le(a: &~str, b: &~str) -> bool { *a <= *b }\n \n /// String hash function\n-pure fn hash(&&s: ~str) -> uint {\n-    let x = do as_bytes(s) |bytes| {\n+pure fn hash(s: &~str) -> uint {\n+    let x = do as_bytes(*s) |bytes| {\n         hash::hash_bytes(bytes)\n     };\n     return x as uint;\n@@ -2070,17 +2075,17 @@ mod tests {\n \n     #[test]\n     fn test_eq() {\n-        assert (eq(~\"\", ~\"\"));\n-        assert (eq(~\"foo\", ~\"foo\"));\n-        assert (!eq(~\"foo\", ~\"bar\"));\n+        assert (eq(&~\"\", &~\"\"));\n+        assert (eq(&~\"foo\", &~\"foo\"));\n+        assert (!eq(&~\"foo\", &~\"bar\"));\n     }\n \n     #[test]\n     fn test_le() {\n-        assert (le(~\"\", ~\"\"));\n-        assert (le(~\"\", ~\"foo\"));\n-        assert (le(~\"foo\", ~\"foo\"));\n-        assert (!eq(~\"foo\", ~\"bar\"));\n+        assert (le(&~\"\", &~\"\"));\n+        assert (le(&~\"\", &~\"foo\"));\n+        assert (le(&~\"foo\", &~\"foo\"));\n+        assert (!eq(&~\"foo\", &~\"bar\"));\n     }\n \n     #[test]\n@@ -2220,7 +2225,7 @@ mod tests {\n     fn test_split_str() {\n         fn t(s: ~str, sep: &a/str, i: int, k: ~str) {\n             let v = split_str(s, sep);\n-            assert eq(v[i], k);\n+            assert v[i] == k;\n         }\n \n         t(~\"--1233345--\", ~\"12345\", 0, ~\"--1233345--\");\n@@ -2348,7 +2353,7 @@ mod tests {\n     #[test]\n     fn test_substr() {\n         fn t(a: ~str, b: ~str, start: int) {\n-            assert (eq(substr(a, start as uint, len(b)), b));\n+            assert substr(a, start as uint, len(b)) == b;\n         }\n         t(~\"hello\", ~\"llo\", 2);\n         t(~\"hello\", ~\"el\", 1);\n@@ -2357,7 +2362,7 @@ mod tests {\n \n     #[test]\n     fn test_concat() {\n-        fn t(v: ~[~str], s: ~str) { assert (eq(concat(v), s)); }\n+        fn t(v: ~[~str], s: ~str) { assert concat(v) == s; }\n         t(~[~\"you\", ~\"know\", ~\"I'm\", ~\"no\", ~\"good\"], ~\"youknowI'mnogood\");\n         let v: ~[~str] = ~[];\n         t(v, ~\"\");\n@@ -2367,7 +2372,7 @@ mod tests {\n     #[test]\n     fn test_connect() {\n         fn t(v: ~[~str], sep: ~str, s: ~str) {\n-            assert (eq(connect(v, sep), s));\n+            assert connect(v, sep) == s;\n         }\n         t(~[~\"you\", ~\"know\", ~\"I'm\", ~\"no\", ~\"good\"],\n           ~\" \", ~\"you know I'm no good\");\n@@ -2385,7 +2390,7 @@ mod tests {\n         let input = ~\"abcDEF\" + unicode + ~\"xyz:.;\";\n         let expected = ~\"ABCDEF\" + unicode + ~\"XYZ:.;\";\n         let actual = to_upper(input);\n-        assert (eq(expected, actual));\n+        assert expected == actual;\n     }\n \n     #[test]\n@@ -2398,9 +2403,9 @@ mod tests {\n     #[test]\n     fn test_unsafe_slice() {\n         unsafe {\n-            assert (eq(~\"ab\", unsafe::slice_bytes(~\"abc\", 0u, 2u)));\n-            assert (eq(~\"bc\", unsafe::slice_bytes(~\"abc\", 1u, 3u)));\n-            assert (eq(~\"\", unsafe::slice_bytes(~\"abc\", 1u, 1u)));\n+            assert ~\"ab\" == unsafe::slice_bytes(~\"abc\", 0u, 2u);\n+            assert ~\"bc\" == unsafe::slice_bytes(~\"abc\", 1u, 3u);\n+            assert ~\"\" == unsafe::slice_bytes(~\"abc\", 1u, 1u);\n             fn a_million_letter_a() -> ~str {\n                 let mut i = 0;\n                 let mut rs = ~\"\";\n@@ -2413,9 +2418,8 @@ mod tests {\n                 while i < 100000 { push_str(rs, ~\"aaaaa\"); i += 1; }\n                 return rs;\n             }\n-            assert eq(half_a_million_letter_a(),\n-                      unsafe::slice_bytes(a_million_letter_a(),\n-                                          0u, 500000u));\n+            assert half_a_million_letter_a() ==\n+                unsafe::slice_bytes(a_million_letter_a(), 0u, 500000u);\n         }\n     }\n \n@@ -2501,10 +2505,10 @@ mod tests {\n \n     #[test]\n     fn test_slice() {\n-        assert (eq(~\"ab\", slice(~\"abc\", 0u, 2u)));\n-        assert (eq(~\"bc\", slice(~\"abc\", 1u, 3u)));\n-        assert (eq(~\"\", slice(~\"abc\", 1u, 1u)));\n-        assert (eq(~\"\\u65e5\", slice(~\"\\u65e5\\u672c\", 0u, 3u)));\n+        assert ~\"ab\" == slice(~\"abc\", 0u, 2u);\n+        assert ~\"bc\" == slice(~\"abc\", 1u, 3u);\n+        assert ~\"\" == slice(~\"abc\", 1u, 1u);\n+        assert ~\"\\u65e5\" == slice(~\"\\u65e5\\u672c\", 0u, 3u);\n \n         let data = ~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\";\n         assert ~\"\u0e1b\" == slice(data, 0u, 3u);\n@@ -2524,8 +2528,8 @@ mod tests {\n             while i < 100000 { push_str(rs, ~\"\u534e\u534e\u534e\u534e\u534e\"); i += 1; }\n             return rs;\n         }\n-        assert eq(half_a_million_letter_X(),\n-                  slice(a_million_letter_X(), 0u, 3u * 500000u));\n+        assert half_a_million_letter_X() ==\n+            slice(a_million_letter_X(), 0u, 3u * 500000u);\n     }\n \n     #[test]\n@@ -2709,7 +2713,7 @@ mod tests {\n             let s = ~\"hello\";\n             let sb = as_buf(s, |b, _l| b);\n             let s_cstr = unsafe::from_buf(sb);\n-            assert (eq(s_cstr, s));\n+            assert s_cstr == s;\n         }\n     }\n "}, {"sha": "f0075d841898cab9ac8f38304a53707d01b4f89a", "filename": "src/libcore/sys.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/97452c0ca16238a2de5503aca07db26ff9e8ba63/src%2Flibcore%2Fsys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97452c0ca16238a2de5503aca07db26ff9e8ba63/src%2Flibcore%2Fsys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsys.rs?ref=97452c0ca16238a2de5503aca07db26ff9e8ba63", "patch": "@@ -8,6 +8,7 @@ export pref_align_of;\n export refcount;\n export log_str;\n export lock_and_signal, condition, methods;\n+export shape_eq, shape_lt, shape_le;\n \n import task::atomically;\n \n@@ -39,6 +40,20 @@ extern mod rusti {\n     fn min_align_of<T>() -> uint;\n }\n \n+/// Compares contents of two pointers using the default method.\n+/// Equivalent to `*x1 == *x2`.  Useful for hashtables.\n+pure fn shape_eq<T>(x1: &T, x2: &T) -> bool {\n+    *x1 == *x2\n+}\n+\n+pure fn shape_lt<T>(x1: &T, x2: &T) -> bool {\n+    *x1 < *x2\n+}\n+\n+pure fn shape_le<T>(x1: &T, x2: &T) -> bool {\n+    *x1 < *x2\n+}\n+\n /**\n  * Returns a pointer to a type descriptor.\n  *"}, {"sha": "49ea87785ecf6270afa4c331190bc4e0df33c3c0", "filename": "src/libcore/uint-template.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/97452c0ca16238a2de5503aca07db26ff9e8ba63/src%2Flibcore%2Fuint-template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97452c0ca16238a2de5503aca07db26ff9e8ba63/src%2Flibcore%2Fuint-template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fuint-template.rs?ref=97452c0ca16238a2de5503aca07db26ff9e8ba63", "patch": "@@ -19,18 +19,18 @@ const max_value: T = 0 as T - 1 as T;\n pure fn min(&&x: T, &&y: T) -> T { if x < y { x } else { y } }\n pure fn max(&&x: T, &&y: T) -> T { if x > y { x } else { y } }\n \n-pure fn add(&&x: T, &&y: T) -> T { x + y }\n-pure fn sub(&&x: T, &&y: T) -> T { x - y }\n-pure fn mul(&&x: T, &&y: T) -> T { x * y }\n-pure fn div(&&x: T, &&y: T) -> T { x / y }\n-pure fn rem(&&x: T, &&y: T) -> T { x % y }\n-\n-pure fn lt(&&x: T, &&y: T) -> bool { x < y }\n-pure fn le(&&x: T, &&y: T) -> bool { x <= y }\n-pure fn eq(&&x: T, &&y: T) -> bool { x == y }\n-pure fn ne(&&x: T, &&y: T) -> bool { x != y }\n-pure fn ge(&&x: T, &&y: T) -> bool { x >= y }\n-pure fn gt(&&x: T, &&y: T) -> bool { x > y }\n+pure fn add(x: &T, y: &T) -> T { *x + *y }\n+pure fn sub(x: &T, y: &T) -> T { *x - *y }\n+pure fn mul(x: &T, y: &T) -> T { *x * *y }\n+pure fn div(x: &T, y: &T) -> T { *x / *y }\n+pure fn rem(x: &T, y: &T) -> T { *x % *y }\n+\n+pure fn lt(x: &T, y: &T) -> bool { *x < *y }\n+pure fn le(x: &T, y: &T) -> bool { *x <= *y }\n+pure fn eq(x: &T, y: &T) -> bool { *x == *y }\n+pure fn ne(x: &T, y: &T) -> bool { *x != *y }\n+pure fn ge(x: &T, y: &T) -> bool { *x >= *y }\n+pure fn gt(x: &T, y: &T) -> bool { *x > *y }\n \n pure fn is_positive(x: T) -> bool { x > 0 as T }\n pure fn is_negative(x: T) -> bool { x < 0 as T }"}, {"sha": "eb8b08a4fe5e639035f149b36efad4ffe9d9951d", "filename": "src/libcore/uint-template/uint.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/97452c0ca16238a2de5503aca07db26ff9e8ba63/src%2Flibcore%2Fuint-template%2Fuint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97452c0ca16238a2de5503aca07db26ff9e8ba63/src%2Flibcore%2Fuint-template%2Fuint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fuint-template%2Fuint.rs?ref=97452c0ca16238a2de5503aca07db26ff9e8ba63", "patch": "@@ -13,9 +13,9 @@ type T = uint;\n  * The smallest integer `q` such that `x/y <= q`.\n  */\n pure fn div_ceil(x: uint, y: uint) -> uint {\n-    let div = div(x, y);\n-    if x % y == 0u { return div;}\n-    else { return div + 1u; }\n+    let div = x / y;\n+    if x % y == 0u { div }\n+    else { div + 1u }\n }\n \n /**\n@@ -31,9 +31,9 @@ pure fn div_ceil(x: uint, y: uint) -> uint {\n  * The integer `q` closest to `x/y`.\n  */\n pure fn div_round(x: uint, y: uint) -> uint {\n-    let div = div(x, y);\n-    if x % y * 2u  < y { return div;}\n-    else { return div + 1u; }\n+    let div = x / y;\n+    if x % y * 2u  < y { div }\n+    else { div + 1u }\n }\n \n /**\n@@ -54,7 +54,7 @@ pure fn div_round(x: uint, y: uint) -> uint {\n pure fn div_floor(x: uint, y: uint) -> uint { return x / y; }\n \n /// Produce a uint suitable for use in a hash table\n-pure fn hash(&&x: uint) -> uint { return x; }\n+pure fn hash(x: &uint) -> uint { *x }\n \n /**\n  * Iterate over the range [`lo`..`hi`), or stop when requested"}, {"sha": "c02560bf6c36c8970476f238fdd28f38c20f2008", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/97452c0ca16238a2de5503aca07db26ff9e8ba63/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97452c0ca16238a2de5503aca07db26ff9e8ba63/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=97452c0ca16238a2de5503aca07db26ff9e8ba63", "patch": "@@ -1654,13 +1654,13 @@ mod u8 {\n     export memcpy, memmove;\n \n     /// Bytewise string comparison\n-    pure fn cmp(&&a: ~[u8], &&b: ~[u8]) -> int {\n-        let a_len = len(a);\n-        let b_len = len(b);\n+    pure fn cmp(a: &~[u8], b: &~[u8]) -> int {\n+        let a_len = len(*a);\n+        let b_len = len(*b);\n         let n = uint::min(a_len, b_len) as libc::size_t;\n         let r = unsafe {\n-            libc::memcmp(unsafe::to_ptr(a) as *libc::c_void,\n-                         unsafe::to_ptr(b) as *libc::c_void, n) as int\n+            libc::memcmp(unsafe::to_ptr(*a) as *libc::c_void,\n+                         unsafe::to_ptr(*b) as *libc::c_void, n) as int\n         };\n \n         if r != 0 { r } else {\n@@ -1675,26 +1675,26 @@ mod u8 {\n     }\n \n     /// Bytewise less than or equal\n-    pure fn lt(&&a: ~[u8], &&b: ~[u8]) -> bool { cmp(a, b) < 0 }\n+    pure fn lt(a: &~[u8], b: &~[u8]) -> bool { cmp(a, b) < 0 }\n \n     /// Bytewise less than or equal\n-    pure fn le(&&a: ~[u8], &&b: ~[u8]) -> bool { cmp(a, b) <= 0 }\n+    pure fn le(a: &~[u8], b: &~[u8]) -> bool { cmp(a, b) <= 0 }\n \n     /// Bytewise equality\n-    pure fn eq(&&a: ~[u8], &&b: ~[u8]) -> bool { unsafe { cmp(a, b) == 0 } }\n+    pure fn eq(a: &~[u8], b: &~[u8]) -> bool { cmp(a, b) == 0 }\n \n     /// Bytewise inequality\n-    pure fn ne(&&a: ~[u8], &&b: ~[u8]) -> bool { unsafe { cmp(a, b) != 0 } }\n+    pure fn ne(a: &~[u8], b: &~[u8]) -> bool { cmp(a, b) != 0 }\n \n     /// Bytewise greater than or equal\n-    pure fn ge(&&a: ~[u8], &&b: ~[u8]) -> bool { cmp(a, b) >= 0 }\n+    pure fn ge(a: &~[u8], b: &~[u8]) -> bool { cmp(a, b) >= 0 }\n \n     /// Bytewise greater than\n-    pure fn gt(&&a: ~[u8], &&b: ~[u8]) -> bool { cmp(a, b) > 0 }\n+    pure fn gt(a: &~[u8], b: &~[u8]) -> bool { cmp(a, b) > 0 }\n \n     /// Byte-vec hash function\n-    fn hash(&&s: ~[u8]) -> uint {\n-        hash::hash_bytes(s) as uint\n+    fn hash(s: &~[u8]) -> uint {\n+        hash::hash_bytes(*s) as uint\n     }\n \n     /**"}, {"sha": "edc35ff7a87f873fcda13ee0143fd8cd33f53849", "filename": "src/libstd/bitv.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/97452c0ca16238a2de5503aca07db26ff9e8ba63/src%2Flibstd%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97452c0ca16238a2de5503aca07db26ff9e8ba63/src%2Flibstd%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbitv.rs?ref=97452c0ca16238a2de5503aca07db26ff9e8ba63", "patch": "@@ -391,8 +391,7 @@ class bitv {\n  * Each uint in the resulting vector has either value 0u or 1u.\n  */\n     fn to_vec() -> ~[uint] {\n-      let sub = |x| self.init_to_vec(x);\n-      return vec::from_fn::<uint>(self.nbits, sub);\n+        vec::from_fn(self.nbits, |x| self.init_to_vec(x))\n     }\n \n /**"}, {"sha": "ed0ee4ff5ed6f42b08e1183afb41ba05494aadc5", "filename": "src/libstd/getopts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/97452c0ca16238a2de5503aca07db26ff9e8ba63/src%2Flibstd%2Fgetopts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97452c0ca16238a2de5503aca07db26ff9e8ba63/src%2Flibstd%2Fgetopts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fgetopts.rs?ref=97452c0ca16238a2de5503aca07db26ff9e8ba63", "patch": "@@ -201,7 +201,7 @@ fn getopts(args: ~[~str], opts: ~[opt]) -> result unsafe {\n         let curlen = str::len(cur);\n         if !is_arg(cur) {\n             vec::push(free, cur);\n-        } else if str::eq(cur, ~\"--\") {\n+        } else if cur == ~\"--\" {\n             let mut j = i + 1u;\n             while j < l { vec::push(free, args[j]); j += 1u; }\n             break;"}, {"sha": "9faea572338224eaf6072d29d97b509c725796d6", "filename": "src/libstd/json.rs", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/97452c0ca16238a2de5503aca07db26ff9e8ba63/src%2Flibstd%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97452c0ca16238a2de5503aca07db26ff9e8ba63/src%2Flibstd%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fjson.rs?ref=97452c0ca16238a2de5503aca07db26ff9e8ba63", "patch": "@@ -588,18 +588,24 @@ impl of to_json for @~str {\n     fn to_json() -> json { string(self) }\n }\n \n-impl <A: to_json copy, B: to_json copy> of to_json for (A, B) {\n+impl <A: to_json, B: to_json> of to_json for (A, B) {\n     fn to_json() -> json {\n-        let (a, b) = self;\n-        list(@~[a.to_json(), b.to_json()])\n+        alt self {\n+          (a, b) => {\n+            list(@~[a.to_json(), b.to_json()])\n+          }\n+        }\n     }\n }\n \n-impl <A: to_json copy, B: to_json copy, C: to_json copy>\n+impl <A: to_json, B: to_json, C: to_json>\n   of to_json for (A, B, C) {\n     fn to_json() -> json {\n-        let (a, b, c) = self;\n-        list(@~[a.to_json(), b.to_json(), c.to_json()])\n+        alt self {\n+          (a, b, c) => {\n+            list(@~[a.to_json(), b.to_json(), c.to_json()])\n+          }\n+        }\n     }\n }\n "}, {"sha": "dd99c9945e12e4137f378c7103c86308879eb040", "filename": "src/libstd/map.rs", "status": "modified", "additions": 158, "deletions": 131, "changes": 289, "blob_url": "https://github.com/rust-lang/rust/blob/97452c0ca16238a2de5503aca07db26ff9e8ba63/src%2Flibstd%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97452c0ca16238a2de5503aca07db26ff9e8ba63/src%2Flibstd%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmap.rs?ref=97452c0ca16238a2de5503aca07db26ff9e8ba63", "patch": "@@ -1,5 +1,7 @@\n //! A map type\n \n+#[warn(deprecated_mode)];\n+\n import chained::hashmap;\n import io::writer_util;\n import to_str::to_str;\n@@ -15,16 +17,16 @@ export vec_from_set;\n  *\n  * The hash should concentrate entropy in the lower bits.\n  */\n-type hashfn<K> = fn@(K) -> uint;\n+type hashfn<K> = fn~(key: &K) -> uint;\n \n-type eqfn<K> = fn@(K, K) -> bool;\n+type eqfn<K> = fn~(key1: &K, key2: &K) -> bool;\n \n /// A convenience type to treat a hashmap as a set\n type set<K> = hashmap<K, ()>;\n \n type hashmap<K, V> = chained::t<K, V>;\n \n-trait map<K, V: copy> {\n+trait map<K: copy, V: copy> {\n     /// Return the number of elements in the map\n     fn size() -> uint;\n \n@@ -39,40 +41,50 @@ trait map<K, V: copy> {\n     fn insert(+K, +V) -> bool;\n \n     /// Returns true if the map contains a value for the specified key\n-    fn contains_key(K) -> bool;\n+    fn contains_key(+key: K) -> bool;\n+\n+    /// Returns true if the map contains a value for the specified\n+    /// key, taking the key by reference.\n+    fn contains_key_ref(key: &K) -> bool;\n \n     /**\n      * Get the value for the specified key. Fails if the key does not exist in\n      * the map.\n      */\n-    fn get(K) -> V;\n-\n-    /// Like get, but as an operator.\n-    fn [](K) -> V;\n+    fn get(+key: K) -> V;\n \n     /**\n      * Get the value for the specified key. If the key does not exist in\n      * the map then returns none.\n      */\n-    fn find(K) -> option<V>;\n+    fn find(+key: K) -> option<V>;\n \n     /**\n      * Remove and return a value from the map. If the key does not exist\n      * in the map then returns none.\n      */\n-    fn remove(K) -> option<V>;\n+    fn remove(+key: K) -> option<V>;\n \n     /// Clear the map, removing all key/value pairs.\n     fn clear();\n \n-    /// Iterate over all the key/value pairs in the map\n-    fn each(fn(K, V) -> bool);\n+    /// Iterate over all the key/value pairs in the map by value\n+    fn each(fn(+key: K, +value: V) -> bool);\n+\n+    /// Iterate over all the keys in the map by value\n+    fn each_key(fn(+key: K) -> bool);\n+\n+    /// Iterate over all the values in the map by value\n+    fn each_value(fn(+value: V) -> bool);\n \n-    /// Iterate over all the keys in the map\n-    fn each_key(fn(K) -> bool);\n+    /// Iterate over all the key/value pairs in the map by reference\n+    fn each_ref(fn(key: &K, value: &V) -> bool);\n \n-    /// Iterate over all the values in the map\n-    fn each_value(fn(V) -> bool);\n+    /// Iterate over all the keys in the map by reference\n+    fn each_key_ref(fn(key: &K) -> bool);\n+\n+    /// Iterate over all the values in the map by reference\n+    fn each_value_ref(fn(value: &V) -> bool);\n }\n \n mod util {\n@@ -93,53 +105,43 @@ mod chained {\n \n     const initial_capacity: uint = 32u; // 2^5\n \n-    type entry<K, V> = {\n-        hash: uint,\n-        key: K,\n-        mut value: V,\n-        mut next: chain<K, V>\n-    };\n-\n-    enum chain<K, V> {\n-        present(@entry<K, V>),\n-        absent\n+    struct entry<K, V> {\n+        hash: uint;\n+        key: K;\n+        value: V;\n+        mut next: option<@entry<K, V>>;\n     }\n \n-    type hashmap__<K, V> = {\n-        mut count: uint,\n-        mut chains: ~[mut chain<K,V>],\n-        hasher: hashfn<K>,\n-        eqer: eqfn<K>\n-    };\n-    type t<K, V> = @hashmap_<K, V>;\n-\n-    enum hashmap_<K, V> {\n-        hashmap_(@hashmap__<K, V>)\n+    struct hashmap_<K, V> {\n+        mut count: uint;\n+        mut chains: ~[mut option<@entry<K,V>>];\n+        hasher: hashfn<K>;\n+        eqer: eqfn<K>;\n     }\n \n-    type t<K, V> = hashmap_<K, V>;\n+    type t<K, V> = @hashmap_<K, V>;\n \n     enum search_result<K, V> {\n         not_found,\n         found_first(uint, @entry<K,V>),\n         found_after(@entry<K,V>, @entry<K,V>)\n     }\n \n-    impl private_methods<K, V: copy> for hashmap_<K, V> {\n-        fn search_rem(k: K, h: uint, idx: uint,\n+    impl private_methods<K, V: copy> for t<K, V> {\n+        fn search_rem(k: &K, h: uint, idx: uint,\n                       e_root: @entry<K,V>) -> search_result<K,V> {\n             let mut e0 = e_root;\n             let mut comp = 1u;   // for logging\n             loop {\n                 alt copy e0.next {\n-                  absent {\n+                  none {\n                     debug!{\"search_tbl: absent, comp %u, hash %u, idx %u\",\n                            comp, h, idx};\n                     return not_found;\n                   }\n-                  present(e1) {\n+                  some(e1) {\n                     comp += 1u;\n-                    if e1.hash == h && self.eqer(e1.key, k) {\n+                    if e1.hash == h && self.eqer(&e1.key, k) {\n                         debug!{\"search_tbl: present, comp %u, \\\n                                 hash %u, idx %u\",\n                                comp, h, idx};\n@@ -152,16 +154,16 @@ mod chained {\n             };\n         }\n \n-        fn search_tbl(k: K, h: uint) -> search_result<K,V> {\n+        fn search_tbl(k: &K, h: uint) -> search_result<K,V> {\n             let idx = h % vec::len(self.chains);\n             alt copy self.chains[idx] {\n-              absent {\n-                debug!{\"search_tbl: absent, comp %u, hash %u, idx %u\",\n+              none {\n+                debug!{\"search_tbl: none, comp %u, hash %u, idx %u\",\n                        0u, h, idx};\n                 return not_found;\n               }\n-              present(e) {\n-                if e.hash == h && self.eqer(e.key, k) {\n+              some(e) {\n+                if e.hash == h && self.eqer(&e.key, k) {\n                     debug!{\"search_tbl: present, comp %u, hash %u, idx %u\",\n                            1u, h, idx};\n                     return found_first(idx, e);\n@@ -173,25 +175,27 @@ mod chained {\n         }\n \n         fn rehash() {\n-            let n_old_chains = vec::len(self.chains);\n+            let n_old_chains = self.chains.len();\n             let n_new_chains: uint = uint::next_power_of_two(n_old_chains+1u);\n             let new_chains = chains(n_new_chains);\n             for self.each_entry |entry| {\n                 let idx = entry.hash % n_new_chains;\n                 entry.next = new_chains[idx];\n-                new_chains[idx] = present(entry);\n+                new_chains[idx] = some(entry);\n             }\n             self.chains = new_chains;\n         }\n \n         fn each_entry(blk: fn(@entry<K,V>) -> bool) {\n-            let mut i = 0u, n = vec::len(self.chains);\n+            // n.b. we can't use vec::iter() here because self.chains\n+            // is stored in a mutable location.\n+            let mut i = 0u, n = self.chains.len();\n             while i < n {\n                 let mut chain = self.chains[i];\n                 loop {\n                     chain = alt chain {\n-                      absent { break; }\n-                      present(entry) {\n+                      none { break; }\n+                      some(entry) {\n                         let next = entry.next;\n                         if !blk(entry) { return; }\n                         next\n@@ -203,10 +207,14 @@ mod chained {\n         }\n     }\n \n-    impl hashmap<K, V: copy> of map<K, V> for t<K, V> {\n+    impl hashmap<K: copy, V: copy> of map<K, V> for t<K, V> {\n         fn size() -> uint { self.count }\n \n-        fn contains_key(k: K) -> bool {\n+        fn contains_key(+k: K) -> bool {\n+            self.contains_key_ref(&k)\n+        }\n+\n+        fn contains_key_ref(k: &K) -> bool {\n             let hash = self.hasher(k);\n             alt self.search_tbl(k, hash) {\n               not_found {false}\n@@ -215,17 +223,17 @@ mod chained {\n         }\n \n         fn insert(+k: K, +v: V) -> bool {\n-            let hash = self.hasher(k);\n-            alt self.search_tbl(k, hash) {\n+            let hash = self.hasher(&k);\n+            alt self.search_tbl(&k, hash) {\n               not_found {\n                 self.count += 1u;\n                 let idx = hash % vec::len(self.chains);\n                 let old_chain = self.chains[idx];\n-                self.chains[idx] = present(@{\n+                self.chains[idx] = some(@entry {\n                     hash: hash,\n                     key: k,\n-                    mut value: v,\n-                    mut next: old_chain});\n+                    value: v,\n+                    next: old_chain});\n \n                 // consider rehashing if more 3/4 full\n                 let nchains = vec::len(self.chains);\n@@ -237,38 +245,43 @@ mod chained {\n \n                 return true;\n               }\n-              found_first(_, entry) {\n-                entry.value = v;\n+              found_first(idx, entry) {\n+                self.chains[idx] = some(@entry {\n+                    hash: hash,\n+                    key: k,\n+                    value: v,\n+                    next: entry.next});\n                 return false;\n               }\n-              found_after(_, entry) {\n-                entry.value = v;\n-                return false\n+              found_after(prev, entry) {\n+                prev.next = some(@entry {\n+                    hash: hash,\n+                    key: k,\n+                    value: v,\n+                    next: entry.next});\n+                return false;\n               }\n             }\n         }\n \n-        fn find(k: K) -> option<V> {\n-            alt self.search_tbl(k, self.hasher(k)) {\n+        fn find(+k: K) -> option<V> {\n+            alt self.search_tbl(&k, self.hasher(&k)) {\n               not_found {none}\n               found_first(_, entry) {some(entry.value)}\n               found_after(_, entry) {some(entry.value)}\n             }\n         }\n \n-        fn get(k: K) -> V {\n-            alt self.find(k) {\n-              some(v) => {v}\n-              none => {fail fmt!{\"Key not found in table: %?\", k}}\n+        fn get(+k: K) -> V {\n+            let opt_v = self.find(k);\n+            if opt_v.is_none() {\n+                fail fmt!{\"Key not found in table: %?\", k};\n             }\n+            option::unwrap(opt_v)\n         }\n \n-        fn [](k: K) -> V {\n-            self.get(k)\n-        }\n-\n-        fn remove(k: K) -> option<V> {\n-            alt self.search_tbl(k, self.hasher(k)) {\n+        fn remove(+k: K) -> option<V> {\n+            alt self.search_tbl(&k, self.hasher(&k)) {\n               not_found {none}\n               found_first(idx, entry) {\n                 self.count -= 1u;\n@@ -288,18 +301,34 @@ mod chained {\n             self.chains = chains(initial_capacity);\n         }\n \n-        fn each(blk: fn(K,V) -> bool) {\n+        fn each(blk: fn(+key: K, +value: V) -> bool) {\n+            self.each_ref(|k, v| blk(*k, *v))\n+        }\n+\n+        fn each_key(blk: fn(+key: K) -> bool) {\n+            self.each_key_ref(|p| blk(*p))\n+        }\n+\n+        fn each_value(blk: fn(+value: V) -> bool) {\n+            self.each_value_ref(|p| blk(*p))\n+        }\n+\n+        fn each_ref(blk: fn(key: &K, value: &V) -> bool) {\n             for self.each_entry |entry| {\n-                if !blk(entry.key, copy entry.value) { break; }\n+                if !blk(&entry.key, &entry.value) { break; }\n             }\n         }\n \n-        fn each_key(blk: fn(K) -> bool) { self.each(|k, _v| blk(k)) }\n+        fn each_key_ref(blk: fn(key: &K) -> bool) {\n+            self.each_ref(|k, _v| blk(k))\n+        }\n \n-        fn each_value(blk: fn(V) -> bool) { self.each(|_k, v| blk(v)) }\n+        fn each_value_ref(blk: fn(value: &V) -> bool) {\n+            self.each_ref(|_k, v| blk(v))\n+        }\n     }\n \n-    impl hashmap<K: to_str, V: to_str copy> of to_str for hashmap_<K, V> {\n+    impl hashmap<K: copy to_str, V: to_str copy> of to_str for t<K, V> {\n         fn to_writer(wr: io::writer) {\n             if self.count == 0u {\n                 wr.write_str(\"{}\");\n@@ -325,24 +354,23 @@ mod chained {\n         }\n     }\n \n-    impl hashmap<K, V: copy> of ops::index<K, V> for t<K, V> {\n-        pure fn index(k: K) -> V {\n+    impl hashmap<K: copy, V: copy> of ops::index<K, V> for t<K, V> {\n+        pure fn index(&&k: K) -> V {\n             unchecked {\n                 self.get(k)\n             }\n         }\n     }\n \n-\n-    fn chains<K,V>(nchains: uint) -> ~[mut chain<K,V>] {\n-        return vec::to_mut(vec::from_elem(nchains, absent));\n+    fn chains<K,V>(nchains: uint) -> ~[mut option<@entry<K,V>>] {\n+        vec::to_mut(vec::from_elem(nchains, none))\n     }\n \n-    fn mk<K, V: copy>(hasher: hashfn<K>, eqer: eqfn<K>) -> t<K,V> {\n-        let slf: t<K, V> = hashmap_(@{mut count: 0u,\n-                                      mut chains: chains(initial_capacity),\n+    fn mk<K, V: copy>(+hasher: hashfn<K>, +eqer: eqfn<K>) -> t<K,V> {\n+        let slf: t<K, V> = @hashmap_ {count: 0u,\n+                                      chains: chains(initial_capacity),\n                                       hasher: hasher,\n-                                      eqer: eqer});\n+                                      eqer: eqer};\n         slf\n     }\n }\n@@ -357,7 +385,7 @@ Parameters:\n hasher - The hash function for key type K\n eqer - The equality function for key type K\n */\n-fn hashmap<K: const, V: copy>(hasher: hashfn<K>, eqer: eqfn<K>)\n+fn hashmap<K: const, V: copy>(+hasher: hashfn<K>, +eqer: eqfn<K>)\n         -> hashmap<K, V> {\n     chained::mk(hasher, eqer)\n }\n@@ -369,7 +397,8 @@ fn str_hash<V: copy>() -> hashmap<~str, V> {\n \n /// Construct a hashmap for boxed string keys\n fn box_str_hash<V: copy>() -> hashmap<@~str, V> {\n-    return hashmap(|x: @~str| str::hash(*x), |x,y| str::eq(*x,*y));\n+    hashmap(|x: &@~str| str::hash(&**x),\n+            |x: &@~str, y: &@~str| str::eq(&**x, &**y))\n }\n \n /// Construct a hashmap for byte string keys\n@@ -388,13 +417,14 @@ fn uint_hash<V: copy>() -> hashmap<uint, V> {\n }\n \n /// Convenience function for adding keys to a hashmap with nil type keys\n-fn set_add<K: const copy>(set: set<K>, key: K) -> bool {\n-    return set.insert(key, ());\n+fn set_add<K: const copy>(set: set<K>, +key: K) -> bool {\n+    set.insert(key, ())\n }\n \n /// Convert a set into a vector.\n fn vec_from_set<T: copy>(s: set<T>) -> ~[T] {\n     let mut v = ~[];\n+    vec::reserve(v, s.size());\n     do s.each_key() |k| {\n         vec::push(v, k);\n         true\n@@ -403,8 +433,8 @@ fn vec_from_set<T: copy>(s: set<T>) -> ~[T] {\n }\n \n /// Construct a hashmap from a vector\n-fn hash_from_vec<K: const copy, V: copy>(hasher: hashfn<K>, eqer: eqfn<K>,\n-                                         items: ~[(K, V)]) -> hashmap<K, V> {\n+fn hash_from_vec<K: const copy, V: copy>(+hasher: hashfn<K>, +eqer: eqfn<K>,\n+                                         items: &[(K, V)]) -> hashmap<K, V> {\n     let map = hashmap(hasher, eqer);\n     do vec::iter(items) |item| {\n         let (key, value) = item;\n@@ -414,22 +444,22 @@ fn hash_from_vec<K: const copy, V: copy>(hasher: hashfn<K>, eqer: eqfn<K>,\n }\n \n /// Construct a hashmap from a vector with string keys\n-fn hash_from_strs<V: copy>(items: ~[(~str, V)]) -> hashmap<~str, V> {\n+fn hash_from_strs<V: copy>(items: &[(~str, V)]) -> hashmap<~str, V> {\n     hash_from_vec(str::hash, str::eq, items)\n }\n \n /// Construct a hashmap from a vector with byte keys\n-fn hash_from_bytes<V: copy>(items: ~[(~[u8], V)]) -> hashmap<~[u8], V> {\n+fn hash_from_bytes<V: copy>(items: &[(~[u8], V)]) -> hashmap<~[u8], V> {\n     hash_from_vec(vec::u8::hash, vec::u8::eq, items)\n }\n \n /// Construct a hashmap from a vector with int keys\n-fn hash_from_ints<V: copy>(items: ~[(int, V)]) -> hashmap<int, V> {\n+fn hash_from_ints<V: copy>(items: &[(int, V)]) -> hashmap<int, V> {\n     hash_from_vec(int::hash, int::eq, items)\n }\n \n /// Construct a hashmap from a vector with uint keys\n-fn hash_from_uints<V: copy>(items: ~[(uint, V)]) -> hashmap<uint, V> {\n+fn hash_from_uints<V: copy>(items: &[(uint, V)]) -> hashmap<uint, V> {\n     hash_from_vec(uint::hash, uint::eq, items)\n }\n \n@@ -439,15 +469,15 @@ mod tests {\n     #[test]\n     fn test_simple() {\n         debug!{\"*** starting test_simple\"};\n-        fn eq_uint(&&x: uint, &&y: uint) -> bool { return x == y; }\n-        fn uint_id(&&x: uint) -> uint { x }\n+        pure fn eq_uint(x: &uint, y: &uint) -> bool { *x == *y }\n+        pure fn uint_id(x: &uint) -> uint { *x }\n         let hasher_uint: map::hashfn<uint> = uint_id;\n         let eqer_uint: map::eqfn<uint> = eq_uint;\n         let hasher_str: map::hashfn<~str> = str::hash;\n         let eqer_str: map::eqfn<~str> = str::eq;\n         debug!{\"uint -> uint\"};\n         let hm_uu: map::hashmap<uint, uint> =\n-            map::hashmap::<uint, uint>(hasher_uint, eqer_uint);\n+            map::hashmap::<uint, uint>(copy hasher_uint, copy eqer_uint);\n         assert (hm_uu.insert(10u, 12u));\n         assert (hm_uu.insert(11u, 13u));\n         assert (hm_uu.insert(12u, 14u));\n@@ -463,7 +493,7 @@ mod tests {\n         let twelve: ~str = ~\"twelve\";\n         debug!{\"str -> uint\"};\n         let hm_su: map::hashmap<~str, uint> =\n-            map::hashmap::<~str, uint>(hasher_str, eqer_str);\n+            map::hashmap::<~str, uint>(copy hasher_str, copy eqer_str);\n         assert (hm_su.insert(~\"ten\", 12u));\n         assert (hm_su.insert(eleven, 13u));\n         assert (hm_su.insert(~\"twelve\", 14u));\n@@ -477,30 +507,30 @@ mod tests {\n         assert (hm_su.get(~\"twelve\") == 12u);\n         debug!{\"uint -> str\"};\n         let hm_us: map::hashmap<uint, ~str> =\n-            map::hashmap::<uint, ~str>(hasher_uint, eqer_uint);\n+            map::hashmap::<uint, ~str>(copy hasher_uint, copy eqer_uint);\n         assert (hm_us.insert(10u, ~\"twelve\"));\n         assert (hm_us.insert(11u, ~\"thirteen\"));\n         assert (hm_us.insert(12u, ~\"fourteen\"));\n-        assert (str::eq(hm_us.get(11u), ~\"thirteen\"));\n-        assert (str::eq(hm_us.get(12u), ~\"fourteen\"));\n-        assert (str::eq(hm_us.get(10u), ~\"twelve\"));\n+        assert hm_us.get(11u) == ~\"thirteen\";\n+        assert hm_us.get(12u) == ~\"fourteen\";\n+        assert hm_us.get(10u) == ~\"twelve\";\n         assert (!hm_us.insert(12u, ~\"fourteen\"));\n-        assert (str::eq(hm_us.get(12u), ~\"fourteen\"));\n+        assert hm_us.get(12u) == ~\"fourteen\";\n         assert (!hm_us.insert(12u, ~\"twelve\"));\n-        assert (str::eq(hm_us.get(12u), ~\"twelve\"));\n+        assert hm_us.get(12u) == ~\"twelve\";\n         debug!{\"str -> str\"};\n         let hm_ss: map::hashmap<~str, ~str> =\n-            map::hashmap::<~str, ~str>(hasher_str, eqer_str);\n+            map::hashmap::<~str, ~str>(copy hasher_str, copy eqer_str);\n         assert (hm_ss.insert(ten, ~\"twelve\"));\n         assert (hm_ss.insert(eleven, ~\"thirteen\"));\n         assert (hm_ss.insert(twelve, ~\"fourteen\"));\n-        assert (str::eq(hm_ss.get(~\"eleven\"), ~\"thirteen\"));\n-        assert (str::eq(hm_ss.get(~\"twelve\"), ~\"fourteen\"));\n-        assert (str::eq(hm_ss.get(~\"ten\"), ~\"twelve\"));\n+        assert hm_ss.get(~\"eleven\") == ~\"thirteen\";\n+        assert hm_ss.get(~\"twelve\") == ~\"fourteen\";\n+        assert hm_ss.get(~\"ten\") == ~\"twelve\";\n         assert (!hm_ss.insert(~\"twelve\", ~\"fourteen\"));\n-        assert (str::eq(hm_ss.get(~\"twelve\"), ~\"fourteen\"));\n+        assert hm_ss.get(~\"twelve\") == ~\"fourteen\";\n         assert (!hm_ss.insert(~\"twelve\", ~\"twelve\"));\n-        assert (str::eq(hm_ss.get(~\"twelve\"), ~\"twelve\"));\n+        assert hm_ss.get(~\"twelve\") == ~\"twelve\";\n         debug!{\"*** finished test_simple\"};\n     }\n \n@@ -512,8 +542,8 @@ mod tests {\n     fn test_growth() {\n         debug!{\"*** starting test_growth\"};\n         let num_to_insert: uint = 64u;\n-        fn eq_uint(&&x: uint, &&y: uint) -> bool { return x == y; }\n-        fn uint_id(&&x: uint) -> uint { x }\n+        pure fn eq_uint(x: &uint, y: &uint) -> bool { *x == *y }\n+        pure fn uint_id(x: &uint) -> uint { *x }\n         debug!{\"uint -> uint\"};\n         let hasher_uint: map::hashfn<uint> = uint_id;\n         let eqer_uint: map::eqfn<uint> = eq_uint;\n@@ -560,22 +590,20 @@ mod tests {\n             debug!{\"get(\\\"%s\\\") = \\\"%s\\\"\",\n                    uint::to_str(i, 2u),\n                    hm_ss.get(uint::to_str(i, 2u))};\n-            assert (str::eq(hm_ss.get(uint::to_str(i, 2u)),\n-                            uint::to_str(i * i, 2u)));\n+            assert hm_ss.get(uint::to_str(i, 2u)) == uint::to_str(i * i, 2u);\n             i += 1u;\n         }\n         assert (hm_ss.insert(uint::to_str(num_to_insert, 2u),\n                              uint::to_str(17u, 2u)));\n-        assert (str::eq(hm_ss.get(uint::to_str(num_to_insert, 2u)),\n-                        uint::to_str(17u, 2u)));\n+        assert hm_ss.get(uint::to_str(num_to_insert, 2u)) ==\n+            uint::to_str(17u, 2u);\n         debug!{\"-----\"};\n         i = 0u;\n         while i < num_to_insert {\n             debug!{\"get(\\\"%s\\\") = \\\"%s\\\"\",\n                    uint::to_str(i, 2u),\n                    hm_ss.get(uint::to_str(i, 2u))};\n-            assert (str::eq(hm_ss.get(uint::to_str(i, 2u)),\n-                            uint::to_str(i * i, 2u)));\n+            assert hm_ss.get(uint::to_str(i, 2u)) == uint::to_str(i * i, 2u);\n             i += 1u;\n         }\n         debug!{\"*** finished test_growth\"};\n@@ -585,16 +613,15 @@ mod tests {\n     fn test_removal() {\n         debug!{\"*** starting test_removal\"};\n         let num_to_insert: uint = 64u;\n-        fn eq(&&x: uint, &&y: uint) -> bool { return x == y; }\n-        fn hash(&&u: uint) -> uint {\n+        fn eq(x: &uint, y: &uint) -> bool { *x == *y }\n+        fn hash(u: &uint) -> uint {\n             // This hash function intentionally causes collisions between\n             // consecutive integer pairs.\n-\n-            return u / 2u * 2u;\n+            *u / 2u * 2u\n         }\n-        assert (hash(0u) == hash(1u));\n-        assert (hash(2u) == hash(3u));\n-        assert (hash(0u) != hash(2u));\n+        assert (hash(&0u) == hash(&1u));\n+        assert (hash(&2u) == hash(&3u));\n+        assert (hash(&0u) != hash(&2u));\n         let hasher: map::hashfn<uint> = hash;\n         let eqer: map::eqfn<uint> = eq;\n         let hm: map::hashmap<uint, uint> ="}, {"sha": "b8bdf581218f7397813ccb3e668fab2f521e06fd", "filename": "src/libstd/smallintmap.rs", "status": "modified", "additions": 29, "deletions": 11, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/97452c0ca16238a2de5503aca07db26ff9e8ba63/src%2Flibstd%2Fsmallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97452c0ca16238a2de5503aca07db26ff9e8ba63/src%2Flibstd%2Fsmallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsmallintmap.rs?ref=97452c0ca16238a2de5503aca07db26ff9e8ba63", "patch": "@@ -74,23 +74,27 @@ impl <V: copy> of map::map<uint, V> for smallintmap<V> {\n         insert(self, key, value);\n         return !exists;\n     }\n-    fn remove(&&key: uint) -> option<V> {\n-        if key >= self.v.len() { return none; }\n+    fn remove(+key: uint) -> option<V> {\n+        if key >= self.v.len() {\n+            return none;\n+        }\n         let old = self.v.get_elt(key);\n         self.v.set_elt(key, none);\n         old\n     }\n     fn clear() {\n         self.v.set(~[mut]);\n     }\n-    fn contains_key(&&key: uint) -> bool {\n+    fn contains_key(+key: uint) -> bool {\n         contains_key(self, key)\n     }\n-    fn get(&&key: uint) -> V { get(self, key) }\n-    fn [](&&key: uint) -> V { get(self, key) }\n-    fn find(&&key: uint) -> option<V> { find(self, key) }\n+    fn contains_key_ref(key: &uint) -> bool {\n+        contains_key(self, *key)\n+    }\n+    fn get(+key: uint) -> V { get(self, key) }\n+    fn find(+key: uint) -> option<V> { find(self, key) }\n     fn rehash() { fail }\n-    fn each(it: fn(&&uint, V) -> bool) {\n+    fn each(it: fn(+key: uint, +value: V) -> bool) {\n         let mut idx = 0u, l = self.v.len();\n         while idx < l {\n             alt self.v.get_elt(idx) {\n@@ -102,15 +106,29 @@ impl <V: copy> of map::map<uint, V> for smallintmap<V> {\n             idx += 1u;\n         }\n     }\n-    fn each_key(it: fn(&&uint) -> bool) {\n+    fn each_key(it: fn(+key: uint) -> bool) {\n+        self.each(|k, _v| it(k))\n+    }\n+    fn each_value(it: fn(+value: V) -> bool) {\n+        self.each(|_k, v| it(v))\n+    }\n+    fn each_ref(it: fn(key: &uint, value: &V) -> bool) {\n         let mut idx = 0u, l = self.v.len();\n         while idx < l {\n-            if self.v.get_elt(idx) != none && !it(idx) { return; }\n+            alt self.v.get_elt(idx) {\n+              some(elt) {\n+                if !it(&idx, &elt) { break; }\n+              }\n+              none { }\n+            }\n             idx += 1u;\n         }\n     }\n-    fn each_value(it: fn(V) -> bool) {\n-        self.each(|_i, v| it(v));\n+    fn each_key_ref(blk: fn(key: &uint) -> bool) {\n+        self.each_ref(|k, _v| blk(k))\n+    }\n+    fn each_value_ref(blk: fn(value: &V) -> bool) {\n+        self.each_ref(|_k, v| blk(v))\n     }\n }\n "}, {"sha": "5cd2a8aa53225ad3b63a027e903ffb15262f0e58", "filename": "src/libstd/sort.rs", "status": "modified", "additions": 15, "deletions": 18, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/97452c0ca16238a2de5503aca07db26ff9e8ba63/src%2Flibstd%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97452c0ca16238a2de5503aca07db26ff9e8ba63/src%2Flibstd%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsort.rs?ref=97452c0ca16238a2de5503aca07db26ff9e8ba63", "patch": "@@ -1,13 +1,13 @@\n //! Sorting methods\n import vec::{len, push};\n-import int::{eq, ord};\n+import core::cmp::{eq, ord};\n \n export le;\n export merge_sort;\n export quick_sort;\n export quick_sort3;\n \n-type le<T> = fn(T, T) -> bool;\n+type le<T> = pure fn(v1: &T, v2: &T) -> bool;\n \n /**\n  * Merge sort. Returns a new vector containing the sorted list.\n@@ -43,7 +43,7 @@ fn merge_sort<T: copy>(le: le<T>, v: ~[const T]) -> ~[T] {\n         let b_len = len(b);\n         let mut b_ix = 0u;\n         while a_ix < a_len && b_ix < b_len {\n-            if le(a[a_ix], b[b_ix]) {\n+            if le(&a[a_ix], &b[b_ix]) {\n                 vec::push(rs, a[a_ix]);\n                 a_ix += 1u;\n             } else { vec::push(rs, b[b_ix]); b_ix += 1u; }\n@@ -61,7 +61,7 @@ fn part<T: copy>(compare_func: le<T>, arr: ~[mut T], left: uint,\n     let mut storage_index: uint = left;\n     let mut i: uint = left;\n     while i < right {\n-        if compare_func(copy arr[i], pivot_value) {\n+        if compare_func(&arr[i], &pivot_value) {\n             arr[i] <-> arr[storage_index];\n             storage_index += 1u;\n         }\n@@ -105,19 +105,19 @@ fn qsort3<T: copy>(compare_func_lt: le<T>, compare_func_eq: le<T>,\n     let mut q: int = j;\n     loop {\n         i += 1;\n-        while compare_func_lt(copy arr[i], v) { i += 1; }\n+        while compare_func_lt(&arr[i], &v) { i += 1; }\n         j -= 1;\n-        while compare_func_lt(v, copy arr[j]) {\n+        while compare_func_lt(&v, &arr[j]) {\n             if j == left { break; }\n             j -= 1;\n         }\n         if i >= j { break; }\n         arr[i] <-> arr[j];\n-        if compare_func_eq(copy arr[i], v) {\n+        if compare_func_eq(&arr[i], &v) {\n             p += 1;\n             arr[p] <-> arr[i];\n         }\n-        if compare_func_eq(v, copy arr[j]) {\n+        if compare_func_eq(&v, &arr[j]) {\n             q -= 1;\n             arr[j] <-> arr[q];\n         }\n@@ -154,9 +154,8 @@ fn qsort3<T: copy>(compare_func_lt: le<T>, compare_func_eq: le<T>,\n  * This is an unstable sort.\n  */\n fn quick_sort3<T: copy ord eq>(arr: ~[mut T]) {\n-    if len::<T>(arr) == 0u { return; }\n-    qsort3::<T>(|x, y| x.lt(y), |x, y| x.eq(y), arr, 0,\n-                (len::<T>(arr) as int) - 1);\n+    if arr.len() <= 1 { return; }\n+    qsort3(core::cmp::lt, core::cmp::eq, arr, 0, (arr.len() - 1) as int);\n }\n \n #[cfg(test)]\n@@ -202,9 +201,8 @@ mod test_qsort3 {\n mod test_qsort {\n     fn check_sort(v1: ~[mut int], v2: ~[mut int]) {\n         let len = vec::len::<int>(v1);\n-        fn leual(&&a: int, &&b: int) -> bool { return a <= b; }\n-        let f = leual;\n-        quick_sort::<int>(f, v1);\n+        pure fn leual(a: &int, b: &int) -> bool { *a <= *b }\n+        quick_sort::<int>(leual, v1);\n         let mut i = 0u;\n         while i < len {\n             log(debug, v2[i]);\n@@ -245,8 +243,7 @@ mod test_qsort {\n \n         let expected = ~[1, 2, 3];\n \n-        fn le(&&a: int, &&b: int) -> bool { int::le(a, b) }\n-        sort::quick_sort(le, names);\n+        sort::quick_sort(int::le, names);\n \n         let immut_names = vec::from_mut(names);\n \n@@ -264,7 +261,7 @@ mod tests {\n \n     fn check_sort(v1: ~[int], v2: ~[int]) {\n         let len = vec::len::<int>(v1);\n-        fn le(&&a: int, &&b: int) -> bool { return a <= b; }\n+        pure fn le(a: &int, b: &int) -> bool { *a <= *b }\n         let f = le;\n         let v3 = merge_sort::<int>(f, v1);\n         let mut i = 0u;\n@@ -294,7 +291,7 @@ mod tests {\n \n     #[test]\n     fn test_merge_sort_mutable() {\n-        fn le(&&a: int, &&b: int) -> bool { return a <= b; }\n+        pure fn le(a: &int, b: &int) -> bool { *a <= *b }\n         let v1 = ~[mut 3, 2, 1];\n         let v2 = merge_sort(le, v1);\n         assert v2 == ~[1, 2, 3];"}, {"sha": "20fb9622e3d55e18afbb51b509595a5603558312", "filename": "src/libstd/term.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/97452c0ca16238a2de5503aca07db26ff9e8ba63/src%2Flibstd%2Fterm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97452c0ca16238a2de5503aca07db26ff9e8ba63/src%2Flibstd%2Fterm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fterm.rs?ref=97452c0ca16238a2de5503aca07db26ff9e8ba63", "patch": "@@ -38,7 +38,7 @@ fn color_supported() -> bool {\n     return alt os::getenv(~\"TERM\") {\n           option::some(env) {\n             for vec::each(supported_terms) |term| {\n-                if str::eq(term, env) { return true; }\n+                if term == env { return true; }\n             }\n             false\n           }"}, {"sha": "8d2673df5c6518701023cfa29361baadda985568", "filename": "src/libstd/test.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/97452c0ca16238a2de5503aca07db26ff9e8ba63/src%2Flibstd%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97452c0ca16238a2de5503aca07db26ff9e8ba63/src%2Flibstd%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftest.rs?ref=97452c0ca16238a2de5503aca07db26ff9e8ba63", "patch": "@@ -372,13 +372,12 @@ fn filter_tests(opts: test_opts,\n     };\n \n     // Sort the tests alphabetically\n-    filtered =\n-        {\n-            fn lteq(t1: test_desc, t2: test_desc) -> bool {\n-                str::le(t1.name, t2.name)\n-            }\n-        sort::merge_sort(|x,y| lteq(x, y), filtered)\n-        };\n+    filtered = {\n+        pure fn lteq(t1: &test_desc, t2: &test_desc) -> bool {\n+            str::le(&t1.name, &t2.name)\n+        }\n+        sort::merge_sort(lteq, filtered)\n+    };\n \n     return filtered;\n }\n@@ -486,7 +485,7 @@ mod tests {\n         let args = ~[~\"progname\", ~\"filter\"];\n         let opts = alt parse_opts(args) { either::left(o) { o }\n           _ { fail ~\"Malformed arg in first_free_arg_should_be_a_filter\"; } };\n-        assert (str::eq(~\"filter\", option::get(opts.filter)));\n+        assert ~\"filter\" == option::get(opts.filter);\n     }\n \n     #[test]"}, {"sha": "21d2de2d31b22ac55927808d56dbc2b5d4d9c641", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/97452c0ca16238a2de5503aca07db26ff9e8ba63/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97452c0ca16238a2de5503aca07db26ff9e8ba63/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=97452c0ca16238a2de5503aca07db26ff9e8ba63", "patch": "@@ -230,18 +230,18 @@ pure fn is_call_expr(e: @expr) -> bool {\n     alt e.node { expr_call(_, _, _) { true } _ { false } }\n }\n \n-fn eq_ty(&&a: @ty, &&b: @ty) -> bool { return box::ptr_eq(a, b); }\n+pure fn eq_ty(a: &@ty, b: &@ty) -> bool { box::ptr_eq(*a, *b) }\n \n-fn hash_ty(&&t: @ty) -> uint {\n+pure fn hash_ty(t: &@ty) -> uint {\n     let res = (t.span.lo << 16u) + t.span.hi;\n     return res;\n }\n \n-fn def_eq(a: ast::def_id, b: ast::def_id) -> bool {\n-    return a.crate == b.crate && a.node == b.node;\n+pure fn def_eq(a: &ast::def_id, b: &ast::def_id) -> bool {\n+    a.crate == b.crate && a.node == b.node\n }\n \n-fn hash_def(d: ast::def_id) -> uint {\n+pure fn hash_def(d: &ast::def_id) -> uint {\n     let mut h = 5381u;\n     h = (h << 5u) + h ^ (d.crate as uint);\n     h = (h << 5u) + h ^ (d.node as uint);"}, {"sha": "da0dec061bbdd126ddc126ee1bb64ccf249f3d5a", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/97452c0ca16238a2de5503aca07db26ff9e8ba63/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97452c0ca16238a2de5503aca07db26ff9e8ba63/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=97452c0ca16238a2de5503aca07db26ff9e8ba63", "patch": "@@ -289,15 +289,15 @@ fn last_meta_item_list_by_name(\n // FIXME (#607): This needs to sort by meta_item variant in addition to\n // the item name (See [Fixme-sorting])\n fn sort_meta_items(+items: ~[@ast::meta_item]) -> ~[@ast::meta_item] {\n-    fn lteq(&&ma: @ast::meta_item, &&mb: @ast::meta_item) -> bool {\n-        fn key(m: @ast::meta_item) -> ast::ident {\n+    pure fn lteq(ma: &@ast::meta_item, mb: &@ast::meta_item) -> bool {\n+        pure fn key(m: &ast::meta_item) -> ast::ident {\n             alt m.node {\n               ast::meta_word(name) { /* FIXME (#2543) */ copy name }\n               ast::meta_name_value(name, _) { /* FIXME (#2543) */ copy name }\n               ast::meta_list(name, _) { /* FIXME (#2543) */ copy name }\n             }\n         }\n-        return key(ma) <= key(mb);\n+        key(*ma) <= key(*mb)\n     }\n \n     // This is sort of stupid here, converting to a vec of mutables and back"}, {"sha": "ec0b69d652c6eb9508f649f5fd9b2396247c0435", "filename": "src/libsyntax/ext/qquote.rs", "status": "modified", "additions": 17, "deletions": 7, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/97452c0ca16238a2de5503aca07db26ff9e8ba63/src%2Flibsyntax%2Fext%2Fqquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97452c0ca16238a2de5503aca07db26ff9e8ba63/src%2Flibsyntax%2Fext%2Fqquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fqquote.rs?ref=97452c0ca16238a2de5503aca07db26ff9e8ba63", "patch": "@@ -13,10 +13,14 @@ import io::*;\n \n import codemap::span;\n \n-type aq_ctxt = @{lo: uint,\n-                 gather: dvec<{lo: uint, hi: uint,\n-                               e: @ast::expr,\n-                               constr: ~str}>};\n+struct gather_item {\n+    lo: uint;\n+    hi: uint;\n+    e: @ast::expr;\n+    constr: ~str;\n+}\n+\n+type aq_ctxt = @{lo: uint, gather: dvec<gather_item>};\n enum fragment {\n     from_expr(@ast::expr),\n     from_ty(@ast::ty)\n@@ -110,7 +114,10 @@ fn gather_anti_quotes<N: qq_helper>(lo: uint, node: N) -> aq_ctxt\n     // FIXME (#2250): Maybe this is an overkill (merge_sort), it might\n     // be better to just keep the gather array in sorted order.\n     do cx.gather.swap |v| {\n-        vec::to_mut(std::sort::merge_sort(|a,b| a.lo < b.lo, v))\n+        pure fn by_lo(a: &gather_item, b: &gather_item) -> bool {\n+            a.lo < b.lo\n+        }\n+        vec::to_mut(std::sort::merge_sort(by_lo, v))\n     };\n     return cx;\n }\n@@ -119,8 +126,11 @@ fn visit_aq<T:qq_helper>(node: T, constr: ~str, &&cx: aq_ctxt, v: vt<aq_ctxt>)\n {\n     alt (node.extract_mac()) {\n       some(mac_aq(sp, e)) {\n-        cx.gather.push({lo: sp.lo - cx.lo, hi: sp.hi - cx.lo,\n-                        e: e, constr: constr});\n+        cx.gather.push(gather_item {\n+            lo: sp.lo - cx.lo,\n+            hi: sp.hi - cx.lo,\n+            e: e,\n+            constr: constr});\n       }\n       _ {node.visit(cx, v);}\n     }"}, {"sha": "092238e17be64257be90800c5b6c38895a4760a0", "filename": "src/libsyntax/parse/common.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/97452c0ca16238a2de5503aca07db26ff9e8ba63/src%2Flibsyntax%2Fparse%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97452c0ca16238a2de5503aca07db26ff9e8ba63/src%2Flibsyntax%2Fparse%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcommon.rs?ref=97452c0ca16238a2de5503aca07db26ff9e8ba63", "patch": "@@ -112,14 +112,14 @@ impl parser_common of parser_common for parser {\n \n     // A sanity check that the word we are asking for is a known keyword\n     fn require_keyword(word: ~str) {\n-        if !self.keywords.contains_key(word) {\n+        if !self.keywords.contains_key_ref(&word) {\n             self.bug(fmt!{\"unknown keyword: %s\", word});\n         }\n     }\n \n     fn token_is_word(word: ~str, ++tok: token::token) -> bool {\n         alt tok {\n-          token::IDENT(sid, false) => { str::eq(word, *self.get_str(sid)) }\n+          token::IDENT(sid, false) => { word == *self.get_str(sid) }\n           _ => { false }\n         }\n     }\n@@ -136,7 +136,7 @@ impl parser_common of parser_common for parser {\n     fn is_any_keyword(tok: token::token) -> bool {\n         alt tok {\n           token::IDENT(sid, false) {\n-            self.keywords.contains_key(*self.get_str(sid))\n+            self.keywords.contains_key_ref(self.get_str(sid))\n           }\n           _ { false }\n         }\n@@ -148,7 +148,7 @@ impl parser_common of parser_common for parser {\n         let mut bump = false;\n         let val = alt self.token {\n           token::IDENT(sid, false) {\n-            if str::eq(word, *self.get_str(sid)) {\n+            if word == *self.get_str(sid) {\n                 bump = true;\n                 true\n             } else { false }\n@@ -169,7 +169,7 @@ impl parser_common of parser_common for parser {\n     }\n \n     fn is_restricted_keyword(word: ~str) -> bool {\n-        self.restricted_keywords.contains_key(word)\n+        self.restricted_keywords.contains_key_ref(&word)\n     }\n \n     fn check_restricted_keywords() {"}, {"sha": "9583be3461d8798d0e11293d54c1f4bac87a0488", "filename": "src/libsyntax/parse/lexer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/97452c0ca16238a2de5503aca07db26ff9e8ba63/src%2Flibsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97452c0ca16238a2de5503aca07db26ff9e8ba63/src%2Flibsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer.rs?ref=97452c0ca16238a2de5503aca07db26ff9e8ba63", "patch": "@@ -456,7 +456,7 @@ fn next_token_inner(rdr: string_reader) -> token::token {\n             bump(rdr);\n             c = rdr.curr;\n         }\n-        if str::eq(accum_str, ~\"_\") { return token::UNDERSCORE; }\n+        if accum_str == ~\"_\" { return token::UNDERSCORE; }\n         let is_mod_name = c == ':' && nextch(rdr) == ':';\n \n         // FIXME: perform NFKC normalization here. (Issue #2253)"}, {"sha": "7d5a088a04fc835e8dd13b7e55c92a0fbae35e0d", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/97452c0ca16238a2de5503aca07db26ff9e8ba63/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97452c0ca16238a2de5503aca07db26ff9e8ba63/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=97452c0ca16238a2de5503aca07db26ff9e8ba63", "patch": "@@ -2066,7 +2066,7 @@ class parser {\n \n     fn is_self_ident() -> bool {\n         alt self.token {\n-            token::IDENT(sid, false) if str::eq(~\"self\", *self.get_str(sid)) {\n+            token::IDENT(sid, false) if ~\"self\" == *self.get_str(sid) {\n                 true\n             }\n             _ => {"}, {"sha": "02a888e4022bf3d9476ba5ad60b5ee1376ffb0b6", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/97452c0ca16238a2de5503aca07db26ff9e8ba63/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97452c0ca16238a2de5503aca07db26ff9e8ba63/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=97452c0ca16238a2de5503aca07db26ff9e8ba63", "patch": "@@ -467,12 +467,13 @@ fn print_item(s: ps, &&item: @ast::item) {\n       ast::item_enum(variants, params) {\n         let newtype =\n             vec::len(variants) == 1u &&\n-                str::eq(*item.ident, *variants[0].node.name) &&\n+                str::eq(item.ident, variants[0].node.name) &&\n                 vec::len(variants[0].node.args) == 1u;\n         if newtype {\n             ibox(s, indent_unit);\n             word_space(s, ~\"enum\");\n         } else { head(s, ~\"enum\"); }\n+\n         word(s.s, *item.ident);\n         print_type_params(s, params);\n         space(s.s);\n@@ -1789,12 +1790,12 @@ fn opt_proto_to_str(opt_p: option<ast::proto>) -> ~str {\n     }\n }\n \n-fn purity_to_str(p: ast::purity) -> ~str {\n+pure fn purity_to_str(p: ast::purity) -> ~str {\n     alt p {\n-      ast::impure_fn {~\"impure\"}\n-      ast::unsafe_fn {~\"unsafe\"}\n-      ast::pure_fn {~\"pure\"}\n-      ast::extern_fn {~\"extern\"}\n+      ast::impure_fn => ~\"impure\",\n+      ast::unsafe_fn => ~\"unsafe\",\n+      ast::pure_fn => ~\"pure\",\n+      ast::extern_fn => ~\"extern\"\n     }\n }\n "}, {"sha": "5b959cb648a85770d7f6977493b2fcd77978db8c", "filename": "src/libsyntax/util/interner.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/97452c0ca16238a2de5503aca07db26ff9e8ba63/src%2Flibsyntax%2Futil%2Finterner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97452c0ca16238a2de5503aca07db26ff9e8ba63/src%2Flibsyntax%2Futil%2Finterner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Finterner.rs?ref=97452c0ca16238a2de5503aca07db26ff9e8ba63", "patch": "@@ -11,8 +11,8 @@ type hash_interner<T: const> =\n      hasher: hashfn<T>,\n      eqer: eqfn<T>};\n \n-fn mk<T: const copy>(hasher: hashfn<T>, eqer: eqfn<T>) -> interner<T> {\n-    let m = map::hashmap::<T, uint>(hasher, eqer);\n+fn mk<T: const copy>(+hasher: hashfn<T>, +eqer: eqfn<T>) -> interner<T> {\n+    let m = map::hashmap::<T, uint>(copy hasher, copy eqer);\n     let hi: hash_interner<T> =\n         {map: m, vect: dvec(), hasher: hasher, eqer: eqer};\n     return hi as interner::<T>;"}, {"sha": "01e91d27f7522f5b69e4b60725a3df4c6cf10892", "filename": "src/rustc/driver/driver.rs", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/97452c0ca16238a2de5503aca07db26ff9e8ba63/src%2Frustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97452c0ca16238a2de5503aca07db26ff9e8ba63/src%2Frustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fdriver%2Fdriver.rs?ref=97452c0ca16238a2de5503aca07db26ff9e8ba63", "patch": "@@ -573,19 +573,17 @@ fn build_session_(sopts: @session::options,\n }\n \n fn parse_pretty(sess: session, &&name: ~str) -> pp_mode {\n-    if str::eq(name, ~\"normal\") {\n-        return ppm_normal;\n-    } else if str::eq(name, ~\"expanded\") {\n-        return ppm_expanded;\n-    } else if str::eq(name, ~\"typed\") {\n-        return ppm_typed;\n-    } else if str::eq(name, ~\"expanded,identified\") {\n-        return ppm_expanded_identified;\n-    } else if str::eq(name, ~\"identified\") {\n-        return ppm_identified;\n+    alt name {\n+      ~\"normal\" => ppm_normal,\n+      ~\"expanded\" => ppm_expanded,\n+      ~\"typed\" => ppm_typed,\n+      ~\"expanded,identified\" => ppm_expanded_identified,\n+      ~\"identified\" => ppm_identified,\n+      _ => {\n+        sess.fatal(~\"argument to `pretty` must be one of `normal`, `typed`, \\\n+                     or `identified`\");\n+      }\n     }\n-    sess.fatal(~\"argument to `pretty` must be one of `normal`, `typed`, or \" +\n-                   ~\"`identified`\");\n }\n \n fn opts() -> ~[getopts::opt] {"}, {"sha": "be758ee699b4f4b43b50f0f7076294b925b7983f", "filename": "src/rustc/lib/llvm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/97452c0ca16238a2de5503aca07db26ff9e8ba63/src%2Frustc%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97452c0ca16238a2de5503aca07db26ff9e8ba63/src%2Frustc%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Flib%2Fllvm.rs?ref=97452c0ca16238a2de5503aca07db26ff9e8ba63", "patch": "@@ -1003,8 +1003,8 @@ fn name_has_type(tn: type_names, s: ~str) -> option<TypeRef> {\n }\n \n fn mk_type_names() -> type_names {\n-    fn hash(&&t: TypeRef) -> uint { return t as uint; }\n-    fn eq(&&a: TypeRef, &&b: TypeRef) -> bool { a as uint == b as uint }\n+    pure fn hash(t: &TypeRef) -> uint { *t as uint }\n+    pure fn eq(a: &TypeRef, b: &TypeRef) -> bool { *a == *b }\n     @{type_names: std::map::hashmap(hash, eq),\n       named_types: std::map::str_hash()}\n }"}, {"sha": "6c329b81539a46301496e0e858b7de671488fdfa", "filename": "src/rustc/metadata/cstore.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/97452c0ca16238a2de5503aca07db26ff9e8ba63/src%2Frustc%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97452c0ca16238a2de5503aca07db26ff9e8ba63/src%2Frustc%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fcstore.rs?ref=97452c0ca16238a2de5503aca07db26ff9e8ba63", "patch": "@@ -163,8 +163,8 @@ fn get_dep_hashes(cstore: cstore) -> ~[@~str] {\n         debug!{\"Add hash[%s]: %s\", cdata.name, *hash};\n         vec::push(result, {name: @cdata.name, hash: hash});\n     };\n-    fn lteq(a: crate_hash, b: crate_hash) -> bool {\n-        return *a.name <= *b.name;\n+    pure fn lteq(a: &crate_hash, b: &crate_hash) -> bool {\n+        *a.name <= *b.name\n     }\n     let sorted = std::sort::merge_sort(lteq, result);\n     debug!{\"sorted:\"};"}, {"sha": "4e22c28c943f870d59d4306dbe495ad873831166", "filename": "src/rustc/metadata/decoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/97452c0ca16238a2de5503aca07db26ff9e8ba63/src%2Frustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97452c0ca16238a2de5503aca07db26ff9e8ba63/src%2Frustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fdecoder.rs?ref=97452c0ca16238a2de5503aca07db26ff9e8ba63", "patch": "@@ -603,7 +603,7 @@ fn get_self_ty(item: ebml::doc) -> ast::self_ty_ {\n                 ebml::get_doc(self_type_doc,\n                               tag_item_trait_method_self_ty_region);\n             let region_string = str::from_bytes(ebml::doc_data(region_doc));\n-            if str::eq(region_string, ~\"\") {\n+            if region_string == ~\"\" {\n                 region = ast::re_anon;\n             } else {\n                 region = ast::re_named(@region_string);"}, {"sha": "3ee7b4f919ff9ff2ef26541ec6ccd34c729083de", "filename": "src/rustc/metadata/encoder.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/97452c0ca16238a2de5503aca07db26ff9e8ba63/src%2Frustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97452c0ca16238a2de5503aca07db26ff9e8ba63/src%2Frustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fencoder.rs?ref=97452c0ca16238a2de5503aca07db26ff9e8ba63", "patch": "@@ -1089,7 +1089,9 @@ fn encode_crate_deps(ebml_w: ebml::writer, cstore: cstore::cstore) {\n         };\n \n         // Sort by cnum\n-        fn lteq(kv1: numdep, kv2: numdep) -> bool { kv1.cnum <= kv2.cnum }\n+        pure fn lteq(kv1: &numdep, kv2: &numdep) -> bool {\n+            kv1.cnum <= kv2.cnum\n+        }\n         std::sort::quick_sort(lteq, deps);\n \n         // Sanity-check the crate numbers"}, {"sha": "125c2ff3aba6e98cb89bb781ae330d1ff63b2f7d", "filename": "src/rustc/metadata/loader.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/97452c0ca16238a2de5503aca07db26ff9e8ba63/src%2Frustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97452c0ca16238a2de5503aca07db26ff9e8ba63/src%2Frustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Floader.rs?ref=97452c0ca16238a2de5503aca07db26ff9e8ba63", "patch": "@@ -183,7 +183,7 @@ fn get_metadata_section(os: os,\n     while llvm::LLVMIsSectionIteratorAtEnd(of.llof, si.llsi) == False {\n         let name_buf = llvm::LLVMGetSectionName(si.llsi);\n         let name = unsafe { str::unsafe::from_c_str(name_buf) };\n-        if str::eq(name, meta_section_name(os)) {\n+        if name == meta_section_name(os) {\n             let cbuf = llvm::LLVMGetSectionContents(si.llsi);\n             let csz = llvm::LLVMGetSectionSize(si.llsi) as uint;\n             unsafe {"}, {"sha": "d1f38ca17e9fbba1bbf3e0f7a722fd57864866ff", "filename": "src/rustc/middle/borrowck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/97452c0ca16238a2de5503aca07db26ff9e8ba63/src%2Frustc%2Fmiddle%2Fborrowck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97452c0ca16238a2de5503aca07db26ff9e8ba63/src%2Frustc%2Fmiddle%2Fborrowck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck.rs?ref=97452c0ca16238a2de5503aca07db26ff9e8ba63", "patch": "@@ -417,11 +417,11 @@ fn save_and_restore<T:copy,U>(&save_and_restore_t: T, f: fn() -> U) -> U {\n fn root_map() -> root_map {\n     return hashmap(root_map_key_hash, root_map_key_eq);\n \n-    fn root_map_key_eq(k1: root_map_key, k2: root_map_key) -> bool {\n+    pure fn root_map_key_eq(k1: &root_map_key, k2: &root_map_key) -> bool {\n         k1.id == k2.id && k1.derefs == k2.derefs\n     }\n \n-    fn root_map_key_hash(k: root_map_key) -> uint {\n+    pure fn root_map_key_hash(k: &root_map_key) -> uint {\n         (k.id << 4) as uint | k.derefs\n     }\n }"}, {"sha": "c3508319375aed5e7a9b28630f06606a4fcd8f87", "filename": "src/rustc/middle/lang_items.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/97452c0ca16238a2de5503aca07db26ff9e8ba63/src%2Frustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97452c0ca16238a2de5503aca07db26ff9e8ba63/src%2Frustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Flang_items.rs?ref=97452c0ca16238a2de5503aca07db26ff9e8ba63", "patch": "@@ -118,7 +118,7 @@ class LanguageItemCollector {\n     }\n \n     fn match_and_collect_item(item_def_id: def_id, key: ~str, value: ~str) {\n-        if !str_eq(key, ~\"lang\") {\n+        if key != ~\"lang\" {\n             return;    // Didn't match.\n         }\n "}, {"sha": "2b240271024aec78f699e1120be0f1106194d3b1", "filename": "src/rustc/middle/resolve3.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/97452c0ca16238a2de5503aca07db26ff9e8ba63/src%2Frustc%2Fmiddle%2Fresolve3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97452c0ca16238a2de5503aca07db26ff9e8ba63/src%2Frustc%2Fmiddle%2Fresolve3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fresolve3.rs?ref=97452c0ca16238a2de5503aca07db26ff9e8ba63", "patch": "@@ -293,7 +293,7 @@ class AtomTable {\n \n /// Creates a hash table of atoms.\n fn atom_hashmap<V:copy>() -> hashmap<Atom,V> {\n-    return hashmap::<Atom,V>(|a| a, |a, b| a == b);\n+    hashmap::<Atom,V>(uint::hash, uint::eq)\n }\n \n /**\n@@ -3168,7 +3168,7 @@ class Resolver {\n \n                 if !self.session.building_library &&\n                         is_none(self.session.main_fn) &&\n-                        str::eq(*item.ident, ~\"main\") {\n+                        *item.ident == ~\"main\" {\n \n                     self.session.main_fn = some((item.id, item.span));\n                 }"}, {"sha": "b0a2acbe3a7e8c2c0bf5b88631a7f9f5e55289a8", "filename": "src/rustc/middle/trans/alt.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/97452c0ca16238a2de5503aca07db26ff9e8ba63/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97452c0ca16238a2de5503aca07db26ff9e8ba63/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs?ref=97452c0ca16238a2de5503aca07db26ff9e8ba63", "patch": "@@ -94,7 +94,7 @@ type bind_map = ~[{\n \n fn assoc(key: ast::ident, list: bind_map) -> option<binding> {\n     for vec::each(list) |elt| {\n-        if str::eq(*elt.ident, *key) {\n+        if str::eq(elt.ident, key) {\n             return some(elt.binding);\n         }\n     }\n@@ -231,7 +231,7 @@ fn enter_rec(bcx: block, dm: DefMap, m: match_, col: uint,\n             for vec::each(fields) |fname| {\n                 let mut pat = dummy;\n                 for vec::each(fpats) |fpat| {\n-                    if str::eq(*fpat.ident, *fname) { pat = fpat.pat; break; }\n+                    if str::eq(fpat.ident, fname) { pat = fpat.pat; break; }\n                 }\n                 vec::push(pats, pat);\n             }\n@@ -331,7 +331,7 @@ fn collect_record_fields(m: match_, col: uint) -> ~[ast::ident] {\n         alt br.pats[col].node {\n           ast::pat_rec(fs, _) {\n             for vec::each(fs) |f| {\n-                if !vec::any(fields, |x| str::eq(*f.ident, *x)) {\n+                if !vec::any(fields, |x| str::eq(f.ident, x)) {\n                     vec::push(fields, f.ident);\n                 }\n             }"}, {"sha": "eaee22ee6779c24715b264264305a9340bd950ff", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/97452c0ca16238a2de5503aca07db26ff9e8ba63/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97452c0ca16238a2de5503aca07db26ff9e8ba63/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=97452c0ca16238a2de5503aca07db26ff9e8ba63", "patch": "@@ -3352,7 +3352,7 @@ fn trans_rec(bcx: block, fields: ~[ast::field],\n     let mut temp_cleanups = ~[];\n     for fields.each |fld| {\n         let ix = option::get(vec::position(ty_fields, |ft| {\n-            str::eq(*fld.node.ident, *ft.ident)\n+            str::eq(fld.node.ident, ft.ident)\n         }));\n         let dst = GEPi(bcx, addr, ~[0u, ix]);\n         bcx = trans_expr_save_in(bcx, fld.node.expr, dst);\n@@ -3365,7 +3365,7 @@ fn trans_rec(bcx: block, fields: ~[ast::field],\n         bcx = cx;\n         // Copy over inherited fields\n         for ty_fields.eachi |i, tf| {\n-            if !vec::any(fields, |f| str::eq(*f.node.ident, *tf.ident)) {\n+            if !vec::any(fields, |f| str::eq(f.node.ident, tf.ident)) {\n                 let dst = GEPi(bcx, addr, ~[0u, i]);\n                 let base = GEPi(bcx, base_val, ~[0u, i]);\n                 let val = load_if_immediate(bcx, base, tf.mt.ty);\n@@ -3429,7 +3429,7 @@ fn trans_struct(block_context: block, span: span, fields: ~[ast::field],\n     for fields.each |field| {\n         let mut found = none;\n         for class_fields.eachi |i, class_field| {\n-            if str::eq(*class_field.ident, *field.node.ident) {\n+            if str::eq(class_field.ident, field.node.ident) {\n                 found = some((i, class_field.id));\n                 break;\n             }\n@@ -5554,10 +5554,10 @@ fn trans_crate(sess: session::session, crate: @ast::crate, tcx: ty::ctxt,\n           discrim_symbols: int_hash::<~str>(),\n           tydescs: ty::new_ty_hash(),\n           external: ast_util::new_def_hash(),\n-          monomorphized: map::hashmap(hash_mono_id, |a, b| a == b),\n+          monomorphized: map::hashmap(hash_mono_id, sys::shape_eq),\n           monomorphizing: ast_util::new_def_hash(),\n           type_use_cache: ast_util::new_def_hash(),\n-          vtables: map::hashmap(hash_mono_id, |a, b| a == b),\n+          vtables: map::hashmap(hash_mono_id, sys::shape_eq),\n           const_cstr_cache: map::str_hash(),\n           module_data: str_hash::<ValueRef>(),\n           lltypes: ty::new_ty_hash(),"}, {"sha": "3addc0a75021727e892831463219ffc4e8691db1", "filename": "src/rustc/middle/trans/common.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/97452c0ca16238a2de5503aca07db26ff9e8ba63/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97452c0ca16238a2de5503aca07db26ff9e8ba63/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=97452c0ca16238a2de5503aca07db26ff9e8ba63", "patch": "@@ -927,14 +927,16 @@ enum mono_param_id {\n     mono_repr(uint /* size */, uint /* align */),\n }\n type mono_id = @{def: ast::def_id, params: ~[mono_param_id]};\n-fn hash_mono_id(&&mi: mono_id) -> uint {\n-    let mut h = syntax::ast_util::hash_def(mi.def);\n+pure fn hash_mono_id(mi: &mono_id) -> uint {\n+    let mut h = syntax::ast_util::hash_def(&mi.def);\n     for vec::each(mi.params) |param| {\n         h = h * alt param {\n           mono_precise(ty, vts) {\n             let mut h = ty::type_id(ty);\n             do option::iter(vts) |vts| {\n-                for vec::each(vts) |vt| { h += hash_mono_id(vt); }\n+                for vec::each(vts) |vt| {\n+                    h += hash_mono_id(&vt);\n+                }\n             }\n             h\n           }"}, {"sha": "11310afd0ffd55fbfc0088c64e5a3426b824d01f", "filename": "src/rustc/middle/trans/shape.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/97452c0ca16238a2de5503aca07db26ff9e8ba63/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97452c0ca16238a2de5503aca07db26ff9e8ba63/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs?ref=97452c0ca16238a2de5503aca07db26ff9e8ba63", "patch": "@@ -33,7 +33,7 @@ fn mk_nominal_id(tcx: ty::ctxt, did: ast::def_id,\n     @{did: did, parent_id: parent_id, tps: tps_norm}\n }\n \n-fn hash_nominal_id(&&ri: nominal_id) -> uint {\n+pure fn hash_nominal_id(ri: &nominal_id) -> uint {\n     let mut h = 5381u;\n     h *= 33u;\n     h += ri.did.crate as uint;\n@@ -46,7 +46,7 @@ fn hash_nominal_id(&&ri: nominal_id) -> uint {\n     return h;\n }\n \n-fn eq_nominal_id(&&mi: nominal_id, &&ni: nominal_id) -> bool {\n+pure fn eq_nominal_id(mi: &nominal_id, ni: &nominal_id) -> bool {\n     if mi.did != ni.did {\n         false\n     } else {"}, {"sha": "004a2da5d92b7355d290553903d73c0165e0fe75", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 54, "deletions": 50, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/97452c0ca16238a2de5503aca07db26ff9e8ba63/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97452c0ca16238a2de5503aca07db26ff9e8ba63/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=97452c0ca16238a2de5503aca07db26ff9e8ba63", "patch": "@@ -295,16 +295,18 @@ pure fn get(t: t) -> t_box unsafe {\n     t3\n }\n \n-fn tbox_has_flag(tb: t_box, flag: tbox_flag) -> bool {\n+pure fn tbox_has_flag(tb: t_box, flag: tbox_flag) -> bool {\n     (tb.flags & (flag as uint)) != 0u\n }\n-fn type_has_params(t: t) -> bool { tbox_has_flag(get(t), has_params) }\n-fn type_has_self(t: t) -> bool { tbox_has_flag(get(t), has_self) }\n-fn type_needs_infer(t: t) -> bool { tbox_has_flag(get(t), needs_infer) }\n-fn type_has_regions(t: t) -> bool { tbox_has_flag(get(t), has_regions) }\n-fn type_has_resources(t: t) -> bool { tbox_has_flag(get(t), has_resources) }\n-fn type_def_id(t: t) -> option<ast::def_id> { get(t).o_def_id }\n-fn type_id(t: t) -> uint { get(t).id }\n+pure fn type_has_params(t: t) -> bool { tbox_has_flag(get(t), has_params) }\n+pure fn type_has_self(t: t) -> bool { tbox_has_flag(get(t), has_self) }\n+pure fn type_needs_infer(t: t) -> bool { tbox_has_flag(get(t), needs_infer) }\n+pure fn type_has_regions(t: t) -> bool { tbox_has_flag(get(t), has_regions) }\n+pure fn type_has_resources(t: t) -> bool {\n+    tbox_has_flag(get(t), has_resources)\n+}\n+pure fn type_def_id(t: t) -> option<ast::def_id> { get(t).o_def_id }\n+pure fn type_id(t: t) -> uint { get(t).id }\n \n enum closure_kind {\n     ck_block,\n@@ -478,31 +480,31 @@ enum tvi_vid = uint;\n enum region_vid = uint;\n \n trait vid {\n-    fn to_uint() -> uint;\n-    fn to_str() -> ~str;\n+    pure fn to_uint() -> uint;\n+    pure fn to_str() -> ~str;\n }\n \n impl of vid for tv_vid {\n-    fn to_uint() -> uint { *self }\n-    fn to_str() -> ~str { fmt!{\"<V%u>\", self.to_uint()} }\n+    pure fn to_uint() -> uint { *self }\n+    pure fn to_str() -> ~str { fmt!{\"<V%u>\", self.to_uint()} }\n }\n \n impl of vid for tvi_vid {\n-    fn to_uint() -> uint { *self }\n-    fn to_str() -> ~str { fmt!{\"<VI%u>\", self.to_uint()} }\n+    pure fn to_uint() -> uint { *self }\n+    pure fn to_str() -> ~str { fmt!{\"<VI%u>\", self.to_uint()} }\n }\n \n impl of vid for region_vid {\n-    fn to_uint() -> uint { *self }\n-    fn to_str() -> ~str { fmt!{\"<R%u>\", self.to_uint()} }\n+    pure fn to_uint() -> uint { *self }\n+    pure fn to_str() -> ~str { fmt!{\"<R%u>\", self.to_uint()} }\n }\n \n trait purity_to_str {\n-    fn to_str() -> ~str;\n+    pure fn to_str() -> ~str;\n }\n \n impl of purity_to_str for purity {\n-    fn to_str() -> ~str {\n+    pure fn to_str() -> ~str {\n         purity_to_str(self)\n     }\n }\n@@ -541,18 +543,18 @@ type node_type_table = @smallintmap::smallintmap<t>;\n \n fn mk_rcache() -> creader_cache {\n     type val = {cnum: int, pos: uint, len: uint};\n-    fn hash_cache_entry(k: val) -> uint {\n-        return (k.cnum as uint) + k.pos + k.len;\n+    pure fn hash_cache_entry(k: &val) -> uint {\n+        (k.cnum as uint) + k.pos + k.len\n     }\n-    fn eq_cache_entries(a: val, b: val) -> bool {\n-        return a.cnum == b.cnum && a.pos == b.pos && a.len == b.len;\n+    pure fn eq_cache_entries(a: &val, b: &val) -> bool {\n+        a.cnum == b.cnum && a.pos == b.pos && a.len == b.len\n     }\n     return map::hashmap(hash_cache_entry, eq_cache_entries);\n }\n \n fn new_ty_hash<V: copy>() -> map::hashmap<t, V> {\n-    map::hashmap(|&&t: t| type_id(t),\n-                 |&&a: t, &&b: t| type_id(a) == type_id(b))\n+    map::hashmap(|t: &t| type_id(*t),\n+                 |a: &t, b: &t| type_id(*a) == type_id(*b))\n }\n \n fn mk_ctxt(s: session::session,\n@@ -561,10 +563,11 @@ fn mk_ctxt(s: session::session,\n            freevars: freevars::freevar_map,\n            region_map: middle::region::region_map,\n            region_paramd_items: middle::region::region_paramd_items) -> ctxt {\n-    let interner = map::hashmap(|&&k: intern_key| {\n+    pure fn hash_intern_key(k: &intern_key) -> uint {\n         hash_type_structure(k.struct) +\n-            option::map_default(k.o_def_id, 0u, ast_util::hash_def)\n-    }, |&&a, &&b| a == b);\n+            option::map_default(k.o_def_id, 0u, |d| ast_util::hash_def(&d))\n+    }\n+    let interner = map::hashmap(hash_intern_key, sys::shape_eq);\n     let vecs_implicitly_copyable =\n         get_lint_level(s.lint_settings.default_settings,\n                        lint::vecs_implicitly_copyable) == allow;\n@@ -2131,46 +2134,47 @@ fn index_sty(cx: ctxt, sty: sty) -> option<mt> {\n     }\n }\n \n-fn hash_bound_region(br: bound_region) -> uint {\n-    alt br { // no idea if this is any good\n+pure fn hash_bound_region(br: &bound_region) -> uint {\n+    alt *br { // no idea if this is any good\n       ty::br_self { 0u }\n       ty::br_anon { 1u }\n-      ty::br_named(str) { str::hash(*str) }\n-      ty::br_cap_avoid(id, br) { id as uint | hash_bound_region(*br) }\n+      ty::br_named(str) { str::hash(str) }\n+      ty::br_cap_avoid(id, br) { id as uint | hash_bound_region(br) }\n     }\n }\n \n fn br_hashmap<V:copy>() -> hashmap<bound_region, V> {\n-    map::hashmap(hash_bound_region,\n-                 |&&a: bound_region, &&b: bound_region| a == b)\n+    map::hashmap(hash_bound_region, sys::shape_eq)\n }\n \n // Type hashing.\n-fn hash_type_structure(st: sty) -> uint {\n-    fn hash_uint(id: uint, n: uint) -> uint { (id << 2u) + n }\n-    fn hash_def(id: uint, did: ast::def_id) -> uint {\n+pure fn hash_type_structure(st: sty) -> uint {\n+    pure fn hash_uint(id: uint, n: uint) -> uint { (id << 2u) + n }\n+    pure fn hash_def(id: uint, did: ast::def_id) -> uint {\n         let h = (id << 2u) + (did.crate as uint);\n         (h << 2u) + (did.node as uint)\n     }\n-    fn hash_subty(id: uint, subty: t) -> uint { (id << 2u) + type_id(subty) }\n-    fn hash_subtys(id: uint, subtys: ~[t]) -> uint {\n+    pure fn hash_subty(id: uint, subty: t) -> uint {\n+        (id << 2u) + type_id(subty)\n+    }\n+    pure fn hash_subtys(id: uint, subtys: ~[t]) -> uint {\n         let mut h = id;\n-        for subtys.each |s| { h = (h << 2u) + type_id(s) }\n+        for vec::each(subtys) |s| { h = (h << 2u) + type_id(s) }\n         h\n     }\n-    fn hash_region(r: region) -> uint {\n-        alt r { // no idea if this is any good\n-          re_bound(br) { (hash_bound_region(br)) << 2u | 0u }\n+    pure fn hash_region(r: &region) -> uint {\n+        alt *r { // no idea if this is any good\n+          re_bound(br) { (hash_bound_region(&br)) << 2u | 0u }\n           re_free(id, br) { ((id as uint) << 4u) |\n-                               (hash_bound_region(br)) << 2u | 1u }\n+                               (hash_bound_region(&br)) << 2u | 1u }\n           re_scope(id)  { ((id as uint) << 2u) | 2u }\n           re_var(id)    { (id.to_uint() << 2u) | 3u }\n           re_bot        { 4u }\n         }\n     }\n-    fn hash_substs(h: uint, substs: substs) -> uint {\n+    pure fn hash_substs(h: uint, substs: substs) -> uint {\n         let h = hash_subtys(h, substs.tps);\n-        h + substs.self_r.map_default(0u, hash_region)\n+        h + substs.self_r.map_default(0u, |r| hash_region(&r))\n     }\n     alt st {\n       ty_nil { 0u } ty_bool { 1u }\n@@ -2200,12 +2204,12 @@ fn hash_type_structure(st: sty) -> uint {\n       ty_tup(ts) { hash_subtys(25u, ts) }\n       ty_rec(fields) {\n         let mut h = 26u;\n-        for fields.each |f| { h = hash_subty(h, f.mt.ty); }\n+        for vec::each(fields) |f| { h = hash_subty(h, f.mt.ty); }\n         h\n       }\n       ty_fn(f) {\n         let mut h = 27u;\n-        for f.inputs.each |a| { h = hash_subty(h, a.ty); }\n+        for vec::each(f.inputs) |a| { h = hash_subty(h, a.ty); }\n         hash_subty(h, f.output)\n       }\n       ty_self { 28u }\n@@ -2229,7 +2233,7 @@ fn hash_type_structure(st: sty) -> uint {\n         hash_substs(h, substs)\n       }\n       ty_rptr(region, mt) {\n-        let mut h = (46u << 2u) + hash_region(region);\n+        let mut h = (46u << 2u) + hash_region(&region);\n         hash_subty(h, mt.ty)\n       }\n     }\n@@ -2375,7 +2379,7 @@ fn field_idx(id: ast::ident, fields: ~[field]) -> option<uint> {\n }\n \n fn get_field(rec_ty: t, id: ast::ident) -> field {\n-    alt check vec::find(get_fields(rec_ty), |f| str::eq(*f.ident, *id)) {\n+    alt check vec::find(get_fields(rec_ty), |f| str::eq(f.ident, id)) {\n       some(f) { f }\n     }\n }\n@@ -2848,7 +2852,7 @@ fn enum_variant_with_id(cx: ctxt, enum_id: ast::def_id,\n     let mut i = 0u;\n     while i < vec::len::<variant_info>(*variants) {\n         let variant = variants[i];\n-        if ast_util::def_eq(variant.id, variant_id) { return variant; }\n+        if ast_util::def_eq(&variant.id, &variant_id) { return variant; }\n         i += 1u;\n     }\n     cx.sess.bug(~\"enum_variant_with_id(): no variant exists with that ID\");"}, {"sha": "61a6c8dff51749c9532d83dd5679011377854ac5", "filename": "src/rustc/middle/typeck/check.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/97452c0ca16238a2de5503aca07db26ff9e8ba63/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97452c0ca16238a2de5503aca07db26ff9e8ba63/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs?ref=97452c0ca16238a2de5503aca07db26ff9e8ba63", "patch": "@@ -1670,7 +1670,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n             for fields_t.each |f| {\n                 let mut found = false;\n                 for base_fields.each |bf| {\n-                    if str::eq(*f.node.ident, *bf.ident) {\n+                    if str::eq(f.node.ident, bf.ident) {\n                         demand::suptype(fcx, f.span, bf.mt.ty, f.node.mt.ty);\n                         found = true;\n                     }"}, {"sha": "0863d82ef8c55be6c03782b5eb412618b95be656", "filename": "src/rustc/middle/typeck/check/alt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/97452c0ca16238a2de5503aca07db26ff9e8ba63/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Falt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97452c0ca16238a2de5503aca07db26ff9e8ba63/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Falt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Falt.rs?ref=97452c0ca16238a2de5503aca07db26ff9e8ba63", "patch": "@@ -197,7 +197,7 @@ fn check_pat(pcx: pat_ctxt, pat: @ast::pat, expected: ty::t) {\n                                 ex_f_count, f_count});\n         }\n         fn matches(name: ast::ident, f: ty::field) -> bool {\n-            return str::eq(*name, *f.ident);\n+            str::eq(name, f.ident)\n         }\n         for fields.each |f| {\n             alt vec::find(ex_fields, |a| matches(f.ident, a)) {"}, {"sha": "9e1fd812fc330a943666c25c09a6772cf9ae3863", "filename": "src/rustdoc/doc.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/97452c0ca16238a2de5503aca07db26ff9e8ba63/src%2Frustdoc%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97452c0ca16238a2de5503aca07db26ff9e8ba63/src%2Frustdoc%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fdoc.rs?ref=97452c0ca16238a2de5503aca07db26ff9e8ba63", "patch": "@@ -316,11 +316,11 @@ impl util of page_utils for ~[page] {\n }\n \n trait item {\n-    fn item() -> itemdoc;\n+    pure fn item() -> itemdoc;\n }\n \n impl of item for itemtag {\n-    fn item() -> itemdoc {\n+    pure fn item() -> itemdoc {\n         alt self {\n           doc::modtag(doc) { doc.item }\n           doc::nmodtag(doc) { doc.item }\n@@ -335,60 +335,60 @@ impl of item for itemtag {\n }\n \n impl of item for simpleitemdoc {\n-    fn item() -> itemdoc { self.item }\n+    pure fn item() -> itemdoc { self.item }\n }\n \n impl of item for moddoc {\n-    fn item() -> itemdoc { self.item }\n+    pure fn item() -> itemdoc { self.item }\n }\n \n impl of item for nmoddoc {\n-    fn item() -> itemdoc { self.item }\n+    pure fn item() -> itemdoc { self.item }\n }\n \n impl of item for enumdoc {\n-    fn item() -> itemdoc { self.item }\n+    pure fn item() -> itemdoc { self.item }\n }\n \n impl of item for traitdoc {\n-    fn item() -> itemdoc { self.item }\n+    pure fn item() -> itemdoc { self.item }\n }\n \n impl of item for impldoc {\n-    fn item() -> itemdoc { self.item }\n+    pure fn item() -> itemdoc { self.item }\n }\n \n trait item_utils {\n-    fn id() -> ast_id;\n-    fn name() -> ~str;\n-    fn path() -> ~[~str];\n-    fn brief() -> option<~str>;\n-    fn desc() -> option<~str>;\n-    fn sections() -> ~[section];\n+    pure fn id() -> ast_id;\n+    pure fn name() -> ~str;\n+    pure fn path() -> ~[~str];\n+    pure fn brief() -> option<~str>;\n+    pure fn desc() -> option<~str>;\n+    pure fn sections() -> ~[section];\n }\n \n impl util<A:item> of item_utils for A {\n-    fn id() -> ast_id {\n+    pure fn id() -> ast_id {\n         self.item().id\n     }\n \n-    fn name() -> ~str {\n+    pure fn name() -> ~str {\n         self.item().name\n     }\n \n-    fn path() -> ~[~str] {\n+    pure fn path() -> ~[~str] {\n         self.item().path\n     }\n \n-    fn brief() -> option<~str> {\n+    pure fn brief() -> option<~str> {\n         self.item().brief\n     }\n \n-    fn desc() -> option<~str> {\n+    pure fn desc() -> option<~str> {\n         self.item().desc\n     }\n \n-    fn sections() -> ~[section] {\n+    pure fn sections() -> ~[section] {\n         self.item().sections\n     }\n }"}, {"sha": "ada77af3cc20de0ffb797af6d5fb98f665b27ded", "filename": "src/rustdoc/markdown_pass.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/97452c0ca16238a2de5503aca07db26ff9e8ba63/src%2Frustdoc%2Fmarkdown_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97452c0ca16238a2de5503aca07db26ff9e8ba63/src%2Frustdoc%2Fmarkdown_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fmarkdown_pass.rs?ref=97452c0ca16238a2de5503aca07db26ff9e8ba63", "patch": "@@ -26,9 +26,9 @@ fn run(\n     +writer_factory: writer_factory\n ) -> doc::doc {\n \n-    fn mods_last(item1: doc::itemtag, item2: doc::itemtag) -> bool {\n-        fn is_mod(item: doc::itemtag) -> bool {\n-            alt item {\n+    pure fn mods_last(item1: &doc::itemtag, item2: &doc::itemtag) -> bool {\n+        pure fn is_mod(item: &doc::itemtag) -> bool {\n+            alt *item {\n               doc::modtag(_) { true }\n               _ { false }\n             }"}, {"sha": "4f3280b353f643bd778f6a4ab0801d74ee19ca4f", "filename": "src/rustdoc/sort_item_name_pass.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/97452c0ca16238a2de5503aca07db26ff9e8ba63/src%2Frustdoc%2Fsort_item_name_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97452c0ca16238a2de5503aca07db26ff9e8ba63/src%2Frustdoc%2Fsort_item_name_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fsort_item_name_pass.rs?ref=97452c0ca16238a2de5503aca07db26ff9e8ba63", "patch": "@@ -4,9 +4,10 @@ import doc::item_utils;\n export mk_pass;\n \n fn mk_pass() -> pass {\n-    sort_pass::mk_pass(~\"sort_item_name\", |item1, item2| {\n-        str::le(item1.name(), item2.name())\n-    })\n+    pure fn by_item_name(item1: &doc::itemtag, item2: &doc::itemtag) -> bool {\n+        (*item1).name() <= (*item2).name()\n+    }\n+    sort_pass::mk_pass(~\"sort_item_name\", by_item_name)\n }\n \n #[test]"}, {"sha": "c7d185fb8a3da90b0ad2caf92e6ccc15b11c2020", "filename": "src/rustdoc/sort_item_type_pass.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/97452c0ca16238a2de5503aca07db26ff9e8ba63/src%2Frustdoc%2Fsort_item_type_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97452c0ca16238a2de5503aca07db26ff9e8ba63/src%2Frustdoc%2Fsort_item_type_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fsort_item_type_pass.rs?ref=97452c0ca16238a2de5503aca07db26ff9e8ba63", "patch": "@@ -5,9 +5,9 @@ import doc::item_utils;\n export mk_pass;\n \n fn mk_pass() -> pass {\n-    do sort_pass::mk_pass(~\"sort_item_type\") |item1, item2| {\n-        fn score(item: doc::itemtag) -> int {\n-            alt item {\n+    pure fn by_score(item1: &doc::itemtag, item2: &doc::itemtag) -> bool {\n+        pure fn score(item: &doc::itemtag) -> int {\n+            alt *item {\n               doc::consttag(_) { 0 }\n               doc::tytag(_) { 1 }\n               doc::enumtag(_) { 2 }\n@@ -21,6 +21,8 @@ fn mk_pass() -> pass {\n \n         score(item1) <= score(item2)\n     }\n+\n+    sort_pass::mk_pass(~\"sort_item_type\", by_score)\n }\n \n #[test]"}, {"sha": "895c98707d14dfed8ac9fbbb334c4d68d309eda4", "filename": "src/rustdoc/sort_pass.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/97452c0ca16238a2de5503aca07db26ff9e8ba63/src%2Frustdoc%2Fsort_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97452c0ca16238a2de5503aca07db26ff9e8ba63/src%2Frustdoc%2Fsort_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fsort_pass.rs?ref=97452c0ca16238a2de5503aca07db26ff9e8ba63", "patch": "@@ -5,7 +5,7 @@ import std::sort;\n \n export item_lteq, mk_pass;\n \n-type item_lteq = fn~(doc::itemtag, doc::itemtag) -> bool;\n+type item_lteq = pure fn~(v1: &doc::itemtag, v2:  &doc::itemtag) -> bool;\n \n fn mk_pass(name: ~str, +lteq: item_lteq) -> pass {\n     {\n@@ -43,8 +43,8 @@ fn fold_mod(\n \n #[test]\n fn test() {\n-    fn name_lteq(item1: doc::itemtag, item2: doc::itemtag) -> bool {\n-        str::le(item1.name(), item2.name())\n+    pure fn name_lteq(item1: &doc::itemtag, item2: &doc::itemtag) -> bool {\n+        (*item1).name() <= (*item2).name()\n     }\n \n     let source = ~\"mod z { mod y { } fn x() { } } mod w { }\";\n@@ -60,7 +60,7 @@ fn test() {\n \n #[test]\n fn should_be_stable() {\n-    fn always_eq(_item1: doc::itemtag, _item2: doc::itemtag) -> bool {\n+    pure fn always_eq(_item1: &doc::itemtag, _item2: &doc::itemtag) -> bool {\n         true\n     }\n "}, {"sha": "1dc6c4ab064a647b7f7e2b5021e5e836f685abdd", "filename": "src/test/bench/graph500-bfs.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/97452c0ca16238a2de5503aca07db26ff9e8ba63/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97452c0ca16238a2de5503aca07db26ff9e8ba63/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fgraph500-bfs.rs?ref=97452c0ca16238a2de5503aca07db26ff9e8ba63", "patch": "@@ -66,9 +66,11 @@ fn make_edges(scale: uint, edgefactor: uint) -> ~[(node_id, node_id)] {\n     }\n }\n \n+pure fn node_hash(n: &node_id) -> uint { *n as uint }\n+\n fn make_graph(N: uint, edges: ~[(node_id, node_id)]) -> graph {\n     let graph = do vec::from_fn(N) |_i| {\n-        map::hashmap::<node_id, ()>(|x| x as uint , |x, y| x == y )\n+        map::hashmap::<node_id, ()>(node_hash, sys::shape_eq)\n     };\n \n     do vec::each(edges) |e| {\n@@ -84,7 +86,7 @@ fn make_graph(N: uint, edges: ~[(node_id, node_id)]) -> graph {\n }\n \n fn gen_search_keys(graph: graph, n: uint) -> ~[node_id] {\n-    let keys = map::hashmap::<node_id, ()>(|x| x as uint , |x, y| x == y );\n+    let keys = map::hashmap::<node_id, ()>(node_hash, sys::shape_eq);\n     let r = rand::rng();\n \n     while keys.size() < n {"}, {"sha": "cebd36a15695b6a7c536999ad9fa2259688d02fc", "filename": "src/test/bench/shootout-k-nucleotide-pipes.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/97452c0ca16238a2de5503aca07db26ff9e8ba63/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97452c0ca16238a2de5503aca07db26ff9e8ba63/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs?ref=97452c0ca16238a2de5503aca07db26ff9e8ba63", "patch": "@@ -17,15 +17,17 @@ fn sort_and_fmt(mm: hashmap<~[u8], uint>, total: uint) -> ~str {\n       return (xx as float) * 100f / (yy as float);\n    }\n \n-   fn le_by_val<TT: copy, UU: copy>(kv0: (TT,UU), kv1: (TT,UU)) -> bool {\n-      let (_, v0) = kv0;\n-      let (_, v1) = kv1;\n+   pure fn le_by_val<TT: copy, UU: copy>(kv0: &(TT,UU),\n+                                         kv1: &(TT,UU)) -> bool {\n+      let (_, v0) = *kv0;\n+      let (_, v1) = *kv1;\n       return v0 >= v1;\n    }\n \n-   fn le_by_key<TT: copy, UU: copy>(kv0: (TT,UU), kv1: (TT,UU)) -> bool {\n-      let (k0, _) = kv0;\n-      let (k1, _) = kv1;\n+   pure fn le_by_key<TT: copy, UU: copy>(kv0: &(TT,UU),\n+                                         kv1: &(TT,UU)) -> bool {\n+      let (k0, _) = *kv0;\n+      let (k1, _) = *kv1;\n       return k0 <= k1;\n    }\n "}, {"sha": "6f026cd62584f19dc4d47d30a73f3762d9a810b1", "filename": "src/test/bench/shootout-k-nucleotide.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/97452c0ca16238a2de5503aca07db26ff9e8ba63/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97452c0ca16238a2de5503aca07db26ff9e8ba63/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs?ref=97452c0ca16238a2de5503aca07db26ff9e8ba63", "patch": "@@ -15,15 +15,17 @@ fn sort_and_fmt(mm: hashmap<~[u8], uint>, total: uint) -> ~str {\n       return (xx as float) * 100f / (yy as float);\n    }\n \n-   fn le_by_val<TT: copy, UU: copy>(kv0: (TT,UU), kv1: (TT,UU)) -> bool {\n-      let (_, v0) = kv0;\n-      let (_, v1) = kv1;\n+   pure fn le_by_val<TT: copy, UU: copy>(kv0: &(TT,UU),\n+                                         kv1: &(TT,UU)) -> bool {\n+      let (_, v0) = *kv0;\n+      let (_, v1) = *kv1;\n       return v0 >= v1;\n    }\n \n-   fn le_by_key<TT: copy, UU: copy>(kv0: (TT,UU), kv1: (TT,UU)) -> bool {\n-      let (k0, _) = kv0;\n-      let (k1, _) = kv1;\n+   pure fn le_by_key<TT: copy, UU: copy>(kv0: &(TT,UU),\n+                                         kv1: &(TT,UU)) -> bool {\n+      let (k0, _) = *kv0;\n+      let (k1, _) = *kv1;\n       return k0 <= k1;\n    }\n "}, {"sha": "c939da509bc0b646ace5f3efd7cfee9d3451dd48", "filename": "src/test/bench/task-perf-word-count-generic.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/97452c0ca16238a2de5503aca07db26ff9e8ba63/src%2Ftest%2Fbench%2Ftask-perf-word-count-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97452c0ca16238a2de5503aca07db26ff9e8ba63/src%2Ftest%2Fbench%2Ftask-perf-word-count-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-word-count-generic.rs?ref=97452c0ca16238a2de5503aca07db26ff9e8ba63", "patch": "@@ -42,19 +42,20 @@ trait word_reader {\n }\n \n trait hash_key {\n-    fn hash() -> uint;\n-    fn eq(self) -> bool;\n+    pure fn hash() -> uint;\n+    pure fn eq(&&k: self) -> bool;\n }\n \n fn mk_hash<K: const hash_key, V: copy>() -> map::hashmap<K, V> {\n-    fn hashfn<K: const hash_key>(k: K) -> uint { k.hash() }\n+    pure fn hashfn<K: const hash_key>(k: &K) -> uint { k.hash() }\n+    pure fn hasheq<K: const hash_key>(k1: &K, k2: &K) -> bool { k1.eq(*k2) }\n \n-    map::hashmap(hashfn::<K>, |x, y| x.eq(y))\n+    map::hashmap(hashfn, hasheq)\n }\n \n impl of hash_key for ~str {\n-    fn hash() -> uint { str::hash(self) }\n-    fn eq(&&x: ~str) -> bool { str::eq(self, x) }\n+    pure fn hash() -> uint { str::hash(&self) }\n+    pure fn eq(&&x: ~str) -> bool { self == x }\n }\n \n // These used to be in task, but they disappeard."}, {"sha": "a1f8010082a93d02927294b5d2b191d1f8478f19", "filename": "src/test/run-fail/unwind-misc-1.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/97452c0ca16238a2de5503aca07db26ff9e8ba63/src%2Ftest%2Frun-fail%2Funwind-misc-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97452c0ca16238a2de5503aca07db26ff9e8ba63/src%2Ftest%2Frun-fail%2Funwind-misc-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Funwind-misc-1.rs?ref=97452c0ca16238a2de5503aca07db26ff9e8ba63", "patch": "@@ -7,12 +7,12 @@ import uint;\n \n fn main() {\n     let count = @mut 0u;\n-    fn hash(&&s: ~[@~str]) -> uint {\n-        if (vec::len(s) > 0u && str::eq(*s[0], ~\"boom\")) { fail; }\n+    pure fn hash(s: &~[@~str]) -> uint {\n+        if vec::len(*s) > 0u && *s[0] == ~\"boom\" { fail; }\n         return 10u;\n     }\n-    fn eq(&&s: ~[@~str], &&t: ~[@~str]) -> bool {\n-        return s == t;\n+    pure fn eq(s: &~[@~str], t: &~[@~str]) -> bool {\n+        return *s == *t;\n     }\n \n     let map = map::hashmap(hash, eq);"}, {"sha": "9e7cf14959f553f567cb8fde7112355f37cff5da", "filename": "src/test/run-fail/zip-different-lengths.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/97452c0ca16238a2de5503aca07db26ff9e8ba63/src%2Ftest%2Frun-fail%2Fzip-different-lengths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97452c0ca16238a2de5503aca07db26ff9e8ba63/src%2Ftest%2Frun-fail%2Fzip-different-lengths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fzip-different-lengths.rs?ref=97452c0ca16238a2de5503aca07db26ff9e8ba63", "patch": "@@ -24,9 +24,6 @@ fn enum_uints(start: uint, end: uint) -> ~[uint] {\n \n fn main() {\n     let a = 'a' as u8, j = 'j' as u8, k = 1u, l = 9u;\n-    // Silly, but necessary\n-    assert (u8::le(a, j));\n-    assert (uint::le(k, l));\n     let chars = enum_chars(a, j);\n     let ints = enum_uints(k, l);\n "}, {"sha": "326a7a7ae2d5edb0eca07901eaf3a662c78335ad", "filename": "src/test/run-pass/class-impl-very-parameterized-iface.rs", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/97452c0ca16238a2de5503aca07db26ff9e8ba63/src%2Ftest%2Frun-pass%2Fclass-impl-very-parameterized-iface.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97452c0ca16238a2de5503aca07db26ff9e8ba63/src%2Ftest%2Frun-pass%2Fclass-impl-very-parameterized-iface.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-impl-very-parameterized-iface.rs?ref=97452c0ca16238a2de5503aca07db26ff9e8ba63", "patch": "@@ -45,21 +45,22 @@ class cat<T: copy> : map<int, T> {\n     self.meows += k;\n     true\n   }\n-  fn contains_key(&&k: int) -> bool { k <= self.meows }\n-  \n-  fn get(&&k:int) -> T { alt self.find(k) {\n+  fn contains_key(+k: int) -> bool { k <= self.meows }\n+  fn contains_key_ref(k: &int) -> bool { self.contains_key(*k) }\n+\n+  fn get(+k:int) -> T { alt self.find(k) {\n       some(v) { v }\n       none    { fail ~\"epic fail\"; }\n     }\n   }\n   fn [](&&k:int) -> T { self.get(k) }\n-  fn find(&&k:int) -> option<T> { if k <= self.meows {\n+  fn find(+k:int) -> option<T> { if k <= self.meows {\n         some(self.name)\n      }\n      else { none }\n   }\n \n-  fn remove(&&k:int) -> option<T> {\n+  fn remove(+k:int) -> option<T> {\n     alt self.find(k) {\n       some(x) {\n         self.meows -= k; some(x)\n@@ -68,20 +69,25 @@ class cat<T: copy> : map<int, T> {\n     }\n   }\n \n-  fn each(f: fn(&&int, &&T) -> bool) {\n+  fn each(f: fn(+int, +T) -> bool) {\n     let mut n = int::abs(self.meows);\n     while n > 0 {\n         if !f(n, self.name) { break; }\n         n -= 1;\n     }\n   }\n \n-  fn each_key(&&f: fn(&&int) -> bool) {\n+  fn each_key(&&f: fn(+int) -> bool) {\n     for self.each |k, _v| { if !f(k) { break; } again;};\n   }\n-  fn each_value(&&f: fn(&&T) -> bool) {\n+  fn each_value(&&f: fn(+T) -> bool) {\n     for self.each |_k, v| { if !f(v) { break; } again;};\n   }\n+\n+  fn each_ref(f: fn(k: &int, v: &T) -> bool) {}\n+  fn each_key_ref(f: fn(k: &int) -> bool) {}\n+  fn each_value_ref(f: fn(k: &T) -> bool) {}\n+\n   fn clear() { }\n }\n "}, {"sha": "a6877c667f626323cec4ec69ab970c3894a8f848", "filename": "src/test/run-pass/spawn-types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/97452c0ca16238a2de5503aca07db26ff9e8ba63/src%2Ftest%2Frun-pass%2Fspawn-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97452c0ca16238a2de5503aca07db26ff9e8ba63/src%2Ftest%2Frun-pass%2Fspawn-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fspawn-types.rs?ref=97452c0ca16238a2de5503aca07db26ff9e8ba63", "patch": "@@ -13,7 +13,7 @@ import task;\n type ctx = comm::chan<int>;\n \n fn iotask(cx: ctx, ip: ~str) {\n-    assert (str::eq(ip, ~\"localhost\"));\n+    assert (ip == ~\"localhost\");\n }\n \n fn main() {"}, {"sha": "bf16c8c7988f0dd47c9649d080a9abe7b630d5d0", "filename": "src/test/run-pass/str-append.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/97452c0ca16238a2de5503aca07db26ff9e8ba63/src%2Ftest%2Frun-pass%2Fstr-append.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97452c0ca16238a2de5503aca07db26ff9e8ba63/src%2Ftest%2Frun-pass%2Fstr-append.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstr-append.rs?ref=97452c0ca16238a2de5503aca07db26ff9e8ba63", "patch": "@@ -19,8 +19,8 @@ fn test2() {\n     let b: ~str = ~\"ABC\" + ff + ~\"ABC\";\n     log(debug, a);\n     log(debug, b);\n-    assert (str::eq(a, ~\"abcABCabc\"));\n-    assert (str::eq(b, ~\"ABCabcABC\"));\n+    assert (a == ~\"abcABCabc\");\n+    assert (b == ~\"ABCabcABC\");\n }\n \n fn main() { test1(); test2(); }"}, {"sha": "210fb9b275b5275586002edbc169a4805b7878cd", "filename": "src/test/run-pass/str-multiline.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/97452c0ca16238a2de5503aca07db26ff9e8ba63/src%2Ftest%2Frun-pass%2Fstr-multiline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97452c0ca16238a2de5503aca07db26ff9e8ba63/src%2Ftest%2Frun-pass%2Fstr-multiline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstr-multiline.rs?ref=97452c0ca16238a2de5503aca07db26ff9e8ba63", "patch": "@@ -12,6 +12,6 @@ is a test\";\n                is \\\n                another \\\n                test\";\n-    assert (str::eq(a, ~\"this is a test\"));\n-    assert (str::eq(b, ~\"this is another test\"));\n+    assert (a == ~\"this is a test\");\n+    assert (b == ~\"this is another test\");\n }"}, {"sha": "a74d1884e3909b4a57fa512cefe28885f3dcccd8", "filename": "src/test/run-pass/syntax-extension-fmt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/97452c0ca16238a2de5503aca07db26ff9e8ba63/src%2Ftest%2Frun-pass%2Fsyntax-extension-fmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97452c0ca16238a2de5503aca07db26ff9e8ba63/src%2Ftest%2Frun-pass%2Fsyntax-extension-fmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsyntax-extension-fmt.rs?ref=97452c0ca16238a2de5503aca07db26ff9e8ba63", "patch": "@@ -4,7 +4,7 @@ import str;\n fn test(actual: ~str, expected: ~str) {\n     log(debug, actual);\n     log(debug, expected);\n-    assert (str::eq(actual, expected));\n+    assert (actual == expected);\n }\n \n fn main() {"}, {"sha": "48ebe3cf52f78f8767a7b8d10f3b02609e228373", "filename": "src/test/run-pass/utf8_chars.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/97452c0ca16238a2de5503aca07db26ff9e8ba63/src%2Ftest%2Frun-pass%2Futf8_chars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97452c0ca16238a2de5503aca07db26ff9e8ba63/src%2Ftest%2Frun-pass%2Futf8_chars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Futf8_chars.rs?ref=97452c0ca16238a2de5503aca07db26ff9e8ba63", "patch": "@@ -10,7 +10,7 @@ fn main() {\n     assert (str::len(s) == 10u);\n     assert (str::char_len(s) == 4u);\n     assert (vec::len(str::chars(s)) == 4u);\n-    assert (str::eq(str::from_chars(str::chars(s)), s));\n+    assert (str::from_chars(str::chars(s)) == s);\n     assert (str::char_at(s, 0u) == 'e');\n     assert (str::char_at(s, 1u) == '\u00e9');\n \n@@ -23,9 +23,9 @@ fn main() {\n     assert (str::pop_char(stack) == '\u20ac');\n     assert (str::pop_char(stack) == 'c');\n     str::push_char(stack, 'u');\n-    assert (str::eq(stack, ~\"a\u00d7u\"));\n+    assert (stack == ~\"a\u00d7u\");\n     assert (str::shift_char(stack) == 'a');\n     assert (str::shift_char(stack) == '\u00d7');\n     str::unshift_char(stack, '\u00df');\n-    assert (str::eq(stack, ~\"\u00dfu\"));\n+    assert (stack == ~\"\u00dfu\");\n }"}]}