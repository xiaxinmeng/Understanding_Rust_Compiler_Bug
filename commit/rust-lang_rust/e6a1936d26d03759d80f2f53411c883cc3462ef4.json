{"sha": "e6a1936d26d03759d80f2f53411c883cc3462ef4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU2YTE5MzZkMjZkMDM3NTlkODBmMmY1MzQxMWM4ODNjYzM0NjJlZjQ=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-10-17T12:51:43Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-10-21T15:49:38Z"}, "message": "Implement \"method matching\". Similar to trait matching, but with the twist that we\nhave to take the transformed self type into account, and allow for coercion between\nthe receiver and the actual type declared on the impl.", "tree": {"sha": "fcd512e1acc76a5937fa52cb6f11aa4cf8a3d6b2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fcd512e1acc76a5937fa52cb6f11aa4cf8a3d6b2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e6a1936d26d03759d80f2f53411c883cc3462ef4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e6a1936d26d03759d80f2f53411c883cc3462ef4", "html_url": "https://github.com/rust-lang/rust/commit/e6a1936d26d03759d80f2f53411c883cc3462ef4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e6a1936d26d03759d80f2f53411c883cc3462ef4/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "04386f4217275f3a745820af476d8af2a2b4a492", "url": "https://api.github.com/repos/rust-lang/rust/commits/04386f4217275f3a745820af476d8af2a2b4a492", "html_url": "https://github.com/rust-lang/rust/commit/04386f4217275f3a745820af476d8af2a2b4a492"}], "stats": {"total": 472, "additions": 422, "deletions": 50}, "files": [{"sha": "f24121d9a3a5f8b5521aac54c71adb64349757f6", "filename": "src/librustc/middle/traits/doc.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e6a1936d26d03759d80f2f53411c883cc3462ef4/src%2Flibrustc%2Fmiddle%2Ftraits%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6a1936d26d03759d80f2f53411c883cc3462ef4/src%2Flibrustc%2Fmiddle%2Ftraits%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fdoc.rs?ref=e6a1936d26d03759d80f2f53411c883cc3462ef4", "patch": "@@ -272,4 +272,11 @@ nested obligation `int : Bar<U>` to find out that `U=uint`.\n It would be good to only do *just as much* nested resolution as\n necessary. Currently, though, we just do a full resolution.\n \n+## Method matching\n+\n+Method dispach follows a slightly different path than normal trait\n+selection. This is because it must account for the transformed self\n+type of the receiver and various other complications. The procedure is\n+described in `select.rs` in the \"METHOD MATCHING\" section.\n+\n */"}, {"sha": "76715561b03971ac54e63e024eb509b80dd8f7a5", "filename": "src/librustc/middle/traits/mod.rs", "status": "modified", "additions": 2, "deletions": 16, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e6a1936d26d03759d80f2f53411c883cc3462ef4/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6a1936d26d03759d80f2f53411c883cc3462ef4/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs?ref=e6a1936d26d03759d80f2f53411c883cc3462ef4", "patch": "@@ -24,6 +24,8 @@ use syntax::codemap::{Span, DUMMY_SP};\n pub use self::fulfill::FulfillmentContext;\n pub use self::select::SelectionContext;\n pub use self::select::SelectionCache;\n+pub use self::select::{MethodMatchResult, MethodMatched, MethodAmbiguous, MethodDidNotMatch};\n+pub use self::select::{MethodMatchedData}; // intentionally don't export variants\n pub use self::util::supertraits;\n pub use self::util::transitive_bounds;\n pub use self::util::Supertraits;\n@@ -219,22 +221,6 @@ pub struct VtableParamData {\n     pub bound: Rc<ty::TraitRef>,\n }\n \n-pub fn evaluate_obligation<'a,'tcx>(infcx: &InferCtxt<'a,'tcx>,\n-                                    param_env: &ty::ParameterEnvironment,\n-                                    obligation: &Obligation,\n-                                    typer: &Typer<'tcx>)\n-                                    -> bool\n-{\n-    /*!\n-     * Attempts to resolve the obligation given. Returns `None` if\n-     * we are unable to resolve, either because of ambiguity or\n-     * due to insufficient inference.\n-     */\n-\n-    let mut selcx = select::SelectionContext::new(infcx, param_env, typer);\n-    selcx.evaluate_obligation(obligation)\n-}\n-\n pub fn select_inherent_impl<'a,'tcx>(infcx: &InferCtxt<'a,'tcx>,\n                                      param_env: &ty::ParameterEnvironment,\n                                      typer: &Typer<'tcx>,"}, {"sha": "90aabca29812c6e8463133b9976850e7cea19ce1", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 413, "deletions": 34, "changes": 447, "blob_url": "https://github.com/rust-lang/rust/blob/e6a1936d26d03759d80f2f53411c883cc3462ef4/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6a1936d26d03759d80f2f53411c883cc3462ef4/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=e6a1936d26d03759d80f2f53411c883cc3462ef4", "patch": "@@ -62,6 +62,23 @@ pub struct SelectionCache {\n     hashmap: RefCell<HashMap<Rc<ty::TraitRef>, SelectionResult<Candidate>>>,\n }\n \n+pub enum MethodMatchResult {\n+    MethodMatched(MethodMatchedData),\n+    MethodAmbiguous(/* list of impls that could apply */ Vec<ast::DefId>),\n+    MethodDidNotMatch,\n+}\n+\n+#[deriving(Show)]\n+pub enum MethodMatchedData {\n+    // In the case of a precise match, we don't really need to store\n+    // how the match was found. So don't.\n+    PreciseMethodMatch,\n+\n+    // In the case of a coercion, we need to know the precise impl so\n+    // that we can determine the type to which things were coerced.\n+    CoerciveMethodMatch(/* impl we matched */ ast::DefId)\n+}\n+\n /**\n  * The selection process begins by considering all impls, where\n  * clauses, and so forth that might resolve an obligation.  Sometimes\n@@ -190,27 +207,51 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     ///////////////////////////////////////////////////////////////////////////\n     // EVALUATION\n     //\n-    // Tests whether an obligation can be selected or whether an impl can be\n-    // applied to particular types. It skips the \"confirmation\" step and\n-    // hence completely ignores output type parameters.\n+    // Tests whether an obligation can be selected or whether an impl\n+    // can be applied to particular types. It skips the \"confirmation\"\n+    // step and hence completely ignores output type parameters.\n     //\n     // The result is \"true\" if the obliation *may* hold and \"false\" if\n     // we can be sure it does not.\n \n-    pub fn evaluate_obligation(&mut self,\n-                               obligation: &Obligation)\n-                               -> bool\n+    pub fn evaluate_obligation_intercrate(&mut self,\n+                                          obligation: &Obligation)\n+                                          -> bool\n     {\n         /*!\n          * Evaluates whether the obligation `obligation` can be\n-         * satisfied (by any means).\n+         * satisfied (by any means). This \"intercrate\" version allows\n+         * for the possibility that unbound type variables may be\n+         * instantiated with types from another crate. This is\n+         * important for coherence. In practice this means that\n+         * unbound type variables must always be considered ambiguous.\n          */\n \n-        debug!(\"evaluate_obligation({})\",\n+        debug!(\"evaluate_obligation_intercrate({})\",\n                obligation.repr(self.tcx()));\n \n         let stack = self.push_stack(None, obligation);\n-        self.evaluate_stack(&stack).may_apply()\n+        self.evaluate_stack_intercrate(&stack).may_apply()\n+    }\n+\n+    pub fn evaluate_obligation_intracrate(&mut self,\n+                                            obligation: &Obligation)\n+                                            -> bool\n+    {\n+        /*!\n+         * Evaluates whether the obligation `obligation` can be\n+         * satisfied (by any means). This \"intracrate\" version does\n+         * not allow for the possibility that unbound type variables\n+         * may be instantiated with types from another crate; hence,\n+         * if there are unbound inputs but no crates locally visible,\n+         * it considers the result to be unimplemented.\n+         */\n+\n+        debug!(\"evaluate_obligation_intracrate({})\",\n+               obligation.repr(self.tcx()));\n+\n+        let stack = self.push_stack(None, obligation);\n+        self.evaluate_stack_intracrate(&stack).may_apply()\n     }\n \n     fn evaluate_builtin_bound_recursively(&mut self,\n@@ -246,26 +287,47 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                obligation.repr(self.tcx()));\n \n         let stack = self.push_stack(previous_stack.map(|x| x), obligation);\n-        let result = self.evaluate_stack(&stack);\n+\n+        // FIXME(#17901) -- Intercrate vs intracrate resolution is a\n+        // tricky question here. For coherence, we want\n+        // intercrate. Also, there was a nasty cycle around impls like\n+        // `impl<T:Eq> Eq for Vec<T>` (which would wind up checking\n+        // whether `$0:Eq`, where $0 was the value substituted for\n+        // `T`, which could then be checked against the very same\n+        // impl). This problem is avoided by the stricter rules around\n+        // unbound type variables by intercrate. I suspect that in the\n+        // latter case a more fine-grained rule would suffice (i.e.,\n+        // consider it ambiguous if even 1 impl matches, no need to\n+        // figure out which one, but call it unimplemented if 0 impls\n+        // match).\n+        let result = self.evaluate_stack_intercrate(&stack);\n+\n         debug!(\"result: {}\", result);\n         result\n     }\n \n-    fn evaluate_stack(&mut self,\n+    fn evaluate_stack_intercrate(&mut self,\n                       stack: &ObligationStack)\n                       -> EvaluationResult\n     {\n         // Whenever any of the types are unbound, there can always be\n         // an impl.  Even if there are no impls in this crate, perhaps\n         // the type would be unified with something from another crate\n         // that does provide an impl.\n-        let input_types = &stack.skol_trait_ref.substs.types;\n+        let input_types = self.input_types(&*stack.skol_trait_ref);\n         if input_types.iter().any(|&t| ty::type_is_skolemized(t)) {\n-            debug!(\"evaluate_stack({}) --> unbound argument, must be ambiguous\",\n+            debug!(\"evaluate_stack_intercrate({}) --> unbound argument, must be ambiguous\",\n                    stack.skol_trait_ref.repr(self.tcx()));\n             return EvaluatedToAmbig;\n         }\n \n+        self.evaluate_stack_intracrate(stack)\n+    }\n+\n+    fn evaluate_stack_intracrate(&mut self,\n+                                 stack: &ObligationStack)\n+                                 -> EvaluationResult\n+    {\n         // If there is any previous entry on the stack that precisely\n         // matches this obligation, then we can assume that the\n         // obligation is satisfied for now (still all other conditions\n@@ -290,7 +352,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             .skip(1) // skip top-most frame\n             .any(|prev| stack.skol_trait_ref == prev.skol_trait_ref)\n         {\n-            debug!(\"evaluate_stack({}) --> recursive\",\n+            debug!(\"evaluate_stack_intracrate({}) --> recursive\",\n                    stack.skol_trait_ref.repr(self.tcx()));\n             return EvaluatedToOk;\n         }\n@@ -320,7 +382,311 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         self.infcx.probe(|| {\n             match self.match_impl(impl_def_id, obligation) {\n                 Ok(substs) => {\n-                    let vtable_impl = self.vtable_impl(impl_def_id, substs, obligation.cause, 0);\n+                    let vtable_impl = self.vtable_impl(impl_def_id,\n+                                                       substs,\n+                                                       obligation.cause,\n+                                                       obligation.recursion_depth + 1);\n+                    self.winnow_selection(None, VtableImpl(vtable_impl)).may_apply()\n+                }\n+                Err(()) => {\n+                    false\n+                }\n+            }\n+        })\n+    }\n+\n+    ///////////////////////////////////////////////////////////////////////////\n+    // METHOD MATCHING\n+    //\n+    // Method matching is a variation on the normal select/evaluation\n+    // situation.  In this scenario, rather than having a full trait\n+    // reference to select from, we start with an expression like\n+    // `receiver.method(...)`. This means that we have `rcvr_ty`, the\n+    // type of the receiver, and we have a possible trait that\n+    // supplies `method`. We must determine whether the receiver is\n+    // applicable, taking into account the transformed self type\n+    // declared on `method`. We also must consider the possibility\n+    // that `receiver` can be *coerced* into a suitable type (for\n+    // example, a receiver type like `&(Any+Send)` might be coerced\n+    // into a receiver like `&Any` to allow for method dispatch).  See\n+    // the body of `evaluate_method_obligation()` for more details on\n+    // the algorithm.\n+\n+    pub fn evaluate_method_obligation(&mut self,\n+                                      rcvr_ty: ty::t,\n+                                      xform_self_ty: ty::t,\n+                                      obligation: &Obligation)\n+                                      -> MethodMatchResult\n+    {\n+        /*!\n+         * Determine whether a trait-method is applicable to a receiver of\n+         * type `rcvr_ty`. *Does not affect the inference state.*\n+         *\n+         * - `rcvr_ty` -- type of the receiver\n+         * - `xform_self_ty` -- transformed self type declared on the method, with `Self`\n+         *   to a fresh type variable\n+         * - `obligation` -- a reference to the trait where the method is declared, with\n+         *   the input types on the trait replaced with fresh type variables\n+         */\n+\n+        // Here is the situation. We have a trait method declared (say) like so:\n+        //\n+        //     trait TheTrait {\n+        //         fn the_method(self: Rc<Self>, ...) { ... }\n+        //     }\n+        //\n+        // And then we have a call looking (say) like this:\n+        //\n+        //     let x: Rc<Foo> = ...;\n+        //     x.the_method()\n+        //\n+        // Now we want to decide if `TheTrait` is applicable. As a\n+        // human, we can see that `TheTrait` is applicable if there is\n+        // an impl for the type `Foo`. But how does the compiler know\n+        // what impl to look for, given that our receiver has type\n+        // `Rc<Foo>`? We need to take the method's self type into\n+        // account.\n+        //\n+        // On entry to this function, we have the following inputs:\n+        //\n+        // - `rcvr_ty = Rc<Foo>`\n+        // - `xform_self_ty = Rc<$0>`\n+        // - `obligation = $0 as TheTrait`\n+        //\n+        // We do the match in two phases. The first is a *precise\n+        // match*, which means that no coercion is required. This is\n+        // the preferred way to match. It works by first making\n+        // `rcvr_ty` a subtype of `xform_self_ty`. This unifies `$0`\n+        // and `Foo`. We can then evaluate (roughly as normal) the\n+        // trait reference `Foo as TheTrait`.\n+        //\n+        // If this fails, we fallback to a coercive match, described below.\n+\n+        match self.infcx.probe(|| self.match_method_precise(rcvr_ty, xform_self_ty, obligation)) {\n+            Ok(()) => { return MethodMatched(PreciseMethodMatch); }\n+            Err(_) => { }\n+        }\n+\n+        // Coercive matches work slightly differently and cannot\n+        // completely reuse the normal trait matching machinery\n+        // (though they employ many of the same bits and pieces). To\n+        // see how it works, let's continue with our previous example,\n+        // but with the following declarations:\n+        //\n+        // ```\n+        // trait Foo : Bar { .. }\n+        // trait Bar : Baz { ... }\n+        // trait Baz { ... }\n+        // impl TheTrait for Bar {\n+        //     fn the_method(self: Rc<Bar>, ...) { ... }\n+        // }\n+        // ```\n+        //\n+        // Now we see that the receiver type `Rc<Foo>` is actually an\n+        // object type. And in fact the impl we want is an impl on the\n+        // supertrait `Rc<Bar>`.  The precise matching procedure won't\n+        // find it, however, because `Rc<Foo>` is not a subtype of\n+        // `Rc<Bar>` -- it is *coercible* to `Rc<Bar>` (actually, such\n+        // coercions are not yet implemented, but let's leave that\n+        // aside for now).\n+        //\n+        // To handle this case, we employ a different procedure. Recall\n+        // that our initial state is as follows:\n+        //\n+        // - `rcvr_ty = Rc<Foo>`\n+        // - `xform_self_ty = Rc<$0>`\n+        // - `obligation = $0 as TheTrait`\n+        //\n+        // We now go through each impl and instantiate all of its type\n+        // variables, yielding the trait reference that the impl\n+        // provides. In our example, the impl would provide `Bar as\n+        // TheTrait`.  Next we (try to) unify the trait reference that\n+        // the impl provides with the input obligation. This would\n+        // unify `$0` and `Bar`. Now we can see whether the receiver\n+        // type (`Rc<Foo>`) is *coercible to* the transformed self\n+        // type (`Rc<$0> == Rc<Bar>`). In this case, the answer is\n+        // yes, so the impl is considered a candidate.\n+        //\n+        // Note that there is the possibility of ambiguity here, even\n+        // when all types are known. In our example, this might occur\n+        // if there was *also* an impl of `TheTrait` for `Baz`. In\n+        // this case, `Rc<Foo>` would be coercible to both `Rc<Bar>`\n+        // and `Rc<Baz>`. (Note that it is not a *coherence violation*\n+        // to have impls for both `Bar` and `Baz`, despite this\n+        // ambiguity).  In this case, we report an error, listing all\n+        // the applicable impls.  The use can explicitly \"up-coerce\"\n+        // to the type they want.\n+        //\n+        // Note that this coercion step only considers actual impls\n+        // found in the source. This is because all the\n+        // compiler-provided impls (such as those for unboxed\n+        // closures) do not have relevant coercions. This simplifies\n+        // life immensly.\n+\n+        let mut impls =\n+            self.assemble_method_candidates_from_impls(rcvr_ty, xform_self_ty, obligation);\n+\n+        if impls.len() > 1 {\n+            impls.retain(|&c| self.winnow_method_impl(c, rcvr_ty, xform_self_ty, obligation));\n+        }\n+\n+        if impls.len() > 1 {\n+            return MethodAmbiguous(impls);\n+        }\n+\n+        match impls.pop() {\n+            Some(def_id) => MethodMatched(CoerciveMethodMatch(def_id)),\n+            None => MethodDidNotMatch\n+        }\n+    }\n+\n+    pub fn confirm_method_match(&mut self,\n+                                rcvr_ty: ty::t,\n+                                xform_self_ty: ty::t,\n+                                obligation: &Obligation,\n+                                data: MethodMatchedData)\n+    {\n+        /*!\n+         * Given the successful result of a method match, this\n+         * function \"confirms\" the result, which basically repeats the\n+         * various matching operations, but outside of any snapshot so\n+         * that their effects are committed into the inference state.\n+         */\n+\n+        let is_ok = match data {\n+            PreciseMethodMatch => {\n+                self.match_method_precise(rcvr_ty, xform_self_ty, obligation).is_ok()\n+            }\n+\n+            CoerciveMethodMatch(impl_def_id) => {\n+                self.match_method_coerce(impl_def_id, rcvr_ty, xform_self_ty, obligation).is_ok()\n+            }\n+        };\n+\n+        if !is_ok {\n+            self.tcx().sess.span_bug(\n+                obligation.cause.span,\n+                format!(\"match not repeatable: {}, {}, {}, {}\",\n+                        rcvr_ty.repr(self.tcx()),\n+                        xform_self_ty.repr(self.tcx()),\n+                        obligation.repr(self.tcx()),\n+                        data)[]);\n+        }\n+    }\n+\n+    fn match_method_precise(&mut self,\n+                            rcvr_ty: ty::t,\n+                            xform_self_ty: ty::t,\n+                            obligation: &Obligation)\n+                            -> Result<(),()>\n+    {\n+        /*!\n+         * Implements the *precise method match* procedure described in\n+         * `evaluate_method_obligation()`.\n+         */\n+\n+        self.infcx.commit_if_ok(|| {\n+            match self.infcx.sub_types(false, infer::Misc(obligation.cause.span),\n+                                       rcvr_ty, xform_self_ty) {\n+                Ok(()) => { }\n+                Err(_) => { return Err(()); }\n+            }\n+\n+            if self.evaluate_obligation_intracrate(obligation) {\n+                Ok(())\n+            } else {\n+                Err(())\n+            }\n+        })\n+    }\n+\n+    fn assemble_method_candidates_from_impls(&mut self,\n+                                             rcvr_ty: ty::t,\n+                                             xform_self_ty: ty::t,\n+                                             obligation: &Obligation)\n+                                             -> Vec<ast::DefId>\n+    {\n+        /*!\n+         * Assembles a list of potentially applicable impls using the\n+         * *coercive match* procedure described in\n+         * `evaluate_method_obligation()`.\n+         */\n+\n+        let mut candidates = Vec::new();\n+\n+        let all_impls = self.all_impls(obligation.trait_ref.def_id);\n+        for &impl_def_id in all_impls.iter() {\n+            self.infcx.probe(|| {\n+                match self.match_method_coerce(impl_def_id, rcvr_ty, xform_self_ty, obligation) {\n+                    Ok(_) => { candidates.push(impl_def_id); }\n+                    Err(_) => { }\n+                }\n+            });\n+        }\n+\n+        candidates\n+    }\n+\n+    fn match_method_coerce(&mut self,\n+                           impl_def_id: ast::DefId,\n+                           rcvr_ty: ty::t,\n+                           xform_self_ty: ty::t,\n+                           obligation: &Obligation)\n+                           -> Result<Substs, ()>\n+    {\n+        /*!\n+         * Applies the *coercive match* procedure described in\n+         * `evaluate_method_obligation()` to a particular impl.\n+         */\n+\n+        // This is almost always expected to succeed. It\n+        // causes the impl's self-type etc to be unified with\n+        // the type variable that is shared between\n+        // obligation/xform_self_ty. In our example, after\n+        // this is done, the type of `xform_self_ty` would\n+        // change from `Rc<$0>` to `Rc<Foo>` (because $0 is\n+        // unified with `Foo`).\n+        let substs = try!(self.match_impl(impl_def_id, obligation));\n+\n+        // Next, check whether we can coerce. For now we require\n+        // that the coercion be a no-op.\n+        let origin = infer::Misc(obligation.cause.span);\n+        match infer::mk_coercety(self.infcx, true, origin,\n+                                 rcvr_ty, xform_self_ty) {\n+            Ok(None) => { /* Fallthrough */ }\n+            Ok(Some(_)) | Err(_) => { return Err(()); }\n+        }\n+\n+        Ok(substs)\n+    }\n+\n+    fn winnow_method_impl(&mut self,\n+                          impl_def_id: ast::DefId,\n+                          rcvr_ty: ty::t,\n+                          xform_self_ty: ty::t,\n+                          obligation: &Obligation)\n+                          -> bool\n+    {\n+        /*!\n+         * A version of `winnow_impl` applicable to coerice method\n+         * matching.  This is basically the same as `winnow_impl` but\n+         * it uses the method matching procedure and is specific to\n+         * impls.\n+         */\n+\n+        debug!(\"winnow_method_impl: impl_def_id={} rcvr_ty={} xform_self_ty={} obligation={}\",\n+               impl_def_id.repr(self.tcx()),\n+               rcvr_ty.repr(self.tcx()),\n+               xform_self_ty.repr(self.tcx()),\n+               obligation.repr(self.tcx()));\n+\n+        self.infcx.probe(|| {\n+            match self.match_method_coerce(impl_def_id, rcvr_ty, xform_self_ty, obligation) {\n+                Ok(substs) => {\n+                    let vtable_impl = self.vtable_impl(impl_def_id,\n+                                                       substs,\n+                                                       obligation.cause,\n+                                                       obligation.recursion_depth + 1);\n                     self.winnow_selection(None, VtableImpl(vtable_impl)).may_apply()\n                 }\n                 Err(()) => {\n@@ -456,24 +822,17 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             return Ok(None);\n         }\n \n-        // If there are *NO* candidates, that might mean either that\n-        // there is no impl or just that we can't know anything for\n-        // sure.\n+        // If there are *NO* candidates, that there are no impls --\n+        // that we know of, anyway. Note that in the case where there\n+        // are unbound type variables within the obligation, it might\n+        // be the case that you could still satisfy the obligation\n+        // from another crate by instantiating the type variables with\n+        // a type from another crate that does have an impl. This case\n+        // is checked for in `evaluate_obligation` (and hence users\n+        // who might care about this case, like coherence, should use\n+        // that function).\n         if candidates.len() == 0 {\n-            // Annoying edge case: if there are no impls, then there\n-            // is no way that this trait reference is implemented,\n-            // *unless* it contains unbound variables. In that case,\n-            // it is possible that one of those unbound variables will\n-            // be bound to a new type from some other crate which will\n-            // also contain impls.\n-            let skol_obligation_self_ty = self.infcx.skolemize(stack.obligation.self_ty());\n-            return if !self.contains_skolemized_types(skol_obligation_self_ty) {\n-                debug!(\"0 matches, unimpl\");\n-                Err(Unimplemented)\n-            } else {\n-                debug!(\"0 matches, ambig\");\n-                Ok(None)\n-            };\n+            return Err(Unimplemented);\n         }\n \n         // Just one candidate left.\n@@ -491,7 +850,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // scope. Otherwise, use the generic tcx cache, since the\n         // result holds across all environments.\n         if\n-            cache_skol_trait_ref.substs.types.iter().any(\n+            self.input_types(&**cache_skol_trait_ref).iter().any(\n                 |&t| ty::type_has_self(t) || ty::type_has_params(t))\n         {\n             &self.param_env.selection_cache\n@@ -1291,8 +1650,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // it'll do for now until we get the new trait-bound\n         // region skolemization working.\n         let (_, new_signature) =\n-            regionmanip::replace_late_bound_regions_in_fn_sig(\n+            regionmanip::replace_late_bound_regions(\n                 self.tcx(),\n+                closure_type.sig.binder_id,\n                 &closure_type.sig,\n                 |br| self.infcx.next_region_var(\n                          infer::LateBoundRegion(obligation.cause.span, br)));\n@@ -1365,6 +1725,10 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                         trait_ref: Rc<ty::TraitRef>)\n                         -> Result<(),()>\n     {\n+        debug!(\"match_trait_refs: obligation={} trait_ref={}\",\n+               obligation.repr(self.tcx()),\n+               trait_ref.repr(self.tcx()));\n+\n         let origin = infer::RelateOutputImplTypes(obligation.cause.span);\n         match self.infcx.sub_trait_refs(false,\n                                         origin,\n@@ -1591,6 +1955,11 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         found_skol\n     }\n+\n+    fn input_types<'a>(&self, trait_ref: &'a ty::TraitRef) -> &'a [ty::t] {\n+        // Select only the \"input types\" from a trait-reference.\n+        trait_ref.substs.types.as_slice()\n+    }\n }\n \n impl Repr for Candidate {\n@@ -1648,3 +2017,13 @@ impl EvaluationResult {\n         }\n     }\n }\n+\n+impl MethodMatchResult {\n+    pub fn may_apply(&self) -> bool {\n+        match *self {\n+            MethodMatched(_) => true,\n+            MethodAmbiguous(_) => true,\n+            MethodDidNotMatch => false,\n+        }\n+    }\n+}"}]}