{"sha": "b7ee8685ac83e0f3f32ac5ab5d597d5451d07057", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI3ZWU4Njg1YWM4M2UwZjNmMzJhYzVhYjVkNTk3ZDU0NTFkMDcwNTc=", "commit": {"author": {"name": "D\u00e1niel Buga", "email": "bugadani@gmail.com", "date": "2020-08-16T19:04:02Z"}, "committer": {"name": "D\u00e1niel Buga", "email": "bugadani@gmail.com", "date": "2020-08-16T19:04:02Z"}, "message": "Fix dogfooding test errors", "tree": {"sha": "632d60c0a820714d0512cb5f9ed8bf2ae34048e0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/632d60c0a820714d0512cb5f9ed8bf2ae34048e0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b7ee8685ac83e0f3f32ac5ab5d597d5451d07057", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b7ee8685ac83e0f3f32ac5ab5d597d5451d07057", "html_url": "https://github.com/rust-lang/rust/commit/b7ee8685ac83e0f3f32ac5ab5d597d5451d07057", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b7ee8685ac83e0f3f32ac5ab5d597d5451d07057/comments", "author": {"login": "bugadani", "id": 977627, "node_id": "MDQ6VXNlcjk3NzYyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/977627?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bugadani", "html_url": "https://github.com/bugadani", "followers_url": "https://api.github.com/users/bugadani/followers", "following_url": "https://api.github.com/users/bugadani/following{/other_user}", "gists_url": "https://api.github.com/users/bugadani/gists{/gist_id}", "starred_url": "https://api.github.com/users/bugadani/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bugadani/subscriptions", "organizations_url": "https://api.github.com/users/bugadani/orgs", "repos_url": "https://api.github.com/users/bugadani/repos", "events_url": "https://api.github.com/users/bugadani/events{/privacy}", "received_events_url": "https://api.github.com/users/bugadani/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bugadani", "id": 977627, "node_id": "MDQ6VXNlcjk3NzYyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/977627?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bugadani", "html_url": "https://github.com/bugadani", "followers_url": "https://api.github.com/users/bugadani/followers", "following_url": "https://api.github.com/users/bugadani/following{/other_user}", "gists_url": "https://api.github.com/users/bugadani/gists{/gist_id}", "starred_url": "https://api.github.com/users/bugadani/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bugadani/subscriptions", "organizations_url": "https://api.github.com/users/bugadani/orgs", "repos_url": "https://api.github.com/users/bugadani/repos", "events_url": "https://api.github.com/users/bugadani/events{/privacy}", "received_events_url": "https://api.github.com/users/bugadani/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3b52d7f780f2023d6596fe73c0a71f663b26bc33", "url": "https://api.github.com/repos/rust-lang/rust/commits/3b52d7f780f2023d6596fe73c0a71f663b26bc33", "html_url": "https://github.com/rust-lang/rust/commit/3b52d7f780f2023d6596fe73c0a71f663b26bc33"}], "stats": {"total": 172, "additions": 85, "deletions": 87}, "files": [{"sha": "a3e7e9971f8f9b2c95667a764ee6aefb4392a6cc", "filename": "clippy_lints/src/methods/unnecessary_lazy_eval.rs", "status": "modified", "additions": 85, "deletions": 87, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/b7ee8685ac83e0f3f32ac5ab5d597d5451d07057/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_lazy_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7ee8685ac83e0f3f32ac5ab5d597d5451d07057/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_lazy_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_lazy_eval.rs?ref=b7ee8685ac83e0f3f32ac5ab5d597d5451d07057", "patch": "@@ -6,6 +6,66 @@ use rustc_lint::LateContext;\n \n use super::UNNECESSARY_LAZY_EVALUATION;\n \n+// Return true if the expression is an accessor of any of the arguments\n+fn expr_uses_argument(expr: &hir::Expr<'_>, params: &[hir::Param<'_>]) -> bool {\n+    params.iter().any(|arg| {\n+        if_chain! {\n+            if let hir::PatKind::Binding(_, _, ident, _) = arg.pat.kind;\n+            if let hir::ExprKind::Path(hir::QPath::Resolved(_, ref path)) = expr.kind;\n+            if let [p, ..] = path.segments;\n+            then {\n+                ident.name == p.ident.name\n+            } else {\n+                false\n+            }\n+        }\n+    })\n+}\n+\n+fn match_any_qpath(path: &hir::QPath<'_>, paths: &[&[&str]]) -> bool {\n+    paths.iter().any(|candidate| match_qpath(path, candidate))\n+}\n+\n+fn can_simplify(expr: &hir::Expr<'_>, params: &[hir::Param<'_>], variant_calls: bool) -> bool {\n+    match expr.kind {\n+        // Closures returning literals can be unconditionally simplified\n+        hir::ExprKind::Lit(_) => true,\n+\n+        hir::ExprKind::Index(ref object, ref index) => {\n+            // arguments are not being indexed into\n+            if expr_uses_argument(object, params) {\n+                false\n+            } else {\n+                // arguments are not used as index\n+                !expr_uses_argument(index, params)\n+            }\n+        },\n+\n+        // Reading fields can be simplified if the object is not an argument of the closure\n+        hir::ExprKind::Field(ref object, _) => !expr_uses_argument(object, params),\n+\n+        // Paths can be simplified if the root is not the argument, this also covers None\n+        hir::ExprKind::Path(_) => !expr_uses_argument(expr, params),\n+\n+        // Calls to Some, Ok, Err can be considered literals if they don't derive an argument\n+        hir::ExprKind::Call(ref func, ref args) => if_chain! {\n+            if variant_calls; // Disable lint when rules conflict with bind_instead_of_map\n+            if let hir::ExprKind::Path(ref path) = func.kind;\n+            if match_any_qpath(path, &[&[\"Some\"], &[\"Ok\"], &[\"Err\"]]);\n+            then {\n+                // Recursively check all arguments\n+                args.iter().all(|arg| can_simplify(arg, params, variant_calls))\n+            } else {\n+                false\n+            }\n+        },\n+\n+        // For anything more complex than the above, a closure is probably the right solution,\n+        // or the case is handled by an other lint\n+        _ => false,\n+    }\n+}\n+\n /// lint use of `<fn>_else(simple closure)` for `Option`s and `Result`s that can be\n /// replaced with `<fn>(return value of simple closure)`\n pub(super) fn lint<'tcx>(\n@@ -18,96 +78,34 @@ pub(super) fn lint<'tcx>(\n     let is_option = is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(&args[0]), sym!(option_type));\n     let is_result = is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(&args[0]), sym!(result_type));\n \n-    if !is_option && !is_result {\n-        return;\n-    }\n-\n-    // Return true if the expression is an accessor of any of the arguments\n-    fn expr_uses_argument(expr: &hir::Expr<'_>, params: &[hir::Param<'_>]) -> bool {\n-        params.iter().any(|arg| {\n-            if_chain! {\n-                if let hir::PatKind::Binding(_, _, ident, _) = arg.pat.kind;\n-                if let hir::ExprKind::Path(hir::QPath::Resolved(_, ref path)) = expr.kind;\n-                if let [p, ..] = path.segments;\n-                then {\n-                    ident.name == p.ident.name\n-                } else {\n-                    false\n-                }\n-            }\n-        })\n-    }\n+    if is_option || is_result {\n+        if let hir::ExprKind::Closure(_, _, eid, _, _) = args[1].kind {\n+            let body = cx.tcx.hir().body(eid);\n+            let ex = &body.value;\n+            let params = &body.params;\n \n-    fn match_any_qpath(path: &hir::QPath<'_>, paths: &[&[&str]]) -> bool {\n-        paths.iter().any(|candidate| match_qpath(path, candidate))\n-    }\n-\n-    fn can_simplify(expr: &hir::Expr<'_>, params: &[hir::Param<'_>], variant_calls: bool) -> bool {\n-        match expr.kind {\n-            // Closures returning literals can be unconditionally simplified\n-            hir::ExprKind::Lit(_) => true,\n-\n-            hir::ExprKind::Index(ref object, ref index) => {\n-                // arguments are not being indexed into\n-                if !expr_uses_argument(object, params) {\n-                    // arguments are not used as index\n-                    !expr_uses_argument(index, params)\n+            if can_simplify(ex, params, allow_variant_calls) {\n+                let msg = if is_option {\n+                    \"unnecessary closure used to substitute value for `Option::None`\"\n                 } else {\n-                    false\n-                }\n-            },\n-\n-            // Reading fields can be simplified if the object is not an argument of the closure\n-            hir::ExprKind::Field(ref object, _) => !expr_uses_argument(object, params),\n-\n-            // Paths can be simplified if the root is not the argument, this also covers None\n-            hir::ExprKind::Path(_) => !expr_uses_argument(expr, params),\n+                    \"unnecessary closure used to substitute value for `Result::Err`\"\n+                };\n \n-            // Calls to Some, Ok, Err can be considered literals if they don't derive an argument\n-            hir::ExprKind::Call(ref func, ref args) => if_chain! {\n-                if variant_calls; // Disable lint when rules conflict with bind_instead_of_map\n-                if let hir::ExprKind::Path(ref path) = func.kind;\n-                if match_any_qpath(path, &[&[\"Some\"], &[\"Ok\"], &[\"Err\"]]);\n-                then {\n-                    // Recursively check all arguments\n-                    args.iter().all(|arg| can_simplify(arg, params, variant_calls))\n-                } else {\n-                    false\n-                }\n-            },\n-\n-            // For anything more complex than the above, a closure is probably the right solution,\n-            // or the case is handled by an other lint\n-            _ => false,\n-        }\n-    }\n-\n-    if let hir::ExprKind::Closure(_, _, eid, _, _) = args[1].kind {\n-        let body = cx.tcx.hir().body(eid);\n-        let ex = &body.value;\n-        let params = &body.params;\n-\n-        if can_simplify(ex, params, allow_variant_calls) {\n-            let msg = if is_option {\n-                \"unnecessary closure used to substitute value for `Option::None`\"\n-            } else {\n-                \"unnecessary closure used to substitute value for `Result::Err`\"\n-            };\n-\n-            span_lint_and_sugg(\n-                cx,\n-                UNNECESSARY_LAZY_EVALUATION,\n-                expr.span,\n-                msg,\n-                &format!(\"Use `{}` instead\", simplify_using),\n-                format!(\n-                    \"{0}.{1}({2})\",\n-                    snippet(cx, args[0].span, \"..\"),\n-                    simplify_using,\n-                    snippet(cx, ex.span, \"..\"),\n-                ),\n-                Applicability::MachineApplicable,\n-            );\n+                span_lint_and_sugg(\n+                    cx,\n+                    UNNECESSARY_LAZY_EVALUATION,\n+                    expr.span,\n+                    msg,\n+                    &format!(\"Use `{}` instead\", simplify_using),\n+                    format!(\n+                        \"{0}.{1}({2})\",\n+                        snippet(cx, args[0].span, \"..\"),\n+                        simplify_using,\n+                        snippet(cx, ex.span, \"..\"),\n+                    ),\n+                    Applicability::MachineApplicable,\n+                );\n+            }\n         }\n     }\n }"}]}