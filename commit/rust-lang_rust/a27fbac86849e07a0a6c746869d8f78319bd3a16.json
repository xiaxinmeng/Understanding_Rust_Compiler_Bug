{"sha": "a27fbac86849e07a0a6c746869d8f78319bd3a16", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEyN2ZiYWM4Njg0OWUwN2EwYTZjNzQ2ODY5ZDhmNzgzMTliZDNhMTY=", "commit": {"author": {"name": "Aaron Turon", "email": "aturon@mozilla.com", "date": "2014-12-14T08:05:32Z"}, "committer": {"name": "Aaron Turon", "email": "aturon@mozilla.com", "date": "2014-12-19T07:31:52Z"}, "message": "Revise std::thread API to join by default\n\nThis commit is part of a series that introduces a `std::thread` API to\nreplace `std::task`.\n\nIn the new API, `spawn` returns a `JoinGuard`, which by default will\njoin the spawned thread when dropped. It can also be used to join\nexplicitly at any time, returning the thread's result. Alternatively,\nthe spawned thread can be explicitly detached (so no join takes place).\n\nAs part of this change, Rust processes now terminate when the main\nthread exits, even if other detached threads are still running, moving\nRust closer to standard threading models. This new behavior may break code\nthat was relying on the previously implicit join-all.\n\nIn addition to the above, the new thread API also offers some built-in\nsupport for building blocking abstractions in user space; see the module\ndoc for details.\n\nCloses #18000\n\n[breaking-change]", "tree": {"sha": "f17d75fcdd4d353f5ff919e491a5fc71252c0ef1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f17d75fcdd4d353f5ff919e491a5fc71252c0ef1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a27fbac86849e07a0a6c746869d8f78319bd3a16", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a27fbac86849e07a0a6c746869d8f78319bd3a16", "html_url": "https://github.com/rust-lang/rust/commit/a27fbac86849e07a0a6c746869d8f78319bd3a16", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a27fbac86849e07a0a6c746869d8f78319bd3a16/comments", "author": {"login": "aturon", "id": 709807, "node_id": "MDQ6VXNlcjcwOTgwNw==", "avatar_url": "https://avatars.githubusercontent.com/u/709807?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aturon", "html_url": "https://github.com/aturon", "followers_url": "https://api.github.com/users/aturon/followers", "following_url": "https://api.github.com/users/aturon/following{/other_user}", "gists_url": "https://api.github.com/users/aturon/gists{/gist_id}", "starred_url": "https://api.github.com/users/aturon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aturon/subscriptions", "organizations_url": "https://api.github.com/users/aturon/orgs", "repos_url": "https://api.github.com/users/aturon/repos", "events_url": "https://api.github.com/users/aturon/events{/privacy}", "received_events_url": "https://api.github.com/users/aturon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aturon", "id": 709807, "node_id": "MDQ6VXNlcjcwOTgwNw==", "avatar_url": "https://avatars.githubusercontent.com/u/709807?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aturon", "html_url": "https://github.com/aturon", "followers_url": "https://api.github.com/users/aturon/followers", "following_url": "https://api.github.com/users/aturon/following{/other_user}", "gists_url": "https://api.github.com/users/aturon/gists{/gist_id}", "starred_url": "https://api.github.com/users/aturon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aturon/subscriptions", "organizations_url": "https://api.github.com/users/aturon/orgs", "repos_url": "https://api.github.com/users/aturon/repos", "events_url": "https://api.github.com/users/aturon/events{/privacy}", "received_events_url": "https://api.github.com/users/aturon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "13f302d0c5dd3a88426da53ba07cdbe16459635b", "url": "https://api.github.com/repos/rust-lang/rust/commits/13f302d0c5dd3a88426da53ba07cdbe16459635b", "html_url": "https://github.com/rust-lang/rust/commit/13f302d0c5dd3a88426da53ba07cdbe16459635b"}], "stats": {"total": 2250, "additions": 464, "deletions": 1786}, "files": [{"sha": "1b445a6e7367fa77cf6ca20523b1d7e336b2a0fa", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a27fbac86849e07a0a6c746869d8f78319bd3a16/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a27fbac86849e07a0a6c746869d8f78319bd3a16/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=a27fbac86849e07a0a6c746869d8f78319bd3a16", "patch": "@@ -445,7 +445,7 @@ fn run_debuginfo_gdb_test(config: &Config, props: &TestProps, testfile: &Path) {\n             loop {\n                 //waiting 1 second for gdbserver start\n                 timer::sleep(Duration::milliseconds(1000));\n-                let result = Thread::with_join(move || {\n+                let result = Thread::spawn(move || {\n                     tcp::TcpStream::connect(\"127.0.0.1:5039\").unwrap();\n                 }).join();\n                 if result.is_err() {"}, {"sha": "87a3abd8f226bef6f68d36f86301db06037b2898", "filename": "src/doc/guide-tasks.md", "status": "modified", "additions": 17, "deletions": 15, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/a27fbac86849e07a0a6c746869d8f78319bd3a16/src%2Fdoc%2Fguide-tasks.md", "raw_url": "https://github.com/rust-lang/rust/raw/a27fbac86849e07a0a6c746869d8f78319bd3a16/src%2Fdoc%2Fguide-tasks.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-tasks.md?ref=a27fbac86849e07a0a6c746869d8f78319bd3a16", "patch": "@@ -1,5 +1,7 @@\n % The Rust Tasks and Communication Guide\n \n+**NOTE** This guide is badly out of date an needs to be rewritten.\n+\n # Introduction\n \n Rust provides safe concurrent abstractions through a number of core library\n@@ -22,7 +24,7 @@ from shared mutable state.\n At its simplest, creating a task is a matter of calling the `spawn` function\n with a closure argument. `spawn` executes the closure in the new task.\n \n-```{rust}\n+```{rust,ignore}\n # use std::task::spawn;\n \n // Print something profound in a different task using a named function\n@@ -49,7 +51,7 @@ closure is limited to capturing `Send`-able data from its environment\n ensures that `spawn` can safely move the entire closure and all its\n associated state into an entirely different task for execution.\n \n-```{rust}\n+```{rust,ignore}\n # use std::task::spawn;\n # fn generate_task_number() -> int { 0 }\n // Generate some state locally\n@@ -75,7 +77,7 @@ The simplest way to create a channel is to use the `channel` function to create\n of a channel, and a **receiver** is the receiving endpoint. Consider the following\n example of calculating two results concurrently:\n \n-```{rust}\n+```{rust,ignore}\n # use std::task::spawn;\n \n let (tx, rx): (Sender<int>, Receiver<int>) = channel();\n@@ -96,15 +98,15 @@ stream for sending and receiving integers (the left-hand side of the `let`,\n `(tx, rx)`, is an example of a destructuring let: the pattern separates a tuple\n into its component parts).\n \n-```{rust}\n+```{rust,ignore}\n let (tx, rx): (Sender<int>, Receiver<int>) = channel();\n ```\n \n The child task will use the sender to send data to the parent task, which will\n wait to receive the data on the receiver. The next statement spawns the child\n task.\n \n-```{rust}\n+```{rust,ignore}\n # use std::task::spawn;\n # fn some_expensive_computation() -> int { 42 }\n # let (tx, rx) = channel();\n@@ -123,7 +125,7 @@ computation, then sends the result over the captured channel.\n Finally, the parent continues with some other expensive computation, then waits\n for the child's result to arrive on the receiver:\n \n-```{rust}\n+```{rust,ignore}\n # fn some_other_expensive_computation() {}\n # let (tx, rx) = channel::<int>();\n # tx.send(0);\n@@ -154,7 +156,7 @@ spawn(move || {\n \n Instead we can clone the `tx`, which allows for multiple senders.\n \n-```{rust}\n+```{rust,ignore}\n let (tx, rx) = channel();\n \n for init_val in range(0u, 3) {\n@@ -179,7 +181,7 @@ Note that the above cloning example is somewhat contrived since you could also\n simply use three `Sender` pairs, but it serves to illustrate the point. For\n reference, written with multiple streams, it might look like the example below.\n \n-```{rust}\n+```{rust,ignore}\n # use std::task::spawn;\n \n // Create a vector of ports, one for each child task\n@@ -203,7 +205,7 @@ getting the result later.\n \n The basic example below illustrates this.\n \n-```{rust}\n+```{rust,ignore}\n use std::sync::Future;\n \n # fn main() {\n@@ -230,7 +232,7 @@ called.\n Here is another example showing how futures allow you to background\n computations. The workload will be distributed on the available cores.\n \n-```{rust}\n+```{rust,ignore}\n # use std::num::Float;\n # use std::sync::Future;\n fn partial_sum(start: uint) -> f64 {\n@@ -268,7 +270,7 @@ Here is a small example showing how to use Arcs. We wish to run concurrently\n several computations on a single large vector of floats. Each task needs the\n full vector to perform its duty.\n \n-```{rust}\n+```{rust,ignore}\n use std::num::Float;\n use std::rand;\n use std::sync::Arc;\n@@ -295,7 +297,7 @@ The function `pnorm` performs a simple computation on the vector (it computes\n the sum of its items at the power given as argument and takes the inverse power\n of this value). The Arc on the vector is created by the line:\n \n-```{rust}\n+```{rust,ignore}\n # use std::rand;\n # use std::sync::Arc;\n # fn main() {\n@@ -309,7 +311,7 @@ the wrapper and not its contents. Within the task's procedure, the captured\n Arc reference can be used as a shared reference to the underlying vector as\n if it were local.\n \n-```{rust}\n+```{rust,ignore}\n # use std::rand;\n # use std::sync::Arc;\n # fn pnorm(nums: &[f64], p: uint) -> f64 { 4.0 }\n@@ -346,11 +348,11 @@ and `()`, callers can pattern-match on a result to check whether it's an `Ok`\n result with an `int` field (representing a successful result) or an `Err` result\n (representing termination with an error).\n \n-```{rust}\n+```{rust,ignore}\n # use std::thread::Thread;\n # fn some_condition() -> bool { false }\n # fn calculate_result() -> int { 0 }\n-let result: Result<int, Box<std::any::Any + Send>> = Thread::with_join(move || {\n+let result: Result<int, Box<std::any::Any + Send>> = Thread::spawn(move || {\n     if some_condition() {\n         calculate_result()\n     } else {"}, {"sha": "d739ad105fc873776a9e900088b2f32957acda8c", "filename": "src/doc/guide.md", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a27fbac86849e07a0a6c746869d8f78319bd3a16/src%2Fdoc%2Fguide.md", "raw_url": "https://github.com/rust-lang/rust/raw/a27fbac86849e07a0a6c746869d8f78319bd3a16/src%2Fdoc%2Fguide.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide.md?ref=a27fbac86849e07a0a6c746869d8f78319bd3a16", "patch": "@@ -5217,6 +5217,8 @@ the same function, so our binary is a little bit larger.\n \n # Tasks\n \n+**NOTE**: this section is currently out of date and will be rewritten soon.\n+\n Concurrency and parallelism are topics that are of increasing interest to a\n broad subsection of software developers. Modern computers are often multi-core,\n to the point that even embedded devices like cell phones have more than one\n@@ -5231,7 +5233,7 @@ library, and not part of the language. This means that in the future, other\n concurrency libraries can be written for Rust to help in specific scenarios.\n Here's an example of creating a task:\n \n-```{rust}\n+```{rust,ignore}\n spawn(move || {\n     println!(\"Hello from a task!\");\n });\n@@ -5261,7 +5263,7 @@ If tasks were only able to capture these values, they wouldn't be very useful.\n Luckily, tasks can communicate with each other through **channel**s. Channels\n work like this:\n \n-```{rust}\n+```{rust,ignore}\n let (tx, rx) = channel();\n \n spawn(move || {\n@@ -5280,7 +5282,7 @@ which returns an `Result<T, TryRecvError>` and does not block.\n \n If you want to send messages to the task as well, create two channels!\n \n-```{rust}\n+```{rust,ignore}\n let (tx1, rx1) = channel();\n let (tx2, rx2) = channel();\n \n@@ -5340,7 +5342,7 @@ we'll just get the value immediately.\n Tasks don't always succeed, they can also panic. A task that wishes to panic\n can call the `panic!` macro, passing a message:\n \n-```{rust}\n+```{rust,ignore}\n spawn(move || {\n     panic!(\"Nope.\");\n });\n@@ -5349,7 +5351,7 @@ spawn(move || {\n If a task panics, it is not possible for it to recover. However, it can\n notify other tasks that it has panicked. We can do this with `task::try`:\n \n-```{rust}\n+```{rust,ignore}\n use std::task;\n use std::rand;\n "}, {"sha": "5be97034357eb11dde654053571898fa2cc9a924", "filename": "src/doc/intro.md", "status": "modified", "additions": 17, "deletions": 9, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/a27fbac86849e07a0a6c746869d8f78319bd3a16/src%2Fdoc%2Fintro.md", "raw_url": "https://github.com/rust-lang/rust/raw/a27fbac86849e07a0a6c746869d8f78319bd3a16/src%2Fdoc%2Fintro.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fintro.md?ref=a27fbac86849e07a0a6c746869d8f78319bd3a16", "patch": "@@ -389,11 +389,13 @@ safe concurrent programs.\n Here's an example of a concurrent Rust program:\n \n ```{rust}\n+use std::thread::Thread;\n+\n fn main() {\n     for _ in range(0u, 10u) {\n-        spawn(move || {\n+        Thread::spawn(move || {\n             println!(\"Hello, world!\");\n-        });\n+        }).detach();\n     }\n }\n ```\n@@ -403,7 +405,8 @@ This program creates ten threads, who all print `Hello, world!`. The\n double bars `||`. (The `move` keyword indicates that the closure takes\n ownership of any data it uses; we'll have more on the significance of\n this shortly.) This closure is executed in a new thread created by\n-`spawn`.\n+`spawn`. The `detach` method means that the child thread is allowed to\n+outlive its parent.\n \n One common form of problem in concurrent programs is a 'data race.'\n This occurs when two different threads attempt to access the same\n@@ -418,13 +421,15 @@ problem.\n Let's see an example. This Rust code will not compile:\n \n ```{rust,ignore}\n+use std::thread::Thread;\n+\n fn main() {\n     let mut numbers = vec![1i, 2i, 3i];\n \n     for i in range(0u, 3u) {\n-        spawn(move || {\n+        Thread::spawn(move || {\n             for j in range(0, 3) { numbers[j] += 1 }\n-        });\n+        }).detach();\n     }\n }\n ```\n@@ -469,20 +474,21 @@ mutation doesn't cause a data race.\n Here's what using an Arc with a Mutex looks like:\n \n ```{rust}\n+use std::thread::Thread;\n use std::sync::{Arc,Mutex};\n \n fn main() {\n     let numbers = Arc::new(Mutex::new(vec![1i, 2i, 3i]));\n \n     for i in range(0u, 3u) {\n         let number = numbers.clone();\n-        spawn(move || {\n+        Thread::spawn(move || {\n             let mut array = number.lock();\n \n             (*array)[i] += 1;\n \n             println!(\"numbers[{}] is {}\", i, (*array)[i]);\n-        });\n+        }).detach();\n     }\n }\n ```\n@@ -532,13 +538,15 @@ As an example, Rust's ownership system is _entirely_ at compile time. The\n safety check that makes this an error about moved values:\n \n ```{rust,ignore}\n+use std::thread::Thread;\n+\n fn main() {\n     let vec = vec![1i, 2, 3];\n \n     for i in range(1u, 3) {\n-        spawn(move || {\n+        Thread::spawn(move || {\n             println!(\"{}\", vec[i]);\n-        });\n+        }).detach();\n     }\n }\n ```"}, {"sha": "e909947ab08b0cb9e55d9915803c3fdf26503119", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a27fbac86849e07a0a6c746869d8f78319bd3a16/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a27fbac86849e07a0a6c746869d8f78319bd3a16/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=a27fbac86849e07a0a6c746869d8f78319bd3a16", "patch": "@@ -39,6 +39,7 @@ use heap::deallocate;\n ///\n /// ```rust\n /// use std::sync::Arc;\n+/// use std::thread::Thread;\n ///\n /// fn main() {\n ///     let numbers = Vec::from_fn(100, |i| i as f32);\n@@ -47,11 +48,11 @@ use heap::deallocate;\n ///     for _ in range(0u, 10) {\n ///         let child_numbers = shared_numbers.clone();\n ///\n-///         spawn(move || {\n+///         Thread::spawn(move || {\n ///             let local_numbers = child_numbers.as_slice();\n ///\n ///             // Work with the local numbers\n-///         });\n+///         }).detach();\n ///     }\n /// }\n /// ```"}, {"sha": "d3790e320ad651b955d6b675f15d25714eccec76", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a27fbac86849e07a0a6c746869d8f78319bd3a16/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a27fbac86849e07a0a6c746869d8f78319bd3a16/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=a27fbac86849e07a0a6c746869d8f78319bd3a16", "patch": "@@ -1344,6 +1344,7 @@ pub mod raw {\n \n #[cfg(test)]\n mod tests {\n+    use std::boxed::Box;\n     use std::cell::Cell;\n     use std::default::Default;\n     use std::mem;\n@@ -1627,7 +1628,10 @@ mod tests {\n     #[test]\n     fn test_swap_remove_noncopyable() {\n         // Tests that we don't accidentally run destructors twice.\n-        let mut v = vec![Box::new(()), Box::new(()), Box::new(())];\n+        let mut v = Vec::new();\n+        v.push(box 0u8);\n+        v.push(box 0u8);\n+        v.push(box 0u8);\n         let mut _e = v.swap_remove(0);\n         assert_eq!(v.len(), 2);\n         _e = v.swap_remove(1);"}, {"sha": "b44b87bd938075cc169a57c652a34c8aafc1dd43", "filename": "src/libcore/borrow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a27fbac86849e07a0a6c746869d8f78319bd3a16/src%2Flibcore%2Fborrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a27fbac86849e07a0a6c746869d8f78319bd3a16/src%2Flibcore%2Fborrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fborrow.rs?ref=a27fbac86849e07a0a6c746869d8f78319bd3a16", "patch": "@@ -92,7 +92,7 @@ impl<'a, T, Sized? B> BorrowFrom<Cow<'a, T, B>> for B where B: ToOwned<T> {\n \n /// Trait for moving into a `Cow`\n pub trait IntoCow<'a, T, Sized? B> {\n-    /// Moves `serlf` into `Cow`\n+    /// Moves `self` into `Cow`\n     fn into_cow(self) -> Cow<'a, T, B>;\n }\n "}, {"sha": "979ddaecb4ae3087d809ba0a8b986f1f778e975e", "filename": "src/libcoretest/finally.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a27fbac86849e07a0a6c746869d8f78319bd3a16/src%2Flibcoretest%2Ffinally.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a27fbac86849e07a0a6c746869d8f78319bd3a16/src%2Flibcoretest%2Ffinally.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Ffinally.rs?ref=a27fbac86849e07a0a6c746869d8f78319bd3a16", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use core::finally::{try_finally, Finally};\n-use std::task::failing;\n+use std::thread::Thread;\n \n #[test]\n fn test_success() {\n@@ -20,7 +20,7 @@ fn test_success() {\n             *i = 10;\n         },\n         |i| {\n-            assert!(!failing());\n+            assert!(!Thread::panicking());\n             assert_eq!(*i, 10);\n             *i = 20;\n         });\n@@ -38,7 +38,7 @@ fn test_fail() {\n             panic!();\n         },\n         |i| {\n-            assert!(failing());\n+            assert!(Thread::panicking());\n             assert_eq!(*i, 10);\n         })\n }"}, {"sha": "120654678e96e9d2b83431b47b60e787f75eecef", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a27fbac86849e07a0a6c746869d8f78319bd3a16/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a27fbac86849e07a0a6c746869d8f78319bd3a16/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=a27fbac86849e07a0a6c746869d8f78319bd3a16", "patch": "@@ -475,22 +475,18 @@ pub fn monitor<F:FnOnce()+Send>(f: F) {\n     static STACK_SIZE: uint = 32000000; // 32MB\n \n     let (tx, rx) = channel();\n-    let mut w = Some(io::ChanWriter::new(tx)); // option dance\n+    let w = io::ChanWriter::new(tx);\n     let mut r = io::ChanReader::new(rx);\n \n-    let mut cfg = thread::cfg().name(\"rustc\".to_string());\n+    let mut cfg = thread::Builder::new().name(\"rustc\".to_string());\n \n     // FIXME: Hacks on hacks. If the env is trying to override the stack size\n     // then *don't* set it explicitly.\n     if os::getenv(\"RUST_MIN_STACK\").is_none() {\n         cfg = cfg.stack_size(STACK_SIZE);\n     }\n \n-    let f = proc() {\n-        std::io::stdio::set_stderr(box w.take().unwrap());\n-        f()\n-    };\n-    match cfg.with_join(f).join() {\n+    match cfg.spawn(move || { std::io::stdio::set_stderr(box w); f() }).join() {\n         Ok(()) => { /* fallthrough */ }\n         Err(value) => {\n             // Task panicked without emitting a fatal diagnostic"}, {"sha": "df7df2f08d9839f84b8ac6b7bd5ce77f340d6f33", "filename": "src/librustc_trans/back/write.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a27fbac86849e07a0a6c746869d8f78319bd3a16/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a27fbac86849e07a0a6c746869d8f78319bd3a16/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fwrite.rs?ref=a27fbac86849e07a0a6c746869d8f78319bd3a16", "patch": "@@ -900,7 +900,7 @@ fn run_work_multithreaded(sess: &Session,\n         let mut tx = Some(tx);\n         futures.push(rx);\n \n-        thread::cfg().name(format!(\"codegen-{}\", i)).spawn(move |:| {\n+        thread::Builder::new().name(format!(\"codegen-{}\", i)).spawn(move |:| {\n             let diag_handler = mk_handler(box diag_emitter);\n \n             // Must construct cgcx inside the proc because it has non-Send\n@@ -927,7 +927,7 @@ fn run_work_multithreaded(sess: &Session,\n             }\n \n             tx.take().unwrap().send(());\n-        });\n+        }).detach();\n     }\n \n     let mut panicked = false;"}, {"sha": "9b99956937c24cc6f270818c3835b9319e7d580e", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a27fbac86849e07a0a6c746869d8f78319bd3a16/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a27fbac86849e07a0a6c746869d8f78319bd3a16/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=a27fbac86849e07a0a6c746869d8f78319bd3a16", "patch": "@@ -102,7 +102,11 @@ struct Output {\n }\n \n pub fn main() {\n-    std::os::set_exit_status(main_args(std::os::args().as_slice()));\n+    static STACK_SIZE: uint = 32000000; // 32MB\n+    let res = std::thread::Builder::new().stack_size(STACK_SIZE).spawn(move || {\n+        main_args(std::os::args().as_slice())\n+    }).join();\n+    std::os::set_exit_status(res.map_err(|_| ()).unwrap());\n }\n \n pub fn opts() -> Vec<getopts::OptGroup> {\n@@ -343,7 +347,7 @@ fn rust_input(cratefile: &str, externs: core::Externs, matches: &getopts::Matche\n     let cr = Path::new(cratefile);\n     info!(\"starting to run rustc\");\n \n-    let (mut krate, analysis) = std::thread::Thread::with_join(move |:| {\n+    let (mut krate, analysis) = std::thread::Thread::spawn(move |:| {\n         let cr = cr;\n         core::run_core(libs, cfgs, externs, &cr, triple)\n     }).join().map_err(|_| \"rustc failed\").unwrap();"}, {"sha": "b55097c0c5a1bd734acae3c14e570db29c94ba64", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a27fbac86849e07a0a6c746869d8f78319bd3a16/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a27fbac86849e07a0a6c746869d8f78319bd3a16/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=a27fbac86849e07a0a6c746869d8f78319bd3a16", "patch": "@@ -155,7 +155,7 @@ fn runtest(test: &str, cratename: &str, libs: Vec<Path>, externs: core::Externs,\n             None => box io::stderr() as Box<Writer>,\n         };\n         io::util::copy(&mut p, &mut err).unwrap();\n-    });\n+    }).detach();\n     let emitter = diagnostic::EmitterWriter::new(box w2, None);\n \n     // Compile the code"}, {"sha": "175e057c22f2ea3e5f70b3147a778a6dc17c24e9", "filename": "src/librustrt/thread.rs", "status": "removed", "additions": 0, "deletions": 559, "changes": 559, "blob_url": "https://github.com/rust-lang/rust/blob/13f302d0c5dd3a88426da53ba07cdbe16459635b/src%2Flibrustrt%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13f302d0c5dd3a88426da53ba07cdbe16459635b/src%2Flibrustrt%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Fthread.rs?ref=13f302d0c5dd3a88426da53ba07cdbe16459635b", "patch": "@@ -1,559 +0,0 @@\n-// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Native os-thread management\n-//!\n-//! This modules contains bindings necessary for managing OS-level threads.\n-//! These functions operate outside of the rust runtime, creating threads\n-//! which are not used for scheduling in any way.\n-\n-#![allow(non_camel_case_types)]\n-\n-use core::prelude::*;\n-\n-use alloc::boxed::Box;\n-use core::mem;\n-use core::uint;\n-use libc;\n-use thunk::{Thunk};\n-\n-use stack;\n-use stack_overflow;\n-\n-pub unsafe fn init() {\n-    imp::guard::init();\n-    stack_overflow::init();\n-}\n-\n-pub unsafe fn cleanup() {\n-    stack_overflow::cleanup();\n-}\n-\n-#[cfg(target_os = \"windows\")]\n-type StartFn = extern \"system\" fn(*mut libc::c_void) -> imp::rust_thread_return;\n-\n-#[cfg(not(target_os = \"windows\"))]\n-type StartFn = extern \"C\" fn(*mut libc::c_void) -> imp::rust_thread_return;\n-\n-/// This struct represents a native thread's state. This is used to join on an\n-/// existing thread created in the join-able state.\n-pub struct Thread<T> {\n-    native: imp::rust_thread,\n-    joined: bool,\n-    packet: Box<Option<T>>,\n-}\n-\n-static DEFAULT_STACK_SIZE: uint = 1024 * 1024;\n-\n-// This is the starting point of rust os threads. The first thing we do\n-// is make sure that we don't trigger __morestack (also why this has a\n-// no_stack_check annotation), and then we extract the main function\n-// and invoke it.\n-#[no_stack_check]\n-fn start_thread(main: *mut libc::c_void) -> imp::rust_thread_return {\n-    unsafe {\n-        stack::record_os_managed_stack_bounds(0, uint::MAX);\n-        let handler = stack_overflow::Handler::new();\n-        let f: Box<Thunk> = mem::transmute(main);\n-        f.invoke(());\n-        drop(handler);\n-        mem::transmute(0 as imp::rust_thread_return)\n-    }\n-}\n-\n-#[no_stack_check]\n-#[cfg(target_os = \"windows\")]\n-extern \"system\" fn thread_start(main: *mut libc::c_void) -> imp::rust_thread_return {\n-    return start_thread(main);\n-}\n-\n-#[no_stack_check]\n-#[cfg(not(target_os = \"windows\"))]\n-extern fn thread_start(main: *mut libc::c_void) -> imp::rust_thread_return {\n-    return start_thread(main);\n-}\n-\n-/// Returns the last writable byte of the main thread's stack next to the guard\n-/// page. Must be called from the main thread.\n-pub fn main_guard_page() -> uint {\n-    unsafe {\n-        imp::guard::main()\n-    }\n-}\n-\n-/// Returns the last writable byte of the current thread's stack next to the\n-/// guard page. Must not be called from the main thread.\n-pub fn current_guard_page() -> uint {\n-    unsafe {\n-        imp::guard::current()\n-    }\n-}\n-\n-// There are two impl blocks b/c if T were specified at the top then it's just a\n-// pain to specify a type parameter on Thread::spawn (which doesn't need the\n-// type parameter).\n-impl Thread<()> {\n-\n-    /// Starts execution of a new OS thread.\n-    ///\n-    /// This function will not wait for the thread to join, but a handle to the\n-    /// thread will be returned.\n-    ///\n-    /// Note that the handle returned is used to acquire the return value of the\n-    /// procedure `main`. The `join` function will wait for the thread to finish\n-    /// and return the value that `main` generated.\n-    ///\n-    /// Also note that the `Thread` returned will *always* wait for the thread\n-    /// to finish executing. This means that even if `join` is not explicitly\n-    /// called, when the `Thread` falls out of scope its destructor will block\n-    /// waiting for the OS thread.\n-    pub fn start<T,F>(main: F) -> Thread<T>\n-        where T:Send, F:FnOnce() -> T, F:Send\n-    {\n-        Thread::start_stack(DEFAULT_STACK_SIZE, main)\n-    }\n-\n-    /// Performs the same functionality as `start`, but specifies an explicit\n-    /// stack size for the new thread.\n-    pub fn start_stack<T, F>(stack: uint, main: F) -> Thread<T>\n-        where T:Send, F:FnOnce() -> T, F:Send\n-    {\n-        // We need the address of the packet to fill in to be stable so when\n-        // `main` fills it in it's still valid, so allocate an extra box to do\n-        // so.\n-        let packet = box None;\n-        let packet2: *mut Option<T> = unsafe {\n-            *mem::transmute::<&Box<Option<T>>, *const *mut Option<T>>(&packet)\n-        };\n-        let native = unsafe {\n-            imp::create(stack, Thunk::new(move |:| {\n-                *packet2 = Some(main.call_once(()));\n-            }))\n-        };\n-\n-        Thread {\n-            native: native,\n-            joined: false,\n-            packet: packet,\n-        }\n-    }\n-\n-    /// This will spawn a new thread, but it will not wait for the thread to\n-    /// finish, nor is it possible to wait for the thread to finish.\n-    ///\n-    /// This corresponds to creating threads in the 'detached' state on unix\n-    /// systems. Note that platforms may not keep the main program alive even if\n-    /// there are detached thread still running around.\n-    pub fn spawn<F>(main: F)\n-        where F : FnOnce() + Send\n-    {\n-        Thread::spawn_stack(DEFAULT_STACK_SIZE, main)\n-    }\n-\n-    /// Performs the same functionality as `spawn`, but explicitly specifies a\n-    /// stack size for the new thread.\n-    pub fn spawn_stack<F>(stack: uint, main: F)\n-        where F : FnOnce() + Send\n-    {\n-        unsafe {\n-            let handle = imp::create(stack, Thunk::new(main));\n-            imp::detach(handle);\n-        }\n-    }\n-\n-    /// Relinquishes the CPU slot that this OS-thread is currently using,\n-    /// allowing another thread to run for awhile.\n-    pub fn yield_now() {\n-        unsafe { imp::yield_now(); }\n-    }\n-}\n-\n-impl<T: Send> Thread<T> {\n-    /// Wait for this thread to finish, returning the result of the thread's\n-    /// calculation.\n-    pub fn join(mut self) -> T {\n-        assert!(!self.joined);\n-        unsafe { imp::join(self.native) };\n-        self.joined = true;\n-        assert!(self.packet.is_some());\n-        self.packet.take().unwrap()\n-    }\n-}\n-\n-#[unsafe_destructor]\n-impl<T: Send> Drop for Thread<T> {\n-    fn drop(&mut self) {\n-        // This is required for correctness. If this is not done then the thread\n-        // would fill in a return box which no longer exists.\n-        if !self.joined {\n-            unsafe { imp::join(self.native) };\n-        }\n-    }\n-}\n-\n-#[cfg(windows)]\n-#[allow(non_snake_case)]\n-mod imp {\n-    use alloc::boxed::Box;\n-    use core::cmp;\n-    use core::mem;\n-    use core::ptr;\n-    use libc;\n-    use libc::types::os::arch::extra::{LPSECURITY_ATTRIBUTES, SIZE_T, BOOL,\n-                                       LPVOID, DWORD, LPDWORD, HANDLE};\n-    use stack::RED_ZONE;\n-    use thunk::Thunk;\n-\n-    pub type rust_thread = HANDLE;\n-    pub type rust_thread_return = DWORD;\n-\n-    pub mod guard {\n-        pub unsafe fn main() -> uint {\n-            0\n-        }\n-\n-        pub unsafe fn current() -> uint {\n-            0\n-        }\n-\n-        pub unsafe fn init() {\n-        }\n-    }\n-\n-    pub unsafe fn create(stack: uint, p: Thunk) -> rust_thread {\n-        let arg: *mut libc::c_void = mem::transmute(box p);\n-\n-        // FIXME On UNIX, we guard against stack sizes that are too small but\n-        // that's because pthreads enforces that stacks are at least\n-        // PTHREAD_STACK_MIN bytes big.  Windows has no such lower limit, it's\n-        // just that below a certain threshold you can't do anything useful.\n-        // That threshold is application and architecture-specific, however.\n-        // For now, the only requirement is that it's big enough to hold the\n-        // red zone.  Round up to the next 64 kB because that's what the NT\n-        // kernel does, might as well make it explicit.  With the current\n-        // 20 kB red zone, that makes for a 64 kB minimum stack.\n-        let stack_size = (cmp::max(stack, RED_ZONE) + 0xfffe) & (-0xfffe - 1);\n-        let ret = CreateThread(ptr::null_mut(), stack_size as libc::size_t,\n-                               super::thread_start, arg, 0, ptr::null_mut());\n-\n-        if ret as uint == 0 {\n-            // be sure to not leak the closure\n-            let _p: Box<Thunk> = mem::transmute(arg);\n-            panic!(\"failed to spawn native thread: {}\", ret);\n-        }\n-        return ret;\n-    }\n-\n-    pub unsafe fn join(native: rust_thread) {\n-        use libc::consts::os::extra::INFINITE;\n-        WaitForSingleObject(native, INFINITE);\n-    }\n-\n-    pub unsafe fn detach(native: rust_thread) {\n-        assert!(libc::CloseHandle(native) != 0);\n-    }\n-\n-    pub unsafe fn yield_now() {\n-        // This function will return 0 if there are no other threads to execute,\n-        // but this also means that the yield was useless so this isn't really a\n-        // case that needs to be worried about.\n-        SwitchToThread();\n-    }\n-\n-    #[allow(non_snake_case)]\n-    extern \"system\" {\n-        fn CreateThread(lpThreadAttributes: LPSECURITY_ATTRIBUTES,\n-                        dwStackSize: SIZE_T,\n-                        lpStartAddress: super::StartFn,\n-                        lpParameter: LPVOID,\n-                        dwCreationFlags: DWORD,\n-                        lpThreadId: LPDWORD) -> HANDLE;\n-        fn WaitForSingleObject(hHandle: HANDLE, dwMilliseconds: DWORD) -> DWORD;\n-        fn SwitchToThread() -> BOOL;\n-    }\n-}\n-\n-#[cfg(unix)]\n-mod imp {\n-    use core::prelude::*;\n-\n-    use alloc::boxed::Box;\n-    use core::cmp;\n-    use core::mem;\n-    use core::ptr;\n-    use libc::consts::os::posix01::{PTHREAD_CREATE_JOINABLE, PTHREAD_STACK_MIN};\n-    use libc;\n-    use thunk::Thunk;\n-\n-    use stack::RED_ZONE;\n-\n-    pub type rust_thread = libc::pthread_t;\n-    pub type rust_thread_return = *mut u8;\n-\n-    #[cfg(all(not(target_os = \"linux\"), not(target_os = \"macos\")))]\n-    pub mod guard {\n-        pub unsafe fn current() -> uint {\n-            0\n-        }\n-\n-        pub unsafe fn main() -> uint {\n-            0\n-        }\n-\n-        pub unsafe fn init() {\n-        }\n-    }\n-\n-    #[cfg(any(target_os = \"linux\", target_os = \"macos\"))]\n-    pub mod guard {\n-        use super::*;\n-        #[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n-        use core::mem;\n-        #[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n-        use core::ptr;\n-        use libc;\n-        use libc::funcs::posix88::mman::{mmap};\n-        use libc::consts::os::posix88::{PROT_NONE,\n-                                        MAP_PRIVATE,\n-                                        MAP_ANON,\n-                                        MAP_FAILED,\n-                                        MAP_FIXED};\n-\n-        // These are initialized in init() and only read from after\n-        static mut PAGE_SIZE: uint = 0;\n-        static mut GUARD_PAGE: uint = 0;\n-\n-        #[cfg(target_os = \"macos\")]\n-        unsafe fn get_stack_start() -> *mut libc::c_void {\n-            current() as *mut libc::c_void\n-        }\n-\n-        #[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n-        unsafe fn get_stack_start() -> *mut libc::c_void {\n-            let mut attr: libc::pthread_attr_t = mem::zeroed();\n-            if pthread_getattr_np(pthread_self(), &mut attr) != 0 {\n-                panic!(\"failed to get thread attributes\");\n-            }\n-            let mut stackaddr = ptr::null_mut();\n-            let mut stacksize = 0;\n-            if pthread_attr_getstack(&attr, &mut stackaddr, &mut stacksize) != 0 {\n-                panic!(\"failed to get stack information\");\n-            }\n-            if pthread_attr_destroy(&mut attr) != 0 {\n-                panic!(\"failed to destroy thread attributes\");\n-            }\n-            stackaddr\n-        }\n-\n-        pub unsafe fn init() {\n-            let psize = libc::sysconf(libc::consts::os::sysconf::_SC_PAGESIZE);\n-            if psize == -1 {\n-                panic!(\"failed to get page size\");\n-            }\n-\n-            PAGE_SIZE = psize as uint;\n-\n-            let stackaddr = get_stack_start();\n-\n-            // Rellocate the last page of the stack.\n-            // This ensures SIGBUS will be raised on\n-            // stack overflow.\n-            let result = mmap(stackaddr,\n-                              PAGE_SIZE as libc::size_t,\n-                              PROT_NONE,\n-                              MAP_PRIVATE | MAP_ANON | MAP_FIXED,\n-                              -1,\n-                              0);\n-\n-            if result != stackaddr || result == MAP_FAILED {\n-                panic!(\"failed to allocate a guard page\");\n-            }\n-\n-            let offset = if cfg!(target_os = \"linux\") {\n-                2\n-            } else {\n-                1\n-            };\n-\n-            GUARD_PAGE = stackaddr as uint + offset * PAGE_SIZE;\n-        }\n-\n-        pub unsafe fn main() -> uint {\n-            GUARD_PAGE\n-        }\n-\n-        #[cfg(target_os = \"macos\")]\n-        pub unsafe fn current() -> uint {\n-            (pthread_get_stackaddr_np(pthread_self()) as libc::size_t -\n-             pthread_get_stacksize_np(pthread_self())) as uint\n-        }\n-\n-        #[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n-        pub unsafe fn current() -> uint {\n-            let mut attr: libc::pthread_attr_t = mem::zeroed();\n-            if pthread_getattr_np(pthread_self(), &mut attr) != 0 {\n-                panic!(\"failed to get thread attributes\");\n-            }\n-            let mut guardsize = 0;\n-            if pthread_attr_getguardsize(&attr, &mut guardsize) != 0 {\n-                panic!(\"failed to get stack guard page\");\n-            }\n-            if guardsize == 0 {\n-                panic!(\"there is no guard page\");\n-            }\n-            let mut stackaddr = ptr::null_mut();\n-            let mut stacksize = 0;\n-            if pthread_attr_getstack(&attr, &mut stackaddr, &mut stacksize) != 0 {\n-                panic!(\"failed to get stack information\");\n-            }\n-            if pthread_attr_destroy(&mut attr) != 0 {\n-                panic!(\"failed to destroy thread attributes\");\n-            }\n-\n-            stackaddr as uint + guardsize as uint\n-        }\n-    }\n-\n-    pub unsafe fn create(stack: uint, p: Thunk) -> rust_thread {\n-        let mut native: libc::pthread_t = mem::zeroed();\n-        let mut attr: libc::pthread_attr_t = mem::zeroed();\n-        assert_eq!(pthread_attr_init(&mut attr), 0);\n-        assert_eq!(pthread_attr_setdetachstate(&mut attr,\n-                                               PTHREAD_CREATE_JOINABLE), 0);\n-\n-        // Reserve room for the red zone, the runtime's stack of last resort.\n-        let stack_size = cmp::max(stack, RED_ZONE + min_stack_size(&attr) as uint);\n-        match pthread_attr_setstacksize(&mut attr, stack_size as libc::size_t) {\n-            0 => {\n-            },\n-            libc::EINVAL => {\n-                // EINVAL means |stack_size| is either too small or not a\n-                // multiple of the system page size.  Because it's definitely\n-                // >= PTHREAD_STACK_MIN, it must be an alignment issue.\n-                // Round up to the nearest page and try again.\n-                let page_size = libc::sysconf(libc::_SC_PAGESIZE) as uint;\n-                let stack_size = (stack_size + page_size - 1) &\n-                                 (-(page_size as int - 1) as uint - 1);\n-                assert_eq!(pthread_attr_setstacksize(&mut attr, stack_size as libc::size_t), 0);\n-            },\n-            errno => {\n-                // This cannot really happen.\n-                panic!(\"pthread_attr_setstacksize() error: {}\", errno);\n-            },\n-        };\n-\n-        let arg: *mut libc::c_void = mem::transmute(box p); // must box since sizeof(p)=2*uint\n-        let ret = pthread_create(&mut native, &attr, super::thread_start, arg);\n-        assert_eq!(pthread_attr_destroy(&mut attr), 0);\n-\n-        if ret != 0 {\n-            // be sure to not leak the closure\n-            let _p: Box<Box<FnOnce()+Send>> = mem::transmute(arg);\n-            panic!(\"failed to spawn native thread: {}\", ret);\n-        }\n-        native\n-    }\n-\n-    pub unsafe fn join(native: rust_thread) {\n-        assert_eq!(pthread_join(native, ptr::null_mut()), 0);\n-    }\n-\n-    pub unsafe fn detach(native: rust_thread) {\n-        assert_eq!(pthread_detach(native), 0);\n-    }\n-\n-    pub unsafe fn yield_now() { assert_eq!(sched_yield(), 0); }\n-    // glibc >= 2.15 has a __pthread_get_minstack() function that returns\n-    // PTHREAD_STACK_MIN plus however many bytes are needed for thread-local\n-    // storage.  We need that information to avoid blowing up when a small stack\n-    // is created in an application with big thread-local storage requirements.\n-    // See #6233 for rationale and details.\n-    //\n-    // Link weakly to the symbol for compatibility with older versions of glibc.\n-    // Assumes that we've been dynamically linked to libpthread but that is\n-    // currently always the case.  Note that you need to check that the symbol\n-    // is non-null before calling it!\n-    #[cfg(target_os = \"linux\")]\n-    fn min_stack_size(attr: *const libc::pthread_attr_t) -> libc::size_t {\n-        type F = unsafe extern \"C\" fn(*const libc::pthread_attr_t) -> libc::size_t;\n-        extern {\n-            #[linkage = \"extern_weak\"]\n-            static __pthread_get_minstack: *const ();\n-        }\n-        if __pthread_get_minstack.is_null() {\n-            PTHREAD_STACK_MIN\n-        } else {\n-            unsafe { mem::transmute::<*const (), F>(__pthread_get_minstack)(attr) }\n-        }\n-    }\n-\n-    // __pthread_get_minstack() is marked as weak but extern_weak linkage is\n-    // not supported on OS X, hence this kludge...\n-    #[cfg(not(target_os = \"linux\"))]\n-    fn min_stack_size(_: *const libc::pthread_attr_t) -> libc::size_t {\n-        PTHREAD_STACK_MIN\n-    }\n-\n-    #[cfg(any(target_os = \"linux\"))]\n-    extern {\n-        pub fn pthread_self() -> libc::pthread_t;\n-        pub fn pthread_getattr_np(native: libc::pthread_t,\n-                                  attr: *mut libc::pthread_attr_t) -> libc::c_int;\n-        pub fn pthread_attr_getguardsize(attr: *const libc::pthread_attr_t,\n-                                         guardsize: *mut libc::size_t) -> libc::c_int;\n-        pub fn pthread_attr_getstack(attr: *const libc::pthread_attr_t,\n-                                     stackaddr: *mut *mut libc::c_void,\n-                                     stacksize: *mut libc::size_t) -> libc::c_int;\n-    }\n-\n-    #[cfg(target_os = \"macos\")]\n-    extern {\n-        pub fn pthread_self() -> libc::pthread_t;\n-        pub fn pthread_get_stackaddr_np(thread: libc::pthread_t) -> *mut libc::c_void;\n-        pub fn pthread_get_stacksize_np(thread: libc::pthread_t) -> libc::size_t;\n-    }\n-\n-    extern {\n-        fn pthread_create(native: *mut libc::pthread_t,\n-                          attr: *const libc::pthread_attr_t,\n-                          f: super::StartFn,\n-                          value: *mut libc::c_void) -> libc::c_int;\n-        fn pthread_join(native: libc::pthread_t,\n-                        value: *mut *mut libc::c_void) -> libc::c_int;\n-        fn pthread_attr_init(attr: *mut libc::pthread_attr_t) -> libc::c_int;\n-        pub fn pthread_attr_destroy(attr: *mut libc::pthread_attr_t) -> libc::c_int;\n-        fn pthread_attr_setstacksize(attr: *mut libc::pthread_attr_t,\n-                                     stack_size: libc::size_t) -> libc::c_int;\n-        fn pthread_attr_setdetachstate(attr: *mut libc::pthread_attr_t,\n-                                       state: libc::c_int) -> libc::c_int;\n-        fn pthread_detach(thread: libc::pthread_t) -> libc::c_int;\n-        fn sched_yield() -> libc::c_int;\n-    }\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use super::Thread;\n-\n-    #[test]\n-    fn smoke() { Thread::start(move|| {}).join(); }\n-\n-    #[test]\n-    fn data() { assert_eq!(Thread::start(move|| { 1i }).join(), 1); }\n-\n-    #[test]\n-    fn detached() { Thread::spawn(move|| {}) }\n-\n-    #[test]\n-    fn small_stacks() {\n-        assert_eq!(42i, Thread::start_stack(0, move|| 42i).join());\n-        assert_eq!(42i, Thread::start_stack(1, move|| 42i).join());\n-    }\n-}"}, {"sha": "8fe3642e702d44ce6d3f1a9e1cd9ea2db9d69f9b", "filename": "src/libstd/c_str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a27fbac86849e07a0a6c746869d8f78319bd3a16/src%2Flibstd%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a27fbac86849e07a0a6c746869d8f78319bd3a16/src%2Flibstd%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fc_str.rs?ref=a27fbac86849e07a0a6c746869d8f78319bd3a16", "patch": "@@ -637,7 +637,7 @@ mod tests {\n \n     #[test]\n     fn test_to_c_str_fail() {\n-        assert!(Thread::with_join(move|| { \"he\\x00llo\".to_c_str() }).join().is_err());\n+        assert!(Thread::spawn(move|| { \"he\\x00llo\".to_c_str() }).join().is_err());\n     }\n \n     #[test]"}, {"sha": "c477acd70aa8d7260ce6e1bfe5666adbe69da35d", "filename": "src/libstd/comm/blocking.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a27fbac86849e07a0a6c746869d8f78319bd3a16/src%2Flibstd%2Fcomm%2Fblocking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a27fbac86849e07a0a6c746869d8f78319bd3a16/src%2Flibstd%2Fcomm%2Fblocking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm%2Fblocking.rs?ref=a27fbac86849e07a0a6c746869d8f78319bd3a16", "patch": "@@ -13,7 +13,7 @@\n use thread::Thread;\n use sync::atomic::{AtomicBool, INIT_ATOMIC_BOOL, Ordering};\n use sync::Arc;\n-use kinds::marker::NoSend;\n+use kinds::marker::{NoSend, NoSync};\n use mem;\n use clone::Clone;\n \n@@ -30,6 +30,7 @@ pub struct SignalToken {\n pub struct WaitToken {\n     inner: Arc<Inner>,\n     no_send: NoSend,\n+    no_sync: NoSync,\n }\n \n pub fn tokens() -> (WaitToken, SignalToken) {\n@@ -40,6 +41,7 @@ pub fn tokens() -> (WaitToken, SignalToken) {\n     let wait_token = WaitToken {\n         inner: inner.clone(),\n         no_send: NoSend,\n+        no_sync: NoSync,\n     };\n     let signal_token = SignalToken {\n         inner: inner"}, {"sha": "4977f966eba292d53a35ece9df8f72e24233e696", "filename": "src/libstd/comm/mod.rs", "status": "modified", "additions": 31, "deletions": 21, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/a27fbac86849e07a0a6c746869d8f78319bd3a16/src%2Flibstd%2Fcomm%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a27fbac86849e07a0a6c746869d8f78319bd3a16/src%2Flibstd%2Fcomm%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm%2Fmod.rs?ref=a27fbac86849e07a0a6c746869d8f78319bd3a16", "patch": "@@ -59,26 +59,30 @@\n //! Simple usage:\n //!\n //! ```\n+//! use std::thread::Thread;\n+//!\n //! // Create a simple streaming channel\n //! let (tx, rx) = channel();\n-//! spawn(move|| {\n+//! Thread::spawn(move|| {\n //!     tx.send(10i);\n-//! });\n+//! }).detach();\n //! assert_eq!(rx.recv(), 10i);\n //! ```\n //!\n //! Shared usage:\n //!\n //! ```\n-//! // Create a shared channel that can be sent along from many tasks\n+//! use std::thread::Thread;\n+//!\n+//! // Create a shared channel that can be sent along from many threads\n //! // where tx is the sending half (tx for transmission), and rx is the receiving\n //! // half (rx for receiving).\n //! let (tx, rx) = channel();\n //! for i in range(0i, 10i) {\n //!     let tx = tx.clone();\n-//!     spawn(move|| {\n+//!     Thread::spawn(move|| {\n //!         tx.send(i);\n-//!     })\n+//!     }).detach()\n //! }\n //!\n //! for _ in range(0i, 10i) {\n@@ -100,11 +104,13 @@\n //! Synchronous channels:\n //!\n //! ```\n+//! use std::thread::Thread;\n+//!\n //! let (tx, rx) = sync_channel::<int>(0);\n-//! spawn(move|| {\n+//! Thread::spawn(move|| {\n //!     // This will wait for the parent task to start receiving\n //!     tx.send(53);\n-//! });\n+//! }).detach();\n //! rx.recv();\n //! ```\n //!\n@@ -451,15 +457,17 @@ impl<T> UnsafeFlavor<T> for Receiver<T> {\n /// # Example\n ///\n /// ```\n+/// use std::thread::Thread;\n+///\n /// // tx is is the sending half (tx for transmission), and rx is the receiving\n /// // half (rx for receiving).\n /// let (tx, rx) = channel();\n ///\n /// // Spawn off an expensive computation\n-/// spawn(move|| {\n+/// Thread::spawn(move|| {\n /// #   fn expensive_computation() {}\n ///     tx.send(expensive_computation());\n-/// });\n+/// }).detach();\n ///\n /// // Do some useful work for awhile\n ///\n@@ -490,15 +498,17 @@ pub fn channel<T: Send>() -> (Sender<T>, Receiver<T>) {\n /// # Example\n ///\n /// ```\n+/// use std::thread::Thread;\n+///\n /// let (tx, rx) = sync_channel(1);\n ///\n /// // this returns immediately\n /// tx.send(1i);\n ///\n-/// spawn(move|| {\n+/// Thread::spawn(move|| {\n ///     // this will block until the previous message has been received\n ///     tx.send(2i);\n-/// });\n+/// }).detach();\n ///\n /// assert_eq!(rx.recv(), 1i);\n /// assert_eq!(rx.recv(), 2i);\n@@ -1242,7 +1252,7 @@ mod test {\n \n     test! { fn oneshot_single_thread_recv_chan_close() {\n         // Receiving on a closed chan will panic\n-        let res = Thread::with_join(move|| {\n+        let res = Thread::spawn(move|| {\n             let (tx, rx) = channel::<int>();\n             drop(tx);\n             rx.recv();\n@@ -1314,7 +1324,7 @@ mod test {\n         spawn(move|| {\n             drop(tx);\n         });\n-        let res = Thread::with_join(move|| {\n+        let res = Thread::spawn(move|| {\n             assert!(rx.recv() == box 10);\n         }).join();\n         assert!(res.is_err());\n@@ -1336,7 +1346,7 @@ mod test {\n             spawn(move|| {\n                 drop(rx);\n             });\n-            let _ = Thread::with_join(move|| {\n+            let _ = Thread::spawn(move|| {\n                 tx.send(1);\n             }).join();\n         }\n@@ -1345,8 +1355,8 @@ mod test {\n     test! { fn oneshot_multi_thread_recv_close_stress() {\n         for _ in range(0, stress_factor()) {\n             let (tx, rx) = channel::<int>();\n-            spawn(proc() {\n-                let res = Thread::with_join(move|| {\n+            spawn(move|| {\n+                let res = Thread::spawn(move|| {\n                     rx.recv();\n                 }).join();\n                 assert!(res.is_err());\n@@ -1664,7 +1674,7 @@ mod sync_tests {\n \n     test! { fn oneshot_single_thread_recv_chan_close() {\n         // Receiving on a closed chan will panic\n-        let res = Thread::with_join(move|| {\n+        let res = Thread::spawn(move|| {\n             let (tx, rx) = sync_channel::<int>(0);\n             drop(tx);\n             rx.recv();\n@@ -1741,7 +1751,7 @@ mod sync_tests {\n         spawn(move|| {\n             drop(tx);\n         });\n-        let res = Thread::with_join(move|| {\n+        let res = Thread::spawn(move|| {\n             assert!(rx.recv() == box 10);\n         }).join();\n         assert!(res.is_err());\n@@ -1763,7 +1773,7 @@ mod sync_tests {\n             spawn(move|| {\n                 drop(rx);\n             });\n-            let _ = Thread::with_join(move || {\n+            let _ = Thread::spawn(move || {\n                 tx.send(1);\n             }).join();\n         }\n@@ -1772,8 +1782,8 @@ mod sync_tests {\n     test! { fn oneshot_multi_thread_recv_close_stress() {\n         for _ in range(0, stress_factor()) {\n             let (tx, rx) = sync_channel::<int>(0);\n-            spawn(proc() {\n-                let res = Thread::with_join(move|| {\n+            spawn(move|| {\n+                let res = Thread::spawn(move|| {\n                     rx.recv();\n                 }).join();\n                 assert!(res.is_err());"}, {"sha": "f75186e70e3d4a6a4f89e33fb0a799fac3fda994", "filename": "src/libstd/comm/sync.rs", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/a27fbac86849e07a0a6c746869d8f78319bd3a16/src%2Flibstd%2Fcomm%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a27fbac86849e07a0a6c746869d8f78319bd3a16/src%2Flibstd%2Fcomm%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm%2Fsync.rs?ref=a27fbac86849e07a0a6c746869d8f78319bd3a16", "patch": "@@ -108,20 +108,18 @@ fn wait<'a, 'b, T: Send>(lock: &'a Mutex<State<T>>,\n                          f: fn(SignalToken) -> Blocker)\n                          -> MutexGuard<'a, State<T>>\n {\n-    let me: Box<Task> = Local::take();\n-    me.deschedule(1, |task| {\n-        match mem::replace(&mut guard.blocker, f(task)) {\n-            NoneBlocked => {}\n-            _ => unreachable!(),\n-        }\n-        mem::drop(guard);\n-        Ok(())\n-    });\n-    lock.lock()\n+    let (wait_token, signal_token) = blocking::tokens();\n+    match mem::replace(&mut guard.blocker, f(signal_token)) {\n+        NoneBlocked => {}\n+        _ => unreachable!(),\n+    }\n+    drop(guard);        // unlock\n+    wait_token.wait();  // block\n+    lock.lock()         // relock\n }\n \n-/// Wakes up a task, dropping the lock at the correct time\n-fn wakeup<T>(task: BlockedTask, guard: MutexGuard<State<T>>) {\n+/// Wakes up a thread, dropping the lock at the correct time\n+fn wakeup<T>(token: SignalToken, guard: MutexGuard<State<T>>) {\n     // We need to be careful to wake up the waiting task *outside* of the mutex\n     // in case it incurs a context switch.\n     drop(guard);"}, {"sha": "e865bf42bd01d5239c6d912a05a6bba572d9526a", "filename": "src/libstd/io/comm_adapters.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a27fbac86849e07a0a6c746869d8f78319bd3a16/src%2Flibstd%2Fio%2Fcomm_adapters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a27fbac86849e07a0a6c746869d8f78319bd3a16/src%2Flibstd%2Fio%2Fcomm_adapters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fcomm_adapters.rs?ref=a27fbac86849e07a0a6c746869d8f78319bd3a16", "patch": "@@ -167,7 +167,7 @@ mod test {\n           tx.send(vec![3u8, 4u8]);\n           tx.send(vec![5u8, 6u8]);\n           tx.send(vec![7u8, 8u8]);\n-        });\n+        }).detach();\n \n         let mut reader = ChanReader::new(rx);\n         let mut buf = [0u8, ..3];\n@@ -210,7 +210,7 @@ mod test {\n           tx.send(b\"rld\\nhow \".to_vec());\n           tx.send(b\"are you?\".to_vec());\n           tx.send(b\"\".to_vec());\n-        });\n+        }).detach();\n \n         let mut reader = ChanReader::new(rx);\n \n@@ -229,11 +229,7 @@ mod test {\n         writer.write_be_u32(42).unwrap();\n \n         let wanted = vec![0u8, 0u8, 0u8, 42u8];\n-<<<<<<< HEAD\n-        let got = match task::try(move|| { rx.recv() }) {\n-=======\n-        let got = match Thread::with_join(proc() { rx.recv() }).join() {\n->>>>>>> Fallout from new thread API\n+        let got = match Thread::spawn(move|| { rx.recv() }).join() {\n             Ok(got) => got,\n             Err(_) => panic!(),\n         };"}, {"sha": "5807a3bc4662e436d1f7c70e5fb7fa383ddc9c2b", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a27fbac86849e07a0a6c746869d8f78319bd3a16/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a27fbac86849e07a0a6c746869d8f78319bd3a16/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=a27fbac86849e07a0a6c746869d8f78319bd3a16", "patch": "@@ -105,6 +105,7 @@\n //!     # #![allow(dead_code)]\n //!     use std::io::{TcpListener, TcpStream};\n //!     use std::io::{Acceptor, Listener};\n+//!     use std::thread::Thread;\n //!\n //!     let listener = TcpListener::bind(\"127.0.0.1:80\");\n //!\n@@ -119,10 +120,10 @@\n //!     for stream in acceptor.incoming() {\n //!         match stream {\n //!             Err(e) => { /* connection failed */ }\n-//!             Ok(stream) => spawn(move|| {\n+//!             Ok(stream) => Thread::spawn(move|| {\n //!                 // connection succeeded\n //!                 handle_client(stream)\n-//!             })\n+//!             }).detach()\n //!         }\n //!     }\n //!"}, {"sha": "6bc952f30af6c912f71a657bf7851cfabd87f01b", "filename": "src/libstd/io/net/tcp.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a27fbac86849e07a0a6c746869d8f78319bd3a16/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a27fbac86849e07a0a6c746869d8f78319bd3a16/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs?ref=a27fbac86849e07a0a6c746869d8f78319bd3a16", "patch": "@@ -136,16 +136,17 @@ impl TcpStream {\n     /// use std::io::timer;\n     /// use std::io::TcpStream;\n     /// use std::time::Duration;\n+    /// use std::thread::Thread;\n     ///\n     /// let mut stream = TcpStream::connect(\"127.0.0.1:34254\").unwrap();\n     /// let stream2 = stream.clone();\n     ///\n-    /// spawn(move|| {\n+    /// Thread::spawn(move|| {\n     ///     // close this stream after one second\n     ///     timer::sleep(Duration::seconds(1));\n     ///     let mut stream = stream2;\n     ///     stream.close_read();\n-    /// });\n+    /// }).detach();\n     ///\n     /// // wait for some data, will get canceled after one second\n     /// let mut buf = [0];\n@@ -279,6 +280,7 @@ impl sys_common::AsInner<TcpStreamImp> for TcpStream {\n /// # #![allow(dead_code)]\n /// use std::io::{TcpListener, TcpStream};\n /// use std::io::{Acceptor, Listener};\n+/// use std::thread::Thread;\n ///\n /// let listener = TcpListener::bind(\"127.0.0.1:80\");\n ///\n@@ -293,10 +295,10 @@ impl sys_common::AsInner<TcpStreamImp> for TcpStream {\n /// for stream in acceptor.incoming() {\n ///     match stream {\n ///         Err(e) => { /* connection failed */ }\n-///         Ok(stream) => spawn(move|| {\n+///         Ok(stream) => Thread::spawn(move|| {\n ///             // connection succeeded\n ///             handle_client(stream)\n-///         })\n+///         }).detach()\n ///     }\n /// }\n ///\n@@ -416,11 +418,12 @@ impl TcpAcceptor {\n     /// ```\n     /// # #![allow(experimental)]\n     /// use std::io::{TcpListener, Listener, Acceptor, EndOfFile};\n+    /// use std::thread::Thread;\n     ///\n     /// let mut a = TcpListener::bind(\"127.0.0.1:8482\").listen().unwrap();\n     /// let a2 = a.clone();\n     ///\n-    /// spawn(move|| {\n+    /// Thread::spawn(move|| {\n     ///     let mut a2 = a2;\n     ///     for socket in a2.incoming() {\n     ///         match socket {\n@@ -429,7 +432,7 @@ impl TcpAcceptor {\n     ///             Err(e) => panic!(\"unexpected error: {}\", e),\n     ///         }\n     ///     }\n-    /// });\n+    /// }).detach();\n     ///\n     /// # fn wait_for_sigint() {}\n     /// // Now that our accept loop is running, wait for the program to be"}, {"sha": "60360a2bc6445cf29d6c5618632a2f782f3a9944", "filename": "src/libstd/io/process.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a27fbac86849e07a0a6c746869d8f78319bd3a16/src%2Flibstd%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a27fbac86849e07a0a6c746869d8f78319bd3a16/src%2Flibstd%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fprocess.rs?ref=a27fbac86849e07a0a6c746869d8f78319bd3a16", "patch": "@@ -698,7 +698,7 @@ impl Process {\n                     Thread::spawn(move |:| {\n                         let mut stream = stream;\n                         tx.send(stream.read_to_end())\n-                    });\n+                    }).detach();\n                 }\n                 None => tx.send(Ok(Vec::new()))\n             }"}, {"sha": "78c194745a88838c9c3bc3a082b6146e34164ab1", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a27fbac86849e07a0a6c746869d8f78319bd3a16/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a27fbac86849e07a0a6c746869d8f78319bd3a16/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=a27fbac86849e07a0a6c746869d8f78319bd3a16", "patch": "@@ -230,7 +230,6 @@ pub mod hash;\n /* Threads and communication */\n \n pub mod task;\n-#[allow(missing_docs)]\n pub mod thread;\n pub mod sync;\n pub mod comm;"}, {"sha": "3d03b5324b9c109b91b15cf6f10881d786da281f", "filename": "src/libstd/macros.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a27fbac86849e07a0a6c746869d8f78319bd3a16/src%2Flibstd%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a27fbac86849e07a0a6c746869d8f78319bd3a16/src%2Flibstd%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmacros.rs?ref=a27fbac86849e07a0a6c746869d8f78319bd3a16", "patch": "@@ -353,13 +353,15 @@ macro_rules! vec {\n /// # Example\n ///\n /// ```\n+/// use std::thread::Thread;\n+///\n /// let (tx1, rx1) = channel();\n /// let (tx2, rx2) = channel();\n /// # fn long_running_task() {}\n /// # fn calculate_the_answer() -> int { 42i }\n ///\n-/// spawn(move|| { long_running_task(); tx1.send(()) });\n-/// spawn(move|| { tx2.send(calculate_the_answer()) });\n+/// Thread::spawn(move|| { long_running_task(); tx1.send(()) }).detach();\n+/// Thread::spawn(move|| { tx2.send(calculate_the_answer()) }).detach();\n ///\n /// select! (\n ///     () = rx1.recv() => println!(\"the long running task finished first\"),"}, {"sha": "a049ea01b6d49c7e3a67cea0eaee9e50f0de08f0", "filename": "src/libstd/os.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a27fbac86849e07a0a6c746869d8f78319bd3a16/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a27fbac86849e07a0a6c746869d8f78319bd3a16/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=a27fbac86849e07a0a6c746869d8f78319bd3a16", "patch": "@@ -26,6 +26,7 @@\n \n #![allow(missing_docs)]\n #![allow(non_snake_case)]\n+#![allow(unused_imports)]\n \n pub use self::MemoryMapKind::*;\n pub use self::MapOption::*;\n@@ -37,7 +38,7 @@ use fmt;\n use io::{IoResult, IoError};\n use iter::{Iterator, IteratorExt};\n use kinds::Copy;\n-use libc::{c_void, c_int};\n+use libc::{c_void, c_int, c_char};\n use libc;\n use boxed::Box;\n use ops::{Drop, FnOnce};"}, {"sha": "62f64159c047a0865b9e031abe2c3490044ba9b9", "filename": "src/libstd/path/posix.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a27fbac86849e07a0a6c746869d8f78319bd3a16/src%2Flibstd%2Fpath%2Fposix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a27fbac86849e07a0a6c746869d8f78319bd3a16/src%2Flibstd%2Fpath%2Fposix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fposix.rs?ref=a27fbac86849e07a0a6c746869d8f78319bd3a16", "patch": "@@ -515,17 +515,17 @@ mod tests {\n     #[test]\n     fn test_null_byte() {\n         use thread::Thread;\n-        let result = Thread::with_join(move|| {\n+        let result = Thread::spawn(move|| {\n             Path::new(b\"foo/bar\\0\")\n         }).join();\n         assert!(result.is_err());\n \n-        let result = Thread::with_join(move|| {\n+        let result = Thread::spawn(move|| {\n             Path::new(\"test\").set_filename(b\"f\\0o\")\n         }).join();\n         assert!(result.is_err());\n \n-        let result = Thread::with_join(move|| {\n+        let result = Thread::spawn(move|| {\n             Path::new(\"test\").push(b\"f\\0o\");\n         }).join();\n         assert!(result.is_err());"}, {"sha": "5cbefb0d3d8e0016a887fc964686685ce85d6ece", "filename": "src/libstd/path/windows.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a27fbac86849e07a0a6c746869d8f78319bd3a16/src%2Flibstd%2Fpath%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a27fbac86849e07a0a6c746869d8f78319bd3a16/src%2Flibstd%2Fpath%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fwindows.rs?ref=a27fbac86849e07a0a6c746869d8f78319bd3a16", "patch": "@@ -1299,17 +1299,17 @@ mod tests {\n     #[test]\n     fn test_null_byte() {\n         use thread::Thread;\n-        let result = Thread::with_join(move|| {\n+        let result = Thread::spawn(move|| {\n             Path::new(b\"foo/bar\\0\")\n         }).join();\n         assert!(result.is_err());\n \n-        let result = Thread::with_join(move|| {\n+        let result = Thread::spawn(move|| {\n             Path::new(\"test\").set_filename(b\"f\\0o\")\n         }).join();\n         assert!(result.is_err());\n \n-        let result = Thread::with_join(move|| {\n+        let result = Thread::spawn(move || {\n             Path::new(\"test\").push(b\"f\\0o\");\n         }).join();\n         assert!(result.is_err());"}, {"sha": "dbe5f9193298a7de0c4d3ad88c27bd7a1df492d0", "filename": "src/libstd/rand/os.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a27fbac86849e07a0a6c746869d8f78319bd3a16/src%2Flibstd%2Frand%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a27fbac86849e07a0a6c746869d8f78319bd3a16/src%2Flibstd%2Frand%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fos.rs?ref=a27fbac86849e07a0a6c746869d8f78319bd3a16", "patch": "@@ -379,7 +379,7 @@ mod test {\n                     r.fill_bytes(&mut v);\n                     Thread::yield_now();\n                 }\n-            });\n+            }).detach();\n         }\n \n         // start all the tasks"}, {"sha": "b63b4ced00545a48baf23f95460d024dc84b47d8", "filename": "src/libstd/rt/at_exit_imp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a27fbac86849e07a0a6c746869d8f78319bd3a16/src%2Flibstd%2Frt%2Fat_exit_imp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a27fbac86849e07a0a6c746869d8f78319bd3a16/src%2Flibstd%2Frt%2Fat_exit_imp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fat_exit_imp.rs?ref=a27fbac86849e07a0a6c746869d8f78319bd3a16", "patch": "@@ -45,7 +45,7 @@ pub fn cleanup() {\n             let queue: Box<Queue> = mem::transmute(queue);\n             let v = mem::replace(&mut *queue.lock(), Vec::new());\n             for to_run in v.into_iter() {\n-                to_run.invoke();\n+                to_run.invoke(());\n             }\n         }\n     }"}, {"sha": "089960a6bc80b8b9a3221c229384e63b0d1f8b30", "filename": "src/libstd/rt/local.rs", "status": "removed", "additions": 0, "deletions": 131, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/13f302d0c5dd3a88426da53ba07cdbe16459635b/src%2Flibstd%2Frt%2Flocal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13f302d0c5dd3a88426da53ba07cdbe16459635b/src%2Flibstd%2Frt%2Flocal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Flocal.rs?ref=13f302d0c5dd3a88426da53ba07cdbe16459635b", "patch": "@@ -1,131 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use core::prelude::*;\n-\n-use boxed::Box;\n-use rt::local_ptr;\n-use rt::task::Task;\n-\n-/// Encapsulates some task-local data.\n-pub trait Local<Borrowed> {\n-    fn put(value: Box<Self>);\n-    fn take() -> Box<Self>;\n-    fn try_take() -> Option<Box<Self>>;\n-    fn exists(unused_value: Option<Self>) -> bool;\n-    fn borrow(unused_value: Option<Self>) -> Borrowed;\n-    unsafe fn unsafe_take() -> Box<Self>;\n-    unsafe fn unsafe_borrow() -> *mut Self;\n-    unsafe fn try_unsafe_borrow() -> Option<*mut Self>;\n-}\n-\n-impl Local<local_ptr::Borrowed<Task>> for Task {\n-    #[inline]\n-    fn put(value: Box<Task>) { unsafe { local_ptr::put(value) } }\n-    #[inline]\n-    fn take() -> Box<Task> { unsafe { local_ptr::take() } }\n-    #[inline]\n-    fn try_take() -> Option<Box<Task>> { unsafe { local_ptr::try_take() } }\n-    fn exists(_: Option<Task>) -> bool { local_ptr::exists() }\n-    #[inline]\n-    fn borrow(_: Option<Task>) -> local_ptr::Borrowed<Task> {\n-        unsafe {\n-            local_ptr::borrow::<Task>()\n-        }\n-    }\n-    #[inline]\n-    unsafe fn unsafe_take() -> Box<Task> { local_ptr::unsafe_take() }\n-    #[inline]\n-    unsafe fn unsafe_borrow() -> *mut Task { local_ptr::unsafe_borrow() }\n-    #[inline]\n-    unsafe fn try_unsafe_borrow() -> Option<*mut Task> {\n-        local_ptr::try_unsafe_borrow()\n-    }\n-}\n-\n-#[cfg(test)]\n-mod test {\n-    use prelude::*;\n-    use super::*;\n-    use super::super::thread::Thread;\n-    use super::super::task::Task;\n-\n-    #[test]\n-    fn thread_local_task_smoke_test() {\n-        Thread::start(move|| {\n-            let task = box Task::new(None, None);\n-            Local::put(task);\n-            let task: Box<Task> = Local::take();\n-            cleanup_task(task);\n-        }).join();\n-    }\n-\n-    #[test]\n-    fn thread_local_task_two_instances() {\n-        Thread::start(move|| {\n-            let task = box Task::new(None, None);\n-            Local::put(task);\n-            let task: Box<Task> = Local::take();\n-            cleanup_task(task);\n-            let task = box Task::new(None, None);\n-            Local::put(task);\n-            let task: Box<Task> = Local::take();\n-            cleanup_task(task);\n-        }).join();\n-    }\n-\n-    #[test]\n-    fn borrow_smoke_test() {\n-        Thread::start(move|| {\n-            let task = box Task::new(None, None);\n-            Local::put(task);\n-\n-            unsafe {\n-                let _task: *mut Task = Local::unsafe_borrow();\n-            }\n-            let task: Box<Task> = Local::take();\n-            cleanup_task(task);\n-        }).join();\n-    }\n-\n-    #[test]\n-    fn borrow_with_return() {\n-        Thread::start(move|| {\n-            let task = box Task::new(None, None);\n-            Local::put(task);\n-\n-            {\n-                let _ = Local::borrow(None::<Task>);\n-            }\n-\n-            let task: Box<Task> = Local::take();\n-            cleanup_task(task);\n-        }).join();\n-    }\n-\n-    #[test]\n-    fn try_take() {\n-        Thread::start(move|| {\n-            let task = box Task::new(None, None);\n-            Local::put(task);\n-\n-            let t: Box<Task> = Local::try_take().unwrap();\n-            let u: Option<Box<Task>> = Local::try_take();\n-            assert!(u.is_none());\n-\n-            cleanup_task(t);\n-        }).join();\n-    }\n-\n-    fn cleanup_task(t: Box<Task>) {\n-        t.drop();\n-    }\n-\n-}"}, {"sha": "fd50d845716b98be5617803e640ad045dfbb3fdc", "filename": "src/libstd/rt/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a27fbac86849e07a0a6c746869d8f78319bd3a16/src%2Flibstd%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a27fbac86849e07a0a6c746869d8f78319bd3a16/src%2Flibstd%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmod.rs?ref=a27fbac86849e07a0a6c746869d8f78319bd3a16", "patch": "@@ -27,6 +27,7 @@ use os;\n use thunk::Thunk;\n use kinds::Send;\n use thread::Thread;\n+use ops::FnOnce;\n use sys;\n use sys_common;\n use sys_common::thread_info::{mod, NewThread};\n@@ -145,8 +146,8 @@ fn lang_start(main: *const u8, argc: int, argv: *const *const u8) -> int {\n ///\n /// It is forbidden for procedures to register more `at_exit` handlers when they\n /// are running, and doing so will lead to a process abort.\n-pub fn at_exit(f: proc():Send) {\n-    at_exit_imp::push(f);\n+pub fn at_exit<F:FnOnce()+Send>(f: F) {\n+    at_exit_imp::push(Thunk::new(f));\n }\n \n /// One-time runtime cleanup."}, {"sha": "381f14570dfbca86316d3ec7bcb5e8f1701f74e3", "filename": "src/libstd/rt/mutex.rs", "status": "removed", "additions": 0, "deletions": 406, "changes": 406, "blob_url": "https://github.com/rust-lang/rust/blob/13f302d0c5dd3a88426da53ba07cdbe16459635b/src%2Flibstd%2Frt%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13f302d0c5dd3a88426da53ba07cdbe16459635b/src%2Flibstd%2Frt%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmutex.rs?ref=13f302d0c5dd3a88426da53ba07cdbe16459635b", "patch": "@@ -1,406 +0,0 @@\n-// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! A native mutex and condition variable type.\n-//!\n-//! This module contains bindings to the platform's native mutex/condition\n-//! variable primitives. It provides two types: `StaticNativeMutex`, which can\n-//! be statically initialized via the `NATIVE_MUTEX_INIT` value, and a simple\n-//! wrapper `NativeMutex` that has a destructor to clean up after itself. These\n-//! objects serve as both mutexes and condition variables simultaneously.\n-//!\n-//! The static lock is lazily initialized, but it can only be unsafely\n-//! destroyed. A statically initialized lock doesn't necessarily have a time at\n-//! which it can get deallocated. For this reason, there is no `Drop`\n-//! implementation of the static mutex, but rather the `destroy()` method must\n-//! be invoked manually if destruction of the mutex is desired.\n-//!\n-//! The non-static `NativeMutex` type does have a destructor, but cannot be\n-//! statically initialized.\n-//!\n-//! It is not recommended to use this type for idiomatic rust use. These types\n-//! are appropriate where no other options are available, but other rust\n-//! concurrency primitives should be used before them: the `sync` crate defines\n-//! `StaticMutex` and `Mutex` types.\n-//!\n-//! # Example\n-//!\n-//! ```rust\n-//! use rt::mutex::{NativeMutex, StaticNativeMutex, NATIVE_MUTEX_INIT};\n-//!\n-//! // Use a statically initialized mutex\n-//! static LOCK: StaticNativeMutex = NATIVE_MUTEX_INIT;\n-//!\n-//! unsafe {\n-//!     let _guard = LOCK.lock();\n-//! } // automatically unlocked here\n-//!\n-//! // Use a normally initialized mutex\n-//! unsafe {\n-//!     let mut lock = NativeMutex::new();\n-//!\n-//!     {\n-//!         let _guard = lock.lock();\n-//!     } // unlocked here\n-//!\n-//!     // sometimes the RAII guard isn't appropriate\n-//!     lock.lock_noguard();\n-//!     lock.unlock_noguard();\n-//! } // `lock` is deallocated here\n-//! ```\n-\n-#![allow(non_camel_case_types)]\n-\n-use core::prelude::*;\n-\n-use sys::mutex as imp;\n-\n-/// A native mutex suitable for storing in statics (that is, it has\n-/// the `destroy` method rather than a destructor).\n-///\n-/// Prefer the `NativeMutex` type where possible, since that does not\n-/// require manual deallocation.\n-pub struct StaticNativeMutex {\n-    inner: imp::Mutex,\n-}\n-\n-/// A native mutex with a destructor for clean-up.\n-///\n-/// See `StaticNativeMutex` for a version that is suitable for storing in\n-/// statics.\n-pub struct NativeMutex {\n-    inner: StaticNativeMutex\n-}\n-\n-/// Automatically unlocks the mutex that it was created from on\n-/// destruction.\n-///\n-/// Using this makes lock-based code resilient to unwinding/task\n-/// panic, because the lock will be automatically unlocked even\n-/// then.\n-#[must_use]\n-pub struct LockGuard<'a> {\n-    lock: &'a StaticNativeMutex\n-}\n-\n-pub const NATIVE_MUTEX_INIT: StaticNativeMutex = StaticNativeMutex {\n-    inner: imp::MUTEX_INIT,\n-};\n-\n-impl StaticNativeMutex {\n-    /// Creates a new mutex.\n-    ///\n-    /// Note that a mutex created in this way needs to be explicit\n-    /// freed with a call to `destroy` or it will leak.\n-    /// Also it is important to avoid locking until mutex has stopped moving\n-    pub unsafe fn new() -> StaticNativeMutex {\n-        StaticNativeMutex { inner: imp::Mutex::new() }\n-    }\n-\n-    /// Acquires this lock. This assumes that the current thread does not\n-    /// already hold the lock.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// use rt::mutex::{StaticNativeMutex, NATIVE_MUTEX_INIT};\n-    /// static LOCK: StaticNativeMutex = NATIVE_MUTEX_INIT;\n-    /// unsafe {\n-    ///     let _guard = LOCK.lock();\n-    ///     // critical section...\n-    /// } // automatically unlocked in `_guard`'s destructor\n-    /// ```\n-    ///\n-    /// # Unsafety\n-    ///\n-    /// This method is unsafe because it will not function correctly if this\n-    /// mutex has been *moved* since it was last used. The mutex can move an\n-    /// arbitrary number of times before its first usage, but once a mutex has\n-    /// been used once it is no longer allowed to move (or otherwise it invokes\n-    /// undefined behavior).\n-    ///\n-    /// Additionally, this type does not take into account any form of\n-    /// scheduling model. This will unconditionally block the *os thread* which\n-    /// is not always desired.\n-    pub unsafe fn lock<'a>(&'a self) -> LockGuard<'a> {\n-        self.inner.lock();\n-\n-        LockGuard { lock: self }\n-    }\n-\n-    /// Attempts to acquire the lock. The value returned is `Some` if\n-    /// the attempt succeeded.\n-    ///\n-    /// # Unsafety\n-    ///\n-    /// This method is unsafe for the same reasons as `lock`.\n-    pub unsafe fn trylock<'a>(&'a self) -> Option<LockGuard<'a>> {\n-        if self.inner.trylock() {\n-            Some(LockGuard { lock: self })\n-        } else {\n-            None\n-        }\n-    }\n-\n-    /// Acquire the lock without creating a `LockGuard`.\n-    ///\n-    /// These needs to be paired with a call to `.unlock_noguard`. Prefer using\n-    /// `.lock`.\n-    ///\n-    /// # Unsafety\n-    ///\n-    /// This method is unsafe for the same reasons as `lock`. Additionally, this\n-    /// does not guarantee that the mutex will ever be unlocked, and it is\n-    /// undefined to drop an already-locked mutex.\n-    pub unsafe fn lock_noguard(&self) { self.inner.lock() }\n-\n-    /// Attempts to acquire the lock without creating a\n-    /// `LockGuard`. The value returned is whether the lock was\n-    /// acquired or not.\n-    ///\n-    /// If `true` is returned, this needs to be paired with a call to\n-    /// `.unlock_noguard`. Prefer using `.trylock`.\n-    ///\n-    /// # Unsafety\n-    ///\n-    /// This method is unsafe for the same reasons as `lock_noguard`.\n-    pub unsafe fn trylock_noguard(&self) -> bool {\n-        self.inner.trylock()\n-    }\n-\n-    /// Unlocks the lock. This assumes that the current thread already holds the\n-    /// lock.\n-    ///\n-    /// # Unsafety\n-    ///\n-    /// This method is unsafe for the same reasons as `lock`. Additionally, it\n-    /// is not guaranteed that this is unlocking a previously locked mutex. It\n-    /// is undefined to unlock an unlocked mutex.\n-    pub unsafe fn unlock_noguard(&self) { self.inner.unlock() }\n-\n-    /// Block on the internal condition variable.\n-    ///\n-    /// This function assumes that the lock is already held. Prefer\n-    /// using `LockGuard.wait` since that guarantees that the lock is\n-    /// held.\n-    ///\n-    /// # Unsafety\n-    ///\n-    /// This method is unsafe for the same reasons as `lock`. Additionally, this\n-    /// is unsafe because the mutex may not be currently locked.\n-    pub unsafe fn wait_noguard(&self) { self.inner.wait() }\n-\n-    /// Signals a thread in `wait` to wake up\n-    ///\n-    /// # Unsafety\n-    ///\n-    /// This method is unsafe for the same reasons as `lock`. Additionally, this\n-    /// is unsafe because the mutex may not be currently locked.\n-    pub unsafe fn signal_noguard(&self) { self.inner.signal() }\n-\n-    /// This function is especially unsafe because there are no guarantees made\n-    /// that no other thread is currently holding the lock or waiting on the\n-    /// condition variable contained inside.\n-    pub unsafe fn destroy(&self) { self.inner.destroy() }\n-}\n-\n-impl NativeMutex {\n-    /// Creates a new mutex.\n-    ///\n-    /// The user must be careful to ensure the mutex is not locked when its is\n-    /// being destroyed.\n-    /// Also it is important to avoid locking until mutex has stopped moving\n-    pub unsafe fn new() -> NativeMutex {\n-        NativeMutex { inner: StaticNativeMutex::new() }\n-    }\n-\n-    /// Acquires this lock. This assumes that the current thread does not\n-    /// already hold the lock.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// use rt::mutex::NativeMutex;\n-    /// unsafe {\n-    ///     let mut lock = NativeMutex::new();\n-    ///\n-    ///     {\n-    ///         let _guard = lock.lock();\n-    ///         // critical section...\n-    ///     } // automatically unlocked in `_guard`'s destructor\n-    /// }\n-    /// ```\n-    ///\n-    /// # Unsafety\n-    ///\n-    /// This method is unsafe due to the same reasons as\n-    /// `StaticNativeMutex::lock`.\n-    pub unsafe fn lock<'a>(&'a self) -> LockGuard<'a> {\n-        self.inner.lock()\n-    }\n-\n-    /// Attempts to acquire the lock. The value returned is `Some` if\n-    /// the attempt succeeded.\n-    ///\n-    /// # Unsafety\n-    ///\n-    /// This method is unsafe due to the same reasons as\n-    /// `StaticNativeMutex::trylock`.\n-    pub unsafe fn trylock<'a>(&'a self) -> Option<LockGuard<'a>> {\n-        self.inner.trylock()\n-    }\n-\n-    /// Acquire the lock without creating a `LockGuard`.\n-    ///\n-    /// These needs to be paired with a call to `.unlock_noguard`. Prefer using\n-    /// `.lock`.\n-    ///\n-    /// # Unsafety\n-    ///\n-    /// This method is unsafe due to the same reasons as\n-    /// `StaticNativeMutex::lock_noguard`.\n-    pub unsafe fn lock_noguard(&self) { self.inner.lock_noguard() }\n-\n-    /// Attempts to acquire the lock without creating a\n-    /// `LockGuard`. The value returned is whether the lock was\n-    /// acquired or not.\n-    ///\n-    /// If `true` is returned, this needs to be paired with a call to\n-    /// `.unlock_noguard`. Prefer using `.trylock`.\n-    ///\n-    /// # Unsafety\n-    ///\n-    /// This method is unsafe due to the same reasons as\n-    /// `StaticNativeMutex::trylock_noguard`.\n-    pub unsafe fn trylock_noguard(&self) -> bool {\n-        self.inner.trylock_noguard()\n-    }\n-\n-    /// Unlocks the lock. This assumes that the current thread already holds the\n-    /// lock.\n-    ///\n-    /// # Unsafety\n-    ///\n-    /// This method is unsafe due to the same reasons as\n-    /// `StaticNativeMutex::unlock_noguard`.\n-    pub unsafe fn unlock_noguard(&self) { self.inner.unlock_noguard() }\n-\n-    /// Block on the internal condition variable.\n-    ///\n-    /// This function assumes that the lock is already held. Prefer\n-    /// using `LockGuard.wait` since that guarantees that the lock is\n-    /// held.\n-    ///\n-    /// # Unsafety\n-    ///\n-    /// This method is unsafe due to the same reasons as\n-    /// `StaticNativeMutex::wait_noguard`.\n-    pub unsafe fn wait_noguard(&self) { self.inner.wait_noguard() }\n-\n-    /// Signals a thread in `wait` to wake up\n-    ///\n-    /// # Unsafety\n-    ///\n-    /// This method is unsafe due to the same reasons as\n-    /// `StaticNativeMutex::signal_noguard`.\n-    pub unsafe fn signal_noguard(&self) { self.inner.signal_noguard() }\n-}\n-\n-impl Drop for NativeMutex {\n-    fn drop(&mut self) {\n-        unsafe {self.inner.destroy()}\n-    }\n-}\n-\n-impl<'a> LockGuard<'a> {\n-    /// Block on the internal condition variable.\n-    pub unsafe fn wait(&self) {\n-        self.lock.wait_noguard()\n-    }\n-\n-    /// Signals a thread in `wait` to wake up.\n-    pub unsafe fn signal(&self) {\n-        self.lock.signal_noguard()\n-    }\n-}\n-\n-#[unsafe_destructor]\n-impl<'a> Drop for LockGuard<'a> {\n-    fn drop(&mut self) {\n-        unsafe {self.lock.unlock_noguard()}\n-    }\n-}\n-\n-#[cfg(test)]\n-mod test {\n-    use prelude::*;\n-\n-    use mem::drop;\n-    use super::{StaticNativeMutex, NATIVE_MUTEX_INIT};\n-    use rt::thread::Thread;\n-\n-    #[test]\n-    fn smoke_lock() {\n-        static LK: StaticNativeMutex = NATIVE_MUTEX_INIT;\n-        unsafe {\n-            let _guard = LK.lock();\n-        }\n-    }\n-\n-    #[test]\n-    fn smoke_cond() {\n-        static LK: StaticNativeMutex = NATIVE_MUTEX_INIT;\n-        unsafe {\n-            let guard = LK.lock();\n-            let t = Thread::start(move|| {\n-                let guard = LK.lock();\n-                guard.signal();\n-            });\n-            guard.wait();\n-            drop(guard);\n-\n-            t.join();\n-        }\n-    }\n-\n-    #[test]\n-    fn smoke_lock_noguard() {\n-        static LK: StaticNativeMutex = NATIVE_MUTEX_INIT;\n-        unsafe {\n-            LK.lock_noguard();\n-            LK.unlock_noguard();\n-        }\n-    }\n-\n-    #[test]\n-    fn smoke_cond_noguard() {\n-        static LK: StaticNativeMutex = NATIVE_MUTEX_INIT;\n-        unsafe {\n-            LK.lock_noguard();\n-            let t = Thread::start(move|| {\n-                LK.lock_noguard();\n-                LK.signal_noguard();\n-                LK.unlock_noguard();\n-            });\n-            LK.wait_noguard();\n-            LK.unlock_noguard();\n-\n-            t.join();\n-        }\n-    }\n-\n-    #[test]\n-    fn destroy_immediately() {\n-        unsafe {\n-            let m = StaticNativeMutex::new();\n-            m.destroy();\n-        }\n-    }\n-}"}, {"sha": "9eb7048f1e699d31a5d09eb02b5f03e13fecb283", "filename": "src/libstd/rt/thread.rs", "status": "removed", "additions": 0, "deletions": 170, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/13f302d0c5dd3a88426da53ba07cdbe16459635b/src%2Flibstd%2Frt%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13f302d0c5dd3a88426da53ba07cdbe16459635b/src%2Flibstd%2Frt%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fthread.rs?ref=13f302d0c5dd3a88426da53ba07cdbe16459635b", "patch": "@@ -1,170 +0,0 @@\n-// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Native os-thread management\n-//!\n-//! This modules contains bindings necessary for managing OS-level threads.\n-//! These functions operate outside of the rust runtime, creating threads\n-//! which are not used for scheduling in any way.\n-\n-#![allow(non_camel_case_types)]\n-\n-use core::prelude::*;\n-\n-use boxed::Box;\n-use mem;\n-use sys::stack_overflow;\n-use sys::thread as imp;\n-\n-pub unsafe fn init() {\n-    imp::guard::init();\n-    stack_overflow::init();\n-}\n-\n-pub unsafe fn cleanup() {\n-    stack_overflow::cleanup();\n-}\n-\n-/// This struct represents a native thread's state. This is used to join on an\n-/// existing thread created in the join-able state.\n-pub struct Thread<T> {\n-    native: imp::rust_thread,\n-    joined: bool,\n-    packet: Box<Option<T>>,\n-}\n-\n-static DEFAULT_STACK_SIZE: uint = 1024 * 1024;\n-\n-/// Returns the last writable byte of the main thread's stack next to the guard\n-/// page. Must be called from the main thread.\n-pub fn main_guard_page() -> uint {\n-    unsafe {\n-        imp::guard::main()\n-    }\n-}\n-\n-/// Returns the last writable byte of the current thread's stack next to the\n-/// guard page. Must not be called from the main thread.\n-pub fn current_guard_page() -> uint {\n-    unsafe {\n-        imp::guard::current()\n-    }\n-}\n-\n-// There are two impl blocks b/c if T were specified at the top then it's just a\n-// pain to specify a type parameter on Thread::spawn (which doesn't need the\n-// type parameter).\n-impl Thread<()> {\n-    /// Starts execution of a new OS thread.\n-    ///\n-    /// This function will not wait for the thread to join, but a handle to the\n-    /// thread will be returned.\n-    ///\n-    /// Note that the handle returned is used to acquire the return value of the\n-    /// procedure `main`. The `join` function will wait for the thread to finish\n-    /// and return the value that `main` generated.\n-    ///\n-    /// Also note that the `Thread` returned will *always* wait for the thread\n-    /// to finish executing. This means that even if `join` is not explicitly\n-    /// called, when the `Thread` falls out of scope its destructor will block\n-    /// waiting for the OS thread.\n-    pub fn start<T: Send>(main: proc():Send -> T) -> Thread<T> {\n-        Thread::start_stack(DEFAULT_STACK_SIZE, main)\n-    }\n-\n-    /// Performs the same functionality as `start`, but specifies an explicit\n-    /// stack size for the new thread.\n-    pub fn start_stack<T: Send>(stack: uint, main: proc():Send -> T) -> Thread<T> {\n-\n-        // We need the address of the packet to fill in to be stable so when\n-        // `main` fills it in it's still valid, so allocate an extra box to do\n-        // so.\n-        let packet = box None;\n-        let packet2: *mut Option<T> = unsafe {\n-            *mem::transmute::<&Box<Option<T>>, *const *mut Option<T>>(&packet)\n-        };\n-        let main = proc() unsafe { *packet2 = Some(main()); };\n-        let native = unsafe { imp::create(stack, box main) };\n-\n-        Thread {\n-            native: native,\n-            joined: false,\n-            packet: packet,\n-        }\n-    }\n-\n-    /// This will spawn a new thread, but it will not wait for the thread to\n-    /// finish, nor is it possible to wait for the thread to finish.\n-    ///\n-    /// This corresponds to creating threads in the 'detached' state on unix\n-    /// systems. Note that platforms may not keep the main program alive even if\n-    /// there are detached thread still running around.\n-    pub fn spawn(main: proc():Send) {\n-        Thread::spawn_stack(DEFAULT_STACK_SIZE, main)\n-    }\n-\n-    /// Performs the same functionality as `spawn`, but explicitly specifies a\n-    /// stack size for the new thread.\n-    pub fn spawn_stack(stack: uint, main: proc():Send) {\n-        unsafe {\n-            let handle = imp::create(stack, box main);\n-            imp::detach(handle);\n-        }\n-    }\n-\n-    /// Relinquishes the CPU slot that this OS-thread is currently using,\n-    /// allowing another thread to run for awhile.\n-    pub fn yield_now() {\n-        unsafe { imp::yield_now(); }\n-    }\n-}\n-\n-impl<T: Send> Thread<T> {\n-    /// Wait for this thread to finish, returning the result of the thread's\n-    /// calculation.\n-    pub fn join(mut self) -> T {\n-        assert!(!self.joined);\n-        unsafe { imp::join(self.native) };\n-        self.joined = true;\n-        assert!(self.packet.is_some());\n-        self.packet.take().unwrap()\n-    }\n-}\n-\n-#[unsafe_destructor]\n-impl<T: Send> Drop for Thread<T> {\n-    fn drop(&mut self) {\n-        // This is required for correctness. If this is not done then the thread\n-        // would fill in a return box which no longer exists.\n-        if !self.joined {\n-            unsafe { imp::join(self.native) };\n-        }\n-    }\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use super::Thread;\n-\n-    #[test]\n-    fn smoke() { Thread::start(proc (){}).join(); }\n-\n-    #[test]\n-    fn data() { assert_eq!(Thread::start(proc () { 1i }).join(), 1); }\n-\n-    #[test]\n-    fn detached() { Thread::spawn(proc () {}) }\n-\n-    #[test]\n-    fn small_stacks() {\n-        assert_eq!(42i, Thread::start_stack(0, proc () 42i).join());\n-        assert_eq!(42i, Thread::start_stack(1, proc () 42i).join());\n-    }\n-}"}, {"sha": "8ef10cbbd77dba09b33340594437c53c7b731027", "filename": "src/libstd/rt/unwind.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a27fbac86849e07a0a6c746869d8f78319bd3a16/src%2Flibstd%2Frt%2Funwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a27fbac86849e07a0a6c746869d8f78319bd3a16/src%2Flibstd%2Frt%2Funwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Funwind.rs?ref=a27fbac86849e07a0a6c746869d8f78319bd3a16", "patch": "@@ -373,6 +373,7 @@ pub mod eabi {\n     pub use self::EXCEPTION_DISPOSITION::*;\n     use rt::libunwind as uw;\n     use libc::{c_void, c_int};\n+    use kinds::Copy;\n \n     #[repr(C)]\n     #[allow(missing_copy_implementations)]"}, {"sha": "fa527a70f83958ee8fb3533a1f1ace2c6a60a6bb", "filename": "src/libstd/rt/util.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a27fbac86849e07a0a6c746869d8f78319bd3a16/src%2Flibstd%2Frt%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a27fbac86849e07a0a6c746869d8f78319bd3a16/src%2Flibstd%2Frt%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Futil.rs?ref=a27fbac86849e07a0a6c746869d8f78319bd3a16", "patch": "@@ -89,6 +89,7 @@ pub fn default_sched_threads() -> uint {\n pub const ENFORCE_SANITY: bool = true || !cfg!(rtopt) || cfg!(rtdebug) ||\n                                   cfg!(rtassert);\n \n+#[allow(missing_copy_implementations)]\n pub struct Stdio(libc::c_int);\n \n #[allow(non_upper_case_globals)]"}, {"sha": "26778ef70b3cad5782e617a498d87096fe6a1873", "filename": "src/libstd/sync/atomic.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a27fbac86849e07a0a6c746869d8f78319bd3a16/src%2Flibstd%2Fsync%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a27fbac86849e07a0a6c746869d8f78319bd3a16/src%2Flibstd%2Fsync%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fatomic.rs?ref=a27fbac86849e07a0a6c746869d8f78319bd3a16", "patch": "@@ -42,14 +42,15 @@\n //! ```\n //! use std::sync::Arc;\n //! use std::sync::atomic::{AtomicUint, SeqCst};\n+//! use std::thread::Thread;\n //!\n //! fn main() {\n //!     let spinlock = Arc::new(AtomicUint::new(1));\n //!\n //!     let spinlock_clone = spinlock.clone();\n-//!     spawn(move|| {\n+//!     Thread::spawn(move|| {\n //!         spinlock_clone.store(0, SeqCst);\n-//!     });\n+//!     }).detach();\n //!\n //!     // Wait for the other task to release the lock\n //!     while spinlock.load(SeqCst) != 0 {}\n@@ -61,21 +62,22 @@\n //! ```\n //! use std::sync::Arc;\n //! use std::sync::atomic::{AtomicOption, SeqCst};\n+//! use std::thread::Thread;\n //!\n //! fn main() {\n //!     struct BigObject;\n //!\n //!     let shared_big_object = Arc::new(AtomicOption::empty());\n //!\n //!     let shared_big_object_clone = shared_big_object.clone();\n-//!     spawn(move|| {\n+//!     Thread::spawn(move|| {\n //!         let unwrapped_big_object = shared_big_object_clone.take(SeqCst);\n //!         if unwrapped_big_object.is_some() {\n //!             println!(\"got a big object from another task\");\n //!         } else {\n //!             println!(\"other task hasn't sent big object yet\");\n //!         }\n-//!     });\n+//!     }).detach();\n //!\n //!     shared_big_object.swap(box BigObject, SeqCst);\n //! }"}, {"sha": "6573d9273ceffd9fb91e62f33abf4a314b1bf0d2", "filename": "src/libstd/sync/barrier.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a27fbac86849e07a0a6c746869d8f78319bd3a16/src%2Flibstd%2Fsync%2Fbarrier.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a27fbac86849e07a0a6c746869d8f78319bd3a16/src%2Flibstd%2Fsync%2Fbarrier.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fbarrier.rs?ref=a27fbac86849e07a0a6c746869d8f78319bd3a16", "patch": "@@ -15,17 +15,18 @@ use sync::{Mutex, Condvar};\n ///\n /// ```rust\n /// use std::sync::{Arc, Barrier};\n+/// use std::thread::Thread;\n ///\n /// let barrier = Arc::new(Barrier::new(10));\n /// for _ in range(0u, 10) {\n ///     let c = barrier.clone();\n ///     // The same messages will be printed together.\n ///     // You will NOT see any interleaving.\n-///     spawn(move|| {\n+///     Thread::spawn(move|| {\n ///         println!(\"before wait\");\n ///         c.wait();\n ///         println!(\"after wait\");\n-///     });\n+///     }).detach();\n /// }\n /// ```\n pub struct Barrier {"}, {"sha": "be27c06b83cd306953e9ac864a57fd72261df73b", "filename": "src/libstd/sync/condvar.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a27fbac86849e07a0a6c746869d8f78319bd3a16/src%2Flibstd%2Fsync%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a27fbac86849e07a0a6c746869d8f78319bd3a16/src%2Flibstd%2Fsync%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fcondvar.rs?ref=a27fbac86849e07a0a6c746869d8f78319bd3a16", "patch": "@@ -36,17 +36,18 @@ use time::Duration;\n ///\n /// ```\n /// use std::sync::{Arc, Mutex, Condvar};\n+/// use std::thread::Thread;\n ///\n /// let pair = Arc::new((Mutex::new(false), Condvar::new()));\n /// let pair2 = pair.clone();\n ///\n /// // Inside of our lock, spawn a new thread, and then wait for it to start\n-/// spawn(move|| {\n+/// Thread::spawn(move|| {\n ///     let &(ref lock, ref cvar) = &*pair2;\n ///     let mut started = lock.lock();\n ///     *started = true;\n ///     cvar.notify_one();\n-/// });\n+/// }).detach();\n ///\n /// // wait for the thread to start up\n /// let &(ref lock, ref cvar) = &*pair;\n@@ -362,4 +363,3 @@ mod tests {\n \n     }\n }\n-"}, {"sha": "5e9d234c6423df1de25631c2e6ed9a9797f86203", "filename": "src/libstd/sync/future.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a27fbac86849e07a0a6c746869d8f78319bd3a16/src%2Flibstd%2Fsync%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a27fbac86849e07a0a6c746869d8f78319bd3a16/src%2Flibstd%2Fsync%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Ffuture.rs?ref=a27fbac86849e07a0a6c746869d8f78319bd3a16", "patch": "@@ -142,7 +142,7 @@ impl<A:Send> Future<A> {\n         Thread::spawn(move |:| {\n             // Don't panic if the other end has hung up\n             let _ = tx.send_opt(blk());\n-        });\n+        }).detach();\n \n         Future::from_receiver(rx)\n     }"}, {"sha": "4829be569cc973901cd17db9093d69ef203ab3ef", "filename": "src/libstd/sync/mutex.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a27fbac86849e07a0a6c746869d8f78319bd3a16/src%2Flibstd%2Fsync%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a27fbac86849e07a0a6c746869d8f78319bd3a16/src%2Flibstd%2Fsync%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmutex.rs?ref=a27fbac86849e07a0a6c746869d8f78319bd3a16", "patch": "@@ -35,6 +35,7 @@ use sys_common::mutex as sys;\n ///\n /// ```rust\n /// use std::sync::{Arc, Mutex};\n+/// use std::thread::Thread;\n /// const N: uint = 10;\n ///\n /// // Spawn a few threads to increment a shared variable (non-atomically), and\n@@ -47,7 +48,7 @@ use sys_common::mutex as sys;\n /// let (tx, rx) = channel();\n /// for _ in range(0u, 10) {\n ///     let (data, tx) = (data.clone(), tx.clone());\n-///     spawn(move|| {\n+///     Thread::spawn(move|| {\n ///         // The shared static can only be accessed once the lock is held.\n ///         // Our non-atomic increment is safe because we're the only thread\n ///         // which can access the shared state when the lock is held.\n@@ -57,7 +58,7 @@ use sys_common::mutex as sys;\n ///             tx.send(());\n ///         }\n ///         // the lock is unlocked here when `data` goes out of scope.\n-///     });\n+///     }).detach();\n /// }\n ///\n /// rx.recv();\n@@ -386,7 +387,7 @@ mod test {\n     fn test_mutex_arc_poison() {\n         let arc = Arc::new(Mutex::new(1i));\n         let arc2 = arc.clone();\n-        let _ = Thread::with_join(move|| {\n+        let _ = Thread::spawn(move|| {\n             let lock = arc2.lock();\n             assert_eq!(*lock, 2);\n         }).join();\n@@ -414,7 +415,7 @@ mod test {\n     fn test_mutex_arc_access_in_unwind() {\n         let arc = Arc::new(Mutex::new(1i));\n         let arc2 = arc.clone();\n-        let _ = Thread::with_join::<()>(move|| -> () {\n+        let _ = Thread::spawn(move|| -> () {\n             struct Unwinder {\n                 i: Arc<Mutex<int>>,\n             }"}, {"sha": "07b2f2cf541e5e1b763f33e10905af3fd82c39b5", "filename": "src/libstd/sync/rwlock.rs", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a27fbac86849e07a0a6c746869d8f78319bd3a16/src%2Flibstd%2Fsync%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a27fbac86849e07a0a6c746869d8f78319bd3a16/src%2Flibstd%2Fsync%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Frwlock.rs?ref=a27fbac86849e07a0a6c746869d8f78319bd3a16", "patch": "@@ -409,7 +409,7 @@ mod tests {\n     fn test_rw_arc_poison_wr() {\n         let arc = Arc::new(RWLock::new(1i));\n         let arc2 = arc.clone();\n-        let _ = Thread::with_join(move|| {\n+        let _ = Thread::spawn(move|| {\n             let lock = arc2.write();\n             assert_eq!(*lock, 2);\n         }).join();\n@@ -422,7 +422,7 @@ mod tests {\n     fn test_rw_arc_poison_ww() {\n         let arc = Arc::new(RWLock::new(1i));\n         let arc2 = arc.clone();\n-        let _ = Thread::with_join(move|| {\n+        let _ = Thread::spawn(move|| {\n             let lock = arc2.write();\n             assert_eq!(*lock, 2);\n         }).join();\n@@ -434,7 +434,7 @@ mod tests {\n     fn test_rw_arc_no_poison_rr() {\n         let arc = Arc::new(RWLock::new(1i));\n         let arc2 = arc.clone();\n-        let _ = Thread::with_join(move|| {\n+        let _ = Thread::spawn(move|| {\n             let lock = arc2.read();\n             assert_eq!(*lock, 2);\n         }).join();\n@@ -445,7 +445,7 @@ mod tests {\n     fn test_rw_arc_no_poison_rw() {\n         let arc = Arc::new(RWLock::new(1i));\n         let arc2 = arc.clone();\n-        let _ = Thread::with_join(move|| {\n+        let _ = Thread::spawn(move|| {\n             let lock = arc2.read();\n             assert_eq!(*lock, 2);\n         }).join();\n@@ -468,13 +468,13 @@ mod tests {\n                 *lock = tmp + 1;\n             }\n             tx.send(());\n-        });\n+        }).detach();\n \n         // Readers try to catch the writer in the act\n         let mut children = Vec::new();\n         for _ in range(0u, 5) {\n             let arc3 = arc.clone();\n-            children.push(Thread::with_join(move|| {\n+            children.push(Thread::spawn(move|| {\n                 let lock = arc3.read();\n                 assert!(*lock >= 0);\n             }));\n@@ -495,11 +495,7 @@ mod tests {\n     fn test_rw_arc_access_in_unwind() {\n         let arc = Arc::new(RWLock::new(1i));\n         let arc2 = arc.clone();\n-<<<<<<< HEAD\n-        let _ = task::try(move|| -> () {\n-=======\n-        let _ = Thread::with_join::<()>(proc() {\n->>>>>>> Fallout from new thread API\n+        let _ = Thread::spawn(move|| -> () {\n             struct Unwinder {\n                 i: Arc<RWLock<int>>,\n             }"}, {"sha": "793825f1b08f5c2b83807b8c7b90a371492f608b", "filename": "src/libstd/sync/task_pool.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a27fbac86849e07a0a6c746869d8f78319bd3a16/src%2Flibstd%2Fsync%2Ftask_pool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a27fbac86849e07a0a6c746869d8f78319bd3a16/src%2Flibstd%2Fsync%2Ftask_pool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Ftask_pool.rs?ref=a27fbac86849e07a0a6c746869d8f78319bd3a16", "patch": "@@ -126,7 +126,7 @@ fn spawn_in_pool(jobs: Arc<Mutex<Receiver<Thunk>>>) {\n         }\n \n         sentinel.cancel();\n-    });\n+    }).detach();\n }\n \n #[cfg(test)]"}, {"sha": "2ff82bfd7a96bc05112961ca771d2e79410b865f", "filename": "src/libstd/sys/common/backtrace.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a27fbac86849e07a0a6c746869d8f78319bd3a16/src%2Flibstd%2Fsys%2Fcommon%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a27fbac86849e07a0a6c746869d8f78319bd3a16/src%2Flibstd%2Fsys%2Fcommon%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fbacktrace.rs?ref=a27fbac86849e07a0a6c746869d8f78319bd3a16", "patch": "@@ -10,8 +10,8 @@\n \n use io::{IoResult, Writer};\n use iter::{Iterator, IteratorExt};\n-use option::{Some, None};\n-use result::{Ok, Err};\n+use option::Option::{Some, None};\n+use result::Result::{Ok, Err};\n use str::{StrPrelude, from_str};\n use unicode::char::UnicodeChar;\n "}, {"sha": "421778e20123fc0fcf0c0655a94c41b0ad138bd4", "filename": "src/libstd/sys/common/helper_thread.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a27fbac86849e07a0a6c746869d8f78319bd3a16/src%2Flibstd%2Fsys%2Fcommon%2Fhelper_thread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a27fbac86849e07a0a6c746869d8f78319bd3a16/src%2Flibstd%2Fsys%2Fcommon%2Fhelper_thread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fhelper_thread.rs?ref=a27fbac86849e07a0a6c746869d8f78319bd3a16", "patch": "@@ -82,16 +82,12 @@ impl<M: Send> Helper<M> {\n                 *self.signal.get() = send as uint;\n \n                 let t = f();\n-<<<<<<< HEAD\n-                task::spawn(move |:| {\n-=======\n-                Thread::spawn(proc() {\n->>>>>>> Fallout from new thread API\n+                Thread::spawn(move |:| {\n                     helper(receive, rx, t);\n                     let _g = self.lock.lock();\n                     *self.shutdown.get() = true;\n                     self.cond.notify_one()\n-                });\n+                }).detach();\n \n                 rt::at_exit(move|:| { self.shutdown() });\n                 *self.initialized.get() = true;"}, {"sha": "048e33399a3c46478e5f586d8a11549f1524419a", "filename": "src/libstd/sys/common/thread.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a27fbac86849e07a0a6c746869d8f78319bd3a16/src%2Flibstd%2Fsys%2Fcommon%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a27fbac86849e07a0a6c746869d8f78319bd3a16/src%2Flibstd%2Fsys%2Fcommon%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fthread.rs?ref=a27fbac86849e07a0a6c746869d8f78319bd3a16", "patch": "@@ -14,6 +14,7 @@ use boxed::Box;\n use mem;\n use uint;\n use libc;\n+use thunk::Thunk;\n use sys_common::stack;\n use sys::{thread, stack_overflow};\n \n@@ -26,8 +27,8 @@ pub fn start_thread(main: *mut libc::c_void) -> thread::rust_thread_return {\n     unsafe {\n         stack::record_os_managed_stack_bounds(0, uint::MAX);\n         let handler = stack_overflow::Handler::new();\n-        let f: Box<proc()> = mem::transmute(main);\n-        (*f)();\n+        let f: Box<Thunk> = mem::transmute(main);\n+        f.invoke(());\n         drop(handler);\n         mem::transmute(0 as thread::rust_thread_return)\n     }"}, {"sha": "92a896c758332e6b642f8e13156e5d5cbf6bc07d", "filename": "src/libstd/sys/common/thread_info.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a27fbac86849e07a0a6c746869d8f78319bd3a16/src%2Flibstd%2Fsys%2Fcommon%2Fthread_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a27fbac86849e07a0a6c746869d8f78319bd3a16/src%2Flibstd%2Fsys%2Fcommon%2Fthread_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fthread_info.rs?ref=a27fbac86849e07a0a6c746869d8f78319bd3a16", "patch": "@@ -28,6 +28,11 @@ thread_local!(static THREAD_INFO: RefCell<Option<ThreadInfo>> = RefCell::new(Non\n \n impl ThreadInfo {\n     fn with<R>(f: |&mut ThreadInfo| -> R) -> R {\n+        if THREAD_INFO.destroyed() {\n+            panic!(\"Use of std::thread::Thread::current() is not possible after \\\n+                    the thread's local data has been destroyed\");\n+        }\n+\n         THREAD_INFO.with(|c| {\n             if c.borrow().is_none() {\n                 *c.borrow_mut() = Some(ThreadInfo {"}, {"sha": "df9dbad2ec787d81428de57046978eed4770bfaa", "filename": "src/libstd/sys/unix/backtrace.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a27fbac86849e07a0a6c746869d8f78319bd3a16/src%2Flibstd%2Fsys%2Funix%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a27fbac86849e07a0a6c746869d8f78319bd3a16/src%2Flibstd%2Fsys%2Funix%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fbacktrace.rs?ref=a27fbac86849e07a0a6c746869d8f78319bd3a16", "patch": "@@ -87,8 +87,8 @@ use c_str::CString;\n use io::{IoResult, Writer};\n use libc;\n use mem;\n-use option::{Some, None, Option};\n-use result::{Ok, Err};\n+use option::Option::{mod, Some, None};\n+use result::Result::{Ok, Err};\n use sync::{StaticMutex, MUTEX_INIT};\n \n use sys_common::backtrace::*;"}, {"sha": "2416b64f98f43ededa4cf99af04cd81db2063146", "filename": "src/libstd/sys/unix/thread.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a27fbac86849e07a0a6c746869d8f78319bd3a16/src%2Flibstd%2Fsys%2Funix%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a27fbac86849e07a0a6c746869d8f78319bd3a16/src%2Flibstd%2Fsys%2Funix%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fthread.rs?ref=a27fbac86849e07a0a6c746869d8f78319bd3a16", "patch": "@@ -16,6 +16,7 @@ use mem;\n use ptr;\n use libc::consts::os::posix01::{PTHREAD_CREATE_JOINABLE, PTHREAD_STACK_MIN};\n use libc;\n+use thunk::Thunk;\n \n use sys_common::stack::RED_ZONE;\n use sys_common::thread::*;\n@@ -153,7 +154,7 @@ pub mod guard {\n     }\n }\n \n-pub unsafe fn create(stack: uint, p: Box<proc():Send>) -> rust_thread {\n+pub unsafe fn create(stack: uint, p: Thunk) -> rust_thread {\n     let mut native: libc::pthread_t = mem::zeroed();\n     let mut attr: libc::pthread_attr_t = mem::zeroed();\n     assert_eq!(pthread_attr_init(&mut attr), 0);\n@@ -181,13 +182,13 @@ pub unsafe fn create(stack: uint, p: Box<proc():Send>) -> rust_thread {\n         },\n     };\n \n-    let arg: *mut libc::c_void = mem::transmute(p);\n+    let arg: *mut libc::c_void = mem::transmute(box p); // must box since sizeof(p)=2*uint\n     let ret = pthread_create(&mut native, &attr, thread_start, arg);\n     assert_eq!(pthread_attr_destroy(&mut attr), 0);\n \n     if ret != 0 {\n         // be sure to not leak the closure\n-        let _p: Box<proc():Send> = mem::transmute(arg);\n+        let _p: Box<Box<FnOnce()+Send>> = mem::transmute(arg);\n         panic!(\"failed to spawn native thread: {}\", ret);\n     }\n     native"}, {"sha": "b5961d783ffab45d1796f33fbbea148af5beea5d", "filename": "src/libstd/sys/windows/backtrace.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a27fbac86849e07a0a6c746869d8f78319bd3a16/src%2Flibstd%2Fsys%2Fwindows%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a27fbac86849e07a0a6c746869d8f78319bd3a16/src%2Flibstd%2Fsys%2Fwindows%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fbacktrace.rs?ref=a27fbac86849e07a0a6c746869d8f78319bd3a16", "patch": "@@ -27,9 +27,9 @@ use io::{IoResult, Writer};\n use libc;\n use mem;\n use ops::Drop;\n-use option::{Some, None};\n+use option::Option::{Some, None};\n use path::Path;\n-use result::{Ok, Err};\n+use result::Result::{Ok, Err};\n use sync::{StaticMutex, MUTEX_INIT};\n use slice::SliceExt;\n use str::StrPrelude;"}, {"sha": "0fb52c758d5db08063a57ab7e575357d2b37f52a", "filename": "src/libstd/sys/windows/fs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a27fbac86849e07a0a6c746869d8f78319bd3a16/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a27fbac86849e07a0a6c746869d8f78319bd3a16/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs?ref=a27fbac86849e07a0a6c746869d8f78319bd3a16", "patch": "@@ -15,7 +15,7 @@ use libc::{mod, c_int};\n \n use c_str::CString;\n use mem;\n-use os::windoze::fill_utf16_buf_and_decode;\n+use sys::os::fill_utf16_buf_and_decode;\n use path;\n use ptr;\n use str;"}, {"sha": "2fbb9494c710bdba8d1eb57f14ceb352a60e8df9", "filename": "src/libstd/sys/windows/os.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a27fbac86849e07a0a6c746869d8f78319bd3a16/src%2Flibstd%2Fsys%2Fwindows%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a27fbac86849e07a0a6c746869d8f78319bd3a16/src%2Flibstd%2Fsys%2Fwindows%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fos.rs?ref=a27fbac86849e07a0a6c746869d8f78319bd3a16", "patch": "@@ -24,6 +24,9 @@ use path::{Path, GenericPath, BytesContainer};\n use ptr::{mod, RawPtr};\n use sync::atomic::{AtomicInt, INIT_ATOMIC_INT, SeqCst};\n use sys::fs::FileDesc;\n+use option::Option;\n+use option::Option::{Some, None};\n+use slice;\n \n use os::TMPBUF_SZ;\n use libc::types::os::arch::extra::DWORD;\n@@ -138,7 +141,7 @@ pub fn fill_utf16_buf_and_decode(f: |*mut u16, DWORD| -> DWORD) -> Option<String\n                 // set `res` to None and continue.\n                 let s = String::from_utf16(sub)\n                     .expect(\"fill_utf16_buf_and_decode: closure created invalid UTF-16\");\n-                res = option::Some(s)\n+                res = Some(s)\n             }\n         }\n         return res;"}, {"sha": "bdf2e0bccb1a07695e27b6ccb86d601854a20d96", "filename": "src/libstd/sys/windows/stack_overflow.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a27fbac86849e07a0a6c746869d8f78319bd3a16/src%2Flibstd%2Fsys%2Fwindows%2Fstack_overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a27fbac86849e07a0a6c746869d8f78319bd3a16/src%2Flibstd%2Fsys%2Fwindows%2Fstack_overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fstack_overflow.rs?ref=a27fbac86849e07a0a6c746869d8f78319bd3a16", "patch": "@@ -34,7 +34,7 @@ impl Drop for Handler {\n // It returns the guard page of the current task or 0 if that\n // guard page doesn't exist. None is returned if there's currently\n // no local task.\n-unsafe fn get_task_guard_page() -> Option<uint> {\n+unsafe fn get_task_guard_page() -> uint {\n     thread_info::stack_guard()\n }\n \n@@ -55,9 +55,7 @@ extern \"system\" fn vectored_handler(ExceptionInfo: *mut EXCEPTION_POINTERS) -> L\n         // however stack checks by limit should be disabled on Windows\n         stack::record_sp_limit(0);\n \n-        if get_task_guard_page().is_some() {\n-           report_overflow();\n-        }\n+        report_overflow();\n \n         EXCEPTION_CONTINUE_SEARCH\n     }"}, {"sha": "4498f56c00a1e4adcefdc3e1b21885e1bc4587dd", "filename": "src/libstd/sys/windows/thread.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a27fbac86849e07a0a6c746869d8f78319bd3a16/src%2Flibstd%2Fsys%2Fwindows%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a27fbac86849e07a0a6c746869d8f78319bd3a16/src%2Flibstd%2Fsys%2Fwindows%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fthread.rs?ref=a27fbac86849e07a0a6c746869d8f78319bd3a16", "patch": "@@ -17,6 +17,7 @@ use ptr;\n use libc;\n use libc::types::os::arch::extra::{LPSECURITY_ATTRIBUTES, SIZE_T, BOOL,\n                                    LPVOID, DWORD, LPDWORD, HANDLE};\n+use thunk::Thunk;\n use sys_common::stack::RED_ZONE;\n use sys_common::thread::*;\n \n@@ -43,8 +44,8 @@ pub mod guard {\n     }\n }\n \n-pub unsafe fn create(stack: uint, p: Box<proc():Send>) -> rust_thread {\n-    let arg: *mut libc::c_void = mem::transmute(p);\n+pub unsafe fn create(stack: uint, p: Thunk) -> rust_thread {\n+    let arg: *mut libc::c_void = mem::transmute(box p);\n     // FIXME On UNIX, we guard against stack sizes that are too small but\n     // that's because pthreads enforces that stacks are at least\n     // PTHREAD_STACK_MIN bytes big.  Windows has no such lower limit, it's\n@@ -60,7 +61,7 @@ pub unsafe fn create(stack: uint, p: Box<proc():Send>) -> rust_thread {\n \n     if ret as uint == 0 {\n         // be sure to not leak the closure\n-        let _p: Box<proc():Send> = mem::transmute(arg);\n+        let _p: Box<Thunk> = mem::transmute(arg);\n         panic!(\"failed to spawn native thread: {}\", ret);\n     }\n     return ret;"}, {"sha": "0644519aabb457f46bde179b5cc4800974918338", "filename": "src/libstd/sys/windows/thread_local.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a27fbac86849e07a0a6c746869d8f78319bd3a16/src%2Flibstd%2Fsys%2Fwindows%2Fthread_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a27fbac86849e07a0a6c746869d8f78319bd3a16/src%2Flibstd%2Fsys%2Fwindows%2Fthread_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fthread_local.rs?ref=a27fbac86849e07a0a6c746869d8f78319bd3a16", "patch": "@@ -14,8 +14,7 @@ use libc::types::os::arch::extra::{DWORD, LPVOID, BOOL};\n \n use mem;\n use rt;\n-use rt::exclusive::Exclusive;\n-use sync::{ONCE_INIT, Once};\n+use sync::{ONCE_INIT, Once, Mutex};\n \n pub type Key = DWORD;\n pub type Dtor = unsafe extern fn(*mut u8);\n@@ -55,7 +54,7 @@ pub type Dtor = unsafe extern fn(*mut u8);\n //                        /threading/thread_local_storage_win.cc#L42\n \n static INIT_DTORS: Once = ONCE_INIT;\n-static mut DTORS: *mut Exclusive<Vec<(Key, Dtor)>> = 0 as *mut _;\n+static mut DTORS: *mut Mutex<Vec<(Key, Dtor)>> = 0 as *mut _;\n \n // -------------------------------------------------------------------------\n // Native bindings\n@@ -126,13 +125,13 @@ extern \"system\" {\n // FIXME: This could probably be at least a little faster with a BTree.\n \n fn init_dtors() {\n-    let dtors = box Exclusive::new(Vec::<(Key, Dtor)>::new());\n+    let dtors = box Mutex::new(Vec::<(Key, Dtor)>::new());\n     unsafe {\n         DTORS = mem::transmute(dtors);\n     }\n \n     rt::at_exit(move|| unsafe {\n-        mem::transmute::<_, Box<Exclusive<Vec<(Key, Dtor)>>>>(DTORS);\n+        mem::transmute::<_, Box<Mutex<Vec<(Key, Dtor)>>>>(DTORS);\n         DTORS = 0 as *mut _;\n     });\n }"}, {"sha": "0f08108fee547744a2a459253d61e93b7fc03667", "filename": "src/libstd/task.rs", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/a27fbac86849e07a0a6c746869d8f78319bd3a16/src%2Flibstd%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a27fbac86849e07a0a6c746869d8f78319bd3a16/src%2Flibstd%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask.rs?ref=a27fbac86849e07a0a6c746869d8f78319bd3a16", "patch": "@@ -17,21 +17,24 @@ use boxed::Box;\n use thread;\n use kinds::Send;\n use result::Result;\n+use ops::FnOnce;\n \n-/// Deprecate: use `std::thread::Cfg` instead.\n-#[deprecated = \"use std::thread::Cfg instead\"]\n-pub type TaskBuilder = thread::Cfg;\n+/// Deprecate: use `std::thread::Builder` instead.\n+#[deprecated = \"use std::thread::Builder instead\"]\n+pub type TaskBuilder = thread::Builder;\n \n-/// Deprecated: use `std::thread::Thread::spawn` instead.\n-#[deprecated = \"use std::thread::Thread::spawn instead\"]\n-pub fn spawn(f: proc(): Send) {\n-    thread::Thread::spawn(f);\n+/// Deprecated: use `std::thread::Thread::spawn` and `detach` instead.\n+#[deprecated = \"use std::thread::Thread::spawn and detach instead\"]\n+pub fn spawn<F>(f: F) where F: FnOnce(), F: Send {\n+    thread::Thread::spawn(f).detach();\n }\n \n-/// Deprecated: use `std::thread::Thread::with_join instead`.\n-#[deprecated = \"use std::thread::Thread::with_join instead\"]\n-pub fn try<T: Send>(f: proc(): Send -> T) -> Result<T, Box<Any + Send>> {\n-    thread::Thread::with_join(f).join()\n+/// Deprecated: use `std::thread::Thread::spawn` and `join` instead.\n+#[deprecated = \"use std::thread::Thread::spawn and join instead\"]\n+pub fn try<T, F>(f: F) -> Result<T, Box<Any + Send>> where\n+    T: Send, F: FnOnce() -> T, F: Send\n+{\n+    thread::Thread::spawn(f).join()\n }\n \n /// Deprecated: use `std::thread::Thread::yield_now instead`."}, {"sha": "6c6c0ce85eb0445b4112e1165f5a37ca925751eb", "filename": "src/libstd/thread.rs", "status": "modified", "additions": 157, "deletions": 164, "changes": 321, "blob_url": "https://github.com/rust-lang/rust/blob/a27fbac86849e07a0a6c746869d8f78319bd3a16/src%2Flibstd%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a27fbac86849e07a0a6c746869d8f78319bd3a16/src%2Flibstd%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread.rs?ref=a27fbac86849e07a0a6c746869d8f78319bd3a16", "patch": "@@ -15,13 +15,12 @@\n //! An executing Rust program consists of a collection of native OS threads,\n //! each with their own stack and local state.\n //!\n-//! Threads generally have their memory *isolated* from each other by virtue of\n-//! Rust's owned types (which of course may only be owned by a single thread at\n-//! a time). Communication between threads can be done through\n-//! [channels](../../std/comm/index.html), Rust's message-passing types, along\n-//! with [other forms of thread synchronization](../../std/sync/index.html) and\n-//! shared-memory data structures. In particular, types that are guaranteed to\n-//! be threadsafe are easily shared between threads using the\n+//! Communication between threads can be done through\n+//! [channels](../../std/comm/index.html), Rust's message-passing\n+//! types, along with [other forms of thread\n+//! synchronization](../../std/sync/index.html) and shared-memory data\n+//! structures. In particular, types that are guaranteed to be\n+//! threadsafe are easily shared between threads using the\n //! atomically-reference-counted container,\n //! [`Arc`](../../std/sync/struct.Arc.html).\n //!\n@@ -54,52 +53,43 @@\n //!\n //! ## Spawning a thread\n //!\n-//! There are a few different ways to spawn a new thread, depending on how it\n-//! should relate to the parent thread.\n-//!\n-//! ### Simple detached threads\n-//!\n-//! The simplest case just spawns a completely independent (detached) thread,\n-//! returning a new `Thread` handle to it:\n+//! A new thread can be spawned using the `Thread::spawn` function:\n //!\n //! ```rust\n //! use std::thread::Thread;\n //!\n-//! Thread::spawn(proc() {\n+//! let guard = Thread::spawn(move || {\n //!     println!(\"Hello, World!\");\n-//! })\n+//!     // some computation here\n+//! });\n+//! let result = guard.join();\n //! ```\n //!\n-//! The spawned thread may outlive its parent.\n-//!\n-//! ### Joining\n-//!\n-//! Alternatively, the `with_join` constructor spawns a new thread and returns a\n-//! `JoinGuard` which can be used to wait until the child thread completes,\n-//! returning its result (or `Err` if the child thread panicked):\n-//!\n-//! ```rust\n-//! use std::thread::Thread;\n+//! The `spawn` function doesn't return a `Thread` directly; instead, it returns\n+//! a *join guard* from which a `Thread` can be extracted. The join guard is an\n+//! RAII-style guard that will automatically join the child thread (block until\n+//! it terminates) when it is dropped. You can join the child thread in advance\n+//! by calling the `join` method on the guard, which will also return the result\n+//! produced by the thread.\n //!\n-//! let guard = Thread::with_join(proc() { panic!() };\n-//! assert!(guard.join().is_err());\n-//! ```\n+//! If you instead wish to *detach* the child thread, allowing it to outlive its\n+//! parent, you can use the `detach` method on the guard,\n //!\n-//! The guard works in RAII style, meaning that the child thread is\n-//! automatically joined when the guard is dropped. A handle to the thread\n-//! itself is available via the `thread` method on the guard.\n+//! A handle to the thread itself is available via the `thread` method on the\n+//! join guard.\n //!\n-//! ### Configured threads\n+//! ## Configuring threads\n //!\n-//! Finally, a new thread can be configured independently of how it is\n-//! spawned. Configuration is available via the `Cfg` builder, which currently\n-//! allows you to set the name, stack size, and writers for `println!` and\n-//! `panic!` for the child thread:\n+//! A new thread can be configured before it is spawned via the `Builder` type,\n+//! which currently allows you to set the name, stack size, and writers for\n+//! `println!` and `panic!` for the child thread:\n //!\n //! ```rust\n //! use std::thread;\n //!\n-//! thread::cfg().name(\"child1\").spawn(proc() { println!(\"Hello, world!\") });\n+//! thread::Builder::new().name(\"child1\".to_string()).spawn(move || {\n+//!     println!(\"Hello, world!\")\n+//! }).detach();\n //! ```\n //!\n //! ## Blocking support: park and unpark\n@@ -139,18 +129,19 @@ use core::prelude::*;\n use any::Any;\n use borrow::IntoCow;\n use boxed::Box;\n-use mem;\n+use cell::UnsafeCell;\n use sync::{Mutex, Condvar, Arc};\n use string::String;\n use rt::{mod, unwind};\n use io::{Writer, stdio};\n+use thunk::Thunk;\n \n use sys::thread as imp;\n use sys_common::{stack, thread_info};\n \n /// Thread configuation. Provides detailed control over the properties\n /// and behavior of new threads.\n-pub struct Cfg {\n+pub struct Builder {\n     // A name for the thread-to-be, for identification in panic messages\n     name: Option<String>,\n     // The size of the stack for the spawned thread\n@@ -161,11 +152,11 @@ pub struct Cfg {\n     stderr: Option<Box<Writer + Send>>,\n }\n \n-impl Cfg {\n+impl Builder {\n     /// Generate the base configuration for spawning a thread, from which\n     /// configuration methods can be chained.\n-    pub fn new() -> Cfg {\n-        Cfg {\n+    pub fn new() -> Builder {\n+        Builder {\n             name: None,\n             stack_size: None,\n             stdout: None,\n@@ -175,41 +166,51 @@ impl Cfg {\n \n     /// Name the thread-to-be. Currently the name is used for identification\n     /// only in panic messages.\n-    pub fn name(mut self, name: String) -> Cfg {\n+    pub fn name(mut self, name: String) -> Builder {\n         self.name = Some(name);\n         self\n     }\n \n     /// Deprecated: use `name` instead\n     #[deprecated = \"use name instead\"]\n-    pub fn named<T: IntoCow<'static, String, str>>(self, name: T) -> Cfg {\n+    pub fn named<T: IntoCow<'static, String, str>>(self, name: T) -> Builder {\n         self.name(name.into_cow().into_owned())\n     }\n \n     /// Set the size of the stack for the new thread.\n-    pub fn stack_size(mut self, size: uint) -> Cfg {\n+    pub fn stack_size(mut self, size: uint) -> Builder {\n         self.stack_size = Some(size);\n         self\n     }\n \n     /// Redirect thread-local stdout.\n     #[experimental = \"Will likely go away after proc removal\"]\n-    pub fn stdout(mut self, stdout: Box<Writer + Send>) -> Cfg {\n+    pub fn stdout(mut self, stdout: Box<Writer + Send>) -> Builder {\n         self.stdout = Some(stdout);\n         self\n     }\n \n     /// Redirect thread-local stderr.\n     #[experimental = \"Will likely go away after proc removal\"]\n-    pub fn stderr(mut self, stderr: Box<Writer + Send>) -> Cfg {\n+    pub fn stderr(mut self, stderr: Box<Writer + Send>) -> Builder {\n         self.stderr = Some(stderr);\n         self\n     }\n \n-    fn core_spawn<T: Send>(self, f: proc():Send -> T, after: proc(Result<T>):Send)\n-                           -> (imp::rust_thread, Thread)\n+    /// Spawn a new joinable thread, and return a JoinGuard guard for it.\n+    ///\n+    /// See `Thead::spawn` and the module doc for more details.\n+    pub fn spawn<T, F>(self, f: F) -> JoinGuard<T> where\n+        T: Send, F: FnOnce() -> T, F: Send\n     {\n-        let Cfg { name, stack_size, stdout, stderr } = self;\n+        self.spawn_inner(Thunk::new(f))\n+    }\n+\n+    fn spawn_inner<T: Send>(self, f: Thunk<(), T>) -> JoinGuard<T> {\n+        let my_packet = Arc::new(UnsafeCell::new(None));\n+        let their_packet = my_packet.clone();\n+\n+        let Builder { name, stack_size, stdout, stderr } = self;\n \n         let stack_size = stack_size.unwrap_or(rt::min_stack());\n         let my_thread = Thread::new(name);\n@@ -221,7 +222,7 @@ impl Cfg {\n         // because by the time that this function is executing we've already\n         // consumed at least a little bit of stack (we don't know the exact byte\n         // address at which our stack started).\n-        let main = proc() {\n+        let main = move |:| {\n             let something_around_the_top_of_the_stack = 1;\n             let addr = &something_around_the_top_of_the_stack as *const int;\n             let my_stack_top = addr as uint;\n@@ -235,74 +236,49 @@ impl Cfg {\n                 their_thread\n             );\n \n-            // There are two primary reasons that general try/catch is\n-            // unsafe. The first is that we do not support nested try/catch. The\n-            // fact that this is happening in a newly-spawned thread\n-            // suffices. The second is that unwinding while unwinding is not\n-            // defined.  We take care of that by having an 'unwinding' flag in\n-            // the thread itself. For these reasons, this unsafety should be ok.\n+            let mut output = None;\n+            let f: Thunk<(), T> = if stdout.is_some() || stderr.is_some() {\n+                Thunk::new(move |:| {\n+                    let _ = stdout.map(stdio::set_stdout);\n+                    let _ = stderr.map(stdio::set_stderr);\n+                    f.invoke(())\n+                })\n+            } else {\n+                f\n+            };\n+\n+            let try_result = {\n+                let ptr = &mut output;\n+\n+                // There are two primary reasons that general try/catch is\n+                // unsafe. The first is that we do not support nested\n+                // try/catch. The fact that this is happening in a newly-spawned\n+                // thread suffices. The second is that unwinding while unwinding\n+                // is not defined.  We take care of that by having an\n+                // 'unwinding' flag in the thread itself. For these reasons,\n+                // this unsafety should be ok.\n+                unsafe {\n+                    unwind::try(move || *ptr = Some(f.invoke(())))\n+                }\n+            };\n             unsafe {\n-                let mut output = None;\n-                let f = if stdout.is_some() || stderr.is_some() {\n-                    proc() {\n-                        let _ = stdout.map(stdio::set_stdout);\n-                        let _ = stderr.map(stdio::set_stderr);\n-                        f()\n-                    }\n-                } else {\n-                    f\n-                };\n-\n-                let try_result = {\n-                    let ptr = &mut output;\n-                    unwind::try(move || *ptr = Some(f()))\n-                };\n-                match (output, try_result) {\n-                    (Some(data), Ok(_)) => after(Ok(data)),\n-                    (None, Err(cause)) => after(Err(cause)),\n+                *their_packet.get() = Some(match (output, try_result) {\n+                    (Some(data), Ok(_)) => Ok(data),\n+                    (None, Err(cause)) => Err(cause),\n                     _ => unreachable!()\n-                }\n+                });\n             }\n         };\n-        (unsafe { imp::create(stack_size, box main) }, my_thread)\n-    }\n-\n-    /// Spawn a detached thread, and return a handle to it.\n-    ///\n-    /// The new child thread may outlive its parent.\n-    pub fn spawn(self, f: proc():Send) -> Thread {\n-        let (native, thread) = self.core_spawn(f, proc(_) {});\n-        unsafe { imp::detach(native) };\n-        thread\n-    }\n-\n-    /// Spawn a joinable thread, and return an RAII guard for it.\n-    pub fn with_join<T: Send>(self, f: proc():Send -> T) -> JoinGuard<T> {\n-        // We need the address of the packet to fill in to be stable so when\n-        // `main` fills it in it's still valid, so allocate an extra box to do\n-        // so.\n-        let any: Box<Any+Send> = box 0u8; // sentinel value\n-        let my_packet = box Err(any);\n-        let their_packet: *mut Result<T> = unsafe {\n-            *mem::transmute::<&Box<Result<T>>, *const *mut Result<T>>(&my_packet)\n-        };\n-\n-        let (native, thread) = self.core_spawn(f, proc(result) {\n-            unsafe { *their_packet = result; }\n-        });\n \n         JoinGuard {\n-            native: native,\n+            native: unsafe { imp::create(stack_size, Thunk::new(main)) },\n             joined: false,\n-            packet: Some(my_packet),\n-            thread: thread,\n+            packet: my_packet,\n+            thread: my_thread,\n         }\n     }\n }\n \n-/// A convenience function for creating configurations.\n-pub fn cfg() -> Cfg { Cfg::new() }\n-\n struct Inner {\n     name: Option<String>,\n     lock: Mutex<bool>,          // true when there is a buffered unpark\n@@ -316,6 +292,7 @@ pub struct Thread {\n }\n \n impl Thread {\n+    // Used only internally to construct a thread object without spawning\n     fn new(name: Option<String>) -> Thread {\n         Thread {\n             inner: Arc::new(Inner {\n@@ -326,16 +303,16 @@ impl Thread {\n         }\n     }\n \n-    /// Spawn a detached thread, and return a handle to it.\n+    /// Spawn a new joinable thread, returning a `JoinGuard` for it.\n     ///\n-    /// The new child thread may outlive its parent.\n-    pub fn spawn(f: proc():Send) -> Thread {\n-        Cfg::new().spawn(f)\n-    }\n-\n-    /// Spawn a joinable thread, and return an RAII guard for it.\n-    pub fn with_join<T: Send>(f: proc():Send -> T) -> JoinGuard<T> {\n-        Cfg::new().with_join(f)\n+    /// The join guard can be used to explicitly join the child thead (via\n+    /// `join`), returning `Result<T>`, or it will implicitly join the child\n+    /// upon being dropped. To detach the child, allowing it to outlive the\n+    /// current thread, use `detach`.  See the module documentation for additional details.\n+    pub fn spawn<T, F>(f: F) -> JoinGuard<T> where\n+        T: Send, F: FnOnce() -> T, F: Send\n+    {\n+        Builder::new().spawn(f)\n     }\n \n     /// Gets a handle to the thread that invokes it.\n@@ -353,10 +330,15 @@ impl Thread {\n         thread_info::panicking()\n     }\n \n-    // http://cr.openjdk.java.net/~stefank/6989984.1/raw_files/new/src/os/linux/vm/os_linux.cpp\n     /// Block unless or until the current thread's token is made available (may wake spuriously).\n     ///\n     /// See the module doc for more detail.\n+    //\n+    // The implementation currently uses the trivial strategy of a Mutex+Condvar\n+    // with wakeup flag, which does not actually allow spurious wakeups. In the\n+    // future, this will be implemented in a more efficient way, perhaps along the lines of\n+    //   http://cr.openjdk.java.net/~stefank/6989984.1/raw_files/new/src/os/linux/vm/os_linux.cpp\n+    // or futuxes, and in either case may allow spurious wakeups.\n     pub fn park() {\n         let thread = Thread::current();\n         let mut guard = thread.inner.lock.lock();\n@@ -394,43 +376,52 @@ impl thread_info::NewThread for Thread {\n pub type Result<T> = ::result::Result<T, Box<Any + Send>>;\n \n #[must_use]\n-/// An RAII guard that will block until thread termination when dropped.\n+/// An RAII-style guard that will block until thread termination when dropped.\n+///\n+/// The type `T` is the return type for the thread's main function.\n pub struct JoinGuard<T> {\n     native: imp::rust_thread,\n     thread: Thread,\n     joined: bool,\n-    packet: Option<Box<Result<T>>>,\n+    packet: Arc<UnsafeCell<Option<Result<T>>>>,\n }\n \n impl<T: Send> JoinGuard<T> {\n     /// Extract a handle to the thread this guard will join on.\n-    pub fn thread(&self) -> Thread {\n-        self.thread.clone()\n+    pub fn thread(&self) -> &Thread {\n+        &self.thread\n     }\n \n     /// Wait for the associated thread to finish, returning the result of the thread's\n     /// calculation.\n+    ///\n+    /// If the child thread panics, `Err` is returned with the parameter given\n+    /// to `panic`.\n     pub fn join(mut self) -> Result<T> {\n         assert!(!self.joined);\n         unsafe { imp::join(self.native) };\n         self.joined = true;\n-        let box res =  self.packet.take().unwrap();\n-        res\n+        unsafe {\n+            (*self.packet.get()).take().unwrap()\n+        }\n+    }\n+\n+    /// Detaches the child thread, allowing it to outlive its parent.\n+    pub fn detach(mut self) {\n+        unsafe { imp::detach(self.native) };\n+        self.joined = true; // avoid joining in the destructor\n     }\n }\n \n #[unsafe_destructor]\n impl<T: Send> Drop for JoinGuard<T> {\n     fn drop(&mut self) {\n-        // This is required for correctness. If this is not done then the thread\n-        // would fill in a return box which no longer exists.\n         if !self.joined {\n             unsafe { imp::join(self.native) };\n         }\n     }\n }\n \n-// TODO: fix tests\n #[cfg(test)]\n mod test {\n     use any::{Any, AnyRefExt};\n@@ -440,37 +431,38 @@ mod test {\n     use result;\n     use std::io::{ChanReader, ChanWriter};\n     use string::String;\n-    use super::{Thread, cfg};\n+    use thunk::Thunk;\n+    use super::{Thread, Builder};\n \n     // !!! These tests are dangerous. If something is buggy, they will hang, !!!\n     // !!! instead of exiting cleanly. This might wedge the buildbots.       !!!\n \n     #[test]\n     fn test_unnamed_thread() {\n-        Thread::with_join(proc() {\n+        Thread::spawn(move|| {\n             assert!(Thread::current().name().is_none());\n         }).join().map_err(|_| ()).unwrap();\n     }\n \n     #[test]\n     fn test_named_thread() {\n-        cfg().name(\"ada lovelace\".to_string()).with_join(proc() {\n+        Builder::new().name(\"ada lovelace\".to_string()).spawn(move|| {\n             assert!(Thread::current().name().unwrap() == \"ada lovelace\".to_string());\n         }).join().map_err(|_| ()).unwrap();\n     }\n \n     #[test]\n     fn test_run_basic() {\n         let (tx, rx) = channel();\n-        Thread::spawn(proc() {\n+        Thread::spawn(move|| {\n             tx.send(());\n-        });\n+        }).detach();\n         rx.recv();\n     }\n \n     #[test]\n     fn test_join_success() {\n-        match Thread::with_join::<String>(proc() {\n+        match Thread::spawn(move|| -> String {\n             \"Success!\".to_string()\n         }).join().as_ref().map(|s| s.as_slice()) {\n             result::Result::Ok(\"Success!\") => (),\n@@ -480,7 +472,7 @@ mod test {\n \n     #[test]\n     fn test_join_panic() {\n-        match Thread::with_join(proc() {\n+        match Thread::spawn(move|| {\n             panic!()\n         }).join() {\n             result::Result::Err(_) => (),\n@@ -496,13 +488,13 @@ mod test {\n \n         fn f(i: int, tx: Sender<()>) {\n             let tx = tx.clone();\n-            Thread::spawn(proc() {\n+            Thread::spawn(move|| {\n                 if i == 0 {\n                     tx.send(());\n                 } else {\n                     f(i - 1, tx);\n                 }\n-            });\n+            }).detach();\n \n         }\n         f(10, tx);\n@@ -513,50 +505,51 @@ mod test {\n     fn test_spawn_sched_childs_on_default_sched() {\n         let (tx, rx) = channel();\n \n-        Thread::spawn(proc() {\n-            Thread::spawn(proc() {\n+        Thread::spawn(move|| {\n+            Thread::spawn(move|| {\n                 tx.send(());\n-            });\n-        });\n+            }).detach();\n+        }).detach();\n \n         rx.recv();\n     }\n \n-    fn avoid_copying_the_body(spawnfn: |v: proc():Send|) {\n+    fn avoid_copying_the_body<F>(spawnfn: F) where F: FnOnce(Thunk) {\n         let (tx, rx) = channel::<uint>();\n \n         let x = box 1;\n         let x_in_parent = (&*x) as *const int as uint;\n \n-        spawnfn(proc() {\n+        spawnfn(Thunk::new(move|| {\n             let x_in_child = (&*x) as *const int as uint;\n             tx.send(x_in_child);\n-        });\n+        }));\n \n         let x_in_child = rx.recv();\n         assert_eq!(x_in_parent, x_in_child);\n     }\n \n     #[test]\n     fn test_avoid_copying_the_body_spawn() {\n-        avoid_copying_the_body(|v| { Thread::spawn(v); });\n+        avoid_copying_the_body(|v| {\n+            Thread::spawn(move || v.invoke(())).detach();\n+        });\n     }\n \n     #[test]\n     fn test_avoid_copying_the_body_thread_spawn() {\n         avoid_copying_the_body(|f| {\n-            let builder = cfg();\n-            builder.spawn(proc() {\n-                f();\n-            });\n+            Thread::spawn(move|| {\n+                f.invoke(());\n+            }).detach();\n         })\n     }\n \n     #[test]\n     fn test_avoid_copying_the_body_join() {\n         avoid_copying_the_body(|f| {\n-            let _ = Thread::with_join(proc() {\n-                f()\n+            let _ = Thread::spawn(move|| {\n+                f.invoke(())\n             }).join();\n         })\n     }\n@@ -568,24 +561,24 @@ mod test {\n         // (well, it would if the constant were 8000+ - I lowered it to be more\n         // valgrind-friendly. try this at home, instead..!)\n         static GENERATIONS: uint = 16;\n-        fn child_no(x: uint) -> proc(): Send {\n-            return proc() {\n+        fn child_no(x: uint) -> Thunk {\n+            return Thunk::new(move|| {\n                 if x < GENERATIONS {\n-                    Thread::spawn(child_no(x+1));\n+                    Thread::spawn(move|| child_no(x+1).invoke(())).detach();\n                 }\n-            }\n+            });\n         }\n-        Thread::spawn(child_no(0));\n+        Thread::spawn(|| child_no(0).invoke(())).detach();\n     }\n \n     #[test]\n     fn test_simple_newsched_spawn() {\n-        Thread::spawn(proc()());\n+        Thread::spawn(move || {}).detach();\n     }\n \n     #[test]\n     fn test_try_panic_message_static_str() {\n-        match Thread::with_join(proc() {\n+        match Thread::spawn(move|| {\n             panic!(\"static string\");\n         }).join() {\n             Err(e) => {\n@@ -599,7 +592,7 @@ mod test {\n \n     #[test]\n     fn test_try_panic_message_owned_str() {\n-        match Thread::with_join(proc() {\n+        match Thread::spawn(move|| {\n             panic!(\"owned string\".to_string());\n         }).join() {\n             Err(e) => {\n@@ -613,7 +606,7 @@ mod test {\n \n     #[test]\n     fn test_try_panic_message_any() {\n-        match Thread::with_join(proc() {\n+        match Thread::spawn(move|| {\n             panic!(box 413u16 as Box<Any + Send>);\n         }).join() {\n             Err(e) => {\n@@ -631,7 +624,7 @@ mod test {\n     fn test_try_panic_message_unit_struct() {\n         struct Juju;\n \n-        match Thread::with_join(proc() {\n+        match Thread::spawn(move|| {\n             panic!(Juju)\n         }).join() {\n             Err(ref e) if e.is::<Juju>() => {}\n@@ -645,9 +638,9 @@ mod test {\n         let mut reader = ChanReader::new(rx);\n         let stdout = ChanWriter::new(tx);\n \n-        let r = cfg().stdout(box stdout as Box<Writer + Send>).with_join(proc() {\n-                print!(\"Hello, world!\");\n-            }).join();\n+        let r = Builder::new().stdout(box stdout as Box<Writer + Send>).spawn(move|| {\n+            print!(\"Hello, world!\");\n+        }).join();\n         assert!(r.is_ok());\n \n         let output = reader.read_to_string().unwrap();"}, {"sha": "4c33d1c418d962d0e22ab7a58c67c8a449387773", "filename": "src/libstd/thread_local/mod.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a27fbac86849e07a0a6c746869d8f78319bd3a16/src%2Flibstd%2Fthread_local%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a27fbac86849e07a0a6c746869d8f78319bd3a16/src%2Flibstd%2Fthread_local%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread_local%2Fmod.rs?ref=a27fbac86849e07a0a6c746869d8f78319bd3a16", "patch": "@@ -68,6 +68,7 @@ pub mod scoped;\n ///\n /// ```\n /// use std::cell::RefCell;\n+/// use std::thread::Thread;\n ///\n /// thread_local!(static FOO: RefCell<uint> = RefCell::new(1));\n ///\n@@ -77,12 +78,12 @@ pub mod scoped;\n /// });\n ///\n /// // each thread starts out with the initial value of 1\n-/// spawn(move|| {\n+/// Thread::spawn(move|| {\n ///     FOO.with(|f| {\n ///         assert_eq!(*f.borrow(), 1);\n ///         *f.borrow_mut() = 3;\n ///     });\n-/// });\n+/// }).detach();\n ///\n /// // we retain our original value of 2 despite the child thread\n /// FOO.with(|f| {\n@@ -533,7 +534,7 @@ mod tests {\n             }\n         }\n \n-        Thread::with_join(move|| {\n+        Thread::spawn(move|| {\n             drop(S1);\n         }).join();\n     }\n@@ -551,7 +552,7 @@ mod tests {\n             }\n         }\n \n-        Thread::with_join(move|| unsafe {\n+        Thread::spawn(move|| unsafe {\n             K1.with(|s| *s.get() = Some(S1));\n         }).join();\n     }"}, {"sha": "067926042f121ba38c6c77e30ba3d449a9638323", "filename": "src/libstd/thunk.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a27fbac86849e07a0a6c746869d8f78319bd3a16/src%2Flibstd%2Fthunk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a27fbac86849e07a0a6c746869d8f78319bd3a16/src%2Flibstd%2Fthunk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthunk.rs?ref=a27fbac86849e07a0a6c746869d8f78319bd3a16", "patch": "@@ -8,6 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// Because this module is temporary...\n+#![allow(missing_docs)]\n+\n use alloc::boxed::Box;\n use core::kinds::Send;\n use core::ops::FnOnce;"}, {"sha": "56af8785a76d47356d5035ca855cfb86c6eb32a8", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a27fbac86849e07a0a6c746869d8f78319bd3a16/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a27fbac86849e07a0a6c746869d8f78319bd3a16/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=a27fbac86849e07a0a6c746869d8f78319bd3a16", "patch": "@@ -1126,7 +1126,7 @@ pub fn run_test(opts: &TestOpts,\n             let mut reader = ChanReader::new(rx);\n             let stdout = ChanWriter::new(tx.clone());\n             let stderr = ChanWriter::new(tx);\n-            let mut cfg = thread::cfg().name(match desc.name {\n+            let mut cfg = thread::Builder::new().name(match desc.name {\n                 DynTestName(ref name) => name.clone().to_string(),\n                 StaticTestName(name) => name.to_string(),\n             });\n@@ -1137,11 +1137,11 @@ pub fn run_test(opts: &TestOpts,\n                 cfg = cfg.stderr(box stderr as Box<Writer + Send>);\n             }\n \n-            let result_guard = cfg.with_join(testfn);\n+            let result_guard = cfg.spawn(move || { testfn.invoke(()) });\n             let stdout = reader.read_to_end().unwrap().into_iter().collect();\n             let test_result = calc_result(&desc, result_guard.join());\n             monitor_ch.send((desc.clone(), test_result, stdout));\n-        });\n+        }).detach();\n     }\n \n     match testfn {"}, {"sha": "645c029f935a712a6023cc77dd0e17bdbf018d26", "filename": "src/test/bench/msgsend-pipes-shared.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a27fbac86849e07a0a6c746869d8f78319bd3a16/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a27fbac86849e07a0a6c746869d8f78319bd3a16/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs?ref=a27fbac86849e07a0a6c746869d8f78319bd3a16", "patch": "@@ -20,7 +20,7 @@\n \n use std::comm;\n use std::os;\n-use std::task;\n+use std::thread::Thread;\n use std::time::Duration;\n use std::uint;\n \n@@ -64,20 +64,20 @@ fn run(args: &[String]) {\n         let mut worker_results = Vec::new();\n         for _ in range(0u, workers) {\n             let to_child = to_child.clone();\n-            worker_results.push(task::try_future(move|| {\n+            worker_results.push(Thread::spawn(move|| {\n                 for _ in range(0u, size / workers) {\n                     //println!(\"worker {}: sending {} bytes\", i, num_bytes);\n                     to_child.send(request::bytes(num_bytes));\n                 }\n                 //println!(\"worker {} exiting\", i);\n             }));\n         }\n-        task::spawn(move|| {\n+        Thread::spawn(move|| {\n             server(&from_parent, &to_parent);\n-        });\n+        }).detach();\n \n         for r in worker_results.into_iter() {\n-            r.unwrap();\n+            let _ = r.join();\n         }\n \n         //println!(\"sending stop message\");"}, {"sha": "ed96c6406d836d7b3cf264b240a095239bf581f7", "filename": "src/test/bench/msgsend-pipes.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a27fbac86849e07a0a6c746869d8f78319bd3a16/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a27fbac86849e07a0a6c746869d8f78319bd3a16/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs?ref=a27fbac86849e07a0a6c746869d8f78319bd3a16", "patch": "@@ -15,7 +15,7 @@\n // I *think* it's the same, more or less.\n \n use std::os;\n-use std::task;\n+use std::thread::Thread;\n use std::time::Duration;\n use std::uint;\n \n@@ -58,7 +58,7 @@ fn run(args: &[String]) {\n         let mut worker_results = Vec::new();\n         let from_parent = if workers == 1 {\n             let (to_child, from_parent) = channel();\n-            worker_results.push(task::try_future(move|| {\n+            worker_results.push(Thread::spawn(move|| {\n                 for _ in range(0u, size / workers) {\n                     //println!(\"worker {}: sending {} bytes\", i, num_bytes);\n                     to_child.send(request::bytes(num_bytes));\n@@ -70,7 +70,7 @@ fn run(args: &[String]) {\n             let (to_child, from_parent) = channel();\n             for _ in range(0u, workers) {\n                 let to_child = to_child.clone();\n-                worker_results.push(task::try_future(move|| {\n+                worker_results.push(Thread::spawn(move|| {\n                     for _ in range(0u, size / workers) {\n                         //println!(\"worker {}: sending {} bytes\", i, num_bytes);\n                         to_child.send(request::bytes(num_bytes));\n@@ -80,12 +80,12 @@ fn run(args: &[String]) {\n             }\n             from_parent\n         };\n-        task::spawn(move|| {\n+        Thread::spawn(move|| {\n             server(&from_parent, &to_parent);\n-        });\n+        }).detach();\n \n         for r in worker_results.into_iter() {\n-            r.unwrap();\n+            let _ = r.join();\n         }\n \n         //println!(\"sending stop message\");"}, {"sha": "f7e8fc8fe1b7adb58199ff2bc45025d8b2141bf7", "filename": "src/test/bench/shootout-pfib.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a27fbac86849e07a0a6c746869d8f78319bd3a16/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a27fbac86849e07a0a6c746869d8f78319bd3a16/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-pfib.rs?ref=a27fbac86849e07a0a6c746869d8f78319bd3a16", "patch": "@@ -22,7 +22,7 @@ extern crate getopts;\n \n use std::os;\n use std::result::Result::{Ok, Err};\n-use std::task;\n+use std::thread::Thread;\n use std::time::Duration;\n \n fn fib(n: int) -> int {\n@@ -34,15 +34,15 @@ fn fib(n: int) -> int {\n         } else {\n             let (tx1, rx) = channel();\n             let tx2 = tx1.clone();\n-            task::spawn(move|| pfib(&tx2, n - 1));\n+            Thread::spawn(move|| pfib(&tx2, n - 1)).detach();\n             let tx2 = tx1.clone();\n-            task::spawn(move|| pfib(&tx2, n - 2));\n+            Thread::spawn(move|| pfib(&tx2, n - 2)).detach();\n             tx.send(rx.recv() + rx.recv());\n         }\n     }\n \n     let (tx, rx) = channel();\n-    spawn(move|| pfib(&tx, n) );\n+    Thread::spawn(move|| pfib(&tx, n) ).detach();\n     rx.recv()\n }\n \n@@ -77,12 +77,12 @@ fn stress_task(id: int) {\n fn stress(num_tasks: int) {\n     let mut results = Vec::new();\n     for i in range(0, num_tasks) {\n-        results.push(task::try_future(move|| {\n+        results.push(Thread::spawn(move|| {\n             stress_task(i);\n         }));\n     }\n     for r in results.into_iter() {\n-        r.unwrap();\n+        let _ = r.join();\n     }\n }\n "}, {"sha": "b8ff1be71bf2b0e231161fd90680656c0f412d9c", "filename": "src/test/run-fail/main-panic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a27fbac86849e07a0a6c746869d8f78319bd3a16/src%2Ftest%2Frun-fail%2Fmain-panic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a27fbac86849e07a0a6c746869d8f78319bd3a16/src%2Ftest%2Frun-fail%2Fmain-panic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fmain-panic.rs?ref=a27fbac86849e07a0a6c746869d8f78319bd3a16", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern:task '<main>' panicked at\n+// error-pattern:thread '<main>' panicked at\n \n fn main() {\n     panic!()"}, {"sha": "c943dfe9f0c604b9351b11b309b8e930df259b9c", "filename": "src/test/run-fail/panic-task-name-none.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a27fbac86849e07a0a6c746869d8f78319bd3a16/src%2Ftest%2Frun-fail%2Fpanic-task-name-none.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a27fbac86849e07a0a6c746869d8f78319bd3a16/src%2Ftest%2Frun-fail%2Fpanic-task-name-none.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fpanic-task-name-none.rs?ref=a27fbac86849e07a0a6c746869d8f78319bd3a16", "patch": "@@ -8,14 +8,14 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern:task '<unnamed>' panicked at 'test'\n+// error-pattern:thread '<unnamed>' panicked at 'test'\n \n-use std::task;\n+use std::thread::Thread;\n \n fn main() {\n-    let r: Result<int,_> = task::try(move|| {\n+    let r: Result<int,_> = Thread::spawn(move|| {\n         panic!(\"test\");\n         1i\n-    });\n+    }).join();\n     assert!(r.is_ok());\n }"}, {"sha": "57901ebcfc622d176cae53eb995060407711bf20", "filename": "src/test/run-fail/panic-task-name-owned.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a27fbac86849e07a0a6c746869d8f78319bd3a16/src%2Ftest%2Frun-fail%2Fpanic-task-name-owned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a27fbac86849e07a0a6c746869d8f78319bd3a16/src%2Ftest%2Frun-fail%2Fpanic-task-name-owned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fpanic-task-name-owned.rs?ref=a27fbac86849e07a0a6c746869d8f78319bd3a16", "patch": "@@ -8,15 +8,14 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern:task 'owned name' panicked at 'test'\n+// error-pattern:thread 'owned name' panicked at 'test'\n \n-use std::task::TaskBuilder;\n+use std::thread::Builder;\n \n fn main() {\n-    let r: Result<int,_> = TaskBuilder::new().named(\"owned name\".to_string())\n-                                             .try(move|| {\n+    let r: Result<int,_> = Builder::new().name(\"owned name\".to_string()).spawn(move|| {\n         panic!(\"test\");\n         1i\n-    });\n+    }).join();\n     assert!(r.is_ok());\n }"}, {"sha": "92ebb3b4587af6b277a3cfb8f71ecb6c482d8a60", "filename": "src/test/run-fail/panic-task-name-send-str.rs", "status": "removed", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/13f302d0c5dd3a88426da53ba07cdbe16459635b/src%2Ftest%2Frun-fail%2Fpanic-task-name-send-str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13f302d0c5dd3a88426da53ba07cdbe16459635b/src%2Ftest%2Frun-fail%2Fpanic-task-name-send-str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fpanic-task-name-send-str.rs?ref=13f302d0c5dd3a88426da53ba07cdbe16459635b", "patch": "@@ -1,21 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// error-pattern:task 'send name' panicked at 'test'\n-\n-fn main() {\n-    let r: Result<int,_> =\n-        ::std::task::TaskBuilder::new().named(\"send name\".into_cow())\n-                                       .try(move|| {\n-            panic!(\"test\");\n-            3i\n-        });\n-    assert!(r.is_ok());\n-}"}, {"sha": "f8dfe9245b4389345a491d62428d84d5e7852509", "filename": "src/test/run-fail/panic-task-name-static.rs", "status": "removed", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/13f302d0c5dd3a88426da53ba07cdbe16459635b/src%2Ftest%2Frun-fail%2Fpanic-task-name-static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13f302d0c5dd3a88426da53ba07cdbe16459635b/src%2Ftest%2Frun-fail%2Fpanic-task-name-static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fpanic-task-name-static.rs?ref=13f302d0c5dd3a88426da53ba07cdbe16459635b", "patch": "@@ -1,19 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// error-pattern:task 'static name' panicked at 'test'\n-\n-fn main() {\n-    let r: Result<int,_> =\n-        ::std::task::TaskBuilder::new().named(\"static name\").try(move|| {\n-            panic!(\"test\");\n-        });\n-    assert!(r.is_ok());\n-}"}, {"sha": "fa360570253b0f0e947eaaf1b2fe669d40704f21", "filename": "src/test/run-fail/test-panic.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a27fbac86849e07a0a6c746869d8f78319bd3a16/src%2Ftest%2Frun-fail%2Ftest-panic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a27fbac86849e07a0a6c746869d8f78319bd3a16/src%2Ftest%2Frun-fail%2Ftest-panic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Ftest-panic.rs?ref=a27fbac86849e07a0a6c746869d8f78319bd3a16", "patch": "@@ -9,12 +9,11 @@\n // except according to those terms.\n \n // check-stdout\n-// error-pattern:task 'test_foo' panicked at\n+// error-pattern:thread 'test_foo' panicked at\n // compile-flags: --test\n // ignore-pretty: does not work well with `--test`\n \n #[test]\n fn test_foo() {\n     panic!()\n }\n-"}, {"sha": "5a5bb53a33a209f12f25f928a01fb662e034e7ff", "filename": "src/test/run-fail/test-should-fail-bad-message.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a27fbac86849e07a0a6c746869d8f78319bd3a16/src%2Ftest%2Frun-fail%2Ftest-should-fail-bad-message.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a27fbac86849e07a0a6c746869d8f78319bd3a16/src%2Ftest%2Frun-fail%2Ftest-should-fail-bad-message.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Ftest-should-fail-bad-message.rs?ref=a27fbac86849e07a0a6c746869d8f78319bd3a16", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n // check-stdout\n-// error-pattern:task 'test_foo' panicked at\n+// error-pattern:thread 'test_foo' panicked at\n // compile-flags: --test\n // ignore-pretty: does not work well with `--test`\n \n@@ -18,5 +18,3 @@\n fn test_foo() {\n     panic!(\"blah\")\n }\n-\n-"}, {"sha": "572447097b775b2d0c00ab206d04eeb9e516b8a4", "filename": "src/test/run-make/bootstrap-from-c-with-native/Makefile", "status": "removed", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/13f302d0c5dd3a88426da53ba07cdbe16459635b/src%2Ftest%2Frun-make%2Fbootstrap-from-c-with-native%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/13f302d0c5dd3a88426da53ba07cdbe16459635b/src%2Ftest%2Frun-make%2Fbootstrap-from-c-with-native%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fbootstrap-from-c-with-native%2FMakefile?ref=13f302d0c5dd3a88426da53ba07cdbe16459635b", "patch": "@@ -1,12 +0,0 @@\n--include ../tools.mk\n-\n-HOST_LIB_DIR=$(TMPDIR)/../../../stage$(RUST_BUILD_STAGE)/lib\n-# This overrides the LD_LIBRARY_PATH for RUN\n-TARGET_RPATH_DIR:=$(TARGET_RPATH_DIR):$(TMPDIR)\n-\n-all:\n-\t$(RUSTC) lib.rs\n-\t$(CC) main.c -o $(call RUN_BINFILE,main) $(call RPATH_LINK_SEARCH,$(HOST_LIB_DIR)) -lboot $(EXTRACFLAGS)\n-\t$(call RUN,main)\n-\t$(call REMOVE_DYLIBS,boot)\n-\t$(call FAIL,main)"}, {"sha": "d2fd5393834ebfbd32ae83308bc9af0902448528", "filename": "src/test/run-make/bootstrap-from-c-with-native/lib.rs", "status": "removed", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/13f302d0c5dd3a88426da53ba07cdbe16459635b/src%2Ftest%2Frun-make%2Fbootstrap-from-c-with-native%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13f302d0c5dd3a88426da53ba07cdbe16459635b/src%2Ftest%2Frun-make%2Fbootstrap-from-c-with-native%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fbootstrap-from-c-with-native%2Flib.rs?ref=13f302d0c5dd3a88426da53ba07cdbe16459635b", "patch": "@@ -1,24 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#![crate_name=\"boot\"]\n-#![crate_type=\"dylib\"]\n-\n-use std::rt;\n-use std::thunk::Thunk;\n-\n-#[no_mangle] // this needs to get called from C\n-pub extern \"C\" fn foo(argc: int, argv: *const *const u8) -> int {\n-    rt::start(argc, argv, Thunk::new(move|| {\n-        spawn(move|| {\n-            println!(\"hello\");\n-        });\n-    }))\n-}"}, {"sha": "1872c1ea43b1139cfaf90e728d6f11d8c07c2c52", "filename": "src/test/run-make/bootstrap-from-c-with-native/main.c", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/13f302d0c5dd3a88426da53ba07cdbe16459635b/src%2Ftest%2Frun-make%2Fbootstrap-from-c-with-native%2Fmain.c", "raw_url": "https://github.com/rust-lang/rust/raw/13f302d0c5dd3a88426da53ba07cdbe16459635b/src%2Ftest%2Frun-make%2Fbootstrap-from-c-with-native%2Fmain.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fbootstrap-from-c-with-native%2Fmain.c?ref=13f302d0c5dd3a88426da53ba07cdbe16459635b", "patch": "@@ -1,16 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// this is the rust entry point that we're going to call.\n-int foo(int argc, char *argv[]);\n-\n-int main(int argc, char *argv[]) {\n-  return foo(argc, argv);\n-}"}, {"sha": "440b7afa984f796ca2d7aab32420dd6f27b1ceb8", "filename": "src/test/run-pass/cleanup-rvalue-temp-during-incomplete-alloc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a27fbac86849e07a0a6c746869d8f78319bd3a16/src%2Ftest%2Frun-pass%2Fcleanup-rvalue-temp-during-incomplete-alloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a27fbac86849e07a0a6c746869d8f78319bd3a16/src%2Ftest%2Frun-pass%2Fcleanup-rvalue-temp-during-incomplete-alloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcleanup-rvalue-temp-during-incomplete-alloc.rs?ref=a27fbac86849e07a0a6c746869d8f78319bd3a16", "patch": "@@ -45,5 +45,5 @@ pub fn fails() {\n }\n \n pub fn main() {\n-    Thread::with_join(fails).join();\n+    Thread::spawn(fails).join();\n }"}, {"sha": "ce3e447350d40cb57877b5c936e647a53411ce33", "filename": "src/test/run-pass/foreign-call-no-runtime.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a27fbac86849e07a0a6c746869d8f78319bd3a16/src%2Ftest%2Frun-pass%2Fforeign-call-no-runtime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a27fbac86849e07a0a6c746869d8f78319bd3a16/src%2Ftest%2Frun-pass%2Fforeign-call-no-runtime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fforeign-call-no-runtime.rs?ref=a27fbac86849e07a0a6c746869d8f78319bd3a16", "patch": "@@ -11,7 +11,7 @@\n extern crate libc;\n \n use std::mem;\n-use std::rt::thread::Thread;\n+use std::thread::Thread;\n \n #[link(name = \"rust_test_helpers\")]\n extern {\n@@ -21,7 +21,7 @@ extern {\n \n pub fn main() {\n     unsafe {\n-        Thread::start(move|| {\n+        Thread::spawn(move|| {\n             let i = &100i;\n             rust_dbg_call(callback, mem::transmute(i));\n         }).join();"}, {"sha": "99758f9f777d6511e8b837a533b8478d60243642", "filename": "src/test/run-pass/issue-16671.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a27fbac86849e07a0a6c746869d8f78319bd3a16/src%2Ftest%2Frun-pass%2Fissue-16671.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a27fbac86849e07a0a6c746869d8f78319bd3a16/src%2Ftest%2Frun-pass%2Fissue-16671.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-16671.rs?ref=a27fbac86849e07a0a6c746869d8f78319bd3a16", "patch": "@@ -18,9 +18,11 @@\n // A var moved into a proc, that has a mutable loan path should\n // not trigger a misleading unused_mut warning.\n \n+use std::thread::Thread;\n+\n pub fn main() {\n     let mut stdin = std::io::stdin();\n-    spawn(move|| {\n+    Thread::spawn(move|| {\n         let _ = stdin.read_to_end();\n-    });\n+    }).detach();\n }"}, {"sha": "4bbbe978192b13f2e85ab112f2a69e9129acb40e", "filename": "src/test/run-pass/issue-2190-1.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a27fbac86849e07a0a6c746869d8f78319bd3a16/src%2Ftest%2Frun-pass%2Fissue-2190-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a27fbac86849e07a0a6c746869d8f78319bd3a16/src%2Ftest%2Frun-pass%2Fissue-2190-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2190-1.rs?ref=a27fbac86849e07a0a6c746869d8f78319bd3a16", "patch": "@@ -8,13 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::task::TaskBuilder;\n+use std::thread::Builder;\n use std::thunk::Thunk;\n \n static generations: uint = 1024+256+128+49;\n \n fn spawn(f: Thunk) {\n-    TaskBuilder::new().stack_size(32 * 1024).spawn(move|| f.invoke(()))\n+    Builder::new().stack_size(32 * 1024).spawn(move|| f.invoke(())).detach()\n }\n \n fn child_no(x: uint) -> Thunk {"}, {"sha": "9bb912e081ce68363d78686e223845dc413a0106", "filename": "src/test/run-pass/match-ref-binding-in-guard-3256.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a27fbac86849e07a0a6c746869d8f78319bd3a16/src%2Ftest%2Frun-pass%2Fmatch-ref-binding-in-guard-3256.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a27fbac86849e07a0a6c746869d8f78319bd3a16/src%2Ftest%2Frun-pass%2Fmatch-ref-binding-in-guard-3256.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmatch-ref-binding-in-guard-3256.rs?ref=a27fbac86849e07a0a6c746869d8f78319bd3a16", "patch": "@@ -8,11 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::rt::exclusive;\n+use std::sync::Mutex;\n \n pub fn main() {\n     unsafe {\n-        let x = Some(exclusive::Exclusive::new(true));\n+        let x = Some(Mutex::new(true));\n         match x {\n             Some(ref z) if *z.lock() => {\n                 assert!(*z.lock());"}, {"sha": "4cf8c52f2bb44ab42d3b91c59cea9791905b2031", "filename": "src/test/run-pass/running-with-no-runtime.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a27fbac86849e07a0a6c746869d8f78319bd3a16/src%2Ftest%2Frun-pass%2Frunning-with-no-runtime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a27fbac86849e07a0a6c746869d8f78319bd3a16/src%2Ftest%2Frun-pass%2Frunning-with-no-runtime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frunning-with-no-runtime.rs?ref=a27fbac86849e07a0a6c746869d8f78319bd3a16", "patch": "@@ -33,11 +33,11 @@ fn start(argc: int, argv: *const *const u8) -> int {\n         return 0\n     }\n \n-    rt::start(argc, argv, Thunk::new(main))\n-}\n-\n-fn main() {\n-    let args = os::args();\n+    let args = unsafe {\n+        Vec::from_fn(argc as uint, |i| {\n+            String::from_raw_buf(*argv.offset(i as int)).into_bytes()\n+        })\n+    };\n     let me = args[0].as_slice();\n \n     let x: &[u8] = &[1u8];\n@@ -52,6 +52,8 @@ fn main() {\n     pass(Command::new(me).arg(x).output().unwrap());\n     let x: &[u8] = &[6u8];\n     pass(Command::new(me).arg(x).output().unwrap());\n+\n+    0\n }\n \n fn pass(output: ProcessOutput) {"}, {"sha": "ea594977f905cf81b37912afc1bc8027a830ce3c", "filename": "src/test/run-pass/spawning-with-debug.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a27fbac86849e07a0a6c746869d8f78319bd3a16/src%2Ftest%2Frun-pass%2Fspawning-with-debug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a27fbac86849e07a0a6c746869d8f78319bd3a16/src%2Ftest%2Frun-pass%2Fspawning-with-debug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fspawning-with-debug.rs?ref=a27fbac86849e07a0a6c746869d8f78319bd3a16", "patch": "@@ -13,9 +13,9 @@\n \n // regression test for issue #10405, make sure we don't call println! too soon.\n \n-use std::task::TaskBuilder;\n+use std::thread::Builder;\n \n pub fn main() {\n-    let mut t = TaskBuilder::new();\n-    t.spawn(move|| ());\n+    let mut t = Builder::new();\n+    t.spawn(move|| ()).detach();\n }"}, {"sha": "561c9e91553dd17fc5d9254f99cfc90d94610da7", "filename": "src/test/run-pass/task-comm-12.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a27fbac86849e07a0a6c746869d8f78319bd3a16/src%2Ftest%2Frun-pass%2Ftask-comm-12.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a27fbac86849e07a0a6c746869d8f78319bd3a16/src%2Ftest%2Frun-pass%2Ftask-comm-12.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-12.rs?ref=a27fbac86849e07a0a6c746869d8f78319bd3a16", "patch": "@@ -8,27 +8,27 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::task;\n+use std::thread::Thread;\n \n pub fn main() { test00(); }\n \n fn start(_task_number: int) { println!(\"Started / Finished task.\"); }\n \n fn test00() {\n     let i: int = 0;\n-    let mut result = task::try_future(move|| {\n+    let mut result = Thread::spawn(move|| {\n         start(i)\n     });\n \n     // Sleep long enough for the task to finish.\n     let mut i = 0u;\n     while i < 10000 {\n-        task::deschedule();\n+        Thread::yield_now();\n         i += 1;\n     }\n \n     // Try joining tasks that have already finished.\n-    result.unwrap();\n+    result.join();\n \n     println!(\"Joined task.\");\n }"}, {"sha": "73f6eb563c1ceb5b7da77e8d9ccc4bcc72bd29c4", "filename": "src/test/run-pass/task-comm-3.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a27fbac86849e07a0a6c746869d8f78319bd3a16/src%2Ftest%2Frun-pass%2Ftask-comm-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a27fbac86849e07a0a6c746869d8f78319bd3a16/src%2Ftest%2Frun-pass%2Ftask-comm-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-3.rs?ref=a27fbac86849e07a0a6c746869d8f78319bd3a16", "patch": "@@ -10,7 +10,7 @@\n \n // no-pretty-expanded FIXME #15189\n \n-use std::task;\n+use std::thread::Thread;\n \n pub fn main() { println!(\"===== WITHOUT THREADS =====\"); test00(); }\n \n@@ -39,7 +39,7 @@ fn test00() {\n     let mut results = Vec::new();\n     while i < number_of_tasks {\n         let tx = tx.clone();\n-        results.push(task::try_future({\n+        results.push(Thread::spawn({\n             let i = i;\n             move|| {\n                 test00_start(&tx, i, number_of_messages)\n@@ -60,7 +60,7 @@ fn test00() {\n     }\n \n     // Join spawned tasks...\n-    for r in results.iter_mut() { r.get_ref(); }\n+    for r in results.into_iter() { r.join(); }\n \n     println!(\"Completed: Final number is: \");\n     println!(\"{}\", sum);"}, {"sha": "69d70050437f18fcb87dd219af6c8eb3ddca09b2", "filename": "src/test/run-pass/task-comm-9.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a27fbac86849e07a0a6c746869d8f78319bd3a16/src%2Ftest%2Frun-pass%2Ftask-comm-9.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a27fbac86849e07a0a6c746869d8f78319bd3a16/src%2Ftest%2Frun-pass%2Ftask-comm-9.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-9.rs?ref=a27fbac86849e07a0a6c746869d8f78319bd3a16", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::task;\n+use std::thread::Thread;\n \n pub fn main() { test00(); }\n \n@@ -23,7 +23,7 @@ fn test00() {\n     let (tx, rx) = channel();\n     let number_of_messages: int = 10;\n \n-    let result = task::try_future(move|| {\n+    let result = Thread::spawn(move|| {\n         test00_start(&tx, number_of_messages);\n     });\n \n@@ -34,7 +34,7 @@ fn test00() {\n         i += 1;\n     }\n \n-    result.unwrap();\n+    result.join();\n \n     assert_eq!(sum, number_of_messages * (number_of_messages - 1) / 2);\n }"}, {"sha": "ddeffcdf722048f2dd8405bfa19123988fa9e569", "filename": "src/test/run-pass/task-stderr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a27fbac86849e07a0a6c746869d8f78319bd3a16/src%2Ftest%2Frun-pass%2Ftask-stderr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a27fbac86849e07a0a6c746869d8f78319bd3a16/src%2Ftest%2Frun-pass%2Ftask-stderr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-stderr.rs?ref=a27fbac86849e07a0a6c746869d8f78319bd3a16", "patch": "@@ -16,7 +16,7 @@ fn main() {\n     let mut reader = ChanReader::new(rx);\n     let stderr = ChanWriter::new(tx);\n \n-    let res = thread::cfg().stderr(box stderr as Box<Writer + Send>).with_join(move|| -> () {\n+    let res = thread::Builder::new().stderr(box stderr as Box<Writer + Send>).spawn(move|| -> () {\n         panic!(\"Hello, world!\")\n     }).join();\n     assert!(res.is_err());"}, {"sha": "b3391669d35d0dd2fec04a2e1a04d7c01b60e74e", "filename": "src/test/run-pass/tcp-stress.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a27fbac86849e07a0a6c746869d8f78319bd3a16/src%2Ftest%2Frun-pass%2Ftcp-stress.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a27fbac86849e07a0a6c746869d8f78319bd3a16/src%2Ftest%2Frun-pass%2Ftcp-stress.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftcp-stress.rs?ref=a27fbac86849e07a0a6c746869d8f78319bd3a16", "patch": "@@ -19,7 +19,7 @@ extern crate libc;\n \n use std::io::net::tcp::{TcpListener, TcpStream};\n use std::io::{Acceptor, Listener};\n-use std::task::TaskBuilder;\n+use std::thread::Builder;\n use std::time::Duration;\n \n fn main() {\n@@ -53,7 +53,7 @@ fn main() {\n     let (tx, rx) = channel();\n     for _ in range(0u, 1000) {\n         let tx = tx.clone();\n-        TaskBuilder::new().stack_size(64 * 1024).spawn(move|| {\n+        Builder::new().stack_size(64 * 1024).spawn(move|| {\n             match TcpStream::connect(addr) {\n                 Ok(stream) => {\n                     let mut stream = stream;\n@@ -64,7 +64,7 @@ fn main() {\n                 Err(e) => debug!(\"{}\", e)\n             }\n             tx.send(());\n-        });\n+        }).detach();\n     }\n \n     // Wait for all clients to exit, but don't wait for the server to exit. The"}, {"sha": "f48272366e2fdbeb047290d7ae6bcb9c7ed19024", "filename": "src/test/run-pass/writealias.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a27fbac86849e07a0a6c746869d8f78319bd3a16/src%2Ftest%2Frun-pass%2Fwritealias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a27fbac86849e07a0a6c746869d8f78319bd3a16/src%2Ftest%2Frun-pass%2Fwritealias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fwritealias.rs?ref=a27fbac86849e07a0a6c746869d8f78319bd3a16", "patch": "@@ -8,15 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::rt::exclusive;\n+use std::sync::Mutex;\n \n struct Point {x: int, y: int, z: int}\n \n fn f(p: &mut Point) { p.z = 13; }\n \n pub fn main() {\n     unsafe {\n-        let x = Some(exclusive::Exclusive::new(true));\n+        let x = Some(Mutex::new(true));\n         match x {\n             Some(ref z) if *z.lock() => {\n                 assert!(*z.lock());"}, {"sha": "9a96b483f2c92d3b3dec452fba69bfc9cff085ea", "filename": "src/test/run-pass/yield.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a27fbac86849e07a0a6c746869d8f78319bd3a16/src%2Ftest%2Frun-pass%2Fyield.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a27fbac86849e07a0a6c746869d8f78319bd3a16/src%2Ftest%2Frun-pass%2Fyield.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fyield.rs?ref=a27fbac86849e07a0a6c746869d8f78319bd3a16", "patch": "@@ -8,18 +8,18 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::task;\n+use std::thread::Thread;\n \n pub fn main() {\n-    let mut result = task::try_future(child);\n+    let mut result = Thread::spawn(child);\n     println!(\"1\");\n-    task::deschedule();\n+    Thread::yield_now();\n     println!(\"2\");\n-    task::deschedule();\n+    Thread::yield_now();\n     println!(\"3\");\n-    result.unwrap();\n+    result.join();\n }\n \n fn child() {\n-    println!(\"4\"); task::deschedule(); println!(\"5\"); task::deschedule(); println!(\"6\");\n+    println!(\"4\"); Thread::yield_now(); println!(\"5\"); Thread::yield_now(); println!(\"6\");\n }"}, {"sha": "13119e5d909cd26b5e05e8b633e3e403bd668a93", "filename": "src/test/run-pass/yield1.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a27fbac86849e07a0a6c746869d8f78319bd3a16/src%2Ftest%2Frun-pass%2Fyield1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a27fbac86849e07a0a6c746869d8f78319bd3a16/src%2Ftest%2Frun-pass%2Fyield1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fyield1.rs?ref=a27fbac86849e07a0a6c746869d8f78319bd3a16", "patch": "@@ -8,13 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::task;\n+use std::thread::Thread;\n \n pub fn main() {\n-    let mut result = task::try_future(child);\n+    let mut result = Thread::spawn(child);\n     println!(\"1\");\n-    task::deschedule();\n-    result.unwrap();\n+    Thread::yield_now();\n+    result.join();\n }\n \n fn child() { println!(\"2\"); }"}]}