{"sha": "d3b2e1fb9ed93575c9780e63f29a28d478b36c2b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQzYjJlMWZiOWVkOTM1NzVjOTc4MGU2M2YyOWEyOGQ0NzhiMzZjMmI=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-04-29T12:02:41Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-05-10T09:48:41Z"}, "message": "fmt", "tree": {"sha": "f4603914926b40d4c8ba37232274c49b1a20b727", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f4603914926b40d4c8ba37232274c49b1a20b727"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d3b2e1fb9ed93575c9780e63f29a28d478b36c2b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d3b2e1fb9ed93575c9780e63f29a28d478b36c2b", "html_url": "https://github.com/rust-lang/rust/commit/d3b2e1fb9ed93575c9780e63f29a28d478b36c2b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d3b2e1fb9ed93575c9780e63f29a28d478b36c2b/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ff39457364659e485991fdb0f145858ff2fb016f", "url": "https://api.github.com/repos/rust-lang/rust/commits/ff39457364659e485991fdb0f145858ff2fb016f", "html_url": "https://github.com/rust-lang/rust/commit/ff39457364659e485991fdb0f145858ff2fb016f"}], "stats": {"total": 43, "additions": 16, "deletions": 27}, "files": [{"sha": "8ce2cabed5dd2ee24e14d8ff76979691b829fd31", "filename": "src/librustc_mir/interpret/intern.rs", "status": "modified", "additions": 16, "deletions": 27, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/d3b2e1fb9ed93575c9780e63f29a28d478b36c2b/src%2Flibrustc_mir%2Finterpret%2Fintern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3b2e1fb9ed93575c9780e63f29a28d478b36c2b/src%2Flibrustc_mir%2Finterpret%2Fintern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintern.rs?ref=d3b2e1fb9ed93575c9780e63f29a28d478b36c2b", "patch": "@@ -146,13 +146,7 @@ impl<'rt, 'mir, 'tcx, M: CompileTimeMachine<'mir, 'tcx>> InternVisitor<'rt, 'mir\n         mode: InternMode,\n         ty: Option<Ty<'tcx>>,\n     ) -> Option<IsStaticOrFn> {\n-        intern_shallow(\n-            self.ecx,\n-            self.leftover_allocations,\n-            alloc_id,\n-            mode,\n-            ty,\n-        )\n+        intern_shallow(self.ecx, self.leftover_allocations, alloc_id, mode, ty)\n     }\n }\n \n@@ -216,10 +210,8 @@ impl<'rt, 'mir, 'tcx: 'mir, M: CompileTimeMachine<'mir, 'tcx>> ValueVisitor<'mir\n                     self.intern_shallow(vtable.alloc_id, InternMode::ConstInner, None);\n                 } else {\n                     // Let validation show the error message, but make sure it *does* error.\n-                    tcx.sess.delay_span_bug(\n-                        tcx.span,\n-                        \"vtables pointers cannot be integer pointers\",\n-                    );\n+                    tcx.sess\n+                        .delay_span_bug(tcx.span, \"vtables pointers cannot be integer pointers\");\n                 }\n             }\n             // Check if we have encountered this pointer+layout combination before.\n@@ -264,7 +256,8 @@ impl<'rt, 'mir, 'tcx: 'mir, M: CompileTimeMachine<'mir, 'tcx>> ValueVisitor<'mir\n                                 ty::Array(_, n)\n                                     if n.eval_usize(tcx.tcx, self.ecx.param_env) == 0 => {}\n                                 ty::Slice(_)\n-                                    if mplace.meta.unwrap_meta().to_machine_usize(self.ecx)? == 0 => {}\n+                                    if mplace.meta.unwrap_meta().to_machine_usize(self.ecx)?\n+                                        == 0 => {}\n                                 _ => mutable_memory_in_const(tcx, \"`&mut`\"),\n                             }\n                         } else {\n@@ -315,16 +308,16 @@ pub fn intern_const_alloc_recursive<M: CompileTimeMachine<'mir, 'tcx>>(\n     intern_kind: InternKind,\n     ret: MPlaceTy<'tcx>,\n     ignore_interior_mut_in_const: bool,\n-)\n-where\n+) where\n     'tcx: 'mir,\n {\n     let tcx = ecx.tcx;\n     let base_intern_mode = match intern_kind {\n         InternKind::Static(mutbl) => InternMode::Static(mutbl),\n         // FIXME: what about array lengths, array initializers?\n-        InternKind::Constant | InternKind::ConstProp | InternKind::Promoted =>\n-            InternMode::ConstBase,\n+        InternKind::Constant | InternKind::ConstProp | InternKind::Promoted => {\n+            InternMode::ConstBase\n+        }\n     };\n \n     // Type based interning.\n@@ -362,7 +355,7 @@ where\n         // references are \"leftover\"-interned, and later validation will show a proper error\n         // and point at the right part of the value causing the problem.\n         match res {\n-            Ok(()) => {},\n+            Ok(()) => {}\n             Err(error) => {\n                 ecx.tcx.sess.delay_span_bug(\n                     ecx.tcx.span,\n@@ -412,10 +405,9 @@ where\n                     // is tracked by const-checking.\n                     // FIXME: downgrade this to a warning? It rejects some legitimate consts,\n                     // such as `const CONST_RAW: *const Vec<i32> = &Vec::new() as *const _;`.\n-                    ecx.tcx.sess.span_err(\n-                        ecx.tcx.span,\n-                        \"untyped pointers are not allowed in constant\",\n-                    );\n+                    ecx.tcx\n+                        .sess\n+                        .span_err(ecx.tcx.span, \"untyped pointers are not allowed in constant\");\n                     // For better errors later, mark the allocation as immutable.\n                     alloc.mutability = Mutability::Not;\n                 }\n@@ -430,13 +422,10 @@ where\n         } else if ecx.memory.dead_alloc_map.contains_key(&alloc_id) {\n             // Codegen does not like dangling pointers, and generally `tcx` assumes that\n             // all allocations referenced anywhere actually exist. So, make sure we error here.\n-            ecx.tcx.sess.span_err(\n-                ecx.tcx.span,\n-                \"encountered dangling pointer in final constant\",\n-            );\n+            ecx.tcx.sess.span_err(ecx.tcx.span, \"encountered dangling pointer in final constant\");\n         } else if ecx.tcx.get_global_alloc(alloc_id).is_none() {\n-                // We have hit an `AllocId` that is neither in local or global memory and isn't\n-                // marked as dangling by local memory.  That should be impossible.\n+            // We have hit an `AllocId` that is neither in local or global memory and isn't\n+            // marked as dangling by local memory.  That should be impossible.\n             span_bug!(ecx.tcx.span, \"encountered unknown alloc id {:?}\", alloc_id);\n         }\n     }"}]}