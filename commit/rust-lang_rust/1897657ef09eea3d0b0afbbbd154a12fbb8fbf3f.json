{"sha": "1897657ef09eea3d0b0afbbbd154a12fbb8fbf3f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE4OTc2NTdlZjA5ZWVhM2QwYjBhZmJiYmQxNTRhMTJmYmI4ZmJmM2Y=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-12-14T16:15:20Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-12-14T16:15:20Z"}, "message": "Auto merge of #56818 - kennytm:rollup-2, r=kennytm\n\nRollup of 14 pull requests (first batch)\n\nSuccessful merges:\n\n - #56562 (Update libc version required by rustc)\n - #56609 (Unconditionally emit the target-cpu LLVM attribute.)\n - #56637 (rustdoc: Fix local reexports of proc macros)\n - #56658 (Add non-panicking `maybe_new_parser_from_file` variant)\n - #56695 (Fix irrefutable matches on integer ranges)\n - #56699 (Use a `newtype_index!` within `Symbol`.)\n - #56702 ([self-profiler] Add column for percent of total time)\n - #56708 (Remove some unnecessary feature gates)\n - #56709 (Remove unneeded extra chars to reduce search-index size)\n - #56744 (specialize: remove Boxes used by Children::insert)\n - #56748 (Update panic message to be clearer about env-vars)\n - #56749 (x86: Add the `adx` target feature to whitelist)\n - #56756 (Disable btree pretty-printers on older gdbs)\n - #56789 (rustc: Add an unstable `simd_select_bitmask` intrinsic)\n\nr? @ghost", "tree": {"sha": "617ccab3713b1745724294eca3a33ad0642b6244", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/617ccab3713b1745724294eca3a33ad0642b6244"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1897657ef09eea3d0b0afbbbd154a12fbb8fbf3f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1897657ef09eea3d0b0afbbbd154a12fbb8fbf3f", "html_url": "https://github.com/rust-lang/rust/commit/1897657ef09eea3d0b0afbbbd154a12fbb8fbf3f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1897657ef09eea3d0b0afbbbd154a12fbb8fbf3f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7d03617bab24a689bc704e71e509b9c11c655f26", "url": "https://api.github.com/repos/rust-lang/rust/commits/7d03617bab24a689bc704e71e509b9c11c655f26", "html_url": "https://github.com/rust-lang/rust/commit/7d03617bab24a689bc704e71e509b9c11c655f26"}, {"sha": "e065de2ea88430c55b824f5f280c965e1230762b", "url": "https://api.github.com/repos/rust-lang/rust/commits/e065de2ea88430c55b824f5f280c965e1230762b", "html_url": "https://github.com/rust-lang/rust/commit/e065de2ea88430c55b824f5f280c965e1230762b"}], "stats": {"total": 435, "additions": 335, "deletions": 100}, "files": [{"sha": "f02c7d87590acdbc1d3818c023d71ff80820e64c", "filename": "src/etc/gdb_rust_pretty_printing.py", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/1897657ef09eea3d0b0afbbbd154a12fbb8fbf3f/src%2Fetc%2Fgdb_rust_pretty_printing.py", "raw_url": "https://github.com/rust-lang/rust/raw/1897657ef09eea3d0b0afbbbd154a12fbb8fbf3f/src%2Fetc%2Fgdb_rust_pretty_printing.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fgdb_rust_pretty_printing.py?ref=1897657ef09eea3d0b0afbbbd154a12fbb8fbf3f", "patch": "@@ -9,6 +9,7 @@\n # except according to those terms.\n \n import gdb\n+import re\n import sys\n import debugger_pretty_printers_common as rustpp\n \n@@ -20,6 +21,16 @@\n \n rust_enabled = 'set language rust' in gdb.execute('complete set language ru', to_string = True)\n \n+# The btree pretty-printers fail in a confusing way unless\n+# https://sourceware.org/bugzilla/show_bug.cgi?id=21763 is fixed.\n+# This fix went in 8.1, so check for that.\n+# See https://github.com/rust-lang/rust/issues/56730\n+gdb_81 = False\n+_match = re.match('([0-9]+)\\\\.([0-9]+)', gdb.VERSION)\n+if _match:\n+    if int(_match.group(1)) > 8 or (int(_match.group(1)) == 8 and int(_match.group(2)) >= 1):\n+        gdb_81 = True\n+\n #===============================================================================\n # GDB Pretty Printing Module for Rust\n #===============================================================================\n@@ -110,10 +121,10 @@ def rust_pretty_printer_lookup_function(gdb_val):\n     if type_kind == rustpp.TYPE_KIND_STD_VECDEQUE:\n         return RustStdVecDequePrinter(val)\n \n-    if type_kind == rustpp.TYPE_KIND_STD_BTREESET:\n+    if type_kind == rustpp.TYPE_KIND_STD_BTREESET and gdb_81:\n         return RustStdBTreeSetPrinter(val)\n \n-    if type_kind == rustpp.TYPE_KIND_STD_BTREEMAP:\n+    if type_kind == rustpp.TYPE_KIND_STD_BTREEMAP and gdb_81:\n         return RustStdBTreeMapPrinter(val)\n \n     if type_kind == rustpp.TYPE_KIND_STD_STRING:"}, {"sha": "b0ca2f6cecc0b9d8355e3f2d28f843c1753c61ca", "filename": "src/librustc/traits/specialize/specialization_graph.rs", "status": "modified", "additions": 33, "deletions": 8, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/1897657ef09eea3d0b0afbbbd154a12fbb8fbf3f/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1897657ef09eea3d0b0afbbbd154a12fbb8fbf3f/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs?ref=1897657ef09eea3d0b0afbbbd154a12fbb8fbf3f", "patch": "@@ -132,10 +132,12 @@ impl<'a, 'gcx, 'tcx> Children {\n             simplified_self,\n         );\n \n-        for possible_sibling in match simplified_self {\n-            Some(sty) => self.filtered(sty),\n-            None => self.iter(),\n-        } {\n+        let possible_siblings = match simplified_self {\n+            Some(sty) => PotentialSiblings::Filtered(self.filtered(sty)),\n+            None => PotentialSiblings::Unfiltered(self.iter()),\n+        };\n+\n+        for possible_sibling in possible_siblings {\n             debug!(\n                 \"insert: impl_def_id={:?}, simplified_self={:?}, possible_sibling={:?}\",\n                 impl_def_id,\n@@ -222,14 +224,37 @@ impl<'a, 'gcx, 'tcx> Children {\n         Ok(Inserted::BecameNewSibling(last_lint))\n     }\n \n-    fn iter(&mut self) -> Box<dyn Iterator<Item = DefId> + '_> {\n+    fn iter(&mut self) -> impl Iterator<Item = DefId> + '_ {\n         let nonblanket = self.nonblanket_impls.iter_mut().flat_map(|(_, v)| v.iter());\n-        Box::new(self.blanket_impls.iter().chain(nonblanket).cloned())\n+        self.blanket_impls.iter().chain(nonblanket).cloned()\n     }\n \n-    fn filtered(&mut self, sty: SimplifiedType) -> Box<dyn Iterator<Item = DefId> + '_> {\n+    fn filtered(&mut self, sty: SimplifiedType) -> impl Iterator<Item = DefId> + '_ {\n         let nonblanket = self.nonblanket_impls.entry(sty).or_default().iter();\n-        Box::new(self.blanket_impls.iter().chain(nonblanket).cloned())\n+        self.blanket_impls.iter().chain(nonblanket).cloned()\n+    }\n+}\n+\n+// A custom iterator used by Children::insert\n+enum PotentialSiblings<I, J>\n+    where I: Iterator<Item = DefId>,\n+          J: Iterator<Item = DefId>\n+{\n+    Unfiltered(I),\n+    Filtered(J)\n+}\n+\n+impl<I, J> Iterator for PotentialSiblings<I, J>\n+    where I: Iterator<Item = DefId>,\n+          J: Iterator<Item = DefId>\n+{\n+    type Item = DefId;\n+\n+    fn next(&mut self) -> Option<Self::Item> {\n+        match *self {\n+            PotentialSiblings::Unfiltered(ref mut iter) => iter.next(),\n+            PotentialSiblings::Filtered(ref mut iter) => iter.next()\n+        }\n     }\n }\n "}, {"sha": "c2bfa62cf9d068737c6a5ea694fdb40778cc1d6a", "filename": "src/librustc/util/profiling.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/1897657ef09eea3d0b0afbbbd154a12fbb8fbf3f/src%2Flibrustc%2Futil%2Fprofiling.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1897657ef09eea3d0b0afbbbd154a12fbb8fbf3f/src%2Flibrustc%2Futil%2Fprofiling.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fprofiling.rs?ref=1897657ef09eea3d0b0afbbbd154a12fbb8fbf3f", "patch": "@@ -62,11 +62,15 @@ macro_rules! define_categories {\n             }\n \n             fn print(&self, lock: &mut StderrLock<'_>) {\n-                writeln!(lock, \"| Phase            | Time (ms)      | Queries        | Hits (%) |\")\n+                writeln!(lock, \"| Phase            | Time (ms)      \\\n+                                | Time (%) | Queries        | Hits (%)\")\n                     .unwrap();\n-                writeln!(lock, \"| ---------------- | -------------- | -------------- | -------- |\")\n+                writeln!(lock, \"| ---------------- | -------------- \\\n+                                | -------- | -------------- | --------\")\n                     .unwrap();\n \n+                let total_time = ($(self.times.$name + )* 0) as f32;\n+\n                 $(\n                     let (hits, total) = self.query_counts.$name;\n                     let (hits, total) = if total > 0 {\n@@ -78,11 +82,12 @@ macro_rules! define_categories {\n \n                     writeln!(\n                         lock,\n-                        \"| {0: <16} | {1: <14} | {2: <14} | {3: <8} |\",\n+                        \"| {0: <16} | {1: <14} | {2: <8.2} | {3: <14} | {4: <8}\",\n                         stringify!($name),\n                         self.times.$name / 1_000_000,\n+                        ((self.times.$name as f32) / total_time) * 100.0,\n                         total,\n-                        hits\n+                        hits,\n                     ).unwrap();\n                 )*\n             }"}, {"sha": "48e0a3a12c963ced9a96469b8cca8c694c3fb4da", "filename": "src/librustc_codegen_llvm/attributes.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1897657ef09eea3d0b0afbbbd154a12fbb8fbf3f/src%2Flibrustc_codegen_llvm%2Fattributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1897657ef09eea3d0b0afbbbd154a12fbb8fbf3f/src%2Flibrustc_codegen_llvm%2Fattributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fattributes.rs?ref=1897657ef09eea3d0b0afbbbd154a12fbb8fbf3f", "patch": "@@ -18,6 +18,7 @@ use rustc::session::config::Sanitizer;\n use rustc::ty::{self, TyCtxt, PolyFnSig};\n use rustc::ty::layout::HasTyCtxt;\n use rustc::ty::query::Providers;\n+use rustc_data_structures::small_c_str::SmallCStr;\n use rustc_data_structures::sync::Lrc;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_target::spec::PanicStrategy;\n@@ -130,8 +131,7 @@ pub fn llvm_target_features(sess: &Session) -> impl Iterator<Item = &str> {\n }\n \n pub fn apply_target_cpu_attr(cx: &CodegenCx<'ll, '_>, llfn: &'ll Value) {\n-    let cpu = llvm_util::target_cpu(cx.tcx.sess);\n-    let target_cpu = CString::new(cpu).unwrap();\n+    let target_cpu = SmallCStr::new(llvm_util::target_cpu(cx.tcx.sess));\n     llvm::AddFunctionAttrStringValue(\n             llfn,\n             llvm::AttributePlace::Function,\n@@ -231,11 +231,7 @@ pub fn from_fn_attrs(\n     // Always annotate functions with the target-cpu they are compiled for.\n     // Without this, ThinLTO won't inline Rust functions into Clang generated\n     // functions (because Clang annotates functions this way too).\n-    // NOTE: For now we just apply this if -Zcross-lang-lto is specified, since\n-    //       it introduce a little overhead and isn't really necessary otherwise.\n-    if cx.tcx.sess.opts.debugging_opts.cross_lang_lto.enabled() {\n-        apply_target_cpu_attr(cx, llfn);\n-    }\n+    apply_target_cpu_attr(cx, llfn);\n \n     let features = llvm_target_features(cx.tcx.sess)\n         .map(|s| s.to_string())"}, {"sha": "8b26ada1576063db231af8f977c05bb6b89447a3", "filename": "src/librustc_codegen_llvm/intrinsic.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/1897657ef09eea3d0b0afbbbd154a12fbb8fbf3f/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1897657ef09eea3d0b0afbbbd154a12fbb8fbf3f/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs?ref=1897657ef09eea3d0b0afbbbd154a12fbb8fbf3f", "patch": "@@ -1171,6 +1171,27 @@ fn generic_simd_intrinsic(\n     );\n     let arg_tys = sig.inputs();\n \n+    if name == \"simd_select_bitmask\" {\n+        let in_ty = arg_tys[0];\n+        let m_len = match in_ty.sty {\n+            // Note that this `.unwrap()` crashes for isize/usize, that's sort\n+            // of intentional as there's not currently a use case for that.\n+            ty::Int(i) => i.bit_width().unwrap(),\n+            ty::Uint(i) => i.bit_width().unwrap(),\n+            _ => return_error!(\"`{}` is not an integral type\", in_ty),\n+        };\n+        require_simd!(arg_tys[1], \"argument\");\n+        let v_len = arg_tys[1].simd_size(tcx);\n+        require!(m_len == v_len,\n+                 \"mismatched lengths: mask length `{}` != other vector length `{}`\",\n+                 m_len, v_len\n+        );\n+        let i1 = bx.type_i1();\n+        let i1xn = bx.type_vector(i1, m_len as u64);\n+        let m_i1s = bx.bitcast(args[0].immediate(), i1xn);\n+        return Ok(bx.select(m_i1s, args[1].immediate(), args[2].immediate()));\n+    }\n+\n     // every intrinsic takes a SIMD vector as its first argument\n     require_simd!(arg_tys[0], \"input\");\n     let in_ty = arg_tys[0];"}, {"sha": "12109ae1662ff5364b8fe79de6f0e9f3c16fb507", "filename": "src/librustc_codegen_llvm/llvm_util.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1897657ef09eea3d0b0afbbbd154a12fbb8fbf3f/src%2Flibrustc_codegen_llvm%2Fllvm_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1897657ef09eea3d0b0afbbbd154a12fbb8fbf3f/src%2Flibrustc_codegen_llvm%2Fllvm_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fllvm_util.rs?ref=1897657ef09eea3d0b0afbbbd154a12fbb8fbf3f", "patch": "@@ -124,6 +124,7 @@ const AARCH64_WHITELIST: &[(&str, Option<&str>)] = &[\n ];\n \n const X86_WHITELIST: &[(&str, Option<&str>)] = &[\n+    (\"adx\", Some(\"adx_target_feature\")),\n     (\"aes\", None),\n     (\"avx\", None),\n     (\"avx2\", None),"}, {"sha": "50994497c2843e62b32bbf3475e1f1702687773e", "filename": "src/librustc_codegen_ssa/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1897657ef09eea3d0b0afbbbd154a12fbb8fbf3f/src%2Flibrustc_codegen_ssa%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/1897657ef09eea3d0b0afbbbd154a12fbb8fbf3f/src%2Flibrustc_codegen_ssa%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2FCargo.toml?ref=1897657ef09eea3d0b0afbbbd154a12fbb8fbf3f", "patch": "@@ -16,7 +16,7 @@ num_cpus = \"1.0\"\n rustc-demangle = \"0.1.4\"\n memmap = \"0.6\"\n log = \"0.4.5\"\n-libc = \"0.2.43\"\n+libc = \"0.2.44\"\n jobserver = \"0.1.11\"\n \n serialize = { path = \"../libserialize\" }"}, {"sha": "328b330f762dc14135cb9c4aad51f402f672fbcf", "filename": "src/librustc_mir/build/matches/simplify.rs", "status": "modified", "additions": 33, "deletions": 1, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/1897657ef09eea3d0b0afbbbd154a12fbb8fbf3f/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1897657ef09eea3d0b0afbbbd154a12fbb8fbf3f/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fsimplify.rs?ref=1897657ef09eea3d0b0afbbbd154a12fbb8fbf3f", "patch": "@@ -26,6 +26,10 @@ use build::{BlockAnd, BlockAndExtension, Builder};\n use build::matches::{Ascription, Binding, MatchPair, Candidate};\n use hair::*;\n use rustc::mir::*;\n+use rustc::ty;\n+use rustc::ty::layout::{Integer, IntegerExt, Size};\n+use syntax::attr::{SignedInt, UnsignedInt};\n+use rustc::hir::RangeEnd;\n \n use std::mem;\n \n@@ -62,6 +66,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                                  match_pair: MatchPair<'pat, 'tcx>,\n                                  candidate: &mut Candidate<'pat, 'tcx>)\n                                  -> Result<(), MatchPair<'pat, 'tcx>> {\n+        let tcx = self.hir.tcx();\n         match *match_pair.pattern.kind {\n             PatternKind::AscribeUserType { ref subpattern, ref user_ty, user_ty_span } => {\n                 candidate.ascriptions.push(Ascription {\n@@ -104,7 +109,34 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 Err(match_pair)\n             }\n \n-            PatternKind::Range { .. } => {\n+            PatternKind::Range { lo, hi, ty, end } => {\n+                let range = match ty.sty {\n+                    ty::Char => {\n+                        Some(('\\u{0000}' as u128, '\\u{10FFFF}' as u128, Size::from_bits(32)))\n+                    }\n+                    ty::Int(ity) => {\n+                        // FIXME(49937): refactor these bit manipulations into interpret.\n+                        let size = Integer::from_attr(&tcx, SignedInt(ity)).size();\n+                        let min = 1u128 << (size.bits() - 1);\n+                        let max = (1u128 << (size.bits() - 1)) - 1;\n+                        Some((min, max, size))\n+                    }\n+                    ty::Uint(uty) => {\n+                        // FIXME(49937): refactor these bit manipulations into interpret.\n+                        let size = Integer::from_attr(&tcx, UnsignedInt(uty)).size();\n+                        let max = !0u128 >> (128 - size.bits());\n+                        Some((0, max, size))\n+                    }\n+                    _ => None,\n+                };\n+                if let Some((min, max, sz)) = range {\n+                    if let (Some(lo), Some(hi)) = (lo.val.try_to_bits(sz), hi.val.try_to_bits(sz)) {\n+                        if lo <= min && (hi > max || hi == max && end == RangeEnd::Included) {\n+                            // Irrefutable pattern match.\n+                            return Ok(());\n+                        }\n+                    }\n+                }\n                 Err(match_pair)\n             }\n "}, {"sha": "a40e56d68ae8b28f6614be69a3c106ea86653896", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1897657ef09eea3d0b0afbbbd154a12fbb8fbf3f/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1897657ef09eea3d0b0afbbbd154a12fbb8fbf3f/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=1897657ef09eea3d0b0afbbbd154a12fbb8fbf3f", "patch": "@@ -435,7 +435,8 @@ pub fn check_platform_intrinsic_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         \"simd_insert\" => (2, vec![param(0), tcx.types.u32, param(1)], param(0)),\n         \"simd_extract\" => (2, vec![param(0), tcx.types.u32], param(1)),\n         \"simd_cast\" => (2, vec![param(0)], param(1)),\n-        \"simd_select\" => (2, vec![param(0), param(1), param(1)], param(1)),\n+        \"simd_select\" |\n+        \"simd_select_bitmask\" => (2, vec![param(0), param(1), param(1)], param(1)),\n         \"simd_reduce_all\" | \"simd_reduce_any\" => (1, vec![param(0)], tcx.types.bool),\n         \"simd_reduce_add_ordered\" | \"simd_reduce_mul_ordered\"\n             => (2, vec![param(0), param(1)], param(1)),"}, {"sha": "536ea39d29805818278ff9f57729442300ce308c", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/1897657ef09eea3d0b0afbbbd154a12fbb8fbf3f/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1897657ef09eea3d0b0afbbbd154a12fbb8fbf3f/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=1897657ef09eea3d0b0afbbbd154a12fbb8fbf3f", "patch": "@@ -806,6 +806,10 @@ impl<'a> fmt::Display for MarkdownSummaryLine<'a> {\n }\n \n pub fn plain_summary_line(md: &str) -> String {\n+    plain_summary_line_full(md, false)\n+}\n+\n+pub fn plain_summary_line_full(md: &str, limit_length: bool) -> String {\n     struct ParserWrapper<'a> {\n         inner: Parser<'a>,\n         is_in: isize,\n@@ -852,7 +856,21 @@ pub fn plain_summary_line(md: &str) -> String {\n             s.push_str(&t);\n         }\n     }\n-    s\n+    if limit_length && s.chars().count() > 60 {\n+        let mut len = 0;\n+        let mut ret = s.split_whitespace()\n+                       .take_while(|p| {\n+                           // + 1 for the added character after the word.\n+                           len += p.chars().count() + 1;\n+                           len < 60\n+                       })\n+                       .collect::<Vec<_>>()\n+                       .join(\" \");\n+        ret.push('\u2026');\n+        ret\n+    } else {\n+        s\n+    }\n }\n \n pub fn markdown_links(md: &str) -> Vec<(String, Option<Range<usize>>)> {"}, {"sha": "4b10c23fd3f3f219bbed58a7e673b10486adb808", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/1897657ef09eea3d0b0afbbbd154a12fbb8fbf3f/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1897657ef09eea3d0b0afbbbd154a12fbb8fbf3f/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=1897657ef09eea3d0b0afbbbd154a12fbb8fbf3f", "patch": "@@ -698,7 +698,7 @@ fn build_index(krate: &clean::Crate, cache: &mut Cache) -> String {\n                 ty: item.type_(),\n                 name: item.name.clone().unwrap(),\n                 path: fqp[..fqp.len() - 1].join(\"::\"),\n-                desc: plain_summary_line(item.doc_value()),\n+                desc: plain_summary_line_short(item.doc_value()),\n                 parent: Some(did),\n                 parent_idx: None,\n                 search_type: get_index_search_type(&item),\n@@ -736,7 +736,7 @@ fn build_index(krate: &clean::Crate, cache: &mut Cache) -> String {\n     }\n \n     let crate_doc = krate.module.as_ref().map(|module| {\n-        plain_summary_line(module.doc_value())\n+        plain_summary_line_short(module.doc_value())\n     }).unwrap_or(String::new());\n \n     let mut crate_data = BTreeMap::new();\n@@ -1481,7 +1481,7 @@ impl DocFolder for Cache {\n                             ty: item.type_(),\n                             name: s.to_string(),\n                             path: path.join(\"::\"),\n-                            desc: plain_summary_line(item.doc_value()),\n+                            desc: plain_summary_line_short(item.doc_value()),\n                             parent,\n                             parent_idx: None,\n                             search_type: get_index_search_type(&item),\n@@ -1512,7 +1512,8 @@ impl DocFolder for Cache {\n             clean::FunctionItem(..) | clean::ModuleItem(..) |\n             clean::ForeignFunctionItem(..) | clean::ForeignStaticItem(..) |\n             clean::ConstantItem(..) | clean::StaticItem(..) |\n-            clean::UnionItem(..) | clean::ForeignTypeItem | clean::MacroItem(..)\n+            clean::UnionItem(..) | clean::ForeignTypeItem |\n+            clean::MacroItem(..) | clean::ProcMacroItem(..)\n             if !self.stripped_mod => {\n                 // Re-exported items mean that the same id can show up twice\n                 // in the rustdoc ast that we're looking at. We know,\n@@ -1673,7 +1674,7 @@ impl<'a> Cache {\n                                 ty: item.type_(),\n                                 name: item_name.to_string(),\n                                 path: path.clone(),\n-                                desc: plain_summary_line(item.doc_value()),\n+                                desc: plain_summary_line_short(item.doc_value()),\n                                 parent: None,\n                                 parent_idx: None,\n                                 search_type: get_index_search_type(&item),\n@@ -2388,7 +2389,13 @@ fn shorter<'a>(s: Option<&'a str>) -> String {\n #[inline]\n fn plain_summary_line(s: Option<&str>) -> String {\n     let line = shorter(s).replace(\"\\n\", \" \");\n-    markdown::plain_summary_line(&line[..])\n+    markdown::plain_summary_line_full(&line[..], false)\n+}\n+\n+#[inline]\n+fn plain_summary_line_short(s: Option<&str>) -> String {\n+    let line = shorter(s).replace(\"\\n\", \" \");\n+    markdown::plain_summary_line_full(&line[..], true)\n }\n \n fn document(w: &mut fmt::Formatter, cx: &Context, item: &clean::Item) -> fmt::Result {"}, {"sha": "287984cc5fac59c53c8c201bce0d3ab0fdec3da3", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1897657ef09eea3d0b0afbbbd154a12fbb8fbf3f/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1897657ef09eea3d0b0afbbbd154a12fbb8fbf3f/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=1897657ef09eea3d0b0afbbbd154a12fbb8fbf3f", "patch": "@@ -424,10 +424,11 @@ impl<'a, 'tcx, 'rcx, 'cstore> RustdocVisitor<'a, 'tcx, 'rcx, 'cstore> {\n             hir::ItemKind::Use(ref path, kind) => {\n                 let is_glob = kind == hir::UseKind::Glob;\n \n-                // Struct and variant constructors always show up alongside their definitions, we've\n-                // already processed them so just discard these.\n+                // Struct and variant constructors and proc macro stubs always show up alongside\n+                // their definitions, we've already processed them so just discard these.\n                 match path.def {\n-                    Def::StructCtor(..) | Def::VariantCtor(..) | Def::SelfCtor(..) => return,\n+                    Def::StructCtor(..) | Def::VariantCtor(..) | Def::SelfCtor(..) |\n+                    Def::Macro(_, MacroKind::ProcMacroStub) => return,\n                     _ => {}\n                 }\n "}, {"sha": "24965ff69318435e874eaad52f9dc8a1b58edcc3", "filename": "src/libstd/io/lazy.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1897657ef09eea3d0b0afbbbd154a12fbb8fbf3f/src%2Flibstd%2Fio%2Flazy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1897657ef09eea3d0b0afbbbd154a12fbb8fbf3f/src%2Flibstd%2Fio%2Flazy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Flazy.rs?ref=1897657ef09eea3d0b0afbbbd154a12fbb8fbf3f", "patch": "@@ -26,7 +26,6 @@ const fn done<T>() -> *mut Arc<T> { 1_usize as *mut _ }\n unsafe impl<T> Sync for Lazy<T> {}\n \n impl<T> Lazy<T> {\n-    #[unstable(feature = \"sys_internals\", issue = \"0\")] // FIXME: min_const_fn\n     pub const fn new() -> Lazy<T> {\n         Lazy {\n             lock: Mutex::new(),"}, {"sha": "0febbe5694bc4f568e9bdcf671dc0483cdf9c716", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1897657ef09eea3d0b0afbbbd154a12fbb8fbf3f/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1897657ef09eea3d0b0afbbbd154a12fbb8fbf3f/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=1897657ef09eea3d0b0afbbbd154a12fbb8fbf3f", "patch": "@@ -271,6 +271,7 @@\n #![feature(libc)]\n #![feature(link_args)]\n #![feature(linkage)]\n+#![cfg_attr(not(stage0), feature(min_const_unsafe_fn))]\n #![feature(needs_panic_runtime)]\n #![feature(never_type)]\n #![feature(nll)]"}, {"sha": "b6180fbeb506850e6554bf8f1b8d35148516c0a7", "filename": "src/libstd/panicking.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1897657ef09eea3d0b0afbbbd154a12fbb8fbf3f/src%2Flibstd%2Fpanicking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1897657ef09eea3d0b0afbbbd154a12fbb8fbf3f/src%2Flibstd%2Fpanicking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpanicking.rs?ref=1897657ef09eea3d0b0afbbbd154a12fbb8fbf3f", "patch": "@@ -209,7 +209,8 @@ fn default_hook(info: &PanicInfo) {\n             if let Some(format) = log_backtrace {\n                 let _ = backtrace::print(err, format);\n             } else if FIRST_PANIC.compare_and_swap(true, false, Ordering::SeqCst) {\n-                let _ = writeln!(err, \"note: Run with `RUST_BACKTRACE=1` for a backtrace.\");\n+                let _ = writeln!(err, \"note: Run with `RUST_BACKTRACE=1` \\\n+                                       environment variable to display a backtrace.\");\n             }\n         }\n     };"}, {"sha": "bf32c712216bc35ab84f1839a1bf84a30195254f", "filename": "src/libstd/sys/sgx/abi/mem.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1897657ef09eea3d0b0afbbbd154a12fbb8fbf3f/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1897657ef09eea3d0b0afbbbd154a12fbb8fbf3f/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fmem.rs?ref=1897657ef09eea3d0b0afbbbd154a12fbb8fbf3f", "patch": "@@ -34,13 +34,6 @@ fn image_base() -> u64 {\n     base\n }\n \n-pub fn is_enclave_range(p: *const u8, len: usize) -> bool {\n-    let start=p as u64;\n-    let end=start + (len as u64);\n-    start >= image_base() &&\n-        end <= image_base() + (unsafe { ENCLAVE_SIZE } as u64) // unsafe ok: link-time constant\n-}\n-\n pub fn is_user_range(p: *const u8, len: usize) -> bool {\n     let start=p as u64;\n     let end=start + (len as u64);"}, {"sha": "d1d180e48251f90fcae1d1feeee1f957e03c3220", "filename": "src/libstd/sys/sgx/abi/usercalls/mod.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1897657ef09eea3d0b0afbbbd154a12fbb8fbf3f/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1897657ef09eea3d0b0afbbbd154a12fbb8fbf3f/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Fmod.rs?ref=1897657ef09eea3d0b0afbbbd154a12fbb8fbf3f", "patch": "@@ -33,14 +33,6 @@ pub fn read(fd: Fd, buf: &mut [u8]) -> IoResult<usize> {\n     }\n }\n \n-pub fn read_alloc(fd: Fd) -> IoResult<Vec<u8>> {\n-    unsafe {\n-        let mut userbuf = alloc::User::<ByteBuffer>::uninitialized();\n-        raw::read_alloc(fd, userbuf.as_raw_mut_ptr()).from_sgx_result()?;\n-        Ok(copy_user_buffer(&userbuf))\n-    }\n-}\n-\n pub fn write(fd: Fd, buf: &[u8]) -> IoResult<usize> {\n     unsafe {\n         let userbuf = alloc::User::new_from_enclave(buf);"}, {"sha": "940f50f25b81a5e9e3c1b59277a69d4d3d984b28", "filename": "src/libstd/sys/sgx/condvar.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1897657ef09eea3d0b0afbbbd154a12fbb8fbf3f/src%2Flibstd%2Fsys%2Fsgx%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1897657ef09eea3d0b0afbbbd154a12fbb8fbf3f/src%2Flibstd%2Fsys%2Fsgx%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fcondvar.rs?ref=1897657ef09eea3d0b0afbbbd154a12fbb8fbf3f", "patch": "@@ -18,7 +18,6 @@ pub struct Condvar {\n }\n \n impl Condvar {\n-    #[unstable(feature = \"sgx_internals\", issue = \"0\")] // FIXME: min_const_fn\n     pub const fn new() -> Condvar {\n         Condvar { inner: SpinMutex::new(WaitVariable::new(())) }\n     }"}, {"sha": "994cf91eea0cd6e58e06a9ca48fbbbfe3d0046ea", "filename": "src/libstd/sys/sgx/mutex.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1897657ef09eea3d0b0afbbbd154a12fbb8fbf3f/src%2Flibstd%2Fsys%2Fsgx%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1897657ef09eea3d0b0afbbbd154a12fbb8fbf3f/src%2Flibstd%2Fsys%2Fsgx%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fmutex.rs?ref=1897657ef09eea3d0b0afbbbd154a12fbb8fbf3f", "patch": "@@ -20,7 +20,6 @@ pub struct Mutex {\n \n // Implementation according to \u201cOperating Systems: Three Easy Pieces\u201d, chapter 28\n impl Mutex {\n-    #[unstable(feature = \"sgx_internals\", issue = \"0\")] // FIXME: min_const_fn\n     pub const fn new() -> Mutex {\n         Mutex { inner: SpinMutex::new(WaitVariable::new(false)) }\n     }\n@@ -79,7 +78,6 @@ pub struct ReentrantMutex {\n }\n \n impl ReentrantMutex {\n-    #[unstable(feature = \"sgx_internals\", issue = \"0\")] // FIXME: min_const_fn\n     pub const fn uninitialized() -> ReentrantMutex {\n         ReentrantMutex {\n             inner: SpinMutex::new(WaitVariable::new(ReentrantLock { owner: None, count: 0 }))"}, {"sha": "a1551dbb53b2ddb4de0eb5dd5438609811ea9ef4", "filename": "src/libstd/sys/sgx/rwlock.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1897657ef09eea3d0b0afbbbd154a12fbb8fbf3f/src%2Flibstd%2Fsys%2Fsgx%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1897657ef09eea3d0b0afbbbd154a12fbb8fbf3f/src%2Flibstd%2Fsys%2Fsgx%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Frwlock.rs?ref=1897657ef09eea3d0b0afbbbd154a12fbb8fbf3f", "patch": "@@ -21,7 +21,6 @@ pub struct RWLock {\n //unsafe impl Sync for RWLock {} // FIXME\n \n impl RWLock {\n-    #[unstable(feature = \"sgx_internals\", issue = \"0\")] // FIXME: min_const_fn\n     pub const fn new() -> RWLock {\n         RWLock {\n             readers: SpinMutex::new(WaitVariable::new(None)),"}, {"sha": "ef0def13eee882d4e91f5bd2c36b38940bdc6688", "filename": "src/libstd/sys/sgx/waitqueue.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1897657ef09eea3d0b0afbbbd154a12fbb8fbf3f/src%2Flibstd%2Fsys%2Fsgx%2Fwaitqueue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1897657ef09eea3d0b0afbbbd154a12fbb8fbf3f/src%2Flibstd%2Fsys%2Fsgx%2Fwaitqueue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fwaitqueue.rs?ref=1897657ef09eea3d0b0afbbbd154a12fbb8fbf3f", "patch": "@@ -50,7 +50,6 @@ pub struct WaitVariable<T> {\n }\n \n impl<T> WaitVariable<T> {\n-    #[unstable(feature = \"sgx_internals\", issue = \"0\")] // FIXME: min_const_fn\n     pub const fn new(var: T) -> Self {\n         WaitVariable {\n             queue: WaitQueue::new(),\n@@ -137,7 +136,6 @@ impl<'a, T> Drop for WaitGuard<'a, T> {\n }\n \n impl WaitQueue {\n-    #[unstable(feature = \"sgx_internals\", issue = \"0\")] // FIXME: min_const_fn\n     pub const fn new() -> Self {\n         WaitQueue {\n             inner: UnsafeList::new()\n@@ -255,7 +253,6 @@ mod unsafe_list {\n     }\n \n     impl<T> UnsafeList<T> {\n-        #[unstable(feature = \"sgx_internals\", issue = \"0\")] // FIXME: min_const_fn\n         pub const fn new() -> Self {\n             unsafe {\n                 UnsafeList {"}, {"sha": "b6f29dd5fc3d3184f6a528fcb36f70b64b3f1051", "filename": "src/libstd/sys_common/condvar.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1897657ef09eea3d0b0afbbbd154a12fbb8fbf3f/src%2Flibstd%2Fsys_common%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1897657ef09eea3d0b0afbbbd154a12fbb8fbf3f/src%2Flibstd%2Fsys_common%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fcondvar.rs?ref=1897657ef09eea3d0b0afbbbd154a12fbb8fbf3f", "patch": "@@ -25,7 +25,6 @@ impl Condvar {\n     ///\n     /// Behavior is undefined if the condition variable is moved after it is\n     /// first used with any of the functions below.\n-    #[unstable(feature = \"sys_internals\", issue = \"0\")] // FIXME: min_const_fn\n     pub const fn new() -> Condvar { Condvar(imp::Condvar::new()) }\n \n     /// Prepares the condition variable for use."}, {"sha": "c6d531c7a1ac59cbb3b641ea96fc645a3b2f6d2d", "filename": "src/libstd/sys_common/mutex.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1897657ef09eea3d0b0afbbbd154a12fbb8fbf3f/src%2Flibstd%2Fsys_common%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1897657ef09eea3d0b0afbbbd154a12fbb8fbf3f/src%2Flibstd%2Fsys_common%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fmutex.rs?ref=1897657ef09eea3d0b0afbbbd154a12fbb8fbf3f", "patch": "@@ -27,7 +27,6 @@ impl Mutex {\n     /// Also, until `init` is called, behavior is undefined if this\n     /// mutex is ever used reentrantly, i.e., `raw_lock` or `try_lock`\n     /// are called by the thread currently holding the lock.\n-    #[unstable(feature = \"sys_internals\", issue = \"0\")] // FIXME: min_const_fn\n     pub const fn new() -> Mutex { Mutex(imp::Mutex::new()) }\n \n     /// Prepare the mutex for use."}, {"sha": "71a4f01ec4cab9f2d3edcee78af3373f2484e24f", "filename": "src/libstd/sys_common/rwlock.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1897657ef09eea3d0b0afbbbd154a12fbb8fbf3f/src%2Flibstd%2Fsys_common%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1897657ef09eea3d0b0afbbbd154a12fbb8fbf3f/src%2Flibstd%2Fsys_common%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Frwlock.rs?ref=1897657ef09eea3d0b0afbbbd154a12fbb8fbf3f", "patch": "@@ -22,7 +22,6 @@ impl RWLock {\n     ///\n     /// Behavior is undefined if the reader-writer lock is moved after it is\n     /// first used with any of the functions below.\n-    #[unstable(feature = \"sys_internals\", issue = \"0\")] // FIXME: min_const_fn\n     pub const fn new() -> RWLock { RWLock(imp::RWLock::new()) }\n \n     /// Acquires shared access to the underlying lock, blocking the current"}, {"sha": "10c451e1f81994463e049b1919ab510c80b32c2b", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 29, "deletions": 8, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/1897657ef09eea3d0b0afbbbd154a12fbb8fbf3f/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1897657ef09eea3d0b0afbbbd154a12fbb8fbf3f/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=1897657ef09eea3d0b0afbbbd154a12fbb8fbf3f", "patch": "@@ -15,7 +15,7 @@ use ast::{self, CrateConfig, NodeId};\n use early_buffered_lints::{BufferedEarlyLint, BufferedEarlyLintId};\n use source_map::{SourceMap, FilePathMapping};\n use syntax_pos::{Span, SourceFile, FileName, MultiSpan};\n-use errors::{Handler, ColorConfig, Diagnostic, DiagnosticBuilder};\n+use errors::{FatalError, Level, Handler, ColorConfig, Diagnostic, DiagnosticBuilder};\n use feature_gate::UnstableFeatures;\n use parse::parser::Parser;\n use ptr::P;\n@@ -192,6 +192,14 @@ pub fn new_parser_from_file<'a>(sess: &'a ParseSess, path: &Path) -> Parser<'a>\n     source_file_to_parser(sess, file_to_source_file(sess, path, None))\n }\n \n+/// Create a new parser, returning buffered diagnostics if the file doesn't\n+/// exist or from lexing the initial token stream.\n+pub fn maybe_new_parser_from_file<'a>(sess: &'a ParseSess, path: &Path)\n+    -> Result<Parser<'a>, Vec<Diagnostic>> {\n+    let file = try_file_to_source_file(sess, path, None).map_err(|db| vec![db])?;\n+    maybe_source_file_to_parser(sess, file)\n+}\n+\n /// Given a session, a crate config, a path, and a span, add\n /// the file at the given path to the source_map, and return a parser.\n /// On an error, use the given span as the source of the problem.\n@@ -236,18 +244,31 @@ pub fn new_parser_from_tts(sess: &ParseSess, tts: Vec<TokenTree>) -> Parser {\n \n // base abstractions\n \n+/// Given a session and a path and an optional span (for error reporting),\n+/// add the path to the session's source_map and return the new source_file or\n+/// error when a file can't be read.\n+fn try_file_to_source_file(sess: &ParseSess, path: &Path, spanopt: Option<Span>)\n+                   -> Result<Lrc<SourceFile>, Diagnostic> {\n+    sess.source_map().load_file(path)\n+    .map_err(|e| {\n+        let msg = format!(\"couldn't read {}: {}\", path.display(), e);\n+        let mut diag = Diagnostic::new(Level::Fatal, &msg);\n+        if let Some(sp) = spanopt {\n+            diag.set_span(sp);\n+        }\n+        diag\n+    })\n+}\n+\n /// Given a session and a path and an optional span (for error reporting),\n /// add the path to the session's source_map and return the new source_file.\n fn file_to_source_file(sess: &ParseSess, path: &Path, spanopt: Option<Span>)\n                    -> Lrc<SourceFile> {\n-    match sess.source_map().load_file(path) {\n+    match try_file_to_source_file(sess, path, spanopt) {\n         Ok(source_file) => source_file,\n-        Err(e) => {\n-            let msg = format!(\"couldn't read {}: {}\", path.display(), e);\n-            match spanopt {\n-                Some(sp) => sess.span_diagnostic.span_fatal(sp, &msg).raise(),\n-                None => sess.span_diagnostic.fatal(&msg).raise()\n-            }\n+        Err(d) => {\n+            DiagnosticBuilder::new_diagnostic(&sess.span_diagnostic, d).emit();\n+            FatalError.raise();\n         }\n     }\n }"}, {"sha": "ed7466574596fc586159abdc3d37c78c3783842c", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1897657ef09eea3d0b0afbbbd154a12fbb8fbf3f/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1897657ef09eea3d0b0afbbbd154a12fbb8fbf3f/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=1897657ef09eea3d0b0afbbbd154a12fbb8fbf3f", "patch": "@@ -207,6 +207,10 @@ pub enum Token {\n     Eof,\n }\n \n+// `Token` is used a lot. Make sure it doesn't unintentionally get bigger.\n+#[cfg(target_arch = \"x86_64\")]\n+static_assert!(MEM_SIZE_OF_STATEMENT: mem::size_of::<Token>() == 16);\n+\n impl Token {\n     pub fn interpolated(nt: Nonterminal) -> Token {\n         Token::Interpolated(Lrc::new((nt, LazyTokenStream::new())))"}, {"sha": "9aafb9fc549fc7c5c0ef7faa1049adcf380c0514", "filename": "src/libsyntax_pos/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1897657ef09eea3d0b0afbbbd154a12fbb8fbf3f/src%2Flibsyntax_pos%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1897657ef09eea3d0b0afbbbd154a12fbb8fbf3f/src%2Flibsyntax_pos%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Flib.rs?ref=1897657ef09eea3d0b0afbbbd154a12fbb8fbf3f", "patch": "@@ -24,10 +24,13 @@\n #![feature(nll)]\n #![feature(non_exhaustive)]\n #![feature(optin_builtin_traits)]\n+#![feature(rustc_attrs)]\n #![feature(specialization)]\n+#![feature(step_trait)]\n #![cfg_attr(not(stage0), feature(stdsimd))]\n \n extern crate arena;\n+#[macro_use]\n extern crate rustc_data_structures;\n \n #[macro_use]"}, {"sha": "b720db899a120d44be2c4fafa2db0362712d6cf8", "filename": "src/libsyntax_pos/symbol.rs", "status": "modified", "additions": 39, "deletions": 22, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/1897657ef09eea3d0b0afbbbd154a12fbb8fbf3f/src%2Flibsyntax_pos%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1897657ef09eea3d0b0afbbbd154a12fbb8fbf3f/src%2Flibsyntax_pos%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fsymbol.rs?ref=1897657ef09eea3d0b0afbbbd154a12fbb8fbf3f", "patch": "@@ -14,6 +14,7 @@\n \n use arena::DroplessArena;\n use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::indexed_vec::Idx;\n use serialize::{Decodable, Decoder, Encodable, Encoder};\n \n use std::fmt;\n@@ -143,9 +144,18 @@ impl Decodable for Ident {\n     }\n }\n \n-/// A symbol is an interned or gensymed string.\n+/// A symbol is an interned or gensymed string. The use of newtype_index! means\n+/// that Option<Symbol> only takes up 4 bytes, because newtype_index! reserves\n+/// the last 256 values for tagging purposes.\n+///\n+/// Note that Symbol cannot be a newtype_index! directly because it implements\n+/// fmt::Debug, Encodable, and Decodable in special ways.\n #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n-pub struct Symbol(u32);\n+pub struct Symbol(SymbolIndex);\n+\n+newtype_index! {\n+    pub struct SymbolIndex { .. }\n+}\n \n // The interner is pointed to by a thread local value which is only set on the main thread\n // with parallelization is disabled. So we don't allow `Symbol` to transfer between threads\n@@ -156,6 +166,10 @@ impl !Send for Symbol { }\n impl !Sync for Symbol { }\n \n impl Symbol {\n+    const fn new(n: u32) -> Self {\n+        Symbol(SymbolIndex::from_u32_const(n))\n+    }\n+\n     /// Maps a string to its interned representation.\n     pub fn intern(string: &str) -> Self {\n         with_interner(|interner| interner.intern(string))\n@@ -189,15 +203,15 @@ impl Symbol {\n     }\n \n     pub fn as_u32(self) -> u32 {\n-        self.0\n+        self.0.as_u32()\n     }\n }\n \n impl fmt::Debug for Symbol {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         let is_gensymed = with_interner(|interner| interner.is_gensymed(*self));\n         if is_gensymed {\n-            write!(f, \"{}({})\", self, self.0)\n+            write!(f, \"{}({:?})\", self, self.0)\n         } else {\n             write!(f, \"{}\", self)\n         }\n@@ -229,6 +243,9 @@ impl<T: ::std::ops::Deref<Target=str>> PartialEq<T> for Symbol {\n }\n \n // The `&'static str`s in this type actually point into the arena.\n+//\n+// Note that normal symbols are indexed upward from 0, and gensyms are indexed\n+// downward from SymbolIndex::MAX_AS_U32.\n #[derive(Default)]\n pub struct Interner {\n     arena: DroplessArena,\n@@ -243,7 +260,7 @@ impl Interner {\n         for &string in init {\n             if string == \"\" {\n                 // We can't allocate empty strings in the arena, so handle this here.\n-                let name = Symbol(this.strings.len() as u32);\n+                let name = Symbol::new(this.strings.len() as u32);\n                 this.names.insert(\"\", name);\n                 this.strings.push(\"\");\n             } else {\n@@ -258,7 +275,7 @@ impl Interner {\n             return name;\n         }\n \n-        let name = Symbol(self.strings.len() as u32);\n+        let name = Symbol::new(self.strings.len() as u32);\n \n         // `from_utf8_unchecked` is safe since we just allocated a `&str` which is known to be\n         // UTF-8.\n@@ -276,10 +293,10 @@ impl Interner {\n     }\n \n     pub fn interned(&self, symbol: Symbol) -> Symbol {\n-        if (symbol.0 as usize) < self.strings.len() {\n+        if (symbol.0.as_usize()) < self.strings.len() {\n             symbol\n         } else {\n-            self.interned(self.gensyms[(!0 - symbol.0) as usize])\n+            self.interned(self.gensyms[(SymbolIndex::MAX_AS_U32 - symbol.0.as_u32()) as usize])\n         }\n     }\n \n@@ -290,17 +307,17 @@ impl Interner {\n \n     fn gensymed(&mut self, symbol: Symbol) -> Symbol {\n         self.gensyms.push(symbol);\n-        Symbol(!0 - self.gensyms.len() as u32 + 1)\n+        Symbol::new(SymbolIndex::MAX_AS_U32 - self.gensyms.len() as u32 + 1)\n     }\n \n     fn is_gensymed(&mut self, symbol: Symbol) -> bool {\n-        symbol.0 as usize >= self.strings.len()\n+        symbol.0.as_usize() >= self.strings.len()\n     }\n \n     pub fn get(&self, symbol: Symbol) -> &str {\n-        match self.strings.get(symbol.0 as usize) {\n+        match self.strings.get(symbol.0.as_usize()) {\n             Some(string) => string,\n-            None => self.get(self.gensyms[(!0 - symbol.0) as usize]),\n+            None => self.get(self.gensyms[(SymbolIndex::MAX_AS_U32 - symbol.0.as_u32()) as usize]),\n         }\n     }\n }\n@@ -324,7 +341,7 @@ macro_rules! declare_keywords {(\n         $(\n             #[allow(non_upper_case_globals)]\n             pub const $konst: Keyword = Keyword {\n-                ident: Ident::with_empty_ctxt(super::Symbol($index))\n+                ident: Ident::with_empty_ctxt(super::Symbol::new($index))\n             };\n         )*\n \n@@ -709,19 +726,19 @@ mod tests {\n     fn interner_tests() {\n         let mut i: Interner = Interner::default();\n         // first one is zero:\n-        assert_eq!(i.intern(\"dog\"), Symbol(0));\n+        assert_eq!(i.intern(\"dog\"), Symbol::new(0));\n         // re-use gets the same entry:\n-        assert_eq!(i.intern(\"dog\"), Symbol(0));\n+        assert_eq!(i.intern(\"dog\"), Symbol::new(0));\n         // different string gets a different #:\n-        assert_eq!(i.intern(\"cat\"), Symbol(1));\n-        assert_eq!(i.intern(\"cat\"), Symbol(1));\n+        assert_eq!(i.intern(\"cat\"), Symbol::new(1));\n+        assert_eq!(i.intern(\"cat\"), Symbol::new(1));\n         // dog is still at zero\n-        assert_eq!(i.intern(\"dog\"), Symbol(0));\n-        assert_eq!(i.gensym(\"zebra\"), Symbol(4294967295));\n-        // gensym of same string gets new number :\n-        assert_eq!(i.gensym(\"zebra\"), Symbol(4294967294));\n+        assert_eq!(i.intern(\"dog\"), Symbol::new(0));\n+        assert_eq!(i.gensym(\"zebra\"), Symbol::new(SymbolIndex::MAX_AS_U32));\n+        // gensym of same string gets new number:\n+        assert_eq!(i.gensym(\"zebra\"), Symbol::new(SymbolIndex::MAX_AS_U32 - 1));\n         // gensym of *existing* string gets new number:\n-        assert_eq!(i.gensym(\"dog\"), Symbol(4294967293));\n+        assert_eq!(i.gensym(\"dog\"), Symbol::new(SymbolIndex::MAX_AS_U32 - 2));\n     }\n \n     #[test]"}, {"sha": "24a4b2b1b054f29add489d45cc65a2ccf1da6cdc", "filename": "src/test/codegen/simd-intrinsic-generic-select.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1897657ef09eea3d0b0afbbbd154a12fbb8fbf3f/src%2Ftest%2Fcodegen%2Fsimd-intrinsic-generic-select.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1897657ef09eea3d0b0afbbbd154a12fbb8fbf3f/src%2Ftest%2Fcodegen%2Fsimd-intrinsic-generic-select.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fsimd-intrinsic-generic-select.rs?ref=1897657ef09eea3d0b0afbbbd154a12fbb8fbf3f", "patch": "@@ -19,12 +19,17 @@\n #[derive(Copy, Clone, PartialEq, Debug)]\n pub struct f32x4(pub f32, pub f32, pub f32, pub f32);\n \n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f32x8(f32, f32, f32, f32, f32, f32, f32, f32);\n+\n #[repr(simd)]\n #[derive(Copy, Clone, PartialEq, Debug)]\n pub struct b8x4(pub i8, pub i8, pub i8, pub i8);\n \n extern \"platform-intrinsic\" {\n     fn simd_select<T, U>(x: T, a: U, b: U) -> U;\n+    fn simd_select_bitmask<T, U>(x: T, a: U, b: U) -> U;\n }\n \n // CHECK-LABEL: @select\n@@ -33,3 +38,10 @@ pub unsafe fn select(m: b8x4, a: f32x4, b: f32x4) -> f32x4 {\n     // CHECK: select <4 x i1>\n     simd_select(m, a, b)\n }\n+\n+// CHECK-LABEL: @select_bitmask\n+#[no_mangle]\n+pub unsafe fn select_bitmask(m: i8, a: f32x8, b: f32x8) -> f32x8 {\n+    // CHECK: select <8 x i1>\n+    simd_select_bitmask(m, a, b)\n+}"}, {"sha": "350b30d2cc1cda009918f5f08a3d3a2c2ec46505", "filename": "src/test/debuginfo/pretty-std-collections.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1897657ef09eea3d0b0afbbbd154a12fbb8fbf3f/src%2Ftest%2Fdebuginfo%2Fpretty-std-collections.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1897657ef09eea3d0b0afbbbd154a12fbb8fbf3f/src%2Ftest%2Fdebuginfo%2Fpretty-std-collections.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fpretty-std-collections.rs?ref=1897657ef09eea3d0b0afbbbd154a12fbb8fbf3f", "patch": "@@ -13,7 +13,11 @@\n // ignore-freebsd: gdb package too new\n // ignore-android: FIXME(#10381)\n // compile-flags:-g\n-// min-gdb-version 7.7\n+\n+// The pretty printers being tested here require the patch from\n+// https://sourceware.org/bugzilla/show_bug.cgi?id=21763\n+// min-gdb-version 8.1\n+\n // min-lldb-version: 310\n \n // === GDB TESTS ==================================================================================="}, {"sha": "2b831ea2bdca4e2d9cdfe945da0c5e507a3f6f5c", "filename": "src/test/run-make-fulldeps/libtest-json/output.json", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1897657ef09eea3d0b0afbbbd154a12fbb8fbf3f/src%2Ftest%2Frun-make-fulldeps%2Flibtest-json%2Foutput.json", "raw_url": "https://github.com/rust-lang/rust/raw/1897657ef09eea3d0b0afbbbd154a12fbb8fbf3f/src%2Ftest%2Frun-make-fulldeps%2Flibtest-json%2Foutput.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Flibtest-json%2Foutput.json?ref=1897657ef09eea3d0b0afbbbd154a12fbb8fbf3f", "patch": "@@ -2,7 +2,7 @@\n { \"type\": \"test\", \"event\": \"started\", \"name\": \"a\" }\n { \"type\": \"test\", \"name\": \"a\", \"event\": \"ok\" }\n { \"type\": \"test\", \"event\": \"started\", \"name\": \"b\" }\n-{ \"type\": \"test\", \"name\": \"b\", \"event\": \"failed\", \"stdout\": \"thread 'main' panicked at 'assertion failed: false', f.rs:18:5\\nnote: Run with `RUST_BACKTRACE=1` for a backtrace.\\n\" }\n+{ \"type\": \"test\", \"name\": \"b\", \"event\": \"failed\", \"stdout\": \"thread 'main' panicked at 'assertion failed: false', f.rs:18:5\\nnote: Run with `RUST_BACKTRACE=1` environment variable to display a backtrace.\\n\" }\n { \"type\": \"test\", \"event\": \"started\", \"name\": \"c\" }\n { \"type\": \"test\", \"name\": \"c\", \"event\": \"ok\" }\n { \"type\": \"test\", \"event\": \"started\", \"name\": \"d\" }"}, {"sha": "03e58fc2387c74493a323eadb170c1424fe9d00e", "filename": "src/test/run-pass/multi-panic.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1897657ef09eea3d0b0afbbbd154a12fbb8fbf3f/src%2Ftest%2Frun-pass%2Fmulti-panic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1897657ef09eea3d0b0afbbbd154a12fbb8fbf3f/src%2Ftest%2Frun-pass%2Fmulti-panic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmulti-panic.rs?ref=1897657ef09eea3d0b0afbbbd154a12fbb8fbf3f", "patch": "@@ -17,7 +17,8 @@ fn check_for_no_backtrace(test: std::process::Output) {\n     let mut it = err.lines();\n \n     assert_eq!(it.next().map(|l| l.starts_with(\"thread '<unnamed>' panicked at\")), Some(true));\n-    assert_eq!(it.next(), Some(\"note: Run with `RUST_BACKTRACE=1` for a backtrace.\"));\n+    assert_eq!(it.next(), Some(\"note: Run with `RUST_BACKTRACE=1` \\\n+                                environment variable to display a backtrace.\"));\n     assert_eq!(it.next().map(|l| l.starts_with(\"thread 'main' panicked at\")), Some(true));\n     assert_eq!(it.next(), None);\n }"}, {"sha": "74b99ca495081ab75f14f158d3cded0a683d343a", "filename": "src/test/run-pass/simd/simd-intrinsic-generic-select.rs", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/1897657ef09eea3d0b0afbbbd154a12fbb8fbf3f/src%2Ftest%2Frun-pass%2Fsimd%2Fsimd-intrinsic-generic-select.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1897657ef09eea3d0b0afbbbd154a12fbb8fbf3f/src%2Ftest%2Frun-pass%2Fsimd%2Fsimd-intrinsic-generic-select.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsimd%2Fsimd-intrinsic-generic-select.rs?ref=1897657ef09eea3d0b0afbbbd154a12fbb8fbf3f", "patch": "@@ -26,6 +26,10 @@ struct i32x4(pub i32, pub i32, pub i32, pub i32);\n #[derive(Copy, Clone, PartialEq, Debug)]\n struct u32x4(pub u32, pub u32, pub u32, pub u32);\n \n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+struct u32x8(u32, u32, u32, u32, u32, u32, u32, u32);\n+\n #[repr(simd)]\n #[derive(Copy, Clone, PartialEq, Debug)]\n struct f32x4(pub f32, pub f32, pub f32, pub f32);\n@@ -36,6 +40,7 @@ struct b8x4(pub i8, pub i8, pub i8, pub i8);\n \n extern \"platform-intrinsic\" {\n     fn simd_select<T, U>(x: T, a: U, b: U) -> U;\n+    fn simd_select_bitmask<T, U>(x: T, a: U, b: U) -> U;\n }\n \n fn main() {\n@@ -146,4 +151,29 @@ fn main() {\n         let e = b8x4(t, f, t, t);\n         assert_eq!(r, e);\n     }\n+\n+    unsafe {\n+        let a = u32x8(0, 1, 2, 3, 4, 5, 6, 7);\n+        let b = u32x8(8, 9, 10, 11, 12, 13, 14, 15);\n+\n+        let r: u32x8 = simd_select_bitmask(0u8, a, b);\n+        let e = b;\n+        assert_eq!(r, e);\n+\n+        let r: u32x8 = simd_select_bitmask(0xffu8, a, b);\n+        let e = a;\n+        assert_eq!(r, e);\n+\n+        let r: u32x8 = simd_select_bitmask(0b01010101u8, a, b);\n+        let e = u32x8(0, 9, 2, 11, 4, 13, 6, 15);\n+        assert_eq!(r, e);\n+\n+        let r: u32x8 = simd_select_bitmask(0b10101010u8, a, b);\n+        let e = u32x8(8, 1, 10, 3, 12, 5, 14, 7);\n+        assert_eq!(r, e);\n+\n+        let r: u32x8 = simd_select_bitmask(0b11110000u8, a, b);\n+        let e = u32x8(8, 9, 10, 11, 4, 5, 6, 7);\n+        assert_eq!(r, e);\n+    }\n }"}, {"sha": "bd6fa1f84b468b5899ab6d78936f865d538f3c51", "filename": "src/test/rustdoc-ui/failed-doctest-output.stdout", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1897657ef09eea3d0b0afbbbd154a12fbb8fbf3f/src%2Ftest%2Frustdoc-ui%2Ffailed-doctest-output.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/1897657ef09eea3d0b0afbbbd154a12fbb8fbf3f/src%2Ftest%2Frustdoc-ui%2Ffailed-doctest-output.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Ffailed-doctest-output.stdout?ref=1897657ef09eea3d0b0afbbbd154a12fbb8fbf3f", "patch": "@@ -13,13 +13,13 @@ error[E0425]: cannot find value `no` in this scope\n   | ^^ not found in this scope\n \n thread '$DIR/failed-doctest-output.rs - OtherStruct (line 27)' panicked at 'couldn't compile the test', src/librustdoc/test.rs:326:13\n-note: Run with `RUST_BACKTRACE=1` for a backtrace.\n+note: Run with `RUST_BACKTRACE=1` environment variable to display a backtrace.\n \n ---- $DIR/failed-doctest-output.rs - SomeStruct (line 21) stdout ----\n thread '$DIR/failed-doctest-output.rs - SomeStruct (line 21)' panicked at 'test executable failed:\n \n thread 'main' panicked at 'oh no', $DIR/failed-doctest-output.rs:3:1\n-note: Run with `RUST_BACKTRACE=1` for a backtrace.\n+note: Run with `RUST_BACKTRACE=1` environment variable to display a backtrace.\n \n ', src/librustdoc/test.rs:361:17\n "}, {"sha": "05d64f82fbdb8eb8a5ab81de1e92e58d6b3cbf69", "filename": "src/test/rustdoc/proc-macro.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/1897657ef09eea3d0b0afbbbd154a12fbb8fbf3f/src%2Ftest%2Frustdoc%2Fproc-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1897657ef09eea3d0b0afbbbd154a12fbb8fbf3f/src%2Ftest%2Frustdoc%2Fproc-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fproc-macro.rs?ref=1897657ef09eea3d0b0afbbbd154a12fbb8fbf3f", "patch": "@@ -61,3 +61,16 @@ pub fn some_proc_attr(_attr: TokenStream, item: TokenStream) -> TokenStream {\n pub fn some_derive(_item: TokenStream) -> TokenStream {\n     TokenStream::new()\n }\n+\n+// @has some_macros/foo/index.html\n+pub mod foo {\n+    // @has - '//code' 'pub use some_proc_macro;'\n+    // @has - '//a/@href' '../../some_macros/macro.some_proc_macro.html'\n+    pub use some_proc_macro;\n+    // @has - '//code' 'pub use some_proc_attr;'\n+    // @has - '//a/@href' '../../some_macros/attr.some_proc_attr.html'\n+    pub use some_proc_attr;\n+    // @has - '//code' 'pub use some_derive;'\n+    // @has - '//a/@href' '../../some_macros/derive.SomeDerive.html'\n+    pub use some_derive;\n+}"}, {"sha": "ff065882d96e291407dab5eb429d67dc3e8959d5", "filename": "src/test/ui/pattern/irrefutable-exhaustive-integer-binding.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1897657ef09eea3d0b0afbbbd154a12fbb8fbf3f/src%2Ftest%2Fui%2Fpattern%2Firrefutable-exhaustive-integer-binding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1897657ef09eea3d0b0afbbbd154a12fbb8fbf3f/src%2Ftest%2Fui%2Fpattern%2Firrefutable-exhaustive-integer-binding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Firrefutable-exhaustive-integer-binding.rs?ref=1897657ef09eea3d0b0afbbbd154a12fbb8fbf3f", "patch": "@@ -0,0 +1,8 @@\n+// run-pass\n+\n+fn main() {\n+    let -2147483648..=2147483647 = 1;\n+    let 0..=255 = 0u8;\n+    let -128..=127 = 0i8;\n+    let '\\u{0000}'..='\\u{10FFFF}' = 'v';\n+}"}, {"sha": "2a2d35e7bd9228a11d251881520e44d530c4a566", "filename": "src/test/ui/simd-intrinsic/simd-intrinsic-generic-select.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1897657ef09eea3d0b0afbbbd154a12fbb8fbf3f/src%2Ftest%2Fui%2Fsimd-intrinsic%2Fsimd-intrinsic-generic-select.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1897657ef09eea3d0b0afbbbd154a12fbb8fbf3f/src%2Ftest%2Fui%2Fsimd-intrinsic%2Fsimd-intrinsic-generic-select.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsimd-intrinsic%2Fsimd-intrinsic-generic-select.rs?ref=1897657ef09eea3d0b0afbbbd154a12fbb8fbf3f", "patch": "@@ -33,6 +33,7 @@ struct b8x8(pub i8, pub i8, pub i8, pub i8,\n \n extern \"platform-intrinsic\" {\n     fn simd_select<T, U>(x: T, a: U, b: U) -> U;\n+    fn simd_select_bitmask<T, U>(x: T, a: U, b: U) -> U;\n }\n \n fn main() {\n@@ -52,5 +53,14 @@ fn main() {\n \n         simd_select(z, z, z);\n         //~^ ERROR mask element type is `f32`, expected `i_`\n+\n+        simd_select_bitmask(0u8, x, x);\n+        //~^ ERROR mask length `8` != other vector length `4`\n+\n+        simd_select_bitmask(0.0f32, x, x);\n+        //~^ ERROR `f32` is not an integral type\n+\n+        simd_select_bitmask(\"x\", x, x);\n+        //~^ ERROR `&str` is not an integral type\n     }\n }"}, {"sha": "584f3d539213b8a99ea8cd0fc368ad99df1e2954", "filename": "src/test/ui/simd-intrinsic/simd-intrinsic-generic-select.stderr", "status": "modified", "additions": 22, "deletions": 4, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/1897657ef09eea3d0b0afbbbd154a12fbb8fbf3f/src%2Ftest%2Fui%2Fsimd-intrinsic%2Fsimd-intrinsic-generic-select.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1897657ef09eea3d0b0afbbbd154a12fbb8fbf3f/src%2Ftest%2Fui%2Fsimd-intrinsic%2Fsimd-intrinsic-generic-select.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsimd-intrinsic%2Fsimd-intrinsic-generic-select.stderr?ref=1897657ef09eea3d0b0afbbbd154a12fbb8fbf3f", "patch": "@@ -1,21 +1,39 @@\n error[E0511]: invalid monomorphization of `simd_select` intrinsic: mismatched lengths: mask length `8` != other vector length `4`\n-  --> $DIR/simd-intrinsic-generic-select.rs:47:9\n+  --> $DIR/simd-intrinsic-generic-select.rs:48:9\n    |\n LL |         simd_select(m8, x, x);\n    |         ^^^^^^^^^^^^^^^^^^^^^\n \n error[E0511]: invalid monomorphization of `simd_select` intrinsic: mask element type is `u32`, expected `i_`\n-  --> $DIR/simd-intrinsic-generic-select.rs:50:9\n+  --> $DIR/simd-intrinsic-generic-select.rs:51:9\n    |\n LL |         simd_select(x, x, x);\n    |         ^^^^^^^^^^^^^^^^^^^^\n \n error[E0511]: invalid monomorphization of `simd_select` intrinsic: mask element type is `f32`, expected `i_`\n-  --> $DIR/simd-intrinsic-generic-select.rs:53:9\n+  --> $DIR/simd-intrinsic-generic-select.rs:54:9\n    |\n LL |         simd_select(z, z, z);\n    |         ^^^^^^^^^^^^^^^^^^^^\n \n-error: aborting due to 3 previous errors\n+error[E0511]: invalid monomorphization of `simd_select_bitmask` intrinsic: mismatched lengths: mask length `8` != other vector length `4`\n+  --> $DIR/simd-intrinsic-generic-select.rs:57:9\n+   |\n+LL |         simd_select_bitmask(0u8, x, x);\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0511]: invalid monomorphization of `simd_select_bitmask` intrinsic: `f32` is not an integral type\n+  --> $DIR/simd-intrinsic-generic-select.rs:60:9\n+   |\n+LL |         simd_select_bitmask(0.0f32, x, x);\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0511]: invalid monomorphization of `simd_select_bitmask` intrinsic: `&str` is not an integral type\n+  --> $DIR/simd-intrinsic-generic-select.rs:63:9\n+   |\n+LL |         simd_select_bitmask(\"x\", x, x);\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 6 previous errors\n \n For more information about this error, try `rustc --explain E0511`."}]}