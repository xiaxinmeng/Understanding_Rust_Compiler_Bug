{"sha": "01f49f0bb2461ebe1987a40c6afea5b1dd30e881", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAxZjQ5ZjBiYjI0NjFlYmUxOTg3YTQwYzZhZmVhNWIxZGQzMGU4ODE=", "commit": {"author": {"name": "Alexander Regueiro", "email": "alexreg@me.com", "date": "2019-03-21T17:55:09Z"}, "committer": {"name": "Alexander Regueiro", "email": "alexreg@me.com", "date": "2019-06-05T20:09:26Z"}, "message": "Use both existential-type desugaring and where-clause (predicate) desugaring depending on context.", "tree": {"sha": "472caf3acf29691bbde6a32e17cf83e0676ce56d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/472caf3acf29691bbde6a32e17cf83e0676ce56d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/01f49f0bb2461ebe1987a40c6afea5b1dd30e881", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/01f49f0bb2461ebe1987a40c6afea5b1dd30e881", "html_url": "https://github.com/rust-lang/rust/commit/01f49f0bb2461ebe1987a40c6afea5b1dd30e881", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/01f49f0bb2461ebe1987a40c6afea5b1dd30e881/comments", "author": {"login": "alexreg", "id": 67036, "node_id": "MDQ6VXNlcjY3MDM2", "avatar_url": "https://avatars.githubusercontent.com/u/67036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexreg", "html_url": "https://github.com/alexreg", "followers_url": "https://api.github.com/users/alexreg/followers", "following_url": "https://api.github.com/users/alexreg/following{/other_user}", "gists_url": "https://api.github.com/users/alexreg/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexreg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexreg/subscriptions", "organizations_url": "https://api.github.com/users/alexreg/orgs", "repos_url": "https://api.github.com/users/alexreg/repos", "events_url": "https://api.github.com/users/alexreg/events{/privacy}", "received_events_url": "https://api.github.com/users/alexreg/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexreg", "id": 67036, "node_id": "MDQ6VXNlcjY3MDM2", "avatar_url": "https://avatars.githubusercontent.com/u/67036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexreg", "html_url": "https://github.com/alexreg", "followers_url": "https://api.github.com/users/alexreg/followers", "following_url": "https://api.github.com/users/alexreg/following{/other_user}", "gists_url": "https://api.github.com/users/alexreg/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexreg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexreg/subscriptions", "organizations_url": "https://api.github.com/users/alexreg/orgs", "repos_url": "https://api.github.com/users/alexreg/repos", "events_url": "https://api.github.com/users/alexreg/events{/privacy}", "received_events_url": "https://api.github.com/users/alexreg/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "aaa53ec8531565e2f5721548b5a38c0062aa0e51", "url": "https://api.github.com/repos/rust-lang/rust/commits/aaa53ec8531565e2f5721548b5a38c0062aa0e51", "html_url": "https://github.com/rust-lang/rust/commit/aaa53ec8531565e2f5721548b5a38c0062aa0e51"}], "stats": {"total": 260, "additions": 173, "deletions": 87}, "files": [{"sha": "165723bcfa27811e24f55542d9a5e8493b19cfdc", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 113, "deletions": 69, "changes": 182, "blob_url": "https://github.com/rust-lang/rust/blob/01f49f0bb2461ebe1987a40c6afea5b1dd30e881/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01f49f0bb2461ebe1987a40c6afea5b1dd30e881/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=01f49f0bb2461ebe1987a40c6afea5b1dd30e881", "patch": "@@ -106,6 +106,7 @@ pub struct LoweringContext<'a> {\n     loop_scopes: Vec<NodeId>,\n     is_in_loop_condition: bool,\n     is_in_trait_impl: bool,\n+    is_in_dyn_type: bool,\n \n     /// What to do when we encounter either an \"anonymous lifetime\n     /// reference\". The term \"anonymous\" is meant to encompass both\n@@ -195,20 +196,17 @@ enum ImplTraitContext<'a> {\n     /// (e.g., for consts and statics).\n     Existential(Option<DefId> /* fn def-ID */),\n \n-    /// Treat `impl Trait` as a bound on the associated type applied to the trait.\n-    /// Example: `trait Foo { type Bar: Iterator<Item = impl Debug>; }` is conceptually\n-    /// equivalent to `trait Foo where <Self::Bar as Iterator>::Item: Debug\n-    /// { type Bar: Iterator; }`.\n-    AssociatedTy,\n-\n     /// `impl Trait` is not accepted in this position.\n     Disallowed(ImplTraitPosition),\n }\n \n /// Position in which `impl Trait` is disallowed. Used for error reporting.\n #[derive(Debug, Copy, Clone, PartialEq, Eq)]\n enum ImplTraitPosition {\n+    /// Disallowed in `let` / `const` / `static` bindings.\n     Binding,\n+\n+    /// All other posiitons.\n     Other,\n }\n \n@@ -223,7 +221,6 @@ impl<'a> ImplTraitContext<'a> {\n         match self {\n             Universal(params) => Universal(params),\n             Existential(fn_def_id) => Existential(*fn_def_id),\n-            AssociatedTy => AssociatedTy,\n             Disallowed(pos) => Disallowed(*pos),\n         }\n     }\n@@ -256,6 +253,8 @@ pub fn lower_crate(\n         catch_scopes: Vec::new(),\n         loop_scopes: Vec::new(),\n         is_in_loop_condition: false,\n+        is_in_trait_impl: false,\n+        is_in_dyn_type: false,\n         anonymous_lifetime_mode: AnonymousLifetimeMode::PassThrough,\n         type_def_lifetime_params: Default::default(),\n         current_module: CRATE_NODE_ID,\n@@ -265,7 +264,6 @@ pub fn lower_crate(\n         is_generator: false,\n         is_async_body: false,\n         current_item: None,\n-        is_in_trait_impl: false,\n         lifetimes_to_define: Vec::new(),\n         is_collecting_in_band_lifetimes: false,\n         in_scope_lifetimes: Vec::new(),\n@@ -1230,6 +1228,20 @@ impl<'a> LoweringContext<'a> {\n         result\n     }\n \n+    fn with_dyn_type_scope<T, F>(&mut self, in_scope: bool, f: F) -> T\n+    where\n+        F: FnOnce(&mut LoweringContext<'_>) -> T,\n+    {\n+        let was_in_dyn_type = self.is_in_dyn_type;\n+        self.is_in_dyn_type = in_scope;\n+\n+        let result = f(self);\n+\n+        self.is_in_dyn_type = was_in_dyn_type;\n+\n+        result\n+    }\n+\n     fn with_new_scopes<T, F>(&mut self, f: F) -> T\n     where\n         F: FnOnce(&mut LoweringContext<'_>) -> T,\n@@ -1353,24 +1365,58 @@ impl<'a> LoweringContext<'a> {\n                                  c: &AssocTyConstraint,\n                                  itctx: ImplTraitContext<'_>)\n                                  -> hir::TypeBinding {\n+        debug!(\"lower_assoc_ty_constraint(constraint={:?}, itctx={:?})\", c, itctx);\n+\n         let ty = match c.kind {\n             AssocTyConstraintKind::Equality { ref ty } => self.lower_ty(ty, itctx),\n             AssocTyConstraintKind::Bound { ref bounds } => {\n-                // Desugar `AssocTy: Bounds` into `AssocTy = impl Bounds`.\n-                let impl_ty_node_id = self.sess.next_node_id();\n-                let parent_def_index = self.current_hir_id_owner.last().unwrap().0;\n-                self.resolver.definitions().create_def_with_parent(\n-                    parent_def_index,\n-                    impl_ty_node_id,\n-                    DefPathData::Misc,\n-                    DefIndexAddressSpace::High,\n-                    Mark::root(),\n-                    DUMMY_SP);\n-                self.lower_ty(&Ty {\n-                    id: self.sess.next_node_id(),\n-                    node: TyKind::ImplTrait(impl_ty_node_id, bounds.clone()),\n-                    span: DUMMY_SP,\n-                }, itctx)\n+                let (existential_desugaring, itctx) = match itctx {\n+                    ImplTraitContext::Existential(_) => (true, itctx),\n+                    ImplTraitContext::Universal(_) if self.is_in_dyn_type => (true, itctx),\n+                    // FIXME: this is only needed until `impl Trait` is allowed in type aliases.\n+                    ImplTraitContext::Disallowed(_) if self.is_in_dyn_type =>\n+                        (true, ImplTraitContext::Existential(None)),\n+                    _ => (false, itctx),\n+                };\n+\n+                if existential_desugaring {\n+                    // Desugar `AssocTy: Bounds` into `AssocTy = impl Bounds`.\n+\n+                    let impl_ty_node_id = self.sess.next_node_id();\n+                    let parent_def_index = self.current_hir_id_owner.last().unwrap().0;\n+                    self.resolver.definitions().create_def_with_parent(\n+                        parent_def_index,\n+                        impl_ty_node_id,\n+                        DefPathData::Misc,\n+                        DefIndexAddressSpace::High,\n+                        Mark::root(),\n+                        DUMMY_SP\n+                    );\n+\n+                    self.with_dyn_type_scope(false, |this| {\n+                        this.lower_ty(\n+                            &Ty {\n+                                id: this.sess.next_node_id(),\n+                                node: TyKind::ImplTrait(impl_ty_node_id, bounds.clone()),\n+                                span: DUMMY_SP,\n+                            },\n+                            itctx,\n+                        )\n+                    })\n+                } else {\n+                    // Desugar `AssocTy: Bounds` into `AssocTy = \u2203 T (T: Bounds)`, where the\n+                    // \"false existential\" later desugars into a trait predicate.\n+\n+                    let bounds = self.lower_param_bounds(bounds, itctx);\n+\n+                    let id = self.sess.next_node_id();\n+                    let LoweredNodeId { node_id: _, hir_id } = self.lower_node_id(id);\n+                    P(hir::Ty {\n+                        hir_id,\n+                        node: hir::TyKind::AssocTyExistential(bounds),\n+                        span: DUMMY_SP,\n+                    })\n+                }\n             }\n         };\n \n@@ -1477,23 +1523,26 @@ impl<'a> LoweringContext<'a> {\n             }\n             TyKind::TraitObject(ref bounds, kind) => {\n                 let mut lifetime_bound = None;\n-                let bounds = bounds\n-                    .iter()\n-                    .filter_map(|bound| match *bound {\n-                        GenericBound::Trait(ref ty, TraitBoundModifier::None) => {\n-                            Some(self.lower_poly_trait_ref(ty, itctx.reborrow()))\n-                        }\n-                        GenericBound::Trait(_, TraitBoundModifier::Maybe) => None,\n-                        GenericBound::Outlives(ref lifetime) => {\n-                            if lifetime_bound.is_none() {\n-                                lifetime_bound = Some(self.lower_lifetime(lifetime));\n+                let (bounds, lifetime_bound) = self.with_dyn_type_scope(true, |this| {\n+                    let bounds = bounds\n+                        .iter()\n+                        .filter_map(|bound| match *bound {\n+                            GenericBound::Trait(ref ty, TraitBoundModifier::None) => {\n+                                Some(this.lower_poly_trait_ref(ty, itctx.reborrow()))\n                             }\n-                            None\n-                        }\n-                    })\n-                    .collect();\n-                let lifetime_bound =\n-                    lifetime_bound.unwrap_or_else(|| self.elided_dyn_bound(t.span));\n+                            GenericBound::Trait(_, TraitBoundModifier::Maybe) => None,\n+                            GenericBound::Outlives(ref lifetime) => {\n+                                if lifetime_bound.is_none() {\n+                                    lifetime_bound = Some(this.lower_lifetime(lifetime));\n+                                }\n+                                None\n+                            }\n+                        })\n+                        .collect();\n+                    let lifetime_bound =\n+                        lifetime_bound.unwrap_or_else(|| this.elided_dyn_bound(t.span));\n+                    (bounds, lifetime_bound)\n+                });\n                 if kind != TraitObjectSyntax::Dyn {\n                     self.maybe_lint_bare_trait(t.span, t.id, false);\n                 }\n@@ -1544,16 +1593,6 @@ impl<'a> LoweringContext<'a> {\n                             }),\n                         ))\n                     }\n-                    ImplTraitContext::AssociatedTy => {\n-                        let hir_bounds = self.lower_param_bounds(\n-                            bounds,\n-                            ImplTraitContext::AssociatedTy,\n-                        );\n-\n-                        hir::TyKind::AssocTyExistential(\n-                            hir_bounds,\n-                        )\n-                    }\n                     ImplTraitContext::Disallowed(pos) => {\n                         let allowed_in = if self.sess.features_untracked()\n                                                 .impl_trait_in_bindings {\n@@ -2407,7 +2446,8 @@ impl<'a> LoweringContext<'a> {\n                 FunctionRetTy::Ty(ref ty) => match in_band_ty_params {\n                     Some((def_id, _)) if impl_trait_return_allow => {\n                         hir::Return(self.lower_ty(ty,\n-                            ImplTraitContext::Existential(Some(def_id))))\n+                            ImplTraitContext::Existential(Some(def_id))\n+                        ))\n                     }\n                     _ => {\n                         hir::Return(self.lower_ty(ty, ImplTraitContext::disallowed()))\n@@ -2770,7 +2810,7 @@ impl<'a> LoweringContext<'a> {\n \n                 let kind = hir::GenericParamKind::Type {\n                     default: default.as_ref().map(|x| {\n-                        self.lower_ty(x, ImplTraitContext::disallowed())\n+                        self.lower_ty(x, ImplTraitContext::Existential(None))\n                     }),\n                     synthetic: param.attrs.iter()\n                                           .filter(|attr| attr.check_name(sym::rustc_synthetic))\n@@ -3275,39 +3315,43 @@ impl<'a> LoweringContext<'a> {\n             ItemKind::ForeignMod(ref nm) => hir::ItemKind::ForeignMod(self.lower_foreign_mod(nm)),\n             ItemKind::GlobalAsm(ref ga) => hir::ItemKind::GlobalAsm(self.lower_global_asm(ga)),\n             ItemKind::Ty(ref t, ref generics) => hir::ItemKind::Ty(\n-                self.lower_ty(t, ImplTraitContext::AssociatedTy),\n-                self.lower_generics(generics, ImplTraitContext::AssociatedTy),\n+                self.lower_ty(t, ImplTraitContext::disallowed()),\n+                self.lower_generics(generics, ImplTraitContext::disallowed()),\n             ),\n             ItemKind::Existential(ref b, ref generics) => hir::ItemKind::Existential(\n                 hir::ExistTy {\n-                    generics: self.lower_generics(generics, ImplTraitContext::AssociatedTy),\n-                    bounds: self.lower_param_bounds(b, ImplTraitContext::AssociatedTy),\n+                    generics: self.lower_generics(generics,\n+                        ImplTraitContext::Existential(None)),\n+                    bounds: self.lower_param_bounds(b,\n+                        ImplTraitContext::Existential(None)),\n                     impl_trait_fn: None,\n                     origin: hir::ExistTyOrigin::ExistentialType,\n                 },\n             ),\n-            ItemKind::Enum(ref enum_definition, ref generics) => hir::ItemKind::Enum(\n-                hir::EnumDef {\n-                    variants: enum_definition\n-                        .variants\n-                        .iter()\n-                        .map(|x| self.lower_variant(x))\n-                        .collect(),\n-                },\n-                self.lower_generics(generics, ImplTraitContext::AssociatedTy),\n-            ),\n+            ItemKind::Enum(ref enum_definition, ref generics) => {\n+                hir::ItemKind::Enum(\n+                    hir::EnumDef {\n+                        variants: enum_definition\n+                            .variants\n+                            .iter()\n+                            .map(|x| self.lower_variant(x))\n+                            .collect(),\n+                    },\n+                    self.lower_generics(generics, ImplTraitContext::disallowed()),\n+                )\n+            },\n             ItemKind::Struct(ref struct_def, ref generics) => {\n                 let struct_def = self.lower_variant_data(struct_def);\n                 hir::ItemKind::Struct(\n                     struct_def,\n-                    self.lower_generics(generics, ImplTraitContext::AssociatedTy),\n+                    self.lower_generics(generics, ImplTraitContext::disallowed()),\n                 )\n             }\n             ItemKind::Union(ref vdata, ref generics) => {\n                 let vdata = self.lower_variant_data(vdata);\n                 hir::ItemKind::Union(\n                     vdata,\n-                    self.lower_generics(generics, ImplTraitContext::AssociatedTy),\n+                    self.lower_generics(generics, ImplTraitContext::disallowed()),\n                 )\n             }\n             ItemKind::Impl(\n@@ -3675,9 +3719,9 @@ impl<'a> LoweringContext<'a> {\n                 (generics, hir::TraitItemKind::Method(sig, hir::TraitMethod::Provided(body_id)))\n             }\n             TraitItemKind::Type(ref bounds, ref default) => {\n-                let generics = self.lower_generics(&i.generics, ImplTraitContext::AssociatedTy);\n+                let generics = self.lower_generics(&i.generics, ImplTraitContext::disallowed());\n                 let node = hir::TraitItemKind::Type(\n-                    self.lower_param_bounds(bounds, ImplTraitContext::AssociatedTy),\n+                    self.lower_param_bounds(bounds, ImplTraitContext::disallowed()),\n                     default\n                         .as_ref()\n                         .map(|x| self.lower_ty(x, ImplTraitContext::disallowed())),"}, {"sha": "532cec2af159ee8900cab4df34831b3b1a96a78e", "filename": "src/librustc_passes/ast_validation.rs", "status": "modified", "additions": 39, "deletions": 7, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/01f49f0bb2461ebe1987a40c6afea5b1dd30e881/src%2Flibrustc_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01f49f0bb2461ebe1987a40c6afea5b1dd30e881/src%2Flibrustc_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fast_validation.rs?ref=01f49f0bb2461ebe1987a40c6afea5b1dd30e881", "patch": "@@ -63,6 +63,10 @@ struct AstValidator<'a> {\n     /// or `Foo::Bar<impl Trait>`\n     is_impl_trait_banned: bool,\n \n+    /// Used to ban associated type bounds (i.e., `Type<AssocType: Bounds>`) in\n+    /// certain positions.\n+    is_assoc_ty_bound_banned: bool,\n+\n     /// rust-lang/rust#57979: the ban of nested `impl Trait` was buggy\n     /// until PRs #57730 and #57981 landed: it would jump directly to\n     /// walk_ty rather than visit_ty (or skip recurring entirely for\n@@ -87,19 +91,34 @@ impl<'a> AstValidator<'a> {\n         self.is_impl_trait_banned = old;\n     }\n \n+    fn with_banned_assoc_ty_bound(&mut self, f: impl FnOnce(&mut Self)) {\n+        let old = mem::replace(&mut self.is_assoc_ty_bound_banned, true);\n+        f(self);\n+        self.is_assoc_ty_bound_banned = old;\n+    }\n+\n     fn with_impl_trait(&mut self, outer: Option<OuterImplTrait>, f: impl FnOnce(&mut Self)) {\n         let old = mem::replace(&mut self.outer_impl_trait, outer);\n         f(self);\n         self.outer_impl_trait = old;\n     }\n \n     fn visit_assoc_ty_constraint_from_generic_args(&mut self, constraint: &'a AssocTyConstraint) {\n-        if let AssocTyConstraintKind::Equality { ref ty } = constraint.kind {\n-            // rust-lang/rust#57979: bug in old `visit_generic_args` called\n-            // `walk_ty` rather than `visit_ty`, skipping outer `impl Trait`\n-            // if it happened to occur at `ty`.\n-            if let TyKind::ImplTrait(..) = ty.node {\n-                self.warning_period_57979_didnt_record_next_impl_trait = true;\n+        match constraint.kind {\n+            AssocTyConstraintKind::Equality { ref ty } => {\n+                // rust-lang/rust#57979: bug in old `visit_generic_args` called\n+                // `walk_ty` rather than `visit_ty`, skipping outer `impl Trait`\n+                // if it happened to occur at `ty`.\n+                if let TyKind::ImplTrait(..) = ty.node {\n+                    self.warning_period_57979_didnt_record_next_impl_trait = true;\n+                }\n+            }\n+            AssocTyConstraintKind::Bound { .. } => {\n+                if self.is_assoc_ty_bound_banned {\n+                    self.err_handler().span_err(constraint.span,\n+                        \"associated type bounds are not allowed within structs, enums, or unions\"\n+                    );\n+                }\n             }\n         }\n         self.visit_assoc_ty_constraint(constraint);\n@@ -726,7 +745,8 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                 // Type bindings such as `Item = impl Debug` in `Iterator<Item = Debug>`\n                 // are allowed to contain nested `impl Trait`.\n                 self.with_impl_trait(None, |this| {\n-                    walk_list!(this, visit_assoc_ty_constraint_from_generic_args, &data.constraints);\n+                    walk_list!(this, visit_assoc_ty_constraint_from_generic_args,\n+                        &data.constraints);\n                 });\n             }\n             GenericArgs::Parenthesized(ref data) => {\n@@ -819,6 +839,17 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n         visit::walk_poly_trait_ref(self, t, m);\n     }\n \n+    fn visit_variant_data(&mut self, s: &'a VariantData, _: Ident,\n+                          _: &'a Generics, _: NodeId, _: Span) {\n+        self.with_banned_assoc_ty_bound(|this| visit::walk_struct_def(this, s))\n+    }\n+\n+    fn visit_enum_def(&mut self, enum_definition: &'a EnumDef,\n+                      generics: &'a Generics, item_id: NodeId, _: Span) {\n+        self.with_banned_assoc_ty_bound(\n+            |this| visit::walk_enum_def(this, enum_definition, generics, item_id))\n+    }\n+\n     fn visit_mac(&mut self, mac: &Spanned<Mac_>) {\n         // when a new macro kind is added but the author forgets to set it up for expansion\n         // because that's the only part that won't cause a compiler error\n@@ -842,6 +873,7 @@ pub fn check_crate(session: &Session, krate: &Crate) -> (bool, bool) {\n         has_global_allocator: false,\n         outer_impl_trait: None,\n         is_impl_trait_banned: false,\n+        is_assoc_ty_bound_banned: false,\n         warning_period_57979_didnt_record_next_impl_trait: false,\n         warning_period_57979_impl_trait_in_proj: false,\n     };"}, {"sha": "5ddb2c974ac02b828533e827260c706736cc480f", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/01f49f0bb2461ebe1987a40c6afea5b1dd30e881/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01f49f0bb2461ebe1987a40c6afea5b1dd30e881/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=01f49f0bb2461ebe1987a40c6afea5b1dd30e881", "patch": "@@ -930,21 +930,22 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n             .into_iter()\n             .map(|r| (self.ast_region_to_region(r, None), r.span))\n         );\n-\n-        bounds.trait_bounds.sort_by_key(|(t, _)| t.def_id());\n     }\n \n-    /// Translates the AST's notion of ty param bounds (which are an enum consisting of a newtyped `Ty`\n-    /// or a region) to ty's notion of ty param bounds, which can either be user-defined traits or the\n-    /// built-in trait `Send`.\n+    /// Translates the AST's notion of ty param bounds (which are an enum consisting of a newtyped\n+    /// `Ty` or a region) to ty's notion of ty param bounds, which can either be user-defined traits\n+    /// or the built-in trait `Send`.\n     pub fn compute_bounds(&self,\n         param_ty: Ty<'tcx>,\n         ast_bounds: &[hir::GenericBound],\n         sized_by_default: SizedByDefault,\n         span: Span,\n     ) -> Bounds<'tcx> {\n         let mut bounds = Bounds::default();\n+\n         self.add_bounds(param_ty, ast_bounds, &mut bounds);\n+        bounds.trait_bounds.sort_by_key(|(t, _)| t.def_id());\n+\n         bounds.implicitly_sized = if let SizedByDefault::Yes = sized_by_default {\n             if !self.is_unsized(ast_bounds, span) {\n                 Some(span)\n@@ -954,6 +955,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n         } else {\n             None\n         };\n+\n         bounds\n     }\n \n@@ -993,7 +995,8 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n             //     for<'a> <T as Iterator>::Item = &'a str // <-- 'a is bad\n             //     for<'a> <T as FnMut<(&'a u32,)>>::Output = &'a str // <-- 'a is ok\n             if let ConvertedBindingKind::Equality(ty) = binding.kind {\n-                let late_bound_in_trait_ref = tcx.collect_constrained_late_bound_regions(&trait_ref);\n+                let late_bound_in_trait_ref =\n+                    tcx.collect_constrained_late_bound_regions(&trait_ref);\n                 let late_bound_in_ty =\n                     tcx.collect_referenced_late_bound_regions(&ty::Binder::bind(ty));\n                 debug!(\"late_bound_in_trait_ref = {:?}\", late_bound_in_trait_ref);\n@@ -1074,8 +1077,11 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n                 }), binding.span));\n             }\n             ConvertedBindingKind::Constraint(ref ast_bounds) => {\n+                // Calling `skip_binder` is okay, because the predicates are re-bound later by\n+                // `instantiate_poly_trait_ref`.\n+                let param_ty = tcx.mk_projection(assoc_ty.def_id, candidate.skip_binder().substs);\n                 self.add_bounds(\n-                    trait_ref.self_ty(),\n+                    param_ty,\n                     ast_bounds,\n                     bounds,\n                 );\n@@ -2050,6 +2056,8 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n             }\n         };\n \n+        debug!(\"ast_ty_to_ty: result_ty={:?}\", result_ty);\n+\n         self.record_ty(ast_ty.hir_id, result_ty, ast_ty.span);\n         result_ty\n     }\n@@ -2135,7 +2143,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n                 }\n             }\n         });\n-        debug!(\"impl_trait_ty_to_ty: final substs = {:?}\", substs);\n+        debug!(\"impl_trait_ty_to_ty: substs={:?}\", substs);\n \n         let ty = tcx.mk_opaque(def_id, substs);\n         debug!(\"impl_trait_ty_to_ty: {}\", ty);"}, {"sha": "90ab596363bffea05fb952a952f41f00e704e22d", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/01f49f0bb2461ebe1987a40c6afea5b1dd30e881/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01f49f0bb2461ebe1987a40c6afea5b1dd30e881/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=01f49f0bb2461ebe1987a40c6afea5b1dd30e881", "patch": "@@ -703,7 +703,8 @@ fn super_predicates_of<'a, 'tcx>(\n \n     // Convert the bounds that follow the colon, e.g., `Bar + Zed` in `trait Foo: Bar + Zed`.\n     let self_param_ty = tcx.mk_self_type();\n-    let superbounds1 = AstConv::compute_bounds(&icx, self_param_ty, bounds, SizedByDefault::No, item.span);\n+    let superbounds1 = AstConv::compute_bounds(&icx, self_param_ty, bounds, SizedByDefault::No,\n+        item.span);\n \n     let superbounds1 = superbounds1.predicates(tcx, self_param_ty);\n \n@@ -1988,15 +1989,16 @@ fn explicit_predicates_of<'a, 'tcx>(\n                         tcx.def_span(def_id),\n                     );\n \n+                    let bounds_predicates = bounds.predicates(tcx, opaque_ty);\n                     if impl_trait_fn.is_some() {\n                         // opaque types\n                         return tcx.arena.alloc(ty::GenericPredicates {\n                             parent: None,\n-                            predicates: bounds.predicates(tcx, opaque_ty),\n+                            predicates: bounds_predicates,\n                         });\n                     } else {\n                         // named existential types\n-                        predicates.extend(bounds.predicates(tcx, opaque_ty));\n+                        predicates.extend(bounds_predicates);\n                         generics\n                     }\n                 }"}]}