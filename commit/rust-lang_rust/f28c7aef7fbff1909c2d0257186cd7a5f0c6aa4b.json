{"sha": "f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYyOGM3YWVmN2ZiZmYxOTA5YzJkMDI1NzE4NmNkN2E1ZjBjNmFhNGI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-06-19T21:31:36Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-06-19T21:31:36Z"}, "message": "Auto merge of #51275 - pnkfelix:nll-diagnostics-revise-check-access-permissions, r=nikomatsakis\n\nNLL diagnostics: revise `fn check_access_permissions`\n\nNLL: revise `fn check_access_permissions` so that its (still branchy) shares more code paths between the different cases, and also provide more diagnostics in more cases (though the added diagnostics still do not always meet the quality bar established by AST-borrowck)\n\n----\n\nTranscribing \"checklist\" suggested by Niko, except I am rendering it as a table to make it clear that I do not regard every item in the list to be a \"must have\" for landing this PR.\n\ngoal | does this PR do it?\n-----|------------------------------\nno suggestions for `ref mut` |  yes\nsuggestions for direct local assignment (`{ let x = 3; x = 4; }`) | yes (see commits at end)\nsuggestions for direct field assignment (`{ let x = (3, 4); x.0 = 5; }` | yes (see commits at end)\nsuggestions for upvars (`let x = 3; let c = \\|\\| { &mut x; }`) | yes\n\nNote that I added support for a couple of rows via changes that are not strictly part of `fn check_access_permissions`. If desired I can remove those commits from this PR and leave them for a later PR.\n\nFix #51031\nFix #51032\n(bug #51191 needs a little more investigation before closing.)\nFix #51578", "tree": {"sha": "3ae6e0cd22a8003311fed08d61a54ef369b2ef9a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3ae6e0cd22a8003311fed08d61a54ef369b2ef9a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b", "html_url": "https://github.com/rust-lang/rust/commit/f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d692ab406ebab720f99f950ac3e9aba1e01296af", "url": "https://api.github.com/repos/rust-lang/rust/commits/d692ab406ebab720f99f950ac3e9aba1e01296af", "html_url": "https://github.com/rust-lang/rust/commit/d692ab406ebab720f99f950ac3e9aba1e01296af"}, {"sha": "46846496ed6194d4cacf1fbd52b9c76b5c83b96c", "url": "https://api.github.com/repos/rust-lang/rust/commits/46846496ed6194d4cacf1fbd52b9c76b5c83b96c", "html_url": "https://github.com/rust-lang/rust/commit/46846496ed6194d4cacf1fbd52b9c76b5c83b96c"}], "stats": {"total": 933, "additions": 670, "deletions": 263}, "files": [{"sha": "d2e04ef31c86afffe55638868b4cbd52ea1824c6", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b", "patch": "@@ -170,6 +170,40 @@ impl<'hir> MapEntry<'hir> {\n         })\n     }\n \n+    fn fn_decl(&self) -> Option<&FnDecl> {\n+        match self {\n+            EntryItem(_, _, ref item) => {\n+                match item.node {\n+                    ItemFn(ref fn_decl, _, _, _, _, _) => Some(&fn_decl),\n+                    _ => None,\n+                }\n+            }\n+\n+            EntryTraitItem(_, _, ref item) => {\n+                match item.node {\n+                    TraitItemKind::Method(ref method_sig, _) => Some(&method_sig.decl),\n+                    _ => None\n+                }\n+            }\n+\n+            EntryImplItem(_, _, ref item) => {\n+                match item.node {\n+                    ImplItemKind::Method(ref method_sig, _) => Some(&method_sig.decl),\n+                    _ => None,\n+                }\n+            }\n+\n+            EntryExpr(_, _, ref expr) => {\n+                match expr.node {\n+                    ExprClosure(_, ref fn_decl, ..) => Some(&fn_decl),\n+                    _ => None,\n+                }\n+            }\n+\n+            _ => None\n+        }\n+    }\n+\n     fn associated_body(self) -> Option<BodyId> {\n         match self {\n             EntryItem(_, _, item) => {\n@@ -502,6 +536,14 @@ impl<'hir> Map<'hir> {\n         self.forest.krate.body(id)\n     }\n \n+    pub fn fn_decl(&self, node_id: ast::NodeId) -> Option<FnDecl> {\n+        if let Some(entry) = self.find_entry(node_id) {\n+            entry.fn_decl().map(|fd| fd.clone())\n+        } else {\n+            bug!(\"no entry for node_id `{}`\", node_id)\n+        }\n+    }\n+\n     /// Returns the `NodeId` that corresponds to the definition of\n     /// which this is the body of, i.e. a `fn`, `const` or `static`\n     /// item (possibly associated), a closure, or a `hir::AnonConst`."}, {"sha": "20a0df2a1717780c9c447f8cafead3cbb4dea256", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 91, "deletions": 9, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b", "patch": "@@ -228,7 +228,7 @@ impl<'tcx> Mir<'tcx> {\n     pub fn temps_iter<'a>(&'a self) -> impl Iterator<Item=Local> + 'a {\n         (self.arg_count+1..self.local_decls.len()).filter_map(move |index| {\n             let local = Local::new(index);\n-            if self.local_decls[local].is_user_variable {\n+            if self.local_decls[local].is_user_variable.is_some() {\n                 None\n             } else {\n                 Some(local)\n@@ -241,7 +241,7 @@ impl<'tcx> Mir<'tcx> {\n     pub fn vars_iter<'a>(&'a self) -> impl Iterator<Item=Local> + 'a {\n         (self.arg_count+1..self.local_decls.len()).filter_map(move |index| {\n             let local = Local::new(index);\n-            if self.local_decls[local].is_user_variable {\n+            if self.local_decls[local].is_user_variable.is_some() {\n                 Some(local)\n             } else {\n                 None\n@@ -255,7 +255,7 @@ impl<'tcx> Mir<'tcx> {\n         (1..self.local_decls.len()).filter_map(move |index| {\n             let local = Local::new(index);\n             let decl = &self.local_decls[local];\n-            if (decl.is_user_variable || index < self.arg_count + 1)\n+            if (decl.is_user_variable.is_some() || index < self.arg_count + 1)\n                && decl.mutability == Mutability::Mut\n             {\n                 Some(local)\n@@ -351,7 +351,7 @@ impl<'tcx> IndexMut<BasicBlock> for Mir<'tcx> {\n     }\n }\n \n-#[derive(Clone, Debug)]\n+#[derive(Copy, Clone, Debug)]\n pub enum ClearCrossCrate<T> {\n     Clear,\n     Set(T)\n@@ -382,6 +382,16 @@ pub enum Mutability {\n     Not,\n }\n \n+impl From<Mutability> for hir::Mutability {\n+    fn from(m: Mutability) -> Self {\n+        match m {\n+            Mutability::Mut => hir::MutMutable,\n+            Mutability::Not => hir::MutImmutable,\n+        }\n+    }\n+}\n+\n+\n #[derive(Copy, Clone, Debug, PartialEq, Eq, RustcEncodable, RustcDecodable)]\n pub enum BorrowKind {\n     /// Data must be immutable and is aliasable.\n@@ -463,6 +473,33 @@ pub enum LocalKind {\n     ReturnPointer,\n }\n \n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]\n+pub struct VarBindingForm {\n+    /// Is variable bound via `x`, `mut x`, `ref x`, or `ref mut x`?\n+    pub binding_mode: ty::BindingMode,\n+    /// If an explicit type was provided for this variable binding,\n+    /// this holds the source Span of that type.\n+    ///\n+    /// NOTE: If you want to change this to a `HirId`, be wary that\n+    /// doing so breaks incremental compilation (as of this writing),\n+    /// while a `Span` does not cause our tests to fail.\n+    pub opt_ty_info: Option<Span>,\n+}\n+\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]\n+pub enum BindingForm {\n+    /// This is a binding for a non-`self` binding, or a `self` that has an explicit type.\n+    Var(VarBindingForm),\n+    /// Binding for a `self`/`&self`/`&mut self` binding where the type is implicit.\n+    ImplicitSelf,\n+}\n+\n+CloneTypeFoldableAndLiftImpls! { BindingForm, }\n+\n+impl_stable_hash_for!(struct self::VarBindingForm { binding_mode, opt_ty_info });\n+\n+impl_stable_hash_for!(enum self::BindingForm { Var(binding), ImplicitSelf, });\n+\n /// A MIR local.\n ///\n /// This can be a binding declared by the user, a temporary inserted by the compiler, a function\n@@ -474,8 +511,14 @@ pub struct LocalDecl<'tcx> {\n     /// Temporaries and the return place are always mutable.\n     pub mutability: Mutability,\n \n-    /// True if this corresponds to a user-declared local variable.\n-    pub is_user_variable: bool,\n+    /// Some(binding_mode) if this corresponds to a user-declared local variable.\n+    ///\n+    /// This is solely used for local diagnostics when generating\n+    /// warnings/errors when compiling the current crate, and\n+    /// therefore it need not be visible across crates. pnkfelix\n+    /// currently hypothesized we *need* to wrap this in a\n+    /// `ClearCrossCrate` as long as it carries as `HirId`.\n+    pub is_user_variable: Option<ClearCrossCrate<BindingForm>>,\n \n     /// True if this is an internal local\n     ///\n@@ -592,6 +635,45 @@ pub struct LocalDecl<'tcx> {\n }\n \n impl<'tcx> LocalDecl<'tcx> {\n+    /// Returns true only if local is a binding that can itself be\n+    /// made mutable via the addition of the `mut` keyword, namely\n+    /// something like the occurrences of `x` in:\n+    /// - `fn foo(x: Type) { ... }`,\n+    /// - `let x = ...`,\n+    /// - or `match ... { C(x) => ... }`\n+    pub fn can_be_made_mutable(&self) -> bool\n+    {\n+        match self.is_user_variable {\n+            Some(ClearCrossCrate::Set(BindingForm::Var(VarBindingForm {\n+                binding_mode: ty::BindingMode::BindByValue(_),\n+                opt_ty_info: _,\n+            }))) => true,\n+\n+            // FIXME: might be able to thread the distinction between\n+            // `self`/`mut self`/`&self`/`&mut self` into the\n+            // `BindingForm::ImplicitSelf` variant, (and then return\n+            // true here for solely the first case).\n+            _ => false,\n+        }\n+    }\n+\n+    /// Returns true if local is definitely not a `ref ident` or\n+    /// `ref mut ident` binding. (Such bindings cannot be made into\n+    /// mutable bindings, but the inverse does not necessarily hold).\n+    pub fn is_nonref_binding(&self) -> bool\n+    {\n+        match self.is_user_variable {\n+            Some(ClearCrossCrate::Set(BindingForm::Var(VarBindingForm {\n+                binding_mode: ty::BindingMode::BindByValue(_),\n+                opt_ty_info: _,\n+            }))) => true,\n+\n+            Some(ClearCrossCrate::Set(BindingForm::ImplicitSelf)) => true,\n+\n+            _ => false,\n+        }\n+    }\n+\n     /// Create a new `LocalDecl` for a temporary.\n     #[inline]\n     pub fn new_temp(ty: Ty<'tcx>, span: Span) -> Self {\n@@ -605,7 +687,7 @@ impl<'tcx> LocalDecl<'tcx> {\n             },\n             visibility_scope: OUTERMOST_SOURCE_SCOPE,\n             internal: false,\n-            is_user_variable: false\n+            is_user_variable: None,\n         }\n     }\n \n@@ -622,7 +704,7 @@ impl<'tcx> LocalDecl<'tcx> {\n             },\n             visibility_scope: OUTERMOST_SOURCE_SCOPE,\n             internal: true,\n-            is_user_variable: false\n+            is_user_variable: None,\n         }\n     }\n \n@@ -641,7 +723,7 @@ impl<'tcx> LocalDecl<'tcx> {\n             visibility_scope: OUTERMOST_SOURCE_SCOPE,\n             internal: false,\n             name: None,     // FIXME maybe we do want some name here?\n-            is_user_variable: false\n+            is_user_variable: None,\n         }\n     }\n }"}, {"sha": "971b3c3d14aebe3b88ed5ad042b34c5e4e92c23b", "filename": "src/librustc/ty/binding.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b/src%2Flibrustc%2Fty%2Fbinding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b/src%2Flibrustc%2Fty%2Fbinding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fbinding.rs?ref=f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b", "patch": "@@ -18,6 +18,8 @@ pub enum BindingMode {\n     BindByValue(Mutability),\n }\n \n+CloneTypeFoldableAndLiftImpls! { BindingMode, }\n+\n impl BindingMode {\n     pub fn convert(ba: BindingAnnotation) -> BindingMode {\n         match ba {"}, {"sha": "38d1ac2cb4ad0482b97c5ae4a29fce422c9d5129", "filename": "src/librustc_mir/borrow_check/error_reporting.rs", "status": "modified", "additions": 17, "deletions": 3, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs?ref=f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b", "patch": "@@ -593,11 +593,18 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         err.emit();\n     }\n \n+    /// Reports an illegal reassignment; for example, an assignment to\n+    /// (part of) a non-`mut` local that occurs potentially after that\n+    /// local has already been initialized. `place` is the path being\n+    /// assigned; `err_place` is a place providing a reason why\n+    /// `place` is not mutable (e.g. the non-`mut` local `x` in an\n+    /// assignment to `x.f`).\n     pub(super) fn report_illegal_reassignment(\n         &mut self,\n         _context: Context,\n         (place, span): (&Place<'tcx>, Span),\n         assigned_span: Span,\n+        err_place: &Place<'tcx>,\n     ) {\n         let is_arg = if let Place::Local(local) = place {\n             if let LocalKind::Arg = self.mir.local_kind(*local) {\n@@ -621,16 +628,23 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             \"cannot assign twice to immutable variable\"\n         };\n         if span != assigned_span {\n-            if is_arg {\n-                err.span_label(assigned_span, \"argument not declared as `mut`\");\n-            } else {\n+            if !is_arg {\n                 let value_msg = match self.describe_place(place) {\n                     Some(name) => format!(\"`{}`\", name),\n                     None => \"value\".to_owned(),\n                 };\n                 err.span_label(assigned_span, format!(\"first assignment to {}\", value_msg));\n             }\n         }\n+        if let Place::Local(local) = err_place {\n+            let local_decl = &self.mir.local_decls[*local];\n+            if let Some(name) = local_decl.name {\n+                if local_decl.can_be_made_mutable() {\n+                    err.span_label(local_decl.source_info.span,\n+                                   format!(\"consider changing this to `mut {}`\", name));\n+                }\n+            }\n+        }\n         err.span_label(span, msg);\n         err.emit();\n     }"}, {"sha": "122b2df4766adbce7da67fc54a300f40e4049f52", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 191, "deletions": 115, "changes": 306, "blob_url": "https://github.com/rust-lang/rust/blob/f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b", "patch": "@@ -18,7 +18,7 @@ use rustc::infer::InferCtxt;\n use rustc::ty::{self, ParamEnv, TyCtxt};\n use rustc::ty::query::Providers;\n use rustc::lint::builtin::UNUSED_MUT;\n-use rustc::mir::{AggregateKind, BasicBlock, BorrowCheckResult, BorrowKind};\n+use rustc::mir::{self, AggregateKind, BasicBlock, BorrowCheckResult, BorrowKind};\n use rustc::mir::{ClearCrossCrate, Local, Location, Place, Mir, Mutability, Operand};\n use rustc::mir::{Projection, ProjectionElem, Rvalue, Field, Statement, StatementKind};\n use rustc::mir::{Terminator, TerminatorKind};\n@@ -278,7 +278,7 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n     // to the set.\n     let temporary_used_locals: FxHashSet<Local> =\n         mbcx.used_mut.iter()\n-            .filter(|&local| !mbcx.mir.local_decls[*local].is_user_variable)\n+            .filter(|&local| !mbcx.mir.local_decls[*local].is_user_variable.is_some())\n             .cloned()\n             .collect();\n \n@@ -1398,9 +1398,10 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n     ) {\n         debug!(\"check_if_reassignment_to_immutable_state({:?})\", place);\n         // determine if this path has a non-mut owner (and thus needs checking).\n-        if let Ok(..) = self.is_mutable(place, LocalMutationIsAllowed::No) {\n-            return;\n-        }\n+        let err_place = match self.is_mutable(place, LocalMutationIsAllowed::No) {\n+            Ok(..) => return,\n+            Err(place) => place,\n+        };\n         debug!(\n             \"check_if_reassignment_to_immutable_state({:?}) - is an imm local\",\n             place\n@@ -1410,7 +1411,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             let init = self.move_data.inits[i];\n             let init_place = &self.move_data.move_paths[init.path].place;\n             if places_conflict(self.tcx, self.mir, &init_place, place, Deep) {\n-                self.report_illegal_reassignment(context, (place, span), init.span);\n+                self.report_illegal_reassignment(context, (place, span), init.span, err_place);\n                 break;\n             }\n         }\n@@ -1658,36 +1659,6 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn specialized_description(&self, place:&Place<'tcx>) -> Option<String>{\n-        if let Some(_name) = self.describe_place(place) {\n-            Some(format!(\"data in a `&` reference\"))\n-        } else {\n-            None\n-        }\n-    }\n-\n-    fn get_default_err_msg(&self, place:&Place<'tcx>) -> String{\n-        match self.describe_place(place) {\n-            Some(name) => format!(\"immutable item `{}`\", name),\n-            None => \"immutable item\".to_owned(),\n-        }\n-    }\n-\n-    fn get_secondary_err_msg(&self, place:&Place<'tcx>) -> String{\n-        match self.specialized_description(place) {\n-            Some(_) => format!(\"data in a `&` reference\"),\n-            None => self.get_default_err_msg(place)\n-        }\n-    }\n-\n-    fn get_primary_err_msg(&self, place:&Place<'tcx>) -> String{\n-        if let Some(name) = self.describe_place(place) {\n-            format!(\"`{}` is a `&` reference, so the data it refers to cannot be written\", name)\n-        } else {\n-            format!(\"cannot assign through `&`-reference\")\n-        }\n-    }\n-\n     /// Check the permissions for the given place and read or write kind\n     ///\n     /// Returns true if an error is reported, false otherwise.\n@@ -1702,7 +1673,15 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             \"check_access_permissions({:?}, {:?}, {:?})\",\n             place, kind, is_local_mutation_allowed\n         );\n-        let mut error_reported = false;\n+\n+        #[derive(Copy, Clone, Debug)]\n+        enum AccessKind {\n+            MutableBorrow,\n+            Mutate,\n+        }\n+        let error_access;\n+        let the_place_err;\n+\n         match kind {\n             Reservation(WriteKind::MutableBorrow(borrow_kind @ BorrowKind::Unique))\n             | Reservation(WriteKind::MutableBorrow(borrow_kind @ BorrowKind::Mut { .. }))\n@@ -1715,91 +1694,29 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     BorrowKind::Shared => unreachable!(),\n                 };\n                 match self.is_mutable(place, is_local_mutation_allowed) {\n-                    Ok(root_place) => self.add_used_mut(root_place, flow_state),\n+                    Ok(root_place) => {\n+                        self.add_used_mut(root_place, flow_state);\n+                        return false;\n+                    }\n                     Err(place_err) => {\n-                        error_reported = true;\n-                        let item_msg = self.get_default_err_msg(place);\n-                        let mut err = self.tcx\n-                            .cannot_borrow_path_as_mutable(span, &item_msg, Origin::Mir);\n-                        err.span_label(span, \"cannot borrow as mutable\");\n-\n-                        if place != place_err {\n-                            if let Some(name) = self.describe_place(place_err) {\n-                                err.note(&format!(\"the value which is causing this path not to be \\\n-                                    mutable is...: `{}`\", name));\n-                            }\n-                        }\n-\n-                        err.emit();\n+                        error_access = AccessKind::MutableBorrow;\n+                        the_place_err = place_err;\n                     }\n                 }\n             }\n             Reservation(WriteKind::Mutate) | Write(WriteKind::Mutate) => {\n                 match self.is_mutable(place, is_local_mutation_allowed) {\n-                    Ok(root_place) => self.add_used_mut(root_place, flow_state),\n+                    Ok(root_place) => {\n+                        self.add_used_mut(root_place, flow_state);\n+                        return false;\n+                    }\n                     Err(place_err) => {\n-                        error_reported = true;\n-\n-                        let err_info = if let Place::Projection(\n-                            box Projection {\n-                                base: Place::Local(local),\n-                                elem: ProjectionElem::Deref\n-                            }\n-                        ) = *place_err {\n-                            let locations = self.mir.find_assignments(local);\n-                            if locations.len() > 0 {\n-                                let item_msg = if error_reported {\n-                                    self.get_secondary_err_msg(&Place::Local(local))\n-                                } else {\n-                                    self.get_default_err_msg(place)\n-                                };\n-                                let sp = self.mir.source_info(locations[0]).span;\n-                                let mut to_suggest_span = String::new();\n-                                if let Ok(src) =\n-                                    self.tcx.sess.codemap().span_to_snippet(sp) {\n-                                        to_suggest_span = src[1..].to_string();\n-                                };\n-                                Some((sp,\n-                                      \"consider changing this to be a \\\n-                                      mutable reference\",\n-                                      to_suggest_span,\n-                                      item_msg,\n-                                      self.get_primary_err_msg(&Place::Local(local))))\n-                            } else {\n-                                None\n-                            }\n-                        } else {\n-                            None\n-                        };\n-\n-                        if let Some((err_help_span,\n-                                     err_help_stmt,\n-                                     to_suggest_span,\n-                                     item_msg,\n-                                     sec_span)) = err_info {\n-                            let mut err = self.tcx.cannot_assign(span, &item_msg, Origin::Mir);\n-                            err.span_suggestion(err_help_span,\n-                                                err_help_stmt,\n-                                                format!(\"&mut {}\", to_suggest_span));\n-                            if place != place_err {\n-                                err.span_label(span, sec_span);\n-                            }\n-                            err.emit()\n-                        } else {\n-                            let item_msg = self.get_default_err_msg(place);\n-                            let mut err = self.tcx.cannot_assign(span, &item_msg, Origin::Mir);\n-                            err.span_label(span, \"cannot mutate\");\n-                            if place != place_err {\n-                                if let Some(name) = self.describe_place(place_err) {\n-                                    err.note(&format!(\"the value which is causing this path not \\\n-                                                       to be mutable is...: `{}`\", name));\n-                                }\n-                            }\n-                            err.emit();\n-                        }\n+                        error_access = AccessKind::Mutate;\n+                        the_place_err = place_err;\n                     }\n                 }\n             }\n+\n             Reservation(WriteKind::Move)\n             | Write(WriteKind::Move)\n             | Reservation(WriteKind::StorageDeadOrDrop)\n@@ -1815,15 +1732,174 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                         ),\n                     );\n                 }\n+                return false;\n+            }\n+            Activation(..) => {\n+                // permission checks are done at Reservation point.\n+                return false;\n             }\n-            Activation(..) => {} // permission checks are done at Reservation point.\n             Read(ReadKind::Borrow(BorrowKind::Unique))\n             | Read(ReadKind::Borrow(BorrowKind::Mut { .. }))\n             | Read(ReadKind::Borrow(BorrowKind::Shared))\n-            | Read(ReadKind::Copy) => {} // Access authorized\n+            | Read(ReadKind::Copy) => {\n+                // Access authorized\n+                return false;\n+            }\n         }\n \n-        error_reported\n+        // at this point, we have set up the error reporting state.\n+\n+        let mut err;\n+        let item_msg = match self.describe_place(place) {\n+            Some(name) => format!(\"immutable item `{}`\", name),\n+            None => \"immutable item\".to_owned(),\n+        };\n+\n+        // `act` and `acted_on` are strings that let us abstract over\n+        // the verbs used in some diagnostic messages.\n+        let act; let acted_on;\n+\n+        match error_access {\n+            AccessKind::Mutate => {\n+                let item_msg = match the_place_err {\n+                    Place::Projection(box Projection {\n+                        base: _,\n+                        elem: ProjectionElem::Deref }\n+                    ) => match self.describe_place(place) {\n+                        Some(description) =>\n+                            format!(\"`{}` which is behind a `&` reference\", description),\n+                        None => format!(\"data in a `&` reference\"),\n+                    },\n+                    _ => item_msg,\n+                };\n+                err = self.tcx.cannot_assign(span, &item_msg, Origin::Mir);\n+                act = \"assign\"; acted_on = \"written\";\n+            }\n+            AccessKind::MutableBorrow => {\n+                err = self.tcx\n+                    .cannot_borrow_path_as_mutable(span, &item_msg, Origin::Mir);\n+                act = \"borrow as mutable\"; acted_on = \"borrowed as mutable\";\n+            }\n+        }\n+\n+        match the_place_err {\n+            // We want to suggest users use `let mut` for local (user\n+            // variable) mutations...\n+            Place::Local(local) if self.mir.local_decls[*local].can_be_made_mutable() => {\n+                // ... but it doesn't make sense to suggest it on\n+                // variables that are `ref x`, `ref mut x`, `&self`,\n+                // or `&mut self` (such variables are simply not\n+                // mutable)..\n+                let local_decl = &self.mir.local_decls[*local];\n+                assert_eq!(local_decl.mutability, Mutability::Not);\n+\n+                err.span_label(span, format!(\"cannot {ACT}\", ACT=act));\n+                err.span_suggestion(local_decl.source_info.span,\n+                                    \"consider changing this to be mutable\",\n+                                    format!(\"mut {}\", local_decl.name.unwrap()));\n+            }\n+\n+            // complete hack to approximate old AST-borrowck\n+            // diagnostic: if the span starts with a mutable borrow of\n+            // a local variable, then just suggest the user remove it.\n+            Place::Local(_) if {\n+                if let Ok(snippet) = self.tcx.sess.codemap().span_to_snippet(span) {\n+                    snippet.starts_with(\"&mut \")\n+                } else {\n+                    false\n+                }\n+            } => {\n+                err.span_label(span, format!(\"cannot {ACT}\", ACT=act));\n+                err.span_label(span, \"try removing `&mut` here\");\n+            }\n+\n+            // We want to point out when a `&` can be readily replaced\n+            // with an `&mut`.\n+            //\n+            // FIXME: can this case be generalized to work for an\n+            // arbitrary base for the projection?\n+            Place::Projection(box Projection { base: Place::Local(local),\n+                                               elem: ProjectionElem::Deref })\n+                if self.mir.local_decls[*local].is_nonref_binding() =>\n+            {\n+                let (err_help_span, suggested_code) =\n+                    find_place_to_suggest_ampmut(self.tcx, self.mir, *local);\n+                err.span_suggestion(err_help_span,\n+                                    \"consider changing this to be a mutable reference\",\n+                                    suggested_code);\n+\n+                let local_decl = &self.mir.local_decls[*local];\n+                if let Some(name) = local_decl.name {\n+                    err.span_label(\n+                        span, format!(\"`{NAME}` is a `&` reference, \\\n+                                       so the data it refers to cannot be {ACTED_ON}\",\n+                                      NAME=name, ACTED_ON=acted_on));\n+                } else {\n+                    err.span_label(span, format!(\"cannot {ACT} through `&`-reference\", ACT=act));\n+                }\n+            }\n+\n+            _ => {\n+                err.span_label(span, format!(\"cannot {ACT}\", ACT=act));\n+            }\n+        }\n+\n+        err.emit();\n+        return true;\n+\n+        // Returns the span to highlight and the associated text to\n+        // present when suggesting that the user use an `&mut`.\n+        //\n+        // When we want to suggest a user change a local variable to be a `&mut`, there\n+        // are three potential \"obvious\" things to highlight:\n+        //\n+        // let ident [: Type] [= RightHandSideExresssion];\n+        //     ^^^^^    ^^^^     ^^^^^^^^^^^^^^^^^^^^^^^\n+        //     (1.)     (2.)              (3.)\n+        //\n+        // We can always fallback on highlighting the first. But chances are good that\n+        // the user experience will be better if we highlight one of the others if possible;\n+        // for example, if the RHS is present and the Type is not, then the type is going to\n+        // be inferred *from* the RHS, which means we should highlight that (and suggest\n+        // that they borrow the RHS mutably).\n+        fn find_place_to_suggest_ampmut<'cx, 'gcx, 'tcx>(tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n+                                                         mir: &Mir<'tcx>,\n+                                                         local: Local) -> (Span, String)\n+        {\n+            // This implementation attempts to emulate AST-borrowck prioritization\n+            // by trying (3.), then (2.) and finally falling back on (1.).\n+            let locations = mir.find_assignments(local);\n+            if locations.len() > 0 {\n+                let assignment_rhs_span = mir.source_info(locations[0]).span;\n+                let snippet = tcx.sess.codemap().span_to_snippet(assignment_rhs_span);\n+                if let Ok(src) = snippet {\n+                    // pnkfelix inherited code; believes intention is\n+                    // highlighted text will always be `&<expr>` and\n+                    // thus can transform to `&mut` by slicing off\n+                    // first ASCII character and prepending \"&mut \".\n+                    let borrowed_expr = src[1..].to_string();\n+                    return (assignment_rhs_span, format!(\"&mut {}\", borrowed_expr));\n+                }\n+            }\n+\n+            let local_decl = &mir.local_decls[local];\n+            let highlight_span = match local_decl.is_user_variable {\n+                // if this is a variable binding with an explicit type,\n+                // try to highlight that for the suggestion.\n+                Some(ClearCrossCrate::Set(mir::BindingForm::Var(mir::VarBindingForm {\n+                    opt_ty_info: Some(ty_span), .. }))) => ty_span,\n+\n+                Some(ClearCrossCrate::Clear) => bug!(\"saw cleared local state\"),\n+\n+                // otherwise, just highlight the span associated with\n+                // the (MIR) LocalDecl.\n+                _ => local_decl.source_info.span,\n+            };\n+\n+            let ty_mut = local_decl.ty.builtin_deref(true).unwrap();\n+            assert_eq!(ty_mut.mutbl, hir::MutImmutable);\n+            return (highlight_span, format!(\"&mut {}\", ty_mut.ty));\n+        }\n     }\n \n     /// Adds the place into the used mutable variables set"}, {"sha": "0fd55f752b84f38869e97b2e9da370ce62111226", "filename": "src/librustc_mir/build/block.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b/src%2Flibrustc_mir%2Fbuild%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b/src%2Flibrustc_mir%2Fbuild%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fblock.rs?ref=f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b", "patch": "@@ -137,7 +137,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                             }\n                         }\n \n-                        this.visit_bindings(&pattern, &mut |this, _, _, node, span, _| {\n+                        this.visit_bindings(&pattern, &mut |this, _, _, _, node, span, _| {\n                             this.storage_live_binding(block, node, span, OutsideGuard);\n                             this.schedule_drop_for_binding(node, span, OutsideGuard);\n                         })"}, {"sha": "94b387abe3c13e7d06ed13f103acc0ef1bda7c35", "filename": "src/librustc_mir/build/expr/into.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs?ref=f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b", "patch": "@@ -249,7 +249,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                         source_info,\n                         visibility_scope: source_info.scope,\n                         internal: true,\n-                        is_user_variable: false\n+                        is_user_variable: None,\n                     });\n                     let ptr_temp = Place::Local(ptr_temp);\n                     let block = unpack!(this.into(&ptr_temp, block, ptr));"}, {"sha": "b6af0ed2a4a1c448ebdf65d964a2ecc9fd3b80a9", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 23, "deletions": 10, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b", "patch": "@@ -307,7 +307,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         assert!(!(visibility_scope.is_some() && lint_level.is_explicit()),\n                 \"can't have both a visibility and a lint scope at the same time\");\n         let mut scope = self.source_scope;\n-        self.visit_bindings(pattern, &mut |this, mutability, name, var, span, ty| {\n+        self.visit_bindings(pattern, &mut |this, mutability, name, mode, var, span, ty| {\n             if visibility_scope.is_none() {\n                 visibility_scope = Some(this.new_source_scope(scope_span,\n                                                            LintLevel::Inherited,\n@@ -325,7 +325,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 scope,\n             };\n             let visibility_scope = visibility_scope.unwrap();\n-            this.declare_binding(source_info, visibility_scope, mutability, name, var,\n+            this.declare_binding(source_info, visibility_scope, mutability, name, mode, var,\n                                  ty, has_guard);\n         });\n         visibility_scope\n@@ -359,11 +359,11 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn visit_bindings<F>(&mut self, pattern: &Pattern<'tcx>, f: &mut F)\n-        where F: FnMut(&mut Self, Mutability, Name, NodeId, Span, Ty<'tcx>)\n+        where F: FnMut(&mut Self, Mutability, Name, BindingMode, NodeId, Span, Ty<'tcx>)\n     {\n         match *pattern.kind {\n-            PatternKind::Binding { mutability, name, var, ty, ref subpattern, .. } => {\n-                f(self, mutability, name, var, pattern.span, ty);\n+            PatternKind::Binding { mutability, name, mode, var, ty, ref subpattern, .. } => {\n+                f(self, mutability, name, mode, var, pattern.span, ty);\n                 if let Some(subpattern) = subpattern.as_ref() {\n                     self.visit_bindings(subpattern, f);\n                 }\n@@ -1118,23 +1118,35 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                        visibility_scope: SourceScope,\n                        mutability: Mutability,\n                        name: Name,\n+                       mode: BindingMode,\n                        var_id: NodeId,\n                        var_ty: Ty<'tcx>,\n                        has_guard: ArmHasGuard)\n     {\n-        debug!(\"declare_binding(var_id={:?}, name={:?}, var_ty={:?}, visibility_scope={:?}, \\\n-                source_info={:?})\",\n-               var_id, name, var_ty, visibility_scope, source_info);\n+        debug!(\"declare_binding(var_id={:?}, name={:?}, mode={:?}, var_ty={:?}, \\\n+                visibility_scope={:?}, source_info={:?})\",\n+               var_id, name, mode, var_ty, visibility_scope, source_info);\n \n         let tcx = self.hir.tcx();\n+        let binding_mode = match mode {\n+            BindingMode::ByValue => ty::BindingMode::BindByValue(mutability.into()),\n+            BindingMode::ByRef { .. } => ty::BindingMode::BindByReference(mutability.into()),\n+        };\n         let local = LocalDecl::<'tcx> {\n             mutability,\n             ty: var_ty.clone(),\n             name: Some(name),\n             source_info,\n             visibility_scope,\n             internal: false,\n-            is_user_variable: true,\n+            is_user_variable: Some(ClearCrossCrate::Set(BindingForm::Var(VarBindingForm {\n+                binding_mode,\n+                // hypothetically, `visit_bindings` could try to unzip\n+                // an outermost hir::Ty as we descend, matching up\n+                // idents in pat; but complex w/ unclear UI payoff.\n+                // Instead, just abandon providing diagnostic info.\n+                opt_ty_info: None,\n+            }))),\n         };\n         let for_arm_body = self.local_decls.push(local.clone());\n         let locals = if has_guard.0 && tcx.all_pat_vars_are_implicit_refs_within_guards() {\n@@ -1145,8 +1157,9 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 name: Some(name),\n                 source_info,\n                 visibility_scope,\n+                // FIXME: should these secretly injected ref_for_guard's be marked as `internal`?\n                 internal: false,\n-                is_user_variable: true,\n+                is_user_variable: None,\n             });\n             LocalsForNode::Three { val_for_guard, ref_for_guard, for_arm_body }\n         } else {"}, {"sha": "85671414618038781c9e4c2f81dcedf885e2112a", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 40, "deletions": 8, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b", "patch": "@@ -70,11 +70,11 @@ pub fn mir_build<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Mir<'t\n                     // HACK(eddyb) Avoid having RustCall on closures,\n                     // as it adds unnecessary (and wrong) auto-tupling.\n                     abi = Abi::Rust;\n-                    Some((liberated_closure_env_ty(tcx, id, body_id), None))\n+                    Some(ArgInfo(liberated_closure_env_ty(tcx, id, body_id), None, None, None))\n                 }\n                 ty::TyGenerator(..) => {\n                     let gen_ty = tcx.body_tables(body_id).node_id_to_type(fn_hir_id);\n-                    Some((gen_ty, None))\n+                    Some(ArgInfo(gen_ty, None, None, None))\n                 }\n                 _ => None,\n             };\n@@ -91,7 +91,23 @@ pub fn mir_build<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Mir<'t\n                     .iter()\n                     .enumerate()\n                     .map(|(index, arg)| {\n-                        (fn_sig.inputs()[index], Some(&*arg.pat))\n+                        let owner_id = tcx.hir.body_owner(body_id);\n+                        let opt_ty_info;\n+                        let self_arg;\n+                        if let Some(ref fn_decl) = tcx.hir.fn_decl(owner_id) {\n+                            let ty_hir_id = fn_decl.inputs[index].hir_id;\n+                            let ty_span = tcx.hir.span(tcx.hir.hir_to_node_id(ty_hir_id));\n+                            opt_ty_info = Some(ty_span);\n+                            self_arg = if index == 0 && fn_decl.has_implicit_self {\n+                                Some(ImplicitSelfBinding)\n+                            } else {\n+                                None\n+                            };\n+                        } else {\n+                            opt_ty_info = None;\n+                            self_arg = None;\n+                        }\n+                        ArgInfo(fn_sig.inputs()[index], opt_ty_info, Some(&*arg.pat), self_arg)\n                     });\n \n             let arguments = implicit_argument.into_iter().chain(explicit_arguments);\n@@ -433,6 +449,13 @@ fn should_abort_on_panic<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n ///////////////////////////////////////////////////////////////////////////\n /// the main entry point for building MIR for a function\n \n+struct ImplicitSelfBinding;\n+\n+struct ArgInfo<'gcx>(Ty<'gcx>,\n+                     Option<Span>,\n+                     Option<&'gcx hir::Pat>,\n+                     Option<ImplicitSelfBinding>);\n+\n fn construct_fn<'a, 'gcx, 'tcx, A>(hir: Cx<'a, 'gcx, 'tcx>,\n                                    fn_id: ast::NodeId,\n                                    arguments: A,\n@@ -442,7 +465,7 @@ fn construct_fn<'a, 'gcx, 'tcx, A>(hir: Cx<'a, 'gcx, 'tcx>,\n                                    yield_ty: Option<Ty<'gcx>>,\n                                    body: &'gcx hir::Body)\n                                    -> Mir<'tcx>\n-    where A: Iterator<Item=(Ty<'gcx>, Option<&'gcx hir::Pat>)>\n+    where A: Iterator<Item=ArgInfo<'gcx>>\n {\n     let arguments: Vec<_> = arguments.collect();\n \n@@ -642,13 +665,13 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n     fn args_and_body(&mut self,\n                      mut block: BasicBlock,\n-                     arguments: &[(Ty<'gcx>, Option<&'gcx hir::Pat>)],\n+                     arguments: &[ArgInfo<'gcx>],\n                      argument_scope: region::Scope,\n                      ast_body: &'gcx hir::Expr)\n                      -> BlockAnd<()>\n     {\n         // Allocate locals for the function arguments\n-        for &(ty, pattern) in arguments.iter() {\n+        for &ArgInfo(ty, _, pattern, _) in arguments.iter() {\n             // If this is a simple binding pattern, give the local a nice name for debuginfo.\n             let mut name = None;\n             if let Some(pat) = pattern {\n@@ -668,16 +691,17 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 visibility_scope: source_info.scope,\n                 name,\n                 internal: false,\n-                is_user_variable: false,\n+                is_user_variable: None,\n             });\n         }\n \n         let mut scope = None;\n         // Bind the argument patterns\n-        for (index, &(ty, pattern)) in arguments.iter().enumerate() {\n+        for (index, arg_info) in arguments.iter().enumerate() {\n             // Function arguments always get the first Local indices after the return place\n             let local = Local::new(index + 1);\n             let place = Place::Local(local);\n+            let &ArgInfo(ty, opt_ty_info, pattern, ref self_binding) = arg_info;\n \n             if let Some(pattern) = pattern {\n                 let pattern = self.hir.pattern_from_hir(pattern);\n@@ -686,6 +710,14 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     // Don't introduce extra copies for simple bindings\n                     PatternKind::Binding { mutability, var, mode: BindingMode::ByValue, .. } => {\n                         self.local_decls[local].mutability = mutability;\n+                        self.local_decls[local].is_user_variable =\n+                            if let Some(ImplicitSelfBinding) = self_binding {\n+                                Some(ClearCrossCrate::Set(BindingForm::ImplicitSelf))\n+                            } else {\n+                                let binding_mode = ty::BindingMode::BindByValue(mutability.into());\n+                                Some(ClearCrossCrate::Set(BindingForm::Var(VarBindingForm {\n+                                    binding_mode, opt_ty_info })))\n+                            };\n                         self.var_indices.insert(var, LocalsForNode::One(local));\n                     }\n                     _ => {"}, {"sha": "c703486560dcd204b3dd51000e853eedf4654365", "filename": "src/librustc_mir/shim.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b/src%2Flibrustc_mir%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b/src%2Flibrustc_mir%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fshim.rs?ref=f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b", "patch": "@@ -144,7 +144,7 @@ fn temp_decl(mutability: Mutability, ty: Ty, span: Span) -> LocalDecl {\n         source_info,\n         visibility_scope: source_info.scope,\n         internal: false,\n-        is_user_variable: false\n+        is_user_variable: None,\n     }\n }\n "}, {"sha": "a6017fafcc8d4621cbe87204329c084cbc9b76e3", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b", "patch": "@@ -303,7 +303,7 @@ fn replace_result_variable<'tcx>(ret_ty: Ty<'tcx>,\n         source_info,\n         visibility_scope: source_info.scope,\n         internal: false,\n-        is_user_variable: false,\n+        is_user_variable: None,\n     };\n     let new_ret_local = Local::new(mir.local_decls.len());\n     mir.local_decls.push(new_ret);\n@@ -644,7 +644,7 @@ fn create_generator_drop_shim<'a, 'tcx>(\n         source_info,\n         visibility_scope: source_info.scope,\n         internal: false,\n-        is_user_variable: false,\n+        is_user_variable: None,\n     };\n \n     make_generator_state_argument_indirect(tcx, def_id, &mut mir);\n@@ -660,7 +660,7 @@ fn create_generator_drop_shim<'a, 'tcx>(\n         source_info,\n         visibility_scope: source_info.scope,\n         internal: false,\n-        is_user_variable: false,\n+        is_user_variable: None,\n     };\n \n     no_landing_pads(tcx, &mut mir);"}, {"sha": "ee9dafdd49eb86c897d6ed4672ff8dd0d54e5248", "filename": "src/test/compile-fail/assign-imm-local-twice.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b/src%2Ftest%2Fcompile-fail%2Fassign-imm-local-twice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b/src%2Ftest%2Fcompile-fail%2Fassign-imm-local-twice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassign-imm-local-twice.rs?ref=f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b", "patch": "@@ -13,6 +13,7 @@\n \n fn test() {\n     let v: isize;\n+    //[mir]~^ NOTE consider changing this to `mut v`\n     v = 1; //[ast]~ NOTE first assignment\n            //[mir]~^ NOTE first assignment\n     println!(\"v={}\", v);"}, {"sha": "3c5f932af47cec42ed4ab5780b5ccb4ba5ab2051", "filename": "src/test/compile-fail/borrowck/borrowck-issue-14498.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-issue-14498.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-issue-14498.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-issue-14498.rs?ref=f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b", "patch": "@@ -27,7 +27,7 @@ fn indirect_write_to_imm_box() {\n     let y: Box<_> = box &mut x;\n     let p = &y;\n     ***p = 2; //[ast]~ ERROR cannot assign to data in a `&` reference\n-              //[mir]~^ ERROR cannot assign to data in a `&` reference\n+              //[mir]~^ ERROR cannot assign to `***p`\n     drop(p);\n }\n "}, {"sha": "f4f40e0407fded4e6443df9cf009877b248c0730", "filename": "src/test/compile-fail/borrowck/borrowck-overloaded-index-ref-index.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-overloaded-index-ref-index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-overloaded-index-ref-index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-overloaded-index-ref-index.rs?ref=f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b", "patch": "@@ -70,6 +70,6 @@ fn main() {\n     };\n     s[2] = 20;\n     //[ast]~^ ERROR cannot assign to immutable indexed content\n-    //[mir]~^^ ERROR cannot assign to immutable item\n+    //[mir]~^^ ERROR cannot assign to data in a `&` reference\n     drop(rs);\n }"}, {"sha": "61e19ffc0d293b7db19a27131db79728eddaecb5", "filename": "src/test/compile-fail/issue-45199.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b/src%2Ftest%2Fcompile-fail%2Fissue-45199.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b/src%2Ftest%2Fcompile-fail%2Fissue-45199.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-45199.rs?ref=f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b", "patch": "@@ -13,6 +13,7 @@\n \n fn test_drop_replace() {\n     let b: Box<isize>;\n+    //[mir]~^ NOTE consider changing this to `mut b`\n     b = Box::new(1);    //[ast]~ NOTE first assignment\n                         //[mir]~^ NOTE first assignment\n     b = Box::new(2);    //[ast]~ ERROR cannot assign twice to immutable variable\n@@ -24,14 +25,15 @@ fn test_drop_replace() {\n fn test_call() {\n     let b = Box::new(1);    //[ast]~ NOTE first assignment\n                             //[mir]~^ NOTE first assignment\n+                            //[mir]~| NOTE consider changing this to `mut b`\n     b = Box::new(2);        //[ast]~ ERROR cannot assign twice to immutable variable\n                             //[mir]~^ ERROR cannot assign twice to immutable variable `b`\n                             //[ast]~| NOTE cannot assign twice to immutable\n                             //[mir]~| NOTE cannot assign twice to immutable\n }\n \n fn test_args(b: Box<i32>) {  //[ast]~ NOTE first assignment\n-                                //[mir]~^ NOTE argument not declared as `mut`\n+                                //[mir]~^ NOTE consider changing this to `mut b`\n     b = Box::new(2);            //[ast]~ ERROR cannot assign twice to immutable variable\n                                 //[mir]~^ ERROR cannot assign to immutable argument `b`\n                                 //[ast]~| NOTE cannot assign twice to immutable"}, {"sha": "7bc3680ca772343b51bafa75f343847445487c0d", "filename": "src/test/compile-fail/liveness-assign-imm-local-in-loop.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b/src%2Ftest%2Fcompile-fail%2Fliveness-assign-imm-local-in-loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b/src%2Ftest%2Fcompile-fail%2Fliveness-assign-imm-local-in-loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-assign-imm-local-in-loop.rs?ref=f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b", "patch": "@@ -13,6 +13,7 @@\n \n fn test() {\n     let v: isize;\n+    //[mir]~^ NOTE consider changing this to `mut v`\n     loop {\n         v = 1; //[ast]~ ERROR cannot assign twice to immutable variable\n                //[mir]~^ ERROR cannot assign twice to immutable variable `v`"}, {"sha": "7812cdd8684f6c773599909581afcb7db2c2498e", "filename": "src/test/compile-fail/liveness-assign-imm-local-in-op-eq.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b/src%2Ftest%2Fcompile-fail%2Fliveness-assign-imm-local-in-op-eq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b/src%2Ftest%2Fcompile-fail%2Fliveness-assign-imm-local-in-op-eq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-assign-imm-local-in-op-eq.rs?ref=f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b", "patch": "@@ -13,6 +13,7 @@\n \n fn test() {\n     let v: isize;\n+    //[mir]~^ NOTE consider changing this to `mut v`\n     v = 2;  //[ast]~ NOTE first assignment\n             //[mir]~^ NOTE first assignment\n     v += 1; //[ast]~ ERROR cannot assign twice to immutable variable"}, {"sha": "bb61a9037d906c9b80939e26350de5ca426c5b64", "filename": "src/test/compile-fail/liveness-assign-imm-local-with-drop.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b/src%2Ftest%2Fcompile-fail%2Fliveness-assign-imm-local-with-drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b/src%2Ftest%2Fcompile-fail%2Fliveness-assign-imm-local-with-drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-assign-imm-local-with-drop.rs?ref=f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b", "patch": "@@ -14,6 +14,7 @@\n fn test() {\n     let b = Box::new(1); //[ast]~ NOTE first assignment\n                          //[mir]~^ NOTE first assignment\n+                         //[mir]~| NOTE consider changing this to `mut b`\n     drop(b);\n     b = Box::new(2); //[ast]~ ERROR cannot assign twice to immutable variable\n                      //[mir]~^ ERROR cannot assign twice to immutable variable `b`"}, {"sha": "672e9fab83743b8bf7b668fa17029850878ace20", "filename": "src/test/compile-fail/liveness-assign-imm-local-with-init.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b/src%2Ftest%2Fcompile-fail%2Fliveness-assign-imm-local-with-init.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b/src%2Ftest%2Fcompile-fail%2Fliveness-assign-imm-local-with-init.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-assign-imm-local-with-init.rs?ref=f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b", "patch": "@@ -14,6 +14,7 @@\n fn test() {\n     let v: isize = 1; //[ast]~ NOTE first assignment\n                       //[mir]~^ NOTE first assignment\n+                      //[mir]~| NOTE consider changing this to `mut v`\n     v.clone();\n     v = 2; //[ast]~ ERROR cannot assign twice to immutable variable\n            //[mir]~^ ERROR cannot assign twice to immutable variable `v`"}, {"sha": "f20719ec7fab7193a0699445284a9366132b3a39", "filename": "src/test/compile-fail/unboxed-closures-mutated-upvar-from-fn-closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b/src%2Ftest%2Fcompile-fail%2Funboxed-closures-mutated-upvar-from-fn-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b/src%2Ftest%2Fcompile-fail%2Funboxed-closures-mutated-upvar-from-fn-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closures-mutated-upvar-from-fn-closure.rs?ref=f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b", "patch": "@@ -23,6 +23,6 @@ fn main() {\n     call(|| {\n         counter += 1;\n         //[ast]~^ ERROR cannot assign to data in a captured outer variable in an `Fn` closure\n-        //[mir]~^^ ERROR cannot assign to immutable item `counter`\n+        //[mir]~^^ ERROR cannot assign to `counter`\n     });\n }"}, {"sha": "fbd58cd4c2260adc3212068169d9ba3ee27672a7", "filename": "src/test/ui/asm-out-assign-imm.nll.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b/src%2Ftest%2Fui%2Fasm-out-assign-imm.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b/src%2Ftest%2Fui%2Fasm-out-assign-imm.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasm-out-assign-imm.nll.stderr?ref=f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b", "patch": "@@ -0,0 +1,14 @@\n+error[E0384]: cannot assign twice to immutable variable `x`\n+  --> $DIR/asm-out-assign-imm.rs:33:9\n+   |\n+LL |     let x: isize;\n+   |         - consider changing this to `mut x`\n+LL |     x = 1;\n+   |     ----- first assignment to `x`\n+...\n+LL |         asm!(\"mov $1, $0\" : \"=r\"(x) : \"r\"(5));\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0384`."}, {"sha": "592f666eff8f3955b2f8af28f90bac2df13117f4", "filename": "src/test/ui/augmented-assignments.nll.stderr", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b/src%2Ftest%2Fui%2Faugmented-assignments.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b/src%2Ftest%2Fui%2Faugmented-assignments.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Faugmented-assignments.nll.stderr?ref=f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b", "patch": "@@ -17,6 +17,9 @@ LL | |     x;  //~ value moved here\n error[E0596]: cannot borrow immutable item `y` as mutable\n   --> $DIR/augmented-assignments.rs:30:5\n    |\n+LL |     let y = Int(2);\n+   |         - help: consider changing this to be mutable: `mut y`\n+LL |     //~^ consider changing this to `mut y`\n LL |     y   //~ error: cannot borrow immutable local variable `y` as mutable\n    |     ^ cannot borrow as mutable\n "}, {"sha": "1cf68795bf07f5e3dc4101d9162eebdb259068ed", "filename": "src/test/ui/borrowck/immutable-arg.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b/src%2Ftest%2Fui%2Fborrowck%2Fimmutable-arg.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b/src%2Ftest%2Fui%2Fborrowck%2Fimmutable-arg.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fimmutable-arg.stderr?ref=f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b", "patch": "@@ -10,7 +10,7 @@ error[E0384]: cannot assign to immutable argument `_x` (Mir)\n   --> $DIR/immutable-arg.rs:14:5\n    |\n LL | fn foo(_x: u32) {\n-   |        -- argument not declared as `mut`\n+   |        -- consider changing this to `mut _x`\n LL |     _x = 4;\n    |     ^^^^^^ cannot assign to immutable argument\n "}, {"sha": "a008a408d97112116774c66e4b3234f24c7896d1", "filename": "src/test/ui/borrowck/issue-45983.nll.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b/src%2Ftest%2Fui%2Fborrowck%2Fissue-45983.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b/src%2Ftest%2Fui%2Fborrowck%2Fissue-45983.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fissue-45983.nll.stderr?ref=f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b", "patch": "@@ -14,13 +14,13 @@ error[E0594]: cannot assign to immutable item `x`\n   --> $DIR/issue-45983.rs:17:18\n    |\n LL |     give_any(|y| x = Some(y));\n-   |                  ^^^^^^^^^^^ cannot mutate\n-   |\n-   = note: the value which is causing this path not to be mutable is...: `x`\n+   |                  ^^^^^^^^^^^ cannot assign\n \n error[E0596]: cannot borrow immutable item `x` as mutable\n   --> $DIR/issue-45983.rs:17:14\n    |\n+LL |     let x = None;\n+   |         - help: consider changing this to be mutable: `mut x`\n LL |     give_any(|y| x = Some(y));\n    |              ^^^^^^^^^^^^^^^ cannot borrow as mutable\n "}, {"sha": "0674c8230165aa20713708cf551c43ebb2d5068f", "filename": "src/test/ui/borrowck/mut-borrow-of-mut-ref.nll.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b/src%2Ftest%2Fui%2Fborrowck%2Fmut-borrow-of-mut-ref.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b/src%2Ftest%2Fui%2Fborrowck%2Fmut-borrow-of-mut-ref.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fmut-borrow-of-mut-ref.nll.stderr?ref=f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b", "patch": "@@ -1,6 +1,8 @@\n error[E0596]: cannot borrow immutable item `b` as mutable\n   --> $DIR/mut-borrow-of-mut-ref.rs:18:7\n    |\n+LL | fn f(b: &mut i32) {\n+   |      - help: consider changing this to be mutable: `mut b`\n LL |     g(&mut b) //~ ERROR cannot borrow\n    |       ^^^^^^ cannot borrow as mutable\n "}, {"sha": "da0b201f5d4e160b6b6d191a8c0dce5adc6ab7d2", "filename": "src/test/ui/codemap_tests/huge_multispan_highlight.nll.stderr", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b/src%2Ftest%2Fui%2Fcodemap_tests%2Fhuge_multispan_highlight.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b/src%2Ftest%2Fui%2Fcodemap_tests%2Fhuge_multispan_highlight.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcodemap_tests%2Fhuge_multispan_highlight.nll.stderr?ref=f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b", "patch": "@@ -1,6 +1,9 @@\n error[E0596]: cannot borrow immutable item `x` as mutable\n   --> $DIR/huge_multispan_highlight.rs:100:13\n    |\n+LL |     let x = \"foo\";\n+   |         - help: consider changing this to be mutable: `mut x`\n+...\n LL |     let y = &mut x; //~ ERROR cannot borrow\n    |             ^^^^^^ cannot borrow as mutable\n "}, {"sha": "10dcf7d0e657a38d177b763486190b1d1da6f925", "filename": "src/test/ui/command-line-diagnostics.nll.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b/src%2Ftest%2Fui%2Fcommand-line-diagnostics.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b/src%2Ftest%2Fui%2Fcommand-line-diagnostics.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcommand-line-diagnostics.nll.stderr?ref=f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b", "patch": "@@ -2,7 +2,9 @@ error[E0384]: cannot assign twice to immutable variable `x`\n   --> $DIR/command-line-diagnostics.rs:16:5\n    |\n LL |     let x = 42;\n-   |             -- first assignment to `x`\n+   |         -   -- first assignment to `x`\n+   |         |\n+   |         consider changing this to `mut x`\n LL |     x = 43;\n    |     ^^^^^^ cannot assign twice to immutable variable\n "}, {"sha": "21c5e3608c00b5dd73fbffac57fa5f504731c930", "filename": "src/test/ui/did_you_mean/issue-31424.nll.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-31424.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-31424.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-31424.nll.stderr?ref=f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b", "patch": "@@ -7,6 +7,8 @@ LL |         (&mut self).bar(); //~ ERROR cannot borrow\n error[E0596]: cannot borrow immutable item `self` as mutable\n   --> $DIR/issue-31424.rs:23:9\n    |\n+LL |     fn bar(self: &mut Self) {\n+   |            ---- help: consider changing this to be mutable: `mut self`\n LL |         (&mut self).bar(); //~ ERROR cannot borrow\n    |         ^^^^^^^^^^^ cannot borrow as mutable\n "}, {"sha": "8dedb6ec4db80a1eed930a3e5168805c7546cef8", "filename": "src/test/ui/did_you_mean/issue-34126.nll.stderr", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-34126.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-34126.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-34126.nll.stderr?ref=f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b", "patch": "@@ -2,7 +2,10 @@ error[E0596]: cannot borrow immutable item `self` as mutable\n   --> $DIR/issue-34126.rs:16:18\n    |\n LL |         self.run(&mut self); //~ ERROR cannot borrow\n-   |                  ^^^^^^^^^ cannot borrow as mutable\n+   |                  ^^^^^^^^^\n+   |                  |\n+   |                  cannot borrow as mutable\n+   |                  try removing `&mut` here\n \n error[E0502]: cannot borrow `self` as mutable because it is also borrowed as immutable\n   --> $DIR/issue-34126.rs:16:18"}, {"sha": "d2271e8e7de76b5ee9cf526f745edb54d1e56aeb", "filename": "src/test/ui/did_you_mean/issue-34337.nll.stderr", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-34337.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-34337.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-34337.nll.stderr?ref=f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b", "patch": "@@ -2,7 +2,10 @@ error[E0596]: cannot borrow immutable item `key` as mutable\n   --> $DIR/issue-34337.rs:16:9\n    |\n LL |     get(&mut key); //~ ERROR cannot borrow\n-   |         ^^^^^^^^ cannot borrow as mutable\n+   |         ^^^^^^^^\n+   |         |\n+   |         cannot borrow as mutable\n+   |         try removing `&mut` here\n \n error: aborting due to previous error\n "}, {"sha": "0c1dcb29d4d2c2067f795325946bc69e76d45ed7", "filename": "src/test/ui/did_you_mean/issue-35937.nll.stderr", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-35937.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-35937.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-35937.nll.stderr?ref=f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b", "patch": "@@ -1,24 +1,29 @@\n error[E0596]: cannot borrow immutable item `f.v` as mutable\n   --> $DIR/issue-35937.rs:17:5\n    |\n+LL |     let f = Foo { v: Vec::new() };\n+   |         - help: consider changing this to be mutable: `mut f`\n LL |     f.v.push(\"cat\".to_string()); //~ ERROR cannot borrow\n    |     ^^^ cannot borrow as mutable\n-   |\n-   = note: the value which is causing this path not to be mutable is...: `f`\n \n error[E0384]: cannot assign twice to immutable variable `s.x`\n   --> $DIR/issue-35937.rs:26:5\n    |\n LL |     let s = S { x: 42 };\n-   |             ----------- first assignment to `s.x`\n+   |         -   ----------- first assignment to `s.x`\n+   |         |\n+   |         consider changing this to `mut s`\n LL |     s.x += 1; //~ ERROR cannot assign\n    |     ^^^^^^^^ cannot assign twice to immutable variable\n \n error[E0384]: cannot assign twice to immutable variable `s.x`\n   --> $DIR/issue-35937.rs:30:5\n    |\n LL | fn bar(s: S) {\n-   |        - first assignment to `s.x`\n+   |        -\n+   |        |\n+   |        first assignment to `s.x`\n+   |        consider changing this to `mut s`\n LL |     s.x += 1; //~ ERROR cannot assign\n    |     ^^^^^^^^ cannot assign twice to immutable variable\n "}, {"sha": "e51a1baad25f26685fdfc7a43477e936986a67de", "filename": "src/test/ui/did_you_mean/issue-37139.nll.stderr", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-37139.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-37139.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-37139.nll.stderr?ref=f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b", "patch": "@@ -2,7 +2,10 @@ error[E0596]: cannot borrow immutable item `x` as mutable\n   --> $DIR/issue-37139.rs:22:18\n    |\n LL |             test(&mut x); //~ ERROR cannot borrow immutable\n-   |                  ^^^^^^ cannot borrow as mutable\n+   |                  ^^^^^^\n+   |                  |\n+   |                  cannot borrow as mutable\n+   |                  try removing `&mut` here\n \n error: aborting due to previous error\n "}, {"sha": "76b8c8ebf602940058e6828efbb1b1a2836de961", "filename": "src/test/ui/did_you_mean/issue-38147-1.nll.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-38147-1.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-38147-1.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-38147-1.nll.stderr?ref=f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b", "patch": "@@ -1,10 +1,10 @@\n error[E0596]: cannot borrow immutable item `*self.s` as mutable\n   --> $DIR/issue-38147-1.rs:27:9\n    |\n+LL |     fn f(&self) {\n+   |          ----- help: consider changing this to be a mutable reference: `&mut Foo<'_>`\n LL |         self.s.push('x'); //~ ERROR cannot borrow data mutably\n-   |         ^^^^^^ cannot borrow as mutable\n-   |\n-   = note: the value which is causing this path not to be mutable is...: `*self`\n+   |         ^^^^^^ `self` is a `&` reference, so the data it refers to cannot be borrowed as mutable\n \n error: aborting due to previous error\n "}, {"sha": "c875957623b62841a675fbd11ce9e9340380c49f", "filename": "src/test/ui/did_you_mean/issue-38147-4.nll.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-38147-4.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-38147-4.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-38147-4.nll.stderr?ref=f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b", "patch": "@@ -1,10 +1,10 @@\n error[E0596]: cannot borrow immutable item `*f.s` as mutable\n   --> $DIR/issue-38147-4.rs:16:5\n    |\n+LL | fn f(x: usize, f: &Foo) {\n+   |                   ---- help: consider changing this to be a mutable reference: `&mut Foo<'_>`\n LL |     f.s.push('x'); //~ ERROR cannot borrow data mutably\n-   |     ^^^ cannot borrow as mutable\n-   |\n-   = note: the value which is causing this path not to be mutable is...: `*f`\n+   |     ^^^ `f` is a `&` reference, so the data it refers to cannot be borrowed as mutable\n \n error: aborting due to previous error\n "}, {"sha": "02c1debca69b24fa515978b7e4c757612eba2fc1", "filename": "src/test/ui/did_you_mean/issue-39544.nll.stderr", "status": "modified", "additions": 37, "deletions": 33, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-39544.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-39544.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-39544.nll.stderr?ref=f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b", "patch": "@@ -1,96 +1,100 @@\n error[E0596]: cannot borrow immutable item `z.x` as mutable\n   --> $DIR/issue-39544.rs:21:13\n    |\n+LL |     let z = Z { x: X::Y };\n+   |         - help: consider changing this to be mutable: `mut z`\n LL |     let _ = &mut z.x; //~ ERROR cannot borrow\n    |             ^^^^^^^^ cannot borrow as mutable\n-   |\n-   = note: the value which is causing this path not to be mutable is...: `z`\n \n error[E0596]: cannot borrow immutable item `self.x` as mutable\n   --> $DIR/issue-39544.rs:26:17\n    |\n+LL |     fn foo<'z>(&'z self) {\n+   |                -------- help: consider changing this to be a mutable reference: `&mut Z`\n LL |         let _ = &mut self.x; //~ ERROR cannot borrow\n-   |                 ^^^^^^^^^^^ cannot borrow as mutable\n-   |\n-   = note: the value which is causing this path not to be mutable is...: `*self`\n+   |                 ^^^^^^^^^^^ `self` is a `&` reference, so the data it refers to cannot be borrowed as mutable\n \n error[E0596]: cannot borrow immutable item `self.x` as mutable\n   --> $DIR/issue-39544.rs:30:17\n    |\n+LL |     fn foo1(&self, other: &Z) {\n+   |             ----- help: consider changing this to be a mutable reference: `&mut Z`\n LL |         let _ = &mut self.x; //~ ERROR cannot borrow\n-   |                 ^^^^^^^^^^^ cannot borrow as mutable\n-   |\n-   = note: the value which is causing this path not to be mutable is...: `*self`\n+   |                 ^^^^^^^^^^^ `self` is a `&` reference, so the data it refers to cannot be borrowed as mutable\n \n error[E0596]: cannot borrow immutable item `other.x` as mutable\n   --> $DIR/issue-39544.rs:31:17\n    |\n+LL |     fn foo1(&self, other: &Z) {\n+   |                           -- help: consider changing this to be a mutable reference: `&mut Z`\n+LL |         let _ = &mut self.x; //~ ERROR cannot borrow\n LL |         let _ = &mut other.x; //~ ERROR cannot borrow\n-   |                 ^^^^^^^^^^^^ cannot borrow as mutable\n-   |\n-   = note: the value which is causing this path not to be mutable is...: `*other`\n+   |                 ^^^^^^^^^^^^ `other` is a `&` reference, so the data it refers to cannot be borrowed as mutable\n \n error[E0596]: cannot borrow immutable item `self.x` as mutable\n   --> $DIR/issue-39544.rs:35:17\n    |\n+LL |     fn foo2<'a>(&'a self, other: &Z) {\n+   |                 -------- help: consider changing this to be a mutable reference: `&mut Z`\n LL |         let _ = &mut self.x; //~ ERROR cannot borrow\n-   |                 ^^^^^^^^^^^ cannot borrow as mutable\n-   |\n-   = note: the value which is causing this path not to be mutable is...: `*self`\n+   |                 ^^^^^^^^^^^ `self` is a `&` reference, so the data it refers to cannot be borrowed as mutable\n \n error[E0596]: cannot borrow immutable item `other.x` as mutable\n   --> $DIR/issue-39544.rs:36:17\n    |\n+LL |     fn foo2<'a>(&'a self, other: &Z) {\n+   |                                  -- help: consider changing this to be a mutable reference: `&mut Z`\n+LL |         let _ = &mut self.x; //~ ERROR cannot borrow\n LL |         let _ = &mut other.x; //~ ERROR cannot borrow\n-   |                 ^^^^^^^^^^^^ cannot borrow as mutable\n-   |\n-   = note: the value which is causing this path not to be mutable is...: `*other`\n+   |                 ^^^^^^^^^^^^ `other` is a `&` reference, so the data it refers to cannot be borrowed as mutable\n \n error[E0596]: cannot borrow immutable item `self.x` as mutable\n   --> $DIR/issue-39544.rs:40:17\n    |\n+LL |     fn foo3<'a>(self: &'a Self, other: &Z) {\n+   |                       -------- help: consider changing this to be a mutable reference: `&mut Z`\n LL |         let _ = &mut self.x; //~ ERROR cannot borrow\n-   |                 ^^^^^^^^^^^ cannot borrow as mutable\n-   |\n-   = note: the value which is causing this path not to be mutable is...: `*self`\n+   |                 ^^^^^^^^^^^ `self` is a `&` reference, so the data it refers to cannot be borrowed as mutable\n \n error[E0596]: cannot borrow immutable item `other.x` as mutable\n   --> $DIR/issue-39544.rs:41:17\n    |\n+LL |     fn foo3<'a>(self: &'a Self, other: &Z) {\n+   |                                        -- help: consider changing this to be a mutable reference: `&mut Z`\n+LL |         let _ = &mut self.x; //~ ERROR cannot borrow\n LL |         let _ = &mut other.x; //~ ERROR cannot borrow\n-   |                 ^^^^^^^^^^^^ cannot borrow as mutable\n-   |\n-   = note: the value which is causing this path not to be mutable is...: `*other`\n+   |                 ^^^^^^^^^^^^ `other` is a `&` reference, so the data it refers to cannot be borrowed as mutable\n \n error[E0596]: cannot borrow immutable item `other.x` as mutable\n   --> $DIR/issue-39544.rs:45:17\n    |\n+LL |     fn foo4(other: &Z) {\n+   |                    -- help: consider changing this to be a mutable reference: `&mut Z`\n LL |         let _ = &mut other.x; //~ ERROR cannot borrow\n-   |                 ^^^^^^^^^^^^ cannot borrow as mutable\n-   |\n-   = note: the value which is causing this path not to be mutable is...: `*other`\n+   |                 ^^^^^^^^^^^^ `other` is a `&` reference, so the data it refers to cannot be borrowed as mutable\n \n error[E0596]: cannot borrow immutable item `z.x` as mutable\n   --> $DIR/issue-39544.rs:51:13\n    |\n+LL | pub fn with_arg(z: Z, w: &Z) {\n+   |                 - help: consider changing this to be mutable: `mut z`\n LL |     let _ = &mut z.x; //~ ERROR cannot borrow\n    |             ^^^^^^^^ cannot borrow as mutable\n-   |\n-   = note: the value which is causing this path not to be mutable is...: `z`\n \n error[E0596]: cannot borrow immutable item `w.x` as mutable\n   --> $DIR/issue-39544.rs:52:13\n    |\n+LL | pub fn with_arg(z: Z, w: &Z) {\n+   |                          -- help: consider changing this to be a mutable reference: `&mut Z`\n+LL |     let _ = &mut z.x; //~ ERROR cannot borrow\n LL |     let _ = &mut w.x; //~ ERROR cannot borrow\n-   |             ^^^^^^^^ cannot borrow as mutable\n-   |\n-   = note: the value which is causing this path not to be mutable is...: `*w`\n+   |             ^^^^^^^^ `w` is a `&` reference, so the data it refers to cannot be borrowed as mutable\n \n-error[E0594]: cannot assign to immutable item `*x.0`\n+error[E0594]: cannot assign to `*x.0` which is behind a `&` reference\n   --> $DIR/issue-39544.rs:58:5\n    |\n LL |     *x.0 = 1;\n-   |     ^^^^^^^^ cannot mutate\n+   |     ^^^^^^^^ cannot assign\n \n error: aborting due to 12 previous errors\n "}, {"sha": "1fd75de81284fd363b62fa149f616dd7894aeb96", "filename": "src/test/ui/did_you_mean/issue-40823.nll.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-40823.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-40823.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-40823.nll.stderr?ref=f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b", "patch": "@@ -1,8 +1,10 @@\n error[E0596]: cannot borrow immutable item `*buf` as mutable\n   --> $DIR/issue-40823.rs:13:5\n    |\n+LL |     let mut buf = &[1, 2, 3, 4];\n+   |                   ------------- help: consider changing this to be a mutable reference: `&mut [1, 2, 3, 4]`\n LL |     buf.iter_mut(); //~ ERROR cannot borrow immutable borrowed content\n-   |     ^^^ cannot borrow as mutable\n+   |     ^^^ `buf` is a `&` reference, so the data it refers to cannot be borrowed as mutable\n \n error: aborting due to previous error\n "}, {"sha": "66e46dfe29d70d7cfc6b2f4dafdca49243e370dd", "filename": "src/test/ui/error-codes/E0389.nll.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b/src%2Ftest%2Fui%2Ferror-codes%2FE0389.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b/src%2Ftest%2Fui%2Ferror-codes%2FE0389.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0389.nll.stderr?ref=f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b", "patch": "@@ -1,4 +1,4 @@\n-error[E0594]: cannot assign to data in a `&` reference\n+error[E0594]: cannot assign to `fancy_ref.num` which is behind a `&` reference\n   --> $DIR/E0389.rs:18:5\n    |\n LL |     let fancy_ref = &(&mut fancy);"}, {"sha": "be10b1d517bdc6c16af40bb31bef21b15a9cc0f8", "filename": "src/test/ui/issue-36400.nll.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b/src%2Ftest%2Fui%2Fissue-36400.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b/src%2Ftest%2Fui%2Fissue-36400.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-36400.nll.stderr?ref=f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b", "patch": "@@ -1,10 +1,10 @@\n error[E0596]: cannot borrow immutable item `*x` as mutable\n   --> $DIR/issue-36400.rs:15:7\n    |\n+LL |     let x = Box::new(3);\n+   |         - help: consider changing this to be mutable: `mut x`\n LL |     f(&mut *x); //~ ERROR cannot borrow immutable\n    |       ^^^^^^^ cannot borrow as mutable\n-   |\n-   = note: the value which is causing this path not to be mutable is...: `x`\n \n error: aborting due to previous error\n "}, {"sha": "93f2837c0fc11ce2b838da0757d829d87805cd54", "filename": "src/test/ui/lifetime-errors/ex3-both-anon-regions-one-is-struct-2.nll.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-one-is-struct-2.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-one-is-struct-2.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-one-is-struct-2.nll.stderr?ref=f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b", "patch": "@@ -18,7 +18,7 @@ error[E0384]: cannot assign to immutable argument `y`\n   --> $DIR/ex3-both-anon-regions-one-is-struct-2.rs:14:5\n    |\n LL | fn foo(mut x: Ref, y: &u32) {\n-   |                    - argument not declared as `mut`\n+   |                    - consider changing this to `mut y`\n LL |     y = x.b; //~ ERROR lifetime mismatch\n    |     ^^^^^^^ cannot assign to immutable argument\n "}, {"sha": "01e26980323949cac18c34806e96e9453f4cc79a", "filename": "src/test/ui/lifetime-errors/ex3-both-anon-regions-using-fn-items.nll.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-using-fn-items.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-using-fn-items.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-using-fn-items.nll.stderr?ref=f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b", "patch": "@@ -15,6 +15,8 @@ LL |   y.push(z); //~ ERROR lifetime mismatch\n error[E0596]: cannot borrow immutable item `y` as mutable\n   --> $DIR/ex3-both-anon-regions-using-fn-items.rs:11:3\n    |\n+LL | fn foo(x:fn(&u8, &u8), y: Vec<&u8>, z: &u8) {\n+   |                        - help: consider changing this to be mutable: `mut y`\n LL |   y.push(z); //~ ERROR lifetime mismatch\n    |   ^ cannot borrow as mutable\n "}, {"sha": "a61d49fc953dbd9eb2ba896d5eddccca5c8179b4", "filename": "src/test/ui/lifetime-errors/ex3-both-anon-regions-using-trait-objects.nll.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-using-trait-objects.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-using-trait-objects.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-using-trait-objects.nll.stderr?ref=f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b", "patch": "@@ -15,6 +15,8 @@ LL |   y.push(z); //~ ERROR lifetime mismatch\n error[E0596]: cannot borrow immutable item `y` as mutable\n   --> $DIR/ex3-both-anon-regions-using-trait-objects.rs:11:3\n    |\n+LL | fn foo(x:Box<Fn(&u8, &u8)> , y: Vec<&u8>, z: &u8) {\n+   |                              - help: consider changing this to be mutable: `mut y`\n LL |   y.push(z); //~ ERROR lifetime mismatch\n    |   ^ cannot borrow as mutable\n "}, {"sha": "0620235371a3928126d3037102188b5002ed61b6", "filename": "src/test/ui/lifetime-errors/liveness-assign-imm-local-notes.stderr", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b/src%2Ftest%2Fui%2Flifetime-errors%2Fliveness-assign-imm-local-notes.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b/src%2Ftest%2Fui%2Flifetime-errors%2Fliveness-assign-imm-local-notes.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fliveness-assign-imm-local-notes.stderr?ref=f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b", "patch": "@@ -32,6 +32,9 @@ LL |             x = 2;      //~ ERROR (Ast) [E0384]\n error[E0384]: cannot assign twice to immutable variable `x` (Mir)\n   --> $DIR/liveness-assign-imm-local-notes.rs:23:9\n    |\n+LL |     let x;\n+   |         - consider changing this to `mut x`\n+...\n LL |         x = 2;\n    |         ----- first assignment to `x`\n LL |         x = 3;      //~ ERROR (Ast) [E0384]\n@@ -40,6 +43,9 @@ LL |         x = 3;      //~ ERROR (Ast) [E0384]\n error[E0384]: cannot assign twice to immutable variable `x` (Mir)\n   --> $DIR/liveness-assign-imm-local-notes.rs:35:13\n    |\n+LL |         let x;\n+   |             - consider changing this to `mut x`\n+...\n LL |             x = 2;\n    |             ----- first assignment to `x`\n LL |             x = 3;      //~ ERROR (Ast) [E0384]\n@@ -48,12 +54,18 @@ LL |             x = 3;      //~ ERROR (Ast) [E0384]\n error[E0384]: cannot assign twice to immutable variable `x` (Mir)\n   --> $DIR/liveness-assign-imm-local-notes.rs:45:13\n    |\n+LL |     let x;\n+   |         - consider changing this to `mut x`\n+...\n LL |             x = 1;      //~ ERROR (Ast) [E0384]\n    |             ^^^^^ cannot assign twice to immutable variable\n \n error[E0384]: cannot assign twice to immutable variable `x` (Mir)\n   --> $DIR/liveness-assign-imm-local-notes.rs:48:13\n    |\n+LL |     let x;\n+   |         - consider changing this to `mut x`\n+...\n LL |             x = 1;      //~ ERROR (Ast) [E0384]\n    |             ----- first assignment to `x`\n ..."}, {"sha": "213eddee720d3e081949e761f6762e0d9955b00a", "filename": "src/test/ui/macros/span-covering-argument-1.nll.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b/src%2Ftest%2Fui%2Fmacros%2Fspan-covering-argument-1.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b/src%2Ftest%2Fui%2Fmacros%2Fspan-covering-argument-1.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fspan-covering-argument-1.nll.stderr?ref=f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b", "patch": "@@ -1,6 +1,8 @@\n error[E0596]: cannot borrow immutable item `foo` as mutable\n   --> $DIR/span-covering-argument-1.rs:15:14\n    |\n+LL |             let $s = 0;\n+   |                 -- help: consider changing this to be mutable: `mut foo`\n LL |             *&mut $s = 0;\n    |              ^^^^^^^ cannot borrow as mutable\n ..."}, {"sha": "96e9f1554144788a6ecbaf1ccf0a15a6f85fea83", "filename": "src/test/ui/nll/issue-47388.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b/src%2Ftest%2Fui%2Fnll%2Fissue-47388.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b/src%2Ftest%2Fui%2Fnll%2Fissue-47388.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-47388.stderr?ref=f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b", "patch": "@@ -1,4 +1,4 @@\n-error[E0594]: cannot assign to data in a `&` reference\n+error[E0594]: cannot assign to `fancy_ref.num` which is behind a `&` reference\n   --> $DIR/issue-47388.rs:18:5\n    |\n LL |     let fancy_ref = &(&mut fancy);"}, {"sha": "c045720a84013204703a6412cb5cfe4ff3786abb", "filename": "src/test/ui/reassign-ref-mut.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b/src%2Ftest%2Fui%2Freassign-ref-mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b/src%2Ftest%2Fui%2Freassign-ref-mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Freassign-ref-mut.rs?ref=f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Tests how we behave when the user attempts to mutate an immutable\n+// binding that was introduced by either `ref` or `ref mut`\n+// patterns.\n+//\n+// Such bindings cannot be made mutable via the mere addition of the\n+// `mut` keyword, and thus we want to check that the compiler does not\n+// suggest doing so.\n+\n+fn main() {\n+    let (mut one_two, mut three_four) = ((1, 2), (3, 4));\n+    let &mut (ref a, ref mut b) = &mut one_two;\n+    a = &three_four.0;\n+    //~^ ERROR cannot assign twice to immutable variable `a` [E0384]\n+    b = &mut three_four.1;\n+    //~^ ERROR cannot assign twice to immutable variable `b` [E0384]\n+}"}, {"sha": "bf627dde720b1953c10da76dc315d1c768fa92a7", "filename": "src/test/ui/reassign-ref-mut.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b/src%2Ftest%2Fui%2Freassign-ref-mut.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b/src%2Ftest%2Fui%2Freassign-ref-mut.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Freassign-ref-mut.stderr?ref=f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b", "patch": "@@ -0,0 +1,20 @@\n+error[E0384]: cannot assign twice to immutable variable `a`\n+  --> $DIR/reassign-ref-mut.rs:22:5\n+   |\n+LL |     let &mut (ref a, ref mut b) = &mut one_two;\n+   |               ----- first assignment to `a`\n+LL |     a = &three_four.0;\n+   |     ^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n+\n+error[E0384]: cannot assign twice to immutable variable `b`\n+  --> $DIR/reassign-ref-mut.rs:24:5\n+   |\n+LL |     let &mut (ref a, ref mut b) = &mut one_two;\n+   |                      --------- first assignment to `b`\n+...\n+LL |     b = &mut three_four.1;\n+   |     ^^^^^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0384`."}, {"sha": "8aa7e8a417c2bea3aeb5d778768278e29720e664", "filename": "src/test/ui/rfc-2005-default-binding-mode/enum.nll.stderr", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b/src%2Ftest%2Fui%2Frfc-2005-default-binding-mode%2Fenum.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b/src%2Ftest%2Fui%2Frfc-2005-default-binding-mode%2Fenum.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2005-default-binding-mode%2Fenum.nll.stderr?ref=f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b", "patch": "@@ -1,26 +1,20 @@\n-error[E0594]: cannot assign to data in a `&` reference\n+error[E0594]: cannot assign to `*x` which is behind a `&` reference\n   --> $DIR/enum.rs:19:5\n    |\n-LL |     let Wrap(x) = &Wrap(3);\n-   |              - help: consider changing this to be a mutable reference: `&mut`\n LL |     *x += 1; //~ ERROR cannot assign to immutable\n-   |     ^^^^^^^\n+   |     ^^^^^^^ cannot assign\n \n-error[E0594]: cannot assign to data in a `&` reference\n+error[E0594]: cannot assign to `*x` which is behind a `&` reference\n   --> $DIR/enum.rs:23:9\n    |\n-LL |     if let Some(x) = &Some(3) {\n-   |                 - help: consider changing this to be a mutable reference: `&mut`\n LL |         *x += 1; //~ ERROR cannot assign to immutable\n-   |         ^^^^^^^\n+   |         ^^^^^^^ cannot assign\n \n-error[E0594]: cannot assign to data in a `&` reference\n+error[E0594]: cannot assign to `*x` which is behind a `&` reference\n   --> $DIR/enum.rs:29:9\n    |\n-LL |     while let Some(x) = &Some(3) {\n-   |                    - help: consider changing this to be a mutable reference: `&mut`\n LL |         *x += 1; //~ ERROR cannot assign to immutable\n-   |         ^^^^^^^\n+   |         ^^^^^^^ cannot assign\n \n error: aborting due to 3 previous errors\n "}, {"sha": "4e00dec761621ac58d317944e99a1275c270ea28", "filename": "src/test/ui/rfc-2005-default-binding-mode/explicit-mut.nll.stderr", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b/src%2Ftest%2Fui%2Frfc-2005-default-binding-mode%2Fexplicit-mut.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b/src%2Ftest%2Fui%2Frfc-2005-default-binding-mode%2Fexplicit-mut.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2005-default-binding-mode%2Fexplicit-mut.nll.stderr?ref=f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b", "patch": "@@ -1,26 +1,20 @@\n-error[E0594]: cannot assign to data in a `&` reference\n+error[E0594]: cannot assign to `*n` which is behind a `&` reference\n   --> $DIR/explicit-mut.rs:17:13\n    |\n-LL |         Some(n) => {\n-   |              - help: consider changing this to be a mutable reference: `&mut`\n LL |             *n += 1; //~ ERROR cannot assign to immutable\n-   |             ^^^^^^^\n+   |             ^^^^^^^ cannot assign\n \n-error[E0594]: cannot assign to data in a `&` reference\n+error[E0594]: cannot assign to `*n` which is behind a `&` reference\n   --> $DIR/explicit-mut.rs:25:13\n    |\n-LL |         Some(n) => {\n-   |              - help: consider changing this to be a mutable reference: `&mut`\n LL |             *n += 1; //~ ERROR cannot assign to immutable\n-   |             ^^^^^^^\n+   |             ^^^^^^^ cannot assign\n \n-error[E0594]: cannot assign to data in a `&` reference\n+error[E0594]: cannot assign to `*n` which is behind a `&` reference\n   --> $DIR/explicit-mut.rs:33:13\n    |\n-LL |         Some(n) => {\n-   |              - help: consider changing this to be a mutable reference: `&mut`\n LL |             *n += 1; //~ ERROR cannot assign to immutable\n-   |             ^^^^^^^\n+   |             ^^^^^^^ cannot assign\n \n error: aborting due to 3 previous errors\n "}, {"sha": "3282fbba6c5cfea76aca5fd6733a04fc25e9b21f", "filename": "src/test/ui/span/borrowck-borrow-overloaded-auto-deref-mut.nll.stderr", "status": "modified", "additions": 20, "deletions": 4, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b/src%2Ftest%2Fui%2Fspan%2Fborrowck-borrow-overloaded-auto-deref-mut.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b/src%2Ftest%2Fui%2Fspan%2Fborrowck-borrow-overloaded-auto-deref-mut.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fborrowck-borrow-overloaded-auto-deref-mut.nll.stderr?ref=f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b", "patch": "@@ -1,50 +1,66 @@\n error[E0596]: cannot borrow immutable item `x` as mutable\n   --> $DIR/borrowck-borrow-overloaded-auto-deref-mut.rs:63:24\n    |\n+LL | fn deref_mut_field1(x: Own<Point>) {\n+   |                     - help: consider changing this to be mutable: `mut x`\n LL |     let __isize = &mut x.y; //~ ERROR cannot borrow\n    |                        ^ cannot borrow as mutable\n \n error[E0596]: cannot borrow immutable item `*x` as mutable\n   --> $DIR/borrowck-borrow-overloaded-auto-deref-mut.rs:75:10\n    |\n+LL | fn deref_extend_mut_field1(x: &Own<Point>) -> &mut isize {\n+   |                               ----------- help: consider changing this to be a mutable reference: `&mut Own<Point>`\n LL |     &mut x.y //~ ERROR cannot borrow\n-   |          ^ cannot borrow as mutable\n+   |          ^ `x` is a `&` reference, so the data it refers to cannot be borrowed as mutable\n \n error[E0596]: cannot borrow immutable item `x` as mutable\n   --> $DIR/borrowck-borrow-overloaded-auto-deref-mut.rs:98:5\n    |\n+LL | fn assign_field1<'a>(x: Own<Point>) {\n+   |                      - help: consider changing this to be mutable: `mut x`\n LL |     x.y = 3; //~ ERROR cannot borrow\n    |     ^ cannot borrow as mutable\n \n error[E0596]: cannot borrow immutable item `*x` as mutable\n   --> $DIR/borrowck-borrow-overloaded-auto-deref-mut.rs:102:5\n    |\n+LL | fn assign_field2<'a>(x: &'a Own<Point>) {\n+   |                         -------------- help: consider changing this to be a mutable reference: `&mut Own<Point>`\n LL |     x.y = 3; //~ ERROR cannot borrow\n-   |     ^ cannot borrow as mutable\n+   |     ^ `x` is a `&` reference, so the data it refers to cannot be borrowed as mutable\n \n error[E0596]: cannot borrow immutable item `x` as mutable\n   --> $DIR/borrowck-borrow-overloaded-auto-deref-mut.rs:119:5\n    |\n+LL | fn deref_mut_method1(x: Own<Point>) {\n+   |                      - help: consider changing this to be mutable: `mut x`\n LL |     x.set(0, 0); //~ ERROR cannot borrow\n    |     ^ cannot borrow as mutable\n \n error[E0596]: cannot borrow immutable item `*x` as mutable\n   --> $DIR/borrowck-borrow-overloaded-auto-deref-mut.rs:131:5\n    |\n+LL | fn deref_extend_mut_method1(x: &Own<Point>) -> &mut isize {\n+   |                                ----------- help: consider changing this to be a mutable reference: `&mut Own<Point>`\n LL |     x.y_mut() //~ ERROR cannot borrow\n-   |     ^ cannot borrow as mutable\n+   |     ^ `x` is a `&` reference, so the data it refers to cannot be borrowed as mutable\n \n error[E0596]: cannot borrow immutable item `x` as mutable\n   --> $DIR/borrowck-borrow-overloaded-auto-deref-mut.rs:139:6\n    |\n+LL | fn assign_method1<'a>(x: Own<Point>) {\n+   |                       - help: consider changing this to be mutable: `mut x`\n LL |     *x.y_mut() = 3; //~ ERROR cannot borrow\n    |      ^ cannot borrow as mutable\n \n error[E0596]: cannot borrow immutable item `*x` as mutable\n   --> $DIR/borrowck-borrow-overloaded-auto-deref-mut.rs:143:6\n    |\n+LL | fn assign_method2<'a>(x: &'a Own<Point>) {\n+   |                          -------------- help: consider changing this to be a mutable reference: `&mut Own<Point>`\n LL |     *x.y_mut() = 3; //~ ERROR cannot borrow\n-   |      ^ cannot borrow as mutable\n+   |      ^ `x` is a `&` reference, so the data it refers to cannot be borrowed as mutable\n \n error: aborting due to 8 previous errors\n "}, {"sha": "0b1bfd8cee6730821670893decd6197ff80cf59b", "filename": "src/test/ui/span/borrowck-borrow-overloaded-deref-mut.nll.stderr", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b/src%2Ftest%2Fui%2Fspan%2Fborrowck-borrow-overloaded-deref-mut.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b/src%2Ftest%2Fui%2Fspan%2Fborrowck-borrow-overloaded-deref-mut.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fborrowck-borrow-overloaded-deref-mut.nll.stderr?ref=f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b", "patch": "@@ -1,26 +1,34 @@\n error[E0596]: cannot borrow immutable item `x` as mutable\n   --> $DIR/borrowck-borrow-overloaded-deref-mut.rs:39:25\n    |\n+LL | fn deref_mut1(x: Own<isize>) {\n+   |               - help: consider changing this to be mutable: `mut x`\n LL |     let __isize = &mut *x; //~ ERROR cannot borrow\n    |                         ^ cannot borrow as mutable\n \n error[E0596]: cannot borrow immutable item `*x` as mutable\n   --> $DIR/borrowck-borrow-overloaded-deref-mut.rs:51:11\n    |\n+LL | fn deref_extend_mut1<'a>(x: &'a Own<isize>) -> &'a mut isize {\n+   |                             -------------- help: consider changing this to be a mutable reference: `&mut Own<isize>`\n LL |     &mut **x //~ ERROR cannot borrow\n-   |           ^^ cannot borrow as mutable\n+   |           ^^ `x` is a `&` reference, so the data it refers to cannot be borrowed as mutable\n \n error[E0596]: cannot borrow immutable item `x` as mutable\n   --> $DIR/borrowck-borrow-overloaded-deref-mut.rs:59:6\n    |\n+LL | fn assign1<'a>(x: Own<isize>) {\n+   |                - help: consider changing this to be mutable: `mut x`\n LL |     *x = 3; //~ ERROR cannot borrow\n    |      ^ cannot borrow as mutable\n \n error[E0596]: cannot borrow immutable item `*x` as mutable\n   --> $DIR/borrowck-borrow-overloaded-deref-mut.rs:63:6\n    |\n+LL | fn assign2<'a>(x: &'a Own<isize>) {\n+   |                   -------------- help: consider changing this to be a mutable reference: `&mut Own<isize>`\n LL |     **x = 3; //~ ERROR cannot borrow\n-   |      ^^ cannot borrow as mutable\n+   |      ^^ `x` is a `&` reference, so the data it refers to cannot be borrowed as mutable\n \n error: aborting due to 4 previous errors\n "}, {"sha": "c4bdef21de4bacdf5698a5c6ee99b7877ae1f993", "filename": "src/test/ui/span/borrowck-call-is-borrow-issue-12224.nll.stderr", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b/src%2Ftest%2Fui%2Fspan%2Fborrowck-call-is-borrow-issue-12224.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b/src%2Ftest%2Fui%2Fspan%2Fborrowck-call-is-borrow-issue-12224.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fborrowck-call-is-borrow-issue-12224.nll.stderr?ref=f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b", "patch": "@@ -15,16 +15,18 @@ LL | |     }));\n error[E0596]: cannot borrow immutable item `*f` as mutable\n   --> $DIR/borrowck-call-is-borrow-issue-12224.rs:35:5\n    |\n+LL | fn test2<F>(f: &F) where F: FnMut() {\n+   |                -- help: consider changing this to be a mutable reference: `&mut F`\n LL |     (*f)();\n-   |     ^^^^ cannot borrow as mutable\n+   |     ^^^^ `f` is a `&` reference, so the data it refers to cannot be borrowed as mutable\n \n error[E0596]: cannot borrow immutable item `*f.f` as mutable\n   --> $DIR/borrowck-call-is-borrow-issue-12224.rs:44:5\n    |\n+LL | fn test4(f: &Test) {\n+   |             ----- help: consider changing this to be a mutable reference: `&mut Test<'_>`\n LL |     f.f.call_mut(())\n-   |     ^^^ cannot borrow as mutable\n-   |\n-   = note: the value which is causing this path not to be mutable is...: `*f`\n+   |     ^^^ `f` is a `&` reference, so the data it refers to cannot be borrowed as mutable\n \n error[E0507]: cannot move out of borrowed content\n   --> $DIR/borrowck-call-is-borrow-issue-12224.rs:66:13"}, {"sha": "0bc614589e3d2ef1d0361fa8db4ae37bd736b6ab", "filename": "src/test/ui/span/borrowck-call-method-from-mut-aliasable.nll.stderr", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b/src%2Ftest%2Fui%2Fspan%2Fborrowck-call-method-from-mut-aliasable.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b/src%2Ftest%2Fui%2Fspan%2Fborrowck-call-method-from-mut-aliasable.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fborrowck-call-method-from-mut-aliasable.nll.stderr?ref=f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b", "patch": "@@ -1,8 +1,11 @@\n error[E0596]: cannot borrow immutable item `*x` as mutable\n   --> $DIR/borrowck-call-method-from-mut-aliasable.rs:27:5\n    |\n+LL | fn b(x: &Foo) {\n+   |         ---- help: consider changing this to be a mutable reference: `&mut Foo`\n+LL |     x.f();\n LL |     x.h(); //~ ERROR cannot borrow\n-   |     ^ cannot borrow as mutable\n+   |     ^ `x` is a `&` reference, so the data it refers to cannot be borrowed as mutable\n \n error: aborting due to previous error\n "}, {"sha": "1cb2c92833c1634ab689cadce02bf38b98765fb1", "filename": "src/test/ui/span/borrowck-fn-in-const-b.nll.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b/src%2Ftest%2Fui%2Fspan%2Fborrowck-fn-in-const-b.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b/src%2Ftest%2Fui%2Fspan%2Fborrowck-fn-in-const-b.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fborrowck-fn-in-const-b.nll.stderr?ref=f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b", "patch": "@@ -1,8 +1,10 @@\n error[E0596]: cannot borrow immutable item `*x` as mutable\n   --> $DIR/borrowck-fn-in-const-b.rs:17:9\n    |\n+LL |     fn broken(x: &Vec<String>) {\n+   |                  ------------ help: consider changing this to be a mutable reference: `&mut std::vec::Vec<std::string::String>`\n LL |         x.push(format!(\"this is broken\"));\n-   |         ^ cannot borrow as mutable\n+   |         ^ `x` is a `&` reference, so the data it refers to cannot be borrowed as mutable\n \n error: aborting due to previous error\n "}, {"sha": "cf615eed55691d3fc1db747ee184707042d3c7b8", "filename": "src/test/ui/span/borrowck-object-mutability.nll.stderr", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b/src%2Ftest%2Fui%2Fspan%2Fborrowck-object-mutability.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b/src%2Ftest%2Fui%2Fspan%2Fborrowck-object-mutability.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fborrowck-object-mutability.nll.stderr?ref=f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b", "patch": "@@ -1,16 +1,20 @@\n error[E0596]: cannot borrow immutable item `*x` as mutable\n   --> $DIR/borrowck-object-mutability.rs:19:5\n    |\n+LL | fn borrowed_receiver(x: &Foo) {\n+   |                         ---- help: consider changing this to be a mutable reference: `&mut Foo`\n+LL |     x.borrowed();\n LL |     x.borrowed_mut(); //~ ERROR cannot borrow\n-   |     ^ cannot borrow as mutable\n+   |     ^ `x` is a `&` reference, so the data it refers to cannot be borrowed as mutable\n \n error[E0596]: cannot borrow immutable item `*x` as mutable\n   --> $DIR/borrowck-object-mutability.rs:29:5\n    |\n+LL | fn owned_receiver(x: Box<Foo>) {\n+   |                   - help: consider changing this to be mutable: `mut x`\n+LL |     x.borrowed();\n LL |     x.borrowed_mut(); //~ ERROR cannot borrow\n    |     ^ cannot borrow as mutable\n-   |\n-   = note: the value which is causing this path not to be mutable is...: `x`\n \n error: aborting due to 2 previous errors\n "}, {"sha": "cd19059fdae32d5121e3621de64dc28c952d7ef9", "filename": "src/test/ui/span/mut-arg-hint.nll.stderr", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b/src%2Ftest%2Fui%2Fspan%2Fmut-arg-hint.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b/src%2Ftest%2Fui%2Fspan%2Fmut-arg-hint.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fmut-arg-hint.nll.stderr?ref=f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b", "patch": "@@ -1,20 +1,26 @@\n error[E0596]: cannot borrow immutable item `*a` as mutable\n   --> $DIR/mut-arg-hint.rs:13:9\n    |\n+LL |     fn foo(mut a: &String) {\n+   |                   ------- help: consider changing this to be a mutable reference: `&mut std::string::String`\n LL |         a.push_str(\"bar\"); //~ ERROR cannot borrow immutable borrowed content\n-   |         ^ cannot borrow as mutable\n+   |         ^ `a` is a `&` reference, so the data it refers to cannot be borrowed as mutable\n \n error[E0596]: cannot borrow immutable item `*a` as mutable\n   --> $DIR/mut-arg-hint.rs:18:5\n    |\n+LL | pub fn foo<'a>(mut a: &'a String) {\n+   |                       ---------- help: consider changing this to be a mutable reference: `&mut std::string::String`\n LL |     a.push_str(\"foo\"); //~ ERROR cannot borrow immutable borrowed content\n-   |     ^ cannot borrow as mutable\n+   |     ^ `a` is a `&` reference, so the data it refers to cannot be borrowed as mutable\n \n error[E0596]: cannot borrow immutable item `*a` as mutable\n   --> $DIR/mut-arg-hint.rs:25:9\n    |\n+LL |     pub fn foo(mut a: &String) {\n+   |                       ------- help: consider changing this to be a mutable reference: `&mut std::string::String`\n LL |         a.push_str(\"foo\"); //~ ERROR cannot borrow immutable borrowed content\n-   |         ^ cannot borrow as mutable\n+   |         ^ `a` is a `&` reference, so the data it refers to cannot be borrowed as mutable\n \n error: aborting due to 3 previous errors\n "}, {"sha": "335ccefe8a0b12096d3655d1343adf11f9232635", "filename": "src/test/ui/suggestions/closure-immutable-outer-variable.nll.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b/src%2Ftest%2Fui%2Fsuggestions%2Fclosure-immutable-outer-variable.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b/src%2Ftest%2Fui%2Fsuggestions%2Fclosure-immutable-outer-variable.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fclosure-immutable-outer-variable.nll.stderr?ref=f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b", "patch": "@@ -2,7 +2,7 @@ error[E0594]: cannot assign to immutable item `y`\n   --> $DIR/closure-immutable-outer-variable.rs:21:26\n    |\n LL |     foo(Box::new(move || y = false) as Box<_>); //~ ERROR cannot assign to captured outer variable\n-   |                          ^^^^^^^^^ cannot mutate\n+   |                          ^^^^^^^^^ cannot assign\n \n error: aborting due to previous error\n "}, {"sha": "7ef21d3720d8833ed9180789d0907889206f7f99", "filename": "src/test/ui/suggestions/fn-closure-mutable-capture.nll.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b/src%2Ftest%2Fui%2Fsuggestions%2Ffn-closure-mutable-capture.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b/src%2Ftest%2Fui%2Fsuggestions%2Ffn-closure-mutable-capture.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Ffn-closure-mutable-capture.nll.stderr?ref=f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b", "patch": "@@ -1,8 +1,8 @@\n-error[E0594]: cannot assign to immutable item `x`\n+error[E0594]: cannot assign to `x` which is behind a `&` reference\n   --> $DIR/fn-closure-mutable-capture.rs:15:17\n    |\n LL |     bar(move || x = 1);\n-   |                 ^^^^^ cannot mutate\n+   |                 ^^^^^ cannot assign\n \n error: aborting due to previous error\n "}, {"sha": "1a36b0c4839b6b79a59d317c8518df502f9abe31", "filename": "src/test/ui/trivial-bounds-inconsistent-copy-reborrow.nll.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b/src%2Ftest%2Fui%2Ftrivial-bounds-inconsistent-copy-reborrow.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b/src%2Ftest%2Fui%2Ftrivial-bounds-inconsistent-copy-reborrow.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftrivial-bounds-inconsistent-copy-reborrow.nll.stderr?ref=f28c7aef7fbff1909c2d0257186cd7a5f0c6aa4b", "patch": "@@ -1,18 +1,18 @@\n error[E0596]: cannot borrow immutable item `**t` as mutable\n   --> $DIR/trivial-bounds-inconsistent-copy-reborrow.rs:16:5\n    |\n+LL | fn reborrow_mut<'a>(t: &'a &'a mut i32) -> &'a mut i32 where &'a mut i32: Copy {\n+   |                        --------------- help: consider changing this to be a mutable reference: `&mut &mut i32`\n LL |     *t //~ ERROR\n-   |     ^^ cannot borrow as mutable\n-   |\n-   = note: the value which is causing this path not to be mutable is...: `*t`\n+   |     ^^ `t` is a `&` reference, so the data it refers to cannot be borrowed as mutable\n \n error[E0596]: cannot borrow immutable item `**t` as mutable\n   --> $DIR/trivial-bounds-inconsistent-copy-reborrow.rs:20:6\n    |\n+LL | fn copy_reborrow_mut<'a>(t: &'a &'a mut i32) -> &'a mut i32 where &'a mut i32: Copy {\n+   |                             --------------- help: consider changing this to be a mutable reference: `&mut &mut i32`\n LL |     {*t} //~ ERROR\n-   |      ^^ cannot borrow as mutable\n-   |\n-   = note: the value which is causing this path not to be mutable is...: `*t`\n+   |      ^^ `t` is a `&` reference, so the data it refers to cannot be borrowed as mutable\n \n error: aborting due to 2 previous errors\n "}]}