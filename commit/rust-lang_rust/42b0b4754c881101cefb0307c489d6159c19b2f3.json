{"sha": "42b0b4754c881101cefb0307c489d6159c19b2f3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQyYjBiNDc1NGM4ODExMDFjZWZiMDMwN2M0ODlkNjE1OWMxOWIyZjM=", "commit": {"author": {"name": "Eduardo Broto", "email": "ebroto@tutanota.com", "date": "2020-05-01T20:37:14Z"}, "committer": {"name": "Eduardo Broto", "email": "ebroto@tutanota.com", "date": "2020-05-01T20:37:14Z"}, "message": "Apply suggestions from PR review", "tree": {"sha": "50c28d32fba31a1afcdc94c185ee89237f320743", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/50c28d32fba31a1afcdc94c185ee89237f320743"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/42b0b4754c881101cefb0307c489d6159c19b2f3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/42b0b4754c881101cefb0307c489d6159c19b2f3", "html_url": "https://github.com/rust-lang/rust/commit/42b0b4754c881101cefb0307c489d6159c19b2f3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/42b0b4754c881101cefb0307c489d6159c19b2f3/comments", "author": {"login": "ebroto", "id": 816908, "node_id": "MDQ6VXNlcjgxNjkwOA==", "avatar_url": "https://avatars.githubusercontent.com/u/816908?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ebroto", "html_url": "https://github.com/ebroto", "followers_url": "https://api.github.com/users/ebroto/followers", "following_url": "https://api.github.com/users/ebroto/following{/other_user}", "gists_url": "https://api.github.com/users/ebroto/gists{/gist_id}", "starred_url": "https://api.github.com/users/ebroto/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ebroto/subscriptions", "organizations_url": "https://api.github.com/users/ebroto/orgs", "repos_url": "https://api.github.com/users/ebroto/repos", "events_url": "https://api.github.com/users/ebroto/events{/privacy}", "received_events_url": "https://api.github.com/users/ebroto/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ebroto", "id": 816908, "node_id": "MDQ6VXNlcjgxNjkwOA==", "avatar_url": "https://avatars.githubusercontent.com/u/816908?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ebroto", "html_url": "https://github.com/ebroto", "followers_url": "https://api.github.com/users/ebroto/followers", "following_url": "https://api.github.com/users/ebroto/following{/other_user}", "gists_url": "https://api.github.com/users/ebroto/gists{/gist_id}", "starred_url": "https://api.github.com/users/ebroto/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ebroto/subscriptions", "organizations_url": "https://api.github.com/users/ebroto/orgs", "repos_url": "https://api.github.com/users/ebroto/repos", "events_url": "https://api.github.com/users/ebroto/events{/privacy}", "received_events_url": "https://api.github.com/users/ebroto/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f072ded3bf6286668ff8eade5b58e471dbe66f2a", "url": "https://api.github.com/repos/rust-lang/rust/commits/f072ded3bf6286668ff8eade5b58e471dbe66f2a", "html_url": "https://github.com/rust-lang/rust/commit/f072ded3bf6286668ff8eade5b58e471dbe66f2a"}], "stats": {"total": 204, "additions": 139, "deletions": 65}, "files": [{"sha": "a4273da1d74129d5409969ebc2519d6858e85479", "filename": "clippy_lints/src/manual_non_exhaustive.rs", "status": "modified", "additions": 45, "deletions": 39, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/42b0b4754c881101cefb0307c489d6159c19b2f3/clippy_lints%2Fsrc%2Fmanual_non_exhaustive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42b0b4754c881101cefb0307c489d6159c19b2f3/clippy_lints%2Fsrc%2Fmanual_non_exhaustive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmanual_non_exhaustive.rs?ref=42b0b4754c881101cefb0307c489d6159c19b2f3", "patch": "@@ -1,10 +1,11 @@\n use crate::utils::{snippet_opt, span_lint_and_then};\n use if_chain::if_chain;\n-use rustc_ast::ast::{Attribute, Ident, Item, ItemKind, StructField, TyKind, Variant, VariantData, VisibilityKind};\n+use rustc_ast::ast::{Attribute, Item, ItemKind, StructField, Variant, VariantData, VisibilityKind};\n use rustc_attr as attr;\n use rustc_errors::Applicability;\n use rustc_lint::{EarlyContext, EarlyLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::Span;\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for manual implementations of the non-exhaustive pattern.\n@@ -90,29 +91,30 @@ fn check_manual_non_exhaustive_enum(cx: &EarlyContext<'_>, item: &Item, variants\n     }\n \n     if_chain! {\n-        if !attr::contains_name(&item.attrs, sym!(non_exhaustive));\n-        let markers = variants.iter().filter(|v| is_non_exhaustive_marker(v)).count();\n-        if markers == 1 && variants.len() > markers;\n-        if let Some(variant) = variants.last();\n-        if is_non_exhaustive_marker(variant);\n+        let mut markers = variants.iter().filter(|v| is_non_exhaustive_marker(v));\n+        if let Some(marker) = markers.next();\n+        if markers.count() == 0 && variants.len() > 1;\n         then {\n             span_lint_and_then(\n                 cx,\n                 MANUAL_NON_EXHAUSTIVE,\n                 item.span,\n                 \"this seems like a manual implementation of the non-exhaustive pattern\",\n                 |diag| {\n-                    let header_span = cx.sess.source_map().span_until_char(item.span, '{');\n-\n-                    if let Some(snippet) = snippet_opt(cx, header_span) {\n-                        diag.span_suggestion(\n-                            item.span,\n-                            \"add the attribute\",\n-                            format!(\"#[non_exhaustive] {}\", snippet),\n-                            Applicability::Unspecified,\n-                        );\n-                        diag.span_help(variant.span, \"and remove this variant\");\n+                    if_chain! {\n+                        if !attr::contains_name(&item.attrs, sym!(non_exhaustive));\n+                        let header_span = cx.sess.source_map().span_until_char(item.span, '{');\n+                        if let Some(snippet) = snippet_opt(cx, header_span);\n+                        then {\n+                            diag.span_suggestion(\n+                                header_span,\n+                                \"add the attribute\",\n+                                format!(\"#[non_exhaustive] {}\", snippet),\n+                                Applicability::Unspecified,\n+                            );\n+                        }\n                     }\n+                    diag.span_help(marker.span, \"remove this variant\");\n                 });\n         }\n     }\n@@ -123,44 +125,48 @@ fn check_manual_non_exhaustive_struct(cx: &EarlyContext<'_>, item: &Item, data:\n         matches!(field.vis.node, VisibilityKind::Inherited)\n     }\n \n-    fn is_non_exhaustive_marker(name: &Option<Ident>) -> bool {\n-        name.map(|n| n.as_str().starts_with('_')).unwrap_or(true)\n+    fn is_non_exhaustive_marker(field: &StructField) -> bool {\n+        is_private(field) && field.ty.kind.is_unit() && field.ident.map_or(true, |n| n.as_str().starts_with('_'))\n+    }\n+\n+    fn find_header_span(cx: &EarlyContext<'_>, item: &Item, data: &VariantData) -> Span {\n+        let delimiter = match data {\n+            VariantData::Struct(..) => '{',\n+            VariantData::Tuple(..) => '(',\n+            _ => unreachable!(\"`VariantData::Unit` is already handled above\"),\n+        };\n+\n+        cx.sess.source_map().span_until_char(item.span, delimiter)\n     }\n \n     let fields = data.fields();\n     let private_fields = fields.iter().filter(|f| is_private(f)).count();\n     let public_fields = fields.iter().filter(|f| f.vis.node.is_pub()).count();\n \n     if_chain! {\n-        if !attr::contains_name(&item.attrs, sym!(non_exhaustive));\n-        if private_fields == 1 && public_fields >= private_fields && public_fields == fields.len() - 1;\n-        if let Some(field) = fields.iter().find(|f| is_private(f));\n-        if is_non_exhaustive_marker(&field.ident);\n-        if let TyKind::Tup(tup_fields) = &field.ty.kind;\n-        if tup_fields.is_empty();\n+        if private_fields == 1 && public_fields >= 1 && public_fields == fields.len() - 1;\n+        if let Some(marker) = fields.iter().find(|f| is_non_exhaustive_marker(f));\n         then {\n             span_lint_and_then(\n                 cx,\n                 MANUAL_NON_EXHAUSTIVE,\n                 item.span,\n                 \"this seems like a manual implementation of the non-exhaustive pattern\",\n                 |diag| {\n-                    let delimiter = match data {\n-                        VariantData::Struct(..) => '{',\n-                        VariantData::Tuple(..) => '(',\n-                        _ => unreachable!(),\n-                    };\n-                    let header_span = cx.sess.source_map().span_until_char(item.span, delimiter);\n-\n-                    if let Some(snippet) = snippet_opt(cx, header_span) {\n-                        diag.span_suggestion(\n-                            item.span,\n-                            \"add the attribute\",\n-                            format!(\"#[non_exhaustive] {}\", snippet),\n-                            Applicability::Unspecified,\n-                        );\n-                        diag.span_help(field.span, \"and remove this field\");\n+                    if_chain! {\n+                        if !attr::contains_name(&item.attrs, sym!(non_exhaustive));\n+                        let header_span = find_header_span(cx, item, data);\n+                        if let Some(snippet) = snippet_opt(cx, header_span);\n+                        then {\n+                            diag.span_suggestion(\n+                                header_span,\n+                                \"add the attribute\",\n+                                format!(\"#[non_exhaustive] {}\", snippet),\n+                                Applicability::Unspecified,\n+                            );\n+                        }\n                     }\n+                    diag.span_help(marker.span, \"remove this field\");\n                 });\n         }\n     }"}, {"sha": "7a788f4852072022b393541e63edae6bf0d474da", "filename": "tests/ui/manual_non_exhaustive.rs", "status": "modified", "additions": 26, "deletions": 13, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/42b0b4754c881101cefb0307c489d6159c19b2f3/tests%2Fui%2Fmanual_non_exhaustive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42b0b4754c881101cefb0307c489d6159c19b2f3/tests%2Fui%2Fmanual_non_exhaustive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_non_exhaustive.rs?ref=42b0b4754c881101cefb0307c489d6159c19b2f3", "patch": "@@ -9,7 +9,16 @@ mod enums {\n         _C,\n     }\n \n-    // last variant does not have doc hidden attribute, should be ignored\n+    // user forgot to remove the marker\n+    #[non_exhaustive]\n+    enum Ep {\n+        A,\n+        B,\n+        #[doc(hidden)]\n+        _C,\n+    }\n+\n+    // marker variant does not have doc hidden attribute, should be ignored\n     enum NoDocHidden {\n         A,\n         B,\n@@ -32,21 +41,13 @@ mod enums {\n         _C(bool),\n     }\n \n-    // variant with doc hidden is not the last one, should be ignored\n-    enum NotLast {\n-        A,\n-        #[doc(hidden)]\n-        _B,\n-        C,\n-    }\n-\n     // variant with doc hidden is the only one, should be ignored\n     enum OnlyMarker {\n         #[doc(hidden)]\n         _A,\n     }\n \n-    // variant with multiple non-exhaustive \"markers\", should be ignored\n+    // variant with multiple markers, should be ignored\n     enum MultipleMarkers {\n         A,\n         #[doc(hidden)]\n@@ -55,7 +56,7 @@ mod enums {\n         _C,\n     }\n \n-    // already non_exhaustive, should be ignored\n+    // already non_exhaustive and no markers, should be ignored\n     #[non_exhaustive]\n     enum NonExhaustive {\n         A,\n@@ -70,6 +71,14 @@ mod structs {\n         _c: (),\n     }\n \n+    // user forgot to remove the private field\n+    #[non_exhaustive]\n+    struct Sp {\n+        pub a: i32,\n+        pub b: i32,\n+        _c: (),\n+    }\n+\n     // some other fields are private, should be ignored\n     struct PrivateFields {\n         a: i32,\n@@ -96,7 +105,7 @@ mod structs {\n         _a: (),\n     }\n \n-    // already non exhaustive, should be ignored\n+    // already non exhaustive and no private fields, should be ignored\n     #[non_exhaustive]\n     struct NonExhaustive {\n         pub a: i32,\n@@ -107,6 +116,10 @@ mod structs {\n mod tuple_structs {\n     struct T(pub i32, pub i32, ());\n \n+    // user forgot to remove the private field\n+    #[non_exhaustive]\n+    struct Tp(pub i32, pub i32, ());\n+\n     // some other fields are private, should be ignored\n     struct PrivateFields(pub i32, i32, ());\n \n@@ -116,7 +129,7 @@ mod tuple_structs {\n     // private field is the only field, should be ignored\n     struct OnlyMarker(());\n \n-    // already non exhaustive, should be ignored\n+    // already non exhaustive and no private fields, should be ignored\n     #[non_exhaustive]\n     struct NonExhaustive(pub i32, pub i32);\n }"}, {"sha": "613c5e8ca1d45b38ec58c9dfc403f4b5abd37e04", "filename": "tests/ui/manual_non_exhaustive.stderr", "status": "modified", "additions": 68, "deletions": 13, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/42b0b4754c881101cefb0307c489d6159c19b2f3/tests%2Fui%2Fmanual_non_exhaustive.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/42b0b4754c881101cefb0307c489d6159c19b2f3/tests%2Fui%2Fmanual_non_exhaustive.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_non_exhaustive.stderr?ref=42b0b4754c881101cefb0307c489d6159c19b2f3", "patch": "@@ -1,48 +1,103 @@\n error: this seems like a manual implementation of the non-exhaustive pattern\n   --> $DIR/manual_non_exhaustive.rs:5:5\n    |\n-LL | /     enum E {\n+LL |       enum E {\n+   |       ^-----\n+   |       |\n+   |  _____help: add the attribute: `#[non_exhaustive] enum E`\n+   | |\n LL | |         A,\n LL | |         B,\n LL | |         #[doc(hidden)]\n LL | |         _C,\n LL | |     }\n-   | |_____^ help: add the attribute: `#[non_exhaustive] enum E`\n+   | |_____^\n    |\n    = note: `-D clippy::manual-non-exhaustive` implied by `-D warnings`\n-help: and remove this variant\n+help: remove this variant\n   --> $DIR/manual_non_exhaustive.rs:9:9\n    |\n LL |         _C,\n    |         ^^\n \n error: this seems like a manual implementation of the non-exhaustive pattern\n-  --> $DIR/manual_non_exhaustive.rs:67:5\n+  --> $DIR/manual_non_exhaustive.rs:14:5\n    |\n-LL | /     struct S {\n+LL | /     enum Ep {\n+LL | |         A,\n+LL | |         B,\n+LL | |         #[doc(hidden)]\n+LL | |         _C,\n+LL | |     }\n+   | |_____^\n+   |\n+help: remove this variant\n+  --> $DIR/manual_non_exhaustive.rs:18:9\n+   |\n+LL |         _C,\n+   |         ^^\n+\n+error: this seems like a manual implementation of the non-exhaustive pattern\n+  --> $DIR/manual_non_exhaustive.rs:68:5\n+   |\n+LL |       struct S {\n+   |       ^-------\n+   |       |\n+   |  _____help: add the attribute: `#[non_exhaustive] struct S`\n+   | |\n+LL | |         pub a: i32,\n+LL | |         pub b: i32,\n+LL | |         _c: (),\n+LL | |     }\n+   | |_____^\n+   |\n+help: remove this field\n+  --> $DIR/manual_non_exhaustive.rs:71:9\n+   |\n+LL |         _c: (),\n+   |         ^^^^^^\n+\n+error: this seems like a manual implementation of the non-exhaustive pattern\n+  --> $DIR/manual_non_exhaustive.rs:76:5\n+   |\n+LL | /     struct Sp {\n LL | |         pub a: i32,\n LL | |         pub b: i32,\n LL | |         _c: (),\n LL | |     }\n-   | |_____^ help: add the attribute: `#[non_exhaustive] struct S`\n+   | |_____^\n    |\n-help: and remove this field\n-  --> $DIR/manual_non_exhaustive.rs:70:9\n+help: remove this field\n+  --> $DIR/manual_non_exhaustive.rs:79:9\n    |\n LL |         _c: (),\n    |         ^^^^^^\n \n error: this seems like a manual implementation of the non-exhaustive pattern\n-  --> $DIR/manual_non_exhaustive.rs:108:5\n+  --> $DIR/manual_non_exhaustive.rs:117:5\n    |\n LL |     struct T(pub i32, pub i32, ());\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: add the attribute: `#[non_exhaustive] struct T`\n+   |     --------^^^^^^^^^^^^^^^^^^^^^^^\n+   |     |\n+   |     help: add the attribute: `#[non_exhaustive] struct T`\n    |\n-help: and remove this field\n-  --> $DIR/manual_non_exhaustive.rs:108:32\n+help: remove this field\n+  --> $DIR/manual_non_exhaustive.rs:117:32\n    |\n LL |     struct T(pub i32, pub i32, ());\n    |                                ^^\n \n-error: aborting due to 3 previous errors\n+error: this seems like a manual implementation of the non-exhaustive pattern\n+  --> $DIR/manual_non_exhaustive.rs:121:5\n+   |\n+LL |     struct Tp(pub i32, pub i32, ());\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: remove this field\n+  --> $DIR/manual_non_exhaustive.rs:121:33\n+   |\n+LL |     struct Tp(pub i32, pub i32, ());\n+   |                                 ^^\n+\n+error: aborting due to 6 previous errors\n "}]}