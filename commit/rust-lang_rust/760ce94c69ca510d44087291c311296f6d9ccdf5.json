{"sha": "760ce94c69ca510d44087291c311296f6d9ccdf5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc2MGNlOTRjNjljYTUxMGQ0NDA4NzI5MWMzMTEyOTZmNmQ5Y2NkZjU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-01-04T18:39:14Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-01-04T18:39:14Z"}, "message": "Auto merge of #67874 - Dylan-DPC:rollup-xy6bkoe, r=Dylan-DPC\n\nRollup of 4 pull requests\n\nSuccessful merges:\n\n - #67137 (libstd uses `core::panic::Location` where possible.)\n - #67709 (Introduce an option for disabling deduplication of diagnostics)\n - #67775 (Make \"use $crate\" a hard error)\n - #67812 (Tweak and extend internal BTreeMap documentation, including debug asserts.)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "a1268072a6fad12c2758f30c8409adb3ea087c20", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a1268072a6fad12c2758f30c8409adb3ea087c20"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/760ce94c69ca510d44087291c311296f6d9ccdf5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/760ce94c69ca510d44087291c311296f6d9ccdf5", "html_url": "https://github.com/rust-lang/rust/commit/760ce94c69ca510d44087291c311296f6d9ccdf5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/760ce94c69ca510d44087291c311296f6d9ccdf5/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cd8377d37e9bc47f9a5a982c41705a7800cbb51d", "url": "https://api.github.com/repos/rust-lang/rust/commits/cd8377d37e9bc47f9a5a982c41705a7800cbb51d", "html_url": "https://github.com/rust-lang/rust/commit/cd8377d37e9bc47f9a5a982c41705a7800cbb51d"}, {"sha": "0bbe11089ccdb575d3f7d5a6c83eb3d2810eef29", "url": "https://api.github.com/repos/rust-lang/rust/commits/0bbe11089ccdb575d3f7d5a6c83eb3d2810eef29", "html_url": "https://github.com/rust-lang/rust/commit/0bbe11089ccdb575d3f7d5a6c83eb3d2810eef29"}], "stats": {"total": 408, "additions": 211, "deletions": 197}, "files": [{"sha": "302c2bcd5e4a32100d243d893b86ddc39a70c1bf", "filename": "src/liballoc/collections/btree/map.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/760ce94c69ca510d44087291c311296f6d9ccdf5/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/760ce94c69ca510d44087291c311296f6d9ccdf5/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs?ref=760ce94c69ca510d44087291c311296f6d9ccdf5", "patch": "@@ -493,7 +493,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n         BTreeMap { root: node::Root::shared_empty_root(), length: 0 }\n     }\n \n-    /// Clears the map, removing all values.\n+    /// Clears the map, removing all elements.\n     ///\n     /// # Examples\n     ///\n@@ -2605,7 +2605,7 @@ impl<'a, K: Ord, V> OccupiedEntry<'a, K, V> {\n \n         // Handle underflow\n         let mut cur_node = small_leaf.forget_type();\n-        while cur_node.len() < node::CAPACITY / 2 {\n+        while cur_node.len() < node::MIN_LEN {\n             match handle_underfull_node(cur_node) {\n                 AtRoot => break,\n                 EmptyParent(_) => unreachable!(),"}, {"sha": "260e51d635dbbc87a0801932847a2aea668b393e", "filename": "src/liballoc/collections/btree/node.rs", "status": "modified", "additions": 37, "deletions": 13, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/760ce94c69ca510d44087291c311296f6d9ccdf5/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/760ce94c69ca510d44087291c311296f6d9ccdf5/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs?ref=760ce94c69ca510d44087291c311296f6d9ccdf5", "patch": "@@ -308,15 +308,15 @@ impl<K, V> Root<K, V> {\n ///   `Leaf`, the `NodeRef` points to a leaf node, when this is `Internal` the\n ///   `NodeRef` points to an internal node, and when this is `LeafOrInternal` the\n ///   `NodeRef` could be pointing to either type of node.\n-///   Note that in case of a leaf node, this might still be the shared root!  Only turn\n-///   this into a `LeafNode` reference if you know it is not a root!  Shared references\n-///   must be dereferencable *for the entire size of their pointee*, so `&InternalNode`\n-///   pointing to the shared root is UB.\n-///   Turning this into a `NodeHeader` is always safe.\n+///   Note that in case of a leaf node, this might still be the shared root!\n+///   Only turn this into a `LeafNode` reference if you know it is not the shared root!\n+///   Shared references must be dereferencable *for the entire size of their pointee*,\n+///   so '&LeafNode` or `&InternalNode` pointing to the shared root is undefined behavior.\n+///   Turning this into a `NodeHeader` reference is always safe.\n pub struct NodeRef<BorrowType, K, V, Type> {\n     height: usize,\n     node: NonNull<LeafNode<K, V>>,\n-    // This is null unless the borrow type is `Mut`\n+    // `root` is null unless the borrow type is `Mut`\n     root: *const Root<K, V>,\n     _marker: PhantomData<(BorrowType, Type)>,\n }\n@@ -370,23 +370,33 @@ impl<BorrowType, K, V, Type> NodeRef<BorrowType, K, V, Type> {\n         NodeRef { height: self.height, node: self.node, root: self.root, _marker: PhantomData }\n     }\n \n-    /// Assert that this is indeed a proper leaf node, and not the shared root.\n+    /// Exposes the leaf \"portion\" of any leaf or internal node that is not the shared root.\n+    /// If the node is a leaf, this function simply opens up its data.\n+    /// If the node is an internal node, so not a leaf, it does have all the data a leaf has\n+    /// (header, keys and values), and this function exposes that.\n+    /// See `NodeRef` on why the node may not be a shared root.\n     unsafe fn as_leaf(&self) -> &LeafNode<K, V> {\n+        debug_assert!(!self.is_shared_root());\n         self.node.as_ref()\n     }\n \n     fn as_header(&self) -> &NodeHeader<K, V> {\n         unsafe { &*(self.node.as_ptr() as *const NodeHeader<K, V>) }\n     }\n \n+    /// Returns whether the node is the shared, empty root.\n     pub fn is_shared_root(&self) -> bool {\n         self.as_header().is_shared_root()\n     }\n \n+    /// Borrows a view into the keys stored in the node.\n+    /// Works on all possible nodes, including the shared root.\n     pub fn keys(&self) -> &[K] {\n         self.reborrow().into_key_slice()\n     }\n \n+    /// Borrows a view into the values stored in the node.\n+    /// The caller must ensure that the node is not the shared root.\n     fn vals(&self) -> &[V] {\n         self.reborrow().into_val_slice()\n     }\n@@ -491,16 +501,24 @@ impl<'a, K, V, Type> NodeRef<marker::Mut<'a>, K, V, Type> {\n         NodeRef { height: self.height, node: self.node, root: self.root, _marker: PhantomData }\n     }\n \n+    /// Exposes the leaf \"portion\" of any leaf or internal node for writing.\n+    /// If the node is a leaf, this function simply opens up its data.\n+    /// If the node is an internal node, so not a leaf, it does have all the data a leaf has\n+    /// (header, keys and values), and this function exposes that.\n+    ///\n     /// Returns a raw ptr to avoid asserting exclusive access to the entire node.\n+    /// This also implies you can invoke this member on the shared root, but the resulting pointer\n+    /// might not be properly aligned and definitely would not allow accessing keys and values.\n     fn as_leaf_mut(&mut self) -> *mut LeafNode<K, V> {\n-        // We are mutable, so we cannot be the shared root, so accessing this as a leaf is okay.\n         self.node.as_ptr()\n     }\n \n+    /// The caller must ensure that the node is not the shared root.\n     fn keys_mut(&mut self) -> &mut [K] {\n         unsafe { self.reborrow_mut().into_key_slice_mut() }\n     }\n \n+    /// The caller must ensure that the node is not the shared root.\n     fn vals_mut(&mut self) -> &mut [V] {\n         unsafe { self.reborrow_mut().into_val_slice_mut() }\n     }\n@@ -551,9 +569,10 @@ impl<'a, K: 'a, V: 'a, Type> NodeRef<marker::Immut<'a>, K, V, Type> {\n         }\n     }\n \n+    /// The caller must ensure that the node is not the shared root.\n     fn into_val_slice(self) -> &'a [V] {\n         debug_assert!(!self.is_shared_root());\n-        // We cannot be the shared root, so `as_leaf` is okay\n+        // We cannot be the shared root, so `as_leaf` is okay.\n         unsafe { slice::from_raw_parts(MaybeUninit::first_ptr(&self.as_leaf().vals), self.len()) }\n     }\n \n@@ -587,6 +606,7 @@ impl<'a, K: 'a, V: 'a, Type> NodeRef<marker::Mut<'a>, K, V, Type> {\n         }\n     }\n \n+    /// The caller must ensure that the node is not the shared root.\n     fn into_val_slice_mut(mut self) -> &'a mut [V] {\n         debug_assert!(!self.is_shared_root());\n         unsafe {\n@@ -597,6 +617,7 @@ impl<'a, K: 'a, V: 'a, Type> NodeRef<marker::Mut<'a>, K, V, Type> {\n         }\n     }\n \n+    /// The caller must ensure that the node is not the shared root.\n     fn into_slices_mut(mut self) -> (&'a mut [K], &'a mut [V]) {\n         debug_assert!(!self.is_shared_root());\n         // We cannot use the getters here, because calling the second one\n@@ -655,6 +676,7 @@ impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::Internal> {\n         // Necessary for correctness, but this is an internal module\n         debug_assert!(edge.height == self.height - 1);\n         debug_assert!(self.len() < CAPACITY);\n+        debug_assert!(!self.is_shared_root());\n \n         let idx = self.len();\n \n@@ -686,6 +708,7 @@ impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::Internal> {\n         // Necessary for correctness, but this is an internal module\n         debug_assert!(edge.height == self.height - 1);\n         debug_assert!(self.len() < CAPACITY);\n+        debug_assert!(!self.is_shared_root());\n \n         unsafe {\n             slice_insert(self.keys_mut(), 0, key);\n@@ -773,6 +796,7 @@ impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal> {\n         }\n     }\n \n+    /// The caller must ensure that the node is not the shared root.\n     fn into_kv_pointers_mut(mut self) -> (*mut K, *mut V) {\n         (self.keys_mut().as_mut_ptr(), self.vals_mut().as_mut_ptr())\n     }\n@@ -1116,8 +1140,8 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::KV>\n         }\n     }\n \n-    /// Removes the key/value pair pointed to by this handle, returning the edge between the\n-    /// now adjacent key/value pairs to the left and right of this handle.\n+    /// Removes the key/value pair pointed to by this handle and returns it, along with the edge\n+    /// between the now adjacent key/value pairs (if any) to the left and right of this handle.\n     pub fn remove(\n         mut self,\n     ) -> (Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge>, K, V) {\n@@ -1260,7 +1284,7 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::\n         }\n     }\n \n-    /// This removes a key/value pair from the left child and replaces it with the key/value pair\n+    /// This removes a key/value pair from the left child and places it in the key/value storage\n     /// pointed to by this handle while pushing the old key/value pair of this handle into the right\n     /// child.\n     pub fn steal_left(&mut self) {\n@@ -1277,7 +1301,7 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::\n         }\n     }\n \n-    /// This removes a key/value pair from the right child and replaces it with the key/value pair\n+    /// This removes a key/value pair from the right child and places it in the key/value storage\n     /// pointed to by this handle while pushing the old key/value pair of this handle into the left\n     /// child.\n     pub fn steal_right(&mut self) {"}, {"sha": "0eb9e19423617b789ff2d27f914a6bb1b391431d", "filename": "src/libcore/macros/mod.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/760ce94c69ca510d44087291c311296f6d9ccdf5/src%2Flibcore%2Fmacros%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/760ce94c69ca510d44087291c311296f6d9ccdf5/src%2Flibcore%2Fmacros%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros%2Fmod.rs?ref=760ce94c69ca510d44087291c311296f6d9ccdf5", "patch": "@@ -1,27 +1,21 @@\n #[doc(include = \"panic.md\")]\n #[macro_export]\n-#[allow_internal_unstable(core_panic,\n-    // FIXME(anp, eddyb) `core_intrinsics` is used here to allow calling\n-    // the `caller_location` intrinsic, but once  `#[track_caller]` is implemented,\n-    // `panicking::{panic, panic_fmt}` can use that instead of a `Location` argument.\n-    core_intrinsics,\n-    const_caller_location,\n-)]\n+#[allow_internal_unstable(core_panic, track_caller)]\n #[stable(feature = \"core\", since = \"1.6.0\")]\n macro_rules! panic {\n     () => (\n         $crate::panic!(\"explicit panic\")\n     );\n     ($msg:expr) => (\n-        $crate::panicking::panic($msg, $crate::intrinsics::caller_location())\n+        $crate::panicking::panic($msg)\n     );\n     ($msg:expr,) => (\n         $crate::panic!($msg)\n     );\n     ($fmt:expr, $($arg:tt)+) => (\n         $crate::panicking::panic_fmt(\n             $crate::format_args!($fmt, $($arg)+),\n-            $crate::intrinsics::caller_location(),\n+            $crate::panic::Location::caller(),\n         )\n     );\n }"}, {"sha": "61b764f2d6206ad7773ede553601ea130ce968d1", "filename": "src/libcore/panicking.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/760ce94c69ca510d44087291c311296f6d9ccdf5/src%2Flibcore%2Fpanicking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/760ce94c69ca510d44087291c311296f6d9ccdf5/src%2Flibcore%2Fpanicking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpanicking.rs?ref=760ce94c69ca510d44087291c311296f6d9ccdf5", "patch": "@@ -36,8 +36,9 @@ use crate::panic::{Location, PanicInfo};\n // never inline unless panic_immediate_abort to avoid code\n // bloat at the call sites as much as possible\n #[cfg_attr(not(feature = \"panic_immediate_abort\"), inline(never))]\n+#[track_caller]\n #[lang = \"panic\"] // needed by codegen for panic on overflow and other `Assert` MIR terminators\n-pub fn panic(expr: &str, location: &Location<'_>) -> ! {\n+pub fn panic(expr: &str) -> ! {\n     if cfg!(feature = \"panic_immediate_abort\") {\n         unsafe { super::intrinsics::abort() }\n     }\n@@ -48,7 +49,7 @@ pub fn panic(expr: &str, location: &Location<'_>) -> ! {\n     // truncation and padding (even though none is used here). Using\n     // Arguments::new_v1 may allow the compiler to omit Formatter::pad from the\n     // output binary, saving up to a few kilobytes.\n-    panic_fmt(fmt::Arguments::new_v1(&[expr], &[]), location)\n+    panic_fmt(fmt::Arguments::new_v1(&[expr], &[]), Location::caller())\n }\n \n #[cold]"}, {"sha": "2279ed859540811d6d45d536323493ba0cf08c87", "filename": "src/librustc_errors/lib.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/760ce94c69ca510d44087291c311296f6d9ccdf5/src%2Flibrustc_errors%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/760ce94c69ca510d44087291c311296f6d9ccdf5/src%2Flibrustc_errors%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Flib.rs?ref=760ce94c69ca510d44087291c311296f6d9ccdf5", "patch": "@@ -329,6 +329,8 @@ pub struct HandlerFlags {\n     /// show macro backtraces even for non-local macros.\n     /// (rustc: see `-Z external-macro-backtrace`)\n     pub external_macro_backtrace: bool,\n+    /// If true, identical diagnostics are reported only once.\n+    pub deduplicate_diagnostics: bool,\n }\n \n impl Drop for HandlerInner {\n@@ -736,16 +738,17 @@ impl HandlerInner {\n             self.emitted_diagnostic_codes.insert(code.clone());\n         }\n \n-        let diagnostic_hash = {\n+        let already_emitted = |this: &mut Self| {\n             use std::hash::Hash;\n             let mut hasher = StableHasher::new();\n             diagnostic.hash(&mut hasher);\n-            hasher.finish()\n+            let diagnostic_hash = hasher.finish();\n+            !this.emitted_diagnostics.insert(diagnostic_hash)\n         };\n \n-        // Only emit the diagnostic if we haven't already emitted an equivalent\n-        // one:\n-        if self.emitted_diagnostics.insert(diagnostic_hash) {\n+        // Only emit the diagnostic if we've been asked to deduplicate and\n+        // haven't already emitted an equivalent diagnostic.\n+        if !(self.flags.deduplicate_diagnostics && already_emitted(self)) {\n             self.emitter.emit_diagnostic(diagnostic);\n             if diagnostic.is_error() {\n                 self.deduplicated_err_count += 1;"}, {"sha": "11f94ab2e627980b0445e92a50967bc442e46b68", "filename": "src/librustc_expand/build.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/760ce94c69ca510d44087291c311296f6d9ccdf5/src%2Flibrustc_expand%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/760ce94c69ca510d44087291c311296f6d9ccdf5/src%2Flibrustc_expand%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fbuild.rs?ref=760ce94c69ca510d44087291c311296f6d9ccdf5", "patch": "@@ -6,7 +6,7 @@ use syntax::ast::{self, AttrVec, BlockCheckMode, Expr, Ident, PatKind, UnOp};\n use syntax::attr;\n use syntax::ptr::P;\n \n-use rustc_span::{Pos, Span};\n+use rustc_span::Span;\n \n impl<'a> ExtCtxt<'a> {\n     pub fn path(&self, span: Span, strs: Vec<ast::Ident>) -> ast::Path {\n@@ -350,16 +350,10 @@ impl<'a> ExtCtxt<'a> {\n     }\n \n     pub fn expr_fail(&self, span: Span, msg: Symbol) -> P<ast::Expr> {\n-        let loc = self.source_map().lookup_char_pos(span.lo());\n-        let expr_file = self.expr_str(span, Symbol::intern(&loc.file.name.to_string()));\n-        let expr_line = self.expr_u32(span, loc.line as u32);\n-        let expr_col = self.expr_u32(span, loc.col.to_usize() as u32 + 1);\n-        let expr_loc_tuple = self.expr_tuple(span, vec![expr_file, expr_line, expr_col]);\n-        let expr_loc_ptr = self.expr_addr_of(span, expr_loc_tuple);\n         self.expr_call_global(\n             span,\n             [sym::std, sym::rt, sym::begin_panic].iter().map(|s| Ident::new(*s, span)).collect(),\n-            vec![self.expr_str(span, msg), expr_loc_ptr],\n+            vec![self.expr_str(span, msg)],\n         )\n     }\n "}, {"sha": "b39a61c5e0dd115c0df9b6ba4e4a63e0e6709e7c", "filename": "src/librustc_mir/const_eval/machine.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/760ce94c69ca510d44087291c311296f6d9ccdf5/src%2Flibrustc_mir%2Fconst_eval%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/760ce94c69ca510d44087291c311296f6d9ccdf5/src%2Flibrustc_mir%2Fconst_eval%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval%2Fmachine.rs?ref=760ce94c69ca510d44087291c311296f6d9ccdf5", "patch": "@@ -177,6 +177,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n \n     fn find_mir_or_eval_fn(\n         ecx: &mut InterpCx<'mir, 'tcx, Self>,\n+        span: Span,\n         instance: ty::Instance<'tcx>,\n         args: &[OpTy<'tcx>],\n         ret: Option<(PlaceTy<'tcx>, mir::BasicBlock)>,\n@@ -199,7 +200,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n                 // Some functions we support even if they are non-const -- but avoid testing\n                 // that for const fn!  We certainly do *not* want to actually call the fn\n                 // though, so be sure we return here.\n-                return if ecx.hook_panic_fn(instance, args, ret)? {\n+                return if ecx.hook_panic_fn(span, instance, args)? {\n                     Ok(None)\n                 } else {\n                     throw_unsup_format!(\"calling non-const function `{}`\", instance)"}, {"sha": "b075e8ea383e1511889d1dba3c85d22f89b70901", "filename": "src/librustc_mir/interpret/intrinsics.rs", "status": "modified", "additions": 8, "deletions": 34, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/760ce94c69ca510d44087291c311296f6d9ccdf5/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/760ce94c69ca510d44087291c311296f6d9ccdf5/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs?ref=760ce94c69ca510d44087291c311296f6d9ccdf5", "patch": "@@ -366,47 +366,21 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     /// Returns `true` if an intercept happened.\n     pub fn hook_panic_fn(\n         &mut self,\n+        span: Span,\n         instance: ty::Instance<'tcx>,\n         args: &[OpTy<'tcx, M::PointerTag>],\n-        _ret: Option<(PlaceTy<'tcx, M::PointerTag>, mir::BasicBlock)>,\n     ) -> InterpResult<'tcx, bool> {\n         let def_id = instance.def_id();\n-        if Some(def_id) == self.tcx.lang_items().panic_fn() {\n-            // &'static str, &core::panic::Location { &'static str, u32, u32 }\n-            assert!(args.len() == 2);\n+        if Some(def_id) == self.tcx.lang_items().panic_fn()\n+            || Some(def_id) == self.tcx.lang_items().begin_panic_fn()\n+        {\n+            // &'static str\n+            assert!(args.len() == 1);\n \n             let msg_place = self.deref_operand(args[0])?;\n             let msg = Symbol::intern(self.read_str(msg_place)?);\n-\n-            let location = self.deref_operand(args[1])?;\n-            let (file, line, col) = (\n-                self.mplace_field(location, 0)?,\n-                self.mplace_field(location, 1)?,\n-                self.mplace_field(location, 2)?,\n-            );\n-\n-            let file_place = self.deref_operand(file.into())?;\n-            let file = Symbol::intern(self.read_str(file_place)?);\n-            let line = self.read_scalar(line.into())?.to_u32()?;\n-            let col = self.read_scalar(col.into())?.to_u32()?;\n-            throw_panic!(Panic { msg, file, line, col })\n-        } else if Some(def_id) == self.tcx.lang_items().begin_panic_fn() {\n-            assert!(args.len() == 2);\n-            // &'static str, &(&'static str, u32, u32)\n-            let msg = args[0];\n-            let place = self.deref_operand(args[1])?;\n-            let (file, line, col) = (\n-                self.mplace_field(place, 0)?,\n-                self.mplace_field(place, 1)?,\n-                self.mplace_field(place, 2)?,\n-            );\n-\n-            let msg_place = self.deref_operand(msg.into())?;\n-            let msg = Symbol::intern(self.read_str(msg_place)?);\n-            let file_place = self.deref_operand(file.into())?;\n-            let file = Symbol::intern(self.read_str(file_place)?);\n-            let line = self.read_scalar(line.into())?.to_u32()?;\n-            let col = self.read_scalar(col.into())?.to_u32()?;\n+            let span = self.find_closest_untracked_caller_location().unwrap_or(span);\n+            let (file, line, col) = self.location_triple_for_span(span);\n             throw_panic!(Panic { msg, file, line, col })\n         } else {\n             return Ok(false);"}, {"sha": "0525108d2d129a928dee79aa1bdd7ef06c49ba9e", "filename": "src/librustc_mir/interpret/intrinsics/caller_location.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/760ce94c69ca510d44087291c311296f6d9ccdf5/src%2Flibrustc_mir%2Finterpret%2Fintrinsics%2Fcaller_location.rs", "raw_url": "https://github.com/rust-lang/rust/raw/760ce94c69ca510d44087291c311296f6d9ccdf5/src%2Flibrustc_mir%2Finterpret%2Fintrinsics%2Fcaller_location.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintrinsics%2Fcaller_location.rs?ref=760ce94c69ca510d44087291c311296f6d9ccdf5", "patch": "@@ -9,8 +9,9 @@ use crate::interpret::{\n };\n \n impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n-    /// Walks up the callstack from the intrinsic's callsite, searching for the first frame which is\n-    /// not `#[track_caller]`.\n+    /// Walks up the callstack from the intrinsic's callsite, searching for the first callsite in a\n+    /// frame which is not `#[track_caller]`. If the first frame found lacks `#[track_caller]`, then\n+    /// `None` is returned and the callsite of the function invocation itself should be used.\n     crate fn find_closest_untracked_caller_location(&self) -> Option<Span> {\n         let mut caller_span = None;\n         for next_caller in self.stack.iter().rev() {\n@@ -54,9 +55,14 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     }\n \n     pub fn alloc_caller_location_for_span(&mut self, span: Span) -> MPlaceTy<'tcx, M::PointerTag> {\n+        let (file, line, column) = self.location_triple_for_span(span);\n+        self.alloc_caller_location(file, line, column)\n+    }\n+\n+    pub(super) fn location_triple_for_span(&self, span: Span) -> (Symbol, u32, u32) {\n         let topmost = span.ctxt().outer_expn().expansion_cause().unwrap_or(span);\n         let caller = self.tcx.sess.source_map().lookup_char_pos(topmost.lo());\n-        self.alloc_caller_location(\n+        (\n             Symbol::intern(&caller.file.name.to_string()),\n             caller.line as u32,\n             caller.col_display as u32 + 1,"}, {"sha": "3dc572d256d8ed661b2de81c08274e566914528d", "filename": "src/librustc_mir/interpret/machine.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/760ce94c69ca510d44087291c311296f6d9ccdf5/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/760ce94c69ca510d44087291c311296f6d9ccdf5/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs?ref=760ce94c69ca510d44087291c311296f6d9ccdf5", "patch": "@@ -139,6 +139,7 @@ pub trait Machine<'mir, 'tcx>: Sized {\n     /// was used.\n     fn find_mir_or_eval_fn(\n         ecx: &mut InterpCx<'mir, 'tcx, Self>,\n+        span: Span,\n         instance: ty::Instance<'tcx>,\n         args: &[OpTy<'tcx, Self::PointerTag>],\n         ret: Option<(PlaceTy<'tcx, Self::PointerTag>, mir::BasicBlock)>,"}, {"sha": "032062d636040f9aa4c41b7221d915cd7a79f96d", "filename": "src/librustc_mir/interpret/terminator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/760ce94c69ca510d44087291c311296f6d9ccdf5/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/760ce94c69ca510d44087291c311296f6d9ccdf5/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs?ref=760ce94c69ca510d44087291c311296f6d9ccdf5", "patch": "@@ -238,7 +238,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             | ty::InstanceDef::CloneShim(..)\n             | ty::InstanceDef::Item(_) => {\n                 // We need MIR for this fn\n-                let body = match M::find_mir_or_eval_fn(self, instance, args, ret, unwind)? {\n+                let body = match M::find_mir_or_eval_fn(self, span, instance, args, ret, unwind)? {\n                     Some(body) => body,\n                     None => return Ok(()),\n                 };"}, {"sha": "31c3a2c7ebceb63099246c6b0b9d67addd1fcc73", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/760ce94c69ca510d44087291c311296f6d9ccdf5/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/760ce94c69ca510d44087291c311296f6d9ccdf5/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=760ce94c69ca510d44087291c311296f6d9ccdf5", "patch": "@@ -125,6 +125,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for ConstPropMachine {\n \n     fn find_mir_or_eval_fn(\n         _ecx: &mut InterpCx<'mir, 'tcx, Self>,\n+        _span: Span,\n         _instance: ty::Instance<'tcx>,\n         _args: &[OpTy<'tcx>],\n         _ret: Option<(PlaceTy<'tcx>, BasicBlock)>,"}, {"sha": "3521ae0faf581e3ed89653e119a26ec111ea87d8", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/760ce94c69ca510d44087291c311296f6d9ccdf5/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/760ce94c69ca510d44087291c311296f6d9ccdf5/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=760ce94c69ca510d44087291c311296f6d9ccdf5", "patch": "@@ -472,11 +472,7 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n \n                         self.r\n                             .session\n-                            .struct_span_warn(item.span, \"`$crate` may not be imported\")\n-                            .note(\n-                                \"`use $crate;` was erroneously allowed and \\\n-                                   will become a hard error in a future release\",\n-                            )\n+                            .struct_span_err(item.span, \"`$crate` may not be imported\")\n                             .emit();\n                     }\n                 }"}, {"sha": "b6b22e298ca6234725164416e38c81ea571ea3db", "filename": "src/librustc_session/config.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/760ce94c69ca510d44087291c311296f6d9ccdf5/src%2Flibrustc_session%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/760ce94c69ca510d44087291c311296f6d9ccdf5/src%2Flibrustc_session%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_session%2Fconfig.rs?ref=760ce94c69ca510d44087291c311296f6d9ccdf5", "patch": "@@ -20,7 +20,7 @@ use rustc_span::source_map::{FileName, FilePathMapping};\n use rustc_span::symbol::{sym, Symbol};\n \n use rustc_errors::emitter::HumanReadableErrorType;\n-use rustc_errors::{ColorConfig, FatalError, Handler};\n+use rustc_errors::{ColorConfig, FatalError, Handler, HandlerFlags};\n \n use getopts;\n \n@@ -597,6 +597,17 @@ impl DebuggingOptions {\n     pub fn ui_testing(&self) -> bool {\n         self.ui_testing.unwrap_or(false)\n     }\n+\n+    pub fn diagnostic_handler_flags(&self, can_emit_warnings: bool) -> HandlerFlags {\n+        HandlerFlags {\n+            can_emit_warnings,\n+            treat_err_as_bug: self.treat_err_as_bug,\n+            dont_buffer_diagnostics: self.dont_buffer_diagnostics,\n+            report_delayed_bugs: self.report_delayed_bugs,\n+            external_macro_backtrace: self.external_macro_backtrace,\n+            deduplicate_diagnostics: self.deduplicate_diagnostics.unwrap_or(true),\n+        }\n+    }\n }\n \n // The type of entry function, so users can have their own entry functions"}, {"sha": "656c1b019b2e2ead069151c9589be1316b61a693", "filename": "src/librustc_session/options.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/760ce94c69ca510d44087291c311296f6d9ccdf5/src%2Flibrustc_session%2Foptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/760ce94c69ca510d44087291c311296f6d9ccdf5/src%2Flibrustc_session%2Foptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_session%2Foptions.rs?ref=760ce94c69ca510d44087291c311296f6d9ccdf5", "patch": "@@ -946,4 +946,6 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n     insert_sideeffect: bool = (false, parse_bool, [TRACKED],\n         \"fix undefined behavior when a thread doesn't eventually make progress \\\n          (such as entering an empty infinite loop) by inserting llvm.sideeffect\"),\n+    deduplicate_diagnostics: Option<bool> = (None, parse_opt_bool, [UNTRACKED],\n+        \"deduplicate identical diagnostics\"),\n }"}, {"sha": "15911db46fe0bf6654a26419eff29173503687c9", "filename": "src/librustc_session/session.rs", "status": "modified", "additions": 1, "deletions": 15, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/760ce94c69ca510d44087291c311296f6d9ccdf5/src%2Flibrustc_session%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/760ce94c69ca510d44087291c311296f6d9ccdf5/src%2Flibrustc_session%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_session%2Fsession.rs?ref=760ce94c69ca510d44087291c311296f6d9ccdf5", "patch": "@@ -941,15 +941,8 @@ pub fn build_session_with_source_map(\n         .last()\n         .unwrap_or(false);\n     let cap_lints_allow = sopts.lint_cap.map_or(false, |cap| cap == lint::Allow);\n-\n     let can_emit_warnings = !(warnings_allow || cap_lints_allow);\n \n-    let treat_err_as_bug = sopts.debugging_opts.treat_err_as_bug;\n-    let dont_buffer_diagnostics = sopts.debugging_opts.dont_buffer_diagnostics;\n-    let report_delayed_bugs = sopts.debugging_opts.report_delayed_bugs;\n-\n-    let external_macro_backtrace = sopts.debugging_opts.external_macro_backtrace;\n-\n     let write_dest = match diagnostics_output {\n         DiagnosticOutput::Default => None,\n         DiagnosticOutput::Raw(write) => Some(write),\n@@ -958,14 +951,7 @@ pub fn build_session_with_source_map(\n \n     let diagnostic_handler = rustc_errors::Handler::with_emitter_and_flags(\n         emitter,\n-        rustc_errors::HandlerFlags {\n-            can_emit_warnings,\n-            treat_err_as_bug,\n-            report_delayed_bugs,\n-            dont_buffer_diagnostics,\n-            external_macro_backtrace,\n-            ..Default::default()\n-        },\n+        sopts.debugging_opts.diagnostic_handler_flags(can_emit_warnings),\n     );\n \n     build_session_(sopts, local_crate_source_file, diagnostic_handler, source_map, lint_caps)"}, {"sha": "0af25efc04234fd23577ea5e50535f2d411fc0ac", "filename": "src/librustdoc/config.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/760ce94c69ca510d44087291c311296f6d9ccdf5/src%2Flibrustdoc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/760ce94c69ca510d44087291c311296f6d9ccdf5/src%2Flibrustdoc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fconfig.rs?ref=760ce94c69ca510d44087291c311296f6d9ccdf5", "patch": "@@ -269,12 +269,7 @@ impl Options {\n         let codegen_options = build_codegen_options(matches, error_format);\n         let debugging_options = build_debugging_options(matches, error_format);\n \n-        let diag = new_handler(\n-            error_format,\n-            None,\n-            debugging_options.treat_err_as_bug,\n-            debugging_options.ui_testing(),\n-        );\n+        let diag = new_handler(error_format, None, &debugging_options);\n \n         // check for deprecated options\n         check_deprecated_options(&matches, &diag);"}, {"sha": "f53f3a75e095cffeef803bbc4e3acebdb1a4923e", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 8, "deletions": 21, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/760ce94c69ca510d44087291c311296f6d9ccdf5/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/760ce94c69ca510d44087291c311296f6d9ccdf5/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=760ce94c69ca510d44087291c311296f6d9ccdf5", "patch": "@@ -35,7 +35,7 @@ use crate::html::render::RenderInfo;\n \n use crate::passes;\n \n-pub use rustc::session::config::{CodegenOptions, Input, Options};\n+pub use rustc::session::config::{CodegenOptions, DebuggingOptions, Input, Options};\n pub use rustc::session::search_paths::SearchPath;\n \n pub type ExternalPaths = FxHashMap<DefId, (Vec<String>, clean::TypeKind)>;\n@@ -170,12 +170,8 @@ impl<'tcx> DocContext<'tcx> {\n pub fn new_handler(\n     error_format: ErrorOutputType,\n     source_map: Option<Lrc<source_map::SourceMap>>,\n-    treat_err_as_bug: Option<usize>,\n-    ui_testing: bool,\n+    debugging_opts: &DebuggingOptions,\n ) -> errors::Handler {\n-    // rustdoc doesn't override (or allow to override) anything from this that is relevant here, so\n-    // stick to the defaults\n-    let sessopts = Options::default();\n     let emitter: Box<dyn Emitter + sync::Send> = match error_format {\n         ErrorOutputType::HumanReadable(kind) => {\n             let (short, color_config) = kind.unzip();\n@@ -184,34 +180,25 @@ pub fn new_handler(\n                     color_config,\n                     source_map.map(|cm| cm as _),\n                     short,\n-                    sessopts.debugging_opts.teach,\n-                    sessopts.debugging_opts.terminal_width,\n+                    debugging_opts.teach,\n+                    debugging_opts.terminal_width,\n                     false,\n                 )\n-                .ui_testing(ui_testing),\n+                .ui_testing(debugging_opts.ui_testing()),\n             )\n         }\n         ErrorOutputType::Json { pretty, json_rendered } => {\n             let source_map = source_map.unwrap_or_else(|| {\n-                Lrc::new(source_map::SourceMap::new(sessopts.file_path_mapping()))\n+                Lrc::new(source_map::SourceMap::new(source_map::FilePathMapping::empty()))\n             });\n             Box::new(\n                 JsonEmitter::stderr(None, source_map, pretty, json_rendered, false)\n-                    .ui_testing(ui_testing),\n+                    .ui_testing(debugging_opts.ui_testing()),\n             )\n         }\n     };\n \n-    errors::Handler::with_emitter_and_flags(\n-        emitter,\n-        errors::HandlerFlags {\n-            can_emit_warnings: true,\n-            treat_err_as_bug,\n-            report_delayed_bugs: false,\n-            external_macro_backtrace: false,\n-            ..Default::default()\n-        },\n-    )\n+    errors::Handler::with_emitter_and_flags(emitter, debugging_opts.diagnostic_handler_flags(true))\n }\n \n pub fn run_core(options: RustdocOptions) -> (clean::Crate, RenderInfo, RenderOptions) {"}, {"sha": "c8a32306194df1bc733395bfe0e0cdf7157dc05c", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 4, "deletions": 14, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/760ce94c69ca510d44087291c311296f6d9ccdf5/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/760ce94c69ca510d44087291c311296f6d9ccdf5/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=760ce94c69ca510d44087291c311296f6d9ccdf5", "patch": "@@ -445,12 +445,7 @@ fn main_args(args: &[String]) -> i32 {\n }\n \n fn main_options(options: config::Options) -> i32 {\n-    let diag = core::new_handler(\n-        options.error_format,\n-        None,\n-        options.debugging_options.treat_err_as_bug,\n-        options.debugging_options.ui_testing(),\n-    );\n+    let diag = core::new_handler(options.error_format, None, &options.debugging_options);\n \n     match (options.should_test, options.markdown_input()) {\n         (true, true) => return markdown::test(options, &diag),\n@@ -463,12 +458,7 @@ fn main_options(options: config::Options) -> i32 {\n \n     // need to move these items separately because we lose them by the time the closure is called,\n     // but we can't crates the Handler ahead of time because it's not Send\n-    let diag_opts = (\n-        options.error_format,\n-        options.debugging_options.treat_err_as_bug,\n-        options.debugging_options.ui_testing(),\n-        options.edition,\n-    );\n+    let diag_opts = (options.error_format, options.edition, options.debugging_options.clone());\n     let show_coverage = options.show_coverage;\n     rust_input(options, move |out| {\n         if show_coverage {\n@@ -479,8 +469,8 @@ fn main_options(options: config::Options) -> i32 {\n \n         let Output { krate, renderinfo, renderopts } = out;\n         info!(\"going to format\");\n-        let (error_format, treat_err_as_bug, ui_testing, edition) = diag_opts;\n-        let diag = core::new_handler(error_format, None, treat_err_as_bug, ui_testing);\n+        let (error_format, edition, debugging_options) = diag_opts;\n+        let diag = core::new_handler(error_format, None, &debugging_options);\n         match html::render::run(krate, renderopts, renderinfo, &diag, edition) {\n             Ok(_) => rustc_driver::EXIT_SUCCESS,\n             Err(e) => {"}, {"sha": "f90647472c6787ee401474fa63ef7de2ebe98251", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/760ce94c69ca510d44087291c311296f6d9ccdf5/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/760ce94c69ca510d44087291c311296f6d9ccdf5/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=760ce94c69ca510d44087291c311296f6d9ccdf5", "patch": "@@ -305,6 +305,7 @@\n #![feature(thread_local)]\n #![feature(toowned_clone_into)]\n #![feature(trace_macros)]\n+#![feature(track_caller)]\n #![feature(try_reserve)]\n #![feature(unboxed_closures)]\n #![feature(untagged_unions)]"}, {"sha": "18fb0f87688dea28d9e3ee577a5f5413b739306d", "filename": "src/libstd/macros.rs", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/760ce94c69ca510d44087291c311296f6d9ccdf5/src%2Flibstd%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/760ce94c69ca510d44087291c311296f6d9ccdf5/src%2Flibstd%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmacros.rs?ref=760ce94c69ca510d44087291c311296f6d9ccdf5", "patch": "@@ -4,6 +4,7 @@\n //! library. Each macro is available for use when linking against the standard\n //! library.\n \n+#[cfg(bootstrap)]\n #[doc(include = \"../libcore/macros/panic.md\")]\n #[macro_export]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -19,8 +20,21 @@ macro_rules! panic {\n         $crate::panic!($msg)\n     });\n     ($fmt:expr, $($arg:tt)+) => ({\n-        $crate::rt::begin_panic_fmt(&$crate::format_args!($fmt, $($arg)+),\n-                                    &($crate::file!(), $crate::line!(), $crate::column!()))\n+        $crate::rt::begin_panic_fmt(&$crate::format_args!($fmt, $($arg)+))\n+    });\n+}\n+\n+#[cfg(not(bootstrap))]\n+#[doc(include = \"../libcore/macros/panic.md\")]\n+#[macro_export]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[allow_internal_unstable(libstd_sys_internals)]\n+macro_rules! panic {\n+    () => ({ $crate::panic!(\"explicit panic\") });\n+    ($msg:expr) => ({ $crate::rt::begin_panic($msg) });\n+    ($msg:expr,) => ({ $crate::panic!($msg) });\n+    ($fmt:expr, $($arg:tt)+) => ({\n+        $crate::rt::begin_panic_fmt(&$crate::format_args!($fmt, $($arg)+))\n     });\n }\n "}, {"sha": "599ccc809be1fc494379e5a059b7c555c2dac416", "filename": "src/libstd/panicking.rs", "status": "modified", "additions": 17, "deletions": 26, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/760ce94c69ca510d44087291c311296f6d9ccdf5/src%2Flibstd%2Fpanicking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/760ce94c69ca510d44087291c311296f6d9ccdf5/src%2Flibstd%2Fpanicking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpanicking.rs?ref=760ce94c69ca510d44087291c311296f6d9ccdf5", "patch": "@@ -313,17 +313,15 @@ pub fn panicking() -> bool {\n #[cold]\n // If panic_immediate_abort, inline the abort call,\n // otherwise avoid inlining because of it is cold path.\n+#[cfg_attr(not(feature = \"panic_immediate_abort\"), track_caller)]\n #[cfg_attr(not(feature = \"panic_immediate_abort\"), inline(never))]\n #[cfg_attr(feature = \"panic_immediate_abort\", inline)]\n-pub fn begin_panic_fmt(msg: &fmt::Arguments<'_>, file_line_col: &(&'static str, u32, u32)) -> ! {\n+pub fn begin_panic_fmt(msg: &fmt::Arguments<'_>) -> ! {\n     if cfg!(feature = \"panic_immediate_abort\") {\n         unsafe { intrinsics::abort() }\n     }\n \n-    // Just package everything into a `PanicInfo` and continue like libcore panics.\n-    let (file, line, col) = *file_line_col;\n-    let location = Location::internal_constructor(file, line, col);\n-    let info = PanicInfo::internal_constructor(Some(msg), &location);\n+    let info = PanicInfo::internal_constructor(Some(msg), Location::caller());\n     begin_panic_handler(&info)\n }\n \n@@ -356,6 +354,9 @@ pub fn begin_panic_handler(info: &PanicInfo<'_>) -> ! {\n \n     unsafe impl<'a> BoxMeUp for PanicPayload<'a> {\n         fn take_box(&mut self) -> *mut (dyn Any + Send) {\n+            // We do two allocations here, unfortunately. But (a) they're required with the current\n+            // scheme, and (b) we don't handle panic + OOM properly anyway (see comment in\n+            // begin_panic below).\n             let contents = mem::take(self.fill());\n             Box::into_raw(Box::new(contents))\n         }\n@@ -365,15 +366,9 @@ pub fn begin_panic_handler(info: &PanicInfo<'_>) -> ! {\n         }\n     }\n \n-    // We do two allocations here, unfortunately. But (a) they're\n-    // required with the current scheme, and (b) we don't handle\n-    // panic + OOM properly anyway (see comment in begin_panic\n-    // below).\n-\n     let loc = info.location().unwrap(); // The current implementation always returns Some\n     let msg = info.message().unwrap(); // The current implementation always returns Some\n-    let file_line_col = (loc.file(), loc.line(), loc.column());\n-    rust_panic_with_hook(&mut PanicPayload::new(msg), info.message(), &file_line_col);\n+    rust_panic_with_hook(&mut PanicPayload::new(msg), info.message(), loc);\n }\n \n /// This is the entry point of panicking for the non-format-string variants of\n@@ -386,19 +381,13 @@ pub fn begin_panic_handler(info: &PanicInfo<'_>) -> ! {\n // bloat at the call sites as much as possible\n #[cfg_attr(not(feature = \"panic_immediate_abort\"), inline(never))]\n #[cold]\n-pub fn begin_panic<M: Any + Send>(msg: M, file_line_col: &(&'static str, u32, u32)) -> ! {\n+#[track_caller]\n+pub fn begin_panic<M: Any + Send>(msg: M, #[cfg(bootstrap)] _: &(&str, u32, u32)) -> ! {\n     if cfg!(feature = \"panic_immediate_abort\") {\n         unsafe { intrinsics::abort() }\n     }\n \n-    // Note that this should be the only allocation performed in this code path.\n-    // Currently this means that panic!() on OOM will invoke this code path,\n-    // but then again we're not really ready for panic on OOM anyway. If\n-    // we do start doing this, then we should propagate this allocation to\n-    // be performed in the parent of this thread instead of the thread that's\n-    // panicking.\n-\n-    rust_panic_with_hook(&mut PanicPayload::new(msg), None, file_line_col);\n+    rust_panic_with_hook(&mut PanicPayload::new(msg), None, Location::caller());\n \n     struct PanicPayload<A> {\n         inner: Option<A>,\n@@ -412,6 +401,11 @@ pub fn begin_panic<M: Any + Send>(msg: M, file_line_col: &(&'static str, u32, u3\n \n     unsafe impl<A: Send + 'static> BoxMeUp for PanicPayload<A> {\n         fn take_box(&mut self) -> *mut (dyn Any + Send) {\n+            // Note that this should be the only allocation performed in this code path. Currently\n+            // this means that panic!() on OOM will invoke this code path, but then again we're not\n+            // really ready for panic on OOM anyway. If we do start doing this, then we should\n+            // propagate this allocation to be performed in the parent of this thread instead of the\n+            // thread that's panicking.\n             let data = match self.inner.take() {\n                 Some(a) => Box::new(a) as Box<dyn Any + Send>,\n                 None => process::abort(),\n@@ -436,10 +430,8 @@ pub fn begin_panic<M: Any + Send>(msg: M, file_line_col: &(&'static str, u32, u3\n fn rust_panic_with_hook(\n     payload: &mut dyn BoxMeUp,\n     message: Option<&fmt::Arguments<'_>>,\n-    file_line_col: &(&str, u32, u32),\n+    location: &Location<'_>,\n ) -> ! {\n-    let (file, line, col) = *file_line_col;\n-\n     let panics = update_panic_count(1);\n \n     // If this is the third nested call (e.g., panics == 2, this is 0-indexed),\n@@ -456,8 +448,7 @@ fn rust_panic_with_hook(\n     }\n \n     unsafe {\n-        let location = Location::internal_constructor(file, line, col);\n-        let mut info = PanicInfo::internal_constructor(message, &location);\n+        let mut info = PanicInfo::internal_constructor(message, location);\n         HOOK_LOCK.read();\n         match HOOK {\n             // Some platforms (like wasm) know that printing to stderr won't ever actually"}, {"sha": "8e9bae8569f196e04cabf92d7c361352e0302193", "filename": "src/test/mir-opt/retain-never-const.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/760ce94c69ca510d44087291c311296f6d9ccdf5/src%2Ftest%2Fmir-opt%2Fretain-never-const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/760ce94c69ca510d44087291c311296f6d9ccdf5/src%2Ftest%2Fmir-opt%2Fretain-never-const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fretain-never-const.rs?ref=760ce94c69ca510d44087291c311296f6d9ccdf5", "patch": "@@ -6,6 +6,7 @@\n \n #![feature(const_panic)]\n #![feature(never_type)]\n+#![warn(const_err)]\n \n struct PrintName<T>(T);\n "}, {"sha": "3493b7c54c43b4773bf440a7f927305976a7c040", "filename": "src/test/ui/consts/miri_unleashed/mutable_const2.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/760ce94c69ca510d44087291c311296f6d9ccdf5/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_const2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/760ce94c69ca510d44087291c311296f6d9ccdf5/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_const2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_const2.stderr?ref=760ce94c69ca510d44087291c311296f6d9ccdf5", "patch": "@@ -10,7 +10,7 @@ error: internal compiler error: mutable allocation in constant\n LL | const MUTABLE_BEHIND_RAW: *mut i32 = &UnsafeCell::new(42) as *const _ as *mut _;\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-thread 'rustc' panicked at 'no errors encountered even though `delay_span_bug` issued', src/librustc_errors/lib.rs:345:17\n+thread 'rustc' panicked at 'no errors encountered even though `delay_span_bug` issued', src/librustc_errors/lib.rs:347:17\n note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace.\n \n error: internal compiler error: unexpected panic"}, {"sha": "1acfce506229f522f4bd21a5937b853272f4e62e", "filename": "src/test/ui/deduplicate-diagnostics.deduplicate.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/760ce94c69ca510d44087291c311296f6d9ccdf5/src%2Ftest%2Fui%2Fdeduplicate-diagnostics.deduplicate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/760ce94c69ca510d44087291c311296f6d9ccdf5/src%2Ftest%2Fui%2Fdeduplicate-diagnostics.deduplicate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdeduplicate-diagnostics.deduplicate.stderr?ref=760ce94c69ca510d44087291c311296f6d9ccdf5", "patch": "@@ -0,0 +1,8 @@\n+error: cannot find derive macro `Unresolved` in this scope\n+  --> $DIR/deduplicate-diagnostics.rs:4:10\n+   |\n+LL | #[derive(Unresolved)]\n+   |          ^^^^^^^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "325da3b5d915bb67232e751a01dbc1a9cfd1bc5a", "filename": "src/test/ui/deduplicate-diagnostics.duplicate.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/760ce94c69ca510d44087291c311296f6d9ccdf5/src%2Ftest%2Fui%2Fdeduplicate-diagnostics.duplicate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/760ce94c69ca510d44087291c311296f6d9ccdf5/src%2Ftest%2Fui%2Fdeduplicate-diagnostics.duplicate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdeduplicate-diagnostics.duplicate.stderr?ref=760ce94c69ca510d44087291c311296f6d9ccdf5", "patch": "@@ -0,0 +1,14 @@\n+error: cannot find derive macro `Unresolved` in this scope\n+  --> $DIR/deduplicate-diagnostics.rs:4:10\n+   |\n+LL | #[derive(Unresolved)]\n+   |          ^^^^^^^^^^\n+\n+error: cannot find derive macro `Unresolved` in this scope\n+  --> $DIR/deduplicate-diagnostics.rs:4:10\n+   |\n+LL | #[derive(Unresolved)]\n+   |          ^^^^^^^^^^\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "4a1f503d757a50d806cb4eed24f38a9f9341f5bd", "filename": "src/test/ui/deduplicate-diagnostics.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/760ce94c69ca510d44087291c311296f6d9ccdf5/src%2Ftest%2Fui%2Fdeduplicate-diagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/760ce94c69ca510d44087291c311296f6d9ccdf5/src%2Ftest%2Fui%2Fdeduplicate-diagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdeduplicate-diagnostics.rs?ref=760ce94c69ca510d44087291c311296f6d9ccdf5", "patch": "@@ -0,0 +1,8 @@\n+// revisions: duplicate deduplicate\n+//[duplicate] compile-flags: -Z deduplicate-diagnostics=no\n+\n+#[derive(Unresolved)] //~ ERROR cannot find derive macro `Unresolved` in this scope\n+                      //[duplicate]~| ERROR cannot find derive macro `Unresolved` in this scope\n+struct S;\n+\n+fn main() {}"}, {"sha": "d625163dc7e1cec64a4599024c9b710caaa18bc7", "filename": "src/test/ui/dollar-crate/dollar-crate-is-keyword.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/760ce94c69ca510d44087291c311296f6d9ccdf5/src%2Ftest%2Fui%2Fdollar-crate%2Fdollar-crate-is-keyword.rs", "raw_url": "https://github.com/rust-lang/rust/raw/760ce94c69ca510d44087291c311296f6d9ccdf5/src%2Ftest%2Fui%2Fdollar-crate%2Fdollar-crate-is-keyword.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdollar-crate%2Fdollar-crate-is-keyword.rs?ref=760ce94c69ca510d44087291c311296f6d9ccdf5", "patch": "@@ -6,10 +6,9 @@ macro_rules! m {\n             struct $crate {} //~ ERROR expected identifier, found reserved identifier `$crate`\n         }\n \n-        use $crate; // OK\n-                    //~^ WARN `$crate` may not be imported\n+        use $crate; //~ ERROR `$crate` may not be imported\n         use $crate as $crate; //~ ERROR expected identifier, found reserved identifier `$crate`\n-                              //~^ WARN `$crate` may not be imported\n+        //~^ ERROR `$crate` may not be imported\n     }\n }\n "}, {"sha": "f5a5f13f9121ec839d9bf4087f98a37e1d33ec37", "filename": "src/test/ui/dollar-crate/dollar-crate-is-keyword.stderr", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/760ce94c69ca510d44087291c311296f6d9ccdf5/src%2Ftest%2Fui%2Fdollar-crate%2Fdollar-crate-is-keyword.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/760ce94c69ca510d44087291c311296f6d9ccdf5/src%2Ftest%2Fui%2Fdollar-crate%2Fdollar-crate-is-keyword.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdollar-crate%2Fdollar-crate-is-keyword.stderr?ref=760ce94c69ca510d44087291c311296f6d9ccdf5", "patch": "@@ -8,35 +8,31 @@ LL | m!();\n    | ----- in this macro invocation\n \n error: expected identifier, found reserved identifier `$crate`\n-  --> $DIR/dollar-crate-is-keyword.rs:11:23\n+  --> $DIR/dollar-crate-is-keyword.rs:10:23\n    |\n LL |         use $crate as $crate;\n    |                       ^^^^^^ expected identifier, found reserved identifier\n ...\n LL | m!();\n    | ----- in this macro invocation\n \n-warning: `$crate` may not be imported\n+error: `$crate` may not be imported\n   --> $DIR/dollar-crate-is-keyword.rs:9:9\n    |\n-LL |         use $crate; // OK\n+LL |         use $crate;\n    |         ^^^^^^^^^^^\n ...\n LL | m!();\n    | ----- in this macro invocation\n-   |\n-   = note: `use $crate;` was erroneously allowed and will become a hard error in a future release\n \n-warning: `$crate` may not be imported\n-  --> $DIR/dollar-crate-is-keyword.rs:11:9\n+error: `$crate` may not be imported\n+  --> $DIR/dollar-crate-is-keyword.rs:10:9\n    |\n LL |         use $crate as $crate;\n    |         ^^^^^^^^^^^^^^^^^^^^^\n ...\n LL | m!();\n    | ----- in this macro invocation\n-   |\n-   = note: `use $crate;` was erroneously allowed and will become a hard error in a future release\n \n-error: aborting due to 2 previous errors\n+error: aborting due to 4 previous errors\n "}, {"sha": "74c6e501c9136289665bdecc706e88ddec372bf0", "filename": "src/test/ui/extern/issue-64655-allow-unwind-when-calling-panic-directly.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/760ce94c69ca510d44087291c311296f6d9ccdf5/src%2Ftest%2Fui%2Fextern%2Fissue-64655-allow-unwind-when-calling-panic-directly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/760ce94c69ca510d44087291c311296f6d9ccdf5/src%2Ftest%2Fui%2Fextern%2Fissue-64655-allow-unwind-when-calling-panic-directly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fextern%2Fissue-64655-allow-unwind-when-calling-panic-directly.rs?ref=760ce94c69ca510d44087291c311296f6d9ccdf5", "patch": "@@ -22,7 +22,7 @@\n //[thin]compile-flags: -C lto=thin\n //[fat]compile-flags: -C lto=fat\n \n-#![feature(core_panic, panic_internals)]\n+#![feature(core_panic)]\n \n // (For some reason, reproducing the LTO issue requires pulling in std\n // explicitly this way.)\n@@ -50,9 +50,7 @@ fn main() {\n         }\n \n         let _guard = Droppable;\n-        let s = \"issue-64655-allow-unwind-when-calling-panic-directly.rs\";\n-        let location = core::panic::Location::internal_constructor(s, 17, 4);\n-        core::panicking::panic(\"???\", &location);\n+        core::panicking::panic(\"???\");\n     });\n \n     let wait = handle.join();"}, {"sha": "aac5a15d3e6b5af72ad29531e28ff3f03c1424d0", "filename": "src/test/ui/imports/import-crate-var.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/760ce94c69ca510d44087291c311296f6d9ccdf5/src%2Ftest%2Fui%2Fimports%2Fimport-crate-var.rs", "raw_url": "https://github.com/rust-lang/rust/raw/760ce94c69ca510d44087291c311296f6d9ccdf5/src%2Ftest%2Fui%2Fimports%2Fimport-crate-var.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimports%2Fimport-crate-var.rs?ref=760ce94c69ca510d44087291c311296f6d9ccdf5", "patch": "@@ -1,10 +1,8 @@\n-// check-pass\n // aux-build:import_crate_var.rs\n \n #[macro_use] extern crate import_crate_var;\n \n fn main() {\n     m!();\n-    //~^ WARN `$crate` may not be imported\n-    //~| NOTE `use $crate;` was erroneously allowed and will become a hard error\n+    //~^ ERROR `$crate` may not be imported\n }"}, {"sha": "85f15ad4648a71618cff265a24173619d2baa8b8", "filename": "src/test/ui/imports/import-crate-var.stderr", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/760ce94c69ca510d44087291c311296f6d9ccdf5/src%2Ftest%2Fui%2Fimports%2Fimport-crate-var.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/760ce94c69ca510d44087291c311296f6d9ccdf5/src%2Ftest%2Fui%2Fimports%2Fimport-crate-var.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimports%2Fimport-crate-var.stderr?ref=760ce94c69ca510d44087291c311296f6d9ccdf5", "patch": "@@ -1,9 +1,10 @@\n-warning: `$crate` may not be imported\n-  --> $DIR/import-crate-var.rs:7:5\n+error: `$crate` may not be imported\n+  --> $DIR/import-crate-var.rs:6:5\n    |\n LL |     m!();\n    |     ^^^^^\n    |\n-   = note: `use $crate;` was erroneously allowed and will become a hard error in a future release\n-   = note: this warning originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\n+   = note: this error originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\n+\n+error: aborting due to previous error\n "}, {"sha": "090e912c1d0ba9fa2ba5342dd163cf7c02e7a87c", "filename": "src/test/ui/rfc-2091-track-caller/caller-location-intrinsic.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/760ce94c69ca510d44087291c311296f6d9ccdf5/src%2Ftest%2Fui%2Frfc-2091-track-caller%2Fcaller-location-intrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/760ce94c69ca510d44087291c311296f6d9ccdf5/src%2Ftest%2Fui%2Frfc-2091-track-caller%2Fcaller-location-intrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2091-track-caller%2Fcaller-location-intrinsic.rs?ref=760ce94c69ca510d44087291c311296f6d9ccdf5", "patch": "@@ -4,16 +4,16 @@\n \n #[inline(never)]\n #[track_caller]\n-fn defeat_const_prop() -> &'static core::panic::Location<'static> {\n+fn codegen_caller_loc() -> &'static core::panic::Location<'static> {\n     core::panic::Location::caller()\n }\n \n macro_rules! caller_location_from_macro {\n-    () => (defeat_const_prop());\n+    () => (codegen_caller_loc());\n }\n \n fn main() {\n-    let loc = defeat_const_prop();\n+    let loc = codegen_caller_loc();\n     assert_eq!(loc.file(), file!());\n     assert_eq!(loc.line(), 16);\n     assert_eq!(loc.column(), 15);"}, {"sha": "1fb75ef35ffc1b6208e2b7577c8eb6577ab56240", "filename": "src/test/ui/rfc-2091-track-caller/diverging-caller-location.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/760ce94c69ca510d44087291c311296f6d9ccdf5/src%2Ftest%2Fui%2Frfc-2091-track-caller%2Fdiverging-caller-location.rs", "raw_url": "https://github.com/rust-lang/rust/raw/760ce94c69ca510d44087291c311296f6d9ccdf5/src%2Ftest%2Fui%2Frfc-2091-track-caller%2Fdiverging-caller-location.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2091-track-caller%2Fdiverging-caller-location.rs?ref=760ce94c69ca510d44087291c311296f6d9ccdf5", "patch": "@@ -0,0 +1,19 @@\n+// run-fail\n+\n+//! This test ensures that `#[track_caller]` can be applied directly to diverging functions, as\n+//! the tracking issue says: https://github.com/rust-lang/rust/issues/47809#issue-292138490.\n+//! Because the annotated function must diverge and a panic keeps that faster than an infinite loop,\n+//! we don't inspect the location returned -- it would be difficult to distinguish between the\n+//! explicit panic and a failed assertion. That it compiles and runs is enough for this one.\n+\n+#![feature(track_caller)]\n+\n+#[track_caller]\n+fn doesnt_return() -> ! {\n+    let _location = core::panic::Location::caller();\n+    panic!(\"huzzah\");\n+}\n+\n+fn main() {\n+    doesnt_return();\n+}"}, {"sha": "76a380ed3e30d21399fd7cf4eb05e23eb7f4a9e3", "filename": "src/test/ui/rfc-2091-track-caller/track-caller-attribute.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/760ce94c69ca510d44087291c311296f6d9ccdf5/src%2Ftest%2Fui%2Frfc-2091-track-caller%2Ftrack-caller-attribute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/760ce94c69ca510d44087291c311296f6d9ccdf5/src%2Ftest%2Fui%2Frfc-2091-track-caller%2Ftrack-caller-attribute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2091-track-caller%2Ftrack-caller-attribute.rs?ref=760ce94c69ca510d44087291c311296f6d9ccdf5", "patch": "@@ -1,6 +1,6 @@\n // run-pass\n \n-#![feature(const_fn, track_caller)]\n+#![feature(track_caller)]\n \n use std::panic::Location;\n "}]}