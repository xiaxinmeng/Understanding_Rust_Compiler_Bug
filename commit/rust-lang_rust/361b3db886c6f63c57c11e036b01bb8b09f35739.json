{"sha": "361b3db886c6f63c57c11e036b01bb8b09f35739", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM2MWIzZGI4ODZjNmY2M2M1N2MxMWUwMzZiMDFiYjhiMDlmMzU3Mzk=", "commit": {"author": {"name": "Michael Hewson", "email": "michael@michaelhewson.ca", "date": "2017-11-09T21:15:35Z"}, "committer": {"name": "Michael Hewson", "email": "michael@michaelhewson.ca", "date": "2017-12-17T09:13:09Z"}, "message": "implement raw-pointer `self`. Works for traits, including trait objects, but not structs", "tree": {"sha": "9aae809be66d5cdb702141fe4378f56b2d2dd15c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9aae809be66d5cdb702141fe4378f56b2d2dd15c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/361b3db886c6f63c57c11e036b01bb8b09f35739", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/361b3db886c6f63c57c11e036b01bb8b09f35739", "html_url": "https://github.com/rust-lang/rust/commit/361b3db886c6f63c57c11e036b01bb8b09f35739", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/361b3db886c6f63c57c11e036b01bb8b09f35739/comments", "author": {"login": "mikeyhew", "id": 6751033, "node_id": "MDQ6VXNlcjY3NTEwMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/6751033?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mikeyhew", "html_url": "https://github.com/mikeyhew", "followers_url": "https://api.github.com/users/mikeyhew/followers", "following_url": "https://api.github.com/users/mikeyhew/following{/other_user}", "gists_url": "https://api.github.com/users/mikeyhew/gists{/gist_id}", "starred_url": "https://api.github.com/users/mikeyhew/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mikeyhew/subscriptions", "organizations_url": "https://api.github.com/users/mikeyhew/orgs", "repos_url": "https://api.github.com/users/mikeyhew/repos", "events_url": "https://api.github.com/users/mikeyhew/events{/privacy}", "received_events_url": "https://api.github.com/users/mikeyhew/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mikeyhew", "id": 6751033, "node_id": "MDQ6VXNlcjY3NTEwMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/6751033?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mikeyhew", "html_url": "https://github.com/mikeyhew", "followers_url": "https://api.github.com/users/mikeyhew/followers", "following_url": "https://api.github.com/users/mikeyhew/following{/other_user}", "gists_url": "https://api.github.com/users/mikeyhew/gists{/gist_id}", "starred_url": "https://api.github.com/users/mikeyhew/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mikeyhew/subscriptions", "organizations_url": "https://api.github.com/users/mikeyhew/orgs", "repos_url": "https://api.github.com/users/mikeyhew/repos", "events_url": "https://api.github.com/users/mikeyhew/events{/privacy}", "received_events_url": "https://api.github.com/users/mikeyhew/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "53a6d14e5bb8b1915a5f0b9371bbf0da934ed052", "url": "https://api.github.com/repos/rust-lang/rust/commits/53a6d14e5bb8b1915a5f0b9371bbf0da934ed052", "html_url": "https://github.com/rust-lang/rust/commit/53a6d14e5bb8b1915a5f0b9371bbf0da934ed052"}], "stats": {"total": 148, "additions": 130, "deletions": 18}, "files": [{"sha": "4151661b5933c30e03c279ebe66493dbbbd0df77", "filename": "src/librustc/traits/object_safety.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/361b3db886c6f63c57c11e036b01bb8b09f35739/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/361b3db886c6f63c57c11e036b01bb8b09f35739/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fobject_safety.rs?ref=361b3db886c6f63c57c11e036b01bb8b09f35739", "patch": "@@ -59,9 +59,7 @@ impl ObjectSafetyViolation {\n             ObjectSafetyViolation::Method(name, MethodViolationCode::Generic) =>\n                 format!(\"method `{}` has generic type parameters\", name).into(),\n             ObjectSafetyViolation::Method(name, MethodViolationCode::NonStandardSelfType) =>\n-                format!(\"method `{}` has a non-standard `self` type. Only `&self`, \\\n-                        `&mut self`, and `Box<Self>` are currently supported \\\n-                        for trait objects\", name).into(),\n+                format!(\"method `{}` has a non-standard `self` type\", name).into(),\n             ObjectSafetyViolation::AssociatedConst(name) =>\n                 format!(\"the trait cannot contain associated consts like `{}`\", name).into(),\n         }"}, {"sha": "46bc54b7f6a670aca91035d8457d667d84bc2d67", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/361b3db886c6f63c57c11e036b01bb8b09f35739/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/361b3db886c6f63c57c11e036b01bb8b09f35739/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=361b3db886c6f63c57c11e036b01bb8b09f35739", "patch": "@@ -1191,6 +1191,7 @@ fn needs_drop_raw<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n pub enum ExplicitSelf<'tcx> {\n     ByValue,\n     ByReference(ty::Region<'tcx>, hir::Mutability),\n+    ByRawPointer(hir::Mutability),\n     ByBox,\n     Other\n }\n@@ -1231,10 +1232,15 @@ impl<'tcx> ExplicitSelf<'tcx> {\n \n         match self_arg_ty.sty {\n             _ if is_self_ty(self_arg_ty) => ByValue,\n-            ty::TyRef(region, ty::TypeAndMut { ty, mutbl}) if is_self_ty(ty) => {\n+            ty::TyRef(region, ty::TypeAndMut { ty, mutbl }) if is_self_ty(ty) => {\n                 ByReference(region, mutbl)\n             }\n-            ty::TyAdt(def, _) if def.is_box() && is_self_ty(self_arg_ty.boxed_ty()) => ByBox,\n+            ty::TyRawPtr(ty::TypeAndMut { ty, mutbl }) if is_self_ty(ty) => {\n+                ByRawPointer(mutbl)\n+            }\n+            ty::TyAdt(def, _) if def.is_box() && is_self_ty(self_arg_ty.boxed_ty()) => {\n+                ByBox\n+            }\n             _ => Other\n         }\n     }"}, {"sha": "7832db7dcb5423b77ea7e3fb1d617dd4524dcc2c", "filename": "src/librustc_typeck/check/autoderef.rs", "status": "modified", "additions": 18, "deletions": 6, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/361b3db886c6f63c57c11e036b01bb8b09f35739/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/361b3db886c6f63c57c11e036b01bb8b09f35739/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs?ref=361b3db886c6f63c57c11e036b01bb8b09f35739", "patch": "@@ -37,6 +37,7 @@ pub struct Autoderef<'a, 'gcx: 'tcx, 'tcx: 'a> {\n     cur_ty: Ty<'tcx>,\n     obligations: Vec<traits::PredicateObligation<'tcx>>,\n     at_start: bool,\n+    include_raw_pointers: bool,\n     span: Span,\n }\n \n@@ -76,12 +77,13 @@ impl<'a, 'gcx, 'tcx> Iterator for Autoderef<'a, 'gcx, 'tcx> {\n         }\n \n         // Otherwise, deref if type is derefable:\n-        let (kind, new_ty) = if let Some(mt) = self.cur_ty.builtin_deref(false, NoPreference) {\n-            (AutoderefKind::Builtin, mt.ty)\n-        } else {\n-            let ty = self.overloaded_deref_ty(self.cur_ty)?;\n-            (AutoderefKind::Overloaded, ty)\n-        };\n+        let (kind, new_ty) =\n+            if let Some(mt) = self.cur_ty.builtin_deref(self.include_raw_pointers, NoPreference) {\n+                (AutoderefKind::Builtin, mt.ty)\n+            } else {\n+                let ty = self.overloaded_deref_ty(self.cur_ty)?;\n+                (AutoderefKind::Overloaded, ty)\n+            };\n \n         if new_ty.references_error() {\n             return None;\n@@ -194,6 +196,15 @@ impl<'a, 'gcx, 'tcx> Autoderef<'a, 'gcx, 'tcx> {\n         }\n     }\n \n+    /// also dereference through raw pointer types\n+    /// e.g. assuming ptr_to_Foo is the type `*const Foo`\n+    /// fcx.autoderef(span, ptr_to_Foo)  => [*const Foo]\n+    /// fcx.autoderef(span, ptr_to_Foo).include_raw_ptrs() => [*const Foo, Foo]\n+    pub fn include_raw_pointers(mut self) -> Self {\n+        self.include_raw_pointers = true;\n+        self\n+    }\n+\n     pub fn finalize(self) {\n         let fcx = self.fcx;\n         fcx.register_predicates(self.into_obligations());\n@@ -212,6 +223,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             cur_ty: self.resolve_type_vars_if_possible(&base_ty),\n             obligations: vec![],\n             at_start: true,\n+            include_raw_pointers: false,\n             span,\n         }\n     }"}, {"sha": "5cb6c6a368e1498bea176a79c55a762c191b1536", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 20, "deletions": 7, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/361b3db886c6f63c57c11e036b01bb8b09f35739/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/361b3db886c6f63c57c11e036b01bb8b09f35739/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=361b3db886c6f63c57c11e036b01bb8b09f35739", "patch": "@@ -503,7 +503,7 @@ impl<'a, 'gcx> CheckTypeWellFormedVisitor<'a, 'gcx> {\n             &ty::Binder(self_arg_ty)\n         );\n \n-        let mut autoderef = fcx.autoderef(span, self_arg_ty);\n+        let mut autoderef = fcx.autoderef(span, self_arg_ty).include_raw_pointers();\n \n         loop {\n             if let Some((potential_self_ty, _)) = autoderef.next() {\n@@ -532,12 +532,25 @@ impl<'a, 'gcx> CheckTypeWellFormedVisitor<'a, 'gcx> {\n         let is_self_ty = |ty| fcx.infcx.can_eq(fcx.param_env, self_ty, ty).is_ok();\n         let self_kind = ExplicitSelf::determine(self_arg_ty, is_self_ty);\n \n-        if let ExplicitSelf::Other = self_kind {\n-            if !fcx.tcx.sess.features.borrow().arbitrary_self_types {\n-                feature_gate::feature_err(&fcx.tcx.sess.parse_sess, \"arbitrary_self_types\", span,\n-                    GateIssue::Language, \"arbitrary `self` types are unstable\")\n-                .help(\"consider changing to `self`, `&self`, `&mut self`, or `self: Box<Self>`\")\n-                .emit();\n+        if !fcx.tcx.sess.features.borrow().arbitrary_self_types {\n+            match self_kind {\n+                ExplicitSelf::ByValue |\n+                ExplicitSelf::ByReference(_, _) |\n+                ExplicitSelf::ByBox => (),\n+\n+                ExplicitSelf::ByRawPointer(_) => {\n+                    feature_gate::feature_err(&fcx.tcx.sess.parse_sess, \"arbitrary_self_types\", span,\n+                        GateIssue::Language, \"raw pointer `self` is unstable\")\n+                    .help(\"consider changing to `self`, `&self`, `&mut self`, or `self: Box<Self>`\")\n+                    .emit();\n+                }\n+\n+                ExplicitSelf::Other => {\n+                    feature_gate::feature_err(&fcx.tcx.sess.parse_sess, \"arbitrary_self_types\", span,\n+                        GateIssue::Language, \"arbitrary `self` types are unstable\")\n+                    .help(\"consider changing to `self`, `&self`, `&mut self`, or `self: Box<Self>`\")\n+                    .emit();\n+                }\n             }\n         }\n     }"}, {"sha": "e213d33a9c2de7a1d80e40dee5e6a5c3742ab273", "filename": "src/test/run-pass/arbitrary_self_types_raw_pointer_struct.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/361b3db886c6f63c57c11e036b01bb8b09f35739/src%2Ftest%2Frun-pass%2Farbitrary_self_types_raw_pointer_struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/361b3db886c6f63c57c11e036b01bb8b09f35739/src%2Ftest%2Frun-pass%2Farbitrary_self_types_raw_pointer_struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Farbitrary_self_types_raw_pointer_struct.rs?ref=361b3db886c6f63c57c11e036b01bb8b09f35739", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(arbitrary_self_types)]\n+\n+struct Foo(String);\n+\n+impl Foo {\n+    unsafe fn foo(self: *const Self) -> *const str {\n+        (*self).0.as_ref()\n+    }\n+}\n+\n+fn main() {\n+    let foo = Foo(\"abc123\".into());\n+    assert_eq!(\"abc123\", unsafe { &*(&foo as *const Foo).foo() });\n+}"}, {"sha": "0d64dacaf4e7c91f9bd9c42b3e868d53df48910d", "filename": "src/test/run-pass/arbitrary_self_types_raw_pointer_trait.rs", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/361b3db886c6f63c57c11e036b01bb8b09f35739/src%2Ftest%2Frun-pass%2Farbitrary_self_types_raw_pointer_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/361b3db886c6f63c57c11e036b01bb8b09f35739/src%2Ftest%2Frun-pass%2Farbitrary_self_types_raw_pointer_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Farbitrary_self_types_raw_pointer_trait.rs?ref=361b3db886c6f63c57c11e036b01bb8b09f35739", "patch": "@@ -0,0 +1,59 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(arbitrary_self_types)]\n+\n+use std::ptr;\n+\n+trait Foo {\n+    fn foo(self: *const Self) -> &'static str;\n+\n+    unsafe fn bar(self: *const Self) -> i64;\n+}\n+\n+impl Foo for i32 {\n+    fn foo(self: *const Self) -> &'static str {\n+        \"I'm an i32!\"\n+    }\n+\n+    unsafe fn bar(self: *const Self) -> i64 {\n+        *self as i64\n+    }\n+}\n+\n+impl Foo for u32 {\n+    fn foo(self: *const Self) -> &'static str {\n+        \"I'm a u32!\"\n+    }\n+\n+    unsafe fn bar(self: *const Self) -> i64 {\n+        *self as i64\n+    }\n+}\n+\n+fn main() {\n+    let foo_i32 = ptr::null::<i32>() as *const Foo;\n+    let foo_u32 = ptr::null::<u32>() as *const Foo;\n+\n+    assert_eq!(\"I'm an i32!\", foo_i32.foo());\n+    assert_eq!(\"I'm a u32!\", foo_u32.foo());\n+\n+    let bar_i32 = 5i32;\n+    let bar_i32_thin = &bar_i32 as *const i32;\n+    assert_eq!(5, unsafe { bar_i32_thin.bar() });\n+    let bar_i32_fat = bar_i32_thin as *const Foo;\n+    assert_eq!(5, unsafe { bar_i32_fat.bar() });\n+\n+    let bar_u32 = 18u32;\n+    let bar_u32_thin = &bar_u32 as *const u32;\n+    assert_eq!(18, unsafe { bar_u32_thin.bar() });\n+    let bar_u32_fat = bar_u32_thin as *const Foo;\n+    assert_eq!(18, unsafe { bar_u32_fat.bar() });\n+}"}]}