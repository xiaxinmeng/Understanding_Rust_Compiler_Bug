{"sha": "89b1686bd7db25b5dd948b1a4d9dfd0c68084c29", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg5YjE2ODZiZDdkYjI1YjVkZDk0OGIxYTRkOWRmZDBjNjgwODRjMjk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-02-14T00:32:01Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-02-14T00:32:01Z"}, "message": "auto merge of #12017 : FlaPer87/rust/replace-mod-crate, r=alexcrichton\n\nThe first setp for #9880 is to add a new `crate` keyword. This PR does exactly that. I took a chance to refactor `parse_item_foreign_mod` and I broke it down into 2 separate methods to isolate each feature.\r\n\r\nThe next step will be to push a new stage0 snapshot and then get rid of all `extern mod` around the code.", "tree": {"sha": "cfde530d295ebf159fc538115565d5ce1409bea3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cfde530d295ebf159fc538115565d5ce1409bea3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/89b1686bd7db25b5dd948b1a4d9dfd0c68084c29", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/89b1686bd7db25b5dd948b1a4d9dfd0c68084c29", "html_url": "https://github.com/rust-lang/rust/commit/89b1686bd7db25b5dd948b1a4d9dfd0c68084c29", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/89b1686bd7db25b5dd948b1a4d9dfd0c68084c29/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "94d453e459107ed1c5d76f693686b29d31cdc58c", "url": "https://api.github.com/repos/rust-lang/rust/commits/94d453e459107ed1c5d76f693686b29d31cdc58c", "html_url": "https://github.com/rust-lang/rust/commit/94d453e459107ed1c5d76f693686b29d31cdc58c"}, {"sha": "5deb3c9ca06509ce261f69fd01426825e32d61c1", "url": "https://api.github.com/repos/rust-lang/rust/commits/5deb3c9ca06509ce261f69fd01426825e32d61c1", "html_url": "https://github.com/rust-lang/rust/commit/5deb3c9ca06509ce261f69fd01426825e32d61c1"}], "stats": {"total": 1194, "additions": 611, "deletions": 583}, "files": [{"sha": "a7214b49bcebb828004bc6b0d6117f98c3df65e5", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 55, "deletions": 55, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/89b1686bd7db25b5dd948b1a4d9dfd0c68084c29/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89b1686bd7db25b5dd948b1a4d9dfd0c68084c29/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=89b1686bd7db25b5dd948b1a4d9dfd0c68084c29", "patch": "@@ -178,18 +178,18 @@ pub fn phase_1_parse_input(sess: Session, cfg: ast::CrateConfig, input: &Input)\n /// standard library and prelude.\n pub fn phase_2_configure_and_expand(sess: Session,\n                                     loader: &mut CrateLoader,\n-                                    mut crate: ast::Crate)\n+                                    mut krate: ast::Crate)\n                                     -> (ast::Crate, syntax::ast_map::Map) {\n     let time_passes = sess.time_passes();\n \n-    sess.building_library.set(session::building_library(sess.opts, &crate));\n-    sess.crate_types.set(session::collect_crate_types(&sess, crate.attrs));\n+    sess.building_library.set(session::building_library(sess.opts, &krate));\n+    sess.crate_types.set(session::collect_crate_types(&sess, krate.attrs));\n \n     time(time_passes, \"gated feature checking\", (), |_|\n-         front::feature_gate::check_crate(sess, &crate));\n+         front::feature_gate::check_crate(sess, &krate));\n \n-    crate = time(time_passes, \"crate injection\", crate, |crate|\n-                 front::std_inject::maybe_inject_crates_ref(sess, crate));\n+    krate = time(time_passes, \"crate injection\", krate, |krate|\n+                 front::std_inject::maybe_inject_crates_ref(sess, krate));\n \n     // strip before expansion to allow macros to depend on\n     // configuration variables e.g/ in\n@@ -199,29 +199,29 @@ pub fn phase_2_configure_and_expand(sess: Session,\n     //\n     // baz! should not use this definition unless foo is enabled.\n \n-    crate = time(time_passes, \"configuration 1\", crate, |crate|\n-                 front::config::strip_unconfigured_items(crate));\n+    krate = time(time_passes, \"configuration 1\", krate, |krate|\n+                 front::config::strip_unconfigured_items(krate));\n \n-    crate = time(time_passes, \"expansion\", crate, |crate| {\n+    krate = time(time_passes, \"expansion\", krate, |krate| {\n         syntax::ext::expand::expand_crate(sess.parse_sess,\n                                           loader,\n-                                          crate)\n+                                          krate)\n     });\n     // dump the syntax-time crates\n     sess.cstore.reset();\n \n     // strip again, in case expansion added anything with a #[cfg].\n-    crate = time(time_passes, \"configuration 2\", crate, |crate|\n-                 front::config::strip_unconfigured_items(crate));\n+    krate = time(time_passes, \"configuration 2\", krate, |krate|\n+                 front::config::strip_unconfigured_items(krate));\n \n-    crate = time(time_passes, \"maybe building test harness\", crate, |crate|\n-                 front::test::modify_for_testing(sess, crate));\n+    krate = time(time_passes, \"maybe building test harness\", krate, |krate|\n+                 front::test::modify_for_testing(sess, krate));\n \n-    crate = time(time_passes, \"prelude injection\", crate, |crate|\n-                 front::std_inject::maybe_inject_prelude(sess, crate));\n+    krate = time(time_passes, \"prelude injection\", krate, |krate|\n+                 front::std_inject::maybe_inject_prelude(sess, krate));\n \n-    time(time_passes, \"assinging node ids and indexing ast\", crate, |crate|\n-         front::assign_node_ids_and_map::assign_node_ids_and_map(sess, crate))\n+    time(time_passes, \"assinging node ids and indexing ast\", krate, |krate|\n+         front::assign_node_ids_and_map::assign_node_ids_and_map(sess, krate))\n }\n \n pub struct CrateAnalysis {\n@@ -237,18 +237,18 @@ pub struct CrateAnalysis {\n /// miscellaneous analysis passes on the crate. Return various\n /// structures carrying the results of the analysis.\n pub fn phase_3_run_analysis_passes(sess: Session,\n-                                   crate: &ast::Crate,\n+                                   krate: &ast::Crate,\n                                    ast_map: syntax::ast_map::Map) -> CrateAnalysis {\n \n     let time_passes = sess.time_passes();\n \n     time(time_passes, \"external crate/lib resolution\", (), |_|\n-         creader::read_crates(sess, crate,\n+         creader::read_crates(sess, krate,\n                               session::sess_os_to_meta_os(sess.targ_cfg.os),\n                               token::get_ident_interner()));\n \n     let lang_items = time(time_passes, \"language item collection\", (), |_|\n-                          middle::lang_items::collect_language_items(crate, sess));\n+                          middle::lang_items::collect_language_items(krate, sess));\n \n     let middle::resolve::CrateMap {\n         def_map: def_map,\n@@ -258,72 +258,72 @@ pub fn phase_3_run_analysis_passes(sess: Session,\n         last_private_map: last_private_map\n     } =\n         time(time_passes, \"resolution\", (), |_|\n-             middle::resolve::resolve_crate(sess, lang_items, crate));\n+             middle::resolve::resolve_crate(sess, lang_items, krate));\n \n     let named_region_map = time(time_passes, \"lifetime resolution\", (),\n-                                |_| middle::resolve_lifetime::crate(sess, crate));\n+                                |_| middle::resolve_lifetime::krate(sess, krate));\n \n     time(time_passes, \"looking for entry point\", (),\n-         |_| middle::entry::find_entry_point(sess, crate, ast_map));\n+         |_| middle::entry::find_entry_point(sess, krate, ast_map));\n \n     sess.macro_registrar_fn.with_mut(|r| *r =\n         time(time_passes, \"looking for macro registrar\", (), |_|\n             syntax::ext::registrar::find_macro_registrar(\n-                sess.span_diagnostic, crate)));\n+                sess.span_diagnostic, krate)));\n \n     let freevars = time(time_passes, \"freevar finding\", (), |_|\n-                        freevars::annotate_freevars(def_map, crate));\n+                        freevars::annotate_freevars(def_map, krate));\n \n     let region_map = time(time_passes, \"region resolution\", (), |_|\n-                          middle::region::resolve_crate(sess, crate));\n+                          middle::region::resolve_crate(sess, krate));\n \n     let ty_cx = ty::mk_ctxt(sess, def_map, named_region_map, ast_map, freevars,\n                             region_map, lang_items);\n \n     // passes are timed inside typeck\n-    let (method_map, vtable_map) = typeck::check_crate(ty_cx, trait_map, crate);\n+    let (method_map, vtable_map) = typeck::check_crate(ty_cx, trait_map, krate);\n \n     // These next two const passes can probably be merged\n     time(time_passes, \"const marking\", (), |_|\n-         middle::const_eval::process_crate(crate, ty_cx));\n+         middle::const_eval::process_crate(krate, ty_cx));\n \n     time(time_passes, \"const checking\", (), |_|\n-         middle::check_const::check_crate(sess, crate, ast_map, def_map,\n+         middle::check_const::check_crate(sess, krate, ast_map, def_map,\n                                           method_map, ty_cx));\n \n     let maps = (external_exports, last_private_map);\n     let (exported_items, public_items) =\n             time(time_passes, \"privacy checking\", maps, |(a, b)|\n                  middle::privacy::check_crate(ty_cx, &method_map, &exp_map2,\n-                                              a, b, crate));\n+                                              a, b, krate));\n \n     time(time_passes, \"effect checking\", (), |_|\n-         middle::effect::check_crate(ty_cx, method_map, crate));\n+         middle::effect::check_crate(ty_cx, method_map, krate));\n \n     time(time_passes, \"loop checking\", (), |_|\n-         middle::check_loop::check_crate(ty_cx, crate));\n+         middle::check_loop::check_crate(ty_cx, krate));\n \n     let middle::moves::MoveMaps {moves_map, moved_variables_set,\n                                  capture_map} =\n         time(time_passes, \"compute moves\", (), |_|\n-             middle::moves::compute_moves(ty_cx, method_map, crate));\n+             middle::moves::compute_moves(ty_cx, method_map, krate));\n \n     time(time_passes, \"match checking\", (), |_|\n          middle::check_match::check_crate(ty_cx, method_map,\n-                                          moves_map, crate));\n+                                          moves_map, krate));\n \n     time(time_passes, \"liveness checking\", (), |_|\n          middle::liveness::check_crate(ty_cx, method_map,\n-                                       capture_map, crate));\n+                                       capture_map, krate));\n \n     let root_map =\n         time(time_passes, \"borrow checking\", (), |_|\n              middle::borrowck::check_crate(ty_cx, method_map,\n                                            moves_map, moved_variables_set,\n-                                           capture_map, crate));\n+                                           capture_map, krate));\n \n     time(time_passes, \"kind checking\", (), |_|\n-         kind::check_crate(ty_cx, method_map, crate));\n+         kind::check_crate(ty_cx, method_map, krate));\n \n     let reachable_map =\n         time(time_passes, \"reachability checking\", (), |_|\n@@ -336,12 +336,12 @@ pub fn phase_3_run_analysis_passes(sess: Session,\n                                        method_map,\n                                        &exported_items,\n                                        reachable_map.get(),\n-                                       crate)\n+                                       krate)\n         });\n     }\n \n     time(time_passes, \"lint checking\", (), |_|\n-         lint::check_crate(ty_cx, method_map, &exported_items, crate));\n+         lint::check_crate(ty_cx, method_map, &exported_items, krate));\n \n     CrateAnalysis {\n         exp_map2: exp_map2,\n@@ -370,11 +370,11 @@ pub struct CrateTranslation {\n /// Run the translation phase to LLVM, after which the AST and analysis can\n /// be discarded.\n pub fn phase_4_translate_to_llvm(sess: Session,\n-                                 crate: ast::Crate,\n+                                 krate: ast::Crate,\n                                  analysis: &CrateAnalysis,\n                                  outputs: &OutputFilenames) -> CrateTranslation {\n-    time(sess.time_passes(), \"translation\", crate, |crate|\n-         trans::base::trans_crate(sess, crate, analysis, outputs))\n+    time(sess.time_passes(), \"translation\", krate, |krate|\n+         trans::base::trans_crate(sess, krate, analysis, outputs))\n }\n \n /// Run LLVM itself, producing a bitcode file, assembly file or object file\n@@ -450,8 +450,8 @@ pub fn stop_after_phase_5(sess: Session) -> bool {\n fn write_out_deps(sess: Session,\n                   input: &Input,\n                   outputs: &OutputFilenames,\n-                  crate: &ast::Crate) -> io::IoResult<()> {\n-    let lm = link::build_link_meta(crate.attrs, outputs,\n+                  krate: &ast::Crate) -> io::IoResult<()> {\n+    let lm = link::build_link_meta(krate.attrs, outputs,\n                                    &mut ::util::sha2::Sha256::new());\n \n     let mut out_filenames = ~[];\n@@ -517,14 +517,14 @@ pub fn compile_input(sess: Session, cfg: ast::CrateConfig, input: &Input,\n     // possible to keep the peak memory usage low\n     let (outputs, trans) = {\n         let (expanded_crate, ast_map) = {\n-            let crate = phase_1_parse_input(sess, cfg, input);\n+            let krate = phase_1_parse_input(sess, cfg, input);\n             if sess.show_span() {\n-                front::show_span::run(sess, &crate);\n+                front::show_span::run(sess, &krate);\n                 return;\n             }\n             if stop_after_phase_1(sess) { return; }\n             let loader = &mut Loader::new(sess);\n-            phase_2_configure_and_expand(sess, loader, crate)\n+            phase_2_configure_and_expand(sess, loader, krate)\n         };\n         let outputs = build_output_filenames(input, outdir, output,\n                                              expanded_crate.attrs, sess);\n@@ -609,15 +609,15 @@ pub fn pretty_print_input(sess: Session,\n                           cfg: ast::CrateConfig,\n                           input: &Input,\n                           ppm: PpMode) {\n-    let crate = phase_1_parse_input(sess, cfg, input);\n+    let krate = phase_1_parse_input(sess, cfg, input);\n \n-    let (crate, ast_map, is_expanded) = match ppm {\n+    let (krate, ast_map, is_expanded) = match ppm {\n         PpmExpanded | PpmExpandedIdentified | PpmTyped => {\n             let loader = &mut Loader::new(sess);\n-            let (crate, ast_map) = phase_2_configure_and_expand(sess, loader, crate);\n-            (crate, Some(ast_map), true)\n+            let (krate, ast_map) = phase_2_configure_and_expand(sess, loader, krate);\n+            (krate, Some(ast_map), true)\n         }\n-        _ => (crate, None, false)\n+        _ => (krate, None, false)\n     };\n \n     let annotation = match ppm {\n@@ -626,7 +626,7 @@ pub fn pretty_print_input(sess: Session,\n         }\n         PpmTyped => {\n             let ast_map = ast_map.expect(\"--pretty=typed missing ast_map\");\n-            let analysis = phase_3_run_analysis_passes(sess, &crate, ast_map);\n+            let analysis = phase_3_run_analysis_passes(sess, &krate, ast_map);\n             ~TypedAnnotation {\n                 analysis: analysis\n             } as ~pprust::PpAnn:\n@@ -640,7 +640,7 @@ pub fn pretty_print_input(sess: Session,\n     pprust::print_crate(sess.codemap,\n                         token::get_ident_interner(),\n                         sess.span_diagnostic,\n-                        &crate,\n+                        &krate,\n                         source_name(input),\n                         &mut rdr,\n                         ~stdout as ~io::Writer,"}, {"sha": "336d9f55d37d386502ea64a40c6167951e49422b", "filename": "src/librustc/driver/session.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/89b1686bd7db25b5dd948b1a4d9dfd0c68084c29/src%2Flibrustc%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89b1686bd7db25b5dd948b1a4d9dfd0c68084c29/src%2Flibrustc%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fsession.rs?ref=89b1686bd7db25b5dd948b1a4d9dfd0c68084c29", "patch": "@@ -456,15 +456,15 @@ pub fn expect<T:Clone>(sess: Session, opt: Option<T>, msg: || -> ~str) -> T {\n     diagnostic::expect(sess.diagnostic(), opt, msg)\n }\n \n-pub fn building_library(options: &Options, crate: &ast::Crate) -> bool {\n+pub fn building_library(options: &Options, krate: &ast::Crate) -> bool {\n     if options.test { return false }\n     for output in options.crate_types.iter() {\n         match *output {\n             CrateTypeExecutable => {}\n             CrateTypeStaticlib | CrateTypeDylib | CrateTypeRlib => return true\n         }\n     }\n-    match syntax::attr::first_attr_value_str_by_name(crate.attrs, \"crate_type\") {\n+    match syntax::attr::first_attr_value_str_by_name(krate.attrs, \"crate_type\") {\n         Some(s) => {\n             s.equiv(&(\"lib\")) ||\n             s.equiv(&(\"rlib\")) ||"}, {"sha": "a6871e513a91a4d400e485783d31cb6195242d47", "filename": "src/librustc/front/assign_node_ids_and_map.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/89b1686bd7db25b5dd948b1a4d9dfd0c68084c29/src%2Flibrustc%2Ffront%2Fassign_node_ids_and_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89b1686bd7db25b5dd948b1a4d9dfd0c68084c29/src%2Flibrustc%2Ffront%2Fassign_node_ids_and_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fassign_node_ids_and_map.rs?ref=89b1686bd7db25b5dd948b1a4d9dfd0c68084c29", "patch": "@@ -24,6 +24,6 @@ impl ast_map::FoldOps for NodeIdAssigner {\n     }\n }\n \n-pub fn assign_node_ids_and_map(sess: Session, crate: ast::Crate) -> (ast::Crate, ast_map::Map) {\n-    ast_map::map_crate(sess.diagnostic(), crate, NodeIdAssigner { sess: sess })\n+pub fn assign_node_ids_and_map(sess: Session, krate: ast::Crate) -> (ast::Crate, ast_map::Map) {\n+    ast_map::map_crate(sess.diagnostic(), krate, NodeIdAssigner { sess: sess })\n }"}, {"sha": "f2130033eed922ddf3699e0a92fac8441d1443aa", "filename": "src/librustc/front/config.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/89b1686bd7db25b5dd948b1a4d9dfd0c68084c29/src%2Flibrustc%2Ffront%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89b1686bd7db25b5dd948b1a4d9dfd0c68084c29/src%2Flibrustc%2Ffront%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fconfig.rs?ref=89b1686bd7db25b5dd948b1a4d9dfd0c68084c29", "patch": "@@ -19,9 +19,9 @@ struct Context<'a> {\n \n // Support conditional compilation by transforming the AST, stripping out\n // any items that do not belong in the current configuration\n-pub fn strip_unconfigured_items(crate: ast::Crate) -> ast::Crate {\n-    let config = crate.config.clone();\n-    strip_items(crate, |attrs| in_cfg(config, attrs))\n+pub fn strip_unconfigured_items(krate: ast::Crate) -> ast::Crate {\n+    let config = krate.config.clone();\n+    strip_items(krate, |attrs| in_cfg(config, attrs))\n }\n \n impl<'a> fold::Folder for Context<'a> {\n@@ -39,13 +39,13 @@ impl<'a> fold::Folder for Context<'a> {\n     }\n }\n \n-pub fn strip_items(crate: ast::Crate,\n+pub fn strip_items(krate: ast::Crate,\n                    in_cfg: |attrs: &[ast::Attribute]| -> bool)\n                    -> ast::Crate {\n     let mut ctxt = Context {\n         in_cfg: in_cfg,\n     };\n-    ctxt.fold_crate(crate)\n+    ctxt.fold_crate(krate)\n }\n \n fn filter_view_item<'r>(cx: &Context, view_item: &'r ast::ViewItem)"}, {"sha": "e023003ff9fac689391f1e942cee295a8c7fe35d", "filename": "src/librustc/front/feature_gate.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/89b1686bd7db25b5dd948b1a4d9dfd0c68084c29/src%2Flibrustc%2Ffront%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89b1686bd7db25b5dd948b1a4d9dfd0c68084c29/src%2Flibrustc%2Ffront%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ffeature_gate.rs?ref=89b1686bd7db25b5dd948b1a4d9dfd0c68084c29", "patch": "@@ -266,13 +266,13 @@ impl Visitor<()> for Context {\n     }\n }\n \n-pub fn check_crate(sess: Session, crate: &ast::Crate) {\n+pub fn check_crate(sess: Session, krate: &ast::Crate) {\n     let mut cx = Context {\n         features: ~[],\n         sess: sess,\n     };\n \n-    for attr in crate.attrs.iter() {\n+    for attr in krate.attrs.iter() {\n         if !attr.name().equiv(&(\"feature\")) {\n             continue\n         }\n@@ -315,7 +315,7 @@ pub fn check_crate(sess: Session, crate: &ast::Crate) {\n         }\n     }\n \n-    visit::walk_crate(&mut cx, crate, ());\n+    visit::walk_crate(&mut cx, krate, ());\n \n     sess.abort_if_errors();\n }"}, {"sha": "aa6fa321a31c054300b2a06b384eb22e8164daaf", "filename": "src/librustc/front/show_span.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/89b1686bd7db25b5dd948b1a4d9dfd0c68084c29/src%2Flibrustc%2Ffront%2Fshow_span.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89b1686bd7db25b5dd948b1a4d9dfd0c68084c29/src%2Flibrustc%2Ffront%2Fshow_span.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fshow_span.rs?ref=89b1686bd7db25b5dd948b1a4d9dfd0c68084c29", "patch": "@@ -30,7 +30,7 @@ impl Visitor<()> for ShowSpanVisitor {\n     }\n }\n \n-pub fn run(sess: Session, crate: &ast::Crate) {\n+pub fn run(sess: Session, krate: &ast::Crate) {\n     let mut v = ShowSpanVisitor { sess: sess };\n-    visit::walk_crate(&mut v, crate, ());\n+    visit::walk_crate(&mut v, krate, ());\n }"}, {"sha": "8171e78151e50683e1cea3770dcd5a12ea7c4ce8", "filename": "src/librustc/front/std_inject.rs", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/89b1686bd7db25b5dd948b1a4d9dfd0c68084c29/src%2Flibrustc%2Ffront%2Fstd_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89b1686bd7db25b5dd948b1a4d9dfd0c68084c29/src%2Flibrustc%2Ffront%2Fstd_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fstd_inject.rs?ref=89b1686bd7db25b5dd948b1a4d9dfd0c68084c29", "patch": "@@ -25,29 +25,29 @@ use syntax::util::small_vector::SmallVector;\n \n pub static VERSION: &'static str = \"0.10-pre\";\n \n-pub fn maybe_inject_crates_ref(sess: Session, crate: ast::Crate)\n+pub fn maybe_inject_crates_ref(sess: Session, krate: ast::Crate)\n                                -> ast::Crate {\n-    if use_std(&crate) {\n-        inject_crates_ref(sess, crate)\n+    if use_std(&krate) {\n+        inject_crates_ref(sess, krate)\n     } else {\n-        crate\n+        krate\n     }\n }\n \n-pub fn maybe_inject_prelude(sess: Session, crate: ast::Crate) -> ast::Crate {\n-    if use_std(&crate) {\n-        inject_prelude(sess, crate)\n+pub fn maybe_inject_prelude(sess: Session, krate: ast::Crate) -> ast::Crate {\n+    if use_std(&krate) {\n+        inject_prelude(sess, krate)\n     } else {\n-        crate\n+        krate\n     }\n }\n \n-fn use_std(crate: &ast::Crate) -> bool {\n-    !attr::contains_name(crate.attrs, \"no_std\")\n+fn use_std(krate: &ast::Crate) -> bool {\n+    !attr::contains_name(krate.attrs, \"no_std\")\n }\n \n-fn use_uv(crate: &ast::Crate) -> bool {\n-    !attr::contains_name(crate.attrs, \"no_uv\")\n+fn use_uv(krate: &ast::Crate) -> bool {\n+    !attr::contains_name(krate.attrs, \"no_uv\")\n }\n \n fn no_prelude(attrs: &[ast::Attribute]) -> bool {\n@@ -58,20 +58,20 @@ struct StandardLibraryInjector {\n     sess: Session,\n }\n \n-pub fn with_version(crate: &str) -> Option<(InternedString, ast::StrStyle)> {\n+pub fn with_version(krate: &str) -> Option<(InternedString, ast::StrStyle)> {\n     match option_env!(\"CFG_DISABLE_INJECT_STD_VERSION\") {\n         Some(\"1\") => None,\n         _ => {\n             Some((token::intern_and_get_ident(format!(\"{}\\\\#{}\",\n-                                                      crate,\n+                                                      krate,\n                                                       VERSION)),\n                   ast::CookedStr))\n         }\n     }\n }\n \n impl fold::Folder for StandardLibraryInjector {\n-    fn fold_crate(&mut self, crate: ast::Crate) -> ast::Crate {\n+    fn fold_crate(&mut self, krate: ast::Crate) -> ast::Crate {\n         let mut vis = ~[ast::ViewItem {\n             node: ast::ViewItemExternMod(self.sess.ident_of(\"std\"),\n                                          with_version(\"std\"),\n@@ -88,7 +88,7 @@ impl fold::Folder for StandardLibraryInjector {\n             span: DUMMY_SP\n         }];\n \n-        if use_uv(&crate) && !self.sess.building_library.get() {\n+        if use_uv(&krate) && !self.sess.building_library.get() {\n             vis.push(ast::ViewItem {\n                 node: ast::ViewItemExternMod(self.sess.ident_of(\"green\"),\n                                              with_version(\"green\"),\n@@ -107,24 +107,24 @@ impl fold::Folder for StandardLibraryInjector {\n             });\n         }\n \n-        vis.push_all(crate.module.view_items);\n+        vis.push_all(krate.module.view_items);\n         let new_module = ast::Mod {\n             view_items: vis,\n-            ..crate.module.clone()\n+            ..krate.module.clone()\n         };\n \n         ast::Crate {\n             module: new_module,\n-            ..crate\n+            ..krate\n         }\n     }\n }\n \n-fn inject_crates_ref(sess: Session, crate: ast::Crate) -> ast::Crate {\n+fn inject_crates_ref(sess: Session, krate: ast::Crate) -> ast::Crate {\n     let mut fold = StandardLibraryInjector {\n         sess: sess,\n     };\n-    fold.fold_crate(crate)\n+    fold.fold_crate(krate)\n }\n \n struct PreludeInjector {\n@@ -133,16 +133,16 @@ struct PreludeInjector {\n \n \n impl fold::Folder for PreludeInjector {\n-    fn fold_crate(&mut self, crate: ast::Crate) -> ast::Crate {\n-        if !no_prelude(crate.attrs) {\n+    fn fold_crate(&mut self, krate: ast::Crate) -> ast::Crate {\n+        if !no_prelude(krate.attrs) {\n             // only add `use std::prelude::*;` if there wasn't a\n             // `#[no_implicit_prelude];` at the crate level.\n             ast::Crate {\n-                module: self.fold_mod(&crate.module),\n-                ..crate\n+                module: self.fold_mod(&krate.module),\n+                ..krate\n             }\n         } else {\n-            crate\n+            krate\n         }\n     }\n \n@@ -194,9 +194,9 @@ impl fold::Folder for PreludeInjector {\n     }\n }\n \n-fn inject_prelude(sess: Session, crate: ast::Crate) -> ast::Crate {\n+fn inject_prelude(sess: Session, krate: ast::Crate) -> ast::Crate {\n     let mut fold = PreludeInjector {\n         sess: sess,\n     };\n-    fold.fold_crate(crate)\n+    fold.fold_crate(krate)\n }"}, {"sha": "c28fec12323758b4e91538967ebf5928735f9290", "filename": "src/librustc/front/test.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/89b1686bd7db25b5dd948b1a4d9dfd0c68084c29/src%2Flibrustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89b1686bd7db25b5dd948b1a4d9dfd0c68084c29/src%2Flibrustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ftest.rs?ref=89b1686bd7db25b5dd948b1a4d9dfd0c68084c29", "patch": "@@ -53,16 +53,16 @@ struct TestCtxt<'a> {\n // Traverse the crate, collecting all the test functions, eliding any\n // existing main functions, and synthesizing a main test harness\n pub fn modify_for_testing(sess: session::Session,\n-                          crate: ast::Crate) -> ast::Crate {\n+                          krate: ast::Crate) -> ast::Crate {\n     // We generate the test harness when building in the 'test'\n     // configuration, either with the '--test' or '--cfg test'\n     // command line options.\n-    let should_test = attr::contains_name(crate.config, \"test\");\n+    let should_test = attr::contains_name(krate.config, \"test\");\n \n     if should_test {\n-        generate_test_harness(sess, crate)\n+        generate_test_harness(sess, krate)\n     } else {\n-        strip_test_functions(crate)\n+        strip_test_functions(krate)\n     }\n }\n \n@@ -156,16 +156,16 @@ impl<'a> fold::Folder for TestHarnessGenerator<'a> {\n     }\n }\n \n-fn generate_test_harness(sess: session::Session, crate: ast::Crate)\n+fn generate_test_harness(sess: session::Session, krate: ast::Crate)\n                          -> ast::Crate {\n     let loader = &mut Loader::new(sess);\n     let mut cx: TestCtxt = TestCtxt {\n         sess: sess,\n         ext_cx: ExtCtxt::new(sess.parse_sess, sess.opts.cfg.clone(), loader),\n         path: RefCell::new(~[]),\n         testfns: RefCell::new(~[]),\n-        is_extra: is_extra(&crate),\n-        config: crate.config.clone(),\n+        is_extra: is_extra(&krate),\n+        config: krate.config.clone(),\n     };\n \n     cx.ext_cx.bt_push(ExpnInfo {\n@@ -180,15 +180,15 @@ fn generate_test_harness(sess: session::Session, crate: ast::Crate)\n     let mut fold = TestHarnessGenerator {\n         cx: cx\n     };\n-    let res = fold.fold_crate(crate);\n+    let res = fold.fold_crate(krate);\n     fold.cx.ext_cx.bt_pop();\n     return res;\n }\n \n-fn strip_test_functions(crate: ast::Crate) -> ast::Crate {\n+fn strip_test_functions(krate: ast::Crate) -> ast::Crate {\n     // When not compiling with --test we should not compile the\n     // #[test] functions\n-    config::strip_items(crate, |attrs| {\n+    config::strip_items(krate, |attrs| {\n         !attr::contains_name(attrs, \"test\") &&\n         !attr::contains_name(attrs, \"bench\")\n     })\n@@ -390,8 +390,8 @@ fn mk_tests(cx: &TestCtxt) -> @ast::Item {\n     )).unwrap()\n }\n \n-fn is_extra(crate: &ast::Crate) -> bool {\n-    match attr::find_crateid(crate.attrs) {\n+fn is_extra(krate: &ast::Crate) -> bool {\n+    match attr::find_crateid(krate.attrs) {\n         Some(ref s) if \"extra\" == s.name => true,\n         _ => false\n     }"}, {"sha": "e62ae091daf61d03b53ed3d95268f888f0ac527a", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/89b1686bd7db25b5dd948b1a4d9dfd0c68084c29/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89b1686bd7db25b5dd948b1a4d9dfd0c68084c29/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=89b1686bd7db25b5dd948b1a4d9dfd0c68084c29", "patch": "@@ -35,7 +35,7 @@ use syntax::visit;\n // Traverses an AST, reading all the information about use'd crates and extern\n // libraries necessary for later resolving, typechecking, linking, etc.\n pub fn read_crates(sess: Session,\n-                   crate: &ast::Crate,\n+                   krate: &ast::Crate,\n                    os: loader::Os,\n                    intr: @IdentInterner) {\n     let mut e = Env {\n@@ -45,12 +45,12 @@ pub fn read_crates(sess: Session,\n         next_crate_num: 1,\n         intr: intr\n     };\n-    visit_crate(&e, crate);\n+    visit_crate(&e, krate);\n     {\n         let mut v = ReadCrateVisitor {\n             e: &mut e\n         };\n-        visit::walk_crate(&mut v, crate, ());\n+        visit::walk_crate(&mut v, krate, ());\n     }\n     let crate_cache = e.crate_cache.borrow();\n     dump_crates(*crate_cache.get());\n@@ -424,14 +424,14 @@ impl Loader {\n }\n \n impl CrateLoader for Loader {\n-    fn load_crate(&mut self, crate: &ast::ViewItem) -> MacroCrate {\n-        let info = extract_crate_info(crate).unwrap();\n+    fn load_crate(&mut self, krate: &ast::ViewItem) -> MacroCrate {\n+        let info = extract_crate_info(krate).unwrap();\n         let cnum = resolve_crate(&mut self.env,\n                                  info.ident.clone(),\n                                  info.name.clone(),\n                                  info.version.clone(),\n                                  ~\"\",\n-                                 crate.span);\n+                                 krate.span);\n         let library = self.env.sess.cstore.get_used_crate_source(cnum).unwrap();\n         MacroCrate {\n             lib: library.dylib,"}, {"sha": "43694415d8d48a2c44e7209acc8a32e34db99adc", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/89b1686bd7db25b5dd948b1a4d9dfd0c68084c29/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89b1686bd7db25b5dd948b1a4d9dfd0c68084c29/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=89b1686bd7db25b5dd948b1a4d9dfd0c68084c29", "patch": "@@ -32,13 +32,13 @@ pub struct StaticMethodInfo {\n }\n \n pub fn get_symbol(cstore: @cstore::CStore, def: ast::DefId) -> ~str {\n-    let cdata = cstore.get_crate_data(def.crate).data();\n+    let cdata = cstore.get_crate_data(def.krate).data();\n     return decoder::get_symbol(cdata, def.node);\n }\n \n pub fn get_type_param_count(cstore: @cstore::CStore, def: ast::DefId)\n                          -> uint {\n-    let cdata = cstore.get_crate_data(def.crate).data();\n+    let cdata = cstore.get_crate_data(def.krate).data();\n     return decoder::get_type_param_count(cdata, def.node);\n }\n \n@@ -57,7 +57,7 @@ pub fn each_child_of_item(cstore: @cstore::CStore,\n                           callback: |decoder::DefLike,\n                                      ast::Ident,\n                                      ast::Visibility|) {\n-    let crate_data = cstore.get_crate_data(def_id.crate);\n+    let crate_data = cstore.get_crate_data(def_id.krate);\n     let get_crate_data: decoder::GetCrateDataCb = |cnum| {\n         cstore.get_crate_data(cnum)\n     };\n@@ -86,7 +86,7 @@ pub fn each_top_level_item_of_crate(cstore: @cstore::CStore,\n \n pub fn get_item_path(tcx: ty::ctxt, def: ast::DefId) -> ast_map::Path {\n     let cstore = tcx.cstore;\n-    let cdata = cstore.get_crate_data(def.crate);\n+    let cdata = cstore.get_crate_data(def.krate);\n     let path = decoder::get_item_path(cdata, def.node);\n \n     // FIXME #1920: This path is not always correct if the crate is not linked\n@@ -108,109 +108,109 @@ pub fn maybe_get_item_ast(tcx: ty::ctxt, def: ast::DefId,\n                           decode_inlined_item: decoder::decode_inlined_item)\n                        -> found_ast {\n     let cstore = tcx.cstore;\n-    let cdata = cstore.get_crate_data(def.crate);\n+    let cdata = cstore.get_crate_data(def.krate);\n     decoder::maybe_get_item_ast(cdata, tcx, def.node,\n                                 decode_inlined_item)\n }\n \n pub fn get_enum_variants(tcx: ty::ctxt, def: ast::DefId)\n                       -> ~[@ty::VariantInfo] {\n     let cstore = tcx.cstore;\n-    let cdata = cstore.get_crate_data(def.crate);\n+    let cdata = cstore.get_crate_data(def.krate);\n     return decoder::get_enum_variants(cstore.intr, cdata, def.node, tcx)\n }\n \n /// Returns information about the given implementation.\n pub fn get_impl(tcx: ty::ctxt, impl_def_id: ast::DefId)\n                 -> ty::Impl {\n-    let cdata = tcx.cstore.get_crate_data(impl_def_id.crate);\n+    let cdata = tcx.cstore.get_crate_data(impl_def_id.krate);\n     decoder::get_impl(tcx.cstore.intr, cdata, impl_def_id.node, tcx)\n }\n \n pub fn get_method(tcx: ty::ctxt, def: ast::DefId) -> ty::Method {\n-    let cdata = tcx.cstore.get_crate_data(def.crate);\n+    let cdata = tcx.cstore.get_crate_data(def.krate);\n     decoder::get_method(tcx.cstore.intr, cdata, def.node, tcx)\n }\n \n pub fn get_method_name_and_explicit_self(cstore: @cstore::CStore,\n                                          def: ast::DefId)\n                                      -> (ast::Ident, ast::ExplicitSelf_)\n {\n-    let cdata = cstore.get_crate_data(def.crate);\n+    let cdata = cstore.get_crate_data(def.krate);\n     decoder::get_method_name_and_explicit_self(cstore.intr, cdata, def.node)\n }\n \n pub fn get_trait_method_def_ids(cstore: @cstore::CStore,\n                                 def: ast::DefId) -> ~[ast::DefId] {\n-    let cdata = cstore.get_crate_data(def.crate);\n+    let cdata = cstore.get_crate_data(def.krate);\n     decoder::get_trait_method_def_ids(cdata, def.node)\n }\n \n pub fn get_item_variances(cstore: @cstore::CStore,\n                           def: ast::DefId) -> ty::ItemVariances {\n-    let cdata = cstore.get_crate_data(def.crate);\n+    let cdata = cstore.get_crate_data(def.krate);\n     decoder::get_item_variances(cdata, def.node)\n }\n \n pub fn get_provided_trait_methods(tcx: ty::ctxt,\n                                   def: ast::DefId)\n                                -> ~[@ty::Method] {\n     let cstore = tcx.cstore;\n-    let cdata = cstore.get_crate_data(def.crate);\n+    let cdata = cstore.get_crate_data(def.krate);\n     decoder::get_provided_trait_methods(cstore.intr, cdata, def.node, tcx)\n }\n \n pub fn get_supertraits(tcx: ty::ctxt, def: ast::DefId) -> ~[@ty::TraitRef] {\n     let cstore = tcx.cstore;\n-    let cdata = cstore.get_crate_data(def.crate);\n+    let cdata = cstore.get_crate_data(def.krate);\n     decoder::get_supertraits(cdata, def.node, tcx)\n }\n \n pub fn get_type_name_if_impl(cstore: @cstore::CStore, def: ast::DefId)\n                           -> Option<ast::Ident> {\n-    let cdata = cstore.get_crate_data(def.crate);\n+    let cdata = cstore.get_crate_data(def.krate);\n     decoder::get_type_name_if_impl(cdata, def.node)\n }\n \n pub fn get_static_methods_if_impl(cstore: @cstore::CStore,\n                                   def: ast::DefId)\n                                -> Option<~[StaticMethodInfo]> {\n-    let cdata = cstore.get_crate_data(def.crate);\n+    let cdata = cstore.get_crate_data(def.krate);\n     decoder::get_static_methods_if_impl(cstore.intr, cdata, def.node)\n }\n \n pub fn get_item_attrs(cstore: @cstore::CStore,\n                       def_id: ast::DefId,\n                       f: |~[@ast::MetaItem]|) {\n-    let cdata = cstore.get_crate_data(def_id.crate);\n+    let cdata = cstore.get_crate_data(def_id.krate);\n     decoder::get_item_attrs(cdata, def_id.node, f)\n }\n \n pub fn get_struct_fields(cstore: @cstore::CStore,\n                          def: ast::DefId)\n                       -> ~[ty::field_ty] {\n-    let cdata = cstore.get_crate_data(def.crate);\n+    let cdata = cstore.get_crate_data(def.krate);\n     decoder::get_struct_fields(cstore.intr, cdata, def.node)\n }\n \n pub fn get_type(tcx: ty::ctxt,\n                 def: ast::DefId)\n              -> ty::ty_param_bounds_and_ty {\n     let cstore = tcx.cstore;\n-    let cdata = cstore.get_crate_data(def.crate);\n+    let cdata = cstore.get_crate_data(def.krate);\n     decoder::get_type(cdata, def.node, tcx)\n }\n \n pub fn get_trait_def(tcx: ty::ctxt, def: ast::DefId) -> ty::TraitDef {\n     let cstore = tcx.cstore;\n-    let cdata = cstore.get_crate_data(def.crate);\n+    let cdata = cstore.get_crate_data(def.krate);\n     decoder::get_trait_def(cdata, def.node, tcx)\n }\n \n pub fn get_field_type(tcx: ty::ctxt, class_id: ast::DefId,\n                       def: ast::DefId) -> ty::ty_param_bounds_and_ty {\n     let cstore = tcx.cstore;\n-    let cdata = cstore.get_crate_data(class_id.crate);\n+    let cdata = cstore.get_crate_data(class_id.krate);\n     let all_items = reader::get_doc(reader::Doc(cdata.data()), tag_items);\n     let class_doc = expect(tcx.diag,\n                            decoder::maybe_find_item(class_id.node, all_items),\n@@ -233,30 +233,30 @@ pub fn get_field_type(tcx: ty::ctxt, class_id: ast::DefId,\n pub fn get_impl_trait(tcx: ty::ctxt,\n                       def: ast::DefId) -> Option<@ty::TraitRef> {\n     let cstore = tcx.cstore;\n-    let cdata = cstore.get_crate_data(def.crate);\n+    let cdata = cstore.get_crate_data(def.krate);\n     decoder::get_impl_trait(cdata, def.node, tcx)\n }\n \n // Given a def_id for an impl, return information about its vtables\n pub fn get_impl_vtables(tcx: ty::ctxt,\n                         def: ast::DefId) -> typeck::impl_res {\n     let cstore = tcx.cstore;\n-    let cdata = cstore.get_crate_data(def.crate);\n+    let cdata = cstore.get_crate_data(def.krate);\n     decoder::get_impl_vtables(cdata, def.node, tcx)\n }\n \n pub fn get_impl_method(cstore: @cstore::CStore,\n                        def: ast::DefId,\n                        mname: ast::Ident)\n                     -> Option<ast::DefId> {\n-    let cdata = cstore.get_crate_data(def.crate);\n+    let cdata = cstore.get_crate_data(def.krate);\n     decoder::get_impl_method(cstore.intr, cdata, def.node, mname)\n }\n \n pub fn get_item_visibility(cstore: @cstore::CStore,\n                            def_id: ast::DefId)\n                         -> ast::Visibility {\n-    let cdata = cstore.get_crate_data(def_id.crate);\n+    let cdata = cstore.get_crate_data(def_id.krate);\n     decoder::get_item_visibility(cdata, def_id.node)\n }\n \n@@ -277,14 +277,14 @@ pub fn each_impl(cstore: @cstore::CStore,\n pub fn each_implementation_for_type(cstore: @cstore::CStore,\n                                     def_id: ast::DefId,\n                                     callback: |ast::DefId|) {\n-    let cdata = cstore.get_crate_data(def_id.crate);\n+    let cdata = cstore.get_crate_data(def_id.krate);\n     decoder::each_implementation_for_type(cdata, def_id.node, callback)\n }\n \n pub fn each_implementation_for_trait(cstore: @cstore::CStore,\n                                      def_id: ast::DefId,\n                                      callback: |ast::DefId|) {\n-    let cdata = cstore.get_crate_data(def_id.crate);\n+    let cdata = cstore.get_crate_data(def_id.krate);\n     decoder::each_implementation_for_trait(cdata, def_id.node, callback)\n }\n \n@@ -295,7 +295,7 @@ pub fn get_trait_of_method(cstore: @cstore::CStore,\n                            def_id: ast::DefId,\n                            tcx: ty::ctxt)\n                            -> Option<ast::DefId> {\n-    let cdata = cstore.get_crate_data(def_id.crate);\n+    let cdata = cstore.get_crate_data(def_id.krate);\n     decoder::get_trait_of_method(cdata, def_id.node, tcx)\n }\n "}, {"sha": "cfc2bb502dc4eb61c51643ad92e59d40e0c299a1", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/89b1686bd7db25b5dd948b1a4d9dfd0c68084c29/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89b1686bd7db25b5dd948b1a4d9dfd0c68084c29/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=89b1686bd7db25b5dd948b1a4d9dfd0c68084c29", "patch": "@@ -191,7 +191,7 @@ fn item_parent_item(d: ebml::Doc) -> Option<ast::DefId> {\n fn item_reqd_and_translated_parent_item(cnum: ast::CrateNum,\n                                         d: ebml::Doc) -> ast::DefId {\n     let trait_did = item_parent_item(d).expect(\"item without parent\");\n-    ast::DefId { crate: cnum, node: trait_did.node }\n+    ast::DefId { krate: cnum, node: trait_did.node }\n }\n \n fn item_def_id(d: ebml::Doc, cdata: Cmd) -> ast::DefId {\n@@ -290,7 +290,7 @@ fn enum_variant_ids(item: ebml::Doc, cdata: Cmd) -> ~[ast::DefId] {\n     let v = tag_items_data_item_variant;\n     reader::tagged_docs(item, v, |p| {\n         let ext = reader::with_doc_data(p, parse_def_id);\n-        ids.push(ast::DefId { crate: cdata.cnum, node: ext.node });\n+        ids.push(ast::DefId { krate: cdata.cnum, node: ext.node });\n         true\n     });\n     return ids;\n@@ -386,7 +386,7 @@ pub fn item_to_def_like(item: ebml::Doc, did: ast::DefId, cnum: ast::CrateNum)\n pub fn lookup_def(cnum: ast::CrateNum, data: &[u8], did_: ast::DefId) ->\n    ast::Def {\n     let item = lookup_item(did_.node, data);\n-    let did = ast::DefId { crate: cnum, node: did_.node };\n+    let did = ast::DefId { krate: cnum, node: did_.node };\n     // We treat references to enums as references to types.\n     return def_like_to_def(item_to_def_like(item, did, cnum));\n }\n@@ -423,7 +423,7 @@ pub fn get_type(cdata: Cmd, id: ast::NodeId, tcx: ty::ctxt)\n \n     let item = lookup_item(id, cdata.data());\n \n-    let t = item_type(ast::DefId { crate: cdata.cnum, node: id }, item, tcx,\n+    let t = item_type(ast::DefId { krate: cdata.cnum, node: id }, item, tcx,\n                       cdata);\n \n     let tp_defs = item_ty_param_defs(item, tcx, cdata, tag_items_data_item_ty_param_bounds);\n@@ -529,10 +529,10 @@ fn each_child_of_item_or_crate(intr: @IdentInterner,\n \n         // This item may be in yet another crate if it was the child of a\n         // reexport.\n-        let other_crates_items = if child_def_id.crate == cdata.cnum {\n+        let other_crates_items = if child_def_id.krate == cdata.cnum {\n             reader::get_doc(reader::Doc(cdata.data()), tag_items)\n         } else {\n-            let crate_data = get_crate_data(child_def_id.crate);\n+            let crate_data = get_crate_data(child_def_id.krate);\n             reader::get_doc(reader::Doc(crate_data.data()), tag_items)\n         };\n \n@@ -617,10 +617,10 @@ fn each_child_of_item_or_crate(intr: @IdentInterner,\n         let name = name_doc.as_str_slice();\n \n         // This reexport may be in yet another crate.\n-        let other_crates_items = if child_def_id.crate == cdata.cnum {\n+        let other_crates_items = if child_def_id.krate == cdata.cnum {\n             reader::get_doc(reader::Doc(cdata.data()), tag_items)\n         } else {\n-            let crate_data = get_crate_data(child_def_id.crate);\n+            let crate_data = get_crate_data(child_def_id.krate);\n             reader::get_doc(reader::Doc(crate_data.data()), tag_items)\n         };\n \n@@ -730,7 +730,7 @@ pub fn get_enum_variants(intr: @IdentInterner, cdata: Cmd, id: ast::NodeId,\n     let mut disr_val = 0;\n     for did in variant_ids.iter() {\n         let item = find_item(did.node, items);\n-        let ctor_ty = item_type(ast::DefId { crate: cdata.cnum, node: id},\n+        let ctor_ty = item_type(ast::DefId { krate: cdata.cnum, node: id},\n                                 item, tcx, cdata);\n         let name = item_name(intr, item);\n         let arg_tys = match ty::get(ctor_ty).sty {\n@@ -799,7 +799,7 @@ pub fn get_impl(intr: @IdentInterner, cdata: Cmd, impl_id: ast::NodeId,\n     let impl_item = lookup_item(impl_id, data);\n     ty::Impl {\n         did: ast::DefId {\n-            crate: cdata.cnum,\n+            krate: cdata.cnum,\n             node: impl_id,\n         },\n         ident: item_name(intr, impl_item),\n@@ -1199,15 +1199,15 @@ pub fn list_crate_metadata(intr: @IdentInterner, bytes: &[u8],\n // then we must translate the crate number from that encoded in the external\n // crate to the correct local crate number.\n pub fn translate_def_id(cdata: Cmd, did: ast::DefId) -> ast::DefId {\n-    if did.crate == ast::LOCAL_CRATE {\n-        return ast::DefId { crate: cdata.cnum, node: did.node };\n+    if did.krate == ast::LOCAL_CRATE {\n+        return ast::DefId { krate: cdata.cnum, node: did.node };\n     }\n \n     let cnum_map = cdata.cnum_map.borrow();\n-    match cnum_map.get().find(&did.crate) {\n+    match cnum_map.get().find(&did.krate) {\n         Some(&n) => {\n             ast::DefId {\n-                crate: n,\n+                krate: n,\n                 node: did.node,\n             }\n         }"}, {"sha": "b5fef36607ff275c8235e9eb1bb6dcdee73b0f95", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/89b1686bd7db25b5dd948b1a4d9dfd0c68084c29/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89b1686bd7db25b5dd948b1a4d9dfd0c68084c29/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=89b1686bd7db25b5dd948b1a4d9dfd0c68084c29", "patch": "@@ -167,7 +167,7 @@ fn encode_family(ebml_w: &mut writer::Encoder, c: char) {\n }\n \n pub fn def_to_str(did: DefId) -> ~str {\n-    format!(\"{}:{}\", did.crate, did.node)\n+    format!(\"{}:{}\", did.krate, did.node)\n }\n \n fn encode_ty_type_param_defs(ebml_w: &mut writer::Encoder,\n@@ -344,7 +344,7 @@ fn encode_enum_variant_info(ecx: &EncodeContext,\n     let mut disr_val = 0;\n     let mut i = 0;\n     let vi = ty::enum_variants(ecx.tcx,\n-                               ast::DefId { crate: LOCAL_CRATE, node: id });\n+                               ast::DefId { krate: LOCAL_CRATE, node: id });\n     for variant in variants.iter() {\n         let def_id = local_def(variant.node.id);\n         {\n@@ -568,7 +568,7 @@ fn encode_reexports(ecx: &EncodeContext,\n                 debug!(\"(encoding info for module) reexport '{}' ({}/{}) for \\\n                         {}\",\n                        exp.name,\n-                       exp.def_id.crate,\n+                       exp.def_id.krate,\n                        exp.def_id.node,\n                        id);\n                 ebml_w.start_tag(tag_items_data_item_reexport);\n@@ -1210,7 +1210,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         // Now output the method info for each method.\n         let r = ty::trait_method_def_ids(tcx, def_id);\n         for (i, &method_def_id) in r.iter().enumerate() {\n-            assert_eq!(method_def_id.crate, ast::LOCAL_CRATE);\n+            assert_eq!(method_def_id.krate, ast::LOCAL_CRATE);\n \n             let method_ty = ty::method(tcx, method_def_id);\n \n@@ -1409,7 +1409,7 @@ impl<'a,'b> visit::Visitor<()> for EncodeVisitor<'a,'b> {\n \n fn encode_info_for_items(ecx: &EncodeContext,\n                          ebml_w: &mut writer::Encoder,\n-                         crate: &Crate)\n+                         krate: &Crate)\n                          -> ~[entry<i64>] {\n     let index = @RefCell::new(~[]);\n     ebml_w.start_tag(tag_items_data);\n@@ -1422,7 +1422,7 @@ fn encode_info_for_items(ecx: &EncodeContext,\n     }\n     encode_info_for_mod(ecx,\n                         ebml_w,\n-                        &crate.module,\n+                        &krate.module,\n                         CRATE_NODE_ID,\n                         [],\n                         syntax::parse::token::special_idents::invalid,\n@@ -1439,7 +1439,7 @@ fn encode_info_for_items(ecx: &EncodeContext,\n             ebml_w_for_visit_item: &mut *ebml_w,\n         };\n \n-        visit::walk_crate(&mut visitor, crate, ());\n+        visit::walk_crate(&mut visitor, krate, ());\n     }\n \n     ebml_w.end_tag();\n@@ -1559,7 +1559,7 @@ fn encode_attributes(ebml_w: &mut writer::Encoder, attrs: &[Attribute]) {\n // metadata that Rust cares about for linking crates. If the user didn't\n // provide it we will throw it in anyway with a default value.\n fn synthesize_crate_attrs(ecx: &EncodeContext,\n-                          crate: &Crate) -> ~[Attribute] {\n+                          krate: &Crate) -> ~[Attribute] {\n \n     fn synthesize_crateid_attr(ecx: &EncodeContext) -> Attribute {\n         assert!(!ecx.link_meta.crateid.name.is_empty());\n@@ -1571,7 +1571,7 @@ fn synthesize_crate_attrs(ecx: &EncodeContext,\n     }\n \n     let mut attrs = ~[];\n-    for attr in crate.attrs.iter() {\n+    for attr in krate.attrs.iter() {\n         if !attr.name().equiv(&(\"crate_id\")) {\n             attrs.push(*attr);\n         }\n@@ -1628,7 +1628,7 @@ fn encode_lang_items(ecx: &EncodeContext, ebml_w: &mut writer::Encoder) {\n \n     for (i, def_id) in ecx.tcx.lang_items.items() {\n         for id in def_id.iter() {\n-            if id.crate == LOCAL_CRATE {\n+            if id.krate == LOCAL_CRATE {\n                 ebml_w.start_tag(tag_lang_items_item);\n \n                 ebml_w.start_tag(tag_lang_items_item_id);\n@@ -1714,15 +1714,15 @@ impl<'a, 'b> Visitor<()> for MacroDefVisitor<'a, 'b> {\n }\n \n fn encode_macro_defs(ecx: &EncodeContext,\n-                     crate: &Crate,\n+                     krate: &Crate,\n                      ebml_w: &mut writer::Encoder) {\n     ebml_w.start_tag(tag_exported_macros);\n     {\n         let mut visitor = MacroDefVisitor {\n             ecx: ecx,\n             ebml_w: ebml_w,\n         };\n-        visit::walk_crate(&mut visitor, crate, ());\n+        visit::walk_crate(&mut visitor, krate, ());\n     }\n     ebml_w.end_tag();\n }\n@@ -1744,7 +1744,7 @@ impl<'a,'b> Visitor<()> for ImplVisitor<'a,'b> {\n                 // Load eagerly if this is an implementation of the Drop trait\n                 // or if the trait is not defined in this crate.\n                 if Some(def_id) == self.ecx.tcx.lang_items.drop_trait() ||\n-                        def_id.crate != LOCAL_CRATE {\n+                        def_id.krate != LOCAL_CRATE {\n                     self.ebml_w.start_tag(tag_impls_impl);\n                     encode_def_id(self.ebml_w, local_def(item.id));\n                     self.ebml_w.end_tag();\n@@ -1767,7 +1767,7 @@ impl<'a,'b> Visitor<()> for ImplVisitor<'a,'b> {\n ///\n /// * Implementations of traits not defined in this crate.\n fn encode_impls(ecx: &EncodeContext,\n-                crate: &Crate,\n+                krate: &Crate,\n                 ebml_w: &mut writer::Encoder) {\n     ebml_w.start_tag(tag_impls);\n \n@@ -1776,18 +1776,18 @@ fn encode_impls(ecx: &EncodeContext,\n             ecx: ecx,\n             ebml_w: ebml_w,\n         };\n-        visit::walk_crate(&mut visitor, crate, ());\n+        visit::walk_crate(&mut visitor, krate, ());\n     }\n \n     ebml_w.end_tag();\n }\n \n fn encode_misc_info(ecx: &EncodeContext,\n-                    crate: &Crate,\n+                    krate: &Crate,\n                     ebml_w: &mut writer::Encoder) {\n     ebml_w.start_tag(tag_misc_info);\n     ebml_w.start_tag(tag_misc_info_crate_items);\n-    for &item in crate.module.items.iter() {\n+    for &item in krate.module.items.iter() {\n         ebml_w.start_tag(tag_mod_child);\n         ebml_w.wr_str(def_to_str(local_def(item.id)));\n         ebml_w.end_tag();\n@@ -1838,13 +1838,13 @@ pub static metadata_encoding_version : &'static [u8] =\n       0x74, //'t' as u8,\n       0, 0, 0, 1 ];\n \n-pub fn encode_metadata(parms: EncodeParams, crate: &Crate) -> ~[u8] {\n+pub fn encode_metadata(parms: EncodeParams, krate: &Crate) -> ~[u8] {\n     let mut wr = MemWriter::new();\n-    encode_metadata_inner(&mut wr, parms, crate);\n+    encode_metadata_inner(&mut wr, parms, krate);\n     wr.unwrap()\n }\n \n-fn encode_metadata_inner(wr: &mut MemWriter, parms: EncodeParams, crate: &Crate) {\n+fn encode_metadata_inner(wr: &mut MemWriter, parms: EncodeParams, krate: &Crate) {\n     let stats = Stats {\n         inline_bytes: Cell::new(0),\n         attr_bytes: Cell::new(0),\n@@ -1895,7 +1895,7 @@ fn encode_metadata_inner(wr: &mut MemWriter, parms: EncodeParams, crate: &Crate)\n     encode_hash(&mut ebml_w, ecx.link_meta.crate_hash);\n \n     let mut i = ebml_w.writer.tell().unwrap();\n-    let crate_attrs = synthesize_crate_attrs(&ecx, crate);\n+    let crate_attrs = synthesize_crate_attrs(&ecx, krate);\n     encode_attributes(&mut ebml_w, crate_attrs);\n     ecx.stats.attr_bytes.set(ebml_w.writer.tell().unwrap() - i);\n \n@@ -1920,23 +1920,23 @@ fn encode_metadata_inner(wr: &mut MemWriter, parms: EncodeParams, crate: &Crate)\n \n     // Encode macro definitions\n     i = ebml_w.writer.tell().unwrap();\n-    encode_macro_defs(&ecx, crate, &mut ebml_w);\n+    encode_macro_defs(&ecx, krate, &mut ebml_w);\n     ecx.stats.macro_defs_bytes.set(ebml_w.writer.tell().unwrap() - i);\n \n     // Encode the def IDs of impls, for coherence checking.\n     i = ebml_w.writer.tell().unwrap();\n-    encode_impls(&ecx, crate, &mut ebml_w);\n+    encode_impls(&ecx, krate, &mut ebml_w);\n     ecx.stats.impl_bytes.set(ebml_w.writer.tell().unwrap() - i);\n \n     // Encode miscellaneous info.\n     i = ebml_w.writer.tell().unwrap();\n-    encode_misc_info(&ecx, crate, &mut ebml_w);\n+    encode_misc_info(&ecx, krate, &mut ebml_w);\n     ecx.stats.misc_bytes.set(ebml_w.writer.tell().unwrap() - i);\n \n     // Encode and index the items.\n     ebml_w.start_tag(tag_items);\n     i = ebml_w.writer.tell().unwrap();\n-    let items_index = encode_info_for_items(&ecx, &mut ebml_w, crate);\n+    let items_index = encode_info_for_items(&ecx, &mut ebml_w, krate);\n     ecx.stats.item_bytes.set(ebml_w.writer.tell().unwrap() - i);\n \n     i = ebml_w.writer.tell().unwrap();"}, {"sha": "5c3fb8bebb0b16360411f45215e4f64e9a5c78b3", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/89b1686bd7db25b5dd948b1a4d9dfd0c68084c29/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89b1686bd7db25b5dd948b1a4d9dfd0c68084c29/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=89b1686bd7db25b5dd948b1a4d9dfd0c68084c29", "patch": "@@ -57,7 +57,7 @@ type conv_did<'a> =\n \n pub struct PState<'a> {\n     data: &'a [u8],\n-    crate: ast::CrateNum,\n+    krate: ast::CrateNum,\n     pos: uint,\n     tcx: ty::ctxt\n }\n@@ -106,7 +106,7 @@ pub fn parse_state_from_data<'a>(data: &'a [u8], crate_num: ast::CrateNum,\n                              pos: uint, tcx: ty::ctxt) -> PState<'a> {\n     PState {\n         data: data,\n-        crate: crate_num,\n+        krate: crate_num,\n         pos: pos,\n         tcx: tcx\n     }\n@@ -377,7 +377,7 @@ fn parse_ty(st: &mut PState, conv: conv_did) -> ty::t {\n         assert_eq!(next(st), ':');\n         let len = parse_hex(st);\n         assert_eq!(next(st), '#');\n-        let key = ty::creader_cache_key {cnum: st.crate,\n+        let key = ty::creader_cache_key {cnum: st.krate,\n                                          pos: pos,\n                                          len: len };\n \n@@ -559,7 +559,7 @@ pub fn parse_def_id(buf: &[u8]) -> ast::DefId {\n        None => fail!(\"internal error: parse_def_id: id expected, but found {:?}\",\n                      def_part)\n     };\n-    ast::DefId { crate: crate_num, node: def_num }\n+    ast::DefId { krate: crate_num, node: def_num }\n }\n \n pub fn parse_type_param_def_data(data: &[u8], start: uint,"}, {"sha": "6bbac6cc4ca97dd55124ec02e7e81af2d0ec2012", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/89b1686bd7db25b5dd948b1a4d9dfd0c68084c29/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89b1686bd7db25b5dd948b1a4d9dfd0c68084c29/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=89b1686bd7db25b5dd948b1a4d9dfd0c68084c29", "patch": "@@ -236,8 +236,8 @@ impl ExtendedDecodeContext {\n          * refer to the current crate and to the new, inlined node-id.\n          */\n \n-        assert_eq!(did.crate, ast::LOCAL_CRATE);\n-        ast::DefId { crate: ast::LOCAL_CRATE, node: self.tr_id(did.node) }\n+        assert_eq!(did.krate, ast::LOCAL_CRATE);\n+        ast::DefId { krate: ast::LOCAL_CRATE, node: self.tr_id(did.node) }\n     }\n     pub fn tr_span(&self, _span: Span) -> Span {\n         codemap::DUMMY_SP // FIXME (#1972): handle span properly\n@@ -989,7 +989,7 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n         }\n     }\n \n-    let lid = ast::DefId { crate: ast::LOCAL_CRATE, node: id };\n+    let lid = ast::DefId { krate: ast::LOCAL_CRATE, node: id };\n     {\n         let tcache = tcx.tcache.borrow();\n         let r = tcache.get().find(&lid);\n@@ -1350,7 +1350,7 @@ fn decode_side_tables(xcx: @ExtendedDecodeContext,\n                     }\n                     c::tag_table_tcache => {\n                         let tpbt = val_dsr.read_ty_param_bounds_and_ty(xcx);\n-                        let lid = ast::DefId { crate: ast::LOCAL_CRATE, node: id };\n+                        let lid = ast::DefId { krate: ast::LOCAL_CRATE, node: id };\n                         let mut tcache = dcx.tcx.tcache.borrow_mut();\n                         tcache.get().insert(lid, tpbt);\n                     }"}, {"sha": "99b0fa1b1f5d568fdfbcdb022eeac4fc924ae0de", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/89b1686bd7db25b5dd948b1a4d9dfd0c68084c29/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89b1686bd7db25b5dd948b1a4d9dfd0c68084c29/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=89b1686bd7db25b5dd948b1a4d9dfd0c68084c29", "patch": "@@ -73,7 +73,7 @@ pub fn check_crate(tcx: ty::ctxt,\n                    moves_map: moves::MovesMap,\n                    moved_variables_set: moves::MovedVariablesSet,\n                    capture_map: moves::CaptureMap,\n-                   crate: &ast::Crate)\n+                   krate: &ast::Crate)\n                    -> root_map {\n     let mut bccx = BorrowckCtxt {\n         tcx: tcx,\n@@ -91,7 +91,7 @@ pub fn check_crate(tcx: ty::ctxt,\n     };\n     let bccx = &mut bccx;\n \n-    visit::walk_crate(bccx, crate, ());\n+    visit::walk_crate(bccx, krate, ());\n \n     if tcx.sess.borrowck_stats() {\n         println!(\"--- borrowck stats ---\");"}, {"sha": "385224c2073bdfd1066007ea0f2f70ae4f5eef31", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/89b1686bd7db25b5dd948b1a4d9dfd0c68084c29/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89b1686bd7db25b5dd948b1a4d9dfd0c68084c29/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=89b1686bd7db25b5dd948b1a4d9dfd0c68084c29", "patch": "@@ -42,7 +42,7 @@ impl Visitor<bool> for CheckCrateVisitor {\n }\n \n pub fn check_crate(sess: Session,\n-                   crate: &Crate,\n+                   krate: &Crate,\n                    ast_map: ast_map::Map,\n                    def_map: resolve::DefMap,\n                    method_map: typeck::method_map,\n@@ -54,7 +54,7 @@ pub fn check_crate(sess: Session,\n         method_map: method_map,\n         tcx: tcx,\n     };\n-    visit::walk_crate(&mut v, crate, false);\n+    visit::walk_crate(&mut v, krate, false);\n     sess.abort_if_errors();\n }\n "}, {"sha": "2c3d4a3e22f6ac76994019101871eaf1f06ef3bb", "filename": "src/librustc/middle/check_loop.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/89b1686bd7db25b5dd948b1a4d9dfd0c68084c29/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89b1686bd7db25b5dd948b1a4d9dfd0c68084c29/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs?ref=89b1686bd7db25b5dd948b1a4d9dfd0c68084c29", "patch": "@@ -24,8 +24,8 @@ struct CheckLoopVisitor {\n     tcx: ty::ctxt,\n }\n \n-pub fn check_crate(tcx: ty::ctxt, crate: &ast::Crate) {\n-    visit::walk_crate(&mut CheckLoopVisitor { tcx: tcx }, crate, Normal)\n+pub fn check_crate(tcx: ty::ctxt, krate: &ast::Crate) {\n+    visit::walk_crate(&mut CheckLoopVisitor { tcx: tcx }, krate, Normal)\n }\n \n impl Visitor<Context> for CheckLoopVisitor {"}, {"sha": "a1e1b1b254974842392aeffdefde3c1a5f28d86d", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/89b1686bd7db25b5dd948b1a4d9dfd0c68084c29/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89b1686bd7db25b5dd948b1a4d9dfd0c68084c29/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=89b1686bd7db25b5dd948b1a4d9dfd0c68084c29", "patch": "@@ -52,13 +52,13 @@ impl Visitor<()> for CheckMatchVisitor {\n pub fn check_crate(tcx: ty::ctxt,\n                    method_map: method_map,\n                    moves_map: moves::MovesMap,\n-                   crate: &Crate) {\n+                   krate: &Crate) {\n     let cx = @MatchCheckCtxt {tcx: tcx,\n                               method_map: method_map,\n                               moves_map: moves_map};\n     let mut v = CheckMatchVisitor { cx: cx };\n \n-    visit::walk_crate(&mut v, crate, ());\n+    visit::walk_crate(&mut v, krate, ());\n \n     tcx.sess.abort_if_errors();\n }"}, {"sha": "52ea5f0a89f1d16a866bb6cff7f87d0bf7d37662", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/89b1686bd7db25b5dd948b1a4d9dfd0c68084c29/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89b1686bd7db25b5dd948b1a4d9dfd0c68084c29/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=89b1686bd7db25b5dd948b1a4d9dfd0c68084c29", "patch": "@@ -302,13 +302,13 @@ impl Visitor<()> for ConstEvalVisitor {\n     }\n }\n \n-pub fn process_crate(crate: &ast::Crate,\n+pub fn process_crate(krate: &ast::Crate,\n                      tcx: ty::ctxt) {\n     let mut v = ConstEvalVisitor {\n         tcx: tcx,\n         ccache: HashMap::new(),\n     };\n-    visit::walk_crate(&mut v, crate, ());\n+    visit::walk_crate(&mut v, krate, ());\n     tcx.sess.abort_if_errors();\n }\n "}, {"sha": "b11f385bdfd829dad70f014eccab7c113551e77b", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/89b1686bd7db25b5dd948b1a4d9dfd0c68084c29/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89b1686bd7db25b5dd948b1a4d9dfd0c68084c29/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=89b1686bd7db25b5dd948b1a4d9dfd0c68084c29", "patch": "@@ -254,7 +254,7 @@ impl Visitor<()> for LifeSeeder {\n fn create_and_seed_worklist(tcx: ty::ctxt,\n                             exported_items: &privacy::ExportedItems,\n                             reachable_symbols: &HashSet<ast::NodeId>,\n-                            crate: &ast::Crate) -> ~[ast::NodeId] {\n+                            krate: &ast::Crate) -> ~[ast::NodeId] {\n     let mut worklist = ~[];\n \n     // Preferably, we would only need to seed the worklist with reachable\n@@ -279,7 +279,7 @@ fn create_and_seed_worklist(tcx: ty::ctxt,\n     let mut life_seeder = LifeSeeder {\n         worklist: worklist\n     };\n-    visit::walk_crate(&mut life_seeder, crate, ());\n+    visit::walk_crate(&mut life_seeder, krate, ());\n \n     return life_seeder.worklist;\n }\n@@ -288,10 +288,10 @@ fn find_live(tcx: ty::ctxt,\n              method_map: typeck::method_map,\n              exported_items: &privacy::ExportedItems,\n              reachable_symbols: &HashSet<ast::NodeId>,\n-             crate: &ast::Crate)\n+             krate: &ast::Crate)\n              -> ~HashSet<ast::NodeId> {\n     let worklist = create_and_seed_worklist(tcx, exported_items,\n-                                            reachable_symbols, crate);\n+                                            reachable_symbols, krate);\n     let mut symbol_visitor = MarkSymbolVisitor::new(tcx, method_map, worklist);\n     symbol_visitor.mark_live_symbols();\n     symbol_visitor.live_symbols\n@@ -412,9 +412,9 @@ pub fn check_crate(tcx: ty::ctxt,\n                    method_map: typeck::method_map,\n                    exported_items: &privacy::ExportedItems,\n                    reachable_symbols: &HashSet<ast::NodeId>,\n-                   crate: &ast::Crate) {\n+                   krate: &ast::Crate) {\n     let live_symbols = find_live(tcx, method_map, exported_items,\n-                                 reachable_symbols, crate);\n+                                 reachable_symbols, krate);\n     let mut visitor = DeadVisitor { tcx: tcx, live_symbols: live_symbols };\n-    visit::walk_crate(&mut visitor, crate, ());\n+    visit::walk_crate(&mut visitor, krate, ());\n }"}, {"sha": "1445d5734ad1945555fc7056a471a5bc817b0d67", "filename": "src/librustc/middle/effect.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/89b1686bd7db25b5dd948b1a4d9dfd0c68084c29/src%2Flibrustc%2Fmiddle%2Feffect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89b1686bd7db25b5dd948b1a4d9dfd0c68084c29/src%2Flibrustc%2Fmiddle%2Feffect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Feffect.rs?ref=89b1686bd7db25b5dd948b1a4d9dfd0c68084c29", "patch": "@@ -175,12 +175,12 @@ impl Visitor<()> for EffectCheckVisitor {\n \n pub fn check_crate(tcx: ty::ctxt,\n                    method_map: method_map,\n-                   crate: &ast::Crate) {\n+                   krate: &ast::Crate) {\n     let mut visitor = EffectCheckVisitor {\n         tcx: tcx,\n         method_map: method_map,\n         unsafe_context: SafeContext,\n     };\n \n-    visit::walk_crate(&mut visitor, crate, ());\n+    visit::walk_crate(&mut visitor, krate, ());\n }"}, {"sha": "a8f746429ba93570d7344f555bdb61719223cdcc", "filename": "src/librustc/middle/entry.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/89b1686bd7db25b5dd948b1a4d9dfd0c68084c29/src%2Flibrustc%2Fmiddle%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89b1686bd7db25b5dd948b1a4d9dfd0c68084c29/src%2Flibrustc%2Fmiddle%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fentry.rs?ref=89b1686bd7db25b5dd948b1a4d9dfd0c68084c29", "patch": "@@ -44,14 +44,14 @@ impl Visitor<()> for EntryContext {\n     }\n }\n \n-pub fn find_entry_point(session: Session, crate: &Crate, ast_map: ast_map::Map) {\n+pub fn find_entry_point(session: Session, krate: &Crate, ast_map: ast_map::Map) {\n     if session.building_library.get() {\n         // No need to find a main function\n         return;\n     }\n \n     // If the user wants no main function at all, then stop here.\n-    if attr::contains_name(crate.attrs, \"no_main\") {\n+    if attr::contains_name(krate.attrs, \"no_main\") {\n         session.entry_type.set(Some(session::EntryNone));\n         return\n     }\n@@ -65,7 +65,7 @@ pub fn find_entry_point(session: Session, crate: &Crate, ast_map: ast_map::Map)\n         non_main_fns: ~[],\n     };\n \n-    visit::walk_crate(&mut ctxt, crate, ());\n+    visit::walk_crate(&mut ctxt, krate, ());\n \n     configure_main(&mut ctxt);\n }"}, {"sha": "4dea61ab5de03fed3d78b4953f67fbba0136d0ca", "filename": "src/librustc/middle/freevars.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/89b1686bd7db25b5dd948b1a4d9dfd0c68084c29/src%2Flibrustc%2Fmiddle%2Ffreevars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89b1686bd7db25b5dd948b1a4d9dfd0c68084c29/src%2Flibrustc%2Fmiddle%2Ffreevars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ffreevars.rs?ref=89b1686bd7db25b5dd948b1a4d9dfd0c68084c29", "patch": "@@ -124,13 +124,13 @@ impl Visitor<()> for AnnotateFreevarsVisitor {\n // efficient as it fully recomputes the free variables at every\n // node of interest rather than building up the free variables in\n // one pass. This could be improved upon if it turns out to matter.\n-pub fn annotate_freevars(def_map: resolve::DefMap, crate: &ast::Crate) ->\n+pub fn annotate_freevars(def_map: resolve::DefMap, krate: &ast::Crate) ->\n    freevar_map {\n     let mut visitor = AnnotateFreevarsVisitor {\n         def_map: def_map,\n         freevars: HashMap::new(),\n     };\n-    visit::walk_crate(&mut visitor, crate, ());\n+    visit::walk_crate(&mut visitor, krate, ());\n \n     let AnnotateFreevarsVisitor {\n         freevars,"}, {"sha": "3700833bfb5d63bd7e2c2b6c65848edffcc7d85d", "filename": "src/librustc/middle/kind.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/89b1686bd7db25b5dd948b1a4d9dfd0c68084c29/src%2Flibrustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89b1686bd7db25b5dd948b1a4d9dfd0c68084c29/src%2Flibrustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fkind.rs?ref=89b1686bd7db25b5dd948b1a4d9dfd0c68084c29", "patch": "@@ -77,12 +77,12 @@ impl Visitor<()> for Context {\n \n pub fn check_crate(tcx: ty::ctxt,\n                    method_map: typeck::method_map,\n-                   crate: &Crate) {\n+                   krate: &Crate) {\n     let mut ctx = Context {\n         tcx: tcx,\n         method_map: method_map,\n     };\n-    visit::walk_crate(&mut ctx, crate, ());\n+    visit::walk_crate(&mut ctx, krate, ());\n     tcx.sess.abort_if_errors();\n }\n "}, {"sha": "290e901d1a3f8a78b265f0b7fe4500024da78485", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/89b1686bd7db25b5dd948b1a4d9dfd0c68084c29/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89b1686bd7db25b5dd948b1a4d9dfd0c68084c29/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=89b1686bd7db25b5dd948b1a4d9dfd0c68084c29", "patch": "@@ -161,24 +161,24 @@ impl LanguageItemCollector {\n         self.items.items[item_index] = Some(item_def_id);\n     }\n \n-    pub fn collect_local_language_items(&mut self, crate: &ast::Crate) {\n+    pub fn collect_local_language_items(&mut self, krate: &ast::Crate) {\n         let mut v = LanguageItemVisitor { this: self };\n-        visit::walk_crate(&mut v, crate, ());\n+        visit::walk_crate(&mut v, krate, ());\n     }\n \n     pub fn collect_external_language_items(&mut self) {\n         let crate_store = self.session.cstore;\n         crate_store.iter_crate_data(|crate_number, _crate_metadata| {\n             each_lang_item(crate_store, crate_number, |node_id, item_index| {\n-                let def_id = ast::DefId { crate: crate_number, node: node_id };\n+                let def_id = ast::DefId { krate: crate_number, node: node_id };\n                 self.collect_item(item_index, def_id);\n                 true\n             });\n         })\n     }\n \n-    pub fn collect(&mut self, crate: &ast::Crate) {\n-        self.collect_local_language_items(crate);\n+    pub fn collect(&mut self, krate: &ast::Crate) {\n+        self.collect_local_language_items(krate);\n         self.collect_external_language_items();\n     }\n }\n@@ -196,10 +196,10 @@ pub fn extract(attrs: &[ast::Attribute]) -> Option<InternedString> {\n     return None;\n }\n \n-pub fn collect_language_items(crate: &ast::Crate,\n+pub fn collect_language_items(krate: &ast::Crate,\n                               session: Session) -> @LanguageItems {\n     let mut collector = LanguageItemCollector::new(session);\n-    collector.collect(crate);\n+    collector.collect(krate);\n     let LanguageItemCollector { items, .. } = collector;\n     session.abort_if_errors();\n     @items"}, {"sha": "c2bdef021fe0383f5fe8cf46e335052b0a5d803e", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/89b1686bd7db25b5dd948b1a4d9dfd0c68084c29/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89b1686bd7db25b5dd948b1a4d9dfd0c68084c29/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=89b1686bd7db25b5dd948b1a4d9dfd0c68084c29", "patch": "@@ -1341,7 +1341,7 @@ fn check_missing_doc_item(cx: &Context, it: &ast::Item) {\n \n fn check_missing_doc_method(cx: &Context, m: &ast::Method) {\n     let did = ast::DefId {\n-        crate: ast::LOCAL_CRATE,\n+        krate: ast::LOCAL_CRATE,\n         node: m.id\n     };\n \n@@ -1643,7 +1643,7 @@ impl<'a> IdVisitingOperation for Context<'a> {\n pub fn check_crate(tcx: ty::ctxt,\n                    method_map: typeck::method_map,\n                    exported_items: &privacy::ExportedItems,\n-                   crate: &ast::Crate) {\n+                   krate: &ast::Crate) {\n     let mut cx = Context {\n         dict: @get_lint_dict(),\n         cur: SmallIntMap::new(),\n@@ -1664,19 +1664,19 @@ pub fn check_crate(tcx: ty::ctxt,\n     for &(lint, level) in tcx.sess.opts.lint_opts.iter() {\n         cx.set_level(lint, level, CommandLine);\n     }\n-    cx.with_lint_attrs(crate.attrs, |cx| {\n+    cx.with_lint_attrs(krate.attrs, |cx| {\n         cx.visit_id(ast::CRATE_NODE_ID);\n         cx.visit_ids(|v| {\n             v.visited_outermost = true;\n-            visit::walk_crate(v, crate, ());\n+            visit::walk_crate(v, krate, ());\n         });\n \n-        check_crate_attrs_usage(cx, crate.attrs);\n+        check_crate_attrs_usage(cx, krate.attrs);\n         // since the root module isn't visited as an item (because it isn't an item), warn for it\n         // here.\n-        check_missing_doc_attrs(cx, None, crate.attrs, crate.span, \"crate\");\n+        check_missing_doc_attrs(cx, None, krate.attrs, krate.span, \"crate\");\n \n-        visit::walk_crate(cx, crate, ());\n+        visit::walk_crate(cx, krate, ());\n     });\n \n     // If we missed any lints added to the session, then there's a bug somewhere"}, {"sha": "e06866e77dd5f04b41c16792fc39e2b40dd5a53a", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/89b1686bd7db25b5dd948b1a4d9dfd0c68084c29/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89b1686bd7db25b5dd948b1a4d9dfd0c68084c29/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=89b1686bd7db25b5dd948b1a4d9dfd0c68084c29", "patch": "@@ -176,11 +176,11 @@ impl Visitor<@IrMaps> for LivenessVisitor {\n pub fn check_crate(tcx: ty::ctxt,\n                    method_map: typeck::method_map,\n                    capture_map: moves::CaptureMap,\n-                   crate: &Crate) {\n+                   krate: &Crate) {\n     let mut visitor = LivenessVisitor;\n \n     let initial_maps = @IrMaps(tcx, method_map, capture_map);\n-    visit::walk_crate(&mut visitor, crate, initial_maps);\n+    visit::walk_crate(&mut visitor, krate, initial_maps);\n     tcx.sess.abort_if_errors();\n }\n "}, {"sha": "a0dc86347929fa1b6a244ef99d76eb59af863c02", "filename": "src/librustc/middle/moves.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/89b1686bd7db25b5dd948b1a4d9dfd0c68084c29/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89b1686bd7db25b5dd948b1a4d9dfd0c68084c29/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmoves.rs?ref=89b1686bd7db25b5dd948b1a4d9dfd0c68084c29", "patch": "@@ -209,7 +209,7 @@ impl visit::Visitor<()> for VisitContext {\n \n pub fn compute_moves(tcx: ty::ctxt,\n                      method_map: method_map,\n-                     crate: &Crate) -> MoveMaps\n+                     krate: &Crate) -> MoveMaps\n {\n     let mut visit_cx = VisitContext {\n         tcx: tcx,\n@@ -221,7 +221,7 @@ pub fn compute_moves(tcx: ty::ctxt,\n         }\n     };\n     let visit_cx = &mut visit_cx;\n-    visit::walk_crate(visit_cx, crate, ());\n+    visit::walk_crate(visit_cx, krate, ());\n     return visit_cx.move_maps;\n }\n "}, {"sha": "d855ad97029ec8ce1a70743e6a94f13a9079454a", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/89b1686bd7db25b5dd948b1a4d9dfd0c68084c29/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89b1686bd7db25b5dd948b1a4d9dfd0c68084c29/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=89b1686bd7db25b5dd948b1a4d9dfd0c68084c29", "patch": "@@ -1091,13 +1091,13 @@ pub fn check_crate(tcx: ty::ctxt,\n                    exp_map2: &resolve::ExportMap2,\n                    external_exports: resolve::ExternalExports,\n                    last_private_map: resolve::LastPrivateMap,\n-                   crate: &ast::Crate) -> (ExportedItems, PublicItems) {\n+                   krate: &ast::Crate) -> (ExportedItems, PublicItems) {\n     // Figure out who everyone's parent is\n     let mut visitor = ParentVisitor {\n         parents: HashMap::new(),\n         curparent: ast::DUMMY_NODE_ID,\n     };\n-    visit::walk_crate(&mut visitor, crate, ());\n+    visit::walk_crate(&mut visitor, krate, ());\n \n     // Use the parent map to check the privacy of everything\n     let mut visitor = PrivacyVisitor {\n@@ -1110,15 +1110,15 @@ pub fn check_crate(tcx: ty::ctxt,\n         external_exports: external_exports,\n         last_private_map: last_private_map,\n     };\n-    visit::walk_crate(&mut visitor, crate, ());\n+    visit::walk_crate(&mut visitor, krate, ());\n \n     // Sanity check to make sure that all privacy usage and controls are\n     // reasonable.\n     let mut visitor = SanePrivacyVisitor {\n         in_fn: false,\n         tcx: tcx,\n     };\n-    visit::walk_crate(&mut visitor, crate, ());\n+    visit::walk_crate(&mut visitor, krate, ());\n \n     tcx.sess.abort_if_errors();\n \n@@ -1135,7 +1135,7 @@ pub fn check_crate(tcx: ty::ctxt,\n     };\n     loop {\n         let before = visitor.exported_items.len();\n-        visit::walk_crate(&mut visitor, crate, ());\n+        visit::walk_crate(&mut visitor, krate, ());\n         if before == visitor.exported_items.len() {\n             break\n         }"}, {"sha": "cd295eb016d82f8c7bd393711df45c6069a1a4fc", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/89b1686bd7db25b5dd948b1a4d9dfd0c68084c29/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89b1686bd7db25b5dd948b1a4d9dfd0c68084c29/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=89b1686bd7db25b5dd948b1a4d9dfd0c68084c29", "patch": "@@ -207,7 +207,7 @@ impl ReachableContext {\n     // eligible for inlining and false otherwise.\n     fn def_id_represents_local_inlined_item(tcx: ty::ctxt, def_id: ast::DefId)\n                                             -> bool {\n-        if def_id.crate != ast::LOCAL_CRATE {\n+        if def_id.krate != ast::LOCAL_CRATE {\n             return false\n         }\n \n@@ -232,7 +232,7 @@ impl ReachableContext {\n                 } else {\n                     // Check the impl. If the generics on the self type of the\n                     // impl require inlining, this method does too.\n-                    assert!(impl_did.crate == ast::LOCAL_CRATE);\n+                    assert!(impl_did.krate == ast::LOCAL_CRATE);\n                     match tcx.items.find(impl_did.node) {\n                         Some(ast_map::NodeItem(item, _)) => {\n                             match item.node {\n@@ -410,7 +410,7 @@ impl ReachableContext {\n     fn mark_destructors_reachable(&self) {\n         let destructor_for_type = self.tcx.destructor_for_type.borrow();\n         for (_, destructor_def_id) in destructor_for_type.get().iter() {\n-            if destructor_def_id.crate == ast::LOCAL_CRATE {\n+            if destructor_def_id.krate == ast::LOCAL_CRATE {\n                 let mut reachable_symbols = self.reachable_symbols\n                                                 .borrow_mut();\n                 reachable_symbols.get().insert(destructor_def_id.node);"}, {"sha": "9b1473cbd8ed4a6e98d171364afc615138652e32", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/89b1686bd7db25b5dd948b1a4d9dfd0c68084c29/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89b1686bd7db25b5dd948b1a4d9dfd0c68084c29/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=89b1686bd7db25b5dd948b1a4d9dfd0c68084c29", "patch": "@@ -908,7 +908,7 @@ impl<'a> Visitor<Context> for RegionResolutionVisitor<'a> {\n     }\n }\n \n-pub fn resolve_crate(sess: Session, crate: &ast::Crate) -> RegionMaps {\n+pub fn resolve_crate(sess: Session, krate: &ast::Crate) -> RegionMaps {\n     let maps = RegionMaps {\n         scope_map: RefCell::new(HashMap::new()),\n         var_map: RefCell::new(HashMap::new()),\n@@ -922,7 +922,7 @@ pub fn resolve_crate(sess: Session, crate: &ast::Crate) -> RegionMaps {\n             region_maps: &maps\n         };\n         let cx = Context { parent: None, var_parent: None };\n-        visit::walk_crate(&mut visitor, crate, cx);\n+        visit::walk_crate(&mut visitor, krate, cx);\n     }\n     return maps;\n }"}, {"sha": "62496f6c7a6a7f9c5afa169e65e2481fff840d97", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/89b1686bd7db25b5dd948b1a4d9dfd0c68084c29/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89b1686bd7db25b5dd948b1a4d9dfd0c68084c29/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=89b1686bd7db25b5dd948b1a4d9dfd0c68084c29", "patch": "@@ -769,7 +769,7 @@ fn Resolver(session: Session,\n     let graph_root = @NameBindings();\n \n     graph_root.define_module(NoParentLink,\n-                             Some(DefId { crate: 0, node: 0 }),\n+                             Some(DefId { krate: 0, node: 0 }),\n                              NormalModuleKind,\n                              false,\n                              true,\n@@ -918,8 +918,8 @@ impl<'a> Visitor<()> for UnusedImportCheckVisitor<'a> {\n \n impl Resolver {\n     /// The main name resolution procedure.\n-    fn resolve(&mut self, crate: &ast::Crate) {\n-        self.build_reduced_graph(crate);\n+    fn resolve(&mut self, krate: &ast::Crate) {\n+        self.build_reduced_graph(krate);\n         self.session.abort_if_errors();\n \n         self.resolve_imports();\n@@ -928,10 +928,10 @@ impl Resolver {\n         self.record_exports();\n         self.session.abort_if_errors();\n \n-        self.resolve_crate(crate);\n+        self.resolve_crate(krate);\n         self.session.abort_if_errors();\n \n-        self.check_for_unused_imports(crate);\n+        self.check_for_unused_imports(krate);\n     }\n \n     //\n@@ -942,12 +942,12 @@ impl Resolver {\n     //\n \n     /// Constructs the reduced graph for the entire crate.\n-    fn build_reduced_graph(&mut self, crate: &ast::Crate) {\n+    fn build_reduced_graph(&mut self, krate: &ast::Crate) {\n         let initial_parent =\n             ModuleReducedGraphParent(self.graph_root.get_module());\n \n         let mut visitor = BuildReducedGraphVisitor { resolver: self, };\n-        visit::walk_crate(&mut visitor, crate, initial_parent);\n+        visit::walk_crate(&mut visitor, krate, initial_parent);\n     }\n \n     /// Returns the current module tracked by the reduced graph parent.\n@@ -1138,7 +1138,7 @@ impl Resolver {\n                     self.add_child(ident, parent, ForbidDuplicateModules, sp);\n \n                 let parent_link = self.get_parent_link(new_parent, ident);\n-                let def_id = DefId { crate: 0, node: item.id };\n+                let def_id = DefId { krate: 0, node: item.id };\n                 name_bindings.define_module(parent_link,\n                                             Some(def_id),\n                                             NormalModuleKind,\n@@ -1500,7 +1500,7 @@ impl Resolver {\n                 // n.b. we don't need to look at the path option here, because cstore already did\n                 match self.session.cstore.find_extern_mod_stmt_cnum(node_id) {\n                     Some(crate_id) => {\n-                        let def_id = DefId { crate: crate_id, node: 0 };\n+                        let def_id = DefId { krate: crate_id, node: 0 };\n                         self.external_exports.insert(def_id);\n                         let parent_link = ModuleParentLink\n                             (self.get_module_from_parent(parent), name);\n@@ -1921,7 +1921,7 @@ impl Resolver {\n                                               root.def_id\n                                                   .get()\n                                                   .unwrap()\n-                                                  .crate,\n+                                                  .krate,\n                                               |def_like, ident, visibility| {\n             self.build_reduced_graph_for_external_crate_def(root,\n                                                             def_like,\n@@ -3298,11 +3298,11 @@ impl Resolver {\n \n     fn record_exports_for_module_subtree(&mut self,\n                                              module_: @Module) {\n-        // If this isn't a local crate, then bail out. We don't need to record\n+        // If this isn't a local krate, then bail out. We don't need to record\n         // exports for nonlocal crates.\n \n         match module_.def_id.get() {\n-            Some(def_id) if def_id.crate == LOCAL_CRATE => {\n+            Some(def_id) if def_id.krate == LOCAL_CRATE => {\n                 // OK. Continue.\n                 debug!(\"(recording exports for module subtree) recording \\\n                         exports for local module `{}`\",\n@@ -3610,10 +3610,10 @@ impl Resolver {\n         return None;\n     }\n \n-    fn resolve_crate(&mut self, crate: &ast::Crate) {\n+    fn resolve_crate(&mut self, krate: &ast::Crate) {\n         debug!(\"(resolving crate) starting\");\n \n-        visit::walk_crate(self, crate, ());\n+        visit::walk_crate(self, krate, ());\n     }\n \n     fn resolve_item(&mut self, item: &Item) {\n@@ -5401,7 +5401,7 @@ impl Resolver {\n                           trait_def_id: DefId,\n                           name: Ident) {\n         debug!(\"(adding trait info) found trait {}:{} for method '{}'\",\n-               trait_def_id.crate,\n+               trait_def_id.krate,\n                trait_def_id.node,\n                self.session.str_of(name));\n         found_traits.push(trait_def_id);\n@@ -5456,9 +5456,9 @@ impl Resolver {\n     // resolve data structures.\n     //\n \n-    fn check_for_unused_imports(&self, crate: &ast::Crate) {\n+    fn check_for_unused_imports(&self, krate: &ast::Crate) {\n         let mut visitor = UnusedImportCheckVisitor{ resolver: self };\n-        visit::walk_crate(&mut visitor, crate, ());\n+        visit::walk_crate(&mut visitor, krate, ());\n     }\n \n     fn check_for_item_unused_imports(&self, vi: &ViewItem) {\n@@ -5579,10 +5579,10 @@ pub struct CrateMap {\n /// Entry point to crate resolution.\n pub fn resolve_crate(session: Session,\n                      lang_items: @LanguageItems,\n-                     crate: &Crate)\n+                     krate: &Crate)\n                   -> CrateMap {\n-    let mut resolver = Resolver(session, lang_items, crate.span);\n-    resolver.resolve(crate);\n+    let mut resolver = Resolver(session, lang_items, krate.span);\n+    resolver.resolve(krate);\n     let Resolver { def_map, export_map2, trait_map, last_private,\n                    external_exports, .. } = resolver;\n     CrateMap {"}, {"sha": "2256bbc46868e5067461dfeeef5802ca1bb91d57", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/89b1686bd7db25b5dd948b1a4d9dfd0c68084c29/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89b1686bd7db25b5dd948b1a4d9dfd0c68084c29/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=89b1686bd7db25b5dd948b1a4d9dfd0c68084c29", "patch": "@@ -44,13 +44,13 @@ enum ScopeChain<'a> {\n     RootScope\n }\n \n-pub fn crate(sess: session::Session, crate: &ast::Crate)\n+pub fn krate(sess: session::Session, krate: &ast::Crate)\n              -> @RefCell<NamedRegionMap> {\n     let mut ctxt = LifetimeContext {\n         sess: sess,\n         named_region_map: @RefCell::new(HashMap::new())\n     };\n-    visit::walk_crate(&mut ctxt, crate, &RootScope);\n+    visit::walk_crate(&mut ctxt, krate, &RootScope);\n     sess.abort_if_errors();\n     ctxt.named_region_map\n }"}, {"sha": "438c0f7c6984f4b2d53f46fa2fe44dcb65667d24", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/89b1686bd7db25b5dd948b1a4d9dfd0c68084c29/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89b1686bd7db25b5dd948b1a4d9dfd0c68084c29/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=89b1686bd7db25b5dd948b1a4d9dfd0c68084c29", "patch": "@@ -522,13 +522,13 @@ pub fn get_res_dtor(ccx: @CrateContext,\n                     substs: &[ty::t])\n                  -> ValueRef {\n     let _icx = push_ctxt(\"trans_res_dtor\");\n-    let did = if did.crate != ast::LOCAL_CRATE {\n+    let did = if did.krate != ast::LOCAL_CRATE {\n         inline::maybe_instantiate_inline(ccx, did)\n     } else {\n         did\n     };\n     if !substs.is_empty() {\n-        assert_eq!(did.crate, ast::LOCAL_CRATE);\n+        assert_eq!(did.krate, ast::LOCAL_CRATE);\n         let tsubsts = ty::substs {regions: ty::ErasedRegions,\n                                   self_ty: None,\n                                   tps: /*bad*/ substs.to_owned() };\n@@ -547,7 +547,7 @@ pub fn get_res_dtor(ccx: @CrateContext,\n                                                     None);\n \n         val\n-    } else if did.crate == ast::LOCAL_CRATE {\n+    } else if did.krate == ast::LOCAL_CRATE {\n         get_item_val(ccx, did.node)\n     } else {\n         let tcx = ccx.tcx;\n@@ -1895,7 +1895,7 @@ pub fn create_entry_wrapper(ccx: @CrateContext,\n                     Ok(id) => id,\n                     Err(s) => { ccx.tcx.sess.fatal(s); }\n                 };\n-                let start_fn = if start_def_id.crate == ast::LOCAL_CRATE {\n+                let start_fn = if start_def_id.krate == ast::LOCAL_CRATE {\n                     get_item_val(ccx, start_def_id.node)\n                 } else {\n                     let start_fn_type = csearch::get_type(ccx.tcx,\n@@ -2610,7 +2610,7 @@ pub fn crate_ctxt_to_encode_parms<'r>(cx: &'r CrateContext, ie: encoder::encode_\n         }\n }\n \n-pub fn write_metadata(cx: &CrateContext, crate: &ast::Crate) -> ~[u8] {\n+pub fn write_metadata(cx: &CrateContext, krate: &ast::Crate) -> ~[u8] {\n     use flate;\n \n     if !cx.sess.building_library.get() {\n@@ -2622,7 +2622,7 @@ pub fn write_metadata(cx: &CrateContext, crate: &ast::Crate) -> ~[u8] {\n         astencode::encode_inlined_item(ecx, ebml_w, path, ii, cx.maps);\n \n     let encode_parms = crate_ctxt_to_encode_parms(cx, encode_inlined_item);\n-    let metadata = encoder::encode_metadata(encode_parms, crate);\n+    let metadata = encoder::encode_metadata(encode_parms, krate);\n     let compressed = encoder::metadata_encoding_version +\n                         flate::deflate_bytes(metadata);\n     let llmeta = C_bytes(compressed);\n@@ -2644,7 +2644,7 @@ pub fn write_metadata(cx: &CrateContext, crate: &ast::Crate) -> ~[u8] {\n }\n \n pub fn trans_crate(sess: session::Session,\n-                   crate: ast::Crate,\n+                   krate: ast::Crate,\n                    analysis: &CrateAnalysis,\n                    output: &OutputFilenames) -> CrateTranslation {\n     // Before we touch LLVM, make sure that multithreading is enabled.\n@@ -2666,7 +2666,7 @@ pub fn trans_crate(sess: session::Session,\n     }\n \n     let mut symbol_hasher = Sha256::new();\n-    let link_meta = link::build_link_meta(crate.attrs, output,\n+    let link_meta = link::build_link_meta(krate.attrs, output,\n                                           &mut symbol_hasher);\n \n     // Append \".rs\" to crate name as LLVM module identifier.\n@@ -2689,7 +2689,7 @@ pub fn trans_crate(sess: session::Session,\n                                      analysis.reachable);\n     {\n         let _icx = push_ctxt(\"text\");\n-        trans_mod(ccx, &crate.module);\n+        trans_mod(ccx, &krate.module);\n     }\n \n     decl_gc_metadata(ccx, llmod_id);\n@@ -2719,7 +2719,7 @@ pub fn trans_crate(sess: session::Session,\n     }\n \n     // Translate the metadata.\n-    let metadata = write_metadata(ccx, &crate);\n+    let metadata = write_metadata(ccx, &krate);\n     if ccx.sess.trans_stats() {\n         println!(\"--- trans stats ---\");\n         println!(\"n_static_tydescs: {}\", ccx.stats.n_static_tydescs.get());"}, {"sha": "53409358f5346f9f6d626c7fe99f05b03d4db4d9", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/89b1686bd7db25b5dd948b1a4d9dfd0c68084c29/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89b1686bd7db25b5dd948b1a4d9dfd0c68084c29/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=89b1686bd7db25b5dd948b1a4d9dfd0c68084c29", "patch": "@@ -346,7 +346,7 @@ pub fn trans_fn_ref_with_vtables(\n     // Check whether this fn has an inlined copy and, if so, redirect\n     // def_id to the local id of the inlined copy.\n     let def_id = {\n-        if def_id.crate != ast::LOCAL_CRATE {\n+        if def_id.krate != ast::LOCAL_CRATE {\n             inline::maybe_instantiate_inline(ccx, def_id)\n         } else {\n             def_id\n@@ -360,7 +360,7 @@ pub fn trans_fn_ref_with_vtables(\n     let must_monomorphise;\n     if type_params.len() > 0 || is_default {\n         must_monomorphise = true;\n-    } else if def_id.crate == ast::LOCAL_CRATE {\n+    } else if def_id.krate == ast::LOCAL_CRATE {\n         {\n             let map_node = session::expect(\n                 ccx.sess,\n@@ -383,7 +383,7 @@ pub fn trans_fn_ref_with_vtables(\n     // Create a monomorphic verison of generic functions\n     if must_monomorphise {\n         // Should be either intra-crate or inlined.\n-        assert_eq!(def_id.crate, ast::LOCAL_CRATE);\n+        assert_eq!(def_id.krate, ast::LOCAL_CRATE);\n \n         let (val, must_cast) =\n             monomorphize::monomorphic_fn(ccx, def_id, &substs,\n@@ -403,7 +403,7 @@ pub fn trans_fn_ref_with_vtables(\n \n     // Find the actual function pointer.\n     let mut val = {\n-        if def_id.crate == ast::LOCAL_CRATE {\n+        if def_id.krate == ast::LOCAL_CRATE {\n             // Internal reference.\n             get_item_val(ccx, def_id.node)\n         } else {\n@@ -512,7 +512,7 @@ pub fn trans_lang_call<'a>(\n                        args: &[ValueRef],\n                        dest: Option<expr::Dest>)\n                        -> Result<'a> {\n-    let fty = if did.crate == ast::LOCAL_CRATE {\n+    let fty = if did.krate == ast::LOCAL_CRATE {\n         ty::node_id_to_type(bcx.ccx().tcx, did.node)\n     } else {\n         csearch::get_type(bcx.ccx().tcx, did).ty\n@@ -541,7 +541,7 @@ pub fn trans_lang_call_with_type_params<'a>(\n                                         dest: expr::Dest)\n                                         -> &'a Block<'a> {\n     let fty;\n-    if did.crate == ast::LOCAL_CRATE {\n+    if did.krate == ast::LOCAL_CRATE {\n         fty = ty::node_id_to_type(bcx.tcx(), did.node);\n     } else {\n         fty = csearch::get_type(bcx.tcx(), did).ty;"}, {"sha": "790ad02a0dd2ba7b84787a8ae6682af4a2651103", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/89b1686bd7db25b5dd948b1a4d9dfd0c68084c29/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89b1686bd7db25b5dd948b1a4d9dfd0c68084c29/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=89b1686bd7db25b5dd948b1a4d9dfd0c68084c29", "patch": "@@ -1398,7 +1398,7 @@ fn describe_enum_variant(cx: &CrateContext,\n     // Could some consistency checks here: size, align, field count, discr type\n \n     // Find the source code location of the variant's definition\n-    let variant_definition_span = if variant_info.id.crate == ast::LOCAL_CRATE {\n+    let variant_definition_span = if variant_info.id.krate == ast::LOCAL_CRATE {\n         {\n             match cx.tcx.items.find(variant_info.id.node) {\n                 Some(ast_map::NodeVariant(ref variant, _, _)) => variant.span,\n@@ -2261,7 +2261,7 @@ fn get_namespace_and_span_for_item(cx: &CrateContext,\n                                    warning_span: Span)\n                                 -> (DIScope, Span) {\n     let containing_scope = namespace_for_item(cx, def_id, warning_span).scope;\n-    let definition_span = if def_id.crate == ast::LOCAL_CRATE {\n+    let definition_span = if def_id.krate == ast::LOCAL_CRATE {\n         {\n             let definition_span = match cx.tcx.items.find(def_id.node) {\n                 Some(ast_map::NodeItem(item, _)) => item.span,\n@@ -2782,16 +2782,16 @@ fn namespace_for_item(cx: &CrateContext,\n     let namespace_path = {\n         let mut item_path = ty::item_path(cx.tcx, def_id);\n \n-        if (def_id.crate == ast::LOCAL_CRATE && item_path.len() < 1) ||\n-           (def_id.crate != ast::LOCAL_CRATE && item_path.len() < 2) {\n+        if (def_id.krate == ast::LOCAL_CRATE && item_path.len() < 1) ||\n+           (def_id.krate != ast::LOCAL_CRATE && item_path.len() < 2) {\n             cx.sess.bug(format!(\"debuginfo::namespace_for_item() - Item path too short: {}\",\n                 ast_map::path_to_str(item_path, token::get_ident_interner())));\n         }\n \n         // remove the name of the item\n         item_path.pop();\n \n-        if def_id.crate == ast::LOCAL_CRATE {\n+        if def_id.krate == ast::LOCAL_CRATE {\n             // prepend crate name if not already present\n             let crate_namespace_ident = token::str_to_ident(cx.link_meta.crateid.name);\n             item_path.insert(0, ast_map::PathMod(crate_namespace_ident));"}, {"sha": "7ac91704cefab59fb37d4254c64a5d435b96f666", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/89b1686bd7db25b5dd948b1a4d9dfd0c68084c29/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89b1686bd7db25b5dd948b1a4d9dfd0c68084c29/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=89b1686bd7db25b5dd948b1a4d9dfd0c68084c29", "patch": "@@ -582,7 +582,7 @@ fn trans_def<'a>(bcx: &'a Block<'a>,\n \n             fn get_did(ccx: @CrateContext, did: ast::DefId)\n                        -> ast::DefId {\n-                if did.crate != ast::LOCAL_CRATE {\n+                if did.krate != ast::LOCAL_CRATE {\n                     inline::maybe_instantiate_inline(ccx, did)\n                 } else {\n                     did\n@@ -592,7 +592,7 @@ fn trans_def<'a>(bcx: &'a Block<'a>,\n             fn get_val<'a>(bcx: &'a Block<'a>, did: ast::DefId, const_ty: ty::t)\n                        -> ValueRef {\n                 // For external constants, we don't inline.\n-                if did.crate == ast::LOCAL_CRATE {\n+                if did.krate == ast::LOCAL_CRATE {\n                     // The LLVM global has the type of its initializer,\n                     // which may not be equal to the enum's type for\n                     // non-C-like enums.\n@@ -1710,7 +1710,7 @@ fn trans_log_level<'a>(bcx: &'a Block<'a>)\n             let external_srcs = ccx.external_srcs.borrow();\n             srccrate = match external_srcs.get().find(&bcx.fcx.id) {\n                 Some(&src) => {\n-                    ccx.sess.cstore.get_crate_data(src.crate).name.clone()\n+                    ccx.sess.cstore.get_crate_data(src.krate).name.clone()\n                 }\n                 None => ccx.link_meta.crateid.name.to_str(),\n             };"}, {"sha": "4e8ca21dca59b2ffae814502555d28d7094b7d3c", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/89b1686bd7db25b5dd948b1a4d9dfd0c68084c29/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89b1686bd7db25b5dd948b1a4d9dfd0c68084c29/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=89b1686bd7db25b5dd948b1a4d9dfd0c68084c29", "patch": "@@ -184,7 +184,7 @@ pub fn trans_static_method_callee(bcx: &Block,\n     let bound_index = ty::lookup_trait_def(bcx.tcx(), trait_id).\n         generics.type_param_defs().len();\n \n-    let mname = if method_id.crate == ast::LOCAL_CRATE {\n+    let mname = if method_id.krate == ast::LOCAL_CRATE {\n         {\n             match bcx.tcx().items.get(method_id.node) {\n                 ast_map::NodeTraitMethod(trait_method, _, _) => {"}, {"sha": "f379b6227d9cad02cc0eb56648eaa7cec7a42b78", "filename": "src/librustc/middle/trans/type_of.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/89b1686bd7db25b5dd948b1a4d9dfd0c68084c29/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89b1686bd7db25b5dd948b1a4d9dfd0c68084c29/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=89b1686bd7db25b5dd948b1a4d9dfd0c68084c29", "patch": "@@ -321,10 +321,10 @@ pub fn llvm_type_name(cx: &CrateContext,\n     let tstr = ppaux::parameterized(cx.tcx, ty::item_path_str(cx.tcx, did),\n                                     &ty::NonerasedRegions(opt_vec::Empty),\n                                     tps, did, false);\n-    if did.crate == 0 {\n+    if did.krate == 0 {\n         format!(\"{}.{}\", name, tstr)\n     } else {\n-        format!(\"{}.{}[\\\\#{}]\", name, tstr, did.crate)\n+        format!(\"{}.{}[\\\\#{}]\", name, tstr, did.krate)\n     }\n }\n "}, {"sha": "a736fb61ab2dc61812c9cde4b71e2164032d15e9", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/89b1686bd7db25b5dd948b1a4d9dfd0c68084c29/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89b1686bd7db25b5dd948b1a4d9dfd0c68084c29/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=89b1686bd7db25b5dd948b1a4d9dfd0c68084c29", "patch": "@@ -2187,7 +2187,7 @@ pub fn type_contents(cx: ctxt, ty: t) -> TypeContents {\n                 // If this assertion failures, it is likely because of a\n                 // failure in the cross-crate inlining code to translate a\n                 // def-id.\n-                assert_eq!(p.def_id.crate, ast::LOCAL_CRATE);\n+                assert_eq!(p.def_id.krate, ast::LOCAL_CRATE);\n \n                 let ty_param_defs = cx.ty_param_defs.borrow();\n                 let tp_def = ty_param_defs.get().get(&p.def_id.node);\n@@ -3842,8 +3842,8 @@ fn lookup_locally_or_in_crate_store<V:Clone>(\n         None => { }\n     }\n \n-    if def_id.crate == ast::LOCAL_CRATE {\n-        fail!(\"no def'n found for {:?} in tcx.{}\", def_id, descr);\n+    if def_id.krate == ast::LOCAL_CRATE {\n+        fail!(\"No def'n found for {:?} in tcx.{}\", def_id, descr);\n     }\n     let v = load_external();\n     map.insert(def_id, v.clone());\n@@ -3895,7 +3895,7 @@ pub fn impl_trait_ref(cx: ctxt, id: ast::DefId) -> Option<@TraitRef> {\n         }\n     }\n \n-    let ret = if id.crate == ast::LOCAL_CRATE {\n+    let ret = if id.krate == ast::LOCAL_CRATE {\n         debug!(\"(impl_trait_ref) searching for trait impl {:?}\", id);\n         {\n             match cx.items.find(id.node) {\n@@ -4085,7 +4085,7 @@ pub fn has_dtor(cx: ctxt, struct_id: DefId) -> bool {\n }\n \n pub fn item_path(cx: ctxt, id: ast::DefId) -> ast_map::Path {\n-    if id.crate != ast::LOCAL_CRATE {\n+    if id.krate != ast::LOCAL_CRATE {\n         return csearch::get_item_path(cx, id)\n     }\n \n@@ -4155,7 +4155,7 @@ pub fn enum_variants(cx: ctxt, id: ast::DefId) -> @~[@VariantInfo] {\n         }\n     }\n \n-    let result = if ast::LOCAL_CRATE != id.crate {\n+    let result = if ast::LOCAL_CRATE != id.krate {\n         @csearch::get_enum_variants(cx, id)\n     } else {\n         /*\n@@ -4274,7 +4274,7 @@ pub fn lookup_trait_def(cx: ctxt, did: ast::DefId) -> @ty::TraitDef {\n             return trait_def;\n         }\n         None => {\n-            assert!(did.crate != ast::LOCAL_CRATE);\n+            assert!(did.krate != ast::LOCAL_CRATE);\n             let trait_def = @csearch::get_trait_def(cx, did);\n             trait_defs.get().insert(did, trait_def);\n             return trait_def;\n@@ -4348,7 +4348,7 @@ pub fn lookup_field_type(tcx: ctxt,\n                          id: DefId,\n                          substs: &substs)\n                       -> ty::t {\n-    let t = if id.crate == ast::LOCAL_CRATE {\n+    let t = if id.krate == ast::LOCAL_CRATE {\n         node_id_to_type(tcx, id.node)\n     } else {\n         {\n@@ -4369,7 +4369,7 @@ pub fn lookup_field_type(tcx: ctxt,\n // Look up the list of field names and IDs for a given struct\n // Fails if the id is not bound to a struct.\n pub fn lookup_struct_fields(cx: ctxt, did: ast::DefId) -> ~[field_ty] {\n-  if did.crate == ast::LOCAL_CRATE {\n+  if did.krate == ast::LOCAL_CRATE {\n       {\n           match cx.items.find(did.node) {\n            Some(ast_map::NodeItem(i,_)) => {\n@@ -4799,7 +4799,7 @@ fn record_trait_implementation(tcx: ctxt,\n /// if necessary.\n pub fn populate_implementations_for_type_if_necessary(tcx: ctxt,\n                                                       type_id: ast::DefId) {\n-    if type_id.crate == LOCAL_CRATE {\n+    if type_id.krate == LOCAL_CRATE {\n         return\n     }\n     {\n@@ -4867,7 +4867,7 @@ pub fn populate_implementations_for_type_if_necessary(tcx: ctxt,\n pub fn populate_implementations_for_trait_if_necessary(\n         tcx: ctxt,\n         trait_id: ast::DefId) {\n-    if trait_id.crate == LOCAL_CRATE {\n+    if trait_id.krate == LOCAL_CRATE {\n         return\n     }\n     {\n@@ -4931,7 +4931,7 @@ pub fn trait_id_of_impl(tcx: ctxt,\n /// the trait that the method belongs to. Otherwise, return `None`.\n pub fn trait_of_method(tcx: ctxt, def_id: ast::DefId)\n                        -> Option<ast::DefId> {\n-    if def_id.crate != LOCAL_CRATE {\n+    if def_id.krate != LOCAL_CRATE {\n         return csearch::get_trait_of_method(tcx.cstore, def_id, tcx);\n     }\n     let method;\n@@ -5012,7 +5012,7 @@ pub fn hash_crate_independent(tcx: ctxt, t: t, local_hash: ~str) -> u64 {\n         let h = if ast_util::is_local(did) {\n             local_hash.clone()\n         } else {\n-            tcx.sess.cstore.get_crate_hash(did.crate)\n+            tcx.sess.cstore.get_crate_hash(did.krate)\n         };\n         hash.input(h.as_bytes());\n         iter(hash, &did.node);"}, {"sha": "27fb78db2013d3622afdf31d7100d671c49aebe6", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/89b1686bd7db25b5dd948b1a4d9dfd0c68084c29/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89b1686bd7db25b5dd948b1a4d9dfd0c68084c29/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=89b1686bd7db25b5dd948b1a4d9dfd0c68084c29", "patch": "@@ -1297,7 +1297,7 @@ impl<'a> LookupContext<'a> {\n     }\n \n     fn report_static_candidate(&self, idx: uint, did: DefId) {\n-        let span = if did.crate == ast::LOCAL_CRATE {\n+        let span = if did.krate == ast::LOCAL_CRATE {\n             {\n                 match self.tcx().items.find(did.node) {\n                   Some(ast_map::NodeMethod(m, _, _)) => m.span,"}, {"sha": "ac8101737eab2d867052b67cc0b8e9665a6974e8", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/89b1686bd7db25b5dd948b1a4d9dfd0c68084c29/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89b1686bd7db25b5dd948b1a4d9dfd0c68084c29/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=89b1686bd7db25b5dd948b1a4d9dfd0c68084c29", "patch": "@@ -312,9 +312,9 @@ impl Visitor<()> for CheckItemTypesVisitor {\n     }\n }\n \n-pub fn check_item_types(ccx: @CrateCtxt, crate: &ast::Crate) {\n+pub fn check_item_types(ccx: @CrateCtxt, krate: &ast::Crate) {\n     let mut visit = CheckItemTypesVisitor { ccx: ccx };\n-    visit::walk_crate(&mut visit, crate, ());\n+    visit::walk_crate(&mut visit, krate, ());\n }\n \n fn check_bare_fn(ccx: @CrateCtxt,\n@@ -2648,7 +2648,7 @@ pub fn check_expr_with_unifier(fcx: @FnCtxt,\n                                       Err(msg) => {\n                                           tcx.sess.span_err(expr.span, msg);\n                                           ast::DefId {\n-                                              crate: ast::CRATE_NODE_ID,\n+                                              krate: ast::CRATE_NODE_ID,\n                                               node: ast::DUMMY_NODE_ID,\n                                           }\n                                       }\n@@ -3625,7 +3625,7 @@ pub fn check_enum_variants(ccx: @CrateCtxt,\n         return variants;\n     }\n \n-    let hint = ty::lookup_repr_hint(ccx.tcx, ast::DefId { crate: ast::LOCAL_CRATE, node: id });\n+    let hint = ty::lookup_repr_hint(ccx.tcx, ast::DefId { krate: ast::LOCAL_CRATE, node: id });\n     if hint != attr::ReprAny && vs.len() <= 1 {\n         ccx.tcx.sess.span_err(sp, format!(\"unsupported representation for {}variant enum\",\n                                           if vs.len() == 1 { \"uni\" } else { \"zero-\" }))"}, {"sha": "a015f43b2302b7e73c52150971e5e1ed1ea8f1cc", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/89b1686bd7db25b5dd948b1a4d9dfd0c68084c29/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89b1686bd7db25b5dd948b1a4d9dfd0c68084c29/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=89b1686bd7db25b5dd948b1a4d9dfd0c68084c29", "patch": "@@ -631,7 +631,7 @@ fn check_expr_fn_block(rcx: &mut Rcx,\n             // Identify the variable being closed over and its node-id.\n             let def = freevar.def;\n             let def_id = ast_util::def_id_of_def(def);\n-            assert!(def_id.crate == ast::LOCAL_CRATE);\n+            assert!(def_id.krate == ast::LOCAL_CRATE);\n             let upvar_id = ty::UpvarId { var_id: def_id.node,\n                                          closure_expr_id: expr.id };\n "}, {"sha": "0d0aa72470f58ea94b489d6c9bc53df9d945d2e7", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/89b1686bd7db25b5dd948b1a4d9dfd0c68084c29/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89b1686bd7db25b5dd948b1a4d9dfd0c68084c29/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=89b1686bd7db25b5dd948b1a4d9dfd0c68084c29", "patch": "@@ -107,7 +107,7 @@ fn type_is_defined_in_local_crate(original_type: t) -> bool {\n             ty_enum(def_id, _) |\n             ty_trait(def_id, _, _, _, _) |\n             ty_struct(def_id, _) => {\n-                if def_id.crate == ast::LOCAL_CRATE {\n+                if def_id.krate == ast::LOCAL_CRATE {\n                     found_nominal = true;\n                 }\n             }\n@@ -209,7 +209,7 @@ impl<'a> visit::Visitor<()> for PrivilegedScopeVisitor<'a> {\n                     let trait_def_id =\n                         self.cc.trait_ref_to_trait_def_id(trait_ref);\n \n-                    if trait_def_id.crate != LOCAL_CRATE {\n+                    if trait_def_id.krate != LOCAL_CRATE {\n                         let session = self.cc.crate_context.tcx.sess;\n                         session.span_err(item.span,\n                                 \"cannot provide an extension implementation \\\n@@ -234,18 +234,18 @@ impl CoherenceChecker {\n         }\n     }\n \n-    fn check(&self, crate: &Crate) {\n+    fn check(&self, krate: &Crate) {\n         // Check implementations and traits. This populates the tables\n         // containing the inherent methods and extension methods. It also\n         // builds up the trait inheritance table.\n         let mut visitor = CoherenceCheckVisitor { cc: self };\n-        visit::walk_crate(&mut visitor, crate, ());\n+        visit::walk_crate(&mut visitor, krate, ());\n \n         // Check that there are no overlapping trait instances\n         self.check_implementation_coherence();\n \n         // Check whether traits with base types are in privileged scopes.\n-        self.check_privileged_scopes(crate);\n+        self.check_privileged_scopes(krate);\n \n         // Bring in external crates. It's fine for this to happen after the\n         // coherence checks, because we ensure by construction that no errors\n@@ -453,12 +453,12 @@ impl CoherenceChecker {\n                             format!(\"conflicting implementations for trait `{}`\",\n                                  ty::item_path_str(self.crate_context.tcx,\n                                                    trait_def_id)));\n-                        if implementation_b.did.crate == LOCAL_CRATE {\n+                        if implementation_b.did.krate == LOCAL_CRATE {\n                             session.span_note(self.span_of_impl(implementation_b),\n                                               \"note conflicting implementation here\");\n                         } else {\n                             let crate_store = self.crate_context.tcx.sess.cstore;\n-                            let cdata = crate_store.get_crate_data(implementation_b.did.crate);\n+                            let cdata = crate_store.get_crate_data(implementation_b.did.krate);\n                             session.note(\n                                 \"conflicting implementation in crate `\" + cdata.name + \"`\");\n                         }\n@@ -471,7 +471,7 @@ impl CoherenceChecker {\n     fn iter_impls_of_trait(&self, trait_def_id: DefId, f: |@Impl|) {\n         self.iter_impls_of_trait_local(trait_def_id, |x| f(x));\n \n-        if trait_def_id.crate == LOCAL_CRATE {\n+        if trait_def_id.krate == LOCAL_CRATE {\n             return;\n         }\n \n@@ -556,9 +556,9 @@ impl CoherenceChecker {\n     }\n \n     // Privileged scope checking\n-    fn check_privileged_scopes(&self, crate: &Crate) {\n-        let mut visitor = PrivilegedScopeVisitor { cc: self };\n-        visit::walk_crate(&mut visitor, crate, ());\n+    fn check_privileged_scopes(&self, krate: &Crate) {\n+        let mut visitor = PrivilegedScopeVisitor{ cc: self };\n+        visit::walk_crate(&mut visitor, krate, ());\n     }\n \n     fn trait_ref_to_trait_def_id(&self, trait_ref: &TraitRef) -> DefId {\n@@ -578,7 +578,7 @@ impl CoherenceChecker {\n                 let def_map = self.crate_context.tcx.def_map.borrow();\n                 match def_map.get().get_copy(&path_id) {\n                     DefTy(def_id) | DefStruct(def_id) => {\n-                        if def_id.crate != LOCAL_CRATE {\n+                        if def_id.krate != LOCAL_CRATE {\n                             return false;\n                         }\n \n@@ -640,7 +640,7 @@ impl CoherenceChecker {\n     }\n \n     fn span_of_impl(&self, implementation: @Impl) -> Span {\n-        assert_eq!(implementation.did.crate, LOCAL_CRATE);\n+        assert_eq!(implementation.did.krate, LOCAL_CRATE);\n         match self.crate_context.tcx.items.find(implementation.did.node) {\n             Some(NodeItem(item, _)) => {\n                 return item.span;\n@@ -700,7 +700,7 @@ impl CoherenceChecker {\n         let crate_store = self.crate_context.tcx.sess.cstore;\n         crate_store.iter_crate_data(|crate_number, _crate_metadata| {\n             each_impl(crate_store, crate_number, |def_id| {\n-                assert_eq!(crate_number, def_id.crate);\n+                assert_eq!(crate_number, def_id.krate);\n                 self.add_external_impl(&mut impls_seen, def_id)\n             })\n         })\n@@ -744,7 +744,7 @@ impl CoherenceChecker {\n                 }\n                 _ => {\n                     // Destructors only work on nominal types.\n-                    if impl_info.did.crate == ast::LOCAL_CRATE {\n+                    if impl_info.did.krate == ast::LOCAL_CRATE {\n                         {\n                             match tcx.items.find(impl_info.did.node) {\n                                 Some(ast_map::NodeItem(item, _)) => {\n@@ -845,6 +845,6 @@ fn subst_receiver_types_in_method_ty(tcx: ty::ctxt,\n     )\n }\n \n-pub fn check_coherence(crate_context: @CrateCtxt, crate: &Crate) {\n-    CoherenceChecker::new(crate_context).check(crate);\n+pub fn check_coherence(crate_context: @CrateCtxt, krate: &Crate) {\n+    CoherenceChecker::new(crate_context).check(krate);\n }"}, {"sha": "abc9376053ef00ca8d03eef2bdc21bc1af4240e3", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/89b1686bd7db25b5dd948b1a4d9dfd0c68084c29/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89b1686bd7db25b5dd948b1a4d9dfd0c68084c29/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=89b1686bd7db25b5dd948b1a4d9dfd0c68084c29", "patch": "@@ -73,7 +73,7 @@ impl visit::Visitor<()> for CollectItemTypesVisitor {\n     }\n }\n \n-pub fn collect_item_types(ccx: @CrateCtxt, crate: &ast::Crate) {\n+pub fn collect_item_types(ccx: @CrateCtxt, krate: &ast::Crate) {\n     fn collect_intrinsic_type(ccx: &CrateCtxt,\n                               lang_item: ast::DefId) {\n         let ty::ty_param_bounds_and_ty { ty: ty, .. } =\n@@ -90,7 +90,7 @@ pub fn collect_item_types(ccx: @CrateCtxt, crate: &ast::Crate) {\n     }\n \n     let mut visitor = CollectItemTypesVisitor{ ccx: ccx };\n-    visit::walk_crate(&mut visitor, crate, ());\n+    visit::walk_crate(&mut visitor, krate, ());\n }\n \n pub trait ToTy {\n@@ -107,7 +107,7 @@ impl AstConv for CrateCtxt {\n     fn tcx(&self) -> ty::ctxt { self.tcx }\n \n     fn get_item_ty(&self, id: ast::DefId) -> ty::ty_param_bounds_and_ty {\n-        if id.crate != ast::LOCAL_CRATE {\n+        if id.krate != ast::LOCAL_CRATE {\n             return csearch::get_type(self.tcx, id)\n         }\n \n@@ -283,7 +283,7 @@ pub fn ensure_trait_methods(ccx: &CrateCtxt, trait_id: ast::NodeId) {\n \n         let tcx = ccx.tcx;\n \n-        let dummy_defid = ast::DefId {crate: 0, node: 0};\n+        let dummy_defid = ast::DefId {krate: 0, node: 0};\n \n         // Represents [A',B',C']\n         let num_trait_bounds = trait_ty_generics.type_param_defs().len();\n@@ -765,7 +765,7 @@ pub fn instantiate_trait_ref(ccx: &CrateCtxt,\n }\n \n fn get_trait_def(ccx: &CrateCtxt, trait_id: ast::DefId) -> @ty::TraitDef {\n-    if trait_id.crate != ast::LOCAL_CRATE {\n+    if trait_id.krate != ast::LOCAL_CRATE {\n         return ty::lookup_trait_def(ccx.tcx, trait_id)\n     }\n "}, {"sha": "0a447a5f8e6fd7e8152ff6c96b32464b0ece9893", "filename": "src/librustc/middle/typeck/infer/test.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/89b1686bd7db25b5dd948b1a4d9dfd0c68084c29/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89b1686bd7db25b5dd948b1a4d9dfd0c68084c29/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs?ref=89b1686bd7db25b5dd948b1a4d9dfd0c68084c29", "patch": "@@ -31,7 +31,7 @@ use syntax::parse::parse_crate_from_source_str;\n use syntax::{ast, attr, parse};\n \n struct Env {\n-    crate: @ast::Crate,\n+    krate: @ast::Crate,\n     tcx: ty::ctxt,\n     infcx: infer::infer_ctxt,\n     err_messages: @DVec<~str>\n@@ -59,7 +59,7 @@ fn setup_env(test_name: &str, source_string: &str) -> Env {\n     let lang_items = LanguageItems::new();\n \n     let parse_sess = parse::new_parse_sess(None);\n-    let crate = parse_crate_from_source_str(\n+    let krate = parse_crate_from_source_str(\n         test_name.to_str(), @source_string.to_str(),\n         cfg, parse_sess);\n \n@@ -68,7 +68,7 @@ fn setup_env(test_name: &str, source_string: &str) -> Env {\n \n     let infcx = infer::new_infer_ctxt(tcx);\n \n-    return Env {crate: crate,\n+    return Env {krate: krate,\n                 tcx: tcx,\n                 infcx: infcx,\n                 err_messages: messages};\n@@ -94,7 +94,7 @@ impl Env {\n     }\n \n     pub fn lookup_item(&self, names: &[~str]) -> ast::node_id {\n-        return match search_mod(self, &self.crate.node.module, 0, names) {\n+        return match search_mod(self, &self.krate.node.module, 0, names) {\n             Some(id) => id,\n             None => {\n                 fail!(\"no item found: `%s`\", names.connect(\"::\"));"}, {"sha": "aa98477f14b9af8ace7cd2dbb0943bb8ce4f3e10", "filename": "src/librustc/middle/typeck/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/89b1686bd7db25b5dd948b1a4d9dfd0c68084c29/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89b1686bd7db25b5dd948b1a4d9dfd0c68084c29/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs?ref=89b1686bd7db25b5dd948b1a4d9dfd0c68084c29", "patch": "@@ -441,7 +441,7 @@ fn check_for_entry_fn(ccx: &CrateCtxt) {\n \n pub fn check_crate(tcx: ty::ctxt,\n                    trait_map: resolve::TraitMap,\n-                   crate: &ast::Crate)\n+                   krate: &ast::Crate)\n                 -> (method_map, vtable_map) {\n     let time_passes = tcx.sess.time_passes();\n     let ccx = @CrateCtxt {\n@@ -452,20 +452,20 @@ pub fn check_crate(tcx: ty::ctxt,\n     };\n \n     time(time_passes, \"type collecting\", (), |_|\n-        collect::collect_item_types(ccx, crate));\n+        collect::collect_item_types(ccx, krate));\n \n     // this ensures that later parts of type checking can assume that items\n     // have valid types and not error\n     tcx.sess.abort_if_errors();\n \n     time(time_passes, \"variance inference\", (), |_|\n-         variance::infer_variance(tcx, crate));\n+         variance::infer_variance(tcx, krate));\n \n     time(time_passes, \"coherence checking\", (), |_|\n-        coherence::check_coherence(ccx, crate));\n+        coherence::check_coherence(ccx, krate));\n \n     time(time_passes, \"type checking\", (), |_|\n-        check::check_item_types(ccx, crate));\n+        check::check_item_types(ccx, krate));\n \n     check_for_entry_fn(ccx);\n     tcx.sess.abort_if_errors();"}, {"sha": "b20312c2241c9a4f2eac0ddbff169090b84a549f", "filename": "src/librustc/middle/typeck/rscope.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/89b1686bd7db25b5dd948b1a4d9dfd0c68084c29/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89b1686bd7db25b5dd948b1a4d9dfd0c68084c29/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs?ref=89b1686bd7db25b5dd948b1a4d9dfd0c68084c29", "patch": "@@ -76,7 +76,7 @@ impl RegionScope for BindingRscope {\n \n pub fn bound_type_regions(defs: &[ty::RegionParameterDef])\n                           -> OptVec<ty::Region> {\n-    assert!(defs.iter().all(|def| def.def_id.crate == ast::LOCAL_CRATE));\n+    assert!(defs.iter().all(|def| def.def_id.krate == ast::LOCAL_CRATE));\n     defs.iter().enumerate().map(\n         |(i, def)| ty::ReEarlyBound(def.def_id.node, i, def.ident)).collect()\n }"}, {"sha": "5848c9bdf02c71842d7d7172c41cef8abde24ce9", "filename": "src/librustc/middle/typeck/variance.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/89b1686bd7db25b5dd948b1a4d9dfd0c68084c29/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89b1686bd7db25b5dd948b1a4d9dfd0c68084c29/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs?ref=89b1686bd7db25b5dd948b1a4d9dfd0c68084c29", "patch": "@@ -207,10 +207,10 @@ use syntax::visit::Visitor;\n use util::ppaux::Repr;\n \n pub fn infer_variance(tcx: ty::ctxt,\n-                      crate: &ast::Crate) {\n+                      krate: &ast::Crate) {\n     let mut arena = arena::Arena::new();\n-    let terms_cx = determine_parameters_to_be_inferred(tcx, &mut arena, crate);\n-    let constraints_cx = add_constraints_from_crate(terms_cx, crate);\n+    let terms_cx = determine_parameters_to_be_inferred(tcx, &mut arena, krate);\n+    let constraints_cx = add_constraints_from_crate(terms_cx, krate);\n     solve_constraints(constraints_cx);\n }\n \n@@ -278,7 +278,7 @@ struct InferredInfo<'a> {\n \n fn determine_parameters_to_be_inferred<'a>(tcx: ty::ctxt,\n                                            arena: &'a mut Arena,\n-                                           crate: &ast::Crate)\n+                                           krate: &ast::Crate)\n                                            -> TermsContext<'a> {\n     let mut terms_cx = TermsContext {\n         tcx: tcx,\n@@ -293,7 +293,7 @@ fn determine_parameters_to_be_inferred<'a>(tcx: ty::ctxt,\n                                               region_params: opt_vec::Empty }\n     };\n \n-    visit::walk_crate(&mut terms_cx, crate, ());\n+    visit::walk_crate(&mut terms_cx, krate, ());\n \n     terms_cx\n }\n@@ -423,7 +423,7 @@ struct Constraint<'a> {\n }\n \n fn add_constraints_from_crate<'a>(terms_cx: TermsContext<'a>,\n-                                  crate: &ast::Crate)\n+                                  krate: &ast::Crate)\n                                   -> ConstraintContext<'a> {\n     let mut invariant_lang_items = [None, ..3];\n     let mut covariant_lang_items = [None, ..3];\n@@ -461,7 +461,7 @@ fn add_constraints_from_crate<'a>(terms_cx: TermsContext<'a>,\n         bivariant: bivariant,\n         constraints: ~[],\n     };\n-    visit::walk_crate(&mut constraint_cx, crate, ());\n+    visit::walk_crate(&mut constraint_cx, krate, ());\n     constraint_cx\n }\n \n@@ -496,7 +496,7 @@ impl<'a> Visitor<()> for ConstraintContext<'a> {\n             ast::ItemStruct(..) => {\n                 let struct_fields = ty::lookup_struct_fields(tcx, did);\n                 for field_info in struct_fields.iter() {\n-                    assert_eq!(field_info.id.crate, ast::LOCAL_CRATE);\n+                    assert_eq!(field_info.id.krate, ast::LOCAL_CRATE);\n                     let field_ty = ty::node_id_to_type(tcx, field_info.id.node);\n                     self.add_constraints_from_ty(field_ty, self.covariant);\n                 }\n@@ -552,15 +552,15 @@ impl<'a> ConstraintContext<'a> {\n          * the type/region parameter with the given id.\n          */\n \n-        assert_eq!(param_def_id.crate, item_def_id.crate);\n+        assert_eq!(param_def_id.krate, item_def_id.krate);\n \n         if self.invariant_lang_items[kind as uint] == Some(item_def_id) {\n             self.invariant\n         } else if self.covariant_lang_items[kind as uint] == Some(item_def_id) {\n             self.covariant\n         } else if self.contravariant_lang_items[kind as uint] == Some(item_def_id) {\n             self.contravariant\n-        } else if param_def_id.crate == ast::LOCAL_CRATE {\n+        } else if param_def_id.krate == ast::LOCAL_CRATE {\n             // Parameter on an item defined within current crate:\n             // variance not yet inferred, so return a symbolic\n             // variance.\n@@ -686,7 +686,7 @@ impl<'a> ConstraintContext<'a> {\n             }\n \n             ty::ty_param(ty::param_ty { def_id: ref def_id, .. }) => {\n-                assert_eq!(def_id.crate, ast::LOCAL_CRATE);\n+                assert_eq!(def_id.krate, ast::LOCAL_CRATE);\n                 match self.terms_cx.inferred_map.find(&def_id.node) {\n                     Some(&index) => {\n                         self.add_constraint(index, variance);\n@@ -700,7 +700,7 @@ impl<'a> ConstraintContext<'a> {\n             }\n \n             ty::ty_self(ref def_id) => {\n-                assert_eq!(def_id.crate, ast::LOCAL_CRATE);\n+                assert_eq!(def_id.krate, ast::LOCAL_CRATE);\n                 let index = self.inferred_index(def_id.node);\n                 self.add_constraint(index, variance);\n             }"}, {"sha": "cced7dc6a269bd87953387fa7b464012b44ffb64", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/89b1686bd7db25b5dd948b1a4d9dfd0c68084c29/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89b1686bd7db25b5dd948b1a4d9dfd0c68084c29/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=89b1686bd7db25b5dd948b1a4d9dfd0c68084c29", "patch": "@@ -781,7 +781,7 @@ impl Repr for ast::DefId {\n         // Unfortunately, there seems to be no way to attempt to print\n         // a path for a def-id, so I'll just make a best effort for now\n         // and otherwise fallback to just printing the crate/node pair\n-        if self.crate == ast::LOCAL_CRATE {\n+        if self.krate == ast::LOCAL_CRATE {\n             {\n                 match tcx.items.find(self.node) {\n                     Some(ast_map::NodeItem(..)) |"}, {"sha": "0c1d8a09a82b9506d2d09bca877bf8250b0f3891", "filename": "src/librustdoc/clean.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/89b1686bd7db25b5dd948b1a4d9dfd0c68084c29/src%2Flibrustdoc%2Fclean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89b1686bd7db25b5dd948b1a4d9dfd0c68084c29/src%2Flibrustdoc%2Fclean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean.rs?ref=89b1686bd7db25b5dd948b1a4d9dfd0c68084c29", "patch": "@@ -615,7 +615,7 @@ pub enum Type {\n         typarams: Option<~[TyParamBound]>,\n         fqn: ~[~str],\n         kind: TypeKind,\n-        crate: ast::CrateNum,\n+        krate: ast::CrateNum,\n     },\n     // I have no idea how to usefully use this.\n     TyParamBinder(ast::NodeId),\n@@ -1250,7 +1250,7 @@ fn resolve_type(path: Path, tpbs: Option<~[TyParamBound]>,\n             }\n         }).to_owned_vec();\n         ExternalPath{ path: path, typarams: tpbs, fqn: fqn, kind: kind,\n-                      crate: def_id.crate }\n+                      krate: def_id.krate }\n     }\n }\n "}, {"sha": "585b18a8821bb090127dbd2595faa68d9212093d", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/89b1686bd7db25b5dd948b1a4d9dfd0c68084c29/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89b1686bd7db25b5dd948b1a4d9dfd0c68084c29/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=89b1686bd7db25b5dd948b1a4d9dfd0c68084c29", "patch": "@@ -28,7 +28,7 @@ use clean;\n use clean::Clean;\n \n pub struct DocContext {\n-    crate: ast::Crate,\n+    krate: ast::Crate,\n     tycx: Option<middle::ty::ctxt>,\n     sess: driver::session::Session\n }\n@@ -73,15 +73,15 @@ fn get_ast_and_resolve(cpath: &Path,\n         cfg.push(@dummy_spanned(ast::MetaWord(cfg_)));\n     }\n \n-    let crate = phase_1_parse_input(sess, cfg, &input);\n+    let krate = phase_1_parse_input(sess, cfg, &input);\n     let loader = &mut Loader::new(sess);\n-    let (crate, ast_map) = phase_2_configure_and_expand(sess, loader, crate);\n+    let (krate, ast_map) = phase_2_configure_and_expand(sess, loader, krate);\n     let driver::driver::CrateAnalysis {\n         exported_items, public_items, ty_cx, ..\n-    } = phase_3_run_analysis_passes(sess, &crate, ast_map);\n+    } = phase_3_run_analysis_passes(sess, &krate, ast_map);\n \n-    debug!(\"crate: {:?}\", crate);\n-    return (DocContext { crate: crate, tycx: Some(ty_cx), sess: sess },\n+    debug!(\"crate: {:?}\", krate);\n+    return (DocContext { krate: krate, tycx: Some(ty_cx), sess: sess },\n             CrateAnalysis {\n                 exported_items: exported_items,\n                 public_items: public_items,\n@@ -93,11 +93,11 @@ pub fn run_core (libs: HashSet<Path>, cfgs: ~[~str], path: &Path) -> (clean::Cra\n     let ctxt = @ctxt;\n     local_data::set(super::ctxtkey, ctxt);\n \n-    let crate = {\n+    let krate = {\n         let mut v = RustdocVisitor::new(ctxt, Some(&analysis));\n-        v.visit(&ctxt.crate);\n+        v.visit(&ctxt.krate);\n         v.clean()\n     };\n \n-    (crate, analysis)\n+    (krate, analysis)\n }"}, {"sha": "c08f2ca382df4a140f647c1dbabdb257e354884a", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/89b1686bd7db25b5dd948b1a4d9dfd0c68084c29/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89b1686bd7db25b5dd948b1a4d9dfd0c68084c29/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=89b1686bd7db25b5dd948b1a4d9dfd0c68084c29", "patch": "@@ -160,10 +160,10 @@ fn resolved_path(w: &mut io::Writer, id: ast::NodeId, p: &clean::Path,\n /// will invoke `path` with proper linking-style arguments.\n fn external_path(w: &mut io::Writer, p: &clean::Path, print_all: bool,\n                  fqn: &[~str], kind: clean::TypeKind,\n-                 crate: ast::CrateNum) -> fmt::Result {\n+                 krate: ast::CrateNum) -> fmt::Result {\n     path(w, p, print_all,\n         |cache, loc| {\n-            match *cache.extern_locations.get(&crate) {\n+            match *cache.extern_locations.get(&krate) {\n                 render::Remote(ref s) => Some(s.clone()),\n                 render::Local => Some(\"../\".repeat(loc.len())),\n                 render::Unknown => None,\n@@ -310,9 +310,9 @@ impl fmt::Show for clean::Type {\n                 typarams(f.buf, tp)\n             }\n             clean::ExternalPath{path: ref path, typarams: ref tp,\n-                                fqn: ref fqn, kind, crate} => {\n+                                fqn: ref fqn, kind, krate} => {\n                 if_ok!(external_path(f.buf, path, false, fqn.as_slice(), kind,\n-                                     crate))\n+                                     krate))\n                 typarams(f.buf, tp)\n             }\n             clean::Self(..) => f.buf.write(\"Self\".as_bytes()),"}, {"sha": "708d3590517e1a2b2a4095e4fef856159399e6fb", "filename": "src/librustdoc/html/layout.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/89b1686bd7db25b5dd948b1a4d9dfd0c68084c29/src%2Flibrustdoc%2Fhtml%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89b1686bd7db25b5dd948b1a4d9dfd0c68084c29/src%2Flibrustdoc%2Fhtml%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Flayout.rs?ref=89b1686bd7db25b5dd948b1a4d9dfd0c68084c29", "patch": "@@ -15,7 +15,7 @@ use std::io;\n pub struct Layout {\n     logo: ~str,\n     favicon: ~str,\n-    crate: ~str,\n+    krate: ~str,\n }\n \n pub struct Page<'a> {\n@@ -37,7 +37,7 @@ pub fn render<T: fmt::Show, S: fmt::Show>(\n \n     <link href='http://fonts.googleapis.com/css?family=Oswald:700|Inconsolata:400'\n           rel='stylesheet' type='text/css'>\n-    <link rel=\\\"stylesheet\\\" type=\\\"text/css\\\" href=\\\"{root_path}{crate}/main.css\\\">\n+    <link rel=\\\"stylesheet\\\" type=\\\"text/css\\\" href=\\\"{root_path}{krate}/main.css\\\">\n \n     {favicon, select, none{} other{<link rel=\\\"shortcut icon\\\" href=\\\"#\\\" />}}\n </head>\n@@ -51,7 +51,7 @@ pub fn render<T: fmt::Show, S: fmt::Show>(\n \n     <section class=\\\"sidebar\\\">\n         {logo, select, none{} other{\n-            <a href='{root_path}{crate}/index.html'><img src='#' alt=''/></a>\n+            <a href='{root_path}{krate}/index.html'><img src='#' alt=''/></a>\n         }}\n \n         {sidebar}\n@@ -77,9 +77,9 @@ pub fn render<T: fmt::Show, S: fmt::Show>(\n     <script>\n         var rootPath = \\\"{root_path}\\\";\n     </script>\n-    <script src=\\\"{root_path}{crate}/jquery.js\\\"></script>\n-    <script src=\\\"{root_path}{crate}/search-index.js\\\"></script>\n-    <script src=\\\"{root_path}{crate}/main.js\\\"></script>\n+    <script src=\\\"{root_path}{krate}/jquery.js\\\"></script>\n+    <script src=\\\"{root_path}{krate}/search-index.js\\\"></script>\n+    <script src=\\\"{root_path}{krate}/main.js\\\"></script>\n \n     <div id=\\\"help\\\" class=\\\"hidden\\\">\n         <div class=\\\"shortcuts\\\">\n@@ -121,7 +121,7 @@ pub fn render<T: fmt::Show, S: fmt::Show>(\n     title     = page.title,\n     favicon   = nonestr(layout.favicon),\n     sidebar   = *sidebar,\n-    crate     = layout.crate,\n+    krate     = layout.krate,\n     )\n }\n "}, {"sha": "29773c60a87e2e1b9c57298cf022cde1e44cf77e", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/89b1686bd7db25b5dd948b1a4d9dfd0c68084c29/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89b1686bd7db25b5dd948b1a4d9dfd0c68084c29/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=89b1686bd7db25b5dd948b1a4d9dfd0c68084c29", "patch": "@@ -195,7 +195,7 @@ local_data_key!(pub cache_key: Arc<Cache>)\n local_data_key!(pub current_location_key: ~[~str])\n \n /// Generates the documentation for `crate` into the directory `dst`\n-pub fn run(mut crate: clean::Crate, dst: Path) -> io::IoResult<()> {\n+pub fn run(mut krate: clean::Crate, dst: Path) -> io::IoResult<()> {\n     let mut cx = Context {\n         dst: dst,\n         current: ~[],\n@@ -204,13 +204,13 @@ pub fn run(mut crate: clean::Crate, dst: Path) -> io::IoResult<()> {\n         layout: layout::Layout {\n             logo: ~\"\",\n             favicon: ~\"\",\n-            crate: crate.name.clone(),\n+            krate: krate.name.clone(),\n         },\n         include_sources: true,\n     };\n     if_ok!(mkdir(&cx.dst));\n \n-    match crate.module.as_ref().map(|m| m.doc_list().unwrap_or(&[])) {\n+    match krate.module.as_ref().map(|m| m.doc_list().unwrap_or(&[])) {\n         Some(attrs) => {\n             for attr in attrs.iter() {\n                 match *attr {\n@@ -243,11 +243,11 @@ pub fn run(mut crate: clean::Crate, dst: Path) -> io::IoResult<()> {\n         extern_locations: HashMap::new(),\n         privmod: false,\n     };\n-    cache.stack.push(crate.name.clone());\n-    crate = cache.fold_crate(crate);\n+    cache.stack.push(krate.name.clone());\n+    krate = cache.fold_crate(krate);\n \n     // Add all the static files\n-    let mut dst = cx.dst.join(crate.name.as_slice());\n+    let mut dst = cx.dst.join(krate.name.as_slice());\n     if_ok!(mkdir(&dst));\n     if_ok!(write(dst.join(\"jquery.js\"),\n                  include_str!(\"static/jquery-2.1.0.min.js\")));\n@@ -295,22 +295,22 @@ pub fn run(mut crate: clean::Crate, dst: Path) -> io::IoResult<()> {\n         info!(\"emitting source files\");\n         let dst = cx.dst.join(\"src\");\n         if_ok!(mkdir(&dst));\n-        let dst = dst.join(crate.name.as_slice());\n+        let dst = dst.join(krate.name.as_slice());\n         if_ok!(mkdir(&dst));\n         let mut folder = SourceCollector {\n             dst: dst,\n             seen: HashSet::new(),\n             cx: &mut cx,\n         };\n-        crate = folder.fold_crate(crate);\n+        krate = folder.fold_crate(krate);\n     }\n \n-    for (&n, e) in crate.externs.iter() {\n+    for (&n, e) in krate.externs.iter() {\n         cache.extern_locations.insert(n, extern_location(e, &cx.dst));\n     }\n \n     // And finally render the whole crate's documentation\n-    cx.crate(crate, cache)\n+    cx.krate(krate, cache)\n }\n \n /// Writes the entire contents of a string to a destination, not attempting to\n@@ -677,12 +677,12 @@ impl Context {\n     ///\n     /// This currently isn't parallelized, but it'd be pretty easy to add\n     /// parallelization to this function.\n-    fn crate(self, mut crate: clean::Crate, cache: Cache) -> io::IoResult<()> {\n-        let mut item = match crate.module.take() {\n+    fn krate(self, mut krate: clean::Crate, cache: Cache) -> io::IoResult<()> {\n+        let mut item = match krate.module.take() {\n             Some(i) => i,\n             None => return Ok(())\n         };\n-        item.name = Some(crate.name);\n+        item.name = Some(krate.name);\n \n         // using a rwarc makes this parallelizable in the future\n         local_data::set(cache_key, Arc::new(cache));\n@@ -827,10 +827,10 @@ impl<'a> fmt::Show for Item<'a> {\n             };\n             if_ok!(write!(fmt.buf,\n                           \"<a class='source'\n-                              href='{root}src/{crate}/{path}.html\\\\#{href}'>\\\n+                              href='{root}src/{krate}/{path}.html\\\\#{href}'>\\\n                               [src]</a>\",\n                           root = self.cx.root_path,\n-                          crate = self.cx.layout.crate,\n+                          krate = self.cx.layout.krate,\n                           path = path.connect(\"/\"),\n                           href = href));\n         }"}, {"sha": "f30e6309f38abf632e2f011a792e8f4a5f97f9b9", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/89b1686bd7db25b5dd948b1a4d9dfd0c68084c29/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89b1686bd7db25b5dd948b1a4d9dfd0c68084c29/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=89b1686bd7db25b5dd948b1a4d9dfd0c68084c29", "patch": "@@ -151,7 +151,7 @@ pub fn main_args(args: &[~str]) -> int {\n         return 0;\n     }\n \n-    let (crate, res) = match acquire_input(input, &matches) {\n+    let (krate, res) = match acquire_input(input, &matches) {\n         Ok(pair) => pair,\n         Err(s) => {\n             println!(\"input error: {}\", s);\n@@ -164,13 +164,13 @@ pub fn main_args(args: &[~str]) -> int {\n     let output = matches.opt_str(\"o\").map(|s| Path::new(s));\n     match matches.opt_str(\"w\") {\n         Some(~\"html\") | None => {\n-            match html::render::run(crate, output.unwrap_or(Path::new(\"doc\"))) {\n+            match html::render::run(krate, output.unwrap_or(Path::new(\"doc\"))) {\n                 Ok(()) => {}\n                 Err(e) => fail!(\"failed to generate documentation: {}\", e),\n             }\n         }\n         Some(~\"json\") => {\n-            match json_output(crate, res, output.unwrap_or(Path::new(\"doc.json\"))) {\n+            match json_output(krate, res, output.unwrap_or(Path::new(\"doc.json\"))) {\n                 Ok(()) => {}\n                 Err(e) => fail!(\"failed to write json: {}\", e),\n             }\n@@ -219,7 +219,7 @@ fn rust_input(cratefile: &str, matches: &getopts::Matches) -> Output {\n     let cfgs = matches.opt_strs(\"cfg\");\n     let cr = Path::new(cratefile);\n     info!(\"starting to run rustc\");\n-    let (crate, analysis) = std::task::try(proc() {\n+    let (krate, analysis) = std::task::try(proc() {\n         let cr = cr;\n         core::run_core(libs.move_iter().collect(), cfgs, &cr)\n     }).unwrap();\n@@ -228,7 +228,7 @@ fn rust_input(cratefile: &str, matches: &getopts::Matches) -> Output {\n \n     // Process all of the crate attributes, extracting plugin metadata along\n     // with the passes which we are supposed to run.\n-    match crate.module.get_ref().doc_list() {\n+    match krate.module.get_ref().doc_list() {\n         Some(nested) => {\n             for inner in nested.iter() {\n                 match *inner {\n@@ -277,7 +277,7 @@ fn rust_input(cratefile: &str, matches: &getopts::Matches) -> Output {\n \n     // Run everything!\n     info!(\"Executing passes/plugins\");\n-    return pm.run_plugins(crate);\n+    return pm.run_plugins(krate);\n }\n \n /// This input format purely deserializes the json output file. No passes are\n@@ -302,7 +302,7 @@ fn json_input(input: &str) -> Result<Output, ~str> {\n                 Some(..) => return Err(~\"malformed json\"),\n                 None => return Err(~\"expected a schema version\"),\n             }\n-            let crate = match obj.pop(&~\"crate\") {\n+            let krate = match obj.pop(&~\"crate\") {\n                 Some(json) => {\n                     let mut d = json::Decoder::new(json);\n                     Decodable::decode(&mut d)\n@@ -312,15 +312,15 @@ fn json_input(input: &str) -> Result<Output, ~str> {\n             // FIXME: this should read from the \"plugins\" field, but currently\n             //      Json doesn't implement decodable...\n             let plugin_output = ~[];\n-            Ok((crate, plugin_output))\n+            Ok((krate, plugin_output))\n         }\n         Ok(..) => Err(~\"malformed json input: expected an object at the top\"),\n     }\n }\n \n /// Outputs the crate/plugin json as a giant json blob at the specified\n /// destination.\n-fn json_output(crate: clean::Crate, res: ~[plugins::PluginJson],\n+fn json_output(krate: clean::Crate, res: ~[plugins::PluginJson],\n                dst: Path) -> io::IoResult<()> {\n     // {\n     //   \"schema\": version,\n@@ -337,7 +337,7 @@ fn json_output(crate: clean::Crate, res: ~[plugins::PluginJson],\n         let mut w = MemWriter::new();\n         {\n             let mut encoder = json::Encoder::new(&mut w as &mut io::Writer);\n-            crate.encode(&mut encoder);\n+            krate.encode(&mut encoder);\n         }\n         str::from_utf8_owned(w.unwrap()).unwrap()\n     };"}, {"sha": "8dd88c5b5300063c092a63f194f950e54935af87", "filename": "src/librustdoc/passes.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/89b1686bd7db25b5dd948b1a4d9dfd0c68084c29/src%2Flibrustdoc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89b1686bd7db25b5dd948b1a4d9dfd0c68084c29/src%2Flibrustdoc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses.rs?ref=89b1686bd7db25b5dd948b1a4d9dfd0c68084c29", "patch": "@@ -21,7 +21,7 @@ use fold;\n use fold::DocFolder;\n \n /// Strip items marked `#[doc(hidden)]`\n-pub fn strip_hidden(crate: clean::Crate) -> plugins::PluginResult {\n+pub fn strip_hidden(krate: clean::Crate) -> plugins::PluginResult {\n     struct Stripper;\n     impl fold::DocFolder for Stripper {\n         fn fold_item(&mut self, i: Item) -> Option<Item> {\n@@ -45,35 +45,35 @@ pub fn strip_hidden(crate: clean::Crate) -> plugins::PluginResult {\n         }\n     }\n     let mut stripper = Stripper;\n-    let crate = stripper.fold_crate(crate);\n-    (crate, None)\n+    let krate = stripper.fold_crate(krate);\n+    (krate, None)\n }\n \n /// Strip private items from the point of view of a crate or externally from a\n /// crate, specified by the `xcrate` flag.\n-pub fn strip_private(crate: clean::Crate) -> plugins::PluginResult {\n+pub fn strip_private(krate: clean::Crate) -> plugins::PluginResult {\n     // This stripper collects all *retained* nodes.\n     let mut retained = HashSet::new();\n     let exported_items = local_data::get(super::analysiskey, |analysis| {\n         analysis.unwrap().exported_items.clone()\n     });\n-    let mut crate = crate;\n+    let mut krate = krate;\n \n     // strip all private items\n     {\n         let mut stripper = Stripper {\n             retained: &mut retained,\n             exported_items: &exported_items,\n         };\n-        crate = stripper.fold_crate(crate);\n+        krate = stripper.fold_crate(krate);\n     }\n \n     // strip all private implementations of traits\n     {\n         let mut stripper = ImplStripper(&retained);\n-        crate = stripper.fold_crate(crate);\n+        krate = stripper.fold_crate(krate);\n     }\n-    (crate, None)\n+    (krate, None)\n }\n \n struct Stripper<'a> {\n@@ -174,7 +174,7 @@ impl<'a> fold::DocFolder for ImplStripper<'a> {\n }\n \n \n-pub fn unindent_comments(crate: clean::Crate) -> plugins::PluginResult {\n+pub fn unindent_comments(krate: clean::Crate) -> plugins::PluginResult {\n     struct CommentCleaner;\n     impl fold::DocFolder for CommentCleaner {\n         fn fold_item(&mut self, i: Item) -> Option<Item> {\n@@ -192,11 +192,11 @@ pub fn unindent_comments(crate: clean::Crate) -> plugins::PluginResult {\n         }\n     }\n     let mut cleaner = CommentCleaner;\n-    let crate = cleaner.fold_crate(crate);\n-    (crate, None)\n+    let krate = cleaner.fold_crate(krate);\n+    (krate, None)\n }\n \n-pub fn collapse_docs(crate: clean::Crate) -> plugins::PluginResult {\n+pub fn collapse_docs(krate: clean::Crate) -> plugins::PluginResult {\n     struct Collapser;\n     impl fold::DocFolder for Collapser {\n         fn fold_item(&mut self, i: Item) -> Option<Item> {\n@@ -223,8 +223,8 @@ pub fn collapse_docs(crate: clean::Crate) -> plugins::PluginResult {\n         }\n     }\n     let mut collapser = Collapser;\n-    let crate = collapser.fold_crate(crate);\n-    (crate, None)\n+    let krate = collapser.fold_crate(krate);\n+    (krate, None)\n }\n \n pub fn unindent(s: &str) -> ~str {"}, {"sha": "2fcf5527a341d2d62dda3cf730e5db6e75ee35ca", "filename": "src/librustdoc/plugins.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/89b1686bd7db25b5dd948b1a4d9dfd0c68084c29/src%2Flibrustdoc%2Fplugins.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89b1686bd7db25b5dd948b1a4d9dfd0c68084c29/src%2Flibrustdoc%2Fplugins.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fplugins.rs?ref=89b1686bd7db25b5dd948b1a4d9dfd0c68084c29", "patch": "@@ -57,15 +57,15 @@ impl PluginManager {\n         self.callbacks.push(plugin);\n     }\n     /// Run all the loaded plugins over the crate, returning their results\n-    pub fn run_plugins(&self, crate: clean::Crate) -> (clean::Crate, ~[PluginJson]) {\n+    pub fn run_plugins(&self, krate: clean::Crate) -> (clean::Crate, ~[PluginJson]) {\n         let mut out_json = ~[];\n-        let mut crate = crate;\n+        let mut krate = krate;\n         for &callback in self.callbacks.iter() {\n-            let (c, res) = callback(crate);\n-            crate = c;\n+            let (c, res) = callback(krate);\n+            krate = c;\n             out_json.push(res);\n         }\n-        (crate, out_json)\n+        (krate, out_json)\n     }\n }\n "}, {"sha": "9f8261b4449b64279446742a80d4d0b0d39d83d5", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/89b1686bd7db25b5dd948b1a4d9dfd0c68084c29/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89b1686bd7db25b5dd948b1a4d9dfd0c68084c29/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=89b1686bd7db25b5dd948b1a4d9dfd0c68084c29", "patch": "@@ -58,31 +58,31 @@ pub fn run(input: &str, matches: &getopts::Matches) -> int {\n                                       span_diagnostic_handler);\n \n     let cfg = driver::build_configuration(sess);\n-    let crate = driver::phase_1_parse_input(sess, cfg, &input);\n+    let krate = driver::phase_1_parse_input(sess, cfg, &input);\n     let loader = &mut Loader::new(sess);\n-    let (crate, _) = driver::phase_2_configure_and_expand(sess, loader, crate);\n+    let (krate, _) = driver::phase_2_configure_and_expand(sess, loader, krate);\n \n     let ctx = @core::DocContext {\n-        crate: crate,\n+        krate: krate,\n         tycx: None,\n         sess: sess,\n     };\n     local_data::set(super::ctxtkey, ctx);\n \n     let mut v = RustdocVisitor::new(ctx, None);\n-    v.visit(&ctx.crate);\n-    let crate = v.clean();\n-    let (crate, _) = passes::unindent_comments(crate);\n-    let (crate, _) = passes::collapse_docs(crate);\n+    v.visit(&ctx.krate);\n+    let krate = v.clean();\n+    let (krate, _) = passes::unindent_comments(krate);\n+    let (krate, _) = passes::collapse_docs(krate);\n \n     let mut collector = Collector {\n         tests: ~[],\n         names: ~[],\n         cnt: 0,\n         libs: libs,\n-        cratename: crate.name.to_owned(),\n+        cratename: krate.name.to_owned(),\n     };\n-    collector.fold_crate(crate);\n+    collector.fold_crate(krate);\n \n     let args = matches.opt_strs(\"test-args\");\n     let mut args = args.iter().flat_map(|s| s.words()).map(|s| s.to_owned());"}, {"sha": "69b740f969d31bb74d5ce5ced9613207b2ee4db5", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/89b1686bd7db25b5dd948b1a4d9dfd0c68084c29/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89b1686bd7db25b5dd948b1a4d9dfd0c68084c29/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=89b1686bd7db25b5dd948b1a4d9dfd0c68084c29", "patch": "@@ -38,12 +38,12 @@ impl<'a> RustdocVisitor<'a> {\n         }\n     }\n \n-    pub fn visit(&mut self, crate: &ast::Crate) {\n-        self.attrs = crate.attrs.clone();\n+    pub fn visit(&mut self, krate: &ast::Crate) {\n+        self.attrs = krate.attrs.clone();\n \n-        self.module = self.visit_mod_contents(crate.span, crate.attrs.clone(),\n+        self.module = self.visit_mod_contents(krate.span, krate.attrs.clone(),\n                                               ast::Public, ast::CRATE_NODE_ID,\n-                                              &crate.module, None);\n+                                              &krate.module, None);\n     }\n \n     pub fn visit_struct_def(&mut self, item: &ast::Item, sd: @ast::StructDef,"}, {"sha": "a5a49b78906309c7b3d55b2a580d6f989ccf0dcf", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/89b1686bd7db25b5dd948b1a4d9dfd0c68084c29/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89b1686bd7db25b5dd948b1a4d9dfd0c68084c29/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=89b1686bd7db25b5dd948b1a4d9dfd0c68084c29", "patch": "@@ -181,7 +181,7 @@ pub type NodeId = u32;\n \n #[deriving(Clone, TotalEq, TotalOrd, Eq, Encodable, Decodable, IterBytes, ToStr)]\n pub struct DefId {\n-    crate: CrateNum,\n+    krate: CrateNum,\n     node: NodeId,\n }\n "}, {"sha": "9d3fe4f0c4d341c27c65d4dfaabe51d784823bd9", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/89b1686bd7db25b5dd948b1a4d9dfd0c68084c29/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89b1686bd7db25b5dd948b1a4d9dfd0c68084c29/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=89b1686bd7db25b5dd948b1a4d9dfd0c68084c29", "patch": "@@ -406,7 +406,7 @@ pub fn map_crate<F: 'static + FoldOps>(diag: @SpanHandler, c: Crate,\n         diag: diag,\n         fold_ops: fold_ops\n     };\n-    let crate = cx.fold_crate(c);\n+    let krate = cx.fold_crate(c);\n \n     if log_enabled!(logging::DEBUG) {\n         let map = cx.map.map.borrow();\n@@ -421,7 +421,7 @@ pub fn map_crate<F: 'static + FoldOps>(diag: @SpanHandler, c: Crate,\n               entries, vector_length, (entries as f64 / vector_length as f64) * 100.);\n     }\n \n-    (crate, cx.map)\n+    (krate, cx.map)\n }\n \n // Used for items loaded from external crate that are being inlined into this"}, {"sha": "5f72a255d718944ef3d622f01829b8501ab9644a", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/89b1686bd7db25b5dd948b1a4d9dfd0c68084c29/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89b1686bd7db25b5dd948b1a4d9dfd0c68084c29/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=89b1686bd7db25b5dd948b1a4d9dfd0c68084c29", "patch": "@@ -38,10 +38,10 @@ pub fn path_to_ident(path: &Path) -> Ident {\n }\n \n pub fn local_def(id: NodeId) -> DefId {\n-    ast::DefId { crate: LOCAL_CRATE, node: id }\n+    ast::DefId { krate: LOCAL_CRATE, node: id }\n }\n \n-pub fn is_local(did: ast::DefId) -> bool { did.crate == LOCAL_CRATE }\n+pub fn is_local(did: ast::DefId) -> bool { did.krate == LOCAL_CRATE }\n \n pub fn stmt_id(s: &Stmt) -> NodeId {\n     match s.node {"}, {"sha": "7ac66ecaa3713c7cb4eae5ec0500c75418ef27c6", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/89b1686bd7db25b5dd948b1a4d9dfd0c68084c29/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89b1686bd7db25b5dd948b1a4d9dfd0c68084c29/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=89b1686bd7db25b5dd948b1a4d9dfd0c68084c29", "patch": "@@ -264,7 +264,7 @@ pub struct MacroCrate {\n }\n \n pub trait CrateLoader {\n-    fn load_crate(&mut self, crate: &ast::ViewItem) -> MacroCrate;\n+    fn load_crate(&mut self, krate: &ast::ViewItem) -> MacroCrate;\n     fn get_exported_macros(&mut self, crate_num: ast::CrateNum) -> ~[~str];\n     fn get_registrar_symbol(&mut self, crate_num: ast::CrateNum) -> Option<~str>;\n }"}, {"sha": "d96fc27f3ddfe3bd1b3dd55a28ba701c93b6a8c6", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/89b1686bd7db25b5dd948b1a4d9dfd0c68084c29/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89b1686bd7db25b5dd948b1a4d9dfd0c68084c29/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=89b1686bd7db25b5dd948b1a4d9dfd0c68084c29", "patch": "@@ -414,10 +414,10 @@ pub fn expand_view_item(vi: &ast::ViewItem,\n     noop_fold_view_item(vi, fld)\n }\n \n-fn load_extern_macros(crate: &ast::ViewItem, fld: &mut MacroExpander) {\n-    let MacroCrate { lib, cnum } = fld.cx.loader.load_crate(crate);\n+fn load_extern_macros(krate: &ast::ViewItem, fld: &mut MacroExpander) {\n+    let MacroCrate { lib, cnum } = fld.cx.loader.load_crate(krate);\n \n-    let crate_name = match crate.node {\n+    let crate_name = match krate.node {\n         ast::ViewItemExternMod(ref name, _, _) => {\n             let string = token::get_ident(name.name);\n             string.get().to_str()\n@@ -453,19 +453,19 @@ fn load_extern_macros(crate: &ast::ViewItem, fld: &mut MacroExpander) {\n         // this is fatal: there are almost certainly macros we need\n         // inside this crate, so continue would spew \"macro undefined\"\n         // errors\n-        Err(err) => fld.cx.span_fatal(crate.span, err)\n+        Err(err) => fld.cx.span_fatal(krate.span, err)\n     };\n \n     unsafe {\n         let registrar: MacroCrateRegistrationFun = match lib.symbol(registrar) {\n             Ok(registrar) => registrar,\n             // again fatal if we can't register macros\n-            Err(err) => fld.cx.span_fatal(crate.span, err)\n+            Err(err) => fld.cx.span_fatal(krate.span, err)\n         };\n         registrar(|name, extension| {\n             let extension = match extension {\n-                NormalTT(ext, _) => NormalTT(ext, Some(crate.span)),\n-                IdentTT(ext, _) => IdentTT(ext, Some(crate.span)),\n+                NormalTT(ext, _) => NormalTT(ext, Some(krate.span)),\n+                IdentTT(ext, _) => IdentTT(ext, Some(krate.span)),\n                 ItemDecorator(ext) => ItemDecorator(ext),\n             };\n             fld.extsbox.insert(name, extension);\n@@ -1036,10 +1036,10 @@ mod test {\n         }\n     }\n \n-    //fn fake_print_crate(crate: &ast::Crate) {\n+    //fn fake_print_crate(krate: &ast::Crate) {\n     //    let mut out = ~std::io::stderr() as ~std::io::Writer;\n     //    let mut s = pprust::rust_printer(out, get_ident_interner());\n-    //    pprust::print_crate_(&mut s, crate);\n+    //    pprust::print_crate_(&mut s, krate);\n     //}\n \n     fn expand_crate_str(crate_str: ~str) -> ast::Crate {"}, {"sha": "f0bad1b40ebbd675acdd36491b490e0ba75b4ced", "filename": "src/libsyntax/ext/registrar.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/89b1686bd7db25b5dd948b1a4d9dfd0c68084c29/src%2Flibsyntax%2Fext%2Fregistrar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89b1686bd7db25b5dd948b1a4d9dfd0c68084c29/src%2Flibsyntax%2Fext%2Fregistrar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fregistrar.rs?ref=89b1686bd7db25b5dd948b1a4d9dfd0c68084c29", "patch": "@@ -35,16 +35,16 @@ impl Visitor<()> for MacroRegistrarContext {\n }\n \n pub fn find_macro_registrar(diagnostic: @diagnostic::SpanHandler,\n-                            crate: &ast::Crate) -> Option<ast::DefId> {\n+                            krate: &ast::Crate) -> Option<ast::DefId> {\n     let mut ctx = MacroRegistrarContext { registrars: ~[] };\n-    visit::walk_crate(&mut ctx, crate, ());\n+    visit::walk_crate(&mut ctx, krate, ());\n \n     match ctx.registrars.len() {\n         0 => None,\n         1 => {\n             let (node_id, _) = ctx.registrars.pop().unwrap();\n             Some(ast::DefId {\n-                crate: ast::LOCAL_CRATE,\n+                krate: ast::LOCAL_CRATE,\n                 node: node_id\n             })\n         },"}, {"sha": "1b14bd72382c558cb580f91f9337ba066d41279f", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/89b1686bd7db25b5dd948b1a4d9dfd0c68084c29/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89b1686bd7db25b5dd948b1a4d9dfd0c68084c29/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=89b1686bd7db25b5dd948b1a4d9dfd0c68084c29", "patch": "@@ -859,8 +859,8 @@ mod test {\n \n     // this version doesn't care about getting comments or docstrings in.\n     fn fake_print_crate(s: &mut pprust::State,\n-                        crate: &ast::Crate) -> io::IoResult<()> {\n-        pprust::print_mod(s, &crate.module, crate.attrs)\n+                        krate: &ast::Crate) -> io::IoResult<()> {\n+        pprust::print_mod(s, &krate.module, krate.attrs)\n     }\n \n     // change every identifier to \"zz\""}, {"sha": "24227dea531f8cb9efbe59a588838ddbfa862c04", "filename": "src/libsyntax/parse/obsolete.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/89b1686bd7db25b5dd948b1a4d9dfd0c68084c29/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89b1686bd7db25b5dd948b1a4d9dfd0c68084c29/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fobsolete.rs?ref=89b1686bd7db25b5dd948b1a4d9dfd0c68084c29", "patch": "@@ -30,7 +30,6 @@ pub enum ObsoleteSyntax {\n     ObsoleteSwap,\n     ObsoleteUnsafeBlock,\n     ObsoleteBareFnType,\n-    ObsoleteNamedExternModule,\n     ObsoleteMultipleLocalDecl,\n     ObsoleteUnsafeExternFn,\n     ObsoleteTraitFuncVisibility,\n@@ -42,7 +41,6 @@ pub enum ObsoleteSyntax {\n     ObsoleteBoxedClosure,\n     ObsoleteClosureType,\n     ObsoleteMultipleImport,\n-    ObsoleteExternModAttributesInParens,\n     ObsoleteManagedPattern,\n     ObsoleteManagedString,\n     ObsoleteManagedVec,\n@@ -86,11 +84,6 @@ impl ParserObsoleteMethods for Parser {\n                 \"bare function type\",\n                 \"use `|A| -> B` or `extern fn(A) -> B` instead\"\n             ),\n-            ObsoleteNamedExternModule => (\n-                \"named external module\",\n-                \"instead of `extern mod foo { ... }`, write `mod foo { \\\n-                 extern { ... } }`\"\n-            ),\n             ObsoleteMultipleLocalDecl => (\n                 \"declaration of multiple locals at once\",\n                 \"instead of e.g. `let a = 1, b = 2`, write \\\n@@ -141,11 +134,6 @@ impl ParserObsoleteMethods for Parser {\n                 \"multiple imports\",\n                 \"only one import is allowed per `use` statement\"\n             ),\n-            ObsoleteExternModAttributesInParens => (\n-                \"`extern mod` with linkage attribute list\",\n-                \"use `extern mod foo = \\\"bar\\\";` instead of \\\n-                `extern mod foo (name = \\\"bar\\\")`\"\n-            ),\n             ObsoleteManagedPattern => (\n                 \"managed pointer pattern\",\n                 \"use a nested `match` expression instead of a managed box \\"}, {"sha": "15608a0f28e9ac72dbd76c981706d6c2a6b22a53", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 81, "deletions": 79, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/89b1686bd7db25b5dd948b1a4d9dfd0c68084c29/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89b1686bd7db25b5dd948b1a4d9dfd0c68084c29/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=89b1686bd7db25b5dd948b1a4d9dfd0c68084c29", "patch": "@@ -866,7 +866,10 @@ impl Parser {\n \n         */\n \n-        let opt_abis = self.parse_opt_abis();\n+        let opt_abis = if self.eat_keyword(keywords::Extern) {\n+            self.parse_opt_abis()\n+        } else { None };\n+\n         let abis = opt_abis.unwrap_or(AbiSet::Rust());\n         let purity = self.parse_unsafety();\n         self.expect_keyword(keywords::Fn);\n@@ -4308,91 +4311,78 @@ impl Parser {\n         }\n     }\n \n-    // parse extern foo; or extern mod foo { ... } or extern { ... }\n-    fn parse_item_foreign_mod(&mut self,\n-                              lo: BytePos,\n-                              opt_abis: Option<AbiSet>,\n-                              visibility: Visibility,\n-                              attrs: ~[Attribute],\n-                              items_allowed: bool)\n-                              -> ItemOrViewItem {\n-        let mut must_be_named_mod = false;\n-        if self.is_keyword(keywords::Mod) {\n-            must_be_named_mod = true;\n-            self.expect_keyword(keywords::Mod);\n-        } else if self.token != token::LBRACE {\n-            let token_str = self.this_token_to_str();\n-            self.span_fatal(self.span,\n-                            format!(\"expected `\\\\{` or `mod` but found `{}`\",\n-                                    token_str))\n-        }\n+    /// Parse extern crate links\n+    ///\n+    /// # Example\n+    ///\n+    /// extern crate extra;\n+    /// extern crate foo = \"bar\";\n+    fn parse_item_extern_crate(&mut self,\n+                                lo: BytePos,\n+                                visibility: Visibility,\n+                                attrs: ~[Attribute])\n+                                -> ItemOrViewItem {\n \n-        let (named, maybe_path, ident) = match self.token {\n+        let (maybe_path, ident) = match self.token {\n             token::IDENT(..) => {\n                 let the_ident = self.parse_ident();\n+                self.expect_one_of(&[], &[token::EQ, token::SEMI]);\n                 let path = if self.token == token::EQ {\n                     self.bump();\n                     Some(self.parse_str())\n-                }\n-                else { None };\n-                (true, path, the_ident)\n+                } else {None};\n+\n+                self.expect(&token::SEMI);\n+                (path, the_ident)\n             }\n             _ => {\n-                if must_be_named_mod {\n-                    let token_str = self.this_token_to_str();\n-                    self.span_fatal(self.span,\n-                                    format!(\"expected foreign module name but \\\n-                                             found `{}`\",\n-                                            token_str))\n-                }\n-\n-                (false, None,\n-                 special_idents::clownshoes_foreign_mod)\n+                let token_str = self.this_token_to_str();\n+                self.span_fatal(self.span,\n+                                format!(\"expected extern crate name but found `{}`\",\n+                                        token_str));\n             }\n         };\n \n-        // extern mod foo { ... } or extern { ... }\n-        if items_allowed && self.eat(&token::LBRACE) {\n-            // `extern mod foo { ... }` is obsolete.\n-            if named {\n-                self.obsolete(self.last_span, ObsoleteNamedExternModule);\n-            }\n-\n-            let abis = opt_abis.unwrap_or(AbiSet::C());\n+        IoviViewItem(ast::ViewItem {\n+                node: ViewItemExternMod(ident, maybe_path, ast::DUMMY_NODE_ID),\n+                attrs: attrs,\n+                vis: visibility,\n+                span: mk_sp(lo, self.last_span.hi)\n+            })\n+    }\n \n-            let (inner, next) = self.parse_inner_attrs_and_next();\n-            let m = self.parse_foreign_mod_items(abis, next);\n-            self.expect(&token::RBRACE);\n+    /// Parse `extern` for foreign ABIs\n+    /// modules.\n+    ///\n+    /// `extern` is expected to have been\n+    /// consumed before calling this method\n+    ///\n+    /// # Examples:\n+    ///\n+    /// extern \"C\" {}\n+    /// extern {}\n+    fn parse_item_foreign_mod(&mut self,\n+                              lo: BytePos,\n+                              opt_abis: Option<AbiSet>,\n+                              visibility: Visibility,\n+                              attrs: ~[Attribute])\n+                              -> ItemOrViewItem {\n \n-            let item = self.mk_item(lo,\n-                                    self.last_span.hi,\n-                                    ident,\n-                                    ItemForeignMod(m),\n-                                    visibility,\n-                                    maybe_append(attrs, Some(inner)));\n-            return IoviItem(item);\n-        }\n+        self.expect(&token::LBRACE);\n \n-        if opt_abis.is_some() {\n-            self.span_err(self.span, \"an ABI may not be specified here\");\n-        }\n+        let abis = opt_abis.unwrap_or(AbiSet::C());\n \n+        let (inner, next) = self.parse_inner_attrs_and_next();\n+        let m = self.parse_foreign_mod_items(abis, next);\n+        self.expect(&token::RBRACE);\n \n-        if self.token == token::LPAREN {\n-            // `extern mod foo (name = \"bar\"[,vers = \"version\"]) is obsolete,\n-            // `extern mod foo = \"bar#[version]\";` should be used.\n-            // Parse obsolete options to avoid wired parser errors\n-            self.parse_optional_meta();\n-            self.obsolete(self.span, ObsoleteExternModAttributesInParens);\n-        }\n-        // extern mod foo;\n-        self.expect(&token::SEMI);\n-        IoviViewItem(ast::ViewItem {\n-            node: ViewItemExternMod(ident, maybe_path, ast::DUMMY_NODE_ID),\n-            attrs: attrs,\n-            vis: visibility,\n-            span: mk_sp(lo, self.last_span.hi)\n-        })\n+        let item = self.mk_item(lo,\n+                                self.last_span.hi,\n+                                special_idents::clownshoes_foreign_mod,\n+                                ItemForeignMod(m),\n+                                visibility,\n+                                maybe_append(attrs, Some(inner)));\n+        return IoviItem(item);\n     }\n \n     // parse type Foo = Bar;\n@@ -4504,10 +4494,6 @@ impl Parser {\n     // Parses a string as an ABI spec on an extern type or module. Consumes\n     // the `extern` keyword, if one is found.\n     fn parse_opt_abis(&mut self) -> Option<AbiSet> {\n-        if !self.eat_keyword(keywords::Extern) {\n-            return None\n-        }\n-\n         match self.token {\n             token::LIT_STR(s)\n             | token::LIT_STR_RAW(s, _) => {\n@@ -4585,7 +4571,20 @@ impl Parser {\n             });\n         }\n         // either a view item or an item:\n-        if self.is_keyword(keywords::Extern) {\n+        if self.eat_keyword(keywords::Extern) {\n+            let next_is_mod = self.eat_keyword(keywords::Mod);\n+\n+            if next_is_mod || self.eat_keyword(keywords::Crate) {\n+                // NOTE(flaper87): Uncomment this when this changes gets into stage0\n+                //\n+                // if next_is_mod {\n+                //    self.span_err(self.span,\n+                //                   format!(\"`extern mod` is obsolete, use `extern crate` instead \\\n+                //                           to refer to external crates.\"))\n+                // }\n+                return self.parse_item_extern_crate(lo, visibility, attrs);\n+            }\n+\n             let opt_abis = self.parse_opt_abis();\n \n             if self.eat_keyword(keywords::Fn) {\n@@ -4600,12 +4599,15 @@ impl Parser {\n                                         visibility,\n                                         maybe_append(attrs, extra_attrs));\n                 return IoviItem(item);\n-            } else  {\n-                // EXTERN MODULE ITEM (IoviViewItem)\n-                return self.parse_item_foreign_mod(lo, opt_abis, visibility, attrs,\n-                                                   true);\n+            } else if self.token == token::LBRACE {\n+                return self.parse_item_foreign_mod(lo, opt_abis, visibility, attrs);\n             }\n+\n+            let token_str = self.this_token_to_str();\n+            self.span_fatal(self.span,\n+                            format!(\"expected `\\\\{` or `fn` but found `{}`\", token_str));\n         }\n+\n         // the rest are all guaranteed to be items:\n         if self.is_keyword(keywords::Static) {\n             // STATIC ITEM"}, {"sha": "423ddb828083c1cd0276f37b3e1c5851268875ba", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 27, "deletions": 26, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/89b1686bd7db25b5dd948b1a4d9dfd0c68084c29/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89b1686bd7db25b5dd948b1a4d9dfd0c68084c29/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=89b1686bd7db25b5dd948b1a4d9dfd0c68084c29", "patch": "@@ -462,37 +462,38 @@ declare_special_idents_and_keywords! {\n         (28,                         Loop,       \"loop\");\n         (29,                         Match,      \"match\");\n         (30,                         Mod,        \"mod\");\n-        (31,                         Mut,        \"mut\");\n-        (32,                         Once,       \"once\");\n-        (33,                         Priv,       \"priv\");\n-        (34,                         Pub,        \"pub\");\n-        (35,                         Ref,        \"ref\");\n-        (36,                         Return,     \"return\");\n+        (31,                         Crate,      \"crate\");\n+        (32,                         Mut,        \"mut\");\n+        (33,                         Once,       \"once\");\n+        (34,                         Priv,       \"priv\");\n+        (35,                         Pub,        \"pub\");\n+        (36,                         Ref,        \"ref\");\n+        (37,                         Return,     \"return\");\n         // Static and Self are also special idents (prefill de-dupes)\n         (super::STATIC_KEYWORD_NAME, Static,     \"static\");\n         (super::SELF_KEYWORD_NAME,   Self,       \"self\");\n-        (37,                         Struct,     \"struct\");\n-        (38,                         Super,      \"super\");\n-        (39,                         True,       \"true\");\n-        (40,                         Trait,      \"trait\");\n-        (41,                         Type,       \"type\");\n-        (42,                         Unsafe,     \"unsafe\");\n-        (43,                         Use,        \"use\");\n-        (44,                         While,      \"while\");\n-        (45,                         Continue,   \"continue\");\n-        (46,                         Proc,       \"proc\");\n-        (47,                         Box,        \"box\");\n+        (38,                         Struct,     \"struct\");\n+        (39,                         Super,      \"super\");\n+        (40,                         True,       \"true\");\n+        (41,                         Trait,      \"trait\");\n+        (42,                         Type,       \"type\");\n+        (43,                         Unsafe,     \"unsafe\");\n+        (44,                         Use,        \"use\");\n+        (45,                         While,      \"while\");\n+        (46,                         Continue,   \"continue\");\n+        (47,                         Proc,       \"proc\");\n+        (48,                         Box,        \"box\");\n \n         'reserved:\n-        (48,                         Alignof,    \"alignof\");\n-        (49,                         Be,         \"be\");\n-        (50,                         Offsetof,   \"offsetof\");\n-        (51,                         Pure,       \"pure\");\n-        (52,                         Sizeof,     \"sizeof\");\n-        (53,                         Typeof,     \"typeof\");\n-        (54,                         Unsized,    \"unsized\");\n-        (55,                         Yield,      \"yield\");\n-        (56,                         Do,         \"do\");\n+        (49,                         Alignof,    \"alignof\");\n+        (50,                         Be,         \"be\");\n+        (51,                         Offsetof,   \"offsetof\");\n+        (52,                         Pure,       \"pure\");\n+        (53,                         Sizeof,     \"sizeof\");\n+        (54,                         Typeof,     \"typeof\");\n+        (55,                         Unsized,    \"unsized\");\n+        (56,                         Yield,      \"yield\");\n+        (57,                         Do,         \"do\");\n     }\n }\n "}, {"sha": "24aa30cb36ba82334c207a7c155d3270f780faf5", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/89b1686bd7db25b5dd948b1a4d9dfd0c68084c29/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89b1686bd7db25b5dd948b1a4d9dfd0c68084c29/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=89b1686bd7db25b5dd948b1a4d9dfd0c68084c29", "patch": "@@ -116,7 +116,7 @@ pub static default_columns: uint = 78u;\n pub fn print_crate(cm: @CodeMap,\n                    intr: @IdentInterner,\n                    span_diagnostic: @diagnostic::SpanHandler,\n-                   crate: &ast::Crate,\n+                   krate: &ast::Crate,\n                    filename: ~str,\n                    input: &mut io::Reader,\n                    out: ~io::Writer,\n@@ -147,11 +147,11 @@ pub fn print_crate(cm: @CodeMap,\n         boxes: RefCell::new(~[]),\n         ann: ann\n     };\n-    print_crate_(&mut s, crate)\n+    print_crate_(&mut s, krate)\n }\n \n-pub fn print_crate_(s: &mut State, crate: &ast::Crate) -> io::IoResult<()> {\n-    if_ok!(print_mod(s, &crate.module, crate.attrs));\n+pub fn print_crate_(s: &mut State, krate: &ast::Crate) -> io::IoResult<()> {\n+    if_ok!(print_mod(s, &krate.module, krate.attrs));\n     if_ok!(print_remaining_comments(s));\n     if_ok!(eof(&mut s.s));\n     Ok(())"}, {"sha": "e1fe43b8e047de2de960884c62b42e433bde5605", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/89b1686bd7db25b5dd948b1a4d9dfd0c68084c29/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89b1686bd7db25b5dd948b1a4d9dfd0c68084c29/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=89b1686bd7db25b5dd948b1a4d9dfd0c68084c29", "patch": "@@ -132,8 +132,8 @@ pub fn walk_inlined_item<E: Clone, V: Visitor<E>>(visitor: &mut V,\n }\n \n \n-pub fn walk_crate<E: Clone, V: Visitor<E>>(visitor: &mut V, crate: &Crate, env: E) {\n-    visitor.visit_mod(&crate.module, crate.span, CRATE_NODE_ID, env)\n+pub fn walk_crate<E: Clone, V: Visitor<E>>(visitor: &mut V, krate: &Crate, env: E) {\n+    visitor.visit_mod(&krate.module, krate.span, CRATE_NODE_ID, env)\n }\n \n pub fn walk_mod<E: Clone, V: Visitor<E>>(visitor: &mut V, module: &Mod, env: E) {"}, {"sha": "638253f816ac6642458abb549636997f4c462ce1", "filename": "src/test/compile-fail/extern-expected-fn-or-brace.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/89b1686bd7db25b5dd948b1a4d9dfd0c68084c29/src%2Ftest%2Fcompile-fail%2Fextern-expected-fn-or-brace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89b1686bd7db25b5dd948b1a4d9dfd0c68084c29/src%2Ftest%2Fcompile-fail%2Fextern-expected-fn-or-brace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fextern-expected-fn-or-brace.rs?ref=89b1686bd7db25b5dd948b1a4d9dfd0c68084c29", "patch": "@@ -0,0 +1,14 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Verifies that the expected token errors for `extern crate` are\n+// raised\n+\n+extern \"C\" mod foo; //~ERROR expected `{` or `fn` but found `mod`"}, {"sha": "ffa6ffb042fe9ad64d020de16d4bc5669c5a313c", "filename": "src/test/compile-fail/extern-foreign-crate.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/89b1686bd7db25b5dd948b1a4d9dfd0c68084c29/src%2Ftest%2Fcompile-fail%2Fextern-foreign-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89b1686bd7db25b5dd948b1a4d9dfd0c68084c29/src%2Ftest%2Fcompile-fail%2Fextern-foreign-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fextern-foreign-crate.rs?ref=89b1686bd7db25b5dd948b1a4d9dfd0c68084c29", "patch": "@@ -0,0 +1,14 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Verifies that the expected token errors for `extern crate` are\n+// raised\n+\n+extern crate foo {} //~ERROR expected one of `=`, `;` but found `{`"}, {"sha": "9fe5e2031bbf56e67feabd4f0ccd1d3096692a1a", "filename": "src/test/compile-fail/obsolete-syntax.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/89b1686bd7db25b5dd948b1a4d9dfd0c68084c29/src%2Ftest%2Fcompile-fail%2Fobsolete-syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89b1686bd7db25b5dd948b1a4d9dfd0c68084c29/src%2Ftest%2Fcompile-fail%2Fobsolete-syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fobsolete-syntax.rs?ref=89b1686bd7db25b5dd948b1a4d9dfd0c68084c29", "patch": "@@ -8,11 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-extern mod obsolete_name {\n-    //~^ ERROR obsolete syntax: named external module\n-    fn bar();\n-}\n-\n trait A {\n     pub fn foo(); //~ ERROR: visibility not necessary\n     pub fn bar(); //~ ERROR: visibility not necessary"}, {"sha": "8949734b80e484f80729ba8eb5ed573462e55c83", "filename": "src/test/run-pass/extern-foreign-crate.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/89b1686bd7db25b5dd948b1a4d9dfd0c68084c29/src%2Ftest%2Frun-pass%2Fextern-foreign-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89b1686bd7db25b5dd948b1a4d9dfd0c68084c29/src%2Ftest%2Frun-pass%2Fextern-foreign-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-foreign-crate.rs?ref=89b1686bd7db25b5dd948b1a4d9dfd0c68084c29", "patch": "@@ -0,0 +1,14 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+extern crate extra;\n+extern mod mystd = \"std\";\n+\n+pub fn main() {}"}]}