{"sha": "24a7a010d1015731418852d893d889f4bcbdeb51", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI0YTdhMDEwZDEwMTU3MzE0MTg4NTJkODkzZDg4OWY0YmNiZGViNTE=", "commit": {"author": {"name": "David Wood", "email": "david@davidtw.co", "date": "2018-11-16T21:56:18Z"}, "committer": {"name": "David Wood", "email": "david@davidtw.co", "date": "2018-12-30T13:25:20Z"}, "message": "Refactor `UserTypeAnnotation`.\n\nThis commit refactors the `UserTypeAnnotation` type to be referred to by\nan index within `UserTypeProjection`. `UserTypeAnnotation` is instead\nkept in an `IndexVec` within the `Mir` struct.\n\nFurther, instead of `UserTypeAnnotation` containing canonicalized types,\nit now contains normal types and the entire `UserTypeAnnotation` is\ncanonicalized. To support this, the type was moved from the `rustc::mir`\nmodule to `rustc::ty` module.", "tree": {"sha": "88f576b3734b605cec00ba83114c22a038e627ae", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/88f576b3734b605cec00ba83114c22a038e627ae"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/24a7a010d1015731418852d893d889f4bcbdeb51", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEEWwgxPGhT5b/6kagXAXYLT59T8VQFAlwox0AACgkQAXYLT59T\n8VQL7A//fbhWnCHqEyk16ZvfGt7TItoQexCiaTyEaDG9ln9StOjZa8J+IiDD57JY\n+m9WbenauvJfGpPuGUhG0sT7JO/znXsClr6PcP2vHrmMd5jmKVDyp8PE0Yh0hwlC\nTHUW78zwbccaFJ3F+Kqyoq8HTHensL91kTvu08jE2pf3cFfKxYxcyG2TvpKGv3os\nJ7pdDk31pfN6ZYYEMxE8nlSlbLiFNKsCkI66XQaXX0HXYsnCRCwpXKR67+TEjuWw\ndSzRA4EFIExqLjwFaraMS7OE9RPNBKOV8VYzo51ah6S1gEW0+cqbGptS79VYGVaL\nx+TX/MYGx7oh/Td0PJpxJW8bpeP3Q0qGRLFP0FBqHGtpQmIinmObs08uQJXraDPx\nsIyqE1/k2Vd1mKFa8NMFE36CNETSG118hjCJKh/f7VCH0bJ71QJHIHJBgC73nmbe\nrP8ecFUFdKNzONs43elfohJlRdTEEq1M56CTH5BTGgkBeIxlMewQ0zhphkVmPJWT\nLfm1BCsPJdVI57Vh8R56waJD8LxxOQ+kRiqbt4sZYHY2UOu4TGXJ9z2HTsq3dgHI\nJaRem9Dp7K/DqTRDMU8C3gNOs0WXXZ1c+BI5isTGOzPKIYch//0gpnj/ESFJenfb\nEz6hUt8Suk+HYUK1GI/Uo7HzQrCJcFIWQntK7jIw75AcfQORgks=\n=NcZU\n-----END PGP SIGNATURE-----", "payload": "tree 88f576b3734b605cec00ba83114c22a038e627ae\nparent 7155690ffcdf2ce325361bdb5b64ad69c043662f\nauthor David Wood <david@davidtw.co> 1542405378 +0100\ncommitter David Wood <david@davidtw.co> 1546176320 +0100\n\nRefactor `UserTypeAnnotation`.\n\nThis commit refactors the `UserTypeAnnotation` type to be referred to by\nan index within `UserTypeProjection`. `UserTypeAnnotation` is instead\nkept in an `IndexVec` within the `Mir` struct.\n\nFurther, instead of `UserTypeAnnotation` containing canonicalized types,\nit now contains normal types and the entire `UserTypeAnnotation` is\ncanonicalized. To support this, the type was moved from the `rustc::mir`\nmodule to `rustc::ty` module.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/24a7a010d1015731418852d893d889f4bcbdeb51", "html_url": "https://github.com/rust-lang/rust/commit/24a7a010d1015731418852d893d889f4bcbdeb51", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/24a7a010d1015731418852d893d889f4bcbdeb51/comments", "author": {"login": "davidtwco", "id": 1295100, "node_id": "MDQ6VXNlcjEyOTUxMDA=", "avatar_url": "https://avatars.githubusercontent.com/u/1295100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidtwco", "html_url": "https://github.com/davidtwco", "followers_url": "https://api.github.com/users/davidtwco/followers", "following_url": "https://api.github.com/users/davidtwco/following{/other_user}", "gists_url": "https://api.github.com/users/davidtwco/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidtwco/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidtwco/subscriptions", "organizations_url": "https://api.github.com/users/davidtwco/orgs", "repos_url": "https://api.github.com/users/davidtwco/repos", "events_url": "https://api.github.com/users/davidtwco/events{/privacy}", "received_events_url": "https://api.github.com/users/davidtwco/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidtwco", "id": 1295100, "node_id": "MDQ6VXNlcjEyOTUxMDA=", "avatar_url": "https://avatars.githubusercontent.com/u/1295100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidtwco", "html_url": "https://github.com/davidtwco", "followers_url": "https://api.github.com/users/davidtwco/followers", "following_url": "https://api.github.com/users/davidtwco/following{/other_user}", "gists_url": "https://api.github.com/users/davidtwco/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidtwco/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidtwco/subscriptions", "organizations_url": "https://api.github.com/users/davidtwco/orgs", "repos_url": "https://api.github.com/users/davidtwco/repos", "events_url": "https://api.github.com/users/davidtwco/events{/privacy}", "received_events_url": "https://api.github.com/users/davidtwco/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7155690ffcdf2ce325361bdb5b64ad69c043662f", "url": "https://api.github.com/repos/rust-lang/rust/commits/7155690ffcdf2ce325361bdb5b64ad69c043662f", "html_url": "https://github.com/rust-lang/rust/commit/7155690ffcdf2ce325361bdb5b64ad69c043662f"}], "stats": {"total": 831, "additions": 476, "deletions": 355}, "files": [{"sha": "002ac7cc7a9bba8dac6908b9daa4e7573d243068", "filename": "src/librustc/ich/impls_mir.rs", "status": "modified", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/24a7a010d1015731418852d893d889f4bcbdeb51/src%2Flibrustc%2Fich%2Fimpls_mir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24a7a010d1015731418852d893d889f4bcbdeb51/src%2Flibrustc%2Fich%2Fimpls_mir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_mir.rs?ref=24a7a010d1015731418852d893d889f4bcbdeb51", "patch": "@@ -494,22 +494,5 @@ impl<'a, 'gcx> HashStable<StableHashingContext<'a>> for mir::ClosureOutlivesSubj\n \n impl_stable_hash_for!(struct mir::interpret::GlobalId<'tcx> { instance, promoted });\n \n-impl<'a, 'gcx> HashStable<StableHashingContext<'a>> for mir::UserTypeAnnotation<'gcx> {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n-        mem::discriminant(self).hash_stable(hcx, hasher);\n-        match *self {\n-            mir::UserTypeAnnotation::Ty(ref ty) => {\n-                ty.hash_stable(hcx, hasher);\n-            }\n-            mir::UserTypeAnnotation::TypeOf(ref def_id, ref substs) => {\n-                def_id.hash_stable(hcx, hasher);\n-                substs.hash_stable(hcx, hasher);\n-            }\n-        }\n-    }\n-}\n-\n impl_stable_hash_for!(struct mir::UserTypeProjection<'tcx> { base, projs });\n impl_stable_hash_for!(struct mir::UserTypeProjections<'tcx> { contents });"}, {"sha": "b2fe4b7561c5a74cf76724178dc07c3510350012", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/24a7a010d1015731418852d893d889f4bcbdeb51/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24a7a010d1015731418852d893d889f4bcbdeb51/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=24a7a010d1015731418852d893d889f4bcbdeb51", "patch": "@@ -1251,3 +1251,29 @@ impl_stable_hash_for!(\n         goal,\n     }\n );\n+\n+impl<'a, 'gcx> HashStable<StableHashingContext<'a>> for ty::UserTypeAnnotation<'gcx> {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a>,\n+                                          hasher: &mut StableHasher<W>) {\n+        mem::discriminant(self).hash_stable(hcx, hasher);\n+        match *self {\n+            ty::UserTypeAnnotation::Ty(ref ty) => {\n+                ty.hash_stable(hcx, hasher);\n+            }\n+            ty::UserTypeAnnotation::TypeOf(ref def_id, ref substs) => {\n+                def_id.hash_stable(hcx, hasher);\n+                substs.hash_stable(hcx, hasher);\n+            }\n+        }\n+    }\n+}\n+\n+impl<'a> HashStable<StableHashingContext<'a>> for ty::UserTypeAnnotationIndex {\n+    #[inline]\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a>,\n+                                          hasher: &mut StableHasher<W>) {\n+        self.index().hash_stable(hcx, hasher);\n+    }\n+}"}, {"sha": "ecbe14c093f409d78e59bd8ebe101f22cd833edb", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 17, "deletions": 33, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/24a7a010d1015731418852d893d889f4bcbdeb51/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24a7a010d1015731418852d893d889f4bcbdeb51/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=24a7a010d1015731418852d893d889f4bcbdeb51", "patch": "@@ -27,9 +27,12 @@ use syntax::ast::{self, Name};\n use syntax::symbol::InternedString;\n use syntax_pos::{Span, DUMMY_SP};\n use ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n-use ty::subst::{CanonicalUserSubsts, Subst, Substs};\n-use ty::{self, AdtDef, CanonicalTy, ClosureSubsts, GeneratorSubsts, Region, Ty, TyCtxt};\n+use ty::subst::{Subst, Substs};\n use ty::layout::VariantIdx;\n+use ty::{\n+    self, AdtDef, CanonicalUserTypeAnnotations, ClosureSubsts, GeneratorSubsts, Region, Ty, TyCtxt,\n+    UserTypeAnnotationIndex, UserTypeAnnotation,\n+};\n use util::ppaux;\n \n pub use mir::interpret::AssertMessage;\n@@ -121,6 +124,9 @@ pub struct Mir<'tcx> {\n     /// variables and temporaries.\n     pub local_decls: LocalDecls<'tcx>,\n \n+    /// User type annotations\n+    pub user_type_annotations: CanonicalUserTypeAnnotations<'tcx>,\n+\n     /// Number of arguments this function takes.\n     ///\n     /// Starting at local 1, `arg_count` locals will be provided by the caller\n@@ -161,7 +167,8 @@ impl<'tcx> Mir<'tcx> {\n         source_scope_local_data: ClearCrossCrate<IndexVec<SourceScope, SourceScopeLocalData>>,\n         promoted: IndexVec<Promoted, Mir<'tcx>>,\n         yield_ty: Option<Ty<'tcx>>,\n-        local_decls: IndexVec<Local, LocalDecl<'tcx>>,\n+        local_decls: LocalDecls<'tcx>,\n+        user_type_annotations: CanonicalUserTypeAnnotations<'tcx>,\n         arg_count: usize,\n         upvar_decls: Vec<UpvarDecl>,\n         span: Span,\n@@ -185,6 +192,7 @@ impl<'tcx> Mir<'tcx> {\n             generator_drop: None,\n             generator_layout: None,\n             local_decls,\n+            user_type_annotations,\n             arg_count,\n             upvar_decls,\n             spread_arg: None,\n@@ -418,6 +426,7 @@ impl_stable_hash_for!(struct Mir<'tcx> {\n     generator_drop,\n     generator_layout,\n     local_decls,\n+    user_type_annotations,\n     arg_count,\n     upvar_decls,\n     spread_arg,\n@@ -2232,7 +2241,7 @@ pub enum AggregateKind<'tcx> {\n         &'tcx AdtDef,\n         VariantIdx,\n         &'tcx Substs<'tcx>,\n-        Option<UserTypeAnnotation<'tcx>>,\n+        Option<UserTypeAnnotationIndex>,\n         Option<usize>,\n     ),\n \n@@ -2446,38 +2455,11 @@ pub struct Constant<'tcx> {\n     /// indicate that `Vec<_>` was explicitly specified.\n     ///\n     /// Needed for NLL to impose user-given type constraints.\n-    pub user_ty: Option<UserTypeAnnotation<'tcx>>,\n+    pub user_ty: Option<UserTypeAnnotationIndex>,\n \n     pub literal: &'tcx ty::Const<'tcx>,\n }\n \n-/// A user-given type annotation attached to a constant.  These arise\n-/// from constants that are named via paths, like `Foo::<A>::new` and\n-/// so forth.\n-#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n-pub enum UserTypeAnnotation<'tcx> {\n-    Ty(CanonicalTy<'tcx>),\n-\n-    /// The canonical type is the result of `type_of(def_id)` with the\n-    /// given substitutions applied.\n-    TypeOf(DefId, CanonicalUserSubsts<'tcx>),\n-}\n-\n-EnumTypeFoldableImpl! {\n-    impl<'tcx> TypeFoldable<'tcx> for UserTypeAnnotation<'tcx> {\n-        (UserTypeAnnotation::Ty)(ty),\n-        (UserTypeAnnotation::TypeOf)(def, substs),\n-    }\n-}\n-\n-EnumLiftImpl! {\n-    impl<'a, 'tcx> Lift<'tcx> for UserTypeAnnotation<'a> {\n-        type Lifted = UserTypeAnnotation<'tcx>;\n-        (UserTypeAnnotation::Ty)(ty),\n-        (UserTypeAnnotation::TypeOf)(def, substs),\n-    }\n-}\n-\n /// A collection of projections into user types.\n ///\n /// They are projections because a binding can occur a part of a\n@@ -2556,7 +2538,7 @@ impl<'tcx> UserTypeProjections<'tcx> {\n ///   determined by finding the type of the `.0` field from `T`.\n #[derive(Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n pub struct UserTypeProjection<'tcx> {\n-    pub base: UserTypeAnnotation<'tcx>,\n+    pub base: UserTypeAnnotationIndex,\n     pub projs: Vec<ProjectionElem<'tcx, (), ()>>,\n }\n \n@@ -2970,6 +2952,7 @@ CloneTypeFoldableAndLiftImpls! {\n     SourceScope,\n     SourceScopeData,\n     SourceScopeLocalData,\n+    UserTypeAnnotationIndex,\n }\n \n BraceStructTypeFoldableImpl! {\n@@ -2983,6 +2966,7 @@ BraceStructTypeFoldableImpl! {\n         generator_drop,\n         generator_layout,\n         local_decls,\n+        user_type_annotations,\n         arg_count,\n         upvar_decls,\n         spread_arg,"}, {"sha": "67f85fbc8679ee133c2bd54722dea3c26807951c", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 15, "deletions": 9, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/24a7a010d1015731418852d893d889f4bcbdeb51/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24a7a010d1015731418852d893d889f4bcbdeb51/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=24a7a010d1015731418852d893d889f4bcbdeb51", "patch": "@@ -1,4 +1,5 @@\n use hir::def_id::DefId;\n+use infer::canonical::Canonical;\n use ty::subst::Substs;\n use ty::{ClosureSubsts, GeneratorSubsts, Region, Ty};\n use mir::*;\n@@ -219,9 +220,10 @@ macro_rules! make_mir_visitor {\n \n             fn visit_user_type_annotation(\n                 &mut self,\n-                ty: & $($mutability)* UserTypeAnnotation<'tcx>,\n+                index: UserTypeAnnotationIndex,\n+                ty: & $($mutability)* Canonical<'tcx, UserTypeAnnotation<'tcx>>,\n             ) {\n-                self.super_user_type_annotation(ty);\n+                self.super_user_type_annotation(index, ty);\n             }\n \n             fn visit_region(&mut self,\n@@ -307,6 +309,14 @@ macro_rules! make_mir_visitor {\n                     self.visit_local_decl(local, & $($mutability)* mir.local_decls[local]);\n                 }\n \n+                for index in mir.user_type_annotations.indices() {\n+                    let (span, annotation) = & $($mutability)* mir.user_type_annotations[index];\n+                    self.visit_user_type_annotation(\n+                        index, annotation\n+                    );\n+                    self.visit_span(span);\n+                }\n+\n                 self.visit_span(&$($mutability)* mir.span);\n             }\n \n@@ -865,18 +875,14 @@ macro_rules! make_mir_visitor {\n \n             fn super_user_type_projection(\n                 &mut self,\n-                ty: & $($mutability)* UserTypeProjection<'tcx>,\n+                _ty: & $($mutability)* UserTypeProjection<'tcx>,\n             ) {\n-                let UserTypeProjection {\n-                    ref $($mutability)* base,\n-                    projs: _, // Note: Does not visit projection elems!\n-                } = *ty;\n-                self.visit_user_type_annotation(base);\n             }\n \n             fn super_user_type_annotation(\n                 &mut self,\n-                _ty: & $($mutability)* UserTypeAnnotation<'tcx>,\n+                _index: UserTypeAnnotationIndex,\n+                _ty: & $($mutability)* Canonical<'tcx, UserTypeAnnotation<'tcx>>,\n             ) {\n             }\n "}, {"sha": "32348e2e5046dbc6027f033996919435b723b20f", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 104, "deletions": 42, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/24a7a010d1015731418852d893d889f4bcbdeb51/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24a7a010d1015731418852d893d889f4bcbdeb51/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=24a7a010d1015731418852d893d889f4bcbdeb51", "patch": "@@ -14,7 +14,7 @@ use hir::map as hir_map;\n use hir::map::DefPathHash;\n use lint::{self, Lint};\n use ich::{StableHashingContext, NodeIdHashingMode};\n-use infer::canonical::{CanonicalVarInfo, CanonicalVarInfos};\n+use infer::canonical::{Canonical, CanonicalVarInfo, CanonicalVarInfos};\n use infer::outlives::free_region_map::FreeRegionMap;\n use middle::cstore::CrateStoreDyn;\n use middle::cstore::EncodedMetadata;\n@@ -23,7 +23,7 @@ use middle::resolve_lifetime::{self, ObjectLifetimeDefault};\n use middle::stability;\n use mir::{self, Mir, interpret, ProjectionKind};\n use mir::interpret::Allocation;\n-use ty::subst::{CanonicalUserSubsts, Kind, Substs, Subst};\n+use ty::subst::{Kind, Substs, Subst};\n use ty::ReprOptions;\n use traits;\n use traits::{Clause, Clauses, GoalKind, Goal, Goals};\n@@ -38,8 +38,8 @@ use ty::GenericParamDefKind;\n use ty::layout::{LayoutDetails, TargetDataLayout, VariantIdx};\n use ty::query;\n use ty::steal::Steal;\n-use ty::BindingMode;\n-use ty::CanonicalTy;\n+use ty::subst::{UserSubsts, UnpackedKind};\n+use ty::{BoundVar, BindingMode};\n use ty::CanonicalPolyFnSig;\n use util::nodemap::{DefIdMap, DefIdSet, ItemLocalMap};\n use util::nodemap::{FxHashMap, FxHashSet};\n@@ -49,7 +49,7 @@ use rustc_data_structures::stable_hasher::{HashStable, hash_stable_hashmap,\n                                            StableHasher, StableHasherResult,\n                                            StableVec};\n use arena::{TypedArena, SyncDroplessArena};\n-use rustc_data_structures::indexed_vec::IndexVec;\n+use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n use rustc_data_structures::sync::{self, Lrc, Lock, WorkerLocal};\n use std::any::Any;\n use std::borrow::Borrow;\n@@ -342,26 +342,21 @@ pub struct TypeckTables<'tcx> {\n     /// other items.\n     node_substs: ItemLocalMap<&'tcx Substs<'tcx>>,\n \n-    /// Stores the canonicalized types provided by the user. See also\n-    /// `AscribeUserType` statement in MIR.\n-    user_provided_tys: ItemLocalMap<CanonicalTy<'tcx>>,\n+    /// This will either store the canonicalized types provided by the user\n+    /// or the substitutions that the user explicitly gave (if any) attached\n+    /// to `id`. These will not include any inferred values. The canonical form\n+    /// is used to capture things like `_` or other unspecified values.\n+    ///\n+    /// For example, if the user wrote `foo.collect::<Vec<_>>()`, then the\n+    /// canonical substitutions would include only `for<X> { Vec<X> }`.\n+    ///\n+    /// See also `AscribeUserType` statement in MIR.\n+    user_provided_types: ItemLocalMap<CanonicalUserTypeAnnotation<'tcx>>,\n \n     /// Stores the canonicalized types provided by the user. See also\n     /// `AscribeUserType` statement in MIR.\n     pub user_provided_sigs: DefIdMap<CanonicalPolyFnSig<'tcx>>,\n \n-    /// Stores the substitutions that the user explicitly gave (if any)\n-    /// attached to `id`. These will not include any inferred\n-    /// values. The canonical form is used to capture things like `_`\n-    /// or other unspecified values.\n-    ///\n-    /// Example:\n-    ///\n-    /// If the user wrote `foo.collect::<Vec<_>>()`, then the\n-    /// canonical substitutions would include only `for<X> { Vec<X>\n-    /// }`.\n-    user_substs: ItemLocalMap<CanonicalUserSubsts<'tcx>>,\n-\n     adjustments: ItemLocalMap<Vec<ty::adjustment::Adjustment<'tcx>>>,\n \n     /// Stores the actual binding mode for all instances of hir::BindingAnnotation.\n@@ -432,11 +427,10 @@ impl<'tcx> TypeckTables<'tcx> {\n             local_id_root,\n             type_dependent_defs: Default::default(),\n             field_indices: Default::default(),\n-            user_provided_tys: Default::default(),\n+            user_provided_types: Default::default(),\n             user_provided_sigs: Default::default(),\n             node_types: Default::default(),\n             node_substs: Default::default(),\n-            user_substs: Default::default(),\n             adjustments: Default::default(),\n             pat_binding_modes: Default::default(),\n             pat_adjustments: Default::default(),\n@@ -491,17 +485,21 @@ impl<'tcx> TypeckTables<'tcx> {\n         }\n     }\n \n-    pub fn user_provided_tys(&self) -> LocalTableInContext<'_, CanonicalTy<'tcx>> {\n+    pub fn user_provided_types(\n+        &self\n+    ) -> LocalTableInContext<'_, CanonicalUserTypeAnnotation<'tcx>> {\n         LocalTableInContext {\n             local_id_root: self.local_id_root,\n-            data: &self.user_provided_tys\n+            data: &self.user_provided_types\n         }\n     }\n \n-    pub fn user_provided_tys_mut(&mut self) -> LocalTableInContextMut<'_, CanonicalTy<'tcx>> {\n+    pub fn user_provided_types_mut(\n+        &mut self\n+    ) -> LocalTableInContextMut<'_, CanonicalUserTypeAnnotation<'tcx>> {\n         LocalTableInContextMut {\n             local_id_root: self.local_id_root,\n-            data: &mut self.user_provided_tys\n+            data: &mut self.user_provided_types\n         }\n     }\n \n@@ -551,18 +549,6 @@ impl<'tcx> TypeckTables<'tcx> {\n         self.node_substs.get(&id.local_id).cloned()\n     }\n \n-    pub fn user_substs_mut(&mut self) -> LocalTableInContextMut<'_, CanonicalUserSubsts<'tcx>> {\n-        LocalTableInContextMut {\n-            local_id_root: self.local_id_root,\n-            data: &mut self.user_substs\n-        }\n-    }\n-\n-    pub fn user_substs(&self, id: hir::HirId) -> Option<CanonicalUserSubsts<'tcx>> {\n-        validate_hir_id_for_typeck_tables(self.local_id_root, id, false);\n-        self.user_substs.get(&id.local_id).cloned()\n-    }\n-\n     // Returns the type of a pattern as a monotype. Like @expr_ty, this function\n     // doesn't provide type parameter substitutions.\n     pub fn pat_ty(&self, pat: &hir::Pat) -> Ty<'tcx> {\n@@ -739,11 +725,10 @@ impl<'a, 'gcx> HashStable<StableHashingContext<'a>> for TypeckTables<'gcx> {\n             local_id_root,\n             ref type_dependent_defs,\n             ref field_indices,\n-            ref user_provided_tys,\n+            ref user_provided_types,\n             ref user_provided_sigs,\n             ref node_types,\n             ref node_substs,\n-            ref user_substs,\n             ref adjustments,\n             ref pat_binding_modes,\n             ref pat_adjustments,\n@@ -763,11 +748,10 @@ impl<'a, 'gcx> HashStable<StableHashingContext<'a>> for TypeckTables<'gcx> {\n         hcx.with_node_id_hashing_mode(NodeIdHashingMode::HashDefPath, |hcx| {\n             type_dependent_defs.hash_stable(hcx, hasher);\n             field_indices.hash_stable(hcx, hasher);\n-            user_provided_tys.hash_stable(hcx, hasher);\n+            user_provided_types.hash_stable(hcx, hasher);\n             user_provided_sigs.hash_stable(hcx, hasher);\n             node_types.hash_stable(hcx, hasher);\n             node_substs.hash_stable(hcx, hasher);\n-            user_substs.hash_stable(hcx, hasher);\n             adjustments.hash_stable(hcx, hasher);\n             pat_binding_modes.hash_stable(hcx, hasher);\n             pat_adjustments.hash_stable(hcx, hasher);\n@@ -805,6 +789,84 @@ impl<'a, 'gcx> HashStable<StableHashingContext<'a>> for TypeckTables<'gcx> {\n     }\n }\n \n+newtype_index! {\n+    pub struct UserTypeAnnotationIndex {\n+        DEBUG_FORMAT = \"UserTypeAnnotation({})\",\n+        const START_INDEX = 0,\n+    }\n+}\n+\n+/// Mapping of type annotation indices to canonical user type annotations.\n+pub type CanonicalUserTypeAnnotations<'tcx> =\n+    IndexVec<UserTypeAnnotationIndex, (Span, CanonicalUserTypeAnnotation<'tcx>)>;\n+\n+/// Canonicalized user type annotation.\n+pub type CanonicalUserTypeAnnotation<'gcx> = Canonical<'gcx, UserTypeAnnotation<'gcx>>;\n+\n+impl CanonicalUserTypeAnnotation<'gcx> {\n+    /// Returns `true` if this represents a substitution of the form `[?0, ?1, ?2]`,\n+    /// i.e. each thing is mapped to a canonical variable with the same index.\n+    pub fn is_identity(&self) -> bool {\n+        match self.value {\n+            UserTypeAnnotation::Ty(_) => false,\n+            UserTypeAnnotation::TypeOf(_, user_substs) => {\n+                if user_substs.user_self_ty.is_some() {\n+                    return false;\n+                }\n+\n+                user_substs.substs.iter().zip(BoundVar::new(0)..).all(|(kind, cvar)| {\n+                    match kind.unpack() {\n+                        UnpackedKind::Type(ty) => match ty.sty {\n+                            ty::Bound(debruijn, b) => {\n+                                // We only allow a `ty::INNERMOST` index in substitutions.\n+                                assert_eq!(debruijn, ty::INNERMOST);\n+                                cvar == b.var\n+                            }\n+                            _ => false,\n+                        },\n+\n+                        UnpackedKind::Lifetime(r) => match r {\n+                            ty::ReLateBound(debruijn, br) => {\n+                                // We only allow a `ty::INNERMOST` index in substitutions.\n+                                assert_eq!(*debruijn, ty::INNERMOST);\n+                                cvar == br.assert_bound_var()\n+                            }\n+                            _ => false,\n+                        },\n+                    }\n+                })\n+            },\n+        }\n+    }\n+}\n+\n+/// A user-given type annotation attached to a constant.  These arise\n+/// from constants that are named via paths, like `Foo::<A>::new` and\n+/// so forth.\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n+pub enum UserTypeAnnotation<'tcx> {\n+    Ty(Ty<'tcx>),\n+\n+    /// The canonical type is the result of `type_of(def_id)` with the\n+    /// given substitutions applied.\n+    TypeOf(DefId, UserSubsts<'tcx>),\n+}\n+\n+EnumTypeFoldableImpl! {\n+    impl<'tcx> TypeFoldable<'tcx> for UserTypeAnnotation<'tcx> {\n+        (UserTypeAnnotation::Ty)(ty),\n+        (UserTypeAnnotation::TypeOf)(def, substs),\n+    }\n+}\n+\n+EnumLiftImpl! {\n+    impl<'a, 'tcx> Lift<'tcx> for UserTypeAnnotation<'a> {\n+        type Lifted = UserTypeAnnotation<'tcx>;\n+        (UserTypeAnnotation::Ty)(ty),\n+        (UserTypeAnnotation::TypeOf)(def, substs),\n+    }\n+}\n+\n impl<'tcx> CommonTypes<'tcx> {\n     fn new(interners: &CtxtInterners<'tcx>) -> CommonTypes<'tcx> {\n         let mk = |sty| CtxtInterners::intern_ty(interners, interners, sty);"}, {"sha": "d40dd830e9fb930f0182de08f52e668a454ded19", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/24a7a010d1015731418852d893d889f4bcbdeb51/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24a7a010d1015731418852d893d889f4bcbdeb51/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=24a7a010d1015731418852d893d889f4bcbdeb51", "patch": "@@ -73,6 +73,10 @@ pub use self::binding::BindingMode::*;\n \n pub use self::context::{TyCtxt, FreeRegionInfo, GlobalArenas, AllArenas, tls, keep_local};\n pub use self::context::{Lift, TypeckTables, CtxtInterners};\n+pub use self::context::{\n+    UserTypeAnnotationIndex, UserTypeAnnotation, CanonicalUserTypeAnnotation,\n+    CanonicalUserTypeAnnotations,\n+};\n \n pub use self::instance::{Instance, InstanceDef};\n "}, {"sha": "64e7af815b4bf93afc8da858cc5556effdec894e", "filename": "src/librustc/ty/subst.rs", "status": "modified", "additions": 1, "deletions": 39, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/24a7a010d1015731418852d893d889f4bcbdeb51/src%2Flibrustc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24a7a010d1015731418852d893d889f4bcbdeb51/src%2Flibrustc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsubst.rs?ref=24a7a010d1015731418852d893d889f4bcbdeb51", "patch": "@@ -2,12 +2,11 @@\n \n use hir::def_id::DefId;\n use infer::canonical::Canonical;\n-use ty::{self, BoundVar, Lift, List, Ty, TyCtxt};\n+use ty::{self, Lift, List, Ty, TyCtxt};\n use ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n \n use serialize::{self, Encodable, Encoder, Decodable, Decoder};\n use syntax_pos::{Span, DUMMY_SP};\n-use rustc_data_structures::indexed_vec::Idx;\n use smallvec::SmallVec;\n \n use core::intrinsics;\n@@ -559,43 +558,6 @@ impl<'a, 'gcx, 'tcx> SubstFolder<'a, 'gcx, 'tcx> {\n \n pub type CanonicalUserSubsts<'tcx> = Canonical<'tcx, UserSubsts<'tcx>>;\n \n-impl CanonicalUserSubsts<'tcx> {\n-    /// True if this represents a substitution like\n-    ///\n-    /// ```text\n-    /// [?0, ?1, ?2]\n-    /// ```\n-    ///\n-    /// i.e., each thing is mapped to a canonical variable with the same index.\n-    pub fn is_identity(&self) -> bool {\n-        if self.value.user_self_ty.is_some() {\n-            return false;\n-        }\n-\n-        self.value.substs.iter().zip(BoundVar::new(0)..).all(|(kind, cvar)| {\n-            match kind.unpack() {\n-                UnpackedKind::Type(ty) => match ty.sty {\n-                    ty::Bound(debruijn, b) => {\n-                        // We only allow a `ty::INNERMOST` index in substitutions.\n-                        assert_eq!(debruijn, ty::INNERMOST);\n-                        cvar == b.var\n-                    }\n-                    _ => false,\n-                },\n-\n-                UnpackedKind::Lifetime(r) => match r {\n-                    ty::ReLateBound(debruijn, br) => {\n-                        // We only allow a `ty::INNERMOST` index in substitutions.\n-                        assert_eq!(*debruijn, ty::INNERMOST);\n-                        cvar == br.assert_bound_var()\n-                    }\n-                    _ => false,\n-                },\n-            }\n-        })\n-    }\n-}\n-\n /// Stores the user-given substs to reach some fully qualified path\n /// (e.g., `<T>::Item` or `<T as Trait>::Item`).\n #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]"}, {"sha": "55af7399aab8f311a97a2e970c690f975a3e7f9e", "filename": "src/librustc_mir/borrow_check/nll/renumber.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/24a7a010d1015731418852d893d889f4bcbdeb51/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Frenumber.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24a7a010d1015731418852d893d889f4bcbdeb51/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Frenumber.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Frenumber.rs?ref=24a7a010d1015731418852d893d889f4bcbdeb51", "patch": "@@ -1,6 +1,10 @@\n+use rustc::infer::canonical::Canonical;\n use rustc::ty::subst::Substs;\n-use rustc::ty::{self, ClosureSubsts, GeneratorSubsts, Ty, TypeFoldable};\n-use rustc::mir::{Location, Mir, UserTypeAnnotation};\n+use rustc::ty::{\n+    self, ClosureSubsts, GeneratorSubsts, Ty, TypeFoldable, UserTypeAnnotation,\n+    UserTypeAnnotationIndex,\n+};\n+use rustc::mir::{Location, Mir};\n use rustc::mir::visit::{MutVisitor, TyContext};\n use rustc::infer::{InferCtxt, NLLRegionVariableOrigin};\n \n@@ -55,7 +59,11 @@ impl<'a, 'gcx, 'tcx> MutVisitor<'tcx> for NLLVisitor<'a, 'gcx, 'tcx> {\n         debug!(\"visit_ty: ty={:?}\", ty);\n     }\n \n-    fn visit_user_type_annotation(&mut self, _ty: &mut UserTypeAnnotation<'tcx>) {\n+    fn visit_user_type_annotation(\n+        &mut self,\n+        _index: UserTypeAnnotationIndex,\n+        _ty: &mut Canonical<'tcx, UserTypeAnnotation<'tcx>>,\n+    ) {\n         // User type annotations represent the types that the user\n         // wrote in the progarm. We don't want to erase the regions\n         // from these types: rather, we want to add them as"}, {"sha": "8f8abe09810a26143c4d8961aa7401ed5fa392c5", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 61, "deletions": 27, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/24a7a010d1015731418852d893d889f4bcbdeb51/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24a7a010d1015731418852d893d889f4bcbdeb51/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=24a7a010d1015731418852d893d889f4bcbdeb51", "patch": "@@ -36,7 +36,10 @@ use rustc::traits::query::{Fallible, NoSolution};\n use rustc::traits::{ObligationCause, PredicateObligations};\n use rustc::ty::fold::TypeFoldable;\n use rustc::ty::subst::{Subst, Substs, UnpackedKind};\n-use rustc::ty::{self, RegionVid, ToPolyTraitRef, Ty, TyCtxt, TyKind};\n+use rustc::ty::{\n+    self, RegionVid, ToPolyTraitRef, Ty, TyCtxt, TyKind, UserTypeAnnotation,\n+    UserTypeAnnotationIndex,\n+};\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n use rustc::ty::layout::VariantIdx;\n@@ -272,19 +275,20 @@ impl<'a, 'b, 'gcx, 'tcx> Visitor<'tcx> for TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n         self.sanitize_constant(constant, location);\n         self.sanitize_type(constant, constant.ty);\n \n-        if let Some(user_ty) = constant.user_ty {\n+        if let Some(annotation_index) = constant.user_ty {\n             if let Err(terr) = self.cx.relate_type_and_user_type(\n                 constant.ty,\n                 ty::Variance::Invariant,\n-                &UserTypeProjection { base: user_ty, projs: vec![], },\n+                &UserTypeProjection { base: annotation_index, projs: vec![], },\n                 location.to_locations(),\n                 ConstraintCategory::Boring,\n             ) {\n+                let annotation = self.cx.instantiated_type_annotations[&annotation_index];\n                 span_mirbug!(\n                     self,\n                     constant,\n                     \"bad constant user type {:?} vs {:?}: {:?}\",\n-                    user_ty,\n+                    annotation,\n                     constant.ty,\n                     terr,\n                 );\n@@ -715,6 +719,15 @@ struct TypeChecker<'a, 'gcx: 'tcx, 'tcx: 'a> {\n     reported_errors: FxHashSet<(Ty<'tcx>, Span)>,\n     borrowck_context: Option<&'a mut BorrowCheckContext<'a, 'tcx>>,\n     universal_region_relations: Option<&'a UniversalRegionRelations<'tcx>>,\n+    /// For each user-type annotation (identified by a UserTypeAnnotationIndex), we create\n+    /// an \"instantiated\" version at the beginning of type check, which replaces each\n+    /// canonical variable with a fresh inference variable. These instantiated versions are\n+    /// stored either in this field or in user_substs, depending on the kind of user-type\n+    /// annotation. They are then referenced by the code which has the job of enforcing these\n+    /// annotations. Part of the reason for this setup is that it allows us to enforce basic\n+    /// WF criteria on the types even if the code that referenced them is dead\n+    /// code (see #54943).\n+    instantiated_type_annotations: FxHashMap<UserTypeAnnotationIndex, UserTypeAnnotation<'tcx>>,\n }\n \n struct BorrowCheckContext<'a, 'tcx: 'a> {\n@@ -860,7 +873,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         borrowck_context: Option<&'a mut BorrowCheckContext<'a, 'tcx>>,\n         universal_region_relations: Option<&'a UniversalRegionRelations<'tcx>>,\n     ) -> Self {\n-        TypeChecker {\n+        let mut checker = Self {\n             infcx,\n             last_span: DUMMY_SP,\n             mir,\n@@ -871,7 +884,36 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n             borrowck_context,\n             reported_errors: Default::default(),\n             universal_region_relations,\n+            instantiated_type_annotations: Default::default(),\n+        };\n+        checker.instantiate_user_type_annotations();\n+        checker\n+    }\n+\n+    /// Instantiate canonical types from user type annotations in the `Mir` into the\n+    /// `TypeChecker`. Used when relating user type annotations and when checking if\n+    /// annotations are well-formed.\n+    fn instantiate_user_type_annotations(&mut self) {\n+        debug!(\n+            \"instantiate_user_type_annotations: user_type_annotations={:?}\",\n+             self.mir.user_type_annotations\n+        );\n+        for annotation_index in self.mir.user_type_annotations.indices() {\n+            let (span, canonical_annotation) = &self.mir.user_type_annotations[annotation_index];\n+            let (mut annotation, _) = self.infcx.instantiate_canonical_with_fresh_inference_vars(\n+                *span, &canonical_annotation\n+            );\n+            match annotation {\n+                UserTypeAnnotation::Ty(ref mut ty) =>\n+                    *ty = self.normalize(ty, Locations::All(*span)),\n+                _ => {},\n+            }\n+            self.instantiated_type_annotations.insert(annotation_index, annotation);\n         }\n+        debug!(\n+            \"instantiate_user_type_annotations: instantiated_type_annotations={:?}\",\n+            self.instantiated_type_annotations,\n+        );\n     }\n \n     /// Given some operation `op` that manipulates types, proves\n@@ -1003,18 +1045,13 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n             a, v, user_ty, locations,\n         );\n \n-        match user_ty.base {\n-            UserTypeAnnotation::Ty(canonical_ty) => {\n-                let (ty, _) = self.infcx\n-                    .instantiate_canonical_with_fresh_inference_vars(DUMMY_SP, &canonical_ty);\n-\n+        match self.instantiated_type_annotations[&user_ty.base] {\n+            UserTypeAnnotation::Ty(ty) => {\n                 // The `TypeRelating` code assumes that \"unresolved inference\n                 // variables\" appear in the \"a\" side, so flip `Contravariant`\n                 // ambient variance to get the right relationship.\n                 let v1 = ty::Contravariant.xform(v);\n-\n                 let tcx = self.infcx.tcx;\n-                let ty = self.normalize(ty, locations);\n \n                 // We need to follow any provided projetions into the type.\n                 //\n@@ -1048,13 +1085,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                     self.relate_types(ty, v1, a, locations, category)?;\n                 }\n             }\n-            UserTypeAnnotation::TypeOf(def_id, canonical_substs) => {\n-                let (\n-                    user_substs,\n-                    _,\n-                ) = self.infcx\n-                    .instantiate_canonical_with_fresh_inference_vars(DUMMY_SP, &canonical_substs);\n-\n+            UserTypeAnnotation::TypeOf(def_id, user_substs) => {\n                 let projs = self.infcx.tcx.intern_projs(&user_ty.projs);\n                 self.fully_perform_op(\n                     locations,\n@@ -1225,19 +1256,20 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                     );\n                 }\n \n-                if let Some(user_ty) = self.rvalue_user_ty(rv) {\n+                if let Some(annotation_index) = self.rvalue_user_ty(rv) {\n                     if let Err(terr) = self.relate_type_and_user_type(\n                         rv_ty,\n                         ty::Variance::Invariant,\n-                        &UserTypeProjection { base: user_ty, projs: vec![], },\n+                        &UserTypeProjection { base: annotation_index, projs: vec![], },\n                         location.to_locations(),\n                         ConstraintCategory::Boring,\n                     ) {\n+                        let annotation = self.instantiated_type_annotations[&annotation_index];\n                         span_mirbug!(\n                             self,\n                             stmt,\n                             \"bad user type on rvalue ({:?} = {:?}): {:?}\",\n-                            user_ty,\n+                            annotation,\n                             rv_ty,\n                             terr\n                         );\n@@ -1282,21 +1314,23 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                     );\n                 };\n             }\n-            StatementKind::AscribeUserType(ref place, variance, box ref c_ty) => {\n+            StatementKind::AscribeUserType(ref place, variance, box ref projection) => {\n                 let place_ty = place.ty(mir, tcx).to_ty(tcx);\n                 if let Err(terr) = self.relate_type_and_user_type(\n                     place_ty,\n                     variance,\n-                    c_ty,\n+                    projection,\n                     Locations::All(stmt.source_info.span),\n                     ConstraintCategory::TypeAnnotation,\n                 ) {\n+                    let annotation = self.instantiated_type_annotations[&projection.base];\n                     span_mirbug!(\n                         self,\n                         stmt,\n-                        \"bad type assert ({:?} <: {:?}): {:?}\",\n+                        \"bad type assert ({:?} <: {:?} with projections {:?}): {:?}\",\n                         place_ty,\n-                        c_ty,\n+                        annotation,\n+                        projection.projs,\n                         terr\n                     );\n                 }\n@@ -1955,7 +1989,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n     /// If this rvalue supports a user-given type annotation, then\n     /// extract and return it. This represents the final type of the\n     /// rvalue and will be unified with the inferred type.\n-    fn rvalue_user_ty(&self, rvalue: &Rvalue<'tcx>) -> Option<UserTypeAnnotation<'tcx>> {\n+    fn rvalue_user_ty(&self, rvalue: &Rvalue<'tcx>) -> Option<UserTypeAnnotationIndex> {\n         match rvalue {\n             Rvalue::Use(_)\n             | Rvalue::Repeat(..)"}, {"sha": "a431bfc61b37ae8c2aa2f9855d2c935b02bb492d", "filename": "src/librustc_mir/build/expr/as_constant.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/24a7a010d1015731418852d893d889f4bcbdeb51/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_constant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24a7a010d1015731418852d893d889f4bcbdeb51/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_constant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_constant.rs?ref=24a7a010d1015731418852d893d889f4bcbdeb51", "patch": "@@ -29,11 +29,16 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 lint_level: _,\n                 value,\n             } => this.as_constant(value),\n-            ExprKind::Literal { literal, user_ty } => Constant {\n-                span,\n-                ty,\n-                user_ty,\n-                literal,\n+            ExprKind::Literal { literal, user_ty } => {\n+                let user_ty = user_ty.map(|ty| {\n+                    this.canonical_user_type_annotations.push((span, ty))\n+                });\n+                Constant {\n+                    span,\n+                    ty,\n+                    user_ty,\n+                    literal,\n+                }\n             },\n             _ => span_bug!(span, \"expression is not a valid constant {:?}\", kind),\n         }"}, {"sha": "3ed00d5797907f638932cb4d51e097d6e94f724c", "filename": "src/librustc_mir/build/expr/as_place.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/24a7a010d1015731418852d893d889f4bcbdeb51/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24a7a010d1015731418852d893d889f4bcbdeb51/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_place.rs?ref=24a7a010d1015731418852d893d889f4bcbdeb51", "patch": "@@ -133,14 +133,17 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             ExprKind::PlaceTypeAscription { source, user_ty } => {\n                 let place = unpack!(block = this.as_place(block, source));\n                 if let Some(user_ty) = user_ty {\n+                    let annotation_index = this.canonical_user_type_annotations.push(\n+                        (source_info.span, user_ty)\n+                    );\n                     this.cfg.push(\n                         block,\n                         Statement {\n                             source_info,\n                             kind: StatementKind::AscribeUserType(\n                                 place.clone(),\n                                 Variance::Invariant,\n-                                box UserTypeProjection { base: user_ty, projs: vec![], },\n+                                box UserTypeProjection { base: annotation_index, projs: vec![], },\n                             ),\n                         },\n                     );\n@@ -153,14 +156,17 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     block = this.as_temp(block, source.temp_lifetime, source, mutability)\n                 );\n                 if let Some(user_ty) = user_ty {\n+                    let annotation_index = this.canonical_user_type_annotations.push(\n+                        (source_info.span, user_ty)\n+                    );\n                     this.cfg.push(\n                         block,\n                         Statement {\n                             source_info,\n                             kind: StatementKind::AscribeUserType(\n                                 Place::Local(temp.clone()),\n                                 Variance::Invariant,\n-                                box UserTypeProjection { base: user_ty, projs: vec![], },\n+                                box UserTypeProjection { base: annotation_index, projs: vec![], },\n                             ),\n                         },\n                     );"}, {"sha": "7dcac05e702a3ad0b297b7fae4b8cc10e1fcdfa4", "filename": "src/librustc_mir/build/expr/as_rvalue.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/24a7a010d1015731418852d893d889f4bcbdeb51/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24a7a010d1015731418852d893d889f4bcbdeb51/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=24a7a010d1015731418852d893d889f4bcbdeb51", "patch": "@@ -331,6 +331,9 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                         .collect()\n                 };\n \n+                let user_ty = user_ty.map(|ty| {\n+                    this.canonical_user_type_annotations.push((expr_span, ty))\n+                });\n                 let adt = box AggregateKind::Adt(\n                     adt_def,\n                     variant_index,"}, {"sha": "92642dff3dc68f4527f297531d5068e9071514e4", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/24a7a010d1015731418852d893d889f4bcbdeb51/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24a7a010d1015731418852d893d889f4bcbdeb51/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=24a7a010d1015731418852d893d889f4bcbdeb51", "patch": "@@ -302,14 +302,17 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 );\n \n                 let ty_source_info = self.source_info(user_ty_span);\n+                let user_ty = box pat_ascription_ty.user_ty(\n+                    &mut self.canonical_user_type_annotations, ty_source_info.span\n+                );\n                 self.cfg.push(\n                     block,\n                     Statement {\n                         source_info: ty_source_info,\n                         kind: StatementKind::AscribeUserType(\n                             place,\n                             ty::Variance::Invariant,\n-                            box pat_ascription_ty.user_ty(),\n+                            user_ty,\n                         ),\n                     },\n                 );\n@@ -1314,14 +1317,17 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 ascription.user_ty,\n             );\n \n+            let user_ty = box ascription.user_ty.clone().user_ty(\n+                &mut self.canonical_user_type_annotations, source_info.span\n+            );\n             self.cfg.push(\n                 block,\n                 Statement {\n                     source_info,\n                     kind: StatementKind::AscribeUserType(\n                         ascription.source.clone(),\n                         ty::Variance::Covariant,\n-                        box ascription.user_ty.clone().user_ty(),\n+                        user_ty,\n                     ),\n                 },\n             );\n@@ -1484,10 +1490,12 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             BindingMode::ByValue => ty::BindingMode::BindByValue(mutability.into()),\n             BindingMode::ByRef { .. } => ty::BindingMode::BindByReference(mutability.into()),\n         };\n+        let user_ty = user_var_ty.clone().user_ty(&mut self.canonical_user_type_annotations);\n+        debug!(\"declare_binding: user_ty={:?}\", user_ty);\n         let local = LocalDecl::<'tcx> {\n             mutability,\n             ty: var_ty,\n-            user_ty: user_var_ty.clone().user_ty(),\n+            user_ty,\n             name: Some(name),\n             source_info,\n             visibility_scope,"}, {"sha": "8acdecf6fa2489c9060c17ce0a59d4c8dc653710", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/24a7a010d1015731418852d893d889f4bcbdeb51/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24a7a010d1015731418852d893d889f4bcbdeb51/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=24a7a010d1015731418852d893d889f4bcbdeb51", "patch": "@@ -379,6 +379,7 @@ struct Builder<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     /// (A match binding can have two locals; the 2nd is for the arm's guard.)\n     var_indices: NodeMap<LocalsForNode>,\n     local_decls: IndexVec<Local, LocalDecl<'tcx>>,\n+    canonical_user_type_annotations: ty::CanonicalUserTypeAnnotations<'tcx>,\n     upvar_decls: Vec<UpvarDecl>,\n     unit_temp: Option<Place<'tcx>>,\n \n@@ -812,6 +813,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 LocalDecl::new_return_place(return_ty, return_span),\n                 1,\n             ),\n+            canonical_user_type_annotations: IndexVec::new(),\n             upvar_decls,\n             var_indices: Default::default(),\n             unit_temp: None,\n@@ -845,6 +847,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             IndexVec::new(),\n             yield_ty,\n             self.local_decls,\n+            self.canonical_user_type_annotations,\n             self.arg_count,\n             self.upvar_decls,\n             self.fn_span,"}, {"sha": "e73cc40c8c6e4ca19a84b14ed754281f6782d633", "filename": "src/librustc_mir/hair/cx/block.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/24a7a010d1015731418852d893d889f4bcbdeb51/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24a7a010d1015731418852d893d889f4bcbdeb51/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs?ref=24a7a010d1015731418852d893d889f4bcbdeb51", "patch": "@@ -78,12 +78,13 @@ fn mirror_stmts<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                         let mut pattern = cx.pattern_from_hir(&local.pat);\n \n                         if let Some(ty) = &local.ty {\n-                            if let Some(&user_ty) = cx.tables.user_provided_tys().get(ty.hir_id) {\n+                            if let Some(&user_ty) = cx.tables.user_provided_types().get(ty.hir_id) {\n+                                debug!(\"mirror_stmts: user_ty={:?}\", user_ty);\n                                 pattern = Pattern {\n                                     ty: pattern.ty,\n                                     span: pattern.span,\n                                     kind: Box::new(PatternKind::AscribeUserType {\n-                                        user_ty: PatternTypeProjection::from_canonical_ty(user_ty),\n+                                        user_ty: PatternTypeProjection::from_user_type(user_ty),\n                                         user_ty_span: ty.span,\n                                         subpattern: pattern\n                                     })"}, {"sha": "293058a0f26f53d359316eb42eae69361a1b19d3", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 44, "deletions": 19, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/24a7a010d1015731418852d893d889f4bcbdeb51/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24a7a010d1015731418852d893d889f4bcbdeb51/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=24a7a010d1015731418852d893d889f4bcbdeb51", "patch": "@@ -11,7 +11,7 @@ use rustc::ty::adjustment::{Adjustment, Adjust, AutoBorrow, AutoBorrowMutability\n use rustc::ty::cast::CastKind as TyCastKind;\n use rustc::hir;\n use rustc::hir::def_id::LocalDefId;\n-use rustc::mir::{BorrowKind};\n+use rustc::mir::BorrowKind;\n use syntax_pos::Span;\n \n impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n@@ -283,9 +283,16 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                 };\n                 if let Some((adt_def, index)) = adt_data {\n                     let substs = cx.tables().node_substs(fun.hir_id);\n-\n-                    let user_ty = cx.tables().user_substs(fun.hir_id)\n-                        .map(|user_substs| UserTypeAnnotation::TypeOf(adt_def.did, user_substs));\n+                    let user_provided_types = cx.tables().user_provided_types();\n+                    let user_ty = user_provided_types.get(fun.hir_id)\n+                        .map(|u_ty| *u_ty)\n+                        .map(|mut u_ty| {\n+                            if let UserTypeAnnotation::TypeOf(ref mut did, _) = &mut u_ty.value {\n+                                *did = adt_def.did;\n+                            }\n+                            u_ty\n+                        });\n+                    debug!(\"make_mirror_unadjusted: (call) user_ty={:?}\", user_ty);\n \n                     let field_refs = args.iter()\n                         .enumerate()\n@@ -464,11 +471,14 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                 ty::Adt(adt, substs) => {\n                     match adt.adt_kind() {\n                         AdtKind::Struct | AdtKind::Union => {\n+                            let user_provided_types = cx.tables().user_provided_types();\n+                            let user_ty = user_provided_types.get(expr.hir_id).map(|u_ty| *u_ty);\n+                            debug!(\"make_mirror_unadjusted: (struct/union) user_ty={:?}\", user_ty);\n                             ExprKind::Adt {\n                                 adt_def: adt,\n                                 variant_index: VariantIdx::new(0),\n                                 substs,\n-                                user_ty: cx.user_substs_applied_to_adt(expr.hir_id, adt),\n+                                user_ty,\n                                 fields: field_refs(cx, fields),\n                                 base: base.as_ref().map(|base| {\n                                     FruInfo {\n@@ -487,11 +497,18 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                                     assert!(base.is_none());\n \n                                     let index = adt.variant_index_with_id(variant_id);\n+                                    let user_provided_types = cx.tables().user_provided_types();\n+                                    let user_ty = user_provided_types.get(expr.hir_id)\n+                                        .map(|u_ty| *u_ty);\n+                                    debug!(\n+                                        \"make_mirror_unadjusted: (variant) user_ty={:?}\",\n+                                        user_ty\n+                                    );\n                                     ExprKind::Adt {\n                                         adt_def: adt,\n                                         variant_index: index,\n                                         substs,\n-                                        user_ty: cx.user_substs_applied_to_adt(expr.hir_id, adt),\n+                                        user_ty,\n                                         fields: field_refs(cx, fields),\n                                         base: None,\n                                     }\n@@ -635,8 +652,8 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         }\n         hir::ExprKind::Cast(ref source, ref cast_ty) => {\n             // Check for a user-given type annotation on this `cast`\n-            let user_ty = cx.tables.user_provided_tys().get(cast_ty.hir_id)\n-                .map(|&t| UserTypeAnnotation::Ty(t));\n+            let user_provided_types = cx.tables.user_provided_types();\n+            let user_ty = user_provided_types.get(cast_ty.hir_id);\n \n             debug!(\n                 \"cast({:?}) has ty w/ hir_id {:?} and user provided ty {:?}\",\n@@ -742,20 +759,20 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                     span: expr.span,\n                     kind: cast,\n                 };\n+                debug!(\"make_mirror_unadjusted: (cast) user_ty={:?}\", user_ty);\n \n                 ExprKind::ValueTypeAscription {\n                     source: cast_expr.to_ref(),\n-                    user_ty: Some(user_ty),\n+                    user_ty: Some(*user_ty),\n                 }\n             } else {\n                 cast\n             }\n         }\n         hir::ExprKind::Type(ref source, ref ty) => {\n-            let user_provided_tys = cx.tables.user_provided_tys();\n-            let user_ty = user_provided_tys\n-                .get(ty.hir_id)\n-                .map(|&c_ty| UserTypeAnnotation::Ty(c_ty));\n+            let user_provided_types = cx.tables.user_provided_types();\n+            let user_ty = user_provided_types.get(ty.hir_id).map(|u_ty| *u_ty);\n+            debug!(\"make_mirror_unadjusted: (type) user_ty={:?}\", user_ty);\n             if source.is_place_expr() {\n                 ExprKind::PlaceTypeAscription {\n                     source: source.to_ref(),\n@@ -792,8 +809,9 @@ fn user_substs_applied_to_def(\n     cx: &mut Cx<'a, 'gcx, 'tcx>,\n     hir_id: hir::HirId,\n     def: &Def,\n-) -> Option<UserTypeAnnotation<'tcx>> {\n-    match def {\n+) -> Option<ty::CanonicalUserTypeAnnotation<'tcx>> {\n+    debug!(\"user_substs_applied_to_def: def={:?}\", def);\n+    let user_provided_type = match def {\n         // A reference to something callable -- e.g., a fn, method, or\n         // a tuple-struct or tuple-variant. This has the type of a\n         // `Fn` but with the user-given substitutions.\n@@ -802,8 +820,7 @@ fn user_substs_applied_to_def(\n         Def::StructCtor(_, CtorKind::Fn) |\n         Def::VariantCtor(_, CtorKind::Fn) |\n         Def::Const(_) |\n-        Def::AssociatedConst(_) =>\n-            Some(UserTypeAnnotation::TypeOf(def.def_id(), cx.tables().user_substs(hir_id)?)),\n+        Def::AssociatedConst(_) => cx.tables().user_provided_types().get(hir_id).map(|u_ty| *u_ty),\n \n         // A unit struct/variant which is used as a value (e.g.,\n         // `None`). This has the type of the enum/struct that defines\n@@ -819,7 +836,9 @@ fn user_substs_applied_to_def(\n \n         _ =>\n             bug!(\"user_substs_applied_to_def: unexpected def {:?} at {:?}\", def, hir_id)\n-    }\n+    };\n+    debug!(\"user_substs_applied_to_def: user_provided_type={:?}\", user_provided_type);\n+    user_provided_type\n }\n \n fn method_callee<'a, 'gcx, 'tcx>(\n@@ -839,6 +858,7 @@ fn method_callee<'a, 'gcx, 'tcx>(\n                     span_bug!(expr.span, \"no type-dependent def for method callee\")\n                 });\n             let user_ty = user_substs_applied_to_def(cx, expr.hir_id, def);\n+            debug!(\"method_callee: user_ty={:?}\", user_ty);\n             (def.def_id(), cx.tables().node_substs(expr.hir_id), user_ty)\n         }\n     };\n@@ -906,6 +926,7 @@ fn convert_path_expr<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         Def::VariantCtor(_, CtorKind::Fn) |\n         Def::SelfCtor(..) => {\n             let user_ty = user_substs_applied_to_def(cx, expr.hir_id, &def);\n+            debug!(\"convert_path_expr: user_ty={:?}\", user_ty);\n             ExprKind::Literal {\n                 literal: ty::Const::zero_sized(\n                     cx.tcx,\n@@ -918,6 +939,7 @@ fn convert_path_expr<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         Def::Const(def_id) |\n         Def::AssociatedConst(def_id) => {\n             let user_ty = user_substs_applied_to_def(cx, expr.hir_id, &def);\n+            debug!(\"convert_path_expr: (const) user_ty={:?}\", user_ty);\n             ExprKind::Literal {\n                 literal: ty::Const::unevaluated(\n                     cx.tcx,\n@@ -931,6 +953,9 @@ fn convert_path_expr<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n \n         Def::StructCtor(def_id, CtorKind::Const) |\n         Def::VariantCtor(def_id, CtorKind::Const) => {\n+            let user_provided_types = cx.tables.user_provided_types();\n+            let user_provided_type = user_provided_types.get(expr.hir_id).map(|u_ty| *u_ty);\n+            debug!(\"convert_path_expr: user_provided_type={:?}\", user_provided_type);\n             match cx.tables().node_id_to_type(expr.hir_id).sty {\n                 // A unit struct/variant which is used as a value.\n                 // We return a completely different ExprKind here to account for this special case.\n@@ -939,7 +964,7 @@ fn convert_path_expr<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                         adt_def,\n                         variant_index: adt_def.variant_index_with_id(def_id),\n                         substs,\n-                        user_ty: cx.user_substs_applied_to_adt(expr.hir_id, adt_def),\n+                        user_ty: user_provided_type,\n                         fields: vec![],\n                         base: None,\n                     }"}, {"sha": "d36a6eb58b85a25a761c43e2003c7f6881aebff1", "filename": "src/librustc_mir/hair/mod.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/24a7a010d1015731418852d893d889f4bcbdeb51/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24a7a010d1015731418852d893d889f4bcbdeb51/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fmod.rs?ref=24a7a010d1015731418852d893d889f4bcbdeb51", "patch": "@@ -4,11 +4,12 @@\n //! unit-tested and separated from the Rust source and compiler data\n //! structures.\n \n-use rustc::mir::{BinOp, BorrowKind, UserTypeAnnotation, Field, UnOp};\n+use rustc::mir::{BinOp, BorrowKind, Field, UnOp};\n use rustc::hir::def_id::DefId;\n+use rustc::infer::canonical::Canonical;\n use rustc::middle::region;\n use rustc::ty::subst::Substs;\n-use rustc::ty::{AdtDef, UpvarSubsts, Region, Ty, Const};\n+use rustc::ty::{AdtDef, UpvarSubsts, Region, Ty, Const, UserTypeAnnotation};\n use rustc::ty::layout::VariantIdx;\n use rustc::hir;\n use syntax::ast;\n@@ -265,20 +266,20 @@ pub enum ExprKind<'tcx> {\n \n         /// Optional user-given substs: for something like `let x =\n         /// Bar::<T> { ... }`.\n-        user_ty: Option<UserTypeAnnotation<'tcx>>,\n+        user_ty: Option<Canonical<'tcx, UserTypeAnnotation<'tcx>>>,\n \n         fields: Vec<FieldExprRef<'tcx>>,\n         base: Option<FruInfo<'tcx>>\n     },\n     PlaceTypeAscription {\n         source: ExprRef<'tcx>,\n         /// Type that the user gave to this expression\n-        user_ty: Option<UserTypeAnnotation<'tcx>>,\n+        user_ty: Option<Canonical<'tcx, UserTypeAnnotation<'tcx>>>,\n     },\n     ValueTypeAscription {\n         source: ExprRef<'tcx>,\n         /// Type that the user gave to this expression\n-        user_ty: Option<UserTypeAnnotation<'tcx>>,\n+        user_ty: Option<Canonical<'tcx, UserTypeAnnotation<'tcx>>>,\n     },\n     Closure {\n         closure_id: DefId,\n@@ -288,7 +289,7 @@ pub enum ExprKind<'tcx> {\n     },\n     Literal {\n         literal: &'tcx Const<'tcx>,\n-        user_ty: Option<UserTypeAnnotation<'tcx>>,\n+        user_ty: Option<Canonical<'tcx, UserTypeAnnotation<'tcx>>>,\n     },\n     InlineAsm {\n         asm: &'tcx hir::InlineAsm,"}, {"sha": "fd3b07c0357b504c52c562cb888fec80c5593213", "filename": "src/librustc_mir/hair/pattern/mod.rs", "status": "modified", "additions": 42, "deletions": 31, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/24a7a010d1015731418852d893d889f4bcbdeb51/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24a7a010d1015731418852d893d889f4bcbdeb51/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs?ref=24a7a010d1015731418852d893d889f4bcbdeb51", "patch": "@@ -12,9 +12,10 @@ use hair::util::UserAnnotatedTyHelpers;\n use hair::constant::*;\n \n use rustc::mir::{fmt_const_val, Field, BorrowKind, Mutability};\n-use rustc::mir::{ProjectionElem, UserTypeAnnotation, UserTypeProjection, UserTypeProjections};\n+use rustc::mir::{ProjectionElem, UserTypeProjection, UserTypeProjections};\n use rustc::mir::interpret::{Scalar, GlobalId, ConstValue, sign_extend};\n use rustc::ty::{self, Region, TyCtxt, AdtDef, Ty, Lift};\n+use rustc::ty::{CanonicalUserTypeAnnotation, CanonicalUserTypeAnnotations, UserTypeAnnotation};\n use rustc::ty::subst::{Substs, Kind};\n use rustc::ty::layout::VariantIdx;\n use rustc::hir::{self, PatKind, RangeEnd};\n@@ -63,9 +64,15 @@ pub(crate) struct PatternTypeProjections<'tcx> {\n }\n \n impl<'tcx> PatternTypeProjections<'tcx> {\n-    pub(crate) fn user_ty(self) -> UserTypeProjections<'tcx> {\n+    pub(crate) fn user_ty(\n+        self,\n+        annotations: &mut CanonicalUserTypeAnnotations<'tcx>,\n+    ) -> UserTypeProjections<'tcx> {\n         UserTypeProjections::from_projections(\n-            self.contents.into_iter().map(|(pat_ty_proj, span)| (pat_ty_proj.user_ty(), span)))\n+            self.contents\n+                .into_iter()\n+                .map(|(pat_ty_proj, span)| (pat_ty_proj.user_ty(annotations, span), span))\n+        )\n     }\n \n     pub(crate) fn none() -> Self {\n@@ -115,30 +122,33 @@ impl<'tcx> PatternTypeProjections<'tcx> {\n }\n \n #[derive(Clone, Debug)]\n-pub struct PatternTypeProjection<'tcx>(UserTypeProjection<'tcx>);\n+pub struct PatternTypeProjection<'tcx> {\n+    pub base: CanonicalUserTypeAnnotation<'tcx>,\n+    pub projs: Vec<ProjectionElem<'tcx, (), ()>>,\n+}\n \n impl<'tcx> PatternTypeProjection<'tcx> {\n     pub(crate) fn index(&self) -> Self {\n         let mut new = self.clone();\n-        new.0.projs.push(ProjectionElem::Index(()));\n+        new.projs.push(ProjectionElem::Index(()));\n         new\n     }\n \n     pub(crate) fn subslice(&self, from: u32, to: u32) -> Self {\n         let mut new = self.clone();\n-        new.0.projs.push(ProjectionElem::Subslice { from, to });\n+        new.projs.push(ProjectionElem::Subslice { from, to });\n         new\n     }\n \n     pub(crate) fn deref(&self) -> Self {\n         let mut new = self.clone();\n-        new.0.projs.push(ProjectionElem::Deref);\n+        new.projs.push(ProjectionElem::Deref);\n         new\n     }\n \n     pub(crate) fn leaf(&self, field: Field) -> Self {\n         let mut new = self.clone();\n-        new.0.projs.push(ProjectionElem::Field(field, ()));\n+        new.projs.push(ProjectionElem::Field(field, ()));\n         new\n     }\n \n@@ -147,24 +157,29 @@ impl<'tcx> PatternTypeProjection<'tcx> {\n                           variant_index: VariantIdx,\n                           field: Field) -> Self {\n         let mut new = self.clone();\n-        new.0.projs.push(ProjectionElem::Downcast(adt_def, variant_index));\n-        new.0.projs.push(ProjectionElem::Field(field, ()));\n+        new.projs.push(ProjectionElem::Downcast(adt_def, variant_index));\n+        new.projs.push(ProjectionElem::Field(field, ()));\n         new\n     }\n \n-    pub(crate) fn from_canonical_ty(c_ty: ty::CanonicalTy<'tcx>) -> Self {\n-        Self::from_user_type(UserTypeAnnotation::Ty(c_ty))\n-    }\n-\n-    pub(crate) fn from_user_type(u_ty: UserTypeAnnotation<'tcx>) -> Self {\n-        Self::from_user_type_proj(UserTypeProjection { base: u_ty, projs: vec![], })\n+    pub(crate) fn from_user_type(user_annotation: CanonicalUserTypeAnnotation<'tcx>) -> Self {\n+        Self {\n+            base: user_annotation,\n+            projs: Vec::new(),\n+        }\n     }\n \n-    pub(crate) fn from_user_type_proj(u_ty: UserTypeProjection<'tcx>) -> Self {\n-        PatternTypeProjection(u_ty)\n+    pub(crate) fn user_ty(\n+        self,\n+        annotations: &mut CanonicalUserTypeAnnotations<'tcx>,\n+        span: Span,\n+    ) -> UserTypeProjection<'tcx> {\n+        let annotation_index = annotations.push((span, self.base));\n+        UserTypeProjection {\n+            base: annotation_index,\n+            projs: self.projs\n+        }\n     }\n-\n-    pub(crate) fn user_ty(self) -> UserTypeProjection<'tcx> { self.0 }\n }\n \n #[derive(Clone, Debug)]\n@@ -788,18 +803,14 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n         };\n \n         if let Some(user_ty) = self.user_substs_applied_to_ty_of_hir_id(hir_id) {\n-            let subpattern = Pattern {\n-                span,\n-                ty,\n-                kind: Box::new(kind),\n-            };\n-\n-            debug!(\"pattern user_ty = {:?} for pattern at {:?}\", user_ty, span);\n-\n-            let pat_ty = PatternTypeProjection::from_user_type(user_ty);\n+            debug!(\"lower_variant_or_leaf: user_ty={:?} span={:?}\", user_ty, span);\n             kind = PatternKind::AscribeUserType {\n-                subpattern,\n-                user_ty: pat_ty,\n+                subpattern: Pattern {\n+                    span,\n+                    ty,\n+                    kind: Box::new(kind),\n+                },\n+                user_ty: PatternTypeProjection::from_user_type(user_ty),\n                 user_ty_span: span,\n             };\n         }"}, {"sha": "f0f8263b64de53f286e090e225f8060473897057", "filename": "src/librustc_mir/hair/util.rs", "status": "modified", "additions": 14, "deletions": 20, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/24a7a010d1015731418852d893d889f4bcbdeb51/src%2Flibrustc_mir%2Fhair%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24a7a010d1015731418852d893d889f4bcbdeb51/src%2Flibrustc_mir%2Fhair%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Futil.rs?ref=24a7a010d1015731418852d893d889f4bcbdeb51", "patch": "@@ -1,37 +1,31 @@\n use rustc::hir;\n-use rustc::mir::UserTypeAnnotation;\n-use rustc::ty::{self, AdtDef, TyCtxt};\n+use rustc::ty::{self, CanonicalUserTypeAnnotation, TyCtxt, UserTypeAnnotation};\n \n crate trait UserAnnotatedTyHelpers<'gcx: 'tcx, 'tcx> {\n     fn tcx(&self) -> TyCtxt<'_, 'gcx, 'tcx>;\n \n     fn tables(&self) -> &ty::TypeckTables<'tcx>;\n \n-    fn user_substs_applied_to_adt(\n-        &self,\n-        hir_id: hir::HirId,\n-        adt_def: &'tcx AdtDef,\n-    ) -> Option<UserTypeAnnotation<'tcx>> {\n-        let user_substs = self.tables().user_substs(hir_id)?;\n-        Some(UserTypeAnnotation::TypeOf(adt_def.did, user_substs))\n-    }\n-\n     /// Looks up the type associated with this hir-id and applies the\n     /// user-given substitutions; the hir-id must map to a suitable\n     /// type.\n     fn user_substs_applied_to_ty_of_hir_id(\n         &self,\n         hir_id: hir::HirId,\n-    ) -> Option<UserTypeAnnotation<'tcx>> {\n-        let user_substs = self.tables().user_substs(hir_id)?;\n+    ) -> Option<CanonicalUserTypeAnnotation<'tcx>> {\n+        let user_provided_types = self.tables().user_provided_types();\n+        let mut user_ty = *user_provided_types.get(hir_id)?;\n+        debug!(\"user_subts_applied_to_ty_of_hir_id: user_ty={:?}\", user_ty);\n         match &self.tables().node_id_to_type(hir_id).sty {\n-            ty::Adt(adt_def, _) => Some(UserTypeAnnotation::TypeOf(adt_def.did, user_substs)),\n-            ty::FnDef(def_id, _) => Some(UserTypeAnnotation::TypeOf(*def_id, user_substs)),\n-            sty => bug!(\n-                \"sty: {:?} should not have user-substs {:?} recorded \",\n-                sty,\n-                user_substs\n-            ),\n+            ty::Adt(adt_def, ..) => {\n+                if let UserTypeAnnotation::TypeOf(ref mut did, _) = &mut user_ty.value {\n+                    *did = adt_def.did;\n+                }\n+                Some(user_ty)\n+            }\n+            ty::FnDef(..) => Some(user_ty),\n+            sty =>\n+                bug!(\"sty: {:?} should not have user provided type {:?} recorded \", sty, user_ty),\n         }\n     }\n }"}, {"sha": "4c123d4a44b058857d3524b0d709a6992cc8fab3", "filename": "src/librustc_mir/shim.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/24a7a010d1015731418852d893d889f4bcbdeb51/src%2Flibrustc_mir%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24a7a010d1015731418852d893d889f4bcbdeb51/src%2Flibrustc_mir%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fshim.rs?ref=24a7a010d1015731418852d893d889f4bcbdeb51", "patch": "@@ -207,6 +207,7 @@ fn build_drop_shim<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         IndexVec::new(),\n         None,\n         local_decls_for_sig(&sig, span),\n+        IndexVec::new(),\n         sig.inputs().len(),\n         vec![],\n         span,\n@@ -376,6 +377,7 @@ impl<'a, 'tcx> CloneShimBuilder<'a, 'tcx> {\n             IndexVec::new(),\n             None,\n             self.local_decls,\n+            IndexVec::new(),\n             self.sig.inputs().len(),\n             vec![],\n             self.span,\n@@ -825,6 +827,7 @@ fn build_call_shim<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         IndexVec::new(),\n         None,\n         local_decls,\n+        IndexVec::new(),\n         sig.inputs().len(),\n         vec![],\n         span,\n@@ -903,6 +906,7 @@ pub fn build_adt_ctor<'a, 'gcx, 'tcx>(infcx: &infer::InferCtxt<'a, 'gcx, 'tcx>,\n         IndexVec::new(),\n         None,\n         local_decls,\n+        IndexVec::new(),\n         sig.inputs().len(),\n         vec![],\n         span,"}, {"sha": "1602fc35a2c9585a54f44d13d052515a1310e72d", "filename": "src/librustc_mir/transform/promote_consts.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/24a7a010d1015731418852d893d889f4bcbdeb51/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24a7a010d1015731418852d893d889f4bcbdeb51/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs?ref=24a7a010d1015731418852d893d889f4bcbdeb51", "patch": "@@ -400,6 +400,7 @@ pub fn promote_candidates<'a, 'tcx>(mir: &mut Mir<'tcx>,\n                 IndexVec::new(),\n                 None,\n                 initial_locals,\n+                IndexVec::new(),\n                 0,\n                 vec![],\n                 mir.span,"}, {"sha": "b9ac0394306bec2867bf0fb85c073c0f9049b3ff", "filename": "src/librustc_traits/type_op.rs", "status": "modified", "additions": 8, "deletions": 22, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/24a7a010d1015731418852d893d889f4bcbdeb51/src%2Flibrustc_traits%2Ftype_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24a7a010d1015731418852d893d889f4bcbdeb51/src%2Flibrustc_traits%2Ftype_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Ftype_op.rs?ref=24a7a010d1015731418852d893d889f4bcbdeb51", "patch": "@@ -14,7 +14,7 @@ use rustc::traits::{\n     Normalized, Obligation, ObligationCause, TraitEngine, TraitEngineExt,\n };\n use rustc::ty::query::Providers;\n-use rustc::ty::subst::{Kind, Subst, UserSelfTy, UserSubsts};\n+use rustc::ty::subst::{Kind, Subst, UserSubsts, UserSelfTy};\n use rustc::ty::{\n     FnSig, Lift, ParamEnv, ParamEnvAnd, PolyFnSig, Predicate, Ty, TyCtxt, TypeFoldable, Variance,\n };\n@@ -44,28 +44,16 @@ fn type_op_ascribe_user_type<'tcx>(\n     tcx.infer_ctxt()\n         .enter_canonical_trait_query(&canonicalized, |infcx, fulfill_cx, key| {\n             let (\n-                param_env,\n-                AscribeUserType {\n-                    mir_ty,\n-                    variance,\n-                    def_id,\n-                    user_substs,\n-                    projs,\n-                },\n+                param_env, AscribeUserType { mir_ty, variance, def_id, user_substs, projs }\n             ) = key.into_parts();\n \n             debug!(\n-                \"type_op_ascribe_user_type(\\\n-                 mir_ty={:?}, variance={:?}, def_id={:?}, user_substs={:?}, projs={:?}\\\n-                 )\",\n-                mir_ty, variance, def_id, user_substs, projs,\n+                \"type_op_user_type_relation: mir_ty={:?} variance={:?} def_id={:?} \\\n+                 user_substs={:?} projs={:?}\",\n+                mir_ty, variance, def_id, user_substs, projs\n             );\n \n-            let mut cx = AscribeUserTypeCx {\n-                infcx,\n-                param_env,\n-                fulfill_cx,\n-            };\n+            let mut cx = AscribeUserTypeCx { infcx, param_env, fulfill_cx };\n             cx.relate_mir_and_user_ty(mir_ty, variance, def_id, user_substs, projs)?;\n \n             Ok(())\n@@ -130,10 +118,9 @@ impl AscribeUserTypeCx<'me, 'gcx, 'tcx> {\n         projs: &[ProjectionKind<'tcx>],\n     ) -> Result<(), NoSolution> {\n         let UserSubsts {\n-            substs,\n             user_self_ty,\n+            substs,\n         } = user_substs;\n-\n         let tcx = self.tcx();\n \n         let ty = tcx.type_of(def_id);\n@@ -174,8 +161,7 @@ impl AscribeUserTypeCx<'me, 'gcx, 'tcx> {\n         if let Some(UserSelfTy {\n             impl_def_id,\n             self_ty,\n-        }) = user_self_ty\n-        {\n+        }) = user_self_ty {\n             let impl_self_ty = self.tcx().type_of(impl_def_id);\n             let impl_self_ty = self.subst(impl_self_ty, &substs);\n             let impl_self_ty = self.normalize(impl_self_ty);"}, {"sha": "acb873206d5abbee8cee5d139e1b8bc61c998e4d", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 56, "deletions": 45, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/24a7a010d1015731418852d893d889f4bcbdeb51/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24a7a010d1015731418852d893d889f4bcbdeb51/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=24a7a010d1015731418852d893d889f4bcbdeb51", "patch": "@@ -102,13 +102,14 @@ use rustc::infer::type_variable::{TypeVariableOrigin};\n use rustc::middle::region;\n use rustc::mir::interpret::{ConstValue, GlobalId};\n use rustc::traits::{self, ObligationCause, ObligationCauseCode, TraitEngine};\n-use rustc::ty::{self, AdtKind, Ty, TyCtxt, GenericParamDefKind, RegionKind, Visibility,\n-                ToPolyTraitRef, ToPredicate};\n+use rustc::ty::{\n+    self, AdtKind, CanonicalUserTypeAnnotation, Ty, TyCtxt, GenericParamDefKind, Visibility,\n+    ToPolyTraitRef, ToPredicate, RegionKind, UserTypeAnnotation\n+};\n use rustc::ty::adjustment::{Adjust, Adjustment, AllowTwoPhase, AutoBorrow, AutoBorrowMutability};\n use rustc::ty::fold::TypeFoldable;\n use rustc::ty::query::Providers;\n-use rustc::ty::subst::{CanonicalUserSubsts, UnpackedKind, Subst, Substs,\n-                       UserSelfTy, UserSubsts};\n+use rustc::ty::subst::{UnpackedKind, Subst, Substs, UserSelfTy, UserSubsts};\n use rustc::ty::util::{Representability, IntTypeExt, Discr};\n use rustc::ty::layout::VariantIdx;\n use syntax_pos::{self, BytePos, Span, MultiSpan};\n@@ -974,10 +975,12 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for GatherLocalsVisitor<'a, 'gcx, 'tcx> {\n                     o_ty\n                 };\n \n-                let c_ty = self.fcx.inh.infcx.canonicalize_user_type_annotation(&revealed_ty);\n+                let c_ty = self.fcx.inh.infcx.canonicalize_user_type_annotation(\n+                    &UserTypeAnnotation::Ty(revealed_ty)\n+                );\n                 debug!(\"visit_local: ty.hir_id={:?} o_ty={:?} revealed_ty={:?} c_ty={:?}\",\n                        ty.hir_id, o_ty, revealed_ty, c_ty);\n-                self.fcx.tables.borrow_mut().user_provided_tys_mut().insert(ty.hir_id, c_ty);\n+                self.fcx.tables.borrow_mut().user_provided_types_mut().insert(ty.hir_id, c_ty);\n \n                 Some(LocalTy { decl_ty: o_ty, revealed_ty })\n             },\n@@ -2108,8 +2111,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         self.tables.borrow_mut().field_indices_mut().insert(hir_id, index);\n     }\n \n-    // The NodeId and the ItemLocalId must identify the same item. We just pass\n-    // both of them for consistency checking.\n     pub fn write_method_call(&self,\n                              hir_id: hir::HirId,\n                              method: MethodCallee<'tcx>) {\n@@ -2138,23 +2139,27 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         if !method.substs.is_noop() {\n             let method_generics = self.tcx.generics_of(method.def_id);\n             if !method_generics.params.is_empty() {\n-                let user_substs = self.infcx.probe(|_| {\n-                    let just_method_substs = Substs::for_item(self.tcx, method.def_id, |param, _| {\n-                        let i = param.index as usize;\n-                        if i < method_generics.parent_count {\n-                            self.infcx.var_for_def(DUMMY_SP, param)\n-                        } else {\n-                            method.substs[i]\n-                        }\n-                    });\n-                    self.infcx.canonicalize_user_type_annotation(&UserSubsts {\n-                        substs: just_method_substs,\n+                let user_type_annotation = self.infcx.probe(|_| {\n+                    let user_substs = UserSubsts {\n+                        substs: Substs::for_item(self.tcx, method.def_id, |param, _| {\n+                            let i = param.index as usize;\n+                            if i < method_generics.parent_count {\n+                                self.infcx.var_for_def(DUMMY_SP, param)\n+                            } else {\n+                                method.substs[i]\n+                            }\n+                        }),\n                         user_self_ty: None, // not relevant here\n-                    })\n+                    };\n+\n+                    self.infcx.canonicalize_user_type_annotation(&UserTypeAnnotation::TypeOf(\n+                        method.def_id,\n+                        user_substs,\n+                    ))\n                 });\n \n-                debug!(\"write_method_call: user_substs = {:?}\", user_substs);\n-                self.write_user_substs(hir_id, user_substs);\n+                debug!(\"write_method_call: user_type_annotation={:?}\", user_type_annotation);\n+                self.write_user_type_annotation(hir_id, user_type_annotation);\n             }\n         }\n     }\n@@ -2177,41 +2182,47 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     /// This should be invoked **before any unifications have\n     /// occurred**, so that annotations like `Vec<_>` are preserved\n     /// properly.\n-    pub fn write_user_substs_from_substs(\n+    pub fn write_user_type_annotation_from_substs(\n         &self,\n         hir_id: hir::HirId,\n+        def_id: DefId,\n         substs: &'tcx Substs<'tcx>,\n         user_self_ty: Option<UserSelfTy<'tcx>>,\n     ) {\n         debug!(\n-            \"write_user_substs_from_substs({:?}, {:?}) in fcx {}\",\n-            hir_id,\n-            substs,\n-            self.tag(),\n+            \"write_user_type_annotation_from_substs: hir_id={:?} def_id={:?} substs={:?} \\\n+             user_self_ty={:?} in fcx {}\",\n+            hir_id, def_id, substs, user_self_ty, self.tag(),\n         );\n \n         if !substs.is_noop() {\n-            let user_substs = self.infcx.canonicalize_user_type_annotation(&UserSubsts {\n-                substs,\n-                user_self_ty,\n-            });\n-            debug!(\"instantiate_value_path: user_substs = {:?}\", user_substs);\n-            self.write_user_substs(hir_id, user_substs);\n+            let canonicalized = self.infcx.canonicalize_user_type_annotation(\n+                &UserTypeAnnotation::TypeOf(def_id, UserSubsts {\n+                    substs,\n+                    user_self_ty,\n+                })\n+            );\n+            debug!(\"write_user_type_annotation_from_substs: canonicalized={:?}\", canonicalized);\n+            self.write_user_type_annotation(hir_id, canonicalized);\n         }\n     }\n \n-    pub fn write_user_substs(&self, hir_id: hir::HirId, substs: CanonicalUserSubsts<'tcx>) {\n+    pub fn write_user_type_annotation(\n+        &self,\n+        hir_id: hir::HirId,\n+        canonical_user_type_annotation: CanonicalUserTypeAnnotation<'tcx>,\n+    ) {\n         debug!(\n-            \"write_user_substs({:?}, {:?}) in fcx {}\",\n-            hir_id,\n-            substs,\n-            self.tag(),\n+            \"write_user_type_annotation: hir_id={:?} canonical_user_type_annotation={:?} tag={}\",\n+            hir_id, canonical_user_type_annotation, self.tag(),\n         );\n \n-        if !substs.is_identity() {\n-            self.tables.borrow_mut().user_substs_mut().insert(hir_id, substs);\n+        if !canonical_user_type_annotation.is_identity() {\n+            self.tables.borrow_mut().user_provided_types_mut().insert(\n+                hir_id, canonical_user_type_annotation\n+            );\n         } else {\n-            debug!(\"write_user_substs: skipping identity substs\");\n+            debug!(\"write_user_type_annotation: skipping identity substs\");\n         }\n     }\n \n@@ -2386,8 +2397,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // although I have my doubts). Other sorts of things are\n         // already sufficiently enforced with erased regions. =)\n         if ty.has_free_regions() || ty.has_projections() {\n-            let c_ty = self.infcx.canonicalize_response(&ty);\n-            self.tables.borrow_mut().user_provided_tys_mut().insert(ast_ty.hir_id, c_ty);\n+            let c_ty = self.infcx.canonicalize_response(&UserTypeAnnotation::Ty(ty));\n+            self.tables.borrow_mut().user_provided_types_mut().insert(ast_ty.hir_id, c_ty);\n         }\n \n         ty\n@@ -3734,7 +3745,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         if let Some((variant, did, substs)) = variant {\n             debug!(\"check_struct_path: did={:?} substs={:?}\", did, substs);\n             let hir_id = self.tcx.hir().node_to_hir_id(node_id);\n-            self.write_user_substs_from_substs(hir_id, substs, None);\n+            self.write_user_type_annotation_from_substs(hir_id, did, substs, None);\n \n             // Check bounds on type arguments used in the path.\n             let bounds = self.instantiate_bounds(path_span, did, substs);\n@@ -5290,7 +5301,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         // First, store the \"user substs\" for later.\n         let hir_id = tcx.hir().node_to_hir_id(node_id);\n-        self.write_user_substs_from_substs(hir_id, substs, user_self_ty);\n+        self.write_user_type_annotation_from_substs(hir_id, def_id, substs, user_self_ty);\n \n         // Add all the obligations that are required, substituting and\n         // normalized appropriately."}, {"sha": "53ea497f01add592b772527e762a2e759cbb904a", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 11, "deletions": 18, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/24a7a010d1015731418852d893d889f4bcbdeb51/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24a7a010d1015731418852d893d889f4bcbdeb51/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=24a7a010d1015731418852d893d889f4bcbdeb51", "patch": "@@ -357,7 +357,7 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n         debug_assert_eq!(fcx_tables.local_id_root, self.tables.local_id_root);\n         let common_local_id_root = fcx_tables.local_id_root.unwrap();\n \n-        for (&local_id, c_ty) in fcx_tables.user_provided_tys().iter() {\n+        for (&local_id, c_ty) in fcx_tables.user_provided_types().iter() {\n             let hir_id = hir::HirId {\n                 owner: common_local_id_root.index,\n                 local_id,\n@@ -374,8 +374,17 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n             };\n \n             self.tables\n-                .user_provided_tys_mut()\n+                .user_provided_types_mut()\n                 .insert(hir_id, c_ty.clone());\n+\n+            if let ty::UserTypeAnnotation::TypeOf(_, user_substs) = c_ty.value {\n+                if self.rustc_dump_user_substs {\n+                    // This is a unit-testing mechanism.\n+                    let node_id = self.tcx().hir().hir_to_node_id(hir_id);\n+                    let span = self.tcx().hir().span(node_id);\n+                    self.tcx().sess.span_err(span, &format!(\"user substs: {:?}\", user_substs));\n+                }\n+            }\n         }\n     }\n \n@@ -573,22 +582,6 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n             assert!(!substs.needs_infer() && !substs.has_placeholders());\n             self.tables.node_substs_mut().insert(hir_id, substs);\n         }\n-\n-        // Copy over any user-substs\n-        if let Some(user_substs) = self.fcx.tables.borrow().user_substs(hir_id) {\n-            let user_substs = self.tcx().lift_to_global(&user_substs).unwrap();\n-            self.tables.user_substs_mut().insert(hir_id, user_substs);\n-\n-            // Unit-testing mechanism:\n-            if self.rustc_dump_user_substs {\n-                let node_id = self.tcx().hir().hir_to_node_id(hir_id);\n-                let span = self.tcx().hir().span(node_id);\n-                self.tcx().sess.span_err(\n-                    span,\n-                    &format!(\"user substs: {:?}\", user_substs),\n-                );\n-            }\n-        }\n     }\n \n     fn visit_adjustments(&mut self, span: Span, hir_id: hir::HirId) {"}, {"sha": "88fd53d4ba59d3feb878618276ba80d84ac67272", "filename": "src/test/mir-opt/basic_assignment.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24a7a010d1015731418852d893d889f4bcbdeb51/src%2Ftest%2Fmir-opt%2Fbasic_assignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24a7a010d1015731418852d893d889f4bcbdeb51/src%2Ftest%2Fmir-opt%2Fbasic_assignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fbasic_assignment.rs?ref=24a7a010d1015731418852d893d889f4bcbdeb51", "patch": "@@ -37,7 +37,7 @@ fn main() {\n //        StorageLive(_4);\n //        _4 = std::option::Option<std::boxed::Box<u32>>::None;\n //        FakeRead(ForLet, _4);\n-//        AscribeUserType(_4, o, UserTypeProjection { base: Ty(Canonical { max_universe: U0, variables: [], value: std::option::Option<std::boxed::Box<u32>> }), projs: [] });\n+//        AscribeUserType(_4, o, UserTypeProjection { base: UserTypeAnnotation(1), projs: [] });\n //        StorageLive(_5);\n //        StorageLive(_6);\n //        _6 = move _4;"}, {"sha": "123c26195d006aadda51d2ec790a201e0f905caf", "filename": "src/test/ui/nll/user-annotations/dump-adt-brace-struct.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24a7a010d1015731418852d893d889f4bcbdeb51/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fdump-adt-brace-struct.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/24a7a010d1015731418852d893d889f4bcbdeb51/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fdump-adt-brace-struct.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fdump-adt-brace-struct.stderr?ref=24a7a010d1015731418852d893d889f4bcbdeb51", "patch": "@@ -1,4 +1,4 @@\n-error: user substs: Canonical { max_universe: U0, variables: [], value: UserSubsts { substs: [u32], user_self_ty: None } }\n+error: user substs: UserSubsts { substs: [u32], user_self_ty: None }\n   --> $DIR/dump-adt-brace-struct.rs:18:5\n    |\n LL |     SomeStruct::<u32> { t: 22 }; //~ ERROR [u32]"}, {"sha": "fc4544437c5b1c2e278255b1ba833946b8ca8c45", "filename": "src/test/ui/nll/user-annotations/dump-fn-method.stderr", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/24a7a010d1015731418852d893d889f4bcbdeb51/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fdump-fn-method.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/24a7a010d1015731418852d893d889f4bcbdeb51/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fdump-fn-method.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fdump-fn-method.stderr?ref=24a7a010d1015731418852d893d889f4bcbdeb51", "patch": "@@ -1,26 +1,26 @@\n-error: user substs: Canonical { max_universe: U0, variables: [], value: UserSubsts { substs: [u32], user_self_ty: None } }\n-  --> $DIR/dump-fn-method.rs:26:13\n+error: user substs: UserSubsts { substs: [^0, ^1, u32], user_self_ty: None }\n+  --> $DIR/dump-fn-method.rs:44:5\n    |\n-LL |     let x = foo::<u32>; //~ ERROR [u32]\n-   |             ^^^^^^^^^^\n+LL |     y.method::<u32>(44, 66); //~ ERROR [^0, ^1, u32]\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: user substs: Canonical { max_universe: U0, variables: [CanonicalVarInfo { kind: Ty(General(U0)) }, CanonicalVarInfo { kind: Ty(General(U0)) }], value: UserSubsts { substs: [^0, u32, ^1], user_self_ty: None } }\n+error: user substs: UserSubsts { substs: [^0, u32, ^1], user_self_ty: None }\n   --> $DIR/dump-fn-method.rs:32:13\n    |\n LL |     let x = <_ as Bazoom<u32>>::method::<_>; //~ ERROR [^0, u32, ^1]\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: user substs: Canonical { max_universe: U0, variables: [], value: UserSubsts { substs: [u8, u16, u32], user_self_ty: None } }\n+error: user substs: UserSubsts { substs: [u8, u16, u32], user_self_ty: None }\n   --> $DIR/dump-fn-method.rs:36:13\n    |\n LL |     let x = <u8 as Bazoom<u16>>::method::<u32>; //~ ERROR [u8, u16, u32]\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: user substs: Canonical { max_universe: U0, variables: [CanonicalVarInfo { kind: Ty(General(U0)) }, CanonicalVarInfo { kind: Ty(General(U0)) }], value: UserSubsts { substs: [^0, ^1, u32], user_self_ty: None } }\n-  --> $DIR/dump-fn-method.rs:44:5\n+error: user substs: UserSubsts { substs: [u32], user_self_ty: None }\n+  --> $DIR/dump-fn-method.rs:26:13\n    |\n-LL |     y.method::<u32>(44, 66); //~ ERROR [^0, ^1, u32]\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     let x = foo::<u32>; //~ ERROR [u32]\n+   |             ^^^^^^^^^^\n \n error: aborting due to 4 previous errors\n "}]}