{"sha": "b2ec71fc277ca590bb8bd26d3f7762d6406860e5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIyZWM3MWZjMjc3Y2E1OTBiYjhiZDI2ZDNmNzc2MmQ2NDA2ODYwZTU=", "commit": {"author": {"name": "Daniel Micay", "email": "danielmicay@gmail.com", "date": "2014-01-18T12:33:41Z"}, "committer": {"name": "Daniel Micay", "email": "danielmicay@gmail.com", "date": "2014-01-23T04:13:57Z"}, "message": "hashmap: port to Vec<T>", "tree": {"sha": "0ffc79e69f1f14fb2b9edd31d6cd08dcc765cc58", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0ffc79e69f1f14fb2b9edd31d6cd08dcc765cc58"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b2ec71fc277ca590bb8bd26d3f7762d6406860e5", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b2ec71fc277ca590bb8bd26d3f7762d6406860e5", "html_url": "https://github.com/rust-lang/rust/commit/b2ec71fc277ca590bb8bd26d3f7762d6406860e5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b2ec71fc277ca590bb8bd26d3f7762d6406860e5/comments", "author": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "committer": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1798de7d08a7f20da08a1aad7d5c5216a75bf4ed", "url": "https://api.github.com/repos/rust-lang/rust/commits/1798de7d08a7f20da08a1aad7d5c5216a75bf4ed", "html_url": "https://github.com/rust-lang/rust/commit/1798de7d08a7f20da08a1aad7d5c5216a75bf4ed"}], "stats": {"total": 50, "additions": 25, "deletions": 25}, "files": [{"sha": "13a03d3252514d378c6d3cdb76b0909fc48d8565", "filename": "src/libstd/hashmap.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/b2ec71fc277ca590bb8bd26d3f7762d6406860e5/src%2Flibstd%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ec71fc277ca590bb8bd26d3f7762d6406860e5/src%2Flibstd%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fhashmap.rs?ref=b2ec71fc277ca590bb8bd26d3f7762d6406860e5", "patch": "@@ -66,8 +66,9 @@ use rand::Rng;\n use rand;\n use uint;\n use util::replace;\n-use vec::{ImmutableVector, MutableVector, OwnedVector};\n-use vec;\n+use vec::{ImmutableVector, MutableVector, OwnedVector, Items, MutItems};\n+use vec_ng;\n+use vec_ng::Vec;\n \n static INITIAL_CAPACITY: uint = 32u; // 2^5\n \n@@ -90,7 +91,7 @@ pub struct HashMap<K,V> {\n     priv k1: u64,\n     priv resize_at: uint,\n     priv size: uint,\n-    priv buckets: ~[Option<Bucket<K, V>>],\n+    priv buckets: Vec<Option<Bucket<K, V>>>\n }\n \n // We could rewrite FoundEntry to have type Option<&Bucket<K, V>>\n@@ -151,7 +152,7 @@ impl<K:Hash + Eq,V> HashMap<K, V> {\n                              -> SearchResult {\n         let mut ret = TableFull;\n         self.bucket_sequence(hash, |i| {\n-            match self.buckets[i] {\n+            match self.buckets.as_slice()[i] {\n                 Some(ref bkt) if bkt.hash == hash && *k == bkt.key => {\n                     ret = FoundEntry(i); false\n                 },\n@@ -169,7 +170,7 @@ impl<K:Hash + Eq,V> HashMap<K, V> {\n                                                -> SearchResult {\n         let mut ret = TableFull;\n         self.bucket_sequence(hash, |i| {\n-            match self.buckets[i] {\n+            match self.buckets.as_slice()[i] {\n                 Some(ref bkt) if bkt.hash == hash && k.equiv(&bkt.key) => {\n                     ret = FoundEntry(i); false\n                 },\n@@ -194,7 +195,7 @@ impl<K:Hash + Eq,V> HashMap<K, V> {\n         self.resize_at = resize_at(new_capacity);\n \n         let old_buckets = replace(&mut self.buckets,\n-                                  vec::from_fn(new_capacity, |_| None));\n+                                  Vec::from_fn(new_capacity, |_| None));\n \n         self.size = 0;\n         for bucket in old_buckets.move_iter() {\n@@ -213,15 +214,15 @@ impl<K:Hash + Eq,V> HashMap<K, V> {\n \n     #[inline]\n     fn value_for_bucket<'a>(&'a self, idx: uint) -> &'a V {\n-        match self.buckets[idx] {\n+        match self.buckets.as_slice()[idx] {\n             Some(ref bkt) => &bkt.value,\n             None => fail!(\"HashMap::find: internal logic error\"),\n         }\n     }\n \n     #[inline]\n     fn mut_value_for_bucket<'a>(&'a mut self, idx: uint) -> &'a mut V {\n-        match self.buckets[idx] {\n+        match self.buckets.as_mut_slice()[idx] {\n             Some(ref mut bkt) => &mut bkt.value,\n             None => unreachable!()\n         }\n@@ -234,13 +235,12 @@ impl<K:Hash + Eq,V> HashMap<K, V> {\n         match self.bucket_for_key_with_hash(hash, &k) {\n             TableFull => { fail!(\"Internal logic error\"); }\n             FoundHole(idx) => {\n-                self.buckets[idx] = Some(Bucket{hash: hash, key: k,\n-                                                value: v});\n+                self.buckets.as_mut_slice()[idx] = Some(Bucket{hash: hash, key: k, value: v});\n                 self.size += 1;\n                 None\n             }\n             FoundEntry(idx) => {\n-                match self.buckets[idx] {\n+                match self.buckets.as_mut_slice()[idx] {\n                     None => { fail!(\"insert_internal: Internal logic error\") }\n                     Some(ref mut b) => {\n                         b.hash = hash;\n@@ -273,16 +273,16 @@ impl<K:Hash + Eq,V> HashMap<K, V> {\n         };\n \n         let len_buckets = self.buckets.len();\n-        let bucket = self.buckets[idx].take();\n+        let bucket = self.buckets.as_mut_slice()[idx].take();\n \n         let value = bucket.map(|bucket| bucket.value);\n \n         /* re-inserting buckets may cause changes in size, so remember\n         what our new size is ahead of time before we start insertions */\n         let size = self.size - 1;\n         idx = self.next_bucket(idx, len_buckets);\n-        while self.buckets[idx].is_some() {\n-            let bucket = self.buckets[idx].take();\n+        while self.buckets.as_slice()[idx].is_some() {\n+            let bucket = self.buckets.as_mut_slice()[idx].take();\n             self.insert_opt_bucket(bucket);\n             idx = self.next_bucket(idx, len_buckets);\n         }\n@@ -300,7 +300,7 @@ impl<K:Hash + Eq,V> Container for HashMap<K, V> {\n impl<K:Hash + Eq,V> Mutable for HashMap<K, V> {\n     /// Clear the map, removing all key-value pairs.\n     fn clear(&mut self) {\n-        for bkt in self.buckets.mut_iter() {\n+        for bkt in self.buckets.as_mut_slice().mut_iter() {\n             *bkt = None;\n         }\n         self.size = 0;\n@@ -380,7 +380,7 @@ impl<K: Hash + Eq, V> HashMap<K, V> {\n             k0: k0, k1: k1,\n             resize_at: resize_at(cap),\n             size: 0,\n-            buckets: vec::from_fn(cap, |_| None)\n+            buckets: Vec::from_fn(cap, |_| None)\n         }\n     }\n \n@@ -455,7 +455,7 @@ impl<K: Hash + Eq, V> HashMap<K, V> {\n             FoundEntry(idx) => { found(&k, self.mut_value_for_bucket(idx), a); idx }\n             FoundHole(idx) => {\n                 let v = not_found(&k, a);\n-                self.buckets[idx] = Some(Bucket{hash: hash, key: k, value: v});\n+                self.buckets.as_mut_slice()[idx] = Some(Bucket{hash: hash, key: k, value: v});\n                 self.size += 1;\n                 idx\n             }\n@@ -541,14 +541,14 @@ impl<K: Hash + Eq, V> HashMap<K, V> {\n     /// An iterator visiting all key-value pairs in arbitrary order.\n     /// Iterator element type is (&'a K, &'a V).\n     pub fn iter<'a>(&'a self) -> Entries<'a, K, V> {\n-        Entries { iter: self.buckets.iter() }\n+        Entries { iter: self.buckets.as_slice().iter() }\n     }\n \n     /// An iterator visiting all key-value pairs in arbitrary order,\n     /// with mutable references to the values.\n     /// Iterator element type is (&'a K, &'a mut V).\n     pub fn mut_iter<'a>(&'a mut self) -> MutEntries<'a, K, V> {\n-        MutEntries { iter: self.buckets.mut_iter() }\n+        MutEntries { iter: self.buckets.as_mut_slice().mut_iter() }\n     }\n \n     /// Creates a consuming iterator, that is, one that moves each key-value\n@@ -599,17 +599,17 @@ impl<K:Hash + Eq + Clone,V:Clone> Clone for HashMap<K,V> {\n /// HashMap iterator\n #[deriving(Clone)]\n pub struct Entries<'a, K, V> {\n-    priv iter: vec::Items<'a, Option<Bucket<K, V>>>,\n+    priv iter: Items<'a, Option<Bucket<K, V>>>,\n }\n \n /// HashMap mutable values iterator\n pub struct MutEntries<'a, K, V> {\n-    priv iter: vec::MutItems<'a, Option<Bucket<K, V>>>,\n+    priv iter: MutItems<'a, Option<Bucket<K, V>>>,\n }\n \n /// HashMap move iterator\n pub struct MoveEntries<K, V> {\n-    priv iter: vec::MoveItems<Option<Bucket<K, V>>>,\n+    priv iter: vec_ng::MoveItems<Option<Bucket<K, V>>>,\n }\n \n /// HashMap keys iterator\n@@ -623,12 +623,12 @@ pub type Values<'a, K, V> =\n /// HashSet iterator\n #[deriving(Clone)]\n pub struct SetItems<'a, K> {\n-    priv iter: vec::Items<'a, Option<Bucket<K, ()>>>,\n+    priv iter: Items<'a, Option<Bucket<K, ()>>>,\n }\n \n /// HashSet move iterator\n pub struct SetMoveItems<K> {\n-    priv iter: vec::MoveItems<Option<Bucket<K, ()>>>,\n+    priv iter: vec_ng::MoveItems<Option<Bucket<K, ()>>>,\n }\n \n impl<'a, K, V> Iterator<(&'a K, &'a V)> for Entries<'a, K, V> {\n@@ -807,7 +807,7 @@ impl<T:Hash + Eq> HashSet<T> {\n     /// An iterator visiting all elements in arbitrary order.\n     /// Iterator element type is &'a T.\n     pub fn iter<'a>(&'a self) -> SetItems<'a, T> {\n-        SetItems { iter: self.map.buckets.iter() }\n+        SetItems { iter: self.map.buckets.as_slice().iter() }\n     }\n \n     /// Creates a consuming iterator, that is, one that moves each value out"}]}