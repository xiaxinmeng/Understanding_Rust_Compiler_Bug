{"sha": "daf3094958cbf69b0e179a0c7320ad8ef63fe347", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRhZjMwOTQ5NThjYmY2OWIwZTE3OWEwYzczMjBhZDhlZjYzZmUzNDc=", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-08-17T13:24:01Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-08-17T13:24:01Z"}, "message": "Emit more concise text edits in ide_db::rename", "tree": {"sha": "95deee23a94bff6003573e1b88a0308102e4bcda", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/95deee23a94bff6003573e1b88a0308102e4bcda"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/daf3094958cbf69b0e179a0c7320ad8ef63fe347", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/daf3094958cbf69b0e179a0c7320ad8ef63fe347", "html_url": "https://github.com/rust-lang/rust/commit/daf3094958cbf69b0e179a0c7320ad8ef63fe347", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/daf3094958cbf69b0e179a0c7320ad8ef63fe347/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "995c8f50a2a544da56f8320d33d44b1ab57f0935", "url": "https://api.github.com/repos/rust-lang/rust/commits/995c8f50a2a544da56f8320d33d44b1ab57f0935", "html_url": "https://github.com/rust-lang/rust/commit/995c8f50a2a544da56f8320d33d44b1ab57f0935"}], "stats": {"total": 92, "additions": 47, "deletions": 45}, "files": [{"sha": "9d452f40baee509588932e0183ea24041cca03f4", "filename": "crates/ide/src/rename.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/daf3094958cbf69b0e179a0c7320ad8ef63fe347/crates%2Fide%2Fsrc%2Frename.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf3094958cbf69b0e179a0c7320ad8ef63fe347/crates%2Fide%2Fsrc%2Frename.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Frename.rs?ref=daf3094958cbf69b0e179a0c7320ad8ef63fe347", "patch": "@@ -274,6 +274,7 @@ mod tests {\n \n     use super::{RangeInfo, RenameError};\n \n+    #[track_caller]\n     fn check(new_name: &str, ra_fixture_before: &str, ra_fixture_after: &str) {\n         let ra_fixture_after = &trim_indent(ra_fixture_after);\n         let (analysis, position) = fixture::position(ra_fixture_before);"}, {"sha": "ef8b31ba5fa78c2bedfeaa9f000c3e9b2c892deb", "filename": "crates/ide_db/src/rename.rs", "status": "modified", "additions": 46, "deletions": 45, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/daf3094958cbf69b0e179a0c7320ad8ef63fe347/crates%2Fide_db%2Fsrc%2Frename.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf3094958cbf69b0e179a0c7320ad8ef63fe347/crates%2Fide_db%2Fsrc%2Frename.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Frename.rs?ref=daf3094958cbf69b0e179a0c7320ad8ef63fe347", "patch": "@@ -30,7 +30,7 @@ use syntax::{\n     ast::{self, NameOwner},\n     lex_single_syntax_kind, AstNode, SyntaxKind, TextRange, T,\n };\n-use text_edit::TextEdit;\n+use text_edit::{TextEdit, TextEditBuilder};\n \n use crate::{\n     defs::Definition,\n@@ -303,28 +303,29 @@ pub fn source_edit_from_references(\n ) -> TextEdit {\n     let mut edit = TextEdit::builder();\n     for reference in references {\n-        let (range, replacement) = match &reference.name {\n+        let has_emitted_edit = match &reference.name {\n             // if the ranges differ then the node is inside a macro call, we can't really attempt\n             // to make special rewrites like shorthand syntax and such, so just rename the node in\n             // the macro input\n             ast::NameLike::NameRef(name_ref)\n                 if name_ref.syntax().text_range() == reference.range =>\n             {\n-                source_edit_from_name_ref(name_ref, new_name, def)\n+                source_edit_from_name_ref(&mut edit, name_ref, new_name, def)\n             }\n             ast::NameLike::Name(name) if name.syntax().text_range() == reference.range => {\n-                source_edit_from_name(name, new_name)\n+                source_edit_from_name(&mut edit, name, new_name)\n             }\n-            _ => None,\n+            _ => false,\n+        };\n+        if !has_emitted_edit {\n+            edit.replace(reference.range, new_name.to_string());\n         }\n-        .unwrap_or_else(|| (reference.range, new_name.to_string()));\n-        edit.replace(range, replacement);\n     }\n \n     edit.finish()\n }\n \n-fn source_edit_from_name(name: &ast::Name, new_name: &str) -> Option<(TextRange, String)> {\n+fn source_edit_from_name(edit: &mut TextEditBuilder, name: &ast::Name, new_name: &str) -> bool {\n     if let Some(_) = ast::RecordPatField::for_field_name(name) {\n         if let Some(ident_pat) = name.syntax().parent().and_then(ast::IdentPat::cast) {\n             cov_mark::hit!(rename_record_pat_field_name_split);\n@@ -333,21 +334,20 @@ fn source_edit_from_name(name: &ast::Name, new_name: &str) -> Option<(TextRange,\n \n             // FIXME: instead of splitting the shorthand, recursively trigger a rename of the\n             // other name https://github.com/rust-analyzer/rust-analyzer/issues/6547\n-            return Some((\n-                TextRange::empty(ident_pat.syntax().text_range().start()),\n-                format!(\"{}: \", new_name),\n-            ));\n+            edit.insert(ident_pat.syntax().text_range().start(), format!(\"{}: \", new_name));\n+            return true;\n         }\n     }\n \n-    None\n+    false\n }\n \n fn source_edit_from_name_ref(\n+    edit: &mut TextEditBuilder,\n     name_ref: &ast::NameRef,\n     new_name: &str,\n     def: Definition,\n-) -> Option<(TextRange, String)> {\n+) -> bool {\n     if let Some(record_field) = ast::RecordExprField::for_name_ref(name_ref) {\n         let rcf_name_ref = record_field.name_ref();\n         let rcf_expr = record_field.expr();\n@@ -358,47 +358,48 @@ fn source_edit_from_name_ref(\n                     if init.text() == new_name {\n                         cov_mark::hit!(test_rename_field_put_init_shorthand);\n                         // Foo { field: local } -> Foo { local }\n-                        //      ^^^^^^^^ delete this\n-                        // FIXME: Actually delete this instead of replacing the entire thing\n+                        //       ^^^^^^^ delete this\n \n                         // same names, we can use a shorthand here instead.\n                         // we do not want to erase attributes hence this range start\n                         let s = field_name.syntax().text_range().start();\n-                        let e = record_field.syntax().text_range().end();\n-                        return Some((TextRange::new(s, e), new_name.to_owned()));\n+                        let e = init.syntax().text_range().start();\n+                        edit.delete(TextRange::new(s, e));\n+                        return true;\n                     }\n                 } else if init == name_ref {\n                     if field_name.text() == new_name {\n                         cov_mark::hit!(test_rename_local_put_init_shorthand);\n                         // Foo { field: local } -> Foo { field }\n                         //            ^^^^^^^ delete this\n-                        // FIXME: Actually delete this instead of replacing the entire thing\n \n                         // same names, we can use a shorthand here instead.\n                         // we do not want to erase attributes hence this range start\n-                        let s = field_name.syntax().text_range().start();\n-                        let e = record_field.syntax().text_range().end();\n-                        return Some((TextRange::new(s, e), new_name.to_owned()));\n+                        let s = field_name.syntax().text_range().end();\n+                        let e = init.syntax().text_range().end();\n+                        edit.delete(TextRange::new(s, e));\n+                        return true;\n                     }\n                 }\n-                None\n             }\n             // init shorthand\n             (None, Some(_)) if matches!(def, Definition::Field(_)) => {\n                 cov_mark::hit!(test_rename_field_in_field_shorthand);\n                 // Foo { field } -> Foo { new_name: field }\n                 //       ^ insert `new_name: `\n-                let s = name_ref.syntax().text_range().start();\n-                Some((TextRange::empty(s), format!(\"{}: \", new_name)))\n+                let offset = name_ref.syntax().text_range().start();\n+                edit.insert(offset, format!(\"{}: \", new_name));\n+                return true;\n             }\n             (None, Some(_)) if matches!(def, Definition::Local(_)) => {\n                 cov_mark::hit!(test_rename_local_in_field_shorthand);\n                 // Foo { field } -> Foo { field: new_name }\n                 //            ^ insert `: new_name`\n-                let s = name_ref.syntax().text_range().end();\n-                Some((TextRange::empty(s), format!(\": {}\", new_name)))\n+                let offset = name_ref.syntax().text_range().end();\n+                edit.insert(offset, format!(\": {}\", new_name));\n+                return true;\n             }\n-            _ => None,\n+            _ => (),\n         }\n     } else if let Some(record_field) = ast::RecordPatField::for_field_name_ref(name_ref) {\n         let rcf_name_ref = record_field.name_ref();\n@@ -409,27 +410,27 @@ fn source_edit_from_name_ref(\n                 if field_name == *name_ref && pat.at_token().is_none() =>\n             {\n                 // field name is being renamed\n-                if pat.name().map_or(false, |it| it.text() == new_name) {\n-                    cov_mark::hit!(test_rename_field_put_init_shorthand_pat);\n-                    // Foo { field: ref mut local } -> Foo { ref mut field }\n-                    //       ^^^^^^^ delete this\n-                    //                      ^^^^^ replace this with `field`\n-                    // FIXME: do this the way its written here\n-\n-                    // same names, we can use a shorthand here instead/\n-                    // we do not want to erase attributes hence this range start\n-                    let s = field_name.syntax().text_range().start();\n-                    let e = record_field.syntax().text_range().end();\n-                    Some((TextRange::new(s, e), pat.to_string()))\n-                } else {\n-                    None\n+                if let Some(name) = pat.name() {\n+                    if name.text() == new_name {\n+                        cov_mark::hit!(test_rename_field_put_init_shorthand_pat);\n+                        // Foo { field: ref mut local } -> Foo { ref mut field }\n+                        //       ^^^^^^^ delete this\n+                        //                      ^^^^^ replace this with `field`\n+\n+                        // same names, we can use a shorthand here instead/\n+                        // we do not want to erase attributes hence this range start\n+                        let s = field_name.syntax().text_range().start();\n+                        let e = pat.syntax().text_range().start();\n+                        edit.delete(TextRange::new(s, e));\n+                        edit.replace(name.syntax().text_range(), new_name.to_string());\n+                        return true;\n+                    }\n                 }\n             }\n-            _ => None,\n+            _ => (),\n         }\n-    } else {\n-        None\n     }\n+    false\n }\n \n fn source_edit_from_def("}]}