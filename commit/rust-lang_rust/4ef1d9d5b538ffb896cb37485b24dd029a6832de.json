{"sha": "4ef1d9d5b538ffb896cb37485b24dd029a6832de", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRlZjFkOWQ1YjUzOGZmYjg5NmNiMzc0ODViMjRkZDAyOWE2ODMyZGU=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-08-23T01:33:05Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-08-23T01:33:19Z"}, "message": "rustc: Remove typestate source", "tree": {"sha": "e50a4d47748fb282dc3864c84157a84443d7de7c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e50a4d47748fb282dc3864c84157a84443d7de7c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4ef1d9d5b538ffb896cb37485b24dd029a6832de", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4ef1d9d5b538ffb896cb37485b24dd029a6832de", "html_url": "https://github.com/rust-lang/rust/commit/4ef1d9d5b538ffb896cb37485b24dd029a6832de", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4ef1d9d5b538ffb896cb37485b24dd029a6832de/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "95bc9d4aef56d656e6dde057c0c9e8347b4d6e7e", "url": "https://api.github.com/repos/rust-lang/rust/commits/95bc9d4aef56d656e6dde057c0c9e8347b4d6e7e", "html_url": "https://github.com/rust-lang/rust/commit/95bc9d4aef56d656e6dde057c0c9e8347b4d6e7e"}], "stats": {"total": 3151, "additions": 0, "deletions": 3151}, "files": [{"sha": "19a2ca1572366d84176a8491999f52465c3193aa", "filename": "src/rustc/middle/tstate/ann.rs", "status": "removed", "additions": 0, "deletions": 257, "changes": 257, "blob_url": "https://github.com/rust-lang/rust/blob/95bc9d4aef56d656e6dde057c0c9e8347b4d6e7e/src%2Frustc%2Fmiddle%2Ftstate%2Fann.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95bc9d4aef56d656e6dde057c0c9e8347b4d6e7e/src%2Frustc%2Fmiddle%2Ftstate%2Fann.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftstate%2Fann.rs?ref=95bc9d4aef56d656e6dde057c0c9e8347b4d6e7e", "patch": "@@ -1,257 +0,0 @@\n-\n-import tritv::*;\n-\n-type precond = t;\n-\n-/* 2 means \"this constraint may or may not be true after execution\"\n-   1 means \"this constraint is definitely true after execution\"\n-   0 means \"this constraint is definitely false after execution\" */\n-type postcond = t;\n-\n-\n-/* 2 means \"don't know about this constraint\"\n-   1 means \"this constraint is definitely true before entry\"\n-   0 means \"this constraint is definitely false on entry\" */\n-type prestate = t;\n-\n-\n-/* similar to postcond */\n-type poststate = t;\n-\n-\n-/* 1 means \"this variable is definitely initialized\"\n-  0 means \"don't know whether this variable is\n-  initialized\" */\n-\n-/*\n-   This says: this expression requires the constraints whose value is 1 in\n-   <pre> to be true, and given the precondition, it guarantees that the\n-   constraints in <post> whose values are 1 are true, and that the constraints\n-   in <post> whose values are 0 are false.\n- */\n-\n-/* named thus so as not to confuse with prestate and poststate */\n-type pre_and_post = {precondition: precond, postcondition: postcond};\n-\n-\n-/* FIXME: once it's implemented: (Issue #34) */\n-\n-//  : ((*.precondition).nbits == (*.postcondition).nbits);\n-type pre_and_post_state = {prestate: prestate, poststate: poststate};\n-\n-type ts_ann = {conditions: pre_and_post, states: pre_and_post_state};\n-\n-fn true_precond(num_vars: uint) -> precond { return create_tritv(num_vars); }\n-\n-fn true_postcond(num_vars: uint) -> postcond {\n-    return true_precond(num_vars);\n-}\n-\n-fn empty_prestate(num_vars: uint) -> prestate {\n-    return true_precond(num_vars);\n-}\n-\n-fn empty_poststate(num_vars: uint) -> poststate {\n-    return true_precond(num_vars);\n-}\n-\n-fn false_postcond(num_vars: uint) -> postcond {\n-    let rslt = create_tritv(num_vars);\n-    rslt.set_all();\n-    rslt\n-}\n-\n-fn empty_pre_post(num_vars: uint) -> pre_and_post {\n-    return {precondition: empty_prestate(num_vars),\n-         postcondition: empty_poststate(num_vars)};\n-}\n-\n-fn empty_states(num_vars: uint) -> pre_and_post_state {\n-    return {prestate: true_precond(num_vars),\n-         poststate: true_postcond(num_vars)};\n-}\n-\n-fn empty_ann(num_vars: uint) -> ts_ann {\n-    return {conditions: empty_pre_post(num_vars),\n-         states: empty_states(num_vars)};\n-}\n-\n-fn get_pre(&&p: pre_and_post) -> precond { return p.precondition; }\n-\n-fn get_post(&&p: pre_and_post) -> postcond { return p.postcondition; }\n-\n-fn difference(p1: precond, p2: precond) -> bool { p1.difference(p2) }\n-\n-fn union(p1: precond, p2: precond) -> bool { p1.union(p2) }\n-\n-fn intersect(p1: precond, p2: precond) -> bool { p1.intersect(p2) }\n-\n-fn pps_len(p: pre_and_post) -> uint {\n-    // gratuitous check\n-\n-    assert (p.precondition.nbits == p.postcondition.nbits);\n-    return p.precondition.nbits;\n-}\n-\n-fn require(i: uint, p: pre_and_post) {\n-    // sets the ith bit in p's pre\n-    p.precondition.set(i, ttrue);\n-}\n-\n-fn require_and_preserve(i: uint, p: pre_and_post) {\n-    // sets the ith bit in p's pre and post\n-    p.precondition.set(i, ttrue);\n-    p.postcondition.set(i, ttrue);\n-}\n-\n-fn set_in_postcond(i: uint, p: pre_and_post) -> bool {\n-    // sets the ith bit in p's post\n-    return set_in_postcond_(i, p.postcondition);\n-}\n-\n-fn set_in_postcond_(i: uint, p: postcond) -> bool {\n-    let was_set = p.get(i);\n-    p.set(i, ttrue);\n-    return was_set != ttrue;\n-}\n-\n-fn set_in_poststate(i: uint, s: pre_and_post_state) -> bool {\n-    // sets the ith bit in p's post\n-    return set_in_poststate_(i, s.poststate);\n-}\n-\n-fn set_in_poststate_(i: uint, p: poststate) -> bool {\n-    let was_set = p.get(i);\n-    p.set(i, ttrue);\n-    return was_set != ttrue;\n-\n-}\n-\n-fn clear_in_poststate(i: uint, s: pre_and_post_state) -> bool {\n-    // sets the ith bit in p's post\n-    return clear_in_poststate_(i, s.poststate);\n-}\n-\n-fn clear_in_poststate_(i: uint, s: poststate) -> bool {\n-    let was_set = s.get(i);\n-    s.set(i, tfalse);\n-    return was_set != tfalse;\n-}\n-\n-fn clear_in_prestate(i: uint, s: pre_and_post_state) -> bool {\n-    // sets the ith bit in p's pre\n-    return clear_in_prestate_(i, s.prestate);\n-}\n-\n-fn clear_in_prestate_(i: uint, s: prestate) -> bool {\n-    let was_set = s.get(i);\n-    s.set(i, tfalse);\n-    return was_set != tfalse;\n-}\n-\n-fn clear_in_postcond(i: uint, s: pre_and_post) -> bool {\n-    // sets the ith bit in p's post\n-    let was_set = s.postcondition.get(i);\n-    s.postcondition.set(i, tfalse);\n-    return was_set != tfalse;\n-}\n-\n-// Sets all the bits in a's precondition to equal the\n-// corresponding bit in p's precondition.\n-fn set_precondition(a: ts_ann, p: precond) {\n-    a.conditions.precondition.become(p);\n-}\n-\n-\n-// Sets all the bits in a's postcondition to equal the\n-// corresponding bit in p's postcondition.\n-fn set_postcondition(a: ts_ann, p: postcond) {\n-    a.conditions.postcondition.become(p);\n-}\n-\n-\n-// Sets all the bits in a's prestate to equal the\n-// corresponding bit in p's prestate.\n-fn set_prestate(a: ts_ann, p: prestate) -> bool {\n-    a.states.prestate.become(p)\n-}\n-\n-\n-// Sets all the bits in a's postcondition to equal the\n-// corresponding bit in p's postcondition.\n-fn set_poststate(a: ts_ann, p: poststate) -> bool {\n-    a.states.poststate.become(p)\n-}\n-\n-\n-// Set all the bits in p that are set in new\n-fn extend_prestate(p: prestate, newv: poststate) -> bool {\n-    p.union(newv)\n-}\n-\n-\n-// Set all the bits in p that are set in new\n-fn extend_poststate(p: poststate, newv: poststate) -> bool {\n-    p.union(newv)\n-}\n-\n-// Sets the given bit in p to \"don't care\"\n-fn relax_prestate(i: uint, p: prestate) -> bool {\n-    let was_set = p.get(i);\n-    p.set(i, dont_care);\n-    return was_set != dont_care;\n-}\n-\n-// Clears the given bit in p\n-fn relax_poststate(i: uint, p: poststate) -> bool {\n-    return relax_prestate(i, p);\n-}\n-\n-// Clears the given bit in p\n-fn relax_precond(i: uint, p: precond) { relax_prestate(i, p); }\n-\n-// Sets all the bits in p to \"don't care\"\n-fn clear(p: precond) { p.clear(); }\n-\n-// Sets all the bits in p to true\n-fn set(p: precond) { p.set_all(); }\n-\n-fn ann_precond(a: ts_ann) -> precond { return a.conditions.precondition; }\n-\n-fn ann_prestate(a: ts_ann) -> prestate { return a.states.prestate; }\n-\n-fn ann_poststate(a: ts_ann) -> poststate { return a.states.poststate; }\n-\n-fn pp_clone(p: pre_and_post) -> pre_and_post {\n-    return {precondition: clone(p.precondition),\n-         postcondition: clone(p.postcondition)};\n-}\n-\n-fn clone(p: prestate) -> prestate { p.clone() }\n-\n-\n-// returns true if a implies b\n-// that is, returns true except if for some bits c and d,\n-// c = 1 and d = either 0 or \"don't know\"\n-fn implies(a: t, b: t) -> bool {\n-    let tmp = b.clone();\n-    tmp.difference(a);\n-    tmp.doesntcare()\n-}\n-\n-fn trit_str(t: trit) -> ~str {\n-    match t { dont_care { ~\"?\" } ttrue { ~\"1\" } tfalse { ~\"0\" } }\n-}\n-\n-// FIXME (#2538): Would be nice to have unit tests for some of these\n-// operations, as a step towards formalizing them more rigorously.\n-\n-//\n-// Local Variables:\n-// mode: rust\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// End:\n-//"}, {"sha": "379546015ccd5e0107452adfbcdc7f23041b8ef6", "filename": "src/rustc/middle/tstate/annotate.rs", "status": "removed", "additions": 0, "deletions": 76, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/95bc9d4aef56d656e6dde057c0c9e8347b4d6e7e/src%2Frustc%2Fmiddle%2Ftstate%2Fannotate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95bc9d4aef56d656e6dde057c0c9e8347b4d6e7e/src%2Frustc%2Fmiddle%2Ftstate%2Fannotate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftstate%2Fannotate.rs?ref=95bc9d4aef56d656e6dde057c0c9e8347b4d6e7e", "patch": "@@ -1,76 +0,0 @@\n-\n-import syntax::ast::*;\n-import syntax::visit;\n-import syntax::codemap::span;\n-import syntax::print::pprust::stmt_to_str;\n-import aux::{num_constraints, get_fn_info, crate_ctxt, add_node};\n-import ann::empty_ann;\n-import pat_util::pat_binding_ids;\n-\n-fn collect_ids_expr(e: @expr, rs: @mut ~[node_id]) { vec::push(*rs, e.id); }\n-\n-fn collect_ids_block(b: blk, rs: @mut ~[node_id]) {\n-    vec::push(*rs, b.node.id);\n-}\n-\n-fn collect_ids_stmt(s: @stmt, rs: @mut ~[node_id]) {\n-    match s.node {\n-      stmt_decl(_, id) | stmt_expr(_, id) | stmt_semi(_, id) {\n-        debug!{\"node_id %s\", int::str(id)};\n-        debug!{\"%s\", stmt_to_str(*s)};\n-        vec::push(*rs, id);\n-      }\n-    }\n-}\n-\n-fn collect_ids_local(tcx: ty::ctxt, l: @local, rs: @mut ~[node_id]) {\n-    vec::push_all(*rs, pat_binding_ids(tcx.def_map, l.node.pat));\n-}\n-\n-fn node_ids_in_fn(tcx: ty::ctxt, body: blk, rs: @mut ~[node_id]) {\n-    let collect_ids =\n-        visit::mk_simple_visitor(@{visit_expr: |a| collect_ids_expr(a, rs),\n-                                   visit_block: |a| collect_ids_block(a, rs),\n-                                   visit_stmt: |a| collect_ids_stmt(a, rs),\n-                                   visit_local: |a|\n-                                       collect_ids_local(tcx, a, rs)\n-                                   with *visit::default_simple_visitor()});\n-    collect_ids.visit_block(body, (), collect_ids);\n-}\n-\n-fn init_vecs(ccx: crate_ctxt, node_ids: ~[node_id], len: uint) {\n-    for node_ids.each |i| {\n-        log(debug, int::str(i) + ~\" |-> \" + uint::str(len));\n-        add_node(ccx, i, empty_ann(len));\n-    }\n-}\n-\n-fn visit_fn(ccx: crate_ctxt, num_constraints: uint, body: blk) {\n-    let node_ids: @mut ~[node_id] = @mut ~[];\n-    node_ids_in_fn(ccx.tcx, body, node_ids);\n-    let node_id_vec = *node_ids;\n-    init_vecs(ccx, node_id_vec, num_constraints);\n-}\n-\n-fn annotate_in_fn(ccx: crate_ctxt, _fk: visit::fn_kind, _decl: fn_decl,\n-                  body: blk, _sp: span, id: node_id) {\n-    let f_info = get_fn_info(ccx, id);\n-    visit_fn(ccx, num_constraints(f_info), body);\n-}\n-\n-fn annotate_crate(ccx: crate_ctxt, crate: crate) {\n-    let do_ann =\n-        visit::mk_simple_visitor(\n-            @{visit_fn: |a,b,c,d,e| annotate_in_fn(ccx, a, b, c, d, e)\n-              with *visit::default_simple_visitor()});\n-    visit::visit_crate(crate, (), do_ann);\n-}\n-//\n-// Local Variables:\n-// mode: rust\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// End:\n-//"}, {"sha": "fc9a84571b7c3cc316ca8ff1a9e59f91edb841ad", "filename": "src/rustc/middle/tstate/auxiliary.rs", "status": "removed", "additions": 0, "deletions": 990, "changes": 990, "blob_url": "https://github.com/rust-lang/rust/blob/95bc9d4aef56d656e6dde057c0c9e8347b4d6e7e/src%2Frustc%2Fmiddle%2Ftstate%2Fauxiliary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95bc9d4aef56d656e6dde057c0c9e8347b4d6e7e/src%2Frustc%2Fmiddle%2Ftstate%2Fauxiliary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftstate%2Fauxiliary.rs?ref=95bc9d4aef56d656e6dde057c0c9e8347b4d6e7e", "patch": "@@ -1,990 +0,0 @@\n-import option::*;\n-import pat_util::*;\n-import syntax::ast::*;\n-import syntax::ast_util::*;\n-import syntax::{visit, codemap};\n-import codemap::span;\n-import std::map::{hashmap, int_hash};\n-import syntax::print::pprust::path_to_str;\n-import tstate::ann::{pre_and_post, pre_and_post_state, empty_ann, prestate,\n-                     poststate, precond, postcond,\n-                     set_prestate, set_poststate, set_in_poststate_,\n-                     extend_prestate, extend_poststate, set_precondition,\n-                     set_postcondition, ts_ann,\n-                     clear_in_postcond,\n-                     clear_in_poststate_};\n-import driver::session::session;\n-import dvec::{dvec, extensions};\n-import tritv::{trit, tfalse, ttrue, dont_care, t};\n-\n-import syntax::print::pprust::{constr_args_to_str, lit_to_str};\n-\n-// Used to communicate which operands should be invalidated\n-// to helper functions\n-enum oper_type {\n-    oper_move,\n-    oper_swap,\n-    oper_assign,\n-    oper_assign_op,\n-    oper_pure,\n-}\n-\n-/* logging funs */\n-fn def_id_to_str(d: def_id) -> ~str {\n-    return int::str(d.crate) + ~\",\" + int::str(d.node);\n-}\n-\n-fn comma_str(args: ~[@constr_arg_use]) -> ~str {\n-    let mut rslt = ~\"\";\n-    let mut comma = false;\n-    for args.each |a| {\n-        if comma { rslt += ~\", \"; } else { comma = true; }\n-        match a.node {\n-          carg_base { rslt += ~\"*\"; }\n-          carg_ident(i) { rslt += *i.ident; }\n-          carg_lit(l) { rslt += lit_to_str(l); }\n-        }\n-    }\n-    return rslt;\n-}\n-\n-fn constraint_to_str(tcx: ty::ctxt, c: sp_constr) -> ~str {\n-    return fmt!{\"%s(%s) - arising from %s\",\n-             path_to_str(c.node.path),\n-             comma_str(c.node.args),\n-             codemap::span_to_str(c.span, tcx.sess.codemap)};\n-}\n-\n-fn tritv_to_str(fcx: fn_ctxt, v: tritv::t) -> ~str {\n-    let mut s = ~\"\";\n-    let mut comma = false;\n-    for constraints(fcx).each |p| {\n-        match v.get(p.bit_num) {\n-          dont_care { }\n-          tt {\n-            s +=\n-                if comma { ~\", \" } else { comma = true; ~\"\" } +\n-                    if tt == tfalse { ~\"!\" } else { ~\"\" } +\n-                    constraint_to_str(fcx.ccx.tcx, p.c);\n-          }\n-        }\n-    }\n-    return s;\n-}\n-\n-fn log_tritv(fcx: fn_ctxt, v: tritv::t) {\n-    log(debug, tritv_to_str(fcx, v));\n-}\n-\n-fn first_difference_string(fcx: fn_ctxt, expected: tritv::t, actual: tritv::t)\n-   -> ~str {\n-    let mut s = ~\"\";\n-    for constraints(fcx).each |c| {\n-      if expected.get(c.bit_num) == ttrue &&\n-         actual.get(c.bit_num) != ttrue {\n-            s = constraint_to_str(fcx.ccx.tcx, c.c);\n-            break;\n-        }\n-    }\n-    return s;\n-}\n-\n-fn log_tritv_err(fcx: fn_ctxt, v: tritv::t) {\n-    log(error, tritv_to_str(fcx, v));\n-}\n-\n-fn tos(v: ~[uint]) -> ~str {\n-    let mut rslt = ~\"\";\n-    for v.each |i| {\n-        if i == 0u {\n-            rslt += ~\"0\";\n-        } else if i == 1u { rslt += ~\"1\"; } else { rslt += ~\"?\"; }\n-    }\n-    return rslt;\n-}\n-\n-fn log_cond(v: ~[uint]) { log(debug, tos(v)); }\n-\n-fn log_cond_err(v: ~[uint]) { log(error, tos(v)); }\n-\n-fn log_pp(pp: pre_and_post) {\n-    let p1 = pp.precondition.to_vec();\n-    let p2 = pp.postcondition.to_vec();\n-    debug!{\"pre:\"};\n-    log_cond(p1);\n-    debug!{\"post:\"};\n-    log_cond(p2);\n-}\n-\n-fn log_pp_err(pp: pre_and_post) {\n-    let p1 = pp.precondition.to_vec();\n-    let p2 = pp.postcondition.to_vec();\n-    error!{\"pre:\"};\n-    log_cond_err(p1);\n-    error!{\"post:\"};\n-    log_cond_err(p2);\n-}\n-\n-fn log_states(pp: pre_and_post_state) {\n-    let p1 = pp.prestate.to_vec();\n-    let p2 = pp.poststate.to_vec();\n-    debug!{\"prestate:\"};\n-    log_cond(p1);\n-    debug!{\"poststate:\"};\n-    log_cond(p2);\n-}\n-\n-fn log_states_err(pp: pre_and_post_state) {\n-    let p1 = pp.prestate.to_vec();\n-    let p2 = pp.poststate.to_vec();\n-    error!{\"prestate:\"};\n-    log_cond_err(p1);\n-    error!{\"poststate:\"};\n-    log_cond_err(p2);\n-}\n-\n-fn print_ident(i: ident) { log(debug, ~\" \" + *i + ~\" \"); }\n-\n-fn print_idents(&idents: ~[ident]) {\n-    if vec::len::<ident>(idents) == 0u { return; }\n-    log(debug, ~\"an ident: \" + *vec::pop::<ident>(idents));\n-    print_idents(idents);\n-}\n-\n-\n-/* data structures */\n-\n-/**********************************************************************/\n-\n-/* Two different data structures represent constraints in different\n- contexts: constraint and norm_constraint.\n-\n-constraint gets used to record constraints in a table keyed by def_ids.  Each\n-constraint has a single operator but a list of possible argument lists, and\n-thus represents several constraints at once, one for each possible argument\n-list.\n-\n-norm_constraint, in contrast, gets used when handling an instance of a\n-constraint rather than a definition of a constraint. It has only a single\n-argument list.\n-\n-The representation of constraints, where multiple instances of the\n-same predicate are collapsed into one entry in the table, makes it\n-easier to look up a specific instance.\n-\n-Both types are in constrast with the constraint type defined in\n-syntax::ast, which is for predicate constraints only, and is what\n-gets generated by the parser. aux and ast share the same type\n-to represent predicate *arguments* however. This type\n-(constr_arg_general) is parameterized (see comments in syntax::ast).\n-\n-Both types store an ident and span, for error-logging purposes.\n-*/\n-type pred_args_ = {args: ~[@constr_arg_use], bit_num: uint};\n-\n-type pred_args = spanned<pred_args_>;\n-\n-// The attached node ID is the *defining* node ID\n-// for this local.\n-type constr_arg_use = spanned<constr_arg_general_<inst>>;\n-\n-/* Predicate constraints refer to the truth value of a predicate on variables\n-(definitely false, maybe true, or definitely true).  The <path> field (and the\n-<def_id> field in the npred constructor) names a user-defined function that\n-may be the operator in a \"check\" expression in the source.  */\n-\n-type constraint = {\n-    path: @path,\n-    // FIXME (#2539): really only want it to be mut during\n-    // collect_locals.  freeze it after that.\n-    descs: @dvec<pred_args>\n-};\n-\n-type tsconstr = {\n-    path: @path,\n-    def_id: def_id,\n-    args: ~[@constr_arg_use]\n-};\n-\n-type sp_constr = spanned<tsconstr>;\n-\n-type norm_constraint = {bit_num: uint, c: sp_constr};\n-\n-type constr_map = std::map::hashmap<def_id, constraint>;\n-\n-/* Contains stuff that has to be computed up front */\n-/* For easy access, the fn_info stores two special constraints for each\n-function.  So we need context. And so it seems clearer to just have separate\n-constraints. */\n-type fn_info =\n-    /* list, accumulated during pre/postcondition\n-    computation, of all local variables that may be\n-    used */\n-    // Doesn't seem to work without the @ -- bug\n-    {constrs: constr_map,\n-     num_constraints: uint,\n-     cf: ret_style,\n-     used_vars: @mut ~[node_id],\n-     ignore: bool};\n-\n-/* mapping from node ID to typestate annotation */\n-type node_ann_table = @mut ~[mut ts_ann];\n-\n-\n-/* mapping from function name to fn_info map */\n-type fn_info_map = std::map::hashmap<node_id, fn_info>;\n-\n-type fn_ctxt =\n-    {enclosing: fn_info, id: node_id, name: ident, ccx: crate_ctxt};\n-\n-type crate_ctxt = {tcx: ty::ctxt, node_anns: node_ann_table, fm: fn_info_map};\n-\n-fn get_fn_info(ccx: crate_ctxt, id: node_id) -> fn_info {\n-    assert (ccx.fm.contains_key(id));\n-    return ccx.fm.get(id);\n-}\n-\n-fn add_node(ccx: crate_ctxt, i: node_id, a: ts_ann) {\n-    let sz = vec::len(*ccx.node_anns);\n-    if sz <= i as uint {\n-        vec::grow(*ccx.node_anns, (i as uint) - sz + 1u, empty_ann(0u));\n-    }\n-    ccx.node_anns[i] = a;\n-}\n-\n-fn get_ts_ann(ccx: crate_ctxt, i: node_id) -> option<ts_ann> {\n-    if i as uint < vec::len(*ccx.node_anns) {\n-        return some::<ts_ann>(ccx.node_anns[i]);\n-    } else { return none::<ts_ann>; }\n-}\n-\n-\n-/********* utils ********/\n-fn node_id_to_ts_ann(ccx: crate_ctxt, id: node_id) -> ts_ann {\n-    match get_ts_ann(ccx, id) {\n-      none {\n-        error!{\"node_id_to_ts_ann: no ts_ann for node_id %d\", id};\n-        fail;\n-      }\n-      some(tt) { return tt; }\n-    }\n-}\n-\n-fn node_id_to_poststate(ccx: crate_ctxt, id: node_id) -> poststate {\n-    debug!{\"node_id_to_poststate\"};\n-    return node_id_to_ts_ann(ccx, id).states.poststate;\n-}\n-\n-fn stmt_to_ann(ccx: crate_ctxt, s: stmt) -> ts_ann {\n-    debug!{\"stmt_to_ann\"};\n-    match s.node {\n-      stmt_decl(_, id) | stmt_expr(_, id) | stmt_semi(_, id) {\n-        return node_id_to_ts_ann(ccx, id);\n-      }\n-    }\n-}\n-\n-\n-/* fails if e has no annotation */\n-fn expr_states(ccx: crate_ctxt, e: @expr) -> pre_and_post_state {\n-    debug!{\"expr_states\"};\n-    return node_id_to_ts_ann(ccx, e.id).states;\n-}\n-\n-\n-/* fails if e has no annotation */\n-fn expr_pp(ccx: crate_ctxt, e: @expr) -> pre_and_post {\n-    debug!{\"expr_pp\"};\n-    return node_id_to_ts_ann(ccx, e.id).conditions;\n-}\n-\n-fn stmt_pp(ccx: crate_ctxt, s: stmt) -> pre_and_post {\n-    return stmt_to_ann(ccx, s).conditions;\n-}\n-\n-\n-/* fails if b has no annotation */\n-fn block_pp(ccx: crate_ctxt, b: blk) -> pre_and_post {\n-    debug!{\"block_pp\"};\n-    return node_id_to_ts_ann(ccx, b.node.id).conditions;\n-}\n-\n-fn clear_pp(pp: pre_and_post) {\n-    ann::clear(pp.precondition);\n-    ann::clear(pp.postcondition);\n-}\n-\n-fn clear_precond(ccx: crate_ctxt, id: node_id) {\n-    let pp = node_id_to_ts_ann(ccx, id);\n-    ann::clear(pp.conditions.precondition);\n-}\n-\n-fn block_states(ccx: crate_ctxt, b: blk) -> pre_and_post_state {\n-    debug!{\"block_states\"};\n-    return node_id_to_ts_ann(ccx, b.node.id).states;\n-}\n-\n-fn stmt_states(ccx: crate_ctxt, s: stmt) -> pre_and_post_state {\n-    return stmt_to_ann(ccx, s).states;\n-}\n-\n-fn expr_precond(ccx: crate_ctxt, e: @expr) -> precond {\n-    return expr_pp(ccx, e).precondition;\n-}\n-\n-fn expr_postcond(ccx: crate_ctxt, e: @expr) -> postcond {\n-    return expr_pp(ccx, e).postcondition;\n-}\n-\n-fn expr_prestate(ccx: crate_ctxt, e: @expr) -> prestate {\n-    return expr_states(ccx, e).prestate;\n-}\n-\n-fn expr_poststate(ccx: crate_ctxt, e: @expr) -> poststate {\n-    return expr_states(ccx, e).poststate;\n-}\n-\n-fn stmt_precond(ccx: crate_ctxt, s: stmt) -> precond {\n-    return stmt_pp(ccx, s).precondition;\n-}\n-\n-fn stmt_postcond(ccx: crate_ctxt, s: stmt) -> postcond {\n-    return stmt_pp(ccx, s).postcondition;\n-}\n-\n-fn states_to_poststate(ss: pre_and_post_state) -> poststate {\n-    return ss.poststate;\n-}\n-\n-fn stmt_prestate(ccx: crate_ctxt, s: stmt) -> prestate {\n-    return stmt_states(ccx, s).prestate;\n-}\n-\n-fn stmt_poststate(ccx: crate_ctxt, s: stmt) -> poststate {\n-    return stmt_states(ccx, s).poststate;\n-}\n-\n-fn block_precond(ccx: crate_ctxt, b: blk) -> precond {\n-    return block_pp(ccx, b).precondition;\n-}\n-\n-fn block_postcond(ccx: crate_ctxt, b: blk) -> postcond {\n-    return block_pp(ccx, b).postcondition;\n-}\n-\n-fn block_prestate(ccx: crate_ctxt, b: blk) -> prestate {\n-    return block_states(ccx, b).prestate;\n-}\n-\n-fn block_poststate(ccx: crate_ctxt, b: blk) -> poststate {\n-    return block_states(ccx, b).poststate;\n-}\n-\n-fn set_prestate_ann(ccx: crate_ctxt, id: node_id, pre: prestate) -> bool {\n-    debug!{\"set_prestate_ann\"};\n-    return set_prestate(node_id_to_ts_ann(ccx, id), pre);\n-}\n-\n-fn extend_prestate_ann(ccx: crate_ctxt, id: node_id, pre: prestate) -> bool {\n-    debug!{\"extend_prestate_ann\"};\n-    return extend_prestate(node_id_to_ts_ann(ccx, id).states.prestate, pre);\n-}\n-\n-fn set_poststate_ann(ccx: crate_ctxt, id: node_id, post: poststate) -> bool {\n-    debug!{\"set_poststate_ann\"};\n-    return set_poststate(node_id_to_ts_ann(ccx, id), post);\n-}\n-\n-fn extend_poststate_ann(ccx: crate_ctxt, id: node_id, post: poststate) ->\n-   bool {\n-    debug!{\"extend_poststate_ann\"};\n-    return extend_poststate(\n-        node_id_to_ts_ann(ccx, id).states.poststate, post);\n-}\n-\n-fn set_pre_and_post(ccx: crate_ctxt, id: node_id, pre: precond,\n-                    post: postcond) {\n-    debug!{\"set_pre_and_post\"};\n-    let tt = node_id_to_ts_ann(ccx, id);\n-    set_precondition(tt, pre);\n-    set_postcondition(tt, post);\n-}\n-\n-fn copy_pre_post(ccx: crate_ctxt, id: node_id, sub: @expr) {\n-    debug!{\"set_pre_and_post\"};\n-    let p = expr_pp(ccx, sub);\n-    copy_pre_post_(ccx, id, p.precondition, p.postcondition);\n-}\n-\n-fn copy_pre_post_(ccx: crate_ctxt, id: node_id, pre: prestate,\n-                  post: poststate) {\n-    debug!{\"set_pre_and_post\"};\n-    let tt = node_id_to_ts_ann(ccx, id);\n-    set_precondition(tt, pre);\n-    set_postcondition(tt, post);\n-}\n-\n-/* sets all bits to *1* */\n-fn set_postcond_false(ccx: crate_ctxt, id: node_id) {\n-    let p = node_id_to_ts_ann(ccx, id);\n-    ann::set(p.conditions.postcondition);\n-}\n-\n-fn pure_exp(ccx: crate_ctxt, id: node_id, p: prestate) -> bool {\n-    return set_prestate_ann(ccx, id, p) | set_poststate_ann(ccx, id, p);\n-}\n-\n-fn num_constraints(m: fn_info) -> uint { return m.num_constraints; }\n-\n-fn new_crate_ctxt(cx: ty::ctxt) -> crate_ctxt {\n-    let na: ~[mut ts_ann] = ~[mut];\n-    return {tcx: cx, node_anns: @mut na, fm: int_hash::<fn_info>()};\n-}\n-\n-/* Use e's type to determine whether it returns.\n- If it has a function type with a ! annotation,\n-the answer is noreturn. */\n-fn controlflow_expr(ccx: crate_ctxt, e: @expr) -> ret_style {\n-    match ty::get(ty::node_id_to_type(ccx.tcx, e.id)).struct {\n-      ty::ty_fn(f) { return f.ret_style; }\n-      _ { return return_val; }\n-    }\n-}\n-\n-fn constraints_expr(cx: ty::ctxt, e: @expr) -> ~[@ty::constr] {\n-    match ty::get(ty::node_id_to_type(cx, e.id)).struct {\n-      ty::ty_fn(f) { return f.constraints; }\n-      _ { return ~[]; }\n-    }\n-}\n-\n-fn node_id_to_def_strict(cx: ty::ctxt, id: node_id) -> def {\n-    match cx.def_map.find(id) {\n-      none {\n-        error!{\"node_id_to_def: node_id %d has no def\", id};\n-        fail;\n-      }\n-      some(d) { return d; }\n-    }\n-}\n-\n-fn node_id_to_def(ccx: crate_ctxt, id: node_id) -> option<def> {\n-    return ccx.tcx.def_map.find(id);\n-}\n-\n-fn norm_a_constraint(id: def_id, c: constraint) -> ~[norm_constraint] {\n-    let mut rslt: ~[norm_constraint] = ~[];\n-    for (*c.descs).each |pd| {\n-        vec::push(rslt,\n-                  {bit_num: pd.node.bit_num,\n-                   c: respan(pd.span, {path: c.path,\n-                                       def_id: id,\n-                                       args: pd.node.args})});\n-    }\n-    return rslt;\n-}\n-\n-\n-// Tried to write this as an iterator, but I got a\n-// non-exhaustive match in trans.\n-fn constraints(fcx: fn_ctxt) -> ~[norm_constraint] {\n-    let mut rslt: ~[norm_constraint] = ~[];\n-    for fcx.enclosing.constrs.each |key, val| {\n-        vec::push_all(rslt, norm_a_constraint(key, val));\n-    };\n-    return rslt;\n-}\n-\n-// FIXME (#2539): Would rather take an immutable vec as an argument,\n-// should freeze it at some earlier point.\n-fn match_args(fcx: fn_ctxt, occs: @dvec<pred_args>,\n-              occ: ~[@constr_arg_use]) -> uint {\n-    debug!{\"match_args: looking at %s\",\n-           constr_args_to_str(fn@(i: inst) -> ~str { *i.ident }, occ)};\n-    for (*occs).each |pd| {\n-        log(debug,\n-                 ~\"match_args: candidate \" + pred_args_to_str(pd));\n-        fn eq(p: inst, q: inst) -> bool { return p.node == q.node; }\n-        if ty::args_eq(eq, pd.node.args, occ) { return pd.node.bit_num; }\n-    }\n-    fcx.ccx.tcx.sess.bug(~\"match_args: no match for occurring args\");\n-}\n-\n-fn def_id_for_constr(tcx: ty::ctxt, t: node_id) -> def_id {\n-    match tcx.def_map.find(t) {\n-      none {\n-        tcx.sess.bug(~\"node_id_for_constr: bad node_id \" + int::str(t));\n-      }\n-      some(def_fn(i, _)) { return i; }\n-      _ { tcx.sess.bug(~\"node_id_for_constr: pred is not a function\"); }\n-    }\n-}\n-\n-fn expr_to_constr_arg(tcx: ty::ctxt, e: @expr) -> @constr_arg_use {\n-    match e.node {\n-      expr_path(p) {\n-        match tcx.def_map.find(e.id) {\n-          some(def_local(nid, _)) | some(def_arg(nid, _)) |\n-          some(def_binding(nid, _)) | some(def_upvar(nid, _, _, _)) {\n-            return @respan(p.span,\n-                        carg_ident({ident: p.idents[0], node: nid}));\n-          }\n-          some(what) {\n-              tcx.sess.span_bug(e.span,\n-                 fmt!{\"exprs_to_constr_args: non-local variable %? \\\n-                                     as pred arg\", what});\n-          }\n-          none {\n-              tcx.sess.span_bug(e.span,\n-                 ~\"exprs_to_constr_args: unbound id as pred arg\");\n-\n-          }\n-        }\n-      }\n-      expr_lit(l) { return @respan(e.span, carg_lit(l)); }\n-      _ {\n-        tcx.sess.span_fatal(e.span,\n-                            ~\"arguments to constrained functions must be \" +\n-                                ~\"literals or local variables\");\n-      }\n-    }\n-}\n-\n-fn exprs_to_constr_args(tcx: ty::ctxt,\n-                        args: ~[@expr]) -> ~[@constr_arg_use] {\n-    let f = |a| expr_to_constr_arg(tcx, a);\n-    let mut rslt: ~[@constr_arg_use] = ~[];\n-    for args.each |e| { vec::push(rslt, f(e)); }\n-    rslt\n-}\n-\n-fn expr_to_constr(tcx: ty::ctxt, e: @expr) -> sp_constr {\n-    match e.node {\n-      expr_call(operator, args, _) {\n-        match operator.node {\n-          expr_path(p) {\n-            return respan(e.span,\n-                       {path: p,\n-                        def_id: def_id_for_constr(tcx, operator.id),\n-                        args: exprs_to_constr_args(tcx, args)});\n-          }\n-          _ {\n-            tcx.sess.span_bug(operator.span,\n-                              ~\"ill-formed operator in predicate\");\n-          }\n-        }\n-      }\n-      _ {\n-        tcx.sess.span_bug(e.span, ~\"ill-formed predicate\");\n-      }\n-    }\n-}\n-\n-fn pred_args_to_str(p: pred_args) -> ~str {\n-    ~\"<\" + uint::str(p.node.bit_num) + ~\", \" +\n-        constr_args_to_str(fn@(i: inst) -> ~str {return *i.ident; },\n-                           p.node.args)\n-        + ~\">\"\n-}\n-\n-fn substitute_constr_args(cx: ty::ctxt, actuals: ~[@expr], c: @ty::constr) ->\n-   tsconstr {\n-    let mut rslt: ~[@constr_arg_use] = ~[];\n-    for c.node.args.each |a| {\n-        vec::push(rslt, substitute_arg(cx, actuals, a));\n-    }\n-    return {path: c.node.path,\n-         def_id: c.node.id,\n-         args: rslt};\n-}\n-\n-fn substitute_arg(cx: ty::ctxt, actuals: ~[@expr], a: @constr_arg) ->\n-   @constr_arg_use {\n-    let num_actuals = vec::len(actuals);\n-    match a.node {\n-      carg_ident(i) {\n-        if i < num_actuals {\n-            return expr_to_constr_arg(cx, actuals[i]);\n-        } else {\n-            cx.sess.span_fatal(a.span, ~\"constraint argument out of bounds\");\n-        }\n-      }\n-      carg_base { return @respan(a.span, carg_base); }\n-      carg_lit(l) { return @respan(a.span, carg_lit(l)); }\n-    }\n-}\n-\n-fn pred_args_matches(pattern: ~[constr_arg_general_<inst>],\n-                     desc: pred_args) ->\n-   bool {\n-    let mut i = 0u;\n-    for desc.node.args.each |c| {\n-        let n = pattern[i];\n-        match c.node {\n-          carg_ident(p) {\n-            match n {\n-              carg_ident(q) { if p.node != q.node { return false; } }\n-              _ { return false; }\n-            }\n-          }\n-          carg_base { if n != carg_base { return false; } }\n-          carg_lit(l) {\n-            match n {\n-              carg_lit(m) { if !const_eval::lit_eq(l, m) { return false; } }\n-              _ { return false; }\n-            }\n-          }\n-        }\n-        i += 1u;\n-    }\n-    return true;\n-}\n-\n-fn find_instance_(pattern: ~[constr_arg_general_<inst>],\n-                  descs: ~[pred_args]) ->\n-   option<uint> {\n-    for descs.each |d| {\n-        if pred_args_matches(pattern, d) { return some(d.node.bit_num); }\n-    }\n-    return none;\n-}\n-\n-type inst = {ident: ident, node: node_id};\n-\n-enum dest {\n-    local_dest(inst), // RHS is assigned to a local variable\n-    call                        // RHS is passed to a function\n-}\n-\n-type subst = ~[{from: inst, to: inst}];\n-\n-fn find_instances(_fcx: fn_ctxt, subst: subst,\n-                  c: constraint) -> ~[{from: uint, to: uint}] {\n-\n-    if vec::len(subst) == 0u { return ~[]; }\n-    let mut res = ~[];\n-    do (*c.descs).swap |v| {\n-        let v <- vec::from_mut(v);\n-        for v.each |d| {\n-            if args_mention(d.node.args, find_in_subst_bool, subst) {\n-                let old_bit_num = d.node.bit_num;\n-                let newv = replace(subst, d);\n-                match find_instance_(newv, v) {\n-                  some(d1) {vec::push(res, {from: old_bit_num, to: d1})}\n-                  _ {}\n-                }\n-            } else {}\n-        }\n-        vec::to_mut(v)\n-    }\n-    return res;\n-}\n-\n-fn find_in_subst(id: node_id, s: subst) -> option<inst> {\n-    for s.each |p| {\n-        if id == p.from.node { return some(p.to); }\n-    }\n-    return none;\n-}\n-\n-fn find_in_subst_bool(s: subst, id: node_id) -> bool {\n-    is_some(find_in_subst(id, s))\n-}\n-\n-fn insts_to_str(stuff: ~[constr_arg_general_<inst>]) -> ~str {\n-    let mut rslt = ~\"<\";\n-    for stuff.each |i| {\n-        rslt +=\n-            ~\" \" +\n-                match i {\n-                  carg_ident(p) { *p.ident }\n-                  carg_base { ~\"*\" }\n-                  carg_lit(_) { ~\"~[lit]\" }\n-                } + ~\" \";\n-    }\n-    rslt += ~\">\";\n-    rslt\n-}\n-\n-fn replace(subst: subst, d: pred_args) -> ~[constr_arg_general_<inst>] {\n-    let mut rslt: ~[constr_arg_general_<inst>] = ~[];\n-    for d.node.args.each |c| {\n-        match c.node {\n-          carg_ident(p) {\n-            match find_in_subst(p.node, subst) {\n-              some(newv) { vec::push(rslt, carg_ident(newv)); }\n-              _ { vec::push(rslt, c.node); }\n-            }\n-          }\n-          _ {\n-            vec::push(rslt, c.node);\n-          }\n-        }\n-    }\n-\n-    return rslt;\n-}\n-\n-enum if_ty { if_check, plain_if, }\n-\n-fn for_constraints_mentioning(fcx: fn_ctxt, id: node_id,\n-                              f: fn(norm_constraint)) {\n-    for constraints(fcx).each |c| {\n-        if constraint_mentions(fcx, c, id) { f(c); }\n-    };\n-}\n-\n-fn local_node_id_to_def_id_strict(fcx: fn_ctxt, sp: span, i: node_id) ->\n-   def_id {\n-    match local_node_id_to_def(fcx, i) {\n-      some(def_local(nid, _)) | some(def_arg(nid, _)) |\n-      some(def_upvar(nid, _, _)) {\n-        return local_def(nid);\n-      }\n-      some(_) {\n-        fcx.ccx.tcx.sess.span_fatal(sp,\n-                                    ~\"local_node_id_to_def_id: id \\\n-               isn't a local\");\n-      }\n-      none {\n-        // should really be bug. span_bug()?\n-        fcx.ccx.tcx.sess.span_fatal(sp,\n-                                    ~\"local_node_id_to_def_id: id \\\n-               is unbound\");\n-      }\n-    }\n-}\n-\n-fn local_node_id_to_def(fcx: fn_ctxt, i: node_id) -> option<def> {\n-    fcx.ccx.tcx.def_map.find(i)\n-}\n-\n-fn local_node_id_to_def_id(fcx: fn_ctxt, i: node_id) -> option<def_id> {\n-    match local_node_id_to_def(fcx, i) {\n-      some(def_local(nid, _)) | some(def_arg(nid, _)) |\n-      some(def_binding(nid, _)) | some(def_upvar(nid, _, _)) {\n-        some(local_def(nid))\n-      }\n-      _ { none }\n-    }\n-}\n-\n-fn local_node_id_to_local_def_id(fcx: fn_ctxt, i: node_id) ->\n-   option<node_id> {\n-    match local_node_id_to_def_id(fcx, i) {\n-      some(did) { some(did.node) }\n-      _ { none }\n-    }\n-}\n-\n-fn copy_in_postcond(fcx: fn_ctxt, parent_exp: node_id, dest: inst, src: inst,\n-                    ty: oper_type) {\n-    let post =\n-        node_id_to_ts_ann(fcx.ccx, parent_exp).conditions.postcondition;\n-    copy_in_poststate_two(fcx, post, post, dest, src, ty);\n-}\n-\n-fn copy_in_poststate(fcx: fn_ctxt, post: poststate, dest: inst, src: inst,\n-                     ty: oper_type) {\n-    copy_in_poststate_two(fcx, post, post, dest, src, ty);\n-}\n-\n-// In target_post, set the bits corresponding to copies of any\n-// constraints mentioning src that are set in src_post, with\n-// dest substituted for src.\n-// (This doesn't create any new constraints. If a new, substituted\n-// constraint isn't already in the bit vector, it's ignored.)\n-fn copy_in_poststate_two(fcx: fn_ctxt, src_post: poststate,\n-                         target_post: poststate, dest: inst, src: inst,\n-                         ty: oper_type) {\n-    let mut subst;\n-    match ty {\n-      oper_swap { subst = ~[{from: dest, to: src}, {from: src, to: dest}]; }\n-      oper_assign_op {\n-        return; // Don't do any propagation\n-      }\n-      _ { subst = ~[{from: src, to: dest}]; }\n-    }\n-\n-\n-    for fcx.enclosing.constrs.each_value |val| {\n-        // replace any occurrences of the src def_id with the\n-        // dest def_id\n-        let insts = find_instances(fcx, subst, val);\n-        for insts.each |p| {\n-            if bitvectors::promises_(p.from, src_post) {\n-                set_in_poststate_(p.to, target_post);\n-            }\n-        }\n-    };\n-}\n-\n-fn forget_in_postcond(fcx: fn_ctxt, parent_exp: node_id, dead_v: node_id) {\n-    // In the postcondition given by parent_exp, clear the bits\n-    // for any constraints mentioning dead_v\n-    let d = local_node_id_to_local_def_id(fcx, dead_v);\n-    do option::iter(d) |d_id| {\n-        do for_constraints_mentioning(fcx, d_id) |c| {\n-                debug!{\"clearing constraint %u %s\",\n-                       c.bit_num,\n-                       constraint_to_str(fcx.ccx.tcx, c.c)};\n-                clear_in_postcond(c.bit_num,\n-                                  node_id_to_ts_ann(fcx.ccx,\n-                                                    parent_exp).conditions);\n-        }\n-    };\n-}\n-\n-fn forget_in_poststate(fcx: fn_ctxt, p: poststate, dead_v: node_id) -> bool {\n-    // In the poststate given by parent_exp, clear the bits\n-    // for any constraints mentioning dead_v\n-    let d = local_node_id_to_local_def_id(fcx, dead_v);\n-    let mut changed = false;\n-    do option::iter(d) |d_id| {\n-        do for_constraints_mentioning(fcx, d_id) |c| {\n-                changed |= clear_in_poststate_(c.bit_num, p);\n-        }\n-    }\n-    return changed;\n-}\n-\n-fn any_eq(v: ~[node_id], d: node_id) -> bool {\n-    for v.each |i| { if i == d { return true; } }\n-    false\n-}\n-\n-fn constraint_mentions(_fcx: fn_ctxt, c: norm_constraint, v: node_id) ->\n-   bool {\n-    return args_mention(c.c.node.args, any_eq, ~[v]);\n-}\n-\n-fn args_mention<T>(args: ~[@constr_arg_use],\n-                   q: fn(~[T], node_id) -> bool,\n-                   s: ~[T]) -> bool {\n-\n-    for args.each |a| {\n-        match a.node {\n-          carg_ident(p1) { if q(s, p1.node) { return true; } } _ { }\n-        }\n-    }\n-    return false;\n-}\n-\n-fn use_var(fcx: fn_ctxt, v: node_id) {\n-    vec::push(*fcx.enclosing.used_vars, v);\n-}\n-\n-fn op_to_oper_ty(io: init_op) -> oper_type {\n-    match io { init_move { oper_move } _ { oper_assign } }\n-}\n-\n-// default function visitor\n-fn do_nothing<T>(_fk: visit::fn_kind, _decl: fn_decl, _body: blk,\n-                 _sp: span, _id: node_id,\n-                 _t: T, _v: visit::vt<T>) {\n-}\n-\n-\n-fn args_to_constr_args(tcx: ty::ctxt, args: ~[arg],\n-                       indices: ~[@sp_constr_arg<uint>])\n-    -> ~[@constr_arg_use] {\n-    let mut actuals: ~[@constr_arg_use] = ~[];\n-    let num_args = vec::len(args);\n-    for indices.each |a| {\n-        vec::push(\n-            actuals,\n-            @respan(a.span,\n-                    match a.node {\n-                        carg_base { carg_base }\n-                        carg_ident(i) {\n-                            if i < num_args {\n-                                carg_ident({ident: args[i].ident,\n-                                            node: args[i].id})\n-                            } else {\n-                                tcx.sess.span_bug(a.span,\n-                                                  ~\"index out of bounds in \\\n-                                                   constraint arg\");\n-                            }\n-                        }\n-                        carg_lit(l) { carg_lit(l) }\n-                    }));\n-    }\n-    return actuals;\n-}\n-\n-fn ast_constr_to_ts_constr(tcx: ty::ctxt, args: ~[arg], c: @constr) ->\n-   tsconstr {\n-    let tconstr = ty::ast_constr_to_constr(tcx, c);\n-    return {path: tconstr.node.path,\n-         def_id: tconstr.node.id,\n-         args: args_to_constr_args(tcx, args, tconstr.node.args)};\n-}\n-\n-fn ast_constr_to_sp_constr(tcx: ty::ctxt, args: ~[arg], c: @constr) ->\n-   sp_constr {\n-    let tconstr = ast_constr_to_ts_constr(tcx, args, c);\n-    return respan(c.span, tconstr);\n-}\n-\n-type binding = {lhs: ~[dest], rhs: option<initializer>};\n-\n-fn local_to_bindings(tcx: ty::ctxt, loc: @local) -> binding {\n-    let mut lhs = ~[];\n-    do pat_bindings(tcx.def_map, loc.node.pat) |_bm, p_id, _s, name| {\n-      vec::push(lhs, local_dest({ident: path_to_ident(name), node: p_id}));\n-    };\n-    {lhs: lhs, rhs: loc.node.init}\n-}\n-\n-fn locals_to_bindings(tcx: ty::ctxt, locals: ~[@local]) -> ~[binding] {\n-    let mut rslt = ~[];\n-    for locals.each |loc| { vec::push(rslt, local_to_bindings(tcx, loc)); }\n-    return rslt;\n-}\n-\n-fn callee_modes(fcx: fn_ctxt, callee: node_id) -> ~[mode] {\n-    let ty = ty::type_autoderef(fcx.ccx.tcx,\n-                                ty::node_id_to_type(fcx.ccx.tcx, callee));\n-    match ty::get(ty).struct {\n-      ty::ty_fn({inputs: args, _}) {\n-        let mut modes = ~[];\n-        for args.each |arg| { vec::push(modes, arg.mode); }\n-        return modes;\n-      }\n-      _ {\n-        // Shouldn't happen; callee should be ty_fn.\n-        fcx.ccx.tcx.sess.bug(~\"non-fn callee type in callee_modes: \" +\n-                                 util::ppaux::ty_to_str(fcx.ccx.tcx, ty));\n-      }\n-    }\n-}\n-\n-fn callee_arg_init_ops(fcx: fn_ctxt, callee: node_id) -> ~[init_op] {\n-    do vec::map(callee_modes(fcx, callee)) |m| {\n-        match ty::resolved_mode(fcx.ccx.tcx, m) {\n-          by_move { init_move }\n-          by_copy | by_ref | by_val | by_mutbl_ref { init_assign }\n-        }\n-    }\n-}\n-\n-fn arg_bindings(ops: ~[init_op], es: ~[@expr]) -> ~[binding] {\n-    let mut bindings: ~[binding] = ~[];\n-    let mut i = 0u;\n-    for ops.each |op| {\n-        vec::push(bindings,\n-                  {lhs: ~[call], rhs: some({op: op, expr: es[i]})});\n-        i += 1u;\n-    }\n-    return bindings;\n-}\n-\n-//\n-// Local Variables:\n-// mode: rust\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// End:\n-//"}, {"sha": "f1dc6a566af245eb4e87a2800a77e576a0e74695", "filename": "src/rustc/middle/tstate/ck.rs", "status": "removed", "additions": 0, "deletions": 153, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/95bc9d4aef56d656e6dde057c0c9e8347b4d6e7e/src%2Frustc%2Fmiddle%2Ftstate%2Fck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95bc9d4aef56d656e6dde057c0c9e8347b4d6e7e/src%2Frustc%2Fmiddle%2Ftstate%2Fck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftstate%2Fck.rs?ref=95bc9d4aef56d656e6dde057c0c9e8347b4d6e7e", "patch": "@@ -1,153 +0,0 @@\n-\n-import syntax::ast;\n-import ast::{stmt, fn_ident, node_id, crate, return_val, noreturn, expr};\n-import syntax::{visit, print};\n-import syntax::codemap::span;\n-import middle::ty;\n-import tstate::ann::{precond, prestate,\n-                     implies, ann_precond, ann_prestate};\n-import aux::*;\n-\n-import util::ppaux::ty_to_str;\n-import bitvectors::*;\n-import annotate::annotate_crate;\n-import collect_locals::mk_f_to_fn_info;\n-import pre_post_conditions::fn_pre_post;\n-import states::find_pre_post_state_fn;\n-import syntax::print::pprust::expr_to_str;\n-import driver::session::session;\n-import std::map::hashmap;\n-\n-fn check_states_expr(e: @expr, fcx: fn_ctxt, v: visit::vt<fn_ctxt>) {\n-    visit::visit_expr(e, fcx, v);\n-\n-    let prec: precond = expr_precond(fcx.ccx, e);\n-    let pres: prestate = expr_prestate(fcx.ccx, e);\n-\n-    if !implies(pres, prec) {\n-        let mut s = ~\"\";\n-        let diff = first_difference_string(fcx, prec, pres);\n-        s +=\n-            ~\"unsatisfied precondition constraint (for example, \" + diff +\n-                ~\") for expression:\\n\";\n-        s += syntax::print::pprust::expr_to_str(e);\n-        s += ~\"\\nprecondition:\\n\";\n-        s += tritv_to_str(fcx, prec);\n-        s += ~\"\\nprestate:\\n\";\n-        s += tritv_to_str(fcx, pres);\n-        fcx.ccx.tcx.sess.span_fatal(e.span, s);\n-    }\n-}\n-\n-fn check_states_stmt(s: @stmt, fcx: fn_ctxt, v: visit::vt<fn_ctxt>) {\n-    visit::visit_stmt(s, fcx, v);\n-\n-    let a = stmt_to_ann(fcx.ccx, *s);\n-    let prec: precond = ann_precond(a);\n-    let pres: prestate = ann_prestate(a);\n-\n-    debug!{\"check_states_stmt:\"};\n-    log(debug, print::pprust::stmt_to_str(*s));\n-    debug!{\"prec = \"};\n-    log_tritv(fcx, prec);\n-    debug!{\"pres = \"};\n-    log_tritv(fcx, pres);\n-\n-    if !implies(pres, prec) {\n-        let mut ss = ~\"\";\n-        let diff = first_difference_string(fcx, prec, pres);\n-        ss +=\n-            ~\"unsatisfied precondition constraint (for example, \" + diff +\n-                ~\") for statement:\\n\";\n-        ss += syntax::print::pprust::stmt_to_str(*s);\n-        ss += ~\"\\nprecondition:\\n\";\n-        ss += tritv_to_str(fcx, prec);\n-        ss += ~\"\\nprestate: \\n\";\n-        ss += tritv_to_str(fcx, pres);\n-        fcx.ccx.tcx.sess.span_fatal(s.span, ss);\n-    }\n-}\n-\n-fn check_states_against_conditions(fcx: fn_ctxt,\n-                                   fk: visit::fn_kind,\n-                                   f_decl: ast::fn_decl,\n-                                   f_body: ast::blk,\n-                                   sp: span,\n-                                   id: node_id) {\n-    /* Postorder traversal instead of pre is important\n-       because we want the smallest possible erroneous statement\n-       or expression. */\n-    let visitor = visit::mk_vt(\n-        @{visit_stmt: check_states_stmt,\n-          visit_expr: check_states_expr,\n-          visit_fn: |a,b,c,d,e,f,g| {\n-              do_nothing::<fn_ctxt>(a, b, c, d, e, f, g)\n-          }\n-          with *visit::default_visitor::<fn_ctxt>()});\n-    visit::visit_fn(fk, f_decl, f_body, sp, id, fcx, visitor);\n-}\n-\n-fn check_fn_states(fcx: fn_ctxt,\n-                   fk: visit::fn_kind,\n-                   f_decl: ast::fn_decl,\n-                   f_body: ast::blk,\n-                   sp: span,\n-                   id: node_id) {\n-    /* Compute the pre- and post-states for this function */\n-\n-    // Fixpoint iteration\n-    while find_pre_post_state_fn(fcx, f_decl, f_body) { }\n-\n-    /* Now compare each expr's pre-state to its precondition\n-       and post-state to its postcondition */\n-\n-    check_states_against_conditions(fcx, fk, f_decl, f_body, sp, id);\n-}\n-\n-fn fn_states(fk: visit::fn_kind, f_decl: ast::fn_decl, f_body: ast::blk,\n-             sp: span, id: node_id,\n-             ccx: crate_ctxt, v: visit::vt<crate_ctxt>) {\n-\n-    visit::visit_fn(fk, f_decl, f_body, sp, id, ccx, v);\n-\n-    // We may not care about typestate for this function if it contains\n-    // no constrained calls\n-    if !ccx.fm.get(id).ignore {\n-        /* Look up the var-to-bit-num map for this function */\n-\n-        let f_info = ccx.fm.get(id);\n-        let name = visit::name_of_fn(fk);\n-        let fcx = {enclosing: f_info, id: id, name: name, ccx: ccx};\n-        check_fn_states(fcx, fk, f_decl, f_body, sp, id)\n-    }\n-}\n-\n-fn check_crate(cx: ty::ctxt, crate: @crate) {\n-    let ccx: crate_ctxt = new_crate_ctxt(cx);\n-    /* Build the global map from function id to var-to-bit-num-map */\n-\n-    mk_f_to_fn_info(ccx, crate);\n-    /* Add a blank ts_ann for every statement (and expression) */\n-\n-    annotate_crate(ccx, *crate);\n-    /* Compute the pre and postcondition for every subexpression */\n-\n-    let vtor = visit::default_visitor::<crate_ctxt>();\n-    let vtor = @{visit_fn: fn_pre_post with *vtor};\n-    visit::visit_crate(*crate, ccx, visit::mk_vt(vtor));\n-\n-    /* Check the pre- and postcondition against the pre- and poststate\n-       for every expression */\n-    let vtor = visit::default_visitor::<crate_ctxt>();\n-    let vtor = @{visit_fn: fn_states with *vtor};\n-    visit::visit_crate(*crate, ccx, visit::mk_vt(vtor));\n-}\n-//\n-// Local Variables:\n-// mode: rust\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// End:\n-//"}, {"sha": "6379e8898f732d5d4437800f0d0f70b716f92ba5", "filename": "src/rustc/middle/tstate/collect_locals.rs", "status": "removed", "additions": 0, "deletions": 165, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/95bc9d4aef56d656e6dde057c0c9e8347b4d6e7e/src%2Frustc%2Fmiddle%2Ftstate%2Fcollect_locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95bc9d4aef56d656e6dde057c0c9e8347b4d6e7e/src%2Frustc%2Fmiddle%2Ftstate%2Fcollect_locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftstate%2Fcollect_locals.rs?ref=95bc9d4aef56d656e6dde057c0c9e8347b4d6e7e", "patch": "@@ -1,165 +0,0 @@\n-import option::*;\n-import pat_util::*;\n-import syntax::ast::*;\n-import syntax::ast_util::*;\n-import syntax::visit;\n-import syntax::codemap::span;\n-import syntax::ast_util::respan;\n-import driver::session::session;\n-import aux::*;\n-import std::map::hashmap;\n-import dvec::{dvec, extensions};\n-\n-type ctxt = {cs: @mut ~[sp_constr], tcx: ty::ctxt};\n-\n-fn collect_pred(e: @expr, cx: ctxt, v: visit::vt<ctxt>) {\n-    match e.node {\n-      expr_check(_, ch) { vec::push(*cx.cs, expr_to_constr(cx.tcx, ch)); }\n-      expr_if_check(ex, _, _) {\n-        vec::push(*cx.cs, expr_to_constr(cx.tcx, ex));\n-      }\n-\n-      // If it's a call, generate appropriate instances of the\n-      // call's constraints.\n-      expr_call(operator, operands, _) {\n-        for constraints_expr(cx.tcx, operator).each |c| {\n-            let ct: sp_constr =\n-                respan(c.span,\n-                       aux::substitute_constr_args(cx.tcx, operands, c));\n-            vec::push(*cx.cs, ct);\n-        }\n-      }\n-      _ { }\n-    }\n-    // visit subexpressions\n-    visit::visit_expr(e, cx, v);\n-}\n-\n-fn find_locals(tcx: ty::ctxt,\n-               fk: visit::fn_kind,\n-               f_decl: fn_decl,\n-               f_body: blk,\n-               sp: span,\n-               id: node_id) -> ctxt {\n-    let cx: ctxt = {cs: @mut ~[], tcx: tcx};\n-    let visitor = visit::default_visitor::<ctxt>();\n-    let visitor =\n-        @{visit_expr: collect_pred,\n-          visit_fn: do_nothing\n-          with *visitor};\n-    visit::visit_fn(fk, f_decl, f_body, sp,\n-                    id, cx, visit::mk_vt(visitor));\n-    return cx;\n-}\n-\n-fn add_constraint(tcx: ty::ctxt, c: sp_constr, next: uint, tbl: constr_map) ->\n-   uint {\n-    log(debug,\n-             constraint_to_str(tcx, c) + ~\" |-> \" + uint::str(next));\n-\n-    let {path: p, def_id: d_id, args: args} = c.node;\n-    match tbl.find(d_id) {\n-      some(ct) {\n-        (*ct.descs).push(respan(c.span, {args: args, bit_num: next}));\n-      }\n-      none {\n-        let rslt = @dvec();\n-        (*rslt).push(respan(c.span, {args: args, bit_num: next}));\n-        tbl.insert(d_id, {path:p, descs:rslt});\n-      }\n-    }\n-    return next + 1u;\n-}\n-\n-fn contains_constrained_calls(tcx: ty::ctxt, body: blk) -> bool {\n-    type cx = @{\n-        tcx: ty::ctxt,\n-        mut has: bool\n-    };\n-    let cx = @{\n-        tcx: tcx,\n-        mut has: false\n-    };\n-    let vtor = visit::default_visitor::<cx>();\n-    let vtor = @{visit_expr: visit_expr with *vtor};\n-    visit::visit_block(body, cx, visit::mk_vt(vtor));\n-    return cx.has;\n-\n-    fn visit_expr(e: @expr, &&cx: cx, v: visit::vt<cx>) {\n-        import syntax::print::pprust;\n-        debug!{\"visiting %?\", pprust::expr_to_str(e)};\n-\n-        visit::visit_expr(e, cx, v);\n-\n-        if constraints_expr(cx.tcx, e).is_not_empty() {\n-            debug!{\"has constraints\"};\n-            cx.has = true;\n-        } else {\n-            debug!{\"has not constraints\"};\n-        }\n-    }\n-}\n-\n-/* builds a table mapping each local var defined in f\n-   to a bit number in the precondition/postcondition vectors */\n-fn mk_fn_info(ccx: crate_ctxt,\n-              fk: visit::fn_kind,\n-              f_decl: fn_decl,\n-              f_body: blk,\n-              f_sp: span,\n-              id: node_id) {\n-    let name = visit::name_of_fn(fk);\n-    let res_map = new_def_hash::<constraint>();\n-    let mut next: uint = 0u;\n-\n-    let cx: ctxt = find_locals(ccx.tcx, fk, f_decl, f_body, f_sp, id);\n-    /* now we have to add bit nums for both the constraints\n-       and the variables... */\n-\n-    let ignore = !contains_constrained_calls(ccx.tcx, f_body);\n-\n-    if !ignore {\n-        let mut i = 0u, l = vec::len(*cx.cs);\n-        while i < l {\n-            next = add_constraint(cx.tcx, copy cx.cs[i], next, res_map);\n-            i += 1u;\n-        }\n-        /* if this function has any constraints, instantiate them to the\n-        argument names and add them */\n-        for f_decl.constraints.each |c| {\n-            let sc = ast_constr_to_sp_constr(cx.tcx, f_decl.inputs, c);\n-            next = add_constraint(cx.tcx, sc, next, res_map);\n-        }\n-    }\n-\n-    let v: @mut ~[node_id] = @mut ~[];\n-    let rslt =\n-        {constrs: res_map,\n-         num_constraints: next,\n-         cf: f_decl.cf,\n-         used_vars: v,\n-         ignore: ignore};\n-    ccx.fm.insert(id, rslt);\n-    debug!{\"%s has %u constraints\", *name, num_constraints(rslt)};\n-}\n-\n-\n-/* initializes the global fn_info_map (mapping each function ID, including\n-   nested locally defined functions, onto a mapping from local variable name\n-   to bit number) */\n-fn mk_f_to_fn_info(ccx: crate_ctxt, c: @crate) {\n-    let visitor =\n-        visit::mk_simple_visitor(@{\n-            visit_fn: |a,b,c,d,e| mk_fn_info(ccx, a, b, c, d, e)\n-            with *visit::default_simple_visitor()});\n-    visit::visit_crate(*c, (), visitor);\n-}\n-//\n-// Local Variables:\n-// mode: rust\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// End:\n-//"}, {"sha": "d1942e41fa81b7306707d08db770b8cd874178f7", "filename": "src/rustc/middle/tstate/pre_post_conditions.rs", "status": "removed", "additions": 0, "deletions": 617, "changes": 617, "blob_url": "https://github.com/rust-lang/rust/blob/95bc9d4aef56d656e6dde057c0c9e8347b4d6e7e/src%2Frustc%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95bc9d4aef56d656e6dde057c0c9e8347b4d6e7e/src%2Frustc%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs?ref=95bc9d4aef56d656e6dde057c0c9e8347b4d6e7e", "patch": "@@ -1,617 +0,0 @@\n-import tstate::ann::*;\n-import aux::*;\n-import bitvectors::{bit_num, seq_preconds, seq_postconds,\n-                    intersect_states,\n-                    relax_precond_block, gen};\n-import tritv::*;\n-\n-import pat_util::*;\n-import syntax::ast::*;\n-import syntax::ast_util::*;\n-import syntax::print::pprust::{expr_to_str, stmt_to_str};\n-import syntax::visit;\n-import util::common::{field_exprs, has_nonlocal_exits};\n-import syntax::codemap::span;\n-import driver::session::session;\n-import std::map::hashmap;\n-\n-fn find_pre_post_mod(_m: _mod) -> _mod {\n-    debug!{\"implement find_pre_post_mod!\"};\n-    fail;\n-}\n-\n-fn find_pre_post_foreign_mod(_m: foreign_mod) -> foreign_mod {\n-    debug!{\"implement find_pre_post_foreign_mod\"};\n-    fail;\n-}\n-\n-fn find_pre_post_method(ccx: crate_ctxt, m: @method) {\n-    assert (ccx.fm.contains_key(m.id));\n-    let fcx: fn_ctxt =\n-        {enclosing: ccx.fm.get(m.id),\n-         id: m.id,\n-         name: m.ident,\n-         ccx: ccx};\n-    find_pre_post_fn(fcx, m.body);\n-}\n-\n-fn find_pre_post_item(ccx: crate_ctxt, i: item) {\n-    match i.node {\n-      item_const(_, e) {\n-          // do nothing -- item_consts don't refer to local vars\n-      }\n-      item_fn(_, _, body) {\n-        assert (ccx.fm.contains_key(i.id));\n-        let fcx =\n-            {enclosing: ccx.fm.get(i.id), id: i.id, name: i.ident, ccx: ccx};\n-        find_pre_post_fn(fcx, body);\n-      }\n-      item_mod(m) { find_pre_post_mod(m); }\n-      item_foreign_mod(nm) { find_pre_post_foreign_mod(nm); }\n-      item_ty(*) | item_enum(*) | item_trait(*) { return; }\n-      item_class(*) {\n-          fail ~\"find_pre_post_item: shouldn't be called on item_class\";\n-      }\n-      item_impl(_, _, _, ms) {\n-        for ms.each |m| { find_pre_post_method(ccx, m); }\n-      }\n-      item_mac(*) { fail ~\"item macros unimplemented\" }\n-    }\n-}\n-\n-\n-/* Finds the pre and postcondition for each expr in <args>;\n-   sets the precondition in a to be the result of combining\n-   the preconditions for <args>, and the postcondition in a to\n-   be the union of all postconditions for <args> */\n-fn find_pre_post_exprs(fcx: fn_ctxt, args: ~[@expr], id: node_id) {\n-    if vec::len::<@expr>(args) > 0u {\n-        debug!{\"find_pre_post_exprs: oper = %s\", expr_to_str(args[0])};\n-    }\n-    fn do_one(fcx: fn_ctxt, e: @expr) { find_pre_post_expr(fcx, e); }\n-    for args.each |e| { do_one(fcx, e); }\n-\n-    fn get_pp(ccx: crate_ctxt, &&e: @expr) -> pre_and_post {\n-        return expr_pp(ccx, e);\n-    }\n-    let pps = vec::map(args, |a| get_pp(fcx.ccx, a) );\n-\n-    set_pre_and_post(fcx.ccx, id, seq_preconds(fcx, pps),\n-                     seq_postconds(fcx, vec::map(pps, get_post)));\n-}\n-\n-fn find_pre_post_loop(fcx: fn_ctxt, index: @expr, body: blk, id: node_id) {\n-    find_pre_post_expr(fcx, index);\n-    find_pre_post_block(fcx, body);\n-\n-    let loop_precond =\n-        seq_preconds(fcx, ~[expr_pp(fcx.ccx, index),\n-                           block_pp(fcx.ccx, body)]);\n-    let loop_postcond =\n-        intersect_states(expr_postcond(fcx.ccx, index),\n-                         block_postcond(fcx.ccx, body));\n-    copy_pre_post_(fcx.ccx, id, loop_precond, loop_postcond);\n-}\n-\n-// Generates a pre/post assuming that a is the\n-// annotation for an if-expression with consequent conseq\n-// and alternative maybe_alt\n-fn join_then_else(fcx: fn_ctxt, antec: @expr, conseq: blk,\n-                  maybe_alt: option<@expr>, id: node_id, chck: if_ty) {\n-    find_pre_post_expr(fcx, antec);\n-    find_pre_post_block(fcx, conseq);\n-    match maybe_alt {\n-      none {\n-        match chck {\n-          if_check {\n-            let c: sp_constr = expr_to_constr(fcx.ccx.tcx, antec);\n-            gen(fcx, antec.id, c.node);\n-          }\n-          _ { }\n-        }\n-\n-        let precond_res =\n-            seq_preconds(fcx,\n-                         ~[expr_pp(fcx.ccx, antec),\n-                          block_pp(fcx.ccx, conseq)]);\n-        set_pre_and_post(fcx.ccx, id, precond_res,\n-                         expr_poststate(fcx.ccx, antec));\n-      }\n-      some(altern) {\n-        /*\n-          if check = if_check, then\n-          be sure that the predicate implied by antec\n-          is *not* true in the alternative\n-         */\n-        find_pre_post_expr(fcx, altern);\n-        let precond_false_case =\n-            seq_preconds(fcx,\n-                         ~[expr_pp(fcx.ccx, antec),\n-                          expr_pp(fcx.ccx, altern)]);\n-        let postcond_false_case =\n-            seq_postconds(fcx,\n-                          ~[expr_postcond(fcx.ccx, antec),\n-                           expr_postcond(fcx.ccx, altern)]);\n-\n-        /* Be sure to set the bit for the check condition here,\n-         so that it's *not* set in the alternative. */\n-        match chck {\n-          if_check {\n-            let c: sp_constr = expr_to_constr(fcx.ccx.tcx, antec);\n-            gen(fcx, antec.id, c.node);\n-          }\n-          _ { }\n-        }\n-        let precond_true_case =\n-            seq_preconds(fcx,\n-                         ~[expr_pp(fcx.ccx, antec),\n-                          block_pp(fcx.ccx, conseq)]);\n-        let postcond_true_case =\n-            seq_postconds(fcx,\n-                          ~[expr_postcond(fcx.ccx, antec),\n-                           block_postcond(fcx.ccx, conseq)]);\n-\n-        let precond_res =\n-            seq_postconds(fcx, ~[precond_true_case, precond_false_case]);\n-        let postcond_res =\n-            intersect_states(postcond_true_case, postcond_false_case);\n-        set_pre_and_post(fcx.ccx, id, precond_res, postcond_res);\n-      }\n-    }\n-}\n-\n-fn gen_if_local(fcx: fn_ctxt, lhs: @expr, rhs: @expr, larger_id: node_id,\n-                new_var: node_id) {\n-    match node_id_to_def(fcx.ccx, new_var) {\n-      some(d) {\n-        match d {\n-          def_local(nid, _) {\n-            find_pre_post_expr(fcx, rhs);\n-            let p = expr_pp(fcx.ccx, rhs);\n-            set_pre_and_post(fcx.ccx, larger_id, p.precondition,\n-                             p.postcondition);\n-          }\n-          _ { find_pre_post_exprs(fcx, ~[lhs, rhs], larger_id); }\n-        }\n-      }\n-      _ { find_pre_post_exprs(fcx, ~[lhs, rhs], larger_id); }\n-    }\n-}\n-\n-fn handle_update(fcx: fn_ctxt, parent: @expr, lhs: @expr, rhs: @expr,\n-                 ty: oper_type) {\n-    find_pre_post_expr(fcx, rhs);\n-    match lhs.node {\n-      expr_path(p) {\n-        let post = expr_postcond(fcx.ccx, parent);\n-        let tmp = post.clone();\n-\n-        match ty {\n-          oper_move {\n-            if is_path(rhs) { forget_in_postcond(fcx, parent.id, rhs.id); }\n-          }\n-          oper_swap {\n-            forget_in_postcond(fcx, parent.id, lhs.id);\n-            forget_in_postcond(fcx, parent.id, rhs.id);\n-          }\n-          oper_assign {\n-            forget_in_postcond(fcx, parent.id, lhs.id);\n-          }\n-          _ { }\n-        }\n-\n-        gen_if_local(fcx, lhs, rhs, parent.id, lhs.id);\n-        match rhs.node {\n-          expr_path(p1) {\n-            let d = local_node_id_to_local_def_id(fcx, lhs.id);\n-            let d1 = local_node_id_to_local_def_id(fcx, rhs.id);\n-            match d {\n-              some(id) {\n-                match d1 {\n-                  some(id1) {\n-                    let instlhs =\n-                        {ident: path_to_ident(p), node: id};\n-                    let instrhs =\n-                        {ident: path_to_ident(p1), node: id1};\n-                    copy_in_poststate_two(fcx, tmp, post, instlhs, instrhs,\n-                                          ty);\n-                  }\n-                  _ { }\n-                }\n-              }\n-              _ { }\n-            }\n-          }\n-          _ {/* do nothing */ }\n-        }\n-      }\n-      _ { find_pre_post_expr(fcx, lhs); }\n-    }\n-}\n-\n-fn forget_args_moved_in(fcx: fn_ctxt, parent: @expr, modes: ~[mode],\n-                        operands: ~[@expr]) {\n-    do vec::iteri(modes) |i,mode| {\n-        match ty::resolved_mode(fcx.ccx.tcx, mode) {\n-          by_move { forget_in_postcond(fcx, parent.id, operands[i].id); }\n-          by_ref | by_val | by_mutbl_ref | by_copy { }\n-        }\n-    }\n-}\n-\n-fn find_pre_post_expr_fn_upvars(fcx: fn_ctxt, e: @expr) {\n-    let rslt = expr_pp(fcx.ccx, e);\n-    clear_pp(rslt);\n-}\n-\n-/* Fills in annotations as a side effect. Does not rebuild the expr */\n-fn find_pre_post_expr(fcx: fn_ctxt, e: @expr) {\n-    let enclosing = fcx.enclosing;\n-    let num_local_vars = num_constraints(enclosing);\n-    fn do_rand_(fcx: fn_ctxt, e: @expr) { find_pre_post_expr(fcx, e); }\n-\n-\n-    match e.node {\n-      expr_call(operator, operands, _) {\n-        /* copy */\n-\n-        let mut args = operands;\n-        vec::push(args, operator);\n-\n-        find_pre_post_exprs(fcx, args, e.id);\n-        /* see if the call has any constraints on its type */\n-        for constraints_expr(fcx.ccx.tcx, operator).each |c| {\n-            let i =\n-                bit_num(fcx, substitute_constr_args(fcx.ccx.tcx, args, c));\n-            require(i, expr_pp(fcx.ccx, e));\n-        }\n-\n-        forget_args_moved_in(fcx, e, callee_modes(fcx, operator.id),\n-                             operands);\n-\n-        /* if this is a failing call, its postcondition sets everything */\n-        match controlflow_expr(fcx.ccx, operator) {\n-          noreturn { set_postcond_false(fcx.ccx, e.id); }\n-          _ { }\n-        }\n-      }\n-      expr_vstore(ee, _) {\n-        find_pre_post_expr(fcx, ee);\n-        let p = expr_pp(fcx.ccx, ee);\n-        set_pre_and_post(fcx.ccx, e.id, p.precondition, p.postcondition);\n-      }\n-      expr_vec(args, _) {\n-        find_pre_post_exprs(fcx, args, e.id);\n-      }\n-      expr_path(p) {\n-        let rslt = expr_pp(fcx.ccx, e);\n-        clear_pp(rslt);\n-      }\n-      expr_new(p, _, v) {\n-        find_pre_post_exprs(fcx, ~[p, v], e.id);\n-      }\n-      expr_log(_, lvl, arg) {\n-        find_pre_post_exprs(fcx, ~[lvl, arg], e.id);\n-      }\n-      expr_fn(_, _, _, cap_clause) | expr_fn_block(_, _, cap_clause) {\n-        find_pre_post_expr_fn_upvars(fcx, e);\n-\n-        for (*cap_clause).each |cap_item| {\n-            let d = local_node_id_to_local_def_id(fcx, cap_item.id);\n-            option::iter(d, |id| use_var(fcx, id) );\n-        }\n-\n-        for (*cap_clause).each |cap_item| {\n-            if cap_item.is_move {\n-                log(debug, (~\"forget_in_postcond: \", cap_item));\n-                forget_in_postcond(fcx, e.id, cap_item.id);\n-            }\n-        }\n-      }\n-      expr_block(b) {\n-        find_pre_post_block(fcx, b);\n-        let p = block_pp(fcx.ccx, b);\n-        set_pre_and_post(fcx.ccx, e.id, p.precondition, p.postcondition);\n-      }\n-      expr_rec(fields, maybe_base) {\n-        let mut es = field_exprs(fields);\n-        match maybe_base { none {/* no-op */ } some(b) { vec::push(es, b); } }\n-        find_pre_post_exprs(fcx, es, e.id);\n-      }\n-      expr_tup(elts) { find_pre_post_exprs(fcx, elts, e.id); }\n-      expr_move(lhs, rhs) { handle_update(fcx, e, lhs, rhs, oper_move); }\n-      expr_swap(lhs, rhs) { handle_update(fcx, e, lhs, rhs, oper_swap); }\n-      expr_assign(lhs, rhs) { handle_update(fcx, e, lhs, rhs, oper_assign); }\n-      expr_assign_op(_, lhs, rhs) {\n-        /* Different from expr_assign in that the lhs *must*\n-           already be initialized */\n-\n-        find_pre_post_exprs(fcx, ~[lhs, rhs], e.id);\n-        forget_in_postcond(fcx, e.id, lhs.id);\n-      }\n-      expr_lit(_) { clear_pp(expr_pp(fcx.ccx, e)); }\n-      expr_ret(maybe_val) {\n-        match maybe_val {\n-          none {\n-            clear_precond(fcx.ccx, e.id);\n-            set_postcond_false(fcx.ccx, e.id);\n-          }\n-          some(ret_val) {\n-            find_pre_post_expr(fcx, ret_val);\n-            set_precondition(node_id_to_ts_ann(fcx.ccx, e.id),\n-                             expr_precond(fcx.ccx, ret_val));\n-            set_postcond_false(fcx.ccx, e.id);\n-          }\n-        }\n-      }\n-      expr_if(antec, conseq, maybe_alt) {\n-        join_then_else(fcx, antec, conseq, maybe_alt, e.id, plain_if);\n-      }\n-      expr_binary(bop, l, r) {\n-        if lazy_binop(bop) {\n-            find_pre_post_expr(fcx, l);\n-            find_pre_post_expr(fcx, r);\n-            let overall_pre =\n-                seq_preconds(fcx,\n-                             ~[expr_pp(fcx.ccx, l), expr_pp(fcx.ccx, r)]);\n-            set_precondition(node_id_to_ts_ann(fcx.ccx, e.id), overall_pre);\n-            set_postcondition(node_id_to_ts_ann(fcx.ccx, e.id),\n-                              expr_postcond(fcx.ccx, l));\n-        } else { find_pre_post_exprs(fcx, ~[l, r], e.id); }\n-      }\n-      expr_addr_of(_, x) | expr_cast(x, _) | expr_unary(_, x) |\n-      expr_loop_body(x) | expr_do_body(x) | expr_assert(x) | expr_copy(x) {\n-        find_pre_post_expr(fcx, x);\n-        copy_pre_post(fcx.ccx, e.id, x);\n-      }\n-      expr_while(test, body) {\n-        find_pre_post_expr(fcx, test);\n-        find_pre_post_block(fcx, body);\n-        set_pre_and_post(fcx.ccx, e.id,\n-                         seq_preconds(fcx,\n-                                      ~[expr_pp(fcx.ccx, test),\n-                                       block_pp(fcx.ccx, body)]),\n-                         intersect_states(expr_postcond(fcx.ccx, test),\n-                                          block_postcond(fcx.ccx, body)));\n-      }\n-      expr_loop(body) {\n-        find_pre_post_block(fcx, body);\n-        /* Infinite loop: if control passes it, everything is true. */\n-        let mut loop_postcond = false_postcond(num_local_vars);\n-        /* Conservative approximation: if the body has any nonlocal exits,\n-         the poststate is blank since we don't know what parts of it\n-          execute. */\n-        if has_nonlocal_exits(body) {\n-            loop_postcond = empty_poststate(num_local_vars);\n-        }\n-        set_pre_and_post(fcx.ccx, e.id, block_precond(fcx.ccx, body),\n-                         loop_postcond);\n-      }\n-      expr_index(val, sub) { find_pre_post_exprs(fcx, ~[val, sub], e.id); }\n-      expr_match(ex, alts, _) {\n-        find_pre_post_expr(fcx, ex);\n-        fn do_an_alt(fcx: fn_ctxt, an_alt: arm) -> pre_and_post {\n-            match an_alt.guard {\n-              some(e) { find_pre_post_expr(fcx, e); }\n-              _ {}\n-            }\n-            find_pre_post_block(fcx, an_alt.body);\n-            return block_pp(fcx.ccx, an_alt.body);\n-        }\n-        let mut alt_pps = ~[];\n-        for alts.each |a| { vec::push(alt_pps, do_an_alt(fcx, a)); }\n-        fn combine_pp(antec: pre_and_post, fcx: fn_ctxt, &&pp: pre_and_post,\n-                      &&next: pre_and_post) -> pre_and_post {\n-            union(pp.precondition, seq_preconds(fcx, ~[antec, next]));\n-            intersect(pp.postcondition, next.postcondition);\n-            return pp;\n-        }\n-        let antec_pp = pp_clone(expr_pp(fcx.ccx, ex));\n-        let e_pp =\n-            {precondition: empty_prestate(num_local_vars),\n-             postcondition: false_postcond(num_local_vars)};\n-        let g = |a,b| combine_pp(antec_pp, fcx, a, b);\n-        let alts_overall_pp =\n-            vec::foldl(e_pp, alt_pps, g);\n-        set_pre_and_post(fcx.ccx, e.id, alts_overall_pp.precondition,\n-                         alts_overall_pp.postcondition);\n-      }\n-      expr_field(operator, _, _) {\n-        find_pre_post_expr(fcx, operator);\n-        copy_pre_post(fcx.ccx, e.id, operator);\n-      }\n-      expr_fail(maybe_val) {\n-        let mut prestate;\n-        match maybe_val {\n-          none { prestate = empty_prestate(num_local_vars); }\n-          some(fail_val) {\n-            find_pre_post_expr(fcx, fail_val);\n-            prestate = expr_precond(fcx.ccx, fail_val);\n-          }\n-        }\n-        set_pre_and_post(fcx.ccx, e.id,\n-                         /* if execution continues after fail,\n-                            then everything is true! */\n-                         prestate, false_postcond(num_local_vars));\n-      }\n-      expr_check(_, p) {\n-        find_pre_post_expr(fcx, p);\n-        copy_pre_post(fcx.ccx, e.id, p);\n-        /* predicate p holds after this expression executes */\n-\n-        let c: sp_constr = expr_to_constr(fcx.ccx.tcx, p);\n-        gen(fcx, e.id, c.node);\n-      }\n-      expr_if_check(p, conseq, maybe_alt) {\n-        join_then_else(fcx, p, conseq, maybe_alt, e.id, if_check);\n-      }\n-      expr_break { clear_pp(expr_pp(fcx.ccx, e)); }\n-      expr_again { clear_pp(expr_pp(fcx.ccx, e)); }\n-      expr_mac(_) { fcx.ccx.tcx.sess.bug(~\"unexpanded macro\"); }\n-    }\n-}\n-\n-fn find_pre_post_stmt(fcx: fn_ctxt, s: stmt) {\n-    debug!{\"stmt = %s\", stmt_to_str(s)};\n-    match s.node {\n-      stmt_decl(adecl, id) {\n-        match adecl.node {\n-          decl_local(alocals) {\n-            let prev_pp = empty_pre_post(num_constraints(fcx.enclosing));\n-            for alocals.each |alocal| {\n-                match alocal.node.init {\n-                  some(an_init) {\n-                    /* LHS always becomes initialized,\n-                     whether or not this is a move */\n-                    find_pre_post_expr(fcx, an_init.expr);\n-                    do pat_bindings(fcx.ccx.tcx.def_map, alocal.node.pat)\n-                        |p_id, _s, _n| {\n-                        copy_pre_post(fcx.ccx, p_id, an_init.expr);\n-                    };\n-                    /* Inherit ann from initializer, and add var being\n-                       initialized to the postcondition */\n-                    copy_pre_post(fcx.ccx, id, an_init.expr);\n-\n-                    let mut p = none;\n-                    match an_init.expr.node {\n-                      expr_path(_p) { p = some(_p); }\n-                      _ { }\n-                    }\n-\n-                    do pat_bindings(fcx.ccx.tcx.def_map, alocal.node.pat)\n-                        |p_id, _s, n| {\n-                        let ident = path_to_ident(n);\n-                        match p {\n-                          some(p) {\n-                            copy_in_postcond(fcx, id,\n-                                             {ident: ident, node: p_id},\n-                                             {ident:\n-                                                  path_to_ident(p),\n-                                              node: an_init.expr.id},\n-                                             op_to_oper_ty(an_init.op));\n-                          }\n-                          none { }\n-                        }\n-                    };\n-\n-                    /* Clear out anything that the previous initializer\n-                    guaranteed */\n-                    let e_pp = expr_pp(fcx.ccx, an_init.expr);\n-                    prev_pp.precondition.become(\n-                               seq_preconds(fcx, ~[prev_pp, e_pp]));\n-\n-                    /* Include the LHSs too, since those aren't in the\n-                     postconds of the RHSs themselves */\n-                    copy_pre_post_(fcx.ccx, id, prev_pp.precondition,\n-                                   prev_pp.postcondition);\n-                  }\n-                  none {\n-                    do pat_bindings(fcx.ccx.tcx.def_map, alocal.node.pat)\n-                        |p_id, _s, _n| {\n-                        clear_pp(node_id_to_ts_ann(fcx.ccx, p_id).conditions);\n-                    };\n-                    clear_pp(node_id_to_ts_ann(fcx.ccx, id).conditions);\n-                  }\n-                }\n-            }\n-          }\n-          decl_item(anitem) {\n-            clear_pp(node_id_to_ts_ann(fcx.ccx, id).conditions);\n-            find_pre_post_item(fcx.ccx, *anitem);\n-          }\n-        }\n-      }\n-      stmt_expr(e, id) | stmt_semi(e, id) {\n-        find_pre_post_expr(fcx, e);\n-        copy_pre_post(fcx.ccx, id, e);\n-      }\n-    }\n-}\n-\n-fn find_pre_post_block(fcx: fn_ctxt, b: blk) {\n-    /* Want to say that if there is a break or cont in this\n-     block, then that invalidates the poststate upheld by\n-    any of the stmts after it.\n-    Given that the typechecker has run, we know any break will be in\n-    a block that forms a loop body. So that's ok. There'll never be an\n-    expr_break outside a loop body, therefore, no expr_break outside a block.\n-    */\n-\n-    /* Conservative approximation for now: This says that if a block contains\n-     *any* breaks or conts, then its postcondition doesn't promise anything.\n-     This will mean that:\n-     x = 0;\n-     break;\n-\n-     won't have a postcondition that says x is initialized, but that's ok.\n-     */\n-\n-    let nv = num_constraints(fcx.enclosing);\n-    fn do_one_(fcx: fn_ctxt, s: @stmt) {\n-        find_pre_post_stmt(fcx, *s);\n-    }\n-    for b.node.stmts.each |s| { do_one_(fcx, s); }\n-    fn do_inner_(fcx: fn_ctxt, &&e: @expr) { find_pre_post_expr(fcx, e); }\n-    let do_inner = |a| do_inner_(fcx, a);\n-    option::map::<@expr, ()>(b.node.expr, do_inner);\n-\n-    let mut pps: ~[pre_and_post] = ~[];\n-    for b.node.stmts.each |s| { vec::push(pps, stmt_pp(fcx.ccx, *s)); }\n-    match b.node.expr {\n-      none {/* no-op */ }\n-      some(e) { vec::push(pps, expr_pp(fcx.ccx, e)); }\n-    }\n-\n-    let block_precond = seq_preconds(fcx, pps);\n-\n-    let mut postconds = ~[];\n-    for pps.each |pp| { vec::push(postconds, get_post(pp)); }\n-\n-    /* A block may be empty, so this next line ensures that the postconds\n-       vector is non-empty. */\n-    vec::push(postconds, block_precond);\n-\n-    let mut block_postcond = empty_poststate(nv);\n-    /* conservative approximation */\n-\n-    if !has_nonlocal_exits(b) {\n-        block_postcond = seq_postconds(fcx, postconds);\n-    }\n-    set_pre_and_post(fcx.ccx, b.node.id, block_precond, block_postcond);\n-}\n-\n-fn find_pre_post_fn(fcx: fn_ctxt, body: blk) {\n-    find_pre_post_block(fcx, body);\n-\n-    // Treat the tail expression as a return statement\n-    match body.node.expr {\n-      some(tailexpr) { set_postcond_false(fcx.ccx, tailexpr.id); }\n-      none {/* fallthrough */ }\n-    }\n-}\n-\n-fn fn_pre_post(fk: visit::fn_kind, decl: fn_decl, body: blk, sp: span,\n-               id: node_id,\n-               ccx: crate_ctxt, v: visit::vt<crate_ctxt>) {\n-\n-    visit::visit_fn(fk, decl, body, sp, id, ccx, v);\n-    assert (ccx.fm.contains_key(id));\n-    if !ccx.fm.get(id).ignore {\n-        let fcx =\n-            {enclosing: ccx.fm.get(id),\n-             id: id,\n-             name: visit::name_of_fn(fk),\n-             ccx: ccx};\n-        find_pre_post_fn(fcx, body);\n-    }\n-}\n-\n-//\n-// Local Variables:\n-// mode: rust\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// End:\n-//"}, {"sha": "f1bc31cbfb2ee8185d706e0ea79eca260ed09f54", "filename": "src/rustc/middle/tstate/states.rs", "status": "removed", "additions": 0, "deletions": 623, "changes": 623, "blob_url": "https://github.com/rust-lang/rust/blob/95bc9d4aef56d656e6dde057c0c9e8347b4d6e7e/src%2Frustc%2Fmiddle%2Ftstate%2Fstates.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95bc9d4aef56d656e6dde057c0c9e8347b4d6e7e/src%2Frustc%2Fmiddle%2Ftstate%2Fstates.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftstate%2Fstates.rs?ref=95bc9d4aef56d656e6dde057c0c9e8347b4d6e7e", "patch": "@@ -1,623 +0,0 @@\n-import ann::*;\n-import aux::*;\n-import tritv::*;\n-\n-import syntax::print::pprust::block_to_str;\n-import bitvectors::*;\n-import pat_util::*;\n-import syntax::ast::*;\n-import syntax::ast_util::*;\n-import syntax::print::pprust::{expr_to_str, stmt_to_str};\n-import syntax::codemap::span;\n-import middle::ty::{expr_ty, type_is_bot};\n-import util::common::{field_exprs, has_nonlocal_exits, may_break};\n-import driver::session::session;\n-import std::map::hashmap;\n-\n-fn forbid_upvar(fcx: fn_ctxt, rhs_id: node_id, sp: span, t: oper_type) {\n-    match t {\n-      oper_move {\n-        match local_node_id_to_def(fcx, rhs_id) {\n-          some(def_upvar(_, _, _)) {\n-            fcx.ccx.tcx.sess.span_err(sp,\n-                                      ~\"tried to deinitialize a variable \\\n-              declared in a different scope\");\n-          }\n-          _ { }\n-        }\n-      }\n-      _ {/* do nothing */ }\n-    }\n-}\n-\n-fn handle_move_or_copy(fcx: fn_ctxt, post: poststate, rhs_path: @path,\n-                       rhs_id: node_id, destlhs: dest, init_op: init_op) {\n-    forbid_upvar(fcx, rhs_id, rhs_path.span, op_to_oper_ty(init_op));\n-\n-    let rhs_d_id = local_node_id_to_def_id(fcx, rhs_id);\n-    match rhs_d_id {\n-      some(rhsid) {\n-        // RHS is a local var\n-        let instrhs =\n-            {ident: path_to_ident(rhs_path), node: rhsid.node};\n-        match destlhs {\n-          local_dest(instlhs) {\n-             copy_in_poststate(fcx, post, instlhs, instrhs,\n-                               op_to_oper_ty(init_op));\n-          }\n-          _ {}\n-        }\n-      }\n-      _ {\n-        // not a local -- do nothing\n-      }\n-    }\n-}\n-\n-fn seq_states(fcx: fn_ctxt, pres: prestate, bindings: ~[binding]) ->\n-   {changed: bool, post: poststate} {\n-    let mut changed = false;\n-    let mut post = pres.clone();\n-    for bindings.each |b| {\n-        match b.rhs {\n-          some(an_init) {\n-            // an expression, with or without a destination\n-            changed |=\n-                find_pre_post_state_expr(fcx, post, an_init.expr) || changed;\n-            post = expr_poststate(fcx.ccx, an_init.expr).clone();\n-            for b.lhs.each |d| {\n-                match an_init.expr.node {\n-                  expr_path(p) {\n-                    handle_move_or_copy(fcx, post, p, an_init.expr.id, d,\n-                                        an_init.op);\n-                  }\n-                  _ { }\n-                }\n-            }\n-\n-            // Forget the RHS if we just moved it.\n-            if an_init.op == init_move {\n-                forget_in_poststate(fcx, post, an_init.expr.id);\n-            }\n-          }\n-          none {\n-          }\n-        }\n-    }\n-    return {changed: changed, post: post};\n-}\n-\n-fn find_pre_post_state_sub(fcx: fn_ctxt, pres: prestate, e: @expr,\n-                           parent: node_id, c: option<tsconstr>) -> bool {\n-    let mut changed = find_pre_post_state_expr(fcx, pres, e);\n-\n-    changed = set_prestate_ann(fcx.ccx, parent, pres) || changed;\n-\n-    let post = expr_poststate(fcx.ccx, e).clone();\n-    match c {\n-      none { }\n-      some(c1) { set_in_poststate_(bit_num(fcx, c1), post); }\n-    }\n-\n-    changed = set_poststate_ann(fcx.ccx, parent, post) || changed;\n-    return changed;\n-}\n-\n-fn find_pre_post_state_two(fcx: fn_ctxt, pres: prestate, lhs: @expr,\n-                           rhs: @expr, parent: node_id, ty: oper_type) ->\n-   bool {\n-    let mut changed = set_prestate_ann(fcx.ccx, parent, pres);\n-    changed = find_pre_post_state_expr(fcx, pres, lhs) || changed;\n-    changed =\n-        find_pre_post_state_expr(fcx, expr_poststate(fcx.ccx, lhs), rhs) ||\n-            changed;\n-    forbid_upvar(fcx, rhs.id, rhs.span, ty);\n-\n-    let post = expr_poststate(fcx.ccx, rhs).clone();\n-\n-    match lhs.node {\n-      expr_path(p) {\n-        // for termination, need to make sure intermediate changes don't set\n-        // changed flag\n-        // tmp remembers \"old\" constraints we'd otherwise forget,\n-        // for substitution purposes\n-        let tmp = post.clone();\n-\n-        match ty {\n-          oper_move {\n-            if is_path(rhs) { forget_in_poststate(fcx, post, rhs.id); }\n-            forget_in_poststate(fcx, post, lhs.id);\n-          }\n-          oper_swap {\n-            forget_in_poststate(fcx, post, lhs.id);\n-            forget_in_poststate(fcx, post, rhs.id);\n-          }\n-          _ { forget_in_poststate(fcx, post, lhs.id); }\n-        }\n-\n-        match rhs.node {\n-          expr_path(p1) {\n-            let d = local_node_id_to_local_def_id(fcx, lhs.id);\n-            let d1 = local_node_id_to_local_def_id(fcx, rhs.id);\n-            match d {\n-              some(id) {\n-                match d1 {\n-                  some(id1) {\n-                    let instlhs =\n-                        {ident: path_to_ident(p), node: id};\n-                    let instrhs =\n-                        {ident: path_to_ident(p1), node: id1};\n-                    copy_in_poststate_two(fcx, tmp, post, instlhs, instrhs,\n-                                          ty);\n-                  }\n-                  _ { }\n-                }\n-              }\n-              _ { }\n-            }\n-          }\n-          _ {/* do nothing */ }\n-        }\n-      }\n-      _ { }\n-    }\n-    changed = set_poststate_ann(fcx.ccx, parent, post) || changed;\n-    return changed;\n-}\n-\n-fn find_pre_post_state_call(fcx: fn_ctxt, pres: prestate, a: @expr,\n-                            id: node_id, ops: ~[init_op], bs: ~[@expr],\n-                            cf: ret_style) -> bool {\n-    let mut changed = find_pre_post_state_expr(fcx, pres, a);\n-    // FIXME (#2178): This could be a typestate constraint (except we're\n-    // not using them inside the compiler, I guess... see discussion in\n-    // bug)\n-    if vec::len(bs) != vec::len(ops) {\n-        fcx.ccx.tcx.sess.span_bug(a.span,\n-                                  fmt!{\"mismatched arg lengths: \\\n-                                        %u exprs vs. %u ops\",\n-                                       vec::len(bs), vec::len(ops)});\n-    }\n-    return find_pre_post_state_exprs(fcx, pres, id, ops,\n-                                   bs, cf) || changed;\n-}\n-\n-fn find_pre_post_state_exprs(fcx: fn_ctxt, pres: prestate, id: node_id,\n-                             ops: ~[init_op], es: ~[@expr],\n-                             cf: ret_style) -> bool {\n-    let rs = seq_states(fcx, pres, arg_bindings(ops, es));\n-    let mut changed = rs.changed | set_prestate_ann(fcx.ccx, id, pres);\n-    /* if this is a failing call, it sets everything as initialized */\n-    match cf {\n-      noreturn {\n-        let post = false_postcond(num_constraints(fcx.enclosing));\n-        changed |= set_poststate_ann(fcx.ccx, id, post);\n-      }\n-      _ { changed |= set_poststate_ann(fcx.ccx, id, rs.post); }\n-    }\n-    return changed;\n-}\n-\n-fn join_then_else(fcx: fn_ctxt, antec: @expr, conseq: blk,\n-                  maybe_alt: option<@expr>, id: node_id, chk: if_ty,\n-                  pres: prestate) -> bool {\n-    let mut changed =\n-        set_prestate_ann(fcx.ccx, id, pres) |\n-            find_pre_post_state_expr(fcx, pres, antec);\n-\n-    match maybe_alt {\n-      none {\n-        match chk {\n-          if_check {\n-            let c: sp_constr = expr_to_constr(fcx.ccx.tcx, antec);\n-            let conseq_prestate = expr_poststate(fcx.ccx, antec).clone();\n-            conseq_prestate.set(bit_num(fcx, c.node), ttrue);\n-            changed |=\n-                find_pre_post_state_block(fcx, conseq_prestate, conseq) |\n-                    set_poststate_ann(fcx.ccx, id,\n-                                      expr_poststate(fcx.ccx, antec));\n-          }\n-          _ {\n-            changed |=\n-                find_pre_post_state_block(fcx, expr_poststate(fcx.ccx, antec),\n-                                          conseq) |\n-                    set_poststate_ann(fcx.ccx, id,\n-                                      expr_poststate(fcx.ccx, antec));\n-          }\n-        }\n-      }\n-      some(altern) {\n-        changed |=\n-            find_pre_post_state_expr(fcx, expr_poststate(fcx.ccx, antec),\n-                                     altern);\n-\n-        let mut conseq_prestate = expr_poststate(fcx.ccx, antec);\n-        match chk {\n-          if_check {\n-            let c: sp_constr = expr_to_constr(fcx.ccx.tcx, antec);\n-            conseq_prestate = conseq_prestate.clone();\n-            conseq_prestate.set(bit_num(fcx, c.node),  ttrue);\n-          }\n-          _ { }\n-        }\n-\n-\n-        changed |= find_pre_post_state_block(fcx, conseq_prestate, conseq);\n-\n-        let poststate_res =\n-            intersect_states(block_poststate(fcx.ccx, conseq),\n-                             expr_poststate(fcx.ccx, altern));\n-        /*\n-           fcx.ccx.tcx.sess.span_note(antec.span,\n-           \"poststate_res = \" + aux::tritv_to_str(fcx, poststate_res));\n-        fcx.ccx.tcx.sess.span_note(antec.span,\n-           \"altern poststate = \" +\n-            aux::tritv_to_str(fcx, expr_poststate(fcx.ccx, altern)));\n-        fcx.ccx.tcx.sess.span_note(antec.span,\n-        \"conseq poststate = \" + aux::tritv_to_str(fcx,\n-           block_poststate(fcx.ccx, conseq)));\n-        */\n-\n-        changed |= set_poststate_ann(fcx.ccx, id, poststate_res);\n-      }\n-    }\n-    return changed;\n-}\n-\n-fn find_pre_post_state_cap_clause(fcx: fn_ctxt, e_id: node_id,\n-                                  pres: prestate, cap_clause: capture_clause)\n-    -> bool\n-{\n-    let ccx = fcx.ccx;\n-    let pres_changed = set_prestate_ann(ccx, e_id, pres);\n-    let post = pres.clone();\n-    for (*cap_clause).each |cap_item| {\n-        if cap_item.is_move {\n-            forget_in_poststate(fcx, post, cap_item.id);\n-        }\n-    }\n-    return set_poststate_ann(ccx, e_id, post) || pres_changed;\n-}\n-\n-fn find_pre_post_state_expr(fcx: fn_ctxt, pres: prestate, e: @expr) -> bool {\n-    let num_constrs = num_constraints(fcx.enclosing);\n-\n-    match e.node {\n-      expr_new(p, _, v) {\n-        return find_pre_post_state_two(fcx, pres, p, v, e.id, oper_pure);\n-      }\n-      expr_vstore(ee, _) {\n-        let mut changed = find_pre_post_state_expr(fcx, pres, ee);\n-        set_prestate_ann(fcx.ccx, e.id, expr_prestate(fcx.ccx, ee));\n-        set_poststate_ann(fcx.ccx, e.id, expr_poststate(fcx.ccx, ee));\n-        return changed;\n-      }\n-      expr_vec(elts, _) {\n-        return find_pre_post_state_exprs(fcx, pres, e.id,\n-                                      vec::from_elem(vec::len(elts),\n-                                                    init_assign), elts,\n-                                      return_val);\n-      }\n-      expr_call(operator, operands, _) {\n-        debug!{\"hey it's a call: %s\", expr_to_str(e)};\n-        return find_pre_post_state_call(fcx, pres, operator, e.id,\n-                                     callee_arg_init_ops(fcx, operator.id),\n-                                     operands,\n-                                     controlflow_expr(fcx.ccx, operator));\n-      }\n-      expr_path(_) { return pure_exp(fcx.ccx, e.id, pres); }\n-      expr_log(_, lvl, ex) {\n-        return find_pre_post_state_two(fcx, pres, lvl, ex, e.id, oper_pure);\n-      }\n-      expr_mac(_) { fcx.ccx.tcx.sess.bug(~\"unexpanded macro\"); }\n-      expr_lit(l) { return pure_exp(fcx.ccx, e.id, pres); }\n-      expr_fn(_, _, _, cap_clause) {\n-        return find_pre_post_state_cap_clause(fcx, e.id, pres, cap_clause);\n-      }\n-      expr_fn_block(_, _, cap_clause) {\n-        return find_pre_post_state_cap_clause(fcx, e.id, pres, cap_clause);\n-      }\n-      expr_block(b) {\n-        return find_pre_post_state_block(fcx, pres, b) |\n-                set_prestate_ann(fcx.ccx, e.id, pres) |\n-                set_poststate_ann(fcx.ccx, e.id, block_poststate(fcx.ccx, b));\n-      }\n-      expr_rec(fields, maybe_base) {\n-        let exs = field_exprs(fields);\n-        let mut changed =\n-            find_pre_post_state_exprs(fcx, pres, e.id,\n-                                      vec::from_elem(vec::len(fields),\n-                                                    init_assign),\n-                                      exs, return_val);\n-\n-        let base_pres = match vec::last_opt(exs) { none { pres }\n-                          some(f) { expr_poststate(fcx.ccx, f) }};\n-        option::iter(maybe_base, |base| {\n-            changed |= find_pre_post_state_expr(fcx, base_pres, base) |\n-                set_poststate_ann(fcx.ccx, e.id,\n-                                  expr_poststate(fcx.ccx, base))\n-        });\n-        return changed;\n-      }\n-      expr_tup(elts) {\n-        return find_pre_post_state_exprs(fcx, pres, e.id,\n-                                      vec::from_elem(vec::len(elts),\n-                                                    init_assign), elts,\n-                                      return_val);\n-      }\n-      expr_move(lhs, rhs) {\n-        return find_pre_post_state_two(fcx, pres, lhs, rhs, e.id, oper_move);\n-      }\n-      expr_assign(lhs, rhs) {\n-        return find_pre_post_state_two(\n-            fcx, pres, lhs, rhs, e.id, oper_assign);\n-      }\n-      expr_swap(lhs, rhs) {\n-        return find_pre_post_state_two(fcx, pres, lhs, rhs, e.id, oper_swap);\n-        // Could be more precise and actually swap the role of\n-        // lhs and rhs in constraints\n-      }\n-      expr_ret(maybe_ret_val) {\n-        let mut changed = set_prestate_ann(fcx.ccx, e.id, pres);\n-        /* everything is true if execution continues after\n-           a return expression (since execution never continues locally\n-           after a return expression */\n-        let post = false_postcond(num_constrs);\n-\n-        set_poststate_ann(fcx.ccx, e.id, post);\n-\n-        match maybe_ret_val {\n-          none {/* do nothing */ }\n-          some(ret_val) {\n-            changed |= find_pre_post_state_expr(fcx, pres, ret_val);\n-          }\n-        }\n-        return changed;\n-      }\n-      expr_if(antec, conseq, maybe_alt) {\n-        return join_then_else(fcx, antec, conseq, maybe_alt, e.id, plain_if,\n-                           pres);\n-      }\n-      expr_binary(bop, l, r) {\n-        if lazy_binop(bop) {\n-            let mut changed = find_pre_post_state_expr(fcx, pres, l);\n-            changed |=\n-                find_pre_post_state_expr(fcx, expr_poststate(fcx.ccx, l), r);\n-            return changed | set_prestate_ann(fcx.ccx, e.id, pres) |\n-                    set_poststate_ann(fcx.ccx, e.id,\n-                                      expr_poststate(fcx.ccx, l));\n-        } else {\n-            return find_pre_post_state_two(fcx, pres, l, r, e.id, oper_pure);\n-        }\n-      }\n-      expr_assign_op(op, lhs, rhs) {\n-        return find_pre_post_state_two(fcx, pres, lhs, rhs, e.id,\n-                                    oper_assign_op);\n-      }\n-      expr_while(test, body) {\n-        let loop_pres =\n-            intersect_states(block_poststate(fcx.ccx, body), pres);\n-\n-        let mut changed =\n-            set_prestate_ann(fcx.ccx, e.id, loop_pres) |\n-                find_pre_post_state_expr(fcx, loop_pres, test) |\n-                find_pre_post_state_block(fcx, expr_poststate(fcx.ccx, test),\n-                                          body);\n-\n-        /* conservative approximation: if a loop contains a break\n-           or cont, we assume nothing about the poststate */\n-        /* which is still unsound -- see ~[Break-unsound] */\n-        if has_nonlocal_exits(body) {\n-            return changed | set_poststate_ann(fcx.ccx, e.id, pres);\n-        } else {\n-            let e_post = expr_poststate(fcx.ccx, test);\n-            let b_post = block_poststate(fcx.ccx, body);\n-            return changed |\n-                    set_poststate_ann(fcx.ccx, e.id,\n-                                      intersect_states(e_post, b_post));\n-        }\n-      }\n-      expr_loop(body) {\n-        let loop_pres =\n-            intersect_states(block_poststate(fcx.ccx, body), pres);\n-        let mut changed = set_prestate_ann(fcx.ccx, e.id, loop_pres)\n-              | find_pre_post_state_block(fcx, loop_pres, body);\n-        /* conservative approximation: if a loop contains a break\n-           or cont, we assume nothing about the poststate (so, we\n-           set all predicates to \"don't know\" */\n-        /* which is still unsound -- see ~[Break-unsound] */\n-        if may_break(body) {\n-                /* Only do this if there are *breaks* not conts.\n-                 An infinite loop with conts is still an infinite loop.\n-                We assume all preds are FALSE, not '?' -- because in the\n-                worst case, the body could invalidate all preds and\n-                deinitialize everything before breaking */\n-            let post = empty_poststate(num_constrs);\n-            post.kill();\n-            return changed | set_poststate_ann(fcx.ccx, e.id, post);\n-        } else {\n-            return changed | set_poststate_ann(fcx.ccx, e.id,\n-                                            false_postcond(num_constrs));\n-        }\n-      }\n-      expr_index(val, sub) {\n-        return find_pre_post_state_two(fcx, pres, val, sub, e.id, oper_pure);\n-      }\n-      expr_match(val, alts, _) {\n-        let mut changed =\n-            set_prestate_ann(fcx.ccx, e.id, pres) |\n-                find_pre_post_state_expr(fcx, pres, val);\n-        let e_post = expr_poststate(fcx.ccx, val);\n-        let mut a_post;\n-        if vec::len(alts) > 0u {\n-            a_post = false_postcond(num_constrs);\n-            for alts.each |an_alt| {\n-                match an_alt.guard {\n-                  some(e) {\n-                    changed |= find_pre_post_state_expr(fcx, e_post, e);\n-                  }\n-                  _ {}\n-                }\n-                changed |=\n-                    find_pre_post_state_block(fcx, e_post, an_alt.body);\n-                intersect(a_post, block_poststate(fcx.ccx, an_alt.body));\n-                // We deliberately do *not* update changed here, because\n-                // we'd go into an infinite loop that way, and the change\n-                // gets made after the if expression.\n-\n-            }\n-        } else {\n-            // No alts; poststate is the poststate of the test\n-\n-            a_post = e_post;\n-        }\n-        return changed | set_poststate_ann(fcx.ccx, e.id, a_post);\n-      }\n-      expr_field(x, _, _) | expr_loop_body(x) | expr_do_body(x) |\n-      expr_unary(_, x) |\n-      expr_addr_of(_, x) | expr_assert(x) | expr_cast(x, _) |\n-      expr_copy(x) {\n-        return find_pre_post_state_sub(fcx, pres, x, e.id, none);\n-      }\n-      expr_fail(maybe_fail_val) {\n-        /* if execution continues after fail, then everything is true!\n-        woo! */\n-        let post = false_postcond(num_constrs);\n-        return set_prestate_ann(fcx.ccx, e.id, pres) |\n-                set_poststate_ann(fcx.ccx, e.id, post) |\n-                option::map_default(\n-                    maybe_fail_val, false,\n-                    |fail_val|\n-                    find_pre_post_state_expr(fcx, pres, fail_val) );\n-      }\n-      expr_check(_, p) {\n-        /* predicate p holds after this expression executes */\n-        let c: sp_constr = expr_to_constr(fcx.ccx.tcx, p);\n-        return find_pre_post_state_sub(fcx, pres, p, e.id, some(c.node));\n-      }\n-      expr_if_check(p, conseq, maybe_alt) {\n-        return join_then_else(\n-            fcx, p, conseq, maybe_alt, e.id, if_check, pres);\n-      }\n-      expr_break { return pure_exp(fcx.ccx, e.id, pres); }\n-      expr_again { return pure_exp(fcx.ccx, e.id, pres); }\n-    }\n-}\n-\n-fn find_pre_post_state_stmt(fcx: fn_ctxt, pres: prestate, s: @stmt) -> bool {\n-    let stmt_ann = stmt_to_ann(fcx.ccx, *s);\n-\n-    debug!{\"[ %s ]\", *fcx.name};\n-    debug!{\"*At beginning: stmt = %s\", stmt_to_str(*s)};\n-    debug!{\"*prestate = %s\", stmt_ann.states.prestate.to_str()};\n-    debug!{\"*poststate = %s\", stmt_ann.states.prestate.to_str()};\n-\n-    match s.node {\n-      stmt_decl(adecl, id) {\n-        match adecl.node {\n-          decl_local(alocals) {\n-            set_prestate(stmt_ann, pres);\n-            let c_and_p = seq_states(fcx, pres,\n-                  locals_to_bindings(fcx.ccx.tcx, alocals));\n-            /* important to do this in one step to ensure\n-            termination (don't want to set changed to true\n-            for intermediate changes) */\n-\n-            let mut changed =\n-                set_poststate(stmt_ann, c_and_p.post) | c_and_p.changed;\n-\n-            debug!{\"Summary: stmt = %s\", stmt_to_str(*s)};\n-            debug!{\"prestate = %s\", stmt_ann.states.prestate.to_str()};\n-            debug!{\"poststate = %s\", stmt_ann.states.poststate.to_str()};\n-            debug!{\"changed = %s\", bool::to_str(changed)};\n-\n-            return changed;\n-          }\n-          decl_item(an_item) {\n-            return set_prestate(stmt_ann, pres)\n-                | set_poststate(stmt_ann, pres);\n-            /* the outer visitor will recurse into the item */\n-          }\n-        }\n-      }\n-      stmt_expr(ex, _) | stmt_semi(ex, _) {\n-        let mut changed =\n-            find_pre_post_state_expr(fcx, pres, ex) |\n-                set_prestate(stmt_ann, expr_prestate(fcx.ccx, ex)) |\n-                set_poststate(stmt_ann, expr_poststate(fcx.ccx, ex));\n-\n-\n-        debug!{\"Finally: %s\", stmt_to_str(*s)};\n-        debug!{\"prestate = %s\", stmt_ann.states.prestate.to_str()};\n-        debug!{\"poststate = %s\", stmt_ann.states.poststate.to_str()};\n-        debug!{\"changed = %s\", bool::to_str(changed)};\n-\n-        return changed;\n-      }\n-    }\n-}\n-\n-\n-/* Updates the pre- and post-states of statements in the block,\n-   returns a boolean flag saying whether any pre- or poststates changed */\n-fn find_pre_post_state_block(fcx: fn_ctxt, pres0: prestate, b: blk) -> bool {\n-    /* First, set the pre-states and post-states for every expression */\n-\n-    let mut pres = pres0;\n-    /* Iterate over each stmt. The new prestate is <pres>. The poststate\n-     consist of improving <pres> with whatever variables this stmt\n-     initializes.  Then <pres> becomes the new poststate. */\n-\n-    let mut changed = false;\n-    for b.node.stmts.each |s| {\n-        changed |= find_pre_post_state_stmt(fcx, pres, s);\n-        pres = stmt_poststate(fcx.ccx, *s);\n-    }\n-    let mut post = pres;\n-    match b.node.expr {\n-      none { }\n-      some(e) {\n-        changed |= find_pre_post_state_expr(fcx, pres, e);\n-        post = expr_poststate(fcx.ccx, e);\n-      }\n-    }\n-\n-    set_prestate_ann(fcx.ccx, b.node.id, pres0);\n-    set_poststate_ann(fcx.ccx, b.node.id, post);\n-\n-    return changed;\n-}\n-\n-fn find_pre_post_state_fn(fcx: fn_ctxt,\n-                          f_decl: fn_decl,\n-                          f_body: blk) -> bool {\n-    // All constraints are considered false until proven otherwise.\n-    // This ensures that intersect works correctly.\n-    kill_all_prestate(fcx, f_body.node.id);\n-\n-    // Instantiate any constraints on the arguments so we can use them\n-    let block_pre = block_prestate(fcx.ccx, f_body);\n-    for f_decl.constraints.each |c| {\n-        let tsc = ast_constr_to_ts_constr(fcx.ccx.tcx, f_decl.inputs, c);\n-        set_in_prestate_constr(fcx, tsc, block_pre);\n-    }\n-\n-    let mut changed = find_pre_post_state_block(fcx, block_pre, f_body);\n-\n-    /*\n-        error!{\"find_pre_post_state_fn\"};\n-        log(error, changed);\n-        fcx.ccx.tcx.sess.span_note(f_body.span, fcx.name);\n-    */\n-\n-    return changed;\n-}\n-//\n-// Local Variables:\n-// mode: rust\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// End:\n-//"}, {"sha": "b6110121171c18af7cff7948759cd9f9216b20f7", "filename": "src/rustc/middle/tstate/tritv.rs", "status": "removed", "additions": 0, "deletions": 270, "changes": 270, "blob_url": "https://github.com/rust-lang/rust/blob/95bc9d4aef56d656e6dde057c0c9e8347b4d6e7e/src%2Frustc%2Fmiddle%2Ftstate%2Ftritv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95bc9d4aef56d656e6dde057c0c9e8347b4d6e7e/src%2Frustc%2Fmiddle%2Ftstate%2Ftritv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftstate%2Ftritv.rs?ref=95bc9d4aef56d656e6dde057c0c9e8347b4d6e7e", "patch": "@@ -1,270 +0,0 @@\n-import std::bitv::*;\n-\n-export t;\n-export create_tritv;\n-export trit, tfalse, ttrue, dont_care;\n-\n-/* for a fixed index:\n-   10 = \"this constraint may or may not be true after execution\"\n-   01 = \"this constraint is definitely true\"\n-   00 = \"this constraint is definitely false\"\n-   11 should never appear\n- FIXME (#2178): typestate precondition (uncertain and val must\n- have the same length; 11 should never appear in a given position)\n- (except we're not putting typestate constraints in the compiler, as\n- per discussion at).\n-*/\n-\n-enum trit { ttrue, tfalse, dont_care, }\n-\n-class t {\n-    // Shouldn't be mut; instead we should have a different\n-    // constructor that takes two bitvs\n-    let mut uncertain: bitv;\n-    let mut val: bitv;\n-    let nbits: uint;\n-    // next two should be private (#2297)\n-    fn set_uncertain(-b: bitv) {\n-        self.uncertain <- b;\n-    }\n-    fn set_val(-b: bitv) {\n-        self.val <- b;\n-    }\n-    fn clone() -> t {\n-        let rs = t(self.nbits);\n-        let r = self.uncertain.clone();\n-        rs.set_uncertain(r);\n-        let r1 = self.val.clone();\n-        rs.set_val(r1);\n-        rs\n-    }\n-    fn difference(p: t) -> bool {\n-        assert (self.nbits == p.nbits);\n-        let mut changed = false;\n-        for uint::range(0, p.nbits) |i| {\n-           let old = p.get(i);\n-           let newv = minus(old, p.get(i));\n-           changed = change(changed, old, newv);\n-           self.set(i, newv);\n-        };\n-        changed\n-    }\n-    pure fn get(i: uint) -> trit {\n-        let b1 = self.uncertain.get(i);\n-        let b2 = self.val.get(i);\n-        assert (!(b1 && b2));\n-        if b1 { dont_care } else if b2 { ttrue } else { tfalse }\n-    }\n-    pure fn set(i: uint, t: trit) -> bool {\n-        let old = self.get(i);\n-        match t {\n-          dont_care {\n-            self.uncertain.set(i, true);\n-            self.val.set(i, false);\n-          }\n-          ttrue {\n-            self.uncertain.set(i, false);\n-            self.val.set(i, true);\n-          }\n-          tfalse {\n-            self.uncertain.set(i, false);\n-            self.val.set(i, false);\n-          }\n-        }\n-        change(false, old, t)\n-    }\n-\n-    fn set_all() {\n-      for uint::range(0u, self.nbits) |i| {\n-         self.set(i, ttrue);\n-      }\n-    }\n-\n-    fn clear() {\n-      for uint::range(0, self.nbits) |i| {\n-         self.set(i, dont_care);\n-      }\n-    }\n-\n-    fn kill() {\n-       for uint::range(0, self.nbits) |i| {\n-           self.set(i, dont_care);\n-       }\n-    }\n-\n-    fn doesntcare() -> bool {\n-        for uint::range(0, self.nbits) |i| {\n-           if self.get(i) != dont_care { return false; }\n-        }\n-        true\n-    }\n-\n-    fn to_vec() -> ~[uint] {\n-      let mut rslt: ~[uint] = ~[];\n-      for uint::range(0, self.nbits) |i| {\n-        vec::push(rslt,\n-                  match self.get(i) {\n-                      dont_care { 2 }\n-                      ttrue     { 1 }\n-                      tfalse    { 0 }\n-                  });\n-      };\n-      rslt\n-    }\n-\n-    fn to_str() -> str {\n-       let mut rs: str = \"\";\n-       for uint::range(0, self.nbits) |i| {\n-        rs +=\n-            match self.get(i) {\n-              dont_care { \"?\" }\n-              ttrue { \"1\" }\n-              tfalse { \"0\" }\n-            };\n-       };\n-       rs\n-    }\n-\n-    fn intersect(p: t) -> bool {\n-      assert (self.nbits == p.nbits);\n-      let mut changed = false;\n-      for uint::range(0, self.nbits) |i| {\n-        let old = self.get(i);\n-        let newv = trit_and(old, p.get(i));\n-        changed = change(changed, old, newv);\n-        self.set(i, newv);\n-       }\n-      return changed;\n-    }\n-\n-    fn become(source: t) -> bool {\n-      assert (self.nbits == source.nbits);\n-      let changed = !self.uncertain.equal(source.uncertain) ||\n-          !self.val.equal(source.val);\n-      self.uncertain.assign(source.uncertain);\n-      self.val.assign(source.val);\n-      changed\n-    }\n-\n-    fn union(p: t) -> bool {\n-        assert (self.nbits == p.nbits);\n-        let mut changed = false;\n-        for uint::range(0, self.nbits) |i| {\n-           let old = self.get(i);\n-           let newv = trit_or(old, p.get(i));\n-           changed = change(changed, old, newv);\n-           self.set(i, newv);\n-        }\n-        return changed;\n-    }\n-\n-    new(len: uint) {\n-        self.uncertain = mk_bitv(len, true);\n-        self.val = mk_bitv(len, false);\n-        self.nbits = len;\n-    }\n-}\n-\n-fn create_tritv(len: uint) -> t { t(len) }\n-\n-\n-fn minus(a: trit, b: trit) -> trit {\n-\n-    /*   2 - anything = 2\n-         1 - 1 = 2\n-         1 - 0 is an error\n-         1 - 2 = 1\n-         0 - 1 is an error\n-         0 - anything else - 0\n-     */\n-    match a {\n-      dont_care { dont_care }\n-      ttrue {\n-        match b {\n-          ttrue { dont_care }\n-          tfalse { ttrue }\n-          /* internally contradictory, but\n-             I guess it'll get flagged? */\n-          dont_care {\n-            ttrue\n-          }\n-        }\n-      }\n-      tfalse {\n-        match b {\n-          ttrue { tfalse }\n-          /* see above comment */\n-          _ {\n-            tfalse\n-          }\n-        }\n-      }\n-     }\n-    }\n-\n-fn trit_or(a: trit, b: trit) -> trit {\n-    match a {\n-      dont_care { b }\n-      ttrue { ttrue }\n-      tfalse {\n-        match b {\n-          ttrue { dont_care }\n-          /* FIXME (#2538): ??????\n-             Again, unit tests would help here\n-           */\n-          _ {\n-            tfalse\n-          }\n-        }\n-      }\n-    }\n-}\n-\n-// FIXME (#2538): This still seems kind of dodgy to me (that is,\n-// that 1 + ? = 1. But it might work out given that\n-// all variables start out in a 0 state. Probably I need\n-// to make it so that all constraints start out in a 0 state\n-// (we consider a constraint false until proven true), too.\n-fn trit_and(a: trit, b: trit) -> trit {\n-    match a {\n-      dont_care { b }\n-      // also seems wrong for case b = ttrue\n-      ttrue {\n-        match b {\n-          dont_care { ttrue }\n-          // ??? Seems wrong\n-          ttrue {\n-            ttrue\n-          }\n-          // false wins, since if something is uninit\n-          // on one path, we care\n-          // (Rationale: it's always safe to assume that\n-          // a var is uninitialized or that a constraint\n-          // needs to be re-established)\n-          tfalse {\n-            tfalse\n-          }\n-        }\n-      }\n-      // Rationale: if it's uninit on one path,\n-      // we can consider it as uninit on all paths\n-      tfalse {\n-        tfalse\n-      }\n-    }\n-    // if the result is dont_care, that means\n-    // a and b were both dont_care\n-}\n-\n-pure fn change(changed: bool, old: trit, newv: trit) -> bool {\n-    changed || newv != old\n-}\n-//\n-// Local Variables:\n-// mode: rust\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// End:\n-//"}]}