{"sha": "d307e6c1970d1edb63d6a08d332e0acdb72c5cc5", "node_id": "C_kwDOAAsO6NoAKGQzMDdlNmMxOTcwZDFlZGI2M2Q2YTA4ZDMzMmUwYWNkYjcyYzVjYzU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-12-24T11:04:48Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-12-24T11:04:48Z"}, "message": "Auto merge of #1928 - RalfJung:fn-abi, r=RalfJung\n\nadjust for FnAbi changes\n\nThis is the Miri side of https://github.com/rust-lang/rust/pull/91342.", "tree": {"sha": "c20ed495ae363cd90d98d460dcdd7c81811b4498", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c20ed495ae363cd90d98d460dcdd7c81811b4498"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d307e6c1970d1edb63d6a08d332e0acdb72c5cc5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d307e6c1970d1edb63d6a08d332e0acdb72c5cc5", "html_url": "https://github.com/rust-lang/rust/commit/d307e6c1970d1edb63d6a08d332e0acdb72c5cc5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d307e6c1970d1edb63d6a08d332e0acdb72c5cc5/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2170d7a7c9ee7c7ee943acf6d7db928b9587cb39", "url": "https://api.github.com/repos/rust-lang/rust/commits/2170d7a7c9ee7c7ee943acf6d7db928b9587cb39", "html_url": "https://github.com/rust-lang/rust/commit/2170d7a7c9ee7c7ee943acf6d7db928b9587cb39"}, {"sha": "5ab0ea67f20e723d4d297fe332255a1c1c641a6c", "url": "https://api.github.com/repos/rust-lang/rust/commits/5ab0ea67f20e723d4d297fe332255a1c1c641a6c", "html_url": "https://github.com/rust-lang/rust/commit/5ab0ea67f20e723d4d297fe332255a1c1c641a6c"}], "stats": {"total": 174, "additions": 93, "deletions": 81}, "files": [{"sha": "1ff2a14b5baae260fbb3b0b5f022e981a94c10c4", "filename": "rust-version", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d307e6c1970d1edb63d6a08d332e0acdb72c5cc5/rust-version", "raw_url": "https://github.com/rust-lang/rust/raw/d307e6c1970d1edb63d6a08d332e0acdb72c5cc5/rust-version", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rust-version?ref=d307e6c1970d1edb63d6a08d332e0acdb72c5cc5", "patch": "@@ -1 +1 @@\n-41c3017c82bbc16842cc3bc1afa904e6910e293c\n+59337cddd41880f8075b07860a99be4dc402ddb1"}, {"sha": "0cc6138ca702a66e182e785273e59d0d2c47dd4a", "filename": "src/helpers.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d307e6c1970d1edb63d6a08d332e0acdb72c5cc5/src%2Fhelpers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d307e6c1970d1edb63d6a08d332e0acdb72c5cc5/src%2Fhelpers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fhelpers.rs?ref=d307e6c1970d1edb63d6a08d332e0acdb72c5cc5", "patch": "@@ -687,7 +687,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         link_name: Symbol,\n     ) -> InterpResult<'tcx, ()> {\n         self.check_abi(abi, exp_abi)?;\n-        if let Some(body) = self.eval_context_mut().lookup_exported_symbol(link_name)? {\n+        if let Some((body, _)) = self.eval_context_mut().lookup_exported_symbol(link_name)? {\n             throw_machine_stop!(TerminationInfo::SymbolShimClashing {\n                 link_name,\n                 span: body.span.data(),"}, {"sha": "7cde8a8df681b138c78bc473e526b4c979aca1cd", "filename": "src/machine.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d307e6c1970d1edb63d6a08d332e0acdb72c5cc5/src%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d307e6c1970d1edb63d6a08d332e0acdb72c5cc5/src%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmachine.rs?ref=d307e6c1970d1edb63d6a08d332e0acdb72c5cc5", "patch": "@@ -452,7 +452,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n         args: &[OpTy<'tcx, Tag>],\n         ret: Option<(&PlaceTy<'tcx, Tag>, mir::BasicBlock)>,\n         unwind: StackPopUnwind,\n-    ) -> InterpResult<'tcx, Option<&'mir mir::Body<'tcx>>> {\n+    ) -> InterpResult<'tcx, Option<(&'mir mir::Body<'tcx>, ty::Instance<'tcx>)>> {\n         ecx.find_mir_or_eval_fn(instance, abi, args, ret, unwind)\n     }\n "}, {"sha": "b07db9535129fed93853e6762b4afa060fed1906", "filename": "src/shims/foreign_items.rs", "status": "modified", "additions": 84, "deletions": 70, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/d307e6c1970d1edb63d6a08d332e0acdb72c5cc5/src%2Fshims%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d307e6c1970d1edb63d6a08d332e0acdb72c5cc5/src%2Fshims%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fforeign_items.rs?ref=d307e6c1970d1edb63d6a08d332e0acdb72c5cc5", "patch": "@@ -1,4 +1,5 @@\n use std::{\n+    collections::hash_map::Entry,\n     convert::{TryFrom, TryInto},\n     iter,\n };\n@@ -34,7 +35,7 @@ pub enum EmulateByNameResult<'mir, 'tcx> {\n     /// Jumping has already been taken care of.\n     AlreadyJumped,\n     /// A MIR body has been found for the function\n-    MirBody(&'mir mir::Body<'tcx>),\n+    MirBody(&'mir mir::Body<'tcx>, ty::Instance<'tcx>),\n     /// The item is not supported.\n     NotSupported,\n }\n@@ -135,81 +136,91 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     fn lookup_exported_symbol(\n         &mut self,\n         link_name: Symbol,\n-    ) -> InterpResult<'tcx, Option<&'mir mir::Body<'tcx>>> {\n+    ) -> InterpResult<'tcx, Option<(&'mir mir::Body<'tcx>, ty::Instance<'tcx>)>> {\n         let this = self.eval_context_mut();\n         let tcx = this.tcx.tcx;\n \n         // If the result was cached, just return it.\n-        if let Some(instance) = this.machine.exported_symbols_cache.get(&link_name) {\n-            return instance.map(|instance| this.load_mir(instance.def, None)).transpose();\n-        }\n-\n-        // Find it if it was not cached.\n-        let mut instance_and_crate: Option<(ty::Instance<'_>, CrateNum)> = None;\n-        // `dependency_formats` includes all the transitive informations needed to link a crate,\n-        // which is what we need here since we need to dig out `exported_symbols` from all transitive\n-        // dependencies.\n-        let dependency_formats = tcx.dependency_formats(());\n-        let dependency_format = dependency_formats\n-            .iter()\n-            .find(|(crate_type, _)| *crate_type == CrateType::Executable)\n-            .expect(\"interpreting a non-executable crate\");\n-        for cnum in\n-            iter::once(LOCAL_CRATE).chain(dependency_format.1.iter().enumerate().filter_map(\n-                |(num, &linkage)| (linkage != Linkage::NotLinked).then_some(CrateNum::new(num + 1)),\n-            ))\n-        {\n-            // We can ignore `_export_level` here: we are a Rust crate, and everything is exported\n-            // from a Rust crate.\n-            for &(symbol, _export_level) in tcx.exported_symbols(cnum) {\n-                if let ExportedSymbol::NonGeneric(def_id) = symbol {\n-                    let attrs = tcx.codegen_fn_attrs(def_id);\n-                    let symbol_name = if let Some(export_name) = attrs.export_name {\n-                        export_name\n-                    } else if attrs.flags.contains(CodegenFnAttrFlags::NO_MANGLE) {\n-                        tcx.item_name(def_id)\n-                    } else {\n-                        // Skip over items without an explicitly defined symbol name.\n-                        continue;\n-                    };\n-                    if symbol_name == link_name {\n-                        if let Some((original_instance, original_cnum)) = instance_and_crate {\n-                            // Make sure we are consistent wrt what is 'first' and 'second'.\n-                            let original_span = tcx.def_span(original_instance.def_id()).data();\n-                            let span = tcx.def_span(def_id).data();\n-                            if original_span < span {\n-                                throw_machine_stop!(TerminationInfo::MultipleSymbolDefinitions {\n-                                    link_name,\n-                                    first: original_span,\n-                                    first_crate: tcx.crate_name(original_cnum),\n-                                    second: span,\n-                                    second_crate: tcx.crate_name(cnum),\n-                                });\n+        // (Cannot use `or_insert` since the code below might have to throw an error.)\n+        let entry = this.machine.exported_symbols_cache.entry(link_name);\n+        let instance = *match entry {\n+            Entry::Occupied(e) => e.into_mut(),\n+            Entry::Vacant(e) => {\n+                // Find it if it was not cached.\n+                let mut instance_and_crate: Option<(ty::Instance<'_>, CrateNum)> = None;\n+                // `dependency_formats` includes all the transitive informations needed to link a crate,\n+                // which is what we need here since we need to dig out `exported_symbols` from all transitive\n+                // dependencies.\n+                let dependency_formats = tcx.dependency_formats(());\n+                let dependency_format = dependency_formats\n+                    .iter()\n+                    .find(|(crate_type, _)| *crate_type == CrateType::Executable)\n+                    .expect(\"interpreting a non-executable crate\");\n+                for cnum in iter::once(LOCAL_CRATE).chain(\n+                    dependency_format.1.iter().enumerate().filter_map(|(num, &linkage)| {\n+                        (linkage != Linkage::NotLinked).then_some(CrateNum::new(num + 1))\n+                    }),\n+                ) {\n+                    // We can ignore `_export_level` here: we are a Rust crate, and everything is exported\n+                    // from a Rust crate.\n+                    for &(symbol, _export_level) in tcx.exported_symbols(cnum) {\n+                        if let ExportedSymbol::NonGeneric(def_id) = symbol {\n+                            let attrs = tcx.codegen_fn_attrs(def_id);\n+                            let symbol_name = if let Some(export_name) = attrs.export_name {\n+                                export_name\n+                            } else if attrs.flags.contains(CodegenFnAttrFlags::NO_MANGLE) {\n+                                tcx.item_name(def_id)\n                             } else {\n-                                throw_machine_stop!(TerminationInfo::MultipleSymbolDefinitions {\n-                                    link_name,\n-                                    first: span,\n-                                    first_crate: tcx.crate_name(cnum),\n-                                    second: original_span,\n-                                    second_crate: tcx.crate_name(original_cnum),\n-                                });\n+                                // Skip over items without an explicitly defined symbol name.\n+                                continue;\n+                            };\n+                            if symbol_name == link_name {\n+                                if let Some((original_instance, original_cnum)) = instance_and_crate\n+                                {\n+                                    // Make sure we are consistent wrt what is 'first' and 'second'.\n+                                    let original_span =\n+                                        tcx.def_span(original_instance.def_id()).data();\n+                                    let span = tcx.def_span(def_id).data();\n+                                    if original_span < span {\n+                                        throw_machine_stop!(\n+                                            TerminationInfo::MultipleSymbolDefinitions {\n+                                                link_name,\n+                                                first: original_span,\n+                                                first_crate: tcx.crate_name(original_cnum),\n+                                                second: span,\n+                                                second_crate: tcx.crate_name(cnum),\n+                                            }\n+                                        );\n+                                    } else {\n+                                        throw_machine_stop!(\n+                                            TerminationInfo::MultipleSymbolDefinitions {\n+                                                link_name,\n+                                                first: span,\n+                                                first_crate: tcx.crate_name(cnum),\n+                                                second: original_span,\n+                                                second_crate: tcx.crate_name(original_cnum),\n+                                            }\n+                                        );\n+                                    }\n+                                }\n+                                if !matches!(tcx.def_kind(def_id), DefKind::Fn | DefKind::AssocFn) {\n+                                    throw_ub_format!(\n+                                        \"attempt to call an exported symbol that is not defined as a function\"\n+                                    );\n+                                }\n+                                instance_and_crate = Some((ty::Instance::mono(tcx, def_id), cnum));\n                             }\n                         }\n-                        if !matches!(tcx.def_kind(def_id), DefKind::Fn | DefKind::AssocFn) {\n-                            throw_ub_format!(\n-                                \"attempt to call an exported symbol that is not defined as a function\"\n-                            );\n-                        }\n-                        instance_and_crate = Some((ty::Instance::mono(tcx, def_id), cnum));\n                     }\n                 }\n+\n+                e.insert(instance_and_crate.map(|ic| ic.0))\n             }\n+        };\n+        match instance {\n+            None => Ok(None), // no symbol with this name\n+            Some(instance) => Ok(Some((this.load_mir(instance.def, None)?, instance))),\n         }\n-\n-        let instance = instance_and_crate.map(|ic| ic.0);\n-        // Cache it and load its MIR, if found.\n-        this.machine.exported_symbols_cache.try_insert(link_name, instance).unwrap();\n-        instance.map(|instance| this.load_mir(instance.def, None)).transpose()\n     }\n \n     /// Emulates calling a foreign item, failing if the item is not supported.\n@@ -225,7 +236,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         args: &[OpTy<'tcx, Tag>],\n         ret: Option<(&PlaceTy<'tcx, Tag>, mir::BasicBlock)>,\n         unwind: StackPopUnwind,\n-    ) -> InterpResult<'tcx, Option<&'mir mir::Body<'tcx>>> {\n+    ) -> InterpResult<'tcx, Option<(&'mir mir::Body<'tcx>, ty::Instance<'tcx>)>> {\n         let this = self.eval_context_mut();\n         let attrs = this.tcx.get_attrs(def_id);\n         let link_name = this\n@@ -253,7 +264,10 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                         this.check_abi_and_shim_symbol_clash(abi, Abi::Rust, link_name)?;\n                         let panic_impl_id = tcx.lang_items().panic_impl().unwrap();\n                         let panic_impl_instance = ty::Instance::mono(tcx, panic_impl_id);\n-                        return Ok(Some(&*this.load_mir(panic_impl_instance.def, None)?));\n+                        return Ok(Some((\n+                            &*this.load_mir(panic_impl_instance.def, None)?,\n+                            panic_impl_instance,\n+                        )));\n                     }\n                     #[rustfmt::skip]\n                     | \"exit\"\n@@ -297,7 +311,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 this.go_to_block(ret);\n             }\n             EmulateByNameResult::AlreadyJumped => (),\n-            EmulateByNameResult::MirBody(mir) => return Ok(Some(mir)),\n+            EmulateByNameResult::MirBody(mir, instance) => return Ok(Some((mir, instance))),\n             EmulateByNameResult::NotSupported => {\n                 if let Some(body) = this.lookup_exported_symbol(link_name)? {\n                     return Ok(Some(body));\n@@ -328,11 +342,11 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n         match allocator_kind {\n             AllocatorKind::Global => {\n-                let body = this\n+                let (body, instance) = this\n                     .lookup_exported_symbol(symbol)?\n                     .expect(\"symbol should be present if there is a global allocator\");\n \n-                Ok(EmulateByNameResult::MirBody(body))\n+                Ok(EmulateByNameResult::MirBody(body, instance))\n             }\n             AllocatorKind::Default => {\n                 default(this)?;"}, {"sha": "66f673d241d363c61887917f47ce03704639a7e5", "filename": "src/shims/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d307e6c1970d1edb63d6a08d332e0acdb72c5cc5/src%2Fshims%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d307e6c1970d1edb63d6a08d332e0acdb72c5cc5/src%2Fshims%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fmod.rs?ref=d307e6c1970d1edb63d6a08d332e0acdb72c5cc5", "patch": "@@ -30,7 +30,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         args: &[OpTy<'tcx, Tag>],\n         ret: Option<(&PlaceTy<'tcx, Tag>, mir::BasicBlock)>,\n         unwind: StackPopUnwind,\n-    ) -> InterpResult<'tcx, Option<&'mir mir::Body<'tcx>>> {\n+    ) -> InterpResult<'tcx, Option<(&'mir mir::Body<'tcx>, ty::Instance<'tcx>)>> {\n         let this = self.eval_context_mut();\n         trace!(\"eval_fn_call: {:#?}, {:?}\", instance, ret.map(|p| p.0));\n \n@@ -54,7 +54,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         }\n \n         // Otherwise, load the MIR.\n-        Ok(Some(&*this.load_mir(instance.def, None)?))\n+        Ok(Some((&*this.load_mir(instance.def, None)?, instance)))\n     }\n \n     /// Returns `true` if the computation was performed, and `false` if we should just evaluate"}, {"sha": "7dbda584e8d4c1cc6d9f427f67063497dbae4641", "filename": "tests/compile-fail/function_calls/exported_symbol_abi_mismatch.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d307e6c1970d1edb63d6a08d332e0acdb72c5cc5/tests%2Fcompile-fail%2Ffunction_calls%2Fexported_symbol_abi_mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d307e6c1970d1edb63d6a08d332e0acdb72c5cc5/tests%2Fcompile-fail%2Ffunction_calls%2Fexported_symbol_abi_mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Ffunction_calls%2Fexported_symbol_abi_mismatch.rs?ref=d307e6c1970d1edb63d6a08d332e0acdb72c5cc5", "patch": "@@ -11,7 +11,7 @@ fn main() {\n \n     #[cfg(fn_ptr)]\n     unsafe { std::mem::transmute::<unsafe fn(), unsafe extern \"C\" fn()>(foo)() }\n-    //[fn_ptr]~^ ERROR calling a function with ABI Rust using caller ABI C\n+    //[fn_ptr]~^ ERROR calling a function with calling convention Rust using calling convention C\n \n     // `Instance` caching should not suppress ABI check.\n     #[cfg(cache)]\n@@ -23,7 +23,7 @@ fn main() {\n             fn foo();\n         }\n         unsafe { foo() }\n-        //[no_cache]~^ ERROR calling a function with ABI Rust using caller ABI C\n-        //[cache]~^^ ERROR calling a function with ABI Rust using caller ABI C\n+        //[no_cache]~^ ERROR calling a function with calling convention Rust using calling convention C\n+        //[cache]~^^ ERROR calling a function with calling convention Rust using calling convention C\n     }\n }"}, {"sha": "1feee9a12ae04781a638189b295a35b3a3f48779", "filename": "tests/compile-fail/panic/bad_unwind.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d307e6c1970d1edb63d6a08d332e0acdb72c5cc5/tests%2Fcompile-fail%2Fpanic%2Fbad_unwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d307e6c1970d1edb63d6a08d332e0acdb72c5cc5/tests%2Fcompile-fail%2Fpanic%2Fbad_unwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fpanic%2Fbad_unwind.rs?ref=d307e6c1970d1edb63d6a08d332e0acdb72c5cc5", "patch": "@@ -1,9 +1,7 @@\n-// error-pattern: calling a function with ABI C-unwind using caller ABI C\n+// error-pattern: unwinding past a stack frame that does not allow unwinding\n #![feature(c_unwind)]\n \n //! Unwinding when the caller ABI is \"C\" (without \"-unwind\") is UB.\n-//! Currently we detect the ABI mismatch; we could probably allow such calls in principle one day\n-//! but then we have to detect the unexpected unwinding.\n \n extern \"C-unwind\" fn unwind() {\n     panic!();"}]}