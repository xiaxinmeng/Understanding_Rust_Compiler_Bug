{"sha": "26b45573be204da2cc0db12828b7a03c41c73793", "node_id": "C_kwDOAAsO6NoAKDI2YjQ1NTczYmUyMDRkYTJjYzBkYjEyODI4YjdhMDNjNDFjNzM3OTM", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-12-01T09:51:00Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-12-01T09:51:00Z"}, "message": "Auto merge of #91418 - matthiaskrgr:rollup-vn9f9w3, r=matthiaskrgr\n\nRollup of 7 pull requests\n\nSuccessful merges:\n\n - #87160 (When recovering from a `:` in a pattern, use adequate AST pattern)\n - #90985 (Use `get_diagnostic_name` more)\n - #91087 (Remove all migrate.nll.stderr files)\n - #91207 (Add support for LLVM coverage mapping format versions 5 and 6)\n - #91298 (Improve error message for `E0659` if the source is not available)\n - #91346 (Add `Option::inspect` and `Result::{inspect, inspect_err}`)\n - #91404 (Fix bad `NodeId` limit checking.)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "78397810624b52cc485ce911abfbc6ab50561579", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/78397810624b52cc485ce911abfbc6ab50561579"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/26b45573be204da2cc0db12828b7a03c41c73793", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/26b45573be204da2cc0db12828b7a03c41c73793", "html_url": "https://github.com/rust-lang/rust/commit/26b45573be204da2cc0db12828b7a03c41c73793", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/26b45573be204da2cc0db12828b7a03c41c73793/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2446a215954a99f9d33019fad7d415ef9c083502", "url": "https://api.github.com/repos/rust-lang/rust/commits/2446a215954a99f9d33019fad7d415ef9c083502", "html_url": "https://github.com/rust-lang/rust/commit/2446a215954a99f9d33019fad7d415ef9c083502"}, {"sha": "4f252f1a91e8c46508443ea92c6f221e6de5beb1", "url": "https://api.github.com/repos/rust-lang/rust/commits/4f252f1a91e8c46508443ea92c6f221e6de5beb1", "html_url": "https://github.com/rust-lang/rust/commit/4f252f1a91e8c46508443ea92c6f221e6de5beb1"}], "stats": {"total": 1075, "additions": 617, "deletions": 458}, "files": [{"sha": "42f5d557542088a10d3da5cb673a85f494cd66e7", "filename": "compiler/rustc_borrowck/src/diagnostics/mod.rs", "status": "modified", "additions": 15, "deletions": 20, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/26b45573be204da2cc0db12828b7a03c41c73793/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26b45573be204da2cc0db12828b7a03c41c73793/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs?ref=26b45573be204da2cc0db12828b7a03c41c73793", "patch": "@@ -738,15 +738,13 @@ impl BorrowedContentSource<'tcx> {\n             BorrowedContentSource::DerefRawPointer => \"a raw pointer\".to_string(),\n             BorrowedContentSource::DerefSharedRef => \"a shared reference\".to_string(),\n             BorrowedContentSource::DerefMutableRef => \"a mutable reference\".to_string(),\n-            BorrowedContentSource::OverloadedDeref(ty) => match ty.kind() {\n-                ty::Adt(def, _) if tcx.is_diagnostic_item(sym::Rc, def.did) => {\n-                    \"an `Rc`\".to_string()\n-                }\n-                ty::Adt(def, _) if tcx.is_diagnostic_item(sym::Arc, def.did) => {\n-                    \"an `Arc`\".to_string()\n-                }\n-                _ => format!(\"dereference of `{}`\", ty),\n-            },\n+            BorrowedContentSource::OverloadedDeref(ty) => ty\n+                .ty_adt_def()\n+                .and_then(|adt| match tcx.get_diagnostic_name(adt.did)? {\n+                    name @ (sym::Rc | sym::Arc) => Some(format!(\"an `{}`\", name)),\n+                    _ => None,\n+                })\n+                .unwrap_or_else(|| format!(\"dereference of `{}`\", ty)),\n             BorrowedContentSource::OverloadedIndex(ty) => format!(\"index of `{}`\", ty),\n         }\n     }\n@@ -770,15 +768,13 @@ impl BorrowedContentSource<'tcx> {\n             BorrowedContentSource::DerefMutableRef => {\n                 bug!(\"describe_for_immutable_place: DerefMutableRef isn't immutable\")\n             }\n-            BorrowedContentSource::OverloadedDeref(ty) => match ty.kind() {\n-                ty::Adt(def, _) if tcx.is_diagnostic_item(sym::Rc, def.did) => {\n-                    \"an `Rc`\".to_string()\n-                }\n-                ty::Adt(def, _) if tcx.is_diagnostic_item(sym::Arc, def.did) => {\n-                    \"an `Arc`\".to_string()\n-                }\n-                _ => format!(\"a dereference of `{}`\", ty),\n-            },\n+            BorrowedContentSource::OverloadedDeref(ty) => ty\n+                .ty_adt_def()\n+                .and_then(|adt| match tcx.get_diagnostic_name(adt.did)? {\n+                    name @ (sym::Rc | sym::Arc) => Some(format!(\"an `{}`\", name)),\n+                    _ => None,\n+                })\n+                .unwrap_or_else(|| format!(\"dereference of `{}`\", ty)),\n             BorrowedContentSource::OverloadedIndex(ty) => format!(\"an index of `{}`\", ty),\n         }\n     }\n@@ -960,8 +956,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                         _ => None,\n                     });\n                 let is_option_or_result = parent_self_ty.map_or(false, |def_id| {\n-                    tcx.is_diagnostic_item(sym::Option, def_id)\n-                        || tcx.is_diagnostic_item(sym::Result, def_id)\n+                    matches!(tcx.get_diagnostic_name(def_id), Some(sym::Option | sym::Result))\n                 });\n                 FnSelfUseKind::Normal { self_arg, implicit_into_iter, is_option_or_result }\n             });"}, {"sha": "0390caaec33e55ef40f8710c521cd56134837e88", "filename": "compiler/rustc_codegen_llvm/src/coverageinfo/mapgen.rs", "status": "modified", "additions": 32, "deletions": 11, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/26b45573be204da2cc0db12828b7a03c41c73793/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmapgen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26b45573be204da2cc0db12828b7a03c41c73793/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmapgen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmapgen.rs?ref=26b45573be204da2cc0db12828b7a03c41c73793", "patch": "@@ -9,6 +9,7 @@ use rustc_data_structures::fx::{FxHashMap, FxHashSet, FxIndexSet};\n use rustc_hir::def_id::{DefId, DefIdSet};\n use rustc_llvm::RustString;\n use rustc_middle::mir::coverage::CodeRegion;\n+use rustc_middle::ty::TyCtxt;\n use rustc_span::Symbol;\n \n use std::ffi::CString;\n@@ -17,10 +18,11 @@ use tracing::debug;\n \n /// Generates and exports the Coverage Map.\n ///\n-/// This Coverage Map complies with Coverage Mapping Format version 4 (zero-based encoded as 3),\n-/// as defined at [LLVM Code Coverage Mapping Format](https://github.com/rust-lang/llvm-project/blob/rustc/11.0-2020-10-12/llvm/docs/CoverageMappingFormat.rst#llvm-code-coverage-mapping-format)\n-/// and published in Rust's November 2020 fork of LLVM. This version is supported by the LLVM\n-/// coverage tools (`llvm-profdata` and `llvm-cov`) bundled with Rust's fork of LLVM.\n+/// Rust Coverage Map generation supports LLVM Coverage Mapping Format versions\n+/// 5 (LLVM 12, only) and 6 (zero-based encoded as 4 and 5, respectively), as defined at\n+/// [LLVM Code Coverage Mapping Format](https://github.com/rust-lang/llvm-project/blob/rustc/13.0-2021-09-30/llvm/docs/CoverageMappingFormat.rst#llvm-code-coverage-mapping-format).\n+/// These versions are supported by the LLVM coverage tools (`llvm-profdata` and `llvm-cov`)\n+/// bundled with Rust's fork of LLVM.\n ///\n /// Consequently, Rust's bundled version of Clang also generates Coverage Maps compliant with\n /// the same version. Clang's implementation of Coverage Map generation was referenced when\n@@ -30,11 +32,12 @@ use tracing::debug;\n pub fn finalize<'ll, 'tcx>(cx: &CodegenCx<'ll, 'tcx>) {\n     let tcx = cx.tcx;\n \n-    // Ensure LLVM supports Coverage Map Version 4 (encoded as a zero-based value: 3).\n-    // If not, the LLVM Version must be less than 11.\n+    // Ensure the installed version of LLVM supports at least Coverage Map\n+    // Version 5 (encoded as a zero-based value: 4), which was introduced with\n+    // LLVM 12.\n     let version = coverageinfo::mapping_version();\n-    if version != 3 {\n-        tcx.sess.fatal(\"rustc option `-Z instrument-coverage` requires LLVM 11 or higher.\");\n+    if version < 4 {\n+        tcx.sess.fatal(\"rustc option `-Z instrument-coverage` requires LLVM 12 or higher.\");\n     }\n \n     debug!(\"Generating coverage map for CodegenUnit: `{}`\", cx.codegen_unit.name());\n@@ -57,7 +60,7 @@ pub fn finalize<'ll, 'tcx>(cx: &CodegenCx<'ll, 'tcx>) {\n         return;\n     }\n \n-    let mut mapgen = CoverageMapGenerator::new();\n+    let mut mapgen = CoverageMapGenerator::new(tcx, version);\n \n     // Encode coverage mappings and generate function records\n     let mut function_data = Vec::new();\n@@ -112,8 +115,26 @@ struct CoverageMapGenerator {\n }\n \n impl CoverageMapGenerator {\n-    fn new() -> Self {\n-        Self { filenames: FxIndexSet::default() }\n+    fn new(tcx: TyCtxt<'_>, version: u32) -> Self {\n+        let mut filenames = FxIndexSet::default();\n+        if version >= 5 {\n+            // LLVM Coverage Mapping Format version 6 (zero-based encoded as 5)\n+            // requires setting the first filename to the compilation directory.\n+            // Since rustc generates coverage maps with relative paths, the\n+            // compilation directory can be combined with the the relative paths\n+            // to get absolute paths, if needed.\n+            let working_dir = tcx\n+                .sess\n+                .opts\n+                .working_dir\n+                .remapped_path_if_available()\n+                .to_string_lossy()\n+                .to_string();\n+            let c_filename =\n+                CString::new(working_dir).expect(\"null error converting filename to C string\");\n+            filenames.insert(c_filename);\n+        }\n+        Self { filenames }\n     }\n \n     /// Using the `expressions` and `counter_regions` collected for the current function, generate"}, {"sha": "2ef4c871825cbdc6f28881a01aac9abe43677033", "filename": "compiler/rustc_codegen_llvm/src/llvm/ffi.rs", "status": "modified", "additions": 40, "deletions": 2, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/26b45573be204da2cc0db12828b7a03c41c73793/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26b45573be204da2cc0db12828b7a03c41c73793/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs?ref=26b45573be204da2cc0db12828b7a03c41c73793", "patch": "@@ -685,7 +685,7 @@ pub type InlineAsmDiagHandlerTy = unsafe extern \"C\" fn(&SMDiagnostic, *const c_v\n pub mod coverageinfo {\n     use super::coverage_map;\n \n-    /// Aligns with [llvm::coverage::CounterMappingRegion::RegionKind](https://github.com/rust-lang/llvm-project/blob/rustc/11.0-2020-10-12/llvm/include/llvm/ProfileData/Coverage/CoverageMapping.h#L206-L222)\n+    /// Aligns with [llvm::coverage::CounterMappingRegion::RegionKind](https://github.com/rust-lang/llvm-project/blob/rustc/13.0-2021-09-30/llvm/include/llvm/ProfileData/Coverage/CoverageMapping.h#L209-L230)\n     #[derive(Copy, Clone, Debug)]\n     #[repr(C)]\n     pub enum RegionKind {\n@@ -704,11 +704,16 @@ pub mod coverageinfo {\n         /// A GapRegion is like a CodeRegion, but its count is only set as the\n         /// line execution count when its the only region in the line.\n         GapRegion = 3,\n+\n+        /// A BranchRegion represents leaf-level boolean expressions and is\n+        /// associated with two counters, each representing the number of times the\n+        /// expression evaluates to true or false.\n+        BranchRegion = 4,\n     }\n \n     /// This struct provides LLVM's representation of a \"CoverageMappingRegion\", encoded into the\n     /// coverage map, in accordance with the\n-    /// [LLVM Code Coverage Mapping Format](https://github.com/rust-lang/llvm-project/blob/rustc/11.0-2020-10-12/llvm/docs/CoverageMappingFormat.rst#llvm-code-coverage-mapping-format).\n+    /// [LLVM Code Coverage Mapping Format](https://github.com/rust-lang/llvm-project/blob/rustc/13.0-2021-09-30/llvm/docs/CoverageMappingFormat.rst#llvm-code-coverage-mapping-format).\n     /// The struct composes fields representing the `Counter` type and value(s) (injected counter\n     /// ID, or expression type and operands), the source file (an indirect index into a \"filenames\n     /// array\", encoded separately), and source location (start and end positions of the represented\n@@ -721,6 +726,10 @@ pub mod coverageinfo {\n         /// The counter type and type-dependent counter data, if any.\n         counter: coverage_map::Counter,\n \n+        /// If the `RegionKind` is a `BranchRegion`, this represents the counter\n+        /// for the false branch of the region.\n+        false_counter: coverage_map::Counter,\n+\n         /// An indirect reference to the source filename. In the LLVM Coverage Mapping Format, the\n         /// file_id is an index into a function-specific `virtual_file_mapping` array of indexes\n         /// that, in turn, are used to look up the filename for this region.\n@@ -758,6 +767,7 @@ pub mod coverageinfo {\n         ) -> Self {\n             Self {\n                 counter,\n+                false_counter: coverage_map::Counter::zero(),\n                 file_id,\n                 expanded_file_id: 0,\n                 start_line,\n@@ -768,6 +778,31 @@ pub mod coverageinfo {\n             }\n         }\n \n+        // This function might be used in the future; the LLVM API is still evolving, as is coverage\n+        // support.\n+        #[allow(dead_code)]\n+        crate fn branch_region(\n+            counter: coverage_map::Counter,\n+            false_counter: coverage_map::Counter,\n+            file_id: u32,\n+            start_line: u32,\n+            start_col: u32,\n+            end_line: u32,\n+            end_col: u32,\n+        ) -> Self {\n+            Self {\n+                counter,\n+                false_counter,\n+                file_id,\n+                expanded_file_id: 0,\n+                start_line,\n+                start_col,\n+                end_line,\n+                end_col,\n+                kind: RegionKind::BranchRegion,\n+            }\n+        }\n+\n         // This function might be used in the future; the LLVM API is still evolving, as is coverage\n         // support.\n         #[allow(dead_code)]\n@@ -781,6 +816,7 @@ pub mod coverageinfo {\n         ) -> Self {\n             Self {\n                 counter: coverage_map::Counter::zero(),\n+                false_counter: coverage_map::Counter::zero(),\n                 file_id,\n                 expanded_file_id,\n                 start_line,\n@@ -803,6 +839,7 @@ pub mod coverageinfo {\n         ) -> Self {\n             Self {\n                 counter: coverage_map::Counter::zero(),\n+                false_counter: coverage_map::Counter::zero(),\n                 file_id,\n                 expanded_file_id: 0,\n                 start_line,\n@@ -826,6 +863,7 @@ pub mod coverageinfo {\n         ) -> Self {\n             Self {\n                 counter,\n+                false_counter: coverage_map::Counter::zero(),\n                 file_id,\n                 expanded_file_id: 0,\n                 start_line,"}, {"sha": "e288760a02b186612249db0225f4ec2a42a57ee4", "filename": "compiler/rustc_codegen_ssa/src/coverageinfo/ffi.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/26b45573be204da2cc0db12828b7a03c41c73793/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcoverageinfo%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26b45573be204da2cc0db12828b7a03c41c73793/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcoverageinfo%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcoverageinfo%2Fffi.rs?ref=26b45573be204da2cc0db12828b7a03c41c73793", "patch": "@@ -1,6 +1,6 @@\n use rustc_middle::mir::coverage::{CounterValueReference, MappedExpressionIndex};\n \n-/// Aligns with [llvm::coverage::Counter::CounterKind](https://github.com/rust-lang/llvm-project/blob/rustc/11.0-2020-10-12/llvm/include/llvm/ProfileData/Coverage/CoverageMapping.h#L206-L222)\n+/// Aligns with [llvm::coverage::Counter::CounterKind](https://github.com/rust-lang/llvm-project/blob/rustc/13.0-2021-09-30/llvm/include/llvm/ProfileData/Coverage/CoverageMapping.h#L95)\n #[derive(Copy, Clone, Debug)]\n #[repr(C)]\n pub enum CounterKind {\n@@ -17,7 +17,7 @@ pub enum CounterKind {\n ///     `instrprof.increment()`)\n ///   * For `CounterKind::Expression`, `id` is the index into the coverage map's array of\n ///     counter expressions.\n-/// Aligns with [llvm::coverage::Counter](https://github.com/rust-lang/llvm-project/blob/rustc/11.0-2020-10-12/llvm/include/llvm/ProfileData/Coverage/CoverageMapping.h#L99-L100)\n+/// Aligns with [llvm::coverage::Counter](https://github.com/rust-lang/llvm-project/blob/rustc/13.0-2021-09-30/llvm/include/llvm/ProfileData/Coverage/CoverageMapping.h#L102-L103)\n /// Important: The Rust struct layout (order and types of fields) must match its C++ counterpart.\n #[derive(Copy, Clone, Debug)]\n #[repr(C)]\n@@ -59,15 +59,15 @@ impl Counter {\n     }\n }\n \n-/// Aligns with [llvm::coverage::CounterExpression::ExprKind](https://github.com/rust-lang/llvm-project/blob/rustc/11.0-2020-10-12/llvm/include/llvm/ProfileData/Coverage/CoverageMapping.h#L147)\n+/// Aligns with [llvm::coverage::CounterExpression::ExprKind](https://github.com/rust-lang/llvm-project/blob/rustc/13.0-2021-09-30/llvm/include/llvm/ProfileData/Coverage/CoverageMapping.h#L150)\n #[derive(Copy, Clone, Debug)]\n #[repr(C)]\n pub enum ExprKind {\n     Subtract = 0,\n     Add = 1,\n }\n \n-/// Aligns with [llvm::coverage::CounterExpression](https://github.com/rust-lang/llvm-project/blob/rustc/11.0-2020-10-12/llvm/include/llvm/ProfileData/Coverage/CoverageMapping.h#L148-L149)\n+/// Aligns with [llvm::coverage::CounterExpression](https://github.com/rust-lang/llvm-project/blob/rustc/13.0-2021-09-30/llvm/include/llvm/ProfileData/Coverage/CoverageMapping.h#L151-L152)\n /// Important: The Rust struct layout (order and types of fields) must match its C++\n /// counterpart.\n #[derive(Copy, Clone, Debug)]"}, {"sha": "65772d02376d43ae082a6e4b11933604c5649fb3", "filename": "compiler/rustc_lint/src/enum_intrinsics_non_enums.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/26b45573be204da2cc0db12828b7a03c41c73793/compiler%2Frustc_lint%2Fsrc%2Fenum_intrinsics_non_enums.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26b45573be204da2cc0db12828b7a03c41c73793/compiler%2Frustc_lint%2Fsrc%2Fenum_intrinsics_non_enums.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fenum_intrinsics_non_enums.rs?ref=26b45573be204da2cc0db12828b7a03c41c73793", "patch": "@@ -91,16 +91,14 @@ fn enforce_mem_variant_count(cx: &LateContext<'_>, func_expr: &hir::Expr<'_>, sp\n \n impl<'tcx> LateLintPass<'tcx> for EnumIntrinsicsNonEnums {\n     fn check_expr(&mut self, cx: &LateContext<'_>, expr: &hir::Expr<'_>) {\n-        if let hir::ExprKind::Call(ref func, ref args) = expr.kind {\n-            if let hir::ExprKind::Path(ref qpath) = func.kind {\n-                if let Some(def_id) = cx.qpath_res(qpath, func.hir_id).opt_def_id() {\n-                    if cx.tcx.is_diagnostic_item(sym::mem_discriminant, def_id) {\n-                        enforce_mem_discriminant(cx, func, expr.span, args[0].span);\n-                    } else if cx.tcx.is_diagnostic_item(sym::mem_variant_count, def_id) {\n-                        enforce_mem_variant_count(cx, func, expr.span);\n-                    }\n-                }\n-            }\n+        let hir::ExprKind::Call(func, args) = &expr.kind else { return };\n+        let hir::ExprKind::Path(qpath) = &func.kind else { return };\n+        let Some(def_id) = cx.qpath_res(qpath, func.hir_id).opt_def_id() else { return };\n+        let Some(name) = cx.tcx.get_diagnostic_name(def_id) else { return };\n+        match name {\n+            sym::mem_discriminant => enforce_mem_discriminant(cx, func, expr.span, args[0].span),\n+            sym::mem_variant_count => enforce_mem_variant_count(cx, func, expr.span),\n+            _ => {}\n         }\n     }\n }"}, {"sha": "7cc40cc60d9cdf7fab5cba1bf0922441a37ef2c6", "filename": "compiler/rustc_lint/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/26b45573be204da2cc0db12828b7a03c41c73793/compiler%2Frustc_lint%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26b45573be204da2cc0db12828b7a03c41c73793/compiler%2Frustc_lint%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flib.rs?ref=26b45573be204da2cc0db12828b7a03c41c73793", "patch": "@@ -33,6 +33,7 @@\n #![cfg_attr(bootstrap, feature(format_args_capture))]\n #![feature(iter_order_by)]\n #![feature(iter_zip)]\n+#![feature(let_else)]\n #![feature(never_type)]\n #![feature(nll)]\n #![feature(control_flow_enum)]"}, {"sha": "4a9b27e89b19927464ef8bdf71849252261c0e70", "filename": "compiler/rustc_lint/src/non_fmt_panic.rs", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/26b45573be204da2cc0db12828b7a03c41c73793/compiler%2Frustc_lint%2Fsrc%2Fnon_fmt_panic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26b45573be204da2cc0db12828b7a03c41c73793/compiler%2Frustc_lint%2Fsrc%2Fnon_fmt_panic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fnon_fmt_panic.rs?ref=26b45573be204da2cc0db12828b7a03c41c73793", "patch": "@@ -309,14 +309,21 @@ fn panic_call<'tcx>(cx: &LateContext<'tcx>, f: &'tcx hir::Expr<'tcx>) -> (Span,\n     // Unwrap more levels of macro expansion, as panic_2015!()\n     // was likely expanded from panic!() and possibly from\n     // [debug_]assert!().\n-    for &i in\n-        &[sym::std_panic_macro, sym::core_panic_macro, sym::assert_macro, sym::debug_assert_macro]\n-    {\n+    loop {\n         let parent = expn.call_site.ctxt().outer_expn_data();\n-        if parent.macro_def_id.map_or(false, |id| cx.tcx.is_diagnostic_item(i, id)) {\n-            expn = parent;\n-            panic_macro = i;\n+        let Some(id) = parent.macro_def_id else { break };\n+        let Some(name) = cx.tcx.get_diagnostic_name(id) else { break };\n+        if !matches!(\n+            name,\n+            sym::core_panic_macro\n+                | sym::std_panic_macro\n+                | sym::assert_macro\n+                | sym::debug_assert_macro\n+        ) {\n+            break;\n         }\n+        expn = parent;\n+        panic_macro = name;\n     }\n \n     let macro_symbol ="}, {"sha": "a3a3cd0077dbefd70c80018aaf5550d93ca9b8e6", "filename": "compiler/rustc_lint/src/noop_method_call.rs", "status": "modified", "additions": 30, "deletions": 32, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/26b45573be204da2cc0db12828b7a03c41c73793/compiler%2Frustc_lint%2Fsrc%2Fnoop_method_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26b45573be204da2cc0db12828b7a03c41c73793/compiler%2Frustc_lint%2Fsrc%2Fnoop_method_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fnoop_method_call.rs?ref=26b45573be204da2cc0db12828b7a03c41c73793", "patch": "@@ -75,38 +75,36 @@ impl<'tcx> LateLintPass<'tcx> for NoopMethodCall {\n             _ => return,\n         };\n         // (Re)check that it implements the noop diagnostic.\n-        for s in [sym::noop_method_clone, sym::noop_method_deref, sym::noop_method_borrow].iter() {\n-            if cx.tcx.is_diagnostic_item(*s, i.def_id()) {\n-                let method = &call.ident.name;\n-                let receiver = &elements[0];\n-                let receiver_ty = cx.typeck_results().expr_ty(receiver);\n-                let expr_ty = cx.typeck_results().expr_ty_adjusted(expr);\n-                if receiver_ty != expr_ty {\n-                    // This lint will only trigger if the receiver type and resulting expression \\\n-                    // type are the same, implying that the method call is unnecessary.\n-                    return;\n-                }\n-                let expr_span = expr.span;\n-                let note = format!(\n-                    \"the type `{:?}` which `{}` is being called on is the same as \\\n-                     the type returned from `{}`, so the method call does not do \\\n-                     anything and can be removed\",\n-                    receiver_ty, method, method,\n-                );\n-\n-                let span = expr_span.with_lo(receiver.span.hi());\n-                cx.struct_span_lint(NOOP_METHOD_CALL, span, |lint| {\n-                    let method = &call.ident.name;\n-                    let message = format!(\n-                        \"call to `.{}()` on a reference in this situation does nothing\",\n-                        &method,\n-                    );\n-                    lint.build(&message)\n-                        .span_label(span, \"unnecessary method call\")\n-                        .note(&note)\n-                        .emit()\n-                });\n-            }\n+        let Some(name) = cx.tcx.get_diagnostic_name(i.def_id()) else { return };\n+        if !matches!(\n+            name,\n+            sym::noop_method_borrow | sym::noop_method_clone | sym::noop_method_deref\n+        ) {\n+            return;\n         }\n+        let method = &call.ident.name;\n+        let receiver = &elements[0];\n+        let receiver_ty = cx.typeck_results().expr_ty(receiver);\n+        let expr_ty = cx.typeck_results().expr_ty_adjusted(expr);\n+        if receiver_ty != expr_ty {\n+            // This lint will only trigger if the receiver type and resulting expression \\\n+            // type are the same, implying that the method call is unnecessary.\n+            return;\n+        }\n+        let expr_span = expr.span;\n+        let note = format!(\n+            \"the type `{:?}` which `{}` is being called on is the same as \\\n+             the type returned from `{}`, so the method call does not do \\\n+             anything and can be removed\",\n+            receiver_ty, method, method,\n+        );\n+\n+        let span = expr_span.with_lo(receiver.span.hi());\n+        cx.struct_span_lint(NOOP_METHOD_CALL, span, |lint| {\n+            let method = &call.ident.name;\n+            let message =\n+                format!(\"call to `.{}()` on a reference in this situation does nothing\", &method,);\n+            lint.build(&message).span_label(span, \"unnecessary method call\").note(&note).emit()\n+        });\n     }\n }"}, {"sha": "154f554d607dfb60af9afaa03d54952f96d4a178", "filename": "compiler/rustc_llvm/llvm-wrapper/CoverageMappingWrapper.cpp", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/26b45573be204da2cc0db12828b7a03c41c73793/compiler%2Frustc_llvm%2Fllvm-wrapper%2FCoverageMappingWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/26b45573be204da2cc0db12828b7a03c41c73793/compiler%2Frustc_llvm%2Fllvm-wrapper%2FCoverageMappingWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_llvm%2Fllvm-wrapper%2FCoverageMappingWrapper.cpp?ref=26b45573be204da2cc0db12828b7a03c41c73793", "patch": "@@ -10,6 +10,7 @@ using namespace llvm;\n \n struct LLVMRustCounterMappingRegion {\n   coverage::Counter Count;\n+  coverage::Counter FalseCount;\n   uint32_t FileID;\n   uint32_t ExpandedFileID;\n   uint32_t LineStart;\n@@ -53,7 +54,7 @@ extern \"C\" void LLVMRustCoverageWriteMappingToBuffer(\n   MappingRegions.reserve(NumMappingRegions);\n   for (const auto &Region : makeArrayRef(RustMappingRegions, NumMappingRegions)) {\n     MappingRegions.emplace_back(\n-        Region.Count, Region.FileID, Region.ExpandedFileID,\n+        Region.Count, Region.FalseCount, Region.FileID, Region.ExpandedFileID,\n         Region.LineStart, Region.ColumnStart, Region.LineEnd, Region.ColumnEnd,\n         Region.Kind);\n   }\n@@ -108,5 +109,9 @@ extern \"C\" void LLVMRustCoverageWriteMappingVarNameToString(RustStringRef Str) {\n }\n \n extern \"C\" uint32_t LLVMRustCoverageMappingVersion() {\n-  return coverage::CovMapVersion::Version4;\n+#if LLVM_VERSION_GE(13, 0)\n+  return coverage::CovMapVersion::Version6;\n+#else\n+  return coverage::CovMapVersion::Version5;\n+#endif\n }"}, {"sha": "640d3a5a02b0f0ae7e1efc759a9f13a9997096a5", "filename": "compiler/rustc_middle/src/mir/coverage.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/26b45573be204da2cc0db12828b7a03c41c73793/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fcoverage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26b45573be204da2cc0db12828b7a03c41c73793/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fcoverage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fcoverage.rs?ref=26b45573be204da2cc0db12828b7a03c41c73793", "patch": "@@ -21,9 +21,9 @@ rustc_index::newtype_index! {\n impl ExpressionOperandId {\n     /// An expression operand for a \"zero counter\", as described in the following references:\n     ///\n-    /// * <https://github.com/rust-lang/llvm-project/blob/rustc/11.0-2020-10-12/llvm/docs/CoverageMappingFormat.rst#counter>\n-    /// * <https://github.com/rust-lang/llvm-project/blob/rustc/11.0-2020-10-12/llvm/docs/CoverageMappingFormat.rst#tag>\n-    /// * <https://github.com/rust-lang/llvm-project/blob/rustc/11.0-2020-10-12/llvm/docs/CoverageMappingFormat.rst#counter-expressions>\n+    /// * <https://github.com/rust-lang/llvm-project/blob/rustc/13.0-2021-09-30/llvm/docs/CoverageMappingFormat.rst#counter>\n+    /// * <https://github.com/rust-lang/llvm-project/blob/rustc/13.0-2021-09-30/llvm/docs/CoverageMappingFormat.rst#tag>\n+    /// * <https://github.com/rust-lang/llvm-project/blob/rustc/13.0-2021-09-30/llvm/docs/CoverageMappingFormat.rst#counter-expressions>\n     ///\n     /// This operand can be used to count two or more separate code regions with a single counter,\n     /// if they run sequentially with no branches, by injecting the `Counter` in a `BasicBlock` for"}, {"sha": "55af2c9ddd32f1cb9a5455e443a0e76b364d530a", "filename": "compiler/rustc_parse/src/parser/diagnostics.rs", "status": "modified", "additions": 180, "deletions": 2, "changes": 182, "blob_url": "https://github.com/rust-lang/rust/blob/26b45573be204da2cc0db12828b7a03c41c73793/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26b45573be204da2cc0db12828b7a03c41c73793/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs?ref=26b45573be204da2cc0db12828b7a03c41c73793", "patch": "@@ -1,6 +1,9 @@\n+use super::pat::Expected;\n use super::ty::AllowPlus;\n-use super::TokenType;\n-use super::{BlockMode, Parser, PathStyle, Restrictions, SemiColonMode, SeqSep, TokenExpectType};\n+use super::{\n+    BlockMode, Parser, PathStyle, RecoverColon, RecoverComma, Restrictions, SemiColonMode, SeqSep,\n+    TokenExpectType, TokenType,\n+};\n \n use rustc_ast as ast;\n use rustc_ast::ptr::P;\n@@ -19,6 +22,8 @@ use rustc_span::source_map::Spanned;\n use rustc_span::symbol::{kw, Ident};\n use rustc_span::{MultiSpan, Span, SpanSnippetError, DUMMY_SP};\n \n+use std::mem::take;\n+\n use tracing::{debug, trace};\n \n const TURBOFISH_SUGGESTION_STR: &str =\n@@ -2075,4 +2080,177 @@ impl<'a> Parser<'a> {\n         );\n         err\n     }\n+\n+    /// Some special error handling for the \"top-level\" patterns in a match arm,\n+    /// `for` loop, `let`, &c. (in contrast to subpatterns within such).\n+    crate fn maybe_recover_colon_colon_in_pat_typo(\n+        &mut self,\n+        mut first_pat: P<Pat>,\n+        ra: RecoverColon,\n+        expected: Expected,\n+    ) -> P<Pat> {\n+        if RecoverColon::Yes != ra || token::Colon != self.token.kind {\n+            return first_pat;\n+        }\n+        if !matches!(first_pat.kind, PatKind::Ident(_, _, None) | PatKind::Path(..))\n+            || !self.look_ahead(1, |token| token.is_ident() && !token.is_reserved_ident())\n+        {\n+            return first_pat;\n+        }\n+        // The pattern looks like it might be a path with a `::` -> `:` typo:\n+        // `match foo { bar:baz => {} }`\n+        let span = self.token.span;\n+        // We only emit \"unexpected `:`\" error here if we can successfully parse the\n+        // whole pattern correctly in that case.\n+        let snapshot = self.clone();\n+\n+        // Create error for \"unexpected `:`\".\n+        match self.expected_one_of_not_found(&[], &[]) {\n+            Err(mut err) => {\n+                self.bump(); // Skip the `:`.\n+                match self.parse_pat_no_top_alt(expected) {\n+                    Err(mut inner_err) => {\n+                        // Carry on as if we had not done anything, callers will emit a\n+                        // reasonable error.\n+                        inner_err.cancel();\n+                        err.cancel();\n+                        *self = snapshot;\n+                    }\n+                    Ok(mut pat) => {\n+                        // We've parsed the rest of the pattern.\n+                        let new_span = first_pat.span.to(pat.span);\n+                        let mut show_sugg = false;\n+                        // Try to construct a recovered pattern.\n+                        match &mut pat.kind {\n+                            PatKind::Struct(qself @ None, path, ..)\n+                            | PatKind::TupleStruct(qself @ None, path, _)\n+                            | PatKind::Path(qself @ None, path) => match &first_pat.kind {\n+                                PatKind::Ident(_, ident, _) => {\n+                                    path.segments.insert(0, PathSegment::from_ident(ident.clone()));\n+                                    path.span = new_span;\n+                                    show_sugg = true;\n+                                    first_pat = pat;\n+                                }\n+                                PatKind::Path(old_qself, old_path) => {\n+                                    path.segments = old_path\n+                                        .segments\n+                                        .iter()\n+                                        .cloned()\n+                                        .chain(take(&mut path.segments))\n+                                        .collect();\n+                                    path.span = new_span;\n+                                    *qself = old_qself.clone();\n+                                    first_pat = pat;\n+                                    show_sugg = true;\n+                                }\n+                                _ => {}\n+                            },\n+                            PatKind::Ident(BindingMode::ByValue(Mutability::Not), ident, None) => {\n+                                match &first_pat.kind {\n+                                    PatKind::Ident(_, old_ident, _) => {\n+                                        let path = PatKind::Path(\n+                                            None,\n+                                            Path {\n+                                                span: new_span,\n+                                                segments: vec![\n+                                                    PathSegment::from_ident(old_ident.clone()),\n+                                                    PathSegment::from_ident(ident.clone()),\n+                                                ],\n+                                                tokens: None,\n+                                            },\n+                                        );\n+                                        first_pat = self.mk_pat(new_span, path);\n+                                        show_sugg = true;\n+                                    }\n+                                    PatKind::Path(old_qself, old_path) => {\n+                                        let mut segments = old_path.segments.clone();\n+                                        segments.push(PathSegment::from_ident(ident.clone()));\n+                                        let path = PatKind::Path(\n+                                            old_qself.clone(),\n+                                            Path { span: new_span, segments, tokens: None },\n+                                        );\n+                                        first_pat = self.mk_pat(new_span, path);\n+                                        show_sugg = true;\n+                                    }\n+                                    _ => {}\n+                                }\n+                            }\n+                            _ => {}\n+                        }\n+                        if show_sugg {\n+                            err.span_suggestion(\n+                                span,\n+                                \"maybe write a path separator here\",\n+                                \"::\".to_string(),\n+                                Applicability::MaybeIncorrect,\n+                            );\n+                        } else {\n+                            first_pat = self.mk_pat(new_span, PatKind::Wild);\n+                        }\n+                        err.emit();\n+                    }\n+                }\n+            }\n+            _ => {\n+                // Carry on as if we had not done anything. This should be unreachable.\n+                *self = snapshot;\n+            }\n+        };\n+        first_pat\n+    }\n+\n+    /// Some special error handling for the \"top-level\" patterns in a match arm,\n+    /// `for` loop, `let`, &c. (in contrast to subpatterns within such).\n+    crate fn maybe_recover_unexpected_comma(\n+        &mut self,\n+        lo: Span,\n+        rc: RecoverComma,\n+    ) -> PResult<'a, ()> {\n+        if rc == RecoverComma::No || self.token != token::Comma {\n+            return Ok(());\n+        }\n+\n+        // An unexpected comma after a top-level pattern is a clue that the\n+        // user (perhaps more accustomed to some other language) forgot the\n+        // parentheses in what should have been a tuple pattern; return a\n+        // suggestion-enhanced error here rather than choking on the comma later.\n+        let comma_span = self.token.span;\n+        self.bump();\n+        if let Err(mut err) = self.skip_pat_list() {\n+            // We didn't expect this to work anyway; we just wanted to advance to the\n+            // end of the comma-sequence so we know the span to suggest parenthesizing.\n+            err.cancel();\n+        }\n+        let seq_span = lo.to(self.prev_token.span);\n+        let mut err = self.struct_span_err(comma_span, \"unexpected `,` in pattern\");\n+        if let Ok(seq_snippet) = self.span_to_snippet(seq_span) {\n+            const MSG: &str = \"try adding parentheses to match on a tuple...\";\n+\n+            err.span_suggestion(\n+                seq_span,\n+                MSG,\n+                format!(\"({})\", seq_snippet),\n+                Applicability::MachineApplicable,\n+            );\n+            err.span_suggestion(\n+                seq_span,\n+                \"...or a vertical bar to match on multiple alternatives\",\n+                seq_snippet.replace(\",\", \" |\"),\n+                Applicability::MachineApplicable,\n+            );\n+        }\n+        Err(err)\n+    }\n+\n+    /// Parse and throw away a parenthesized comma separated\n+    /// sequence of patterns until `)` is reached.\n+    fn skip_pat_list(&mut self) -> PResult<'a, ()> {\n+        while !self.check(&token::CloseDelim(token::Paren)) {\n+            self.parse_pat_no_top_alt(None)?;\n+            if !self.eat(&token::Comma) {\n+                return Ok(());\n+            }\n+        }\n+        Ok(())\n+    }\n }"}, {"sha": "ac3123c40e3d96d78190fccbb073386a8ffe31d4", "filename": "compiler/rustc_parse/src/parser/pat.rs", "status": "modified", "additions": 9, "deletions": 104, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/26b45573be204da2cc0db12828b7a03c41c73793/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26b45573be204da2cc0db12828b7a03c41c73793/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs?ref=26b45573be204da2cc0db12828b7a03c41c73793", "patch": "@@ -3,14 +3,16 @@ use crate::{maybe_recover_from_interpolated_ty_qpath, maybe_whole};\n use rustc_ast::mut_visit::{noop_visit_pat, MutVisitor};\n use rustc_ast::ptr::P;\n use rustc_ast::token;\n-use rustc_ast::{self as ast, AttrVec, Attribute, MacCall, Pat, PatField, PatKind, RangeEnd};\n-use rustc_ast::{BindingMode, Expr, ExprKind, Mutability, Path, QSelf, RangeSyntax};\n+use rustc_ast::{\n+    self as ast, AttrVec, Attribute, BindingMode, Expr, ExprKind, MacCall, Mutability, Pat,\n+    PatField, PatKind, Path, QSelf, RangeEnd, RangeSyntax,\n+};\n use rustc_ast_pretty::pprust;\n use rustc_errors::{struct_span_err, Applicability, DiagnosticBuilder, PResult};\n use rustc_span::source_map::{respan, Span, Spanned};\n use rustc_span::symbol::{kw, sym, Ident};\n \n-type Expected = Option<&'static str>;\n+pub(super) type Expected = Option<&'static str>;\n \n /// `Expected` for function and lambda parameter patterns.\n pub(super) const PARAM_EXPECTED: Expected = Some(\"parameter name\");\n@@ -98,55 +100,9 @@ impl<'a> Parser<'a> {\n             // If we parsed a leading `|` which should be gated,\n             // then we should really gate the leading `|`.\n             // This complicated procedure is done purely for diagnostics UX.\n-            let mut first_pat = first_pat;\n-\n-            if let (RecoverColon::Yes, token::Colon) = (ra, &self.token.kind) {\n-                if matches!(\n-                    first_pat.kind,\n-                    PatKind::Ident(BindingMode::ByValue(Mutability::Not), _, None)\n-                        | PatKind::Path(..)\n-                ) && self.look_ahead(1, |token| token.is_ident() && !token.is_reserved_ident())\n-                {\n-                    // The pattern looks like it might be a path with a `::` -> `:` typo:\n-                    // `match foo { bar:baz => {} }`\n-                    let span = self.token.span;\n-                    // We only emit \"unexpected `:`\" error here if we can successfully parse the\n-                    // whole pattern correctly in that case.\n-                    let snapshot = self.clone();\n-\n-                    // Create error for \"unexpected `:`\".\n-                    match self.expected_one_of_not_found(&[], &[]) {\n-                        Err(mut err) => {\n-                            self.bump(); // Skip the `:`.\n-                            match self.parse_pat_no_top_alt(expected) {\n-                                Err(mut inner_err) => {\n-                                    // Carry on as if we had not done anything, callers will emit a\n-                                    // reasonable error.\n-                                    inner_err.cancel();\n-                                    err.cancel();\n-                                    *self = snapshot;\n-                                }\n-                                Ok(pat) => {\n-                                    // We've parsed the rest of the pattern.\n-                                    err.span_suggestion(\n-                                        span,\n-                                        \"maybe write a path separator here\",\n-                                        \"::\".to_string(),\n-                                        Applicability::MachineApplicable,\n-                                    );\n-                                    err.emit();\n-                                    first_pat =\n-                                        self.mk_pat(first_pat.span.to(pat.span), PatKind::Wild);\n-                                }\n-                            }\n-                        }\n-                        _ => {\n-                            // Carry on as if we had not done anything. This should be unreachable.\n-                            *self = snapshot;\n-                        }\n-                    };\n-                }\n-            }\n+\n+            // Check if the user wrote `foo:bar` instead of `foo::bar`.\n+            let first_pat = self.maybe_recover_colon_colon_in_pat_typo(first_pat, ra, expected);\n \n             if let Some(leading_vert_span) = leading_vert_span {\n                 // If there was a leading vert, treat this as an or-pattern. This improves\n@@ -321,57 +277,6 @@ impl<'a> Parser<'a> {\n         err.emit();\n     }\n \n-    /// Some special error handling for the \"top-level\" patterns in a match arm,\n-    /// `for` loop, `let`, &c. (in contrast to subpatterns within such).\n-    fn maybe_recover_unexpected_comma(&mut self, lo: Span, rc: RecoverComma) -> PResult<'a, ()> {\n-        if rc == RecoverComma::No || self.token != token::Comma {\n-            return Ok(());\n-        }\n-\n-        // An unexpected comma after a top-level pattern is a clue that the\n-        // user (perhaps more accustomed to some other language) forgot the\n-        // parentheses in what should have been a tuple pattern; return a\n-        // suggestion-enhanced error here rather than choking on the comma later.\n-        let comma_span = self.token.span;\n-        self.bump();\n-        if let Err(mut err) = self.skip_pat_list() {\n-            // We didn't expect this to work anyway; we just wanted to advance to the\n-            // end of the comma-sequence so we know the span to suggest parenthesizing.\n-            err.cancel();\n-        }\n-        let seq_span = lo.to(self.prev_token.span);\n-        let mut err = self.struct_span_err(comma_span, \"unexpected `,` in pattern\");\n-        if let Ok(seq_snippet) = self.span_to_snippet(seq_span) {\n-            const MSG: &str = \"try adding parentheses to match on a tuple...\";\n-\n-            err.span_suggestion(\n-                seq_span,\n-                MSG,\n-                format!(\"({})\", seq_snippet),\n-                Applicability::MachineApplicable,\n-            );\n-            err.span_suggestion(\n-                seq_span,\n-                \"...or a vertical bar to match on multiple alternatives\",\n-                seq_snippet.replace(\",\", \" |\"),\n-                Applicability::MachineApplicable,\n-            );\n-        }\n-        Err(err)\n-    }\n-\n-    /// Parse and throw away a parenthesized comma separated\n-    /// sequence of patterns until `)` is reached.\n-    fn skip_pat_list(&mut self) -> PResult<'a, ()> {\n-        while !self.check(&token::CloseDelim(token::Paren)) {\n-            self.parse_pat_no_top_alt(None)?;\n-            if !self.eat(&token::Comma) {\n-                return Ok(());\n-            }\n-        }\n-        Ok(())\n-    }\n-\n     /// A `|` or possibly `||` token shouldn't be here. Ban it.\n     fn ban_illegal_vert(&mut self, lo: Option<Span>, pos: &str, ctx: &str) {\n         let span = self.token.span;\n@@ -1168,7 +1073,7 @@ impl<'a> Parser<'a> {\n         self.mk_pat(span, PatKind::Ident(bm, ident, None))\n     }\n \n-    fn mk_pat(&self, span: Span, kind: PatKind) -> P<Pat> {\n+    pub(super) fn mk_pat(&self, span: Span, kind: PatKind) -> P<Pat> {\n         P(Pat { kind, span, id: ast::DUMMY_NODE_ID, tokens: None })\n     }\n }"}, {"sha": "6a13627a56314f11cb9359ca9348ed8bafeae7a6", "filename": "compiler/rustc_resolve/src/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/26b45573be204da2cc0db12828b7a03c41c73793/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26b45573be204da2cc0db12828b7a03c41c73793/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs?ref=26b45573be204da2cc0db12828b7a03c41c73793", "patch": "@@ -1178,7 +1178,7 @@ impl<'a> Resolver<'a> {\n \n     fn binding_description(&self, b: &NameBinding<'_>, ident: Ident, from_prelude: bool) -> String {\n         let res = b.res();\n-        if b.span.is_dummy() {\n+        if b.span.is_dummy() || self.session.source_map().span_to_snippet(b.span).is_err() {\n             // These already contain the \"built-in\" prefix or look bad with it.\n             let add_built_in =\n                 !matches!(b.res(), Res::NonMacroAttr(..) | Res::PrimTy(..) | Res::ToolMod);"}, {"sha": "a8ae4736c040295a39c84686ffd3ddbef4afd832", "filename": "compiler/rustc_resolve/src/lib.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/26b45573be204da2cc0db12828b7a03c41c73793/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26b45573be204da2cc0db12828b7a03c41c73793/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flib.rs?ref=26b45573be204da2cc0db12828b7a03c41c73793", "patch": "@@ -1430,12 +1430,9 @@ impl<'a> Resolver<'a> {\n     }\n \n     pub fn next_node_id(&mut self) -> NodeId {\n-        let next = self\n-            .next_node_id\n-            .as_usize()\n-            .checked_add(1)\n-            .expect(\"input too large; ran out of NodeIds\");\n-        self.next_node_id = ast::NodeId::from_usize(next);\n+        let next =\n+            self.next_node_id.as_u32().checked_add(1).expect(\"input too large; ran out of NodeIds\");\n+        self.next_node_id = ast::NodeId::from_u32(next);\n         self.next_node_id\n     }\n "}, {"sha": "72339da571df4d7eb1b2ca56d28a7c9ad3799170", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/26b45573be204da2cc0db12828b7a03c41c73793/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26b45573be204da2cc0db12828b7a03c41c73793/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=26b45573be204da2cc0db12828b7a03c41c73793", "patch": "@@ -539,11 +539,6 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                         // is otherwise overwhelming and unhelpful (see #85844 for an\n                         // example).\n \n-                        let trait_is_debug =\n-                            self.tcx.is_diagnostic_item(sym::Debug, trait_ref.def_id());\n-                        let trait_is_display =\n-                            self.tcx.is_diagnostic_item(sym::Display, trait_ref.def_id());\n-\n                         let in_std_macro =\n                             match obligation.cause.span.ctxt().outer_expn_data().macro_def_id {\n                                 Some(macro_def_id) => {\n@@ -553,7 +548,12 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                                 None => false,\n                             };\n \n-                        if in_std_macro && (trait_is_debug || trait_is_display) {\n+                        if in_std_macro\n+                            && matches!(\n+                                self.tcx.get_diagnostic_name(trait_ref.def_id()),\n+                                Some(sym::Debug | sym::Display)\n+                            )\n+                        {\n                             err.emit();\n                             return;\n                         }"}, {"sha": "4eeb5e43943862dd7d7f9a57d5d3dc49a3db51c6", "filename": "library/core/src/option.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/26b45573be204da2cc0db12828b7a03c41c73793/library%2Fcore%2Fsrc%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26b45573be204da2cc0db12828b7a03c41c73793/library%2Fcore%2Fsrc%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Foption.rs?ref=26b45573be204da2cc0db12828b7a03c41c73793", "patch": "@@ -848,6 +848,31 @@ impl<T> Option<T> {\n         }\n     }\n \n+    /// Calls the provided closure with a reference to the contained value (if [`Some`]).\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(result_option_inspect)]\n+    ///\n+    /// let v = vec![1, 2, 3, 4, 5];\n+    ///\n+    /// // prints \"got: 4\"\n+    /// let x: Option<&usize> = v.get(3).inspect(|x| println!(\"got: {}\", x));\n+    ///\n+    /// // prints nothing\n+    /// let x: Option<&usize> = v.get(5).inspect(|x| println!(\"got: {}\", x));\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"result_option_inspect\", issue = \"91345\")]\n+    pub fn inspect<F: FnOnce(&T)>(self, f: F) -> Self {\n+        if let Some(ref x) = self {\n+            f(x);\n+        }\n+\n+        self\n+    }\n+\n     /// Returns the provided default result (if none),\n     /// or applies a function to the contained value (if any).\n     ///"}, {"sha": "a494c089f68ba760b8796a5c926fab7df5f3e01c", "filename": "library/core/src/result.rs", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/26b45573be204da2cc0db12828b7a03c41c73793/library%2Fcore%2Fsrc%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26b45573be204da2cc0db12828b7a03c41c73793/library%2Fcore%2Fsrc%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fresult.rs?ref=26b45573be204da2cc0db12828b7a03c41c73793", "patch": "@@ -854,6 +854,53 @@ impl<T, E> Result<T, E> {\n         }\n     }\n \n+    /// Calls the provided closure with a reference to the contained value (if [`Ok`]).\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(result_option_inspect)]\n+    ///\n+    /// let x: u8 = \"4\"\n+    ///     .parse::<u8>()\n+    ///     .inspect(|x| println!(\"original: {}\", x))\n+    ///     .map(|x| x.pow(3))\n+    ///     .expect(\"failed to parse number\");\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"result_option_inspect\", issue = \"91345\")]\n+    pub fn inspect<F: FnOnce(&T)>(self, f: F) -> Self {\n+        if let Ok(ref t) = self {\n+            f(t);\n+        }\n+\n+        self\n+    }\n+\n+    /// Calls the provided closure with a reference to the contained error (if [`Err`]).\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(result_option_inspect)]\n+    ///\n+    /// use std::{fs, io};\n+    ///\n+    /// fn read() -> io::Result<String> {\n+    ///     fs::read_to_string(\"address.txt\")\n+    ///         .inspect_err(|e| eprintln!(\"failed to read file: {}\", e))\n+    /// }\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"result_option_inspect\", issue = \"91345\")]\n+    pub fn inspect_err<F: FnOnce(&E)>(self, f: F) -> Self {\n+        if let Err(ref e) = self {\n+            f(e);\n+        }\n+\n+        self\n+    }\n+\n     /////////////////////////////////////////////////////////////////////////\n     // Iterator constructors\n     /////////////////////////////////////////////////////////////////////////"}, {"sha": "f4d1ca0ec691130ffe2bcd74006655ae213d1012", "filename": "src/doc/unstable-book/src/compiler-flags/instrument-coverage.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/26b45573be204da2cc0db12828b7a03c41c73793/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Finstrument-coverage.md", "raw_url": "https://github.com/rust-lang/rust/raw/26b45573be204da2cc0db12828b7a03c41c73793/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Finstrument-coverage.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Finstrument-coverage.md?ref=26b45573be204da2cc0db12828b7a03c41c73793", "patch": "@@ -20,7 +20,7 @@ This document describes how to enable and use the LLVM instrumentation-based cov\n When `-Z instrument-coverage` is enabled, the Rust compiler enhances rust-based libraries and binaries by:\n \n -   Automatically injecting calls to an LLVM intrinsic ([`llvm.instrprof.increment`]), at functions and branches in compiled code, to increment counters when conditional sections of code are executed.\n--   Embedding additional information in the data section of each library and binary (using the [LLVM Code Coverage Mapping Format] _Version 4_, supported _only_ in LLVM 11 and up), to define the code regions (start and end positions in the source code) being counted.\n+-   Embedding additional information in the data section of each library and binary (using the [LLVM Code Coverage Mapping Format] _Version 5_, if compiling with LLVM 12, or _Version 6_, if compiling with LLVM 13 or higher), to define the code regions (start and end positions in the source code) being counted.\n \n When running a coverage-instrumented program, the counter values are written to a `profraw` file at program termination. LLVM bundles tools that read the counter results, combine those results with the coverage map (embedded in the program binary), and generate coverage reports in multiple formats.\n \n@@ -123,7 +123,7 @@ If `LLVM_PROFILE_FILE` contains a path to a non-existent directory, the missing\n \n ## Installing LLVM coverage tools\n \n-LLVM's supplies two tools\u2014`llvm-profdata` and `llvm-cov`\u2014that process coverage data and generate reports. There are several ways to find and/or install these tools, but note that the coverage mapping data generated by the Rust compiler requires LLVM version 11 or higher. (`llvm-cov --version` typically shows the tool's LLVM version number.):\n+LLVM's supplies two tools\u2014`llvm-profdata` and `llvm-cov`\u2014that process coverage data and generate reports. There are several ways to find and/or install these tools, but note that the coverage mapping data generated by the Rust compiler requires LLVM version 12 or higher. (`llvm-cov --version` typically shows the tool's LLVM version number.):\n \n -   The LLVM tools may be installed (or installable) directly to your OS (such as via `apt-get`, for Linux).\n -   If you are building the Rust compiler from source, you can optionally use the bundled LLVM tools, built from source. Those tool binaries can typically be found in your build platform directory at something like: `rust/build/x86_64-unknown-linux-gnu/llvm/bin/llvm-*`."}, {"sha": "3c4df3533e147f512a481954d373fdd95e20214a", "filename": "src/test/run-make-fulldeps/coverage-llvmir/Makefile", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/26b45573be204da2cc0db12828b7a03c41c73793/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-llvmir%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/26b45573be204da2cc0db12828b7a03c41c73793/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-llvmir%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-llvmir%2FMakefile?ref=26b45573be204da2cc0db12828b7a03c41c73793", "patch": "@@ -1,5 +1,11 @@\n # needs-profiler-support\n \n+# Rust coverage maps support LLVM Coverage Mapping Format versions 5 and 6,\n+# corresponding with LLVM versions 12 and 13, respectively.\n+# When upgrading LLVM versions, consider whether to enforce a minimum LLVM\n+# version during testing, with an additional directive at the top of this file\n+# that sets, for example: `min-llvm-version: 12.0`\n+\n -include ../coverage/coverage_tools.mk\n \n BASEDIR=../coverage-llvmir"}, {"sha": "9122e0406c2efc49ce6d7131de87b01d3b5264b5", "filename": "src/test/run-make-fulldeps/coverage-reports/Makefile", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/26b45573be204da2cc0db12828b7a03c41c73793/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/26b45573be204da2cc0db12828b7a03c41c73793/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2FMakefile?ref=26b45573be204da2cc0db12828b7a03c41c73793", "patch": "@@ -1,6 +1,12 @@\n # needs-profiler-support\n # ignore-windows-gnu\n \n+# Rust coverage maps support LLVM Coverage Mapping Format versions 5 and 6,\n+# corresponding with LLVM versions 12 and 13, respectively.\n+# When upgrading LLVM versions, consider whether to enforce a minimum LLVM\n+# version during testing, with an additional directive at the top of this file\n+# that sets, for example: `min-llvm-version: 12.0`\n+\n # FIXME(mati865): MinGW GCC miscompiles compiler-rt profiling library but with Clang it works\n # properly. Since we only have GCC on the CI ignore the test for now.\n \n@@ -115,6 +121,7 @@ endif\n \t\"$(LLVM_BIN_DIR)\"/llvm-cov show \\\n \t\t\t$(DEBUG_FLAG) \\\n \t\t\t$(LLVM_COV_IGNORE_FILES) \\\n+\t\t\t--compilation-dir=. \\\n \t\t\t--Xdemangler=\"$(RUST_DEMANGLER)\" \\\n \t\t\t--show-line-counts-or-regions \\\n \t\t\t--instr-profile=\"$(TMPDIR)\"/$@.profdata \\"}, {"sha": "10400cff5e51c33396addda8af0a1930e6963b34", "filename": "src/test/ui/borrowck/issue-55492-borrowck-migrate-scans-parents.migrate.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/26b45573be204da2cc0db12828b7a03c41c73793/src%2Ftest%2Fui%2Fborrowck%2Fissue-55492-borrowck-migrate-scans-parents.migrate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/26b45573be204da2cc0db12828b7a03c41c73793/src%2Ftest%2Fui%2Fborrowck%2Fissue-55492-borrowck-migrate-scans-parents.migrate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fissue-55492-borrowck-migrate-scans-parents.migrate.stderr?ref=26b45573be204da2cc0db12828b7a03c41c73793", "patch": "@@ -1,5 +1,5 @@\n error[E0594]: cannot assign to `x`, as it is not declared as mutable\n-  --> $DIR/issue-55492-borrowck-migrate-scans-parents.rs:19:46\n+  --> $DIR/issue-55492-borrowck-migrate-scans-parents.rs:17:46\n    |\n LL |     pub fn e(x: &'static mut isize) {\n    |              - help: consider changing this to be mutable: `mut x`\n@@ -8,7 +8,7 @@ LL |         let mut c1 = |y: &'static mut isize| x = y;\n    |                                              ^^^^^ cannot assign\n \n error[E0594]: cannot assign to `x`, as it is not declared as mutable\n-  --> $DIR/issue-55492-borrowck-migrate-scans-parents.rs:30:50\n+  --> $DIR/issue-55492-borrowck-migrate-scans-parents.rs:28:50\n    |\n LL |     pub fn ee(x: &'static mut isize) {\n    |               - help: consider changing this to be mutable: `mut x`\n@@ -17,31 +17,31 @@ LL |             let mut c2 = |y: &'static mut isize| x = y;\n    |                                                  ^^^^^ cannot assign\n \n error[E0594]: cannot assign to `x`, as it is not declared as mutable\n-  --> $DIR/issue-55492-borrowck-migrate-scans-parents.rs:42:14\n+  --> $DIR/issue-55492-borrowck-migrate-scans-parents.rs:40:14\n    |\n LL |     pub fn capture_assign_whole(x: (i32,)) {\n    |                                 - help: consider changing this to be mutable: `mut x`\n LL |         || { x = (1,); };\n    |              ^^^^^^^^ cannot assign\n \n error[E0594]: cannot assign to `x.0`, as `x` is not declared as mutable\n-  --> $DIR/issue-55492-borrowck-migrate-scans-parents.rs:47:14\n+  --> $DIR/issue-55492-borrowck-migrate-scans-parents.rs:45:14\n    |\n LL |     pub fn capture_assign_part(x: (i32,)) {\n    |                                - help: consider changing this to be mutable: `mut x`\n LL |         || { x.0 = 1; };\n    |              ^^^^^^^ cannot assign\n \n error[E0596]: cannot borrow `x` as mutable, as it is not declared as mutable\n-  --> $DIR/issue-55492-borrowck-migrate-scans-parents.rs:52:14\n+  --> $DIR/issue-55492-borrowck-migrate-scans-parents.rs:50:14\n    |\n LL |     pub fn capture_reborrow_whole(x: (i32,)) {\n    |                                   - help: consider changing this to be mutable: `mut x`\n LL |         || { &mut x; };\n    |              ^^^^^^ cannot borrow as mutable\n \n error[E0596]: cannot borrow `x.0` as mutable, as `x` is not declared as mutable\n-  --> $DIR/issue-55492-borrowck-migrate-scans-parents.rs:57:14\n+  --> $DIR/issue-55492-borrowck-migrate-scans-parents.rs:55:14\n    |\n LL |     pub fn capture_reborrow_part(x: (i32,)) {\n    |                                  - help: consider changing this to be mutable: `mut x`"}, {"sha": "10400cff5e51c33396addda8af0a1930e6963b34", "filename": "src/test/ui/borrowck/issue-55492-borrowck-migrate-scans-parents.nll.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/26b45573be204da2cc0db12828b7a03c41c73793/src%2Ftest%2Fui%2Fborrowck%2Fissue-55492-borrowck-migrate-scans-parents.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/26b45573be204da2cc0db12828b7a03c41c73793/src%2Ftest%2Fui%2Fborrowck%2Fissue-55492-borrowck-migrate-scans-parents.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fissue-55492-borrowck-migrate-scans-parents.nll.stderr?ref=26b45573be204da2cc0db12828b7a03c41c73793", "patch": "@@ -1,5 +1,5 @@\n error[E0594]: cannot assign to `x`, as it is not declared as mutable\n-  --> $DIR/issue-55492-borrowck-migrate-scans-parents.rs:19:46\n+  --> $DIR/issue-55492-borrowck-migrate-scans-parents.rs:17:46\n    |\n LL |     pub fn e(x: &'static mut isize) {\n    |              - help: consider changing this to be mutable: `mut x`\n@@ -8,7 +8,7 @@ LL |         let mut c1 = |y: &'static mut isize| x = y;\n    |                                              ^^^^^ cannot assign\n \n error[E0594]: cannot assign to `x`, as it is not declared as mutable\n-  --> $DIR/issue-55492-borrowck-migrate-scans-parents.rs:30:50\n+  --> $DIR/issue-55492-borrowck-migrate-scans-parents.rs:28:50\n    |\n LL |     pub fn ee(x: &'static mut isize) {\n    |               - help: consider changing this to be mutable: `mut x`\n@@ -17,31 +17,31 @@ LL |             let mut c2 = |y: &'static mut isize| x = y;\n    |                                                  ^^^^^ cannot assign\n \n error[E0594]: cannot assign to `x`, as it is not declared as mutable\n-  --> $DIR/issue-55492-borrowck-migrate-scans-parents.rs:42:14\n+  --> $DIR/issue-55492-borrowck-migrate-scans-parents.rs:40:14\n    |\n LL |     pub fn capture_assign_whole(x: (i32,)) {\n    |                                 - help: consider changing this to be mutable: `mut x`\n LL |         || { x = (1,); };\n    |              ^^^^^^^^ cannot assign\n \n error[E0594]: cannot assign to `x.0`, as `x` is not declared as mutable\n-  --> $DIR/issue-55492-borrowck-migrate-scans-parents.rs:47:14\n+  --> $DIR/issue-55492-borrowck-migrate-scans-parents.rs:45:14\n    |\n LL |     pub fn capture_assign_part(x: (i32,)) {\n    |                                - help: consider changing this to be mutable: `mut x`\n LL |         || { x.0 = 1; };\n    |              ^^^^^^^ cannot assign\n \n error[E0596]: cannot borrow `x` as mutable, as it is not declared as mutable\n-  --> $DIR/issue-55492-borrowck-migrate-scans-parents.rs:52:14\n+  --> $DIR/issue-55492-borrowck-migrate-scans-parents.rs:50:14\n    |\n LL |     pub fn capture_reborrow_whole(x: (i32,)) {\n    |                                   - help: consider changing this to be mutable: `mut x`\n LL |         || { &mut x; };\n    |              ^^^^^^ cannot borrow as mutable\n \n error[E0596]: cannot borrow `x.0` as mutable, as `x` is not declared as mutable\n-  --> $DIR/issue-55492-borrowck-migrate-scans-parents.rs:57:14\n+  --> $DIR/issue-55492-borrowck-migrate-scans-parents.rs:55:14\n    |\n LL |     pub fn capture_reborrow_part(x: (i32,)) {\n    |                                  - help: consider changing this to be mutable: `mut x`"}, {"sha": "fe7ed8ed3fa248cf2769f5c2e248430a6964daf7", "filename": "src/test/ui/borrowck/issue-55492-borrowck-migrate-scans-parents.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/26b45573be204da2cc0db12828b7a03c41c73793/src%2Ftest%2Fui%2Fborrowck%2Fissue-55492-borrowck-migrate-scans-parents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26b45573be204da2cc0db12828b7a03c41c73793/src%2Ftest%2Fui%2Fborrowck%2Fissue-55492-borrowck-migrate-scans-parents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fissue-55492-borrowck-migrate-scans-parents.rs?ref=26b45573be204da2cc0db12828b7a03c41c73793", "patch": "@@ -3,15 +3,13 @@\n // looks at some parent.\n \n // revisions: migrate nll\n+//[nll]compile-flags: -Z borrowck=mir\n \n // Since we are testing nll (and migration) explicitly as a separate\n // revisions, don't worry about the --compare-mode=nll on this test.\n \n // ignore-compare-mode-nll\n \n-//[nll]compile-flags: -Z borrowck=mir\n-\n-\n // transcribed from borrowck-closures-unique.rs\n mod borrowck_closures_unique {\n     pub fn e(x: &'static mut isize) {"}, {"sha": "efd4e1a1716d333c119ff685bcad42f19e520bd6", "filename": "src/test/ui/borrowck/issue-58776-borrowck-scans-children.migrate.stderr", "status": "removed", "additions": 0, "deletions": 32, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/2446a215954a99f9d33019fad7d415ef9c083502/src%2Ftest%2Fui%2Fborrowck%2Fissue-58776-borrowck-scans-children.migrate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2446a215954a99f9d33019fad7d415ef9c083502/src%2Ftest%2Fui%2Fborrowck%2Fissue-58776-borrowck-scans-children.migrate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fissue-58776-borrowck-scans-children.migrate.stderr?ref=2446a215954a99f9d33019fad7d415ef9c083502", "patch": "@@ -1,32 +0,0 @@\n-error[E0506]: cannot assign to `greeting` because it is borrowed\n-  --> $DIR/issue-58776-borrowck-scans-children.rs:11:5\n-   |\n-LL |     let res = (|| (|| &greeting)())();\n-   |                --      -------- borrow occurs due to use in closure\n-   |                |\n-   |                borrow of `greeting` occurs here\n-LL | \n-LL |     greeting = \"DEALLOCATED\".to_string();\n-   |     ^^^^^^^^ assignment to borrowed `greeting` occurs here\n-...\n-LL |     println!(\"thread result: {:?}\", res);\n-   |                                     --- borrow later used here\n-\n-error[E0505]: cannot move out of `greeting` because it is borrowed\n-  --> $DIR/issue-58776-borrowck-scans-children.rs:14:10\n-   |\n-LL |     let res = (|| (|| &greeting)())();\n-   |                --      -------- borrow occurs due to use in closure\n-   |                |\n-   |                borrow of `greeting` occurs here\n-...\n-LL |     drop(greeting);\n-   |          ^^^^^^^^ move out of `greeting` occurs here\n-...\n-LL |     println!(\"thread result: {:?}\", res);\n-   |                                     --- borrow later used here\n-\n-error: aborting due to 2 previous errors\n-\n-Some errors have detailed explanations: E0505, E0506.\n-For more information about an error, try `rustc --explain E0505`."}, {"sha": "fb082bc1eabcf51bcd907f1e6d7e802fa2a4188f", "filename": "src/test/ui/error-codes/E0161.edition.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/26b45573be204da2cc0db12828b7a03c41c73793/src%2Ftest%2Fui%2Ferror-codes%2FE0161.edition.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/26b45573be204da2cc0db12828b7a03c41c73793/src%2Ftest%2Fui%2Ferror-codes%2FE0161.edition.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0161.edition.stderr?ref=26b45573be204da2cc0db12828b7a03c41c73793", "patch": "@@ -1,5 +1,5 @@\n error[E0161]: cannot move a value of type dyn Bar: the size of dyn Bar cannot be statically determined\n-  --> $DIR/E0161.rs:29:5\n+  --> $DIR/E0161.rs:32:5\n    |\n LL |     x.f();\n    |     ^^^^^"}, {"sha": "fb082bc1eabcf51bcd907f1e6d7e802fa2a4188f", "filename": "src/test/ui/error-codes/E0161.migrate.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/26b45573be204da2cc0db12828b7a03c41c73793/src%2Ftest%2Fui%2Ferror-codes%2FE0161.migrate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/26b45573be204da2cc0db12828b7a03c41c73793/src%2Ftest%2Fui%2Ferror-codes%2FE0161.migrate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0161.migrate.stderr?ref=26b45573be204da2cc0db12828b7a03c41c73793", "patch": "@@ -1,5 +1,5 @@\n error[E0161]: cannot move a value of type dyn Bar: the size of dyn Bar cannot be statically determined\n-  --> $DIR/E0161.rs:29:5\n+  --> $DIR/E0161.rs:32:5\n    |\n LL |     x.f();\n    |     ^^^^^"}, {"sha": "fb082bc1eabcf51bcd907f1e6d7e802fa2a4188f", "filename": "src/test/ui/error-codes/E0161.nll.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/26b45573be204da2cc0db12828b7a03c41c73793/src%2Ftest%2Fui%2Ferror-codes%2FE0161.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/26b45573be204da2cc0db12828b7a03c41c73793/src%2Ftest%2Fui%2Ferror-codes%2FE0161.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0161.nll.stderr?ref=26b45573be204da2cc0db12828b7a03c41c73793", "patch": "@@ -1,5 +1,5 @@\n error[E0161]: cannot move a value of type dyn Bar: the size of dyn Bar cannot be statically determined\n-  --> $DIR/E0161.rs:29:5\n+  --> $DIR/E0161.rs:32:5\n    |\n LL |     x.f();\n    |     ^^^^^"}, {"sha": "f3a7b68c7cf850eac4521ad4082321152d58e42d", "filename": "src/test/ui/error-codes/E0161.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/26b45573be204da2cc0db12828b7a03c41c73793/src%2Ftest%2Fui%2Ferror-codes%2FE0161.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26b45573be204da2cc0db12828b7a03c41c73793/src%2Ftest%2Fui%2Ferror-codes%2FE0161.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0161.rs?ref=26b45573be204da2cc0db12828b7a03c41c73793", "patch": "@@ -1,5 +1,3 @@\n-// ignore-compare-mode-nll\n-\n // Check that E0161 is a hard error in all possible configurations that might\n // affect it.\n \n@@ -13,6 +11,11 @@\n //[zflagsul] check-pass\n //[editionul] check-pass\n \n+// Since we are testing nll (and migration) explicitly as a separate\n+// revisions, don't worry about the --compare-mode=nll on this test.\n+\n+// ignore-compare-mode-nll\n+\n #![allow(incomplete_features)]\n #![cfg_attr(nll, feature(nll))]\n #![cfg_attr(nllul, feature(nll))]"}, {"sha": "fb082bc1eabcf51bcd907f1e6d7e802fa2a4188f", "filename": "src/test/ui/error-codes/E0161.zflags.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/26b45573be204da2cc0db12828b7a03c41c73793/src%2Ftest%2Fui%2Ferror-codes%2FE0161.zflags.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/26b45573be204da2cc0db12828b7a03c41c73793/src%2Ftest%2Fui%2Ferror-codes%2FE0161.zflags.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0161.zflags.stderr?ref=26b45573be204da2cc0db12828b7a03c41c73793", "patch": "@@ -1,5 +1,5 @@\n error[E0161]: cannot move a value of type dyn Bar: the size of dyn Bar cannot be statically determined\n-  --> $DIR/E0161.rs:29:5\n+  --> $DIR/E0161.rs:32:5\n    |\n LL |     x.f();\n    |     ^^^^^"}, {"sha": "7da6b029c26f0f6ad6e712410fa3fe9e16a4fbf0", "filename": "src/test/ui/higher-rank-trait-bounds/normalize-under-binder/issue-71955.migrate.stderr", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/26b45573be204da2cc0db12828b7a03c41c73793/src%2Ftest%2Fui%2Fhigher-rank-trait-bounds%2Fnormalize-under-binder%2Fissue-71955.migrate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/26b45573be204da2cc0db12828b7a03c41c73793/src%2Ftest%2Fui%2Fhigher-rank-trait-bounds%2Fnormalize-under-binder%2Fissue-71955.migrate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhigher-rank-trait-bounds%2Fnormalize-under-binder%2Fissue-71955.migrate.stderr?ref=26b45573be204da2cc0db12828b7a03c41c73793", "patch": "@@ -1,5 +1,5 @@\n error: implementation of `Parser` is not general enough\n-  --> $DIR/issue-71955.rs:52:5\n+  --> $DIR/issue-71955.rs:57:5\n    |\n LL |     foo(bar, \"string\", |s| s.len() == 5);\n    |     ^^^ implementation of `Parser` is not general enough\n@@ -8,7 +8,7 @@ LL |     foo(bar, \"string\", |s| s.len() == 5);\n    = note: ...but it actually implements `Parser<'1>`, for some specific lifetime `'1`\n \n error: implementation of `Parser` is not general enough\n-  --> $DIR/issue-71955.rs:52:5\n+  --> $DIR/issue-71955.rs:57:5\n    |\n LL |     foo(bar, \"string\", |s| s.len() == 5);\n    |     ^^^ implementation of `Parser` is not general enough\n@@ -17,7 +17,7 @@ LL |     foo(bar, \"string\", |s| s.len() == 5);\n    = note: ...but it actually implements `Parser<'1>`, for some specific lifetime `'1`\n \n error: implementation of `Parser` is not general enough\n-  --> $DIR/issue-71955.rs:52:5\n+  --> $DIR/issue-71955.rs:57:5\n    |\n LL |     foo(bar, \"string\", |s| s.len() == 5);\n    |     ^^^ implementation of `Parser` is not general enough\n@@ -26,7 +26,7 @@ LL |     foo(bar, \"string\", |s| s.len() == 5);\n    = note: ...but it actually implements `Parser<'1>`, for some specific lifetime `'1`\n \n error: implementation of `Parser` is not general enough\n-  --> $DIR/issue-71955.rs:52:5\n+  --> $DIR/issue-71955.rs:57:5\n    |\n LL |     foo(bar, \"string\", |s| s.len() == 5);\n    |     ^^^ implementation of `Parser` is not general enough\n@@ -35,7 +35,7 @@ LL |     foo(bar, \"string\", |s| s.len() == 5);\n    = note: ...but it actually implements `Parser<'1>`, for some specific lifetime `'1`\n \n error: implementation of `Parser` is not general enough\n-  --> $DIR/issue-71955.rs:52:5\n+  --> $DIR/issue-71955.rs:57:5\n    |\n LL |     foo(bar, \"string\", |s| s.len() == 5);\n    |     ^^^ implementation of `Parser` is not general enough\n@@ -44,7 +44,7 @@ LL |     foo(bar, \"string\", |s| s.len() == 5);\n    = note: ...but it actually implements `Parser<'1>`, for some specific lifetime `'1`\n \n error: implementation of `Parser` is not general enough\n-  --> $DIR/issue-71955.rs:58:5\n+  --> $DIR/issue-71955.rs:63:5\n    |\n LL |     foo(baz, \"string\", |s| s.0.len() == 5);\n    |     ^^^ implementation of `Parser` is not general enough\n@@ -53,7 +53,7 @@ LL |     foo(baz, \"string\", |s| s.0.len() == 5);\n    = note: ...but it actually implements `Parser<'1>`, for some specific lifetime `'1`\n \n error: implementation of `Parser` is not general enough\n-  --> $DIR/issue-71955.rs:58:5\n+  --> $DIR/issue-71955.rs:63:5\n    |\n LL |     foo(baz, \"string\", |s| s.0.len() == 5);\n    |     ^^^ implementation of `Parser` is not general enough\n@@ -62,7 +62,7 @@ LL |     foo(baz, \"string\", |s| s.0.len() == 5);\n    = note: ...but it actually implements `Parser<'1>`, for some specific lifetime `'1`\n \n error: implementation of `Parser` is not general enough\n-  --> $DIR/issue-71955.rs:58:5\n+  --> $DIR/issue-71955.rs:63:5\n    |\n LL |     foo(baz, \"string\", |s| s.0.len() == 5);\n    |     ^^^ implementation of `Parser` is not general enough\n@@ -71,7 +71,7 @@ LL |     foo(baz, \"string\", |s| s.0.len() == 5);\n    = note: ...but it actually implements `Parser<'1>`, for some specific lifetime `'1`\n \n error: implementation of `Parser` is not general enough\n-  --> $DIR/issue-71955.rs:58:5\n+  --> $DIR/issue-71955.rs:63:5\n    |\n LL |     foo(baz, \"string\", |s| s.0.len() == 5);\n    |     ^^^ implementation of `Parser` is not general enough\n@@ -80,7 +80,7 @@ LL |     foo(baz, \"string\", |s| s.0.len() == 5);\n    = note: ...but it actually implements `Parser<'1>`, for some specific lifetime `'1`\n \n error: implementation of `Parser` is not general enough\n-  --> $DIR/issue-71955.rs:58:5\n+  --> $DIR/issue-71955.rs:63:5\n    |\n LL |     foo(baz, \"string\", |s| s.0.len() == 5);\n    |     ^^^ implementation of `Parser` is not general enough"}, {"sha": "c2feaa91280557c001a6d88fe53b304e89e5905b", "filename": "src/test/ui/higher-rank-trait-bounds/normalize-under-binder/issue-71955.nll.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/26b45573be204da2cc0db12828b7a03c41c73793/src%2Ftest%2Fui%2Fhigher-rank-trait-bounds%2Fnormalize-under-binder%2Fissue-71955.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/26b45573be204da2cc0db12828b7a03c41c73793/src%2Ftest%2Fui%2Fhigher-rank-trait-bounds%2Fnormalize-under-binder%2Fissue-71955.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhigher-rank-trait-bounds%2Fnormalize-under-binder%2Fissue-71955.nll.stderr?ref=26b45573be204da2cc0db12828b7a03c41c73793", "patch": "@@ -1,5 +1,5 @@\n error: fatal error triggered by #[rustc_error]\n-  --> $DIR/issue-71955.rs:42:1\n+  --> $DIR/issue-71955.rs:47:1\n    |\n LL | fn main() {\n    | ^^^^^^^^^"}, {"sha": "3d6778b6942c52c8213684d14fc30ae50ff1df9d", "filename": "src/test/ui/higher-rank-trait-bounds/normalize-under-binder/issue-71955.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/26b45573be204da2cc0db12828b7a03c41c73793/src%2Ftest%2Fui%2Fhigher-rank-trait-bounds%2Fnormalize-under-binder%2Fissue-71955.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26b45573be204da2cc0db12828b7a03c41c73793/src%2Ftest%2Fui%2Fhigher-rank-trait-bounds%2Fnormalize-under-binder%2Fissue-71955.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhigher-rank-trait-bounds%2Fnormalize-under-binder%2Fissue-71955.rs?ref=26b45573be204da2cc0db12828b7a03c41c73793", "patch": "@@ -3,6 +3,11 @@\n // [nll]compile-flags: -Zborrowck=mir\n // check-fail\n \n+// Since we are testing nll (and migration) explicitly as a separate\n+// revisions, don't worry about the --compare-mode=nll on this test.\n+\n+// ignore-compare-mode-nll\n+\n #![feature(rustc_attrs)]\n \n trait Parser<'s> {"}, {"sha": "a2ab1f1856d3ee3ea8f0f34c9e59b42dc0b23def", "filename": "src/test/ui/hrtb/issue-30786.migrate.stderr", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/26b45573be204da2cc0db12828b7a03c41c73793/src%2Ftest%2Fui%2Fhrtb%2Fissue-30786.migrate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/26b45573be204da2cc0db12828b7a03c41c73793/src%2Ftest%2Fui%2Fhrtb%2Fissue-30786.migrate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhrtb%2Fissue-30786.migrate.stderr?ref=26b45573be204da2cc0db12828b7a03c41c73793", "patch": "@@ -1,5 +1,5 @@\n-error[E0599]: the method `filterx` exists for struct `Map<Repeat, [closure@$DIR/issue-30786.rs:127:27: 127:36]>`, but its trait bounds were not satisfied\n-  --> $DIR/issue-30786.rs:128:22\n+error[E0599]: the method `filterx` exists for struct `Map<Repeat, [closure@$DIR/issue-30786.rs:126:27: 126:36]>`, but its trait bounds were not satisfied\n+  --> $DIR/issue-30786.rs:127:22\n    |\n LL | pub struct Map<S, F> {\n    | --------------------\n@@ -8,19 +8,19 @@ LL | pub struct Map<S, F> {\n    | doesn't satisfy `_: StreamExt`\n ...\n LL |     let filter = map.filterx(|x: &_| true);\n-   |                      ^^^^^^^ method cannot be called on `Map<Repeat, [closure@$DIR/issue-30786.rs:127:27: 127:36]>` due to unsatisfied trait bounds\n+   |                      ^^^^^^^ method cannot be called on `Map<Repeat, [closure@$DIR/issue-30786.rs:126:27: 126:36]>` due to unsatisfied trait bounds\n    |\n note: the following trait bounds were not satisfied because of the requirements of the implementation of `StreamExt` for `_`:\n-      `&'a mut Map<Repeat, [closure@$DIR/issue-30786.rs:127:27: 127:36]>: Stream`\n-      `&'a mut &Map<Repeat, [closure@$DIR/issue-30786.rs:127:27: 127:36]>: Stream`\n-      `&'a mut &mut Map<Repeat, [closure@$DIR/issue-30786.rs:127:27: 127:36]>: Stream`\n-  --> $DIR/issue-30786.rs:106:9\n+      `&'a mut Map<Repeat, [closure@$DIR/issue-30786.rs:126:27: 126:36]>: Stream`\n+      `&'a mut &Map<Repeat, [closure@$DIR/issue-30786.rs:126:27: 126:36]>: Stream`\n+      `&'a mut &mut Map<Repeat, [closure@$DIR/issue-30786.rs:126:27: 126:36]>: Stream`\n+  --> $DIR/issue-30786.rs:105:9\n    |\n LL | impl<T> StreamExt for T where for<'a> &'a mut T: Stream {}\n    |         ^^^^^^^^^     ^\n \n-error[E0599]: the method `countx` exists for struct `Filter<Map<Repeat, for<'r> fn(&'r u64) -> &'r u64 {identity::<u64>}>, [closure@$DIR/issue-30786.rs:140:30: 140:42]>`, but its trait bounds were not satisfied\n-  --> $DIR/issue-30786.rs:141:24\n+error[E0599]: the method `countx` exists for struct `Filter<Map<Repeat, for<'r> fn(&'r u64) -> &'r u64 {identity::<u64>}>, [closure@$DIR/issue-30786.rs:139:30: 139:42]>`, but its trait bounds were not satisfied\n+  --> $DIR/issue-30786.rs:140:24\n    |\n LL | pub struct Filter<S, F> {\n    | -----------------------\n@@ -29,13 +29,13 @@ LL | pub struct Filter<S, F> {\n    | doesn't satisfy `_: StreamExt`\n ...\n LL |     let count = filter.countx();\n-   |                        ^^^^^^ method cannot be called on `Filter<Map<Repeat, for<'r> fn(&'r u64) -> &'r u64 {identity::<u64>}>, [closure@$DIR/issue-30786.rs:140:30: 140:42]>` due to unsatisfied trait bounds\n+   |                        ^^^^^^ method cannot be called on `Filter<Map<Repeat, for<'r> fn(&'r u64) -> &'r u64 {identity::<u64>}>, [closure@$DIR/issue-30786.rs:139:30: 139:42]>` due to unsatisfied trait bounds\n    |\n note: the following trait bounds were not satisfied because of the requirements of the implementation of `StreamExt` for `_`:\n-      `&'a mut Filter<Map<Repeat, for<'r> fn(&'r u64) -> &'r u64 {identity::<u64>}>, [closure@$DIR/issue-30786.rs:140:30: 140:42]>: Stream`\n-      `&'a mut &Filter<Map<Repeat, for<'r> fn(&'r u64) -> &'r u64 {identity::<u64>}>, [closure@$DIR/issue-30786.rs:140:30: 140:42]>: Stream`\n-      `&'a mut &mut Filter<Map<Repeat, for<'r> fn(&'r u64) -> &'r u64 {identity::<u64>}>, [closure@$DIR/issue-30786.rs:140:30: 140:42]>: Stream`\n-  --> $DIR/issue-30786.rs:106:9\n+      `&'a mut Filter<Map<Repeat, for<'r> fn(&'r u64) -> &'r u64 {identity::<u64>}>, [closure@$DIR/issue-30786.rs:139:30: 139:42]>: Stream`\n+      `&'a mut &Filter<Map<Repeat, for<'r> fn(&'r u64) -> &'r u64 {identity::<u64>}>, [closure@$DIR/issue-30786.rs:139:30: 139:42]>: Stream`\n+      `&'a mut &mut Filter<Map<Repeat, for<'r> fn(&'r u64) -> &'r u64 {identity::<u64>}>, [closure@$DIR/issue-30786.rs:139:30: 139:42]>: Stream`\n+  --> $DIR/issue-30786.rs:105:9\n    |\n LL | impl<T> StreamExt for T where for<'a> &'a mut T: Stream {}\n    |         ^^^^^^^^^     ^"}, {"sha": "a2ab1f1856d3ee3ea8f0f34c9e59b42dc0b23def", "filename": "src/test/ui/hrtb/issue-30786.nll.stderr", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/26b45573be204da2cc0db12828b7a03c41c73793/src%2Ftest%2Fui%2Fhrtb%2Fissue-30786.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/26b45573be204da2cc0db12828b7a03c41c73793/src%2Ftest%2Fui%2Fhrtb%2Fissue-30786.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhrtb%2Fissue-30786.nll.stderr?ref=26b45573be204da2cc0db12828b7a03c41c73793", "patch": "@@ -1,5 +1,5 @@\n-error[E0599]: the method `filterx` exists for struct `Map<Repeat, [closure@$DIR/issue-30786.rs:127:27: 127:36]>`, but its trait bounds were not satisfied\n-  --> $DIR/issue-30786.rs:128:22\n+error[E0599]: the method `filterx` exists for struct `Map<Repeat, [closure@$DIR/issue-30786.rs:126:27: 126:36]>`, but its trait bounds were not satisfied\n+  --> $DIR/issue-30786.rs:127:22\n    |\n LL | pub struct Map<S, F> {\n    | --------------------\n@@ -8,19 +8,19 @@ LL | pub struct Map<S, F> {\n    | doesn't satisfy `_: StreamExt`\n ...\n LL |     let filter = map.filterx(|x: &_| true);\n-   |                      ^^^^^^^ method cannot be called on `Map<Repeat, [closure@$DIR/issue-30786.rs:127:27: 127:36]>` due to unsatisfied trait bounds\n+   |                      ^^^^^^^ method cannot be called on `Map<Repeat, [closure@$DIR/issue-30786.rs:126:27: 126:36]>` due to unsatisfied trait bounds\n    |\n note: the following trait bounds were not satisfied because of the requirements of the implementation of `StreamExt` for `_`:\n-      `&'a mut Map<Repeat, [closure@$DIR/issue-30786.rs:127:27: 127:36]>: Stream`\n-      `&'a mut &Map<Repeat, [closure@$DIR/issue-30786.rs:127:27: 127:36]>: Stream`\n-      `&'a mut &mut Map<Repeat, [closure@$DIR/issue-30786.rs:127:27: 127:36]>: Stream`\n-  --> $DIR/issue-30786.rs:106:9\n+      `&'a mut Map<Repeat, [closure@$DIR/issue-30786.rs:126:27: 126:36]>: Stream`\n+      `&'a mut &Map<Repeat, [closure@$DIR/issue-30786.rs:126:27: 126:36]>: Stream`\n+      `&'a mut &mut Map<Repeat, [closure@$DIR/issue-30786.rs:126:27: 126:36]>: Stream`\n+  --> $DIR/issue-30786.rs:105:9\n    |\n LL | impl<T> StreamExt for T where for<'a> &'a mut T: Stream {}\n    |         ^^^^^^^^^     ^\n \n-error[E0599]: the method `countx` exists for struct `Filter<Map<Repeat, for<'r> fn(&'r u64) -> &'r u64 {identity::<u64>}>, [closure@$DIR/issue-30786.rs:140:30: 140:42]>`, but its trait bounds were not satisfied\n-  --> $DIR/issue-30786.rs:141:24\n+error[E0599]: the method `countx` exists for struct `Filter<Map<Repeat, for<'r> fn(&'r u64) -> &'r u64 {identity::<u64>}>, [closure@$DIR/issue-30786.rs:139:30: 139:42]>`, but its trait bounds were not satisfied\n+  --> $DIR/issue-30786.rs:140:24\n    |\n LL | pub struct Filter<S, F> {\n    | -----------------------\n@@ -29,13 +29,13 @@ LL | pub struct Filter<S, F> {\n    | doesn't satisfy `_: StreamExt`\n ...\n LL |     let count = filter.countx();\n-   |                        ^^^^^^ method cannot be called on `Filter<Map<Repeat, for<'r> fn(&'r u64) -> &'r u64 {identity::<u64>}>, [closure@$DIR/issue-30786.rs:140:30: 140:42]>` due to unsatisfied trait bounds\n+   |                        ^^^^^^ method cannot be called on `Filter<Map<Repeat, for<'r> fn(&'r u64) -> &'r u64 {identity::<u64>}>, [closure@$DIR/issue-30786.rs:139:30: 139:42]>` due to unsatisfied trait bounds\n    |\n note: the following trait bounds were not satisfied because of the requirements of the implementation of `StreamExt` for `_`:\n-      `&'a mut Filter<Map<Repeat, for<'r> fn(&'r u64) -> &'r u64 {identity::<u64>}>, [closure@$DIR/issue-30786.rs:140:30: 140:42]>: Stream`\n-      `&'a mut &Filter<Map<Repeat, for<'r> fn(&'r u64) -> &'r u64 {identity::<u64>}>, [closure@$DIR/issue-30786.rs:140:30: 140:42]>: Stream`\n-      `&'a mut &mut Filter<Map<Repeat, for<'r> fn(&'r u64) -> &'r u64 {identity::<u64>}>, [closure@$DIR/issue-30786.rs:140:30: 140:42]>: Stream`\n-  --> $DIR/issue-30786.rs:106:9\n+      `&'a mut Filter<Map<Repeat, for<'r> fn(&'r u64) -> &'r u64 {identity::<u64>}>, [closure@$DIR/issue-30786.rs:139:30: 139:42]>: Stream`\n+      `&'a mut &Filter<Map<Repeat, for<'r> fn(&'r u64) -> &'r u64 {identity::<u64>}>, [closure@$DIR/issue-30786.rs:139:30: 139:42]>: Stream`\n+      `&'a mut &mut Filter<Map<Repeat, for<'r> fn(&'r u64) -> &'r u64 {identity::<u64>}>, [closure@$DIR/issue-30786.rs:139:30: 139:42]>: Stream`\n+  --> $DIR/issue-30786.rs:105:9\n    |\n LL | impl<T> StreamExt for T where for<'a> &'a mut T: Stream {}\n    |         ^^^^^^^^^     ^"}, {"sha": "540c26c358b1dfefc9f1d697fc31f361d6e41bb8", "filename": "src/test/ui/hrtb/issue-30786.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/26b45573be204da2cc0db12828b7a03c41c73793/src%2Ftest%2Fui%2Fhrtb%2Fissue-30786.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26b45573be204da2cc0db12828b7a03c41c73793/src%2Ftest%2Fui%2Fhrtb%2Fissue-30786.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhrtb%2Fissue-30786.rs?ref=26b45573be204da2cc0db12828b7a03c41c73793", "patch": "@@ -7,15 +7,14 @@\n // through again.\n \n // revisions: migrate nll\n+//[nll]compile-flags: -Z borrowck=mir\n \n // Since we are testing nll (and migration) explicitly as a separate\n // revisions, don't worry about the --compare-mode=nll on this test.\n \n // ignore-compare-mode-nll\n // ignore-compare-mode-polonius\n \n-//[nll]compile-flags: -Z borrowck=mir\n-\n pub trait Stream {\n     type Item;\n     fn next(self) -> Option<Self::Item>;"}, {"sha": "0b7b67496d6f32df39107feb43e1c957a029ae21", "filename": "src/test/ui/parser/issues/issue-87086-colon-path-sep.rs", "status": "modified", "additions": 22, "deletions": 9, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/26b45573be204da2cc0db12828b7a03c41c73793/src%2Ftest%2Fui%2Fparser%2Fissues%2Fissue-87086-colon-path-sep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26b45573be204da2cc0db12828b7a03c41c73793/src%2Ftest%2Fui%2Fparser%2Fissues%2Fissue-87086-colon-path-sep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissues%2Fissue-87086-colon-path-sep.rs?ref=26b45573be204da2cc0db12828b7a03c41c73793", "patch": "@@ -1,11 +1,15 @@\n // Tests that a suggestion is issued if the user wrote a colon instead of\n // a path separator in a match arm.\n \n-enum Foo {\n-    Bar,\n-    Baz,\n+mod qux {\n+    pub enum Foo {\n+        Bar,\n+        Baz,\n+    }\n }\n \n+use qux::Foo;\n+\n fn f() -> Foo { Foo::Bar }\n \n fn g1() {\n@@ -16,41 +20,43 @@ fn g1() {\n         _ => {}\n     }\n     match f() {\n-        Foo::Bar:Baz => {}\n+        qux::Foo:Bar => {}\n         //~^ ERROR: expected one of\n         //~| HELP: maybe write a path separator here\n         _ => {}\n     }\n     match f() {\n-        Foo:Bar::Baz => {}\n+        qux:Foo::Baz => {}\n         //~^ ERROR: expected one of\n         //~| HELP: maybe write a path separator here\n         _ => {}\n     }\n     match f() {\n-        Foo: Bar::Baz if true => {}\n+        qux: Foo::Baz if true => {}\n         //~^ ERROR: expected one of\n         //~| HELP: maybe write a path separator here\n         _ => {}\n     }\n-    if let Bar:Baz = f() {\n+    if let Foo:Bar = f() {\n     //~^ ERROR: expected one of\n     //~| HELP: maybe write a path separator here\n     }\n }\n \n fn g1_neg() {\n     match f() {\n-        ref Foo: Bar::Baz => {}\n+        ref qux: Foo::Baz => {}\n         //~^ ERROR: expected one of\n+        //~| HELP: maybe write a path separator here\n         _ => {}\n     }\n }\n \n fn g2_neg() {\n     match f() {\n-        mut Foo: Bar::Baz => {}\n+        mut qux: Foo::Baz => {}\n         //~^ ERROR: expected one of\n+        //~| HELP: maybe write a path separator here\n         _ => {}\n     }\n }\n@@ -62,5 +68,12 @@ fn main() {\n         Foo:Bar::Baz => {}\n         //~^ ERROR: expected one of\n         //~| HELP: maybe write a path separator here\n+        //~| ERROR: failed to resolve: `Bar` is a variant, not a module\n+    }\n+    match myfoo {\n+        Foo::Bar => {}\n+        Foo:Bar => {}\n+        //~^ ERROR: expected one of\n+        //~| HELP: maybe write a path separator here\n     }\n }"}, {"sha": "2050a16beb34983c63e96f847a82c1d23f3f16d5", "filename": "src/test/ui/parser/issues/issue-87086-colon-path-sep.stderr", "status": "modified", "additions": 41, "deletions": 19, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/26b45573be204da2cc0db12828b7a03c41c73793/src%2Ftest%2Fui%2Fparser%2Fissues%2Fissue-87086-colon-path-sep.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/26b45573be204da2cc0db12828b7a03c41c73793/src%2Ftest%2Fui%2Fparser%2Fissues%2Fissue-87086-colon-path-sep.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissues%2Fissue-87086-colon-path-sep.stderr?ref=26b45573be204da2cc0db12828b7a03c41c73793", "patch": "@@ -1,5 +1,5 @@\n error: expected one of `@` or `|`, found `:`\n-  --> $DIR/issue-87086-colon-path-sep.rs:13:12\n+  --> $DIR/issue-87086-colon-path-sep.rs:17:12\n    |\n LL |         Foo:Bar => {}\n    |            ^\n@@ -8,61 +8,83 @@ LL |         Foo:Bar => {}\n    |            help: maybe write a path separator here: `::`\n \n error: expected one of `!`, `(`, `...`, `..=`, `..`, `::`, `{`, or `|`, found `:`\n-  --> $DIR/issue-87086-colon-path-sep.rs:19:17\n+  --> $DIR/issue-87086-colon-path-sep.rs:23:17\n    |\n-LL |         Foo::Bar:Baz => {}\n+LL |         qux::Foo:Bar => {}\n    |                 ^\n    |                 |\n    |                 expected one of 8 possible tokens\n    |                 help: maybe write a path separator here: `::`\n \n error: expected one of `@` or `|`, found `:`\n-  --> $DIR/issue-87086-colon-path-sep.rs:25:12\n+  --> $DIR/issue-87086-colon-path-sep.rs:29:12\n    |\n-LL |         Foo:Bar::Baz => {}\n+LL |         qux:Foo::Baz => {}\n    |            ^\n    |            |\n    |            expected one of `@` or `|`\n    |            help: maybe write a path separator here: `::`\n \n error: expected one of `@` or `|`, found `:`\n-  --> $DIR/issue-87086-colon-path-sep.rs:31:12\n+  --> $DIR/issue-87086-colon-path-sep.rs:35:12\n    |\n-LL |         Foo: Bar::Baz if true => {}\n+LL |         qux: Foo::Baz if true => {}\n    |            ^\n    |            |\n    |            expected one of `@` or `|`\n    |            help: maybe write a path separator here: `::`\n \n error: expected one of `@` or `|`, found `:`\n-  --> $DIR/issue-87086-colon-path-sep.rs:36:15\n+  --> $DIR/issue-87086-colon-path-sep.rs:40:15\n    |\n-LL |     if let Bar:Baz = f() {\n+LL |     if let Foo:Bar = f() {\n    |               ^\n    |               |\n    |               expected one of `@` or `|`\n    |               help: maybe write a path separator here: `::`\n \n-error: expected one of `=>`, `@`, `if`, or `|`, found `:`\n-  --> $DIR/issue-87086-colon-path-sep.rs:44:16\n+error: expected one of `@` or `|`, found `:`\n+  --> $DIR/issue-87086-colon-path-sep.rs:48:16\n    |\n-LL |         ref Foo: Bar::Baz => {}\n-   |                ^ expected one of `=>`, `@`, `if`, or `|`\n+LL |         ref qux: Foo::Baz => {}\n+   |                ^\n+   |                |\n+   |                expected one of `@` or `|`\n+   |                help: maybe write a path separator here: `::`\n \n-error: expected one of `=>`, `@`, `if`, or `|`, found `:`\n-  --> $DIR/issue-87086-colon-path-sep.rs:52:16\n+error: expected one of `@` or `|`, found `:`\n+  --> $DIR/issue-87086-colon-path-sep.rs:57:16\n    |\n-LL |         mut Foo: Bar::Baz => {}\n-   |                ^ expected one of `=>`, `@`, `if`, or `|`\n+LL |         mut qux: Foo::Baz => {}\n+   |                ^\n+   |                |\n+   |                expected one of `@` or `|`\n+   |                help: maybe write a path separator here: `::`\n \n error: expected one of `@` or `|`, found `:`\n-  --> $DIR/issue-87086-colon-path-sep.rs:62:12\n+  --> $DIR/issue-87086-colon-path-sep.rs:68:12\n    |\n LL |         Foo:Bar::Baz => {}\n    |            ^\n    |            |\n    |            expected one of `@` or `|`\n    |            help: maybe write a path separator here: `::`\n \n-error: aborting due to 8 previous errors\n+error: expected one of `@` or `|`, found `:`\n+  --> $DIR/issue-87086-colon-path-sep.rs:75:12\n+   |\n+LL |         Foo:Bar => {}\n+   |            ^\n+   |            |\n+   |            expected one of `@` or `|`\n+   |            help: maybe write a path separator here: `::`\n+\n+error[E0433]: failed to resolve: `Bar` is a variant, not a module\n+  --> $DIR/issue-87086-colon-path-sep.rs:68:13\n+   |\n+LL |         Foo:Bar::Baz => {}\n+   |             ^^^ `Bar` is a variant, not a module\n+\n+error: aborting due to 10 previous errors\n \n+For more information about this error, try `rustc --explain E0433`."}, {"sha": "9bb385b0dcdc8e0c0801f5b9003619c2450cad20", "filename": "src/test/ui/regions/regions-assoc-type-in-supertrait-outlives-container.migrate.nll.stderr", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/2446a215954a99f9d33019fad7d415ef9c083502/src%2Ftest%2Fui%2Fregions%2Fregions-assoc-type-in-supertrait-outlives-container.migrate.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2446a215954a99f9d33019fad7d415ef9c083502/src%2Ftest%2Fui%2Fregions%2Fregions-assoc-type-in-supertrait-outlives-container.migrate.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-assoc-type-in-supertrait-outlives-container.migrate.nll.stderr?ref=2446a215954a99f9d33019fad7d415ef9c083502", "patch": "@@ -1,15 +0,0 @@\n-error: lifetime may not live long enough\n-  --> $DIR/regions-assoc-type-in-supertrait-outlives-container.rs:39:12\n-   |\n-LL | fn with_assoc<'a,'b>() {\n-   |               -- -- lifetime `'b` defined here\n-   |               |\n-   |               lifetime `'a` defined here\n-...\n-LL |     let _: &'a WithAssoc<TheType<'b>> = loop { };\n-   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^ type annotation requires that `'b` must outlive `'a`\n-   |\n-   = help: consider adding the following bound: `'b: 'a`\n-\n-error: aborting due to previous error\n-"}, {"sha": "d9fd1aebf277d719cce674760eaa55991154a72d", "filename": "src/test/ui/regions/regions-assoc-type-in-supertrait-outlives-container.migrate.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/26b45573be204da2cc0db12828b7a03c41c73793/src%2Ftest%2Fui%2Fregions%2Fregions-assoc-type-in-supertrait-outlives-container.migrate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/26b45573be204da2cc0db12828b7a03c41c73793/src%2Ftest%2Fui%2Fregions%2Fregions-assoc-type-in-supertrait-outlives-container.migrate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-assoc-type-in-supertrait-outlives-container.migrate.stderr?ref=26b45573be204da2cc0db12828b7a03c41c73793", "patch": "@@ -1,16 +1,16 @@\n error[E0491]: in type `&'a WithAssoc<TheType<'b>>`, reference has a longer lifetime than the data it references\n-  --> $DIR/regions-assoc-type-in-supertrait-outlives-container.rs:39:12\n+  --> $DIR/regions-assoc-type-in-supertrait-outlives-container.rs:44:12\n    |\n LL |     let _: &'a WithAssoc<TheType<'b>> = loop { };\n    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n note: the pointer is valid for the lifetime `'a` as defined here\n-  --> $DIR/regions-assoc-type-in-supertrait-outlives-container.rs:33:15\n+  --> $DIR/regions-assoc-type-in-supertrait-outlives-container.rs:38:15\n    |\n LL | fn with_assoc<'a,'b>() {\n    |               ^^\n note: but the referenced data is only valid for the lifetime `'b` as defined here\n-  --> $DIR/regions-assoc-type-in-supertrait-outlives-container.rs:33:18\n+  --> $DIR/regions-assoc-type-in-supertrait-outlives-container.rs:38:18\n    |\n LL | fn with_assoc<'a,'b>() {\n    |                  ^^"}, {"sha": "ba7572ebe31377ea9302d72836efb2fa9f337a47", "filename": "src/test/ui/regions/regions-assoc-type-in-supertrait-outlives-container.nll.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/26b45573be204da2cc0db12828b7a03c41c73793/src%2Ftest%2Fui%2Fregions%2Fregions-assoc-type-in-supertrait-outlives-container.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/26b45573be204da2cc0db12828b7a03c41c73793/src%2Ftest%2Fui%2Fregions%2Fregions-assoc-type-in-supertrait-outlives-container.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-assoc-type-in-supertrait-outlives-container.nll.stderr?ref=26b45573be204da2cc0db12828b7a03c41c73793", "patch": "@@ -1,5 +1,5 @@\n error: lifetime may not live long enough\n-  --> $DIR/regions-assoc-type-in-supertrait-outlives-container.rs:39:12\n+  --> $DIR/regions-assoc-type-in-supertrait-outlives-container.rs:44:12\n    |\n LL | fn with_assoc<'a,'b>() {\n    |               -- -- lifetime `'b` defined here"}, {"sha": "08bc64926fac365247fa73e9b3a78064c3f1f009", "filename": "src/test/ui/regions/regions-assoc-type-in-supertrait-outlives-container.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/26b45573be204da2cc0db12828b7a03c41c73793/src%2Ftest%2Fui%2Fregions%2Fregions-assoc-type-in-supertrait-outlives-container.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26b45573be204da2cc0db12828b7a03c41c73793/src%2Ftest%2Fui%2Fregions%2Fregions-assoc-type-in-supertrait-outlives-container.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-assoc-type-in-supertrait-outlives-container.rs?ref=26b45573be204da2cc0db12828b7a03c41c73793", "patch": "@@ -6,6 +6,11 @@\n // revisions: migrate nll\n //[nll]compile-flags: -Z borrowck=mir\n \n+// Since we are testing nll (and migration) explicitly as a separate\n+// revisions, don't worry about the --compare-mode=nll on this test.\n+\n+// ignore-compare-mode-nll\n+\n #![allow(dead_code)]\n \n pub trait TheTrait {"}, {"sha": "0d4694a64d087c7f7502b550ef7f043ba1bacd81", "filename": "src/test/ui/regions/regions-free-region-ordering-caller.migrate.nll.stderr", "status": "removed", "additions": 0, "deletions": 39, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/2446a215954a99f9d33019fad7d415ef9c083502/src%2Ftest%2Fui%2Fregions%2Fregions-free-region-ordering-caller.migrate.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2446a215954a99f9d33019fad7d415ef9c083502/src%2Ftest%2Fui%2Fregions%2Fregions-free-region-ordering-caller.migrate.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-free-region-ordering-caller.migrate.nll.stderr?ref=2446a215954a99f9d33019fad7d415ef9c083502", "patch": "@@ -1,39 +0,0 @@\n-error: lifetime may not live long enough\n-  --> $DIR/regions-free-region-ordering-caller.rs:11:12\n-   |\n-LL | fn call2<'a, 'b>(a: &'a usize, b: &'b usize) {\n-   |          --  -- lifetime `'b` defined here\n-   |          |\n-   |          lifetime `'a` defined here\n-LL |     let z: Option<&'b &'a usize> = None;\n-   |            ^^^^^^^^^^^^^^^^^^^^^ type annotation requires that `'a` must outlive `'b`\n-   |\n-   = help: consider adding the following bound: `'a: 'b`\n-\n-error: lifetime may not live long enough\n-  --> $DIR/regions-free-region-ordering-caller.rs:17:12\n-   |\n-LL | fn call3<'a, 'b>(a: &'a usize, b: &'b usize) {\n-   |          --  -- lifetime `'b` defined here\n-   |          |\n-   |          lifetime `'a` defined here\n-LL |     let y: Paramd<'a> = Paramd { x: a };\n-LL |     let z: Option<&'b Paramd<'a>> = None;\n-   |            ^^^^^^^^^^^^^^^^^^^^^^ type annotation requires that `'a` must outlive `'b`\n-   |\n-   = help: consider adding the following bound: `'a: 'b`\n-\n-error: lifetime may not live long enough\n-  --> $DIR/regions-free-region-ordering-caller.rs:22:12\n-   |\n-LL | fn call4<'a, 'b>(a: &'a usize, b: &'b usize) {\n-   |          --  -- lifetime `'b` defined here\n-   |          |\n-   |          lifetime `'a` defined here\n-LL |     let z: Option<&'a &'b usize> = None;\n-   |            ^^^^^^^^^^^^^^^^^^^^^ type annotation requires that `'b` must outlive `'a`\n-   |\n-   = help: consider adding the following bound: `'b: 'a`\n-\n-error: aborting due to 3 previous errors\n-"}, {"sha": "a27a010d7f302346ff76cb066406ac0f7197708e", "filename": "src/test/ui/regions/regions-free-region-ordering-caller.migrate.stderr", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/26b45573be204da2cc0db12828b7a03c41c73793/src%2Ftest%2Fui%2Fregions%2Fregions-free-region-ordering-caller.migrate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/26b45573be204da2cc0db12828b7a03c41c73793/src%2Ftest%2Fui%2Fregions%2Fregions-free-region-ordering-caller.migrate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-free-region-ordering-caller.migrate.stderr?ref=26b45573be204da2cc0db12828b7a03c41c73793", "patch": "@@ -1,50 +1,50 @@\n error[E0491]: in type `&'b &'a usize`, reference has a longer lifetime than the data it references\n-  --> $DIR/regions-free-region-ordering-caller.rs:11:12\n+  --> $DIR/regions-free-region-ordering-caller.rs:16:12\n    |\n LL |     let z: Option<&'b &'a usize> = None;\n    |            ^^^^^^^^^^^^^^^^^^^^^\n    |\n note: the pointer is valid for the lifetime `'b` as defined here\n-  --> $DIR/regions-free-region-ordering-caller.rs:10:14\n+  --> $DIR/regions-free-region-ordering-caller.rs:15:14\n    |\n LL | fn call2<'a, 'b>(a: &'a usize, b: &'b usize) {\n    |              ^^\n note: but the referenced data is only valid for the lifetime `'a` as defined here\n-  --> $DIR/regions-free-region-ordering-caller.rs:10:10\n+  --> $DIR/regions-free-region-ordering-caller.rs:15:10\n    |\n LL | fn call2<'a, 'b>(a: &'a usize, b: &'b usize) {\n    |          ^^\n \n error[E0491]: in type `&'b Paramd<'a>`, reference has a longer lifetime than the data it references\n-  --> $DIR/regions-free-region-ordering-caller.rs:17:12\n+  --> $DIR/regions-free-region-ordering-caller.rs:22:12\n    |\n LL |     let z: Option<&'b Paramd<'a>> = None;\n    |            ^^^^^^^^^^^^^^^^^^^^^^\n    |\n note: the pointer is valid for the lifetime `'b` as defined here\n-  --> $DIR/regions-free-region-ordering-caller.rs:15:14\n+  --> $DIR/regions-free-region-ordering-caller.rs:20:14\n    |\n LL | fn call3<'a, 'b>(a: &'a usize, b: &'b usize) {\n    |              ^^\n note: but the referenced data is only valid for the lifetime `'a` as defined here\n-  --> $DIR/regions-free-region-ordering-caller.rs:15:10\n+  --> $DIR/regions-free-region-ordering-caller.rs:20:10\n    |\n LL | fn call3<'a, 'b>(a: &'a usize, b: &'b usize) {\n    |          ^^\n \n error[E0491]: in type `&'a &'b usize`, reference has a longer lifetime than the data it references\n-  --> $DIR/regions-free-region-ordering-caller.rs:22:12\n+  --> $DIR/regions-free-region-ordering-caller.rs:27:12\n    |\n LL |     let z: Option<&'a &'b usize> = None;\n    |            ^^^^^^^^^^^^^^^^^^^^^\n    |\n note: the pointer is valid for the lifetime `'a` as defined here\n-  --> $DIR/regions-free-region-ordering-caller.rs:21:10\n+  --> $DIR/regions-free-region-ordering-caller.rs:26:10\n    |\n LL | fn call4<'a, 'b>(a: &'a usize, b: &'b usize) {\n    |          ^^\n note: but the referenced data is only valid for the lifetime `'b` as defined here\n-  --> $DIR/regions-free-region-ordering-caller.rs:21:14\n+  --> $DIR/regions-free-region-ordering-caller.rs:26:14\n    |\n LL | fn call4<'a, 'b>(a: &'a usize, b: &'b usize) {\n    |              ^^"}, {"sha": "546eb93d8ecab9a7f45f018dcca3de8751a85b28", "filename": "src/test/ui/regions/regions-free-region-ordering-caller.nll.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/26b45573be204da2cc0db12828b7a03c41c73793/src%2Ftest%2Fui%2Fregions%2Fregions-free-region-ordering-caller.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/26b45573be204da2cc0db12828b7a03c41c73793/src%2Ftest%2Fui%2Fregions%2Fregions-free-region-ordering-caller.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-free-region-ordering-caller.nll.stderr?ref=26b45573be204da2cc0db12828b7a03c41c73793", "patch": "@@ -1,5 +1,5 @@\n error: lifetime may not live long enough\n-  --> $DIR/regions-free-region-ordering-caller.rs:11:12\n+  --> $DIR/regions-free-region-ordering-caller.rs:16:12\n    |\n LL | fn call2<'a, 'b>(a: &'a usize, b: &'b usize) {\n    |          --  -- lifetime `'b` defined here\n@@ -11,7 +11,7 @@ LL |     let z: Option<&'b &'a usize> = None;\n    = help: consider adding the following bound: `'a: 'b`\n \n error: lifetime may not live long enough\n-  --> $DIR/regions-free-region-ordering-caller.rs:17:12\n+  --> $DIR/regions-free-region-ordering-caller.rs:22:12\n    |\n LL | fn call3<'a, 'b>(a: &'a usize, b: &'b usize) {\n    |          --  -- lifetime `'b` defined here\n@@ -24,7 +24,7 @@ LL |     let z: Option<&'b Paramd<'a>> = None;\n    = help: consider adding the following bound: `'a: 'b`\n \n error: lifetime may not live long enough\n-  --> $DIR/regions-free-region-ordering-caller.rs:22:12\n+  --> $DIR/regions-free-region-ordering-caller.rs:27:12\n    |\n LL | fn call4<'a, 'b>(a: &'a usize, b: &'b usize) {\n    |          --  -- lifetime `'b` defined here"}, {"sha": "11997a5fb56a5c3659da35785af282d549d6e4f4", "filename": "src/test/ui/regions/regions-free-region-ordering-caller.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/26b45573be204da2cc0db12828b7a03c41c73793/src%2Ftest%2Fui%2Fregions%2Fregions-free-region-ordering-caller.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26b45573be204da2cc0db12828b7a03c41c73793/src%2Ftest%2Fui%2Fregions%2Fregions-free-region-ordering-caller.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-free-region-ordering-caller.rs?ref=26b45573be204da2cc0db12828b7a03c41c73793", "patch": "@@ -5,6 +5,11 @@\n // revisions: migrate nll\n //[nll]compile-flags: -Z borrowck=mir\n \n+// Since we are testing nll (and migration) explicitly as a separate\n+// revisions, don't worry about the --compare-mode=nll on this test.\n+\n+// ignore-compare-mode-nll\n+\n struct Paramd<'a> { x: &'a usize }\n \n fn call2<'a, 'b>(a: &'a usize, b: &'b usize) {"}, {"sha": "29e92f33ec9148a97bc12a522b49883726195c17", "filename": "src/test/ui/regions/regions-outlives-projection-container-hrtb.migrate.nll.stderr", "status": "removed", "additions": 0, "deletions": 28, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/2446a215954a99f9d33019fad7d415ef9c083502/src%2Ftest%2Fui%2Fregions%2Fregions-outlives-projection-container-hrtb.migrate.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2446a215954a99f9d33019fad7d415ef9c083502/src%2Ftest%2Fui%2Fregions%2Fregions-outlives-projection-container-hrtb.migrate.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-outlives-projection-container-hrtb.migrate.nll.stderr?ref=2446a215954a99f9d33019fad7d415ef9c083502", "patch": "@@ -1,28 +0,0 @@\n-error: lifetime may not live long enough\n-  --> $DIR/regions-outlives-projection-container-hrtb.rs:30:12\n-   |\n-LL | fn with_assoc<'a,'b>() {\n-   |               -- -- lifetime `'b` defined here\n-   |               |\n-   |               lifetime `'a` defined here\n-...\n-LL |     let _: &'a WithHrAssoc<TheType<'b>> = loop { };\n-   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type annotation requires that `'b` must outlive `'a`\n-   |\n-   = help: consider adding the following bound: `'b: 'a`\n-\n-error: lifetime may not live long enough\n-  --> $DIR/regions-outlives-projection-container-hrtb.rs:50:12\n-   |\n-LL | fn with_assoc_sub<'a,'b>() {\n-   |                   -- -- lifetime `'b` defined here\n-   |                   |\n-   |                   lifetime `'a` defined here\n-...\n-LL |     let _: &'a WithHrAssocSub<TheType<'b>> = loop { };\n-   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type annotation requires that `'b` must outlive `'a`\n-   |\n-   = help: consider adding the following bound: `'b: 'a`\n-\n-error: aborting due to 2 previous errors\n-"}, {"sha": "f2308bb7c78b1e140b34eb2080484eb37a270256", "filename": "src/test/ui/regions/regions-outlives-projection-container-hrtb.migrate.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/26b45573be204da2cc0db12828b7a03c41c73793/src%2Ftest%2Fui%2Fregions%2Fregions-outlives-projection-container-hrtb.migrate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/26b45573be204da2cc0db12828b7a03c41c73793/src%2Ftest%2Fui%2Fregions%2Fregions-outlives-projection-container-hrtb.migrate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-outlives-projection-container-hrtb.migrate.stderr?ref=26b45573be204da2cc0db12828b7a03c41c73793", "patch": "@@ -1,33 +1,33 @@\n error[E0491]: in type `&'a WithHrAssoc<TheType<'b>>`, reference has a longer lifetime than the data it references\n-  --> $DIR/regions-outlives-projection-container-hrtb.rs:30:12\n+  --> $DIR/regions-outlives-projection-container-hrtb.rs:35:12\n    |\n LL |     let _: &'a WithHrAssoc<TheType<'b>> = loop { };\n    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n note: the pointer is valid for the lifetime `'a` as defined here\n-  --> $DIR/regions-outlives-projection-container-hrtb.rs:27:15\n+  --> $DIR/regions-outlives-projection-container-hrtb.rs:32:15\n    |\n LL | fn with_assoc<'a,'b>() {\n    |               ^^\n note: but the referenced data is only valid for the lifetime `'b` as defined here\n-  --> $DIR/regions-outlives-projection-container-hrtb.rs:27:18\n+  --> $DIR/regions-outlives-projection-container-hrtb.rs:32:18\n    |\n LL | fn with_assoc<'a,'b>() {\n    |                  ^^\n \n error[E0491]: in type `&'a WithHrAssocSub<TheType<'b>>`, reference has a longer lifetime than the data it references\n-  --> $DIR/regions-outlives-projection-container-hrtb.rs:50:12\n+  --> $DIR/regions-outlives-projection-container-hrtb.rs:55:12\n    |\n LL |     let _: &'a WithHrAssocSub<TheType<'b>> = loop { };\n    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n note: the pointer is valid for the lifetime `'a` as defined here\n-  --> $DIR/regions-outlives-projection-container-hrtb.rs:46:19\n+  --> $DIR/regions-outlives-projection-container-hrtb.rs:51:19\n    |\n LL | fn with_assoc_sub<'a,'b>() {\n    |                   ^^\n note: but the referenced data is only valid for the lifetime `'b` as defined here\n-  --> $DIR/regions-outlives-projection-container-hrtb.rs:46:22\n+  --> $DIR/regions-outlives-projection-container-hrtb.rs:51:22\n    |\n LL | fn with_assoc_sub<'a,'b>() {\n    |                      ^^"}, {"sha": "472323772c1a50a0e68adb29d06120b28aac045a", "filename": "src/test/ui/regions/regions-outlives-projection-container-hrtb.nll.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/26b45573be204da2cc0db12828b7a03c41c73793/src%2Ftest%2Fui%2Fregions%2Fregions-outlives-projection-container-hrtb.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/26b45573be204da2cc0db12828b7a03c41c73793/src%2Ftest%2Fui%2Fregions%2Fregions-outlives-projection-container-hrtb.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-outlives-projection-container-hrtb.nll.stderr?ref=26b45573be204da2cc0db12828b7a03c41c73793", "patch": "@@ -1,5 +1,5 @@\n error: lifetime may not live long enough\n-  --> $DIR/regions-outlives-projection-container-hrtb.rs:30:12\n+  --> $DIR/regions-outlives-projection-container-hrtb.rs:35:12\n    |\n LL | fn with_assoc<'a,'b>() {\n    |               -- -- lifetime `'b` defined here\n@@ -12,7 +12,7 @@ LL |     let _: &'a WithHrAssoc<TheType<'b>> = loop { };\n    = help: consider adding the following bound: `'b: 'a`\n \n error: lifetime may not live long enough\n-  --> $DIR/regions-outlives-projection-container-hrtb.rs:50:12\n+  --> $DIR/regions-outlives-projection-container-hrtb.rs:55:12\n    |\n LL | fn with_assoc_sub<'a,'b>() {\n    |                   -- -- lifetime `'b` defined here"}, {"sha": "695a81dca27c84925390f361575fc3ab1bd773e3", "filename": "src/test/ui/regions/regions-outlives-projection-container-hrtb.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/26b45573be204da2cc0db12828b7a03c41c73793/src%2Ftest%2Fui%2Fregions%2Fregions-outlives-projection-container-hrtb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26b45573be204da2cc0db12828b7a03c41c73793/src%2Ftest%2Fui%2Fregions%2Fregions-outlives-projection-container-hrtb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-outlives-projection-container-hrtb.rs?ref=26b45573be204da2cc0db12828b7a03c41c73793", "patch": "@@ -4,6 +4,11 @@\n // revisions: migrate nll\n //[nll]compile-flags: -Z borrowck=mir\n \n+// Since we are testing nll (and migration) explicitly as a separate\n+// revisions, don't worry about the --compare-mode=nll on this test.\n+\n+// ignore-compare-mode-nll\n+\n #![allow(dead_code)]\n \n pub trait TheTrait<'b> {"}, {"sha": "7035144302479f4a0578aa074b6d1d4607f78bca", "filename": "src/test/ui/regions/regions-outlives-projection-container-wc.migrate.nll.stderr", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/2446a215954a99f9d33019fad7d415ef9c083502/src%2Ftest%2Fui%2Fregions%2Fregions-outlives-projection-container-wc.migrate.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2446a215954a99f9d33019fad7d415ef9c083502/src%2Ftest%2Fui%2Fregions%2Fregions-outlives-projection-container-wc.migrate.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-outlives-projection-container-wc.migrate.nll.stderr?ref=2446a215954a99f9d33019fad7d415ef9c083502", "patch": "@@ -1,15 +0,0 @@\n-error: lifetime may not live long enough\n-  --> $DIR/regions-outlives-projection-container-wc.rs:33:12\n-   |\n-LL | fn with_assoc<'a,'b>() {\n-   |               -- -- lifetime `'b` defined here\n-   |               |\n-   |               lifetime `'a` defined here\n-...\n-LL |     let _: &'a WithAssoc<TheType<'b>> = loop { };\n-   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^ type annotation requires that `'b` must outlive `'a`\n-   |\n-   = help: consider adding the following bound: `'b: 'a`\n-\n-error: aborting due to previous error\n-"}, {"sha": "bda2896fca4ac9b3bb831986f4e9494c630bd2b6", "filename": "src/test/ui/regions/regions-outlives-projection-container-wc.migrate.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/26b45573be204da2cc0db12828b7a03c41c73793/src%2Ftest%2Fui%2Fregions%2Fregions-outlives-projection-container-wc.migrate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/26b45573be204da2cc0db12828b7a03c41c73793/src%2Ftest%2Fui%2Fregions%2Fregions-outlives-projection-container-wc.migrate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-outlives-projection-container-wc.migrate.stderr?ref=26b45573be204da2cc0db12828b7a03c41c73793", "patch": "@@ -1,16 +1,16 @@\n error[E0491]: in type `&'a WithAssoc<TheType<'b>>`, reference has a longer lifetime than the data it references\n-  --> $DIR/regions-outlives-projection-container-wc.rs:33:12\n+  --> $DIR/regions-outlives-projection-container-wc.rs:38:12\n    |\n LL |     let _: &'a WithAssoc<TheType<'b>> = loop { };\n    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n note: the pointer is valid for the lifetime `'a` as defined here\n-  --> $DIR/regions-outlives-projection-container-wc.rs:27:15\n+  --> $DIR/regions-outlives-projection-container-wc.rs:32:15\n    |\n LL | fn with_assoc<'a,'b>() {\n    |               ^^\n note: but the referenced data is only valid for the lifetime `'b` as defined here\n-  --> $DIR/regions-outlives-projection-container-wc.rs:27:18\n+  --> $DIR/regions-outlives-projection-container-wc.rs:32:18\n    |\n LL | fn with_assoc<'a,'b>() {\n    |                  ^^"}, {"sha": "fc32a72d508963db013d438d3df048b49ae6be1b", "filename": "src/test/ui/regions/regions-outlives-projection-container-wc.nll.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/26b45573be204da2cc0db12828b7a03c41c73793/src%2Ftest%2Fui%2Fregions%2Fregions-outlives-projection-container-wc.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/26b45573be204da2cc0db12828b7a03c41c73793/src%2Ftest%2Fui%2Fregions%2Fregions-outlives-projection-container-wc.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-outlives-projection-container-wc.nll.stderr?ref=26b45573be204da2cc0db12828b7a03c41c73793", "patch": "@@ -1,5 +1,5 @@\n error: lifetime may not live long enough\n-  --> $DIR/regions-outlives-projection-container-wc.rs:33:12\n+  --> $DIR/regions-outlives-projection-container-wc.rs:38:12\n    |\n LL | fn with_assoc<'a,'b>() {\n    |               -- -- lifetime `'b` defined here"}, {"sha": "c9b714cffb6e4528cc0bf1f8a7050fd61c98cd95", "filename": "src/test/ui/regions/regions-outlives-projection-container-wc.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/26b45573be204da2cc0db12828b7a03c41c73793/src%2Ftest%2Fui%2Fregions%2Fregions-outlives-projection-container-wc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26b45573be204da2cc0db12828b7a03c41c73793/src%2Ftest%2Fui%2Fregions%2Fregions-outlives-projection-container-wc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-outlives-projection-container-wc.rs?ref=26b45573be204da2cc0db12828b7a03c41c73793", "patch": "@@ -6,6 +6,11 @@\n // revisions: migrate nll\n //[nll]compile-flags: -Z borrowck=mir\n \n+// Since we are testing nll (and migration) explicitly as a separate\n+// revisions, don't worry about the --compare-mode=nll on this test.\n+\n+// ignore-compare-mode-nll\n+\n #![allow(dead_code)]\n \n pub trait TheTrait {"}]}