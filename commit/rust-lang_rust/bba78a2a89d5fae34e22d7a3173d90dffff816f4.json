{"sha": "bba78a2a89d5fae34e22d7a3173d90dffff816f4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJiYTc4YTJhODlkNWZhZTM0ZTIyZDdhMzE3M2Q5MGRmZmZmODE2ZjQ=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-12-29T00:40:15Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-12-31T19:34:22Z"}, "message": "Implement native UDP I/O", "tree": {"sha": "d14dd194276ed9b6909f36a485fcfa2011ae88aa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d14dd194276ed9b6909f36a485fcfa2011ae88aa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bba78a2a89d5fae34e22d7a3173d90dffff816f4", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bba78a2a89d5fae34e22d7a3173d90dffff816f4", "html_url": "https://github.com/rust-lang/rust/commit/bba78a2a89d5fae34e22d7a3173d90dffff816f4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bba78a2a89d5fae34e22d7a3173d90dffff816f4/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "292269708701f1dfc663668aa72584617b3d9ccc", "url": "https://api.github.com/repos/rust-lang/rust/commits/292269708701f1dfc663668aa72584617b3d9ccc", "html_url": "https://github.com/rust-lang/rust/commit/292269708701f1dfc663668aa72584617b3d9ccc"}], "stats": {"total": 492, "additions": 379, "deletions": 113}, "files": [{"sha": "b936a36cf3a6590ab1809389528ec9876da6e7a1", "filename": "src/libnative/io/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bba78a2a89d5fae34e22d7a3173d90dffff816f4/src%2Flibnative%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bba78a2a89d5fae34e22d7a3173d90dffff816f4/src%2Flibnative%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fmod.rs?ref=bba78a2a89d5fae34e22d7a3173d90dffff816f4", "patch": "@@ -166,8 +166,8 @@ impl rtio::IoFactory for IoFactory {\n     fn tcp_bind(&mut self, addr: SocketAddr) -> IoResult<~RtioTcpListener> {\n         net::TcpListener::bind(addr).map(|s| ~s as ~RtioTcpListener)\n     }\n-    fn udp_bind(&mut self, _addr: SocketAddr) -> IoResult<~RtioUdpSocket> {\n-        Err(unimpl())\n+    fn udp_bind(&mut self, addr: SocketAddr) -> IoResult<~RtioUdpSocket> {\n+        net::UdpSocket::bind(addr).map(|u| ~u as ~RtioUdpSocket)\n     }\n     fn unix_bind(&mut self, _path: &CString) -> IoResult<~RtioUnixListener> {\n         Err(unimpl())"}, {"sha": "674f02d4a22f0666c9bb6faec94533242fe599eb", "filename": "src/libnative/io/net.rs", "status": "modified", "additions": 262, "deletions": 87, "changes": 349, "blob_url": "https://github.com/rust-lang/rust/blob/bba78a2a89d5fae34e22d7a3173d90dffff816f4/src%2Flibnative%2Fio%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bba78a2a89d5fae34e22d7a3173d90dffff816f4/src%2Flibnative%2Fio%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fnet.rs?ref=bba78a2a89d5fae34e22d7a3173d90dffff816f4", "patch": "@@ -19,13 +19,13 @@ use std::unstable::intrinsics;\n use super::IoResult;\n use super::file::keep_going;\n \n+////////////////////////////////////////////////////////////////////////////////\n+// sockaddr and misc bindings\n+////////////////////////////////////////////////////////////////////////////////\n+\n #[cfg(windows)] pub type sock_t = libc::SOCKET;\n #[cfg(unix)]    pub type sock_t = super::file::fd_t;\n \n-pub struct TcpStream {\n-    priv fd: sock_t,\n-}\n-\n #[cfg(target_endian = \"big\")] pub fn htons(x: u16) -> u16 { x }\n #[cfg(target_endian = \"big\")] pub fn ntohs(x: u16) -> u16 { x }\n #[cfg(target_endian = \"little\")]\n@@ -37,52 +37,88 @@ pub fn ntohs(u: u16) -> u16 {\n     unsafe { intrinsics::bswap16(u as i16) as u16 }\n }\n \n+enum InAddr {\n+    InAddr(libc::in_addr),\n+    In6Addr(libc::in6_addr),\n+}\n+\n+fn ip_to_inaddr(ip: ip::IpAddr) -> InAddr {\n+    match ip {\n+        ip::Ipv4Addr(a, b, c, d) => {\n+            InAddr(libc::in_addr {\n+                s_addr: (d as u32 << 24) |\n+                        (c as u32 << 16) |\n+                        (b as u32 <<  8) |\n+                        (a as u32 <<  0)\n+            })\n+        }\n+        ip::Ipv6Addr(a, b, c, d, e, f, g, h) => {\n+            In6Addr(libc::in6_addr {\n+                s6_addr: [\n+                    htons(a),\n+                    htons(b),\n+                    htons(c),\n+                    htons(d),\n+                    htons(e),\n+                    htons(f),\n+                    htons(g),\n+                    htons(h),\n+                ]\n+            })\n+        }\n+    }\n+}\n+\n fn addr_to_sockaddr(addr: ip::SocketAddr) -> (libc::sockaddr_storage, uint) {\n     unsafe {\n         let storage: libc::sockaddr_storage = intrinsics::init();\n-        let len = match addr.ip {\n-            ip::Ipv4Addr(a, b, c, d) => {\n+        let len = match ip_to_inaddr(addr.ip) {\n+            InAddr(inaddr) => {\n                 let storage: *mut libc::sockaddr_in = cast::transmute(&storage);\n                 (*storage).sin_family = libc::AF_INET as libc::sa_family_t;\n                 (*storage).sin_port = htons(addr.port);\n-                (*storage).sin_addr.s_addr = (d as u32 << 24) |\n-                                             (c as u32 << 16) |\n-                                             (b as u32 <<  8) |\n-                                             (a as u32 <<  0);\n+                (*storage).sin_addr = inaddr;\n                 mem::size_of::<libc::sockaddr_in>()\n             }\n-            ip::Ipv6Addr(a, b, c, d, e, f, g, h) => {\n+            In6Addr(inaddr) => {\n                 let storage: *mut libc::sockaddr_in6 = cast::transmute(&storage);\n                 (*storage).sin6_family = libc::AF_INET6 as libc::sa_family_t;\n                 (*storage).sin6_port = htons(addr.port);\n-                (*storage).sin6_addr.s6_addr[0] = htons(a);\n-                (*storage).sin6_addr.s6_addr[1] = htons(b);\n-                (*storage).sin6_addr.s6_addr[2] = htons(c);\n-                (*storage).sin6_addr.s6_addr[3] = htons(d);\n-                (*storage).sin6_addr.s6_addr[4] = htons(e);\n-                (*storage).sin6_addr.s6_addr[5] = htons(f);\n-                (*storage).sin6_addr.s6_addr[6] = htons(g);\n-                (*storage).sin6_addr.s6_addr[7] = htons(h);\n+                (*storage).sin6_addr = inaddr;\n                 mem::size_of::<libc::sockaddr_in6>()\n             }\n         };\n         return (storage, len);\n     }\n }\n \n-fn socket(addr: ip::SocketAddr) -> IoResult<sock_t> {\n+fn socket(addr: ip::SocketAddr, ty: libc::c_int) -> IoResult<sock_t> {\n     unsafe {\n         let fam = match addr.ip {\n             ip::Ipv4Addr(..) => libc::AF_INET,\n             ip::Ipv6Addr(..) => libc::AF_INET6,\n         };\n-        match libc::socket(fam, libc::SOCK_STREAM, 0) {\n+        match libc::socket(fam, ty, 0) {\n             -1 => Err(super::last_error()),\n             fd => Ok(fd),\n         }\n     }\n }\n \n+fn setsockopt<T>(fd: sock_t, opt: libc::c_int, val: libc::c_int,\n+                 payload: T) -> IoResult<()> {\n+    unsafe {\n+        let payload = &payload as *T as *libc::c_void;\n+        let ret = libc::setsockopt(fd, opt, val,\n+                                   payload,\n+                                   mem::size_of::<T>() as libc::socklen_t);\n+        super::mkerr_libc(ret)\n+    }\n+}\n+\n+#[cfg(windows)] unsafe fn close(sock: sock_t) { libc::closesocket(sock); }\n+#[cfg(unix)]    unsafe fn close(sock: sock_t) { libc::close(sock); }\n+\n fn sockname(fd: sock_t,\n             f: extern \"system\" unsafe fn(sock_t, *mut libc::sockaddr,\n                                          *mut libc::socklen_t) -> libc::c_int)\n@@ -99,11 +135,16 @@ fn sockname(fd: sock_t,\n             return Err(super::last_error())\n         }\n     }\n+    return sockaddr_to_addr(&storage, len as uint);\n+}\n+\n+fn sockaddr_to_addr(storage: &libc::sockaddr_storage,\n+                    len: uint) -> IoResult<ip::SocketAddr> {\n     match storage.ss_family as libc::c_int {\n         libc::AF_INET => {\n             assert!(len as uint >= mem::size_of::<libc::sockaddr_in>());\n-            let storage: &mut libc::sockaddr_in = unsafe {\n-                cast::transmute(&mut storage)\n+            let storage: &libc::sockaddr_in = unsafe {\n+                cast::transmute(storage)\n             };\n             let addr = storage.sin_addr.s_addr as u32;\n             let a = (addr >>  0) as u8;\n@@ -117,8 +158,8 @@ fn sockname(fd: sock_t,\n         }\n         libc::AF_INET6 => {\n             assert!(len as uint >= mem::size_of::<libc::sockaddr_in6>());\n-            let storage: &mut libc::sockaddr_in6 = unsafe {\n-                cast::transmute(&mut storage)\n+            let storage: &libc::sockaddr_in6 = unsafe {\n+                cast::transmute(storage)\n             };\n             let a = ntohs(storage.sin6_addr.s6_addr[0]);\n             let b = ntohs(storage.sin6_addr.s6_addr[1]);\n@@ -180,10 +221,18 @@ pub fn init() {\n     }\n }\n \n+////////////////////////////////////////////////////////////////////////////////\n+// TCP streams\n+////////////////////////////////////////////////////////////////////////////////\n+\n+pub struct TcpStream {\n+    priv fd: sock_t,\n+}\n+\n impl TcpStream {\n     pub fn connect(addr: ip::SocketAddr) -> IoResult<TcpStream> {\n         unsafe {\n-            socket(addr).and_then(|fd| {\n+            socket(addr, libc::SOCK_STREAM).and_then(|fd| {\n                 let (addr, len) = addr_to_sockaddr(addr);\n                 let addrp = &addr as *libc::sockaddr_storage;\n                 let ret = TcpStream { fd: fd };\n@@ -199,63 +248,31 @@ impl TcpStream {\n     pub fn fd(&self) -> sock_t { self.fd }\n \n     fn set_nodelay(&mut self, nodelay: bool) -> IoResult<()> {\n-        unsafe {\n-            let on = nodelay as libc::c_int;\n-            let on = &on as *libc::c_int;\n-            super::mkerr_libc(libc::setsockopt(self.fd,\n-                                               libc::IPPROTO_TCP,\n-                                               libc::TCP_NODELAY,\n-                                               on as *libc::c_void,\n-                                               mem::size_of::<libc::c_void>()\n-                                                    as libc::socklen_t))\n-        }\n+        setsockopt(self.fd, libc::IPPROTO_TCP, libc::TCP_NODELAY,\n+                   nodelay as libc::c_int)\n     }\n \n     fn set_keepalive(&mut self, seconds: Option<uint>) -> IoResult<()> {\n-        unsafe {\n-            let on = seconds.is_some() as libc::c_int;\n-            let on = &on as *libc::c_int;\n-            let ret = libc::setsockopt(self.fd,\n-                                       libc::SOL_SOCKET,\n-                                       libc::SO_KEEPALIVE,\n-                                       on as *libc::c_void,\n-                                       mem::size_of::<libc::c_void>()\n-                                            as libc::socklen_t);\n-            if ret != 0 { return Err(super::last_error()) }\n-\n-            match seconds {\n-                Some(n) => self.set_tcp_keepalive(n),\n-                None => Ok(())\n-            }\n+        let ret = setsockopt(self.fd, libc::SOL_SOCKET, libc::SO_KEEPALIVE,\n+                             seconds.is_some() as libc::c_int);\n+        match seconds {\n+            Some(n) => ret.and_then(|()| self.set_tcp_keepalive(n)),\n+            None => ret,\n         }\n     }\n \n     #[cfg(target_os = \"macos\")]\n-    unsafe fn set_tcp_keepalive(&mut self, seconds: uint) -> IoResult<()> {\n-        let delay = seconds as libc::c_uint;\n-        let delay = &delay as *libc::c_uint;\n-        let ret = libc::setsockopt(self.fd,\n-                                   libc::IPPROTO_TCP,\n-                                   libc::TCP_KEEPALIVE,\n-                                   delay as *libc::c_void,\n-                                   mem::size_of::<libc::c_uint>()\n-                                        as libc::socklen_t);\n-        super::mkerr_libc(ret)\n+    fn set_tcp_keepalive(&mut self, seconds: uint) -> IoResult<()> {\n+        setsockopt(self.fd, libc::IPPROTO_TCP, libc::TCP_KEEPALIVE,\n+                   seconds as libc::c_int)\n     }\n     #[cfg(target_os = \"freebsd\")]\n-    unsafe fn set_tcp_keepalive(&mut self, seconds: uint) -> IoResult<()> {\n-        let delay = seconds as libc::c_uint;\n-        let delay = &delay as *libc::c_uint;\n-        let ret = libc::setsockopt(self.fd,\n-                                   libc::IPPROTO_TCP,\n-                                   libc::TCP_KEEPIDLE,\n-                                   delay as *libc::c_void,\n-                                   mem::size_of::<libc::c_uint>()\n-                                        as libc::socklen_t);\n-        super::mkerr_libc(ret)\n+    fn set_tcp_keepalive(&mut self, seconds: uint) -> IoResult<()> {\n+        setsockopt(self.fd, libc::IPPROTO_TCP, libc::TCP_KEEPIDLE,\n+                   seconds as libc::c_int)\n     }\n     #[cfg(not(target_os = \"macos\"), not(target_os = \"freebsd\"))]\n-    unsafe fn set_tcp_keepalive(&mut self, _seconds: uint) -> IoResult<()> {\n+    fn set_tcp_keepalive(&mut self, _seconds: uint) -> IoResult<()> {\n         Ok(())\n     }\n }\n@@ -320,25 +337,21 @@ impl rtio::RtioSocket for TcpStream {\n }\n \n impl Drop for TcpStream {\n-    #[cfg(unix)]\n-    fn drop(&mut self) {\n-        unsafe { libc::close(self.fd); }\n-    }\n-\n-    #[cfg(windows)]\n-    fn drop(&mut self) {\n-        unsafe { libc::closesocket(self.fd); }\n-    }\n+    fn drop(&mut self) { unsafe { close(self.fd); } }\n }\n \n+////////////////////////////////////////////////////////////////////////////////\n+// TCP listeners\n+////////////////////////////////////////////////////////////////////////////////\n+\n pub struct TcpListener {\n     priv fd: sock_t,\n }\n \n impl TcpListener {\n     pub fn bind(addr: ip::SocketAddr) -> IoResult<TcpListener> {\n         unsafe {\n-            socket(addr).and_then(|fd| {\n+            socket(addr, libc::SOCK_STREAM).and_then(|fd| {\n                 let (addr, len) = addr_to_sockaddr(addr);\n                 let addrp = &addr as *libc::sockaddr_storage;\n                 let ret = TcpListener { fd: fd };\n@@ -356,7 +369,7 @@ impl TcpListener {\n     pub fn native_listen(self, backlog: int) -> IoResult<TcpAcceptor> {\n         match unsafe { libc::listen(self.fd, backlog as libc::c_int) } {\n             -1 => Err(super::last_error()),\n-            _ => Ok(TcpAcceptor { fd: self.fd })\n+            _ => Ok(TcpAcceptor { listener: self })\n         }\n     }\n }\n@@ -373,20 +386,24 @@ impl rtio::RtioSocket for TcpListener {\n     }\n }\n \n+impl Drop for TcpListener {\n+    fn drop(&mut self) { unsafe { close(self.fd); } }\n+}\n+\n pub struct TcpAcceptor {\n-    priv fd: sock_t,\n+    priv listener: TcpListener,\n }\n \n impl TcpAcceptor {\n-    pub fn fd(&self) -> sock_t { self.fd }\n+    pub fn fd(&self) -> sock_t { self.listener.fd }\n \n     pub fn native_accept(&mut self) -> IoResult<TcpStream> {\n         unsafe {\n             let mut storage: libc::sockaddr_storage = intrinsics::init();\n             let storagep = &mut storage as *mut libc::sockaddr_storage;\n             let size = mem::size_of::<libc::sockaddr_storage>();\n             let mut size = size as libc::socklen_t;\n-            match libc::accept(self.fd,\n+            match libc::accept(self.fd(),\n                                storagep as *mut libc::sockaddr,\n                                &mut size as *mut libc::socklen_t) {\n                 -1 => Err(super::last_error()),\n@@ -398,7 +415,7 @@ impl TcpAcceptor {\n \n impl rtio::RtioSocket for TcpAcceptor {\n     fn socket_name(&mut self) -> IoResult<ip::SocketAddr> {\n-        sockname(self.fd, libc::getsockname)\n+        sockname(self.fd(), libc::getsockname)\n     }\n }\n \n@@ -410,3 +427,161 @@ impl rtio::RtioTcpAcceptor for TcpAcceptor {\n     fn accept_simultaneously(&mut self) -> IoResult<()> { Ok(()) }\n     fn dont_accept_simultaneously(&mut self) -> IoResult<()> { Ok(()) }\n }\n+\n+////////////////////////////////////////////////////////////////////////////////\n+// UDP\n+////////////////////////////////////////////////////////////////////////////////\n+\n+pub struct UdpSocket {\n+    priv fd: sock_t,\n+}\n+\n+impl UdpSocket {\n+    pub fn bind(addr: ip::SocketAddr) -> IoResult<UdpSocket> {\n+        unsafe {\n+            socket(addr, libc::SOCK_DGRAM).and_then(|fd| {\n+                let (addr, len) = addr_to_sockaddr(addr);\n+                let addrp = &addr as *libc::sockaddr_storage;\n+                let ret = UdpSocket { fd: fd };\n+                match libc::bind(fd, addrp as *libc::sockaddr,\n+                                 len as libc::socklen_t) {\n+                    -1 => Err(super::last_error()),\n+                    _ => Ok(ret),\n+                }\n+            })\n+        }\n+    }\n+\n+    pub fn fd(&self) -> sock_t { self.fd }\n+\n+    pub fn set_broadcast(&mut self, on: bool) -> IoResult<()> {\n+        setsockopt(self.fd, libc::SOL_SOCKET, libc::SO_BROADCAST,\n+                   on as libc::c_int)\n+    }\n+\n+    pub fn set_multicast_loop(&mut self, on: bool) -> IoResult<()> {\n+        setsockopt(self.fd, libc::IPPROTO_IP, libc::IP_MULTICAST_LOOP,\n+                   on as libc::c_int)\n+    }\n+\n+    pub fn set_membership(&mut self, addr: ip::IpAddr,\n+                          opt: libc::c_int) -> IoResult<()> {\n+        match ip_to_inaddr(addr) {\n+            InAddr(addr) => {\n+                let mreq = libc::ip_mreq {\n+                    imr_multiaddr: addr,\n+                    // interface == INADDR_ANY\n+                    imr_interface: libc::in_addr { s_addr: 0x0 },\n+                };\n+                setsockopt(self.fd, libc::IPPROTO_IP, opt, mreq)\n+            }\n+            In6Addr(addr) => {\n+                let mreq = libc::ip6_mreq {\n+                    ipv6mr_multiaddr: addr,\n+                    ipv6mr_interface: 0,\n+                };\n+                setsockopt(self.fd, libc::IPPROTO_IPV6, opt, mreq)\n+            }\n+        }\n+    }\n+}\n+\n+impl rtio::RtioSocket for UdpSocket {\n+    fn socket_name(&mut self) -> IoResult<ip::SocketAddr> {\n+        sockname(self.fd(), libc::getsockname)\n+    }\n+}\n+\n+#[cfg(windows)] type msglen_t = libc::c_int;\n+#[cfg(unix)]    type msglen_t = libc::size_t;\n+\n+impl rtio::RtioUdpSocket for UdpSocket {\n+    fn recvfrom(&mut self, buf: &mut [u8]) -> IoResult<(uint, ip::SocketAddr)> {\n+        unsafe {\n+            let mut storage: libc::sockaddr_storage = intrinsics::init();\n+            let storagep = &mut storage as *mut libc::sockaddr_storage;\n+            let mut addrlen: libc::socklen_t =\n+                    mem::size_of::<libc::sockaddr_storage>() as libc::socklen_t;\n+            let ret = libc::recvfrom(self.fd,\n+                                     buf.as_ptr() as *mut libc::c_void,\n+                                     buf.len() as msglen_t,\n+                                     0,\n+                                     storagep as *mut libc::sockaddr,\n+                                     &mut addrlen);\n+            if ret < 0 { return Err(super::last_error()) }\n+            sockaddr_to_addr(&storage, addrlen as uint).and_then(|addr| {\n+                Ok((ret as uint, addr))\n+            })\n+        }\n+    }\n+    fn sendto(&mut self, buf: &[u8], dst: ip::SocketAddr) -> IoResult<()> {\n+        let (dst, len) = addr_to_sockaddr(dst);\n+        let dstp = &dst as *libc::sockaddr_storage;\n+        unsafe {\n+            let ret = libc::sendto(self.fd,\n+                                   buf.as_ptr() as *libc::c_void,\n+                                   buf.len() as msglen_t,\n+                                   0,\n+                                   dstp as *libc::sockaddr,\n+                                   len as libc::socklen_t);\n+            match ret {\n+                -1 => Err(super::last_error()),\n+                n if n as uint != buf.len() => {\n+                    Err(io::IoError {\n+                        kind: io::OtherIoError,\n+                        desc: \"couldn't send entire packet at once\",\n+                        detail: None,\n+                    })\n+                }\n+                _ => Ok(())\n+            }\n+        }\n+    }\n+\n+    fn join_multicast(&mut self, multi: ip::IpAddr) -> IoResult<()> {\n+        match multi {\n+            ip::Ipv4Addr(..) => {\n+                self.set_membership(multi, libc::IP_ADD_MEMBERSHIP)\n+            }\n+            ip::Ipv6Addr(..) => {\n+                self.set_membership(multi, libc::IPV6_ADD_MEMBERSHIP)\n+            }\n+        }\n+    }\n+    fn leave_multicast(&mut self, multi: ip::IpAddr) -> IoResult<()> {\n+        match multi {\n+            ip::Ipv4Addr(..) => {\n+                self.set_membership(multi, libc::IP_DROP_MEMBERSHIP)\n+            }\n+            ip::Ipv6Addr(..) => {\n+                self.set_membership(multi, libc::IPV6_DROP_MEMBERSHIP)\n+            }\n+        }\n+    }\n+\n+    fn loop_multicast_locally(&mut self) -> IoResult<()> {\n+        self.set_multicast_loop(true)\n+    }\n+    fn dont_loop_multicast_locally(&mut self) -> IoResult<()> {\n+        self.set_multicast_loop(false)\n+    }\n+\n+    fn multicast_time_to_live(&mut self, ttl: int) -> IoResult<()> {\n+        setsockopt(self.fd, libc::IPPROTO_IP, libc::IP_MULTICAST_TTL,\n+                   ttl as libc::c_int)\n+    }\n+    fn time_to_live(&mut self, ttl: int) -> IoResult<()> {\n+        setsockopt(self.fd, libc::IPPROTO_IP, libc::IP_TTL, ttl as libc::c_int)\n+    }\n+\n+    fn hear_broadcasts(&mut self) -> IoResult<()> {\n+        self.set_broadcast(true)\n+    }\n+    fn ignore_broadcasts(&mut self) -> IoResult<()> {\n+        self.set_broadcast(false)\n+    }\n+}\n+\n+impl Drop for UdpSocket {\n+    fn drop(&mut self) { unsafe { close(self.fd) } }\n+}"}, {"sha": "b4f79b285b777c4211008f7d6f859c4439e6460f", "filename": "src/libstd/io/net/udp.rs", "status": "modified", "additions": 25, "deletions": 23, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/bba78a2a89d5fae34e22d7a3173d90dffff816f4/src%2Flibstd%2Fio%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bba78a2a89d5fae34e22d7a3173d90dffff816f4/src%2Flibstd%2Fio%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Fudp.rs?ref=bba78a2a89d5fae34e22d7a3173d90dffff816f4", "patch": "@@ -104,25 +104,24 @@ mod test {\n     use io::test::*;\n     use prelude::*;\n \n-    #[test]  #[ignore]\n-    fn bind_error() {\n+    iotest!(fn bind_error() {\n         let mut called = false;\n         io_error::cond.trap(|e| {\n-            assert!(e.kind == PermissionDenied);\n+            assert_eq!(e.kind, PermissionDenied);\n             called = true;\n         }).inside(|| {\n             let addr = SocketAddr { ip: Ipv4Addr(0, 0, 0, 0), port: 1 };\n             let socket = UdpSocket::bind(addr);\n             assert!(socket.is_none());\n         });\n         assert!(called);\n-    }\n+    } #[ignore(cfg(windows))])\n \n-    #[test]\n-    fn socket_smoke_test_ip4() {\n+    iotest!(fn socket_smoke_test_ip4() {\n         let server_ip = next_test_ip4();\n         let client_ip = next_test_ip4();\n         let (port, chan) = Chan::new();\n+        let (port2, chan2) = Chan::new();\n \n         do spawn {\n             match UdpSocket::bind(client_ip) {\n@@ -132,6 +131,7 @@ mod test {\n                 }\n                 None => fail!()\n             }\n+            chan2.send(());\n         }\n \n         match UdpSocket::bind(server_ip) {\n@@ -149,10 +149,10 @@ mod test {\n             }\n             None => fail!()\n         }\n-    }\n+        port2.recv();\n+    })\n \n-    #[test]\n-    fn socket_smoke_test_ip6() {\n+    iotest!(fn socket_smoke_test_ip6() {\n         let server_ip = next_test_ip6();\n         let client_ip = next_test_ip6();\n         let (port, chan) = Chan::<()>::new();\n@@ -182,13 +182,13 @@ mod test {\n             }\n             None => fail!()\n         }\n-    }\n+    })\n \n-    #[test]\n-    fn stream_smoke_test_ip4() {\n+    iotest!(fn stream_smoke_test_ip4() {\n         let server_ip = next_test_ip4();\n         let client_ip = next_test_ip4();\n         let (port, chan) = Chan::new();\n+        let (port2, chan2) = Chan::new();\n \n         do spawn {\n             match UdpSocket::bind(client_ip) {\n@@ -200,6 +200,7 @@ mod test {\n                 }\n                 None => fail!()\n             }\n+            chan2.send(());\n         }\n \n         match UdpSocket::bind(server_ip) {\n@@ -218,13 +219,14 @@ mod test {\n             }\n             None => fail!()\n         }\n-    }\n+        port2.recv();\n+    })\n \n-    #[test]\n-    fn stream_smoke_test_ip6() {\n+    iotest!(fn stream_smoke_test_ip6() {\n         let server_ip = next_test_ip6();\n         let client_ip = next_test_ip6();\n         let (port, chan) = Chan::new();\n+        let (port2, chan2) = Chan::new();\n \n         do spawn {\n             match UdpSocket::bind(client_ip) {\n@@ -236,6 +238,7 @@ mod test {\n                 }\n                 None => fail!()\n             }\n+            chan2.send(());\n         }\n \n         match UdpSocket::bind(server_ip) {\n@@ -254,9 +257,10 @@ mod test {\n             }\n             None => fail!()\n         }\n-    }\n+        port2.recv();\n+    })\n \n-    fn socket_name(addr: SocketAddr) {\n+    pub fn socket_name(addr: SocketAddr) {\n         let server = UdpSocket::bind(addr);\n \n         assert!(server.is_some());\n@@ -269,13 +273,11 @@ mod test {\n         assert_eq!(addr, so_name.unwrap());\n     }\n \n-    #[test]\n-    fn socket_name_ip4() {\n+    iotest!(fn socket_name_ip4() {\n         socket_name(next_test_ip4());\n-    }\n+    })\n \n-    #[test]\n-    fn socket_name_ip6() {\n+    iotest!(fn socket_name_ip6() {\n         socket_name(next_test_ip6());\n-    }\n+    })\n }"}, {"sha": "c6066a915156b9f0928a67e4cfe702692e587a53", "filename": "src/libstd/libc.rs", "status": "modified", "additions": 90, "deletions": 1, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/bba78a2a89d5fae34e22d7a3173d90dffff816f4/src%2Flibstd%2Flibc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bba78a2a89d5fae34e22d7a3173d90dffff816f4/src%2Flibstd%2Flibc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flibc.rs?ref=bba78a2a89d5fae34e22d7a3173d90dffff816f4", "patch": "@@ -243,6 +243,8 @@ pub mod types {\n                 }\n             }\n             pub mod bsd44 {\n+                use libc::types::os::arch::c95::c_uint;\n+\n                 pub type socklen_t = u32;\n                 pub type sa_family_t = u16;\n                 pub type in_port_t = u16;\n@@ -275,6 +277,14 @@ pub mod types {\n                 pub struct in6_addr {\n                     s6_addr: [u16, ..8]\n                 }\n+                pub struct ip_mreq {\n+                    imr_multiaddr: in_addr,\n+                    imr_interface: in_addr,\n+                }\n+                pub struct ip6_mreq {\n+                    ipv6mr_multiaddr: in6_addr,\n+                    ipv6mr_interface: c_uint,\n+                }\n             }\n         }\n \n@@ -575,6 +585,8 @@ pub mod types {\n                 }\n             }\n             pub mod bsd44 {\n+                use libc::types::os::arch::c95::c_uint;\n+\n                 pub type socklen_t = u32;\n                 pub type sa_family_t = u8;\n                 pub type in_port_t = u16;\n@@ -612,6 +624,14 @@ pub mod types {\n                 pub struct in6_addr {\n                     s6_addr: [u16, ..8]\n                 }\n+                pub struct ip_mreq {\n+                    imr_multiaddr: in_addr,\n+                    imr_interface: in_addr,\n+                }\n+                pub struct ip6_mreq {\n+                    ipv6mr_multiaddr: in6_addr,\n+                    ipv6mr_interface: c_uint,\n+                }\n             }\n         }\n \n@@ -773,6 +793,14 @@ pub mod types {\n                 pub struct in6_addr {\n                     s6_addr: [u16, ..8]\n                 }\n+                pub struct ip_mreq {\n+                    imr_multiaddr: in_addr,\n+                    imr_interface: in_addr,\n+                }\n+                pub struct ip6_mreq {\n+                    ipv6mr_multiaddr: in6_addr,\n+                    ipv6mr_interface: c_uint,\n+                }\n             }\n         }\n \n@@ -1015,7 +1043,7 @@ pub mod types {\n             }\n \n             pub mod bsd44 {\n-                use libc::types::os::arch::c95::c_int;\n+                use libc::types::os::arch::c95::{c_int, c_uint};\n \n                 pub type socklen_t = c_int;\n                 pub type sa_family_t = u8;\n@@ -1054,6 +1082,14 @@ pub mod types {\n                 pub struct in6_addr {\n                     s6_addr: [u16, ..8]\n                 }\n+                pub struct ip_mreq {\n+                    imr_multiaddr: in_addr,\n+                    imr_interface: in_addr,\n+                }\n+                pub struct ip6_mreq {\n+                    ipv6mr_multiaddr: in6_addr,\n+                    ipv6mr_interface: c_uint,\n+                }\n             }\n         }\n \n@@ -1364,10 +1400,20 @@ pub mod consts {\n             pub static SOCK_STREAM: c_int = 1;\n             pub static SOCK_DGRAM: c_int = 2;\n             pub static IPPROTO_TCP: c_int = 6;\n+            pub static IPPROTO_IP: c_int = 0;\n+            pub static IPPROTO_IPV6: c_int = 41;\n+            pub static IP_MULTICAST_TTL: c_int = 3;\n+            pub static IP_MULTICAST_LOOP: c_int = 4;\n+            pub static IP_ADD_MEMBERSHIP: c_int = 5;\n+            pub static IP_DROP_MEMBERSHIP: c_int = 6;\n+            pub static IPV6_ADD_MEMBERSHIP: c_int = 5;\n+            pub static IPV6_DROP_MEMBERSHIP: c_int = 6;\n+            pub static IP_TTL: c_int = 4;\n \n             pub static TCP_NODELAY: c_int = 0x0001;\n             pub static SOL_SOCKET: c_int = 0xffff;\n             pub static SO_KEEPALIVE: c_int = 8;\n+            pub static SO_BROADCAST: c_int = 32;\n         }\n         pub mod extra {\n             use libc::types::os::arch::c95::c_int;\n@@ -2070,10 +2116,20 @@ pub mod consts {\n             pub static SOCK_STREAM: c_int = 1;\n             pub static SOCK_DGRAM: c_int = 2;\n             pub static IPPROTO_TCP: c_int = 6;\n+            pub static IPPROTO_IP: c_int = 0;\n+            pub static IPPROTO_IPV6: c_int = 41;\n+            pub static IP_MULTICAST_TTL: c_int = 33;\n+            pub static IP_MULTICAST_LOOP: c_int = 34;\n+            pub static IP_TTL: c_int = 2;\n+            pub static IP_ADD_MEMBERSHIP: c_int = 35;\n+            pub static IP_DROP_MEMBERSHIP: c_int = 36;\n+            pub static IPV6_ADD_MEMBERSHIP: c_int = 20;\n+            pub static IPV6_DROP_MEMBERSHIP: c_int = 21;\n \n             pub static TCP_NODELAY: c_int = 1;\n             pub static SOL_SOCKET: c_int = 1;\n             pub static SO_KEEPALIVE: c_int = 9;\n+            pub static SO_BROADCAST: c_int = 6;\n         }\n         #[cfg(target_arch = \"x86\")]\n         #[cfg(target_arch = \"x86_64\")]\n@@ -2497,11 +2553,21 @@ pub mod consts {\n             pub static SOCK_STREAM: c_int = 1;\n             pub static SOCK_DGRAM: c_int = 2;\n             pub static IPPROTO_TCP: c_int = 6;\n+            pub static IPPROTO_IP: c_int = 0;\n+            pub static IPPROTO_IPV6: c_int = 41;\n+            pub static IP_MULTICAST_TTL: c_int = 10;\n+            pub static IP_MULTICAST_LOOP: c_int = 11;\n+            pub static IP_TTL: c_int = 4;\n+            pub static IP_ADD_MEMBERSHIP: c_int = 12;\n+            pub static IP_DROP_MEMBERSHIP: c_int = 13;\n+            pub static IPV6_ADD_MEMBERSHIP: c_int = 12;\n+            pub static IPV6_DROP_MEMBERSHIP: c_int = 13;\n \n             pub static TCP_NODELAY: c_int = 1;\n             pub static TCP_KEEPIDLE: c_int = 256;\n             pub static SOL_SOCKET: c_int = 0xffff;\n             pub static SO_KEEPALIVE: c_int = 0x0008;\n+            pub static SO_BROADCAST: c_int = 0x0020;\n         }\n         pub mod extra {\n             use libc::types::os::arch::c95::c_int;\n@@ -2862,11 +2928,21 @@ pub mod consts {\n             pub static SOCK_STREAM: c_int = 1;\n             pub static SOCK_DGRAM: c_int = 2;\n             pub static IPPROTO_TCP: c_int = 6;\n+            pub static IPPROTO_IP: c_int = 0;\n+            pub static IPPROTO_IPV6: c_int = 41;\n+            pub static IP_MULTICAST_TTL: c_int = 10;\n+            pub static IP_MULTICAST_LOOP: c_int = 11;\n+            pub static IP_TTL: c_int = 4;\n+            pub static IP_ADD_MEMBERSHIP: c_int = 12;\n+            pub static IP_DROP_MEMBERSHIP: c_int = 13;\n+            pub static IPV6_ADD_MEMBERSHIP: c_int = 12;\n+            pub static IPV6_DROP_MEMBERSHIP: c_int = 13;\n \n             pub static TCP_NODELAY: c_int = 0x01;\n             pub static TCP_KEEPALIVE: c_int = 0x10;\n             pub static SOL_SOCKET: c_int = 0xffff;\n             pub static SO_KEEPALIVE: c_int = 0x0008;\n+            pub static SO_BROADCAST: c_int = 0x0020;\n         }\n         pub mod extra {\n             use libc::types::os::arch::c95::c_int;\n@@ -3573,6 +3649,12 @@ pub mod funcs {\n                         flags: c_int) -> ssize_t;\n             pub fn send(socket: c_int, buf: *mut c_void, len: size_t,\n                         flags: c_int) -> ssize_t;\n+            pub fn recvfrom(socket: c_int, buf: *mut c_void, len: size_t,\n+                            flags: c_int, addr: *mut sockaddr,\n+                            addrlen: *mut socklen_t) -> ssize_t;\n+            pub fn sendto(socket: c_int, buf: *c_void, len: size_t,\n+                          flags: c_int, addr: *sockaddr,\n+                          addrlen: socklen_t) -> ssize_t;\n         }\n     }\n \n@@ -3581,6 +3663,7 @@ pub mod funcs {\n         use libc::types::common::c95::{c_void};\n         use libc::types::os::common::bsd44::{socklen_t, sockaddr, SOCKET};\n         use libc::types::os::arch::c95::c_int;\n+        use libc::types::os::arch::posix88::ssize_t;\n \n         extern \"system\" {\n             pub fn socket(domain: c_int, ty: c_int, protocol: c_int) -> SOCKET;\n@@ -3602,6 +3685,12 @@ pub mod funcs {\n                         flags: c_int) -> c_int;\n             pub fn send(socket: SOCKET, buf: *mut c_void, len: c_int,\n                         flags: c_int) -> c_int;\n+            pub fn recvfrom(socket: SOCKET, buf: *mut c_void, len: c_int,\n+                            flags: c_int, addr: *mut sockaddr,\n+                            addrlen: *mut c_int) -> ssize_t;\n+            pub fn sendto(socket: SOCKET, buf: *c_void, len: c_int,\n+                          flags: c_int, addr: *sockaddr,\n+                          addrlen: c_int) -> c_int;\n         }\n     }\n "}]}