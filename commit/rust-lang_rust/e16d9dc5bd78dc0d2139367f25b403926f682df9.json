{"sha": "e16d9dc5bd78dc0d2139367f25b403926f682df9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUxNmQ5ZGM1YmQ3OGRjMGQyMTM5MzY3ZjI1YjQwMzkyNmY2ODJkZjk=", "commit": {"author": {"name": "Jonas Schievink", "email": "jonasschievink@gmail.com", "date": "2021-02-09T16:27:04Z"}, "committer": {"name": "Jonas Schievink", "email": "jonasschievink@gmail.com", "date": "2021-02-09T16:27:04Z"}, "message": "Use `block_def_map` in `Resolver`\n\nThis required a few changes to not bail out immediately if a\n`ModuleScope` doesn't resolve a path.\n\nThe `LocalItemsScope` hack is now removed.", "tree": {"sha": "83bccff0dce8543fd7035ce96ff57ba49220fe21", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/83bccff0dce8543fd7035ce96ff57ba49220fe21"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e16d9dc5bd78dc0d2139367f25b403926f682df9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e16d9dc5bd78dc0d2139367f25b403926f682df9", "html_url": "https://github.com/rust-lang/rust/commit/e16d9dc5bd78dc0d2139367f25b403926f682df9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e16d9dc5bd78dc0d2139367f25b403926f682df9/comments", "author": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "34ad3d629a75c8bbc419c0159c213901ce8ad28d", "url": "https://api.github.com/repos/rust-lang/rust/commits/34ad3d629a75c8bbc419c0159c213901ce8ad28d", "html_url": "https://github.com/rust-lang/rust/commit/34ad3d629a75c8bbc419c0159c213901ce8ad28d"}], "stats": {"total": 215, "additions": 97, "deletions": 118}, "files": [{"sha": "e293aa425384e4410da61174ee74959b6dd6953f", "filename": "crates/hir_def/src/resolver.rs", "status": "modified", "additions": 97, "deletions": 118, "changes": 215, "blob_url": "https://github.com/rust-lang/rust/blob/e16d9dc5bd78dc0d2139367f25b403926f682df9/crates%2Fhir_def%2Fsrc%2Fresolver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e16d9dc5bd78dc0d2139367f25b403926f682df9/crates%2Fhir_def%2Fsrc%2Fresolver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fresolver.rs?ref=e16d9dc5bd78dc0d2139367f25b403926f682df9", "patch": "@@ -10,7 +10,6 @@ use rustc_hash::FxHashSet;\n \n use crate::{\n     body::scope::{ExprScopes, ScopeId},\n-    body::Body,\n     builtin_type::BuiltinType,\n     db::DefDatabase,\n     expr::{ExprId, PatId},\n@@ -58,8 +57,6 @@ enum Scope {\n     AdtScope(AdtId),\n     /// Local bindings\n     ExprScope(ExprScope),\n-    /// Temporary hack to support local items.\n-    LocalItemsScope(Arc<Body>),\n }\n \n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -169,13 +166,7 @@ impl Resolver {\n         for scope in self.scopes.iter().rev() {\n             match scope {\n                 Scope::ExprScope(_) => continue,\n-                Scope::GenericParams { .. }\n-                | Scope::ImplDefScope(_)\n-                | Scope::LocalItemsScope(_)\n-                    if skip_to_mod =>\n-                {\n-                    continue\n-                }\n+                Scope::GenericParams { .. } | Scope::ImplDefScope(_) if skip_to_mod => continue,\n \n                 Scope::GenericParams { params, def } => {\n                     if let Some(local_id) = params.find_type_by_name(first_name) {\n@@ -199,41 +190,13 @@ impl Resolver {\n                     }\n                 }\n                 Scope::ModuleScope(m) => {\n-                    let (module_def, idx) = m.crate_def_map.resolve_path(\n-                        db,\n-                        m.module_id,\n-                        &path,\n-                        BuiltinShadowMode::Other,\n-                    );\n-                    let res = to_type_ns(module_def)?;\n-                    return Some((res, idx));\n-                }\n-                Scope::LocalItemsScope(body) => {\n-                    let def = body.item_scope.get(first_name);\n-                    if let Some(res) = to_type_ns(def) {\n-                        return Some((res, None));\n+                    if let Some(res) = m.resolve_path_in_type_ns(db, path) {\n+                        return Some(res);\n                     }\n                 }\n             }\n         }\n-        return None;\n-        fn to_type_ns(per_ns: PerNs) -> Option<TypeNs> {\n-            let res = match per_ns.take_types()? {\n-                ModuleDefId::AdtId(it) => TypeNs::AdtId(it),\n-                ModuleDefId::EnumVariantId(it) => TypeNs::EnumVariantId(it),\n-\n-                ModuleDefId::TypeAliasId(it) => TypeNs::TypeAliasId(it),\n-                ModuleDefId::BuiltinType(it) => TypeNs::BuiltinType(it),\n-\n-                ModuleDefId::TraitId(it) => TypeNs::TraitId(it),\n-\n-                ModuleDefId::FunctionId(_)\n-                | ModuleDefId::ConstId(_)\n-                | ModuleDefId::StaticId(_)\n-                | ModuleDefId::ModuleId(_) => return None,\n-            };\n-            Some(res)\n-        }\n+        None\n     }\n \n     pub fn resolve_path_in_type_ns_fully(\n@@ -280,7 +243,6 @@ impl Resolver {\n                 | Scope::ExprScope(_)\n                 | Scope::GenericParams { .. }\n                 | Scope::ImplDefScope(_)\n-                | Scope::LocalItemsScope(_)\n                     if skip_to_mod =>\n                 {\n                     continue\n@@ -335,63 +297,14 @@ impl Resolver {\n                 }\n \n                 Scope::ModuleScope(m) => {\n-                    let (module_def, idx) = m.crate_def_map.resolve_path(\n-                        db,\n-                        m.module_id,\n-                        &path,\n-                        BuiltinShadowMode::Other,\n-                    );\n-                    return match idx {\n-                        None => {\n-                            let value = to_value_ns(module_def)?;\n-                            Some(ResolveValueResult::ValueNs(value))\n-                        }\n-                        Some(idx) => {\n-                            let ty = match module_def.take_types()? {\n-                                ModuleDefId::AdtId(it) => TypeNs::AdtId(it),\n-                                ModuleDefId::TraitId(it) => TypeNs::TraitId(it),\n-                                ModuleDefId::TypeAliasId(it) => TypeNs::TypeAliasId(it),\n-                                ModuleDefId::BuiltinType(it) => TypeNs::BuiltinType(it),\n-\n-                                ModuleDefId::ModuleId(_)\n-                                | ModuleDefId::FunctionId(_)\n-                                | ModuleDefId::EnumVariantId(_)\n-                                | ModuleDefId::ConstId(_)\n-                                | ModuleDefId::StaticId(_) => return None,\n-                            };\n-                            Some(ResolveValueResult::Partial(ty, idx))\n-                        }\n-                    };\n-                }\n-                Scope::LocalItemsScope(body) => {\n-                    // we don't bother looking in the builtin scope here because there are no builtin values\n-                    let def = to_value_ns(body.item_scope.get(first_name));\n-\n-                    if let Some(res) = def {\n-                        return Some(ResolveValueResult::ValueNs(res));\n+                    if let Some(def) = m.resolve_path_in_value_ns(db, path) {\n+                        return Some(def);\n                     }\n                 }\n             }\n         }\n-        return None;\n-\n-        fn to_value_ns(per_ns: PerNs) -> Option<ValueNs> {\n-            let res = match per_ns.take_values()? {\n-                ModuleDefId::FunctionId(it) => ValueNs::FunctionId(it),\n-                ModuleDefId::AdtId(AdtId::StructId(it)) => ValueNs::StructId(it),\n-                ModuleDefId::EnumVariantId(it) => ValueNs::EnumVariantId(it),\n-                ModuleDefId::ConstId(it) => ValueNs::ConstId(it),\n-                ModuleDefId::StaticId(it) => ValueNs::StaticId(it),\n-\n-                ModuleDefId::AdtId(AdtId::EnumId(_))\n-                | ModuleDefId::AdtId(AdtId::UnionId(_))\n-                | ModuleDefId::TraitId(_)\n-                | ModuleDefId::TypeAliasId(_)\n-                | ModuleDefId::BuiltinType(_)\n-                | ModuleDefId::ModuleId(_) => return None,\n-            };\n-            Some(res)\n-        }\n+\n+        None\n     }\n \n     pub fn resolve_path_in_value_ns_fully(\n@@ -410,11 +323,6 @@ impl Resolver {\n         db: &dyn DefDatabase,\n         path: &ModPath,\n     ) -> Option<MacroDefId> {\n-        // Search item scope legacy macro first\n-        if let Some(def) = self.resolve_local_macro_def(path) {\n-            return Some(def);\n-        }\n-\n         let (item_map, module) = self.module_scope()?;\n         item_map.resolve_path(db, module, &path, BuiltinShadowMode::Other).0.take_macros()\n     }\n@@ -447,16 +355,6 @@ impl Resolver {\n         })\n     }\n \n-    fn resolve_local_macro_def(&self, path: &ModPath) -> Option<MacroDefId> {\n-        let name = path.as_ident()?;\n-        self.scopes.iter().rev().find_map(|scope| {\n-            if let Scope::LocalItemsScope(body) = scope {\n-                return body.item_scope.get_legacy_macro(name);\n-            }\n-            None\n-        })\n-    }\n-\n     pub fn module(&self) -> Option<ModuleId> {\n         let (def_map, local_id) = self.module_scope()?;\n         Some(def_map.module_id(local_id))\n@@ -538,9 +436,6 @@ impl Scope {\n                     });\n                 }\n             }\n-            Scope::LocalItemsScope(body) => body.item_scope.entries().for_each(|(name, def)| {\n-                f(name.clone(), ScopeDef::PerNs(def));\n-            }),\n             &Scope::GenericParams { ref params, def: parent } => {\n                 for (local_id, param) in params.types.iter() {\n                     if let Some(ref name) = param.name {\n@@ -584,10 +479,19 @@ pub fn resolver_for_scope(\n     scope_id: Option<ScopeId>,\n ) -> Resolver {\n     let mut r = owner.resolver(db);\n-    r = r.push_local_items_scope(db.body(owner));\n     let scopes = db.expr_scopes(owner);\n     let scope_chain = scopes.scope_chain(scope_id).collect::<Vec<_>>();\n     for scope in scope_chain.into_iter().rev() {\n+        if let Some(block) = scopes.block(scope) {\n+            if let Some(def_map) = db.block_def_map(block) {\n+                let root = def_map.root();\n+                r = r.push_module_scope(def_map, root);\n+                // FIXME: This adds as many module scopes as there are blocks, but resolving in each\n+                // already traverses all parents, so this is O(n\u00b2). I think we could only store the\n+                // innermost module scope instead?\n+            }\n+        }\n+\n         r = r.push_expr_scope(owner, Arc::clone(&scopes), scope);\n     }\n     r\n@@ -612,10 +516,6 @@ impl Resolver {\n         self.push_scope(Scope::ModuleScope(ModuleItemMap { crate_def_map, module_id }))\n     }\n \n-    fn push_local_items_scope(self, body: Arc<Body>) -> Resolver {\n-        self.push_scope(Scope::LocalItemsScope(body))\n-    }\n-\n     fn push_expr_scope(\n         self,\n         owner: DefWithBodyId,\n@@ -626,6 +526,85 @@ impl Resolver {\n     }\n }\n \n+impl ModuleItemMap {\n+    pub fn resolve_path_in_value_ns(\n+        &self,\n+        db: &dyn DefDatabase,\n+        path: &ModPath,\n+    ) -> Option<ResolveValueResult> {\n+        let (module_def, idx) =\n+            self.crate_def_map.resolve_path(db, self.module_id, &path, BuiltinShadowMode::Other);\n+        return match idx {\n+            None => {\n+                let value = to_value_ns(module_def)?;\n+                Some(ResolveValueResult::ValueNs(value))\n+            }\n+            Some(idx) => {\n+                let ty = match module_def.take_types()? {\n+                    ModuleDefId::AdtId(it) => TypeNs::AdtId(it),\n+                    ModuleDefId::TraitId(it) => TypeNs::TraitId(it),\n+                    ModuleDefId::TypeAliasId(it) => TypeNs::TypeAliasId(it),\n+                    ModuleDefId::BuiltinType(it) => TypeNs::BuiltinType(it),\n+\n+                    ModuleDefId::ModuleId(_)\n+                    | ModuleDefId::FunctionId(_)\n+                    | ModuleDefId::EnumVariantId(_)\n+                    | ModuleDefId::ConstId(_)\n+                    | ModuleDefId::StaticId(_) => return None,\n+                };\n+                Some(ResolveValueResult::Partial(ty, idx))\n+            }\n+        };\n+    }\n+\n+    pub fn resolve_path_in_type_ns(\n+        &self,\n+        db: &dyn DefDatabase,\n+        path: &ModPath,\n+    ) -> Option<(TypeNs, Option<usize>)> {\n+        let (module_def, idx) =\n+            self.crate_def_map.resolve_path(db, self.module_id, &path, BuiltinShadowMode::Other);\n+        let res = to_type_ns(module_def)?;\n+        Some((res, idx))\n+    }\n+}\n+\n+fn to_value_ns(per_ns: PerNs) -> Option<ValueNs> {\n+    let res = match per_ns.take_values()? {\n+        ModuleDefId::FunctionId(it) => ValueNs::FunctionId(it),\n+        ModuleDefId::AdtId(AdtId::StructId(it)) => ValueNs::StructId(it),\n+        ModuleDefId::EnumVariantId(it) => ValueNs::EnumVariantId(it),\n+        ModuleDefId::ConstId(it) => ValueNs::ConstId(it),\n+        ModuleDefId::StaticId(it) => ValueNs::StaticId(it),\n+\n+        ModuleDefId::AdtId(AdtId::EnumId(_))\n+        | ModuleDefId::AdtId(AdtId::UnionId(_))\n+        | ModuleDefId::TraitId(_)\n+        | ModuleDefId::TypeAliasId(_)\n+        | ModuleDefId::BuiltinType(_)\n+        | ModuleDefId::ModuleId(_) => return None,\n+    };\n+    Some(res)\n+}\n+\n+fn to_type_ns(per_ns: PerNs) -> Option<TypeNs> {\n+    let res = match per_ns.take_types()? {\n+        ModuleDefId::AdtId(it) => TypeNs::AdtId(it),\n+        ModuleDefId::EnumVariantId(it) => TypeNs::EnumVariantId(it),\n+\n+        ModuleDefId::TypeAliasId(it) => TypeNs::TypeAliasId(it),\n+        ModuleDefId::BuiltinType(it) => TypeNs::BuiltinType(it),\n+\n+        ModuleDefId::TraitId(it) => TypeNs::TraitId(it),\n+\n+        ModuleDefId::FunctionId(_)\n+        | ModuleDefId::ConstId(_)\n+        | ModuleDefId::StaticId(_)\n+        | ModuleDefId::ModuleId(_) => return None,\n+    };\n+    Some(res)\n+}\n+\n pub trait HasResolver: Copy {\n     /// Builds a resolver for type references inside this def.\n     fn resolver(self, db: &dyn DefDatabase) -> Resolver;"}]}