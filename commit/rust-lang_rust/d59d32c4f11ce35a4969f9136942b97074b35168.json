{"sha": "d59d32c4f11ce35a4969f9136942b97074b35168", "node_id": "C_kwDOAAsO6NoAKGQ1OWQzMmM0ZjExY2UzNWE0OTY5ZjkxMzY5NDJiOTcwNzRiMzUxNjg", "commit": {"author": {"name": "Chris Denton", "email": "christophersdenton@gmail.com", "date": "2021-12-08T18:48:17Z"}, "committer": {"name": "Chris Denton", "email": "christophersdenton@gmail.com", "date": "2022-02-08T14:57:34Z"}, "message": "`std::path::absolute`", "tree": {"sha": "1c27f68ec9a10ecd8c74f7627e142cb3f7a013e6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1c27f68ec9a10ecd8c74f7627e142cb3f7a013e6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d59d32c4f11ce35a4969f9136942b97074b35168", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEE+p/jD6jrzmnSIWJLcTRy8vRWJ94FAmIChN8ACgkQcTRy8vRW\nJ95ZPg/6Ao7hPzMdCwTkg5HffTFHaKNMKVmOHnUaoUn5ivcoA045/1BSW2tKM5X0\nkdBHVJoJ1whB2XGxcrOpIw0dDZSvqVrBNYW/jreSHL2l8rSrRVhFA7YzRV/GPTbI\nzsKHqDA5iYa2VPJ7v8WLsVJHKyj6nMa7meJKI2qxCSJr/oSa4sWDncMaBTPDBLhY\nEbi1AmhtH/c/My88efjt9Cuv7MtyGd1AA3sqwgXV1aLPyi03x0AF9gDh9je+bvdA\nJCSiN9cX2HPgcRmpETuIerbCO22MlhzdfOIbe8kHyl8q1HWgRWJFjCvv0M5kjCiq\n+O1RBf8HSJb9/V99VbiDfU7G9/reLpDDfRvWIlPv9y9XyskCcTIJ/pkoHcvZHhWj\n9BISX06X3m6Bu9cB1VmMqOnhTpLMVkEImQCZPyI5WTSQrjNXtUPtXIYxDZRXU4Md\n6byRWF1Pjp6TvUcentm8JJzXbwvZ8+VAkDn2Kl3ybRaGwTsrlBA5GLN27h8S5Q1k\nK+NlF/y6XNXrJaFYsI+bCPS+ZqrSTcdFzHyCR7d/i+nMLRryYVI1SCl6nriGnhuz\nQaSWxBXqS0pT8js88150kXtXvBQSL+EXfJJb1wHxJ3D315Zg8lBOUboKp7tJq3tR\nNIzm4P49gPyW37AQjBlDR0a/NE9pfacgSybV4c1ej1asmNM4Zm4=\n=CQV+\n-----END PGP SIGNATURE-----", "payload": "tree 1c27f68ec9a10ecd8c74f7627e142cb3f7a013e6\nparent 775e480722c7aba6ff4ff3ccec8c1f4639ae7889\nauthor Chris Denton <christophersdenton@gmail.com> 1638989297 +0000\ncommitter Chris Denton <christophersdenton@gmail.com> 1644332254 +0000\n\n`std::path::absolute`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d59d32c4f11ce35a4969f9136942b97074b35168", "html_url": "https://github.com/rust-lang/rust/commit/d59d32c4f11ce35a4969f9136942b97074b35168", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d59d32c4f11ce35a4969f9136942b97074b35168/comments", "author": {"login": "ChrisDenton", "id": 4459874, "node_id": "MDQ6VXNlcjQ0NTk4NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4459874?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ChrisDenton", "html_url": "https://github.com/ChrisDenton", "followers_url": "https://api.github.com/users/ChrisDenton/followers", "following_url": "https://api.github.com/users/ChrisDenton/following{/other_user}", "gists_url": "https://api.github.com/users/ChrisDenton/gists{/gist_id}", "starred_url": "https://api.github.com/users/ChrisDenton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ChrisDenton/subscriptions", "organizations_url": "https://api.github.com/users/ChrisDenton/orgs", "repos_url": "https://api.github.com/users/ChrisDenton/repos", "events_url": "https://api.github.com/users/ChrisDenton/events{/privacy}", "received_events_url": "https://api.github.com/users/ChrisDenton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ChrisDenton", "id": 4459874, "node_id": "MDQ6VXNlcjQ0NTk4NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4459874?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ChrisDenton", "html_url": "https://github.com/ChrisDenton", "followers_url": "https://api.github.com/users/ChrisDenton/followers", "following_url": "https://api.github.com/users/ChrisDenton/following{/other_user}", "gists_url": "https://api.github.com/users/ChrisDenton/gists{/gist_id}", "starred_url": "https://api.github.com/users/ChrisDenton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ChrisDenton/subscriptions", "organizations_url": "https://api.github.com/users/ChrisDenton/orgs", "repos_url": "https://api.github.com/users/ChrisDenton/repos", "events_url": "https://api.github.com/users/ChrisDenton/events{/privacy}", "received_events_url": "https://api.github.com/users/ChrisDenton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "775e480722c7aba6ff4ff3ccec8c1f4639ae7889", "url": "https://api.github.com/repos/rust-lang/rust/commits/775e480722c7aba6ff4ff3ccec8c1f4639ae7889", "html_url": "https://github.com/rust-lang/rust/commit/775e480722c7aba6ff4ff3ccec8c1f4639ae7889"}], "stats": {"total": 212, "additions": 208, "deletions": 4}, "files": [{"sha": "f93d64bf5d31ea88b072805df617d286750e4769", "filename": "library/std/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d59d32c4f11ce35a4969f9136942b97074b35168/library%2Fstd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d59d32c4f11ce35a4969f9136942b97074b35168/library%2Fstd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Flib.rs?ref=d59d32c4f11ce35a4969f9136942b97074b35168", "patch": "@@ -222,6 +222,7 @@\n // std is implemented with unstable features, many of which are internal\n // compiler details that will never be stable\n // NB: the following list is sorted to minimize merge conflicts.\n+#![feature(absolute_path)]\n #![feature(alloc_error_handler)]\n #![feature(alloc_layout_extra)]\n #![feature(allocator_api)]"}, {"sha": "dc5922c53bac0b1948fed5d8bd66806793d46720", "filename": "library/std/src/path.rs", "status": "modified", "additions": 77, "deletions": 1, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/d59d32c4f11ce35a4969f9136942b97074b35168/library%2Fstd%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d59d32c4f11ce35a4969f9136942b97074b35168/library%2Fstd%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fpath.rs?ref=d59d32c4f11ce35a4969f9136942b97074b35168", "patch": "@@ -85,7 +85,7 @@ use crate::str::FromStr;\n use crate::sync::Arc;\n \n use crate::ffi::{OsStr, OsString};\n-\n+use crate::sys;\n use crate::sys::path::{is_sep_byte, is_verbatim_sep, parse_prefix, MAIN_SEP_STR};\n \n ////////////////////////////////////////////////////////////////////////////////\n@@ -3164,3 +3164,79 @@ impl Error for StripPrefixError {\n         \"prefix not found\"\n     }\n }\n+\n+/// Makes the path absolute without accessing the filesystem.\n+///\n+/// If the path is relative, the current directory is used as the base directory.\n+/// All intermediate components will be resolved according to platforms-specific\n+/// rules but unlike [`canonicalize`][crate::fs::canonicalize] this does not\n+/// resolve symlinks and may succeed even if the path does not exist.\n+///\n+/// If the `path` is empty or getting the\n+/// [current directory][crate::env::current_dir] fails then an error will be\n+/// returned.\n+///\n+/// # Examples\n+///\n+/// ## Posix paths\n+///\n+/// ```\n+/// #![feature(absolute_path)]\n+/// # #[cfg(unix)]\n+/// fn main() -> std::io::Result<()> {\n+///   use std::path::{self, Path};\n+///\n+///   // Relative to absolute\n+///   let absolute = path::absolute(\"foo/./bar\")?;\n+///   assert!(absolute.ends_with(\"foo/bar\"));\n+///\n+///   // Absolute to absolute\n+///   let absolute = path::absolute(\"/foo//test/.././bar.rs\")?;\n+///   assert_eq!(absolute, Path::new(\"/foo/test/../bar.rs\"));\n+///   Ok(())\n+/// }\n+/// # #[cfg(not(unix))]\n+/// # fn main() {}\n+/// ```\n+///\n+/// The paths is resolved using [POSIX semantics][posix-semantics] except that\n+/// it stops short of resolving symlinks. This means it will keep `..`\n+/// components and trailing slashes.\n+///\n+/// ## Windows paths\n+///\n+/// ```\n+/// #![feature(absolute_path)]\n+/// # #[cfg(windows)]\n+/// fn main() -> std::io::Result<()> {\n+///   use std::path::{self, Path};\n+///\n+///   // Relative to absolute\n+///   let absolute = path::absolute(\"foo/./bar\")?;\n+///   assert!(absolute.ends_with(r\"foo\\bar\"));\n+///\n+///   // Absolute to absolute\n+///   let absolute = path::absolute(r\"C:\\foo//test\\..\\./bar.rs\")?;\n+///\n+///   assert_eq!(absolute, Path::new(r\"C:\\foo\\bar.rs\"));\n+///   Ok(())\n+/// }\n+/// # #[cfg(not(windows))]\n+/// # fn main() {}\n+/// ```\n+///\n+/// For verbatim paths this will simply return the path as given. For other\n+/// paths this is currently equivalent to calling [`GetFullPathNameW`][windows-path]\n+/// This may change in the future.\n+///\n+/// [posix-semantics]: https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap04.html#tag_04_13\n+/// [windows-path]: https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-getfullpathnamew\n+#[unstable(feature = \"absolute_path\", issue = \"none\")]\n+pub fn absolute<P: AsRef<Path>>(path: P) -> io::Result<PathBuf> {\n+    let path = path.as_ref();\n+    if path.as_os_str().is_empty() {\n+        Err(io::const_io_error!(io::ErrorKind::InvalidInput, \"cannot make an empty path absolute\",))\n+    } else {\n+        sys::path::absolute(path)\n+    }\n+}"}, {"sha": "cf35254a2e36546659200b97125e8b87f8795551", "filename": "library/std/src/path/tests.rs", "status": "modified", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/d59d32c4f11ce35a4969f9136942b97074b35168/library%2Fstd%2Fsrc%2Fpath%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d59d32c4f11ce35a4969f9136942b97074b35168/library%2Fstd%2Fsrc%2Fpath%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fpath%2Ftests.rs?ref=d59d32c4f11ce35a4969f9136942b97074b35168", "patch": "@@ -1665,6 +1665,64 @@ fn test_ord() {\n     ord!(Equal, \"foo/bar\", \"foo/bar//\");\n }\n \n+#[test]\n+#[cfg(unix)]\n+fn test_unix_absolute() {\n+    use crate::path::absolute;\n+\n+    assert!(absolute(\"\").is_err());\n+\n+    let relative = \"a/b\";\n+    let mut expected = crate::env::current_dir().unwrap();\n+    expected.push(relative);\n+    assert_eq!(absolute(relative).unwrap(), expected);\n+\n+    // Test how components are collected.\n+    assert_eq!(absolute(\"/a/b/c\").unwrap(), Path::new(\"/a/b/c\"));\n+    assert_eq!(absolute(\"/a//b/c\").unwrap(), Path::new(\"/a/b/c\"));\n+    assert_eq!(absolute(\"//a/b/c\").unwrap(), Path::new(\"//a/b/c\"));\n+    assert_eq!(absolute(\"///a/b/c\").unwrap(), Path::new(\"/a/b/c\"));\n+    assert_eq!(absolute(\"/a/b/c/\").unwrap(), Path::new(\"/a/b/c/\"));\n+    assert_eq!(absolute(\"/a/./b/../c/.././..\").unwrap(), Path::new(\"/a/b/../c/../..\"));\n+}\n+\n+#[test]\n+#[cfg(windows)]\n+fn test_windows_absolute() {\n+    use crate::path::absolute;\n+    // An empty path is an error.\n+    assert!(absolute(\"\").is_err());\n+\n+    let relative = r\"a\\b\";\n+    let mut expected = crate::env::current_dir().unwrap();\n+    expected.push(relative);\n+    assert_eq!(absolute(relative).unwrap(), expected);\n+\n+    macro_rules! unchanged(\n+        ($path:expr) => {\n+            assert_eq!(absolute($path).unwrap(), Path::new($path));\n+        }\n+    );\n+\n+    unchanged!(r\"C:\\path\\to\\file\");\n+    unchanged!(r\"C:\\path\\to\\file\\\");\n+    unchanged!(r\"\\\\server\\share\\to\\file\");\n+    unchanged!(r\"\\\\server.\\share.\\to\\file\");\n+    unchanged!(r\"\\\\.\\PIPE\\name\");\n+    unchanged!(r\"\\\\.\\C:\\path\\to\\COM1\");\n+    unchanged!(r\"\\\\?\\C:\\path\\to\\file\");\n+    unchanged!(r\"\\\\?\\UNC\\server\\share\\to\\file\");\n+    unchanged!(r\"\\\\?\\PIPE\\name\");\n+    // Verbatim paths are always unchanged, no matter what.\n+    unchanged!(r\"\\\\?\\path.\\to/file..\");\n+\n+    assert_eq!(absolute(r\"C:\\path..\\to.\\file.\").unwrap(), Path::new(r\"C:\\path..\\to\\file\"));\n+    assert_eq!(absolute(r\"C:\\path\\to\\COM1\").unwrap(), Path::new(r\"\\\\.\\COM1\"));\n+    assert_eq!(absolute(r\"C:\\path\\to\\COM1.txt\").unwrap(), Path::new(r\"\\\\.\\COM1\"));\n+    assert_eq!(absolute(r\"C:\\path\\to\\COM1  .txt\").unwrap(), Path::new(r\"\\\\.\\COM1\"));\n+    assert_eq!(absolute(r\"C:\\path\\to\\cOnOuT$\").unwrap(), Path::new(r\"\\\\.\\cOnOuT$\"));\n+}\n+\n #[bench]\n fn bench_path_cmp_fast_path_buf_sort(b: &mut test::Bencher) {\n     let prefix = \"my/home\";"}, {"sha": "9cfc61bf174fa704cc0bce4d9ed471da07564e7c", "filename": "library/std/src/sys/sgx/path.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d59d32c4f11ce35a4969f9136942b97074b35168/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d59d32c4f11ce35a4969f9136942b97074b35168/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fpath.rs?ref=d59d32c4f11ce35a4969f9136942b97074b35168", "patch": "@@ -1,5 +1,6 @@\n use crate::ffi::OsStr;\n-use crate::path::Prefix;\n+use crate::path::{Path, PathBuf, Prefix};\n+use crate::sys::unsupported;\n \n #[inline]\n pub fn is_sep_byte(b: u8) -> bool {\n@@ -17,3 +18,7 @@ pub fn parse_prefix(_: &OsStr) -> Option<Prefix<'_>> {\n \n pub const MAIN_SEP_STR: &str = \"/\";\n pub const MAIN_SEP: char = '/';\n+\n+pub(crate) fn absolute(_path: &Path) -> io::Result<PathBuf> {\n+    unsupported()\n+}"}, {"sha": "ed532dc989b1f7c8e16ddef3bbd88f07bcb27756", "filename": "library/std/src/sys/solid/path.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d59d32c4f11ce35a4969f9136942b97074b35168/library%2Fstd%2Fsrc%2Fsys%2Fsolid%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d59d32c4f11ce35a4969f9136942b97074b35168/library%2Fstd%2Fsrc%2Fsys%2Fsolid%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsolid%2Fpath.rs?ref=d59d32c4f11ce35a4969f9136942b97074b35168", "patch": "@@ -1,5 +1,6 @@\n use crate::ffi::OsStr;\n-use crate::path::Prefix;\n+use crate::path::{Path, PathBuf, Prefix};\n+use crate::sys::unsupported;\n \n #[inline]\n pub fn is_sep_byte(b: u8) -> bool {\n@@ -17,3 +18,7 @@ pub fn parse_prefix(_: &OsStr) -> Option<Prefix<'_>> {\n \n pub const MAIN_SEP_STR: &str = \"\\\\\";\n pub const MAIN_SEP: char = '\\\\';\n+\n+pub(crate) fn absolute(_path: &Path) -> io::Result<PathBuf> {\n+    unsupported()\n+}"}, {"sha": "1fdabab4598a75045610b7598207d6d611d051a3", "filename": "library/std/src/sys/unix/path.rs", "status": "modified", "additions": 44, "deletions": 1, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/d59d32c4f11ce35a4969f9136942b97074b35168/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d59d32c4f11ce35a4969f9136942b97074b35168/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fpath.rs?ref=d59d32c4f11ce35a4969f9136942b97074b35168", "patch": "@@ -1,5 +1,8 @@\n+use crate::env;\n use crate::ffi::OsStr;\n-use crate::path::Prefix;\n+use crate::io;\n+use crate::os::unix::ffi::OsStrExt;\n+use crate::path::{Path, PathBuf, Prefix};\n \n #[inline]\n pub fn is_sep_byte(b: u8) -> bool {\n@@ -18,3 +21,43 @@ pub fn parse_prefix(_: &OsStr) -> Option<Prefix<'_>> {\n \n pub const MAIN_SEP_STR: &str = \"/\";\n pub const MAIN_SEP: char = '/';\n+\n+/// Make a POSIX path absolute without changing its semantics.\n+pub(crate) fn absolute(path: &Path) -> io::Result<PathBuf> {\n+    // This is mostly a wrapper around collecting `Path::components`, with\n+    // exceptions made where this conflicts with the POSIX specification.\n+    // See 4.13 Pathname Resolution, IEEE Std 1003.1-2017\n+    // https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap04.html#tag_04_13\n+\n+    let mut components = path.components();\n+    let path_os = path.as_os_str().as_bytes();\n+\n+    let mut normalized = if path.is_absolute() {\n+        // \"If a pathname begins with two successive <slash> characters, the\n+        // first component following the leading <slash> characters may be\n+        // interpreted in an implementation-defined manner, although more than\n+        // two leading <slash> characters shall be treated as a single <slash>\n+        // character.\"\n+        if path_os.starts_with(b\"//\") && !path_os.starts_with(b\"///\") {\n+            components.next();\n+            PathBuf::from(\"//\")\n+        } else {\n+            PathBuf::new()\n+        }\n+    } else {\n+        env::current_dir()?\n+    };\n+    normalized.extend(components);\n+\n+    // \"Interfaces using pathname resolution may specify additional constraints\n+    // when a pathname that does not name an existing directory contains at\n+    // least one non- <slash> character and contains one or more trailing\n+    // <slash> characters\".\n+    // A trailing <slash> is also meaningful if \"a symbolic link is\n+    // encountered during pathname resolution\".\n+    if path_os.ends_with(b\"/\") {\n+        normalized.push(\"\");\n+    }\n+\n+    Ok(normalized)\n+}"}, {"sha": "e54fcaed4957d8ab38d440234ed36bd123991209", "filename": "library/std/src/sys/windows/path.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d59d32c4f11ce35a4969f9136942b97074b35168/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d59d32c4f11ce35a4969f9136942b97074b35168/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fpath.rs?ref=d59d32c4f11ce35a4969f9136942b97074b35168", "patch": "@@ -260,3 +260,19 @@ pub(crate) fn maybe_verbatim(path: &Path) -> io::Result<Vec<u16>> {\n     )?;\n     Ok(path)\n }\n+\n+/// Make a Windows path absolute.\n+pub(crate) fn absolute(path: &Path) -> io::Result<PathBuf> {\n+    if path.as_os_str().bytes().starts_with(br\"\\\\?\\\") {\n+        return Ok(path.into());\n+    }\n+    let path = to_u16s(path)?;\n+    let lpfilename = path.as_ptr();\n+    fill_utf16_buf(\n+        // SAFETY: `fill_utf16_buf` ensures the `buffer` and `size` are valid.\n+        // `lpfilename` is a pointer to a null terminated string that is not\n+        // invalidated until after `GetFullPathNameW` returns successfully.\n+        |buffer, size| unsafe { c::GetFullPathNameW(lpfilename, size, buffer, ptr::null_mut()) },\n+        super::os2path,\n+    )\n+}"}]}