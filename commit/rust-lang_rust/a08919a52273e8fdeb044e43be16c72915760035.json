{"sha": "a08919a52273e8fdeb044e43be16c72915760035", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEwODkxOWE1MjI3M2U4ZmRlYjA0NGU0M2JlMTZjNzI5MTU3NjAwMzU=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-09-27T01:16:44Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-09-27T01:17:33Z"}, "message": "libcore: Partially de-export char, f32, f64, and float", "tree": {"sha": "a1b789bfd01c2ef3f0a8239ba5107d64812d1092", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a1b789bfd01c2ef3f0a8239ba5107d64812d1092"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a08919a52273e8fdeb044e43be16c72915760035", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a08919a52273e8fdeb044e43be16c72915760035", "html_url": "https://github.com/rust-lang/rust/commit/a08919a52273e8fdeb044e43be16c72915760035", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a08919a52273e8fdeb044e43be16c72915760035/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dd80cb22e3591267882136d8d5529dc92f049952", "url": "https://api.github.com/repos/rust-lang/rust/commits/dd80cb22e3591267882136d8d5529dc92f049952", "html_url": "https://github.com/rust-lang/rust/commit/dd80cb22e3591267882136d8d5529dc92f049952"}], "stats": {"total": 280, "additions": 136, "deletions": 144}, "files": [{"sha": "057a2b8166b32c6ae710f6a0041c912afef639e6", "filename": "src/libcore/char.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a08919a52273e8fdeb044e43be16c72915760035/src%2Flibcore%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a08919a52273e8fdeb044e43be16c72915760035/src%2Flibcore%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar.rs?ref=a08919a52273e8fdeb044e43be16c72915760035", "patch": "@@ -47,9 +47,9 @@ export is_alphabetic,\n        to_digit, cmp,\n        escape_default, escape_unicode;\n \n-use is_alphabetic = unicode::derived_property::Alphabetic;\n-use is_XID_start = unicode::derived_property::XID_Start;\n-use is_XID_continue = unicode::derived_property::XID_Continue;\n+pub use is_alphabetic = unicode::derived_property::Alphabetic;\n+pub use is_XID_start = unicode::derived_property::XID_Start;\n+pub use is_XID_continue = unicode::derived_property::XID_Continue;\n \n \n /**"}, {"sha": "3d3f25e7bee453529be5032a773fdfc8b0f26f2a", "filename": "src/libcore/f32.rs", "status": "modified", "additions": 40, "deletions": 44, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/a08919a52273e8fdeb044e43be16c72915760035/src%2Flibcore%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a08919a52273e8fdeb044e43be16c72915760035/src%2Flibcore%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ff32.rs?ref=a08919a52273e8fdeb044e43be16c72915760035", "patch": "@@ -6,8 +6,8 @@\n \n // PORT\n \n-use cmath::c_float::*;\n-use cmath::c_float_targ_consts::*;\n+pub use cmath::c_float::*;\n+pub use cmath::c_float_targ_consts::*;\n \n export add, sub, mul, div, rem, lt, le, eq, ne, ge, gt;\n export is_positive, is_negative, is_nonpositive, is_nonnegative;\n@@ -22,58 +22,56 @@ export lgamma, ln, log_radix, ln1p, log10, log2, ilog_radix;\n export modf, pow, round, sin, sinh, sqrt, tan, tanh, tgamma, trunc;\n export signbit;\n \n-export num;\n-\n // These are not defined inside consts:: for consistency with\n // the integer types\n \n-const NaN: f32 = 0.0_f32/0.0_f32;\n+pub const NaN: f32 = 0.0_f32/0.0_f32;\n \n-const infinity: f32 = 1.0_f32/0.0_f32;\n+pub const infinity: f32 = 1.0_f32/0.0_f32;\n \n-const neg_infinity: f32 = -1.0_f32/0.0_f32;\n+pub const neg_infinity: f32 = -1.0_f32/0.0_f32;\n \n-pure fn is_NaN(f: f32) -> bool { f != f }\n+pub pure fn is_NaN(f: f32) -> bool { f != f }\n \n-pure fn add(x: f32, y: f32) -> f32 { return x + y; }\n+pub pure fn add(x: f32, y: f32) -> f32 { return x + y; }\n \n-pure fn sub(x: f32, y: f32) -> f32 { return x - y; }\n+pub pure fn sub(x: f32, y: f32) -> f32 { return x - y; }\n \n-pure fn mul(x: f32, y: f32) -> f32 { return x * y; }\n+pub pure fn mul(x: f32, y: f32) -> f32 { return x * y; }\n \n-pure fn div(x: f32, y: f32) -> f32 { return x / y; }\n+pub pure fn div(x: f32, y: f32) -> f32 { return x / y; }\n \n-pure fn rem(x: f32, y: f32) -> f32 { return x % y; }\n+pub pure fn rem(x: f32, y: f32) -> f32 { return x % y; }\n \n-pure fn lt(x: f32, y: f32) -> bool { return x < y; }\n+pub pure fn lt(x: f32, y: f32) -> bool { return x < y; }\n \n-pure fn le(x: f32, y: f32) -> bool { return x <= y; }\n+pub pure fn le(x: f32, y: f32) -> bool { return x <= y; }\n \n-pure fn eq(x: f32, y: f32) -> bool { return x == y; }\n+pub pure fn eq(x: f32, y: f32) -> bool { return x == y; }\n \n-pure fn ne(x: f32, y: f32) -> bool { return x != y; }\n+pub pure fn ne(x: f32, y: f32) -> bool { return x != y; }\n \n-pure fn ge(x: f32, y: f32) -> bool { return x >= y; }\n+pub pure fn ge(x: f32, y: f32) -> bool { return x >= y; }\n \n-pure fn gt(x: f32, y: f32) -> bool { return x > y; }\n+pub pure fn gt(x: f32, y: f32) -> bool { return x > y; }\n \n // FIXME (#1999): replace the predicates below with llvm intrinsics or\n // calls to the libmath macros in the rust runtime for performance.\n \n /// Returns true if `x` is a positive number, including +0.0f320 and +Infinity\n-pure fn is_positive(x: f32) -> bool\n+pub pure fn is_positive(x: f32) -> bool\n     { return x > 0.0f32 || (1.0f32/x) == infinity; }\n \n /// Returns true if `x` is a negative number, including -0.0f320 and -Infinity\n-pure fn is_negative(x: f32) -> bool\n+pub pure fn is_negative(x: f32) -> bool\n     { return x < 0.0f32 || (1.0f32/x) == neg_infinity; }\n \n /**\n  * Returns true if `x` is a negative number, including -0.0f320 and -Infinity\n  *\n  * This is the same as `f32::is_negative`.\n  */\n-pure fn is_nonpositive(x: f32) -> bool {\n+pub pure fn is_nonpositive(x: f32) -> bool {\n   return x < 0.0f32 || (1.0f32/x) == neg_infinity;\n }\n \n@@ -82,78 +80,76 @@ pure fn is_nonpositive(x: f32) -> bool {\n  *\n  * This is the same as `f32::is_positive`.)\n  */\n-pure fn is_nonnegative(x: f32) -> bool {\n+pub pure fn is_nonnegative(x: f32) -> bool {\n   return x > 0.0f32 || (1.0f32/x) == infinity;\n }\n \n /// Returns true if `x` is a zero number (positive or negative zero)\n-pure fn is_zero(x: f32) -> bool {\n+pub pure fn is_zero(x: f32) -> bool {\n     return x == 0.0f32 || x == -0.0f32;\n }\n \n /// Returns true if `x`is an infinite number\n-pure fn is_infinite(x: f32) -> bool {\n+pub pure fn is_infinite(x: f32) -> bool {\n     return x == infinity || x == neg_infinity;\n }\n \n /// Returns true if `x`is a finite number\n-pure fn is_finite(x: f32) -> bool {\n+pub pure fn is_finite(x: f32) -> bool {\n     return !(is_NaN(x) || is_infinite(x));\n }\n \n // FIXME (#1999): add is_normal, is_subnormal, and fpclassify.\n \n /* Module: consts */\n-mod consts {\n-    #[legacy_exports];\n-\n+pub mod consts {\n     // FIXME (requires Issue #1433 to fix): replace with mathematical\n     // constants from cmath.\n     /// Archimedes' constant\n-    const pi: f32 = 3.14159265358979323846264338327950288_f32;\n+    pub const pi: f32 = 3.14159265358979323846264338327950288_f32;\n \n     /// pi/2.0\n-    const frac_pi_2: f32 = 1.57079632679489661923132169163975144_f32;\n+    pub const frac_pi_2: f32 = 1.57079632679489661923132169163975144_f32;\n \n     /// pi/4.0\n-    const frac_pi_4: f32 = 0.785398163397448309615660845819875721_f32;\n+    pub const frac_pi_4: f32 = 0.785398163397448309615660845819875721_f32;\n \n     /// 1.0/pi\n-    const frac_1_pi: f32 = 0.318309886183790671537767526745028724_f32;\n+    pub const frac_1_pi: f32 = 0.318309886183790671537767526745028724_f32;\n \n     /// 2.0/pi\n-    const frac_2_pi: f32 = 0.636619772367581343075535053490057448_f32;\n+    pub const frac_2_pi: f32 = 0.636619772367581343075535053490057448_f32;\n \n     /// 2.0/sqrt(pi)\n-    const frac_2_sqrtpi: f32 = 1.12837916709551257389615890312154517_f32;\n+    pub const frac_2_sqrtpi: f32 = 1.12837916709551257389615890312154517_f32;\n \n     /// sqrt(2.0)\n-    const sqrt2: f32 = 1.41421356237309504880168872420969808_f32;\n+    pub const sqrt2: f32 = 1.41421356237309504880168872420969808_f32;\n \n     /// 1.0/sqrt(2.0)\n-    const frac_1_sqrt2: f32 = 0.707106781186547524400844362104849039_f32;\n+    pub const frac_1_sqrt2: f32 = 0.707106781186547524400844362104849039_f32;\n \n     /// Euler's number\n-    const e: f32 = 2.71828182845904523536028747135266250_f32;\n+    pub const e: f32 = 2.71828182845904523536028747135266250_f32;\n \n     /// log2(e)\n-    const log2_e: f32 = 1.44269504088896340735992468100189214_f32;\n+    pub const log2_e: f32 = 1.44269504088896340735992468100189214_f32;\n \n     /// log10(e)\n-    const log10_e: f32 = 0.434294481903251827651128918916605082_f32;\n+    pub const log10_e: f32 = 0.434294481903251827651128918916605082_f32;\n \n     /// ln(2.0)\n-    const ln_2: f32 = 0.693147180559945309417232121458176568_f32;\n+    pub const ln_2: f32 = 0.693147180559945309417232121458176568_f32;\n \n     /// ln(10.0)\n-    const ln_10: f32 = 2.30258509299404568401799145468436421_f32;\n+    pub const ln_10: f32 = 2.30258509299404568401799145468436421_f32;\n }\n \n-pure fn signbit(x: f32) -> int {\n+pub pure fn signbit(x: f32) -> int {\n     if is_negative(x) { return 1; } else { return 0; }\n }\n \n-pure fn logarithm(n: f32, b: f32) -> f32 {\n+pub pure fn logarithm(n: f32, b: f32) -> f32 {\n     return log2(n) / log2(b);\n }\n "}, {"sha": "6066b6688f17e7f557fd6445ffa979cc1765d3ac", "filename": "src/libcore/f64.rs", "status": "modified", "additions": 52, "deletions": 54, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/a08919a52273e8fdeb044e43be16c72915760035/src%2Flibcore%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a08919a52273e8fdeb044e43be16c72915760035/src%2Flibcore%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ff64.rs?ref=a08919a52273e8fdeb044e43be16c72915760035", "patch": "@@ -9,6 +9,9 @@\n use cmath::c_double::*;\n use cmath::c_double_targ_consts::*;\n \n+// These are not defined inside consts:: for consistency with\n+// the integer types\n+\n // Even though this module exports everything defined in it,\n // because it contains re-exports, we also have to explicitly\n // export locally defined things. That's a bit annoying.\n@@ -30,77 +33,74 @@ export j0, j1, jn, y0, y1, yn;\n \n export num;\n \n-// These are not defined inside consts:: for consistency with\n-// the integer types\n-\n // PORT check per architecture\n \n // FIXME (#1433): obtain these in a different way\n \n-const radix: uint = 2u;\n+pub const radix: uint = 2u;\n \n-const mantissa_digits: uint = 53u;\n-const digits: uint = 15u;\n+pub const mantissa_digits: uint = 53u;\n+pub const digits: uint = 15u;\n \n-const epsilon: f64 = 2.2204460492503131e-16_f64;\n+pub const epsilon: f64 = 2.2204460492503131e-16_f64;\n \n-const min_value: f64 = 2.2250738585072014e-308_f64;\n-const max_value: f64 = 1.7976931348623157e+308_f64;\n+pub const min_value: f64 = 2.2250738585072014e-308_f64;\n+pub const max_value: f64 = 1.7976931348623157e+308_f64;\n \n-const min_exp: int = -1021;\n-const max_exp: int = 1024;\n+pub const min_exp: int = -1021;\n+pub const max_exp: int = 1024;\n \n-const min_10_exp: int = -307;\n-const max_10_exp: int = 308;\n+pub const min_10_exp: int = -307;\n+pub const max_10_exp: int = 308;\n \n-const NaN: f64 = 0.0_f64/0.0_f64;\n+pub const NaN: f64 = 0.0_f64/0.0_f64;\n \n-const infinity: f64 = 1.0_f64/0.0_f64;\n+pub const infinity: f64 = 1.0_f64/0.0_f64;\n \n-const neg_infinity: f64 = -1.0_f64/0.0_f64;\n+pub const neg_infinity: f64 = -1.0_f64/0.0_f64;\n \n-pure fn is_NaN(f: f64) -> bool { f != f }\n+pub pure fn is_NaN(f: f64) -> bool { f != f }\n \n-pure fn add(x: f64, y: f64) -> f64 { return x + y; }\n+pub pure fn add(x: f64, y: f64) -> f64 { return x + y; }\n \n-pure fn sub(x: f64, y: f64) -> f64 { return x - y; }\n+pub pure fn sub(x: f64, y: f64) -> f64 { return x - y; }\n \n-pure fn mul(x: f64, y: f64) -> f64 { return x * y; }\n+pub pure fn mul(x: f64, y: f64) -> f64 { return x * y; }\n \n-pure fn div(x: f64, y: f64) -> f64 { return x / y; }\n+pub pure fn div(x: f64, y: f64) -> f64 { return x / y; }\n \n-pure fn rem(x: f64, y: f64) -> f64 { return x % y; }\n+pub pure fn rem(x: f64, y: f64) -> f64 { return x % y; }\n \n-pure fn lt(x: f64, y: f64) -> bool { return x < y; }\n+pub pure fn lt(x: f64, y: f64) -> bool { return x < y; }\n \n-pure fn le(x: f64, y: f64) -> bool { return x <= y; }\n+pub pure fn le(x: f64, y: f64) -> bool { return x <= y; }\n \n-pure fn eq(x: f64, y: f64) -> bool { return x == y; }\n+pub pure fn eq(x: f64, y: f64) -> bool { return x == y; }\n \n-pure fn ne(x: f64, y: f64) -> bool { return x != y; }\n+pub pure fn ne(x: f64, y: f64) -> bool { return x != y; }\n \n-pure fn ge(x: f64, y: f64) -> bool { return x >= y; }\n+pub pure fn ge(x: f64, y: f64) -> bool { return x >= y; }\n \n-pure fn gt(x: f64, y: f64) -> bool { return x > y; }\n+pub pure fn gt(x: f64, y: f64) -> bool { return x > y; }\n \n-pure fn sqrt(x: f64) -> f64 {\n+pub pure fn sqrt(x: f64) -> f64 {\n     cmath::c_double::sqrt(x as libc::c_double) as f64\n }\n \n /// Returns true if `x` is a positive number, including +0.0f640 and +Infinity\n-pure fn is_positive(x: f64) -> bool\n+pub pure fn is_positive(x: f64) -> bool\n     { return x > 0.0f64 || (1.0f64/x) == infinity; }\n \n /// Returns true if `x` is a negative number, including -0.0f640 and -Infinity\n-pure fn is_negative(x: f64) -> bool\n+pub pure fn is_negative(x: f64) -> bool\n     { return x < 0.0f64 || (1.0f64/x) == neg_infinity; }\n \n /**\n  * Returns true if `x` is a negative number, including -0.0f640 and -Infinity\n  *\n  * This is the same as `f64::is_negative`.\n  */\n-pure fn is_nonpositive(x: f64) -> bool {\n+pub pure fn is_nonpositive(x: f64) -> bool {\n   return x < 0.0f64 || (1.0f64/x) == neg_infinity;\n }\n \n@@ -109,78 +109,76 @@ pure fn is_nonpositive(x: f64) -> bool {\n  *\n  * This is the same as `f64::positive`.\n  */\n-pure fn is_nonnegative(x: f64) -> bool {\n+pub pure fn is_nonnegative(x: f64) -> bool {\n   return x > 0.0f64 || (1.0f64/x) == infinity;\n }\n \n /// Returns true if `x` is a zero number (positive or negative zero)\n-pure fn is_zero(x: f64) -> bool {\n+pub pure fn is_zero(x: f64) -> bool {\n     return x == 0.0f64 || x == -0.0f64;\n }\n \n /// Returns true if `x`is an infinite number\n-pure fn is_infinite(x: f64) -> bool {\n+pub pure fn is_infinite(x: f64) -> bool {\n     return x == infinity || x == neg_infinity;\n }\n \n /// Returns true if `x`is a finite number\n-pure fn is_finite(x: f64) -> bool {\n+pub pure fn is_finite(x: f64) -> bool {\n     return !(is_NaN(x) || is_infinite(x));\n }\n \n // FIXME (#1999): add is_normal, is_subnormal, and fpclassify\n \n /* Module: consts */\n-mod consts {\n-    #[legacy_exports];\n-\n+pub mod consts {\n     // FIXME (requires Issue #1433 to fix): replace with mathematical\n     // constants from cmath.\n     /// Archimedes' constant\n-    const pi: f64 = 3.14159265358979323846264338327950288_f64;\n+    pub const pi: f64 = 3.14159265358979323846264338327950288_f64;\n \n     /// pi/2.0\n-    const frac_pi_2: f64 = 1.57079632679489661923132169163975144_f64;\n+    pub const frac_pi_2: f64 = 1.57079632679489661923132169163975144_f64;\n \n     /// pi/4.0\n-    const frac_pi_4: f64 = 0.785398163397448309615660845819875721_f64;\n+    pub const frac_pi_4: f64 = 0.785398163397448309615660845819875721_f64;\n \n     /// 1.0/pi\n-    const frac_1_pi: f64 = 0.318309886183790671537767526745028724_f64;\n+    pub const frac_1_pi: f64 = 0.318309886183790671537767526745028724_f64;\n \n     /// 2.0/pi\n-    const frac_2_pi: f64 = 0.636619772367581343075535053490057448_f64;\n+    pub const frac_2_pi: f64 = 0.636619772367581343075535053490057448_f64;\n \n     /// 2.0/sqrt(pi)\n-    const frac_2_sqrtpi: f64 = 1.12837916709551257389615890312154517_f64;\n+    pub const frac_2_sqrtpi: f64 = 1.12837916709551257389615890312154517_f64;\n \n     /// sqrt(2.0)\n-    const sqrt2: f64 = 1.41421356237309504880168872420969808_f64;\n+    pub const sqrt2: f64 = 1.41421356237309504880168872420969808_f64;\n \n     /// 1.0/sqrt(2.0)\n-    const frac_1_sqrt2: f64 = 0.707106781186547524400844362104849039_f64;\n+    pub const frac_1_sqrt2: f64 = 0.707106781186547524400844362104849039_f64;\n \n     /// Euler's number\n-    const e: f64 = 2.71828182845904523536028747135266250_f64;\n+    pub const e: f64 = 2.71828182845904523536028747135266250_f64;\n \n     /// log2(e)\n-    const log2_e: f64 = 1.44269504088896340735992468100189214_f64;\n+    pub const log2_e: f64 = 1.44269504088896340735992468100189214_f64;\n \n     /// log10(e)\n-    const log10_e: f64 = 0.434294481903251827651128918916605082_f64;\n+    pub const log10_e: f64 = 0.434294481903251827651128918916605082_f64;\n \n     /// ln(2.0)\n-    const ln_2: f64 = 0.693147180559945309417232121458176568_f64;\n+    pub const ln_2: f64 = 0.693147180559945309417232121458176568_f64;\n \n     /// ln(10.0)\n-    const ln_10: f64 = 2.30258509299404568401799145468436421_f64;\n+    pub const ln_10: f64 = 2.30258509299404568401799145468436421_f64;\n }\n \n-pure fn signbit(x: f64) -> int {\n+pub pure fn signbit(x: f64) -> int {\n     if is_negative(x) { return 1; } else { return 0; }\n }\n \n-pure fn logarithm(n: f64, b: f64) -> f64 {\n+pub pure fn logarithm(n: f64, b: f64) -> f64 {\n     return log2(n) / log2(b);\n }\n "}, {"sha": "b240fd95f19064585649cb70ad83cc7cdfc94ed2", "filename": "src/libcore/float.rs", "status": "modified", "additions": 41, "deletions": 43, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/a08919a52273e8fdeb044e43be16c72915760035/src%2Flibcore%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a08919a52273e8fdeb044e43be16c72915760035/src%2Flibcore%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffloat.rs?ref=a08919a52273e8fdeb044e43be16c72915760035", "patch": "@@ -51,49 +51,47 @@ const infinity: float = 1.0/0.0;\n const neg_infinity: float = -1.0/0.0;\n \n /* Module: consts */\n-mod consts {\n-    #[legacy_exports];\n-\n+pub mod consts {\n     // FIXME (requires Issue #1433 to fix): replace with mathematical\n     // constants from cmath.\n     /// Archimedes' constant\n-    const pi: float = 3.14159265358979323846264338327950288;\n+    pub const pi: float = 3.14159265358979323846264338327950288;\n \n     /// pi/2.0\n-    const frac_pi_2: float = 1.57079632679489661923132169163975144;\n+    pub const frac_pi_2: float = 1.57079632679489661923132169163975144;\n \n     /// pi/4.0\n-    const frac_pi_4: float = 0.785398163397448309615660845819875721;\n+    pub const frac_pi_4: float = 0.785398163397448309615660845819875721;\n \n     /// 1.0/pi\n-    const frac_1_pi: float = 0.318309886183790671537767526745028724;\n+    pub const frac_1_pi: float = 0.318309886183790671537767526745028724;\n \n     /// 2.0/pi\n-    const frac_2_pi: float = 0.636619772367581343075535053490057448;\n+    pub const frac_2_pi: float = 0.636619772367581343075535053490057448;\n \n     /// 2.0/sqrt(pi)\n-    const frac_2_sqrtpi: float = 1.12837916709551257389615890312154517;\n+    pub const frac_2_sqrtpi: float = 1.12837916709551257389615890312154517;\n \n     /// sqrt(2.0)\n-    const sqrt2: float = 1.41421356237309504880168872420969808;\n+    pub const sqrt2: float = 1.41421356237309504880168872420969808;\n \n     /// 1.0/sqrt(2.0)\n-    const frac_1_sqrt2: float = 0.707106781186547524400844362104849039;\n+    pub const frac_1_sqrt2: float = 0.707106781186547524400844362104849039;\n \n     /// Euler's number\n-    const e: float = 2.71828182845904523536028747135266250;\n+    pub const e: float = 2.71828182845904523536028747135266250;\n \n     /// log2(e)\n-    const log2_e: float = 1.44269504088896340735992468100189214;\n+    pub const log2_e: float = 1.44269504088896340735992468100189214;\n \n     /// log10(e)\n-    const log10_e: float = 0.434294481903251827651128918916605082;\n+    pub const log10_e: float = 0.434294481903251827651128918916605082;\n \n     /// ln(2.0)\n-    const ln_2: float = 0.693147180559945309417232121458176568;\n+    pub const ln_2: float = 0.693147180559945309417232121458176568;\n \n     /// ln(10.0)\n-    const ln_10: float = 2.30258509299404568401799145468436421;\n+    pub const ln_10: float = 2.30258509299404568401799145468436421;\n }\n \n /**\n@@ -194,12 +192,12 @@ fn to_str_common(num: float, digits: uint, exact: bool) -> ~str {\n  * * num - The float value\n  * * digits - The number of significant digits\n  */\n-fn to_str_exact(num: float, digits: uint) -> ~str {\n+pub fn to_str_exact(num: float, digits: uint) -> ~str {\n     to_str_common(num, digits, true)\n }\n \n #[test]\n-fn test_to_str_exact_do_decimal() {\n+pub fn test_to_str_exact_do_decimal() {\n     let s = to_str_exact(5.0, 4u);\n     assert s == ~\"5.0000\";\n }\n@@ -214,7 +212,7 @@ fn test_to_str_exact_do_decimal() {\n  * * num - The float value\n  * * digits - The number of significant digits\n  */\n-fn to_str(num: float, digits: uint) -> ~str {\n+pub fn to_str(num: float, digits: uint) -> ~str {\n     to_str_common(num, digits, false)\n }\n \n@@ -244,7 +242,7 @@ fn to_str(num: float, digits: uint) -> ~str {\n  * `none` if the string did not represent a valid number.  Otherwise,\n  * `Some(n)` where `n` is the floating-point number represented by `[num]`.\n  */\n-fn from_str(num: &str) -> Option<float> {\n+pub fn from_str(num: &str) -> Option<float> {\n    if num == \"inf\" {\n        return Some(infinity as float);\n    } else if num == \"-inf\" {\n@@ -379,7 +377,7 @@ fn from_str(num: &str) -> Option<float> {\n  *\n  * `NaN` if both `x` and `pow` are `0u`, otherwise `x^pow`\n  */\n-fn pow_with_uint(base: uint, pow: uint) -> float {\n+pub fn pow_with_uint(base: uint, pow: uint) -> float {\n     if base == 0u {\n         if pow == 0u {\n             return NaN as float;\n@@ -399,21 +397,21 @@ fn pow_with_uint(base: uint, pow: uint) -> float {\n     return total;\n }\n \n-pure fn is_positive(x: float) -> bool { f64::is_positive(x as f64) }\n-pure fn is_negative(x: float) -> bool { f64::is_negative(x as f64) }\n-pure fn is_nonpositive(x: float) -> bool { f64::is_nonpositive(x as f64) }\n-pure fn is_nonnegative(x: float) -> bool { f64::is_nonnegative(x as f64) }\n-pure fn is_zero(x: float) -> bool { f64::is_zero(x as f64) }\n-pure fn is_infinite(x: float) -> bool { f64::is_infinite(x as f64) }\n-pure fn is_finite(x: float) -> bool { f64::is_finite(x as f64) }\n-pure fn is_NaN(x: float) -> bool { f64::is_NaN(x as f64) }\n-\n-pure fn abs(x: float) -> float { f64::abs(x as f64) as float }\n-pure fn sqrt(x: float) -> float { f64::sqrt(x as f64) as float }\n-pure fn atan(x: float) -> float { f64::atan(x as f64) as float }\n-pure fn sin(x: float) -> float { f64::sin(x as f64) as float }\n-pure fn cos(x: float) -> float { f64::cos(x as f64) as float }\n-pure fn tan(x: float) -> float { f64::tan(x as f64) as float }\n+pub pure fn is_positive(x: float) -> bool { f64::is_positive(x as f64) }\n+pub pure fn is_negative(x: float) -> bool { f64::is_negative(x as f64) }\n+pub pure fn is_nonpositive(x: float) -> bool { f64::is_nonpositive(x as f64) }\n+pub pure fn is_nonnegative(x: float) -> bool { f64::is_nonnegative(x as f64) }\n+pub pure fn is_zero(x: float) -> bool { f64::is_zero(x as f64) }\n+pub pure fn is_infinite(x: float) -> bool { f64::is_infinite(x as f64) }\n+pub pure fn is_finite(x: float) -> bool { f64::is_finite(x as f64) }\n+pub pure fn is_NaN(x: float) -> bool { f64::is_NaN(x as f64) }\n+\n+pub pure fn abs(x: float) -> float { f64::abs(x as f64) as float }\n+pub pure fn sqrt(x: float) -> float { f64::sqrt(x as f64) as float }\n+pub pure fn atan(x: float) -> float { f64::atan(x as f64) as float }\n+pub pure fn sin(x: float) -> float { f64::sin(x as f64) as float }\n+pub pure fn cos(x: float) -> float { f64::cos(x as f64) as float }\n+pub pure fn tan(x: float) -> float { f64::tan(x as f64) as float }\n \n impl float : Eq {\n     pure fn eq(other: &float) -> bool { self == (*other) }\n@@ -440,7 +438,7 @@ impl float: num::Num {\n }\n \n #[test]\n-fn test_from_str() {\n+pub fn test_from_str() {\n    assert from_str(~\"3\") == Some(3.);\n    assert from_str(~\"3\") == Some(3.);\n    assert from_str(~\"3.14\") == Some(3.14);\n@@ -483,7 +481,7 @@ fn test_from_str() {\n }\n \n #[test]\n-fn test_positive() {\n+pub fn test_positive() {\n   assert(is_positive(infinity));\n   assert(is_positive(1.));\n   assert(is_positive(0.));\n@@ -494,7 +492,7 @@ fn test_positive() {\n }\n \n #[test]\n-fn test_negative() {\n+pub fn test_negative() {\n   assert(!is_negative(infinity));\n   assert(!is_negative(1.));\n   assert(!is_negative(0.));\n@@ -505,7 +503,7 @@ fn test_negative() {\n }\n \n #[test]\n-fn test_nonpositive() {\n+pub fn test_nonpositive() {\n   assert(!is_nonpositive(infinity));\n   assert(!is_nonpositive(1.));\n   assert(!is_nonpositive(0.));\n@@ -516,7 +514,7 @@ fn test_nonpositive() {\n }\n \n #[test]\n-fn test_nonnegative() {\n+pub fn test_nonnegative() {\n   assert(is_nonnegative(infinity));\n   assert(is_nonnegative(1.));\n   assert(is_nonnegative(0.));\n@@ -527,13 +525,13 @@ fn test_nonnegative() {\n }\n \n #[test]\n-fn test_to_str_inf() {\n+pub fn test_to_str_inf() {\n     assert to_str(infinity, 10u) == ~\"inf\";\n     assert to_str(-infinity, 10u) == ~\"-inf\";\n }\n \n #[test]\n-fn test_traits() {\n+pub fn test_traits() {\n     fn test<U:num::Num cmp::Eq>(ten: &U) {\n         assert (ten.to_int() == 10);\n "}]}