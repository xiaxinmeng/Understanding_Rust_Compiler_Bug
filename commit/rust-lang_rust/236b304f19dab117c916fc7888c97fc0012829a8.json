{"sha": "236b304f19dab117c916fc7888c97fc0012829a8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIzNmIzMDRmMTlkYWIxMTdjOTE2ZmM3ODg4Yzk3ZmMwMDEyODI5YTg=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-01-17T00:13:23Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-01-17T00:13:34Z"}, "message": "Convert some material covering items, view-items, types.", "tree": {"sha": "7393f03bd21eb5ff12d70d67cd8cf0e600ea0c3d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7393f03bd21eb5ff12d70d67cd8cf0e600ea0c3d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/236b304f19dab117c916fc7888c97fc0012829a8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/236b304f19dab117c916fc7888c97fc0012829a8", "html_url": "https://github.com/rust-lang/rust/commit/236b304f19dab117c916fc7888c97fc0012829a8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/236b304f19dab117c916fc7888c97fc0012829a8/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e20d90671856ac9935ea42281b669eee891a984d", "url": "https://api.github.com/repos/rust-lang/rust/commits/e20d90671856ac9935ea42281b669eee891a984d", "html_url": "https://github.com/rust-lang/rust/commit/e20d90671856ac9935ea42281b669eee891a984d"}], "stats": {"total": 416, "additions": 415, "deletions": 1}, "files": [{"sha": "07b6f2e01daad3da95bcb43846572ce11aded17e", "filename": "doc/rust.md", "status": "modified", "additions": 415, "deletions": 1, "changes": 416, "blob_url": "https://github.com/rust-lang/rust/blob/236b304f19dab117c916fc7888c97fc0012829a8/doc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/236b304f19dab117c916fc7888c97fc0012829a8/doc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frust.md?ref=236b304f19dab117c916fc7888c97fc0012829a8", "patch": "@@ -566,8 +566,229 @@ a referencing crate file, or by the filename of the source file itself.\n \n # Items and attributes\n \n+A crate is a collection of [items](#items), each of which may have some number\n+of [attributes](#attributes) attached to it.\n \n-### Attributes\n+## Items\n+\n+~~~~~~~~ {.ebnf .gram}\n+item : mod_item | fn_item | type_item | enum_item\n+     | res_item | iface_item | impl_item ;\n+~~~~~~~~\n+\n+An _item_ is a component of a crate; some module items can be defined in\n+[crate files](#crate-files) but most are defined in [source\n+files](#source-files). Items are organized within a crate by a nested set of\n+[modules](#modules). Every crate has a single \"outermost\" anonymous module;\n+all further items within the crate have [paths](#paths) within the module tree\n+of the crate.\n+\n+Items are entirely determined at compile-time, remain constant during\n+execution, and may reside in read-only memory.\n+\n+There are several kinds of item:\n+\n+  * [modules](#modules)\n+  * [functions](#functions)\n+  * [type definitions](#type-definitions)\n+  * [eunmerations](#enumerations)\n+  * [resources](#resources)\n+  * [interfaces](#interfaces)\n+  * [implementations](#implementations)\n+\n+Some items form an implicit scope for the declaration of sub-items. In other\n+words, within a function or module, declarations of items can (in many cases)\n+be mixed with the statements, control blocks, and similar artifacts that\n+otherwise compose the item body. The meaning of these scoped items is the same\n+as if the item was declared outside the scope -- it is still a static item --\n+except that the item's *path name* within the module namespace is qualified by\n+the name of the enclosing item, or is private to the enclosing item (in the\n+case of functions). The exact locations in which sub-items may be declared is\n+given by the grammar.\n+\n+All items except modules may be *parametrized* by type. Type parameters are\n+given as a comma-separated list of identifiers enclosed in angle brackets\n+(`<...>`), after the name of the item and before its definition. The type\n+parameters of an item are considered \"part of the name\", not the type of the\n+item; in order to refer to the type-parametrized item, a referencing\n+[path](#paths) must in general provide type arguments as a list of\n+comma-separated types enclosed within angle brackets. In practice, the\n+type-inference system can usually infer such argument types from\n+context. There are no general type-parametric types, only type-parametric\n+items.\n+\n+\n+### Modules\n+\n+~~~~~~~~ {.ebnf .gram}\n+mod_item : \"mod\" '{' mod '}' ;\n+mod : [ view_item | item ] * ;\n+~~~~~~~~\n+\n+A module is a kind of item that contains zero or more [view\n+items](#view-items) and zero or more sub-[items](#items). The view items\n+manage the visibility of the items defined within the module, as well as the\n+visibility of names from outside the module when referenced from inside the\n+module.\n+\n+#### View items\n+\n+~~~~~~~~ {.ebnf .gram}\n+view_item : use_decl | import_decl | export_decl ;\n+~~~~~~~~\n+\n+A view item manages the namespace of a module; it does not define new items\n+but simply changes the visibility of other items. There are several kinds of\n+view item:\n+\n+ * [use declarations](#use-declarations)\n+ * [import declarations](#import-declarations)\n+ * [export declarations](#export-declarations)\n+\n+##### Use declarations\n+\n+~~~~~~~~ {.ebnf .gram}\n+use_decl : \"use\" ident [ '(' link_attrs ')' ] ? ;\n+link_attrs : link_attr [ ',' link_attrs ] + ;\n+link_attr : ident '=' immediate ;\n+~~~~~~~~\n+\n+A _use declaration_ specifies a dependency on an external crate. The external\n+crate is then imported into the declaring scope as the `ident` provided in the\n+`use_decl`.\n+\n+The external crate is resolved to a specific `soname` at compile time, and a\n+runtime linkage requirement to that `soname` is passed to the linker for\n+loading at runtime. The `soname` is resolved at compile time by scanning the\n+compiler's library path and matching the `link_attrs` provided in the\n+`use_decl` against any `#link` attributes that were declared on the external\n+crate when it was compiled. If no `link_attrs` are provided, a default `name`\n+attribute is assumed, equal to the `ident` given in the `use_decl`.\n+\n+Two examples of `use` declarations:\n+\n+~~~~~~~~\n+use pcre (uuid = \"54aba0f8-a7b1-4beb-92f1-4cf625264841\");\n+\n+use std; // equivalent to: use std ( name = \"std\" );\n+\n+use ruststd (name = \"std\"); // linking to 'std' under another name\n+~~~~~~~~\n+\n+##### Import declarations\n+\n+~~~~~~~~ {.ebnf .gram}\n+import_decl : \"import\" ident [ '=' path\n+                             | \"::\" path_glob ] ;\n+\n+path_glob : ident [ \"::\" path_glob ] ?\n+          | '*'\n+          | '{' ident [ ',' ident ] * '}'\n+~~~~~~~~\n+\n+An _import declaration_ creates one or more local name bindings synonymous\n+with some other [path](#paths). Usually an import declaration is used to\n+shorten the path required to refer to a module item.\n+\n+*Note*: unlike many languages, Rust's `import` declarations do not* declare\n+*linkage-dependency with external crates. Linkage dependencies are\n+*independently declared with [`use` declarations](#use -eclarations).\n+\n+Imports support a number of \"convenience\" notations:\n+\n+  * Importing as a different name than the imported name, using the \n+    syntax `import x = p::q::r;`.\n+  * Importing a list of paths differing only in final element, using\n+    the glob-like brace syntax `import a::b::{c,d,e,f};`\n+  * Importing all paths matching a given prefix, using the glob-like\n+    asterisk syntax `import a::b::*;`\n+\n+An example of imports:\n+\n+~~~~\n+import foo = core::info;\n+import std::math::sin;\n+import std::str::{char_at, hash};\n+import core::option::*;\n+\n+fn main() {\n+    // Equivalent to 'log(core::info, std::math::sin(1.0));'\n+    log(foo, sin(1.0));\n+\n+    // Equivalent to 'log(core::info, core::option::some(1.0));'\n+    log(info, some(1.0));\n+\n+    // Equivalent to 'log(core::info,\n+    //                    std::str::hash(std::str::char_at(\"foo\")));'\n+    log(info, hash(char_at(\"foo\")));\n+}\n+~~~~\n+\n+##### Export declarations\n+\n+~~~~~~~~ {.ebnf .gram}\n+export_decl : \"export\" ident [ ',' ident ] * ;\n+~~~~~~~~\n+\n+An _export declaration_ restricts the set of local names within a module that\n+can be accessed from code outside the module. By default, all _local items_ in\n+a module are exported; imported paths are not automatically re-exported by\n+default. If a module contains an explicit `export` declaration, this\n+declaration replaces the default export with the export specified.\n+\n+An example of an export:\n+\n+~~~~~~~~\n+mod foo {\n+    export primary;\n+\n+    fn primary() {\n+        helper(1, 2);\n+        helper(3, 4);\n+    }\n+\n+    fn helper(x: int, y: int) {\n+        ...\n+    }\n+}\n+\n+fn main() {\n+    foo::primary();  // Will compile.\n+    foo::helper(2,3) // ERROR: will not compile.\n+}\n+~~~~~~~~\n+\n+Multiple names may be exported from a single export declaration:\n+\n+~~~~~~~~\n+mod foo {\n+    export primary, secondary;\n+\n+    fn primary() {\n+        helper(1, 2);\n+        helper(3, 4);\n+    }\n+\n+    fn secondary() {\n+        ...\n+    }\n+\n+    fn helper(x: int, y: int) {\n+        ...\n+    }\n+}\n+~~~~~~~~\n+\n+\n+### Functions\n+### Type definitions\n+### Enumerations\n+### Resources\n+### Interfaces\n+### Implementations\n+\n+\n+## Attributes\n \n ~~~~~~~~{.ebnf .gram}\n attribute : '#' '[' attr_list ']' ;\n@@ -737,6 +958,199 @@ macro-generated and user-written code can cause unintentional capture.\n Future versions of Rust will address these issues.\n \n \n+# Types and typestates\n+\n+## Type system\n+\n+Every slot and value in a Rust program has a type. The _type_ of a *value*\n+defines the interpretation of the memory holding it. The type of a *slot* may\n+also include [constraints](#constrained-types).\n+\n+Built-in types and type-constructors are tightly integrated into the language,\n+in nontrivial ways that are not possible to emulate in user-defined\n+types. User-defined types have limited capabilities. In addition, every\n+built-in type or type-constructor name is reserved as a *keyword* in Rust;\n+they cannot be used as user-defined identifiers in any context.\n+\n+### Primitive types\n+\n+The primitive types are the following:\n+\n+* The \"nil\" type `()`, having the single \"nil\" value `()`.^[The \"nil\" value\n+  `()` is *not* a sentinel \"null pointer\" value for reference slots; the \"nil\"\n+  type is the implicit return type from functions otherwise lacking a return\n+  type, and can be used in other contexts (such as message-sending or\n+  type-parametric code) as a zero-size type.]\n+* The boolean type `bool` with values `true` and `false`.\n+* The machine types.\n+* The machine-dependent integer and floating-point types.\n+\n+#### Machine types\n+\n+The machine types are the following:\n+\n+\n+* The unsigned word types `u8`, `u16`, `u32` and `u64`, with values drawn from\n+  the integer intervals $[0, 2^8 - 1]$, $[0, 2^16 - 1]$, $[0, 2^32 - 1]$ and\n+  $[0, 2^64 - 1]$ respectively.\n+\n+* The signed two's complement word types `i8`, `i16`, `i32` and `i64`, with\n+  values drawn from the integer intervals $[-(2^7), 2^7 - 1]$,\n+  $[-(2^15), 2^15 - 1]$, $[-(2^31), 2^31 - 1]$, $[-(2^63), 2^63 - 1]$\n+  respectively.\n+\n+* The IEEE 754-2008 `binary32` and `binary64` floating-point types: `f32` and\n+  `f64`, respectively.\n+\n+#### Machine-dependent integer types\n+\n+The Rust type `uint`^[A Rust `uint` is analogous to a C99 `uintptr_t`.] is an\n+unsigned integer type with with target-machine-dependent size. Its size, in\n+bits, is equal to the number of bits required to hold any memory address on\n+the target machine.\n+\n+The Rust type `int`^[A Rust `int` is analogous to a C99 `intptr_t`.] is a\n+two's complement signed integer type with target-machine-dependent size. Its\n+size, in bits, is equal to the size of the rust type `uint` on the same target\n+machine.\n+\n+\n+#### Machine-dependent floating point type\n+\n+The Rust type `float` is a machine-specific type equal to one of the supported\n+Rust floating-point machine types (`f32` or `f64`). It is the largest\n+floating-point type that is directly supported by hardware on the target\n+machine, or if the target machine has no floating-point hardware support, the\n+largest floating-point type supported by the software floating-point library\n+used to support the other floating-point machine types.\n+\n+Note that due to the preference for hardware-supported floating-point, the\n+type `float` may not be equal to the largest *supported* floating-point type.\n+\n+\n+### Textual types\n+\n+The types `char` and `str` hold textual data.\n+\n+A value of type `char` is a Unicode character, represented as a 32-bit\n+unsigned word holding a UCS-4 codepoint.\n+\n+A value of type `str` is a Unicode string, represented as a vector of 8-bit\n+unsigned bytes holding a sequence of UTF-8 codepoints.\n+\n+\n+\n+### Record types\n+\n+The record type-constructor forms a new heterogeneous product of values.^[The\n+record type-constructor is analogous to the `struct` type-constructor in the\n+Algol/C family, the *record* types of the ML family, or the *structure* types\n+of the Lisp family.] Fields of a record type are accessed by name and are\n+arranged in memory in the order specified by the record type.\n+\n+An example of a record type and its use:\n+\n+~~~~\n+type point = {x: int, y: int};\n+let p: point = {x: 10, y: 11};\n+let px: int = p.x;\n+~~~~\n+\n+### Tuple types\n+\n+The tuple type-constructor forms a new heterogeneous product of values similar\n+to the record type-constructor. The differences are as follows:\n+\n+* tuple elements cannot be mutable, unlike record fields\n+* tuple elements are not named and can be accessed only by pattern-matching\n+\n+Tuple types and values are denoted by listing the types or values of their\n+elements, respectively, in a parenthesized, comma-separated\n+list. Single-element tuples are not legal; all tuples have two or more values.\n+\n+The members of a tuple are laid out in memory contiguously, like a record, in\n+order specified by the tuple type.\n+\n+An example of a tuple type and its use:\n+\n+~~~~\n+type pair = (int,str);\n+let p: pair = (10,\"hello\");\n+let (a, b) = p;\n+assert (b == \"world\");\n+~~~~\n+\n+### Vector types\n+\n+The vector type-constructor represents a homogeneous array of values of a\n+given type. A vector has a fixed size. The kind of a vector type depends on\n+the kind of its member type, as with other simple structural types.\n+\n+An example of a vector type and its use:\n+\n+~~~~\n+let v: [int] = [7, 5, 3];\n+let i: int = v[2];\n+assert (i == 3);\n+~~~~\n+\n+Vectors always *allocate* a storage region sufficient to store the first power\n+of two worth of elements greater than or equal to the size of the vector. This\n+behaviour supports idiomatic in-place \"growth\" of a mutable slot holding a\n+vector:\n+\n+\n+~~~~\n+let v: mutable [int] = [1, 2, 3];\n+v += [4, 5, 6];\n+~~~~\n+\n+Normal vector concatenation causes the allocation of a fresh vector to hold\n+the result; in this case, however, the slot holding the vector recycles the\n+underlying storage in-place (since the reference-count of the underlying\n+storage is equal to 1).\n+\n+All accessible elements of a vector are always initialized, and access to a\n+vector is always bounds-checked.\n+\n+\n+### Enumerated types\n+\n+An *enumerated type* is a nominal, heterogeneous disjoint union type.^[The\n+`enum` type is analogous to a `data` constructor declaration in ML or a *pick\n+ADT* in Limbo.} An [`enum` *item*](#enumerations) consists of a number of\n+*constructors*, each of which is independently named and takes an optional\n+tuple of arguments.\n+\n+Enumerated types cannot be denoted *structurally* as types, but must be\n+denoted by named reference to an [*enumeration* item](#enumerations).\n+\n+\n+### Function types\n+\n+The function type-constructor `fn` forms new function types. A function type\n+consists of a sequence of input slots, an optional set of [input\n+constraints](#input-constraints) and an output slot. See\n+[Ref.Item.Fn](#ref.item.fn).\n+\n+An example of a `fn` type:\n+\n+~~~~\n+fn add(x: int, y: int) -> int {\n+  ret x + y;\n+}\n+\n+let int x = add(5,7);\n+\n+type binop = fn(int,int) -> int;\n+let bo: binop = add;\n+x = bo(5,7);\n+~~~~\n+\n+\n+\n+## Typestate system\n+\n # Memory and concurrency models\n \n Rust has a memory model centered around concurrently-executing _tasks_. Thus"}]}