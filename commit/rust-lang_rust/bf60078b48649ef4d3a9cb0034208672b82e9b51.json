{"sha": "bf60078b48649ef4d3a9cb0034208672b82e9b51", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJmNjAwNzhiNDg2NDllZjRkM2E5Y2IwMDM0MjA4NjcyYjgyZTliNTE=", "commit": {"author": {"name": "Jonathan Reem", "email": "jonathan.reem@gmail.com", "date": "2016-01-30T07:36:38Z"}, "committer": {"name": "Jonathan Reem", "email": "jonathan.reem@gmail.com", "date": "2016-01-30T21:29:19Z"}, "message": "Change MutexGuard and RwLockWriteGuard to store &mut T not &UnsafeCell<T>\n\nThis centralizes the unsafety of converting from UnsafeCell<T> to &mut T.", "tree": {"sha": "f415010ec54bdbc0538ab52852d767d4c3f82a0c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f415010ec54bdbc0538ab52852d767d4c3f82a0c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bf60078b48649ef4d3a9cb0034208672b82e9b51", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bf60078b48649ef4d3a9cb0034208672b82e9b51", "html_url": "https://github.com/rust-lang/rust/commit/bf60078b48649ef4d3a9cb0034208672b82e9b51", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bf60078b48649ef4d3a9cb0034208672b82e9b51/comments", "author": {"login": "reem", "id": 4745181, "node_id": "MDQ6VXNlcjQ3NDUxODE=", "avatar_url": "https://avatars.githubusercontent.com/u/4745181?v=4", "gravatar_id": "", "url": "https://api.github.com/users/reem", "html_url": "https://github.com/reem", "followers_url": "https://api.github.com/users/reem/followers", "following_url": "https://api.github.com/users/reem/following{/other_user}", "gists_url": "https://api.github.com/users/reem/gists{/gist_id}", "starred_url": "https://api.github.com/users/reem/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/reem/subscriptions", "organizations_url": "https://api.github.com/users/reem/orgs", "repos_url": "https://api.github.com/users/reem/repos", "events_url": "https://api.github.com/users/reem/events{/privacy}", "received_events_url": "https://api.github.com/users/reem/received_events", "type": "User", "site_admin": false}, "committer": {"login": "reem", "id": 4745181, "node_id": "MDQ6VXNlcjQ3NDUxODE=", "avatar_url": "https://avatars.githubusercontent.com/u/4745181?v=4", "gravatar_id": "", "url": "https://api.github.com/users/reem", "html_url": "https://github.com/reem", "followers_url": "https://api.github.com/users/reem/followers", "following_url": "https://api.github.com/users/reem/following{/other_user}", "gists_url": "https://api.github.com/users/reem/gists{/gist_id}", "starred_url": "https://api.github.com/users/reem/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/reem/subscriptions", "organizations_url": "https://api.github.com/users/reem/orgs", "repos_url": "https://api.github.com/users/reem/repos", "events_url": "https://api.github.com/users/reem/events{/privacy}", "received_events_url": "https://api.github.com/users/reem/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a4343e99c0e38bcb31386d48a6682e3a1896a0cc", "url": "https://api.github.com/repos/rust-lang/rust/commits/a4343e99c0e38bcb31386d48a6682e3a1896a0cc", "html_url": "https://github.com/rust-lang/rust/commit/a4343e99c0e38bcb31386d48a6682e3a1896a0cc"}], "stats": {"total": 84, "additions": 46, "deletions": 38}, "files": [{"sha": "ab566f3f94583a222d5d6b005b4021cd72136f2b", "filename": "src/libstd/sync/mutex.rs", "status": "modified", "additions": 19, "deletions": 18, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/bf60078b48649ef4d3a9cb0034208672b82e9b51/src%2Flibstd%2Fsync%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf60078b48649ef4d3a9cb0034208672b82e9b51/src%2Flibstd%2Fsync%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmutex.rs?ref=bf60078b48649ef4d3a9cb0034208672b82e9b51", "patch": "@@ -172,7 +172,7 @@ pub struct MutexGuard<'a, T: ?Sized + 'a> {\n     // funny underscores due to how Deref/DerefMut currently work (they\n     // disregard field privacy).\n     __lock: &'a StaticMutex,\n-    __data: &'a UnsafeCell<T>,\n+    __data: &'a mut T,\n     __poison: poison::Guard,\n }\n \n@@ -212,7 +212,7 @@ impl<T: ?Sized> Mutex<T> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn lock(&self) -> LockResult<MutexGuard<T>> {\n         unsafe { self.inner.lock.lock() }\n-        MutexGuard::new(&*self.inner, &self.data)\n+        unsafe { MutexGuard::new(&*self.inner, &self.data) }\n     }\n \n     /// Attempts to acquire this lock.\n@@ -231,7 +231,7 @@ impl<T: ?Sized> Mutex<T> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn try_lock(&self) -> TryLockResult<MutexGuard<T>> {\n         if unsafe { self.inner.lock.try_lock() } {\n-            Ok(try!(MutexGuard::new(&*self.inner, &self.data)))\n+            Ok(try!(unsafe { MutexGuard::new(&*self.inner, &self.data) }))\n         } else {\n             Err(TryLockError::WouldBlock)\n         }\n@@ -339,14 +339,14 @@ impl StaticMutex {\n     #[inline]\n     pub fn lock(&'static self) -> LockResult<MutexGuard<()>> {\n         unsafe { self.lock.lock() }\n-        MutexGuard::new(self, &DUMMY.0)\n+        unsafe { MutexGuard::new(self, &DUMMY.0) }\n     }\n \n     /// Attempts to grab this lock, see `Mutex::try_lock`\n     #[inline]\n     pub fn try_lock(&'static self) -> TryLockResult<MutexGuard<()>> {\n         if unsafe { self.lock.try_lock() } {\n-            Ok(try!(MutexGuard::new(self, &DUMMY.0)))\n+            Ok(try!(unsafe { MutexGuard::new(self, &DUMMY.0) }))\n         } else {\n             Err(TryLockError::WouldBlock)\n         }\n@@ -369,12 +369,12 @@ impl StaticMutex {\n \n impl<'mutex, T: ?Sized> MutexGuard<'mutex, T> {\n \n-    fn new(lock: &'mutex StaticMutex, data: &'mutex UnsafeCell<T>)\n+    unsafe fn new(lock: &'mutex StaticMutex, data: &'mutex UnsafeCell<T>)\n            -> LockResult<MutexGuard<'mutex, T>> {\n         poison::map_result(lock.poison.borrow(), |guard| {\n             MutexGuard {\n                 __lock: lock,\n-                __data: data,\n+                __data: &mut *data.get(),\n                 __poison: guard,\n             }\n         })\n@@ -385,7 +385,10 @@ impl<'mutex, T: ?Sized> MutexGuard<'mutex, T> {\n     /// Applies the supplied closure to the data, returning a new lock\n     /// guard referencing the borrow returned by the closure.\n     ///\n+    /// # Examples\n+    ///\n     /// ```rust\n+    /// # #![feature(guard_map)]\n     /// # use std::sync::{Mutex, MutexGuard};\n     /// let x = Mutex::new(vec![1, 2]);\n     ///\n@@ -401,13 +404,15 @@ impl<'mutex, T: ?Sized> MutexGuard<'mutex, T> {\n                issue = \"0\")]\n     pub fn map<U: ?Sized, F>(this: Self, cb: F) -> MutexGuard<'mutex, U>\n     where F: FnOnce(&'mutex mut T) -> &'mutex mut U {\n-        let new_data = unsafe {\n-            let data = cb(&mut *this.__data.get());\n-            mem::transmute::<&'mutex mut U, &'mutex UnsafeCell<U>>(data)\n-        };\n+        // Compute the new data while still owning the original lock\n+        // in order to correctly poison if the callback panics.\n+        let data = unsafe { ptr::read(&this.__data) };\n+        let new_data = cb(data);\n \n-        let lock = unsafe { ptr::read(&this.__lock) };\n+        // We don't want to unlock the lock by running the destructor of the\n+        // original lock, so just read the fields we need and forget it.\n         let poison = unsafe { ptr::read(&this.__poison) };\n+        let lock = unsafe { ptr::read(&this.__lock) };\n         mem::forget(this);\n \n         MutexGuard {\n@@ -422,16 +427,12 @@ impl<'mutex, T: ?Sized> MutexGuard<'mutex, T> {\n impl<'mutex, T: ?Sized> Deref for MutexGuard<'mutex, T> {\n     type Target = T;\n \n-    fn deref(&self) -> &T {\n-        unsafe { &*self.__data.get() }\n-    }\n+    fn deref(&self) -> &T {self.__data }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'mutex, T: ?Sized> DerefMut for MutexGuard<'mutex, T> {\n-    fn deref_mut(&mut self) -> &mut T {\n-        unsafe { &mut *self.__data.get() }\n-    }\n+    fn deref_mut(&mut self) -> &mut T { self.__data }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "7c1fcd6dea7c72fcc4c82c9dfc00c48377314167", "filename": "src/libstd/sync/rwlock.rs", "status": "modified", "additions": 27, "deletions": 20, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/bf60078b48649ef4d3a9cb0034208672b82e9b51/src%2Flibstd%2Fsync%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf60078b48649ef4d3a9cb0034208672b82e9b51/src%2Flibstd%2Fsync%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Frwlock.rs?ref=bf60078b48649ef4d3a9cb0034208672b82e9b51", "patch": "@@ -133,7 +133,7 @@ impl<'a, T: ?Sized> !marker::Send for RwLockReadGuard<'a, T> {}\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct RwLockWriteGuard<'a, T: ?Sized + 'a> {\n     __lock: &'a StaticRwLock,\n-    __data: &'a UnsafeCell<T>,\n+    __data: &'a mut T,\n     __poison: poison::Guard,\n }\n \n@@ -178,7 +178,7 @@ impl<T: ?Sized> RwLock<T> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn read(&self) -> LockResult<RwLockReadGuard<T>> {\n         unsafe { self.inner.lock.read() }\n-        RwLockReadGuard::new(&*self.inner, &self.data)\n+        unsafe { RwLockReadGuard::new(&*self.inner, &self.data) }\n     }\n \n     /// Attempts to acquire this rwlock with shared read access.\n@@ -202,7 +202,7 @@ impl<T: ?Sized> RwLock<T> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn try_read(&self) -> TryLockResult<RwLockReadGuard<T>> {\n         if unsafe { self.inner.lock.try_read() } {\n-            Ok(try!(RwLockReadGuard::new(&*self.inner, &self.data)))\n+            Ok(try!(unsafe { RwLockReadGuard::new(&*self.inner, &self.data) }))\n         } else {\n             Err(TryLockError::WouldBlock)\n         }\n@@ -226,7 +226,7 @@ impl<T: ?Sized> RwLock<T> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn write(&self) -> LockResult<RwLockWriteGuard<T>> {\n         unsafe { self.inner.lock.write() }\n-        RwLockWriteGuard::new(&*self.inner, &self.data)\n+        unsafe { RwLockWriteGuard::new(&*self.inner, &self.data) }\n     }\n \n     /// Attempts to lock this rwlock with exclusive write access.\n@@ -250,7 +250,7 @@ impl<T: ?Sized> RwLock<T> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn try_write(&self) -> TryLockResult<RwLockWriteGuard<T>> {\n         if unsafe { self.inner.lock.try_write() } {\n-            Ok(try!(RwLockWriteGuard::new(&*self.inner, &self.data)))\n+            Ok(try!(unsafe { RwLockWriteGuard::new(&*self.inner, &self.data) }))\n         } else {\n             Err(TryLockError::WouldBlock)\n         }\n@@ -361,7 +361,7 @@ impl StaticRwLock {\n     #[inline]\n     pub fn read(&'static self) -> LockResult<RwLockReadGuard<'static, ()>> {\n         unsafe { self.lock.read() }\n-        RwLockReadGuard::new(self, &DUMMY.0)\n+        unsafe { RwLockReadGuard::new(self, &DUMMY.0) }\n     }\n \n     /// Attempts to acquire this lock with shared read access.\n@@ -371,7 +371,7 @@ impl StaticRwLock {\n     pub fn try_read(&'static self)\n                     -> TryLockResult<RwLockReadGuard<'static, ()>> {\n         if unsafe { self.lock.try_read() } {\n-            Ok(try!(RwLockReadGuard::new(self, &DUMMY.0)))\n+            unsafe { Ok(try!(RwLockReadGuard::new(self, &DUMMY.0))) }\n         } else {\n             Err(TryLockError::WouldBlock)\n         }\n@@ -384,7 +384,7 @@ impl StaticRwLock {\n     #[inline]\n     pub fn write(&'static self) -> LockResult<RwLockWriteGuard<'static, ()>> {\n         unsafe { self.lock.write() }\n-        RwLockWriteGuard::new(self, &DUMMY.0)\n+        unsafe { RwLockWriteGuard::new(self, &DUMMY.0) }\n     }\n \n     /// Attempts to lock this rwlock with exclusive write access.\n@@ -394,7 +394,7 @@ impl StaticRwLock {\n     pub fn try_write(&'static self)\n                      -> TryLockResult<RwLockWriteGuard<'static, ()>> {\n         if unsafe { self.lock.try_write() } {\n-            Ok(try!(RwLockWriteGuard::new(self, &DUMMY.0)))\n+            Ok(unsafe { try!(RwLockWriteGuard::new(self, &DUMMY.0)) })\n         } else {\n             Err(TryLockError::WouldBlock)\n         }\n@@ -412,12 +412,12 @@ impl StaticRwLock {\n }\n \n impl<'rwlock, T: ?Sized> RwLockReadGuard<'rwlock, T> {\n-    fn new(lock: &'rwlock StaticRwLock, data: &'rwlock UnsafeCell<T>)\n+    unsafe fn new(lock: &'rwlock StaticRwLock, data: &'rwlock UnsafeCell<T>)\n            -> LockResult<RwLockReadGuard<'rwlock, T>> {\n         poison::map_result(lock.poison.borrow(), |_| {\n             RwLockReadGuard {\n                 __lock: lock,\n-                __data: unsafe { &*data.get() },\n+                __data: &*data.get(),\n             }\n         })\n     }\n@@ -427,7 +427,10 @@ impl<'rwlock, T: ?Sized> RwLockReadGuard<'rwlock, T> {\n     /// Applies the supplied closure to the data, returning a new lock\n     /// guard referencing the borrow returned by the closure.\n     ///\n+    /// # Examples\n+    ///\n     /// ```rust\n+    /// # #![feature(guard_map)]\n     /// # use std::sync::{RwLockReadGuard, RwLock};\n     /// let x = RwLock::new(vec![1, 2]);\n     ///\n@@ -451,12 +454,12 @@ impl<'rwlock, T: ?Sized> RwLockReadGuard<'rwlock, T> {\n }\n \n impl<'rwlock, T: ?Sized> RwLockWriteGuard<'rwlock, T> {\n-    fn new(lock: &'rwlock StaticRwLock, data: &'rwlock UnsafeCell<T>)\n+    unsafe fn new(lock: &'rwlock StaticRwLock, data: &'rwlock UnsafeCell<T>)\n            -> LockResult<RwLockWriteGuard<'rwlock, T>> {\n         poison::map_result(lock.poison.borrow(), |guard| {\n             RwLockWriteGuard {\n                 __lock: lock,\n-                __data: data,\n+                __data: &mut *data.get(),\n                 __poison: guard,\n             }\n         })\n@@ -467,7 +470,10 @@ impl<'rwlock, T: ?Sized> RwLockWriteGuard<'rwlock, T> {\n     /// Applies the supplied closure to the data, returning a new lock\n     /// guard referencing the borrow returned by the closure.\n     ///\n+    /// # Examples\n+    ///\n     /// ```rust\n+    /// # #![feature(guard_map)]\n     /// # use std::sync::{RwLockWriteGuard, RwLock};\n     /// let x = RwLock::new(vec![1, 2]);\n     ///\n@@ -485,11 +491,13 @@ impl<'rwlock, T: ?Sized> RwLockWriteGuard<'rwlock, T> {\n                issue = \"0\")]\n     pub fn map<U: ?Sized, F>(this: Self, cb: F) -> RwLockWriteGuard<'rwlock, U>\n     where F: FnOnce(&'rwlock mut T) -> &'rwlock mut U {\n-        let new_data = unsafe {\n-            let data: &'rwlock mut T = &mut *this.__data.get();\n-            mem::transmute::<&'rwlock mut U, &'rwlock UnsafeCell<U>>(cb(data))\n-        };\n+        // Compute the new data while still owning the original lock\n+        // in order to correctly poison if the callback panics.\n+        let data = unsafe { ptr::read(&this.__data) };\n+        let new_data = cb(data);\n \n+        // We don't want to unlock the lock by running the destructor of the\n+        // original lock, so just read the fields we need and forget it.\n         let poison = unsafe { ptr::read(&this.__poison) };\n         let lock = unsafe { ptr::read(&this.__lock) };\n         mem::forget(this);\n@@ -513,13 +521,12 @@ impl<'rwlock, T: ?Sized> Deref for RwLockReadGuard<'rwlock, T> {\n impl<'rwlock, T: ?Sized> Deref for RwLockWriteGuard<'rwlock, T> {\n     type Target = T;\n \n-    fn deref(&self) -> &T { unsafe { &*self.__data.get() } }\n+    fn deref(&self) -> &T { self.__data }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'rwlock, T: ?Sized> DerefMut for RwLockWriteGuard<'rwlock, T> {\n-    fn deref_mut(&mut self) -> &mut T {\n-        unsafe { &mut *self.__data.get() }\n+    fn deref_mut(&mut self) -> &mut T { self.__data\n     }\n }\n "}]}