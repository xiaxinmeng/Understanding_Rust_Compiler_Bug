{"sha": "d9cd4a33f53689bc0847775669a14f666a138fd7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ5Y2Q0YTMzZjUzNjg5YmMwODQ3Nzc1NjY5YTE0ZjY2NmExMzhmZDc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-09-01T05:41:22Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-09-01T05:41:22Z"}, "message": "Auto merge of #76047 - Dylan-DPC:rename/maybe, r=RalfJung\n\nrename get_{ref, mut} to assume_init_{ref,mut} in Maybeuninit\n\nReferences #63568\n\nRework with comments addressed from #66174\n\nHave replaced most of the occurrences I've found, hopefully didn't miss out anything\n\nr? @RalfJung\n\n(thanks @danielhenrymantilla for the initial work on this)", "tree": {"sha": "24ce504a4585e8a47614d43144214a4fc326b028", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/24ce504a4585e8a47614d43144214a4fc326b028"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d9cd4a33f53689bc0847775669a14f666a138fd7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d9cd4a33f53689bc0847775669a14f666a138fd7", "html_url": "https://github.com/rust-lang/rust/commit/d9cd4a33f53689bc0847775669a14f666a138fd7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d9cd4a33f53689bc0847775669a14f666a138fd7/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "445f34bb144c5b163163d8243e9845c644d3662d", "url": "https://api.github.com/repos/rust-lang/rust/commits/445f34bb144c5b163163d8243e9845c644d3662d", "html_url": "https://github.com/rust-lang/rust/commit/445f34bb144c5b163163d8243e9845c644d3662d"}, {"sha": "943911cc8bc173763a76fcc20dc4d75274e0cd9b", "url": "https://api.github.com/repos/rust-lang/rust/commits/943911cc8bc173763a76fcc20dc4d75274e0cd9b", "html_url": "https://github.com/rust-lang/rust/commit/943911cc8bc173763a76fcc20dc4d75274e0cd9b"}], "stats": {"total": 82, "additions": 41, "deletions": 41}, "files": [{"sha": "7f9ab5357d6973d74c945ce434cee9319d6aaf4c", "filename": "library/core/src/fmt/float.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/d9cd4a33f53689bc0847775669a14f666a138fd7/library%2Fcore%2Fsrc%2Ffmt%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9cd4a33f53689bc0847775669a14f666a138fd7/library%2Fcore%2Fsrc%2Ffmt%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ffmt%2Ffloat.rs?ref=d9cd4a33f53689bc0847775669a14f666a138fd7", "patch": "@@ -14,11 +14,11 @@ fn float_to_decimal_common_exact<T>(\n where\n     T: flt2dec::DecodableFloat,\n {\n-    // SAFETY: Possible undefined behavior, see FIXME(#53491)\n+    // SAFETY: Possible undefined behavior, see FIXME(#76092)\n     unsafe {\n         let mut buf = MaybeUninit::<[u8; 1024]>::uninit(); // enough for f32 and f64\n         let mut parts = MaybeUninit::<[flt2dec::Part<'_>; 4]>::uninit();\n-        // FIXME(#53491): This is calling `get_mut` on an uninitialized\n+        // FIXME(#76092): This is calling `assume_init_mut` on an uninitialized\n         // `MaybeUninit` (here and elsewhere in this file). Revisit this once\n         // we decided whether that is valid or not.\n         // We can do this only because we are libstd and coupled to the compiler.\n@@ -28,8 +28,8 @@ where\n             *num,\n             sign,\n             precision,\n-            buf.get_mut(),\n-            parts.get_mut(),\n+            buf.assume_init_mut(),\n+            parts.assume_init_mut(),\n         );\n         fmt.pad_formatted_parts(&formatted)\n     }\n@@ -47,19 +47,19 @@ fn float_to_decimal_common_shortest<T>(\n where\n     T: flt2dec::DecodableFloat,\n {\n-    // SAFETY: Possible undefined behavior, see FIXME(#53491)\n+    // SAFETY: Possible undefined behavior, see FIXME(#76092)\n     unsafe {\n         // enough for f32 and f64\n         let mut buf = MaybeUninit::<[u8; flt2dec::MAX_SIG_DIGITS]>::uninit();\n         let mut parts = MaybeUninit::<[flt2dec::Part<'_>; 4]>::uninit();\n-        // FIXME(#53491)\n+        // FIXME(#76092)\n         let formatted = flt2dec::to_shortest_str(\n             flt2dec::strategy::grisu::format_shortest,\n             *num,\n             sign,\n             precision,\n-            buf.get_mut(),\n-            parts.get_mut(),\n+            buf.assume_init_mut(),\n+            parts.assume_init_mut(),\n         );\n         fmt.pad_formatted_parts(&formatted)\n     }\n@@ -103,19 +103,19 @@ fn float_to_exponential_common_exact<T>(\n where\n     T: flt2dec::DecodableFloat,\n {\n-    // SAFETY: Possible undefined behavior, see FIXME(#53491)\n+    // SAFETY: Possible undefined behavior, see FIXME(#76092)\n     unsafe {\n         let mut buf = MaybeUninit::<[u8; 1024]>::uninit(); // enough for f32 and f64\n         let mut parts = MaybeUninit::<[flt2dec::Part<'_>; 6]>::uninit();\n-        // FIXME(#53491)\n+        // FIXME(#76092)\n         let formatted = flt2dec::to_exact_exp_str(\n             flt2dec::strategy::grisu::format_exact,\n             *num,\n             sign,\n             precision,\n             upper,\n-            buf.get_mut(),\n-            parts.get_mut(),\n+            buf.assume_init_mut(),\n+            parts.assume_init_mut(),\n         );\n         fmt.pad_formatted_parts(&formatted)\n     }\n@@ -133,20 +133,20 @@ fn float_to_exponential_common_shortest<T>(\n where\n     T: flt2dec::DecodableFloat,\n {\n-    // SAFETY: Possible undefined behavior, see FIXME(#53491)\n+    // SAFETY: Possible undefined behavior, see FIXME(#76092)\n     unsafe {\n         // enough for f32 and f64\n         let mut buf = MaybeUninit::<[u8; flt2dec::MAX_SIG_DIGITS]>::uninit();\n         let mut parts = MaybeUninit::<[flt2dec::Part<'_>; 6]>::uninit();\n-        // FIXME(#53491)\n+        // FIXME(#76092)\n         let formatted = flt2dec::to_shortest_exp_str(\n             flt2dec::strategy::grisu::format_shortest,\n             *num,\n             sign,\n             (0, 0),\n             upper,\n-            buf.get_mut(),\n-            parts.get_mut(),\n+            buf.assume_init_mut(),\n+            parts.assume_init_mut(),\n         );\n         fmt.pad_formatted_parts(&formatted)\n     }"}, {"sha": "a79d9e25f34fcaccdfd8d5e2f7685ff5c3c69f22", "filename": "library/core/src/mem/maybe_uninit.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/d9cd4a33f53689bc0847775669a14f666a138fd7/library%2Fcore%2Fsrc%2Fmem%2Fmaybe_uninit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9cd4a33f53689bc0847775669a14f666a138fd7/library%2Fcore%2Fsrc%2Fmem%2Fmaybe_uninit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fmem%2Fmaybe_uninit.rs?ref=d9cd4a33f53689bc0847775669a14f666a138fd7", "patch": "@@ -369,7 +369,7 @@ impl<T> MaybeUninit<T> {\n     pub fn write(&mut self, val: T) -> &mut T {\n         unsafe {\n             self.value = ManuallyDrop::new(val);\n-            self.get_mut()\n+            self.assume_init_mut()\n         }\n     }\n \n@@ -601,7 +601,7 @@ impl<T> MaybeUninit<T> {\n     /// // create a shared reference to it:\n     /// let x: &Vec<u32> = unsafe {\n     ///     // Safety: `x` has been initialized.\n-    ///     x.get_ref()\n+    ///     x.assume_init_ref()\n     /// };\n     /// assert_eq!(x, &vec![1, 2, 3]);\n     /// ```\n@@ -613,7 +613,7 @@ impl<T> MaybeUninit<T> {\n     /// use std::mem::MaybeUninit;\n     ///\n     /// let x = MaybeUninit::<Vec<u32>>::uninit();\n-    /// let x_vec: &Vec<u32> = unsafe { x.get_ref() };\n+    /// let x_vec: &Vec<u32> = unsafe { x.assume_init_ref() };\n     /// // We have created a reference to an uninitialized vector! This is undefined behavior. \u26a0\ufe0f\n     /// ```\n     ///\n@@ -624,14 +624,14 @@ impl<T> MaybeUninit<T> {\n     /// let b = MaybeUninit::<Cell<bool>>::uninit();\n     /// // Initialize the `MaybeUninit` using `Cell::set`:\n     /// unsafe {\n-    ///     b.get_ref().set(true);\n-    ///  // ^^^^^^^^^^^\n-    ///  // Reference to an uninitialized `Cell<bool>`: UB!\n+    ///     b.assume_init_ref().set(true);\n+    ///    // ^^^^^^^^^^^^^^^\n+    ///    // Reference to an uninitialized `Cell<bool>`: UB!\n     /// }\n     /// ```\n     #[unstable(feature = \"maybe_uninit_ref\", issue = \"63568\")]\n     #[inline(always)]\n-    pub unsafe fn get_ref(&self) -> &T {\n+    pub unsafe fn assume_init_ref(&self) -> &T {\n         // SAFETY: the caller must guarantee that `self` is initialized.\n         // This also means that `self` must be a `value` variant.\n         unsafe {\n@@ -650,7 +650,7 @@ impl<T> MaybeUninit<T> {\n     ///\n     /// Calling this when the content is not yet fully initialized causes undefined\n     /// behavior: it is up to the caller to guarantee that the `MaybeUninit<T>` really\n-    /// is in an initialized state. For instance, `.get_mut()` cannot be used to\n+    /// is in an initialized state. For instance, `.assume_init_mut()` cannot be used to\n     /// initialize a `MaybeUninit`.\n     ///\n     /// # Examples\n@@ -678,7 +678,7 @@ impl<T> MaybeUninit<T> {\n     /// // the `&mut MaybeUninit<[u8; 2048]>` to a `&mut [u8; 2048]`:\n     /// let buf: &mut [u8; 2048] = unsafe {\n     ///     // Safety: `buf` has been initialized.\n-    ///     buf.get_mut()\n+    ///     buf.assume_init_mut()\n     /// };\n     ///\n     /// // Now we can use `buf` as a normal slice:\n@@ -691,15 +691,15 @@ impl<T> MaybeUninit<T> {\n     ///\n     /// ### *Incorrect* usages of this method:\n     ///\n-    /// You cannot use `.get_mut()` to initialize a value:\n+    /// You cannot use `.assume_init_mut()` to initialize a value:\n     ///\n     /// ```rust,no_run\n     /// #![feature(maybe_uninit_ref)]\n     /// use std::mem::MaybeUninit;\n     ///\n     /// let mut b = MaybeUninit::<bool>::uninit();\n     /// unsafe {\n-    ///     *b.get_mut() = true;\n+    ///     *b.assume_init_mut() = true;\n     ///     // We have created a (mutable) reference to an uninitialized `bool`!\n     ///     // This is undefined behavior. \u26a0\ufe0f\n     /// }\n@@ -716,8 +716,8 @@ impl<T> MaybeUninit<T> {\n     /// fn read_chunk (reader: &'_ mut dyn io::Read) -> io::Result<[u8; 64]>\n     /// {\n     ///     let mut buffer = MaybeUninit::<[u8; 64]>::uninit();\n-    ///     reader.read_exact(unsafe { buffer.get_mut() })?;\n-    ///                             // ^^^^^^^^^^^^^^^^\n+    ///     reader.read_exact(unsafe { buffer.assume_init_mut() })?;\n+    ///                             // ^^^^^^^^^^^^^^^^^^^^^^^^\n     ///                             // (mutable) reference to uninitialized memory!\n     ///                             // This is undefined behavior.\n     ///     Ok(unsafe { buffer.assume_init() })\n@@ -737,23 +737,23 @@ impl<T> MaybeUninit<T> {\n     ///\n     /// let foo: Foo = unsafe {\n     ///     let mut foo = MaybeUninit::<Foo>::uninit();\n-    ///     ptr::write(&mut foo.get_mut().a as *mut u32, 1337);\n-    ///                  // ^^^^^^^^^^^^^\n+    ///     ptr::write(&mut foo.assume_init_mut().a as *mut u32, 1337);\n+    ///                  // ^^^^^^^^^^^^^^^^^^^^^\n     ///                  // (mutable) reference to uninitialized memory!\n     ///                  // This is undefined behavior.\n-    ///     ptr::write(&mut foo.get_mut().b as *mut u8, 42);\n-    ///                  // ^^^^^^^^^^^^^\n+    ///     ptr::write(&mut foo.assume_init_mut().b as *mut u8, 42);\n+    ///                  // ^^^^^^^^^^^^^^^^^^^^^\n     ///                  // (mutable) reference to uninitialized memory!\n     ///                  // This is undefined behavior.\n     ///     foo.assume_init()\n     /// };\n     /// ```\n-    // FIXME(#53491): We currently rely on the above being incorrect, i.e., we have references\n+    // FIXME(#76092): We currently rely on the above being incorrect, i.e., we have references\n     // to uninitialized data (e.g., in `libcore/fmt/float.rs`).  We should make\n     // a final decision about the rules before stabilization.\n     #[unstable(feature = \"maybe_uninit_ref\", issue = \"63568\")]\n     #[inline(always)]\n-    pub unsafe fn get_mut(&mut self) -> &mut T {\n+    pub unsafe fn assume_init_mut(&mut self) -> &mut T {\n         // SAFETY: the caller must guarantee that `self` is initialized.\n         // This also means that `self` must be a `value` variant.\n         unsafe {"}, {"sha": "b3df6f49dc490126471225647faed8ff475f3c67", "filename": "library/std/src/io/util.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d9cd4a33f53689bc0847775669a14f666a138fd7/library%2Fstd%2Fsrc%2Fio%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9cd4a33f53689bc0847775669a14f666a138fd7/library%2Fstd%2Fsrc%2Fio%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Futil.rs?ref=d9cd4a33f53689bc0847775669a14f666a138fd7", "patch": "@@ -52,24 +52,24 @@ where\n     W: Write,\n {\n     let mut buf = MaybeUninit::<[u8; super::DEFAULT_BUF_SIZE]>::uninit();\n-    // FIXME(#53491): This is calling `get_mut` and `get_ref` on an uninitialized\n+    // FIXME(#76092): This is calling `get_mut` and `get_ref` on an uninitialized\n     // `MaybeUninit`. Revisit this once we decided whether that is valid or not.\n     // This is still technically undefined behavior due to creating a reference\n     // to uninitialized data, but within libstd we can rely on more guarantees\n     // than if this code were in an external lib.\n     unsafe {\n-        reader.initializer().initialize(buf.get_mut());\n+        reader.initializer().initialize(buf.assume_init_mut());\n     }\n \n     let mut written = 0;\n     loop {\n-        let len = match reader.read(unsafe { buf.get_mut() }) {\n+        let len = match reader.read(unsafe { buf.assume_init_mut() }) {\n             Ok(0) => return Ok(written),\n             Ok(len) => len,\n             Err(ref e) if e.kind() == ErrorKind::Interrupted => continue,\n             Err(e) => return Err(e),\n         };\n-        writer.write_all(unsafe { &buf.get_ref()[..len] })?;\n+        writer.write_all(unsafe { &buf.assume_init_ref()[..len] })?;\n         written += len as u64;\n     }\n }"}, {"sha": "845e9d76a772b254b15db515d7d7d5a78c7e92c7", "filename": "library/std/src/lazy.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d9cd4a33f53689bc0847775669a14f666a138fd7/library%2Fstd%2Fsrc%2Flazy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9cd4a33f53689bc0847775669a14f666a138fd7/library%2Fstd%2Fsrc%2Flazy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Flazy.rs?ref=d9cd4a33f53689bc0847775669a14f666a138fd7", "patch": "@@ -379,13 +379,13 @@ impl<T> SyncOnceCell<T> {\n     /// Safety: The value must be initialized\n     unsafe fn get_unchecked(&self) -> &T {\n         debug_assert!(self.is_initialized());\n-        (&*self.value.get()).get_ref()\n+        (&*self.value.get()).assume_init_ref()\n     }\n \n     /// Safety: The value must be initialized\n     unsafe fn get_unchecked_mut(&mut self) -> &mut T {\n         debug_assert!(self.is_initialized());\n-        (&mut *self.value.get()).get_mut()\n+        (&mut *self.value.get()).assume_init_mut()\n     }\n }\n "}]}