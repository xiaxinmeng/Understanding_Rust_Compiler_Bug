{"sha": "fff822fead6249671cbcb090b24bce58fab38de0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZmZjgyMmZlYWQ2MjQ5NjcxY2JjYjA5MGIyNGJjZTU4ZmFiMzhkZTA=", "commit": {"author": {"name": "Lzu Tao", "email": "taolzu@gmail.com", "date": "2020-06-02T07:59:11Z"}, "committer": {"name": "Lzu Tao", "email": "taolzu@gmail.com", "date": "2020-06-10T01:35:47Z"}, "message": "Migrate to numeric associated consts", "tree": {"sha": "417a72d52d12d147a03535fe7cbe465b3bcdb695", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/417a72d52d12d147a03535fe7cbe465b3bcdb695"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fff822fead6249671cbcb090b24bce58fab38de0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fff822fead6249671cbcb090b24bce58fab38de0", "html_url": "https://github.com/rust-lang/rust/commit/fff822fead6249671cbcb090b24bce58fab38de0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fff822fead6249671cbcb090b24bce58fab38de0/comments", "author": {"login": "tesuji", "id": 15225902, "node_id": "MDQ6VXNlcjE1MjI1OTAy", "avatar_url": "https://avatars.githubusercontent.com/u/15225902?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tesuji", "html_url": "https://github.com/tesuji", "followers_url": "https://api.github.com/users/tesuji/followers", "following_url": "https://api.github.com/users/tesuji/following{/other_user}", "gists_url": "https://api.github.com/users/tesuji/gists{/gist_id}", "starred_url": "https://api.github.com/users/tesuji/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tesuji/subscriptions", "organizations_url": "https://api.github.com/users/tesuji/orgs", "repos_url": "https://api.github.com/users/tesuji/repos", "events_url": "https://api.github.com/users/tesuji/events{/privacy}", "received_events_url": "https://api.github.com/users/tesuji/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tesuji", "id": 15225902, "node_id": "MDQ6VXNlcjE1MjI1OTAy", "avatar_url": "https://avatars.githubusercontent.com/u/15225902?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tesuji", "html_url": "https://github.com/tesuji", "followers_url": "https://api.github.com/users/tesuji/followers", "following_url": "https://api.github.com/users/tesuji/following{/other_user}", "gists_url": "https://api.github.com/users/tesuji/gists{/gist_id}", "starred_url": "https://api.github.com/users/tesuji/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tesuji/subscriptions", "organizations_url": "https://api.github.com/users/tesuji/orgs", "repos_url": "https://api.github.com/users/tesuji/repos", "events_url": "https://api.github.com/users/tesuji/events{/privacy}", "received_events_url": "https://api.github.com/users/tesuji/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "283522400b5c13dfdf2b7e608e63a70ee8e3d7af", "url": "https://api.github.com/repos/rust-lang/rust/commits/283522400b5c13dfdf2b7e608e63a70ee8e3d7af", "html_url": "https://github.com/rust-lang/rust/commit/283522400b5c13dfdf2b7e608e63a70ee8e3d7af"}], "stats": {"total": 1003, "additions": 485, "deletions": 518}, "files": [{"sha": "0327a9f9a96e54d89c9dae49955706560faee84e", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fff822fead6249671cbcb090b24bce58fab38de0/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff822fead6249671cbcb090b24bce58fab38de0/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=fff822fead6249671cbcb090b24bce58fab38de0", "patch": "@@ -2034,7 +2034,7 @@ trait RcBoxPtr<T: ?Sized> {\n         // The reference count will never be zero when this is called;\n         // nevertheless, we insert an abort here to hint LLVM at\n         // an otherwise missed optimization.\n-        if strong == 0 || strong == usize::max_value() {\n+        if strong == 0 || strong == usize::MAX {\n             abort();\n         }\n         self.inner().strong.set(strong + 1);\n@@ -2058,7 +2058,7 @@ trait RcBoxPtr<T: ?Sized> {\n         // The reference count will never be zero when this is called;\n         // nevertheless, we insert an abort here to hint LLVM at\n         // an otherwise missed optimization.\n-        if weak == 0 || weak == usize::max_value() {\n+        if weak == 0 || weak == usize::MAX {\n             abort();\n         }\n         self.inner().weak.set(weak + 1);"}, {"sha": "e88385faf4fd4c57283645cf2a25adfe33c71933", "filename": "src/liballoc/rc/tests.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fff822fead6249671cbcb090b24bce58fab38de0/src%2Fliballoc%2Frc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff822fead6249671cbcb090b24bce58fab38de0/src%2Fliballoc%2Frc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc%2Ftests.rs?ref=fff822fead6249671cbcb090b24bce58fab38de0", "patch": "@@ -407,14 +407,14 @@ fn test_from_vec() {\n fn test_downcast() {\n     use std::any::Any;\n \n-    let r1: Rc<dyn Any> = Rc::new(i32::max_value());\n+    let r1: Rc<dyn Any> = Rc::new(i32::MAX);\n     let r2: Rc<dyn Any> = Rc::new(\"abc\");\n \n     assert!(r1.clone().downcast::<u32>().is_err());\n \n     let r1i32 = r1.downcast::<i32>();\n     assert!(r1i32.is_ok());\n-    assert_eq!(r1i32.unwrap(), Rc::new(i32::max_value()));\n+    assert_eq!(r1i32.unwrap(), Rc::new(i32::MAX));\n \n     assert!(r2.clone().downcast::<i32>().is_err());\n "}, {"sha": "6f08cd7f123be67c2d036e615f2a5286da21f493", "filename": "src/liballoc/sync/tests.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fff822fead6249671cbcb090b24bce58fab38de0/src%2Fliballoc%2Fsync%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff822fead6249671cbcb090b24bce58fab38de0/src%2Fliballoc%2Fsync%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fsync%2Ftests.rs?ref=fff822fead6249671cbcb090b24bce58fab38de0", "patch": "@@ -465,14 +465,14 @@ fn test_from_vec() {\n fn test_downcast() {\n     use std::any::Any;\n \n-    let r1: Arc<dyn Any + Send + Sync> = Arc::new(i32::max_value());\n+    let r1: Arc<dyn Any + Send + Sync> = Arc::new(i32::MAX);\n     let r2: Arc<dyn Any + Send + Sync> = Arc::new(\"abc\");\n \n     assert!(r1.clone().downcast::<u32>().is_err());\n \n     let r1i32 = r1.downcast::<i32>();\n     assert!(r1i32.is_ok());\n-    assert_eq!(r1i32.unwrap(), Arc::new(i32::max_value()));\n+    assert_eq!(r1i32.unwrap(), Arc::new(i32::MAX));\n \n     assert!(r2.clone().downcast::<i32>().is_err());\n "}, {"sha": "eee98d45340429f4f759f8bee607e8bd0ca2f5da", "filename": "src/liballoc/tests/str.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fff822fead6249671cbcb090b24bce58fab38de0/src%2Fliballoc%2Ftests%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff822fead6249671cbcb090b24bce58fab38de0/src%2Fliballoc%2Ftests%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fstr.rs?ref=fff822fead6249671cbcb090b24bce58fab38de0", "patch": "@@ -566,13 +566,13 @@ mod slice_index {\n                 data: \"hello\";\n                 // note: using 0 specifically ensures that the result of overflowing is 0..0,\n                 //       so that `get` doesn't simply return None for the wrong reason.\n-                bad: data[0..=usize::max_value()];\n+                bad: data[0..=usize::MAX];\n                 message: \"maximum usize\";\n             }\n \n             in mod rangetoinclusive {\n                 data: \"hello\";\n-                bad: data[..=usize::max_value()];\n+                bad: data[..=usize::MAX];\n                 message: \"maximum usize\";\n             }\n         }"}, {"sha": "a9813a8704f30e93cfd3a93e695a8b078b75c552", "filename": "src/liballoc/tests/vec.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/fff822fead6249671cbcb090b24bce58fab38de0/src%2Fliballoc%2Ftests%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff822fead6249671cbcb090b24bce58fab38de0/src%2Fliballoc%2Ftests%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fvec.rs?ref=fff822fead6249671cbcb090b24bce58fab38de0", "patch": "@@ -68,7 +68,7 @@ fn test_reserve() {\n \n #[test]\n fn test_zst_capacity() {\n-    assert_eq!(Vec::<()>::new().capacity(), usize::max_value());\n+    assert_eq!(Vec::<()>::new().capacity(), usize::MAX);\n }\n \n #[test]\n@@ -563,19 +563,19 @@ fn test_drain_inclusive_range() {\n \n #[test]\n fn test_drain_max_vec_size() {\n-    let mut v = Vec::<()>::with_capacity(usize::max_value());\n+    let mut v = Vec::<()>::with_capacity(usize::MAX);\n     unsafe {\n-        v.set_len(usize::max_value());\n+        v.set_len(usize::MAX);\n     }\n-    for _ in v.drain(usize::max_value() - 1..) {}\n-    assert_eq!(v.len(), usize::max_value() - 1);\n+    for _ in v.drain(usize::MAX - 1..) {}\n+    assert_eq!(v.len(), usize::MAX - 1);\n \n-    let mut v = Vec::<()>::with_capacity(usize::max_value());\n+    let mut v = Vec::<()>::with_capacity(usize::MAX);\n     unsafe {\n-        v.set_len(usize::max_value());\n+        v.set_len(usize::MAX);\n     }\n-    for _ in v.drain(usize::max_value() - 1..=usize::max_value() - 1) {}\n-    assert_eq!(v.len(), usize::max_value() - 1);\n+    for _ in v.drain(usize::MAX - 1..=usize::MAX - 1) {}\n+    assert_eq!(v.len(), usize::MAX - 1);\n }\n \n #[test]"}, {"sha": "cadc2e631b0fa28df1feaf056ad291ef2b1cd95d", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fff822fead6249671cbcb090b24bce58fab38de0/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff822fead6249671cbcb090b24bce58fab38de0/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=fff822fead6249671cbcb090b24bce58fab38de0", "patch": "@@ -1163,16 +1163,16 @@ impl<'b> BorrowRef<'b> {\n             // Incrementing borrow can result in a non-reading value (<= 0) in these cases:\n             // 1. It was < 0, i.e. there are writing borrows, so we can't allow a read borrow\n             //    due to Rust's reference aliasing rules\n-            // 2. It was isize::max_value() (the max amount of reading borrows) and it overflowed\n-            //    into isize::min_value() (the max amount of writing borrows) so we can't allow\n+            // 2. It was isize::MAX (the max amount of reading borrows) and it overflowed\n+            //    into isize::MIN (the max amount of writing borrows) so we can't allow\n             //    an additional read borrow because isize can't represent so many read borrows\n             //    (this can only happen if you mem::forget more than a small constant amount of\n             //    `Ref`s, which is not good practice)\n             None\n         } else {\n             // Incrementing borrow can result in a reading value (> 0) in these cases:\n             // 1. It was = 0, i.e. it wasn't borrowed, and we are taking the first read borrow\n-            // 2. It was > 0 and < isize::max_value(), i.e. there were read borrows, and isize\n+            // 2. It was > 0 and < isize::MAX, i.e. there were read borrows, and isize\n             //    is large enough to represent having one more read borrow\n             borrow.set(b);\n             Some(BorrowRef { borrow })\n@@ -1198,7 +1198,7 @@ impl Clone for BorrowRef<'_> {\n         debug_assert!(is_reading(borrow));\n         // Prevent the borrow counter from overflowing into\n         // a writing borrow.\n-        assert!(borrow != isize::max_value());\n+        assert!(borrow != isize::MAX);\n         self.borrow.set(borrow + 1);\n         BorrowRef { borrow: self.borrow }\n     }\n@@ -1489,7 +1489,7 @@ impl<'b> BorrowRefMut<'b> {\n         let borrow = self.borrow.get();\n         debug_assert!(is_writing(borrow));\n         // Prevent the borrow counter from underflowing.\n-        assert!(borrow != isize::min_value());\n+        assert!(borrow != isize::MIN);\n         self.borrow.set(borrow - 1);\n         BorrowRefMut { borrow: self.borrow }\n     }"}, {"sha": "5ff52a9a11b5a348bd543f2907130f52f63d833e", "filename": "src/libcore/convert/num.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fff822fead6249671cbcb090b24bce58fab38de0/src%2Flibcore%2Fconvert%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff822fead6249671cbcb090b24bce58fab38de0/src%2Flibcore%2Fconvert%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fconvert%2Fnum.rs?ref=fff822fead6249671cbcb090b24bce58fab38de0", "patch": "@@ -217,7 +217,7 @@ macro_rules! try_from_upper_bounded {\n             /// is outside of the range of the target type.\n             #[inline]\n             fn try_from(u: $source) -> Result<Self, Self::Error> {\n-                if u > (Self::max_value() as $source) {\n+                if u > (Self::MAX as $source) {\n                     Err(TryFromIntError(()))\n                 } else {\n                     Ok(u as Self)\n@@ -239,8 +239,8 @@ macro_rules! try_from_both_bounded {\n             /// is outside of the range of the target type.\n             #[inline]\n             fn try_from(u: $source) -> Result<Self, Self::Error> {\n-                let min = Self::min_value() as $source;\n-                let max = Self::max_value() as $source;\n+                let min = Self::MIN as $source;\n+                let max = Self::MAX as $source;\n                 if u < min || u > max {\n                     Err(TryFromIntError(()))\n                 } else {"}, {"sha": "3e5114f336119a0ff73ad08773589d4f2d5272eb", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 33, "deletions": 33, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/fff822fead6249671cbcb090b24bce58fab38de0/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff822fead6249671cbcb090b24bce58fab38de0/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=fff822fead6249671cbcb090b24bce58fab38de0", "patch": "@@ -750,9 +750,9 @@ $EndFeature, \"\n         }\n \n         doc_comment! {\n-            concat!(\"Unchecked integer addition. Computes `self + rhs, assuming overflow\n+            concat!(\"Unchecked integer addition. Computes `self + rhs`, assuming overflow\n cannot occur. This results in undefined behavior when `self + rhs > \", stringify!($SelfT),\n-\"::max_value()` or `self + rhs < \", stringify!($SelfT), \"::min_value()`.\"),\n+\"::MAX` or `self + rhs < \", stringify!($SelfT), \"::MIN`.\"),\n             #[unstable(\n                 feature = \"unchecked_math\",\n                 reason = \"niche optimization path\",\n@@ -792,9 +792,9 @@ $EndFeature, \"\n         }\n \n         doc_comment! {\n-            concat!(\"Unchecked integer subtraction. Computes `self - rhs, assuming overflow\n+            concat!(\"Unchecked integer subtraction. Computes `self - rhs`, assuming overflow\n cannot occur. This results in undefined behavior when `self - rhs > \", stringify!($SelfT),\n-\"::max_value()` or `self - rhs < \", stringify!($SelfT), \"::min_value()`.\"),\n+\"::MAX` or `self - rhs < \", stringify!($SelfT), \"::MIN`.\"),\n             #[unstable(\n                 feature = \"unchecked_math\",\n                 reason = \"niche optimization path\",\n@@ -834,9 +834,9 @@ $EndFeature, \"\n         }\n \n         doc_comment! {\n-            concat!(\"Unchecked integer multiplication. Computes `self * rhs, assuming overflow\n+            concat!(\"Unchecked integer multiplication. Computes `self * rhs`, assuming overflow\n cannot occur. This results in undefined behavior when `self * rhs > \", stringify!($SelfT),\n-\"::max_value()` or `self * rhs < \", stringify!($SelfT), \"::min_value()`.\"),\n+\"::MAX` or `self * rhs < \", stringify!($SelfT), \"::MIN`.\"),\n             #[unstable(\n                 feature = \"unchecked_math\",\n                 reason = \"niche optimization path\",\n@@ -871,7 +871,7 @@ $EndFeature, \"\n                           without modifying the original\"]\n             #[inline]\n             pub const fn checked_div(self, rhs: Self) -> Option<Self> {\n-                if rhs == 0 || (self == Self::min_value() && rhs == -1) {\n+                if rhs == 0 || (self == Self::MIN && rhs == -1) {\n                     None\n                 } else {\n                     // SAFETY: div by zero and by INT_MIN have been checked above\n@@ -900,7 +900,7 @@ assert_eq!((1\", stringify!($SelfT), \").checked_div_euclid(0), None);\n                           without modifying the original\"]\n             #[inline]\n             pub const fn checked_div_euclid(self, rhs: Self) -> Option<Self> {\n-                if rhs == 0 || (self == Self::min_value() && rhs == -1) {\n+                if rhs == 0 || (self == Self::MIN && rhs == -1) {\n                     None\n                 } else {\n                     Some(self.div_euclid(rhs))\n@@ -929,7 +929,7 @@ $EndFeature, \"\n                           without modifying the original\"]\n             #[inline]\n             pub const fn checked_rem(self, rhs: Self) -> Option<Self> {\n-                if rhs == 0 || (self == Self::min_value() && rhs == -1) {\n+                if rhs == 0 || (self == Self::MIN && rhs == -1) {\n                     None\n                 } else {\n                     // SAFETY: div by zero and by INT_MIN have been checked above\n@@ -957,7 +957,7 @@ assert_eq!(\", stringify!($SelfT), \"::MIN.checked_rem_euclid(-1), None);\n                           without modifying the original\"]\n             #[inline]\n             pub const fn checked_rem_euclid(self, rhs: Self) -> Option<Self> {\n-                if rhs == 0 || (self == Self::min_value() && rhs == -1) {\n+                if rhs == 0 || (self == Self::MIN && rhs == -1) {\n                     None\n                 } else {\n                     Some(self.rem_euclid(rhs))\n@@ -1236,9 +1236,9 @@ $EndFeature, \"\n                 match self.checked_mul(rhs) {\n                     Some(x) => x,\n                     None => if (self < 0) == (rhs < 0) {\n-                        Self::max_value()\n+                        Self::MAX\n                     } else {\n-                        Self::min_value()\n+                        Self::MIN\n                     }\n                 }\n             }\n@@ -1267,8 +1267,8 @@ $EndFeature, \"\n             pub const fn saturating_pow(self, exp: u32) -> Self {\n                 match self.checked_pow(exp) {\n                     Some(x) => x,\n-                    None if self < 0 && exp % 2 == 1 => Self::min_value(),\n-                    None => Self::max_value(),\n+                    None if self < 0 && exp % 2 == 1 => Self::MIN,\n+                    None => Self::MAX,\n                 }\n             }\n         }\n@@ -1738,7 +1738,7 @@ $EndFeature, \"\n             #[must_use = \"this returns the result of the operation, \\\n                           without modifying the original\"]\n             pub const fn overflowing_div(self, rhs: Self) -> (Self, bool) {\n-                if self == Self::min_value() && rhs == -1 {\n+                if self == Self::MIN && rhs == -1 {\n                     (self, true)\n                 } else {\n                     (self / rhs, false)\n@@ -1771,7 +1771,7 @@ assert_eq!(\", stringify!($SelfT), \"::MIN.overflowing_div_euclid(-1), (\", stringi\n             #[must_use = \"this returns the result of the operation, \\\n                           without modifying the original\"]\n             pub const fn overflowing_div_euclid(self, rhs: Self) -> (Self, bool) {\n-                if self == Self::min_value() && rhs == -1 {\n+                if self == Self::MIN && rhs == -1 {\n                     (self, true)\n                 } else {\n                     (self.div_euclid(rhs), false)\n@@ -1805,7 +1805,7 @@ $EndFeature, \"\n             #[must_use = \"this returns the result of the operation, \\\n                           without modifying the original\"]\n             pub const fn overflowing_rem(self, rhs: Self) -> (Self, bool) {\n-                if self == Self::min_value() && rhs == -1 {\n+                if self == Self::MIN && rhs == -1 {\n                     (0, true)\n                 } else {\n                     (self % rhs, false)\n@@ -1838,7 +1838,7 @@ assert_eq!(\", stringify!($SelfT), \"::MIN.overflowing_rem_euclid(-1), (0, true));\n                           without modifying the original\"]\n             #[inline]\n             pub const fn overflowing_rem_euclid(self, rhs: Self) -> (Self, bool) {\n-                if self == Self::min_value() && rhs == -1 {\n+                if self == Self::MIN && rhs == -1 {\n                     (0, true)\n                 } else {\n                     (self.rem_euclid(rhs), false)\n@@ -1869,8 +1869,8 @@ assert_eq!(\", stringify!($SelfT), \"::MIN.overflowing_neg(), (\", stringify!($Self\n             #[allow(unused_attributes)]\n             #[allow_internal_unstable(const_if_match)]\n             pub const fn overflowing_neg(self) -> (Self, bool) {\n-                if self == Self::min_value() {\n-                    (Self::min_value(), true)\n+                if self == Self::MIN {\n+                    (Self::MIN, true)\n                 } else {\n                     (-self, false)\n                 }\n@@ -1952,7 +1952,7 @@ $EndFeature, \"\n             #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n             #[inline]\n             pub const fn overflowing_abs(self) -> (Self, bool) {\n-                (self.wrapping_abs(), self == Self::min_value())\n+                (self.wrapping_abs(), self == Self::MIN)\n             }\n         }\n \n@@ -2986,9 +2986,9 @@ assert_eq!((\", stringify!($SelfT), \"::MAX - 2).checked_add(3), None);\", $EndFeat\n         }\n \n         doc_comment! {\n-            concat!(\"Unchecked integer addition. Computes `self + rhs, assuming overflow\n+            concat!(\"Unchecked integer addition. Computes `self + rhs`, assuming overflow\n cannot occur. This results in undefined behavior when `self + rhs > \", stringify!($SelfT),\n-\"::max_value()` or `self + rhs < \", stringify!($SelfT), \"::min_value()`.\"),\n+\"::MAX` or `self + rhs < \", stringify!($SelfT), \"::MIN`.\"),\n             #[unstable(\n                 feature = \"unchecked_math\",\n                 reason = \"niche optimization path\",\n@@ -3026,9 +3026,9 @@ assert_eq!(0\", stringify!($SelfT), \".checked_sub(1), None);\", $EndFeature, \"\n         }\n \n         doc_comment! {\n-            concat!(\"Unchecked integer subtraction. Computes `self - rhs, assuming overflow\n+            concat!(\"Unchecked integer subtraction. Computes `self - rhs`, assuming overflow\n cannot occur. This results in undefined behavior when `self - rhs > \", stringify!($SelfT),\n-\"::max_value()` or `self - rhs < \", stringify!($SelfT), \"::min_value()`.\"),\n+\"::MAX` or `self - rhs < \", stringify!($SelfT), \"::MIN`.\"),\n             #[unstable(\n                 feature = \"unchecked_math\",\n                 reason = \"niche optimization path\",\n@@ -3066,9 +3066,9 @@ assert_eq!(\", stringify!($SelfT), \"::MAX.checked_mul(2), None);\", $EndFeature, \"\n         }\n \n         doc_comment! {\n-            concat!(\"Unchecked integer multiplication. Computes `self * rhs, assuming overflow\n+            concat!(\"Unchecked integer multiplication. Computes `self * rhs`, assuming overflow\n cannot occur. This results in undefined behavior when `self * rhs > \", stringify!($SelfT),\n-\"::max_value()` or `self * rhs < \", stringify!($SelfT), \"::min_value()`.\"),\n+\"::MAX` or `self * rhs < \", stringify!($SelfT), \"::MIN`.\"),\n             #[unstable(\n                 feature = \"unchecked_math\",\n                 reason = \"niche optimization path\",\n@@ -3366,7 +3366,7 @@ assert_eq!((\", stringify!($SelfT), \"::MAX).saturating_mul(10), \", stringify!($Se\n             pub const fn saturating_mul(self, rhs: Self) -> Self {\n                 match self.checked_mul(rhs) {\n                     Some(x) => x,\n-                    None => Self::max_value(),\n+                    None => Self::MAX,\n                 }\n             }\n         }\n@@ -3393,7 +3393,7 @@ $EndFeature, \"\n             pub const fn saturating_pow(self, exp: u32) -> Self {\n                 match self.checked_pow(exp) {\n                     Some(x) => x,\n-                    None => Self::max_value(),\n+                    None => Self::MAX,\n                 }\n             }\n         }\n@@ -4080,7 +4080,7 @@ Basic usage:\n         }\n     }\n \n-            doc_comment! {\n+        doc_comment! {\n             concat!(\"Performs Euclidean division.\n \n Since, for the positive integers, all common\n@@ -4178,7 +4178,7 @@ assert!(!10\", stringify!($SelfT), \".is_power_of_two());\", $EndFeature, \"\n             // (such as intel pre-haswell) have more efficient ctlz\n             // intrinsics when the argument is non-zero.\n             let z = unsafe { intrinsics::ctlz_nonzero(p) };\n-            <$SelfT>::max_value() >> z\n+            <$SelfT>::MAX >> z\n         }\n \n         doc_comment! {\n@@ -5160,9 +5160,9 @@ trait FromStrRadixHelper: PartialOrd + Copy {\n macro_rules! doit {\n     ($($t:ty)*) => ($(impl FromStrRadixHelper for $t {\n         #[inline]\n-        fn min_value() -> Self { Self::min_value() }\n+        fn min_value() -> Self { Self::MIN }\n         #[inline]\n-        fn max_value() -> Self { Self::max_value() }\n+        fn max_value() -> Self { Self::MAX }\n         #[inline]\n         fn from_u32(u: u32) -> Self { u as Self }\n         #[inline]"}, {"sha": "f6acb8f8b9a9273f3865281c2c47d7cc02f018f6", "filename": "src/libcore/num/wrapping.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fff822fead6249671cbcb090b24bce58fab38de0/src%2Flibcore%2Fnum%2Fwrapping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff822fead6249671cbcb090b24bce58fab38de0/src%2Flibcore%2Fnum%2Fwrapping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fwrapping.rs?ref=fff822fead6249671cbcb090b24bce58fab38de0", "patch": "@@ -694,7 +694,7 @@ Basic usage:\n #![feature(wrapping_int_impl)]\n use std::num::Wrapping;\n \n-let n = Wrapping(\", stringify!($t), \"::max_value()) >> 2;\n+let n = Wrapping(\", stringify!($t), \"::MAX) >> 2;\n \n assert_eq!(n.leading_zeros(), 3);\n ```\"),\n@@ -723,8 +723,7 @@ use std::num::Wrapping;\n \n assert_eq!(Wrapping(100\", stringify!($t), \").abs(), Wrapping(100));\n assert_eq!(Wrapping(-100\", stringify!($t), \").abs(), Wrapping(100));\n-assert_eq!(Wrapping(\", stringify!($t), \"::min_value()).abs(), Wrapping(\", stringify!($t),\n-\"::min_value()));\n+assert_eq!(Wrapping(\", stringify!($t), \"::MIN).abs(), Wrapping(\", stringify!($t), \"::MIN));\n assert_eq!(Wrapping(-128i8).abs().0 as u8, 128u8);\n ```\"),\n                 #[inline]\n@@ -823,7 +822,7 @@ Basic usage:\n #![feature(wrapping_int_impl)]\n use std::num::Wrapping;\n \n-let n = Wrapping(\", stringify!($t), \"::max_value()) >> 2;\n+let n = Wrapping(\", stringify!($t), \"::MAX) >> 2;\n \n assert_eq!(n.leading_zeros(), 2);\n ```\"),"}, {"sha": "e39d18d7733a239f98f97d7b1257c72e5516fe6c", "filename": "src/libcore/ptr/const_ptr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fff822fead6249671cbcb090b24bce58fab38de0/src%2Flibcore%2Fptr%2Fconst_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff822fead6249671cbcb090b24bce58fab38de0/src%2Flibcore%2Fptr%2Fconst_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr%2Fconst_ptr.rs?ref=fff822fead6249671cbcb090b24bce58fab38de0", "patch": "@@ -291,7 +291,7 @@ impl<T: ?Sized> *const T {\n         T: Sized,\n     {\n         let pointee_size = mem::size_of::<T>();\n-        assert!(0 < pointee_size && pointee_size <= isize::max_value() as usize);\n+        assert!(0 < pointee_size && pointee_size <= isize::MAX as usize);\n         intrinsics::ptr_offset_from(self, origin)\n     }\n \n@@ -336,7 +336,7 @@ impl<T: ?Sized> *const T {\n         T: Sized,\n     {\n         let pointee_size = mem::size_of::<T>();\n-        assert!(0 < pointee_size && pointee_size <= isize::max_value() as usize);\n+        assert!(0 < pointee_size && pointee_size <= isize::MAX as usize);\n \n         let d = isize::wrapping_sub(self as _, origin as _);\n         d.wrapping_div(pointee_size as _)"}, {"sha": "57d0008e6f8a2f876c544371f378d6d8d60f5896", "filename": "src/libcore/ptr/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fff822fead6249671cbcb090b24bce58fab38de0/src%2Flibcore%2Fptr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff822fead6249671cbcb090b24bce58fab38de0/src%2Flibcore%2Fptr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr%2Fmod.rs?ref=fff822fead6249671cbcb090b24bce58fab38de0", "patch": "@@ -1128,7 +1128,7 @@ pub(crate) unsafe fn align_offset<T: Sized>(p: *const T, a: usize) -> usize {\n                 //\n                 // Note, that we use wrapping operations here intentionally \u2013 the original formula\n                 // uses e.g., subtraction `mod n`. It is entirely fine to do them `mod\n-                // usize::max_value()` instead, because we take the result `mod n` at the end\n+                // usize::MAX` instead, because we take the result `mod n` at the end\n                 // anyway.\n                 inverse = inverse.wrapping_mul(2usize.wrapping_sub(x.wrapping_mul(inverse)));\n                 if going_mod >= m {\n@@ -1193,7 +1193,7 @@ pub(crate) unsafe fn align_offset<T: Sized>(p: *const T, a: usize) -> usize {\n     }\n \n     // Cannot be aligned at all.\n-    usize::max_value()\n+    usize::MAX\n }\n \n /// Compares raw pointers for equality."}, {"sha": "8f0b662aa28e9de80df7376b1683196f0bd48eea", "filename": "src/libcore/slice/mod.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fff822fead6249671cbcb090b24bce58fab38de0/src%2Flibcore%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff822fead6249671cbcb090b24bce58fab38de0/src%2Flibcore%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmod.rs?ref=fff822fead6249671cbcb090b24bce58fab38de0", "patch": "@@ -3043,16 +3043,12 @@ impl<T> SliceIndex<[T]> for ops::RangeInclusive<usize> {\n \n     #[inline]\n     fn get(self, slice: &[T]) -> Option<&[T]> {\n-        if *self.end() == usize::max_value() {\n-            None\n-        } else {\n-            (*self.start()..self.end() + 1).get(slice)\n-        }\n+        if *self.end() == usize::MAX { None } else { (*self.start()..self.end() + 1).get(slice) }\n     }\n \n     #[inline]\n     fn get_mut(self, slice: &mut [T]) -> Option<&mut [T]> {\n-        if *self.end() == usize::max_value() {\n+        if *self.end() == usize::MAX {\n             None\n         } else {\n             (*self.start()..self.end() + 1).get_mut(slice)\n@@ -3071,15 +3067,15 @@ impl<T> SliceIndex<[T]> for ops::RangeInclusive<usize> {\n \n     #[inline]\n     fn index(self, slice: &[T]) -> &[T] {\n-        if *self.end() == usize::max_value() {\n+        if *self.end() == usize::MAX {\n             slice_index_overflow_fail();\n         }\n         (*self.start()..self.end() + 1).index(slice)\n     }\n \n     #[inline]\n     fn index_mut(self, slice: &mut [T]) -> &mut [T] {\n-        if *self.end() == usize::max_value() {\n+        if *self.end() == usize::MAX {\n             slice_index_overflow_fail();\n         }\n         (*self.start()..self.end() + 1).index_mut(slice)"}, {"sha": "6c4b28499a60bb4da70d577daa5ac8b4e3345ef2", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/fff822fead6249671cbcb090b24bce58fab38de0/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff822fead6249671cbcb090b24bce58fab38de0/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=fff822fead6249671cbcb090b24bce58fab38de0", "patch": "@@ -1651,7 +1651,7 @@ fn run_utf8_validation(v: &[u8]) -> Result<(), Utf8Error> {\n             // Ascii case, try to skip forward quickly.\n             // When the pointer is aligned, read 2 words of data per iteration\n             // until we find a word containing a non-ascii byte.\n-            if align != usize::max_value() && align.wrapping_sub(index) % usize_bytes == 0 {\n+            if align != usize::MAX && align.wrapping_sub(index) % usize_bytes == 0 {\n                 let ptr = v.as_ptr();\n                 while index < blocks_end {\n                     // SAFETY: since `align - index` and `ascii_block_size` are\n@@ -2083,15 +2083,15 @@ mod traits {\n         type Output = str;\n         #[inline]\n         fn get(self, slice: &str) -> Option<&Self::Output> {\n-            if *self.end() == usize::max_value() {\n+            if *self.end() == usize::MAX {\n                 None\n             } else {\n                 (*self.start()..self.end() + 1).get(slice)\n             }\n         }\n         #[inline]\n         fn get_mut(self, slice: &mut str) -> Option<&mut Self::Output> {\n-            if *self.end() == usize::max_value() {\n+            if *self.end() == usize::MAX {\n                 None\n             } else {\n                 (*self.start()..self.end() + 1).get_mut(slice)\n@@ -2107,14 +2107,14 @@ mod traits {\n         }\n         #[inline]\n         fn index(self, slice: &str) -> &Self::Output {\n-            if *self.end() == usize::max_value() {\n+            if *self.end() == usize::MAX {\n                 str_index_overflow_fail();\n             }\n             (*self.start()..self.end() + 1).index(slice)\n         }\n         #[inline]\n         fn index_mut(self, slice: &mut str) -> &mut Self::Output {\n-            if *self.end() == usize::max_value() {\n+            if *self.end() == usize::MAX {\n                 str_index_overflow_fail();\n             }\n             (*self.start()..self.end() + 1).index_mut(slice)\n@@ -2140,11 +2140,11 @@ mod traits {\n         type Output = str;\n         #[inline]\n         fn get(self, slice: &str) -> Option<&Self::Output> {\n-            if self.end == usize::max_value() { None } else { (..self.end + 1).get(slice) }\n+            if self.end == usize::MAX { None } else { (..self.end + 1).get(slice) }\n         }\n         #[inline]\n         fn get_mut(self, slice: &mut str) -> Option<&mut Self::Output> {\n-            if self.end == usize::max_value() { None } else { (..self.end + 1).get_mut(slice) }\n+            if self.end == usize::MAX { None } else { (..self.end + 1).get_mut(slice) }\n         }\n         #[inline]\n         unsafe fn get_unchecked(self, slice: &str) -> &Self::Output {\n@@ -2156,14 +2156,14 @@ mod traits {\n         }\n         #[inline]\n         fn index(self, slice: &str) -> &Self::Output {\n-            if self.end == usize::max_value() {\n+            if self.end == usize::MAX {\n                 str_index_overflow_fail();\n             }\n             (..self.end + 1).index(slice)\n         }\n         #[inline]\n         fn index_mut(self, slice: &mut str) -> &mut Self::Output {\n-            if self.end == usize::max_value() {\n+            if self.end == usize::MAX {\n                 str_index_overflow_fail();\n             }\n             (..self.end + 1).index_mut(slice)"}, {"sha": "939f1325c8499a2470722686192794b57d037edf", "filename": "src/libcore/tests/num/mod.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/fff822fead6249671cbcb090b24bce58fab38de0/src%2Flibcore%2Ftests%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff822fead6249671cbcb090b24bce58fab38de0/src%2Flibcore%2Ftests%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fnum%2Fmod.rs?ref=fff822fead6249671cbcb090b24bce58fab38de0", "patch": "@@ -140,8 +140,8 @@ macro_rules! test_impl_from {\n     ($fn_name: ident, $Small: ty, $Large: ty) => {\n         #[test]\n         fn $fn_name() {\n-            let small_max = <$Small>::max_value();\n-            let small_min = <$Small>::min_value();\n+            let small_max = <$Small>::MAX;\n+            let small_min = <$Small>::MIN;\n             let large_max: $Large = small_max.into();\n             let large_min: $Large = small_min.into();\n             assert_eq!(large_max as $Small, small_max);\n@@ -248,8 +248,8 @@ macro_rules! test_impl_try_from_always_ok {\n     ($fn_name:ident, $source:ty, $target: ty) => {\n         #[test]\n         fn $fn_name() {\n-            let max = <$source>::max_value();\n-            let min = <$source>::min_value();\n+            let max = <$source>::MAX;\n+            let min = <$source>::MIN;\n             let zero: $source = 0;\n             assert_eq!(<$target as TryFrom<$source>>::try_from(max).unwrap(), max as $target);\n             assert_eq!(<$target as TryFrom<$source>>::try_from(min).unwrap(), min as $target);\n@@ -361,8 +361,8 @@ macro_rules! test_impl_try_from_signed_to_unsigned_upper_ok {\n     ($fn_name:ident, $source:ty, $target:ty) => {\n         #[test]\n         fn $fn_name() {\n-            let max = <$source>::max_value();\n-            let min = <$source>::min_value();\n+            let max = <$source>::MAX;\n+            let min = <$source>::MIN;\n             let zero: $source = 0;\n             let neg_one: $source = -1;\n             assert_eq!(<$target as TryFrom<$source>>::try_from(max).unwrap(), max as $target);\n@@ -426,8 +426,8 @@ macro_rules! test_impl_try_from_unsigned_to_signed_upper_err {\n     ($fn_name:ident, $source:ty, $target:ty) => {\n         #[test]\n         fn $fn_name() {\n-            let max = <$source>::max_value();\n-            let min = <$source>::min_value();\n+            let max = <$source>::MAX;\n+            let min = <$source>::MIN;\n             let zero: $source = 0;\n             assert!(<$target as TryFrom<$source>>::try_from(max).is_err());\n             assert_eq!(<$target as TryFrom<$source>>::try_from(min).unwrap(), min as $target);\n@@ -487,11 +487,11 @@ macro_rules! test_impl_try_from_same_sign_err {\n     ($fn_name:ident, $source:ty, $target:ty) => {\n         #[test]\n         fn $fn_name() {\n-            let max = <$source>::max_value();\n-            let min = <$source>::min_value();\n+            let max = <$source>::MAX;\n+            let min = <$source>::MIN;\n             let zero: $source = 0;\n-            let t_max = <$target>::max_value();\n-            let t_min = <$target>::min_value();\n+            let t_max = <$target>::MAX;\n+            let t_min = <$target>::MIN;\n             assert!(<$target as TryFrom<$source>>::try_from(max).is_err());\n             if min != 0 {\n                 assert!(<$target as TryFrom<$source>>::try_from(min).is_err());\n@@ -576,11 +576,11 @@ macro_rules! test_impl_try_from_signed_to_unsigned_err {\n     ($fn_name:ident, $source:ty, $target:ty) => {\n         #[test]\n         fn $fn_name() {\n-            let max = <$source>::max_value();\n-            let min = <$source>::min_value();\n+            let max = <$source>::MAX;\n+            let min = <$source>::MIN;\n             let zero: $source = 0;\n-            let t_max = <$target>::max_value();\n-            let t_min = <$target>::min_value();\n+            let t_max = <$target>::MAX;\n+            let t_min = <$target>::MIN;\n             assert!(<$target as TryFrom<$source>>::try_from(max).is_err());\n             assert!(<$target as TryFrom<$source>>::try_from(min).is_err());\n             assert_eq!(<$target as TryFrom<$source>>::try_from(zero).unwrap(), zero as $target);"}, {"sha": "9fea34d668fcc77d2e841e2487c2380f23ea4fbf", "filename": "src/libcore/tests/ptr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fff822fead6249671cbcb090b24bce58fab38de0/src%2Flibcore%2Ftests%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff822fead6249671cbcb090b24bce58fab38de0/src%2Flibcore%2Ftests%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fptr.rs?ref=fff822fead6249671cbcb090b24bce58fab38de0", "patch": "@@ -357,7 +357,7 @@ fn align_offset_weird_strides() {\n \n     unsafe fn test_weird_stride<T>(ptr: *const T, align: usize) -> bool {\n         let numptr = ptr as usize;\n-        let mut expected = usize::max_value();\n+        let mut expected = usize::MAX;\n         // Naive but definitely correct way to find the *first* aligned element of stride::<T>.\n         for el in 0..align {\n             if (numptr + el * ::std::mem::size_of::<T>()) % align == 0 {"}, {"sha": "cd46117f76322ad214d6d1acdc50ada453940396", "filename": "src/libcore/tests/slice.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fff822fead6249671cbcb090b24bce58fab38de0/src%2Flibcore%2Ftests%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff822fead6249671cbcb090b24bce58fab38de0/src%2Flibcore%2Ftests%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fslice.rs?ref=fff822fead6249671cbcb090b24bce58fab38de0", "patch": "@@ -1691,8 +1691,8 @@ fn test_copy_within_panics_src_inverted() {\n #[should_panic(expected = \"attempted to index slice up to maximum usize\")]\n fn test_copy_within_panics_src_out_of_bounds() {\n     let mut bytes = *b\"Hello, World!\";\n-    // an inclusive range ending at usize::max_value() would make src_end overflow\n-    bytes.copy_within(usize::max_value()..=usize::max_value(), 0);\n+    // an inclusive range ending at usize::MAX would make src_end overflow\n+    bytes.copy_within(usize::MAX..=usize::MAX, 0);\n }\n \n #[test]"}, {"sha": "ba3adc4a135cb3a1e51b64cffe18fcc070799825", "filename": "src/librustc_apfloat/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fff822fead6249671cbcb090b24bce58fab38de0/src%2Flibrustc_apfloat%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff822fead6249671cbcb090b24bce58fab38de0/src%2Flibrustc_apfloat%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_apfloat%2Flib.rs?ref=fff822fead6249671cbcb090b24bce58fab38de0", "patch": "@@ -133,9 +133,9 @@ impl Neg for Round {\n pub type ExpInt = i16;\n \n // \\c ilogb error results.\n-pub const IEK_INF: ExpInt = ExpInt::max_value();\n-pub const IEK_NAN: ExpInt = ExpInt::min_value();\n-pub const IEK_ZERO: ExpInt = ExpInt::min_value() + 1;\n+pub const IEK_INF: ExpInt = ExpInt::MAX;\n+pub const IEK_NAN: ExpInt = ExpInt::MIN;\n+pub const IEK_ZERO: ExpInt = ExpInt::MIN + 1;\n \n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n pub struct ParseError(pub &'static str);"}, {"sha": "2d8bb7d1e8e03911d0086ea58bbaf4b9a155eb54", "filename": "src/librustc_apfloat/tests/ieee.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fff822fead6249671cbcb090b24bce58fab38de0/src%2Flibrustc_apfloat%2Ftests%2Fieee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff822fead6249671cbcb090b24bce58fab38de0/src%2Flibrustc_apfloat%2Ftests%2Fieee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_apfloat%2Ftests%2Fieee.rs?ref=fff822fead6249671cbcb090b24bce58fab38de0", "patch": "@@ -2997,8 +2997,8 @@ fn scalbn() {\n     assert!(smallest_f64.scalbn(2099).is_infinite());\n \n     // Test for integer overflows when adding to exponent.\n-    assert!(smallest_f64.scalbn(-ExpInt::max_value()).is_pos_zero());\n-    assert!(largest_f64.scalbn(ExpInt::max_value()).is_infinite());\n+    assert!(smallest_f64.scalbn(-ExpInt::MAX).is_pos_zero());\n+    assert!(largest_f64.scalbn(ExpInt::MAX).is_infinite());\n \n     assert!(largest_denormal_f64.bitwise_eq(largest_denormal_f64.scalbn(0),));\n     assert!(neg_largest_denormal_f64.bitwise_eq(neg_largest_denormal_f64.scalbn(0),));"}, {"sha": "b68ef1eb7f4c4da88d381afdd2ba2f86c9dfaff2", "filename": "src/librustc_data_structures/base_n/tests.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fff822fead6249671cbcb090b24bce58fab38de0/src%2Flibrustc_data_structures%2Fbase_n%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff822fead6249671cbcb090b24bce58fab38de0/src%2Flibrustc_data_structures%2Fbase_n%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fbase_n%2Ftests.rs?ref=fff822fead6249671cbcb090b24bce58fab38de0", "patch": "@@ -12,8 +12,8 @@ fn test_encode() {\n         test(35, base);\n         test(36, base);\n         test(37, base);\n-        test(u64::max_value() as u128, base);\n-        test(u128::max_value(), base);\n+        test(u64::MAX as u128, base);\n+        test(u128::MAX, base);\n \n         for i in 0..1_000 {\n             test(i * 983, base);"}, {"sha": "ea55674045c0f73ed49019ffa94c4693a29c6a58", "filename": "src/librustc_expand/proc_macro_server.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fff822fead6249671cbcb090b24bce58fab38de0/src%2Flibrustc_expand%2Fproc_macro_server.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff822fead6249671cbcb090b24bce58fab38de0/src%2Flibrustc_expand%2Fproc_macro_server.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fproc_macro_server.rs?ref=fff822fead6249671cbcb090b24bce58fab38de0", "patch": "@@ -582,10 +582,10 @@ impl server::Literal for Rustc<'_> {\n         };\n \n         // Bounds check the values, preventing addition overflow and OOB spans.\n-        if start > u32::max_value() as usize\n-            || end > u32::max_value() as usize\n-            || (u32::max_value() - start as u32) < span.lo().to_u32()\n-            || (u32::max_value() - end as u32) < span.lo().to_u32()\n+        if start > u32::MAX as usize\n+            || end > u32::MAX as usize\n+            || (u32::MAX - start as u32) < span.lo().to_u32()\n+            || (u32::MAX - end as u32) < span.lo().to_u32()\n             || start >= end\n             || end > length\n         {"}, {"sha": "697d25fdb585bebd78cbc6a973356bcb358b1e2b", "filename": "src/librustc_lexer/src/unescape.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fff822fead6249671cbcb090b24bce58fab38de0/src%2Flibrustc_lexer%2Fsrc%2Funescape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff822fead6249671cbcb090b24bce58fab38de0/src%2Flibrustc_lexer%2Fsrc%2Funescape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lexer%2Fsrc%2Funescape.rs?ref=fff822fead6249671cbcb090b24bce58fab38de0", "patch": "@@ -335,7 +335,7 @@ where\n \n fn byte_from_char(c: char) -> u8 {\n     let res = c as u32;\n-    assert!(res <= u8::max_value() as u32, \"guaranteed because of Mode::ByteStr\");\n+    assert!(res <= u8::MAX as u32, \"guaranteed because of Mode::ByteStr\");\n     res as u8\n }\n "}, {"sha": "a67c09b8923797255501cbf3653bbe2690bb167b", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/fff822fead6249671cbcb090b24bce58fab38de0/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff822fead6249671cbcb090b24bce58fab38de0/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=fff822fead6249671cbcb090b24bce58fab38de0", "patch": "@@ -108,23 +108,23 @@ fn lint_overflowing_range_endpoint<'a, 'tcx>(\n // warnings are consistent between 32- and 64-bit platforms.\n fn int_ty_range(int_ty: ast::IntTy) -> (i128, i128) {\n     match int_ty {\n-        ast::IntTy::Isize => (i64::min_value() as i128, i64::max_value() as i128),\n-        ast::IntTy::I8 => (i8::min_value() as i64 as i128, i8::max_value() as i128),\n-        ast::IntTy::I16 => (i16::min_value() as i64 as i128, i16::max_value() as i128),\n-        ast::IntTy::I32 => (i32::min_value() as i64 as i128, i32::max_value() as i128),\n-        ast::IntTy::I64 => (i64::min_value() as i128, i64::max_value() as i128),\n-        ast::IntTy::I128 => (i128::min_value() as i128, i128::max_value()),\n+        ast::IntTy::Isize => (i64::MIN as i128, i64::MAX as i128),\n+        ast::IntTy::I8 => (i8::MIN as i64 as i128, i8::MAX as i128),\n+        ast::IntTy::I16 => (i16::MIN as i64 as i128, i16::MAX as i128),\n+        ast::IntTy::I32 => (i32::MIN as i64 as i128, i32::MAX as i128),\n+        ast::IntTy::I64 => (i64::MIN as i128, i64::MAX as i128),\n+        ast::IntTy::I128 => (i128::MIN as i128, i128::MAX),\n     }\n }\n \n fn uint_ty_range(uint_ty: ast::UintTy) -> (u128, u128) {\n     match uint_ty {\n-        ast::UintTy::Usize => (u64::min_value() as u128, u64::max_value() as u128),\n-        ast::UintTy::U8 => (u8::min_value() as u128, u8::max_value() as u128),\n-        ast::UintTy::U16 => (u16::min_value() as u128, u16::max_value() as u128),\n-        ast::UintTy::U32 => (u32::min_value() as u128, u32::max_value() as u128),\n-        ast::UintTy::U64 => (u64::min_value() as u128, u64::max_value() as u128),\n-        ast::UintTy::U128 => (u128::min_value(), u128::max_value()),\n+        ast::UintTy::Usize => (u64::MIN as u128, u64::MAX as u128),\n+        ast::UintTy::U8 => (u8::MIN as u128, u8::MAX as u128),\n+        ast::UintTy::U16 => (u16::MIN as u128, u16::MAX as u128),\n+        ast::UintTy::U32 => (u32::MIN as u128, u32::MAX as u128),\n+        ast::UintTy::U64 => (u64::MIN as u128, u64::MAX as u128),\n+        ast::UintTy::U128 => (u128::MIN, u128::MAX),\n     }\n }\n "}, {"sha": "b8ebcd6c8a8fffb138ad51c2e46dd95190f95351", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fff822fead6249671cbcb090b24bce58fab38de0/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff822fead6249671cbcb090b24bce58fab38de0/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=fff822fead6249671cbcb090b24bce58fab38de0", "patch": "@@ -934,7 +934,7 @@ impl<'a> CrateLoader<'a> {\n                 src: ExternCrateSource::Path,\n                 span,\n                 // to have the least priority in `update_extern_crate`\n-                path_len: usize::max_value(),\n+                path_len: usize::MAX,\n                 dependency_of: LOCAL_CRATE,\n             },\n         );"}, {"sha": "2917a771a2cf87d956e5ba4ccdbd118985a0c578", "filename": "src/librustc_mir_build/build/matches/simplify.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fff822fead6249671cbcb090b24bce58fab38de0/src%2Flibrustc_mir_build%2Fbuild%2Fmatches%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff822fead6249671cbcb090b24bce58fab38de0/src%2Flibrustc_mir_build%2Fbuild%2Fmatches%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fbuild%2Fmatches%2Fsimplify.rs?ref=fff822fead6249671cbcb090b24bce58fab38de0", "patch": "@@ -160,13 +160,13 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     }\n                     ty::Int(ity) => {\n                         let size = Integer::from_attr(&tcx, SignedInt(ity)).size();\n-                        let max = truncate(u128::max_value(), size);\n+                        let max = truncate(u128::MAX, size);\n                         let bias = 1u128 << (size.bits() - 1);\n                         (Some((0, max, size)), bias)\n                     }\n                     ty::Uint(uty) => {\n                         let size = Integer::from_attr(&tcx, UnsignedInt(uty)).size();\n-                        let max = truncate(u128::max_value(), size);\n+                        let max = truncate(u128::MAX, size);\n                         (Some((0, max, size)), 0)\n                     }\n                     _ => (None, 0),"}, {"sha": "dc7d8098e55425c56f15af7b10009cc96a506d7d", "filename": "src/librustc_mir_build/hair/pattern/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fff822fead6249671cbcb090b24bce58fab38de0/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff822fead6249671cbcb090b24bce58fab38de0/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2F_match.rs?ref=fff822fead6249671cbcb090b24bce58fab38de0", "patch": "@@ -1519,7 +1519,7 @@ fn all_constructors<'a, 'tcx>(\n         }\n         ty::Uint(uty) => {\n             let size = Integer::from_attr(&cx.tcx, UnsignedInt(uty)).size();\n-            let max = truncate(u128::max_value(), size);\n+            let max = truncate(u128::MAX, size);\n             vec![make_range(0, max)]\n         }\n         _ => {"}, {"sha": "69e3758941929bd209b1711d59a35f976dcff3b2", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fff822fead6249671cbcb090b24bce58fab38de0/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff822fead6249671cbcb090b24bce58fab38de0/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=fff822fead6249671cbcb090b24bce58fab38de0", "patch": "@@ -1088,7 +1088,7 @@ fn id_from_hir_id(id: hir::HirId, scx: &SaveContext<'_, '_>) -> rls_data::Id {\n }\n \n fn null_id() -> rls_data::Id {\n-    rls_data::Id { krate: u32::max_value(), index: u32::max_value() }\n+    rls_data::Id { krate: u32::MAX, index: u32::MAX }\n }\n \n fn lower_attributes("}, {"sha": "411a6eecbba1584f3a49d45cbf861f694c99407b", "filename": "src/librustc_session/config.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fff822fead6249671cbcb090b24bce58fab38de0/src%2Flibrustc_session%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff822fead6249671cbcb090b24bce58fab38de0/src%2Flibrustc_session%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_session%2Fconfig.rs?ref=fff822fead6249671cbcb090b24bce58fab38de0", "patch": "@@ -1031,7 +1031,7 @@ pub fn get_cmd_lint_options(\n                 // HACK: forbid is always specified last, so it can't be overridden.\n                 // FIXME: remove this once <https://github.com/rust-lang/rust/issues/70819> is\n                 // fixed and `forbid` works as expected.\n-                usize::max_value()\n+                usize::MAX\n             } else {\n                 passed_arg_pos\n             };"}, {"sha": "743b7eca4e29b92a7a07765749b9ad574ae161b1", "filename": "src/librustc_span/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fff822fead6249671cbcb090b24bce58fab38de0/src%2Flibrustc_span%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff822fead6249671cbcb090b24bce58fab38de0/src%2Flibrustc_span%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_span%2Flib.rs?ref=fff822fead6249671cbcb090b24bce58fab38de0", "patch": "@@ -1250,7 +1250,7 @@ impl SourceFile {\n             hasher.finish::<u128>()\n         };\n         let end_pos = start_pos.to_usize() + src.len();\n-        assert!(end_pos <= u32::max_value() as usize);\n+        assert!(end_pos <= u32::MAX as usize);\n \n         let (lines, multibyte_chars, non_narrow_chars) =\n             analyze_source_file::analyze_source_file(&src[..], start_pos);"}, {"sha": "4b5bce1db26282ab91580c7202c35e676c3fb771", "filename": "src/librustc_span/source_map.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fff822fead6249671cbcb090b24bce58fab38de0/src%2Flibrustc_span%2Fsource_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff822fead6249671cbcb090b24bce58fab38de0/src%2Flibrustc_span%2Fsource_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_span%2Fsource_map.rs?ref=fff822fead6249671cbcb090b24bce58fab38de0", "patch": "@@ -819,9 +819,7 @@ impl SourceMap {\n \n         // Disregard indexes that are at the start or end of their spans, they can't fit bigger\n         // characters.\n-        if (!forwards && end_index == usize::min_value())\n-            || (forwards && start_index == usize::max_value())\n-        {\n+        if (!forwards && end_index == usize::MIN) || (forwards && start_index == usize::MAX) {\n             debug!(\"find_width_of_character_at_span: start or end of span, cannot be multibyte\");\n             return 1;\n         }"}, {"sha": "d752ba89a276d9762263c6f4fdeccbaed45a12ee", "filename": "src/libstd/f32.rs", "status": "modified", "additions": 28, "deletions": 29, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/fff822fead6249671cbcb090b24bce58fab38de0/src%2Flibstd%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff822fead6249671cbcb090b24bce58fab38de0/src%2Flibstd%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ff32.rs?ref=fff822fead6249671cbcb090b24bce58fab38de0", "patch": "@@ -916,8 +916,7 @@ impl f32 {\n \n #[cfg(test)]\n mod tests {\n-    use crate::f32;\n-    use crate::f32::*;\n+    use crate::f32::consts;\n     use crate::num::FpCategory as Fp;\n     use crate::num::*;\n \n@@ -928,14 +927,14 @@ mod tests {\n \n     #[test]\n     fn test_min_nan() {\n-        assert_eq!(NAN.min(2.0), 2.0);\n-        assert_eq!(2.0f32.min(NAN), 2.0);\n+        assert_eq!(f32::NAN.min(2.0), 2.0);\n+        assert_eq!(2.0f32.min(f32::NAN), 2.0);\n     }\n \n     #[test]\n     fn test_max_nan() {\n-        assert_eq!(NAN.max(2.0), 2.0);\n-        assert_eq!(2.0f32.max(NAN), 2.0);\n+        assert_eq!(f32::NAN.max(2.0), 2.0);\n+        assert_eq!(2.0f32.max(f32::NAN), 2.0);\n     }\n \n     #[test]\n@@ -1158,52 +1157,52 @@ mod tests {\n \n     #[test]\n     fn test_abs() {\n-        assert_eq!(INFINITY.abs(), INFINITY);\n+        assert_eq!(f32::INFINITY.abs(), f32::INFINITY);\n         assert_eq!(1f32.abs(), 1f32);\n         assert_eq!(0f32.abs(), 0f32);\n         assert_eq!((-0f32).abs(), 0f32);\n         assert_eq!((-1f32).abs(), 1f32);\n-        assert_eq!(NEG_INFINITY.abs(), INFINITY);\n-        assert_eq!((1f32 / NEG_INFINITY).abs(), 0f32);\n-        assert!(NAN.abs().is_nan());\n+        assert_eq!(f32::NEG_INFINITY.abs(), f32::INFINITY);\n+        assert_eq!((1f32 / f32::NEG_INFINITY).abs(), 0f32);\n+        assert!(f32::NAN.abs().is_nan());\n     }\n \n     #[test]\n     fn test_signum() {\n-        assert_eq!(INFINITY.signum(), 1f32);\n+        assert_eq!(f32::INFINITY.signum(), 1f32);\n         assert_eq!(1f32.signum(), 1f32);\n         assert_eq!(0f32.signum(), 1f32);\n         assert_eq!((-0f32).signum(), -1f32);\n         assert_eq!((-1f32).signum(), -1f32);\n-        assert_eq!(NEG_INFINITY.signum(), -1f32);\n-        assert_eq!((1f32 / NEG_INFINITY).signum(), -1f32);\n-        assert!(NAN.signum().is_nan());\n+        assert_eq!(f32::NEG_INFINITY.signum(), -1f32);\n+        assert_eq!((1f32 / f32::NEG_INFINITY).signum(), -1f32);\n+        assert!(f32::NAN.signum().is_nan());\n     }\n \n     #[test]\n     fn test_is_sign_positive() {\n-        assert!(INFINITY.is_sign_positive());\n+        assert!(f32::INFINITY.is_sign_positive());\n         assert!(1f32.is_sign_positive());\n         assert!(0f32.is_sign_positive());\n         assert!(!(-0f32).is_sign_positive());\n         assert!(!(-1f32).is_sign_positive());\n-        assert!(!NEG_INFINITY.is_sign_positive());\n-        assert!(!(1f32 / NEG_INFINITY).is_sign_positive());\n-        assert!(NAN.is_sign_positive());\n-        assert!(!(-NAN).is_sign_positive());\n+        assert!(!f32::NEG_INFINITY.is_sign_positive());\n+        assert!(!(1f32 / f32::NEG_INFINITY).is_sign_positive());\n+        assert!(f32::NAN.is_sign_positive());\n+        assert!(!(-f32::NAN).is_sign_positive());\n     }\n \n     #[test]\n     fn test_is_sign_negative() {\n-        assert!(!INFINITY.is_sign_negative());\n+        assert!(!f32::INFINITY.is_sign_negative());\n         assert!(!1f32.is_sign_negative());\n         assert!(!0f32.is_sign_negative());\n         assert!((-0f32).is_sign_negative());\n         assert!((-1f32).is_sign_negative());\n-        assert!(NEG_INFINITY.is_sign_negative());\n-        assert!((1f32 / NEG_INFINITY).is_sign_negative());\n-        assert!(!NAN.is_sign_negative());\n-        assert!((-NAN).is_sign_negative());\n+        assert!(f32::NEG_INFINITY.is_sign_negative());\n+        assert!((1f32 / f32::NEG_INFINITY).is_sign_negative());\n+        assert!(!f32::NAN.is_sign_negative());\n+        assert!((-f32::NAN).is_sign_negative());\n     }\n \n     #[test]\n@@ -1268,13 +1267,13 @@ mod tests {\n \n     #[test]\n     fn test_sqrt_domain() {\n-        assert!(NAN.sqrt().is_nan());\n-        assert!(NEG_INFINITY.sqrt().is_nan());\n+        assert!(f32::NAN.sqrt().is_nan());\n+        assert!(f32::NEG_INFINITY.sqrt().is_nan());\n         assert!((-1.0f32).sqrt().is_nan());\n         assert_eq!((-0.0f32).sqrt(), -0.0);\n         assert_eq!(0.0f32.sqrt(), 0.0);\n         assert_eq!(1.0f32.sqrt(), 1.0);\n-        assert_eq!(INFINITY.sqrt(), INFINITY);\n+        assert_eq!(f32::INFINITY.sqrt(), f32::INFINITY);\n     }\n \n     #[test]\n@@ -1523,13 +1522,13 @@ mod tests {\n     #[test]\n     #[should_panic]\n     fn test_clamp_min_is_nan() {\n-        let _ = 1.0f32.clamp(NAN, 1.0);\n+        let _ = 1.0f32.clamp(f32::NAN, 1.0);\n     }\n \n     #[test]\n     #[should_panic]\n     fn test_clamp_max_is_nan() {\n-        let _ = 1.0f32.clamp(3.0, NAN);\n+        let _ = 1.0f32.clamp(3.0, f32::NAN);\n     }\n \n     #[test]"}, {"sha": "9cd60d846a7073dd8610977c5edc9e19e2c5a717", "filename": "src/libstd/f64.rs", "status": "modified", "additions": 91, "deletions": 92, "changes": 183, "blob_url": "https://github.com/rust-lang/rust/blob/fff822fead6249671cbcb090b24bce58fab38de0/src%2Flibstd%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff822fead6249671cbcb090b24bce58fab38de0/src%2Flibstd%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ff64.rs?ref=fff822fead6249671cbcb090b24bce58fab38de0", "patch": "@@ -943,8 +943,7 @@ impl f64 {\n \n #[cfg(test)]\n mod tests {\n-    use crate::f64;\n-    use crate::f64::*;\n+    use crate::f64::consts;\n     use crate::num::FpCategory as Fp;\n     use crate::num::*;\n \n@@ -955,19 +954,19 @@ mod tests {\n \n     #[test]\n     fn test_min_nan() {\n-        assert_eq!(NAN.min(2.0), 2.0);\n-        assert_eq!(2.0f64.min(NAN), 2.0);\n+        assert_eq!(f64::NAN.min(2.0), 2.0);\n+        assert_eq!(2.0f64.min(f64::NAN), 2.0);\n     }\n \n     #[test]\n     fn test_max_nan() {\n-        assert_eq!(NAN.max(2.0), 2.0);\n-        assert_eq!(2.0f64.max(NAN), 2.0);\n+        assert_eq!(f64::NAN.max(2.0), 2.0);\n+        assert_eq!(2.0f64.max(f64::NAN), 2.0);\n     }\n \n     #[test]\n     fn test_nan() {\n-        let nan: f64 = NAN;\n+        let nan: f64 = f64::NAN;\n         assert!(nan.is_nan());\n         assert!(!nan.is_infinite());\n         assert!(!nan.is_finite());\n@@ -979,7 +978,7 @@ mod tests {\n \n     #[test]\n     fn test_infinity() {\n-        let inf: f64 = INFINITY;\n+        let inf: f64 = f64::INFINITY;\n         assert!(inf.is_infinite());\n         assert!(!inf.is_finite());\n         assert!(inf.is_sign_positive());\n@@ -991,7 +990,7 @@ mod tests {\n \n     #[test]\n     fn test_neg_infinity() {\n-        let neg_inf: f64 = NEG_INFINITY;\n+        let neg_inf: f64 = f64::NEG_INFINITY;\n         assert!(neg_inf.is_infinite());\n         assert!(!neg_inf.is_finite());\n         assert!(!neg_inf.is_sign_positive());\n@@ -1043,9 +1042,9 @@ mod tests {\n \n     #[test]\n     fn test_is_nan() {\n-        let nan: f64 = NAN;\n-        let inf: f64 = INFINITY;\n-        let neg_inf: f64 = NEG_INFINITY;\n+        let nan: f64 = f64::NAN;\n+        let inf: f64 = f64::INFINITY;\n+        let neg_inf: f64 = f64::NEG_INFINITY;\n         assert!(nan.is_nan());\n         assert!(!0.0f64.is_nan());\n         assert!(!5.3f64.is_nan());\n@@ -1056,9 +1055,9 @@ mod tests {\n \n     #[test]\n     fn test_is_infinite() {\n-        let nan: f64 = NAN;\n-        let inf: f64 = INFINITY;\n-        let neg_inf: f64 = NEG_INFINITY;\n+        let nan: f64 = f64::NAN;\n+        let inf: f64 = f64::INFINITY;\n+        let neg_inf: f64 = f64::NEG_INFINITY;\n         assert!(!nan.is_infinite());\n         assert!(inf.is_infinite());\n         assert!(neg_inf.is_infinite());\n@@ -1069,9 +1068,9 @@ mod tests {\n \n     #[test]\n     fn test_is_finite() {\n-        let nan: f64 = NAN;\n-        let inf: f64 = INFINITY;\n-        let neg_inf: f64 = NEG_INFINITY;\n+        let nan: f64 = f64::NAN;\n+        let inf: f64 = f64::INFINITY;\n+        let neg_inf: f64 = f64::NEG_INFINITY;\n         assert!(!nan.is_finite());\n         assert!(!inf.is_finite());\n         assert!(!neg_inf.is_finite());\n@@ -1083,9 +1082,9 @@ mod tests {\n     #[cfg_attr(all(target_arch = \"wasm32\", target_os = \"emscripten\"), ignore)] // issue 42630\n     #[test]\n     fn test_is_normal() {\n-        let nan: f64 = NAN;\n-        let inf: f64 = INFINITY;\n-        let neg_inf: f64 = NEG_INFINITY;\n+        let nan: f64 = f64::NAN;\n+        let inf: f64 = f64::INFINITY;\n+        let neg_inf: f64 = f64::NEG_INFINITY;\n         let zero: f64 = 0.0f64;\n         let neg_zero: f64 = -0.0;\n         assert!(!nan.is_normal());\n@@ -1101,9 +1100,9 @@ mod tests {\n     #[cfg_attr(all(target_arch = \"wasm32\", target_os = \"emscripten\"), ignore)] // issue 42630\n     #[test]\n     fn test_classify() {\n-        let nan: f64 = NAN;\n-        let inf: f64 = INFINITY;\n-        let neg_inf: f64 = NEG_INFINITY;\n+        let nan: f64 = f64::NAN;\n+        let inf: f64 = f64::INFINITY;\n+        let neg_inf: f64 = f64::NEG_INFINITY;\n         let zero: f64 = 0.0f64;\n         let neg_zero: f64 = -0.0;\n         assert_eq!(nan.classify(), Fp::Nan);\n@@ -1187,59 +1186,59 @@ mod tests {\n \n     #[test]\n     fn test_abs() {\n-        assert_eq!(INFINITY.abs(), INFINITY);\n+        assert_eq!(f64::INFINITY.abs(), f64::INFINITY);\n         assert_eq!(1f64.abs(), 1f64);\n         assert_eq!(0f64.abs(), 0f64);\n         assert_eq!((-0f64).abs(), 0f64);\n         assert_eq!((-1f64).abs(), 1f64);\n-        assert_eq!(NEG_INFINITY.abs(), INFINITY);\n-        assert_eq!((1f64 / NEG_INFINITY).abs(), 0f64);\n-        assert!(NAN.abs().is_nan());\n+        assert_eq!(f64::NEG_INFINITY.abs(), f64::INFINITY);\n+        assert_eq!((1f64 / f64::NEG_INFINITY).abs(), 0f64);\n+        assert!(f64::NAN.abs().is_nan());\n     }\n \n     #[test]\n     fn test_signum() {\n-        assert_eq!(INFINITY.signum(), 1f64);\n+        assert_eq!(f64::INFINITY.signum(), 1f64);\n         assert_eq!(1f64.signum(), 1f64);\n         assert_eq!(0f64.signum(), 1f64);\n         assert_eq!((-0f64).signum(), -1f64);\n         assert_eq!((-1f64).signum(), -1f64);\n-        assert_eq!(NEG_INFINITY.signum(), -1f64);\n-        assert_eq!((1f64 / NEG_INFINITY).signum(), -1f64);\n-        assert!(NAN.signum().is_nan());\n+        assert_eq!(f64::NEG_INFINITY.signum(), -1f64);\n+        assert_eq!((1f64 / f64::NEG_INFINITY).signum(), -1f64);\n+        assert!(f64::NAN.signum().is_nan());\n     }\n \n     #[test]\n     fn test_is_sign_positive() {\n-        assert!(INFINITY.is_sign_positive());\n+        assert!(f64::INFINITY.is_sign_positive());\n         assert!(1f64.is_sign_positive());\n         assert!(0f64.is_sign_positive());\n         assert!(!(-0f64).is_sign_positive());\n         assert!(!(-1f64).is_sign_positive());\n-        assert!(!NEG_INFINITY.is_sign_positive());\n-        assert!(!(1f64 / NEG_INFINITY).is_sign_positive());\n-        assert!(NAN.is_sign_positive());\n-        assert!(!(-NAN).is_sign_positive());\n+        assert!(!f64::NEG_INFINITY.is_sign_positive());\n+        assert!(!(1f64 / f64::NEG_INFINITY).is_sign_positive());\n+        assert!(f64::NAN.is_sign_positive());\n+        assert!(!(-f64::NAN).is_sign_positive());\n     }\n \n     #[test]\n     fn test_is_sign_negative() {\n-        assert!(!INFINITY.is_sign_negative());\n+        assert!(!f64::INFINITY.is_sign_negative());\n         assert!(!1f64.is_sign_negative());\n         assert!(!0f64.is_sign_negative());\n         assert!((-0f64).is_sign_negative());\n         assert!((-1f64).is_sign_negative());\n-        assert!(NEG_INFINITY.is_sign_negative());\n-        assert!((1f64 / NEG_INFINITY).is_sign_negative());\n-        assert!(!NAN.is_sign_negative());\n-        assert!((-NAN).is_sign_negative());\n+        assert!(f64::NEG_INFINITY.is_sign_negative());\n+        assert!((1f64 / f64::NEG_INFINITY).is_sign_negative());\n+        assert!(!f64::NAN.is_sign_negative());\n+        assert!((-f64::NAN).is_sign_negative());\n     }\n \n     #[test]\n     fn test_mul_add() {\n-        let nan: f64 = NAN;\n-        let inf: f64 = INFINITY;\n-        let neg_inf: f64 = NEG_INFINITY;\n+        let nan: f64 = f64::NAN;\n+        let inf: f64 = f64::INFINITY;\n+        let neg_inf: f64 = f64::NEG_INFINITY;\n         assert_approx_eq!(12.3f64.mul_add(4.5, 6.7), 62.05);\n         assert_approx_eq!((-12.3f64).mul_add(-4.5, -6.7), 48.65);\n         assert_approx_eq!(0.0f64.mul_add(8.9, 1.2), 1.2);\n@@ -1253,9 +1252,9 @@ mod tests {\n \n     #[test]\n     fn test_recip() {\n-        let nan: f64 = NAN;\n-        let inf: f64 = INFINITY;\n-        let neg_inf: f64 = NEG_INFINITY;\n+        let nan: f64 = f64::NAN;\n+        let inf: f64 = f64::INFINITY;\n+        let neg_inf: f64 = f64::NEG_INFINITY;\n         assert_eq!(1.0f64.recip(), 1.0);\n         assert_eq!(2.0f64.recip(), 0.5);\n         assert_eq!((-0.4f64).recip(), -2.5);\n@@ -1267,9 +1266,9 @@ mod tests {\n \n     #[test]\n     fn test_powi() {\n-        let nan: f64 = NAN;\n-        let inf: f64 = INFINITY;\n-        let neg_inf: f64 = NEG_INFINITY;\n+        let nan: f64 = f64::NAN;\n+        let inf: f64 = f64::INFINITY;\n+        let neg_inf: f64 = f64::NEG_INFINITY;\n         assert_eq!(1.0f64.powi(1), 1.0);\n         assert_approx_eq!((-3.1f64).powi(2), 9.61);\n         assert_approx_eq!(5.9f64.powi(-2), 0.028727);\n@@ -1281,9 +1280,9 @@ mod tests {\n \n     #[test]\n     fn test_powf() {\n-        let nan: f64 = NAN;\n-        let inf: f64 = INFINITY;\n-        let neg_inf: f64 = NEG_INFINITY;\n+        let nan: f64 = f64::NAN;\n+        let inf: f64 = f64::INFINITY;\n+        let neg_inf: f64 = f64::NEG_INFINITY;\n         assert_eq!(1.0f64.powf(1.0), 1.0);\n         assert_approx_eq!(3.4f64.powf(4.5), 246.408183);\n         assert_approx_eq!(2.7f64.powf(-3.2), 0.041652);\n@@ -1297,13 +1296,13 @@ mod tests {\n \n     #[test]\n     fn test_sqrt_domain() {\n-        assert!(NAN.sqrt().is_nan());\n-        assert!(NEG_INFINITY.sqrt().is_nan());\n+        assert!(f64::NAN.sqrt().is_nan());\n+        assert!(f64::NEG_INFINITY.sqrt().is_nan());\n         assert!((-1.0f64).sqrt().is_nan());\n         assert_eq!((-0.0f64).sqrt(), -0.0);\n         assert_eq!(0.0f64.sqrt(), 0.0);\n         assert_eq!(1.0f64.sqrt(), 1.0);\n-        assert_eq!(INFINITY.sqrt(), INFINITY);\n+        assert_eq!(f64::INFINITY.sqrt(), f64::INFINITY);\n     }\n \n     #[test]\n@@ -1312,9 +1311,9 @@ mod tests {\n         assert_approx_eq!(2.718282, 1.0f64.exp());\n         assert_approx_eq!(148.413159, 5.0f64.exp());\n \n-        let inf: f64 = INFINITY;\n-        let neg_inf: f64 = NEG_INFINITY;\n-        let nan: f64 = NAN;\n+        let inf: f64 = f64::INFINITY;\n+        let neg_inf: f64 = f64::NEG_INFINITY;\n+        let nan: f64 = f64::NAN;\n         assert_eq!(inf, inf.exp());\n         assert_eq!(0.0, neg_inf.exp());\n         assert!(nan.exp().is_nan());\n@@ -1325,19 +1324,19 @@ mod tests {\n         assert_eq!(32.0, 5.0f64.exp2());\n         assert_eq!(1.0, 0.0f64.exp2());\n \n-        let inf: f64 = INFINITY;\n-        let neg_inf: f64 = NEG_INFINITY;\n-        let nan: f64 = NAN;\n+        let inf: f64 = f64::INFINITY;\n+        let neg_inf: f64 = f64::NEG_INFINITY;\n+        let nan: f64 = f64::NAN;\n         assert_eq!(inf, inf.exp2());\n         assert_eq!(0.0, neg_inf.exp2());\n         assert!(nan.exp2().is_nan());\n     }\n \n     #[test]\n     fn test_ln() {\n-        let nan: f64 = NAN;\n-        let inf: f64 = INFINITY;\n-        let neg_inf: f64 = NEG_INFINITY;\n+        let nan: f64 = f64::NAN;\n+        let inf: f64 = f64::INFINITY;\n+        let neg_inf: f64 = f64::NEG_INFINITY;\n         assert_approx_eq!(1.0f64.exp().ln(), 1.0);\n         assert!(nan.ln().is_nan());\n         assert_eq!(inf.ln(), inf);\n@@ -1350,9 +1349,9 @@ mod tests {\n \n     #[test]\n     fn test_log() {\n-        let nan: f64 = NAN;\n-        let inf: f64 = INFINITY;\n-        let neg_inf: f64 = NEG_INFINITY;\n+        let nan: f64 = f64::NAN;\n+        let inf: f64 = f64::INFINITY;\n+        let neg_inf: f64 = f64::NEG_INFINITY;\n         assert_eq!(10.0f64.log(10.0), 1.0);\n         assert_approx_eq!(2.3f64.log(3.5), 0.664858);\n         assert_eq!(1.0f64.exp().log(1.0f64.exp()), 1.0);\n@@ -1368,9 +1367,9 @@ mod tests {\n \n     #[test]\n     fn test_log2() {\n-        let nan: f64 = NAN;\n-        let inf: f64 = INFINITY;\n-        let neg_inf: f64 = NEG_INFINITY;\n+        let nan: f64 = f64::NAN;\n+        let inf: f64 = f64::INFINITY;\n+        let neg_inf: f64 = f64::NEG_INFINITY;\n         assert_approx_eq!(10.0f64.log2(), 3.321928);\n         assert_approx_eq!(2.3f64.log2(), 1.201634);\n         assert_approx_eq!(1.0f64.exp().log2(), 1.442695);\n@@ -1384,9 +1383,9 @@ mod tests {\n \n     #[test]\n     fn test_log10() {\n-        let nan: f64 = NAN;\n-        let inf: f64 = INFINITY;\n-        let neg_inf: f64 = NEG_INFINITY;\n+        let nan: f64 = f64::NAN;\n+        let inf: f64 = f64::INFINITY;\n+        let neg_inf: f64 = f64::NEG_INFINITY;\n         assert_eq!(10.0f64.log10(), 1.0);\n         assert_approx_eq!(2.3f64.log10(), 0.361728);\n         assert_approx_eq!(1.0f64.exp().log10(), 0.434294);\n@@ -1402,9 +1401,9 @@ mod tests {\n     #[test]\n     fn test_to_degrees() {\n         let pi: f64 = consts::PI;\n-        let nan: f64 = NAN;\n-        let inf: f64 = INFINITY;\n-        let neg_inf: f64 = NEG_INFINITY;\n+        let nan: f64 = f64::NAN;\n+        let inf: f64 = f64::INFINITY;\n+        let neg_inf: f64 = f64::NEG_INFINITY;\n         assert_eq!(0.0f64.to_degrees(), 0.0);\n         assert_approx_eq!((-5.8f64).to_degrees(), -332.315521);\n         assert_eq!(pi.to_degrees(), 180.0);\n@@ -1416,9 +1415,9 @@ mod tests {\n     #[test]\n     fn test_to_radians() {\n         let pi: f64 = consts::PI;\n-        let nan: f64 = NAN;\n-        let inf: f64 = INFINITY;\n-        let neg_inf: f64 = NEG_INFINITY;\n+        let nan: f64 = f64::NAN;\n+        let inf: f64 = f64::INFINITY;\n+        let neg_inf: f64 = f64::NEG_INFINITY;\n         assert_eq!(0.0f64.to_radians(), 0.0);\n         assert_approx_eq!(154.6f64.to_radians(), 2.698279);\n         assert_approx_eq!((-332.31f64).to_radians(), -5.799903);\n@@ -1433,9 +1432,9 @@ mod tests {\n         assert_eq!(0.0f64.asinh(), 0.0f64);\n         assert_eq!((-0.0f64).asinh(), -0.0f64);\n \n-        let inf: f64 = INFINITY;\n-        let neg_inf: f64 = NEG_INFINITY;\n-        let nan: f64 = NAN;\n+        let inf: f64 = f64::INFINITY;\n+        let neg_inf: f64 = f64::NEG_INFINITY;\n+        let nan: f64 = f64::NAN;\n         assert_eq!(inf.asinh(), inf);\n         assert_eq!(neg_inf.asinh(), neg_inf);\n         assert!(nan.asinh().is_nan());\n@@ -1450,9 +1449,9 @@ mod tests {\n         assert_eq!(1.0f64.acosh(), 0.0f64);\n         assert!(0.999f64.acosh().is_nan());\n \n-        let inf: f64 = INFINITY;\n-        let neg_inf: f64 = NEG_INFINITY;\n-        let nan: f64 = NAN;\n+        let inf: f64 = f64::INFINITY;\n+        let neg_inf: f64 = f64::NEG_INFINITY;\n+        let nan: f64 = f64::NAN;\n         assert_eq!(inf.acosh(), inf);\n         assert!(neg_inf.acosh().is_nan());\n         assert!(nan.acosh().is_nan());\n@@ -1465,9 +1464,9 @@ mod tests {\n         assert_eq!(0.0f64.atanh(), 0.0f64);\n         assert_eq!((-0.0f64).atanh(), -0.0f64);\n \n-        let inf: f64 = INFINITY;\n-        let neg_inf: f64 = NEG_INFINITY;\n-        let nan: f64 = NAN;\n+        let inf: f64 = f64::INFINITY;\n+        let neg_inf: f64 = f64::NEG_INFINITY;\n+        let nan: f64 = f64::NAN;\n         assert_eq!(1.0f64.atanh(), inf);\n         assert_eq!((-1.0f64).atanh(), neg_inf);\n         assert!(2f64.atanh().atanh().is_nan());\n@@ -1546,13 +1545,13 @@ mod tests {\n     #[test]\n     #[should_panic]\n     fn test_clamp_min_is_nan() {\n-        let _ = 1.0f64.clamp(NAN, 1.0);\n+        let _ = 1.0f64.clamp(f64::NAN, 1.0);\n     }\n \n     #[test]\n     #[should_panic]\n     fn test_clamp_max_is_nan() {\n-        let _ = 1.0f64.clamp(3.0, NAN);\n+        let _ = 1.0f64.clamp(3.0, f64::NAN);\n     }\n \n     #[test]"}, {"sha": "0737008a94c9a57369f85f28433f0f0c38ab0a9c", "filename": "src/libstd/io/buffered.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fff822fead6249671cbcb090b24bce58fab38de0/src%2Flibstd%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff822fead6249671cbcb090b24bce58fab38de0/src%2Flibstd%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fbuffered.rs?ref=fff822fead6249671cbcb090b24bce58fab38de0", "patch": "@@ -366,7 +366,7 @@ impl<R: Seek> Seek for BufReader<R> {\n             // it should be safe to assume that remainder fits within an i64 as the alternative\n             // means we managed to allocate 8 exbibytes and that's absurd.\n             // But it's not out of the realm of possibility for some weird underlying reader to\n-            // support seeking by i64::min_value() so we need to handle underflow when subtracting\n+            // support seeking by i64::MIN so we need to handle underflow when subtracting\n             // remainder.\n             if let Some(offset) = n.checked_sub(remainder) {\n                 result = self.inner.seek(SeekFrom::Current(offset))?;\n@@ -1268,7 +1268,7 @@ mod tests {\n                         self.pos = self.pos.wrapping_add(n as u64);\n                     }\n                     SeekFrom::End(n) => {\n-                        self.pos = u64::max_value().wrapping_add(n as u64);\n+                        self.pos = u64::MAX.wrapping_add(n as u64);\n                     }\n                 }\n                 Ok(self.pos)\n@@ -1277,11 +1277,11 @@ mod tests {\n \n         let mut reader = BufReader::with_capacity(5, PositionReader { pos: 0 });\n         assert_eq!(reader.fill_buf().ok(), Some(&[0, 1, 2, 3, 4][..]));\n-        assert_eq!(reader.seek(SeekFrom::End(-5)).ok(), Some(u64::max_value() - 5));\n+        assert_eq!(reader.seek(SeekFrom::End(-5)).ok(), Some(u64::MAX - 5));\n         assert_eq!(reader.fill_buf().ok().map(|s| s.len()), Some(5));\n         // the following seek will require two underlying seeks\n         let expected = 9223372036854775802;\n-        assert_eq!(reader.seek(SeekFrom::Current(i64::min_value())).ok(), Some(expected));\n+        assert_eq!(reader.seek(SeekFrom::Current(i64::MIN)).ok(), Some(expected));\n         assert_eq!(reader.fill_buf().ok().map(|s| s.len()), Some(5));\n         // seeking to 0 should empty the buffer.\n         assert_eq!(reader.seek(SeekFrom::Current(0)).ok(), Some(expected));\n@@ -1319,7 +1319,7 @@ mod tests {\n         // The following seek will require two underlying seeks.  The first will\n         // succeed but the second will fail.  This should still invalidate the\n         // buffer.\n-        assert!(reader.seek(SeekFrom::Current(i64::min_value())).is_err());\n+        assert!(reader.seek(SeekFrom::Current(i64::MIN)).is_err());\n         assert_eq!(reader.buffer().len(), 0);\n     }\n "}, {"sha": "f4db5f8145060b42ac13594196462aa440f7a273", "filename": "src/libstd/io/cursor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fff822fead6249671cbcb090b24bce58fab38de0/src%2Flibstd%2Fio%2Fcursor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff822fead6249671cbcb090b24bce58fab38de0/src%2Flibstd%2Fio%2Fcursor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fcursor.rs?ref=fff822fead6249671cbcb090b24bce58fab38de0", "patch": "@@ -963,7 +963,7 @@ mod tests {\n     #[cfg(target_pointer_width = \"32\")]\n     fn vec_seek_and_write_past_usize_max() {\n         let mut c = Cursor::new(Vec::new());\n-        c.set_position(<usize>::max_value() as u64 + 1);\n+        c.set_position(usize::MAX as u64 + 1);\n         assert!(c.write_all(&[1, 2, 3]).is_err());\n     }\n "}, {"sha": "b496c16a749cf8b3027706bf5ffdcb672411be2e", "filename": "src/libstd/num.rs", "status": "modified", "additions": 14, "deletions": 23, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/fff822fead6249671cbcb090b24bce58fab38de0/src%2Flibstd%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff822fead6249671cbcb090b24bce58fab38de0/src%2Flibstd%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum.rs?ref=fff822fead6249671cbcb090b24bce58fab38de0", "patch": "@@ -52,52 +52,43 @@ where\n #[cfg(test)]\n mod tests {\n     use crate::ops::Mul;\n-    use crate::u16;\n-    use crate::u32;\n-    use crate::u64;\n-    use crate::u8;\n-    use crate::usize;\n \n     #[test]\n     fn test_saturating_add_uint() {\n-        use crate::usize::MAX;\n         assert_eq!(3_usize.saturating_add(5_usize), 8_usize);\n-        assert_eq!(3_usize.saturating_add(MAX - 1), MAX);\n-        assert_eq!(MAX.saturating_add(MAX), MAX);\n-        assert_eq!((MAX - 2).saturating_add(1), MAX - 1);\n+        assert_eq!(3_usize.saturating_add(usize::MAX - 1), usize::MAX);\n+        assert_eq!(usize::MAX.saturating_add(usize::MAX), usize::MAX);\n+        assert_eq!((usize::MAX - 2).saturating_add(1), usize::MAX - 1);\n     }\n \n     #[test]\n     fn test_saturating_sub_uint() {\n-        use crate::usize::MAX;\n         assert_eq!(5_usize.saturating_sub(3_usize), 2_usize);\n         assert_eq!(3_usize.saturating_sub(5_usize), 0_usize);\n         assert_eq!(0_usize.saturating_sub(1_usize), 0_usize);\n-        assert_eq!((MAX - 1).saturating_sub(MAX), 0);\n+        assert_eq!((usize::MAX - 1).saturating_sub(usize::MAX), 0);\n     }\n \n     #[test]\n     fn test_saturating_add_int() {\n-        use crate::isize::{MAX, MIN};\n         assert_eq!(3i32.saturating_add(5), 8);\n-        assert_eq!(3isize.saturating_add(MAX - 1), MAX);\n-        assert_eq!(MAX.saturating_add(MAX), MAX);\n-        assert_eq!((MAX - 2).saturating_add(1), MAX - 1);\n+        assert_eq!(3isize.saturating_add(isize::MAX - 1), isize::MAX);\n+        assert_eq!(isize::MAX.saturating_add(isize::MAX), isize::MAX);\n+        assert_eq!((isize::MAX - 2).saturating_add(1), isize::MAX - 1);\n         assert_eq!(3i32.saturating_add(-5), -2);\n-        assert_eq!(MIN.saturating_add(-1), MIN);\n-        assert_eq!((-2isize).saturating_add(-MAX), MIN);\n+        assert_eq!(isize::MIN.saturating_add(-1), isize::MIN);\n+        assert_eq!((-2isize).saturating_add(-isize::MAX), isize::MIN);\n     }\n \n     #[test]\n     fn test_saturating_sub_int() {\n-        use crate::isize::{MAX, MIN};\n         assert_eq!(3i32.saturating_sub(5), -2);\n-        assert_eq!(MIN.saturating_sub(1), MIN);\n-        assert_eq!((-2isize).saturating_sub(MAX), MIN);\n+        assert_eq!(isize::MIN.saturating_sub(1), isize::MIN);\n+        assert_eq!((-2isize).saturating_sub(isize::MAX), isize::MIN);\n         assert_eq!(3i32.saturating_sub(-5), 8);\n-        assert_eq!(3isize.saturating_sub(-(MAX - 1)), MAX);\n-        assert_eq!(MAX.saturating_sub(-MAX), MAX);\n-        assert_eq!((MAX - 2).saturating_sub(-1), MAX - 1);\n+        assert_eq!(3isize.saturating_sub(-(isize::MAX - 1)), isize::MAX);\n+        assert_eq!(isize::MAX.saturating_sub(-isize::MAX), isize::MAX);\n+        assert_eq!((isize::MAX - 2).saturating_sub(-1), isize::MAX - 1);\n     }\n \n     #[test]"}, {"sha": "2250c0d4203ef26a52d4fb2b7b0c442a82a1ba1a", "filename": "src/libstd/sync/condvar.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fff822fead6249671cbcb090b24bce58fab38de0/src%2Flibstd%2Fsync%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff822fead6249671cbcb090b24bce58fab38de0/src%2Flibstd%2Fsync%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fcondvar.rs?ref=fff822fead6249671cbcb090b24bce58fab38de0", "patch": "@@ -609,7 +609,6 @@ mod tests {\n     use crate::sync::{Arc, Condvar, Mutex};\n     use crate::thread;\n     use crate::time::Duration;\n-    use crate::u64;\n \n     #[test]\n     fn smoke() {"}, {"sha": "d6cc811154f11f667bd2abf47c1e1765061f517a", "filename": "src/libstd/sync/mpsc/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fff822fead6249671cbcb090b24bce58fab38de0/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff822fead6249671cbcb090b24bce58fab38de0/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs?ref=fff822fead6249671cbcb090b24bce58fab38de0", "patch": "@@ -2176,8 +2176,7 @@ mod tests {\n     #[cfg_attr(target_env = \"sgx\", ignore)] // FIXME: https://github.com/fortanix/rust-sgx/issues/31\n     fn very_long_recv_timeout_wont_panic() {\n         let (tx, rx) = channel::<()>();\n-        let join_handle =\n-            thread::spawn(move || rx.recv_timeout(Duration::from_secs(u64::max_value())));\n+        let join_handle = thread::spawn(move || rx.recv_timeout(Duration::from_secs(u64::MAX)));\n         thread::sleep(Duration::from_secs(1));\n         assert!(tx.send(()).is_ok());\n         assert_eq!(join_handle.join().unwrap(), Ok(()));"}, {"sha": "dabdc0c9b510af2dbfda6c7b46ded950d0a4fe49", "filename": "src/libstd/sys/cloudabi/condvar.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fff822fead6249671cbcb090b24bce58fab38de0/src%2Flibstd%2Fsys%2Fcloudabi%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff822fead6249671cbcb090b24bce58fab38de0/src%2Flibstd%2Fsys%2Fcloudabi%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcloudabi%2Fcondvar.rs?ref=fff822fead6249671cbcb090b24bce58fab38de0", "patch": "@@ -42,7 +42,7 @@ impl Condvar {\n             let ret = abi::condvar_signal(\n                 condvar as *mut abi::condvar,\n                 abi::scope::PRIVATE,\n-                abi::nthreads::max_value(),\n+                abi::nthreads::MAX,\n             );\n             assert_eq!(ret, abi::errno::SUCCESS, \"Failed to broadcast on condition variable\");\n         }"}, {"sha": "132e579b3a5cbcd38d3e698af47bd3903359f5ac", "filename": "src/libstd/sys/hermit/condvar.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fff822fead6249671cbcb090b24bce58fab38de0/src%2Flibstd%2Fsys%2Fhermit%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff822fead6249671cbcb090b24bce58fab38de0/src%2Flibstd%2Fsys%2Fhermit%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fhermit%2Fcondvar.rs?ref=fff822fead6249671cbcb090b24bce58fab38de0", "patch": "@@ -35,7 +35,7 @@ impl Condvar {\n \n     pub unsafe fn wait_timeout(&self, mutex: &Mutex, dur: Duration) -> bool {\n         let nanos = dur.as_nanos();\n-        let nanos = cmp::min(i64::max_value() as u128, nanos);\n+        let nanos = cmp::min(i64::MAX as u128, nanos);\n \n         // add current task to the wait queue\n         let _ = abi::add_queue(self.id(), nanos as i64);"}, {"sha": "ea05ee3d7cedf1894673e233de16d47fa0bfbfa4", "filename": "src/libstd/sys/unix/android.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fff822fead6249671cbcb090b24bce58fab38de0/src%2Flibstd%2Fsys%2Funix%2Fandroid.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff822fead6249671cbcb090b24bce58fab38de0/src%2Flibstd%2Fsys%2Funix%2Fandroid.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fandroid.rs?ref=fff822fead6249671cbcb090b24bce58fab38de0", "patch": "@@ -95,7 +95,7 @@ pub fn ftruncate64(fd: c_int, size: u64) -> io::Result<()> {\n         match ftruncate64.get() {\n             Some(f) => cvt_r(|| f(fd, size as i64)).map(drop),\n             None => {\n-                if size > i32::max_value() as u64 {\n+                if size > i32::MAX as u64 {\n                     Err(io::Error::new(io::ErrorKind::InvalidInput, \"cannot truncate >2GB\"))\n                 } else {\n                     cvt_r(|| ftruncate(fd, size as i32)).map(drop)"}, {"sha": "9f1847943f3262e63cfd43464e2aa91d65853920", "filename": "src/libstd/sys/unix/condvar.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fff822fead6249671cbcb090b24bce58fab38de0/src%2Flibstd%2Fsys%2Funix%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff822fead6249671cbcb090b24bce58fab38de0/src%2Flibstd%2Fsys%2Funix%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fcondvar.rs?ref=fff822fead6249671cbcb090b24bce58fab38de0", "patch": "@@ -10,14 +10,10 @@ unsafe impl Send for Condvar {}\n unsafe impl Sync for Condvar {}\n \n const TIMESPEC_MAX: libc::timespec =\n-    libc::timespec { tv_sec: <libc::time_t>::max_value(), tv_nsec: 1_000_000_000 - 1 };\n+    libc::timespec { tv_sec: <libc::time_t>::MAX, tv_nsec: 1_000_000_000 - 1 };\n \n fn saturating_cast_to_time_t(value: u64) -> libc::time_t {\n-    if value > <libc::time_t>::max_value() as u64 {\n-        <libc::time_t>::max_value()\n-    } else {\n-        value as libc::time_t\n-    }\n+    if value > <libc::time_t>::MAX as u64 { <libc::time_t>::MAX } else { value as libc::time_t }\n }\n \n impl Condvar {"}, {"sha": "cd24605ec7ab724650fd971ba2ce96aec7c0085a", "filename": "src/libstd/sys/unix/ext/net.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fff822fead6249671cbcb090b24bce58fab38de0/src%2Flibstd%2Fsys%2Funix%2Fext%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff822fead6249671cbcb090b24bce58fab38de0/src%2Flibstd%2Fsys%2Funix%2Fext%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fext%2Fnet.rs?ref=fff822fead6249671cbcb090b24bce58fab38de0", "patch": "@@ -1090,7 +1090,7 @@ impl<'a> Iterator for Incoming<'a> {\n     }\n \n     fn size_hint(&self) -> (usize, Option<usize>) {\n-        (usize::max_value(), None)\n+        (usize::MAX, None)\n     }\n }\n "}, {"sha": "c481ca8961f86192a3629e4660690bff33b141e9", "filename": "src/libstd/sys/unix/fd.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fff822fead6249671cbcb090b24bce58fab38de0/src%2Flibstd%2Fsys%2Funix%2Ffd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff822fead6249671cbcb090b24bce58fab38de0/src%2Flibstd%2Fsys%2Funix%2Ffd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ffd.rs?ref=fff822fead6249671cbcb090b24bce58fab38de0", "patch": "@@ -23,11 +23,7 @@ fn max_len() -> usize {\n     // intentionally showing odd behavior by rejecting any read with a size\n     // larger than or equal to INT_MAX. To handle both of these the read\n     // size is capped on both platforms.\n-    if cfg!(target_os = \"macos\") {\n-        <c_int>::max_value() as usize - 1\n-    } else {\n-        <ssize_t>::max_value() as usize\n-    }\n+    if cfg!(target_os = \"macos\") { <c_int>::MAX as usize - 1 } else { <ssize_t>::MAX as usize }\n }\n \n impl FileDesc {\n@@ -58,7 +54,7 @@ impl FileDesc {\n             libc::readv(\n                 self.fd,\n                 bufs.as_ptr() as *const libc::iovec,\n-                cmp::min(bufs.len(), c_int::max_value() as usize) as c_int,\n+                cmp::min(bufs.len(), c_int::MAX as usize) as c_int,\n             )\n         })?;\n         Ok(ret as usize)\n@@ -115,7 +111,7 @@ impl FileDesc {\n             libc::writev(\n                 self.fd,\n                 bufs.as_ptr() as *const libc::iovec,\n-                cmp::min(bufs.len(), c_int::max_value() as usize) as c_int,\n+                cmp::min(bufs.len(), c_int::MAX as usize) as c_int,\n             )\n         })?;\n         Ok(ret as usize)"}, {"sha": "29cdbf05354fbe353ba382332c54d8f927bb20a1", "filename": "src/libstd/sys/unix/fs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fff822fead6249671cbcb090b24bce58fab38de0/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff822fead6249671cbcb090b24bce58fab38de0/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ffs.rs?ref=fff822fead6249671cbcb090b24bce58fab38de0", "patch": "@@ -1196,7 +1196,7 @@ pub fn copy(from: &Path, to: &Path) -> io::Result<u64> {\n     let mut written = 0u64;\n     while written < len {\n         let copy_result = if has_copy_file_range {\n-            let bytes_to_copy = cmp::min(len - written, usize::max_value() as u64) as usize;\n+            let bytes_to_copy = cmp::min(len - written, usize::MAX as u64) as usize;\n             let copy_result = unsafe {\n                 // We actually don't have to adjust the offsets,\n                 // because copy_file_range adjusts the file offset automatically"}, {"sha": "3717c660b575d6f1c9e2d353be65fdfa6be3212f", "filename": "src/libstd/sys/unix/net.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fff822fead6249671cbcb090b24bce58fab38de0/src%2Flibstd%2Fsys%2Funix%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff822fead6249671cbcb090b24bce58fab38de0/src%2Flibstd%2Fsys%2Funix%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fnet.rs?ref=fff822fead6249671cbcb090b24bce58fab38de0", "patch": "@@ -148,7 +148,7 @@ impl Socket {\n                 timeout = 1;\n             }\n \n-            let timeout = cmp::min(timeout, c_int::max_value() as u64) as c_int;\n+            let timeout = cmp::min(timeout, c_int::MAX as u64) as c_int;\n \n             match unsafe { libc::poll(&mut pollfd, 1, timeout) } {\n                 -1 => {\n@@ -283,8 +283,8 @@ impl Socket {\n                     ));\n                 }\n \n-                let secs = if dur.as_secs() > libc::time_t::max_value() as u64 {\n-                    libc::time_t::max_value()\n+                let secs = if dur.as_secs() > libc::time_t::MAX as u64 {\n+                    libc::time_t::MAX\n                 } else {\n                     dur.as_secs() as libc::time_t\n                 };"}, {"sha": "7b3d69dcaa015fe0ddf16603dd6424c38d0a9c2c", "filename": "src/libstd/sys/unix/thread.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fff822fead6249671cbcb090b24bce58fab38de0/src%2Flibstd%2Fsys%2Funix%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff822fead6249671cbcb090b24bce58fab38de0/src%2Flibstd%2Fsys%2Funix%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fthread.rs?ref=fff822fead6249671cbcb090b24bce58fab38de0", "patch": "@@ -171,7 +171,7 @@ impl Thread {\n         unsafe {\n             while secs > 0 || nsecs > 0 {\n                 let mut ts = libc::timespec {\n-                    tv_sec: cmp::min(libc::time_t::max_value() as u64, secs) as libc::time_t,\n+                    tv_sec: cmp::min(libc::time_t::MAX as u64, secs) as libc::time_t,\n                     tv_nsec: nsecs,\n                 };\n                 secs -= ts.tv_sec as u64;"}, {"sha": "5a77966d974688ecb1ac2ec70b604f07ca1242ff", "filename": "src/libstd/sys/vxworks/condvar.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fff822fead6249671cbcb090b24bce58fab38de0/src%2Flibstd%2Fsys%2Fvxworks%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff822fead6249671cbcb090b24bce58fab38de0/src%2Flibstd%2Fsys%2Fvxworks%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Fcondvar.rs?ref=fff822fead6249671cbcb090b24bce58fab38de0", "patch": "@@ -10,14 +10,10 @@ unsafe impl Send for Condvar {}\n unsafe impl Sync for Condvar {}\n \n const TIMESPEC_MAX: libc::timespec =\n-    libc::timespec { tv_sec: <libc::time_t>::max_value(), tv_nsec: 1_000_000_000 - 1 };\n+    libc::timespec { tv_sec: <libc::time_t>::MAX, tv_nsec: 1_000_000_000 - 1 };\n \n fn saturating_cast_to_time_t(value: u64) -> libc::time_t {\n-    if value > <libc::time_t>::max_value() as u64 {\n-        <libc::time_t>::max_value()\n-    } else {\n-        value as libc::time_t\n-    }\n+    if value > <libc::time_t>::MAX as u64 { <libc::time_t>::MAX } else { value as libc::time_t }\n }\n \n impl Condvar {"}, {"sha": "7fa86f0db043f21bc2be1efa9a6c719aba73327d", "filename": "src/libstd/sys/vxworks/fd.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fff822fead6249671cbcb090b24bce58fab38de0/src%2Flibstd%2Fsys%2Fvxworks%2Ffd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff822fead6249671cbcb090b24bce58fab38de0/src%2Flibstd%2Fsys%2Fvxworks%2Ffd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Ffd.rs?ref=fff822fead6249671cbcb090b24bce58fab38de0", "patch": "@@ -17,7 +17,7 @@ fn max_len() -> usize {\n     // The maximum read limit on most posix-like systems is `SSIZE_MAX`,\n     // with the man page quoting that if the count of bytes to read is\n     // greater than `SSIZE_MAX` the result is \"unspecified\".\n-    <ssize_t>::max_value() as usize\n+    <ssize_t>::MAX as usize\n }\n \n impl FileDesc {\n@@ -48,7 +48,7 @@ impl FileDesc {\n             libc::readv(\n                 self.fd,\n                 bufs.as_ptr() as *const libc::iovec,\n-                cmp::min(bufs.len(), c_int::max_value() as usize) as c_int,\n+                cmp::min(bufs.len(), c_int::MAX as usize) as c_int,\n             )\n         })?;\n         Ok(ret as usize)\n@@ -98,7 +98,7 @@ impl FileDesc {\n             libc::writev(\n                 self.fd,\n                 bufs.as_ptr() as *const libc::iovec,\n-                cmp::min(bufs.len(), c_int::max_value() as usize) as c_int,\n+                cmp::min(bufs.len(), c_int::MAX as usize) as c_int,\n             )\n         })?;\n         Ok(ret as usize)"}, {"sha": "32c27ab6e9e8d4cb2247befc969929dcc4d44d95", "filename": "src/libstd/sys/vxworks/net.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fff822fead6249671cbcb090b24bce58fab38de0/src%2Flibstd%2Fsys%2Fvxworks%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff822fead6249671cbcb090b24bce58fab38de0/src%2Flibstd%2Fsys%2Fvxworks%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Fnet.rs?ref=fff822fead6249671cbcb090b24bce58fab38de0", "patch": "@@ -107,7 +107,7 @@ impl Socket {\n                 timeout = 1;\n             }\n \n-            let timeout = cmp::min(timeout, c_int::max_value() as u64) as c_int;\n+            let timeout = cmp::min(timeout, c_int::MAX as u64) as c_int;\n \n             match unsafe { libc::poll(&mut pollfd, 1, timeout) } {\n                 -1 => {\n@@ -220,8 +220,8 @@ impl Socket {\n                     ));\n                 }\n \n-                let secs = if dur.as_secs() > libc::time_t::max_value() as u64 {\n-                    libc::time_t::max_value()\n+                let secs = if dur.as_secs() > libc::time_t::MAX as u64 {\n+                    libc::time_t::MAX\n                 } else {\n                     dur.as_secs() as libc::time_t\n                 };"}, {"sha": "24a2e0f965d28f1caa255b2cb902b91b80255454", "filename": "src/libstd/sys/vxworks/thread.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fff822fead6249671cbcb090b24bce58fab38de0/src%2Flibstd%2Fsys%2Fvxworks%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff822fead6249671cbcb090b24bce58fab38de0/src%2Flibstd%2Fsys%2Fvxworks%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Fthread.rs?ref=fff822fead6249671cbcb090b24bce58fab38de0", "patch": "@@ -96,7 +96,7 @@ impl Thread {\n         unsafe {\n             while secs > 0 || nsecs > 0 {\n                 let mut ts = libc::timespec {\n-                    tv_sec: cmp::min(libc::time_t::max_value() as u64, secs) as libc::time_t,\n+                    tv_sec: cmp::min(libc::time_t::MAX as u64, secs) as libc::time_t,\n                     tv_nsec: nsecs,\n                 };\n                 secs -= ts.tv_sec as u64;"}, {"sha": "4fe9661421b03fca32be286f33909156a1ef9ca5", "filename": "src/libstd/sys/wasi/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fff822fead6249671cbcb090b24bce58fab38de0/src%2Flibstd%2Fsys%2Fwasi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff822fead6249671cbcb090b24bce58fab38de0/src%2Flibstd%2Fsys%2Fwasi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasi%2Fmod.rs?ref=fff822fead6249671cbcb090b24bce58fab38de0", "patch": "@@ -64,7 +64,7 @@ pub fn unsupported_err() -> std_io::Error {\n \n pub fn decode_error_kind(errno: i32) -> std_io::ErrorKind {\n     use std_io::ErrorKind::*;\n-    if errno > u16::max_value() as i32 || errno < 0 {\n+    if errno > u16::MAX as i32 || errno < 0 {\n         return Other;\n     }\n     match errno as u16 {"}, {"sha": "0d39b1cec328c5f5ece2af2202bdbac3e19bff24", "filename": "src/libstd/sys/wasi/thread.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fff822fead6249671cbcb090b24bce58fab38de0/src%2Flibstd%2Fsys%2Fwasi%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff822fead6249671cbcb090b24bce58fab38de0/src%2Flibstd%2Fsys%2Fwasi%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasi%2Fthread.rs?ref=fff822fead6249671cbcb090b24bce58fab38de0", "patch": "@@ -25,7 +25,7 @@ impl Thread {\n \n     pub fn sleep(dur: Duration) {\n         let nanos = dur.as_nanos();\n-        assert!(nanos <= u64::max_value() as u128);\n+        assert!(nanos <= u64::MAX as u128);\n \n         const USERDATA: wasi::Userdata = 0x0123_45678;\n "}, {"sha": "1859cdd5a0ed840f0db015383eaa2ddfa73adfc1", "filename": "src/libstd/sys/wasm/condvar_atomics.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fff822fead6249671cbcb090b24bce58fab38de0/src%2Flibstd%2Fsys%2Fwasm%2Fcondvar_atomics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff822fead6249671cbcb090b24bce58fab38de0/src%2Flibstd%2Fsys%2Fwasm%2Fcondvar_atomics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasm%2Fcondvar_atomics.rs?ref=fff822fead6249671cbcb090b24bce58fab38de0", "patch": "@@ -48,7 +48,7 @@ impl Condvar {\n     #[inline]\n     pub unsafe fn notify_all(&self) {\n         self.cnt.fetch_add(1, SeqCst);\n-        wasm32::atomic_notify(self.ptr(), u32::max_value()); // -1 == \"wake everyone\"\n+        wasm32::atomic_notify(self.ptr(), u32::MAX); // -1 == \"wake everyone\"\n     }\n \n     pub unsafe fn wait(&self, mutex: &Mutex) {\n@@ -72,7 +72,7 @@ impl Condvar {\n         let ticket = self.cnt.load(SeqCst) as i32;\n         mutex.unlock();\n         let nanos = dur.as_nanos();\n-        let nanos = cmp::min(i64::max_value() as u128, nanos);\n+        let nanos = cmp::min(i64::MAX as u128, nanos);\n \n         // If the return value is 2 then a timeout happened, so we return\n         // `false` as we weren't actually notified."}, {"sha": "0a11896a0048f31cb28f9b6819319c11dfb41418", "filename": "src/libstd/sys/wasm/thread.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fff822fead6249671cbcb090b24bce58fab38de0/src%2Flibstd%2Fsys%2Fwasm%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff822fead6249671cbcb090b24bce58fab38de0/src%2Flibstd%2Fsys%2Fwasm%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasm%2Fthread.rs?ref=fff822fead6249671cbcb090b24bce58fab38de0", "patch": "@@ -38,7 +38,7 @@ impl Thread {\n         // 2).\n         let mut nanos = dur.as_nanos();\n         while nanos > 0 {\n-            let amt = cmp::min(i64::max_value() as u128, nanos);\n+            let amt = cmp::min(i64::MAX as u128, nanos);\n             let mut x = 0;\n             let val = unsafe { wasm32::i32_atomic_wait(&mut x, 0, amt as i64) };\n             debug_assert_eq!(val, 2);"}, {"sha": "0d4baa3b340dfa9d75d54a5a8be6a7b317929807", "filename": "src/libstd/sys/windows/handle.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fff822fead6249671cbcb090b24bce58fab38de0/src%2Flibstd%2Fsys%2Fwindows%2Fhandle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff822fead6249671cbcb090b24bce58fab38de0/src%2Flibstd%2Fsys%2Fwindows%2Fhandle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fhandle.rs?ref=fff822fead6249671cbcb090b24bce58fab38de0", "patch": "@@ -70,7 +70,7 @@ impl RawHandle {\n \n     pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> {\n         let mut read = 0;\n-        let len = cmp::min(buf.len(), <c::DWORD>::max_value() as usize) as c::DWORD;\n+        let len = cmp::min(buf.len(), <c::DWORD>::MAX as usize) as c::DWORD;\n         let res = cvt(unsafe {\n             c::ReadFile(self.0, buf.as_mut_ptr() as c::LPVOID, len, &mut read, ptr::null_mut())\n         });\n@@ -99,7 +99,7 @@ impl RawHandle {\n \n     pub fn read_at(&self, buf: &mut [u8], offset: u64) -> io::Result<usize> {\n         let mut read = 0;\n-        let len = cmp::min(buf.len(), <c::DWORD>::max_value() as usize) as c::DWORD;\n+        let len = cmp::min(buf.len(), <c::DWORD>::MAX as usize) as c::DWORD;\n         let res = unsafe {\n             let mut overlapped: c::OVERLAPPED = mem::zeroed();\n             overlapped.Offset = offset as u32;\n@@ -118,7 +118,7 @@ impl RawHandle {\n         buf: &mut [u8],\n         overlapped: *mut c::OVERLAPPED,\n     ) -> io::Result<Option<usize>> {\n-        let len = cmp::min(buf.len(), <c::DWORD>::max_value() as usize) as c::DWORD;\n+        let len = cmp::min(buf.len(), <c::DWORD>::MAX as usize) as c::DWORD;\n         let mut amt = 0;\n         let res = cvt(c::ReadFile(self.0, buf.as_ptr() as c::LPVOID, len, &mut amt, overlapped));\n         match res {\n@@ -165,7 +165,7 @@ impl RawHandle {\n \n     pub fn write(&self, buf: &[u8]) -> io::Result<usize> {\n         let mut amt = 0;\n-        let len = cmp::min(buf.len(), <c::DWORD>::max_value() as usize) as c::DWORD;\n+        let len = cmp::min(buf.len(), <c::DWORD>::MAX as usize) as c::DWORD;\n         cvt(unsafe {\n             c::WriteFile(self.0, buf.as_ptr() as c::LPVOID, len, &mut amt, ptr::null_mut())\n         })?;\n@@ -183,7 +183,7 @@ impl RawHandle {\n \n     pub fn write_at(&self, buf: &[u8], offset: u64) -> io::Result<usize> {\n         let mut written = 0;\n-        let len = cmp::min(buf.len(), <c::DWORD>::max_value() as usize) as c::DWORD;\n+        let len = cmp::min(buf.len(), <c::DWORD>::MAX as usize) as c::DWORD;\n         unsafe {\n             let mut overlapped: c::OVERLAPPED = mem::zeroed();\n             overlapped.Offset = offset as u32;"}, {"sha": "fb06df1f80cda1c0fc5b74bef5e4bf91309cbc11", "filename": "src/libstd/sys/windows/io.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fff822fead6249671cbcb090b24bce58fab38de0/src%2Flibstd%2Fsys%2Fwindows%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff822fead6249671cbcb090b24bce58fab38de0/src%2Flibstd%2Fsys%2Fwindows%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fio.rs?ref=fff822fead6249671cbcb090b24bce58fab38de0", "patch": "@@ -12,7 +12,7 @@ pub struct IoSlice<'a> {\n impl<'a> IoSlice<'a> {\n     #[inline]\n     pub fn new(buf: &'a [u8]) -> IoSlice<'a> {\n-        assert!(buf.len() <= c::ULONG::max_value() as usize);\n+        assert!(buf.len() <= c::ULONG::MAX as usize);\n         IoSlice {\n             vec: c::WSABUF {\n                 len: buf.len() as c::ULONG,\n@@ -49,7 +49,7 @@ pub struct IoSliceMut<'a> {\n impl<'a> IoSliceMut<'a> {\n     #[inline]\n     pub fn new(buf: &'a mut [u8]) -> IoSliceMut<'a> {\n-        assert!(buf.len() <= c::ULONG::max_value() as usize);\n+        assert!(buf.len() <= c::ULONG::MAX as usize);\n         IoSliceMut {\n             vec: c::WSABUF { len: buf.len() as c::ULONG, buf: buf.as_mut_ptr() as *mut c::CHAR },\n             _p: PhantomData,"}, {"sha": "d63139d8052c23a535db8f5bbda2404a18babee5", "filename": "src/libstd/sys/windows/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fff822fead6249671cbcb090b24bce58fab38de0/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff822fead6249671cbcb090b24bce58fab38de0/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs?ref=fff822fead6249671cbcb090b24bce58fab38de0", "patch": "@@ -295,7 +295,7 @@ pub fn dur2timeout(dur: Duration) -> c::DWORD {\n         .checked_mul(1000)\n         .and_then(|ms| ms.checked_add((dur.subsec_nanos() as u64) / 1_000_000))\n         .and_then(|ms| ms.checked_add(if dur.subsec_nanos() % 1_000_000 > 0 { 1 } else { 0 }))\n-        .map(|ms| if ms > <c::DWORD>::max_value() as u64 { c::INFINITE } else { ms as c::DWORD })\n+        .map(|ms| if ms > <c::DWORD>::MAX as u64 { c::INFINITE } else { ms as c::DWORD })\n         .unwrap_or(c::INFINITE)\n }\n "}, {"sha": "9e74454bc23353d61b670227413e63b63b905359", "filename": "src/libstd/sys/windows/net.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fff822fead6249671cbcb090b24bce58fab38de0/src%2Flibstd%2Fsys%2Fwindows%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff822fead6249671cbcb090b24bce58fab38de0/src%2Flibstd%2Fsys%2Fwindows%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fnet.rs?ref=fff822fead6249671cbcb090b24bce58fab38de0", "patch": "@@ -228,7 +228,7 @@ impl Socket {\n     fn recv_with_flags(&self, buf: &mut [u8], flags: c_int) -> io::Result<usize> {\n         // On unix when a socket is shut down all further reads return 0, so we\n         // do the same on windows to map a shut down socket to returning EOF.\n-        let len = cmp::min(buf.len(), i32::max_value() as usize) as i32;\n+        let len = cmp::min(buf.len(), i32::MAX as usize) as i32;\n         unsafe {\n             match c::recv(self.0, buf.as_mut_ptr() as *mut c_void, len, flags) {\n                 -1 if c::WSAGetLastError() == c::WSAESHUTDOWN => Ok(0),\n@@ -245,7 +245,7 @@ impl Socket {\n     pub fn read_vectored(&self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n         // On unix when a socket is shut down all further reads return 0, so we\n         // do the same on windows to map a shut down socket to returning EOF.\n-        let len = cmp::min(bufs.len(), c::DWORD::max_value() as usize) as c::DWORD;\n+        let len = cmp::min(bufs.len(), c::DWORD::MAX as usize) as c::DWORD;\n         let mut nread = 0;\n         let mut flags = 0;\n         unsafe {\n@@ -282,7 +282,7 @@ impl Socket {\n     ) -> io::Result<(usize, SocketAddr)> {\n         let mut storage: c::SOCKADDR_STORAGE_LH = unsafe { mem::zeroed() };\n         let mut addrlen = mem::size_of_val(&storage) as c::socklen_t;\n-        let len = cmp::min(buf.len(), <wrlen_t>::max_value() as usize) as wrlen_t;\n+        let len = cmp::min(buf.len(), <wrlen_t>::MAX as usize) as wrlen_t;\n \n         // On unix when a socket is shut down all further reads return 0, so we\n         // do the same on windows to map a shut down socket to returning EOF.\n@@ -313,7 +313,7 @@ impl Socket {\n     }\n \n     pub fn write_vectored(&self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n-        let len = cmp::min(bufs.len(), c::DWORD::max_value() as usize) as c::DWORD;\n+        let len = cmp::min(bufs.len(), c::DWORD::MAX as usize) as c::DWORD;\n         let mut nwritten = 0;\n         unsafe {\n             cvt(c::WSASend("}, {"sha": "81a5ef95e82dcdc7cc33a230c715385304fdbf84", "filename": "src/libstd/sys_common/net.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fff822fead6249671cbcb090b24bce58fab38de0/src%2Flibstd%2Fsys_common%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff822fead6249671cbcb090b24bce58fab38de0/src%2Flibstd%2Fsys_common%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fnet.rs?ref=fff822fead6249671cbcb090b24bce58fab38de0", "patch": "@@ -271,7 +271,7 @@ impl TcpStream {\n     }\n \n     pub fn write(&self, buf: &[u8]) -> io::Result<usize> {\n-        let len = cmp::min(buf.len(), <wrlen_t>::max_value() as usize) as wrlen_t;\n+        let len = cmp::min(buf.len(), <wrlen_t>::MAX as usize) as wrlen_t;\n         let ret = cvt(unsafe {\n             c::send(*self.inner.as_inner(), buf.as_ptr() as *const c_void, len, MSG_NOSIGNAL)\n         })?;\n@@ -502,7 +502,7 @@ impl UdpSocket {\n     }\n \n     pub fn send_to(&self, buf: &[u8], dst: &SocketAddr) -> io::Result<usize> {\n-        let len = cmp::min(buf.len(), <wrlen_t>::max_value() as usize) as wrlen_t;\n+        let len = cmp::min(buf.len(), <wrlen_t>::MAX as usize) as wrlen_t;\n         let (dstp, dstlen) = dst.into_inner();\n         let ret = cvt(unsafe {\n             c::sendto(\n@@ -641,7 +641,7 @@ impl UdpSocket {\n     }\n \n     pub fn send(&self, buf: &[u8]) -> io::Result<usize> {\n-        let len = cmp::min(buf.len(), <wrlen_t>::max_value() as usize) as wrlen_t;\n+        let len = cmp::min(buf.len(), <wrlen_t>::MAX as usize) as wrlen_t;\n         let ret = cvt(unsafe {\n             c::send(*self.inner.as_inner(), buf.as_ptr() as *const c_void, len, MSG_NOSIGNAL)\n         })?;"}, {"sha": "d435ca6842518bcd47b05abbd6f15d9e5e0c2c87", "filename": "src/libstd/thread/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fff822fead6249671cbcb090b24bce58fab38de0/src%2Flibstd%2Fthread%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff822fead6249671cbcb090b24bce58fab38de0/src%2Flibstd%2Fthread%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Fmod.rs?ref=fff822fead6249671cbcb090b24bce58fab38de0", "patch": "@@ -1530,7 +1530,6 @@ mod tests {\n     use crate::sync::mpsc::{channel, Sender};\n     use crate::thread::{self, ThreadId};\n     use crate::time::Duration;\n-    use crate::u32;\n \n     // !!! These tests are dangerous. If something is buggy, they will hang, !!!\n     // !!! instead of exiting cleanly. This might wedge the buildbots.       !!!"}, {"sha": "bc3bfde6d7559104fb50d224022ae45fb457b4e9", "filename": "src/libstd/time.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fff822fead6249671cbcb090b24bce58fab38de0/src%2Flibstd%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff822fead6249671cbcb090b24bce58fab38de0/src%2Flibstd%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftime.rs?ref=fff822fead6249671cbcb090b24bce58fab38de0", "patch": "@@ -686,7 +686,7 @@ mod tests {\n \n         // checked_add_duration will not panic on overflow\n         let mut maybe_t = Some(Instant::now());\n-        let max_duration = Duration::from_secs(u64::max_value());\n+        let max_duration = Duration::from_secs(u64::MAX);\n         // in case `Instant` can store `>= now + max_duration`.\n         for _ in 0..2 {\n             maybe_t = maybe_t.and_then(|t| t.checked_add(max_duration));\n@@ -766,7 +766,7 @@ mod tests {\n \n         // checked_add_duration will not panic on overflow\n         let mut maybe_t = Some(SystemTime::UNIX_EPOCH);\n-        let max_duration = Duration::from_secs(u64::max_value());\n+        let max_duration = Duration::from_secs(u64::MAX);\n         // in case `SystemTime` can store `>= UNIX_EPOCH + max_duration`.\n         for _ in 0..2 {\n             maybe_t = maybe_t.and_then(|t| t.checked_add(max_duration));"}, {"sha": "814339e198f95035b7cf787a35a9f5c4a9bbbf3b", "filename": "src/test/rustdoc/show-const-contents.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fff822fead6249671cbcb090b24bce58fab38de0/src%2Ftest%2Frustdoc%2Fshow-const-contents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff822fead6249671cbcb090b24bce58fab38de0/src%2Ftest%2Frustdoc%2Fshow-const-contents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fshow-const-contents.rs?ref=fff822fead6249671cbcb090b24bce58fab38de0", "patch": "@@ -28,8 +28,8 @@ pub const CONST_CALC_I32: i32 = 42 + 1;\n // @!has show_const_contents/constant.CONST_REF_I32.html '; //'\n pub const CONST_REF_I32: &'static i32 = &42;\n \n-// @has show_const_contents/constant.CONST_I32_MAX.html '= i32::max_value(); // 2_147_483_647i32'\n-pub const CONST_I32_MAX: i32 = i32::max_value();\n+// @has show_const_contents/constant.CONST_I32_MAX.html '= i32::MAX; // 2_147_483_647i32'\n+pub const CONST_I32_MAX: i32 = i32::MAX;\n \n // @!has show_const_contents/constant.UNIT.html '= ();'\n // @!has show_const_contents/constant.UNIT.html '; //'\n@@ -56,11 +56,11 @@ pub use std::i32::MAX;\n \n macro_rules! int_module {\n     ($T:ident) => (\n-        pub const MIN: $T = $T::min_value();\n+        pub const MIN: $T = $T::MIN;\n     )\n }\n \n-// @has show_const_contents/constant.MIN.html '= i16::min_value(); // -32_768i16'\n+// @has show_const_contents/constant.MIN.html '= i16::MIN; // -32_768i16'\n int_module!(i16);\n \n // @has show_const_contents/constant.ESCAPE.html //pre '= r#\"<script>alert(\"ESCAPE\");</script>\"#;'"}, {"sha": "e843584b69bb57c34ccf956843ee9b3c38de7c05", "filename": "src/test/ui/consts/const-eval/shift_overflow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fff822fead6249671cbcb090b24bce58fab38de0/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fshift_overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff822fead6249671cbcb090b24bce58fab38de0/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fshift_overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fshift_overflow.rs?ref=fff822fead6249671cbcb090b24bce58fab38de0", "patch": "@@ -1,6 +1,6 @@\n enum Foo {\n     // test that we detect overflows for non-u32 discriminants\n-    X = 1 << ((u32::max_value() as u64) + 1), //~ ERROR E0080\n+    X = 1 << ((u32::MAX as u64) + 1), //~ ERROR E0080\n     Y = 42,\n }\n "}, {"sha": "f4840e9ac96bd7235cf2f7dd4bf80f094857b614", "filename": "src/test/ui/consts/const-eval/shift_overflow.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fff822fead6249671cbcb090b24bce58fab38de0/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fshift_overflow.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fff822fead6249671cbcb090b24bce58fab38de0/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fshift_overflow.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fshift_overflow.stderr?ref=fff822fead6249671cbcb090b24bce58fab38de0", "patch": "@@ -1,8 +1,8 @@\n error[E0080]: evaluation of constant value failed\n   --> $DIR/shift_overflow.rs:3:9\n    |\n-LL |     X = 1 << ((u32::max_value() as u64) + 1),\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ attempt to shift left with overflow\n+LL |     X = 1 << ((u32::MAX as u64) + 1),\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ attempt to shift left with overflow\n \n error: aborting due to previous error\n "}, {"sha": "9c94551f7440e2a523e3e5e4845ea0bc76ff2622", "filename": "src/test/ui/consts/const-int-arithmetic.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/fff822fead6249671cbcb090b24bce58fab38de0/src%2Ftest%2Fui%2Fconsts%2Fconst-int-arithmetic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff822fead6249671cbcb090b24bce58fab38de0/src%2Ftest%2Fui%2Fconsts%2Fconst-int-arithmetic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-int-arithmetic.rs?ref=fff822fead6249671cbcb090b24bce58fab38de0", "patch": "@@ -34,8 +34,8 @@ suite!(\n         C6: 5i8.checked_mul(122), None;\n         C7: (-127i8).checked_mul(-99), None;\n \n-        C8: (i8::min_value() + 1).checked_div(-1), Some(127);\n-        C9: i8::min_value().checked_div(-1), None;\n+        C8: (i8::MIN + 1).checked_div(-1), Some(127);\n+        C9: i8::MIN.checked_div(-1), None;\n         C10: 1i8.checked_div(0), None;\n \n         C11: 5i8.checked_rem(2), Some(1);\n@@ -56,8 +56,8 @@ suite!(\n         C21: i8::MIN.checked_abs(), None;\n \n         // `const_euclidean_int_methods`\n-        C22: (i8::min_value() + 1).checked_div_euclid(-1), Some(127);\n-        C23: i8::min_value().checked_div_euclid(-1), None;\n+        C22: (i8::MIN + 1).checked_div_euclid(-1), Some(127);\n+        C23: i8::MIN.checked_div_euclid(-1), None;\n         C24: (1i8).checked_div_euclid(0), None;\n \n         C25: 5i8.checked_rem_euclid(2), Some(1);\n@@ -72,26 +72,26 @@ suite!(\n     saturating_and_wrapping -> i8 {\n         // `const_saturating_int_methods`\n         C28: 100i8.saturating_add(1), 101;\n-        C29: i8::max_value().saturating_add(100), i8::max_value();\n-        C30: i8::min_value().saturating_add(-1), i8::min_value();\n+        C29: i8::MAX.saturating_add(100), i8::MAX;\n+        C30: i8::MIN.saturating_add(-1), i8::MIN;\n \n         C31: 100i8.saturating_sub(127), -27;\n-        C32: i8::min_value().saturating_sub(100), i8::min_value();\n-        C33: i8::max_value().saturating_sub(-1), i8::max_value();\n+        C32: i8::MIN.saturating_sub(100), i8::MIN;\n+        C33: i8::MAX.saturating_sub(-1), i8::MAX;\n \n         C34: 10i8.saturating_mul(12), 120;\n         C35: i8::MAX.saturating_mul(10), i8::MAX;\n         C36: i8::MIN.saturating_mul(10), i8::MIN;\n \n         C37: 100i8.saturating_neg(), -100;\n         C38: (-100i8).saturating_neg(), 100;\n-        C39: i8::min_value().saturating_neg(), i8::max_value();\n-        C40: i8::max_value().saturating_neg(), i8::min_value() + 1;\n+        C39: i8::MIN.saturating_neg(), i8::MAX;\n+        C40: i8::MAX.saturating_neg(), i8::MIN + 1;\n \n         C57: 100i8.saturating_abs(), 100;\n         C58: (-100i8).saturating_abs(), 100;\n-        C59: i8::min_value().saturating_abs(), i8::max_value();\n-        C60: (i8::min_value() + 1).saturating_abs(), i8::max_value();\n+        C59: i8::MIN.saturating_abs(), i8::MAX;\n+        C60: (i8::MIN + 1).saturating_abs(), i8::MAX;\n \n         // `const_wrapping_int_methods`\n         C41: 100i8.wrapping_div(10), 10;"}, {"sha": "4aaeeaa38853db784a2e2051197996a8b9f967f5", "filename": "src/test/ui/consts/const-int-conversion-rpass.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fff822fead6249671cbcb090b24bce58fab38de0/src%2Ftest%2Fui%2Fconsts%2Fconst-int-conversion-rpass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff822fead6249671cbcb090b24bce58fab38de0/src%2Ftest%2Fui%2Fconsts%2Fconst-int-conversion-rpass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-int-conversion-rpass.rs?ref=fff822fead6249671cbcb090b24bce58fab38de0", "patch": "@@ -6,13 +6,13 @@ const FROM_LE_BYTES: i32 = i32::from_le_bytes([0x12, 0x34, 0x56, 0x78]);\n const FROM_NE_BYTES: i32 = i32::from_be(i32::from_ne_bytes([0x80, 0, 0, 0]));\n const TO_BE_BYTES: [u8; 4] = 0x12_34_56_78_i32.to_be_bytes();\n const TO_LE_BYTES: [u8; 4] = 0x12_34_56_78_i32.to_le_bytes();\n-const TO_NE_BYTES: [u8; 4] = i32::min_value().to_be().to_ne_bytes();\n+const TO_NE_BYTES: [u8; 4] = i32::MIN.to_be().to_ne_bytes();\n \n fn main() {\n     assert_eq!(REVERSE, 0x1e6a2c48);\n     assert_eq!(FROM_BE_BYTES, 0x12_34_56_78);\n     assert_eq!(FROM_LE_BYTES, 0x78_56_34_12);\n-    assert_eq!(FROM_NE_BYTES, i32::min_value());\n+    assert_eq!(FROM_NE_BYTES, i32::MIN);\n     assert_eq!(TO_BE_BYTES, [0x12, 0x34, 0x56, 0x78]);\n     assert_eq!(TO_LE_BYTES, [0x78, 0x56, 0x34, 0x12]);\n     assert_eq!(TO_NE_BYTES, [0x80, 0, 0, 0]);"}, {"sha": "5a05a2b35937abaf33ca0d3db668bc2f6fdd47e9", "filename": "src/test/ui/consts/const-int-conversion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fff822fead6249671cbcb090b24bce58fab38de0/src%2Ftest%2Fui%2Fconsts%2Fconst-int-conversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff822fead6249671cbcb090b24bce58fab38de0/src%2Ftest%2Fui%2Fconsts%2Fconst-int-conversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-int-conversion.rs?ref=fff822fead6249671cbcb090b24bce58fab38de0", "patch": "@@ -11,6 +11,6 @@ fn main() {\n         //~^ ERROR temporary value dropped while borrowed\n     let c: &'static [u8] = &(0x12_34_56_78_i32.to_le_bytes());\n         //~^ ERROR temporary value dropped while borrowed\n-    let d: &'static [u8] = &(i32::min_value().to_be().to_ne_bytes());\n+    let d: &'static [u8] = &(i32::MIN.to_be().to_ne_bytes());\n         //~^ ERROR temporary value dropped while borrowed\n }"}, {"sha": "61162a792262bd98aaca4cfd0de4088a80e9d8f2", "filename": "src/test/ui/consts/const-int-conversion.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fff822fead6249671cbcb090b24bce58fab38de0/src%2Ftest%2Fui%2Fconsts%2Fconst-int-conversion.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fff822fead6249671cbcb090b24bce58fab38de0/src%2Ftest%2Fui%2Fconsts%2Fconst-int-conversion.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-int-conversion.stderr?ref=fff822fead6249671cbcb090b24bce58fab38de0", "patch": "@@ -67,8 +67,8 @@ LL | }\n error[E0716]: temporary value dropped while borrowed\n   --> $DIR/const-int-conversion.rs:14:29\n    |\n-LL |     let d: &'static [u8] = &(i32::min_value().to_be().to_ne_bytes());\n-   |            -------------    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ creates a temporary which is freed while still in use\n+LL |     let d: &'static [u8] = &(i32::MIN.to_be().to_ne_bytes());\n+   |            -------------    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ creates a temporary which is freed while still in use\n    |            |\n    |            type annotation requires that borrow lasts for `'static`\n LL |"}, {"sha": "eecb88becabcabc5fd5484f3fd205b80d88689bd", "filename": "src/test/ui/consts/const-int-overflowing-rpass.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fff822fead6249671cbcb090b24bce58fab38de0/src%2Ftest%2Fui%2Fconsts%2Fconst-int-overflowing-rpass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff822fead6249671cbcb090b24bce58fab38de0/src%2Ftest%2Fui%2Fconsts%2Fconst-int-overflowing-rpass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-int-overflowing-rpass.rs?ref=fff822fead6249671cbcb090b24bce58fab38de0", "patch": "@@ -1,7 +1,7 @@\n // run-pass\n \n const ADD_A: (u32, bool) = 5u32.overflowing_add(2);\n-const ADD_B: (u32, bool) = u32::max_value().overflowing_add(1);\n+const ADD_B: (u32, bool) = u32::MAX.overflowing_add(1);\n \n const SUB_A: (u32, bool) = 5u32.overflowing_sub(2);\n const SUB_B: (u32, bool) = 0u32.overflowing_sub(1);\n@@ -20,14 +20,14 @@ const NEG_B: (u32, bool) = core::u32::MAX.overflowing_neg();\n \n const ABS_POS: (i32, bool) = 10i32.overflowing_abs();\n const ABS_NEG: (i32, bool) = (-10i32).overflowing_abs();\n-const ABS_MIN: (i32, bool) = i32::min_value().overflowing_abs();\n+const ABS_MIN: (i32, bool) = i32::MIN.overflowing_abs();\n \n fn main() {\n     assert_eq!(ADD_A, (7, false));\n     assert_eq!(ADD_B, (0, true));\n \n     assert_eq!(SUB_A, (3, false));\n-    assert_eq!(SUB_B, (u32::max_value(), true));\n+    assert_eq!(SUB_B, (u32::MAX, true));\n \n     assert_eq!(MUL_A, (10, false));\n     assert_eq!(MUL_B, (1410065408, true));\n@@ -43,5 +43,5 @@ fn main() {\n \n     assert_eq!(ABS_POS, (10, false));\n     assert_eq!(ABS_NEG, (10, false));\n-    assert_eq!(ABS_MIN, (i32::min_value(), true));\n+    assert_eq!(ABS_MIN, (i32::MIN, true));\n }"}, {"sha": "4f936236dbb206470025ebe13aa3e714a4f51b04", "filename": "src/test/ui/consts/const-int-pow-rpass.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fff822fead6249671cbcb090b24bce58fab38de0/src%2Ftest%2Fui%2Fconsts%2Fconst-int-pow-rpass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff822fead6249671cbcb090b24bce58fab38de0/src%2Ftest%2Fui%2Fconsts%2Fconst-int-pow-rpass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-int-pow-rpass.rs?ref=fff822fead6249671cbcb090b24bce58fab38de0", "patch": "@@ -20,10 +20,10 @@ const NEXT_POWER_OF_TWO: u32 = 3u32.next_power_of_two();\n \n const CHECKED_NEXT_POWER_OF_TWO_OK: Option<u32> = 3u32.checked_next_power_of_two();\n const CHECKED_NEXT_POWER_OF_TWO_OVERFLOW: Option<u32> =\n-    u32::max_value().checked_next_power_of_two();\n+    u32::MAX.checked_next_power_of_two();\n \n const WRAPPING_NEXT_POWER_OF_TWO: u32 =\n-    u32::max_value().wrapping_next_power_of_two();\n+    u32::MAX.wrapping_next_power_of_two();\n \n fn main() {\n     assert!(!IS_POWER_OF_TWO_A);\n@@ -37,7 +37,7 @@ fn main() {\n \n     assert_eq!(WRAPPING_POW, 217);\n     assert_eq!(OVERFLOWING_POW, (217, true));\n-    assert_eq!(SATURATING_POW, u8::max_value());\n+    assert_eq!(SATURATING_POW, u8::MAX);\n \n     assert_eq!(NEXT_POWER_OF_TWO, 4);\n "}, {"sha": "4718120a51bd3529d87a1400a6895c6e55b3c13e", "filename": "src/test/ui/consts/const-int-saturating-arith.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/fff822fead6249671cbcb090b24bce58fab38de0/src%2Ftest%2Fui%2Fconsts%2Fconst-int-saturating-arith.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff822fead6249671cbcb090b24bce58fab38de0/src%2Ftest%2Fui%2Fconsts%2Fconst-int-saturating-arith.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-int-saturating-arith.rs?ref=fff822fead6249671cbcb090b24bce58fab38de0", "patch": "@@ -2,33 +2,33 @@\n #![feature(const_saturating_int_methods)]\n \n const INT_U32_NO: u32 = (42 as u32).saturating_add(2);\n-const INT_U32: u32 = u32::max_value().saturating_add(1);\n-const INT_U128: u128 = u128::max_value().saturating_add(1);\n-const INT_I128: i128 = i128::max_value().saturating_add(1);\n-const INT_I128_NEG: i128 = i128::min_value().saturating_add(-1);\n+const INT_U32: u32 = u32::MAX.saturating_add(1);\n+const INT_U128: u128 = u128::MAX.saturating_add(1);\n+const INT_I128: i128 = i128::MAX.saturating_add(1);\n+const INT_I128_NEG: i128 = i128::MIN.saturating_add(-1);\n \n const INT_U32_NO_SUB: u32 = (42 as u32).saturating_sub(2);\n const INT_U32_SUB: u32 = (1 as u32).saturating_sub(2);\n const INT_I32_NO_SUB: i32 = (-42 as i32).saturating_sub(2);\n-const INT_I32_NEG_SUB: i32 = i32::min_value().saturating_sub(1);\n-const INT_I32_POS_SUB: i32 = i32::max_value().saturating_sub(-1);\n+const INT_I32_NEG_SUB: i32 = i32::MIN.saturating_sub(1);\n+const INT_I32_POS_SUB: i32 = i32::MAX.saturating_sub(-1);\n const INT_U128_SUB: u128 = (0 as u128).saturating_sub(1);\n-const INT_I128_NEG_SUB: i128 = i128::min_value().saturating_sub(1);\n-const INT_I128_POS_SUB: i128 = i128::max_value().saturating_sub(-1);\n+const INT_I128_NEG_SUB: i128 = i128::MIN.saturating_sub(1);\n+const INT_I128_POS_SUB: i128 = i128::MAX.saturating_sub(-1);\n \n fn main() {\n     assert_eq!(INT_U32_NO, 44);\n-    assert_eq!(INT_U32, u32::max_value());\n-    assert_eq!(INT_U128, u128::max_value());\n-    assert_eq!(INT_I128, i128::max_value());\n-    assert_eq!(INT_I128_NEG, i128::min_value());\n+    assert_eq!(INT_U32, u32::MAX);\n+    assert_eq!(INT_U128, u128::MAX);\n+    assert_eq!(INT_I128, i128::MAX);\n+    assert_eq!(INT_I128_NEG, i128::MIN);\n \n     assert_eq!(INT_U32_NO_SUB, 40);\n     assert_eq!(INT_U32_SUB, 0);\n     assert_eq!(INT_I32_NO_SUB, -44);\n-    assert_eq!(INT_I32_NEG_SUB, i32::min_value());\n-    assert_eq!(INT_I32_POS_SUB, i32::max_value());\n+    assert_eq!(INT_I32_NEG_SUB, i32::MIN);\n+    assert_eq!(INT_I32_POS_SUB, i32::MAX);\n     assert_eq!(INT_U128_SUB, 0);\n-    assert_eq!(INT_I128_NEG_SUB, i128::min_value());\n-    assert_eq!(INT_I128_POS_SUB, i128::max_value());\n+    assert_eq!(INT_I128_NEG_SUB, i128::MIN);\n+    assert_eq!(INT_I128_POS_SUB, i128::MAX);\n }"}, {"sha": "1596093b2c14b0492aadf7ff11a4c2453e6e5b80", "filename": "src/test/ui/consts/const-int-unchecked.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fff822fead6249671cbcb090b24bce58fab38de0/src%2Ftest%2Fui%2Fconsts%2Fconst-int-unchecked.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff822fead6249671cbcb090b24bce58fab38de0/src%2Ftest%2Fui%2Fconsts%2Fconst-int-unchecked.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-int-unchecked.rs?ref=fff822fead6249671cbcb090b24bce58fab38de0", "patch": "@@ -131,12 +131,12 @@ const _: u16 = unsafe { std::intrinsics::unchecked_mul(300u16, 250u16) };\n \n const _: i32 = unsafe { std::intrinsics::unchecked_div(1, 0) };\n //~^ ERROR any use of this value will cause an error\n-const _: i32 = unsafe { std::intrinsics::unchecked_div(i32::min_value(), -1) };\n+const _: i32 = unsafe { std::intrinsics::unchecked_div(i32::MIN, -1) };\n //~^ ERROR any use of this value will cause an error\n \n const _: i32 = unsafe { std::intrinsics::unchecked_rem(1, 0) };\n //~^ ERROR any use of this value will cause an error\n-const _: i32 = unsafe { std::intrinsics::unchecked_rem(i32::min_value(), -1) };\n+const _: i32 = unsafe { std::intrinsics::unchecked_rem(i32::MIN, -1) };\n //~^ ERROR any use of this value will cause an error\n \n fn main() {}"}, {"sha": "0287b404e7d465b40df39e2b3479a1f98ffd778b", "filename": "src/test/ui/consts/const-int-unchecked.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fff822fead6249671cbcb090b24bce58fab38de0/src%2Ftest%2Fui%2Fconsts%2Fconst-int-unchecked.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fff822fead6249671cbcb090b24bce58fab38de0/src%2Ftest%2Fui%2Fconsts%2Fconst-int-unchecked.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-int-unchecked.stderr?ref=fff822fead6249671cbcb090b24bce58fab38de0", "patch": "@@ -355,8 +355,8 @@ LL | const _: i32 = unsafe { std::intrinsics::unchecked_div(1, 0) };\n error: any use of this value will cause an error\n   --> $DIR/const-int-unchecked.rs:134:25\n    |\n-LL | const _: i32 = unsafe { std::intrinsics::unchecked_div(i32::min_value(), -1) };\n-   | ------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---\n+LL | const _: i32 = unsafe { std::intrinsics::unchecked_div(i32::MIN, -1) };\n+   | ------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---\n    |                         |\n    |                         overflow executing `unchecked_div`\n \n@@ -371,8 +371,8 @@ LL | const _: i32 = unsafe { std::intrinsics::unchecked_rem(1, 0) };\n error: any use of this value will cause an error\n   --> $DIR/const-int-unchecked.rs:139:25\n    |\n-LL | const _: i32 = unsafe { std::intrinsics::unchecked_rem(i32::min_value(), -1) };\n-   | ------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---\n+LL | const _: i32 = unsafe { std::intrinsics::unchecked_rem(i32::MIN, -1) };\n+   | ------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---\n    |                         |\n    |                         overflow executing `unchecked_rem`\n "}, {"sha": "225d1e9393db470987d704330fbce7c8b4a716f5", "filename": "src/test/ui/consts/const-int-wrapping-rpass.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fff822fead6249671cbcb090b24bce58fab38de0/src%2Ftest%2Fui%2Fconsts%2Fconst-int-wrapping-rpass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff822fead6249671cbcb090b24bce58fab38de0/src%2Ftest%2Fui%2Fconsts%2Fconst-int-wrapping-rpass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-int-wrapping-rpass.rs?ref=fff822fead6249671cbcb090b24bce58fab38de0", "patch": "@@ -1,10 +1,10 @@\n // run-pass\n \n const ADD_A: u32 = 200u32.wrapping_add(55);\n-const ADD_B: u32 = 200u32.wrapping_add(u32::max_value());\n+const ADD_B: u32 = 200u32.wrapping_add(u32::MAX);\n \n const SUB_A: u32 = 100u32.wrapping_sub(100);\n-const SUB_B: u32 = 100u32.wrapping_sub(u32::max_value());\n+const SUB_B: u32 = 100u32.wrapping_sub(u32::MAX);\n \n const MUL_A: u8 = 10u8.wrapping_mul(12);\n const MUL_B: u8 = 25u8.wrapping_mul(12);\n@@ -20,7 +20,7 @@ const NEG_B: u32 = 1234567890u32.wrapping_neg();\n \n const ABS_POS: i32 = 10i32.wrapping_abs();\n const ABS_NEG: i32 = (-10i32).wrapping_abs();\n-const ABS_MIN: i32 = i32::min_value().wrapping_abs();\n+const ABS_MIN: i32 = i32::MIN.wrapping_abs();\n \n fn main() {\n     assert_eq!(ADD_A, 255);\n@@ -43,5 +43,5 @@ fn main() {\n \n     assert_eq!(ABS_POS, 10);\n     assert_eq!(ABS_NEG, 10);\n-    assert_eq!(ABS_MIN, i32::min_value());\n+    assert_eq!(ABS_MIN, i32::MIN);\n }"}, {"sha": "4e2cc89948a01e8d86c584d9b97c2c32d926f80d", "filename": "src/test/ui/enum-discriminant/issue-70509-partial_eq.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fff822fead6249671cbcb090b24bce58fab38de0/src%2Ftest%2Fui%2Fenum-discriminant%2Fissue-70509-partial_eq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff822fead6249671cbcb090b24bce58fab38de0/src%2Ftest%2Fui%2Fenum-discriminant%2Fissue-70509-partial_eq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fenum-discriminant%2Fissue-70509-partial_eq.rs?ref=fff822fead6249671cbcb090b24bce58fab38de0", "patch": "@@ -5,7 +5,7 @@\n #[repr(i128)]\n enum Test {\n     A(Box<u64>) = 0,\n-    B(usize) = u64::max_value() as i128 + 1,\n+    B(usize) = u64::MAX as i128 + 1,\n }\n \n fn main() {"}, {"sha": "eefbc44f585b28bf412e8e05fd6e944030adb7ed", "filename": "src/test/ui/enum-discriminant/repr128.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/fff822fead6249671cbcb090b24bce58fab38de0/src%2Ftest%2Fui%2Fenum-discriminant%2Frepr128.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff822fead6249671cbcb090b24bce58fab38de0/src%2Ftest%2Fui%2Fenum-discriminant%2Frepr128.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fenum-discriminant%2Frepr128.rs?ref=fff822fead6249671cbcb090b24bce58fab38de0", "patch": "@@ -8,17 +8,17 @@ use std::marker::DiscriminantKind;\n enum Signed {\n     Zero = 0,\n     Staircase = 0x01_02_03_04_05_06_07_08_09_0a_0b_0c_0d_0e_0f,\n-    U64Limit = u64::max_value() as i128 + 1,\n+    U64Limit = u64::MAX as i128 + 1,\n     SmallNegative = -1,\n-    BigNegative = i128::min_value(),\n+    BigNegative = i128::MIN,\n     Next,\n }\n \n #[repr(u128)]\n enum Unsigned {\n     Zero = 0,\n     Staircase = 0x01_02_03_04_05_06_07_08_09_0a_0b_0c_0d_0e_0f,\n-    U64Limit = u64::max_value() as u128 + 1,\n+    U64Limit = u64::MAX as u128 + 1,\n     Next,\n }\n \n@@ -32,13 +32,13 @@ where\n fn main() {\n     discr(Signed::Zero, 0);\n     discr(Signed::Staircase, 0x01_02_03_04_05_06_07_08_09_0a_0b_0c_0d_0e_0f);\n-    discr(Signed::U64Limit, u64::max_value() as i128 + 1);\n+    discr(Signed::U64Limit, u64::MAX as i128 + 1);\n     discr(Signed::SmallNegative, -1);\n-    discr(Signed::BigNegative, i128::min_value());\n-    discr(Signed::Next, i128::min_value() + 1);\n+    discr(Signed::BigNegative, i128::MIN);\n+    discr(Signed::Next, i128::MIN + 1);\n \n     discr(Unsigned::Zero, 0);\n     discr(Unsigned::Staircase, 0x01_02_03_04_05_06_07_08_09_0a_0b_0c_0d_0e_0f);\n-    discr(Unsigned::U64Limit, u64::max_value() as u128 + 1);\n-    discr(Unsigned::Next, u64::max_value() as u128 + 2);\n+    discr(Unsigned::U64Limit, u64::MAX as u128 + 1);\n+    discr(Unsigned::Next, u64::MAX as u128 + 2);\n }"}, {"sha": "78cfecf2f32f049d4882bb2e9b1a8d3e1292991d", "filename": "src/test/ui/issues/issue-44216-add-instant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fff822fead6249671cbcb090b24bce58fab38de0/src%2Ftest%2Fui%2Fissues%2Fissue-44216-add-instant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff822fead6249671cbcb090b24bce58fab38de0/src%2Ftest%2Fui%2Fissues%2Fissue-44216-add-instant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-44216-add-instant.rs?ref=fff822fead6249671cbcb090b24bce58fab38de0", "patch": "@@ -6,5 +6,5 @@ use std::time::{Instant, Duration};\n \n fn main() {\n     let now = Instant::now();\n-    let _ = now + Duration::from_secs(u64::max_value());\n+    let _ = now + Duration::from_secs(u64::MAX);\n }"}, {"sha": "7e9a3f802ec89a28b89150f1c4bf2b8e7653672d", "filename": "src/test/ui/issues/issue-44216-add-system-time.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fff822fead6249671cbcb090b24bce58fab38de0/src%2Ftest%2Fui%2Fissues%2Fissue-44216-add-system-time.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff822fead6249671cbcb090b24bce58fab38de0/src%2Ftest%2Fui%2Fissues%2Fissue-44216-add-system-time.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-44216-add-system-time.rs?ref=fff822fead6249671cbcb090b24bce58fab38de0", "patch": "@@ -6,5 +6,5 @@ use std::time::{Duration, SystemTime};\n \n fn main() {\n     let now = SystemTime::now();\n-    let _ = now + Duration::from_secs(u64::max_value());\n+    let _ = now + Duration::from_secs(u64::MAX);\n }"}, {"sha": "e40f80d449d96fed59794c8b97ca5b57ffdaa6ad", "filename": "src/test/ui/issues/issue-44216-sub-instant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fff822fead6249671cbcb090b24bce58fab38de0/src%2Ftest%2Fui%2Fissues%2Fissue-44216-sub-instant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff822fead6249671cbcb090b24bce58fab38de0/src%2Ftest%2Fui%2Fissues%2Fissue-44216-sub-instant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-44216-sub-instant.rs?ref=fff822fead6249671cbcb090b24bce58fab38de0", "patch": "@@ -6,5 +6,5 @@ use std::time::{Instant, Duration};\n \n fn main() {\n     let now = Instant::now();\n-    let _ = now - Duration::from_secs(u64::max_value());\n+    let _ = now - Duration::from_secs(u64::MAX);\n }"}, {"sha": "2c5a000fab692d42b3de9ac92029b1b594b9b083", "filename": "src/test/ui/issues/issue-44216-sub-system-time.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fff822fead6249671cbcb090b24bce58fab38de0/src%2Ftest%2Fui%2Fissues%2Fissue-44216-sub-system-time.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff822fead6249671cbcb090b24bce58fab38de0/src%2Ftest%2Fui%2Fissues%2Fissue-44216-sub-system-time.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-44216-sub-system-time.rs?ref=fff822fead6249671cbcb090b24bce58fab38de0", "patch": "@@ -6,5 +6,5 @@ use std::time::{Duration, SystemTime};\n \n fn main() {\n     let now = SystemTime::now();\n-    let _ = now - Duration::from_secs(u64::max_value());\n+    let _ = now - Duration::from_secs(u64::MAX);\n }"}, {"sha": "a7de4bd74aae4550dab11cf585d665fc1a9e3604", "filename": "src/test/ui/issues/issue-8460.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/fff822fead6249671cbcb090b24bce58fab38de0/src%2Ftest%2Fui%2Fissues%2Fissue-8460.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff822fead6249671cbcb090b24bce58fab38de0/src%2Ftest%2Fui%2Fissues%2Fissue-8460.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-8460.rs?ref=fff822fead6249671cbcb090b24bce58fab38de0", "patch": "@@ -27,21 +27,21 @@ macro_rules! check {\n \n fn main() {\n     check![\n-        isize::min_value() / -isize::one(),\n-        i8::min_value() / -i8::one(),\n-        i16::min_value() / -i16::one(),\n-        i32::min_value() / -i32::one(),\n-        i64::min_value() / -i64::one(),\n+        isize::MIN / -isize::one(),\n+        i8::MIN / -i8::one(),\n+        i16::MIN / -i16::one(),\n+        i32::MIN / -i32::one(),\n+        i64::MIN / -i64::one(),\n         1isize / isize::zero(),\n         1i8 / i8::zero(),\n         1i16 / i16::zero(),\n         1i32 / i32::zero(),\n         1i64 / i64::zero(),\n-        isize::min_value() % -isize::one(),\n-        i8::min_value() % -i8::one(),\n-        i16::min_value() % -i16::one(),\n-        i32::min_value() % -i32::one(),\n-        i64::min_value() % -i64::one(),\n+        isize::MIN % -isize::one(),\n+        i8::MIN % -i8::one(),\n+        i16::MIN % -i16::one(),\n+        i32::MIN % -i32::one(),\n+        i64::MIN % -i64::one(),\n         1isize % isize::zero(),\n         1i8 % i8::zero(),\n         1i16 % i16::zero(),"}, {"sha": "67605d2fcc25389d54813e72a94c100deeec1f7f", "filename": "src/test/ui/iterators/iter-step-overflow-debug.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fff822fead6249671cbcb090b24bce58fab38de0/src%2Ftest%2Fui%2Fiterators%2Fiter-step-overflow-debug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff822fead6249671cbcb090b24bce58fab38de0/src%2Ftest%2Fui%2Fiterators%2Fiter-step-overflow-debug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fiterators%2Fiter-step-overflow-debug.rs?ref=fff822fead6249671cbcb090b24bce58fab38de0", "patch": "@@ -6,14 +6,14 @@ use std::panic;\n \n fn main() {\n     let r = panic::catch_unwind(|| {\n-        let mut it = u8::max_value()..;\n+        let mut it = u8::MAX..;\n         it.next().unwrap(); // 255\n         it.next().unwrap();\n     });\n     assert!(r.is_err());\n \n     let r = panic::catch_unwind(|| {\n-        let mut it = i8::max_value()..;\n+        let mut it = i8::MAX..;\n         it.next().unwrap(); // 127\n         it.next().unwrap();\n     });"}, {"sha": "33e708769badb7db38f32013e19a6fc517ac6483", "filename": "src/test/ui/iterators/iter-step-overflow-ndebug.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fff822fead6249671cbcb090b24bce58fab38de0/src%2Ftest%2Fui%2Fiterators%2Fiter-step-overflow-ndebug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff822fead6249671cbcb090b24bce58fab38de0/src%2Ftest%2Fui%2Fiterators%2Fiter-step-overflow-ndebug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fiterators%2Fiter-step-overflow-ndebug.rs?ref=fff822fead6249671cbcb090b24bce58fab38de0", "patch": "@@ -2,11 +2,11 @@\n // compile-flags: -C debug_assertions=no\n \n fn main() {\n-    let mut it = u8::max_value()..;\n+    let mut it = u8::MAX..;\n     assert_eq!(it.next().unwrap(), 255);\n-    assert_eq!(it.next().unwrap(), u8::min_value());\n+    assert_eq!(it.next().unwrap(), u8::MIN);\n \n-    let mut it = i8::max_value()..;\n+    let mut it = i8::MAX..;\n     assert_eq!(it.next().unwrap(), 127);\n-    assert_eq!(it.next().unwrap(), i8::min_value());\n+    assert_eq!(it.next().unwrap(), i8::MIN);\n }"}, {"sha": "b7667d1bbf6d9699c42d220f3c334c7e90f4b337", "filename": "src/test/ui/iterators/iter-sum-overflow-debug.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fff822fead6249671cbcb090b24bce58fab38de0/src%2Ftest%2Fui%2Fiterators%2Fiter-sum-overflow-debug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff822fead6249671cbcb090b24bce58fab38de0/src%2Ftest%2Fui%2Fiterators%2Fiter-sum-overflow-debug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fiterators%2Fiter-sum-overflow-debug.rs?ref=fff822fead6249671cbcb090b24bce58fab38de0", "patch": "@@ -6,22 +6,22 @@ use std::panic;\n \n fn main() {\n     let r = panic::catch_unwind(|| {\n-        [1, i32::max_value()].iter().sum::<i32>();\n+        [1, i32::MAX].iter().sum::<i32>();\n     });\n     assert!(r.is_err());\n \n     let r = panic::catch_unwind(|| {\n-        [2, i32::max_value()].iter().product::<i32>();\n+        [2, i32::MAX].iter().product::<i32>();\n     });\n     assert!(r.is_err());\n \n     let r = panic::catch_unwind(|| {\n-        [1, i32::max_value()].iter().cloned().sum::<i32>();\n+        [1, i32::MAX].iter().cloned().sum::<i32>();\n     });\n     assert!(r.is_err());\n \n     let r = panic::catch_unwind(|| {\n-        [2, i32::max_value()].iter().cloned().product::<i32>();\n+        [2, i32::MAX].iter().cloned().product::<i32>();\n     });\n     assert!(r.is_err());\n }"}, {"sha": "69f4744cc2a1a6d940dcedbf4b69773fc5559377", "filename": "src/test/ui/iterators/iter-sum-overflow-ndebug.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/fff822fead6249671cbcb090b24bce58fab38de0/src%2Ftest%2Fui%2Fiterators%2Fiter-sum-overflow-ndebug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff822fead6249671cbcb090b24bce58fab38de0/src%2Ftest%2Fui%2Fiterators%2Fiter-sum-overflow-ndebug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fiterators%2Fiter-sum-overflow-ndebug.rs?ref=fff822fead6249671cbcb090b24bce58fab38de0", "patch": "@@ -2,13 +2,13 @@\n // compile-flags: -C debug_assertions=no\n \n fn main() {\n-    assert_eq!([1i32, i32::max_value()].iter().sum::<i32>(),\n-               1i32.wrapping_add(i32::max_value()));\n-    assert_eq!([2i32, i32::max_value()].iter().product::<i32>(),\n-               2i32.wrapping_mul(i32::max_value()));\n+    assert_eq!([1i32, i32::MAX].iter().sum::<i32>(),\n+               1i32.wrapping_add(i32::MAX));\n+    assert_eq!([2i32, i32::MAX].iter().product::<i32>(),\n+               2i32.wrapping_mul(i32::MAX));\n \n-    assert_eq!([1i32, i32::max_value()].iter().cloned().sum::<i32>(),\n-               1i32.wrapping_add(i32::max_value()));\n-    assert_eq!([2i32, i32::max_value()].iter().cloned().product::<i32>(),\n-               2i32.wrapping_mul(i32::max_value()));\n+    assert_eq!([1i32, i32::MAX].iter().cloned().sum::<i32>(),\n+               1i32.wrapping_add(i32::MAX));\n+    assert_eq!([2i32, i32::MAX].iter().cloned().product::<i32>(),\n+               2i32.wrapping_mul(i32::MAX));\n }"}, {"sha": "04ca7f8a3153422dde04a558088ae13c0a404b33", "filename": "src/test/ui/iterators/iter-sum-overflow-overflow-checks.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fff822fead6249671cbcb090b24bce58fab38de0/src%2Ftest%2Fui%2Fiterators%2Fiter-sum-overflow-overflow-checks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff822fead6249671cbcb090b24bce58fab38de0/src%2Ftest%2Fui%2Fiterators%2Fiter-sum-overflow-overflow-checks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fiterators%2Fiter-sum-overflow-overflow-checks.rs?ref=fff822fead6249671cbcb090b24bce58fab38de0", "patch": "@@ -6,22 +6,22 @@ use std::panic;\n \n fn main() {\n     let r = panic::catch_unwind(|| {\n-        [1, i32::max_value()].iter().sum::<i32>();\n+        [1, i32::MAX].iter().sum::<i32>();\n     });\n     assert!(r.is_err());\n \n     let r = panic::catch_unwind(|| {\n-        [2, i32::max_value()].iter().product::<i32>();\n+        [2, i32::MAX].iter().product::<i32>();\n     });\n     assert!(r.is_err());\n \n     let r = panic::catch_unwind(|| {\n-        [1, i32::max_value()].iter().cloned().sum::<i32>();\n+        [1, i32::MAX].iter().cloned().sum::<i32>();\n     });\n     assert!(r.is_err());\n \n     let r = panic::catch_unwind(|| {\n-        [2, i32::max_value()].iter().cloned().product::<i32>();\n+        [2, i32::MAX].iter().cloned().product::<i32>();\n     });\n     assert!(r.is_err());\n }"}, {"sha": "64dee3e3c8b2029770789648d4c81966c8fe6f26", "filename": "src/test/ui/iterators/skip-count-overflow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fff822fead6249671cbcb090b24bce58fab38de0/src%2Ftest%2Fui%2Fiterators%2Fskip-count-overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff822fead6249671cbcb090b24bce58fab38de0/src%2Ftest%2Fui%2Fiterators%2Fskip-count-overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fiterators%2Fskip-count-overflow.rs?ref=fff822fead6249671cbcb090b24bce58fab38de0", "patch": "@@ -3,6 +3,6 @@\n // compile-flags: -C overflow-checks -C opt-level=3\n \n fn main() {\n-    let i = (0..usize::max_value()).chain(0..10).skip(usize::max_value());\n+    let i = (0..usize::MAX).chain(0..10).skip(usize::MAX);\n     assert_eq!(i.count(), 10);\n }"}, {"sha": "d61a1ab03b6b3cae5c7f97eb6dee055d79040edf", "filename": "src/test/ui/numbers-arithmetic/i128.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fff822fead6249671cbcb090b24bce58fab38de0/src%2Ftest%2Fui%2Fnumbers-arithmetic%2Fi128.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff822fead6249671cbcb090b24bce58fab38de0/src%2Ftest%2Fui%2Fnumbers-arithmetic%2Fi128.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnumbers-arithmetic%2Fi128.rs?ref=fff822fead6249671cbcb090b24bce58fab38de0", "patch": "@@ -87,7 +87,7 @@ fn main() {\n     assert_eq!((-z).checked_mul(-z), Some(0x734C_C2F2_A521));\n     assert_eq!((z).checked_mul(z), Some(0x734C_C2F2_A521));\n     assert_eq!((k).checked_mul(k), None);\n-    let l: i128 = b(i128::min_value());\n+    let l: i128 = b(i128::MIN);\n     let o: i128 = b(17);\n     assert_eq!(l.checked_sub(b(2)), None);\n     assert_eq!(l.checked_add(l), None);"}, {"sha": "10ec3f0c6624e73ce29211b01c16eaf721c2a626", "filename": "src/test/ui/numbers-arithmetic/int-abs-overflow.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fff822fead6249671cbcb090b24bce58fab38de0/src%2Ftest%2Fui%2Fnumbers-arithmetic%2Fint-abs-overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff822fead6249671cbcb090b24bce58fab38de0/src%2Ftest%2Fui%2Fnumbers-arithmetic%2Fint-abs-overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnumbers-arithmetic%2Fint-abs-overflow.rs?ref=fff822fead6249671cbcb090b24bce58fab38de0", "patch": "@@ -5,9 +5,9 @@\n use std::thread;\n \n fn main() {\n-    assert!(thread::spawn(|| i8::min_value().abs()).join().is_err());\n-    assert!(thread::spawn(|| i16::min_value().abs()).join().is_err());\n-    assert!(thread::spawn(|| i32::min_value().abs()).join().is_err());\n-    assert!(thread::spawn(|| i64::min_value().abs()).join().is_err());\n-    assert!(thread::spawn(|| isize::min_value().abs()).join().is_err());\n+    assert!(thread::spawn(|| i8::MIN.abs()).join().is_err());\n+    assert!(thread::spawn(|| i16::MIN.abs()).join().is_err());\n+    assert!(thread::spawn(|| i32::MIN.abs()).join().is_err());\n+    assert!(thread::spawn(|| i64::MIN.abs()).join().is_err());\n+    assert!(thread::spawn(|| isize::MIN.abs()).join().is_err());\n }"}, {"sha": "101c5d50b20b91ba293d2ba1d0620f89744cbf18", "filename": "src/test/ui/numbers-arithmetic/next-power-of-two-overflow-debug.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fff822fead6249671cbcb090b24bce58fab38de0/src%2Ftest%2Fui%2Fnumbers-arithmetic%2Fnext-power-of-two-overflow-debug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff822fead6249671cbcb090b24bce58fab38de0/src%2Ftest%2Fui%2Fnumbers-arithmetic%2Fnext-power-of-two-overflow-debug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnumbers-arithmetic%2Fnext-power-of-two-overflow-debug.rs?ref=fff822fead6249671cbcb090b24bce58fab38de0", "patch": "@@ -9,12 +9,12 @@ fn main() {\n     macro_rules! overflow_test {\n         ($t:ident) => (\n             let r = panic::catch_unwind(|| {\n-                ($t::max_value()).next_power_of_two()\n+                ($t::MAX).next_power_of_two()\n             });\n             assert!(r.is_err());\n \n             let r = panic::catch_unwind(|| {\n-                (($t::max_value() >> 1) + 2).next_power_of_two()\n+                (($t::MAX >> 1) + 2).next_power_of_two()\n             });\n             assert!(r.is_err());\n         )"}, {"sha": "4785abbc55470b76b855b4940f82db910fd1efca", "filename": "src/test/ui/numbers-arithmetic/promoted_overflow_opt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fff822fead6249671cbcb090b24bce58fab38de0/src%2Ftest%2Fui%2Fnumbers-arithmetic%2Fpromoted_overflow_opt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff822fead6249671cbcb090b24bce58fab38de0/src%2Ftest%2Fui%2Fnumbers-arithmetic%2Fpromoted_overflow_opt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnumbers-arithmetic%2Fpromoted_overflow_opt.rs?ref=fff822fead6249671cbcb090b24bce58fab38de0", "patch": "@@ -5,5 +5,5 @@\n \n fn main() {\n     let x = &(0u32 - 1);\n-    assert_eq!(*x, u32::max_value())\n+    assert_eq!(*x, u32::MAX)\n }"}, {"sha": "d7e28055b2154b585df41d401fe9bbd02c7e4982", "filename": "src/test/ui/numbers-arithmetic/u128.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fff822fead6249671cbcb090b24bce58fab38de0/src%2Ftest%2Fui%2Fnumbers-arithmetic%2Fu128.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff822fead6249671cbcb090b24bce58fab38de0/src%2Ftest%2Fui%2Fnumbers-arithmetic%2Fu128.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnumbers-arithmetic%2Fu128.rs?ref=fff822fead6249671cbcb090b24bce58fab38de0", "patch": "@@ -53,14 +53,14 @@ fn main() {\n     assert_eq!(\"10000000000000000000000000000000000000000000000000000000000000000000\",\n                format!(\"{:b}\", j));\n     assert_eq!(\"340282366920938463463374607431768211455\",\n-        format!(\"{}\", u128::max_value()));\n+        format!(\"{}\", u128::MAX));\n     assert_eq!(\"147573952589676412928\", format!(\"{:?}\", j));\n     // common traits\n     assert_eq!(x, b(x.clone()));\n     // overflow checks\n     assert_eq!((z).checked_mul(z), Some(0x734C_C2F2_A521));\n     assert_eq!((k).checked_mul(k), None);\n-    let l: u128 = b(u128::max_value() - 10);\n+    let l: u128 = b(u128::MAX - 10);\n     let o: u128 = b(17);\n     assert_eq!(l.checked_add(b(11)), None);\n     assert_eq!(l.checked_sub(l), Some(0));"}, {"sha": "b7b3ec997810e72c089c222916e0054e74253cb4", "filename": "src/test/ui/simd/simd-intrinsic-generic-arithmetic-saturating.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fff822fead6249671cbcb090b24bce58fab38de0/src%2Ftest%2Fui%2Fsimd%2Fsimd-intrinsic-generic-arithmetic-saturating.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff822fead6249671cbcb090b24bce58fab38de0/src%2Ftest%2Fui%2Fsimd%2Fsimd-intrinsic-generic-arithmetic-saturating.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsimd%2Fsimd-intrinsic-generic-arithmetic-saturating.rs?ref=fff822fead6249671cbcb090b24bce58fab38de0", "patch": "@@ -20,7 +20,7 @@ extern \"platform-intrinsic\" {\n fn main() {\n     // unsigned\n     {\n-        const M: u32 = u32::max_value();\n+        const M: u32 = u32::MAX;\n \n         let a = u32x4(1, 2, 3, 4);\n         let b = u32x4(2, 4, 6, 8);\n@@ -48,8 +48,8 @@ fn main() {\n \n     // signed\n     {\n-        const MIN: i32 = i32::min_value();\n-        const MAX: i32 = i32::max_value();\n+        const MIN: i32 = i32::MIN;\n+        const MAX: i32 = i32::MAX;\n \n         let a = i32x4(1, 2, 3, 4);\n         let b = i32x4(2, 4, 6, 8);"}, {"sha": "a323bd9e82b4a16992f95885f6a3ffd023ab7cf5", "filename": "src/test/ui/simd/simd-intrinsic-generic-bitmask.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fff822fead6249671cbcb090b24bce58fab38de0/src%2Ftest%2Fui%2Fsimd%2Fsimd-intrinsic-generic-bitmask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff822fead6249671cbcb090b24bce58fab38de0/src%2Ftest%2Fui%2Fsimd%2Fsimd-intrinsic-generic-bitmask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsimd%2Fsimd-intrinsic-generic-bitmask.rs?ref=fff822fead6249671cbcb090b24bce58fab38de0", "patch": "@@ -39,7 +39,7 @@ fn main() {\n     let e = 0b_1101;\n \n     // Check usize / isize\n-    let msize: Tx4<usize> = Tx4(usize::max_value(), 0, usize::max_value(), usize::max_value());\n+    let msize: Tx4<usize> = Tx4(usize::MAX, 0, usize::MAX, usize::MAX);\n \n     unsafe {\n         let r: u8 = simd_bitmask(z);"}, {"sha": "8b5afeac0bc2dd75fc732e9e6f20b8cb54e63369", "filename": "src/test/ui/simd/simd-intrinsic-generic-reduction.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fff822fead6249671cbcb090b24bce58fab38de0/src%2Ftest%2Fui%2Fsimd%2Fsimd-intrinsic-generic-reduction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff822fead6249671cbcb090b24bce58fab38de0/src%2Ftest%2Fui%2Fsimd%2Fsimd-intrinsic-generic-reduction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsimd%2Fsimd-intrinsic-generic-reduction.rs?ref=fff822fead6249671cbcb090b24bce58fab38de0", "patch": "@@ -100,7 +100,7 @@ fn main() {\n         let r: u32 = simd_reduce_max(x);\n         assert_eq!(r, 4_u32);\n \n-        let t = u32::max_value();\n+        let t = u32::MAX;\n         let x = u32x4(t, t, t, t);\n         let r: u32 = simd_reduce_and(x);\n         assert_eq!(r, t);"}, {"sha": "22c5acca064e9242b4f7c1f962ccd25044ba9d08", "filename": "src/tools/clippy/clippy_lints/src/consts.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fff822fead6249671cbcb090b24bce58fab38de0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff822fead6249671cbcb090b24bce58fab38de0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fconsts.rs?ref=fff822fead6249671cbcb090b24bce58fab38de0", "patch": "@@ -254,11 +254,11 @@ impl<'c, 'cc> ConstEvalLateContext<'c, 'cc> {\n                     if let [\"core\", \"num\", int_impl, \"max_value\"] = *def_path;\n                     then {\n                        let value = match int_impl {\n-                           \"<impl i8>\" => i8::max_value() as u128,\n-                           \"<impl i16>\" => i16::max_value() as u128,\n-                           \"<impl i32>\" => i32::max_value() as u128,\n-                           \"<impl i64>\" => i64::max_value() as u128,\n-                           \"<impl i128>\" => i128::max_value() as u128,\n+                           \"<impl i8>\" => i8::MAX as u128,\n+                           \"<impl i16>\" => i16::MAX as u128,\n+                           \"<impl i32>\" => i32::MAX as u128,\n+                           \"<impl i64>\" => i64::MAX as u128,\n+                           \"<impl i128>\" => i128::MAX as u128,\n                            _ => return None,\n                        };\n                        Some(Constant::Int(value))"}, {"sha": "12b62f5cf97899792eada3b8f46295924ce9a24f", "filename": "src/tools/clippy/clippy_lints/src/enum_clike.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fff822fead6249671cbcb090b24bce58fab38de0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fenum_clike.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff822fead6249671cbcb090b24bce58fab38de0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fenum_clike.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fenum_clike.rs?ref=fff822fead6249671cbcb090b24bce58fab38de0", "patch": "@@ -65,7 +65,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnportableVariant {\n                                     continue;\n                                 }\n                             },\n-                            ty::Uint(UintTy::Usize) if val > u128::from(u32::max_value()) => {},\n+                            ty::Uint(UintTy::Usize) if val > u128::from(u32::MAX) => {},\n                             _ => continue,\n                         }\n                         span_lint("}, {"sha": "a9d8c66f26189421d428bc6baeb8f6b4c4d5c898", "filename": "src/tools/clippy/clippy_lints/src/types.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/fff822fead6249671cbcb090b24bce58fab38de0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff822fead6249671cbcb090b24bce58fab38de0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes.rs?ref=fff822fead6249671cbcb090b24bce58fab38de0", "patch": "@@ -1946,18 +1946,18 @@ fn detect_extreme_expr<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_\n     let which = match (&ty.kind, cv) {\n         (&ty::Bool, Constant::Bool(false)) | (&ty::Uint(_), Constant::Int(0)) => Minimum,\n         (&ty::Int(ity), Constant::Int(i))\n-            if i == unsext(cx.tcx, i128::min_value() >> (128 - int_bits(cx.tcx, ity)), ity) =>\n+            if i == unsext(cx.tcx, i128::MIN >> (128 - int_bits(cx.tcx, ity)), ity) =>\n         {\n             Minimum\n         },\n \n         (&ty::Bool, Constant::Bool(true)) => Maximum,\n         (&ty::Int(ity), Constant::Int(i))\n-            if i == unsext(cx.tcx, i128::max_value() >> (128 - int_bits(cx.tcx, ity)), ity) =>\n+            if i == unsext(cx.tcx, i128::MAX >> (128 - int_bits(cx.tcx, ity)), ity) =>\n         {\n             Maximum\n         },\n-        (&ty::Uint(uty), Constant::Int(i)) if clip(cx.tcx, u128::max_value(), uty) == i => Maximum,\n+        (&ty::Uint(uty), Constant::Int(i)) if clip(cx.tcx, u128::MAX, uty) == i => Maximum,\n \n         _ => return None,\n     };\n@@ -2039,7 +2039,7 @@ impl FullInt {\n     fn cmp_s_u(s: i128, u: u128) -> Ordering {\n         if s < 0 {\n             Ordering::Less\n-        } else if u > (i128::max_value() as u128) {\n+        } else if u > (i128::MAX as u128) {\n             Ordering::Greater\n         } else {\n             (s as u128).cmp(&u)\n@@ -2084,48 +2084,48 @@ fn numeric_cast_precast_bounds<'a>(cx: &LateContext<'_, '_>, expr: &'a Expr<'_>)\n         match pre_cast_ty.kind {\n             ty::Int(int_ty) => Some(match int_ty {\n                 IntTy::I8 => (\n-                    FullInt::S(i128::from(i8::min_value())),\n-                    FullInt::S(i128::from(i8::max_value())),\n+                    FullInt::S(i128::from(i8::MIN)),\n+                    FullInt::S(i128::from(i8::MAX)),\n                 ),\n                 IntTy::I16 => (\n-                    FullInt::S(i128::from(i16::min_value())),\n-                    FullInt::S(i128::from(i16::max_value())),\n+                    FullInt::S(i128::from(i16::MIN)),\n+                    FullInt::S(i128::from(i16::MAX)),\n                 ),\n                 IntTy::I32 => (\n-                    FullInt::S(i128::from(i32::min_value())),\n-                    FullInt::S(i128::from(i32::max_value())),\n+                    FullInt::S(i128::from(i32::MIN)),\n+                    FullInt::S(i128::from(i32::MAX)),\n                 ),\n                 IntTy::I64 => (\n-                    FullInt::S(i128::from(i64::min_value())),\n-                    FullInt::S(i128::from(i64::max_value())),\n+                    FullInt::S(i128::from(i64::MIN)),\n+                    FullInt::S(i128::from(i64::MAX)),\n                 ),\n-                IntTy::I128 => (FullInt::S(i128::min_value()), FullInt::S(i128::max_value())),\n+                IntTy::I128 => (FullInt::S(i128::MIN), FullInt::S(i128::MAX)),\n                 IntTy::Isize => (\n-                    FullInt::S(isize::min_value() as i128),\n-                    FullInt::S(isize::max_value() as i128),\n+                    FullInt::S(isize::MIN as i128),\n+                    FullInt::S(isize::MAX as i128),\n                 ),\n             }),\n             ty::Uint(uint_ty) => Some(match uint_ty {\n                 UintTy::U8 => (\n-                    FullInt::U(u128::from(u8::min_value())),\n-                    FullInt::U(u128::from(u8::max_value())),\n+                    FullInt::U(u128::from(u8::MIN)),\n+                    FullInt::U(u128::from(u8::MAX)),\n                 ),\n                 UintTy::U16 => (\n-                    FullInt::U(u128::from(u16::min_value())),\n-                    FullInt::U(u128::from(u16::max_value())),\n+                    FullInt::U(u128::from(u16::MIN)),\n+                    FullInt::U(u128::from(u16::MAX)),\n                 ),\n                 UintTy::U32 => (\n-                    FullInt::U(u128::from(u32::min_value())),\n-                    FullInt::U(u128::from(u32::max_value())),\n+                    FullInt::U(u128::from(u32::MIN)),\n+                    FullInt::U(u128::from(u32::MAX)),\n                 ),\n                 UintTy::U64 => (\n-                    FullInt::U(u128::from(u64::min_value())),\n-                    FullInt::U(u128::from(u64::max_value())),\n+                    FullInt::U(u128::from(u64::MIN)),\n+                    FullInt::U(u128::from(u64::MAX)),\n                 ),\n-                UintTy::U128 => (FullInt::U(u128::min_value()), FullInt::U(u128::max_value())),\n+                UintTy::U128 => (FullInt::U(u128::MIN), FullInt::U(u128::MAX)),\n                 UintTy::Usize => (\n-                    FullInt::U(usize::min_value() as u128),\n-                    FullInt::U(usize::max_value() as u128),\n+                    FullInt::U(usize::MIN as u128),\n+                    FullInt::U(usize::MAX as u128),\n                 ),\n             }),\n             _ => None,"}, {"sha": "8ee0969b0f0761b16371eb485570ac83ad3abe5d", "filename": "src/tools/clippy/tests/ui/cast.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fff822fead6249671cbcb090b24bce58fab38de0/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff822fead6249671cbcb090b24bce58fab38de0/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcast.rs?ref=fff822fead6249671cbcb090b24bce58fab38de0", "patch": "@@ -37,11 +37,11 @@ fn main() {\n     1isize as usize;\n     -1isize as usize;\n     0i8 as u8;\n-    i8::max_value() as u8;\n-    i16::max_value() as u16;\n-    i32::max_value() as u32;\n-    i64::max_value() as u64;\n-    i128::max_value() as u128;\n+    i8::MAX as u8;\n+    i16::MAX as u16;\n+    i32::MAX as u32;\n+    i64::MAX as u64;\n+    i128::MAX as u128;\n \n     (-1i8).abs() as u8;\n     (-1i16).abs() as u16;"}, {"sha": "2f32a7b1578219a2a5c951b9099994a22681bed5", "filename": "src/tools/clippy/tests/ui/implicit_saturating_sub.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/fff822fead6249671cbcb090b24bce58fab38de0/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fimplicit_saturating_sub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff822fead6249671cbcb090b24bce58fab38de0/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fimplicit_saturating_sub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fimplicit_saturating_sub.rs?ref=fff822fead6249671cbcb090b24bce58fab38de0", "patch": "@@ -110,7 +110,7 @@ fn main() {\n     }\n \n     // Lint\n-    if i_8 > i8::min_value() {\n+    if i_8 > i8::MIN {\n         i_8 -= 1;\n     }\n \n@@ -120,7 +120,7 @@ fn main() {\n     }\n \n     // Lint\n-    if i_8 != i8::min_value() {\n+    if i_8 != i8::MIN {\n         i_8 -= 1;\n     }\n \n@@ -135,7 +135,7 @@ fn main() {\n     }\n \n     // Lint\n-    if i_16 > i16::min_value() {\n+    if i_16 > i16::MIN {\n         i_16 -= 1;\n     }\n \n@@ -145,7 +145,7 @@ fn main() {\n     }\n \n     // Lint\n-    if i_16 != i16::min_value() {\n+    if i_16 != i16::MIN {\n         i_16 -= 1;\n     }\n \n@@ -160,7 +160,7 @@ fn main() {\n     }\n \n     // Lint\n-    if i_32 > i32::min_value() {\n+    if i_32 > i32::MIN {\n         i_32 -= 1;\n     }\n \n@@ -170,7 +170,7 @@ fn main() {\n     }\n \n     // Lint\n-    if i_32 != i32::min_value() {\n+    if i_32 != i32::MIN {\n         i_32 -= 1;\n     }\n \n@@ -180,7 +180,7 @@ fn main() {\n     let mut i_64: i64 = endi_64 - starti_64;\n \n     // Lint\n-    if i64::min_value() < i_64 {\n+    if i64::MIN < i_64 {\n         i_64 -= 1;\n     }\n "}, {"sha": "2eb2023b3b9ef44bbdfa0c0c7f23169f6b0de117", "filename": "src/tools/clippy/tests/ui/implicit_saturating_sub.stderr", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/fff822fead6249671cbcb090b24bce58fab38de0/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fimplicit_saturating_sub.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fff822fead6249671cbcb090b24bce58fab38de0/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fimplicit_saturating_sub.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fimplicit_saturating_sub.stderr?ref=fff822fead6249671cbcb090b24bce58fab38de0", "patch": "@@ -75,7 +75,7 @@ LL | |     }\n error: Implicitly performing saturating subtraction\n   --> $DIR/implicit_saturating_sub.rs:113:5\n    |\n-LL | /     if i_8 > i8::min_value() {\n+LL | /     if i_8 > i8::MIN {\n LL | |         i_8 -= 1;\n LL | |     }\n    | |_____^ help: try: `i_8 = i_8.saturating_sub(1);`\n@@ -91,7 +91,7 @@ LL | |     }\n error: Implicitly performing saturating subtraction\n   --> $DIR/implicit_saturating_sub.rs:123:5\n    |\n-LL | /     if i_8 != i8::min_value() {\n+LL | /     if i_8 != i8::MIN {\n LL | |         i_8 -= 1;\n LL | |     }\n    | |_____^ help: try: `i_8 = i_8.saturating_sub(1);`\n@@ -107,7 +107,7 @@ LL | |     }\n error: Implicitly performing saturating subtraction\n   --> $DIR/implicit_saturating_sub.rs:138:5\n    |\n-LL | /     if i_16 > i16::min_value() {\n+LL | /     if i_16 > i16::MIN {\n LL | |         i_16 -= 1;\n LL | |     }\n    | |_____^ help: try: `i_16 = i_16.saturating_sub(1);`\n@@ -123,7 +123,7 @@ LL | |     }\n error: Implicitly performing saturating subtraction\n   --> $DIR/implicit_saturating_sub.rs:148:5\n    |\n-LL | /     if i_16 != i16::min_value() {\n+LL | /     if i_16 != i16::MIN {\n LL | |         i_16 -= 1;\n LL | |     }\n    | |_____^ help: try: `i_16 = i_16.saturating_sub(1);`\n@@ -139,7 +139,7 @@ LL | |     }\n error: Implicitly performing saturating subtraction\n   --> $DIR/implicit_saturating_sub.rs:163:5\n    |\n-LL | /     if i_32 > i32::min_value() {\n+LL | /     if i_32 > i32::MIN {\n LL | |         i_32 -= 1;\n LL | |     }\n    | |_____^ help: try: `i_32 = i_32.saturating_sub(1);`\n@@ -155,15 +155,15 @@ LL | |     }\n error: Implicitly performing saturating subtraction\n   --> $DIR/implicit_saturating_sub.rs:173:5\n    |\n-LL | /     if i_32 != i32::min_value() {\n+LL | /     if i_32 != i32::MIN {\n LL | |         i_32 -= 1;\n LL | |     }\n    | |_____^ help: try: `i_32 = i_32.saturating_sub(1);`\n \n error: Implicitly performing saturating subtraction\n   --> $DIR/implicit_saturating_sub.rs:183:5\n    |\n-LL | /     if i64::min_value() < i_64 {\n+LL | /     if i64::MIN < i_64 {\n LL | |         i_64 -= 1;\n LL | |     }\n    | |_____^ help: try: `i_64 = i_64.saturating_sub(1);`"}, {"sha": "63cc29b670f6b3d4573e4dc017d19ef856babbad", "filename": "src/tools/unicode-table-generator/src/raw_emitter.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fff822fead6249671cbcb090b24bce58fab38de0/src%2Ftools%2Funicode-table-generator%2Fsrc%2Fraw_emitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff822fead6249671cbcb090b24bce58fab38de0/src%2Ftools%2Funicode-table-generator%2Fsrc%2Fraw_emitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Funicode-table-generator%2Fsrc%2Fraw_emitter.rs?ref=fff822fead6249671cbcb090b24bce58fab38de0", "patch": "@@ -43,7 +43,7 @@ impl RawEmitter {\n         words.push(0);\n         let unique_words =\n             words.iter().cloned().collect::<BTreeSet<_>>().into_iter().collect::<Vec<_>>();\n-        if unique_words.len() > u8::max_value() as usize {\n+        if unique_words.len() > u8::MAX as usize {\n             panic!(\"cannot pack {} into 8 bits\", unique_words.len());\n         }\n         // needed for the chunk mapping to work"}]}