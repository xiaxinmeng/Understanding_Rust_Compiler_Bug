{"sha": "39b306a53db513c754d5e8d60fc2691829209131", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM5YjMwNmE1M2RiNTEzYzc1NGQ1ZThkNjBmYzI2OTE4MjkyMDkxMzE=", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2021-03-06T10:17:56Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2021-03-30T16:10:05Z"}, "message": "Do not allocate in decoder.", "tree": {"sha": "3b1a49331c09cdc636cdc955594824a58d4aa7cf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3b1a49331c09cdc636cdc955594824a58d4aa7cf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/39b306a53db513c754d5e8d60fc2691829209131", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/39b306a53db513c754d5e8d60fc2691829209131", "html_url": "https://github.com/rust-lang/rust/commit/39b306a53db513c754d5e8d60fc2691829209131", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/39b306a53db513c754d5e8d60fc2691829209131/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6bfaf3a9cb7b601e3c4ed2e661ed213b8bc4d639", "url": "https://api.github.com/repos/rust-lang/rust/commits/6bfaf3a9cb7b601e3c4ed2e661ed213b8bc4d639", "html_url": "https://github.com/rust-lang/rust/commit/6bfaf3a9cb7b601e3c4ed2e661ed213b8bc4d639"}], "stats": {"total": 58, "additions": 34, "deletions": 24}, "files": [{"sha": "3067da9436d8623a8a88d9ca723e806a35e5fad0", "filename": "compiler/rustc_query_system/src/dep_graph/serialized.rs", "status": "modified", "additions": 34, "deletions": 24, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/39b306a53db513c754d5e8d60fc2691829209131/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fserialized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39b306a53db513c754d5e8d60fc2691829209131/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fserialized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fserialized.rs?ref=39b306a53db513c754d5e8d60fc2691829209131", "patch": "@@ -5,9 +5,9 @@ use super::{DepKind, DepNode, DepNodeIndex};\n use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sync::{AtomicU32, Lock, Lrc, Ordering};\n-use rustc_index::vec::{Idx, IndexVec};\n+use rustc_index::vec::IndexVec;\n use rustc_serialize::opaque::{self, FileEncodeResult, FileEncoder, IntEncodedWithFixedSize};\n-use rustc_serialize::{Decodable, Encodable};\n+use rustc_serialize::{Decodable, Decoder, Encodable};\n use smallvec::SmallVec;\n use std::convert::TryInto;\n \n@@ -85,31 +85,41 @@ impl<'a, K: DepKind + Decodable<opaque::Decoder<'a>>> Decodable<opaque::Decoder<\n         let mut edge_list_data = Vec::with_capacity(edge_count);\n \n         for _index in 0..node_count {\n-            let node = NodeInfo::<K, SerializedDepNodeIndex>::decode(d)?;\n-            debug!(?_index, ?node);\n-\n-            let _i: SerializedDepNodeIndex = nodes.push(node.node);\n-            debug_assert_eq!(_i.index(), _index);\n-            let _i: SerializedDepNodeIndex = fingerprints.push(node.fingerprint);\n-            debug_assert_eq!(_i.index(), _index);\n-\n-            let start = edge_list_data.len().try_into().unwrap();\n-            edge_list_data.extend(node.edges.into_iter());\n-            let end = edge_list_data.len().try_into().unwrap();\n-\n-            let _i: SerializedDepNodeIndex = edge_list_indices.push((start, end));\n-            debug_assert_eq!(_i.index(), _index);\n+            d.read_struct(\"NodeInfo\", 3, |d| {\n+                let dep_node: DepNode<K> = d.read_struct_field(\"node\", 0, Decodable::decode)?;\n+                let _i: SerializedDepNodeIndex = nodes.push(dep_node);\n+                debug_assert_eq!(_i.index(), _index);\n+\n+                let fingerprint: Fingerprint =\n+                    d.read_struct_field(\"fingerprint\", 1, Decodable::decode)?;\n+                let _i: SerializedDepNodeIndex = fingerprints.push(fingerprint);\n+                debug_assert_eq!(_i.index(), _index);\n+\n+                d.read_struct_field(\"edges\", 2, |d| {\n+                    d.read_seq(|d, len| {\n+                        let start = edge_list_data.len().try_into().unwrap();\n+                        for e in 0..len {\n+                            let edge = d.read_seq_elt(e, Decodable::decode)?;\n+                            edge_list_data.push(edge);\n+                        }\n+                        let end = edge_list_data.len().try_into().unwrap();\n+                        let _i: SerializedDepNodeIndex = edge_list_indices.push((start, end));\n+                        debug_assert_eq!(_i.index(), _index);\n+                        Ok(())\n+                    })\n+                })\n+            })?;\n         }\n \n         Ok(SerializedDepGraph { nodes, fingerprints, edge_list_indices, edge_list_data })\n     }\n }\n \n #[derive(Debug, Encodable, Decodable)]\n-pub struct NodeInfo<K: DepKind, I: Idx> {\n+pub struct NodeInfo<K: DepKind> {\n     node: DepNode<K>,\n     fingerprint: Fingerprint,\n-    edges: SmallVec<[I; 8]>,\n+    edges: SmallVec<[DepNodeIndex; 8]>,\n }\n \n struct Stat<K: DepKind> {\n@@ -128,7 +138,7 @@ struct Stats<K: DepKind> {\n fn encode_node<K: DepKind>(\n     encoder: &mut FileEncoder,\n     _index: DepNodeIndex,\n-    node: &NodeInfo<K, DepNodeIndex>,\n+    node: &NodeInfo<K>,\n     _record_graph: &Option<Lrc<Lock<DepGraphQuery<K>>>>,\n     record_stats: &Option<Lrc<Lock<Stats<K>>>>,\n ) -> FileEncodeResult {\n@@ -181,7 +191,7 @@ pub struct GraphEncoder<K: DepKind> {\n \n #[cfg(parallel_compiler)]\n pub struct GraphEncoder<K: DepKind> {\n-    send: WorkerLocal<mpsc::Sender<(DepNodeIndex, NodeInfo<K, DepNodeIndex>)>>,\n+    send: WorkerLocal<mpsc::Sender<(DepNodeIndex, NodeInfo<K>)>>,\n     thread: thread::JoinHandle<FileEncodeResult>,\n     counter: AtomicU32,\n     record_graph: Option<Lrc<Lock<DepGraphQuery<K>>>>,\n@@ -350,8 +360,8 @@ impl<K: DepKind + Encodable<FileEncoder>> GraphEncoder<K> {\n #[instrument(skip(encoder, recv, process))]\n fn encode_graph<K: DepKind + Encodable<FileEncoder>>(\n     mut encoder: FileEncoder,\n-    recv: mpsc::Receiver<(DepNodeIndex, NodeInfo<K, DepNodeIndex>)>,\n-    process: impl Fn(&mut FileEncoder, DepNodeIndex, &NodeInfo<K, DepNodeIndex>) -> FileEncodeResult,\n+    recv: mpsc::Receiver<(DepNodeIndex, NodeInfo<K>)>,\n+    process: impl Fn(&mut FileEncoder, DepNodeIndex, &NodeInfo<K>) -> FileEncodeResult,\n ) -> FileEncodeResult {\n     let mut edge_count: usize = 0;\n     let node_count: usize = ordered_recv(recv, |index, node| {\n@@ -366,8 +376,8 @@ fn encode_graph<K: DepKind + Encodable<FileEncoder>>(\n /// the messages may not arrive in order. This function sorts them as they come.\n #[cfg(parallel_compiler)]\n fn ordered_recv<K: DepKind + Encodable<opaque::FileEncoder>>(\n-    recv: mpsc::Receiver<(DepNodeIndex, NodeInfo<K, DepNodeIndex>)>,\n-    mut f: impl FnMut(DepNodeIndex, &NodeInfo<K, DepNodeIndex>) -> FileEncodeResult,\n+    recv: mpsc::Receiver<(DepNodeIndex, NodeInfo<K>)>,\n+    mut f: impl FnMut(DepNodeIndex, &NodeInfo<K>) -> FileEncodeResult,\n ) -> Result<usize, std::io::Error> {\n     let mut pending = Vec::<(DepNodeIndex, _)>::new();\n     let mut expected = DepNodeIndex::new(0);"}]}