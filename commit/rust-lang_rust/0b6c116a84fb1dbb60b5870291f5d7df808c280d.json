{"sha": "0b6c116a84fb1dbb60b5870291f5d7df808c280d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBiNmMxMTZhODRmYjFkYmI2MGI1ODcwMjkxZjVkN2RmODA4YzI4MGQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-01-12T02:28:48Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-01-12T02:28:48Z"}, "message": "Auto merge of #68142 - Centril:rollup-dl232e9, r=Centril\n\nRollup of 6 pull requests\n\nSuccessful merges:\n\n - #67494 (Constify more of alloc::Layout)\n - #67867 (Correctly check for opaque types in `assoc_ty_def`)\n - #67948 (Galloping search for binary_search_util)\n - #68045 (Move more of `rustc::lint` into `rustc_lint`)\n - #68089 (Unstabilize `Vec::remove_item`)\n - #68108 (Add suggestions when encountering chained comparisons)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "22efe869664863f74b929dcb29f0b28ad2ce25e6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/22efe869664863f74b929dcb29f0b28ad2ce25e6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0b6c116a84fb1dbb60b5870291f5d7df808c280d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0b6c116a84fb1dbb60b5870291f5d7df808c280d", "html_url": "https://github.com/rust-lang/rust/commit/0b6c116a84fb1dbb60b5870291f5d7df808c280d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0b6c116a84fb1dbb60b5870291f5d7df808c280d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f363745872f9b45cfec575f3c2cac42f0c242c03", "url": "https://api.github.com/repos/rust-lang/rust/commits/f363745872f9b45cfec575f3c2cac42f0c242c03", "html_url": "https://github.com/rust-lang/rust/commit/f363745872f9b45cfec575f3c2cac42f0c242c03"}, {"sha": "82c19b4388dc671dd4c1224b8577a5e23ff315e4", "url": "https://api.github.com/repos/rust-lang/rust/commits/82c19b4388dc671dd4c1224b8577a5e23ff315e4", "html_url": "https://github.com/rust-lang/rust/commit/82c19b4388dc671dd4c1224b8577a5e23ff315e4"}], "stats": {"total": 2496, "additions": 1404, "deletions": 1092}, "files": [{"sha": "0008a4a361531928aadb1ae4caeccf28daa1af8f", "filename": "Cargo.lock", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0b6c116a84fb1dbb60b5870291f5d7df808c280d/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/0b6c116a84fb1dbb60b5870291f5d7df808c280d/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=0b6c116a84fb1dbb60b5870291f5d7df808c280d", "patch": "@@ -3663,6 +3663,7 @@ dependencies = [\n  \"log\",\n  \"rustc\",\n  \"rustc_data_structures\",\n+ \"rustc_error_codes\",\n  \"rustc_errors\",\n  \"rustc_feature\",\n  \"rustc_hir\",\n@@ -3788,6 +3789,7 @@ dependencies = [\n  \"rustc_error_codes\",\n  \"rustc_errors\",\n  \"rustc_hir\",\n+ \"rustc_lint\",\n  \"rustc_metadata\",\n  \"rustc_span\",\n  \"syntax\","}, {"sha": "c1ae67a1a339f9ae46c5c0e67abadf1fc3bdaef5", "filename": "src/liballoc/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0b6c116a84fb1dbb60b5870291f5d7df808c280d/src%2Fliballoc%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b6c116a84fb1dbb60b5870291f5d7df808c280d/src%2Fliballoc%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Flib.rs?ref=0b6c116a84fb1dbb60b5870291f5d7df808c280d", "patch": "@@ -11,6 +11,7 @@\n #![feature(associated_type_bounds)]\n #![feature(binary_heap_into_iter_sorted)]\n #![feature(binary_heap_drain_sorted)]\n+#![feature(vec_remove_item)]\n \n use std::collections::hash_map::DefaultHasher;\n use std::hash::{Hash, Hasher};"}, {"sha": "e9cbf627846b5a3d4b624e3b9723b305c21f1e08", "filename": "src/liballoc/vec.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0b6c116a84fb1dbb60b5870291f5d7df808c280d/src%2Fliballoc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b6c116a84fb1dbb60b5870291f5d7df808c280d/src%2Fliballoc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fvec.rs?ref=0b6c116a84fb1dbb60b5870291f5d7df808c280d", "patch": "@@ -1696,13 +1696,14 @@ impl<T> Vec<T> {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(vec_remove_item)]\n     /// let mut vec = vec![1, 2, 3, 1];\n     ///\n     /// vec.remove_item(&1);\n     ///\n     /// assert_eq!(vec, vec![2, 3, 1]);\n     /// ```\n-    #[stable(feature = \"vec_remove_item\", since = \"1.42.0\")]\n+    #[unstable(feature = \"vec_remove_item\", reason = \"recently added\", issue = \"40062\")]\n     pub fn remove_item<V>(&mut self, item: &V) -> Option<T>\n     where\n         T: PartialEq<V>,"}, {"sha": "4354e1c7b5f695c1455f5e24f4bb7d165d5758b4", "filename": "src/libcore/alloc.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0b6c116a84fb1dbb60b5870291f5d7df808c280d/src%2Flibcore%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b6c116a84fb1dbb60b5870291f5d7df808c280d/src%2Flibcore%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Falloc.rs?ref=0b6c116a84fb1dbb60b5870291f5d7df808c280d", "patch": "@@ -64,8 +64,9 @@ impl Layout {\n     ///    must not overflow (i.e., the rounded value must be less than\n     ///    `usize::MAX`).\n     #[stable(feature = \"alloc_layout\", since = \"1.28.0\")]\n+    #[rustc_const_unstable(feature = \"const_alloc_layout\", issue = \"67521\")]\n     #[inline]\n-    pub fn from_size_align(size: usize, align: usize) -> Result<Self, LayoutErr> {\n+    pub const fn from_size_align(size: usize, align: usize) -> Result<Self, LayoutErr> {\n         if !align.is_power_of_two() {\n             return Err(LayoutErr { private: () });\n         }\n@@ -106,15 +107,17 @@ impl Layout {\n \n     /// The minimum size in bytes for a memory block of this layout.\n     #[stable(feature = \"alloc_layout\", since = \"1.28.0\")]\n+    #[rustc_const_unstable(feature = \"const_alloc_layout\", issue = \"67521\")]\n     #[inline]\n-    pub fn size(&self) -> usize {\n+    pub const fn size(&self) -> usize {\n         self.size_\n     }\n \n     /// The minimum byte alignment for a memory block of this layout.\n     #[stable(feature = \"alloc_layout\", since = \"1.28.0\")]\n+    #[rustc_const_unstable(feature = \"const_alloc_layout\", issue = \"67521\")]\n     #[inline]\n-    pub fn align(&self) -> usize {\n+    pub const fn align(&self) -> usize {\n         self.align_.get()\n     }\n \n@@ -181,8 +184,9 @@ impl Layout {\n     /// address for the whole allocated block of memory. One way to\n     /// satisfy this constraint is to ensure `align <= self.align()`.\n     #[unstable(feature = \"alloc_layout_extra\", issue = \"55724\")]\n+    #[rustc_const_unstable(feature = \"const_alloc_layout\", issue = \"67521\")]\n     #[inline]\n-    pub fn padding_needed_for(&self, align: usize) -> usize {\n+    pub const fn padding_needed_for(&self, align: usize) -> usize {\n         let len = self.size();\n \n         // Rounded up value is:"}, {"sha": "95ffe4f438f5f608d69ea683989a974000846b04", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0b6c116a84fb1dbb60b5870291f5d7df808c280d/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b6c116a84fb1dbb60b5870291f5d7df808c280d/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=0b6c116a84fb1dbb60b5870291f5d7df808c280d", "patch": "@@ -70,6 +70,7 @@\n #![feature(bound_cloned)]\n #![feature(cfg_target_has_atomic)]\n #![feature(concat_idents)]\n+#![feature(const_alloc_layout)]\n #![feature(const_if_match)]\n #![feature(const_panic)]\n #![feature(const_fn_union)]"}, {"sha": "5a99e7965538b2ff243d6763fe42886715964e05", "filename": "src/librustc/hir/check_attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0b6c116a84fb1dbb60b5870291f5d7df808c280d/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b6c116a84fb1dbb60b5870291f5d7df808c280d/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fcheck_attr.rs?ref=0b6c116a84fb1dbb60b5870291f5d7df808c280d", "patch": "@@ -5,7 +5,6 @@\n //! item.\n \n use crate::hir::map::Map;\n-use crate::lint::builtin::UNUSED_ATTRIBUTES;\n use crate::ty::query::Providers;\n use crate::ty::TyCtxt;\n \n@@ -16,6 +15,7 @@ use rustc_hir::def_id::DefId;\n use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n use rustc_hir::DUMMY_HIR_ID;\n use rustc_hir::{self, HirId, Item, ItemKind, TraitItem, TraitItemKind};\n+use rustc_session::lint::builtin::UNUSED_ATTRIBUTES;\n use rustc_span::symbol::sym;\n use rustc_span::Span;\n use syntax::ast::Attribute;"}, {"sha": "2164a0b44bdcb9381df3d8395cfea166a2c94943", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0b6c116a84fb1dbb60b5870291f5d7df808c280d/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b6c116a84fb1dbb60b5870291f5d7df808c280d/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=0b6c116a84fb1dbb60b5870291f5d7df808c280d", "patch": "@@ -49,6 +49,7 @@\n #![feature(thread_local)]\n #![feature(trace_macros)]\n #![feature(trusted_len)]\n+#![feature(vec_remove_item)]\n #![feature(stmt_expr_attributes)]\n #![feature(integer_atomics)]\n #![feature(test)]\n@@ -71,8 +72,6 @@ extern crate rustc_data_structures;\n #[macro_use]\n extern crate log;\n #[macro_use]\n-extern crate syntax;\n-#[macro_use]\n extern crate smallvec;\n \n #[cfg(test)]"}, {"sha": "2ed6cd5283b10c3ab3e9dc96412d63ecb0031eae", "filename": "src/librustc/lint.rs", "status": "added", "additions": 369, "deletions": 0, "changes": 369, "blob_url": "https://github.com/rust-lang/rust/blob/0b6c116a84fb1dbb60b5870291f5d7df808c280d/src%2Flibrustc%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b6c116a84fb1dbb60b5870291f5d7df808c280d/src%2Flibrustc%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint.rs?ref=0b6c116a84fb1dbb60b5870291f5d7df808c280d", "patch": "@@ -0,0 +1,369 @@\n+use std::cmp;\n+\n+use crate::ich::StableHashingContext;\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n+use rustc_errors::{pluralize, Applicability, DiagnosticBuilder, DiagnosticId};\n+use rustc_hir::HirId;\n+pub use rustc_session::lint::{builtin, Level, Lint, LintId, LintPass};\n+use rustc_session::{DiagnosticMessageId, Session};\n+use rustc_span::hygiene::MacroKind;\n+use rustc_span::source_map::{DesugaringKind, ExpnKind, MultiSpan};\n+use rustc_span::{Span, Symbol};\n+\n+/// How a lint level was set.\n+#[derive(Clone, Copy, PartialEq, Eq, HashStable)]\n+pub enum LintSource {\n+    /// Lint is at the default level as declared\n+    /// in rustc or a plugin.\n+    Default,\n+\n+    /// Lint level was set by an attribute.\n+    Node(Symbol, Span, Option<Symbol> /* RFC 2383 reason */),\n+\n+    /// Lint level was set by a command-line flag.\n+    CommandLine(Symbol),\n+}\n+\n+pub type LevelSource = (Level, LintSource);\n+\n+pub struct LintLevelSets {\n+    pub list: Vec<LintSet>,\n+    pub lint_cap: Level,\n+}\n+\n+pub enum LintSet {\n+    CommandLine {\n+        // -A,-W,-D flags, a `Symbol` for the flag itself and `Level` for which\n+        // flag.\n+        specs: FxHashMap<LintId, LevelSource>,\n+    },\n+\n+    Node {\n+        specs: FxHashMap<LintId, LevelSource>,\n+        parent: u32,\n+    },\n+}\n+\n+impl LintLevelSets {\n+    pub fn new() -> Self {\n+        LintLevelSets { list: Vec::new(), lint_cap: Level::Forbid }\n+    }\n+\n+    pub fn get_lint_level(\n+        &self,\n+        lint: &'static Lint,\n+        idx: u32,\n+        aux: Option<&FxHashMap<LintId, LevelSource>>,\n+        sess: &Session,\n+    ) -> LevelSource {\n+        let (level, mut src) = self.get_lint_id_level(LintId::of(lint), idx, aux);\n+\n+        // If `level` is none then we actually assume the default level for this\n+        // lint.\n+        let mut level = level.unwrap_or_else(|| lint.default_level(sess.edition()));\n+\n+        // If we're about to issue a warning, check at the last minute for any\n+        // directives against the warnings \"lint\". If, for example, there's an\n+        // `allow(warnings)` in scope then we want to respect that instead.\n+        if level == Level::Warn {\n+            let (warnings_level, warnings_src) =\n+                self.get_lint_id_level(LintId::of(builtin::WARNINGS), idx, aux);\n+            if let Some(configured_warning_level) = warnings_level {\n+                if configured_warning_level != Level::Warn {\n+                    level = configured_warning_level;\n+                    src = warnings_src;\n+                }\n+            }\n+        }\n+\n+        // Ensure that we never exceed the `--cap-lints` argument.\n+        level = cmp::min(level, self.lint_cap);\n+\n+        if let Some(driver_level) = sess.driver_lint_caps.get(&LintId::of(lint)) {\n+            // Ensure that we never exceed driver level.\n+            level = cmp::min(*driver_level, level);\n+        }\n+\n+        return (level, src);\n+    }\n+\n+    pub fn get_lint_id_level(\n+        &self,\n+        id: LintId,\n+        mut idx: u32,\n+        aux: Option<&FxHashMap<LintId, LevelSource>>,\n+    ) -> (Option<Level>, LintSource) {\n+        if let Some(specs) = aux {\n+            if let Some(&(level, src)) = specs.get(&id) {\n+                return (Some(level), src);\n+            }\n+        }\n+        loop {\n+            match self.list[idx as usize] {\n+                LintSet::CommandLine { ref specs } => {\n+                    if let Some(&(level, src)) = specs.get(&id) {\n+                        return (Some(level), src);\n+                    }\n+                    return (None, LintSource::Default);\n+                }\n+                LintSet::Node { ref specs, parent } => {\n+                    if let Some(&(level, src)) = specs.get(&id) {\n+                        return (Some(level), src);\n+                    }\n+                    idx = parent;\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+pub struct LintLevelMap {\n+    pub sets: LintLevelSets,\n+    pub id_to_set: FxHashMap<HirId, u32>,\n+}\n+\n+impl LintLevelMap {\n+    /// If the `id` was previously registered with `register_id` when building\n+    /// this `LintLevelMap` this returns the corresponding lint level and source\n+    /// of the lint level for the lint provided.\n+    ///\n+    /// If the `id` was not previously registered, returns `None`. If `None` is\n+    /// returned then the parent of `id` should be acquired and this function\n+    /// should be called again.\n+    pub fn level_and_source(\n+        &self,\n+        lint: &'static Lint,\n+        id: HirId,\n+        session: &Session,\n+    ) -> Option<LevelSource> {\n+        self.id_to_set.get(&id).map(|idx| self.sets.get_lint_level(lint, *idx, None, session))\n+    }\n+}\n+\n+impl<'a> HashStable<StableHashingContext<'a>> for LintLevelMap {\n+    #[inline]\n+    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n+        let LintLevelMap { ref sets, ref id_to_set } = *self;\n+\n+        id_to_set.hash_stable(hcx, hasher);\n+\n+        let LintLevelSets { ref list, lint_cap } = *sets;\n+\n+        lint_cap.hash_stable(hcx, hasher);\n+\n+        hcx.while_hashing_spans(true, |hcx| {\n+            list.len().hash_stable(hcx, hasher);\n+\n+            // We are working under the assumption here that the list of\n+            // lint-sets is built in a deterministic order.\n+            for lint_set in list {\n+                ::std::mem::discriminant(lint_set).hash_stable(hcx, hasher);\n+\n+                match *lint_set {\n+                    LintSet::CommandLine { ref specs } => {\n+                        specs.hash_stable(hcx, hasher);\n+                    }\n+                    LintSet::Node { ref specs, parent } => {\n+                        specs.hash_stable(hcx, hasher);\n+                        parent.hash_stable(hcx, hasher);\n+                    }\n+                }\n+            }\n+        })\n+    }\n+}\n+\n+pub fn struct_lint_level<'a>(\n+    sess: &'a Session,\n+    lint: &'static Lint,\n+    level: Level,\n+    src: LintSource,\n+    span: Option<MultiSpan>,\n+    msg: &str,\n+) -> DiagnosticBuilder<'a> {\n+    let mut err = match (level, span) {\n+        (Level::Allow, _) => return sess.diagnostic().struct_dummy(),\n+        (Level::Warn, Some(span)) => sess.struct_span_warn(span, msg),\n+        (Level::Warn, None) => sess.struct_warn(msg),\n+        (Level::Deny, Some(span)) | (Level::Forbid, Some(span)) => sess.struct_span_err(span, msg),\n+        (Level::Deny, None) | (Level::Forbid, None) => sess.struct_err(msg),\n+    };\n+\n+    // Check for future incompatibility lints and issue a stronger warning.\n+    let lint_id = LintId::of(lint);\n+    let future_incompatible = lint.future_incompatible;\n+\n+    // If this code originates in a foreign macro, aka something that this crate\n+    // did not itself author, then it's likely that there's nothing this crate\n+    // can do about it. We probably want to skip the lint entirely.\n+    if err.span.primary_spans().iter().any(|s| in_external_macro(sess, *s)) {\n+        // Any suggestions made here are likely to be incorrect, so anything we\n+        // emit shouldn't be automatically fixed by rustfix.\n+        err.allow_suggestions(false);\n+\n+        // If this is a future incompatible lint it'll become a hard error, so\n+        // we have to emit *something*. Also allow lints to whitelist themselves\n+        // on a case-by-case basis for emission in a foreign macro.\n+        if future_incompatible.is_none() && !lint.report_in_external_macro {\n+            err.cancel();\n+            // Don't continue further, since we don't want to have\n+            // `diag_span_note_once` called for a diagnostic that isn't emitted.\n+            return err;\n+        }\n+    }\n+\n+    let name = lint.name_lower();\n+    match src {\n+        LintSource::Default => {\n+            sess.diag_note_once(\n+                &mut err,\n+                DiagnosticMessageId::from(lint),\n+                &format!(\"`#[{}({})]` on by default\", level.as_str(), name),\n+            );\n+        }\n+        LintSource::CommandLine(lint_flag_val) => {\n+            let flag = match level {\n+                Level::Warn => \"-W\",\n+                Level::Deny => \"-D\",\n+                Level::Forbid => \"-F\",\n+                Level::Allow => panic!(),\n+            };\n+            let hyphen_case_lint_name = name.replace(\"_\", \"-\");\n+            if lint_flag_val.as_str() == name {\n+                sess.diag_note_once(\n+                    &mut err,\n+                    DiagnosticMessageId::from(lint),\n+                    &format!(\n+                        \"requested on the command line with `{} {}`\",\n+                        flag, hyphen_case_lint_name\n+                    ),\n+                );\n+            } else {\n+                let hyphen_case_flag_val = lint_flag_val.as_str().replace(\"_\", \"-\");\n+                sess.diag_note_once(\n+                    &mut err,\n+                    DiagnosticMessageId::from(lint),\n+                    &format!(\n+                        \"`{} {}` implied by `{} {}`\",\n+                        flag, hyphen_case_lint_name, flag, hyphen_case_flag_val\n+                    ),\n+                );\n+            }\n+        }\n+        LintSource::Node(lint_attr_name, src, reason) => {\n+            if let Some(rationale) = reason {\n+                err.note(&rationale.as_str());\n+            }\n+            sess.diag_span_note_once(\n+                &mut err,\n+                DiagnosticMessageId::from(lint),\n+                src,\n+                \"lint level defined here\",\n+            );\n+            if lint_attr_name.as_str() != name {\n+                let level_str = level.as_str();\n+                sess.diag_note_once(\n+                    &mut err,\n+                    DiagnosticMessageId::from(lint),\n+                    &format!(\n+                        \"`#[{}({})]` implied by `#[{}({})]`\",\n+                        level_str, name, level_str, lint_attr_name\n+                    ),\n+                );\n+            }\n+        }\n+    }\n+\n+    err.code(DiagnosticId::Lint(name));\n+\n+    if let Some(future_incompatible) = future_incompatible {\n+        const STANDARD_MESSAGE: &str = \"this was previously accepted by the compiler but is being phased out; \\\n+             it will become a hard error\";\n+\n+        let explanation = if lint_id == LintId::of(builtin::UNSTABLE_NAME_COLLISIONS) {\n+            \"once this method is added to the standard library, \\\n+             the ambiguity may cause an error or change in behavior!\"\n+                .to_owned()\n+        } else if lint_id == LintId::of(builtin::MUTABLE_BORROW_RESERVATION_CONFLICT) {\n+            \"this borrowing pattern was not meant to be accepted, \\\n+             and may become a hard error in the future\"\n+                .to_owned()\n+        } else if let Some(edition) = future_incompatible.edition {\n+            format!(\"{} in the {} edition!\", STANDARD_MESSAGE, edition)\n+        } else {\n+            format!(\"{} in a future release!\", STANDARD_MESSAGE)\n+        };\n+        let citation = format!(\"for more information, see {}\", future_incompatible.reference);\n+        err.warn(&explanation);\n+        err.note(&citation);\n+    }\n+\n+    return err;\n+}\n+\n+/// Returns whether `span` originates in a foreign crate's external macro.\n+///\n+/// This is used to test whether a lint should not even begin to figure out whether it should\n+/// be reported on the current node.\n+pub fn in_external_macro(sess: &Session, span: Span) -> bool {\n+    let expn_data = span.ctxt().outer_expn_data();\n+    match expn_data.kind {\n+        ExpnKind::Root | ExpnKind::Desugaring(DesugaringKind::ForLoop) => false,\n+        ExpnKind::AstPass(_) | ExpnKind::Desugaring(_) => true, // well, it's \"external\"\n+        ExpnKind::Macro(MacroKind::Bang, _) => {\n+            if expn_data.def_site.is_dummy() {\n+                // Dummy span for the `def_site` means it's an external macro.\n+                return true;\n+            }\n+            match sess.source_map().span_to_snippet(expn_data.def_site) {\n+                Ok(code) => !code.starts_with(\"macro_rules\"),\n+                // No snippet means external macro or compiler-builtin expansion.\n+                Err(_) => true,\n+            }\n+        }\n+        ExpnKind::Macro(..) => true, // definitely a plugin\n+    }\n+}\n+\n+pub fn add_elided_lifetime_in_path_suggestion(\n+    sess: &Session,\n+    db: &mut DiagnosticBuilder<'_>,\n+    n: usize,\n+    path_span: Span,\n+    incl_angl_brckt: bool,\n+    insertion_span: Span,\n+    anon_lts: String,\n+) {\n+    let (replace_span, suggestion) = if incl_angl_brckt {\n+        (insertion_span, anon_lts)\n+    } else {\n+        // When possible, prefer a suggestion that replaces the whole\n+        // `Path<T>` expression with `Path<'_, T>`, rather than inserting `'_, `\n+        // at a point (which makes for an ugly/confusing label)\n+        if let Ok(snippet) = sess.source_map().span_to_snippet(path_span) {\n+            // But our spans can get out of whack due to macros; if the place we think\n+            // we want to insert `'_` isn't even within the path expression's span, we\n+            // should bail out of making any suggestion rather than panicking on a\n+            // subtract-with-overflow or string-slice-out-out-bounds (!)\n+            // FIXME: can we do better?\n+            if insertion_span.lo().0 < path_span.lo().0 {\n+                return;\n+            }\n+            let insertion_index = (insertion_span.lo().0 - path_span.lo().0) as usize;\n+            if insertion_index > snippet.len() {\n+                return;\n+            }\n+            let (before, after) = snippet.split_at(insertion_index);\n+            (path_span, format!(\"{}{}{}\", before, anon_lts, after))\n+        } else {\n+            (insertion_span, anon_lts)\n+        }\n+    };\n+    db.span_suggestion(\n+        replace_span,\n+        &format!(\"indicate the anonymous lifetime{}\", pluralize!(n)),\n+        suggestion,\n+        Applicability::MachineApplicable,\n+    );\n+}"}, {"sha": "e586ad1836c737926ad53c17fcb2422589709e10", "filename": "src/librustc/lint/levels.rs", "status": "removed", "additions": 0, "deletions": 550, "changes": 550, "blob_url": "https://github.com/rust-lang/rust/blob/f363745872f9b45cfec575f3c2cac42f0c242c03/src%2Flibrustc%2Flint%2Flevels.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f363745872f9b45cfec575f3c2cac42f0c242c03/src%2Flibrustc%2Flint%2Flevels.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Flevels.rs?ref=f363745872f9b45cfec575f3c2cac42f0c242c03", "patch": "@@ -1,550 +0,0 @@\n-use std::cmp;\n-\n-use crate::ich::StableHashingContext;\n-use crate::lint::builtin;\n-use crate::lint::context::{CheckLintNameResult, LintStore};\n-use crate::lint::{self, Level, Lint, LintId, LintSource};\n-use crate::session::Session;\n-use rustc_data_structures::fx::FxHashMap;\n-use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n-use rustc_errors::{struct_span_err, Applicability, DiagnosticBuilder};\n-use rustc_hir::HirId;\n-use rustc_span::source_map::MultiSpan;\n-use rustc_span::symbol::{sym, Symbol};\n-use syntax::ast;\n-use syntax::attr;\n-use syntax::print::pprust;\n-use syntax::sess::feature_err;\n-\n-use rustc_error_codes::*;\n-\n-pub struct LintLevelSets {\n-    list: Vec<LintSet>,\n-    lint_cap: Level,\n-}\n-\n-enum LintSet {\n-    CommandLine {\n-        // -A,-W,-D flags, a `Symbol` for the flag itself and `Level` for which\n-        // flag.\n-        specs: FxHashMap<LintId, (Level, LintSource)>,\n-    },\n-\n-    Node {\n-        specs: FxHashMap<LintId, (Level, LintSource)>,\n-        parent: u32,\n-    },\n-}\n-\n-impl LintLevelSets {\n-    pub fn new(sess: &Session, lint_store: &LintStore) -> LintLevelSets {\n-        let mut me = LintLevelSets { list: Vec::new(), lint_cap: Level::Forbid };\n-        me.process_command_line(sess, lint_store);\n-        return me;\n-    }\n-\n-    pub fn builder<'a>(\n-        sess: &'a Session,\n-        warn_about_weird_lints: bool,\n-        store: &LintStore,\n-    ) -> LintLevelsBuilder<'a> {\n-        LintLevelsBuilder::new(sess, warn_about_weird_lints, LintLevelSets::new(sess, store))\n-    }\n-\n-    fn process_command_line(&mut self, sess: &Session, store: &LintStore) {\n-        let mut specs = FxHashMap::default();\n-        self.lint_cap = sess.opts.lint_cap.unwrap_or(Level::Forbid);\n-\n-        for &(ref lint_name, level) in &sess.opts.lint_opts {\n-            store.check_lint_name_cmdline(sess, &lint_name, level);\n-\n-            // If the cap is less than this specified level, e.g., if we've got\n-            // `--cap-lints allow` but we've also got `-D foo` then we ignore\n-            // this specification as the lint cap will set it to allow anyway.\n-            let level = cmp::min(level, self.lint_cap);\n-\n-            let lint_flag_val = Symbol::intern(lint_name);\n-            let ids = match store.find_lints(&lint_name) {\n-                Ok(ids) => ids,\n-                Err(_) => continue, // errors handled in check_lint_name_cmdline above\n-            };\n-            for id in ids {\n-                let src = LintSource::CommandLine(lint_flag_val);\n-                specs.insert(id, (level, src));\n-            }\n-        }\n-\n-        self.list.push(LintSet::CommandLine { specs: specs });\n-    }\n-\n-    fn get_lint_level(\n-        &self,\n-        lint: &'static Lint,\n-        idx: u32,\n-        aux: Option<&FxHashMap<LintId, (Level, LintSource)>>,\n-        sess: &Session,\n-    ) -> (Level, LintSource) {\n-        let (level, mut src) = self.get_lint_id_level(LintId::of(lint), idx, aux);\n-\n-        // If `level` is none then we actually assume the default level for this\n-        // lint.\n-        let mut level = level.unwrap_or_else(|| lint.default_level(sess.edition()));\n-\n-        // If we're about to issue a warning, check at the last minute for any\n-        // directives against the warnings \"lint\". If, for example, there's an\n-        // `allow(warnings)` in scope then we want to respect that instead.\n-        if level == Level::Warn {\n-            let (warnings_level, warnings_src) =\n-                self.get_lint_id_level(LintId::of(lint::builtin::WARNINGS), idx, aux);\n-            if let Some(configured_warning_level) = warnings_level {\n-                if configured_warning_level != Level::Warn {\n-                    level = configured_warning_level;\n-                    src = warnings_src;\n-                }\n-            }\n-        }\n-\n-        // Ensure that we never exceed the `--cap-lints` argument.\n-        level = cmp::min(level, self.lint_cap);\n-\n-        if let Some(driver_level) = sess.driver_lint_caps.get(&LintId::of(lint)) {\n-            // Ensure that we never exceed driver level.\n-            level = cmp::min(*driver_level, level);\n-        }\n-\n-        return (level, src);\n-    }\n-\n-    fn get_lint_id_level(\n-        &self,\n-        id: LintId,\n-        mut idx: u32,\n-        aux: Option<&FxHashMap<LintId, (Level, LintSource)>>,\n-    ) -> (Option<Level>, LintSource) {\n-        if let Some(specs) = aux {\n-            if let Some(&(level, src)) = specs.get(&id) {\n-                return (Some(level), src);\n-            }\n-        }\n-        loop {\n-            match self.list[idx as usize] {\n-                LintSet::CommandLine { ref specs } => {\n-                    if let Some(&(level, src)) = specs.get(&id) {\n-                        return (Some(level), src);\n-                    }\n-                    return (None, LintSource::Default);\n-                }\n-                LintSet::Node { ref specs, parent } => {\n-                    if let Some(&(level, src)) = specs.get(&id) {\n-                        return (Some(level), src);\n-                    }\n-                    idx = parent;\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-pub struct LintLevelsBuilder<'a> {\n-    sess: &'a Session,\n-    sets: LintLevelSets,\n-    id_to_set: FxHashMap<HirId, u32>,\n-    cur: u32,\n-    warn_about_weird_lints: bool,\n-}\n-\n-pub struct BuilderPush {\n-    prev: u32,\n-    pub changed: bool,\n-}\n-\n-impl<'a> LintLevelsBuilder<'a> {\n-    pub fn new(\n-        sess: &'a Session,\n-        warn_about_weird_lints: bool,\n-        sets: LintLevelSets,\n-    ) -> LintLevelsBuilder<'a> {\n-        assert_eq!(sets.list.len(), 1);\n-        LintLevelsBuilder {\n-            sess,\n-            sets,\n-            cur: 0,\n-            id_to_set: Default::default(),\n-            warn_about_weird_lints,\n-        }\n-    }\n-\n-    /// Pushes a list of AST lint attributes onto this context.\n-    ///\n-    /// This function will return a `BuilderPush` object which should be passed\n-    /// to `pop` when this scope for the attributes provided is exited.\n-    ///\n-    /// This function will perform a number of tasks:\n-    ///\n-    /// * It'll validate all lint-related attributes in `attrs`\n-    /// * It'll mark all lint-related attributes as used\n-    /// * Lint levels will be updated based on the attributes provided\n-    /// * Lint attributes are validated, e.g., a #[forbid] can't be switched to\n-    ///   #[allow]\n-    ///\n-    /// Don't forget to call `pop`!\n-    pub fn push(&mut self, attrs: &[ast::Attribute], store: &LintStore) -> BuilderPush {\n-        let mut specs = FxHashMap::default();\n-        let sess = self.sess;\n-        let bad_attr = |span| struct_span_err!(sess, span, E0452, \"malformed lint attribute input\");\n-        for attr in attrs {\n-            let level = match Level::from_symbol(attr.name_or_empty()) {\n-                None => continue,\n-                Some(lvl) => lvl,\n-            };\n-\n-            let meta = unwrap_or!(attr.meta(), continue);\n-            attr::mark_used(attr);\n-\n-            let mut metas = unwrap_or!(meta.meta_item_list(), continue);\n-\n-            if metas.is_empty() {\n-                // FIXME (#55112): issue unused-attributes lint for `#[level()]`\n-                continue;\n-            }\n-\n-            // Before processing the lint names, look for a reason (RFC 2383)\n-            // at the end.\n-            let mut reason = None;\n-            let tail_li = &metas[metas.len() - 1];\n-            if let Some(item) = tail_li.meta_item() {\n-                match item.kind {\n-                    ast::MetaItemKind::Word => {} // actual lint names handled later\n-                    ast::MetaItemKind::NameValue(ref name_value) => {\n-                        if item.path == sym::reason {\n-                            // found reason, reslice meta list to exclude it\n-                            metas = &metas[0..metas.len() - 1];\n-                            // FIXME (#55112): issue unused-attributes lint if we thereby\n-                            // don't have any lint names (`#[level(reason = \"foo\")]`)\n-                            if let ast::LitKind::Str(rationale, _) = name_value.kind {\n-                                if !self.sess.features_untracked().lint_reasons {\n-                                    feature_err(\n-                                        &self.sess.parse_sess,\n-                                        sym::lint_reasons,\n-                                        item.span,\n-                                        \"lint reasons are experimental\",\n-                                    )\n-                                    .emit();\n-                                }\n-                                reason = Some(rationale);\n-                            } else {\n-                                bad_attr(name_value.span)\n-                                    .span_label(name_value.span, \"reason must be a string literal\")\n-                                    .emit();\n-                            }\n-                        } else {\n-                            bad_attr(item.span)\n-                                .span_label(item.span, \"bad attribute argument\")\n-                                .emit();\n-                        }\n-                    }\n-                    ast::MetaItemKind::List(_) => {\n-                        bad_attr(item.span).span_label(item.span, \"bad attribute argument\").emit();\n-                    }\n-                }\n-            }\n-\n-            for li in metas {\n-                let meta_item = match li.meta_item() {\n-                    Some(meta_item) if meta_item.is_word() => meta_item,\n-                    _ => {\n-                        let sp = li.span();\n-                        let mut err = bad_attr(sp);\n-                        let mut add_label = true;\n-                        if let Some(item) = li.meta_item() {\n-                            if let ast::MetaItemKind::NameValue(_) = item.kind {\n-                                if item.path == sym::reason {\n-                                    err.span_label(sp, \"reason in lint attribute must come last\");\n-                                    add_label = false;\n-                                }\n-                            }\n-                        }\n-                        if add_label {\n-                            err.span_label(sp, \"bad attribute argument\");\n-                        }\n-                        err.emit();\n-                        continue;\n-                    }\n-                };\n-                let tool_name = if meta_item.path.segments.len() > 1 {\n-                    let tool_ident = meta_item.path.segments[0].ident;\n-                    if !attr::is_known_lint_tool(tool_ident) {\n-                        struct_span_err!(\n-                            sess,\n-                            tool_ident.span,\n-                            E0710,\n-                            \"an unknown tool name found in scoped lint: `{}`\",\n-                            pprust::path_to_string(&meta_item.path),\n-                        )\n-                        .emit();\n-                        continue;\n-                    }\n-\n-                    Some(tool_ident.name)\n-                } else {\n-                    None\n-                };\n-                let name = meta_item.path.segments.last().expect(\"empty lint name\").ident.name;\n-                match store.check_lint_name(&name.as_str(), tool_name) {\n-                    CheckLintNameResult::Ok(ids) => {\n-                        let src = LintSource::Node(name, li.span(), reason);\n-                        for id in ids {\n-                            specs.insert(*id, (level, src));\n-                        }\n-                    }\n-\n-                    CheckLintNameResult::Tool(result) => {\n-                        match result {\n-                            Ok(ids) => {\n-                                let complete_name = &format!(\"{}::{}\", tool_name.unwrap(), name);\n-                                let src = LintSource::Node(\n-                                    Symbol::intern(complete_name),\n-                                    li.span(),\n-                                    reason,\n-                                );\n-                                for id in ids {\n-                                    specs.insert(*id, (level, src));\n-                                }\n-                            }\n-                            Err((Some(ids), new_lint_name)) => {\n-                                let lint = builtin::RENAMED_AND_REMOVED_LINTS;\n-                                let (lvl, src) =\n-                                    self.sets.get_lint_level(lint, self.cur, Some(&specs), &sess);\n-                                let msg = format!(\n-                                    \"lint name `{}` is deprecated \\\n-                                     and may not have an effect in the future. \\\n-                                     Also `cfg_attr(cargo-clippy)` won't be necessary anymore\",\n-                                    name\n-                                );\n-                                lint::struct_lint_level(\n-                                    self.sess,\n-                                    lint,\n-                                    lvl,\n-                                    src,\n-                                    Some(li.span().into()),\n-                                    &msg,\n-                                )\n-                                .span_suggestion(\n-                                    li.span(),\n-                                    \"change it to\",\n-                                    new_lint_name.to_string(),\n-                                    Applicability::MachineApplicable,\n-                                )\n-                                .emit();\n-\n-                                let src = LintSource::Node(\n-                                    Symbol::intern(&new_lint_name),\n-                                    li.span(),\n-                                    reason,\n-                                );\n-                                for id in ids {\n-                                    specs.insert(*id, (level, src));\n-                                }\n-                            }\n-                            Err((None, _)) => {\n-                                // If Tool(Err(None, _)) is returned, then either the lint does not\n-                                // exist in the tool or the code was not compiled with the tool and\n-                                // therefore the lint was never added to the `LintStore`. To detect\n-                                // this is the responsibility of the lint tool.\n-                            }\n-                        }\n-                    }\n-\n-                    _ if !self.warn_about_weird_lints => {}\n-\n-                    CheckLintNameResult::Warning(msg, renamed) => {\n-                        let lint = builtin::RENAMED_AND_REMOVED_LINTS;\n-                        let (level, src) =\n-                            self.sets.get_lint_level(lint, self.cur, Some(&specs), &sess);\n-                        let mut err = lint::struct_lint_level(\n-                            self.sess,\n-                            lint,\n-                            level,\n-                            src,\n-                            Some(li.span().into()),\n-                            &msg,\n-                        );\n-                        if let Some(new_name) = renamed {\n-                            err.span_suggestion(\n-                                li.span(),\n-                                \"use the new name\",\n-                                new_name,\n-                                Applicability::MachineApplicable,\n-                            );\n-                        }\n-                        err.emit();\n-                    }\n-                    CheckLintNameResult::NoLint(suggestion) => {\n-                        let lint = builtin::UNKNOWN_LINTS;\n-                        let (level, src) =\n-                            self.sets.get_lint_level(lint, self.cur, Some(&specs), self.sess);\n-                        let msg = format!(\"unknown lint: `{}`\", name);\n-                        let mut db = lint::struct_lint_level(\n-                            self.sess,\n-                            lint,\n-                            level,\n-                            src,\n-                            Some(li.span().into()),\n-                            &msg,\n-                        );\n-\n-                        if let Some(suggestion) = suggestion {\n-                            db.span_suggestion(\n-                                li.span(),\n-                                \"did you mean\",\n-                                suggestion.to_string(),\n-                                Applicability::MachineApplicable,\n-                            );\n-                        }\n-\n-                        db.emit();\n-                    }\n-                }\n-            }\n-        }\n-\n-        for (id, &(level, ref src)) in specs.iter() {\n-            if level == Level::Forbid {\n-                continue;\n-            }\n-            let forbid_src = match self.sets.get_lint_id_level(*id, self.cur, None) {\n-                (Some(Level::Forbid), src) => src,\n-                _ => continue,\n-            };\n-            let forbidden_lint_name = match forbid_src {\n-                LintSource::Default => id.to_string(),\n-                LintSource::Node(name, _, _) => name.to_string(),\n-                LintSource::CommandLine(name) => name.to_string(),\n-            };\n-            let (lint_attr_name, lint_attr_span) = match *src {\n-                LintSource::Node(name, span, _) => (name, span),\n-                _ => continue,\n-            };\n-            let mut diag_builder = struct_span_err!(\n-                self.sess,\n-                lint_attr_span,\n-                E0453,\n-                \"{}({}) overruled by outer forbid({})\",\n-                level.as_str(),\n-                lint_attr_name,\n-                forbidden_lint_name\n-            );\n-            diag_builder.span_label(lint_attr_span, \"overruled by previous forbid\");\n-            match forbid_src {\n-                LintSource::Default => {}\n-                LintSource::Node(_, forbid_source_span, reason) => {\n-                    diag_builder.span_label(forbid_source_span, \"`forbid` level set here\");\n-                    if let Some(rationale) = reason {\n-                        diag_builder.note(&rationale.as_str());\n-                    }\n-                }\n-                LintSource::CommandLine(_) => {\n-                    diag_builder.note(\"`forbid` lint level was set on command line\");\n-                }\n-            }\n-            diag_builder.emit();\n-            // don't set a separate error for every lint in the group\n-            break;\n-        }\n-\n-        let prev = self.cur;\n-        if specs.len() > 0 {\n-            self.cur = self.sets.list.len() as u32;\n-            self.sets.list.push(LintSet::Node { specs: specs, parent: prev });\n-        }\n-\n-        BuilderPush { prev: prev, changed: prev != self.cur }\n-    }\n-\n-    /// Called after `push` when the scope of a set of attributes are exited.\n-    pub fn pop(&mut self, push: BuilderPush) {\n-        self.cur = push.prev;\n-    }\n-\n-    /// Used to emit a lint-related diagnostic based on the current state of\n-    /// this lint context.\n-    pub fn struct_lint(\n-        &self,\n-        lint: &'static Lint,\n-        span: Option<MultiSpan>,\n-        msg: &str,\n-    ) -> DiagnosticBuilder<'a> {\n-        let (level, src) = self.sets.get_lint_level(lint, self.cur, None, self.sess);\n-        lint::struct_lint_level(self.sess, lint, level, src, span, msg)\n-    }\n-\n-    /// Registers the ID provided with the current set of lints stored in\n-    /// this context.\n-    pub fn register_id(&mut self, id: HirId) {\n-        self.id_to_set.insert(id, self.cur);\n-    }\n-\n-    pub fn build(self) -> LintLevelSets {\n-        self.sets\n-    }\n-\n-    pub fn build_map(self) -> LintLevelMap {\n-        LintLevelMap { sets: self.sets, id_to_set: self.id_to_set }\n-    }\n-}\n-\n-pub struct LintLevelMap {\n-    sets: LintLevelSets,\n-    id_to_set: FxHashMap<HirId, u32>,\n-}\n-\n-impl LintLevelMap {\n-    /// If the `id` was previously registered with `register_id` when building\n-    /// this `LintLevelMap` this returns the corresponding lint level and source\n-    /// of the lint level for the lint provided.\n-    ///\n-    /// If the `id` was not previously registered, returns `None`. If `None` is\n-    /// returned then the parent of `id` should be acquired and this function\n-    /// should be called again.\n-    pub fn level_and_source(\n-        &self,\n-        lint: &'static Lint,\n-        id: HirId,\n-        session: &Session,\n-    ) -> Option<(Level, LintSource)> {\n-        self.id_to_set.get(&id).map(|idx| self.sets.get_lint_level(lint, *idx, None, session))\n-    }\n-}\n-\n-impl<'a> HashStable<StableHashingContext<'a>> for LintLevelMap {\n-    #[inline]\n-    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n-        let LintLevelMap { ref sets, ref id_to_set } = *self;\n-\n-        id_to_set.hash_stable(hcx, hasher);\n-\n-        let LintLevelSets { ref list, lint_cap } = *sets;\n-\n-        lint_cap.hash_stable(hcx, hasher);\n-\n-        hcx.while_hashing_spans(true, |hcx| {\n-            list.len().hash_stable(hcx, hasher);\n-\n-            // We are working under the assumption here that the list of\n-            // lint-sets is built in a deterministic order.\n-            for lint_set in list {\n-                ::std::mem::discriminant(lint_set).hash_stable(hcx, hasher);\n-\n-                match *lint_set {\n-                    LintSet::CommandLine { ref specs } => {\n-                        specs.hash_stable(hcx, hasher);\n-                    }\n-                    LintSet::Node { ref specs, parent } => {\n-                        specs.hash_stable(hcx, hasher);\n-                        parent.hash_stable(hcx, hasher);\n-                    }\n-                }\n-            }\n-        })\n-    }\n-}"}, {"sha": "1176ffc79d26d0749080c114d1d2161170b5278e", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0b6c116a84fb1dbb60b5870291f5d7df808c280d/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b6c116a84fb1dbb60b5870291f5d7df808c280d/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=0b6c116a84fb1dbb60b5870291f5d7df808c280d", "patch": "@@ -3,7 +3,6 @@\n \n pub use self::StabilityLevel::*;\n \n-use crate::lint::{self, in_derive_expansion, Lint};\n use crate::session::{DiagnosticMessageId, Session};\n use crate::ty::{self, TyCtxt};\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n@@ -13,7 +12,7 @@ use rustc_hir as hir;\n use rustc_hir::def::DefKind;\n use rustc_hir::def_id::{CrateNum, DefId, CRATE_DEF_INDEX};\n use rustc_hir::{self, HirId};\n-use rustc_session::lint::{BuiltinLintDiagnostics, LintBuffer};\n+use rustc_session::lint::{self, BuiltinLintDiagnostics, Lint, LintBuffer};\n use rustc_span::symbol::{sym, Symbol};\n use rustc_span::{MultiSpan, Span};\n use syntax::ast::CRATE_NODE_ID;\n@@ -201,7 +200,7 @@ pub fn early_report_deprecation(\n     lint: &'static Lint,\n     span: Span,\n ) {\n-    if in_derive_expansion(span) {\n+    if span.in_derive_expansion() {\n         return;\n     }\n \n@@ -218,7 +217,7 @@ fn late_report_deprecation(\n     def_id: DefId,\n     hir_id: HirId,\n ) {\n-    if in_derive_expansion(span) {\n+    if span.in_derive_expansion() {\n         return;\n     }\n "}, {"sha": "8643bd63d8cba29e9ab99dbf4e14fcba938c2ed1", "filename": "src/librustc/mir/interpret/error.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0b6c116a84fb1dbb60b5870291f5d7df808c280d/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b6c116a84fb1dbb60b5870291f5d7df808c280d/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs?ref=0b6c116a84fb1dbb60b5870291f5d7df808c280d", "patch": "@@ -154,7 +154,7 @@ impl<'tcx> ConstEvalErr<'tcx> {\n                 .next()\n                 .unwrap_or(lint_root);\n             tcx.struct_span_lint_hir(\n-                crate::rustc::lint::builtin::CONST_ERR,\n+                rustc_session::lint::builtin::CONST_ERR,\n                 hir_id,\n                 tcx.span,\n                 message,"}, {"sha": "eca9df688c64f7e9b583f18413298a9eb7a667e5", "filename": "src/librustc/query/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0b6c116a84fb1dbb60b5870291f5d7df808c280d/src%2Flibrustc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b6c116a84fb1dbb60b5870291f5d7df808c280d/src%2Flibrustc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fquery%2Fmod.rs?ref=0b6c116a84fb1dbb60b5870291f5d7df808c280d", "patch": "@@ -82,7 +82,7 @@ rustc_queries! {\n             desc { \"looking up the native libraries of a linked crate\" }\n         }\n \n-        query lint_levels(_: CrateNum) -> &'tcx lint::LintLevelMap {\n+        query lint_levels(_: CrateNum) -> &'tcx LintLevelMap {\n             eval_always\n             desc { \"computing the lint levels for items in this crate\" }\n         }"}, {"sha": "ce57fb8110496036f86b0109aa636336a5f04f61", "filename": "src/librustc/traits/object_safety.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0b6c116a84fb1dbb60b5870291f5d7df808c280d/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b6c116a84fb1dbb60b5870291f5d7df808c280d/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fobject_safety.rs?ref=0b6c116a84fb1dbb60b5870291f5d7df808c280d", "patch": "@@ -10,17 +10,18 @@\n \n use super::elaborate_predicates;\n \n-use crate::lint;\n use crate::traits::{self, Obligation, ObligationCause};\n use crate::ty::subst::{InternalSubsts, Subst};\n use crate::ty::{self, Predicate, ToPredicate, Ty, TyCtxt, TypeFoldable};\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n+use rustc_session::lint::builtin::WHERE_CLAUSES_OBJECT_SAFETY;\n use rustc_span::symbol::Symbol;\n use rustc_span::{Span, DUMMY_SP};\n+use syntax::ast;\n+\n use std::borrow::Cow;\n use std::iter::{self};\n-use syntax::ast::{self};\n \n #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n pub enum ObjectSafetyViolation {\n@@ -178,16 +179,17 @@ fn object_safety_violations_for_trait(\n             {\n                 // Using `CRATE_NODE_ID` is wrong, but it's hard to get a more precise id.\n                 // It's also hard to get a use site span, so we use the method definition span.\n-                tcx.lint_node_note(\n-                    lint::builtin::WHERE_CLAUSES_OBJECT_SAFETY,\n+                tcx.struct_span_lint_hir(\n+                    WHERE_CLAUSES_OBJECT_SAFETY,\n                     hir::CRATE_HIR_ID,\n                     *span,\n                     &format!(\n                         \"the trait `{}` cannot be made into an object\",\n                         tcx.def_path_str(trait_def_id)\n                     ),\n-                    &violation.error_msg(),\n-                );\n+                )\n+                .note(&violation.error_msg())\n+                .emit();\n                 false\n             } else {\n                 true"}, {"sha": "5bc211ade40ad1d6fd5d5175b8031cf572f26cee", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0b6c116a84fb1dbb60b5870291f5d7df808c280d/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b6c116a84fb1dbb60b5870291f5d7df808c280d/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=0b6c116a84fb1dbb60b5870291f5d7df808c280d", "patch": "@@ -1467,7 +1467,7 @@ fn assoc_ty_def(\n     // cycle error if the specialization graph is currently being built.\n     let impl_node = specialization_graph::Node::Impl(impl_def_id);\n     for item in impl_node.items(tcx) {\n-        if item.kind == ty::AssocKind::Type\n+        if matches!(item.kind, ty::AssocKind::Type | ty::AssocKind::OpaqueTy)\n             && tcx.hygienic_eq(item.ident, assoc_ty_name, trait_def_id)\n         {\n             return specialization_graph::NodeItem {"}, {"sha": "f5199dbdabb2f42534d164b92ef1b4820e33e084", "filename": "src/librustc/traits/specialize/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0b6c116a84fb1dbb60b5870291f5d7df808c280d/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b6c116a84fb1dbb60b5870291f5d7df808c280d/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs?ref=0b6c116a84fb1dbb60b5870291f5d7df808c280d", "patch": "@@ -12,14 +12,14 @@\n pub mod specialization_graph;\n \n use crate::infer::{InferCtxt, InferOk};\n-use crate::lint;\n use crate::traits::select::IntercrateAmbiguityCause;\n use crate::traits::{self, coherence, FutureCompatOverlapErrorKind, ObligationCause, TraitEngine};\n use crate::ty::subst::{InternalSubsts, Subst, SubstsRef};\n use crate::ty::{self, TyCtxt, TypeFoldable};\n use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::struct_span_err;\n use rustc_hir::def_id::DefId;\n+use rustc_session::lint::builtin::ORDER_DEPENDENT_TRAIT_OBJECTS;\n use rustc_span::DUMMY_SP;\n \n use super::util::impl_trait_ref_and_oblig;\n@@ -342,7 +342,7 @@ pub(super) fn specialization_graph_provider(\n                                 unreachable!(\"converted to hard error above\")\n                             }\n                             FutureCompatOverlapErrorKind::Issue33140 => {\n-                                lint::builtin::ORDER_DEPENDENT_TRAIT_OBJECTS\n+                                ORDER_DEPENDENT_TRAIT_OBJECTS\n                             }\n                         };\n                         tcx.struct_span_lint_hir("}, {"sha": "6b98fddb22ef913b72ca56820d7fbada126c3f6f", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 24, "deletions": 46, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/0b6c116a84fb1dbb60b5870291f5d7df808c280d/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b6c116a84fb1dbb60b5870291f5d7df808c280d/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=0b6c116a84fb1dbb60b5870291f5d7df808c280d", "patch": "@@ -8,7 +8,7 @@ use crate::hir::map as hir_map;\n use crate::hir::map::DefPathHash;\n use crate::ich::{NodeIdHashingMode, StableHashingContext};\n use crate::infer::canonical::{Canonical, CanonicalVarInfo, CanonicalVarInfos};\n-use crate::lint::{self, Lint};\n+use crate::lint::{struct_lint_level, LintSource};\n use crate::middle;\n use crate::middle::cstore::CrateStoreDyn;\n use crate::middle::cstore::EncodedMetadata;\n@@ -20,9 +20,6 @@ use crate::mir::interpret::{Allocation, ConstValue, Scalar};\n use crate::mir::{\n     interpret, BodyAndCache, Field, Local, Place, PlaceElem, ProjectionKind, Promoted,\n };\n-use crate::session::config::CrateType;\n-use crate::session::config::{BorrowckMode, OutputFilenames};\n-use crate::session::Session;\n use crate::traits;\n use crate::traits::{Clause, Clauses, Goal, GoalKind, Goals};\n use crate::ty::free_region_map::FreeRegionMap;\n@@ -44,11 +41,15 @@ use crate::ty::{ExistentialPredicate, InferTy, ParamTy, PolyFnSig, Predicate, Pr\n use crate::ty::{InferConst, ParamConst};\n use crate::ty::{List, TyKind, TyS};\n use crate::util::common::ErrorReported;\n+use rustc_data_structures::sync;\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::{CrateNum, DefId, DefIdMap, DefIdSet, DefIndex, LOCAL_CRATE};\n use rustc_hir::{HirId, Node, TraitCandidate};\n use rustc_hir::{ItemKind, ItemLocalId, ItemLocalMap, ItemLocalSet};\n+use rustc_session::config::CrateType;\n+use rustc_session::config::{BorrowckMode, OutputFilenames};\n+use rustc_session::Session;\n \n use arena::SyncDroplessArena;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n@@ -61,6 +62,7 @@ use rustc_data_structures::sync::{Lock, Lrc, WorkerLocal};\n use rustc_errors::DiagnosticBuilder;\n use rustc_index::vec::{Idx, IndexVec};\n use rustc_macros::HashStable;\n+use rustc_session::lint::{Level, Lint};\n use rustc_session::node_id::NodeMap;\n use rustc_span::source_map::MultiSpan;\n use rustc_span::symbol::{kw, sym, Symbol};\n@@ -946,7 +948,11 @@ pub struct GlobalCtxt<'tcx> {\n \n     pub sess: &'tcx Session,\n \n-    pub lint_store: Lrc<lint::LintStore>,\n+    /// This only ever stores a `LintStore` but we don't want a dependency on that type here.\n+    ///\n+    /// FIXME(Centril): consider `dyn LintStoreMarker` once\n+    /// we can upcast to `Any` for some additional type safety.\n+    pub lint_store: Lrc<dyn Any + sync::Sync + sync::Send>,\n \n     pub dep_graph: DepGraph,\n \n@@ -1115,7 +1121,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     /// reference to the context, to allow formatting values that need it.\n     pub fn create_global_ctxt(\n         s: &'tcx Session,\n-        lint_store: Lrc<lint::LintStore>,\n+        lint_store: Lrc<dyn Any + sync::Send + sync::Sync>,\n         local_providers: ty::query::Providers<'tcx>,\n         extern_providers: ty::query::Providers<'tcx>,\n         arenas: &'tcx AllArenas,\n@@ -2551,57 +2557,29 @@ impl<'tcx> TyCtxt<'tcx> {\n         iter.intern_with(|xs| self.intern_goals(xs))\n     }\n \n-    pub fn lint_hir<S: Into<MultiSpan>>(\n+    pub fn lint_hir(\n         self,\n         lint: &'static Lint,\n         hir_id: HirId,\n-        span: S,\n+        span: impl Into<MultiSpan>,\n         msg: &str,\n     ) {\n         self.struct_span_lint_hir(lint, hir_id, span.into(), msg).emit()\n     }\n \n-    pub fn lint_hir_note<S: Into<MultiSpan>>(\n-        self,\n-        lint: &'static Lint,\n-        hir_id: HirId,\n-        span: S,\n-        msg: &str,\n-        note: &str,\n-    ) {\n-        let mut err = self.struct_span_lint_hir(lint, hir_id, span.into(), msg);\n-        err.note(note);\n-        err.emit()\n-    }\n-\n-    pub fn lint_node_note<S: Into<MultiSpan>>(\n-        self,\n-        lint: &'static Lint,\n-        id: hir::HirId,\n-        span: S,\n-        msg: &str,\n-        note: &str,\n-    ) {\n-        let mut err = self.struct_span_lint_hir(lint, id, span.into(), msg);\n-        err.note(note);\n-        err.emit()\n-    }\n-\n     /// Walks upwards from `id` to find a node which might change lint levels with attributes.\n     /// It stops at `bound` and just returns it if reached.\n-    pub fn maybe_lint_level_root_bounded(\n-        self,\n-        mut id: hir::HirId,\n-        bound: hir::HirId,\n-    ) -> hir::HirId {\n+    pub fn maybe_lint_level_root_bounded(self, mut id: HirId, bound: HirId) -> HirId {\n+        let hir = self.hir();\n         loop {\n             if id == bound {\n                 return bound;\n             }\n-            if lint::maybe_lint_level_root(self, id) {\n+\n+            if hir.attrs(id).iter().any(|attr| Level::from_symbol(attr.name_or_empty()).is_some()) {\n                 return id;\n             }\n-            let next = self.hir().get_parent_node(id);\n+            let next = hir.get_parent_node(id);\n             if next == id {\n                 bug!(\"lint traversal reached the root of the crate\");\n             }\n@@ -2613,7 +2591,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         self,\n         lint: &'static Lint,\n         mut id: hir::HirId,\n-    ) -> (lint::Level, lint::LintSource) {\n+    ) -> (Level, LintSource) {\n         let sets = self.lint_levels(LOCAL_CRATE);\n         loop {\n             if let Some(pair) = sets.level_and_source(lint, id, self.sess) {\n@@ -2627,15 +2605,15 @@ impl<'tcx> TyCtxt<'tcx> {\n         }\n     }\n \n-    pub fn struct_span_lint_hir<S: Into<MultiSpan>>(\n+    pub fn struct_span_lint_hir(\n         self,\n         lint: &'static Lint,\n         hir_id: HirId,\n-        span: S,\n+        span: impl Into<MultiSpan>,\n         msg: &str,\n     ) -> DiagnosticBuilder<'tcx> {\n         let (level, src) = self.lint_level_at_node(lint, hir_id);\n-        lint::struct_lint_level(self.sess, lint, level, src, Some(span.into()), msg)\n+        struct_lint_level(self.sess, lint, level, src, Some(span.into()), msg)\n     }\n \n     pub fn struct_lint_node(\n@@ -2645,7 +2623,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         msg: &str,\n     ) -> DiagnosticBuilder<'tcx> {\n         let (level, src) = self.lint_level_at_node(lint, id);\n-        lint::struct_lint_level(self.sess, lint, level, src, None, msg)\n+        struct_lint_level(self.sess, lint, level, src, None, msg)\n     }\n \n     pub fn in_scope_traits(self, id: HirId) -> Option<&'tcx StableVec<TraitCandidate>> {"}, {"sha": "1d41871bb33a924979c0bfdde0e1f0a8a87efb2e", "filename": "src/librustc/ty/query/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0b6c116a84fb1dbb60b5870291f5d7df808c280d/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b6c116a84fb1dbb60b5870291f5d7df808c280d/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs?ref=0b6c116a84fb1dbb60b5870291f5d7df808c280d", "patch": "@@ -1,7 +1,7 @@\n use crate::dep_graph::{self, DepNode};\n use crate::hir::exports::Export;\n use crate::infer::canonical::{self, Canonical};\n-use crate::lint;\n+use crate::lint::LintLevelMap;\n use crate::middle::codegen_fn_attrs::CodegenFnAttrs;\n use crate::middle::cstore::{CrateSource, DepKind, NativeLibraryKind};\n use crate::middle::cstore::{ExternCrate, ForeignModule, LinkagePreference, NativeLibrary};"}, {"sha": "d30d0bd8345fff22d2f00f3e77f1db27567b8166", "filename": "src/librustc_ast_lowering/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0b6c116a84fb1dbb60b5870291f5d7df808c280d/src%2Flibrustc_ast_lowering%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b6c116a84fb1dbb60b5870291f5d7df808c280d/src%2Flibrustc_ast_lowering%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_lowering%2Flib.rs?ref=0b6c116a84fb1dbb60b5870291f5d7df808c280d", "patch": "@@ -37,7 +37,6 @@ use rustc::arena::Arena;\n use rustc::dep_graph::DepGraph;\n use rustc::hir::map::definitions::{DefKey, DefPathData, Definitions};\n use rustc::hir::map::Map;\n-use rustc::lint::builtin;\n use rustc::{bug, span_bug};\n use rustc_data_structures::captures::Captures;\n use rustc_data_structures::fx::FxHashSet;\n@@ -51,7 +50,7 @@ use rustc_hir::intravisit;\n use rustc_hir::{ConstArg, GenericArg, ParamName};\n use rustc_index::vec::IndexVec;\n use rustc_session::config::nightly_options;\n-use rustc_session::lint::{BuiltinLintDiagnostics, LintBuffer};\n+use rustc_session::lint::{builtin, BuiltinLintDiagnostics, LintBuffer};\n use rustc_session::node_id::NodeMap;\n use rustc_session::Session;\n use rustc_span::hygiene::ExpnId;"}, {"sha": "2d45e280444955e08b2784647840c985f5d044e3", "filename": "src/librustc_ast_passes/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0b6c116a84fb1dbb60b5870291f5d7df808c280d/src%2Flibrustc_ast_passes%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/0b6c116a84fb1dbb60b5870291f5d7df808c280d/src%2Flibrustc_ast_passes%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_passes%2FCargo.toml?ref=0b6c116a84fb1dbb60b5870291f5d7df808c280d", "patch": "@@ -11,7 +11,7 @@ path = \"lib.rs\"\n [dependencies]\n log = \"0.4\"\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n-rustc_errors = { path = \"../librustc_errors\", package = \"rustc_errors\" }\n+rustc_errors = { path = \"../librustc_errors\" }\n rustc_error_codes = { path = \"../librustc_error_codes\" }\n rustc_feature = { path = \"../librustc_feature\" }\n rustc_parse = { path = \"../librustc_parse\" }"}, {"sha": "ede5757a479de273216921e6ec9e04ee8b8b8ce9", "filename": "src/librustc_data_structures/binary_search_util/mod.rs", "status": "modified", "additions": 40, "deletions": 20, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/0b6c116a84fb1dbb60b5870291f5d7df808c280d/src%2Flibrustc_data_structures%2Fbinary_search_util%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b6c116a84fb1dbb60b5870291f5d7df808c280d/src%2Flibrustc_data_structures%2Fbinary_search_util%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fbinary_search_util%2Fmod.rs?ref=0b6c116a84fb1dbb60b5870291f5d7df808c280d", "patch": "@@ -14,35 +14,55 @@ where\n         Ok(mid) => mid,\n         Err(_) => return &[],\n     };\n+    let size = data.len();\n \n-    // We get back *some* element with the given key -- so\n-    // search backwards to find the *first* one.\n-    //\n-    // (It'd be more efficient to use a \"galloping\" search\n-    // here, but it's not really worth it for small-ish\n-    // amounts of data.)\n+    // We get back *some* element with the given key -- so do\n+    // a galloping search backwards to find the *first* one.\n     let mut start = mid;\n-    while start > 0 {\n-        if key_fn(&data[start - 1]) == *key {\n-            start -= 1;\n-        } else {\n+    let mut previous = mid;\n+    let mut step = 1;\n+    loop {\n+        start = start.saturating_sub(step);\n+        if start == 0 || key_fn(&data[start]) != *key {\n             break;\n         }\n+        previous = start;\n+        step *= 2;\n+    }\n+    step = previous - start;\n+    while step > 1 {\n+        let half = step / 2;\n+        let mid = start + half;\n+        if key_fn(&data[mid]) != *key {\n+            start = mid;\n+        }\n+        step -= half;\n+    }\n+    // adjust by one if we have overshot\n+    if start < size && key_fn(&data[start]) != *key {\n+        start += 1;\n     }\n \n     // Now search forward to find the *last* one.\n-    //\n-    // (It'd be more efficient to use a \"galloping\" search\n-    // here, but it's not really worth it for small-ish\n-    // amounts of data.)\n-    let mut end = mid + 1;\n-    let max = data.len();\n-    while end < max {\n-        if key_fn(&data[end]) == *key {\n-            end += 1;\n-        } else {\n+    let mut end = mid;\n+    let mut previous = mid;\n+    let mut step = 1;\n+    loop {\n+        end = end.saturating_add(step).min(size);\n+        if end == size || key_fn(&data[end]) != *key {\n             break;\n         }\n+        previous = end;\n+        step *= 2;\n+    }\n+    step = end - previous;\n+    while step > 1 {\n+        let half = step / 2;\n+        let mid = end - half;\n+        if key_fn(&data[mid]) != *key {\n+            end = mid;\n+        }\n+        step -= half;\n     }\n \n     &data[start..end]"}, {"sha": "072b85d716d74d17367f2e668fc1d1762f35bc52", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/0b6c116a84fb1dbb60b5870291f5d7df808c280d/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b6c116a84fb1dbb60b5870291f5d7df808c280d/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=0b6c116a84fb1dbb60b5870291f5d7df808c280d", "patch": "@@ -23,9 +23,7 @@ extern crate lazy_static;\n \n pub extern crate rustc_plugin_impl as plugin;\n \n-//use rustc_resolve as resolve;\n-use rustc::lint;\n-use rustc::lint::Lint;\n+use rustc::lint::{Lint, LintId};\n use rustc::middle::cstore::MetadataLoader;\n use rustc::session::config::nightly_options;\n use rustc::session::config::{ErrorOutputType, Input, OutputType, PrintRequest};\n@@ -41,6 +39,7 @@ use rustc_feature::{find_gated_cfg, UnstableFeatures};\n use rustc_hir::def_id::LOCAL_CRATE;\n use rustc_interface::util::get_builtin_codegen_backend;\n use rustc_interface::{interface, Queries};\n+use rustc_lint::LintStore;\n use rustc_metadata::locator;\n use rustc_save_analysis as save;\n use rustc_save_analysis::DumpHandler;\n@@ -811,7 +810,7 @@ the command line flag directly.\n     );\n }\n \n-fn describe_lints(sess: &Session, lint_store: &lint::LintStore, loaded_plugins: bool) {\n+fn describe_lints(sess: &Session, lint_store: &LintStore, loaded_plugins: bool) {\n     println!(\n         \"\n Available lint options:\n@@ -832,8 +831,8 @@ Available lint options:\n     }\n \n     fn sort_lint_groups(\n-        lints: Vec<(&'static str, Vec<lint::LintId>, bool)>,\n-    ) -> Vec<(&'static str, Vec<lint::LintId>)> {\n+        lints: Vec<(&'static str, Vec<LintId>, bool)>,\n+    ) -> Vec<(&'static str, Vec<LintId>)> {\n         let mut lints: Vec<_> = lints.into_iter().map(|(x, y, _)| (x, y)).collect();\n         lints.sort_by_key(|l| l.0);\n         lints\n@@ -892,7 +891,7 @@ Available lint options:\n     println!(\"    {}  {}\", padded(\"----\"), \"---------\");\n     println!(\"    {}  {}\", padded(\"warnings\"), \"all lints that are set to issue warnings\");\n \n-    let print_lint_groups = |lints: Vec<(&'static str, Vec<lint::LintId>)>| {\n+    let print_lint_groups = |lints: Vec<(&'static str, Vec<LintId>)>| {\n         for (name, to) in lints {\n             let name = name.to_lowercase().replace(\"_\", \"-\");\n             let desc = to"}, {"sha": "9cd9eb66cf6c1f0b304385a0ec22323790c53b0f", "filename": "src/librustc_interface/interface.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0b6c116a84fb1dbb60b5870291f5d7df808c280d/src%2Flibrustc_interface%2Finterface.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b6c116a84fb1dbb60b5870291f5d7df808c280d/src%2Flibrustc_interface%2Finterface.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Finterface.rs?ref=0b6c116a84fb1dbb60b5870291f5d7df808c280d", "patch": "@@ -12,6 +12,7 @@ use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::sync::Lrc;\n use rustc_data_structures::OnDrop;\n use rustc_errors::registry::Registry;\n+use rustc_lint::LintStore;\n use rustc_parse::new_parser_from_source_str;\n use rustc_span::edition;\n use rustc_span::source_map::{FileLoader, FileName, SourceMap};\n@@ -36,7 +37,7 @@ pub struct Compiler {\n     pub(crate) output_dir: Option<PathBuf>,\n     pub(crate) output_file: Option<PathBuf>,\n     pub(crate) crate_name: Option<String>,\n-    pub(crate) register_lints: Option<Box<dyn Fn(&Session, &mut lint::LintStore) + Send + Sync>>,\n+    pub(crate) register_lints: Option<Box<dyn Fn(&Session, &mut LintStore) + Send + Sync>>,\n     pub(crate) override_queries:\n         Option<fn(&Session, &mut ty::query::Providers<'_>, &mut ty::query::Providers<'_>)>,\n }\n@@ -136,7 +137,7 @@ pub struct Config {\n     ///\n     /// Note that if you find a Some here you probably want to call that function in the new\n     /// function being registered.\n-    pub register_lints: Option<Box<dyn Fn(&Session, &mut lint::LintStore) + Send + Sync>>,\n+    pub register_lints: Option<Box<dyn Fn(&Session, &mut LintStore) + Send + Sync>>,\n \n     /// This is a callback from the driver that is called just after we have populated\n     /// the list of queries."}, {"sha": "67f9819f3314d6c280f3e11f03b596d35e59497f", "filename": "src/librustc_interface/passes.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/0b6c116a84fb1dbb60b5870291f5d7df808c280d/src%2Flibrustc_interface%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b6c116a84fb1dbb60b5870291f5d7df808c280d/src%2Flibrustc_interface%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fpasses.rs?ref=0b6c116a84fb1dbb60b5870291f5d7df808c280d", "patch": "@@ -27,6 +27,7 @@ use rustc_errors::PResult;\n use rustc_expand::base::ExtCtxt;\n use rustc_hir::def_id::{CrateNum, LOCAL_CRATE};\n use rustc_incremental;\n+use rustc_lint::LintStore;\n use rustc_mir as mir;\n use rustc_parse::{parse_crate_from_file, parse_crate_from_source_str};\n use rustc_passes::{self, hir_stats, layout_test};\n@@ -100,7 +101,7 @@ declare_box_region_type!(\n /// Returns `None` if we're aborting after handling -W help.\n pub fn configure_and_expand(\n     sess: Lrc<Session>,\n-    lint_store: Lrc<lint::LintStore>,\n+    lint_store: Lrc<LintStore>,\n     metadata_loader: Box<MetadataLoaderDyn>,\n     krate: ast::Crate,\n     crate_name: &str,\n@@ -150,10 +151,10 @@ impl BoxedResolver {\n pub fn register_plugins<'a>(\n     sess: &'a Session,\n     metadata_loader: &'a dyn MetadataLoader,\n-    register_lints: impl Fn(&Session, &mut lint::LintStore),\n+    register_lints: impl Fn(&Session, &mut LintStore),\n     mut krate: ast::Crate,\n     crate_name: &str,\n-) -> Result<(ast::Crate, Lrc<lint::LintStore>)> {\n+) -> Result<(ast::Crate, Lrc<LintStore>)> {\n     krate = sess.time(\"attributes_injection\", || {\n         rustc_builtin_macros::cmdline_attrs::inject(\n             krate,\n@@ -214,7 +215,7 @@ pub fn register_plugins<'a>(\n \n fn configure_and_expand_inner<'a>(\n     sess: &'a Session,\n-    lint_store: &'a lint::LintStore,\n+    lint_store: &'a LintStore,\n     mut krate: ast::Crate,\n     crate_name: &str,\n     resolver_arenas: &'a ResolverArenas<'a>,\n@@ -420,7 +421,7 @@ fn configure_and_expand_inner<'a>(\n \n pub fn lower_to_hir<'res, 'tcx>(\n     sess: &'tcx Session,\n-    lint_store: &lint::LintStore,\n+    lint_store: &LintStore,\n     resolver: &'res mut Resolver<'_>,\n     dep_graph: &'res DepGraph,\n     krate: &'res ast::Crate,\n@@ -705,7 +706,7 @@ impl<'tcx> QueryContext<'tcx> {\n \n pub fn create_global_ctxt<'tcx>(\n     compiler: &'tcx Compiler,\n-    lint_store: Lrc<lint::LintStore>,\n+    lint_store: Lrc<LintStore>,\n     hir_forest: &'tcx map::Forest<'tcx>,\n     mut resolver_outputs: ResolverOutputs,\n     outputs: OutputFilenames,"}, {"sha": "bd9717d3f3d0253bb6b158244821460b6cfd371b", "filename": "src/librustc_interface/queries.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0b6c116a84fb1dbb60b5870291f5d7df808c280d/src%2Flibrustc_interface%2Fqueries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b6c116a84fb1dbb60b5870291f5d7df808c280d/src%2Flibrustc_interface%2Fqueries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fqueries.rs?ref=0b6c116a84fb1dbb60b5870291f5d7df808c280d", "patch": "@@ -4,8 +4,6 @@ use crate::passes::{self, BoxedResolver, QueryContext};\n use rustc::arena::Arena;\n use rustc::dep_graph::DepGraph;\n use rustc::hir::map;\n-use rustc::lint;\n-use rustc::lint::LintStore;\n use rustc::session::config::{OutputFilenames, OutputType};\n use rustc::session::Session;\n use rustc::ty::steal::Steal;\n@@ -15,6 +13,7 @@ use rustc_codegen_utils::codegen_backend::CodegenBackend;\n use rustc_data_structures::sync::{Lrc, Once, WorkerLocal};\n use rustc_hir::def_id::LOCAL_CRATE;\n use rustc_incremental::DepGraphFuture;\n+use rustc_lint::LintStore;\n use std::any::Any;\n use std::cell::{Ref, RefCell, RefMut};\n use std::mem;\n@@ -133,7 +132,7 @@ impl<'tcx> Queries<'tcx> {\n             let crate_name = self.crate_name()?.peek().clone();\n             let krate = self.parse()?.take();\n \n-            let empty: &(dyn Fn(&Session, &mut lint::LintStore) + Sync + Send) = &|_, _| {};\n+            let empty: &(dyn Fn(&Session, &mut LintStore) + Sync + Send) = &|_, _| {};\n             let result = passes::register_plugins(\n                 self.session(),\n                 &*self.codegen_backend().metadata_loader(),"}, {"sha": "ec75a1c6a3938d92df5d95ee847cf19270997473", "filename": "src/librustc_interface/tests.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/0b6c116a84fb1dbb60b5870291f5d7df808c280d/src%2Flibrustc_interface%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b6c116a84fb1dbb60b5870291f5d7df808c280d/src%2Flibrustc_interface%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Ftests.rs?ref=0b6c116a84fb1dbb60b5870291f5d7df808c280d", "patch": "@@ -2,7 +2,7 @@ extern crate getopts;\n \n use crate::interface::parse_cfgspecs;\n \n-use rustc::lint;\n+use rustc::lint::Level;\n use rustc::middle::cstore;\n use rustc::session::config::{build_configuration, build_session_options, to_crate_config};\n use rustc::session::config::{rustc_optgroups, ErrorOutputType, ExternLocation, Options, Passes};\n@@ -186,24 +186,24 @@ fn test_lints_tracking_hash_different_values() {\n     let mut v3 = Options::default();\n \n     v1.lint_opts = vec![\n-        (String::from(\"a\"), lint::Allow),\n-        (String::from(\"b\"), lint::Warn),\n-        (String::from(\"c\"), lint::Deny),\n-        (String::from(\"d\"), lint::Forbid),\n+        (String::from(\"a\"), Level::Allow),\n+        (String::from(\"b\"), Level::Warn),\n+        (String::from(\"c\"), Level::Deny),\n+        (String::from(\"d\"), Level::Forbid),\n     ];\n \n     v2.lint_opts = vec![\n-        (String::from(\"a\"), lint::Allow),\n-        (String::from(\"b\"), lint::Warn),\n-        (String::from(\"X\"), lint::Deny),\n-        (String::from(\"d\"), lint::Forbid),\n+        (String::from(\"a\"), Level::Allow),\n+        (String::from(\"b\"), Level::Warn),\n+        (String::from(\"X\"), Level::Deny),\n+        (String::from(\"d\"), Level::Forbid),\n     ];\n \n     v3.lint_opts = vec![\n-        (String::from(\"a\"), lint::Allow),\n-        (String::from(\"b\"), lint::Warn),\n-        (String::from(\"c\"), lint::Forbid),\n-        (String::from(\"d\"), lint::Deny),\n+        (String::from(\"a\"), Level::Allow),\n+        (String::from(\"b\"), Level::Warn),\n+        (String::from(\"c\"), Level::Forbid),\n+        (String::from(\"d\"), Level::Deny),\n     ];\n \n     assert!(v1.dep_tracking_hash() != v2.dep_tracking_hash());\n@@ -222,17 +222,17 @@ fn test_lints_tracking_hash_different_construction_order() {\n     let mut v2 = Options::default();\n \n     v1.lint_opts = vec![\n-        (String::from(\"a\"), lint::Allow),\n-        (String::from(\"b\"), lint::Warn),\n-        (String::from(\"c\"), lint::Deny),\n-        (String::from(\"d\"), lint::Forbid),\n+        (String::from(\"a\"), Level::Allow),\n+        (String::from(\"b\"), Level::Warn),\n+        (String::from(\"c\"), Level::Deny),\n+        (String::from(\"d\"), Level::Forbid),\n     ];\n \n     v2.lint_opts = vec![\n-        (String::from(\"a\"), lint::Allow),\n-        (String::from(\"c\"), lint::Deny),\n-        (String::from(\"b\"), lint::Warn),\n-        (String::from(\"d\"), lint::Forbid),\n+        (String::from(\"a\"), Level::Allow),\n+        (String::from(\"c\"), Level::Deny),\n+        (String::from(\"b\"), Level::Warn),\n+        (String::from(\"d\"), Level::Forbid),\n     ];\n \n     assert_eq!(v1.dep_tracking_hash(), v2.dep_tracking_hash());"}, {"sha": "abf9f96e6475b26e464dddf33271f8696f9e448c", "filename": "src/librustc_lint/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0b6c116a84fb1dbb60b5870291f5d7df808c280d/src%2Flibrustc_lint%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/0b6c116a84fb1dbb60b5870291f5d7df808c280d/src%2Flibrustc_lint%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2FCargo.toml?ref=0b6c116a84fb1dbb60b5870291f5d7df808c280d", "patch": "@@ -13,6 +13,7 @@ log = \"0.4\"\n unicode-security = \"0.0.2\"\n rustc = { path = \"../librustc\" }\n rustc_errors = { path = \"../librustc_errors\" }\n+rustc_error_codes = { path = \"../librustc_error_codes\" }\n rustc_hir = { path = \"../librustc_hir\" }\n rustc_target = { path = \"../librustc_target\" }\n syntax = { path = \"../libsyntax\" }"}, {"sha": "fb11b6771e9caceec027973e4b905751b3330c98", "filename": "src/librustc_lint/array_into_iter.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0b6c116a84fb1dbb60b5870291f5d7df808c280d/src%2Flibrustc_lint%2Farray_into_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b6c116a84fb1dbb60b5870291f5d7df808c280d/src%2Flibrustc_lint%2Farray_into_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Farray_into_iter.rs?ref=0b6c116a84fb1dbb60b5870291f5d7df808c280d", "patch": "@@ -1,8 +1,9 @@\n-use rustc::lint::{FutureIncompatibleInfo, LateContext, LateLintPass, LintContext};\n+use crate::{LateContext, LateLintPass, LintContext};\n use rustc::ty;\n use rustc::ty::adjustment::{Adjust, Adjustment};\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n+use rustc_session::lint::FutureIncompatibleInfo;\n use rustc_span::symbol::sym;\n \n declare_lint! {"}, {"sha": "15a8332a28492e1f432062f52c31d1268fdb8ed2", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0b6c116a84fb1dbb60b5870291f5d7df808c280d/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b6c116a84fb1dbb60b5870291f5d7df808c280d/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=0b6c116a84fb1dbb60b5870291f5d7df808c280d", "patch": "@@ -21,8 +21,8 @@\n //! If you define a new `LateLintPass`, you will also need to add it to the\n //! `late_lint_methods!` invocation in `lib.rs`.\n \n+use crate::{EarlyContext, EarlyLintPass, LateContext, LateLintPass, LintContext};\n use rustc::hir::map::Map;\n-use rustc::lint::{self, EarlyContext, EarlyLintPass, LateContext, LateLintPass, LintContext};\n use rustc::traits::misc::can_type_implement_copy;\n use rustc::ty::{self, layout::VariantIdx, Ty, TyCtxt};\n use rustc_data_structures::fx::FxHashSet;\n@@ -51,7 +51,7 @@ use log::debug;\n use std::fmt::Write;\n \n // hardwired lints from librustc\n-pub use lint::builtin::*;\n+pub use rustc_session::lint::builtin::*;\n \n declare_lint! {\n     WHILE_TRUE,"}, {"sha": "2b514c301f2a3890a6765c845e7f5950d104313a", "filename": "src/librustc_lint/context.rs", "status": "renamed", "additions": 11, "deletions": 52, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/0b6c116a84fb1dbb60b5870291f5d7df808c280d/src%2Flibrustc_lint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b6c116a84fb1dbb60b5870291f5d7df808c280d/src%2Flibrustc_lint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fcontext.rs?ref=0b6c116a84fb1dbb60b5870291f5d7df808c280d", "patch": "@@ -16,22 +16,23 @@\n \n use self::TargetLint::*;\n \n-use crate::hir::map::{definitions::DisambiguatedDefPathData, DefPathData};\n-use crate::lint::levels::{LintLevelSets, LintLevelsBuilder};\n-use crate::lint::{EarlyLintPassObject, LateLintPassObject};\n-use crate::middle::privacy::AccessLevels;\n-use crate::middle::stability;\n-use crate::session::Session;\n-use crate::ty::layout::{LayoutError, LayoutOf, TyLayout};\n-use crate::ty::{self, print::Printer, subst::GenericArg, Ty, TyCtxt};\n+use crate::levels::LintLevelsBuilder;\n+use crate::passes::{EarlyLintPassObject, LateLintPassObject};\n+use rustc::hir::map::definitions::{DefPathData, DisambiguatedDefPathData};\n+use rustc::lint::add_elided_lifetime_in_path_suggestion;\n+use rustc::middle::privacy::AccessLevels;\n+use rustc::middle::stability;\n+use rustc::ty::layout::{LayoutError, LayoutOf, TyLayout};\n+use rustc::ty::{self, print::Printer, subst::GenericArg, Ty, TyCtxt};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sync;\n use rustc_error_codes::*;\n-use rustc_errors::{pluralize, struct_span_err, Applicability, DiagnosticBuilder};\n+use rustc_errors::{struct_span_err, Applicability, DiagnosticBuilder};\n use rustc_hir as hir;\n use rustc_hir::def_id::{CrateNum, DefId};\n use rustc_session::lint::BuiltinLintDiagnostics;\n use rustc_session::lint::{FutureIncompatibleInfo, Level, Lint, LintBuffer, LintId};\n+use rustc_session::Session;\n use rustc_span::{symbol::Symbol, MultiSpan, Span, DUMMY_SP};\n use syntax::ast;\n use syntax::util::lev_distance::find_best_match_for_name;\n@@ -467,48 +468,6 @@ impl LintPassObject for EarlyLintPassObject {}\n \n impl LintPassObject for LateLintPassObject {}\n \n-pub fn add_elided_lifetime_in_path_suggestion(\n-    sess: &Session,\n-    db: &mut DiagnosticBuilder<'_>,\n-    n: usize,\n-    path_span: Span,\n-    incl_angl_brckt: bool,\n-    insertion_span: Span,\n-    anon_lts: String,\n-) {\n-    let (replace_span, suggestion) = if incl_angl_brckt {\n-        (insertion_span, anon_lts)\n-    } else {\n-        // When possible, prefer a suggestion that replaces the whole\n-        // `Path<T>` expression with `Path<'_, T>`, rather than inserting `'_, `\n-        // at a point (which makes for an ugly/confusing label)\n-        if let Ok(snippet) = sess.source_map().span_to_snippet(path_span) {\n-            // But our spans can get out of whack due to macros; if the place we think\n-            // we want to insert `'_` isn't even within the path expression's span, we\n-            // should bail out of making any suggestion rather than panicking on a\n-            // subtract-with-overflow or string-slice-out-out-bounds (!)\n-            // FIXME: can we do better?\n-            if insertion_span.lo().0 < path_span.lo().0 {\n-                return;\n-            }\n-            let insertion_index = (insertion_span.lo().0 - path_span.lo().0) as usize;\n-            if insertion_index > snippet.len() {\n-                return;\n-            }\n-            let (before, after) = snippet.split_at(insertion_index);\n-            (path_span, format!(\"{}{}{}\", before, anon_lts, after))\n-        } else {\n-            (insertion_span, anon_lts)\n-        }\n-    };\n-    db.span_suggestion(\n-        replace_span,\n-        &format!(\"indicate the anonymous lifetime{}\", pluralize!(n)),\n-        suggestion,\n-        Applicability::MachineApplicable,\n-    );\n-}\n-\n pub trait LintContext: Sized {\n     type PassObject: LintPassObject;\n \n@@ -674,7 +633,7 @@ impl<'a> EarlyContext<'a> {\n             sess,\n             krate,\n             lint_store,\n-            builder: LintLevelSets::builder(sess, warn_about_weird_lints, lint_store),\n+            builder: LintLevelsBuilder::new(sess, warn_about_weird_lints, lint_store),\n             buffered,\n         }\n     }", "previous_filename": "src/librustc/lint/context.rs"}, {"sha": "490114b2d4d2a037d84793042d36efe05dd5df80", "filename": "src/librustc_lint/early.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0b6c116a84fb1dbb60b5870291f5d7df808c280d/src%2Flibrustc_lint%2Fearly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b6c116a84fb1dbb60b5870291f5d7df808c280d/src%2Flibrustc_lint%2Fearly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fearly.rs?ref=0b6c116a84fb1dbb60b5870291f5d7df808c280d", "patch": "@@ -14,10 +14,9 @@\n //! upon. As the ast is traversed, this keeps track of the current lint level\n //! for all lint attributes.\n \n-use rustc::lint::{EarlyContext, LintStore};\n-use rustc::lint::{EarlyLintPass, EarlyLintPassObject};\n-use rustc::lint::{LintContext, LintPass};\n-use rustc_session::lint::LintBuffer;\n+use crate::context::{EarlyContext, LintContext, LintStore};\n+use crate::passes::{EarlyLintPass, EarlyLintPassObject};\n+use rustc_session::lint::{LintBuffer, LintPass};\n use rustc_session::Session;\n use rustc_span::Span;\n use syntax::ast;\n@@ -291,7 +290,7 @@ macro_rules! early_lint_pass_impl {\n     )\n }\n \n-early_lint_methods!(early_lint_pass_impl, []);\n+crate::early_lint_methods!(early_lint_pass_impl, []);\n \n fn early_lint_crate<T: EarlyLintPass>(\n     sess: &Session,"}, {"sha": "2f8393bd906c0e0f9bdfea87072deec9dbe30ecb", "filename": "src/librustc_lint/internal.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0b6c116a84fb1dbb60b5870291f5d7df808c280d/src%2Flibrustc_lint%2Finternal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b6c116a84fb1dbb60b5870291f5d7df808c280d/src%2Flibrustc_lint%2Finternal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Finternal.rs?ref=0b6c116a84fb1dbb60b5870291f5d7df808c280d", "patch": "@@ -1,7 +1,7 @@\n //! Some lints that are only useful in the compiler or crates that use compiler internals, such as\n //! Clippy.\n \n-use crate::lint::{EarlyContext, EarlyLintPass, LateContext, LateLintPass, LintContext};\n+use crate::{EarlyContext, EarlyLintPass, LateContext, LateLintPass, LintContext};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_errors::Applicability;\n use rustc_hir::{GenericArg, HirId, MutTy, Mutability, Path, PathSegment, QPath, Ty, TyKind};", "previous_filename": "src/librustc/lint/internal.rs"}, {"sha": "30a3788377508b106ff02a8f817ab6d7dc2d56c5", "filename": "src/librustc_lint/late.rs", "status": "modified", "additions": 15, "deletions": 8, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/0b6c116a84fb1dbb60b5870291f5d7df808c280d/src%2Flibrustc_lint%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b6c116a84fb1dbb60b5870291f5d7df808c280d/src%2Flibrustc_lint%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flate.rs?ref=0b6c116a84fb1dbb60b5870291f5d7df808c280d", "patch": "@@ -14,9 +14,8 @@\n //! upon. As the ast is traversed, this keeps track of the current lint level\n //! for all lint attributes.\n \n+use crate::{passes::LateLintPassObject, LateContext, LateLintPass, LintStore};\n use rustc::hir::map::Map;\n-use rustc::lint::LateContext;\n-use rustc::lint::{LateLintPass, LateLintPassObject};\n use rustc::ty::{self, TyCtxt};\n use rustc_data_structures::sync::{join, par_iter, ParallelIterator};\n use rustc_hir as hir;\n@@ -29,8 +28,16 @@ use syntax::ast;\n use syntax::walk_list;\n \n use log::debug;\n+use std::any::Any;\n use std::slice;\n \n+/// Extract the `LintStore` from the query context.\n+/// This function exists because we've erased `LintStore` as `dyn Any` in the context.\n+crate fn unerased_lint_store<'tcx>(tcx: TyCtxt<'tcx>) -> &'tcx LintStore {\n+    let store: &dyn Any = &*tcx.lint_store;\n+    store.downcast_ref().unwrap()\n+}\n+\n macro_rules! lint_callback { ($cx:expr, $f:ident, $($args:expr),*) => ({\n     $cx.pass.$f(&$cx.context, $($args),*);\n }) }\n@@ -342,7 +349,7 @@ macro_rules! late_lint_pass_impl {\n     )\n }\n \n-late_lint_methods!(late_lint_pass_impl, [], ['tcx]);\n+crate::late_lint_methods!(late_lint_pass_impl, [], ['tcx]);\n \n fn late_lint_mod_pass<'tcx, T: for<'a> LateLintPass<'a, 'tcx>>(\n     tcx: TyCtxt<'tcx>,\n@@ -356,7 +363,7 @@ fn late_lint_mod_pass<'tcx, T: for<'a> LateLintPass<'a, 'tcx>>(\n         tables: &ty::TypeckTables::empty(None),\n         param_env: ty::ParamEnv::empty(),\n         access_levels,\n-        lint_store: &tcx.lint_store,\n+        lint_store: unerased_lint_store(tcx),\n         last_node_with_lint_attrs: tcx.hir().as_local_hir_id(module_def_id).unwrap(),\n         generics: None,\n         only_module: true,\n@@ -386,7 +393,7 @@ pub fn late_lint_mod<'tcx, T: for<'a> LateLintPass<'a, 'tcx>>(\n     late_lint_mod_pass(tcx, module_def_id, builtin_lints);\n \n     let mut passes: Vec<_> =\n-        tcx.lint_store.late_module_passes.iter().map(|pass| (pass)()).collect();\n+        unerased_lint_store(tcx).late_module_passes.iter().map(|pass| (pass)()).collect();\n \n     if !passes.is_empty() {\n         late_lint_mod_pass(tcx, module_def_id, LateLintPassObjects { lints: &mut passes[..] });\n@@ -403,7 +410,7 @@ fn late_lint_pass_crate<'tcx, T: for<'a> LateLintPass<'a, 'tcx>>(tcx: TyCtxt<'tc\n         tables: &ty::TypeckTables::empty(None),\n         param_env: ty::ParamEnv::empty(),\n         access_levels,\n-        lint_store: &tcx.lint_store,\n+        lint_store: unerased_lint_store(tcx),\n         last_node_with_lint_attrs: hir::CRATE_HIR_ID,\n         generics: None,\n         only_module: false,\n@@ -424,7 +431,7 @@ fn late_lint_pass_crate<'tcx, T: for<'a> LateLintPass<'a, 'tcx>>(tcx: TyCtxt<'tc\n }\n \n fn late_lint_crate<'tcx, T: for<'a> LateLintPass<'a, 'tcx>>(tcx: TyCtxt<'tcx>, builtin_lints: T) {\n-    let mut passes = tcx.lint_store.late_passes.iter().map(|p| (p)()).collect::<Vec<_>>();\n+    let mut passes = unerased_lint_store(tcx).late_passes.iter().map(|p| (p)()).collect::<Vec<_>>();\n \n     if !tcx.sess.opts.debugging_opts.no_interleave_lints {\n         if !passes.is_empty() {\n@@ -443,7 +450,7 @@ fn late_lint_crate<'tcx, T: for<'a> LateLintPass<'a, 'tcx>>(tcx: TyCtxt<'tcx>, b\n         }\n \n         let mut passes: Vec<_> =\n-            tcx.lint_store.late_module_passes.iter().map(|pass| (pass)()).collect();\n+            unerased_lint_store(tcx).late_module_passes.iter().map(|pass| (pass)()).collect();\n \n         for pass in &mut passes {\n             tcx.sess"}, {"sha": "bbc3e57f5dd01a38683395b1906e4b88a769c5ba", "filename": "src/librustc_lint/levels.rs", "status": "modified", "additions": 391, "deletions": 8, "changes": 399, "blob_url": "https://github.com/rust-lang/rust/blob/0b6c116a84fb1dbb60b5870291f5d7df808c280d/src%2Flibrustc_lint%2Flevels.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b6c116a84fb1dbb60b5870291f5d7df808c280d/src%2Flibrustc_lint%2Flevels.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flevels.rs?ref=0b6c116a84fb1dbb60b5870291f5d7df808c280d", "patch": "@@ -1,22 +1,33 @@\n+use crate::context::{CheckLintNameResult, LintStore};\n+use crate::late::unerased_lint_store;\n use rustc::hir::map::Map;\n-use rustc::lint::{LintLevelMap, LintLevelSets, LintLevelsBuilder, LintStore};\n+use rustc::lint::struct_lint_level;\n+use rustc::lint::{LintLevelMap, LintLevelSets, LintSet, LintSource};\n use rustc::ty::query::Providers;\n use rustc::ty::TyCtxt;\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_error_codes::*;\n+use rustc_errors::{struct_span_err, Applicability, DiagnosticBuilder};\n use rustc_hir as hir;\n use rustc_hir::def_id::{CrateNum, LOCAL_CRATE};\n+use rustc_hir::hir_id::HirId;\n use rustc_hir::intravisit;\n+use rustc_session::lint::{builtin, Level, Lint};\n+use rustc_session::Session;\n+use rustc_span::{sym, MultiSpan, Symbol};\n use syntax::ast;\n+use syntax::attr;\n+use syntax::print::pprust;\n+use syntax::sess::feature_err;\n+use syntax::unwrap_or;\n \n-pub use rustc_session::lint::{FutureIncompatibleInfo, Level, Lint, LintId};\n+use std::cmp;\n \n fn lint_levels(tcx: TyCtxt<'_>, cnum: CrateNum) -> &LintLevelMap {\n     assert_eq!(cnum, LOCAL_CRATE);\n-    let store = &tcx.lint_store;\n-    let mut builder = LintLevelMapBuilder {\n-        levels: LintLevelSets::builder(tcx.sess, false, &store),\n-        tcx: tcx,\n-        store: store,\n-    };\n+    let store = unerased_lint_store(tcx);\n+    let levels = LintLevelsBuilder::new(tcx.sess, false, &store);\n+    let mut builder = LintLevelMapBuilder { levels, tcx, store };\n     let krate = tcx.hir().krate();\n \n     let push = builder.levels.push(&krate.attrs, &store);\n@@ -30,6 +41,378 @@ fn lint_levels(tcx: TyCtxt<'_>, cnum: CrateNum) -> &LintLevelMap {\n     tcx.arena.alloc(builder.levels.build_map())\n }\n \n+pub struct LintLevelsBuilder<'a> {\n+    sess: &'a Session,\n+    sets: LintLevelSets,\n+    id_to_set: FxHashMap<HirId, u32>,\n+    cur: u32,\n+    warn_about_weird_lints: bool,\n+}\n+\n+pub struct BuilderPush {\n+    prev: u32,\n+    pub changed: bool,\n+}\n+\n+impl<'a> LintLevelsBuilder<'a> {\n+    pub fn new(sess: &'a Session, warn_about_weird_lints: bool, store: &LintStore) -> Self {\n+        let mut builder = LintLevelsBuilder {\n+            sess,\n+            sets: LintLevelSets::new(),\n+            cur: 0,\n+            id_to_set: Default::default(),\n+            warn_about_weird_lints,\n+        };\n+        builder.process_command_line(sess, store);\n+        assert_eq!(builder.sets.list.len(), 1);\n+        builder\n+    }\n+\n+    fn process_command_line(&mut self, sess: &Session, store: &LintStore) {\n+        let mut specs = FxHashMap::default();\n+        self.sets.lint_cap = sess.opts.lint_cap.unwrap_or(Level::Forbid);\n+\n+        for &(ref lint_name, level) in &sess.opts.lint_opts {\n+            store.check_lint_name_cmdline(sess, &lint_name, level);\n+\n+            // If the cap is less than this specified level, e.g., if we've got\n+            // `--cap-lints allow` but we've also got `-D foo` then we ignore\n+            // this specification as the lint cap will set it to allow anyway.\n+            let level = cmp::min(level, self.sets.lint_cap);\n+\n+            let lint_flag_val = Symbol::intern(lint_name);\n+            let ids = match store.find_lints(&lint_name) {\n+                Ok(ids) => ids,\n+                Err(_) => continue, // errors handled in check_lint_name_cmdline above\n+            };\n+            for id in ids {\n+                let src = LintSource::CommandLine(lint_flag_val);\n+                specs.insert(id, (level, src));\n+            }\n+        }\n+\n+        self.sets.list.push(LintSet::CommandLine { specs });\n+    }\n+\n+    /// Pushes a list of AST lint attributes onto this context.\n+    ///\n+    /// This function will return a `BuilderPush` object which should be passed\n+    /// to `pop` when this scope for the attributes provided is exited.\n+    ///\n+    /// This function will perform a number of tasks:\n+    ///\n+    /// * It'll validate all lint-related attributes in `attrs`\n+    /// * It'll mark all lint-related attributes as used\n+    /// * Lint levels will be updated based on the attributes provided\n+    /// * Lint attributes are validated, e.g., a #[forbid] can't be switched to\n+    ///   #[allow]\n+    ///\n+    /// Don't forget to call `pop`!\n+    pub fn push(&mut self, attrs: &[ast::Attribute], store: &LintStore) -> BuilderPush {\n+        let mut specs = FxHashMap::default();\n+        let sess = self.sess;\n+        let bad_attr = |span| struct_span_err!(sess, span, E0452, \"malformed lint attribute input\");\n+        for attr in attrs {\n+            let level = match Level::from_symbol(attr.name_or_empty()) {\n+                None => continue,\n+                Some(lvl) => lvl,\n+            };\n+\n+            let meta = unwrap_or!(attr.meta(), continue);\n+            attr::mark_used(attr);\n+\n+            let mut metas = unwrap_or!(meta.meta_item_list(), continue);\n+\n+            if metas.is_empty() {\n+                // FIXME (#55112): issue unused-attributes lint for `#[level()]`\n+                continue;\n+            }\n+\n+            // Before processing the lint names, look for a reason (RFC 2383)\n+            // at the end.\n+            let mut reason = None;\n+            let tail_li = &metas[metas.len() - 1];\n+            if let Some(item) = tail_li.meta_item() {\n+                match item.kind {\n+                    ast::MetaItemKind::Word => {} // actual lint names handled later\n+                    ast::MetaItemKind::NameValue(ref name_value) => {\n+                        if item.path == sym::reason {\n+                            // found reason, reslice meta list to exclude it\n+                            metas = &metas[0..metas.len() - 1];\n+                            // FIXME (#55112): issue unused-attributes lint if we thereby\n+                            // don't have any lint names (`#[level(reason = \"foo\")]`)\n+                            if let ast::LitKind::Str(rationale, _) = name_value.kind {\n+                                if !self.sess.features_untracked().lint_reasons {\n+                                    feature_err(\n+                                        &self.sess.parse_sess,\n+                                        sym::lint_reasons,\n+                                        item.span,\n+                                        \"lint reasons are experimental\",\n+                                    )\n+                                    .emit();\n+                                }\n+                                reason = Some(rationale);\n+                            } else {\n+                                bad_attr(name_value.span)\n+                                    .span_label(name_value.span, \"reason must be a string literal\")\n+                                    .emit();\n+                            }\n+                        } else {\n+                            bad_attr(item.span)\n+                                .span_label(item.span, \"bad attribute argument\")\n+                                .emit();\n+                        }\n+                    }\n+                    ast::MetaItemKind::List(_) => {\n+                        bad_attr(item.span).span_label(item.span, \"bad attribute argument\").emit();\n+                    }\n+                }\n+            }\n+\n+            for li in metas {\n+                let meta_item = match li.meta_item() {\n+                    Some(meta_item) if meta_item.is_word() => meta_item,\n+                    _ => {\n+                        let sp = li.span();\n+                        let mut err = bad_attr(sp);\n+                        let mut add_label = true;\n+                        if let Some(item) = li.meta_item() {\n+                            if let ast::MetaItemKind::NameValue(_) = item.kind {\n+                                if item.path == sym::reason {\n+                                    err.span_label(sp, \"reason in lint attribute must come last\");\n+                                    add_label = false;\n+                                }\n+                            }\n+                        }\n+                        if add_label {\n+                            err.span_label(sp, \"bad attribute argument\");\n+                        }\n+                        err.emit();\n+                        continue;\n+                    }\n+                };\n+                let tool_name = if meta_item.path.segments.len() > 1 {\n+                    let tool_ident = meta_item.path.segments[0].ident;\n+                    if !attr::is_known_lint_tool(tool_ident) {\n+                        struct_span_err!(\n+                            sess,\n+                            tool_ident.span,\n+                            E0710,\n+                            \"an unknown tool name found in scoped lint: `{}`\",\n+                            pprust::path_to_string(&meta_item.path),\n+                        )\n+                        .emit();\n+                        continue;\n+                    }\n+\n+                    Some(tool_ident.name)\n+                } else {\n+                    None\n+                };\n+                let name = meta_item.path.segments.last().expect(\"empty lint name\").ident.name;\n+                match store.check_lint_name(&name.as_str(), tool_name) {\n+                    CheckLintNameResult::Ok(ids) => {\n+                        let src = LintSource::Node(name, li.span(), reason);\n+                        for id in ids {\n+                            specs.insert(*id, (level, src));\n+                        }\n+                    }\n+\n+                    CheckLintNameResult::Tool(result) => {\n+                        match result {\n+                            Ok(ids) => {\n+                                let complete_name = &format!(\"{}::{}\", tool_name.unwrap(), name);\n+                                let src = LintSource::Node(\n+                                    Symbol::intern(complete_name),\n+                                    li.span(),\n+                                    reason,\n+                                );\n+                                for id in ids {\n+                                    specs.insert(*id, (level, src));\n+                                }\n+                            }\n+                            Err((Some(ids), new_lint_name)) => {\n+                                let lint = builtin::RENAMED_AND_REMOVED_LINTS;\n+                                let (lvl, src) =\n+                                    self.sets.get_lint_level(lint, self.cur, Some(&specs), &sess);\n+                                let msg = format!(\n+                                    \"lint name `{}` is deprecated \\\n+                                     and may not have an effect in the future. \\\n+                                     Also `cfg_attr(cargo-clippy)` won't be necessary anymore\",\n+                                    name\n+                                );\n+                                struct_lint_level(\n+                                    self.sess,\n+                                    lint,\n+                                    lvl,\n+                                    src,\n+                                    Some(li.span().into()),\n+                                    &msg,\n+                                )\n+                                .span_suggestion(\n+                                    li.span(),\n+                                    \"change it to\",\n+                                    new_lint_name.to_string(),\n+                                    Applicability::MachineApplicable,\n+                                )\n+                                .emit();\n+\n+                                let src = LintSource::Node(\n+                                    Symbol::intern(&new_lint_name),\n+                                    li.span(),\n+                                    reason,\n+                                );\n+                                for id in ids {\n+                                    specs.insert(*id, (level, src));\n+                                }\n+                            }\n+                            Err((None, _)) => {\n+                                // If Tool(Err(None, _)) is returned, then either the lint does not\n+                                // exist in the tool or the code was not compiled with the tool and\n+                                // therefore the lint was never added to the `LintStore`. To detect\n+                                // this is the responsibility of the lint tool.\n+                            }\n+                        }\n+                    }\n+\n+                    _ if !self.warn_about_weird_lints => {}\n+\n+                    CheckLintNameResult::Warning(msg, renamed) => {\n+                        let lint = builtin::RENAMED_AND_REMOVED_LINTS;\n+                        let (level, src) =\n+                            self.sets.get_lint_level(lint, self.cur, Some(&specs), &sess);\n+                        let mut err = struct_lint_level(\n+                            self.sess,\n+                            lint,\n+                            level,\n+                            src,\n+                            Some(li.span().into()),\n+                            &msg,\n+                        );\n+                        if let Some(new_name) = renamed {\n+                            err.span_suggestion(\n+                                li.span(),\n+                                \"use the new name\",\n+                                new_name,\n+                                Applicability::MachineApplicable,\n+                            );\n+                        }\n+                        err.emit();\n+                    }\n+                    CheckLintNameResult::NoLint(suggestion) => {\n+                        let lint = builtin::UNKNOWN_LINTS;\n+                        let (level, src) =\n+                            self.sets.get_lint_level(lint, self.cur, Some(&specs), self.sess);\n+                        let msg = format!(\"unknown lint: `{}`\", name);\n+                        let mut db = struct_lint_level(\n+                            self.sess,\n+                            lint,\n+                            level,\n+                            src,\n+                            Some(li.span().into()),\n+                            &msg,\n+                        );\n+\n+                        if let Some(suggestion) = suggestion {\n+                            db.span_suggestion(\n+                                li.span(),\n+                                \"did you mean\",\n+                                suggestion.to_string(),\n+                                Applicability::MachineApplicable,\n+                            );\n+                        }\n+\n+                        db.emit();\n+                    }\n+                }\n+            }\n+        }\n+\n+        for (id, &(level, ref src)) in specs.iter() {\n+            if level == Level::Forbid {\n+                continue;\n+            }\n+            let forbid_src = match self.sets.get_lint_id_level(*id, self.cur, None) {\n+                (Some(Level::Forbid), src) => src,\n+                _ => continue,\n+            };\n+            let forbidden_lint_name = match forbid_src {\n+                LintSource::Default => id.to_string(),\n+                LintSource::Node(name, _, _) => name.to_string(),\n+                LintSource::CommandLine(name) => name.to_string(),\n+            };\n+            let (lint_attr_name, lint_attr_span) = match *src {\n+                LintSource::Node(name, span, _) => (name, span),\n+                _ => continue,\n+            };\n+            let mut diag_builder = struct_span_err!(\n+                self.sess,\n+                lint_attr_span,\n+                E0453,\n+                \"{}({}) overruled by outer forbid({})\",\n+                level.as_str(),\n+                lint_attr_name,\n+                forbidden_lint_name\n+            );\n+            diag_builder.span_label(lint_attr_span, \"overruled by previous forbid\");\n+            match forbid_src {\n+                LintSource::Default => {}\n+                LintSource::Node(_, forbid_source_span, reason) => {\n+                    diag_builder.span_label(forbid_source_span, \"`forbid` level set here\");\n+                    if let Some(rationale) = reason {\n+                        diag_builder.note(&rationale.as_str());\n+                    }\n+                }\n+                LintSource::CommandLine(_) => {\n+                    diag_builder.note(\"`forbid` lint level was set on command line\");\n+                }\n+            }\n+            diag_builder.emit();\n+            // don't set a separate error for every lint in the group\n+            break;\n+        }\n+\n+        let prev = self.cur;\n+        if specs.len() > 0 {\n+            self.cur = self.sets.list.len() as u32;\n+            self.sets.list.push(LintSet::Node { specs: specs, parent: prev });\n+        }\n+\n+        BuilderPush { prev: prev, changed: prev != self.cur }\n+    }\n+\n+    /// Called after `push` when the scope of a set of attributes are exited.\n+    pub fn pop(&mut self, push: BuilderPush) {\n+        self.cur = push.prev;\n+    }\n+\n+    /// Used to emit a lint-related diagnostic based on the current state of\n+    /// this lint context.\n+    pub fn struct_lint(\n+        &self,\n+        lint: &'static Lint,\n+        span: Option<MultiSpan>,\n+        msg: &str,\n+    ) -> DiagnosticBuilder<'a> {\n+        let (level, src) = self.sets.get_lint_level(lint, self.cur, None, self.sess);\n+        struct_lint_level(self.sess, lint, level, src, span, msg)\n+    }\n+\n+    /// Registers the ID provided with the current set of lints stored in\n+    /// this context.\n+    pub fn register_id(&mut self, id: HirId) {\n+        self.id_to_set.insert(id, self.cur);\n+    }\n+\n+    pub fn build(self) -> LintLevelSets {\n+        self.sets\n+    }\n+\n+    pub fn build_map(self) -> LintLevelMap {\n+        LintLevelMap { sets: self.sets, id_to_set: self.id_to_set }\n+    }\n+}\n+\n struct LintLevelMapBuilder<'a, 'tcx> {\n     levels: LintLevelsBuilder<'tcx>,\n     tcx: TyCtxt<'tcx>,"}, {"sha": "6e3382dee9aae21c91c61c3d03c819d760ba82b0", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 41, "deletions": 21, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/0b6c116a84fb1dbb60b5870291f5d7df808c280d/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b6c116a84fb1dbb60b5870291f5d7df808c280d/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=0b6c116a84fb1dbb60b5870291f5d7df808c280d", "patch": "@@ -1,9 +1,25 @@\n-//! # Lints in the Rust compiler\n+//! Lints, aka compiler warnings.\n //!\n-//! This currently only contains the definitions and implementations\n-//! of most of the lints that `rustc` supports directly, it does not\n-//! contain the infrastructure for defining/registering lints. That is\n-//! available in `rustc::lint` and `rustc_driver::plugin` respectively.\n+//! A 'lint' check is a kind of miscellaneous constraint that a user _might_\n+//! want to enforce, but might reasonably want to permit as well, on a\n+//! module-by-module basis. They contrast with static constraints enforced by\n+//! other phases of the compiler, which are generally required to hold in order\n+//! to compile the program at all.\n+//!\n+//! Most lints can be written as `LintPass` instances. These run after\n+//! all other analyses. The `LintPass`es built into rustc are defined\n+//! within `rustc_session::lint::builtin`,\n+//! which has further comments on how to add such a lint.\n+//! rustc can also load user-defined lint plugins via the plugin mechanism.\n+//!\n+//! Some of rustc's lints are defined elsewhere in the compiler and work by\n+//! calling `add_lint()` on the overall `Session` object. This works when\n+//! it happens before the main lint pass, which emits the lints stored by\n+//! `add_lint()`. To emit lints after the main lint pass (from codegen, for\n+//! example) requires more effort. See `emit_lint` and `GatherNodeLevels`\n+//! in `context.rs`.\n+//!\n+//! Some code also exists in `rustc_session::lint`, `rustc::lint`.\n //!\n //! ## Note\n //!\n@@ -14,6 +30,8 @@\n #![feature(bool_to_option)]\n #![feature(box_patterns)]\n #![feature(box_syntax)]\n+#![feature(crate_visibility_modifier)]\n+#![feature(never_type)]\n #![feature(nll)]\n #![recursion_limit = \"256\"]\n \n@@ -24,45 +42,47 @@ extern crate rustc_session;\n \n mod array_into_iter;\n pub mod builtin;\n+mod context;\n mod early;\n+mod internal;\n mod late;\n mod levels;\n mod non_ascii_idents;\n mod nonstandard_style;\n+mod passes;\n mod redundant_semicolon;\n mod types;\n mod unused;\n \n-use rustc::lint;\n-use rustc::lint::builtin::{\n-    BARE_TRAIT_OBJECTS, ELIDED_LIFETIMES_IN_PATHS, EXPLICIT_OUTLIVES_REQUIREMENTS,\n-    INTRA_DOC_LINK_RESOLUTION_FAILURE, MISSING_DOC_CODE_EXAMPLES, PRIVATE_DOC_TESTS,\n-};\n-use rustc::lint::{EarlyContext, EarlyLintPass, LateContext, LateLintPass};\n use rustc::ty::query::Providers;\n use rustc::ty::TyCtxt;\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n-use rustc_session::lint::{LintArray, LintPass};\n-\n+use rustc_session::lint::builtin::{\n+    BARE_TRAIT_OBJECTS, ELIDED_LIFETIMES_IN_PATHS, EXPLICIT_OUTLIVES_REQUIREMENTS,\n+    INTRA_DOC_LINK_RESOLUTION_FAILURE, MISSING_DOC_CODE_EXAMPLES, PRIVATE_DOC_TESTS,\n+};\n use rustc_span::Span;\n use syntax::ast;\n \n-use lint::LintId;\n-\n use array_into_iter::ArrayIntoIter;\n use builtin::*;\n+use internal::*;\n use non_ascii_idents::*;\n use nonstandard_style::*;\n use redundant_semicolon::*;\n-use rustc::lint::internal::*;\n use types::*;\n use unused::*;\n \n-/// Useful for other parts of the compiler.\n+/// Useful for other parts of the compiler / Clippy.\n pub use builtin::SoftLints;\n+pub use context::{EarlyContext, LateContext, LintContext, LintStore};\n pub use early::check_ast_crate;\n pub use late::check_crate;\n+pub use passes::{EarlyLintPass, LateLintPass};\n+pub use rustc_session::lint::Level::{self, *};\n+pub use rustc_session::lint::{BufferedEarlyLint, FutureIncompatibleInfo, Lint, LintId};\n+pub use rustc_session::lint::{LintArray, LintPass};\n \n pub fn provide(providers: &mut Providers<'_>) {\n     levels::provide(providers);\n@@ -179,8 +199,8 @@ late_lint_passes!(declare_combined_late_pass, [pub BuiltinCombinedLateLintPass])\n \n late_lint_mod_passes!(declare_combined_late_pass, [BuiltinCombinedModuleLateLintPass]);\n \n-pub fn new_lint_store(no_interleave_lints: bool, internal_lints: bool) -> lint::LintStore {\n-    let mut lint_store = lint::LintStore::new();\n+pub fn new_lint_store(no_interleave_lints: bool, internal_lints: bool) -> LintStore {\n+    let mut lint_store = LintStore::new();\n \n     register_builtins(&mut lint_store, no_interleave_lints);\n     if internal_lints {\n@@ -193,7 +213,7 @@ pub fn new_lint_store(no_interleave_lints: bool, internal_lints: bool) -> lint::\n /// Tell the `LintStore` about all the built-in lints (the ones\n /// defined in this crate and the ones defined in\n /// `rustc::lint::builtin`).\n-fn register_builtins(store: &mut lint::LintStore, no_interleave_lints: bool) {\n+fn register_builtins(store: &mut LintStore, no_interleave_lints: bool) {\n     macro_rules! add_lint_group {\n         ($name:expr, $($lint:ident),*) => (\n             store.register_group(false, $name, None, vec![$(LintId::of($lint)),*]);\n@@ -390,7 +410,7 @@ fn register_builtins(store: &mut lint::LintStore, no_interleave_lints: bool) {\n     store.register_removed(\"plugin_as_library\", \"plugins have been deprecated and retired\");\n }\n \n-fn register_internals(store: &mut lint::LintStore) {\n+fn register_internals(store: &mut LintStore) {\n     store.register_lints(&DefaultHashTypes::get_lints());\n     store.register_early_pass(|| box DefaultHashTypes::new());\n     store.register_lints(&LintPassImpl::get_lints());"}, {"sha": "3c85a1b31b2445e77e37a7533d11529c64be8718", "filename": "src/librustc_lint/non_ascii_idents.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0b6c116a84fb1dbb60b5870291f5d7df808c280d/src%2Flibrustc_lint%2Fnon_ascii_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b6c116a84fb1dbb60b5870291f5d7df808c280d/src%2Flibrustc_lint%2Fnon_ascii_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fnon_ascii_idents.rs?ref=0b6c116a84fb1dbb60b5870291f5d7df808c280d", "patch": "@@ -1,4 +1,4 @@\n-use rustc::lint::{EarlyContext, EarlyLintPass, LintContext};\n+use crate::{EarlyContext, EarlyLintPass, LintContext};\n use syntax::ast;\n \n declare_lint! {"}, {"sha": "a2b7884241ff7b9bbc4600aa68b64a47043b3be1", "filename": "src/librustc_lint/nonstandard_style.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0b6c116a84fb1dbb60b5870291f5d7df808c280d/src%2Flibrustc_lint%2Fnonstandard_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b6c116a84fb1dbb60b5870291f5d7df808c280d/src%2Flibrustc_lint%2Fnonstandard_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fnonstandard_style.rs?ref=0b6c116a84fb1dbb60b5870291f5d7df808c280d", "patch": "@@ -1,4 +1,4 @@\n-use rustc::lint::{EarlyContext, EarlyLintPass, LateContext, LateLintPass, LintContext};\n+use crate::{EarlyContext, EarlyLintPass, LateContext, LateLintPass, LintContext};\n use rustc::ty;\n use rustc_errors::Applicability;\n use rustc_hir as hir;"}, {"sha": "7e5d670767ad80de22d057a4efa63ba194456a2d", "filename": "src/librustc_lint/passes.rs", "status": "renamed", "additions": 4, "deletions": 224, "changes": 228, "blob_url": "https://github.com/rust-lang/rust/blob/0b6c116a84fb1dbb60b5870291f5d7df808c280d/src%2Flibrustc_lint%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b6c116a84fb1dbb60b5870291f5d7df808c280d/src%2Flibrustc_lint%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fpasses.rs?ref=0b6c116a84fb1dbb60b5870291f5d7df808c280d", "patch": "@@ -1,47 +1,12 @@\n-//! Lints, aka compiler warnings.\n-//!\n-//! A 'lint' check is a kind of miscellaneous constraint that a user _might_\n-//! want to enforce, but might reasonably want to permit as well, on a\n-//! module-by-module basis. They contrast with static constraints enforced by\n-//! other phases of the compiler, which are generally required to hold in order\n-//! to compile the program at all.\n-//!\n-//! Most lints can be written as `LintPass` instances. These run after\n-//! all other analyses. The `LintPass`es built into rustc are defined\n-//! within `builtin.rs`, which has further comments on how to add such a lint.\n-//! rustc can also load user-defined lint plugins via the plugin mechanism.\n-//!\n-//! Some of rustc's lints are defined elsewhere in the compiler and work by\n-//! calling `add_lint()` on the overall `Session` object. This works when\n-//! it happens before the main lint pass, which emits the lints stored by\n-//! `add_lint()`. To emit lints after the main lint pass (from codegen, for\n-//! example) requires more effort. See `emit_lint` and `GatherNodeLevels`\n-//! in `context.rs`.\n+use crate::context::{EarlyContext, LateContext};\n \n-pub use self::Level::*;\n-pub use self::LintSource::*;\n-\n-use crate::ty::TyCtxt;\n use rustc_data_structures::sync;\n-use rustc_errors::{DiagnosticBuilder, DiagnosticId};\n use rustc_hir as hir;\n use rustc_session::lint::builtin::HardwiredLints;\n-use rustc_session::{DiagnosticMessageId, Session};\n-use rustc_span::hygiene::MacroKind;\n-use rustc_span::source_map::{DesugaringKind, ExpnKind, MultiSpan};\n-use rustc_span::symbol::Symbol;\n+use rustc_session::lint::LintPass;\n use rustc_span::Span;\n use syntax::ast;\n \n-pub use crate::lint::context::{\n-    add_elided_lifetime_in_path_suggestion, CheckLintNameResult, EarlyContext, LateContext,\n-    LintContext, LintStore,\n-};\n-\n-pub use rustc_session::lint::builtin;\n-pub use rustc_session::lint::{BufferedEarlyLint, FutureIncompatibleInfo, Level, Lint, LintId};\n-pub use rustc_session::lint::{LintArray, LintPass};\n-\n #[macro_export]\n macro_rules! late_lint_methods {\n     ($macro:path, $args:tt, [$hir:tt]) => (\n@@ -176,6 +141,7 @@ macro_rules! declare_combined_late_lint_pass {\n             expand_combined_late_lint_pass_methods!([$($passes),*], $methods);\n         }\n \n+        #[allow(rustc::lint_pass_impl_without_macro)]\n         impl LintPass for $name {\n             fn name(&self) -> &'static str {\n                 panic!()\n@@ -303,6 +269,7 @@ macro_rules! declare_combined_early_lint_pass {\n             expand_combined_early_lint_pass_methods!([$($passes),*], $methods);\n         }\n \n+        #[allow(rustc::lint_pass_impl_without_macro)]\n         impl LintPass for $name {\n             fn name(&self) -> &'static str {\n                 panic!()\n@@ -315,190 +282,3 @@ macro_rules! declare_combined_early_lint_pass {\n pub type EarlyLintPassObject = Box<dyn EarlyLintPass + sync::Send + sync::Sync + 'static>;\n pub type LateLintPassObject =\n     Box<dyn for<'a, 'tcx> LateLintPass<'a, 'tcx> + sync::Send + sync::Sync + 'static>;\n-\n-/// How a lint level was set.\n-#[derive(Clone, Copy, PartialEq, Eq, HashStable)]\n-pub enum LintSource {\n-    /// Lint is at the default level as declared\n-    /// in rustc or a plugin.\n-    Default,\n-\n-    /// Lint level was set by an attribute.\n-    Node(ast::Name, Span, Option<Symbol> /* RFC 2383 reason */),\n-\n-    /// Lint level was set by a command-line flag.\n-    CommandLine(Symbol),\n-}\n-\n-pub type LevelSource = (Level, LintSource);\n-\n-mod context;\n-pub mod internal;\n-mod levels;\n-\n-pub use self::levels::{LintLevelMap, LintLevelSets, LintLevelsBuilder};\n-\n-pub fn struct_lint_level<'a>(\n-    sess: &'a Session,\n-    lint: &'static Lint,\n-    level: Level,\n-    src: LintSource,\n-    span: Option<MultiSpan>,\n-    msg: &str,\n-) -> DiagnosticBuilder<'a> {\n-    let mut err = match (level, span) {\n-        (Level::Allow, _) => return sess.diagnostic().struct_dummy(),\n-        (Level::Warn, Some(span)) => sess.struct_span_warn(span, msg),\n-        (Level::Warn, None) => sess.struct_warn(msg),\n-        (Level::Deny, Some(span)) | (Level::Forbid, Some(span)) => sess.struct_span_err(span, msg),\n-        (Level::Deny, None) | (Level::Forbid, None) => sess.struct_err(msg),\n-    };\n-\n-    // Check for future incompatibility lints and issue a stronger warning.\n-    let lint_id = LintId::of(lint);\n-    let future_incompatible = lint.future_incompatible;\n-\n-    // If this code originates in a foreign macro, aka something that this crate\n-    // did not itself author, then it's likely that there's nothing this crate\n-    // can do about it. We probably want to skip the lint entirely.\n-    if err.span.primary_spans().iter().any(|s| in_external_macro(sess, *s)) {\n-        // Any suggestions made here are likely to be incorrect, so anything we\n-        // emit shouldn't be automatically fixed by rustfix.\n-        err.allow_suggestions(false);\n-\n-        // If this is a future incompatible lint it'll become a hard error, so\n-        // we have to emit *something*. Also allow lints to whitelist themselves\n-        // on a case-by-case basis for emission in a foreign macro.\n-        if future_incompatible.is_none() && !lint.report_in_external_macro {\n-            err.cancel();\n-            // Don't continue further, since we don't want to have\n-            // `diag_span_note_once` called for a diagnostic that isn't emitted.\n-            return err;\n-        }\n-    }\n-\n-    let name = lint.name_lower();\n-    match src {\n-        LintSource::Default => {\n-            sess.diag_note_once(\n-                &mut err,\n-                DiagnosticMessageId::from(lint),\n-                &format!(\"`#[{}({})]` on by default\", level.as_str(), name),\n-            );\n-        }\n-        LintSource::CommandLine(lint_flag_val) => {\n-            let flag = match level {\n-                Level::Warn => \"-W\",\n-                Level::Deny => \"-D\",\n-                Level::Forbid => \"-F\",\n-                Level::Allow => panic!(),\n-            };\n-            let hyphen_case_lint_name = name.replace(\"_\", \"-\");\n-            if lint_flag_val.as_str() == name {\n-                sess.diag_note_once(\n-                    &mut err,\n-                    DiagnosticMessageId::from(lint),\n-                    &format!(\n-                        \"requested on the command line with `{} {}`\",\n-                        flag, hyphen_case_lint_name\n-                    ),\n-                );\n-            } else {\n-                let hyphen_case_flag_val = lint_flag_val.as_str().replace(\"_\", \"-\");\n-                sess.diag_note_once(\n-                    &mut err,\n-                    DiagnosticMessageId::from(lint),\n-                    &format!(\n-                        \"`{} {}` implied by `{} {}`\",\n-                        flag, hyphen_case_lint_name, flag, hyphen_case_flag_val\n-                    ),\n-                );\n-            }\n-        }\n-        LintSource::Node(lint_attr_name, src, reason) => {\n-            if let Some(rationale) = reason {\n-                err.note(&rationale.as_str());\n-            }\n-            sess.diag_span_note_once(\n-                &mut err,\n-                DiagnosticMessageId::from(lint),\n-                src,\n-                \"lint level defined here\",\n-            );\n-            if lint_attr_name.as_str() != name {\n-                let level_str = level.as_str();\n-                sess.diag_note_once(\n-                    &mut err,\n-                    DiagnosticMessageId::from(lint),\n-                    &format!(\n-                        \"`#[{}({})]` implied by `#[{}({})]`\",\n-                        level_str, name, level_str, lint_attr_name\n-                    ),\n-                );\n-            }\n-        }\n-    }\n-\n-    err.code(DiagnosticId::Lint(name));\n-\n-    if let Some(future_incompatible) = future_incompatible {\n-        const STANDARD_MESSAGE: &str = \"this was previously accepted by the compiler but is being phased out; \\\n-             it will become a hard error\";\n-\n-        let explanation = if lint_id == LintId::of(builtin::UNSTABLE_NAME_COLLISIONS) {\n-            \"once this method is added to the standard library, \\\n-             the ambiguity may cause an error or change in behavior!\"\n-                .to_owned()\n-        } else if lint_id == LintId::of(builtin::MUTABLE_BORROW_RESERVATION_CONFLICT) {\n-            \"this borrowing pattern was not meant to be accepted, \\\n-             and may become a hard error in the future\"\n-                .to_owned()\n-        } else if let Some(edition) = future_incompatible.edition {\n-            format!(\"{} in the {} edition!\", STANDARD_MESSAGE, edition)\n-        } else {\n-            format!(\"{} in a future release!\", STANDARD_MESSAGE)\n-        };\n-        let citation = format!(\"for more information, see {}\", future_incompatible.reference);\n-        err.warn(&explanation);\n-        err.note(&citation);\n-    }\n-\n-    return err;\n-}\n-\n-pub fn maybe_lint_level_root(tcx: TyCtxt<'_>, id: hir::HirId) -> bool {\n-    let attrs = tcx.hir().attrs(id);\n-    attrs.iter().any(|attr| Level::from_symbol(attr.name_or_empty()).is_some())\n-}\n-\n-/// Returns whether `span` originates in a foreign crate's external macro.\n-///\n-/// This is used to test whether a lint should not even begin to figure out whether it should\n-/// be reported on the current node.\n-pub fn in_external_macro(sess: &Session, span: Span) -> bool {\n-    let expn_data = span.ctxt().outer_expn_data();\n-    match expn_data.kind {\n-        ExpnKind::Root | ExpnKind::Desugaring(DesugaringKind::ForLoop) => false,\n-        ExpnKind::AstPass(_) | ExpnKind::Desugaring(_) => true, // well, it's \"external\"\n-        ExpnKind::Macro(MacroKind::Bang, _) => {\n-            if expn_data.def_site.is_dummy() {\n-                // Dummy span for the `def_site` means it's an external macro.\n-                return true;\n-            }\n-            match sess.source_map().span_to_snippet(expn_data.def_site) {\n-                Ok(code) => !code.starts_with(\"macro_rules\"),\n-                // No snippet means external macro or compiler-builtin expansion.\n-                Err(_) => true,\n-            }\n-        }\n-        ExpnKind::Macro(..) => true, // definitely a plugin\n-    }\n-}\n-\n-/// Returns `true` if `span` originates in a derive-macro's expansion.\n-pub fn in_derive_expansion(span: Span) -> bool {\n-    if let ExpnKind::Macro(MacroKind::Derive, _) = span.ctxt().outer_expn_data().kind {\n-        return true;\n-    }\n-    false\n-}", "previous_filename": "src/librustc/lint/mod.rs"}, {"sha": "21b244ad75d4e048c52233abf670497c53ac403d", "filename": "src/librustc_lint/redundant_semicolon.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0b6c116a84fb1dbb60b5870291f5d7df808c280d/src%2Flibrustc_lint%2Fredundant_semicolon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b6c116a84fb1dbb60b5870291f5d7df808c280d/src%2Flibrustc_lint%2Fredundant_semicolon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fredundant_semicolon.rs?ref=0b6c116a84fb1dbb60b5870291f5d7df808c280d", "patch": "@@ -1,4 +1,4 @@\n-use rustc::lint::{EarlyContext, EarlyLintPass, LintContext};\n+use crate::{EarlyContext, EarlyLintPass, LintContext};\n use rustc_errors::Applicability;\n use syntax::ast::{ExprKind, Stmt, StmtKind};\n "}, {"sha": "674a82b61961c457bf68b3f092027bbc7f301f34", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0b6c116a84fb1dbb60b5870291f5d7df808c280d/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b6c116a84fb1dbb60b5870291f5d7df808c280d/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=0b6c116a84fb1dbb60b5870291f5d7df808c280d", "patch": "@@ -1,6 +1,6 @@\n #![allow(non_snake_case)]\n \n-use rustc::lint::{LateContext, LateLintPass, LintContext};\n+use crate::{LateContext, LateLintPass, LintContext};\n use rustc::mir::interpret::{sign_extend, truncate};\n use rustc::ty::layout::{self, IntegerExt, LayoutOf, SizeSkeleton, VariantIdx};\n use rustc::ty::subst::SubstsRef;"}, {"sha": "26cbda3d97895bf04e5fc2a1a8907ce1f7ed3dbd", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0b6c116a84fb1dbb60b5870291f5d7df808c280d/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b6c116a84fb1dbb60b5870291f5d7df808c280d/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=0b6c116a84fb1dbb60b5870291f5d7df808c280d", "patch": "@@ -1,5 +1,4 @@\n-use rustc::lint::builtin::UNUSED_ATTRIBUTES;\n-use rustc::lint::{EarlyContext, EarlyLintPass, LateContext, LateLintPass, LintContext};\n+use crate::{EarlyContext, EarlyLintPass, LateContext, LateLintPass, LintContext};\n use rustc::ty::adjustment;\n use rustc::ty::{self, Ty};\n use rustc_data_structures::fx::FxHashMap;\n@@ -8,6 +7,7 @@ use rustc_feature::{AttributeType, BuiltinAttribute, BUILTIN_ATTRIBUTE_MAP};\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::DefId;\n+use rustc_session::lint::builtin::UNUSED_ATTRIBUTES;\n use rustc_span::symbol::Symbol;\n use rustc_span::symbol::{kw, sym};\n use rustc_span::{BytePos, Span};"}, {"sha": "072cdf2ebba3a26386190276493c2e5f37490ab5", "filename": "src/librustc_mir/transform/check_unsafety.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0b6c116a84fb1dbb60b5870291f5d7df808c280d/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b6c116a84fb1dbb60b5870291f5d7df808c280d/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs?ref=0b6c116a84fb1dbb60b5870291f5d7df808c280d", "patch": "@@ -637,17 +637,17 @@ pub fn check_unsafety(tcx: TyCtxt<'_>, def_id: DefId) {\n                 if let Some(impl_def_id) = builtin_derive_def_id(tcx, def_id) {\n                     tcx.unsafe_derive_on_repr_packed(impl_def_id);\n                 } else {\n-                    tcx.lint_node_note(\n+                    tcx.struct_span_lint_hir(\n                         SAFE_PACKED_BORROWS,\n                         lint_hir_id,\n                         source_info.span,\n                         &format!(\n-                            \"{} is unsafe and requires unsafe function or block \\\n-                                            (error E0133)\",\n+                            \"{} is unsafe and requires unsafe function or block (error E0133)\",\n                             description\n                         ),\n-                        &details.as_str(),\n-                    );\n+                    )\n+                    .note(&details.as_str())\n+                    .emit();\n                 }\n             }\n         }"}, {"sha": "6a18c63017ed6cce86d937470f4ac42fece74c47", "filename": "src/librustc_parse/parser/diagnostics.rs", "status": "modified", "additions": 70, "deletions": 13, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/0b6c116a84fb1dbb60b5870291f5d7df808c280d/src%2Flibrustc_parse%2Fparser%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b6c116a84fb1dbb60b5870291f5d7df808c280d/src%2Flibrustc_parse%2Fparser%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fdiagnostics.rs?ref=0b6c116a84fb1dbb60b5870291f5d7df808c280d", "patch": "@@ -4,6 +4,7 @@ use rustc_data_structures::fx::FxHashSet;\n use rustc_error_codes::*;\n use rustc_errors::{pluralize, struct_span_err};\n use rustc_errors::{Applicability, DiagnosticBuilder, Handler, PResult};\n+use rustc_span::source_map::Spanned;\n use rustc_span::symbol::kw;\n use rustc_span::{MultiSpan, Span, SpanSnippetError, DUMMY_SP};\n use syntax::ast::{\n@@ -491,6 +492,58 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n+    /// Check to see if a pair of chained operators looks like an attempt at chained comparison,\n+    /// e.g. `1 < x <= 3`. If so, suggest either splitting the comparison into two, or\n+    /// parenthesising the leftmost comparison.\n+    fn attempt_chained_comparison_suggestion(\n+        &mut self,\n+        err: &mut DiagnosticBuilder<'_>,\n+        inner_op: &Expr,\n+        outer_op: &Spanned<AssocOp>,\n+    ) {\n+        if let ExprKind::Binary(op, ref l1, ref r1) = inner_op.kind {\n+            match (op.node, &outer_op.node) {\n+                // `x < y < z` and friends.\n+                (BinOpKind::Lt, AssocOp::Less) | (BinOpKind::Lt, AssocOp::LessEqual) |\n+                (BinOpKind::Le, AssocOp::LessEqual) | (BinOpKind::Le, AssocOp::Less) |\n+                // `x > y > z` and friends.\n+                (BinOpKind::Gt, AssocOp::Greater) | (BinOpKind::Gt, AssocOp::GreaterEqual) |\n+                (BinOpKind::Ge, AssocOp::GreaterEqual) | (BinOpKind::Ge, AssocOp::Greater) => {\n+                    let expr_to_str = |e: &Expr| {\n+                        self.span_to_snippet(e.span)\n+                            .unwrap_or_else(|_| pprust::expr_to_string(&e))\n+                    };\n+                    err.span_suggestion(\n+                        inner_op.span.to(outer_op.span),\n+                        \"split the comparison into two...\",\n+                        format!(\n+                            \"{} {} {} && {} {}\",\n+                            expr_to_str(&l1),\n+                            op.node.to_string(),\n+                            expr_to_str(&r1),\n+                            expr_to_str(&r1),\n+                            outer_op.node.to_ast_binop().unwrap().to_string(),\n+                        ),\n+                        Applicability::MaybeIncorrect,\n+                    );\n+                    err.span_suggestion(\n+                        inner_op.span.to(outer_op.span),\n+                        \"...or parenthesize one of the comparisons\",\n+                        format!(\n+                            \"({} {} {}) {}\",\n+                            expr_to_str(&l1),\n+                            op.node.to_string(),\n+                            expr_to_str(&r1),\n+                            outer_op.node.to_ast_binop().unwrap().to_string(),\n+                        ),\n+                        Applicability::MaybeIncorrect,\n+                    );\n+                }\n+                _ => {}\n+            }\n+        }\n+    }\n+\n     /// Produces an error if comparison operators are chained (RFC #558).\n     /// We only need to check the LHS, not the RHS, because all comparison ops have same\n     /// precedence (see `fn precedence`) and are left-associative (see `fn fixity`).\n@@ -506,27 +559,31 @@ impl<'a> Parser<'a> {\n     ///           /   \\\n     ///     inner_op   r2\n     ///        /  \\\n-    ///     l1    r1\n+    ///      l1    r1\n     pub(super) fn check_no_chained_comparison(\n         &mut self,\n-        lhs: &Expr,\n-        outer_op: &AssocOp,\n+        inner_op: &Expr,\n+        outer_op: &Spanned<AssocOp>,\n     ) -> PResult<'a, Option<P<Expr>>> {\n         debug_assert!(\n-            outer_op.is_comparison(),\n+            outer_op.node.is_comparison(),\n             \"check_no_chained_comparison: {:?} is not comparison\",\n-            outer_op,\n+            outer_op.node,\n         );\n \n         let mk_err_expr =\n             |this: &Self, span| Ok(Some(this.mk_expr(span, ExprKind::Err, AttrVec::new())));\n \n-        match lhs.kind {\n+        match inner_op.kind {\n             ExprKind::Binary(op, _, _) if op.node.is_comparison() => {\n                 // Respan to include both operators.\n                 let op_span = op.span.to(self.prev_span);\n-                let mut err = self\n-                    .struct_span_err(op_span, \"chained comparison operators require parentheses\");\n+                let mut err =\n+                    self.struct_span_err(op_span, \"comparison operators cannot be chained\");\n+\n+                // If it looks like a genuine attempt to chain operators (as opposed to a\n+                // misformatted turbofish, for instance), suggest a correct form.\n+                self.attempt_chained_comparison_suggestion(&mut err, inner_op, outer_op);\n \n                 let suggest = |err: &mut DiagnosticBuilder<'_>| {\n                     err.span_suggestion_verbose(\n@@ -538,12 +595,12 @@ impl<'a> Parser<'a> {\n                 };\n \n                 if op.node == BinOpKind::Lt &&\n-                    *outer_op == AssocOp::Less ||  // Include `<` to provide this recommendation\n-                    *outer_op == AssocOp::Greater\n+                    outer_op.node == AssocOp::Less ||  // Include `<` to provide this recommendation\n+                    outer_op.node == AssocOp::Greater\n                 // even in a case like the following:\n                 {\n                     //     Foo<Bar<Baz<Qux, ()>>>\n-                    if *outer_op == AssocOp::Less {\n+                    if outer_op.node == AssocOp::Less {\n                         let snapshot = self.clone();\n                         self.bump();\n                         // So far we have parsed `foo<bar<`, consume the rest of the type args.\n@@ -575,7 +632,7 @@ impl<'a> Parser<'a> {\n                                 // FIXME: actually check that the two expressions in the binop are\n                                 // paths and resynthesize new fn call expression instead of using\n                                 // `ExprKind::Err` placeholder.\n-                                mk_err_expr(self, lhs.span.to(self.prev_span))\n+                                mk_err_expr(self, inner_op.span.to(self.prev_span))\n                             }\n                             Err(mut expr_err) => {\n                                 expr_err.cancel();\n@@ -597,7 +654,7 @@ impl<'a> Parser<'a> {\n                                 // FIXME: actually check that the two expressions in the binop are\n                                 // paths and resynthesize new fn call expression instead of using\n                                 // `ExprKind::Err` placeholder.\n-                                mk_err_expr(self, lhs.span.to(self.prev_span))\n+                                mk_err_expr(self, inner_op.span.to(self.prev_span))\n                             }\n                         }\n                     } else {"}, {"sha": "098c8355ab94498b3eacf626da50beffb3610573", "filename": "src/librustc_parse/parser/expr.rs", "status": "modified", "additions": 23, "deletions": 19, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/0b6c116a84fb1dbb60b5870291f5d7df808c280d/src%2Flibrustc_parse%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b6c116a84fb1dbb60b5870291f5d7df808c280d/src%2Flibrustc_parse%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fexpr.rs?ref=0b6c116a84fb1dbb60b5870291f5d7df808c280d", "patch": "@@ -4,7 +4,7 @@ use super::{SemiColonMode, SeqSep, TokenExpectType};\n use crate::maybe_recover_from_interpolated_ty_qpath;\n \n use rustc_errors::{Applicability, PResult};\n-use rustc_span::source_map::{self, Span};\n+use rustc_span::source_map::{self, Span, Spanned};\n use rustc_span::symbol::{kw, sym, Symbol};\n use std::mem;\n use syntax::ast::{self, AttrStyle, AttrVec, CaptureBy, Field, Ident, Lit, DUMMY_NODE_ID};\n@@ -180,17 +180,17 @@ impl<'a> Parser<'a> {\n             };\n \n             let cur_op_span = self.token.span;\n-            let restrictions = if op.is_assign_like() {\n+            let restrictions = if op.node.is_assign_like() {\n                 self.restrictions & Restrictions::NO_STRUCT_LITERAL\n             } else {\n                 self.restrictions\n             };\n-            let prec = op.precedence();\n+            let prec = op.node.precedence();\n             if prec < min_prec {\n                 break;\n             }\n             // Check for deprecated `...` syntax\n-            if self.token == token::DotDotDot && op == AssocOp::DotDotEq {\n+            if self.token == token::DotDotDot && op.node == AssocOp::DotDotEq {\n                 self.err_dotdotdot_syntax(self.token.span);\n             }\n \n@@ -199,11 +199,12 @@ impl<'a> Parser<'a> {\n             }\n \n             self.bump();\n-            if op.is_comparison() {\n+            if op.node.is_comparison() {\n                 if let Some(expr) = self.check_no_chained_comparison(&lhs, &op)? {\n                     return Ok(expr);\n                 }\n             }\n+            let op = op.node;\n             // Special cases:\n             if op == AssocOp::As {\n                 lhs = self.parse_assoc_op_cast(lhs, lhs_span, ExprKind::Cast)?;\n@@ -297,7 +298,7 @@ impl<'a> Parser<'a> {\n     }\n \n     fn should_continue_as_assoc_expr(&mut self, lhs: &Expr) -> bool {\n-        match (self.expr_is_complete(lhs), self.check_assoc_op()) {\n+        match (self.expr_is_complete(lhs), self.check_assoc_op().map(|op| op.node)) {\n             // Semi-statement forms are odd:\n             // See https://github.com/rust-lang/rust/issues/29071\n             (true, None) => false,\n@@ -342,19 +343,22 @@ impl<'a> Parser<'a> {\n     /// The method does not advance the current token.\n     ///\n     /// Also performs recovery for `and` / `or` which are mistaken for `&&` and `||` respectively.\n-    fn check_assoc_op(&self) -> Option<AssocOp> {\n-        match (AssocOp::from_token(&self.token), &self.token.kind) {\n-            (op @ Some(_), _) => op,\n-            (None, token::Ident(sym::and, false)) => {\n-                self.error_bad_logical_op(\"and\", \"&&\", \"conjunction\");\n-                Some(AssocOp::LAnd)\n-            }\n-            (None, token::Ident(sym::or, false)) => {\n-                self.error_bad_logical_op(\"or\", \"||\", \"disjunction\");\n-                Some(AssocOp::LOr)\n-            }\n-            _ => None,\n-        }\n+    fn check_assoc_op(&self) -> Option<Spanned<AssocOp>> {\n+        Some(Spanned {\n+            node: match (AssocOp::from_token(&self.token), &self.token.kind) {\n+                (Some(op), _) => op,\n+                (None, token::Ident(sym::and, false)) => {\n+                    self.error_bad_logical_op(\"and\", \"&&\", \"conjunction\");\n+                    AssocOp::LAnd\n+                }\n+                (None, token::Ident(sym::or, false)) => {\n+                    self.error_bad_logical_op(\"or\", \"||\", \"disjunction\");\n+                    AssocOp::LOr\n+                }\n+                _ => return None,\n+            },\n+            span: self.token.span,\n+        })\n     }\n \n     /// Error on `and` and `or` suggesting `&&` and `||` respectively."}, {"sha": "f2778b2aa6bcd220d38ba71e8c9a341243302851", "filename": "src/librustc_passes/dead.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0b6c116a84fb1dbb60b5870291f5d7df808c280d/src%2Flibrustc_passes%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b6c116a84fb1dbb60b5870291f5d7df808c280d/src%2Flibrustc_passes%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fdead.rs?ref=0b6c116a84fb1dbb60b5870291f5d7df808c280d", "patch": "@@ -3,7 +3,6 @@\n // from live codes are live, and everything else is dead.\n \n use rustc::hir::map::Map;\n-use rustc::lint;\n use rustc::middle::codegen_fn_attrs::CodegenFnAttrFlags;\n use rustc::middle::privacy;\n use rustc::ty::{self, DefIdTree, TyCtxt};\n@@ -14,6 +13,7 @@ use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n use rustc_hir::itemlikevisit::ItemLikeVisitor;\n use rustc_hir::{Node, PatKind, TyKind};\n+use rustc_session::lint;\n \n use rustc_span;\n use rustc_span::symbol::sym;"}, {"sha": "7718139f6e9246af2b0eb2ef03781ee4c3de31e6", "filename": "src/librustc_passes/liveness.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/0b6c116a84fb1dbb60b5870291f5d7df808c280d/src%2Flibrustc_passes%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b6c116a84fb1dbb60b5870291f5d7df808c280d/src%2Flibrustc_passes%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fliveness.rs?ref=0b6c116a84fb1dbb60b5870291f5d7df808c280d", "patch": "@@ -1513,13 +1513,16 @@ impl<'tcx> Liveness<'_, 'tcx> {\n                 if ln == self.s.exit_ln { false } else { self.assigned_on_exit(ln, var).is_some() };\n \n             if is_assigned {\n-                self.ir.tcx.lint_hir_note(\n-                    lint::builtin::UNUSED_VARIABLES,\n-                    hir_id,\n-                    spans,\n-                    &format!(\"variable `{}` is assigned to, but never used\", name),\n-                    &format!(\"consider using `_{}` instead\", name),\n-                );\n+                self.ir\n+                    .tcx\n+                    .struct_span_lint_hir(\n+                        lint::builtin::UNUSED_VARIABLES,\n+                        hir_id,\n+                        spans,\n+                        &format!(\"variable `{}` is assigned to, but never used\", name),\n+                    )\n+                    .note(&format!(\"consider using `_{}` instead\", name))\n+                    .emit();\n             } else {\n                 let mut err = self.ir.tcx.struct_span_lint_hir(\n                     lint::builtin::UNUSED_VARIABLES,"}, {"sha": "41e6c699c340ec592b1a243ddc377b34b154a0ef", "filename": "src/librustc_plugin_impl/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0b6c116a84fb1dbb60b5870291f5d7df808c280d/src%2Flibrustc_plugin_impl%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/0b6c116a84fb1dbb60b5870291f5d7df808c280d/src%2Flibrustc_plugin_impl%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_plugin_impl%2FCargo.toml?ref=0b6c116a84fb1dbb60b5870291f5d7df808c280d", "patch": "@@ -14,6 +14,7 @@ doctest = false\n rustc = { path = \"../librustc\" }\n rustc_errors = { path = \"../librustc_errors\" }\n rustc_hir = { path = \"../librustc_hir\" }\n+rustc_lint = { path = \"../librustc_lint\" }\n rustc_metadata = { path = \"../librustc_metadata\" }\n syntax = { path = \"../libsyntax\" }\n rustc_span = { path = \"../librustc_span\" }"}, {"sha": "10712eb60b9e3bf21de86462d15a5f884b806c86", "filename": "src/librustc_plugin_impl/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0b6c116a84fb1dbb60b5870291f5d7df808c280d/src%2Flibrustc_plugin_impl%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b6c116a84fb1dbb60b5870291f5d7df808c280d/src%2Flibrustc_plugin_impl%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_plugin_impl%2Flib.rs?ref=0b6c116a84fb1dbb60b5870291f5d7df808c280d", "patch": "@@ -9,7 +9,7 @@\n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n #![feature(nll)]\n \n-use rustc::lint::LintStore;\n+use rustc_lint::LintStore;\n \n pub mod build;\n pub mod load;"}, {"sha": "5779d17e3e51ebe57cdb66de56232338b192696b", "filename": "src/librustc_span/lib.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0b6c116a84fb1dbb60b5870291f5d7df808c280d/src%2Flibrustc_span%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b6c116a84fb1dbb60b5870291f5d7df808c280d/src%2Flibrustc_span%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_span%2Flib.rs?ref=0b6c116a84fb1dbb60b5870291f5d7df808c280d", "patch": "@@ -308,6 +308,11 @@ impl Span {\n         self.ctxt() != SyntaxContext::root()\n     }\n \n+    /// Returns `true` if `span` originates in a derive-macro's expansion.\n+    pub fn in_derive_expansion(self) -> bool {\n+        matches!(self.ctxt().outer_expn_data().kind, ExpnKind::Macro(MacroKind::Derive, _))\n+    }\n+\n     #[inline]\n     pub fn with_root_ctxt(lo: BytePos, hi: BytePos) -> Span {\n         Span::new(lo, hi, SyntaxContext::root())"}, {"sha": "61a7bc765bcf241c572863a9a27d3601081d6afb", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0b6c116a84fb1dbb60b5870291f5d7df808c280d/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b6c116a84fb1dbb60b5870291f5d7df808c280d/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=0b6c116a84fb1dbb60b5870291f5d7df808c280d", "patch": "@@ -1,4 +1,3 @@\n-use rustc::lint;\n use rustc::middle::cstore::CrateStore;\n use rustc::middle::privacy::AccessLevels;\n use rustc::session::config::ErrorOutputType;\n@@ -14,6 +13,7 @@ use rustc_hir::HirId;\n use rustc_interface::interface;\n use rustc_lint;\n use rustc_resolve as resolve;\n+use rustc_session::lint;\n \n use rustc_errors::emitter::{Emitter, EmitterWriter};\n use rustc_errors::json::JsonEmitter;"}, {"sha": "1da00e3a47b8268db9e73c0a87bdc028cb719fa2", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0b6c116a84fb1dbb60b5870291f5d7df808c280d/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b6c116a84fb1dbb60b5870291f5d7df808c280d/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=0b6c116a84fb1dbb60b5870291f5d7df808c280d", "patch": "@@ -10,6 +10,7 @@\n #![feature(nll)]\n #![feature(set_stdio)]\n #![feature(test)]\n+#![feature(vec_remove_item)]\n #![feature(ptr_offset_from)]\n #![feature(crate_visibility_modifier)]\n #![feature(drain_filter)]\n@@ -35,6 +36,7 @@ extern crate rustc_metadata;\n extern crate rustc_mir;\n extern crate rustc_parse;\n extern crate rustc_resolve;\n+extern crate rustc_session;\n extern crate rustc_span as rustc_span;\n extern crate rustc_target;\n extern crate rustc_typeck;"}, {"sha": "725c350fe4e227d8071198e8b4c453b22af13e8e", "filename": "src/test/ui-fulldeps/auxiliary/issue-40001-plugin.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0b6c116a84fb1dbb60b5870291f5d7df808c280d/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Fissue-40001-plugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b6c116a84fb1dbb60b5870291f5d7df808c280d/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Fissue-40001-plugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Fissue-40001-plugin.rs?ref=0b6c116a84fb1dbb60b5870291f5d7df808c280d", "patch": "@@ -1,17 +1,17 @@\n #![feature(box_syntax, plugin, plugin_registrar, rustc_private)]\n #![crate_type = \"dylib\"]\n \n-#[macro_use] extern crate rustc;\n-#[macro_use] extern crate rustc_session;\n extern crate rustc_driver;\n extern crate rustc_hir;\n+#[macro_use] extern crate rustc_lint;\n+#[macro_use] extern crate rustc_session;\n extern crate rustc_span;\n extern crate syntax;\n \n use rustc_hir::intravisit;\n use rustc_hir as hir;\n use rustc_hir::Node;\n-use rustc::lint::{LateContext, LintPass, LintArray, LateLintPass, LintContext};\n+use rustc_lint::{LateContext, LintPass, LintArray, LateLintPass, LintContext};\n use rustc_driver::plugin::Registry;\n use rustc_span::source_map;\n use syntax::print::pprust;"}, {"sha": "98963a180c8502be1618accb24629d599a24fc3b", "filename": "src/test/ui-fulldeps/auxiliary/lint-for-crate-rpass.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0b6c116a84fb1dbb60b5870291f5d7df808c280d/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint-for-crate-rpass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b6c116a84fb1dbb60b5870291f5d7df808c280d/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint-for-crate-rpass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint-for-crate-rpass.rs?ref=0b6c116a84fb1dbb60b5870291f5d7df808c280d", "patch": "@@ -2,14 +2,14 @@\n \n #![feature(plugin_registrar, rustc_private)]\n #![feature(box_syntax)]\n-#[macro_use] extern crate rustc;\n-#[macro_use] extern crate rustc_session;\n extern crate rustc_driver;\n extern crate rustc_hir;\n extern crate rustc_span;\n+#[macro_use] extern crate rustc_lint;\n+#[macro_use] extern crate rustc_session;\n extern crate syntax;\n \n-use rustc::lint::{LateContext, LintContext, LintPass, LateLintPass};\n+use rustc_lint::{LateContext, LintContext, LintPass, LateLintPass};\n use rustc_driver::plugin::Registry;\n use rustc_span::symbol::Symbol;\n use syntax::attr;"}, {"sha": "589477da62527d0a2dc662cc5d29967cffdac8f7", "filename": "src/test/ui-fulldeps/auxiliary/lint-for-crate.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0b6c116a84fb1dbb60b5870291f5d7df808c280d/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint-for-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b6c116a84fb1dbb60b5870291f5d7df808c280d/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint-for-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint-for-crate.rs?ref=0b6c116a84fb1dbb60b5870291f5d7df808c280d", "patch": "@@ -3,14 +3,14 @@\n #![feature(plugin_registrar, rustc_private)]\n #![feature(box_syntax)]\n \n-#[macro_use] extern crate rustc;\n-#[macro_use] extern crate rustc_session;\n extern crate rustc_driver;\n extern crate rustc_hir;\n+#[macro_use] extern crate rustc_lint;\n+#[macro_use] extern crate rustc_session;\n extern crate rustc_span;\n extern crate syntax;\n \n-use rustc::lint::{LateContext, LintContext, LintPass, LateLintPass, LintArray};\n+use rustc_lint::{LateContext, LintContext, LintPass, LateLintPass, LintArray};\n use rustc_driver::plugin::Registry;\n use rustc_span::symbol::Symbol;\n use syntax::attr;"}, {"sha": "2cc288c21e6978f7ad95302c742d54e54cfb4590", "filename": "src/test/ui-fulldeps/auxiliary/lint-group-plugin-test.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0b6c116a84fb1dbb60b5870291f5d7df808c280d/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint-group-plugin-test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b6c116a84fb1dbb60b5870291f5d7df808c280d/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint-group-plugin-test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint-group-plugin-test.rs?ref=0b6c116a84fb1dbb60b5870291f5d7df808c280d", "patch": "@@ -4,12 +4,12 @@\n #![feature(box_syntax, rustc_private)]\n \n // Load rustc as a plugin to get macros.\n-#[macro_use] extern crate rustc;\n-#[macro_use] extern crate rustc_session;\n extern crate rustc_driver;\n extern crate rustc_hir;\n+#[macro_use] extern crate rustc_lint;\n+#[macro_use] extern crate rustc_session;\n \n-use rustc::lint::{LateContext, LintContext, LintPass, LateLintPass, LintArray, LintId};\n+use rustc_lint::{LateContext, LintContext, LintPass, LateLintPass, LintArray, LintId};\n use rustc_driver::plugin::Registry;\n \n declare_lint!(TEST_LINT, Warn, \"Warn about items named 'lintme'\");"}, {"sha": "c704701cc480b4573386c81daf229b9d9ed69fdc", "filename": "src/test/ui-fulldeps/auxiliary/lint-plugin-test.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0b6c116a84fb1dbb60b5870291f5d7df808c280d/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint-plugin-test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b6c116a84fb1dbb60b5870291f5d7df808c280d/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint-plugin-test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint-plugin-test.rs?ref=0b6c116a84fb1dbb60b5870291f5d7df808c280d", "patch": "@@ -6,11 +6,11 @@\n extern crate syntax;\n \n // Load rustc as a plugin to get macros\n-#[macro_use] extern crate rustc;\n-#[macro_use] extern crate rustc_session;\n extern crate rustc_driver;\n+#[macro_use] extern crate rustc_lint;\n+#[macro_use] extern crate rustc_session;\n \n-use rustc::lint::{EarlyContext, LintContext, LintPass, EarlyLintPass, LintArray};\n+use rustc_lint::{EarlyContext, LintContext, LintPass, EarlyLintPass, LintArray};\n use rustc_driver::plugin::Registry;\n use syntax::ast;\n declare_lint!(TEST_LINT, Warn, \"Warn about items named 'lintme'\");"}, {"sha": "fa545ddc2bc6be860b82bd6e063c7cba6dd66cf1", "filename": "src/test/ui-fulldeps/auxiliary/lint-tool-test.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0b6c116a84fb1dbb60b5870291f5d7df808c280d/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint-tool-test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b6c116a84fb1dbb60b5870291f5d7df808c280d/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint-tool-test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint-tool-test.rs?ref=0b6c116a84fb1dbb60b5870291f5d7df808c280d", "patch": "@@ -4,11 +4,11 @@\n extern crate syntax;\n \n // Load rustc as a plugin to get macros\n-#[macro_use] extern crate rustc;\n-#[macro_use] extern crate rustc_session;\n extern crate rustc_driver;\n+#[macro_use] extern crate rustc_lint;\n+#[macro_use] extern crate rustc_session;\n \n-use rustc::lint::{EarlyContext, EarlyLintPass, LintArray, LintContext, LintPass, LintId};\n+use rustc_lint::{EarlyContext, EarlyLintPass, LintArray, LintContext, LintPass, LintId};\n use rustc_driver::plugin::Registry;\n use syntax::ast;\n declare_tool_lint!(pub clippy::TEST_LINT, Warn, \"Warn about stuff\");"}, {"sha": "e4e94bb9492371c811fb2a0ccc56fef040e673df", "filename": "src/test/ui/did_you_mean/issue-40396.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0b6c116a84fb1dbb60b5870291f5d7df808c280d/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-40396.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b6c116a84fb1dbb60b5870291f5d7df808c280d/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-40396.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-40396.rs?ref=0b6c116a84fb1dbb60b5870291f5d7df808c280d", "patch": "@@ -1,8 +1,8 @@\n fn main() {\n     (0..13).collect<Vec<i32>>();\n-    //~^ ERROR chained comparison\n+    //~^ ERROR comparison operators cannot be chained\n     Vec<i32>::new();\n-    //~^ ERROR chained comparison\n+    //~^ ERROR comparison operators cannot be chained\n     (0..13).collect<Vec<i32>();\n-    //~^ ERROR chained comparison\n+    //~^ ERROR comparison operators cannot be chained\n }"}, {"sha": "f952136a7bfe36b8b1031acbf17606dfa9259e4f", "filename": "src/test/ui/did_you_mean/issue-40396.stderr", "status": "modified", "additions": 19, "deletions": 3, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/0b6c116a84fb1dbb60b5870291f5d7df808c280d/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-40396.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0b6c116a84fb1dbb60b5870291f5d7df808c280d/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-40396.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-40396.stderr?ref=0b6c116a84fb1dbb60b5870291f5d7df808c280d", "patch": "@@ -1,15 +1,23 @@\n-error: chained comparison operators require parentheses\n+error: comparison operators cannot be chained\n   --> $DIR/issue-40396.rs:2:20\n    |\n LL |     (0..13).collect<Vec<i32>>();\n    |                    ^^^^^\n    |\n+help: split the comparison into two...\n+   |\n+LL |     (0..13).collect < Vec && Vec <i32>>();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: ...or parenthesize one of the comparisons\n+   |\n+LL |     ((0..13).collect < Vec) <i32>>();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n help: use `::<...>` instead of `<...>` to specify type arguments\n    |\n LL |     (0..13).collect::<Vec<i32>>();\n    |                    ^^\n \n-error: chained comparison operators require parentheses\n+error: comparison operators cannot be chained\n   --> $DIR/issue-40396.rs:4:8\n    |\n LL |     Vec<i32>::new();\n@@ -20,12 +28,20 @@ help: use `::<...>` instead of `<...>` to specify type arguments\n LL |     Vec::<i32>::new();\n    |        ^^\n \n-error: chained comparison operators require parentheses\n+error: comparison operators cannot be chained\n   --> $DIR/issue-40396.rs:6:20\n    |\n LL |     (0..13).collect<Vec<i32>();\n    |                    ^^^^^\n    |\n+help: split the comparison into two...\n+   |\n+LL |     (0..13).collect < Vec && Vec <i32>();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: ...or parenthesize one of the comparisons\n+   |\n+LL |     ((0..13).collect < Vec) <i32>();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n help: use `::<...>` instead of `<...>` to specify type arguments\n    |\n LL |     (0..13).collect::<Vec<i32>();"}, {"sha": "0431196f1744e064b78ff66937a00b14bb3f1d3b", "filename": "src/test/ui/parser/chained-comparison-suggestion.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/0b6c116a84fb1dbb60b5870291f5d7df808c280d/src%2Ftest%2Fui%2Fparser%2Fchained-comparison-suggestion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b6c116a84fb1dbb60b5870291f5d7df808c280d/src%2Ftest%2Fui%2Fparser%2Fchained-comparison-suggestion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fchained-comparison-suggestion.rs?ref=0b6c116a84fb1dbb60b5870291f5d7df808c280d", "patch": "@@ -0,0 +1,40 @@\n+// Check that we get nice suggestions when attempting a chained comparison.\n+\n+fn comp1() {\n+    1 < 2 <= 3; //~ ERROR comparison operators cannot be chained\n+    //~^ ERROR mismatched types\n+}\n+\n+fn comp2() {\n+    1 < 2 < 3; //~ ERROR comparison operators cannot be chained\n+}\n+\n+fn comp3() {\n+    1 <= 2 < 3; //~ ERROR comparison operators cannot be chained\n+    //~^ ERROR mismatched types\n+}\n+\n+fn comp4() {\n+    1 <= 2 <= 3; //~ ERROR comparison operators cannot be chained\n+    //~^ ERROR mismatched types\n+}\n+\n+fn comp5() {\n+    1 > 2 >= 3; //~ ERROR comparison operators cannot be chained\n+    //~^ ERROR mismatched types\n+}\n+\n+fn comp6() {\n+    1 > 2 > 3; //~ ERROR comparison operators cannot be chained\n+}\n+\n+fn comp7() {\n+    1 >= 2 > 3; //~ ERROR comparison operators cannot be chained\n+}\n+\n+fn comp8() {\n+    1 >= 2 >= 3; //~ ERROR comparison operators cannot be chained\n+    //~^ ERROR mismatched types\n+}\n+\n+fn main() {}"}, {"sha": "5c10a4599dd032e984b9f1fa11cf8e1f98a8ac16", "filename": "src/test/ui/parser/chained-comparison-suggestion.stderr", "status": "added", "additions": 159, "deletions": 0, "changes": 159, "blob_url": "https://github.com/rust-lang/rust/blob/0b6c116a84fb1dbb60b5870291f5d7df808c280d/src%2Ftest%2Fui%2Fparser%2Fchained-comparison-suggestion.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0b6c116a84fb1dbb60b5870291f5d7df808c280d/src%2Ftest%2Fui%2Fparser%2Fchained-comparison-suggestion.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fchained-comparison-suggestion.stderr?ref=0b6c116a84fb1dbb60b5870291f5d7df808c280d", "patch": "@@ -0,0 +1,159 @@\n+error: comparison operators cannot be chained\n+  --> $DIR/chained-comparison-suggestion.rs:4:7\n+   |\n+LL |     1 < 2 <= 3;\n+   |       ^^^^^^\n+   |\n+help: split the comparison into two...\n+   |\n+LL |     1 < 2 && 2 <= 3;\n+   |     ^^^^^^^^^^^^^\n+help: ...or parenthesize one of the comparisons\n+   |\n+LL |     (1 < 2) <= 3;\n+   |     ^^^^^^^^^^\n+\n+error: comparison operators cannot be chained\n+  --> $DIR/chained-comparison-suggestion.rs:9:7\n+   |\n+LL |     1 < 2 < 3;\n+   |       ^^^^^\n+   |\n+   = help: use `::<...>` instead of `<...>` to specify type arguments\n+   = help: or use `(...)` if you meant to specify fn arguments\n+help: split the comparison into two...\n+   |\n+LL |     1 < 2 && 2 < 3;\n+   |     ^^^^^^^^^^^^\n+help: ...or parenthesize one of the comparisons\n+   |\n+LL |     (1 < 2) < 3;\n+   |     ^^^^^^^^^\n+\n+error: comparison operators cannot be chained\n+  --> $DIR/chained-comparison-suggestion.rs:13:7\n+   |\n+LL |     1 <= 2 < 3;\n+   |       ^^^^^^\n+   |\n+help: split the comparison into two...\n+   |\n+LL |     1 <= 2 && 2 < 3;\n+   |     ^^^^^^^^^^^^^\n+help: ...or parenthesize one of the comparisons\n+   |\n+LL |     (1 <= 2) < 3;\n+   |     ^^^^^^^^^^\n+\n+error: comparison operators cannot be chained\n+  --> $DIR/chained-comparison-suggestion.rs:18:7\n+   |\n+LL |     1 <= 2 <= 3;\n+   |       ^^^^^^^\n+   |\n+help: split the comparison into two...\n+   |\n+LL |     1 <= 2 && 2 <= 3;\n+   |     ^^^^^^^^^^^^^^\n+help: ...or parenthesize one of the comparisons\n+   |\n+LL |     (1 <= 2) <= 3;\n+   |     ^^^^^^^^^^^\n+\n+error: comparison operators cannot be chained\n+  --> $DIR/chained-comparison-suggestion.rs:23:7\n+   |\n+LL |     1 > 2 >= 3;\n+   |       ^^^^^^\n+   |\n+help: split the comparison into two...\n+   |\n+LL |     1 > 2 && 2 >= 3;\n+   |     ^^^^^^^^^^^^^\n+help: ...or parenthesize one of the comparisons\n+   |\n+LL |     (1 > 2) >= 3;\n+   |     ^^^^^^^^^^\n+\n+error: comparison operators cannot be chained\n+  --> $DIR/chained-comparison-suggestion.rs:28:7\n+   |\n+LL |     1 > 2 > 3;\n+   |       ^^^^^\n+   |\n+   = help: use `::<...>` instead of `<...>` to specify type arguments\n+   = help: or use `(...)` if you meant to specify fn arguments\n+help: split the comparison into two...\n+   |\n+LL |     1 > 2 && 2 > 3;\n+   |     ^^^^^^^^^^^^\n+help: ...or parenthesize one of the comparisons\n+   |\n+LL |     (1 > 2) > 3;\n+   |     ^^^^^^^^^\n+\n+error: comparison operators cannot be chained\n+  --> $DIR/chained-comparison-suggestion.rs:32:7\n+   |\n+LL |     1 >= 2 > 3;\n+   |       ^^^^^^\n+   |\n+   = help: use `::<...>` instead of `<...>` to specify type arguments\n+   = help: or use `(...)` if you meant to specify fn arguments\n+help: split the comparison into two...\n+   |\n+LL |     1 >= 2 && 2 > 3;\n+   |     ^^^^^^^^^^^^^\n+help: ...or parenthesize one of the comparisons\n+   |\n+LL |     (1 >= 2) > 3;\n+   |     ^^^^^^^^^^\n+\n+error: comparison operators cannot be chained\n+  --> $DIR/chained-comparison-suggestion.rs:36:7\n+   |\n+LL |     1 >= 2 >= 3;\n+   |       ^^^^^^^\n+   |\n+help: split the comparison into two...\n+   |\n+LL |     1 >= 2 && 2 >= 3;\n+   |     ^^^^^^^^^^^^^^\n+help: ...or parenthesize one of the comparisons\n+   |\n+LL |     (1 >= 2) >= 3;\n+   |     ^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/chained-comparison-suggestion.rs:4:14\n+   |\n+LL |     1 < 2 <= 3;\n+   |              ^ expected `bool`, found integer\n+\n+error[E0308]: mismatched types\n+  --> $DIR/chained-comparison-suggestion.rs:13:14\n+   |\n+LL |     1 <= 2 < 3;\n+   |              ^ expected `bool`, found integer\n+\n+error[E0308]: mismatched types\n+  --> $DIR/chained-comparison-suggestion.rs:18:15\n+   |\n+LL |     1 <= 2 <= 3;\n+   |               ^ expected `bool`, found integer\n+\n+error[E0308]: mismatched types\n+  --> $DIR/chained-comparison-suggestion.rs:23:14\n+   |\n+LL |     1 > 2 >= 3;\n+   |              ^ expected `bool`, found integer\n+\n+error[E0308]: mismatched types\n+  --> $DIR/chained-comparison-suggestion.rs:36:15\n+   |\n+LL |     1 >= 2 >= 3;\n+   |               ^ expected `bool`, found integer\n+\n+error: aborting due to 13 previous errors\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "e27b03dddc5be56882eaf84089585bd4ceb9e98d", "filename": "src/test/ui/parser/require-parens-for-chained-comparison.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0b6c116a84fb1dbb60b5870291f5d7df808c280d/src%2Ftest%2Fui%2Fparser%2Frequire-parens-for-chained-comparison.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b6c116a84fb1dbb60b5870291f5d7df808c280d/src%2Ftest%2Fui%2Fparser%2Frequire-parens-for-chained-comparison.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Frequire-parens-for-chained-comparison.rs?ref=0b6c116a84fb1dbb60b5870291f5d7df808c280d", "patch": "@@ -3,24 +3,26 @@ struct X;\n \n fn main() {\n     false == false == false;\n-    //~^ ERROR chained comparison operators require parentheses\n+    //~^ ERROR comparison operators cannot be chained\n \n     false == 0 < 2;\n-    //~^ ERROR chained comparison operators require parentheses\n+    //~^ ERROR comparison operators cannot be chained\n     //~| ERROR mismatched types\n     //~| ERROR mismatched types\n \n     f<X>();\n-    //~^ ERROR chained comparison operators require parentheses\n+    //~^ ERROR comparison operators cannot be chained\n     //~| HELP use `::<...>` instead of `<...>` to specify type arguments\n \n     f<Result<Option<X>, Option<Option<X>>>(1, 2);\n-    //~^ ERROR chained comparison operators require parentheses\n+    //~^ ERROR comparison operators cannot be chained\n+    //~| HELP split the comparison into two...\n+    //~| ...or parenthesize one of the comparisons\n     //~| HELP use `::<...>` instead of `<...>` to specify type arguments\n \n     use std::convert::identity;\n     let _ = identity<u8>;\n-    //~^ ERROR chained comparison operators require parentheses\n+    //~^ ERROR comparison operators cannot be chained\n     //~| HELP use `::<...>` instead of `<...>` to specify type arguments\n     //~| HELP or use `(...)` if you meant to specify fn arguments\n }"}, {"sha": "44edf2de7f8de22adccbaf1aa6c0168f4671c671", "filename": "src/test/ui/parser/require-parens-for-chained-comparison.stderr", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/0b6c116a84fb1dbb60b5870291f5d7df808c280d/src%2Ftest%2Fui%2Fparser%2Frequire-parens-for-chained-comparison.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0b6c116a84fb1dbb60b5870291f5d7df808c280d/src%2Ftest%2Fui%2Fparser%2Frequire-parens-for-chained-comparison.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Frequire-parens-for-chained-comparison.stderr?ref=0b6c116a84fb1dbb60b5870291f5d7df808c280d", "patch": "@@ -1,16 +1,16 @@\n-error: chained comparison operators require parentheses\n+error: comparison operators cannot be chained\n   --> $DIR/require-parens-for-chained-comparison.rs:5:11\n    |\n LL |     false == false == false;\n    |           ^^^^^^^^^^^\n \n-error: chained comparison operators require parentheses\n+error: comparison operators cannot be chained\n   --> $DIR/require-parens-for-chained-comparison.rs:8:11\n    |\n LL |     false == 0 < 2;\n    |           ^^^^^^\n \n-error: chained comparison operators require parentheses\n+error: comparison operators cannot be chained\n   --> $DIR/require-parens-for-chained-comparison.rs:13:6\n    |\n LL |     f<X>();\n@@ -21,19 +21,27 @@ help: use `::<...>` instead of `<...>` to specify type arguments\n LL |     f::<X>();\n    |      ^^\n \n-error: chained comparison operators require parentheses\n+error: comparison operators cannot be chained\n   --> $DIR/require-parens-for-chained-comparison.rs:17:6\n    |\n LL |     f<Result<Option<X>, Option<Option<X>>>(1, 2);\n    |      ^^^^^^^^\n    |\n+help: split the comparison into two...\n+   |\n+LL |     f < Result && Result <Option<X>, Option<Option<X>>>(1, 2);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^\n+help: ...or parenthesize one of the comparisons\n+   |\n+LL |     (f < Result) <Option<X>, Option<Option<X>>>(1, 2);\n+   |     ^^^^^^^^^^^^^^\n help: use `::<...>` instead of `<...>` to specify type arguments\n    |\n LL |     f::<Result<Option<X>, Option<Option<X>>>(1, 2);\n    |      ^^\n \n-error: chained comparison operators require parentheses\n-  --> $DIR/require-parens-for-chained-comparison.rs:22:21\n+error: comparison operators cannot be chained\n+  --> $DIR/require-parens-for-chained-comparison.rs:24:21\n    |\n LL |     let _ = identity<u8>;\n    |                     ^^^^"}, {"sha": "c46c4715924e59439ba11f562da9504b1d4e606f", "filename": "src/test/ui/type-alias-impl-trait/incoherent-assoc-imp-trait.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0b6c116a84fb1dbb60b5870291f5d7df808c280d/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fincoherent-assoc-imp-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b6c116a84fb1dbb60b5870291f5d7df808c280d/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fincoherent-assoc-imp-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fincoherent-assoc-imp-trait.rs?ref=0b6c116a84fb1dbb60b5870291f5d7df808c280d", "patch": "@@ -0,0 +1,16 @@\n+// Regression test for issue 67856\n+\n+#![feature(unboxed_closures)]\n+#![feature(type_alias_impl_trait)]\n+#![feature(fn_traits)]\n+\n+trait MyTrait {}\n+impl MyTrait for () {}\n+\n+impl<F> FnOnce<()> for &F {\n+    //~^ ERROR conflicting implementations\n+    //~| ERROR type parameter `F` must be used\n+    type Output = impl MyTrait;\n+    extern \"rust-call\" fn call_once(self, _: ()) -> Self::Output {}\n+}\n+fn main() {}"}, {"sha": "f8e1e55f23f9a38cb99f3b4e0ea55f7f67936d9d", "filename": "src/test/ui/type-alias-impl-trait/incoherent-assoc-imp-trait.stderr", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/0b6c116a84fb1dbb60b5870291f5d7df808c280d/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fincoherent-assoc-imp-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0b6c116a84fb1dbb60b5870291f5d7df808c280d/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fincoherent-assoc-imp-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fincoherent-assoc-imp-trait.stderr?ref=0b6c116a84fb1dbb60b5870291f5d7df808c280d", "patch": "@@ -0,0 +1,23 @@\n+error[E0119]: conflicting implementations of trait `std::ops::FnOnce<()>` for type `&_`:\n+  --> $DIR/incoherent-assoc-imp-trait.rs:10:1\n+   |\n+LL | impl<F> FnOnce<()> for &F {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: conflicting implementation in crate `core`:\n+           - impl<A, F> std::ops::FnOnce<A> for &F\n+             where F: std::ops::Fn<A>, F: ?Sized;\n+\n+error[E0210]: type parameter `F` must be used as the type parameter for some local type (e.g., `MyStruct<F>`)\n+  --> $DIR/incoherent-assoc-imp-trait.rs:10:6\n+   |\n+LL | impl<F> FnOnce<()> for &F {\n+   |      ^ type parameter `F` must be used as the type parameter for some local type\n+   |\n+   = note: implementing a foreign trait is only possible if at least one of the types for which is it implemented is local\n+   = note: only traits defined in the current crate can be implemented for a type parameter\n+\n+error: aborting due to 2 previous errors\n+\n+Some errors have detailed explanations: E0119, E0210.\n+For more information about an error, try `rustc --explain E0119`."}, {"sha": "efa9d05f16c38136e10db0a5841f611a60a9739b", "filename": "src/tools/compiletest/src/main.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0b6c116a84fb1dbb60b5870291f5d7df808c280d/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b6c116a84fb1dbb60b5870291f5d7df808c280d/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs?ref=0b6c116a84fb1dbb60b5870291f5d7df808c280d", "patch": "@@ -1,4 +1,5 @@\n #![crate_name = \"compiletest\"]\n+#![feature(vec_remove_item)]\n #![deny(warnings)]\n // The `test` crate is the only unstable feature\n // allowed here, just to share similar code."}]}