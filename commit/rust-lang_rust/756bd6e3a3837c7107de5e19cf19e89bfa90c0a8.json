{"sha": "756bd6e3a3837c7107de5e19cf19e89bfa90c0a8", "node_id": "C_kwDOAAsO6NoAKDc1NmJkNmUzYTM4MzdjNzEwN2RlNWUxOWNmMTllODliZmE5MGMwYTg", "commit": {"author": {"name": "Maybe Waffle", "email": "waffle.lapkin@gmail.com", "date": "2022-08-02T06:42:16Z"}, "committer": {"name": "Maybe Waffle", "email": "waffle.lapkin@gmail.com", "date": "2022-08-02T06:46:43Z"}, "message": "Use `next_chunk` in `ArrayChunks` impl", "tree": {"sha": "453c1fe6f7c2f4c2c9911e344ed71fdddf6b828b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/453c1fe6f7c2f4c2c9911e344ed71fdddf6b828b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/756bd6e3a3837c7107de5e19cf19e89bfa90c0a8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/756bd6e3a3837c7107de5e19cf19e89bfa90c0a8", "html_url": "https://github.com/rust-lang/rust/commit/756bd6e3a3837c7107de5e19cf19e89bfa90c0a8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/756bd6e3a3837c7107de5e19cf19e89bfa90c0a8/comments", "author": {"login": "WaffleLapkin", "id": 38225716, "node_id": "MDQ6VXNlcjM4MjI1NzE2", "avatar_url": "https://avatars.githubusercontent.com/u/38225716?v=4", "gravatar_id": "", "url": "https://api.github.com/users/WaffleLapkin", "html_url": "https://github.com/WaffleLapkin", "followers_url": "https://api.github.com/users/WaffleLapkin/followers", "following_url": "https://api.github.com/users/WaffleLapkin/following{/other_user}", "gists_url": "https://api.github.com/users/WaffleLapkin/gists{/gist_id}", "starred_url": "https://api.github.com/users/WaffleLapkin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/WaffleLapkin/subscriptions", "organizations_url": "https://api.github.com/users/WaffleLapkin/orgs", "repos_url": "https://api.github.com/users/WaffleLapkin/repos", "events_url": "https://api.github.com/users/WaffleLapkin/events{/privacy}", "received_events_url": "https://api.github.com/users/WaffleLapkin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "WaffleLapkin", "id": 38225716, "node_id": "MDQ6VXNlcjM4MjI1NzE2", "avatar_url": "https://avatars.githubusercontent.com/u/38225716?v=4", "gravatar_id": "", "url": "https://api.github.com/users/WaffleLapkin", "html_url": "https://github.com/WaffleLapkin", "followers_url": "https://api.github.com/users/WaffleLapkin/followers", "following_url": "https://api.github.com/users/WaffleLapkin/following{/other_user}", "gists_url": "https://api.github.com/users/WaffleLapkin/gists{/gist_id}", "starred_url": "https://api.github.com/users/WaffleLapkin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/WaffleLapkin/subscriptions", "organizations_url": "https://api.github.com/users/WaffleLapkin/orgs", "repos_url": "https://api.github.com/users/WaffleLapkin/repos", "events_url": "https://api.github.com/users/WaffleLapkin/events{/privacy}", "received_events_url": "https://api.github.com/users/WaffleLapkin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "475e4ba747aa897360748c5ae0bf4d373662f83f", "url": "https://api.github.com/repos/rust-lang/rust/commits/475e4ba747aa897360748c5ae0bf4d373662f83f", "html_url": "https://github.com/rust-lang/rust/commit/475e4ba747aa897360748c5ae0bf4d373662f83f"}], "stats": {"total": 169, "additions": 37, "deletions": 132}, "files": [{"sha": "3af72c16aafb5b9ca635fd4f7f6584d21d16e944", "filename": "library/core/src/iter/adapters/array_chunks.rs", "status": "modified", "additions": 37, "deletions": 132, "changes": 169, "blob_url": "https://github.com/rust-lang/rust/blob/756bd6e3a3837c7107de5e19cf19e89bfa90c0a8/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Farray_chunks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/756bd6e3a3837c7107de5e19cf19e89bfa90c0a8/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Farray_chunks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Farray_chunks.rs?ref=756bd6e3a3837c7107de5e19cf19e89bfa90c0a8", "patch": "@@ -1,9 +1,6 @@\n use crate::array;\n use crate::iter::{FusedIterator, Iterator};\n-use crate::mem;\n-use crate::mem::MaybeUninit;\n use crate::ops::{ControlFlow, NeverShortCircuit, Try};\n-use crate::ptr;\n \n /// An iterator over `N` elements of the iterator at a time.\n ///\n@@ -70,37 +67,18 @@ where\n         F: FnMut(B, Self::Item) -> R,\n         R: Try<Output = B>,\n     {\n-        let mut array = MaybeUninit::uninit_array();\n-        // SAFETY: `array` will still be valid if `guard` is dropped.\n-        let mut guard = unsafe { FrontGuard::new(&mut array) };\n-\n-        let result = self.iter.try_fold(init, |mut acc, item| {\n-            // SAFETY: `init` starts at 0, increases by one each iteration and\n-            // is reset to 0 once it reaches N.\n-            unsafe { array.get_unchecked_mut(guard.init) }.write(item);\n-            guard.init += 1;\n-            if guard.init == N {\n-                guard.init = 0;\n-                let array = mem::replace(&mut array, MaybeUninit::uninit_array());\n-                // SAFETY: the condition above asserts that all elements are\n-                // initialized.\n-                let item = unsafe { MaybeUninit::array_assume_init(array) };\n-                acc = f(acc, item)?;\n-            }\n-            R::from_output(acc)\n-        });\n-        match result.branch() {\n-            ControlFlow::Continue(o) => {\n-                if guard.init > 0 {\n-                    let init = guard.init;\n-                    mem::forget(guard);\n-                    // SAFETY: `array` was initialized with `init` elements.\n-                    self.remainder =\n-                        Some(unsafe { array::IntoIter::new_unchecked(array, 0..init) });\n+        let mut acc = init;\n+        loop {\n+            match self.iter.next_chunk() {\n+                Ok(chunk) => acc = f(acc, chunk)?,\n+                Err(remainder) => {\n+                    // Make sure to not override `self.remainder` with an empty array\n+                    // when `next` is called after `ArrayChunks` exhaustion.\n+                    self.remainder.get_or_insert(remainder);\n+\n+                    break try { acc };\n                 }\n-                R::from_output(o)\n             }\n-            ControlFlow::Break(r) => R::from_residual(r),\n         }\n     }\n \n@@ -113,33 +91,6 @@ where\n     }\n }\n \n-/// A guard for an array where elements are filled from the left.\n-struct FrontGuard<T, const N: usize> {\n-    /// A pointer to the array that is being filled. We need to use a raw\n-    /// pointer here because of the lifetime issues in the fold implementations.\n-    ptr: *mut T,\n-    /// The number of *initialized* elements.\n-    init: usize,\n-}\n-\n-impl<T, const N: usize> FrontGuard<T, N> {\n-    unsafe fn new(array: &mut [MaybeUninit<T>; N]) -> Self {\n-        Self { ptr: MaybeUninit::slice_as_mut_ptr(array), init: 0 }\n-    }\n-}\n-\n-impl<T, const N: usize> Drop for FrontGuard<T, N> {\n-    fn drop(&mut self) {\n-        debug_assert!(self.init <= N);\n-        // SAFETY: This raw slice will only contain the initialized objects\n-        // within the buffer.\n-        unsafe {\n-            let slice = ptr::slice_from_raw_parts_mut(self.ptr, self.init);\n-            ptr::drop_in_place(slice);\n-        }\n-    }\n-}\n-\n #[unstable(feature = \"iter_array_chunks\", reason = \"recently added\", issue = \"none\")]\n impl<I, const N: usize> DoubleEndedIterator for ArrayChunks<I, N>\n where\n@@ -157,29 +108,20 @@ where\n         R: Try<Output = B>,\n     {\n         // We are iterating from the back we need to first handle the remainder.\n-        if self.next_back_remainder().is_none() {\n-            return R::from_output(init);\n-        }\n+        self.next_back_remainder();\n \n-        let mut array = MaybeUninit::uninit_array();\n-        // SAFETY: `array` will still be valid if `guard` is dropped.\n-        let mut guard = unsafe { BackGuard::new(&mut array) };\n+        let mut acc = init;\n+        let mut iter = self.iter.by_ref().rev();\n \n-        self.iter.try_rfold(init, |mut acc, item| {\n-            guard.uninit -= 1;\n-            // SAFETY: `uninit` starts at N, decreases by one each iteration and\n-            // is reset to N once it reaches 0.\n-            unsafe { array.get_unchecked_mut(guard.uninit) }.write(item);\n-            if guard.uninit == 0 {\n-                guard.uninit = N;\n-                let array = mem::replace(&mut array, MaybeUninit::uninit_array());\n-                // SAFETY: the condition above asserts that all elements are\n-                // initialized.\n-                let item = unsafe { MaybeUninit::array_assume_init(array) };\n-                acc = f(acc, item)?;\n-            }\n-            R::from_output(acc)\n-        })\n+        // NB remainder is handled by `next_back_remainder`, so\n+        // `next_chunk` can't return `Err` with non-empty remainder\n+        // (assuming correct `I as ExactSizeIterator` impl).\n+        while let Ok(mut chunk) = iter.next_chunk() {\n+            chunk.reverse();\n+            acc = f(acc, chunk)?\n+        }\n+\n+        try { acc }\n     }\n \n     fn rfold<B, F>(mut self, init: B, mut f: F) -> B\n@@ -195,63 +137,26 @@ impl<I, const N: usize> ArrayChunks<I, N>\n where\n     I: DoubleEndedIterator + ExactSizeIterator,\n {\n-    #[inline]\n-    fn next_back_remainder(&mut self) -> Option<()> {\n+    /// Updates `self.remainder` such that `self.iter.len` is divisible by `N`.\n+    fn next_back_remainder(&mut self) {\n+        // Make sure to not override `self.remainder` with an empty array\n+        // when `next_back` is called after `ArrayChunks` exhaustion.\n+        if self.remainder.is_some() {\n+            return;\n+        }\n+\n         // We use the `ExactSizeIterator` implementation of the underlying\n         // iterator to know how many remaining elements there are.\n         let rem = self.iter.len() % N;\n-        if rem == 0 {\n-            return Some(());\n-        }\n-\n-        let mut array = MaybeUninit::uninit_array();\n \n-        // SAFETY: The array will still be valid if `guard` is dropped and\n-        // it is forgotten otherwise.\n-        let mut guard = unsafe { FrontGuard::new(&mut array) };\n+        // Take the last `rem` elements out of `self.iter`.\n+        let mut remainder =\n+            // SAFETY: `unwrap_err` always succeeds because x % N < N for all x.\n+            unsafe { self.iter.by_ref().rev().take(rem).next_chunk().unwrap_err_unchecked() };\n \n-        // SAFETY: `rem` is in the range 1..N based on how it is calculated.\n-        for slot in unsafe { array.get_unchecked_mut(..rem) }.iter_mut() {\n-            slot.write(self.iter.next_back()?);\n-            guard.init += 1;\n-        }\n-\n-        let init = guard.init;\n-        mem::forget(guard);\n-        // SAFETY: `array` was initialized with exactly `init` elements.\n-        self.remainder = unsafe {\n-            array.get_unchecked_mut(..init).reverse();\n-            Some(array::IntoIter::new_unchecked(array, 0..init))\n-        };\n-        Some(())\n-    }\n-}\n-\n-/// A guard for an array where elements are filled from the right.\n-struct BackGuard<T, const N: usize> {\n-    /// A pointer to the array that is being filled. We need to use a raw\n-    /// pointer here because of the lifetime issues in the rfold implementations.\n-    ptr: *mut T,\n-    /// The number of *uninitialized* elements.\n-    uninit: usize,\n-}\n-\n-impl<T, const N: usize> BackGuard<T, N> {\n-    unsafe fn new(array: &mut [MaybeUninit<T>; N]) -> Self {\n-        Self { ptr: MaybeUninit::slice_as_mut_ptr(array), uninit: N }\n-    }\n-}\n-\n-impl<T, const N: usize> Drop for BackGuard<T, N> {\n-    fn drop(&mut self) {\n-        debug_assert!(self.uninit <= N);\n-        // SAFETY: This raw slice will only contain the initialized objects\n-        // within the buffer.\n-        unsafe {\n-            let ptr = self.ptr.offset(self.uninit as isize);\n-            let slice = ptr::slice_from_raw_parts_mut(ptr, N - self.uninit);\n-            ptr::drop_in_place(slice);\n-        }\n+        // We used `.rev()` above, so we need to re-reverse the reminder\n+        remainder.as_mut_slice().reverse();\n+        self.remainder = Some(remainder);\n     }\n }\n "}]}