{"sha": "cc3c8bbfaf5af19caf3deb131a995a65ca4674f9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNjM2M4YmJmYWY1YWYxOWNhZjNkZWIxMzFhOTk1YTY1Y2E0Njc0Zjk=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-07-01T15:37:54Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-07-05T19:45:42Z"}, "message": "rustc: Add a flag for specifying dependencies\n\nThis comit implements a new flag, --extern, which is used to specify where a\ncrate is located. The purpose of this flag is to bypass the normal crate\nloading/matching of the compiler to point it directly at the right file.\n\nThis flag takes the form `--extern foo=bar` where `foo` is the name of a crate\nand `bar` is the location at which to find the crate. Multiple `--extern`\ndirectives are allowed with the same crate name to specify the rlib/dylib pair\nfor a crate. It is invalid to specify more than one rlib or more than one dylib,\nand it's required that the crates are valid rust crates.\n\nI have also added some extensive documentation to metadata::loader about how\ncrate loading should work.\n\nRFC: 0035-remove-crate-id", "tree": {"sha": "736c2fddddef10a410d8cafa4092b754504aafbd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/736c2fddddef10a410d8cafa4092b754504aafbd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cc3c8bbfaf5af19caf3deb131a995a65ca4674f9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cc3c8bbfaf5af19caf3deb131a995a65ca4674f9", "html_url": "https://github.com/rust-lang/rust/commit/cc3c8bbfaf5af19caf3deb131a995a65ca4674f9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cc3c8bbfaf5af19caf3deb131a995a65ca4674f9/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "df4ea9c39a355e4cff425cca7d58e7758cb3461c", "url": "https://api.github.com/repos/rust-lang/rust/commits/df4ea9c39a355e4cff425cca7d58e7758cb3461c", "html_url": "https://github.com/rust-lang/rust/commit/df4ea9c39a355e4cff425cca7d58e7758cb3461c"}], "stats": {"total": 459, "additions": 444, "deletions": 15}, "files": [{"sha": "497fcab44e1bde7a8c4c54327e2920d07c1dd9e1", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cc3c8bbfaf5af19caf3deb131a995a65ca4674f9/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc3c8bbfaf5af19caf3deb131a995a65ca4674f9/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=cc3c8bbfaf5af19caf3deb131a995a65ca4674f9", "patch": "@@ -588,10 +588,11 @@ pub fn find_crate_name(sess: Option<&Session>,\n     }), None)\n }\n \n-pub fn build_link_meta(krate: &ast::Crate, name: String) -> LinkMeta {\n+pub fn build_link_meta(sess: &Session, krate: &ast::Crate,\n+                       name: String) -> LinkMeta {\n     let r = LinkMeta {\n         crate_name: name,\n-        crate_hash: Svh::calculate(krate),\n+        crate_hash: Svh::calculate(sess, krate),\n     };\n     info!(\"{}\", r);\n     return r;"}, {"sha": "24b9ff970aa220a513447ba38ade1517da2b4917", "filename": "src/librustc/back/svh.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cc3c8bbfaf5af19caf3deb131a995a65ca4674f9/src%2Flibrustc%2Fback%2Fsvh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc3c8bbfaf5af19caf3deb131a995a65ca4674f9/src%2Flibrustc%2Fback%2Fsvh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Fsvh.rs?ref=cc3c8bbfaf5af19caf3deb131a995a65ca4674f9", "patch": "@@ -53,6 +53,8 @@ use std::iter::range_step;\n use syntax::ast;\n use syntax::visit;\n \n+use driver::session::Session;\n+\n #[deriving(Clone, PartialEq)]\n pub struct Svh {\n     hash: String,\n@@ -68,7 +70,7 @@ impl Svh {\n         self.hash.as_slice()\n     }\n \n-    pub fn calculate(krate: &ast::Crate) -> Svh {\n+    pub fn calculate(sess: &Session, krate: &ast::Crate) -> Svh {\n         // FIXME (#14132): This is better than it used to be, but it still not\n         // ideal. We now attempt to hash only the relevant portions of the\n         // Crate AST as well as the top-level crate attributes. (However,\n@@ -80,6 +82,10 @@ impl Svh {\n         //        avoid collisions.\n         let mut state = SipState::new();\n \n+        for data in sess.opts.cg.metadata.iter() {\n+            data.hash(&mut state);\n+        }\n+\n         {\n             let mut visit = svh_visitor::make(&mut state);\n             visit::walk_crate(&mut visit, krate, ());"}, {"sha": "72875735864950cffdce7c1701cfdbc4012b70ec", "filename": "src/librustc/driver/config.rs", "status": "modified", "additions": 23, "deletions": 3, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/cc3c8bbfaf5af19caf3deb131a995a65ca4674f9/src%2Flibrustc%2Fdriver%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc3c8bbfaf5af19caf3deb131a995a65ca4674f9/src%2Flibrustc%2Fdriver%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fconfig.rs?ref=cc3c8bbfaf5af19caf3deb131a995a65ca4674f9", "patch": "@@ -30,7 +30,7 @@ use syntax::diagnostic::{ColorConfig, Auto, Always, Never};\n use syntax::parse;\n use syntax::parse::token::InternedString;\n \n-use std::collections::HashSet;\n+use std::collections::{HashSet, HashMap};\n use getopts::{optopt, optmulti, optflag, optflagopt};\n use getopts;\n use lib::llvm::llvm;\n@@ -95,6 +95,7 @@ pub struct Options {\n     pub print_metas: (bool, bool),\n     pub cg: CodegenOptions,\n     pub color: ColorConfig,\n+    pub externs: HashMap<String, Vec<String>>,\n }\n \n /// Some reasonable defaults\n@@ -120,6 +121,7 @@ pub fn basic_options() -> Options {\n         print_metas: (false, false),\n         cg: basic_codegen_options(),\n         color: Auto,\n+        externs: HashMap::new(),\n     }\n }\n \n@@ -551,7 +553,9 @@ pub fn optgroups() -> Vec<getopts::OptGroup> {\n         optopt(\"\", \"color\", \"Configure coloring of output:\n             auto   = colorize, if output goes to a tty (default);\n             always = always colorize output;\n-            never  = never colorize output\", \"auto|always|never\")\n+            never  = never colorize output\", \"auto|always|never\"),\n+        optmulti(\"\", \"extern\", \"Specify where an external rust library is located\",\n+                 \"PATH\"),\n     )\n }\n \n@@ -730,6 +734,21 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n         }\n     };\n \n+    let mut externs = HashMap::new();\n+    for arg in matches.opt_strs(\"extern\").iter() {\n+        let mut parts = arg.as_slice().splitn('=', 1);\n+        let name = match parts.next() {\n+            Some(s) => s,\n+            None => early_error(\"--extern value must not be empty\"),\n+        };\n+        let location = match parts.next() {\n+            Some(s) => s,\n+            None => early_error(\"--extern value must be of the format `foo=bar`\"),\n+        };\n+        let locs = externs.find_or_insert(name.to_string(), Vec::new());\n+        locs.push(location.to_string());\n+    }\n+\n     Options {\n         crate_types: crate_types,\n         gc: gc,\n@@ -750,7 +769,8 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n         write_dependency_info: write_dependency_info,\n         print_metas: print_metas,\n         cg: cg,\n-        color: color\n+        color: color,\n+        externs: externs,\n     }\n }\n "}, {"sha": "7d3d67df6d15768ee6e2bbd0cec72614c7eeffa2", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 27, "deletions": 5, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/cc3c8bbfaf5af19caf3deb131a995a65ca4674f9/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc3c8bbfaf5af19caf3deb131a995a65ca4674f9/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=cc3c8bbfaf5af19caf3deb131a995a65ca4674f9", "patch": "@@ -280,12 +280,32 @@ fn existing_match(e: &Env, name: &str,\n                   hash: Option<&Svh>) -> Option<ast::CrateNum> {\n     let mut ret = None;\n     e.sess.cstore.iter_crate_data(|cnum, data| {\n-        if data.name().as_slice() == name {\n-            let other_hash = data.hash();\n-            match hash {\n-                Some(hash) if *hash != other_hash => {}\n-                Some(..) | None => { ret = Some(cnum); }\n+        if data.name().as_slice() != name { return }\n+\n+        match hash {\n+            Some(hash) if *hash == data.hash() => { ret = Some(cnum); return }\n+            Some(..) => return,\n+            None => {}\n+        }\n+\n+        // When the hash is None we're dealing with a top-level dependency in\n+        // which case we may have a specification on the command line for this\n+        // library. Even though an upstream library may have loaded something of\n+        // the same name, we have to make sure it was loaded from the exact same\n+        // location as well.\n+        let source = e.sess.cstore.get_used_crate_source(cnum).unwrap();\n+        let dylib = source.dylib.as_ref().map(|p| p.as_vec());\n+        let rlib = source.rlib.as_ref().map(|p| p.as_vec());\n+        match e.sess.opts.externs.find_equiv(&name) {\n+            Some(locs) => {\n+                let found = locs.iter().any(|l| {\n+                    Some(l.as_bytes()) == dylib || Some(l.as_bytes()) == rlib\n+                });\n+                if found {\n+                    ret = Some(cnum);\n+                }\n             }\n+            None => ret = Some(cnum),\n         }\n     });\n     return ret;\n@@ -361,6 +381,7 @@ fn resolve_crate<'a>(e: &mut Env,\n                 root: root,\n                 rejected_via_hash: vec!(),\n                 rejected_via_triple: vec!(),\n+                should_match_name: true,\n             };\n             let library = load_ctxt.load_library_crate();\n             register_crate(e, root, ident, name, span, library)\n@@ -422,6 +443,7 @@ impl<'a> PluginMetadataReader<'a> {\n             root: &None,\n             rejected_via_hash: vec!(),\n             rejected_via_triple: vec!(),\n+            should_match_name: true,\n         };\n         let library = match load_ctxt.maybe_load_library_crate() {\n             Some (l) => l,"}, {"sha": "1b2349a271ed1a6ed6b776b597d83af09388b08a", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 281, "deletions": 3, "changes": 284, "blob_url": "https://github.com/rust-lang/rust/blob/cc3c8bbfaf5af19caf3deb131a995a65ca4674f9/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc3c8bbfaf5af19caf3deb131a995a65ca4674f9/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=cc3c8bbfaf5af19caf3deb131a995a65ca4674f9", "patch": "@@ -9,6 +9,208 @@\n // except according to those terms.\n \n //! Finds crate binaries and loads their metadata\n+//!\n+//! Might I be the first to welcome you to a world of platform differences,\n+//! version requirements, dependency graphs, conficting desires, and fun! This\n+//! is the major guts (along with metadata::creader) of the compiler for loading\n+//! crates and resolving dependencies. Let's take a tour!\n+//!\n+//! # The problem\n+//!\n+//! Each invocation of the compiler is immediately concerned with one primary\n+//! problem, to connect a set of crates to resolved crates on the filesystem.\n+//! Concretely speaking, the compiler follows roughly these steps to get here:\n+//!\n+//! 1. Discover a set of `extern crate` statements.\n+//! 2. Transform these directives into crate names. If the directive does not\n+//!    have an explicit name, then the identifier is the name.\n+//! 3. For each of these crate names, find a corresponding crate on the\n+//!    filesystem.\n+//!\n+//! Sounds easy, right? Let's walk into some of the nuances.\n+//!\n+//! ## Transitive Dependencies\n+//!\n+//! Let's say we've got three crates: A, B, and C. A depends on B, and B depends\n+//! on C. When we're compiling A, we primarily need to find and locate B, but we\n+//! also end up needing to find and locate C as well.\n+//!\n+//! The reason for this is that any of B's types could be composed of C's types,\n+//! any function in B could return a type from C, etc. To be able to guarantee\n+//! that we can always typecheck/translate any function, we have to have\n+//! complete knowledge of the whole ecosystem, not just our immediate\n+//! dependencies.\n+//!\n+//! So now as part of the \"find a corresponding crate on the filesystem\" step\n+//! above, this involves also finding all crates for *all upstream\n+//! dependencies*. This includes all dependencies transitively.\n+//!\n+//! ## Rlibs and Dylibs\n+//!\n+//! The compiler has two forms of intermediate dependencies. These are dubbed\n+//! rlibs and dylibs for the static and dynamic variants, respectively. An rlib\n+//! is a rustc-defined file format (currently just an ar archive) while a dylib\n+//! is a platform-defined dynamic library. Each library has a metadata somewhere\n+//! inside of it.\n+//!\n+//! When translating a crate name to a crate on the filesystem, we all of a\n+//! sudden need to take into account both rlibs and dylibs! Linkage later on may\n+//! use either one of these files, as each has their pros/cons. The job of crate\n+//! loading is to discover what's possible by finding all candidates.\n+//!\n+//! Most parts of this loading systems keep the dylib/rlib as just separate\n+//! variables.\n+//!\n+//! ## Where to look?\n+//!\n+//! We can't exactly scan your whole hard drive when looking for dependencies,\n+//! so we need to places to look. Currently the compiler will implicitly add the\n+//! target lib search path ($prefix/lib/rustlib/$target/lib) to any compilation,\n+//! and otherwise all -L flags are added to the search paths.\n+//!\n+//! ## What criterion to select on?\n+//!\n+//! This a pretty tricky area of loading crates. Given a file, how do we know\n+//! whether it's the right crate? Currently, the rules look along these lines:\n+//!\n+//! 1. Does the filename match an rlib/dylib pattern? That is to say, does the\n+//!    filename have the right prefix/suffix?\n+//! 2. Does the filename have the right prefix for the crate name being queried?\n+//!    This is filtering for files like `libfoo*.rlib` and such.\n+//! 3. Is the file an actual rust library? This is done by loading the metadata\n+//!    from the library and making sure it's actually there.\n+//! 4. Does the name in the metadata agree with the name of the library?\n+//! 5. Does the target in the metadata agree with the current target?\n+//! 6. Does the SVH match? (more on this later)\n+//!\n+//! If the file answeres `yes` to all these questions, then the file is\n+//! considered as being *candidate* for being accepted. It is illegal to have\n+//! more than two candidates as the compiler has no method by which to resolve\n+//! this conflict. Additionally, rlib/dylib candidates are considered\n+//! separately.\n+//!\n+//! After all this has happened, we have 1 or two files as candidates. These\n+//! represent the rlib/dylib file found for a library, and they're returned as\n+//! being found.\n+//!\n+//! ### What about versions?\n+//!\n+//! A lot of effort has been put forth to remove versioning from the compiler.\n+//! There have been forays in the past to have versioning baked in, but it was\n+//! largely always deemed insufficient to the point that it was recognized that\n+//! it's probably something the compiler shouldn't do anyway due to its\n+//! complicated nature and the state of the half-baked solutions.\n+//!\n+//! With a departure from versioning, the primary criterion for loading crates\n+//! is just the name of a crate. If we stopped here, it would imply that you\n+//! could never link two crates of the same name from different sources\n+//! together, which is clearly a bad state to be in.\n+//!\n+//! To resolve this problem, we come to the next section!\n+//!\n+//! # Expert Mode\n+//!\n+//! A number of flags have been added to the compiler to solve the \"version\n+//! problem\" in the previous section, as well as generally enabling more\n+//! powerful usage of the crate loading system of the compiler. The goal of\n+//! these flags and options are to enable third-party tools to drive the\n+//! compiler with prior knowledge about how the world should look.\n+//!\n+//! ## The `--extern` flag\n+//!\n+//! The compiler accepts a flag of this form a number of times:\n+//!\n+//! ```notrust\n+//! --extern crate-name=path/to/the/crate.rlib\n+//! ```\n+//!\n+//! This flag is basically the following letter to the compiler:\n+//!\n+//! > Dear rustc,\n+//! >\n+//! > When you are attempting to load the immediate dependency `crate-name`, I\n+//! > would like you too assume that the library is located at\n+//! > `path/to/the/crate.rlib`, and look nowhere else. Also, please do not\n+//! > assume that the path I specified has the name `crate-name`.\n+//!\n+//! This flag basically overrides most matching logic except for validating that\n+//! the file is indeed a rust library. The same `crate-name` can be specified\n+//! twice to specify the rlib/dylib pair.\n+//!\n+//! ## Enabling \"multiple versions\"\n+//!\n+//! This basically boils down to the ability to specify arbitrary packages to\n+//! the compiler. For example, if crate A wanted to use Bv1 and Bv2, then it\n+//! would look something like:\n+//!\n+//! ```ignore\n+//! extern crate b1;\n+//! extern crate b2;\n+//!\n+//! fn main() {}\n+//! ```\n+//!\n+//! and the compiler would be invoked as:\n+//!\n+//! ```notrust\n+//! rustc a.rs --extern b1=path/to/libb1.rlib --extern b2=path/to/libb2.rlib\n+//! ```\n+//!\n+//! In this scenario there are two crates named `b` and the compiler must be\n+//! manually driven to be informed where each crate is.\n+//!\n+//! ## Frobbing symbols\n+//!\n+//! One of the immediate problems with linking the same library together twice\n+//! in the same problem is dealing with duplicate symbols. The primary way to\n+//! deal with this in rustc is to add hashes to the end of each symbol.\n+//!\n+//! In order to force hashes to change between versions of a library, if\n+//! desired, the compiler exposes an option `-C metadata=foo`, which is used to\n+//! initially seed each symbol hash. The string `foo` is prepended to each\n+//! string-to-hash to ensure that symbols change over time.\n+//!\n+//! ## Loading transitive dependencies\n+//!\n+//! Dealing with same-named-but-distinct crates is not just a local problem, but\n+//! one that also needs to be dealt with for transitive dependences. Note that\n+//! in the letter above `--extern` flags only apply to the *local* set of\n+//! dependencies, not the upstream transitive dependencies. Consider this\n+//! dependency graph:\n+//!\n+//! ```notrust\n+//! A.1   A.2\n+//! |     |\n+//! |     |\n+//! B     C\n+//!  \\   /\n+//!   \\ /\n+//!    D\n+//! ```\n+//!\n+//! In this scenario, when we compile `D`, we need to be able to distinctly\n+//! resolve `A.1` and `A.2`, but an `--extern` flag cannot apply to these\n+//! transitive dependencies.\n+//!\n+//! Note that the key idea here is that `B` and `C` are both *already compiled*.\n+//! That is, they have already resolved their dependencies. Due to unrelated\n+//! technical reasons, when a library is compiled, it is only compatible with\n+//! the *exact same* version of the upstream libraries it was compiled against.\n+//! We use the \"Strict Version Hash\" to identify the exact copy of an upstream\n+//! library.\n+//!\n+//! With this knowledge, we know that `B` and `C` will depend on `A` with\n+//! different SVH values, so we crawl the normal `-L` paths looking for\n+//! `liba*.rlib` and filter based on the contained SVH.\n+//!\n+//! In the end, this ends up not needing `--extern` to specify upstream\n+//! transitive dependencies.\n+//!\n+//! # Wrapping up\n+//!\n+//! That's the general overview of loading crates in the compiler, but it's by\n+//! no means all of the necessary details. Take a look at the rest of\n+//! metadata::loader or metadata::creader for all the juicy details!\n \n use back::archive::{ArchiveRO, METADATA_FILENAME};\n use back::svh::Svh;\n@@ -67,6 +269,7 @@ pub struct Context<'a> {\n     pub root: &'a Option<CratePaths>,\n     pub rejected_via_hash: Vec<CrateMismatch>,\n     pub rejected_via_triple: Vec<CrateMismatch>,\n+    pub should_match_name: bool,\n }\n \n pub struct Library {\n@@ -164,6 +367,17 @@ impl<'a> Context<'a> {\n     }\n \n     fn find_library_crate(&mut self) -> Option<Library> {\n+        // If an SVH is specified, then this is a transitive dependency that\n+        // must be loaded via -L plus some filtering.\n+        if self.hash.is_none() {\n+            self.should_match_name = false;\n+            match self.find_commandline_library() {\n+                Some(l) => return Some(l),\n+                None => {}\n+            }\n+            self.should_match_name = true;\n+        }\n+\n         let dypair = self.dylibname();\n \n         // want: crate_name.dir_part() + prefix + crate_name.file_part + \"-\"\n@@ -348,9 +562,11 @@ impl<'a> Context<'a> {\n     }\n \n     fn crate_matches(&mut self, crate_data: &[u8], libpath: &Path) -> bool {\n-        match decoder::maybe_get_crate_name(crate_data) {\n-            Some(ref name) if self.crate_name == name.as_slice() => {}\n-            _ => { info!(\"Rejecting via crate name\"); return false }\n+        if self.should_match_name {\n+            match decoder::maybe_get_crate_name(crate_data) {\n+                Some(ref name) if self.crate_name == name.as_slice() => {}\n+                _ => { info!(\"Rejecting via crate name\"); return false }\n+            }\n         }\n         let hash = match decoder::maybe_get_crate_hash(crate_data) {\n             Some(hash) => hash, None => {\n@@ -403,6 +619,68 @@ impl<'a> Context<'a> {\n         }\n     }\n \n+    fn find_commandline_library(&mut self) -> Option<Library> {\n+        let locs = match self.sess.opts.externs.find_equiv(&self.crate_name) {\n+            Some(s) => s,\n+            None => return None,\n+        };\n+\n+        // First, filter out all libraries that look suspicious. We only accept\n+        // files which actually exist that have the correct naming scheme for\n+        // rlibs/dylibs.\n+        let sess = self.sess;\n+        let dylibname = self.dylibname();\n+        let mut locs = locs.iter().map(|l| Path::new(l.as_slice())).filter(|loc| {\n+            if !loc.exists() {\n+                sess.err(format!(\"extern location does not exist: {}\",\n+                                 loc.display()).as_slice());\n+                return false;\n+            }\n+            let file = loc.filename_str().unwrap();\n+            if file.starts_with(\"lib\") && file.ends_with(\".rlib\") {\n+                return true\n+            } else {\n+                match dylibname {\n+                    Some((prefix, suffix)) => {\n+                        if file.starts_with(prefix) && file.ends_with(suffix) {\n+                            return true\n+                        }\n+                    }\n+                    None => {}\n+                }\n+            }\n+            sess.err(format!(\"extern location is of an unknown type: {}\",\n+                             loc.display()).as_slice());\n+            false\n+        });\n+\n+        // Now that we have an itertor of good candidates, make sure there's at\n+        // most one rlib and at most one dylib.\n+        let mut rlibs = HashSet::new();\n+        let mut dylibs = HashSet::new();\n+        for loc in locs {\n+            if loc.filename_str().unwrap().ends_with(\".rlib\") {\n+                rlibs.insert(loc.clone());\n+            } else {\n+                dylibs.insert(loc.clone());\n+            }\n+        }\n+\n+        // Extract the rlib/dylib pair.\n+        let mut metadata = None;\n+        let rlib = self.extract_one(rlibs, \"rlib\", &mut metadata);\n+        let dylib = self.extract_one(dylibs, \"dylib\", &mut metadata);\n+\n+        if rlib.is_none() && dylib.is_none() { return None }\n+        match metadata {\n+            Some(metadata) => Some(Library {\n+                dylib: dylib,\n+                rlib: rlib,\n+                metadata: metadata,\n+            }),\n+            None => None,\n+        }\n+    }\n }\n \n pub fn note_crate_name(diag: &SpanHandler, name: &str) {"}, {"sha": "d371a2589ffd53ca26f4b8035248af354959c385", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc3c8bbfaf5af19caf3deb131a995a65ca4674f9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc3c8bbfaf5af19caf3deb131a995a65ca4674f9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=cc3c8bbfaf5af19caf3deb131a995a65ca4674f9", "patch": "@@ -2309,7 +2309,7 @@ pub fn trans_crate(krate: ast::Crate,\n         }\n     }\n \n-    let link_meta = link::build_link_meta(&krate, name);\n+    let link_meta = link::build_link_meta(&tcx.sess, &krate, name);\n \n     // Append \".rs\" to crate name as LLVM module identifier.\n     //"}, {"sha": "9b86bf9754956eea9a883510df3604c506923956", "filename": "src/test/run-make/extern-flag-disambiguates/Makefile", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/cc3c8bbfaf5af19caf3deb131a995a65ca4674f9/src%2Ftest%2Frun-make%2Fextern-flag-disambiguates%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/cc3c8bbfaf5af19caf3deb131a995a65ca4674f9/src%2Ftest%2Frun-make%2Fextern-flag-disambiguates%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fextern-flag-disambiguates%2FMakefile?ref=cc3c8bbfaf5af19caf3deb131a995a65ca4674f9", "patch": "@@ -0,0 +1,24 @@\n+-include ../tools.mk\n+\n+# Attempt to build this dependency tree:\n+#\n+#\tA.1   A.2\n+#\t |\\    |\n+#\t | \\   |\n+#        B  \\  C\n+#         \\ | /\n+#          \\|/\n+#           D\n+#\n+# Note that A.1 and A.2 are crates with the same name.\n+\n+all:\n+\t$(RUSTC) -C metadata=1 -C extra-filename=-1 a.rs\n+\t$(RUSTC) -C metadata=2 -C extra-filename=-2 a.rs\n+\t$(RUSTC) b.rs --extern a=$(TMPDIR)/liba-1.rlib\n+\t$(RUSTC) c.rs --extern a=$(TMPDIR)/liba-2.rlib\n+\t$(RUSTC) --cfg before d.rs --extern a=$(TMPDIR)/liba-1.rlib\n+\t$(call RUN,d)\n+\t$(RUSTC) --cfg after  d.rs --extern a=$(TMPDIR)/liba-1.rlib\n+\t$(call RUN,d)\n+"}, {"sha": "db1a0e0433ece380ce0e1f4e81a714d6e6f370db", "filename": "src/test/run-make/extern-flag-disambiguates/a.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cc3c8bbfaf5af19caf3deb131a995a65ca4674f9/src%2Ftest%2Frun-make%2Fextern-flag-disambiguates%2Fa.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc3c8bbfaf5af19caf3deb131a995a65ca4674f9/src%2Ftest%2Frun-make%2Fextern-flag-disambiguates%2Fa.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fextern-flag-disambiguates%2Fa.rs?ref=cc3c8bbfaf5af19caf3deb131a995a65ca4674f9", "patch": "@@ -0,0 +1,6 @@\n+#![crate_name = \"a\"]\n+#![crate_type = \"rlib\"]\n+\n+static FOO: uint = 3;\n+\n+pub fn token() -> &'static uint { &FOO }"}, {"sha": "f4fb09631a9c7690be8231a6f3fe4bfc27924858", "filename": "src/test/run-make/extern-flag-disambiguates/b.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/cc3c8bbfaf5af19caf3deb131a995a65ca4674f9/src%2Ftest%2Frun-make%2Fextern-flag-disambiguates%2Fb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc3c8bbfaf5af19caf3deb131a995a65ca4674f9/src%2Ftest%2Frun-make%2Fextern-flag-disambiguates%2Fb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fextern-flag-disambiguates%2Fb.rs?ref=cc3c8bbfaf5af19caf3deb131a995a65ca4674f9", "patch": "@@ -0,0 +1,9 @@\n+#![crate_name = \"b\"]\n+#![crate_type = \"rlib\"]\n+\n+extern crate a;\n+\n+static FOO: uint = 3;\n+\n+pub fn token() -> &'static uint { &FOO }\n+pub fn a_token() -> &'static uint { a::token() }"}, {"sha": "e017d747e6fe4ff248d30ab81bc76d3840d7034f", "filename": "src/test/run-make/extern-flag-disambiguates/c.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/cc3c8bbfaf5af19caf3deb131a995a65ca4674f9/src%2Ftest%2Frun-make%2Fextern-flag-disambiguates%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc3c8bbfaf5af19caf3deb131a995a65ca4674f9/src%2Ftest%2Frun-make%2Fextern-flag-disambiguates%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fextern-flag-disambiguates%2Fc.rs?ref=cc3c8bbfaf5af19caf3deb131a995a65ca4674f9", "patch": "@@ -0,0 +1,9 @@\n+#![crate_name = \"c\"]\n+#![crate_type = \"rlib\"]\n+\n+extern crate a;\n+\n+static FOO: uint = 3;\n+\n+pub fn token() -> &'static uint { &FOO }\n+pub fn a_token() -> &'static uint { a::token() }"}, {"sha": "e3c968edb6a9fcb3cd026eeba502dfbbe679eaf4", "filename": "src/test/run-make/extern-flag-disambiguates/d.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/cc3c8bbfaf5af19caf3deb131a995a65ca4674f9/src%2Ftest%2Frun-make%2Fextern-flag-disambiguates%2Fd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc3c8bbfaf5af19caf3deb131a995a65ca4674f9/src%2Ftest%2Frun-make%2Fextern-flag-disambiguates%2Fd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fextern-flag-disambiguates%2Fd.rs?ref=cc3c8bbfaf5af19caf3deb131a995a65ca4674f9", "patch": "@@ -0,0 +1,11 @@\n+#[cfg(before)] extern crate a;\n+extern crate b;\n+extern crate c;\n+#[cfg(after)] extern crate a;\n+\n+fn t(a: &'static uint) -> uint { a as *const _ as uint }\n+\n+fn main() {\n+    assert!(t(a::token()) == t(b::a_token()));\n+    assert!(t(a::token()) != t(c::a_token()));\n+}"}, {"sha": "ca5aa052a7b3bfae152722eef6dc627b0933c2c4", "filename": "src/test/run-make/extern-flag-fun/Makefile", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/cc3c8bbfaf5af19caf3deb131a995a65ca4674f9/src%2Ftest%2Frun-make%2Fextern-flag-fun%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/cc3c8bbfaf5af19caf3deb131a995a65ca4674f9/src%2Ftest%2Frun-make%2Fextern-flag-fun%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fextern-flag-fun%2FMakefile?ref=cc3c8bbfaf5af19caf3deb131a995a65ca4674f9", "patch": "@@ -0,0 +1,16 @@\n+-include ../tools.mk\n+\n+all:\n+\t$(RUSTC) bar.rs --crate-type=rlib\n+\t$(RUSTC) bar.rs --crate-type=rlib -C extra-filename=-a\n+\t$(RUSTC) foo.rs --extern hello && exit 1 || exit 0\n+\t$(RUSTC) foo.rs --extern bar=no-exist && exit 1 || exit 0\n+\t$(RUSTC) foo.rs --extern bar=foo.rs && exit 1 || exit 0\n+\t$(RUSTC) foo.rs \\\n+\t\t--extern bar=$(TMPDIR)/libbar.rlib \\\n+\t\t--extern bar=$(TMPDIR)/libbar-a.rlib \\\n+\t\t&& exit 1 || exit 0\n+\t$(RUSTC) foo.rs \\\n+\t\t--extern bar=$(TMPDIR)/libbar.rlib \\\n+\t\t--extern bar=$(TMPDIR)/libbar.rlib\n+\t$(RUSTC) foo.rs --extern bar=$(TMPDIR)/libbar.rlib"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "src/test/run-make/extern-flag-fun/bar.rs", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/cc3c8bbfaf5af19caf3deb131a995a65ca4674f9/src%2Ftest%2Frun-make%2Fextern-flag-fun%2Fbar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc3c8bbfaf5af19caf3deb131a995a65ca4674f9/src%2Ftest%2Frun-make%2Fextern-flag-fun%2Fbar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fextern-flag-fun%2Fbar.rs?ref=cc3c8bbfaf5af19caf3deb131a995a65ca4674f9"}, {"sha": "0edda7d7b8842debbdd5417ed08d904c00d9c956", "filename": "src/test/run-make/extern-flag-fun/foo.rs", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cc3c8bbfaf5af19caf3deb131a995a65ca4674f9/src%2Ftest%2Frun-make%2Fextern-flag-fun%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc3c8bbfaf5af19caf3deb131a995a65ca4674f9/src%2Ftest%2Frun-make%2Fextern-flag-fun%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fextern-flag-fun%2Ffoo.rs?ref=cc3c8bbfaf5af19caf3deb131a995a65ca4674f9", "patch": "@@ -0,0 +1,3 @@\n+extern crate bar;\n+\n+fn main() {}"}, {"sha": "09e6ae0bbf7cd01f578084b768dd967d7f02d505", "filename": "src/test/run-make/metadata-flag-frobs-symbols/Makefile", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cc3c8bbfaf5af19caf3deb131a995a65ca4674f9/src%2Ftest%2Frun-make%2Fmetadata-flag-frobs-symbols%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/cc3c8bbfaf5af19caf3deb131a995a65ca4674f9/src%2Ftest%2Frun-make%2Fmetadata-flag-frobs-symbols%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fmetadata-flag-frobs-symbols%2FMakefile?ref=cc3c8bbfaf5af19caf3deb131a995a65ca4674f9", "patch": "@@ -0,0 +1,10 @@\n+-include ../tools.mk\n+\n+all:\n+\t$(RUSTC) foo.rs -C metadata=a -C extra-filename=-a\n+\t$(RUSTC) foo.rs -C metadata=b -C extra-filename=-b\n+\t$(RUSTC) bar.rs \\\n+\t\t--extern foo1=$(TMPDIR)/libfoo-a.rlib \\\n+\t\t--extern foo2=$(TMPDIR)/libfoo-b.rlib \\\n+\t\t-Z print-link-args\n+\t$(call RUN,bar)"}, {"sha": "1e6957a3694b60bd0b86bced1d9867e7d4fc4754", "filename": "src/test/run-make/metadata-flag-frobs-symbols/bar.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cc3c8bbfaf5af19caf3deb131a995a65ca4674f9/src%2Ftest%2Frun-make%2Fmetadata-flag-frobs-symbols%2Fbar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc3c8bbfaf5af19caf3deb131a995a65ca4674f9/src%2Ftest%2Frun-make%2Fmetadata-flag-frobs-symbols%2Fbar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fmetadata-flag-frobs-symbols%2Fbar.rs?ref=cc3c8bbfaf5af19caf3deb131a995a65ca4674f9", "patch": "@@ -0,0 +1,8 @@\n+extern crate foo1;\n+extern crate foo2;\n+\n+fn main() {\n+    let a = foo1::foo();\n+    let b = foo2::foo();\n+    assert!(a as *const _ != b as *const _);\n+}"}, {"sha": "1974f4bc56284dcefe47dae90800862b88a712b3", "filename": "src/test/run-make/metadata-flag-frobs-symbols/foo.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cc3c8bbfaf5af19caf3deb131a995a65ca4674f9/src%2Ftest%2Frun-make%2Fmetadata-flag-frobs-symbols%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc3c8bbfaf5af19caf3deb131a995a65ca4674f9/src%2Ftest%2Frun-make%2Fmetadata-flag-frobs-symbols%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fmetadata-flag-frobs-symbols%2Ffoo.rs?ref=cc3c8bbfaf5af19caf3deb131a995a65ca4674f9", "patch": "@@ -0,0 +1,6 @@\n+#![crate_name = \"foo\"]\n+#![crate_type = \"rlib\"]\n+\n+static FOO: uint = 3;\n+\n+pub fn foo() -> &'static uint { &FOO }"}]}