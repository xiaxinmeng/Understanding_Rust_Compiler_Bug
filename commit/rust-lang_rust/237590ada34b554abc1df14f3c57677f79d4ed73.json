{"sha": "237590ada34b554abc1df14f3c57677f79d4ed73", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIzNzU5MGFkYTM0YjU1NGFiYzFkZjE0ZjNjNTc2NzdmNzlkNGVkNzM=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2017-09-13T16:32:39Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-09-13T16:32:39Z"}, "message": "Merge pull request #336 from RalfJung/mir-validate\n\nValiation: Identify write locks using an abstract lvalue", "tree": {"sha": "29a75d3936d75596312cf6ed5943ed3f616d637f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/29a75d3936d75596312cf6ed5943ed3f616d637f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/237590ada34b554abc1df14f3c57677f79d4ed73", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/237590ada34b554abc1df14f3c57677f79d4ed73", "html_url": "https://github.com/rust-lang/rust/commit/237590ada34b554abc1df14f3c57677f79d4ed73", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/237590ada34b554abc1df14f3c57677f79d4ed73/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "02a943b3fb5966aa326b1ec9986d568ec422c668", "url": "https://api.github.com/repos/rust-lang/rust/commits/02a943b3fb5966aa326b1ec9986d568ec422c668", "html_url": "https://github.com/rust-lang/rust/commit/02a943b3fb5966aa326b1ec9986d568ec422c668"}, {"sha": "5d2ed4d2ba8a41ad7a7caa2e0672921f36174c9d", "url": "https://api.github.com/repos/rust-lang/rust/commits/5d2ed4d2ba8a41ad7a7caa2e0672921f36174c9d", "html_url": "https://github.com/rust-lang/rust/commit/5d2ed4d2ba8a41ad7a7caa2e0672921f36174c9d"}], "stats": {"total": 728, "additions": 426, "deletions": 302}, "files": [{"sha": "190e3018c7f415656c9a2b044e2519a8cecd1567", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/237590ada34b554abc1df14f3c57677f79d4ed73/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/237590ada34b554abc1df14f3c57677f79d4ed73/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=237590ada34b554abc1df14f3c57677f79d4ed73", "patch": "@@ -618,7 +618,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         }\n         for (field_index, operand) in operands.iter().enumerate() {\n             let value = self.eval_operand(operand)?;\n-            let field_dest = self.lvalue_field(dest, field_index, dest_ty, value.ty)?;\n+            let field_dest = self.lvalue_field(dest, mir::Field::new(field_index), dest_ty, value.ty)?;\n             self.write_value(value, field_dest)?;\n         }\n         Ok(())\n@@ -1466,7 +1466,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n \n     /// ensures this Value is not a ByRef\n     pub(super) fn follow_by_ref_value(\n-        &mut self,\n+        &self,\n         value: Value,\n         ty: Ty<'tcx>,\n     ) -> EvalResult<'tcx, Value> {\n@@ -1479,7 +1479,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n     }\n \n     pub fn value_to_primval(\n-        &mut self,\n+        &self,\n         ValTy { value, ty } : ValTy<'tcx>,\n     ) -> EvalResult<'tcx, PrimVal> {\n         match self.follow_by_ref_value(value, ty)? {"}, {"sha": "7fb6ac4209f179c6099579b7d41d22d7a56c92b4", "filename": "src/librustc_mir/interpret/lvalue.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/237590ada34b554abc1df14f3c57677f79d4ed73/src%2Flibrustc_mir%2Finterpret%2Flvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/237590ada34b554abc1df14f3c57677f79d4ed73/src%2Flibrustc_mir%2Finterpret%2Flvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Flvalue.rs?ref=237590ada34b554abc1df14f3c57677f79d4ed73", "patch": "@@ -218,12 +218,14 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n     pub fn lvalue_field(\n         &mut self,\n         base: Lvalue,\n-        field_index: usize,\n+        field: mir::Field,\n         base_ty: Ty<'tcx>,\n         field_ty: Ty<'tcx>,\n     ) -> EvalResult<'tcx, Lvalue> {\n-        let base_layout = self.type_layout(base_ty)?;\n         use rustc::ty::layout::Layout::*;\n+\n+        let base_layout = self.type_layout(base_ty)?;\n+        let field_index = field.index();\n         let (offset, packed) = match *base_layout {\n             Univariant { ref variant, .. } => (variant.offsets[field_index], variant.packed),\n \n@@ -405,7 +407,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         use rustc::mir::ProjectionElem::*;\n         let (ptr, extra) = match *proj_elem {\n             Field(field, field_ty) => {\n-                return self.lvalue_field(base, field.index(), base_ty, field_ty);\n+                return self.lvalue_field(base, field, base_ty, field_ty);\n             }\n \n             Downcast(_, variant) => {"}, {"sha": "bde79294adda50781d83abf8db995c44224352ae", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 86, "deletions": 53, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/237590ada34b554abc1df14f3c57677f79d4ed73/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/237590ada34b554abc1df14f3c57677f79d4ed73/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=237590ada34b554abc1df14f3c57677f79d4ed73", "patch": "@@ -9,7 +9,7 @@ use syntax::ast::Mutability;\n use rustc::middle::region;\n \n use super::{EvalResult, EvalErrorKind, PrimVal, Pointer, EvalContext, DynamicLifetime, Machine,\n-            RangeMap};\n+            RangeMap, AbsLvalue};\n \n ////////////////////////////////////////////////////////////////////////////////\n // Locks\n@@ -23,14 +23,29 @@ pub enum AccessKind {\n \n /// Information about a lock that is currently held.\n #[derive(Clone, Debug)]\n-struct LockInfo {\n+struct LockInfo<'tcx> {\n     /// Stores for which lifetimes (of the original write lock) we got\n     /// which suspensions.\n-    suspended: HashMap<DynamicLifetime, Vec<region::Scope>>,\n+    suspended: HashMap<WriteLockId<'tcx>, Vec<region::Scope>>,\n     /// The current state of the lock that's actually effective.\n     active: Lock,\n }\n \n+/// Write locks are identified by a stack frame and an \"abstract\" (untyped) lvalue.\n+/// It may be tempting to use the lifetime as identifier, but that does not work\n+/// for two reasons:\n+/// * First of all, due to subtyping, the same lock may be referred to with different\n+///   lifetimes.\n+/// * Secondly, different write locks may actually have the same lifetime.  See `test2`\n+///   in `run-pass/many_shr_bor.rs`.\n+/// The Id is \"captured\" when the lock is first suspended; at that point, the borrow checker\n+/// considers the path frozen and hence the Id remains stable.\n+#[derive(Clone, Debug, PartialEq, Eq, Hash)]\n+struct WriteLockId<'tcx> {\n+    frame: usize,\n+    path: AbsLvalue<'tcx>,\n+}\n+\n #[derive(Clone, Debug, PartialEq)]\n pub enum Lock {\n     NoLock,\n@@ -39,14 +54,14 @@ pub enum Lock {\n }\n use self::Lock::*;\n \n-impl Default for LockInfo {\n+impl<'tcx> Default for LockInfo<'tcx> {\n     fn default() -> Self {\n         LockInfo::new(NoLock)\n     }\n }\n \n-impl LockInfo {\n-    fn new(lock: Lock) -> LockInfo {\n+impl<'tcx> LockInfo<'tcx> {\n+    fn new(lock: Lock) -> LockInfo<'tcx> {\n         LockInfo {\n             suspended: HashMap::new(),\n             active: lock,\n@@ -128,7 +143,7 @@ impl fmt::Debug for AllocId {\n }\n \n #[derive(Debug)]\n-pub struct Allocation<M> {\n+pub struct Allocation<'tcx, M> {\n     /// The actual bytes of the allocation.\n     /// Note that the bytes of a pointer represent the offset of the pointer\n     pub bytes: Vec<u8>,\n@@ -146,17 +161,17 @@ pub struct Allocation<M> {\n     /// Helps guarantee that stack allocations aren't deallocated via `rust_deallocate`\n     pub kind: MemoryKind<M>,\n     /// Memory regions that are locked by some function\n-    locks: RangeMap<LockInfo>,\n+    locks: RangeMap<LockInfo<'tcx>>,\n }\n \n-impl<M> Allocation<M> {\n-    fn check_locks<'tcx>(\n+impl<'tcx, M> Allocation<'tcx, M> {\n+    fn check_locks(\n         &self,\n         frame: Option<usize>,\n         offset: u64,\n         len: u64,\n         access: AccessKind,\n-    ) -> Result<(), LockInfo> {\n+    ) -> Result<(), LockInfo<'tcx>> {\n         if len == 0 {\n             return Ok(());\n         }\n@@ -237,7 +252,7 @@ pub struct Memory<'a, 'tcx, M: Machine<'tcx>> {\n     pub data: M::MemoryData,\n \n     /// Actual memory allocations (arbitrary bytes, may contain pointers into other allocations).\n-    alloc_map: HashMap<u64, Allocation<M::MemoryKinds>>,\n+    alloc_map: HashMap<u64, Allocation<'tcx, M::MemoryKinds>>,\n \n     /// The AllocId to assign to the next new regular allocation. Always incremented, never gets smaller.\n     next_alloc_id: u64,\n@@ -610,62 +625,72 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n \n     /// Release or suspend a write lock of the given lifetime prematurely.\n     /// When releasing, if there is a read lock or someone else's write lock, that's an error.\n-    /// We *do* accept relasing a NoLock, as this can happen when a local is first acquired and later force_allocate'd.\n+    /// If no lock is held, that's fine.  This can happen when e.g. a local is initialized\n+    /// from a constant, and then suspended.\n     /// When suspending, the same cases are fine; we just register an additional suspension.\n     pub(crate) fn suspend_write_lock(\n         &mut self,\n         ptr: MemoryPointer,\n         len: u64,\n-        lock_region: Option<region::Scope>,\n+        lock_path: &AbsLvalue<'tcx>,\n         suspend: Option<region::Scope>,\n     ) -> EvalResult<'tcx> {\n         assert!(len > 0);\n         let cur_frame = self.cur_frame;\n-        let lock_lft = DynamicLifetime {\n-            frame: cur_frame,\n-            region: lock_region,\n-        };\n         let alloc = self.get_mut_unchecked(ptr.alloc_id)?;\n \n         'locks: for lock in alloc.locks.iter_mut(ptr.offset, len) {\n             let is_our_lock = match lock.active {\n-                WriteLock(lft) => lft == lock_lft,\n+                WriteLock(lft) =>\n+                    // Double-check that we are holding the lock.\n+                    // (Due to subtyping, checking the region would not make any sense.)\n+                    lft.frame == cur_frame,\n                 ReadLock(_) | NoLock => false,\n             };\n             if is_our_lock {\n-                trace!(\"Releasing {:?} at {:?}\", lock.active, lock_lft);\n+                trace!(\"Releasing {:?}\", lock.active);\n                 // Disable the lock\n                 lock.active = NoLock;\n             } else {\n                 trace!(\n-                    \"Not touching {:?} at {:?} as its not our lock\",\n+                    \"Not touching {:?} as it is not our lock\",\n                     lock.active,\n-                    lock_lft\n                 );\n             }\n-            match suspend {\n-                Some(suspend_region) => {\n-                    trace!(\"Adding suspension to {:?} at {:?}\", lock.active, lock_lft);\n-                    // We just released this lock, so add a new suspension.\n-                    // FIXME: Really, if there ever already is a suspension when is_our_lock, or if there is no suspension when !is_our_lock, something is amiss.\n-                    // But this model is not good enough yet to prevent that.\n-                    lock.suspended\n-                        .entry(lock_lft)\n-                        .or_insert_with(|| Vec::new())\n-                        .push(suspend_region);\n+            // Check if we want to register a suspension\n+            if let Some(suspend_region) = suspend {\n+                let lock_id = WriteLockId {\n+                    frame: cur_frame,\n+                    path: lock_path.clone(),\n+                };\n+                trace!(\"Adding suspension to {:?}\", lock_id);\n+                let mut new_suspension = false;\n+                lock.suspended\n+                    .entry(lock_id)\n+                    // Remember whether we added a new suspension or not\n+                    .or_insert_with(|| { new_suspension = true; Vec::new() })\n+                    .push(suspend_region);\n+                // If the suspension is new, we should have owned this.\n+                // If there already was a suspension, we should NOT have owned this.\n+                if new_suspension == is_our_lock {\n+                    // All is well\n+                    continue 'locks;\n                 }\n-                None => {\n-                    // Make sure we did not try to release someone else's lock.\n-                    if !is_our_lock && lock.active != NoLock {\n-                        return err!(InvalidMemoryLockRelease {\n-                            ptr,\n-                            len,\n-                            frame: cur_frame,\n-                            lock: lock.active.clone(),\n-                        });\n-                    }\n+            } else {\n+                if !is_our_lock {\n+                    // All is well.\n+                    continue 'locks;\n                 }\n             }\n+            // If we get here, releasing this is an error except for NoLock.\n+            if lock.active != NoLock {\n+                return err!(InvalidMemoryLockRelease {\n+                    ptr,\n+                    len,\n+                    frame: cur_frame,\n+                    lock: lock.active.clone(),\n+                });\n+            }\n         }\n \n         Ok(())\n@@ -676,26 +701,27 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n         &mut self,\n         ptr: MemoryPointer,\n         len: u64,\n+        lock_path: &AbsLvalue<'tcx>,\n         lock_region: Option<region::Scope>,\n         suspended_region: region::Scope,\n     ) -> EvalResult<'tcx> {\n         assert!(len > 0);\n         let cur_frame = self.cur_frame;\n-        let lock_lft = DynamicLifetime {\n+        let lock_id = WriteLockId {\n             frame: cur_frame,\n-            region: lock_region,\n+            path: lock_path.clone(),\n         };\n         let alloc = self.get_mut_unchecked(ptr.alloc_id)?;\n \n         for lock in alloc.locks.iter_mut(ptr.offset, len) {\n             // Check if we have a suspension here\n-            let (got_the_lock, remove_suspension) = match lock.suspended.get_mut(&lock_lft) {\n+            let (got_the_lock, remove_suspension) = match lock.suspended.get_mut(&lock_id) {\n                 None => {\n                     trace!(\"No suspension around, we can just acquire\");\n                     (true, false)\n                 }\n                 Some(suspensions) => {\n-                    trace!(\"Found suspension of {:?}, removing it\", lock_lft);\n+                    trace!(\"Found suspension of {:?}, removing it\", lock_id);\n                     // That's us!  Remove suspension (it should be in there).  The same suspension can\n                     // occur multiple times (when there are multiple shared borrows of this that have the same\n                     // lifetime); only remove one of them.\n@@ -715,12 +741,17 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n             if remove_suspension {\n                 // with NLL, we could do that up in the match above...\n                 assert!(got_the_lock);\n-                lock.suspended.remove(&lock_lft);\n+                lock.suspended.remove(&lock_id);\n             }\n             if got_the_lock {\n                 match lock.active {\n                     ref mut active @ NoLock => {\n-                        *active = WriteLock(lock_lft);\n+                        *active = WriteLock(\n+                            DynamicLifetime {\n+                                frame: cur_frame,\n+                                region: lock_region,\n+                            }\n+                        );\n                     }\n                     _ => {\n                         return err!(MemoryAcquireConflict {\n@@ -770,8 +801,10 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n                 if lock_ended {\n                     lock.active = NoLock;\n                 }\n-                // Also clean up suspended write locks\n-                lock.suspended.retain(|lft, _suspensions| !has_ended(lft));\n+                // Also clean up suspended write locks when the function returns\n+                if ending_region.is_none() {\n+                    lock.suspended.retain(|id, _suspensions| id.frame != cur_frame);\n+                }\n             }\n             // Clean up the map\n             alloc.locks.retain(|lock| match lock.active {\n@@ -784,7 +817,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n \n /// Allocation accessors\n impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n-    pub fn get(&self, id: AllocId) -> EvalResult<'tcx, &Allocation<M::MemoryKinds>> {\n+    pub fn get(&self, id: AllocId) -> EvalResult<'tcx, &Allocation<'tcx, M::MemoryKinds>> {\n         match id.into_alloc_id_kind() {\n             AllocIdKind::Function(_) => err!(DerefFunctionPointer),\n             AllocIdKind::Runtime(id) => {\n@@ -799,7 +832,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n     fn get_mut_unchecked(\n         &mut self,\n         id: AllocId,\n-    ) -> EvalResult<'tcx, &mut Allocation<M::MemoryKinds>> {\n+    ) -> EvalResult<'tcx, &mut Allocation<'tcx, M::MemoryKinds>> {\n         match id.into_alloc_id_kind() {\n             AllocIdKind::Function(_) => err!(DerefFunctionPointer),\n             AllocIdKind::Runtime(id) => {\n@@ -811,7 +844,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n         }\n     }\n \n-    fn get_mut(&mut self, id: AllocId) -> EvalResult<'tcx, &mut Allocation<M::MemoryKinds>> {\n+    fn get_mut(&mut self, id: AllocId) -> EvalResult<'tcx, &mut Allocation<'tcx, M::MemoryKinds>> {\n         let alloc = self.get_mut_unchecked(id)?;\n         if alloc.mutable == Mutability::Mutable {\n             Ok(alloc)"}, {"sha": "08837c4fb6d7805abab6ebb03141285421e0d749", "filename": "src/librustc_mir/interpret/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/237590ada34b554abc1df14f3c57677f79d4ed73/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/237590ada34b554abc1df14f3c57677f79d4ed73/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmod.rs?ref=237590ada34b554abc1df14f3c57677f79d4ed73", "patch": "@@ -39,4 +39,4 @@ pub use self::const_eval::{eval_body_as_integer, eval_body_as_primval};\n \n pub use self::machine::Machine;\n \n-pub use self::validation::ValidationQuery;\n+pub use self::validation::{ValidationQuery, AbsLvalue};"}, {"sha": "251bd71ffceff2be4c114e742b6cc2f776b6995a", "filename": "src/librustc_mir/interpret/validation.rs", "status": "modified", "additions": 290, "deletions": 214, "changes": 504, "blob_url": "https://github.com/rust-lang/rust/blob/237590ada34b554abc1df14f3c57677f79d4ed73/src%2Flibrustc_mir%2Finterpret%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/237590ada34b554abc1df14f3c57677f79d4ed73/src%2Flibrustc_mir%2Finterpret%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidation.rs?ref=237590ada34b554abc1df14f3c57677f79d4ed73", "patch": "@@ -1,4 +1,4 @@\n-use rustc::hir::Mutability;\n+use rustc::hir::{self, Mutability};\n use rustc::hir::Mutability::*;\n use rustc::mir::{self, ValidationOp, ValidationOperand};\n use rustc::ty::{self, Ty, TypeFoldable, TyCtxt};\n@@ -7,11 +7,12 @@ use rustc::traits;\n use rustc::infer::InferCtxt;\n use rustc::traits::Reveal;\n use rustc::middle::region;\n+use rustc_data_structures::indexed_vec::Idx;\n \n use super::{EvalError, EvalResult, EvalErrorKind, EvalContext, DynamicLifetime, AccessKind, Value,\n-            Lvalue, LvalueExtra, Machine};\n+            Lvalue, LvalueExtra, Machine, ValTy};\n \n-pub type ValidationQuery<'tcx> = ValidationOperand<'tcx, Lvalue>;\n+pub type ValidationQuery<'tcx> = ValidationOperand<'tcx, (AbsLvalue<'tcx>, Lvalue)>;\n \n #[derive(Copy, Clone, Debug, PartialEq)]\n enum ValidationMode {\n@@ -31,8 +32,77 @@ impl ValidationMode {\n     }\n }\n \n-// Validity checks\n+// Abstract lvalues\n+#[derive(Clone, Debug, PartialEq, Eq, Hash)]\n+pub enum AbsLvalue<'tcx> {\n+    Local(mir::Local),\n+    Static(hir::def_id::DefId),\n+    Projection(Box<AbsLvalueProjection<'tcx>>),\n+}\n+\n+type AbsLvalueProjection<'tcx> = mir::Projection<'tcx, AbsLvalue<'tcx>, u64, ()>;\n+type AbsLvalueElem<'tcx> = mir::ProjectionElem<'tcx, u64, ()>;\n+\n+impl<'tcx> AbsLvalue<'tcx> {\n+    pub fn field(self, f: mir::Field) -> AbsLvalue<'tcx> {\n+        self.elem(mir::ProjectionElem::Field(f, ()))\n+    }\n+\n+    pub fn deref(self) -> AbsLvalue<'tcx> {\n+        self.elem(mir::ProjectionElem::Deref)\n+    }\n+\n+    pub fn downcast(self, adt_def: &'tcx ty::AdtDef, variant_index: usize) -> AbsLvalue<'tcx> {\n+        self.elem(mir::ProjectionElem::Downcast(adt_def, variant_index))\n+    }\n+\n+    pub fn index(self, index: u64) -> AbsLvalue<'tcx> {\n+        self.elem(mir::ProjectionElem::Index(index))\n+    }\n+\n+    fn elem(self, elem: AbsLvalueElem<'tcx>) -> AbsLvalue<'tcx> {\n+        AbsLvalue::Projection(Box::new(AbsLvalueProjection {\n+            base: self,\n+            elem,\n+        }))\n+    }\n+}\n+\n impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n+    fn abstract_lvalue_projection(&self, proj: &mir::LvalueProjection<'tcx>) -> EvalResult<'tcx, AbsLvalueProjection<'tcx>> {\n+        use self::mir::ProjectionElem::*;\n+\n+        let elem = match proj.elem {\n+            Deref => Deref,\n+            Field(f, _) => Field(f, ()),\n+            Index(v) => {\n+                let value = self.frame().get_local(v)?;\n+                let ty = self.tcx.types.usize;\n+                let n = self.value_to_primval(ValTy { value, ty })?.to_u64()?;\n+                Index(n)\n+            },\n+            ConstantIndex { offset, min_length, from_end } =>\n+                ConstantIndex { offset, min_length, from_end },\n+            Subslice { from, to } =>\n+                Subslice { from, to },\n+            Downcast(adt, sz) => Downcast(adt, sz),\n+        };\n+        Ok(AbsLvalueProjection {\n+            base: self.abstract_lvalue(&proj.base)?,\n+            elem\n+        })\n+    }\n+\n+    fn abstract_lvalue(&self, lval: &mir::Lvalue<'tcx>) -> EvalResult<'tcx, AbsLvalue<'tcx>> {\n+        Ok(match lval {\n+            &mir::Lvalue::Local(l) => AbsLvalue::Local(l),\n+            &mir::Lvalue::Static(ref s) => AbsLvalue::Static(s.def_id),\n+            &mir::Lvalue::Projection(ref p) =>\n+                AbsLvalue::Projection(Box::new(self.abstract_lvalue_projection(&*p)?)),\n+        })\n+    }\n+\n+    // Validity checks\n     pub(crate) fn validation_op(\n         &mut self,\n         op: ValidationOp,\n@@ -56,8 +126,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n             use regex::Regex;\n             lazy_static! {\n                 static ref RE: Regex = Regex::new(\"^(\\\n-                    (std|alloc::heap::__core)::mem::uninitialized::|\\\n-                    (std|alloc::heap::__core)::mem::forget::|\\\n+                    (std|alloc::heap::__core)::mem::(uninitialized|forget)::|\\\n                     <(std|alloc)::heap::Heap as (std::heap|alloc::allocator)::Alloc>::|\\\n                     <(std|alloc::heap::__core)::mem::ManuallyDrop<T>><.*>::new$|\\\n                     <(std|alloc::heap::__core)::mem::ManuallyDrop<T> as std::ops::DerefMut><.*>::deref_mut$|\\\n@@ -79,8 +148,9 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         // We need to monomorphize ty *without* erasing lifetimes\n         let ty = operand.ty.subst(self.tcx, self.substs());\n         let lval = self.eval_lvalue(&operand.lval)?;\n+        let abs_lval = self.abstract_lvalue(&operand.lval)?;\n         let query = ValidationQuery {\n-            lval,\n+            lval: (abs_lval, lval),\n             ty,\n             re: operand.re,\n             mutbl: operand.mutbl,\n@@ -264,12 +334,13 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         mode: ValidationMode,\n     ) -> EvalResult<'tcx> {\n         // TODO: Maybe take visibility/privacy into account.\n-        for (idx, field) in variant.fields.iter().enumerate() {\n-            let field_ty = field.ty(self.tcx, subst);\n-            let field_lvalue = self.lvalue_field(query.lval, idx, query.ty, field_ty)?;\n+        for (idx, field_def) in variant.fields.iter().enumerate() {\n+            let field_ty = field_def.ty(self.tcx, subst);\n+            let field = mir::Field::new(idx);\n+            let field_lvalue = self.lvalue_field(query.lval.1, field, query.ty, field_ty)?;\n             self.validate(\n                 ValidationQuery {\n-                    lval: field_lvalue,\n+                    lval: (query.lval.0.clone().field(field), field_lvalue),\n                     ty: field_ty,\n                     ..query\n                 },\n@@ -282,6 +353,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n     fn validate_ptr(\n         &mut self,\n         val: Value,\n+        abs_lval: AbsLvalue<'tcx>,\n         pointee_ty: Ty<'tcx>,\n         re: Option<region::Scope>,\n         mutbl: Mutability,\n@@ -296,7 +368,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         let pointee_lvalue = self.val_to_lvalue(val, pointee_ty)?;\n         self.validate(\n             ValidationQuery {\n-                lval: pointee_lvalue,\n+                lval: (abs_lval.deref(), pointee_lvalue),\n                 ty: pointee_ty,\n                 re,\n                 mutbl,\n@@ -306,23 +378,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n     }\n \n     /// Validate the lvalue at the given type. If `acquire` is false, just do a release of all write locks\n-    #[inline]\n-    fn validate(&mut self, query: ValidationQuery<'tcx>, mode: ValidationMode) -> EvalResult<'tcx> {\n-        match self.try_validate(query, mode) {\n-            // ReleaseUntil(None) of an uninitalized variable is a NOP.  This is needed because\n-            // we have to release the return value of a function; due to destination-passing-style\n-            // the callee may directly write there.\n-            // TODO: Ideally we would know whether the destination is already initialized, and only\n-            // release if it is.  But of course that can't even always be statically determined.\n-            Err(EvalError { kind: EvalErrorKind::ReadUndefBytes, .. })\n-                if mode == ValidationMode::ReleaseUntil(None) => {\n-                return Ok(());\n-            }\n-            res => res,\n-        }\n-    }\n-\n-    fn try_validate(\n+    fn validate(\n         &mut self,\n         mut query: ValidationQuery<'tcx>,\n         mode: ValidationMode,\n@@ -345,7 +401,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         // HACK: For now, bail out if we hit a dead local during recovery (can happen because sometimes we have\n         // StorageDead before EndRegion due to https://github.com/rust-lang/rust/issues/43481).\n         // TODO: We should rather fix the MIR.\n-        match query.lval {\n+        match query.lval.1 {\n             Lvalue::Local { frame, local } => {\n                 let res = self.stack[frame].get_local(local);\n                 match (res, mode) {\n@@ -380,7 +436,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n             // Tracking the same state for locals not backed by memory would just duplicate too\n             // much machinery.\n             // FIXME: We ignore alignment.\n-            let (ptr, extra) = self.force_allocation(query.lval)?.to_ptr_extra_aligned();\n+            let (ptr, extra) = self.force_allocation(query.lval.1)?.to_ptr_extra_aligned();\n             // Determine the size\n             // FIXME: Can we reuse size_and_align_of_dst for Lvalues?\n             let len = match self.type_size(query.ty)? {\n@@ -431,6 +487,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                                 self.memory.recover_write_lock(\n                                     ptr,\n                                     len,\n+                                    &query.lval.0,\n                                     query.re,\n                                     ending_ce,\n                                 )?\n@@ -439,7 +496,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                                 self.memory.suspend_write_lock(\n                                     ptr,\n                                     len,\n-                                    query.re,\n+                                    &query.lval.0,\n                                     suspended_ce,\n                                 )?\n                             }\n@@ -449,206 +506,225 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n             }\n         }\n \n-        match query.ty.sty {\n-            TyInt(_) | TyUint(_) | TyRawPtr(_) => {\n-                // TODO: Make sure these are not undef.\n-                // We could do a bounds-check and other sanity checks on the lvalue, but it would be a bug in miri for this to ever fail.\n-                Ok(())\n-            }\n-            TyBool | TyFloat(_) | TyChar | TyStr => {\n-                // TODO: Check if these are valid bool/float/codepoint/UTF-8, respectively (and in particular, not undef).\n-                Ok(())\n-            }\n-            TyNever => err!(ValidationFailure(format!(\"The empty type is never valid.\"))),\n-            TyRef(region,\n-                  ty::TypeAndMut {\n-                      ty: pointee_ty,\n-                      mutbl,\n-                  }) => {\n-                let val = self.read_lvalue(query.lval)?;\n-                // Sharing restricts our context\n-                if mutbl == MutImmutable {\n-                    query.mutbl = MutImmutable;\n+        let res = do catch {\n+            match query.ty.sty {\n+                TyInt(_) | TyUint(_) | TyRawPtr(_) => {\n+                    // TODO: Make sure these are not undef.\n+                    // We could do a bounds-check and other sanity checks on the lvalue, but it would be a bug in miri for this to ever fail.\n+                    Ok(())\n                 }\n-                // Inner lifetimes *outlive* outer ones, so only if we have no lifetime restriction yet,\n-                // we record the region of this borrow to the context.\n-                if query.re == None {\n-                    match *region {\n-                        ReScope(scope) => query.re = Some(scope),\n-                        // It is possible for us to encounter erased lifetimes here because the lifetimes in\n-                        // this functions' Subst will be erased.\n-                        _ => {}\n+                TyBool | TyFloat(_) | TyChar | TyStr => {\n+                    // TODO: Check if these are valid bool/float/codepoint/UTF-8, respectively (and in particular, not undef).\n+                    Ok(())\n+                }\n+                TyNever => err!(ValidationFailure(format!(\"The empty type is never valid.\"))),\n+                TyRef(region,\n+                    ty::TypeAndMut {\n+                        ty: pointee_ty,\n+                        mutbl,\n+                    }) => {\n+                    let val = self.read_lvalue(query.lval.1)?;\n+                    // Sharing restricts our context\n+                    if mutbl == MutImmutable {\n+                        query.mutbl = MutImmutable;\n+                    }\n+                    // Inner lifetimes *outlive* outer ones, so only if we have no lifetime restriction yet,\n+                    // we record the region of this borrow to the context.\n+                    if query.re == None {\n+                        match *region {\n+                            ReScope(scope) => query.re = Some(scope),\n+                            // It is possible for us to encounter erased lifetimes here because the lifetimes in\n+                            // this functions' Subst will be erased.\n+                            _ => {}\n+                        }\n                     }\n+                    self.validate_ptr(val, query.lval.0, pointee_ty, query.re, query.mutbl, mode)\n+                }\n+                TyAdt(adt, _) if adt.is_box() => {\n+                    let val = self.read_lvalue(query.lval.1)?;\n+                    self.validate_ptr(val, query.lval.0, query.ty.boxed_ty(), query.re, query.mutbl, mode)\n+                }\n+                TyFnPtr(_sig) => {\n+                    let ptr = self.read_lvalue(query.lval.1)?\n+                        .into_ptr(&self.memory)?\n+                        .to_ptr()?;\n+                    self.memory.get_fn(ptr)?;\n+                    // TODO: Check if the signature matches (should be the same check as what terminator/mod.rs already does on call?).\n+                    Ok(())\n+                }\n+                TyFnDef(..) => {\n+                    // This is a zero-sized type with all relevant data sitting in the type.\n+                    // There is nothing to validate.\n+                    Ok(())\n                 }\n-                self.validate_ptr(val, pointee_ty, query.re, query.mutbl, mode)\n-            }\n-            TyAdt(adt, _) if adt.is_box() => {\n-                let val = self.read_lvalue(query.lval)?;\n-                self.validate_ptr(val, query.ty.boxed_ty(), query.re, query.mutbl, mode)\n-            }\n-            TyFnPtr(_sig) => {\n-                let ptr = self.read_lvalue(query.lval)?\n-                    .into_ptr(&self.memory)?\n-                    .to_ptr()?;\n-                self.memory.get_fn(ptr)?;\n-                // TODO: Check if the signature matches (should be the same check as what terminator/mod.rs already does on call?).\n-                Ok(())\n-            }\n-            TyFnDef(..) => {\n-                // This is a zero-sized type with all relevant data sitting in the type.\n-                // There is nothing to validate.\n-                Ok(())\n-            }\n \n-            // Compound types\n-            TySlice(elem_ty) => {\n-                let len = match query.lval {\n-                    Lvalue::Ptr { extra: LvalueExtra::Length(len), .. } => len,\n-                    _ => {\n-                        bug!(\n-                            \"acquire_valid of a TySlice given non-slice lvalue: {:?}\",\n-                            query.lval\n-                        )\n+                // Compound types\n+                TySlice(elem_ty) => {\n+                    let len = match query.lval.1 {\n+                        Lvalue::Ptr { extra: LvalueExtra::Length(len), .. } => len,\n+                        _ => {\n+                            bug!(\n+                                \"acquire_valid of a TySlice given non-slice lvalue: {:?}\",\n+                                query.lval\n+                            )\n+                        }\n+                    };\n+                    for i in 0..len {\n+                        let inner_lvalue = self.lvalue_index(query.lval.1, query.ty, i)?;\n+                        self.validate(\n+                            ValidationQuery {\n+                                lval: (query.lval.0.clone().index(i), inner_lvalue),\n+                                ty: elem_ty,\n+                                ..query\n+                            },\n+                            mode,\n+                        )?;\n                     }\n-                };\n-                for i in 0..len {\n-                    let inner_lvalue = self.lvalue_index(query.lval, query.ty, i)?;\n-                    self.validate(\n-                        ValidationQuery {\n-                            lval: inner_lvalue,\n-                            ty: elem_ty,\n-                            ..query\n-                        },\n-                        mode,\n-                    )?;\n-                }\n-                Ok(())\n-            }\n-            TyArray(elem_ty, len) => {\n-                let len = len.val.to_const_int().unwrap().to_u64().unwrap();\n-                for i in 0..len {\n-                    let inner_lvalue = self.lvalue_index(query.lval, query.ty, i as u64)?;\n-                    self.validate(\n-                        ValidationQuery {\n-                            lval: inner_lvalue,\n-                            ty: elem_ty,\n-                            ..query\n-                        },\n-                        mode,\n-                    )?;\n+                    Ok(())\n                 }\n-                Ok(())\n-            }\n-            TyDynamic(_data, _region) => {\n-                // Check that this is a valid vtable\n-                let vtable = match query.lval {\n-                    Lvalue::Ptr { extra: LvalueExtra::Vtable(vtable), .. } => vtable,\n-                    _ => {\n-                        bug!(\n-                            \"acquire_valid of a TyDynamic given non-trait-object lvalue: {:?}\",\n-                            query.lval\n-                        )\n+                TyArray(elem_ty, len) => {\n+                    let len = len.val.to_const_int().unwrap().to_u64().unwrap();\n+                    for i in 0..len {\n+                        let inner_lvalue = self.lvalue_index(query.lval.1, query.ty, i as u64)?;\n+                        self.validate(\n+                            ValidationQuery {\n+                                lval: (query.lval.0.clone().index(i as u64), inner_lvalue),\n+                                ty: elem_ty,\n+                                ..query\n+                            },\n+                            mode,\n+                        )?;\n                     }\n-                };\n-                self.read_size_and_align_from_vtable(vtable)?;\n-                // TODO: Check that the vtable contains all the function pointers we expect it to have.\n-                // Trait objects cannot have any operations performed\n-                // on them directly.  We cannot, in general, even acquire any locks as the trait object *could*\n-                // contain an UnsafeCell.  If we call functions to get access to data, we will validate\n-                // their return values.  So, it doesn't seem like there's anything else to do.\n-                Ok(())\n-            }\n-            TyAdt(adt, subst) => {\n-                if Some(adt.did) == self.tcx.lang_items().unsafe_cell_type() &&\n-                    query.mutbl == MutImmutable\n-                {\n-                    // No locks for shared unsafe cells.  Also no other validation, the only field is private anyway.\n-                    return Ok(());\n+                    Ok(())\n                 }\n-\n-                match adt.adt_kind() {\n-                    AdtKind::Enum => {\n-                        // TODO: Can we get the discriminant without forcing an allocation?\n-                        let ptr = self.force_allocation(query.lval)?.to_ptr()?;\n-                        let discr = self.read_discriminant_value(ptr, query.ty)?;\n-\n-                        // Get variant index for discriminant\n-                        let variant_idx = adt.discriminants(self.tcx).position(|variant_discr| {\n-                            variant_discr.to_u128_unchecked() == discr\n-                        });\n-                        let variant_idx = match variant_idx {\n-                            Some(val) => val,\n-                            None => return err!(InvalidDiscriminant),\n-                        };\n-                        let variant = &adt.variants[variant_idx];\n-\n-                        if variant.fields.len() > 0 {\n-                            // Downcast to this variant, if needed\n-                            let lval = if adt.variants.len() > 1 {\n-                                self.eval_lvalue_projection(\n-                                    query.lval,\n-                                    query.ty,\n-                                    &mir::ProjectionElem::Downcast(adt, variant_idx),\n-                                )?\n-                            } else {\n+                TyDynamic(_data, _region) => {\n+                    // Check that this is a valid vtable\n+                    let vtable = match query.lval.1 {\n+                        Lvalue::Ptr { extra: LvalueExtra::Vtable(vtable), .. } => vtable,\n+                        _ => {\n+                            bug!(\n+                                \"acquire_valid of a TyDynamic given non-trait-object lvalue: {:?}\",\n                                 query.lval\n-                            };\n-\n-                            // Recursively validate the fields\n-                            self.validate_variant(\n-                                ValidationQuery { lval, ..query },\n-                                variant,\n-                                subst,\n-                                mode,\n                             )\n-                        } else {\n-                            // No fields, nothing left to check.  Downcasting may fail, e.g. in case of a CEnum.\n-                            Ok(())\n                         }\n+                    };\n+                    self.read_size_and_align_from_vtable(vtable)?;\n+                    // TODO: Check that the vtable contains all the function pointers we expect it to have.\n+                    // Trait objects cannot have any operations performed\n+                    // on them directly.  We cannot, in general, even acquire any locks as the trait object *could*\n+                    // contain an UnsafeCell.  If we call functions to get access to data, we will validate\n+                    // their return values.  So, it doesn't seem like there's anything else to do.\n+                    Ok(())\n+                }\n+                TyAdt(adt, subst) => {\n+                    if Some(adt.did) == self.tcx.lang_items().unsafe_cell_type() &&\n+                        query.mutbl == MutImmutable\n+                    {\n+                        // No locks for shared unsafe cells.  Also no other validation, the only field is private anyway.\n+                        return Ok(());\n                     }\n-                    AdtKind::Struct => {\n-                        self.validate_variant(query, adt.struct_variant(), subst, mode)\n+\n+                    match adt.adt_kind() {\n+                        AdtKind::Enum => {\n+                            // TODO: Can we get the discriminant without forcing an allocation?\n+                            let ptr = self.force_allocation(query.lval.1)?.to_ptr()?;\n+                            let discr = self.read_discriminant_value(ptr, query.ty)?;\n+\n+                            // Get variant index for discriminant\n+                            let variant_idx = adt.discriminants(self.tcx).position(|variant_discr| {\n+                                variant_discr.to_u128_unchecked() == discr\n+                            });\n+                            let variant_idx = match variant_idx {\n+                                Some(val) => val,\n+                                None => return err!(InvalidDiscriminant),\n+                            };\n+                            let variant = &adt.variants[variant_idx];\n+\n+                            if variant.fields.len() > 0 {\n+                                // Downcast to this variant, if needed\n+                                let lval = if adt.variants.len() > 1 {\n+                                    (\n+                                        query.lval.0.downcast(adt, variant_idx),\n+                                        self.eval_lvalue_projection(\n+                                            query.lval.1,\n+                                            query.ty,\n+                                            &mir::ProjectionElem::Downcast(adt, variant_idx),\n+                                        )?,\n+                                    )\n+                                } else {\n+                                    query.lval\n+                                };\n+\n+                                // Recursively validate the fields\n+                                self.validate_variant(\n+                                    ValidationQuery { lval, ..query },\n+                                    variant,\n+                                    subst,\n+                                    mode,\n+                                )\n+                            } else {\n+                                // No fields, nothing left to check.  Downcasting may fail, e.g. in case of a CEnum.\n+                                Ok(())\n+                            }\n+                        }\n+                        AdtKind::Struct => {\n+                            self.validate_variant(query, adt.struct_variant(), subst, mode)\n+                        }\n+                        AdtKind::Union => {\n+                            // No guarantees are provided for union types.\n+                            // TODO: Make sure that all access to union fields is unsafe; otherwise, we may have some checking to do (but what exactly?)\n+                            Ok(())\n+                        }\n                     }\n-                    AdtKind::Union => {\n-                        // No guarantees are provided for union types.\n-                        // TODO: Make sure that all access to union fields is unsafe; otherwise, we may have some checking to do (but what exactly?)\n-                        Ok(())\n+                }\n+                TyTuple(ref types, _) => {\n+                    for (idx, field_ty) in types.iter().enumerate() {\n+                        let field = mir::Field::new(idx);\n+                        let field_lvalue = self.lvalue_field(query.lval.1, field, query.ty, field_ty)?;\n+                        self.validate(\n+                            ValidationQuery {\n+                                lval: (query.lval.0.clone().field(field), field_lvalue),\n+                                ty: field_ty,\n+                                ..query\n+                            },\n+                            mode,\n+                        )?;\n                     }\n+                    Ok(())\n                 }\n-            }\n-            TyTuple(ref types, _) => {\n-                for (idx, field_ty) in types.iter().enumerate() {\n-                    let field_lvalue = self.lvalue_field(query.lval, idx, query.ty, field_ty)?;\n-                    self.validate(\n-                        ValidationQuery {\n-                            lval: field_lvalue,\n-                            ty: field_ty,\n-                            ..query\n-                        },\n-                        mode,\n-                    )?;\n+                TyClosure(def_id, ref closure_substs) => {\n+                    for (idx, field_ty) in closure_substs.upvar_tys(def_id, self.tcx).enumerate() {\n+                        let field = mir::Field::new(idx);\n+                        let field_lvalue = self.lvalue_field(query.lval.1, field, query.ty, field_ty)?;\n+                        self.validate(\n+                            ValidationQuery {\n+                                lval: (query.lval.0.clone().field(field), field_lvalue),\n+                                ty: field_ty,\n+                                ..query\n+                            },\n+                            mode,\n+                        )?;\n+                    }\n+                    // TODO: Check if the signature matches (should be the same check as what terminator/mod.rs already does on call?).\n+                    // Is there other things we can/should check?  Like vtable pointers?\n+                    Ok(())\n                 }\n-                Ok(())\n+                // FIXME: generators aren't validated right now\n+                TyGenerator(..) => Ok(()),\n+                _ => bug!(\"We already established that this is a type we support. ({})\", query.ty),\n             }\n-            TyClosure(def_id, ref closure_substs) => {\n-                for (idx, field_ty) in closure_substs.upvar_tys(def_id, self.tcx).enumerate() {\n-                    let field_lvalue = self.lvalue_field(query.lval, idx, query.ty, field_ty)?;\n-                    self.validate(\n-                        ValidationQuery {\n-                            lval: field_lvalue,\n-                            ty: field_ty,\n-                            ..query\n-                        },\n-                        mode,\n-                    )?;\n-                }\n-                // TODO: Check if the signature matches (should be the same check as what terminator/mod.rs already does on call?).\n-                // Is there other things we can/should check?  Like vtable pointers?\n-                Ok(())\n+        };\n+        match res {\n+            // ReleaseUntil(None) of an uninitalized variable is a NOP.  This is needed because\n+            // we have to release the return value of a function; due to destination-passing-style\n+            // the callee may directly write there.\n+            // TODO: Ideally we would know whether the destination is already initialized, and only\n+            // release if it is.  But of course that can't even always be statically determined.\n+            Err(EvalError { kind: EvalErrorKind::ReadUndefBytes, .. })\n+                if mode == ValidationMode::ReleaseUntil(None) => {\n+                return Ok(());\n             }\n-            // FIXME: generators aren't validated right now\n-            TyGenerator(..) => Ok(()),\n-            _ => bug!(\"We already established that this is a type we support. ({})\", query.ty),\n+            res => res,\n         }\n     }\n }"}, {"sha": "c640932e50e21953955b38c94f6bd5e83b423fa8", "filename": "src/librustc_mir/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/237590ada34b554abc1df14f3c57677f79d4ed73/src%2Flibrustc_mir%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/237590ada34b554abc1df14f3c57677f79d4ed73/src%2Flibrustc_mir%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Flib.rs?ref=237590ada34b554abc1df14f3c57677f79d4ed73", "patch": "@@ -3,6 +3,7 @@\n     rustc_private,\n     conservative_impl_trait,\n     never_type,\n+    catch_expr,\n )]\n \n // From rustc."}, {"sha": "80149eeffaa641c32a70dc2dc04645c2a426658e", "filename": "tests/compile-fail/panic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/237590ada34b554abc1df14f3c57677f79d4ed73/tests%2Fcompile-fail%2Fpanic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/237590ada34b554abc1df14f3c57677f79d4ed73/tests%2Fcompile-fail%2Fpanic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fpanic.rs?ref=237590ada34b554abc1df14f3c57677f79d4ed73", "patch": "@@ -1,4 +1,4 @@\n-// FIXME: Probably failing due to https://github.com/solson/miri/issues/296\n+// FIXME: Something in panic handling fails validation with full-MIR\n // compile-flags: -Zmir-emit-validate=0\n //error-pattern: the evaluated program panicked\n "}, {"sha": "b352346114d7f2943bbc305431c168280007f68e", "filename": "tests/compile-fail/validation_lock_confusion.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/237590ada34b554abc1df14f3c57677f79d4ed73/tests%2Fcompile-fail%2Fvalidation_lock_confusion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/237590ada34b554abc1df14f3c57677f79d4ed73/tests%2Fcompile-fail%2Fvalidation_lock_confusion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fvalidation_lock_confusion.rs?ref=237590ada34b554abc1df14f3c57677f79d4ed73", "patch": "@@ -0,0 +1,24 @@\n+// Make sure validation can handle many overlapping shared borrows for different parts of a data structure\n+#![allow(unused_variables)]\n+use std::cell::RefCell;\n+\n+fn evil(x: *mut i32) {\n+    unsafe { *x = 0; } //~ ERROR: in conflict with lock WriteLock\n+}\n+\n+fn test(r: &mut RefCell<i32>) {\n+    let x = &*r; // releasing write lock, first suspension recorded\n+    let mut x_ref = x.borrow_mut();\n+    let x_inner : &mut i32 = &mut *x_ref; // new inner write lock, with same lifetime as outer lock\n+    {\n+        let x_inner_shr = &*x_inner; // releasing inner write lock, recording suspension\n+        let y = &*r; // second suspension for the outer write lock\n+        let x_inner_shr2 = &*x_inner; // 2nd suspension for inner write lock\n+    }\n+    // If the two locks are mixed up, here we should have a write lock, but we do not.\n+    evil(x_inner as *mut _);\n+}\n+\n+fn main() {\n+    test(&mut RefCell::new(0));\n+}"}, {"sha": "fa4ae9afdf6925bf31de40b8226d74172bcfd65a", "filename": "tests/compile-fail/zst2.rs", "status": "removed", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/02a943b3fb5966aa326b1ec9986d568ec422c668/tests%2Fcompile-fail%2Fzst2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02a943b3fb5966aa326b1ec9986d568ec422c668/tests%2Fcompile-fail%2Fzst2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fzst2.rs?ref=02a943b3fb5966aa326b1ec9986d568ec422c668", "patch": "@@ -1,11 +0,0 @@\n-// FIXME: Probably failing due to https://github.com/solson/miri/issues/296\n-// compile-flags: -Zmir-emit-validate=0\n-// error-pattern: the evaluated program panicked\n-\n-#[derive(Debug)]\n-struct A;\n-\n-fn main() {\n-    // can't use assert_eq, b/c that will try to print the pointer addresses with full MIR enabled\n-    assert!(&A as *const A as *const () == &() as *const _)\n-}"}, {"sha": "320541552fb59161eb101994c45c6298c3088a76", "filename": "tests/compile-fail/zst3.rs", "status": "removed", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/02a943b3fb5966aa326b1ec9986d568ec422c668/tests%2Fcompile-fail%2Fzst3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02a943b3fb5966aa326b1ec9986d568ec422c668/tests%2Fcompile-fail%2Fzst3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fzst3.rs?ref=02a943b3fb5966aa326b1ec9986d568ec422c668", "patch": "@@ -1,11 +0,0 @@\n-// FIXME: Probably failing due to https://github.com/solson/miri/issues/296\n-// compile-flags: -Zmir-emit-validate=0\n-// error-pattern: the evaluated program panicked\n-\n-#[derive(Debug)]\n-struct A;\n-\n-fn main() {\n-    // can't use assert_eq, b/c that will try to print the pointer addresses with full MIR enabled\n-    assert!(&A as *const A == &A as *const A);\n-}"}, {"sha": "f4a358174f555bce8e38d0a3f9427d52fe0e93b9", "filename": "tests/run-pass-fullmir/hashmap.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/237590ada34b554abc1df14f3c57677f79d4ed73/tests%2Frun-pass-fullmir%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/237590ada34b554abc1df14f3c57677f79d4ed73/tests%2Frun-pass-fullmir%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass-fullmir%2Fhashmap.rs?ref=237590ada34b554abc1df14f3c57677f79d4ed73", "patch": "@@ -1,5 +1,3 @@\n-// FIXME: disable validation until we figure out how to handle <https://github.com/solson/miri/issues/296>.\n-// compile-flags: -Zmir-emit-validate=0\n use std::collections::{self, HashMap};\n use std::hash::BuildHasherDefault;\n "}, {"sha": "0fd28d6f1e8df607974629d87c80e3173d356c39", "filename": "tests/run-pass/btreemap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/237590ada34b554abc1df14f3c57677f79d4ed73/tests%2Frun-pass%2Fbtreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/237590ada34b554abc1df14f3c57677f79d4ed73/tests%2Frun-pass%2Fbtreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fbtreemap.rs?ref=237590ada34b554abc1df14f3c57677f79d4ed73", "patch": "@@ -1,4 +1,4 @@\n-// mir validation can't cope with `mem::uninitialized::<SomeEnum>()`\n+// mir validation can't cope with `mem::uninitialized()`, so this test fails with validation & full-MIR.\n // compile-flags: -Zmir-emit-validate=0\n \n #[derive(PartialEq, Eq, PartialOrd, Ord)]"}, {"sha": "393bafebfe4d6cde0fb5bc832358d05fe208fdeb", "filename": "tests/run-pass/many_shr_bor.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/237590ada34b554abc1df14f3c57677f79d4ed73/tests%2Frun-pass%2Fmany_shr_bor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/237590ada34b554abc1df14f3c57677f79d4ed73/tests%2Frun-pass%2Fmany_shr_bor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fmany_shr_bor.rs?ref=237590ada34b554abc1df14f3c57677f79d4ed73", "patch": "@@ -1,4 +1,4 @@\n-// Make sure validation can handle many overlapping shared borrows for difference parts of a data structure\n+// Make sure validation can handle many overlapping shared borrows for different parts of a data structure\n #![allow(unused_variables)]\n use std::cell::RefCell;\n \n@@ -24,7 +24,7 @@ fn test1() {\n fn test2(r: &mut RefCell<i32>) {\n     let x = &*r; // releasing write lock, first suspension recorded\n     let mut x_ref = x.borrow_mut();\n-    let x_inner : &mut i32 = &mut *x_ref;\n+    let x_inner : &mut i32 = &mut *x_ref; // new inner write lock, with same lifetime as outer lock\n     let x_inner_shr = &*x_inner; // releasing inner write lock, recording suspension\n     let y = &*r; // second suspension for the outer write lock\n     let x_inner_shr2 = &*x_inner; // 2nd suspension for inner write lock"}, {"sha": "c2d7b88ea0757f99435e400cbe2fd1dc6d688d97", "filename": "tests/run-pass/zst2.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/237590ada34b554abc1df14f3c57677f79d4ed73/tests%2Frun-pass%2Fzst2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/237590ada34b554abc1df14f3c57677f79d4ed73/tests%2Frun-pass%2Fzst2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fzst2.rs?ref=237590ada34b554abc1df14f3c57677f79d4ed73", "patch": "@@ -0,0 +1,12 @@\n+#![allow(dead_code)]\n+\n+#[derive(Debug)]\n+struct A;\n+\n+fn main() {\n+    // can't use assert_eq, b/c that will try to print the pointer addresses with full MIR enabled\n+\n+    // FIXME: Test disabled for now, see <https://github.com/solson/miri/issues/131>.\n+    //assert!(&A as *const A as *const () == &() as *const _);\n+    //assert!(&A as *const A == &A as *const A);\n+}"}]}