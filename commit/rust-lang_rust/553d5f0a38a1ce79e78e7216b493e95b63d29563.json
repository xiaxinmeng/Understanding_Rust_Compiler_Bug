{"sha": "553d5f0a38a1ce79e78e7216b493e95b63d29563", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU1M2Q1ZjBhMzhhMWNlNzllNzhlNzIxNmI0OTNlOTViNjNkMjk1NjM=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2016-09-05T22:26:02Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2016-09-08T20:37:32Z"}, "message": "Address comments", "tree": {"sha": "5cd5007038989342978c49de6cfda121918337ee", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5cd5007038989342978c49de6cfda121918337ee"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/553d5f0a38a1ce79e78e7216b493e95b63d29563", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/553d5f0a38a1ce79e78e7216b493e95b63d29563", "html_url": "https://github.com/rust-lang/rust/commit/553d5f0a38a1ce79e78e7216b493e95b63d29563", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/553d5f0a38a1ce79e78e7216b493e95b63d29563/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f2b672d5567c3b20542e845baaf8a9c47d9df907", "url": "https://api.github.com/repos/rust-lang/rust/commits/f2b672d5567c3b20542e845baaf8a9c47d9df907", "html_url": "https://github.com/rust-lang/rust/commit/f2b672d5567c3b20542e845baaf8a9c47d9df907"}], "stats": {"total": 439, "additions": 210, "deletions": 229}, "files": [{"sha": "e3f3da916a0a94df2fd45d442874392d94c2f53f", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 195, "deletions": 209, "changes": 404, "blob_url": "https://github.com/rust-lang/rust/blob/553d5f0a38a1ce79e78e7216b493e95b63d29563/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/553d5f0a38a1ce79e78e7216b493e95b63d29563/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=553d5f0a38a1ce79e78e7216b493e95b63d29563", "patch": "@@ -15,7 +15,7 @@ pub use self::Primitive::*;\n use infer::InferCtxt;\n use session::Session;\n use traits;\n-use ty::{self, AdtKind, Ty, TyCtxt, TypeFoldable};\n+use ty::{self, Ty, TyCtxt, TypeFoldable};\n \n use syntax::ast::{FloatTy, IntTy, UintTy};\n use syntax::attr;\n@@ -555,7 +555,7 @@ impl<'a, 'gcx, 'tcx> Struct {\n             }\n \n             // Is this the NonZero lang item wrapping a pointer or integer type?\n-            (&Univariant { non_zero: true, .. }, &ty::TyAdt(def, substs)) if def.is_struct() => {\n+            (&Univariant { non_zero: true, .. }, &ty::TyAdt(def, substs)) => {\n                 let fields = &def.struct_variant().fields;\n                 assert_eq!(fields.len(), 1);\n                 match *fields[0].ty(tcx, substs).layout(infcx)? {\n@@ -918,243 +918,229 @@ impl<'a, 'gcx, 'tcx> Layout {\n                 Univariant { variant: st, non_zero: false }\n             }\n \n-            // ADTs.\n-            ty::TyAdt(def, substs) => match def.adt_kind() {\n-                AdtKind::Struct => {\n-                    if ty.is_simd() {\n-                        // SIMD vector types.\n-                        let element = ty.simd_type(tcx);\n-                        match *element.layout(infcx)? {\n-                            Scalar { value, .. } => {\n-                                return success(Vector {\n-                                    element: value,\n-                                    count: ty.simd_size(tcx) as u64\n-                                });\n-                            }\n-                            _ => {\n-                                tcx.sess.fatal(&format!(\"monomorphising SIMD type `{}` with \\\n-                                                        a non-machine element type `{}`\",\n-                                                        ty, element));\n-                            }\n-                        }\n+            // SIMD vector types.\n+            ty::TyAdt(def, ..) if def.is_simd() => {\n+                let element = ty.simd_type(tcx);\n+                match *element.layout(infcx)? {\n+                    Scalar { value, .. } => {\n+                        return success(Vector {\n+                            element: value,\n+                            count: ty.simd_size(tcx) as u64\n+                        });\n                     }\n-                    let fields = def.struct_variant().fields.iter().map(|field| {\n-                        field.ty(tcx, substs).layout(infcx)\n+                    _ => {\n+                        tcx.sess.fatal(&format!(\"monomorphising SIMD type `{}` with \\\n+                                                a non-machine element type `{}`\",\n+                                                ty, element));\n+                    }\n+                }\n+            }\n+\n+            // ADTs.\n+            ty::TyAdt(def, substs) => {\n+                let hint = *tcx.lookup_repr_hints(def.did).get(0)\n+                    .unwrap_or(&attr::ReprAny);\n+\n+                if def.variants.is_empty() {\n+                    // Uninhabitable; represent as unit\n+                    // (Typechecking will reject discriminant-sizing attrs.)\n+                    assert_eq!(hint, attr::ReprAny);\n+\n+                    return success(Univariant {\n+                        variant: Struct::new(dl, false),\n+                        non_zero: false\n                     });\n-                    let packed = tcx.lookup_packed(def.did);\n-                    let mut st = Struct::new(dl, packed);\n-                    st.extend(dl, fields, ty)?;\n+                }\n \n-                    Univariant {\n-                        variant: st,\n-                        non_zero: Some(def.did) == tcx.lang_items.non_zero()\n+                if def.is_enum() && def.variants.iter().all(|v| v.fields.is_empty()) {\n+                    // All bodies empty -> intlike\n+                    let (mut min, mut max) = (i64::MAX, i64::MIN);\n+                    for v in &def.variants {\n+                        let x = v.disr_val.to_u64_unchecked() as i64;\n+                        if x < min { min = x; }\n+                        if x > max { max = x; }\n                     }\n+\n+                    let (discr, signed) = Integer::repr_discr(tcx, hint, min, max);\n+                    return success(CEnum {\n+                        discr: discr,\n+                        signed: signed,\n+                        min: min as u64,\n+                        max: max as u64\n+                    });\n                 }\n-                AdtKind::Union => {\n-                    let fields = def.struct_variant().fields.iter().map(|field| {\n+\n+                if def.variants.len() == 1 {\n+                    // Struct, or union, or univariant enum equivalent to a struct.\n+                    // (Typechecking will reject discriminant-sizing attrs.)\n+                    assert!(!def.is_enum() || hint == attr::ReprAny);\n+                    let fields = def.variants[0].fields.iter().map(|field| {\n                         field.ty(tcx, substs).layout(infcx)\n                     });\n                     let packed = tcx.lookup_packed(def.did);\n-                    let mut un = Union::new(dl, packed);\n-                    un.extend(dl, fields, ty)?;\n-                    UntaggedUnion { variants: un }\n+                    let layout = if def.is_union() {\n+                        let mut un = Union::new(dl, packed);\n+                        un.extend(dl, fields, ty)?;\n+                        UntaggedUnion { variants: un }\n+                    } else {\n+                        let mut st = Struct::new(dl, packed);\n+                        st.extend(dl, fields, ty)?;\n+                        let non_zero = Some(def.did) == tcx.lang_items.non_zero();\n+                        Univariant { variant: st, non_zero: non_zero }\n+                    };\n+                    return success(layout);\n                 }\n-                AdtKind::Enum => {\n-                    let hint = *tcx.lookup_repr_hints(def.did).get(0)\n-                        .unwrap_or(&attr::ReprAny);\n-\n-                    if def.variants.is_empty() {\n-                        // Uninhabitable; represent as unit\n-                        // (Typechecking will reject discriminant-sizing attrs.)\n-                        assert_eq!(hint, attr::ReprAny);\n-\n-                        return success(Univariant {\n-                            variant: Struct::new(dl, false),\n-                            non_zero: false\n-                        });\n-                    }\n-\n-                    if def.variants.iter().all(|v| v.fields.is_empty()) {\n-                        // All bodies empty -> intlike\n-                        let (mut min, mut max) = (i64::MAX, i64::MIN);\n-                        for v in &def.variants {\n-                            let x = v.disr_val.to_u64_unchecked() as i64;\n-                            if x < min { min = x; }\n-                            if x > max { max = x; }\n-                        }\n \n-                        let (discr, signed) = Integer::repr_discr(tcx, hint, min, max);\n-                        return success(CEnum {\n-                            discr: discr,\n-                            signed: signed,\n-                            min: min as u64,\n-                            max: max as u64\n-                        });\n+                // Since there's at least one\n+                // non-empty body, explicit discriminants should have\n+                // been rejected by a checker before this point.\n+                for (i, v) in def.variants.iter().enumerate() {\n+                    if i as u64 != v.disr_val.to_u64_unchecked() {\n+                        bug!(\"non-C-like enum {} with specified discriminants\",\n+                            tcx.item_path_str(def.did));\n                     }\n+                }\n \n-                    // Since there's at least one\n-                    // non-empty body, explicit discriminants should have\n-                    // been rejected by a checker before this point.\n-                    for (i, v) in def.variants.iter().enumerate() {\n-                        if i as u64 != v.disr_val.to_u64_unchecked() {\n-                            bug!(\"non-C-like enum {} with specified discriminants\",\n-                                tcx.item_path_str(def.did));\n-                        }\n-                    }\n+                // Cache the substituted and normalized variant field types.\n+                let variants = def.variants.iter().map(|v| {\n+                    v.fields.iter().map(|field| field.ty(tcx, substs)).collect::<Vec<_>>()\n+                }).collect::<Vec<_>>();\n \n-                    if def.variants.len() == 1 {\n-                        // Equivalent to a struct/tuple/newtype.\n-                        // (Typechecking will reject discriminant-sizing attrs.)\n-                        assert_eq!(hint, attr::ReprAny);\n-                        let fields = def.variants[0].fields.iter().map(|field| {\n-                            field.ty(tcx, substs).layout(infcx)\n+                if variants.len() == 2 && hint == attr::ReprAny {\n+                    // Nullable pointer optimization\n+                    for discr in 0..2 {\n+                        let other_fields = variants[1 - discr].iter().map(|ty| {\n+                            ty.layout(infcx)\n                         });\n-                        let mut st = Struct::new(dl, false);\n-                        st.extend(dl, fields, ty)?;\n-                        return success(Univariant { variant: st, non_zero: false });\n-                    }\n-\n-                    // Cache the substituted and normalized variant field types.\n-                    let variants = def.variants.iter().map(|v| {\n-                        v.fields.iter().map(|field| field.ty(tcx, substs)).collect::<Vec<_>>()\n-                    }).collect::<Vec<_>>();\n-\n-                    if variants.len() == 2 && hint == attr::ReprAny {\n-                        // Nullable pointer optimization\n-                        for discr in 0..2 {\n-                            let other_fields = variants[1 - discr].iter().map(|ty| {\n-                                ty.layout(infcx)\n-                            });\n-                            if !Struct::would_be_zero_sized(dl, other_fields)? {\n-                                continue;\n-                            }\n-                            let path = Struct::non_zero_field_path(infcx,\n-                                variants[discr].iter().cloned())?;\n-                            let mut path = if let Some(p) = path { p } else { continue };\n-\n-                            // FIXME(eddyb) should take advantage of a newtype.\n-                            if path == &[0] && variants[discr].len() == 1 {\n-                                match *variants[discr][0].layout(infcx)? {\n-                                    Scalar { value, .. } => {\n-                                        return success(RawNullablePointer {\n-                                            nndiscr: discr as u64,\n-                                            value: value\n-                                        });\n-                                    }\n-                                    _ => {\n-                                        bug!(\"Layout::compute: `{}`'s non-zero \\\n-                                            `{}` field not scalar?!\",\n-                                            ty, variants[discr][0])\n-                                    }\n+                        if !Struct::would_be_zero_sized(dl, other_fields)? {\n+                            continue;\n+                        }\n+                        let path = Struct::non_zero_field_path(infcx,\n+                            variants[discr].iter().cloned())?;\n+                        let mut path = if let Some(p) = path { p } else { continue };\n+\n+                        // FIXME(eddyb) should take advantage of a newtype.\n+                        if path == &[0] && variants[discr].len() == 1 {\n+                            match *variants[discr][0].layout(infcx)? {\n+                                Scalar { value, .. } => {\n+                                    return success(RawNullablePointer {\n+                                        nndiscr: discr as u64,\n+                                        value: value\n+                                    });\n+                                }\n+                                _ => {\n+                                    bug!(\"Layout::compute: `{}`'s non-zero \\\n+                                        `{}` field not scalar?!\",\n+                                        ty, variants[discr][0])\n                                 }\n                             }\n-\n-                            path.push(0); // For GEP through a pointer.\n-                            path.reverse();\n-                            let mut st = Struct::new(dl, false);\n-                            st.extend(dl, variants[discr].iter().map(|ty| ty.layout(infcx)), ty)?;\n-                            return success(StructWrappedNullablePointer {\n-                                nndiscr: discr as u64,\n-                                nonnull: st,\n-                                discrfield: path\n-                            });\n                         }\n-                    }\n \n-                    // The general case.\n-                    let discr_max = (variants.len() - 1) as i64;\n-                    assert!(discr_max >= 0);\n-                    let (min_ity, _) = Integer::repr_discr(tcx, hint, 0, discr_max);\n-\n-                    let mut align = dl.aggregate_align;\n-                    let mut size = Size::from_bytes(0);\n-\n-                    // We're interested in the smallest alignment, so start large.\n-                    let mut start_align = Align::from_bytes(256, 256).unwrap();\n-\n-                    // Create the set of structs that represent each variant\n-                    // Use the minimum integer type we figured out above\n-                    let discr = Some(Scalar { value: Int(min_ity), non_zero: false });\n-                    let mut variants = variants.into_iter().map(|fields| {\n-                        let mut found_start = false;\n-                        let fields = fields.into_iter().map(|field| {\n-                            let field = field.layout(infcx)?;\n-                            if !found_start {\n-                                // Find the first field we can't move later\n-                                // to make room for a larger discriminant.\n-                                let field_align = field.align(dl);\n-                                if field.size(dl).bytes() != 0 || field_align.abi() != 1 {\n-                                    start_align = start_align.min(field_align);\n-                                    found_start = true;\n-                                }\n-                            }\n-                            Ok(field)\n-                        });\n+                        path.push(0); // For GEP through a pointer.\n+                        path.reverse();\n                         let mut st = Struct::new(dl, false);\n-                        st.extend(dl, discr.iter().map(Ok).chain(fields), ty)?;\n-                        size = cmp::max(size, st.min_size());\n-                        align = align.max(st.align);\n-                        Ok(st)\n-                    }).collect::<Result<Vec<_>, _>>()?;\n-\n-                    // Align the maximum variant size to the largest alignment.\n-                    size = size.abi_align(align);\n-\n-                    if size.bytes() >= dl.obj_size_bound() {\n-                        return Err(LayoutError::SizeOverflow(ty));\n+                        st.extend(dl, variants[discr].iter().map(|ty| ty.layout(infcx)), ty)?;\n+                        return success(StructWrappedNullablePointer {\n+                            nndiscr: discr as u64,\n+                            nonnull: st,\n+                            discrfield: path\n+                        });\n                     }\n+                }\n \n-                    // Check to see if we should use a different type for the\n-                    // discriminant. We can safely use a type with the same size\n-                    // as the alignment of the first field of each variant.\n-                    // We increase the size of the discriminant to avoid LLVM copying\n-                    // padding when it doesn't need to. This normally causes unaligned\n-                    // load/stores and excessive memcpy/memset operations. By using a\n-                    // bigger integer size, LLVM can be sure about it's contents and\n-                    // won't be so conservative.\n-\n-                    // Use the initial field alignment\n-                    let wanted = start_align.abi();\n-                    let mut ity = min_ity;\n-                    for &candidate in &[I16, I32, I64] {\n-                        let ty = Int(candidate);\n-                        if wanted == ty.align(dl).abi() && wanted == ty.size(dl).bytes() {\n-                            ity = candidate;\n-                            break;\n+                // The general case.\n+                let discr_max = (variants.len() - 1) as i64;\n+                assert!(discr_max >= 0);\n+                let (min_ity, _) = Integer::repr_discr(tcx, hint, 0, discr_max);\n+\n+                let mut align = dl.aggregate_align;\n+                let mut size = Size::from_bytes(0);\n+\n+                // We're interested in the smallest alignment, so start large.\n+                let mut start_align = Align::from_bytes(256, 256).unwrap();\n+\n+                // Create the set of structs that represent each variant\n+                // Use the minimum integer type we figured out above\n+                let discr = Some(Scalar { value: Int(min_ity), non_zero: false });\n+                let mut variants = variants.into_iter().map(|fields| {\n+                    let mut found_start = false;\n+                    let fields = fields.into_iter().map(|field| {\n+                        let field = field.layout(infcx)?;\n+                        if !found_start {\n+                            // Find the first field we can't move later\n+                            // to make room for a larger discriminant.\n+                            let field_align = field.align(dl);\n+                            if field.size(dl).bytes() != 0 || field_align.abi() != 1 {\n+                                start_align = start_align.min(field_align);\n+                                found_start = true;\n+                            }\n                         }\n-                    }\n+                        Ok(field)\n+                    });\n+                    let mut st = Struct::new(dl, false);\n+                    st.extend(dl, discr.iter().map(Ok).chain(fields), ty)?;\n+                    size = cmp::max(size, st.min_size());\n+                    align = align.max(st.align);\n+                    Ok(st)\n+                }).collect::<Result<Vec<_>, _>>()?;\n+\n+                // Align the maximum variant size to the largest alignment.\n+                size = size.abi_align(align);\n+\n+                if size.bytes() >= dl.obj_size_bound() {\n+                    return Err(LayoutError::SizeOverflow(ty));\n+                }\n \n-                    // FIXME(eddyb) conservative only to avoid diverging from trans::adt.\n-                    if align.abi() != start_align.abi() {\n-                        ity = min_ity;\n+                // Check to see if we should use a different type for the\n+                // discriminant. We can safely use a type with the same size\n+                // as the alignment of the first field of each variant.\n+                // We increase the size of the discriminant to avoid LLVM copying\n+                // padding when it doesn't need to. This normally causes unaligned\n+                // load/stores and excessive memcpy/memset operations. By using a\n+                // bigger integer size, LLVM can be sure about it's contents and\n+                // won't be so conservative.\n+\n+                // Use the initial field alignment\n+                let wanted = start_align.abi();\n+                let mut ity = min_ity;\n+                for &candidate in &[I16, I32, I64] {\n+                    let ty = Int(candidate);\n+                    if wanted == ty.align(dl).abi() && wanted == ty.size(dl).bytes() {\n+                        ity = candidate;\n+                        break;\n                     }\n+                }\n \n-                    // If the alignment is not larger than the chosen discriminant size,\n-                    // don't use the alignment as the final size.\n-                    if ity <= min_ity {\n-                        ity = min_ity;\n-                    } else {\n-                        // Patch up the variants' first few fields.\n-                        let old_ity_size = Int(min_ity).size(dl);\n-                        let new_ity_size = Int(ity).size(dl);\n-                        for variant in &mut variants {\n-                            for offset in &mut variant.offset_after_field {\n-                                if *offset > old_ity_size {\n-                                    break;\n-                                }\n-                                *offset = new_ity_size;\n+                // FIXME(eddyb) conservative only to avoid diverging from trans::adt.\n+                if align.abi() != start_align.abi() {\n+                    ity = min_ity;\n+                }\n+\n+                // If the alignment is not larger than the chosen discriminant size,\n+                // don't use the alignment as the final size.\n+                if ity <= min_ity {\n+                    ity = min_ity;\n+                } else {\n+                    // Patch up the variants' first few fields.\n+                    let old_ity_size = Int(min_ity).size(dl);\n+                    let new_ity_size = Int(ity).size(dl);\n+                    for variant in &mut variants {\n+                        for offset in &mut variant.offset_after_field {\n+                            if *offset > old_ity_size {\n+                                break;\n                             }\n+                            *offset = new_ity_size;\n                         }\n                     }\n+                }\n \n-                    General {\n-                        discr: ity,\n-                        variants: variants,\n-                        size: size,\n-                        align: align\n-                    }\n+                General {\n+                    discr: ity,\n+                    variants: variants,\n+                    size: size,\n+                    align: align\n                 }\n-            },\n+            }\n \n             // Types with no meaningful known layout.\n             ty::TyProjection(_) | ty::TyAnon(..) => {"}, {"sha": "6b3ebaa895fa3883a59321596d1062b6dbf67e9b", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 15, "deletions": 20, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/553d5f0a38a1ce79e78e7216b493e95b63d29563/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/553d5f0a38a1ce79e78e7216b493e95b63d29563/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=553d5f0a38a1ce79e78e7216b493e95b63d29563", "patch": "@@ -253,15 +253,13 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// if not a structure at all. Corresponds to the only possible unsized\n     /// field, and its type can be used to determine unsizing strategy.\n     pub fn struct_tail(self, mut ty: Ty<'tcx>) -> Ty<'tcx> {\n-        loop {\n-            match ty.sty {\n-                TyAdt(def, substs) if def.is_struct() => {\n-                    match def.struct_variant().fields.last() {\n-                        Some(f) => ty = f.ty(self, substs),\n-                        None => break\n-                    }\n-                }\n-                _ => break\n+        while let TyAdt(def, substs) = ty.sty {\n+            if !def.is_struct() {\n+                break\n+            }\n+            match def.struct_variant().fields.last() {\n+                Some(f) => ty = f.ty(self, substs),\n+                None => break\n             }\n         }\n         ty\n@@ -277,17 +275,14 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                                  target: Ty<'tcx>)\n                                  -> (Ty<'tcx>, Ty<'tcx>) {\n         let (mut a, mut b) = (source, target);\n-        loop {\n-            match (&a.sty, &b.sty) {\n-                (&TyAdt(a_def, a_substs), &TyAdt(b_def, b_substs))\n-                        if a_def == b_def && a_def.is_struct() => {\n-                    match a_def.struct_variant().fields.last() {\n-                        Some(f) => {\n-                            a = f.ty(self, a_substs);\n-                            b = f.ty(self, b_substs);\n-                        }\n-                        _ => break\n-                    }\n+        while let (&TyAdt(a_def, a_substs), &TyAdt(b_def, b_substs)) = (&a.sty, &b.sty) {\n+            if a_def != b_def || !a_def.is_struct() {\n+                break\n+            }\n+            match a_def.struct_variant().fields.last() {\n+                Some(f) => {\n+                    a = f.ty(self, a_substs);\n+                    b = f.ty(self, b_substs);\n                 }\n                 _ => break\n             }"}]}