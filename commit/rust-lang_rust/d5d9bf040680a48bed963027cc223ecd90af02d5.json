{"sha": "d5d9bf040680a48bed963027cc223ecd90af02d5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ1ZDliZjA0MDY4MGE0OGJlZDk2MzAyN2NjMjIzZWNkOTBhZjAyZDU=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2020-04-17T21:56:00Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-04-17T21:56:00Z"}, "message": "Rollup merge of #71167 - RalfJung:big-o, r=shepmaster\n\nbig-O notation: parenthesis for function calls, explicit multiplication\n\nI saw `O(n m log n)` in the docs and found that really hard to parse. In particular, I don't think we should use blank space as syntax for *both* multiplication and function calls, that is just confusing.\n\nThis PR makes both multiplication and function calls explicit using Rust-like syntax. If you prefer, I can also leave one of them implicit, but I believe explicit is better here.\n\nWhile I was at it I also added backticks consistently.", "tree": {"sha": "32047f9862e32f09befdf8499637c706fbaeae49", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/32047f9862e32f09befdf8499637c706fbaeae49"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d5d9bf040680a48bed963027cc223ecd90af02d5", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJemiXwCRBK7hj4Ov3rIwAAdHIIAG2ztOSj6urbB88zlxye/01E\nHqTTwCdd5870/xNvB/p0HJi4VZ3F0cDM4wlWjYs0YWC1ELPUEQKwAUQbXcGB0wjQ\nZe9aurEJNcLVFBWAbqgDMKS3nXkyq7dMwI6LarEtr594sjW1H95Mn9Hr76bcfkRh\naDnOTtoohI/61sb5zhhMuFLIeaNfancIqg/Hf3qFOkCmJxh2EZK1TRCxkhlpbWXI\nyvaiITgDxLOC90VnYolepCupNGmyxkbgkyFm1rH0XY/PiCUwN/l34/Nf7G7M39pD\nfbJl9LIs7QPvQq2pn453L+FMFU9NOGiuhnniL3xistDZiNO5ASSO19Bq1q3wh60=\n=UEmO\n-----END PGP SIGNATURE-----\n", "payload": "tree 32047f9862e32f09befdf8499637c706fbaeae49\nparent b45f133a0db02356cdd3190fea72bc3c7a7d0bb9\nparent 818bef55584943a5ae1199c9c481f15df4490041\nauthor Dylan DPC <dylan.dpc@gmail.com> 1587160560 +0200\ncommitter GitHub <noreply@github.com> 1587160560 +0200\n\nRollup merge of #71167 - RalfJung:big-o, r=shepmaster\n\nbig-O notation: parenthesis for function calls, explicit multiplication\n\nI saw `O(n m log n)` in the docs and found that really hard to parse. In particular, I don't think we should use blank space as syntax for *both* multiplication and function calls, that is just confusing.\n\nThis PR makes both multiplication and function calls explicit using Rust-like syntax. If you prefer, I can also leave one of them implicit, but I believe explicit is better here.\n\nWhile I was at it I also added backticks consistently.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d5d9bf040680a48bed963027cc223ecd90af02d5", "html_url": "https://github.com/rust-lang/rust/commit/d5d9bf040680a48bed963027cc223ecd90af02d5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d5d9bf040680a48bed963027cc223ecd90af02d5/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b45f133a0db02356cdd3190fea72bc3c7a7d0bb9", "url": "https://api.github.com/repos/rust-lang/rust/commits/b45f133a0db02356cdd3190fea72bc3c7a7d0bb9", "html_url": "https://github.com/rust-lang/rust/commit/b45f133a0db02356cdd3190fea72bc3c7a7d0bb9"}, {"sha": "818bef55584943a5ae1199c9c481f15df4490041", "url": "https://api.github.com/repos/rust-lang/rust/commits/818bef55584943a5ae1199c9c481f15df4490041", "html_url": "https://github.com/rust-lang/rust/commit/818bef55584943a5ae1199c9c481f15df4490041"}], "stats": {"total": 93, "additions": 46, "deletions": 47}, "files": [{"sha": "03c9164fb909536b23b2255d04fcfd78ce622a76", "filename": "src/liballoc/collections/binary_heap.rs", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/d5d9bf040680a48bed963027cc223ecd90af02d5/src%2Fliballoc%2Fcollections%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5d9bf040680a48bed963027cc223ecd90af02d5/src%2Fliballoc%2Fcollections%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbinary_heap.rs?ref=d5d9bf040680a48bed963027cc223ecd90af02d5", "patch": "@@ -1,10 +1,10 @@\n //! A priority queue implemented with a binary heap.\n //!\n-//! Insertion and popping the largest element have `O(log n)` time complexity.\n+//! Insertion and popping the largest element have `O(log(n))` time complexity.\n //! Checking the largest element is `O(1)`. Converting a vector to a binary heap\n //! can be done in-place, and has `O(n)` complexity. A binary heap can also be\n-//! converted to a sorted vector in-place, allowing it to be used for an `O(n\n-//! log n)` in-place heapsort.\n+//! converted to a sorted vector in-place, allowing it to be used for an `O(n * log(n))`\n+//! in-place heapsort.\n //!\n //! # Examples\n //!\n@@ -233,9 +233,9 @@ use super::SpecExtend;\n ///\n /// # Time complexity\n ///\n-/// | [push] | [pop]    | [peek]/[peek\\_mut] |\n-/// |--------|----------|--------------------|\n-/// | O(1)~  | O(log n) | O(1)               |\n+/// | [push] | [pop]     | [peek]/[peek\\_mut] |\n+/// |--------|-----------|--------------------|\n+/// | O(1)~  | O(log(n)) | O(1)               |\n ///\n /// The value for `push` is an expected cost; the method documentation gives a\n /// more detailed analysis.\n@@ -398,7 +398,7 @@ impl<T: Ord> BinaryHeap<T> {\n     ///\n     /// # Time complexity\n     ///\n-    /// Cost is O(1) in the worst case.\n+    /// Cost is `O(1)` in the worst case.\n     #[stable(feature = \"binary_heap_peek_mut\", since = \"1.12.0\")]\n     pub fn peek_mut(&mut self) -> Option<PeekMut<'_, T>> {\n         if self.is_empty() { None } else { Some(PeekMut { heap: self, sift: true }) }\n@@ -422,8 +422,7 @@ impl<T: Ord> BinaryHeap<T> {\n     ///\n     /// # Time complexity\n     ///\n-    /// The worst case cost of `pop` on a heap containing *n* elements is O(log\n-    /// n).\n+    /// The worst case cost of `pop` on a heap containing *n* elements is `O(log(n))`.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn pop(&mut self) -> Option<T> {\n         self.data.pop().map(|mut item| {\n@@ -456,15 +455,15 @@ impl<T: Ord> BinaryHeap<T> {\n     ///\n     /// The expected cost of `push`, averaged over every possible ordering of\n     /// the elements being pushed, and over a sufficiently large number of\n-    /// pushes, is O(1). This is the most meaningful cost metric when pushing\n+    /// pushes, is `O(1)`. This is the most meaningful cost metric when pushing\n     /// elements that are *not* already in any sorted pattern.\n     ///\n     /// The time complexity degrades if elements are pushed in predominantly\n     /// ascending order. In the worst case, elements are pushed in ascending\n-    /// sorted order and the amortized cost per push is O(log n) against a heap\n+    /// sorted order and the amortized cost per push is `O(log(n))` against a heap\n     /// containing *n* elements.\n     ///\n-    /// The worst case cost of a *single* call to `push` is O(n). The worst case\n+    /// The worst case cost of a *single* call to `push` is `O(n)`. The worst case\n     /// occurs when capacity is exhausted and needs a resize. The resize cost\n     /// has been amortized in the previous figures.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -623,7 +622,7 @@ impl<T: Ord> BinaryHeap<T> {\n \n         // `rebuild` takes O(len1 + len2) operations\n         // and about 2 * (len1 + len2) comparisons in the worst case\n-        // while `extend` takes O(len2 * log_2(len1)) operations\n+        // while `extend` takes O(len2 * log(len1)) operations\n         // and about 1 * len2 * log_2(len1) comparisons in the worst case,\n         // assuming len1 >= len2.\n         #[inline]\n@@ -644,7 +643,7 @@ impl<T: Ord> BinaryHeap<T> {\n     /// The remaining elements will be removed on drop in heap order.\n     ///\n     /// Note:\n-    /// * `.drain_sorted()` is O(n lg n); much slower than `.drain()`.\n+    /// * `.drain_sorted()` is `O(n * log(n))`; much slower than `.drain()`.\n     ///   You should use the latter for most cases.\n     ///\n     /// # Examples\n@@ -729,7 +728,7 @@ impl<T> BinaryHeap<T> {\n     ///\n     /// # Time complexity\n     ///\n-    /// Cost is O(1) in the worst case.\n+    /// Cost is `O(1)` in the worst case.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn peek(&self) -> Option<&T> {\n         self.data.get(0)"}, {"sha": "91d93a1be1c98040ed6dca95dfc8274abe0d905c", "filename": "src/liballoc/collections/btree/map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d5d9bf040680a48bed963027cc223ecd90af02d5/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5d9bf040680a48bed963027cc223ecd90af02d5/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs?ref=d5d9bf040680a48bed963027cc223ecd90af02d5", "patch": "@@ -40,7 +40,7 @@ use UnderflowResult::*;\n /// performance on *small* nodes of elements which are cheap to compare. However in the future we\n /// would like to further explore choosing the optimal search strategy based on the choice of B,\n /// and possibly other factors. Using linear search, searching for a random element is expected\n-/// to take O(B log<sub>B</sub>n) comparisons, which is generally worse than a BST. In practice,\n+/// to take O(B * log(n)) comparisons, which is generally worse than a BST. In practice,\n /// however, performance is excellent.\n ///\n /// It is a logic error for a key to be modified in such a way that the key's ordering relative to"}, {"sha": "af341e6c1caab8313f9d3d6172db6c2a41194032", "filename": "src/liballoc/collections/linked_list.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d5d9bf040680a48bed963027cc223ecd90af02d5/src%2Fliballoc%2Fcollections%2Flinked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5d9bf040680a48bed963027cc223ecd90af02d5/src%2Fliballoc%2Fcollections%2Flinked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Flinked_list.rs?ref=d5d9bf040680a48bed963027cc223ecd90af02d5", "patch": "@@ -390,7 +390,7 @@ impl<T> LinkedList<T> {\n     /// This reuses all the nodes from `other` and moves them into `self`. After\n     /// this operation, `other` becomes empty.\n     ///\n-    /// This operation should compute in O(1) time and O(1) memory.\n+    /// This operation should compute in `O(1)` time and `O(1)` memory.\n     ///\n     /// # Examples\n     ///\n@@ -547,7 +547,7 @@ impl<T> LinkedList<T> {\n \n     /// Returns `true` if the `LinkedList` is empty.\n     ///\n-    /// This operation should compute in O(1) time.\n+    /// This operation should compute in `O(1)` time.\n     ///\n     /// # Examples\n     ///\n@@ -568,7 +568,7 @@ impl<T> LinkedList<T> {\n \n     /// Returns the length of the `LinkedList`.\n     ///\n-    /// This operation should compute in O(1) time.\n+    /// This operation should compute in `O(1)` time.\n     ///\n     /// # Examples\n     ///\n@@ -594,7 +594,7 @@ impl<T> LinkedList<T> {\n \n     /// Removes all elements from the `LinkedList`.\n     ///\n-    /// This operation should compute in O(n) time.\n+    /// This operation should compute in `O(n)` time.\n     ///\n     /// # Examples\n     ///\n@@ -737,7 +737,7 @@ impl<T> LinkedList<T> {\n \n     /// Adds an element first in the list.\n     ///\n-    /// This operation should compute in O(1) time.\n+    /// This operation should compute in `O(1)` time.\n     ///\n     /// # Examples\n     ///\n@@ -760,7 +760,7 @@ impl<T> LinkedList<T> {\n     /// Removes the first element and returns it, or `None` if the list is\n     /// empty.\n     ///\n-    /// This operation should compute in O(1) time.\n+    /// This operation should compute in `O(1)` time.\n     ///\n     /// # Examples\n     ///\n@@ -783,7 +783,7 @@ impl<T> LinkedList<T> {\n \n     /// Appends an element to the back of a list.\n     ///\n-    /// This operation should compute in O(1) time.\n+    /// This operation should compute in `O(1)` time.\n     ///\n     /// # Examples\n     ///\n@@ -803,7 +803,7 @@ impl<T> LinkedList<T> {\n     /// Removes the last element from a list and returns it, or `None` if\n     /// it is empty.\n     ///\n-    /// This operation should compute in O(1) time.\n+    /// This operation should compute in `O(1)` time.\n     ///\n     /// # Examples\n     ///\n@@ -824,7 +824,7 @@ impl<T> LinkedList<T> {\n     /// Splits the list into two at the given index. Returns everything after the given index,\n     /// including the index.\n     ///\n-    /// This operation should compute in O(n) time.\n+    /// This operation should compute in `O(n)` time.\n     ///\n     /// # Panics\n     ///\n@@ -880,7 +880,7 @@ impl<T> LinkedList<T> {\n \n     /// Removes the element at the given index and returns it.\n     ///\n-    /// This operation should compute in O(n) time.\n+    /// This operation should compute in `O(n)` time.\n     ///\n     /// # Panics\n     /// Panics if at >= len"}, {"sha": "091b068b0b2459cf2950fe679b4f3d4f08e49963", "filename": "src/liballoc/collections/vec_deque.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d5d9bf040680a48bed963027cc223ecd90af02d5/src%2Fliballoc%2Fcollections%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5d9bf040680a48bed963027cc223ecd90af02d5/src%2Fliballoc%2Fcollections%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fvec_deque.rs?ref=d5d9bf040680a48bed963027cc223ecd90af02d5", "patch": "@@ -1391,7 +1391,7 @@ impl<T> VecDeque<T> {\n     /// Removes an element from anywhere in the `VecDeque` and returns it,\n     /// replacing it with the first element.\n     ///\n-    /// This does not preserve ordering, but is O(1).\n+    /// This does not preserve ordering, but is `O(1)`.\n     ///\n     /// Returns `None` if `index` is out of bounds.\n     ///\n@@ -1426,7 +1426,7 @@ impl<T> VecDeque<T> {\n     /// Removes an element from anywhere in the `VecDeque` and returns it, replacing it with the\n     /// last element.\n     ///\n-    /// This does not preserve ordering, but is O(1).\n+    /// This does not preserve ordering, but is `O(1)`.\n     ///\n     /// Returns `None` if `index` is out of bounds.\n     ///\n@@ -2927,7 +2927,7 @@ impl<T> From<VecDeque<T>> for Vec<T> {\n     /// [`Vec<T>`]: crate::vec::Vec\n     /// [`VecDeque<T>`]: crate::collections::VecDeque\n     ///\n-    /// This never needs to re-allocate, but does need to do O(n) data movement if\n+    /// This never needs to re-allocate, but does need to do `O(n)` data movement if\n     /// the circular buffer doesn't happen to be at the beginning of the allocation.\n     ///\n     /// # Examples"}, {"sha": "955cbe77819e5b29b5bef6495684cfdcfedd02d7", "filename": "src/liballoc/slice.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d5d9bf040680a48bed963027cc223ecd90af02d5/src%2Fliballoc%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5d9bf040680a48bed963027cc223ecd90af02d5/src%2Fliballoc%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fslice.rs?ref=d5d9bf040680a48bed963027cc223ecd90af02d5", "patch": "@@ -165,7 +165,7 @@ mod hack {\n impl<T> [T] {\n     /// Sorts the slice.\n     ///\n-    /// This sort is stable (i.e., does not reorder equal elements) and `O(n log n)` worst-case.\n+    /// This sort is stable (i.e., does not reorder equal elements) and `O(n * log(n))` worst-case.\n     ///\n     /// When applicable, unstable sorting is preferred because it is generally faster than stable\n     /// sorting and it doesn't allocate auxiliary memory.\n@@ -200,7 +200,7 @@ impl<T> [T] {\n \n     /// Sorts the slice with a comparator function.\n     ///\n-    /// This sort is stable (i.e., does not reorder equal elements) and `O(n log n)` worst-case.\n+    /// This sort is stable (i.e., does not reorder equal elements) and `O(n * log(n))` worst-case.\n     ///\n     /// The comparator function must define a total ordering for the elements in the slice. If\n     /// the ordering is not total, the order of the elements is unspecified. An order is a\n@@ -254,7 +254,7 @@ impl<T> [T] {\n \n     /// Sorts the slice with a key extraction function.\n     ///\n-    /// This sort is stable (i.e., does not reorder equal elements) and `O(m n log n)`\n+    /// This sort is stable (i.e., does not reorder equal elements) and `O(m * n * log(n))`\n     /// worst-case, where the key function is `O(m)`.\n     ///\n     /// For expensive key functions (e.g. functions that are not simple property accesses or\n@@ -297,7 +297,7 @@ impl<T> [T] {\n     ///\n     /// During sorting, the key function is called only once per element.\n     ///\n-    /// This sort is stable (i.e., does not reorder equal elements) and `O(m n + n log n)`\n+    /// This sort is stable (i.e., does not reorder equal elements) and `O(m * n + n * log(n))`\n     /// worst-case, where the key function is `O(m)`.\n     ///\n     /// For simple key functions (e.g., functions that are property accesses or\n@@ -935,7 +935,7 @@ where\n /// 1. for every `i` in `1..runs.len()`: `runs[i - 1].len > runs[i].len`\n /// 2. for every `i` in `2..runs.len()`: `runs[i - 2].len > runs[i - 1].len + runs[i].len`\n ///\n-/// The invariants ensure that the total running time is `O(n log n)` worst-case.\n+/// The invariants ensure that the total running time is `O(n * log(n))` worst-case.\n fn merge_sort<T, F>(v: &mut [T], mut is_less: F)\n where\n     F: FnMut(&T, &T) -> bool,"}, {"sha": "df976128b5efb7e92e6f6d5f9131432ab8835eed", "filename": "src/libcore/slice/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d5d9bf040680a48bed963027cc223ecd90af02d5/src%2Flibcore%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5d9bf040680a48bed963027cc223ecd90af02d5/src%2Flibcore%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmod.rs?ref=d5d9bf040680a48bed963027cc223ecd90af02d5", "patch": "@@ -1606,7 +1606,7 @@ impl<T> [T] {\n     /// Sorts the slice, but may not preserve the order of equal elements.\n     ///\n     /// This sort is unstable (i.e., may reorder equal elements), in-place\n-    /// (i.e., does not allocate), and `O(n log n)` worst-case.\n+    /// (i.e., does not allocate), and `O(n * log(n))` worst-case.\n     ///\n     /// # Current implementation\n     ///\n@@ -1642,7 +1642,7 @@ impl<T> [T] {\n     /// elements.\n     ///\n     /// This sort is unstable (i.e., may reorder equal elements), in-place\n-    /// (i.e., does not allocate), and `O(n log n)` worst-case.\n+    /// (i.e., does not allocate), and `O(n * log(n))` worst-case.\n     ///\n     /// The comparator function must define a total ordering for the elements in the slice. If\n     /// the ordering is not total, the order of the elements is unspecified. An order is a\n@@ -1697,7 +1697,7 @@ impl<T> [T] {\n     /// elements.\n     ///\n     /// This sort is unstable (i.e., may reorder equal elements), in-place\n-    /// (i.e., does not allocate), and `O(m n log n)` worst-case, where the key function is\n+    /// (i.e., does not allocate), and `O(m * n * log(n))` worst-case, where the key function is\n     /// `O(m)`.\n     ///\n     /// # Current implementation\n@@ -1957,7 +1957,7 @@ impl<T> [T] {\n         // over all the elements, swapping as we go so that at the end\n         // the elements we wish to keep are in the front, and those we\n         // wish to reject are at the back. We can then split the slice.\n-        // This operation is still O(n).\n+        // This operation is still `O(n)`.\n         //\n         // Example: We start in this state, where `r` represents \"next\n         // read\" and `w` represents \"next_write`."}, {"sha": "be3e7aaa2e89a678fbd297d70a3b67874b65817e", "filename": "src/libcore/slice/sort.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d5d9bf040680a48bed963027cc223ecd90af02d5/src%2Flibcore%2Fslice%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5d9bf040680a48bed963027cc223ecd90af02d5/src%2Flibcore%2Fslice%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fsort.rs?ref=d5d9bf040680a48bed963027cc223ecd90af02d5", "patch": "@@ -143,7 +143,7 @@ where\n     }\n }\n \n-/// Sorts `v` using heapsort, which guarantees `O(n log n)` worst-case.\n+/// Sorts `v` using heapsort, which guarantees `O(n * log(n))` worst-case.\n #[cold]\n pub fn heapsort<T, F>(v: &mut [T], is_less: &mut F)\n where\n@@ -621,7 +621,7 @@ where\n         }\n \n         // If too many bad pivot choices were made, simply fall back to heapsort in order to\n-        // guarantee `O(n log n)` worst-case.\n+        // guarantee `O(n * log(n))` worst-case.\n         if limit == 0 {\n             heapsort(v, is_less);\n             return;\n@@ -684,7 +684,7 @@ where\n     }\n }\n \n-/// Sorts `v` using pattern-defeating quicksort, which is `O(n log n)` worst-case.\n+/// Sorts `v` using pattern-defeating quicksort, which is `O(n * log(n))` worst-case.\n pub fn quicksort<T, F>(v: &mut [T], mut is_less: F)\n where\n     F: FnMut(&T, &T) -> bool,"}, {"sha": "cc6663bebd3d4cf99aa8ce21f798d0f43010d3dc", "filename": "src/libstd/collections/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d5d9bf040680a48bed963027cc223ecd90af02d5/src%2Flibstd%2Fcollections%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5d9bf040680a48bed963027cc223ecd90af02d5/src%2Flibstd%2Fcollections%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fmod.rs?ref=d5d9bf040680a48bed963027cc223ecd90af02d5", "patch": "@@ -110,10 +110,10 @@\n //!\n //! For Sets, all operations have the cost of the equivalent Map operation.\n //!\n-//! |              | get       | insert   | remove   | predecessor | append |\n-//! |--------------|-----------|----------|----------|-------------|--------|\n-//! | [`HashMap`]  | O(1)~     | O(1)~*   | O(1)~    | N/A         | N/A    |\n-//! | [`BTreeMap`] | O(log n)  | O(log n) | O(log n) | O(log n)    | O(n+m) |\n+//! |              | get       | insert    | remove    | predecessor | append |\n+//! |--------------|-----------|-----------|-----------|-------------|--------|\n+//! | [`HashMap`]  | O(1)~     | O(1)~*    | O(1)~     | N/A         | N/A    |\n+//! | [`BTreeMap`] | O(log(n)) | O(log(n)) | O(log(n)) | O(log(n))   | O(n+m) |\n //!\n //! # Correct and Efficient Usage of Collections\n //!"}, {"sha": "5aca7b7476a52f2025390d8143121e714563a1cd", "filename": "src/libstd/ffi/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d5d9bf040680a48bed963027cc223ecd90af02d5/src%2Flibstd%2Fffi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5d9bf040680a48bed963027cc223ecd90af02d5/src%2Flibstd%2Fffi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fmod.rs?ref=d5d9bf040680a48bed963027cc223ecd90af02d5", "patch": "@@ -43,8 +43,8 @@\n //! terminator, so the buffer length is really `len+1` characters.\n //! Rust strings don't have a nul terminator; their length is always\n //! stored and does not need to be calculated. While in Rust\n-//! accessing a string's length is a O(1) operation (because the\n-//! length is stored); in C it is an O(length) operation because the\n+//! accessing a string's length is a `O(1)` operation (because the\n+//! length is stored); in C it is an `O(length)` operation because the\n //! length needs to be computed by scanning the string for the nul\n //! terminator.\n //!"}]}