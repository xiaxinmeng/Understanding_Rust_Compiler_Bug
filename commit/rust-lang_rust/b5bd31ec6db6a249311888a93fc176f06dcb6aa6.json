{"sha": "b5bd31ec6db6a249311888a93fc176f06dcb6aa6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI1YmQzMWVjNmRiNmEyNDkzMTE4ODhhOTNmYzE3NmYwNmRjYjZhYTY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-10-08T21:32:07Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-10-08T21:32:07Z"}, "message": "Auto merge of #65223 - Centril:rollup-5sdvdni, r=Centril\n\nRollup of 7 pull requests\n\nSuccessful merges:\n\n - #64284 (Warn if include macro fails to include entire file)\n - #65081 (Remove -Zprofile-queries)\n - #65133 (typeck: prohibit foreign statics w/ generics)\n - #65135 (Add check for missing tests for error codes)\n - #65141 (Replace code of conduct with link)\n - #65194 (Use structured suggestion for removal of `as_str()` call)\n - #65213 (Ignore `ExprKind::DropTemps` for some ref suggestions)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "8d6c88672d85193d1a53f3a72c703f886b501071", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8d6c88672d85193d1a53f3a72c703f886b501071"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b5bd31ec6db6a249311888a93fc176f06dcb6aa6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b5bd31ec6db6a249311888a93fc176f06dcb6aa6", "html_url": "https://github.com/rust-lang/rust/commit/b5bd31ec6db6a249311888a93fc176f06dcb6aa6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b5bd31ec6db6a249311888a93fc176f06dcb6aa6/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2748a9fd93dd1a00a4521f4f16de5befbf77f6cd", "url": "https://api.github.com/repos/rust-lang/rust/commits/2748a9fd93dd1a00a4521f4f16de5befbf77f6cd", "html_url": "https://github.com/rust-lang/rust/commit/2748a9fd93dd1a00a4521f4f16de5befbf77f6cd"}, {"sha": "ff51611c42d160f95a01d556045d32f0539d8989", "url": "https://api.github.com/repos/rust-lang/rust/commits/ff51611c42d160f95a01d556045d32f0539d8989", "html_url": "https://github.com/rust-lang/rust/commit/ff51611c42d160f95a01d556045d32f0539d8989"}], "stats": {"total": 1635, "additions": 582, "deletions": 1053}, "files": [{"sha": "e3708bc485399fd42b32c6a1c24491771afa1a04", "filename": "CODE_OF_CONDUCT.md", "status": "modified", "additions": 1, "deletions": 38, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/b5bd31ec6db6a249311888a93fc176f06dcb6aa6/CODE_OF_CONDUCT.md", "raw_url": "https://github.com/rust-lang/rust/raw/b5bd31ec6db6a249311888a93fc176f06dcb6aa6/CODE_OF_CONDUCT.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CODE_OF_CONDUCT.md?ref=b5bd31ec6db6a249311888a93fc176f06dcb6aa6", "patch": "@@ -1,40 +1,3 @@\n # The Rust Code of Conduct\n \n-A version of this document [can be found online](https://www.rust-lang.org/conduct.html).\n-\n-## Conduct\n-\n-**Contact**: [rust-mods@rust-lang.org](mailto:rust-mods@rust-lang.org)\n-\n-* We are committed to providing a friendly, safe and welcoming environment for all, regardless of level of experience, gender identity and expression, sexual orientation, disability, personal appearance, body size, race, ethnicity, age, religion, nationality, or other similar characteristic.\n-* On IRC, please avoid using overtly sexual nicknames or other nicknames that might detract from a friendly, safe and welcoming environment for all.\n-* Please be kind and courteous. There's no need to be mean or rude.\n-* Respect that people have differences of opinion and that every design or implementation choice carries a trade-off and numerous costs. There is seldom a right answer.\n-* Please keep unstructured critique to a minimum. If you have solid ideas you want to experiment with, make a fork and see how it works.\n-* We will exclude you from interaction if you insult, demean or harass anyone. That is not welcome behavior. We interpret the term \"harassment\" as including the definition in the <a href=\"http://citizencodeofconduct.org/\">Citizen Code of Conduct</a>; if you have any lack of clarity about what might be included in that concept, please read their definition. In particular, we don't tolerate behavior that excludes people in socially marginalized groups.\n-* Private harassment is also unacceptable. No matter who you are, if you feel you have been or are being harassed or made uncomfortable by a community member, please contact one of the channel ops or any of the [Rust moderation team][mod_team] immediately. Whether you're a regular contributor or a newcomer, we care about making this community a safe place for you and we've got your back.\n-* Likewise any spamming, trolling, flaming, baiting or other attention-stealing behavior is not welcome.\n-\n-## Moderation\n-\n-\n-These are the policies for upholding our community's standards of conduct. If you feel that a thread needs moderation, please contact the [Rust moderation team][mod_team].\n-\n-1. Remarks that violate the Rust standards of conduct, including hateful, hurtful, oppressive, or exclusionary remarks, are not allowed. (Cursing is allowed, but never targeting another user, and never in a hateful manner.)\n-2. Remarks that moderators find inappropriate, whether listed in the code of conduct or not, are also not allowed.\n-3. Moderators will first respond to such remarks with a warning.\n-4. If the warning is unheeded, the user will be \"kicked,\" i.e., kicked out of the communication channel to cool off.\n-5. If the user comes back and continues to make trouble, they will be banned, i.e., indefinitely excluded.\n-6. Moderators may choose at their discretion to un-ban the user if it was a first offense and they offer the offended party a genuine apology.\n-7. If a moderator bans someone and you think it was unjustified, please take it up with that moderator, or with a different moderator, **in private**. Complaints about bans in-channel are not allowed.\n-8. Moderators are held to a higher standard than other community members. If a moderator creates an inappropriate situation, they should expect less leeway than others.\n-\n-In the Rust community we strive to go the extra step to look out for each other. Don't just aim to be technically unimpeachable, try to be your best self. In particular, avoid flirting with offensive or sensitive issues, particularly if they're off-topic; this all too often leads to unnecessary fights, hurt feelings, and damaged trust; worse, it can drive people away from the community entirely.\n-\n-And if someone takes issue with something you said or did, resist the urge to be defensive. Just stop doing what it was they complained about and apologize. Even if you feel you were misinterpreted or unfairly accused, chances are good there was something you could've communicated better \u2014 remember that it's your responsibility to make your fellow Rustaceans comfortable. Everyone wants to get along and we are all here first and foremost because we want to talk about cool technology. You will find that people will be eager to assume good intent and forgive as long as you earn their trust.\n-\n-The enforcement policies listed above apply to all official Rust venues; including all communication channels (Rust Discord server, Rust Zulip server); GitHub repositories under rust-lang, rust-lang-nursery, and rust-lang-deprecated; and all forums under rust-lang.org (users.rust-lang.org, internals.rust-lang.org). For other projects adopting the Rust Code of Conduct, please contact the maintainers of those projects for enforcement. If you wish to use this code of conduct for your own project, consider explicitly mentioning your moderation policy or making a copy with your own moderation policy so as to avoid confusion.\n-\n-*Adapted from the [Node.js Policy on Trolling](https://blog.izs.me/2012/08/policy-on-trolling) as well as the [Contributor Covenant v1.3.0](https://www.contributor-covenant.org/version/1/3/0/).*\n-\n-[mod_team]: https://www.rust-lang.org/team.html#Moderation-team\n+The Code of Conduct for this repository [can be found online](https://www.rust-lang.org/conduct.html)."}, {"sha": "e0cb00cf697f4bcf83dcd6d0efcd1d956acea6b5", "filename": "src/librustc/dep_graph/graph.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b5bd31ec6db6a249311888a93fc176f06dcb6aa6/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5bd31ec6db6a249311888a93fc176f06dcb6aa6/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fgraph.rs?ref=b5bd31ec6db6a249311888a93fc176f06dcb6aa6", "patch": "@@ -9,7 +9,6 @@ use std::hash::Hash;\n use std::collections::hash_map::Entry;\n use std::mem;\n use crate::ty::{self, TyCtxt};\n-use crate::util::common::{ProfileQueriesMsg, profq_msg};\n use parking_lot::{Mutex, Condvar};\n \n use crate::ich::{StableHashingContext, StableHashingContextProvider, Fingerprint};\n@@ -256,10 +255,6 @@ impl DepGraph {\n             //  - we can get an idea of the runtime cost.\n             let mut hcx = cx.get_stable_hashing_context();\n \n-            if cfg!(debug_assertions) {\n-                profq_msg(hcx.sess(), ProfileQueriesMsg::TaskBegin(key.clone()))\n-            };\n-\n             let result = if no_tcx {\n                 task(cx, arg)\n             } else {\n@@ -275,10 +270,6 @@ impl DepGraph {\n                 })\n             };\n \n-            if cfg!(debug_assertions) {\n-                profq_msg(hcx.sess(), ProfileQueriesMsg::TaskEnd)\n-            };\n-\n             let current_fingerprint = hash_result(&mut hcx, &result);\n \n             let dep_node_index = finish_task_and_alloc_depnode("}, {"sha": "0c9760b3c0f4031dfd449fcdeeed4126ab6f0dab", "filename": "src/librustc/error_codes.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b5bd31ec6db6a249311888a93fc176f06dcb6aa6/src%2Flibrustc%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5bd31ec6db6a249311888a93fc176f06dcb6aa6/src%2Flibrustc%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ferror_codes.rs?ref=b5bd31ec6db6a249311888a93fc176f06dcb6aa6", "patch": "@@ -466,7 +466,6 @@ fn main() {\n ```\n \"##,\n \n-\n E0139: r##\"\n #### Note: this error code is no longer emitted by the compiler.\n \n@@ -1562,7 +1561,9 @@ fn transmute_lifetime<'a, T>(t: &'a (T,)) -> &'a T {\n \"##,\n \n E0496: r##\"\n-A lifetime name is shadowing another lifetime name. Erroneous code example:\n+A lifetime name is shadowing another lifetime name.\n+\n+Erroneous code example:\n \n ```compile_fail,E0496\n struct Foo<'a> {\n@@ -1594,8 +1595,11 @@ fn main() {\n \"##,\n \n E0497: r##\"\n-A stability attribute was used outside of the standard library. Erroneous code\n-example:\n+#### Note: this error code is no longer emitted by the compiler.\n+\n+A stability attribute was used outside of the standard library.\n+\n+Erroneous code example:\n \n ```compile_fail\n #[stable] // error: stability attributes may not be used outside of the\n@@ -2125,7 +2129,7 @@ rejected in your own crates.\n //  E0272, // on_unimplemented #0\n //  E0273, // on_unimplemented #1\n //  E0274, // on_unimplemented #2\n-    E0278, // requirement is not satisfied\n+//  E0278, // requirement is not satisfied\n     E0279, // requirement is not satisfied\n     E0280, // requirement is not satisfied\n //  E0285, // overflow evaluation builtin bounds\n@@ -2165,10 +2169,10 @@ rejected in your own crates.\n     E0687, // in-band lifetimes cannot be used in `fn`/`Fn` syntax\n     E0688, // in-band lifetimes cannot be mixed with explicit lifetime binders\n     E0697, // closures cannot be static\n-    E0707, // multiple elided lifetimes used in arguments of `async fn`\n+//  E0707, // multiple elided lifetimes used in arguments of `async fn`\n     E0708, // `async` non-`move` closures with parameters are not currently\n            // supported\n-    E0709, // multiple different lifetimes used in arguments of `async fn`\n+//  E0709, // multiple different lifetimes used in arguments of `async fn`\n     E0710, // an unknown tool name found in scoped lint\n     E0711, // a feature has been declared with conflicting stability attributes\n //  E0702, // replaced with a generic attribute input check"}, {"sha": "1f792ecc2da9031fb3b78b3afe990272b8670868", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b5bd31ec6db6a249311888a93fc176f06dcb6aa6/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5bd31ec6db6a249311888a93fc176f06dcb6aa6/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=b5bd31ec6db6a249311888a93fc176f06dcb6aa6", "patch": "@@ -1548,6 +1548,19 @@ impl Expr {\n             }\n         }\n     }\n+\n+    /// If `Self.kind` is `ExprKind::DropTemps(expr)`, drill down until we get a non-`DropTemps`\n+    /// `Expr`. This is used in suggestions to ignore this `ExprKind` as it is semantically\n+    /// silent, only signaling the ownership system. By doing this, suggestions that check the\n+    /// `ExprKind` of any given `Expr` for presentation don't have to care about `DropTemps`\n+    /// beyond remembering to call this function before doing analysis on it.\n+    pub fn peel_drop_temps(&self) -> &Self {\n+        let mut expr = self;\n+        while let ExprKind::DropTemps(inner) = &expr.kind {\n+            expr = inner;\n+        }\n+        expr\n+    }\n }\n \n impl fmt::Debug for Expr {"}, {"sha": "5ca474a8b1d91a32612e8b3554ee61e63e6e5d61", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b5bd31ec6db6a249311888a93fc176f06dcb6aa6/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5bd31ec6db6a249311888a93fc176f06dcb6aa6/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=b5bd31ec6db6a249311888a93fc176f06dcb6aa6", "patch": "@@ -368,6 +368,12 @@ pub mod parser {\n         Allow,\n         \"possible meta-variable misuse at macro definition\"\n     }\n+\n+    declare_lint! {\n+        pub INCOMPLETE_INCLUDE,\n+        Deny,\n+        \"trailing content in included file\"\n+    }\n }\n \n declare_lint! {"}, {"sha": "b31efc24e52d1fc3d93c9db9cce52ced0bd9c720", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b5bd31ec6db6a249311888a93fc176f06dcb6aa6/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5bd31ec6db6a249311888a93fc176f06dcb6aa6/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=b5bd31ec6db6a249311888a93fc176f06dcb6aa6", "patch": "@@ -28,6 +28,7 @@ use crate::hir::intravisit;\n use crate::hir;\n use crate::lint::builtin::BuiltinLintDiagnostics;\n use crate::lint::builtin::parser::{ILL_FORMED_ATTRIBUTE_INPUT, META_VARIABLE_MISUSE};\n+use crate::lint::builtin::parser::INCOMPLETE_INCLUDE;\n use crate::session::{Session, DiagnosticMessageId};\n use crate::ty::TyCtxt;\n use crate::ty::query::Providers;\n@@ -83,6 +84,7 @@ impl Lint {\n         match lint_id {\n             BufferedEarlyLintId::IllFormedAttributeInput => ILL_FORMED_ATTRIBUTE_INPUT,\n             BufferedEarlyLintId::MetaVariableMisuse => META_VARIABLE_MISUSE,\n+            BufferedEarlyLintId::IncompleteInclude => INCOMPLETE_INCLUDE,\n         }\n     }\n "}, {"sha": "4618a6277edffd538c97f8613389828d2fef3d2b", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b5bd31ec6db6a249311888a93fc176f06dcb6aa6/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5bd31ec6db6a249311888a93fc176f06dcb6aa6/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=b5bd31ec6db6a249311888a93fc176f06dcb6aa6", "patch": "@@ -1316,10 +1316,6 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n         \"dump the dependency graph to $RUST_DEP_GRAPH (default: /tmp/dep_graph.gv)\"),\n     query_dep_graph: bool = (false, parse_bool, [UNTRACKED],\n         \"enable queries of the dependency graph for regression testing\"),\n-    profile_queries: bool = (false, parse_bool, [UNTRACKED],\n-        \"trace and profile the queries of the incremental compilation framework\"),\n-    profile_queries_and_keys: bool = (false, parse_bool, [UNTRACKED],\n-        \"trace and profile the queries and keys of the incremental compilation framework\"),\n     no_analysis: bool = (false, parse_bool, [UNTRACKED],\n         \"parse and expand the source, but run no analysis\"),\n     extra_plugins: Vec<String> = (Vec::new(), parse_list, [TRACKED],"}, {"sha": "9d60221fa3d753a83acc72155a737a27ba5f444c", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 1, "deletions": 13, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b5bd31ec6db6a249311888a93fc176f06dcb6aa6/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5bd31ec6db6a249311888a93fc176f06dcb6aa6/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=b5bd31ec6db6a249311888a93fc176f06dcb6aa6", "patch": "@@ -11,7 +11,6 @@ use crate::session::config::{OutputType, PrintRequest, SwitchWithOptPath};\n use crate::session::search_paths::{PathKind, SearchPath};\n use crate::util::nodemap::{FxHashMap, FxHashSet};\n use crate::util::common::{duration_to_secs_str, ErrorReported};\n-use crate::util::common::ProfileQueriesMsg;\n \n use rustc_data_structures::base_n;\n use rustc_data_structures::sync::{\n@@ -46,7 +45,7 @@ use std::fmt;\n use std::io::Write;\n use std::path::PathBuf;\n use std::time::Duration;\n-use std::sync::{Arc, mpsc};\n+use std::sync::Arc;\n \n mod code_stats;\n pub mod config;\n@@ -125,9 +124,6 @@ pub struct Session {\n     /// `-Zquery-dep-graph` is specified.\n     pub cgu_reuse_tracker: CguReuseTracker,\n \n-    /// Used by `-Z profile-queries` in `util::common`.\n-    pub profile_channel: Lock<Option<mpsc::Sender<ProfileQueriesMsg>>>,\n-\n     /// Used by `-Z self-profile`.\n     pub prof: SelfProfilerRef,\n \n@@ -509,13 +505,6 @@ impl Session {\n     pub fn time_extended(&self) -> bool {\n         self.opts.debugging_opts.time_passes\n     }\n-    pub fn profile_queries(&self) -> bool {\n-        self.opts.debugging_opts.profile_queries\n-            || self.opts.debugging_opts.profile_queries_and_keys\n-    }\n-    pub fn profile_queries_and_keys(&self) -> bool {\n-        self.opts.debugging_opts.profile_queries_and_keys\n-    }\n     pub fn instrument_mcount(&self) -> bool {\n         self.opts.debugging_opts.instrument_mcount\n     }\n@@ -1234,7 +1223,6 @@ fn build_session_(\n         incr_comp_session: OneThread::new(RefCell::new(IncrCompSession::NotInitialized)),\n         cgu_reuse_tracker,\n         prof: SelfProfilerRef::new(self_profiler),\n-        profile_channel: Lock::new(None),\n         perf_stats: PerfStats {\n             symbol_hash_time: Lock::new(Duration::from_secs(0)),\n             decode_def_path_tables_time: Lock::new(Duration::from_secs(0)),"}, {"sha": "1bba7fdd863ea5653b64528319983a4986dfacd5", "filename": "src/librustc/ty/query/on_disk_cache.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b5bd31ec6db6a249311888a93fc176f06dcb6aa6/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5bd31ec6db6a249311888a93fc176f06dcb6aa6/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs?ref=b5bd31ec6db6a249311888a93fc176f06dcb6aa6", "patch": "@@ -1075,7 +1075,7 @@ where\n     let desc = &format!(\"encode_query_results for {}\",\n         ::std::any::type_name::<Q>());\n \n-    time_ext(tcx.sess.time_extended(), Some(tcx.sess), desc, || {\n+    time_ext(tcx.sess.time_extended(), desc, || {\n         let shards = Q::query_cache(tcx).lock_shards();\n         assert!(shards.iter().all(|shard| shard.active.is_empty()));\n         for (key, entry) in shards.iter().flat_map(|shard| shard.results.iter()) {"}, {"sha": "7f05e553bc9765273d91dfd4f7157cad4873bf68", "filename": "src/librustc/ty/query/plumbing.rs", "status": "modified", "additions": 0, "deletions": 49, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/b5bd31ec6db6a249311888a93fc176f06dcb6aa6/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5bd31ec6db6a249311888a93fc176f06dcb6aa6/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs?ref=b5bd31ec6db6a249311888a93fc176f06dcb6aa6", "patch": "@@ -9,8 +9,6 @@ use crate::ty::query::Query;\n use crate::ty::query::config::{QueryConfig, QueryDescription};\n use crate::ty::query::job::{QueryJob, QueryResult, QueryInfo};\n \n-use crate::util::common::{profq_msg, ProfileQueriesMsg, QueryMsg};\n-\n use errors::DiagnosticBuilder;\n use errors::Level;\n use errors::Diagnostic;\n@@ -62,33 +60,6 @@ impl<'tcx, M: QueryConfig<'tcx>> Default for QueryCache<'tcx, M> {\n     }\n }\n \n-// If enabled, sends a message to the profile-queries thread.\n-macro_rules! profq_msg {\n-    ($tcx:expr, $msg:expr) => {\n-        if cfg!(debug_assertions) {\n-            if $tcx.sess.profile_queries() {\n-                profq_msg($tcx.sess, $msg)\n-            }\n-        }\n-    }\n-}\n-\n-// If enabled, formats a key using its debug string, which can be\n-// expensive to compute (in terms of time).\n-macro_rules! profq_query_msg {\n-    ($query:expr, $tcx:expr, $key:expr) => {{\n-        let msg = if cfg!(debug_assertions) {\n-            if $tcx.sess.profile_queries_and_keys() {\n-                Some(format!(\"{:?}\", $key))\n-            } else { None }\n-        } else { None };\n-        QueryMsg {\n-            query: $query,\n-            msg,\n-        }\n-    }}\n-}\n-\n /// A type representing the responsibility to execute the job in the `job` field.\n /// This will poison the relevant query if dropped.\n pub(super) struct JobOwner<'a, 'tcx, Q: QueryDescription<'tcx>> {\n@@ -111,7 +82,6 @@ impl<'a, 'tcx, Q: QueryDescription<'tcx>> JobOwner<'a, 'tcx, Q> {\n         loop {\n             let mut lock = cache.get_shard_by_value(key).lock();\n             if let Some(value) = lock.results.get(key) {\n-                profq_msg!(tcx, ProfileQueriesMsg::CacheHit);\n                 tcx.prof.query_cache_hit(Q::NAME);\n                 let result = (value.value.clone(), value.index);\n                 #[cfg(debug_assertions)]\n@@ -358,13 +328,6 @@ impl<'tcx> TyCtxt<'tcx> {\n                key,\n                span);\n \n-        profq_msg!(self,\n-            ProfileQueriesMsg::QueryBegin(\n-                span.data(),\n-                profq_query_msg!(Q::NAME.as_str(), self, key),\n-            )\n-        );\n-\n         let job = match JobOwner::try_get(self, span, &key) {\n             TryGetJob::NotYetStarted(job) => job,\n             TryGetJob::Cycle(result) => return result,\n@@ -383,7 +346,6 @@ impl<'tcx> TyCtxt<'tcx> {\n \n         if Q::ANON {\n \n-            profq_msg!(self, ProfileQueriesMsg::ProviderBegin);\n             let prof_timer = self.prof.query_provider(Q::NAME);\n \n             let ((result, dep_node_index), diagnostics) = with_diagnostics(|diagnostics| {\n@@ -395,7 +357,6 @@ impl<'tcx> TyCtxt<'tcx> {\n             });\n \n             drop(prof_timer);\n-            profq_msg!(self, ProfileQueriesMsg::ProviderEnd);\n \n             self.dep_graph.read_index(dep_node_index);\n \n@@ -468,7 +429,6 @@ impl<'tcx> TyCtxt<'tcx> {\n         };\n \n         let result = if let Some(result) = result {\n-            profq_msg!(self, ProfileQueriesMsg::CacheHit);\n             result\n         } else {\n             // We could not load a result from the on-disk cache, so\n@@ -542,7 +502,6 @@ impl<'tcx> TyCtxt<'tcx> {\n                  - dep-node: {:?}\",\n                 key, dep_node);\n \n-        profq_msg!(self, ProfileQueriesMsg::ProviderBegin);\n         let prof_timer = self.prof.query_provider(Q::NAME);\n \n         let ((result, dep_node_index), diagnostics) = with_diagnostics(|diagnostics| {\n@@ -564,7 +523,6 @@ impl<'tcx> TyCtxt<'tcx> {\n         });\n \n         drop(prof_timer);\n-        profq_msg!(self, ProfileQueriesMsg::ProviderEnd);\n \n         if unlikely!(!diagnostics.is_empty()) {\n             if dep_node.kind != crate::dep_graph::DepKind::Null {\n@@ -606,19 +564,12 @@ impl<'tcx> TyCtxt<'tcx> {\n \n             let _ = self.get_query::<Q>(DUMMY_SP, key);\n         } else {\n-            profq_msg!(self, ProfileQueriesMsg::CacheHit);\n             self.prof.query_cache_hit(Q::NAME);\n         }\n     }\n \n     #[allow(dead_code)]\n     fn force_query<Q: QueryDescription<'tcx>>(self, key: Q::Key, span: Span, dep_node: DepNode) {\n-        profq_msg!(\n-            self,\n-            ProfileQueriesMsg::QueryBegin(span.data(),\n-                                          profq_query_msg!(Q::NAME.as_str(), self, key))\n-        );\n-\n         // We may be concurrently trying both execute and force a query.\n         // Ensure that only one of them runs the query.\n         let job = match JobOwner::try_get(self, span, &key) {"}, {"sha": "3e52a6aa50850c12901e0f9b8c5cac6e418a5374", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 2, "deletions": 73, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/b5bd31ec6db6a249311888a93fc176f06dcb6aa6/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5bd31ec6db6a249311888a93fc176f06dcb6aa6/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=b5bd31ec6db6a249311888a93fc176f06dcb6aa6", "patch": "@@ -6,11 +6,8 @@ use std::cell::Cell;\n use std::fmt::Debug;\n use std::time::{Duration, Instant};\n \n-use std::sync::mpsc::{Sender};\n-use syntax_pos::{SpanData};\n use syntax::symbol::{Symbol, sym};\n use rustc_macros::HashStable;\n-use crate::dep_graph::{DepNode};\n use crate::session::Session;\n \n #[cfg(test)]\n@@ -26,71 +23,13 @@ pub struct ErrorReported;\n \n thread_local!(static TIME_DEPTH: Cell<usize> = Cell::new(0));\n \n-/// Parameters to the `Dump` variant of type `ProfileQueriesMsg`.\n-#[derive(Clone,Debug)]\n-pub struct ProfQDumpParams {\n-    /// A base path for the files we will dump.\n-    pub path:String,\n-    /// To ensure that the compiler waits for us to finish our dumps.\n-    pub ack:Sender<()>,\n-    /// Toggle dumping a log file with every `ProfileQueriesMsg`.\n-    pub dump_profq_msg_log:bool,\n-}\n-\n #[allow(nonstandard_style)]\n #[derive(Clone, Debug, PartialEq, Eq)]\n pub struct QueryMsg {\n     pub query: &'static str,\n     pub msg: Option<String>,\n }\n \n-/// A sequence of these messages induce a trace of query-based incremental compilation.\n-// FIXME(matthewhammer): Determine whether we should include cycle detection here or not.\n-#[derive(Clone,Debug)]\n-pub enum ProfileQueriesMsg {\n-    /// Begin a timed pass.\n-    TimeBegin(String),\n-    /// End a timed pass.\n-    TimeEnd,\n-    /// Begin a task (see `dep_graph::graph::with_task`).\n-    TaskBegin(DepNode),\n-    /// End a task.\n-    TaskEnd,\n-    /// Begin a new query.\n-    /// Cannot use `Span` because queries are sent to other thread.\n-    QueryBegin(SpanData, QueryMsg),\n-    /// Query is satisfied by using an already-known value for the given key.\n-    CacheHit,\n-    /// Query requires running a provider; providers may nest, permitting queries to nest.\n-    ProviderBegin,\n-    /// Query is satisfied by a provider terminating with a value.\n-    ProviderEnd,\n-    /// Dump a record of the queries to the given path.\n-    Dump(ProfQDumpParams),\n-    /// Halt the profiling/monitoring background thread.\n-    Halt\n-}\n-\n-/// If enabled, send a message to the profile-queries thread.\n-pub fn profq_msg(sess: &Session, msg: ProfileQueriesMsg) {\n-    if let Some(s) = sess.profile_channel.borrow().as_ref() {\n-        s.send(msg).unwrap()\n-    } else {\n-        // Do nothing.\n-    }\n-}\n-\n-/// Set channel for profile queries channel.\n-pub fn profq_set_chan(sess: &Session, s: Sender<ProfileQueriesMsg>) -> bool {\n-    let mut channel = sess.profile_channel.borrow_mut();\n-    if channel.is_none() {\n-        *channel = Some(s);\n-        true\n-    } else {\n-        false\n-    }\n-}\n-\n /// Read the current depth of `time()` calls. This is used to\n /// encourage indentation across threads.\n pub fn time_depth() -> usize {\n@@ -107,10 +46,10 @@ pub fn set_time_depth(depth: usize) {\n pub fn time<T, F>(sess: &Session, what: &str, f: F) -> T where\n     F: FnOnce() -> T,\n {\n-    time_ext(sess.time_passes(), Some(sess), what, f)\n+    time_ext(sess.time_passes(), what, f)\n }\n \n-pub fn time_ext<T, F>(do_it: bool, sess: Option<&Session>, what: &str, f: F) -> T where\n+pub fn time_ext<T, F>(do_it: bool, what: &str, f: F) -> T where\n     F: FnOnce() -> T,\n {\n     if !do_it { return f(); }\n@@ -121,19 +60,9 @@ pub fn time_ext<T, F>(do_it: bool, sess: Option<&Session>, what: &str, f: F) ->\n         r\n     });\n \n-    if let Some(sess) = sess {\n-        if cfg!(debug_assertions) {\n-            profq_msg(sess, ProfileQueriesMsg::TimeBegin(what.to_string()))\n-        }\n-    }\n     let start = Instant::now();\n     let rv = f();\n     let dur = start.elapsed();\n-    if let Some(sess) = sess {\n-        if cfg!(debug_assertions) {\n-            profq_msg(sess, ProfileQueriesMsg::TimeEnd)\n-        }\n-    }\n \n     print_time_passes_entry(true, what, dur);\n "}, {"sha": "7437b1e3c8a32e2f7c31599d57a117fd86015de7", "filename": "src/librustc_codegen_llvm/back/lto.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b5bd31ec6db6a249311888a93fc176f06dcb6aa6/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5bd31ec6db6a249311888a93fc176f06dcb6aa6/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs?ref=b5bd31ec6db6a249311888a93fc176f06dcb6aa6", "patch": "@@ -116,7 +116,7 @@ fn prepare_lto(cgcx: &CodegenContext<LlvmCodegenBackend>,\n                 info!(\"adding bytecode {}\", name);\n                 let bc_encoded = data.data();\n \n-                let (bc, id) = time_ext(cgcx.time_passes, None, &format!(\"decode {}\", name), || {\n+                let (bc, id) = time_ext(cgcx.time_passes, &format!(\"decode {}\", name), || {\n                     match DecodedBytecode::new(bc_encoded) {\n                         Ok(b) => Ok((b.bytecode(), b.identifier().to_string())),\n                         Err(e) => Err(diag_handler.fatal(&e)),\n@@ -295,7 +295,7 @@ fn fat_lto(cgcx: &CodegenContext<LlvmCodegenBackend>,\n         for (bc_decoded, name) in serialized_modules {\n             let _timer = cgcx.prof.generic_activity(\"LLVM_fat_lto_link_module\");\n             info!(\"linking {:?}\", name);\n-            time_ext(cgcx.time_passes, None, &format!(\"ll link {:?}\", name), || {\n+            time_ext(cgcx.time_passes, &format!(\"ll link {:?}\", name), || {\n                 let data = bc_decoded.data();\n                 linker.add(&data).map_err(|()| {\n                     let msg = format!(\"failed to load bc of {:?}\", name);\n@@ -590,7 +590,7 @@ pub(crate) fn run_pass_manager(cgcx: &CodegenContext<LlvmCodegenBackend>,\n             llvm::LLVMRustAddPass(pm, pass.unwrap());\n         }\n \n-        time_ext(cgcx.time_passes, None, \"LTO passes\", ||\n+        time_ext(cgcx.time_passes, \"LTO passes\", ||\n              llvm::LLVMRunPassManager(pm, module.module_llvm.llmod()));\n \n         llvm::LLVMDisposePassManager(pm);"}, {"sha": "52f3a1cbb5c30b06959ddd66d120f79557fe2b4a", "filename": "src/librustc_codegen_llvm/back/write.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b5bd31ec6db6a249311888a93fc176f06dcb6aa6/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5bd31ec6db6a249311888a93fc176f06dcb6aa6/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs?ref=b5bd31ec6db6a249311888a93fc176f06dcb6aa6", "patch": "@@ -427,7 +427,6 @@ pub(crate) unsafe fn optimize(cgcx: &CodegenContext<LlvmCodegenBackend>,\n         {\n             let _timer = cgcx.prof.generic_activity(\"LLVM_module_optimize_function_passes\");\n             time_ext(config.time_passes,\n-                        None,\n                         &format!(\"llvm function passes [{}]\", module_name.unwrap()),\n                         || {\n                 llvm::LLVMRustRunFunctionPassManager(fpm, llmod)\n@@ -436,7 +435,6 @@ pub(crate) unsafe fn optimize(cgcx: &CodegenContext<LlvmCodegenBackend>,\n         {\n             let _timer = cgcx.prof.generic_activity(\"LLVM_module_optimize_module_passes\");\n             time_ext(config.time_passes,\n-                    None,\n                     &format!(\"llvm module passes [{}]\", module_name.unwrap()),\n                     || {\n                 llvm::LLVMRunPassManager(mpm, llmod)\n@@ -538,7 +536,7 @@ pub(crate) unsafe fn codegen(cgcx: &CodegenContext<LlvmCodegenBackend>,\n             embed_bitcode(cgcx, llcx, llmod, None);\n         }\n \n-        time_ext(config.time_passes, None, &format!(\"codegen passes [{}]\", module_name.unwrap()),\n+        time_ext(config.time_passes, &format!(\"codegen passes [{}]\", module_name.unwrap()),\n             || -> Result<(), FatalError> {\n             if config.emit_ir {\n                 let _timer = cgcx.prof.generic_activity(\"LLVM_module_codegen_emit_ir\");"}, {"sha": "1c5d3b1a890ee76dfcfcd60966208b55aeed3bfe", "filename": "src/librustc_codegen_ssa/back/link.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b5bd31ec6db6a249311888a93fc176f06dcb6aa6/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5bd31ec6db6a249311888a93fc176f06dcb6aa6/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs?ref=b5bd31ec6db6a249311888a93fc176f06dcb6aa6", "patch": "@@ -1535,7 +1535,7 @@ fn add_upstream_rust_crates<'a, B: ArchiveBuilder<'a>>(\n         let name = cratepath.file_name().unwrap().to_str().unwrap();\n         let name = &name[3..name.len() - 5]; // chop off lib/.rlib\n \n-        time_ext(sess.time_extended(), Some(sess), &format!(\"altering {}.rlib\", name), || {\n+        time_ext(sess.time_extended(), &format!(\"altering {}.rlib\", name), || {\n             let mut archive = <B as ArchiveBuilder>::new(sess, &dst, Some(cratepath));\n             archive.update_symbols();\n "}, {"sha": "b7f4df62b494b637ee266acf3d4fa856163af937", "filename": "src/librustc_incremental/persist/load.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b5bd31ec6db6a249311888a93fc176f06dcb6aa6/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5bd31ec6db6a249311888a93fc176f06dcb6aa6/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fload.rs?ref=b5bd31ec6db6a249311888a93fc176f06dcb6aa6", "patch": "@@ -160,7 +160,7 @@ pub fn load_dep_graph(sess: &Session) -> DepGraphFuture {\n     }\n \n     MaybeAsync::Async(std::thread::spawn(move || {\n-        time_ext(time_passes, None, \"background load prev dep-graph\", move || {\n+        time_ext(time_passes, \"background load prev dep-graph\", move || {\n             match load_data(report_incremental_info, &path) {\n                 LoadResult::DataOutOfDate => LoadResult::DataOutOfDate,\n                 LoadResult::Error { message } => LoadResult::Error { message },"}, {"sha": "b26bd75c974c6b67edae5cdc985ab475cf77d484", "filename": "src/librustc_interface/interface.rs", "status": "modified", "additions": 1, "deletions": 12, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b5bd31ec6db6a249311888a93fc176f06dcb6aa6/src%2Flibrustc_interface%2Finterface.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5bd31ec6db6a249311888a93fc176f06dcb6aa6/src%2Flibrustc_interface%2Finterface.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Finterface.rs?ref=b5bd31ec6db6a249311888a93fc176f06dcb6aa6", "patch": "@@ -1,6 +1,5 @@\n use crate::queries::Queries;\n use crate::util;\n-use crate::profile;\n pub use crate::passes::BoxedResolver;\n \n use rustc::lint;\n@@ -115,17 +114,7 @@ where\n         compiler.sess.diagnostic().print_error_count(&util::diagnostics_registry());\n     });\n \n-    if compiler.sess.profile_queries() {\n-        profile::begin(&compiler.sess);\n-    }\n-\n-    let r = f(&compiler);\n-\n-    if compiler.sess.profile_queries() {\n-        profile::dump(&compiler.sess, \"profile_queries\".to_string())\n-    }\n-\n-    r\n+    f(&compiler)\n }\n \n pub fn run_compiler<F, R>(mut config: Config, f: F) -> R"}, {"sha": "6be36e9b9001b80d608950547b3b07a7f7b865ad", "filename": "src/librustc_interface/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b5bd31ec6db6a249311888a93fc176f06dcb6aa6/src%2Flibrustc_interface%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5bd31ec6db6a249311888a93fc176f06dcb6aa6/src%2Flibrustc_interface%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Flib.rs?ref=b5bd31ec6db6a249311888a93fc176f06dcb6aa6", "patch": "@@ -16,6 +16,5 @@ mod passes;\n mod queries;\n pub mod util;\n mod proc_macro_decls;\n-mod profile;\n \n pub use interface::{run_compiler, Config};"}, {"sha": "2e71d46f4154c6384c5f1a0768df2761b0ba0be6", "filename": "src/librustc_interface/profile/mod.rs", "status": "removed", "additions": 0, "deletions": 297, "changes": 297, "blob_url": "https://github.com/rust-lang/rust/blob/2748a9fd93dd1a00a4521f4f16de5befbf77f6cd/src%2Flibrustc_interface%2Fprofile%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2748a9fd93dd1a00a4521f4f16de5befbf77f6cd/src%2Flibrustc_interface%2Fprofile%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fprofile%2Fmod.rs?ref=2748a9fd93dd1a00a4521f4f16de5befbf77f6cd", "patch": "@@ -1,297 +0,0 @@\n-use log::debug;\n-use rustc::dep_graph::DepNode;\n-use rustc::session::Session;\n-use rustc::util::common::{ProfQDumpParams, ProfileQueriesMsg, profq_msg, profq_set_chan};\n-use std::sync::mpsc::{Receiver};\n-use std::io::{Write};\n-use std::time::{Duration, Instant};\n-\n-pub mod trace;\n-\n-/// begin a profile thread, if not already running\n-pub fn begin(sess: &Session) {\n-    use std::thread;\n-    use std::sync::mpsc::{channel};\n-    let (tx, rx) = channel();\n-    if profq_set_chan(sess, tx) {\n-        thread::spawn(move || profile_queries_thread(rx));\n-    }\n-}\n-\n-/// dump files with profiling information to the given base path, and\n-/// wait for this dump to complete.\n-///\n-/// wraps the RPC (send/recv channel logic) of requesting a dump.\n-pub fn dump(sess: &Session, path: String) {\n-    use std::sync::mpsc::{channel};\n-    let (tx, rx) = channel();\n-    let params = ProfQDumpParams {\n-        path,\n-        ack: tx,\n-        // FIXME: Add another compiler flag to toggle whether this log\n-        // is written; false for now\n-        dump_profq_msg_log: true,\n-    };\n-    profq_msg(sess, ProfileQueriesMsg::Dump(params));\n-    let _ = rx.recv().unwrap();\n-}\n-\n-// State for parsing recursive trace structure in separate thread, via messages\n-#[derive(Clone, Eq, PartialEq)]\n-enum ParseState {\n-    // No (local) parse state; may be parsing a tree, focused on a\n-    // sub-tree that could be anything.\n-    Clear,\n-    // Have Query information from the last message\n-    HaveQuery(trace::Query, Instant),\n-    // Have \"time-begin\" information from the last message (doit flag, and message)\n-    HaveTimeBegin(String, Instant),\n-    // Have \"task-begin\" information from the last message\n-    HaveTaskBegin(DepNode, Instant),\n-}\n-struct StackFrame {\n-    pub parse_st: ParseState,\n-    pub traces:   Vec<trace::Rec>,\n-}\n-\n-fn total_duration(traces: &[trace::Rec]) -> Duration {\n-    Duration::new(0, 0) + traces.iter().map(|t| t.dur_total).sum()\n-}\n-\n-// profiling thread; retains state (in local variables) and dump traces, upon request.\n-fn profile_queries_thread(r: Receiver<ProfileQueriesMsg>) {\n-    use self::trace::*;\n-    use std::fs::File;\n-\n-    let mut profq_msgs: Vec<ProfileQueriesMsg> = vec![];\n-    let mut frame: StackFrame = StackFrame { parse_st: ParseState::Clear, traces: vec![] };\n-    let mut stack: Vec<StackFrame> = vec![];\n-    loop {\n-        let msg = r.recv();\n-        if let Err(_recv_err) = msg {\n-            // FIXME: Perhaps do something smarter than simply quitting?\n-            break\n-        };\n-        let msg = msg.unwrap();\n-        debug!(\"profile_queries_thread: {:?}\", msg);\n-\n-        // Meta-level versus _actual_ queries messages\n-        match msg {\n-            ProfileQueriesMsg::Halt => return,\n-            ProfileQueriesMsg::Dump(params) => {\n-                assert!(stack.is_empty());\n-                assert!(frame.parse_st == ParseState::Clear);\n-\n-                // write log of all messages\n-                if params.dump_profq_msg_log {\n-                    let mut log_file =\n-                        File::create(format!(\"{}.log.txt\", params.path)).unwrap();\n-                    for m in profq_msgs.iter() {\n-                        writeln!(&mut log_file, \"{:?}\", m).unwrap()\n-                    };\n-                }\n-\n-                // write HTML file, and counts file\n-                let html_path = format!(\"{}.html\", params.path);\n-                let mut html_file = File::create(&html_path).unwrap();\n-\n-                let counts_path = format!(\"{}.counts.txt\", params.path);\n-                let mut counts_file = File::create(&counts_path).unwrap();\n-\n-                writeln!(html_file,\n-                    \"<html>\\n<head>\\n<link rel=\\\"stylesheet\\\" type=\\\"text/css\\\" href=\\\"{}\\\">\",\n-                    \"profile_queries.css\").unwrap();\n-                writeln!(html_file, \"<style>\").unwrap();\n-                trace::write_style(&mut html_file);\n-                writeln!(html_file, \"</style>\\n</head>\\n<body>\").unwrap();\n-                trace::write_traces(&mut html_file, &mut counts_file, &frame.traces);\n-                writeln!(html_file, \"</body>\\n</html>\").unwrap();\n-\n-                let ack_path = format!(\"{}.ack\", params.path);\n-                let ack_file = File::create(&ack_path).unwrap();\n-                drop(ack_file);\n-\n-                // Tell main thread that we are done, e.g., so it can exit\n-                params.ack.send(()).unwrap();\n-            }\n-            // Actual query message:\n-            msg => {\n-                // Record msg in our log\n-                profq_msgs.push(msg.clone());\n-                // Respond to the message, knowing that we've already handled Halt and Dump, above.\n-                match (frame.parse_st.clone(), msg) {\n-                    (_, ProfileQueriesMsg::Halt) | (_, ProfileQueriesMsg::Dump(_)) => {\n-                        unreachable!();\n-                    },\n-                    // Parse State: Clear\n-                    (ParseState::Clear,\n-                     ProfileQueriesMsg::QueryBegin(span, querymsg)) => {\n-                        let start = Instant::now();\n-                        frame.parse_st = ParseState::HaveQuery\n-                            (Query { span, msg: querymsg }, start)\n-                    },\n-                    (ParseState::Clear,\n-                     ProfileQueriesMsg::CacheHit) => {\n-                        panic!(\"parse error: unexpected CacheHit; expected QueryBegin\")\n-                    },\n-                    (ParseState::Clear,\n-                     ProfileQueriesMsg::ProviderBegin) => {\n-                        panic!(\"parse error: expected QueryBegin before beginning a provider\")\n-                    },\n-                    (ParseState::Clear,\n-                     ProfileQueriesMsg::ProviderEnd) => {\n-                        let provider_extent = frame.traces;\n-                        match stack.pop() {\n-                            None =>\n-                                panic!(\"parse error: expected a stack frame; found an empty stack\"),\n-                            Some(old_frame) => {\n-                                match old_frame.parse_st {\n-                                    ParseState::HaveQuery(q, start) => {\n-                                        let duration = start.elapsed();\n-                                        frame = StackFrame{\n-                                            parse_st: ParseState::Clear,\n-                                            traces: old_frame.traces\n-                                        };\n-                                        let dur_extent = total_duration(&provider_extent);\n-                                        let trace = Rec {\n-                                            effect: Effect::QueryBegin(q, CacheCase::Miss),\n-                                            extent: Box::new(provider_extent),\n-                                            start: start,\n-                                            dur_self: duration - dur_extent,\n-                                            dur_total: duration,\n-                                        };\n-                                        frame.traces.push( trace );\n-                                    },\n-                                    _ => panic!(\"internal parse error: malformed parse stack\")\n-                                }\n-                            }\n-                        }\n-                    },\n-                    (ParseState::Clear,\n-                     ProfileQueriesMsg::TimeBegin(msg)) => {\n-                        let start = Instant::now();\n-                        frame.parse_st = ParseState::HaveTimeBegin(msg, start);\n-                        stack.push(frame);\n-                        frame = StackFrame{parse_st: ParseState::Clear, traces: vec![]};\n-                    },\n-                    (_, ProfileQueriesMsg::TimeBegin(_)) => {\n-                        panic!(\"parse error; did not expect time begin here\");\n-                    },\n-                    (ParseState::Clear,\n-                     ProfileQueriesMsg::TimeEnd) => {\n-                        let provider_extent = frame.traces;\n-                        match stack.pop() {\n-                            None =>\n-                                panic!(\"parse error: expected a stack frame; found an empty stack\"),\n-                            Some(old_frame) => {\n-                                match old_frame.parse_st {\n-                                    ParseState::HaveTimeBegin(msg, start) => {\n-                                        let duration = start.elapsed();\n-                                        frame = StackFrame{\n-                                            parse_st: ParseState::Clear,\n-                                            traces: old_frame.traces\n-                                        };\n-                                        let dur_extent = total_duration(&provider_extent);\n-                                        let trace = Rec {\n-                                            effect: Effect::TimeBegin(msg),\n-                                            extent: Box::new(provider_extent),\n-                                            start: start,\n-                                            dur_total: duration,\n-                                            dur_self: duration - dur_extent,\n-                                        };\n-                                        frame.traces.push( trace );\n-                                    },\n-                                    _ => panic!(\"internal parse error: malformed parse stack\")\n-                                }\n-                            }\n-                        }\n-                    },\n-                    (_, ProfileQueriesMsg::TimeEnd) => {\n-                        panic!(\"parse error\")\n-                    },\n-                    (ParseState::Clear,\n-                     ProfileQueriesMsg::TaskBegin(key)) => {\n-                        let start = Instant::now();\n-                        frame.parse_st = ParseState::HaveTaskBegin(key, start);\n-                        stack.push(frame);\n-                        frame = StackFrame{ parse_st: ParseState::Clear, traces: vec![] };\n-                    },\n-                    (_, ProfileQueriesMsg::TaskBegin(_)) => {\n-                        panic!(\"parse error; did not expect time begin here\");\n-                    },\n-                    (ParseState::Clear,\n-                     ProfileQueriesMsg::TaskEnd) => {\n-                        let provider_extent = frame.traces;\n-                        match stack.pop() {\n-                            None =>\n-                                panic!(\"parse error: expected a stack frame; found an empty stack\"),\n-                            Some(old_frame) => {\n-                                match old_frame.parse_st {\n-                                    ParseState::HaveTaskBegin(key, start) => {\n-                                        let duration = start.elapsed();\n-                                        frame = StackFrame{\n-                                            parse_st: ParseState::Clear,\n-                                            traces: old_frame.traces\n-                                        };\n-                                        let dur_extent = total_duration(&provider_extent);\n-                                        let trace = Rec {\n-                                            effect: Effect::TaskBegin(key),\n-                                            extent: Box::new(provider_extent),\n-                                            start: start,\n-                                            dur_total: duration,\n-                                            dur_self: duration - dur_extent,\n-                                        };\n-                                        frame.traces.push( trace );\n-                                    },\n-                                    _ => panic!(\"internal parse error: malformed parse stack\")\n-                                }\n-                            }\n-                        }\n-                    },\n-                    (_, ProfileQueriesMsg::TaskEnd) => {\n-                        panic!(\"parse error\")\n-                    },\n-                    // Parse State: HaveQuery\n-                    (ParseState::HaveQuery(q,start),\n-                     ProfileQueriesMsg::CacheHit) => {\n-                        let duration = start.elapsed();\n-                        let trace : Rec = Rec{\n-                            effect: Effect::QueryBegin(q, CacheCase::Hit),\n-                            extent: Box::new(vec![]),\n-                            start: start,\n-                            dur_self: duration,\n-                            dur_total: duration,\n-                        };\n-                        frame.traces.push( trace );\n-                        frame.parse_st = ParseState::Clear;\n-                    },\n-                    (ParseState::HaveQuery(_, _),\n-                     ProfileQueriesMsg::ProviderBegin) => {\n-                        stack.push(frame);\n-                        frame = StackFrame{ parse_st: ParseState::Clear, traces: vec![] };\n-                    },\n-\n-                    // Parse errors:\n-\n-                    (ParseState::HaveQuery(q, _),\n-                     ProfileQueriesMsg::ProviderEnd) => {\n-                        panic!(\"parse error: unexpected ProviderEnd; \\\n-                                expected something else to follow BeginQuery for {:?}\", q)\n-                    },\n-                    (ParseState::HaveQuery(q1, _),\n-                     ProfileQueriesMsg::QueryBegin(span2, querymsg2)) => {\n-                        panic!(\"parse error: unexpected QueryBegin; \\\n-                                earlier query is unfinished: {:?} and now {:?}\",\n-                               q1, Query{span:span2, msg: querymsg2})\n-                    },\n-                    (ParseState::HaveTimeBegin(_, _), _) => {\n-                        unreachable!()\n-                    },\n-                    (ParseState::HaveTaskBegin(_, _), _) => {\n-                        unreachable!()\n-                    },\n-                }\n-            }\n-        }\n-    }\n-}"}, {"sha": "95c4ea6ff23478ffd6868c06238be7d7e94d5190", "filename": "src/librustc_interface/profile/trace.rs", "status": "removed", "additions": 0, "deletions": 304, "changes": 304, "blob_url": "https://github.com/rust-lang/rust/blob/2748a9fd93dd1a00a4521f4f16de5befbf77f6cd/src%2Flibrustc_interface%2Fprofile%2Ftrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2748a9fd93dd1a00a4521f4f16de5befbf77f6cd/src%2Flibrustc_interface%2Fprofile%2Ftrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fprofile%2Ftrace.rs?ref=2748a9fd93dd1a00a4521f4f16de5befbf77f6cd", "patch": "@@ -1,304 +0,0 @@\n-use super::*;\n-use syntax_pos::SpanData;\n-use rustc_data_structures::fx::FxHashMap;\n-use rustc::util::common::QueryMsg;\n-use std::fs::File;\n-use std::time::{Duration, Instant};\n-use rustc::dep_graph::{DepNode};\n-\n-#[derive(Debug, Clone, Eq, PartialEq)]\n-pub struct Query {\n-    pub span: SpanData,\n-    pub msg: QueryMsg,\n-}\n-pub enum Effect {\n-    QueryBegin(Query, CacheCase),\n-    TimeBegin(String),\n-    TaskBegin(DepNode),\n-}\n-pub enum CacheCase {\n-    Hit, Miss\n-}\n-/// Recursive trace structure\n-pub struct Rec {\n-    pub effect: Effect,\n-    pub start: Instant,\n-    pub dur_self: Duration,\n-    pub dur_total: Duration,\n-    pub extent: Box<Vec<Rec>>,\n-}\n-pub struct QueryMetric {\n-    pub count: usize,\n-    pub dur_self: Duration,\n-    pub dur_total: Duration,\n-}\n-\n-fn cons(s: &str) -> String {\n-    let first = s.split(|d| d == '(' || d == '{').next();\n-    assert!(first.is_some() && first != Some(\"\"));\n-    first.unwrap().to_owned()\n-}\n-\n-pub fn cons_of_query_msg(q: &trace::Query) -> String {\n-    cons(&format!(\"{:?}\", q.msg))\n-}\n-\n-pub fn cons_of_key(k: &DepNode) -> String {\n-    cons(&format!(\"{:?}\", k))\n-}\n-\n-// First return value is text; second return value is a CSS class\n-pub fn html_of_effect(eff: &Effect) -> (String, String) {\n-    match *eff {\n-        Effect::TimeBegin(ref msg) => {\n-            (msg.clone(),\n-             \"time-begin\".to_string())\n-        },\n-        Effect::TaskBegin(ref key) => {\n-            let cons = cons_of_key(key);\n-            (cons.clone(), format!(\"{} task-begin\", cons))\n-        },\n-        Effect::QueryBegin(ref qmsg, ref cc) => {\n-            let cons = cons_of_query_msg(qmsg);\n-            (cons.clone(),\n-             format!(\"{} {}\",\n-                     cons,\n-                     match *cc {\n-                         CacheCase::Hit => \"hit\",\n-                         CacheCase::Miss => \"miss\",\n-                     }))\n-        }\n-    }\n-}\n-\n-// First return value is text; second return value is a CSS class\n-fn html_of_duration(_start: &Instant, dur: &Duration) -> (String, String) {\n-    use rustc::util::common::duration_to_secs_str;\n-    (duration_to_secs_str(dur.clone()), String::new())\n-}\n-\n-fn html_of_fraction(frac: f64) -> (String, &'static str) {\n-    let css = {\n-        if       frac > 0.50  { \"frac-50\" }\n-        else if  frac > 0.40  { \"frac-40\" }\n-        else if  frac > 0.30  { \"frac-30\" }\n-        else if  frac > 0.20  { \"frac-20\" }\n-        else if  frac > 0.10  { \"frac-10\" }\n-        else if  frac > 0.05  { \"frac-05\" }\n-        else if  frac > 0.02  { \"frac-02\" }\n-        else if  frac > 0.01  { \"frac-01\" }\n-        else if  frac > 0.001 { \"frac-001\" }\n-        else                  { \"frac-0\" }\n-    };\n-    let percent = frac * 100.0;\n-\n-    if percent > 0.1 {\n-        (format!(\"{:.1}%\", percent), css)\n-    } else {\n-        (\"< 0.1%\".to_string(), css)\n-    }\n-}\n-\n-fn total_duration(traces: &[Rec]) -> Duration {\n-    Duration::new(0, 0) + traces.iter().map(|t| t.dur_total).sum()\n-}\n-\n-fn duration_div(nom: Duration, den: Duration) -> f64 {\n-    fn to_nanos(d: Duration) -> u64 {\n-        d.as_secs() * 1_000_000_000 + d.subsec_nanos() as u64\n-    }\n-\n-    to_nanos(nom) as f64 / to_nanos(den) as f64\n-}\n-\n-fn write_traces_rec(file: &mut File, traces: &[Rec], total: Duration, depth: usize) {\n-    for t in traces {\n-        let (eff_text, eff_css_classes) = html_of_effect(&t.effect);\n-        let (dur_text, dur_css_classes) = html_of_duration(&t.start, &t.dur_total);\n-        let fraction = duration_div(t.dur_total, total);\n-        let percent = fraction * 100.0;\n-        let (frc_text, frc_css_classes) = html_of_fraction(fraction);\n-        writeln!(file, \"<div class=\\\"trace depth-{} extent-{}{} {} {} {}\\\">\",\n-                 depth,\n-                 t.extent.len(),\n-                 /* Heuristic for 'important' CSS class: */\n-                 if t.extent.len() > 5 || percent >= 1.0 { \" important\" } else { \"\" },\n-                 eff_css_classes,\n-                 dur_css_classes,\n-                 frc_css_classes,\n-        ).unwrap();\n-        writeln!(file, \"<div class=\\\"eff\\\">{}</div>\", eff_text).unwrap();\n-        writeln!(file, \"<div class=\\\"dur\\\">{}</div>\", dur_text).unwrap();\n-        writeln!(file, \"<div class=\\\"frc\\\">{}</div>\", frc_text).unwrap();\n-        write_traces_rec(file, &t.extent, total, depth + 1);\n-        writeln!(file, \"</div>\").unwrap();\n-    }\n-}\n-\n-fn compute_counts_rec(counts: &mut FxHashMap<String,QueryMetric>, traces: &[Rec]) {\n-    counts.reserve(traces.len());\n-    for t in traces.iter() {\n-        match t.effect {\n-            Effect::TimeBegin(ref msg) => {\n-                let qm = match counts.get(msg) {\n-                    Some(_qm) => panic!(\"TimeBegin with non-unique, repeat message\"),\n-                    None => QueryMetric {\n-                        count: 1,\n-                        dur_self: t.dur_self,\n-                        dur_total: t.dur_total,\n-                    }\n-                };\n-                counts.insert(msg.clone(), qm);\n-            },\n-            Effect::TaskBegin(ref key) => {\n-                let cons = cons_of_key(key);\n-                let qm = match counts.get(&cons) {\n-                    Some(qm) =>\n-                        QueryMetric {\n-                            count: qm.count + 1,\n-                            dur_self: qm.dur_self + t.dur_self,\n-                            dur_total: qm.dur_total + t.dur_total,\n-                        },\n-                    None => QueryMetric {\n-                        count: 1,\n-                        dur_self: t.dur_self,\n-                        dur_total: t.dur_total,\n-                    }\n-                };\n-                counts.insert(cons, qm);\n-            },\n-            Effect::QueryBegin(ref qmsg, ref _cc) => {\n-                let qcons = cons_of_query_msg(qmsg);\n-                let qm = match counts.get(&qcons) {\n-                    Some(qm) =>\n-                        QueryMetric {\n-                            count: qm.count + 1,\n-                            dur_total: qm.dur_total + t.dur_total,\n-                            dur_self: qm.dur_self + t.dur_self\n-                        },\n-                    None => QueryMetric {\n-                        count: 1,\n-                        dur_total: t.dur_total,\n-                        dur_self: t.dur_self,\n-                    }\n-                };\n-                counts.insert(qcons, qm);\n-            }\n-        }\n-        compute_counts_rec(counts, &t.extent)\n-    }\n-}\n-\n-pub fn write_counts(count_file: &mut File, counts: &mut FxHashMap<String, QueryMetric>) {\n-    use rustc::util::common::duration_to_secs_str;\n-    use std::cmp::Reverse;\n-\n-    let mut data = counts.iter().map(|(ref cons, ref qm)|\n-        (cons.clone(), qm.count.clone(), qm.dur_total.clone(), qm.dur_self.clone())\n-    ).collect::<Vec<_>>();\n-\n-    data.sort_by_key(|k| Reverse(k.3));\n-    for (cons, count, dur_total, dur_self) in data {\n-        writeln!(count_file, \"{}, {}, {}, {}\",\n-                 cons, count,\n-                 duration_to_secs_str(dur_total),\n-                 duration_to_secs_str(dur_self)\n-        ).unwrap();\n-    }\n-}\n-\n-pub fn write_traces(html_file: &mut File, counts_file: &mut File, traces: &[Rec]) {\n-    let capacity = traces.iter().fold(0, |acc, t| acc + 1 + t.extent.len());\n-    let mut counts = FxHashMap::with_capacity_and_hasher(capacity, Default::default());\n-    compute_counts_rec(&mut counts, traces);\n-    write_counts(counts_file, &mut counts);\n-\n-    let total: Duration = total_duration(traces);\n-    write_traces_rec(html_file, traces, total, 0)\n-}\n-\n-pub fn write_style(html_file: &mut File) {\n-    write!(html_file, \"{}\", \"\n-body {\n-    font-family: sans-serif;\n-    background: black;\n-}\n-.trace {\n-    color: black;\n-    display: inline-block;\n-    border-style: solid;\n-    border-color: red;\n-    border-width: 1px;\n-    border-radius: 5px;\n-    padding: 0px;\n-    margin: 1px;\n-    font-size: 0px;\n-}\n-.task-begin {\n-    border-width: 1px;\n-    color: white;\n-    border-color: #ff8;\n-    font-size: 0px;\n-}\n-.miss {\n-    border-color: red;\n-    border-width: 1px;\n-}\n-.extent-0 {\n-    padding: 2px;\n-}\n-.time-begin {\n-    border-width: 4px;\n-    font-size: 12px;\n-    color: white;\n-    border-color: #afa;\n-}\n-.important {\n-    border-width: 3px;\n-    font-size: 12px;\n-    color: white;\n-    border-color: #f77;\n-}\n-.hit {\n-    padding: 0px;\n-    border-color: blue;\n-    border-width: 3px;\n-}\n-.eff {\n-  color: #fff;\n-  display: inline-block;\n-}\n-.frc {\n-  color: #7f7;\n-  display: inline-block;\n-}\n-.dur {\n-  display: none\n-}\n-.frac-50 {\n-  padding: 10px;\n-  border-width: 10px;\n-  font-size: 32px;\n-}\n-.frac-40 {\n-  padding: 8px;\n-  border-width: 8px;\n-  font-size: 24px;\n-}\n-.frac-30 {\n-  padding: 6px;\n-  border-width: 6px;\n-  font-size: 18px;\n-}\n-.frac-20 {\n-  padding: 4px;\n-  border-width: 6px;\n-  font-size: 16px;\n-}\n-.frac-10 {\n-  padding: 2px;\n-  border-width: 6px;\n-  font-size: 14px;\n-}\n-\").unwrap();\n-}"}, {"sha": "2edc8fadf45684dae76eb1bce80429c4b97e548a", "filename": "src/librustc_lint/error_codes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b5bd31ec6db6a249311888a93fc176f06dcb6aa6/src%2Flibrustc_lint%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5bd31ec6db6a249311888a93fc176f06dcb6aa6/src%2Flibrustc_lint%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ferror_codes.rs?ref=b5bd31ec6db6a249311888a93fc176f06dcb6aa6", "patch": "@@ -1,4 +1,4 @@\n syntax::register_diagnostics! {\n ;\n-    E0721, // `await` keyword\n+//  E0721, // `await` keyword\n }"}, {"sha": "77853ff1fe80aa2681de8a1df8056101400e1f20", "filename": "src/librustc_mir/error_codes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b5bd31ec6db6a249311888a93fc176f06dcb6aa6/src%2Flibrustc_mir%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5bd31ec6db6a249311888a93fc176f06dcb6aa6/src%2Flibrustc_mir%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ferror_codes.rs?ref=b5bd31ec6db6a249311888a93fc176f06dcb6aa6", "patch": "@@ -953,7 +953,7 @@ https://doc.rust-lang.org/std/cell/\n \"##,\n \n E0388: r##\"\n-E0388 was removed and is no longer issued.\n+#### Note: this error code is no longer emitted by the compiler.\n \"##,\n \n E0389: r##\""}, {"sha": "e460e9813b3ee01c547eb5d093f12acdc23ebe86", "filename": "src/librustc_passes/error_codes.rs", "status": "modified", "additions": 21, "deletions": 4, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/b5bd31ec6db6a249311888a93fc176f06dcb6aa6/src%2Flibrustc_passes%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5bd31ec6db6a249311888a93fc176f06dcb6aa6/src%2Flibrustc_passes%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Ferror_codes.rs?ref=b5bd31ec6db6a249311888a93fc176f06dcb6aa6", "patch": "@@ -1,12 +1,15 @@\n syntax::register_diagnostics! {\n-/*\n E0014: r##\"\n+#### Note: this error code is no longer emitted by the compiler.\n+\n Constants can only be initialized by a constant value or, in a future\n version of Rust, a call to a const function. This error indicates the use\n of a path (like a::b, or x) denoting something other than one of these\n-allowed items. Erroneous code xample:\n+allowed items.\n \n-```compile_fail\n+Erroneous code example:\n+\n+```\n const FOO: i32 = { let x = 0; x }; // 'x' isn't a constant nor a function!\n ```\n \n@@ -18,10 +21,10 @@ const FOO: i32 = { const X : i32 = 0; X };\n const FOO2: i32 = { 0 }; // but brackets are useless here\n ```\n \"##,\n-*/\n \n E0130: r##\"\n You declared a pattern as an argument in a foreign function declaration.\n+\n Erroneous code example:\n \n ```compile_fail\n@@ -57,6 +60,20 @@ extern {\n E0136: r##\"\n A binary can only have one entry point, and by default that entry point is the\n function `main()`. If there are multiple such functions, please rename one.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0136\n+fn main() {\n+    // ...\n+}\n+\n+// ...\n+\n+fn main() { // error!\n+    // ...\n+}\n+```\n \"##,\n \n E0137: r##\""}, {"sha": "03afb547d3a226a54faa166b91bf8673bb20b2ad", "filename": "src/librustc_privacy/error_codes.rs", "status": "modified", "additions": 17, "deletions": 6, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/b5bd31ec6db6a249311888a93fc176f06dcb6aa6/src%2Flibrustc_privacy%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5bd31ec6db6a249311888a93fc176f06dcb6aa6/src%2Flibrustc_privacy%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Ferror_codes.rs?ref=b5bd31ec6db6a249311888a93fc176f06dcb6aa6", "patch": "@@ -1,8 +1,9 @@\n syntax::register_diagnostics! {\n \n E0445: r##\"\n-A private trait was used on a public type parameter bound. Erroneous code\n-examples:\n+A private trait was used on a public type parameter bound.\n+\n+Erroneous code examples:\n \n ```compile_fail,E0445\n #![deny(private_in_public)]\n@@ -32,7 +33,9 @@ pub fn foo<T: Foo> (t: T) {} // ok!\n \"##,\n \n E0446: r##\"\n-A private type was used in a public type signature. Erroneous code example:\n+A private type was used in a public type signature.\n+\n+Erroneous code example:\n \n ```compile_fail,E0446\n #![deny(private_in_public)]\n@@ -65,7 +68,9 @@ mod Foo {\n E0447: r##\"\n #### Note: this error code is no longer emitted by the compiler.\n \n-The `pub` keyword was used inside a function. Erroneous code example:\n+The `pub` keyword was used inside a function.\n+\n+Erroneous code example:\n \n ```\n fn foo() {\n@@ -79,7 +84,11 @@ is invalid.\n \"##,\n \n E0448: r##\"\n-The `pub` keyword was used inside a public enum. Erroneous code example:\n+#### Note: this error code is no longer emitted by the compiler.\n+\n+The `pub` keyword was used inside a public enum.\n+\n+Erroneous code example:\n \n ```compile_fail\n pub enum Foo {\n@@ -106,7 +115,9 @@ pub enum Foo {\n \"##,\n \n E0451: r##\"\n-A struct constructor with private fields was invoked. Erroneous code example:\n+A struct constructor with private fields was invoked.\n+\n+Erroneous code example:\n \n ```compile_fail,E0451\n mod Bar {"}, {"sha": "d713315decbe95bb3d689ce0249ed6e049a0c039", "filename": "src/librustc_resolve/diagnostics.rs", "status": "modified", "additions": 20, "deletions": 18, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/b5bd31ec6db6a249311888a93fc176f06dcb6aa6/src%2Flibrustc_resolve%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5bd31ec6db6a249311888a93fc176f06dcb6aa6/src%2Flibrustc_resolve%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fdiagnostics.rs?ref=b5bd31ec6db6a249311888a93fc176f06dcb6aa6", "patch": "@@ -20,7 +20,7 @@ use syntax_pos::{BytePos, Span, MultiSpan};\n \n use crate::resolve_imports::{ImportDirective, ImportDirectiveSubclass, ImportResolver};\n use crate::{path_names_to_string, KNOWN_TOOLS};\n-use crate::{BindingError, CrateLint, LegacyScope, Module, ModuleOrUniformRoot};\n+use crate::{BindingError, CrateLint, HasGenericParams, LegacyScope, Module, ModuleOrUniformRoot};\n use crate::{PathResult, ParentScope, ResolutionError, Resolver, Scope, ScopeSet, Segment};\n \n type Res = def::Res<ast::NodeId>;\n@@ -102,7 +102,7 @@ impl<'a> Resolver<'a> {\n         &self, span: Span, resolution_error: ResolutionError<'_>\n     ) -> DiagnosticBuilder<'_> {\n         match resolution_error {\n-            ResolutionError::GenericParamsFromOuterFunction(outer_res) => {\n+            ResolutionError::GenericParamsFromOuterFunction(outer_res, has_generic_params) => {\n                 let mut err = struct_span_err!(self.session,\n                     span,\n                     E0401,\n@@ -148,22 +148,24 @@ impl<'a> Resolver<'a> {\n                     }\n                 }\n \n-                // Try to retrieve the span of the function signature and generate a new message\n-                // with a local type or const parameter.\n-                let sugg_msg = &format!(\"try using a local generic parameter instead\");\n-                if let Some((sugg_span, new_snippet)) = cm.generate_local_type_param_snippet(span) {\n-                    // Suggest the modification to the user\n-                    err.span_suggestion(\n-                        sugg_span,\n-                        sugg_msg,\n-                        new_snippet,\n-                        Applicability::MachineApplicable,\n-                    );\n-                } else if let Some(sp) = cm.generate_fn_name_span(span) {\n-                    err.span_label(sp,\n-                        format!(\"try adding a local generic parameter in this method instead\"));\n-                } else {\n-                    err.help(&format!(\"try using a local generic parameter instead\"));\n+                if has_generic_params == HasGenericParams::Yes {\n+                    // Try to retrieve the span of the function signature and generate a new\n+                    // message with a local type or const parameter.\n+                    let sugg_msg = &format!(\"try using a local generic parameter instead\");\n+                    if let Some((sugg_span, snippet)) = cm.generate_local_type_param_snippet(span) {\n+                        // Suggest the modification to the user\n+                        err.span_suggestion(\n+                            sugg_span,\n+                            sugg_msg,\n+                            snippet,\n+                            Applicability::MachineApplicable,\n+                        );\n+                    } else if let Some(sp) = cm.generate_fn_name_span(span) {\n+                        err.span_label(sp,\n+                            format!(\"try adding a local generic parameter in this method instead\"));\n+                    } else {\n+                        err.help(&format!(\"try using a local generic parameter instead\"));\n+                    }\n                 }\n \n                 err"}, {"sha": "bb9f895c5f39b67aa0d89c2ab990da75c05b8fd6", "filename": "src/librustc_resolve/late.rs", "status": "modified", "additions": 116, "deletions": 139, "changes": 255, "blob_url": "https://github.com/rust-lang/rust/blob/b5bd31ec6db6a249311888a93fc176f06dcb6aa6/src%2Flibrustc_resolve%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5bd31ec6db6a249311888a93fc176f06dcb6aa6/src%2Flibrustc_resolve%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flate.rs?ref=b5bd31ec6db6a249311888a93fc176f06dcb6aa6", "patch": "@@ -5,7 +5,6 @@\n //! If you wonder why there's no `early.rs`, that's because it's split into three files -\n //! `build_reduced_graph.rs`, `macros.rs` and `resolve_imports.rs`.\n \n-use GenericParameters::*;\n use RibKind::*;\n \n use crate::{path_names_to_string, BindingError, CrateLint, LexicalScopeBinding};\n@@ -46,16 +45,6 @@ struct BindingInfo {\n     binding_mode: BindingMode,\n }\n \n-#[derive(Copy, Clone)]\n-enum GenericParameters<'a, 'b> {\n-    NoGenericParams,\n-    HasGenericParams(// Type parameters.\n-                      &'b Generics,\n-\n-                      // The kind of the rib used for type parameters.\n-                      RibKind<'a>),\n-}\n-\n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n enum PatternSource {\n     Match,\n@@ -85,6 +74,10 @@ enum PatBoundCtx {\n     Or,\n }\n \n+/// Does this the item (from the item rib scope) allow generic parameters?\n+#[derive(Copy, Clone, Debug, Eq, PartialEq)]\n+crate enum HasGenericParams { Yes, No }\n+\n /// The rib kind restricts certain accesses,\n /// e.g. to a `Res::Local` of an outer item.\n #[derive(Copy, Clone, Debug)]\n@@ -103,7 +96,7 @@ crate enum RibKind<'a> {\n     FnItemRibKind,\n \n     /// We passed through an item scope. Disallow upvars.\n-    ItemRibKind,\n+    ItemRibKind(HasGenericParams),\n \n     /// We're in a constant item. Can't refer to dynamic stuff.\n     ConstantItemRibKind,\n@@ -134,7 +127,7 @@ impl RibKind<'_> {\n             | ModuleRibKind(_)\n             | MacroDefinition(_) => false,\n             AssocItemRibKind\n-            | ItemRibKind\n+            | ItemRibKind(_)\n             | ForwardTyParamBanRibKind\n             | TyParamAsConstParamTy => true,\n         }\n@@ -406,17 +399,21 @@ impl<'a, 'tcx> Visitor<'tcx> for LateResolutionVisitor<'a, '_> {\n         visit::walk_poly_trait_ref(self, tref, m);\n     }\n     fn visit_foreign_item(&mut self, foreign_item: &'tcx ForeignItem) {\n-        let generic_params = match foreign_item.kind {\n+        match foreign_item.kind {\n             ForeignItemKind::Fn(_, ref generics) => {\n-                HasGenericParams(generics, ItemRibKind)\n+                self.with_generic_param_rib(generics, ItemRibKind(HasGenericParams::Yes), |this| {\n+                    visit::walk_foreign_item(this, foreign_item);\n+                });\n             }\n-            ForeignItemKind::Static(..) => NoGenericParams,\n-            ForeignItemKind::Ty => NoGenericParams,\n-            ForeignItemKind::Macro(..) => NoGenericParams,\n-        };\n-        self.with_generic_param_rib(generic_params, |this| {\n-            visit::walk_foreign_item(this, foreign_item);\n-        });\n+            ForeignItemKind::Static(..) => {\n+                self.with_item_rib(HasGenericParams::No, |this| {\n+                    visit::walk_foreign_item(this, foreign_item);\n+                });\n+            }\n+            ForeignItemKind::Ty | ForeignItemKind::Macro(..) => {\n+                visit::walk_foreign_item(self, foreign_item);\n+            }\n+        }\n     }\n     fn visit_fn(&mut self, fn_kind: FnKind<'tcx>, declaration: &'tcx FnDecl, _: Span, _: NodeId) {\n         debug!(\"(resolving function) entering function\");\n@@ -660,7 +657,7 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n     fn resolve_adt(&mut self, item: &Item, generics: &Generics) {\n         debug!(\"resolve_adt\");\n         self.with_current_self_item(item, |this| {\n-            this.with_generic_param_rib(HasGenericParams(generics, ItemRibKind), |this| {\n+            this.with_generic_param_rib(generics, ItemRibKind(HasGenericParams::Yes), |this| {\n                 let item_def_id = this.r.definitions.local_def_id(item.id);\n                 this.with_self_rib(Res::SelfTy(None, Some(item_def_id)), |this| {\n                     visit::walk_item(this, item);\n@@ -719,10 +716,8 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n             ItemKind::TyAlias(_, ref generics) |\n             ItemKind::OpaqueTy(_, ref generics) |\n             ItemKind::Fn(_, _, ref generics, _) => {\n-                self.with_generic_param_rib(\n-                    HasGenericParams(generics, ItemRibKind),\n-                    |this| visit::walk_item(this, item)\n-                );\n+                self.with_generic_param_rib(generics, ItemRibKind(HasGenericParams::Yes),\n+                                            |this| visit::walk_item(this, item));\n             }\n \n             ItemKind::Enum(_, ref generics) |\n@@ -740,43 +735,40 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n \n             ItemKind::Trait(.., ref generics, ref bounds, ref trait_items) => {\n                 // Create a new rib for the trait-wide type parameters.\n-                self.with_generic_param_rib(HasGenericParams(generics, ItemRibKind), |this| {\n+                self.with_generic_param_rib(generics, ItemRibKind(HasGenericParams::Yes), |this| {\n                     let local_def_id = this.r.definitions.local_def_id(item.id);\n                     this.with_self_rib(Res::SelfTy(Some(local_def_id), None), |this| {\n                         this.visit_generics(generics);\n                         walk_list!(this, visit_param_bound, bounds);\n \n                         for trait_item in trait_items {\n                             this.with_trait_items(trait_items, |this| {\n-                                let generic_params = HasGenericParams(\n-                                    &trait_item.generics,\n-                                    AssocItemRibKind,\n-                                );\n-                                this.with_generic_param_rib(generic_params, |this| {\n-                                    match trait_item.kind {\n-                                        TraitItemKind::Const(ref ty, ref default) => {\n-                                            this.visit_ty(ty);\n-\n-                                            // Only impose the restrictions of\n-                                            // ConstRibKind for an actual constant\n-                                            // expression in a provided default.\n-                                            if let Some(ref expr) = *default{\n-                                                this.with_constant_rib(|this| {\n-                                                    this.visit_expr(expr);\n-                                                });\n+                                this.with_generic_param_rib(&trait_item.generics, AssocItemRibKind,\n+                                    |this| {\n+                                        match trait_item.kind {\n+                                            TraitItemKind::Const(ref ty, ref default) => {\n+                                                this.visit_ty(ty);\n+\n+                                                // Only impose the restrictions of\n+                                                // ConstRibKind for an actual constant\n+                                                // expression in a provided default.\n+                                                if let Some(ref expr) = *default{\n+                                                    this.with_constant_rib(|this| {\n+                                                        this.visit_expr(expr);\n+                                                    });\n+                                                }\n                                             }\n-                                        }\n-                                        TraitItemKind::Method(_, _) => {\n-                                            visit::walk_trait_item(this, trait_item)\n-                                        }\n-                                        TraitItemKind::Type(..) => {\n-                                            visit::walk_trait_item(this, trait_item)\n-                                        }\n-                                        TraitItemKind::Macro(_) => {\n-                                            panic!(\"unexpanded macro in resolve!\")\n-                                        }\n-                                    };\n-                                });\n+                                            TraitItemKind::Method(_, _) => {\n+                                                visit::walk_trait_item(this, trait_item)\n+                                            }\n+                                            TraitItemKind::Type(..) => {\n+                                                visit::walk_trait_item(this, trait_item)\n+                                            }\n+                                            TraitItemKind::Macro(_) => {\n+                                                panic!(\"unexpanded macro in resolve!\")\n+                                            }\n+                                        };\n+                                    });\n                             });\n                         }\n                     });\n@@ -785,7 +777,7 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n \n             ItemKind::TraitAlias(ref generics, ref bounds) => {\n                 // Create a new rib for the trait-wide type parameters.\n-                self.with_generic_param_rib(HasGenericParams(generics, ItemRibKind), |this| {\n+                self.with_generic_param_rib(generics, ItemRibKind(HasGenericParams::Yes), |this| {\n                     let local_def_id = this.r.definitions.local_def_id(item.id);\n                     this.with_self_rib(Res::SelfTy(Some(local_def_id), None), |this| {\n                         this.visit_generics(generics);\n@@ -803,7 +795,7 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n             ItemKind::Static(ref ty, _, ref expr) |\n             ItemKind::Const(ref ty, ref expr) => {\n                 debug!(\"resolve_item ItemKind::Const\");\n-                self.with_item_rib(|this| {\n+                self.with_item_rib(HasGenericParams::No, |this| {\n                     this.visit_ty(ty);\n                     this.with_constant_rib(|this| {\n                         this.visit_expr(expr);\n@@ -824,91 +816,75 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n         }\n     }\n \n-    fn with_generic_param_rib<'c, F>(&'c mut self, generic_params: GenericParameters<'a, 'c>, f: F)\n+    fn with_generic_param_rib<'c, F>(&'c mut self, generics: &'c Generics, kind: RibKind<'a>, f: F)\n         where F: FnOnce(&mut Self)\n     {\n         debug!(\"with_generic_param_rib\");\n-        match generic_params {\n-            HasGenericParams(generics, rib_kind) => {\n-                let mut function_type_rib = Rib::new(rib_kind);\n-                let mut function_value_rib = Rib::new(rib_kind);\n-                let mut seen_bindings = FxHashMap::default();\n-                // We also can't shadow bindings from the parent item\n-                if let AssocItemRibKind = rib_kind {\n-                    let mut add_bindings_for_ns = |ns| {\n-                        let parent_rib = self.ribs[ns].iter()\n-                            .rfind(|rib| if let ItemRibKind = rib.kind { true } else { false })\n-                            .expect(\"associated item outside of an item\");\n-                        seen_bindings.extend(\n-                            parent_rib.bindings.iter().map(|(ident, _)| (*ident, ident.span)),\n-                        );\n-                    };\n-                    add_bindings_for_ns(ValueNS);\n-                    add_bindings_for_ns(TypeNS);\n-                }\n-                for param in &generics.params {\n-                    match param.kind {\n-                        GenericParamKind::Lifetime { .. } => {}\n-                        GenericParamKind::Type { .. } => {\n-                            let ident = param.ident.modern();\n-                            debug!(\"with_generic_param_rib: {}\", param.id);\n-\n-                            if seen_bindings.contains_key(&ident) {\n-                                let span = seen_bindings.get(&ident).unwrap();\n-                                let err = ResolutionError::NameAlreadyUsedInParameterList(\n-                                    ident.name,\n-                                    *span,\n-                                );\n-                                self.r.report_error(param.ident.span, err);\n-                            }\n-                            seen_bindings.entry(ident).or_insert(param.ident.span);\n-\n-                            // Plain insert (no renaming).\n-                            let res = Res::Def(\n-                                DefKind::TyParam,\n-                                self.r.definitions.local_def_id(param.id),\n-                            );\n-                            function_type_rib.bindings.insert(ident, res);\n-                            self.r.record_partial_res(param.id, PartialRes::new(res));\n-                        }\n-                        GenericParamKind::Const { .. } => {\n-                            let ident = param.ident.modern();\n-                            debug!(\"with_generic_param_rib: {}\", param.id);\n-\n-                            if seen_bindings.contains_key(&ident) {\n-                                let span = seen_bindings.get(&ident).unwrap();\n-                                let err = ResolutionError::NameAlreadyUsedInParameterList(\n-                                    ident.name,\n-                                    *span,\n-                                );\n-                                self.r.report_error(param.ident.span, err);\n-                            }\n-                            seen_bindings.entry(ident).or_insert(param.ident.span);\n-\n-                            let res = Res::Def(\n-                                DefKind::ConstParam,\n-                                self.r.definitions.local_def_id(param.id),\n-                            );\n-                            function_value_rib.bindings.insert(ident, res);\n-                            self.r.record_partial_res(param.id, PartialRes::new(res));\n-                        }\n-                    }\n-                }\n-                self.ribs[ValueNS].push(function_value_rib);\n-                self.ribs[TypeNS].push(function_type_rib);\n+        let mut function_type_rib = Rib::new(kind);\n+        let mut function_value_rib = Rib::new(kind);\n+        let mut seen_bindings = FxHashMap::default();\n+\n+        // We also can't shadow bindings from the parent item\n+        if let AssocItemRibKind = kind {\n+            let mut add_bindings_for_ns = |ns| {\n+                let parent_rib = self.ribs[ns].iter()\n+                    .rfind(|r| if let ItemRibKind(_) = r.kind { true } else { false })\n+                    .expect(\"associated item outside of an item\");\n+                seen_bindings.extend(\n+                    parent_rib.bindings.iter().map(|(ident, _)| (*ident, ident.span)),\n+                );\n+            };\n+            add_bindings_for_ns(ValueNS);\n+            add_bindings_for_ns(TypeNS);\n+        }\n+\n+        for param in &generics.params {\n+            if let GenericParamKind::Lifetime { .. } = param.kind {\n+                continue;\n             }\n \n-            NoGenericParams => {\n-                // Nothing to do.\n+            let def_kind = match param.kind {\n+                GenericParamKind::Type { .. } => DefKind::TyParam,\n+                GenericParamKind::Const { .. } => DefKind::ConstParam,\n+                _ => unreachable!(),\n+            };\n+\n+            let ident = param.ident.modern();\n+            debug!(\"with_generic_param_rib: {}\", param.id);\n+\n+            if seen_bindings.contains_key(&ident) {\n+                let span = seen_bindings.get(&ident).unwrap();\n+                let err = ResolutionError::NameAlreadyUsedInParameterList(\n+                    ident.name,\n+                    *span,\n+                );\n+                self.r.report_error(param.ident.span, err);\n+            }\n+            seen_bindings.entry(ident).or_insert(param.ident.span);\n+\n+            // Plain insert (no renaming).\n+            let res = Res::Def(def_kind, self.r.definitions.local_def_id(param.id));\n+\n+            match param.kind {\n+                GenericParamKind::Type { .. } => {\n+                    function_type_rib.bindings.insert(ident, res);\n+                    self.r.record_partial_res(param.id, PartialRes::new(res));\n+                }\n+                GenericParamKind::Const { .. } => {\n+                    function_value_rib.bindings.insert(ident, res);\n+                    self.r.record_partial_res(param.id, PartialRes::new(res));\n+                }\n+                _ => unreachable!(),\n             }\n         }\n \n+        self.ribs[ValueNS].push(function_value_rib);\n+        self.ribs[TypeNS].push(function_type_rib);\n+\n         f(self);\n \n-        if let HasGenericParams(..) = generic_params {\n-            self.ribs[TypeNS].pop();\n-            self.ribs[ValueNS].pop();\n-        }\n+        self.ribs[TypeNS].pop();\n+        self.ribs[ValueNS].pop();\n     }\n \n     fn with_label_rib(&mut self, kind: RibKind<'a>, f: impl FnOnce(&mut Self)) {\n@@ -917,8 +893,9 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n         self.label_ribs.pop();\n     }\n \n-    fn with_item_rib(&mut self, f: impl FnOnce(&mut Self)) {\n-        self.with_rib(ValueNS, ItemRibKind, |this| this.with_rib(TypeNS, ItemRibKind, f))\n+    fn with_item_rib(&mut self, has_generic_params: HasGenericParams, f: impl FnOnce(&mut Self)) {\n+        let kind = ItemRibKind(has_generic_params);\n+        self.with_rib(ValueNS, kind, |this| this.with_rib(TypeNS, kind, f))\n     }\n \n     fn with_constant_rib(&mut self, f: impl FnOnce(&mut Self)) {\n@@ -1023,7 +1000,7 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n                               impl_items: &[ImplItem]) {\n         debug!(\"resolve_implementation\");\n         // If applicable, create a rib for the type parameters.\n-        self.with_generic_param_rib(HasGenericParams(generics, ItemRibKind), |this| {\n+        self.with_generic_param_rib(generics, ItemRibKind(HasGenericParams::Yes), |this| {\n             // Dummy self type for better errors if `Self` is used in the trait path.\n             this.with_self_rib(Res::SelfTy(None, None), |this| {\n                 // Resolve the trait reference, if necessary.\n@@ -1044,9 +1021,9 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n                                 debug!(\"resolve_implementation with_self_rib_ns(ValueNS, ...)\");\n                                 for impl_item in impl_items {\n                                     // We also need a new scope for the impl item type parameters.\n-                                    let generic_params = HasGenericParams(&impl_item.generics,\n-                                                                          AssocItemRibKind);\n-                                    this.with_generic_param_rib(generic_params, |this| {\n+                                    this.with_generic_param_rib(&impl_item.generics,\n+                                                                AssocItemRibKind,\n+                                                                |this| {\n                                         use crate::ResolutionError::*;\n                                         match impl_item.kind {\n                                             ImplItemKind::Const(..) => {"}, {"sha": "9c4281bbb62c584944793fffdbece5ab166b89f1", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 25, "deletions": 21, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/b5bd31ec6db6a249311888a93fc176f06dcb6aa6/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5bd31ec6db6a249311888a93fc176f06dcb6aa6/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=b5bd31ec6db6a249311888a93fc176f06dcb6aa6", "patch": "@@ -61,7 +61,7 @@ use rustc_data_structures::fx::FxIndexMap;\n \n use diagnostics::{Suggestion, ImportSuggestion};\n use diagnostics::{find_span_of_binding_until_next_binding, extend_span_to_previous_binding};\n-use late::{PathSource, Rib, RibKind::*};\n+use late::{HasGenericParams, PathSource, Rib, RibKind::*};\n use resolve_imports::{ImportDirective, ImportDirectiveSubclass, NameResolution, ImportResolver};\n use macros::{LegacyBinding, LegacyScope};\n \n@@ -178,7 +178,7 @@ impl Ord for BindingError {\n \n enum ResolutionError<'a> {\n     /// Error E0401: can't use type or const parameters from outer function.\n-    GenericParamsFromOuterFunction(Res),\n+    GenericParamsFromOuterFunction(Res, HasGenericParams),\n     /// Error E0403: the name is already used for a type or const parameter in this generic\n     /// parameter list.\n     NameAlreadyUsedInParameterList(Name, Span),\n@@ -2156,7 +2156,7 @@ impl<'a> Resolver<'a> {\n                         ForwardTyParamBanRibKind | TyParamAsConstParamTy => {\n                             // Nothing to do. Continue.\n                         }\n-                        ItemRibKind | FnItemRibKind | AssocItemRibKind => {\n+                        ItemRibKind(_) | FnItemRibKind | AssocItemRibKind => {\n                             // This was an attempt to access an upvar inside a\n                             // named function item. This is not allowed, so we\n                             // report an error.\n@@ -2184,22 +2184,23 @@ impl<'a> Resolver<'a> {\n             }\n             Res::Def(DefKind::TyParam, _) | Res::SelfTy(..) => {\n                 for rib in ribs {\n-                    match rib.kind {\n+                    let has_generic_params = match rib.kind {\n                         NormalRibKind | AssocItemRibKind |\n                         ModuleRibKind(..) | MacroDefinition(..) | ForwardTyParamBanRibKind |\n                         ConstantItemRibKind | TyParamAsConstParamTy => {\n                             // Nothing to do. Continue.\n+                            continue;\n                         }\n-                        ItemRibKind | FnItemRibKind => {\n-                            // This was an attempt to use a type parameter outside its scope.\n-                            if record_used {\n-                                self.report_error(\n-                                    span, ResolutionError::GenericParamsFromOuterFunction(res)\n-                                );\n-                            }\n-                            return Res::Err;\n-                        }\n+                        // This was an attempt to use a type parameter outside its scope.\n+                        ItemRibKind(has_generic_params) => has_generic_params,\n+                        FnItemRibKind => HasGenericParams::Yes,\n+                    };\n+\n+                    if record_used {\n+                        self.report_error(span, ResolutionError::GenericParamsFromOuterFunction(\n+                            res, has_generic_params));\n                     }\n+                    return Res::Err;\n                 }\n             }\n             Res::Def(DefKind::ConstParam, _) => {\n@@ -2211,15 +2212,18 @@ impl<'a> Resolver<'a> {\n                     ribs.next();\n                 }\n                 for rib in ribs {\n-                    if let ItemRibKind | FnItemRibKind = rib.kind {\n-                        // This was an attempt to use a const parameter outside its scope.\n-                        if record_used {\n-                            self.report_error(\n-                                span, ResolutionError::GenericParamsFromOuterFunction(res)\n-                            );\n-                        }\n-                        return Res::Err;\n+                    let has_generic_params = match rib.kind {\n+                        ItemRibKind(has_generic_params) => has_generic_params,\n+                        FnItemRibKind => HasGenericParams::Yes,\n+                        _ => continue,\n+                    };\n+\n+                    // This was an attempt to use a const parameter outside its scope.\n+                    if record_used {\n+                        self.report_error(span, ResolutionError::GenericParamsFromOuterFunction(\n+                            res, has_generic_params));\n                     }\n+                    return Res::Err;\n                 }\n             }\n             _ => {}"}, {"sha": "d92ea7fd49a7294fa5d87175bf524ac020399c5b", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b5bd31ec6db6a249311888a93fc176f06dcb6aa6/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5bd31ec6db6a249311888a93fc176f06dcb6aa6/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=b5bd31ec6db6a249311888a93fc176f06dcb6aa6", "patch": "@@ -115,6 +115,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             Err(e) => e\n         };\n \n+        let expr = expr.peel_drop_temps();\n         let cause = self.misc(expr.span);\n         let expr_ty = self.resolve_type_vars_with_obligations(checked_ty);\n         let mut err = self.report_mismatched_types(&cause, expected, expr_ty, e);\n@@ -355,6 +356,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         };\n         let is_macro = sp.from_expansion() && !is_desugaring;\n \n+        // `ExprKind::DropTemps` is semantically irrelevant for these suggestions.\n+        let expr = expr.peel_drop_temps();\n+\n         match (&expr.kind, &expected.kind, &checked_ty.kind) {\n             (_, &ty::Ref(_, exp, _), &ty::Ref(_, check, _)) => match (&exp.kind, &check.kind) {\n                 (&ty::Str, &ty::Array(arr, _)) |"}, {"sha": "ad46a443b8ffa9e886969f8409266a13d30b4d7a", "filename": "src/librustc_typeck/check/expr.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b5bd31ec6db6a249311888a93fc176f06dcb6aa6/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5bd31ec6db6a249311888a93fc176f06dcb6aa6/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs?ref=b5bd31ec6db6a249311888a93fc176f06dcb6aa6", "patch": "@@ -87,12 +87,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n \n         if let Some(mut err) = self.demand_suptype_diag(expr.span, expected_ty, ty) {\n+            let expr = expr.peel_drop_temps();\n             self.suggest_ref_or_into(&mut err, expr, expected_ty, ty);\n-\n-            let expr = match &expr.kind {\n-                ExprKind::DropTemps(expr) => expr,\n-                _ => expr,\n-            };\n             extend_err(&mut err);\n             // Error possibly reported in `check_assign` so avoid emitting error again.\n             err.emit_unless(self.is_assign_to_bool(expr, expected_ty));"}, {"sha": "70cb799cc6e7c8d390dea932b7b708920c7ee45f", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 19, "deletions": 6, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/b5bd31ec6db6a249311888a93fc176f06dcb6aa6/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5bd31ec6db6a249311888a93fc176f06dcb6aa6/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=b5bd31ec6db6a249311888a93fc176f06dcb6aa6", "patch": "@@ -538,13 +538,26 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     }\n                 }\n \n+                let mut fallback_span = true;\n+                let msg = \"remove this method call\";\n                 if item_name.as_str() == \"as_str\" && actual.peel_refs().is_str() {\n-                    // FIXME: the span is not quite correct, it should point to \".as_str()\" instead\n-                    // of just \"as_str\".\n-                    err.span_label(\n-                        span,\n-                        \"try removing `as_str`\"\n-                    );\n+                    if let SelfSource::MethodCall(expr) = source {\n+                        let call_expr = self.tcx.hir().expect_expr(\n+                            self.tcx.hir().get_parent_node(expr.hir_id),\n+                        );\n+                        if let Some(span) = call_expr.span.trim_start(expr.span) {\n+                            err.span_suggestion(\n+                                span,\n+                                msg,\n+                                String::new(),\n+                                Applicability::MachineApplicable,\n+                            );\n+                            fallback_span = false;\n+                        }\n+                    }\n+                    if fallback_span {\n+                        err.span_label(span, msg);\n+                    }\n                 } else if let Some(lev_candidate) = lev_candidate {\n                     let def_kind = lev_candidate.def_kind();\n                     err.span_suggestion("}, {"sha": "7475b9cc3b327b9b4940f2edc0b9587756aa12e9", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b5bd31ec6db6a249311888a93fc176f06dcb6aa6/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5bd31ec6db6a249311888a93fc176f06dcb6aa6/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=b5bd31ec6db6a249311888a93fc176f06dcb6aa6", "patch": "@@ -4216,20 +4216,21 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub fn suggest_mismatched_types_on_tail(\n         &self,\n         err: &mut DiagnosticBuilder<'tcx>,\n-        expression: &'tcx hir::Expr,\n+        expr: &'tcx hir::Expr,\n         expected: Ty<'tcx>,\n         found: Ty<'tcx>,\n         cause_span: Span,\n         blk_id: hir::HirId,\n     ) -> bool {\n-        self.suggest_missing_semicolon(err, expression, expected, cause_span);\n+        let expr = expr.peel_drop_temps();\n+        self.suggest_missing_semicolon(err, expr, expected, cause_span);\n         let mut pointing_at_return_type = false;\n         if let Some((fn_decl, can_suggest)) = self.get_fn_decl(blk_id) {\n             pointing_at_return_type = self.suggest_missing_return_type(\n                 err, &fn_decl, expected, found, can_suggest);\n         }\n-        self.suggest_ref_or_into(err, expression, expected, found);\n-        self.suggest_boxing_when_appropriate(err, expression, expected, found);\n+        self.suggest_ref_or_into(err, expr, expected, found);\n+        self.suggest_boxing_when_appropriate(err, expr, expected, found);\n         pointing_at_return_type\n     }\n "}, {"sha": "8bd899ae4d5cef0ca85b69bb8b40e8e690a47028", "filename": "src/librustc_typeck/error_codes.rs", "status": "modified", "additions": 15, "deletions": 17, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/b5bd31ec6db6a249311888a93fc176f06dcb6aa6/src%2Flibrustc_typeck%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5bd31ec6db6a249311888a93fc176f06dcb6aa6/src%2Flibrustc_typeck%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Ferror_codes.rs?ref=b5bd31ec6db6a249311888a93fc176f06dcb6aa6", "patch": "@@ -1873,13 +1873,14 @@ This fails because `&mut T` is not `Copy`, even when `T` is `Copy` (this\n differs from the behavior for `&T`, which is always `Copy`).\n \"##,\n \n-/*\n E0205: r##\"\n+#### Note: this error code is no longer emitted by the compiler.\n+\n An attempt to implement the `Copy` trait for an enum failed because one of the\n variants does not implement `Copy`. To fix this, you must implement `Copy` for\n the mentioned variant. Note that this may not be possible, as in the example of\n \n-```compile_fail,E0205\n+```compile_fail,E0204\n enum Foo {\n     Bar(Vec<u32>),\n     Baz,\n@@ -1892,7 +1893,7 @@ This fails because `Vec<T>` does not implement `Copy` for any `T`.\n \n Here's another example that will fail:\n \n-```compile_fail,E0205\n+```compile_fail,E0204\n #[derive(Copy)]\n enum Foo<'a> {\n     Bar(&'a mut bool),\n@@ -1903,7 +1904,6 @@ enum Foo<'a> {\n This fails because `&mut T` is not `Copy`, even when `T` is `Copy` (this\n differs from the behavior for `&T`, which is always `Copy`).\n \"##,\n-*/\n \n E0206: r##\"\n You can only implement `Copy` for a struct or enum. Both of the following\n@@ -2126,8 +2126,9 @@ For information on the design of the orphan rules, see [RFC 1023].\n [RFC 1023]: https://github.com/rust-lang/rfcs/blob/master/text/1023-rebalancing-coherence.md\n \"##,\n \n-/*\n E0211: r##\"\n+#### Note: this error code is no longer emitted by the compiler.\n+\n You used a function or type which doesn't fit the requirements for where it was\n used. Erroneous code examples:\n \n@@ -2174,7 +2175,7 @@ extern \"rust-intrinsic\" {\n }\n ```\n \n-The second case example is a bit particular : the main function must always\n+The second case example is a bit particular: the main function must always\n have this definition:\n \n ```compile_fail\n@@ -2206,7 +2207,6 @@ impl Foo {\n }\n ```\n \"##,\n-     */\n \n E0220: r##\"\n You used an associated type which isn't defined in the trait.\n@@ -2727,14 +2727,9 @@ impl<T, U> CoerceUnsized<MyType<U>> for MyType<T>\n [`CoerceUnsized`]: https://doc.rust-lang.org/std/ops/trait.CoerceUnsized.html\n \"##,\n \n-/*\n-// Associated consts can now be accessed through generic type parameters, and\n-// this error is no longer emitted.\n-//\n-// FIXME: consider whether to leave it in the error index, or remove it entirely\n-//        as associated consts is not stabilized yet.\n-\n E0329: r##\"\n+#### Note: this error code is no longer emitted by the compiler.\n+\n An attempt was made to access an associated constant through either a generic\n type parameter or `Self`. This is not supported yet. An example causing this\n error is shown below:\n@@ -2765,12 +2760,15 @@ trait Foo {\n \n struct MyStruct;\n \n+impl Foo for MyStruct {\n+    const BAR: f64 = 0f64;\n+}\n+\n fn get_bar_good() -> f64 {\n     <MyStruct as Foo>::BAR\n }\n ```\n \"##,\n-*/\n \n E0366: r##\"\n An attempt was made to implement `Drop` on a concrete specialization of a\n@@ -4973,7 +4971,7 @@ and the pin is required to keep it in the same place in memory.\n            // between structures with the same definition\n //  E0558, // replaced with a generic attribute input check\n //  E0563, // cannot determine a type for this `impl Trait` removed in 6383de15\n-    E0564, // only named lifetimes are allowed in `impl Trait`,\n+//  E0564, // only named lifetimes are allowed in `impl Trait`,\n            // but `{}` was found in the type `{}`\n     E0587, // type has conflicting packed and align representation hints\n     E0588, // packed type cannot transitively contain a `[repr(align)]` type\n@@ -4986,7 +4984,7 @@ and the pin is required to keep it in the same place in memory.\n     E0634, // type has conflicting packed representaton hints\n     E0640, // infer outlives requirements\n     E0641, // cannot cast to/from a pointer with an unknown kind\n-    E0645, // trait aliases not finished\n+//  E0645, // trait aliases not finished\n     E0719, // duplicate values for associated type binding\n     E0722, // Malformed `#[optimize]` attribute\n     E0724, // `#[ffi_returns_twice]` is only allowed in foreign functions"}, {"sha": "5cc953b9066282400bd11c5493f90c1bf4a0873b", "filename": "src/libsyntax/early_buffered_lints.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b5bd31ec6db6a249311888a93fc176f06dcb6aa6/src%2Flibsyntax%2Fearly_buffered_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5bd31ec6db6a249311888a93fc176f06dcb6aa6/src%2Flibsyntax%2Fearly_buffered_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fearly_buffered_lints.rs?ref=b5bd31ec6db6a249311888a93fc176f06dcb6aa6", "patch": "@@ -11,6 +11,7 @@ use syntax_pos::MultiSpan;\n pub enum BufferedEarlyLintId {\n     IllFormedAttributeInput,\n     MetaVariableMisuse,\n+    IncompleteInclude,\n }\n \n /// Stores buffered lint info which can later be passed to `librustc`."}, {"sha": "f74507dcc21f678dca92fe0eb07324b1075ad405", "filename": "src/libsyntax_ext/source_util.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b5bd31ec6db6a249311888a93fc176f06dcb6aa6/src%2Flibsyntax_ext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5bd31ec6db6a249311888a93fc176f06dcb6aa6/src%2Flibsyntax_ext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fsource_util.rs?ref=b5bd31ec6db6a249311888a93fc176f06dcb6aa6", "patch": "@@ -5,6 +5,7 @@ use syntax::print::pprust;\n use syntax::ptr::P;\n use syntax::symbol::Symbol;\n use syntax::tokenstream::TokenStream;\n+use syntax::early_buffered_lints::BufferedEarlyLintId;\n \n use smallvec::SmallVec;\n use syntax_pos::{self, Pos, Span};\n@@ -83,7 +84,16 @@ pub fn expand_include<'cx>(cx: &'cx mut ExtCtxt<'_>, sp: Span, tts: TokenStream)\n     }\n     impl<'a> base::MacResult for ExpandResult<'a> {\n         fn make_expr(mut self: Box<ExpandResult<'a>>) -> Option<P<ast::Expr>> {\n-            Some(panictry!(self.p.parse_expr()))\n+            let r = panictry!(self.p.parse_expr());\n+            if self.p.token != token::Eof {\n+                self.p.sess.buffer_lint(\n+                    BufferedEarlyLintId::IncompleteInclude,\n+                    self.p.token.span,\n+                    ast::CRATE_NODE_ID,\n+                    \"include macro expected single expression in source\",\n+                );\n+            }\n+            Some(r)\n         }\n \n         fn make_items(mut self: Box<ExpandResult<'a>>) -> Option<SmallVec<[P<ast::Item>; 1]>> {"}, {"sha": "0936f3b9e38e856c313cb33272fcaffa658de498", "filename": "src/test/ui/if/if-no-match-bindings.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b5bd31ec6db6a249311888a93fc176f06dcb6aa6/src%2Ftest%2Fui%2Fif%2Fif-no-match-bindings.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b5bd31ec6db6a249311888a93fc176f06dcb6aa6/src%2Ftest%2Fui%2Fif%2Fif-no-match-bindings.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fif%2Fif-no-match-bindings.stderr?ref=b5bd31ec6db6a249311888a93fc176f06dcb6aa6", "patch": "@@ -29,7 +29,7 @@ LL |     if &true {}\n    |        ^^^^^\n    |        |\n    |        expected bool, found &bool\n-   |        help: consider dereferencing the borrow: `*&true`\n+   |        help: consider removing the borrow: `true`\n    |\n    = note: expected type `bool`\n               found type `&bool`\n@@ -41,7 +41,7 @@ LL |     if &mut true {}\n    |        ^^^^^^^^^\n    |        |\n    |        expected bool, found &mut bool\n-   |        help: consider dereferencing the borrow: `*&mut true`\n+   |        help: consider removing the borrow: `true`\n    |\n    = note: expected type `bool`\n               found type `&mut bool`\n@@ -77,7 +77,7 @@ LL |     while &true {}\n    |           ^^^^^\n    |           |\n    |           expected bool, found &bool\n-   |           help: consider dereferencing the borrow: `*&true`\n+   |           help: consider removing the borrow: `true`\n    |\n    = note: expected type `bool`\n               found type `&bool`\n@@ -89,7 +89,7 @@ LL |     while &mut true {}\n    |           ^^^^^^^^^\n    |           |\n    |           expected bool, found &mut bool\n-   |           help: consider dereferencing the borrow: `*&mut true`\n+   |           help: consider removing the borrow: `true`\n    |\n    = note: expected type `bool`\n               found type `&mut bool`"}, {"sha": "aa6380bd24dc7c4e505dd34dd8f2a28753e5ae21", "filename": "src/test/ui/include-single-expr-helper-1.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b5bd31ec6db6a249311888a93fc176f06dcb6aa6/src%2Ftest%2Fui%2Finclude-single-expr-helper-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5bd31ec6db6a249311888a93fc176f06dcb6aa6/src%2Ftest%2Fui%2Finclude-single-expr-helper-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finclude-single-expr-helper-1.rs?ref=b5bd31ec6db6a249311888a93fc176f06dcb6aa6", "patch": "@@ -0,0 +1,5 @@\n+// ignore-test auxiliary file for include-single-expr.rs\n+\n+0\n+\n+// trailing comment permitted"}, {"sha": "84d8b69603b6bf338653990b4643241d39ec20eb", "filename": "src/test/ui/include-single-expr-helper.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b5bd31ec6db6a249311888a93fc176f06dcb6aa6/src%2Ftest%2Fui%2Finclude-single-expr-helper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5bd31ec6db6a249311888a93fc176f06dcb6aa6/src%2Ftest%2Fui%2Finclude-single-expr-helper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finclude-single-expr-helper.rs?ref=b5bd31ec6db6a249311888a93fc176f06dcb6aa6", "patch": "@@ -0,0 +1,5 @@\n+// ignore-test auxiliary file for include-single-expr.rs\n+\n+0\n+10\n+100"}, {"sha": "0f4c29ec01456996a0d1aba1ad2815e767a7d7bb", "filename": "src/test/ui/include-single-expr.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b5bd31ec6db6a249311888a93fc176f06dcb6aa6/src%2Ftest%2Fui%2Finclude-single-expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5bd31ec6db6a249311888a93fc176f06dcb6aa6/src%2Ftest%2Fui%2Finclude-single-expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finclude-single-expr.rs?ref=b5bd31ec6db6a249311888a93fc176f06dcb6aa6", "patch": "@@ -0,0 +1,6 @@\n+// error-pattern include macro expected single expression\n+\n+fn main() {\n+    include!(\"include-single-expr-helper.rs\");\n+    include!(\"include-single-expr-helper-1.rs\");\n+}"}, {"sha": "80eecf8f1b97940658648897aa8bb41a80600ce9", "filename": "src/test/ui/include-single-expr.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b5bd31ec6db6a249311888a93fc176f06dcb6aa6/src%2Ftest%2Fui%2Finclude-single-expr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b5bd31ec6db6a249311888a93fc176f06dcb6aa6/src%2Ftest%2Fui%2Finclude-single-expr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finclude-single-expr.stderr?ref=b5bd31ec6db6a249311888a93fc176f06dcb6aa6", "patch": "@@ -0,0 +1,10 @@\n+error: include macro expected single expression in source\n+  --> $DIR/include-single-expr-helper.rs:4:1\n+   |\n+LL | 10\n+   | ^^\n+   |\n+   = note: `#[deny(incomplete_include)]` on by default\n+\n+error: aborting due to previous error\n+"}, {"sha": "1e74445af55cb0327bb4facb4604e54d0212e01b", "filename": "src/test/ui/inner-static-type-parameter.stderr", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b5bd31ec6db6a249311888a93fc176f06dcb6aa6/src%2Ftest%2Fui%2Finner-static-type-parameter.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b5bd31ec6db6a249311888a93fc176f06dcb6aa6/src%2Ftest%2Fui%2Finner-static-type-parameter.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finner-static-type-parameter.stderr?ref=b5bd31ec6db6a249311888a93fc176f06dcb6aa6", "patch": "@@ -2,9 +2,7 @@ error[E0401]: can't use generic parameters from outer function\n   --> $DIR/inner-static-type-parameter.rs:6:19\n    |\n LL | fn foo<T>() {\n-   |    --- - type parameter from outer function\n-   |    |\n-   |    try adding a local generic parameter in this method instead\n+   |        - type parameter from outer function\n LL |     static a: Bar<T> = Bar::What;\n    |                   ^ use of generic parameter from outer function\n "}, {"sha": "ce45f630e48a58da14702a26e97496b733f17a94", "filename": "src/test/ui/resolve/issue-65025-extern-static-parent-generics.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b5bd31ec6db6a249311888a93fc176f06dcb6aa6/src%2Ftest%2Fui%2Fresolve%2Fissue-65025-extern-static-parent-generics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5bd31ec6db6a249311888a93fc176f06dcb6aa6/src%2Ftest%2Fui%2Fresolve%2Fissue-65025-extern-static-parent-generics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fissue-65025-extern-static-parent-generics.rs?ref=b5bd31ec6db6a249311888a93fc176f06dcb6aa6", "patch": "@@ -0,0 +1,10 @@\n+unsafe fn foo<A>() {\n+    extern \"C\" {\n+        static baz: *const A;\n+        //~^ ERROR can't use generic parameters from outer function\n+    }\n+\n+    let bar: *const u64 = core::mem::transmute(&baz);\n+}\n+\n+fn main() { }"}, {"sha": "6bbf76dd1fbb2a2cafc55b46f2494485989ea044", "filename": "src/test/ui/resolve/issue-65025-extern-static-parent-generics.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b5bd31ec6db6a249311888a93fc176f06dcb6aa6/src%2Ftest%2Fui%2Fresolve%2Fissue-65025-extern-static-parent-generics.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b5bd31ec6db6a249311888a93fc176f06dcb6aa6/src%2Ftest%2Fui%2Fresolve%2Fissue-65025-extern-static-parent-generics.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fissue-65025-extern-static-parent-generics.stderr?ref=b5bd31ec6db6a249311888a93fc176f06dcb6aa6", "patch": "@@ -0,0 +1,12 @@\n+error[E0401]: can't use generic parameters from outer function\n+  --> $DIR/issue-65025-extern-static-parent-generics.rs:3:28\n+   |\n+LL | unsafe fn foo<A>() {\n+   |               - type parameter from outer function\n+LL |     extern \"C\" {\n+LL |         static baz: *const A;\n+   |                            ^ use of generic parameter from outer function\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0401`."}, {"sha": "63d3431ec9b2f7bb9a62163667bca421bdf8264d", "filename": "src/test/ui/resolve/issue-65035-static-with-parent-generics.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/b5bd31ec6db6a249311888a93fc176f06dcb6aa6/src%2Ftest%2Fui%2Fresolve%2Fissue-65035-static-with-parent-generics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5bd31ec6db6a249311888a93fc176f06dcb6aa6/src%2Ftest%2Fui%2Fresolve%2Fissue-65035-static-with-parent-generics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fissue-65035-static-with-parent-generics.rs?ref=b5bd31ec6db6a249311888a93fc176f06dcb6aa6", "patch": "@@ -0,0 +1,29 @@\n+#![feature(const_generics)]\n+//~^ WARN the feature `const_generics` is incomplete and may cause the compiler to crash\n+\n+fn f<T>() {\n+    extern \"C\" {\n+        static a: *const T;\n+        //~^ ERROR can't use generic parameters from outer function\n+    }\n+}\n+\n+fn g<T: Default>() {\n+    static a: *const T = Default::default();\n+    //~^ ERROR can't use generic parameters from outer function\n+}\n+\n+fn h<const N: usize>() {\n+    extern \"C\" {\n+        static a: [u8; N];\n+        //~^ ERROR can't use generic parameters from outer function\n+    }\n+}\n+\n+fn i<const N: usize>() {\n+    static a: [u8; N] = [0; N];\n+    //~^ ERROR can't use generic parameters from outer function\n+    //~^^ ERROR can't use generic parameters from outer function\n+}\n+\n+fn main() {}"}, {"sha": "82e2aa2db8e25efa6ce3338a2f38c36e91f09211", "filename": "src/test/ui/resolve/issue-65035-static-with-parent-generics.stderr", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/b5bd31ec6db6a249311888a93fc176f06dcb6aa6/src%2Ftest%2Fui%2Fresolve%2Fissue-65035-static-with-parent-generics.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b5bd31ec6db6a249311888a93fc176f06dcb6aa6/src%2Ftest%2Fui%2Fresolve%2Fissue-65035-static-with-parent-generics.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fissue-65035-static-with-parent-generics.stderr?ref=b5bd31ec6db6a249311888a93fc176f06dcb6aa6", "patch": "@@ -0,0 +1,53 @@\n+error[E0401]: can't use generic parameters from outer function\n+  --> $DIR/issue-65035-static-with-parent-generics.rs:6:26\n+   |\n+LL | fn f<T>() {\n+   |      - type parameter from outer function\n+LL |     extern \"C\" {\n+LL |         static a: *const T;\n+   |                          ^ use of generic parameter from outer function\n+\n+error[E0401]: can't use generic parameters from outer function\n+  --> $DIR/issue-65035-static-with-parent-generics.rs:12:22\n+   |\n+LL | fn g<T: Default>() {\n+   |      - type parameter from outer function\n+LL |     static a: *const T = Default::default();\n+   |                      ^ use of generic parameter from outer function\n+\n+error[E0401]: can't use generic parameters from outer function\n+  --> $DIR/issue-65035-static-with-parent-generics.rs:18:24\n+   |\n+LL | fn h<const N: usize>() {\n+   |            - const parameter from outer function\n+LL |     extern \"C\" {\n+LL |         static a: [u8; N];\n+   |                        ^ use of generic parameter from outer function\n+\n+error[E0401]: can't use generic parameters from outer function\n+  --> $DIR/issue-65035-static-with-parent-generics.rs:24:20\n+   |\n+LL | fn i<const N: usize>() {\n+   |            - const parameter from outer function\n+LL |     static a: [u8; N] = [0; N];\n+   |                    ^ use of generic parameter from outer function\n+\n+error[E0401]: can't use generic parameters from outer function\n+  --> $DIR/issue-65035-static-with-parent-generics.rs:24:29\n+   |\n+LL | fn i<const N: usize>() {\n+   |            - const parameter from outer function\n+LL |     static a: [u8; N] = [0; N];\n+   |                             ^ use of generic parameter from outer function\n+\n+warning: the feature `const_generics` is incomplete and may cause the compiler to crash\n+  --> $DIR/issue-65035-static-with-parent-generics.rs:1:12\n+   |\n+LL | #![feature(const_generics)]\n+   |            ^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+\n+error: aborting due to 5 previous errors\n+\n+For more information about this error, try `rustc --explain E0401`."}, {"sha": "ad4686c1915d67de9ef1e40b89cff1bca1e80770", "filename": "src/test/ui/rfc-2497-if-let-chains/disallowed-positions.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b5bd31ec6db6a249311888a93fc176f06dcb6aa6/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fdisallowed-positions.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b5bd31ec6db6a249311888a93fc176f06dcb6aa6/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fdisallowed-positions.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fdisallowed-positions.stderr?ref=b5bd31ec6db6a249311888a93fc176f06dcb6aa6", "patch": "@@ -520,7 +520,7 @@ LL |     if &let 0 = 0 {}\n    |        ^^^^^^^^^^\n    |        |\n    |        expected bool, found &bool\n-   |        help: consider dereferencing the borrow: `*&let 0 = 0`\n+   |        help: consider removing the borrow: `let 0 = 0`\n    |\n    = note: expected type `bool`\n               found type `&bool`\n@@ -708,7 +708,7 @@ LL |     while &let 0 = 0 {}\n    |           ^^^^^^^^^^\n    |           |\n    |           expected bool, found &bool\n-   |           help: consider dereferencing the borrow: `*&let 0 = 0`\n+   |           help: consider removing the borrow: `let 0 = 0`\n    |\n    = note: expected type `bool`\n               found type `&bool`"}, {"sha": "eae9cc075084a683c6b87d208b181bf2a9d3dab8", "filename": "src/test/ui/suggestions/remove-as_str.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b5bd31ec6db6a249311888a93fc176f06dcb6aa6/src%2Ftest%2Fui%2Fsuggestions%2Fremove-as_str.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b5bd31ec6db6a249311888a93fc176f06dcb6aa6/src%2Ftest%2Fui%2Fsuggestions%2Fremove-as_str.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fremove-as_str.stderr?ref=b5bd31ec6db6a249311888a93fc176f06dcb6aa6", "patch": "@@ -2,25 +2,25 @@ error[E0599]: no method named `as_str` found for type `&str` in the current scop\n   --> $DIR/remove-as_str.rs:2:7\n    |\n LL |     s.as_str();\n-   |       ^^^^^^ try removing `as_str`\n+   |      -^^^^^^-- help: remove this method call\n \n error[E0599]: no method named `as_str` found for type `&'a str` in the current scope\n   --> $DIR/remove-as_str.rs:7:7\n    |\n LL |     s.as_str();\n-   |       ^^^^^^ try removing `as_str`\n+   |      -^^^^^^-- help: remove this method call\n \n error[E0599]: no method named `as_str` found for type `&mut str` in the current scope\n   --> $DIR/remove-as_str.rs:12:7\n    |\n LL |     s.as_str();\n-   |       ^^^^^^ try removing `as_str`\n+   |      -^^^^^^-- help: remove this method call\n \n error[E0599]: no method named `as_str` found for type `&&str` in the current scope\n   --> $DIR/remove-as_str.rs:17:7\n    |\n LL |     s.as_str();\n-   |       ^^^^^^ try removing `as_str`\n+   |      -^^^^^^-- help: remove this method call\n \n error: aborting due to 4 previous errors\n "}, {"sha": "c59533da1dc39c06eb0e982fafe5a2a21c4f6cdb", "filename": "src/tools/error_index_generator/build.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b5bd31ec6db6a249311888a93fc176f06dcb6aa6/src%2Ftools%2Ferror_index_generator%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5bd31ec6db6a249311888a93fc176f06dcb6aa6/src%2Ftools%2Ferror_index_generator%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ferror_index_generator%2Fbuild.rs?ref=b5bd31ec6db6a249311888a93fc176f06dcb6aa6", "patch": "@@ -15,7 +15,7 @@ fn main() {\n             println!(\"cargo:rerun-if-changed={}\", entry.path().to_str().unwrap());\n             let file = fs::read_to_string(entry.path()).unwrap()\n                 .replace(\"syntax::register_diagnostics!\", \"register_diagnostics!\");\n-            let contents = format!(\"(|| {{\\n{}\\n}})();\", file);\n+            let contents = format!(\"(|| {{\\n{}\\n}})()\", file);\n \n             fs::write(&out_dir.join(&format!(\"error_{}.rs\", idx)), &contents).unwrap();\n "}, {"sha": "159baff184d1be900e530cef616243c79c6d6063", "filename": "src/tools/tidy/src/error_codes_check.rs", "status": "added", "additions": 137, "deletions": 0, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/b5bd31ec6db6a249311888a93fc176f06dcb6aa6/src%2Ftools%2Ftidy%2Fsrc%2Ferror_codes_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5bd31ec6db6a249311888a93fc176f06dcb6aa6/src%2Ftools%2Ftidy%2Fsrc%2Ferror_codes_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Ferror_codes_check.rs?ref=b5bd31ec6db6a249311888a93fc176f06dcb6aa6", "patch": "@@ -0,0 +1,137 @@\n+//! Checks that all error codes have at least one test to prevent having error\n+//! codes that are silently not thrown by the compiler anymore.\n+\n+use std::collections::HashMap;\n+use std::ffi::OsStr;\n+use std::path::Path;\n+\n+// A few of those error codes can't be tested but all the others can and *should* be tested!\n+const WHITELIST: &[&str] = &[\n+    \"E0183\",\n+    \"E0227\",\n+    \"E0279\",\n+    \"E0280\",\n+    \"E0311\",\n+    \"E0313\",\n+    \"E0314\",\n+    \"E0315\",\n+    \"E0377\",\n+    \"E0456\",\n+    \"E0461\",\n+    \"E0462\",\n+    \"E0464\",\n+    \"E0465\",\n+    \"E0472\",\n+    \"E0473\",\n+    \"E0474\",\n+    \"E0475\",\n+    \"E0476\",\n+    \"E0479\",\n+    \"E0480\",\n+    \"E0481\",\n+    \"E0482\",\n+    \"E0483\",\n+    \"E0484\",\n+    \"E0485\",\n+    \"E0486\",\n+    \"E0487\",\n+    \"E0488\",\n+    \"E0489\",\n+    \"E0514\",\n+    \"E0519\",\n+    \"E0523\",\n+    \"E0526\",\n+    \"E0554\",\n+    \"E0570\",\n+    \"E0629\",\n+    \"E0630\",\n+    \"E0640\",\n+    \"E0717\",\n+    \"E0727\",\n+    \"E0729\",\n+];\n+\n+fn extract_error_codes(f: &str, error_codes: &mut HashMap<String, bool>) {\n+    let mut reached_no_explanation = false;\n+    let mut last_error_code = None;\n+\n+    for line in f.lines() {\n+        let s = line.trim();\n+        if s.starts_with('E') && s.ends_with(\": r##\\\"\") {\n+            if let Some(err_code) = s.splitn(2, ':').next() {\n+                let err_code = err_code.to_owned();\n+                last_error_code = Some(err_code.clone());\n+                if !error_codes.contains_key(&err_code) {\n+                    error_codes.insert(err_code, false);\n+                }\n+            }\n+        } else if s.starts_with(\"```\") && s.contains(\"compile_fail\") && s.contains('E') {\n+            if let Some(err_code) = s.splitn(2, 'E').skip(1).next() {\n+                if let Some(err_code) = err_code.splitn(2, ',').next() {\n+                    let nb = error_codes.entry(format!(\"E{}\", err_code)).or_insert(false);\n+                    *nb = true;\n+                }\n+            }\n+        } else if s == \";\" {\n+            reached_no_explanation = true;\n+        } else if reached_no_explanation && s.starts_with('E') {\n+            if let Some(err_code) = s.splitn(2, ',').next() {\n+                let err_code = err_code.to_owned();\n+                if !error_codes.contains_key(&err_code) { // this check should *never* fail!\n+                    error_codes.insert(err_code, false);\n+                }\n+            }\n+        } else if s.starts_with(\"#### Note: this error code is no longer emitted by the compiler\") {\n+            if let Some(last) = last_error_code {\n+                error_codes.get_mut(&last).map(|x| *x = true);\n+            }\n+            last_error_code = None;\n+        }\n+    }\n+}\n+\n+fn extract_error_codes_from_tests(f: &str, error_codes: &mut HashMap<String, bool>) {\n+    for line in f.lines() {\n+        let s = line.trim();\n+        if s.starts_with(\"error[E\") || s.starts_with(\"warning[E\") {\n+            if let Some(err_code) = s.splitn(2, ']').next() {\n+                if let Some(err_code) = err_code.splitn(2, '[').skip(1).next() {\n+                    let nb = error_codes.entry(err_code.to_owned()).or_insert(false);\n+                    *nb = true;\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+pub fn check(path: &Path, bad: &mut bool) {\n+    println!(\"Checking which error codes lack tests...\");\n+    let mut error_codes: HashMap<String, bool> = HashMap::new();\n+    super::walk(path,\n+                &mut |path| super::filter_dirs(path),\n+                &mut |entry, contents| {\n+        let file_name = entry.file_name();\n+        if file_name == \"error_codes.rs\" {\n+            extract_error_codes(contents, &mut error_codes);\n+        } else if entry.path().extension() == Some(OsStr::new(\"stderr\")) {\n+            extract_error_codes_from_tests(contents, &mut error_codes);\n+        }\n+    });\n+    println!(\"Found {} error codes\", error_codes.len());\n+\n+    let mut errors = Vec::new();\n+    for (err_code, nb) in &error_codes {\n+        if !*nb && !WHITELIST.contains(&err_code.as_str()) {\n+            errors.push(format!(\"Error code {} needs to have at least one UI test!\", err_code));\n+        }\n+    }\n+    errors.sort();\n+    for err in &errors {\n+        eprintln!(\"{}\", err);\n+    }\n+    println!(\"Found {} error codes with no tests\", errors.len());\n+    if !errors.is_empty() {\n+        *bad = true;\n+    }\n+    println!(\"Done!\");\n+}"}, {"sha": "eb93eb297479d03e37bc7fb15babcad4fb5c294b", "filename": "src/tools/tidy/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b5bd31ec6db6a249311888a93fc176f06dcb6aa6/src%2Ftools%2Ftidy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5bd31ec6db6a249311888a93fc176f06dcb6aa6/src%2Ftools%2Ftidy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Flib.rs?ref=b5bd31ec6db6a249311888a93fc176f06dcb6aa6", "patch": "@@ -41,6 +41,7 @@ pub mod extdeps;\n pub mod ui_tests;\n pub mod unit_tests;\n pub mod unstable_book;\n+pub mod error_codes_check;\n \n fn filter_dirs(path: &Path) -> bool {\n     let skip = ["}, {"sha": "e08c23c01fe2d337ef332352433716d0ceab0d8d", "filename": "src/tools/tidy/src/main.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b5bd31ec6db6a249311888a93fc176f06dcb6aa6/src%2Ftools%2Ftidy%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5bd31ec6db6a249311888a93fc176f06dcb6aa6/src%2Ftools%2Ftidy%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fmain.rs?ref=b5bd31ec6db6a249311888a93fc176f06dcb6aa6", "patch": "@@ -35,6 +35,7 @@ fn main() {\n     deps::check_whitelist(&path, &cargo, &mut bad);\n     extdeps::check(&path, &mut bad);\n     ui_tests::check(&path, &mut bad);\n+    error_codes_check::check(&path, &mut bad);\n \n     if bad {\n         eprintln!(\"some tidy checks failed\");"}]}