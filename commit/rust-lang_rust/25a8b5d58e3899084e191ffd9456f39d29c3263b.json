{"sha": "25a8b5d58e3899084e191ffd9456f39d29c3263b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI1YThiNWQ1OGUzODk5MDg0ZTE5MWZmZDk0NTZmMzlkMjljMzI2M2I=", "commit": {"author": {"name": "Wesley Wiser", "email": "wwiser@gmail.com", "date": "2019-12-27T16:44:36Z"}, "committer": {"name": "Wesley Wiser", "email": "wwiser@gmail.com", "date": "2019-12-27T18:04:32Z"}, "message": "Fix `Instance::resolve()` incorrectly returning specialized instances\n\nWe only want to return specializations when `Reveal::All` is passed, not\nwhen `Reveal::UserFacing` is. Resolving this fixes several issues with\nthe `ConstProp`, `SimplifyBranches`, and `Inline` MIR optimization\npasses.\n\nFixes #66901", "tree": {"sha": "770a1239529778173c709cf29b2826faee379a12", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/770a1239529778173c709cf29b2826faee379a12"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/25a8b5d58e3899084e191ffd9456f39d29c3263b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/25a8b5d58e3899084e191ffd9456f39d29c3263b", "html_url": "https://github.com/rust-lang/rust/commit/25a8b5d58e3899084e191ffd9456f39d29c3263b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/25a8b5d58e3899084e191ffd9456f39d29c3263b/comments", "author": {"login": "wesleywiser", "id": 831192, "node_id": "MDQ6VXNlcjgzMTE5Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/831192?v=4", "gravatar_id": "", "url": "https://api.github.com/users/wesleywiser", "html_url": "https://github.com/wesleywiser", "followers_url": "https://api.github.com/users/wesleywiser/followers", "following_url": "https://api.github.com/users/wesleywiser/following{/other_user}", "gists_url": "https://api.github.com/users/wesleywiser/gists{/gist_id}", "starred_url": "https://api.github.com/users/wesleywiser/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/wesleywiser/subscriptions", "organizations_url": "https://api.github.com/users/wesleywiser/orgs", "repos_url": "https://api.github.com/users/wesleywiser/repos", "events_url": "https://api.github.com/users/wesleywiser/events{/privacy}", "received_events_url": "https://api.github.com/users/wesleywiser/received_events", "type": "User", "site_admin": false}, "committer": {"login": "wesleywiser", "id": 831192, "node_id": "MDQ6VXNlcjgzMTE5Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/831192?v=4", "gravatar_id": "", "url": "https://api.github.com/users/wesleywiser", "html_url": "https://github.com/wesleywiser", "followers_url": "https://api.github.com/users/wesleywiser/followers", "following_url": "https://api.github.com/users/wesleywiser/following{/other_user}", "gists_url": "https://api.github.com/users/wesleywiser/gists{/gist_id}", "starred_url": "https://api.github.com/users/wesleywiser/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/wesleywiser/subscriptions", "organizations_url": "https://api.github.com/users/wesleywiser/orgs", "repos_url": "https://api.github.com/users/wesleywiser/repos", "events_url": "https://api.github.com/users/wesleywiser/events{/privacy}", "received_events_url": "https://api.github.com/users/wesleywiser/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "41501a6b03a8f10d8c29dfcb37dbd5ff84b33f34", "url": "https://api.github.com/repos/rust-lang/rust/commits/41501a6b03a8f10d8c29dfcb37dbd5ff84b33f34", "html_url": "https://github.com/rust-lang/rust/commit/41501a6b03a8f10d8c29dfcb37dbd5ff84b33f34"}], "stats": {"total": 199, "additions": 182, "deletions": 17}, "files": [{"sha": "c593a51e457b8179d2dc027ad2da1ddf8bcc6834", "filename": "src/librustc/mir/interpret/queries.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/25a8b5d58e3899084e191ffd9456f39d29c3263b/src%2Flibrustc%2Fmir%2Finterpret%2Fqueries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25a8b5d58e3899084e191ffd9456f39d29c3263b/src%2Flibrustc%2Fmir%2Finterpret%2Fqueries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fqueries.rs?ref=25a8b5d58e3899084e191ffd9456f39d29c3263b", "patch": "@@ -18,7 +18,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         let substs = InternalSubsts::identity_for_item(self, def_id);\n         let instance = ty::Instance::new(def_id, substs);\n         let cid = GlobalId { instance, promoted: None };\n-        let param_env = self.param_env(def_id);\n+        let param_env = self.param_env(def_id).with_reveal_all();\n         self.const_eval_validated(param_env.and(cid))\n     }\n "}, {"sha": "bcb012ea51494e3e8fb740958d7e67dd901f39ff", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/25a8b5d58e3899084e191ffd9456f39d29c3263b/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25a8b5d58e3899084e191ffd9456f39d29c3263b/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=25a8b5d58e3899084e191ffd9456f39d29c3263b", "patch": "@@ -1028,6 +1028,9 @@ fn assemble_candidates_from_impls<'cx, 'tcx>(\n                 // In either case, we handle this by not adding a\n                 // candidate for an impl if it contains a `default`\n                 // type.\n+                //\n+                // NOTE: This should be kept in sync with the similar code in\n+                // `rustc::ty::instance::resolve_associated_item()`.\n                 let node_item =\n                     assoc_ty_def(selcx, impl_data.impl_def_id, obligation.predicate.item_def_id);\n "}, {"sha": "cfd1779c080ecc3388671479a5378c71fbf30207", "filename": "src/librustc/ty/instance.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/25a8b5d58e3899084e191ffd9456f39d29c3263b/src%2Flibrustc%2Fty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25a8b5d58e3899084e191ffd9456f39d29c3263b/src%2Flibrustc%2Fty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finstance.rs?ref=25a8b5d58e3899084e191ffd9456f39d29c3263b", "patch": "@@ -346,6 +346,25 @@ fn resolve_associated_item<'tcx>(\n         traits::VtableImpl(impl_data) => {\n             let (def_id, substs) =\n                 traits::find_associated_item(tcx, param_env, trait_item, rcvr_substs, &impl_data);\n+\n+            let resolved_item = tcx.associated_item(def_id);\n+\n+            // Since this is a trait item, we need to see if the item is either a trait default item\n+            // or a specialization because we can't resolve those unless we can `Reveal::All`.\n+            // NOTE: This should be kept in sync with the similar code in\n+            // `rustc::traits::project::assemble_candidates_from_impls()`.\n+            let eligible = if !resolved_item.defaultness.is_default() {\n+                true\n+            } else if param_env.reveal == traits::Reveal::All {\n+                !trait_ref.needs_subst()\n+            } else {\n+                false\n+            };\n+\n+            if !eligible {\n+                return None;\n+            }\n+\n             let substs = tcx.erase_regions(&substs);\n             Some(ty::Instance::new(def_id, substs))\n         }"}, {"sha": "6c4b69d9d767e3eb32c604a1c5724e05904115c7", "filename": "src/librustc_mir/const_eval/eval_queries.rs", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/25a8b5d58e3899084e191ffd9456f39d29c3263b/src%2Flibrustc_mir%2Fconst_eval%2Feval_queries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25a8b5d58e3899084e191ffd9456f39d29c3263b/src%2Flibrustc_mir%2Fconst_eval%2Feval_queries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval%2Feval_queries.rs?ref=25a8b5d58e3899084e191ffd9456f39d29c3263b", "patch": "@@ -212,11 +212,7 @@ pub fn const_eval_validated_provider<'tcx>(\n         key.param_env.reveal = Reveal::UserFacing;\n         match tcx.const_eval_validated(key) {\n             // try again with reveal all as requested\n-            Err(ErrorHandled::TooGeneric) => {\n-                // Promoteds should never be \"too generic\" when getting evaluated.\n-                // They either don't get evaluated, or we are in a monomorphic context\n-                assert!(key.value.promoted.is_none());\n-            }\n+            Err(ErrorHandled::TooGeneric) => {}\n             // dedupliate calls\n             other => return other,\n         }\n@@ -301,10 +297,18 @@ pub fn const_eval_raw_provider<'tcx>(\n                 // Ensure that if the above error was either `TooGeneric` or `Reported`\n                 // an error must be reported.\n                 let v = err.report_as_error(ecx.tcx, \"could not evaluate static initializer\");\n-                tcx.sess.delay_span_bug(\n-                    err.span,\n-                    &format!(\"static eval failure did not emit an error: {:#?}\", v),\n-                );\n+\n+                // If this is `Reveal:All`, then we need to make sure an error is reported but if\n+                // this is `Reveal::UserFacing`, then it's expected that we could get a\n+                // `TooGeneric` error. When we fall back to `Reveal::All`, then it will either\n+                // succeed or we'll report this error then.\n+                if key.param_env.reveal == Reveal::All {\n+                    tcx.sess.delay_span_bug(\n+                        err.span,\n+                        &format!(\"static eval failure did not emit an error: {:#?}\", v),\n+                    );\n+                }\n+\n                 v\n             } else if def_id.is_local() {\n                 // constant defined in this crate, we can figure out a lint level!"}, {"sha": "8c380589151e8a6ed65792d06324bf4ac2f3d34d", "filename": "src/librustc_mir/hair/pattern/mod.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/25a8b5d58e3899084e191ffd9456f39d29c3263b/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25a8b5d58e3899084e191ffd9456f39d29c3263b/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs?ref=25a8b5d58e3899084e191ffd9456f39d29c3263b", "patch": "@@ -742,7 +742,13 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n         let kind = match res {\n             Res::Def(DefKind::Const, def_id) | Res::Def(DefKind::AssocConst, def_id) => {\n                 let substs = self.tables.node_substs(id);\n-                match self.tcx.const_eval_resolve(self.param_env, def_id, substs, Some(span)) {\n+                // Use `Reveal::All` here because patterns are always monomorphic even if their function isn't.\n+                match self.tcx.const_eval_resolve(\n+                    self.param_env.with_reveal_all(),\n+                    def_id,\n+                    substs,\n+                    Some(span),\n+                ) {\n                     Ok(value) => {\n                         let pattern = self.const_to_pat(value, id, span);\n                         if !is_associated_const {"}, {"sha": "62717daed16420a775498db320e886a3b3af5a90", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/25a8b5d58e3899084e191ffd9456f39d29c3263b/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25a8b5d58e3899084e191ffd9456f39d29c3263b/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=25a8b5d58e3899084e191ffd9456f39d29c3263b", "patch": "@@ -33,6 +33,7 @@ use crate::interpret::{\n     ScalarMaybeUndef, StackPopCleanup,\n };\n use crate::rustc::ty::subst::Subst;\n+use crate::rustc::ty::TypeFoldable;\n use crate::transform::{MirPass, MirSource};\n \n /// The maximum number of bytes that we'll allocate space for a return value.\n@@ -293,13 +294,20 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         source: MirSource<'tcx>,\n     ) -> ConstPropagator<'mir, 'tcx> {\n         let def_id = source.def_id();\n-        let param_env = tcx.param_env(def_id);\n+        let substs = &InternalSubsts::identity_for_item(tcx, def_id);\n+        let mut param_env = tcx.param_env(def_id);\n+\n+        // If we're evaluating inside a monomorphic function, then use `Reveal::All` because\n+        // we want to see the same instances that codegen will see. This allows us to `resolve()`\n+        // specializations.\n+        if !substs.needs_subst() {\n+            param_env = param_env.with_reveal_all();\n+        }\n+\n         let span = tcx.def_span(def_id);\n         let mut ecx = InterpCx::new(tcx.at(span), param_env, ConstPropMachine, ());\n         let can_const_prop = CanConstProp::check(body);\n \n-        let substs = &InternalSubsts::identity_for_item(tcx, def_id);\n-\n         let ret = ecx\n             .layout_of(body.return_ty().subst(tcx, substs))\n             .ok()"}, {"sha": "98cd34177096569015fbe45df43ade961b805f62", "filename": "src/librustc_mir/transform/inline.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/25a8b5d58e3899084e191ffd9456f39d29c3263b/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25a8b5d58e3899084e191ffd9456f39d29c3263b/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finline.rs?ref=25a8b5d58e3899084e191ffd9456f39d29c3263b", "patch": "@@ -8,8 +8,8 @@ use rustc_index::vec::{Idx, IndexVec};\n \n use rustc::mir::visit::*;\n use rustc::mir::*;\n-use rustc::ty::subst::{Subst, SubstsRef};\n-use rustc::ty::{self, Instance, InstanceDef, ParamEnv, Ty, TyCtxt};\n+use rustc::ty::subst::{InternalSubsts, Subst, SubstsRef};\n+use rustc::ty::{self, Instance, InstanceDef, ParamEnv, Ty, TyCtxt, TypeFoldable};\n \n use super::simplify::{remove_dead_blocks, CfgSimplifier};\n use crate::transform::{MirPass, MirSource};\n@@ -66,7 +66,14 @@ impl Inliner<'tcx> {\n \n         let mut callsites = VecDeque::new();\n \n-        let param_env = self.tcx.param_env(self.source.def_id());\n+        let mut param_env = self.tcx.param_env(self.source.def_id());\n+\n+        let substs = &InternalSubsts::identity_for_item(self.tcx, self.source.def_id());\n+\n+        // For monomorphic functions, we can use `Reveal::All` to resolve specialized instances.\n+        if !substs.needs_subst() {\n+            param_env = param_env.with_reveal_all();\n+        }\n \n         // Only do inlining into fn bodies.\n         let id = self.tcx.hir().as_local_hir_id(self.source.def_id()).unwrap();"}, {"sha": "9591019bb4f70670f84d2cae174d9ce7a8cef9e6", "filename": "src/test/mir-opt/inline/inline-specialization.rs", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/25a8b5d58e3899084e191ffd9456f39d29c3263b/src%2Ftest%2Fmir-opt%2Finline%2Finline-specialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25a8b5d58e3899084e191ffd9456f39d29c3263b/src%2Ftest%2Fmir-opt%2Finline%2Finline-specialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finline%2Finline-specialization.rs?ref=25a8b5d58e3899084e191ffd9456f39d29c3263b", "patch": "@@ -0,0 +1,48 @@\n+#![feature(specialization)]\n+\n+fn main() {\n+    let x = <Vec::<()> as Foo>::bar();\n+}\n+\n+trait Foo {\n+    fn bar() -> u32;\n+}\n+\n+impl<T> Foo for Vec<T> {\n+    #[inline(always)]\n+    default fn bar() -> u32 { 123 }\n+}\n+\n+// END RUST SOURCE\n+// START rustc.main.Inline.before.mir\n+// let mut _0: ();\n+// let _1: u32;\n+// scope 1 {\n+//   debug x => _1;\n+// }\n+// bb0: {\n+//   StorageLive(_1);\n+//   _1 = const <std::vec::Vec<()> as Foo>::bar() -> bb1;\n+// }\n+// bb1: {\n+//   _0 = ();\n+//   StorageDead(_1);\n+//   return;\n+// }\n+// END rustc.main.Inline.before.mir\n+// START rustc.main.Inline.after.mir\n+// let mut _0: ();\n+// let _1: u32;\n+// scope 1 {\n+//   debug x => _1;\n+// }\n+// scope 2 {\n+// }\n+// bb0: {\n+//   StorageLive(_1);\n+//   _1 = const 123u32;\n+//   _0 = ();\n+//   StorageDead(_1);\n+//   return;\n+// }\n+// END rustc.main.Inline.after.mir"}, {"sha": "8010d2fe1aee933983eb901a15c14c686385e70a", "filename": "src/test/ui/consts/trait_specialization.rs", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/25a8b5d58e3899084e191ffd9456f39d29c3263b/src%2Ftest%2Fui%2Fconsts%2Ftrait_specialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25a8b5d58e3899084e191ffd9456f39d29c3263b/src%2Ftest%2Fui%2Fconsts%2Ftrait_specialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Ftrait_specialization.rs?ref=25a8b5d58e3899084e191ffd9456f39d29c3263b", "patch": "@@ -0,0 +1,65 @@\n+// ignore-wasm32-bare which doesn't support `std::process:exit()`\n+// compile-flags: -Zmir-opt-level=2\n+// run-pass\n+\n+// Tests that specialization does not cause optimizations running on polymorphic MIR to resolve\n+// to a `default` implementation.\n+\n+#![feature(specialization)]\n+\n+trait Marker {}\n+\n+trait SpecializedTrait {\n+    const CONST_BOOL: bool;\n+    const CONST_STR: &'static str;\n+    fn method() -> &'static str;\n+}\n+impl <T> SpecializedTrait for T {\n+    default const CONST_BOOL: bool = false;\n+    default const CONST_STR: &'static str = \"in default impl\";\n+    #[inline(always)]\n+    default fn method() -> &'static str {\n+        \"in default impl\"\n+    }\n+}\n+impl <T: Marker> SpecializedTrait for T {\n+    const CONST_BOOL: bool = true;\n+    const CONST_STR: &'static str = \"in specialized impl\";\n+    fn method() -> &'static str {\n+        \"in specialized impl\"\n+    }\n+}\n+\n+fn const_bool<T>() -> &'static str {\n+    if <T as SpecializedTrait>::CONST_BOOL {\n+        \"in specialized impl\"\n+    } else {\n+        \"in default impl\"\n+    }\n+}\n+fn const_str<T>() -> &'static str {\n+    <T as SpecializedTrait>::CONST_STR\n+}\n+fn run_method<T>() -> &'static str {\n+    <T as SpecializedTrait>::method()\n+}\n+\n+struct TypeA;\n+impl Marker for TypeA {}\n+struct TypeB;\n+\n+#[inline(never)]\n+fn exit_if_not_eq(left: &str, right: &str) {\n+    if left != right {\n+        std::process::exit(1);\n+    }\n+}\n+\n+pub fn main() {\n+    exit_if_not_eq(\"in specialized impl\", const_bool::<TypeA>());\n+    exit_if_not_eq(\"in default impl\", const_bool::<TypeB>());\n+    exit_if_not_eq(\"in specialized impl\", const_str::<TypeA>());\n+    exit_if_not_eq(\"in default impl\", const_str::<TypeB>());\n+    exit_if_not_eq(\"in specialized impl\", run_method::<TypeA>());\n+    exit_if_not_eq(\"in default impl\", run_method::<TypeB>());\n+}"}, {"sha": "db535b53fcf3743aa727baca240afca29f822e5d", "filename": "src/test/ui/type-alias-enum-variants/self-in-enum-definition.stderr", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/25a8b5d58e3899084e191ffd9456f39d29c3263b/src%2Ftest%2Fui%2Ftype-alias-enum-variants%2Fself-in-enum-definition.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/25a8b5d58e3899084e191ffd9456f39d29c3263b/src%2Ftest%2Fui%2Ftype-alias-enum-variants%2Fself-in-enum-definition.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-enum-variants%2Fself-in-enum-definition.stderr?ref=25a8b5d58e3899084e191ffd9456f39d29c3263b", "patch": "@@ -4,6 +4,11 @@ error[E0391]: cycle detected when const-evaluating + checking `Alpha::V3::{{cons\n LL |     V3 = Self::V1 {} as u8 + 2,\n    |          ^^^^^^^^\n    |\n+note: ...which requires const-evaluating + checking `Alpha::V3::{{constant}}#0`...\n+  --> $DIR/self-in-enum-definition.rs:5:10\n+   |\n+LL |     V3 = Self::V1 {} as u8 + 2,\n+   |          ^^^^^^^^\n note: ...which requires const-evaluating `Alpha::V3::{{constant}}#0`...\n   --> $DIR/self-in-enum-definition.rs:5:10\n    |"}]}