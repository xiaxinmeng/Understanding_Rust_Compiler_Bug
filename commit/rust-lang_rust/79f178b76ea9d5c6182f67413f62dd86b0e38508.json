{"sha": "79f178b76ea9d5c6182f67413f62dd86b0e38508", "node_id": "C_kwDOAAsO6NoAKDc5ZjE3OGI3NmVhOWQ1YzYxODJmNjc0MTNmNjJkZDg2YjBlMzg1MDg", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-04-02T02:35:03Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-04-02T02:35:03Z"}, "message": "Auto merge of #95581 - Dylan-DPC:rollup-2suh5h1, r=Dylan-DPC\n\nRollup of 8 pull requests\n\nSuccessful merges:\n\n - #95354 (Handle rustc_const_stable attribute in library feature collector)\n - #95373 (invalid_value lint: detect invalid initialization of arrays)\n - #95430 (Disable #[thread_local] support on i686-pc-windows-msvc)\n - #95544 (Add error message suggestion for missing noreturn in naked function)\n - #95556 (Implement provenance preserving methods on NonNull)\n - #95557 (Fix `thread_local!` macro to be compatible with `no_implicit_prelude`)\n - #95559 (small type system refactoring)\n - #95560 (convert more `DefId`s to `LocalDefId`)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "6b246b60668f826a00e2264255f7c2e4237ed837", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6b246b60668f826a00e2264255f7c2e4237ed837"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/79f178b76ea9d5c6182f67413f62dd86b0e38508", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/79f178b76ea9d5c6182f67413f62dd86b0e38508", "html_url": "https://github.com/rust-lang/rust/commit/79f178b76ea9d5c6182f67413f62dd86b0e38508", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/79f178b76ea9d5c6182f67413f62dd86b0e38508/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c75909c2340c0f8bdf20079b34025fbf3b952985", "url": "https://api.github.com/repos/rust-lang/rust/commits/c75909c2340c0f8bdf20079b34025fbf3b952985", "html_url": "https://github.com/rust-lang/rust/commit/c75909c2340c0f8bdf20079b34025fbf3b952985"}, {"sha": "1c82fac3f7ca41937faf8b8ade8e120259255b88", "url": "https://api.github.com/repos/rust-lang/rust/commits/1c82fac3f7ca41937faf8b8ade8e120259255b88", "html_url": "https://github.com/rust-lang/rust/commit/1c82fac3f7ca41937faf8b8ade8e120259255b88"}], "stats": {"total": 581, "additions": 389, "deletions": 192}, "files": [{"sha": "c7fa2527eb2f388b0fae7ad1685720da4ad50b4f", "filename": "compiler/rustc_infer/src/infer/canonical/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/79f178b76ea9d5c6182f67413f62dd86b0e38508/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79f178b76ea9d5c6182f67413f62dd86b0e38508/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fmod.rs?ref=79f178b76ea9d5c6182f67413f62dd86b0e38508", "patch": "@@ -49,7 +49,6 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n     /// At the end of processing, the substitution S (once\n     /// canonicalized) then represents the values that you computed\n     /// for each of the canonical inputs to your query.\n-\n     pub fn instantiate_canonical_with_fresh_inference_vars<T>(\n         &self,\n         span: Span,"}, {"sha": "86229dbfad746a51b528e1de9fff6d256cf7baff", "filename": "compiler/rustc_infer/src/infer/combine.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/79f178b76ea9d5c6182f67413f62dd86b0e38508/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79f178b76ea9d5c6182f67413f62dd86b0e38508/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs?ref=79f178b76ea9d5c6182f67413f62dd86b0e38508", "patch": "@@ -27,15 +27,12 @@ use super::glb::Glb;\n use super::lub::Lub;\n use super::sub::Sub;\n use super::type_variable::TypeVariableValue;\n-use super::unify_key::replace_if_possible;\n-use super::unify_key::{ConstVarValue, ConstVariableValue};\n-use super::unify_key::{ConstVariableOrigin, ConstVariableOriginKind};\n use super::{InferCtxt, MiscVariable, TypeTrace};\n-\n use crate::traits::{Obligation, PredicateObligations};\n-\n use rustc_data_structures::sso::SsoHashMap;\n use rustc_hir::def_id::DefId;\n+use rustc_middle::infer::unify_key::{ConstVarValue, ConstVariableValue};\n+use rustc_middle::infer::unify_key::{ConstVariableOrigin, ConstVariableOriginKind};\n use rustc_middle::traits::ObligationCause;\n use rustc_middle::ty::error::{ExpectedFound, TypeError};\n use rustc_middle::ty::relate::{self, Relate, RelateResult, TypeRelation};\n@@ -140,8 +137,8 @@ impl<'infcx, 'tcx> InferCtxt<'infcx, 'tcx> {\n             return Ok(a);\n         }\n \n-        let a = replace_if_possible(&mut self.inner.borrow_mut().const_unification_table(), a);\n-        let b = replace_if_possible(&mut self.inner.borrow_mut().const_unification_table(), b);\n+        let a = self.shallow_resolve(a);\n+        let b = self.shallow_resolve(b);\n \n         let a_is_expected = relation.a_is_expected();\n "}, {"sha": "c33c0c996bdeeae535704f863bd4c9fb88f10466", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/static_impl_trait.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/79f178b76ea9d5c6182f67413f62dd86b0e38508/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79f178b76ea9d5c6182f67413f62dd86b0e38508/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs?ref=79f178b76ea9d5c6182f67413f62dd86b0e38508", "patch": "@@ -237,15 +237,15 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n                 ObligationCauseCode::MatchImpl(parent, ..) => parent.code(),\n                 _ => cause.code(),\n             }\n-            && let (ObligationCauseCode::ItemObligation(item_def_id), None) = (code, override_error_code)\n+            && let (&ObligationCauseCode::ItemObligation(item_def_id), None) = (code, override_error_code)\n         {\n             // Same case of `impl Foo for dyn Bar { fn qux(&self) {} }` introducing a `'static`\n             // lifetime as above, but called using a fully-qualified path to the method:\n             // `Foo::qux(bar)`.\n             let mut v = TraitObjectVisitor(FxHashSet::default());\n             v.visit_ty(param.param_ty);\n             if let Some((ident, self_ty)) =\n-                self.get_impl_ident_and_self_ty_from_trait(*item_def_id, &v.0)\n+                self.get_impl_ident_and_self_ty_from_trait(item_def_id, &v.0)\n                 && self.suggest_constrain_dyn_trait_in_impl(&mut err, &v.0, ident, self_ty)\n             {\n                 override_error_code = Some(ident.name);"}, {"sha": "6d23dc4f471f7392910365a46422f921d111398b", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/trait_impl_difference.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/79f178b76ea9d5c6182f67413f62dd86b0e38508/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ftrait_impl_difference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79f178b76ea9d5c6182f67413f62dd86b0e38508/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ftrait_impl_difference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ftrait_impl_difference.rs?ref=79f178b76ea9d5c6182f67413f62dd86b0e38508", "patch": "@@ -7,7 +7,7 @@ use crate::traits::ObligationCauseCode::CompareImplMethodObligation;\n use rustc_errors::ErrorGuaranteed;\n use rustc_hir as hir;\n use rustc_hir::def::Res;\n-use rustc_hir::def_id::DefId;\n+use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_hir::intravisit::Visitor;\n use rustc_middle::hir::nested_filter;\n use rustc_middle::ty::print::RegionHighlightMode;\n@@ -51,7 +51,7 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n         {\n             let guar = self.emit_associated_type_err(\n                 span,\n-                self.infcx.tcx.item_name(impl_item_def_id),\n+                self.infcx.tcx.item_name(impl_item_def_id.to_def_id()),\n                 impl_item_def_id,\n                 trait_item_def_id,\n             );\n@@ -155,7 +155,7 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n         &self,\n         span: Span,\n         item_name: Symbol,\n-        impl_item_def_id: DefId,\n+        impl_item_def_id: LocalDefId,\n         trait_item_def_id: DefId,\n     ) -> ErrorGuaranteed {\n         let impl_sp = self.tcx().def_span(impl_item_def_id);"}, {"sha": "5dcac7f56cc41dfe630553c7c417d62e35357d39", "filename": "compiler/rustc_infer/src/infer/error_reporting/note.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/79f178b76ea9d5c6182f67413f62dd86b0e38508/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79f178b76ea9d5c6182f67413f62dd86b0e38508/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote.rs?ref=79f178b76ea9d5c6182f67413f62dd86b0e38508", "patch": "@@ -348,7 +348,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 let mut err = self.report_concrete_failure(*parent, sub, sup);\n \n                 let trait_item_span = self.tcx.def_span(trait_item_def_id);\n-                let item_name = self.tcx.item_name(impl_item_def_id);\n+                let item_name = self.tcx.item_name(impl_item_def_id.to_def_id());\n                 err.span_label(\n                     trait_item_span,\n                     format!(\"definition of `{}` from trait\", item_name),\n@@ -370,7 +370,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     let where_clause_span = self\n                         .tcx\n                         .hir()\n-                        .get_generics(impl_item_def_id.expect_local())\n+                        .get_generics(impl_item_def_id)\n                         .unwrap()\n                         .where_clause\n                         .tail_span_for_suggestion();"}, {"sha": "0a11a81c2942511e461dbd620a5c1da14f09855d", "filename": "compiler/rustc_infer/src/infer/freshen.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/79f178b76ea9d5c6182f67413f62dd86b0e38508/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffreshen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79f178b76ea9d5c6182f67413f62dd86b0e38508/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffreshen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffreshen.rs?ref=79f178b76ea9d5c6182f67413f62dd86b0e38508", "patch": "@@ -30,17 +30,13 @@\n //! solving a set of constraints. In contrast, the type inferencer assigns a value to each type\n //! variable only once, and it does so as soon as it can, so it is reasonable to ask what the type\n //! inferencer knows \"so far\".\n-\n+use super::InferCtxt;\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_middle::infer::unify_key::ToType;\n use rustc_middle::ty::fold::TypeFolder;\n use rustc_middle::ty::{self, Ty, TyCtxt, TypeFoldable};\n-\n-use rustc_data_structures::fx::FxHashMap;\n-\n use std::collections::hash_map::Entry;\n \n-use super::unify_key::ToType;\n-use super::InferCtxt;\n-\n pub struct TypeFreshener<'a, 'tcx> {\n     infcx: &'a InferCtxt<'a, 'tcx>,\n     ty_freshen_count: u32,"}, {"sha": "2524bd78355a118c3701d1dedc371df28db90d1b", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/79f178b76ea9d5c6182f67413f62dd86b0e38508/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79f178b76ea9d5c6182f67413f62dd86b0e38508/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=79f178b76ea9d5c6182f67413f62dd86b0e38508", "patch": "@@ -70,8 +70,6 @@ mod sub;\n pub mod type_variable;\n mod undo_log;\n \n-pub use rustc_middle::infer::unify_key;\n-\n #[must_use]\n #[derive(Debug)]\n pub struct InferOk<'tcx, T> {\n@@ -425,16 +423,20 @@ pub enum SubregionOrigin<'tcx> {\n \n     /// Comparing the signature and requirements of an impl method against\n     /// the containing trait.\n-    CompareImplMethodObligation { span: Span, impl_item_def_id: DefId, trait_item_def_id: DefId },\n+    CompareImplMethodObligation {\n+        span: Span,\n+        impl_item_def_id: LocalDefId,\n+        trait_item_def_id: DefId,\n+    },\n \n     /// Comparing the signature and requirements of an impl associated type\n     /// against the containing trait\n-    CompareImplTypeObligation { span: Span, impl_item_def_id: DefId, trait_item_def_id: DefId },\n+    CompareImplTypeObligation { span: Span, impl_item_def_id: LocalDefId, trait_item_def_id: DefId },\n \n     /// Checking that the bounds of a trait's associated type hold for a given impl\n     CheckAssociatedTypeBounds {\n         parent: Box<SubregionOrigin<'tcx>>,\n-        impl_item_def_id: DefId,\n+        impl_item_def_id: LocalDefId,\n         trait_item_def_id: DefId,\n     },\n }\n@@ -558,9 +560,9 @@ impl<'tcx> fmt::Display for FixupError<'tcx> {\n     }\n }\n \n-/// Helper type of a temporary returned by `tcx.infer_ctxt()`.\n-/// Necessary because we can't write the following bound:\n-/// `F: for<'b, 'tcx> where 'tcx FnOnce(InferCtxt<'b, 'tcx>)`.\n+/// A temporary returned by `tcx.infer_ctxt()`. This is necessary\n+/// for multiple `InferCtxt` to share the same `in_progress_typeck_results`\n+/// without using `Rc` or something similar.\n pub struct InferCtxtBuilder<'tcx> {\n     tcx: TyCtxt<'tcx>,\n     fresh_typeck_results: Option<RefCell<ty::TypeckResults<'tcx>>>,"}, {"sha": "25b11e31d57d4737d32cff0da17e153c2a22f3a0", "filename": "compiler/rustc_infer/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/79f178b76ea9d5c6182f67413f62dd86b0e38508/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79f178b76ea9d5c6182f67413f62dd86b0e38508/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=79f178b76ea9d5c6182f67413f62dd86b0e38508", "patch": "@@ -4,7 +4,7 @@ use crate::infer::InferCtxt;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::{struct_span_err, DiagnosticBuilder, ErrorGuaranteed};\n use rustc_hir as hir;\n-use rustc_hir::def_id::DefId;\n+use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_middle::ty::TyCtxt;\n use rustc_span::{MultiSpan, Span};\n use std::fmt;\n@@ -14,7 +14,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     pub fn report_extra_impl_obligation(\n         &self,\n         error_span: Span,\n-        impl_item_def_id: DefId,\n+        impl_item_def_id: LocalDefId,\n         trait_item_def_id: DefId,\n         requirement: &dyn fmt::Display,\n     ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n@@ -25,7 +25,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n         if let Some(trait_item_span) = self.tcx.hir().span_if_local(trait_item_def_id) {\n             let span = self.tcx.sess.source_map().guess_head_span(trait_item_span);\n-            let item_name = self.tcx.item_name(impl_item_def_id);\n+            let item_name = self.tcx.item_name(impl_item_def_id.to_def_id());\n             err.span_label(span, format!(\"definition of `{}` from trait\", item_name));\n         }\n "}, {"sha": "d43c661dda6fa2342b0efc673718e1484683f2bd", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 16, "deletions": 7, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/79f178b76ea9d5c6182f67413f62dd86b0e38508/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79f178b76ea9d5c6182f67413f62dd86b0e38508/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=79f178b76ea9d5c6182f67413f62dd86b0e38508", "patch": "@@ -2548,7 +2548,7 @@ impl<'tcx> LateLintPass<'tcx> for InvalidValue {\n         /// Return `Some` only if we are sure this type does *not*\n         /// allow zero initialization.\n         fn ty_find_init_error<'tcx>(\n-            tcx: TyCtxt<'tcx>,\n+            cx: &LateContext<'tcx>,\n             ty: Ty<'tcx>,\n             init: InitKind,\n         ) -> Option<InitError> {\n@@ -2575,7 +2575,7 @@ impl<'tcx> LateLintPass<'tcx> for InvalidValue {\n                 Adt(adt_def, substs) if !adt_def.is_union() => {\n                     // First check if this ADT has a layout attribute (like `NonNull` and friends).\n                     use std::ops::Bound;\n-                    match tcx.layout_scalar_valid_range(adt_def.did()) {\n+                    match cx.tcx.layout_scalar_valid_range(adt_def.did()) {\n                         // We exploit here that `layout_scalar_valid_range` will never\n                         // return `Bound::Excluded`.  (And we have tests checking that we\n                         // handle the attribute correctly.)\n@@ -2603,12 +2603,12 @@ impl<'tcx> LateLintPass<'tcx> for InvalidValue {\n                             // Proceed recursively, check all fields.\n                             let variant = &adt_def.variant(VariantIdx::from_u32(0));\n                             variant.fields.iter().find_map(|field| {\n-                                ty_find_init_error(tcx, field.ty(tcx, substs), init).map(\n+                                ty_find_init_error(cx, field.ty(cx.tcx, substs), init).map(\n                                     |(mut msg, span)| {\n                                         if span.is_none() {\n                                             // Point to this field, should be helpful for figuring\n                                             // out where the source of the error is.\n-                                            let span = tcx.def_span(field.did);\n+                                            let span = cx.tcx.def_span(field.did);\n                                             write!(\n                                                 &mut msg,\n                                                 \" (in this {} field)\",\n@@ -2627,7 +2627,7 @@ impl<'tcx> LateLintPass<'tcx> for InvalidValue {\n                         // Multi-variant enum.\n                         _ => {\n                             if init == InitKind::Uninit && is_multi_variant(*adt_def) {\n-                                let span = tcx.def_span(adt_def.did());\n+                                let span = cx.tcx.def_span(adt_def.did());\n                                 Some((\n                                     \"enums have to be initialized to a variant\".to_string(),\n                                     Some(span),\n@@ -2642,7 +2642,16 @@ impl<'tcx> LateLintPass<'tcx> for InvalidValue {\n                 }\n                 Tuple(..) => {\n                     // Proceed recursively, check all fields.\n-                    ty.tuple_fields().iter().find_map(|field| ty_find_init_error(tcx, field, init))\n+                    ty.tuple_fields().iter().find_map(|field| ty_find_init_error(cx, field, init))\n+                }\n+                Array(ty, len) => {\n+                    if matches!(len.try_eval_usize(cx.tcx, cx.param_env), Some(v) if v > 0) {\n+                        // Array length known at array non-empty -- recurse.\n+                        ty_find_init_error(cx, *ty, init)\n+                    } else {\n+                        // Empty array or size unknown.\n+                        None\n+                    }\n                 }\n                 // Conservative fallback.\n                 _ => None,\n@@ -2655,7 +2664,7 @@ impl<'tcx> LateLintPass<'tcx> for InvalidValue {\n             // We are extremely conservative with what we warn about.\n             let conjured_ty = cx.typeck_results().expr_ty(expr);\n             if let Some((msg, span)) =\n-                with_no_trimmed_paths!(ty_find_init_error(cx.tcx, conjured_ty, init))\n+                with_no_trimmed_paths!(ty_find_init_error(cx, conjured_ty, init))\n             {\n                 cx.struct_span_lint(INVALID_VALUE, expr.span, |lint| {\n                     let mut err = lint.build(&format!("}, {"sha": "f2627885d030dc5db0eaf680042dcaf5f8c97bc1", "filename": "compiler/rustc_middle/src/infer/unify_key.rs", "status": "modified", "additions": 2, "deletions": 27, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/79f178b76ea9d5c6182f67413f62dd86b0e38508/compiler%2Frustc_middle%2Fsrc%2Finfer%2Funify_key.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79f178b76ea9d5c6182f67413f62dd86b0e38508/compiler%2Frustc_middle%2Fsrc%2Finfer%2Funify_key.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Finfer%2Funify_key.rs?ref=79f178b76ea9d5c6182f67413f62dd86b0e38508", "patch": "@@ -1,13 +1,8 @@\n-use crate::ty::{self, InferConst, Ty, TyCtxt};\n-use rustc_data_structures::snapshot_vec;\n-use rustc_data_structures::undo_log::UndoLogs;\n-use rustc_data_structures::unify::{\n-    self, EqUnifyValue, InPlace, NoError, UnificationTable, UnifyKey, UnifyValue,\n-};\n+use crate::ty::{self, Ty, TyCtxt};\n+use rustc_data_structures::unify::{NoError, UnifyKey, UnifyValue};\n use rustc_span::def_id::DefId;\n use rustc_span::symbol::Symbol;\n use rustc_span::Span;\n-\n use std::cmp;\n use std::marker::PhantomData;\n \n@@ -165,23 +160,3 @@ impl<'tcx> UnifyValue for ConstVarValue<'tcx> {\n         })\n     }\n }\n-\n-impl<'tcx> EqUnifyValue for ty::Const<'tcx> {}\n-\n-pub fn replace_if_possible<'tcx, V, L>(\n-    table: &mut UnificationTable<InPlace<ty::ConstVid<'tcx>, V, L>>,\n-    c: ty::Const<'tcx>,\n-) -> ty::Const<'tcx>\n-where\n-    V: snapshot_vec::VecLike<unify::Delegate<ty::ConstVid<'tcx>>>,\n-    L: UndoLogs<snapshot_vec::UndoLog<unify::Delegate<ty::ConstVid<'tcx>>>>,\n-{\n-    if let ty::ConstKind::Infer(InferConst::Var(vid)) = c.val() {\n-        match table.probe_value(vid).val.known() {\n-            Some(c) => c,\n-            None => c,\n-        }\n-    } else {\n-        c\n-    }\n-}"}, {"sha": "7c3d08b26bf54e38d46cf769f9306bdd793329a5", "filename": "compiler/rustc_middle/src/traits/mod.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/79f178b76ea9d5c6182f67413f62dd86b0e38508/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79f178b76ea9d5c6182f67413f62dd86b0e38508/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs?ref=79f178b76ea9d5c6182f67413f62dd86b0e38508", "patch": "@@ -276,24 +276,23 @@ pub enum ObligationCauseCode<'tcx> {\n \n     /// Error derived when matching traits/impls; see ObligationCause for more details\n     CompareImplMethodObligation {\n-        impl_item_def_id: DefId,\n+        impl_item_def_id: LocalDefId,\n         trait_item_def_id: DefId,\n     },\n \n     /// Error derived when matching traits/impls; see ObligationCause for more details\n     CompareImplTypeObligation {\n-        impl_item_def_id: DefId,\n+        impl_item_def_id: LocalDefId,\n         trait_item_def_id: DefId,\n     },\n \n     /// Checking that the bounds of a trait's associated type hold for a given impl\n     CheckAssociatedTypeBounds {\n-        impl_item_def_id: DefId,\n+        impl_item_def_id: LocalDefId,\n         trait_item_def_id: DefId,\n     },\n \n-    /// Checking that this expression can be assigned where it needs to be\n-    // FIXME(eddyb) #11161 is the original Expr required?\n+    /// Checking that this expression can be assigned to its target.\n     ExprAssignable,\n \n     /// Computing common supertype in the arms of a match expression"}, {"sha": "c414d7c031c0471b34b3ca68b217ec5303e25ee5", "filename": "compiler/rustc_passes/src/lib_features.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/79f178b76ea9d5c6182f67413f62dd86b0e38508/compiler%2Frustc_passes%2Fsrc%2Flib_features.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79f178b76ea9d5c6182f67413f62dd86b0e38508/compiler%2Frustc_passes%2Fsrc%2Flib_features.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Flib_features.rs?ref=79f178b76ea9d5c6182f67413f62dd86b0e38508", "patch": "@@ -29,10 +29,11 @@ impl<'tcx> LibFeatureCollector<'tcx> {\n     }\n \n     fn extract(&self, attr: &Attribute) -> Option<(Symbol, Option<Symbol>, Span)> {\n-        let stab_attrs = [sym::stable, sym::unstable, sym::rustc_const_unstable];\n+        let stab_attrs =\n+            [sym::stable, sym::unstable, sym::rustc_const_stable, sym::rustc_const_unstable];\n \n-        // Find a stability attribute (i.e., `#[stable (..)]`, `#[unstable (..)]`,\n-        // `#[rustc_const_unstable (..)]`).\n+        // Find a stability attribute: one of #[stable(\u2026)], #[unstable(\u2026)],\n+        // #[rustc_const_stable(\u2026)], or #[rustc_const_unstable(\u2026)].\n         if let Some(stab_attr) = stab_attrs.iter().find(|stab_attr| attr.has_name(**stab_attr)) {\n             let meta_kind = attr.meta_kind();\n             if let Some(MetaItemKind::List(ref metas)) = meta_kind {\n@@ -52,7 +53,9 @@ impl<'tcx> LibFeatureCollector<'tcx> {\n                     // This additional check for stability is to make sure we\n                     // don't emit additional, irrelevant errors for malformed\n                     // attributes.\n-                    if *stab_attr != sym::stable || since.is_some() {\n+                    let is_unstable =\n+                        matches!(*stab_attr, sym::unstable | sym::rustc_const_unstable);\n+                    if since.is_some() || is_unstable {\n                         return Some((feature, since, attr.span));\n                     }\n                 }"}, {"sha": "02f6b4060599ea161ace7d81617fa32dee3e3b18", "filename": "compiler/rustc_passes/src/naked_functions.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/79f178b76ea9d5c6182f67413f62dd86b0e38508/compiler%2Frustc_passes%2Fsrc%2Fnaked_functions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79f178b76ea9d5c6182f67413f62dd86b0e38508/compiler%2Frustc_passes%2Fsrc%2Fnaked_functions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fnaked_functions.rs?ref=79f178b76ea9d5c6182f67413f62dd86b0e38508", "patch": "@@ -1,7 +1,7 @@\n //! Checks validity of naked functions.\n \n use rustc_ast::{Attribute, InlineAsmOptions};\n-use rustc_errors::struct_span_err;\n+use rustc_errors::{struct_span_err, Applicability};\n use rustc_hir as hir;\n use rustc_hir::def_id::LocalDefId;\n use rustc_hir::intravisit::{FnKind, Visitor};\n@@ -274,12 +274,25 @@ impl<'tcx> CheckInlineAssembly<'tcx> {\n         }\n \n         if !asm.options.contains(InlineAsmOptions::NORETURN) {\n+            let last_span = asm\n+                .operands\n+                .last()\n+                .map_or_else(|| asm.template_strs.last().unwrap().2, |op| op.1)\n+                .shrink_to_hi();\n+\n             struct_span_err!(\n                 self.tcx.sess,\n                 span,\n                 E0787,\n                 \"asm in naked functions must use `noreturn` option\"\n             )\n+            .span_suggestion(\n+                last_span,\n+                \"consider specifying that the asm block is responsible \\\n+                for returning from the function\",\n+                String::from(\", options(noreturn)\"),\n+                Applicability::MachineApplicable,\n+            )\n             .emit();\n         }\n     }"}, {"sha": "5b30dc1d3dab6005f5db4af2f1856ff17b04093c", "filename": "compiler/rustc_target/src/spec/i686_pc_windows_msvc.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/79f178b76ea9d5c6182f67413f62dd86b0e38508/compiler%2Frustc_target%2Fsrc%2Fspec%2Fi686_pc_windows_msvc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79f178b76ea9d5c6182f67413f62dd86b0e38508/compiler%2Frustc_target%2Fsrc%2Fspec%2Fi686_pc_windows_msvc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fi686_pc_windows_msvc.rs?ref=79f178b76ea9d5c6182f67413f62dd86b0e38508", "patch": "@@ -19,6 +19,8 @@ pub fn target() -> Target {\n         .entry(LinkerFlavor::Lld(LldFlavor::Link))\n         .or_default()\n         .extend(pre_link_args_msvc);\n+    // Workaround for #95429\n+    base.has_thread_local = false;\n \n     Target {\n         llvm_target: \"i686-pc-windows-msvc\".to_string(),"}, {"sha": "216aa89dd1f28349ea3b3b645526ee6c0f2c88f4", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/79f178b76ea9d5c6182f67413f62dd86b0e38508/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79f178b76ea9d5c6182f67413f62dd86b0e38508/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=79f178b76ea9d5c6182f67413f62dd86b0e38508", "patch": "@@ -1913,15 +1913,15 @@ impl<'a, 'tcx> InferCtxtPrivExt<'a, 'tcx> for InferCtxt<'a, 'tcx> {\n                     self.suggest_fully_qualified_path(&mut err, def_id, span, trait_ref.def_id());\n                 } else if let (\n                     Ok(ref snippet),\n-                    ObligationCauseCode::BindingObligation(ref def_id, _),\n+                    &ObligationCauseCode::BindingObligation(def_id, _),\n                 ) =\n                     (self.tcx.sess.source_map().span_to_snippet(span), obligation.cause.code())\n                 {\n-                    let generics = self.tcx.generics_of(*def_id);\n+                    let generics = self.tcx.generics_of(def_id);\n                     if generics.params.iter().any(|p| p.name != kw::SelfUpper)\n                         && !snippet.ends_with('>')\n                         && !generics.has_impl_trait()\n-                        && !self.tcx.fn_trait_kind_from_lang_item(*def_id).is_some()\n+                        && !self.tcx.fn_trait_kind_from_lang_item(def_id).is_some()\n                     {\n                         // FIXME: To avoid spurious suggestions in functions where type arguments\n                         // where already supplied, we check the snippet to make sure it doesn't\n@@ -2223,6 +2223,7 @@ impl<'a, 'tcx> InferCtxtPrivExt<'a, 'tcx> for InferCtxt<'a, 'tcx> {\n             \"suggest_unsized_bound_if_applicable: pred={:?} item_def_id={:?} span={:?}\",\n             pred, item_def_id, span\n         );\n+\n         let (Some(node), true) = (\n             self.tcx.hir().get_if_local(item_def_id),\n             Some(pred.def_id()) == self.tcx.lang_items().sized_trait(),"}, {"sha": "b49a5f6578f75bdf670e0a012b72f5f574bc4b81", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/79f178b76ea9d5c6182f67413f62dd86b0e38508/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79f178b76ea9d5c6182f67413f62dd86b0e38508/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=79f178b76ea9d5c6182f67413f62dd86b0e38508", "patch": "@@ -128,7 +128,7 @@ pub trait InferCtxtExt<'tcx> {\n     fn suggest_fully_qualified_path(\n         &self,\n         err: &mut Diagnostic,\n-        def_id: DefId,\n+        item_def_id: DefId,\n         span: Span,\n         trait_ref: DefId,\n     );\n@@ -1317,16 +1317,16 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n     fn suggest_fully_qualified_path(\n         &self,\n         err: &mut Diagnostic,\n-        def_id: DefId,\n+        item_def_id: DefId,\n         span: Span,\n         trait_ref: DefId,\n     ) {\n-        if let Some(assoc_item) = self.tcx.opt_associated_item(def_id) {\n+        if let Some(assoc_item) = self.tcx.opt_associated_item(item_def_id) {\n             if let ty::AssocKind::Const | ty::AssocKind::Type = assoc_item.kind {\n                 err.note(&format!(\n                     \"{}s cannot be accessed directly on a `trait`, they can only be \\\n                         accessed through a specific `impl`\",\n-                    assoc_item.kind.as_def_kind().descr(def_id)\n+                    assoc_item.kind.as_def_kind().descr(item_def_id)\n                 ));\n                 err.span_suggestion(\n                     span,"}, {"sha": "0bd5e018f4a3851bca1685f7524a0b6b2e240d88", "filename": "compiler/rustc_typeck/src/check/compare_method.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/79f178b76ea9d5c6182f67413f62dd86b0e38508/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79f178b76ea9d5c6182f67413f62dd86b0e38508/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs?ref=79f178b76ea9d5c6182f67413f62dd86b0e38508", "patch": "@@ -28,7 +28,6 @@ use super::{potentially_plural_count, FnCtxt, Inherited};\n /// - `impl_m_span`: span to use for reporting errors\n /// - `trait_m`: the method in the trait\n /// - `impl_trait_ref`: the TraitRef corresponding to the trait implementation\n-\n crate fn compare_impl_method<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     impl_m: &ty::AssocItem,\n@@ -88,7 +87,7 @@ fn compare_predicate_entailment<'tcx>(\n         impl_m_span,\n         impl_m_hir_id,\n         ObligationCauseCode::CompareImplMethodObligation {\n-            impl_item_def_id: impl_m.def_id,\n+            impl_item_def_id: impl_m.def_id.expect_local(),\n             trait_item_def_id: trait_m.def_id,\n         },\n     );\n@@ -231,7 +230,7 @@ fn compare_predicate_entailment<'tcx>(\n                 span,\n                 impl_m_hir_id,\n                 ObligationCauseCode::CompareImplMethodObligation {\n-                    impl_item_def_id: impl_m.def_id,\n+                    impl_item_def_id: impl_m.def_id.expect_local(),\n                     trait_item_def_id: trait_m.def_id,\n                 },\n             );\n@@ -1154,7 +1153,7 @@ fn compare_type_predicate_entailment<'tcx>(\n         impl_ty_span,\n         impl_ty_hir_id,\n         ObligationCauseCode::CompareImplTypeObligation {\n-            impl_item_def_id: impl_ty.def_id,\n+            impl_item_def_id: impl_ty.def_id.expect_local(),\n             trait_item_def_id: trait_ty.def_id,\n         },\n     );\n@@ -1383,7 +1382,7 @@ pub fn check_type_bounds<'tcx>(\n             impl_ty_span,\n             impl_ty_hir_id,\n             ObligationCauseCode::CheckAssociatedTypeBounds {\n-                impl_item_def_id: impl_ty.def_id,\n+                impl_item_def_id: impl_ty.def_id.expect_local(),\n                 trait_item_def_id: trait_ty.def_id,\n             },\n         );"}, {"sha": "55a5eb966c2221b27f8188250a14f5009f9e0f68", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/79f178b76ea9d5c6182f67413f62dd86b0e38508/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79f178b76ea9d5c6182f67413f62dd86b0e38508/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fmod.rs?ref=79f178b76ea9d5c6182f67413f62dd86b0e38508", "patch": "@@ -14,7 +14,7 @@ use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_infer::infer;\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n-use rustc_infer::infer::unify_key::{ConstVariableOrigin, ConstVariableOriginKind};\n+use rustc_middle::infer::unify_key::{ConstVariableOrigin, ConstVariableOriginKind};\n use rustc_middle::ty::fold::TypeFoldable;\n use rustc_middle::ty::subst::GenericArgKind;\n use rustc_middle::ty::{self, Const, Ty, TyCtxt};"}, {"sha": "62ca728868b45595cf57a788b65882982a8c0c44", "filename": "compiler/rustc_typeck/src/check/inherited.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/79f178b76ea9d5c6182f67413f62dd86b0e38508/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Finherited.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79f178b76ea9d5c6182f67413f62dd86b0e38508/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Finherited.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Finherited.rs?ref=79f178b76ea9d5c6182f67413f62dd86b0e38508", "patch": "@@ -68,9 +68,9 @@ impl<'a, 'tcx> Deref for Inherited<'a, 'tcx> {\n     }\n }\n \n-/// Helper type of a temporary returned by `Inherited::build(...)`.\n-/// Necessary because we can't write the following bound:\n-/// `F: for<'b, 'tcx> where 'tcx FnOnce(Inherited<'b, 'tcx>)`.\n+/// A temporary returned by `Inherited::build(...)`. This is necessary\n+/// for multiple `InferCtxt` to share the same `in_progress_typeck_results`\n+/// without using `Rc` or something similar.\n pub struct InheritedBuilder<'tcx> {\n     infcx: infer::InferCtxtBuilder<'tcx>,\n     def_id: LocalDefId,"}, {"sha": "bc0fa9165561da32e12488fae8967c8eb25e2216", "filename": "compiler/rustc_typeck/src/check/method/confirm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/79f178b76ea9d5c6182f67413f62dd86b0e38508/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79f178b76ea9d5c6182f67413f62dd86b0e38508/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fconfirm.rs?ref=79f178b76ea9d5c6182f67413f62dd86b0e38508", "patch": "@@ -2,9 +2,9 @@ use super::{probe, MethodCallee};\n \n use crate::astconv::{AstConv, CreateSubstsForGenericArgsCtxt, IsMethodCall};\n use crate::check::{callee, FnCtxt};\n-use crate::hir::def_id::DefId;\n-use crate::hir::GenericArg;\n use rustc_hir as hir;\n+use rustc_hir::def_id::DefId;\n+use rustc_hir::GenericArg;\n use rustc_infer::infer::{self, InferOk};\n use rustc_middle::traits::{ObligationCauseCode, UnifyReceiverContext};\n use rustc_middle::ty::adjustment::{Adjust, Adjustment, PointerCast};"}, {"sha": "6edcc12bcf5a640c964673c834fccf63116b65e2", "filename": "compiler/rustc_typeck/src/check/method/probe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/79f178b76ea9d5c6182f67413f62dd86b0e38508/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79f178b76ea9d5c6182f67413f62dd86b0e38508/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs?ref=79f178b76ea9d5c6182f67413f62dd86b0e38508", "patch": "@@ -15,8 +15,8 @@ use rustc_hir::def::Namespace;\n use rustc_infer::infer::canonical::OriginalQueryValues;\n use rustc_infer::infer::canonical::{Canonical, QueryResponse};\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n-use rustc_infer::infer::unify_key::{ConstVariableOrigin, ConstVariableOriginKind};\n use rustc_infer::infer::{self, InferOk, TyCtxtInferExt};\n+use rustc_middle::infer::unify_key::{ConstVariableOrigin, ConstVariableOriginKind};\n use rustc_middle::middle::stability;\n use rustc_middle::ty::fast_reject::{simplify_type, TreatParams};\n use rustc_middle::ty::subst::{InternalSubsts, Subst, SubstsRef};"}, {"sha": "9b1767c7835555d7b7b4c65ee7e49970f5ac8765", "filename": "compiler/rustc_typeck/src/check/wfcheck.rs", "status": "modified", "additions": 16, "deletions": 13, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/79f178b76ea9d5c6182f67413f62dd86b0e38508/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79f178b76ea9d5c6182f67413f62dd86b0e38508/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=79f178b76ea9d5c6182f67413f62dd86b0e38508", "patch": "@@ -940,7 +940,7 @@ fn check_associated_item(\n                     item.ident(fcx.tcx).span,\n                     sig,\n                     hir_sig.decl,\n-                    item.def_id,\n+                    item.def_id.expect_local(),\n                     &mut implied_bounds,\n                 );\n                 check_method_receiver(fcx, hir_sig, item, self_ty);\n@@ -1068,7 +1068,7 @@ fn check_type_defn<'tcx, F>(\n             }\n         }\n \n-        check_where_clauses(fcx, item.span, item.def_id.to_def_id(), None);\n+        check_where_clauses(fcx, item.span, item.def_id, None);\n \n         // No implied bounds in a struct definition.\n         FxHashSet::default()\n@@ -1096,7 +1096,7 @@ fn check_trait(tcx: TyCtxt<'_>, item: &hir::Item<'_>) {\n \n     // FIXME: this shouldn't use an `FnCtxt` at all.\n     for_item(tcx, item).with_fcx(|fcx| {\n-        check_where_clauses(fcx, item.span, item.def_id.to_def_id(), None);\n+        check_where_clauses(fcx, item.span, item.def_id, None);\n \n         FxHashSet::default()\n     });\n@@ -1144,7 +1144,7 @@ fn check_item_fn(\n     for_id(tcx, def_id, span).with_fcx(|fcx| {\n         let sig = tcx.fn_sig(def_id);\n         let mut implied_bounds = FxHashSet::default();\n-        check_fn_or_method(fcx, ident.span, sig, decl, def_id.to_def_id(), &mut implied_bounds);\n+        check_fn_or_method(fcx, ident.span, sig, decl, def_id, &mut implied_bounds);\n         implied_bounds\n     })\n }\n@@ -1238,7 +1238,7 @@ fn check_impl<'tcx>(\n             }\n         }\n \n-        check_where_clauses(fcx, item.span, item.def_id.to_def_id(), None);\n+        check_where_clauses(fcx, item.span, item.def_id, None);\n \n         fcx.impl_implied_bounds(item.def_id.to_def_id(), item.span)\n     });\n@@ -1249,7 +1249,7 @@ fn check_impl<'tcx>(\n fn check_where_clauses<'tcx, 'fcx>(\n     fcx: &FnCtxt<'fcx, 'tcx>,\n     span: Span,\n-    def_id: DefId,\n+    def_id: LocalDefId,\n     return_ty: Option<(Ty<'tcx>, Span)>,\n ) {\n     let tcx = fcx.tcx;\n@@ -1317,7 +1317,7 @@ fn check_where_clauses<'tcx, 'fcx>(\n     // For more examples see tests `defaults-well-formedness.rs` and `type-check-defaults.rs`.\n     //\n     // First we build the defaulted substitution.\n-    let substs = InternalSubsts::for_item(tcx, def_id, |param, _| {\n+    let substs = InternalSubsts::for_item(tcx, def_id.to_def_id(), |param, _| {\n         match param.kind {\n             GenericParamDefKind::Lifetime => {\n                 // All regions are identity.\n@@ -1411,8 +1411,11 @@ fn check_where_clauses<'tcx, 'fcx>(\n             // below: there, we are not trying to prove those predicates\n             // to be *true* but merely *well-formed*.\n             let pred = fcx.normalize_associated_types_in(sp, pred);\n-            let cause =\n-                traits::ObligationCause::new(sp, fcx.body_id, traits::ItemObligation(def_id));\n+            let cause = traits::ObligationCause::new(\n+                sp,\n+                fcx.body_id,\n+                traits::ItemObligation(def_id.to_def_id()),\n+            );\n             traits::Obligation::new(cause, fcx.param_env, pred)\n         });\n \n@@ -1445,10 +1448,10 @@ fn check_fn_or_method<'fcx, 'tcx>(\n     span: Span,\n     sig: ty::PolyFnSig<'tcx>,\n     hir_decl: &hir::FnDecl<'_>,\n-    def_id: DefId,\n+    def_id: LocalDefId,\n     implied_bounds: &mut FxHashSet<Ty<'tcx>>,\n ) {\n-    let sig = fcx.tcx.liberate_late_bound_regions(def_id, sig);\n+    let sig = fcx.tcx.liberate_late_bound_regions(def_id.to_def_id(), sig);\n \n     // Normalize the input and output types one at a time, using a different\n     // `WellFormedLoc` for each. We cannot call `normalize_associated_types`\n@@ -1462,7 +1465,7 @@ fn check_fn_or_method<'fcx, 'tcx>(\n                 span,\n                 ty,\n                 WellFormedLoc::Param {\n-                    function: def_id.expect_local(),\n+                    function: def_id,\n                     // Note that the `param_idx` of the output type is\n                     // one greater than the index of the last input type.\n                     param_idx: i.try_into().unwrap(),\n@@ -1485,7 +1488,7 @@ fn check_fn_or_method<'fcx, 'tcx>(\n             input_ty.into(),\n             ty.span,\n             ObligationCauseCode::WellFormed(Some(WellFormedLoc::Param {\n-                function: def_id.expect_local(),\n+                function: def_id,\n                 param_idx: i.try_into().unwrap(),\n             })),\n         );"}, {"sha": "db6898c1308a20b9ca71e5fb5efb35bf2071c6fe", "filename": "library/core/src/alloc/layout.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/79f178b76ea9d5c6182f67413f62dd86b0e38508/library%2Fcore%2Fsrc%2Falloc%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79f178b76ea9d5c6182f67413f62dd86b0e38508/library%2Fcore%2Fsrc%2Falloc%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Falloc%2Flayout.rs?ref=79f178b76ea9d5c6182f67413f62dd86b0e38508", "patch": "@@ -56,7 +56,7 @@ impl Layout {\n     ///    must not overflow (i.e., the rounded value must be less than\n     ///    or equal to `usize::MAX`).\n     #[stable(feature = \"alloc_layout\", since = \"1.28.0\")]\n-    #[rustc_const_stable(feature = \"const_alloc_layout\", since = \"1.50.0\")]\n+    #[rustc_const_stable(feature = \"const_alloc_layout_size_align\", since = \"1.50.0\")]\n     #[inline]\n     pub const fn from_size_align(size: usize, align: usize) -> Result<Self, LayoutError> {\n         if !align.is_power_of_two() {\n@@ -93,7 +93,7 @@ impl Layout {\n     /// This function is unsafe as it does not verify the preconditions from\n     /// [`Layout::from_size_align`].\n     #[stable(feature = \"alloc_layout\", since = \"1.28.0\")]\n-    #[rustc_const_stable(feature = \"alloc_layout\", since = \"1.36.0\")]\n+    #[rustc_const_stable(feature = \"const_alloc_layout_unchecked\", since = \"1.36.0\")]\n     #[must_use]\n     #[inline]\n     pub const unsafe fn from_size_align_unchecked(size: usize, align: usize) -> Self {\n@@ -103,7 +103,7 @@ impl Layout {\n \n     /// The minimum size in bytes for a memory block of this layout.\n     #[stable(feature = \"alloc_layout\", since = \"1.28.0\")]\n-    #[rustc_const_stable(feature = \"const_alloc_layout\", since = \"1.50.0\")]\n+    #[rustc_const_stable(feature = \"const_alloc_layout_size_align\", since = \"1.50.0\")]\n     #[must_use]\n     #[inline]\n     pub const fn size(&self) -> usize {\n@@ -112,7 +112,7 @@ impl Layout {\n \n     /// The minimum byte alignment for a memory block of this layout.\n     #[stable(feature = \"alloc_layout\", since = \"1.28.0\")]\n-    #[rustc_const_stable(feature = \"const_alloc_layout\", since = \"1.50.0\")]\n+    #[rustc_const_stable(feature = \"const_alloc_layout_size_align\", since = \"1.50.0\")]\n     #[must_use = \"this returns the minimum alignment, \\\n                   without modifying the layout\"]\n     #[inline]"}, {"sha": "3195205b1b6776a087b07be6dddc396619a8625e", "filename": "library/core/src/char/methods.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/79f178b76ea9d5c6182f67413f62dd86b0e38508/library%2Fcore%2Fsrc%2Fchar%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79f178b76ea9d5c6182f67413f62dd86b0e38508/library%2Fcore%2Fsrc%2Fchar%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fchar%2Fmethods.rs?ref=79f178b76ea9d5c6182f67413f62dd86b0e38508", "patch": "@@ -1092,7 +1092,7 @@ impl char {\n     /// ```\n     #[must_use]\n     #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")]\n-    #[rustc_const_stable(feature = \"const_ascii_methods_on_intrinsics\", since = \"1.32.0\")]\n+    #[rustc_const_stable(feature = \"const_char_is_ascii\", since = \"1.32.0\")]\n     #[inline]\n     pub const fn is_ascii(&self) -> bool {\n         *self as u32 <= 0x7F"}, {"sha": "474a632773fb810f89a3b0b802a276f831679105", "filename": "library/core/src/intrinsics.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/79f178b76ea9d5c6182f67413f62dd86b0e38508/library%2Fcore%2Fsrc%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79f178b76ea9d5c6182f67413f62dd86b0e38508/library%2Fcore%2Fsrc%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fintrinsics.rs?ref=79f178b76ea9d5c6182f67413f62dd86b0e38508", "patch": "@@ -1638,7 +1638,7 @@ extern \"rust-intrinsic\" {\n     /// let num_trailing = unsafe { cttz_nonzero(x) };\n     /// assert_eq!(num_trailing, 3);\n     /// ```\n-    #[rustc_const_stable(feature = \"const_cttz\", since = \"1.53.0\")]\n+    #[rustc_const_stable(feature = \"const_cttz_nonzero\", since = \"1.53.0\")]\n     pub fn cttz_nonzero<T: Copy>(x: T) -> T;\n \n     /// Reverses the bytes in an integer type `T`.\n@@ -1718,15 +1718,15 @@ extern \"rust-intrinsic\" {\n     /// Safe wrappers for this intrinsic are available on the integer\n     /// primitives via the `checked_div` method. For example,\n     /// [`u32::checked_div`]\n-    #[rustc_const_stable(feature = \"const_int_unchecked_arith\", since = \"1.52.0\")]\n+    #[rustc_const_stable(feature = \"const_int_unchecked_div\", since = \"1.52.0\")]\n     pub fn unchecked_div<T: Copy>(x: T, y: T) -> T;\n     /// Returns the remainder of an unchecked division, resulting in\n     /// undefined behavior when `y == 0` or `x == T::MIN && y == -1`\n     ///\n     /// Safe wrappers for this intrinsic are available on the integer\n     /// primitives via the `checked_rem` method. For example,\n     /// [`u32::checked_rem`]\n-    #[rustc_const_stable(feature = \"const_int_unchecked_arith\", since = \"1.52.0\")]\n+    #[rustc_const_stable(feature = \"const_int_unchecked_rem\", since = \"1.52.0\")]\n     pub fn unchecked_rem<T: Copy>(x: T, y: T) -> T;\n \n     /// Performs an unchecked left shift, resulting in undefined behavior when"}, {"sha": "7dfcc36ce9391284021c9253eb32dc625e58b12d", "filename": "library/core/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/79f178b76ea9d5c6182f67413f62dd86b0e38508/library%2Fcore%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79f178b76ea9d5c6182f67413f62dd86b0e38508/library%2Fcore%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Flib.rs?ref=79f178b76ea9d5c6182f67413f62dd86b0e38508", "patch": "@@ -97,7 +97,6 @@\n // Library features:\n #![feature(const_align_offset)]\n #![feature(const_align_of_val)]\n-#![feature(const_alloc_layout)]\n #![feature(const_arguments_as_str)]\n #![feature(const_array_into_iter_constructors)]\n #![feature(const_bigint_helper_methods)]"}, {"sha": "58d682fc4c8d4b31cb53e0541e48f063f94864fb", "filename": "library/core/src/mem/maybe_uninit.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/79f178b76ea9d5c6182f67413f62dd86b0e38508/library%2Fcore%2Fsrc%2Fmem%2Fmaybe_uninit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79f178b76ea9d5c6182f67413f62dd86b0e38508/library%2Fcore%2Fsrc%2Fmem%2Fmaybe_uninit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fmem%2Fmaybe_uninit.rs?ref=79f178b76ea9d5c6182f67413f62dd86b0e38508", "patch": "@@ -622,7 +622,7 @@ impl<T> MaybeUninit<T> {\n     /// // `x` had not been initialized yet, so this last line caused undefined behavior. \u26a0\ufe0f\n     /// ```\n     #[stable(feature = \"maybe_uninit\", since = \"1.36.0\")]\n-    #[rustc_const_stable(feature = \"const_maybe_uninit_assume_init\", since = \"1.59.0\")]\n+    #[rustc_const_stable(feature = \"const_maybe_uninit_assume_init_by_value\", since = \"1.59.0\")]\n     #[inline(always)]\n     #[rustc_diagnostic_item = \"assume_init\"]\n     #[track_caller]\n@@ -788,7 +788,7 @@ impl<T> MaybeUninit<T> {\n     /// }\n     /// ```\n     #[stable(feature = \"maybe_uninit_ref\", since = \"1.55.0\")]\n-    #[rustc_const_stable(feature = \"const_maybe_uninit_assume_init\", since = \"1.59.0\")]\n+    #[rustc_const_stable(feature = \"const_maybe_uninit_assume_init_ref\", since = \"1.59.0\")]\n     #[inline(always)]\n     pub const unsafe fn assume_init_ref(&self) -> &T {\n         // SAFETY: the caller must guarantee that `self` is initialized."}, {"sha": "005f8749e01e6791347eb09530281e0d650cfcfa", "filename": "library/core/src/mem/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/79f178b76ea9d5c6182f67413f62dd86b0e38508/library%2Fcore%2Fsrc%2Fmem%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79f178b76ea9d5c6182f67413f62dd86b0e38508/library%2Fcore%2Fsrc%2Fmem%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fmem%2Fmod.rs?ref=79f178b76ea9d5c6182f67413f62dd86b0e38508", "patch": "@@ -299,7 +299,7 @@ pub fn forget_unsized<T: ?Sized>(t: T) {\n #[must_use]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_promotable]\n-#[rustc_const_stable(feature = \"const_size_of\", since = \"1.24.0\")]\n+#[rustc_const_stable(feature = \"const_mem_size_of\", since = \"1.24.0\")]\n #[cfg_attr(not(test), rustc_diagnostic_item = \"mem_size_of\")]\n pub const fn size_of<T>() -> usize {\n     intrinsics::size_of::<T>()\n@@ -581,7 +581,7 @@ pub const unsafe fn align_of_val_raw<T: ?Sized>(val: *const T) -> usize {\n #[inline]\n #[must_use]\n #[stable(feature = \"needs_drop\", since = \"1.21.0\")]\n-#[rustc_const_stable(feature = \"const_needs_drop\", since = \"1.36.0\")]\n+#[rustc_const_stable(feature = \"const_mem_needs_drop\", since = \"1.36.0\")]\n #[rustc_diagnostic_item = \"needs_drop\"]\n pub const fn needs_drop<T>() -> bool {\n     intrinsics::needs_drop::<T>()"}, {"sha": "ec460286d0378f9d471991647d53b41777337488", "filename": "library/core/src/num/int_macros.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/79f178b76ea9d5c6182f67413f62dd86b0e38508/library%2Fcore%2Fsrc%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79f178b76ea9d5c6182f67413f62dd86b0e38508/library%2Fcore%2Fsrc%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fint_macros.rs?ref=79f178b76ea9d5c6182f67413f62dd86b0e38508", "patch": "@@ -270,7 +270,7 @@ macro_rules! int_impl {\n         #[doc = concat!(\"assert_eq!(0, 0\", stringify!($SelfT), \".reverse_bits());\")]\n         /// ```\n         #[stable(feature = \"reverse_bits\", since = \"1.37.0\")]\n-        #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.37.0\")]\n+        #[rustc_const_stable(feature = \"reverse_bits\", since = \"1.37.0\")]\n         #[must_use = \"this returns the result of the operation, \\\n                       without modifying the original\"]\n         #[inline(always)]\n@@ -603,7 +603,7 @@ macro_rules! int_impl {\n         #[doc = concat!(\"assert_eq!((1\", stringify!($SelfT), \").checked_div(0), None);\")]\n         /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.52.0\")]\n+        #[rustc_const_stable(feature = \"const_checked_int_div\", since = \"1.52.0\")]\n         #[must_use = \"this returns the result of the operation, \\\n                       without modifying the original\"]\n         #[inline]\n@@ -656,7 +656,7 @@ macro_rules! int_impl {\n         #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MIN.checked_rem(-1), None);\")]\n         /// ```\n         #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n-        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.52.0\")]\n+        #[rustc_const_stable(feature = \"const_checked_int_div\", since = \"1.52.0\")]\n         #[must_use = \"this returns the result of the operation, \\\n                       without modifying the original\"]\n         #[inline]"}, {"sha": "8cbece0417b0788b53fea2a686f0e53269c5516d", "filename": "library/core/src/num/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/79f178b76ea9d5c6182f67413f62dd86b0e38508/library%2Fcore%2Fsrc%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79f178b76ea9d5c6182f67413f62dd86b0e38508/library%2Fcore%2Fsrc%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fmod.rs?ref=79f178b76ea9d5c6182f67413f62dd86b0e38508", "patch": "@@ -281,7 +281,7 @@ impl u8 {\n     /// ```\n     #[must_use]\n     #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")]\n-    #[rustc_const_stable(feature = \"const_ascii_methods_on_intrinsics\", since = \"1.43.0\")]\n+    #[rustc_const_stable(feature = \"const_u8_is_ascii\", since = \"1.43.0\")]\n     #[inline]\n     pub const fn is_ascii(&self) -> bool {\n         *self & 128 == 0"}, {"sha": "0ffbde33a0d1e5dc75f75069b10f7ca7b369bd90", "filename": "library/core/src/num/nonzero.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/79f178b76ea9d5c6182f67413f62dd86b0e38508/library%2Fcore%2Fsrc%2Fnum%2Fnonzero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79f178b76ea9d5c6182f67413f62dd86b0e38508/library%2Fcore%2Fsrc%2Fnum%2Fnonzero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fnonzero.rs?ref=79f178b76ea9d5c6182f67413f62dd86b0e38508", "patch": "@@ -74,7 +74,7 @@ macro_rules! nonzero_integers {\n                 /// Returns the value as a primitive type.\n                 #[$stability]\n                 #[inline]\n-                #[rustc_const_stable(feature = \"nonzero\", since = \"1.34.0\")]\n+                #[rustc_const_stable(feature = \"const_nonzero_get\", since = \"1.34.0\")]\n                 pub const fn get(self) -> $Int {\n                     self.0\n                 }"}, {"sha": "514ac69f7e049f8e69f669dbeacab77e89456d8b", "filename": "library/core/src/num/uint_macros.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/79f178b76ea9d5c6182f67413f62dd86b0e38508/library%2Fcore%2Fsrc%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79f178b76ea9d5c6182f67413f62dd86b0e38508/library%2Fcore%2Fsrc%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fuint_macros.rs?ref=79f178b76ea9d5c6182f67413f62dd86b0e38508", "patch": "@@ -273,7 +273,7 @@ macro_rules! uint_impl {\n         #[doc = concat!(\"assert_eq!(0, 0\", stringify!($SelfT), \".reverse_bits());\")]\n         /// ```\n         #[stable(feature = \"reverse_bits\", since = \"1.37.0\")]\n-        #[rustc_const_stable(feature = \"const_math\", since = \"1.37.0\")]\n+        #[rustc_const_stable(feature = \"reverse_bits\", since = \"1.37.0\")]\n         #[must_use = \"this returns the result of the operation, \\\n                       without modifying the original\"]\n         #[inline(always)]\n@@ -591,7 +591,7 @@ macro_rules! uint_impl {\n         #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_div(0), None);\")]\n         /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.52.0\")]\n+        #[rustc_const_stable(feature = \"const_checked_int_div\", since = \"1.52.0\")]\n         #[must_use = \"this returns the result of the operation, \\\n                       without modifying the original\"]\n         #[inline]\n@@ -642,7 +642,7 @@ macro_rules! uint_impl {\n         #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".checked_rem(0), None);\")]\n         /// ```\n         #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n-        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.52.0\")]\n+        #[rustc_const_stable(feature = \"const_checked_int_div\", since = \"1.52.0\")]\n         #[must_use = \"this returns the result of the operation, \\\n                       without modifying the original\"]\n         #[inline]"}, {"sha": "b5ca9e35dced13fcfb702b23f77dc803951e982e", "filename": "library/core/src/option.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/79f178b76ea9d5c6182f67413f62dd86b0e38508/library%2Fcore%2Fsrc%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79f178b76ea9d5c6182f67413f62dd86b0e38508/library%2Fcore%2Fsrc%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Foption.rs?ref=79f178b76ea9d5c6182f67413f62dd86b0e38508", "patch": "@@ -549,7 +549,7 @@ impl<T> Option<T> {\n     #[must_use = \"if you intended to assert that this has a value, consider `.unwrap()` instead\"]\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_const_stable(feature = \"const_option\", since = \"1.48.0\")]\n+    #[rustc_const_stable(feature = \"const_option_basics\", since = \"1.48.0\")]\n     pub const fn is_some(&self) -> bool {\n         matches!(*self, Some(_))\n     }\n@@ -592,7 +592,7 @@ impl<T> Option<T> {\n                   `.and_then(|_| panic!(\\\"`Option` had a value when expected `None`\\\"))` instead\"]\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_const_stable(feature = \"const_option\", since = \"1.48.0\")]\n+    #[rustc_const_stable(feature = \"const_option_basics\", since = \"1.48.0\")]\n     pub const fn is_none(&self) -> bool {\n         !self.is_some()\n     }\n@@ -621,7 +621,7 @@ impl<T> Option<T> {\n     /// println!(\"still can print text: {text:?}\");\n     /// ```\n     #[inline]\n-    #[rustc_const_stable(feature = \"const_option\", since = \"1.48.0\")]\n+    #[rustc_const_stable(feature = \"const_option_basics\", since = \"1.48.0\")]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub const fn as_ref(&self) -> Option<&T> {\n         match *self {"}, {"sha": "e2a19c1b5818e1e073aa2f70c0ca8798405ae766", "filename": "library/core/src/ptr/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/79f178b76ea9d5c6182f67413f62dd86b0e38508/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79f178b76ea9d5c6182f67413f62dd86b0e38508/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs?ref=79f178b76ea9d5c6182f67413f62dd86b0e38508", "patch": "@@ -510,7 +510,7 @@ pub const fn null_mut<T>() -> *mut T {\n /// see the [module documentation][crate::ptr] for details.\n #[inline(always)]\n #[must_use]\n-#[rustc_const_stable(feature = \"strict_provenance\", since = \"1.61.0\")]\n+#[rustc_const_stable(feature = \"stable_things_using_strict_provenance\", since = \"1.61.0\")]\n #[unstable(feature = \"strict_provenance\", issue = \"95228\")]\n pub const fn invalid<T>(addr: usize) -> *const T {\n     // FIXME(strict_provenance_magic): I am magic and should be a compiler intrinsic.\n@@ -537,7 +537,7 @@ pub const fn invalid<T>(addr: usize) -> *const T {\n /// see the [module documentation][crate::ptr] for details.\n #[inline(always)]\n #[must_use]\n-#[rustc_const_stable(feature = \"strict_provenance\", since = \"1.61.0\")]\n+#[rustc_const_stable(feature = \"stable_things_using_strict_provenance\", since = \"1.61.0\")]\n #[unstable(feature = \"strict_provenance\", issue = \"95228\")]\n pub const fn invalid_mut<T>(addr: usize) -> *mut T {\n     // FIXME(strict_provenance_magic): I am magic and should be a compiler intrinsic."}, {"sha": "7516d4bba4cdfcd98a6d94c08eb65785879a571c", "filename": "library/core/src/ptr/non_null.rs", "status": "modified", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/79f178b76ea9d5c6182f67413f62dd86b0e38508/library%2Fcore%2Fsrc%2Fptr%2Fnon_null.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79f178b76ea9d5c6182f67413f62dd86b0e38508/library%2Fcore%2Fsrc%2Fptr%2Fnon_null.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fnon_null.rs?ref=79f178b76ea9d5c6182f67413f62dd86b0e38508", "patch": "@@ -4,6 +4,7 @@ use crate::fmt;\n use crate::hash;\n use crate::marker::Unsize;\n use crate::mem::{self, MaybeUninit};\n+use crate::num::NonZeroUsize;\n use crate::ops::{CoerceUnsized, DispatchFromDyn};\n use crate::ptr::Unique;\n use crate::slice::{self, SliceIndex};\n@@ -253,6 +254,53 @@ impl<T: ?Sized> NonNull<T> {\n         (self.cast(), super::metadata(self.as_ptr()))\n     }\n \n+    /// Gets the \"address\" portion of the pointer.\n+    ///\n+    /// This API and its claimed semantics are part of the Strict Provenance experiment,\n+    /// see the [module documentation][crate::ptr] for details.\n+    #[must_use]\n+    #[inline]\n+    #[unstable(feature = \"strict_provenance\", issue = \"95228\")]\n+    pub fn addr(self) -> NonZeroUsize\n+    where\n+        T: Sized,\n+    {\n+        // SAFETY: The pointer is guaranteed by the type to be non-null,\n+        // meaning that the address will be non-zero.\n+        unsafe { NonZeroUsize::new_unchecked(self.pointer.addr()) }\n+    }\n+\n+    /// Creates a new pointer with the given address.\n+    ///\n+    /// This API and its claimed semantics are part of the Strict Provenance experiment,\n+    /// see the [module documentation][crate::ptr] for details.\n+    #[must_use]\n+    #[inline]\n+    #[unstable(feature = \"strict_provenance\", issue = \"95228\")]\n+    pub fn with_addr(self, addr: NonZeroUsize) -> Self\n+    where\n+        T: Sized,\n+    {\n+        // SAFETY: The result of `ptr::from::with_addr` is non-null because `addr` is guaranteed to be non-zero.\n+        unsafe { NonNull::new_unchecked(self.pointer.with_addr(addr.get()) as *mut _) }\n+    }\n+\n+    /// Creates a new pointer by mapping `self`'s address to a new one.\n+    ///\n+    /// This is a convenience for [`with_addr`][Self::with_addr], see that method for details.\n+    ///\n+    /// This API and its claimed semantics are part of the Strict Provenance experiment,\n+    /// see the [module documentation][crate::ptr] for details.\n+    #[must_use]\n+    #[inline]\n+    #[unstable(feature = \"strict_provenance\", issue = \"95228\")]\n+    pub fn map_addr(self, f: impl FnOnce(NonZeroUsize) -> NonZeroUsize) -> Self\n+    where\n+        T: Sized,\n+    {\n+        self.with_addr(f(self.addr()))\n+    }\n+\n     /// Acquires the underlying `*mut` pointer.\n     ///\n     /// # Examples"}, {"sha": "641749be36637f7f172eccbba6dc0fdf518b8a86", "filename": "library/core/src/result.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/79f178b76ea9d5c6182f67413f62dd86b0e38508/library%2Fcore%2Fsrc%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79f178b76ea9d5c6182f67413f62dd86b0e38508/library%2Fcore%2Fsrc%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fresult.rs?ref=79f178b76ea9d5c6182f67413f62dd86b0e38508", "patch": "@@ -536,7 +536,7 @@ impl<T, E> Result<T, E> {\n     /// assert_eq!(x.is_ok(), false);\n     /// ```\n     #[must_use = \"if you intended to assert that this is ok, consider `.unwrap()` instead\"]\n-    #[rustc_const_stable(feature = \"const_result\", since = \"1.48.0\")]\n+    #[rustc_const_stable(feature = \"const_result_basics\", since = \"1.48.0\")]\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub const fn is_ok(&self) -> bool {\n@@ -580,7 +580,7 @@ impl<T, E> Result<T, E> {\n     /// assert_eq!(x.is_err(), true);\n     /// ```\n     #[must_use = \"if you intended to assert that this is err, consider `.unwrap_err()` instead\"]\n-    #[rustc_const_stable(feature = \"const_result\", since = \"1.48.0\")]\n+    #[rustc_const_stable(feature = \"const_result_basics\", since = \"1.48.0\")]\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub const fn is_err(&self) -> bool {\n@@ -698,7 +698,7 @@ impl<T, E> Result<T, E> {\n     /// assert_eq!(x.as_ref(), Err(&\"Error\"));\n     /// ```\n     #[inline]\n-    #[rustc_const_stable(feature = \"const_result\", since = \"1.48.0\")]\n+    #[rustc_const_stable(feature = \"const_result_basics\", since = \"1.48.0\")]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub const fn as_ref(&self) -> Result<&T, &E> {\n         match *self {"}, {"sha": "6285d1c1cbb564ca275bebd8bc609277294434c8", "filename": "library/core/src/sync/atomic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/79f178b76ea9d5c6182f67413f62dd86b0e38508/library%2Fcore%2Fsrc%2Fsync%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79f178b76ea9d5c6182f67413f62dd86b0e38508/library%2Fcore%2Fsrc%2Fsync%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fsync%2Fatomic.rs?ref=79f178b76ea9d5c6182f67413f62dd86b0e38508", "patch": "@@ -2498,7 +2498,7 @@ macro_rules! atomic_int_ptr_sized {\n             stable(feature = \"atomic_access\", since = \"1.15.0\"),\n             stable(feature = \"atomic_from\", since = \"1.23.0\"),\n             stable(feature = \"atomic_nand\", since = \"1.27.0\"),\n-            rustc_const_stable(feature = \"const_integer_atomics\", since = \"1.24.0\"),\n+            rustc_const_stable(feature = \"const_ptr_sized_atomics\", since = \"1.24.0\"),\n             stable(feature = \"rust1\", since = \"1.0.0\"),\n             \"isize\",\n             \"\",\n@@ -2518,7 +2518,7 @@ macro_rules! atomic_int_ptr_sized {\n             stable(feature = \"atomic_access\", since = \"1.15.0\"),\n             stable(feature = \"atomic_from\", since = \"1.23.0\"),\n             stable(feature = \"atomic_nand\", since = \"1.27.0\"),\n-            rustc_const_stable(feature = \"const_integer_atomics\", since = \"1.24.0\"),\n+            rustc_const_stable(feature = \"const_ptr_sized_atomics\", since = \"1.24.0\"),\n             stable(feature = \"rust1\", since = \"1.0.0\"),\n             \"usize\",\n             \"\","}, {"sha": "6c97305b1a8492908c2cd046b6c4b3998d783325", "filename": "library/core/src/time.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/79f178b76ea9d5c6182f67413f62dd86b0e38508/library%2Fcore%2Fsrc%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79f178b76ea9d5c6182f67413f62dd86b0e38508/library%2Fcore%2Fsrc%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ftime.rs?ref=79f178b76ea9d5c6182f67413f62dd86b0e38508", "patch": "@@ -333,7 +333,7 @@ impl Duration {\n     ///\n     /// [`subsec_nanos`]: Duration::subsec_nanos\n     #[stable(feature = \"duration\", since = \"1.3.0\")]\n-    #[rustc_const_stable(feature = \"duration\", since = \"1.32.0\")]\n+    #[rustc_const_stable(feature = \"duration_consts\", since = \"1.32.0\")]\n     #[must_use]\n     #[inline]\n     pub const fn as_secs(&self) -> u64 {\n@@ -356,7 +356,7 @@ impl Duration {\n     /// assert_eq!(duration.subsec_millis(), 432);\n     /// ```\n     #[stable(feature = \"duration_extras\", since = \"1.27.0\")]\n-    #[rustc_const_stable(feature = \"duration_extras\", since = \"1.32.0\")]\n+    #[rustc_const_stable(feature = \"duration_consts\", since = \"1.32.0\")]\n     #[must_use]\n     #[inline]\n     pub const fn subsec_millis(&self) -> u32 {\n@@ -379,7 +379,7 @@ impl Duration {\n     /// assert_eq!(duration.subsec_micros(), 234_567);\n     /// ```\n     #[stable(feature = \"duration_extras\", since = \"1.27.0\")]\n-    #[rustc_const_stable(feature = \"duration_extras\", since = \"1.32.0\")]\n+    #[rustc_const_stable(feature = \"duration_consts\", since = \"1.32.0\")]\n     #[must_use]\n     #[inline]\n     pub const fn subsec_micros(&self) -> u32 {\n@@ -402,7 +402,7 @@ impl Duration {\n     /// assert_eq!(duration.subsec_nanos(), 10_000_000);\n     /// ```\n     #[stable(feature = \"duration\", since = \"1.3.0\")]\n-    #[rustc_const_stable(feature = \"duration\", since = \"1.32.0\")]\n+    #[rustc_const_stable(feature = \"duration_consts\", since = \"1.32.0\")]\n     #[must_use]\n     #[inline]\n     pub const fn subsec_nanos(&self) -> u32 {"}, {"sha": "3af277a556b4f45c9e67253058175afe7c15011c", "filename": "library/core/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/79f178b76ea9d5c6182f67413f62dd86b0e38508/library%2Fcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79f178b76ea9d5c6182f67413f62dd86b0e38508/library%2Fcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Flib.rs?ref=79f178b76ea9d5c6182f67413f62dd86b0e38508", "patch": "@@ -13,7 +13,6 @@\n #![feature(const_convert)]\n #![feature(const_heap)]\n #![feature(const_maybe_uninit_as_mut_ptr)]\n-#![feature(const_maybe_uninit_assume_init)]\n #![feature(const_maybe_uninit_assume_init_read)]\n #![feature(const_nonnull_new)]\n #![feature(const_num_from_num)]\n@@ -87,6 +86,7 @@\n #![feature(int_roundings)]\n #![feature(slice_group_by)]\n #![feature(split_array)]\n+#![feature(strict_provenance)]\n #![feature(trusted_random_access)]\n #![feature(unsize)]\n #![feature(unzip_option)]"}, {"sha": "03fe56022b069107e27de11684ce1728c0263242", "filename": "library/core/tests/ptr.rs", "status": "modified", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/79f178b76ea9d5c6182f67413f62dd86b0e38508/library%2Fcore%2Ftests%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79f178b76ea9d5c6182f67413f62dd86b0e38508/library%2Fcore%2Ftests%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fptr.rs?ref=79f178b76ea9d5c6182f67413f62dd86b0e38508", "patch": "@@ -1,4 +1,5 @@\n use core::cell::RefCell;\n+use core::num::NonZeroUsize;\n use core::ptr;\n use core::ptr::*;\n use std::fmt::{Debug, Display};\n@@ -691,3 +692,80 @@ fn thin_box() {\n         }\n     }\n }\n+\n+#[test]\n+fn nonnull_tagged_pointer_with_provenance() {\n+    let raw_pointer = Box::into_raw(Box::new(10));\n+\n+    let mut p = TaggedPointer::new(raw_pointer).unwrap();\n+    assert_eq!(p.tag(), 0);\n+\n+    p.set_tag(1);\n+    assert_eq!(p.tag(), 1);\n+    assert_eq!(unsafe { *p.pointer().as_ptr() }, 10);\n+\n+    p.set_tag(3);\n+    assert_eq!(p.tag(), 3);\n+    assert_eq!(unsafe { *p.pointer().as_ptr() }, 10);\n+\n+    unsafe { Box::from_raw(p.pointer().as_ptr()) };\n+\n+    /// A non-null pointer type which carries several bits of metadata and maintains provenance.\n+    #[repr(transparent)]\n+    pub struct TaggedPointer<T>(NonNull<T>);\n+\n+    impl<T> Clone for TaggedPointer<T> {\n+        fn clone(&self) -> Self {\n+            Self(self.0)\n+        }\n+    }\n+\n+    impl<T> Copy for TaggedPointer<T> {}\n+\n+    impl<T> TaggedPointer<T> {\n+        /// The ABI-required minimum alignment of the `P` type.\n+        pub const ALIGNMENT: usize = core::mem::align_of::<T>();\n+        /// A mask for data-carrying bits of the address.\n+        pub const DATA_MASK: usize = !Self::ADDRESS_MASK;\n+        /// Number of available bits of storage in the address.\n+        pub const NUM_BITS: u32 = Self::ALIGNMENT.trailing_zeros();\n+        /// A mask for the non-data-carrying bits of the address.\n+        pub const ADDRESS_MASK: usize = usize::MAX << Self::NUM_BITS;\n+\n+        /// Create a new tagged pointer from a possibly null pointer.\n+        pub fn new(pointer: *mut T) -> Option<TaggedPointer<T>> {\n+            Some(TaggedPointer(NonNull::new(pointer)?))\n+        }\n+\n+        /// Consume this tagged pointer and produce a raw mutable pointer to the\n+        /// memory location.\n+        pub fn pointer(self) -> NonNull<T> {\n+            // SAFETY: The `addr` guaranteed to have bits set in the Self::ADDRESS_MASK, so the result will be non-null.\n+            self.0.map_addr(|addr| unsafe {\n+                NonZeroUsize::new_unchecked(addr.get() & Self::ADDRESS_MASK)\n+            })\n+        }\n+\n+        /// Consume this tagged pointer and produce the data it carries.\n+        pub fn tag(&self) -> usize {\n+            self.0.addr().get() & Self::DATA_MASK\n+        }\n+\n+        /// Update the data this tagged pointer carries to a new value.\n+        pub fn set_tag(&mut self, data: usize) {\n+            assert_eq!(\n+                data & Self::ADDRESS_MASK,\n+                0,\n+                \"cannot set more data beyond the lowest NUM_BITS\"\n+            );\n+            let data = data & Self::DATA_MASK;\n+\n+            // SAFETY: This value will always be non-zero because the upper bits (from\n+            // ADDRESS_MASK) will always be non-zero. This a property of the type and its\n+            // construction.\n+            self.0 = self.0.map_addr(|addr| unsafe {\n+                NonZeroUsize::new_unchecked((addr.get() & Self::ADDRESS_MASK) | data)\n+            })\n+        }\n+    }\n+}"}, {"sha": "036f2919976074653f589471a2f24469e873e920", "filename": "library/std/src/net/ip.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/79f178b76ea9d5c6182f67413f62dd86b0e38508/library%2Fstd%2Fsrc%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79f178b76ea9d5c6182f67413f62dd86b0e38508/library%2Fstd%2Fsrc%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fnet%2Fip.rs?ref=79f178b76ea9d5c6182f67413f62dd86b0e38508", "patch": "@@ -235,7 +235,7 @@ impl IpAddr {\n     /// assert_eq!(IpAddr::V4(Ipv4Addr::new(0, 0, 0, 0)).is_unspecified(), true);\n     /// assert_eq!(IpAddr::V6(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 0)).is_unspecified(), true);\n     /// ```\n-    #[rustc_const_stable(feature = \"const_ip\", since = \"1.50.0\")]\n+    #[rustc_const_stable(feature = \"const_ip_50\", since = \"1.50.0\")]\n     #[stable(feature = \"ip_shared\", since = \"1.12.0\")]\n     #[must_use]\n     #[inline]\n@@ -259,7 +259,7 @@ impl IpAddr {\n     /// assert_eq!(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)).is_loopback(), true);\n     /// assert_eq!(IpAddr::V6(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 0x1)).is_loopback(), true);\n     /// ```\n-    #[rustc_const_stable(feature = \"const_ip\", since = \"1.50.0\")]\n+    #[rustc_const_stable(feature = \"const_ip_50\", since = \"1.50.0\")]\n     #[stable(feature = \"ip_shared\", since = \"1.12.0\")]\n     #[must_use]\n     #[inline]\n@@ -309,7 +309,7 @@ impl IpAddr {\n     /// assert_eq!(IpAddr::V4(Ipv4Addr::new(224, 254, 0, 0)).is_multicast(), true);\n     /// assert_eq!(IpAddr::V6(Ipv6Addr::new(0xff00, 0, 0, 0, 0, 0, 0, 0)).is_multicast(), true);\n     /// ```\n-    #[rustc_const_stable(feature = \"const_ip\", since = \"1.50.0\")]\n+    #[rustc_const_stable(feature = \"const_ip_50\", since = \"1.50.0\")]\n     #[stable(feature = \"ip_shared\", since = \"1.12.0\")]\n     #[must_use]\n     #[inline]\n@@ -387,7 +387,7 @@ impl IpAddr {\n     /// assert_eq!(IpAddr::V4(Ipv4Addr::new(203, 0, 113, 6)).is_ipv4(), true);\n     /// assert_eq!(IpAddr::V6(Ipv6Addr::new(0x2001, 0xdb8, 0, 0, 0, 0, 0, 0)).is_ipv4(), false);\n     /// ```\n-    #[rustc_const_stable(feature = \"const_ip\", since = \"1.50.0\")]\n+    #[rustc_const_stable(feature = \"const_ip_50\", since = \"1.50.0\")]\n     #[stable(feature = \"ipaddr_checker\", since = \"1.16.0\")]\n     #[must_use]\n     #[inline]\n@@ -408,7 +408,7 @@ impl IpAddr {\n     /// assert_eq!(IpAddr::V4(Ipv4Addr::new(203, 0, 113, 6)).is_ipv6(), false);\n     /// assert_eq!(IpAddr::V6(Ipv6Addr::new(0x2001, 0xdb8, 0, 0, 0, 0, 0, 0)).is_ipv6(), true);\n     /// ```\n-    #[rustc_const_stable(feature = \"const_ip\", since = \"1.50.0\")]\n+    #[rustc_const_stable(feature = \"const_ip_50\", since = \"1.50.0\")]\n     #[stable(feature = \"ipaddr_checker\", since = \"1.16.0\")]\n     #[must_use]\n     #[inline]\n@@ -454,7 +454,7 @@ impl Ipv4Addr {\n     ///\n     /// let addr = Ipv4Addr::new(127, 0, 0, 1);\n     /// ```\n-    #[rustc_const_stable(feature = \"const_ipv4\", since = \"1.32.0\")]\n+    #[rustc_const_stable(feature = \"const_ip_32\", since = \"1.32.0\")]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[must_use]\n     #[inline]\n@@ -516,7 +516,7 @@ impl Ipv4Addr {\n     /// let addr = Ipv4Addr::new(127, 0, 0, 1);\n     /// assert_eq!(addr.octets(), [127, 0, 0, 1]);\n     /// ```\n-    #[rustc_const_stable(feature = \"const_ipv4\", since = \"1.50.0\")]\n+    #[rustc_const_stable(feature = \"const_ip_50\", since = \"1.50.0\")]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[must_use]\n     #[inline]\n@@ -540,7 +540,7 @@ impl Ipv4Addr {\n     /// assert_eq!(Ipv4Addr::new(0, 0, 0, 0).is_unspecified(), true);\n     /// assert_eq!(Ipv4Addr::new(45, 22, 13, 197).is_unspecified(), false);\n     /// ```\n-    #[rustc_const_stable(feature = \"const_ipv4\", since = \"1.32.0\")]\n+    #[rustc_const_stable(feature = \"const_ip_32\", since = \"1.32.0\")]\n     #[stable(feature = \"ip_shared\", since = \"1.12.0\")]\n     #[must_use]\n     #[inline]\n@@ -562,7 +562,7 @@ impl Ipv4Addr {\n     /// assert_eq!(Ipv4Addr::new(127, 0, 0, 1).is_loopback(), true);\n     /// assert_eq!(Ipv4Addr::new(45, 22, 13, 197).is_loopback(), false);\n     /// ```\n-    #[rustc_const_stable(feature = \"const_ipv4\", since = \"1.50.0\")]\n+    #[rustc_const_stable(feature = \"const_ip_50\", since = \"1.50.0\")]\n     #[stable(since = \"1.7.0\", feature = \"ip_17\")]\n     #[must_use]\n     #[inline]\n@@ -593,7 +593,7 @@ impl Ipv4Addr {\n     /// assert_eq!(Ipv4Addr::new(192, 168, 0, 2).is_private(), true);\n     /// assert_eq!(Ipv4Addr::new(192, 169, 0, 2).is_private(), false);\n     /// ```\n-    #[rustc_const_stable(feature = \"const_ipv4\", since = \"1.50.0\")]\n+    #[rustc_const_stable(feature = \"const_ip_50\", since = \"1.50.0\")]\n     #[stable(since = \"1.7.0\", feature = \"ip_17\")]\n     #[must_use]\n     #[inline]\n@@ -621,7 +621,7 @@ impl Ipv4Addr {\n     /// assert_eq!(Ipv4Addr::new(169, 254, 10, 65).is_link_local(), true);\n     /// assert_eq!(Ipv4Addr::new(16, 89, 10, 65).is_link_local(), false);\n     /// ```\n-    #[rustc_const_stable(feature = \"const_ipv4\", since = \"1.50.0\")]\n+    #[rustc_const_stable(feature = \"const_ip_50\", since = \"1.50.0\")]\n     #[stable(since = \"1.7.0\", feature = \"ip_17\")]\n     #[must_use]\n     #[inline]\n@@ -823,7 +823,7 @@ impl Ipv4Addr {\n     /// assert_eq!(Ipv4Addr::new(236, 168, 10, 65).is_multicast(), true);\n     /// assert_eq!(Ipv4Addr::new(172, 16, 10, 65).is_multicast(), false);\n     /// ```\n-    #[rustc_const_stable(feature = \"const_ipv4\", since = \"1.50.0\")]\n+    #[rustc_const_stable(feature = \"const_ip_50\", since = \"1.50.0\")]\n     #[stable(since = \"1.7.0\", feature = \"ip_17\")]\n     #[must_use]\n     #[inline]\n@@ -845,7 +845,7 @@ impl Ipv4Addr {\n     /// assert_eq!(Ipv4Addr::new(255, 255, 255, 255).is_broadcast(), true);\n     /// assert_eq!(Ipv4Addr::new(236, 168, 10, 65).is_broadcast(), false);\n     /// ```\n-    #[rustc_const_stable(feature = \"const_ipv4\", since = \"1.50.0\")]\n+    #[rustc_const_stable(feature = \"const_ip_50\", since = \"1.50.0\")]\n     #[stable(since = \"1.7.0\", feature = \"ip_17\")]\n     #[must_use]\n     #[inline]\n@@ -873,7 +873,7 @@ impl Ipv4Addr {\n     /// assert_eq!(Ipv4Addr::new(203, 0, 113, 6).is_documentation(), true);\n     /// assert_eq!(Ipv4Addr::new(193, 34, 17, 19).is_documentation(), false);\n     /// ```\n-    #[rustc_const_stable(feature = \"const_ipv4\", since = \"1.50.0\")]\n+    #[rustc_const_stable(feature = \"const_ip_50\", since = \"1.50.0\")]\n     #[stable(since = \"1.7.0\", feature = \"ip_17\")]\n     #[must_use]\n     #[inline]\n@@ -901,7 +901,7 @@ impl Ipv4Addr {\n     ///     Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0xc000, 0x2ff)\n     /// );\n     /// ```\n-    #[rustc_const_stable(feature = \"const_ipv4\", since = \"1.50.0\")]\n+    #[rustc_const_stable(feature = \"const_ip_50\", since = \"1.50.0\")]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[must_use = \"this returns the result of the operation, \\\n                   without modifying the original\"]\n@@ -928,7 +928,7 @@ impl Ipv4Addr {\n     /// assert_eq!(Ipv4Addr::new(192, 0, 2, 255).to_ipv6_mapped(),\n     ///            Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc000, 0x2ff));\n     /// ```\n-    #[rustc_const_stable(feature = \"const_ipv4\", since = \"1.50.0\")]\n+    #[rustc_const_stable(feature = \"const_ip_50\", since = \"1.50.0\")]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[must_use = \"this returns the result of the operation, \\\n                   without modifying the original\"]\n@@ -1216,7 +1216,7 @@ impl Ipv6Addr {\n     ///\n     /// let addr = Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc00a, 0x2ff);\n     /// ```\n-    #[rustc_const_stable(feature = \"const_ipv6\", since = \"1.32.0\")]\n+    #[rustc_const_stable(feature = \"const_ip_32\", since = \"1.32.0\")]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[must_use]\n     #[inline]\n@@ -1278,7 +1278,7 @@ impl Ipv6Addr {\n     /// assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc00a, 0x2ff).segments(),\n     ///            [0, 0, 0, 0, 0, 0xffff, 0xc00a, 0x2ff]);\n     /// ```\n-    #[rustc_const_stable(feature = \"const_ipv6\", since = \"1.50.0\")]\n+    #[rustc_const_stable(feature = \"const_ip_50\", since = \"1.50.0\")]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[must_use]\n     #[inline]\n@@ -1315,7 +1315,7 @@ impl Ipv6Addr {\n     /// assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc00a, 0x2ff).is_unspecified(), false);\n     /// assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 0).is_unspecified(), true);\n     /// ```\n-    #[rustc_const_stable(feature = \"const_ipv6\", since = \"1.50.0\")]\n+    #[rustc_const_stable(feature = \"const_ip_50\", since = \"1.50.0\")]\n     #[stable(since = \"1.7.0\", feature = \"ip_17\")]\n     #[must_use]\n     #[inline]\n@@ -1339,7 +1339,7 @@ impl Ipv6Addr {\n     /// assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc00a, 0x2ff).is_loopback(), false);\n     /// assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 0x1).is_loopback(), true);\n     /// ```\n-    #[rustc_const_stable(feature = \"const_ipv6\", since = \"1.50.0\")]\n+    #[rustc_const_stable(feature = \"const_ip_50\", since = \"1.50.0\")]\n     #[stable(since = \"1.7.0\", feature = \"ip_17\")]\n     #[must_use]\n     #[inline]\n@@ -1624,7 +1624,7 @@ impl Ipv6Addr {\n     /// assert_eq!(Ipv6Addr::new(0xff00, 0, 0, 0, 0, 0, 0, 0).is_multicast(), true);\n     /// assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc00a, 0x2ff).is_multicast(), false);\n     /// ```\n-    #[rustc_const_stable(feature = \"const_ipv6\", since = \"1.50.0\")]\n+    #[rustc_const_stable(feature = \"const_ip_50\", since = \"1.50.0\")]\n     #[stable(since = \"1.7.0\", feature = \"ip_17\")]\n     #[must_use]\n     #[inline]\n@@ -1693,7 +1693,7 @@ impl Ipv6Addr {\n     /// assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1).to_ipv4(),\n     ///            Some(Ipv4Addr::new(0, 0, 0, 1)));\n     /// ```\n-    #[rustc_const_stable(feature = \"const_ipv6\", since = \"1.50.0\")]\n+    #[rustc_const_stable(feature = \"const_ip_50\", since = \"1.50.0\")]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[must_use = \"this returns the result of the operation, \\\n                   without modifying the original\"]\n@@ -1740,7 +1740,7 @@ impl Ipv6Addr {\n     /// assert_eq!(Ipv6Addr::new(0xff00, 0, 0, 0, 0, 0, 0, 0).octets(),\n     ///            [255, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);\n     /// ```\n-    #[rustc_const_stable(feature = \"const_ipv6\", since = \"1.32.0\")]\n+    #[rustc_const_stable(feature = \"const_ip_32\", since = \"1.32.0\")]\n     #[stable(feature = \"ipv6_to_octets\", since = \"1.12.0\")]\n     #[must_use]\n     #[inline]"}, {"sha": "587e453ceef91b348f478bbb4032d0435cceaecf", "filename": "library/std/src/thread/local.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/79f178b76ea9d5c6182f67413f62dd86b0e38508/library%2Fstd%2Fsrc%2Fthread%2Flocal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79f178b76ea9d5c6182f67413f62dd86b0e38508/library%2Fstd%2Fsrc%2Fthread%2Flocal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fthread%2Flocal.rs?ref=79f178b76ea9d5c6182f67413f62dd86b0e38508", "patch": "@@ -193,7 +193,7 @@ macro_rules! __thread_local_inner {\n             #[cfg(all(target_family = \"wasm\", not(target_feature = \"atomics\")))]\n             {\n                 static mut VAL: $t = INIT_EXPR;\n-                Some(&VAL)\n+                $crate::option::Option::Some(&VAL)\n             }\n \n             // If the platform has support for `#[thread_local]`, use it.\n@@ -209,7 +209,7 @@ macro_rules! __thread_local_inner {\n                 // just get going.\n                 if !$crate::mem::needs_drop::<$t>() {\n                     unsafe {\n-                        return Some(&VAL)\n+                        return $crate::option::Option::Some(&VAL)\n                     }\n                 }\n \n@@ -223,7 +223,7 @@ macro_rules! __thread_local_inner {\n                     let ptr = ptr as *mut $t;\n \n                     unsafe {\n-                        debug_assert_eq!(STATE, 1);\n+                        $crate::debug_assert_eq!(STATE, 1);\n                         STATE = 2;\n                         $crate::ptr::drop_in_place(ptr);\n                     }\n@@ -239,14 +239,14 @@ macro_rules! __thread_local_inner {\n                                 destroy,\n                             );\n                             STATE = 1;\n-                            Some(&VAL)\n+                            $crate::option::Option::Some(&VAL)\n                         }\n                         // 1 == the destructor is registered and the value\n                         //   is valid, so return the pointer.\n-                        1 => Some(&VAL),\n+                        1 => $crate::option::Option::Some(&VAL),\n                         // otherwise the destructor has already run, so we\n                         // can't give access.\n-                        _ => None,\n+                        _ => $crate::option::Option::None,\n                     }\n                 }\n             }\n@@ -269,7 +269,7 @@ macro_rules! __thread_local_inner {\n                             if let $crate::option::Option::Some(value) = init.take() {\n                                 return value;\n                             } else if $crate::cfg!(debug_assertions) {\n-                                unreachable!(\"missing initial value\");\n+                                $crate::unreachable!(\"missing initial value\");\n                             }\n                         }\n                         __init()\n@@ -344,7 +344,7 @@ macro_rules! __thread_local_inner {\n                             if let $crate::option::Option::Some(value) = init.take() {\n                                 return value;\n                             } else if $crate::cfg!(debug_assertions) {\n-                                unreachable!(\"missing default value\");\n+                                $crate::unreachable!(\"missing default value\");\n                             }\n                         }\n                         __init()"}, {"sha": "8455dd9ef95f4f4777b6e195691050ece8d8207e", "filename": "src/test/rustdoc/const-display.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/79f178b76ea9d5c6182f67413f62dd86b0e38508/src%2Ftest%2Frustdoc%2Fconst-display.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79f178b76ea9d5c6182f67413f62dd86b0e38508/src%2Ftest%2Frustdoc%2Fconst-display.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fconst-display.rs?ref=79f178b76ea9d5c6182f67413f62dd86b0e38508", "patch": "@@ -64,7 +64,7 @@ impl Foo {\n     // @has 'foo/struct.Foo.html' '//*[@id=\"method.stable_impl\"]/h4[@class=\"code-header\"]' 'pub const fn stable_impl() -> u32'\n     // @has - '//span[@class=\"since\"]' '1.0.0 (const: 1.2.0)'\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_const_stable(feature = \"rust1\", since = \"1.2.0\")]\n+    #[rustc_const_stable(feature = \"const2\", since = \"1.2.0\")]\n     pub const fn stable_impl() -> u32 { 42 }\n }\n \n@@ -75,12 +75,12 @@ impl Bar {\n     // Do not show non-const stabilities that are the same as the enclosing item.\n     // @matches 'foo/struct.Bar.html' '//span[@class=\"since\"]' '^const: 1.2.0$'\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_const_stable(feature = \"rust1\", since = \"1.2.0\")]\n+    #[rustc_const_stable(feature = \"const2\", since = \"1.2.0\")]\n     pub const fn stable_impl() -> u32 { 42 }\n \n     // Show const-stability even for unstable functions.\n     // @matches 'foo/struct.Bar.html' '//span[@class=\"since\"]' '^const: 1.3.0$'\n     #[unstable(feature = \"foo2\", issue = \"none\")]\n-    #[rustc_const_stable(feature = \"rust1\", since = \"1.3.0\")]\n+    #[rustc_const_stable(feature = \"const3\", since = \"1.3.0\")]\n     pub const fn const_stable_unstable() -> u32 { 42 }\n }"}, {"sha": "35dc9cca33b5aa373f10eecc400d7177b1bfb0b4", "filename": "src/test/ui/asm/naked-functions.stderr", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/79f178b76ea9d5c6182f67413f62dd86b0e38508/src%2Ftest%2Fui%2Fasm%2Fnaked-functions.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/79f178b76ea9d5c6182f67413f62dd86b0e38508/src%2Ftest%2Fui%2Fasm%2Fnaked-functions.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasm%2Fnaked-functions.stderr?ref=79f178b76ea9d5c6182f67413f62dd86b0e38508", "patch": "@@ -97,6 +97,11 @@ LL | |\n LL | |          sym G,\n LL | |     );\n    | |_____^\n+   |\n+help: consider specifying that the asm block is responsible for returning from the function\n+   |\n+LL |          sym G, options(noreturn),\n+   |               +++++++++++++++++++\n \n error[E0787]: naked functions must contain a single asm block\n   --> $DIR/naked-functions.rs:53:1\n@@ -131,18 +136,33 @@ error[E0787]: asm in naked functions must use `noreturn` option\n    |\n LL |     asm!(\"\");\n    |     ^^^^^^^^\n+   |\n+help: consider specifying that the asm block is responsible for returning from the function\n+   |\n+LL |     asm!(\"\", options(noreturn));\n+   |            +++++++++++++++++++\n \n error[E0787]: asm in naked functions must use `noreturn` option\n   --> $DIR/naked-functions.rs:85:5\n    |\n LL |     asm!(\"\");\n    |     ^^^^^^^^\n+   |\n+help: consider specifying that the asm block is responsible for returning from the function\n+   |\n+LL |     asm!(\"\", options(noreturn));\n+   |            +++++++++++++++++++\n \n error[E0787]: asm in naked functions must use `noreturn` option\n   --> $DIR/naked-functions.rs:87:5\n    |\n LL |     asm!(\"\");\n    |     ^^^^^^^^\n+   |\n+help: consider specifying that the asm block is responsible for returning from the function\n+   |\n+LL |     asm!(\"\", options(noreturn));\n+   |            +++++++++++++++++++\n \n error[E0787]: naked functions must contain a single asm block\n   --> $DIR/naked-functions.rs:81:1\n@@ -198,6 +218,11 @@ error[E0787]: asm in naked functions must use `noreturn` option\n    |\n LL |     asm!(\"\", options(readonly, nostack), options(pure));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: consider specifying that the asm block is responsible for returning from the function\n+   |\n+LL |     asm!(\"\", options(noreturn), options(readonly, nostack), options(pure));\n+   |            +++++++++++++++++++\n \n error[E0787]: asm options unsupported in naked functions: `may_unwind`\n   --> $DIR/naked-functions.rs:118:5"}, {"sha": "38e5c454edf7566677a91f23a006b1a5af0d7114", "filename": "src/test/ui/consts/assert-type-intrinsics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/79f178b76ea9d5c6182f67413f62dd86b0e38508/src%2Ftest%2Fui%2Fconsts%2Fassert-type-intrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79f178b76ea9d5c6182f67413f62dd86b0e38508/src%2Ftest%2Fui%2Fconsts%2Fassert-type-intrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fassert-type-intrinsics.rs?ref=79f178b76ea9d5c6182f67413f62dd86b0e38508", "patch": "@@ -1,7 +1,7 @@\n // error-pattern: any use of this value will cause an error\n \n #![feature(never_type)]\n-#![feature(const_maybe_uninit_assume_init, const_assert_type2)]\n+#![feature(const_assert_type2)]\n #![feature(core_intrinsics)]\n \n use std::intrinsics;"}, {"sha": "3472c05d12fa80ac23d1ee0375a5e549a2d86c34", "filename": "src/test/ui/consts/const-eval/simd/insert_extract.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/79f178b76ea9d5c6182f67413f62dd86b0e38508/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fsimd%2Finsert_extract.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79f178b76ea9d5c6182f67413f62dd86b0e38508/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fsimd%2Finsert_extract.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fsimd%2Finsert_extract.rs?ref=79f178b76ea9d5c6182f67413f62dd86b0e38508", "patch": "@@ -2,7 +2,7 @@\n #![feature(repr_simd)]\n #![feature(platform_intrinsics)]\n #![feature(staged_api)]\n-#![stable(feature = \"foo\", since = \"1.33.7\")]\n+#![stable(feature = \"foo\", since = \"1.3.37\")]\n #![allow(non_camel_case_types)]\n \n #[repr(simd)] struct i8x1(i8);"}, {"sha": "5cd323c01db8cb8234339c3c51c7974300c313a6", "filename": "src/test/ui/lint/uninitialized-zeroed.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/79f178b76ea9d5c6182f67413f62dd86b0e38508/src%2Ftest%2Fui%2Flint%2Funinitialized-zeroed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79f178b76ea9d5c6182f67413f62dd86b0e38508/src%2Ftest%2Fui%2Flint%2Funinitialized-zeroed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Funinitialized-zeroed.rs?ref=79f178b76ea9d5c6182f67413f62dd86b0e38508", "patch": "@@ -81,6 +81,9 @@ fn main() {\n         let _val: *const dyn Send = mem::zeroed(); //~ ERROR: does not permit zero-initialization\n         let _val: *const dyn Send = mem::uninitialized(); //~ ERROR: does not permit being left uninitialized\n \n+        let _val: [fn(); 2] = mem::zeroed(); //~ ERROR: does not permit zero-initialization\n+        let _val: [fn(); 2] = mem::uninitialized(); //~ ERROR: does not permit being left uninitialized\n+\n         // Things that can be zero, but not uninit.\n         let _val: bool = mem::zeroed();\n         let _val: bool = mem::uninitialized(); //~ ERROR: does not permit being left uninitialized\n@@ -94,6 +97,9 @@ fn main() {\n         let _val: Fruit = mem::zeroed();\n         let _val: Fruit = mem::uninitialized(); //~ ERROR: does not permit being left uninitialized\n \n+        let _val: [bool; 2] = mem::zeroed();\n+        let _val: [bool; 2] = mem::uninitialized(); //~ ERROR: does not permit being left uninitialized\n+\n         // Transmute-from-0\n         let _val: &'static i32 = mem::transmute(0usize); //~ ERROR: does not permit zero-initialization\n         let _val: &'static [i32] = mem::transmute((0usize, 0usize)); //~ ERROR: does not permit zero-initialization\n@@ -110,6 +116,8 @@ fn main() {\n         let _val: MaybeUninit<&'static i32> = mem::zeroed();\n         let _val: i32 = mem::zeroed();\n         let _val: bool = MaybeUninit::zeroed().assume_init();\n+        let _val: [bool; 0] = MaybeUninit::uninit().assume_init();\n+        let _val: [!; 0] = MaybeUninit::zeroed().assume_init();\n         // Some things that happen to work due to rustc implementation details,\n         // but are not guaranteed to keep working.\n         let _val: i32 = mem::uninitialized();"}, {"sha": "b6a66f0a95ad193890718915dc427ee0515cf964", "filename": "src/test/ui/lint/uninitialized-zeroed.stderr", "status": "modified", "additions": 44, "deletions": 11, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/79f178b76ea9d5c6182f67413f62dd86b0e38508/src%2Ftest%2Fui%2Flint%2Funinitialized-zeroed.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/79f178b76ea9d5c6182f67413f62dd86b0e38508/src%2Ftest%2Fui%2Flint%2Funinitialized-zeroed.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Funinitialized-zeroed.stderr?ref=79f178b76ea9d5c6182f67413f62dd86b0e38508", "patch": "@@ -329,8 +329,30 @@ LL |         let _val: *const dyn Send = mem::uninitialized();\n    |\n    = note: the vtable of a wide raw pointer must be non-null\n \n+error: the type `[fn(); 2]` does not permit zero-initialization\n+  --> $DIR/uninitialized-zeroed.rs:84:31\n+   |\n+LL |         let _val: [fn(); 2] = mem::zeroed();\n+   |                               ^^^^^^^^^^^^^\n+   |                               |\n+   |                               this code causes undefined behavior when executed\n+   |                               help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n+   |\n+   = note: function pointers must be non-null\n+\n+error: the type `[fn(); 2]` does not permit being left uninitialized\n+  --> $DIR/uninitialized-zeroed.rs:85:31\n+   |\n+LL |         let _val: [fn(); 2] = mem::uninitialized();\n+   |                               ^^^^^^^^^^^^^^^^^^^^\n+   |                               |\n+   |                               this code causes undefined behavior when executed\n+   |                               help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n+   |\n+   = note: function pointers must be non-null\n+\n error: the type `bool` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:86:26\n+  --> $DIR/uninitialized-zeroed.rs:89:26\n    |\n LL |         let _val: bool = mem::uninitialized();\n    |                          ^^^^^^^^^^^^^^^^^^^^\n@@ -341,7 +363,7 @@ LL |         let _val: bool = mem::uninitialized();\n    = note: booleans must be either `true` or `false`\n \n error: the type `Wrap<char>` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:89:32\n+  --> $DIR/uninitialized-zeroed.rs:92:32\n    |\n LL |         let _val: Wrap<char> = mem::uninitialized();\n    |                                ^^^^^^^^^^^^^^^^^^^^\n@@ -356,7 +378,7 @@ LL | struct Wrap<T> { wrapped: T }\n    |                  ^^^^^^^^^^\n \n error: the type `NonBig` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:92:28\n+  --> $DIR/uninitialized-zeroed.rs:95:28\n    |\n LL |         let _val: NonBig = mem::uninitialized();\n    |                            ^^^^^^^^^^^^^^^^^^^^\n@@ -367,7 +389,7 @@ LL |         let _val: NonBig = mem::uninitialized();\n    = note: `NonBig` must be initialized inside its custom valid range\n \n error: the type `Fruit` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:95:27\n+  --> $DIR/uninitialized-zeroed.rs:98:27\n    |\n LL |         let _val: Fruit = mem::uninitialized();\n    |                           ^^^^^^^^^^^^^^^^^^^^\n@@ -384,8 +406,19 @@ LL | |     Banana,\n LL | | }\n    | |_^\n \n+error: the type `[bool; 2]` does not permit being left uninitialized\n+  --> $DIR/uninitialized-zeroed.rs:101:31\n+   |\n+LL |         let _val: [bool; 2] = mem::uninitialized();\n+   |                               ^^^^^^^^^^^^^^^^^^^^\n+   |                               |\n+   |                               this code causes undefined behavior when executed\n+   |                               help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n+   |\n+   = note: booleans must be either `true` or `false`\n+\n error: the type `&i32` does not permit zero-initialization\n-  --> $DIR/uninitialized-zeroed.rs:98:34\n+  --> $DIR/uninitialized-zeroed.rs:104:34\n    |\n LL |         let _val: &'static i32 = mem::transmute(0usize);\n    |                                  ^^^^^^^^^^^^^^^^^^^^^^\n@@ -396,7 +429,7 @@ LL |         let _val: &'static i32 = mem::transmute(0usize);\n    = note: references must be non-null\n \n error: the type `&[i32]` does not permit zero-initialization\n-  --> $DIR/uninitialized-zeroed.rs:99:36\n+  --> $DIR/uninitialized-zeroed.rs:105:36\n    |\n LL |         let _val: &'static [i32] = mem::transmute((0usize, 0usize));\n    |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -407,7 +440,7 @@ LL |         let _val: &'static [i32] = mem::transmute((0usize, 0usize));\n    = note: references must be non-null\n \n error: the type `NonZeroU32` does not permit zero-initialization\n-  --> $DIR/uninitialized-zeroed.rs:100:32\n+  --> $DIR/uninitialized-zeroed.rs:106:32\n    |\n LL |         let _val: NonZeroU32 = mem::transmute(0);\n    |                                ^^^^^^^^^^^^^^^^^\n@@ -418,7 +451,7 @@ LL |         let _val: NonZeroU32 = mem::transmute(0);\n    = note: `std::num::NonZeroU32` must be non-null\n \n error: the type `NonNull<i32>` does not permit zero-initialization\n-  --> $DIR/uninitialized-zeroed.rs:103:34\n+  --> $DIR/uninitialized-zeroed.rs:109:34\n    |\n LL |         let _val: NonNull<i32> = MaybeUninit::zeroed().assume_init();\n    |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -429,7 +462,7 @@ LL |         let _val: NonNull<i32> = MaybeUninit::zeroed().assume_init();\n    = note: `std::ptr::NonNull<i32>` must be non-null\n \n error: the type `NonNull<i32>` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:104:34\n+  --> $DIR/uninitialized-zeroed.rs:110:34\n    |\n LL |         let _val: NonNull<i32> = MaybeUninit::uninit().assume_init();\n    |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -440,7 +473,7 @@ LL |         let _val: NonNull<i32> = MaybeUninit::uninit().assume_init();\n    = note: `std::ptr::NonNull<i32>` must be non-null\n \n error: the type `bool` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:105:26\n+  --> $DIR/uninitialized-zeroed.rs:111:26\n    |\n LL |         let _val: bool = MaybeUninit::uninit().assume_init();\n    |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -450,5 +483,5 @@ LL |         let _val: bool = MaybeUninit::uninit().assume_init();\n    |\n    = note: booleans must be either `true` or `false`\n \n-error: aborting due to 36 previous errors\n+error: aborting due to 39 previous errors\n "}, {"sha": "905c14dc5fd219da60c363dd78bcc9d2c2e4747f", "filename": "src/test/ui/macros/issue-95533.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/79f178b76ea9d5c6182f67413f62dd86b0e38508/src%2Ftest%2Fui%2Fmacros%2Fissue-95533.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79f178b76ea9d5c6182f67413f62dd86b0e38508/src%2Ftest%2Fui%2Fmacros%2Fissue-95533.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fissue-95533.rs?ref=79f178b76ea9d5c6182f67413f62dd86b0e38508", "patch": "@@ -0,0 +1,8 @@\n+// check-pass\n+\n+#![no_implicit_prelude]\n+// the macro should not rely on the prelude being imported\n+::std::thread_local! { static P: () = (); }\n+::std::thread_local! { static Q: () = const { () }; }\n+\n+fn main () {}"}]}