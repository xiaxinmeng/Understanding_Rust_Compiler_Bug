{"sha": "ac86b8edffcfd8076436c4154ec0236a91cc3c62", "node_id": "C_kwDOAAsO6NoAKGFjODZiOGVkZmZjZmQ4MDc2NDM2YzQxNTRlYzAyMzZhOTFjYzNjNjI", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-25T10:41:05Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-25T10:41:05Z"}, "message": "Auto merge of #12856 - Veykril:multi-proc-srv, r=Veykril\n\nfeat: Spawn a proc-macro-srv instance per workspace\n\ncc https://github.com/rust-lang/rust-analyzer/issues/12855\n\nThe idea is to have each server be spawned with the appropriate toolchain, that way workspaces with differing toolchains shouldn't suffer from proc-macro abi mismatches.", "tree": {"sha": "3ae4ddb89e9ff006e0edac0f1891214033992045", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3ae4ddb89e9ff006e0edac0f1891214033992045"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ac86b8edffcfd8076436c4154ec0236a91cc3c62", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ac86b8edffcfd8076436c4154ec0236a91cc3c62", "html_url": "https://github.com/rust-lang/rust/commit/ac86b8edffcfd8076436c4154ec0236a91cc3c62", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ac86b8edffcfd8076436c4154ec0236a91cc3c62/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c7788ad3bed256d5e7e9698a52c3e2bfaeb0bb75", "url": "https://api.github.com/repos/rust-lang/rust/commits/c7788ad3bed256d5e7e9698a52c3e2bfaeb0bb75", "html_url": "https://github.com/rust-lang/rust/commit/c7788ad3bed256d5e7e9698a52c3e2bfaeb0bb75"}, {"sha": "50b27e57baa83d63fecf77c712c345d480f2c3c6", "url": "https://api.github.com/repos/rust-lang/rust/commits/50b27e57baa83d63fecf77c712c345d480f2c3c6", "html_url": "https://github.com/rust-lang/rust/commit/50b27e57baa83d63fecf77c712c345d480f2c3c6"}], "stats": {"total": 59, "additions": 31, "deletions": 28}, "files": [{"sha": "0ada4b73e842d9d7f814bf71f74c9dc4441158c3", "filename": "crates/rust-analyzer/src/cli/load_cargo.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ac86b8edffcfd8076436c4154ec0236a91cc3c62/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fload_cargo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac86b8edffcfd8076436c4154ec0236a91cc3c62/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fload_cargo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fload_cargo.rs?ref=ac86b8edffcfd8076436c4154ec0236a91cc3c62", "patch": "@@ -60,9 +60,9 @@ pub fn load_workspace(\n \n     let proc_macro_client = if load_config.with_proc_macro {\n         let path = AbsPathBuf::assert(std::env::current_exe()?);\n-        Some(ProcMacroServer::spawn(path, &[\"proc-macro\"]).unwrap())\n+        Ok(ProcMacroServer::spawn(path, &[\"proc-macro\"]).unwrap())\n     } else {\n-        None\n+        Err(\"proc macro server not started\".to_owned())\n     };\n \n     let crate_graph = ws.to_crate_graph(\n@@ -89,7 +89,7 @@ pub fn load_workspace(\n     if load_config.prefill_caches {\n         host.analysis().parallel_prime_caches(1, |_| {})?;\n     }\n-    Ok((host, vfs, proc_macro_client))\n+    Ok((host, vfs, proc_macro_client.ok()))\n }\n \n fn load_crate_graph("}, {"sha": "8f881cba4dbd7b113534e3cfdf1d6aa85bf95d27", "filename": "crates/rust-analyzer/src/global_state.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ac86b8edffcfd8076436c4154ec0236a91cc3c62/crates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac86b8edffcfd8076436c4154ec0236a91cc3c62/crates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs?ref=ac86b8edffcfd8076436c4154ec0236a91cc3c62", "patch": "@@ -61,7 +61,7 @@ pub(crate) struct GlobalState {\n     pub(crate) proc_macro_changed: bool,\n     pub(crate) last_reported_status: Option<lsp_ext::ServerStatusParams>,\n     pub(crate) source_root_config: SourceRootConfig,\n-    pub(crate) proc_macro_client: Option<ProcMacroServer>,\n+    pub(crate) proc_macro_clients: Vec<Result<ProcMacroServer, String>>,\n \n     pub(crate) flycheck: Vec<FlycheckHandle>,\n     pub(crate) flycheck_sender: Sender<flycheck::Message>,\n@@ -151,7 +151,7 @@ impl GlobalState {\n             proc_macro_changed: false,\n             last_reported_status: None,\n             source_root_config: SourceRootConfig::default(),\n-            proc_macro_client: None,\n+            proc_macro_clients: vec![],\n \n             flycheck: Vec::new(),\n             flycheck_sender,"}, {"sha": "deb777c952fdf7d7658f92b77b8d50f68244499c", "filename": "crates/rust-analyzer/src/handlers.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac86b8edffcfd8076436c4154ec0236a91cc3c62/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac86b8edffcfd8076436c4154ec0236a91cc3c62/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs?ref=ac86b8edffcfd8076436c4154ec0236a91cc3c62", "patch": "@@ -44,7 +44,7 @@ use crate::{\n };\n \n pub(crate) fn handle_workspace_reload(state: &mut GlobalState, _: ()) -> Result<()> {\n-    state.proc_macro_client = None;\n+    state.proc_macro_clients.clear();\n     state.proc_macro_changed = false;\n     state.fetch_workspaces_queue.request_op(\"reload workspace request\".to_string());\n     state.fetch_build_data_queue.request_op(\"reload workspace request\".to_string());"}, {"sha": "e5802773e74739168bc7b68e94a0d6cd2ba9daa6", "filename": "crates/rust-analyzer/src/reload.rs", "status": "modified", "additions": 25, "deletions": 22, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/ac86b8edffcfd8076436c4154ec0236a91cc3c62/crates%2Frust-analyzer%2Fsrc%2Freload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac86b8edffcfd8076436c4154ec0236a91cc3c62/crates%2Frust-analyzer%2Fsrc%2Freload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Freload.rs?ref=ac86b8edffcfd8076436c4154ec0236a91cc3c62", "patch": "@@ -303,18 +303,21 @@ impl GlobalState {\n         let files_config = self.config.files();\n         let project_folders = ProjectFolders::new(&self.workspaces, &files_config.exclude);\n \n-        if self.proc_macro_client.is_none() {\n+        if self.proc_macro_clients.is_empty() {\n             if let Some((path, args)) = self.config.proc_macro_srv() {\n-                match ProcMacroServer::spawn(path.clone(), args) {\n-                    Ok(it) => self.proc_macro_client = Some(it),\n-                    Err(err) => {\n-                        tracing::error!(\n-                            \"Failed to run proc_macro_srv from path {}, error: {:?}\",\n-                            path.display(),\n-                            err\n-                        );\n-                    }\n-                }\n+                self.proc_macro_clients = (0..self.workspaces.len())\n+                    .map(|_| {\n+                        ProcMacroServer::spawn(path.clone(), args.clone()).map_err(|err| {\n+                            let error = format!(\n+                                \"Failed to run proc_macro_srv from path {}, error: {:?}\",\n+                                path.display(),\n+                                err\n+                            );\n+                            tracing::error!(error);\n+                            error\n+                        })\n+                    })\n+                    .collect();\n             }\n         }\n \n@@ -331,15 +334,7 @@ impl GlobalState {\n \n         // Create crate graph from all the workspaces\n         let crate_graph = {\n-            let proc_macro_client = self.proc_macro_client.as_ref();\n             let dummy_replacements = self.config.dummy_replacements();\n-            let mut load_proc_macro = move |crate_name: &str, path: &AbsPath| {\n-                load_proc_macro(\n-                    proc_macro_client,\n-                    path,\n-                    dummy_replacements.get(crate_name).map(|v| &**v).unwrap_or_default(),\n-                )\n-            };\n \n             let vfs = &mut self.vfs.write().0;\n             let loader = &mut self.loader;\n@@ -359,7 +354,15 @@ impl GlobalState {\n             };\n \n             let mut crate_graph = CrateGraph::default();\n-            for ws in self.workspaces.iter() {\n+            for (idx, ws) in self.workspaces.iter().enumerate() {\n+                let proc_macro_client = self.proc_macro_clients[idx].as_ref();\n+                let mut load_proc_macro = move |crate_name: &str, path: &AbsPath| {\n+                    load_proc_macro(\n+                        proc_macro_client,\n+                        path,\n+                        dummy_replacements.get(crate_name).map(|v| &**v).unwrap_or_default(),\n+                    )\n+                };\n                 crate_graph.extend(ws.to_crate_graph(&mut load_proc_macro, &mut load));\n             }\n             crate_graph\n@@ -536,14 +539,14 @@ impl SourceRootConfig {\n /// Load the proc-macros for the given lib path, replacing all expanders whose names are in `dummy_replace`\n /// with an identity dummy expander.\n pub(crate) fn load_proc_macro(\n-    server: Option<&ProcMacroServer>,\n+    server: Result<&ProcMacroServer, &String>,\n     path: &AbsPath,\n     dummy_replace: &[Box<str>],\n ) -> ProcMacroLoadResult {\n     let res: Result<Vec<_>, String> = (|| {\n         let dylib = MacroDylib::new(path.to_path_buf())\n             .map_err(|io| format!(\"Proc-macro dylib loading failed: {io}\"))?;\n-        let server = server.ok_or_else(|| format!(\"Proc-macro server not started\"))?;\n+        let server = server.map_err(ToOwned::to_owned)?;\n         let vec = server.load_dylib(dylib).map_err(|e| format!(\"{e}\"))?;\n         if vec.is_empty() {\n             return Err(\"proc macro library returned no proc macros\".to_string());"}]}