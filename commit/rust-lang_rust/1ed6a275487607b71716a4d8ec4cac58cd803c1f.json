{"sha": "1ed6a275487607b71716a4d8ec4cac58cd803c1f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFlZDZhMjc1NDg3NjA3YjcxNzE2YTRkOGVjNGNhYzU4Y2Q4MDNjMWY=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-12-28T16:50:12Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-12-28T20:18:16Z"}, "message": "Change representation of type params to handle interface bounds\n\nIssue #1227", "tree": {"sha": "c58f05a60a423ed141071ea2cb16765a3ead5b2c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c58f05a60a423ed141071ea2cb16765a3ead5b2c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1ed6a275487607b71716a4d8ec4cac58cd803c1f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1ed6a275487607b71716a4d8ec4cac58cd803c1f", "html_url": "https://github.com/rust-lang/rust/commit/1ed6a275487607b71716a4d8ec4cac58cd803c1f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1ed6a275487607b71716a4d8ec4cac58cd803c1f/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5930463faa07ce95268b6011db37c5be183f9f10", "url": "https://api.github.com/repos/rust-lang/rust/commits/5930463faa07ce95268b6011db37c5be183f9f10", "html_url": "https://github.com/rust-lang/rust/commit/5930463faa07ce95268b6011db37c5be183f9f10"}], "stats": {"total": 546, "additions": 317, "deletions": 229}, "files": [{"sha": "ba9d57bb9b32387cdc37a504ae89bd1614ece67a", "filename": "src/comp/metadata/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1ed6a275487607b71716a4d8ec4cac58cd803c1f/src%2Fcomp%2Fmetadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ed6a275487607b71716a4d8ec4cac58cd803c1f/src%2Fcomp%2Fmetadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fcommon.rs?ref=1ed6a275487607b71716a4d8ec4cac58cd803c1f", "patch": "@@ -22,7 +22,7 @@ const tag_items_data_item: uint = 0x09u;\n \n const tag_items_data_item_family: uint = 0x0au;\n \n-const tag_items_data_item_ty_param_kinds: uint = 0x0bu;\n+const tag_items_data_item_ty_param_bounds: uint = 0x0bu;\n \n const tag_items_data_item_type: uint = 0x0cu;\n "}, {"sha": "2603903cf656b5717b661b5f9930d9f7483a77ec", "filename": "src/comp/metadata/csearch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1ed6a275487607b71716a4d8ec4cac58cd803c1f/src%2Fcomp%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ed6a275487607b71716a4d8ec4cac58cd803c1f/src%2Fcomp%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fcsearch.rs?ref=1ed6a275487607b71716a4d8ec4cac58cd803c1f", "patch": "@@ -86,7 +86,7 @@ fn get_impl_methods(cstore: cstore::cstore, def: ast::def_id)\n     decoder::lookup_impl_methods(cdata, def.node, def.crate)\n }\n \n-fn get_type(tcx: ty::ctxt, def: ast::def_id) -> ty::ty_param_kinds_and_ty {\n+fn get_type(tcx: ty::ctxt, def: ast::def_id) -> ty::ty_param_bounds_and_ty {\n     let cstore = tcx.sess.get_cstore();\n     let cnum = def.crate;\n     let cdata = cstore::get_crate_data(cstore, cnum).data;"}, {"sha": "b5bf3a1de1303e10e8555f645593bc4e73909a73", "filename": "src/comp/metadata/decoder.rs", "status": "modified", "additions": 33, "deletions": 48, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/1ed6a275487607b71716a4d8ec4cac58cd803c1f/src%2Fcomp%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ed6a275487607b71716a4d8ec4cac58cd803c1f/src%2Fcomp%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fdecoder.rs?ref=1ed6a275487607b71716a4d8ec4cac58cd803c1f", "patch": "@@ -14,7 +14,6 @@ export get_symbol;\n export get_tag_variants;\n export get_type;\n export get_type_param_count;\n-export get_type_param_kinds;\n export lookup_def;\n export lookup_item_name;\n export resolve_path;\n@@ -90,21 +89,22 @@ fn variant_tag_id(d: ebml::doc) -> ast::def_id {\n     ret parse_def_id(ebml::doc_data(tagdoc));\n }\n \n+fn parse_external_def_id(this_cnum: ast::crate_num,\n+                         extres: external_resolver, s: str) ->\n+    ast::def_id {\n+    let buf = str::bytes(s);\n+    let external_def_id = parse_def_id(buf);\n+\n+\n+    // This item was defined in the crate we're searching if it's has the\n+    // local crate number, otherwise we need to search a different crate\n+    if external_def_id.crate == ast::local_crate {\n+        ret {crate: this_cnum, node: external_def_id.node};\n+    } else { ret extres(external_def_id); }\n+}\n+\n fn item_type(item: ebml::doc, this_cnum: ast::crate_num, tcx: ty::ctxt,\n              extres: external_resolver) -> ty::t {\n-    fn parse_external_def_id(this_cnum: ast::crate_num,\n-                             extres: external_resolver, s: str) ->\n-       ast::def_id {\n-        let buf = str::bytes(s);\n-        let external_def_id = parse_def_id(buf);\n-\n-\n-        // This item was defined in the crate we're searching if it's has the\n-        // local crate number, otherwise we need to search a different crate\n-        if external_def_id.crate == ast::local_crate {\n-            ret {crate: this_cnum, node: external_def_id.node};\n-        } else { ret extres(external_def_id); }\n-    }\n     let tp = ebml::get_doc(item, tag_items_data_item_type);\n     let def_parser = bind parse_external_def_id(this_cnum, extres, _);\n     let t = parse_ty_data(item.data, this_cnum, tp.start, tp.end - tp.start,\n@@ -115,32 +115,24 @@ fn item_type(item: ebml::doc, this_cnum: ast::crate_num, tcx: ty::ctxt,\n     t\n }\n \n-fn item_ty_param_kinds(item: ebml::doc) -> [ast::kind] {\n-    let ks: [ast::kind] = [];\n-    let tp = tag_items_data_item_ty_param_kinds;\n-    ebml::tagged_docs(item, tp) {|p|\n-        let dat: [u8] = ebml::doc_data(p);\n-        let vi = ebml::vint_at(dat, 0u);\n-        let i = 0u;\n-        while i < vi.val {\n-            let k =\n-                alt dat[vi.next + i] as char {\n-                  's' { ast::kind_sendable }\n-                  'c' { ast::kind_copyable }\n-                  'a' { ast::kind_noncopyable }\n-                };\n-            ks += [k];\n-            i += 1u;\n-        }\n-    };\n-    ret ks;\n+fn item_ty_param_bounds(item: ebml::doc, this_cnum: ast::crate_num,\n+                        tcx: ty::ctxt, extres: external_resolver)\n+    -> [@[ty::param_bound]] {\n+    let bounds = [];\n+    let def_parser = bind parse_external_def_id(this_cnum, extres, _);\n+    ebml::tagged_docs(item, tag_items_data_item_ty_param_bounds) {|p|\n+        bounds += [tydecode::parse_bounds_data(@ebml::doc_data(p), this_cnum,\n+                                               def_parser, tcx)];\n+    }\n+    bounds\n }\n \n fn item_ty_param_count(item: ebml::doc) -> uint {\n     let n = 0u;\n-    let tp = tag_items_data_item_ty_param_kinds;\n-    ebml::tagged_docs(item, tp) {|p|\n-        n += ebml::vint_at(ebml::doc_data(p), 0u).val;\n+    ebml::tagged_docs(item, tag_items_data_item_ty_param_bounds) {|p|\n+        for byte in ebml::doc_data(p) {\n+            if byte as char == '.' { n += 1u; }\n+        }\n     }\n     n\n }\n@@ -213,28 +205,21 @@ fn lookup_def(cnum: ast::crate_num, data: @[u8], did_: ast::def_id) ->\n }\n \n fn get_type(data: @[u8], def: ast::def_id, tcx: ty::ctxt,\n-            extres: external_resolver) -> ty::ty_param_kinds_and_ty {\n+            extres: external_resolver) -> ty::ty_param_bounds_and_ty {\n     let this_cnum = def.crate;\n     let node_id = def.node;\n     let item = lookup_item(node_id, data);\n     let t = item_type(item, this_cnum, tcx, extres);\n-    let tp_kinds: [ast::kind];\n-    let fam_ch = item_family(item);\n-    let has_ty_params = family_has_type_params(fam_ch);\n-    if has_ty_params {\n-        tp_kinds = item_ty_param_kinds(item);\n-    } else { tp_kinds = []; }\n-    ret {kinds: tp_kinds, ty: t};\n+    let tp_bounds = if family_has_type_params(item_family(item)) {\n+        item_ty_param_bounds(item, this_cnum, tcx, extres)\n+    } else { [] };\n+    ret {bounds: tp_bounds, ty: t};\n }\n \n fn get_type_param_count(data: @[u8], id: ast::node_id) -> uint {\n     item_ty_param_count(lookup_item(id, data))\n }\n \n-fn get_type_param_kinds(data: @[u8], id: ast::node_id) -> [ast::kind] {\n-    ret item_ty_param_kinds(lookup_item(id, data));\n-}\n-\n fn get_symbol(data: @[u8], id: ast::node_id) -> str {\n     ret item_symbol(lookup_item(id, data));\n }"}, {"sha": "60994d3b17ce3f408b8cdcabd7090f4b0bb1abf9", "filename": "src/comp/metadata/encoder.rs", "status": "modified", "additions": 22, "deletions": 24, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/1ed6a275487607b71716a4d8ec4cac58cd803c1f/src%2Fcomp%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ed6a275487607b71716a4d8ec4cac58cd803c1f/src%2Fcomp%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fencoder.rs?ref=1ed6a275487607b71716a4d8ec4cac58cd803c1f", "patch": "@@ -183,18 +183,17 @@ fn encode_family(ebml_w: ebml::writer, c: u8) {\n \n fn def_to_str(did: def_id) -> str { ret #fmt[\"%d:%d\", did.crate, did.node]; }\n \n-fn encode_type_param_kinds(ebml_w: ebml::writer, tps: [ty_param]) {\n-    ebml::start_tag(ebml_w, tag_items_data_item_ty_param_kinds);\n-    ebml::write_vint(ebml_w.writer, vec::len::<ty_param>(tps));\n-    for tp: ty_param in tps {\n-        let c = alt ast_util::ty_param_kind(tp) {\n-          kind_sendable. { 's' }\n-          kind_copyable. { 'c' }\n-          kind_noncopyable. { 'a' }\n-        };\n-        ebml_w.writer.write([c as u8]);\n+fn encode_type_param_bounds(ebml_w: ebml::writer, ecx: @encode_ctxt,\n+                            params: [ty_param]) {\n+    let ty_str_ctxt = @{ds: def_to_str,\n+                        tcx: ecx.ccx.tcx,\n+                        abbrevs: tyencode::ac_use_abbrevs(ecx.type_abbrevs)};\n+    for param in params {\n+        ebml::start_tag(ebml_w, tag_items_data_item_ty_param_bounds);\n+        let bs = ecx.ccx.tcx.ty_param_bounds.get(local_def(param.id));\n+        tyencode::enc_bounds(io::new_writer(ebml_w.writer), ty_str_ctxt, bs);\n+        ebml::end_tag(ebml_w);\n     }\n-    ebml::end_tag(ebml_w);\n }\n \n fn encode_variant_id(ebml_w: ebml::writer, vid: def_id) {\n@@ -205,9 +204,8 @@ fn encode_variant_id(ebml_w: ebml::writer, vid: def_id) {\n \n fn encode_type(ecx: @encode_ctxt, ebml_w: ebml::writer, typ: ty::t) {\n     ebml::start_tag(ebml_w, tag_items_data_item_type);\n-    let f = def_to_str;\n     let ty_str_ctxt =\n-        @{ds: f,\n+        @{ds: def_to_str,\n           tcx: ecx.ccx.tcx,\n           abbrevs: tyencode::ac_use_abbrevs(ecx.type_abbrevs)};\n     tyencode::enc_ty(io::new_writer(ebml_w.writer), ty_str_ctxt, typ);\n@@ -247,7 +245,7 @@ fn encode_tag_variant_info(ecx: @encode_ctxt, ebml_w: ebml::writer,\n             encode_symbol(ecx, ebml_w, variant.node.id);\n         }\n         encode_discriminant(ecx, ebml_w, variant.node.id);\n-        encode_type_param_kinds(ebml_w, ty_params);\n+        encode_type_param_bounds(ebml_w, ecx, ty_params);\n         ebml::end_tag(ebml_w);\n     }\n }\n@@ -293,7 +291,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n                         pure_fn. { 'p' }\n                         impure_fn. { 'f' }\n                       } as u8);\n-        encode_type_param_kinds(ebml_w, tps);\n+        encode_type_param_bounds(ebml_w, ecx, tps);\n         encode_type(ecx, ebml_w, node_id_to_monotype(ecx.ccx.tcx, item.id));\n         encode_symbol(ecx, ebml_w, item.id);\n         ebml::end_tag(ebml_w);\n@@ -312,7 +310,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n         ebml::start_tag(ebml_w, tag_items_data_item);\n         encode_def_id(ebml_w, local_def(item.id));\n         encode_family(ebml_w, 'y' as u8);\n-        encode_type_param_kinds(ebml_w, tps);\n+        encode_type_param_bounds(ebml_w, ecx, tps);\n         encode_type(ecx, ebml_w, node_id_to_monotype(ecx.ccx.tcx, item.id));\n         encode_name(ebml_w, item.ident);\n         ebml::end_tag(ebml_w);\n@@ -321,7 +319,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n         ebml::start_tag(ebml_w, tag_items_data_item);\n         encode_def_id(ebml_w, local_def(item.id));\n         encode_family(ebml_w, 't' as u8);\n-        encode_type_param_kinds(ebml_w, tps);\n+        encode_type_param_bounds(ebml_w, ecx, tps);\n         encode_type(ecx, ebml_w, node_id_to_monotype(ecx.ccx.tcx, item.id));\n         encode_name(ebml_w, item.ident);\n         for v: variant in variants {\n@@ -336,7 +334,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n         ebml::start_tag(ebml_w, tag_items_data_item);\n         encode_def_id(ebml_w, local_def(ctor_id));\n         encode_family(ebml_w, 'y' as u8);\n-        encode_type_param_kinds(ebml_w, tps);\n+        encode_type_param_bounds(ebml_w, ecx, tps);\n         encode_type(ecx, ebml_w, ty::ty_fn_ret(ecx.ccx.tcx, fn_ty));\n         encode_name(ebml_w, item.ident);\n         encode_symbol(ecx, ebml_w, item.id);\n@@ -346,7 +344,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n         ebml::start_tag(ebml_w, tag_items_data_item);\n         encode_def_id(ebml_w, local_def(ctor_id));\n         encode_family(ebml_w, 'f' as u8);\n-        encode_type_param_kinds(ebml_w, tps);\n+        encode_type_param_bounds(ebml_w, ecx, tps);\n         encode_type(ecx, ebml_w, fn_ty);\n         encode_symbol(ecx, ebml_w, ctor_id);\n         ebml::end_tag(ebml_w);\n@@ -357,7 +355,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n         ebml::start_tag(ebml_w, tag_items_data_item);\n         encode_def_id(ebml_w, local_def(item.id));\n         encode_family(ebml_w, 'y' as u8);\n-        encode_type_param_kinds(ebml_w, tps);\n+        encode_type_param_bounds(ebml_w, ecx, tps);\n         encode_type(ecx, ebml_w, ty::ty_fn_ret(ecx.ccx.tcx, fn_ty));\n         encode_name(ebml_w, item.ident);\n         ebml::end_tag(ebml_w);\n@@ -366,7 +364,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n         ebml::start_tag(ebml_w, tag_items_data_item);\n         encode_def_id(ebml_w, local_def(ctor_id));\n         encode_family(ebml_w, 'f' as u8);\n-        encode_type_param_kinds(ebml_w, tps);\n+        encode_type_param_bounds(ebml_w, ecx, tps);\n         encode_type(ecx, ebml_w, fn_ty);\n         encode_symbol(ecx, ebml_w, ctor_id);\n         ebml::end_tag(ebml_w);\n@@ -375,7 +373,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n         ebml::start_tag(ebml_w, tag_items_data_item);\n         encode_def_id(ebml_w, local_def(item.id));\n         encode_family(ebml_w, 'i' as u8);\n-        encode_type_param_kinds(ebml_w, tps);\n+        encode_type_param_bounds(ebml_w, ecx, tps);\n         encode_type(ecx, ebml_w, node_id_to_monotype(ecx.ccx.tcx, item.id));\n         encode_name(ebml_w, item.ident);\n         for m in methods {\n@@ -390,7 +388,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n             ebml::start_tag(ebml_w, tag_items_data_item);\n             encode_def_id(ebml_w, local_def(m.id));\n             encode_family(ebml_w, 'f' as u8);\n-            encode_type_param_kinds(ebml_w, tps + m.tps);\n+            encode_type_param_bounds(ebml_w, ecx, tps + m.tps);\n             encode_type(ecx, ebml_w,\n                         node_id_to_monotype(ecx.ccx.tcx, m.id));\n             encode_name(ebml_w, m.ident);\n@@ -421,7 +419,7 @@ fn encode_info_for_native_item(ecx: @encode_ctxt, ebml_w: ebml::writer,\n             } as u8;\n         encode_def_id(ebml_w, local_def(nitem.id));\n         encode_family(ebml_w, letter);\n-        encode_type_param_kinds(ebml_w, tps);\n+        encode_type_param_bounds(ebml_w, ecx, tps);\n         encode_type(ecx, ebml_w, node_id_to_monotype(ecx.ccx.tcx, nitem.id));\n         encode_symbol(ecx, ebml_w, nitem.id);\n       }"}, {"sha": "4f4c7f41c5e1145ad7a638f1e9ea51ceead5ad18", "filename": "src/comp/metadata/tydecode.rs", "status": "modified", "additions": 27, "deletions": 15, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/1ed6a275487607b71716a4d8ec4cac58cd803c1f/src%2Fcomp%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ed6a275487607b71716a4d8ec4cac58cd803c1f/src%2Fcomp%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Ftydecode.rs?ref=1ed6a275487607b71716a4d8ec4cac58cd803c1f", "patch": "@@ -10,6 +10,7 @@ import middle::ty;\n \n export parse_def_id;\n export parse_ty_data;\n+export parse_bounds_data;\n \n // Compact string representation for ty::t values. API ty_str &\n // parse_from_str. Extra parameters are for converting to/from def_ids in the\n@@ -21,7 +22,9 @@ type str_def = fn@(str) -> ast::def_id;\n type pstate =\n     {data: @[u8], crate: int, mutable pos: uint, len: uint, tcx: ty::ctxt};\n \n-fn peek(st: @pstate) -> u8 { ret st.data[st.pos]; }\n+fn peek(st: @pstate) -> u8 {\n+    if st.pos < vec::len(*st.data) { st.data[st.pos] } else { 0u8 }\n+}\n \n fn next(st: @pstate) -> u8 {\n     let ch = st.data[st.pos];\n@@ -48,8 +51,7 @@ fn parse_ty_data(data: @[u8], crate_num: int, pos: uint, len: uint,\n                  sd: str_def, tcx: ty::ctxt) -> ty::t {\n     let st =\n         @{data: data, crate: crate_num, mutable pos: pos, len: len, tcx: tcx};\n-    let result = parse_ty(st, sd);\n-    ret result;\n+    parse_ty(st, sd)\n }\n \n fn parse_ret_ty(st: @pstate, sd: str_def) -> (ast::ret_style, ty::t) {\n@@ -201,18 +203,8 @@ fn parse_ty(st: @pstate, sd: str_def) -> ty::t {\n         ret ty::mk_tag(st.tcx, def, params);\n       }\n       'p' {\n-        let k =\n-            alt next(st) as char {\n-              's' { kind_sendable }\n-              'c' { kind_copyable }\n-              'a' { kind_noncopyable }\n-              c {\n-                #error(\"unexpected char in encoded type param: \");\n-                log(error, c);\n-                fail\n-              }\n-            };\n-        ret ty::mk_param(st.tcx, parse_int(st) as uint, k);\n+        let bounds = parse_bounds(st, sd);\n+        ret ty::mk_param(st.tcx, parse_int(st) as uint, bounds);\n       }\n       '@' { ret ty::mk_box(st.tcx, parse_mt(st, sd)); }\n       '~' { ret ty::mk_uniq(st.tcx, parse_mt(st, sd)); }\n@@ -400,6 +392,26 @@ fn parse_def_id(buf: [u8]) -> ast::def_id {\n     ret {crate: crate_num, node: def_num};\n }\n \n+fn parse_bounds_data(data: @[u8], crate_num: int, sd: str_def, tcx: ty::ctxt)\n+    -> @[ty::param_bound] {\n+    let st = @{data: data, crate: crate_num, mutable pos: 0u,\n+               len: vec::len(*data), tcx: tcx};\n+    parse_bounds(st, sd)\n+}\n+\n+fn parse_bounds(st: @pstate, sd: str_def) -> @[ty::param_bound] {\n+    let bounds = [];\n+    while peek(st) as char == '.' {\n+        next(st);\n+        bounds += [alt next(st) as char {\n+          'S' { ty::bound_send }\n+          'C' { ty::bound_copy }\n+          'I' { ty::bound_iface(parse_ty(st, sd)) }\n+        }];\n+    }\n+    @bounds\n+}\n+\n //\n // Local Variables:\n // mode: rust"}, {"sha": "88885153e77a283a5744fd975374afdda0c8161d", "filename": "src/comp/metadata/tyencode.rs", "status": "modified", "additions": 17, "deletions": 6, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/1ed6a275487607b71716a4d8ec4cac58cd803c1f/src%2Fcomp%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ed6a275487607b71716a4d8ec4cac58cd803c1f/src%2Fcomp%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Ftyencode.rs?ref=1ed6a275487607b71716a4d8ec4cac58cd803c1f", "patch": "@@ -13,6 +13,7 @@ export ty_abbrev;\n export ac_no_abbrevs;\n export ac_use_abbrevs;\n export enc_ty;\n+export enc_bounds;\n \n type ctxt =\n     // Def -> str Callback:\n@@ -175,12 +176,9 @@ fn enc_sty(w: io::writer, cx: @ctxt, st: ty::sty) {\n         w.write_str(cx.ds(def));\n         w.write_char('|');\n       }\n-      ty::ty_param(id, k) {\n-        alt k {\n-          kind_sendable. { w.write_str(\"ps\"); }\n-          kind_copyable. { w.write_str(\"pc\"); }\n-          kind_noncopyable. { w.write_str(\"pa\"); }\n-        }\n+      ty::ty_param(id, bounds) {\n+        w.write_char('p');\n+        enc_bounds(w, cx, bounds);\n         w.write_str(uint::str(id));\n       }\n       ty::ty_type. { w.write_char('Y'); }\n@@ -265,6 +263,19 @@ fn enc_ty_constr(w: io::writer, cx: @ctxt, c: @ty::type_constr) {\n     w.write_char(')');\n }\n \n+fn enc_bounds(w: io::writer, cx: @ctxt, bs: @[ty::param_bound]) {\n+    for bound in *bs {\n+        w.write_char('.');\n+        alt bound {\n+          ty::bound_send. { w.write_char('S'); }\n+          ty::bound_copy. { w.write_char('C'); }\n+          ty::bound_iface(tp) {\n+            w.write_char('I');\n+            enc_ty(w, cx, tp);\n+          }\n+        }\n+    }\n+}\n \n //\n // Local Variables:"}, {"sha": "3a6d41419f28d29ac59077a224f01229ed502957", "filename": "src/comp/middle/kind.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1ed6a275487607b71716a4d8ec4cac58cd803c1f/src%2Fcomp%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ed6a275487607b71716a4d8ec4cac58cd803c1f/src%2Fcomp%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fkind.rs?ref=1ed6a275487607b71716a4d8ec4cac58cd803c1f", "patch": "@@ -162,7 +162,9 @@ fn check_expr(e: @expr, cx: ctx, v: visit::vt<ctx>) {\n         alt substs.substs {\n           some(ts) {\n             let did = ast_util::def_id_of_def(cx.tcx.def_map.get(e.id));\n-            let kinds = ty::lookup_item_type(cx.tcx, did).kinds, i = 0u;\n+            let kinds = vec::map(ty::lookup_item_type(cx.tcx, did).bounds,\n+                                 {|bs| ty::param_bounds_to_kind(bs)});\n+            let i = 0u;\n             for ty in ts {\n                 let kind = ty::type_kind(cx.tcx, ty);\n                 if !ty::kind_lteq(kinds[i], kind) {"}, {"sha": "9eaaee2cb3650ed0fe657c9671e8719d7b81d499", "filename": "src/comp/middle/resolve.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1ed6a275487607b71716a4d8ec4cac58cd803c1f/src%2Fcomp%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ed6a275487607b71716a4d8ec4cac58cd803c1f/src%2Fcomp%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fresolve.rs?ref=1ed6a275487607b71716a4d8ec4cac58cd803c1f", "patch": "@@ -399,6 +399,7 @@ fn visit_item_with_scope(i: @ast::item, sc: scopes, v: vt<scopes>) {\n     let sc = cons(scope_item(i), @sc);\n     alt i.node {\n       ast::item_impl(tps, ifce, sty, methods) {\n+        visit::visit_ty_params(tps, sc, v);\n         alt ifce { some(ty) { v.visit_ty(ty, sc, v); } _ {} }\n         v.visit_ty(sty, sc, v);\n         for m in methods {\n@@ -901,12 +902,12 @@ fn lookup_in_scope(e: env, sc: scopes, sp: span, name: ident, ns: namespace)\n \n fn lookup_in_ty_params(name: ident, ty_params: [ast::ty_param]) ->\n    option::t<def> {\n-    let i = 0u;\n+    let n = 0u;\n     for tp: ast::ty_param in ty_params {\n         if str::eq(tp.ident, name) {\n-            ret some(ast::def_ty_param(i, ast_util::ty_param_kind(tp)));\n+            ret some(ast::def_ty_param(local_def(tp.id), n));\n         }\n-        i += 1u;\n+        n += 1u;\n     }\n     ret none::<def>;\n }"}, {"sha": "94529b8be6033249eaf012d7d9368bee61919913", "filename": "src/comp/middle/shape.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1ed6a275487607b71716a4d8ec4cac58cd803c1f/src%2Fcomp%2Fmiddle%2Fshape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ed6a275487607b71716a4d8ec4cac58cd803c1f/src%2Fcomp%2Fmiddle%2Fshape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fshape.rs?ref=1ed6a275487607b71716a4d8ec4cac58cd803c1f", "patch": "@@ -450,7 +450,7 @@ fn gen_tag_shapes(ccx: @crate_ctxt) -> ValueRef {\n         let did = ccx.shape_cx.tag_order[i];\n         let variants = ty::tag_variants(ccx.tcx, did);\n         let item_tyt = ty::lookup_item_type(ccx.tcx, did);\n-        let ty_param_count = vec::len(item_tyt.kinds);\n+        let ty_param_count = vec::len(item_tyt.bounds);\n \n         for v: ty::variant_info in *variants {\n             offsets += [vec::len(data) as u16];"}, {"sha": "5b7713fc0c053d0452f466eebe5cd494c9a82670", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1ed6a275487607b71716a4d8ec4cac58cd803c1f/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ed6a275487607b71716a4d8ec4cac58cd803c1f/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=1ed6a275487607b71716a4d8ec4cac58cd803c1f", "patch": "@@ -227,14 +227,14 @@ fn type_of_tag(cx: @crate_ctxt, sp: span, did: ast::def_id, t: ty::t)\n     }\n }\n \n-fn type_of_ty_param_kinds_and_ty(lcx: @local_ctxt, sp: span,\n-                                 tpt: ty::ty_param_kinds_and_ty) -> TypeRef {\n+fn type_of_ty_param_bounds_and_ty(lcx: @local_ctxt, sp: span,\n+                                 tpt: ty::ty_param_bounds_and_ty) -> TypeRef {\n     let cx = lcx.ccx;\n     let t = tpt.ty;\n     alt ty::struct(cx.tcx, t) {\n       ty::ty_fn(_) | ty::ty_native_fn(_, _) {\n         check returns_non_ty_var(cx, t);\n-        ret type_of_fn_from_ty(cx, sp, t, vec::len(tpt.kinds));\n+        ret type_of_fn_from_ty(cx, sp, t, vec::len(tpt.bounds));\n       }\n       _ {\n         // fall through\n@@ -2599,11 +2599,11 @@ fn lval_no_env(bcx: @block_ctxt, val: ValueRef, kind: lval_kind)\n }\n \n fn trans_external_path(cx: @block_ctxt, did: ast::def_id,\n-                       tpt: ty::ty_param_kinds_and_ty) -> ValueRef {\n+                       tpt: ty::ty_param_bounds_and_ty) -> ValueRef {\n     let lcx = cx.fcx.lcx;\n     let name = csearch::get_symbol(lcx.ccx.sess.get_cstore(), did);\n     ret get_extern_const(lcx.ccx.externs, lcx.ccx.llmod, name,\n-                         type_of_ty_param_kinds_and_ty(lcx, cx.sp, tpt));\n+                         type_of_ty_param_bounds_and_ty(lcx, cx.sp, tpt));\n }\n \n fn lval_static_fn(bcx: @block_ctxt, fn_id: ast::def_id, id: ast::node_id)\n@@ -2731,8 +2731,7 @@ fn trans_var(cx: @block_ctxt, sp: span, def: ast::def, id: ast::node_id)\n             ret lval_no_env(cx, ccx.consts.get(did.node), owned);\n         } else {\n             let tp = ty::node_id_to_monotype(ccx.tcx, id);\n-            let k: [ast::kind] = [];\n-            let val = trans_external_path(cx, did, {kinds: k, ty: tp});\n+            let val = trans_external_path(cx, did, {bounds: [], ty: tp});\n             ret lval_no_env(cx, load_if_immediate(cx, val, tp), owned_imm);\n         }\n       }\n@@ -4657,8 +4656,7 @@ fn trans_tag_variant(cx: @local_ctxt, tag_id: ast::node_id,\n     let ty_param_substs: [ty::t] = [];\n     i = 0u;\n     for tp: ast::ty_param in ty_params {\n-        ty_param_substs += [ty::mk_param(ccx.tcx, i,\n-                                         ast_util::ty_param_kind(tp))];\n+        ty_param_substs += [ty::mk_param(ccx.tcx, i, @[])];\n         i += 1u;\n     }\n     let arg_tys = arg_tys_of_fn(ccx, variant.node.id);"}, {"sha": "bcc22956a65c7d57953b68d35171a79943476dda", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 38, "deletions": 13, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/1ed6a275487607b71716a4d8ec4cac58cd803c1f/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ed6a275487607b71716a4d8ec4cac58cd803c1f/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=1ed6a275487607b71716a4d8ec4cac58cd803c1f", "patch": "@@ -106,7 +106,7 @@ export tag_variants;\n export iface_methods, store_iface_methods;\n export tag_variant_with_id;\n export ty_param_substs_opt_and_ty;\n-export ty_param_kinds_and_ty;\n+export ty_param_bounds_and_ty;\n export ty_native_fn;\n export ty_bool;\n export ty_bot;\n@@ -185,14 +185,16 @@ export closure_kind;\n export closure_block;\n export closure_shared;\n export closure_send;\n+export param_bound, bound_copy, bound_send, bound_iface;\n+export param_bounds_to_kind;\n \n // Data types\n \n type arg = {mode: mode, ty: t};\n \n type field = {ident: ast::ident, mt: mt};\n \n-type method = {ident: ast::ident, tps: [ast::kind], fty: fn_ty};\n+type method = {ident: ast::ident, tps: [@[param_bound]], fty: fn_ty};\n \n type constr_table = hashmap<ast::node_id, [constr]>;\n \n@@ -217,7 +219,8 @@ type ctxt =\n       kind_cache: hashmap<t, ast::kind>,\n       ast_ty_to_ty_cache: hashmap<@ast::ty, option::t<t>>,\n       tag_var_cache: hashmap<ast::def_id, @[variant_info]>,\n-      iface_method_cache: hashmap<def_id, @[method]>};\n+      iface_method_cache: hashmap<def_id, @[method]>,\n+      ty_param_bounds: hashmap<def_id, @[param_bound]>};\n \n type ty_ctxt = ctxt;\n \n@@ -265,7 +268,7 @@ tag sty {\n     ty_tup([t]);\n     ty_var(int); // type variable\n \n-    ty_param(uint, ast::kind); // fn/tag type param\n+    ty_param(uint, @[param_bound]); // fn/tag type param\n \n     ty_type; // type_desc*\n     ty_send_type; // type_desc* that has been cloned into exchange heap\n@@ -299,9 +302,29 @@ tag type_err {\n     terr_constr_mismatch(@type_constr, @type_constr);\n }\n \n-type ty_param_kinds_and_ty = {kinds: [ast::kind], ty: t};\n+tag param_bound {\n+    bound_copy;\n+    bound_send;\n+    bound_iface(t);\n+}\n+\n+fn param_bounds_to_kind(bounds: @[param_bound]) -> ast::kind {\n+    let kind = ast::kind_noncopyable;\n+    for bound in *bounds {\n+        alt bound {\n+          bound_copy. {\n+            if kind != ast::kind_sendable { kind = ast::kind_copyable; }\n+          }\n+          bound_send. { kind = ast::kind_sendable; }\n+          _ {}\n+        }\n+    }\n+    kind\n+}\n+\n+type ty_param_bounds_and_ty = {bounds: [@[param_bound]], ty: t};\n \n-type type_cache = hashmap<ast::def_id, ty_param_kinds_and_ty>;\n+type type_cache = hashmap<ast::def_id, ty_param_bounds_and_ty>;\n \n const idx_nil: uint = 0u;\n \n@@ -415,7 +438,8 @@ fn mk_ctxt(s: session::session, dm: resolve::def_map, amap: ast_map::map,\n           ast_ty_to_ty_cache:\n               map::mk_hashmap(ast_util::hash_ty, ast_util::eq_ty),\n           tag_var_cache: new_def_hash(),\n-          iface_method_cache: new_def_hash()};\n+          iface_method_cache: new_def_hash(),\n+          ty_param_bounds: new_def_hash()};\n     populate_type_store(cx);\n     ret cx;\n }\n@@ -600,7 +624,7 @@ fn mk_res(cx: ctxt, did: ast::def_id, inner: t, tps: [t]) -> t {\n \n fn mk_var(cx: ctxt, v: int) -> t { ret gen_ty(cx, ty_var(v)); }\n \n-fn mk_param(cx: ctxt, n: uint, k: ast::kind) -> t {\n+fn mk_param(cx: ctxt, n: uint, k: @[param_bound]) -> t {\n     ret gen_ty(cx, ty_param(n, k));\n }\n \n@@ -698,7 +722,7 @@ fn walk_ty(cx: ctxt, walker: ty_walk, ty: t) {\n \n tag fold_mode {\n     fm_var(fn@(int) -> t);\n-    fm_param(fn@(uint, ast::kind) -> t);\n+    fm_param(fn@(uint, @[param_bound]) -> t);\n     fm_general(fn@(t) -> t);\n }\n \n@@ -1029,7 +1053,7 @@ fn type_kind(cx: ctxt, ty: t) -> ast::kind {\n       }\n       // Resources are always noncopyable.\n       ty_res(did, inner, tps) { ast::kind_noncopyable }\n-      ty_param(_, k) { k }\n+      ty_param(_, bounds) { param_bounds_to_kind(bounds) }\n       ty_constr(t, _) { type_kind(cx, t) }\n     };\n \n@@ -2574,7 +2598,7 @@ fn bind_params_in_type(sp: span, cx: ctxt, next_ty_var: fn@() -> int, typ: t,\n     while i < ty_param_count { *param_var_ids += [next_ty_var()]; i += 1u; }\n     fn binder(sp: span, cx: ctxt, param_var_ids: @mutable [int],\n               _next_ty_var: fn@() -> int, index: uint,\n-              _kind: ast::kind) -> t {\n+              _bounds: @[param_bound]) -> t {\n         if index < vec::len(*param_var_ids) {\n             ret mk_var(cx, param_var_ids[index]);\n         } else {\n@@ -2593,7 +2617,8 @@ fn bind_params_in_type(sp: span, cx: ctxt, next_ty_var: fn@() -> int, typ: t,\n // substitions.\n fn substitute_type_params(cx: ctxt, substs: [ty::t], typ: t) -> t {\n     if !type_contains_params(cx, typ) { ret typ; }\n-    fn substituter(_cx: ctxt, substs: @[ty::t], idx: uint, _kind: ast::kind)\n+    fn substituter(_cx: ctxt, substs: @[ty::t], idx: uint,\n+                   _bounds: @[param_bound])\n        -> t {\n         // FIXME: bounds check can fail\n         ret substs[idx];\n@@ -2674,7 +2699,7 @@ fn tag_variant_with_id(cx: ctxt, tag_id: ast::def_id, variant_id: ast::def_id)\n \n // If the given item is in an external crate, looks up its type and adds it to\n // the type cache. Returns the type parameters and type.\n-fn lookup_item_type(cx: ctxt, did: ast::def_id) -> ty_param_kinds_and_ty {\n+fn lookup_item_type(cx: ctxt, did: ast::def_id) -> ty_param_bounds_and_ty {\n     if did.crate == ast::local_crate {\n         // The item is in this crate. The caller should have added it to the\n         // type cache already; we simply return it."}, {"sha": "9709684d0db375347f9875e2106a8c80f700e8e7", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 98, "deletions": 69, "changes": 167, "blob_url": "https://github.com/rust-lang/rust/blob/1ed6a275487607b71716a4d8ec4cac58cd803c1f/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ed6a275487607b71716a4d8ec4cac58cd803c1f/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=1ed6a275487607b71716a4d8ec4cac58cd803c1f", "patch": "@@ -1,6 +1,6 @@\n import syntax::{ast, ast_util};\n import ast::spanned;\n-import syntax::ast_util::{local_def, respan, ty_param_kind};\n+import syntax::ast_util::{local_def, respan};\n import syntax::visit;\n import metadata::csearch;\n import driver::session;\n@@ -9,7 +9,7 @@ import syntax::codemap::span;\n import middle::ty;\n import middle::ty::{node_id_to_type, arg, bind_params_in_type, block_ty,\n                     expr_ty, field, node_type_table, mk_nil,\n-                    ty_param_substs_opt_and_ty, ty_param_kinds_and_ty};\n+                    ty_param_substs_opt_and_ty, ty_param_bounds_and_ty};\n import util::ppaux::ty_to_str;\n import middle::ty::unify::{ures_ok, ures_err, fix_ok, fix_err};\n import core::{int, vec, str, option};\n@@ -70,28 +70,28 @@ fn lookup_def(fcx: @fn_ctxt, sp: span, id: ast::node_id) -> ast::def {\n }\n \n // Returns the type parameter count and the type for the given definition.\n-fn ty_param_kinds_and_ty_for_def(fcx: @fn_ctxt, sp: span, defn: ast::def) ->\n-   ty_param_kinds_and_ty {\n+fn ty_param_bounds_and_ty_for_def(fcx: @fn_ctxt, sp: span, defn: ast::def) ->\n+   ty_param_bounds_and_ty {\n     alt defn {\n       ast::def_arg(id, _) {\n         assert (fcx.locals.contains_key(id.node));\n         let typ = ty::mk_var(fcx.ccx.tcx, lookup_local(fcx, sp, id.node));\n-        ret {kinds: [], ty: typ};\n+        ret {bounds: [], ty: typ};\n       }\n       ast::def_local(id, _) {\n         assert (fcx.locals.contains_key(id.node));\n         let typ = ty::mk_var(fcx.ccx.tcx, lookup_local(fcx, sp, id.node));\n-        ret {kinds: [], ty: typ};\n+        ret {bounds: [], ty: typ};\n       }\n       ast::def_obj_field(id, _) {\n         assert (fcx.locals.contains_key(id.node));\n         let typ = ty::mk_var(fcx.ccx.tcx, lookup_local(fcx, sp, id.node));\n-        ret {kinds: [], ty: typ};\n+        ret {bounds: [], ty: typ};\n       }\n       ast::def_self(id) {\n         alt get_self_info(fcx.ccx) {\n           some(self_obj(_, obj_t)) | some(self_impl(obj_t)) {\n-            ret {kinds: [], ty: obj_t};\n+            ret {bounds: [], ty: obj_t};\n           }\n         }\n       }\n@@ -102,18 +102,18 @@ fn ty_param_kinds_and_ty_for_def(fcx: @fn_ctxt, sp: span, defn: ast::def) ->\n       ast::def_binding(id) {\n         assert (fcx.locals.contains_key(id.node));\n         let typ = ty::mk_var(fcx.ccx.tcx, lookup_local(fcx, sp, id.node));\n-        ret {kinds: [], ty: typ};\n+        ret {bounds: [], ty: typ};\n       }\n       ast::def_mod(_) {\n         // Hopefully part of a path.\n         // TODO: return a type that's more poisonous, perhaps?\n-        ret {kinds: [], ty: ty::mk_nil(fcx.ccx.tcx)};\n+        ret {bounds: [], ty: ty::mk_nil(fcx.ccx.tcx)};\n       }\n       ast::def_ty(_) {\n         fcx.ccx.tcx.sess.span_fatal(sp, \"expected value but found type\");\n       }\n       ast::def_upvar(_, inner, _) {\n-        ret ty_param_kinds_and_ty_for_def(fcx, sp, *inner);\n+        ret ty_param_bounds_and_ty_for_def(fcx, sp, *inner);\n       }\n       _ {\n         // FIXME: handle other names.\n@@ -126,9 +126,9 @@ fn ty_param_kinds_and_ty_for_def(fcx: @fn_ctxt, sp: span, defn: ast::def) ->\n // Instantiates the given path, which must refer to an item with the given\n // number of type parameters and type.\n fn instantiate_path(fcx: @fn_ctxt, pth: @ast::path,\n-                    tpt: ty_param_kinds_and_ty, sp: span)\n+                    tpt: ty_param_bounds_and_ty, sp: span)\n     -> ty_param_substs_opt_and_ty {\n-    let ty_param_count = vec::len(tpt.kinds);\n+    let ty_param_count = vec::len(tpt.bounds);\n     let bind_result =\n         bind_params_in_type(sp, fcx.ccx.tcx, bind next_ty_var_id(fcx), tpt.ty,\n                             ty_param_count);\n@@ -238,7 +238,7 @@ tag mode { m_collect; m_check; m_check_tyvar(@fn_ctxt); }\n \n fn ast_ty_to_ty(tcx: ty::ctxt, mode: mode, &&ast_ty: @ast::ty) -> ty::t {\n     fn getter(tcx: ty::ctxt, mode: mode, id: ast::def_id)\n-        -> ty::ty_param_kinds_and_ty {\n+        -> ty::ty_param_bounds_and_ty {\n         alt mode {\n           m_check. | m_check_tyvar(_) { ty::lookup_item_type(tcx, id) }\n           m_collect. {\n@@ -281,14 +281,14 @@ fn ast_ty_to_ty(tcx: ty::ctxt, mode: mode, &&ast_ty: @ast::ty) -> ty::t {\n         // TODO: maybe record cname chains so we can do\n         // \"foo = int\" like OCaml?\n \n-        let ty_param_kinds_and_ty = getter(tcx, mode, id);\n-        if vec::len(ty_param_kinds_and_ty.kinds) == 0u {\n-            ret ty_param_kinds_and_ty.ty;\n+        let ty_param_bounds_and_ty = getter(tcx, mode, id);\n+        if vec::len(ty_param_bounds_and_ty.bounds) == 0u {\n+            ret ty_param_bounds_and_ty.ty;\n         }\n \n         // The typedef is type-parametric. Do the type substitution.\n         let param_bindings: [ty::t] = [];\n-        if vec::len(args) != vec::len(ty_param_kinds_and_ty.kinds) {\n+        if vec::len(args) != vec::len(ty_param_bounds_and_ty.bounds) {\n             tcx.sess.span_fatal(sp, \"Wrong number of type arguments for a \\\n                                      polymorphic type\");\n         }\n@@ -297,7 +297,7 @@ fn ast_ty_to_ty(tcx: ty::ctxt, mode: mode, &&ast_ty: @ast::ty) -> ty::t {\n         }\n         let typ =\n             ty::substitute_type_params(tcx, param_bindings,\n-                                       ty_param_kinds_and_ty.ty);\n+                                       ty_param_bounds_and_ty.ty);\n         ret typ;\n     }\n     let typ;\n@@ -342,7 +342,9 @@ fn ast_ty_to_ty(tcx: ty::ctxt, mode: mode, &&ast_ty: @ast::ty) -> ty::t {\n             typ = instantiate(tcx, ast_ty.span, mode, id, path.node.types);\n           }\n           some(ast::def_native_ty(id)) { typ = getter(tcx, mode, id).ty; }\n-          some(ast::def_ty_param(id, k)) { typ = ty::mk_param(tcx, id, k); }\n+          some(ast::def_ty_param(id, n)) {\n+            typ = ty::mk_param(tcx, n, tcx.ty_param_bounds.get(id));\n+          }\n           some(_) {\n             tcx.sess.span_fatal(ast_ty.span,\n                                 \"found type name used as a variable\");\n@@ -376,11 +378,11 @@ fn ast_ty_to_ty(tcx: ty::ctxt, mode: mode, &&ast_ty: @ast::ty) -> ty::t {\n }\n \n fn ty_of_item(tcx: ty::ctxt, mode: mode, it: @ast::item)\n-    -> ty::ty_param_kinds_and_ty {\n+    -> ty::ty_param_bounds_and_ty {\n     alt it.node {\n       ast::item_const(t, _) {\n         let typ = ast_ty_to_ty(tcx, mode, t);\n-        let tpt = {kinds: [], ty: typ};\n+        let tpt = {bounds: [], ty: typ};\n         tcx.tcache.insert(local_def(it.id), tpt);\n         ret tpt;\n       }\n@@ -399,34 +401,37 @@ fn ty_of_item(tcx: ty::ctxt, mode: mode, it: @ast::item)\n         }\n         // Tell ast_ty_to_ty() that we want to perform a recursive\n         // call to resolve any named types.\n-        let typ = ty::mk_named(tcx, ast_ty_to_ty(tcx, mode, t), @it.ident);\n-        let tpt = {kinds: ty_param_kinds(tps), ty: typ};\n+        let tpt = {bounds: ty_param_bounds(tcx, mode, tps),\n+                   ty: ty::mk_named(tcx, ast_ty_to_ty(tcx, mode, t),\n+                                    @it.ident)};\n         tcx.tcache.insert(local_def(it.id), tpt);\n         ret tpt;\n       }\n       ast::item_res(decl, tps, _, _, _) {\n+        let {bounds, params} = mk_ty_params(tcx, tps);\n         let t_arg = ty_of_arg(tcx, mode, decl.inputs[0]);\n         let t = ty::mk_named(tcx, ty::mk_res(tcx, local_def(it.id), t_arg.ty,\n-                                             mk_ty_params(tcx, tps)),\n+                                             params),\n                              @it.ident);\n-        let t_res = {kinds: ty_param_kinds(tps), ty: t};\n+        let t_res = {bounds: bounds, ty: t};\n         tcx.tcache.insert(local_def(it.id), t_res);\n         ret t_res;\n       }\n       ast::item_tag(_, tps) {\n         // Create a new generic polytype.\n-        let subtys: [ty::t] = mk_ty_params(tcx, tps);\n-        let t = ty::mk_named(tcx, ty::mk_tag(tcx, local_def(it.id), subtys),\n+        let {bounds, params} = mk_ty_params(tcx, tps);\n+        let t = ty::mk_named(tcx, ty::mk_tag(tcx, local_def(it.id), params),\n                              @it.ident);\n-        let tpt = {kinds: ty_param_kinds(tps), ty: t};\n+        let tpt = {bounds: bounds, ty: t};\n         tcx.tcache.insert(local_def(it.id), tpt);\n         ret tpt;\n       }\n       ast::item_iface(tps, ms) {\n+        let {bounds, params} = mk_ty_params(tcx, tps);\n         let t = ty::mk_named(tcx, ty::mk_iface(tcx, local_def(it.id),\n-                                               mk_ty_params(tcx, tps)),\n+                                               params),\n                              @it.ident);\n-        let tpt = {kinds: ty_param_kinds(tps), ty: t};\n+        let tpt = {bounds: bounds, ty: t};\n         tcx.tcache.insert(local_def(it.id), tpt);\n         ty::store_iface_methods(tcx, it.id, @vec::map(ms, {|m|\n             ty_of_ty_method(tcx, m_collect, m)\n@@ -438,7 +443,7 @@ fn ty_of_item(tcx: ty::ctxt, mode: mode, it: @ast::item)\n     }\n }\n fn ty_of_native_item(tcx: ty::ctxt, mode: mode, it: @ast::native_item)\n-    -> ty::ty_param_kinds_and_ty {\n+    -> ty::ty_param_bounds_and_ty {\n     alt it.node {\n       ast::native_item_fn(fn_decl, params) {\n         ret ty_of_native_fn_decl(tcx, mode, fn_decl, params,\n@@ -450,7 +455,7 @@ fn ty_of_native_item(tcx: ty::ctxt, mode: mode, it: @ast::native_item)\n           none. { }\n         }\n         let t = ty::mk_native(tcx, ast_util::local_def(it.id));\n-        let tpt = {kinds: [], ty: t};\n+        let tpt = {bounds: [], ty: t};\n         tcx.tcache.insert(local_def(it.id), tpt);\n         ret tpt;\n       }\n@@ -474,43 +479,69 @@ fn ty_of_fn_decl(tcx: ty::ctxt, mode: mode, decl: ast::fn_decl) -> ty::fn_ty {\n }\n fn ty_of_fn(tcx: ty::ctxt, mode: mode, decl: ast::fn_decl,\n             ty_params: [ast::ty_param], def_id: ast::def_id)\n-    -> ty::ty_param_kinds_and_ty {\n-    let tpt = {kinds: ty_param_kinds(ty_params),\n+    -> ty::ty_param_bounds_and_ty {\n+    let tpt = {bounds: ty_param_bounds(tcx, mode, ty_params),\n                ty: ty::mk_fn(tcx, ty_of_fn_decl(tcx, mode, decl))};\n     tcx.tcache.insert(def_id, tpt);\n     ret tpt;\n }\n fn ty_of_native_fn_decl(tcx: ty::ctxt, mode: mode, decl: ast::fn_decl,\n                   ty_params: [ast::ty_param], def_id: ast::def_id)\n-    -> ty::ty_param_kinds_and_ty {\n-    let input_tys = [];\n+    -> ty::ty_param_bounds_and_ty {\n+    let input_tys = [], bounds = ty_param_bounds(tcx, mode, ty_params);\n     for a: ast::arg in decl.inputs { input_tys += [ty_of_arg(tcx, mode, a)]; }\n     let output_ty = ast_ty_to_ty(tcx, mode, decl.output);\n \n     let t_fn = ty::mk_native_fn(tcx, input_tys, output_ty);\n-    let tpt = {kinds: ty_param_kinds(ty_params), ty: t_fn};\n+    let tpt = {bounds: bounds, ty: t_fn};\n     tcx.tcache.insert(def_id, tpt);\n     ret tpt;\n }\n+fn ty_param_bounds(tcx: ty::ctxt, mode: mode, params: [ast::ty_param])\n+    -> [@[ty::param_bound]] {\n+    let result = [];\n+    for param in params {\n+        result += [alt tcx.ty_param_bounds.find(local_def(param.id)) {\n+          some(bs) { bs }\n+          none. {\n+            let bounds = [];\n+            for b in *param.bounds {\n+                bounds += [alt b {\n+                  ast::bound_send. { ty::bound_send }\n+                  ast::bound_copy. { ty::bound_copy }\n+                  ast::bound_iface(ifc) {\n+                    ty::bound_iface(ast_ty_to_ty(tcx, mode, ifc))\n+                  }\n+                }];\n+            }\n+            let boxed = @bounds;\n+            tcx.ty_param_bounds.insert(local_def(param.id), boxed);\n+            boxed\n+          }\n+        }];\n+    }\n+    result\n+}\n fn ty_of_method(tcx: ty::ctxt, mode: mode, m: @ast::method) -> ty::method {\n-    {ident: m.ident, tps: vec::map(m.tps, {|tp| tp.kind}),\n+    {ident: m.ident, tps: ty_param_bounds(tcx, mode, m.tps),\n      fty: ty_of_fn_decl(tcx, mode, m.decl)}\n }\n fn ty_of_ty_method(tcx: ty::ctxt, mode: mode, m: ast::ty_method)\n     -> ty::method {\n-    {ident: m.ident, tps: vec::map(m.tps, {|tp| tp.kind}),\n+    {ident: m.ident, tps: ty_param_bounds(tcx, mode, m.tps),\n      fty: ty_of_fn_decl(tcx, mode, m.decl)}\n }\n fn ty_of_obj(tcx: ty::ctxt, mode: mode, id: ast::ident, ob: ast::_obj,\n-        ty_params: [ast::ty_param]) -> ty::ty_param_kinds_and_ty {\n+        ty_params: [ast::ty_param]) -> ty::ty_param_bounds_and_ty {\n+    let bounds = ty_param_bounds(tcx, mode, ty_params);\n     let methods = vec::map(ob.methods, {|m| ty_of_method(tcx, mode, m)});\n     let t_obj = ty::mk_named(tcx, ty::mk_obj(tcx, ty::sort_methods(methods)),\n                              @id);\n-    ret {kinds: ty_param_kinds(ty_params), ty: t_obj};\n+    ret {bounds: bounds, ty: t_obj};\n }\n fn ty_of_obj_ctor(tcx: ty::ctxt, mode: mode, id: ast::ident, ob: ast::_obj,\n             ctor_id: ast::node_id, ty_params: [ast::ty_param])\n-    -> ty::ty_param_kinds_and_ty {\n+    -> ty::ty_param_bounds_and_ty {\n     let t_obj = ty_of_obj(tcx, mode, id, ob, ty_params);\n     let t_inputs: [arg] = [];\n     for f: ast::obj_field in ob.fields {\n@@ -520,7 +551,7 @@ fn ty_of_obj_ctor(tcx: ty::ctxt, mode: mode, id: ast::ident, ob: ast::_obj,\n     let t_fn = ty::mk_fn(tcx, {proto: ast::proto_shared(ast::sugar_normal),\n                                inputs: t_inputs, output: t_obj.ty,\n                                ret_style: ast::return_val, constraints: []});\n-    let tpt = {kinds: ty_param_kinds(ty_params), ty: t_fn};\n+    let tpt = {bounds: ty_param_bounds(tcx, mode, ty_params), ty: t_fn};\n     tcx.tcache.insert(local_def(ctor_id), tpt);\n     ret tpt;\n }\n@@ -588,20 +619,15 @@ mod write {\n     }\n }\n \n-fn mk_ty_params(tcx: ty::ctxt, atps: [ast::ty_param]) -> [ty::t] {\n-    let tps = [];\n-    let i = 0u;\n-    for atp: ast::ty_param in atps {\n-        tps += [ty::mk_param(tcx, i, ty_param_kind(atp))];\n-        i += 1u;\n-    }\n-    ret tps;\n-}\n-\n-fn ty_param_kinds(tps: [ast::ty_param]) -> [ast::kind] {\n-    let k: [ast::kind] = [];\n-    for p: ast::ty_param in tps { k += [ty_param_kind(p)]; }\n-    ret k;\n+fn mk_ty_params(tcx: ty::ctxt, atps: [ast::ty_param])\n+    -> {bounds: [@[ty::param_bound]], params: [ty::t]} {\n+    let i = 0u, bounds = ty_param_bounds(tcx, m_collect, atps);\n+    {bounds: bounds,\n+     params: vec::map(atps, {|_atp|\n+         let t = ty::mk_param(tcx, i, bounds[i]);\n+         i += 1u;\n+         t\n+     })}\n }\n \n // Item collection - a pair of bootstrap passes:\n@@ -646,7 +672,8 @@ mod collect {\n                            inputs: args, output: tag_ty,\n                            ret_style: ast::return_val, constraints: []})\n             };\n-            let tpt = {kinds: ty_param_kinds(ty_params), ty: result_ty};\n+            let tpt = {bounds: ty_param_bounds(cx.tcx, m_collect, ty_params),\n+                       ty: result_ty};\n             cx.tcx.tcache.insert(local_def(variant.node.id), tpt);\n             write::ty_only(cx.tcx, variant.node.id, result_ty);\n         }\n@@ -660,13 +687,14 @@ mod collect {\n             write::ty_only(cx.tcx, it.id, tpt.ty);\n             get_tag_variant_types(cx, tpt.ty, variants, ty_params);\n           }\n-          ast::item_impl(_, _, selfty, ms) {\n+          ast::item_impl(tps, _, selfty, ms) {\n+            ty_param_bounds(cx.tcx, m_collect, tps);\n             for m in ms {\n+                let bounds = ty_param_bounds(cx.tcx, m_collect, m.tps);\n                 let ty = ty::mk_fn(cx.tcx, ty_of_fn_decl(cx.tcx, m_collect,\n                                                          m.decl));\n-                cx.tcx.tcache.insert(local_def(m.id),\n-                                     {kinds: ty_param_kinds(m.tps),\n-                                      ty: ty});\n+                cx.tcx.tcache.insert(local_def(m.id), {bounds: bounds,\n+                                                       ty: ty});\n                 write::ty_only(cx.tcx, m.id, ty);\n             }\n             write::ty_only(cx.tcx, it.id, ast_ty_to_ty(cx.tcx, m_collect,\n@@ -705,10 +733,10 @@ mod collect {\n             }\n           }\n           ast::item_res(decl, tps, _, dtor_id, ctor_id) {\n+            let {bounds, params} = mk_ty_params(cx.tcx, tps);\n             let t_arg = ty_of_arg(cx.tcx, m_collect, decl.inputs[0]);\n-            let t_res =\n-                ty::mk_res(cx.tcx, local_def(it.id), t_arg.ty,\n-                           mk_ty_params(cx.tcx, tps));\n+            let t_res = ty::mk_res(cx.tcx, local_def(it.id), t_arg.ty,\n+                                   params);\n             let t_ctor = ty::mk_fn(cx.tcx, {\n                 proto: ast::proto_shared(ast::sugar_normal),\n                 inputs: [{mode: ast::by_copy with t_arg}],\n@@ -723,7 +751,8 @@ mod collect {\n             write::ty_only(cx.tcx, it.id, t_res);\n             write::ty_only(cx.tcx, ctor_id, t_ctor);\n             cx.tcx.tcache.insert(local_def(ctor_id),\n-                                 {kinds: ty_param_kinds(tps), ty: t_ctor});\n+                                 {bounds: bounds,\n+                                  ty: t_ctor});\n             write::ty_only(cx.tcx, dtor_id, t_dtor);\n           }\n           _ {\n@@ -1449,7 +1478,7 @@ fn lookup_method(fcx: @fn_ctxt, isc: resolve::iscopes,\n                     }\n                 } else {\n                     let tpt = csearch::get_type(fcx.ccx.tcx, did);\n-                    (vec::len(tpt.kinds), tpt.ty)\n+                    (vec::len(tpt.bounds), tpt.ty)\n                 };\n                 let {ids, ty: self_ty} = if n_tps > 0u {\n                     bind_params_in_type(ast_util::dummy_sp(), fcx.ccx.tcx,\n@@ -1782,7 +1811,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n       ast::expr_path(pth) {\n         let defn = lookup_def(fcx, pth.span, id);\n \n-        let tpt = ty_param_kinds_and_ty_for_def(fcx, expr.span, defn);\n+        let tpt = ty_param_bounds_and_ty_for_def(fcx, expr.span, defn);\n         if ty::def_has_ty_params(defn) {\n             let path_tpot = instantiate_path(fcx, pth, tpt, expr.span);\n             write::ty_fixup(fcx, id, path_tpot);"}, {"sha": "bc688719b24e0d688d45bef3b183b7beba40e642", "filename": "src/comp/syntax/ast.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1ed6a275487607b71716a4d8ec4cac58cd803c1f/src%2Fcomp%2Fsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ed6a275487607b71716a4d8ec4cac58cd803c1f/src%2Fcomp%2Fsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fast.rs?ref=1ed6a275487607b71716a4d8ec4cac58cd803c1f", "patch": "@@ -24,7 +24,13 @@ type def_id = {crate: crate_num, node: node_id};\n const local_crate: crate_num = 0;\n const crate_node_id: node_id = 0;\n \n-type ty_param = {ident: ident, kind: kind};\n+tag ty_param_bound {\n+    bound_copy;\n+    bound_send;\n+    bound_iface(@ty);\n+}\n+\n+type ty_param = {ident: ident, id: node_id, bounds: @[ty_param_bound]};\n \n tag def {\n     def_fn(def_id, purity);\n@@ -37,7 +43,7 @@ tag def {\n     def_local(def_id, let_style);\n     def_variant(def_id /* tag */, def_id /* variant */);\n     def_ty(def_id);\n-    def_ty_param(uint, kind);\n+    def_ty_param(def_id, uint);\n     def_binding(def_id);\n     def_use(def_id);\n     def_native_ty(def_id);"}, {"sha": "7a77861ae0b7913e1e3e49c5eb21f5a698062c2d", "filename": "src/comp/syntax/ast_util.rs", "status": "modified", "additions": 5, "deletions": 18, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/1ed6a275487607b71716a4d8ec4cac58cd803c1f/src%2Fcomp%2Fsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ed6a275487607b71716a4d8ec4cac58cd803c1f/src%2Fcomp%2Fsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fast_util.rs?ref=1ed6a275487607b71716a4d8ec4cac58cd803c1f", "patch": "@@ -25,22 +25,11 @@ fn variant_def_ids(d: def) -> {tg: def_id, var: def_id} {\n \n fn def_id_of_def(d: def) -> def_id {\n     alt d {\n-      def_fn(id, _) { ret id; }\n-      def_obj_field(id, _) { ret id; }\n-      def_self(id) { ret id; }\n-      def_mod(id) { ret id; }\n-      def_native_mod(id) { ret id; }\n-      def_const(id) { ret id; }\n-      def_arg(id, _) { ret id; }\n-      def_local(id, _) { ret id; }\n-      def_variant(_, id) { ret id; }\n-      def_ty(id) { ret id; }\n-      def_ty_param(_, _) { fail; }\n-      def_binding(id) { ret id; }\n-      def_use(id) { ret id; }\n-      def_native_ty(id) { ret id; }\n-      def_native_fn(id, _) { ret id; }\n-      def_upvar(id, _, _) { ret id; }\n+      def_fn(id, _) | def_obj_field(id, _) | def_self(id) | def_mod(id) |\n+      def_native_mod(id) | def_const(id) | def_arg(id, _) | def_local(id, _) |\n+      def_variant(_, id) | def_ty(id) | def_ty_param(id, _) |\n+      def_binding(id) | def_use(id) | def_native_ty(id) |\n+      def_native_fn(id, _) | def_upvar(id, _, _) { id }\n     }\n }\n \n@@ -247,8 +236,6 @@ fn ternary_to_if(e: @expr) -> @expr {\n     }\n }\n \n-fn ty_param_kind(tp: ty_param) -> kind { tp.kind }\n-\n // FIXME this doesn't handle big integer/float literals correctly (nor does\n // the rest of our literal handling)\n tag const_val {"}, {"sha": "b681f7134228f9bbdff1a7d30c1990fda6f99696", "filename": "src/comp/syntax/parse/parser.rs", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/1ed6a275487607b71716a4d8ec4cac58cd803c1f/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ed6a275487607b71716a4d8ec4cac58cd803c1f/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs?ref=1ed6a275487607b71716a4d8ec4cac58cd803c1f", "patch": "@@ -1718,10 +1718,18 @@ fn parse_block_tail(p: parser, lo: uint, s: ast::blk_check_mode) -> ast::blk {\n }\n \n fn parse_ty_param(p: parser) -> ast::ty_param {\n-    let k = if eat_word(p, \"send\") { ast::kind_sendable }\n-            else if eat_word(p, \"copy\") { ast::kind_copyable }\n-            else { ast::kind_noncopyable };\n-    ret {ident: parse_ident(p), kind: k};\n+    let bounds = [];\n+    if eat_word(p, \"send\") { bounds += [ast::bound_send]; }\n+    else if eat_word(p, \"copy\") { bounds += [ast::bound_copy]; }\n+    let ident = parse_ident(p);\n+    if eat(p, token::COLON) {\n+        while p.peek() != token::COMMA && p.peek() != token::GT {\n+            if eat_word(p, \"send\") { bounds += [ast::bound_send]; }\n+            else if eat_word(p, \"copy\") { bounds += [ast::bound_copy]; }\n+            else { bounds += [ast::bound_iface(parse_ty(p, false))]; }\n+        }\n+    }\n+    ret {ident: ident, id: p.get_id(), bounds: @bounds};\n }\n \n fn parse_ty_params(p: parser) -> [ast::ty_param] {\n@@ -1856,7 +1864,8 @@ fn parse_item_impl(p: parser, attrs: [ast::attribute]) -> @ast::item {\n               ast::ty_path(pt, _) {\n                 if vec::len(pt.node.idents) == 1u &&\n                    vec::len(pt.node.types) == 0u {\n-                     ret {ident: pt.node.idents[0], kind: ast::kind_sendable};\n+                     ret {ident: pt.node.idents[0], id: p.get_id(),\n+                          bounds: @[]};\n                 }\n               }\n               _ {}"}, {"sha": "48893f67227d93c7453b9be9ecd133829947b5f1", "filename": "src/comp/syntax/print/pprust.rs", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/1ed6a275487607b71716a4d8ec4cac58cd803c1f/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ed6a275487607b71716a4d8ec4cac58cd803c1f/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs?ref=1ed6a275487607b71716a4d8ec4cac58cd803c1f", "patch": "@@ -1204,20 +1204,26 @@ fn print_arg_mode(s: ps, m: ast::mode) {\n     }\n }\n \n-fn print_kind(s: ps, kind: ast::kind) {\n-    alt kind {\n-      ast::kind_sendable. { word_nbsp(s, \"send\"); }\n-      ast::kind_copyable. { word_nbsp(s, \"copy\"); }\n-      ast::kind_noncopyable. {}\n+fn print_bounds(s: ps, bounds: @[ast::ty_param_bound]) {\n+    if vec::len(*bounds) > 0u {\n+        word(s.s, \":\");\n+        for bound in *bounds {\n+            nbsp(s);\n+            alt bound {\n+              ast::bound_copy. { word(s.s, \"copy\"); }\n+              ast::bound_send. { word(s.s, \"send\"); }\n+              ast::bound_iface(t) { print_type(s, t); }\n+            }\n+        }\n     }\n }\n \n fn print_type_params(s: ps, params: [ast::ty_param]) {\n     if vec::len(params) > 0u {\n         word(s.s, \"<\");\n         fn printParam(s: ps, param: ast::ty_param) {\n-            print_kind(s, param.kind);\n             word(s.s, param.ident);\n+            print_bounds(s, param.bounds);\n         }\n         commasep(s, inconsistent, params, printParam);\n         word(s.s, \">\");"}, {"sha": "64dfafb9c4bc81061dd4b2552154964eb2ecbe46", "filename": "src/comp/syntax/visit.rs", "status": "modified", "additions": 26, "deletions": 7, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/1ed6a275487607b71716a4d8ec4cac58cd803c1f/src%2Fcomp%2Fsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ed6a275487607b71716a4d8ec4cac58cd803c1f/src%2Fcomp%2Fsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fvisit.rs?ref=1ed6a275487607b71716a4d8ec4cac58cd803c1f", "patch": "@@ -92,32 +92,36 @@ fn visit_item<E>(i: @item, e: E, v: vt<E>) {\n         for vi: @view_item in nm.view_items { v.visit_view_item(vi, e, v); }\n         for ni: @native_item in nm.items { v.visit_native_item(ni, e, v); }\n       }\n-      item_ty(t, _) { v.visit_ty(t, e, v); }\n+      item_ty(t, tps) { v.visit_ty(t, e, v); visit_ty_params(tps, e, v); }\n       item_res(decl, tps, body, dtor_id, _) {\n         v.visit_fn(decl, tps, body, i.span, some(i.ident), dtor_id,\n                    e, v);\n       }\n-      item_tag(variants, _) {\n+      item_tag(variants, tps) {\n+        visit_ty_params(tps, e, v);\n         for vr: variant in variants {\n             for va: variant_arg in vr.node.args { v.visit_ty(va.ty, e, v); }\n         }\n       }\n-      item_obj(ob, _, _) {\n+      item_obj(ob, tps, _) {\n+        visit_ty_params(tps, e, v);\n         for f: obj_field in ob.fields { v.visit_ty(f.ty, e, v); }\n         for m: @method in ob.methods {\n             v.visit_fn(m.decl, m.tps, m.body, m.span,\n                        some(m.ident), m.id, e, v);\n         }\n       }\n-      item_impl(_, ifce, ty, methods) {\n+      item_impl(tps, ifce, ty, methods) {\n+        visit_ty_params(tps, e, v);\n         alt ifce { some(ty) { v.visit_ty(ty, e, v); } _ {} }\n         v.visit_ty(ty, e, v);\n         for m in methods {\n             v.visit_fn(m.decl, m.tps, m.body, m.span,\n                        some(m.ident), m.id, e, v);\n         }\n       }\n-      item_iface(_, methods) {\n+      item_iface(tps, methods) {\n+        visit_ty_params(tps, e, v);\n         for m in methods {\n             for a in m.decl.inputs { v.visit_ty(a.ty, e, v); }\n             v.visit_ty(m.decl.output, e, v);\n@@ -191,11 +195,25 @@ fn visit_pat<E>(p: @pat, e: E, v: vt<E>) {\n \n fn visit_native_item<E>(ni: @native_item, e: E, v: vt<E>) {\n     alt ni.node {\n-      native_item_fn(fd, _) { visit_fn_decl(fd, e, v); }\n+      native_item_fn(fd, tps) {\n+        visit_ty_params(tps, e, v);\n+        visit_fn_decl(fd, e, v);\n+      }\n       native_item_ty. { }\n     }\n }\n \n+fn visit_ty_params<E>(tps: [ty_param], e: E, v: vt<E>) {\n+    for tp in tps {\n+        for bound in *tp.bounds {\n+            alt bound {\n+              bound_iface(t) { v.visit_ty(t, e, v); }\n+              _ {}\n+            }\n+        }\n+    }\n+}\n+\n fn visit_fn_decl<E>(fd: fn_decl, e: E, v: vt<E>) {\n     for a: arg in fd.inputs { v.visit_ty(a.ty, e, v); }\n     for c: @constr in fd.constraints {\n@@ -204,9 +222,10 @@ fn visit_fn_decl<E>(fd: fn_decl, e: E, v: vt<E>) {\n     v.visit_ty(fd.output, e, v);\n }\n \n-fn visit_fn<E>(decl: fn_decl, _tp: [ty_param], body: blk, _sp: span,\n+fn visit_fn<E>(decl: fn_decl, tp: [ty_param], body: blk, _sp: span,\n                _i: fn_ident, _id: node_id, e: E, v: vt<E>) {\n     visit_fn_decl(decl, e, v);\n+    visit_ty_params(tp, e, v);\n     v.visit_block(body, e, v);\n }\n "}]}