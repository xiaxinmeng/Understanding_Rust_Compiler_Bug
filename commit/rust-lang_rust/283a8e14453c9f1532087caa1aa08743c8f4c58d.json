{"sha": "283a8e14453c9f1532087caa1aa08743c8f4c58d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI4M2E4ZTE0NDUzYzlmMTUzMjA4N2NhYTFhYTA4NzQzYzhmNGM1OGQ=", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2020-11-02T20:27:36Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2021-08-22T18:23:29Z"}, "message": "Make all query forcing go through try_execute_query.\n\ntry_execute_query is now able to centralize the path for query\nget/ensure/force.\n\ntry_execute_query now takes the dep_node as a parameter, so it can\naccommodate `force`. This dep_node is an Option to avoid computing it in\nthe `get` fast path.\n\ntry_execute_query now returns both the result and the dep_node_index to\nallow the caller to handle the dep graph.\n\nThe caller is responsible for marking the dependency.", "tree": {"sha": "adcc55a3871d0df2b4e910823446c5d1313937a6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/adcc55a3871d0df2b4e910823446c5d1313937a6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/283a8e14453c9f1532087caa1aa08743c8f4c58d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/283a8e14453c9f1532087caa1aa08743c8f4c58d", "html_url": "https://github.com/rust-lang/rust/commit/283a8e14453c9f1532087caa1aa08743c8f4c58d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/283a8e14453c9f1532087caa1aa08743c8f4c58d/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "45d6decc19b419448961fdb5ba3e062c9267a393", "url": "https://api.github.com/repos/rust-lang/rust/commits/45d6decc19b419448961fdb5ba3e062c9267a393", "html_url": "https://github.com/rust-lang/rust/commit/45d6decc19b419448961fdb5ba3e062c9267a393"}], "stats": {"total": 71, "additions": 31, "deletions": 40}, "files": [{"sha": "82392dee165444604b6ede96d57417929c6f0ba4", "filename": "compiler/rustc_query_system/src/query/plumbing.rs", "status": "modified", "additions": 31, "deletions": 40, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/283a8e14453c9f1532087caa1aa08743c8f4c58d/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/283a8e14453c9f1532087caa1aa08743c8f4c58d/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs?ref=283a8e14453c9f1532087caa1aa08743c8f4c58d", "patch": "@@ -427,12 +427,13 @@ fn try_execute_query<CTX, C>(\n     span: Span,\n     key: C::Key,\n     lookup: QueryLookup,\n+    dep_node: Option<DepNode<CTX::DepKind>>,\n     query: &QueryVtable<CTX, C::Key, C::Value>,\n     compute: fn(CTX::DepContext, C::Key) -> C::Value,\n-) -> C::Stored\n+) -> (C::Stored, Option<DepNodeIndex>)\n where\n     C: QueryCache,\n-    C::Key: DepNodeParams<CTX::DepContext>,\n+    C::Key: Clone + DepNodeParams<CTX::DepContext>,\n     CTX: QueryContext,\n {\n     let job = match JobOwner::<'_, CTX::DepKind, C>::try_start(\n@@ -445,11 +446,10 @@ where\n         query,\n     ) {\n         TryGetJob::NotYetStarted(job) => job,\n-        TryGetJob::Cycle(result) => return result,\n+        TryGetJob::Cycle(result) => return (result, None),\n         #[cfg(parallel_compiler)]\n         TryGetJob::JobCompleted((v, index)) => {\n-            tcx.dep_context().dep_graph().read_index(index);\n-            return v;\n+            return (v, Some(index));\n         }\n     };\n \n@@ -461,10 +461,11 @@ where\n         let result = tcx.start_query(job.id, None, || compute(*tcx.dep_context(), key));\n         let dep_node_index = dep_graph.next_virtual_depnode_index();\n         prof_timer.finish_with_query_invocation_id(dep_node_index.into());\n-        return job.complete(result, dep_node_index);\n+        let result = job.complete(result, dep_node_index);\n+        return (result, None);\n     }\n \n-    if query.anon {\n+    let (result, dep_node_index) = if query.anon {\n         let prof_timer = tcx.dep_context().profiler().query_provider();\n \n         let ((result, dep_node_index), diagnostics) = with_diagnostics(|diagnostics| {\n@@ -477,34 +478,35 @@ where\n \n         prof_timer.finish_with_query_invocation_id(dep_node_index.into());\n \n-        dep_graph.read_index(dep_node_index);\n-\n         let side_effects = QuerySideEffects { diagnostics };\n \n         if unlikely!(!side_effects.is_empty()) {\n             tcx.store_side_effects_for_anon_node(dep_node_index, side_effects);\n         }\n \n-        return job.complete(result, dep_node_index);\n-    }\n-\n-    let dep_node = query.to_dep_node(*tcx.dep_context(), &key);\n-\n-    if !query.eval_always {\n+        let result = job.complete(result, dep_node_index);\n+        (result, dep_node_index)\n+    } else if query.eval_always {\n+        // `to_dep_node` is expensive for some `DepKind`s.\n+        let dep_node = dep_node.unwrap_or_else(|| query.to_dep_node(*tcx.dep_context(), &key));\n+        force_query_with_job(tcx, key, job, dep_node, query, compute)\n+    } else {\n+        // `to_dep_node` is expensive for some `DepKind`s.\n+        let dep_node = dep_node.unwrap_or_else(|| query.to_dep_node(*tcx.dep_context(), &key));\n         // The diagnostics for this query will be\n         // promoted to the current session during\n         // `try_mark_green()`, so we can ignore them here.\n         let loaded = tcx.start_query(job.id, None, || {\n             try_load_from_disk_and_cache_in_memory(tcx, &key, &dep_node, query, compute)\n         });\n         if let Some((result, dep_node_index)) = loaded {\n-            return job.complete(result, dep_node_index);\n+            let result = job.complete(result, dep_node_index);\n+            (result, dep_node_index)\n+        } else {\n+            force_query_with_job(tcx, key, job, dep_node, query, compute)\n         }\n-    }\n-\n-    let (result, dep_node_index) = force_query_with_job(tcx, key, job, dep_node, query, compute);\n-    dep_graph.read_index(dep_node_index);\n-    result\n+    };\n+    (result, Some(dep_node_index))\n }\n \n fn try_load_from_disk_and_cache_in_memory<CTX, K, V>(\n@@ -524,7 +526,6 @@ where\n \n     let (prev_dep_node_index, dep_node_index) =\n         tcx.dep_context().dep_graph().try_mark_green(tcx, &dep_node)?;\n-    tcx.dep_context().dep_graph().read_index(dep_node_index);\n \n     debug_assert!(tcx.dep_context().dep_graph().is_green(dep_node));\n \n@@ -700,7 +701,12 @@ where\n     C: QueryCache,\n     C::Key: DepNodeParams<CTX::DepContext>,\n {\n-    try_execute_query(tcx, state, cache, span, key, lookup, query, compute)\n+    let (result, dep_node_index) =\n+        try_execute_query(tcx, state, cache, span, key, lookup, None, query, compute);\n+    if let Some(dep_node_index) = dep_node_index {\n+        tcx.dep_context().dep_graph().read_index(dep_node_index)\n+    }\n+    result\n }\n \n /// Ensure that either this query has all green inputs or been executed.\n@@ -779,23 +785,8 @@ where\n         Err(lookup) => lookup,\n     };\n \n-    let job = match JobOwner::<'_, CTX::DepKind, C>::try_start(\n-        tcx,\n-        state,\n-        cache,\n-        DUMMY_SP,\n-        key.clone(),\n-        lookup,\n-        query,\n-    ) {\n-        TryGetJob::NotYetStarted(job) => job,\n-        TryGetJob::Cycle(_) => return true,\n-        #[cfg(parallel_compiler)]\n-        TryGetJob::JobCompleted(_) => return true,\n-    };\n-\n-    force_query_with_job(tcx, key, job, dep_node, query, compute);\n-\n+    let _ =\n+        try_execute_query(tcx, state, cache, DUMMY_SP, key, lookup, Some(dep_node), query, compute);\n     true\n }\n "}]}