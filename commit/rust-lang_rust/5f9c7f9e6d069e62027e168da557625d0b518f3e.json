{"sha": "5f9c7f9e6d069e62027e168da557625d0b518f3e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVmOWM3ZjllNmQwNjllNjIwMjdlMTY4ZGE1NTc2MjVkMGI1MThmM2U=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-06-25T06:44:08Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-06-25T06:44:08Z"}, "message": "Auto merge of #51688 - spastorino:error-note-field-after-move, r=nikomatsakis\n\nFix erroneous error note when using field after move\n\nCloses #51512\n\nr? @nikomatsakis", "tree": {"sha": "5e7d98d98b48fe774ba79f0b6f4fca264ec3eac6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5e7d98d98b48fe774ba79f0b6f4fca264ec3eac6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5f9c7f9e6d069e62027e168da557625d0b518f3e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5f9c7f9e6d069e62027e168da557625d0b518f3e", "html_url": "https://github.com/rust-lang/rust/commit/5f9c7f9e6d069e62027e168da557625d0b518f3e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5f9c7f9e6d069e62027e168da557625d0b518f3e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "01cc982e936120acb0424e41de14e42ba2d88c6f", "url": "https://api.github.com/repos/rust-lang/rust/commits/01cc982e936120acb0424e41de14e42ba2d88c6f", "html_url": "https://github.com/rust-lang/rust/commit/01cc982e936120acb0424e41de14e42ba2d88c6f"}, {"sha": "1dae309ca1c8ae89384170de2e5d4683d5f94cd4", "url": "https://api.github.com/repos/rust-lang/rust/commits/1dae309ca1c8ae89384170de2e5d4683d5f94cd4", "html_url": "https://github.com/rust-lang/rust/commit/1dae309ca1c8ae89384170de2e5d4683d5f94cd4"}], "stats": {"total": 1254, "additions": 768, "deletions": 486}, "files": [{"sha": "500903c1c3b5ed22831e476e8cc2075ca78b08a5", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f9c7f9e6d069e62027e168da557625d0b518f3e/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f9c7f9e6d069e62027e168da557625d0b518f3e/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=5f9c7f9e6d069e62027e168da557625d0b518f3e", "patch": "@@ -680,7 +680,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                 let mut err = self.cannot_act_on_moved_value(use_span,\n                                                              verb,\n                                                              msg,\n-                                                             &format!(\"{}\", nl),\n+                                                             Some(format!(\"{}\", nl)),\n                                                              Origin::Ast);\n                 let need_note = match lp.ty.sty {\n                     ty::TypeVariants::TyClosure(id, _) => {"}, {"sha": "44fc67dfa437959e869863a4c244db732cf81069", "filename": "src/librustc_mir/borrow_check/error_reporting.rs", "status": "modified", "additions": 85, "deletions": 23, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/5f9c7f9e6d069e62027e168da557625d0b518f3e/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f9c7f9e6d069e62027e168da557625d0b518f3e/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs?ref=5f9c7f9e6d069e62027e168da557625d0b518f3e", "patch": "@@ -52,15 +52,17 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n             self.moved_error_reported.insert(root_place.clone());\n \n-            let item_msg = match self.describe_place(place) {\n+            let item_msg = match self.describe_place_with_options(place, IncludingDowncast(true)) {\n                 Some(name) => format!(\"`{}`\", name),\n                 None => \"value\".to_owned(),\n             };\n             self.tcx\n                 .cannot_act_on_uninitialized_variable(\n                     span,\n                     desired_action.as_noun(),\n-                    &self.describe_place(place).unwrap_or(\"_\".to_owned()),\n+                    &self\n+                        .describe_place_with_options(place, IncludingDowncast(true))\n+                        .unwrap_or(\"_\".to_owned()),\n                     Origin::Mir,\n                 )\n                 .span_label(span, format!(\"use of possibly uninitialized {}\", item_msg))\n@@ -72,14 +74,17 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 span,\n                 desired_action.as_noun(),\n                 msg,\n-                &self.describe_place(place).unwrap_or(\"_\".to_owned()),\n+                self.describe_place_with_options(&place, IncludingDowncast(true)),\n                 Origin::Mir,\n             );\n \n             let mut is_loop_move = false;\n-            for moi in mois {\n+            for moi in &mois {\n                 let move_msg = \"\"; //FIXME: add \" (into closure)\"\n-                let move_span = self.mir.source_info(self.move_data.moves[*moi].source).span;\n+                let move_span = self\n+                    .mir\n+                    .source_info(self.move_data.moves[**moi].source)\n+                    .span;\n                 if span == move_span {\n                     err.span_label(\n                         span,\n@@ -116,16 +121,23 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 };\n \n                 if needs_note {\n-                    let note_msg = match self.describe_place(place) {\n-                        Some(name) => format!(\"`{}`\", name),\n-                        None => \"value\".to_owned(),\n-                    };\n+                    let mpi = self.move_data.moves[*mois[0]].path;\n+                    let place = &self.move_data.move_paths[mpi].place;\n+\n+                    if let Some(ty) = self.retrieve_type_for_place(place) {\n+                        let note_msg = match self\n+                            .describe_place_with_options(place, IncludingDowncast(true))\n+                        {\n+                            Some(name) => format!(\"`{}`\", name),\n+                            None => \"value\".to_owned(),\n+                        };\n \n-                    err.note(&format!(\n-                        \"move occurs because {} has type `{}`, \\\n-                         which does not implement the `Copy` trait\",\n-                        note_msg, ty\n-                    ));\n+                        err.note(&format!(\n+                            \"move occurs because {} has type `{}`, \\\n+                             which does not implement the `Copy` trait\",\n+                            note_msg, ty\n+                        ));\n+                    }\n                 }\n             }\n \n@@ -644,8 +656,10 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             let local_decl = &self.mir.local_decls[*local];\n             if let Some(name) = local_decl.name {\n                 if local_decl.can_be_made_mutable() {\n-                    err.span_label(local_decl.source_info.span,\n-                                   format!(\"consider changing this to `mut {}`\", name));\n+                    err.span_label(\n+                        local_decl.source_info.span,\n+                        format!(\"consider changing this to `mut {}`\", name),\n+                    );\n                 }\n             }\n         }\n@@ -654,12 +668,26 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n     }\n }\n \n+pub(super) struct IncludingDowncast(bool);\n+\n impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n     // End-user visible description of `place` if one can be found. If the\n     // place is a temporary for instance, None will be returned.\n     pub(super) fn describe_place(&self, place: &Place<'tcx>) -> Option<String> {\n+        self.describe_place_with_options(place, IncludingDowncast(false))\n+    }\n+\n+    // End-user visible description of `place` if one can be found. If the\n+    // place is a temporary for instance, None will be returned.\n+    // `IncludingDowncast` parameter makes the function return `Err` if `ProjectionElem` is\n+    // `Downcast` and `IncludingDowncast` is true\n+    pub(super) fn describe_place_with_options(\n+        &self,\n+        place: &Place<'tcx>,\n+        including_downcast: IncludingDowncast,\n+    ) -> Option<String> {\n         let mut buf = String::new();\n-        match self.append_place_to_string(place, &mut buf, false) {\n+        match self.append_place_to_string(place, &mut buf, false, &including_downcast) {\n             Ok(()) => Some(buf),\n             Err(()) => None,\n         }\n@@ -671,6 +699,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         place: &Place<'tcx>,\n         buf: &mut String,\n         mut autoderef: bool,\n+        including_downcast: &IncludingDowncast,\n     ) -> Result<(), ()> {\n         match *place {\n             Place::Local(local) => {\n@@ -692,15 +721,33 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                             }\n                         } else {\n                             if autoderef {\n-                                self.append_place_to_string(&proj.base, buf, autoderef)?;\n+                                self.append_place_to_string(\n+                                    &proj.base,\n+                                    buf,\n+                                    autoderef,\n+                                    &including_downcast,\n+                                )?;\n                             } else {\n                                 buf.push_str(&\"*\");\n-                                self.append_place_to_string(&proj.base, buf, autoderef)?;\n+                                self.append_place_to_string(\n+                                    &proj.base,\n+                                    buf,\n+                                    autoderef,\n+                                    &including_downcast,\n+                                )?;\n                             }\n                         }\n                     }\n                     ProjectionElem::Downcast(..) => {\n-                        self.append_place_to_string(&proj.base, buf, autoderef)?;\n+                        self.append_place_to_string(\n+                            &proj.base,\n+                            buf,\n+                            autoderef,\n+                            &including_downcast,\n+                        )?;\n+                        if including_downcast.0 {\n+                            return Err(());\n+                        }\n                     }\n                     ProjectionElem::Field(field, _ty) => {\n                         autoderef = true;\n@@ -711,14 +758,24 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                             buf.push_str(&name);\n                         } else {\n                             let field_name = self.describe_field(&proj.base, field);\n-                            self.append_place_to_string(&proj.base, buf, autoderef)?;\n+                            self.append_place_to_string(\n+                                &proj.base,\n+                                buf,\n+                                autoderef,\n+                                &including_downcast,\n+                            )?;\n                             buf.push_str(&format!(\".{}\", field_name));\n                         }\n                     }\n                     ProjectionElem::Index(index) => {\n                         autoderef = true;\n \n-                        self.append_place_to_string(&proj.base, buf, autoderef)?;\n+                        self.append_place_to_string(\n+                            &proj.base,\n+                            buf,\n+                            autoderef,\n+                            &including_downcast,\n+                        )?;\n                         buf.push_str(\"[\");\n                         if let Err(_) = self.append_local_to_string(index, buf) {\n                             buf.push_str(\"..\");\n@@ -730,7 +787,12 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                         // Since it isn't possible to borrow an element on a particular index and\n                         // then use another while the borrow is held, don't output indices details\n                         // to avoid confusing the end-user\n-                        self.append_place_to_string(&proj.base, buf, autoderef)?;\n+                        self.append_place_to_string(\n+                            &proj.base,\n+                            buf,\n+                            autoderef,\n+                            &including_downcast,\n+                        )?;\n                         buf.push_str(&\"[..]\");\n                     }\n                 };"}, {"sha": "6d77364aae02a6b783beceef0339cf6aec44e611", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 171, "deletions": 142, "changes": 313, "blob_url": "https://github.com/rust-lang/rust/blob/5f9c7f9e6d069e62027e168da557625d0b518f3e/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f9c7f9e6d069e62027e168da557625d0b518f3e/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=5f9c7f9e6d069e62027e168da557625d0b518f3e", "patch": "@@ -15,13 +15,13 @@ use rustc::hir;\n use rustc::hir::def_id::DefId;\n use rustc::hir::map::definitions::DefPathData;\n use rustc::infer::InferCtxt;\n-use rustc::ty::{self, ParamEnv, TyCtxt};\n-use rustc::ty::query::Providers;\n use rustc::lint::builtin::UNUSED_MUT;\n use rustc::mir::{self, AggregateKind, BasicBlock, BorrowCheckResult, BorrowKind};\n-use rustc::mir::{ClearCrossCrate, Local, Location, Place, Mir, Mutability, Operand};\n-use rustc::mir::{Projection, ProjectionElem, Rvalue, Field, Statement, StatementKind};\n+use rustc::mir::{ClearCrossCrate, Local, Location, Mir, Mutability, Operand, Place};\n+use rustc::mir::{Field, Projection, ProjectionElem, Rvalue, Statement, StatementKind};\n use rustc::mir::{Terminator, TerminatorKind};\n+use rustc::ty::query::Providers;\n+use rustc::ty::{self, ParamEnv, TyCtxt};\n \n use rustc_data_structures::control_flow_graph::dominators::Dominators;\n use rustc_data_structures::fx::FxHashSet;\n@@ -33,20 +33,20 @@ use std::rc::Rc;\n \n use syntax_pos::Span;\n \n-use dataflow::{do_dataflow, DebugFormatted};\n+use dataflow::indexes::BorrowIndex;\n+use dataflow::move_paths::{HasMoveData, LookupResult, MoveData, MovePathIndex};\n+use dataflow::move_paths::{IllegalMoveOriginKind, MoveError};\n+use dataflow::Borrows;\n+use dataflow::DataflowResultsConsumer;\n use dataflow::FlowAtLocation;\n use dataflow::MoveDataParamEnv;\n-use dataflow::{DataflowResultsConsumer};\n-use dataflow::{MaybeInitializedPlaces, MaybeUninitializedPlaces};\n+use dataflow::{do_dataflow, DebugFormatted};\n use dataflow::{EverInitializedPlaces, MovingOutStatements};\n-use dataflow::Borrows;\n-use dataflow::indexes::BorrowIndex;\n-use dataflow::move_paths::{IllegalMoveOriginKind, MoveError};\n-use dataflow::move_paths::{HasMoveData, LookupResult, MoveData, MovePathIndex};\n+use dataflow::{MaybeInitializedPlaces, MaybeUninitializedPlaces};\n use util::borrowck_errors::{BorrowckErrors, Origin};\n use util::collect_writes::FindAssignments;\n \n-use self::borrow_set::{BorrowSet, BorrowData};\n+use self::borrow_set::{BorrowData, BorrowSet};\n use self::flows::Flows;\n use self::location::LocationTable;\n use self::prefixes::PrefixSet;\n@@ -58,9 +58,9 @@ crate mod borrow_set;\n mod error_reporting;\n mod flows;\n mod location;\n+mod path_utils;\n crate mod place_ext;\n mod prefixes;\n-mod path_utils;\n mod used_muts;\n \n pub(crate) mod nll;\n@@ -72,10 +72,7 @@ pub fn provide(providers: &mut Providers) {\n     };\n }\n \n-fn mir_borrowck<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    def_id: DefId,\n-) -> BorrowCheckResult<'tcx> {\n+fn mir_borrowck<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> BorrowCheckResult<'tcx> {\n     let input_mir = tcx.mir_validated(def_id);\n     debug!(\"run query mir_borrowck: {}\", tcx.item_path_str(def_id));\n \n@@ -103,7 +100,8 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n     let tcx = infcx.tcx;\n     let attributes = tcx.get_attrs(def_id);\n     let param_env = tcx.param_env(def_id);\n-    let id = tcx.hir\n+    let id = tcx\n+        .hir\n         .as_local_node_id(def_id)\n         .expect(\"do_mir_borrowck: non-local DefId\");\n \n@@ -138,9 +136,10 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n                         // borrow to provide feedback about why this\n                         // was a move rather than a copy.\n                         match ty.sty {\n-                            ty::TyArray(..) | ty::TySlice(..) =>\n-                                tcx.cannot_move_out_of_interior_noncopy(span, ty, None, origin),\n-                            _ => tcx.cannot_move_out_of(span, \"borrowed content\", origin)\n+                            ty::TyArray(..) | ty::TySlice(..) => {\n+                                tcx.cannot_move_out_of_interior_noncopy(span, ty, None, origin)\n+                            }\n+                            _ => tcx.cannot_move_out_of(span, \"borrowed content\", origin),\n                         }\n                     }\n                     IllegalMoveOriginKind::InteriorOfTypeWithDestructor { container_ty: ty } => {\n@@ -277,16 +276,21 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n     // Note that this set is expected to be small - only upvars from closures\n     // would have a chance of erroneously adding non-user-defined mutable vars\n     // to the set.\n-    let temporary_used_locals: FxHashSet<Local> =\n-        mbcx.used_mut.iter()\n-            .filter(|&local| !mbcx.mir.local_decls[*local].is_user_variable.is_some())\n-            .cloned()\n-            .collect();\n+    let temporary_used_locals: FxHashSet<Local> = mbcx\n+        .used_mut\n+        .iter()\n+        .filter(|&local| !mbcx.mir.local_decls[*local].is_user_variable.is_some())\n+        .cloned()\n+        .collect();\n     mbcx.gather_used_muts(temporary_used_locals);\n \n     debug!(\"mbcx.used_mut: {:?}\", mbcx.used_mut);\n \n-    for local in mbcx.mir.mut_vars_and_args_iter().filter(|local| !mbcx.used_mut.contains(local)) {\n+    for local in mbcx\n+        .mir\n+        .mut_vars_and_args_iter()\n+        .filter(|local| !mbcx.used_mut.contains(local))\n+    {\n         if let ClearCrossCrate::Set(ref vsi) = mbcx.mir.source_scope_local_data {\n             let local_decl = &mbcx.mir.local_decls[local];\n \n@@ -297,7 +301,9 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n \n             // Skip over locals that begin with an underscore or have no name\n             match local_decl.name {\n-                Some(name) => if name.as_str().starts_with(\"_\") { continue; },\n+                Some(name) => if name.as_str().starts_with(\"_\") {\n+                    continue;\n+                },\n                 None => continue,\n             }\n \n@@ -308,10 +314,9 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n                 UNUSED_MUT,\n                 vsi[local_decl.source_info.scope].lint_root,\n                 span,\n-                \"variable does not need to be mutable\"\n-            )\n-            .span_suggestion_short(mut_span, \"remove this `mut`\", \"\".to_owned())\n-            .emit();\n+                \"variable does not need to be mutable\",\n+            ).span_suggestion_short(mut_span, \"remove this `mut`\", \"\".to_owned())\n+                .emit();\n         }\n     }\n \n@@ -419,12 +424,13 @@ impl<'cx, 'gcx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx\n                 );\n             }\n             StatementKind::ReadForMatch(ref place) => {\n-                self.access_place(ContextKind::ReadForMatch.new(location),\n-                                  (place, span),\n-                                  (Deep, Read(ReadKind::Borrow(BorrowKind::Shared))),\n-                                  LocalMutationIsAllowed::No,\n-                                  flow_state,\n-                                  );\n+                self.access_place(\n+                    ContextKind::ReadForMatch.new(location),\n+                    (place, span),\n+                    (Deep, Read(ReadKind::Borrow(BorrowKind::Shared))),\n+                    LocalMutationIsAllowed::No,\n+                    flow_state,\n+                );\n             }\n             StatementKind::SetDiscriminant {\n                 ref place,\n@@ -479,10 +485,10 @@ impl<'cx, 'gcx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx\n                 // ignored when consuming results (update to\n                 // flow_state already handled).\n             }\n-            StatementKind::Nop |\n-            StatementKind::UserAssertTy(..) |\n-            StatementKind::Validate(..) |\n-            StatementKind::StorageLive(..) => {\n+            StatementKind::Nop\n+            | StatementKind::UserAssertTy(..)\n+            | StatementKind::Validate(..)\n+            | StatementKind::StorageLive(..) => {\n                 // `Nop`, `UserAssertTy`, `Validate`, and `StorageLive` are irrelevant\n                 // to borrow check.\n             }\n@@ -596,11 +602,7 @@ impl<'cx, 'gcx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx\n                 use rustc::mir::interpret::EvalErrorKind::BoundsCheck;\n                 if let BoundsCheck { ref len, ref index } = *msg {\n                     self.consume_operand(ContextKind::Assert.new(loc), (len, span), flow_state);\n-                    self.consume_operand(\n-                        ContextKind::Assert.new(loc),\n-                        (index, span),\n-                        flow_state,\n-                    );\n+                    self.consume_operand(ContextKind::Assert.new(loc), (index, span), flow_state);\n                 }\n             }\n \n@@ -660,8 +662,8 @@ enum MutateMode {\n     WriteAndRead,\n }\n \n-use self::ShallowOrDeep::{Deep, Shallow};\n use self::ReadOrWrite::{Activation, Read, Reservation, Write};\n+use self::ShallowOrDeep::{Deep, Shallow};\n \n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n enum ArtificialField {\n@@ -795,10 +797,8 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         span: Span,\n     ) {\n         let gcx = self.tcx.global_tcx();\n-        let drop_field = |\n-            mir: &mut MirBorrowckCtxt<'cx, 'gcx, 'tcx>,\n-            (index, field): (usize, ty::Ty<'gcx>),\n-        | {\n+        let drop_field = |mir: &mut MirBorrowckCtxt<'cx, 'gcx, 'tcx>,\n+                          (index, field): (usize, ty::Ty<'gcx>)| {\n             let field_ty = gcx.normalize_erasing_regions(mir.param_env, field);\n             let place = drop_place.clone().field(Field::new(index), field_ty);\n \n@@ -820,23 +820,31 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             }\n             // Same as above, but for tuples.\n             ty::TyTuple(tys) => {\n-                tys.iter().cloned().enumerate()\n+                tys.iter()\n+                    .cloned()\n+                    .enumerate()\n                     .for_each(|field| drop_field(self, field));\n             }\n             // Closures also have disjoint fields, but they are only\n             // directly accessed in the body of the closure.\n             ty::TyClosure(def, substs)\n-                if *drop_place == Place::Local(Local::new(1)) && !self.mir.upvar_decls.is_empty()\n-            => {\n-                substs.upvar_tys(def, self.tcx).enumerate()\n+                if *drop_place == Place::Local(Local::new(1))\n+                    && !self.mir.upvar_decls.is_empty() =>\n+            {\n+                substs\n+                    .upvar_tys(def, self.tcx)\n+                    .enumerate()\n                     .for_each(|field| drop_field(self, field));\n             }\n             // Generators also have disjoint fields, but they are only\n             // directly accessed in the body of the generator.\n             ty::TyGenerator(def, substs, _)\n-                if *drop_place == Place::Local(Local::new(1)) && !self.mir.upvar_decls.is_empty()\n-            => {\n-                substs.upvar_tys(def, self.tcx).enumerate()\n+                if *drop_place == Place::Local(Local::new(1))\n+                    && !self.mir.upvar_decls.is_empty() =>\n+            {\n+                substs\n+                    .upvar_tys(def, self.tcx)\n+                    .enumerate()\n                     .for_each(|field| drop_field(self, field));\n             }\n             _ => {\n@@ -888,7 +896,8 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             }\n         }\n \n-        if self.access_place_error_reported\n+        if self\n+            .access_place_error_reported\n             .contains(&(place_span.0.clone(), place_span.1))\n         {\n             debug!(\n@@ -931,10 +940,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n     ) -> bool {\n         debug!(\n             \"check_access_for_conflict(context={:?}, place_span={:?}, sd={:?}, rw={:?})\",\n-            context,\n-            place_span,\n-            sd,\n-            rw,\n+            context, place_span, sd, rw,\n         );\n \n         let mut error_reported = false;\n@@ -951,8 +957,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             (sd, place_span.0),\n             &borrow_set,\n             flow_state.borrows_in_scope(location),\n-            |this, borrow_index, borrow|\n-            match (rw, borrow.kind) {\n+            |this, borrow_index, borrow| match (rw, borrow.kind) {\n                 // Obviously an activation is compatible with its own\n                 // reservation (or even prior activating uses of same\n                 // borrow); so don't check if they interfere.\n@@ -989,12 +994,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                         }\n                         ReadKind::Borrow(bk) => {\n                             error_reported = true;\n-                            this.report_conflicting_borrow(\n-                                context,\n-                                place_span,\n-                                bk,\n-                                &borrow,\n-                            )\n+                            this.report_conflicting_borrow(context, place_span, bk, &borrow)\n                         }\n                     }\n                     Control::Break\n@@ -1026,12 +1026,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     match kind {\n                         WriteKind::MutableBorrow(bk) => {\n                             error_reported = true;\n-                            this.report_conflicting_borrow(\n-                                context,\n-                                place_span,\n-                                bk,\n-                                &borrow,\n-                            )\n+                            this.report_conflicting_borrow(context, place_span, bk, &borrow)\n                         }\n                         WriteKind::StorageDeadOrDrop => {\n                             error_reported = true;\n@@ -1185,7 +1180,9 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 // moved into the closure and subsequently used by the closure,\n                 // in order to populate our used_mut set.\n                 if let AggregateKind::Closure(def_id, _) = &**aggregate_kind {\n-                    let BorrowCheckResult { used_mut_upvars, .. } = self.tcx.mir_borrowck(*def_id);\n+                    let BorrowCheckResult {\n+                        used_mut_upvars, ..\n+                    } = self.tcx.mir_borrowck(*def_id);\n                     debug!(\"{:?} used_mut_upvars={:?}\", def_id, used_mut_upvars);\n                     for field in used_mut_upvars {\n                         match operands[field.index()] {\n@@ -1197,9 +1194,9 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                                     self.used_mut_upvars.push(field);\n                                 }\n                             }\n-                            Operand::Move(Place::Static(..)) |\n-                            Operand::Copy(..) |\n-                            Operand::Constant(..) => {}\n+                            Operand::Move(Place::Static(..))\n+                            | Operand::Copy(..)\n+                            | Operand::Constant(..) => {}\n                         }\n                     }\n                 }\n@@ -1280,7 +1277,8 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             Place::Static(statik) => {\n                 // Thread-locals might be dropped after the function exits, but\n                 // \"true\" statics will never be.\n-                let is_thread_local = self.tcx\n+                let is_thread_local = self\n+                    .tcx\n                     .get_attrs(statik.def_id)\n                     .iter()\n                     .any(|attr| attr.check_name(\"thread_local\"));\n@@ -1676,8 +1674,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             Reservation(WriteKind::MutableBorrow(borrow_kind @ BorrowKind::Unique))\n             | Reservation(WriteKind::MutableBorrow(borrow_kind @ BorrowKind::Mut { .. }))\n             | Write(WriteKind::MutableBorrow(borrow_kind @ BorrowKind::Unique))\n-            | Write(WriteKind::MutableBorrow(borrow_kind @ BorrowKind::Mut { .. })) =>\n-            {\n+            | Write(WriteKind::MutableBorrow(borrow_kind @ BorrowKind::Mut { .. })) => {\n                 let is_local_mutation_allowed = match borrow_kind {\n                     BorrowKind::Unique => LocalMutationIsAllowed::Yes,\n                     BorrowKind::Mut { .. } => is_local_mutation_allowed,\n@@ -1747,28 +1744,33 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n         // `act` and `acted_on` are strings that let us abstract over\n         // the verbs used in some diagnostic messages.\n-        let act; let acted_on;\n+        let act;\n+        let acted_on;\n \n         match error_access {\n             AccessKind::Mutate => {\n                 let item_msg = match the_place_err {\n                     Place::Projection(box Projection {\n                         base: _,\n-                        elem: ProjectionElem::Deref }\n-                    ) => match self.describe_place(place) {\n-                        Some(description) =>\n-                            format!(\"`{}` which is behind a `&` reference\", description),\n+                        elem: ProjectionElem::Deref,\n+                    }) => match self.describe_place(place) {\n+                        Some(description) => {\n+                            format!(\"`{}` which is behind a `&` reference\", description)\n+                        }\n                         None => format!(\"data in a `&` reference\"),\n                     },\n                     _ => item_msg,\n                 };\n                 err = self.tcx.cannot_assign(span, &item_msg, Origin::Mir);\n-                act = \"assign\"; acted_on = \"written\";\n+                act = \"assign\";\n+                acted_on = \"written\";\n             }\n             AccessKind::MutableBorrow => {\n-                err = self.tcx\n+                err = self\n+                    .tcx\n                     .cannot_borrow_path_as_mutable(span, &item_msg, Origin::Mir);\n-                act = \"borrow as mutable\"; acted_on = \"borrowed as mutable\";\n+                act = \"borrow as mutable\";\n+                acted_on = \"borrowed as mutable\";\n             }\n         }\n \n@@ -1783,23 +1785,27 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 let local_decl = &self.mir.local_decls[*local];\n                 assert_eq!(local_decl.mutability, Mutability::Not);\n \n-                err.span_label(span, format!(\"cannot {ACT}\", ACT=act));\n-                err.span_suggestion(local_decl.source_info.span,\n-                                    \"consider changing this to be mutable\",\n-                                    format!(\"mut {}\", local_decl.name.unwrap()));\n+                err.span_label(span, format!(\"cannot {ACT}\", ACT = act));\n+                err.span_suggestion(\n+                    local_decl.source_info.span,\n+                    \"consider changing this to be mutable\",\n+                    format!(\"mut {}\", local_decl.name.unwrap()),\n+                );\n             }\n \n             // complete hack to approximate old AST-borrowck\n             // diagnostic: if the span starts with a mutable borrow of\n             // a local variable, then just suggest the user remove it.\n-            Place::Local(_) if {\n-                if let Ok(snippet) = self.tcx.sess.codemap().span_to_snippet(span) {\n-                    snippet.starts_with(\"&mut \")\n-                } else {\n-                    false\n-                }\n-            } => {\n-                err.span_label(span, format!(\"cannot {ACT}\", ACT=act));\n+            Place::Local(_)\n+                if {\n+                    if let Ok(snippet) = self.tcx.sess.codemap().span_to_snippet(span) {\n+                        snippet.starts_with(\"&mut \")\n+                    } else {\n+                        false\n+                    }\n+                } =>\n+            {\n+                err.span_label(span, format!(\"cannot {ACT}\", ACT = act));\n                 err.span_label(span, \"try removing `&mut` here\");\n             }\n \n@@ -1808,29 +1814,40 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             //\n             // FIXME: can this case be generalized to work for an\n             // arbitrary base for the projection?\n-            Place::Projection(box Projection { base: Place::Local(local),\n-                                               elem: ProjectionElem::Deref })\n-                if self.mir.local_decls[*local].is_nonref_binding() =>\n+            Place::Projection(box Projection {\n+                base: Place::Local(local),\n+                elem: ProjectionElem::Deref,\n+            }) if self.mir.local_decls[*local].is_nonref_binding() =>\n             {\n                 let (err_help_span, suggested_code) =\n                     find_place_to_suggest_ampmut(self.tcx, self.mir, *local);\n-                err.span_suggestion(err_help_span,\n-                                    \"consider changing this to be a mutable reference\",\n-                                    suggested_code);\n+                err.span_suggestion(\n+                    err_help_span,\n+                    \"consider changing this to be a mutable reference\",\n+                    suggested_code,\n+                );\n \n                 let local_decl = &self.mir.local_decls[*local];\n                 if let Some(name) = local_decl.name {\n                     err.span_label(\n-                        span, format!(\"`{NAME}` is a `&` reference, \\\n-                                       so the data it refers to cannot be {ACTED_ON}\",\n-                                      NAME=name, ACTED_ON=acted_on));\n+                        span,\n+                        format!(\n+                            \"`{NAME}` is a `&` reference, \\\n+                             so the data it refers to cannot be {ACTED_ON}\",\n+                            NAME = name,\n+                            ACTED_ON = acted_on\n+                        ),\n+                    );\n                 } else {\n-                    err.span_label(span, format!(\"cannot {ACT} through `&`-reference\", ACT=act));\n+                    err.span_label(\n+                        span,\n+                        format!(\"cannot {ACT} through `&`-reference\", ACT = act),\n+                    );\n                 }\n             }\n \n             _ => {\n-                err.span_label(span, format!(\"cannot {ACT}\", ACT=act));\n+                err.span_label(span, format!(\"cannot {ACT}\", ACT = act));\n             }\n         }\n \n@@ -1852,10 +1869,11 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         // for example, if the RHS is present and the Type is not, then the type is going to\n         // be inferred *from* the RHS, which means we should highlight that (and suggest\n         // that they borrow the RHS mutably).\n-        fn find_place_to_suggest_ampmut<'cx, 'gcx, 'tcx>(tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n-                                                         mir: &Mir<'tcx>,\n-                                                         local: Local) -> (Span, String)\n-        {\n+        fn find_place_to_suggest_ampmut<'cx, 'gcx, 'tcx>(\n+            tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n+            mir: &Mir<'tcx>,\n+            local: Local,\n+        ) -> (Span, String) {\n             // This implementation attempts to emulate AST-borrowck prioritization\n             // by trying (3.), then (2.) and finally falling back on (1.).\n             let locations = mir.find_assignments(local);\n@@ -1877,7 +1895,9 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 // if this is a variable binding with an explicit type,\n                 // try to highlight that for the suggestion.\n                 Some(ClearCrossCrate::Set(mir::BindingForm::Var(mir::VarBindingForm {\n-                    opt_ty_info: Some(ty_span), .. }))) => ty_span,\n+                    opt_ty_info: Some(ty_span),\n+                    ..\n+                }))) => ty_span,\n \n                 Some(ClearCrossCrate::Clear) => bug!(\"saw cleared local state\"),\n \n@@ -1896,7 +1916,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n     fn add_used_mut<'d>(\n         &mut self,\n         root_place: RootPlace<'d, 'tcx>,\n-        flow_state: &Flows<'cx, 'gcx, 'tcx>\n+        flow_state: &Flows<'cx, 'gcx, 'tcx>,\n     ) {\n         match root_place {\n             RootPlace {\n@@ -1944,29 +1964,32 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 let local = &self.mir.local_decls[local];\n                 match local.mutability {\n                     Mutability::Not => match is_local_mutation_allowed {\n-                        LocalMutationIsAllowed::Yes => {\n-                            Ok(RootPlace {\n-                                place,\n-                                is_local_mutation_allowed: LocalMutationIsAllowed::Yes\n-                            })\n-                        }\n-                        LocalMutationIsAllowed::ExceptUpvars => {\n-                            Ok(RootPlace {\n-                                place,\n-                                is_local_mutation_allowed: LocalMutationIsAllowed::ExceptUpvars\n-                            })\n-                        }\n+                        LocalMutationIsAllowed::Yes => Ok(RootPlace {\n+                            place,\n+                            is_local_mutation_allowed: LocalMutationIsAllowed::Yes,\n+                        }),\n+                        LocalMutationIsAllowed::ExceptUpvars => Ok(RootPlace {\n+                            place,\n+                            is_local_mutation_allowed: LocalMutationIsAllowed::ExceptUpvars,\n+                        }),\n                         LocalMutationIsAllowed::No => Err(place),\n                     },\n-                    Mutability::Mut => Ok(RootPlace { place, is_local_mutation_allowed }),\n+                    Mutability::Mut => Ok(RootPlace {\n+                        place,\n+                        is_local_mutation_allowed,\n+                    }),\n                 }\n             }\n-            Place::Static(ref static_) =>\n+            Place::Static(ref static_) => {\n                 if self.tcx.is_static(static_.def_id) != Some(hir::Mutability::MutMutable) {\n                     Err(place)\n                 } else {\n-                    Ok(RootPlace { place, is_local_mutation_allowed })\n-                },\n+                    Ok(RootPlace {\n+                        place,\n+                        is_local_mutation_allowed,\n+                    })\n+                }\n+            }\n             Place::Projection(ref proj) => {\n                 match proj.elem {\n                     ProjectionElem::Deref => {\n@@ -2004,7 +2027,10 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                                     // `*mut` raw pointers are always mutable, regardless of\n                                     // context. The users have to check by themselves.\n                                     hir::MutMutable => {\n-                                        return Ok(RootPlace { place, is_local_mutation_allowed });\n+                                        return Ok(RootPlace {\n+                                            place,\n+                                            is_local_mutation_allowed,\n+                                        });\n                                     }\n                                 }\n                             }\n@@ -2063,7 +2089,10 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                                     // }\n                                     // ```\n                                     let _ = self.is_mutable(&proj.base, is_local_mutation_allowed)?;\n-                                    Ok(RootPlace { place, is_local_mutation_allowed })\n+                                    Ok(RootPlace {\n+                                        place,\n+                                        is_local_mutation_allowed,\n+                                    })\n                                 }\n                             }\n                         } else {\n@@ -2083,7 +2112,8 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         match *place {\n             Place::Projection(ref proj) => match proj.elem {\n                 ProjectionElem::Field(field, _ty) => {\n-                    let is_projection_from_ty_closure = proj.base\n+                    let is_projection_from_ty_closure = proj\n+                        .base\n                         .ty(self.mir, self.tcx)\n                         .to_ty(self.tcx)\n                         .is_closure();\n@@ -2185,4 +2215,3 @@ impl ContextKind {\n         }\n     }\n }\n-"}, {"sha": "be87365bdbb5d98bb370ffca66e6071ff667aae6", "filename": "src/librustc_mir/util/borrowck_errors.rs", "status": "modified", "additions": 470, "deletions": 311, "changes": 781, "blob_url": "https://github.com/rust-lang/rust/blob/5f9c7f9e6d069e62027e168da557625d0b518f3e/src%2Flibrustc_mir%2Futil%2Fborrowck_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f9c7f9e6d069e62027e168da557625d0b518f3e/src%2Flibrustc_mir%2Futil%2Fborrowck_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fborrowck_errors.rs?ref=5f9c7f9e6d069e62027e168da557625d0b518f3e", "patch": "@@ -8,15 +8,18 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use rustc::ty::{self, TyCtxt};\n use rustc::session::config::BorrowckMode;\n+use rustc::ty::{self, TyCtxt};\n use rustc_errors::{DiagnosticBuilder, DiagnosticId};\n use syntax_pos::{MultiSpan, Span};\n \n use std::fmt;\n \n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n-pub enum Origin { Ast, Mir }\n+pub enum Origin {\n+    Ast,\n+    Mir,\n+}\n \n impl fmt::Display for Origin {\n     fn fmt(&self, w: &mut fmt::Formatter) -> fmt::Result {\n@@ -53,472 +56,628 @@ impl Origin {\n }\n \n pub trait BorrowckErrors<'cx>: Sized + Copy {\n-    fn struct_span_err_with_code<S: Into<MultiSpan>>(self,\n-                                                     sp: S,\n-                                                     msg: &str,\n-                                                     code: DiagnosticId)\n-                                                     -> DiagnosticBuilder<'cx>;\n+    fn struct_span_err_with_code<S: Into<MultiSpan>>(\n+        self,\n+        sp: S,\n+        msg: &str,\n+        code: DiagnosticId,\n+    ) -> DiagnosticBuilder<'cx>;\n \n-    fn struct_span_err<S: Into<MultiSpan>>(self,\n-                                           sp: S,\n-                                           msg: &str)\n-                                           -> DiagnosticBuilder<'cx>;\n+    fn struct_span_err<S: Into<MultiSpan>>(self, sp: S, msg: &str) -> DiagnosticBuilder<'cx>;\n \n     /// Cancels the given error if we shouldn't emit errors for a given\n     /// origin in the current mode.\n     ///\n     /// Always make sure that the error gets passed through this function\n     /// before you return it.\n-    fn cancel_if_wrong_origin(self,\n-                              diag: DiagnosticBuilder<'cx>,\n-                              o: Origin)\n-                              -> DiagnosticBuilder<'cx>;\n-\n-    fn cannot_move_when_borrowed(self, span: Span, desc: &str, o: Origin)\n-                                 -> DiagnosticBuilder<'cx>\n-    {\n-        let err = struct_span_err!(self, span, E0505,\n-                                   \"cannot move out of `{}` because it is borrowed{OGN}\",\n-                                   desc, OGN=o);\n+    fn cancel_if_wrong_origin(\n+        self,\n+        diag: DiagnosticBuilder<'cx>,\n+        o: Origin,\n+    ) -> DiagnosticBuilder<'cx>;\n+\n+    fn cannot_move_when_borrowed(\n+        self,\n+        span: Span,\n+        desc: &str,\n+        o: Origin,\n+    ) -> DiagnosticBuilder<'cx> {\n+        let err = struct_span_err!(\n+            self,\n+            span,\n+            E0505,\n+            \"cannot move out of `{}` because it is borrowed{OGN}\",\n+            desc,\n+            OGN = o\n+        );\n         self.cancel_if_wrong_origin(err, o)\n     }\n \n-    fn cannot_use_when_mutably_borrowed(self,\n-                                        span: Span,\n-                                        desc: &str,\n-                                        borrow_span: Span,\n-                                        borrow_desc: &str,\n-                                        o: Origin)\n-                                        -> DiagnosticBuilder<'cx>\n-    {\n-        let mut err = struct_span_err!(self, span, E0503,\n-                         \"cannot use `{}` because it was mutably borrowed{OGN}\",\n-                         desc, OGN=o);\n-\n-        err.span_label(borrow_span, format!(\"borrow of `{}` occurs here\", borrow_desc));\n+    fn cannot_use_when_mutably_borrowed(\n+        self,\n+        span: Span,\n+        desc: &str,\n+        borrow_span: Span,\n+        borrow_desc: &str,\n+        o: Origin,\n+    ) -> DiagnosticBuilder<'cx> {\n+        let mut err = struct_span_err!(\n+            self,\n+            span,\n+            E0503,\n+            \"cannot use `{}` because it was mutably borrowed{OGN}\",\n+            desc,\n+            OGN = o\n+        );\n+\n+        err.span_label(\n+            borrow_span,\n+            format!(\"borrow of `{}` occurs here\", borrow_desc),\n+        );\n         err.span_label(span, format!(\"use of borrowed `{}`\", borrow_desc));\n \n         self.cancel_if_wrong_origin(err, o)\n     }\n \n-    fn cannot_act_on_uninitialized_variable(self,\n-                                            span: Span,\n-                                            verb: &str,\n-                                            desc: &str,\n-                                            o: Origin)\n-                                            -> DiagnosticBuilder<'cx>\n-    {\n-        let err = struct_span_err!(self, span, E0381,\n-                                   \"{} of possibly uninitialized variable: `{}`{OGN}\",\n-                                   verb, desc, OGN=o);\n+    fn cannot_act_on_uninitialized_variable(\n+        self,\n+        span: Span,\n+        verb: &str,\n+        desc: &str,\n+        o: Origin,\n+    ) -> DiagnosticBuilder<'cx> {\n+        let err = struct_span_err!(\n+            self,\n+            span,\n+            E0381,\n+            \"{} of possibly uninitialized variable: `{}`{OGN}\",\n+            verb,\n+            desc,\n+            OGN = o\n+        );\n         self.cancel_if_wrong_origin(err, o)\n     }\n \n-    fn cannot_mutably_borrow_multiply(self,\n-                                      new_loan_span: Span,\n-                                      desc: &str,\n-                                      opt_via: &str,\n-                                      old_loan_span: Span,\n-                                      old_opt_via: &str,\n-                                      old_load_end_span: Option<Span>,\n-                                      o: Origin)\n-                                      -> DiagnosticBuilder<'cx>\n-    {\n-        let mut err = struct_span_err!(self, new_loan_span, E0499,\n-                         \"cannot borrow `{}`{} as mutable more than once at a time{OGN}\",\n-                         desc, opt_via, OGN=o);\n+    fn cannot_mutably_borrow_multiply(\n+        self,\n+        new_loan_span: Span,\n+        desc: &str,\n+        opt_via: &str,\n+        old_loan_span: Span,\n+        old_opt_via: &str,\n+        old_load_end_span: Option<Span>,\n+        o: Origin,\n+    ) -> DiagnosticBuilder<'cx> {\n+        let mut err = struct_span_err!(\n+            self,\n+            new_loan_span,\n+            E0499,\n+            \"cannot borrow `{}`{} as mutable more than once at a time{OGN}\",\n+            desc,\n+            opt_via,\n+            OGN = o\n+        );\n         if old_loan_span == new_loan_span {\n             // Both borrows are happening in the same place\n             // Meaning the borrow is occurring in a loop\n-            err.span_label(new_loan_span,\n-                           format!(\"mutable borrow starts here in previous \\\n-                                    iteration of loop{}\", opt_via));\n+            err.span_label(\n+                new_loan_span,\n+                format!(\n+                    \"mutable borrow starts here in previous \\\n+                     iteration of loop{}\",\n+                    opt_via\n+                ),\n+            );\n             if let Some(old_load_end_span) = old_load_end_span {\n                 err.span_label(old_load_end_span, \"mutable borrow ends here\");\n             }\n         } else {\n-            err.span_label(old_loan_span,\n-                           format!(\"first mutable borrow occurs here{}\", old_opt_via));\n-            err.span_label(new_loan_span,\n-                           format!(\"second mutable borrow occurs here{}\", opt_via));\n+            err.span_label(\n+                old_loan_span,\n+                format!(\"first mutable borrow occurs here{}\", old_opt_via),\n+            );\n+            err.span_label(\n+                new_loan_span,\n+                format!(\"second mutable borrow occurs here{}\", opt_via),\n+            );\n             if let Some(old_load_end_span) = old_load_end_span {\n                 err.span_label(old_load_end_span, \"first borrow ends here\");\n             }\n         }\n         self.cancel_if_wrong_origin(err, o)\n     }\n \n-    fn cannot_uniquely_borrow_by_two_closures(self,\n-                                              new_loan_span: Span,\n-                                              desc: &str,\n-                                              old_loan_span: Span,\n-                                              old_load_end_span: Option<Span>,\n-                                              o: Origin)\n-                                              -> DiagnosticBuilder<'cx>\n-    {\n-        let mut err = struct_span_err!(self, new_loan_span, E0524,\n-                         \"two closures require unique access to `{}` at the same time{OGN}\",\n-                         desc, OGN=o);\n-        err.span_label(\n-            old_loan_span,\n-            \"first closure is constructed here\");\n-        err.span_label(\n+    fn cannot_uniquely_borrow_by_two_closures(\n+        self,\n+        new_loan_span: Span,\n+        desc: &str,\n+        old_loan_span: Span,\n+        old_load_end_span: Option<Span>,\n+        o: Origin,\n+    ) -> DiagnosticBuilder<'cx> {\n+        let mut err = struct_span_err!(\n+            self,\n             new_loan_span,\n-            \"second closure is constructed here\");\n+            E0524,\n+            \"two closures require unique access to `{}` at the same time{OGN}\",\n+            desc,\n+            OGN = o\n+        );\n+        err.span_label(old_loan_span, \"first closure is constructed here\");\n+        err.span_label(new_loan_span, \"second closure is constructed here\");\n         if let Some(old_load_end_span) = old_load_end_span {\n-            err.span_label(\n-                old_load_end_span,\n-                \"borrow from first closure ends here\");\n+            err.span_label(old_load_end_span, \"borrow from first closure ends here\");\n         }\n         self.cancel_if_wrong_origin(err, o)\n     }\n \n-    fn cannot_uniquely_borrow_by_one_closure(self,\n-                                             new_loan_span: Span,\n-                                             desc_new: &str,\n-                                             opt_via: &str,\n-                                             old_loan_span: Span,\n-                                             noun_old: &str,\n-                                             old_opt_via: &str,\n-                                             previous_end_span: Option<Span>,\n-                                             o: Origin)\n-                                             -> DiagnosticBuilder<'cx>\n-    {\n-        let mut err = struct_span_err!(self, new_loan_span, E0500,\n-                         \"closure requires unique access to `{}` but {} is already borrowed{}{OGN}\",\n-                         desc_new, noun_old, old_opt_via, OGN=o);\n-        err.span_label(new_loan_span,\n-                       format!(\"closure construction occurs here{}\", opt_via));\n-        err.span_label(old_loan_span,\n-                       format!(\"borrow occurs here{}\", old_opt_via));\n+    fn cannot_uniquely_borrow_by_one_closure(\n+        self,\n+        new_loan_span: Span,\n+        desc_new: &str,\n+        opt_via: &str,\n+        old_loan_span: Span,\n+        noun_old: &str,\n+        old_opt_via: &str,\n+        previous_end_span: Option<Span>,\n+        o: Origin,\n+    ) -> DiagnosticBuilder<'cx> {\n+        let mut err = struct_span_err!(\n+            self,\n+            new_loan_span,\n+            E0500,\n+            \"closure requires unique access to `{}` but {} is already borrowed{}{OGN}\",\n+            desc_new,\n+            noun_old,\n+            old_opt_via,\n+            OGN = o\n+        );\n+        err.span_label(\n+            new_loan_span,\n+            format!(\"closure construction occurs here{}\", opt_via),\n+        );\n+        err.span_label(old_loan_span, format!(\"borrow occurs here{}\", old_opt_via));\n         if let Some(previous_end_span) = previous_end_span {\n             err.span_label(previous_end_span, \"borrow ends here\");\n         }\n         self.cancel_if_wrong_origin(err, o)\n     }\n \n-    fn cannot_reborrow_already_uniquely_borrowed(self,\n-                                                 new_loan_span: Span,\n-                                                 desc_new: &str,\n-                                                 opt_via: &str,\n-                                                 kind_new: &str,\n-                                                 old_loan_span: Span,\n-                                                 old_opt_via: &str,\n-                                                 previous_end_span: Option<Span>,\n-                                                 o: Origin)\n-                                                 -> DiagnosticBuilder<'cx>\n-    {\n-        let mut err = struct_span_err!(self, new_loan_span, E0501,\n-                         \"cannot borrow `{}`{} as {} because previous closure \\\n-                          requires unique access{OGN}\",\n-                         desc_new, opt_via, kind_new, OGN=o);\n-        err.span_label(new_loan_span,\n-                       format!(\"borrow occurs here{}\", opt_via));\n-        err.span_label(old_loan_span,\n-                       format!(\"closure construction occurs here{}\", old_opt_via));\n+    fn cannot_reborrow_already_uniquely_borrowed(\n+        self,\n+        new_loan_span: Span,\n+        desc_new: &str,\n+        opt_via: &str,\n+        kind_new: &str,\n+        old_loan_span: Span,\n+        old_opt_via: &str,\n+        previous_end_span: Option<Span>,\n+        o: Origin,\n+    ) -> DiagnosticBuilder<'cx> {\n+        let mut err = struct_span_err!(\n+            self,\n+            new_loan_span,\n+            E0501,\n+            \"cannot borrow `{}`{} as {} because previous closure \\\n+             requires unique access{OGN}\",\n+            desc_new,\n+            opt_via,\n+            kind_new,\n+            OGN = o\n+        );\n+        err.span_label(new_loan_span, format!(\"borrow occurs here{}\", opt_via));\n+        err.span_label(\n+            old_loan_span,\n+            format!(\"closure construction occurs here{}\", old_opt_via),\n+        );\n         if let Some(previous_end_span) = previous_end_span {\n             err.span_label(previous_end_span, \"borrow from closure ends here\");\n         }\n         self.cancel_if_wrong_origin(err, o)\n     }\n \n-    fn cannot_reborrow_already_borrowed(self,\n-                                        span: Span,\n-                                        desc_new: &str,\n-                                        msg_new: &str,\n-                                        kind_new: &str,\n-                                        old_span: Span,\n-                                        noun_old: &str,\n-                                        kind_old: &str,\n-                                        msg_old: &str,\n-                                        old_load_end_span: Option<Span>,\n-                                        o: Origin)\n-                                        -> DiagnosticBuilder<'cx>\n-    {\n-        let mut err = struct_span_err!(self, span, E0502,\n-                         \"cannot borrow `{}`{} as {} because {} is also borrowed as {}{}{OGN}\",\n-                         desc_new, msg_new, kind_new, noun_old, kind_old, msg_old, OGN=o);\n+    fn cannot_reborrow_already_borrowed(\n+        self,\n+        span: Span,\n+        desc_new: &str,\n+        msg_new: &str,\n+        kind_new: &str,\n+        old_span: Span,\n+        noun_old: &str,\n+        kind_old: &str,\n+        msg_old: &str,\n+        old_load_end_span: Option<Span>,\n+        o: Origin,\n+    ) -> DiagnosticBuilder<'cx> {\n+        let mut err = struct_span_err!(\n+            self,\n+            span,\n+            E0502,\n+            \"cannot borrow `{}`{} as {} because {} is also borrowed as {}{}{OGN}\",\n+            desc_new,\n+            msg_new,\n+            kind_new,\n+            noun_old,\n+            kind_old,\n+            msg_old,\n+            OGN = o\n+        );\n         err.span_label(span, format!(\"{} borrow occurs here{}\", kind_new, msg_new));\n-        err.span_label(old_span, format!(\"{} borrow occurs here{}\", kind_old, msg_old));\n+        err.span_label(\n+            old_span,\n+            format!(\"{} borrow occurs here{}\", kind_old, msg_old),\n+        );\n         if let Some(old_load_end_span) = old_load_end_span {\n             err.span_label(old_load_end_span, format!(\"{} borrow ends here\", kind_old));\n         }\n         self.cancel_if_wrong_origin(err, o)\n     }\n \n-    fn cannot_assign_to_borrowed(self, span: Span, borrow_span: Span, desc: &str, o: Origin)\n-                                 -> DiagnosticBuilder<'cx>\n-    {\n-        let mut err = struct_span_err!(self, span, E0506,\n-                         \"cannot assign to `{}` because it is borrowed{OGN}\",\n-                         desc, OGN=o);\n+    fn cannot_assign_to_borrowed(\n+        self,\n+        span: Span,\n+        borrow_span: Span,\n+        desc: &str,\n+        o: Origin,\n+    ) -> DiagnosticBuilder<'cx> {\n+        let mut err = struct_span_err!(\n+            self,\n+            span,\n+            E0506,\n+            \"cannot assign to `{}` because it is borrowed{OGN}\",\n+            desc,\n+            OGN = o\n+        );\n \n         err.span_label(borrow_span, format!(\"borrow of `{}` occurs here\", desc));\n-        err.span_label(span, format!(\"assignment to borrowed `{}` occurs here\", desc));\n+        err.span_label(\n+            span,\n+            format!(\"assignment to borrowed `{}` occurs here\", desc),\n+        );\n \n         self.cancel_if_wrong_origin(err, o)\n     }\n \n-    fn cannot_move_into_closure(self, span: Span, desc: &str, o: Origin)\n-                                -> DiagnosticBuilder<'cx>\n-    {\n-        let err = struct_span_err!(self, span, E0504,\n-                                   \"cannot move `{}` into closure because it is borrowed{OGN}\",\n-                                   desc, OGN=o);\n+    fn cannot_move_into_closure(self, span: Span, desc: &str, o: Origin) -> DiagnosticBuilder<'cx> {\n+        let err = struct_span_err!(\n+            self,\n+            span,\n+            E0504,\n+            \"cannot move `{}` into closure because it is borrowed{OGN}\",\n+            desc,\n+            OGN = o\n+        );\n \n         self.cancel_if_wrong_origin(err, o)\n     }\n \n-    fn cannot_reassign_immutable(self, span: Span, desc: &str, is_arg: bool, o: Origin)\n-                                 -> DiagnosticBuilder<'cx>\n-    {\n+    fn cannot_reassign_immutable(\n+        self,\n+        span: Span,\n+        desc: &str,\n+        is_arg: bool,\n+        o: Origin,\n+    ) -> DiagnosticBuilder<'cx> {\n         let msg = if is_arg {\n             \"to immutable argument\"\n         } else {\n             \"twice to immutable variable\"\n         };\n-        let err = struct_span_err!(self, span, E0384,\n-                                   \"cannot assign {} `{}`{OGN}\",\n-                                   msg, desc, OGN=o);\n+        let err = struct_span_err!(\n+            self,\n+            span,\n+            E0384,\n+            \"cannot assign {} `{}`{OGN}\",\n+            msg,\n+            desc,\n+            OGN = o\n+        );\n \n         self.cancel_if_wrong_origin(err, o)\n     }\n \n-    fn cannot_assign(self, span: Span, desc: &str, o: Origin)\n-                     -> DiagnosticBuilder<'cx>\n-    {\n-        let err = struct_span_err!(self, span, E0594,\n-                                  \"cannot assign to {}{OGN}\",\n-                                  desc, OGN=o);\n+    fn cannot_assign(self, span: Span, desc: &str, o: Origin) -> DiagnosticBuilder<'cx> {\n+        let err = struct_span_err!(self, span, E0594, \"cannot assign to {}{OGN}\", desc, OGN = o);\n         self.cancel_if_wrong_origin(err, o)\n     }\n \n-    fn cannot_assign_static(self, span: Span, desc: &str, o: Origin)\n-                            -> DiagnosticBuilder<'cx>\n-    {\n+    fn cannot_assign_static(self, span: Span, desc: &str, o: Origin) -> DiagnosticBuilder<'cx> {\n         self.cannot_assign(span, &format!(\"immutable static item `{}`\", desc), o)\n     }\n \n-    fn cannot_move_out_of(self, move_from_span: Span, move_from_desc: &str, o: Origin)\n-                          -> DiagnosticBuilder<'cx>\n-    {\n-        let mut err = struct_span_err!(self, move_from_span, E0507,\n-                                       \"cannot move out of {}{OGN}\",\n-                                       move_from_desc, OGN=o);\n+    fn cannot_move_out_of(\n+        self,\n+        move_from_span: Span,\n+        move_from_desc: &str,\n+        o: Origin,\n+    ) -> DiagnosticBuilder<'cx> {\n+        let mut err = struct_span_err!(\n+            self,\n+            move_from_span,\n+            E0507,\n+            \"cannot move out of {}{OGN}\",\n+            move_from_desc,\n+            OGN = o\n+        );\n         err.span_label(\n             move_from_span,\n-            format!(\"cannot move out of {}\", move_from_desc));\n+            format!(\"cannot move out of {}\", move_from_desc),\n+        );\n \n         self.cancel_if_wrong_origin(err, o)\n     }\n \n     /// Signal an error due to an attempt to move out of the interior\n     /// of an array or slice. `is_index` is None when error origin\n     /// didn't capture whether there was an indexing operation or not.\n-    fn cannot_move_out_of_interior_noncopy(self,\n-                                           move_from_span: Span,\n-                                           ty: ty::Ty,\n-                                           is_index: Option<bool>,\n-                                           o: Origin)\n-                                           -> DiagnosticBuilder<'cx>\n-    {\n+    fn cannot_move_out_of_interior_noncopy(\n+        self,\n+        move_from_span: Span,\n+        ty: ty::Ty,\n+        is_index: Option<bool>,\n+        o: Origin,\n+    ) -> DiagnosticBuilder<'cx> {\n         let type_name = match (&ty.sty, is_index) {\n-            (&ty::TyArray(_, _), Some(true)) |\n-            (&ty::TyArray(_, _), None) => \"array\",\n-            (&ty::TySlice(_),    _) => \"slice\",\n+            (&ty::TyArray(_, _), Some(true)) | (&ty::TyArray(_, _), None) => \"array\",\n+            (&ty::TySlice(_), _) => \"slice\",\n             _ => span_bug!(move_from_span, \"this path should not cause illegal move\"),\n         };\n-        let mut err = struct_span_err!(self, move_from_span, E0508,\n-                                       \"cannot move out of type `{}`, \\\n-                                        a non-copy {}{OGN}\",\n-                                       ty, type_name, OGN=o);\n+        let mut err = struct_span_err!(\n+            self,\n+            move_from_span,\n+            E0508,\n+            \"cannot move out of type `{}`, \\\n+             a non-copy {}{OGN}\",\n+            ty,\n+            type_name,\n+            OGN = o\n+        );\n         err.span_label(move_from_span, \"cannot move out of here\");\n \n         self.cancel_if_wrong_origin(err, o)\n     }\n \n-    fn cannot_move_out_of_interior_of_drop(self,\n-                                           move_from_span: Span,\n-                                           container_ty: ty::Ty,\n-                                           o: Origin)\n-                                           -> DiagnosticBuilder<'cx>\n-    {\n-        let mut err = struct_span_err!(self, move_from_span, E0509,\n-                                       \"cannot move out of type `{}`, \\\n-                                        which implements the `Drop` trait{OGN}\",\n-                                       container_ty, OGN=o);\n+    fn cannot_move_out_of_interior_of_drop(\n+        self,\n+        move_from_span: Span,\n+        container_ty: ty::Ty,\n+        o: Origin,\n+    ) -> DiagnosticBuilder<'cx> {\n+        let mut err = struct_span_err!(\n+            self,\n+            move_from_span,\n+            E0509,\n+            \"cannot move out of type `{}`, \\\n+             which implements the `Drop` trait{OGN}\",\n+            container_ty,\n+            OGN = o\n+        );\n         err.span_label(move_from_span, \"cannot move out of here\");\n \n         self.cancel_if_wrong_origin(err, o)\n     }\n \n-    fn cannot_act_on_moved_value(self,\n-                                 use_span: Span,\n-                                 verb: &str,\n-                                 optional_adverb_for_moved: &str,\n-                                 moved_path: &str,\n-                                 o: Origin)\n-                                 -> DiagnosticBuilder<'cx>\n-    {\n-        let err = struct_span_err!(self, use_span, E0382,\n-                                   \"{} of {}moved value: `{}`{OGN}\",\n-                                   verb, optional_adverb_for_moved, moved_path, OGN=o);\n+    fn cannot_act_on_moved_value(\n+        self,\n+        use_span: Span,\n+        verb: &str,\n+        optional_adverb_for_moved: &str,\n+        moved_path: Option<String>,\n+        o: Origin,\n+    ) -> DiagnosticBuilder<'cx> {\n+        let moved_path = moved_path\n+            .map(|mp| format!(\": `{}`\", mp))\n+            .unwrap_or(\"\".to_owned());\n+\n+        let err = struct_span_err!(\n+            self,\n+            use_span,\n+            E0382,\n+            \"{} of {}moved value{}{OGN}\",\n+            verb,\n+            optional_adverb_for_moved,\n+            moved_path,\n+            OGN = o\n+        );\n \n         self.cancel_if_wrong_origin(err, o)\n     }\n \n-    fn cannot_partially_reinit_an_uninit_struct(self,\n-                                                span: Span,\n-                                                uninit_path: &str,\n-                                                o: Origin)\n-                                                -> DiagnosticBuilder<'cx>\n-    {\n-        let err = struct_span_err!(self,\n-                                   span,\n-                                   E0383,\n-                                   \"partial reinitialization of uninitialized structure `{}`{OGN}\",\n-                                   uninit_path, OGN=o);\n+    fn cannot_partially_reinit_an_uninit_struct(\n+        self,\n+        span: Span,\n+        uninit_path: &str,\n+        o: Origin,\n+    ) -> DiagnosticBuilder<'cx> {\n+        let err = struct_span_err!(\n+            self,\n+            span,\n+            E0383,\n+            \"partial reinitialization of uninitialized structure `{}`{OGN}\",\n+            uninit_path,\n+            OGN = o\n+        );\n \n         self.cancel_if_wrong_origin(err, o)\n     }\n \n-    fn closure_cannot_assign_to_borrowed(self,\n-                                         span: Span,\n-                                         descr: &str,\n-                                         o: Origin)\n-                                         -> DiagnosticBuilder<'cx>\n-    {\n-        let err = struct_span_err!(self, span, E0595, \"closure cannot assign to {}{OGN}\",\n-                                   descr, OGN=o);\n+    fn closure_cannot_assign_to_borrowed(\n+        self,\n+        span: Span,\n+        descr: &str,\n+        o: Origin,\n+    ) -> DiagnosticBuilder<'cx> {\n+        let err = struct_span_err!(\n+            self,\n+            span,\n+            E0595,\n+            \"closure cannot assign to {}{OGN}\",\n+            descr,\n+            OGN = o\n+        );\n \n         self.cancel_if_wrong_origin(err, o)\n     }\n \n-    fn cannot_borrow_path_as_mutable(self,\n-                                     span: Span,\n-                                     path: &str,\n-                                     o: Origin)\n-                                     -> DiagnosticBuilder<'cx>\n-    {\n-        let err = struct_span_err!(self, span, E0596, \"cannot borrow {} as mutable{OGN}\",\n-                                   path, OGN=o);\n+    fn cannot_borrow_path_as_mutable(\n+        self,\n+        span: Span,\n+        path: &str,\n+        o: Origin,\n+    ) -> DiagnosticBuilder<'cx> {\n+        let err = struct_span_err!(\n+            self,\n+            span,\n+            E0596,\n+            \"cannot borrow {} as mutable{OGN}\",\n+            path,\n+            OGN = o\n+        );\n \n         self.cancel_if_wrong_origin(err, o)\n     }\n \n-    fn cannot_borrow_across_generator_yield(self,\n-                                            span: Span,\n-                                            yield_span: Span,\n-                                            o: Origin)\n-                                            -> DiagnosticBuilder<'cx>\n-    {\n-        let mut err = struct_span_err!(self,\n-                                       span,\n-                                       E0626,\n-                                       \"borrow may still be in use when generator yields{OGN}\",\n-                                       OGN=o);\n+    fn cannot_borrow_across_generator_yield(\n+        self,\n+        span: Span,\n+        yield_span: Span,\n+        o: Origin,\n+    ) -> DiagnosticBuilder<'cx> {\n+        let mut err = struct_span_err!(\n+            self,\n+            span,\n+            E0626,\n+            \"borrow may still be in use when generator yields{OGN}\",\n+            OGN = o\n+        );\n         err.span_label(yield_span, \"possible yield occurs here\");\n \n         self.cancel_if_wrong_origin(err, o)\n     }\n \n-    fn path_does_not_live_long_enough(self,\n-                                      span: Span,\n-                                      path: &str,\n-                                      o: Origin)\n-                                      -> DiagnosticBuilder<'cx>\n-    {\n-        let err = struct_span_err!(self, span, E0597, \"{} does not live long enough{OGN}\",\n-                                   path, OGN=o);\n+    fn path_does_not_live_long_enough(\n+        self,\n+        span: Span,\n+        path: &str,\n+        o: Origin,\n+    ) -> DiagnosticBuilder<'cx> {\n+        let err = struct_span_err!(\n+            self,\n+            span,\n+            E0597,\n+            \"{} does not live long enough{OGN}\",\n+            path,\n+            OGN = o\n+        );\n \n         self.cancel_if_wrong_origin(err, o)\n     }\n \n-    fn lifetime_too_short_for_reborrow(self,\n-                                       span: Span,\n-                                       path: &str,\n-                                       o: Origin)\n-                                       -> DiagnosticBuilder<'cx>\n-    {\n-        let err = struct_span_err!(self, span, E0598,\n-                                   \"lifetime of {} is too short to guarantee \\\n-                                    its contents can be safely reborrowed{OGN}\",\n-                                   path, OGN=o);\n+    fn lifetime_too_short_for_reborrow(\n+        self,\n+        span: Span,\n+        path: &str,\n+        o: Origin,\n+    ) -> DiagnosticBuilder<'cx> {\n+        let err = struct_span_err!(\n+            self,\n+            span,\n+            E0598,\n+            \"lifetime of {} is too short to guarantee \\\n+             its contents can be safely reborrowed{OGN}\",\n+            path,\n+            OGN = o\n+        );\n \n         self.cancel_if_wrong_origin(err, o)\n     }\n \n-    fn cannot_act_on_capture_in_sharable_fn(self,\n-                                            span: Span,\n-                                            bad_thing: &str,\n-                                            help: (Span, &str),\n-                                            o: Origin)\n-                                            -> DiagnosticBuilder<'cx>\n-    {\n+    fn cannot_act_on_capture_in_sharable_fn(\n+        self,\n+        span: Span,\n+        bad_thing: &str,\n+        help: (Span, &str),\n+        o: Origin,\n+    ) -> DiagnosticBuilder<'cx> {\n         let (help_span, help_msg) = help;\n-        let mut err = struct_span_err!(self, span, E0387,\n-                                       \"{} in a captured outer variable in an `Fn` closure{OGN}\",\n-                                       bad_thing, OGN=o);\n+        let mut err = struct_span_err!(\n+            self,\n+            span,\n+            E0387,\n+            \"{} in a captured outer variable in an `Fn` closure{OGN}\",\n+            bad_thing,\n+            OGN = o\n+        );\n         err.span_help(help_span, help_msg);\n \n         self.cancel_if_wrong_origin(err, o)\n     }\n \n-    fn cannot_assign_into_immutable_reference(self,\n-                                              span: Span,\n-                                              bad_thing: &str,\n-                                              o: Origin)\n-                                              -> DiagnosticBuilder<'cx>\n-    {\n-        let mut err = struct_span_err!(self, span, E0389, \"{} in a `&` reference{OGN}\",\n-                                       bad_thing, OGN=o);\n+    fn cannot_assign_into_immutable_reference(\n+        self,\n+        span: Span,\n+        bad_thing: &str,\n+        o: Origin,\n+    ) -> DiagnosticBuilder<'cx> {\n+        let mut err = struct_span_err!(\n+            self,\n+            span,\n+            E0389,\n+            \"{} in a `&` reference{OGN}\",\n+            bad_thing,\n+            OGN = o\n+        );\n         err.span_label(span, \"assignment into an immutable reference\");\n \n         self.cancel_if_wrong_origin(err, o)\n     }\n \n-    fn cannot_capture_in_long_lived_closure(self,\n-                                            closure_span: Span,\n-                                            borrowed_path: &str,\n-                                            capture_span: Span,\n-                                            o: Origin)\n-                                            -> DiagnosticBuilder<'cx>\n-    {\n-        let mut err = struct_span_err!(self, closure_span, E0373,\n-                                       \"closure may outlive the current function, \\\n-                                        but it borrows {}, \\\n-                                        which is owned by the current function{OGN}\",\n-                                       borrowed_path, OGN=o);\n+    fn cannot_capture_in_long_lived_closure(\n+        self,\n+        closure_span: Span,\n+        borrowed_path: &str,\n+        capture_span: Span,\n+        o: Origin,\n+    ) -> DiagnosticBuilder<'cx> {\n+        let mut err = struct_span_err!(\n+            self,\n+            closure_span,\n+            E0373,\n+            \"closure may outlive the current function, \\\n+             but it borrows {}, \\\n+             which is owned by the current function{OGN}\",\n+            borrowed_path,\n+            OGN = o\n+        );\n         err.span_label(capture_span, format!(\"{} is borrowed here\", borrowed_path))\n-            .span_label(closure_span, format!(\"may outlive borrowed value {}\", borrowed_path));\n+            .span_label(\n+                closure_span,\n+                format!(\"may outlive borrowed value {}\", borrowed_path),\n+            );\n \n         self.cancel_if_wrong_origin(err, o)\n     }\n }\n \n impl<'cx, 'gcx, 'tcx> BorrowckErrors<'cx> for TyCtxt<'cx, 'gcx, 'tcx> {\n-    fn struct_span_err_with_code<S: Into<MultiSpan>>(self,\n-                                                     sp: S,\n-                                                     msg: &str,\n-                                                     code: DiagnosticId)\n-                                                     -> DiagnosticBuilder<'cx>\n-    {\n+    fn struct_span_err_with_code<S: Into<MultiSpan>>(\n+        self,\n+        sp: S,\n+        msg: &str,\n+        code: DiagnosticId,\n+    ) -> DiagnosticBuilder<'cx> {\n         self.sess.struct_span_err_with_code(sp, msg, code)\n     }\n \n-    fn struct_span_err<S: Into<MultiSpan>>(self,\n-                                           sp: S,\n-                                           msg: &str)\n-                                           -> DiagnosticBuilder<'cx>\n-    {\n+    fn struct_span_err<S: Into<MultiSpan>>(self, sp: S, msg: &str) -> DiagnosticBuilder<'cx> {\n         self.sess.struct_span_err(sp, msg)\n     }\n \n-    fn cancel_if_wrong_origin(self,\n-                              mut diag: DiagnosticBuilder<'cx>,\n-                              o: Origin)\n-                              -> DiagnosticBuilder<'cx>\n-    {\n+    fn cancel_if_wrong_origin(\n+        self,\n+        mut diag: DiagnosticBuilder<'cx>,\n+        o: Origin,\n+    ) -> DiagnosticBuilder<'cx> {\n         if !o.should_emit_errors(self.borrowck_mode()) {\n             self.sess.diagnostic().cancel(&mut diag);\n         }"}, {"sha": "601f05b499c75c2a46f7e73083db8cb914338dd8", "filename": "src/test/ui/borrowck/borrowck-box-insensitivity.nll.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5f9c7f9e6d069e62027e168da557625d0b518f3e/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-box-insensitivity.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5f9c7f9e6d069e62027e168da557625d0b518f3e/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-box-insensitivity.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-box-insensitivity.nll.stderr?ref=5f9c7f9e6d069e62027e168da557625d0b518f3e", "patch": "@@ -7,7 +7,7 @@ LL |     //~^ value moved here\n LL |     let _y = a.y; //~ ERROR use of moved\n    |              ^^^ value used here after move\n    |\n-   = note: move occurs because `a.y` has type `std::boxed::Box<isize>`, which does not implement the `Copy` trait\n+   = note: move occurs because `a.x` has type `std::boxed::Box<isize>`, which does not implement the `Copy` trait\n \n error[E0382]: use of moved value: `a.y`\n   --> $DIR/borrowck-box-insensitivity.rs:108:14\n@@ -18,7 +18,7 @@ LL |     //~^ value moved here\n LL |     let _y = a.y; //~ ERROR use of collaterally moved\n    |              ^^^ value used here after move\n    |\n-   = note: move occurs because `a.y` has type `std::boxed::Box<isize>`, which does not implement the `Copy` trait\n+   = note: move occurs because `a.x.x` has type `std::boxed::Box<isize>`, which does not implement the `Copy` trait\n \n error: aborting due to 2 previous errors\n "}, {"sha": "2a94e05016d4edff759287c8ed80717eb095dfed", "filename": "src/test/ui/borrowck/issue-41962.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f9c7f9e6d069e62027e168da557625d0b518f3e/src%2Ftest%2Fui%2Fborrowck%2Fissue-41962.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f9c7f9e6d069e62027e168da557625d0b518f3e/src%2Ftest%2Fui%2Fborrowck%2Fissue-41962.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fissue-41962.rs?ref=5f9c7f9e6d069e62027e168da557625d0b518f3e", "patch": "@@ -20,7 +20,7 @@ pub fn main(){\n         //~| ERROR use of moved value: `(maybe as std::prelude::v1::Some).0` (Ast) [E0382]\n         //~| ERROR use of moved value: `maybe` (Mir) [E0382]\n         //~| ERROR use of moved value: `maybe` (Mir) [E0382]\n-        //~| ERROR use of moved value: `maybe.0` (Mir) [E0382]\n+        //~| ERROR use of moved value (Mir) [E0382]\n         //~| ERROR borrow of moved value: `maybe` (Mir) [E0382]\n     }\n }"}, {"sha": "bd5d2a46fd8c751ab127cfa7f19e146033231dfe", "filename": "src/test/ui/borrowck/issue-41962.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5f9c7f9e6d069e62027e168da557625d0b518f3e/src%2Ftest%2Fui%2Fborrowck%2Fissue-41962.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5f9c7f9e6d069e62027e168da557625d0b518f3e/src%2Ftest%2Fui%2Fborrowck%2Fissue-41962.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fissue-41962.stderr?ref=5f9c7f9e6d069e62027e168da557625d0b518f3e", "patch": "@@ -26,7 +26,7 @@ LL |           if let Some(thing) = maybe {\n LL | |         }\n    | |_________^ value used here after move\n    |\n-   = note: move occurs because `maybe` has type `std::option::Option<std::vec::Vec<bool>>`, which does not implement the `Copy` trait\n+   = note: move occurs because value has type `std::vec::Vec<bool>`, which does not implement the `Copy` trait\n \n error[E0382]: borrow of moved value: `maybe` (Mir)\n   --> $DIR/issue-41962.rs:17:9\n@@ -38,7 +38,7 @@ LL |           if let Some(thing) = maybe {\n LL | |         }\n    | |_________^ value borrowed here after move\n    |\n-   = note: move occurs because `maybe` has type `std::option::Option<std::vec::Vec<bool>>`, which does not implement the `Copy` trait\n+   = note: move occurs because value has type `std::vec::Vec<bool>`, which does not implement the `Copy` trait\n \n error[E0382]: use of moved value: `maybe` (Mir)\n   --> $DIR/issue-41962.rs:17:16\n@@ -49,15 +49,15 @@ LL |         if let Some(thing) = maybe {\n    |                |    value moved here\n    |                value used here after move\n    |\n-   = note: move occurs because `maybe` has type `std::option::Option<std::vec::Vec<bool>>`, which does not implement the `Copy` trait\n+   = note: move occurs because value has type `std::vec::Vec<bool>`, which does not implement the `Copy` trait\n \n-error[E0382]: use of moved value: `maybe.0` (Mir)\n+error[E0382]: use of moved value (Mir)\n   --> $DIR/issue-41962.rs:17:21\n    |\n LL |         if let Some(thing) = maybe {\n    |                     ^^^^^ value moved here in previous iteration of loop\n    |\n-   = note: move occurs because `maybe.0` has type `std::vec::Vec<bool>`, which does not implement the `Copy` trait\n+   = note: move occurs because value has type `std::vec::Vec<bool>`, which does not implement the `Copy` trait\n \n error: aborting due to 6 previous errors\n "}, {"sha": "d5b18a6c9629848f3227acb2fc4a96c607e22f53", "filename": "src/test/ui/moves-based-on-type-match-bindings.nll.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f9c7f9e6d069e62027e168da557625d0b518f3e/src%2Ftest%2Fui%2Fmoves-based-on-type-match-bindings.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5f9c7f9e6d069e62027e168da557625d0b518f3e/src%2Ftest%2Fui%2Fmoves-based-on-type-match-bindings.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmoves-based-on-type-match-bindings.nll.stderr?ref=5f9c7f9e6d069e62027e168da557625d0b518f3e", "patch": "@@ -7,7 +7,7 @@ LL |         Foo {f} => {}\n LL |     touch(&x); //~ ERROR use of partially moved value: `x`\n    |           ^^ value borrowed here after move\n    |\n-   = note: move occurs because `x` has type `Foo<std::string::String>`, which does not implement the `Copy` trait\n+   = note: move occurs because `x.f` has type `std::string::String`, which does not implement the `Copy` trait\n \n error: aborting due to previous error\n "}, {"sha": "4543d2ba638c46681019e96efba1fa714c152eec", "filename": "src/test/ui/nll/issue-51512.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/5f9c7f9e6d069e62027e168da557625d0b518f3e/src%2Ftest%2Fui%2Fnll%2Fissue-51512.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f9c7f9e6d069e62027e168da557625d0b518f3e/src%2Ftest%2Fui%2Fnll%2Fissue-51512.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-51512.rs?ref=5f9c7f9e6d069e62027e168da557625d0b518f3e", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(warnings)]\n+#![feature(nll)]\n+\n+fn main() {\n+    let range = 0..1;\n+    let r = range;\n+    let x = range.start;\n+    //~^ ERROR use of moved value: `range.start` [E0382]\n+}"}, {"sha": "102de43e5d710077234b67317d70dc504c29de91", "filename": "src/test/ui/nll/issue-51512.stderr", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5f9c7f9e6d069e62027e168da557625d0b518f3e/src%2Ftest%2Fui%2Fnll%2Fissue-51512.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5f9c7f9e6d069e62027e168da557625d0b518f3e/src%2Ftest%2Fui%2Fnll%2Fissue-51512.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-51512.stderr?ref=5f9c7f9e6d069e62027e168da557625d0b518f3e", "patch": "@@ -0,0 +1,13 @@\n+error[E0382]: use of moved value: `range.start`\n+  --> $DIR/issue-51512.rs:17:13\n+   |\n+LL |     let r = range;\n+   |             ----- value moved here\n+LL |     let x = range.start;\n+   |             ^^^^^^^^^^^ value used here after move\n+   |\n+   = note: move occurs because `range` has type `std::ops::Range<i32>`, which does not implement the `Copy` trait\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0382`."}]}