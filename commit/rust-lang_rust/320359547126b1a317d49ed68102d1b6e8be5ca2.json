{"sha": "320359547126b1a317d49ed68102d1b6e8be5ca2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMyMDM1OTU0NzEyNmIxYTMxN2Q0OWVkNjgxMDJkMWI2ZThiZTVjYTI=", "commit": {"author": {"name": "John Clements", "email": "clements@racket-lang.org", "date": "2013-06-04T19:34:25Z"}, "committer": {"name": "John Clements", "email": "clements@racket-lang.org", "date": "2013-06-05T19:01:38Z"}, "message": "interner just uses uints, not idents with syntax context", "tree": {"sha": "0acad4ebe7ddec98ed996a9603098533da2f9bfb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0acad4ebe7ddec98ed996a9603098533da2f9bfb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/320359547126b1a317d49ed68102d1b6e8be5ca2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/320359547126b1a317d49ed68102d1b6e8be5ca2", "html_url": "https://github.com/rust-lang/rust/commit/320359547126b1a317d49ed68102d1b6e8be5ca2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/320359547126b1a317d49ed68102d1b6e8be5ca2/comments", "author": {"login": "jbclements", "id": 226617, "node_id": "MDQ6VXNlcjIyNjYxNw==", "avatar_url": "https://avatars.githubusercontent.com/u/226617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jbclements", "html_url": "https://github.com/jbclements", "followers_url": "https://api.github.com/users/jbclements/followers", "following_url": "https://api.github.com/users/jbclements/following{/other_user}", "gists_url": "https://api.github.com/users/jbclements/gists{/gist_id}", "starred_url": "https://api.github.com/users/jbclements/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jbclements/subscriptions", "organizations_url": "https://api.github.com/users/jbclements/orgs", "repos_url": "https://api.github.com/users/jbclements/repos", "events_url": "https://api.github.com/users/jbclements/events{/privacy}", "received_events_url": "https://api.github.com/users/jbclements/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jbclements", "id": 226617, "node_id": "MDQ6VXNlcjIyNjYxNw==", "avatar_url": "https://avatars.githubusercontent.com/u/226617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jbclements", "html_url": "https://github.com/jbclements", "followers_url": "https://api.github.com/users/jbclements/followers", "following_url": "https://api.github.com/users/jbclements/following{/other_user}", "gists_url": "https://api.github.com/users/jbclements/gists{/gist_id}", "starred_url": "https://api.github.com/users/jbclements/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jbclements/subscriptions", "organizations_url": "https://api.github.com/users/jbclements/orgs", "repos_url": "https://api.github.com/users/jbclements/repos", "events_url": "https://api.github.com/users/jbclements/events{/privacy}", "received_events_url": "https://api.github.com/users/jbclements/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ae02bf70e01f48dc00b82620ff121eedc9e7db7c", "url": "https://api.github.com/repos/rust-lang/rust/commits/ae02bf70e01f48dc00b82620ff121eedc9e7db7c", "html_url": "https://github.com/rust-lang/rust/commit/ae02bf70e01f48dc00b82620ff121eedc9e7db7c"}], "stats": {"total": 426, "additions": 225, "deletions": 201}, "files": [{"sha": "749c065de32f327ff252a562291c67481ac530b3", "filename": "src/librustc/driver/session.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/320359547126b1a317d49ed68102d1b6e8be5ca2/src%2Flibrustc%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/320359547126b1a317d49ed68102d1b6e8be5ca2/src%2Flibrustc%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fsession.rs?ref=320359547126b1a317d49ed68102d1b6e8be5ca2", "patch": "@@ -294,12 +294,17 @@ impl Session_ {\n         self.opts.optimize == No && !self.debugging_opt(no_debug_borrows)\n     }\n \n+    // pointless function, now...\n     pub fn str_of(@self, id: ast::ident) -> @~str {\n-        token::get_ident_interner().get(id)\n+        token::ident_to_str(id)\n     }\n+\n+    // pointless function, now...\n     pub fn ident_of(@self, st: &str) -> ast::ident {\n-        token::get_ident_interner().intern(st)\n+        token::str_to_ident(st)\n     }\n+\n+    // pointless function, now...\n     pub fn intr(@self) -> @syntax::parse::token::ident_interner {\n         token::get_ident_interner()\n     }"}, {"sha": "642df89da6ea556ead02e978f8875021af2364cb", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/320359547126b1a317d49ed68102d1b6e8be5ca2/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/320359547126b1a317d49ed68102d1b6e8be5ca2/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=320359547126b1a317d49ed68102d1b6e8be5ca2", "patch": "@@ -22,6 +22,7 @@ use core::vec;\n use syntax::attr;\n use syntax::codemap::{span, dummy_sp};\n use syntax::diagnostic::span_handler;\n+use syntax::parse::token;\n use syntax::parse::token::ident_interner;\n use syntax::visit;\n use syntax::ast;\n@@ -176,7 +177,7 @@ fn visit_item(e: @mut Env, i: @ast::item) {\n                             }\n                             nn\n                         }\n-                        None => e.intr.get(i.ident)\n+                        None => token::ident_to_str(i.ident)\n                     };\n                 if attr::find_attrs_by_name(i.attrs, \"nolink\").is_empty() {\n                     already_added =\n@@ -235,7 +236,7 @@ fn resolve_crate(e: @mut Env,\n                  hash: @~str,\n                  span: span)\n               -> ast::crate_num {\n-    let metas = metas_with_ident(@/*bad*/copy *e.intr.get(ident), metas);\n+    let metas = metas_with_ident(token::ident_to_str(ident), metas);\n \n     match existing_match(e, metas, hash) {\n       None => {\n@@ -276,7 +277,7 @@ fn resolve_crate(e: @mut Env,\n             match attr::last_meta_item_value_str_by_name(load_ctxt.metas,\n                                                          \"name\") {\n                 Some(v) => v,\n-                None => e.intr.get(ident),\n+                None => token::ident_to_str(ident),\n             };\n         let cmeta = @cstore::crate_metadata {\n             name: cname,\n@@ -305,10 +306,11 @@ fn resolve_crate_deps(e: @mut Env, cdata: @~[u8]) -> cstore::cnum_map {\n     for decoder::get_crate_deps(e.intr, cdata).each |dep| {\n         let extrn_cnum = dep.cnum;\n         let cname = dep.name;\n+        let cname_str = token::ident_to_str(dep.name);\n         let cmetas = metas_with(dep.vers, @~\"vers\", ~[]);\n         debug!(\"resolving dep crate %s ver: %s hash: %s\",\n-               *e.intr.get(dep.name), *dep.vers, *dep.hash);\n-        match existing_match(e, metas_with_ident(e.intr.get(cname),\n+               *cname_str, *dep.vers, *dep.hash);\n+        match existing_match(e, metas_with_ident(cname_str,\n                                                  copy cmetas),\n                              dep.hash) {\n           Some(local_cnum) => {"}, {"sha": "93136aca18a25af9dc36435ee9780de4a7619570", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/320359547126b1a317d49ed68102d1b6e8be5ca2/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/320359547126b1a317d49ed68102d1b6e8be5ca2/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=320359547126b1a317d49ed68102d1b6e8be5ca2", "patch": "@@ -40,6 +40,7 @@ use syntax::parse::token::{StringRef, ident_interner, special_idents};\n use syntax::print::pprust;\n use syntax::{ast, ast_util};\n use syntax::codemap;\n+use syntax::parse::token;\n \n type cmd = @crate_metadata;\n \n@@ -297,10 +298,10 @@ fn item_path(intr: @ident_interner, item_doc: ebml::Doc) -> ast_map::path {\n     for reader::docs(path_doc) |tag, elt_doc| {\n         if tag == tag_path_elt_mod {\n             let str = reader::doc_as_str(elt_doc);\n-            result.push(ast_map::path_mod(intr.intern(str)));\n+            result.push(ast_map::path_mod(token::str_to_ident(str)));\n         } else if tag == tag_path_elt_name {\n             let str = reader::doc_as_str(elt_doc);\n-            result.push(ast_map::path_name(intr.intern(str)));\n+            result.push(ast_map::path_name(token::str_to_ident(str)));\n         } else {\n             // ignore tag_path_len element\n         }\n@@ -314,8 +315,8 @@ fn item_name(intr: @ident_interner, item: ebml::Doc) -> ast::ident {\n     do reader::with_doc_data(name) |data| {\n         let string = str::from_bytes_slice(data);\n         match intr.find_equiv(&StringRef(string)) {\n-            None => intr.intern(string),\n-            Some(val) => val,\n+            None => token::str_to_ident(string),\n+            Some(val) => ast::new_ident(val),\n         }\n     }\n }\n@@ -843,7 +844,7 @@ pub fn get_type_name_if_impl(intr: @ident_interner,\n     }\n \n     for reader::tagged_docs(item, tag_item_impl_type_basename) |doc| {\n-        return Some(intr.intern(str::from_bytes(reader::doc_data(doc))));\n+        return Some(token::str_to_ident(str::from_bytes(reader::doc_data(doc))));\n     }\n \n     return None;\n@@ -1095,7 +1096,7 @@ pub fn get_crate_deps(intr: @ident_interner, data: @~[u8]) -> ~[crate_dep] {\n     }\n     for reader::tagged_docs(depsdoc, tag_crate_dep) |depdoc| {\n         deps.push(crate_dep {cnum: crate_num,\n-                  name: intr.intern(docstr(depdoc, tag_crate_dep_name)),\n+                  name: token::str_to_ident(docstr(depdoc, tag_crate_dep_name)),\n                   vers: @docstr(depdoc, tag_crate_dep_vers),\n                   hash: @docstr(depdoc, tag_crate_dep_hash)});\n         crate_num += 1;\n@@ -1109,7 +1110,7 @@ fn list_crate_deps(intr: @ident_interner, data: @~[u8], out: @io::Writer) {\n     for get_crate_deps(intr, data).each |dep| {\n         out.write_str(\n             fmt!(\"%d %s-%s-%s\\n\",\n-                 dep.cnum, *intr.get(dep.name), *dep.hash, *dep.vers));\n+                 dep.cnum, *token::ident_to_str(dep.name), *dep.hash, *dep.vers));\n     }\n \n     out.write_str(\"\\n\");"}, {"sha": "427ec80740d85d610ab069100a0920531296451c", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/320359547126b1a317d49ed68102d1b6e8be5ca2/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/320359547126b1a317d49ed68102d1b6e8be5ca2/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=320359547126b1a317d49ed68102d1b6e8be5ca2", "patch": "@@ -1055,7 +1055,7 @@ fn encode_info_for_item(ecx: @EncodeContext,\n                         tcx.sess.span_unimpl(\n                             item.span,\n                             fmt!(\"Method %s is both provided and static\",\n-                                 *tcx.sess.intr().get(method_ty.ident)));\n+                                 *token::ident_to_str(method_ty.ident)));\n                     }\n                     encode_type_param_bounds(ebml_w, ecx,\n                                              &m.generics.ty_params);"}, {"sha": "08155d675fef5ea7685dcb2904ed76115a423d17", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/320359547126b1a317d49ed68102d1b6e8be5ca2/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/320359547126b1a317d49ed68102d1b6e8be5ca2/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=320359547126b1a317d49ed68102d1b6e8be5ca2", "patch": "@@ -19,6 +19,7 @@ use metadata::filesearch::FileSearch;\n use metadata::filesearch;\n use syntax::codemap::span;\n use syntax::diagnostic::span_handler;\n+use syntax::parse::token;\n use syntax::parse::token::ident_interner;\n use syntax::print::pprust;\n use syntax::{ast, attr};\n@@ -59,7 +60,7 @@ pub fn load_library_crate(cx: &Context) -> (~str, @~[u8]) {\n       None => {\n         cx.diag.span_fatal(\n             cx.span, fmt!(\"can't find crate for `%s`\",\n-                          *cx.intr.get(cx.ident)));\n+                          *token::ident_to_str(cx.ident)));\n       }\n     }\n }"}, {"sha": "8bde4e37d54d81b1887699e70c8fc726b4759324", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/320359547126b1a317d49ed68102d1b6e8be5ca2/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/320359547126b1a317d49ed68102d1b6e8be5ca2/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=320359547126b1a317d49ed68102d1b6e8be5ca2", "patch": "@@ -1168,7 +1168,7 @@ impl fake_ext_ctxt for fake_session {\n         }\n     }\n     fn ident_of(&self, st: &str) -> ast::ident {\n-        token::get_ident_interner().intern(st)\n+        token::str_to_ident(st)\n     }\n }\n "}, {"sha": "e3fc0bde72a354f4770bd496d89dd1b8b89e9a9d", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/320359547126b1a317d49ed68102d1b6e8be5ca2/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/320359547126b1a317d49ed68102d1b6e8be5ca2/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=320359547126b1a317d49ed68102d1b6e8be5ca2", "patch": "@@ -30,6 +30,7 @@ use syntax::ast;\n use syntax::ast_map;\n use syntax::visit;\n use syntax::codemap::span;\n+use syntax::parse::token;\n \n macro_rules! if_ok(\n     ($inp: expr) => (\n@@ -711,7 +712,7 @@ impl BorrowckCtxt {\n             LpVar(id) => {\n                 match self.tcx.items.find(&id) {\n                     Some(&ast_map::node_local(ident)) => {\n-                        str::push_str(out, *self.tcx.sess.intr().get(ident));\n+                        str::push_str(out, *token::ident_to_str(ident));\n                     }\n                     r => {\n                         self.tcx.sess.bug(\n@@ -726,7 +727,7 @@ impl BorrowckCtxt {\n                 match fname {\n                     mc::NamedField(fname) => {\n                         str::push_char(out, '.');\n-                        str::push_str(out, *self.tcx.sess.intr().get(fname));\n+                        str::push_str(out, *token::ident_to_str(fname));\n                     }\n                     mc::PositionalField(idx) => {\n                         str::push_char(out, '#'); // invent a notation here"}, {"sha": "d2f3f8752751d1cc7521d02fdb27cfd4d5134d4d", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 15, "deletions": 37, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/320359547126b1a317d49ed68102d1b6e8be5ca2/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/320359547126b1a317d49ed68102d1b6e8be5ca2/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=320359547126b1a317d49ed68102d1b6e8be5ca2", "patch": "@@ -235,8 +235,7 @@ pub fn check_crate(tcx: ty::ctxt,\n             if field.ident != ident { loop; }\n             if field.vis == private {\n                 tcx.sess.span_err(span, fmt!(\"field `%s` is private\",\n-                                             *token::get_ident_interner()\n-                                             .get(ident)));\n+                                             *token::ident_to_str(ident)));\n             }\n             break;\n         }\n@@ -245,7 +244,7 @@ pub fn check_crate(tcx: ty::ctxt,\n     // Given the ID of a method, checks to ensure it's in scope.\n     let check_method_common: @fn(span: span,\n                                  method_id: def_id,\n-                                 name: &ident) =\n+                                 name: ident) =\n             |span, method_id, name| {\n         if method_id.crate == local_crate {\n             let is_private = method_is_private(span, method_id.node);\n@@ -256,17 +255,15 @@ pub fn check_crate(tcx: ty::ctxt,\n                      !privileged_items.contains(&(container_id.node))) {\n                 tcx.sess.span_err(span,\n                                   fmt!(\"method `%s` is private\",\n-                                       *token::get_ident_interner()\n-                                           .get(*name)));\n+                                       *token::ident_to_str(name)));\n             }\n         } else {\n             let visibility =\n                 csearch::get_item_visibility(tcx.sess.cstore, method_id);\n             if visibility != public {\n                 tcx.sess.span_err(span,\n                                   fmt!(\"method `%s` is private\",\n-                                       *token::get_ident_interner()\n-                                           .get(*name)));\n+                                       *token::ident_to_str(name)));\n             }\n         }\n     };\n@@ -278,27 +275,21 @@ pub fn check_crate(tcx: ty::ctxt,\n         match def {\n             def_static_method(method_id, _, _) => {\n                 debug!(\"found static method def, checking it\");\n-                check_method_common(span, method_id, path.idents.last())\n+                check_method_common(span, method_id, *path.idents.last())\n             }\n             def_fn(def_id, _) => {\n                 if def_id.crate == local_crate {\n                     if local_item_is_private(span, def_id.node) &&\n                             !privileged_items.contains(&def_id.node) {\n                         tcx.sess.span_err(span,\n                                           fmt!(\"function `%s` is private\",\n-                                               *token::get_ident_interner()\n-                                                   .get(copy *path\n-                                                             .idents\n-                                                             .last())));\n+                                               *token::ident_to_str(*path.idents.last())));\n                     }\n                 } else if csearch::get_item_visibility(tcx.sess.cstore,\n                                                        def_id) != public {\n                     tcx.sess.span_err(span,\n                                       fmt!(\"function `%s` is private\",\n-                                           *token::get_ident_interner()\n-                                               .get(copy *path\n-                                                         .idents\n-                                                         .last())));\n+                                           *token::ident_to_str(*path.idents.last())));\n                 }\n             }\n             _ => {}\n@@ -312,7 +303,7 @@ pub fn check_crate(tcx: ty::ctxt,\n             |span, origin, ident| {\n         match *origin {\n             method_static(method_id) => {\n-                check_method_common(span, method_id, &ident)\n+                check_method_common(span, method_id, ident)\n             }\n             method_param(method_param {\n                 trait_id: trait_id,\n@@ -328,25 +319,17 @@ pub fn check_crate(tcx: ty::ctxt,\n                             match item.node {\n                                 item_trait(_, _, ref methods) => {\n                                     if method_num >= (*methods).len() {\n-                                        tcx.sess.span_bug(span, \"method \\\n-                                                                 number \\\n-                                                                 out of \\\n-                                                                 range?!\");\n+                                        tcx.sess.span_bug(span, \"method number out of range?!\");\n                                     }\n                                     match (*methods)[method_num] {\n                                         provided(method)\n                                              if method.vis == private &&\n                                              !privileged_items\n                                              .contains(&(trait_id.node)) => {\n                                             tcx.sess.span_err(span,\n-                                                              fmt!(\"method\n-                                                                    `%s` \\\n-                                                                    is \\\n-                                                                    private\",\n-                                                                   *token::get_ident_interner()\n-                                                                   .get\n-                                                                   (method\n-                                                                    .ident)));\n+                                                              fmt!(\"method `%s` is private\",\n+                                                                   *token::ident_to_str(method\n+                                                                                        .ident)));\n                                         }\n                                         provided(_) | required(_) => {\n                                             // Required methods can't be\n@@ -355,20 +338,15 @@ pub fn check_crate(tcx: ty::ctxt,\n                                     }\n                                 }\n                                 _ => {\n-                                    tcx.sess.span_bug(span, \"trait wasn't \\\n-                                                             actually a \\\n-                                                             trait?!\");\n+                                    tcx.sess.span_bug(span, \"trait wasn't actually a trait?!\");\n                                 }\n                             }\n                         }\n                         Some(_) => {\n-                            tcx.sess.span_bug(span, \"trait wasn't an \\\n-                                                     item?!\");\n+                            tcx.sess.span_bug(span, \"trait wasn't an item?!\");\n                         }\n                         None => {\n-                            tcx.sess.span_bug(span, \"trait item wasn't \\\n-                                                     found in the AST \\\n-                                                     map?!\");\n+                            tcx.sess.span_bug(span, \"trait item wasn't found in the AST map?!\");\n                         }\n                     }\n                 } else {"}, {"sha": "6b3061864442cd392fbefa0b0fe33ddf3eb7d45e", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/320359547126b1a317d49ed68102d1b6e8be5ca2/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/320359547126b1a317d49ed68102d1b6e8be5ca2/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=320359547126b1a317d49ed68102d1b6e8be5ca2", "patch": "@@ -728,7 +728,7 @@ impl PrimitiveTypeTable {\n                   intr: @ident_interner,\n                   string: &str,\n                   primitive_type: prim_ty) {\n-        let ident = intr.intern(string);\n+        let ident = token::str_to_ident(string);\n         self.primitive_types.insert(ident, primitive_type);\n     }\n }\n@@ -2948,11 +2948,11 @@ impl Resolver {\n         // top of the crate otherwise.\n         let mut containing_module;\n         let mut i;\n-        if *interner.get(module_path[0]) == ~\"self\" {\n+        if *token::ident_to_str(module_path[0]) == ~\"self\" {\n             containing_module =\n                 self.get_nearest_normal_module_parent_or_self(module_);\n             i = 1;\n-        } else if *interner.get(module_path[0]) == ~\"super\" {\n+        } else if *token::ident_to_str(module_path[0]) == ~\"super\" {\n             containing_module =\n                 self.get_nearest_normal_module_parent_or_self(module_);\n             i = 0;  // We'll handle `super` below.\n@@ -2962,7 +2962,7 @@ impl Resolver {\n \n         // Now loop through all the `super`s we find.\n         while i < module_path.len() &&\n-                *interner.get(module_path[i]) == ~\"super\" {\n+                *token::ident_to_str(module_path[i]) == ~\"super\" {\n             debug!(\"(resolving module prefix) resolving `super` at %s\",\n                    self.module_to_str(containing_module));\n             match self.get_nearest_normal_module_parent(containing_module) {"}, {"sha": "846d3cd26108c51b5ca62aae8815a165e6c0ba88", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/320359547126b1a317d49ed68102d1b6e8be5ca2/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/320359547126b1a317d49ed68102d1b6e8be5ca2/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=320359547126b1a317d49ed68102d1b6e8be5ca2", "patch": "@@ -2505,7 +2505,7 @@ pub fn get_item_val(ccx: @CrateContext, id: ast::node_id) -> ValueRef {\n                 }\n                 ast::foreign_item_const(*) => {\n                     let typ = ty::node_id_to_type(tcx, ni.id);\n-                    let ident = token::get_ident_interner().get(ni.ident);\n+                    let ident = token::ident_to_str(ni.ident);\n                     let g = do str::as_c_str(*ident) |buf| {\n                         unsafe {\n                             llvm::LLVMAddGlobal(ccx.llmod,"}, {"sha": "8831cde110541a19af3141a68be929c48e7ad463", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/320359547126b1a317d49ed68102d1b6e8be5ca2/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/320359547126b1a317d49ed68102d1b6e8be5ca2/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=320359547126b1a317d49ed68102d1b6e8be5ca2", "patch": "@@ -52,16 +52,19 @@ use core::vec;\n use syntax::ast::ident;\n use syntax::ast_map::{path, path_elt};\n use syntax::codemap::span;\n+use syntax::parse::token;\n use syntax::parse::token::ident_interner;\n use syntax::{ast, ast_map};\n use syntax::abi::{X86, X86_64, Arm, Mips};\n \n+// NOTE: this thunk is totally pointless now that we're not passing\n+// interners around...\n pub type namegen = @fn(s: &str) -> ident;\n pub fn new_namegen(intr: @ident_interner) -> namegen {\n     let f: @fn(s: &str) -> ident = |prefix| {\n-        intr.gensym(fmt!(\"%s_%u\",\n-                          prefix,\n-                          intr.gensym(prefix).name))\n+        token::str_to_ident(fmt!(\"%s_%u\",\n+                                 prefix,\n+                                 token::gensym(prefix)))\n     };\n     f\n }"}, {"sha": "e494d5f0db9e6f4cfd1309ca6f1862559410a006", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/320359547126b1a317d49ed68102d1b6e8be5ca2/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/320359547126b1a317d49ed68102d1b6e8be5ca2/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=320359547126b1a317d49ed68102d1b6e8be5ca2", "patch": "@@ -344,7 +344,7 @@ pub fn trans_foreign_mod(ccx: @CrateContext,\n                 }\n             }\n             ast::foreign_item_const(*) => {\n-                let ident = token::get_ident_interner().get(foreign_item.ident);\n+                let ident = token::ident_to_str(foreign_item.ident);\n                 ccx.item_symbols.insert(foreign_item.id, copy *ident);\n             }\n         }"}, {"sha": "1764db8ba6d7e31b3a6fc025f5685ec7e8fb7a50", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/320359547126b1a317d49ed68102d1b6e8be5ca2/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/320359547126b1a317d49ed68102d1b6e8be5ca2/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=320359547126b1a317d49ed68102d1b6e8be5ca2", "patch": "@@ -655,7 +655,7 @@ impl Repr for ty::Method {\n \n impl Repr for ast::ident {\n     fn repr(&self, tcx: ctxt) -> ~str {\n-        copy *tcx.sess.intr().get(*self)\n+        copy *token::ident_to_str(*self)\n     }\n }\n "}, {"sha": "54722fae2d7662ab27842d3be62c208a2ab6007e", "filename": "src/librustdoc/extract.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/320359547126b1a317d49ed68102d1b6e8be5ca2/src%2Flibrustdoc%2Fextract.rs", "raw_url": "https://github.com/rust-lang/rust/raw/320359547126b1a317d49ed68102d1b6e8be5ca2/src%2Flibrustdoc%2Fextract.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fextract.rs?ref=320359547126b1a317d49ed68102d1b6e8be5ca2", "patch": "@@ -18,14 +18,14 @@ use doc;\n \n use core::vec;\n use syntax::ast;\n-use syntax::parse::token::{ident_interner};\n+use syntax;\n+use syntax::parse::token::{ident_interner, ident_to_str};\n use syntax::parse::token;\n \n // Hack; rather than thread an interner through everywhere, rely on\n // thread-local data\n pub fn to_str(id: ast::ident) -> ~str {\n-    let intr = token::get_ident_interner();\n-    return copy *(*intr).get(id);\n+    return copy *ident_to_str(id);\n }\n \n pub fn interner() -> @ident_interner {"}, {"sha": "45c801f0994cfcba91d46b797c04337548c68b56", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/320359547126b1a317d49ed68102d1b6e8be5ca2/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/320359547126b1a317d49ed68102d1b6e8be5ca2/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=320359547126b1a317d49ed68102d1b6e8be5ca2", "patch": "@@ -15,7 +15,7 @@ use core::prelude::*;\n use codemap::{span, spanned};\n use abi::AbiSet;\n use opt_vec::OptVec;\n-use parse::token::get_ident_interner;\n+use parse::token::{get_ident_interner, ident_to_str, interner_get, str_to_ident};\n \n use core::hashmap::HashMap;\n use core::option::Option;\n@@ -32,6 +32,9 @@ use extra::serialize::{Encodable, Decodable, Encoder, Decoder};\n #[deriving(Eq)]\n pub struct ident { name: Name, ctxt: SyntaxContext }\n \n+/// Construct an identifier with the given name and an empty context:\n+pub fn new_ident(name: Name) -> ident { ident {name: name, ctxt: empty_ctxt}}\n+\n // a SyntaxContext represents a chain of macro-expandings\n // and renamings. Each macro expansion corresponds to\n // a fresh uint\n@@ -81,13 +84,13 @@ pub type Mrk = uint;\n \n impl<S:Encoder> Encodable<S> for ident {\n     fn encode(&self, s: &mut S) {\n-        s.emit_str(*get_ident_interner().get(*self));\n+        s.emit_str(*interner_get(self.name));\n     }\n }\n \n impl<D:Decoder> Decodable<D> for ident {\n     fn decode(d: &mut D) -> ident {\n-        get_ident_interner().intern(d.read_str())\n+        str_to_ident(d.read_str())\n     }\n }\n "}, {"sha": "ec77ba8853041a1aefb2fa3836241a3b3fccce04", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/320359547126b1a317d49ed68102d1b6e8be5ca2/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/320359547126b1a317d49ed68102d1b6e8be5ca2/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=320359547126b1a317d49ed68102d1b6e8be5ca2", "patch": "@@ -58,8 +58,8 @@ pub fn path_to_str_with_sep(p: &[path_elt], sep: &str, itr: @ident_interner)\n                          -> ~str {\n     let strs = do p.map |e| {\n         match *e {\n-          path_mod(s) => copy *itr.get(s),\n-          path_name(s) => copy *itr.get(s)\n+          path_mod(s) => copy *itr.get(s.name),\n+          path_name(s) => copy *itr.get(s.name)\n         }\n     };\n     str::connect(strs, sep)\n@@ -68,9 +68,9 @@ pub fn path_to_str_with_sep(p: &[path_elt], sep: &str, itr: @ident_interner)\n pub fn path_ident_to_str(p: &path, i: ident, itr: @ident_interner) -> ~str {\n     if vec::is_empty(*p) {\n         //FIXME /* FIXME (#2543) */ copy *i\n-        copy *itr.get(i)\n+        copy *itr.get(i.name)\n     } else {\n-        fmt!(\"%s::%s\", path_to_str(*p, itr), *itr.get(i))\n+        fmt!(\"%s::%s\", path_to_str(*p, itr), *itr.get(i.name))\n     }\n }\n \n@@ -80,8 +80,8 @@ pub fn path_to_str(p: &[path_elt], itr: @ident_interner) -> ~str {\n \n pub fn path_elt_to_str(pe: path_elt, itr: @ident_interner) -> ~str {\n     match pe {\n-        path_mod(s) => copy *itr.get(s),\n-        path_name(s) => copy *itr.get(s)\n+        path_mod(s) => copy *itr.get(s.name),\n+        path_name(s) => copy *itr.get(s.name)\n     }\n }\n \n@@ -356,16 +356,16 @@ pub fn node_id_to_str(map: map, id: node_id, itr: @ident_interner) -> ~str {\n       }\n       Some(&node_method(m, _, path)) => {\n         fmt!(\"method %s in %s (id=%?)\",\n-             *itr.get(m.ident), path_to_str(*path, itr), id)\n+             *itr.get(m.ident.name), path_to_str(*path, itr), id)\n       }\n       Some(&node_trait_method(ref tm, _, path)) => {\n         let m = ast_util::trait_method_to_ty_method(&**tm);\n         fmt!(\"method %s in %s (id=%?)\",\n-             *itr.get(m.ident), path_to_str(*path, itr), id)\n+             *itr.get(m.ident.name), path_to_str(*path, itr), id)\n       }\n       Some(&node_variant(ref variant, _, path)) => {\n         fmt!(\"variant %s in %s (id=%?)\",\n-             *itr.get(variant.node.name), path_to_str(*path, itr), id)\n+             *itr.get(variant.node.name.name), path_to_str(*path, itr), id)\n       }\n       Some(&node_expr(expr)) => {\n         fmt!(\"expr %s (id=%?)\", pprust::expr_to_str(expr, itr), id)\n@@ -381,7 +381,7 @@ pub fn node_id_to_str(map: map, id: node_id, itr: @ident_interner) -> ~str {\n         fmt!(\"arg (id=%?)\", id)\n       }\n       Some(&node_local(ident)) => {\n-        fmt!(\"local (id=%?, name=%s)\", id, *itr.get(ident))\n+        fmt!(\"local (id=%?, name=%s)\", id, *itr.get(ident.name))\n       }\n       Some(&node_block(_)) => {\n         fmt!(\"block\")"}, {"sha": "cf90da4ffae21a38730415de3334bebc1d8dad27", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/320359547126b1a317d49ed68102d1b6e8be5ca2/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/320359547126b1a317d49ed68102d1b6e8be5ca2/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=320359547126b1a317d49ed68102d1b6e8be5ca2", "patch": "@@ -26,7 +26,7 @@ use core::to_bytes;\n \n pub fn path_name_i(idents: &[ident], intr: @token::ident_interner) -> ~str {\n     // FIXME: Bad copies (#2543 -- same for everything else that says \"bad\")\n-    str::connect(idents.map(|i| copy *intr.get(*i)), \"::\")\n+    str::connect(idents.map(|i| copy *token::interner_get(i.name)), \"::\")\n }\n \n "}, {"sha": "97df2c6554e2b2eab64221c6498daac910942350", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/320359547126b1a317d49ed68102d1b6e8be5ca2/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/320359547126b1a317d49ed68102d1b6e8be5ca2/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=320359547126b1a317d49ed68102d1b6e8be5ca2", "patch": "@@ -19,7 +19,7 @@ use diagnostic::span_handler;\n use ext;\n use parse;\n use parse::token;\n-use parse::token::{intern, get_ident_interner};\n+use parse::token::{ident_to_str, intern, get_ident_interner, str_to_ident};\n \n use core::hashmap::HashMap;\n use core::vec;\n@@ -310,10 +310,10 @@ impl ExtCtxt {\n         *self.trace_mac = x\n     }\n     pub fn str_of(&self, id: ast::ident) -> ~str {\n-        copy *get_ident_interner().get(id)\n+        copy *ident_to_str(id)\n     }\n     pub fn ident_of(&self, st: &str) -> ast::ident {\n-        get_ident_interner().intern(st)\n+        str_to_ident(st)\n     }\n }\n "}, {"sha": "d46e0efcd0e69158b9cd98de10273f78f095e99d", "filename": "src/libsyntax/ext/concat_idents.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/320359547126b1a317d49ed68102d1b6e8be5ca2/src%2Flibsyntax%2Fext%2Fconcat_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/320359547126b1a317d49ed68102d1b6e8be5ca2/src%2Flibsyntax%2Fext%2Fconcat_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fconcat_idents.rs?ref=320359547126b1a317d49ed68102d1b6e8be5ca2", "patch": "@@ -15,7 +15,7 @@ use codemap::span;\n use ext::base::*;\n use ext::base;\n use parse::token;\n-use parse::token::{get_ident_interner};\n+use parse::token::{get_ident_interner, str_to_ident};\n \n pub fn expand_syntax_ext(cx: @ExtCtxt, sp: span, tts: &[ast::token_tree])\n     -> base::MacResult {\n@@ -34,7 +34,7 @@ pub fn expand_syntax_ext(cx: @ExtCtxt, sp: span, tts: &[ast::token_tree])\n             }\n         }\n     }\n-    let res = get_ident_interner().intern(res_str);\n+    let res = str_to_ident(res_str);\n \n     let e = @ast::expr {\n         id: cx.next_id(),"}, {"sha": "1e95f62e3e8328705840fba4c25560ec8808f5b1", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/320359547126b1a317d49ed68102d1b6e8be5ca2/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/320359547126b1a317d49ed68102d1b6e8be5ca2/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=320359547126b1a317d49ed68102d1b6e8be5ca2", "patch": "@@ -25,7 +25,7 @@ use ext::base::*;\n use fold::*;\n use parse;\n use parse::{parse_item_from_source_str};\n-use parse::token::{get_ident_interner,intern};\n+use parse::token::{get_ident_interner, ident_to_str, intern};\n \n use core::vec;\n \n@@ -50,7 +50,7 @@ pub fn expand_expr(extsbox: @mut SyntaxEnv,\n                                   separators\"));\n                     }\n                     let extname = pth.idents[0];\n-                    let extnamestr = get_ident_interner().get(extname);\n+                    let extnamestr = ident_to_str(extname);\n                     // leaving explicit deref here to highlight unbox op:\n                     match (*extsbox).find(&extname.name) {\n                         None => {\n@@ -218,7 +218,7 @@ pub fn expand_item_mac(extsbox: @mut SyntaxEnv,\n \n     let extname = pth.idents[0];\n     let interner = get_ident_interner();\n-    let extnamestr = interner.get(extname);\n+    let extnamestr = ident_to_str(extname);\n     let expanded = match (*extsbox).find(&extname.name) {\n         None => cx.span_fatal(pth.span,\n                               fmt!(\"macro undefined: '%s!'\", *extnamestr)),\n@@ -228,7 +228,7 @@ pub fn expand_item_mac(extsbox: @mut SyntaxEnv,\n                 cx.span_fatal(pth.span,\n                               fmt!(\"macro %s! expects no ident argument, \\\n                                     given '%s'\", *extnamestr,\n-                                   *interner.get(it.ident)));\n+                                   *ident_to_str(it.ident)));\n             }\n             cx.bt_push(ExpandedFrom(CallInfo {\n                 call_site: it.span,\n@@ -316,7 +316,7 @@ pub fn expand_stmt(extsbox: @mut SyntaxEnv,\n                   separators\"));\n     }\n     let extname = pth.idents[0];\n-    let extnamestr = get_ident_interner().get(extname);\n+    let extnamestr = ident_to_str(extname);\n     let (fully_expanded, sp) = match (*extsbox).find(&extname.name) {\n         None =>\n             cx.span_fatal(pth.span, fmt!(\"macro undefined: '%s'\", *extnamestr)),\n@@ -735,7 +735,7 @@ mod test {\n     use codemap;\n     use codemap::spanned;\n     use parse;\n-    use parse::token::{get_ident_interner};\n+    use parse::token::{gensym, get_ident_interner};\n     use core::io;\n     use core::option::{None, Some};\n     use util::parser_testing::{string_to_item_and_sess};\n@@ -849,7 +849,7 @@ mod test {\n         };\n         let table = @mut new_sctable();\n         let a_name = 100; // enforced by testing_interner\n-        let a2_name = get_ident_interner().gensym(\"a2\").name;\n+        let a2_name = gensym(\"a2\");\n         let renamer = new_ident_renamer(ast::ident{name:a_name,ctxt:empty_ctxt},\n                                         a2_name,table);\n         let renamed_ast = fun_to_ident_folder(renamer).fold_item(item_ast).get();"}, {"sha": "6648992dc61cfe1461f77d55bb58ea49d9eb5e45", "filename": "src/libsyntax/ext/fmt.rs", "status": "modified", "additions": 14, "deletions": 16, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/320359547126b1a317d49ed68102d1b6e8be5ca2/src%2Flibsyntax%2Fext%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/320359547126b1a317d49ed68102d1b6e8be5ca2/src%2Flibsyntax%2Fext%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ffmt.rs?ref=320359547126b1a317d49ed68102d1b6e8be5ca2", "patch": "@@ -25,7 +25,7 @@ use ext::build::AstBuilder;\n use core::option;\n use core::unstable::extfmt::ct::*;\n use core::vec;\n-use parse::token::{get_ident_interner};\n+use parse::token::{get_ident_interner, str_to_ident};\n \n pub fn expand_syntax_ext(cx: @ExtCtxt, sp: span, tts: &[ast::token_tree])\n     -> base::MacResult {\n@@ -54,12 +54,11 @@ fn pieces_to_expr(cx: @ExtCtxt, sp: span,\n                   pieces: ~[Piece], args: ~[@ast::expr])\n    -> @ast::expr {\n     fn make_path_vec(cx: @ExtCtxt, ident: &str) -> ~[ast::ident] {\n-        let intr = get_ident_interner();\n-        return ~[intr.intern(\"std\"),\n-                 intr.intern(\"unstable\"),\n-                 intr.intern(\"extfmt\"),\n-                 intr.intern(\"rt\"),\n-                 intr.intern(ident)];\n+        return ~[str_to_ident(\"std\"),\n+                 str_to_ident(\"unstable\"),\n+                 str_to_ident(\"extfmt\"),\n+                 str_to_ident(\"rt\"),\n+                 str_to_ident(ident)];\n     }\n     fn make_rt_path_expr(cx: @ExtCtxt, sp: span, nm: &str) -> @ast::expr {\n         let path = make_path_vec(cx, nm);\n@@ -113,15 +112,14 @@ fn pieces_to_expr(cx: @ExtCtxt, sp: span,\n         fn make_conv_struct(cx: @ExtCtxt, sp: span, flags_expr: @ast::expr,\n                          width_expr: @ast::expr, precision_expr: @ast::expr,\n                          ty_expr: @ast::expr) -> @ast::expr {\n-            let intr = get_ident_interner();\n             cx.expr_struct(\n                 sp,\n                 cx.path_global(sp, make_path_vec(cx, \"Conv\")),\n                 ~[\n-                    cx.field_imm(sp, intr.intern(\"flags\"), flags_expr),\n-                    cx.field_imm(sp, intr.intern(\"width\"), width_expr),\n-                    cx.field_imm(sp, intr.intern(\"precision\"), precision_expr),\n-                    cx.field_imm(sp, intr.intern(\"ty\"), ty_expr)\n+                    cx.field_imm(sp, str_to_ident(\"flags\"), flags_expr),\n+                    cx.field_imm(sp, str_to_ident(\"width\"), width_expr),\n+                    cx.field_imm(sp, str_to_ident(\"precision\"), precision_expr),\n+                    cx.field_imm(sp, str_to_ident(\"ty\"), ty_expr)\n                 ]\n             )\n         }\n@@ -256,11 +254,11 @@ fn pieces_to_expr(cx: @ExtCtxt, sp: span,\n     let nargs = args.len();\n \n     /* 'ident' is the local buffer building up the result of fmt! */\n-    let ident = get_ident_interner().intern(\"__fmtbuf\");\n+    let ident = str_to_ident(\"__fmtbuf\");\n     let buf = || cx.expr_ident(fmt_sp, ident);\n-    let core_ident = get_ident_interner().intern(\"std\");\n-    let str_ident = get_ident_interner().intern(\"str\");\n-    let push_ident = get_ident_interner().intern(\"push_str\");\n+    let core_ident = str_to_ident(\"std\");\n+    let str_ident = str_to_ident(\"str\");\n+    let push_ident = str_to_ident(\"push_str\");\n     let mut stms = ~[];\n \n     /* Translate each piece (portion of the fmt expression) by invoking the"}, {"sha": "68641d3f3e7e501a4684dc92a72a0bdc853b94db", "filename": "src/libsyntax/ext/pipes/parse_proto.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/320359547126b1a317d49ed68102d1b6e8be5ca2/src%2Flibsyntax%2Fext%2Fpipes%2Fparse_proto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/320359547126b1a317d49ed68102d1b6e8be5ca2/src%2Flibsyntax%2Fext%2Fpipes%2Fparse_proto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fparse_proto.rs?ref=320359547126b1a317d49ed68102d1b6e8be5ca2", "patch": "@@ -17,7 +17,7 @@ use ext::pipes::proto::*;\n use parse::common::SeqSep;\n use parse::parser;\n use parse::token;\n-use parse::token::{get_ident_interner};\n+use parse::token::{get_ident_interner, interner_get};\n \n pub trait proto_parser {\n     fn parse_proto(&self, id: ~str) -> protocol;\n@@ -43,11 +43,11 @@ impl proto_parser for parser::Parser {\n \n     fn parse_state(&self, proto: protocol) {\n         let id = self.parse_ident();\n-        let name = copy *get_ident_interner().get(id);\n+        let name = copy *interner_get(id.name);\n \n         self.expect(&token::COLON);\n         let dir = match copy *self.token {\n-            token::IDENT(n, _) => get_ident_interner().get(n),\n+            token::IDENT(n, _) => interner_get(n.name),\n             _ => fail!()\n         };\n         self.bump();\n@@ -78,7 +78,7 @@ impl proto_parser for parser::Parser {\n     }\n \n     fn parse_message(&self, state: state) {\n-        let mname = copy *get_ident_interner().get(self.parse_ident());\n+        let mname = copy *interner_get(self.parse_ident().name);\n \n         let args = if *self.token == token::LPAREN {\n             self.parse_unspanned_seq(\n@@ -97,7 +97,7 @@ impl proto_parser for parser::Parser {\n \n         let next = match *self.token {\n           token::IDENT(_, _) => {\n-            let name = copy *get_ident_interner().get(self.parse_ident());\n+            let name = copy *interner_get(self.parse_ident().name);\n             let ntys = if *self.token == token::LT {\n                 self.parse_unspanned_seq(\n                     &token::LT,"}, {"sha": "f8835b51aa50a405d74bdbdf6eadc9a4195b579d", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/320359547126b1a317d49ed68102d1b6e8be5ca2/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/320359547126b1a317d49ed68102d1b6e8be5ca2/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=320359547126b1a317d49ed68102d1b6e8be5ca2", "patch": "@@ -80,7 +80,7 @@ pub mod rt {\n \n     impl ToSource for ast::ident {\n         fn to_source(&self, cx: @ExtCtxt) -> ~str {\n-            copy *get_ident_interner().get(*self)\n+            copy *interner_get(self.name)\n         }\n     }\n \n@@ -418,11 +418,11 @@ pub fn expand_quote_stmt(cx: @ExtCtxt,\n }\n \n fn ids_ext(cx: @ExtCtxt, strs: ~[~str]) -> ~[ast::ident] {\n-    strs.map(|str| get_ident_interner().intern(*str))\n+    strs.map(|str| str_to_ident(*str))\n }\n \n fn id_ext(cx: @ExtCtxt, str: &str) -> ast::ident {\n-    get_ident_interner().intern(str)\n+    str_to_ident(str)\n }\n \n // Lift an ident to the expr that evaluates to that ident."}, {"sha": "86077a5c0b30a7c5b755e479fc3eae8cb5cd020e", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/320359547126b1a317d49ed68102d1b6e8be5ca2/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/320359547126b1a317d49ed68102d1b6e8be5ca2/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=320359547126b1a317d49ed68102d1b6e8be5ca2", "patch": "@@ -19,7 +19,7 @@ use codemap;\n use parse::lexer::*; //resolve bug?\n use parse::ParseSess;\n use parse::parser::Parser;\n-use parse::token::{Token, EOF, to_str, nonterminal, get_ident_interner};\n+use parse::token::{Token, EOF, to_str, nonterminal, get_ident_interner, ident_to_str};\n use parse::token;\n \n use core::hashmap::HashMap;\n@@ -201,13 +201,13 @@ pub fn nameize(p_s: @mut ParseSess, ms: &[matcher], res: &[@named_match])\n             };\n           }\n           codemap::spanned {\n-                node: match_nonterminal(bind_name, _, idx), span: sp\n+                node: match_nonterminal(ref bind_name, _, idx), span: sp\n           } => {\n-            if ret_val.contains_key(&bind_name) {\n+            if ret_val.contains_key(bind_name) {\n                 p_s.span_diagnostic.span_fatal(sp, ~\"Duplicated bind name: \"+\n-                                               *get_ident_interner().get(bind_name))\n+                                               *ident_to_str(*bind_name))\n             }\n-            ret_val.insert(bind_name, res[idx]);\n+            ret_val.insert(*bind_name, res[idx]);\n           }\n         }\n     }\n@@ -372,9 +372,9 @@ pub fn parse(\n                 || bb_eis.len() > 1u {\n                 let nts = str::connect(vec::map(bb_eis, |ei| {\n                     match ei.elts[ei.idx].node {\n-                      match_nonterminal(bind,name,_) => {\n-                        fmt!(\"%s ('%s')\", *get_ident_interner().get(name),\n-                             *get_ident_interner().get(bind))\n+                      match_nonterminal(ref bind,ref name,_) => {\n+                        fmt!(\"%s ('%s')\", *ident_to_str(*name),\n+                             *ident_to_str(*bind))\n                       }\n                       _ => fail!()\n                     } }), \" or \");\n@@ -396,9 +396,9 @@ pub fn parse(\n \n                 let mut ei = bb_eis.pop();\n                 match ei.elts[ei.idx].node {\n-                  match_nonterminal(_, name, idx) => {\n+                  match_nonterminal(_, ref name, idx) => {\n                     ei.matches[idx].push(@matched_nonterminal(\n-                        parse_nt(&rust_parser, *get_ident_interner().get(name))));\n+                        parse_nt(&rust_parser, *ident_to_str(*name))));\n                     ei.idx += 1u;\n                   }\n                   _ => fail!()"}, {"sha": "be2c50d223d9d1159c3f543026e016d00934978d", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/320359547126b1a317d49ed68102d1b6e8be5ca2/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/320359547126b1a317d49ed68102d1b6e8be5ca2/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=320359547126b1a317d49ed68102d1b6e8be5ca2", "patch": "@@ -21,7 +21,7 @@ use ext::tt::macro_parser::{named_match, matched_seq, matched_nonterminal};\n use ext::tt::macro_parser::{parse, parse_or_else, success, failure};\n use parse::lexer::{new_tt_reader, reader};\n use parse::parser::Parser;\n-use parse::token::{get_ident_interner, special_idents};\n+use parse::token::{get_ident_interner, special_idents, gensym_ident, ident_to_str};\n use parse::token::{FAT_ARROW, SEMI, nt_matchers, nt_tt};\n use print;\n \n@@ -38,8 +38,8 @@ pub fn add_new_extension(cx: @ExtCtxt,\n         spanned { node: copy m, span: dummy_sp() }\n     }\n \n-    let lhs_nm =  get_ident_interner().gensym(\"lhs\");\n-    let rhs_nm =  get_ident_interner().gensym(\"rhs\");\n+    let lhs_nm =  gensym_ident(\"lhs\");\n+    let rhs_nm =  gensym_ident(\"rhs\");\n \n     // The grammar for macro_rules! is:\n     // $( $lhs:mtcs => $rhs:tt );+\n@@ -151,7 +151,7 @@ pub fn add_new_extension(cx: @ExtCtxt,\n         |cx, sp, arg| generic_extension(cx, sp, name, arg, *lhses, *rhses);\n \n     return MRDef(MacroDef{\n-        name: copy *get_ident_interner().get(name),\n+        name: copy *ident_to_str(name),\n         ext: NormalTT(base::SyntaxExpanderTT{expander: exp, span: Some(sp)})\n     });\n }"}, {"sha": "8ff66dc62e3f898523e4d9568c011787770eacdc", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/320359547126b1a317d49ed68102d1b6e8be5ca2/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/320359547126b1a317d49ed68102d1b6e8be5ca2/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=320359547126b1a317d49ed68102d1b6e8be5ca2", "patch": "@@ -15,7 +15,8 @@ use ast::{token_tree, tt_delim, tt_tok, tt_seq, tt_nonterminal,ident};\n use codemap::{span, dummy_sp};\n use diagnostic::span_handler;\n use ext::tt::macro_parser::{named_match, matched_seq, matched_nonterminal};\n-use parse::token::{EOF, INTERPOLATED, IDENT, Token, nt_ident, ident_interner, get_ident_interner};\n+use parse::token::{EOF, INTERPOLATED, IDENT, Token, nt_ident, ident_interner};\n+use parse::token::{ident_to_str, get_ident_interner};\n use parse::lexer::TokenAndSpan;\n \n use core::hashmap::HashMap;\n@@ -126,7 +127,7 @@ fn lookup_cur_matched(r: &mut TtReader, name: ident) -> @named_match {\n         Some(s) => lookup_cur_matched_by_matched(r, s),\n         None => {\n             r.sp_diag.span_fatal(r.cur_span, fmt!(\"unknown macro variable `%s`\",\n-                                                  *r.interner.get(name)));\n+                                                  *r.interner.get(name.name)));\n         }\n     }\n }\n@@ -139,13 +140,13 @@ fn lockstep_iter_size(t: &token_tree, r: &mut TtReader) -> lis {\n         match lhs {\n           lis_unconstrained => copy rhs,\n           lis_contradiction(_) => copy lhs,\n-          lis_constraint(l_len, l_id) => match rhs {\n+          lis_constraint(l_len, ref l_id) => match rhs {\n             lis_unconstrained => copy lhs,\n             lis_contradiction(_) => copy rhs,\n             lis_constraint(r_len, _) if l_len == r_len => copy lhs,\n-            lis_constraint(r_len, r_id) => {\n-                let l_n = copy *get_ident_interner().get(l_id);\n-                let r_n = copy *get_ident_interner().get(r_id);\n+            lis_constraint(r_len, ref r_id) => {\n+                let l_n = copy *ident_to_str(*l_id);\n+                let r_n = copy *ident_to_str(*r_id);\n                 lis_contradiction(fmt!(\"Inconsistent lockstep iteration: \\\n                                        '%s' has %u items, but '%s' has %u\",\n                                         l_n, l_len, r_n, r_len))\n@@ -295,7 +296,7 @@ pub fn tt_next_token(r: &mut TtReader) -> TokenAndSpan {\n                 r.sp_diag.span_fatal(\n                     copy r.cur_span, /* blame the macro writer */\n                     fmt!(\"variable '%s' is still repeating at this depth\",\n-                         *get_ident_interner().get(ident)));\n+                         *ident_to_str(ident)));\n               }\n             }\n           }"}, {"sha": "7c6b2774d777be4835e18e1381fae87fca2e7302", "filename": "src/libsyntax/parse/lexer.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/320359547126b1a317d49ed68102d1b6e8be5ca2/src%2Flibsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/320359547126b1a317d49ed68102d1b6e8be5ca2/src%2Flibsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer.rs?ref=320359547126b1a317d49ed68102d1b6e8be5ca2", "patch": "@@ -17,7 +17,7 @@ use diagnostic::span_handler;\n use ext::tt::transcribe::{tt_next_token};\n use ext::tt::transcribe::{dup_tt_reader};\n use parse::token;\n-use parse::token::{get_ident_interner};\n+use parse::token::{get_ident_interner, str_to_ident};\n \n use core::char;\n use core::either;\n@@ -275,7 +275,7 @@ fn consume_any_line_comment(rdr: @mut StringReader)\n                 // but comments with only more \"/\"s are not\n                 if !is_line_non_doc_comment(acc) {\n                     return Some(TokenAndSpan{\n-                        tok: token::DOC_COMMENT(get_ident_interner().intern(acc)),\n+                        tok: token::DOC_COMMENT(str_to_ident(acc)),\n                         sp: codemap::mk_sp(start_bpos, rdr.pos)\n                     });\n                 }\n@@ -329,7 +329,7 @@ fn consume_block_comment(rdr: @mut StringReader)\n             // but comments with only \"*\"s between two \"/\"s are not\n             if !is_block_non_doc_comment(acc) {\n                 return Some(TokenAndSpan{\n-                    tok: token::DOC_COMMENT(get_ident_interner().intern(acc)),\n+                    tok: token::DOC_COMMENT(str_to_ident(acc)),\n                     sp: codemap::mk_sp(start_bpos, rdr.pos)\n                 });\n             }\n@@ -475,12 +475,12 @@ fn scan_number(c: char, rdr: @mut StringReader) -> token::Token {\n         if c == '3' && n == '2' {\n             bump(rdr);\n             bump(rdr);\n-            return token::LIT_FLOAT(get_ident_interner().intern(num_str),\n+            return token::LIT_FLOAT(str_to_ident(num_str),\n                                  ast::ty_f32);\n         } else if c == '6' && n == '4' {\n             bump(rdr);\n             bump(rdr);\n-            return token::LIT_FLOAT(get_ident_interner().intern(num_str),\n+            return token::LIT_FLOAT(str_to_ident(num_str),\n                                  ast::ty_f64);\n             /* FIXME (#2252): if this is out of range for either a\n             32-bit or 64-bit float, it won't be noticed till the\n@@ -492,9 +492,9 @@ fn scan_number(c: char, rdr: @mut StringReader) -> token::Token {\n     }\n     if is_float {\n         if is_machine_float {\n-            return token::LIT_FLOAT(get_ident_interner().intern(num_str), ast::ty_f);\n+            return token::LIT_FLOAT(str_to_ident(num_str), ast::ty_f);\n         }\n-        return token::LIT_FLOAT_UNSUFFIXED(get_ident_interner().intern(num_str));\n+        return token::LIT_FLOAT_UNSUFFIXED(str_to_ident(num_str));\n     } else {\n         if str::len(num_str) == 0u {\n             rdr.fatal(~\"no valid digits found for number\");\n@@ -557,7 +557,7 @@ fn next_token_inner(rdr: @mut StringReader) -> token::Token {\n         let is_mod_name = c == ':' && nextch(rdr) == ':';\n \n         // FIXME: perform NFKC normalization here. (Issue #2253)\n-        return token::IDENT(get_ident_interner().intern(accum_str), is_mod_name);\n+        return token::IDENT(str_to_ident(accum_str), is_mod_name);\n     }\n     if is_dec_digit(c) {\n         return scan_number(c, rdr);\n@@ -667,7 +667,7 @@ fn next_token_inner(rdr: @mut StringReader) -> token::Token {\n                 lifetime_name.push_char(rdr.curr);\n                 bump(rdr);\n             }\n-            return token::LIFETIME(get_ident_interner().intern(lifetime_name));\n+            return token::LIFETIME(str_to_ident(lifetime_name));\n         }\n \n         // Otherwise it is a character constant:\n@@ -740,7 +740,7 @@ fn next_token_inner(rdr: @mut StringReader) -> token::Token {\n             }\n         }\n         bump(rdr);\n-        return token::LIT_STR(get_ident_interner().intern(accum_str));\n+        return token::LIT_STR(str_to_ident(accum_str));\n       }\n       '-' => {\n         if nextch(rdr) == '>' {\n@@ -784,7 +784,7 @@ mod test {\n     use core::option::None;\n     use diagnostic;\n     use parse::token;\n-    use parse::token::{get_ident_interner};\n+    use parse::token::{get_ident_interner, str_to_ident};\n \n     // represents a testing reader (incl. both reader and interner)\n     struct Env {\n@@ -809,7 +809,7 @@ mod test {\n         let Env {interner: ident_interner, string_reader} =\n             setup(~\"/* my source file */ \\\n                     fn main() { io::println(~\\\"zebra\\\"); }\\n\");\n-        let id = ident_interner.intern(\"fn\");\n+        let id = str_to_ident(\"fn\");\n         let tok1 = string_reader.next_token();\n         let tok2 = TokenAndSpan{\n             tok:token::IDENT(id, false),\n@@ -820,7 +820,7 @@ mod test {\n         // read another token:\n         let tok3 = string_reader.next_token();\n         let tok4 = TokenAndSpan{\n-            tok:token::IDENT(ident_interner.intern(\"main\"), false),\n+            tok:token::IDENT(str_to_ident(\"main\"), false),\n             sp:span {lo:BytePos(24),hi:BytePos(28),expn_info: None}};\n         assert_eq!(tok3,tok4);\n         // the lparen is already read:\n@@ -839,7 +839,7 @@ mod test {\n \n     // make the identifier by looking up the string in the interner\n     fn mk_ident (env: Env, id: &str, is_mod_name: bool) -> token::Token {\n-        token::IDENT (get_ident_interner().intern(id),is_mod_name)\n+        token::IDENT (str_to_ident(id),is_mod_name)\n     }\n \n     #[test] fn doublecolonparsing () {\n@@ -898,7 +898,7 @@ mod test {\n         let env = setup(~\"'abc\");\n         let TokenAndSpan {tok, sp: _} =\n             env.string_reader.next_token();\n-        let id = get_ident_interner().intern(\"abc\");\n+        let id = token::str_to_ident(\"abc\");\n         assert_eq!(tok, token::LIFETIME(id));\n     }\n "}, {"sha": "cfc2eaca241e1c3f036bd1c36d3b1800747198a8", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/320359547126b1a317d49ed68102d1b6e8be5ca2/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/320359547126b1a317d49ed68102d1b6e8be5ca2/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=320359547126b1a317d49ed68102d1b6e8be5ca2", "patch": "@@ -348,8 +348,8 @@ mod test {\n     use ast_util::new_ident;\n     use abi;\n     use parse::parser::Parser;\n-    use parse::token::intern;\n-    use util::parser_testing::{string_to_tts_and_sess,string_to_parser};\n+    use parse::token::{intern, str_to_ident};\n+    use util::parser_testing::{string_to_tts_and_sess, string_to_parser};\n     use util::parser_testing::{string_to_expr, string_to_item};\n     use util::parser_testing::{string_to_stmt};\n "}, {"sha": "54845849ebbbae89c2c98fedf5a677b47ed70802", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/320359547126b1a317d49ed68102d1b6e8be5ca2/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/320359547126b1a317d49ed68102d1b6e8be5ca2/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=320359547126b1a317d49ed68102d1b6e8be5ca2", "patch": "@@ -85,7 +85,7 @@ use parse::obsolete::{ObsoleteLifetimeNotation, ObsoleteConstManagedPointer};\n use parse::obsolete::{ObsoletePurity, ObsoleteStaticMethod};\n use parse::obsolete::{ObsoleteConstItem, ObsoleteFixedLengthVectorType};\n use parse::obsolete::{ObsoleteNamedExternModule, ObsoleteMultipleLocalDecl};\n-use parse::token::{can_begin_expr, get_ident_interner, is_ident, is_ident_or_path};\n+use parse::token::{can_begin_expr, get_ident_interner, ident_to_str, is_ident, is_ident_or_path};\n use parse::token::{is_plain_ident, INTERPOLATED, keywords, special_idents, token_to_binop};\n use parse::token;\n use parse::{new_sub_parser_from_file, next_node_id, ParseSess};\n@@ -333,7 +333,7 @@ impl Parser {\n     pub fn get_id(&self) -> node_id { next_node_id(self.sess) }\n \n     pub fn id_to_str(&self, id: ident) -> @~str {\n-        get_ident_interner().get(id)\n+        get_ident_interner().get(id.name)\n     }\n \n     // is this one of the keywords that signals a closure type?\n@@ -3370,7 +3370,7 @@ impl Parser {\n             }\n             if fields.len() == 0 {\n                 self.fatal(fmt!(\"Unit-like struct should be written as `struct %s;`\",\n-                                *get_ident_interner().get(class_name)));\n+                                *get_ident_interner().get(class_name.name)));\n             }\n             self.bump();\n         } else if *self.token == token::LPAREN {\n@@ -3582,7 +3582,7 @@ impl Parser {\n     }\n \n     fn push_mod_path(&self, id: ident, attrs: ~[ast::attribute]) {\n-        let default_path = get_ident_interner().get(id);\n+        let default_path = token::interner_get(id.name);\n         let file_path = match ::attr::first_attr_value_str_by_name(\n             attrs, \"path\") {\n \n@@ -3605,7 +3605,7 @@ impl Parser {\n         let prefix = prefix.dir_path();\n         let mod_path_stack = &*self.mod_path_stack;\n         let mod_path = Path(\".\").push_many(*mod_path_stack);\n-        let default_path = *get_ident_interner().get(id) + \".rs\";\n+        let default_path = *token::interner_get(id.name) + \".rs\";\n         let file_path = match ::attr::first_attr_value_str_by_name(\n             outer_attrs, \"path\") {\n             Some(d) => {\n@@ -3980,7 +3980,7 @@ impl Parser {\n         match *self.token {\n             token::LIT_STR(s) => {\n                 self.bump();\n-                let the_string = self.id_to_str(s);\n+                let the_string = ident_to_str(s);\n                 let mut words = ~[];\n                 for str::each_word(*the_string) |s| { words.push(s) }\n                 let mut abis = AbiSet::empty();\n@@ -4542,7 +4542,7 @@ impl Parser {\n         match *self.token {\n             token::LIT_STR(s) => {\n                 self.bump();\n-                self.id_to_str(s)\n+                ident_to_str(s)\n             }\n             _ =>  self.fatal(\"expected string literal\")\n         }"}, {"sha": "400d52d5a52401fdae8b953174fa1bfea9613001", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 47, "deletions": 25, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/320359547126b1a317d49ed68102d1b6e8be5ca2/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/320359547126b1a317d49ed68102d1b6e8be5ca2/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=320359547126b1a317d49ed68102d1b6e8be5ca2", "patch": "@@ -11,6 +11,7 @@\n use core::prelude::*;\n \n use ast;\n+use ast::Name;\n use ast_util;\n use parse::token;\n use util::interner::StrInterner;\n@@ -176,29 +177,29 @@ pub fn to_str(in: @ident_interner, t: &Token) -> ~str {\n           u.to_str() + ast_util::uint_ty_to_str(t)\n       }\n       LIT_INT_UNSUFFIXED(i) => { i.to_str() }\n-      LIT_FLOAT(s, t) => {\n-        let mut body = copy *in.get(s);\n+      LIT_FLOAT(ref s, t) => {\n+        let mut body = copy *ident_to_str(*s);\n         if body.ends_with(\".\") {\n             body += \"0\";  // `10.f` is not a float literal\n         }\n         body + ast_util::float_ty_to_str(t)\n       }\n-      LIT_FLOAT_UNSUFFIXED(s) => {\n-        let mut body = copy *in.get(s);\n+      LIT_FLOAT_UNSUFFIXED(ref s) => {\n+        let mut body = copy *ident_to_str(*s);\n         if body.ends_with(\".\") {\n             body += \"0\";  // `10.f` is not a float literal\n         }\n         body\n       }\n-      LIT_STR(s) => { ~\"\\\"\" + str::escape_default(*in.get(s)) + \"\\\"\" }\n+      LIT_STR(ref s) => { ~\"\\\"\" + str::escape_default(*ident_to_str(*s)) + \"\\\"\" }\n \n       /* Name components */\n-      IDENT(s, _) => copy *in.get(s),\n-      LIFETIME(s) => fmt!(\"'%s\", *in.get(s)),\n+      IDENT(s, _) => copy *in.get(s.name),\n+      LIFETIME(s) => fmt!(\"'%s\", *in.get(s.name)),\n       UNDERSCORE => ~\"_\",\n \n       /* Other */\n-      DOC_COMMENT(s) => copy *in.get(s),\n+      DOC_COMMENT(ref s) => copy *ident_to_str(*s),\n       EOF => ~\"<eof>\",\n       INTERPOLATED(ref nt) => {\n         match nt {\n@@ -394,27 +395,22 @@ pub struct ident_interner {\n }\n \n impl ident_interner {\n-    // I'm torn as to whether these should produce idents or\n-    // just uints.\n-    pub fn intern(&self, val: &str) -> ast::ident {\n-        ast::ident { name: self.interner.intern(val), ctxt: 0 }\n+    pub fn intern(&self, val: &str) -> Name {\n+        self.interner.intern(val)\n     }\n-    pub fn gensym(&self, val: &str) -> ast::ident {\n-        ast::ident { name: self.interner.gensym(val), ctxt: 0 }\n+    pub fn gensym(&self, val: &str) -> Name {\n+        self.interner.gensym(val)\n     }\n-    pub fn get(&self, idx: ast::ident) -> @~str {\n-        self.interner.get(idx.name)\n+    pub fn get(&self, idx: Name) -> @~str {\n+        self.interner.get(idx)\n     }\n+    // is this really something that should be exposed?\n     pub fn len(&self) -> uint {\n         self.interner.len()\n     }\n-    pub fn find_equiv<Q:Hash +\n-                        IterBytes +\n-                        Equiv<@~str>>(&self, val: &Q) -> Option<ast::ident> {\n-        match self.interner.find_equiv(val) {\n-            Some(v) => Some(ast::ident { name: v, ctxt: 0 }),\n-            None => None,\n-        }\n+    pub fn find_equiv<Q:Hash + IterBytes + Equiv<@~str>>(&self, val: &Q)\n+                                                     -> Option<Name> {\n+        self.interner.find_equiv(val)\n     }\n }\n \n@@ -532,9 +528,35 @@ pub fn mk_fake_ident_interner() -> @ident_interner {\n }\n \n // maps a string to its interned representation\n-pub fn intern(str : &str) -> uint {\n+pub fn intern(str : &str) -> Name {\n+    let interner = get_ident_interner();\n+    interner.intern(str)\n+}\n+\n+// gensyms a new uint, using the current interner\n+pub fn gensym(str : &str) -> Name {\n     let interner = get_ident_interner();\n-    interner.intern(str).name\n+    interner.gensym(str)\n+}\n+\n+// map an interned representation back to a string\n+pub fn interner_get(name : Name) -> @~str {\n+    get_ident_interner().get(name)\n+}\n+\n+// maps an identifier to the string that it corresponds to\n+pub fn ident_to_str(id : ast::ident) -> @~str {\n+    interner_get(id.name)\n+}\n+\n+// maps a string to an identifier with an empty syntax context\n+pub fn str_to_ident(str : &str) -> ast::ident {\n+    ast::new_ident(intern(str))\n+}\n+\n+// maps a string to a gensym'ed identifier\n+pub fn gensym_ident(str : &str) -> ast::ident {\n+    ast::new_ident(gensym(str))\n }\n \n /**"}, {"sha": "0e8612cbffbe501ce618affafc98eb644069d26f", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/320359547126b1a317d49ed68102d1b6e8be5ca2/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/320359547126b1a317d49ed68102d1b6e8be5ca2/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=320359547126b1a317d49ed68102d1b6e8be5ca2", "patch": "@@ -21,7 +21,7 @@ use codemap::{CodeMap, BytePos};\n use codemap;\n use diagnostic;\n use parse::classify::expr_is_simple_block;\n-use parse::token::ident_interner;\n+use parse::token::{ident_interner, ident_to_str};\n use parse::{comments, token};\n use parse;\n use print::pp::{break_offset, word, space, zerobreak, hardbreak};\n@@ -1475,7 +1475,7 @@ pub fn print_decl(s: @ps, decl: @ast::decl) {\n }\n \n pub fn print_ident(s: @ps, ident: ast::ident) {\n-    word(s.s, *s.intr.get(ident));\n+    word(s.s, *ident_to_str(ident));\n }\n \n pub fn print_for_decl(s: @ps, loc: @ast::local, coll: @ast::expr) {\n@@ -2237,6 +2237,7 @@ mod test {\n     use core::cmp::Eq;\n     use core::option::None;\n     use parse;\n+    use parse::token;\n \n     fn string_check<T:Eq> (given : &T, expected: &T) {\n         if !(given == expected) {\n@@ -2246,8 +2247,7 @@ mod test {\n \n     #[test]\n     fn test_fun_to_str() {\n-        let mock_interner = parse::token::mk_fake_ident_interner();\n-        let abba_ident = mock_interner.intern(\"abba\");\n+        let abba_ident = token::str_to_ident(\"abba\");\n \n         let decl = ast::fn_decl {\n             inputs: ~[],\n@@ -2258,14 +2258,13 @@ mod test {\n         };\n         let generics = ast_util::empty_generics();\n         assert_eq!(&fun_to_str(&decl, ast::impure_fn, abba_ident,\n-                               None, &generics, mock_interner),\n+                               None, &generics, token::get_ident_interner()),\n                    &~\"fn abba()\");\n     }\n \n     #[test]\n     fn test_variant_to_str() {\n-        let mock_interner = parse::token::mk_fake_ident_interner();\n-        let ident = mock_interner.intern(\"principal_skinner\");\n+        let ident = token::str_to_ident(\"principal_skinner\");\n \n         let var = codemap::respan(codemap::dummy_sp(), ast::variant_ {\n             name: ident,\n@@ -2277,7 +2276,7 @@ mod test {\n             vis: ast::public,\n         });\n \n-        let varstr = variant_to_str(&var,mock_interner);\n+        let varstr = variant_to_str(&var,token::get_ident_interner());\n         assert_eq!(&varstr,&~\"pub principal_skinner\");\n     }\n }"}, {"sha": "2b74ef7fbea3358e9b463e5d4350fc001e7f2358", "filename": "src/libsyntax/util/parser_testing.rs", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/320359547126b1a317d49ed68102d1b6e8be5ca2/src%2Flibsyntax%2Futil%2Fparser_testing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/320359547126b1a317d49ed68102d1b6e8be5ca2/src%2Flibsyntax%2Futil%2Fparser_testing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fparser_testing.rs?ref=320359547126b1a317d49ed68102d1b6e8be5ca2", "patch": "@@ -10,11 +10,11 @@\n \n use core::option::{Option,None};\n use ast;\n-use parse::parser::Parser;\n use parse::{new_parse_sess};\n-\n-use syntax::parse::{ParseSess,string_to_filemap,filemap_to_tts};\n-use syntax::parse::{new_parser_from_source_str};\n+use parse::{ParseSess,string_to_filemap,filemap_to_tts};\n+use parse::{new_parser_from_source_str};\n+use parse::parser::Parser;\n+use parse::token;\n \n // map a string to tts, using a made-up filename: return both the token_trees\n // and the ParseSess\n@@ -58,3 +58,13 @@ pub fn string_to_stmt (source_str : @~str) -> @ast::stmt {\n     string_to_parser(source_str).parse_stmt(~[])\n }\n \n+// parse a string, return a pat. Uses \"irrefutable\"... which doesn't\n+// (currently) affect parsing.\n+pub fn string_to_pat(source_str : @~str) -> @ast::pat {\n+    string_to_parser(source_str).parse_pat()\n+}\n+\n+// convert a vector of strings to a vector of ast::idents\n+pub fn strs_to_idents(ids: ~[&str]) -> ~[ast::ident] {\n+    ids.map(|u| token::str_to_ident(*u))\n+}"}]}