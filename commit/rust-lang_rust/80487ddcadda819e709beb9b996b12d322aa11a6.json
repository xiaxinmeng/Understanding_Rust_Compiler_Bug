{"sha": "80487ddcadda819e709beb9b996b12d322aa11a6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgwNDg3ZGRjYWRkYTgxOWU3MDliZWI5Yjk5NmIxMmQzMjJhYTExYTY=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-05-06T16:52:53Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-05-08T16:35:59Z"}, "message": "std: Extract format string parsing out of libstd\n\nThis code does not belong in libstd, and rather belongs in a dedicated crate. In\nthe future, the syntax::ext::format module should move to the fmt_macros crate\n(hence the name of the crate), but for now the fmt_macros crate will only\ncontain the format string parser.\n\nThe entire fmt_macros crate is marked #[experimental] because it is not meant\nfor general consumption, only the format!() interface is officially supported,\nnot the internals.\n\nThis is a breaking change for anyone using the internals of std::fmt::parse.\nSome of the flags have moved to std::fmt::rt, while the actual parsing support\nhas all moved to the fmt_macros library.\n\n[breaking-change]", "tree": {"sha": "6fa2208f015edd2e0007b5bba723405b2f5d7172", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6fa2208f015edd2e0007b5bba723405b2f5d7172"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/80487ddcadda819e709beb9b996b12d322aa11a6", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/80487ddcadda819e709beb9b996b12d322aa11a6", "html_url": "https://github.com/rust-lang/rust/commit/80487ddcadda819e709beb9b996b12d322aa11a6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/80487ddcadda819e709beb9b996b12d322aa11a6/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "87115fd001440652291c509a77bda74fa511dab0", "url": "https://api.github.com/repos/rust-lang/rust/commits/87115fd001440652291c509a77bda74fa511dab0", "html_url": "https://github.com/rust-lang/rust/commit/87115fd001440652291c509a77bda74fa511dab0"}], "stats": {"total": 148, "additions": 100, "deletions": 48}, "files": [{"sha": "b75b5ba81e2bd7fb14a0aa850f53d19059c66b1c", "filename": "mk/crates.mk", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/80487ddcadda819e709beb9b996b12d322aa11a6/mk%2Fcrates.mk", "raw_url": "https://github.com/rust-lang/rust/raw/80487ddcadda819e709beb9b996b12d322aa11a6/mk%2Fcrates.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcrates.mk?ref=80487ddcadda819e709beb9b996b12d322aa11a6", "patch": "@@ -52,7 +52,7 @@\n TARGET_CRATES := libc std green rustuv native flate arena glob term semver \\\n                  uuid serialize sync getopts collections num test time rand \\\n \t\t workcache url log regex graphviz core\n-HOST_CRATES := syntax rustc rustdoc fourcc hexfloat regex_macros\n+HOST_CRATES := syntax rustc rustdoc fourcc hexfloat regex_macros fmt_macros\n CRATES := $(TARGET_CRATES) $(HOST_CRATES)\n TOOLS := compiletest rustdoc rustc\n \n@@ -61,7 +61,7 @@ DEPS_std := core libc native:rustrt native:compiler-rt native:backtrace\n DEPS_green := std rand native:context_switch\n DEPS_rustuv := std native:uv native:uv_support\n DEPS_native := std\n-DEPS_syntax := std term serialize collections log\n+DEPS_syntax := std term serialize collections log fmt_macros\n DEPS_rustc := syntax native:rustllvm flate arena serialize sync getopts \\\n               collections time log\n DEPS_rustdoc := rustc native:hoedown serialize sync getopts collections \\\n@@ -88,6 +88,7 @@ DEPS_workcache := std serialize collections log\n DEPS_log := std sync\n DEPS_regex := std collections\n DEPS_regex_macros = syntax std regex\n+DEPS_fmt_macros = std\n \n TOOL_DEPS_compiletest := test green rustuv getopts\n TOOL_DEPS_rustdoc := rustdoc native"}, {"sha": "91b3fefdd02aebebbe14992ea937132a4caf7ce0", "filename": "src/libfmt_macros/lib.rs", "status": "renamed", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/80487ddcadda819e709beb9b996b12d322aa11a6/src%2Flibfmt_macros%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80487ddcadda819e709beb9b996b12d322aa11a6/src%2Flibfmt_macros%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfmt_macros%2Flib.rs?ref=80487ddcadda819e709beb9b996b12d322aa11a6", "patch": "@@ -8,17 +8,21 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! Parsing of format strings\n+//! Macro support for format strings\n //!\n //! These structures are used when parsing format strings for the compiler.\n //! Parsing does not happen at runtime: structures of `std::fmt::rt` are\n //! generated instead.\n \n-use prelude::*;\n+#![crate_id = \"fmt_macros#0.11-pre\"]\n+#![license = \"MIT/ASL2\"]\n+#![crate_type = \"rlib\"]\n+#![crate_type = \"dylib\"]\n+#![feature(macro_rules, globs)]\n+#![experimental]\n \n-use char;\n-use owned::Box;\n-use str;\n+use std::char;\n+use std::str;\n \n /// A piece is a portion of the format string which represents the next part\n /// to emit. These are emitted as a stream by the `Parser` class.\n@@ -164,7 +168,7 @@ pub struct PluralArm<'a> {\n /// is specially placed in the `Plural` variant of `Method`.\n ///\n /// http://www.icu-project.org/apiref/icu4c/classicu_1_1PluralRules.html\n-#[deriving(Eq, TotalEq, Hash)]\n+#[deriving(Eq, TotalEq, Hash, Show)]\n #[allow(missing_doc)]\n pub enum PluralKeyword {\n     /// The plural form for zero objects.\n@@ -683,7 +687,6 @@ impl<'a> Parser<'a> {\n #[cfg(test)]\n mod tests {\n     use super::*;\n-    use prelude::*;\n \n     fn same(fmt: &'static str, p: &[Piece<'static>]) {\n         let mut parser = Parser::new(fmt);", "previous_filename": "src/libstd/fmt/parse.rs"}, {"sha": "8846fa3f6f384389e686e60bfbe46bbb06987531", "filename": "src/libstd/fmt/mod.rs", "status": "modified", "additions": 45, "deletions": 20, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/80487ddcadda819e709beb9b996b12d322aa11a6/src%2Flibstd%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80487ddcadda819e709beb9b996b12d322aa11a6/src%2Flibstd%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffmt%2Fmod.rs?ref=80487ddcadda819e709beb9b996b12d322aa11a6", "patch": "@@ -510,9 +510,34 @@ pub use self::num::Radix;\n pub use self::num::RadixFmt;\n \n mod num;\n-pub mod parse;\n pub mod rt;\n \n+#[cfg(stage0)]\n+#[allow(missing_doc)]\n+pub mod parse {\n+    #[deriving(Eq)]\n+    pub enum Alignment {\n+        AlignLeft,\n+        AlignRight,\n+        AlignUnknown,\n+    }\n+\n+    pub enum PluralKeyword {\n+        Zero,\n+        One,\n+        Two,\n+        Few,\n+        Many,\n+    }\n+\n+    pub enum Flag {\n+        FlagSignPlus,\n+        FlagSignMinus,\n+        FlagAlternate,\n+        FlagSignAwareZeroPad,\n+    }\n+}\n+\n pub type Result = io::IoResult<()>;\n \n /// A struct to represent both where to emit formatting strings to and how they\n@@ -524,7 +549,7 @@ pub struct Formatter<'a> {\n     /// Character used as 'fill' whenever there is alignment\n     pub fill: char,\n     /// Boolean indication of whether the output should be left-aligned\n-    pub align: parse::Alignment,\n+    pub align: rt::Alignment,\n     /// Optionally specified integer width that the output should be\n     pub width: Option<uint>,\n     /// Optionally specified precision for numeric types\n@@ -757,7 +782,7 @@ pub unsafe fn write_unsafe(output: &mut io::Writer,\n         width: None,\n         precision: None,\n         buf: output,\n-        align: parse::AlignUnknown,\n+        align: rt::AlignUnknown,\n         fill: ' ',\n         args: args,\n         curarg: args.iter(),\n@@ -890,15 +915,15 @@ impl<'a> Formatter<'a> {\n                 let value = value - match offset { Some(i) => i, None => 0 };\n                 for s in selectors.iter() {\n                     let run = match s.selector {\n-                        rt::Keyword(parse::Zero) => value == 0,\n-                        rt::Keyword(parse::One) => value == 1,\n-                        rt::Keyword(parse::Two) => value == 2,\n+                        rt::Keyword(rt::Zero) => value == 0,\n+                        rt::Keyword(rt::One) => value == 1,\n+                        rt::Keyword(rt::Two) => value == 2,\n \n                         // FIXME: Few/Many should have a user-specified boundary\n                         //      One possible option would be in the function\n                         //      pointer of the 'arg: Argument' struct.\n-                        rt::Keyword(parse::Few) => value < 8,\n-                        rt::Keyword(parse::Many) => value >= 8,\n+                        rt::Keyword(rt::Few) => value < 8,\n+                        rt::Keyword(rt::Many) => value >= 8,\n \n                         rt::Literal(..) => false\n                     };\n@@ -960,7 +985,7 @@ impl<'a> Formatter<'a> {\n     /// This function will correctly account for the flags provided as well as\n     /// the minimum width. It will not take precision into account.\n     pub fn pad_integral(&mut self, is_positive: bool, prefix: &str, buf: &[u8]) -> Result {\n-        use fmt::parse::{FlagAlternate, FlagSignPlus, FlagSignAwareZeroPad};\n+        use fmt::rt::{FlagAlternate, FlagSignPlus, FlagSignAwareZeroPad};\n \n         let mut width = buf.len();\n \n@@ -1000,11 +1025,11 @@ impl<'a> Formatter<'a> {\n             Some(min) if self.flags & (1 << (FlagSignAwareZeroPad as uint)) != 0 => {\n                 self.fill = '0';\n                 try!(write_prefix(self));\n-                self.with_padding(min - width, parse::AlignRight, |f| f.buf.write(buf))\n+                self.with_padding(min - width, rt::AlignRight, |f| f.buf.write(buf))\n             }\n             // Otherwise, the sign and prefix goes after the padding\n             Some(min) => {\n-                self.with_padding(min - width, parse::AlignRight, |f| {\n+                self.with_padding(min - width, rt::AlignRight, |f| {\n                     try!(write_prefix(f)); f.buf.write(buf)\n                 })\n             }\n@@ -1055,7 +1080,7 @@ impl<'a> Formatter<'a> {\n             // If we're under both the maximum and the minimum width, then fill\n             // up the minimum width with the specified string + some alignment.\n             Some(width) => {\n-                self.with_padding(width - s.len(), parse::AlignLeft, |me| {\n+                self.with_padding(width - s.len(), rt::AlignLeft, |me| {\n                     me.buf.write(s.as_bytes())\n                 })\n             }\n@@ -1066,21 +1091,21 @@ impl<'a> Formatter<'a> {\n     /// afterwards depending on whether right or left alingment is requested.\n     fn with_padding(&mut self,\n                     padding: uint,\n-                    default: parse::Alignment,\n+                    default: rt::Alignment,\n                     f: |&mut Formatter| -> Result) -> Result {\n         let align = match self.align {\n-            parse::AlignUnknown => default,\n-            parse::AlignLeft | parse::AlignRight => self.align\n+            rt::AlignUnknown => default,\n+            rt::AlignLeft | rt::AlignRight => self.align\n         };\n-        if align == parse::AlignLeft {\n+        if align == rt::AlignLeft {\n             try!(f(self));\n         }\n         let mut fill = [0u8, ..4];\n         let len = self.fill.encode_utf8(fill);\n         for _ in range(0, padding) {\n             try!(self.buf.write(fill.slice_to(len)));\n         }\n-        if align == parse::AlignRight {\n+        if align == rt::AlignRight {\n             try!(f(self));\n         }\n         Ok(())\n@@ -1203,7 +1228,7 @@ impl<T> Poly for T {\n \n impl<T> Pointer for *T {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n-        f.flags |= 1 << (parse::FlagAlternate as uint);\n+        f.flags |= 1 << (rt::FlagAlternate as uint);\n         secret_lower_hex::<uint>(&(*self as uint), f)\n     }\n }\n@@ -1304,7 +1329,7 @@ impl<T: Show, U: Show> Show for ::result::Result<T, U> {\n \n impl<'a, T: Show> Show for &'a [T] {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n-        if f.flags & (1 << (parse::FlagAlternate as uint)) == 0 {\n+        if f.flags & (1 << (rt::FlagAlternate as uint)) == 0 {\n             try!(write!(f.buf, \"[\"));\n         }\n         let mut is_first = true;\n@@ -1316,7 +1341,7 @@ impl<'a, T: Show> Show for &'a [T] {\n             }\n             try!(write!(f.buf, \"{}\", *x))\n         }\n-        if f.flags & (1 << (parse::FlagAlternate as uint)) == 0 {\n+        if f.flags & (1 << (rt::FlagAlternate as uint)) == 0 {\n             try!(write!(f.buf, \"]\"));\n         }\n         Ok(())"}, {"sha": "33e86a4485b3fa2f56fab7f6c4c89de71bab62c7", "filename": "src/libstd/fmt/rt.rs", "status": "modified", "additions": 35, "deletions": 3, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/80487ddcadda819e709beb9b996b12d322aa11a6/src%2Flibstd%2Ffmt%2Frt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80487ddcadda819e709beb9b996b12d322aa11a6/src%2Flibstd%2Ffmt%2Frt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffmt%2Frt.rs?ref=80487ddcadda819e709beb9b996b12d322aa11a6", "patch": "@@ -17,9 +17,17 @@\n #![allow(missing_doc)]\n #![doc(hidden)]\n \n-use fmt::parse;\n use option::Option;\n \n+#[cfg(stage0)]\n+pub use fmt::parse::{Alignment, AlignLeft, AlignRight, AlignUnknown};\n+#[cfg(stage0)]\n+pub use fmt::parse::{PluralKeyword, Zero, One, Two, Few, Many};\n+#[cfg(stage0)]\n+pub use fmt::parse::{Flag, FlagSignPlus, FlagSignMinus, FlagSignAwareZeroPad};\n+#[cfg(stage0)]\n+pub use fmt::parse::{FlagAlternate};\n+\n pub enum Piece<'a> {\n     String(&'a str),\n     // FIXME(#8259): this shouldn't require the unit-value here\n@@ -35,12 +43,20 @@ pub struct Argument<'a> {\n \n pub struct FormatSpec {\n     pub fill: char,\n-    pub align: parse::Alignment,\n+    pub align: Alignment,\n     pub flags: uint,\n     pub precision: Count,\n     pub width: Count,\n }\n \n+#[cfg(not(stage0))]\n+#[deriving(Eq)]\n+pub enum Alignment {\n+    AlignLeft,\n+    AlignRight,\n+    AlignUnknown,\n+}\n+\n pub enum Count {\n     CountIs(uint), CountIsParam(uint), CountIsNextParam, CountImplied,\n }\n@@ -49,16 +65,32 @@ pub enum Position {\n     ArgumentNext, ArgumentIs(uint)\n }\n \n+#[cfg(not(stage0))]\n+pub enum Flag {\n+    FlagSignPlus,\n+    FlagSignMinus,\n+    FlagAlternate,\n+    FlagSignAwareZeroPad,\n+}\n+\n pub enum Method<'a> {\n     Plural(Option<uint>, &'a [PluralArm<'a>], &'a [Piece<'a>]),\n     Select(&'a [SelectArm<'a>], &'a [Piece<'a>]),\n }\n \n pub enum PluralSelector {\n-    Keyword(parse::PluralKeyword),\n+    Keyword(PluralKeyword),\n     Literal(uint),\n }\n \n+pub enum PluralKeyword {\n+    Zero,\n+    One,\n+    Two,\n+    Few,\n+    Many,\n+}\n+\n pub struct PluralArm<'a> {\n     pub selector: PluralSelector,\n     pub result: &'a [Piece<'a>],"}, {"sha": "7b465a2dc35cea1931e1665bf44e2027c8121273", "filename": "src/libsyntax/ext/format.rs", "status": "modified", "additions": 6, "deletions": 16, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/80487ddcadda819e709beb9b996b12d322aa11a6/src%2Flibsyntax%2Fext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80487ddcadda819e709beb9b996b12d322aa11a6/src%2Flibsyntax%2Fext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fformat.rs?ref=80487ddcadda819e709beb9b996b12d322aa11a6", "patch": "@@ -18,7 +18,7 @@ use parse::token::InternedString;\n use parse::token;\n use rsparse = parse;\n \n-use std::fmt::parse;\n+use parse = fmt_macros;\n use collections::{HashMap, HashSet};\n \n #[deriving(Eq)]\n@@ -232,7 +232,7 @@ impl<'a, 'b> Context<'a, 'b> {\n                             parse::Keyword(name) => {\n                                 self.ecx.span_err(self.fmtsp,\n                                                   format!(\"duplicate selector \\\n-                                                           `{:?}`\", name));\n+                                                           `{}`\", name));\n                             }\n                             parse::Literal(idx) => {\n                                 self.ecx.span_err(self.fmtsp,\n@@ -375,21 +375,11 @@ impl<'a, 'b> Context<'a, 'b> {\n         return vec!(unnamed, allow_dead_code);\n     }\n \n-    fn parsepath(&self, s: &str) -> Vec<ast::Ident> {\n-        vec!(self.ecx.ident_of(\"std\"), self.ecx.ident_of(\"fmt\"),\n-          self.ecx.ident_of(\"parse\"), self.ecx.ident_of(s))\n-    }\n-\n     fn rtpath(&self, s: &str) -> Vec<ast::Ident> {\n         vec!(self.ecx.ident_of(\"std\"), self.ecx.ident_of(\"fmt\"),\n           self.ecx.ident_of(\"rt\"), self.ecx.ident_of(s))\n     }\n \n-    fn ctpath(&self, s: &str) -> Vec<ast::Ident> {\n-        vec!(self.ecx.ident_of(\"std\"), self.ecx.ident_of(\"fmt\"),\n-          self.ecx.ident_of(\"parse\"), self.ecx.ident_of(s))\n-    }\n-\n     fn none(&self) -> @ast::Expr {\n         let none = self.ecx.path_global(self.fmtsp, vec!(\n                 self.ecx.ident_of(\"std\"),\n@@ -475,7 +465,7 @@ impl<'a, 'b> Context<'a, 'b> {\n                             }).collect();\n                         let (lr, selarg) = match arm.selector {\n                             parse::Keyword(t) => {\n-                                let p = self.ctpath(format!(\"{:?}\", t));\n+                                let p = self.rtpath(t.to_str());\n                                 let p = self.ecx.path_global(sp, p);\n                                 (self.rtpath(\"Keyword\"), self.ecx.expr_path(p))\n                             }\n@@ -564,13 +554,13 @@ impl<'a, 'b> Context<'a, 'b> {\n                 let fill = self.ecx.expr_lit(sp, ast::LitChar(fill));\n                 let align = match arg.format.align {\n                     parse::AlignLeft => {\n-                        self.ecx.path_global(sp, self.parsepath(\"AlignLeft\"))\n+                        self.ecx.path_global(sp, self.rtpath(\"AlignLeft\"))\n                     }\n                     parse::AlignRight => {\n-                        self.ecx.path_global(sp, self.parsepath(\"AlignRight\"))\n+                        self.ecx.path_global(sp, self.rtpath(\"AlignRight\"))\n                     }\n                     parse::AlignUnknown => {\n-                        self.ecx.path_global(sp, self.parsepath(\"AlignUnknown\"))\n+                        self.ecx.path_global(sp, self.rtpath(\"AlignUnknown\"))\n                     }\n                 };\n                 let align = self.ecx.expr_path(align);"}, {"sha": "5e1d988df5c30145a2eaf2f916f6fbe65ca97559", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/80487ddcadda819e709beb9b996b12d322aa11a6/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80487ddcadda819e709beb9b996b12d322aa11a6/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=80487ddcadda819e709beb9b996b12d322aa11a6", "patch": "@@ -35,6 +35,7 @@ extern crate term;\n extern crate collections;\n #[phase(syntax, link)]\n extern crate log;\n+extern crate fmt_macros;\n \n pub mod util {\n     pub mod interner;"}]}