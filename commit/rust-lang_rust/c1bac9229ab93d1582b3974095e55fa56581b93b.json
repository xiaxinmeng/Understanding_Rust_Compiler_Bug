{"sha": "c1bac9229ab93d1582b3974095e55fa56581b93b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMxYmFjOTIyOWFiOTNkMTU4MmIzOTc0MDk1ZTU1ZmE1NjU4MWI5M2I=", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2021-07-14T21:50:53Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2021-09-19T22:50:47Z"}, "message": "Remove lower_node_id_with_owner.", "tree": {"sha": "02a3e37996388403281945c769594525dc83ee5a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/02a3e37996388403281945c769594525dc83ee5a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c1bac9229ab93d1582b3974095e55fa56581b93b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c1bac9229ab93d1582b3974095e55fa56581b93b", "html_url": "https://github.com/rust-lang/rust/commit/c1bac9229ab93d1582b3974095e55fa56581b93b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c1bac9229ab93d1582b3974095e55fa56581b93b/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d7795d302adbb8c1547c952cd0d04a7f9ca29262", "url": "https://api.github.com/repos/rust-lang/rust/commits/d7795d302adbb8c1547c952cd0d04a7f9ca29262", "html_url": "https://github.com/rust-lang/rust/commit/d7795d302adbb8c1547c952cd0d04a7f9ca29262"}], "stats": {"total": 97, "additions": 34, "deletions": 63}, "files": [{"sha": "e93db721fcfcfd59882188a4491e21760098ba31", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 34, "deletions": 63, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/c1bac9229ab93d1582b3974095e55fa56581b93b/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1bac9229ab93d1582b3974095e55fa56581b93b/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=c1bac9229ab93d1582b3974095e55fa56581b93b", "patch": "@@ -80,8 +80,6 @@ mod item;\n mod pat;\n mod path;\n \n-const HIR_ID_COUNTER_LOCKED: u32 = 0xFFFFFFFF;\n-\n rustc_hir::arena_types!(rustc_arena::declare_arena, 'tcx);\n \n struct LoweringContext<'a, 'hir: 'a> {\n@@ -151,7 +149,7 @@ struct LoweringContext<'a, 'hir: 'a> {\n     in_scope_lifetimes: Vec<ParamName>,\n \n     current_hir_id_owner: (LocalDefId, u32),\n-    item_local_id_counters: NodeMap<u32>,\n+    item_local_id_counters: IndexVec<LocalDefId, u32>,\n     node_id_to_hir_id: IndexVec<NodeId, Option<hir::HirId>>,\n \n     allow_try_trait: Option<Lrc<[Symbol]>>,\n@@ -488,52 +486,41 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         id\n     }\n \n-    fn allocate_hir_id_counter(&mut self, owner: NodeId) -> LocalDefId {\n-        // Set up the counter if needed.\n-        self.item_local_id_counters.entry(owner).or_insert(0);\n-        // Always allocate the first `HirId` for the owner itself.\n-        let lowered = self.lower_node_id_with_owner(owner, owner);\n-        debug_assert_eq!(lowered.local_id.as_u32(), 0);\n-        lowered.owner\n-    }\n-\n     fn create_stable_hashing_context(&self) -> LoweringHasher<'_> {\n         LoweringHasher {\n             source_map: CachingSourceMapView::new(self.sess.source_map()),\n             resolver: self.resolver,\n         }\n     }\n \n-    fn lower_node_id_generic(\n-        &mut self,\n-        ast_node_id: NodeId,\n-        alloc_hir_id: impl FnOnce(&mut Self) -> hir::HirId,\n-    ) -> hir::HirId {\n-        assert_ne!(ast_node_id, DUMMY_NODE_ID);\n-\n-        let min_size = ast_node_id.as_usize() + 1;\n-\n-        if min_size > self.node_id_to_hir_id.len() {\n-            self.node_id_to_hir_id.resize(min_size, None);\n-        }\n+    fn allocate_hir_id_counter(&mut self, owner: NodeId) -> LocalDefId {\n+        // Set up the counter if needed.\n+        let def_id = self.resolver.local_def_id(owner);\n \n-        if let Some(existing_hir_id) = self.node_id_to_hir_id[ast_node_id] {\n-            existing_hir_id\n+        // Always allocate the first `HirId` for the owner itself.\n+        self.node_id_to_hir_id.ensure_contains_elem(owner, || None);\n+        if let Some(_lowered) = self.node_id_to_hir_id[owner] {\n+            debug_assert_eq!(_lowered.owner, def_id);\n+            debug_assert_eq!(_lowered.local_id.as_u32(), 0);\n         } else {\n-            // Generate a new `HirId`.\n-            let hir_id = alloc_hir_id(self);\n-            self.node_id_to_hir_id[ast_node_id] = Some(hir_id);\n+            self.item_local_id_counters.ensure_contains_elem(def_id, || 0);\n+            let local_id_counter = &mut self.item_local_id_counters[def_id];\n+            let local_id = *local_id_counter;\n \n-            hir_id\n+            // We want to be sure not to modify the counter in the map while it\n+            // is also on the stack. Otherwise we'll get lost updates when writing\n+            // back from the stack to the map.\n+            debug_assert_eq!(local_id, 0);\n+\n+            *local_id_counter += 1;\n+            self.node_id_to_hir_id[owner] = Some(hir::HirId::make_owner(def_id));\n         }\n+        def_id\n     }\n \n     fn with_hir_id_owner<T>(&mut self, owner: NodeId, f: impl FnOnce(&mut Self) -> T) -> T {\n-        let counter = self\n-            .item_local_id_counters\n-            .insert(owner, HIR_ID_COUNTER_LOCKED)\n-            .unwrap_or_else(|| panic!(\"no `item_local_id_counters` entry for {:?}\", owner));\n         let def_id = self.resolver.local_def_id(owner);\n+        let counter = self.item_local_id_counters[def_id];\n         let old_owner = std::mem::replace(&mut self.current_hir_id_owner, (def_id, counter));\n         let ret = f(self);\n         let (new_def_id, new_counter) =\n@@ -542,8 +529,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         debug_assert!(def_id == new_def_id);\n         debug_assert!(new_counter >= counter);\n \n-        let prev = self.item_local_id_counters.insert(owner, new_counter).unwrap();\n-        debug_assert!(prev == HIR_ID_COUNTER_LOCKED);\n+        self.item_local_id_counters[def_id] = new_counter;\n         ret\n     }\n \n@@ -554,35 +540,20 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     /// `HirIdValidator` later on, which makes sure that all `NodeId`s got mapped\n     /// properly. Calling the method twice with the same `NodeId` is fine though.\n     fn lower_node_id(&mut self, ast_node_id: NodeId) -> hir::HirId {\n-        self.lower_node_id_generic(ast_node_id, |this| {\n-            let &mut (owner, ref mut local_id_counter) = &mut this.current_hir_id_owner;\n-            let local_id = *local_id_counter;\n-            *local_id_counter += 1;\n-            hir::HirId { owner, local_id: hir::ItemLocalId::from_u32(local_id) }\n-        })\n-    }\n+        assert_ne!(ast_node_id, DUMMY_NODE_ID);\n \n-    fn lower_node_id_with_owner(&mut self, ast_node_id: NodeId, owner: NodeId) -> hir::HirId {\n-        self.lower_node_id_generic(ast_node_id, |this| {\n-            let local_id_counter = this\n-                .item_local_id_counters\n-                .get_mut(&owner)\n-                .expect(\"called `lower_node_id_with_owner` before `allocate_hir_id_counter`\");\n+        self.node_id_to_hir_id.ensure_contains_elem(ast_node_id, || None);\n+        if let Some(existing_hir_id) = self.node_id_to_hir_id[ast_node_id] {\n+            existing_hir_id\n+        } else {\n+            // Generate a new `HirId`.\n+            let &mut (owner, ref mut local_id_counter) = &mut self.current_hir_id_owner;\n             let local_id = *local_id_counter;\n-\n-            // We want to be sure not to modify the counter in the map while it\n-            // is also on the stack. Otherwise we'll get lost updates when writing\n-            // back from the stack to the map.\n-            debug_assert!(local_id != HIR_ID_COUNTER_LOCKED);\n-\n             *local_id_counter += 1;\n-            let owner = this.resolver.opt_local_def_id(owner).expect(\n-                \"you forgot to call `create_def` or are lowering node-IDs \\\n-                 that do not belong to the current owner\",\n-            );\n-\n-            hir::HirId { owner, local_id: hir::ItemLocalId::from_u32(local_id) }\n-        })\n+            let hir_id = hir::HirId { owner, local_id: hir::ItemLocalId::from_u32(local_id) };\n+            self.node_id_to_hir_id[ast_node_id] = Some(hir_id);\n+            hir_id\n+        }\n     }\n \n     fn next_id(&mut self) -> hir::HirId {\n@@ -592,7 +563,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n \n     fn lower_res(&mut self, res: Res<NodeId>) -> Res {\n         res.map_id(|id| {\n-            self.lower_node_id_generic(id, |_| {\n+            self.node_id_to_hir_id.get(id).copied().flatten().unwrap_or_else(|| {\n                 panic!(\"expected `NodeId` to be lowered already for res {:#?}\", res);\n             })\n         })"}]}