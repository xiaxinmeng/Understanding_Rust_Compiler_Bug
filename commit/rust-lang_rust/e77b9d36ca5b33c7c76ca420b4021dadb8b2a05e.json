{"sha": "e77b9d36ca5b33c7c76ca420b4021dadb8b2a05e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU3N2I5ZDM2Y2E1YjMzYzdjNzZjYTQyMGI0MDIxZGFkYjhiMmEwNWU=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-12-04T02:23:20Z"}, "committer": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-12-23T12:27:44Z"}, "message": "refactor parse_field", "tree": {"sha": "ffb5575a22984b0be95a5c1cac8f41dfd5c6b7b6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ffb5575a22984b0be95a5c1cac8f41dfd5c6b7b6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e77b9d36ca5b33c7c76ca420b4021dadb8b2a05e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e77b9d36ca5b33c7c76ca420b4021dadb8b2a05e", "html_url": "https://github.com/rust-lang/rust/commit/e77b9d36ca5b33c7c76ca420b4021dadb8b2a05e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e77b9d36ca5b33c7c76ca420b4021dadb8b2a05e/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a916ac22b9f7f1f0f7aba0a41a789b3ecd765018", "url": "https://api.github.com/repos/rust-lang/rust/commits/a916ac22b9f7f1f0f7aba0a41a789b3ecd765018", "html_url": "https://github.com/rust-lang/rust/commit/a916ac22b9f7f1f0f7aba0a41a789b3ecd765018"}], "stats": {"total": 63, "additions": 33, "deletions": 30}, "files": [{"sha": "ce17b8fa54642c924f11ffa819bafecb2fd0af62", "filename": "src/librustc_parse/parser/expr.rs", "status": "modified", "additions": 33, "deletions": 30, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/e77b9d36ca5b33c7c76ca420b4021dadb8b2a05e/src%2Flibrustc_parse%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e77b9d36ca5b33c7c76ca420b4021dadb8b2a05e/src%2Flibrustc_parse%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fexpr.rs?ref=e77b9d36ca5b33c7c76ca420b4021dadb8b2a05e", "patch": "@@ -1866,48 +1866,51 @@ impl<'a> Parser<'a> {\n \n     /// Parses `ident (COLON expr)?`.\n     fn parse_field(&mut self) -> PResult<'a, Field> {\n-        let attrs = self.parse_outer_attributes()?;\n+        let attrs = self.parse_outer_attributes()?.into();\n         let lo = self.token.span;\n \n         // Check if a colon exists one ahead. This means we're parsing a fieldname.\n-        let (fieldname, expr, is_shorthand) =\n-            if self.look_ahead(1, |t| t == &token::Colon || t == &token::Eq) {\n-                let fieldname = self.parse_field_name()?;\n-\n-                // Check for an equals token. This means the source incorrectly attempts to\n-                // initialize a field with an eq rather than a colon.\n-                if self.token == token::Eq {\n-                    self.diagnostic()\n-                        .struct_span_err(self.token.span, \"expected `:`, found `=`\")\n-                        .span_suggestion(\n-                            fieldname.span.shrink_to_hi().to(self.token.span),\n-                            \"replace equals symbol with a colon\",\n-                            \":\".to_string(),\n-                            Applicability::MachineApplicable,\n-                        )\n-                        .emit();\n-                }\n-                self.bump(); // `:`\n-                (fieldname, self.parse_expr()?, false)\n-            } else {\n-                let fieldname = self.parse_ident_common(false)?;\n-\n-                // Mimic `x: x` for the `x` field shorthand.\n-                let path = ast::Path::from_ident(fieldname);\n-                let expr = self.mk_expr(fieldname.span, ExprKind::Path(None, path), AttrVec::new());\n-                (fieldname, expr, true)\n-            };\n+        let is_shorthand = !self.look_ahead(1, |t| t == &token::Colon || t == &token::Eq);\n+        let (ident, expr) = if is_shorthand {\n+            // Mimic `x: x` for the `x` field shorthand.\n+            let ident = self.parse_ident_common(false)?;\n+            let path = ast::Path::from_ident(ident);\n+            (ident, self.mk_expr(ident.span, ExprKind::Path(None, path), AttrVec::new()))\n+        } else {\n+            let ident = self.parse_field_name()?;\n+            self.error_on_eq_field_init(ident);\n+            self.bump(); // `:`\n+            (ident, self.parse_expr()?)\n+        };\n         Ok(ast::Field {\n-            ident: fieldname,\n+            ident,\n             span: lo.to(expr.span),\n             expr,\n             is_shorthand,\n-            attrs: attrs.into(),\n+            attrs,\n             id: DUMMY_NODE_ID,\n             is_placeholder: false,\n         })\n     }\n \n+    /// Check for `=`. This means the source incorrectly attempts to\n+    /// initialize a field with an eq rather than a colon.\n+    fn error_on_eq_field_init(&self, field_name: Ident) {\n+        if self.token != token::Eq {\n+            return;\n+        }\n+\n+        self.diagnostic()\n+            .struct_span_err(self.token.span, \"expected `:`, found `=`\")\n+            .span_suggestion(\n+                field_name.span.shrink_to_hi().to(self.token.span),\n+                \"replace equals symbol with a colon\",\n+                \":\".to_string(),\n+                Applicability::MachineApplicable,\n+            )\n+            .emit();\n+    }\n+\n     fn err_dotdotdot_syntax(&self, span: Span) {\n         self.struct_span_err(span, \"unexpected token: `...`\")\n             .span_suggestion("}]}