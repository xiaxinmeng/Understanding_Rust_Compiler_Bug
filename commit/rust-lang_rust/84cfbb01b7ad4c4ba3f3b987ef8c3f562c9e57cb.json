{"sha": "84cfbb01b7ad4c4ba3f3b987ef8c3f562c9e57cb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg0Y2ZiYjAxYjdhZDRjNGJhM2YzYjk4N2VmOGMzZjU2MmM5ZTU3Y2I=", "commit": {"author": {"name": "Christian Poveda", "email": "cpovedar@fnal.gov", "date": "2019-06-24T21:34:38Z"}, "committer": {"name": "Christian Poveda", "email": "cpovedar@fnal.gov", "date": "2019-06-24T22:18:25Z"}, "message": "Reorganize MemoryExtra and AllocExtra structures", "tree": {"sha": "f9af30d36bbd533be13a1915fa1a7f4cc91bc255", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f9af30d36bbd533be13a1915fa1a7f4cc91bc255"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/84cfbb01b7ad4c4ba3f3b987ef8c3f562c9e57cb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/84cfbb01b7ad4c4ba3f3b987ef8c3f562c9e57cb", "html_url": "https://github.com/rust-lang/rust/commit/84cfbb01b7ad4c4ba3f3b987ef8c3f562c9e57cb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/84cfbb01b7ad4c4ba3f3b987ef8c3f562c9e57cb/comments", "author": {"login": "pvdrz", "id": 31802960, "node_id": "MDQ6VXNlcjMxODAyOTYw", "avatar_url": "https://avatars.githubusercontent.com/u/31802960?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pvdrz", "html_url": "https://github.com/pvdrz", "followers_url": "https://api.github.com/users/pvdrz/followers", "following_url": "https://api.github.com/users/pvdrz/following{/other_user}", "gists_url": "https://api.github.com/users/pvdrz/gists{/gist_id}", "starred_url": "https://api.github.com/users/pvdrz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pvdrz/subscriptions", "organizations_url": "https://api.github.com/users/pvdrz/orgs", "repos_url": "https://api.github.com/users/pvdrz/repos", "events_url": "https://api.github.com/users/pvdrz/events{/privacy}", "received_events_url": "https://api.github.com/users/pvdrz/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pvdrz", "id": 31802960, "node_id": "MDQ6VXNlcjMxODAyOTYw", "avatar_url": "https://avatars.githubusercontent.com/u/31802960?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pvdrz", "html_url": "https://github.com/pvdrz", "followers_url": "https://api.github.com/users/pvdrz/followers", "following_url": "https://api.github.com/users/pvdrz/following{/other_user}", "gists_url": "https://api.github.com/users/pvdrz/gists{/gist_id}", "starred_url": "https://api.github.com/users/pvdrz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pvdrz/subscriptions", "organizations_url": "https://api.github.com/users/pvdrz/orgs", "repos_url": "https://api.github.com/users/pvdrz/repos", "events_url": "https://api.github.com/users/pvdrz/events{/privacy}", "received_events_url": "https://api.github.com/users/pvdrz/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2861ceb2fa1acc2c642abd4f2efb96c713a47e29", "url": "https://api.github.com/repos/rust-lang/rust/commits/2861ceb2fa1acc2c642abd4f2efb96c713a47e29", "html_url": "https://github.com/rust-lang/rust/commit/2861ceb2fa1acc2c642abd4f2efb96c713a47e29"}], "stats": {"total": 262, "additions": 161, "deletions": 101}, "files": [{"sha": "c48e7b7772b1de1bafeaa42f784864ce588f911f", "filename": "src/intptrcast.rs", "status": "modified", "additions": 79, "deletions": 4, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/84cfbb01b7ad4c4ba3f3b987ef8c3f562c9e57cb/src%2Fintptrcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84cfbb01b7ad4c4ba3f3b987ef8c3f562c9e57cb/src%2Fintptrcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintptrcast.rs?ref=84cfbb01b7ad4c4ba3f3b987ef8c3f562c9e57cb", "patch": "@@ -1,13 +1,26 @@\n-use std::cell::RefCell;\n+use std::cell::{Cell, RefCell};\n \n-use rustc::mir::interpret::AllocId;\n+use rustc::mir::interpret::{AllocId, Pointer, InterpResult};\n+use rustc_mir::interpret::Memory;\n+use rustc_target::abi::Size;\n \n-pub type MemoryState = RefCell<GlobalState>;\n+use crate::stacked_borrows::Tag;\n+use crate::Evaluator;\n+\n+pub type MemoryExtra = RefCell<GlobalState>;\n+\n+#[derive(Clone, Debug, Default)]\n+pub struct AllocExtra {\n+    base_addr: Cell<Option<u64>>\n+}\n \n #[derive(Clone, Debug)]\n pub struct GlobalState {\n-    /// This field is used as a map between the address of each allocation and its `AllocId`\n+    /// This is used as a map between the address of each allocation and its `AllocId`.\n+    /// It is always sorted\n     pub int_to_ptr_map: Vec<(u64, AllocId)>,\n+    /// This is used as a memory address when a new pointer is casted to an integer. It\n+    /// is always larger than any address that was previously made part of a block.\n     pub next_base_addr: u64,\n }\n \n@@ -20,3 +33,65 @@ impl Default for GlobalState {\n         }\n     }\n }\n+\n+impl<'mir, 'tcx> GlobalState {\n+    pub fn int_to_ptr(\n+        base_addr: u64,\n+        memory: &Memory<'mir, 'tcx, Evaluator<'tcx>>,\n+    ) -> InterpResult<'tcx, Pointer<Tag>> {\n+        let global_state = memory.extra.intptrcast.borrow();\n+        \n+        match global_state.int_to_ptr_map.binary_search_by_key(&base_addr, |(addr, _)| *addr) {\n+            Ok(pos) => {\n+                let (_, alloc_id) = global_state.int_to_ptr_map[pos];\n+                // `base_addr` is the starting address for an allocation, the offset should be\n+                // zero. The pointer is untagged because it was created from a cast\n+                Ok(Pointer::new_with_tag(alloc_id, Size::from_bytes(0), Tag::Untagged))\n+            },\n+            Err(0) => err!(DanglingPointerDeref), \n+            Err(pos) => {\n+                // This is the gargest of the adresses smaller than `base_addr`,\n+                // i.e. the greatest lower bound (glb)\n+                let (glb, alloc_id) = global_state.int_to_ptr_map[pos - 1];\n+                // This never overflows because `base_addr >= glb`\n+                let offset = base_addr - glb;\n+                // If the offset exceeds the size of the allocation, this access is illegal\n+                if offset <= memory.get(alloc_id)?.bytes.len() as u64 {\n+                    // This pointer is untagged because it was created from a cast\n+                    Ok(Pointer::new_with_tag(alloc_id, Size::from_bytes(offset), Tag::Untagged))\n+                } else {\n+                    err!(DanglingPointerDeref)\n+                } \n+            }\n+        }\n+    }\n+\n+    pub fn ptr_to_int(\n+        ptr: Pointer<Tag>,\n+        memory: &Memory<'mir, 'tcx, Evaluator<'tcx>>,\n+    ) -> InterpResult<'tcx, u64> {\n+        let mut global_state = memory.extra.intptrcast.borrow_mut();\n+\n+        let alloc = memory.get(ptr.alloc_id)?;\n+\n+        let base_addr = match alloc.extra.intptrcast.base_addr.get() { \n+            Some(base_addr) => base_addr,\n+            None => {\n+                let base_addr = global_state.next_base_addr;\n+                global_state.next_base_addr += alloc.bytes.len() as u64;\n+\n+                alloc.extra.intptrcast.base_addr.set(Some(base_addr));\n+\n+                let elem = (base_addr, ptr.alloc_id);\n+\n+                // Given that `next_base_addr` increases in each allocation, pushing the\n+                // corresponding tuple keeps `int_to_ptr_map` sorted\n+                global_state.int_to_ptr_map.push(elem); \n+\n+                base_addr\n+            }\n+        };\n+\n+        Ok(base_addr + ptr.offset.bytes())\n+    }\n+}"}, {"sha": "77acd3045da573c147d5601ee3c1f18932e6441d", "filename": "src/lib.rs", "status": "modified", "additions": 17, "deletions": 62, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/84cfbb01b7ad4c4ba3f3b987ef8c3f562c9e57cb/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84cfbb01b7ad4c4ba3f3b987ef8c3f562c9e57cb/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=84cfbb01b7ad4c4ba3f3b987ef8c3f562c9e57cb", "patch": "@@ -25,7 +25,6 @@ mod memory;\n \n use std::collections::HashMap;\n use std::borrow::Cow;\n-use std::cell::Cell;\n use std::rc::Rc;\n \n use rand::rngs::StdRng;\n@@ -387,7 +386,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'tcx> {\n     type MemoryKinds = MiriMemoryKind;\n \n     type FrameExtra = stacked_borrows::CallId;\n-    type MemoryExtra = memory::MemoryState;\n+    type MemoryExtra = memory::MemoryExtra;\n     type AllocExtra = memory::AllocExtra;\n     type PointerTag = Tag;\n \n@@ -513,17 +512,17 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'tcx> {\n     ) -> (Cow<'b, Allocation<Self::PointerTag, Self::AllocExtra>>, Self::PointerTag) {\n         let kind = kind.expect(\"we set our STATIC_KIND so this cannot be None\");\n         let alloc = alloc.into_owned();\n-        let (extra, base_tag) = Stacks::new_allocation(\n+        let (stacks, base_tag) = Stacks::new_allocation(\n             id,\n             Size::from_bytes(alloc.bytes.len() as u64),\n-            Rc::clone(&memory.extra.stacked),\n+            Rc::clone(&memory.extra.stacked_borrows),\n             kind,\n         );\n         if kind != MiriMemoryKind::Static.into() {\n             assert!(alloc.relocations.is_empty(), \"Only statics can come initialized with inner pointers\");\n             // Now we can rely on the inner pointers being static, too.\n         }\n-        let mut memory_extra = memory.extra.stacked.borrow_mut();\n+        let mut memory_extra = memory.extra.stacked_borrows.borrow_mut();\n         let alloc: Allocation<Tag, Self::AllocExtra> = Allocation {\n             bytes: alloc.bytes,\n             relocations: Relocations::from_presorted(\n@@ -537,8 +536,8 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'tcx> {\n             align: alloc.align,\n             mutability: alloc.mutability,\n             extra: AllocExtra {\n-                stacks: extra,\n-                base_addr: Cell::new(None),\n+                stacked_borrows: stacks,\n+                intptrcast: Default::default(),\n             },\n         };\n         (Cow::Owned(alloc), base_tag)\n@@ -549,7 +548,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'tcx> {\n         id: AllocId,\n         memory: &Memory<'mir, 'tcx, Self>,\n     ) -> Self::PointerTag {\n-        memory.extra.stacked.borrow_mut().static_base_ptr(id)\n+        memory.extra.stacked_borrows.borrow_mut().static_base_ptr(id)\n     }\n \n     #[inline(always)]\n@@ -574,49 +573,27 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'tcx> {\n     fn stack_push(\n         ecx: &mut InterpretCx<'mir, 'tcx, Self>,\n     ) -> InterpResult<'tcx, stacked_borrows::CallId> {\n-        Ok(ecx.memory().extra.stacked.borrow_mut().new_call())\n+        Ok(ecx.memory().extra.stacked_borrows.borrow_mut().new_call())\n     }\n \n     #[inline(always)]\n     fn stack_pop(\n         ecx: &mut InterpretCx<'mir, 'tcx, Self>,\n         extra: stacked_borrows::CallId,\n     ) -> InterpResult<'tcx> {\n-        Ok(ecx.memory().extra.stacked.borrow_mut().end_call(extra))\n+        Ok(ecx.memory().extra.stacked_borrows.borrow_mut().end_call(extra))\n     }\n \n     fn int_to_ptr(\n         int: u64,\n         memory: &Memory<'mir, 'tcx, Self>,\n     ) -> InterpResult<'tcx, Pointer<Self::PointerTag>> {\n         if int == 0 {\n-            return err!(InvalidNullPointerUsage);\n-        }\n-        \n-        if memory.extra.rng.is_none() {\n-            return err!(ReadBytesAsPointer);\n-        }\n-\n-        let extra = memory.extra.intptrcast.borrow();\n-        \n-        match extra.int_to_ptr_map.binary_search_by_key(&int, |(int, _)| *int) {\n-            Ok(pos) => {\n-                let (_, alloc_id) = extra.int_to_ptr_map[pos];\n-                Ok(Pointer::new_with_tag(alloc_id, Size::from_bytes(0), Tag::Untagged))\n-            }\n-            Err(pos) => {\n-                if pos > 0 {\n-                    let (glb, alloc_id) = extra.int_to_ptr_map[pos - 1];\n-                    let offset = int - glb;\n-                    if offset <= memory.get(alloc_id)?.bytes.len() as u64 {\n-                        Ok(Pointer::new_with_tag(alloc_id, Size::from_bytes(offset), Tag::Untagged))\n-                    } else {\n-                        return err!(DanglingPointerDeref);\n-                    }\n-                } else {\n-                    return err!(DanglingPointerDeref);\n-                }\n-            }\n+            err!(InvalidNullPointerUsage)\n+        } else if memory.extra.rng.is_none() {\n+            err!(ReadBytesAsPointer)\n+        } else {\n+           intptrcast::GlobalState::int_to_ptr(int, memory)\n         }\n     }\n  \n@@ -625,31 +602,9 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'tcx> {\n         memory: &Memory<'mir, 'tcx, Self>,\n     ) -> InterpResult<'tcx, u64> {\n         if memory.extra.rng.is_none() {\n-            return err!(ReadPointerAsBytes);\n+            err!(ReadPointerAsBytes)\n+        } else {\n+            intptrcast::GlobalState::ptr_to_int(ptr, memory)\n         }\n-\n-        let mut extra = memory.extra.intptrcast.borrow_mut();\n-\n-        let alloc = memory.get(ptr.alloc_id)?;\n-\n-        let base_addr = match alloc.extra.base_addr.get() { \n-            Some(base_addr) => base_addr,\n-            None => {\n-                let base_addr = extra.next_base_addr;\n-                extra.next_base_addr += alloc.bytes.len() as u64;\n-\n-                alloc.extra.base_addr.set(Some(base_addr));\n-\n-                let elem = (base_addr, ptr.alloc_id);\n-\n-                // Given that `next_base_addr` increases in each allocation, pushing the\n-                // corresponding tuple keeps `int_to_ptr_map` sorted\n-                extra.int_to_ptr_map.push(elem); \n-\n-                base_addr\n-            }\n-        };\n-\n-        Ok(base_addr + ptr.offset.bytes())\n     }\n }"}, {"sha": "ea8f01a808c0434e5697acda9c5bdbdc38976f96", "filename": "src/memory.rs", "status": "modified", "additions": 12, "deletions": 24, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/84cfbb01b7ad4c4ba3f3b987ef8c3f562c9e57cb/src%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84cfbb01b7ad4c4ba3f3b987ef8c3f562c9e57cb/src%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmemory.rs?ref=84cfbb01b7ad4c4ba3f3b987ef8c3f562c9e57cb", "patch": "@@ -1,25 +1,24 @@\n-use std::cell::Cell;\n use rand::rngs::StdRng;\n \n use rustc_mir::interpret::{Pointer, Allocation, AllocationExtra, InterpResult};\n use rustc_target::abi::Size;\n \n use crate::{stacked_borrows, intptrcast};\n-use crate::stacked_borrows::{Tag, AccessKind};\n+use crate::stacked_borrows::Tag;\n \n #[derive(Default, Clone, Debug)]\n-pub struct MemoryState {\n-    pub stacked: stacked_borrows::MemoryState,\n-    pub intptrcast: intptrcast::MemoryState,\n-    /// The random number generator to use if Miri\n-    /// is running in non-deterministic mode\n+pub struct MemoryExtra {\n+    pub stacked_borrows: stacked_borrows::MemoryExtra,\n+    pub intptrcast: intptrcast::MemoryExtra,\n+    /// The random number generator to use if Miri is running in non-deterministic mode and to\n+    /// enable intptrcast\n     pub(crate) rng: Option<StdRng>\n }\n \n-#[derive(Debug, Clone,)]\n+#[derive(Debug, Clone)]\n pub struct AllocExtra {\n-    pub stacks: stacked_borrows::Stacks,\n-    pub base_addr: Cell<Option<u64>>,\n+    pub stacked_borrows: stacked_borrows::AllocExtra,\n+    pub intptrcast: intptrcast::AllocExtra,\n }\n \n impl AllocationExtra<Tag> for AllocExtra {\n@@ -29,11 +28,7 @@ impl AllocationExtra<Tag> for AllocExtra {\n         ptr: Pointer<Tag>,\n         size: Size,\n     ) -> InterpResult<'tcx> {\n-        trace!(\"read access with tag {:?}: {:?}, size {}\", ptr.tag, ptr.erase_tag(), size.bytes());\n-        alloc.extra.stacks.for_each(ptr, size, |stack, global| {\n-            stack.access(AccessKind::Read, ptr.tag, global)?;\n-            Ok(())\n-        })\n+        alloc.extra.stacked_borrows.memory_read(ptr, size)\n     }\n \n     #[inline(always)]\n@@ -42,11 +37,7 @@ impl AllocationExtra<Tag> for AllocExtra {\n         ptr: Pointer<Tag>,\n         size: Size,\n     ) -> InterpResult<'tcx> {\n-        trace!(\"write access with tag {:?}: {:?}, size {}\", ptr.tag, ptr.erase_tag(), size.bytes());\n-        alloc.extra.stacks.for_each(ptr, size, |stack, global| {\n-            stack.access(AccessKind::Write, ptr.tag, global)?;\n-            Ok(())\n-        })\n+        alloc.extra.stacked_borrows.memory_written(ptr, size)\n     }\n \n     #[inline(always)]\n@@ -55,9 +46,6 @@ impl AllocationExtra<Tag> for AllocExtra {\n         ptr: Pointer<Tag>,\n         size: Size,\n     ) -> InterpResult<'tcx> {\n-        trace!(\"deallocation with tag {:?}: {:?}, size {}\", ptr.tag, ptr.erase_tag(), size.bytes());\n-        alloc.extra.stacks.for_each(ptr, size, |stack, global| {\n-            stack.dealloc(ptr.tag, global)\n-        })\n+        alloc.extra.stacked_borrows.memory_deallocated(ptr, size)\n     }\n }"}, {"sha": "8f2b75d6043ad835adfedf08245d11d53d483ff8", "filename": "src/operator.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/84cfbb01b7ad4c4ba3f3b987ef8c3f562c9e57cb/src%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84cfbb01b7ad4c4ba3f3b987ef8c3f562c9e57cb/src%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Foperator.rs?ref=84cfbb01b7ad4c4ba3f3b987ef8c3f562c9e57cb", "patch": "@@ -44,6 +44,9 @@ impl<'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'mir, 'tcx> {\n \n         trace!(\"ptr_op: {:?} {:?} {:?}\", *left, bin_op, *right);\n \n+        // If intptrcast is enabled and the operation is not an offset\n+        // we can force the cast from pointers to integer addresses and\n+        // then dispatch to rustc binary operation method\n         if self.memory().extra.rng.is_some() && bin_op != Offset {\n             let l_bits = self.force_bits(left.imm.to_scalar()?, left.layout.size)?;\n             let r_bits = self.force_bits(right.imm.to_scalar()?, right.layout.size)?;"}, {"sha": "c47ad95c04b3b91c7070648b9038828f7d5a0c81", "filename": "src/stacked_borrows.rs", "status": "modified", "additions": 50, "deletions": 11, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/84cfbb01b7ad4c4ba3f3b987ef8c3f562c9e57cb/src%2Fstacked_borrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84cfbb01b7ad4c4ba3f3b987ef8c3f562c9e57cb/src%2Fstacked_borrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstacked_borrows.rs?ref=84cfbb01b7ad4c4ba3f3b987ef8c3f562c9e57cb", "patch": "@@ -16,6 +16,7 @@ use crate::{\n \n pub type PtrId = NonZeroU64;\n pub type CallId = NonZeroU64;\n+pub type AllocExtra = Stacks;\n \n /// Tracking pointer provenance\n #[derive(Copy, Clone, Hash, PartialEq, Eq)]\n@@ -86,7 +87,7 @@ pub struct Stacks {\n     // Even reading memory can have effects on the stack, so we need a `RefCell` here.\n     stacks: RefCell<RangeMap<Stack>>,\n     // Pointer to global state\n-    global: MemoryState,\n+    global: MemoryExtra,\n }\n \n /// Extra global state, available to the memory access hooks.\n@@ -104,7 +105,7 @@ pub struct GlobalState {\n     active_calls: HashSet<CallId>,\n }\n /// Memory extra state gives us interior mutable access to the global state.\n-pub type MemoryState = Rc<RefCell<GlobalState>>;\n+pub type MemoryExtra = Rc<RefCell<GlobalState>>;\n \n /// Indicates which kind of access is being performed.\n #[derive(Copy, Clone, Hash, PartialEq, Eq)]\n@@ -286,7 +287,7 @@ impl<'tcx> Stack {\n \n     /// Test if a memory `access` using pointer tagged `tag` is granted.\n     /// If yes, return the index of the item that granted it.\n-    pub(crate) fn access(\n+    fn access(\n         &mut self,\n         access: AccessKind,\n         tag: Tag,\n@@ -336,7 +337,7 @@ impl<'tcx> Stack {\n \n     /// Deallocate a location: Like a write access, but also there must be no\n     /// active protectors at all because we will remove all items.\n-    pub(crate) fn dealloc(\n+    fn dealloc(\n         &mut self,\n         tag: Tag,\n         global: &GlobalState,\n@@ -423,7 +424,7 @@ impl<'tcx> Stacks {\n         size: Size,\n         perm: Permission,\n         tag: Tag,\n-        extra: MemoryState,\n+        extra: MemoryExtra,\n     ) -> Self {\n         let item = Item { perm, tag, protector: None };\n         let stack = Stack {\n@@ -437,7 +438,7 @@ impl<'tcx> Stacks {\n     }\n \n     /// Call `f` on every stack in the range.\n-    pub(crate) fn for_each(\n+    fn for_each(\n         &self,\n         ptr: Pointer<Tag>,\n         size: Size,\n@@ -457,7 +458,7 @@ impl Stacks {\n     pub fn new_allocation(\n         id: AllocId,\n         size: Size,\n-        extra: MemoryState, \n+        extra: MemoryExtra, \n         kind: MemoryKind<MiriMemoryKind>,\n     ) -> (Self, Tag) {\n         let (tag, perm) = match kind {\n@@ -476,6 +477,44 @@ impl Stacks {\n         let stack = Stacks::new(size, perm, tag, extra);\n         (stack, tag)\n     }\n+\n+    #[inline(always)]\n+    pub fn memory_read<'tcx>(\n+        &self,\n+        ptr: Pointer<Tag>,\n+        size: Size,\n+    ) -> InterpResult<'tcx> {\n+        trace!(\"read access with tag {:?}: {:?}, size {}\", ptr.tag, ptr.erase_tag(), size.bytes());\n+        self.for_each(ptr, size, |stack, global| {\n+            stack.access(AccessKind::Read, ptr.tag, global)?;\n+            Ok(())\n+        })\n+    }\n+\n+    #[inline(always)]\n+    pub fn memory_written<'tcx>(\n+        &mut self,\n+        ptr: Pointer<Tag>,\n+        size: Size,\n+    ) -> InterpResult<'tcx> {\n+        trace!(\"write access with tag {:?}: {:?}, size {}\", ptr.tag, ptr.erase_tag(), size.bytes());\n+        self.for_each(ptr, size, |stack, global| {\n+            stack.access(AccessKind::Write, ptr.tag, global)?;\n+            Ok(())\n+        })\n+    }\n+\n+    #[inline(always)]\n+    pub fn memory_deallocated<'tcx>(\n+        &mut self,\n+        ptr: Pointer<Tag>,\n+        size: Size,\n+    ) -> InterpResult<'tcx> {\n+        trace!(\"deallocation with tag {:?}: {:?}, size {}\", ptr.tag, ptr.erase_tag(), size.bytes());\n+        self.for_each(ptr, size, |stack, global| {\n+            stack.dealloc(ptr.tag, global)\n+        })\n+    }\n }\n \n /// Retagging/reborrowing.  There is some policy in here, such as which permissions\n@@ -514,14 +553,14 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                     // We are only ever `SharedReadOnly` inside the frozen bits.\n                     let perm = if frozen { Permission::SharedReadOnly } else { Permission::SharedReadWrite };\n                     let item = Item { perm, tag: new_tag, protector };\n-                    alloc.extra.stacks.for_each(cur_ptr, size, |stack, global| {\n+                    alloc.extra.stacked_borrows.for_each(cur_ptr, size, |stack, global| {\n                         stack.grant(cur_ptr.tag, item, global)\n                     })\n                 });\n             }\n         };\n         let item = Item { perm, tag: new_tag, protector };\n-        alloc.extra.stacks.for_each(ptr, size, |stack, global| {\n+        alloc.extra.stacked_borrows.for_each(ptr, size, |stack, global| {\n             stack.grant(ptr.tag, item, global)\n         })\n     }\n@@ -548,7 +587,7 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         // Compute new borrow.\n         let new_tag = match kind {\n             RefKind::Raw { .. } => Tag::Untagged,\n-            _ => Tag::Tagged(this.memory().extra.stacked.borrow_mut().new_ptr()),\n+            _ => Tag::Tagged(this.memory().extra.stacked_borrows.borrow_mut().new_ptr()),\n         };\n \n         // Reborrow.\n@@ -582,7 +621,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 ty::RawPtr(tym) if kind == RetagKind::Raw =>\n                     Some((RefKind::Raw { mutable: tym.mutbl == MutMutable }, false)),\n                 // Boxes do not get a protector: protectors reflect that references outlive the call\n-            // they were passed in to; that's just not the case for boxes.\n+                // they were passed in to; that's just not the case for boxes.\n                 ty::Adt(..) if ty.is_box() => Some((RefKind::Unique { two_phase: false }, false)),\n                 _ => None,\n             }"}]}