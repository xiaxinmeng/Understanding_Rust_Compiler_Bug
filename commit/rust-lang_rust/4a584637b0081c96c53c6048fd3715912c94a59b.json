{"sha": "4a584637b0081c96c53c6048fd3715912c94a59b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRhNTg0NjM3YjAwODFjOTZjNTNjNjA0OGZkMzcxNTkxMmM5NGE1OWI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-10-27T01:18:57Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-10-27T01:18:57Z"}, "message": "Auto merge of #36695 - arielb1:literal-match, r=eddyb\n\nRefactor match checking to use HAIR\n\nRefactor match checking to use HAIR instead of HIR, fixing quite a few bugs in the process.\n\nr? @eddyb", "tree": {"sha": "c4bb920c15a5a2462b6cf422c3d72d702ee3e8c9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c4bb920c15a5a2462b6cf422c3d72d702ee3e8c9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4a584637b0081c96c53c6048fd3715912c94a59b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4a584637b0081c96c53c6048fd3715912c94a59b", "html_url": "https://github.com/rust-lang/rust/commit/4a584637b0081c96c53c6048fd3715912c94a59b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4a584637b0081c96c53c6048fd3715912c94a59b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c59cb71d976ceabf00c7da0224a795fab530601e", "url": "https://api.github.com/repos/rust-lang/rust/commits/c59cb71d976ceabf00c7da0224a795fab530601e", "html_url": "https://github.com/rust-lang/rust/commit/c59cb71d976ceabf00c7da0224a795fab530601e"}, {"sha": "3f9ebb48cf462eb72536b726e6f61bdeafa7e5ce", "url": "https://api.github.com/repos/rust-lang/rust/commits/3f9ebb48cf462eb72536b726e6f61bdeafa7e5ce", "html_url": "https://github.com/rust-lang/rust/commit/3f9ebb48cf462eb72536b726e6f61bdeafa7e5ce"}], "stats": {"total": 3235, "additions": 1904, "deletions": 1331}, "files": [{"sha": "683ba90adf94ab6bb54b03ab0e3bb1794aace828", "filename": "src/Cargo.lock", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4a584637b0081c96c53c6048fd3715912c94a59b/src%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/4a584637b0081c96c53c6048fd3715912c94a59b/src%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.lock?ref=4a584637b0081c96c53c6048fd3715912c94a59b", "patch": "@@ -330,11 +330,13 @@ dependencies = [\n name = \"rustc_const_eval\"\n version = \"0.0.0\"\n dependencies = [\n+ \"arena 0.0.0\",\n  \"graphviz 0.0.0\",\n  \"log 0.0.0\",\n  \"rustc 0.0.0\",\n  \"rustc_back 0.0.0\",\n  \"rustc_const_math 0.0.0\",\n+ \"rustc_data_structures 0.0.0\",\n  \"rustc_errors 0.0.0\",\n  \"serialize 0.0.0\",\n  \"syntax 0.0.0\","}, {"sha": "0e5cbce8639bede34939199f10ccd95a9b66ee42", "filename": "src/librustc_const_eval/Cargo.toml", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4a584637b0081c96c53c6048fd3715912c94a59b/src%2Flibrustc_const_eval%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/4a584637b0081c96c53c6048fd3715912c94a59b/src%2Flibrustc_const_eval%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2FCargo.toml?ref=4a584637b0081c96c53c6048fd3715912c94a59b", "patch": "@@ -9,11 +9,13 @@ path = \"lib.rs\"\n crate-type = [\"dylib\"]\n \n [dependencies]\n+arena = { path = \"../libarena\" }\n log = { path = \"../liblog\" }\n serialize = { path = \"../libserialize\" }\n rustc = { path = \"../librustc\" }\n rustc_back = { path = \"../librustc_back\" }\n rustc_const_math = { path = \"../librustc_const_math\" }\n+rustc_data_structures = { path = \"../librustc_data_structures\" }\n rustc_errors = { path = \"../librustc_errors\" }\n syntax = { path = \"../libsyntax\" }\n graphviz = { path = \"../libgraphviz\" }"}, {"sha": "7f5eb31612cb394f002a5e1cdfa68d99f562ed77", "filename": "src/librustc_const_eval/_match.rs", "status": "added", "additions": 767, "deletions": 0, "changes": 767, "blob_url": "https://github.com/rust-lang/rust/blob/4a584637b0081c96c53c6048fd3715912c94a59b/src%2Flibrustc_const_eval%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a584637b0081c96c53c6048fd3715912c94a59b/src%2Flibrustc_const_eval%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2F_match.rs?ref=4a584637b0081c96c53c6048fd3715912c94a59b", "patch": "@@ -0,0 +1,767 @@\n+// Copyright 2012-2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use self::Constructor::*;\n+use self::Usefulness::*;\n+use self::WitnessPreference::*;\n+\n+use rustc::middle::const_val::ConstVal;\n+use eval::{compare_const_vals};\n+\n+use rustc_const_math::ConstInt;\n+\n+use rustc_data_structures::fnv::FnvHashMap;\n+use rustc_data_structures::indexed_vec::Idx;\n+\n+use pattern::{FieldPattern, Pattern, PatternKind};\n+use pattern::{PatternFoldable, PatternFolder};\n+\n+use rustc::hir::def_id::{DefId};\n+use rustc::hir::pat_util::def_to_path;\n+use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n+\n+use rustc::hir;\n+use rustc::hir::def::CtorKind;\n+use rustc::hir::{Pat, PatKind};\n+use rustc::util::common::ErrorReported;\n+\n+use syntax::ast::{self, DUMMY_NODE_ID};\n+use syntax::codemap::Spanned;\n+use syntax::ptr::P;\n+use syntax_pos::{Span, DUMMY_SP};\n+\n+use arena::TypedArena;\n+\n+use std::cmp::Ordering;\n+use std::fmt;\n+use std::iter::{FromIterator, IntoIterator, repeat};\n+\n+pub fn expand_pattern<'a, 'tcx>(cx: &MatchCheckCtxt<'a, 'tcx>, pat: Pattern<'tcx>)\n+                                -> &'a Pattern<'tcx>\n+{\n+    cx.pattern_arena.alloc(LiteralExpander.fold_pattern(&pat))\n+}\n+\n+struct LiteralExpander;\n+impl<'tcx> PatternFolder<'tcx> for LiteralExpander {\n+    fn fold_pattern(&mut self, pat: &Pattern<'tcx>) -> Pattern<'tcx> {\n+        match (&pat.ty.sty, &*pat.kind) {\n+            (&ty::TyRef(_, mt), &PatternKind::Constant { ref value }) => {\n+                Pattern {\n+                    ty: pat.ty,\n+                    span: pat.span,\n+                    kind: box PatternKind::Deref {\n+                        subpattern: Pattern {\n+                            ty: mt.ty,\n+                            span: pat.span,\n+                            kind: box PatternKind::Constant { value: value.clone() },\n+                        }\n+                    }\n+                }\n+            }\n+            (_, &PatternKind::Binding { subpattern: Some(ref s), .. }) => {\n+                s.fold_with(self)\n+            }\n+            _ => pat.super_fold_with(self)\n+        }\n+    }\n+}\n+\n+pub const DUMMY_WILD_PAT: &'static Pat = &Pat {\n+    id: DUMMY_NODE_ID,\n+    node: PatKind::Wild,\n+    span: DUMMY_SP\n+};\n+\n+impl<'tcx> Pattern<'tcx> {\n+    fn is_wildcard(&self) -> bool {\n+        match *self.kind {\n+            PatternKind::Binding { subpattern: None, .. } | PatternKind::Wild =>\n+                true,\n+            _ => false\n+        }\n+    }\n+}\n+\n+pub struct Matrix<'a, 'tcx: 'a>(Vec<Vec<&'a Pattern<'tcx>>>);\n+\n+impl<'a, 'tcx> Matrix<'a, 'tcx> {\n+    pub fn empty() -> Self {\n+        Matrix(vec![])\n+    }\n+\n+    pub fn push(&mut self, row: Vec<&'a Pattern<'tcx>>) {\n+        self.0.push(row)\n+    }\n+}\n+\n+/// Pretty-printer for matrices of patterns, example:\n+/// ++++++++++++++++++++++++++\n+/// + _     + []             +\n+/// ++++++++++++++++++++++++++\n+/// + true  + [First]        +\n+/// ++++++++++++++++++++++++++\n+/// + true  + [Second(true)] +\n+/// ++++++++++++++++++++++++++\n+/// + false + [_]            +\n+/// ++++++++++++++++++++++++++\n+/// + _     + [_, _, ..tail] +\n+/// ++++++++++++++++++++++++++\n+impl<'a, 'tcx> fmt::Debug for Matrix<'a, 'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"\\n\")?;\n+\n+        let &Matrix(ref m) = self;\n+        let pretty_printed_matrix: Vec<Vec<String>> = m.iter().map(|row| {\n+            row.iter().map(|pat| format!(\"{:?}\", pat)).collect()\n+        }).collect();\n+\n+        let column_count = m.iter().map(|row| row.len()).max().unwrap_or(0);\n+        assert!(m.iter().all(|row| row.len() == column_count));\n+        let column_widths: Vec<usize> = (0..column_count).map(|col| {\n+            pretty_printed_matrix.iter().map(|row| row[col].len()).max().unwrap_or(0)\n+        }).collect();\n+\n+        let total_width = column_widths.iter().cloned().sum::<usize>() + column_count * 3 + 1;\n+        let br = repeat('+').take(total_width).collect::<String>();\n+        write!(f, \"{}\\n\", br)?;\n+        for row in pretty_printed_matrix {\n+            write!(f, \"+\")?;\n+            for (column, pat_str) in row.into_iter().enumerate() {\n+                write!(f, \" \")?;\n+                write!(f, \"{:1$}\", pat_str, column_widths[column])?;\n+                write!(f, \" +\")?;\n+            }\n+            write!(f, \"\\n\")?;\n+            write!(f, \"{}\\n\", br)?;\n+        }\n+        Ok(())\n+    }\n+}\n+\n+impl<'a, 'tcx> FromIterator<Vec<&'a Pattern<'tcx>>> for Matrix<'a, 'tcx> {\n+    fn from_iter<T: IntoIterator<Item=Vec<&'a Pattern<'tcx>>>>(iter: T) -> Self\n+    {\n+        Matrix(iter.into_iter().collect())\n+    }\n+}\n+\n+//NOTE: appears to be the only place other then InferCtxt to contain a ParamEnv\n+pub struct MatchCheckCtxt<'a, 'tcx: 'a> {\n+    pub tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    /// A wild pattern with an error type - it exists to avoid having to normalize\n+    /// associated types to get field types.\n+    pub wild_pattern: &'a Pattern<'tcx>,\n+    pub pattern_arena: &'a TypedArena<Pattern<'tcx>>,\n+    pub byte_array_map: FnvHashMap<*const Pattern<'tcx>, Vec<&'a Pattern<'tcx>>>,\n+}\n+\n+impl<'a, 'tcx> MatchCheckCtxt<'a, 'tcx> {\n+    pub fn create_and_enter<F, R>(\n+        tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+        f: F) -> R\n+        where F: for<'b> FnOnce(MatchCheckCtxt<'b, 'tcx>) -> R\n+    {\n+        let wild_pattern = Pattern {\n+            ty: tcx.types.err,\n+            span: DUMMY_SP,\n+            kind: box PatternKind::Wild\n+        };\n+\n+        let pattern_arena = TypedArena::new();\n+\n+        f(MatchCheckCtxt {\n+            tcx: tcx,\n+            wild_pattern: &wild_pattern,\n+            pattern_arena: &pattern_arena,\n+            byte_array_map: FnvHashMap(),\n+        })\n+    }\n+\n+    // convert a byte-string pattern to a list of u8 patterns.\n+    fn lower_byte_str_pattern(&mut self, pat: &'a Pattern<'tcx>) -> Vec<&'a Pattern<'tcx>> {\n+        let pattern_arena = &*self.pattern_arena;\n+        let tcx = self.tcx;\n+        self.byte_array_map.entry(pat).or_insert_with(|| {\n+            match pat.kind {\n+                box PatternKind::Constant {\n+                    value: ConstVal::ByteStr(ref data)\n+                } => {\n+                    data.iter().map(|c| &*pattern_arena.alloc(Pattern {\n+                        ty: tcx.types.u8,\n+                        span: pat.span,\n+                        kind: box PatternKind::Constant {\n+                            value: ConstVal::Integral(ConstInt::U8(*c))\n+                        }\n+                    })).collect()\n+                }\n+                _ => span_bug!(pat.span, \"unexpected byte array pattern {:?}\", pat)\n+            }\n+        }).clone()\n+    }\n+}\n+\n+#[derive(Clone, Debug, PartialEq)]\n+pub enum Constructor {\n+    /// The constructor of all patterns that don't vary by constructor,\n+    /// e.g. struct patterns and fixed-length arrays.\n+    Single,\n+    /// Enum variants.\n+    Variant(DefId),\n+    /// Literal values.\n+    ConstantValue(ConstVal),\n+    /// Ranges of literal values (2..5).\n+    ConstantRange(ConstVal, ConstVal),\n+    /// Array patterns of length n.\n+    Slice(usize),\n+}\n+\n+impl Constructor {\n+    fn variant_for_adt<'tcx, 'container, 'a>(&self,\n+                                             adt: &'a ty::AdtDefData<'tcx, 'container>)\n+                                             -> &'a ty::VariantDefData<'tcx, 'container> {\n+        match self {\n+            &Variant(vid) => adt.variant_with_id(vid),\n+            &Single => {\n+                assert_eq!(adt.variants.len(), 1);\n+                &adt.variants[0]\n+            }\n+            _ => bug!(\"bad constructor {:?} for adt {:?}\", self, adt)\n+        }\n+    }\n+}\n+\n+#[derive(Clone, PartialEq)]\n+pub enum Usefulness {\n+    Useful,\n+    UsefulWithWitness(Vec<Witness>),\n+    NotUseful\n+}\n+\n+#[derive(Copy, Clone)]\n+pub enum WitnessPreference {\n+    ConstructWitness,\n+    LeaveOutWitness\n+}\n+\n+#[derive(Copy, Clone, Debug)]\n+struct PatternContext<'tcx> {\n+    ty: Ty<'tcx>,\n+    max_slice_length: usize,\n+}\n+\n+\n+fn const_val_to_expr(value: &ConstVal) -> P<hir::Expr> {\n+    let node = match value {\n+        &ConstVal::Bool(b) => ast::LitKind::Bool(b),\n+        _ => bug!()\n+    };\n+    P(hir::Expr {\n+        id: DUMMY_NODE_ID,\n+        node: hir::ExprLit(P(Spanned { node: node, span: DUMMY_SP })),\n+        span: DUMMY_SP,\n+        attrs: ast::ThinVec::new(),\n+    })\n+}\n+\n+/// A stack of patterns in reverse order of construction\n+#[derive(Clone, PartialEq, Eq)]\n+pub struct Witness(Vec<P<Pat>>);\n+\n+impl Witness {\n+    pub fn single_pattern(&self) -> &Pat {\n+        assert_eq!(self.0.len(), 1);\n+        &self.0[0]\n+    }\n+\n+    fn push_wild_constructor<'a, 'tcx>(\n+        mut self,\n+        cx: &MatchCheckCtxt<'a, 'tcx>,\n+        ctor: &Constructor,\n+        ty: Ty<'tcx>)\n+        -> Self\n+    {\n+        let arity = constructor_arity(cx, ctor, ty);\n+        self.0.extend(repeat(DUMMY_WILD_PAT).take(arity).map(|p| P(p.clone())));\n+        self.apply_constructor(cx, ctor, ty)\n+    }\n+\n+\n+    /// Constructs a partial witness for a pattern given a list of\n+    /// patterns expanded by the specialization step.\n+    ///\n+    /// When a pattern P is discovered to be useful, this function is used bottom-up\n+    /// to reconstruct a complete witness, e.g. a pattern P' that covers a subset\n+    /// of values, V, where each value in that set is not covered by any previously\n+    /// used patterns and is covered by the pattern P'. Examples:\n+    ///\n+    /// left_ty: tuple of 3 elements\n+    /// pats: [10, 20, _]           => (10, 20, _)\n+    ///\n+    /// left_ty: struct X { a: (bool, &'static str), b: usize}\n+    /// pats: [(false, \"foo\"), 42]  => X { a: (false, \"foo\"), b: 42 }\n+    fn apply_constructor<'a, 'tcx>(\n+        mut self,\n+        cx: &MatchCheckCtxt<'a,'tcx>,\n+        ctor: &Constructor,\n+        ty: Ty<'tcx>)\n+        -> Self\n+    {\n+        let arity = constructor_arity(cx, ctor, ty);\n+        let pat = {\n+            let len = self.0.len();\n+            let mut pats = self.0.drain(len-arity..).rev();\n+\n+            match ty.sty {\n+                ty::TyTuple(..) => PatKind::Tuple(pats.collect(), None),\n+\n+                ty::TyAdt(adt, _) => {\n+                    let v = ctor.variant_for_adt(adt);\n+                    match v.ctor_kind {\n+                        CtorKind::Fictive => {\n+                            let field_pats: hir::HirVec<_> = v.fields.iter()\n+                                .zip(pats)\n+                                .filter(|&(_, ref pat)| pat.node != PatKind::Wild)\n+                                .map(|(field, pat)| Spanned {\n+                                    span: DUMMY_SP,\n+                                    node: hir::FieldPat {\n+                                        name: field.name,\n+                                        pat: pat,\n+                                        is_shorthand: false,\n+                                    }\n+                                }).collect();\n+                            let has_more_fields = field_pats.len() < arity;\n+                            PatKind::Struct(\n+                                def_to_path(cx.tcx, v.did), field_pats, has_more_fields)\n+                        }\n+                        CtorKind::Fn => {\n+                            PatKind::TupleStruct(\n+                                def_to_path(cx.tcx, v.did), pats.collect(), None)\n+                        }\n+                        CtorKind::Const => {\n+                            PatKind::Path(None, def_to_path(cx.tcx, v.did))\n+                        }\n+                    }\n+                }\n+\n+                ty::TyRef(_, ty::TypeAndMut { mutbl, .. }) => {\n+                    PatKind::Ref(pats.nth(0).unwrap(), mutbl)\n+                }\n+\n+                ty::TySlice(_) | ty::TyArray(..) => {\n+                    PatKind::Slice(pats.collect(), None, hir::HirVec::new())\n+                }\n+\n+                _ => {\n+                    match *ctor {\n+                        ConstantValue(ref v) => PatKind::Lit(const_val_to_expr(v)),\n+                        _ => PatKind::Wild,\n+                    }\n+                }\n+            }\n+        };\n+\n+        self.0.push(P(hir::Pat {\n+            id: DUMMY_NODE_ID,\n+            node: pat,\n+            span: DUMMY_SP\n+        }));\n+\n+        self\n+    }\n+}\n+\n+/// Return the set of constructors from the same type as the first column of `matrix`,\n+/// that are matched only by wildcard patterns from that first column.\n+///\n+/// Therefore, if there is some pattern that is unmatched by `matrix`, it will\n+/// still be unmatched if the first constructor is replaced by any of the constructors\n+/// in the return value.\n+fn missing_constructors(cx: &mut MatchCheckCtxt,\n+                        matrix: &Matrix,\n+                        pcx: PatternContext) -> Vec<Constructor> {\n+    let used_constructors: Vec<Constructor> =\n+        matrix.0.iter()\n+        .flat_map(|row| pat_constructors(cx, row[0], pcx).unwrap_or(vec![]))\n+        .collect();\n+    debug!(\"used_constructors = {:?}\", used_constructors);\n+    all_constructors(cx, pcx).into_iter()\n+        .filter(|c| !used_constructors.contains(c))\n+        .collect()\n+}\n+\n+/// This determines the set of all possible constructors of a pattern matching\n+/// values of type `left_ty`. For vectors, this would normally be an infinite set\n+///\n+/// This intentionally does not list ConstantValue specializations for\n+/// non-booleans, because we currently assume that there is always a\n+/// \"non-standard constant\" that matches. See issue #12483.\n+///\n+/// but is instead bounded by the maximum fixed length of slice patterns in\n+/// the column of patterns being analyzed.\n+fn all_constructors(_cx: &mut MatchCheckCtxt, pcx: PatternContext) -> Vec<Constructor> {\n+    match pcx.ty.sty {\n+        ty::TyBool =>\n+            [true, false].iter().map(|b| ConstantValue(ConstVal::Bool(*b))).collect(),\n+        ty::TySlice(_) =>\n+            (0..pcx.max_slice_length+1).map(|length| Slice(length)).collect(),\n+        ty::TyArray(_, length) => vec![Slice(length)],\n+        ty::TyAdt(def, _) if def.is_enum() && def.variants.len() > 1 =>\n+            def.variants.iter().map(|v| Variant(v.did)).collect(),\n+        _ => vec![Single]\n+    }\n+}\n+\n+/// Algorithm from http://moscova.inria.fr/~maranget/papers/warn/index.html\n+///\n+/// Whether a vector `v` of patterns is 'useful' in relation to a set of such\n+/// vectors `m` is defined as there being a set of inputs that will match `v`\n+/// but not any of the sets in `m`.\n+///\n+/// This is used both for reachability checking (if a pattern isn't useful in\n+/// relation to preceding patterns, it is not reachable) and exhaustiveness\n+/// checking (if a wildcard pattern is useful in relation to a matrix, the\n+/// matrix isn't exhaustive).\n+///\n+/// Note: is_useful doesn't work on empty types, as the paper notes.\n+/// So it assumes that v is non-empty.\n+pub fn is_useful<'a, 'tcx>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n+                           matrix: &Matrix<'a, 'tcx>,\n+                           v: &[&'a Pattern<'tcx>],\n+                           witness: WitnessPreference)\n+                           -> Usefulness {\n+    let &Matrix(ref rows) = matrix;\n+    debug!(\"is_useful({:?}, {:?})\", matrix, v);\n+    if rows.is_empty() {\n+        return match witness {\n+            ConstructWitness => UsefulWithWitness(vec![Witness(\n+                repeat(DUMMY_WILD_PAT).take(v.len()).map(|p| P(p.clone())).collect()\n+            )]),\n+            LeaveOutWitness => Useful\n+        };\n+    }\n+    if rows[0].is_empty() {\n+        return NotUseful;\n+    }\n+\n+    let &Matrix(ref rows) = matrix;\n+    assert!(rows.iter().all(|r| r.len() == v.len()));\n+    let pcx = PatternContext {\n+        ty: rows.iter().map(|r| r[0].ty).find(|ty| !ty.references_error())\n+            .unwrap_or(v[0].ty),\n+        max_slice_length: rows.iter().filter_map(|row| match *row[0].kind {\n+            PatternKind::Slice { ref prefix, slice: _, ref suffix } =>\n+                Some(prefix.len() + suffix.len()),\n+            PatternKind::Constant { value: ConstVal::ByteStr(ref data) } =>\n+                Some(data.len()),\n+            _ => None\n+        }).max().map_or(0, |v| v + 1)\n+    };\n+\n+    debug!(\"is_useful_expand_first_col: pcx={:?}, expanding {:?}\", pcx, v[0]);\n+\n+    if let Some(constructors) = pat_constructors(cx, v[0], pcx) {\n+        debug!(\"is_useful - expanding constructors: {:?}\", constructors);\n+        constructors.into_iter().map(|c|\n+            is_useful_specialized(cx, matrix, v, c.clone(), pcx.ty, witness)\n+        ).find(|result| result != &NotUseful).unwrap_or(NotUseful)\n+    } else {\n+        debug!(\"is_useful - expanding wildcard\");\n+        let constructors = missing_constructors(cx, matrix, pcx);\n+        debug!(\"is_useful - missing_constructors = {:?}\", constructors);\n+        if constructors.is_empty() {\n+            all_constructors(cx, pcx).into_iter().map(|c| {\n+                is_useful_specialized(cx, matrix, v, c.clone(), pcx.ty, witness)\n+            }).find(|result| result != &NotUseful).unwrap_or(NotUseful)\n+        } else {\n+            let matrix = rows.iter().filter_map(|r| {\n+                if r[0].is_wildcard() {\n+                    Some(r[1..].to_vec())\n+                } else {\n+                    None\n+                }\n+            }).collect();\n+            match is_useful(cx, &matrix, &v[1..], witness) {\n+                UsefulWithWitness(pats) => {\n+                    let cx = &*cx;\n+                    UsefulWithWitness(pats.into_iter().flat_map(|witness| {\n+                        constructors.iter().map(move |ctor| {\n+                            witness.clone().push_wild_constructor(cx, ctor, pcx.ty)\n+                        })\n+                    }).collect())\n+                }\n+                result => result\n+            }\n+        }\n+    }\n+}\n+\n+fn is_useful_specialized<'a, 'tcx>(\n+    cx: &mut MatchCheckCtxt<'a, 'tcx>,\n+    &Matrix(ref m): &Matrix<'a, 'tcx>,\n+    v: &[&'a Pattern<'tcx>],\n+    ctor: Constructor,\n+    lty: Ty<'tcx>,\n+    witness: WitnessPreference) -> Usefulness\n+{\n+    let arity = constructor_arity(cx, &ctor, lty);\n+    let matrix = Matrix(m.iter().flat_map(|r| {\n+        specialize(cx, &r[..], &ctor, 0, arity)\n+    }).collect());\n+    match specialize(cx, v, &ctor, 0, arity) {\n+        Some(v) => match is_useful(cx, &matrix, &v[..], witness) {\n+            UsefulWithWitness(witnesses) => UsefulWithWitness(\n+                witnesses.into_iter()\n+                    .map(|witness| witness.apply_constructor(cx, &ctor, lty))\n+                    .collect()\n+            ),\n+            result => result\n+        },\n+        None => NotUseful\n+    }\n+}\n+\n+/// Determines the constructors that the given pattern can be specialized to.\n+///\n+/// In most cases, there's only one constructor that a specific pattern\n+/// represents, such as a specific enum variant or a specific literal value.\n+/// Slice patterns, however, can match slices of different lengths. For instance,\n+/// `[a, b, ..tail]` can match a slice of length 2, 3, 4 and so on.\n+///\n+/// Returns None in case of a catch-all, which can't be specialized.\n+fn pat_constructors(_cx: &mut MatchCheckCtxt,\n+                    pat: &Pattern,\n+                    pcx: PatternContext)\n+                    -> Option<Vec<Constructor>>\n+{\n+    match *pat.kind {\n+        PatternKind::Binding { .. } | PatternKind::Wild =>\n+            None,\n+        PatternKind::Leaf { .. } | PatternKind::Deref { .. } =>\n+            Some(vec![Single]),\n+        PatternKind::Variant { adt_def, variant_index, .. } =>\n+            Some(vec![Variant(adt_def.variants[variant_index].did)]),\n+        PatternKind::Constant { ref value } =>\n+            Some(vec![ConstantValue(value.clone())]),\n+        PatternKind::Range { ref lo, ref hi } =>\n+            Some(vec![ConstantRange(lo.clone(), hi.clone())]),\n+        PatternKind::Array { .. } => match pcx.ty.sty {\n+            ty::TyArray(_, length) => Some(vec![Slice(length)]),\n+            _ => span_bug!(pat.span, \"bad ty {:?} for array pattern\", pcx.ty)\n+        },\n+        PatternKind::Slice { ref prefix, ref slice, ref suffix } => {\n+            let pat_len = prefix.len() + suffix.len();\n+            if slice.is_some() {\n+                Some((pat_len..pcx.max_slice_length+1).map(Slice).collect())\n+            } else {\n+                Some(vec![Slice(pat_len)])\n+            }\n+        }\n+    }\n+}\n+\n+/// This computes the arity of a constructor. The arity of a constructor\n+/// is how many subpattern patterns of that constructor should be expanded to.\n+///\n+/// For instance, a tuple pattern (_, 42, Some([])) has the arity of 3.\n+/// A struct pattern's arity is the number of fields it contains, etc.\n+fn constructor_arity(_cx: &MatchCheckCtxt, ctor: &Constructor, ty: Ty) -> usize {\n+    debug!(\"constructor_arity({:?}, {:?})\", ctor, ty);\n+    match ty.sty {\n+        ty::TyTuple(ref fs) => fs.len(),\n+        ty::TyBox(_) => 1,\n+        ty::TySlice(..) | ty::TyArray(..) => match *ctor {\n+            Slice(length) => length,\n+            ConstantValue(_) => 0,\n+            _ => bug!(\"bad slice pattern {:?} {:?}\", ctor, ty)\n+        },\n+        ty::TyRef(..) => 1,\n+        ty::TyAdt(adt, _) => {\n+            ctor.variant_for_adt(adt).fields.len()\n+        }\n+        _ => 0\n+    }\n+}\n+\n+fn slice_pat_covered_by_constructor(_tcx: TyCtxt, _span: Span,\n+                                    ctor: &Constructor,\n+                                    prefix: &[Pattern],\n+                                    slice: &Option<Pattern>,\n+                                    suffix: &[Pattern])\n+                                    -> Result<bool, ErrorReported> {\n+    let data = match *ctor {\n+        ConstantValue(ConstVal::ByteStr(ref data)) => data,\n+        _ => bug!()\n+    };\n+\n+    let pat_len = prefix.len() + suffix.len();\n+    if data.len() < pat_len || (slice.is_none() && data.len() > pat_len) {\n+        return Ok(false);\n+    }\n+\n+    for (ch, pat) in\n+        data[..prefix.len()].iter().zip(prefix).chain(\n+            data[data.len()-suffix.len()..].iter().zip(suffix))\n+    {\n+        match pat.kind {\n+            box PatternKind::Constant { ref value } => match *value {\n+                ConstVal::Integral(ConstInt::U8(u)) => {\n+                    if u != *ch {\n+                        return Ok(false);\n+                    }\n+                },\n+                _ => span_bug!(pat.span, \"bad const u8 {:?}\", value)\n+            },\n+            _ => {}\n+        }\n+    }\n+\n+    Ok(true)\n+}\n+\n+fn range_covered_by_constructor(tcx: TyCtxt, span: Span,\n+                                ctor: &Constructor,\n+                                from: &ConstVal, to: &ConstVal)\n+                                -> Result<bool, ErrorReported> {\n+    let (c_from, c_to) = match *ctor {\n+        ConstantValue(ref value)        => (value, value),\n+        ConstantRange(ref from, ref to) => (from, to),\n+        Single                          => return Ok(true),\n+        _                               => bug!()\n+    };\n+    let cmp_from = compare_const_vals(tcx, span, c_from, from)?;\n+    let cmp_to = compare_const_vals(tcx, span, c_to, to)?;\n+    Ok(cmp_from != Ordering::Less && cmp_to != Ordering::Greater)\n+}\n+\n+fn patterns_for_variant<'a, 'tcx>(\n+    cx: &mut MatchCheckCtxt<'a, 'tcx>,\n+    subpatterns: &'a [FieldPattern<'tcx>],\n+    arity: usize)\n+    -> Vec<&'a Pattern<'tcx>>\n+{\n+    let mut result = vec![cx.wild_pattern; arity];\n+\n+    for subpat in subpatterns {\n+        result[subpat.field.index()] = &subpat.pattern;\n+    }\n+\n+    debug!(\"patterns_for_variant({:?}, {:?}) = {:?}\", subpatterns, arity, result);\n+    result\n+}\n+\n+/// This is the main specialization step. It expands the first pattern in the given row\n+/// into `arity` patterns based on the constructor. For most patterns, the step is trivial,\n+/// for instance tuple patterns are flattened and box patterns expand into their inner pattern.\n+///\n+/// OTOH, slice patterns with a subslice pattern (..tail) can be expanded into multiple\n+/// different patterns.\n+/// Structure patterns with a partial wild pattern (Foo { a: 42, .. }) have their missing\n+/// fields filled with wild patterns.\n+fn specialize<'a, 'tcx>(\n+    cx: &mut MatchCheckCtxt<'a, 'tcx>,\n+    r: &[&'a Pattern<'tcx>],\n+    constructor: &Constructor, col: usize, arity: usize)\n+    -> Option<Vec<&'a Pattern<'tcx>>>\n+{\n+    let pat = &r[col];\n+\n+    let head: Option<Vec<&Pattern>> = match *pat.kind {\n+        PatternKind::Binding { .. } | PatternKind::Wild =>\n+            Some(vec![cx.wild_pattern; arity]),\n+\n+        PatternKind::Variant { adt_def, variant_index, ref subpatterns } => {\n+            let ref variant = adt_def.variants[variant_index];\n+            if *constructor == Variant(variant.did) {\n+                Some(patterns_for_variant(cx, subpatterns, arity))\n+            } else {\n+                None\n+            }\n+        }\n+\n+        PatternKind::Leaf { ref subpatterns } => Some(patterns_for_variant(cx, subpatterns, arity)),\n+        PatternKind::Deref { ref subpattern } => Some(vec![subpattern]),\n+\n+        PatternKind::Constant { ref value } => {\n+            match *constructor {\n+                Slice(..) => match *value {\n+                    ConstVal::ByteStr(ref data) => {\n+                        if arity == data.len() {\n+                            Some(cx.lower_byte_str_pattern(pat))\n+                        } else {\n+                            None\n+                        }\n+                    }\n+                    _ => span_bug!(pat.span,\n+                        \"unexpected const-val {:?} with ctor {:?}\", value, constructor)\n+                },\n+                _ => {\n+                    match range_covered_by_constructor(\n+                        cx.tcx, pat.span, constructor, value, value\n+                            ) {\n+                        Ok(true) => Some(vec![]),\n+                        Ok(false) => None,\n+                        Err(ErrorReported) => None,\n+                    }\n+                }\n+            }\n+        }\n+\n+        PatternKind::Range { ref lo, ref hi } => {\n+            match range_covered_by_constructor(\n+                cx.tcx, pat.span, constructor, lo, hi\n+            ) {\n+                Ok(true) => Some(vec![]),\n+                Ok(false) => None,\n+                Err(ErrorReported) => None,\n+            }\n+        }\n+\n+        PatternKind::Array { ref prefix, ref slice, ref suffix } |\n+        PatternKind::Slice { ref prefix, ref slice, ref suffix } => {\n+            match *constructor {\n+                Slice(..) => {\n+                    let pat_len = prefix.len() + suffix.len();\n+                    if let Some(slice_count) = arity.checked_sub(pat_len) {\n+                        if slice_count == 0 || slice.is_some() {\n+                            Some(\n+                                prefix.iter().chain(\n+                                repeat(cx.wild_pattern).take(slice_count).chain(\n+                                suffix.iter()\n+                            )).collect())\n+                        } else {\n+                            None\n+                        }\n+                    } else {\n+                        None\n+                    }\n+                }\n+                ConstantValue(..) => {\n+                    match slice_pat_covered_by_constructor(\n+                        cx.tcx, pat.span, constructor, prefix, slice, suffix\n+                            ) {\n+                        Ok(true) => Some(vec![]),\n+                        Ok(false) => None,\n+                        Err(ErrorReported) => None\n+                    }\n+                }\n+                _ => span_bug!(pat.span,\n+                    \"unexpected ctor {:?} for slice pat\", constructor)\n+            }\n+        }\n+    };\n+    debug!(\"specialize({:?}, {:?}) = {:?}\", r[col], arity, head);\n+\n+    head.map(|mut head| {\n+        head.extend_from_slice(&r[..col]);\n+        head.extend_from_slice(&r[col + 1..]);\n+        head\n+    })\n+}"}, {"sha": "9aa1ac62f5523abf6b42d7ab4f143fc16ee6686c", "filename": "src/librustc_const_eval/check_match.rs", "status": "modified", "additions": 225, "deletions": 897, "changes": 1122, "blob_url": "https://github.com/rust-lang/rust/blob/4a584637b0081c96c53c6048fd3715912c94a59b/src%2Flibrustc_const_eval%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a584637b0081c96c53c6048fd3715912c94a59b/src%2Flibrustc_const_eval%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fcheck_match.rs?ref=4a584637b0081c96c53c6048fd3715912c94a59b", "patch": "@@ -8,226 +8,210 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use self::Constructor::*;\n-use self::Usefulness::*;\n-use self::WitnessPreference::*;\n+use _match::{MatchCheckCtxt, Matrix, expand_pattern, is_useful};\n+use _match::{DUMMY_WILD_PAT};\n+use _match::Usefulness::*;\n+use _match::WitnessPreference::*;\n+\n+use pattern::{Pattern, PatternContext, PatternError};\n \n-use rustc::dep_graph::DepNode;\n-use rustc::middle::const_val::ConstVal;\n-use ::{eval_const_expr, eval_const_expr_partial, compare_const_vals};\n-use ::{const_expr_to_pat, lookup_const_by_id};\n-use ::EvalHint::ExprTypeChecked;\n use eval::report_const_eval_err;\n-use rustc::hir::def::*;\n-use rustc::hir::def_id::{DefId};\n+\n+use rustc::dep_graph::DepNode;\n+\n+use rustc::hir::pat_util::{pat_bindings, pat_contains_bindings};\n+\n use rustc::middle::expr_use_visitor::{ConsumeMode, Delegate, ExprUseVisitor};\n use rustc::middle::expr_use_visitor::{LoanCause, MutateMode};\n use rustc::middle::expr_use_visitor as euv;\n use rustc::middle::mem_categorization::{cmt};\n-use rustc::hir::pat_util::*;\n use rustc::session::Session;\n use rustc::traits::Reveal;\n-use rustc::ty::{self, Ty, TyCtxt};\n+use rustc::ty::{self, TyCtxt};\n use rustc_errors::DiagnosticBuilder;\n-use std::cmp::Ordering;\n-use std::fmt;\n-use std::iter::{FromIterator, IntoIterator, repeat};\n \n-use rustc::hir;\n-use rustc::hir::{Pat, PatKind};\n+use rustc::hir::def::*;\n use rustc::hir::intravisit::{self, Visitor, FnKind};\n-use rustc_back::slice;\n-\n-use syntax::ast::{self, DUMMY_NODE_ID, NodeId};\n-use syntax::codemap::Spanned;\n-use syntax_pos::{Span, DUMMY_SP};\n use rustc::hir::print::pat_to_string;\n-use syntax::ptr::P;\n-use syntax::util::move_map::MoveMap;\n-use rustc::util::common::ErrorReported;\n+use rustc::hir::{self, Pat, PatKind};\n \n-pub const DUMMY_WILD_PAT: &'static Pat = &Pat {\n-    id: DUMMY_NODE_ID,\n-    node: PatKind::Wild,\n-    span: DUMMY_SP\n-};\n-\n-struct Matrix<'a, 'tcx>(Vec<Vec<(&'a Pat, Option<Ty<'tcx>>)>>);\n+use rustc_back::slice;\n \n-/// Pretty-printer for matrices of patterns, example:\n-/// ++++++++++++++++++++++++++\n-/// + _     + []             +\n-/// ++++++++++++++++++++++++++\n-/// + true  + [First]        +\n-/// ++++++++++++++++++++++++++\n-/// + true  + [Second(true)] +\n-/// ++++++++++++++++++++++++++\n-/// + false + [_]            +\n-/// ++++++++++++++++++++++++++\n-/// + _     + [_, _, ..tail] +\n-/// ++++++++++++++++++++++++++\n-impl<'a, 'tcx> fmt::Debug for Matrix<'a, 'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"\\n\")?;\n+use syntax::ast;\n+use syntax::ptr::P;\n+use syntax_pos::Span;\n \n-        let &Matrix(ref m) = self;\n-        let pretty_printed_matrix: Vec<Vec<String>> = m.iter().map(|row| {\n-            row.iter()\n-               .map(|&(pat,ty)| format!(\"{}: {:?}\", pat_to_string(&pat), ty))\n-               .collect::<Vec<String>>()\n-        }).collect();\n+struct OuterVisitor<'a, 'tcx: 'a> { tcx: TyCtxt<'a, 'tcx, 'tcx> }\n \n-        let column_count = m.iter().map(|row| row.len()).max().unwrap_or(0);\n-        assert!(m.iter().all(|row| row.len() == column_count));\n-        let column_widths: Vec<usize> = (0..column_count).map(|col| {\n-            pretty_printed_matrix.iter().map(|row| row[col].len()).max().unwrap_or(0)\n-        }).collect();\n+impl<'a, 'v, 'tcx> Visitor<'v> for OuterVisitor<'a, 'tcx> {\n+    fn visit_expr(&mut self, _expr: &hir::Expr) {\n+        return // const, static and N in [T; N] - shouldn't contain anything\n+    }\n \n-        let total_width = column_widths.iter().cloned().sum::<usize>() + column_count * 3 + 1;\n-        let br = repeat('+').take(total_width).collect::<String>();\n-        write!(f, \"{}\\n\", br)?;\n-        for row in pretty_printed_matrix {\n-            write!(f, \"+\")?;\n-            for (column, pat_str) in row.into_iter().enumerate() {\n-                write!(f, \" \")?;\n-                write!(f, \"{:1$}\", pat_str, column_widths[column])?;\n-                write!(f, \" +\")?;\n-            }\n-            write!(f, \"\\n\")?;\n-            write!(f, \"{}\\n\", br)?;\n+    fn visit_trait_item(&mut self, item: &hir::TraitItem) {\n+        if let hir::ConstTraitItem(..) = item.node {\n+            return // nothing worth match checking in a constant\n+        } else {\n+            intravisit::walk_trait_item(self, item);\n         }\n-        Ok(())\n     }\n-}\n \n-impl<'a, 'tcx> FromIterator<Vec<(&'a Pat, Option<Ty<'tcx>>)>> for Matrix<'a, 'tcx> {\n-    fn from_iter<T: IntoIterator<Item=Vec<(&'a Pat, Option<Ty<'tcx>>)>>>(iter: T)\n-                                                                         -> Self\n-    {\n-        Matrix(iter.into_iter().collect())\n+    fn visit_impl_item(&mut self, item: &hir::ImplItem) {\n+        if let hir::ImplItemKind::Const(..) = item.node {\n+            return // nothing worth match checking in a constant\n+        } else {\n+            intravisit::walk_impl_item(self, item);\n+        }\n     }\n-}\n \n-//NOTE: appears to be the only place other then InferCtxt to contain a ParamEnv\n-pub struct MatchCheckCtxt<'a, 'tcx: 'a> {\n-    pub tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    pub param_env: ty::ParameterEnvironment<'tcx>,\n+    fn visit_fn(&mut self, fk: FnKind<'v>, fd: &'v hir::FnDecl,\n+                b: &'v hir::Block, s: Span, id: ast::NodeId) {\n+        if let FnKind::Closure(..) = fk {\n+            span_bug!(s, \"check_match: closure outside of function\")\n+        }\n+\n+        MatchVisitor {\n+            tcx: self.tcx,\n+            param_env: &ty::ParameterEnvironment::for_item(self.tcx, id)\n+        }.visit_fn(fk, fd, b, s, id);\n+    }\n }\n \n-#[derive(Clone, Debug, PartialEq)]\n-pub enum Constructor {\n-    /// The constructor of all patterns that don't vary by constructor,\n-    /// e.g. struct patterns and fixed-length arrays.\n-    Single,\n-    /// Enum variants.\n-    Variant(DefId),\n-    /// Literal values.\n-    ConstantValue(ConstVal),\n-    /// Ranges of literal values (2..5).\n-    ConstantRange(ConstVal, ConstVal),\n-    /// Array patterns of length n.\n-    Slice(usize),\n-    /// Array patterns with a subslice.\n-    SliceWithSubslice(usize, usize)\n+pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n+    tcx.visit_all_items_in_krate(DepNode::MatchCheck, &mut OuterVisitor { tcx: tcx });\n+    tcx.sess.abort_if_errors();\n }\n \n-#[derive(Clone, PartialEq)]\n-enum Usefulness {\n-    Useful,\n-    UsefulWithWitness(Vec<P<Pat>>),\n-    NotUseful\n+fn create_e0004<'a>(sess: &'a Session, sp: Span, error_message: String) -> DiagnosticBuilder<'a> {\n+    struct_span_err!(sess, sp, E0004, \"{}\", &error_message)\n }\n \n-#[derive(Copy, Clone)]\n-enum WitnessPreference {\n-    ConstructWitness,\n-    LeaveOutWitness\n+struct MatchVisitor<'a, 'tcx: 'a> {\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    param_env: &'a ty::ParameterEnvironment<'tcx>\n }\n \n-impl<'a, 'tcx, 'v> Visitor<'v> for MatchCheckCtxt<'a, 'tcx> {\n+impl<'a, 'tcx, 'v> Visitor<'v> for MatchVisitor<'a, 'tcx> {\n     fn visit_expr(&mut self, ex: &hir::Expr) {\n-        check_expr(self, ex);\n-    }\n-    fn visit_local(&mut self, l: &hir::Local) {\n-        check_local(self, l);\n+        intravisit::walk_expr(self, ex);\n+\n+        match ex.node {\n+            hir::ExprMatch(ref scrut, ref arms, source) => {\n+                self.check_match(scrut, arms, source, ex.span);\n+            }\n+            _ => {}\n+        }\n     }\n-    fn visit_fn(&mut self, fk: FnKind<'v>, fd: &'v hir::FnDecl,\n-                b: &'v hir::Block, s: Span, n: NodeId) {\n-        check_fn(self, fk, fd, b, s, n);\n+\n+    fn visit_local(&mut self, loc: &hir::Local) {\n+        intravisit::walk_local(self, loc);\n+\n+        self.check_irrefutable(&loc.pat, false);\n+\n+        // Check legality of move bindings and `@` patterns.\n+        self.check_patterns(false, slice::ref_slice(&loc.pat));\n     }\n-}\n \n-pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n-    tcx.visit_all_items_in_krate(DepNode::MatchCheck, &mut MatchCheckCtxt {\n-        tcx: tcx,\n-        param_env: tcx.empty_parameter_environment(),\n-    });\n-    tcx.sess.abort_if_errors();\n-}\n+    fn visit_fn(&mut self, fk: FnKind<'v>, fd: &'v hir::FnDecl,\n+                b: &'v hir::Block, s: Span, n: ast::NodeId) {\n+        intravisit::walk_fn(self, fk, fd, b, s, n);\n \n-fn create_e0004<'a>(sess: &'a Session, sp: Span, error_message: String) -> DiagnosticBuilder<'a> {\n-    struct_span_err!(sess, sp, E0004, \"{}\", &error_message)\n+        for input in &fd.inputs {\n+            self.check_irrefutable(&input.pat, true);\n+            self.check_patterns(false, slice::ref_slice(&input.pat));\n+        }\n+    }\n }\n \n-fn check_expr(cx: &mut MatchCheckCtxt, ex: &hir::Expr) {\n-    intravisit::walk_expr(cx, ex);\n-    match ex.node {\n-        hir::ExprMatch(ref scrut, ref arms, source) => {\n-            for arm in arms {\n-                // First, check legality of move bindings.\n-                check_legality_of_move_bindings(cx,\n-                                                arm.guard.is_some(),\n-                                                &arm.pats);\n+impl<'a, 'tcx> MatchVisitor<'a, 'tcx> {\n+    fn check_patterns(&self, has_guard: bool, pats: &[P<Pat>]) {\n+        check_legality_of_move_bindings(self, has_guard, pats);\n+        for pat in pats {\n+            check_legality_of_bindings_in_at_patterns(self, pat);\n+        }\n+    }\n \n-                // Second, if there is a guard on each arm, make sure it isn't\n-                // assigning or borrowing anything mutably.\n-                if let Some(ref guard) = arm.guard {\n-                    check_for_mutation_in_guard(cx, &guard);\n+    fn report_inlining_errors(&self, patcx: PatternContext, pat_span: Span) {\n+        for error in patcx.errors {\n+            match error {\n+                PatternError::BadConstInPattern(span, def_id) => {\n+                    self.tcx.sess.span_err(\n+                        span,\n+                        &format!(\"constants of the type `{}` \\\n+                                  cannot be used in patterns\",\n+                                 self.tcx.item_path_str(def_id)));\n+                }\n+                PatternError::StaticInPattern(span) => {\n+                    span_err!(self.tcx.sess, span, E0158,\n+                              \"statics cannot be referenced in patterns\");\n+                }\n+                PatternError::ConstEval(err) => {\n+                    report_const_eval_err(self.tcx, &err, pat_span, \"pattern\").emit();\n                 }\n             }\n+        }\n+    }\n \n-            let mut static_inliner = StaticInliner::new(cx.tcx);\n-            let inlined_arms = arms.iter().map(|arm| {\n-                (arm.pats.iter().map(|pat| {\n-                    static_inliner.fold_pat((*pat).clone())\n-                }).collect(), arm.guard.as_ref().map(|e| &**e))\n-            }).collect::<Vec<(Vec<P<Pat>>, Option<&hir::Expr>)>>();\n+    fn check_match(\n+        &self,\n+        scrut: &hir::Expr,\n+        arms: &[hir::Arm],\n+        source: hir::MatchSource,\n+        span: Span)\n+    {\n+        for arm in arms {\n+            // First, check legality of move bindings.\n+            self.check_patterns(arm.guard.is_some(), &arm.pats);\n+\n+            // Second, if there is a guard on each arm, make sure it isn't\n+            // assigning or borrowing anything mutably.\n+            if let Some(ref guard) = arm.guard {\n+                check_for_mutation_in_guard(self, &guard);\n+            }\n \n-            // Bail out early if inlining failed.\n-            if static_inliner.failed {\n-                return;\n+            // Third, perform some lints.\n+            for pat in &arm.pats {\n+                check_for_bindings_named_the_same_as_variants(self, pat);\n             }\n+        }\n \n-            for pat in inlined_arms\n-                .iter()\n-                .flat_map(|&(ref pats, _)| pats) {\n-                // Third, check legality of move bindings.\n-                check_legality_of_bindings_in_at_patterns(cx, &pat);\n+        MatchCheckCtxt::create_and_enter(self.tcx, |ref mut cx| {\n+            let mut have_errors = false;\n \n-                // Fourth, check if there are any references to NaN that we should warn about.\n-                check_for_static_nan(cx, &pat);\n+            let inlined_arms : Vec<(Vec<_>, _)> = arms.iter().map(|arm| (\n+                arm.pats.iter().map(|pat| {\n+                    let mut patcx = PatternContext::new(self.tcx);\n+                    let pattern = expand_pattern(cx, patcx.lower_pattern(&pat));\n+                    if !patcx.errors.is_empty() {\n+                        self.report_inlining_errors(patcx, pat.span);\n+                        have_errors = true;\n+                    }\n+                    (pattern, &**pat)\n+                }).collect(),\n+                arm.guard.as_ref().map(|e| &**e)\n+            )).collect();\n \n-                // Fifth, check if for any of the patterns that match an enumerated type\n-                // are bindings with the same name as one of the variants of said type.\n-                check_for_bindings_named_the_same_as_variants(cx, &pat);\n+            // Bail out early if inlining failed.\n+            if have_errors {\n+                return;\n             }\n \n             // Fourth, check for unreachable arms.\n-            check_arms(cx, &inlined_arms[..], source);\n+            check_arms(cx, &inlined_arms, source);\n \n             // Finally, check if the whole match expression is exhaustive.\n             // Check for empty enum, because is_useful only works on inhabited types.\n-            let pat_ty = cx.tcx.node_id_to_type(scrut.id);\n+            let pat_ty = self.tcx.node_id_to_type(scrut.id);\n             if inlined_arms.is_empty() {\n-                if !pat_ty.is_uninhabited(cx.tcx) {\n+                if !pat_ty.is_uninhabited(self.tcx) {\n                     // We know the type is inhabited, so this must be wrong\n-                    let mut err = create_e0004(cx.tcx.sess, ex.span,\n+                    let mut err = create_e0004(self.tcx.sess, span,\n                                                format!(\"non-exhaustive patterns: type {} \\\n                                                         is non-empty\",\n                                                        pat_ty));\n-                    span_help!(&mut err, ex.span,\n-                        \"Please ensure that all possible cases are being handled; \\\n-                         possibly adding wildcards or more match arms.\");\n+                    span_help!(&mut err, span,\n+                               \"Please ensure that all possible cases are being handled; \\\n+                                possibly adding wildcards or more match arms.\");\n                     err.emit();\n                 }\n                 // If the type *is* uninhabited, it's vacuously exhaustive\n@@ -238,15 +222,44 @@ fn check_expr(cx: &mut MatchCheckCtxt, ex: &hir::Expr) {\n                 .iter()\n                 .filter(|&&(_, guard)| guard.is_none())\n                 .flat_map(|arm| &arm.0)\n-                .map(|pat| vec![wrap_pat(cx, &pat)])\n+                .map(|pat| vec![pat.0])\n                 .collect();\n             check_exhaustive(cx, scrut.span, &matrix, source);\n-        },\n-        _ => ()\n+        })\n+    }\n+\n+    fn check_irrefutable(&self, pat: &Pat, is_fn_arg: bool) {\n+        let origin = if is_fn_arg {\n+            \"function argument\"\n+        } else {\n+            \"local binding\"\n+        };\n+\n+        MatchCheckCtxt::create_and_enter(self.tcx, |ref mut cx| {\n+            let mut patcx = PatternContext::new(self.tcx);\n+            let pats : Matrix = vec![vec![\n+                expand_pattern(cx, patcx.lower_pattern(pat))\n+            ]].into_iter().collect();\n+\n+            let witness = match is_useful(cx, &pats, &[cx.wild_pattern], ConstructWitness) {\n+                UsefulWithWitness(witness) => witness,\n+                NotUseful => return,\n+                Useful => bug!()\n+            };\n+\n+            let pattern_string = pat_to_string(witness[0].single_pattern());\n+            let mut diag = struct_span_err!(\n+                self.tcx.sess, pat.span, E0005,\n+                \"refutable pattern in {}: `{}` not covered\",\n+                origin, pattern_string\n+            );\n+            diag.span_label(pat.span, &format!(\"pattern `{}` not covered\", pattern_string));\n+            diag.emit();\n+        });\n     }\n }\n \n-fn check_for_bindings_named_the_same_as_variants(cx: &MatchCheckCtxt, pat: &Pat) {\n+fn check_for_bindings_named_the_same_as_variants(cx: &MatchVisitor, pat: &Pat) {\n     pat.walk(|p| {\n         if let PatKind::Binding(hir::BindByValue(hir::MutImmutable), name, None) = p.node {\n             let pat_ty = cx.tcx.pat_ty(p);\n@@ -275,36 +288,30 @@ fn check_for_bindings_named_the_same_as_variants(cx: &MatchCheckCtxt, pat: &Pat)\n     });\n }\n \n-// Check that we do not match against a static NaN (#6804)\n-fn check_for_static_nan(cx: &MatchCheckCtxt, pat: &Pat) {\n-    pat.walk(|p| {\n-        if let PatKind::Lit(ref expr) = p.node {\n-            match eval_const_expr_partial(cx.tcx, &expr, ExprTypeChecked, None) {\n-                Ok(ConstVal::Float(f)) if f.is_nan() => {\n-                    span_warn!(cx.tcx.sess, p.span, E0003,\n-                               \"unmatchable NaN in pattern, \\\n-                                use the is_nan method in a guard instead\");\n-                }\n-                Ok(_) => {}\n-\n-                Err(err) => {\n-                    report_const_eval_err(cx.tcx, &err, p.span, \"pattern\").emit();\n-                }\n-            }\n-        }\n-        true\n-    });\n+/// Checks for common cases of \"catchall\" patterns that may not be intended as such.\n+fn pat_is_catchall(dm: &DefMap, pat: &Pat) -> bool {\n+    match pat.node {\n+        PatKind::Binding(.., None) => true,\n+        PatKind::Binding(.., Some(ref s)) => pat_is_catchall(dm, s),\n+        PatKind::Ref(ref s, _) => pat_is_catchall(dm, s),\n+        PatKind::Tuple(ref v, _) => v.iter().all(|p| {\n+            pat_is_catchall(dm, &p)\n+        }),\n+        _ => false\n+    }\n }\n \n // Check for unreachable patterns\n-fn check_arms(cx: &MatchCheckCtxt,\n-              arms: &[(Vec<P<Pat>>, Option<&hir::Expr>)],\n-              source: hir::MatchSource) {\n-    let mut seen = Matrix(vec![]);\n+fn check_arms<'a, 'tcx>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n+                        arms: &[(Vec<(&'a Pattern<'tcx>, &hir::Pat)>, Option<&hir::Expr>)],\n+                        source: hir::MatchSource)\n+{\n+    let mut seen = Matrix::empty();\n+    let mut catchall = None;\n     let mut printed_if_let_err = false;\n     for &(ref pats, guard) in arms {\n-        for pat in pats {\n-            let v = vec![wrap_pat(cx, &pat)];\n+        for &(pat, hir_pat) in pats {\n+            let v = vec![pat];\n \n             match is_useful(cx, &seen, &v[..], LeaveOutWitness) {\n                 NotUseful => {\n@@ -317,7 +324,7 @@ fn check_arms(cx: &MatchCheckCtxt,\n                                 // find the first arm pattern so we can use its span\n                                 let &(ref first_arm_pats, _) = &arms[0];\n                                 let first_pat = &first_arm_pats[0];\n-                                let span = first_pat.span;\n+                                let span = first_pat.0.span;\n                                 struct_span_err!(cx.tcx.sess, span, E0162,\n                                                 \"irrefutable if-let pattern\")\n                                     .span_label(span, &format!(\"irrefutable pattern\"))\n@@ -330,7 +337,7 @@ fn check_arms(cx: &MatchCheckCtxt,\n                             // find the first arm pattern so we can use its span\n                             let &(ref first_arm_pats, _) = &arms[0];\n                             let first_pat = &first_arm_pats[0];\n-                            let span = first_pat.span;\n+                            let span = first_pat.0.span;\n                             struct_span_err!(cx.tcx.sess, span, E0165,\n                                              \"irrefutable while-let pattern\")\n                                 .span_label(span, &format!(\"irrefutable pattern\"))\n@@ -348,13 +355,10 @@ fn check_arms(cx: &MatchCheckCtxt,\n                         hir::MatchSource::Normal => {\n                             let mut err = struct_span_err!(cx.tcx.sess, pat.span, E0001,\n                                                            \"unreachable pattern\");\n-                            err.span_label(pat.span, &format!(\"this is an unreachable pattern\"));\n+                            err.span_label(pat.span, &\"this is an unreachable pattern\");\n                             // if we had a catchall pattern, hint at that\n-                            for row in &seen.0 {\n-                                if pat_is_catchall(&cx.tcx.def_map.borrow(), row[0].0) {\n-                                    span_note!(err, row[0].0.span,\n-                                               \"this pattern matches any value\");\n-                                }\n+                            if let Some(catchall) = catchall {\n+                                err.span_note(catchall, \"this pattern matches any value\");\n                             }\n                             err.emit();\n                         },\n@@ -368,42 +372,25 @@ fn check_arms(cx: &MatchCheckCtxt,\n                 UsefulWithWitness(_) => bug!()\n             }\n             if guard.is_none() {\n-                let Matrix(mut rows) = seen;\n-                rows.push(v);\n-                seen = Matrix(rows);\n+                seen.push(v);\n+                if catchall.is_none() && pat_is_catchall(&cx.tcx.def_map.borrow(), hir_pat) {\n+                    catchall = Some(pat.span);\n+                }\n             }\n         }\n     }\n }\n \n-/// Checks for common cases of \"catchall\" patterns that may not be intended as such.\n-fn pat_is_catchall(dm: &DefMap, p: &Pat) -> bool {\n-    match p.node {\n-        PatKind::Binding(.., None) => true,\n-        PatKind::Binding(.., Some(ref s)) => pat_is_catchall(dm, &s),\n-        PatKind::Ref(ref s, _) => pat_is_catchall(dm, &s),\n-        PatKind::Tuple(ref v, _) => v.iter().all(|p| pat_is_catchall(dm, &p)),\n-        _ => false\n-    }\n-}\n-\n-fn raw_pat(p: &Pat) -> &Pat {\n-    match p.node {\n-        PatKind::Binding(.., Some(ref s)) => raw_pat(&s),\n-        _ => p\n-    }\n-}\n-\n-fn check_exhaustive<'a, 'tcx>(cx: &MatchCheckCtxt<'a, 'tcx>,\n+fn check_exhaustive<'a, 'tcx>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n                               sp: Span,\n                               matrix: &Matrix<'a, 'tcx>,\n                               source: hir::MatchSource) {\n-    match is_useful(cx, matrix, &[(DUMMY_WILD_PAT, None)], ConstructWitness) {\n+    match is_useful(cx, matrix, &[cx.wild_pattern], ConstructWitness) {\n         UsefulWithWitness(pats) => {\n             let witnesses = if pats.is_empty() {\n                 vec![DUMMY_WILD_PAT]\n             } else {\n-                pats.iter().map(|w| &**w).collect()\n+                pats.iter().map(|w| w.single_pattern()).collect()\n             };\n             match source {\n                 hir::MatchSource::ForLoopDesugar => {\n@@ -460,664 +447,8 @@ fn check_exhaustive<'a, 'tcx>(cx: &MatchCheckCtxt<'a, 'tcx>,\n     }\n }\n \n-fn const_val_to_expr(value: &ConstVal) -> P<hir::Expr> {\n-    let node = match value {\n-        &ConstVal::Bool(b) => ast::LitKind::Bool(b),\n-        _ => bug!()\n-    };\n-    P(hir::Expr {\n-        id: DUMMY_NODE_ID,\n-        node: hir::ExprLit(P(Spanned { node: node, span: DUMMY_SP })),\n-        span: DUMMY_SP,\n-        attrs: ast::ThinVec::new(),\n-    })\n-}\n-\n-struct StaticInliner<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    failed: bool\n-}\n-\n-impl<'a, 'tcx> StaticInliner<'a, 'tcx> {\n-    pub fn new<'b>(tcx: TyCtxt<'b, 'tcx, 'tcx>) -> StaticInliner<'b, 'tcx> {\n-        StaticInliner {\n-            tcx: tcx,\n-            failed: false\n-        }\n-    }\n-}\n-\n-impl<'a, 'tcx> StaticInliner<'a, 'tcx> {\n-    fn fold_pat(&mut self, pat: P<Pat>) -> P<Pat> {\n-        match pat.node {\n-            PatKind::Path(..) => {\n-                match self.tcx.expect_def(pat.id) {\n-                    Def::AssociatedConst(did) | Def::Const(did) => {\n-                        let substs = Some(self.tcx.node_id_item_substs(pat.id).substs);\n-                        if let Some((const_expr, _)) = lookup_const_by_id(self.tcx, did, substs) {\n-                            match const_expr_to_pat(self.tcx, const_expr, pat.id, pat.span) {\n-                                Ok(new_pat) => return new_pat,\n-                                Err(def_id) => {\n-                                    self.failed = true;\n-                                    self.tcx.sess.span_err(\n-                                        pat.span,\n-                                        &format!(\"constants of the type `{}` \\\n-                                                  cannot be used in patterns\",\n-                                                 self.tcx.item_path_str(def_id)));\n-                                }\n-                            }\n-                        } else {\n-                            self.failed = true;\n-                            span_err!(self.tcx.sess, pat.span, E0158,\n-                                \"statics cannot be referenced in patterns\");\n-                        }\n-                    }\n-                    _ => {}\n-                }\n-            }\n-            _ => {}\n-        }\n-\n-        pat.map(|Pat { id, node, span }| {\n-            let node = match node {\n-                PatKind::Binding(binding_mode, pth1, sub) => {\n-                    PatKind::Binding(binding_mode, pth1, sub.map(|x| self.fold_pat(x)))\n-                }\n-                PatKind::TupleStruct(pth, pats, ddpos) => {\n-                    PatKind::TupleStruct(pth, pats.move_map(|x| self.fold_pat(x)), ddpos)\n-                }\n-                PatKind::Struct(pth, fields, etc) => {\n-                    let fs = fields.move_map(|f| {\n-                        Spanned {\n-                            span: f.span,\n-                            node: hir::FieldPat {\n-                                name: f.node.name,\n-                                pat: self.fold_pat(f.node.pat),\n-                                is_shorthand: f.node.is_shorthand,\n-                            },\n-                        }\n-                    });\n-                    PatKind::Struct(pth, fs, etc)\n-                }\n-                PatKind::Tuple(elts, ddpos) => {\n-                    PatKind::Tuple(elts.move_map(|x| self.fold_pat(x)), ddpos)\n-                }\n-                PatKind::Box(inner) => PatKind::Box(self.fold_pat(inner)),\n-                PatKind::Ref(inner, mutbl) => PatKind::Ref(self.fold_pat(inner), mutbl),\n-                PatKind::Slice(before, slice, after) => {\n-                    PatKind::Slice(before.move_map(|x| self.fold_pat(x)),\n-                                   slice.map(|x| self.fold_pat(x)),\n-                                   after.move_map(|x| self.fold_pat(x)))\n-                }\n-                PatKind::Wild |\n-                PatKind::Lit(_) |\n-                PatKind::Range(..) |\n-                PatKind::Path(..) => node\n-            };\n-            Pat {\n-                id: id,\n-                node: node,\n-                span: span\n-            }\n-        })\n-    }\n-}\n-\n-/// Constructs a partial witness for a pattern given a list of\n-/// patterns expanded by the specialization step.\n-///\n-/// When a pattern P is discovered to be useful, this function is used bottom-up\n-/// to reconstruct a complete witness, e.g. a pattern P' that covers a subset\n-/// of values, V, where each value in that set is not covered by any previously\n-/// used patterns and is covered by the pattern P'. Examples:\n-///\n-/// left_ty: tuple of 3 elements\n-/// pats: [10, 20, _]           => (10, 20, _)\n-///\n-/// left_ty: struct X { a: (bool, &'static str), b: usize}\n-/// pats: [(false, \"foo\"), 42]  => X { a: (false, \"foo\"), b: 42 }\n-fn construct_witness<'a,'tcx>(cx: &MatchCheckCtxt<'a,'tcx>, ctor: &Constructor,\n-                              pats: Vec<&Pat>, left_ty: Ty<'tcx>) -> P<Pat> {\n-    let pats_len = pats.len();\n-    let mut pats = pats.into_iter().map(|p| P((*p).clone()));\n-    let pat = match left_ty.sty {\n-        ty::TyTuple(..) => PatKind::Tuple(pats.collect(), None),\n-\n-        ty::TyAdt(adt, _) => {\n-            let v = ctor.variant_for_adt(adt);\n-            match v.ctor_kind {\n-                CtorKind::Fictive => {\n-                    let field_pats: hir::HirVec<_> = v.fields.iter()\n-                        .zip(pats)\n-                        .filter(|&(_, ref pat)| pat.node != PatKind::Wild)\n-                        .map(|(field, pat)| Spanned {\n-                            span: DUMMY_SP,\n-                            node: hir::FieldPat {\n-                                name: field.name,\n-                                pat: pat,\n-                                is_shorthand: false,\n-                            }\n-                        }).collect();\n-                    let has_more_fields = field_pats.len() < pats_len;\n-                    PatKind::Struct(def_to_path(cx.tcx, v.did), field_pats, has_more_fields)\n-                }\n-                CtorKind::Fn => {\n-                    PatKind::TupleStruct(def_to_path(cx.tcx, v.did), pats.collect(), None)\n-                }\n-                CtorKind::Const => {\n-                    PatKind::Path(None, def_to_path(cx.tcx, v.did))\n-                }\n-            }\n-        }\n-\n-        ty::TyRef(_, ty::TypeAndMut { mutbl, .. }) => {\n-            assert_eq!(pats_len, 1);\n-            PatKind::Ref(pats.nth(0).unwrap(), mutbl)\n-        }\n-\n-        ty::TySlice(_) => match ctor {\n-            &Slice(n) => {\n-                assert_eq!(pats_len, n);\n-                PatKind::Slice(pats.collect(), None, hir::HirVec::new())\n-            },\n-            _ => unreachable!()\n-        },\n-\n-        ty::TyArray(_, len) => {\n-            assert_eq!(pats_len, len);\n-            PatKind::Slice(pats.collect(), None, hir::HirVec::new())\n-        }\n-\n-        _ => {\n-            match *ctor {\n-                ConstantValue(ref v) => PatKind::Lit(const_val_to_expr(v)),\n-                _ => PatKind::Wild,\n-            }\n-        }\n-    };\n-\n-    P(hir::Pat {\n-        id: DUMMY_NODE_ID,\n-        node: pat,\n-        span: DUMMY_SP\n-    })\n-}\n-\n-impl Constructor {\n-    fn variant_for_adt<'tcx, 'container, 'a>(&self,\n-                                             adt: &'a ty::AdtDefData<'tcx, 'container>)\n-                                             -> &'a ty::VariantDefData<'tcx, 'container> {\n-        match self {\n-            &Variant(vid) => adt.variant_with_id(vid),\n-            _ => adt.struct_variant()\n-        }\n-    }\n-}\n-\n-fn missing_constructors(cx: &MatchCheckCtxt, &Matrix(ref rows): &Matrix,\n-                       left_ty: Ty, max_slice_length: usize) -> Vec<Constructor> {\n-    let used_constructors: Vec<Constructor> = rows.iter()\n-        .flat_map(|row| pat_constructors(cx, row[0].0, left_ty, max_slice_length))\n-        .collect();\n-    all_constructors(cx, left_ty, max_slice_length)\n-        .into_iter()\n-        .filter(|c| !used_constructors.contains(c))\n-        .collect()\n-}\n-\n-/// This determines the set of all possible constructors of a pattern matching\n-/// values of type `left_ty`. For vectors, this would normally be an infinite set\n-/// but is instead bounded by the maximum fixed length of slice patterns in\n-/// the column of patterns being analyzed.\n-fn all_constructors(_cx: &MatchCheckCtxt, left_ty: Ty,\n-                    max_slice_length: usize) -> Vec<Constructor> {\n-    match left_ty.sty {\n-        ty::TyBool =>\n-            [true, false].iter().map(|b| ConstantValue(ConstVal::Bool(*b))).collect(),\n-        ty::TySlice(_) =>\n-            (0..max_slice_length+1).map(|length| Slice(length)).collect(),\n-        ty::TyAdt(def, _) if def.is_enum() =>\n-            def.variants.iter().map(|v| Variant(v.did)).collect(),\n-        _ => vec![Single]\n-    }\n-}\n-\n-// Algorithm from http://moscova.inria.fr/~maranget/papers/warn/index.html\n-//\n-// Whether a vector `v` of patterns is 'useful' in relation to a set of such\n-// vectors `m` is defined as there being a set of inputs that will match `v`\n-// but not any of the sets in `m`.\n-//\n-// This is used both for reachability checking (if a pattern isn't useful in\n-// relation to preceding patterns, it is not reachable) and exhaustiveness\n-// checking (if a wildcard pattern is useful in relation to a matrix, the\n-// matrix isn't exhaustive).\n-\n-// Note: is_useful doesn't work on empty types, as the paper notes.\n-// So it assumes that v is non-empty.\n-fn is_useful<'a, 'tcx>(cx: &MatchCheckCtxt<'a, 'tcx>,\n-                       matrix: &Matrix<'a, 'tcx>,\n-                       v: &[(&Pat, Option<Ty<'tcx>>)],\n-                       witness: WitnessPreference)\n-                       -> Usefulness {\n-    let &Matrix(ref rows) = matrix;\n-    debug!(\"is_useful({:?}, {:?})\", matrix, v);\n-    if rows.is_empty() {\n-        return match witness {\n-            ConstructWitness => UsefulWithWitness(vec!()),\n-            LeaveOutWitness => Useful\n-        };\n-    }\n-    if rows[0].is_empty() {\n-        return NotUseful;\n-    }\n-    assert!(rows.iter().all(|r| r.len() == v.len()));\n-    let left_ty = match rows.iter().filter_map(|r| r[0].1).next().or_else(|| v[0].1) {\n-        Some(ty) => ty,\n-        None => {\n-            // all patterns are wildcards - we can pick any type we want\n-            cx.tcx.types.bool\n-        }\n-    };\n-\n-    let max_slice_length = rows.iter().filter_map(|row| match row[0].0.node {\n-        PatKind::Slice(ref before, _, ref after) => Some(before.len() + after.len()),\n-        _ => None\n-    }).max().map_or(0, |v| v + 1);\n-\n-    let constructors = pat_constructors(cx, v[0].0, left_ty, max_slice_length);\n-    debug!(\"is_useful - pat_constructors = {:?} left_ty = {:?}\", constructors,\n-           left_ty);\n-    if constructors.is_empty() {\n-        let constructors = missing_constructors(cx, matrix, left_ty, max_slice_length);\n-        debug!(\"is_useful - missing_constructors = {:?}\", constructors);\n-        if constructors.is_empty() {\n-            all_constructors(cx, left_ty, max_slice_length).into_iter().map(|c| {\n-                match is_useful_specialized(cx, matrix, v, c.clone(), left_ty, witness) {\n-                    UsefulWithWitness(pats) => UsefulWithWitness({\n-                        let arity = constructor_arity(cx, &c, left_ty);\n-                        let mut result = {\n-                            let pat_slice = &pats[..];\n-                            let subpats: Vec<_> = (0..arity).map(|i| {\n-                                pat_slice.get(i).map_or(DUMMY_WILD_PAT, |p| &**p)\n-                            }).collect();\n-                            vec![construct_witness(cx, &c, subpats, left_ty)]\n-                        };\n-                        result.extend(pats.into_iter().skip(arity));\n-                        result\n-                    }),\n-                    result => result\n-                }\n-            }).find(|result| result != &NotUseful).unwrap_or(NotUseful)\n-        } else {\n-            let matrix = rows.iter().filter_map(|r| {\n-                match raw_pat(r[0].0).node {\n-                    PatKind::Binding(..) | PatKind::Wild => Some(r[1..].to_vec()),\n-                    _ => None,\n-                }\n-            }).collect();\n-            match is_useful(cx, &matrix, &v[1..], witness) {\n-                UsefulWithWitness(pats) => {\n-                    let mut new_pats: Vec<_> = constructors.into_iter().map(|constructor| {\n-                        let arity = constructor_arity(cx, &constructor, left_ty);\n-                        let wild_pats = vec![DUMMY_WILD_PAT; arity];\n-                        construct_witness(cx, &constructor, wild_pats, left_ty)\n-                    }).collect();\n-                    new_pats.extend(pats);\n-                    UsefulWithWitness(new_pats)\n-                },\n-                result => result\n-            }\n-        }\n-    } else {\n-        constructors.into_iter().map(|c|\n-            is_useful_specialized(cx, matrix, v, c.clone(), left_ty, witness)\n-        ).find(|result| result != &NotUseful).unwrap_or(NotUseful)\n-    }\n-}\n-\n-fn is_useful_specialized<'a, 'tcx>(\n-    cx: &MatchCheckCtxt<'a, 'tcx>,\n-    &Matrix(ref m): &Matrix<'a, 'tcx>,\n-    v: &[(&Pat, Option<Ty<'tcx>>)],\n-    ctor: Constructor,\n-    lty: Ty<'tcx>,\n-    witness: WitnessPreference) -> Usefulness\n-{\n-    let arity = constructor_arity(cx, &ctor, lty);\n-    let matrix = Matrix(m.iter().filter_map(|r| {\n-        specialize(cx, &r[..], &ctor, 0, arity)\n-    }).collect());\n-    match specialize(cx, v, &ctor, 0, arity) {\n-        Some(v) => is_useful(cx, &matrix, &v[..], witness),\n-        None => NotUseful\n-    }\n-}\n-\n-/// Determines the constructors that the given pattern can be specialized to.\n-///\n-/// In most cases, there's only one constructor that a specific pattern\n-/// represents, such as a specific enum variant or a specific literal value.\n-/// Slice patterns, however, can match slices of different lengths. For instance,\n-/// `[a, b, ..tail]` can match a slice of length 2, 3, 4 and so on.\n-///\n-/// On the other hand, a wild pattern and an identifier pattern cannot be\n-/// specialized in any way.\n-fn pat_constructors(cx: &MatchCheckCtxt, p: &Pat,\n-                    left_ty: Ty, max_slice_length: usize) -> Vec<Constructor> {\n-    let pat = raw_pat(p);\n-    match pat.node {\n-        PatKind::Struct(..) | PatKind::TupleStruct(..) | PatKind::Path(..) =>\n-            match cx.tcx.expect_def(pat.id) {\n-                Def::Variant(id) | Def::VariantCtor(id, ..) => vec![Variant(id)],\n-                Def::Struct(..) | Def::StructCtor(..) | Def::Union(..) |\n-                Def::TyAlias(..) | Def::AssociatedTy(..) => vec![Single],\n-                Def::Const(..) | Def::AssociatedConst(..) =>\n-                    span_bug!(pat.span, \"const pattern should've been rewritten\"),\n-                def => span_bug!(pat.span, \"pat_constructors: unexpected definition {:?}\", def),\n-            },\n-        PatKind::Lit(ref expr) =>\n-            vec![ConstantValue(eval_const_expr(cx.tcx, &expr))],\n-        PatKind::Range(ref lo, ref hi) =>\n-            vec![ConstantRange(eval_const_expr(cx.tcx, &lo), eval_const_expr(cx.tcx, &hi))],\n-        PatKind::Slice(ref before, ref slice, ref after) =>\n-            match left_ty.sty {\n-                ty::TyArray(..) => vec![Single],\n-                ty::TySlice(_) if slice.is_some() => {\n-                    (before.len() + after.len()..max_slice_length+1)\n-                        .map(|length| Slice(length))\n-                        .collect()\n-                }\n-                ty::TySlice(_) => vec!(Slice(before.len() + after.len())),\n-                _ => span_bug!(pat.span, \"pat_constructors: unexpected \\\n-                                          slice pattern type {:?}\", left_ty)\n-            },\n-        PatKind::Box(..) | PatKind::Tuple(..) | PatKind::Ref(..) =>\n-            vec![Single],\n-        PatKind::Binding(..) | PatKind::Wild =>\n-            vec![],\n-    }\n-}\n-\n-/// This computes the arity of a constructor. The arity of a constructor\n-/// is how many subpattern patterns of that constructor should be expanded to.\n-///\n-/// For instance, a tuple pattern (_, 42, Some([])) has the arity of 3.\n-/// A struct pattern's arity is the number of fields it contains, etc.\n-pub fn constructor_arity(_cx: &MatchCheckCtxt, ctor: &Constructor, ty: Ty) -> usize {\n-    debug!(\"constructor_arity({:?}, {:?})\", ctor, ty);\n-    match ty.sty {\n-        ty::TyTuple(ref fs) => fs.len(),\n-        ty::TyBox(_) => 1,\n-        ty::TySlice(_) => match *ctor {\n-            Slice(length) => length,\n-            ConstantValue(_) => 0,\n-            _ => bug!()\n-        },\n-        ty::TyRef(..) => 1,\n-        ty::TyAdt(adt, _) => {\n-            ctor.variant_for_adt(adt).fields.len()\n-        }\n-        ty::TyArray(_, n) => n,\n-        _ => 0\n-    }\n-}\n-\n-fn range_covered_by_constructor(tcx: TyCtxt, span: Span,\n-                                ctor: &Constructor,\n-                                from: &ConstVal, to: &ConstVal)\n-                                -> Result<bool, ErrorReported> {\n-    let (c_from, c_to) = match *ctor {\n-        ConstantValue(ref value)        => (value, value),\n-        ConstantRange(ref from, ref to) => (from, to),\n-        Single                          => return Ok(true),\n-        _                               => bug!()\n-    };\n-    let cmp_from = compare_const_vals(tcx, span, c_from, from)?;\n-    let cmp_to = compare_const_vals(tcx, span, c_to, to)?;\n-    Ok(cmp_from != Ordering::Less && cmp_to != Ordering::Greater)\n-}\n-\n-fn wrap_pat<'a, 'b, 'tcx>(cx: &MatchCheckCtxt<'b, 'tcx>,\n-                          pat: &'a Pat)\n-                          -> (&'a Pat, Option<Ty<'tcx>>)\n-{\n-    let pat_ty = cx.tcx.pat_ty(pat);\n-    (pat, Some(match pat.node {\n-        PatKind::Binding(hir::BindByRef(..), ..) => {\n-            pat_ty.builtin_deref(false, ty::NoPreference).unwrap().ty\n-        }\n-        _ => pat_ty\n-    }))\n-}\n-\n-/// This is the main specialization step. It expands the first pattern in the given row\n-/// into `arity` patterns based on the constructor. For most patterns, the step is trivial,\n-/// for instance tuple patterns are flattened and box patterns expand into their inner pattern.\n-///\n-/// OTOH, slice patterns with a subslice pattern (..tail) can be expanded into multiple\n-/// different patterns.\n-/// Structure patterns with a partial wild pattern (Foo { a: 42, .. }) have their missing\n-/// fields filled with wild patterns.\n-pub fn specialize<'a, 'b, 'tcx>(\n-    cx: &MatchCheckCtxt<'b, 'tcx>,\n-    r: &[(&'a Pat, Option<Ty<'tcx>>)],\n-    constructor: &Constructor, col: usize, arity: usize)\n-    -> Option<Vec<(&'a Pat, Option<Ty<'tcx>>)>>\n-{\n-    let pat = raw_pat(r[col].0);\n-    let &Pat {\n-        id: pat_id, ref node, span: pat_span\n-    } = pat;\n-    let wpat = |pat: &'a Pat| wrap_pat(cx, pat);\n-    let dummy_pat = (DUMMY_WILD_PAT, None);\n-\n-    let head: Option<Vec<(&Pat, Option<Ty>)>> = match *node {\n-        PatKind::Binding(..) | PatKind::Wild =>\n-            Some(vec![dummy_pat; arity]),\n-\n-        PatKind::Path(..) => {\n-            match cx.tcx.expect_def(pat_id) {\n-                Def::Const(..) | Def::AssociatedConst(..) =>\n-                    span_bug!(pat_span, \"const pattern should've \\\n-                                         been rewritten\"),\n-                Def::VariantCtor(id, CtorKind::Const) if *constructor != Variant(id) => None,\n-                Def::VariantCtor(_, CtorKind::Const) |\n-                Def::StructCtor(_, CtorKind::Const) => Some(Vec::new()),\n-                def => span_bug!(pat_span, \"specialize: unexpected definition: {:?}\", def),\n-            }\n-        }\n-\n-        PatKind::TupleStruct(_, ref args, ddpos) => {\n-            match cx.tcx.expect_def(pat_id) {\n-                Def::Const(..) | Def::AssociatedConst(..) =>\n-                    span_bug!(pat_span, \"const pattern should've \\\n-                                         been rewritten\"),\n-                Def::VariantCtor(id, CtorKind::Fn) if *constructor != Variant(id) => None,\n-                Def::VariantCtor(_, CtorKind::Fn) |\n-                Def::StructCtor(_, CtorKind::Fn) => {\n-                    match ddpos {\n-                        Some(ddpos) => {\n-                            let mut pats: Vec<_> = args[..ddpos].iter().map(|p| {\n-                                wpat(p)\n-                            }).collect();\n-                            pats.extend(repeat((DUMMY_WILD_PAT, None)).take(arity - args.len()));\n-                            pats.extend(args[ddpos..].iter().map(|p| wpat(p)));\n-                            Some(pats)\n-                        }\n-                        None => Some(args.iter().map(|p| wpat(p)).collect())\n-                    }\n-                }\n-                def => span_bug!(pat_span, \"specialize: unexpected definition: {:?}\", def),\n-            }\n-        }\n-\n-        PatKind::Struct(_, ref pattern_fields, _) => {\n-            let adt = cx.tcx.node_id_to_type(pat_id).ty_adt_def().unwrap();\n-            let variant = constructor.variant_for_adt(adt);\n-            let def_variant = adt.variant_of_def(cx.tcx.expect_def(pat_id));\n-            if variant.did == def_variant.did {\n-                Some(variant.fields.iter().map(|sf| {\n-                    match pattern_fields.iter().find(|f| f.node.name == sf.name) {\n-                        Some(ref f) => wpat(&f.node.pat),\n-                        _ => dummy_pat\n-                    }\n-                }).collect())\n-            } else {\n-                None\n-            }\n-        }\n-\n-        PatKind::Tuple(ref args, Some(ddpos)) => {\n-            let mut pats: Vec<_> = args[..ddpos].iter().map(|p| wpat(p)).collect();\n-            pats.extend(repeat(dummy_pat).take(arity - args.len()));\n-            pats.extend(args[ddpos..].iter().map(|p| wpat(p)));\n-            Some(pats)\n-        }\n-        PatKind::Tuple(ref args, None) =>\n-            Some(args.iter().map(|p| wpat(&**p)).collect()),\n-\n-        PatKind::Box(ref inner) | PatKind::Ref(ref inner, _) =>\n-            Some(vec![wpat(&**inner)]),\n-\n-        PatKind::Lit(ref expr) => {\n-            if let Some(&ty::TyS { sty: ty::TyRef(_, mt), .. }) = r[col].1 {\n-                // HACK: handle string literals. A string literal pattern\n-                // serves both as an unary reference pattern and as a\n-                // nullary value pattern, depending on the type.\n-                Some(vec![(pat, Some(mt.ty))])\n-            } else {\n-                let expr_value = eval_const_expr(cx.tcx, &expr);\n-                match range_covered_by_constructor(\n-                    cx.tcx, expr.span, constructor, &expr_value, &expr_value\n-                ) {\n-                    Ok(true) => Some(vec![]),\n-                    Ok(false) => None,\n-                    Err(ErrorReported) => None,\n-                }\n-            }\n-        }\n-\n-        PatKind::Range(ref from, ref to) => {\n-            let from_value = eval_const_expr(cx.tcx, &from);\n-            let to_value = eval_const_expr(cx.tcx, &to);\n-            match range_covered_by_constructor(\n-                cx.tcx, pat_span, constructor, &from_value, &to_value\n-            ) {\n-                Ok(true) => Some(vec![]),\n-                Ok(false) => None,\n-                Err(ErrorReported) => None,\n-            }\n-        }\n-\n-        PatKind::Slice(ref before, ref slice, ref after) => {\n-            let pat_len = before.len() + after.len();\n-            match *constructor {\n-                Single => {\n-                    // Fixed-length vectors.\n-                    Some(\n-                        before.iter().map(|p| wpat(p)).chain(\n-                        repeat(dummy_pat).take(arity - pat_len).chain(\n-                        after.iter().map(|p| wpat(p))\n-                    )).collect())\n-                },\n-                Slice(length) if pat_len <= length && slice.is_some() => {\n-                    Some(\n-                        before.iter().map(|p| wpat(p)).chain(\n-                        repeat(dummy_pat).take(arity - pat_len).chain(\n-                        after.iter().map(|p| wpat(p))\n-                    )).collect())\n-                }\n-                Slice(length) if pat_len == length => {\n-                    Some(\n-                        before.iter().map(|p| wpat(p)).chain(\n-                        after.iter().map(|p| wpat(p))\n-                    ).collect())\n-                }\n-                SliceWithSubslice(prefix, suffix)\n-                    if before.len() == prefix\n-                        && after.len() == suffix\n-                        && slice.is_some() => {\n-                    // this is used by trans::_match only\n-                    let mut pats: Vec<_> = before.iter()\n-                        .map(|p| (&**p, None)).collect();\n-                    pats.extend(after.iter().map(|p| (&**p, None)));\n-                    Some(pats)\n-                }\n-                _ => None\n-            }\n-        }\n-    };\n-    debug!(\"specialize({:?}, {:?}) = {:?}\", r[col], arity, head);\n-\n-    head.map(|mut head| {\n-        head.extend_from_slice(&r[..col]);\n-        head.extend_from_slice(&r[col + 1..]);\n-        head\n-    })\n-}\n-\n-fn check_local(cx: &mut MatchCheckCtxt, loc: &hir::Local) {\n-    intravisit::walk_local(cx, loc);\n-\n-    let pat = StaticInliner::new(cx.tcx).fold_pat(loc.pat.clone());\n-    check_irrefutable(cx, &pat, false);\n-\n-    // Check legality of move bindings and `@` patterns.\n-    check_legality_of_move_bindings(cx, false, slice::ref_slice(&loc.pat));\n-    check_legality_of_bindings_in_at_patterns(cx, &loc.pat);\n-}\n-\n-fn check_fn(cx: &mut MatchCheckCtxt,\n-            kind: FnKind,\n-            decl: &hir::FnDecl,\n-            body: &hir::Block,\n-            sp: Span,\n-            fn_id: NodeId) {\n-    match kind {\n-        FnKind::Closure(_) => {}\n-        _ => cx.param_env = ty::ParameterEnvironment::for_item(cx.tcx, fn_id),\n-    }\n-\n-    intravisit::walk_fn(cx, kind, decl, body, sp, fn_id);\n-\n-    for input in &decl.inputs {\n-        check_irrefutable(cx, &input.pat, true);\n-        check_legality_of_move_bindings(cx, false, slice::ref_slice(&input.pat));\n-        check_legality_of_bindings_in_at_patterns(cx, &input.pat);\n-    }\n-}\n-\n-fn check_irrefutable(cx: &MatchCheckCtxt, pat: &Pat, is_fn_arg: bool) {\n-    let origin = if is_fn_arg {\n-        \"function argument\"\n-    } else {\n-        \"local binding\"\n-    };\n-\n-    is_refutable(cx, pat, |uncovered_pat| {\n-        let pattern_string = pat_to_string(uncovered_pat);\n-        struct_span_err!(cx.tcx.sess, pat.span, E0005,\n-            \"refutable pattern in {}: `{}` not covered\",\n-            origin,\n-            pattern_string,\n-        ).span_label(pat.span, &format!(\"pattern `{}` not covered\", pattern_string)).emit();\n-    });\n-}\n-\n-fn is_refutable<A, F>(cx: &MatchCheckCtxt, pat: &Pat, refutable: F) -> Option<A> where\n-    F: FnOnce(&Pat) -> A,\n-{\n-    let pats = Matrix(vec!(vec!(wrap_pat(cx, pat))));\n-    match is_useful(cx, &pats, &[(DUMMY_WILD_PAT, None)], ConstructWitness) {\n-        UsefulWithWitness(pats) => Some(refutable(&pats[0])),\n-        NotUseful => None,\n-        Useful => bug!()\n-    }\n-}\n-\n // Legality of move bindings checking\n-fn check_legality_of_move_bindings(cx: &MatchCheckCtxt,\n+fn check_legality_of_move_bindings(cx: &MatchVisitor,\n                                    has_guard: bool,\n                                    pats: &[P<Pat>]) {\n     let mut by_ref_span = None;\n@@ -1156,13 +487,9 @@ fn check_legality_of_move_bindings(cx: &MatchCheckCtxt,\n         pat.walk(|p| {\n             if let PatKind::Binding(hir::BindByValue(..), _, ref sub) = p.node {\n                 let pat_ty = cx.tcx.node_id_to_type(p.id);\n-                //FIXME: (@jroesch) this code should be floated up as well\n-                cx.tcx.infer_ctxt(None, Some(cx.param_env.clone()),\n-                                  Reveal::NotSpecializable).enter(|infcx| {\n-                    if infcx.type_moves_by_default(pat_ty, pat.span) {\n-                        check_move(p, sub.as_ref().map(|p| &**p));\n-                    }\n-                });\n+                if pat_ty.moves_by_default(cx.tcx, cx.param_env, pat.span) {\n+                    check_move(p, sub.as_ref().map(|p| &**p));\n+                }\n             }\n             true\n         });\n@@ -1171,8 +498,9 @@ fn check_legality_of_move_bindings(cx: &MatchCheckCtxt,\n \n /// Ensures that a pattern guard doesn't borrow by mutable reference or\n /// assign.\n-fn check_for_mutation_in_guard<'a, 'tcx>(cx: &'a MatchCheckCtxt<'a, 'tcx>,\n-                                         guard: &hir::Expr) {\n+///\n+/// FIXME: this should be done by borrowck.\n+fn check_for_mutation_in_guard(cx: &MatchVisitor, guard: &hir::Expr) {\n     cx.tcx.infer_ctxt(None, Some(cx.param_env.clone()),\n                       Reveal::NotSpecializable).enter(|infcx| {\n         let mut checker = MutationChecker {\n@@ -1184,15 +512,15 @@ fn check_for_mutation_in_guard<'a, 'tcx>(cx: &'a MatchCheckCtxt<'a, 'tcx>,\n }\n \n struct MutationChecker<'a, 'gcx: 'a> {\n-    cx: &'a MatchCheckCtxt<'a, 'gcx>,\n+    cx: &'a MatchVisitor<'a, 'gcx>,\n }\n \n impl<'a, 'gcx, 'tcx> Delegate<'tcx> for MutationChecker<'a, 'gcx> {\n     fn matched_pat(&mut self, _: &Pat, _: cmt, _: euv::MatchMode) {}\n-    fn consume(&mut self, _: NodeId, _: Span, _: cmt, _: ConsumeMode) {}\n+    fn consume(&mut self, _: ast::NodeId, _: Span, _: cmt, _: ConsumeMode) {}\n     fn consume_pat(&mut self, _: &Pat, _: cmt, _: ConsumeMode) {}\n     fn borrow(&mut self,\n-              _: NodeId,\n+              _: ast::NodeId,\n               span: Span,\n               _: cmt,\n               _: &'tcx ty::Region,\n@@ -1208,8 +536,8 @@ impl<'a, 'gcx, 'tcx> Delegate<'tcx> for MutationChecker<'a, 'gcx> {\n             ty::ImmBorrow | ty::UniqueImmBorrow => {}\n         }\n     }\n-    fn decl_without_init(&mut self, _: NodeId, _: Span) {}\n-    fn mutate(&mut self, _: NodeId, span: Span, _: cmt, mode: MutateMode) {\n+    fn decl_without_init(&mut self, _: ast::NodeId, _: Span) {}\n+    fn mutate(&mut self, _: ast::NodeId, span: Span, _: cmt, mode: MutateMode) {\n         match mode {\n             MutateMode::JustWrite | MutateMode::WriteAndRead => {\n                 struct_span_err!(self.cx.tcx.sess, span, E0302, \"cannot assign in a pattern guard\")\n@@ -1224,12 +552,12 @@ impl<'a, 'gcx, 'tcx> Delegate<'tcx> for MutationChecker<'a, 'gcx> {\n /// Forbids bindings in `@` patterns. This is necessary for memory safety,\n /// because of the way rvalues are handled in the borrow check. (See issue\n /// #14587.)\n-fn check_legality_of_bindings_in_at_patterns(cx: &MatchCheckCtxt, pat: &Pat) {\n+fn check_legality_of_bindings_in_at_patterns(cx: &MatchVisitor, pat: &Pat) {\n     AtBindingPatternVisitor { cx: cx, bindings_allowed: true }.visit_pat(pat);\n }\n \n struct AtBindingPatternVisitor<'a, 'b:'a, 'tcx:'b> {\n-    cx: &'a MatchCheckCtxt<'b, 'tcx>,\n+    cx: &'a MatchVisitor<'b, 'tcx>,\n     bindings_allowed: bool\n }\n "}, {"sha": "f70583db70a60e483c1f8b145f631fac99c793d4", "filename": "src/librustc_const_eval/diagnostics.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4a584637b0081c96c53c6048fd3715912c94a59b/src%2Flibrustc_const_eval%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a584637b0081c96c53c6048fd3715912c94a59b/src%2Flibrustc_const_eval%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fdiagnostics.rs?ref=4a584637b0081c96c53c6048fd3715912c94a59b", "patch": "@@ -40,7 +40,7 @@ Ensure the ordering of the match arm is correct and remove any superfluous\n arms.\n \"##,\n \n-E0002: r##\"\n+/*E0002: r##\"\n This error indicates that an empty match expression is invalid because the type\n it is matching on is non-empty (there exist values of this type). In safe code\n it is impossible to create an instance of an empty type, so empty match\n@@ -68,10 +68,10 @@ fn foo(x: Option<String>) {\n     }\n }\n ```\n-\"##,\n+\"##,*/\n \n \n-E0003: r##\"\n+/*E0003: r##\"\n Not-a-Number (NaN) values cannot be compared for equality and hence can never\n match the input to a match expression. So, the following will not compile:\n \n@@ -100,7 +100,7 @@ match number {\n }\n ```\n \"##,\n-\n+*/\n \n E0004: r##\"\n This error indicates that the compiler cannot guarantee a matching pattern for"}, {"sha": "c02cca0da72255e5662fff0eda1086dfe1693517", "filename": "src/librustc_const_eval/eval.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4a584637b0081c96c53c6048fd3715912c94a59b/src%2Flibrustc_const_eval%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a584637b0081c96c53c6048fd3715912c94a59b/src%2Flibrustc_const_eval%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Feval.rs?ref=4a584637b0081c96c53c6048fd3715912c94a59b", "patch": "@@ -392,7 +392,7 @@ pub fn note_const_eval_err<'a, 'tcx>(\n \n pub fn eval_const_expr<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                  e: &Expr) -> ConstVal {\n-    match eval_const_expr_partial(tcx, e, ExprTypeChecked, None) {\n+    match eval_const_expr_checked(tcx, e) {\n         Ok(r) => r,\n         // non-const path still needs to be a fatal error, because enums are funky\n         Err(s) => {\n@@ -407,15 +407,21 @@ pub fn eval_const_expr<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n }\n \n+pub fn eval_const_expr_checked<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                         e: &Expr) -> EvalResult\n+{\n+    eval_const_expr_partial(tcx, e, ExprTypeChecked, None)\n+}\n+\n pub type FnArgMap<'a> = Option<&'a NodeMap<ConstVal>>;\n \n-#[derive(Clone)]\n+#[derive(Clone, Debug)]\n pub struct ConstEvalErr {\n     pub span: Span,\n     pub kind: ErrKind,\n }\n \n-#[derive(Clone)]\n+#[derive(Clone, Debug)]\n pub enum ErrKind {\n     CannotCast,\n     CannotCastTo(&'static str),"}, {"sha": "1a07ece044ff21bea29ffa9cf456a24483f6018b", "filename": "src/librustc_const_eval/lib.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4a584637b0081c96c53c6048fd3715912c94a59b/src%2Flibrustc_const_eval%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a584637b0081c96c53c6048fd3715912c94a59b/src%2Flibrustc_const_eval%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Flib.rs?ref=4a584637b0081c96c53c6048fd3715912c94a59b", "patch": "@@ -31,11 +31,13 @@\n #![feature(box_patterns)]\n #![feature(box_syntax)]\n \n+extern crate arena;\n #[macro_use] extern crate syntax;\n #[macro_use] extern crate log;\n #[macro_use] extern crate rustc;\n extern crate rustc_back;\n extern crate rustc_const_math;\n+extern crate rustc_data_structures;\n extern crate rustc_errors;\n extern crate graphviz;\n extern crate syntax_pos;\n@@ -46,7 +48,9 @@ extern crate serialize as rustc_serialize; // used by deriving\n pub mod diagnostics;\n \n mod eval;\n+mod _match;\n pub mod check_match;\n+pub mod pattern;\n \n pub use eval::*;\n "}, {"sha": "a6c886533c86cba73fa6b770a9d5b091c43b9306", "filename": "src/librustc_const_eval/pattern.rs", "status": "added", "additions": 612, "deletions": 0, "changes": 612, "blob_url": "https://github.com/rust-lang/rust/blob/4a584637b0081c96c53c6048fd3715912c94a59b/src%2Flibrustc_const_eval%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a584637b0081c96c53c6048fd3715912c94a59b/src%2Flibrustc_const_eval%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fpattern.rs?ref=4a584637b0081c96c53c6048fd3715912c94a59b", "patch": "@@ -0,0 +1,612 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use eval;\n+\n+use rustc::middle::const_val::ConstVal;\n+use rustc::mir::repr::{Field, BorrowKind, Mutability};\n+use rustc::ty::{self, TyCtxt, AdtDef, Ty, Region};\n+use rustc::hir::{self, PatKind};\n+use rustc::hir::def::Def;\n+use rustc::hir::def_id::DefId;\n+use rustc::hir::pat_util::EnumerateAndAdjustIterator;\n+\n+use rustc_data_structures::indexed_vec::Idx;\n+\n+use syntax::ast;\n+use syntax::ptr::P;\n+use syntax_pos::Span;\n+\n+#[derive(Clone, Debug)]\n+pub enum PatternError {\n+    StaticInPattern(Span),\n+    BadConstInPattern(Span, DefId),\n+    ConstEval(eval::ConstEvalErr),\n+}\n+\n+#[derive(Copy, Clone, Debug)]\n+pub enum BindingMode<'tcx> {\n+    ByValue,\n+    ByRef(&'tcx Region, BorrowKind),\n+}\n+\n+#[derive(Clone, Debug)]\n+pub struct FieldPattern<'tcx> {\n+    pub field: Field,\n+    pub pattern: Pattern<'tcx>,\n+}\n+\n+#[derive(Clone, Debug)]\n+pub struct Pattern<'tcx> {\n+    pub ty: Ty<'tcx>,\n+    pub span: Span,\n+    pub kind: Box<PatternKind<'tcx>>,\n+}\n+\n+#[derive(Clone, Debug)]\n+pub enum PatternKind<'tcx> {\n+    Wild,\n+\n+    /// x, ref x, x @ P, etc\n+    Binding {\n+        mutability: Mutability,\n+        name: ast::Name,\n+        mode: BindingMode<'tcx>,\n+        var: ast::NodeId,\n+        ty: Ty<'tcx>,\n+        subpattern: Option<Pattern<'tcx>>,\n+    },\n+\n+    /// Foo(...) or Foo{...} or Foo, where `Foo` is a variant name from an adt with >1 variants\n+    Variant {\n+        adt_def: AdtDef<'tcx>,\n+        variant_index: usize,\n+        subpatterns: Vec<FieldPattern<'tcx>>,\n+    },\n+\n+    /// (...), Foo(...), Foo{...}, or Foo, where `Foo` is a variant name from an adt with 1 variant\n+    Leaf {\n+        subpatterns: Vec<FieldPattern<'tcx>>,\n+    },\n+\n+    /// box P, &P, &mut P, etc\n+    Deref {\n+        subpattern: Pattern<'tcx>,\n+    },\n+\n+    Constant {\n+        value: ConstVal,\n+    },\n+\n+    Range {\n+        lo: ConstVal,\n+        hi: ConstVal,\n+    },\n+\n+    /// matches against a slice, checking the length and extracting elements\n+    Slice {\n+        prefix: Vec<Pattern<'tcx>>,\n+        slice: Option<Pattern<'tcx>>,\n+        suffix: Vec<Pattern<'tcx>>,\n+    },\n+\n+    /// fixed match against an array, irrefutable\n+    Array {\n+        prefix: Vec<Pattern<'tcx>>,\n+        slice: Option<Pattern<'tcx>>,\n+        suffix: Vec<Pattern<'tcx>>,\n+    },\n+}\n+\n+pub struct PatternContext<'a, 'gcx: 'tcx, 'tcx: 'a> {\n+    pub tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    pub errors: Vec<PatternError>,\n+}\n+\n+impl<'a, 'gcx, 'tcx> Pattern<'tcx> {\n+    pub fn from_hir(tcx: TyCtxt<'a, 'gcx, 'tcx>, pat: &hir::Pat) -> Self {\n+        let mut pcx = PatternContext::new(tcx);\n+        let result = pcx.lower_pattern(pat);\n+        if !pcx.errors.is_empty() {\n+            span_bug!(pat.span, \"encountered errors lowering pattern: {:?}\", pcx.errors)\n+        }\n+        debug!(\"Pattern::from_hir({:?}) = {:?}\", pat, result);\n+        result\n+    }\n+}\n+\n+impl<'a, 'gcx, 'tcx> PatternContext<'a, 'gcx, 'tcx> {\n+    pub fn new(tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Self {\n+        PatternContext { tcx: tcx, errors: vec![] }\n+    }\n+\n+    pub fn lower_pattern(&mut self, pat: &hir::Pat) -> Pattern<'tcx> {\n+        let mut ty = self.tcx.node_id_to_type(pat.id);\n+\n+        let kind = match pat.node {\n+            PatKind::Wild => PatternKind::Wild,\n+\n+            PatKind::Lit(ref value) => {\n+                match eval::eval_const_expr_checked(self.tcx.global_tcx(), value) {\n+                    Ok(value) => {\n+                        PatternKind::Constant { value: value }\n+                    }\n+                    Err(e) => {\n+                        self.errors.push(PatternError::ConstEval(e));\n+                        PatternKind::Wild\n+                    }\n+                }\n+            }\n+\n+            PatKind::Range(ref lo, ref hi) => {\n+                let r_lo = eval::eval_const_expr_checked(self.tcx.global_tcx(), lo);\n+                if let Err(ref e_lo) = r_lo {\n+                    self.errors.push(PatternError::ConstEval(e_lo.clone()));\n+                }\n+\n+                let r_hi = eval::eval_const_expr_checked(self.tcx.global_tcx(), hi);\n+                if let Err(ref e_hi) = r_hi {\n+                    self.errors.push(PatternError::ConstEval(e_hi.clone()));\n+                }\n+\n+                if let (Ok(lo), Ok(hi)) = (r_lo, r_hi) {\n+                    PatternKind::Range { lo: lo, hi: hi }\n+                } else {\n+                    PatternKind::Wild\n+                }\n+            }\n+\n+            PatKind::Path(..) => {\n+                match self.tcx.expect_def(pat.id) {\n+                    Def::Const(def_id) | Def::AssociatedConst(def_id) => {\n+                        let tcx = self.tcx.global_tcx();\n+                        let substs = Some(self.tcx.node_id_item_substs(pat.id).substs);\n+                        match eval::lookup_const_by_id(tcx, def_id, substs) {\n+                            Some((const_expr, _const_ty)) => {\n+                                match eval::const_expr_to_pat(\n+                                    tcx, const_expr, pat.id, pat.span)\n+                                {\n+                                    Ok(pat) => return self.lower_pattern(&pat),\n+                                    Err(_) => {\n+                                        self.errors.push(PatternError::BadConstInPattern(\n+                                            pat.span, def_id));\n+                                        PatternKind::Wild\n+                                    }\n+                                }\n+                            }\n+                            None => {\n+                                self.errors.push(PatternError::StaticInPattern(pat.span));\n+                                PatternKind::Wild\n+                            }\n+                        }\n+                    }\n+                    _ => self.lower_variant_or_leaf(pat, vec![])\n+                }\n+            }\n+\n+            PatKind::Ref(ref subpattern, _) |\n+            PatKind::Box(ref subpattern) => {\n+                PatternKind::Deref { subpattern: self.lower_pattern(subpattern) }\n+            }\n+\n+            PatKind::Slice(ref prefix, ref slice, ref suffix) => {\n+                let ty = self.tcx.node_id_to_type(pat.id);\n+                match ty.sty {\n+                    ty::TyRef(_, mt) =>\n+                        PatternKind::Deref {\n+                            subpattern: Pattern {\n+                                ty: mt.ty,\n+                                span: pat.span,\n+                                kind: Box::new(self.slice_or_array_pattern(\n+                                    pat.span, mt.ty, prefix, slice, suffix))\n+                            },\n+                        },\n+\n+                    ty::TySlice(..) |\n+                    ty::TyArray(..) =>\n+                        self.slice_or_array_pattern(pat.span, ty, prefix, slice, suffix),\n+\n+                    ref sty =>\n+                        span_bug!(\n+                            pat.span,\n+                            \"unexpanded type for vector pattern: {:?}\",\n+                            sty),\n+                }\n+            }\n+\n+            PatKind::Tuple(ref subpatterns, ddpos) => {\n+                match self.tcx.node_id_to_type(pat.id).sty {\n+                    ty::TyTuple(ref tys) => {\n+                        let subpatterns =\n+                            subpatterns.iter()\n+                                       .enumerate_and_adjust(tys.len(), ddpos)\n+                                       .map(|(i, subpattern)| FieldPattern {\n+                                            field: Field::new(i),\n+                                            pattern: self.lower_pattern(subpattern)\n+                                       })\n+                                       .collect();\n+\n+                        PatternKind::Leaf { subpatterns: subpatterns }\n+                    }\n+\n+                    ref sty => span_bug!(pat.span, \"unexpected type for tuple pattern: {:?}\", sty),\n+                }\n+            }\n+\n+            PatKind::Binding(bm, ref ident, ref sub) => {\n+                let def_id = self.tcx.expect_def(pat.id).def_id();\n+                let id = self.tcx.map.as_local_node_id(def_id).unwrap();\n+                let var_ty = self.tcx.node_id_to_type(pat.id);\n+                let region = match var_ty.sty {\n+                    ty::TyRef(r, _) => Some(r),\n+                    _ => None,\n+                };\n+                let (mutability, mode) = match bm {\n+                    hir::BindByValue(hir::MutMutable) =>\n+                        (Mutability::Mut, BindingMode::ByValue),\n+                    hir::BindByValue(hir::MutImmutable) =>\n+                        (Mutability::Not, BindingMode::ByValue),\n+                    hir::BindByRef(hir::MutMutable) =>\n+                        (Mutability::Not, BindingMode::ByRef(region.unwrap(), BorrowKind::Mut)),\n+                    hir::BindByRef(hir::MutImmutable) =>\n+                        (Mutability::Not, BindingMode::ByRef(region.unwrap(), BorrowKind::Shared)),\n+                };\n+\n+                // A ref x pattern is the same node used for x, and as such it has\n+                // x's type, which is &T, where we want T (the type being matched).\n+                if let hir::BindByRef(_) = bm {\n+                    if let ty::TyRef(_, mt) = ty.sty {\n+                        ty = mt.ty;\n+                    } else {\n+                        bug!(\"`ref {}` has wrong type {}\", ident.node, ty);\n+                    }\n+                }\n+\n+                PatternKind::Binding {\n+                    mutability: mutability,\n+                    mode: mode,\n+                    name: ident.node,\n+                    var: id,\n+                    ty: var_ty,\n+                    subpattern: self.lower_opt_pattern(sub),\n+                }\n+            }\n+\n+            PatKind::TupleStruct(_, ref subpatterns, ddpos) => {\n+                let pat_ty = self.tcx.node_id_to_type(pat.id);\n+                let adt_def = match pat_ty.sty {\n+                    ty::TyAdt(adt_def, _) => adt_def,\n+                    _ => span_bug!(pat.span, \"tuple struct pattern not applied to an ADT\"),\n+                };\n+                let variant_def = adt_def.variant_of_def(self.tcx.expect_def(pat.id));\n+\n+                let subpatterns =\n+                        subpatterns.iter()\n+                                   .enumerate_and_adjust(variant_def.fields.len(), ddpos)\n+                                   .map(|(i, field)| FieldPattern {\n+                                       field: Field::new(i),\n+                                       pattern: self.lower_pattern(field),\n+                                   })\n+                                   .collect();\n+                self.lower_variant_or_leaf(pat, subpatterns)\n+            }\n+\n+            PatKind::Struct(_, ref fields, _) => {\n+                let pat_ty = self.tcx.node_id_to_type(pat.id);\n+                let adt_def = match pat_ty.sty {\n+                    ty::TyAdt(adt_def, _) => adt_def,\n+                    _ => {\n+                        span_bug!(\n+                            pat.span,\n+                            \"struct pattern not applied to an ADT\");\n+                    }\n+                };\n+                let variant_def = adt_def.variant_of_def(self.tcx.expect_def(pat.id));\n+\n+                let subpatterns =\n+                    fields.iter()\n+                          .map(|field| {\n+                              let index = variant_def.index_of_field_named(field.node.name);\n+                              let index = index.unwrap_or_else(|| {\n+                                  span_bug!(\n+                                      pat.span,\n+                                      \"no field with name {:?}\",\n+                                      field.node.name);\n+                              });\n+                              FieldPattern {\n+                                  field: Field::new(index),\n+                                  pattern: self.lower_pattern(&field.node.pat),\n+                              }\n+                          })\n+                          .collect();\n+\n+                self.lower_variant_or_leaf(pat, subpatterns)\n+            }\n+        };\n+\n+        Pattern {\n+            span: pat.span,\n+            ty: ty,\n+            kind: Box::new(kind),\n+        }\n+    }\n+\n+    fn lower_patterns(&mut self, pats: &[P<hir::Pat>]) -> Vec<Pattern<'tcx>> {\n+        pats.iter().map(|p| self.lower_pattern(p)).collect()\n+    }\n+\n+    fn lower_opt_pattern(&mut self, pat: &Option<P<hir::Pat>>) -> Option<Pattern<'tcx>>\n+    {\n+        pat.as_ref().map(|p| self.lower_pattern(p))\n+    }\n+\n+    fn flatten_nested_slice_patterns(\n+        &mut self,\n+        prefix: Vec<Pattern<'tcx>>,\n+        slice: Option<Pattern<'tcx>>,\n+        suffix: Vec<Pattern<'tcx>>)\n+        -> (Vec<Pattern<'tcx>>, Option<Pattern<'tcx>>, Vec<Pattern<'tcx>>)\n+    {\n+        let orig_slice = match slice {\n+            Some(orig_slice) => orig_slice,\n+            None => return (prefix, slice, suffix)\n+        };\n+        let orig_prefix = prefix;\n+        let orig_suffix = suffix;\n+\n+        // dance because of intentional borrow-checker stupidity.\n+        let kind = *orig_slice.kind;\n+        match kind {\n+            PatternKind::Slice { prefix, slice, mut suffix } |\n+            PatternKind::Array { prefix, slice, mut suffix } => {\n+                let mut orig_prefix = orig_prefix;\n+\n+                orig_prefix.extend(prefix);\n+                suffix.extend(orig_suffix);\n+\n+                (orig_prefix, slice, suffix)\n+            }\n+            _ => {\n+                (orig_prefix, Some(Pattern {\n+                    kind: box kind, ..orig_slice\n+                }), orig_suffix)\n+            }\n+        }\n+    }\n+\n+    fn slice_or_array_pattern(\n+        &mut self,\n+        span: Span,\n+        ty: Ty<'tcx>,\n+        prefix: &[P<hir::Pat>],\n+        slice: &Option<P<hir::Pat>>,\n+        suffix: &[P<hir::Pat>])\n+        -> PatternKind<'tcx>\n+    {\n+        let prefix = self.lower_patterns(prefix);\n+        let slice = self.lower_opt_pattern(slice);\n+        let suffix = self.lower_patterns(suffix);\n+        let (prefix, slice, suffix) =\n+            self.flatten_nested_slice_patterns(prefix, slice, suffix);\n+\n+        match ty.sty {\n+            ty::TySlice(..) => {\n+                // matching a slice or fixed-length array\n+                PatternKind::Slice { prefix: prefix, slice: slice, suffix: suffix }\n+            }\n+\n+            ty::TyArray(_, len) => {\n+                // fixed-length array\n+                assert!(len >= prefix.len() + suffix.len());\n+                PatternKind::Array { prefix: prefix, slice: slice, suffix: suffix }\n+            }\n+\n+            _ => {\n+                span_bug!(span, \"bad slice pattern type {:?}\", ty);\n+            }\n+        }\n+    }\n+\n+    fn lower_variant_or_leaf(\n+        &mut self,\n+        pat: &hir::Pat,\n+        subpatterns: Vec<FieldPattern<'tcx>>)\n+        -> PatternKind<'tcx>\n+    {\n+        match self.tcx.expect_def(pat.id) {\n+            Def::Variant(variant_id) | Def::VariantCtor(variant_id, ..) => {\n+                let enum_id = self.tcx.parent_def_id(variant_id).unwrap();\n+                let adt_def = self.tcx.lookup_adt_def(enum_id);\n+                if adt_def.variants.len() > 1 {\n+                    PatternKind::Variant {\n+                        adt_def: adt_def,\n+                        variant_index: adt_def.variant_index_with_id(variant_id),\n+                        subpatterns: subpatterns,\n+                    }\n+                } else {\n+                    PatternKind::Leaf { subpatterns: subpatterns }\n+                }\n+            }\n+\n+            Def::Struct(..) | Def::StructCtor(..) | Def::Union(..) |\n+            Def::TyAlias(..) | Def::AssociatedTy(..) => {\n+                PatternKind::Leaf { subpatterns: subpatterns }\n+            }\n+\n+            def => {\n+                span_bug!(pat.span, \"inappropriate def for pattern: {:?}\", def);\n+            }\n+        }\n+    }\n+}\n+\n+pub trait PatternFoldable<'tcx> : Sized {\n+    fn fold_with<F: PatternFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+        self.super_fold_with(folder)\n+    }\n+\n+    fn super_fold_with<F: PatternFolder<'tcx>>(&self, folder: &mut F) -> Self;\n+}\n+\n+pub trait PatternFolder<'tcx> : Sized {\n+    fn fold_pattern(&mut self, pattern: &Pattern<'tcx>) -> Pattern<'tcx> {\n+        pattern.super_fold_with(self)\n+    }\n+\n+    fn fold_pattern_kind(&mut self, kind: &PatternKind<'tcx>) -> PatternKind<'tcx> {\n+        kind.super_fold_with(self)\n+    }\n+}\n+\n+\n+impl<'tcx, T: PatternFoldable<'tcx>> PatternFoldable<'tcx> for Box<T> {\n+    fn super_fold_with<F: PatternFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+        let content: T = (**self).fold_with(folder);\n+        box content\n+    }\n+}\n+\n+impl<'tcx, T: PatternFoldable<'tcx>> PatternFoldable<'tcx> for Vec<T> {\n+    fn super_fold_with<F: PatternFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+        self.iter().map(|t| t.fold_with(folder)).collect()\n+    }\n+}\n+\n+impl<'tcx, T: PatternFoldable<'tcx>> PatternFoldable<'tcx> for Option<T> {\n+    fn super_fold_with<F: PatternFolder<'tcx>>(&self, folder: &mut F) -> Self{\n+        self.as_ref().map(|t| t.fold_with(folder))\n+    }\n+}\n+\n+macro_rules! CopyImpls {\n+    ($($ty:ty),+) => {\n+        $(\n+            impl<'tcx> PatternFoldable<'tcx> for $ty {\n+                fn super_fold_with<F: PatternFolder<'tcx>>(&self, _: &mut F) -> Self {\n+                    self.clone()\n+                }\n+            }\n+            )+\n+    }\n+}\n+\n+macro_rules! TcxCopyImpls {\n+    ($($ty:ident),+) => {\n+        $(\n+            impl<'tcx> PatternFoldable<'tcx> for $ty<'tcx> {\n+                fn super_fold_with<F: PatternFolder<'tcx>>(&self, _: &mut F) -> Self {\n+                    *self\n+                }\n+            }\n+        )+\n+    }\n+}\n+\n+CopyImpls!{ Span, Field, Mutability, ast::Name, ast::NodeId, usize, ConstVal }\n+TcxCopyImpls!{ Ty, BindingMode, AdtDef }\n+\n+impl<'tcx> PatternFoldable<'tcx> for FieldPattern<'tcx> {\n+    fn super_fold_with<F: PatternFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+        FieldPattern {\n+            field: self.field.fold_with(folder),\n+            pattern: self.pattern.fold_with(folder)\n+        }\n+    }\n+}\n+\n+impl<'tcx> PatternFoldable<'tcx> for Pattern<'tcx> {\n+    fn fold_with<F: PatternFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+        folder.fold_pattern(self)\n+    }\n+\n+    fn super_fold_with<F: PatternFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+        Pattern {\n+            ty: self.ty.fold_with(folder),\n+            span: self.span.fold_with(folder),\n+            kind: self.kind.fold_with(folder)\n+        }\n+    }\n+}\n+\n+impl<'tcx> PatternFoldable<'tcx> for PatternKind<'tcx> {\n+    fn fold_with<F: PatternFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+        folder.fold_pattern_kind(self)\n+    }\n+\n+    fn super_fold_with<F: PatternFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+        match *self {\n+            PatternKind::Wild => PatternKind::Wild,\n+            PatternKind::Binding {\n+                mutability,\n+                name,\n+                mode,\n+                var,\n+                ty,\n+                ref subpattern,\n+            } => PatternKind::Binding {\n+                mutability: mutability.fold_with(folder),\n+                name: name.fold_with(folder),\n+                mode: mode.fold_with(folder),\n+                var: var.fold_with(folder),\n+                ty: ty.fold_with(folder),\n+                subpattern: subpattern.fold_with(folder),\n+            },\n+            PatternKind::Variant {\n+                adt_def,\n+                variant_index,\n+                ref subpatterns,\n+            } => PatternKind::Variant {\n+                adt_def: adt_def.fold_with(folder),\n+                variant_index: variant_index.fold_with(folder),\n+                subpatterns: subpatterns.fold_with(folder)\n+            },\n+            PatternKind::Leaf {\n+                ref subpatterns,\n+            } => PatternKind::Leaf {\n+                subpatterns: subpatterns.fold_with(folder),\n+            },\n+            PatternKind::Deref {\n+                ref subpattern,\n+            } => PatternKind::Deref {\n+                subpattern: subpattern.fold_with(folder),\n+            },\n+            PatternKind::Constant {\n+                ref value\n+            } => PatternKind::Constant {\n+                value: value.fold_with(folder)\n+            },\n+            PatternKind::Range {\n+                ref lo,\n+                ref hi\n+            } => PatternKind::Range {\n+                lo: lo.fold_with(folder),\n+                hi: hi.fold_with(folder)\n+            },\n+            PatternKind::Slice {\n+                ref prefix,\n+                ref slice,\n+                ref suffix,\n+            } => PatternKind::Slice {\n+                prefix: prefix.fold_with(folder),\n+                slice: slice.fold_with(folder),\n+                suffix: suffix.fold_with(folder)\n+            },\n+            PatternKind::Array {\n+                ref prefix,\n+                ref slice,\n+                ref suffix\n+            } => PatternKind::Array {\n+                prefix: prefix.fold_with(folder),\n+                slice: slice.fold_with(folder),\n+                suffix: suffix.fold_with(folder)\n+            },\n+        }\n+    }\n+}"}, {"sha": "78a1604a5cbbac69df0e1159d07a8608f5fe1ad3", "filename": "src/librustc_mir/build/matches/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4a584637b0081c96c53c6048fd3715912c94a59b/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a584637b0081c96c53c6048fd3715912c94a59b/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs?ref=4a584637b0081c96c53c6048fd3715912c94a59b", "patch": "@@ -73,8 +73,8 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 Test {\n                     span: match_pair.pattern.span,\n                     kind: TestKind::Range {\n-                        lo: lo.clone(),\n-                        hi: hi.clone(),\n+                        lo: Literal::Value { value: lo.clone() },\n+                        hi: Literal::Value { value: hi.clone() },\n                         ty: match_pair.pattern.ty.clone(),\n                     },\n                 }"}, {"sha": "a7249677e01031a7c9895e02cf72720f2e9fad96", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4a584637b0081c96c53c6048fd3715912c94a59b/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a584637b0081c96c53c6048fd3715912c94a59b/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=4a584637b0081c96c53c6048fd3715912c94a59b", "patch": "@@ -9,6 +9,8 @@\n // except according to those terms.\n \n use hair::cx::Cx;\n+use hair::Pattern;\n+\n use rustc::middle::region::{CodeExtent, CodeExtentData, ROOT_CODE_EXTENT};\n use rustc::ty::{self, Ty};\n use rustc::mir::repr::*;\n@@ -339,7 +341,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             let lvalue = Lvalue::Local(Local::new(index + 1));\n \n             if let Some(pattern) = pattern {\n-                let pattern = self.hir.irrefutable_pat(pattern);\n+                let pattern = Pattern::from_hir(self.hir.tcx(), pattern);\n                 scope = self.declare_bindings(scope, ast_block.span, &pattern);\n                 unpack!(block = self.lvalue_into_pattern(block, pattern, &lvalue));\n             }"}, {"sha": "ec1136368c1354317d18670e0b500be4f4dfa452", "filename": "src/librustc_mir/hair/cx/block.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4a584637b0081c96c53c6048fd3715912c94a59b/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a584637b0081c96c53c6048fd3715912c94a59b/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs?ref=4a584637b0081c96c53c6048fd3715912c94a59b", "patch": "@@ -57,7 +57,7 @@ fn mirror_stmts<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                     let remainder_extent =\n                         cx.tcx.region_maps.lookup_code_extent(remainder_extent);\n \n-                    let pattern = cx.irrefutable_pat(&local.pat);\n+                    let pattern = Pattern::from_hir(cx.tcx, &local.pat);\n                     result.push(StmtRef::Mirror(Box::new(Stmt {\n                         span: stmt.span,\n                         kind: StmtKind::Let {"}, {"sha": "45c49a4627ff6cac481d647c50c812f0e8c89250", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4a584637b0081c96c53c6048fd3715912c94a59b/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a584637b0081c96c53c6048fd3715912c94a59b/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=4a584637b0081c96c53c6048fd3715912c94a59b", "patch": "@@ -657,7 +657,7 @@ fn to_borrow_kind(m: hir::Mutability) -> BorrowKind {\n fn convert_arm<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                                arm: &'tcx hir::Arm) -> Arm<'tcx> {\n     Arm {\n-        patterns: arm.pats.iter().map(|p| cx.refutable_pat(p)).collect(),\n+        patterns: arm.pats.iter().map(|p| Pattern::from_hir(cx.tcx, p)).collect(),\n         guard: arm.guard.to_ref(),\n         body: arm.body.to_ref(),\n     }"}, {"sha": "f87e0acaa4ca1c689b97015ade729d23e1ff0583", "filename": "src/librustc_mir/hair/cx/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4a584637b0081c96c53c6048fd3715912c94a59b/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a584637b0081c96c53c6048fd3715912c94a59b/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs?ref=4a584637b0081c96c53c6048fd3715912c94a59b", "patch": "@@ -196,5 +196,4 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n \n mod block;\n mod expr;\n-mod pattern;\n mod to_ref;"}, {"sha": "84f415463be05613e9d6bd36f3b2b0503975637b", "filename": "src/librustc_mir/hair/cx/pattern.rs", "status": "removed", "additions": 0, "deletions": 328, "changes": 328, "blob_url": "https://github.com/rust-lang/rust/blob/c59cb71d976ceabf00c7da0224a795fab530601e/src%2Flibrustc_mir%2Fhair%2Fcx%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c59cb71d976ceabf00c7da0224a795fab530601e/src%2Flibrustc_mir%2Fhair%2Fcx%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fpattern.rs?ref=c59cb71d976ceabf00c7da0224a795fab530601e", "patch": "@@ -1,328 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use hair::*;\n-use hair::cx::Cx;\n-use rustc_data_structures::indexed_vec::Idx;\n-use rustc_const_eval as const_eval;\n-use rustc::hir::def::Def;\n-use rustc::hir::pat_util::EnumerateAndAdjustIterator;\n-use rustc::ty::{self, Ty};\n-use rustc::mir::repr::*;\n-use rustc::hir::{self, PatKind};\n-use syntax::ptr::P;\n-use syntax_pos::Span;\n-\n-/// When there are multiple patterns in a single arm, each one has its\n-/// own node-ids for the bindings.  References to the variables always\n-/// use the node-ids from the first pattern in the arm, so we just\n-/// remap the ids for all subsequent bindings to the first one.\n-///\n-/// Example:\n-/// ```\n-/// match foo {\n-///    Test1(flavor /* def 1 */) |\n-///    Test2(flavor /* def 2 */) if flavor /* ref 1 */.is_tasty() => { ... }\n-///    _ => { ... }\n-/// }\n-/// ```\n-struct PatCx<'patcx, 'cx: 'patcx, 'gcx: 'cx+'tcx, 'tcx: 'cx> {\n-    cx: &'patcx mut Cx<'cx, 'gcx, 'tcx>,\n-}\n-\n-impl<'cx, 'gcx, 'tcx> Cx<'cx, 'gcx, 'tcx> {\n-    pub fn irrefutable_pat(&mut self, pat: &hir::Pat) -> Pattern<'tcx> {\n-        PatCx::new(self).to_pattern(pat)\n-    }\n-\n-    pub fn refutable_pat(&mut self,\n-                         pat: &hir::Pat)\n-                         -> Pattern<'tcx> {\n-        PatCx::new(self).to_pattern(pat)\n-    }\n-}\n-\n-impl<'patcx, 'cx, 'gcx, 'tcx> PatCx<'patcx, 'cx, 'gcx, 'tcx> {\n-    fn new(cx: &'patcx mut Cx<'cx, 'gcx, 'tcx>)\n-               -> PatCx<'patcx, 'cx, 'gcx, 'tcx> {\n-        PatCx {\n-            cx: cx,\n-        }\n-    }\n-\n-    fn to_pattern(&mut self, pat: &hir::Pat) -> Pattern<'tcx> {\n-        let mut ty = self.cx.tcx.node_id_to_type(pat.id);\n-\n-        let kind = match pat.node {\n-            PatKind::Wild => PatternKind::Wild,\n-\n-            PatKind::Lit(ref value) => {\n-                let value = const_eval::eval_const_expr(self.cx.tcx.global_tcx(), value);\n-                PatternKind::Constant { value: value }\n-            }\n-\n-            PatKind::Range(ref lo, ref hi) => {\n-                let lo = const_eval::eval_const_expr(self.cx.tcx.global_tcx(), lo);\n-                let lo = Literal::Value { value: lo };\n-                let hi = const_eval::eval_const_expr(self.cx.tcx.global_tcx(), hi);\n-                let hi = Literal::Value { value: hi };\n-                PatternKind::Range { lo: lo, hi: hi }\n-            },\n-\n-            PatKind::Path(..) => {\n-                match self.cx.tcx.expect_def(pat.id) {\n-                    Def::Const(def_id) | Def::AssociatedConst(def_id) => {\n-                        let tcx = self.cx.tcx.global_tcx();\n-                        let substs = Some(self.cx.tcx.node_id_item_substs(pat.id).substs);\n-                        match const_eval::lookup_const_by_id(tcx, def_id, substs) {\n-                            Some((const_expr, _const_ty)) => {\n-                                match const_eval::const_expr_to_pat(tcx,\n-                                                                    const_expr,\n-                                                                    pat.id,\n-                                                                    pat.span) {\n-                                    Ok(pat) =>\n-                                        return self.to_pattern(&pat),\n-                                    Err(_) =>\n-                                        span_bug!(\n-                                            pat.span, \"illegal constant\"),\n-                                }\n-                            }\n-                            None => {\n-                                span_bug!(\n-                                    pat.span,\n-                                    \"cannot eval constant: {:?}\",\n-                                    def_id)\n-                            }\n-                        }\n-                    }\n-                    _ => {\n-                        self.variant_or_leaf(pat, vec![])\n-                    }\n-                }\n-            }\n-\n-            PatKind::Ref(ref subpattern, _) |\n-            PatKind::Box(ref subpattern) => {\n-                PatternKind::Deref { subpattern: self.to_pattern(subpattern) }\n-            }\n-\n-            PatKind::Slice(ref prefix, ref slice, ref suffix) => {\n-                let ty = self.cx.tcx.node_id_to_type(pat.id);\n-                match ty.sty {\n-                    ty::TyRef(_, mt) =>\n-                        PatternKind::Deref {\n-                            subpattern: Pattern {\n-                                ty: mt.ty,\n-                                span: pat.span,\n-                                kind: Box::new(self.slice_or_array_pattern(pat.span, mt.ty, prefix,\n-                                                                           slice, suffix)),\n-                            },\n-                        },\n-\n-                    ty::TySlice(..) |\n-                    ty::TyArray(..) =>\n-                        self.slice_or_array_pattern(pat.span, ty, prefix, slice, suffix),\n-\n-                    ref sty =>\n-                        span_bug!(\n-                            pat.span,\n-                            \"unexpanded type for vector pattern: {:?}\",\n-                            sty),\n-                }\n-            }\n-\n-            PatKind::Tuple(ref subpatterns, ddpos) => {\n-                match self.cx.tcx.node_id_to_type(pat.id).sty {\n-                    ty::TyTuple(ref tys) => {\n-                        let subpatterns =\n-                            subpatterns.iter()\n-                                       .enumerate_and_adjust(tys.len(), ddpos)\n-                                       .map(|(i, subpattern)| FieldPattern {\n-                                            field: Field::new(i),\n-                                            pattern: self.to_pattern(subpattern),\n-                                       })\n-                                       .collect();\n-\n-                        PatternKind::Leaf { subpatterns: subpatterns }\n-                    }\n-\n-                    ref sty => span_bug!(pat.span, \"unexpected type for tuple pattern: {:?}\", sty),\n-                }\n-            }\n-\n-            PatKind::Binding(bm, ref ident, ref sub) => {\n-                let def_id = self.cx.tcx.expect_def(pat.id).def_id();\n-                let id = self.cx.tcx.map.as_local_node_id(def_id).unwrap();\n-                let var_ty = self.cx.tcx.node_id_to_type(pat.id);\n-                let region = match var_ty.sty {\n-                    ty::TyRef(r, _) => Some(r),\n-                    _ => None,\n-                };\n-                let (mutability, mode) = match bm {\n-                    hir::BindByValue(hir::MutMutable) =>\n-                        (Mutability::Mut, BindingMode::ByValue),\n-                    hir::BindByValue(hir::MutImmutable) =>\n-                        (Mutability::Not, BindingMode::ByValue),\n-                    hir::BindByRef(hir::MutMutable) =>\n-                        (Mutability::Not, BindingMode::ByRef(region.unwrap(), BorrowKind::Mut)),\n-                    hir::BindByRef(hir::MutImmutable) =>\n-                        (Mutability::Not, BindingMode::ByRef(region.unwrap(), BorrowKind::Shared)),\n-                };\n-\n-                // A ref x pattern is the same node used for x, and as such it has\n-                // x's type, which is &T, where we want T (the type being matched).\n-                if let hir::BindByRef(_) = bm {\n-                    if let ty::TyRef(_, mt) = ty.sty {\n-                        ty = mt.ty;\n-                    } else {\n-                        bug!(\"`ref {}` has wrong type {}\", ident.node, ty);\n-                    }\n-                }\n-\n-                PatternKind::Binding {\n-                    mutability: mutability,\n-                    mode: mode,\n-                    name: ident.node,\n-                    var: id,\n-                    ty: var_ty,\n-                    subpattern: self.to_opt_pattern(sub),\n-                }\n-            }\n-\n-            PatKind::TupleStruct(_, ref subpatterns, ddpos) => {\n-                let pat_ty = self.cx.tcx.node_id_to_type(pat.id);\n-                let adt_def = match pat_ty.sty {\n-                    ty::TyAdt(adt_def, _) => adt_def,\n-                    _ => span_bug!(pat.span, \"tuple struct pattern not applied to an ADT\"),\n-                };\n-                let variant_def = adt_def.variant_of_def(self.cx.tcx.expect_def(pat.id));\n-\n-                let subpatterns =\n-                        subpatterns.iter()\n-                                   .enumerate_and_adjust(variant_def.fields.len(), ddpos)\n-                                   .map(|(i, field)| FieldPattern {\n-                                       field: Field::new(i),\n-                                       pattern: self.to_pattern(field),\n-                                   })\n-                                   .collect();\n-                self.variant_or_leaf(pat, subpatterns)\n-            }\n-\n-            PatKind::Struct(_, ref fields, _) => {\n-                let pat_ty = self.cx.tcx.node_id_to_type(pat.id);\n-                let adt_def = match pat_ty.sty {\n-                    ty::TyAdt(adt_def, _) => adt_def,\n-                    _ => {\n-                        span_bug!(\n-                            pat.span,\n-                            \"struct pattern not applied to an ADT\");\n-                    }\n-                };\n-                let variant_def = adt_def.variant_of_def(self.cx.tcx.expect_def(pat.id));\n-\n-                let subpatterns =\n-                    fields.iter()\n-                          .map(|field| {\n-                              let index = variant_def.index_of_field_named(field.node.name);\n-                              let index = index.unwrap_or_else(|| {\n-                                  span_bug!(\n-                                      pat.span,\n-                                      \"no field with name {:?}\",\n-                                      field.node.name);\n-                              });\n-                              FieldPattern {\n-                                  field: Field::new(index),\n-                                  pattern: self.to_pattern(&field.node.pat),\n-                              }\n-                          })\n-                          .collect();\n-\n-                self.variant_or_leaf(pat, subpatterns)\n-            }\n-        };\n-\n-        Pattern {\n-            span: pat.span,\n-            ty: ty,\n-            kind: Box::new(kind),\n-        }\n-    }\n-\n-    fn to_patterns(&mut self, pats: &[P<hir::Pat>]) -> Vec<Pattern<'tcx>> {\n-        pats.iter().map(|p| self.to_pattern(p)).collect()\n-    }\n-\n-    fn to_opt_pattern(&mut self, pat: &Option<P<hir::Pat>>) -> Option<Pattern<'tcx>> {\n-        pat.as_ref().map(|p| self.to_pattern(p))\n-    }\n-\n-    fn slice_or_array_pattern(&mut self,\n-                              span: Span,\n-                              ty: Ty<'tcx>,\n-                              prefix: &[P<hir::Pat>],\n-                              slice: &Option<P<hir::Pat>>,\n-                              suffix: &[P<hir::Pat>])\n-                              -> PatternKind<'tcx> {\n-        match ty.sty {\n-            ty::TySlice(..) => {\n-                // matching a slice or fixed-length array\n-                PatternKind::Slice {\n-                    prefix: self.to_patterns(prefix),\n-                    slice: self.to_opt_pattern(slice),\n-                    suffix: self.to_patterns(suffix),\n-                }\n-            }\n-\n-            ty::TyArray(_, len) => {\n-                // fixed-length array\n-                assert!(len >= prefix.len() + suffix.len());\n-                PatternKind::Array {\n-                    prefix: self.to_patterns(prefix),\n-                    slice: self.to_opt_pattern(slice),\n-                    suffix: self.to_patterns(suffix),\n-                }\n-            }\n-\n-            _ => {\n-                span_bug!(span, \"unexpanded macro or bad constant etc\");\n-            }\n-        }\n-    }\n-\n-    fn variant_or_leaf(&mut self,\n-                       pat: &hir::Pat,\n-                       subpatterns: Vec<FieldPattern<'tcx>>)\n-                       -> PatternKind<'tcx> {\n-        match self.cx.tcx.expect_def(pat.id) {\n-            Def::Variant(variant_id) | Def::VariantCtor(variant_id, ..) => {\n-                let enum_id = self.cx.tcx.parent_def_id(variant_id).unwrap();\n-                let adt_def = self.cx.tcx.lookup_adt_def(enum_id);\n-                if adt_def.variants.len() > 1 {\n-                    PatternKind::Variant {\n-                        adt_def: adt_def,\n-                        variant_index: adt_def.variant_index_with_id(variant_id),\n-                        subpatterns: subpatterns,\n-                    }\n-                } else {\n-                    PatternKind::Leaf { subpatterns: subpatterns }\n-                }\n-            }\n-\n-            Def::Struct(..) | Def::StructCtor(..) | Def::Union(..) |\n-            Def::TyAlias(..) | Def::AssociatedTy(..) => {\n-                PatternKind::Leaf { subpatterns: subpatterns }\n-            }\n-\n-            def => {\n-                span_bug!(pat.span, \"inappropriate def for pattern: {:?}\", def);\n-            }\n-        }\n-    }\n-}"}, {"sha": "49a592b07fb4f5134728da29738787bdf02c1b0a", "filename": "src/librustc_mir/hair/mod.rs", "status": "modified", "additions": 3, "deletions": 77, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/4a584637b0081c96c53c6048fd3715912c94a59b/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a584637b0081c96c53c6048fd3715912c94a59b/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fmod.rs?ref=4a584637b0081c96c53c6048fd3715912c94a59b", "patch": "@@ -14,9 +14,7 @@\n //! unit-tested and separated from the Rust source and compiler data\n //! structures.\n \n-use rustc::mir::repr::{BinOp, BorrowKind, Field, Literal, Mutability, UnOp,\n-    TypedConstVal};\n-use rustc::middle::const_val::ConstVal;\n+use rustc::mir::repr::{BinOp, BorrowKind, Field, Literal, UnOp, TypedConstVal};\n use rustc::hir::def_id::DefId;\n use rustc::middle::region::CodeExtent;\n use rustc::ty::subst::Substs;\n@@ -28,6 +26,8 @@ use self::cx::Cx;\n \n pub mod cx;\n \n+pub use rustc_const_eval::pattern::{BindingMode, Pattern, PatternKind, FieldPattern};\n+\n #[derive(Clone, Debug)]\n pub struct Block<'tcx> {\n     pub extent: CodeExtent,\n@@ -266,86 +266,12 @@ pub struct Arm<'tcx> {\n     pub body: ExprRef<'tcx>,\n }\n \n-#[derive(Clone, Debug)]\n-pub struct Pattern<'tcx> {\n-    pub ty: Ty<'tcx>,\n-    pub span: Span,\n-    pub kind: Box<PatternKind<'tcx>>,\n-}\n-\n #[derive(Copy, Clone, Debug)]\n pub enum LogicalOp {\n     And,\n     Or,\n }\n \n-#[derive(Clone, Debug)]\n-pub enum PatternKind<'tcx> {\n-    Wild,\n-\n-    /// x, ref x, x @ P, etc\n-    Binding {\n-        mutability: Mutability,\n-        name: ast::Name,\n-        mode: BindingMode<'tcx>,\n-        var: ast::NodeId,\n-        ty: Ty<'tcx>,\n-        subpattern: Option<Pattern<'tcx>>,\n-    },\n-\n-    /// Foo(...) or Foo{...} or Foo, where `Foo` is a variant name from an adt with >1 variants\n-    Variant {\n-        adt_def: AdtDef<'tcx>,\n-        variant_index: usize,\n-        subpatterns: Vec<FieldPattern<'tcx>>,\n-    },\n-\n-    /// (...), Foo(...), Foo{...}, or Foo, where `Foo` is a variant name from an adt with 1 variant\n-    Leaf {\n-        subpatterns: Vec<FieldPattern<'tcx>>,\n-    },\n-\n-    /// box P, &P, &mut P, etc\n-    Deref {\n-        subpattern: Pattern<'tcx>,\n-    },\n-\n-    Constant {\n-        value: ConstVal,\n-    },\n-\n-    Range {\n-        lo: Literal<'tcx>,\n-        hi: Literal<'tcx>,\n-    },\n-\n-    /// matches against a slice, checking the length and extracting elements\n-    Slice {\n-        prefix: Vec<Pattern<'tcx>>,\n-        slice: Option<Pattern<'tcx>>,\n-        suffix: Vec<Pattern<'tcx>>,\n-    },\n-\n-    /// fixed match against an array, irrefutable\n-    Array {\n-        prefix: Vec<Pattern<'tcx>>,\n-        slice: Option<Pattern<'tcx>>,\n-        suffix: Vec<Pattern<'tcx>>,\n-    },\n-}\n-\n-#[derive(Copy, Clone, Debug)]\n-pub enum BindingMode<'tcx> {\n-    ByValue,\n-    ByRef(&'tcx Region, BorrowKind),\n-}\n-\n-#[derive(Clone, Debug)]\n-pub struct FieldPattern<'tcx> {\n-    pub field: Field,\n-    pub pattern: Pattern<'tcx>,\n-}\n-\n ///////////////////////////////////////////////////////////////////////////\n // The Mirror trait\n "}, {"sha": "9b045ed1d02cce60d8eeb7d203bd58557e14896e", "filename": "src/test/compile-fail/const-eval-overflow-2.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4a584637b0081c96c53c6048fd3715912c94a59b/src%2Ftest%2Fcompile-fail%2Fconst-eval-overflow-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a584637b0081c96c53c6048fd3715912c94a59b/src%2Ftest%2Fcompile-fail%2Fconst-eval-overflow-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-eval-overflow-2.rs?ref=4a584637b0081c96c53c6048fd3715912c94a59b", "patch": "@@ -21,10 +21,6 @@ const NEG_128: i8 = -128;\n const NEG_NEG_128: i8 = -NEG_128;\n //~^ ERROR constant evaluation error\n //~| attempt to negate with overflow\n-//~| ERROR constant evaluation error\n-//~| attempt to negate with overflow\n-//~| ERROR constant evaluation error\n-//~| attempt to negate with overflow\n \n fn main() {\n     match -128i8 {"}, {"sha": "b40aa2a8e27dcdf67c250265c17081355c165dcc", "filename": "src/test/compile-fail/const-pattern-not-const-evaluable.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4a584637b0081c96c53c6048fd3715912c94a59b/src%2Ftest%2Fcompile-fail%2Fconst-pattern-not-const-evaluable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a584637b0081c96c53c6048fd3715912c94a59b/src%2Ftest%2Fcompile-fail%2Fconst-pattern-not-const-evaluable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-pattern-not-const-evaluable.rs?ref=4a584637b0081c96c53c6048fd3715912c94a59b", "patch": "@@ -25,13 +25,11 @@ const fn foo() -> Cake {\n     Marmor\n         //~^ ERROR: constant evaluation error [E0080]\n         //~| unimplemented constant expression: enum variants\n-        //~^^^ ERROR: constant evaluation error [E0080]\n-        //~| unimplemented constant expression: enum variants\n }\n \n const WORKS: Cake = Marmor;\n \n-const GOO: Cake = foo(); //~ NOTE for expression here\n+const GOO: Cake = foo();\n \n fn main() {\n     match BlackForest {"}, {"sha": "54f5313aed16e7d4a3367ba99d7ecb08d89ee1e5", "filename": "src/test/compile-fail/issue-26158.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/4a584637b0081c96c53c6048fd3715912c94a59b/src%2Ftest%2Fcompile-fail%2Fissue-26158.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a584637b0081c96c53c6048fd3715912c94a59b/src%2Ftest%2Fcompile-fail%2Fissue-26158.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-26158.rs?ref=4a584637b0081c96c53c6048fd3715912c94a59b", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(slice_patterns)]\n+\n+fn main() {\n+    let x: &[u32] = &[];\n+    let &[[ref _a, ref _b..]..] = x; //~ ERROR refutable pattern\n+}"}, {"sha": "8f2670725ced7982805c6a937103f7a4de70790c", "filename": "src/test/compile-fail/issue-6804.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/4a584637b0081c96c53c6048fd3715912c94a59b/src%2Ftest%2Fcompile-fail%2Fissue-6804.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a584637b0081c96c53c6048fd3715912c94a59b/src%2Ftest%2Fcompile-fail%2Fissue-6804.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-6804.rs?ref=4a584637b0081c96c53c6048fd3715912c94a59b", "patch": "@@ -11,26 +11,24 @@\n #![feature(rustc_attrs)]\n #![feature(slice_patterns)]\n #![allow(dead_code)]\n+#![deny(illegal_floating_point_constant_pattern)]\n \n // Matching against NaN should result in a warning\n \n use std::f64::NAN;\n \n #[rustc_error]\n-fn main() { //~ ERROR compilation successful\n+fn main() {\n     let x = NAN;\n     match x {\n-        NAN => {},\n+        NAN => {}, //~ ERROR floating point constants cannot be used\n+                   //~| WARNING hard error\n         _ => {},\n     };\n-    //~^^^ WARNING unmatchable NaN in pattern, use the is_nan method in a guard instead\n-    //~| WARNING floating point constants cannot be used\n-    //~| WARNING this was previously accepted\n+\n     match [x, 1.0] {\n-        [NAN, _] => {},\n+        [NAN, _] => {}, //~ ERROR floating point constants cannot be used\n+                        //~| WARNING hard error\n         _ => {},\n     };\n-    //~^^^ WARNING unmatchable NaN in pattern, use the is_nan method in a guard instead\n-    //~| WARNING floating point constants cannot be used\n-    //~| WARNING this was previously accepted\n }"}, {"sha": "86323656b873e0db44604c1d95bf5556b3be60fc", "filename": "src/test/compile-fail/match-byte-array-patterns.rs", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/4a584637b0081c96c53c6048fd3715912c94a59b/src%2Ftest%2Fcompile-fail%2Fmatch-byte-array-patterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a584637b0081c96c53c6048fd3715912c94a59b/src%2Ftest%2Fcompile-fail%2Fmatch-byte-array-patterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmatch-byte-array-patterns.rs?ref=4a584637b0081c96c53c6048fd3715912c94a59b", "patch": "@@ -0,0 +1,73 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(advanced_slice_patterns, slice_patterns)]\n+\n+fn main() {\n+    let buf = &[0, 1, 2, 3];\n+\n+    match buf {\n+        b\"AAAA\" => {},\n+        &[0x41, 0x41, 0x41, 0x41] => {} //~ ERROR unreachable pattern\n+        _ => {}\n+    }\n+\n+    match buf {\n+        &[0x41, 0x41, 0x41, 0x41] => {}\n+        b\"AAAA\" => {}, //~ ERROR unreachable pattern\n+        _ => {}\n+    }\n+\n+    match buf {\n+        &[_, 0x41, 0x41, 0x41] => {},\n+        b\"AAAA\" => {}, //~ ERROR unreachable pattern\n+        _ => {}\n+    }\n+\n+    match buf {\n+        &[0x41, .., 0x41] => {}\n+        b\"AAAA\" => {}, //~ ERROR unreachable pattern\n+        _ => {}\n+    }\n+\n+    match buf { //~ ERROR non-exhaustive\n+        b\"AAAA\" => {}\n+    }\n+\n+    let buf: &[u8] = buf;\n+\n+    match buf {\n+        b\"AAAA\" => {},\n+        &[0x41, 0x41, 0x41, 0x41] => {} //~ ERROR unreachable pattern\n+        _ => {}\n+    }\n+\n+    match buf {\n+        &[0x41, 0x41, 0x41, 0x41] => {}\n+        b\"AAAA\" => {}, //~ ERROR unreachable pattern\n+        _ => {}\n+    }\n+\n+    match buf {\n+        &[_, 0x41, 0x41, 0x41] => {},\n+        b\"AAAA\" => {}, //~ ERROR unreachable pattern\n+        _ => {}\n+    }\n+\n+    match buf {\n+        &[0x41, .., 0x41] => {}\n+        b\"AAAA\" => {}, //~ ERROR unreachable pattern\n+        _ => {}\n+    }\n+\n+    match buf { //~ ERROR non-exhaustive\n+        b\"AAAA\" => {}\n+    }\n+}"}, {"sha": "dbfe588fb0c6a3788c2e0221bbad538e72c2b475", "filename": "src/test/run-pass/match-byte-array-patterns.rs", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/4a584637b0081c96c53c6048fd3715912c94a59b/src%2Ftest%2Frun-pass%2Fmatch-byte-array-patterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a584637b0081c96c53c6048fd3715912c94a59b/src%2Ftest%2Frun-pass%2Fmatch-byte-array-patterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmatch-byte-array-patterns.rs?ref=4a584637b0081c96c53c6048fd3715912c94a59b", "patch": "@@ -0,0 +1,54 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(slice_patterns)]\n+\n+fn main() {\n+    let buf = &[0u8; 4];\n+    match buf {\n+        &[0, 1, 0, 0] => unimplemented!(),\n+        b\"true\" => unimplemented!(),\n+        _ => {}\n+    }\n+\n+    match buf {\n+        b\"true\" => unimplemented!(),\n+        &[0, 1, 0, 0] => unimplemented!(),\n+        _ => {}\n+    }\n+\n+    match buf {\n+        b\"true\" => unimplemented!(),\n+        &[0, x, 0, 0] => assert_eq!(x, 0),\n+        _ => unimplemented!(),\n+    }\n+\n+    let buf: &[u8] = buf;\n+\n+    match buf {\n+        &[0, 1, 0, 0] => unimplemented!(),\n+        &[_] => unimplemented!(),\n+        &[_, _, _, _, _, ..] => unimplemented!(),\n+        b\"true\" => unimplemented!(),\n+        _ => {}\n+    }\n+\n+    match buf {\n+        b\"true\" => unimplemented!(),\n+        &[0, 1, 0, 0] => unimplemented!(),\n+        _ => {}\n+    }\n+\n+    match buf {\n+        b\"true\" => unimplemented!(),\n+        &[0, x, 0, 0] => assert_eq!(x, 0),\n+        _ => unimplemented!(),\n+    }\n+}"}, {"sha": "bd0731a555cb6d80feef08a5c33d975580936f2b", "filename": "src/test/run-pass/vec-matching.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/4a584637b0081c96c53c6048fd3715912c94a59b/src%2Ftest%2Frun-pass%2Fvec-matching.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a584637b0081c96c53c6048fd3715912c94a59b/src%2Ftest%2Frun-pass%2Fvec-matching.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvec-matching.rs?ref=4a584637b0081c96c53c6048fd3715912c94a59b", "patch": "@@ -144,11 +144,26 @@ fn e() {\n     assert_eq!(c, 1);\n }\n \n+fn f() {\n+    let x = &[1, 2, 3, 4, 5];\n+    let [a, [b, [c, ..].., d].., e] = *x;\n+    assert_eq!((a, b, c, d, e), (1, 2, 3, 4, 5));\n+\n+    let x: &[isize] = x;\n+    let (a, b, c, d, e) = match *x {\n+        [a, [b, [c, ..].., d].., e] => (a, b, c, d, e),\n+        _ => unimplemented!()\n+    };\n+\n+    assert_eq!((a, b, c, d, e), (1, 2, 3, 4, 5));\n+}\n+\n pub fn main() {\n     a();\n     b();\n     b_slice();\n     c();\n     d();\n     e();\n+    f();\n }"}, {"sha": "6497f69035dec96497fa8736964f1f8becd3966f", "filename": "src/test/ui/check_match/issue-35609.rs", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/4a584637b0081c96c53c6048fd3715912c94a59b/src%2Ftest%2Fui%2Fcheck_match%2Fissue-35609.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a584637b0081c96c53c6048fd3715912c94a59b/src%2Ftest%2Fui%2Fcheck_match%2Fissue-35609.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcheck_match%2Fissue-35609.rs?ref=4a584637b0081c96c53c6048fd3715912c94a59b", "patch": "@@ -0,0 +1,53 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+enum Enum {\n+    A, B, C, D, E, F\n+}\n+use Enum::*;\n+\n+struct S(Enum, ());\n+struct Sd { x: Enum, y: () }\n+\n+fn main() {\n+    match (A, ()) {\n+        (A, _) => {}\n+    }\n+\n+    match (A, A) {\n+        (_, A) => {}\n+    }\n+\n+    match ((A, ()), ()) {\n+        ((A, ()), _) => {}\n+    }\n+\n+    match ((A, ()), A) {\n+        ((A, ()), _) => {}\n+    }\n+\n+    match ((A, ()), ()) {\n+        ((A, _), _) => {}\n+    }\n+\n+\n+    match S(A, ()) {\n+        S(A, _) => {}\n+    }\n+\n+    match (Sd { x: A, y: () }) {\n+        Sd { x: A, y: _ } => {}\n+    }\n+\n+    match Some(A) {\n+        Some(A) => (),\n+        None => ()\n+    }\n+}"}, {"sha": "66069c7a86a344a25a7c26cdce8bb5c842756f47", "filename": "src/test/ui/check_match/issue-35609.stderr", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/4a584637b0081c96c53c6048fd3715912c94a59b/src%2Ftest%2Fui%2Fcheck_match%2Fissue-35609.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4a584637b0081c96c53c6048fd3715912c94a59b/src%2Ftest%2Fui%2Fcheck_match%2Fissue-35609.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcheck_match%2Fissue-35609.stderr?ref=4a584637b0081c96c53c6048fd3715912c94a59b", "patch": "@@ -0,0 +1,50 @@\n+error[E0004]: non-exhaustive patterns: `(B, _)`, `(C, _)`, `(D, _)` and 2 more not covered\n+  --> $DIR/issue-35609.rs:20:11\n+   |\n+20 |     match (A, ()) {\n+   |           ^^^^^^^ patterns `(B, _)`, `(C, _)`, `(D, _)` and 2 more not covered\n+\n+error[E0004]: non-exhaustive patterns: `(A, B)`, `(B, B)`, `(C, B)` and 27 more not covered\n+  --> $DIR/issue-35609.rs:24:11\n+   |\n+24 |     match (A, A) {\n+   |           ^^^^^^ patterns `(A, B)`, `(B, B)`, `(C, B)` and 27 more not covered\n+\n+error[E0004]: non-exhaustive patterns: `((B, _), _)`, `((C, _), _)`, `((D, _), _)` and 2 more not covered\n+  --> $DIR/issue-35609.rs:28:11\n+   |\n+28 |     match ((A, ()), ()) {\n+   |           ^^^^^^^^^^^^^ patterns `((B, _), _)`, `((C, _), _)`, `((D, _), _)` and 2 more not covered\n+\n+error[E0004]: non-exhaustive patterns: `((B, _), _)`, `((C, _), _)`, `((D, _), _)` and 2 more not covered\n+  --> $DIR/issue-35609.rs:32:11\n+   |\n+32 |     match ((A, ()), A) {\n+   |           ^^^^^^^^^^^^ patterns `((B, _), _)`, `((C, _), _)`, `((D, _), _)` and 2 more not covered\n+\n+error[E0004]: non-exhaustive patterns: `((B, _), _)`, `((C, _), _)`, `((D, _), _)` and 2 more not covered\n+  --> $DIR/issue-35609.rs:36:11\n+   |\n+36 |     match ((A, ()), ()) {\n+   |           ^^^^^^^^^^^^^ patterns `((B, _), _)`, `((C, _), _)`, `((D, _), _)` and 2 more not covered\n+\n+error[E0004]: non-exhaustive patterns: `S(B, _)`, `S(C, _)`, `S(D, _)` and 2 more not covered\n+  --> $DIR/issue-35609.rs:41:11\n+   |\n+41 |     match S(A, ()) {\n+   |           ^^^^^^^^ patterns `S(B, _)`, `S(C, _)`, `S(D, _)` and 2 more not covered\n+\n+error[E0004]: non-exhaustive patterns: `Sd { x: B, .. }`, `Sd { x: C, .. }`, `Sd { x: D, .. }` and 2 more not covered\n+  --> $DIR/issue-35609.rs:45:11\n+   |\n+45 |     match (Sd { x: A, y: () }) {\n+   |           ^^^^^^^^^^^^^^^^^^^^ patterns `Sd { x: B, .. }`, `Sd { x: C, .. }`, `Sd { x: D, .. }` and 2 more not covered\n+\n+error[E0004]: non-exhaustive patterns: `Some(B)`, `Some(C)`, `Some(D)` and 2 more not covered\n+  --> $DIR/issue-35609.rs:49:11\n+   |\n+49 |     match Some(A) {\n+   |           ^^^^^^^ patterns `Some(B)`, `Some(C)`, `Some(D)` and 2 more not covered\n+\n+error: aborting due to 8 previous errors\n+"}]}