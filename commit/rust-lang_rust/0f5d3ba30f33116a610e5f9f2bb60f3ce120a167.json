{"sha": "0f5d3ba30f33116a610e5f9f2bb60f3ce120a167", "node_id": "C_kwDOAAsO6NoAKDBmNWQzYmEzMGYzMzExNmE2MTBlNWY5ZjJiYjYwZjNjZTEyMGExNjc", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-12-10T08:24:41Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-12-10T08:24:41Z"}, "message": "Rollup merge of #104019 - compiler-errors:print-generator-sizes, r=wesleywiser\n\nCompute generator sizes with `-Zprint_type_sizes`\n\nFixes #103887\nr? `@pnkfelix`", "tree": {"sha": "f5505e44581251ae18020d829d39f47bcf91369b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f5505e44581251ae18020d829d39f47bcf91369b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0f5d3ba30f33116a610e5f9f2bb60f3ce120a167", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjlEJJCRBK7hj4Ov3rIwAAKdwIAHRZY5PNQQ976eUl4oxkLT59\n9gtkkTe4yivuGxSfTsqDg6XSpBkCvotRWsoSlNBMXOYgSvs8ge7mwUYVf6dRNerg\nRvICI1Xi8njZPS9DoI1TICbDzTvEOw7M0gLyxsvaaEn3zbYlXZ4WT5ltXno5LTig\nRIeIdQpXjJMuTui80ihS6Cm/q3Mh7MYUeyN0U6V+yZMB8lxWoL7TpeQo4pQxjvss\nTo66HmCELSN294M0Xz8zVKS32kh1ifLYEGWeePT5Jw38Xo8A73D/x8A6ug/vyMBu\nttS8qaWFgYev2GRgBOuSmOJY/dJnAHPriJHPUasULqNjnBrEyCRk5u8I3f4UyKk=\n=b5nE\n-----END PGP SIGNATURE-----\n", "payload": "tree f5505e44581251ae18020d829d39f47bcf91369b\nparent ae8794ce6a7180aa81c718172321ac704e94f342\nparent 7d23e29f9fb61985aca0227acbabb62f95208c01\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1670660681 +0100\ncommitter GitHub <noreply@github.com> 1670660681 +0100\n\nRollup merge of #104019 - compiler-errors:print-generator-sizes, r=wesleywiser\n\nCompute generator sizes with `-Zprint_type_sizes`\n\nFixes #103887\nr? `@pnkfelix`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0f5d3ba30f33116a610e5f9f2bb60f3ce120a167", "html_url": "https://github.com/rust-lang/rust/commit/0f5d3ba30f33116a610e5f9f2bb60f3ce120a167", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0f5d3ba30f33116a610e5f9f2bb60f3ce120a167/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ae8794ce6a7180aa81c718172321ac704e94f342", "url": "https://api.github.com/repos/rust-lang/rust/commits/ae8794ce6a7180aa81c718172321ac704e94f342", "html_url": "https://github.com/rust-lang/rust/commit/ae8794ce6a7180aa81c718172321ac704e94f342"}, {"sha": "7d23e29f9fb61985aca0227acbabb62f95208c01", "url": "https://api.github.com/repos/rust-lang/rust/commits/7d23e29f9fb61985aca0227acbabb62f95208c01", "html_url": "https://github.com/rust-lang/rust/commit/7d23e29f9fb61985aca0227acbabb62f95208c01"}], "stats": {"total": 390, "additions": 286, "deletions": 104}, "files": [{"sha": "a9e3dcf4cb39a7c56663f6bb271c82e0003ea71f", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/metadata.rs", "status": "modified", "additions": 1, "deletions": 67, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/0f5d3ba30f33116a610e5f9f2bb60f3ce120a167/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f5d3ba30f33116a610e5f9f2bb60f3ce120a167/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs?ref=0f5d3ba30f33116a610e5f9f2bb60f3ce120a167", "patch": "@@ -27,9 +27,7 @@ use rustc_codegen_ssa::traits::*;\n use rustc_fs_util::path_to_c_string;\n use rustc_hir::def::CtorKind;\n use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n-use rustc_index::vec::{Idx, IndexVec};\n use rustc_middle::bug;\n-use rustc_middle::mir::{self, GeneratorLayout};\n use rustc_middle::ty::layout::{LayoutOf, TyAndLayout};\n use rustc_middle::ty::subst::GenericArgKind;\n use rustc_middle::ty::{\n@@ -1026,33 +1024,6 @@ fn build_struct_type_di_node<'ll, 'tcx>(\n // Tuples\n //=-----------------------------------------------------------------------------\n \n-/// Returns names of captured upvars for closures and generators.\n-///\n-/// Here are some examples:\n-///  - `name__field1__field2` when the upvar is captured by value.\n-///  - `_ref__name__field` when the upvar is captured by reference.\n-///\n-/// For generators this only contains upvars that are shared by all states.\n-fn closure_saved_names_of_captured_variables(tcx: TyCtxt<'_>, def_id: DefId) -> SmallVec<String> {\n-    let body = tcx.optimized_mir(def_id);\n-\n-    body.var_debug_info\n-        .iter()\n-        .filter_map(|var| {\n-            let is_ref = match var.value {\n-                mir::VarDebugInfoContents::Place(place) if place.local == mir::Local::new(1) => {\n-                    // The projection is either `[.., Field, Deref]` or `[.., Field]`. It\n-                    // implies whether the variable is captured by value or by reference.\n-                    matches!(place.projection.last().unwrap(), mir::ProjectionElem::Deref)\n-                }\n-                _ => return None,\n-            };\n-            let prefix = if is_ref { \"_ref__\" } else { \"\" };\n-            Some(prefix.to_owned() + var.name.as_str())\n-        })\n-        .collect()\n-}\n-\n /// Builds the DW_TAG_member debuginfo nodes for the upvars of a closure or generator.\n /// For a generator, this will handle upvars shared by all states.\n fn build_upvar_field_di_nodes<'ll, 'tcx>(\n@@ -1083,7 +1054,7 @@ fn build_upvar_field_di_nodes<'ll, 'tcx>(\n             .all(|&t| t == cx.tcx.normalize_erasing_regions(ParamEnv::reveal_all(), t))\n     );\n \n-    let capture_names = closure_saved_names_of_captured_variables(cx.tcx, def_id);\n+    let capture_names = cx.tcx.closure_saved_names_of_captured_variables(def_id);\n     let layout = cx.layout_of(closure_or_generator_ty);\n \n     up_var_tys\n@@ -1229,43 +1200,6 @@ fn build_union_type_di_node<'ll, 'tcx>(\n     )\n }\n \n-// FIXME(eddyb) maybe precompute this? Right now it's computed once\n-// per generator monomorphization, but it doesn't depend on substs.\n-fn generator_layout_and_saved_local_names<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    def_id: DefId,\n-) -> (&'tcx GeneratorLayout<'tcx>, IndexVec<mir::GeneratorSavedLocal, Option<Symbol>>) {\n-    let body = tcx.optimized_mir(def_id);\n-    let generator_layout = body.generator_layout().unwrap();\n-    let mut generator_saved_local_names = IndexVec::from_elem(None, &generator_layout.field_tys);\n-\n-    let state_arg = mir::Local::new(1);\n-    for var in &body.var_debug_info {\n-        let mir::VarDebugInfoContents::Place(place) = &var.value else { continue };\n-        if place.local != state_arg {\n-            continue;\n-        }\n-        match place.projection[..] {\n-            [\n-                // Deref of the `Pin<&mut Self>` state argument.\n-                mir::ProjectionElem::Field(..),\n-                mir::ProjectionElem::Deref,\n-                // Field of a variant of the state.\n-                mir::ProjectionElem::Downcast(_, variant),\n-                mir::ProjectionElem::Field(field, _),\n-            ] => {\n-                let name = &mut generator_saved_local_names\n-                    [generator_layout.variant_fields[variant][field]];\n-                if name.is_none() {\n-                    name.replace(var.name);\n-                }\n-            }\n-            _ => {}\n-        }\n-    }\n-    (generator_layout, generator_saved_local_names)\n-}\n-\n /// Computes the type parameters for a type, if any, for the given metadata.\n fn build_generic_type_param_di_nodes<'ll, 'tcx>(\n     cx: &CodegenCx<'ll, 'tcx>,"}, {"sha": "69443b9b828e2caf3a19ba382557c3431ada8169", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/metadata/enums/cpp_like.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0f5d3ba30f33116a610e5f9f2bb60f3ce120a167/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata%2Fenums%2Fcpp_like.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f5d3ba30f33116a610e5f9f2bb60f3ce120a167/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata%2Fenums%2Fcpp_like.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata%2Fenums%2Fcpp_like.rs?ref=0f5d3ba30f33116a610e5f9f2bb60f3ce120a167", "patch": "@@ -22,9 +22,9 @@ use crate::{\n     common::CodegenCx,\n     debuginfo::{\n         metadata::{\n-            build_field_di_node, closure_saved_names_of_captured_variables,\n+            build_field_di_node,\n             enums::{tag_base_type, DiscrResult},\n-            file_metadata, generator_layout_and_saved_local_names, size_and_align_of, type_di_node,\n+            file_metadata, size_and_align_of, type_di_node,\n             type_map::{self, Stub, UniqueTypeId},\n             unknown_file_metadata, DINodeCreationResult, SmallVec, NO_GENERICS, NO_SCOPE_METADATA,\n             UNKNOWN_LINE_NUMBER,\n@@ -677,9 +677,9 @@ fn build_union_fields_for_direct_tag_generator<'ll, 'tcx>(\n     };\n \n     let (generator_layout, state_specific_upvar_names) =\n-        generator_layout_and_saved_local_names(cx.tcx, generator_def_id);\n+        cx.tcx.generator_layout_and_saved_local_names(generator_def_id);\n \n-    let common_upvar_names = closure_saved_names_of_captured_variables(cx.tcx, generator_def_id);\n+    let common_upvar_names = cx.tcx.closure_saved_names_of_captured_variables(generator_def_id);\n     let variant_range = generator_substs.variant_range(generator_def_id, cx.tcx);\n     let variant_count = (variant_range.start.as_u32()..variant_range.end.as_u32()).len();\n "}, {"sha": "93419d27a6236c5356a1a4045c7e05b0225794a6", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/metadata/enums/native.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0f5d3ba30f33116a610e5f9f2bb60f3ce120a167/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata%2Fenums%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f5d3ba30f33116a610e5f9f2bb60f3ce120a167/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata%2Fenums%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata%2Fenums%2Fnative.rs?ref=0f5d3ba30f33116a610e5f9f2bb60f3ce120a167", "patch": "@@ -4,9 +4,8 @@ use crate::{\n     common::CodegenCx,\n     debuginfo::{\n         metadata::{\n-            closure_saved_names_of_captured_variables,\n             enums::tag_base_type,\n-            file_metadata, generator_layout_and_saved_local_names, size_and_align_of, type_di_node,\n+            file_metadata, size_and_align_of, type_di_node,\n             type_map::{self, Stub, StubInfo, UniqueTypeId},\n             unknown_file_metadata, DINodeCreationResult, SmallVec, NO_GENERICS,\n             UNKNOWN_LINE_NUMBER,\n@@ -157,7 +156,7 @@ pub(super) fn build_generator_di_node<'ll, 'tcx>(\n         ),\n         |cx, generator_type_di_node| {\n             let (generator_layout, state_specific_upvar_names) =\n-                generator_layout_and_saved_local_names(cx.tcx, generator_def_id);\n+                cx.tcx.generator_layout_and_saved_local_names(generator_def_id);\n \n             let Variants::Multiple { tag_encoding: TagEncoding::Direct, ref variants, .. } = generator_type_and_layout.variants else {\n                 bug!(\n@@ -167,7 +166,7 @@ pub(super) fn build_generator_di_node<'ll, 'tcx>(\n             };\n \n             let common_upvar_names =\n-                closure_saved_names_of_captured_variables(cx.tcx, generator_def_id);\n+                cx.tcx.closure_saved_names_of_captured_variables(generator_def_id);\n \n             // Build variant struct types\n             let variant_struct_type_di_nodes: SmallVec<_> = variants"}, {"sha": "9ea8dc6e69fdde0b172103282cd1c384bd3fb5b2", "filename": "compiler/rustc_middle/src/ty/util.rs", "status": "modified", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/0f5d3ba30f33116a610e5f9f2bb60f3ce120a167/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f5d3ba30f33116a610e5f9f2bb60f3ce120a167/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs?ref=0f5d3ba30f33116a610e5f9f2bb60f3ce120a167", "patch": "@@ -1,6 +1,7 @@\n //! Miscellaneous type-system utilities that are too small to deserve their own modules.\n \n use crate::middle::codegen_fn_attrs::CodegenFnAttrFlags;\n+use crate::mir;\n use crate::ty::layout::IntegerExt;\n use crate::ty::{\n     self, DefIdTree, FallibleTypeFolder, Ty, TyCtxt, TypeFoldable, TypeFolder, TypeSuperFoldable,\n@@ -15,6 +16,7 @@ use rustc_hir as hir;\n use rustc_hir::def::{CtorOf, DefKind, Res};\n use rustc_hir::def_id::DefId;\n use rustc_index::bit_set::GrowableBitSet;\n+use rustc_index::vec::{Idx, IndexVec};\n use rustc_macros::HashStable;\n use rustc_span::{sym, DUMMY_SP};\n use rustc_target::abi::{Integer, IntegerType, Size, TargetDataLayout};\n@@ -692,6 +694,80 @@ impl<'tcx> TyCtxt<'tcx> {\n     pub fn bound_impl_subject(self, def_id: DefId) -> ty::EarlyBinder<ty::ImplSubject<'tcx>> {\n         ty::EarlyBinder(self.impl_subject(def_id))\n     }\n+\n+    /// Returns names of captured upvars for closures and generators.\n+    ///\n+    /// Here are some examples:\n+    ///  - `name__field1__field2` when the upvar is captured by value.\n+    ///  - `_ref__name__field` when the upvar is captured by reference.\n+    ///\n+    /// For generators this only contains upvars that are shared by all states.\n+    pub fn closure_saved_names_of_captured_variables(\n+        self,\n+        def_id: DefId,\n+    ) -> SmallVec<[String; 16]> {\n+        let body = self.optimized_mir(def_id);\n+\n+        body.var_debug_info\n+            .iter()\n+            .filter_map(|var| {\n+                let is_ref = match var.value {\n+                    mir::VarDebugInfoContents::Place(place)\n+                        if place.local == mir::Local::new(1) =>\n+                    {\n+                        // The projection is either `[.., Field, Deref]` or `[.., Field]`. It\n+                        // implies whether the variable is captured by value or by reference.\n+                        matches!(place.projection.last().unwrap(), mir::ProjectionElem::Deref)\n+                    }\n+                    _ => return None,\n+                };\n+                let prefix = if is_ref { \"_ref__\" } else { \"\" };\n+                Some(prefix.to_owned() + var.name.as_str())\n+            })\n+            .collect()\n+    }\n+\n+    // FIXME(eddyb) maybe precompute this? Right now it's computed once\n+    // per generator monomorphization, but it doesn't depend on substs.\n+    pub fn generator_layout_and_saved_local_names(\n+        self,\n+        def_id: DefId,\n+    ) -> (\n+        &'tcx ty::GeneratorLayout<'tcx>,\n+        IndexVec<mir::GeneratorSavedLocal, Option<rustc_span::Symbol>>,\n+    ) {\n+        let tcx = self;\n+        let body = tcx.optimized_mir(def_id);\n+        let generator_layout = body.generator_layout().unwrap();\n+        let mut generator_saved_local_names =\n+            IndexVec::from_elem(None, &generator_layout.field_tys);\n+\n+        let state_arg = mir::Local::new(1);\n+        for var in &body.var_debug_info {\n+            let mir::VarDebugInfoContents::Place(place) = &var.value else { continue };\n+            if place.local != state_arg {\n+                continue;\n+            }\n+            match place.projection[..] {\n+                [\n+                    // Deref of the `Pin<&mut Self>` state argument.\n+                    mir::ProjectionElem::Field(..),\n+                    mir::ProjectionElem::Deref,\n+                    // Field of a variant of the state.\n+                    mir::ProjectionElem::Downcast(_, variant),\n+                    mir::ProjectionElem::Field(field, _),\n+                ] => {\n+                    let name = &mut generator_saved_local_names\n+                        [generator_layout.variant_fields[variant][field]];\n+                    if name.is_none() {\n+                        name.replace(var.name);\n+                    }\n+                }\n+                _ => {}\n+            }\n+        }\n+        (generator_layout, generator_saved_local_names)\n+    }\n }\n \n struct OpaqueTypeExpander<'tcx> {"}, {"sha": "1085bce44758fe7235929e8c7ca2b703f23cbae3", "filename": "compiler/rustc_session/src/code_stats.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0f5d3ba30f33116a610e5f9f2bb60f3ce120a167/compiler%2Frustc_session%2Fsrc%2Fcode_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f5d3ba30f33116a610e5f9f2bb60f3ce120a167/compiler%2Frustc_session%2Fsrc%2Fcode_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fcode_stats.rs?ref=0f5d3ba30f33116a610e5f9f2bb60f3ce120a167", "patch": "@@ -19,7 +19,7 @@ pub enum SizeKind {\n     Min,\n }\n \n-#[derive(Clone, PartialEq, Eq, Hash, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n pub struct FieldInfo {\n     pub name: Symbol,\n     pub offset: u64,\n@@ -33,6 +33,7 @@ pub enum DataTypeKind {\n     Union,\n     Enum,\n     Closure,\n+    Generator,\n }\n \n #[derive(PartialEq, Eq, Hash, Debug)]\n@@ -114,7 +115,7 @@ impl CodeStats {\n \n             let struct_like = match kind {\n                 DataTypeKind::Struct | DataTypeKind::Closure => true,\n-                DataTypeKind::Enum | DataTypeKind::Union => false,\n+                DataTypeKind::Enum | DataTypeKind::Union | DataTypeKind::Generator => false,\n             };\n             for (i, variant_info) in variants.into_iter().enumerate() {\n                 let VariantInfo { ref name, kind: _, align: _, size, ref fields } = *variant_info;"}, {"sha": "f4672a70072b2b30ce8435d350d898bfa2e8c4c3", "filename": "compiler/rustc_ty_utils/src/layout.rs", "status": "modified", "additions": 116, "deletions": 27, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/0f5d3ba30f33116a610e5f9f2bb60f3ce120a167/compiler%2Frustc_ty_utils%2Fsrc%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f5d3ba30f33116a610e5f9f2bb60f3ce120a167/compiler%2Frustc_ty_utils%2Fsrc%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Flayout.rs?ref=0f5d3ba30f33116a610e5f9f2bb60f3ce120a167", "patch": "@@ -1,3 +1,4 @@\n+use hir::def_id::DefId;\n use rustc_hir as hir;\n use rustc_index::bit_set::BitSet;\n use rustc_index::vec::{Idx, IndexVec};\n@@ -6,7 +7,7 @@ use rustc_middle::ty::layout::{\n     IntegerExt, LayoutCx, LayoutError, LayoutOf, TyAndLayout, MAX_SIMD_LANES,\n };\n use rustc_middle::ty::{\n-    self, subst::SubstsRef, EarlyBinder, ReprOptions, Ty, TyCtxt, TypeVisitable,\n+    self, subst::SubstsRef, AdtDef, EarlyBinder, ReprOptions, Ty, TyCtxt, TypeVisitable,\n };\n use rustc_session::{DataTypeKind, FieldInfo, SizeKind, VariantInfo};\n use rustc_span::symbol::Symbol;\n@@ -814,27 +815,39 @@ fn record_layout_for_printing_outlined<'tcx>(\n         );\n     };\n \n-    let adt_def = match *layout.ty.kind() {\n-        ty::Adt(ref adt_def, _) => {\n+    match *layout.ty.kind() {\n+        ty::Adt(adt_def, _) => {\n             debug!(\"print-type-size t: `{:?}` process adt\", layout.ty);\n-            adt_def\n+            let adt_kind = adt_def.adt_kind();\n+            let adt_packed = adt_def.repr().pack.is_some();\n+            let (variant_infos, opt_discr_size) = variant_info_for_adt(cx, layout, adt_def);\n+            record(adt_kind.into(), adt_packed, opt_discr_size, variant_infos);\n+        }\n+\n+        ty::Generator(def_id, substs, _) => {\n+            debug!(\"print-type-size t: `{:?}` record generator\", layout.ty);\n+            // Generators always have a begin/poisoned/end state with additional suspend points\n+            let (variant_infos, opt_discr_size) =\n+                variant_info_for_generator(cx, layout, def_id, substs);\n+            record(DataTypeKind::Generator, false, opt_discr_size, variant_infos);\n         }\n \n         ty::Closure(..) => {\n             debug!(\"print-type-size t: `{:?}` record closure\", layout.ty);\n             record(DataTypeKind::Closure, false, None, vec![]);\n-            return;\n         }\n \n         _ => {\n             debug!(\"print-type-size t: `{:?}` skip non-nominal\", layout.ty);\n-            return;\n         }\n     };\n+}\n \n-    let adt_kind = adt_def.adt_kind();\n-    let adt_packed = adt_def.repr().pack.is_some();\n-\n+fn variant_info_for_adt<'tcx>(\n+    cx: &LayoutCx<'tcx, TyCtxt<'tcx>>,\n+    layout: TyAndLayout<'tcx>,\n+    adt_def: AdtDef<'tcx>,\n+) -> (Vec<VariantInfo>, Option<Size>) {\n     let build_variant_info = |n: Option<Symbol>, flds: &[Symbol], layout: TyAndLayout<'tcx>| {\n         let mut min_size = Size::ZERO;\n         let field_info: Vec<_> = flds\n@@ -843,10 +856,7 @@ fn record_layout_for_printing_outlined<'tcx>(\n             .map(|(i, &name)| {\n                 let field_layout = layout.field(cx, i);\n                 let offset = layout.fields.offset(i);\n-                let field_end = offset + field_layout.size;\n-                if min_size < field_end {\n-                    min_size = field_end;\n-                }\n+                min_size = min_size.max(offset + field_layout.size);\n                 FieldInfo {\n                     name,\n                     offset: offset.bytes(),\n@@ -871,16 +881,9 @@ fn record_layout_for_printing_outlined<'tcx>(\n                 debug!(\"print-type-size `{:#?}` variant {}\", layout, adt_def.variant(index).name);\n                 let variant_def = &adt_def.variant(index);\n                 let fields: Vec<_> = variant_def.fields.iter().map(|f| f.name).collect();\n-                record(\n-                    adt_kind.into(),\n-                    adt_packed,\n-                    None,\n-                    vec![build_variant_info(Some(variant_def.name), &fields, layout)],\n-                );\n+                (vec![build_variant_info(Some(variant_def.name), &fields, layout)], None)\n             } else {\n-                // (This case arises for *empty* enums; so give it\n-                // zero variants.)\n-                record(adt_kind.into(), adt_packed, None, vec![]);\n+                (vec![], None)\n             }\n         }\n \n@@ -898,15 +901,101 @@ fn record_layout_for_printing_outlined<'tcx>(\n                     build_variant_info(Some(variant_def.name), &fields, layout.for_variant(cx, i))\n                 })\n                 .collect();\n-            record(\n-                adt_kind.into(),\n-                adt_packed,\n+\n+            (\n+                variant_infos,\n                 match tag_encoding {\n                     TagEncoding::Direct => Some(tag.size(cx)),\n                     _ => None,\n                 },\n-                variant_infos,\n-            );\n+            )\n         }\n     }\n }\n+\n+fn variant_info_for_generator<'tcx>(\n+    cx: &LayoutCx<'tcx, TyCtxt<'tcx>>,\n+    layout: TyAndLayout<'tcx>,\n+    def_id: DefId,\n+    substs: ty::SubstsRef<'tcx>,\n+) -> (Vec<VariantInfo>, Option<Size>) {\n+    let Variants::Multiple { tag, ref tag_encoding, .. } = layout.variants else {\n+        return (vec![], None);\n+    };\n+\n+    let (generator, state_specific_names) = cx.tcx.generator_layout_and_saved_local_names(def_id);\n+    let upvar_names = cx.tcx.closure_saved_names_of_captured_variables(def_id);\n+\n+    let mut upvars_size = Size::ZERO;\n+    let upvar_fields: Vec<_> = substs\n+        .as_generator()\n+        .upvar_tys()\n+        .zip(upvar_names)\n+        .enumerate()\n+        .map(|(field_idx, (_, name))| {\n+            let field_layout = layout.field(cx, field_idx);\n+            let offset = layout.fields.offset(field_idx);\n+            upvars_size = upvars_size.max(offset + field_layout.size);\n+            FieldInfo {\n+                name: Symbol::intern(&name),\n+                offset: offset.bytes(),\n+                size: field_layout.size.bytes(),\n+                align: field_layout.align.abi.bytes(),\n+            }\n+        })\n+        .collect();\n+\n+    let variant_infos: Vec<_> = generator\n+        .variant_fields\n+        .iter_enumerated()\n+        .map(|(variant_idx, variant_def)| {\n+            let variant_layout = layout.for_variant(cx, variant_idx);\n+            let mut variant_size = Size::ZERO;\n+            let fields = variant_def\n+                .iter()\n+                .enumerate()\n+                .map(|(field_idx, local)| {\n+                    let field_layout = variant_layout.field(cx, field_idx);\n+                    let offset = variant_layout.fields.offset(field_idx);\n+                    // The struct is as large as the last field's end\n+                    variant_size = variant_size.max(offset + field_layout.size);\n+                    FieldInfo {\n+                        name: state_specific_names.get(*local).copied().flatten().unwrap_or(\n+                            Symbol::intern(&format!(\".generator_field{}\", local.as_usize())),\n+                        ),\n+                        offset: offset.bytes(),\n+                        size: field_layout.size.bytes(),\n+                        align: field_layout.align.abi.bytes(),\n+                    }\n+                })\n+                .chain(upvar_fields.iter().copied())\n+                .collect();\n+\n+            // If the variant has no state-specific fields, then it's the size of the upvars.\n+            if variant_size == Size::ZERO {\n+                variant_size = upvars_size;\n+            }\n+            // We need to add the discriminant size back into min_size, since it is subtracted\n+            // later during printing.\n+            variant_size += match tag_encoding {\n+                TagEncoding::Direct => tag.size(cx),\n+                _ => Size::ZERO,\n+            };\n+\n+            VariantInfo {\n+                name: Some(Symbol::intern(&ty::GeneratorSubsts::variant_name(variant_idx))),\n+                kind: SizeKind::Exact,\n+                size: variant_size.bytes(),\n+                align: variant_layout.align.abi.bytes(),\n+                fields,\n+            }\n+        })\n+        .collect();\n+    (\n+        variant_infos,\n+        match tag_encoding {\n+            TagEncoding::Direct => Some(tag.size(cx)),\n+            _ => None,\n+        },\n+    )\n+}"}, {"sha": "3491ad5afbc1501100d192a234e567a7f892bf47", "filename": "src/test/ui/print_type_sizes/async.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/0f5d3ba30f33116a610e5f9f2bb60f3ce120a167/src%2Ftest%2Fui%2Fprint_type_sizes%2Fasync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f5d3ba30f33116a610e5f9f2bb60f3ce120a167/src%2Ftest%2Fui%2Fprint_type_sizes%2Fasync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprint_type_sizes%2Fasync.rs?ref=0f5d3ba30f33116a610e5f9f2bb60f3ce120a167", "patch": "@@ -0,0 +1,19 @@\n+// compile-flags: -Z print-type-sizes\n+// edition:2021\n+// build-pass\n+// ignore-pass\n+\n+#![feature(start)]\n+\n+async fn wait() {}\n+\n+async fn test(arg: [u8; 8192]) {\n+    wait().await;\n+    drop(arg);\n+}\n+\n+#[start]\n+fn start(_: isize, _: *const *const u8) -> isize {\n+    let _ = test([0; 8192]);\n+    0\n+}"}, {"sha": "94ad09ef296d3b15b713c3e5dc68adf8596671eb", "filename": "src/test/ui/print_type_sizes/async.stdout", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/0f5d3ba30f33116a610e5f9f2bb60f3ce120a167/src%2Ftest%2Fui%2Fprint_type_sizes%2Fasync.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/0f5d3ba30f33116a610e5f9f2bb60f3ce120a167/src%2Ftest%2Fui%2Fprint_type_sizes%2Fasync.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprint_type_sizes%2Fasync.stdout?ref=0f5d3ba30f33116a610e5f9f2bb60f3ce120a167", "patch": "@@ -0,0 +1,34 @@\n+print-type-size type: `[async fn body@$DIR/async.rs:10:32: 13:2]`: 16386 bytes, alignment: 1 bytes\n+print-type-size     discriminant: 1 bytes\n+print-type-size     variant `Suspend0`: 16385 bytes\n+print-type-size         field `.arg`: 8192 bytes, offset: 0 bytes, alignment: 1 bytes\n+print-type-size         field `.arg`: 8192 bytes\n+print-type-size         field `.__awaitee`: 1 bytes\n+print-type-size     variant `Unresumed`: 8192 bytes\n+print-type-size         field `.arg`: 8192 bytes, offset: 0 bytes, alignment: 1 bytes\n+print-type-size     variant `Returned`: 8192 bytes\n+print-type-size         field `.arg`: 8192 bytes, offset: 0 bytes, alignment: 1 bytes\n+print-type-size     variant `Panicked`: 8192 bytes\n+print-type-size         field `.arg`: 8192 bytes, offset: 0 bytes, alignment: 1 bytes\n+print-type-size type: `std::mem::ManuallyDrop<[u8; 8192]>`: 8192 bytes, alignment: 1 bytes\n+print-type-size     field `.value`: 8192 bytes\n+print-type-size type: `std::mem::MaybeUninit<[u8; 8192]>`: 8192 bytes, alignment: 1 bytes\n+print-type-size     variant `MaybeUninit`: 8192 bytes\n+print-type-size         field `.uninit`: 0 bytes\n+print-type-size         field `.value`: 8192 bytes\n+print-type-size type: `[async fn body@$DIR/async.rs:8:17: 8:19]`: 1 bytes, alignment: 1 bytes\n+print-type-size     discriminant: 1 bytes\n+print-type-size     variant `Unresumed`: 0 bytes\n+print-type-size     variant `Returned`: 0 bytes\n+print-type-size     variant `Panicked`: 0 bytes\n+print-type-size type: `std::mem::ManuallyDrop<[async fn body@$DIR/async.rs:8:17: 8:19]>`: 1 bytes, alignment: 1 bytes\n+print-type-size     field `.value`: 1 bytes\n+print-type-size type: `std::mem::MaybeUninit<[async fn body@$DIR/async.rs:8:17: 8:19]>`: 1 bytes, alignment: 1 bytes\n+print-type-size     variant `MaybeUninit`: 1 bytes\n+print-type-size         field `.uninit`: 0 bytes\n+print-type-size         field `.value`: 1 bytes\n+print-type-size type: `std::task::Poll<()>`: 1 bytes, alignment: 1 bytes\n+print-type-size     discriminant: 1 bytes\n+print-type-size     variant `Ready`: 0 bytes\n+print-type-size         field `.0`: 0 bytes\n+print-type-size     variant `Pending`: 0 bytes"}, {"sha": "a46db6121046b999834f4ab76759263a687accc4", "filename": "src/test/ui/print_type_sizes/generator.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/0f5d3ba30f33116a610e5f9f2bb60f3ce120a167/src%2Ftest%2Fui%2Fprint_type_sizes%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f5d3ba30f33116a610e5f9f2bb60f3ce120a167/src%2Ftest%2Fui%2Fprint_type_sizes%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprint_type_sizes%2Fgenerator.rs?ref=0f5d3ba30f33116a610e5f9f2bb60f3ce120a167", "patch": "@@ -0,0 +1,20 @@\n+// compile-flags: -Z print-type-sizes\n+// build-pass\n+// ignore-pass\n+\n+#![feature(start, generators, generator_trait)]\n+\n+use std::ops::Generator;\n+\n+fn generator<const C: usize>(array: [u8; C]) -> impl Generator<Yield = (), Return = ()> {\n+    move |()| {\n+        yield ();\n+        let _ = array;\n+    }\n+}\n+\n+#[start]\n+fn start(_: isize, _: *const *const u8) -> isize {\n+    let _ = generator([0; 8192]);\n+    0\n+}"}, {"sha": "28d4a6e6cff40de7cfa64a1c4cca2655ef26d27d", "filename": "src/test/ui/print_type_sizes/generator.stdout", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0f5d3ba30f33116a610e5f9f2bb60f3ce120a167/src%2Ftest%2Fui%2Fprint_type_sizes%2Fgenerator.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/0f5d3ba30f33116a610e5f9f2bb60f3ce120a167/src%2Ftest%2Fui%2Fprint_type_sizes%2Fgenerator.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprint_type_sizes%2Fgenerator.stdout?ref=0f5d3ba30f33116a610e5f9f2bb60f3ce120a167", "patch": "@@ -0,0 +1,10 @@\n+print-type-size type: `[generator@$DIR/generator.rs:10:5: 10:14]`: 8193 bytes, alignment: 1 bytes\n+print-type-size     discriminant: 1 bytes\n+print-type-size     variant `Unresumed`: 8192 bytes\n+print-type-size         field `.array`: 8192 bytes, offset: 0 bytes, alignment: 1 bytes\n+print-type-size     variant `Returned`: 8192 bytes\n+print-type-size         field `.array`: 8192 bytes, offset: 0 bytes, alignment: 1 bytes\n+print-type-size     variant `Panicked`: 8192 bytes\n+print-type-size         field `.array`: 8192 bytes, offset: 0 bytes, alignment: 1 bytes\n+print-type-size     variant `Suspend0`: 8192 bytes\n+print-type-size         field `.array`: 8192 bytes, offset: 0 bytes, alignment: 1 bytes"}]}