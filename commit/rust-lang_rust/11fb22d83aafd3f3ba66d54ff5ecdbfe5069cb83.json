{"sha": "11fb22d83aafd3f3ba66d54ff5ecdbfe5069cb83", "node_id": "C_kwDOAAsO6NoAKDExZmIyMmQ4M2FhZmQzZjNiYTY2ZDU0ZmY1ZWNkYmZlNTA2OWNiODM", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2021-11-29T00:35:50Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2021-12-20T21:37:12Z"}, "message": "CTFE eval_fn_call: use FnAbi to determine argument skipping and compatibility", "tree": {"sha": "b0f5edaeb0b756e9196594b82e739825a2c6cfd4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b0f5edaeb0b756e9196594b82e739825a2c6cfd4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/11fb22d83aafd3f3ba66d54ff5ecdbfe5069cb83", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/11fb22d83aafd3f3ba66d54ff5ecdbfe5069cb83", "html_url": "https://github.com/rust-lang/rust/commit/11fb22d83aafd3f3ba66d54ff5ecdbfe5069cb83", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/11fb22d83aafd3f3ba66d54ff5ecdbfe5069cb83/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "84f962a89bac3948ed116f1ad04c2f4793fb69ea", "url": "https://api.github.com/repos/rust-lang/rust/commits/84f962a89bac3948ed116f1ad04c2f4793fb69ea", "html_url": "https://github.com/rust-lang/rust/commit/84f962a89bac3948ed116f1ad04c2f4793fb69ea"}], "stats": {"total": 309, "additions": 198, "deletions": 111}, "files": [{"sha": "d101c786c4538ad2b4eefaeeb943416f132ba1e3", "filename": "compiler/rustc_const_eval/src/const_eval/machine.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/11fb22d83aafd3f3ba66d54ff5ecdbfe5069cb83/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11fb22d83aafd3f3ba66d54ff5ecdbfe5069cb83/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs?ref=11fb22d83aafd3f3ba66d54ff5ecdbfe5069cb83", "patch": "@@ -260,7 +260,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n         args: &[OpTy<'tcx>],\n         _ret: Option<(&PlaceTy<'tcx>, mir::BasicBlock)>,\n         _unwind: StackPopUnwind, // unwinding is not supported in consts\n-    ) -> InterpResult<'tcx, Option<&'mir mir::Body<'tcx>>> {\n+    ) -> InterpResult<'tcx, Option<(&'mir mir::Body<'tcx>, ty::Instance<'tcx>)>> {\n         debug!(\"find_mir_or_eval_fn: {:?}\", instance);\n \n         // Only check non-glue functions\n@@ -283,7 +283,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n             }\n         }\n         // This is a const fn. Call it.\n-        Ok(Some(ecx.load_mir(instance.def, None)?))\n+        Ok(Some((ecx.load_mir(instance.def, None)?, instance)))\n     }\n \n     fn call_intrinsic("}, {"sha": "eb562dc1e56346f7e503c481940052c9c00e50d9", "filename": "compiler/rustc_const_eval/src/interpret/eval_context.rs", "status": "modified", "additions": 21, "deletions": 2, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/11fb22d83aafd3f3ba66d54ff5ecdbfe5069cb83/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11fb22d83aafd3f3ba66d54ff5ecdbfe5069cb83/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs?ref=11fb22d83aafd3f3ba66d54ff5ecdbfe5069cb83", "patch": "@@ -8,15 +8,18 @@ use rustc_index::vec::IndexVec;\n use rustc_macros::HashStable;\n use rustc_middle::mir;\n use rustc_middle::mir::interpret::{InterpError, InvalidProgramInfo};\n-use rustc_middle::ty::layout::{self, LayoutError, LayoutOf, LayoutOfHelpers, TyAndLayout};\n+use rustc_middle::ty::layout::{\n+    self, FnAbiError, FnAbiOfHelpers, FnAbiRequest, LayoutError, LayoutOf, LayoutOfHelpers,\n+    TyAndLayout,\n+};\n use rustc_middle::ty::{\n     self, query::TyCtxtAt, subst::SubstsRef, ParamEnv, Ty, TyCtxt, TypeFoldable,\n };\n use rustc_mir_dataflow::storage::AlwaysLiveLocals;\n use rustc_query_system::ich::StableHashingContext;\n use rustc_session::Limit;\n use rustc_span::{Pos, Span};\n-use rustc_target::abi::{Align, HasDataLayout, Size, TargetDataLayout};\n+use rustc_target::abi::{call::FnAbi, Align, HasDataLayout, Size, TargetDataLayout};\n \n use super::{\n     AllocId, GlobalId, Immediate, InterpErrorInfo, InterpResult, MPlaceTy, Machine, MemPlace,\n@@ -333,6 +336,22 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> LayoutOfHelpers<'tcx> for InterpC\n     }\n }\n \n+impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> FnAbiOfHelpers<'tcx> for InterpCx<'mir, 'tcx, M> {\n+    type FnAbiOfResult = InterpResult<'tcx, &'tcx FnAbi<'tcx, Ty<'tcx>>>;\n+\n+    fn handle_fn_abi_err(\n+        &self,\n+        err: FnAbiError<'tcx>,\n+        _span: Span,\n+        _fn_abi_request: FnAbiRequest<'tcx>,\n+    ) -> InterpErrorInfo<'tcx> {\n+        match err {\n+            FnAbiError::Layout(err) => err_inval!(Layout(err)).into(),\n+            FnAbiError::AdjustForForeignAbi(err) => err_inval!(FnAbi(err)).into(),\n+        }\n+    }\n+}\n+\n /// Test if it is valid for a MIR assignment to assign `src`-typed place to `dest`-typed value.\n /// This test should be symmetric, as it is primarily about layout compatibility.\n pub(super) fn mir_assign_valid_types<'tcx>("}, {"sha": "6a03b699d47d442e945b6416764fbd47b5f18a23", "filename": "compiler/rustc_const_eval/src/interpret/machine.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/11fb22d83aafd3f3ba66d54ff5ecdbfe5069cb83/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11fb22d83aafd3f3ba66d54ff5ecdbfe5069cb83/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs?ref=11fb22d83aafd3f3ba66d54ff5ecdbfe5069cb83", "patch": "@@ -167,7 +167,7 @@ pub trait Machine<'mir, 'tcx>: Sized {\n         args: &[OpTy<'tcx, Self::PointerTag>],\n         ret: Option<(&PlaceTy<'tcx, Self::PointerTag>, mir::BasicBlock)>,\n         unwind: StackPopUnwind,\n-    ) -> InterpResult<'tcx, Option<&'mir mir::Body<'tcx>>>;\n+    ) -> InterpResult<'tcx, Option<(&'mir mir::Body<'tcx>, ty::Instance<'tcx>)>>;\n \n     /// Execute `fn_val`.  It is the hook's responsibility to advance the instruction\n     /// pointer as appropriate."}, {"sha": "d72ba6b0b9620c7eb97e829023f5d79b92223720", "filename": "compiler/rustc_const_eval/src/interpret/terminator.rs", "status": "modified", "additions": 168, "deletions": 104, "changes": 272, "blob_url": "https://github.com/rust-lang/rust/blob/11fb22d83aafd3f3ba66d54ff5ecdbfe5069cb83/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11fb22d83aafd3f3ba66d54ff5ecdbfe5069cb83/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs?ref=11fb22d83aafd3f3ba66d54ff5ecdbfe5069cb83", "patch": "@@ -1,14 +1,14 @@\n use std::borrow::Cow;\n use std::convert::TryFrom;\n \n-use rustc_middle::middle::codegen_fn_attrs::CodegenFnAttrFlags;\n-use rustc_middle::ty::layout::{self, LayoutOf as _, TyAndLayout};\n+use rustc_middle::ty::layout::{FnAbiOf, LayoutOf};\n use rustc_middle::ty::Instance;\n use rustc_middle::{\n     mir,\n     ty::{self, Ty},\n };\n use rustc_target::abi;\n+use rustc_target::abi::call::{ArgAbi, FnAbi, PassMode};\n use rustc_target::spec::abi::Abi;\n \n use super::{\n@@ -17,10 +17,6 @@ use super::{\n };\n \n impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n-    fn fn_can_unwind(&self, attrs: CodegenFnAttrFlags, abi: Abi) -> bool {\n-        layout::fn_can_unwind(*self.tcx, attrs, abi)\n-    }\n-\n     pub(super) fn eval_terminator(\n         &mut self,\n         terminator: &mir::Terminator<'tcx>,\n@@ -64,25 +60,27 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 let old_stack = self.frame_idx();\n                 let old_loc = self.frame().loc;\n                 let func = self.eval_operand(func, None)?;\n-                let (fn_val, abi, caller_can_unwind) = match *func.layout.ty.kind() {\n-                    ty::FnPtr(sig) => {\n-                        let caller_abi = sig.abi();\n+                let args = self.eval_operands(args)?;\n+\n+                let fn_sig_binder = func.layout.ty.fn_sig(*self.tcx);\n+                let fn_sig =\n+                    self.tcx.normalize_erasing_late_bound_regions(self.param_env, fn_sig_binder);\n+                let extra_args = &args[fn_sig.inputs().len()..];\n+                let extra_args = self.tcx.mk_type_list(extra_args.iter().map(|arg| arg.layout.ty));\n+\n+                let (fn_val, fn_abi, with_caller_location) = match *func.layout.ty.kind() {\n+                    ty::FnPtr(_sig) => {\n                         let fn_ptr = self.read_pointer(&func)?;\n                         let fn_val = self.memory.get_fn(fn_ptr)?;\n-                        (\n-                            fn_val,\n-                            caller_abi,\n-                            self.fn_can_unwind(CodegenFnAttrFlags::empty(), caller_abi),\n-                        )\n+                        (fn_val, self.fn_abi_of_fn_ptr(fn_sig_binder, extra_args)?, false)\n                     }\n                     ty::FnDef(def_id, substs) => {\n-                        let sig = func.layout.ty.fn_sig(*self.tcx);\n+                        let instance =\n+                            self.resolve(ty::WithOptConstParam::unknown(def_id), substs)?;\n                         (\n-                            FnVal::Instance(\n-                                self.resolve(ty::WithOptConstParam::unknown(def_id), substs)?,\n-                            ),\n-                            sig.abi(),\n-                            self.fn_can_unwind(self.tcx.codegen_fn_attrs(def_id).flags, sig.abi()),\n+                            FnVal::Instance(instance),\n+                            self.fn_abi_of_instance(instance, extra_args)?,\n+                            instance.def.requires_caller_location(*self.tcx),\n                         )\n                     }\n                     _ => span_bug!(\n@@ -91,7 +89,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                         func.layout.ty\n                     ),\n                 };\n-                let args = self.eval_operands(args)?;\n+\n                 let dest_place;\n                 let ret = match destination {\n                     Some((dest, ret)) => {\n@@ -102,10 +100,11 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 };\n                 self.eval_fn_call(\n                     fn_val,\n-                    abi,\n+                    (fn_sig.abi, fn_abi),\n                     &args,\n+                    with_caller_location,\n                     ret,\n-                    match (cleanup, caller_can_unwind) {\n+                    match (cleanup, fn_abi.can_unwind) {\n                         (Some(cleanup), true) => StackPopUnwind::Cleanup(*cleanup),\n                         (None, true) => StackPopUnwind::Skip,\n                         (_, false) => StackPopUnwind::NotAllowed,\n@@ -174,68 +173,120 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     }\n \n     fn check_argument_compat(\n-        rust_abi: bool,\n-        caller: TyAndLayout<'tcx>,\n-        callee: TyAndLayout<'tcx>,\n+        caller_abi: &ArgAbi<'tcx, Ty<'tcx>>,\n+        callee_abi: &ArgAbi<'tcx, Ty<'tcx>>,\n     ) -> bool {\n-        if caller.ty == callee.ty {\n-            // No question\n+        // Heuristic for type comparison.\n+        let layout_compat = || {\n+            if caller_abi.layout.ty == callee_abi.layout.ty {\n+                // No question\n+                return true;\n+            }\n+            // Compare layout\n+            match (caller_abi.layout.abi, callee_abi.layout.abi) {\n+                // Different valid ranges are okay (once we enforce validity,\n+                // that will take care to make it UB to leave the range, just\n+                // like for transmute).\n+                (abi::Abi::Scalar(caller), abi::Abi::Scalar(callee)) => {\n+                    caller.value == callee.value\n+                }\n+                (\n+                    abi::Abi::ScalarPair(caller1, caller2),\n+                    abi::Abi::ScalarPair(callee1, callee2),\n+                ) => caller1.value == callee1.value && caller2.value == callee2.value,\n+                // Be conservative\n+                _ => false,\n+            }\n+        };\n+        // Padding must be fully equal.\n+        let pad_compat = || {\n+            if caller_abi.pad != callee_abi.pad {\n+                trace!(\n+                    \"check_argument_compat: incompatible pad: {:?} != {:?}\",\n+                    caller_abi.pad,\n+                    callee_abi.pad\n+                );\n+                return false;\n+            }\n             return true;\n-        }\n-        if !rust_abi {\n-            // Don't risk anything\n-            return false;\n-        }\n-        // Compare layout\n-        match (caller.abi, callee.abi) {\n-            // Different valid ranges are okay (once we enforce validity,\n-            // that will take care to make it UB to leave the range, just\n-            // like for transmute).\n-            (abi::Abi::Scalar(caller), abi::Abi::Scalar(callee)) => caller.value == callee.value,\n-            (abi::Abi::ScalarPair(caller1, caller2), abi::Abi::ScalarPair(callee1, callee2)) => {\n-                caller1.value == callee1.value && caller2.value == callee2.value\n+        };\n+        // For comparing the PassMode, we allow the attributes to differ\n+        // (e.g., it is okay for NonNull to differ between caller and callee).\n+        // FIXME: Are there attributes (`call::ArgAttributes`) that do need to be checked?\n+        let mode_compat = || {\n+            match (caller_abi.mode, callee_abi.mode) {\n+                (PassMode::Ignore, PassMode::Ignore) => return true,\n+                (PassMode::Direct(_), PassMode::Direct(_)) => return true,\n+                (PassMode::Pair(_, _), PassMode::Pair(_, _)) => return true,\n+                (PassMode::Cast(c1), PassMode::Cast(c2)) if c1 == c2 => return true,\n+                (\n+                    PassMode::Indirect { attrs: _, extra_attrs: e1, on_stack: s1 },\n+                    PassMode::Indirect { attrs: _, extra_attrs: e2, on_stack: s2 },\n+                ) if e1.is_some() == e2.is_some() && s1 == s2 => return true,\n+                _ => {}\n             }\n-            // Be conservative\n-            _ => false,\n-        }\n+            trace!(\n+                \"check_argument_compat: incompatible modes:\\ncaller: {:?}\\ncallee: {:?}\",\n+                caller_abi.mode,\n+                callee_abi.mode\n+            );\n+            return false;\n+        };\n+\n+        layout_compat() && pad_compat() && mode_compat()\n     }\n \n-    /// Pass a single argument, checking the types for compatibility.\n-    fn pass_argument(\n+    /// Initialize a single callee argument, checking the types for compatibility.\n+    fn pass_argument<'x, 'y>(\n         &mut self,\n-        rust_abi: bool,\n-        caller_arg: &mut impl Iterator<Item = OpTy<'tcx, M::PointerTag>>,\n+        caller_args: &mut impl Iterator<\n+            Item = (&'x OpTy<'tcx, M::PointerTag>, &'y ArgAbi<'tcx, Ty<'tcx>>),\n+        >,\n+        callee_abi: &ArgAbi<'tcx, Ty<'tcx>>,\n         callee_arg: &PlaceTy<'tcx, M::PointerTag>,\n-    ) -> InterpResult<'tcx> {\n-        if rust_abi && callee_arg.layout.is_zst() {\n-            // Nothing to do.\n-            trace!(\"Skipping callee ZST\");\n+    ) -> InterpResult<'tcx>\n+    where\n+        'tcx: 'x,\n+        'tcx: 'y,\n+    {\n+        if matches!(callee_abi.mode, PassMode::Ignore) {\n+            // This one is skipped.\n             return Ok(());\n         }\n-        let caller_arg = caller_arg.next().ok_or_else(|| {\n+        // Find next caller arg.\n+        let (caller_arg, caller_abi) = caller_args.next().ok_or_else(|| {\n             err_ub_format!(\"calling a function with fewer arguments than it requires\")\n         })?;\n-        if rust_abi {\n-            assert!(!caller_arg.layout.is_zst(), \"ZSTs must have been already filtered out\");\n-        }\n         // Now, check\n-        if !Self::check_argument_compat(rust_abi, caller_arg.layout, callee_arg.layout) {\n+        if !Self::check_argument_compat(caller_abi, callee_abi) {\n             throw_ub_format!(\n                 \"calling a function with argument of type {:?} passing data of type {:?}\",\n                 callee_arg.layout.ty,\n                 caller_arg.layout.ty\n             )\n         }\n-        // We allow some transmutes here\n+        // We allow some transmutes here.\n+        // FIXME: Depending on the PassMode, this should reset some padding to uninitialized. (This\n+        // is true for all `copy_op`, but there are a lot of special cases for argument passing\n+        // specifically.)\n         self.copy_op_transmute(&caller_arg, callee_arg)\n     }\n \n     /// Call this function -- pushing the stack frame and initializing the arguments.\n+    ///\n+    /// For now, we require *both* the `Abi` and `FnAbi` of the caller. In principle, however,\n+    /// `FnAbi` should be enough -- if they are sufficiently compatible, it's probably okay for\n+    /// `Abi` to differ.\n+    ///\n+    /// `with_caller_location` indicates whether the caller passed a caller location. Miri\n+    /// implements caller locations without argument passing, but to match `FnAbi` we need to know\n+    /// when those arguments are present.\n     pub(crate) fn eval_fn_call(\n         &mut self,\n         fn_val: FnVal<'tcx, M::ExtraFnVal>,\n-        caller_abi: Abi,\n+        (caller_abi, caller_fn_abi): (Abi, &FnAbi<'tcx, Ty<'tcx>>),\n         args: &[OpTy<'tcx, M::PointerTag>],\n+        with_caller_location: bool,\n         ret: Option<(&PlaceTy<'tcx, M::PointerTag>, mir::BasicBlock)>,\n         mut unwind: StackPopUnwind,\n     ) -> InterpResult<'tcx> {\n@@ -250,6 +301,8 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n         let get_abi = |this: &Self, instance_ty: Ty<'tcx>| match instance_ty.kind() {\n             ty::FnDef(..) => instance_ty.fn_sig(*this.tcx).abi(),\n+            // Even after lowering closures and generators away, the *callee* can still have this\n+            // kind of type.\n             ty::Closure(..) => Abi::RustCall,\n             ty::Generator(..) => Abi::Rust,\n             _ => span_bug!(this.cur_span(), \"unexpected callee ty: {:?}\", instance_ty),\n@@ -281,6 +334,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     check_abi(get_abi(self, instance.ty(*self.tcx, self.param_env)))?;\n                 }\n                 assert!(caller_abi == Abi::RustIntrinsic || caller_abi == Abi::PlatformIntrinsic);\n+                // caller_fn_abi is not relevant here, we interpret the arguments directly for each intrinsic.\n                 M::call_intrinsic(self, instance, args, ret, unwind)\n             }\n             ty::InstanceDef::VtableShim(..)\n@@ -291,26 +345,25 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             | ty::InstanceDef::CloneShim(..)\n             | ty::InstanceDef::Item(_) => {\n                 // We need MIR for this fn\n-                let body =\n+                let (body, instance) =\n                     match M::find_mir_or_eval_fn(self, instance, caller_abi, args, ret, unwind)? {\n                         Some(body) => body,\n                         None => return Ok(()),\n                     };\n \n-                // Check against the ABI of the MIR body we are calling (not the ABI of `instance`;\n-                // these can differ when `find_mir_or_eval_fn` does something clever like resolve\n-                // exported symbol names).\n-                let callee_def_id = body.source.def_id();\n-                let callee_abi = get_abi(self, self.tcx.type_of(callee_def_id));\n+                // Compute callee information using the `instance` returned by\n+                // `find_mir_or_eval_fn`.\n+                let callee_abi = get_abi(self, instance.ty(*self.tcx, self.param_env));\n+                // FIXME: for variadic support, do we have to somehow determine calle's extra_args?\n+                let callee_fn_abi = self.fn_abi_of_instance(instance, ty::List::empty())?;\n+                assert!(!callee_fn_abi.c_variadic);\n+                assert!(!caller_fn_abi.c_variadic);\n \n                 if M::enforce_abi(self) {\n                     check_abi(callee_abi)?;\n                 }\n \n-                if !matches!(unwind, StackPopUnwind::NotAllowed)\n-                    && !self\n-                        .fn_can_unwind(self.tcx.codegen_fn_attrs(callee_def_id).flags, callee_abi)\n-                {\n+                if !matches!(unwind, StackPopUnwind::NotAllowed) && !callee_fn_abi.can_unwind {\n                     // The callee cannot unwind.\n                     unwind = StackPopUnwind::NotAllowed;\n                 }\n@@ -343,12 +396,8 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                             .collect::<Vec<_>>()\n                     );\n \n-                    // Figure out how to pass which arguments.\n-                    // The Rust ABI is special: ZST get skipped.\n-                    let rust_abi = matches!(caller_abi, Abi::Rust | Abi::RustCall);\n-\n-                    // We have two iterators: Where the arguments come from,\n-                    // and where they go to.\n+                    // In principle, we have two iterators: Where the arguments come from, and where\n+                    // they go to.\n \n                     // For where they come from: If the ABI is RustCall, we untuple the\n                     // last incoming argument.  These two iterators do not have the same type,\n@@ -373,53 +422,59 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                             // Plain arg passing\n                             Cow::from(args)\n                         };\n-                    // Skip ZSTs\n-                    let mut caller_iter =\n-                        caller_args.iter().filter(|op| !rust_abi || !op.layout.is_zst()).copied();\n+                    // If `with_caller_location` is set we pretend there is an extra argument (that\n+                    // we will not pass).\n+                    assert_eq!(\n+                        caller_args.len() + if with_caller_location { 1 } else { 0 },\n+                        caller_fn_abi.args.len(),\n+                        \"mismatch between caller ABI and caller arguments\",\n+                    );\n+                    let mut caller_args = caller_args\n+                        .iter()\n+                        .zip(caller_fn_abi.args.iter())\n+                        .filter(|arg_and_abi| !matches!(arg_and_abi.1.mode, PassMode::Ignore));\n \n                     // Now we have to spread them out across the callee's locals,\n                     // taking into account the `spread_arg`.  If we could write\n                     // this is a single iterator (that handles `spread_arg`), then\n                     // `pass_argument` would be the loop body. It takes care to\n                     // not advance `caller_iter` for ZSTs.\n+                    let mut callee_args_abis = callee_fn_abi.args.iter();\n                     for local in body.args_iter() {\n                         let dest = self.eval_place(mir::Place::from(local))?;\n                         if Some(local) == body.spread_arg {\n                             // Must be a tuple\n                             for i in 0..dest.layout.fields.count() {\n                                 let dest = self.place_field(&dest, i)?;\n-                                self.pass_argument(rust_abi, &mut caller_iter, &dest)?;\n+                                let callee_abi = callee_args_abis.next().unwrap();\n+                                self.pass_argument(&mut caller_args, callee_abi, &dest)?;\n                             }\n                         } else {\n                             // Normal argument\n-                            self.pass_argument(rust_abi, &mut caller_iter, &dest)?;\n+                            let callee_abi = callee_args_abis.next().unwrap();\n+                            self.pass_argument(&mut caller_args, callee_abi, &dest)?;\n                         }\n                     }\n-                    // Now we should have no more caller args\n-                    if caller_iter.next().is_some() {\n+                    // If the callee needs a caller location, pretend we consume one more argument from the ABI.\n+                    if instance.def.requires_caller_location(*self.tcx) {\n+                        callee_args_abis.next().unwrap();\n+                    }\n+                    // Now we should have no more caller args or callee arg ABIs\n+                    assert!(\n+                        callee_args_abis.next().is_none(),\n+                        \"mismatch between callee ABI and callee body arguments\"\n+                    );\n+                    if caller_args.next().is_some() {\n                         throw_ub_format!(\"calling a function with more arguments than it expected\")\n                     }\n                     // Don't forget to check the return type!\n-                    if let Some((caller_ret, _)) = ret {\n-                        let callee_ret = self.eval_place(mir::Place::return_place())?;\n-                        if !Self::check_argument_compat(\n-                            rust_abi,\n-                            caller_ret.layout,\n-                            callee_ret.layout,\n-                        ) {\n-                            throw_ub_format!(\n-                                \"calling a function with return type {:?} passing \\\n-                                     return place of type {:?}\",\n-                                callee_ret.layout.ty,\n-                                caller_ret.layout.ty\n-                            )\n-                        }\n-                    } else {\n-                        let local = mir::RETURN_PLACE;\n-                        let callee_layout = self.layout_of_local(self.frame(), local, None)?;\n-                        if !callee_layout.abi.is_uninhabited() {\n-                            throw_ub_format!(\"calling a returning function without a return place\")\n-                        }\n+                    if !Self::check_argument_compat(&caller_fn_abi.ret, &callee_fn_abi.ret) {\n+                        throw_ub_format!(\n+                            \"calling a function with return type {:?} passing \\\n+                                    return place of type {:?}\",\n+                            callee_fn_abi.ret.layout.ty,\n+                            caller_fn_abi.ret.layout.ty,\n+                        )\n                     }\n                 };\n                 match res {\n@@ -464,7 +519,14 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 ));\n                 trace!(\"Patched self operand to {:#?}\", args[0]);\n                 // recurse with concrete function\n-                self.eval_fn_call(fn_val, caller_abi, &args, ret, unwind)\n+                self.eval_fn_call(\n+                    fn_val,\n+                    (caller_abi, caller_fn_abi),\n+                    &args,\n+                    with_caller_location,\n+                    ret,\n+                    unwind,\n+                )\n             }\n         }\n     }\n@@ -489,6 +551,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             }\n             _ => (instance, place),\n         };\n+        let fn_abi = self.fn_abi_of_instance(instance, ty::List::empty())?;\n \n         let arg = ImmTy::from_immediate(\n             place.to_ref(self),\n@@ -500,8 +563,9 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n         self.eval_fn_call(\n             FnVal::Instance(instance),\n-            Abi::Rust,\n+            (Abi::Rust, fn_abi),\n             &[arg.into()],\n+            false,\n             Some((&dest.into(), target)),\n             match unwind {\n                 Some(cleanup) => StackPopUnwind::Cleanup(cleanup),"}, {"sha": "3a9df35afaaca309f702d5d95abaa312fb78ca12", "filename": "compiler/rustc_middle/src/mir/interpret/error.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/11fb22d83aafd3f3ba66d54ff5ecdbfe5069cb83/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11fb22d83aafd3f3ba66d54ff5ecdbfe5069cb83/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Ferror.rs?ref=11fb22d83aafd3f3ba66d54ff5ecdbfe5069cb83", "patch": "@@ -8,7 +8,7 @@ use rustc_errors::{pluralize, struct_span_err, DiagnosticBuilder, ErrorReported}\n use rustc_macros::HashStable;\n use rustc_session::CtfeBacktrace;\n use rustc_span::def_id::DefId;\n-use rustc_target::abi::{Align, Size};\n+use rustc_target::abi::{call, Align, Size};\n use std::{any::Any, backtrace::Backtrace, fmt};\n \n #[derive(Debug, Copy, Clone, PartialEq, Eq, HashStable, TyEncodable, TyDecodable)]\n@@ -141,6 +141,9 @@ pub enum InvalidProgramInfo<'tcx> {\n     AlreadyReported(ErrorReported),\n     /// An error occurred during layout computation.\n     Layout(layout::LayoutError<'tcx>),\n+    /// An error occurred during FnAbi computation.\n+    /// (Not using `FnAbiError` as that contains a nested `LayoutError`.)\n+    FnAbi(call::AdjustForForeignAbiError),\n     /// An invalid transmute happened.\n     TransmuteSizeDiff(Ty<'tcx>, Ty<'tcx>),\n     /// SizeOf of unsized type was requested.\n@@ -157,6 +160,7 @@ impl fmt::Display for InvalidProgramInfo<'_> {\n                 write!(f, \"encountered constants with type errors, stopping evaluation\")\n             }\n             Layout(ref err) => write!(f, \"{}\", err),\n+            FnAbi(ref err) => write!(f, \"{}\", err),\n             TransmuteSizeDiff(from_ty, to_ty) => write!(\n                 f,\n                 \"transmuting `{}` to `{}` is not possible, because these types do not have the same size\","}, {"sha": "7e56e062fc989b66dbb35868a6f03edf434bb2e1", "filename": "compiler/rustc_mir_transform/src/const_prop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/11fb22d83aafd3f3ba66d54ff5ecdbfe5069cb83/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11fb22d83aafd3f3ba66d54ff5ecdbfe5069cb83/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs?ref=11fb22d83aafd3f3ba66d54ff5ecdbfe5069cb83", "patch": "@@ -207,7 +207,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for ConstPropMachine<'mir, 'tcx>\n         _args: &[OpTy<'tcx>],\n         _ret: Option<(&PlaceTy<'tcx>, BasicBlock)>,\n         _unwind: StackPopUnwind,\n-    ) -> InterpResult<'tcx, Option<&'mir Body<'tcx>>> {\n+    ) -> InterpResult<'tcx, Option<(&'mir Body<'tcx>, ty::Instance<'tcx>)>> {\n         Ok(None)\n     }\n "}]}