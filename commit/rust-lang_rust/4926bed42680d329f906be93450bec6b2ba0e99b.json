{"sha": "4926bed42680d329f906be93450bec6b2ba0e99b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ5MjZiZWQ0MjY4MGQzMjlmOTA2YmU5MzQ1MGJlYzZiMmJhMGU5OWI=", "commit": {"author": {"name": "uHOOCCOOHu", "email": "hooccooh1896@gmail.com", "date": "2019-09-11T18:01:07Z"}, "committer": {"name": "uHOOCCOOHu", "email": "hooccooh1896@gmail.com", "date": "2019-09-15T11:40:32Z"}, "message": "Support path starting with a type", "tree": {"sha": "455c0bc9d839a18fffda6d018bf41d1c58ebfa52", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/455c0bc9d839a18fffda6d018bf41d1c58ebfa52"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4926bed42680d329f906be93450bec6b2ba0e99b", "comment_count": 0, "verification": {"verified": false, "reason": "no_user", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEEXLDp5dXVcfV/VA/qztOS3gxIPQAFAl1+IzIACgkQztOS3gxI\nPQDl5BAAoC61iidGizdZmvdyc0U/vXXG+cILAUqDdS0wEfVUTsWpQ+RW6xsZor/2\nhDrUsNBMxxI9oocV80KqtT2iSkk72ZkwV78X6CIq6jeBSfQom7pPoQe/LNZBrjxL\niHyL2PTfEum3IrkT6+5ZoY0EMebRxF9sldTByAwelfnUeuwX5phk11/j57ddrZBz\nLT1ZZ583LpMwQ7kdYRt9wC5knWu6qxc5dEfPY6ffg6hxSbVEPGtyHy03sUxKdlPR\nPNwhc9h16zqt0trvWFAm5v7KdcUl4o6rTSM8mX188gy7MknRFY1d3hvaGC20lL9n\nwlPeLrENE917zmN4Y7k5nwetso2D1NevcBXPG3gaESEpjC1nBees7LZ5kgNrrWJY\nCZDiJVpRCJseJZJhArearalvBKnB8/kr8iMAASTcek6NrnN3JTJURN9sddZaYHM9\nsUPfJf4lhciNQg816kHvSjypvcGPjpcPkI6+4a2OvmoBSvsB11+b/To4+GAt2agN\na2qAylwvzSGx3D6kDFwfkwU4mcAgo1l0EeChsBAsR+bde/KuuIY1jqqqIUO9B/zl\nNEMGdT6MgJQQFL5zhMybwcoZkAHHQsXHn9wimYThEOyKoLJ0UqN9tBhQrCn8vYUF\na5rt7IStK4+sHGntmYY6uVMN1ldkIqR6gOcUxGgQsLHnkvMlV9g=\n=b3+7\n-----END PGP SIGNATURE-----", "payload": "tree 455c0bc9d839a18fffda6d018bf41d1c58ebfa52\nparent 2d79a1ad83cc39075c7c9e3230973013c8c58b17\nauthor uHOOCCOOHu <hooccooh1896@gmail.com> 1568224867 +0800\ncommitter uHOOCCOOHu <hooccooh1896@gmail.com> 1568547632 +0800\n\nSupport path starting with a type\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4926bed42680d329f906be93450bec6b2ba0e99b", "html_url": "https://github.com/rust-lang/rust/commit/4926bed42680d329f906be93450bec6b2ba0e99b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4926bed42680d329f906be93450bec6b2ba0e99b/comments", "author": null, "committer": null, "parents": [{"sha": "2d79a1ad83cc39075c7c9e3230973013c8c58b17", "url": "https://api.github.com/repos/rust-lang/rust/commits/2d79a1ad83cc39075c7c9e3230973013c8c58b17", "html_url": "https://github.com/rust-lang/rust/commit/2d79a1ad83cc39075c7c9e3230973013c8c58b17"}], "stats": {"total": 339, "additions": 211, "deletions": 128}, "files": [{"sha": "5ecda1ff5397b0aa85342a2c9f7d8bb27481848c", "filename": "crates/ra_assists/src/auto_import.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4926bed42680d329f906be93450bec6b2ba0e99b/crates%2Fra_assists%2Fsrc%2Fauto_import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4926bed42680d329f906be93450bec6b2ba0e99b/crates%2Fra_assists%2Fsrc%2Fauto_import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fauto_import.rs?ref=4926bed42680d329f906be93450bec6b2ba0e99b", "patch": "@@ -504,19 +504,20 @@ fn apply_auto_import(\n     }\n }\n \n-pub fn collect_hir_path_segments(path: &hir::Path) -> Vec<SmolStr> {\n+pub fn collect_hir_path_segments(path: &hir::Path) -> Option<Vec<SmolStr>> {\n     let mut ps = Vec::<SmolStr>::with_capacity(10);\n     match path.kind {\n         hir::PathKind::Abs => ps.push(\"\".into()),\n         hir::PathKind::Crate => ps.push(\"crate\".into()),\n         hir::PathKind::Plain => {}\n         hir::PathKind::Self_ => ps.push(\"self\".into()),\n         hir::PathKind::Super => ps.push(\"super\".into()),\n+        hir::PathKind::Type => return None,\n     }\n     for s in path.segments.iter() {\n         ps.push(s.name.to_string().into());\n     }\n-    ps\n+    Some(ps)\n }\n \n // This function produces sequence of text edits into edit\n@@ -552,7 +553,7 @@ pub(crate) fn auto_import(mut ctx: AssistCtx<impl HirDatabase>) -> Option<Assist\n     }\n \n     let hir_path = hir::Path::from_ast(path.clone())?;\n-    let segments = collect_hir_path_segments(&hir_path);\n+    let segments = collect_hir_path_segments(&hir_path)?;\n     if segments.len() < 2 {\n         return None;\n     }"}, {"sha": "c675bf8de833a13d8d40304957c4780676e5e038", "filename": "crates/ra_hir/src/expr/validation.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4926bed42680d329f906be93450bec6b2ba0e99b/crates%2Fra_hir%2Fsrc%2Fexpr%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4926bed42680d329f906be93450bec6b2ba0e99b/crates%2Fra_hir%2Fsrc%2Fexpr%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fexpr%2Fvalidation.rs?ref=4926bed42680d329f906be93450bec6b2ba0e99b", "patch": "@@ -8,7 +8,7 @@ use crate::{\n     diagnostics::{DiagnosticSink, MissingFields, MissingOkInTailExpr},\n     expr::AstPtr,\n     name,\n-    path::{PathKind, PathSegment},\n+    path::PathKind,\n     ty::{ApplicationTy, InferenceResult, Ty, TypeCtor},\n     Adt, Function, Name, Path,\n };\n@@ -108,14 +108,10 @@ impl<'a, 'b> ExprValidator<'a, 'b> {\n             None => return,\n         };\n \n-        let std_result_path = Path {\n-            kind: PathKind::Abs,\n-            segments: vec![\n-                PathSegment { name: name::STD, args_and_bindings: None },\n-                PathSegment { name: name::RESULT_MOD, args_and_bindings: None },\n-                PathSegment { name: name::RESULT_TYPE, args_and_bindings: None },\n-            ],\n-        };\n+        let std_result_path = Path::from_simple_segments(\n+            PathKind::Abs,\n+            vec![name::STD, name::RESULT_MOD, name::RESULT_TYPE],\n+        );\n \n         let resolver = self.func.resolver(db);\n         let std_result_enum = match resolver.resolve_known_enum(db, &std_result_path) {"}, {"sha": "be1cc76b63b58887708472b2a30942f4bb9ea0eb", "filename": "crates/ra_hir/src/nameres.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4926bed42680d329f906be93450bec6b2ba0e99b/crates%2Fra_hir%2Fsrc%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4926bed42680d329f906be93450bec6b2ba0e99b/crates%2Fra_hir%2Fsrc%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres.rs?ref=4926bed42680d329f906be93450bec6b2ba0e99b", "patch": "@@ -382,6 +382,11 @@ impl CrateDefMap {\n                     return ResolvePathResult::empty(ReachedFixedPoint::No); // extern crate declarations can add to the extern prelude\n                 }\n             }\n+            PathKind::Type => {\n+                // This is handled in `infer::infer_path_expr`\n+                // The result returned here does not matter\n+                return ResolvePathResult::empty(ReachedFixedPoint::Yes);\n+            }\n         };\n \n         for (i, segment) in segments {\n@@ -401,8 +406,11 @@ impl CrateDefMap {\n             curr_per_ns = match curr {\n                 ModuleDef::Module(module) => {\n                     if module.krate != self.krate {\n-                        let path =\n-                            Path { segments: path.segments[i..].to_vec(), kind: PathKind::Self_ };\n+                        let path = Path {\n+                            segments: path.segments[i..].to_vec(),\n+                            kind: PathKind::Self_,\n+                            type_ref: None,\n+                        };\n                         log::debug!(\"resolving {:?} in other crate\", path);\n                         let defp_map = db.crate_def_map(module.krate);\n                         let (def, s) = defp_map.resolve_path(db, module.module_id, &path);"}, {"sha": "7c19fda14562f848e36b660cf792d3b81dd0cb74", "filename": "crates/ra_hir/src/path.rs", "status": "modified", "additions": 53, "deletions": 28, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/4926bed42680d329f906be93450bec6b2ba0e99b/crates%2Fra_hir%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4926bed42680d329f906be93450bec6b2ba0e99b/crates%2Fra_hir%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fpath.rs?ref=4926bed42680d329f906be93450bec6b2ba0e99b", "patch": "@@ -1,4 +1,4 @@\n-use std::sync::Arc;\n+use std::{iter, sync::Arc};\n \n use ra_syntax::{\n     ast::{self, NameOwner, TypeAscriptionOwner},\n@@ -10,6 +10,7 @@ use crate::{name, type_ref::TypeRef, AsName, Name};\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct Path {\n     pub kind: PathKind,\n+    pub type_ref: Option<Box<TypeRef>>,\n     pub segments: Vec<PathSegment>,\n }\n \n@@ -50,6 +51,8 @@ pub enum PathKind {\n     Crate,\n     // Absolute path\n     Abs,\n+    // Type based path like `<T>::foo`\n+    Type,\n }\n \n impl Path {\n@@ -63,10 +66,22 @@ impl Path {\n         }\n     }\n \n+    pub fn from_simple_segments(kind: PathKind, segments: impl IntoIterator<Item = Name>) -> Path {\n+        Path {\n+            kind,\n+            type_ref: None,\n+            segments: segments\n+                .into_iter()\n+                .map(|name| PathSegment { name, args_and_bindings: None })\n+                .collect(),\n+        }\n+    }\n+\n     /// Converts an `ast::Path` to `Path`. Works with use trees.\n     pub fn from_ast(mut path: ast::Path) -> Option<Path> {\n         let mut kind = PathKind::Plain;\n         let mut segments = Vec::new();\n+        let mut path_type_ref = None;\n         loop {\n             let segment = path.segment()?;\n \n@@ -92,24 +107,33 @@ impl Path {\n                 ast::PathSegmentKind::Type { type_ref, trait_ref } => {\n                     assert!(path.qualifier().is_none()); // this can only occur at the first segment\n \n-                    // FIXME: handle <T> syntax (type segments without trait)\n-\n-                    // <T as Trait<A>>::Foo desugars to Trait<Self=T, A>::Foo\n-                    let path = Path::from_ast(trait_ref?.path()?)?;\n-                    kind = path.kind;\n-                    let mut prefix_segments = path.segments;\n-                    prefix_segments.reverse();\n-                    segments.extend(prefix_segments);\n-                    // Insert the type reference (T in the above example) as Self parameter for the trait\n                     let self_type = TypeRef::from_ast(type_ref?);\n-                    let mut last_segment = segments.last_mut()?;\n-                    if last_segment.args_and_bindings.is_none() {\n-                        last_segment.args_and_bindings = Some(Arc::new(GenericArgs::empty()));\n-                    };\n-                    let args = last_segment.args_and_bindings.as_mut().unwrap();\n-                    let mut args_inner = Arc::make_mut(args);\n-                    args_inner.has_self_type = true;\n-                    args_inner.args.insert(0, GenericArg::Type(self_type));\n+\n+                    match trait_ref {\n+                        // <T>::foo\n+                        None => {\n+                            kind = PathKind::Type;\n+                            path_type_ref = Some(Box::new(self_type));\n+                        }\n+                        // <T as Trait<A>>::Foo desugars to Trait<Self=T, A>::Foo\n+                        Some(trait_ref) => {\n+                            let path = Path::from_ast(trait_ref.path()?)?;\n+                            kind = path.kind;\n+                            let mut prefix_segments = path.segments;\n+                            prefix_segments.reverse();\n+                            segments.extend(prefix_segments);\n+                            // Insert the type reference (T in the above example) as Self parameter for the trait\n+                            let mut last_segment = segments.last_mut()?;\n+                            if last_segment.args_and_bindings.is_none() {\n+                                last_segment.args_and_bindings =\n+                                    Some(Arc::new(GenericArgs::empty()));\n+                            };\n+                            let args = last_segment.args_and_bindings.as_mut().unwrap();\n+                            let mut args_inner = Arc::make_mut(args);\n+                            args_inner.has_self_type = true;\n+                            args_inner.args.insert(0, GenericArg::Type(self_type));\n+                        }\n+                    }\n                 }\n                 ast::PathSegmentKind::CrateKw => {\n                     kind = PathKind::Crate;\n@@ -130,7 +154,7 @@ impl Path {\n             };\n         }\n         segments.reverse();\n-        return Some(Path { kind, segments });\n+        return Some(Path { kind, type_ref: path_type_ref, segments });\n \n         fn qualifier(path: &ast::Path) -> Option<ast::Path> {\n             if let Some(q) = path.qualifier() {\n@@ -230,10 +254,7 @@ impl GenericArgs {\n \n impl From<Name> for Path {\n     fn from(name: Name) -> Path {\n-        Path {\n-            kind: PathKind::Plain,\n-            segments: vec![PathSegment { name, args_and_bindings: None }],\n-        }\n+        Path::from_simple_segments(PathKind::Plain, iter::once(name))\n     }\n }\n \n@@ -287,8 +308,12 @@ fn convert_path(prefix: Option<Path>, path: ast::Path) -> Option<Path> {\n     let segment = path.segment()?;\n     let res = match segment.kind()? {\n         ast::PathSegmentKind::Name(name) => {\n-            let mut res = prefix\n-                .unwrap_or_else(|| Path { kind: PathKind::Plain, segments: Vec::with_capacity(1) });\n+            // no type args in use\n+            let mut res = prefix.unwrap_or_else(|| Path {\n+                kind: PathKind::Plain,\n+                type_ref: None,\n+                segments: Vec::with_capacity(1),\n+            });\n             res.segments.push(PathSegment {\n                 name: name.as_name(),\n                 args_and_bindings: None, // no type args in use\n@@ -299,19 +324,19 @@ fn convert_path(prefix: Option<Path>, path: ast::Path) -> Option<Path> {\n             if prefix.is_some() {\n                 return None;\n             }\n-            Path { kind: PathKind::Crate, segments: Vec::new() }\n+            Path::from_simple_segments(PathKind::Crate, iter::empty())\n         }\n         ast::PathSegmentKind::SelfKw => {\n             if prefix.is_some() {\n                 return None;\n             }\n-            Path { kind: PathKind::Self_, segments: Vec::new() }\n+            Path::from_simple_segments(PathKind::Self_, iter::empty())\n         }\n         ast::PathSegmentKind::SuperKw => {\n             if prefix.is_some() {\n                 return None;\n             }\n-            Path { kind: PathKind::Super, segments: Vec::new() }\n+            Path::from_simple_segments(PathKind::Super, iter::empty())\n         }\n         ast::PathSegmentKind::Type { .. } => {\n             // not allowed in imports"}, {"sha": "e357c74e39cdc7fa860b1a47c8ccf4b79d3a0f7f", "filename": "crates/ra_hir/src/resolve.rs", "status": "modified", "additions": 17, "deletions": 11, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/4926bed42680d329f906be93450bec6b2ba0e99b/crates%2Fra_hir%2Fsrc%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4926bed42680d329f906be93450bec6b2ba0e99b/crates%2Fra_hir%2Fsrc%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fresolve.rs?ref=4926bed42680d329f906be93450bec6b2ba0e99b", "patch": "@@ -15,6 +15,7 @@ use crate::{\n     name::{Name, SELF_PARAM, SELF_TYPE},\n     nameres::{CrateDefMap, CrateModuleId, PerNs},\n     path::{Path, PathKind},\n+    type_ref::TypeRef,\n     Adt, BuiltinType, Const, Enum, EnumVariant, Function, MacroDef, ModuleDef, Static, Struct,\n     Trait, TypeAlias,\n };\n@@ -64,9 +65,10 @@ pub enum TypeNs {\n }\n \n #[derive(Debug)]\n-pub enum ValueOrPartial {\n+pub enum ResolveValueResult<'a> {\n     ValueNs(ValueNs),\n     Partial(TypeNs, usize),\n+    TypeRef(&'a TypeRef),\n }\n \n #[derive(Debug)]\n@@ -183,11 +185,15 @@ impl Resolver {\n         Some(res)\n     }\n \n-    pub(crate) fn resolve_path_in_value_ns(\n+    pub(crate) fn resolve_path_in_value_ns<'p>(\n         &self,\n         db: &impl HirDatabase,\n-        path: &Path,\n-    ) -> Option<ValueOrPartial> {\n+        path: &'p Path,\n+    ) -> Option<ResolveValueResult<'p>> {\n+        if let Some(type_ref) = &path.type_ref {\n+            return Some(ResolveValueResult::TypeRef(type_ref));\n+        }\n+\n         let n_segments = path.segments.len();\n         let tmp = SELF_PARAM;\n         let first_name = if path.is_self() { &tmp } else { &path.segments.first()?.name };\n@@ -208,23 +214,23 @@ impl Resolver {\n                         .find(|entry| entry.name() == first_name);\n \n                     if let Some(e) = entry {\n-                        return Some(ValueOrPartial::ValueNs(ValueNs::LocalBinding(e.pat())));\n+                        return Some(ResolveValueResult::ValueNs(ValueNs::LocalBinding(e.pat())));\n                     }\n                 }\n                 Scope::ExprScope(_) => continue,\n \n                 Scope::GenericParams(params) if n_segments > 1 => {\n                     if let Some(param) = params.find_by_name(first_name) {\n                         let ty = TypeNs::GenericParam(param.idx);\n-                        return Some(ValueOrPartial::Partial(ty, 1));\n+                        return Some(ResolveValueResult::Partial(ty, 1));\n                     }\n                 }\n                 Scope::GenericParams(_) => continue,\n \n                 Scope::ImplBlockScope(impl_) if n_segments > 1 => {\n                     if first_name == &SELF_TYPE {\n                         let ty = TypeNs::SelfType(*impl_);\n-                        return Some(ValueOrPartial::Partial(ty, 1));\n+                        return Some(ResolveValueResult::Partial(ty, 1));\n                     }\n                 }\n                 Scope::ImplBlockScope(_) => continue,\n@@ -247,7 +253,7 @@ impl Resolver {\n                                 | ModuleDef::BuiltinType(_)\n                                 | ModuleDef::Module(_) => return None,\n                             };\n-                            Some(ValueOrPartial::ValueNs(value))\n+                            Some(ResolveValueResult::ValueNs(value))\n                         }\n                         Some(idx) => {\n                             let ty = match module_def.take_types()? {\n@@ -262,7 +268,7 @@ impl Resolver {\n                                 | ModuleDef::Const(_)\n                                 | ModuleDef::Static(_) => return None,\n                             };\n-                            Some(ValueOrPartial::Partial(ty, idx))\n+                            Some(ResolveValueResult::Partial(ty, idx))\n                         }\n                     };\n                 }\n@@ -277,8 +283,8 @@ impl Resolver {\n         path: &Path,\n     ) -> Option<ValueNs> {\n         match self.resolve_path_in_value_ns(db, path)? {\n-            ValueOrPartial::ValueNs(it) => Some(it),\n-            ValueOrPartial::Partial(..) => None,\n+            ResolveValueResult::ValueNs(it) => Some(it),\n+            ResolveValueResult::Partial(..) | ResolveValueResult::TypeRef(_) => None,\n         }\n     }\n "}, {"sha": "59053cda32275334735f15670527d81c36ee1367", "filename": "crates/ra_hir/src/source_binder.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4926bed42680d329f906be93450bec6b2ba0e99b/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4926bed42680d329f906be93450bec6b2ba0e99b/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs?ref=4926bed42680d329f906be93450bec6b2ba0e99b", "patch": "@@ -26,7 +26,7 @@ use crate::{\n     },\n     ids::LocationCtx,\n     name,\n-    path::{PathKind, PathSegment},\n+    path::PathKind,\n     resolve::{ScopeDef, TypeNs, ValueNs},\n     ty::method_resolution::implements_trait,\n     AsName, AstId, Const, Crate, DefWithBody, Either, Enum, Function, HasBody, HirFileId, MacroDef,\n@@ -433,14 +433,10 @@ impl SourceAnalyzer {\n     /// Checks that particular type `ty` implements `std::future::Future`.\n     /// This function is used in `.await` syntax completion.\n     pub fn impls_future(&self, db: &impl HirDatabase, ty: Ty) -> bool {\n-        let std_future_path = Path {\n-            kind: PathKind::Abs,\n-            segments: vec![\n-                PathSegment { name: name::STD, args_and_bindings: None },\n-                PathSegment { name: name::FUTURE_MOD, args_and_bindings: None },\n-                PathSegment { name: name::FUTURE_TYPE, args_and_bindings: None },\n-            ],\n-        };\n+        let std_future_path = Path::from_simple_segments(\n+            PathKind::Abs,\n+            vec![name::STD, name::FUTURE_MOD, name::FUTURE_TYPE],\n+        );\n \n         let std_future_trait = match self.resolver.resolve_known_trait(db, &std_future_path) {\n             Some(it) => it,"}, {"sha": "3981de82946c87e94df71a626dbee1864f964848", "filename": "crates/ra_hir/src/ty/infer.rs", "status": "modified", "additions": 55, "deletions": 65, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/4926bed42680d329f906be93450bec6b2ba0e99b/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4926bed42680d329f906be93450bec6b2ba0e99b/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs?ref=4926bed42680d329f906be93450bec6b2ba0e99b", "patch": "@@ -44,11 +44,12 @@ use crate::{\n     generics::{GenericParams, HasGenericParams},\n     name,\n     nameres::Namespace,\n-    path::{GenericArg, GenericArgs, PathKind, PathSegment},\n-    resolve::{Resolver, TypeNs, ValueNs, ValueOrPartial},\n+    path::{GenericArg, GenericArgs, PathKind},\n+    resolve::{ResolveValueResult, Resolver, TypeNs, ValueNs},\n     ty::infer::diagnostics::InferenceDiagnostic,\n     type_ref::{Mutability, TypeRef},\n-    Adt, ConstData, DefWithBody, FnData, Function, HasBody, ImplItem, Name, Path, StructField,\n+    Adt, ConstData, DefWithBody, Either, FnData, Function, HasBody, ImplItem, Name, Path,\n+    StructField,\n };\n \n mod unify;\n@@ -470,9 +471,13 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         let value_or_partial = resolver.resolve_path_in_value_ns(self.db, &path)?;\n \n         let (value, self_subst) = match value_or_partial {\n-            ValueOrPartial::ValueNs(it) => (it, None),\n-            ValueOrPartial::Partial(def, remaining_index) => {\n-                self.resolve_assoc_item(def, path, remaining_index, id)?\n+            ResolveValueResult::ValueNs(it) => (it, None),\n+            ResolveValueResult::Partial(def, remaining_index) => {\n+                self.resolve_assoc_item(Either::A(def), path, remaining_index, id)?\n+            }\n+            ResolveValueResult::TypeRef(type_ref) => {\n+                let ty = self.make_ty(type_ref);\n+                self.resolve_assoc_item(Either::B(ty), path, 0, id)?\n             }\n         };\n \n@@ -503,7 +508,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n \n     fn resolve_assoc_item(\n         &mut self,\n-        mut def: TypeNs,\n+        mut def_or_ty: Either<TypeNs, Ty>,\n         path: &Path,\n         remaining_index: usize,\n         id: ExprOrPatId,\n@@ -516,30 +521,33 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         // resolve intermediate segments\n         for (i, segment) in path.segments[remaining_index..].iter().enumerate() {\n             let is_last_segment = i == path.segments[remaining_index..].len() - 1;\n-            ty = {\n-                let typable: TypableDef = match def {\n-                    TypeNs::Adt(it) => it.into(),\n-                    TypeNs::TypeAlias(it) => it.into(),\n-                    TypeNs::BuiltinType(it) => it.into(),\n-                    // FIXME associated item of traits, generics, and Self\n-                    TypeNs::Trait(_) | TypeNs::GenericParam(_) | TypeNs::SelfType(_) => {\n-                        return None;\n-                    }\n-                    // FIXME: report error here\n-                    TypeNs::EnumVariant(_) => return None,\n-                };\n-\n-                let ty = self.db.type_for_def(typable, Namespace::Types);\n+            ty = match def_or_ty {\n+                Either::A(def) => {\n+                    let typable: TypableDef = match def {\n+                        TypeNs::Adt(it) => it.into(),\n+                        TypeNs::TypeAlias(it) => it.into(),\n+                        TypeNs::BuiltinType(it) => it.into(),\n+                        // FIXME associated item of traits, generics, and Self\n+                        TypeNs::Trait(_) | TypeNs::GenericParam(_) | TypeNs::SelfType(_) => {\n+                            return None;\n+                        }\n+                        // FIXME: report error here\n+                        TypeNs::EnumVariant(_) => return None,\n+                    };\n \n-                // For example, this substs will take `Gen::*<u32>*::make`\n-                assert!(remaining_index > 0);\n-                let substs = Ty::substs_from_path_segment(\n-                    self.db,\n-                    &self.resolver,\n-                    &path.segments[remaining_index + i - 1],\n-                    typable,\n-                );\n-                ty.subst(&substs)\n+                    let ty = self.db.type_for_def(typable, Namespace::Types);\n+\n+                    // For example, this substs will take `Gen::*<u32>*::make`\n+                    assert!(remaining_index > 0);\n+                    let substs = Ty::substs_from_path_segment(\n+                        self.db,\n+                        &self.resolver,\n+                        &path.segments[remaining_index + i - 1],\n+                        typable,\n+                    );\n+                    ty.subst(&substs)\n+                }\n+                Either::B(ty) => ty,\n             };\n             if is_last_segment {\n                 break;\n@@ -550,15 +558,15 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             log::debug!(\"looking for path segment: {:?}\", segment);\n \n             let ty = mem::replace(&mut ty, Ty::Unknown);\n-            def = ty.iterate_impl_items(self.db, krate, |item| {\n+            def_or_ty = ty.iterate_impl_items(self.db, krate, |item| {\n                 match item {\n                     crate::ImplItem::Method(_) => None,\n                     crate::ImplItem::Const(_) => None,\n \n                     // FIXME: Resolve associated types\n                     crate::ImplItem::TypeAlias(_) => {\n-                        // Some(TypeNs::TypeAlias(..))\n-                        None::<TypeNs>\n+                        // Some(Either::A(TypeNs::TypeAlias(..)))\n+                        None\n                     }\n                 }\n             })?;\n@@ -1434,56 +1442,38 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n     }\n \n     fn resolve_into_iter_item(&self) -> Option<TypeAlias> {\n-        let into_iter_path = Path {\n-            kind: PathKind::Abs,\n-            segments: vec![\n-                PathSegment { name: name::STD, args_and_bindings: None },\n-                PathSegment { name: name::ITER, args_and_bindings: None },\n-                PathSegment { name: name::INTO_ITERATOR, args_and_bindings: None },\n-            ],\n-        };\n+        let into_iter_path = Path::from_simple_segments(\n+            PathKind::Abs,\n+            vec![name::STD, name::ITER, name::INTO_ITERATOR],\n+        );\n \n         let trait_ = self.resolver.resolve_known_trait(self.db, &into_iter_path)?;\n         trait_.associated_type_by_name(self.db, &name::ITEM)\n     }\n \n     fn resolve_ops_try_ok(&self) -> Option<TypeAlias> {\n-        let ops_try_path = Path {\n-            kind: PathKind::Abs,\n-            segments: vec![\n-                PathSegment { name: name::STD, args_and_bindings: None },\n-                PathSegment { name: name::OPS, args_and_bindings: None },\n-                PathSegment { name: name::TRY, args_and_bindings: None },\n-            ],\n-        };\n+        let ops_try_path =\n+            Path::from_simple_segments(PathKind::Abs, vec![name::STD, name::OPS, name::TRY]);\n \n         let trait_ = self.resolver.resolve_known_trait(self.db, &ops_try_path)?;\n         trait_.associated_type_by_name(self.db, &name::OK)\n     }\n \n     fn resolve_future_future_output(&self) -> Option<TypeAlias> {\n-        let future_future_path = Path {\n-            kind: PathKind::Abs,\n-            segments: vec![\n-                PathSegment { name: name::STD, args_and_bindings: None },\n-                PathSegment { name: name::FUTURE_MOD, args_and_bindings: None },\n-                PathSegment { name: name::FUTURE_TYPE, args_and_bindings: None },\n-            ],\n-        };\n+        let future_future_path = Path::from_simple_segments(\n+            PathKind::Abs,\n+            vec![name::STD, name::FUTURE_MOD, name::FUTURE_TYPE],\n+        );\n \n         let trait_ = self.resolver.resolve_known_trait(self.db, &future_future_path)?;\n         trait_.associated_type_by_name(self.db, &name::OUTPUT)\n     }\n \n     fn resolve_boxed_box(&self) -> Option<Adt> {\n-        let boxed_box_path = Path {\n-            kind: PathKind::Abs,\n-            segments: vec![\n-                PathSegment { name: name::STD, args_and_bindings: None },\n-                PathSegment { name: name::BOXED_MOD, args_and_bindings: None },\n-                PathSegment { name: name::BOX_TYPE, args_and_bindings: None },\n-            ],\n-        };\n+        let boxed_box_path = Path::from_simple_segments(\n+            PathKind::Abs,\n+            vec![name::STD, name::BOXED_MOD, name::BOX_TYPE],\n+        );\n         let struct_ = self.resolver.resolve_known_struct(self.db, &boxed_box_path)?;\n         Some(Adt::Struct(struct_))\n     }"}, {"sha": "1bd677cab755373512195f705bde498b8437384f", "filename": "crates/ra_hir/src/ty/tests.rs", "status": "modified", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/4926bed42680d329f906be93450bec6b2ba0e99b/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4926bed42680d329f906be93450bec6b2ba0e99b/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs?ref=4926bed42680d329f906be93450bec6b2ba0e99b", "patch": "@@ -281,6 +281,64 @@ fn test() {\n     );\n }\n \n+#[test]\n+fn infer_path_type() {\n+    assert_snapshot!(\n+        infer(r#\"\n+struct S;\n+\n+impl S {\n+    fn foo() -> i32 { 1 }\n+}\n+\n+fn test() {\n+    S::foo();\n+    <S>::foo();\n+}\n+\"#),\n+        @r###\"\n+    [41; 46) '{ 1 }': i32\n+    [43; 44) '1': i32\n+    [60; 93) '{     ...o(); }': ()\n+    [66; 72) 'S::foo': fn foo() -> i32\n+    [66; 74) 'S::foo()': i32\n+    [80; 88) '<S>::foo': fn foo() -> i32\n+    [80; 90) '<S>::foo()': i32\n+\"###\n+    );\n+}\n+\n+#[test]\n+fn infer_slice_method() {\n+    assert_snapshot!(\n+        infer(r#\"\n+#[lang = \"slice\"]\n+impl<T> [T] {\n+    fn foo(&self) -> T {\n+        loop {}\n+    }\n+}\n+\n+#[lang = \"slice_alloc\"]\n+impl<T> [T] {}\n+\n+fn test() {\n+    <[_]>::foo(b\"foo\");\n+}\n+\"#),\n+        @r###\"\n+    [45; 49) 'self': &[T]\n+    [56; 79) '{     ...     }': !\n+    [66; 73) 'loop {}': !\n+    [71; 73) '{}': ()\n+    [133; 160) '{     ...o\"); }': ()\n+    [139; 149) '<[_]>::foo': fn foo<u8>(&[T]) -> T\n+    [139; 157) '<[_]>:...\"foo\")': u8\n+    [150; 156) 'b\"foo\"': &[u8]\n+\"###\n+    );\n+}\n+\n #[test]\n fn infer_struct() {\n     assert_snapshot!("}, {"sha": "dc1f8c82cb7554419477d417df413bdc0615ed50", "filename": "crates/ra_syntax/src/ast/generated.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4926bed42680d329f906be93450bec6b2ba0e99b/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4926bed42680d329f906be93450bec6b2ba0e99b/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs?ref=4926bed42680d329f906be93450bec6b2ba0e99b", "patch": "@@ -2385,6 +2385,9 @@ impl PathSegment {\n     pub fn ret_type(&self) -> Option<RetType> {\n         AstChildren::new(&self.syntax).next()\n     }\n+    pub fn path_type(&self) -> Option<PathType> {\n+        AstChildren::new(&self.syntax).next()\n+    }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct PathType {"}, {"sha": "da9de2214be2fa8810cab713d37255a49ec702ce", "filename": "crates/ra_syntax/src/grammar.ron", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4926bed42680d329f906be93450bec6b2ba0e99b/crates%2Fra_syntax%2Fsrc%2Fgrammar.ron", "raw_url": "https://github.com/rust-lang/rust/raw/4926bed42680d329f906be93450bec6b2ba0e99b/crates%2Fra_syntax%2Fsrc%2Fgrammar.ron", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fgrammar.ron?ref=4926bed42680d329f906be93450bec6b2ba0e99b", "patch": "@@ -689,7 +689,7 @@ Grammar(\n             ]\n         ),\n         \"PathSegment\": (\n-            options: [ \"NameRef\", \"TypeArgList\", \"ParamList\", \"RetType\" ]\n+            options: [ \"NameRef\", \"TypeArgList\", \"ParamList\", \"RetType\", \"PathType\" ]\n         ),\n         \"TypeArgList\": (collections: [\n             (\"type_args\", \"TypeArg\"),"}]}