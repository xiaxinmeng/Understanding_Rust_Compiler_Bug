{"sha": "a8babed8a3a806066f2bf2ae3fcd21fd35703ed8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE4YmFiZWQ4YTNhODA2MDY2ZjJiZjJhZTNmY2QyMWZkMzU3MDNlZDg=", "commit": {"author": {"name": "Nikita Popov", "email": "nikita.ppv@gmail.com", "date": "2018-12-21T10:44:05Z"}, "committer": {"name": "Nikita Popov", "email": "nikita.ppv@gmail.com", "date": "2018-12-21T10:44:05Z"}, "message": "Remove \"visited\" set from inhabitedness checking\n\nNow that references are no longer recursively checked, this should\nno longer be necessary, and it's a major performance bottleneck.", "tree": {"sha": "8a7ec290d121f30f33899044e8ea8c59d621bfaf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8a7ec290d121f30f33899044e8ea8c59d621bfaf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a8babed8a3a806066f2bf2ae3fcd21fd35703ed8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a8babed8a3a806066f2bf2ae3fcd21fd35703ed8", "html_url": "https://github.com/rust-lang/rust/commit/a8babed8a3a806066f2bf2ae3fcd21fd35703ed8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a8babed8a3a806066f2bf2ae3fcd21fd35703ed8/comments", "author": {"login": "nikic", "id": 216080, "node_id": "MDQ6VXNlcjIxNjA4MA==", "avatar_url": "https://avatars.githubusercontent.com/u/216080?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikic", "html_url": "https://github.com/nikic", "followers_url": "https://api.github.com/users/nikic/followers", "following_url": "https://api.github.com/users/nikic/following{/other_user}", "gists_url": "https://api.github.com/users/nikic/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikic/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikic/subscriptions", "organizations_url": "https://api.github.com/users/nikic/orgs", "repos_url": "https://api.github.com/users/nikic/repos", "events_url": "https://api.github.com/users/nikic/events{/privacy}", "received_events_url": "https://api.github.com/users/nikic/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikic", "id": 216080, "node_id": "MDQ6VXNlcjIxNjA4MA==", "avatar_url": "https://avatars.githubusercontent.com/u/216080?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikic", "html_url": "https://github.com/nikic", "followers_url": "https://api.github.com/users/nikic/followers", "following_url": "https://api.github.com/users/nikic/following{/other_user}", "gists_url": "https://api.github.com/users/nikic/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikic/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikic/subscriptions", "organizations_url": "https://api.github.com/users/nikic/orgs", "repos_url": "https://api.github.com/users/nikic/repos", "events_url": "https://api.github.com/users/nikic/events{/privacy}", "received_events_url": "https://api.github.com/users/nikic/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6d34ec18c7d7e574553f6347ecf08e1e1c45c13d", "url": "https://api.github.com/repos/rust-lang/rust/commits/6d34ec18c7d7e574553f6347ecf08e1e1c45c13d", "html_url": "https://github.com/rust-lang/rust/commit/6d34ec18c7d7e574553f6347ecf08e1e1c45c13d"}], "stats": {"total": 54, "additions": 10, "deletions": 44}, "files": [{"sha": "c64811e32f437b6cd9db9f9b65734078a0874694", "filename": "src/librustc/ty/inhabitedness/mod.rs", "status": "modified", "additions": 10, "deletions": 44, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/a8babed8a3a806066f2bf2ae3fcd21fd35703ed8/src%2Flibrustc%2Fty%2Finhabitedness%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8babed8a3a806066f2bf2ae3fcd21fd35703ed8/src%2Flibrustc%2Fty%2Finhabitedness%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finhabitedness%2Fmod.rs?ref=a8babed8a3a806066f2bf2ae3fcd21fd35703ed8", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use util::nodemap::{FxHashMap, FxHashSet};\n use ty::context::TyCtxt;\n use ty::{AdtDef, VariantDef, FieldDef, Ty, TyS};\n use ty::{DefId, Substs};\n@@ -113,7 +112,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     fn ty_inhabitedness_forest(self, ty: Ty<'tcx>) -> DefIdForest {\n-        ty.uninhabited_from(&mut FxHashMap::default(), self)\n+        ty.uninhabited_from(self)\n     }\n \n     pub fn is_enum_variant_uninhabited_from(self,\n@@ -140,20 +139,19 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         let adt_kind = self.adt_def(adt_def_id).adt_kind();\n \n         // Compute inhabitedness forest:\n-        variant.uninhabited_from(&mut FxHashMap::default(), self, substs, adt_kind)\n+        variant.uninhabited_from(self, substs, adt_kind)\n     }\n }\n \n impl<'a, 'gcx, 'tcx> AdtDef {\n     /// Calculate the forest of DefIds from which this adt is visibly uninhabited.\n     fn uninhabited_from(\n         &self,\n-        visited: &mut FxHashMap<DefId, FxHashSet<&'tcx Substs<'tcx>>>,\n         tcx: TyCtxt<'a, 'gcx, 'tcx>,\n         substs: &'tcx Substs<'tcx>) -> DefIdForest\n     {\n         DefIdForest::intersection(tcx, self.variants.iter().map(|v| {\n-            v.uninhabited_from(visited, tcx, substs, self.adt_kind())\n+            v.uninhabited_from(tcx, substs, self.adt_kind())\n         }))\n     }\n }\n@@ -162,7 +160,6 @@ impl<'a, 'gcx, 'tcx> VariantDef {\n     /// Calculate the forest of DefIds from which this variant is visibly uninhabited.\n     fn uninhabited_from(\n         &self,\n-        visited: &mut FxHashMap<DefId, FxHashSet<&'tcx Substs<'tcx>>>,\n         tcx: TyCtxt<'a, 'gcx, 'tcx>,\n         substs: &'tcx Substs<'tcx>,\n         adt_kind: AdtKind) -> DefIdForest\n@@ -175,7 +172,7 @@ impl<'a, 'gcx, 'tcx> VariantDef {\n             AdtKind::Struct => false,\n         };\n         DefIdForest::union(tcx, self.fields.iter().map(|f| {\n-            f.uninhabited_from(visited, tcx, substs, is_enum)\n+            f.uninhabited_from(tcx, substs, is_enum)\n         }))\n     }\n }\n@@ -184,13 +181,12 @@ impl<'a, 'gcx, 'tcx> FieldDef {\n     /// Calculate the forest of DefIds from which this field is visibly uninhabited.\n     fn uninhabited_from(\n         &self,\n-        visited: &mut FxHashMap<DefId, FxHashSet<&'tcx Substs<'tcx>>>,\n         tcx: TyCtxt<'a, 'gcx, 'tcx>,\n         substs: &'tcx Substs<'tcx>,\n         is_enum: bool,\n     ) -> DefIdForest {\n-        let mut data_uninhabitedness = move || {\n-            self.ty(tcx, substs).uninhabited_from(visited, tcx)\n+        let data_uninhabitedness = move || {\n+            self.ty(tcx, substs).uninhabited_from(tcx)\n         };\n         // FIXME(canndrew): Currently enum fields are (incorrectly) stored with\n         // Visibility::Invisible so we need to override self.vis if we're\n@@ -213,54 +209,24 @@ impl<'a, 'gcx, 'tcx> FieldDef {\n \n impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n     /// Calculate the forest of DefIds from which this type is visibly uninhabited.\n-    fn uninhabited_from(\n-        &self,\n-        visited: &mut FxHashMap<DefId, FxHashSet<&'tcx Substs<'tcx>>>,\n-        tcx: TyCtxt<'a, 'gcx, 'tcx>) -> DefIdForest\n+    fn uninhabited_from(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> DefIdForest\n     {\n         match self.sty {\n-            Adt(def, substs) => {\n-                {\n-                    let substs_set = visited.entry(def.did).or_default();\n-                    if !substs_set.insert(substs) {\n-                        // We are already calculating the inhabitedness of this type.\n-                        // The type must contain a reference to itself. Break the\n-                        // infinite loop.\n-                        return DefIdForest::empty();\n-                    }\n-                    if substs_set.len() >= tcx.sess.recursion_limit.get() / 4 {\n-                        // We have gone very deep, reinstantiating this ADT inside\n-                        // itself with different type arguments. We are probably\n-                        // hitting an infinite loop. For example, it's possible to write:\n-                        //                a type Foo<T>\n-                        //      which contains a Foo<(T, T)>\n-                        //      which contains a Foo<((T, T), (T, T))>\n-                        //      which contains a Foo<(((T, T), (T, T)), ((T, T), (T, T)))>\n-                        //      etc.\n-                        let error = format!(\"reached recursion limit while checking \\\n-                                             inhabitedness of `{}`\", self);\n-                        tcx.sess.fatal(&error);\n-                    }\n-                }\n-                let ret = def.uninhabited_from(visited, tcx, substs);\n-                let substs_set = visited.get_mut(&def.did).unwrap();\n-                substs_set.remove(substs);\n-                ret\n-            }\n+            Adt(def, substs) => def.uninhabited_from(tcx, substs),\n \n             Never => DefIdForest::full(tcx),\n \n             Tuple(ref tys) => {\n                 DefIdForest::union(tcx, tys.iter().map(|ty| {\n-                    ty.uninhabited_from(visited, tcx)\n+                    ty.uninhabited_from(tcx)\n                 }))\n             }\n \n             Array(ty, len) => {\n                 match len.assert_usize(tcx) {\n                     // If the array is definitely non-empty, it's uninhabited if\n                     // the type of its elements is uninhabited.\n-                    Some(n) if n != 0 => ty.uninhabited_from(visited, tcx),\n+                    Some(n) if n != 0 => ty.uninhabited_from(tcx),\n                     _ => DefIdForest::empty()\n                 }\n             }"}]}