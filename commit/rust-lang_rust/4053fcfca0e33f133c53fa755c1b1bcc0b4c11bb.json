{"sha": "4053fcfca0e33f133c53fa755c1b1bcc0b4c11bb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQwNTNmY2ZjYTBlMzNmMTMzYzUzZmE3NTVjMWIxYmNjMGI0YzExYmI=", "commit": {"author": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2019-12-21T14:00:44Z"}, "committer": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2019-12-22T23:08:03Z"}, "message": "Introduce our own Chalk TypeFamily, instead of using ChalkIr\n\nIt's not very different, except we can directly use Salsa IDs instead of casting\nthem. This means we need to refactor the handling of errors to get rid of\nUNKNOWN_TRAIT though.", "tree": {"sha": "6a77ae7692757830e4c0f5966824b6cd6979d4a2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6a77ae7692757830e4c0f5966824b6cd6979d4a2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4053fcfca0e33f133c53fa755c1b1bcc0b4c11bb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4053fcfca0e33f133c53fa755c1b1bcc0b4c11bb", "html_url": "https://github.com/rust-lang/rust/commit/4053fcfca0e33f133c53fa755c1b1bcc0b4c11bb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4053fcfca0e33f133c53fa755c1b1bcc0b4c11bb/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6b5efe5bdab160278469417734f4bb619c7bac61", "url": "https://api.github.com/repos/rust-lang/rust/commits/6b5efe5bdab160278469417734f4bb619c7bac61", "html_url": "https://github.com/rust-lang/rust/commit/6b5efe5bdab160278469417734f4bb619c7bac61"}], "stats": {"total": 213, "additions": 126, "deletions": 87}, "files": [{"sha": "ce9a06fde4b94bec40f1f438dbcaf698d5e68f1d", "filename": "crates/ra_hir_ty/src/tests/method_resolution.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4053fcfca0e33f133c53fa755c1b1bcc0b4c11bb/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4053fcfca0e33f133c53fa755c1b1bcc0b4c11bb/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fmethod_resolution.rs?ref=4053fcfca0e33f133c53fa755c1b1bcc0b4c11bb", "patch": "@@ -865,7 +865,7 @@ mod foo {\n \n #[test]\n fn method_resolution_where_clause_for_unknown_trait() {\n-    // The blanket impl shouldn't apply because we can't even resolve UnknownTrait\n+    // The blanket impl currently applies because we ignore the unresolved where clause\n     let t = type_at(\n         r#\"\n //- /main.rs\n@@ -875,7 +875,7 @@ impl<T> Trait for T where T: UnknownTrait {}\n fn test() { (&S).foo()<|>; }\n \"#,\n     );\n-    assert_eq!(t, \"{unknown}\");\n+    assert_eq!(t, \"u128\");\n }\n \n #[test]"}, {"sha": "c4dc857bc7b9cbe3ad61b1a885fb53188114f2d2", "filename": "crates/ra_hir_ty/src/traits.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4053fcfca0e33f133c53fa755c1b1bcc0b4c11bb/crates%2Fra_hir_ty%2Fsrc%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4053fcfca0e33f133c53fa755c1b1bcc0b4c11bb/crates%2Fra_hir_ty%2Fsrc%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftraits.rs?ref=4053fcfca0e33f133c53fa755c1b1bcc0b4c11bb", "patch": "@@ -291,7 +291,7 @@ impl FnTrait {\n     }\n }\n \n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub struct ClosureFnTraitImplData {\n     def: DefWithBodyId,\n     expr: ExprId,\n@@ -300,7 +300,7 @@ pub struct ClosureFnTraitImplData {\n \n /// An impl. Usually this comes from an impl block, but some built-in types get\n /// synthetic impls.\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub enum Impl {\n     /// A normal impl from an impl block.\n     ImplBlock(ImplId),"}, {"sha": "dd41176f0df66469b8bf4d5cb150bb8acd1721ca", "filename": "crates/ra_hir_ty/src/traits/builtin.rs", "status": "modified", "additions": 33, "deletions": 16, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/4053fcfca0e33f133c53fa755c1b1bcc0b4c11bb/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4053fcfca0e33f133c53fa755c1b1bcc0b4c11bb/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fbuiltin.rs?ref=4053fcfca0e33f133c53fa755c1b1bcc0b4c11bb", "patch": "@@ -28,24 +28,24 @@ pub(super) fn get_builtin_impls(\n     trait_: TraitId,\n     mut callback: impl FnMut(Impl),\n ) {\n+    // Note: since impl_datum needs to be infallible, we need to make sure here\n+    // that we have all prerequisites to build the respective impls.\n     if let Ty::Apply(ApplicationTy { ctor: TypeCtor::Closure { def, expr }, .. }) = ty {\n         for &fn_trait in [super::FnTrait::FnOnce, super::FnTrait::FnMut, super::FnTrait::Fn].iter()\n         {\n             if let Some(actual_trait) = get_fn_trait(db, krate, fn_trait) {\n                 if trait_ == actual_trait {\n                     let impl_ = super::ClosureFnTraitImplData { def: *def, expr: *expr, fn_trait };\n-                    callback(Impl::ClosureFnTraitImpl(impl_));\n+                    if check_closure_fn_trait_impl_prerequisites(db, krate, impl_) {\n+                        callback(Impl::ClosureFnTraitImpl(impl_));\n+                    }\n                 }\n             }\n         }\n     }\n }\n \n-pub(super) fn impl_datum(\n-    db: &impl HirDatabase,\n-    krate: CrateId,\n-    impl_: Impl,\n-) -> Option<BuiltinImplData> {\n+pub(super) fn impl_datum(db: &impl HirDatabase, krate: CrateId, impl_: Impl) -> BuiltinImplData {\n     match impl_ {\n         Impl::ImplBlock(_) => unreachable!(),\n         Impl::ClosureFnTraitImpl(data) => closure_fn_trait_impl_datum(db, krate, data),\n@@ -65,21 +65,38 @@ pub(super) fn associated_ty_value(\n     }\n }\n \n+fn check_closure_fn_trait_impl_prerequisites(\n+    db: &impl HirDatabase,\n+    krate: CrateId,\n+    data: super::ClosureFnTraitImplData,\n+) -> bool {\n+    // the respective Fn/FnOnce/FnMut trait needs to exist\n+    if get_fn_trait(db, krate, data.fn_trait).is_none() {\n+        return false;\n+    }\n+\n+    // FIXME: there are more assumptions that we should probably check here:\n+    // the traits having no type params, FnOnce being a supertrait\n+\n+    // the FnOnce trait needs to exist and have an assoc type named Output\n+    let fn_once_trait = match get_fn_trait(db, krate, super::FnTrait::FnOnce) {\n+        Some(t) => t,\n+        None => return false,\n+    };\n+    db.trait_data(fn_once_trait).associated_type_by_name(&name![Output]).is_some()\n+}\n+\n fn closure_fn_trait_impl_datum(\n     db: &impl HirDatabase,\n     krate: CrateId,\n     data: super::ClosureFnTraitImplData,\n-) -> Option<BuiltinImplData> {\n+) -> BuiltinImplData {\n     // for some closure |X, Y| -> Z:\n     // impl<T, U, V> Fn<(T, U)> for closure<fn(T, U) -> V> { Output = V }\n \n-    let trait_ = get_fn_trait(db, krate, data.fn_trait)?; // get corresponding fn trait\n-\n-    // validate FnOnce trait, since we need it in the assoc ty value definition\n-    // and don't want to return a valid value only to find out later that FnOnce\n-    // is broken\n-    let fn_once_trait = get_fn_trait(db, krate, super::FnTrait::FnOnce)?;\n-    let _output = db.trait_data(fn_once_trait).associated_type_by_name(&name![Output])?;\n+    let trait_ = get_fn_trait(db, krate, data.fn_trait) // get corresponding fn trait\n+        // the existence of the Fn trait has been checked before\n+        .expect(\"fn trait for closure impl missing\");\n \n     let num_args: u16 = match &db.body(data.def.into())[data.expr] {\n         Expr::Lambda { args, .. } => args.len() as u16,\n@@ -107,12 +124,12 @@ fn closure_fn_trait_impl_datum(\n \n     let output_ty_id = AssocTyValue::ClosureFnTraitImplOutput(data.clone());\n \n-    Some(BuiltinImplData {\n+    BuiltinImplData {\n         num_vars: num_args as usize + 1,\n         trait_ref,\n         where_clauses: Vec::new(),\n         assoc_ty_values: vec![output_ty_id],\n-    })\n+    }\n }\n \n fn closure_fn_trait_output_assoc_ty_value("}, {"sha": "9e38337e560c44641a7a1907b5994c5c4a0caac6", "filename": "crates/ra_hir_ty/src/traits/chalk.rs", "status": "modified", "additions": 89, "deletions": 67, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/4053fcfca0e33f133c53fa755c1b1bcc0b4c11bb/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4053fcfca0e33f133c53fa755c1b1bcc0b4c11bb/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk.rs?ref=4053fcfca0e33f133c53fa755c1b1bcc0b4c11bb", "patch": "@@ -1,5 +1,5 @@\n //! Conversion code from/to Chalk.\n-use std::sync::Arc;\n+use std::{fmt, sync::Arc};\n \n use log::debug;\n \n@@ -17,7 +17,73 @@ use crate::{\n     ProjectionTy, Substs, TraitRef, Ty, TypeCtor, TypeWalk,\n };\n \n-pub type TypeFamily = chalk_ir::family::ChalkIr;\n+#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]\n+pub struct TypeFamily {}\n+\n+impl chalk_ir::family::TypeFamily for TypeFamily {\n+    type InternedType = Box<chalk_ir::TyData<Self>>;\n+    type InternedLifetime = chalk_ir::LifetimeData<Self>;\n+    type InternedParameter = chalk_ir::ParameterData<Self>;\n+    type DefId = InternId;\n+\n+    // FIXME: implement these\n+    fn debug_struct_id(\n+        _type_kind_id: chalk_ir::StructId<Self>,\n+        _fmt: &mut fmt::Formatter<'_>,\n+    ) -> Option<fmt::Result> {\n+        None\n+    }\n+\n+    fn debug_trait_id(\n+        _type_kind_id: chalk_ir::TraitId<Self>,\n+        _fmt: &mut fmt::Formatter<'_>,\n+    ) -> Option<fmt::Result> {\n+        None\n+    }\n+\n+    fn debug_assoc_type_id(\n+        _id: chalk_ir::AssocTypeId<Self>,\n+        _fmt: &mut fmt::Formatter<'_>,\n+    ) -> Option<fmt::Result> {\n+        None\n+    }\n+\n+    fn debug_projection(\n+        _projection: &chalk_ir::ProjectionTy<Self>,\n+        _fmt: &mut fmt::Formatter<'_>,\n+    ) -> Option<fmt::Result> {\n+        None\n+    }\n+\n+    fn intern_ty(ty: chalk_ir::TyData<Self>) -> Box<chalk_ir::TyData<Self>> {\n+        Box::new(ty)\n+    }\n+\n+    fn ty_data(ty: &Box<chalk_ir::TyData<Self>>) -> &chalk_ir::TyData<Self> {\n+        ty\n+    }\n+\n+    fn intern_lifetime(lifetime: chalk_ir::LifetimeData<Self>) -> chalk_ir::LifetimeData<Self> {\n+        lifetime\n+    }\n+\n+    fn lifetime_data(lifetime: &chalk_ir::LifetimeData<Self>) -> &chalk_ir::LifetimeData<Self> {\n+        lifetime\n+    }\n+\n+    fn intern_parameter(parameter: chalk_ir::ParameterData<Self>) -> chalk_ir::ParameterData<Self> {\n+        parameter\n+    }\n+\n+    fn parameter_data(parameter: &chalk_ir::ParameterData<Self>) -> &chalk_ir::ParameterData<Self> {\n+        parameter\n+    }\n+}\n+\n+impl chalk_ir::family::HasTypeFamily for TypeFamily {\n+    type TypeFamily = Self;\n+}\n+\n pub type AssocTypeId = chalk_ir::AssocTypeId<TypeFamily>;\n pub type AssociatedTyDatum = chalk_rust_ir::AssociatedTyDatum<TypeFamily>;\n pub type TraitId = chalk_ir::TraitId<TypeFamily>;\n@@ -29,9 +95,6 @@ pub type ImplDatum = chalk_rust_ir::ImplDatum<TypeFamily>;\n pub type AssociatedTyValueId = chalk_rust_ir::AssociatedTyValueId;\n pub type AssociatedTyValue = chalk_rust_ir::AssociatedTyValue<TypeFamily>;\n \n-/// This represents a trait whose name we could not resolve.\n-const UNKNOWN_TRAIT: TraitId = chalk_ir::TraitId(chalk_ir::RawId { index: u32::max_value() });\n-\n pub(super) trait ToChalk {\n     type Chalk;\n     fn to_chalk(self, db: &impl HirDatabase) -> Self::Chalk;\n@@ -162,11 +225,11 @@ impl ToChalk for hir_def::TraitId {\n     type Chalk = TraitId;\n \n     fn to_chalk(self, _db: &impl HirDatabase) -> TraitId {\n-        chalk_ir::TraitId(id_to_chalk(self))\n+        chalk_ir::TraitId(self.as_intern_id())\n     }\n \n     fn from_chalk(_db: &impl HirDatabase, trait_id: TraitId) -> hir_def::TraitId {\n-        id_from_chalk(trait_id.0)\n+        InternKey::from_intern_id(trait_id.0)\n     }\n }\n \n@@ -215,11 +278,11 @@ impl ToChalk for TypeAliasId {\n     type Chalk = AssocTypeId;\n \n     fn to_chalk(self, _db: &impl HirDatabase) -> AssocTypeId {\n-        chalk_ir::AssocTypeId(id_to_chalk(self))\n+        chalk_ir::AssocTypeId(self.as_intern_id())\n     }\n \n     fn from_chalk(_db: &impl HirDatabase, type_alias_id: AssocTypeId) -> TypeAliasId {\n-        id_from_chalk(type_alias_id.0)\n+        InternKey::from_intern_id(type_alias_id.0)\n     }\n }\n \n@@ -250,13 +313,7 @@ impl ToChalk for GenericPredicate {\n                 }),\n                 0,\n             ),\n-            GenericPredicate::Error => {\n-                let impossible_trait_ref = chalk_ir::TraitRef {\n-                    trait_id: UNKNOWN_TRAIT,\n-                    parameters: vec![Ty::Unknown.to_chalk(db).cast()],\n-                };\n-                make_binders(chalk_ir::WhereClause::Implemented(impossible_trait_ref), 0)\n-            }\n+            GenericPredicate::Error => panic!(\"tried passing GenericPredicate::Error to Chalk\"),\n         }\n     }\n \n@@ -266,10 +323,6 @@ impl ToChalk for GenericPredicate {\n     ) -> GenericPredicate {\n         match where_clause.value {\n             chalk_ir::WhereClause::Implemented(tr) => {\n-                if tr.trait_id == UNKNOWN_TRAIT {\n-                    // FIXME we need an Error enum on the Chalk side to avoid this\n-                    return GenericPredicate::Error;\n-                }\n                 GenericPredicate::Implemented(from_chalk(db, tr))\n             }\n             chalk_ir::WhereClause::ProjectionEq(projection_eq) => {\n@@ -460,9 +513,8 @@ fn convert_where_clauses(\n     let mut result = Vec::with_capacity(generic_predicates.len());\n     for pred in generic_predicates.iter() {\n         if pred.is_error() {\n-            // HACK: Return just the single predicate (which is always false\n-            // anyway), otherwise Chalk can easily get into slow situations\n-            return vec![pred.clone().subst(substs).to_chalk(db)];\n+            // skip errored predicates completely\n+            continue;\n         }\n         result.push(pred.clone().subst(substs).to_chalk(db));\n     }\n@@ -491,10 +543,11 @@ where\n         parameters: &[Parameter<TypeFamily>],\n     ) -> Vec<ImplId> {\n         debug!(\"impls_for_trait {:?}\", trait_id);\n-        if trait_id == UNKNOWN_TRAIT {\n-            return Vec::new();\n-        }\n         let trait_: hir_def::TraitId = from_chalk(self.db, trait_id);\n+\n+        // Note: Since we're using impls_for_trait, only impls where the trait\n+        // can be resolved should ever reach Chalk. `impl_datum` relies on that\n+        // and will panic if the trait can't be resolved.\n         let mut result: Vec<_> = self\n             .db\n             .impls_for_trait(self.krate, trait_.into())\n@@ -566,24 +619,6 @@ pub(crate) fn trait_datum_query(\n     trait_id: TraitId,\n ) -> Arc<TraitDatum> {\n     debug!(\"trait_datum {:?}\", trait_id);\n-    if trait_id == UNKNOWN_TRAIT {\n-        let trait_datum_bound = chalk_rust_ir::TraitDatumBound { where_clauses: Vec::new() };\n-\n-        let flags = chalk_rust_ir::TraitFlags {\n-            auto: false,\n-            marker: false,\n-            upstream: true,\n-            fundamental: false,\n-            non_enumerable: true,\n-            coinductive: false,\n-        };\n-        return Arc::new(TraitDatum {\n-            id: trait_id,\n-            binders: make_binders(trait_datum_bound, 1),\n-            flags,\n-            associated_ty_ids: vec![],\n-        });\n-    }\n     let trait_: hir_def::TraitId = from_chalk(db, trait_id);\n     let trait_data = db.trait_data(trait_);\n     debug!(\"trait {:?} = {:?}\", trait_id, trait_data.name);\n@@ -653,18 +688,20 @@ pub(crate) fn impl_datum_query(\n     let impl_: Impl = from_chalk(db, impl_id);\n     match impl_ {\n         Impl::ImplBlock(impl_block) => impl_block_datum(db, krate, impl_id, impl_block),\n-        _ => builtin::impl_datum(db, krate, impl_).map(|d| Arc::new(d.to_chalk(db))),\n+        _ => Arc::new(builtin::impl_datum(db, krate, impl_).to_chalk(db)),\n     }\n-    .unwrap_or_else(invalid_impl_datum)\n }\n \n fn impl_block_datum(\n     db: &impl HirDatabase,\n     krate: CrateId,\n     chalk_id: ImplId,\n     impl_id: hir_def::ImplId,\n-) -> Option<Arc<ImplDatum>> {\n-    let trait_ref = db.impl_trait(impl_id)?;\n+) -> Arc<ImplDatum> {\n+    let trait_ref = db\n+        .impl_trait(impl_id)\n+        // ImplIds for impls where the trait ref can't be resolved should never reach Chalk\n+        .expect(\"invalid impl passed to Chalk\");\n     let impl_data = db.impl_data(impl_id);\n \n     let generic_params = generics(db, impl_id.into());\n@@ -716,21 +753,6 @@ fn impl_block_datum(\n         polarity,\n         associated_ty_value_ids,\n     };\n-    Some(Arc::new(impl_datum))\n-}\n-\n-fn invalid_impl_datum() -> Arc<ImplDatum> {\n-    let trait_ref = chalk_ir::TraitRef {\n-        trait_id: UNKNOWN_TRAIT,\n-        parameters: vec![chalk_ir::TyData::BoundVar(0).cast().intern().cast()],\n-    };\n-    let impl_datum_bound = chalk_rust_ir::ImplDatumBound { trait_ref, where_clauses: Vec::new() };\n-    let impl_datum = ImplDatum {\n-        binders: make_binders(impl_datum_bound, 1),\n-        impl_type: chalk_rust_ir::ImplType::External,\n-        polarity: chalk_rust_ir::Polarity::Positive,\n-        associated_ty_value_ids: Vec::new(),\n-    };\n     Arc::new(impl_datum)\n }\n \n@@ -786,25 +808,25 @@ fn id_to_chalk<T: InternKey>(salsa_id: T) -> chalk_ir::RawId {\n \n impl From<StructId> for crate::TypeCtorId {\n     fn from(struct_id: StructId) -> Self {\n-        id_from_chalk(struct_id.0)\n+        InternKey::from_intern_id(struct_id.0)\n     }\n }\n \n impl From<crate::TypeCtorId> for StructId {\n     fn from(type_ctor_id: crate::TypeCtorId) -> Self {\n-        chalk_ir::StructId(id_to_chalk(type_ctor_id))\n+        chalk_ir::StructId(type_ctor_id.as_intern_id())\n     }\n }\n \n impl From<ImplId> for crate::traits::GlobalImplId {\n     fn from(impl_id: ImplId) -> Self {\n-        id_from_chalk(impl_id.0)\n+        InternKey::from_intern_id(impl_id.0)\n     }\n }\n \n impl From<crate::traits::GlobalImplId> for ImplId {\n     fn from(impl_id: crate::traits::GlobalImplId) -> Self {\n-        chalk_ir::ImplId(id_to_chalk(impl_id))\n+        chalk_ir::ImplId(impl_id.as_intern_id())\n     }\n }\n "}]}