{"sha": "3b65165ab79f535792fc7c504b3fbadf29d7a877", "node_id": "C_kwDOAAsO6NoAKDNiNjUxNjVhYjc5ZjUzNTc5MmZjN2M1MDRiM2ZiYWRmMjlkN2E4Nzc", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-11-20T01:06:27Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-11-20T01:06:27Z"}, "message": "Auto merge of #91064 - matthiaskrgr:rollup-2ijidpt, r=matthiaskrgr\n\nRollup of 8 pull requests\n\nSuccessful merges:\n\n - #88361 (Makes docs for references a little less confusing)\n - #90089 (Improve display of enum variants)\n - #90956 (Add a regression test for #87573)\n - #90999 (fix CTFE/Miri simd_insert/extract on array-style repr(simd) types)\n - #91026 (rustdoc doctest: detect `fn main` after an unexpected semicolon)\n - #91035 (Put back removed empty line)\n - #91044 (Turn all 0x1b_u8 into '\\x1b' or b'\\x1b')\n - #91054 (rustdoc: Fix some unescaped HTML tags in docs)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "4164712d63a36017d395421f266b187752a5cefa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4164712d63a36017d395421f266b187752a5cefa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3b65165ab79f535792fc7c504b3fbadf29d7a877", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3b65165ab79f535792fc7c504b3fbadf29d7a877", "html_url": "https://github.com/rust-lang/rust/commit/3b65165ab79f535792fc7c504b3fbadf29d7a877", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3b65165ab79f535792fc7c504b3fbadf29d7a877/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a77da2d454e6caa227a85b16410b95f93495e7e0", "url": "https://api.github.com/repos/rust-lang/rust/commits/a77da2d454e6caa227a85b16410b95f93495e7e0", "html_url": "https://github.com/rust-lang/rust/commit/a77da2d454e6caa227a85b16410b95f93495e7e0"}, {"sha": "54bc33367cc6fb72b72b6ec96d7c62361fa9b145", "url": "https://api.github.com/repos/rust-lang/rust/commits/54bc33367cc6fb72b72b6ec96d7c62361fa9b145", "html_url": "https://github.com/rust-lang/rust/commit/54bc33367cc6fb72b72b6ec96d7c62361fa9b145"}], "stats": {"total": 422, "additions": 293, "deletions": 129}, "files": [{"sha": "9bbb42eb01961b509829655517085073e622163f", "filename": "compiler/rustc_const_eval/src/interpret/intrinsics.rs", "status": "modified", "additions": 16, "deletions": 31, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/3b65165ab79f535792fc7c504b3fbadf29d7a877/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b65165ab79f535792fc7c504b3fbadf29d7a877/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs?ref=3b65165ab79f535792fc7c504b3fbadf29d7a877", "patch": "@@ -419,48 +419,33 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             sym::simd_insert => {\n                 let index = u64::from(self.read_scalar(&args[1])?.to_u32()?);\n                 let elem = &args[2];\n-                let input = &args[0];\n-                let (len, e_ty) = input.layout.ty.simd_size_and_type(*self.tcx);\n+                let (input, input_len) = self.operand_to_simd(&args[0])?;\n+                let (dest, dest_len) = self.place_to_simd(dest)?;\n+                assert_eq!(input_len, dest_len, \"Return vector length must match input length\");\n                 assert!(\n-                    index < len,\n-                    \"Index `{}` must be in bounds of vector type `{}`: `[0, {})`\",\n+                    index < dest_len,\n+                    \"Index `{}` must be in bounds of vector with length {}`\",\n                     index,\n-                    e_ty,\n-                    len\n-                );\n-                assert_eq!(\n-                    input.layout, dest.layout,\n-                    \"Return type `{}` must match vector type `{}`\",\n-                    dest.layout.ty, input.layout.ty\n-                );\n-                assert_eq!(\n-                    elem.layout.ty, e_ty,\n-                    \"Scalar element type `{}` must match vector element type `{}`\",\n-                    elem.layout.ty, e_ty\n+                    dest_len\n                 );\n \n-                for i in 0..len {\n-                    let place = self.place_index(dest, i)?;\n-                    let value = if i == index { *elem } else { self.operand_index(input, i)? };\n-                    self.copy_op(&value, &place)?;\n+                for i in 0..dest_len {\n+                    let place = self.mplace_index(&dest, i)?;\n+                    let value =\n+                        if i == index { *elem } else { self.mplace_index(&input, i)?.into() };\n+                    self.copy_op(&value, &place.into())?;\n                 }\n             }\n             sym::simd_extract => {\n                 let index = u64::from(self.read_scalar(&args[1])?.to_u32()?);\n-                let (len, e_ty) = args[0].layout.ty.simd_size_and_type(*self.tcx);\n+                let (input, input_len) = self.operand_to_simd(&args[0])?;\n                 assert!(\n-                    index < len,\n-                    \"index `{}` is out-of-bounds of vector type `{}` with length `{}`\",\n+                    index < input_len,\n+                    \"index `{}` must be in bounds of vector with length `{}`\",\n                     index,\n-                    e_ty,\n-                    len\n-                );\n-                assert_eq!(\n-                    e_ty, dest.layout.ty,\n-                    \"Return type `{}` must match vector element type `{}`\",\n-                    dest.layout.ty, e_ty\n+                    input_len\n                 );\n-                self.copy_op(&self.operand_index(&args[0], index)?, dest)?;\n+                self.copy_op(&self.mplace_index(&input, index)?.into(), dest)?;\n             }\n             sym::likely | sym::unlikely | sym::black_box => {\n                 // These just return their argument"}, {"sha": "de9e94ce2ac0c820137e5edcb9c3f68ce20f848e", "filename": "compiler/rustc_const_eval/src/interpret/operand.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3b65165ab79f535792fc7c504b3fbadf29d7a877/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b65165ab79f535792fc7c504b3fbadf29d7a877/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs?ref=3b65165ab79f535792fc7c504b3fbadf29d7a877", "patch": "@@ -437,6 +437,18 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         })\n     }\n \n+    /// Converts a repr(simd) operand into an operand where `place_index` accesses the SIMD elements.\n+    /// Also returns the number of elements.\n+    pub fn operand_to_simd(\n+        &self,\n+        base: &OpTy<'tcx, M::PointerTag>,\n+    ) -> InterpResult<'tcx, (MPlaceTy<'tcx, M::PointerTag>, u64)> {\n+        // Basically we just transmute this place into an array following simd_size_and_type.\n+        // This only works in memory, but repr(simd) types should never be immediates anyway.\n+        assert!(base.layout.ty.is_simd());\n+        self.mplace_to_simd(&base.assert_mem_place())\n+    }\n+\n     /// Read from a local. Will not actually access the local if reading from a ZST.\n     /// Will not access memory, instead an indirect `Operand` is returned.\n     ///"}, {"sha": "d7f2853fc86f508a26d70aa3b61580c97db0a2f6", "filename": "compiler/rustc_const_eval/src/interpret/place.rs", "status": "modified", "additions": 27, "deletions": 1, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/3b65165ab79f535792fc7c504b3fbadf29d7a877/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b65165ab79f535792fc7c504b3fbadf29d7a877/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs?ref=3b65165ab79f535792fc7c504b3fbadf29d7a877", "patch": "@@ -200,7 +200,7 @@ impl<'tcx, Tag: Provenance> MPlaceTy<'tcx, Tag> {\n             }\n         } else {\n             // Go through the layout.  There are lots of types that support a length,\n-            // e.g., SIMD types.\n+            // e.g., SIMD types. (But not all repr(simd) types even have FieldsShape::Array!)\n             match self.layout.fields {\n                 FieldsShape::Array { count, .. } => Ok(count),\n                 _ => bug!(\"len not supported on sized type {:?}\", self.layout.ty),\n@@ -533,6 +533,22 @@ where\n         })\n     }\n \n+    /// Converts a repr(simd) place into a place where `place_index` accesses the SIMD elements.\n+    /// Also returns the number of elements.\n+    pub fn mplace_to_simd(\n+        &self,\n+        base: &MPlaceTy<'tcx, M::PointerTag>,\n+    ) -> InterpResult<'tcx, (MPlaceTy<'tcx, M::PointerTag>, u64)> {\n+        // Basically we just transmute this place into an array following simd_size_and_type.\n+        // (Transmuting is okay since this is an in-memory place. We also double-check the size\n+        // stays the same.)\n+        let (len, e_ty) = base.layout.ty.simd_size_and_type(*self.tcx);\n+        let array = self.tcx.mk_array(e_ty, len);\n+        let layout = self.layout_of(array)?;\n+        assert_eq!(layout.size, base.layout.size);\n+        Ok((MPlaceTy { layout, ..*base }, len))\n+    }\n+\n     /// Gets the place of a field inside the place, and also the field's type.\n     /// Just a convenience function, but used quite a bit.\n     /// This is the only projection that might have a side-effect: We cannot project\n@@ -594,6 +610,16 @@ where\n         })\n     }\n \n+    /// Converts a repr(simd) place into a place where `place_index` accesses the SIMD elements.\n+    /// Also returns the number of elements.\n+    pub fn place_to_simd(\n+        &mut self,\n+        base: &PlaceTy<'tcx, M::PointerTag>,\n+    ) -> InterpResult<'tcx, (MPlaceTy<'tcx, M::PointerTag>, u64)> {\n+        let mplace = self.force_allocation(base)?;\n+        self.mplace_to_simd(&mplace)\n+    }\n+\n     /// Computes a place. You should only use this if you intend to write into this\n     /// place; for reading, a more efficient alternative is `eval_place_for_read`.\n     pub fn eval_place("}, {"sha": "c79e25f4781c83e0e03d90b5b4c8f4cd90dd0fd4", "filename": "compiler/rustc_middle/src/ty/sty.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3b65165ab79f535792fc7c504b3fbadf29d7a877/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b65165ab79f535792fc7c504b3fbadf29d7a877/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs?ref=3b65165ab79f535792fc7c504b3fbadf29d7a877", "patch": "@@ -1805,17 +1805,22 @@ impl<'tcx> TyS<'tcx> {\n     pub fn simd_size_and_type(&self, tcx: TyCtxt<'tcx>) -> (u64, Ty<'tcx>) {\n         match self.kind() {\n             Adt(def, substs) => {\n+                assert!(def.repr.simd(), \"`simd_size_and_type` called on non-SIMD type\");\n                 let variant = def.non_enum_variant();\n                 let f0_ty = variant.fields[0].ty(tcx, substs);\n \n                 match f0_ty.kind() {\n+                    // If the first field is an array, we assume it is the only field and its\n+                    // elements are the SIMD components.\n                     Array(f0_elem_ty, f0_len) => {\n                         // FIXME(repr_simd): https://github.com/rust-lang/rust/pull/78863#discussion_r522784112\n                         // The way we evaluate the `N` in `[T; N]` here only works since we use\n                         // `simd_size_and_type` post-monomorphization. It will probably start to ICE\n                         // if we use it in generic code. See the `simd-array-trait` ui test.\n                         (f0_len.eval_usize(tcx, ParamEnv::empty()) as u64, f0_elem_ty)\n                     }\n+                    // Otherwise, the fields of this Adt are the SIMD components (and we assume they\n+                    // all have the same type).\n                     _ => (variant.fields.len() as u64, f0_ty),\n                 }\n             }"}, {"sha": "7250dca2adfe45bd1d55b7e27105b6a00c0a6283", "filename": "library/core/src/char/methods.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/3b65165ab79f535792fc7c504b3fbadf29d7a877/library%2Fcore%2Fsrc%2Fchar%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b65165ab79f535792fc7c504b3fbadf29d7a877/library%2Fcore%2Fsrc%2Fchar%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fchar%2Fmethods.rs?ref=3b65165ab79f535792fc7c504b3fbadf29d7a877", "patch": "@@ -1250,7 +1250,7 @@ impl char {\n     /// let percent = '%';\n     /// let space = ' ';\n     /// let lf = '\\n';\n-    /// let esc: char = 0x1b_u8.into();\n+    /// let esc = '\\x1b';\n     ///\n     /// assert!(uppercase_a.is_ascii_alphabetic());\n     /// assert!(uppercase_g.is_ascii_alphabetic());\n@@ -1284,7 +1284,7 @@ impl char {\n     /// let percent = '%';\n     /// let space = ' ';\n     /// let lf = '\\n';\n-    /// let esc: char = 0x1b_u8.into();\n+    /// let esc = '\\x1b';\n     ///\n     /// assert!(uppercase_a.is_ascii_uppercase());\n     /// assert!(uppercase_g.is_ascii_uppercase());\n@@ -1318,7 +1318,7 @@ impl char {\n     /// let percent = '%';\n     /// let space = ' ';\n     /// let lf = '\\n';\n-    /// let esc: char = 0x1b_u8.into();\n+    /// let esc = '\\x1b';\n     ///\n     /// assert!(!uppercase_a.is_ascii_lowercase());\n     /// assert!(!uppercase_g.is_ascii_lowercase());\n@@ -1355,7 +1355,7 @@ impl char {\n     /// let percent = '%';\n     /// let space = ' ';\n     /// let lf = '\\n';\n-    /// let esc: char = 0x1b_u8.into();\n+    /// let esc = '\\x1b';\n     ///\n     /// assert!(uppercase_a.is_ascii_alphanumeric());\n     /// assert!(uppercase_g.is_ascii_alphanumeric());\n@@ -1389,7 +1389,7 @@ impl char {\n     /// let percent = '%';\n     /// let space = ' ';\n     /// let lf = '\\n';\n-    /// let esc: char = 0x1b_u8.into();\n+    /// let esc = '\\x1b';\n     ///\n     /// assert!(!uppercase_a.is_ascii_digit());\n     /// assert!(!uppercase_g.is_ascii_digit());\n@@ -1426,7 +1426,7 @@ impl char {\n     /// let percent = '%';\n     /// let space = ' ';\n     /// let lf = '\\n';\n-    /// let esc: char = 0x1b_u8.into();\n+    /// let esc = '\\x1b';\n     ///\n     /// assert!(uppercase_a.is_ascii_hexdigit());\n     /// assert!(!uppercase_g.is_ascii_hexdigit());\n@@ -1464,7 +1464,7 @@ impl char {\n     /// let percent = '%';\n     /// let space = ' ';\n     /// let lf = '\\n';\n-    /// let esc: char = 0x1b_u8.into();\n+    /// let esc = '\\x1b';\n     ///\n     /// assert!(!uppercase_a.is_ascii_punctuation());\n     /// assert!(!uppercase_g.is_ascii_punctuation());\n@@ -1498,7 +1498,7 @@ impl char {\n     /// let percent = '%';\n     /// let space = ' ';\n     /// let lf = '\\n';\n-    /// let esc: char = 0x1b_u8.into();\n+    /// let esc = '\\x1b';\n     ///\n     /// assert!(uppercase_a.is_ascii_graphic());\n     /// assert!(uppercase_g.is_ascii_graphic());\n@@ -1549,7 +1549,7 @@ impl char {\n     /// let percent = '%';\n     /// let space = ' ';\n     /// let lf = '\\n';\n-    /// let esc: char = 0x1b_u8.into();\n+    /// let esc = '\\x1b';\n     ///\n     /// assert!(!uppercase_a.is_ascii_whitespace());\n     /// assert!(!uppercase_g.is_ascii_whitespace());\n@@ -1585,7 +1585,7 @@ impl char {\n     /// let percent = '%';\n     /// let space = ' ';\n     /// let lf = '\\n';\n-    /// let esc: char = 0x1b_u8.into();\n+    /// let esc = '\\x1b';\n     ///\n     /// assert!(!uppercase_a.is_ascii_control());\n     /// assert!(!uppercase_g.is_ascii_control());"}, {"sha": "e3eab07b9df6d7e63ee64cbad51a79c36acd4f3e", "filename": "library/core/src/num/mod.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/3b65165ab79f535792fc7c504b3fbadf29d7a877/library%2Fcore%2Fsrc%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b65165ab79f535792fc7c504b3fbadf29d7a877/library%2Fcore%2Fsrc%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fmod.rs?ref=3b65165ab79f535792fc7c504b3fbadf29d7a877", "patch": "@@ -428,7 +428,7 @@ impl u8 {\n     /// let percent = b'%';\n     /// let space = b' ';\n     /// let lf = b'\\n';\n-    /// let esc = 0x1b_u8;\n+    /// let esc = b'\\x1b';\n     ///\n     /// assert!(uppercase_a.is_ascii_alphabetic());\n     /// assert!(uppercase_g.is_ascii_alphabetic());\n@@ -462,7 +462,7 @@ impl u8 {\n     /// let percent = b'%';\n     /// let space = b' ';\n     /// let lf = b'\\n';\n-    /// let esc = 0x1b_u8;\n+    /// let esc = b'\\x1b';\n     ///\n     /// assert!(uppercase_a.is_ascii_uppercase());\n     /// assert!(uppercase_g.is_ascii_uppercase());\n@@ -496,7 +496,7 @@ impl u8 {\n     /// let percent = b'%';\n     /// let space = b' ';\n     /// let lf = b'\\n';\n-    /// let esc = 0x1b_u8;\n+    /// let esc = b'\\x1b';\n     ///\n     /// assert!(!uppercase_a.is_ascii_lowercase());\n     /// assert!(!uppercase_g.is_ascii_lowercase());\n@@ -533,7 +533,7 @@ impl u8 {\n     /// let percent = b'%';\n     /// let space = b' ';\n     /// let lf = b'\\n';\n-    /// let esc = 0x1b_u8;\n+    /// let esc = b'\\x1b';\n     ///\n     /// assert!(uppercase_a.is_ascii_alphanumeric());\n     /// assert!(uppercase_g.is_ascii_alphanumeric());\n@@ -567,7 +567,7 @@ impl u8 {\n     /// let percent = b'%';\n     /// let space = b' ';\n     /// let lf = b'\\n';\n-    /// let esc = 0x1b_u8;\n+    /// let esc = b'\\x1b';\n     ///\n     /// assert!(!uppercase_a.is_ascii_digit());\n     /// assert!(!uppercase_g.is_ascii_digit());\n@@ -604,7 +604,7 @@ impl u8 {\n     /// let percent = b'%';\n     /// let space = b' ';\n     /// let lf = b'\\n';\n-    /// let esc = 0x1b_u8;\n+    /// let esc = b'\\x1b';\n     ///\n     /// assert!(uppercase_a.is_ascii_hexdigit());\n     /// assert!(!uppercase_g.is_ascii_hexdigit());\n@@ -642,7 +642,7 @@ impl u8 {\n     /// let percent = b'%';\n     /// let space = b' ';\n     /// let lf = b'\\n';\n-    /// let esc = 0x1b_u8;\n+    /// let esc = b'\\x1b';\n     ///\n     /// assert!(!uppercase_a.is_ascii_punctuation());\n     /// assert!(!uppercase_g.is_ascii_punctuation());\n@@ -676,7 +676,7 @@ impl u8 {\n     /// let percent = b'%';\n     /// let space = b' ';\n     /// let lf = b'\\n';\n-    /// let esc = 0x1b_u8;\n+    /// let esc = b'\\x1b';\n     ///\n     /// assert!(uppercase_a.is_ascii_graphic());\n     /// assert!(uppercase_g.is_ascii_graphic());\n@@ -727,7 +727,7 @@ impl u8 {\n     /// let percent = b'%';\n     /// let space = b' ';\n     /// let lf = b'\\n';\n-    /// let esc = 0x1b_u8;\n+    /// let esc = b'\\x1b';\n     ///\n     /// assert!(!uppercase_a.is_ascii_whitespace());\n     /// assert!(!uppercase_g.is_ascii_whitespace());\n@@ -763,7 +763,7 @@ impl u8 {\n     /// let percent = b'%';\n     /// let space = b' ';\n     /// let lf = b'\\n';\n-    /// let esc = 0x1b_u8;\n+    /// let esc = b'\\x1b';\n     ///\n     /// assert!(!uppercase_a.is_ascii_control());\n     /// assert!(!uppercase_g.is_ascii_control());"}, {"sha": "f47a30c9b5d7dc109b4d402f1c918378615aa373", "filename": "library/core/src/primitive_docs.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3b65165ab79f535792fc7c504b3fbadf29d7a877/library%2Fcore%2Fsrc%2Fprimitive_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b65165ab79f535792fc7c504b3fbadf29d7a877/library%2Fcore%2Fsrc%2Fprimitive_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fprimitive_docs.rs?ref=3b65165ab79f535792fc7c504b3fbadf29d7a877", "patch": "@@ -1104,11 +1104,10 @@ mod prim_usize {}\n /// * [`Clone`] \\(Note that this will not defer to `T`'s `Clone` implementation if it exists!)\n /// * [`Deref`]\n /// * [`Borrow`]\n-/// * [`Pointer`]\n+/// * [`fmt::Pointer`]\n ///\n /// [`Deref`]: ops::Deref\n /// [`Borrow`]: borrow::Borrow\n-/// [`Pointer`]: fmt::Pointer\n ///\n /// `&mut T` references get all of the above except `Copy` and `Clone` (to prevent creating\n /// multiple simultaneous mutable borrows), plus the following, regardless of the type of its\n@@ -1124,7 +1123,7 @@ mod prim_usize {}\n /// The following traits are implemented on `&T` references if the underlying `T` also implements\n /// that trait:\n ///\n-/// * All the traits in [`std::fmt`] except [`Pointer`] and [`fmt::Write`]\n+/// * All the traits in [`std::fmt`] except [`fmt::Pointer`] (which is implemented regardless of the type of its referent) and [`fmt::Write`]\n /// * [`PartialOrd`]\n /// * [`Ord`]\n /// * [`PartialEq`]\n@@ -1133,9 +1132,9 @@ mod prim_usize {}\n /// * [`Fn`] \\(in addition, `&T` references get [`FnMut`] and [`FnOnce`] if `T: Fn`)\n /// * [`Hash`]\n /// * [`ToSocketAddrs`]\n+/// * [`Send`] \\(`&T` references also require <code>T: [Sync]</code>)\n ///\n /// [`std::fmt`]: fmt\n-/// ['Pointer`]: fmt::Pointer\n /// [`Hash`]: hash::Hash\n #[doc = concat!(\"[`ToSocketAddrs`]: \", include_str!(\"../primitive_docs/net_tosocketaddrs.md\"))]\n ///\n@@ -1150,7 +1149,6 @@ mod prim_usize {}\n /// * [`ExactSizeIterator`]\n /// * [`FusedIterator`]\n /// * [`TrustedLen`]\n-/// * [`Send`] \\(note that `&T` references only get `Send` if <code>T: [Sync]</code>)\n /// * [`io::Write`]\n /// * [`Read`]\n /// * [`Seek`]"}, {"sha": "f47a30c9b5d7dc109b4d402f1c918378615aa373", "filename": "library/std/src/primitive_docs.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3b65165ab79f535792fc7c504b3fbadf29d7a877/library%2Fstd%2Fsrc%2Fprimitive_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b65165ab79f535792fc7c504b3fbadf29d7a877/library%2Fstd%2Fsrc%2Fprimitive_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fprimitive_docs.rs?ref=3b65165ab79f535792fc7c504b3fbadf29d7a877", "patch": "@@ -1104,11 +1104,10 @@ mod prim_usize {}\n /// * [`Clone`] \\(Note that this will not defer to `T`'s `Clone` implementation if it exists!)\n /// * [`Deref`]\n /// * [`Borrow`]\n-/// * [`Pointer`]\n+/// * [`fmt::Pointer`]\n ///\n /// [`Deref`]: ops::Deref\n /// [`Borrow`]: borrow::Borrow\n-/// [`Pointer`]: fmt::Pointer\n ///\n /// `&mut T` references get all of the above except `Copy` and `Clone` (to prevent creating\n /// multiple simultaneous mutable borrows), plus the following, regardless of the type of its\n@@ -1124,7 +1123,7 @@ mod prim_usize {}\n /// The following traits are implemented on `&T` references if the underlying `T` also implements\n /// that trait:\n ///\n-/// * All the traits in [`std::fmt`] except [`Pointer`] and [`fmt::Write`]\n+/// * All the traits in [`std::fmt`] except [`fmt::Pointer`] (which is implemented regardless of the type of its referent) and [`fmt::Write`]\n /// * [`PartialOrd`]\n /// * [`Ord`]\n /// * [`PartialEq`]\n@@ -1133,9 +1132,9 @@ mod prim_usize {}\n /// * [`Fn`] \\(in addition, `&T` references get [`FnMut`] and [`FnOnce`] if `T: Fn`)\n /// * [`Hash`]\n /// * [`ToSocketAddrs`]\n+/// * [`Send`] \\(`&T` references also require <code>T: [Sync]</code>)\n ///\n /// [`std::fmt`]: fmt\n-/// ['Pointer`]: fmt::Pointer\n /// [`Hash`]: hash::Hash\n #[doc = concat!(\"[`ToSocketAddrs`]: \", include_str!(\"../primitive_docs/net_tosocketaddrs.md\"))]\n ///\n@@ -1150,7 +1149,6 @@ mod prim_usize {}\n /// * [`ExactSizeIterator`]\n /// * [`FusedIterator`]\n /// * [`TrustedLen`]\n-/// * [`Send`] \\(note that `&T` references only get `Send` if <code>T: [Sync]</code>)\n /// * [`io::Write`]\n /// * [`Read`]\n /// * [`Seek`]"}, {"sha": "8da1d22a4d172d3f6a2c5830bcc10cc138d6df1d", "filename": "src/doc/rustdoc/src/unstable-features.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3b65165ab79f535792fc7c504b3fbadf29d7a877/src%2Fdoc%2Frustdoc%2Fsrc%2Funstable-features.md", "raw_url": "https://github.com/rust-lang/rust/raw/3b65165ab79f535792fc7c504b3fbadf29d7a877/src%2Fdoc%2Frustdoc%2Fsrc%2Funstable-features.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustdoc%2Fsrc%2Funstable-features.md?ref=3b65165ab79f535792fc7c504b3fbadf29d7a877", "patch": "@@ -398,6 +398,7 @@ undocumented item:\n ```rust\n /// This item has documentation\n pub fn foo() {}\n+\n pub fn no_documentation() {}\n ```\n "}, {"sha": "37db20aaefa8d327311e91bf9f6e7234af0f5f8f", "filename": "src/librustdoc/doctest.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/3b65165ab79f535792fc7c504b3fbadf29d7a877/src%2Flibrustdoc%2Fdoctest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b65165ab79f535792fc7c504b3fbadf29d7a877/src%2Flibrustdoc%2Fdoctest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoctest.rs?ref=3b65165ab79f535792fc7c504b3fbadf29d7a877", "patch": "@@ -1,4 +1,4 @@\n-use rustc_ast as ast;\n+use rustc_ast::{self as ast, token};\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::sync::Lrc;\n use rustc_errors::{ColorConfig, ErrorReported, FatalError};\n@@ -537,7 +537,6 @@ crate fn make_test(\n             use rustc_errors::emitter::{Emitter, EmitterWriter};\n             use rustc_errors::Handler;\n             use rustc_parse::maybe_new_parser_from_source_str;\n-            use rustc_parse::parser::ForceCollect;\n             use rustc_session::parse::ParseSess;\n             use rustc_span::source_map::FilePathMapping;\n \n@@ -573,9 +572,9 @@ crate fn make_test(\n                 }\n             };\n \n-            loop {\n-                match parser.parse_item(ForceCollect::No) {\n-                    Ok(Some(item)) => {\n+            match parser.parse_mod(&token::Eof) {\n+                Ok((_attrs, items, _span)) => {\n+                    for item in items {\n                         if !found_main {\n                             if let ast::ItemKind::Fn(..) = item.kind {\n                                 if item.ident.name == sym::main {\n@@ -607,11 +606,9 @@ crate fn make_test(\n                             break;\n                         }\n                     }\n-                    Ok(None) => break,\n-                    Err(mut e) => {\n-                        e.cancel();\n-                        break;\n-                    }\n+                }\n+                Err(mut e) => {\n+                    e.cancel();\n                 }\n             }\n "}, {"sha": "6ed911b8d24099ff4cf3e1dc2079a734df6a08e8", "filename": "src/librustdoc/externalfiles.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3b65165ab79f535792fc7c504b3fbadf29d7a877/src%2Flibrustdoc%2Fexternalfiles.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b65165ab79f535792fc7c504b3fbadf29d7a877/src%2Flibrustdoc%2Fexternalfiles.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fexternalfiles.rs?ref=3b65165ab79f535792fc7c504b3fbadf29d7a877", "patch": "@@ -8,13 +8,13 @@ use serde::Serialize;\n \n #[derive(Clone, Debug, Serialize)]\n crate struct ExternalHtml {\n-    /// Content that will be included inline in the <head> section of a\n+    /// Content that will be included inline in the `<head>` section of a\n     /// rendered Markdown file or generated documentation\n     crate in_header: String,\n-    /// Content that will be included inline between <body> and the content of\n+    /// Content that will be included inline between `<body>` and the content of\n     /// a rendered Markdown file or generated documentation\n     crate before_content: String,\n-    /// Content that will be included inline between the content and </body> of\n+    /// Content that will be included inline between the content and `</body>` of\n     /// a rendered Markdown file or generated documentation\n     crate after_content: String,\n }"}, {"sha": "049d17a4b477af36e53639465ab24202beebbd9e", "filename": "src/librustdoc/html/render/print_item.rs", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/3b65165ab79f535792fc7c504b3fbadf29d7a877/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b65165ab79f535792fc7c504b3fbadf29d7a877/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs?ref=3b65165ab79f535792fc7c504b3fbadf29d7a877", "patch": "@@ -1080,7 +1080,7 @@ fn item_enum(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, e: &clean::Enum\n                 cx.derive_id(format!(\"{}.{}\", ItemType::Variant, variant.name.as_ref().unwrap()));\n             write!(\n                 w,\n-                \"<div id=\\\"{id}\\\" class=\\\"variant small-section-header\\\">\\\n+                \"<h3 id=\\\"{id}\\\" class=\\\"variant small-section-header\\\">\\\n                     <a href=\\\"#{id}\\\" class=\\\"anchor field\\\"></a>\\\n                     <code>{name}\",\n                 id = id,\n@@ -1093,9 +1093,7 @@ fn item_enum(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, e: &clean::Enum\n             }\n             w.write_str(\"</code>\");\n             render_stability_since(w, variant, it, cx.tcx());\n-            w.write_str(\"</div>\");\n-            document(w, cx, variant, Some(it), HeadingOffset::H3);\n-            document_non_exhaustive(w, variant);\n+            w.write_str(\"</h3>\");\n \n             use crate::clean::Variant;\n             if let Some((extra, fields)) = match *variant.kind {\n@@ -1109,12 +1107,8 @@ fn item_enum(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, e: &clean::Enum\n                     variant.name.as_ref().unwrap()\n                 ));\n                 write!(w, \"<div class=\\\"sub-variant\\\" id=\\\"{id}\\\">\", id = variant_id);\n-                write!(\n-                    w,\n-                    \"<h3>{extra}Fields of <b>{name}</b></h3><div>\",\n-                    extra = extra,\n-                    name = variant.name.as_ref().unwrap(),\n-                );\n+                write!(w, \"<h4>{extra}Fields</h4>\", extra = extra,);\n+                document_non_exhaustive(w, variant);\n                 for field in fields {\n                     match *field.kind {\n                         clean::StrippedItem(box clean::StructFieldItem(_)) => {}\n@@ -1126,21 +1120,25 @@ fn item_enum(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, e: &clean::Enum\n                             ));\n                             write!(\n                                 w,\n-                                \"<span id=\\\"{id}\\\" class=\\\"variant small-section-header\\\">\\\n+                                \"<div class=\\\"sub-variant-field\\\">\\\n+                                 <span id=\\\"{id}\\\" class=\\\"variant small-section-header\\\">\\\n                                     <a href=\\\"#{id}\\\" class=\\\"anchor field\\\"></a>\\\n                                     <code>{f}:&nbsp;{t}</code>\\\n                                 </span>\",\n                                 id = id,\n                                 f = field.name.as_ref().unwrap(),\n                                 t = ty.print(cx)\n                             );\n-                            document(w, cx, field, Some(variant), HeadingOffset::H4);\n+                            document(w, cx, field, Some(variant), HeadingOffset::H5);\n+                            write!(w, \"</div>\");\n                         }\n                         _ => unreachable!(),\n                     }\n                 }\n-                w.write_str(\"</div></div>\");\n+                w.write_str(\"</div>\");\n             }\n+\n+            document(w, cx, variant, Some(it), HeadingOffset::H4);\n         }\n     }\n     let def_id = it.def_id.expect_def_id();"}, {"sha": "cb1df15bbb152237f003cf33fd93433280c90d8a", "filename": "src/librustdoc/html/static/css/rustdoc.css", "status": "modified", "additions": 16, "deletions": 13, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/3b65165ab79f535792fc7c504b3fbadf29d7a877/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/3b65165ab79f535792fc7c504b3fbadf29d7a877/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css?ref=3b65165ab79f535792fc7c504b3fbadf29d7a877", "patch": "@@ -1102,25 +1102,28 @@ a.test-arrow:hover{\n \tmargin-right: 5px;\n }\n \n-.sub-variant, .sub-variant > h3 {\n-\tmargin-top: 0px !important;\n-\tpadding-top: 1px;\n+h3.variant {\n+\tfont-weight: 600;\n+\tfont-size: 1.1em;\n+\tmargin-bottom: 10px;\n+\tborder-bottom: none;\n }\n \n-#main .sub-variant > h3 {\n-\tfont-size: 15px;\n-\tmargin-left: 25px;\n-\tmargin-bottom: 5px;\n+.sub-variant h4 {\n+\tfont-size: 1em;\n+\tfont-weight: 400;\n+\tborder-bottom: none;\n+\tmargin-top: 0;\n+\tmargin-bottom: 0;\n }\n \n-.sub-variant > div {\n-\tmargin-left: 20px;\n-\tmargin-bottom: 10px;\n+.sub-variant {\n+\tmargin-left: 24px;\n+\tmargin-bottom: 40px;\n }\n \n-.sub-variant > div > span {\n-\tdisplay: block;\n-\tposition: relative;\n+.sub-variant > .sub-variant-field {\n+\tmargin-left: 24px;\n }\n \n .toggle-label {"}, {"sha": "87c512468e05fd9a1dcfd0fdc5a91028c8933c2a", "filename": "src/test/rustdoc-gui/headings.goml", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/3b65165ab79f535792fc7c504b3fbadf29d7a877/src%2Ftest%2Frustdoc-gui%2Fheadings.goml", "raw_url": "https://github.com/rust-lang/rust/raw/3b65165ab79f535792fc7c504b3fbadf29d7a877/src%2Ftest%2Frustdoc-gui%2Fheadings.goml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-gui%2Fheadings.goml?ref=3b65165ab79f535792fc7c504b3fbadf29d7a877", "patch": "@@ -1,4 +1,4 @@\n-// This test check that headers (a) have the correct heading level, (b) are the right size,\n+// This test checks that headers (a) have the correct heading level, (b) are the right size,\n // and (c) have the correct underlining (or absence of underlining).\n // The sizes may change as design changes, but try to make sure a lower header is never bigger than\n // its parent headers. Also make sure lower headers don't have underlines when their parents lack\n@@ -67,25 +67,25 @@ assert-css: (\"h4#top-doc-prose-sub-sub-heading\", {\"border-bottom-width\": \"1px\"})\n assert-css: (\"h2#variants\", {\"font-size\": \"22.4px\"})\n assert-css: (\"h2#variants\", {\"border-bottom-width\": \"1px\"})\n \n-assert-css: (\"h3#none-prose-title\", {\"font-size\": \"20.8px\"})\n-assert-css: (\"h3#none-prose-title\", {\"border-bottom-width\": \"0px\"})\n-assert-css: (\"h4#none-prose-sub-heading\", {\"font-size\": \"16px\"})\n-assert-css: (\"h4#none-prose-sub-heading\", {\"border-bottom-width\": \"0px\"})\n-\n-assert-css: (\"h3#wrapped-prose-title\", {\"font-size\": \"20.8px\"})\n-assert-css: (\"h3#wrapped-prose-title\", {\"border-bottom-width\": \"0px\"})\n-assert-css: (\"h4#wrapped-prose-sub-heading\", {\"font-size\": \"16px\"})\n-assert-css: (\"h4#wrapped-prose-sub-heading\", {\"border-bottom-width\": \"0px\"})\n-\n-assert-css: (\"h4#wrapped0-prose-title\", {\"font-size\": \"16px\"})\n-assert-css: (\"h4#wrapped0-prose-title\", {\"border-bottom-width\": \"0px\"})\n-assert-css: (\"h5#wrapped0-prose-sub-heading\", {\"font-size\": \"16px\"})\n-assert-css: (\"h5#wrapped0-prose-sub-heading\", {\"border-bottom-width\": \"0px\"})\n-\n-assert-css: (\"h4#structy-prose-title\", {\"font-size\": \"16px\"})\n-assert-css: (\"h4#structy-prose-title\", {\"border-bottom-width\": \"0px\"})\n-assert-css: (\"h5#structy-prose-sub-heading\", {\"font-size\": \"16px\"})\n-assert-css: (\"h5#structy-prose-sub-heading\", {\"border-bottom-width\": \"0px\"})\n+assert-css: (\"h4#none-prose-title\", {\"font-size\": \"16px\"})\n+assert-css: (\"h4#none-prose-title\", {\"border-bottom-width\": \"0px\"})\n+assert-css: (\"h5#none-prose-sub-heading\", {\"font-size\": \"16px\"})\n+assert-css: (\"h5#none-prose-sub-heading\", {\"border-bottom-width\": \"0px\"})\n+\n+assert-css: (\"h4#wrapped-prose-title\", {\"font-size\": \"16px\"})\n+assert-css: (\"h4#wrapped-prose-title\", {\"border-bottom-width\": \"0px\"})\n+assert-css: (\"h5#wrapped-prose-sub-heading\", {\"font-size\": \"16px\"})\n+assert-css: (\"h5#wrapped-prose-sub-heading\", {\"border-bottom-width\": \"0px\"})\n+\n+assert-css: (\"h5#wrapped0-prose-title\", {\"font-size\": \"16px\"})\n+assert-css: (\"h5#wrapped0-prose-title\", {\"border-bottom-width\": \"0px\"})\n+assert-css: (\"h6#wrapped0-prose-sub-heading\", {\"font-size\": \"15.2px\"})\n+assert-css: (\"h6#wrapped0-prose-sub-heading\", {\"border-bottom-width\": \"0px\"})\n+\n+assert-css: (\"h5#structy-prose-title\", {\"font-size\": \"16px\"})\n+assert-css: (\"h5#structy-prose-title\", {\"border-bottom-width\": \"0px\"})\n+assert-css: (\"h6#structy-prose-sub-heading\", {\"font-size\": \"15.2px\"})\n+assert-css: (\"h6#structy-prose-sub-heading\", {\"border-bottom-width\": \"0px\"})\n \n assert-css: (\"h2#implementations\", {\"font-size\": \"22.4px\"})\n assert-css: (\"h2#implementations\", {\"border-bottom-width\": \"1px\"})"}, {"sha": "16d737106ea890e2dd8f348625f8a0554c00f9c0", "filename": "src/test/rustdoc-ui/failed-doctest-extra-semicolon-on-item.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3b65165ab79f535792fc7c504b3fbadf29d7a877/src%2Ftest%2Frustdoc-ui%2Ffailed-doctest-extra-semicolon-on-item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b65165ab79f535792fc7c504b3fbadf29d7a877/src%2Ftest%2Frustdoc-ui%2Ffailed-doctest-extra-semicolon-on-item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Ffailed-doctest-extra-semicolon-on-item.rs?ref=3b65165ab79f535792fc7c504b3fbadf29d7a877", "patch": "@@ -0,0 +1,18 @@\n+// FIXME: if/when the output of the test harness can be tested on its own, this test should be\n+// adapted to use that, and that normalize line can go away\n+\n+// compile-flags:--test\n+// normalize-stdout-test: \"src/test/rustdoc-ui\" -> \"$$DIR\"\n+// normalize-stdout-test \"finished in \\d+\\.\\d+s\" -> \"finished in $$TIME\"\n+// failure-status: 101\n+\n+/// <https://github.com/rust-lang/rust/issues/91014>\n+///\n+/// ```rust\n+/// struct S {}; // unexpected semicolon after struct def\n+///\n+/// fn main() {\n+///    assert_eq!(0, 1);\n+/// }\n+/// ```\n+mod m {}"}, {"sha": "61468b6c7457b3cdf3922f0fbc6eacdd64286898", "filename": "src/test/rustdoc-ui/failed-doctest-extra-semicolon-on-item.stdout", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/3b65165ab79f535792fc7c504b3fbadf29d7a877/src%2Ftest%2Frustdoc-ui%2Ffailed-doctest-extra-semicolon-on-item.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/3b65165ab79f535792fc7c504b3fbadf29d7a877/src%2Ftest%2Frustdoc-ui%2Ffailed-doctest-extra-semicolon-on-item.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Ffailed-doctest-extra-semicolon-on-item.stdout?ref=3b65165ab79f535792fc7c504b3fbadf29d7a877", "patch": "@@ -0,0 +1,24 @@\n+\n+running 1 test\n+test $DIR/failed-doctest-extra-semicolon-on-item.rs - m (line 11) ... FAILED\n+\n+failures:\n+\n+---- $DIR/failed-doctest-extra-semicolon-on-item.rs - m (line 11) stdout ----\n+error: expected item, found `;`\n+  --> $DIR/failed-doctest-extra-semicolon-on-item.rs:12:12\n+   |\n+LL | struct S {}; // unexpected semicolon after struct def\n+   |            ^ help: remove this semicolon\n+   |\n+   = help: braced struct declarations are not followed by a semicolon\n+\n+error: aborting due to previous error\n+\n+Couldn't compile the test.\n+\n+failures:\n+    $DIR/failed-doctest-extra-semicolon-on-item.rs - m (line 11)\n+\n+test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in $TIME\n+"}, {"sha": "2e5c34391c4af5a0e99b760ce7c4adb420e14839", "filename": "src/test/rustdoc/enum-headings.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/3b65165ab79f535792fc7c504b3fbadf29d7a877/src%2Ftest%2Frustdoc%2Fenum-headings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b65165ab79f535792fc7c504b3fbadf29d7a877/src%2Ftest%2Frustdoc%2Fenum-headings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fenum-headings.rs?ref=3b65165ab79f535792fc7c504b3fbadf29d7a877", "patch": "@@ -0,0 +1,40 @@\n+#![crate_name = \"foo\"]\n+// @has foo/enum.Token.html\n+/// A token!\n+/// # First\n+/// Some following text...\n+// @has - '//h2[@id=\"first\"]' \"First\"\n+pub enum Token {\n+    /// A declaration!\n+    /// # Variant-First\n+    /// Some following text...\n+    // @has - '//h4[@id=\"variant-first\"]' \"Variant-First\"\n+    Declaration {\n+        /// A version!\n+        /// # Variant-Field-First\n+        /// Some following text...\n+        // @has - '//h5[@id=\"variant-field-first\"]' \"Variant-Field-First\"\n+        version: String,\n+    },\n+    /// A Zoople!\n+    /// # Variant-First\n+    Zoople(\n+        // @has - '//h5[@id=\"variant-tuple-field-first\"]' \"Variant-Tuple-Field-First\"\n+        /// Zoople's first variant!\n+        /// # Variant-Tuple-Field-First\n+        /// Some following text...\n+        usize,\n+    ),\n+    /// Unfinished business!\n+    /// # Non-Exhaustive-First\n+    /// Some following text...\n+    // @has - '//h4[@id=\"non-exhaustive-first\"]' \"Non-Exhaustive-First\"\n+    #[non_exhaustive]\n+    Unfinished {\n+        /// This is x.\n+        /// # X-First\n+        /// Some following text...\n+        // @has - '//h5[@id=\"x-first\"]' \"X-First\"\n+        x: usize,\n+    },\n+}"}, {"sha": "139c5b4391ab7261860d3eb2f6f84ef99fd187af", "filename": "src/test/rustdoc/tuple-struct-fields-doc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3b65165ab79f535792fc7c504b3fbadf29d7a877/src%2Ftest%2Frustdoc%2Ftuple-struct-fields-doc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b65165ab79f535792fc7c504b3fbadf29d7a877/src%2Ftest%2Frustdoc%2Ftuple-struct-fields-doc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Ftuple-struct-fields-doc.rs?ref=3b65165ab79f535792fc7c504b3fbadf29d7a877", "patch": "@@ -20,10 +20,10 @@ pub struct Foo(\n \n // @has foo/enum.Bar.html\n // @has - '//pre[@class=\"rust enum\"]' 'BarVariant(String),'\n-// @matches - '//*[@id=\"variant.BarVariant.fields\"]/h3' '^Tuple Fields of BarVariant$'\n+// @matches - '//*[@id=\"variant.BarVariant.fields\"]/h4' '^Tuple Fields$'\n // @has - '//*[@id=\"variant.BarVariant.field.0\"]' '0: String'\n // @has - '//*[@id=\"variant.BarVariant.fields\"]//*[@class=\"docblock\"]' 'Hello docs'\n-// @matches - '//*[@id=\"variant.FooVariant.fields\"]/h3' '^Fields of FooVariant$'\n+// @matches - '//*[@id=\"variant.FooVariant.fields\"]/h4' '^Fields$'\n pub enum Bar {\n     BarVariant(\n         /// Hello docs"}, {"sha": "a1d6c5e51b49896726271f4f207da931fdc1fe06", "filename": "src/test/ui/consts/const-eval/simd/insert_extract.rs", "status": "modified", "additions": 16, "deletions": 6, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/3b65165ab79f535792fc7c504b3fbadf29d7a877/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fsimd%2Finsert_extract.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b65165ab79f535792fc7c504b3fbadf29d7a877/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fsimd%2Finsert_extract.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fsimd%2Finsert_extract.rs?ref=3b65165ab79f535792fc7c504b3fbadf29d7a877", "patch": "@@ -7,7 +7,9 @@\n \n #[repr(simd)] struct i8x1(i8);\n #[repr(simd)] struct u16x2(u16, u16);\n-#[repr(simd)] struct f32x4(f32, f32, f32, f32);\n+// Make some of them array types to ensure those also work.\n+#[repr(simd)] struct i8x1_arr([i8; 1]);\n+#[repr(simd)] struct f32x4([f32; 4]);\n \n extern \"platform-intrinsic\" {\n     #[rustc_const_stable(feature = \"foo\", since = \"1.3.37\")]\n@@ -25,6 +27,14 @@ fn main() {\n         assert_eq!(X0, 42);\n         assert_eq!(Y0, 42);\n     }\n+    {\n+        const U: i8x1_arr = i8x1_arr([13]);\n+        const V: i8x1_arr = unsafe { simd_insert(U, 0_u32, 42_i8) };\n+        const X0: i8 = V.0[0];\n+        const Y0: i8 = unsafe { simd_extract(V, 0) };\n+        assert_eq!(X0, 42);\n+        assert_eq!(Y0, 42);\n+    }\n     {\n         const U: u16x2 = u16x2(13, 14);\n         const V: u16x2 = unsafe { simd_insert(U, 1_u32, 42_u16) };\n@@ -38,12 +48,12 @@ fn main() {\n         assert_eq!(Y1, 42);\n     }\n     {\n-        const U: f32x4 = f32x4(13., 14., 15., 16.);\n+        const U: f32x4 = f32x4([13., 14., 15., 16.]);\n         const V: f32x4 = unsafe { simd_insert(U, 1_u32, 42_f32) };\n-        const X0: f32 = V.0;\n-        const X1: f32 = V.1;\n-        const X2: f32 = V.2;\n-        const X3: f32 = V.3;\n+        const X0: f32 = V.0[0];\n+        const X1: f32 = V.0[1];\n+        const X2: f32 = V.0[2];\n+        const X3: f32 = V.0[3];\n         const Y0: f32 = unsafe { simd_extract(V, 0) };\n         const Y1: f32 = unsafe { simd_extract(V, 1) };\n         const Y2: f32 = unsafe { simd_extract(V, 2) };"}, {"sha": "aeb0c245a72ecee184bd1d34fb2ea5d0aca90290", "filename": "src/test/ui/lang-items/issue-87573.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/3b65165ab79f535792fc7c504b3fbadf29d7a877/src%2Ftest%2Fui%2Flang-items%2Fissue-87573.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b65165ab79f535792fc7c504b3fbadf29d7a877/src%2Ftest%2Fui%2Flang-items%2Fissue-87573.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flang-items%2Fissue-87573.rs?ref=3b65165ab79f535792fc7c504b3fbadf29d7a877", "patch": "@@ -0,0 +1,28 @@\n+// Regression test for #87573, ensures that duplicate lang items or invalid generics\n+// for lang items doesn't cause ICE.\n+\n+#![feature(no_core, lang_items)]\n+#![no_core]\n+#![crate_type = \"lib\"]\n+\n+pub static STATIC_BOOL: bool = true;\n+\n+#[lang = \"sized\"]\n+trait Sized {}\n+\n+#[lang = \"copy\"]\n+trait Copy {}\n+\n+#[lang = \"sync\"]\n+trait Sync {}\n+impl Sync for bool {}\n+\n+#[lang = \"drop_in_place\"]\n+//~^ ERROR: `drop_in_place` language item must be applied to a function with at least 1 generic argument\n+fn drop_fn() {\n+    while false {}\n+}\n+\n+#[lang = \"start\"]\n+//~^ ERROR: `start` language item must be applied to a function with 1 generic argument\n+fn start(){}"}, {"sha": "25560cfa0e6c72ce04c833b41bb50508a71a6068", "filename": "src/test/ui/lang-items/issue-87573.stderr", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/3b65165ab79f535792fc7c504b3fbadf29d7a877/src%2Ftest%2Fui%2Flang-items%2Fissue-87573.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3b65165ab79f535792fc7c504b3fbadf29d7a877/src%2Ftest%2Fui%2Flang-items%2Fissue-87573.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flang-items%2Fissue-87573.stderr?ref=3b65165ab79f535792fc7c504b3fbadf29d7a877", "patch": "@@ -0,0 +1,21 @@\n+error[E0718]: `drop_in_place` language item must be applied to a function with at least 1 generic argument\n+  --> $DIR/issue-87573.rs:20:1\n+   |\n+LL | #[lang = \"drop_in_place\"]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |\n+LL | fn drop_fn() {\n+   |           - this function has 0 generic arguments\n+\n+error[E0718]: `start` language item must be applied to a function with 1 generic argument\n+  --> $DIR/issue-87573.rs:26:1\n+   |\n+LL | #[lang = \"start\"]\n+   | ^^^^^^^^^^^^^^^^^\n+LL |\n+LL | fn start(){}\n+   |         - this function has 0 generic arguments\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0718`."}]}