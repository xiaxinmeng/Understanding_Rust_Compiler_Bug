{"sha": "b09522a634f5c6c53dd01ad60a37b6503355ce88", "node_id": "C_kwDOAAsO6NoAKGIwOTUyMmE2MzRmNWM2YzUzZGQwMWFkNjBhMzdiNjUwMzM1NWNlODg", "commit": {"author": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2022-04-20T02:22:42Z"}, "committer": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2022-04-20T02:28:26Z"}, "message": "Remove the loop from `Parser::bump()`.\n\nThe loop is there to handle a `NoDelim` open/close token. This commit\nchanges `TokenCursor::inlined_next` so it never returns such a token.\nThis is a performance win because the conditional test in `bump()` is\nremoved.\n\nIf the parser needs changing in the future to handle `NoDelim` tokens,\nthen `inlined_next()` can easily be changed to return them.", "tree": {"sha": "7b793a4141b79ce978966e7903e34aed7f91c29a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7b793a4141b79ce978966e7903e34aed7f91c29a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b09522a634f5c6c53dd01ad60a37b6503355ce88", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b09522a634f5c6c53dd01ad60a37b6503355ce88", "html_url": "https://github.com/rust-lang/rust/commit/b09522a634f5c6c53dd01ad60a37b6503355ce88", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b09522a634f5c6c53dd01ad60a37b6503355ce88/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3cd5e346170437f844d18c17d3f870dc4722c96a", "url": "https://api.github.com/repos/rust-lang/rust/commits/3cd5e346170437f844d18c17d3f870dc4722c96a", "html_url": "https://github.com/rust-lang/rust/commit/3cd5e346170437f844d18c17d3f870dc4722c96a"}], "stats": {"total": 63, "additions": 34, "deletions": 29}, "files": [{"sha": "173e0c2d52985673cdd8f7af5060fafe00ce1717", "filename": "compiler/rustc_parse/src/parser/mod.rs", "status": "modified", "additions": 34, "deletions": 29, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/b09522a634f5c6c53dd01ad60a37b6503355ce88/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b09522a634f5c6c53dd01ad60a37b6503355ce88/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs?ref=b09522a634f5c6c53dd01ad60a37b6503355ce88", "patch": "@@ -242,12 +242,17 @@ struct TokenCursorFrame {\n     delim: token::DelimToken,\n     span: DelimSpan,\n     tree_cursor: tokenstream::Cursor,\n-    close_delim: bool,\n+    need_to_produce_close_delim: bool,\n }\n \n impl TokenCursorFrame {\n-    fn new(span: DelimSpan, delim: DelimToken, tts: TokenStream, close_delim: bool) -> Self {\n-        TokenCursorFrame { delim, span, tree_cursor: tts.into_trees(), close_delim }\n+    fn new(span: DelimSpan, delim: DelimToken, tts: TokenStream) -> Self {\n+        TokenCursorFrame {\n+            delim,\n+            span,\n+            tree_cursor: tts.into_trees(),\n+            need_to_produce_close_delim: delim != DelimToken::NoDelim,\n+        }\n     }\n }\n \n@@ -261,28 +266,32 @@ impl TokenCursor {\n     fn inlined_next(&mut self, desugar_doc_comments: bool) -> (Token, Spacing) {\n         loop {\n             if let Some((tree, spacing)) = self.frame.tree_cursor.next_with_spacing() {\n-                return match tree {\n+                match tree {\n                     TokenTree::Token(token) => match (desugar_doc_comments, &token) {\n                         (true, &Token { kind: token::DocComment(_, attr_style, data), span }) => {\n-                            self.desugar(attr_style, data, span)\n+                            return self.desugar(attr_style, data, span);\n                         }\n-                        _ => (token, spacing),\n+                        _ => return (token, spacing),\n                     },\n                     TokenTree::Delimited(sp, delim, tts) => {\n                         // Set `open_delim` to true here because we deal with it immediately.\n-                        let frame = TokenCursorFrame::new(sp, delim, tts, false);\n+                        let frame = TokenCursorFrame::new(sp, delim, tts);\n                         self.stack.push(mem::replace(&mut self.frame, frame));\n-                        (Token::new(token::OpenDelim(delim), sp.open), Spacing::Alone)\n+                        if delim != DelimToken::NoDelim {\n+                            return (Token::new(token::OpenDelim(delim), sp.open), Spacing::Alone);\n+                        }\n+                        // No open delimeter to return; continue on to the next iteration.\n                     }\n                 };\n-            } else if !self.frame.close_delim {\n-                self.frame.close_delim = true;\n+            } else if self.frame.need_to_produce_close_delim {\n+                self.frame.need_to_produce_close_delim = false;\n                 return (\n                     Token::new(token::CloseDelim(self.frame.delim), self.frame.span.close),\n                     Spacing::Alone,\n                 );\n             } else if let Some(frame) = self.stack.pop() {\n                 self.frame = frame;\n+                // Back to the parent frame; continue on to the next iteration.\n             } else {\n                 return (Token::new(token::Eof, DUMMY_SP), Spacing::Alone);\n             }\n@@ -333,7 +342,6 @@ impl TokenCursor {\n                         .cloned()\n                         .collect::<TokenStream>()\n                 },\n-                true,\n             ),\n         ));\n \n@@ -422,7 +430,7 @@ impl<'a> Parser<'a> {\n         desugar_doc_comments: bool,\n         subparser_name: Option<&'static str>,\n     ) -> Self {\n-        let start_frame = TokenCursorFrame::new(DelimSpan::dummy(), token::NoDelim, tokens, true);\n+        let start_frame = TokenCursorFrame::new(DelimSpan::dummy(), token::NoDelim, tokens);\n \n         let mut parser = Parser {\n             sess,\n@@ -993,24 +1001,21 @@ impl<'a> Parser<'a> {\n     /// Advance the parser by one token.\n     pub fn bump(&mut self) {\n         let fallback_span = self.token.span;\n-        loop {\n-            let (mut next, spacing) = self.token_cursor.inlined_next(self.desugar_doc_comments);\n-            self.token_cursor.num_next_calls += 1;\n-            // We've retrieved an token from the underlying\n-            // cursor, so we no longer need to worry about\n-            // an unglued token. See `break_and_eat` for more details\n-            self.token_cursor.break_last_token = false;\n-            if next.span.is_dummy() {\n-                // Tweak the location for better diagnostics, but keep syntactic context intact.\n-                next.span = fallback_span.with_ctxt(next.span.ctxt());\n-            }\n-            if !matches!(\n-                next.kind,\n-                token::OpenDelim(token::NoDelim) | token::CloseDelim(token::NoDelim)\n-            ) {\n-                return self.inlined_bump_with((next, spacing));\n-            }\n+        let (mut next, spacing) = self.token_cursor.inlined_next(self.desugar_doc_comments);\n+        self.token_cursor.num_next_calls += 1;\n+        // We've retrieved an token from the underlying\n+        // cursor, so we no longer need to worry about\n+        // an unglued token. See `break_and_eat` for more details\n+        self.token_cursor.break_last_token = false;\n+        if next.span.is_dummy() {\n+            // Tweak the location for better diagnostics, but keep syntactic context intact.\n+            next.span = fallback_span.with_ctxt(next.span.ctxt());\n         }\n+        debug_assert!(!matches!(\n+            next.kind,\n+            token::OpenDelim(token::NoDelim) | token::CloseDelim(token::NoDelim)\n+        ));\n+        self.inlined_bump_with((next, spacing))\n     }\n \n     /// Look-ahead `dist` tokens of `self.token` and get access to that token there."}]}