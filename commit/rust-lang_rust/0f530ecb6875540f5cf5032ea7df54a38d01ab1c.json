{"sha": "0f530ecb6875540f5cf5032ea7df54a38d01ab1c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBmNTMwZWNiNjg3NTU0MGY1Y2Y1MDMyZWE3ZGY1NGEzOGQwMWFiMWM=", "commit": {"author": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2019-11-24T05:44:28Z"}, "committer": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2019-11-28T20:22:07Z"}, "message": "review comments", "tree": {"sha": "f1e2800ecf67804fd450171830c5309de4a2bc7e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f1e2800ecf67804fd450171830c5309de4a2bc7e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0f530ecb6875540f5cf5032ea7df54a38d01ab1c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0f530ecb6875540f5cf5032ea7df54a38d01ab1c", "html_url": "https://github.com/rust-lang/rust/commit/0f530ecb6875540f5cf5032ea7df54a38d01ab1c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0f530ecb6875540f5cf5032ea7df54a38d01ab1c/comments", "author": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "committer": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9fb446d4726c88490c1dd069fa6982c7e5718643", "url": "https://api.github.com/repos/rust-lang/rust/commits/9fb446d4726c88490c1dd069fa6982c7e5718643", "html_url": "https://github.com/rust-lang/rust/commit/9fb446d4726c88490c1dd069fa6982c7e5718643"}], "stats": {"total": 158, "additions": 81, "deletions": 77}, "files": [{"sha": "66bb3a8d883a4670136cf944604725aaa1557777", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 2, "deletions": 75, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/0f530ecb6875540f5cf5032ea7df54a38d01ab1c/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f530ecb6875540f5cf5032ea7df54a38d01ab1c/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=0f530ecb6875540f5cf5032ea7df54a38d01ab1c", "patch": "@@ -16,9 +16,9 @@ use crate::ty::AdtKind;\n use crate::ty::query::Providers;\n use crate::util::nodemap::{NodeMap, FxHashSet};\n \n-use errors::{Applicability, DiagnosticBuilder, FatalError};\n+use errors::FatalError;\n use syntax_pos::{Span, DUMMY_SP, MultiSpan};\n-use syntax::source_map::{Spanned, SourceMap};\n+use syntax::source_map::Spanned;\n use syntax::ast::{self, CrateSugar, Ident, Name, NodeId, AsmDialect};\n use syntax::ast::{Attribute, Label, LitKind, StrStyle, FloatTy, IntTy, UintTy};\n pub use syntax::ast::{Mutability, Constness, Unsafety, Movability, CaptureBy};\n@@ -644,79 +644,6 @@ impl Generics {\n             self.params.iter().map(|p| p.span).collect::<Vec<Span>>().into()\n         }\n     }\n-\n-    /// Suggest restricting a type param with a new bound.\n-    pub fn suggest_constraining_type_param(\n-        &self,\n-        err: &mut DiagnosticBuilder<'_>,\n-        param_name: &str,\n-        constraint: &str,\n-        source_map: &SourceMap,\n-        span: Span,\n-    ) -> bool {\n-        let restrict_msg = \"consider further restricting this bound\";\n-        if let Some(param) = self.params.iter().filter(|p| {\n-            p.name.ident().as_str() == param_name\n-        }).next() {\n-            if param_name.starts_with(\"impl \") {\n-                // `impl Trait` in argument:\n-                // `fn foo(x: impl Trait) {}` \u2192 `fn foo(t: impl Trait + Trait2) {}`\n-                err.span_suggestion(\n-                    param.span,\n-                    restrict_msg,\n-                    // `impl CurrentTrait + MissingTrait`\n-                    format!(\"{} + {}\", param_name, constraint),\n-                    Applicability::MachineApplicable,\n-                );\n-            } else if self.where_clause.predicates.is_empty() &&\n-                    param.bounds.is_empty()\n-            {\n-                // If there are no bounds whatsoever, suggest adding a constraint\n-                // to the type parameter:\n-                // `fn foo<T>(t: T) {}` \u2192 `fn foo<T: Trait>(t: T) {}`\n-                err.span_suggestion(\n-                    param.span,\n-                    \"consider restricting this bound\",\n-                    format!(\"{}: {}\", param_name, constraint),\n-                    Applicability::MachineApplicable,\n-                );\n-            } else if !self.where_clause.predicates.is_empty() {\n-                // There is a `where` clause, so suggest expanding it:\n-                // `fn foo<T>(t: T) where T: Debug {}` \u2192\n-                // `fn foo<T>(t: T) where T: Debug, T: Trait {}`\n-                err.span_suggestion(\n-                    self.where_clause.span().unwrap().shrink_to_hi(),\n-                    &format!(\"consider further restricting type parameter `{}`\", param_name),\n-                    format!(\", {}: {}\", param_name, constraint),\n-                    Applicability::MachineApplicable,\n-                );\n-            } else {\n-                // If there is no `where` clause lean towards constraining to the\n-                // type parameter:\n-                // `fn foo<X: Bar, T>(t: T, x: X) {}` \u2192 `fn foo<T: Trait>(t: T) {}`\n-                // `fn foo<T: Bar>(t: T) {}` \u2192 `fn foo<T: Bar + Trait>(t: T) {}`\n-                let sp = param.span.with_hi(span.hi());\n-                let span = source_map.span_through_char(sp, ':');\n-                if sp != param.span && sp != span {\n-                    // Only suggest if we have high certainty that the span\n-                    // covers the colon in `foo<T: Trait>`.\n-                    err.span_suggestion(\n-                        span,\n-                        restrict_msg,\n-                        format!(\"{}: {} + \", param_name, constraint),\n-                        Applicability::MachineApplicable,\n-                    );\n-                } else {\n-                    err.span_label(\n-                        param.span,\n-                        &format!(\"consider adding a `where {}: {}` bound\", param_name, constraint),\n-                    );\n-                }\n-            }\n-            return true;\n-        }\n-        false\n-    }\n }\n \n /// Synthetic type parameters are converted to another form during lowering; this allows"}, {"sha": "6e723cdc999b02a56c64688a5644d9d475d2a6f0", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 76, "deletions": 1, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/0f530ecb6875540f5cf5032ea7df54a38d01ab1c/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f530ecb6875540f5cf5032ea7df54a38d01ab1c/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=0f530ecb6875540f5cf5032ea7df54a38d01ab1c", "patch": "@@ -39,6 +39,7 @@ use syntax::ast;\n use syntax::symbol::{sym, kw};\n use syntax_pos::{DUMMY_SP, Span, ExpnKind, MultiSpan};\n use rustc::hir::def_id::LOCAL_CRATE;\n+use syntax_pos::source_map::SourceMap;\n \n use rustc_error_codes::*;\n \n@@ -1189,7 +1190,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     // Missing generic type parameter bound.\n                     let param_name = self_ty.to_string();\n                     let constraint = trait_ref.to_string();\n-                    if generics.suggest_constraining_type_param(\n+                    if suggest_constraining_type_param(\n+                        generics,\n                         &mut err,\n                         &param_name,\n                         &constraint,\n@@ -2497,3 +2499,76 @@ impl ArgKind {\n         }\n     }\n }\n+\n+/// Suggest restricting a type param with a new bound.\n+pub fn suggest_constraining_type_param(\n+    generics: &hir::Generics,\n+    err: &mut DiagnosticBuilder<'_>,\n+    param_name: &str,\n+    constraint: &str,\n+    source_map: &SourceMap,\n+    span: Span,\n+) -> bool {\n+    let restrict_msg = \"consider further restricting this bound\";\n+    if let Some(param) = generics.params.iter().filter(|p| {\n+        p.name.ident().as_str() == param_name\n+    }).next() {\n+        if param_name.starts_with(\"impl \") {\n+            // `impl Trait` in argument:\n+            // `fn foo(x: impl Trait) {}` \u2192 `fn foo(t: impl Trait + Trait2) {}`\n+            err.span_suggestion(\n+                param.span,\n+                restrict_msg,\n+                // `impl CurrentTrait + MissingTrait`\n+                format!(\"{} + {}\", param_name, constraint),\n+                Applicability::MachineApplicable,\n+            );\n+        } else if generics.where_clause.predicates.is_empty() &&\n+                param.bounds.is_empty()\n+        {\n+            // If there are no bounds whatsoever, suggest adding a constraint\n+            // to the type parameter:\n+            // `fn foo<T>(t: T) {}` \u2192 `fn foo<T: Trait>(t: T) {}`\n+            err.span_suggestion(\n+                param.span,\n+                \"consider restricting this bound\",\n+                format!(\"{}: {}\", param_name, constraint),\n+                Applicability::MachineApplicable,\n+            );\n+        } else if !generics.where_clause.predicates.is_empty() {\n+            // There is a `where` clause, so suggest expanding it:\n+            // `fn foo<T>(t: T) where T: Debug {}` \u2192\n+            // `fn foo<T>(t: T) where T: Debug, T: Trait {}`\n+            err.span_suggestion(\n+                generics.where_clause.span().unwrap().shrink_to_hi(),\n+                &format!(\"consider further restricting type parameter `{}`\", param_name),\n+                format!(\", {}: {}\", param_name, constraint),\n+                Applicability::MachineApplicable,\n+            );\n+        } else {\n+            // If there is no `where` clause lean towards constraining to the\n+            // type parameter:\n+            // `fn foo<X: Bar, T>(t: T, x: X) {}` \u2192 `fn foo<T: Trait>(t: T) {}`\n+            // `fn foo<T: Bar>(t: T) {}` \u2192 `fn foo<T: Bar + Trait>(t: T) {}`\n+            let sp = param.span.with_hi(span.hi());\n+            let span = source_map.span_through_char(sp, ':');\n+            if sp != param.span && sp != span {\n+                // Only suggest if we have high certainty that the span\n+                // covers the colon in `foo<T: Trait>`.\n+                err.span_suggestion(\n+                    span,\n+                    restrict_msg,\n+                    format!(\"{}: {} + \", param_name, constraint),\n+                    Applicability::MachineApplicable,\n+                );\n+            } else {\n+                err.span_label(\n+                    param.span,\n+                    &format!(\"consider adding a `where {}: {}` bound\", param_name, constraint),\n+                );\n+            }\n+        }\n+        return true;\n+    }\n+    false\n+}"}, {"sha": "48f8ad9bbd8d693673ac0cffeea9ef2ef58cb4fd", "filename": "src/librustc_mir/borrow_check/conflict_errors.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0f530ecb6875540f5cf5032ea7df54a38d01ab1c/src%2Flibrustc_mir%2Fborrow_check%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f530ecb6875540f5cf5032ea7df54a38d01ab1c/src%2Flibrustc_mir%2Fborrow_check%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fconflict_errors.rs?ref=0f530ecb6875540f5cf5032ea7df54a38d01ab1c", "patch": "@@ -7,6 +7,7 @@ use rustc::mir::{\n     PlaceRef, ProjectionElem, Rvalue, Statement, StatementKind, TerminatorKind, VarBindingForm,\n };\n use rustc::ty::{self, Ty};\n+use rustc::traits::error_reporting::suggest_constraining_type_param;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_index::vec::Idx;\n use rustc_errors::{Applicability, DiagnosticBuilder};\n@@ -233,7 +234,8 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     let generics = tcx.generics_of(self.mir_def_id);\n                     let param = generics.type_param(&param_ty, tcx);\n                     let generics = tcx.hir().get_generics(self.mir_def_id).unwrap();\n-                    generics.suggest_constraining_type_param(\n+                    suggest_constraining_type_param(\n+                        generics,\n                         &mut err,\n                         &param.name.as_str(),\n                         \"Copy\","}]}