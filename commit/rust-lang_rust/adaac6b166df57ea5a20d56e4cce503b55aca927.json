{"sha": "adaac6b166df57ea5a20d56e4cce503b55aca927", "node_id": "C_kwDOAAsO6NoAKGFkYWFjNmIxNjZkZjU3ZWE1YTIwZDU2ZTRjY2U1MDNiNTVhY2E5Mjc", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-04-26T02:36:42Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-04-26T02:36:42Z"}, "message": "Auto merge of #110634 - saethlin:pointy-decoder, r=cjgillot\n\nRewrite MemDecoder around pointers not a slice\n\nThis is basically https://github.com/rust-lang/rust/pull/109910 but I'm being a lot more aggressive. The pointer-based structure means that it makes a lot more sense to absorb more complexity into `MemDecoder`, most of the diff is just complexity moving from one place to another.\n\nThe primary argument for this structure is that we only incur a single bounds check when doing multi-byte reads from a `MemDecoder`. With the slice-based implementation we need to do those with `data[position..position + len]` , which needs to account for `position + len` wrapping. It would be possible to dodge the first bounds check if we stored a slice that starts at `position`, but that would require updating the pointer and length on every read.\n\nThis PR also embeds the failure path in a separate function, which means that this PR should subsume all the perf wins observed in https://github.com/rust-lang/rust/pull/109867.", "tree": {"sha": "2a058aa7f4bc9cc6cf3586c7dcb24afa19bdbf86", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2a058aa7f4bc9cc6cf3586c7dcb24afa19bdbf86"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/adaac6b166df57ea5a20d56e4cce503b55aca927", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/adaac6b166df57ea5a20d56e4cce503b55aca927", "html_url": "https://github.com/rust-lang/rust/commit/adaac6b166df57ea5a20d56e4cce503b55aca927", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/adaac6b166df57ea5a20d56e4cce503b55aca927/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "84d4f16728ed2e5a90c800d6d84225be3ca7c3c8", "url": "https://api.github.com/repos/rust-lang/rust/commits/84d4f16728ed2e5a90c800d6d84225be3ca7c3c8", "html_url": "https://github.com/rust-lang/rust/commit/84d4f16728ed2e5a90c800d6d84225be3ca7c3c8"}, {"sha": "1f67ba61a985c621cb10ae091aaa5c2b009aa721", "url": "https://api.github.com/repos/rust-lang/rust/commits/1f67ba61a985c621cb10ae091aaa5c2b009aa721", "html_url": "https://github.com/rust-lang/rust/commit/1f67ba61a985c621cb10ae091aaa5c2b009aa721"}], "stats": {"total": 304, "additions": 174, "deletions": 130}, "files": [{"sha": "a310cbb80293a8a92243cfa35568568bf52db9e3", "filename": "compiler/rustc_metadata/src/rmeta/decoder.rs", "status": "modified", "additions": 5, "deletions": 20, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/adaac6b166df57ea5a20d56e4cce503b55aca927/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adaac6b166df57ea5a20d56e4cce503b55aca927/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs?ref=adaac6b166df57ea5a20d56e4cce503b55aca927", "patch": "@@ -373,16 +373,6 @@ impl<'a, 'tcx> TyDecoder for DecodeContext<'a, 'tcx> {\n         self.tcx()\n     }\n \n-    #[inline]\n-    fn peek_byte(&self) -> u8 {\n-        self.opaque.data[self.opaque.position()]\n-    }\n-\n-    #[inline]\n-    fn position(&self) -> usize {\n-        self.opaque.position()\n-    }\n-\n     fn cached_ty_for_shorthand<F>(&mut self, shorthand: usize, or_insert_with: F) -> Ty<'tcx>\n     where\n         F: FnOnce(&mut Self) -> Ty<'tcx>,\n@@ -404,7 +394,7 @@ impl<'a, 'tcx> TyDecoder for DecodeContext<'a, 'tcx> {\n     where\n         F: FnOnce(&mut Self) -> R,\n     {\n-        let new_opaque = MemDecoder::new(self.opaque.data, pos);\n+        let new_opaque = MemDecoder::new(self.opaque.data(), pos);\n         let old_opaque = mem::replace(&mut self.opaque, new_opaque);\n         let old_state = mem::replace(&mut self.lazy_state, LazyState::NoNode);\n         let r = f(self);\n@@ -625,17 +615,12 @@ impl<'a, 'tcx> Decodable<DecodeContext<'a, 'tcx>> for Symbol {\n             SYMBOL_OFFSET => {\n                 // read str offset\n                 let pos = d.read_usize();\n-                let old_pos = d.opaque.position();\n \n                 // move to str offset and read\n-                d.opaque.set_position(pos);\n-                let s = d.read_str();\n-                let sym = Symbol::intern(s);\n-\n-                // restore position\n-                d.opaque.set_position(old_pos);\n-\n-                sym\n+                d.opaque.with_position(pos, |d| {\n+                    let s = d.read_str();\n+                    Symbol::intern(s)\n+                })\n             }\n             SYMBOL_PREINTERNED => {\n                 let symbol_index = d.read_u32();"}, {"sha": "05402a58701f1f462b83ab9e8b2b310d5ccb4d37", "filename": "compiler/rustc_metadata/src/rmeta/def_path_hash_map.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/adaac6b166df57ea5a20d56e4cce503b55aca927/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdef_path_hash_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adaac6b166df57ea5a20d56e4cce503b55aca927/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdef_path_hash_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdef_path_hash_map.rs?ref=adaac6b166df57ea5a20d56e4cce503b55aca927", "patch": "@@ -45,9 +45,6 @@ impl<'a, 'tcx> Encodable<EncodeContext<'a, 'tcx>> for DefPathHashMapRef<'tcx> {\n \n impl<'a, 'tcx> Decodable<DecodeContext<'a, 'tcx>> for DefPathHashMapRef<'static> {\n     fn decode(d: &mut DecodeContext<'a, 'tcx>) -> DefPathHashMapRef<'static> {\n-        // Import TyDecoder so we can access the DecodeContext::position() method\n-        use crate::rustc_middle::ty::codec::TyDecoder;\n-\n         let len = d.read_usize();\n         let pos = d.position();\n         let o = slice_owned(d.blob().clone(), |blob| &blob[pos..pos + len]);"}, {"sha": "3793d85c85a41cd69240e332acb3dd8d27b5a8ec", "filename": "compiler/rustc_middle/src/ty/codec.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/adaac6b166df57ea5a20d56e4cce503b55aca927/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcodec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adaac6b166df57ea5a20d56e4cce503b55aca927/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcodec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcodec.rs?ref=adaac6b166df57ea5a20d56e4cce503b55aca927", "patch": "@@ -530,6 +530,16 @@ macro_rules! implement_ty_decoder {\n                 fn read_raw_bytes(&mut self, len: usize) -> &[u8] {\n                     self.opaque.read_raw_bytes(len)\n                 }\n+\n+                #[inline]\n+                fn position(&self) -> usize {\n+                    self.opaque.position()\n+                }\n+\n+                #[inline]\n+                fn peek_byte(&self) -> u8 {\n+                    self.opaque.peek_byte()\n+                }\n             }\n         }\n     }"}, {"sha": "c0f2d7803d492928530ba6137d4d5691b46b8b65", "filename": "compiler/rustc_query_impl/src/on_disk_cache.rs", "status": "modified", "additions": 12, "deletions": 44, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/adaac6b166df57ea5a20d56e4cce503b55aca927/compiler%2Frustc_query_impl%2Fsrc%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adaac6b166df57ea5a20d56e4cce503b55aca927/compiler%2Frustc_query_impl%2Fsrc%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Fon_disk_cache.rs?ref=adaac6b166df57ea5a20d56e4cce503b55aca927", "patch": "@@ -169,13 +169,12 @@ impl<'sess> rustc_middle::ty::OnDiskCache<'sess> for OnDiskCache<'sess> {\n \n             // Decode the *position* of the footer, which can be found in the\n             // last 8 bytes of the file.\n-            decoder.set_position(data.len() - IntEncodedWithFixedSize::ENCODED_SIZE);\n-            let footer_pos = IntEncodedWithFixedSize::decode(&mut decoder).0 as usize;\n-\n+            let footer_pos = decoder\n+                .with_position(decoder.len() - IntEncodedWithFixedSize::ENCODED_SIZE, |decoder| {\n+                    IntEncodedWithFixedSize::decode(decoder).0 as usize\n+                });\n             // Decode the file footer, which contains all the lookup tables, etc.\n-            decoder.set_position(footer_pos);\n-\n-            decode_tagged(&mut decoder, TAG_FILE_FOOTER)\n+            decoder.with_position(footer_pos, |decoder| decode_tagged(decoder, TAG_FILE_FOOTER))\n         };\n \n         Self {\n@@ -522,29 +521,13 @@ impl<'a, 'tcx> CacheDecoder<'a, 'tcx> {\n     }\n }\n \n-trait DecoderWithPosition: Decoder {\n-    fn position(&self) -> usize;\n-}\n-\n-impl<'a> DecoderWithPosition for MemDecoder<'a> {\n-    fn position(&self) -> usize {\n-        self.position()\n-    }\n-}\n-\n-impl<'a, 'tcx> DecoderWithPosition for CacheDecoder<'a, 'tcx> {\n-    fn position(&self) -> usize {\n-        self.opaque.position()\n-    }\n-}\n-\n // Decodes something that was encoded with `encode_tagged()` and verify that the\n // tag matches and the correct amount of bytes was read.\n fn decode_tagged<D, T, V>(decoder: &mut D, expected_tag: T) -> V\n where\n     T: Decodable<D> + Eq + std::fmt::Debug,\n     V: Decodable<D>,\n-    D: DecoderWithPosition,\n+    D: Decoder,\n {\n     let start_pos = decoder.position();\n \n@@ -568,16 +551,6 @@ impl<'a, 'tcx> TyDecoder for CacheDecoder<'a, 'tcx> {\n         self.tcx\n     }\n \n-    #[inline]\n-    fn position(&self) -> usize {\n-        self.opaque.position()\n-    }\n-\n-    #[inline]\n-    fn peek_byte(&self) -> u8 {\n-        self.opaque.data[self.opaque.position()]\n-    }\n-\n     fn cached_ty_for_shorthand<F>(&mut self, shorthand: usize, or_insert_with: F) -> Ty<'tcx>\n     where\n         F: FnOnce(&mut Self) -> Ty<'tcx>,\n@@ -600,9 +573,9 @@ impl<'a, 'tcx> TyDecoder for CacheDecoder<'a, 'tcx> {\n     where\n         F: FnOnce(&mut Self) -> R,\n     {\n-        debug_assert!(pos < self.opaque.data.len());\n+        debug_assert!(pos < self.opaque.len());\n \n-        let new_opaque = MemDecoder::new(self.opaque.data, pos);\n+        let new_opaque = MemDecoder::new(self.opaque.data(), pos);\n         let old_opaque = mem::replace(&mut self.opaque, new_opaque);\n         let r = f(self);\n         self.opaque = old_opaque;\n@@ -743,17 +716,12 @@ impl<'a, 'tcx> Decodable<CacheDecoder<'a, 'tcx>> for Symbol {\n             SYMBOL_OFFSET => {\n                 // read str offset\n                 let pos = d.read_usize();\n-                let old_pos = d.opaque.position();\n \n                 // move to str offset and read\n-                d.opaque.set_position(pos);\n-                let s = d.read_str();\n-                let sym = Symbol::intern(s);\n-\n-                // restore position\n-                d.opaque.set_position(old_pos);\n-\n-                sym\n+                d.opaque.with_position(pos, |d| {\n+                    let s = d.read_str();\n+                    Symbol::intern(s)\n+                })\n             }\n             SYMBOL_PREINTERNED => {\n                 let symbol_index = d.read_u32();"}, {"sha": "edddfda624242704e707f88297cbd8971e3763e1", "filename": "compiler/rustc_query_system/src/dep_graph/serialized.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/adaac6b166df57ea5a20d56e4cce503b55aca927/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fserialized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adaac6b166df57ea5a20d56e4cce503b55aca927/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fserialized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fserialized.rs?ref=adaac6b166df57ea5a20d56e4cce503b55aca927", "patch": "@@ -94,21 +94,19 @@ impl<'a, K: DepKind + Decodable<MemDecoder<'a>>> Decodable<MemDecoder<'a>>\n {\n     #[instrument(level = \"debug\", skip(d))]\n     fn decode(d: &mut MemDecoder<'a>) -> SerializedDepGraph<K> {\n-        let start_position = d.position();\n-\n         // The last 16 bytes are the node count and edge count.\n         debug!(\"position: {:?}\", d.position());\n-        d.set_position(d.data.len() - 2 * IntEncodedWithFixedSize::ENCODED_SIZE);\n+        let (node_count, edge_count) =\n+            d.with_position(d.len() - 2 * IntEncodedWithFixedSize::ENCODED_SIZE, |d| {\n+                debug!(\"position: {:?}\", d.position());\n+                let node_count = IntEncodedWithFixedSize::decode(d).0 as usize;\n+                let edge_count = IntEncodedWithFixedSize::decode(d).0 as usize;\n+                (node_count, edge_count)\n+            });\n         debug!(\"position: {:?}\", d.position());\n \n-        let node_count = IntEncodedWithFixedSize::decode(d).0 as usize;\n-        let edge_count = IntEncodedWithFixedSize::decode(d).0 as usize;\n         debug!(?node_count, ?edge_count);\n \n-        debug!(\"position: {:?}\", d.position());\n-        d.set_position(start_position);\n-        debug!(\"position: {:?}\", d.position());\n-\n         let mut nodes = IndexVec::with_capacity(node_count);\n         let mut fingerprints = IndexVec::with_capacity(node_count);\n         let mut edge_list_indices = IndexVec::with_capacity(node_count);"}, {"sha": "e568b9e6786f96a1208cec07f28d5cff531a1fde", "filename": "compiler/rustc_serialize/src/leb128.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/adaac6b166df57ea5a20d56e4cce503b55aca927/compiler%2Frustc_serialize%2Fsrc%2Fleb128.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adaac6b166df57ea5a20d56e4cce503b55aca927/compiler%2Frustc_serialize%2Fsrc%2Fleb128.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_serialize%2Fsrc%2Fleb128.rs?ref=adaac6b166df57ea5a20d56e4cce503b55aca927", "patch": "@@ -1,3 +1,6 @@\n+use crate::opaque::MemDecoder;\n+use crate::serialize::Decoder;\n+\n /// Returns the length of the longest LEB128 encoding for `T`, assuming `T` is an integer type\n pub const fn max_leb128_len<T>() -> usize {\n     // The longest LEB128 encoding for an integer uses 7 bits per byte.\n@@ -50,21 +53,19 @@ impl_write_unsigned_leb128!(write_usize_leb128, usize);\n macro_rules! impl_read_unsigned_leb128 {\n     ($fn_name:ident, $int_ty:ty) => {\n         #[inline]\n-        pub fn $fn_name(slice: &[u8], position: &mut usize) -> $int_ty {\n+        pub fn $fn_name(decoder: &mut MemDecoder<'_>) -> $int_ty {\n             // The first iteration of this loop is unpeeled. This is a\n             // performance win because this code is hot and integer values less\n             // than 128 are very common, typically occurring 50-80% or more of\n             // the time, even for u64 and u128.\n-            let byte = slice[*position];\n-            *position += 1;\n+            let byte = decoder.read_u8();\n             if (byte & 0x80) == 0 {\n                 return byte as $int_ty;\n             }\n             let mut result = (byte & 0x7F) as $int_ty;\n             let mut shift = 7;\n             loop {\n-                let byte = slice[*position];\n-                *position += 1;\n+                let byte = decoder.read_u8();\n                 if (byte & 0x80) == 0 {\n                     result |= (byte as $int_ty) << shift;\n                     return result;\n@@ -127,14 +128,13 @@ impl_write_signed_leb128!(write_isize_leb128, isize);\n macro_rules! impl_read_signed_leb128 {\n     ($fn_name:ident, $int_ty:ty) => {\n         #[inline]\n-        pub fn $fn_name(slice: &[u8], position: &mut usize) -> $int_ty {\n+        pub fn $fn_name(decoder: &mut MemDecoder<'_>) -> $int_ty {\n             let mut result = 0;\n             let mut shift = 0;\n             let mut byte;\n \n             loop {\n-                byte = slice[*position];\n-                *position += 1;\n+                byte = decoder.read_u8();\n                 result |= <$int_ty>::from(byte & 0x7F) << shift;\n                 shift += 7;\n "}, {"sha": "ce8503918b4f206d05238442d46766f002ee688b", "filename": "compiler/rustc_serialize/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/adaac6b166df57ea5a20d56e4cce503b55aca927/compiler%2Frustc_serialize%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adaac6b166df57ea5a20d56e4cce503b55aca927/compiler%2Frustc_serialize%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_serialize%2Fsrc%2Flib.rs?ref=adaac6b166df57ea5a20d56e4cce503b55aca927", "patch": "@@ -16,6 +16,7 @@ Core encoding and decoding interfaces.\n #![feature(maybe_uninit_slice)]\n #![feature(new_uninit)]\n #![feature(allocator_api)]\n+#![feature(ptr_sub_ptr)]\n #![cfg_attr(test, feature(test))]\n #![allow(rustc::internal)]\n #![deny(rustc::untranslatable_diagnostic)]"}, {"sha": "b7976ea3b1c63362b9a3cb11838ec67ea8255a75", "filename": "compiler/rustc_serialize/src/opaque.rs", "status": "modified", "additions": 119, "deletions": 36, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/adaac6b166df57ea5a20d56e4cce503b55aca927/compiler%2Frustc_serialize%2Fsrc%2Fopaque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adaac6b166df57ea5a20d56e4cce503b55aca927/compiler%2Frustc_serialize%2Fsrc%2Fopaque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_serialize%2Fsrc%2Fopaque.rs?ref=adaac6b166df57ea5a20d56e4cce503b55aca927", "patch": "@@ -2,7 +2,9 @@ use crate::leb128::{self, largest_max_leb128_len};\n use crate::serialize::{Decodable, Decoder, Encodable, Encoder};\n use std::fs::File;\n use std::io::{self, Write};\n+use std::marker::PhantomData;\n use std::mem::MaybeUninit;\n+use std::ops::Range;\n use std::path::Path;\n use std::ptr;\n \n@@ -510,38 +512,125 @@ impl Encoder for FileEncoder {\n // Decoder\n // -----------------------------------------------------------------------------\n \n+// Conceptually, `MemDecoder` wraps a `&[u8]` with a cursor into it that is always valid.\n+// This is implemented with three pointers, two which represent the original slice and a\n+// third that is our cursor.\n+// It is an invariant of this type that start <= current <= end.\n+// Additionally, the implementation of this type never modifies start and end.\n pub struct MemDecoder<'a> {\n-    pub data: &'a [u8],\n-    position: usize,\n+    start: *const u8,\n+    current: *const u8,\n+    end: *const u8,\n+    _marker: PhantomData<&'a u8>,\n }\n \n impl<'a> MemDecoder<'a> {\n     #[inline]\n     pub fn new(data: &'a [u8], position: usize) -> MemDecoder<'a> {\n-        MemDecoder { data, position }\n+        let Range { start, end } = data.as_ptr_range();\n+        MemDecoder { start, current: data[position..].as_ptr(), end, _marker: PhantomData }\n     }\n \n     #[inline]\n-    pub fn position(&self) -> usize {\n-        self.position\n+    pub fn data(&self) -> &'a [u8] {\n+        // SAFETY: This recovers the original slice, only using members we never modify.\n+        unsafe { std::slice::from_raw_parts(self.start, self.len()) }\n     }\n \n     #[inline]\n-    pub fn set_position(&mut self, pos: usize) {\n-        self.position = pos\n+    pub fn len(&self) -> usize {\n+        // SAFETY: This recovers the length of the original slice, only using members we never modify.\n+        unsafe { self.end.sub_ptr(self.start) }\n+    }\n+\n+    #[inline]\n+    pub fn remaining(&self) -> usize {\n+        // SAFETY: This type guarantees current <= end.\n+        unsafe { self.end.sub_ptr(self.current) }\n+    }\n+\n+    #[cold]\n+    #[inline(never)]\n+    fn decoder_exhausted() -> ! {\n+        panic!(\"MemDecoder exhausted\")\n     }\n \n     #[inline]\n-    pub fn advance(&mut self, bytes: usize) {\n-        self.position += bytes;\n+    fn read_byte(&mut self) -> u8 {\n+        if self.current == self.end {\n+            Self::decoder_exhausted();\n+        }\n+        // SAFETY: This type guarantees current <= end, and we just checked current == end.\n+        unsafe {\n+            let byte = *self.current;\n+            self.current = self.current.add(1);\n+            byte\n+        }\n+    }\n+\n+    #[inline]\n+    fn read_array<const N: usize>(&mut self) -> [u8; N] {\n+        self.read_raw_bytes(N).try_into().unwrap()\n+    }\n+\n+    // The trait method doesn't have a lifetime parameter, and we need a version of this\n+    // that definitely returns a slice based on the underlying storage as opposed to\n+    // the Decoder itself in order to implement read_str efficiently.\n+    #[inline]\n+    fn read_raw_bytes_inherent(&mut self, bytes: usize) -> &'a [u8] {\n+        if bytes > self.remaining() {\n+            Self::decoder_exhausted();\n+        }\n+        // SAFETY: We just checked if this range is in-bounds above.\n+        unsafe {\n+            let slice = std::slice::from_raw_parts(self.current, bytes);\n+            self.current = self.current.add(bytes);\n+            slice\n+        }\n+    }\n+\n+    /// While we could manually expose manipulation of the decoder position,\n+    /// all current users of that method would need to reset the position later,\n+    /// incurring the bounds check of set_position twice.\n+    #[inline]\n+    pub fn with_position<F, T>(&mut self, pos: usize, func: F) -> T\n+    where\n+        F: Fn(&mut MemDecoder<'a>) -> T,\n+    {\n+        struct SetOnDrop<'a, 'guarded> {\n+            decoder: &'guarded mut MemDecoder<'a>,\n+            current: *const u8,\n+        }\n+        impl Drop for SetOnDrop<'_, '_> {\n+            fn drop(&mut self) {\n+                self.decoder.current = self.current;\n+            }\n+        }\n+\n+        if pos >= self.len() {\n+            Self::decoder_exhausted();\n+        }\n+        let previous = self.current;\n+        // SAFETY: We just checked if this add is in-bounds above.\n+        unsafe {\n+            self.current = self.start.add(pos);\n+        }\n+        let guard = SetOnDrop { current: previous, decoder: self };\n+        func(guard.decoder)\n     }\n }\n \n macro_rules! read_leb128 {\n-    ($dec:expr, $fun:ident) => {{ leb128::$fun($dec.data, &mut $dec.position) }};\n+    ($dec:expr, $fun:ident) => {{ leb128::$fun($dec) }};\n }\n \n impl<'a> Decoder for MemDecoder<'a> {\n+    #[inline]\n+    fn position(&self) -> usize {\n+        // SAFETY: This type guarantees start <= current\n+        unsafe { self.current.sub_ptr(self.start) }\n+    }\n+\n     #[inline]\n     fn read_u128(&mut self) -> u128 {\n         read_leb128!(self, read_u128_leb128)\n@@ -559,17 +648,12 @@ impl<'a> Decoder for MemDecoder<'a> {\n \n     #[inline]\n     fn read_u16(&mut self) -> u16 {\n-        let bytes = [self.data[self.position], self.data[self.position + 1]];\n-        let value = u16::from_le_bytes(bytes);\n-        self.position += 2;\n-        value\n+        u16::from_le_bytes(self.read_array())\n     }\n \n     #[inline]\n     fn read_u8(&mut self) -> u8 {\n-        let value = self.data[self.position];\n-        self.position += 1;\n-        value\n+        self.read_byte()\n     }\n \n     #[inline]\n@@ -594,17 +678,12 @@ impl<'a> Decoder for MemDecoder<'a> {\n \n     #[inline]\n     fn read_i16(&mut self) -> i16 {\n-        let bytes = [self.data[self.position], self.data[self.position + 1]];\n-        let value = i16::from_le_bytes(bytes);\n-        self.position += 2;\n-        value\n+        i16::from_le_bytes(self.read_array())\n     }\n \n     #[inline]\n     fn read_i8(&mut self) -> i8 {\n-        let value = self.data[self.position];\n-        self.position += 1;\n-        value as i8\n+        self.read_byte() as i8\n     }\n \n     #[inline]\n@@ -625,22 +704,26 @@ impl<'a> Decoder for MemDecoder<'a> {\n     }\n \n     #[inline]\n-    fn read_str(&mut self) -> &'a str {\n+    fn read_str(&mut self) -> &str {\n         let len = self.read_usize();\n-        let sentinel = self.data[self.position + len];\n-        assert!(sentinel == STR_SENTINEL);\n-        let s = unsafe {\n-            std::str::from_utf8_unchecked(&self.data[self.position..self.position + len])\n-        };\n-        self.position += len + 1;\n-        s\n+        let bytes = self.read_raw_bytes_inherent(len + 1);\n+        assert!(bytes[len] == STR_SENTINEL);\n+        unsafe { std::str::from_utf8_unchecked(&bytes[..len]) }\n     }\n \n     #[inline]\n-    fn read_raw_bytes(&mut self, bytes: usize) -> &'a [u8] {\n-        let start = self.position;\n-        self.position += bytes;\n-        &self.data[start..self.position]\n+    fn read_raw_bytes(&mut self, bytes: usize) -> &[u8] {\n+        self.read_raw_bytes_inherent(bytes)\n+    }\n+\n+    #[inline]\n+    fn peek_byte(&self) -> u8 {\n+        if self.current == self.end {\n+            Self::decoder_exhausted();\n+        }\n+        // SAFETY: This type guarantees current is inbounds or one-past-the-end, which is end.\n+        // Since we just checked current == end, the current pointer must be inbounds.\n+        unsafe { *self.current }\n     }\n }\n "}, {"sha": "a6d9c7b7d4210453488ccfac793e45d6e99d7b9a", "filename": "compiler/rustc_serialize/src/serialize.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/adaac6b166df57ea5a20d56e4cce503b55aca927/compiler%2Frustc_serialize%2Fsrc%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adaac6b166df57ea5a20d56e4cce503b55aca927/compiler%2Frustc_serialize%2Fsrc%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_serialize%2Fsrc%2Fserialize.rs?ref=adaac6b166df57ea5a20d56e4cce503b55aca927", "patch": "@@ -84,6 +84,8 @@ pub trait Decoder {\n     fn read_char(&mut self) -> char;\n     fn read_str(&mut self) -> &str;\n     fn read_raw_bytes(&mut self, len: usize) -> &[u8];\n+    fn peek_byte(&self) -> u8;\n+    fn position(&self) -> usize;\n }\n \n /// Trait for types that can be serialized"}, {"sha": "7872e7784311ac43e456d5da2c5bcd489e55f458", "filename": "compiler/rustc_serialize/tests/leb128.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/adaac6b166df57ea5a20d56e4cce503b55aca927/compiler%2Frustc_serialize%2Ftests%2Fleb128.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adaac6b166df57ea5a20d56e4cce503b55aca927/compiler%2Frustc_serialize%2Ftests%2Fleb128.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_serialize%2Ftests%2Fleb128.rs?ref=adaac6b166df57ea5a20d56e4cce503b55aca927", "patch": "@@ -3,6 +3,7 @@\n \n use rustc_serialize::leb128::*;\n use std::mem::MaybeUninit;\n+use rustc_serialize::Decoder;\n \n macro_rules! impl_test_unsigned_leb128 {\n     ($test_name:ident, $write_fn_name:ident, $read_fn_name:ident, $int_ty:ident) => {\n@@ -28,12 +29,12 @@ macro_rules! impl_test_unsigned_leb128 {\n                 stream.extend($write_fn_name(&mut buf, x));\n             }\n \n-            let mut position = 0;\n+            let mut decoder = rustc_serialize::opaque::MemDecoder::new(&stream, 0);\n             for &expected in &values {\n-                let actual = $read_fn_name(&stream, &mut position);\n+                let actual = $read_fn_name(&mut decoder);\n                 assert_eq!(expected, actual);\n             }\n-            assert_eq!(stream.len(), position);\n+            assert_eq!(stream.len(), decoder.position());\n         }\n     };\n }\n@@ -74,12 +75,12 @@ macro_rules! impl_test_signed_leb128 {\n                 stream.extend($write_fn_name(&mut buf, x));\n             }\n \n-            let mut position = 0;\n+            let mut decoder = rustc_serialize::opaque::MemDecoder::new(&stream, 0);\n             for &expected in &values {\n-                let actual = $read_fn_name(&stream, &mut position);\n+                let actual = $read_fn_name(&mut decoder);\n                 assert_eq!(expected, actual);\n             }\n-            assert_eq!(stream.len(), position);\n+            assert_eq!(stream.len(), decoder.position());\n         }\n     };\n }"}, {"sha": "3b638934629b538f75bd2ecbd1be7d5bfe75931b", "filename": "compiler/rustc_type_ir/src/codec.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/adaac6b166df57ea5a20d56e4cce503b55aca927/compiler%2Frustc_type_ir%2Fsrc%2Fcodec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adaac6b166df57ea5a20d56e4cce503b55aca927/compiler%2Frustc_type_ir%2Fsrc%2Fcodec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_type_ir%2Fsrc%2Fcodec.rs?ref=adaac6b166df57ea5a20d56e4cce503b55aca927", "patch": "@@ -27,10 +27,13 @@ pub trait TyEncoder: Encoder {\n     const CLEAR_CROSS_CRATE: bool;\n \n     fn position(&self) -> usize;\n+\n     fn type_shorthands(&mut self) -> &mut FxHashMap<<Self::I as Interner>::Ty, usize>;\n+\n     fn predicate_shorthands(\n         &mut self,\n     ) -> &mut FxHashMap<<Self::I as Interner>::PredicateKind, usize>;\n+\n     fn encode_alloc_id(&mut self, alloc_id: &<Self::I as Interner>::AllocId);\n }\n \n@@ -40,10 +43,6 @@ pub trait TyDecoder: Decoder {\n \n     fn interner(&self) -> Self::I;\n \n-    fn peek_byte(&self) -> u8;\n-\n-    fn position(&self) -> usize;\n-\n     fn cached_ty_for_shorthand<F>(\n         &mut self,\n         shorthand: usize,"}]}