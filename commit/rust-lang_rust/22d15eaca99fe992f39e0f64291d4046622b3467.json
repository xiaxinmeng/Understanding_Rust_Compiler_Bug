{"sha": "22d15eaca99fe992f39e0f64291d4046622b3467", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIyZDE1ZWFjYTk5ZmU5OTJmMzllMGY2NDI5MWQ0MDQ2NjIyYjM0Njc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-09-18T11:11:51Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-09-18T11:11:51Z"}, "message": "Auto merge of #36555 - jseyfried:issue_36540, r=eddyb\n\nVisit and fold macro invocations in the same order\n\nFixes #36540.\nr? @nrc", "tree": {"sha": "a310dcf930eb6f815d92a101c50a83a8987cdf14", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a310dcf930eb6f815d92a101c50a83a8987cdf14"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/22d15eaca99fe992f39e0f64291d4046622b3467", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/22d15eaca99fe992f39e0f64291d4046622b3467", "html_url": "https://github.com/rust-lang/rust/commit/22d15eaca99fe992f39e0f64291d4046622b3467", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/22d15eaca99fe992f39e0f64291d4046622b3467/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f39039e6e5ab4ff3010e2d133d12e44d1cfcb631", "url": "https://api.github.com/repos/rust-lang/rust/commits/f39039e6e5ab4ff3010e2d133d12e44d1cfcb631", "html_url": "https://github.com/rust-lang/rust/commit/f39039e6e5ab4ff3010e2d133d12e44d1cfcb631"}, {"sha": "c7e4ae0d8d22847259e2e08a851f80e375221707", "url": "https://api.github.com/repos/rust-lang/rust/commits/c7e4ae0d8d22847259e2e08a851f80e375221707", "html_url": "https://github.com/rust-lang/rust/commit/c7e4ae0d8d22847259e2e08a851f80e375221707"}], "stats": {"total": 113, "additions": 55, "deletions": 58}, "files": [{"sha": "36f273e1dbc299f3c6c31773578ee050307f6649", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 31, "deletions": 53, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/22d15eaca99fe992f39e0f64291d4046622b3467/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22d15eaca99fe992f39e0f64291d4046622b3467/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=22d15eaca99fe992f39e0f64291d4046622b3467", "patch": "@@ -478,8 +478,8 @@ pub fn noop_fold_parenthesized_parameter_data<T: Folder>(data: ParenthesizedPara\n pub fn noop_fold_local<T: Folder>(l: P<Local>, fld: &mut T) -> P<Local> {\n     l.map(|Local {id, pat, ty, init, span, attrs}| Local {\n         id: fld.new_id(id),\n-        ty: ty.map(|t| fld.fold_ty(t)),\n         pat: fld.fold_pat(pat),\n+        ty: ty.map(|t| fld.fold_ty(t)),\n         init: init.map(|e| fld.fold_expr(e)),\n         span: fld.new_span(span),\n         attrs: fold_attrs(attrs.into(), fld).into(),\n@@ -860,65 +860,46 @@ pub fn noop_fold_item_kind<T: Folder>(i: ItemKind, folder: &mut T) -> ItemKind {\n             ItemKind::Const(folder.fold_ty(t), folder.fold_expr(e))\n         }\n         ItemKind::Fn(decl, unsafety, constness, abi, generics, body) => {\n-            ItemKind::Fn(\n-                folder.fold_fn_decl(decl),\n-                unsafety,\n-                constness,\n-                abi,\n-                folder.fold_generics(generics),\n-                folder.fold_block(body)\n-            )\n+            let generics = folder.fold_generics(generics);\n+            let decl = folder.fold_fn_decl(decl);\n+            let body = folder.fold_block(body);\n+            ItemKind::Fn(decl, unsafety, constness, abi, generics, body)\n         }\n         ItemKind::Mod(m) => ItemKind::Mod(folder.fold_mod(m)),\n         ItemKind::ForeignMod(nm) => ItemKind::ForeignMod(folder.fold_foreign_mod(nm)),\n         ItemKind::Ty(t, generics) => {\n             ItemKind::Ty(folder.fold_ty(t), folder.fold_generics(generics))\n         }\n         ItemKind::Enum(enum_definition, generics) => {\n-            ItemKind::Enum(\n-                ast::EnumDef {\n-                    variants: enum_definition.variants.move_map(|x| folder.fold_variant(x)),\n-                },\n-                folder.fold_generics(generics))\n+            let generics = folder.fold_generics(generics);\n+            let variants = enum_definition.variants.move_map(|x| folder.fold_variant(x));\n+            ItemKind::Enum(ast::EnumDef { variants: variants }, generics)\n         }\n         ItemKind::Struct(struct_def, generics) => {\n-            let struct_def = folder.fold_variant_data(struct_def);\n-            ItemKind::Struct(struct_def, folder.fold_generics(generics))\n+            let generics = folder.fold_generics(generics);\n+            ItemKind::Struct(folder.fold_variant_data(struct_def), generics)\n         }\n         ItemKind::Union(struct_def, generics) => {\n-            let struct_def = folder.fold_variant_data(struct_def);\n-            ItemKind::Union(struct_def, folder.fold_generics(generics))\n+            let generics = folder.fold_generics(generics);\n+            ItemKind::Union(folder.fold_variant_data(struct_def), generics)\n         }\n         ItemKind::DefaultImpl(unsafety, ref trait_ref) => {\n             ItemKind::DefaultImpl(unsafety, folder.fold_trait_ref((*trait_ref).clone()))\n         }\n-        ItemKind::Impl(unsafety, polarity, generics, ifce, ty, impl_items) => {\n-            let new_impl_items = impl_items.move_flat_map(|item| {\n-                folder.fold_impl_item(item)\n-            });\n-            let ifce = match ifce {\n-                None => None,\n-                Some(ref trait_ref) => {\n-                    Some(folder.fold_trait_ref((*trait_ref).clone()))\n-                }\n-            };\n-            ItemKind::Impl(unsafety,\n-                     polarity,\n-                     folder.fold_generics(generics),\n-                     ifce,\n-                     folder.fold_ty(ty),\n-                     new_impl_items)\n-        }\n-        ItemKind::Trait(unsafety, generics, bounds, items) => {\n-            let bounds = folder.fold_bounds(bounds);\n-            let items = items.move_flat_map(|item| {\n-                folder.fold_trait_item(item)\n-            });\n-            ItemKind::Trait(unsafety,\n-                      folder.fold_generics(generics),\n-                      bounds,\n-                      items)\n-        }\n+        ItemKind::Impl(unsafety, polarity, generics, ifce, ty, impl_items) => ItemKind::Impl(\n+            unsafety,\n+            polarity,\n+            folder.fold_generics(generics),\n+            ifce.map(|trait_ref| folder.fold_trait_ref(trait_ref.clone())),\n+            folder.fold_ty(ty),\n+            impl_items.move_flat_map(|item| folder.fold_impl_item(item)),\n+        ),\n+        ItemKind::Trait(unsafety, generics, bounds, items) => ItemKind::Trait(\n+            unsafety,\n+            folder.fold_generics(generics),\n+            folder.fold_bounds(bounds),\n+            items.move_flat_map(|item| folder.fold_trait_item(item)),\n+        ),\n         ItemKind::Mac(m) => ItemKind::Mac(folder.fold_mac(m)),\n     }\n }\n@@ -954,9 +935,9 @@ pub fn noop_fold_impl_item<T: Folder>(i: ImplItem, folder: &mut T)\n                                       -> SmallVector<ImplItem> {\n     SmallVector::one(ImplItem {\n         id: folder.new_id(i.id),\n+        vis: folder.fold_vis(i.vis),\n         ident: folder.fold_ident(i.ident),\n         attrs: fold_attrs(i.attrs, folder),\n-        vis: folder.fold_vis(i.vis),\n         defaultness: i.defaultness,\n         node: match i.node  {\n             ast::ImplItemKind::Const(ty, expr) => {\n@@ -1031,22 +1012,20 @@ pub fn noop_fold_item<T: Folder>(i: P<Item>, folder: &mut T) -> SmallVector<P<It\n // fold one item into exactly one item\n pub fn noop_fold_item_simple<T: Folder>(Item {id, ident, attrs, node, vis, span}: Item,\n                                         folder: &mut T) -> Item {\n-    let id = folder.new_id(id);\n-    let node = folder.fold_item_kind(node);\n-\n     Item {\n-        id: id,\n+        id: folder.new_id(id),\n+        vis: folder.fold_vis(vis),\n         ident: folder.fold_ident(ident),\n         attrs: fold_attrs(attrs, folder),\n-        node: node,\n-        vis: folder.fold_vis(vis),\n+        node: folder.fold_item_kind(node),\n         span: folder.new_span(span)\n     }\n }\n \n pub fn noop_fold_foreign_item<T: Folder>(ni: ForeignItem, folder: &mut T) -> ForeignItem {\n     ForeignItem {\n         id: folder.new_id(ni.id),\n+        vis: folder.fold_vis(ni.vis),\n         ident: folder.fold_ident(ni.ident),\n         attrs: fold_attrs(ni.attrs, folder),\n         node: match ni.node {\n@@ -1057,7 +1036,6 @@ pub fn noop_fold_foreign_item<T: Folder>(ni: ForeignItem, folder: &mut T) -> For\n                 ForeignItemKind::Static(folder.fold_ty(t), m)\n             }\n         },\n-        vis: folder.fold_vis(ni.vis),\n         span: folder.new_span(ni.span)\n     }\n }"}, {"sha": "57b06c40878fe9dcea3adc3c7486a9a0f4c6a018", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/22d15eaca99fe992f39e0f64291d4046622b3467/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22d15eaca99fe992f39e0f64291d4046622b3467/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=22d15eaca99fe992f39e0f64291d4046622b3467", "patch": "@@ -532,8 +532,8 @@ pub fn walk_fn_kind<V: Visitor>(visitor: &mut V, function_kind: FnKind) {\n pub fn walk_fn<V>(visitor: &mut V, kind: FnKind, declaration: &FnDecl, body: &Block, _span: Span)\n     where V: Visitor,\n {\n-    walk_fn_decl(visitor, declaration);\n     walk_fn_kind(visitor, kind);\n+    walk_fn_decl(visitor, declaration);\n     visitor.visit_block(body)\n }\n \n@@ -652,13 +652,13 @@ pub fn walk_expr<V: Visitor>(visitor: &mut V, expression: &Expr) {\n             walk_list!(visitor, visit_expr, subexpressions);\n         }\n         ExprKind::Call(ref callee_expression, ref arguments) => {\n+            visitor.visit_expr(callee_expression);\n             walk_list!(visitor, visit_expr, arguments);\n-            visitor.visit_expr(callee_expression)\n         }\n         ExprKind::MethodCall(ref ident, ref types, ref arguments) => {\n             visitor.visit_ident(ident.span, ident.node);\n-            walk_list!(visitor, visit_expr, arguments);\n             walk_list!(visitor, visit_ty, types);\n+            walk_list!(visitor, visit_expr, arguments);\n         }\n         ExprKind::Binary(_, ref left_expression, ref right_expression) => {\n             visitor.visit_expr(left_expression);\n@@ -717,12 +717,12 @@ pub fn walk_expr<V: Visitor>(visitor: &mut V, expression: &Expr) {\n         }\n         ExprKind::Block(ref block) => visitor.visit_block(block),\n         ExprKind::Assign(ref left_hand_expression, ref right_hand_expression) => {\n+            visitor.visit_expr(left_hand_expression);\n             visitor.visit_expr(right_hand_expression);\n-            visitor.visit_expr(left_hand_expression)\n         }\n         ExprKind::AssignOp(_, ref left_expression, ref right_expression) => {\n+            visitor.visit_expr(left_expression);\n             visitor.visit_expr(right_expression);\n-            visitor.visit_expr(left_expression)\n         }\n         ExprKind::Field(ref subexpression, ref ident) => {\n             visitor.visit_expr(subexpression);"}, {"sha": "6b0deff3ba4fa394c82706178ff9d3226e3b3580", "filename": "src/test/run-pass/type-macros-simple.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/22d15eaca99fe992f39e0f64291d4046622b3467/src%2Ftest%2Frun-pass%2Ftype-macros-simple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22d15eaca99fe992f39e0f64291d4046622b3467/src%2Ftest%2Frun-pass%2Ftype-macros-simple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftype-macros-simple.rs?ref=22d15eaca99fe992f39e0f64291d4046622b3467", "patch": "@@ -15,3 +15,22 @@ macro_rules! Tuple {\n fn main() {\n     let x: Tuple!(i32, i32) = (1, 2);\n }\n+\n+fn issue_36540() {\n+    let i32 = 0;\n+    macro_rules! m { () => { i32 } }\n+    struct S<T = m!()>(m!(), T) where T: Trait<m!()>;\n+\n+    let x: m!() = m!();\n+    std::cell::Cell::<m!()>::new(m!());\n+    impl<T = m!()> std::ops::Index<m!()> for Trait<(m!(), T)>\n+        where T: Trait<m!()>\n+    {\n+        type Output = m!();\n+        fn index(&self, i: m!()) -> &m!() {\n+            unimplemented!()\n+        }\n+    }\n+}\n+\n+trait Trait<T> {}"}]}