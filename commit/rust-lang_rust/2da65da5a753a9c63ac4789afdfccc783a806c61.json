{"sha": "2da65da5a753a9c63ac4789afdfccc783a806c61", "node_id": "C_kwDOAAsO6NoAKDJkYTY1ZGE1YTc1M2E5YzYzYWM0Nzg5YWZkZmNjYzc4M2E4MDZjNjE", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-04-24T22:24:20Z"}, "committer": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-04-24T22:41:20Z"}, "message": "pull some methods out of report_method_error", "tree": {"sha": "7d272137b23e7e76a182a09a197c399077ad7c3f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7d272137b23e7e76a182a09a197c399077ad7c3f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2da65da5a753a9c63ac4789afdfccc783a806c61", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2da65da5a753a9c63ac4789afdfccc783a806c61", "html_url": "https://github.com/rust-lang/rust/commit/2da65da5a753a9c63ac4789afdfccc783a806c61", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2da65da5a753a9c63ac4789afdfccc783a806c61/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "875cd8930e7bd27eb61d280c58b15e967fddd641", "url": "https://api.github.com/repos/rust-lang/rust/commits/875cd8930e7bd27eb61d280c58b15e967fddd641", "html_url": "https://github.com/rust-lang/rust/commit/875cd8930e7bd27eb61d280c58b15e967fddd641"}], "stats": {"total": 364, "additions": 196, "deletions": 168}, "files": [{"sha": "4329c88e81e259c74cfac8aac17f430490d4c234", "filename": "compiler/rustc_typeck/src/check/method/suggest.rs", "status": "modified", "additions": 196, "deletions": 168, "changes": 364, "blob_url": "https://github.com/rust-lang/rust/blob/2da65da5a753a9c63ac4789afdfccc783a806c61/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2da65da5a753a9c63ac4789afdfccc783a806c61/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs?ref=2da65da5a753a9c63ac4789afdfccc783a806c61", "patch": "@@ -271,118 +271,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         (None, true) => \"variant\",\n                     }\n                 };\n-                // Suggest clamping down the type if the method that is being attempted to\n-                // be used exists at all, and the type is an ambiguous numeric type\n-                // ({integer}/{float}).\n-                let mut candidates = all_traits(self.tcx)\n-                    .into_iter()\n-                    .filter_map(|info| self.associated_value(info.def_id, item_name));\n-                // There are methods that are defined on the primitive types and won't be\n-                // found when exploring `all_traits`, but we also need them to be accurate on\n-                // our suggestions (#47759).\n-                let found_assoc = |ty: Ty<'tcx>| {\n-                    simplify_type(tcx, ty, TreatParams::AsPlaceholders)\n-                        .and_then(|simp| {\n-                            tcx.incoherent_impls(simp)\n-                                .iter()\n-                                .find_map(|&id| self.associated_value(id, item_name))\n-                        })\n-                        .is_some()\n-                };\n-                let found_candidate = candidates.next().is_some()\n-                    || found_assoc(tcx.types.i8)\n-                    || found_assoc(tcx.types.i16)\n-                    || found_assoc(tcx.types.i32)\n-                    || found_assoc(tcx.types.i64)\n-                    || found_assoc(tcx.types.i128)\n-                    || found_assoc(tcx.types.u8)\n-                    || found_assoc(tcx.types.u16)\n-                    || found_assoc(tcx.types.u32)\n-                    || found_assoc(tcx.types.u64)\n-                    || found_assoc(tcx.types.u128)\n-                    || found_assoc(tcx.types.f32)\n-                    || found_assoc(tcx.types.f32);\n-                if let (true, false, SelfSource::MethodCall(expr), true) =\n-                    (actual.is_numeric(), actual.has_concrete_skeleton(), source, found_candidate)\n-                {\n-                    let mut err = struct_span_err!(\n-                        tcx.sess,\n-                        span,\n-                        E0689,\n-                        \"can't call {} `{}` on ambiguous numeric type `{}`\",\n-                        item_kind,\n-                        item_name,\n-                        ty_str\n-                    );\n-                    let concrete_type = if actual.is_integral() { \"i32\" } else { \"f32\" };\n-                    match expr.kind {\n-                        ExprKind::Lit(ref lit) => {\n-                            // numeric literal\n-                            let snippet = tcx\n-                                .sess\n-                                .source_map()\n-                                .span_to_snippet(lit.span)\n-                                .unwrap_or_else(|_| \"<numeric literal>\".to_owned());\n-\n-                            // If this is a floating point literal that ends with '.',\n-                            // get rid of it to stop this from becoming a member access.\n-                            let snippet = snippet.strip_suffix('.').unwrap_or(&snippet);\n \n-                            err.span_suggestion(\n-                                lit.span,\n-                                &format!(\n-                                    \"you must specify a concrete type for this numeric value, \\\n-                                         like `{}`\",\n-                                    concrete_type\n-                                ),\n-                                format!(\"{snippet}_{concrete_type}\"),\n-                                Applicability::MaybeIncorrect,\n-                            );\n-                        }\n-                        ExprKind::Path(QPath::Resolved(_, path)) => {\n-                            // local binding\n-                            if let hir::def::Res::Local(hir_id) = path.res {\n-                                let span = tcx.hir().span(hir_id);\n-                                let snippet = tcx.sess.source_map().span_to_snippet(span);\n-                                let filename = tcx.sess.source_map().span_to_filename(span);\n-\n-                                let parent_node =\n-                                    self.tcx.hir().get(self.tcx.hir().get_parent_node(hir_id));\n-                                let msg = format!(\n-                                    \"you must specify a type for this binding, like `{}`\",\n-                                    concrete_type,\n-                                );\n-\n-                                match (filename, parent_node, snippet) {\n-                                    (\n-                                        FileName::Real(_),\n-                                        Node::Local(hir::Local {\n-                                            source: hir::LocalSource::Normal,\n-                                            ty,\n-                                            ..\n-                                        }),\n-                                        Ok(ref snippet),\n-                                    ) => {\n-                                        err.span_suggestion(\n-                                            // account for `let x: _ = 42;`\n-                                            //                  ^^^^\n-                                            span.to(ty.as_ref().map(|ty| ty.span).unwrap_or(span)),\n-                                            &msg,\n-                                            format!(\"{}: {}\", snippet, concrete_type),\n-                                            Applicability::MaybeIncorrect,\n-                                        );\n-                                    }\n-                                    _ => {\n-                                        err.span_label(span, msg);\n-                                    }\n-                                }\n-                            }\n-                        }\n-                        _ => {}\n-                    }\n-                    err.emit();\n+                if self.suggest_constraining_numerical_ty(\n+                    tcx, actual, source, span, item_kind, item_name, &ty_str,\n+                ) {\n                     return None;\n                 }\n+\n                 span = item_name.span;\n \n                 // Don't show generic arguments when the method can't be found in any implementation (#81576).\n@@ -426,10 +321,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 }\n \n                 if let Mode::MethodCall = mode && let SelfSource::MethodCall(cal) = source {\n-                            self.suggest_await_before_method(\n-                                &mut err, item_name, actual, cal, span,\n-                            );\n-                        }\n+                    self.suggest_await_before_method(\n+                        &mut err, item_name, actual, cal, span,\n+                    );\n+                }\n                 if let Some(span) = tcx.resolutions(()).confused_type_with_std_module.get(&span) {\n                     if let Ok(snippet) = tcx.sess.source_map().span_to_snippet(*span) {\n                         err.span_suggestion(\n@@ -967,7 +862,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     }\n                 }\n \n-                let mut label_span_not_found = || {\n+                let label_span_not_found = |err: &mut DiagnosticBuilder<'_, _>| {\n                     if unsatisfied_predicates.is_empty() {\n                         err.span_label(span, format!(\"{item_kind} not found in `{ty_str}`\"));\n                         let is_string_or_ref_str = match actual.kind() {\n@@ -1053,62 +948,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 // If the method name is the name of a field with a function or closure type,\n                 // give a helping note that it has to be called as `(x.f)(...)`.\n                 if let SelfSource::MethodCall(expr) = source {\n-                    let field_receiver =\n-                        self.autoderef(span, rcvr_ty).find_map(|(ty, _)| match ty.kind() {\n-                            ty::Adt(def, substs) if !def.is_enum() => {\n-                                let variant = &def.non_enum_variant();\n-                                self.tcx.find_field_index(item_name, variant).map(|index| {\n-                                    let field = &variant.fields[index];\n-                                    let field_ty = field.ty(tcx, substs);\n-                                    (field, field_ty)\n-                                })\n-                            }\n-                            _ => None,\n-                        });\n-\n-                    if let Some((field, field_ty)) = field_receiver {\n-                        let scope = self.tcx.parent_module(self.body_id).to_def_id();\n-                        let is_accessible = field.vis.is_accessible_from(scope, self.tcx);\n-\n-                        if is_accessible {\n-                            if self.is_fn_ty(field_ty, span) {\n-                                let expr_span = expr.span.to(item_name.span);\n-                                err.multipart_suggestion(\n-                                    &format!(\n-                                        \"to call the function stored in `{}`, \\\n-                                         surround the field access with parentheses\",\n-                                        item_name,\n-                                    ),\n-                                    vec![\n-                                        (expr_span.shrink_to_lo(), '('.to_string()),\n-                                        (expr_span.shrink_to_hi(), ')'.to_string()),\n-                                    ],\n-                                    Applicability::MachineApplicable,\n-                                );\n-                            } else {\n-                                let call_expr = self\n-                                    .tcx\n-                                    .hir()\n-                                    .expect_expr(self.tcx.hir().get_parent_node(expr.hir_id));\n-\n-                                if let Some(span) = call_expr.span.trim_start(item_name.span) {\n-                                    err.span_suggestion(\n-                                        span,\n-                                        \"remove the arguments\",\n-                                        String::new(),\n-                                        Applicability::MaybeIncorrect,\n-                                    );\n-                                }\n-                            }\n-                        }\n-\n-                        let field_kind = if is_accessible { \"field\" } else { \"private field\" };\n-                        err.span_label(item_name.span, format!(\"{}, not a method\", field_kind));\n-                    } else if lev_candidate.is_none() && !custom_span_label {\n-                        label_span_not_found();\n+                    if !self.suggest_field_call(span, rcvr_ty, expr, item_name, &mut err)\n+                        && lev_candidate.is_none()\n+                        && !custom_span_label\n+                    {\n+                        label_span_not_found(&mut err);\n                     }\n                 } else if !custom_span_label {\n-                    label_span_not_found();\n+                    label_span_not_found(&mut err);\n                 }\n \n                 bound_spans.sort();\n@@ -1255,6 +1102,187 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         None\n     }\n \n+    fn suggest_field_call(\n+        &self,\n+        span: Span,\n+        rcvr_ty: Ty<'tcx>,\n+        expr: &hir::Expr<'_>,\n+        item_name: Ident,\n+        err: &mut DiagnosticBuilder<'tcx, ErrorGuaranteed>,\n+    ) -> bool {\n+        let tcx = self.tcx;\n+        let field_receiver = self.autoderef(span, rcvr_ty).find_map(|(ty, _)| match ty.kind() {\n+            ty::Adt(def, substs) if !def.is_enum() => {\n+                let variant = &def.non_enum_variant();\n+                tcx.find_field_index(item_name, variant).map(|index| {\n+                    let field = &variant.fields[index];\n+                    let field_ty = field.ty(tcx, substs);\n+                    (field, field_ty)\n+                })\n+            }\n+            _ => None,\n+        });\n+        if let Some((field, field_ty)) = field_receiver {\n+            let scope = tcx.parent_module(self.body_id).to_def_id();\n+            let is_accessible = field.vis.is_accessible_from(scope, tcx);\n+\n+            if is_accessible {\n+                if self.is_fn_ty(field_ty, span) {\n+                    let expr_span = expr.span.to(item_name.span);\n+                    err.multipart_suggestion(\n+                        &format!(\n+                            \"to call the function stored in `{}`, \\\n+                                         surround the field access with parentheses\",\n+                            item_name,\n+                        ),\n+                        vec![\n+                            (expr_span.shrink_to_lo(), '('.to_string()),\n+                            (expr_span.shrink_to_hi(), ')'.to_string()),\n+                        ],\n+                        Applicability::MachineApplicable,\n+                    );\n+                } else {\n+                    let call_expr = tcx.hir().expect_expr(tcx.hir().get_parent_node(expr.hir_id));\n+\n+                    if let Some(span) = call_expr.span.trim_start(item_name.span) {\n+                        err.span_suggestion(\n+                            span,\n+                            \"remove the arguments\",\n+                            String::new(),\n+                            Applicability::MaybeIncorrect,\n+                        );\n+                    }\n+                }\n+            }\n+\n+            let field_kind = if is_accessible { \"field\" } else { \"private field\" };\n+            err.span_label(item_name.span, format!(\"{}, not a method\", field_kind));\n+            return true;\n+        }\n+        false\n+    }\n+\n+    fn suggest_constraining_numerical_ty(\n+        &self,\n+        tcx: TyCtxt<'tcx>,\n+        actual: Ty<'tcx>,\n+        source: SelfSource<'_>,\n+        span: Span,\n+        item_kind: &str,\n+        item_name: Ident,\n+        ty_str: &str,\n+    ) -> bool {\n+        let found_candidate = all_traits(self.tcx)\n+            .into_iter()\n+            .any(|info| self.associated_value(info.def_id, item_name).is_some());\n+        let found_assoc = |ty: Ty<'tcx>| {\n+            simplify_type(tcx, ty, TreatParams::AsPlaceholders)\n+                .and_then(|simp| {\n+                    tcx.incoherent_impls(simp)\n+                        .iter()\n+                        .find_map(|&id| self.associated_value(id, item_name))\n+                })\n+                .is_some()\n+        };\n+        let found_candidate = found_candidate\n+            || found_assoc(tcx.types.i8)\n+            || found_assoc(tcx.types.i16)\n+            || found_assoc(tcx.types.i32)\n+            || found_assoc(tcx.types.i64)\n+            || found_assoc(tcx.types.i128)\n+            || found_assoc(tcx.types.u8)\n+            || found_assoc(tcx.types.u16)\n+            || found_assoc(tcx.types.u32)\n+            || found_assoc(tcx.types.u64)\n+            || found_assoc(tcx.types.u128)\n+            || found_assoc(tcx.types.f32)\n+            || found_assoc(tcx.types.f32);\n+        if found_candidate\n+            && actual.is_numeric()\n+            && !actual.has_concrete_skeleton()\n+            && let SelfSource::MethodCall(expr) = source\n+        {\n+            let mut err = struct_span_err!(\n+                tcx.sess,\n+                span,\n+                E0689,\n+                \"can't call {} `{}` on ambiguous numeric type `{}`\",\n+                item_kind,\n+                item_name,\n+                ty_str\n+            );\n+            let concrete_type = if actual.is_integral() { \"i32\" } else { \"f32\" };\n+            match expr.kind {\n+                ExprKind::Lit(ref lit) => {\n+                    // numeric literal\n+                    let snippet = tcx\n+                        .sess\n+                        .source_map()\n+                        .span_to_snippet(lit.span)\n+                        .unwrap_or_else(|_| \"<numeric literal>\".to_owned());\n+\n+                    // If this is a floating point literal that ends with '.',\n+                    // get rid of it to stop this from becoming a member access.\n+                    let snippet = snippet.strip_suffix('.').unwrap_or(&snippet);\n+\n+                    err.span_suggestion(\n+                        lit.span,\n+                        &format!(\n+                            \"you must specify a concrete type for this numeric value, \\\n+                                         like `{}`\",\n+                            concrete_type\n+                        ),\n+                        format!(\"{snippet}_{concrete_type}\"),\n+                        Applicability::MaybeIncorrect,\n+                    );\n+                }\n+                ExprKind::Path(QPath::Resolved(_, path)) => {\n+                    // local binding\n+                    if let hir::def::Res::Local(hir_id) = path.res {\n+                        let span = tcx.hir().span(hir_id);\n+                        let snippet = tcx.sess.source_map().span_to_snippet(span);\n+                        let filename = tcx.sess.source_map().span_to_filename(span);\n+\n+                        let parent_node =\n+                            self.tcx.hir().get(self.tcx.hir().get_parent_node(hir_id));\n+                        let msg = format!(\n+                            \"you must specify a type for this binding, like `{}`\",\n+                            concrete_type,\n+                        );\n+\n+                        match (filename, parent_node, snippet) {\n+                            (\n+                                FileName::Real(_),\n+                                Node::Local(hir::Local {\n+                                    source: hir::LocalSource::Normal,\n+                                    ty,\n+                                    ..\n+                                }),\n+                                Ok(ref snippet),\n+                            ) => {\n+                                err.span_suggestion(\n+                                    // account for `let x: _ = 42;`\n+                                    //                  ^^^^\n+                                    span.to(ty.as_ref().map(|ty| ty.span).unwrap_or(span)),\n+                                    &msg,\n+                                    format!(\"{}: {}\", snippet, concrete_type),\n+                                    Applicability::MaybeIncorrect,\n+                                );\n+                            }\n+                            _ => {\n+                                err.span_label(span, msg);\n+                            }\n+                        }\n+                    }\n+                }\n+                _ => {}\n+            }\n+            err.emit();\n+            return true;\n+        }\n+        false\n+    }\n+\n     crate fn note_unmet_impls_on_type(\n         &self,\n         err: &mut Diagnostic,"}]}