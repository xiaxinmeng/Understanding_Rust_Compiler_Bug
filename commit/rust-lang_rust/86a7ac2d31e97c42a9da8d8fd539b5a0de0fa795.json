{"sha": "86a7ac2d31e97c42a9da8d8fd539b5a0de0fa795", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg2YTdhYzJkMzFlOTdjNDJhOWRhOGQ4ZmQ1MzliNWEwZGUwZmE3OTU=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-10-08T12:44:00Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-10-08T12:44:00Z"}, "message": "Simplify event processing", "tree": {"sha": "17d16374b28e3221cfb793340b32aabe2f4fd1dd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/17d16374b28e3221cfb793340b32aabe2f4fd1dd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/86a7ac2d31e97c42a9da8d8fd539b5a0de0fa795", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/86a7ac2d31e97c42a9da8d8fd539b5a0de0fa795", "html_url": "https://github.com/rust-lang/rust/commit/86a7ac2d31e97c42a9da8d8fd539b5a0de0fa795", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/86a7ac2d31e97c42a9da8d8fd539b5a0de0fa795/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3c12d38a32f5c87e87d9dbced774453216086bab", "url": "https://api.github.com/repos/rust-lang/rust/commits/3c12d38a32f5c87e87d9dbced774453216086bab", "html_url": "https://github.com/rust-lang/rust/commit/3c12d38a32f5c87e87d9dbced774453216086bab"}], "stats": {"total": 220, "additions": 122, "deletions": 98}, "files": [{"sha": "65d85279f5d58c3633d28dd52b36a2491ea31fd4", "filename": "crates/ra_editor/src/scope/fn_scope.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/86a7ac2d31e97c42a9da8d8fd539b5a0de0fa795/crates%2Fra_editor%2Fsrc%2Fscope%2Ffn_scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86a7ac2d31e97c42a9da8d8fd539b5a0de0fa795/crates%2Fra_editor%2Fsrc%2Fscope%2Ffn_scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_editor%2Fsrc%2Fscope%2Ffn_scope.rs?ref=86a7ac2d31e97c42a9da8d8fd539b5a0de0fa795", "patch": "@@ -245,11 +245,13 @@ pub fn resolve_local_name<'a>(name_ref: ast::NameRef, scopes: &'a FnScopes) -> O\n     use std::collections::HashSet;\n \n     let mut shadowed = HashSet::new();\n-    scopes.scope_chain(name_ref.syntax())\n+    let ret = scopes.scope_chain(name_ref.syntax())\n         .flat_map(|scope| scopes.entries(scope).iter())\n         .filter(|entry| shadowed.insert(entry.name()))\n         .filter(|entry| entry.name() == name_ref.text())\n-        .nth(0)\n+        .nth(0);\n+    eprintln!(\"ret = {:?}\", ret);\n+    ret\n }\n \n #[cfg(test)]\n@@ -357,7 +359,6 @@ mod tests {\n         let scopes = FnScopes::new(fn_def);\n \n         let local_name = resolve_local_name(name_ref, &scopes).unwrap().ast().name().unwrap();\n-\n         let expected_name = find_node_at_offset::<ast::Name>(file.syntax(), expected_offset.into()).unwrap();\n         assert_eq!(local_name.syntax().range(), expected_name.syntax().range());\n     }\n@@ -394,4 +395,4 @@ mod tests {\n         }\",\n         46);\n     }\n-}\n\\ No newline at end of file\n+}"}, {"sha": "70346962981a4d183aee5c26235b962690b05661", "filename": "crates/ra_syntax/src/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/86a7ac2d31e97c42a9da8d8fd539b5a0de0fa795/crates%2Fra_syntax%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86a7ac2d31e97c42a9da8d8fd539b5a0de0fa795/crates%2Fra_syntax%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Flib.rs?ref=86a7ac2d31e97c42a9da8d8fd539b5a0de0fa795", "patch": "@@ -74,7 +74,8 @@ impl File {\n     }\n     pub fn parse(text: &str) -> File {\n         let tokens = tokenize(&text);\n-        let (green, errors) = parser_impl::parse_with::<yellow::GreenBuilder>(\n+        let (green, errors) = parser_impl::parse_with(\n+            yellow::GreenBuilder::new(),\n             text, &tokens, grammar::root,\n         );\n         File::new(green, errors)"}, {"sha": "48f37c57c718513343290ca3d30d924a10107d98", "filename": "crates/ra_syntax/src/parser_impl/event.rs", "status": "modified", "additions": 88, "deletions": 60, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/86a7ac2d31e97c42a9da8d8fd539b5a0de0fa795/crates%2Fra_syntax%2Fsrc%2Fparser_impl%2Fevent.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86a7ac2d31e97c42a9da8d8fd539b5a0de0fa795/crates%2Fra_syntax%2Fsrc%2Fparser_impl%2Fevent.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fparser_impl%2Fevent.rs?ref=86a7ac2d31e97c42a9da8d8fd539b5a0de0fa795", "patch": "@@ -9,6 +9,7 @@\n //! this stream to a real tree.\n use std::mem;\n use {\n+    TextUnit, TextRange, SmolStr,\n     lexer::Token,\n     parser_impl::Sink,\n     SyntaxKind::{self, TOMBSTONE},\n@@ -78,77 +79,104 @@ pub(crate) enum Event {\n     },\n }\n \n+pub(super) struct EventProcessor<'a, S: Sink> {\n+    sink: S,\n+    text_pos: TextUnit,\n+    text: &'a str,\n+    token_pos: usize,\n+    tokens: &'a [Token],\n+    events: &'a mut [Event],\n+}\n \n-pub(super) fn process<'a, S: Sink<'a>>(builder: &mut S, tokens: &[Token], mut events: Vec<Event>) {\n-    fn tombstone() -> Event {\n-        Event::Start { kind: TOMBSTONE, forward_parent: None }\n+impl<'a, S: Sink> EventProcessor<'a, S> {\n+    pub(super) fn new(sink: S, text: &'a str, tokens: &'a[Token], events: &'a mut [Event]) -> EventProcessor<'a, S> {\n+        EventProcessor {\n+            sink,\n+            text_pos: 0.into(),\n+            text,\n+            token_pos: 0,\n+            tokens,\n+            events\n+        }\n     }\n-    let eat_ws = |idx: &mut usize, builder: &mut S| {\n-        while let Some(token) = tokens.get(*idx) {\n-            if !token.kind.is_trivia() {\n-                break;\n-            }\n-            builder.leaf(token.kind, token.len);\n-            *idx += 1\n+\n+    pub(super) fn process(mut self) -> S {\n+        fn tombstone() -> Event {\n+            Event::Start { kind: TOMBSTONE, forward_parent: None }\n         }\n-    };\n+        let mut depth = 0;\n+        let mut forward_parents = Vec::new();\n \n-    let events: &mut [Event] = &mut events;\n-    let mut depth = 0;\n-    let mut forward_parents = Vec::new();\n-    let mut next_tok_idx = 0;\n-    for i in 0..events.len() {\n-        match mem::replace(&mut events[i], tombstone()) {\n-            Event::Start {\n-                kind: TOMBSTONE, ..\n-            } => (),\n+        for i in 0..self.events.len() {\n+            match mem::replace(&mut self.events[i], tombstone()) {\n+                Event::Start {\n+                    kind: TOMBSTONE, ..\n+                } => (),\n \n-            Event::Start { kind, forward_parent } => {\n-                forward_parents.push(kind);\n-                let mut idx = i;\n-                let mut fp = forward_parent;\n-                while let Some(fwd) = fp {\n-                    idx += fwd as usize;\n-                    fp = match mem::replace(&mut events[idx], tombstone()) {\n-                        Event::Start {\n-                            kind,\n-                            forward_parent,\n-                        } => {\n-                            forward_parents.push(kind);\n-                            forward_parent\n-                        },\n-                        _ => unreachable!(),\n-                    };\n+                Event::Start { kind, forward_parent } => {\n+                    forward_parents.push(kind);\n+                    let mut idx = i;\n+                    let mut fp = forward_parent;\n+                    while let Some(fwd) = fp {\n+                        idx += fwd as usize;\n+                        fp = match mem::replace(&mut self.events[idx], tombstone()) {\n+                            Event::Start {\n+                                kind,\n+                                forward_parent,\n+                            } => {\n+                                forward_parents.push(kind);\n+                                forward_parent\n+                            },\n+                            _ => unreachable!(),\n+                        };\n+                    }\n+                    for kind in forward_parents.drain(..).rev() {\n+                        if depth > 0 {\n+                            self.eat_ws();\n+                        }\n+                        depth += 1;\n+                        self.sink.start_internal(kind);\n+                    }\n                 }\n-                for kind in forward_parents.drain(..).rev() {\n-                    if depth > 0 {\n-                        eat_ws(&mut next_tok_idx, builder);\n+                Event::Finish => {\n+                    depth -= 1;\n+                    if depth == 0 {\n+                        self.eat_ws();\n                     }\n-                    depth += 1;\n-                    builder.start_internal(kind);\n+\n+                    self.sink.finish_internal();\n                 }\n-            }\n-            Event::Finish => {\n-                depth -= 1;\n-                if depth == 0 {\n-                    eat_ws(&mut next_tok_idx, builder);\n+                Event::Token {\n+                    kind,\n+                    mut n_raw_tokens,\n+                } => {\n+                    self.eat_ws();\n+                    let mut len = 0.into();\n+                    for _ in 0..n_raw_tokens {\n+                        len += self.tokens[self.token_pos].len;\n+                    }\n+                    self.leaf(kind, len, n_raw_tokens as usize);\n                 }\n-\n-                builder.finish_internal();\n+                Event::Error { msg } => self.sink.error(msg, self.text_pos),\n             }\n-            Event::Token {\n-                kind,\n-                mut n_raw_tokens,\n-            } => {\n-                eat_ws(&mut next_tok_idx, builder);\n-                let mut len = 0.into();\n-                for _ in 0..n_raw_tokens {\n-                    len += tokens[next_tok_idx].len;\n-                    next_tok_idx += 1;\n-                }\n-                builder.leaf(kind, len);\n+        }\n+        self.sink\n+    }\n+\n+    fn eat_ws(&mut self) {\n+        while let Some(&token) = self.tokens.get(self.token_pos) {\n+            if !token.kind.is_trivia() {\n+                break;\n             }\n-            Event::Error { msg } => builder.error(msg),\n+            self.leaf(token.kind, token.len, 1);\n         }\n     }\n+\n+    fn leaf(&mut self, kind: SyntaxKind, len: TextUnit, n_tokens: usize) {\n+        let range = TextRange::offset_len(self.text_pos, len);\n+        let text: SmolStr = self.text[range].into();\n+        self.text_pos += len;\n+        self.token_pos += n_tokens;\n+        self.sink.leaf(kind, text);\n+    }\n }"}, {"sha": "8d74cef0ee144781a4ba35fe5f23a6f304c32d8f", "filename": "crates/ra_syntax/src/parser_impl/mod.rs", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/86a7ac2d31e97c42a9da8d8fd539b5a0de0fa795/crates%2Fra_syntax%2Fsrc%2Fparser_impl%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86a7ac2d31e97c42a9da8d8fd539b5a0de0fa795/crates%2Fra_syntax%2Fsrc%2Fparser_impl%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fparser_impl%2Fmod.rs?ref=86a7ac2d31e97c42a9da8d8fd539b5a0de0fa795", "patch": "@@ -4,45 +4,44 @@ mod input;\n use std::cell::Cell;\n \n use {\n+    TextUnit, SmolStr,\n     lexer::Token,\n     parser_api::Parser,\n     parser_impl::{\n-        event::{process, Event},\n+        event::{EventProcessor, Event},\n         input::{InputPosition, ParserInput},\n     },\n-    TextUnit,\n };\n \n use SyntaxKind::{self, EOF, TOMBSTONE};\n \n-pub(crate) trait Sink<'a> {\n+pub(crate) trait Sink {\n     type Tree;\n \n-    fn new(text: &'a str) -> Self;\n-\n-    fn leaf(&mut self, kind: SyntaxKind, len: TextUnit);\n+    fn leaf(&mut self, kind: SyntaxKind, text: SmolStr);\n     fn start_internal(&mut self, kind: SyntaxKind);\n     fn finish_internal(&mut self);\n-    fn error(&mut self, err: String);\n+    fn error(&mut self, message: String, offset: TextUnit);\n     fn finish(self) -> Self::Tree;\n }\n \n /// Parse a sequence of tokens into the representative node tree\n-pub(crate) fn parse_with<'a, S: Sink<'a>>(\n-    text: &'a str,\n+pub(crate) fn parse_with<S: Sink>(\n+    sink: S,\n+    text: &str,\n     tokens: &[Token],\n     parser: fn(&mut Parser),\n ) -> S::Tree {\n-    let events = {\n+    let mut events = {\n         let input = input::ParserInput::new(text, tokens);\n         let parser_impl = ParserImpl::new(&input);\n         let mut parser_api = Parser(parser_impl);\n         parser(&mut parser_api);\n         parser_api.0.into_events()\n     };\n-    let mut sink = S::new(text);\n-    process(&mut sink, tokens, events);\n-    sink.finish()\n+    EventProcessor::new(sink, text, tokens, &mut events)\n+        .process()\n+        .finish()\n }\n \n /// Implementation details of `Parser`, extracted"}, {"sha": "d8b6a6a108f0ef7879ed835484c71a3d1de3242d", "filename": "crates/ra_syntax/src/reparsing.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/86a7ac2d31e97c42a9da8d8fd539b5a0de0fa795/crates%2Fra_syntax%2Fsrc%2Freparsing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86a7ac2d31e97c42a9da8d8fd539b5a0de0fa795/crates%2Fra_syntax%2Fsrc%2Freparsing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Freparsing.rs?ref=86a7ac2d31e97c42a9da8d8fd539b5a0de0fa795", "patch": "@@ -84,7 +84,8 @@ fn reparse_block<'node>(\n         return None;\n     }\n     let (green, new_errors) =\n-        parser_impl::parse_with::<yellow::GreenBuilder>(\n+        parser_impl::parse_with(\n+            yellow::GreenBuilder::new(),\n             &text, &tokens, reparser,\n         );\n     Some((node, green, new_errors))"}, {"sha": "c307b2bd00e7ff3f3a75499e4c1ec000a0df6baa", "filename": "crates/ra_syntax/src/yellow/builder.rs", "status": "modified", "additions": 13, "deletions": 19, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/86a7ac2d31e97c42a9da8d8fd539b5a0de0fa795/crates%2Fra_syntax%2Fsrc%2Fyellow%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86a7ac2d31e97c42a9da8d8fd539b5a0de0fa795/crates%2Fra_syntax%2Fsrc%2Fyellow%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fyellow%2Fbuilder.rs?ref=86a7ac2d31e97c42a9da8d8fd539b5a0de0fa795", "patch": "@@ -1,33 +1,29 @@\n use rowan::GreenNodeBuilder;\n use {\n+    TextUnit, SmolStr,\n     parser_impl::Sink,\n     yellow::{GreenNode, SyntaxError, RaTypes},\n-    SyntaxKind, TextRange, TextUnit,\n+    SyntaxKind,\n };\n \n-pub(crate) struct GreenBuilder<'a> {\n-    text: &'a str,\n-    pos: TextUnit,\n+pub(crate) struct GreenBuilder {\n     errors: Vec<SyntaxError>,\n     inner: GreenNodeBuilder<RaTypes>,\n }\n \n-impl<'a> Sink<'a> for GreenBuilder<'a> {\n-    type Tree = (GreenNode, Vec<SyntaxError>);\n-\n-    fn new(text: &'a str) -> Self {\n+impl GreenBuilder {\n+    pub(crate) fn new() -> GreenBuilder {\n         GreenBuilder {\n-            text,\n-            pos: 0.into(),\n             errors: Vec::new(),\n             inner: GreenNodeBuilder::new(),\n         }\n     }\n+}\n+\n+impl Sink for GreenBuilder {\n+    type Tree = (GreenNode, Vec<SyntaxError>);\n \n-    fn leaf(&mut self, kind: SyntaxKind, len: TextUnit) {\n-        let range = TextRange::offset_len(self.pos, len);\n-        self.pos += len;\n-        let text = self.text[range].into();\n+    fn leaf(&mut self, kind: SyntaxKind, text: SmolStr) {\n         self.inner.leaf(kind, text);\n     }\n \n@@ -39,11 +35,9 @@ impl<'a> Sink<'a> for GreenBuilder<'a> {\n         self.inner.finish_internal();\n     }\n \n-    fn error(&mut self, message: String) {\n-        self.errors.push(SyntaxError {\n-            msg: message,\n-            offset: self.pos,\n-        })\n+    fn error(&mut self, message: String, offset: TextUnit) {\n+        let error = SyntaxError { msg: message, offset };\n+        self.errors.push(error)\n     }\n \n     fn finish(self) -> (GreenNode, Vec<SyntaxError>) {"}]}