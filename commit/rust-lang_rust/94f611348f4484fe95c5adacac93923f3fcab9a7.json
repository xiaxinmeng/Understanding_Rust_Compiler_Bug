{"sha": "94f611348f4484fe95c5adacac93923f3fcab9a7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk0ZjYxMTM0OGY0NDg0ZmU5NWM1YWRhY2FjOTM5MjNmM2ZjYWI5YTc=", "commit": {"author": {"name": "David Cook", "email": "divergentdave@gmail.com", "date": "2020-02-16T19:13:16Z"}, "committer": {"name": "David Cook", "email": "divergentdave@gmail.com", "date": "2020-02-23T21:37:22Z"}, "message": "Use os_str_length_as_c_str in readdir[64]_r", "tree": {"sha": "407ebadd4e73ce70ca144a6f3bd35153b2fcff10", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/407ebadd4e73ce70ca144a6f3bd35153b2fcff10"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/94f611348f4484fe95c5adacac93923f3fcab9a7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/94f611348f4484fe95c5adacac93923f3fcab9a7", "html_url": "https://github.com/rust-lang/rust/commit/94f611348f4484fe95c5adacac93923f3fcab9a7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/94f611348f4484fe95c5adacac93923f3fcab9a7/comments", "author": {"login": "divergentdave", "id": 181772, "node_id": "MDQ6VXNlcjE4MTc3Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/181772?v=4", "gravatar_id": "", "url": "https://api.github.com/users/divergentdave", "html_url": "https://github.com/divergentdave", "followers_url": "https://api.github.com/users/divergentdave/followers", "following_url": "https://api.github.com/users/divergentdave/following{/other_user}", "gists_url": "https://api.github.com/users/divergentdave/gists{/gist_id}", "starred_url": "https://api.github.com/users/divergentdave/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/divergentdave/subscriptions", "organizations_url": "https://api.github.com/users/divergentdave/orgs", "repos_url": "https://api.github.com/users/divergentdave/repos", "events_url": "https://api.github.com/users/divergentdave/events{/privacy}", "received_events_url": "https://api.github.com/users/divergentdave/received_events", "type": "User", "site_admin": false}, "committer": {"login": "divergentdave", "id": 181772, "node_id": "MDQ6VXNlcjE4MTc3Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/181772?v=4", "gravatar_id": "", "url": "https://api.github.com/users/divergentdave", "html_url": "https://github.com/divergentdave", "followers_url": "https://api.github.com/users/divergentdave/followers", "following_url": "https://api.github.com/users/divergentdave/following{/other_user}", "gists_url": "https://api.github.com/users/divergentdave/gists{/gist_id}", "starred_url": "https://api.github.com/users/divergentdave/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/divergentdave/subscriptions", "organizations_url": "https://api.github.com/users/divergentdave/orgs", "repos_url": "https://api.github.com/users/divergentdave/repos", "events_url": "https://api.github.com/users/divergentdave/events{/privacy}", "received_events_url": "https://api.github.com/users/divergentdave/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "947fa1fa26ca5ebc19dd8b39ee8289ce54e0c8db", "url": "https://api.github.com/repos/rust-lang/rust/commits/947fa1fa26ca5ebc19dd8b39ee8289ce54e0c8db", "html_url": "https://github.com/rust-lang/rust/commit/947fa1fa26ca5ebc19dd8b39ee8289ce54e0c8db"}], "stats": {"total": 84, "additions": 47, "deletions": 37}, "files": [{"sha": "24adc72fa87b5bfd748ab99740f773aba76b642d", "filename": "src/helpers.rs", "status": "modified", "additions": 26, "deletions": 15, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/94f611348f4484fe95c5adacac93923f3fcab9a7/src%2Fhelpers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94f611348f4484fe95c5adacac93923f3fcab9a7/src%2Fhelpers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fhelpers.rs?ref=94f611348f4484fe95c5adacac93923f3fcab9a7", "patch": "@@ -483,21 +483,6 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         scalar: Scalar<Tag>,\n         size: u64,\n     ) -> InterpResult<'tcx, bool> {\n-        #[cfg(target_os = \"unix\")]\n-        fn os_str_to_bytes<'tcx, 'a>(os_str: &'a OsStr) -> InterpResult<'tcx, &'a [u8]> {\n-            std::os::unix::ffi::OsStringExt::into_bytes(os_str)\n-        }\n-        #[cfg(not(target_os = \"unix\"))]\n-        fn os_str_to_bytes<'tcx, 'a>(os_str: &'a OsStr) -> InterpResult<'tcx, &'a [u8]> {\n-            // On non-unix platforms the best we can do to transform bytes from/to OS strings is to do the\n-            // intermediate transformation into strings. Which invalidates non-utf8 paths that are actually\n-            // valid.\n-            os_str\n-                .to_str()\n-                .map(|s| s.as_bytes())\n-                .ok_or_else(|| err_unsup_format!(\"{:?} is not a valid utf-8 string\", os_str).into())\n-        }\n-\n         let bytes = os_str_to_bytes(os_str)?;\n         // If `size` is smaller or equal than `bytes.len()`, writing `bytes` plus the required null\n         // terminator to memory using the `ptr` pointer would cause an out-of-bounds access.\n@@ -510,6 +495,16 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         Ok(true)\n     }\n \n+    /// Helper function to determine how long an OsStr would be as a C string, not including the\n+    /// null terminator.\n+    fn os_str_length_as_c_str(\n+        &mut self,\n+        os_str: &OsStr,\n+    ) -> InterpResult<'tcx, usize> {\n+        let bytes = os_str_to_bytes(os_str)?;\n+        Ok(bytes.len())\n+    }\n+\n     fn alloc_os_str_as_c_str(\n         &mut self,\n         os_str: &OsStr,\n@@ -525,6 +520,22 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     }\n }\n \n+#[cfg(target_os = \"unix\")]\n+fn os_str_to_bytes<'tcx, 'a>(os_str: &'a OsStr) -> InterpResult<'tcx, &'a [u8]> {\n+    std::os::unix::ffi::OsStringExt::into_bytes(os_str)\n+}\n+\n+#[cfg(not(target_os = \"unix\"))]\n+fn os_str_to_bytes<'tcx, 'a>(os_str: &'a OsStr) -> InterpResult<'tcx, &'a [u8]> {\n+    // On non-unix platforms the best we can do to transform bytes from/to OS strings is to do the\n+    // intermediate transformation into strings. Which invalidates non-utf8 paths that are actually\n+    // valid.\n+    os_str\n+        .to_str()\n+        .map(|s| s.as_bytes())\n+        .ok_or_else(|| err_unsup_format!(\"{:?} is not a valid utf-8 string\", os_str).into())\n+}\n+\n pub fn immty_from_int_checked<'tcx>(\n     int: impl Into<i128>,\n     layout: TyLayout<'tcx>,"}, {"sha": "cee9174696ffab33bdd505777a215d2f1d6dbc35", "filename": "src/shims/fs.rs", "status": "modified", "additions": 21, "deletions": 22, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/94f611348f4484fe95c5adacac93923f3fcab9a7/src%2Fshims%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94f611348f4484fe95c5adacac93923f3fcab9a7/src%2Fshims%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Ffs.rs?ref=94f611348f4484fe95c5adacac93923f3fcab9a7", "patch": "@@ -875,27 +875,26 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             match dir_iter.next() {\n                 Some(Ok(dir_entry)) => {\n                     // write into entry, write pointer to result, return 0 on success\n+\n+                    let name_offset = dirent64_layout.details.fields.offset(4);\n+                    let name_ptr = entry_ptr.offset(name_offset, this)?;\n+\n+                    let name_fits = this.write_os_str_to_c_str(&dir_entry.file_name(), Scalar::Ptr(name_ptr), 256)?;\n+                    if !name_fits {\n+                        panic!(\"A directory entry had a name too large to fit in libc::dirent64\");\n+                    }\n+\n                     let entry_place = this.deref_operand(entry_op)?;\n                     let ino64_t_layout = this.libc_ty_layout(\"ino64_t\")?;\n                     let off64_t_layout = this.libc_ty_layout(\"off64_t\")?;\n                     let c_ushort_layout = this.libc_ty_layout(\"c_ushort\")?;\n                     let c_uchar_layout = this.libc_ty_layout(\"c_uchar\")?;\n \n-                    let name_offset = dirent64_layout.details.fields.offset(4);\n-                    let name_ptr = entry_ptr.offset(name_offset, this)?;\n-\n                     #[cfg(unix)]\n                     let ino = std::os::unix::fs::DirEntryExt::ino(&dir_entry);\n                     #[cfg(not(unix))]\n                     let ino = 0;\n \n-                    #[cfg(unix)]\n-                    let file_name = dir_entry.file_name();\n-                    #[cfg(unix)]\n-                    let file_name = std::os::unix::ffi::OsStrExt::as_bytes(file_name.as_os_str());\n-                    #[cfg(not(unix))]\n-                    let file_name = b\"\";\n-\n                     let file_type = this.file_type_to_d_type(dir_entry.file_type())? as u128;\n \n                     let imms = [\n@@ -905,7 +904,6 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                         immty_from_uint_checked(file_type, c_uchar_layout)?, // d_type\n                     ];\n                     this.write_packed_immediates(entry_place, &imms)?;\n-                    this.memory.write_bytes(Scalar::Ptr(name_ptr), file_name.iter().copied())?;\n \n                     let result_place = this.deref_operand(result_op)?;\n                     this.write_scalar(this.read_scalar(entry_op)?, result_place.into())?;\n@@ -947,38 +945,39 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             match dir_iter.next() {\n                 Some(Ok(dir_entry)) => {\n                     // write into entry, write pointer to result, return 0 on success\n+\n+                    let name_offset = dirent_layout.details.fields.offset(5);\n+                    let name_ptr = entry_ptr.offset(name_offset, this)?;\n+\n+                    let file_name = dir_entry.file_name();\n+                    let name_fits = this.write_os_str_to_c_str(&file_name, Scalar::Ptr(name_ptr), 1024)?;\n+                    if !name_fits {\n+                        panic!(\"A directory entry had a name too large to fit in libc::dirent\");\n+                    }\n+\n                     let entry_place = this.deref_operand(entry_op)?;\n                     let ino_t_layout = this.libc_ty_layout(\"ino_t\")?;\n                     let off_t_layout = this.libc_ty_layout(\"off_t\")?;\n                     let c_ushort_layout = this.libc_ty_layout(\"c_ushort\")?;\n                     let c_uchar_layout = this.libc_ty_layout(\"c_uchar\")?;\n \n-                    let name_offset = dirent_layout.details.fields.offset(5);\n-                    let name_ptr = entry_ptr.offset(name_offset, this)?;\n-\n                     #[cfg(unix)]\n                     let ino = std::os::unix::fs::DirEntryExt::ino(&dir_entry);\n                     #[cfg(not(unix))]\n                     let ino = 0;\n \n-                    #[cfg(unix)]\n-                    let file_name = dir_entry.file_name();\n-                    #[cfg(unix)]\n-                    let file_name = std::os::unix::ffi::OsStrExt::as_bytes(file_name.as_os_str());\n-                    #[cfg(not(unix))]\n-                    let file_name = b\"\";\n+                    let file_name_len = this.os_str_length_as_c_str(&file_name)? as u128;\n \n                     let file_type = this.file_type_to_d_type(dir_entry.file_type())? as u128;\n \n                     let imms = [\n                         immty_from_uint_checked(ino, ino_t_layout)?, // d_ino\n                         immty_from_uint_checked(0u128, off_t_layout)?, // d_seekoff\n                         immty_from_uint_checked(0u128, c_ushort_layout)?, // d_reclen\n-                        immty_from_uint_checked(file_name.len() as u128, c_ushort_layout)?, // d_namlen\n+                        immty_from_uint_checked(file_name_len, c_ushort_layout)?, // d_namlen\n                         immty_from_uint_checked(file_type, c_uchar_layout)?, // d_type\n                     ];\n                     this.write_packed_immediates(entry_place, &imms)?;\n-                    this.memory.write_bytes(Scalar::Ptr(name_ptr), file_name.iter().copied())?;\n \n                     let result_place = this.deref_operand(result_op)?;\n                     this.write_scalar(this.read_scalar(entry_op)?, result_place.into())?;"}]}