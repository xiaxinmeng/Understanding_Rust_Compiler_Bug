{"sha": "a82fe9ae0c770d540e9028596035d72b42c8d0e7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE4MmZlOWFlMGM3NzBkNTQwZTkwMjg1OTYwMzVkNzJiNDJjOGQwZTc=", "commit": {"author": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2017-06-20T14:26:53Z"}, "committer": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2017-06-20T14:26:53Z"}, "message": "Enable more zst writes and reads", "tree": {"sha": "a13ca3908dd080078e79b1c28a4ba7dd1384855c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a13ca3908dd080078e79b1c28a4ba7dd1384855c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a82fe9ae0c770d540e9028596035d72b42c8d0e7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a82fe9ae0c770d540e9028596035d72b42c8d0e7", "html_url": "https://github.com/rust-lang/rust/commit/a82fe9ae0c770d540e9028596035d72b42c8d0e7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a82fe9ae0c770d540e9028596035d72b42c8d0e7/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ea6f6079ca6958c1b74f8255b55c2d76e9c121d8", "url": "https://api.github.com/repos/rust-lang/rust/commits/ea6f6079ca6958c1b74f8255b55c2d76e9c121d8", "html_url": "https://github.com/rust-lang/rust/commit/ea6f6079ca6958c1b74f8255b55c2d76e9c121d8"}], "stats": {"total": 176, "additions": 161, "deletions": 15}, "files": [{"sha": "ac2d391f4217ec7b683612020891e57d3a226aa3", "filename": "src/memory.rs", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/a82fe9ae0c770d540e9028596035d72b42c8d0e7/src%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a82fe9ae0c770d540e9028596035d72b42c8d0e7/src%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmemory.rs?ref=a82fe9ae0c770d540e9028596035d72b42c8d0e7", "patch": "@@ -603,9 +603,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n     }\n \n     fn get_bytes(&self, ptr: Pointer, size: u64, align: u64) -> EvalResult<'tcx, &[u8]> {\n-        if size == 0 {\n-            return Ok(&[]);\n-        }\n+        assert_ne!(size, 0);\n         if self.relocations(ptr, size)?.count() != 0 {\n             return Err(EvalError::ReadPointerAsBytes);\n         }\n@@ -614,9 +612,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n     }\n \n     fn get_bytes_mut(&mut self, ptr: Pointer, size: u64, align: u64) -> EvalResult<'tcx, &mut [u8]> {\n-        if size == 0 {\n-            return Ok(&mut []);\n-        }\n+        assert_ne!(size, 0);\n         self.clear_relocations(ptr, size)?;\n         self.mark_definedness(PrimVal::Ptr(ptr), size, true)?;\n         self.get_bytes_unchecked_mut(ptr, size, align)\n@@ -716,17 +712,26 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         }\n     }\n \n-    pub fn read_bytes(&self, ptr: Pointer, size: u64) -> EvalResult<'tcx, &[u8]> {\n-        self.get_bytes(ptr, size, 1)\n+    pub fn read_bytes(&self, ptr: PrimVal, size: u64) -> EvalResult<'tcx, &[u8]> {\n+        if size == 0 {\n+            return Ok(&[]);\n+        }\n+        self.get_bytes(ptr.to_ptr()?, size, 1)\n     }\n \n     pub fn write_bytes(&mut self, ptr: Pointer, src: &[u8]) -> EvalResult<'tcx> {\n+        if src.is_empty() {\n+            return Ok(());\n+        }\n         let bytes = self.get_bytes_mut(ptr, src.len() as u64, 1)?;\n         bytes.clone_from_slice(src);\n         Ok(())\n     }\n \n     pub fn write_repeat(&mut self, ptr: Pointer, val: u8, count: u64) -> EvalResult<'tcx> {\n+        if count == 0 {\n+            return Ok(());\n+        }\n         let bytes = self.get_bytes_mut(ptr, count, 1)?;\n         for b in bytes { *b = val; }\n         Ok(())"}, {"sha": "d4e169cbcfb63d2fd3ce56e17887151e56eee85f", "filename": "src/terminator/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a82fe9ae0c770d540e9028596035d72b42c8d0e7/src%2Fterminator%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a82fe9ae0c770d540e9028596035d72b42c8d0e7/src%2Fterminator%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fterminator%2Fmod.rs?ref=a82fe9ae0c770d540e9028596035d72b42c8d0e7", "patch": "@@ -626,8 +626,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             }\n \n             \"memcmp\" => {\n-                let left = args[0].read_ptr(&self.memory)?.to_ptr()?;\n-                let right = args[1].read_ptr(&self.memory)?.to_ptr()?;\n+                let left = args[0].read_ptr(&self.memory)?;\n+                let right = args[1].read_ptr(&self.memory)?;\n                 let n = self.value_to_primval(args[2], usize)?.to_u64()?;\n \n                 let result = {\n@@ -646,24 +646,24 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             }\n \n             \"memrchr\" => {\n-                let ptr = args[0].read_ptr(&self.memory)?.to_ptr()?;\n+                let ptr = args[0].read_ptr(&self.memory)?;\n                 let val = self.value_to_primval(args[1], usize)?.to_u64()? as u8;\n                 let num = self.value_to_primval(args[2], usize)?.to_u64()?;\n                 if let Some(idx) = self.memory.read_bytes(ptr, num)?.iter().rev().position(|&c| c == val) {\n                     let new_ptr = ptr.offset(num - idx as u64 - 1, self.memory.layout)?;\n-                    self.write_primval(dest, PrimVal::Ptr(new_ptr), dest_ty)?;\n+                    self.write_primval(dest, new_ptr, dest_ty)?;\n                 } else {\n                     self.write_primval(dest, PrimVal::Bytes(0), dest_ty)?;\n                 }\n             }\n \n             \"memchr\" => {\n-                let ptr = args[0].read_ptr(&self.memory)?.to_ptr()?;\n+                let ptr = args[0].read_ptr(&self.memory)?;\n                 let val = self.value_to_primval(args[1], usize)?.to_u64()? as u8;\n                 let num = self.value_to_primval(args[2], usize)?.to_u64()?;\n                 if let Some(idx) = self.memory.read_bytes(ptr, num)?.iter().position(|&c| c == val) {\n                     let new_ptr = ptr.offset(idx as u64, self.memory.layout)?;\n-                    self.write_primval(dest, PrimVal::Ptr(new_ptr), dest_ty)?;\n+                    self.write_primval(dest, new_ptr, dest_ty)?;\n                 } else {\n                     self.write_primval(dest, PrimVal::Bytes(0), dest_ty)?;\n                 }\n@@ -680,7 +680,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n             \"write\" => {\n                 let fd = self.value_to_primval(args[0], usize)?.to_u64()?;\n-                let buf = args[1].read_ptr(&self.memory)?.to_ptr()?;\n+                let buf = args[1].read_ptr(&self.memory)?;\n                 let n = self.value_to_primval(args[2], usize)?.to_u64()?;\n                 trace!(\"Called write({:?}, {:?}, {:?})\", fd, buf, n);\n                 let result = if fd == 1 || fd == 2 { // stdout/stderr"}, {"sha": "8631909a2a96612f234205c6ee7026b6d79f4893", "filename": "tests/run-pass/loop-break-value.rs", "status": "added", "additions": 141, "deletions": 0, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/a82fe9ae0c770d540e9028596035d72b42c8d0e7/tests%2Frun-pass%2Floop-break-value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a82fe9ae0c770d540e9028596035d72b42c8d0e7/tests%2Frun-pass%2Floop-break-value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Floop-break-value.rs?ref=a82fe9ae0c770d540e9028596035d72b42c8d0e7", "patch": "@@ -0,0 +1,141 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(never_type)]\n+#![allow(unreachable_code)]\n+\n+#[allow(unused)]\n+fn never_returns() {\n+    loop {\n+        break loop {};\n+    }\n+}\n+\n+pub fn main() {\n+    let value = 'outer: loop {\n+        if 1 == 1 {\n+            break 13;\n+        } else {\n+            let _never: ! = loop {\n+                break loop {\n+                    break 'outer panic!();\n+                }\n+            };\n+        }\n+    };\n+    assert_eq!(value, 13);\n+\n+    let x = [1, 3u32, 5];\n+    let y = [17];\n+    let z = [];\n+    let coerced: &[_] = loop {\n+        match 2 {\n+            1 => break &x,\n+            2 => break &y,\n+            3 => break &z,\n+            _ => (),\n+        }\n+    };\n+    assert_eq!(coerced, &[17u32]);\n+\n+    let trait_unified = loop {\n+        break if true {\n+            break Default::default()\n+        } else {\n+            break [13, 14]\n+        };\n+    };\n+    assert_eq!(trait_unified, [0, 0]);\n+\n+    let trait_unified_2 = loop {\n+        if false {\n+            break [String::from(\"Hello\")]\n+        } else {\n+            break Default::default()\n+        };\n+    };\n+    assert_eq!(trait_unified_2, [\"\"]);\n+\n+    let trait_unified_3 = loop {\n+        break if false {\n+            break [String::from(\"Hello\")]\n+        } else {\n+            [\"Yes\".into()]\n+        };\n+    };\n+    assert_eq!(trait_unified_3, [\"Yes\"]);\n+\n+    let regular_break = loop {\n+        if true {\n+            break;\n+        } else {\n+            break break Default::default();\n+        }\n+    };\n+    assert_eq!(regular_break, ());\n+\n+    let regular_break_2 = loop {\n+        if true {\n+            break Default::default();\n+        } else {\n+            break;\n+        }\n+    };\n+    assert_eq!(regular_break_2, ());\n+\n+    let regular_break_3 = loop {\n+        break if true {\n+            Default::default()\n+        } else {\n+            break;\n+        }\n+    };\n+    assert_eq!(regular_break_3, ());\n+\n+    let regular_break_4 = loop {\n+        break ();\n+        break;\n+    };\n+    assert_eq!(regular_break_4, ());\n+\n+    let regular_break_5 = loop {\n+        break;\n+        break ();\n+    };\n+    assert_eq!(regular_break_5, ());\n+\n+    let nested_break_value = 'outer2: loop {\n+        let _a: u32 = 'inner: loop {\n+            if true {\n+                break 'outer2 \"hello\";\n+            } else {\n+                break 'inner 17;\n+            }\n+        };\n+        panic!();\n+    };\n+    assert_eq!(nested_break_value, \"hello\");\n+\n+    let break_from_while_cond = loop {\n+        'inner_loop: while break 'inner_loop {\n+            panic!();\n+        }\n+        break 123;\n+    };\n+    assert_eq!(break_from_while_cond, 123);\n+\n+    let break_from_while_to_outer = 'outer_loop: loop {\n+        while break 'outer_loop 567 {\n+            panic!(\"from_inner\");\n+        }\n+        panic!(\"from outer\");\n+    };\n+    assert_eq!(break_from_while_to_outer, 567);\n+}"}]}