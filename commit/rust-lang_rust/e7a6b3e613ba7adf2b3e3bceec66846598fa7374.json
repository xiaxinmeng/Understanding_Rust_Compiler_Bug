{"sha": "e7a6b3e613ba7adf2b3e3bceec66846598fa7374", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU3YTZiM2U2MTNiYTdhZGYyYjNlM2JjZWVjNjY4NDY1OThmYTczNzQ=", "commit": {"author": {"name": "NiekGr", "email": "git@niek.gr", "date": "2018-05-05T13:01:51Z"}, "committer": {"name": "NiekGr", "email": "git@niek.gr", "date": "2018-05-06T21:54:05Z"}, "message": "Update len_zero to handle comparisions with one\n\nI have added test cases for comparisons with zero and one.\nWhile implementing handling of one, incorrect handlings of zero\nwere also fixed.\n\nfixes rust-lang-nursery/rust-clippy/#2554", "tree": {"sha": "b5879c1b726536a6695c365eac4d8c1022e18f30", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b5879c1b726536a6695c365eac4d8c1022e18f30"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e7a6b3e613ba7adf2b3e3bceec66846598fa7374", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e7a6b3e613ba7adf2b3e3bceec66846598fa7374", "html_url": "https://github.com/rust-lang/rust/commit/e7a6b3e613ba7adf2b3e3bceec66846598fa7374", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e7a6b3e613ba7adf2b3e3bceec66846598fa7374/comments", "author": null, "committer": null, "parents": [{"sha": "e6735dd3279684c9702851ad9f2e1cc2d7a53a87", "url": "https://api.github.com/repos/rust-lang/rust/commits/e6735dd3279684c9702851ad9f2e1cc2d7a53a87", "html_url": "https://github.com/rust-lang/rust/commit/e6735dd3279684c9702851ad9f2e1cc2d7a53a87"}], "stats": {"total": 216, "additions": 158, "deletions": 58}, "files": [{"sha": "09b3da1e99c2d2e5683f62ccee024bde2dee27f5", "filename": "clippy_lints/src/len_zero.rs", "status": "modified", "additions": 42, "deletions": 21, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/e7a6b3e613ba7adf2b3e3bceec66846598fa7374/clippy_lints%2Fsrc%2Flen_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7a6b3e613ba7adf2b3e3bceec66846598fa7374/clippy_lints%2Fsrc%2Flen_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flen_zero.rs?ref=e7a6b3e613ba7adf2b3e3bceec66846598fa7374", "patch": "@@ -1,7 +1,7 @@\n-use rustc::lint::*;\n use rustc::hir::def_id::DefId;\n-use rustc::ty;\n use rustc::hir::*;\n+use rustc::lint::*;\n+use rustc::ty;\n use std::collections::HashSet;\n use syntax::ast::{Lit, LitKind, Name};\n use syntax::codemap::{Span, Spanned};\n@@ -81,8 +81,24 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for LenZero {\n \n         if let ExprBinary(Spanned { node: cmp, .. }, ref left, ref right) = expr.node {\n             match cmp {\n-                BiEq => check_cmp(cx, expr.span, left, right, \"\"),\n-                BiGt | BiNe => check_cmp(cx, expr.span, left, right, \"!\"),\n+                BiEq => {\n+                    check_cmp(cx, expr.span, left, right, \"\", 0); // len == 0\n+                    check_cmp(cx, expr.span, right, left, \"\", 0); // 0 == len\n+                },\n+                BiNe => {\n+                    check_cmp(cx, expr.span, left, right, \"!\", 0); // len != 0\n+                    check_cmp(cx, expr.span, right, left, \"!\", 0); // 0 != len\n+                },\n+                BiGt => {\n+                    check_cmp(cx, expr.span, left, right, \"!\", 0); // len > 0\n+                    check_cmp(cx, expr.span, right, left, \"\", 1); // 1 > len\n+                },\n+                BiLt => {\n+                    check_cmp(cx, expr.span, left, right, \"\", 1); // len < 1\n+                    check_cmp(cx, expr.span, right, left, \"!\", 0); // 0 < len\n+                },\n+                BiGe => check_cmp(cx, expr.span, left, right, \"!\", 1), // len <= 1\n+                BiLe => check_cmp(cx, expr.span, right, left, \"!\", 1), // 1 >= len\n                 _ => (),\n             }\n         }\n@@ -168,40 +184,45 @@ fn check_impl_items(cx: &LateContext, item: &Item, impl_items: &[ImplItemRef]) {\n                 cx,\n                 LEN_WITHOUT_IS_EMPTY,\n                 item.span,\n-                &format!(\"item `{}` has a public `len` method but {} `is_empty` method\", ty, is_empty),\n+                &format!(\n+                    \"item `{}` has a public `len` method but {} `is_empty` method\",\n+                    ty, is_empty\n+                ),\n             );\n         }\n     }\n }\n \n-fn check_cmp(cx: &LateContext, span: Span, left: &Expr, right: &Expr, op: &str) {\n-    // check if we are in an is_empty() method\n-    if let Some(name) = get_item_name(cx, left) {\n-        if name == \"is_empty\" {\n-            return;\n+fn check_cmp(cx: &LateContext, span: Span, method: &Expr, lit: &Expr, op: &str, compare_to: u32) {\n+    if let (&ExprMethodCall(ref method_path, _, ref args), &ExprLit(ref lit)) = (&method.node, &lit.node) {\n+        // check if we are in an is_empty() method\n+        if let Some(name) = get_item_name(cx, method) {\n+            if name == \"is_empty\" {\n+                return;\n+            }\n         }\n-    }\n-    match (&left.node, &right.node) {\n-        (&ExprLit(ref lit), &ExprMethodCall(ref method_path, _, ref args)) |\n-        (&ExprMethodCall(ref method_path, _, ref args), &ExprLit(ref lit)) => {\n-            check_len_zero(cx, span, method_path.name, args, lit, op)\n-        },\n-        _ => (),\n+\n+        check_len(cx, span, method_path.name, args, lit, op, compare_to)\n     }\n }\n \n-fn check_len_zero(cx: &LateContext, span: Span, name: Name, args: &[Expr], lit: &Lit, op: &str) {\n+fn check_len(cx: &LateContext, span: Span, method_name: Name, args: &[Expr], lit: &Lit, op: &str, compare_to: u32) {\n     if let Spanned {\n-        node: LitKind::Int(0, _),\n+        node: LitKind::Int(lit, _),\n         ..\n     } = *lit\n     {\n-        if name == \"len\" && args.len() == 1 && has_is_empty(cx, &args[0]) {\n+        // check if length is compared to the specified number\n+        if lit != u128::from(compare_to) {\n+            return;\n+        }\n+\n+        if method_name == \"len\" && args.len() == 1 && has_is_empty(cx, &args[0]) {\n             span_lint_and_sugg(\n                 cx,\n                 LEN_ZERO,\n                 span,\n-                \"length comparison to zero\",\n+                &format!(\"length comparison to {}\", if compare_to == 0 { \"zero\" } else { \"one\" }),\n                 \"using `is_empty` is more concise\",\n                 format!(\"{}{}.is_empty()\", op, snippet(cx, args[0].span, \"_\")),\n             );"}, {"sha": "2e71c2761fa09343dd99a9dd5c3d8ec1815880fc", "filename": "tests/ui/len_zero.rs", "status": "modified", "additions": 55, "deletions": 18, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/e7a6b3e613ba7adf2b3e3bceec66846598fa7374/tests%2Fui%2Flen_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7a6b3e613ba7adf2b3e3bceec66846598fa7374/tests%2Fui%2Flen_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flen_zero.rs?ref=e7a6b3e613ba7adf2b3e3bceec66846598fa7374", "patch": "@@ -1,6 +1,3 @@\n-\n-\n-\n #![warn(len_without_is_empty, len_zero)]\n #![allow(dead_code, unused)]\n \n@@ -12,7 +9,8 @@ impl PubOne {\n     }\n }\n \n-impl PubOne { // A second impl for this struct - the error span shouldn't mention this\n+impl PubOne {\n+    // A second impl for this struct - the error span shouldn't mention this\n     pub fn irrelevant(self: &Self) -> bool {\n         false\n     }\n@@ -39,15 +37,17 @@ impl PubAllowed {\n struct NotPubOne;\n \n impl NotPubOne {\n-    pub fn len(self: &Self) -> isize { // no error, len is pub but `NotPubOne` is not exported anyway\n+    pub fn len(self: &Self) -> isize {\n+        // no error, len is pub but `NotPubOne` is not exported anyway\n         1\n     }\n }\n \n struct One;\n \n impl One {\n-    fn len(self: &Self) -> isize { // no error, len is private, see #1085\n+    fn len(self: &Self) -> isize {\n+        // no error, len is private, see #1085\n         1\n     }\n }\n@@ -120,7 +120,7 @@ impl HasWrongIsEmpty {\n         1\n     }\n \n-    pub fn is_empty(self: &Self, x : u32) -> bool {\n+    pub fn is_empty(self: &Self, x: u32) -> bool {\n         false\n     }\n }\n@@ -129,28 +129,28 @@ pub trait Empty {\n     fn is_empty(&self) -> bool;\n }\n \n-pub trait InheritingEmpty: Empty { //must not trigger LEN_WITHOUT_IS_EMPTY\n+pub trait InheritingEmpty: Empty {\n+    //must not trigger LEN_WITHOUT_IS_EMPTY\n     fn len(&self) -> isize;\n }\n \n-\n-\n fn main() {\n     let x = [1, 2];\n     if x.len() == 0 {\n         println!(\"This should not happen!\");\n     }\n \n-    if \"\".len() == 0 {\n-    }\n+    if \"\".len() == 0 {}\n \n     let y = One;\n-    if y.len()  == 0 { //no error because One does not have .is_empty()\n+    if y.len() == 0 {\n+        //no error because One does not have .is_empty()\n         println!(\"This should not happen either!\");\n     }\n \n-    let z : &TraitsToo = &y;\n-    if z.len() > 0 { //no error, because TraitsToo has no .is_empty() method\n+    let z: &TraitsToo = &y;\n+    if z.len() > 0 {\n+        //no error, because TraitsToo has no .is_empty() method\n         println!(\"Nor should this!\");\n     }\n \n@@ -164,6 +164,43 @@ fn main() {\n     if has_is_empty.len() > 0 {\n         println!(\"Or this!\");\n     }\n+    if has_is_empty.len() < 1 {\n+        println!(\"Or this!\");\n+    }\n+    if has_is_empty.len() >= 1 {\n+        println!(\"Or this!\");\n+    }\n+    if has_is_empty.len() > 1 {\n+        // no error\n+        println!(\"This can happen.\");\n+    }\n+    if has_is_empty.len() <= 1 {\n+        // no error\n+        println!(\"This can happen.\");\n+    }\n+    if 0 == has_is_empty.len() {\n+        println!(\"Or this!\");\n+    }\n+    if 0 != has_is_empty.len() {\n+        println!(\"Or this!\");\n+    }\n+    if 0 < has_is_empty.len() {\n+        println!(\"Or this!\");\n+    }\n+    if 1 <= has_is_empty.len() {\n+        println!(\"Or this!\");\n+    }\n+    if 1 > has_is_empty.len() {\n+        println!(\"Or this!\");\n+    }\n+    if 1 < has_is_empty.len() {\n+        // no error\n+        println!(\"This can happen.\");\n+    }\n+    if 1 >= has_is_empty.len() {\n+        // no error\n+        println!(\"This can happen.\");\n+    }\n     assert!(!has_is_empty.is_empty());\n \n     let with_is_empty: &WithIsEmpty = &Wither;\n@@ -173,14 +210,14 @@ fn main() {\n     assert!(!with_is_empty.is_empty());\n \n     let has_wrong_is_empty = HasWrongIsEmpty;\n-    if has_wrong_is_empty.len() == 0 { //no error as HasWrongIsEmpty does not have .is_empty()\n+    if has_wrong_is_empty.len() == 0 {\n+        //no error as HasWrongIsEmpty does not have .is_empty()\n         println!(\"Or this!\");\n     }\n }\n \n fn test_slice(b: &[u8]) {\n-    if b.len() != 0 {\n-    }\n+    if b.len() != 0 {}\n }\n \n // this used to ICE"}, {"sha": "a04185bc63fe160252cf32506e36820e33153d3c", "filename": "tests/ui/len_zero.stderr", "status": "modified", "additions": 61, "deletions": 19, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/e7a6b3e613ba7adf2b3e3bceec66846598fa7374/tests%2Fui%2Flen_zero.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e7a6b3e613ba7adf2b3e3bceec66846598fa7374/tests%2Fui%2Flen_zero.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flen_zero.stderr?ref=e7a6b3e613ba7adf2b3e3bceec66846598fa7374", "patch": "@@ -1,11 +1,11 @@\n error: item `PubOne` has a public `len` method but no corresponding `is_empty` method\n-  --> $DIR/len_zero.rs:9:1\n+  --> $DIR/len_zero.rs:6:1\n    |\n-9  | / impl PubOne {\n-10 | |     pub fn len(self: &Self) -> isize {\n-11 | |         1\n-12 | |     }\n-13 | | }\n+6  | / impl PubOne {\n+7  | |     pub fn len(self: &Self) -> isize {\n+8  | |         1\n+9  | |     }\n+10 | | }\n    | |_^\n    |\n    = note: `-D len-without-is-empty` implied by `-D warnings`\n@@ -43,17 +43,17 @@ error: item `HasWrongIsEmpty` has a public `len` method but no corresponding `is\n     | |_^\n \n error: length comparison to zero\n-   --> $DIR/len_zero.rs:140:8\n+   --> $DIR/len_zero.rs:139:8\n     |\n-140 |     if x.len() == 0 {\n+139 |     if x.len() == 0 {\n     |        ^^^^^^^^^^^^ help: using `is_empty` is more concise: `x.is_empty()`\n     |\n     = note: `-D len-zero` implied by `-D warnings`\n \n error: length comparison to zero\n-   --> $DIR/len_zero.rs:144:8\n+   --> $DIR/len_zero.rs:143:8\n     |\n-144 |     if \"\".len() == 0 {\n+143 |     if \"\".len() == 0 {}\n     |        ^^^^^^^^^^^^^ help: using `is_empty` is more concise: `\"\".is_empty()`\n \n error: length comparison to zero\n@@ -74,25 +74,67 @@ error: length comparison to zero\n 164 |     if has_is_empty.len() > 0 {\n     |        ^^^^^^^^^^^^^^^^^^^^^^ help: using `is_empty` is more concise: `!has_is_empty.is_empty()`\n \n-error: length comparison to zero\n+error: length comparison to one\n+   --> $DIR/len_zero.rs:167:8\n+    |\n+167 |     if has_is_empty.len() < 1 {\n+    |        ^^^^^^^^^^^^^^^^^^^^^^ help: using `is_empty` is more concise: `has_is_empty.is_empty()`\n+\n+error: length comparison to one\n    --> $DIR/len_zero.rs:170:8\n     |\n-170 |     if with_is_empty.len() == 0 {\n+170 |     if has_is_empty.len() >= 1 {\n+    |        ^^^^^^^^^^^^^^^^^^^^^^^ help: using `is_empty` is more concise: `!has_is_empty.is_empty()`\n+\n+error: length comparison to zero\n+   --> $DIR/len_zero.rs:181:8\n+    |\n+181 |     if 0 == has_is_empty.len() {\n+    |        ^^^^^^^^^^^^^^^^^^^^^^^ help: using `is_empty` is more concise: `has_is_empty.is_empty()`\n+\n+error: length comparison to zero\n+   --> $DIR/len_zero.rs:184:8\n+    |\n+184 |     if 0 != has_is_empty.len() {\n+    |        ^^^^^^^^^^^^^^^^^^^^^^^ help: using `is_empty` is more concise: `!has_is_empty.is_empty()`\n+\n+error: length comparison to zero\n+   --> $DIR/len_zero.rs:187:8\n+    |\n+187 |     if 0 < has_is_empty.len() {\n+    |        ^^^^^^^^^^^^^^^^^^^^^^ help: using `is_empty` is more concise: `!has_is_empty.is_empty()`\n+\n+error: length comparison to one\n+   --> $DIR/len_zero.rs:190:8\n+    |\n+190 |     if 1 <= has_is_empty.len() {\n+    |        ^^^^^^^^^^^^^^^^^^^^^^^ help: using `is_empty` is more concise: `!has_is_empty.is_empty()`\n+\n+error: length comparison to one\n+   --> $DIR/len_zero.rs:193:8\n+    |\n+193 |     if 1 > has_is_empty.len() {\n+    |        ^^^^^^^^^^^^^^^^^^^^^^ help: using `is_empty` is more concise: `has_is_empty.is_empty()`\n+\n+error: length comparison to zero\n+   --> $DIR/len_zero.rs:207:8\n+    |\n+207 |     if with_is_empty.len() == 0 {\n     |        ^^^^^^^^^^^^^^^^^^^^^^^^ help: using `is_empty` is more concise: `with_is_empty.is_empty()`\n \n error: length comparison to zero\n-   --> $DIR/len_zero.rs:182:8\n+   --> $DIR/len_zero.rs:220:8\n     |\n-182 |     if b.len() != 0 {\n+220 |     if b.len() != 0 {}\n     |        ^^^^^^^^^^^^ help: using `is_empty` is more concise: `!b.is_empty()`\n \n error: trait `DependsOnFoo` has a `len` method but no (possibly inherited) `is_empty` method\n-   --> $DIR/len_zero.rs:189:1\n+   --> $DIR/len_zero.rs:226:1\n     |\n-189 | / pub trait DependsOnFoo: Foo {\n-190 | |     fn len(&mut self) -> usize;\n-191 | | }\n+226 | / pub trait DependsOnFoo: Foo {\n+227 | |     fn len(&mut self) -> usize;\n+228 | | }\n     | |_^\n \n-error: aborting due to 12 previous errors\n+error: aborting due to 19 previous errors\n "}]}