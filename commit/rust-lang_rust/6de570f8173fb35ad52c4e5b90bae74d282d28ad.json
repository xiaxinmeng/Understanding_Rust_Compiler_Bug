{"sha": "6de570f8173fb35ad52c4e5b90bae74d282d28ad", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZkZTU3MGY4MTczZmIzNWFkNTJjNGU1YjkwYmFlNzRkMjgyZDI4YWQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-08-21T09:55:54Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-08-21T09:55:54Z"}, "message": "auto merge of #16487 : steveklabnik/rust/guide_ownership, r=brson\n\nWhew. This section was so important, I saved it for last.\r\n\r\n/cc @wycats, @nikomatsakis", "tree": {"sha": "1df1aef288c197e29f52665a686844c9840d7c58", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1df1aef288c197e29f52665a686844c9840d7c58"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6de570f8173fb35ad52c4e5b90bae74d282d28ad", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6de570f8173fb35ad52c4e5b90bae74d282d28ad", "html_url": "https://github.com/rust-lang/rust/commit/6de570f8173fb35ad52c4e5b90bae74d282d28ad", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6de570f8173fb35ad52c4e5b90bae74d282d28ad/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5305f9b89419b2b31e00fc69bf9cc90469cbbc41", "url": "https://api.github.com/repos/rust-lang/rust/commits/5305f9b89419b2b31e00fc69bf9cc90469cbbc41", "html_url": "https://github.com/rust-lang/rust/commit/5305f9b89419b2b31e00fc69bf9cc90469cbbc41"}, {"sha": "c47dfbb16a155053d114e005d702cf76c84d45eb", "url": "https://api.github.com/repos/rust-lang/rust/commits/c47dfbb16a155053d114e005d702cf76c84d45eb", "html_url": "https://github.com/rust-lang/rust/commit/c47dfbb16a155053d114e005d702cf76c84d45eb"}], "stats": {"total": 167, "additions": 167, "deletions": 0}, "files": [{"sha": "c4c1fce23c5bb6409c1b805645e52a87199146da", "filename": "src/doc/guide.md", "status": "modified", "additions": 167, "deletions": 0, "changes": 167, "blob_url": "https://github.com/rust-lang/rust/blob/6de570f8173fb35ad52c4e5b90bae74d282d28ad/src%2Fdoc%2Fguide.md", "raw_url": "https://github.com/rust-lang/rust/raw/6de570f8173fb35ad52c4e5b90bae74d282d28ad/src%2Fdoc%2Fguide.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide.md?ref=6de570f8173fb35ad52c4e5b90bae74d282d28ad", "patch": "@@ -3668,6 +3668,173 @@ In order to truly understand this error, we have to learn a few new concepts:\n \n ## Ownership, borrowing, and lifetimes\n \n+Whenever a resource of some kind is created, something must be responsible\n+for destroying that resource as well. Given that we're discussing pointers\n+right now, let's discuss this in the context of memory allocation, though\n+it applies to other resources as well.\n+\n+When you allocate heap memory, you need a mechanism to free that memory.  Many\n+languages let the programmer control the allocation, and then use a garbage\n+collector to handle the deallocation. This is a valid, time-tested strategy,\n+but it's not without its drawbacks. Because the programmer does not have to\n+think as much about deallocation, allocation becomes something commonplace,\n+because it's easy. And if you need precise control over when something is\n+deallocated, leaving it up to your runtime can make this difficult.\n+\n+Rust chooses a different path, and that path is called **ownership**. Any\n+binding that creates a resource is the **owner** of that resource.  Being an\n+owner gives you three privileges, with two restrictions:\n+\n+1. You control when that resource is deallocated.\n+2. You may lend that resource, immutably, to as many borrowers as you'd like.\n+3. You may lend that resource, mutably, to a single borrower. **BUT**\n+4. Once you've done so, you may not also lend it out otherwise, mutably or\n+   immutably.\n+5. You may not lend it out mutably if you're currently lending it to someone.\n+\n+What's up with all this 'lending' and 'borrowing'? When you allocate memory,\n+you get a pointer to that memory. This pointer allows you to manipulate said\n+memory. If you are the owner of a pointer, then you may allow another\n+binding to temporarily borrow that pointer, and then they can manipulate the\n+memory. The length of time that the borrower is borrowing the pointer\n+from you is called a **lifetime**.\n+\n+If two distinct bindings share a pointer, and the memory that pointer points to\n+is immutable, then there are no problems. But if it's mutable, both pointers\n+can attempt to write to the memory at the same time, causing a **race\n+condition**. Therefore, if someone wants to mutate something that they've\n+borrowed from you, you must not have lent out that pointer to anyone else.\n+\n+Rust has a sophisticated system called the **borrow checker** to make sure that\n+everyone plays by these rules. At compile time, it verifies that none of these\n+rules are broken. If there's no problem, our program compiles successfully, and\n+there is no runtime overhead for any of this. The borrow checker works only at\n+compile time. If the borrow checker did find a problem, it will report a\n+**lifetime error**, and your program will refuse to compile.\n+\n+That's a lot to take in. It's also one of the _most_ important concepts in\n+all of Rust. Let's see this syntax in action:\n+\n+```{rust}\n+{ \n+    let x = 5i; // x is the owner of this integer, which is memory on the stack.\n+\n+    // other code here...\n+   \n+} // privilege 1: when x goes out of scope, this memory is deallocated\n+\n+/// this function borrows an integer. It's given back automatically when the\n+/// function returns.\n+fn foo(x: &int) -> &int { x } \n+\n+{ \n+    let x = 5i; // x is the owner of this integer, which is memory on the stack.\n+\n+    // privilege 2: you may lend that resource, to as many borrowers as you'd like\n+    let y = &x;\n+    let z = &x;\n+\n+    foo(&x); // functions can borrow too!\n+\n+    let a = &x; // we can do this alllllll day!\n+} \n+\n+{ \n+    let mut x = 5i; // x is the owner of this integer, which is memory on the stack.\n+\n+    let y = &mut x; // privilege 3: you may lend that resource to a single borrower,\n+                    // mutably\n+}   \n+```\n+\n+If you are a borrower, you get a few privileges as well, but must also obey a\n+restriction:\n+\n+1. If the borrow is immutable, you may read the data the pointer points to.\n+2. If the borrow is mutable, you may read and write the data the pointer points to.\n+3. You may lend the pointer to someone else in an immutable fashion, **BUT**\n+4. When you do so, they must return it to you before you must give your own\n+   borrow back.\n+\n+This last requirement can seem odd, but it also makes sense. If you have to\n+return something, and you've lent it to someone, they need to give it back to\n+you for you to give it back! If we didn't, then the owner could deallocate\n+the memory, and the person we've loaned it out to would have a pointer to\n+invalid memory. This is called a 'dangling pointer.'\n+\n+Let's re-examine the error that led us to talk about all of this, which was a\n+violation of the restrictions placed on owners who lend something out mutably.\n+The code:\n+\n+```{rust,ignore}\n+let mut x = 5i;\n+let y = &mut x;\n+let z = &mut x;\n+```\n+\n+The error:\n+\n+```{notrust,ignore}\n+error: cannot borrow `x` as mutable more than once at a time\n+     let z = &mut x;\n+                  ^\n+note: previous borrow of `x` occurs here; the mutable borrow prevents subsequent moves, borrows, or modification of `x` until the borrow ends\n+     let y = &mut x;\n+                  ^\n+note: previous borrow ends here\n+ fn main() {\n+     let mut x = 5i;\n+     let y = &mut x;\n+     let z = &mut x;\n+ }\n+ ^\n+```\n+\n+This error comes in three parts. Let's go over each in turn.\n+\n+```{notrust,ignore}\n+error: cannot borrow `x` as mutable more than once at a time\n+     let z = &mut x;\n+                  ^\n+```\n+\n+This error states the restriction: you cannot lend out something mutable more\n+than once at the same time. The borrow checker knows the rules!\n+\n+```{notrust,ignore}\n+note: previous borrow of `x` occurs here; the mutable borrow prevents subsequent moves, borrows, or modification of `x` until the borrow ends\n+     let y = &mut x;\n+                  ^\n+```\n+\n+Some compiler errors come with notes to help you fix the error. This error comes\n+with two notes, and this is the first. This note informs us of exactly where\n+the first mutable borrow occurred. The error showed us the second. So now we\n+see both parts of the problem. It also alludes to rule #3, by reminding us that\n+we can't change `x` until the borrow is over.\n+\n+```{notrust,ignore}\n+note: previous borrow ends here\n+ fn main() {\n+     let mut x = 5i;\n+     let y = &mut x;\n+     let z = &mut x;\n+ }\n+ ^\n+```\n+\n+Here's the second note, which lets us know where the first borrow would be over.\n+This is useful, because if we wait to try to borrow `x` after this borrow is\n+over, then everything will work.\n+\n+These rules are very simple, but that doesn't mean that they're easy. For more\n+advanced patterns, please consult the [Lifetime Guide](guide-lifetimes.html).\n+You'll also learn what this type signature with the `'a` syntax is:\n+\n+```{rust,ignore}\n+pub fn as_maybe_owned(&self) -> MaybeOwned<'a> { ... }\n+```\n+\n ## Boxes\n \n All of our references so far have been to variables we've created on the stack."}]}