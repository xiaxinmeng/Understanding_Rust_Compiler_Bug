{"sha": "7ca430df713ad1697a9d27eb4ae0f49c8563eed4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdjYTQzMGRmNzEzYWQxNjk3YTlkMjdlYjRhZTBmNDljODU2M2VlZDQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-11-08T17:27:56Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-11-08T17:27:56Z"}, "message": "Auto merge of #45205 - rkruppe:saturating-casts, r=eddyb\n\nSaturating casts between integers and floats\n\nIntroduces a new flag, `-Z saturating-float-casts`, which makes code generation for int->float and float->int casts safe (`undef`-free), implementing [the saturating semantics laid out by](https://github.com/rust-lang/rust/issues/10184#issuecomment-299229143) @jorendorff for float->int casts and overflowing to infinity for `u128::MAX` -> `f32`.\nConstant evaluation in trans was changed to behave like HIR const eval already did, i.e., saturate for u128->f32 and report an error for problematic float->int casts.\n\nMany thanks to @eddyb, whose APFloat port simplified many parts of this patch, and made HIR constant evaluation recognize dangerous float casts as mentioned above.\nAlso thanks to @ActuallyaDeviloper whose branchless implementation served as inspiration for this implementation.\n\ncc #10184 #41799\nfixes #45134", "tree": {"sha": "1c6453c32fe136f095038e6cfc1a3396a778ec3c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1c6453c32fe136f095038e6cfc1a3396a778ec3c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7ca430df713ad1697a9d27eb4ae0f49c8563eed4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7ca430df713ad1697a9d27eb4ae0f49c8563eed4", "html_url": "https://github.com/rust-lang/rust/commit/7ca430df713ad1697a9d27eb4ae0f49c8563eed4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7ca430df713ad1697a9d27eb4ae0f49c8563eed4/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6e2977499bc9075fcc50f03e155303db53583f90", "url": "https://api.github.com/repos/rust-lang/rust/commits/6e2977499bc9075fcc50f03e155303db53583f90", "html_url": "https://github.com/rust-lang/rust/commit/6e2977499bc9075fcc50f03e155303db53583f90"}, {"sha": "ef0b99930e52ee90f9452542dd14f148bbbe13af", "url": "https://api.github.com/repos/rust-lang/rust/commits/ef0b99930e52ee90f9452542dd14f148bbbe13af", "html_url": "https://github.com/rust-lang/rust/commit/ef0b99930e52ee90f9452542dd14f148bbbe13af"}], "stats": {"total": 551, "additions": 535, "deletions": 16}, "files": [{"sha": "0263c74595f261c6b71ad7608944bbb93e0ed384", "filename": "src/Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7ca430df713ad1697a9d27eb4ae0f49c8563eed4/src%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/7ca430df713ad1697a9d27eb4ae0f49c8563eed4/src%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.lock?ref=7ca430df713ad1697a9d27eb4ae0f49c8563eed4", "patch": "@@ -1869,6 +1869,7 @@ dependencies = [\n  \"rustc 0.0.0\",\n  \"rustc-demangle 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc_allocator 0.0.0\",\n+ \"rustc_apfloat 0.0.0\",\n  \"rustc_back 0.0.0\",\n  \"rustc_const_math 0.0.0\",\n  \"rustc_data_structures 0.0.0\","}, {"sha": "6939f8a55997b7e8096fad3c1613a1887b54fea9", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7ca430df713ad1697a9d27eb4ae0f49c8563eed4/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ca430df713ad1697a9d27eb4ae0f49c8563eed4/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=7ca430df713ad1697a9d27eb4ae0f49c8563eed4", "patch": "@@ -1135,6 +1135,9 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n         \"control whether #[inline] functions are in all cgus\"),\n     tls_model: Option<String> = (None, parse_opt_string, [TRACKED],\n          \"choose the TLS model to use (rustc --print tls-models for details)\"),\n+    saturating_float_casts: bool = (false, parse_bool, [TRACKED],\n+        \"make casts between integers and floats safe: clip out-of-range inputs to the min/max \\\n+         integer or to infinity respectively, and turn `NAN` into 0 when casting to integers\"),\n }\n \n pub fn default_lib_output() -> CrateType {"}, {"sha": "09c9cecdceee6ffa016aa62af12dfa598be33ae8", "filename": "src/librustc_apfloat/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7ca430df713ad1697a9d27eb4ae0f49c8563eed4/src%2Flibrustc_apfloat%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ca430df713ad1697a9d27eb4ae0f49c8563eed4/src%2Flibrustc_apfloat%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_apfloat%2Flib.rs?ref=7ca430df713ad1697a9d27eb4ae0f49c8563eed4", "patch": "@@ -96,7 +96,7 @@ impl Status {\n }\n \n impl<T> StatusAnd<T> {\n-    fn map<F: FnOnce(T) -> U, U>(self, f: F) -> StatusAnd<U> {\n+    pub fn map<F: FnOnce(T) -> U, U>(self, f: F) -> StatusAnd<U> {\n         StatusAnd {\n             status: self.status,\n             value: f(self.value),\n@@ -378,7 +378,7 @@ pub trait Float\n     fn from_bits(input: u128) -> Self;\n     fn from_i128_r(input: i128, round: Round) -> StatusAnd<Self> {\n         if input < 0 {\n-            Self::from_u128_r(-input as u128, -round).map(|r| -r)\n+            Self::from_u128_r(input.wrapping_neg() as u128, -round).map(|r| -r)\n         } else {\n             Self::from_u128_r(input as u128, round)\n         }"}, {"sha": "9d820ea8cbed2990e91ab163aee9416840f8e8b1", "filename": "src/librustc_const_math/float.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7ca430df713ad1697a9d27eb4ae0f49c8563eed4/src%2Flibrustc_const_math%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ca430df713ad1697a9d27eb4ae0f49c8563eed4/src%2Flibrustc_const_math%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_math%2Ffloat.rs?ref=7ca430df713ad1697a9d27eb4ae0f49c8563eed4", "patch": "@@ -203,3 +203,11 @@ impl ::std::ops::Neg for ConstFloat {\n         ConstFloat { bits, ty: self.ty }\n     }\n }\n+\n+/// This is `f32::MAX + (0.5 ULP)` as an integer. Numbers greater or equal to this\n+/// are rounded to infinity when converted to `f32`.\n+///\n+/// NB: Computed as maximum significand with an extra 1 bit added (for the half ULP)\n+/// shifted by the maximum exponent (accounting for normalization).\n+pub const MAX_F32_PLUS_HALF_ULP: u128 = ((1 << (Single::PRECISION + 1)) - 1)\n+                                        << (Single::MAX_EXP - Single::PRECISION as i16);"}, {"sha": "f797464c1f8f13f8ffd4d89397a6e5c55c27ed5b", "filename": "src/librustc_trans/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7ca430df713ad1697a9d27eb4ae0f49c8563eed4/src%2Flibrustc_trans%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/7ca430df713ad1697a9d27eb4ae0f49c8563eed4/src%2Flibrustc_trans%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2FCargo.toml?ref=7ca430df713ad1697a9d27eb4ae0f49c8563eed4", "patch": "@@ -19,6 +19,7 @@ owning_ref = \"0.3.3\"\n rustc-demangle = \"0.1.4\"\n rustc = { path = \"../librustc\" }\n rustc_allocator = { path = \"../librustc_allocator\" }\n+rustc_apfloat = { path = \"../librustc_apfloat\" }\n rustc_back = { path = \"../librustc_back\" }\n rustc_const_math = { path = \"../librustc_const_math\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }"}, {"sha": "29394af33969faf984129c62405220a621739088", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7ca430df713ad1697a9d27eb4ae0f49c8563eed4/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ca430df713ad1697a9d27eb4ae0f49c8563eed4/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=7ca430df713ad1697a9d27eb4ae0f49c8563eed4", "patch": "@@ -24,6 +24,7 @@\n #![feature(custom_attribute)]\n #![allow(unused_attributes)]\n #![feature(i128_type)]\n+#![feature(i128)]\n #![feature(libc)]\n #![feature(quote)]\n #![feature(rustc_diagnostic_macros)]\n@@ -43,6 +44,7 @@ extern crate libc;\n extern crate owning_ref;\n #[macro_use] extern crate rustc;\n extern crate rustc_allocator;\n+extern crate rustc_apfloat;\n extern crate rustc_back;\n extern crate rustc_data_structures;\n extern crate rustc_incremental;"}, {"sha": "6573e507bd32554e26acd6398a9b7cde2d8c2a24", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 65, "deletions": 8, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/7ca430df713ad1697a9d27eb4ae0f49c8563eed4/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ca430df713ad1697a9d27eb4ae0f49c8563eed4/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=7ca430df713ad1697a9d27eb4ae0f49c8563eed4", "patch": "@@ -11,7 +11,7 @@\n use llvm::{self, ValueRef};\n use rustc::middle::const_val::{ConstEvalErr, ConstVal, ErrKind};\n use rustc_const_math::ConstInt::*;\n-use rustc_const_math::{ConstInt, ConstMathErr};\n+use rustc_const_math::{ConstInt, ConstMathErr, MAX_F32_PLUS_HALF_ULP};\n use rustc::hir::def_id::DefId;\n use rustc::infer::TransNormalize;\n use rustc::traits;\n@@ -21,6 +21,7 @@ use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n use rustc::ty::layout::{self, LayoutTyper};\n use rustc::ty::cast::{CastTy, IntTy};\n use rustc::ty::subst::{Kind, Substs, Subst};\n+use rustc_apfloat::{ieee, Float, Status};\n use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n use {adt, base, machine};\n use abi::{self, Abi};\n@@ -689,20 +690,18 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                                     llvm::LLVMConstIntCast(llval, ll_t_out.to_ref(), s)\n                                 }\n                                 (CastTy::Int(_), CastTy::Float) => {\n-                                    if signed {\n-                                        llvm::LLVMConstSIToFP(llval, ll_t_out.to_ref())\n-                                    } else {\n-                                        llvm::LLVMConstUIToFP(llval, ll_t_out.to_ref())\n-                                    }\n+                                    cast_const_int_to_float(self.ccx, llval, signed, ll_t_out)\n                                 }\n                                 (CastTy::Float, CastTy::Float) => {\n                                     llvm::LLVMConstFPCast(llval, ll_t_out.to_ref())\n                                 }\n                                 (CastTy::Float, CastTy::Int(IntTy::I)) => {\n-                                    llvm::LLVMConstFPToSI(llval, ll_t_out.to_ref())\n+                                    cast_const_float_to_int(self.ccx, &operand,\n+                                                            true, ll_t_out, span)\n                                 }\n                                 (CastTy::Float, CastTy::Int(_)) => {\n-                                    llvm::LLVMConstFPToUI(llval, ll_t_out.to_ref())\n+                                    cast_const_float_to_int(self.ccx, &operand,\n+                                                            false, ll_t_out, span)\n                                 }\n                                 (CastTy::Ptr(_), CastTy::Ptr(_)) |\n                                 (CastTy::FnPtr, CastTy::Ptr(_)) |\n@@ -955,6 +954,64 @@ pub fn const_scalar_checked_binop<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n }\n \n+unsafe fn cast_const_float_to_int(ccx: &CrateContext,\n+                                  operand: &Const,\n+                                  signed: bool,\n+                                  int_ty: Type,\n+                                  span: Span) -> ValueRef {\n+    let llval = operand.llval;\n+    let float_bits = match operand.ty.sty {\n+        ty::TyFloat(fty) => fty.bit_width(),\n+        _ => bug!(\"cast_const_float_to_int: operand not a float\"),\n+    };\n+    // Note: this breaks if llval is a complex constant expression rather than a simple constant.\n+    // One way that might happen would be if addresses could be turned into integers in constant\n+    // expressions, but that doesn't appear to be possible?\n+    // In any case, an ICE is better than producing undef.\n+    let llval_bits = consts::bitcast(llval, Type::ix(ccx, float_bits as u64));\n+    let bits = const_to_opt_u128(llval_bits, false).unwrap_or_else(|| {\n+        panic!(\"could not get bits of constant float {:?}\",\n+               Value(llval));\n+    });\n+    let int_width = int_ty.int_width() as usize;\n+    // Try to convert, but report an error for overflow and NaN. This matches HIR const eval.\n+    let cast_result = match float_bits {\n+        32 if signed => ieee::Single::from_bits(bits).to_i128(int_width).map(|v| v as u128),\n+        64 if signed => ieee::Double::from_bits(bits).to_i128(int_width).map(|v| v as u128),\n+        32 => ieee::Single::from_bits(bits).to_u128(int_width),\n+        64 => ieee::Double::from_bits(bits).to_u128(int_width),\n+        n => bug!(\"unsupported float width {}\", n),\n+    };\n+    if cast_result.status.contains(Status::INVALID_OP) {\n+        let err = ConstEvalErr { span: span, kind: ErrKind::CannotCast };\n+        err.report(ccx.tcx(), span, \"expression\");\n+    }\n+    C_big_integral(int_ty, cast_result.value)\n+}\n+\n+unsafe fn cast_const_int_to_float(ccx: &CrateContext,\n+                                  llval: ValueRef,\n+                                  signed: bool,\n+                                  float_ty: Type) -> ValueRef {\n+    // Note: this breaks if llval is a complex constant expression rather than a simple constant.\n+    // One way that might happen would be if addresses could be turned into integers in constant\n+    // expressions, but that doesn't appear to be possible?\n+    // In any case, an ICE is better than producing undef.\n+    let value = const_to_opt_u128(llval, signed).unwrap_or_else(|| {\n+        panic!(\"could not get z128 value of constant integer {:?}\",\n+               Value(llval));\n+    });\n+    if signed {\n+        llvm::LLVMConstSIToFP(llval, float_ty.to_ref())\n+    } else if float_ty.float_width() == 32 && value >= MAX_F32_PLUS_HALF_ULP {\n+        // We're casting to f32 and the value is > f32::MAX + 0.5 ULP -> round up to infinity.\n+        let infinity_bits = C_u32(ccx, ieee::Single::INFINITY.to_bits() as u32);\n+        consts::bitcast(infinity_bits, float_ty)\n+    } else {\n+        llvm::LLVMConstUIToFP(llval, float_ty.to_ref())\n+    }\n+}\n+\n impl<'a, 'tcx> MirContext<'a, 'tcx> {\n     pub fn trans_constant(&mut self,\n                           bcx: &Builder<'a, 'tcx>,"}, {"sha": "19131a68d869d7f6c20ff6a5ea76fc85a44ff964", "filename": "src/librustc_trans/mir/rvalue.rs", "status": "modified", "additions": 163, "deletions": 6, "changes": 169, "blob_url": "https://github.com/rust-lang/rust/blob/7ca430df713ad1697a9d27eb4ae0f49c8563eed4/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ca430df713ad1697a9d27eb4ae0f49c8563eed4/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Frvalue.rs?ref=7ca430df713ad1697a9d27eb4ae0f49c8563eed4", "patch": "@@ -15,11 +15,15 @@ use rustc::ty::layout::{Layout, LayoutTyper};\n use rustc::mir::tcx::LvalueTy;\n use rustc::mir;\n use rustc::middle::lang_items::ExchangeMallocFnLangItem;\n+use rustc_apfloat::{ieee, Float, Status, Round};\n+use rustc_const_math::MAX_F32_PLUS_HALF_ULP;\n+use std::{u128, i128};\n \n use base;\n use builder::Builder;\n use callee;\n-use common::{self, val_ty, C_bool, C_i32, C_null, C_usize, C_uint};\n+use common::{self, val_ty, C_bool, C_i32, C_u32, C_u64, C_null, C_usize, C_uint, C_big_integral};\n+use consts;\n use adt;\n use machine;\n use monomorphize;\n@@ -333,14 +337,12 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                                 bcx.ptrtoint(llval, ll_t_out),\n                             (CastTy::Int(_), CastTy::Ptr(_)) =>\n                                 bcx.inttoptr(llval, ll_t_out),\n-                            (CastTy::Int(_), CastTy::Float) if signed =>\n-                                bcx.sitofp(llval, ll_t_out),\n                             (CastTy::Int(_), CastTy::Float) =>\n-                                bcx.uitofp(llval, ll_t_out),\n+                                cast_int_to_float(&bcx, signed, llval, ll_t_in, ll_t_out),\n                             (CastTy::Float, CastTy::Int(IntTy::I)) =>\n-                                bcx.fptosi(llval, ll_t_out),\n+                                cast_float_to_int(&bcx, true, llval, ll_t_in, ll_t_out),\n                             (CastTy::Float, CastTy::Int(_)) =>\n-                                bcx.fptoui(llval, ll_t_out),\n+                                cast_float_to_int(&bcx, false, llval, ll_t_in, ll_t_out),\n                             _ => bug!(\"unsupported cast: {:?} to {:?}\", operand.ty, cast_ty)\n                         };\n                         OperandValue::Immediate(newval)\n@@ -815,3 +817,158 @@ fn get_overflow_intrinsic(oop: OverflowOp, bcx: &Builder, ty: Ty) -> ValueRef {\n \n     bcx.ccx.get_intrinsic(&name)\n }\n+\n+fn cast_int_to_float(bcx: &Builder,\n+                     signed: bool,\n+                     x: ValueRef,\n+                     int_ty: Type,\n+                     float_ty: Type) -> ValueRef {\n+    // Most integer types, even i128, fit into [-f32::MAX, f32::MAX] after rounding.\n+    // It's only u128 -> f32 that can cause overflows (i.e., should yield infinity).\n+    // LLVM's uitofp produces undef in those cases, so we manually check for that case.\n+    let is_u128_to_f32 = !signed && int_ty.int_width() == 128 && float_ty.float_width() == 32;\n+    if is_u128_to_f32 && bcx.sess().opts.debugging_opts.saturating_float_casts {\n+        // All inputs greater or equal to (f32::MAX + 0.5 ULP) are rounded to infinity,\n+        // and for everything else LLVM's uitofp works just fine.\n+        let max = C_big_integral(int_ty, MAX_F32_PLUS_HALF_ULP);\n+        let overflow = bcx.icmp(llvm::IntUGE, x, max);\n+        let infinity_bits = C_u32(bcx.ccx, ieee::Single::INFINITY.to_bits() as u32);\n+        let infinity = consts::bitcast(infinity_bits, float_ty);\n+        bcx.select(overflow, infinity, bcx.uitofp(x, float_ty))\n+    } else {\n+        if signed {\n+            bcx.sitofp(x, float_ty)\n+        } else {\n+            bcx.uitofp(x, float_ty)\n+        }\n+    }\n+}\n+\n+fn cast_float_to_int(bcx: &Builder,\n+                     signed: bool,\n+                     x: ValueRef,\n+                     float_ty: Type,\n+                     int_ty: Type) -> ValueRef {\n+    let fptosui_result = if signed {\n+        bcx.fptosi(x, int_ty)\n+    } else {\n+        bcx.fptoui(x, int_ty)\n+    };\n+\n+    if !bcx.sess().opts.debugging_opts.saturating_float_casts {\n+        return fptosui_result;\n+    }\n+    // LLVM's fpto[su]i returns undef when the input x is infinite, NaN, or does not fit into the\n+    // destination integer type after rounding towards zero. This `undef` value can cause UB in\n+    // safe code (see issue #10184), so we implement a saturating conversion on top of it:\n+    // Semantically, the mathematical value of the input is rounded towards zero to the next\n+    // mathematical integer, and then the result is clamped into the range of the destination\n+    // integer type. Positive and negative infinity are mapped to the maximum and minimum value of\n+    // the destination integer type. NaN is mapped to 0.\n+    //\n+    // Define f_min and f_max as the largest and smallest (finite) floats that are exactly equal to\n+    // a value representable in int_ty.\n+    // They are exactly equal to int_ty::{MIN,MAX} if float_ty has enough significand bits.\n+    // Otherwise, int_ty::MAX must be rounded towards zero, as it is one less than a power of two.\n+    // int_ty::MIN, however, is either zero or a negative power of two and is thus exactly\n+    // representable. Note that this only works if float_ty's exponent range is sufficently large.\n+    // f16 or 256 bit integers would break this property. Right now the smallest float type is f32\n+    // with exponents ranging up to 127, which is barely enough for i128::MIN = -2^127.\n+    // On the other hand, f_max works even if int_ty::MAX is greater than float_ty::MAX. Because\n+    // we're rounding towards zero, we just get float_ty::MAX (which is always an integer).\n+    // This already happens today with u128::MAX = 2^128 - 1 > f32::MAX.\n+    fn compute_clamp_bounds<F: Float>(signed: bool, int_ty: Type) -> (u128, u128) {\n+        let rounded_min = F::from_i128_r(int_min(signed, int_ty), Round::TowardZero);\n+        assert_eq!(rounded_min.status, Status::OK);\n+        let rounded_max = F::from_u128_r(int_max(signed, int_ty), Round::TowardZero);\n+        assert!(rounded_max.value.is_finite());\n+        (rounded_min.value.to_bits(), rounded_max.value.to_bits())\n+    }\n+    fn int_max(signed: bool, int_ty: Type) -> u128 {\n+        let shift_amount = 128 - int_ty.int_width();\n+        if signed {\n+            i128::MAX as u128 >> shift_amount\n+        } else {\n+            u128::MAX >> shift_amount\n+        }\n+    }\n+    fn int_min(signed: bool, int_ty: Type) -> i128 {\n+        if signed {\n+            i128::MIN >> (128 - int_ty.int_width())\n+        } else {\n+            0\n+        }\n+    }\n+    let float_bits_to_llval = |bits| {\n+        let bits_llval = match float_ty.float_width() {\n+            32 => C_u32(bcx.ccx, bits as u32),\n+            64 => C_u64(bcx.ccx, bits as u64),\n+            n => bug!(\"unsupported float width {}\", n),\n+        };\n+        consts::bitcast(bits_llval, float_ty)\n+    };\n+    let (f_min, f_max) = match float_ty.float_width() {\n+        32 => compute_clamp_bounds::<ieee::Single>(signed, int_ty),\n+        64 => compute_clamp_bounds::<ieee::Double>(signed, int_ty),\n+        n => bug!(\"unsupported float width {}\", n),\n+    };\n+    let f_min = float_bits_to_llval(f_min);\n+    let f_max = float_bits_to_llval(f_max);\n+    // To implement saturation, we perform the following steps:\n+    //\n+    // 1. Cast x to an integer with fpto[su]i. This may result in undef.\n+    // 2. Compare x to f_min and f_max, and use the comparison results to select:\n+    //  a) int_ty::MIN if x < f_min or x is NaN\n+    //  b) int_ty::MAX if x > f_max\n+    //  c) the result of fpto[su]i otherwise\n+    // 3. If x is NaN, return 0.0, otherwise return the result of step 2.\n+    //\n+    // This avoids resulting undef because values in range [f_min, f_max] by definition fit into the\n+    // destination type. It creates an undef temporary, but *producing* undef is not UB. Our use of\n+    // undef does not introduce any non-determinism either.\n+    // More importantly, the above procedure correctly implements saturating conversion.\n+    // Proof (sketch):\n+    // If x is NaN, 0 is returned by definition.\n+    // Otherwise, x is finite or infinite and thus can be compared with f_min and f_max.\n+    // This yields three cases to consider:\n+    // (1) if x in [f_min, f_max], the result of fpto[su]i is returned, which agrees with\n+    //     saturating conversion for inputs in that range.\n+    // (2) if x > f_max, then x is larger than int_ty::MAX. This holds even if f_max is rounded\n+    //     (i.e., if f_max < int_ty::MAX) because in those cases, nextUp(f_max) is already larger\n+    //     than int_ty::MAX. Because x is larger than int_ty::MAX, the return value of int_ty::MAX\n+    //     is correct.\n+    // (3) if x < f_min, then x is smaller than int_ty::MIN. As shown earlier, f_min exactly equals\n+    //     int_ty::MIN and therefore the return value of int_ty::MIN is correct.\n+    // QED.\n+\n+    // Step 1 was already performed above.\n+\n+    // Step 2: We use two comparisons and two selects, with %s1 being the result:\n+    //     %less_or_nan = fcmp ult %x, %f_min\n+    //     %greater = fcmp olt %x, %f_max\n+    //     %s0 = select %less_or_nan, int_ty::MIN, %fptosi_result\n+    //     %s1 = select %greater, int_ty::MAX, %s0\n+    // Note that %less_or_nan uses an *unordered* comparison. This comparison is true if the\n+    // operands are not comparable (i.e., if x is NaN). The unordered comparison ensures that s1\n+    // becomes int_ty::MIN if x is NaN.\n+    // Performance note: Unordered comparison can be lowered to a \"flipped\" comparison and a\n+    // negation, and the negation can be merged into the select. Therefore, it not necessarily any\n+    // more expensive than a ordered (\"normal\") comparison. Whether these optimizations will be\n+    // performed is ultimately up to the backend, but at least x86 does perform them.\n+    let less_or_nan = bcx.fcmp(llvm::RealULT, x, f_min);\n+    let greater = bcx.fcmp(llvm::RealOGT, x, f_max);\n+    let int_max = C_big_integral(int_ty, int_max(signed, int_ty));\n+    let int_min = C_big_integral(int_ty, int_min(signed, int_ty) as u128);\n+    let s0 = bcx.select(less_or_nan, int_min, fptosui_result);\n+    let s1 = bcx.select(greater, int_max, s0);\n+\n+    // Step 3: NaN replacement.\n+    // For unsigned types, the above step already yielded int_ty::MIN == 0 if x is NaN.\n+    // Therefore we only need to execute this step for signed integer types.\n+    if signed {\n+        // LLVM has no isNaN predicate, so we use (x == x) instead\n+        bcx.select(bcx.fcmp(llvm::RealOEQ, x, x), s1, C_uint(int_ty, 0))\n+    } else {\n+        s1\n+    }\n+}"}, {"sha": "64ab19cceee2d2399eb2b1f6ca02d49265acbe60", "filename": "src/test/codegen/unchecked-float-casts.rs", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/7ca430df713ad1697a9d27eb4ae0f49c8563eed4/src%2Ftest%2Fcodegen%2Funchecked-float-casts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ca430df713ad1697a9d27eb4ae0f49c8563eed4/src%2Ftest%2Fcodegen%2Funchecked-float-casts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Funchecked-float-casts.rs?ref=7ca430df713ad1697a9d27eb4ae0f49c8563eed4", "patch": "@@ -0,0 +1,65 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags: -C no-prepopulate-passes\n+\n+// This file tests that we don't generate any code for saturation if\n+// -Z saturating-float-casts is not enabled.\n+\n+#![crate_type = \"lib\"]\n+#![feature(i128_type)]\n+\n+// CHECK-LABEL: @f32_to_u32\n+#[no_mangle]\n+pub fn f32_to_u32(x: f32) -> u32 {\n+    // CHECK: fptoui\n+    // CHECK-NOT: fcmp\n+    // CHECK-NOT: icmp\n+    // CHECK-NOT: select\n+    x as u32\n+}\n+\n+// CHECK-LABEL: @f32_to_i32\n+#[no_mangle]\n+pub fn f32_to_i32(x: f32) -> i32 {\n+    // CHECK: fptosi\n+    // CHECK-NOT: fcmp\n+    // CHECK-NOT: icmp\n+    // CHECK-NOT: select\n+    x as i32\n+}\n+\n+#[no_mangle]\n+pub fn f64_to_u8(x: f32) -> u16 {\n+    // CHECK-NOT: fcmp\n+    // CHECK-NOT: icmp\n+    // CHECK-NOT: select\n+    x as u16\n+}\n+\n+// CHECK-LABEL: @i32_to_f64\n+#[no_mangle]\n+pub fn i32_to_f64(x: i32) -> f64 {\n+    // CHECK: sitofp\n+    // CHECK-NOT: fcmp\n+    // CHECK-NOT: icmp\n+    // CHECK-NOT: select\n+    x as f64\n+}\n+\n+// CHECK-LABEL: @u128_to_f32\n+#[no_mangle]\n+pub fn u128_to_f32(x: u128) -> f32 {\n+    // CHECK: uitofp\n+    // CHECK-NOT: fcmp\n+    // CHECK-NOT: icmp\n+    // CHECK-NOT: select\n+    x as f32\n+}"}, {"sha": "2efefd926919fd6c885ce3264e60d59794af52a7", "filename": "src/test/compile-fail/float-int-invalid-const-cast.rs", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/7ca430df713ad1697a9d27eb4ae0f49c8563eed4/src%2Ftest%2Fcompile-fail%2Ffloat-int-invalid-const-cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ca430df713ad1697a9d27eb4ae0f49c8563eed4/src%2Ftest%2Fcompile-fail%2Ffloat-int-invalid-const-cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffloat-int-invalid-const-cast.rs?ref=7ca430df713ad1697a9d27eb4ae0f49c8563eed4", "patch": "@@ -0,0 +1,61 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(i128_type)]\n+#![allow(const_err)] // this test is only about hard errors\n+\n+use std::{f32, f64};\n+\n+// Forces evaluation of constants, triggering hard error\n+fn force<T>(_: T) {}\n+\n+fn main() {\n+    { const X: u16 = -1. as u16; force(X); } //~ ERROR constant evaluation error\n+    { const X: u128 = -100. as u128; force(X); } //~ ERROR constant evaluation error\n+\n+    { const X: i8 = f32::NAN as i8; force(X); } //~ ERROR constant evaluation error\n+    { const X: i32 = f32::NAN as i32; force(X); } //~ ERROR constant evaluation error\n+    { const X: u64 = f32::NAN as u64; force(X); } //~ ERROR constant evaluation error\n+    { const X: u128 = f32::NAN as u128; force(X); } //~ ERROR constant evaluation error\n+\n+    { const X: i8 = f32::INFINITY as i8; force(X); } //~ ERROR constant evaluation error\n+    { const X: u32 = f32::INFINITY as u32; force(X); } //~ ERROR constant evaluation error\n+    { const X: i128 = f32::INFINITY as i128; force(X); } //~ ERROR constant evaluation error\n+    { const X: u128 = f32::INFINITY as u128; force(X); } //~ ERROR constant evaluation error\n+\n+    { const X: u8 = f32::NEG_INFINITY as u8; force(X); } //~ ERROR constant evaluation error\n+    { const X: u16 = f32::NEG_INFINITY as u16; force(X); } //~ ERROR constant evaluation error\n+    { const X: i64 = f32::NEG_INFINITY as i64; force(X); } //~ ERROR constant evaluation error\n+    { const X: i128 = f32::NEG_INFINITY as i128; force(X); } //~ ERROR constant evaluation error\n+\n+    { const X: i8 = f64::NAN as i8; force(X); } //~ ERROR constant evaluation error\n+    { const X: i32 = f64::NAN as i32; force(X); } //~ ERROR constant evaluation error\n+    { const X: u64 = f64::NAN as u64; force(X); } //~ ERROR constant evaluation error\n+    { const X: u128 = f64::NAN as u128; force(X); } //~ ERROR constant evaluation error\n+\n+    { const X: i8 = f64::INFINITY as i8; force(X); } //~ ERROR constant evaluation error\n+    { const X: u32 = f64::INFINITY as u32; force(X); } //~ ERROR constant evaluation error\n+    { const X: i128 = f64::INFINITY as i128; force(X); } //~ ERROR constant evaluation error\n+    { const X: u128 = f64::INFINITY as u128; force(X); } //~ ERROR constant evaluation error\n+\n+    { const X: u8 = f64::NEG_INFINITY as u8; force(X); } //~ ERROR constant evaluation error\n+    { const X: u16 = f64::NEG_INFINITY as u16; force(X); } //~ ERROR constant evaluation error\n+    { const X: i64 = f64::NEG_INFINITY as i64; force(X); } //~ ERROR constant evaluation error\n+    { const X: i128 = f64::NEG_INFINITY as i128; force(X); } //~ ERROR constant evaluation error\n+\n+    { const X: u8 = 256. as u8; force(X); } //~ ERROR constant evaluation error\n+    { const X: i8 = -129. as i8; force(X); } //~ ERROR constant evaluation error\n+    { const X: i8 = 128. as i8; force(X); } //~ ERROR constant evaluation error\n+    { const X: i32 = 2147483648. as i32; force(X); } //~ ERROR constant evaluation error\n+    { const X: i32 = -2147483904. as i32; force(X); } //~ ERROR constant evaluation error\n+    { const X: u32 = 4294967296. as u32; force(X); } //~ ERROR constant evaluation error\n+    { const X: u128 = 1e40 as u128; force(X); } //~ ERROR constant evaluation error\n+    { const X: i128 = 1e40 as i128; force(X); } //~ ERROR constant evaluation error\n+}\n\\ No newline at end of file"}, {"sha": "6db4d7635f07f82c48016fe3fa10e903a2e605be", "filename": "src/test/run-pass/saturating-float-casts.rs", "status": "added", "additions": 164, "deletions": 0, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/7ca430df713ad1697a9d27eb4ae0f49c8563eed4/src%2Ftest%2Frun-pass%2Fsaturating-float-casts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ca430df713ad1697a9d27eb4ae0f49c8563eed4/src%2Ftest%2Frun-pass%2Fsaturating-float-casts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsaturating-float-casts.rs?ref=7ca430df713ad1697a9d27eb4ae0f49c8563eed4", "patch": "@@ -0,0 +1,164 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags: -Z saturating-float-casts\n+\n+#![feature(test, i128, i128_type, stmt_expr_attributes)]\n+#![deny(overflowing_literals)]\n+extern crate test;\n+\n+use std::{f32, f64};\n+use std::{u8, i8, u16, i16, u32, i32, u64, i64};\n+#[cfg(not(target_os=\"emscripten\"))]\n+use std::{u128, i128};\n+use test::black_box;\n+\n+macro_rules! test {\n+    ($val:expr, $src_ty:ident -> $dest_ty:ident, $expected:expr) => (\n+        // black_box disables constant evaluation to test run-time conversions:\n+        assert_eq!(black_box::<$src_ty>($val) as $dest_ty, $expected,\n+                    \"run-time {} -> {}\", stringify!($src_ty), stringify!($dest_ty));\n+    );\n+\n+    ($fval:expr, f* -> $ity:ident, $ival:expr) => (\n+        test!($fval, f32 -> $ity, $ival);\n+        test!($fval, f64 -> $ity, $ival);\n+    )\n+}\n+\n+// This macro tests const eval in addition to run-time evaluation.\n+// If and when saturating casts are adopted, this macro should be merged with test!() to ensure\n+// that run-time and const eval agree on inputs that currently trigger a const eval error.\n+macro_rules! test_c {\n+    ($val:expr, $src_ty:ident -> $dest_ty:ident, $expected:expr) => ({\n+        test!($val, $src_ty -> $dest_ty, $expected);\n+        {\n+            const X: $src_ty = $val;\n+            const Y: $dest_ty = X as $dest_ty;\n+            assert_eq!(Y, $expected,\n+                        \"const eval {} -> {}\", stringify!($src_ty), stringify!($dest_ty));\n+        }\n+    });\n+\n+    ($fval:expr, f* -> $ity:ident, $ival:expr) => (\n+        test!($fval, f32 -> $ity, $ival);\n+        test!($fval, f64 -> $ity, $ival);\n+    )\n+}\n+\n+macro_rules! common_fptoi_tests {\n+    ($fty:ident -> $($ity:ident)+) => ({ $(\n+        test!($fty::NAN, $fty -> $ity, 0);\n+        test!($fty::INFINITY, $fty -> $ity, $ity::MAX);\n+        test!($fty::NEG_INFINITY, $fty -> $ity, $ity::MIN);\n+        // These two tests are not solely float->int tests, in particular the latter relies on\n+        // `u128::MAX as f32` not being UB. But that's okay, since this file tests int->float\n+        // as well, the test is just slightly misplaced.\n+        test!($ity::MIN as $fty, $fty -> $ity, $ity::MIN);\n+        test!($ity::MAX as $fty, $fty -> $ity, $ity::MAX);\n+        test_c!(0., $fty -> $ity, 0);\n+        test_c!($fty::MIN_POSITIVE, $fty -> $ity, 0);\n+        test!(-0.9, $fty -> $ity, 0);\n+        test_c!(1., $fty -> $ity, 1);\n+        test_c!(42., $fty -> $ity, 42);\n+    )+ });\n+\n+    (f* -> $($ity:ident)+) => ({\n+        common_fptoi_tests!(f32 -> $($ity)+);\n+        common_fptoi_tests!(f64 -> $($ity)+);\n+    })\n+}\n+\n+macro_rules! fptoui_tests {\n+    ($fty: ident -> $($ity: ident)+) => ({ $(\n+        test!(-0., $fty -> $ity, 0);\n+        test!(-$fty::MIN_POSITIVE, $fty -> $ity, 0);\n+        test!(-0.99999994, $fty -> $ity, 0);\n+        test!(-1., $fty -> $ity, 0);\n+        test!(-100., $fty -> $ity, 0);\n+        test!(#[allow(overflowing_literals)] -1e50, $fty -> $ity, 0);\n+        test!(#[allow(overflowing_literals)] -1e130, $fty -> $ity, 0);\n+    )+ });\n+\n+    (f* -> $($ity:ident)+) => ({\n+        fptoui_tests!(f32 -> $($ity)+);\n+        fptoui_tests!(f64 -> $($ity)+);\n+    })\n+}\n+\n+pub fn main() {\n+    common_fptoi_tests!(f* -> i8 i16 i32 i64 u8 u16 u32 u64);\n+    fptoui_tests!(f* -> u8 u16 u32 u64);\n+    // FIXME emscripten does not support i128\n+    #[cfg(not(target_os=\"emscripten\"))] {\n+        common_fptoi_tests!(f* -> i128 u128);\n+        fptoui_tests!(f* -> u128);\n+    }\n+\n+    // The following tests cover edge cases for some integer types.\n+\n+    // # u8\n+    test_c!(254., f* -> u8, 254);\n+    test!(256., f* -> u8, 255);\n+\n+    // # i8\n+    test_c!(-127., f* -> i8, -127);\n+    test!(-129., f* -> i8, -128);\n+    test_c!(126., f* -> i8, 126);\n+    test!(128., f* -> i8, 127);\n+\n+    // # i32\n+    // -2147483648. is i32::MIN (exactly)\n+    test_c!(-2147483648., f* -> i32, i32::MIN);\n+    // 2147483648. is i32::MAX rounded up\n+    test!(2147483648., f32 -> i32, 2147483647);\n+    // With 24 significand bits, floats with magnitude in [2^30 + 1, 2^31] are rounded to\n+    // multiples of 2^7. Therefore, nextDown(round(i32::MAX)) is 2^31 - 128:\n+    test_c!(2147483520., f32 -> i32, 2147483520);\n+    // Similarly, nextUp(i32::MIN) is i32::MIN + 2^8 and nextDown(i32::MIN) is i32::MIN - 2^7\n+    test!(-2147483904., f* -> i32, i32::MIN);\n+    test_c!(-2147483520., f* -> i32, -2147483520);\n+\n+    // # u32\n+    // round(MAX) and nextUp(round(MAX))\n+    test_c!(4294967040., f* -> u32, 4294967040);\n+    test!(4294967296., f* -> u32, 4294967295);\n+\n+    // # u128\n+    #[cfg(not(target_os=\"emscripten\"))]\n+    {\n+        // float->int:\n+        test_c!(f32::MAX, f32 -> u128, 0xffffff00000000000000000000000000);\n+        // nextDown(f32::MAX) = 2^128 - 2 * 2^104\n+        const SECOND_LARGEST_F32: f32 = 340282326356119256160033759537265639424.;\n+        test_c!(SECOND_LARGEST_F32, f32 -> u128, 0xfffffe00000000000000000000000000);\n+\n+        // int->float:\n+        // f32::MAX - 0.5 ULP and smaller should be rounded down\n+        test_c!(0xfffffe00000000000000000000000000, u128 -> f32, SECOND_LARGEST_F32);\n+        test_c!(0xfffffe7fffffffffffffffffffffffff, u128 -> f32, SECOND_LARGEST_F32);\n+        test_c!(0xfffffe80000000000000000000000000, u128 -> f32, SECOND_LARGEST_F32);\n+        // numbers within < 0.5 ULP of f32::MAX it should be rounded to f32::MAX\n+        test_c!(0xfffffe80000000000000000000000001, u128 -> f32, f32::MAX);\n+        test_c!(0xfffffeffffffffffffffffffffffffff, u128 -> f32, f32::MAX);\n+        test_c!(0xffffff00000000000000000000000000, u128 -> f32, f32::MAX);\n+        test_c!(0xffffff00000000000000000000000001, u128 -> f32, f32::MAX);\n+        test_c!(0xffffff7fffffffffffffffffffffffff, u128 -> f32, f32::MAX);\n+        // f32::MAX + 0.5 ULP and greater should be rounded to infinity\n+        test_c!(0xffffff80000000000000000000000000, u128 -> f32, f32::INFINITY);\n+        test_c!(0xffffff80000000f00000000000000000, u128 -> f32, f32::INFINITY);\n+        test_c!(0xffffff87ffffffffffffffff00000001, u128 -> f32, f32::INFINITY);\n+\n+        // u128->f64 should not be affected by the u128->f32 checks\n+        test_c!(0xffffff80000000000000000000000000, u128 -> f64,\n+              340282356779733661637539395458142568448.0);\n+        test_c!(u128::MAX, u128 -> f64, 340282366920938463463374607431768211455.0);\n+    }\n+}"}]}