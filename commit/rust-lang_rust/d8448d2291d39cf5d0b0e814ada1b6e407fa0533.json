{"sha": "d8448d2291d39cf5d0b0e814ada1b6e407fa0533", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ4NDQ4ZDIyOTFkMzljZjVkMGIwZTgxNGFkYTFiNmU0MDdmYTA1MzM=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2020-03-21T06:40:23Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2020-03-21T07:57:35Z"}, "message": "infer: export methods on `InferCtxt` instead of `ShallowResolver`.", "tree": {"sha": "640fda4a3727ab1f9da24b47f4063ee422f3101e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/640fda4a3727ab1f9da24b47f4063ee422f3101e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d8448d2291d39cf5d0b0e814ada1b6e407fa0533", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d8448d2291d39cf5d0b0e814ada1b6e407fa0533", "html_url": "https://github.com/rust-lang/rust/commit/d8448d2291d39cf5d0b0e814ada1b6e407fa0533", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d8448d2291d39cf5d0b0e814ada1b6e407fa0533/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5f13820478907b09d50baf74f3ff2b78499ecd6c", "url": "https://api.github.com/repos/rust-lang/rust/commits/5f13820478907b09d50baf74f3ff2b78499ecd6c", "html_url": "https://github.com/rust-lang/rust/commit/5f13820478907b09d50baf74f3ff2b78499ecd6c"}], "stats": {"total": 67, "additions": 29, "deletions": 38}, "files": [{"sha": "bb39858122a860be664bf50de201cbc9122208bc", "filename": "src/librustc_infer/infer/mod.rs", "status": "modified", "additions": 26, "deletions": 35, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/d8448d2291d39cf5d0b0e814ada1b6e407fa0533/src%2Flibrustc_infer%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8448d2291d39cf5d0b0e814ada1b6e407fa0533/src%2Flibrustc_infer%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fmod.rs?ref=d8448d2291d39cf5d0b0e814ada1b6e407fa0533", "patch": "@@ -1347,8 +1347,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     where\n         T: TypeFoldable<'tcx>,\n     {\n-        let mut r = ShallowResolver::new(self);\n-        value.fold_with(&mut r)\n+        value.fold_with(&mut ShallowResolver { infcx: self })\n     }\n \n     pub fn root_var(&self, var: ty::TyVid) -> ty::TyVid {\n@@ -1565,22 +1564,12 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         // variables, thus we don't need to substitute back the original values.\n         self.tcx.const_eval_resolve(param_env, def_id, substs, promoted, span)\n     }\n-}\n-\n-pub struct ShallowResolver<'a, 'tcx> {\n-    infcx: &'a InferCtxt<'a, 'tcx>,\n-}\n-\n-impl<'a, 'tcx> ShallowResolver<'a, 'tcx> {\n-    #[inline(always)]\n-    pub fn new(infcx: &'a InferCtxt<'a, 'tcx>) -> Self {\n-        ShallowResolver { infcx }\n-    }\n \n     /// If `typ` is a type variable of some kind, resolve it one level\n     /// (but do not resolve types found in the result). If `typ` is\n     /// not a type variable, just return it unmodified.\n-    pub fn shallow_resolve(&mut self, typ: Ty<'tcx>) -> Ty<'tcx> {\n+    // FIXME(eddyb) inline into `ShallowResolver::visit_ty`.\n+    fn shallow_resolve_ty(&self, typ: Ty<'tcx>) -> Ty<'tcx> {\n         match typ.kind {\n             ty::Infer(ty::TyVar(v)) => {\n                 // Not entirely obvious: if `typ` is a type variable,\n@@ -1594,78 +1583,80 @@ impl<'a, 'tcx> ShallowResolver<'a, 'tcx> {\n                 // depth.\n                 //\n                 // Note: if these two lines are combined into one we get\n-                // dynamic borrow errors on `self.infcx.inner`.\n-                let known = self.infcx.inner.borrow_mut().type_variables.probe(v).known();\n-                known.map(|t| self.fold_ty(t)).unwrap_or(typ)\n+                // dynamic borrow errors on `self.inner`.\n+                let known = self.inner.borrow_mut().type_variables.probe(v).known();\n+                known.map(|t| self.shallow_resolve_ty(t)).unwrap_or(typ)\n             }\n \n             ty::Infer(ty::IntVar(v)) => self\n-                .infcx\n                 .inner\n                 .borrow_mut()\n                 .int_unification_table\n                 .probe_value(v)\n-                .map(|v| v.to_type(self.infcx.tcx))\n+                .map(|v| v.to_type(self.tcx))\n                 .unwrap_or(typ),\n \n             ty::Infer(ty::FloatVar(v)) => self\n-                .infcx\n                 .inner\n                 .borrow_mut()\n                 .float_unification_table\n                 .probe_value(v)\n-                .map(|v| v.to_type(self.infcx.tcx))\n+                .map(|v| v.to_type(self.tcx))\n                 .unwrap_or(typ),\n \n             _ => typ,\n         }\n     }\n \n-    // `resolver.shallow_resolve_changed(ty)` is equivalent to\n-    // `resolver.shallow_resolve(ty) != ty`, but more efficient. It's always\n-    // inlined, despite being large, because it has only two call sites that\n-    // are extremely hot.\n+    /// `infer_ty_changed(infer_ty)` is equivalent to `shallow_resolve(ty) != ty`\n+    /// (where `ty.kind = ty::Infer(infer_ty)`), but more efficient. It's always\n+    /// inlined, despite being large, because it has only two call sites that\n+    /// are extremely hot.\n     #[inline(always)]\n-    pub fn shallow_resolve_changed(&self, infer: ty::InferTy) -> bool {\n-        match infer {\n+    pub fn infer_ty_changed(&self, infer_ty: ty::InferTy) -> bool {\n+        match infer_ty {\n             ty::TyVar(v) => {\n                 use self::type_variable::TypeVariableValue;\n \n-                // If `inlined_probe` returns a `Known` value its `kind` never\n-                // matches `infer`.\n-                match self.infcx.inner.borrow_mut().type_variables.inlined_probe(v) {\n+                // If `inlined_probe` returns a `Known` value, it never equals\n+                // `ty::Infer(ty::TyVar(v))`.\n+                match self.inner.borrow_mut().type_variables.inlined_probe(v) {\n                     TypeVariableValue::Unknown { .. } => false,\n                     TypeVariableValue::Known { .. } => true,\n                 }\n             }\n \n             ty::IntVar(v) => {\n-                // If inlined_probe_value returns a value it's always a\n+                // If `inlined_probe_value` returns a value it's always a\n                 // `ty::Int(_)` or `ty::UInt(_)`, which never matches a\n                 // `ty::Infer(_)`.\n-                self.infcx.inner.borrow_mut().int_unification_table.inlined_probe_value(v).is_some()\n+                self.inner.borrow_mut().int_unification_table.inlined_probe_value(v).is_some()\n             }\n \n             ty::FloatVar(v) => {\n-                // If inlined_probe_value returns a value it's always a\n+                // If `inlined_probe_value` returns a value it's always a\n                 // `ty::Float(_)`, which never matches a `ty::Infer(_)`.\n                 //\n                 // Not `inlined_probe_value(v)` because this call site is colder.\n-                self.infcx.inner.borrow_mut().float_unification_table.probe_value(v).is_some()\n+                self.inner.borrow_mut().float_unification_table.probe_value(v).is_some()\n             }\n \n             _ => unreachable!(),\n         }\n     }\n }\n \n+struct ShallowResolver<'a, 'tcx> {\n+    infcx: &'a InferCtxt<'a, 'tcx>,\n+}\n+\n impl<'a, 'tcx> TypeFolder<'tcx> for ShallowResolver<'a, 'tcx> {\n     fn tcx<'b>(&'b self) -> TyCtxt<'tcx> {\n         self.infcx.tcx\n     }\n \n     fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n-        self.shallow_resolve(ty)\n+        self.infcx.shallow_resolve_ty(ty)\n     }\n \n     fn fold_const(&mut self, ct: &'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx> {"}, {"sha": "710f01475842fe4e82fbd72e42e93a75d5cdacc4", "filename": "src/librustc_trait_selection/traits/fulfill.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d8448d2291d39cf5d0b0e814ada1b6e407fa0533/src%2Flibrustc_trait_selection%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8448d2291d39cf5d0b0e814ada1b6e407fa0533/src%2Flibrustc_trait_selection%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Ffulfill.rs?ref=d8448d2291d39cf5d0b0e814ada1b6e407fa0533", "patch": "@@ -1,4 +1,4 @@\n-use crate::infer::{InferCtxt, ShallowResolver};\n+use crate::infer::InferCtxt;\n use rustc::ty::error::ExpectedFound;\n use rustc::ty::{self, ToPolyTraitRef, Ty, TypeFoldable};\n use rustc_data_structures::obligation_forest::ProcessResult;\n@@ -267,7 +267,7 @@ impl<'a, 'b, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'tcx> {\n             // code is so hot. 1 and 0 dominate; 2+ is fairly rare.\n             1 => {\n                 let infer = pending_obligation.stalled_on[0];\n-                ShallowResolver::new(self.selcx.infcx()).shallow_resolve_changed(infer)\n+                self.selcx.infcx().infer_ty_changed(infer)\n             }\n             0 => {\n                 // In this case we haven't changed, but wish to make a change.\n@@ -278,7 +278,7 @@ impl<'a, 'b, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'tcx> {\n                 // form was a perf win. See #64545 for details.\n                 (|| {\n                     for &infer in &pending_obligation.stalled_on {\n-                        if ShallowResolver::new(self.selcx.infcx()).shallow_resolve_changed(infer) {\n+                        if self.selcx.infcx().infer_ty_changed(infer) {\n                             return true;\n                         }\n                     }"}]}