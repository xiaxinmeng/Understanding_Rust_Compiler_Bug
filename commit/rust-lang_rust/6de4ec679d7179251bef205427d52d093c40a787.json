{"sha": "6de4ec679d7179251bef205427d52d093c40a787", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZkZTRlYzY3OWQ3MTc5MjUxYmVmMjA1NDI3ZDUyZDA5M2M0MGE3ODc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-05-31T15:24:04Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-05-31T15:24:04Z"}, "message": "Auto merge of #51235 - nikomatsakis:issue-51117-borrowck-implicit-deref, r=eddyb\n\nremove notion of Implicit derefs from mem-cat\n\n`PointerKind` is included in `LoanPath` and hence forms part of the equality check; this led to having two unequal paths that both represent `*x`, depending on whether the `*` was inserted automatically or explicitly. Bad mojo.\n\nFixes #51117\n\nr? @eddyb", "tree": {"sha": "d15ed51b512993ddd18af2254f295841aecaa4d9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d15ed51b512993ddd18af2254f295841aecaa4d9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6de4ec679d7179251bef205427d52d093c40a787", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6de4ec679d7179251bef205427d52d093c40a787", "html_url": "https://github.com/rust-lang/rust/commit/6de4ec679d7179251bef205427d52d093c40a787", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6de4ec679d7179251bef205427d52d093c40a787/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ae2f2991860f1d117414a61b0b0c862a8e2d3468", "url": "https://api.github.com/repos/rust-lang/rust/commits/ae2f2991860f1d117414a61b0b0c862a8e2d3468", "html_url": "https://github.com/rust-lang/rust/commit/ae2f2991860f1d117414a61b0b0c862a8e2d3468"}, {"sha": "8a624b737a772ecc6840870bbf895950602b2920", "url": "https://api.github.com/repos/rust-lang/rust/commits/8a624b737a772ecc6840870bbf895950602b2920", "html_url": "https://github.com/rust-lang/rust/commit/8a624b737a772ecc6840870bbf895950602b2920"}], "stats": {"total": 207, "additions": 139, "deletions": 68}, "files": [{"sha": "9fb7d31ed6f75d178128989b8ed8f643da5afc47", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/6de4ec679d7179251bef205427d52d093c40a787/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6de4ec679d7179251bef205427d52d093c40a787/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=6de4ec679d7179251bef205427d52d093c40a787", "patch": "@@ -837,17 +837,24 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n     /// established up front, e.g. via `determine_pat_move_mode` (see\n     /// also `walk_irrefutable_pat` for patterns that stand alone).\n     fn walk_pat(&mut self, cmt_discr: mc::cmt<'tcx>, pat: &hir::Pat, match_mode: MatchMode) {\n-        debug!(\"walk_pat cmt_discr={:?} pat={:?}\", cmt_discr, pat);\n+        debug!(\"walk_pat(cmt_discr={:?}, pat={:?})\", cmt_discr, pat);\n \n         let ExprUseVisitor { ref mc, ref mut delegate, param_env } = *self;\n         return_if_err!(mc.cat_pattern(cmt_discr.clone(), pat, |cmt_pat, pat| {\n             if let PatKind::Binding(_, canonical_id, ..) = pat.node {\n-                debug!(\"binding cmt_pat={:?} pat={:?} match_mode={:?}\", cmt_pat, pat, match_mode);\n+                debug!(\n+                    \"walk_pat: binding cmt_pat={:?} pat={:?} match_mode={:?}\",\n+                    cmt_pat,\n+                    pat,\n+                    match_mode,\n+                );\n                 let bm = *mc.tables.pat_binding_modes().get(pat.hir_id)\n                                                      .expect(\"missing binding mode\");\n+                debug!(\"walk_pat: pat.hir_id={:?} bm={:?}\", pat.hir_id, bm);\n \n                 // pat_ty: the type of the binding being produced.\n                 let pat_ty = return_if_err!(mc.node_ty(pat.hir_id));\n+                debug!(\"walk_pat: pat_ty={:?}\", pat_ty);\n \n                 // Each match binding is effectively an assignment to the\n                 // binding being produced."}, {"sha": "f2120d97868271835a455c34dc08eb9bb084d34e", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 45, "deletions": 45, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/6de4ec679d7179251bef205427d52d093c40a787/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6de4ec679d7179251bef205427d52d093c40a787/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=6de4ec679d7179251bef205427d52d093c40a787", "patch": "@@ -95,7 +95,7 @@ pub enum Categorization<'tcx> {\n     StaticItem,\n     Upvar(Upvar),                          // upvar referenced by closure env\n     Local(ast::NodeId),                    // local variable\n-    Deref(cmt<'tcx>, PointerKind<'tcx>),   // deref of a ptr\n+    Deref(cmt<'tcx>, PointerKind<'tcx>), // deref of a ptr\n     Interior(cmt<'tcx>, InteriorKind),     // something interior: field, tuple, etc\n     Downcast(cmt<'tcx>, DefId),            // selects a particular enum variant (*1)\n \n@@ -120,9 +120,6 @@ pub enum PointerKind<'tcx> {\n \n     /// `*T`\n     UnsafePtr(hir::Mutability),\n-\n-    /// Implicit deref of the `&T` that results from an overloaded index `[]`.\n-    Implicit(ty::BorrowKind, ty::Region<'tcx>),\n }\n \n // We use the term \"interior\" to mean \"something reachable from the\n@@ -172,6 +169,7 @@ pub enum MutabilityCategory {\n pub enum Note {\n     NoteClosureEnv(ty::UpvarId), // Deref through closure env\n     NoteUpvarRef(ty::UpvarId),   // Deref through by-ref upvar\n+    NoteIndex,                   // Deref as part of desugaring `x[]` into its two components\n     NoteNone                     // Nothing special\n }\n \n@@ -231,8 +229,7 @@ impl<'tcx> cmt_<'tcx> {\n \n     pub fn immutability_blame(&self) -> Option<ImmutabilityBlame<'tcx>> {\n         match self.cat {\n-            Categorization::Deref(ref base_cmt, BorrowedPtr(ty::ImmBorrow, _)) |\n-            Categorization::Deref(ref base_cmt, Implicit(ty::ImmBorrow, _)) => {\n+            Categorization::Deref(ref base_cmt, BorrowedPtr(ty::ImmBorrow, _)) => {\n                 // try to figure out where the immutable reference came from\n                 match base_cmt.cat {\n                     Categorization::Local(node_id) =>\n@@ -328,7 +325,7 @@ impl MutabilityCategory {\n             Unique => {\n                 base_mutbl.inherit()\n             }\n-            BorrowedPtr(borrow_kind, _) | Implicit(borrow_kind, _) => {\n+            BorrowedPtr(borrow_kind, _) => {\n                 MutabilityCategory::from_borrow_kind(borrow_kind)\n             }\n             UnsafePtr(m) => {\n@@ -617,7 +614,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n                 } else {\n                     previous()?\n                 });\n-                self.cat_deref(expr, base, false)\n+                self.cat_deref(expr, base, NoteNone)\n             }\n \n             adjustment::Adjust::NeverToAny |\n@@ -640,10 +637,10 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n         match expr.node {\n           hir::ExprUnary(hir::UnDeref, ref e_base) => {\n             if self.tables.is_method_call(expr) {\n-                self.cat_overloaded_place(expr, e_base, false)\n+                self.cat_overloaded_place(expr, e_base, NoteNone)\n             } else {\n                 let base_cmt = Rc::new(self.cat_expr(&e_base)?);\n-                self.cat_deref(expr, base_cmt, false)\n+                self.cat_deref(expr, base_cmt, NoteNone)\n             }\n           }\n \n@@ -664,7 +661,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n                 // The call to index() returns a `&T` value, which\n                 // is an rvalue. That is what we will be\n                 // dereferencing.\n-                self.cat_overloaded_place(expr, base, true)\n+                self.cat_overloaded_place(expr, base, NoteIndex)\n             } else {\n                 let base_cmt = Rc::new(self.cat_expr(&base)?);\n                 self.cat_index(expr, base_cmt, expr_ty, InteriorOffsetKind::Index)\n@@ -999,12 +996,18 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n         ret\n     }\n \n-    fn cat_overloaded_place(&self,\n-                             expr: &hir::Expr,\n-                             base: &hir::Expr,\n-                             implicit: bool)\n-                             -> McResult<cmt_<'tcx>> {\n-        debug!(\"cat_overloaded_place: implicit={}\", implicit);\n+    fn cat_overloaded_place(\n+        &self,\n+        expr: &hir::Expr,\n+        base: &hir::Expr,\n+        note: Note,\n+    ) -> McResult<cmt_<'tcx>> {\n+        debug!(\n+            \"cat_overloaded_place(expr={:?}, base={:?}, note={:?})\",\n+            expr,\n+            base,\n+            note,\n+        );\n \n         // Reconstruct the output assuming it's a reference with the\n         // same region and mutability as the receiver. This holds for\n@@ -1024,14 +1027,15 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n         });\n \n         let base_cmt = Rc::new(self.cat_rvalue_node(expr.id, expr.span, ref_ty));\n-        self.cat_deref(expr, base_cmt, implicit)\n+        self.cat_deref(expr, base_cmt, note)\n     }\n \n-    pub fn cat_deref<N:ast_node>(&self,\n-                                 node: &N,\n-                                 base_cmt: cmt<'tcx>,\n-                                 implicit: bool)\n-                                 -> McResult<cmt_<'tcx>> {\n+    pub fn cat_deref(\n+        &self,\n+        node: &impl ast_node,\n+        base_cmt: cmt<'tcx>,\n+        note: Note,\n+    ) -> McResult<cmt_<'tcx>> {\n         debug!(\"cat_deref: base_cmt={:?}\", base_cmt);\n \n         let base_cmt_ty = base_cmt.ty;\n@@ -1049,7 +1053,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n             ty::TyRawPtr(ref mt) => UnsafePtr(mt.mutbl),\n             ty::TyRef(r, _, mutbl) => {\n                 let bk = ty::BorrowKind::from_mutbl(mutbl);\n-                if implicit { Implicit(bk, r) } else { BorrowedPtr(bk, r) }\n+                BorrowedPtr(bk, r)\n             }\n             ref ty => bug!(\"unexpected type in cat_deref: {:?}\", ty)\n         };\n@@ -1060,7 +1064,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n             mutbl: MutabilityCategory::from_pointer_kind(base_cmt.mutbl, ptr),\n             cat: Categorization::Deref(base_cmt, ptr),\n             ty: deref_ty,\n-            note: NoteNone\n+            note: note,\n         };\n         debug!(\"cat_deref ret {:?}\", ret);\n         Ok(ret)\n@@ -1193,7 +1197,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n         // step out of sync again. So you'll see below that we always\n         // get the type of the *subpattern* and use that.\n \n-        debug!(\"cat_pattern: {:?} cmt={:?}\", pat, cmt);\n+        debug!(\"cat_pattern(pat={:?}, cmt={:?})\", pat, cmt);\n \n         // If (pattern) adjustments are active for this pattern, adjust the `cmt` correspondingly.\n         // `cmt`s are constructed differently from patterns. For example, in\n@@ -1231,10 +1235,13 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n                         .pat_adjustments()\n                         .get(pat.hir_id)\n                         .map(|v| v.len())\n-                        .unwrap_or(0) {\n-            cmt = Rc::new(self.cat_deref(pat, cmt, true /* implicit */)?);\n+                        .unwrap_or(0)\n+        {\n+            debug!(\"cat_pattern: applying adjustment to cmt={:?}\", cmt);\n+            cmt = Rc::new(self.cat_deref(pat, cmt, NoteNone)?);\n         }\n         let cmt = cmt; // lose mutability\n+        debug!(\"cat_pattern: applied adjustment derefs to get cmt={:?}\", cmt);\n \n         // Invoke the callback, but only now, after the `cmt` has adjusted.\n         //\n@@ -1330,7 +1337,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n             // box p1, &p1, &mut p1.  we can ignore the mutability of\n             // PatKind::Ref since that information is already contained\n             // in the type.\n-            let subcmt = Rc::new(self.cat_deref(pat, cmt, false)?);\n+            let subcmt = Rc::new(self.cat_deref(pat, cmt, NoteNone)?);\n             self.cat_pattern_(subcmt, &subpat, op)?;\n           }\n \n@@ -1391,7 +1398,6 @@ impl<'tcx> cmt_<'tcx> {\n             Categorization::Local(..) |\n             Categorization::Deref(_, UnsafePtr(..)) |\n             Categorization::Deref(_, BorrowedPtr(..)) |\n-            Categorization::Deref(_, Implicit(..)) |\n             Categorization::Upvar(..) => {\n                 (*self).clone()\n             }\n@@ -1411,9 +1417,7 @@ impl<'tcx> cmt_<'tcx> {\n \n         match self.cat {\n             Categorization::Deref(ref b, BorrowedPtr(ty::MutBorrow, _)) |\n-            Categorization::Deref(ref b, Implicit(ty::MutBorrow, _)) |\n             Categorization::Deref(ref b, BorrowedPtr(ty::UniqueImmBorrow, _)) |\n-            Categorization::Deref(ref b, Implicit(ty::UniqueImmBorrow, _)) |\n             Categorization::Deref(ref b, Unique) |\n             Categorization::Downcast(ref b, _) |\n             Categorization::Interior(ref b, _) => {\n@@ -1436,8 +1440,7 @@ impl<'tcx> cmt_<'tcx> {\n                 }\n             }\n \n-            Categorization::Deref(_, BorrowedPtr(ty::ImmBorrow, _)) |\n-            Categorization::Deref(_, Implicit(ty::ImmBorrow, _)) => {\n+            Categorization::Deref(_, BorrowedPtr(ty::ImmBorrow, _)) => {\n                 FreelyAliasable(AliasableBorrowed)\n             }\n         }\n@@ -1460,7 +1463,7 @@ impl<'tcx> cmt_<'tcx> {\n                     _ => bug!()\n                 })\n             }\n-            NoteNone => None\n+            NoteIndex | NoteNone => None\n         }\n     }\n \n@@ -1487,17 +1490,17 @@ impl<'tcx> cmt_<'tcx> {\n                     Some(_) => bug!(),\n                     None => {\n                         match pk {\n-                            Implicit(..) => {\n-                                format!(\"indexed content\")\n-                            }\n                             Unique => {\n                                 format!(\"`Box` content\")\n                             }\n                             UnsafePtr(..) => {\n                                 format!(\"dereference of raw pointer\")\n                             }\n                             BorrowedPtr(..) => {\n-                                format!(\"borrowed content\")\n+                                match self.note {\n+                                    NoteIndex => format!(\"indexed content\"),\n+                                    _ => format!(\"borrowed content\"),\n+                                }\n                             }\n                         }\n                     }\n@@ -1525,12 +1528,9 @@ impl<'tcx> cmt_<'tcx> {\n pub fn ptr_sigil(ptr: PointerKind) -> &'static str {\n     match ptr {\n         Unique => \"Box\",\n-        BorrowedPtr(ty::ImmBorrow, _) |\n-        Implicit(ty::ImmBorrow, _) => \"&\",\n-        BorrowedPtr(ty::MutBorrow, _) |\n-        Implicit(ty::MutBorrow, _) => \"&mut\",\n-        BorrowedPtr(ty::UniqueImmBorrow, _) |\n-        Implicit(ty::UniqueImmBorrow, _) => \"&unique\",\n+        BorrowedPtr(ty::ImmBorrow, _) => \"&\",\n+        BorrowedPtr(ty::MutBorrow, _) => \"&mut\",\n+        BorrowedPtr(ty::UniqueImmBorrow, _) => \"&unique\",\n         UnsafePtr(_) => \"*\",\n     }\n }"}, {"sha": "c6b1d94e597c3794f63890148e1f9a768efd56f0", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 25, "deletions": 6, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/6de4ec679d7179251bef205427d52d093c40a787/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6de4ec679d7179251bef205427d52d093c40a787/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=6de4ec679d7179251bef205427d52d093c40a787", "patch": "@@ -137,17 +137,30 @@ impl<'tcx> ProjectionTyCandidateSet<'tcx> {\n     fn push_candidate(&mut self, candidate: ProjectionTyCandidate<'tcx>) -> bool {\n         use self::ProjectionTyCandidateSet::*;\n         use self::ProjectionTyCandidate::*;\n+\n+        // This wacky variable is just used to try and\n+        // make code readable and avoid confusing paths.\n+        // It is assigned a \"value\" of `()` only on those\n+        // paths in which we wish to convert `*self` to\n+        // ambiguous (and return false, because the candidate\n+        // was not used). On other paths, it is not assigned,\n+        // and hence if those paths *could* reach the code that\n+        // comes after the match, this fn would not compile.\n+        let convert_to_ambigious;\n+\n         match self {\n             None => {\n                 *self = Single(candidate);\n-                true\n+                return true;\n             }\n+\n             Single(current) => {\n                 // Duplicates can happen inside ParamEnv. In the case, we\n                 // perform a lazy deduplication.\n                 if current == &candidate {\n                     return false;\n                 }\n+\n                 // Prefer where-clauses. As in select, if there are multiple\n                 // candidates, we prefer where-clause candidates over impls.  This\n                 // may seem a bit surprising, since impls are the source of\n@@ -156,17 +169,23 @@ impl<'tcx> ProjectionTyCandidateSet<'tcx> {\n                 // clauses are the safer choice. See the comment on\n                 // `select::SelectionCandidate` and #21974 for more details.\n                 match (current, candidate) {\n-                    (ParamEnv(..), ParamEnv(..)) => { *self = Ambiguous; }\n-                    (ParamEnv(..), _) => {}\n+                    (ParamEnv(..), ParamEnv(..)) => convert_to_ambigious = (),\n+                    (ParamEnv(..), _) => return false,\n                     (_, ParamEnv(..)) => { unreachable!(); }\n-                    (_, _) => { *self = Ambiguous; }\n+                    (_, _) => convert_to_ambigious = (),\n                 }\n-                false\n             }\n+\n             Ambiguous | Error(..) => {\n-                false\n+                return false;\n             }\n         }\n+\n+        // We only ever get here when we moved from a single candidate\n+        // to ambiguous.\n+        let () = convert_to_ambigious;\n+        *self = Ambiguous;\n+        false\n     }\n }\n "}, {"sha": "fa9bb57275abdadd9164729bf7e082ee27790b61", "filename": "src/librustc_borrowck/borrowck/gather_loans/gather_moves.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6de4ec679d7179251bef205427d52d093c40a787/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6de4ec679d7179251bef205427d52d093c40a787/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs?ref=6de4ec679d7179251bef205427d52d093c40a787", "patch": "@@ -180,7 +180,6 @@ fn check_and_get_illegal_move_origin<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n                                                -> Option<mc::cmt_<'tcx>> {\n     match cmt.cat {\n         Categorization::Deref(_, mc::BorrowedPtr(..)) |\n-        Categorization::Deref(_, mc::Implicit(..)) |\n         Categorization::Deref(_, mc::UnsafePtr(..)) |\n         Categorization::StaticItem => {\n             Some(cmt.clone())"}, {"sha": "323e0997e3e4732c2d81ffafce9d8033effcb6b4", "filename": "src/librustc_borrowck/borrowck/gather_loans/lifetime.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6de4ec679d7179251bef205427d52d093c40a787/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Flifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6de4ec679d7179251bef205427d52d093c40a787/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Flifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Flifetime.rs?ref=6de4ec679d7179251bef205427d52d093c40a787", "patch": "@@ -74,7 +74,6 @@ impl<'a, 'tcx> GuaranteeLifetimeContext<'a, 'tcx> {\n             Categorization::Local(..) |                     // L-Local\n             Categorization::Upvar(..) |\n             Categorization::Deref(_, mc::BorrowedPtr(..)) | // L-Deref-Borrowed\n-            Categorization::Deref(_, mc::Implicit(..)) |\n             Categorization::Deref(_, mc::UnsafePtr(..)) => {\n                 self.check_scope(self.scope(cmt))\n             }\n@@ -122,8 +121,7 @@ impl<'a, 'tcx> GuaranteeLifetimeContext<'a, 'tcx> {\n             Categorization::Deref(_, mc::UnsafePtr(..)) => {\n                 self.bccx.tcx.types.re_static\n             }\n-            Categorization::Deref(_, mc::BorrowedPtr(_, r)) |\n-            Categorization::Deref(_, mc::Implicit(_, r)) => {\n+            Categorization::Deref(_, mc::BorrowedPtr(_, r)) => {\n                 r\n             }\n             Categorization::Downcast(ref cmt, _) |"}, {"sha": "18026a14259ded975c73512e48f7fdb634cc91dc", "filename": "src/librustc_borrowck/borrowck/gather_loans/move_error.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6de4ec679d7179251bef205427d52d093c40a787/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6de4ec679d7179251bef205427d52d093c40a787/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs?ref=6de4ec679d7179251bef205427d52d093c40a787", "patch": "@@ -140,7 +140,6 @@ fn report_cannot_move_out_of<'a, 'tcx>(bccx: &'a BorrowckCtxt<'a, 'tcx>,\n                                        -> DiagnosticBuilder<'a> {\n     match move_from.cat {\n         Categorization::Deref(_, mc::BorrowedPtr(..)) |\n-        Categorization::Deref(_, mc::Implicit(..)) |\n         Categorization::Deref(_, mc::UnsafePtr(..)) |\n         Categorization::StaticItem => {\n             bccx.cannot_move_out_of("}, {"sha": "e332f68327546ac1b8684cd1039a4a37ec8c5355", "filename": "src/librustc_borrowck/borrowck/gather_loans/restrictions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6de4ec679d7179251bef205427d52d093c40a787/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6de4ec679d7179251bef205427d52d093c40a787/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Frestrictions.rs?ref=6de4ec679d7179251bef205427d52d093c40a787", "patch": "@@ -149,7 +149,7 @@ impl<'a, 'tcx> RestrictionsContext<'a, 'tcx> {\n                         let result = self.restrict(&cmt_base);\n                         self.extend(result, &cmt, LpDeref(pk))\n                     }\n-                    mc::Implicit(bk, lt) | mc::BorrowedPtr(bk, lt) => {\n+                    mc::BorrowedPtr(bk, lt) => {\n                         // R-Deref-[Mut-]Borrowed\n                         if !self.bccx.is_subregion_of(self.loan_region, lt) {\n                             self.bccx.report("}, {"sha": "f0f920966dae82d34ba32a4d0e12b4dba75af184", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6de4ec679d7179251bef205427d52d093c40a787/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6de4ec679d7179251bef205427d52d093c40a787/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=6de4ec679d7179251bef205427d52d093c40a787", "patch": "@@ -234,6 +234,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     .borrow_mut()\n                     .pat_binding_modes_mut()\n                     .insert(pat.hir_id, bm);\n+                debug!(\"check_pat_walk: pat.hir_id={:?} bm={:?}\", pat.hir_id, bm);\n                 let typ = self.local_ty(pat.span, pat.id);\n                 match bm {\n                     ty::BindByReference(mutbl) => {"}, {"sha": "f6fcf2fcd48253c2c1cf2534f59feb5dd5f2cbac", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6de4ec679d7179251bef205427d52d093c40a787/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6de4ec679d7179251bef205427d52d093c40a787/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=6de4ec679d7179251bef205427d52d093c40a787", "patch": "@@ -1111,7 +1111,6 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n                    borrow_kind,\n                    borrow_cmt);\n             match borrow_cmt_cat {\n-                Categorization::Deref(ref_cmt, mc::Implicit(ref_kind, ref_region)) |\n                 Categorization::Deref(ref_cmt, mc::BorrowedPtr(ref_kind, ref_region)) => {\n                     match self.link_reborrowed_region(span,\n                                                       borrow_region, borrow_kind,"}, {"sha": "cfb9c2a50620e3c5e1e8b514dcaa9e1ae2c84e55", "filename": "src/librustc_typeck/check/upvar.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/6de4ec679d7179251bef205427d52d093c40a787/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6de4ec679d7179251bef205427d52d093c40a787/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs?ref=6de4ec679d7179251bef205427d52d093c40a787", "patch": "@@ -332,8 +332,7 @@ impl<'a, 'gcx, 'tcx> InferBorrowKind<'a, 'gcx, 'tcx> {\n             guarantor.cat\n         );\n         match guarantor.cat {\n-            Categorization::Deref(_, mc::BorrowedPtr(..)) |\n-            Categorization::Deref(_, mc::Implicit(..)) => {\n+            Categorization::Deref(_, mc::BorrowedPtr(..)) => {\n                 debug!(\n                     \"adjust_upvar_borrow_kind_for_consume: found deref with note {:?}\",\n                     cmt.note\n@@ -371,7 +370,7 @@ impl<'a, 'gcx, 'tcx> InferBorrowKind<'a, 'gcx, 'tcx> {\n                             var_name(tcx, upvar_id.var_id),\n                         );\n                     }\n-                    mc::NoteNone => {}\n+                    mc::NoteIndex | mc::NoteNone => {}\n                 }\n             }\n             _ => {}\n@@ -393,8 +392,7 @@ impl<'a, 'gcx, 'tcx> InferBorrowKind<'a, 'gcx, 'tcx> {\n                 self.adjust_upvar_borrow_kind_for_mut(&base);\n             }\n \n-            Categorization::Deref(base, mc::BorrowedPtr(..)) |\n-            Categorization::Deref(base, mc::Implicit(..)) => {\n+            Categorization::Deref(base, mc::BorrowedPtr(..)) => {\n                 if !self.try_adjust_upvar_deref(cmt, ty::MutBorrow) {\n                     // assignment to deref of an `&mut`\n                     // borrowed pointer implies that the\n@@ -426,8 +424,7 @@ impl<'a, 'gcx, 'tcx> InferBorrowKind<'a, 'gcx, 'tcx> {\n                 self.adjust_upvar_borrow_kind_for_unique(&base);\n             }\n \n-            Categorization::Deref(base, mc::BorrowedPtr(..)) |\n-            Categorization::Deref(base, mc::Implicit(..)) => {\n+            Categorization::Deref(base, mc::BorrowedPtr(..)) => {\n                 if !self.try_adjust_upvar_deref(cmt, ty::UniqueImmBorrow) {\n                     // for a borrowed pointer to be unique, its\n                     // base must be unique\n@@ -487,7 +484,7 @@ impl<'a, 'gcx, 'tcx> InferBorrowKind<'a, 'gcx, 'tcx> {\n \n                 true\n             }\n-            mc::NoteNone => false,\n+            mc::NoteIndex | mc::NoteNone => false,\n         }\n     }\n "}, {"sha": "1ddca21320211857b61312294073fa5fad0e5a26", "filename": "src/test/ui/borrowck/issue-51117.nll.stderr", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/6de4ec679d7179251bef205427d52d093c40a787/src%2Ftest%2Fui%2Fborrowck%2Fissue-51117.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6de4ec679d7179251bef205427d52d093c40a787/src%2Ftest%2Fui%2Fborrowck%2Fissue-51117.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fissue-51117.nll.stderr?ref=6de4ec679d7179251bef205427d52d093c40a787", "patch": "@@ -0,0 +1,13 @@\n+error[E0499]: cannot borrow `*bar` as mutable more than once at a time\n+  --> $DIR/issue-51117.rs:20:13\n+   |\n+LL |         Some(baz) => {\n+   |              --- first mutable borrow occurs here\n+LL |             bar.take(); //~ ERROR cannot borrow\n+   |             ^^^ second mutable borrow occurs here\n+LL |             drop(baz);\n+   |                  --- borrow later used here\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0499`."}, {"sha": "0a1e672b577611e93fc42131b71941443e0c68e9", "filename": "src/test/ui/borrowck/issue-51117.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/6de4ec679d7179251bef205427d52d093c40a787/src%2Ftest%2Fui%2Fborrowck%2Fissue-51117.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6de4ec679d7179251bef205427d52d093c40a787/src%2Ftest%2Fui%2Fborrowck%2Fissue-51117.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fissue-51117.rs?ref=6de4ec679d7179251bef205427d52d093c40a787", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Regression test for #51117 in borrowck interaction with match\n+// default bindings. The borrow of `*bar` created by `baz` was failing\n+// to register as a conflict with `bar.take()`.\n+\n+fn main() {\n+    let mut foo = Some(\"foo\".to_string());\n+    let bar = &mut foo;\n+    match bar {\n+        Some(baz) => {\n+            bar.take(); //~ ERROR cannot borrow\n+            drop(baz);\n+        },\n+        None => unreachable!(),\n+    }\n+}"}, {"sha": "cb434f9b322fe9c9c784621becad43086ef525ac", "filename": "src/test/ui/borrowck/issue-51117.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6de4ec679d7179251bef205427d52d093c40a787/src%2Ftest%2Fui%2Fborrowck%2Fissue-51117.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6de4ec679d7179251bef205427d52d093c40a787/src%2Ftest%2Fui%2Fborrowck%2Fissue-51117.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fissue-51117.stderr?ref=6de4ec679d7179251bef205427d52d093c40a787", "patch": "@@ -0,0 +1,14 @@\n+error[E0499]: cannot borrow `*bar` as mutable more than once at a time\n+  --> $DIR/issue-51117.rs:20:13\n+   |\n+LL |         Some(baz) => {\n+   |              --- first mutable borrow occurs here\n+LL |             bar.take(); //~ ERROR cannot borrow\n+   |             ^^^ second mutable borrow occurs here\n+...\n+LL |     }\n+   |     - first borrow ends here\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0499`."}]}