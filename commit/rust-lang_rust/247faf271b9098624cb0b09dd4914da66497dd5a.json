{"sha": "247faf271b9098624cb0b09dd4914da66497dd5a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI0N2ZhZjI3MWI5MDk4NjI0Y2IwYjA5ZGQ0OTE0ZGE2NjQ5N2RkNWE=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-05-29T12:14:16Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-05-29T12:14:16Z"}, "message": "Merge #9027\n\n9027: feat: Attribute completion is context aware r=Veykril a=Veykril\n\nThis splits off the `lint` and `derive` completions into their own submodules of `attribute`.\r\n\r\nThe idea is to create a lazy global hashmap that maps `SyntaxKind` to attribute names(`&[&str]`) in which we index with the syntax kind of the \"thing\" we are attributing giving us the attributes back that are valid for this kind. Then we use this name to do a binary search on the attribute list to fetch and build the corresponding completion item.\r\n\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>", "tree": {"sha": "b327bd6ab1a67f3655a81f37547af05c2ceaef2b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b327bd6ab1a67f3655a81f37547af05c2ceaef2b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/247faf271b9098624cb0b09dd4914da66497dd5a", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgsjAYCRBK7hj4Ov3rIwAAqZUIAG0X8d8D/uuwfN5LXcBKfcgc\n9pX5J1qGi1k9x1gL6RrC4PAFoSuRtkmIyfrVeTImTzosSHbeK9zsphvdSINGxPsZ\nTsX2+iYRXIkt6SZGrQp+Fr8F7ngWDmCo25GKi+bPTYFd544e7r7Qug4Let1ci5Gg\nBdT9zQvLbd7UQE4VO1bqZOOJ7ER63Y1XmZGmOazoqBWfDg4UNdsx4olUsIB8upOR\nQKVA94Djr5t1ZHLVCY0GRlQERKnhG0P2R31jEYz67qKMdg2451Nmp0jMXsTHIZ4r\nuzuPN0ZZRI7JanRrGDpvNd0dA7AUZryc8zVMJJTIeTimfusXXV+IqqNSl9IgT1s=\n=gfkp\n-----END PGP SIGNATURE-----\n", "payload": "tree b327bd6ab1a67f3655a81f37547af05c2ceaef2b\nparent 7869b01b702d1f12acb03ac131b6eb90ad82e9bb\nparent c9f0f47bbba3d02a6389af14aaf1c3d1d088d191\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1622290456 +0000\ncommitter GitHub <noreply@github.com> 1622290456 +0000\n\nMerge #9027\n\n9027: feat: Attribute completion is context aware r=Veykril a=Veykril\n\nThis splits off the `lint` and `derive` completions into their own submodules of `attribute`.\r\n\r\nThe idea is to create a lazy global hashmap that maps `SyntaxKind` to attribute names(`&[&str]`) in which we index with the syntax kind of the \"thing\" we are attributing giving us the attributes back that are valid for this kind. Then we use this name to do a binary search on the attribute list to fetch and build the corresponding completion item.\r\n\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/247faf271b9098624cb0b09dd4914da66497dd5a", "html_url": "https://github.com/rust-lang/rust/commit/247faf271b9098624cb0b09dd4914da66497dd5a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/247faf271b9098624cb0b09dd4914da66497dd5a/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7869b01b702d1f12acb03ac131b6eb90ad82e9bb", "url": "https://api.github.com/repos/rust-lang/rust/commits/7869b01b702d1f12acb03ac131b6eb90ad82e9bb", "html_url": "https://github.com/rust-lang/rust/commit/7869b01b702d1f12acb03ac131b6eb90ad82e9bb"}, {"sha": "c9f0f47bbba3d02a6389af14aaf1c3d1d088d191", "url": "https://api.github.com/repos/rust-lang/rust/commits/c9f0f47bbba3d02a6389af14aaf1c3d1d088d191", "html_url": "https://github.com/rust-lang/rust/commit/c9f0f47bbba3d02a6389af14aaf1c3d1d088d191"}], "stats": {"total": 1219, "additions": 860, "deletions": 359}, "files": [{"sha": "192f0efc2a8836c90f1f90d3f6dde552063aa0ec", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/247faf271b9098624cb0b09dd4914da66497dd5a/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/247faf271b9098624cb0b09dd4914da66497dd5a/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=247faf271b9098624cb0b09dd4914da66497dd5a", "patch": "@@ -647,6 +647,7 @@ dependencies = [\n  \"ide_db\",\n  \"itertools\",\n  \"log\",\n+ \"once_cell\",\n  \"profile\",\n  \"rustc-hash\",\n  \"stdx\","}, {"sha": "ba81c9e04ab5f264ff2df4138850e804947a80e9", "filename": "crates/ide_completion/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/247faf271b9098624cb0b09dd4914da66497dd5a/crates%2Fide_completion%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/247faf271b9098624cb0b09dd4914da66497dd5a/crates%2Fide_completion%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2FCargo.toml?ref=247faf271b9098624cb0b09dd4914da66497dd5a", "patch": "@@ -15,6 +15,7 @@ itertools = \"0.10.0\"\n log = \"0.4.8\"\n rustc-hash = \"1.1.0\"\n either = \"1.6.1\"\n+once_cell = \"1.7\"\n \n stdx = { path = \"../stdx\", version = \"0.0.0\" }\n syntax = { path = \"../syntax\", version = \"0.0.0\" }"}, {"sha": "610fec65a74627219b3fb4e08bfdc3c246038a47", "filename": "crates/ide_completion/src/completions/attribute.rs", "status": "modified", "additions": 555, "deletions": 359, "changes": 914, "blob_url": "https://github.com/rust-lang/rust/blob/247faf271b9098624cb0b09dd4914da66497dd5a/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fattribute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/247faf271b9098624cb0b09dd4914da66497dd5a/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fattribute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fattribute.rs?ref=247faf271b9098624cb0b09dd4914da66497dd5a", "patch": "@@ -3,9 +3,11 @@\n //! This module uses a bit of static metadata to provide completions\n //! for built-in attributes.\n \n-use itertools::Itertools;\n-use rustc_hash::FxHashSet;\n-use syntax::{ast, AstNode, T};\n+use std::mem;\n+\n+use once_cell::sync::Lazy;\n+use rustc_hash::{FxHashMap, FxHashSet};\n+use syntax::{ast, AstNode, NodeOrToken, SyntaxKind, T};\n \n use crate::{\n     context::CompletionContext,\n@@ -14,33 +16,40 @@ use crate::{\n     Completions,\n };\n \n-pub(crate) fn complete_attribute(acc: &mut Completions, ctx: &CompletionContext) -> Option<()> {\n-    if ctx.mod_declaration_under_caret.is_some() {\n-        return None;\n-    }\n+mod derive;\n+mod lint;\n+pub(crate) use self::lint::LintCompletion;\n \n+pub(crate) fn complete_attribute(acc: &mut Completions, ctx: &CompletionContext) -> Option<()> {\n     let attribute = ctx.attribute_under_caret.as_ref()?;\n-    match (attribute.path(), attribute.token_tree()) {\n-        (Some(path), Some(token_tree)) => {\n-            let path = path.syntax().text();\n-            if path == \"derive\" {\n-                complete_derive(acc, ctx, token_tree)\n-            } else if path == \"feature\" {\n-                complete_lint(acc, ctx, token_tree, FEATURES)\n-            } else if path == \"allow\" || path == \"warn\" || path == \"deny\" || path == \"forbid\" {\n-                complete_lint(acc, ctx, token_tree.clone(), DEFAULT_LINT_COMPLETIONS);\n-                complete_lint(acc, ctx, token_tree, CLIPPY_LINTS);\n+    match (attribute.path().and_then(|p| p.as_single_name_ref()), attribute.token_tree()) {\n+        (Some(path), Some(token_tree)) => match path.text().as_str() {\n+            \"derive\" => derive::complete_derive(acc, ctx, token_tree),\n+            \"feature\" => lint::complete_lint(acc, ctx, token_tree, FEATURES),\n+            \"allow\" | \"warn\" | \"deny\" | \"forbid\" => {\n+                lint::complete_lint(acc, ctx, token_tree.clone(), lint::DEFAULT_LINT_COMPLETIONS);\n+                lint::complete_lint(acc, ctx, token_tree, CLIPPY_LINTS);\n             }\n-        }\n-        (_, Some(_token_tree)) => {}\n-        _ => complete_attribute_start(acc, ctx, attribute),\n+            _ => (),\n+        },\n+        (None, Some(_)) => (),\n+        _ => complete_new_attribute(acc, ctx, attribute),\n     }\n     Some(())\n }\n \n-fn complete_attribute_start(acc: &mut Completions, ctx: &CompletionContext, attribute: &ast::Attr) {\n+fn complete_new_attribute(acc: &mut Completions, ctx: &CompletionContext, attribute: &ast::Attr) {\n+    let attribute_annotated_item_kind = attribute.syntax().parent().map(|it| it.kind());\n+    let attributes = attribute_annotated_item_kind.and_then(|kind| {\n+        if ast::Expr::can_cast(kind) {\n+            Some(EXPR_ATTRIBUTES)\n+        } else {\n+            KIND_TO_ATTRIBUTES.get(&kind).copied()\n+        }\n+    });\n     let is_inner = attribute.kind() == ast::AttrKind::Inner;\n-    for attr_completion in ATTRIBUTES.iter().filter(|compl| is_inner || !compl.prefer_inner) {\n+\n+    let add_completion = |attr_completion: &AttrCompletion| {\n         let mut item = CompletionItem::new(\n             CompletionKind::Attribute,\n             ctx.source_range(),\n@@ -56,9 +65,19 @@ fn complete_attribute_start(acc: &mut Completions, ctx: &CompletionContext, attr\n             item.insert_snippet(cap, snippet);\n         }\n \n-        if attribute.kind() == ast::AttrKind::Inner || !attr_completion.prefer_inner {\n+        if is_inner || !attr_completion.prefer_inner {\n             acc.add(item.build());\n         }\n+    };\n+\n+    match attributes {\n+        Some(applicable) => applicable\n+            .iter()\n+            .flat_map(|name| ATTRIBUTES.binary_search_by(|attr| attr.key().cmp(name)).ok())\n+            .flat_map(|idx| ATTRIBUTES.get(idx))\n+            .for_each(add_completion),\n+        None if is_inner => ATTRIBUTES.iter().for_each(add_completion),\n+        None => ATTRIBUTES.iter().filter(|compl| !compl.prefer_inner).for_each(add_completion),\n     }\n }\n \n@@ -70,6 +89,10 @@ struct AttrCompletion {\n }\n \n impl AttrCompletion {\n+    fn key(&self) -> &'static str {\n+        self.lookup.unwrap_or(self.label)\n+    }\n+\n     const fn prefer_inner(self) -> AttrCompletion {\n         AttrCompletion { prefer_inner: true, ..self }\n     }\n@@ -83,26 +106,119 @@ const fn attr(\n     AttrCompletion { label, lookup, snippet, prefer_inner: false }\n }\n \n+macro_rules! attrs {\n+    // attributes applicable to all items\n+    [@ { item $($tt:tt)* } {$($acc:tt)*}] => {\n+        attrs!(@ { $($tt)* } { $($acc)*, \"deprecated\", \"doc\", \"dochidden\", \"docalias\", \"must_use\", \"no_mangle\" })\n+    };\n+    // attributes applicable to all adts\n+    [@ { adt $($tt:tt)* } {$($acc:tt)*}] => {\n+        attrs!(@ { $($tt)* } { $($acc)*, \"derive\", \"repr\" })\n+    };\n+    // attributes applicable to all linkable things aka functions/statics\n+    [@ { linkable $($tt:tt)* } {$($acc:tt)*}] => {\n+        attrs!(@ { $($tt)* } { $($acc)*, \"export_name\", \"link_name\", \"link_section\" })\n+    };\n+    // error fallback for nicer error message\n+    [@ { $ty:ident $($tt:tt)* } {$($acc:tt)*}] => {\n+        compile_error!(concat!(\"unknown attr subtype \", stringify!($ty)))\n+    };\n+    // general push down accumulation\n+    [@ { $lit:literal $($tt:tt)*} {$($acc:tt)*}] => {\n+        attrs!(@ { $($tt)* } { $($acc)*, $lit })\n+    };\n+    [@ {$($tt:tt)+} {$($tt2:tt)*}] => {\n+        compile_error!(concat!(\"Unexpected input \", stringify!($($tt)+)))\n+    };\n+    // final output construction\n+    [@ {} {$($tt:tt)*}] => { &[$($tt)*] as _ };\n+    // starting matcher\n+    [$($tt:tt),*] => {\n+        attrs!(@ { $($tt)* } { \"allow\", \"cfg\", \"cfg_attr\", \"deny\", \"forbid\", \"warn\" })\n+    };\n+}\n+\n+#[rustfmt::skip]\n+static KIND_TO_ATTRIBUTES: Lazy<FxHashMap<SyntaxKind, &[&str]>> = Lazy::new(|| {\n+    use SyntaxKind::*;\n+    std::array::IntoIter::new([\n+        (\n+            SOURCE_FILE,\n+            attrs!(\n+                item,\n+                \"crate_name\", \"feature\", \"no_implicit_prelude\", \"no_main\", \"no_std\",\n+                \"recursion_limit\", \"type_length_limit\", \"windows_subsystem\"\n+            ),\n+        ),\n+        (MODULE, attrs!(item, \"no_implicit_prelude\", \"path\")),\n+        (ITEM_LIST, attrs!(item, \"no_implicit_prelude\")),\n+        (MACRO_RULES, attrs!(item, \"macro_export\", \"macro_use\")),\n+        (MACRO_DEF, attrs!(item)),\n+        (EXTERN_CRATE, attrs!(item, \"macro_use\", \"no_link\")),\n+        (USE, attrs!(item)),\n+        (TYPE_ALIAS, attrs!(item)),\n+        (STRUCT, attrs!(item, adt, \"non_exhaustive\")),\n+        (ENUM, attrs!(item, adt, \"non_exhaustive\")),\n+        (UNION, attrs!(item, adt)),\n+        (CONST, attrs!(item)),\n+        (\n+            FN,\n+            attrs!(\n+                item, linkable,\n+                \"cold\", \"ignore\", \"inline\", \"must_use\", \"panic_handler\", \"proc_macro\",\n+                \"proc_macro_derive\", \"proc_macro_attribute\", \"should_panic\", \"target_feature\",\n+                \"test\", \"track_caller\"\n+            ),\n+        ),\n+        (STATIC, attrs!(item, linkable, \"global_allocator\", \"used\")),\n+        (TRAIT, attrs!(item, \"must_use\")),\n+        (IMPL, attrs!(item, \"automatically_derived\")),\n+        (ASSOC_ITEM_LIST, attrs!(item)),\n+        (EXTERN_BLOCK, attrs!(item, \"link\")),\n+        (EXTERN_ITEM_LIST, attrs!(item, \"link\")),\n+        (MACRO_CALL, attrs!()),\n+        (SELF_PARAM, attrs!()),\n+        (PARAM, attrs!()),\n+        (RECORD_FIELD, attrs!()),\n+        (VARIANT, attrs!(\"non_exhaustive\")),\n+        (TYPE_PARAM, attrs!()),\n+        (CONST_PARAM, attrs!()),\n+        (LIFETIME_PARAM, attrs!()),\n+        (LET_STMT, attrs!()),\n+        (EXPR_STMT, attrs!()),\n+        (LITERAL, attrs!()),\n+        (RECORD_EXPR_FIELD_LIST, attrs!()),\n+        (RECORD_EXPR_FIELD, attrs!()),\n+        (MATCH_ARM_LIST, attrs!()),\n+        (MATCH_ARM, attrs!()),\n+        (IDENT_PAT, attrs!()),\n+        (RECORD_PAT_FIELD, attrs!()),\n+    ])\n+    .collect()\n+});\n+const EXPR_ATTRIBUTES: &[&str] = attrs!();\n+\n /// https://doc.rust-lang.org/reference/attributes.html#built-in-attributes-index\n+// Keep these sorted for the binary search!\n const ATTRIBUTES: &[AttrCompletion] = &[\n     attr(\"allow(\u2026)\", Some(\"allow\"), Some(\"allow(${0:lint})\")),\n     attr(\"automatically_derived\", None, None),\n-    attr(\"cfg_attr(\u2026)\", Some(\"cfg_attr\"), Some(\"cfg_attr(${1:predicate}, ${0:attr})\")),\n     attr(\"cfg(\u2026)\", Some(\"cfg\"), Some(\"cfg(${0:predicate})\")),\n+    attr(\"cfg_attr(\u2026)\", Some(\"cfg_attr\"), Some(\"cfg_attr(${1:predicate}, ${0:attr})\")),\n     attr(\"cold\", None, None),\n     attr(r#\"crate_name = \"\"\"#, Some(\"crate_name\"), Some(r#\"crate_name = \"${0:crate_name}\"\"#))\n         .prefer_inner(),\n     attr(\"deny(\u2026)\", Some(\"deny\"), Some(\"deny(${0:lint})\")),\n     attr(r#\"deprecated\"#, Some(\"deprecated\"), Some(r#\"deprecated\"#)),\n     attr(\"derive(\u2026)\", Some(\"derive\"), Some(r#\"derive(${0:Debug})\"#)),\n+    attr(r#\"doc = \"\u2026\"\"#, Some(\"doc\"), Some(r#\"doc = \"${0:docs}\"\"#)),\n+    attr(r#\"doc(alias = \"\u2026\")\"#, Some(\"docalias\"), Some(r#\"doc(alias = \"${0:docs}\")\"#)),\n+    attr(r#\"doc(hidden)\"#, Some(\"dochidden\"), Some(r#\"doc(hidden)\"#)),\n     attr(\n         r#\"export_name = \"\u2026\"\"#,\n         Some(\"export_name\"),\n         Some(r#\"export_name = \"${0:exported_symbol_name}\"\"#),\n     ),\n-    attr(r#\"doc(alias = \"\u2026\")\"#, Some(\"docalias\"), Some(r#\"doc(alias = \"${0:docs}\")\"#)),\n-    attr(r#\"doc = \"\u2026\"\"#, Some(\"doc\"), Some(r#\"doc = \"${0:docs}\"\"#)),\n-    attr(r#\"doc(hidden)\"#, Some(\"dochidden\"), Some(r#\"doc(hidden)\"#)),\n     attr(\"feature(\u2026)\", Some(\"feature\"), Some(\"feature(${0:flag})\")).prefer_inner(),\n     attr(\"forbid(\u2026)\", Some(\"forbid\"), Some(\"forbid(${0:lint})\")),\n     // FIXME: resolve through macro resolution?\n@@ -119,8 +235,8 @@ const ATTRIBUTES: &[AttrCompletion] = &[\n     attr(\"macro_export\", None, None),\n     attr(\"macro_use\", None, None),\n     attr(r#\"must_use\"#, Some(\"must_use\"), Some(r#\"must_use\"#)),\n-    attr(\"no_link\", None, None).prefer_inner(),\n     attr(\"no_implicit_prelude\", None, None).prefer_inner(),\n+    attr(\"no_link\", None, None).prefer_inner(),\n     attr(\"no_main\", None, None).prefer_inner(),\n     attr(\"no_mangle\", None, None),\n     attr(\"no_std\", None, None).prefer_inner(),\n@@ -153,412 +269,492 @@ const ATTRIBUTES: &[AttrCompletion] = &[\n     .prefer_inner(),\n ];\n \n-fn complete_derive(acc: &mut Completions, ctx: &CompletionContext, derive_input: ast::TokenTree) {\n-    if let Ok(existing_derives) = parse_comma_sep_input(derive_input) {\n-        for derive_completion in DEFAULT_DERIVE_COMPLETIONS\n-            .iter()\n-            .filter(|completion| !existing_derives.contains(completion.label))\n-        {\n-            let mut components = vec![derive_completion.label];\n-            components.extend(\n-                derive_completion\n-                    .dependencies\n-                    .iter()\n-                    .filter(|&&dependency| !existing_derives.contains(dependency)),\n-            );\n-            let lookup = components.join(\", \");\n-            let label = components.iter().rev().join(\", \");\n-            let mut item =\n-                CompletionItem::new(CompletionKind::Attribute, ctx.source_range(), label);\n-            item.lookup_by(lookup).kind(CompletionItemKind::Attribute);\n-            item.add_to(acc);\n-        }\n-\n-        for custom_derive_name in get_derive_names_in_scope(ctx).difference(&existing_derives) {\n-            let mut item = CompletionItem::new(\n-                CompletionKind::Attribute,\n-                ctx.source_range(),\n-                custom_derive_name,\n-            );\n-            item.kind(CompletionItemKind::Attribute);\n-            item.add_to(acc);\n-        }\n-    }\n-}\n-\n-fn complete_lint(\n-    acc: &mut Completions,\n-    ctx: &CompletionContext,\n-    derive_input: ast::TokenTree,\n-    lints_completions: &[LintCompletion],\n-) {\n-    if let Ok(existing_lints) = parse_comma_sep_input(derive_input) {\n-        for lint_completion in lints_completions\n-            .into_iter()\n-            .filter(|completion| !existing_lints.contains(completion.label))\n-        {\n-            let mut item = CompletionItem::new(\n-                CompletionKind::Attribute,\n-                ctx.source_range(),\n-                lint_completion.label,\n-            );\n-            item.kind(CompletionItemKind::Attribute).detail(lint_completion.description);\n-            item.add_to(acc)\n-        }\n-    }\n-}\n-\n-fn parse_comma_sep_input(derive_input: ast::TokenTree) -> Result<FxHashSet<String>, ()> {\n-    match (derive_input.left_delimiter_token(), derive_input.right_delimiter_token()) {\n-        (Some(left_paren), Some(right_paren))\n-            if left_paren.kind() == T!['('] && right_paren.kind() == T![')'] =>\n-        {\n-            let mut input_derives = FxHashSet::default();\n-            let mut current_derive = String::new();\n-            for token in derive_input\n-                .syntax()\n-                .children_with_tokens()\n-                .filter_map(|token| token.into_token())\n-                .skip_while(|token| token != &left_paren)\n-                .skip(1)\n-                .take_while(|token| token != &right_paren)\n-            {\n-                if T![,] == token.kind() {\n-                    if !current_derive.is_empty() {\n-                        input_derives.insert(current_derive);\n-                        current_derive = String::new();\n-                    }\n-                } else {\n-                    current_derive.push_str(token.text().trim());\n-                }\n-            }\n-\n+fn parse_comma_sep_input(derive_input: ast::TokenTree) -> Option<FxHashSet<String>> {\n+    let (l_paren, r_paren) = derive_input.l_paren_token().zip(derive_input.r_paren_token())?;\n+    let mut input_derives = FxHashSet::default();\n+    let mut current_derive = String::new();\n+    for token in derive_input\n+        .syntax()\n+        .children_with_tokens()\n+        .filter_map(NodeOrToken::into_token)\n+        .skip_while(|token| token != &l_paren)\n+        .skip(1)\n+        .take_while(|token| token != &r_paren)\n+    {\n+        if token.kind() == T![,] {\n             if !current_derive.is_empty() {\n-                input_derives.insert(current_derive);\n+                input_derives.insert(mem::take(&mut current_derive));\n             }\n-            Ok(input_derives)\n+        } else {\n+            current_derive.push_str(token.text().trim());\n         }\n-        _ => Err(()),\n     }\n-}\n-\n-fn get_derive_names_in_scope(ctx: &CompletionContext) -> FxHashSet<String> {\n-    let mut result = FxHashSet::default();\n-    ctx.scope.process_all_names(&mut |name, scope_def| {\n-        if let hir::ScopeDef::MacroDef(mac) = scope_def {\n-            // FIXME kind() doesn't check whether proc-macro is a derive\n-            if mac.kind() == hir::MacroKind::Derive || mac.kind() == hir::MacroKind::ProcMacro {\n-                result.insert(name.to_string());\n-            }\n-        }\n-    });\n-    result\n-}\n-\n-struct DeriveCompletion {\n-    label: &'static str,\n-    dependencies: &'static [&'static str],\n-}\n-\n-/// Standard Rust derives and the information about their dependencies\n-/// (the dependencies are needed so that the main derive don't break the compilation when added)\n-const DEFAULT_DERIVE_COMPLETIONS: &[DeriveCompletion] = &[\n-    DeriveCompletion { label: \"Clone\", dependencies: &[] },\n-    DeriveCompletion { label: \"Copy\", dependencies: &[\"Clone\"] },\n-    DeriveCompletion { label: \"Debug\", dependencies: &[] },\n-    DeriveCompletion { label: \"Default\", dependencies: &[] },\n-    DeriveCompletion { label: \"Hash\", dependencies: &[] },\n-    DeriveCompletion { label: \"PartialEq\", dependencies: &[] },\n-    DeriveCompletion { label: \"Eq\", dependencies: &[\"PartialEq\"] },\n-    DeriveCompletion { label: \"PartialOrd\", dependencies: &[\"PartialEq\"] },\n-    DeriveCompletion { label: \"Ord\", dependencies: &[\"PartialOrd\", \"Eq\", \"PartialEq\"] },\n-];\n \n-pub(crate) struct LintCompletion {\n-    pub(crate) label: &'static str,\n-    pub(crate) description: &'static str,\n+    if !current_derive.is_empty() {\n+        input_derives.insert(current_derive);\n+    }\n+    Some(input_derives)\n }\n \n-#[rustfmt::skip]\n-const DEFAULT_LINT_COMPLETIONS: &[LintCompletion] = &[\n-    LintCompletion { label: \"absolute_paths_not_starting_with_crate\", description: r#\"fully qualified paths that start with a module name instead of `crate`, `self`, or an extern crate name\"# },\n-    LintCompletion { label: \"anonymous_parameters\", description: r#\"detects anonymous parameters\"# },\n-    LintCompletion { label: \"box_pointers\", description: r#\"use of owned (Box type) heap memory\"# },\n-    LintCompletion { label: \"deprecated_in_future\", description: r#\"detects use of items that will be deprecated in a future version\"# },\n-    LintCompletion { label: \"elided_lifetimes_in_paths\", description: r#\"hidden lifetime parameters in types are deprecated\"# },\n-    LintCompletion { label: \"explicit_outlives_requirements\", description: r#\"outlives requirements can be inferred\"# },\n-    LintCompletion { label: \"indirect_structural_match\", description: r#\"pattern with const indirectly referencing non-structural-match type\"# },\n-    LintCompletion { label: \"keyword_idents\", description: r#\"detects edition keywords being used as an identifier\"# },\n-    LintCompletion { label: \"macro_use_extern_crate\", description: r#\"the `#[macro_use]` attribute is now deprecated in favor of using macros via the module system\"# },\n-    LintCompletion { label: \"meta_variable_misuse\", description: r#\"possible meta-variable misuse at macro definition\"# },\n-    LintCompletion { label: \"missing_copy_implementations\", description: r#\"detects potentially-forgotten implementations of `Copy`\"# },\n-    LintCompletion { label: \"missing_crate_level_docs\", description: r#\"detects crates with no crate-level documentation\"# },\n-    LintCompletion { label: \"missing_debug_implementations\", description: r#\"detects missing implementations of Debug\"# },\n-    LintCompletion { label: \"missing_docs\", description: r#\"detects missing documentation for public members\"# },\n-    LintCompletion { label: \"missing_doc_code_examples\", description: r#\"detects publicly-exported items without code samples in their documentation\"# },\n-    LintCompletion { label: \"non_ascii_idents\", description: r#\"detects non-ASCII identifiers\"# },\n-    LintCompletion { label: \"private_doc_tests\", description: r#\"detects code samples in docs of private items not documented by rustdoc\"# },\n-    LintCompletion { label: \"single_use_lifetimes\", description: r#\"detects lifetime parameters that are only used once\"# },\n-    LintCompletion { label: \"trivial_casts\", description: r#\"detects trivial casts which could be removed\"# },\n-    LintCompletion { label: \"trivial_numeric_casts\", description: r#\"detects trivial casts of numeric types which could be removed\"# },\n-    LintCompletion { label: \"unaligned_references\", description: r#\"detects unaligned references to fields of packed structs\"# },\n-    LintCompletion { label: \"unreachable_pub\", description: r#\"`pub` items not reachable from crate root\"# },\n-    LintCompletion { label: \"unsafe_code\", description: r#\"usage of `unsafe` code\"# },\n-    LintCompletion { label: \"unsafe_op_in_unsafe_fn\", description: r#\"unsafe operations in unsafe functions without an explicit unsafe block are deprecated\"# },\n-    LintCompletion { label: \"unstable_features\", description: r#\"enabling unstable features (deprecated. do not use)\"# },\n-    LintCompletion { label: \"unused_crate_dependencies\", description: r#\"crate dependencies that are never used\"# },\n-    LintCompletion { label: \"unused_extern_crates\", description: r#\"extern crates that are never used\"# },\n-    LintCompletion { label: \"unused_import_braces\", description: r#\"unnecessary braces around an imported item\"# },\n-    LintCompletion { label: \"unused_lifetimes\", description: r#\"detects lifetime parameters that are never used\"# },\n-    LintCompletion { label: \"unused_qualifications\", description: r#\"detects unnecessarily qualified names\"# },\n-    LintCompletion { label: \"unused_results\", description: r#\"unused result of an expression in a statement\"# },\n-    LintCompletion { label: \"variant_size_differences\", description: r#\"detects enums with widely varying variant sizes\"# },\n-    LintCompletion { label: \"array_into_iter\", description: r#\"detects calling `into_iter` on arrays\"# },\n-    LintCompletion { label: \"asm_sub_register\", description: r#\"using only a subset of a register for inline asm inputs\"# },\n-    LintCompletion { label: \"bare_trait_objects\", description: r#\"suggest using `dyn Trait` for trait objects\"# },\n-    LintCompletion { label: \"bindings_with_variant_name\", description: r#\"detects pattern bindings with the same name as one of the matched variants\"# },\n-    LintCompletion { label: \"cenum_impl_drop_cast\", description: r#\"a C-like enum implementing Drop is cast\"# },\n-    LintCompletion { label: \"clashing_extern_declarations\", description: r#\"detects when an extern fn has been declared with the same name but different types\"# },\n-    LintCompletion { label: \"coherence_leak_check\", description: r#\"distinct impls distinguished only by the leak-check code\"# },\n-    LintCompletion { label: \"confusable_idents\", description: r#\"detects visually confusable pairs between identifiers\"# },\n-    LintCompletion { label: \"dead_code\", description: r#\"detect unused, unexported items\"# },\n-    LintCompletion { label: \"deprecated\", description: r#\"detects use of deprecated items\"# },\n-    LintCompletion { label: \"ellipsis_inclusive_range_patterns\", description: r#\"`...` range patterns are deprecated\"# },\n-    LintCompletion { label: \"exported_private_dependencies\", description: r#\"public interface leaks type from a private dependency\"# },\n-    LintCompletion { label: \"illegal_floating_point_literal_pattern\", description: r#\"floating-point literals cannot be used in patterns\"# },\n-    LintCompletion { label: \"improper_ctypes\", description: r#\"proper use of libc types in foreign modules\"# },\n-    LintCompletion { label: \"improper_ctypes_definitions\", description: r#\"proper use of libc types in foreign item definitions\"# },\n-    LintCompletion { label: \"incomplete_features\", description: r#\"incomplete features that may function improperly in some or all cases\"# },\n-    LintCompletion { label: \"inline_no_sanitize\", description: r#\"detects incompatible use of `#[inline(always)]` and `#[no_sanitize(...)]`\"# },\n-    LintCompletion { label: \"intra_doc_link_resolution_failure\", description: r#\"failures in resolving intra-doc link targets\"# },\n-    LintCompletion { label: \"invalid_codeblock_attributes\", description: r#\"codeblock attribute looks a lot like a known one\"# },\n-    LintCompletion { label: \"invalid_value\", description: r#\"an invalid value is being created (such as a NULL reference)\"# },\n-    LintCompletion { label: \"irrefutable_let_patterns\", description: r#\"detects irrefutable patterns in if-let and while-let statements\"# },\n-    LintCompletion { label: \"late_bound_lifetime_arguments\", description: r#\"detects generic lifetime arguments in path segments with late bound lifetime parameters\"# },\n-    LintCompletion { label: \"mixed_script_confusables\", description: r#\"detects Unicode scripts whose mixed script confusables codepoints are solely used\"# },\n-    LintCompletion { label: \"mutable_borrow_reservation_conflict\", description: r#\"reservation of a two-phased borrow conflicts with other shared borrows\"# },\n-    LintCompletion { label: \"non_camel_case_types\", description: r#\"types, variants, traits and type parameters should have camel case names\"# },\n-    LintCompletion { label: \"non_shorthand_field_patterns\", description: r#\"using `Struct { x: x }` instead of `Struct { x }` in a pattern\"# },\n-    LintCompletion { label: \"non_snake_case\", description: r#\"variables, methods, functions, lifetime parameters and modules should have snake case names\"# },\n-    LintCompletion { label: \"non_upper_case_globals\", description: r#\"static constants should have uppercase identifiers\"# },\n-    LintCompletion { label: \"no_mangle_generic_items\", description: r#\"generic items must be mangled\"# },\n-    LintCompletion { label: \"overlapping_patterns\", description: r#\"detects overlapping patterns\"# },\n-    LintCompletion { label: \"path_statements\", description: r#\"path statements with no effect\"# },\n-    LintCompletion { label: \"private_in_public\", description: r#\"detect private items in public interfaces not caught by the old implementation\"# },\n-    LintCompletion { label: \"proc_macro_derive_resolution_fallback\", description: r#\"detects proc macro derives using inaccessible names from parent modules\"# },\n-    LintCompletion { label: \"redundant_semicolons\", description: r#\"detects unnecessary trailing semicolons\"# },\n-    LintCompletion { label: \"renamed_and_removed_lints\", description: r#\"lints that have been renamed or removed\"# },\n-    LintCompletion { label: \"safe_packed_borrows\", description: r#\"safe borrows of fields of packed structs were erroneously allowed\"# },\n-    LintCompletion { label: \"stable_features\", description: r#\"stable features found in `#[feature]` directive\"# },\n-    LintCompletion { label: \"trivial_bounds\", description: r#\"these bounds don't depend on an type parameters\"# },\n-    LintCompletion { label: \"type_alias_bounds\", description: r#\"bounds in type aliases are not enforced\"# },\n-    LintCompletion { label: \"tyvar_behind_raw_pointer\", description: r#\"raw pointer to an inference variable\"# },\n-    LintCompletion { label: \"uncommon_codepoints\", description: r#\"detects uncommon Unicode codepoints in identifiers\"# },\n-    LintCompletion { label: \"unconditional_recursion\", description: r#\"functions that cannot return without calling themselves\"# },\n-    LintCompletion { label: \"unknown_lints\", description: r#\"unrecognized lint attribute\"# },\n-    LintCompletion { label: \"unnameable_test_items\", description: r#\"detects an item that cannot be named being marked as `#[test_case]`\"# },\n-    LintCompletion { label: \"unreachable_code\", description: r#\"detects unreachable code paths\"# },\n-    LintCompletion { label: \"unreachable_patterns\", description: r#\"detects unreachable patterns\"# },\n-    LintCompletion { label: \"unstable_name_collisions\", description: r#\"detects name collision with an existing but unstable method\"# },\n-    LintCompletion { label: \"unused_allocation\", description: r#\"detects unnecessary allocations that can be eliminated\"# },\n-    LintCompletion { label: \"unused_assignments\", description: r#\"detect assignments that will never be read\"# },\n-    LintCompletion { label: \"unused_attributes\", description: r#\"detects attributes that were not used by the compiler\"# },\n-    LintCompletion { label: \"unused_braces\", description: r#\"unnecessary braces around an expression\"# },\n-    LintCompletion { label: \"unused_comparisons\", description: r#\"comparisons made useless by limits of the types involved\"# },\n-    LintCompletion { label: \"unused_doc_comments\", description: r#\"detects doc comments that aren't used by rustdoc\"# },\n-    LintCompletion { label: \"unused_features\", description: r#\"unused features found in crate-level `#[feature]` directives\"# },\n-    LintCompletion { label: \"unused_imports\", description: r#\"imports that are never used\"# },\n-    LintCompletion { label: \"unused_labels\", description: r#\"detects labels that are never used\"# },\n-    LintCompletion { label: \"unused_macros\", description: r#\"detects macros that were not used\"# },\n-    LintCompletion { label: \"unused_must_use\", description: r#\"unused result of a type flagged as `#[must_use]`\"# },\n-    LintCompletion { label: \"unused_mut\", description: r#\"detect mut variables which don't need to be mutable\"# },\n-    LintCompletion { label: \"unused_parens\", description: r#\"`if`, `match`, `while` and `return` do not need parentheses\"# },\n-    LintCompletion { label: \"unused_unsafe\", description: r#\"unnecessary use of an `unsafe` block\"# },\n-    LintCompletion { label: \"unused_variables\", description: r#\"detect variables which are not used in any way\"# },\n-    LintCompletion { label: \"warnings\", description: r#\"mass-change the level for lints which produce warnings\"# },\n-    LintCompletion { label: \"where_clauses_object_safety\", description: r#\"checks the object safety of where clauses\"# },\n-    LintCompletion { label: \"while_true\", description: r#\"suggest using `loop { }` instead of `while true { }`\"# },\n-    LintCompletion { label: \"ambiguous_associated_items\", description: r#\"ambiguous associated items\"# },\n-    LintCompletion { label: \"arithmetic_overflow\", description: r#\"arithmetic operation overflows\"# },\n-    LintCompletion { label: \"conflicting_repr_hints\", description: r#\"conflicts between `#[repr(..)]` hints that were previously accepted and used in practice\"# },\n-    LintCompletion { label: \"const_err\", description: r#\"constant evaluation detected erroneous expression\"# },\n-    LintCompletion { label: \"ill_formed_attribute_input\", description: r#\"ill-formed attribute inputs that were previously accepted and used in practice\"# },\n-    LintCompletion { label: \"incomplete_include\", description: r#\"trailing content in included file\"# },\n-    LintCompletion { label: \"invalid_type_param_default\", description: r#\"type parameter default erroneously allowed in invalid location\"# },\n-    LintCompletion { label: \"macro_expanded_macro_exports_accessed_by_absolute_paths\", description: r#\"macro-expanded `macro_export` macros from the current crate cannot be referred to by absolute paths\"# },\n-    LintCompletion { label: \"missing_fragment_specifier\", description: r#\"detects missing fragment specifiers in unused `macro_rules!` patterns\"# },\n-    LintCompletion { label: \"mutable_transmutes\", description: r#\"mutating transmuted &mut T from &T may cause undefined behavior\"# },\n-    LintCompletion { label: \"no_mangle_const_items\", description: r#\"const items will not have their symbols exported\"# },\n-    LintCompletion { label: \"order_dependent_trait_objects\", description: r#\"trait-object types were treated as different depending on marker-trait order\"# },\n-    LintCompletion { label: \"overflowing_literals\", description: r#\"literal out of range for its type\"# },\n-    LintCompletion { label: \"patterns_in_fns_without_body\", description: r#\"patterns in functions without body were erroneously allowed\"# },\n-    LintCompletion { label: \"pub_use_of_private_extern_crate\", description: r#\"detect public re-exports of private extern crates\"# },\n-    LintCompletion { label: \"soft_unstable\", description: r#\"a feature gate that doesn't break dependent crates\"# },\n-    LintCompletion { label: \"unconditional_panic\", description: r#\"operation will cause a panic at runtime\"# },\n-    LintCompletion { label: \"unknown_crate_types\", description: r#\"unknown crate type found in `#[crate_type]` directive\"# },\n-];\n-\n #[cfg(test)]\n mod tests {\n+    use super::*;\n+\n     use expect_test::{expect, Expect};\n \n     use crate::{test_utils::completion_list, CompletionKind};\n \n+    #[test]\n+    fn attributes_are_sorted() {\n+        let mut attrs = ATTRIBUTES.iter().map(|attr| attr.key());\n+        let mut prev = attrs.next().unwrap();\n+\n+        attrs.for_each(|next| {\n+            assert!(\n+                prev < next,\n+                r#\"ATTRIBUTES array is not sorted, \"{}\" should come after \"{}\"\"#,\n+                prev,\n+                next\n+            );\n+            prev = next;\n+        });\n+    }\n+\n     fn check(ra_fixture: &str, expect: Expect) {\n         let actual = completion_list(ra_fixture, CompletionKind::Attribute);\n         expect.assert_eq(&actual);\n     }\n \n     #[test]\n-    fn empty_derive_completion() {\n+    fn test_attribute_completion_inside_nested_attr() {\n+        check(r#\"#[cfg($0)]\"#, expect![[]])\n+    }\n+\n+    #[test]\n+    fn test_attribute_completion_with_existing_attr() {\n+        check(\n+            r#\"#[no_mangle] #[$0] mcall!();\"#,\n+            expect![[r#\"\n+                at allow(\u2026)\n+                at cfg(\u2026)\n+                at cfg_attr(\u2026)\n+                at deny(\u2026)\n+                at forbid(\u2026)\n+                at warn(\u2026)\n+            \"#]],\n+        )\n+    }\n+\n+    #[test]\n+    fn complete_attribute_on_source_file() {\n         check(\n-            r#\"\n-#[derive($0)]\n-struct Test {}\n-        \"#,\n+            r#\"#![$0]\"#,\n             expect![[r#\"\n-                at Clone\n-                at Clone, Copy\n-                at Debug\n-                at Default\n-                at Hash\n-                at PartialEq\n-                at PartialEq, Eq\n-                at PartialEq, PartialOrd\n-                at PartialEq, Eq, PartialOrd, Ord\n+                at allow(\u2026)\n+                at cfg(\u2026)\n+                at cfg_attr(\u2026)\n+                at deny(\u2026)\n+                at forbid(\u2026)\n+                at warn(\u2026)\n+                at deprecated\n+                at doc = \"\u2026\"\n+                at doc(hidden)\n+                at doc(alias = \"\u2026\")\n+                at must_use\n+                at no_mangle\n+                at crate_name = \"\"\n+                at feature(\u2026)\n+                at no_implicit_prelude\n+                at no_main\n+                at no_std\n+                at recursion_limit = \u2026\n+                at type_length_limit = \u2026\n+                at windows_subsystem = \"\u2026\"\n             \"#]],\n         );\n     }\n \n     #[test]\n-    fn no_completion_for_incorrect_derive() {\n+    fn complete_attribute_on_module() {\n         check(\n-            r#\"\n-#[derive{$0)]\n-struct Test {}\n-\"#,\n-            expect![[r#\"\"#]],\n-        )\n+            r#\"#[$0] mod foo;\"#,\n+            expect![[r#\"\n+            at allow(\u2026)\n+            at cfg(\u2026)\n+            at cfg_attr(\u2026)\n+            at deny(\u2026)\n+            at forbid(\u2026)\n+            at warn(\u2026)\n+            at deprecated\n+            at doc = \"\u2026\"\n+            at doc(hidden)\n+            at doc(alias = \"\u2026\")\n+            at must_use\n+            at no_mangle\n+            at path = \"\u2026\"\n+        \"#]],\n+        );\n+        check(\n+            r#\"mod foo {#![$0]}\"#,\n+            expect![[r#\"\n+                at allow(\u2026)\n+                at cfg(\u2026)\n+                at cfg_attr(\u2026)\n+                at deny(\u2026)\n+                at forbid(\u2026)\n+                at warn(\u2026)\n+                at deprecated\n+                at doc = \"\u2026\"\n+                at doc(hidden)\n+                at doc(alias = \"\u2026\")\n+                at must_use\n+                at no_mangle\n+                at no_implicit_prelude\n+            \"#]],\n+        );\n     }\n \n     #[test]\n-    fn derive_with_input_completion() {\n+    fn complete_attribute_on_macro_rules() {\n         check(\n-            r#\"\n-#[derive(serde::Serialize, PartialEq, $0)]\n-struct Test {}\n-\"#,\n+            r#\"#[$0] macro_rules! foo {}\"#,\n             expect![[r#\"\n-                at Clone\n-                at Clone, Copy\n-                at Debug\n-                at Default\n-                at Hash\n-                at Eq\n-                at PartialOrd\n-                at Eq, PartialOrd, Ord\n+                at allow(\u2026)\n+                at cfg(\u2026)\n+                at cfg_attr(\u2026)\n+                at deny(\u2026)\n+                at forbid(\u2026)\n+                at warn(\u2026)\n+                at deprecated\n+                at doc = \"\u2026\"\n+                at doc(hidden)\n+                at doc(alias = \"\u2026\")\n+                at must_use\n+                at no_mangle\n+                at macro_export\n+                at macro_use\n             \"#]],\n-        )\n+        );\n     }\n \n     #[test]\n-    fn test_attribute_completion() {\n+    fn complete_attribute_on_macro_def() {\n         check(\n-            r#\"#[$0]\"#,\n+            r#\"#[$0] macro foo {}\"#,\n             expect![[r#\"\n                 at allow(\u2026)\n-                at automatically_derived\n+                at cfg(\u2026)\n                 at cfg_attr(\u2026)\n+                at deny(\u2026)\n+                at forbid(\u2026)\n+                at warn(\u2026)\n+                at deprecated\n+                at doc = \"\u2026\"\n+                at doc(hidden)\n+                at doc(alias = \"\u2026\")\n+                at must_use\n+                at no_mangle\n+            \"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn complete_attribute_on_extern_crate() {\n+        check(\n+            r#\"#[$0] extern crate foo;\"#,\n+            expect![[r#\"\n+                at allow(\u2026)\n                 at cfg(\u2026)\n-                at cold\n+                at cfg_attr(\u2026)\n                 at deny(\u2026)\n+                at forbid(\u2026)\n+                at warn(\u2026)\n                 at deprecated\n-                at derive(\u2026)\n-                at export_name = \"\u2026\"\n+                at doc = \"\u2026\"\n+                at doc(hidden)\n                 at doc(alias = \"\u2026\")\n+                at must_use\n+                at no_mangle\n+                at macro_use\n+            \"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn complete_attribute_on_use() {\n+        check(\n+            r#\"#[$0] use foo;\"#,\n+            expect![[r#\"\n+                at allow(\u2026)\n+                at cfg(\u2026)\n+                at cfg_attr(\u2026)\n+                at deny(\u2026)\n+                at forbid(\u2026)\n+                at warn(\u2026)\n+                at deprecated\n                 at doc = \"\u2026\"\n                 at doc(hidden)\n+                at doc(alias = \"\u2026\")\n+                at must_use\n+                at no_mangle\n+            \"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn complete_attribute_on_type_alias() {\n+        check(\n+            r#\"#[$0] type foo = ();\"#,\n+            expect![[r#\"\n+                at allow(\u2026)\n+                at cfg(\u2026)\n+                at cfg_attr(\u2026)\n+                at deny(\u2026)\n                 at forbid(\u2026)\n-                at ignore = \"\u2026\"\n-                at inline\n-                at link\n-                at link_name = \"\u2026\"\n-                at link_section = \"\u2026\"\n-                at macro_export\n-                at macro_use\n+                at warn(\u2026)\n+                at deprecated\n+                at doc = \"\u2026\"\n+                at doc(hidden)\n+                at doc(alias = \"\u2026\")\n                 at must_use\n                 at no_mangle\n+            \"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn complete_attribute_on_struct() {\n+        check(\n+            r#\"#[$0] struct Foo;\"#,\n+            expect![[r#\"\n+                at allow(\u2026)\n+                at cfg(\u2026)\n+                at cfg_attr(\u2026)\n+                at deny(\u2026)\n+                at forbid(\u2026)\n+                at warn(\u2026)\n+                at deprecated\n+                at doc = \"\u2026\"\n+                at doc(hidden)\n+                at doc(alias = \"\u2026\")\n+                at must_use\n+                at no_mangle\n+                at derive(\u2026)\n+                at repr(\u2026)\n                 at non_exhaustive\n-                at path = \"\u2026\"\n-                at proc_macro\n-                at proc_macro_attribute\n-                at proc_macro_derive(\u2026)\n+            \"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn complete_attribute_on_enum() {\n+        check(\n+            r#\"#[$0] enum Foo {}\"#,\n+            expect![[r#\"\n+                at allow(\u2026)\n+                at cfg(\u2026)\n+                at cfg_attr(\u2026)\n+                at deny(\u2026)\n+                at forbid(\u2026)\n+                at warn(\u2026)\n+                at deprecated\n+                at doc = \"\u2026\"\n+                at doc(hidden)\n+                at doc(alias = \"\u2026\")\n+                at must_use\n+                at no_mangle\n+                at derive(\u2026)\n                 at repr(\u2026)\n-                at should_panic\n-                at target_feature = \"\u2026\"\n-                at test\n-                at track_caller\n-                at used\n+                at non_exhaustive\n+            \"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn complete_attribute_on_const() {\n+        check(\n+            r#\"#[$0] const FOO: () = ();\"#,\n+            expect![[r#\"\n+                at allow(\u2026)\n+                at cfg(\u2026)\n+                at cfg_attr(\u2026)\n+                at deny(\u2026)\n+                at forbid(\u2026)\n                 at warn(\u2026)\n+                at deprecated\n+                at doc = \"\u2026\"\n+                at doc(hidden)\n+                at doc(alias = \"\u2026\")\n+                at must_use\n+                at no_mangle\n             \"#]],\n-        )\n+        );\n     }\n \n     #[test]\n-    fn test_attribute_completion_inside_nested_attr() {\n-        check(r#\"#[cfg($0)]\"#, expect![[]])\n+    fn complete_attribute_on_static() {\n+        check(\n+            r#\"#[$0] static FOO: () = ()\"#,\n+            expect![[r#\"\n+                at allow(\u2026)\n+                at cfg(\u2026)\n+                at cfg_attr(\u2026)\n+                at deny(\u2026)\n+                at forbid(\u2026)\n+                at warn(\u2026)\n+                at deprecated\n+                at doc = \"\u2026\"\n+                at doc(hidden)\n+                at doc(alias = \"\u2026\")\n+                at must_use\n+                at no_mangle\n+                at export_name = \"\u2026\"\n+                at link_name = \"\u2026\"\n+                at link_section = \"\u2026\"\n+                at used\n+            \"#]],\n+        );\n     }\n \n     #[test]\n-    fn test_inner_attribute_completion() {\n+    fn complete_attribute_on_trait() {\n         check(\n-            r\"#![$0]\",\n+            r#\"#[$0] trait Foo {}\"#,\n             expect![[r#\"\n                 at allow(\u2026)\n-                at automatically_derived\n+                at cfg(\u2026)\n                 at cfg_attr(\u2026)\n+                at deny(\u2026)\n+                at forbid(\u2026)\n+                at warn(\u2026)\n+                at deprecated\n+                at doc = \"\u2026\"\n+                at doc(hidden)\n+                at doc(alias = \"\u2026\")\n+                at must_use\n+                at no_mangle\n+                at must_use\n+            \"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn complete_attribute_on_impl() {\n+        check(\n+            r#\"#[$0] impl () {}\"#,\n+            expect![[r#\"\n+                at allow(\u2026)\n                 at cfg(\u2026)\n-                at cold\n-                at crate_name = \"\"\n+                at cfg_attr(\u2026)\n                 at deny(\u2026)\n+                at forbid(\u2026)\n+                at warn(\u2026)\n                 at deprecated\n-                at derive(\u2026)\n-                at export_name = \"\u2026\"\n+                at doc = \"\u2026\"\n+                at doc(hidden)\n                 at doc(alias = \"\u2026\")\n+                at must_use\n+                at no_mangle\n+                at automatically_derived\n+            \"#]],\n+        );\n+        check(\n+            r#\"impl () {#![$0]}\"#,\n+            expect![[r#\"\n+                at allow(\u2026)\n+                at cfg(\u2026)\n+                at cfg_attr(\u2026)\n+                at deny(\u2026)\n+                at forbid(\u2026)\n+                at warn(\u2026)\n+                at deprecated\n                 at doc = \"\u2026\"\n                 at doc(hidden)\n-                at feature(\u2026)\n+                at doc(alias = \"\u2026\")\n+                at must_use\n+                at no_mangle\n+            \"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn complete_attribute_on_extern_block() {\n+        check(\n+            r#\"#[$0] extern {}\"#,\n+            expect![[r#\"\n+                at allow(\u2026)\n+                at cfg(\u2026)\n+                at cfg_attr(\u2026)\n+                at deny(\u2026)\n                 at forbid(\u2026)\n-                at global_allocator\n-                at ignore = \"\u2026\"\n-                at inline\n+                at warn(\u2026)\n+                at deprecated\n+                at doc = \"\u2026\"\n+                at doc(hidden)\n+                at doc(alias = \"\u2026\")\n+                at must_use\n+                at no_mangle\n                 at link\n-                at link_name = \"\u2026\"\n-                at link_section = \"\u2026\"\n-                at macro_export\n-                at macro_use\n+            \"#]],\n+        );\n+        check(\n+            r#\"extern {#![$0]}\"#,\n+            expect![[r#\"\n+                at allow(\u2026)\n+                at cfg(\u2026)\n+                at cfg_attr(\u2026)\n+                at deny(\u2026)\n+                at forbid(\u2026)\n+                at warn(\u2026)\n+                at deprecated\n+                at doc = \"\u2026\"\n+                at doc(hidden)\n+                at doc(alias = \"\u2026\")\n                 at must_use\n-                at no_link\n-                at no_implicit_prelude\n-                at no_main\n                 at no_mangle\n-                at no_std\n+                at link\n+            \"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn complete_attribute_on_variant() {\n+        check(\n+            r#\"enum Foo { #[$0] Bar }\"#,\n+            expect![[r#\"\n+                at allow(\u2026)\n+                at cfg(\u2026)\n+                at cfg_attr(\u2026)\n+                at deny(\u2026)\n+                at forbid(\u2026)\n+                at warn(\u2026)\n                 at non_exhaustive\n-                at panic_handler\n-                at path = \"\u2026\"\n-                at proc_macro\n-                at proc_macro_attribute\n-                at proc_macro_derive(\u2026)\n-                at recursion_limit = \u2026\n-                at repr(\u2026)\n-                at should_panic\n-                at target_feature = \"\u2026\"\n-                at test\n-                at track_caller\n-                at type_length_limit = \u2026\n-                at used\n+            \"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn complete_attribute_on_expr() {\n+        check(\n+            r#\"fn main() { #[$0] foo() }\"#,\n+            expect![[r#\"\n+                at allow(\u2026)\n+                at cfg(\u2026)\n+                at cfg_attr(\u2026)\n+                at deny(\u2026)\n+                at forbid(\u2026)\n+                at warn(\u2026)\n+            \"#]],\n+        );\n+        check(\n+            r#\"fn main() { #[$0] foo(); }\"#,\n+            expect![[r#\"\n+                at allow(\u2026)\n+                at cfg(\u2026)\n+                at cfg_attr(\u2026)\n+                at deny(\u2026)\n+                at forbid(\u2026)\n                 at warn(\u2026)\n-                at windows_subsystem = \"\u2026\"\n             \"#]],\n         );\n     }"}, {"sha": "7b0a778a226e975303b0cc03440548de17ace6b7", "filename": "crates/ide_completion/src/completions/attribute/derive.rs", "status": "added", "additions": 142, "deletions": 0, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/247faf271b9098624cb0b09dd4914da66497dd5a/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fattribute%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/247faf271b9098624cb0b09dd4914da66497dd5a/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fattribute%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fattribute%2Fderive.rs?ref=247faf271b9098624cb0b09dd4914da66497dd5a", "patch": "@@ -0,0 +1,142 @@\n+//! Completion for derives\n+use itertools::Itertools;\n+use rustc_hash::FxHashSet;\n+use syntax::ast;\n+\n+use crate::{\n+    context::CompletionContext,\n+    item::{CompletionItem, CompletionItemKind, CompletionKind},\n+    Completions,\n+};\n+\n+pub(super) fn complete_derive(\n+    acc: &mut Completions,\n+    ctx: &CompletionContext,\n+    derive_input: ast::TokenTree,\n+) {\n+    if let Some(existing_derives) = super::parse_comma_sep_input(derive_input) {\n+        for derive_completion in DEFAULT_DERIVE_COMPLETIONS\n+            .iter()\n+            .filter(|completion| !existing_derives.contains(completion.label))\n+        {\n+            let mut components = vec![derive_completion.label];\n+            components.extend(\n+                derive_completion\n+                    .dependencies\n+                    .iter()\n+                    .filter(|&&dependency| !existing_derives.contains(dependency)),\n+            );\n+            let lookup = components.join(\", \");\n+            let label = components.iter().rev().join(\", \");\n+            let mut item =\n+                CompletionItem::new(CompletionKind::Attribute, ctx.source_range(), label);\n+            item.lookup_by(lookup).kind(CompletionItemKind::Attribute);\n+            item.add_to(acc);\n+        }\n+\n+        for custom_derive_name in get_derive_names_in_scope(ctx).difference(&existing_derives) {\n+            let mut item = CompletionItem::new(\n+                CompletionKind::Attribute,\n+                ctx.source_range(),\n+                custom_derive_name,\n+            );\n+            item.kind(CompletionItemKind::Attribute);\n+            item.add_to(acc);\n+        }\n+    }\n+}\n+fn get_derive_names_in_scope(ctx: &CompletionContext) -> FxHashSet<String> {\n+    let mut result = FxHashSet::default();\n+    ctx.scope.process_all_names(&mut |name, scope_def| {\n+        if let hir::ScopeDef::MacroDef(mac) = scope_def {\n+            // FIXME kind() doesn't check whether proc-macro is a derive\n+            if mac.kind() == hir::MacroKind::Derive || mac.kind() == hir::MacroKind::ProcMacro {\n+                result.insert(name.to_string());\n+            }\n+        }\n+    });\n+    result\n+}\n+\n+struct DeriveCompletion {\n+    label: &'static str,\n+    dependencies: &'static [&'static str],\n+}\n+\n+/// Standard Rust derives and the information about their dependencies\n+/// (the dependencies are needed so that the main derive don't break the compilation when added)\n+const DEFAULT_DERIVE_COMPLETIONS: &[DeriveCompletion] = &[\n+    DeriveCompletion { label: \"Clone\", dependencies: &[] },\n+    DeriveCompletion { label: \"Copy\", dependencies: &[\"Clone\"] },\n+    DeriveCompletion { label: \"Debug\", dependencies: &[] },\n+    DeriveCompletion { label: \"Default\", dependencies: &[] },\n+    DeriveCompletion { label: \"Hash\", dependencies: &[] },\n+    DeriveCompletion { label: \"PartialEq\", dependencies: &[] },\n+    DeriveCompletion { label: \"Eq\", dependencies: &[\"PartialEq\"] },\n+    DeriveCompletion { label: \"PartialOrd\", dependencies: &[\"PartialEq\"] },\n+    DeriveCompletion { label: \"Ord\", dependencies: &[\"PartialOrd\", \"Eq\", \"PartialEq\"] },\n+];\n+\n+#[cfg(test)]\n+mod tests {\n+    use expect_test::{expect, Expect};\n+\n+    use crate::{test_utils::completion_list, CompletionKind};\n+\n+    fn check(ra_fixture: &str, expect: Expect) {\n+        let actual = completion_list(ra_fixture, CompletionKind::Attribute);\n+        expect.assert_eq(&actual);\n+    }\n+\n+    #[test]\n+    fn empty_derive_completion() {\n+        check(\n+            r#\"\n+#[derive($0)]\n+struct Test {}\n+        \"#,\n+            expect![[r#\"\n+                at Clone\n+                at Clone, Copy\n+                at Debug\n+                at Default\n+                at Hash\n+                at PartialEq\n+                at PartialEq, Eq\n+                at PartialEq, PartialOrd\n+                at PartialEq, Eq, PartialOrd, Ord\n+            \"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn no_completion_for_incorrect_derive() {\n+        check(\n+            r#\"\n+#[derive{$0)]\n+struct Test {}\n+\"#,\n+            expect![[r#\"\"#]],\n+        )\n+    }\n+\n+    #[test]\n+    fn derive_with_input_completion() {\n+        check(\n+            r#\"\n+#[derive(serde::Serialize, PartialEq, $0)]\n+struct Test {}\n+\"#,\n+            expect![[r#\"\n+                at Clone\n+                at Clone, Copy\n+                at Debug\n+                at Default\n+                at Hash\n+                at Eq\n+                at PartialOrd\n+                at Eq, PartialOrd, Ord\n+            \"#]],\n+        )\n+    }\n+}"}, {"sha": "115c6cfe0cb273ec8daa56ece04ce65c583a8d76", "filename": "crates/ide_completion/src/completions/attribute/lint.rs", "status": "added", "additions": 154, "deletions": 0, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/247faf271b9098624cb0b09dd4914da66497dd5a/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fattribute%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/247faf271b9098624cb0b09dd4914da66497dd5a/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fattribute%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fattribute%2Flint.rs?ref=247faf271b9098624cb0b09dd4914da66497dd5a", "patch": "@@ -0,0 +1,154 @@\n+//! Completion for lints\n+use syntax::ast;\n+\n+use crate::{\n+    context::CompletionContext,\n+    item::{CompletionItem, CompletionItemKind, CompletionKind},\n+    Completions,\n+};\n+\n+pub(super) fn complete_lint(\n+    acc: &mut Completions,\n+    ctx: &CompletionContext,\n+    derive_input: ast::TokenTree,\n+    lints_completions: &[LintCompletion],\n+) {\n+    if let Some(existing_lints) = super::parse_comma_sep_input(derive_input) {\n+        for lint_completion in lints_completions\n+            .into_iter()\n+            .filter(|completion| !existing_lints.contains(completion.label))\n+        {\n+            let mut item = CompletionItem::new(\n+                CompletionKind::Attribute,\n+                ctx.source_range(),\n+                lint_completion.label,\n+            );\n+            item.kind(CompletionItemKind::Attribute).detail(lint_completion.description);\n+            item.add_to(acc)\n+        }\n+    }\n+}\n+\n+pub(crate) struct LintCompletion {\n+    pub(crate) label: &'static str,\n+    pub(crate) description: &'static str,\n+}\n+\n+#[rustfmt::skip]\n+pub(super) const DEFAULT_LINT_COMPLETIONS: &[LintCompletion] = &[\n+    LintCompletion { label: \"absolute_paths_not_starting_with_crate\", description: r#\"fully qualified paths that start with a module name instead of `crate`, `self`, or an extern crate name\"# },\n+    LintCompletion { label: \"anonymous_parameters\", description: r#\"detects anonymous parameters\"# },\n+    LintCompletion { label: \"box_pointers\", description: r#\"use of owned (Box type) heap memory\"# },\n+    LintCompletion { label: \"deprecated_in_future\", description: r#\"detects use of items that will be deprecated in a future version\"# },\n+    LintCompletion { label: \"elided_lifetimes_in_paths\", description: r#\"hidden lifetime parameters in types are deprecated\"# },\n+    LintCompletion { label: \"explicit_outlives_requirements\", description: r#\"outlives requirements can be inferred\"# },\n+    LintCompletion { label: \"indirect_structural_match\", description: r#\"pattern with const indirectly referencing non-structural-match type\"# },\n+    LintCompletion { label: \"keyword_idents\", description: r#\"detects edition keywords being used as an identifier\"# },\n+    LintCompletion { label: \"macro_use_extern_crate\", description: r#\"the `#[macro_use]` attribute is now deprecated in favor of using macros via the module system\"# },\n+    LintCompletion { label: \"meta_variable_misuse\", description: r#\"possible meta-variable misuse at macro definition\"# },\n+    LintCompletion { label: \"missing_copy_implementations\", description: r#\"detects potentially-forgotten implementations of `Copy`\"# },\n+    LintCompletion { label: \"missing_crate_level_docs\", description: r#\"detects crates with no crate-level documentation\"# },\n+    LintCompletion { label: \"missing_debug_implementations\", description: r#\"detects missing implementations of Debug\"# },\n+    LintCompletion { label: \"missing_docs\", description: r#\"detects missing documentation for public members\"# },\n+    LintCompletion { label: \"missing_doc_code_examples\", description: r#\"detects publicly-exported items without code samples in their documentation\"# },\n+    LintCompletion { label: \"non_ascii_idents\", description: r#\"detects non-ASCII identifiers\"# },\n+    LintCompletion { label: \"private_doc_tests\", description: r#\"detects code samples in docs of private items not documented by rustdoc\"# },\n+    LintCompletion { label: \"single_use_lifetimes\", description: r#\"detects lifetime parameters that are only used once\"# },\n+    LintCompletion { label: \"trivial_casts\", description: r#\"detects trivial casts which could be removed\"# },\n+    LintCompletion { label: \"trivial_numeric_casts\", description: r#\"detects trivial casts of numeric types which could be removed\"# },\n+    LintCompletion { label: \"unaligned_references\", description: r#\"detects unaligned references to fields of packed structs\"# },\n+    LintCompletion { label: \"unreachable_pub\", description: r#\"`pub` items not reachable from crate root\"# },\n+    LintCompletion { label: \"unsafe_code\", description: r#\"usage of `unsafe` code\"# },\n+    LintCompletion { label: \"unsafe_op_in_unsafe_fn\", description: r#\"unsafe operations in unsafe functions without an explicit unsafe block are deprecated\"# },\n+    LintCompletion { label: \"unstable_features\", description: r#\"enabling unstable features (deprecated. do not use)\"# },\n+    LintCompletion { label: \"unused_crate_dependencies\", description: r#\"crate dependencies that are never used\"# },\n+    LintCompletion { label: \"unused_extern_crates\", description: r#\"extern crates that are never used\"# },\n+    LintCompletion { label: \"unused_import_braces\", description: r#\"unnecessary braces around an imported item\"# },\n+    LintCompletion { label: \"unused_lifetimes\", description: r#\"detects lifetime parameters that are never used\"# },\n+    LintCompletion { label: \"unused_qualifications\", description: r#\"detects unnecessarily qualified names\"# },\n+    LintCompletion { label: \"unused_results\", description: r#\"unused result of an expression in a statement\"# },\n+    LintCompletion { label: \"variant_size_differences\", description: r#\"detects enums with widely varying variant sizes\"# },\n+    LintCompletion { label: \"array_into_iter\", description: r#\"detects calling `into_iter` on arrays\"# },\n+    LintCompletion { label: \"asm_sub_register\", description: r#\"using only a subset of a register for inline asm inputs\"# },\n+    LintCompletion { label: \"bare_trait_objects\", description: r#\"suggest using `dyn Trait` for trait objects\"# },\n+    LintCompletion { label: \"bindings_with_variant_name\", description: r#\"detects pattern bindings with the same name as one of the matched variants\"# },\n+    LintCompletion { label: \"cenum_impl_drop_cast\", description: r#\"a C-like enum implementing Drop is cast\"# },\n+    LintCompletion { label: \"clashing_extern_declarations\", description: r#\"detects when an extern fn has been declared with the same name but different types\"# },\n+    LintCompletion { label: \"coherence_leak_check\", description: r#\"distinct impls distinguished only by the leak-check code\"# },\n+    LintCompletion { label: \"confusable_idents\", description: r#\"detects visually confusable pairs between identifiers\"# },\n+    LintCompletion { label: \"dead_code\", description: r#\"detect unused, unexported items\"# },\n+    LintCompletion { label: \"deprecated\", description: r#\"detects use of deprecated items\"# },\n+    LintCompletion { label: \"ellipsis_inclusive_range_patterns\", description: r#\"`...` range patterns are deprecated\"# },\n+    LintCompletion { label: \"exported_private_dependencies\", description: r#\"public interface leaks type from a private dependency\"# },\n+    LintCompletion { label: \"illegal_floating_point_literal_pattern\", description: r#\"floating-point literals cannot be used in patterns\"# },\n+    LintCompletion { label: \"improper_ctypes\", description: r#\"proper use of libc types in foreign modules\"# },\n+    LintCompletion { label: \"improper_ctypes_definitions\", description: r#\"proper use of libc types in foreign item definitions\"# },\n+    LintCompletion { label: \"incomplete_features\", description: r#\"incomplete features that may function improperly in some or all cases\"# },\n+    LintCompletion { label: \"inline_no_sanitize\", description: r#\"detects incompatible use of `#[inline(always)]` and `#[no_sanitize(...)]`\"# },\n+    LintCompletion { label: \"intra_doc_link_resolution_failure\", description: r#\"failures in resolving intra-doc link targets\"# },\n+    LintCompletion { label: \"invalid_codeblock_attributes\", description: r#\"codeblock attribute looks a lot like a known one\"# },\n+    LintCompletion { label: \"invalid_value\", description: r#\"an invalid value is being created (such as a NULL reference)\"# },\n+    LintCompletion { label: \"irrefutable_let_patterns\", description: r#\"detects irrefutable patterns in if-let and while-let statements\"# },\n+    LintCompletion { label: \"late_bound_lifetime_arguments\", description: r#\"detects generic lifetime arguments in path segments with late bound lifetime parameters\"# },\n+    LintCompletion { label: \"mixed_script_confusables\", description: r#\"detects Unicode scripts whose mixed script confusables codepoints are solely used\"# },\n+    LintCompletion { label: \"mutable_borrow_reservation_conflict\", description: r#\"reservation of a two-phased borrow conflicts with other shared borrows\"# },\n+    LintCompletion { label: \"non_camel_case_types\", description: r#\"types, variants, traits and type parameters should have camel case names\"# },\n+    LintCompletion { label: \"non_shorthand_field_patterns\", description: r#\"using `Struct { x: x }` instead of `Struct { x }` in a pattern\"# },\n+    LintCompletion { label: \"non_snake_case\", description: r#\"variables, methods, functions, lifetime parameters and modules should have snake case names\"# },\n+    LintCompletion { label: \"non_upper_case_globals\", description: r#\"static constants should have uppercase identifiers\"# },\n+    LintCompletion { label: \"no_mangle_generic_items\", description: r#\"generic items must be mangled\"# },\n+    LintCompletion { label: \"overlapping_patterns\", description: r#\"detects overlapping patterns\"# },\n+    LintCompletion { label: \"path_statements\", description: r#\"path statements with no effect\"# },\n+    LintCompletion { label: \"private_in_public\", description: r#\"detect private items in public interfaces not caught by the old implementation\"# },\n+    LintCompletion { label: \"proc_macro_derive_resolution_fallback\", description: r#\"detects proc macro derives using inaccessible names from parent modules\"# },\n+    LintCompletion { label: \"redundant_semicolons\", description: r#\"detects unnecessary trailing semicolons\"# },\n+    LintCompletion { label: \"renamed_and_removed_lints\", description: r#\"lints that have been renamed or removed\"# },\n+    LintCompletion { label: \"safe_packed_borrows\", description: r#\"safe borrows of fields of packed structs were erroneously allowed\"# },\n+    LintCompletion { label: \"stable_features\", description: r#\"stable features found in `#[feature]` directive\"# },\n+    LintCompletion { label: \"trivial_bounds\", description: r#\"these bounds don't depend on an type parameters\"# },\n+    LintCompletion { label: \"type_alias_bounds\", description: r#\"bounds in type aliases are not enforced\"# },\n+    LintCompletion { label: \"tyvar_behind_raw_pointer\", description: r#\"raw pointer to an inference variable\"# },\n+    LintCompletion { label: \"uncommon_codepoints\", description: r#\"detects uncommon Unicode codepoints in identifiers\"# },\n+    LintCompletion { label: \"unconditional_recursion\", description: r#\"functions that cannot return without calling themselves\"# },\n+    LintCompletion { label: \"unknown_lints\", description: r#\"unrecognized lint attribute\"# },\n+    LintCompletion { label: \"unnameable_test_items\", description: r#\"detects an item that cannot be named being marked as `#[test_case]`\"# },\n+    LintCompletion { label: \"unreachable_code\", description: r#\"detects unreachable code paths\"# },\n+    LintCompletion { label: \"unreachable_patterns\", description: r#\"detects unreachable patterns\"# },\n+    LintCompletion { label: \"unstable_name_collisions\", description: r#\"detects name collision with an existing but unstable method\"# },\n+    LintCompletion { label: \"unused_allocation\", description: r#\"detects unnecessary allocations that can be eliminated\"# },\n+    LintCompletion { label: \"unused_assignments\", description: r#\"detect assignments that will never be read\"# },\n+    LintCompletion { label: \"unused_attributes\", description: r#\"detects attributes that were not used by the compiler\"# },\n+    LintCompletion { label: \"unused_braces\", description: r#\"unnecessary braces around an expression\"# },\n+    LintCompletion { label: \"unused_comparisons\", description: r#\"comparisons made useless by limits of the types involved\"# },\n+    LintCompletion { label: \"unused_doc_comments\", description: r#\"detects doc comments that aren't used by rustdoc\"# },\n+    LintCompletion { label: \"unused_features\", description: r#\"unused features found in crate-level `#[feature]` directives\"# },\n+    LintCompletion { label: \"unused_imports\", description: r#\"imports that are never used\"# },\n+    LintCompletion { label: \"unused_labels\", description: r#\"detects labels that are never used\"# },\n+    LintCompletion { label: \"unused_macros\", description: r#\"detects macros that were not used\"# },\n+    LintCompletion { label: \"unused_must_use\", description: r#\"unused result of a type flagged as `#[must_use]`\"# },\n+    LintCompletion { label: \"unused_mut\", description: r#\"detect mut variables which don't need to be mutable\"# },\n+    LintCompletion { label: \"unused_parens\", description: r#\"`if`, `match`, `while` and `return` do not need parentheses\"# },\n+    LintCompletion { label: \"unused_unsafe\", description: r#\"unnecessary use of an `unsafe` block\"# },\n+    LintCompletion { label: \"unused_variables\", description: r#\"detect variables which are not used in any way\"# },\n+    LintCompletion { label: \"warnings\", description: r#\"mass-change the level for lints which produce warnings\"# },\n+    LintCompletion { label: \"where_clauses_object_safety\", description: r#\"checks the object safety of where clauses\"# },\n+    LintCompletion { label: \"while_true\", description: r#\"suggest using `loop { }` instead of `while true { }`\"# },\n+    LintCompletion { label: \"ambiguous_associated_items\", description: r#\"ambiguous associated items\"# },\n+    LintCompletion { label: \"arithmetic_overflow\", description: r#\"arithmetic operation overflows\"# },\n+    LintCompletion { label: \"conflicting_repr_hints\", description: r#\"conflicts between `#[repr(..)]` hints that were previously accepted and used in practice\"# },\n+    LintCompletion { label: \"const_err\", description: r#\"constant evaluation detected erroneous expression\"# },\n+    LintCompletion { label: \"ill_formed_attribute_input\", description: r#\"ill-formed attribute inputs that were previously accepted and used in practice\"# },\n+    LintCompletion { label: \"incomplete_include\", description: r#\"trailing content in included file\"# },\n+    LintCompletion { label: \"invalid_type_param_default\", description: r#\"type parameter default erroneously allowed in invalid location\"# },\n+    LintCompletion { label: \"macro_expanded_macro_exports_accessed_by_absolute_paths\", description: r#\"macro-expanded `macro_export` macros from the current crate cannot be referred to by absolute paths\"# },\n+    LintCompletion { label: \"missing_fragment_specifier\", description: r#\"detects missing fragment specifiers in unused `macro_rules!` patterns\"# },\n+    LintCompletion { label: \"mutable_transmutes\", description: r#\"mutating transmuted &mut T from &T may cause undefined behavior\"# },\n+    LintCompletion { label: \"no_mangle_const_items\", description: r#\"const items will not have their symbols exported\"# },\n+    LintCompletion { label: \"order_dependent_trait_objects\", description: r#\"trait-object types were treated as different depending on marker-trait order\"# },\n+    LintCompletion { label: \"overflowing_literals\", description: r#\"literal out of range for its type\"# },\n+    LintCompletion { label: \"patterns_in_fns_without_body\", description: r#\"patterns in functions without body were erroneously allowed\"# },\n+    LintCompletion { label: \"pub_use_of_private_extern_crate\", description: r#\"detect public re-exports of private extern crates\"# },\n+    LintCompletion { label: \"soft_unstable\", description: r#\"a feature gate that doesn't break dependent crates\"# },\n+    LintCompletion { label: \"unconditional_panic\", description: r#\"operation will cause a panic at runtime\"# },\n+    LintCompletion { label: \"unknown_crate_types\", description: r#\"unknown crate type found in `#[crate_type]` directive\"# },\n+];"}, {"sha": "884fe0739dba4da6787a52596f3a1a3b9dea4656", "filename": "crates/syntax/src/ast/node_ext.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/247faf271b9098624cb0b09dd4914da66497dd5a/crates%2Fsyntax%2Fsrc%2Fast%2Fnode_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/247faf271b9098624cb0b09dd4914da66497dd5a/crates%2Fsyntax%2Fsrc%2Fast%2Fnode_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast%2Fnode_ext.rs?ref=247faf271b9098624cb0b09dd4914da66497dd5a", "patch": "@@ -243,6 +243,13 @@ impl ast::Path {\n         }\n     }\n \n+    pub fn as_single_name_ref(&self) -> Option<ast::NameRef> {\n+        match self.qualifier() {\n+            Some(_) => None,\n+            None => self.segment()?.name_ref(),\n+        }\n+    }\n+\n     pub fn first_qualifier_or_self(&self) -> ast::Path {\n         successors(Some(self.clone()), ast::Path::qualifier).last().unwrap()\n     }"}]}