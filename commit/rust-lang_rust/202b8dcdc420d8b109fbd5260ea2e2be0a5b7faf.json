{"sha": "202b8dcdc420d8b109fbd5260ea2e2be0a5b7faf", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIwMmI4ZGNkYzQyMGQ4YjEwOWZiZDUyNjBlYTJlMmJlMGE1YjdmYWY=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-04-17T22:05:17Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-04-30T10:43:02Z"}, "message": "adapt to snapshot", "tree": {"sha": "e83d223715ffe4b842f3a46b274b31ee3655ec50", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e83d223715ffe4b842f3a46b274b31ee3655ec50"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/202b8dcdc420d8b109fbd5260ea2e2be0a5b7faf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/202b8dcdc420d8b109fbd5260ea2e2be0a5b7faf", "html_url": "https://github.com/rust-lang/rust/commit/202b8dcdc420d8b109fbd5260ea2e2be0a5b7faf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/202b8dcdc420d8b109fbd5260ea2e2be0a5b7faf/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c081ffbd1e845687202a975ea2e698b623e5722f", "url": "https://api.github.com/repos/rust-lang/rust/commits/c081ffbd1e845687202a975ea2e698b623e5722f", "html_url": "https://github.com/rust-lang/rust/commit/c081ffbd1e845687202a975ea2e698b623e5722f"}], "stats": {"total": 1367, "additions": 3, "deletions": 1364}, "files": [{"sha": "00ea4a9322111150357cad22aa436722b6442df5", "filename": "src/libcore/container.rs", "status": "modified", "additions": 0, "deletions": 36, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/202b8dcdc420d8b109fbd5260ea2e2be0a5b7faf/src%2Flibcore%2Fcontainer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/202b8dcdc420d8b109fbd5260ea2e2be0a5b7faf/src%2Flibcore%2Fcontainer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcontainer.rs?ref=202b8dcdc420d8b109fbd5260ea2e2be0a5b7faf", "patch": "@@ -25,42 +25,6 @@ pub trait Mutable: Container {\n     fn clear(&mut self);\n }\n \n-#[cfg(stage0)]\n-pub trait Map<K, V>: Mutable {\n-    /// Return true if the map contains a value for the specified key\n-    fn contains_key(&self, key: &K) -> bool;\n-\n-    // Visits all keys and values\n-    fn each(&self, f: &fn(&K, &V) -> bool);\n-\n-    /// Visit all keys\n-    fn each_key(&self, f: &fn(&K) -> bool);\n-\n-    /// Visit all values\n-    fn each_value(&self, f: &fn(&V) -> bool);\n-\n-    /// Iterate over the map and mutate the contained values\n-    fn mutate_values(&mut self, f: &fn(&K, &mut V) -> bool);\n-\n-    /// Return a reference to the value corresponding to the key\n-    fn find(&self, key: &K) -> Option<&'self V>;\n-\n-    /// Return a mutable reference to the value corresponding to the key\n-    fn find_mut(&mut self, key: &K) -> Option<&'self mut V>;\n-\n-    /// Insert a key-value pair into the map. An existing value for a\n-    /// key is replaced by the new value. Return true if the key did\n-    /// not already exist in the map.\n-    fn insert(&mut self, key: K, value: V) -> bool;\n-\n-    /// Remove a key-value pair from the map. Return true if the key\n-    /// was present in the map, otherwise false.\n-    fn remove(&mut self, key: &K) -> bool;\n-}\n-\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n-#[cfg(stage3)]\n pub trait Map<K, V>: Mutable {\n     /// Return true if the map contains a value for the specified key\n     fn contains_key(&self, key: &K) -> bool;"}, {"sha": "ad1994a92d2bbf2b1531509e4062f5f22293e958", "filename": "src/libcore/hashmap.rs", "status": "modified", "additions": 0, "deletions": 168, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/202b8dcdc420d8b109fbd5260ea2e2be0a5b7faf/src%2Flibcore%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/202b8dcdc420d8b109fbd5260ea2e2be0a5b7faf/src%2Flibcore%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhashmap.rs?ref=202b8dcdc420d8b109fbd5260ea2e2be0a5b7faf", "patch": "@@ -184,18 +184,6 @@ priv impl<K:Hash + Eq,V> HashMap<K, V> {\n         }\n     }\n \n-    #[cfg(stage0)]\n-    #[inline(always)]\n-    fn value_for_bucket(&self, idx: uint) -> &'self V {\n-        match self.buckets[idx] {\n-            Some(ref bkt) => &bkt.value,\n-            None => fail!(~\"HashMap::find: internal logic error\"),\n-        }\n-    }\n-\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n-    #[cfg(stage3)]\n     #[inline(always)]\n     fn value_for_bucket<'a>(&'a self, idx: uint) -> &'a V {\n         match self.buckets[idx] {\n@@ -204,18 +192,6 @@ priv impl<K:Hash + Eq,V> HashMap<K, V> {\n         }\n     }\n \n-    #[cfg(stage0)]\n-    #[inline(always)]\n-    fn mut_value_for_bucket(&mut self, idx: uint) -> &'self mut V {\n-        match self.buckets[idx] {\n-            Some(ref mut bkt) => &mut bkt.value,\n-            None => unreachable()\n-        }\n-    }\n-\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n-    #[cfg(stage3)]\n     #[inline(always)]\n     fn mut_value_for_bucket<'a>(&'a mut self, idx: uint) -> &'a mut V {\n         match self.buckets[idx] {\n@@ -329,21 +305,6 @@ impl<K:Hash + Eq,V> Map<K, V> for HashMap<K, V> {\n     }\n \n     /// Visit all key-value pairs\n-    #[cfg(stage0)]\n-    fn each(&self, blk: &fn(&'self K, &'self V) -> bool) {\n-        for uint::range(0, self.buckets.len()) |i| {\n-            for self.buckets[i].each |bucket| {\n-                if !blk(&bucket.key, &bucket.value) {\n-                    return;\n-                }\n-            }\n-        }\n-    }\n-\n-    /// Visit all key-value pairs\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n-    #[cfg(stage3)]\n     fn each<'a>(&'a self, blk: &fn(&'a K, &'a V) -> bool) {\n         for uint::range(0, self.buckets.len()) |i| {\n             for self.buckets[i].each |bucket| {\n@@ -360,15 +321,6 @@ impl<K:Hash + Eq,V> Map<K, V> for HashMap<K, V> {\n     }\n \n     /// Visit all values\n-    #[cfg(stage0)]\n-    fn each_value(&self, blk: &fn(v: &V) -> bool) {\n-        self.each(|_, v| blk(v))\n-    }\n-\n-    /// Visit all values\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n-    #[cfg(stage3)]\n     fn each_value<'a>(&'a self, blk: &fn(v: &'a V) -> bool) {\n         self.each(|_, v| blk(v))\n     }\n@@ -386,18 +338,6 @@ impl<K:Hash + Eq,V> Map<K, V> for HashMap<K, V> {\n     }\n \n     /// Return a reference to the value corresponding to the key\n-    #[cfg(stage0)]\n-    fn find(&self, k: &K) -> Option<&'self V> {\n-        match self.bucket_for_key(k) {\n-            FoundEntry(idx) => Some(self.value_for_bucket(idx)),\n-            TableFull | FoundHole(_) => None,\n-        }\n-    }\n-\n-    /// Return a reference to the value corresponding to the key\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n-    #[cfg(stage3)]\n     fn find<'a>(&'a self, k: &K) -> Option<&'a V> {\n         match self.bucket_for_key(k) {\n             FoundEntry(idx) => Some(self.value_for_bucket(idx)),\n@@ -406,21 +346,6 @@ impl<K:Hash + Eq,V> Map<K, V> for HashMap<K, V> {\n     }\n \n     /// Return a mutable reference to the value corresponding to the key\n-    #[cfg(stage0)]\n-    fn find_mut(&mut self, k: &K) -> Option<&'self mut V> {\n-        let idx = match self.bucket_for_key(k) {\n-            FoundEntry(idx) => idx,\n-            TableFull | FoundHole(_) => return None\n-        };\n-        unsafe {  // FIXME(#4903)---requires flow-sensitive borrow checker\n-            Some(::cast::transmute_mut_region(self.mut_value_for_bucket(idx)))\n-        }\n-    }\n-\n-    /// Return a mutable reference to the value corresponding to the key\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n-    #[cfg(stage3)]\n     fn find_mut<'a>(&'a mut self, k: &K) -> Option<&'a mut V> {\n         let idx = match self.bucket_for_key(k) {\n             FoundEntry(idx) => idx,\n@@ -503,40 +428,6 @@ pub impl<K: Hash + Eq, V> HashMap<K, V> {\n \n     /// Return the value corresponding to the key in the map, or insert\n     /// and return the value if it doesn't exist.\n-    #[cfg(stage0)]\n-    fn find_or_insert(&mut self, k: K, v: V) -> &'self V {\n-        if self.size >= self.resize_at {\n-            // n.b.: We could also do this after searching, so\n-            // that we do not resize if this call to insert is\n-            // simply going to update a key in place.  My sense\n-            // though is that it's worse to have to search through\n-            // buckets to find the right spot twice than to just\n-            // resize in this corner case.\n-            self.expand();\n-        }\n-\n-        let hash = k.hash_keyed(self.k0, self.k1) as uint;\n-        let idx = match self.bucket_for_key_with_hash(hash, &k) {\n-            TableFull => fail!(~\"Internal logic error\"),\n-            FoundEntry(idx) => idx,\n-            FoundHole(idx) => {\n-                self.buckets[idx] = Some(Bucket{hash: hash, key: k,\n-                                     value: v});\n-                self.size += 1;\n-                idx\n-            },\n-        };\n-\n-        unsafe { // FIXME(#4903)---requires flow-sensitive borrow checker\n-            ::cast::transmute_region(self.value_for_bucket(idx))\n-        }\n-    }\n-\n-    /// Return the value corresponding to the key in the map, or insert\n-    /// and return the value if it doesn't exist.\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n-    #[cfg(stage3)]\n     fn find_or_insert<'a>(&'a mut self, k: K, v: V) -> &'a V {\n         if self.size >= self.resize_at {\n             // n.b.: We could also do this after searching, so\n@@ -567,41 +458,6 @@ pub impl<K: Hash + Eq, V> HashMap<K, V> {\n \n     /// Return the value corresponding to the key in the map, or create,\n     /// insert, and return a new value if it doesn't exist.\n-    #[cfg(stage0)]\n-    fn find_or_insert_with(&mut self, k: K, f: &fn(&K) -> V) -> &'self V {\n-        if self.size >= self.resize_at {\n-            // n.b.: We could also do this after searching, so\n-            // that we do not resize if this call to insert is\n-            // simply going to update a key in place.  My sense\n-            // though is that it's worse to have to search through\n-            // buckets to find the right spot twice than to just\n-            // resize in this corner case.\n-            self.expand();\n-        }\n-\n-        let hash = k.hash_keyed(self.k0, self.k1) as uint;\n-        let idx = match self.bucket_for_key_with_hash(hash, &k) {\n-            TableFull => fail!(~\"Internal logic error\"),\n-            FoundEntry(idx) => idx,\n-            FoundHole(idx) => {\n-                let v = f(&k);\n-                self.buckets[idx] = Some(Bucket{hash: hash, key: k,\n-                                     value: v});\n-                self.size += 1;\n-                idx\n-            },\n-        };\n-\n-        unsafe { // FIXME(#4903)---requires flow-sensitive borrow checker\n-            ::cast::transmute_region(self.value_for_bucket(idx))\n-        }\n-    }\n-\n-    /// Return the value corresponding to the key in the map, or create,\n-    /// insert, and return a new value if it doesn't exist.\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n-    #[cfg(stage3)]\n     fn find_or_insert_with<'a>(&'a mut self, k: K, f: &fn(&K) -> V) -> &'a V {\n         if self.size >= self.resize_at {\n             // n.b.: We could also do this after searching, so\n@@ -647,17 +503,6 @@ pub impl<K: Hash + Eq, V> HashMap<K, V> {\n         }\n     }\n \n-    #[cfg(stage0)]\n-    fn get(&self, k: &K) -> &'self V {\n-        match self.find(k) {\n-            Some(v) => v,\n-            None => fail!(fmt!(\"No entry found for key: %?\", k)),\n-        }\n-    }\n-\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n-    #[cfg(stage3)]\n     fn get<'a>(&'a self, k: &K) -> &'a V {\n         match self.find(k) {\n             Some(v) => v,\n@@ -676,19 +521,6 @@ pub impl<K: Hash + Eq, V> HashMap<K, V> {\n \n     /// Return the value corresponding to the key in the map, using\n     /// equivalence\n-    #[cfg(stage0)]\n-    fn find_equiv<Q:Hash + Equiv<K>>(&self, k: &Q) -> Option<&'self V> {\n-        match self.bucket_for_key_equiv(k) {\n-            FoundEntry(idx) => Some(self.value_for_bucket(idx)),\n-            TableFull | FoundHole(_) => None,\n-        }\n-    }\n-\n-    /// Return the value corresponding to the key in the map, using\n-    /// equivalence\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n-    #[cfg(stage3)]\n     fn find_equiv<'a, Q:Hash + Equiv<K>>(&'a self, k: &Q) -> Option<&'a V> {\n         match self.bucket_for_key_equiv(k) {\n             FoundEntry(idx) => Some(self.value_for_bucket(idx)),"}, {"sha": "5abf376ddde65ccca6ab241937827e36d9df378a", "filename": "src/libcore/option.rs", "status": "modified", "additions": 0, "deletions": 104, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/202b8dcdc420d8b109fbd5260ea2e2be0a5b7faf/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/202b8dcdc420d8b109fbd5260ea2e2be0a5b7faf/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=202b8dcdc420d8b109fbd5260ea2e2be0a5b7faf", "patch": "@@ -100,16 +100,6 @@ impl<T: Copy + Add<T,T>> Add<Option<T>, Option<T>> for Option<T> {\n \n impl<T> BaseIter<T> for Option<T> {\n     /// Performs an operation on the contained value by reference\n-    #[cfg(stage0)]\n-    #[inline(always)]\n-    fn each(&self, f: &fn(x: &'self T) -> bool) {\n-        match *self { None => (), Some(ref t) => { f(t); } }\n-    }\n-\n-    /// Performs an operation on the contained value by reference\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n-    #[cfg(stage3)]\n     #[inline(always)]\n     fn each<'a>(&'a self, f: &fn(x: &'a T) -> bool) {\n         match *self { None => (), Some(ref t) => { f(t); } }\n@@ -122,15 +112,6 @@ impl<T> BaseIter<T> for Option<T> {\n }\n \n impl<T> MutableIter<T> for Option<T> {\n-    #[cfg(stage0)]\n-    #[inline(always)]\n-    fn each_mut(&mut self, f: &fn(&'self mut T) -> bool) {\n-        match *self { None => (), Some(ref mut t) => { f(t); } }\n-    }\n-\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n-    #[cfg(stage3)]\n     #[inline(always)]\n     fn each_mut<'a>(&'a mut self, f: &fn(&'a mut T) -> bool) {\n         match *self { None => (), Some(ref mut t) => { f(t); } }\n@@ -200,35 +181,12 @@ pub impl<T> Option<T> {\n      * Update an optional value by optionally running its content by reference\n      * through a function that returns an option.\n      */\n-    #[cfg(stage0)]\n-    #[inline(always)]\n-    fn chain_ref<U>(&self, f: &fn(x: &'self T) -> Option<U>) -> Option<U> {\n-        match *self { Some(ref x) => f(x), None => None }\n-    }\n-\n-    /**\n-     * Update an optional value by optionally running its content by reference\n-     * through a function that returns an option.\n-     */\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n-    #[cfg(stage3)]\n     #[inline(always)]\n     fn chain_ref<'a, U>(&'a self, f: &fn(x: &'a T) -> Option<U>) -> Option<U> {\n         match *self { Some(ref x) => f(x), None => None }\n     }\n \n     /// Maps a `some` value from one type to another by reference\n-    #[cfg(stage0)]\n-    #[inline(always)]\n-    fn map<U>(&self, f: &fn(&'self T) -> U) -> Option<U> {\n-        match *self { Some(ref x) => Some(f(x)), None => None }\n-    }\n-\n-    /// Maps a `some` value from one type to another by reference\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n-    #[cfg(stage3)]\n     #[inline(always)]\n     fn map<'a, U>(&self, f: &fn(&'a T) -> U) -> Option<U> {\n         match *self { Some(ref x) => Some(f(x)), None => None }\n@@ -242,16 +200,6 @@ pub impl<T> Option<T> {\n     }\n \n     /// Applies a function to the contained value or returns a default\n-    #[cfg(stage0)]\n-    #[inline(always)]\n-    fn map_default<U>(&self, def: U, f: &fn(&'self T) -> U) -> U {\n-        match *self { None => def, Some(ref t) => f(t) }\n-    }\n-\n-    /// Applies a function to the contained value or returns a default\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n-    #[cfg(stage3)]\n     #[inline(always)]\n     fn map_default<'a, U>(&'a self, def: U, f: &fn(&'a T) -> U) -> U {\n         match *self { None => def, Some(ref t) => f(t) }\n@@ -295,32 +243,6 @@ pub impl<T> Option<T> {\n     case explicitly.\n      */\n     #[inline(always)]\n-    #[cfg(stage0)]\n-    fn get_ref(&self) -> &'self T {\n-        match *self {\n-          Some(ref x) => x,\n-          None => fail!(~\"option::get_ref none\")\n-        }\n-    }\n-\n-    /**\n-    Gets an immutable reference to the value inside an option.\n-\n-    # Failure\n-\n-    Fails if the value equals `None`\n-\n-    # Safety note\n-\n-    In general, because this function may fail, its use is discouraged\n-    (calling `get` on `None` is akin to dereferencing a null pointer).\n-    Instead, prefer to use pattern matching and handle the `None`\n-    case explicitly.\n-     */\n-    #[inline(always)]\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n-    #[cfg(stage3)]\n     fn get_ref<'a>(&'a self) -> &'a T {\n         match *self {\n           Some(ref x) => x,\n@@ -343,32 +265,6 @@ pub impl<T> Option<T> {\n     case explicitly.\n      */\n     #[inline(always)]\n-    #[cfg(stage0)]\n-    fn get_mut_ref(&mut self) -> &'self mut T {\n-        match *self {\n-          Some(ref mut x) => x,\n-          None => fail!(~\"option::get_mut_ref none\")\n-        }\n-    }\n-\n-    /**\n-    Gets a mutable reference to the value inside an option.\n-\n-    # Failure\n-\n-    Fails if the value equals `None`\n-\n-    # Safety note\n-\n-    In general, because this function may fail, its use is discouraged\n-    (calling `get` on `None` is akin to dereferencing a null pointer).\n-    Instead, prefer to use pattern matching and handle the `None`\n-    case explicitly.\n-     */\n-    #[inline(always)]\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n-    #[cfg(stage3)]\n     fn get_mut_ref<'a>(&'a mut self) -> &'a mut T {\n         match *self {\n           Some(ref mut x) => x,"}, {"sha": "47de360f5899510abbdfefc713464c3bf1c47e4d", "filename": "src/libcore/reflect.rs", "status": "modified", "additions": 1, "deletions": 32, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/202b8dcdc420d8b109fbd5260ea2e2be0a5b7faf/src%2Flibcore%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/202b8dcdc420d8b109fbd5260ea2e2be0a5b7faf/src%2Flibcore%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Freflect.rs?ref=202b8dcdc420d8b109fbd5260ea2e2be0a5b7faf", "patch": "@@ -15,7 +15,7 @@ Runtime type reflection\n */\n \n use intrinsic::{TyDesc, TyVisitor};\n-#[cfg(not(stage0))] use intrinsic::Opaque;\n+use intrinsic::Opaque;\n use libc::c_void;\n use sys;\n use vec;\n@@ -394,17 +394,6 @@ impl<V:TyVisitor + MovePtr> TyVisitor for MovePtrAdaptor<V> {\n         true\n     }\n \n-    #[cfg(stage0)]\n-    fn visit_enter_enum(&self, n_variants: uint, sz: uint, align: uint)\n-                     -> bool {\n-        self.align(align);\n-        if ! self.inner.visit_enter_enum(n_variants, sz, align) {\n-            return false;\n-        }\n-        true\n-    }\n-\n-    #[cfg(not(stage0))]\n     fn visit_enter_enum(&self, n_variants: uint,\n                         get_disr: extern unsafe fn(ptr: *Opaque) -> int,\n                         sz: uint, align: uint)\n@@ -428,15 +417,6 @@ impl<V:TyVisitor + MovePtr> TyVisitor for MovePtrAdaptor<V> {\n         true\n     }\n \n-    #[cfg(stage0)]\n-    fn visit_enum_variant_field(&self, i: uint, inner: *TyDesc) -> bool {\n-        unsafe { self.align((*inner).align); }\n-        if ! self.inner.visit_enum_variant_field(i, inner) { return false; }\n-        unsafe { self.bump((*inner).size); }\n-        true\n-    }\n-\n-    #[cfg(not(stage0))]\n     fn visit_enum_variant_field(&self, i: uint, offset: uint, inner: *TyDesc) -> bool {\n         self.inner.push_ptr();\n         self.bump(offset);\n@@ -457,17 +437,6 @@ impl<V:TyVisitor + MovePtr> TyVisitor for MovePtrAdaptor<V> {\n         true\n     }\n \n-    #[cfg(stage0)]\n-    fn visit_leave_enum(&self, n_variants: uint, sz: uint, align: uint)\n-                     -> bool {\n-        if ! self.inner.visit_leave_enum(n_variants, sz, align) {\n-            return false;\n-        }\n-        self.bump(sz);\n-        true\n-    }\n-\n-    #[cfg(not(stage0))]\n     fn visit_leave_enum(&self, n_variants: uint,\n                         get_disr: extern unsafe fn(ptr: *Opaque) -> int,\n                         sz: uint, align: uint) -> bool {"}, {"sha": "2d6412b0cc8329a56e62b5e4c81439972df997bf", "filename": "src/libcore/repr.rs", "status": "modified", "additions": 1, "deletions": 109, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/202b8dcdc420d8b109fbd5260ea2e2be0a5b7faf/src%2Flibcore%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/202b8dcdc420d8b109fbd5260ea2e2be0a5b7faf/src%2Flibcore%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frepr.rs?ref=202b8dcdc420d8b109fbd5260ea2e2be0a5b7faf", "patch": "@@ -18,7 +18,7 @@ use cast::transmute;\n use char;\n use intrinsic;\n use intrinsic::{TyDesc, TyVisitor, visit_tydesc};\n-#[cfg(not(stage0))] use intrinsic::Opaque;\n+use intrinsic::Opaque;\n use io::{Writer, WriterUtil};\n use libc::c_void;\n use managed;\n@@ -138,14 +138,6 @@ impl Repr for char {\n \n // New implementation using reflect::MovePtr\n \n-#[cfg(stage0)]\n-enum VariantState {\n-    Degenerate,\n-    TagMatch,\n-    TagMismatch,\n-}\n-\n-#[cfg(not(stage0))]\n enum VariantState {\n     SearchingFor(int),\n     Matched,\n@@ -190,18 +182,6 @@ pub impl ReprVisitor {\n         true\n     }\n \n-    #[cfg(stage0)] #[inline(always)]\n-    fn bump(&self, sz: uint) {\n-      do self.move_ptr() |p| {\n-            ((p as uint) + sz) as *c_void\n-      };\n-    }\n-\n-    #[cfg(stage0)] #[inline(always)]\n-    fn bump_past<T>(&self) {\n-        self.bump(sys::size_of::<T>());\n-    }\n-\n     #[inline(always)]\n     fn visit_inner(&self, inner: *TyDesc) -> bool {\n         self.visit_ptr_inner(self.ptr, inner)\n@@ -467,18 +447,6 @@ impl TyVisitor for ReprVisitor {\n         true\n     }\n \n-    #[cfg(stage0)]\n-    fn visit_enter_enum(&self, n_variants: uint,\n-                        _sz: uint, _align: uint) -> bool {\n-        if n_variants == 1 {\n-            self.var_stk.push(Degenerate)\n-        } else {\n-            self.var_stk.push(TagMatch)\n-        }\n-        true\n-    }\n-\n-    #[cfg(not(stage0))]\n     fn visit_enter_enum(&self, _n_variants: uint,\n                         get_disr: extern unsafe fn(ptr: *Opaque) -> int,\n                         _sz: uint, _align: uint) -> bool {\n@@ -487,40 +455,6 @@ impl TyVisitor for ReprVisitor {\n         true\n     }\n \n-    #[cfg(stage0)]\n-    fn visit_enter_enum_variant(&self, _variant: uint,\n-                                disr_val: int,\n-                                n_fields: uint,\n-                                name: &str) -> bool {\n-        let mut write = false;\n-        match self.var_stk.pop() {\n-            Degenerate => {\n-                write = true;\n-                self.var_stk.push(Degenerate);\n-            }\n-            TagMatch | TagMismatch => {\n-                do self.get::<int>() |t| {\n-                    if disr_val == *t {\n-                        write = true;\n-                        self.var_stk.push(TagMatch);\n-                    } else {\n-                        self.var_stk.push(TagMismatch);\n-                    }\n-                };\n-                self.bump_past::<int>();\n-            }\n-        }\n-\n-        if write {\n-            self.writer.write_str(name);\n-            if n_fields > 0 {\n-                self.writer.write_char('(');\n-            }\n-        }\n-        true\n-    }\n-\n-    #[cfg(not(stage0))]\n     fn visit_enter_enum_variant(&self, _variant: uint,\n                                 disr_val: int,\n                                 n_fields: uint,\n@@ -549,23 +483,6 @@ impl TyVisitor for ReprVisitor {\n         true\n     }\n \n-    #[cfg(stage0)]\n-    fn visit_enum_variant_field(&self, i: uint, inner: *TyDesc) -> bool {\n-        match self.var_stk[vec::uniq_len(&const self.var_stk) - 1] {\n-            Degenerate | TagMatch => {\n-                if i != 0 {\n-                    self.writer.write_str(\", \");\n-                }\n-                if ! self.visit_inner(inner) {\n-                    return false;\n-                }\n-            }\n-            TagMismatch => ()\n-        }\n-        true\n-    }\n-\n-    #[cfg(not(stage0))]\n     fn visit_enum_variant_field(&self, i: uint, _offset: uint, inner: *TyDesc) -> bool {\n         match self.var_stk[vec::uniq_len(&const self.var_stk) - 1] {\n             Matched => {\n@@ -581,23 +498,6 @@ impl TyVisitor for ReprVisitor {\n         true\n     }\n \n-    #[cfg(stage0)]\n-    fn visit_leave_enum_variant(&self, _variant: uint,\n-                                _disr_val: int,\n-                                n_fields: uint,\n-                                _name: &str) -> bool {\n-        match self.var_stk[vec::uniq_len(&const self.var_stk) - 1] {\n-            Degenerate | TagMatch => {\n-                if n_fields > 0 {\n-                    self.writer.write_char(')');\n-                }\n-            }\n-            TagMismatch => ()\n-        }\n-        true\n-    }\n-\n-    #[cfg(not(stage0))]\n     fn visit_leave_enum_variant(&self, _variant: uint,\n                                 _disr_val: int,\n                                 n_fields: uint,\n@@ -613,14 +513,6 @@ impl TyVisitor for ReprVisitor {\n         true\n     }\n \n-    #[cfg(stage0)]\n-    fn visit_leave_enum(&self, _n_variants: uint,\n-                        _sz: uint, _align: uint) -> bool {\n-        self.var_stk.pop();\n-        true\n-    }\n-\n-    #[cfg(not(stage0))]\n     fn visit_leave_enum(&self, _n_variants: uint,\n                         _get_disr: extern unsafe fn(ptr: *Opaque) -> int,\n                         _sz: uint, _align: uint) -> bool {"}, {"sha": "17cc07c660d1af4d6b6fd2420c277bd849c5affd", "filename": "src/libcore/result.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/202b8dcdc420d8b109fbd5260ea2e2be0a5b7faf/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/202b8dcdc420d8b109fbd5260ea2e2be0a5b7faf/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=202b8dcdc420d8b109fbd5260ea2e2be0a5b7faf", "patch": "@@ -226,13 +226,6 @@ pub fn map_err<T:Copy,E,F:Copy>(res: &Result<T, E>, op: &fn(&E) -> F)\n }\n \n pub impl<T, E> Result<T, E> {\n-    #[cfg(stage0)]\n-    #[inline(always)]\n-    fn get_ref(&self) -> &'self T { get_ref(self) }\n-\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n-    #[cfg(stage3)]\n     #[inline(always)]\n     fn get_ref<'a>(&'a self) -> &'a T { get_ref(self) }\n "}, {"sha": "e77ec82637e4b6c8804399e951b7a61ed8d48eb1", "filename": "src/libcore/rt/mod.rs", "status": "modified", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/202b8dcdc420d8b109fbd5260ea2e2be0a5b7faf/src%2Flibcore%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/202b8dcdc420d8b109fbd5260ea2e2be0a5b7faf/src%2Flibcore%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fmod.rs?ref=202b8dcdc420d8b109fbd5260ea2e2be0a5b7faf", "patch": "@@ -49,27 +49,6 @@ mod context;\n mod thread;\n pub mod env;\n \n-#[cfg(stage0)]\n-pub fn start(main: *u8, _argc: int, _argv: *c_char, _crate_map: *u8) -> int {\n-    use self::sched::{Scheduler, Task};\n-    use self::uvio::UvEventLoop;\n-\n-    let loop_ = ~UvEventLoop::new();\n-    let mut sched = ~Scheduler::new(loop_);\n-    let main_task = ~do Task::new(&mut sched.stack_pool) {\n-        // XXX: Can't call a C function pointer from Rust yet\n-        unsafe { rust_call_nullary_fn(main) };\n-    };\n-    sched.task_queue.push_back(main_task);\n-    sched.run();\n-    return 0;\n-\n-    extern {\n-        fn rust_call_nullary_fn(f: *u8);\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n pub fn start(main: *u8, _argc: int, _argv: **c_char, _crate_map: *u8) -> int {\n     use self::sched::{Scheduler, Task};\n     use self::uvio::UvEventLoop;"}, {"sha": "fd64438c61b467db6daf1ade0757b99e2b2b0070", "filename": "src/libcore/rt/rtio.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/202b8dcdc420d8b109fbd5260ea2e2be0a5b7faf/src%2Flibcore%2Frt%2Frtio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/202b8dcdc420d8b109fbd5260ea2e2be0a5b7faf/src%2Flibcore%2Frt%2Frtio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Frtio.rs?ref=202b8dcdc420d8b109fbd5260ea2e2be0a5b7faf", "patch": "@@ -24,11 +24,6 @@ pub trait EventLoop {\n     fn run(&mut self);\n     fn callback(&mut self, ~fn());\n     /// The asynchronous I/O services. Not all event loops may provide one\n-    #[cfg(stage0)]\n-    fn io(&mut self) -> Option<&'self mut IoFactoryObject>;\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n-    #[cfg(stage3)]\n     fn io<'a>(&'a mut self) -> Option<&'a mut IoFactoryObject>;\n }\n "}, {"sha": "fba91dd7d8ab9208a66fccb8f2eafa5f5b78ff57", "filename": "src/libcore/rt/uvio.rs", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/202b8dcdc420d8b109fbd5260ea2e2be0a5b7faf/src%2Flibcore%2Frt%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/202b8dcdc420d8b109fbd5260ea2e2be0a5b7faf/src%2Flibcore%2Frt%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fuvio.rs?ref=202b8dcdc420d8b109fbd5260ea2e2be0a5b7faf", "patch": "@@ -69,14 +69,6 @@ impl EventLoop for UvEventLoop {\n         }\n     }\n \n-    #[cfg(stage0)]\n-    fn io(&mut self) -> Option<&'self mut IoFactoryObject> {\n-        Some(&mut self.uvio)\n-    }\n-\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n-    #[cfg(stage3)]\n     fn io<'a>(&'a mut self) -> Option<&'a mut IoFactoryObject> {\n         Some(&mut self.uvio)\n     }\n@@ -99,14 +91,6 @@ fn test_callback_run_once() {\n pub struct UvIoFactory(Loop);\n \n pub impl UvIoFactory {\n-    #[cfg(stage0)]\n-    fn uv_loop(&mut self) -> &'self mut Loop {\n-        match self { &UvIoFactory(ref mut ptr) => ptr }\n-    }\n-\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n-    #[cfg(stage3)]\n     fn uv_loop<'a>(&'a mut self) -> &'a mut Loop {\n         match self { &UvIoFactory(ref mut ptr) => ptr }\n     }"}, {"sha": "f0756be994432743495172cff8d72a0cd093773f", "filename": "src/libcore/trie.rs", "status": "modified", "additions": 0, "deletions": 95, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/202b8dcdc420d8b109fbd5260ea2e2be0a5b7faf/src%2Flibcore%2Ftrie.rs", "raw_url": "https://github.com/rust-lang/rust/raw/202b8dcdc420d8b109fbd5260ea2e2be0a5b7faf/src%2Flibcore%2Ftrie.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftrie.rs?ref=202b8dcdc420d8b109fbd5260ea2e2be0a5b7faf", "patch": "@@ -56,16 +56,6 @@ impl<T> Map<uint, T> for TrieMap<T> {\n \n     /// Visit all key-value pairs in order\n     #[inline(always)]\n-    #[cfg(stage0)]\n-    fn each(&self, f: &fn(&uint, &'self T) -> bool) {\n-        self.root.each(f);\n-    }\n-\n-    /// Visit all key-value pairs in order\n-    #[inline(always)]\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n-    #[cfg(stage3)]\n     fn each<'a>(&'a self, f: &fn(&uint, &'a T) -> bool) {\n         self.root.each(f);\n     }\n@@ -78,16 +68,6 @@ impl<T> Map<uint, T> for TrieMap<T> {\n \n     /// Visit all values in order\n     #[inline(always)]\n-    #[cfg(stage0)]\n-    fn each_value(&self, f: &fn(&T) -> bool) {\n-        self.each(|_, v| f(v))\n-    }\n-\n-    /// Visit all values in order\n-    #[inline(always)]\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n-    #[cfg(stage3)]\n     fn each_value<'a>(&'a self, f: &fn(&'a T) -> bool) {\n         self.each(|_, v| f(v))\n     }\n@@ -99,31 +79,6 @@ impl<T> Map<uint, T> for TrieMap<T> {\n     }\n \n     /// Return a reference to the value corresponding to the key\n-    #[cfg(stage0)]\n-    #[inline(hint)]\n-    fn find(&self, key: &uint) -> Option<&'self T> {\n-        let mut node: &'self TrieNode<T> = &self.root;\n-        let mut idx = 0;\n-        loop {\n-            match node.children[chunk(*key, idx)] {\n-              Internal(ref x) => node = &**x,\n-              External(stored, ref value) => {\n-                if stored == *key {\n-                    return Some(value)\n-                } else {\n-                    return None\n-                }\n-              }\n-              Nothing => return None\n-            }\n-            idx += 1;\n-        }\n-    }\n-\n-    /// Return a reference to the value corresponding to the key\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n-    #[cfg(stage3)]\n     #[inline(hint)]\n     fn find<'a>(&'a self, key: &uint) -> Option<&'a T> {\n         let mut node: &'a TrieNode<T> = &self.root;\n@@ -145,16 +100,6 @@ impl<T> Map<uint, T> for TrieMap<T> {\n     }\n \n     /// Return a mutable reference to the value corresponding to the key\n-    #[cfg(stage0)]\n-    #[inline(always)]\n-    fn find_mut(&mut self, key: &uint) -> Option<&'self mut T> {\n-        find_mut(&mut self.root.children[chunk(*key, 0)], *key, 1)\n-    }\n-\n-    /// Return a mutable reference to the value corresponding to the key\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n-    #[cfg(stage3)]\n     #[inline(always)]\n     fn find_mut<'a>(&'a mut self, key: &uint) -> Option<&'a mut T> {\n         find_mut(&mut self.root.children[chunk(*key, 0)], *key, 1)\n@@ -193,16 +138,6 @@ pub impl<T> TrieMap<T> {\n \n     /// Visit all key-value pairs in reverse order\n     #[inline(always)]\n-    #[cfg(stage0)]\n-    fn each_reverse(&self, f: &fn(&uint, &'self T) -> bool) {\n-        self.root.each_reverse(f);\n-    }\n-\n-    /// Visit all key-value pairs in reverse order\n-    #[inline(always)]\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n-    #[cfg(stage3)]\n     fn each_reverse<'a>(&'a self, f: &fn(&uint, &'a T) -> bool) {\n         self.root.each_reverse(f);\n     }\n@@ -298,21 +233,6 @@ impl<T> TrieNode<T> {\n }\n \n impl<T> TrieNode<T> {\n-    #[cfg(stage0)]\n-    fn each(&self, f: &fn(&uint, &'self T) -> bool) -> bool {\n-        for uint::range(0, self.children.len()) |idx| {\n-            match self.children[idx] {\n-                Internal(ref x) => if !x.each(f) { return false },\n-                External(k, ref v) => if !f(&k, v) { return false },\n-                Nothing => ()\n-            }\n-        }\n-        true\n-    }\n-\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n-    #[cfg(stage3)]\n     fn each<'a>(&'a self, f: &fn(&uint, &'a T) -> bool) -> bool {\n         for uint::range(0, self.children.len()) |idx| {\n             match self.children[idx] {\n@@ -324,21 +244,6 @@ impl<T> TrieNode<T> {\n         true\n     }\n \n-    #[cfg(stage0)]\n-    fn each_reverse(&self, f: &fn(&uint, &'self T) -> bool) -> bool {\n-        for uint::range_rev(self.children.len(), 0) |idx| {\n-            match self.children[idx - 1] {\n-                Internal(ref x) => if !x.each_reverse(f) { return false },\n-                External(k, ref v) => if !f(&k, v) { return false },\n-                Nothing => ()\n-            }\n-        }\n-        true\n-    }\n-\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n-    #[cfg(stage3)]\n     fn each_reverse<'a>(&'a self, f: &fn(&uint, &'a T) -> bool) -> bool {\n         for uint::range_rev(self.children.len(), 0) |idx| {\n             match self.children[idx - 1] {"}, {"sha": "6da22657906ddbf45d76e90cd296ec180ad39763", "filename": "src/libcore/tuple.rs", "status": "modified", "additions": 0, "deletions": 28, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/202b8dcdc420d8b109fbd5260ea2e2be0a5b7faf/src%2Flibcore%2Ftuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/202b8dcdc420d8b109fbd5260ea2e2be0a5b7faf/src%2Flibcore%2Ftuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftuple.rs?ref=202b8dcdc420d8b109fbd5260ea2e2be0a5b7faf", "patch": "@@ -56,39 +56,11 @@ impl<T:Clone,U:Clone> Clone for (T, U) {\n     }\n }\n \n-#[cfg(stage0)]\n-pub trait ImmutableTuple<T, U> {\n-    fn first_ref(&self) -> &'self T;\n-    fn second_ref(&self) -> &'self U;\n-}\n-\n-#[cfg(stage0)]\n-impl<T, U> ImmutableTuple<T, U> for (T, U) {\n-    #[inline(always)]\n-    fn first_ref(&self) -> &'self T {\n-        match *self {\n-            (ref t, _) => t,\n-        }\n-    }\n-    #[inline(always)]\n-    fn second_ref(&self) -> &'self U {\n-        match *self {\n-            (_, ref u) => u,\n-        }\n-    }\n-}\n-\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n-#[cfg(stage3)]\n pub trait ImmutableTuple<T, U> {\n     fn first_ref<'a>(&'a self) -> &'a T;\n     fn second_ref<'a>(&'a self) -> &'a U;\n }\n \n-#[cfg(stage1)]\n-#[cfg(stage2)]\n-#[cfg(stage3)]\n impl<T, U> ImmutableTuple<T, U> for (T, U) {\n     #[inline(always)]\n     fn first_ref<'a>(&'a self) -> &'a T {"}, {"sha": "de0542afc399a150f604dba47fe3e7a734fa5598", "filename": "src/libcore/unstable/lang.rs", "status": "modified", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/202b8dcdc420d8b109fbd5260ea2e2be0a5b7faf/src%2Flibcore%2Funstable%2Flang.rs", "raw_url": "https://github.com/rust-lang/rust/raw/202b8dcdc420d8b109fbd5260ea2e2be0a5b7faf/src%2Flibcore%2Funstable%2Flang.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funstable%2Flang.rs?ref=202b8dcdc420d8b109fbd5260ea2e2be0a5b7faf", "patch": "@@ -135,32 +135,6 @@ pub unsafe fn strdup_uniq(ptr: *c_uchar, len: uint) -> ~str {\n }\n \n #[lang=\"start\"]\n-#[cfg(stage0)]\n-pub fn start(main: *u8, argc: int, argv: *c_char,\n-             crate_map: *u8) -> int {\n-    use libc::getenv;\n-    use rt::start;\n-\n-    unsafe {\n-        let use_old_rt = do str::as_c_str(\"RUST_NEWRT\") |s| {\n-            getenv(s).is_null()\n-        };\n-        if use_old_rt {\n-            return rust_start(main as *c_void, argc as c_int, argv,\n-                              crate_map as *c_void) as int;\n-        } else {\n-            return start(main, argc, argv, crate_map);\n-        }\n-    }\n-\n-    extern {\n-        fn rust_start(main: *c_void, argc: c_int, argv: *c_char,\n-                      crate_map: *c_void) -> c_int;\n-    }\n-}\n-\n-#[lang=\"start\"]\n-#[cfg(not(stage0))]\n pub fn start(main: *u8, argc: int, argv: **c_char,\n              crate_map: *u8) -> int {\n     use libc::getenv;"}, {"sha": "94f866643532c7f1231065074532af66ae724c8a", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 0, "deletions": 217, "changes": 217, "blob_url": "https://github.com/rust-lang/rust/blob/202b8dcdc420d8b109fbd5260ea2e2be0a5b7faf/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/202b8dcdc420d8b109fbd5260ea2e2be0a5b7faf/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=202b8dcdc420d8b109fbd5260ea2e2be0a5b7faf", "patch": "@@ -1566,16 +1566,6 @@ pub fn each_permutation<T:Copy>(v: &[T], put: &fn(ts: &[T]) -> bool) {\n     }\n }\n \n-// see doc below\n-#[cfg(stage0)] // XXX: lifetimes!\n-pub fn windowed<T>(n: uint, v: &[T], it: &fn(&[T]) -> bool) {\n-    assert!(1u <= n);\n-    if n > v.len() { return; }\n-    for uint::range(0, v.len() - n + 1) |i| {\n-        if !it(v.slice(i, i+n)) { return }\n-    }\n-}\n-\n /**\n  * Iterate over all contiguous windows of length `n` of the vector `v`.\n  *\n@@ -1590,9 +1580,6 @@ pub fn windowed<T>(n: uint, v: &[T], it: &fn(&[T]) -> bool) {\n  * ~~~\n  *\n  */\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n-#[cfg(stage3)]\n pub fn windowed<'r, T>(n: uint, v: &'r [T], it: &fn(&'r [T]) -> bool) {\n     assert!(1u <= n);\n     if n > v.len() { return; }\n@@ -1854,150 +1841,6 @@ impl<'self,T:Copy> CopyableVector<T> for &'self const [T] {\n     }\n }\n \n-#[cfg(stage0)]\n-pub trait ImmutableVector<T> {\n-    fn slice(&self, start: uint, end: uint) -> &'self [T];\n-    fn head(&self) -> &'self T;\n-    fn head_opt(&self) -> Option<&'self T>;\n-    fn tail(&self) -> &'self [T];\n-    fn tailn(&self, n: uint) -> &'self [T];\n-    fn init(&self) -> &'self [T];\n-    fn initn(&self, n: uint) -> &'self [T];\n-    fn last(&self) -> &'self T;\n-    fn last_opt(&self) -> Option<&'self T>;\n-    fn each_reverse(&self, blk: &fn(&T) -> bool);\n-    fn eachi_reverse(&self, blk: &fn(uint, &T) -> bool);\n-    fn foldr<U: Copy>(&self, z: U, p: &fn(t: &T, u: U) -> U) -> U;\n-    fn map<U>(&self, f: &fn(t: &T) -> U) -> ~[U];\n-    fn mapi<U>(&self, f: &fn(uint, t: &T) -> U) -> ~[U];\n-    fn map_r<U>(&self, f: &fn(x: &T) -> U) -> ~[U];\n-    fn alli(&self, f: &fn(uint, t: &T) -> bool) -> bool;\n-    fn flat_map<U>(&self, f: &fn(t: &T) -> ~[U]) -> ~[U];\n-    fn filter_mapped<U:Copy>(&self, f: &fn(t: &T) -> Option<U>) -> ~[U];\n-    unsafe fn unsafe_ref(&self, index: uint) -> *T;\n-}\n-\n-/// Extension methods for vectors\n-#[cfg(stage0)]\n-impl<'self,T> ImmutableVector<T> for &'self [T] {\n-    /// Return a slice that points into another slice.\n-    #[inline]\n-    fn slice(&self, start: uint, end: uint) -> &'self [T] {\n-        slice(*self, start, end)\n-    }\n-\n-    /// Returns the first element of a vector, failing if the vector is empty.\n-    #[inline]\n-    fn head(&self) -> &'self T { head(*self) }\n-\n-    /// Returns the first element of a vector\n-    #[inline]\n-    fn head_opt(&self) -> Option<&'self T> { head_opt(*self) }\n-\n-    /// Returns all but the first element of a vector\n-    #[inline]\n-    fn tail(&self) -> &'self [T] { tail(*self) }\n-\n-    /// Returns all but the first `n' elements of a vector\n-    #[inline]\n-    fn tailn(&self, n: uint) -> &'self [T] { tailn(*self, n) }\n-\n-    /// Returns all but the last elemnt of a vector\n-    #[inline]\n-    fn init(&self) -> &'self [T] { init(*self) }\n-\n-    /// Returns all but the last `n' elemnts of a vector\n-    #[inline]\n-    fn initn(&self, n: uint) -> &'self [T] { initn(*self, n) }\n-\n-    /// Returns the last element of a `v`, failing if the vector is empty.\n-    #[inline]\n-    fn last(&self) -> &'self T { last(*self) }\n-\n-    /// Returns the last element of a `v`, failing if the vector is empty.\n-    #[inline]\n-    fn last_opt(&self) -> Option<&'self T> { last_opt(*self) }\n-\n-    /// Iterates over a vector's elements in reverse.\n-    #[inline]\n-    fn each_reverse(&self, blk: &fn(&T) -> bool) {\n-        each_reverse(*self, blk)\n-    }\n-\n-    /// Iterates over a vector's elements and indices in reverse.\n-    #[inline]\n-    fn eachi_reverse(&self, blk: &fn(uint, &T) -> bool) {\n-        eachi_reverse(*self, blk)\n-    }\n-\n-    /// Reduce a vector from right to left\n-    #[inline]\n-    fn foldr<U:Copy>(&self, z: U, p: &fn(t: &T, u: U) -> U) -> U {\n-        foldr(*self, z, p)\n-    }\n-\n-    /// Apply a function to each element of a vector and return the results\n-    #[inline]\n-    fn map<U>(&self, f: &fn(t: &T) -> U) -> ~[U] { map(*self, f) }\n-\n-    /**\n-     * Apply a function to the index and value of each element in the vector\n-     * and return the results\n-     */\n-    fn mapi<U>(&self, f: &fn(uint, t: &T) -> U) -> ~[U] {\n-        mapi(*self, f)\n-    }\n-\n-    #[inline]\n-    fn map_r<U>(&self, f: &fn(x: &T) -> U) -> ~[U] {\n-        let mut r = ~[];\n-        let mut i = 0;\n-        while i < self.len() {\n-            r.push(f(&self[i]));\n-            i += 1;\n-        }\n-        r\n-    }\n-\n-    /**\n-     * Returns true if the function returns true for all elements.\n-     *\n-     *     If the vector is empty, true is returned.\n-     */\n-    fn alli(&self, f: &fn(uint, t: &T) -> bool) -> bool {\n-        alli(*self, f)\n-    }\n-    /**\n-     * Apply a function to each element of a vector and return a concatenation\n-     * of each result vector\n-     */\n-    #[inline]\n-    fn flat_map<U>(&self, f: &fn(t: &T) -> ~[U]) -> ~[U] {\n-        flat_map(*self, f)\n-    }\n-    /**\n-     * Apply a function to each element of a vector and return the results\n-     *\n-     * If function `f` returns `none` then that element is excluded from\n-     * the resulting vector.\n-     */\n-    #[inline]\n-    fn filter_mapped<U:Copy>(&self, f: &fn(t: &T) -> Option<U>) -> ~[U] {\n-        filter_mapped(*self, f)\n-    }\n-\n-    /// Returns a pointer to the element at the given index, without doing\n-    /// bounds checking.\n-    #[inline(always)]\n-    unsafe fn unsafe_ref(&self, index: uint) -> *T {\n-        let (ptr, _): (*T, uint) = transmute(*self);\n-        ptr.offset(index)\n-    }\n-}\n-\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n-#[cfg(stage3)]\n pub trait ImmutableVector<'self, T> {\n     fn slice(&self, start: uint, end: uint) -> &'self [T];\n     fn iter(self) -> VecIterator<'self, T>;\n@@ -2022,9 +1865,6 @@ pub trait ImmutableVector<'self, T> {\n }\n \n /// Extension methods for vectors\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n-#[cfg(stage3)]\n impl<'self,T> ImmutableVector<'self, T> for &'self [T] {\n     /// Return a slice that points into another slice.\n     #[inline]\n@@ -2634,17 +2474,6 @@ pub mod bytes {\n // ___________________________________________________________________________\n // ITERATION TRAIT METHODS\n \n-#[cfg(stage0)]\n-impl<'self,A> old_iter::BaseIter<A> for &'self [A] {\n-    #[inline(always)]\n-    fn each(&self, blk: &fn(v: &'self A) -> bool) { each(*self, blk) }\n-    #[inline(always)]\n-    fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n-}\n-\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n-#[cfg(stage3)]\n impl<'self,A> old_iter::BaseIter<A> for &'self [A] {\n     #[inline(always)]\n     fn each<'a>(&'a self, blk: &fn(v: &'a A) -> bool) { each(*self, blk) }\n@@ -2653,18 +2482,6 @@ impl<'self,A> old_iter::BaseIter<A> for &'self [A] {\n }\n \n // FIXME(#4148): This should be redundant\n-#[cfg(stage0)]\n-impl<A> old_iter::BaseIter<A> for ~[A] {\n-    #[inline(always)]\n-    fn each(&self, blk: &fn(v: &'self A) -> bool) { each(*self, blk) }\n-    #[inline(always)]\n-    fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n-}\n-\n-// FIXME(#4148): This should be redundant\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n-#[cfg(stage3)]\n impl<A> old_iter::BaseIter<A> for ~[A] {\n     #[inline(always)]\n     fn each<'a>(&'a self, blk: &fn(v: &'a A) -> bool) { each(*self, blk) }\n@@ -2673,36 +2490,13 @@ impl<A> old_iter::BaseIter<A> for ~[A] {\n }\n \n // FIXME(#4148): This should be redundant\n-#[cfg(stage0)]\n-impl<A> old_iter::BaseIter<A> for @[A] {\n-    #[inline(always)]\n-    fn each(&self, blk: &fn(v: &'self A) -> bool) { each(*self, blk) }\n-    #[inline(always)]\n-    fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n-}\n-\n-// FIXME(#4148): This should be redundant\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n-#[cfg(stage3)]\n impl<A> old_iter::BaseIter<A> for @[A] {\n     #[inline(always)]\n     fn each<'a>(&'a self, blk: &fn(v: &'a A) -> bool) { each(*self, blk) }\n     #[inline(always)]\n     fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n }\n \n-#[cfg(stage0)]\n-impl<'self,A> old_iter::MutableIter<A> for &'self mut [A] {\n-    #[inline(always)]\n-    fn each_mut(&mut self, blk: &fn(v: &'self mut A) -> bool) {\n-        each_mut(*self, blk)\n-    }\n-}\n-\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n-#[cfg(stage3)]\n impl<'self,A> old_iter::MutableIter<A> for &'self mut [A] {\n     #[inline(always)]\n     fn each_mut<'a>(&'a mut self, blk: &fn(v: &'a mut A) -> bool) {\n@@ -2711,17 +2505,6 @@ impl<'self,A> old_iter::MutableIter<A> for &'self mut [A] {\n }\n \n // FIXME(#4148): This should be redundant\n-#[cfg(stage0)]\n-impl<A> old_iter::MutableIter<A> for ~[A] {\n-    #[inline(always)]\n-    fn each_mut(&mut self, blk: &fn(v: &'self mut A) -> bool) {\n-        each_mut(*self, blk)\n-    }\n-}\n-\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n-#[cfg(stage3)]\n impl<A> old_iter::MutableIter<A> for ~[A] {\n     #[inline(always)]\n     fn each_mut<'a>(&'a mut self, blk: &fn(v: &'a mut A) -> bool) {"}, {"sha": "c65521228fa8713bed6e15cf451f3e11e242cdc1", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 0, "deletions": 104, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/202b8dcdc420d8b109fbd5260ea2e2be0a5b7faf/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/202b8dcdc420d8b109fbd5260ea2e2be0a5b7faf/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=202b8dcdc420d8b109fbd5260ea2e2be0a5b7faf", "patch": "@@ -557,29 +557,6 @@ trait read_method_map_entry_helper {\n                             -> method_map_entry;\n }\n \n-#[cfg(stage0)]\n-fn encode_method_map_entry(ecx: @e::EncodeContext,\n-                              ebml_w: &writer::Encoder,\n-                              mme: method_map_entry) {\n-    do ebml_w.emit_struct(\"method_map_entry\", 3) {\n-        do ebml_w.emit_field(~\"self_arg\", 0u) {\n-            ebml_w.emit_arg(ecx, mme.self_arg);\n-        }\n-        do ebml_w.emit_field(~\"explicit_self\", 2u) {\n-            mme.explicit_self.encode(ebml_w);\n-        }\n-        do ebml_w.emit_field(~\"origin\", 1u) {\n-            mme.origin.encode(ebml_w);\n-        }\n-        do ebml_w.emit_field(~\"self_mode\", 3) {\n-            mme.self_mode.encode(ebml_w);\n-        }\n-    }\n-}\n-\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n-#[cfg(stage3)]\n fn encode_method_map_entry(ecx: @e::EncodeContext,\n                               ebml_w: &writer::Encoder,\n                               mme: method_map_entry) {\n@@ -600,34 +577,6 @@ fn encode_method_map_entry(ecx: @e::EncodeContext,\n }\n \n impl read_method_map_entry_helper for reader::Decoder {\n-    #[cfg(stage0)]\n-    fn read_method_map_entry(&self, xcx: @ExtendedDecodeContext)\n-        -> method_map_entry {\n-        do self.read_struct(\"method_map_entry\", 3) {\n-            method_map_entry {\n-                self_arg: self.read_field(~\"self_arg\", 0u, || {\n-                    self.read_arg(xcx)\n-                }),\n-                explicit_self: self.read_field(~\"explicit_self\", 2u, || {\n-                    let self_type: ast::self_ty_ = Decodable::decode(self);\n-                    self_type\n-                }),\n-                origin: self.read_field(~\"origin\", 1u, || {\n-                    let method_origin: method_origin =\n-                        Decodable::decode(self);\n-                    method_origin.tr(xcx)\n-                }),\n-                self_mode: self.read_field(~\"self_mode\", 3, || {\n-                    let self_mode: ty::SelfMode = Decodable::decode(self);\n-                    self_mode\n-                }),\n-            }\n-        }\n-    }\n-\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n-    #[cfg(stage3)]\n     fn read_method_map_entry(&self, xcx: @ExtendedDecodeContext)\n         -> method_map_entry {\n         do self.read_struct(\"method_map_entry\", 3) {\n@@ -841,33 +790,6 @@ impl ebml_writer_helpers for writer::Encoder {\n         }\n     }\n \n-    #[cfg(stage0)]\n-    fn emit_tpbt(&self, ecx: @e::EncodeContext,\n-                 tpbt: ty::ty_param_bounds_and_ty) {\n-        do self.emit_struct(\"ty_param_bounds_and_ty\", 2) {\n-            do self.emit_field(~\"generics\", 0) {\n-                do self.emit_struct(\"Generics\", 2) {\n-                    do self.emit_field(~\"type_param_defs\", 0) {\n-                        do self.emit_from_vec(*tpbt.generics.type_param_defs)\n-                            |type_param_def|\n-                        {\n-                            self.emit_type_param_def(ecx, type_param_def);\n-                        }\n-                    }\n-                    do self.emit_field(~\"region_param\", 1) {\n-                        tpbt.generics.region_param.encode(self);\n-                    }\n-                }\n-            }\n-            do self.emit_field(~\"ty\", 1) {\n-                self.emit_ty(ecx, tpbt.ty);\n-            }\n-        }\n-    }\n-\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n-    #[cfg(stage3)]\n     fn emit_tpbt(&self, ecx: @e::EncodeContext,\n                  tpbt: ty::ty_param_bounds_and_ty) {\n         do self.emit_struct(\"ty_param_bounds_and_ty\", 2) {\n@@ -1126,32 +1048,6 @@ impl ebml_decoder_decoder_helpers for reader::Decoder {\n         }\n     }\n \n-    #[cfg(stage0)]\n-    fn read_ty_param_bounds_and_ty(&self, xcx: @ExtendedDecodeContext)\n-        -> ty::ty_param_bounds_and_ty\n-    {\n-        do self.read_struct(\"ty_param_bounds_and_ty\", 2) {\n-            ty::ty_param_bounds_and_ty {\n-                generics: do self.read_struct(\"Generics\", 2) {\n-                    ty::Generics {\n-                        type_param_defs: self.read_field(\"type_param_defs\", 0, || {\n-                            @self.read_to_vec(|| self.read_type_param_def(xcx))\n-                        }),\n-                        region_param: self.read_field(~\"region_param\", 1, || {\n-                            Decodable::decode(self)\n-                        })\n-                    }\n-                },\n-                ty: self.read_field(~\"ty\", 1, || {\n-                    self.read_ty(xcx)\n-                })\n-            }\n-        }\n-    }\n-\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n-    #[cfg(stage3)]\n     fn read_ty_param_bounds_and_ty(&self, xcx: @ExtendedDecodeContext)\n         -> ty::ty_param_bounds_and_ty\n     {"}, {"sha": "9e34d5c6177e69d62c323eedb9173990077afe24", "filename": "src/librustc/rustc.rc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/202b8dcdc420d8b109fbd5260ea2e2be0a5b7faf/src%2Flibrustc%2Frustc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/202b8dcdc420d8b109fbd5260ea2e2be0a5b7faf/src%2Flibrustc%2Frustc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Frustc.rc?ref=202b8dcdc420d8b109fbd5260ea2e2be0a5b7faf", "patch": "@@ -85,6 +85,7 @@ pub mod middle {\n     pub mod lint;\n     #[path = \"borrowck/mod.rs\"]\n     pub mod borrowck;\n+    pub mod dataflow;\n     pub mod mem_categorization;\n     pub mod liveness;\n     pub mod kind;"}, {"sha": "e714af5fa1890b6433a89bb853bd01768bda618e", "filename": "src/libstd/arena.rs", "status": "modified", "additions": 0, "deletions": 56, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/202b8dcdc420d8b109fbd5260ea2e2be0a5b7faf/src%2Flibstd%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/202b8dcdc420d8b109fbd5260ea2e2be0a5b7faf/src%2Flibstd%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Farena.rs?ref=202b8dcdc420d8b109fbd5260ea2e2be0a5b7faf", "patch": "@@ -201,21 +201,6 @@ pub impl Arena {\n     }\n \n     #[inline(always)]\n-    #[cfg(stage0)]\n-    priv fn alloc_pod<T>(&self, op: &fn() -> T) -> &'self T {\n-        unsafe {\n-            let tydesc = sys::get_type_desc::<T>();\n-            let ptr = self.alloc_pod_inner((*tydesc).size, (*tydesc).align);\n-            let ptr: *mut T = transmute(ptr);\n-            rusti::move_val_init(&mut (*ptr), op());\n-            return transmute(ptr);\n-        }\n-    }\n-\n-    #[inline(always)]\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n-    #[cfg(stage3)]\n     priv fn alloc_pod<'a, T>(&'a self, op: &fn() -> T) -> &'a T {\n         unsafe {\n             let tydesc = sys::get_type_desc::<T>();\n@@ -261,31 +246,6 @@ pub impl Arena {\n     }\n \n     #[inline(always)]\n-    #[cfg(stage0)]\n-    priv fn alloc_nonpod<T>(&self, op: &fn() -> T) -> &'self T {\n-        unsafe {\n-            let tydesc = sys::get_type_desc::<T>();\n-            let (ty_ptr, ptr) =\n-                self.alloc_nonpod_inner((*tydesc).size, (*tydesc).align);\n-            let ty_ptr: *mut uint = transmute(ty_ptr);\n-            let ptr: *mut T = transmute(ptr);\n-            // Write in our tydesc along with a bit indicating that it\n-            // has *not* been initialized yet.\n-            *ty_ptr = transmute(tydesc);\n-            // Actually initialize it\n-            rusti::move_val_init(&mut(*ptr), op());\n-            // Now that we are done, update the tydesc to indicate that\n-            // the object is there.\n-            *ty_ptr = bitpack_tydesc_ptr(tydesc, true);\n-\n-            return transmute(ptr);\n-        }\n-    }\n-\n-    #[inline(always)]\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n-    #[cfg(stage3)]\n     priv fn alloc_nonpod<'a, T>(&'a self, op: &fn() -> T) -> &'a T {\n         unsafe {\n             let tydesc = sys::get_type_desc::<T>();\n@@ -308,22 +268,6 @@ pub impl Arena {\n \n     // The external interface\n     #[inline(always)]\n-    #[cfg(stage0)]\n-    fn alloc<T>(&self, op: &fn() -> T) -> &'self T {\n-        unsafe {\n-            if !rusti::needs_drop::<T>() {\n-                self.alloc_pod(op)\n-            } else {\n-                self.alloc_nonpod(op)\n-            }\n-        }\n-    }\n-\n-    // The external interface\n-    #[inline(always)]\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n-    #[cfg(stage3)]\n     fn alloc<'a, T>(&'a self, op: &fn() -> T) -> &'a T {\n         unsafe {\n             if !rusti::needs_drop::<T>() {"}, {"sha": "64d708e0b2e89da362cfae8c198cede1631fcf75", "filename": "src/libstd/deque.rs", "status": "modified", "additions": 0, "deletions": 122, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/202b8dcdc420d8b109fbd5260ea2e2be0a5b7faf/src%2Flibstd%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/202b8dcdc420d8b109fbd5260ea2e2be0a5b7faf/src%2Flibstd%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fdeque.rs?ref=202b8dcdc420d8b109fbd5260ea2e2be0a5b7faf", "patch": "@@ -37,128 +37,6 @@ impl<T> Mutable for Deque<T> {\n     }\n }\n \n-#[cfg(stage0)]\n-pub impl<T> Deque<T> {\n-    /// Create an empty Deque\n-    fn new() -> Deque<T> {\n-        Deque{nelts: 0, lo: 0, hi: 0,\n-              elts: vec::from_fn(initial_capacity, |_| None)}\n-    }\n-\n-    /// Return a reference to the first element in the deque\n-    ///\n-    /// Fails if the deque is empty\n-    #[cfg(stage0)]\n-    fn peek_front(&self) -> &'self T { get(self.elts, self.lo) }\n-\n-    /// Return a reference to the first element in the deque\n-    ///\n-    /// Fails if the deque is empty\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n-    #[cfg(stage3)]\n-    fn peek_front<'a>(&'a self) -> &'a T { get(self.elts, self.lo) }\n-\n-    /// Return a reference to the last element in the deque\n-    ///\n-    /// Fails if the deque is empty\n-    #[cfg(stage0)]\n-    fn peek_back(&self) -> &'self T { get(self.elts, self.hi - 1u) }\n-\n-    /// Return a reference to the last element in the deque\n-    ///\n-    /// Fails if the deque is empty\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n-    #[cfg(stage3)]\n-    fn peek_back<'a>(&'a self) -> &'a T { get(self.elts, self.hi - 1u) }\n-\n-    /// Retrieve an element in the deque by index\n-    ///\n-    /// Fails if there is no element with the given index\n-    #[cfg(stage0)]\n-    fn get(&self, i: int) -> &'self T {\n-        let idx = (self.lo + (i as uint)) % self.elts.len();\n-        get(self.elts, idx)\n-    }\n-\n-    /// Retrieve an element in the deque by index\n-    ///\n-    /// Fails if there is no element with the given index\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n-    #[cfg(stage3)]\n-    fn get<'a>(&'a self, i: int) -> &'a T {\n-        let idx = (self.lo + (i as uint)) % self.elts.len();\n-        get(self.elts, idx)\n-    }\n-\n-    /// Iterate over the elements in the deque\n-    fn each(&self, f: &fn(&T) -> bool) {\n-        self.eachi(|_i, e| f(e))\n-    }\n-\n-    /// Iterate over the elements in the deque by index\n-    fn eachi(&self, f: &fn(uint, &T) -> bool) {\n-        for uint::range(0, self.nelts) |i| {\n-            if !f(i, self.get(i as int)) { return; }\n-        }\n-    }\n-\n-    /// Remove and return the first element in the deque\n-    ///\n-    /// Fails if the deque is empty\n-    fn pop_front(&mut self) -> T {\n-        let result = self.elts[self.lo].swap_unwrap();\n-        self.lo = (self.lo + 1u) % self.elts.len();\n-        self.nelts -= 1u;\n-        result\n-    }\n-\n-    /// Remove and return the last element in the deque\n-    ///\n-    /// Fails if the deque is empty\n-    fn pop_back(&mut self) -> T {\n-        if self.hi == 0u {\n-            self.hi = self.elts.len() - 1u;\n-        } else { self.hi -= 1u; }\n-        let result = self.elts[self.hi].swap_unwrap();\n-        self.elts[self.hi] = None;\n-        self.nelts -= 1u;\n-        result\n-    }\n-\n-    /// Prepend an element to the deque\n-    fn add_front(&mut self, t: T) {\n-        let oldlo = self.lo;\n-        if self.lo == 0u {\n-            self.lo = self.elts.len() - 1u;\n-        } else { self.lo -= 1u; }\n-        if self.lo == self.hi {\n-            self.elts = grow(self.nelts, oldlo, self.elts);\n-            self.lo = self.elts.len() - 1u;\n-            self.hi = self.nelts;\n-        }\n-        self.elts[self.lo] = Some(t);\n-        self.nelts += 1u;\n-    }\n-\n-    /// Append an element to the deque\n-    fn add_back(&mut self, t: T) {\n-        if self.lo == self.hi && self.nelts != 0u {\n-            self.elts = grow(self.nelts, self.lo, self.elts);\n-            self.lo = 0u;\n-            self.hi = self.nelts;\n-        }\n-        self.elts[self.hi] = Some(t);\n-        self.hi = (self.hi + 1u) % self.elts.len();\n-        self.nelts += 1u;\n-    }\n-}\n-\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n-#[cfg(stage3)]\n pub impl<T> Deque<T> {\n     /// Create an empty Deque\n     fn new() -> Deque<T> {"}, {"sha": "9b89036eee51b0a26a1ed5ea743114053a103c58", "filename": "src/libstd/ebml.rs", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/202b8dcdc420d8b109fbd5260ea2e2be0a5b7faf/src%2Flibstd%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/202b8dcdc420d8b109fbd5260ea2e2be0a5b7faf/src%2Flibstd%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Febml.rs?ref=202b8dcdc420d8b109fbd5260ea2e2be0a5b7faf", "patch": "@@ -400,16 +400,6 @@ pub mod reader {\n             f()\n         }\n \n-        #[cfg(stage0)]\n-        fn read_field<T>(&self, name: &str, idx: uint, f: &fn() -> T) -> T {\n-            debug!(\"read_field(name=%?, idx=%u)\", name, idx);\n-            self._check_label(name);\n-            f()\n-        }\n-\n-        #[cfg(stage1)]\n-        #[cfg(stage2)]\n-        #[cfg(stage3)]\n         fn read_struct_field<T>(&self, name: &str, idx: uint, f: &fn() -> T) -> T {\n             debug!(\"read_struct_field(name=%?, idx=%u)\", name, idx);\n             self._check_label(name);\n@@ -714,14 +704,6 @@ pub mod writer {\n         }\n \n         fn emit_struct(&self, _name: &str, _len: uint, f: &fn()) { f() }\n-        #[cfg(stage0)]\n-        fn emit_field(&self, name: &str, _idx: uint, f: &fn()) {\n-            self._emit_label(name);\n-            f()\n-        }\n-        #[cfg(stage1)]\n-        #[cfg(stage2)]\n-        #[cfg(stage3)]\n         fn emit_struct_field(&self, name: &str, _idx: uint, f: &fn()) {\n             self._emit_label(name);\n             f()"}, {"sha": "c3fc16bdf70baad55ecff545e77a6f46d838bc13", "filename": "src/libstd/future.rs", "status": "modified", "additions": 0, "deletions": 29, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/202b8dcdc420d8b109fbd5260ea2e2be0a5b7faf/src%2Flibstd%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/202b8dcdc420d8b109fbd5260ea2e2be0a5b7faf/src%2Flibstd%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffuture.rs?ref=202b8dcdc420d8b109fbd5260ea2e2be0a5b7faf", "patch": "@@ -54,35 +54,6 @@ pub impl<A:Copy> Future<A> {\n }\n \n pub impl<A> Future<A> {\n-    #[cfg(stage0)]\n-    fn get_ref(&self) -> &'self A {\n-        /*!\n-        * Executes the future's closure and then returns a borrowed\n-        * pointer to the result.  The borrowed pointer lasts as long as\n-        * the future.\n-        */\n-        unsafe {\n-            match self.state {\n-                Forced(ref mut v) => { return cast::transmute(v); }\n-                Evaluating => fail!(~\"Recursive forcing of future!\"),\n-                Pending(_) => {}\n-            }\n-\n-            let mut state = Evaluating;\n-            self.state <-> state;\n-            match state {\n-                Forced(_) | Evaluating => fail!(~\"Logic error.\"),\n-                Pending(f) => {\n-                    self.state = Forced(f());\n-                    self.get_ref()\n-                }\n-            }\n-        }\n-    }\n-\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n-    #[cfg(stage3)]\n     fn get_ref<'a>(&'a self) -> &'a A {\n         /*!\n         * Executes the future's closure and then returns a borrowed"}, {"sha": "5d5b0bd952f189c8f6ee21abfe2a83e1a6ad9c84", "filename": "src/libstd/json.rs", "status": "modified", "additions": 0, "deletions": 48, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/202b8dcdc420d8b109fbd5260ea2e2be0a5b7faf/src%2Flibstd%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/202b8dcdc420d8b109fbd5260ea2e2be0a5b7faf/src%2Flibstd%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fjson.rs?ref=202b8dcdc420d8b109fbd5260ea2e2be0a5b7faf", "patch": "@@ -143,16 +143,6 @@ impl serialize::Encoder for Encoder {\n         f();\n         self.wr.write_char('}');\n     }\n-    #[cfg(stage0)]\n-    fn emit_field(&self, name: &str, idx: uint, f: &fn()) {\n-        if idx != 0 { self.wr.write_char(','); }\n-        self.wr.write_str(escape_str(name));\n-        self.wr.write_char(':');\n-        f();\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n-    #[cfg(stage3)]\n     fn emit_struct_field(&self, name: &str, idx: uint, f: &fn()) {\n         if idx != 0 { self.wr.write_char(','); }\n         self.wr.write_str(escape_str(name));\n@@ -289,21 +279,6 @@ impl serialize::Encoder for PrettyEncoder {\n             self.wr.write_char('}');\n         }\n     }\n-    #[cfg(stage0)]\n-    fn emit_field(&self, name: &str, idx: uint, f: &fn()) {\n-        if idx == 0 {\n-            self.wr.write_char('\\n');\n-        } else {\n-            self.wr.write_str(\",\\n\");\n-        }\n-        self.wr.write_str(spaces(self.indent));\n-        self.wr.write_str(escape_str(name));\n-        self.wr.write_str(\": \");\n-        f();\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n-    #[cfg(stage3)]\n     fn emit_struct_field(&self, name: &str, idx: uint, f: &fn()) {\n         if idx == 0 {\n             self.wr.write_char('\\n');\n@@ -901,29 +876,6 @@ impl serialize::Decoder for Decoder {\n         value\n     }\n \n-    #[cfg(stage0)]\n-    fn read_field<T>(&self, name: &str, idx: uint, f: &fn() -> T) -> T {\n-        debug!(\"read_field(name=%?, idx=%u)\", name, idx);\n-        match self.stack.pop() {\n-            Object(obj) => {\n-                let mut obj = obj;\n-                let value = match obj.pop(&name.to_owned()) {\n-                    None => fail!(fmt!(\"no such field: %s\", name)),\n-                    Some(json) => {\n-                        self.stack.push(json);\n-                        f()\n-                    }\n-                };\n-                self.stack.push(Object(obj));\n-                value\n-            }\n-            value => fail!(fmt!(\"not an object: %?\", value))\n-        }\n-    }\n-\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n-    #[cfg(stage3)]\n     fn read_struct_field<T>(&self, name: &str, idx: uint, f: &fn() -> T) -> T {\n         debug!(\"read_struct_field(name=%?, idx=%u)\", name, idx);\n         match self.stack.pop() {"}, {"sha": "33fe1cfff8e59b0deb699cb12c2635034765009f", "filename": "src/libstd/priority_queue.rs", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/202b8dcdc420d8b109fbd5260ea2e2be0a5b7faf/src%2Flibstd%2Fpriority_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/202b8dcdc420d8b109fbd5260ea2e2be0a5b7faf/src%2Flibstd%2Fpriority_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpriority_queue.rs?ref=202b8dcdc420d8b109fbd5260ea2e2be0a5b7faf", "patch": "@@ -45,25 +45,9 @@ impl<T:Ord> Mutable for PriorityQueue<T> {\n \n pub impl <T:Ord> PriorityQueue<T> {\n     /// Returns the greatest item in the queue - fails if empty\n-    #[cfg(stage0)]\n-    fn top(&self) -> &'self T { &self.data[0] }\n-\n-    /// Returns the greatest item in the queue - fails if empty\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n-    #[cfg(stage3)]\n     fn top<'a>(&'a self) -> &'a T { &self.data[0] }\n \n     /// Returns the greatest item in the queue - None if empty\n-    #[cfg(stage0)]\n-    fn maybe_top(&self) -> Option<&'self T> {\n-        if self.is_empty() { None } else { Some(self.top()) }\n-    }\n-\n-    /// Returns the greatest item in the queue - None if empty\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n-    #[cfg(stage3)]\n     fn maybe_top<'a>(&'a self) -> Option<&'a T> {\n         if self.is_empty() { None } else { Some(self.top()) }\n     }"}, {"sha": "032df4c819cdd84caced2a855faf2412243c3c98", "filename": "src/libstd/serialize.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/202b8dcdc420d8b109fbd5260ea2e2be0a5b7faf/src%2Flibstd%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/202b8dcdc420d8b109fbd5260ea2e2be0a5b7faf/src%2Flibstd%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fserialize.rs?ref=202b8dcdc420d8b109fbd5260ea2e2be0a5b7faf", "patch": "@@ -55,11 +55,6 @@ pub trait Encoder {\n     fn emit_enum_struct_variant_field(&self, f_name: &str, f_idx: uint, f: &fn());\n \n     fn emit_struct(&self, name: &str, len: uint, f: &fn());\n-    #[cfg(stage0)]\n-    fn emit_field(&self, f_name: &str, f_idx: uint, f: &fn());\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n-    #[cfg(stage3)]\n     fn emit_struct_field(&self, f_name: &str, f_idx: uint, f: &fn());\n \n     fn emit_tuple(&self, len: uint, f: &fn());\n@@ -111,11 +106,6 @@ pub trait Decoder {\n     fn read_enum_struct_variant_field<T>(&self, &f_name: &str, f_idx: uint, f: &fn() -> T) -> T;\n \n     fn read_struct<T>(&self, s_name: &str, len: uint, f: &fn() -> T) -> T;\n-    #[cfg(stage0)]\n-    fn read_field<T>(&self, f_name: &str, f_idx: uint, f: &fn() -> T) -> T;\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n-    #[cfg(stage3)]\n     fn read_struct_field<T>(&self, f_name: &str, f_idx: uint, f: &fn() -> T) -> T;\n \n     fn read_tuple<T>(&self, f: &fn(uint) -> T) -> T;"}, {"sha": "1b72300a178bad17f20049474752741cba8d8eb3", "filename": "src/libstd/smallintmap.rs", "status": "modified", "additions": 0, "deletions": 77, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/202b8dcdc420d8b109fbd5260ea2e2be0a5b7faf/src%2Flibstd%2Fsmallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/202b8dcdc420d8b109fbd5260ea2e2be0a5b7faf/src%2Flibstd%2Fsmallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsmallintmap.rs?ref=202b8dcdc420d8b109fbd5260ea2e2be0a5b7faf", "patch": "@@ -50,20 +50,6 @@ impl<V> Map<uint, V> for SmallIntMap<V> {\n     }\n \n     /// Visit all key-value pairs in order\n-    #[cfg(stage0)]\n-    fn each(&self, it: &fn(&uint, &'self V) -> bool) {\n-        for uint::range(0, self.v.len()) |i| {\n-            match self.v[i] {\n-              Some(ref elt) => if !it(&i, elt) { break },\n-              None => ()\n-            }\n-        }\n-    }\n-\n-    /// Visit all key-value pairs in order\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n-    #[cfg(stage3)]\n     fn each<'a>(&'a self, it: &fn(&uint, &'a V) -> bool) {\n         for uint::range(0, self.v.len()) |i| {\n             match self.v[i] {\n@@ -79,15 +65,6 @@ impl<V> Map<uint, V> for SmallIntMap<V> {\n     }\n \n     /// Visit all values in order\n-    #[cfg(stage0)]\n-    fn each_value(&self, blk: &fn(value: &V) -> bool) {\n-        self.each(|_, v| blk(v))\n-    }\n-\n-    /// Visit all values in order\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n-    #[cfg(stage3)]\n     fn each_value<'a>(&'a self, blk: &fn(value: &'a V) -> bool) {\n         self.each(|_, v| blk(v))\n     }\n@@ -103,22 +80,6 @@ impl<V> Map<uint, V> for SmallIntMap<V> {\n     }\n \n     /// Return a reference to the value corresponding to the key\n-    #[cfg(stage0)]\n-    fn find(&self, key: &uint) -> Option<&'self V> {\n-        if *key < self.v.len() {\n-            match self.v[*key] {\n-              Some(ref value) => Some(value),\n-              None => None\n-            }\n-        } else {\n-            None\n-        }\n-    }\n-\n-    /// Return a reference to the value corresponding to the key\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n-    #[cfg(stage3)]\n     fn find<'a>(&'a self, key: &uint) -> Option<&'a V> {\n         if *key < self.v.len() {\n             match self.v[*key] {\n@@ -131,22 +92,6 @@ impl<V> Map<uint, V> for SmallIntMap<V> {\n     }\n \n     /// Return a mutable reference to the value corresponding to the key\n-    #[cfg(stage0)]\n-    fn find_mut(&mut self, key: &uint) -> Option<&'self mut V> {\n-        if *key < self.v.len() {\n-            match self.v[*key] {\n-              Some(ref mut value) => Some(value),\n-              None => None\n-            }\n-        } else {\n-            None\n-        }\n-    }\n-\n-    /// Return a mutable reference to the value corresponding to the key\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n-    #[cfg(stage3)]\n     fn find_mut<'a>(&'a mut self, key: &uint) -> Option<&'a mut V> {\n         if *key < self.v.len() {\n             match self.v[*key] {\n@@ -188,20 +133,6 @@ pub impl<V> SmallIntMap<V> {\n     fn new() -> SmallIntMap<V> { SmallIntMap{v: ~[]} }\n \n     /// Visit all key-value pairs in reverse order\n-    #[cfg(stage0)]\n-    fn each_reverse(&self, it: &fn(uint, &'self V) -> bool) {\n-        for uint::range_rev(self.v.len(), 0) |i| {\n-            match self.v[i - 1] {\n-              Some(ref elt) => if !it(i - 1, elt) { break },\n-              None => ()\n-            }\n-        }\n-    }\n-\n-    /// Visit all key-value pairs in reverse order\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n-    #[cfg(stage3)]\n     fn each_reverse<'a>(&'a self, it: &fn(uint, &'a V) -> bool) {\n         for uint::range_rev(self.v.len(), 0) |i| {\n             match self.v[i - 1] {\n@@ -211,14 +142,6 @@ pub impl<V> SmallIntMap<V> {\n         }\n     }\n \n-    #[cfg(stage0)]\n-    fn get(&self, key: &uint) -> &'self V {\n-        self.find(key).expect(\"key not present\")\n-    }\n-\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n-    #[cfg(stage3)]\n     fn get<'a>(&'a self, key: &uint) -> &'a V {\n         self.find(key).expect(\"key not present\")\n     }"}, {"sha": "5bad9ecae3ed77e1fce4f0e315545363f958bcf8", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/202b8dcdc420d8b109fbd5260ea2e2be0a5b7faf/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/202b8dcdc420d8b109fbd5260ea2e2be0a5b7faf/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=202b8dcdc420d8b109fbd5260ea2e2be0a5b7faf", "patch": "@@ -451,17 +451,6 @@ impl <K: Eq + Hash + IterBytes ,V: Copy> MapChain<K,V>{\n \n     // ugh: can't get this to compile with mut because of the\n     // lack of flow sensitivity.\n-    #[cfg(stage0)]\n-    fn get_map(&self) -> &'self HashMap<K,@V> {\n-        match *self {\n-            BaseMapChain (~ref map) => map,\n-            ConsMapChain (~ref map,_) => map\n-        }\n-    }\n-\n-    // ugh: can't get this to compile with mut because of the\n-    // lack of flow sensitivity.\n-    #[cfg(not(stage0))]\n     fn get_map<'a>(&'a self) -> &'a HashMap<K,@V> {\n         match *self {\n             BaseMapChain (~ref map) => map,"}, {"sha": "600ab964e5238fc52c09f5fb4880a9dae5d9a6c5", "filename": "src/libsyntax/opt_vec.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/202b8dcdc420d8b109fbd5260ea2e2be0a5b7faf/src%2Flibsyntax%2Fopt_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/202b8dcdc420d8b109fbd5260ea2e2be0a5b7faf/src%2Flibsyntax%2Fopt_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fopt_vec.rs?ref=202b8dcdc420d8b109fbd5260ea2e2be0a5b7faf", "patch": "@@ -61,15 +61,6 @@ impl<T> OptVec<T> {\n         }\n     }\n \n-    #[cfg(stage0)]\n-    fn get(&self, i: uint) -> &'self T {\n-        match *self {\n-            Empty => fail!(fmt!(\"Invalid index %u\", i)),\n-            Vec(ref v) => &v[i]\n-        }\n-    }\n-\n-    #[cfg(not(stage0))]\n     fn get<'a>(&'a self, i: uint) -> &'a T {\n         match *self {\n             Empty => fail!(fmt!(\"Invalid index %u\", i)),"}]}