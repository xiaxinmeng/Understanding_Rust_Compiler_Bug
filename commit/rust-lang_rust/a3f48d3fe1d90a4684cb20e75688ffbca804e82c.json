{"sha": "a3f48d3fe1d90a4684cb20e75688ffbca804e82c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEzZjQ4ZDNmZTFkOTBhNDY4NGNiMjBlNzU2ODhmZmJjYTgwNGU4MmM=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-12-07T19:52:38Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-12-07T19:52:38Z"}, "message": "Merge branch 'master' of github.com:graydon/rust", "tree": {"sha": "f8ca510a3e827cb31e38cffdc260ab6112cf6b79", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f8ca510a3e827cb31e38cffdc260ab6112cf6b79"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a3f48d3fe1d90a4684cb20e75688ffbca804e82c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a3f48d3fe1d90a4684cb20e75688ffbca804e82c", "html_url": "https://github.com/rust-lang/rust/commit/a3f48d3fe1d90a4684cb20e75688ffbca804e82c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a3f48d3fe1d90a4684cb20e75688ffbca804e82c/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1652b921fa2fadc936b346fc3de217cf97b0e476", "url": "https://api.github.com/repos/rust-lang/rust/commits/1652b921fa2fadc936b346fc3de217cf97b0e476", "html_url": "https://github.com/rust-lang/rust/commit/1652b921fa2fadc936b346fc3de217cf97b0e476"}, {"sha": "6c95e400d82699887b66f5de0fef2bb5e1f8cc32", "url": "https://api.github.com/repos/rust-lang/rust/commits/6c95e400d82699887b66f5de0fef2bb5e1f8cc32", "html_url": "https://github.com/rust-lang/rust/commit/6c95e400d82699887b66f5de0fef2bb5e1f8cc32"}], "stats": {"total": 661, "additions": 509, "deletions": 152}, "files": [{"sha": "aab593f3046a451d92831153da3efb7d847e953d", "filename": "Makefile.in", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a3f48d3fe1d90a4684cb20e75688ffbca804e82c/Makefile.in", "raw_url": "https://github.com/rust-lang/rust/raw/a3f48d3fe1d90a4684cb20e75688ffbca804e82c/Makefile.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Makefile.in?ref=a3f48d3fe1d90a4684cb20e75688ffbca804e82c", "patch": "@@ -353,12 +353,24 @@ $(foreach build,$(CFG_TARGET_TRIPLES), \\\n # Builds a functional Rustc for the given host.\n ######################################################################\n \n-define DEF_RUSTC_TARGET\n+define DEF_RUSTC_STAGE_TARGET\n # $(1) == architecture\n+# $(2) == stage\n \n-rustc-H-$(1):\t\t\t\t\t\t\t\t\t\\\n+rustc-stage$(2)-H-$(1):\t\t\t\t\t\t\t\\\n \t$$(foreach target,$$(CFG_TARGET_TRIPLES),\t\\\n-\t\t$$(SREQ3_T_$$(target)_H_$(1)))\n+\t\t$$(SREQ$(2)_T_$$(target)_H_$(1)))\n+\n+endef\n+\n+$(foreach host,$(CFG_TARGET_TRIPLES),\t\t\t\t\t\t\t\\\n+ $(eval $(foreach stage,1 2 3,\t\t\t\t\t\t\t\t\t\\\n+  $(eval $(call DEF_RUSTC_STAGE_TARGET,$(host),$(stage))))))\n+\n+define DEF_RUSTC_TARGET\n+# $(1) == architecture\n+\n+rustc-H-$(1): rustc-stage3-H-$(1)\n endef\n \n $(foreach host,$(CFG_TARGET_TRIPLES),\t\t\t\\"}, {"sha": "71f33ccb3729017a53ea1204ef02aa90e9f34f05", "filename": "src/comp/back/upcall.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a3f48d3fe1d90a4684cb20e75688ffbca804e82c/src%2Fcomp%2Fback%2Fupcall.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3f48d3fe1d90a4684cb20e75688ffbca804e82c/src%2Fcomp%2Fback%2Fupcall.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Fupcall.rs?ref=a3f48d3fe1d90a4684cb20e75688ffbca804e82c", "patch": "@@ -27,7 +27,8 @@ type upcalls =\n      dynastack_free: ValueRef,\n      alloc_c_stack: ValueRef,\n      call_shim_on_c_stack: ValueRef,\n-     rust_personality: ValueRef};\n+     rust_personality: ValueRef,\n+     reset_stack_limit: ValueRef};\n \n fn declare_upcalls(targ_cfg: @session::config,\n                    _tn: type_names,\n@@ -89,7 +90,8 @@ fn declare_upcalls(targ_cfg: @session::config,\n                                   // arguments: void *args, void *fn_ptr\n                                   [T_ptr(T_i8()), T_ptr(T_i8())],\n                                   int_t),\n-          rust_personality: d(\"rust_personality\", [], T_i32())\n+          rust_personality: d(\"rust_personality\", [], T_i32()),\n+          reset_stack_limit: dv(\"reset_stack_limit\", [])\n          };\n }\n //"}, {"sha": "63dadd347e1682649285a7e239f4b7868cc9031a", "filename": "src/comp/middle/mut.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/a3f48d3fe1d90a4684cb20e75688ffbca804e82c/src%2Fcomp%2Fmiddle%2Fmut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3f48d3fe1d90a4684cb20e75688ffbca804e82c/src%2Fcomp%2Fmiddle%2Fmut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fmut.rs?ref=a3f48d3fe1d90a4684cb20e75688ffbca804e82c", "patch": "@@ -150,6 +150,7 @@ fn visit_decl(cx: @ctx, d: @decl, &&e: (), v: visit::vt<()>) {\n fn visit_expr(cx: @ctx, ex: @expr, &&e: (), v: visit::vt<()>) {\n     alt ex.node {\n       expr_call(f, args, _) { check_call(cx, f, args); }\n+      expr_bind(f, args) { check_bind(cx, f, args); }\n       expr_swap(lhs, rhs) {\n         check_lval(cx, lhs, msg_assign);\n         check_lval(cx, rhs, msg_assign);\n@@ -230,6 +231,30 @@ fn check_call(cx: @ctx, f: @expr, args: [@expr]) {\n     }\n }\n \n+fn check_bind(cx: @ctx, f: @expr, args: [option::t<@expr>]) {\n+    let arg_ts = ty::ty_fn_args(cx.tcx, ty::expr_ty(cx.tcx, f));\n+    let i = 0u;\n+    for arg in args {\n+        alt arg {\n+          some(expr) {\n+            alt (alt arg_ts[i].mode {\n+              by_mut_ref. { some(\"by mutable reference\") }\n+              by_move. { some(\"by move\") }\n+              _ { none }\n+            }) {\n+              some(name) {\n+                cx.tcx.sess.span_err(\n+                    expr.span, \"can not bind an argument passed \" + name);\n+              }\n+              none. {}\n+            }\n+          }\n+          _ {}\n+        }\n+        i += 1u;\n+    }\n+}\n+\n fn is_immutable_def(def: def) -> option::t<str> {\n     alt def {\n       def_fn(_, _) | def_mod(_) | def_native_mod(_) | def_const(_) |"}, {"sha": "107c53cfac37b51409aeef1fa7565c377f861f36", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a3f48d3fe1d90a4684cb20e75688ffbca804e82c/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3f48d3fe1d90a4684cb20e75688ffbca804e82c/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=a3f48d3fe1d90a4684cb20e75688ffbca804e82c", "patch": "@@ -3462,6 +3462,12 @@ fn trans_bind_thunk(cx: @local_ctxt, sp: span, incoming_fty: ty::t,\n             bcx = bound_arg.bcx;\n             let val = bound_arg.val;\n             if out_arg.mode == ast::by_val { val = Load(bcx, val); }\n+            if out_arg.mode == ast::by_copy {\n+                let {bcx: cx, val: alloc} = alloc_ty(bcx, out_arg.ty);\n+                bcx = memmove_ty(cx, alloc, val, out_arg.ty);\n+                bcx = take_ty(bcx, alloc, out_arg.ty);\n+                val = alloc;\n+            }\n             // If the type is parameterized, then we need to cast the\n             // type we actually have to the parameterized out type.\n             if ty::type_contains_params(cx.ccx.tcx, out_arg.ty) {\n@@ -3904,6 +3910,11 @@ fn trans_landing_pad(bcx: @block_ctxt,\n     // The landing pad block is a cleanup\n     SetCleanup(bcx, llpad);\n \n+    // Because we may have unwound across a stack boundary, we must call into\n+    // the runtime to figure out which stack segment we are on and place the\n+    // stack limit back into the TLS.\n+    Call(bcx, bcx_ccx(bcx).upcalls.reset_stack_limit, []);\n+\n     // FIXME: This seems like a very naive and redundant way to generate the\n     // landing pads, as we're re-generating all in-scope cleanups for each\n     // function call. Probably good optimization opportunities here.\n@@ -4531,7 +4542,9 @@ fn zero_alloca(cx: @block_ctxt, llptr: ValueRef, t: ty::t)\n fn trans_stmt(cx: @block_ctxt, s: ast::stmt) -> @block_ctxt {\n     // FIXME Fill in cx.sp\n \n-    add_span_comment(cx, s.span, stmt_to_str(s));\n+    if (!bcx_ccx(cx).sess.get_opts().no_asm_comments) {\n+        add_span_comment(cx, s.span, stmt_to_str(s));\n+    }\n \n     let bcx = cx;\n     alt s.node {"}, {"sha": "b7756b0902d8b6b7d12671cb00b09940f952acdc", "filename": "src/comp/middle/trans_build.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a3f48d3fe1d90a4684cb20e75688ffbca804e82c/src%2Fcomp%2Fmiddle%2Ftrans_build.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3f48d3fe1d90a4684cb20e75688ffbca804e82c/src%2Fcomp%2Fmiddle%2Ftrans_build.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_build.rs?ref=a3f48d3fe1d90a4684cb20e75688ffbca804e82c", "patch": "@@ -515,7 +515,9 @@ fn add_span_comment(bcx: @block_ctxt, sp: span, text: str) {\n fn add_comment(bcx: @block_ctxt, text: str) {\n     let ccx = bcx_ccx(bcx);\n     if (!ccx.sess.get_opts().no_asm_comments) {\n-        let comment_text = \"; \" + text;\n+        check str::is_not_empty(\"$\");\n+        let sanitized = str::replace(text, \"$\", \"\");\n+        let comment_text = \"; \" + sanitized;\n         let asm = str::as_buf(comment_text, { |c|\n             str::as_buf(\"\", { |e|\n                 llvm::LLVMConstInlineAsm(T_fn([], T_void()), c, e, 0, 0)})});"}, {"sha": "d8e57c90986672224afa4b2eb84d92e5e01a9a07", "filename": "src/comp/middle/tstate/pre_post_conditions.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a3f48d3fe1d90a4684cb20e75688ffbca804e82c/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3f48d3fe1d90a4684cb20e75688ffbca804e82c/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs?ref=a3f48d3fe1d90a4684cb20e75688ffbca804e82c", "patch": "@@ -452,6 +452,10 @@ fn find_pre_post_expr(fcx: fn_ctxt, e: @expr) {\n       expr_alt(ex, alts) {\n         find_pre_post_expr(fcx, ex);\n         fn do_an_alt(fcx: fn_ctxt, an_alt: arm) -> pre_and_post {\n+            alt an_alt.guard {\n+              some(e) { find_pre_post_expr(fcx, e); }\n+              _ {}\n+            }\n             find_pre_post_block(fcx, an_alt.body);\n             ret block_pp(fcx.ccx, an_alt.body);\n         }"}, {"sha": "aa7977d142d303e02b914a728954eb0fca1961c4", "filename": "src/comp/middle/tstate/states.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a3f48d3fe1d90a4684cb20e75688ffbca804e82c/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3f48d3fe1d90a4684cb20e75688ffbca804e82c/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs?ref=a3f48d3fe1d90a4684cb20e75688ffbca804e82c", "patch": "@@ -530,6 +530,12 @@ fn find_pre_post_state_expr(fcx: fn_ctxt, pres: prestate, e: @expr) -> bool {\n         if vec::len(alts) > 0u {\n             a_post = false_postcond(num_constrs);\n             for an_alt: arm in alts {\n+                alt an_alt.guard {\n+                  some(e) {\n+                    changed |= find_pre_post_state_expr(fcx, e_post, e);\n+                  }\n+                  _ {}\n+                }\n                 changed |=\n                     find_pre_post_state_block(fcx, e_post, an_alt.body);\n                 intersect(a_post, block_poststate(fcx.ccx, an_alt.body));"}, {"sha": "022b249674b974c747fd327e1fb87add1bba43b9", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/a3f48d3fe1d90a4684cb20e75688ffbca804e82c/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3f48d3fe1d90a4684cb20e75688ffbca804e82c/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=a3f48d3fe1d90a4684cb20e75688ffbca804e82c", "patch": "@@ -1299,23 +1299,23 @@ fn type_autoderef(cx: ctxt, t: ty::t) -> ty::t {\n fn hash_type_structure(st: sty) -> uint {\n     fn hash_uint(id: uint, n: uint) -> uint {\n         let h = id;\n-        h += h << 5u + n;\n+        h += (h << 5u) + n;\n         ret h;\n     }\n     fn hash_def(id: uint, did: ast::def_id) -> uint {\n         let h = id;\n-        h += h << 5u + (did.crate as uint);\n-        h += h << 5u + (did.node as uint);\n+        h += (h << 5u) + (did.crate as uint);\n+        h += (h << 5u) + (did.node as uint);\n         ret h;\n     }\n     fn hash_subty(id: uint, subty: t) -> uint {\n         let h = id;\n-        h += h << 5u + hash_ty(subty);\n+        h += (h << 5u) + hash_ty(subty);\n         ret h;\n     }\n     fn hash_type_constr(id: uint, c: @type_constr) -> uint {\n         let h = id;\n-        h += h << 5u + hash_def(h, c.node.id);\n+        h += (h << 5u) + hash_def(h, c.node.id);\n         ret hash_type_constr_args(h, c.node.args);\n     }\n     fn hash_type_constr_args(id: uint, args: [@ty_constr_arg]) -> uint {\n@@ -1338,8 +1338,8 @@ fn hash_type_structure(st: sty) -> uint {\n \n     fn hash_fn(id: uint, args: [arg], rty: t) -> uint {\n         let h = id;\n-        for a: arg in args { h += h << 5u + hash_ty(a.ty); }\n-        h += h << 5u + hash_ty(rty);\n+        for a: arg in args { h += (h << 5u) + hash_ty(a.ty); }\n+        h += (h << 5u) + hash_ty(rty);\n         ret h;\n     }\n     alt st {\n@@ -1366,19 +1366,19 @@ fn hash_type_structure(st: sty) -> uint {\n       ty_str. { ret 17u; }\n       ty_tag(did, tys) {\n         let h = hash_def(18u, did);\n-        for typ: t in tys { h += h << 5u + hash_ty(typ); }\n+        for typ: t in tys { h += (h << 5u) + hash_ty(typ); }\n         ret h;\n       }\n       ty_box(mt) { ret hash_subty(19u, mt.ty); }\n       ty_vec(mt) { ret hash_subty(21u, mt.ty); }\n       ty_rec(fields) {\n         let h = 26u;\n-        for f: field in fields { h += h << 5u + hash_ty(f.mt.ty); }\n+        for f: field in fields { h += (h << 5u) + hash_ty(f.mt.ty); }\n         ret h;\n       }\n       ty_tup(ts) {\n         let h = 25u;\n-        for tt in ts { h += h << 5u + hash_ty(tt); }\n+        for tt in ts { h += (h << 5u) + hash_ty(tt); }\n         ret h;\n       }\n \n@@ -1389,7 +1389,7 @@ fn hash_type_structure(st: sty) -> uint {\n       ty_native_fn(args, rty) { ret hash_fn(28u, args, rty); }\n       ty_obj(methods) {\n         let h = 29u;\n-        for m: method in methods { h += h << 5u + str::hash(m.ident); }\n+        for m: method in methods { h += (h << 5u) + str::hash(m.ident); }\n         ret h;\n       }\n       ty_var(v) { ret hash_uint(30u, v as uint); }\n@@ -1400,23 +1400,23 @@ fn hash_type_structure(st: sty) -> uint {\n       ty_ptr(mt) { ret hash_subty(35u, mt.ty); }\n       ty_res(did, sub, tps) {\n         let h = hash_subty(hash_def(18u, did), sub);\n-        for tp: t in tps { h += h << 5u + hash_ty(tp); }\n+        for tp: t in tps { h += (h << 5u) + hash_ty(tp); }\n         ret h;\n       }\n       ty_constr(t, cs) {\n         let h = 36u;\n-        for c: @type_constr in cs { h += h << 5u + hash_type_constr(h, c); }\n+        for c: @type_constr in cs { h += (h << 5u) + hash_type_constr(h, c); }\n         ret h;\n       }\n-      ty_uniq(mt) { let h = 37u; h += h << 5u + hash_ty(mt.ty); ret h; }\n+      ty_uniq(mt) { let h = 37u; h += (h << 5u) + hash_ty(mt.ty); ret h; }\n     }\n }\n \n fn hash_type_info(st: sty, cname_opt: option::t<str>) -> uint {\n     let h = hash_type_structure(st);\n     alt cname_opt {\n       none. {/* no-op */ }\n-      some(s) { h += h << 5u + str::hash(s); }\n+      some(s) { h += (h << 5u) + str::hash(s); }\n     }\n     ret h;\n }"}, {"sha": "60b3f2b6fa409b1e26d0d6f22eb68eaa4684897c", "filename": "src/comp/syntax/ast_util.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a3f48d3fe1d90a4684cb20e75688ffbca804e82c/src%2Fcomp%2Fsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3f48d3fe1d90a4684cb20e75688ffbca804e82c/src%2Fcomp%2Fsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fast_util.rs?ref=a3f48d3fe1d90a4684cb20e75688ffbca804e82c", "patch": "@@ -193,10 +193,13 @@ fn is_constraint_arg(e: @expr) -> bool {\n \n fn eq_ty(&&a: @ty, &&b: @ty) -> bool { ret std::box::ptr_eq(a, b); }\n \n-fn hash_ty(&&t: @ty) -> uint { ret t.span.lo << 16u + t.span.hi; }\n+fn hash_ty(&&t: @ty) -> uint {\n+    let res = (t.span.lo << 16u) + t.span.hi;\n+    ret res;\n+}\n \n fn hash_def_id(&&id: def_id) -> uint {\n-    id.crate as uint << 16u + (id.node as uint)\n+    (id.crate as uint << 16u) + (id.node as uint)\n }\n \n fn eq_def_id(&&a: def_id, &&b: def_id) -> bool {"}, {"sha": "660c367991b6d341c9c552f039bfe4de62048fce", "filename": "src/etc/gen-intrinsics", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a3f48d3fe1d90a4684cb20e75688ffbca804e82c/src%2Fetc%2Fgen-intrinsics", "raw_url": "https://github.com/rust-lang/rust/raw/a3f48d3fe1d90a4684cb20e75688ffbca804e82c/src%2Fetc%2Fgen-intrinsics", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fgen-intrinsics?ref=a3f48d3fe1d90a4684cb20e75688ffbca804e82c", "patch": "@@ -17,10 +17,11 @@ do\n         -Isrc/rt/arch/$ARCH -fno-stack-protector \\\n         -o src/rt/intrinsics/intrinsics.$ARCH.ll.in \\\n         src/rt/intrinsics/intrinsics.cpp\n-    sed -i \\\n+    sed -i .orig \\\n         -e 's/^target datalayout =/; target datalayout =/' \\\n         src/rt/intrinsics/intrinsics.$ARCH.ll.in\n-    sed -i \\\n+    sed -i .orig \\\n         -e 's/^target triple = \"[^\"]*\"/target triple = \"@CFG_TARGET_TRIPLE@\"/' \\\n         src/rt/intrinsics/intrinsics.$ARCH.ll.in\n-done\n\\ No newline at end of file\n+    rm src/rt/intrinsics/intrinsics.$ARCH.ll.in.orig\n+done"}, {"sha": "a4ef467401742b6a55fe635f5ab261000c3f1a62", "filename": "src/libstd/map.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a3f48d3fe1d90a4684cb20e75688ffbca804e82c/src%2Flibstd%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3f48d3fe1d90a4684cb20e75688ffbca804e82c/src%2Flibstd%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmap.rs?ref=a3f48d3fe1d90a4684cb20e75688ffbca804e82c", "patch": "@@ -137,21 +137,25 @@ fn mk_hashmap<copy K, copy V>(hasher: hashfn<K>, eqer: eqfn<K>)\n     // is always a power of 2), so that all buckets are probed for a\n     // fixed key.\n \n-    fn hashl(n: uint, _nbkts: uint) -> uint { ret (n >>> 16u) * 2u + 1u; }\n-    fn hashr(n: uint, _nbkts: uint) -> uint { ret 0x0000_ffff_u & n; }\n-    fn hash(h: uint, nbkts: uint, i: uint) -> uint {\n-        ret (hashl(h, nbkts) * i + hashr(h, nbkts)) % nbkts;\n+    fn hashl(n: u32) -> u32 { ret (n >>> 16u32) * 2u32 + 1u32; }\n+    fn hashr(n: u32) -> u32 { ret 0x0000_ffff_u32 & n; }\n+    fn hash(h: u32, nbkts: uint, i: uint) -> uint {\n+        ret ((hashl(h) as uint) * i + (hashr(h) as uint)) % nbkts;\n     }\n+\n+    fn to_u64(h: uint) -> u32 {\n+        ret (h as u32) ^ ((h >>> 16u) as u32);\n+    }\n+\n     /**\n      * We attempt to never call this with a full table.  If we do, it\n      * will fail.\n      */\n-\n     fn insert_common<copy K, copy V>(hasher: hashfn<K>, eqer: eqfn<K>,\n                                      bkts: [mutable bucket<K, V>],\n                                      nbkts: uint, key: K, val: V) -> bool {\n         let i: uint = 0u;\n-        let h: uint = hasher(key);\n+        let h = to_u64(hasher(key));\n         while i < nbkts {\n             let j: uint = hash(h, nbkts, i);\n             alt bkts[j] {\n@@ -171,7 +175,7 @@ fn mk_hashmap<copy K, copy V>(hasher: hashfn<K>, eqer: eqfn<K>)\n                                    bkts: [mutable bucket<K, V>],\n                                    nbkts: uint, key: K) -> option::t<V> {\n         let i: uint = 0u;\n-        let h: uint = hasher(key);\n+        let h = to_u64(hasher(key));\n         while i < nbkts {\n             let j: uint = hash(h, nbkts, i);\n             alt bkts[j] {\n@@ -244,7 +248,7 @@ fn mk_hashmap<copy K, copy V>(hasher: hashfn<K>, eqer: eqfn<K>)\n         }\n         fn remove(key: K) -> option::t<V> {\n             let i: uint = 0u;\n-            let h: uint = hasher(key);\n+            let h = to_u64(hasher(key));\n             while i < nbkts {\n                 let j: uint = hash(h, nbkts, i);\n                 alt bkts[j] {"}, {"sha": "521dc33758e986d980d224ceb3e7b50322d8003a", "filename": "src/libstd/str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3f48d3fe1d90a4684cb20e75688ffbca804e82c/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3f48d3fe1d90a4684cb20e75688ffbca804e82c/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=a3f48d3fe1d90a4684cb20e75688ffbca804e82c", "patch": "@@ -324,7 +324,7 @@ fn char_range_at(s: str, i: uint) -> {ch: char, next: uint} {\n     // Clunky way to get the right bits from the first byte. Uses two shifts,\n     // the first to clip off the marker bits at the left of the byte, and then\n     // a second (as uint) to get it to the right position.\n-    val += (b0 << (w + 1u as u8) as uint) << (w - 1u) * 6u - w - 1u;\n+    val += (b0 << (w + 1u as u8) as uint) << ((w - 1u) * 6u - w - 1u);\n     ret {ch: val as char, next: i};\n }\n "}, {"sha": "3e396d3ac63c5b86ec93576e36d467c0f8c46b59", "filename": "src/libstd/task.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3f48d3fe1d90a4684cb20e75688ffbca804e82c/src%2Flibstd%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3f48d3fe1d90a4684cb20e75688ffbca804e82c/src%2Flibstd%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask.rs?ref=a3f48d3fe1d90a4684cb20e75688ffbca804e82c", "patch": "@@ -288,7 +288,7 @@ fn spawn_inner<send T>(-data: T, f: fn(T),\n                           notify: option<comm::chan<task_notification>>)\n     -> task unsafe {\n \n-    fn wrapper<send T>(-data: *u8, f: fn(T)) unsafe {\n+    fn wrapper<send T>(data: *u8, f: fn(T)) unsafe {\n         let data: ~T = unsafe::reinterpret_cast(data);\n         f(*data);\n     }"}, {"sha": "3f299de5d15484d91c8bc84dadd28f7dcad0cf06", "filename": "src/rt/arch/i386/record_sp.S", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a3f48d3fe1d90a4684cb20e75688ffbca804e82c/src%2Frt%2Farch%2Fi386%2Frecord_sp.S", "raw_url": "https://github.com/rust-lang/rust/raw/a3f48d3fe1d90a4684cb20e75688ffbca804e82c/src%2Frt%2Farch%2Fi386%2Frecord_sp.S", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Farch%2Fi386%2Frecord_sp.S?ref=a3f48d3fe1d90a4684cb20e75688ffbca804e82c", "patch": "@@ -2,11 +2,14 @@\n \n #if defined(__APPLE__) || defined(_WIN32)\n #define RECORD_SP          _record_sp\n+#define GET_SP             _get_sp\n #else\n #define RECORD_SP          record_sp\n+#define GET_SP             get_sp\n #endif\n \n .globl RECORD_SP\n+.globl GET_SP\n \n #if defined(__linux__)\n RECORD_SP:\n@@ -25,3 +28,7 @@ RECORD_SP:\n \tret\n #endif\n #endif\n+\n+GET_SP:\n+\tmovl %esp, %eax\n+\tret\n\\ No newline at end of file"}, {"sha": "535b6190f1c23880c6295049c77b95345fa9f664", "filename": "src/rt/arch/x86_64/morestack.S", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a3f48d3fe1d90a4684cb20e75688ffbca804e82c/src%2Frt%2Farch%2Fx86_64%2Fmorestack.S", "raw_url": "https://github.com/rust-lang/rust/raw/a3f48d3fe1d90a4684cb20e75688ffbca804e82c/src%2Frt%2Farch%2Fx86_64%2Fmorestack.S", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Farch%2Fx86_64%2Fmorestack.S?ref=a3f48d3fe1d90a4684cb20e75688ffbca804e82c", "patch": "@@ -132,6 +132,10 @@ MORESTACK:\n \n \taddq $8, %rsp\n \tpopq %rbp\n+#ifdef __linux__\n+\t.cfi_restore %rbp\n+\t.cfi_def_cfa %rsp, 8\n+#endif\n \tret\n \t\n #if defined(__ELF__)"}, {"sha": "415f6685655c944ffd8e9587a59e6ffdb780cbe6", "filename": "src/rt/arch/x86_64/record_sp.S", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a3f48d3fe1d90a4684cb20e75688ffbca804e82c/src%2Frt%2Farch%2Fx86_64%2Frecord_sp.S", "raw_url": "https://github.com/rust-lang/rust/raw/a3f48d3fe1d90a4684cb20e75688ffbca804e82c/src%2Frt%2Farch%2Fx86_64%2Frecord_sp.S", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Farch%2Fx86_64%2Frecord_sp.S?ref=a3f48d3fe1d90a4684cb20e75688ffbca804e82c", "patch": "@@ -2,11 +2,14 @@\n \n #if defined(__APPLE__) || defined(_WIN32)\n #define RECORD_SP          _record_sp\n+#define GET_SP             _get_sp\n #else\n #define RECORD_SP          record_sp\n+#define GET_SP             get_sp\n #endif\n \n .globl RECORD_SP\n+.globl GET_SP\n \n #if defined(__linux__)\n RECORD_SP:\n@@ -23,3 +26,7 @@ RECORD_SP:\n \tret\n #endif\n #endif\n+\n+GET_SP:\n+\tmovq %rsp, %rax\n+\tret"}, {"sha": "601a7c3f0ef9a674b643cb117c294dd9d9b3056b", "filename": "src/rt/rust_scheduler.cpp", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a3f48d3fe1d90a4684cb20e75688ffbca804e82c/src%2Frt%2Frust_scheduler.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/a3f48d3fe1d90a4684cb20e75688ffbca804e82c/src%2Frt%2Frust_scheduler.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_scheduler.cpp?ref=a3f48d3fe1d90a4684cb20e75688ffbca804e82c", "patch": "@@ -286,7 +286,6 @@ rust_scheduler::start_main_loop() {\n              scheduled_task->state->name);\n \n         place_task_in_tls(scheduled_task);\n-        //pthread_setspecific(89, (void *)scheduled_task->stk->limit);\n \n         interrupt_flag = 0;\n "}, {"sha": "3593d0ff335ffde595af25b1124c0d84935699d6", "filename": "src/rt/rust_shape.cpp", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a3f48d3fe1d90a4684cb20e75688ffbca804e82c/src%2Frt%2Frust_shape.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/a3f48d3fe1d90a4684cb20e75688ffbca804e82c/src%2Frt%2Frust_shape.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_shape.cpp?ref=a3f48d3fe1d90a4684cb20e75688ffbca804e82c", "patch": "@@ -530,9 +530,9 @@ log::walk_res(const rust_fn *dtor, unsigned n_params,\n } // end namespace shape\n \n extern \"C\" void\n-upcall_cmp_type(int8_t *result, const type_desc *tydesc,\n-                const type_desc **subtydescs, uint8_t *data_0,\n-                uint8_t *data_1, uint8_t cmp_type) {\n+shape_cmp_type(int8_t *result, const type_desc *tydesc,\n+\t       const type_desc **subtydescs, uint8_t *data_0,\n+\t       uint8_t *data_1, uint8_t cmp_type) {\n     rust_task *task = rust_scheduler::get_task();\n     shape::arena arena;\n \n@@ -553,7 +553,7 @@ upcall_cmp_type(int8_t *result, const type_desc *tydesc,\n }\n \n extern \"C\" void\n-upcall_log_type(const type_desc *tydesc, uint8_t *data, uint32_t level) {\n+shape_log_type(const type_desc *tydesc, uint8_t *data, uint32_t level) {\n     rust_task *task = rust_scheduler::get_task();\n     if (task->sched->log_lvl < level)\n         return;     // TODO: Don't evaluate at all?"}, {"sha": "bdc2f7ff7ce56e7b5dc6c3d4a4061841d5104b23", "filename": "src/rt/rust_task.cpp", "status": "modified", "additions": 43, "deletions": 7, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/a3f48d3fe1d90a4684cb20e75688ffbca804e82c/src%2Frt%2Frust_task.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/a3f48d3fe1d90a4684cb20e75688ffbca804e82c/src%2Frt%2Frust_task.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_task.cpp?ref=a3f48d3fe1d90a4684cb20e75688ffbca804e82c", "patch": "@@ -14,15 +14,22 @@\n \n #include \"globals.h\"\n \n+// Each stack gets some guard bytes that valgrind will verify we don't touch\n+#ifndef NVALGRIND\n+#define STACK_NOACCESS_SIZE 16\n+#else\n+#define STACK_NOACCESS_SIZE 0\n+#endif\n+\n // The amount of extra space at the end of each stack segment, available\n // to the rt, compiler and dynamic linker for running small functions\n // FIXME: We want this to be 128 but need to slim the red zone calls down\n #ifdef __i386__\n-#define RED_ZONE_SIZE 2048\n+#define RED_ZONE_SIZE (65536 + STACK_NOACCESS_SIZE)\n #endif\n \n #ifdef __x86_64__\n-#define RED_ZONE_SIZE 2048\n+#define RED_ZONE_SIZE (65536 + STACK_NOACCESS_SIZE)\n #endif\n \n // Stack size\n@@ -51,11 +58,14 @@ new_stk(rust_scheduler *sched, rust_task *task, size_t minsz)\n     LOGPTR(task->sched, \"new stk\", (uintptr_t)stk);\n     memset(stk, 0, sizeof(stk_seg));\n     stk->next = task->stk;\n-    stk->limit = (uintptr_t) &stk->data[minsz + RED_ZONE_SIZE];\n-    LOGPTR(task->sched, \"stk limit\", stk->limit);\n+    stk->end = (uintptr_t) &stk->data[minsz + RED_ZONE_SIZE];\n+    LOGPTR(task->sched, \"stk end\", stk->end);\n     stk->valgrind_id =\n         VALGRIND_STACK_REGISTER(&stk->data[0],\n                                 &stk->data[minsz + RED_ZONE_SIZE]);\n+#ifndef NVALGRIND\n+    VALGRIND_MAKE_MEM_NOACCESS(stk->data, STACK_NOACCESS_SIZE);\n+#endif\n     task->stk = stk;\n     return stk;\n }\n@@ -67,6 +77,9 @@ del_stk(rust_task *task, stk_seg *stk)\n \n     task->stk = stk->next;\n \n+#ifndef NVALGRIND\n+    VALGRIND_MAKE_MEM_DEFINED(stk->data, STACK_NOACCESS_SIZE);\n+#endif\n     VALGRIND_STACK_DEREGISTER(stk->valgrind_id);\n     LOGPTR(task->sched, \"freeing stk segment\", (uintptr_t)stk);\n     task->free(stk);\n@@ -106,7 +119,7 @@ rust_task::rust_task(rust_scheduler *sched, rust_task_list *state,\n     user.notify_enabled = 0;\n \n     stk = new_stk(sched, this, 0);\n-    user.rust_sp = stk->limit;\n+    user.rust_sp = stk->end;\n     if (supervisor) {\n         supervisor->ref();\n     }\n@@ -582,7 +595,7 @@ rust_task::new_stack(size_t stk_sz, void *args_addr, size_t args_sz) {\n \n     stk_seg *stk_seg = new_stk(sched, this, stk_sz + args_sz);\n \n-    uint8_t *new_sp = (uint8_t*)stk_seg->limit;\n+    uint8_t *new_sp = (uint8_t*)stk_seg->end;\n     size_t sizeof_retaddr = sizeof(void*);\n     // Make enough room on the new stack to hold the old stack pointer\n     // in addition to the function arguments\n@@ -608,11 +621,34 @@ rust_task::record_stack_limit() {\n     // account for those 256 bytes.\n     const unsigned LIMIT_OFFSET = 256;\n     A(sched,\n-      (uintptr_t)stk->limit - RED_ZONE_SIZE\n+      (uintptr_t)stk->end - RED_ZONE_SIZE\n       - (uintptr_t)stk->data >= LIMIT_OFFSET,\n       \"Stack size must be greater than LIMIT_OFFSET\");\n     record_sp(stk->data + LIMIT_OFFSET + RED_ZONE_SIZE);\n }\n+\n+extern \"C\" uintptr_t get_sp();\n+\n+/*\n+Called by landing pads during unwinding to figure out which\n+stack segment we are currently running on, delete the others,\n+and record the stack limit (which was not restored when unwinding\n+through __morestack).\n+ */\n+void\n+rust_task::reset_stack_limit() {\n+    uintptr_t sp = get_sp();\n+    // Not positive these bounds for sp are correct.\n+    // I think that the first possible value for esp on a new\n+    // stack is stk->end, which points one word in front of\n+    // the first work to be pushed onto a new stack.\n+    while (sp <= (uintptr_t)stk->data || stk->end < sp) {\n+        del_stk(this, stk);\n+        A(sched, stk != NULL, \"Failed to find the current stack\");\n+    }\n+    record_stack_limit();\n+}\n+\n //\n // Local Variables:\n // mode: C++"}, {"sha": "3d5cbff9910363be0191620ff03446c7fdb67090", "filename": "src/rt/rust_task.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a3f48d3fe1d90a4684cb20e75688ffbca804e82c/src%2Frt%2Frust_task.h", "raw_url": "https://github.com/rust-lang/rust/raw/a3f48d3fe1d90a4684cb20e75688ffbca804e82c/src%2Frt%2Frust_task.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_task.h?ref=a3f48d3fe1d90a4684cb20e75688ffbca804e82c", "patch": "@@ -25,7 +25,7 @@ struct rust_box;\n \n struct stk_seg {\n     stk_seg *next;\n-    uintptr_t limit;\n+    uintptr_t end;\n     unsigned int valgrind_id;\n #ifndef _LP64\n     uint32_t pad;\n@@ -200,6 +200,7 @@ rust_task : public kernel_owned<rust_task>, rust_cond\n     void *new_stack(size_t stk_sz, void *args_addr, size_t args_sz);\n     void del_stack();\n     void record_stack_limit();\n+    void reset_stack_limit();\n };\n \n //"}, {"sha": "e4b646e39ffa37b7e5a5fd5525a7789cb132cb71", "filename": "src/rt/rust_upcall.cpp", "status": "modified", "additions": 319, "deletions": 89, "changes": 408, "blob_url": "https://github.com/rust-lang/rust/blob/a3f48d3fe1d90a4684cb20e75688ffbca804e82c/src%2Frt%2Frust_upcall.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/a3f48d3fe1d90a4684cb20e75688ffbca804e82c/src%2Frt%2Frust_upcall.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_upcall.cpp?ref=a3f48d3fe1d90a4684cb20e75688ffbca804e82c", "patch": "@@ -6,7 +6,31 @@\n #include \"rust_upcall.h\"\n #include <stdint.h>\n \n-// Upcalls.\n+extern \"C\" void record_sp(void *limit);\n+\n+/**\n+ * Switches to the C-stack and invokes |fn_ptr|, passing |args| as argument.\n+ */\n+extern \"C\" CDECL void\n+upcall_call_shim_on_c_stack(void *args, void *fn_ptr) {\n+    rust_task *task = rust_scheduler::get_task();\n+\n+    // FIXME (1226) - The shim functions generated by rustc contain the\n+    // morestack prologue, so we need to let them know they have enough\n+    // stack.\n+    record_sp(0);\n+\n+    rust_scheduler *sched = task->sched;\n+    try {\n+        sched->c_context.call_shim_on_c_stack(args, fn_ptr);\n+    } catch (...) {\n+        task = rust_scheduler::get_task();\n+        task->record_stack_limit();\n+        throw;\n+    }\n+    task = rust_scheduler::get_task();\n+    task->record_stack_limit();\n+}\n \n #if defined(__i386__) || defined(__x86_64__) || defined(_M_X64)\n void\n@@ -47,193 +71,407 @@ copy_elements(rust_task *task, type_desc *elem_t,\n     }\n }\n \n+struct s_fail_args {\n+    char const *expr;\n+    char const *file;\n+    size_t line;\n+};\n+\n extern \"C\" CDECL void\n-upcall_fail(char const *expr,\n-            char const *file,\n-            size_t line) {\n+upcall_s_fail(s_fail_args *args) {\n     rust_task *task = rust_scheduler::get_task();\n     LOG_UPCALL_ENTRY(task);\n-    LOG_ERR(task, upcall, \"upcall fail '%s', %s:%\" PRIdPTR, expr, file, line);\n+    LOG_ERR(task, upcall, \"upcall fail '%s', %s:%\" PRIdPTR, \n+            args->expr, args->file, args->line);\n     task->fail();\n }\n \n+struct s_malloc_args {\n+    size_t nbytes;\n+    type_desc *td;\n+};\n+\n extern \"C\" CDECL uintptr_t\n-upcall_malloc(size_t nbytes, type_desc *td) {\n+upcall_s_malloc(s_malloc_args *args) {\n     rust_task *task = rust_scheduler::get_task();\n     LOG_UPCALL_ENTRY(task);\n \n     LOG(task, mem,\n         \"upcall malloc(%\" PRIdPTR \", 0x%\" PRIxPTR \")\",\n-        nbytes, td);\n+        args->nbytes, args->td);\n \n     gc::maybe_gc(task);\n     cc::maybe_cc(task);\n \n     // TODO: Maybe use dladdr here to find a more useful name for the\n     // type_desc.\n \n-    void *p = task->malloc(nbytes, \"tdesc\", td);\n-    memset(p, '\\0', nbytes);\n+    void *p = task->malloc(args->nbytes, \"tdesc\", args->td);\n+    memset(p, '\\0', args->nbytes);\n \n-    task->local_allocs[p] = td;\n+    task->local_allocs[p] = args->td;\n     debug::maybe_track_origin(task, p);\n \n     LOG(task, mem,\n         \"upcall malloc(%\" PRIdPTR \", 0x%\" PRIxPTR \") = 0x%\" PRIxPTR,\n-        nbytes, td, (uintptr_t)p);\n+        args->nbytes, args->td, (uintptr_t)p);\n     return (uintptr_t) p;\n }\n \n+struct s_free_args {\n+    void *ptr;\n+    uintptr_t is_gc;\n+};\n+\n /**\n  * Called whenever an object's ref count drops to zero.\n  */\n extern \"C\" CDECL void\n-upcall_free(void* ptr, uintptr_t is_gc) {\n+upcall_s_free(s_free_args *args) {\n     rust_task *task = rust_scheduler::get_task();\n     LOG_UPCALL_ENTRY(task);\n \n     rust_scheduler *sched = task->sched;\n     DLOG(sched, mem,\n              \"upcall free(0x%\" PRIxPTR \", is_gc=%\" PRIdPTR \")\",\n-             (uintptr_t)ptr, is_gc);\n+             (uintptr_t)args->ptr, args->is_gc);\n \n-    task->local_allocs.erase(ptr);\n-    debug::maybe_untrack_origin(task, ptr);\n+    task->local_allocs.erase(args->ptr);\n+    debug::maybe_untrack_origin(task, args->ptr);\n \n-    task->free(ptr, (bool) is_gc);\n+    task->free(args->ptr, (bool) args->is_gc);\n }\n \n+struct s_shared_malloc_args {\n+    size_t nbytes;\n+    type_desc *td;\n+};\n+\n extern \"C\" CDECL uintptr_t\n-upcall_shared_malloc(size_t nbytes, type_desc *td) {\n+upcall_s_shared_malloc(s_shared_malloc_args *args) {\n     rust_task *task = rust_scheduler::get_task();\n     LOG_UPCALL_ENTRY(task);\n \n     LOG(task, mem,\n-                   \"upcall shared_malloc(%\" PRIdPTR \", 0x%\" PRIxPTR \")\",\n-                   nbytes, td);\n-    void *p = task->kernel->malloc(nbytes, \"shared malloc\");\n-    memset(p, '\\0', nbytes);\n+        \"upcall shared_malloc(%\" PRIdPTR \", 0x%\" PRIxPTR \")\",\n+        args->nbytes, args->td);\n+    void *p = task->kernel->malloc(args->nbytes, \"shared malloc\");\n+    memset(p, '\\0', args->nbytes);\n     LOG(task, mem,\n-                   \"upcall shared_malloc(%\" PRIdPTR \", 0x%\" PRIxPTR\n-                   \") = 0x%\" PRIxPTR,\n-                   nbytes, td, (uintptr_t)p);\n+        \"upcall shared_malloc(%\" PRIdPTR \", 0x%\" PRIxPTR\n+        \") = 0x%\" PRIxPTR,\n+        args->nbytes, args->td, (uintptr_t)p);\n     return (uintptr_t) p;\n }\n \n+struct s_shared_free_args {\n+    void *ptr;\n+};\n+\n /**\n  * Called whenever an object's ref count drops to zero.\n  */\n extern \"C\" CDECL void\n-upcall_shared_free(void* ptr) {\n+upcall_s_shared_free(s_shared_free_args *args) {\n     rust_task *task = rust_scheduler::get_task();\n     LOG_UPCALL_ENTRY(task);\n \n     rust_scheduler *sched = task->sched;\n     DLOG(sched, mem,\n              \"upcall shared_free(0x%\" PRIxPTR\")\",\n-             (uintptr_t)ptr);\n-    task->kernel->free(ptr);\n+             (uintptr_t)args->ptr);\n+    task->kernel->free(args->ptr);\n }\n \n+struct s_get_type_desc_args {\n+    size_t size;\n+    size_t align;\n+    size_t n_descs;\n+    type_desc const **descs;\n+    uintptr_t n_obj_params;\n+};\n+\n extern \"C\" CDECL type_desc *\n-upcall_get_type_desc(void *curr_crate, // ignored, legacy compat.\n-                     size_t size,\n-                     size_t align,\n-                     size_t n_descs,\n-                     type_desc const **descs,\n-                     uintptr_t n_obj_params) {\n+upcall_s_get_type_desc(s_get_type_desc_args *args) {\n     rust_task *task = rust_scheduler::get_task();\n     check_stack(task);\n     LOG_UPCALL_ENTRY(task);\n \n     LOG(task, cache, \"upcall get_type_desc with size=%\" PRIdPTR\n-        \", align=%\" PRIdPTR \", %\" PRIdPTR \" descs\", size, align,\n-        n_descs);\n+        \", align=%\" PRIdPTR \", %\" PRIdPTR \" descs\", args->size, args->align,\n+        args->n_descs);\n     rust_crate_cache *cache = task->get_crate_cache();\n-    type_desc *td = cache->get_type_desc(size, align, n_descs, descs,\n-                                         n_obj_params);\n+    type_desc *td = cache->get_type_desc(args->size, args->align, args->n_descs,\n+                                         args->descs, args->n_obj_params);\n     LOG(task, cache, \"returning tydesc 0x%\" PRIxPTR, td);\n     return td;\n }\n \n+struct s_vec_grow_args {\n+    rust_vec** vp;\n+    size_t new_sz;\n+};\n+\n extern \"C\" CDECL void\n-upcall_vec_grow(rust_vec** vp, size_t new_sz) {\n+upcall_s_vec_grow(s_vec_grow_args *args) {\n     rust_task *task = rust_scheduler::get_task();\n     LOG_UPCALL_ENTRY(task);\n-    reserve_vec(task, vp, new_sz);\n-    (*vp)->fill = new_sz;\n+    reserve_vec(task, args->vp, args->new_sz);\n+    (*args->vp)->fill = args->new_sz;\n }\n \n+struct s_vec_push_args {\n+    rust_vec** vp;\n+    type_desc* elt_ty;\n+    void* elt;\n+};\n+\n extern \"C\" CDECL void\n-upcall_vec_push(rust_vec** vp, type_desc* elt_ty, void* elt) {\n+upcall_s_vec_push(s_vec_push_args *args) {\n     rust_task *task = rust_scheduler::get_task();\n     LOG_UPCALL_ENTRY(task);\n-    size_t new_sz = (*vp)->fill + elt_ty->size;\n-    reserve_vec(task, vp, new_sz);\n-    rust_vec* v = *vp;\n-    copy_elements(task, elt_ty, &v->data[0] + v->fill, elt, elt_ty->size);\n-    v->fill += elt_ty->size;\n+    size_t new_sz = (*args->vp)->fill + args->elt_ty->size;\n+    reserve_vec(task, args->vp, new_sz);\n+    rust_vec* v = *args->vp;\n+    copy_elements(task, args->elt_ty, &v->data[0] + v->fill, \n+                  args->elt, args->elt_ty->size);\n+    v->fill += args->elt_ty->size;\n }\n \n /**\n  * Returns a token that can be used to deallocate all of the allocated space\n  * space in the dynamic stack.\n  */\n extern \"C\" CDECL void *\n-upcall_dynastack_mark() {\n+upcall_s_dynastack_mark() {\n     return rust_scheduler::get_task()->dynastack.mark();\n }\n \n+struct s_dynastack_alloc_args {\n+    size_t sz;\n+};\n+\n /**\n  * Allocates space in the dynamic stack and returns it.\n  *\n  * FIXME: Deprecated since dynamic stacks need to be self-describing for GC.\n  */\n extern \"C\" CDECL void *\n-upcall_dynastack_alloc(size_t sz) {\n+upcall_s_dynastack_alloc(s_dynastack_alloc_args *args) {\n+    size_t sz = args->sz;\n     return sz ? rust_scheduler::get_task()->dynastack.alloc(sz, NULL) : NULL;\n }\n \n+struct s_dynastack_alloc_2_args {\n+    size_t sz;\n+    type_desc *ty;\n+};\n+\n /**\n  * Allocates space associated with a type descriptor in the dynamic stack and\n  * returns it.\n  */\n extern \"C\" CDECL void *\n-upcall_dynastack_alloc_2(size_t sz, type_desc *ty) {\n+upcall_s_dynastack_alloc_2(s_dynastack_alloc_2_args *args) {\n+    size_t sz = args->sz;\n+    type_desc *ty = args->ty;\n     return sz ? rust_scheduler::get_task()->dynastack.alloc(sz, ty) : NULL;\n }\n \n+struct s_dynastack_free_args {\n+    void *ptr;\n+};\n+\n /** Frees space in the dynamic stack. */\n extern \"C\" CDECL void\n-upcall_dynastack_free(void *ptr) {\n-    return rust_scheduler::get_task()->dynastack.free(ptr);\n+upcall_s_dynastack_free(s_dynastack_free_args *args) {\n+    return rust_scheduler::get_task()->dynastack.free(args->ptr);\n }\n \n-extern \"C\" void record_sp(void *limit);\n+extern \"C\" _Unwind_Reason_Code\n+__gxx_personality_v0(int version,\n+                     _Unwind_Action actions,\n+                     uint64_t exception_class,\n+                     _Unwind_Exception *ue_header,\n+                     _Unwind_Context *context);\n+\n+struct s_rust_personality_args {\n+    int version;\n+    _Unwind_Action actions;\n+    uint64_t exception_class;\n+    _Unwind_Exception *ue_header;\n+    _Unwind_Context *context;\n+};\n+\n+extern \"C\" _Unwind_Reason_Code\n+upcall_s_rust_personality(s_rust_personality_args *args) {\n+    return __gxx_personality_v0(args->version,\n+                                args->actions,\n+                                args->exception_class,\n+                                args->ue_header,\n+                                args->context);\n+}\n+\n+extern \"C\" void\n+shape_cmp_type(int8_t *result, const type_desc *tydesc,\n+               const type_desc **subtydescs, uint8_t *data_0,\n+               uint8_t *data_1, uint8_t cmp_type);\n+\n+struct s_cmp_type_args {\n+    int8_t *result;\n+    const type_desc *tydesc;\n+    const type_desc **subtydescs;\n+    uint8_t *data_0;\n+    uint8_t *data_1;\n+    uint8_t cmp_type;\n+};\n+\n+extern \"C\" void\n+upcall_s_cmp_type(s_cmp_type_args *args) {\n+    shape_cmp_type(args->result, args->tydesc, args->subtydescs,\n+                   args->data_0, args->data_1, args->cmp_type);\n+}\n+\n+extern \"C\" void\n+shape_log_type(const type_desc *tydesc, uint8_t *data, uint32_t level);\n+\n+struct s_log_type_args {\n+    const type_desc *tydesc;\n+    uint8_t *data;\n+    uint32_t level;\n+};\n+\n+extern \"C\" void\n+upcall_s_log_type(s_log_type_args *args) {\n+    shape_log_type(args->tydesc, args->data, args->level);\n+}\n+\n+\n+// ______________________________________________________________________________\n+// Upcalls in original format: deprecated and should be removed once snapshot\n+// transitions them away.\n+\n+extern \"C\" CDECL void\n+upcall_fail(char const *expr,\n+            char const *file,\n+            size_t line) {\n+    s_fail_args args = {expr,file,line};\n+    upcall_s_fail(&args);\n+}\n+\n+extern \"C\" CDECL uintptr_t\n+upcall_malloc(size_t nbytes, type_desc *td) {\n+    s_malloc_args args = {nbytes, td};\n+    return upcall_s_malloc(&args);\n+}\n \n /**\n- * Switch to the C stack and call the given function, passing a single pointer\n- * argument.\n+ * Called whenever an object's ref count drops to zero.\n  */\n extern \"C\" CDECL void\n-upcall_call_shim_on_c_stack(void *args, void *fn_ptr) {\n-    rust_task *task = rust_scheduler::get_task();\n+upcall_free(void* ptr, uintptr_t is_gc) {\n+    s_free_args args = {ptr, is_gc};\n+    upcall_s_free(&args);\n+}\n \n-    // FIXME (1226) - The shim functions generated by rustc contain the\n-    // morestack prologue, so we need to let them know they have enough\n-    // stack.\n-    record_sp(0);\n+extern \"C\" CDECL uintptr_t\n+upcall_shared_malloc(size_t nbytes, type_desc *td) {\n+    s_shared_malloc_args args = {nbytes, td};\n+    return upcall_s_shared_malloc(&args);\n+}\n \n-    rust_scheduler *sched = task->sched;\n-    try {\n-        sched->c_context.call_shim_on_c_stack(args, fn_ptr);\n-    } catch (...) {\n-        task = rust_scheduler::get_task();\n-        task->record_stack_limit();\n-        throw;\n-    }\n-    task = rust_scheduler::get_task();\n-    task->record_stack_limit();\n+/**\n+ * Called whenever an object's ref count drops to zero.\n+ */\n+extern \"C\" CDECL void\n+upcall_shared_free(void* ptr) {\n+    s_shared_free_args args = {ptr};\n+    upcall_s_shared_free(&args);\n+}\n+\n+extern \"C\" CDECL type_desc *\n+upcall_get_type_desc(void *curr_crate, // ignored, legacy compat.\n+                     size_t size,\n+                     size_t align,\n+                     size_t n_descs,\n+                     type_desc const **descs,\n+                     uintptr_t n_obj_params) {\n+    s_get_type_desc_args args = {size,align,n_descs,descs,n_obj_params};\n+    return upcall_s_get_type_desc(&args);\n+}\n+\n+extern \"C\" CDECL void\n+upcall_vec_grow(rust_vec** vp, size_t new_sz) {\n+    s_vec_grow_args args = {vp, new_sz};\n+    upcall_s_vec_grow(&args);\n+}\n+\n+extern \"C\" CDECL void\n+upcall_vec_push(rust_vec** vp, type_desc* elt_ty, void* elt) {\n+    s_vec_push_args args = {vp, elt_ty, elt};\n+    upcall_s_vec_push(&args);\n+}\n+\n+/**\n+ * Returns a token that can be used to deallocate all of the allocated space\n+ * space in the dynamic stack.\n+ */\n+extern \"C\" CDECL void *\n+upcall_dynastack_mark() {\n+    return upcall_s_dynastack_mark();\n+}\n+\n+/**\n+ * Allocates space in the dynamic stack and returns it.\n+ *\n+ * FIXME: Deprecated since dynamic stacks need to be self-describing for GC.\n+ */\n+extern \"C\" CDECL void *\n+upcall_dynastack_alloc(size_t sz) {\n+    s_dynastack_alloc_args args = {sz};\n+    return upcall_s_dynastack_alloc(&args);\n+}\n+\n+/**\n+ * Allocates space associated with a type descriptor in the dynamic stack and\n+ * returns it.\n+ */\n+extern \"C\" CDECL void *\n+upcall_dynastack_alloc_2(size_t sz, type_desc *ty) {\n+    s_dynastack_alloc_2_args args = {sz, ty};\n+    return upcall_s_dynastack_alloc_2(&args);\n+}\n+\n+/** Frees space in the dynamic stack. */\n+extern \"C\" CDECL void\n+upcall_dynastack_free(void *ptr) {\n+    s_dynastack_free_args args = {ptr};\n+    return upcall_s_dynastack_free(&args);\n+}\n+\n+extern \"C\" _Unwind_Reason_Code\n+upcall_rust_personality(int version,\n+                        _Unwind_Action actions,\n+                        uint64_t exception_class,\n+                        _Unwind_Exception *ue_header,\n+                        _Unwind_Context *context) {\n+    s_rust_personality_args args = {version, actions, exception_class, ue_header, \n+                                    context};\n+    return upcall_s_rust_personality(&args);\n+}\n+\n+extern \"C\" void\n+upcall_cmp_type(int8_t *result, const type_desc *tydesc,\n+                const type_desc **subtydescs, uint8_t *data_0,\n+                uint8_t *data_1, uint8_t cmp_type) {\n+    s_cmp_type_args args = {result, tydesc, subtydescs, data_0, data_1, cmp_type};\n+    upcall_s_cmp_type(&args);\n+}\n+\n+extern \"C\" void\n+upcall_log_type(const type_desc *tydesc, uint8_t *data, uint32_t level) {\n+    s_log_type_args args = {tydesc, data, level};\n+    upcall_s_log_type(&args);\n }\n \n struct rust_new_stack2_args {\n@@ -245,6 +483,8 @@ struct rust_new_stack2_args {\n \n // A new stack function suitable for calling through\n // upcall_call_shim_on_c_stack\n+// FIXME: Convert this to the same arrangement as\n+// the other upcalls, simplify __morestack\n extern \"C\" CDECL void\n upcall_new_stack(struct rust_new_stack2_args *args) {\n     rust_task *task = rust_scheduler::get_task();\n@@ -253,30 +493,21 @@ upcall_new_stack(struct rust_new_stack2_args *args) {\n                                       args->args_sz);\n }\n \n+// FIXME: As above\n extern \"C\" CDECL void\n upcall_del_stack() {\n     rust_task *task = rust_scheduler::get_task();\n     task->del_stack();\n }\n \n-extern \"C\" _Unwind_Reason_Code\n-__gxx_personality_v0(int version,\n-                     _Unwind_Action actions,\n-                     uint64_t exception_class,\n-                     _Unwind_Exception *ue_header,\n-                     _Unwind_Context *context);\n-\n-extern \"C\" _Unwind_Reason_Code\n-upcall_rust_personality(int version,\n-                        _Unwind_Action actions,\n-                        uint64_t exception_class,\n-                        _Unwind_Exception *ue_header,\n-                        _Unwind_Context *context) {\n-    return __gxx_personality_v0(version,\n-                                actions,\n-                                exception_class,\n-                                ue_header,\n-                                context);\n+// Landing pads need to call this to insert the\n+// correct limit into TLS.\n+// NB: This must run on the Rust stack because it\n+// needs to acquire the value of the stack pointer\n+extern \"C\" CDECL void\n+upcall_reset_stack_limit() {\n+    rust_task *task = rust_scheduler::get_task();\n+    task->reset_stack_limit();\n }\n \n //\n@@ -286,6 +517,5 @@ upcall_rust_personality(int version,\n // indent-tabs-mode: nil\n // c-basic-offset: 4\n // buffer-file-coding-system: utf-8-unix\n-// compile-command: \"make -k -C $RBUILD 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n // End:\n //"}, {"sha": "306c750c8fbb2a96e79b4257911ce09fb851d2c7", "filename": "src/rt/rustrt.def.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a3f48d3fe1d90a4684cb20e75688ffbca804e82c/src%2Frt%2Frustrt.def.in", "raw_url": "https://github.com/rust-lang/rust/raw/a3f48d3fe1d90a4684cb20e75688ffbca804e82c/src%2Frt%2Frustrt.def.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frustrt.def.in?ref=a3f48d3fe1d90a4684cb20e75688ffbca804e82c", "patch": "@@ -69,6 +69,7 @@ upcall_vec_push\n upcall_call_shim_on_c_stack\n upcall_new_stack\n upcall_del_stack\n+upcall_reset_stack_limit\n asm_call_on_stack\n rust_uv_default_loop\n rust_uv_loop_new"}, {"sha": "d030971363352cbdc4af50ca8eedad32b57d7785", "filename": "src/test/bench/task-perf-word-count.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a3f48d3fe1d90a4684cb20e75688ffbca804e82c/src%2Ftest%2Fbench%2Ftask-perf-word-count.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3f48d3fe1d90a4684cb20e75688ffbca804e82c/src%2Ftest%2Fbench%2Ftask-perf-word-count.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-word-count.rs?ref=a3f48d3fe1d90a4684cb20e75688ffbca804e82c", "patch": "@@ -112,29 +112,29 @@ mod map_reduce {\n \n         send(out, chan(p));\n \n-        let ref_count = 0;\n-        let is_done = false;\n+        let state = @{mutable ref_count: 0, mutable is_done: false};\n \n-        fn get(p: port<reduce_proto>, &ref_count: int, &is_done: bool) ->\n-           option<int> {\n-            while !is_done || ref_count > 0 {\n+        fn get(p: port<reduce_proto>, state: @{mutable ref_count: int,\n+                                               mutable is_done: bool})\n+            -> option<int> {\n+            while !state.is_done || state.ref_count > 0 {\n                 alt recv(p) {\n                   emit_val(v) {\n                     // log_err #fmt(\"received %d\", v);\n                     ret some(v);\n                   }\n                   done. {\n                     // log_err \"all done\";\n-                    is_done = true;\n+                    state.is_done = true;\n                   }\n-                  ref. { ref_count += 1; }\n-                  release. { ref_count -= 1; }\n+                  ref. { state.ref_count += 1; }\n+                  release. { state.ref_count -= 1; }\n                 }\n             }\n             ret none;\n         }\n \n-        reduce(key, bind get(p, ref_count, is_done));\n+        reduce(key, bind get(p, state));\n     }\n \n     fn map_reduce(-inputs: [str]) {"}, {"sha": "9796017a8eb0885d5a5135d9e8e19f4e95daa6a3", "filename": "src/test/run-fail/morestack3.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a3f48d3fe1d90a4684cb20e75688ffbca804e82c/src%2Ftest%2Frun-fail%2Fmorestack3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3f48d3fe1d90a4684cb20e75688ffbca804e82c/src%2Ftest%2Frun-fail%2Fmorestack3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fmorestack3.rs?ref=a3f48d3fe1d90a4684cb20e75688ffbca804e82c", "patch": "@@ -25,10 +25,10 @@ resource and_then_get_big_again(_i: @int) {\n             getbig(i - 1);\n         }\n     }\n-    getbig(1000);\n+    getbig(100);\n }\n \n fn main() {\n     rustrt::set_min_stack(256u);\n-    std::task::spawn(1000, getbig_and_fail);\n+    std::task::spawn(100, getbig_and_fail);\n }\n\\ No newline at end of file"}, {"sha": "2fba1ebb1961528148faf770f5ecd3d271be0702", "filename": "src/test/stdtest/treemap.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a3f48d3fe1d90a4684cb20e75688ffbca804e82c/src%2Ftest%2Fstdtest%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3f48d3fe1d90a4684cb20e75688ffbca804e82c/src%2Ftest%2Fstdtest%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Ftreemap.rs?ref=a3f48d3fe1d90a4684cb20e75688ffbca804e82c", "patch": "@@ -39,8 +39,8 @@ fn traverse_in_order() {\n     insert(m, 2, ());\n     insert(m, 1, ());\n \n-    let n = 0;\n-    fn t(&n: int, &&k: int, &&_v: ()) { assert (n == k); n += 1; }\n+    let n = @mutable 0;\n+    fn t(n: @mutable int, &&k: int, &&_v: ()) { assert (*n == k); *n += 1; }\n     traverse(m, bind t(n, _, _));\n }\n "}]}