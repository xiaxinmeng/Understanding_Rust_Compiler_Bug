{"sha": "d11c88738247123cdd0a1d4429acbca164269a1d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQxMWM4ODczODI0NzEyM2NkZDBhMWQ0NDI5YWNiY2ExNjQyNjlhMWQ=", "commit": {"author": {"name": "Paul Stansifer", "email": "paul.stansifer@gmail.com", "date": "2011-07-26T17:53:14Z"}, "committer": {"name": "Paul Stansifer", "email": "paul.stansifer@gmail.com", "date": "2011-07-26T18:09:37Z"}, "message": "Add basic support for blocks and types in macros.", "tree": {"sha": "f366c460c28628481ccfecd2c695db447fc155f0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f366c460c28628481ccfecd2c695db447fc155f0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d11c88738247123cdd0a1d4429acbca164269a1d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d11c88738247123cdd0a1d4429acbca164269a1d", "html_url": "https://github.com/rust-lang/rust/commit/d11c88738247123cdd0a1d4429acbca164269a1d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d11c88738247123cdd0a1d4429acbca164269a1d/comments", "author": {"login": "paulstansifer", "id": 1431, "node_id": "MDQ6VXNlcjE0MzE=", "avatar_url": "https://avatars.githubusercontent.com/u/1431?v=4", "gravatar_id": "", "url": "https://api.github.com/users/paulstansifer", "html_url": "https://github.com/paulstansifer", "followers_url": "https://api.github.com/users/paulstansifer/followers", "following_url": "https://api.github.com/users/paulstansifer/following{/other_user}", "gists_url": "https://api.github.com/users/paulstansifer/gists{/gist_id}", "starred_url": "https://api.github.com/users/paulstansifer/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/paulstansifer/subscriptions", "organizations_url": "https://api.github.com/users/paulstansifer/orgs", "repos_url": "https://api.github.com/users/paulstansifer/repos", "events_url": "https://api.github.com/users/paulstansifer/events{/privacy}", "received_events_url": "https://api.github.com/users/paulstansifer/received_events", "type": "User", "site_admin": false}, "committer": {"login": "paulstansifer", "id": 1431, "node_id": "MDQ6VXNlcjE0MzE=", "avatar_url": "https://avatars.githubusercontent.com/u/1431?v=4", "gravatar_id": "", "url": "https://api.github.com/users/paulstansifer", "html_url": "https://github.com/paulstansifer", "followers_url": "https://api.github.com/users/paulstansifer/followers", "following_url": "https://api.github.com/users/paulstansifer/following{/other_user}", "gists_url": "https://api.github.com/users/paulstansifer/gists{/gist_id}", "starred_url": "https://api.github.com/users/paulstansifer/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/paulstansifer/subscriptions", "organizations_url": "https://api.github.com/users/paulstansifer/orgs", "repos_url": "https://api.github.com/users/paulstansifer/repos", "events_url": "https://api.github.com/users/paulstansifer/events{/privacy}", "received_events_url": "https://api.github.com/users/paulstansifer/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e133f929b782a0697c4aa9ad708ad88e7fe08491", "url": "https://api.github.com/repos/rust-lang/rust/commits/e133f929b782a0697c4aa9ad708ad88e7fe08491", "html_url": "https://github.com/rust-lang/rust/commit/e133f929b782a0697c4aa9ad708ad88e7fe08491"}], "stats": {"total": 134, "additions": 127, "deletions": 7}, "files": [{"sha": "9ab3f188aade808036e789d78a6ab9bf3cb0c838", "filename": "src/comp/syntax/ext/simplext.rs", "status": "modified", "additions": 123, "deletions": 7, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/d11c88738247123cdd0a1d4429acbca164269a1d/src%2Fcomp%2Fsyntax%2Fext%2Fsimplext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d11c88738247123cdd0a1d4429acbca164269a1d/src%2Fcomp%2Fsyntax%2Fext%2Fsimplext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Fsimplext.rs?ref=d11c88738247123cdd0a1d4429acbca164269a1d", "patch": "@@ -23,6 +23,7 @@ import ast::ident;\n import ast::path;\n import ast::ty;\n import ast::blk;\n+import ast::blk_;\n import ast::expr;\n import ast::expr_;\n import ast::path_;\n@@ -218,6 +219,10 @@ fn transcribe(&ext_ctxt cx, &bindings b, @expr body) -> @expr {\n             fold_path = bind transcribe_path(cx, b, idx_path, _, _),\n             fold_expr = bind transcribe_expr(cx, b, idx_path, _, _,\n                                              afp.fold_expr),\n+            fold_ty = bind transcribe_type(cx, b, idx_path, _, _,\n+                                           afp.fold_ty),\n+            fold_block = bind transcribe_block(cx, b, idx_path, _, _, \n+                                               afp.fold_block),\n             map_exprs = bind transcribe_exprs(cx, b, idx_path, _, _)\n             with *afp);\n     auto f = make_fold(f_pre);\n@@ -390,8 +395,45 @@ fn transcribe_expr(&ext_ctxt cx, &bindings b, @mutable vec[uint] idx_path,\n     }\n }\n \n+fn transcribe_type(&ext_ctxt cx, &bindings b, @mutable vec[uint] idx_path,\n+                   &ast::ty_ t, ast_fold fld,\n+                   fn(&ast::ty_, ast_fold) -> ast::ty_ orig) -> ast::ty_ {\n+    ret alt(t) {\n+      case (ast::ty_path(?pth,_)) {\n+        alt (path_to_ident(pth)) {\n+          case (some(?id)) {\n+            alt (follow_for_trans(cx, b.find(id), idx_path)) {\n+              case (some(match_ty(?ty))) { ty.node }\n+              case (some(?m)) { match_error(cx, m, \"a type\") }\n+              case (none) { orig(t, fld) }\n+            }\n+          }\n+          case (none) { orig(t, fld) }\n+        }\n+      }\n+      case (_) { orig(t, fld) }\n+    }\n+}\n \n \n+/* for parsing reasons, syntax variables bound to blocks must be used like\n+`{v}` */\n+\n+fn transcribe_block(&ext_ctxt cx, &bindings b, @mutable vec[uint] idx_path,\n+                    &blk_ blk, ast_fold fld,\n+                    fn(&blk_, ast_fold) -> blk_ orig) -> blk_ {\n+    ret alt (block_to_ident(blk)) {\n+      case (some(?id)) {\n+        alt (follow_for_trans(cx, b.find(id), idx_path)) {\n+          case (some(match_block(?new_blk))) { new_blk.node }\n+          // possibly allow promotion of ident/path/expr to blocks?\n+          case (some(?m)) { match_error(cx, m, \"a block\")}\n+          case (none) { orig(blk, fld) }\n+        }\n+      }\n+      case (none) { orig(blk, fld) }\n+    }\n+}\n \n \n /* traverse the pattern, building instructions on how to bind the actual\n@@ -415,13 +457,17 @@ fn p_t_s_rec(&ext_ctxt cx, &matchable m, &selector s, &binders b) {\n             }\n           }\n           /* TODO: handle embedded types and blocks, at least */\n+          case (expr_mac(?mac)) {\n+            p_t_s_r_mac(cx, mac, s, b);\n+          }\n           case (_) {\n             fn select(&ext_ctxt cx, &matchable m, @expr pat)\n                 -> match_result {\n                 ret alt(m) {\n                   case (match_expr(?e)) {\n                     if (e==pat) { some(leaf(match_exact)) } else { none }\n                   }\n+                  case (_) { cx.bug(\"broken traversal in p_t_s_r\"); fail }\n                 }\n             }\n             b.literal_ast_matchers += ~[bind select(cx,_,e)];\n@@ -439,12 +485,8 @@ fn specialize_match(&matchable m) -> matchable {\n         alt (e.node) {\n           case (expr_path(?pth)) {\n             alt (path_to_ident(pth)) {\n-              case (some(?id)) {\n-                match_ident(respan(pth.span,id))\n-              }\n-              case (none) {\n-                match_path(pth)\n-              }\n+              case (some(?id)) { match_ident(respan(pth.span,id)) }\n+              case (none) { match_path(pth) }\n             }\n           }\n           case (_) { m }\n@@ -454,7 +496,7 @@ fn specialize_match(&matchable m) -> matchable {\n     }\n }\n \n-/* Too much indentation, had to pull these out */\n+/* pattern_to_selectors helper functions */\n fn p_t_s_r_path(&ext_ctxt cx, &path p, &selector s, &binders b) {\n     alt (path_to_ident(p)) {\n       case (some(?p_id)) {\n@@ -473,6 +515,80 @@ fn p_t_s_r_path(&ext_ctxt cx, &path p, &selector s, &binders b) {\n     }\n }\n \n+fn block_to_ident(&blk_ blk) -> option::t[ident] {\n+    if(ivec::len(blk.stmts) != 0u) { ret none; }\n+    ret alt (blk.expr) {\n+      case (some(?expr)) {\n+        alt (expr.node) {\n+          case (expr_path(?pth)) { path_to_ident(pth) }\n+          case (_) { none }\n+        }\n+      }\n+      case(none) { none }\n+    }\n+}\n+\n+fn p_t_s_r_mac(&ext_ctxt cx, &ast::mac mac, &selector s, &binders b) {\n+    fn select_pt_1(&ext_ctxt cx, &matchable m, fn(&ast::mac) ->\n+                   match_result fn_m) -> match_result {\n+        ret alt(m) {\n+          case (match_expr(?e)) {\n+            alt(e.node) {\n+              case (expr_mac(?mac)) { fn_m(mac) }\n+              case (_) { none }\n+            }\n+          }\n+          case (_) { cx.bug(\"broken traversal in p_t_s_r\"); fail }\n+        }\n+    }\n+    fn no_des(&ext_ctxt cx, &span sp, &str syn) -> ! {\n+        cx.span_fatal(sp, \"destructuring \"+syn+\" is not yet supported\");\n+    }\n+    alt (mac.node) {\n+      case (ast::mac_ellipsis) { cx.span_fatal(mac.span, \"misused `...`\"); }\n+      case (ast::mac_invoc(_,_, _)) { no_des(cx, mac.span, \"macro calls\"); }\n+      case (ast::mac_embed_type(?ty)) {\n+        alt (ty.node) {\n+          case ast::ty_path(?pth, _) {\n+            alt (path_to_ident(pth)) {\n+              case (some(?id)) {\n+                /* look for an embedded type */\n+                fn select_pt_2(&ast::mac m) -> match_result {\n+                    ret alt (m.node) {\n+                      case (ast::mac_embed_type(?t)) {\n+                        some(leaf(match_ty(t)))\n+                      }\n+                      case (_) { none }\n+                    }\n+                }\n+                b.real_binders.insert(id,\n+                                      bind select_pt_1(cx, _, select_pt_2));\n+              }\n+              case (none) { no_des(cx, pth.span, \"under `#<>`\"); }\n+            }\n+          }\n+          case (_) { no_des(cx, ty.span, \"under `#<>`\"); }\n+        }\n+      }\n+      case (ast::mac_embed_block(?blk)) {\n+        alt (block_to_ident(blk.node)) {\n+          case (some(?id)) {\n+            fn select_pt_2(&ast::mac m) -> match_result {\n+                ret alt (m.node) {\n+                  case (ast::mac_embed_block(?blk)) {\n+                    some(leaf(match_block(blk)))\n+                  }\n+                  case (_) { none }\n+                }\n+            }\n+            b.real_binders.insert(id, bind select_pt_1(cx, _, select_pt_2));\n+          }\n+          case (none) { no_des(cx, blk.span, \"under `#{}`\"); }\n+        }\n+      }\n+    }\n+}\n+\n /* TODO: move this to vec.rs */\n \n fn ivec_to_vec[T](&(T)[] v) -> vec[T] {"}, {"sha": "4c459fab6b2b286c9fb48c6b6a0dcaadf74d682a", "filename": "src/test/run-pass/macro-by-example-2.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d11c88738247123cdd0a1d4429acbca164269a1d/src%2Ftest%2Frun-pass%2Fmacro-by-example-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d11c88738247123cdd0a1d4429acbca164269a1d/src%2Ftest%2Frun-pass%2Fmacro-by-example-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmacro-by-example-2.rs?ref=d11c88738247123cdd0a1d4429acbca164269a1d", "patch": "@@ -20,5 +20,9 @@ fn main() {\n     assert(#dup([1,[1,2,3,4]]) == [[1,1], [1,2], [1,3], [1,4]]);\n \n \n+    #macro([#lambda(x, #<t>, body, #<s>),\n+            {fn result(t x) -> s { ret body }; result}]);\n+\n+    assert(#lambda(i, #<uint>, i+4u, #<uint>)(12u) == 16u)\n \n }\n\\ No newline at end of file"}]}