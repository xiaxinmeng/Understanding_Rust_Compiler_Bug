{"sha": "775e96970fa5c4af239becc16c78c8a37e8b25e9", "node_id": "C_kwDOAAsO6NoAKDc3NWU5Njk3MGZhNWM0YWYyMzliZWNjMTZjNzhjOGEzN2U4YjI1ZTk", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-08-31T12:29:51Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-08-31T12:29:51Z"}, "message": "Rollup merge of #90946 - GuillaumeGomez:def-id-remove-weird-case, r=Manishearth\n\nIgnore `reference`s in \"Type::inner_def_id\"\n\nFixes #90775.\n\nReopening of #90726.\n\nAs discussed on [zulip](https://rust-lang.zulipchat.com/#narrow/stream/266220-rustdoc/topic/rendering.20for.20reference.20primitive.20doc.20page), the reference page shouldn't list these implementations (since they are listed on the types and on the traits in any case). And more generally, you don't implement something on a reference but on something behind a reference. I think it's the important point.\n\nSo currently it looks like this:\n\n![Screenshot from 2021-11-16 10-20-41](https://user-images.githubusercontent.com/3050060/141957799-57aeadc5-41f8-45f6-a4a5-33b1eca6a500.png)\n\nWith this PR, only the implementations over generics behind a reference are kept.\n\nYou can test it [here](https://rustdoc.crud.net/imperio/def-id-remove-weird-case/std/primitive.reference.html).\n\ncc ``@camelid``", "tree": {"sha": "14f464d8d8fdfc50c6da0033722a469f406c12f7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/14f464d8d8fdfc50c6da0033722a469f406c12f7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/775e96970fa5c4af239becc16c78c8a37e8b25e9", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjD1Q/CRBK7hj4Ov3rIwAAAH0IAILBurRSPyXYikOWPZ6CPgm0\nwhZ28zYfQ1UHe0wL+yX2hs+myEMCNoIdct2A+QOYH5rHVmVxBwf2Lrw5C0o0QJwR\naFDgHuVBgmF3ZvzGhN6wUF4foZXeNAo+H0NipW11IOrSUZ2VkW4NkE1i2M9rY7df\nVu+peSWSisbOd8LK0pbEwSgAF5eT0AcYUA6ePPDB/1B6cSTtLH5v6eCbS6aOfHzj\nxbZiRCKnuj6z5+dRkP8a4SOdfNGrZKppEm3mOxH/jLsYOy+bO8T3es9uLeb2SNx8\n89PcQmlIpQZDnHf8Tn8CSMuxEVwvsW70cYChAPDFZtsiRoNoN6ZODL7KHmsBXo4=\n=X3QK\n-----END PGP SIGNATURE-----\n", "payload": "tree 14f464d8d8fdfc50c6da0033722a469f406c12f7\nparent 12e4fd0755d7d976d4ee0f2004dc938290752ff7\nparent 477b7ba1657986a31b60ccf149011c037ef649d1\nauthor Ralf Jung <post@ralfj.de> 1661948991 +0200\ncommitter GitHub <noreply@github.com> 1661948991 +0200\n\nRollup merge of #90946 - GuillaumeGomez:def-id-remove-weird-case, r=Manishearth\n\nIgnore `reference`s in \"Type::inner_def_id\"\n\nFixes #90775.\n\nReopening of #90726.\n\nAs discussed on [zulip](https://rust-lang.zulipchat.com/#narrow/stream/266220-rustdoc/topic/rendering.20for.20reference.20primitive.20doc.20page), the reference page shouldn't list these implementations (since they are listed on the types and on the traits in any case). And more generally, you don't implement something on a reference but on something behind a reference. I think it's the important point.\n\nSo currently it looks like this:\n\n![Screenshot from 2021-11-16 10-20-41](https://user-images.githubusercontent.com/3050060/141957799-57aeadc5-41f8-45f6-a4a5-33b1eca6a500.png)\n\nWith this PR, only the implementations over generics behind a reference are kept.\n\nYou can test it [here](https://rustdoc.crud.net/imperio/def-id-remove-weird-case/std/primitive.reference.html).\n\ncc ``@camelid``\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/775e96970fa5c4af239becc16c78c8a37e8b25e9", "html_url": "https://github.com/rust-lang/rust/commit/775e96970fa5c4af239becc16c78c8a37e8b25e9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/775e96970fa5c4af239becc16c78c8a37e8b25e9/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "12e4fd0755d7d976d4ee0f2004dc938290752ff7", "url": "https://api.github.com/repos/rust-lang/rust/commits/12e4fd0755d7d976d4ee0f2004dc938290752ff7", "html_url": "https://github.com/rust-lang/rust/commit/12e4fd0755d7d976d4ee0f2004dc938290752ff7"}, {"sha": "477b7ba1657986a31b60ccf149011c037ef649d1", "url": "https://api.github.com/repos/rust-lang/rust/commits/477b7ba1657986a31b60ccf149011c037ef649d1", "html_url": "https://github.com/rust-lang/rust/commit/477b7ba1657986a31b60ccf149011c037ef649d1"}], "stats": {"total": 337, "additions": 219, "deletions": 118}, "files": [{"sha": "cf43033d1d29a0b40e82304a3da4e5a86615f323", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 167, "deletions": 113, "changes": 280, "blob_url": "https://github.com/rust-lang/rust/blob/775e96970fa5c4af239becc16c78c8a37e8b25e9/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/775e96970fa5c4af239becc16c78c8a37e8b25e9/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=775e96970fa5c4af239becc16c78c8a37e8b25e9", "patch": "@@ -613,10 +613,10 @@ fn short_item_info(\n \n // Render the list of items inside one of the sections \"Trait Implementations\",\n // \"Auto Trait Implementations,\" \"Blanket Trait Implementations\" (on struct/enum pages).\n-fn render_impls(\n+pub(crate) fn render_impls(\n     cx: &mut Context<'_>,\n     w: &mut Buffer,\n-    impls: &[&&Impl],\n+    impls: &[&Impl],\n     containing_item: &clean::Item,\n     toggle_open_by_default: bool,\n ) {\n@@ -1025,6 +1025,47 @@ impl<'a> AssocItemLink<'a> {\n     }\n }\n \n+fn write_impl_section_heading(w: &mut Buffer, title: &str, id: &str) {\n+    write!(\n+        w,\n+        \"<h2 id=\\\"{id}\\\" class=\\\"small-section-header\\\">\\\n+            {title}\\\n+            <a href=\\\"#{id}\\\" class=\\\"anchor\\\"></a>\\\n+         </h2>\"\n+    );\n+}\n+\n+pub(crate) fn render_all_impls(\n+    w: &mut Buffer,\n+    cx: &mut Context<'_>,\n+    containing_item: &clean::Item,\n+    concrete: &[&Impl],\n+    synthetic: &[&Impl],\n+    blanket_impl: &[&Impl],\n+) {\n+    let mut impls = Buffer::empty_from(w);\n+    render_impls(cx, &mut impls, concrete, containing_item, true);\n+    let impls = impls.into_inner();\n+    if !impls.is_empty() {\n+        write_impl_section_heading(w, \"Trait Implementations\", \"trait-implementations\");\n+        write!(w, \"<div id=\\\"trait-implementations-list\\\">{}</div>\", impls);\n+    }\n+\n+    if !synthetic.is_empty() {\n+        write_impl_section_heading(w, \"Auto Trait Implementations\", \"synthetic-implementations\");\n+        w.write_str(\"<div id=\\\"synthetic-implementations-list\\\">\");\n+        render_impls(cx, w, synthetic, containing_item, false);\n+        w.write_str(\"</div>\");\n+    }\n+\n+    if !blanket_impl.is_empty() {\n+        write_impl_section_heading(w, \"Blanket Implementations\", \"blanket-implementations\");\n+        w.write_str(\"<div id=\\\"blanket-implementations-list\\\">\");\n+        render_impls(cx, w, blanket_impl, containing_item, false);\n+        w.write_str(\"</div>\");\n+    }\n+}\n+\n fn render_assoc_items(\n     w: &mut Buffer,\n     cx: &mut Context<'_>,\n@@ -1054,12 +1095,7 @@ fn render_assoc_items_inner(\n         let mut tmp_buf = Buffer::empty_from(w);\n         let (render_mode, id) = match what {\n             AssocItemRender::All => {\n-                tmp_buf.write_str(\n-                    \"<h2 id=\\\"implementations\\\" class=\\\"small-section-header\\\">\\\n-                         Implementations\\\n-                         <a href=\\\"#implementations\\\" class=\\\"anchor\\\"></a>\\\n-                     </h2>\",\n-                );\n+                write_impl_section_heading(&mut tmp_buf, \"Implementations\", \"implementations\");\n                 (RenderMode::Normal, \"implementations-list\".to_owned())\n             }\n             AssocItemRender::DerefFor { trait_, type_, deref_mut_ } => {\n@@ -1068,15 +1104,14 @@ fn render_assoc_items_inner(\n                 if let Some(def_id) = type_.def_id(cx.cache()) {\n                     cx.deref_id_map.insert(def_id, id.clone());\n                 }\n-                write!(\n-                    tmp_buf,\n-                    \"<h2 id=\\\"{id}\\\" class=\\\"small-section-header\\\">\\\n-                         <span>Methods from {trait_}&lt;Target = {type_}&gt;</span>\\\n-                         <a href=\\\"#{id}\\\" class=\\\"anchor\\\"></a>\\\n-                     </h2>\",\n-                    id = id,\n-                    trait_ = trait_.print(cx),\n-                    type_ = type_.print(cx),\n+                write_impl_section_heading(\n+                    &mut tmp_buf,\n+                    &format!(\n+                        \"<span>Methods from {trait_}&lt;Target = {type_}&gt;</span>\",\n+                        trait_ = trait_.print(cx),\n+                        type_ = type_.print(cx),\n+                    ),\n+                    &id,\n                 );\n                 (RenderMode::ForDeref { mut_: deref_mut_ }, cx.derive_id(id))\n             }\n@@ -1123,49 +1158,12 @@ fn render_assoc_items_inner(\n             return;\n         }\n \n-        let (synthetic, concrete): (Vec<&&Impl>, Vec<&&Impl>) =\n-            traits.iter().partition(|t| t.inner_impl().kind.is_auto());\n-        let (blanket_impl, concrete): (Vec<&&Impl>, _) =\n+        let (synthetic, concrete): (Vec<&Impl>, Vec<&Impl>) =\n+            traits.into_iter().partition(|t| t.inner_impl().kind.is_auto());\n+        let (blanket_impl, concrete): (Vec<&Impl>, _) =\n             concrete.into_iter().partition(|t| t.inner_impl().kind.is_blanket());\n \n-        let mut impls = Buffer::empty_from(w);\n-        render_impls(cx, &mut impls, &concrete, containing_item, true);\n-        let impls = impls.into_inner();\n-        if !impls.is_empty() {\n-            write!(\n-                w,\n-                \"<h2 id=\\\"trait-implementations\\\" class=\\\"small-section-header\\\">\\\n-                     Trait Implementations\\\n-                     <a href=\\\"#trait-implementations\\\" class=\\\"anchor\\\"></a>\\\n-                 </h2>\\\n-                 <div id=\\\"trait-implementations-list\\\">{}</div>\",\n-                impls\n-            );\n-        }\n-\n-        if !synthetic.is_empty() {\n-            w.write_str(\n-                \"<h2 id=\\\"synthetic-implementations\\\" class=\\\"small-section-header\\\">\\\n-                     Auto Trait Implementations\\\n-                     <a href=\\\"#synthetic-implementations\\\" class=\\\"anchor\\\"></a>\\\n-                 </h2>\\\n-                 <div id=\\\"synthetic-implementations-list\\\">\",\n-            );\n-            render_impls(cx, w, &synthetic, containing_item, false);\n-            w.write_str(\"</div>\");\n-        }\n-\n-        if !blanket_impl.is_empty() {\n-            w.write_str(\n-                \"<h2 id=\\\"blanket-implementations\\\" class=\\\"small-section-header\\\">\\\n-                     Blanket Implementations\\\n-                     <a href=\\\"#blanket-implementations\\\" class=\\\"anchor\\\"></a>\\\n-                 </h2>\\\n-                 <div id=\\\"blanket-implementations-list\\\">\",\n-            );\n-            render_impls(cx, w, &blanket_impl, containing_item, false);\n-            w.write_str(\"</div>\");\n-        }\n+        render_all_impls(w, cx, containing_item, &concrete, &synthetic, &blanket_impl);\n     }\n }\n \n@@ -1970,6 +1968,70 @@ fn small_url_encode(s: String) -> String {\n     }\n }\n \n+pub(crate) fn sidebar_render_assoc_items(\n+    cx: &Context<'_>,\n+    out: &mut Buffer,\n+    id_map: &mut IdMap,\n+    concrete: Vec<&Impl>,\n+    synthetic: Vec<&Impl>,\n+    blanket_impl: Vec<&Impl>,\n+) {\n+    let format_impls = |impls: Vec<&Impl>, id_map: &mut IdMap| {\n+        let mut links = FxHashSet::default();\n+\n+        let mut ret = impls\n+            .iter()\n+            .filter_map(|it| {\n+                let trait_ = it.inner_impl().trait_.as_ref()?;\n+                let encoded =\n+                    id_map.derive(get_id_for_impl(&it.inner_impl().for_, Some(trait_), cx));\n+\n+                let i_display = format!(\"{:#}\", trait_.print(cx));\n+                let out = Escape(&i_display);\n+                let prefix = match it.inner_impl().polarity {\n+                    ty::ImplPolarity::Positive | ty::ImplPolarity::Reservation => \"\",\n+                    ty::ImplPolarity::Negative => \"!\",\n+                };\n+                let generated = format!(\"<a href=\\\"#{}\\\">{}{}</a>\", encoded, prefix, out);\n+                if links.insert(generated.clone()) { Some(generated) } else { None }\n+            })\n+            .collect::<Vec<String>>();\n+        ret.sort();\n+        ret\n+    };\n+\n+    let concrete_format = format_impls(concrete, id_map);\n+    let synthetic_format = format_impls(synthetic, id_map);\n+    let blanket_format = format_impls(blanket_impl, id_map);\n+\n+    if !concrete_format.is_empty() {\n+        print_sidebar_block(\n+            out,\n+            \"trait-implementations\",\n+            \"Trait Implementations\",\n+            concrete_format.iter(),\n+        );\n+    }\n+\n+    if !synthetic_format.is_empty() {\n+        print_sidebar_block(\n+            out,\n+            \"synthetic-implementations\",\n+            \"Auto Trait Implementations\",\n+            synthetic_format.iter(),\n+        );\n+    }\n+\n+    if !blanket_format.is_empty() {\n+        print_sidebar_block(\n+            out,\n+            \"blanket-implementations\",\n+            \"Blanket Implementations\",\n+            blanket_format.iter(),\n+        );\n+    }\n+}\n+\n fn sidebar_assoc_items(cx: &Context<'_>, out: &mut Buffer, it: &clean::Item) {\n     let did = it.item_id.expect_def_id();\n     let cache = cx.cache();\n@@ -2018,65 +2080,12 @@ fn sidebar_assoc_items(cx: &Context<'_>, out: &mut Buffer, it: &clean::Item) {\n                 sidebar_deref_methods(cx, out, impl_, v, &mut derefs, &mut used_links);\n             }\n \n-            let format_impls = |impls: Vec<&Impl>, id_map: &mut IdMap| {\n-                let mut links = FxHashSet::default();\n-\n-                let mut ret = impls\n-                    .iter()\n-                    .filter_map(|it| {\n-                        let trait_ = it.inner_impl().trait_.as_ref()?;\n-                        let encoded =\n-                            id_map.derive(get_id_for_impl(&it.inner_impl().for_, Some(trait_), cx));\n-\n-                        let i_display = format!(\"{:#}\", trait_.print(cx));\n-                        let out = Escape(&i_display);\n-                        let prefix = match it.inner_impl().polarity {\n-                            ty::ImplPolarity::Positive | ty::ImplPolarity::Reservation => \"\",\n-                            ty::ImplPolarity::Negative => \"!\",\n-                        };\n-                        let generated = format!(\"<a href=\\\"#{}\\\">{}{}</a>\", encoded, prefix, out);\n-                        if links.insert(generated.clone()) { Some(generated) } else { None }\n-                    })\n-                    .collect::<Vec<String>>();\n-                ret.sort();\n-                ret\n-            };\n-\n             let (synthetic, concrete): (Vec<&Impl>, Vec<&Impl>) =\n                 v.iter().partition::<Vec<_>, _>(|i| i.inner_impl().kind.is_auto());\n             let (blanket_impl, concrete): (Vec<&Impl>, Vec<&Impl>) =\n                 concrete.into_iter().partition::<Vec<_>, _>(|i| i.inner_impl().kind.is_blanket());\n \n-            let concrete_format = format_impls(concrete, &mut id_map);\n-            let synthetic_format = format_impls(synthetic, &mut id_map);\n-            let blanket_format = format_impls(blanket_impl, &mut id_map);\n-\n-            if !concrete_format.is_empty() {\n-                print_sidebar_block(\n-                    out,\n-                    \"trait-implementations\",\n-                    \"Trait Implementations\",\n-                    concrete_format.iter(),\n-                );\n-            }\n-\n-            if !synthetic_format.is_empty() {\n-                print_sidebar_block(\n-                    out,\n-                    \"synthetic-implementations\",\n-                    \"Auto Trait Implementations\",\n-                    synthetic_format.iter(),\n-                );\n-            }\n-\n-            if !blanket_format.is_empty() {\n-                print_sidebar_block(\n-                    out,\n-                    \"blanket-implementations\",\n-                    \"Blanket Implementations\",\n-                    blanket_format.iter(),\n-                );\n-            }\n+            sidebar_render_assoc_items(cx, out, &mut id_map, concrete, synthetic, blanket_impl);\n         }\n     }\n }\n@@ -2346,9 +2355,54 @@ fn sidebar_trait(cx: &Context<'_>, buf: &mut Buffer, it: &clean::Item, t: &clean\n     buf.push_str(\"</section>\")\n }\n \n+/// Returns the list of implementations for the primitive reference type, filtering out any\n+/// implementations that are on concrete or partially generic types, only keeping implementations\n+/// of the form `impl<T> Trait for &T`.\n+pub(crate) fn get_filtered_impls_for_reference<'a>(\n+    shared: &'a Rc<SharedContext<'_>>,\n+    it: &clean::Item,\n+) -> (Vec<&'a Impl>, Vec<&'a Impl>, Vec<&'a Impl>) {\n+    let def_id = it.item_id.expect_def_id();\n+    // If the reference primitive is somehow not defined, exit early.\n+    let Some(v) = shared.cache.impls.get(&def_id) else { return (Vec::new(), Vec::new(), Vec::new()) };\n+    // Since there is no \"direct implementation\" on the reference primitive type, we filter out\n+    // every implementation which isn't a trait implementation.\n+    let traits: Vec<_> = v.iter().filter(|i| i.inner_impl().trait_.is_some()).collect();\n+    let (synthetic, concrete): (Vec<&Impl>, Vec<&Impl>) =\n+        traits.into_iter().partition(|t| t.inner_impl().kind.is_auto());\n+\n+    let (blanket_impl, concrete): (Vec<&Impl>, _) =\n+        concrete.into_iter().partition(|t| t.inner_impl().kind.is_blanket());\n+    // Now we keep only references over full generic types.\n+    let concrete: Vec<_> = concrete\n+        .into_iter()\n+        .filter(|t| match t.inner_impl().for_ {\n+            clean::Type::BorrowedRef { ref type_, .. } => type_.is_full_generic(),\n+            _ => false,\n+        })\n+        .collect();\n+\n+    (concrete, synthetic, blanket_impl)\n+}\n+\n fn sidebar_primitive(cx: &Context<'_>, buf: &mut Buffer, it: &clean::Item) {\n     let mut sidebar = Buffer::new();\n-    sidebar_assoc_items(cx, &mut sidebar, it);\n+\n+    if it.name.map(|n| n.as_str() != \"reference\").unwrap_or(false) {\n+        sidebar_assoc_items(cx, &mut sidebar, it);\n+    } else {\n+        let shared = Rc::clone(&cx.shared);\n+        let (concrete, synthetic, blanket_impl) = get_filtered_impls_for_reference(&shared, it);\n+\n+        sidebar_render_assoc_items(\n+            cx,\n+            &mut sidebar,\n+            &mut IdMap::new(),\n+            concrete,\n+            synthetic,\n+            blanket_impl,\n+        );\n+    }\n \n     if !sidebar.is_empty() {\n         write!(buf, \"<section>{}</section>\", sidebar.into_inner());"}, {"sha": "e3c9dbf502f825afeda600248badf6bf41f94884", "filename": "src/librustdoc/html/render/print_item.rs", "status": "modified", "additions": 15, "deletions": 5, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/775e96970fa5c4af239becc16c78c8a37e8b25e9/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/775e96970fa5c4af239becc16c78c8a37e8b25e9/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs?ref=775e96970fa5c4af239becc16c78c8a37e8b25e9", "patch": "@@ -16,10 +16,10 @@ use std::fmt;\n use std::rc::Rc;\n \n use super::{\n-    collect_paths_for_type, document, ensure_trailing_slash, item_ty_to_section,\n-    notable_traits_decl, render_assoc_item, render_assoc_items, render_attributes_in_code,\n-    render_attributes_in_pre, render_impl, render_rightside, render_stability_since_raw,\n-    AssocItemLink, Context, ImplRenderingParameters,\n+    collect_paths_for_type, document, ensure_trailing_slash, get_filtered_impls_for_reference,\n+    item_ty_to_section, notable_traits_decl, render_all_impls, render_assoc_item,\n+    render_assoc_items, render_attributes_in_code, render_attributes_in_pre, render_impl,\n+    render_rightside, render_stability_since_raw, AssocItemLink, Context, ImplRenderingParameters,\n };\n use crate::clean;\n use crate::config::ModuleSorting;\n@@ -1371,8 +1371,18 @@ fn item_proc_macro(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, m: &c\n }\n \n fn item_primitive(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item) {\n+    let def_id = it.item_id.expect_def_id();\n     document(w, cx, it, None, HeadingOffset::H2);\n-    render_assoc_items(w, cx, it, it.item_id.expect_def_id(), AssocItemRender::All)\n+    if it.name.map(|n| n.as_str() != \"reference\").unwrap_or(false) {\n+        render_assoc_items(w, cx, it, def_id, AssocItemRender::All);\n+    } else {\n+        // We handle the \"reference\" primitive type on its own because we only want to list\n+        // implementations on generic types.\n+        let shared = Rc::clone(&cx.shared);\n+        let (concrete, synthetic, blanket_impl) = get_filtered_impls_for_reference(&shared, it);\n+\n+        render_all_impls(w, cx, it, &concrete, &synthetic, &blanket_impl);\n+    }\n }\n \n fn item_constant(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, c: &clean::Constant) {"}, {"sha": "5c1193406092244a7c76b5ff49d841b48f2bb844", "filename": "src/test/rustdoc/primitive-reference.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/775e96970fa5c4af239becc16c78c8a37e8b25e9/src%2Ftest%2Frustdoc%2Fprimitive-reference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/775e96970fa5c4af239becc16c78c8a37e8b25e9/src%2Ftest%2Frustdoc%2Fprimitive-reference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fprimitive-reference.rs?ref=775e96970fa5c4af239becc16c78c8a37e8b25e9", "patch": "@@ -0,0 +1,37 @@\n+#![crate_name = \"foo\"]\n+\n+#![feature(rustdoc_internals)]\n+\n+// @has foo/index.html\n+// @has - '//h2[@id=\"primitives\"]' 'Primitive Types'\n+// @has - '//a[@href=\"primitive.reference.html\"]' 'reference'\n+// @has - '//div[@class=\"sidebar-elems\"]//li/a' 'Primitive Types'\n+// @has - '//div[@class=\"sidebar-elems\"]//li/a/@href' '#primitives'\n+// @has foo/primitive.reference.html\n+// @has - '//a[@class=\"primitive\"]' 'reference'\n+// @has - '//span[@class=\"in-band\"]' 'Primitive Type reference'\n+// @has - '//section[@id=\"main-content\"]//div[@class=\"docblock\"]//p' 'this is a test!'\n+\n+// There should be only one implementation listed.\n+// @count - '//*[@class=\"impl has-srclink\"]' 1\n+// @has - '//*[@id=\"impl-Foo%3C%26A%3E-for-%26B\"]/*[@class=\"code-header in-band\"]' \\\n+//        'impl<A, B> Foo<&A> for &B'\n+#[doc(primitive = \"reference\")]\n+/// this is a test!\n+mod reference {}\n+\n+pub struct Bar;\n+\n+// This implementation should **not** show up.\n+impl<T> From<&T> for Bar {\n+    fn from(s: &T) -> Self {\n+        Bar\n+    }\n+}\n+\n+pub trait Foo<T> {\n+    fn stuff(&self, other: &T) {}\n+}\n+\n+// This implementation should show up.\n+impl<A, B> Foo<&A> for &B {}"}]}