{"sha": "1db4d607e7621a7d813743e83125859a47970f79", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFkYjRkNjA3ZTc2MjFhN2Q4MTM3NDNlODMxMjU4NTlhNDc5NzBmNzk=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-10-27T23:29:23Z"}, "committer": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-11-07T04:25:31Z"}, "message": "parser: allow ABIs from literal macro fragments", "tree": {"sha": "cde776509b2b3fbfb57b2a8bb9c4d33ef3856978", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cde776509b2b3fbfb57b2a8bb9c4d33ef3856978"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1db4d607e7621a7d813743e83125859a47970f79", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1db4d607e7621a7d813743e83125859a47970f79", "html_url": "https://github.com/rust-lang/rust/commit/1db4d607e7621a7d813743e83125859a47970f79", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1db4d607e7621a7d813743e83125859a47970f79/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "49def0769c51d182bf6c321eefdcda288e3ad218", "url": "https://api.github.com/repos/rust-lang/rust/commits/49def0769c51d182bf6c321eefdcda288e3ad218", "html_url": "https://github.com/rust-lang/rust/commit/49def0769c51d182bf6c321eefdcda288e3ad218"}], "stats": {"total": 89, "additions": 63, "deletions": 26}, "files": [{"sha": "0c358b1caaf71d0fb6e9936af8f8a836584c61d8", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 27, "deletions": 13, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/1db4d607e7621a7d813743e83125859a47970f79/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1db4d607e7621a7d813743e83125859a47970f79/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=1db4d607e7621a7d813743e83125859a47970f79", "patch": "@@ -1205,27 +1205,41 @@ impl<'a> Parser<'a> {\n         Ok(())\n     }\n \n-    /// Parses `extern` followed by an optional ABI string, or nothing.\n+    /// Parses `extern string_literal?`.\n+    /// If `extern` is not found, the Rust ABI is used.\n+    /// If `extern` is found and a `string_literal` does not follow, the C ABI is used.\n     fn parse_extern_abi(&mut self) -> PResult<'a, Abi> {\n         Ok(if self.eat_keyword(kw::Extern) {\n-            let ext_sp = self.prev_span;\n-            self.parse_opt_abi()?.unwrap_or_else(|| Abi::new(sym::C, ext_sp))\n+            self.parse_opt_abi()?\n         } else {\n             Abi::default()\n         })\n     }\n \n-    /// Parses a string as an ABI spec on an extern type or module.\n-    fn parse_opt_abi(&mut self) -> PResult<'a, Option<Abi>> {\n-        match self.token.kind {\n-            token::Literal(token::Lit { kind: token::Str, symbol, suffix }) |\n-            token::Literal(token::Lit { kind: token::StrRaw(..), symbol, suffix }) => {\n-                self.expect_no_suffix(self.token.span, \"an ABI spec\", suffix);\n-                self.bump();\n-                Ok(Some(Abi::new(symbol, self.prev_span)))\n+    /// Parses a string literal as an ABI spec.\n+    /// If one is not found, the \"C\" ABI is used.\n+    fn parse_opt_abi(&mut self) -> PResult<'a, Abi> {\n+        let span = if self.token.can_begin_literal_or_bool() {\n+            let ast::Lit { span, kind, .. } = self.parse_lit()?;\n+            match kind {\n+                ast::LitKind::Str(symbol, _) => return Ok(Abi::new(symbol, span)),\n+                ast::LitKind::Err(_) => {}\n+                _ => {\n+                    self.struct_span_err(span, \"non-string ABI literal\")\n+                        .span_suggestion(\n+                            span,\n+                            \"specify the ABI with a string literal\",\n+                            \"\\\"C\\\"\".to_string(),\n+                            Applicability::MaybeIncorrect,\n+                        )\n+                        .emit();\n+                }\n             }\n-            _ => Ok(None),\n-        }\n+            span\n+        } else {\n+            self.prev_span\n+        };\n+        Ok(Abi::new(sym::C, span))\n     }\n \n     /// We are parsing `async fn`. If we are on Rust 2015, emit an error."}, {"sha": "80ea8f380fbada7f4beb9d885ac169d808f0c46c", "filename": "src/libsyntax/parse/parser/expr.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1db4d607e7621a7d813743e83125859a47970f79/src%2Flibsyntax%2Fparse%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1db4d607e7621a7d813743e83125859a47970f79/src%2Flibsyntax%2Fparse%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser%2Fexpr.rs?ref=1db4d607e7621a7d813743e83125859a47970f79", "patch": "@@ -1116,7 +1116,11 @@ impl<'a> Parser<'a> {\n                 Err(self.span_fatal(token.span, &msg))\n             }\n             Err(err) => {\n-                let (lit, span) = (token.expect_lit(), token.span);\n+                let span = token.span;\n+                let lit = match token.kind {\n+                    token::Literal(lit) => lit,\n+                    _ => unreachable!(),\n+                };\n                 self.bump();\n                 self.error_literal_from_token(err, lit, span);\n                 // Pack possible quotes and prefixes from the original literal into"}, {"sha": "ebb1cf129965e87f0ee4eb0c2ef6b4b72fae73e3", "filename": "src/libsyntax/parse/parser/item.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1db4d607e7621a7d813743e83125859a47970f79/src%2Flibsyntax%2Fparse%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1db4d607e7621a7d813743e83125859a47970f79/src%2Flibsyntax%2Fparse%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser%2Fitem.rs?ref=1db4d607e7621a7d813743e83125859a47970f79", "patch": "@@ -110,7 +110,7 @@ impl<'a> Parser<'a> {\n                 return Ok(Some(self.parse_item_extern_crate(lo, vis, attrs)?));\n             }\n \n-            let abi = self.parse_opt_abi()?.unwrap_or_else(|| Abi::new(sym::C, extern_sp));\n+            let abi = self.parse_opt_abi()?;\n \n             if self.eat_keyword(kw::Fn) {\n                 // EXTERN FUNCTION ITEM"}, {"sha": "6f3da344ccf88e6cc7a5857d809dcef8a3fcda56", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1db4d607e7621a7d813743e83125859a47970f79/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1db4d607e7621a7d813743e83125859a47970f79/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=1db4d607e7621a7d813743e83125859a47970f79", "patch": "@@ -402,13 +402,6 @@ impl Token {\n         }\n     }\n \n-    crate fn expect_lit(&self) -> Lit {\n-        match self.kind {\n-            Literal(lit) => lit,\n-            _ => panic!(\"`expect_lit` called on non-literal\"),\n-        }\n-    }\n-\n     /// Returns `true` if the token is any literal, a minus (which can prefix a literal,\n     /// for example a '-42', or one of the boolean idents).\n     pub fn can_begin_literal_or_bool(&self) -> bool {"}, {"sha": "7db83674efc60620e086413be79f3332263a184d", "filename": "src/test/ui/parser/bad-lit-suffixes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1db4d607e7621a7d813743e83125859a47970f79/src%2Ftest%2Fui%2Fparser%2Fbad-lit-suffixes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1db4d607e7621a7d813743e83125859a47970f79/src%2Ftest%2Fui%2Fparser%2Fbad-lit-suffixes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fbad-lit-suffixes.rs?ref=1db4d607e7621a7d813743e83125859a47970f79", "patch": "@@ -1,9 +1,9 @@\n extern\n-    \"C\"suffix //~ ERROR suffixes on an ABI spec are invalid\n+    \"C\"suffix //~ ERROR suffixes on a string literal are invalid\n     fn foo() {}\n \n extern\n-    \"C\"suffix //~ ERROR suffixes on an ABI spec are invalid\n+    \"C\"suffix //~ ERROR suffixes on a string literal are invalid\n {}\n \n fn main() {"}, {"sha": "6b0049298ffd23e57f8996afc24a5b5ea5d9ee2e", "filename": "src/test/ui/parser/bad-lit-suffixes.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1db4d607e7621a7d813743e83125859a47970f79/src%2Ftest%2Fui%2Fparser%2Fbad-lit-suffixes.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1db4d607e7621a7d813743e83125859a47970f79/src%2Ftest%2Fui%2Fparser%2Fbad-lit-suffixes.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fbad-lit-suffixes.stderr?ref=1db4d607e7621a7d813743e83125859a47970f79", "patch": "@@ -1,10 +1,10 @@\n-error: suffixes on an ABI spec are invalid\n+error: suffixes on a string literal are invalid\n   --> $DIR/bad-lit-suffixes.rs:2:5\n    |\n LL |     \"C\"suffix\n    |     ^^^^^^^^^ invalid suffix `suffix`\n \n-error: suffixes on an ABI spec are invalid\n+error: suffixes on a string literal are invalid\n   --> $DIR/bad-lit-suffixes.rs:6:5\n    |\n LL |     \"C\"suffix"}, {"sha": "cb23f2c808c3478515e6366ce7d66d565062f2d7", "filename": "src/test/ui/parser/extern-abi-from-mac-literal-frag.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/1db4d607e7621a7d813743e83125859a47970f79/src%2Ftest%2Fui%2Fparser%2Fextern-abi-from-mac-literal-frag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1db4d607e7621a7d813743e83125859a47970f79/src%2Ftest%2Fui%2Fparser%2Fextern-abi-from-mac-literal-frag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fextern-abi-from-mac-literal-frag.rs?ref=1db4d607e7621a7d813743e83125859a47970f79", "patch": "@@ -0,0 +1,26 @@\n+// check-pass\n+\n+// In this test we check that the parser accepts an ABI string when it\n+// comes from a macro `literal` fragment as opposed to a hardcoded string.\n+\n+fn main() {}\n+\n+macro_rules! abi_from_lit_frag {\n+    ($abi:literal) => {\n+        extern $abi {\n+            fn _import();\n+        }\n+\n+        extern $abi fn _export() {}\n+\n+        type _PTR = extern $abi fn();\n+    }\n+}\n+\n+mod rust {\n+    abi_from_lit_frag!(\"Rust\");\n+}\n+\n+mod c {\n+    abi_from_lit_frag!(\"C\");\n+}"}]}