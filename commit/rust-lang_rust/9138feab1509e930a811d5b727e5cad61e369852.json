{"sha": "9138feab1509e930a811d5b727e5cad61e369852", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkxMzhmZWFiMTUwOWU5MzBhODExZDViNzI3ZTVjYWQ2MWUzNjk4NTI=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-04-28T02:28:40Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-05-14T21:52:06Z"}, "message": "core::rt: Only use one mechanism for attaching custom data to uv handles", "tree": {"sha": "166236653a05031cafd1ea3b7009176d6a6a61c3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/166236653a05031cafd1ea3b7009176d6a6a61c3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9138feab1509e930a811d5b727e5cad61e369852", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9138feab1509e930a811d5b727e5cad61e369852", "html_url": "https://github.com/rust-lang/rust/commit/9138feab1509e930a811d5b727e5cad61e369852", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9138feab1509e930a811d5b727e5cad61e369852/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "91ca3a9b295404e6dc36677d415573935a9989db", "url": "https://api.github.com/repos/rust-lang/rust/commits/91ca3a9b295404e6dc36677d415573935a9989db", "html_url": "https://github.com/rust-lang/rust/commit/91ca3a9b295404e6dc36677d415573935a9989db"}], "stats": {"total": 69, "additions": 19, "deletions": 50}, "files": [{"sha": "801a6173b1ed248867c26e4c00340b9b3fc37df5", "filename": "src/libcore/rt/uv/mod.rs", "status": "modified", "additions": 19, "deletions": 50, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/9138feab1509e930a811d5b727e5cad61e369852/src%2Flibcore%2Frt%2Fuv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9138feab1509e930a811d5b727e5cad61e369852/src%2Flibcore%2Frt%2Fuv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fuv%2Fmod.rs?ref=9138feab1509e930a811d5b727e5cad61e369852", "patch": "@@ -132,28 +132,38 @@ pub impl IdleWatcher {\n             let handle = uvll::idle_new();\n             assert!(handle.is_not_null());\n             assert!(0 == uvll::idle_init(loop_.native_handle(), handle));\n-            uvll::set_data_for_uv_handle(handle, null::<()>());\n-            NativeHandle::from_native_handle(handle)\n+            let mut watcher: IdleWatcher = NativeHandle::from_native_handle(handle);\n+            watcher.install_watcher_data();\n+            return watcher\n         }\n     }\n \n     fn start(&mut self, cb: IdleCallback) {\n+        {\n+            let data = self.get_watcher_data();\n+            data.idle_cb = Some(cb);\n+        }\n \n-        self.set_callback(cb);\n         unsafe {\n             assert!(0 == uvll::idle_start(self.native_handle(), idle_cb))\n         };\n \n         extern fn idle_cb(handle: *uvll::uv_idle_t, status: c_int) {\n-            let idle_watcher: IdleWatcher = NativeHandle::from_native_handle(handle);\n-            let cb: &IdleCallback = idle_watcher.borrow_callback();\n+            let mut idle_watcher: IdleWatcher = NativeHandle::from_native_handle(handle);\n+            let data = idle_watcher.get_watcher_data();\n+            let cb: &IdleCallback = data.idle_cb.get_ref();\n             let status = status_to_maybe_uv_error(handle, status);\n             (*cb)(idle_watcher, status);\n         }\n     }\n \n     fn stop(&mut self) {\n-        unsafe { assert!(0 == uvll::idle_stop(self.native_handle())); }\n+        // NB: Not resetting the Rust idl_cb to None here because `stop` is likely\n+        // called from *within* the idle callback, which would cause a use after free\n+\n+        unsafe {\n+            assert!(0 == uvll::idle_stop(self.native_handle()));\n+        }\n     }\n \n     fn close(self) {\n@@ -162,7 +172,7 @@ pub impl IdleWatcher {\n         extern fn close_cb(handle: *uvll::uv_idle_t) {\n             unsafe {\n                 let mut idle_watcher: IdleWatcher = NativeHandle::from_native_handle(handle);\n-                idle_watcher.drop_callback::<IdleCallback>();\n+                idle_watcher.drop_watcher_data();\n                 uvll::idle_delete(handle);\n             }\n         }\n@@ -185,13 +195,11 @@ struct WatcherData {\n     connect_cb: Option<ConnectionCallback>,\n     close_cb: Option<NullCallback>,\n     alloc_cb: Option<AllocCallback>,\n+    idle_cb: Option<IdleCallback>\n }\n \n pub trait WatcherInterop {\n     fn event_loop(&self) -> Loop;\n-    fn set_callback<CB: Callback>(&mut self, cb: CB);\n-    fn drop_callback<CB: Callback>(&mut self);\n-    fn borrow_callback<CB: Callback>(&self) -> &CB;\n     fn install_watcher_data(&mut self);\n     fn get_watcher_data<'r>(&'r mut self) -> &'r mut WatcherData;\n     fn drop_watcher_data(&mut self);\n@@ -207,46 +215,6 @@ impl<H, W: Watcher + NativeHandle<*H>> WatcherInterop for W {\n         }\n     }\n \n-    /// Set the custom data on a handle to a callback Note: This is only\n-    /// suitable for watchers that make just one type of callback.  For\n-    /// others use WatcherData\n-    pub fn set_callback<CB: Callback>(&mut self, cb: CB) {\n-        unsafe {\n-            self.drop_callback::<CB>();\n-\n-            // XXX: Boxing the callback so it fits into a\n-            // pointer. Unfortunate extra allocation\n-            let boxed_cb = ~cb;\n-            let data = transmute::<~CB, *c_void>(boxed_cb);\n-            uvll::set_data_for_uv_handle(self.native_handle(), data);\n-        }\n-    }\n-\n-    /// Delete a callback from a handle's custom data\n-    pub fn drop_callback<CB: Callback>(&mut self) {\n-        unsafe {\n-            let handle = self.native_handle();\n-            let handle_data: *c_void = uvll::get_data_for_uv_handle(handle);\n-            if handle_data.is_not_null() {\n-                // Take ownership of the callback and drop it\n-                let _cb = transmute::<*c_void, ~CB>(handle_data);\n-                // Make sure the pointer is zeroed\n-                uvll::set_data_for_uv_handle(self.native_handle(), null::<()>());\n-            }\n-        }\n-    }\n-\n-    /// Take a pointer to the callback installed as custom data\n-    pub fn borrow_callback<CB: Callback>(&self) -> &CB {\n-        unsafe {\n-            let handle = self.native_handle();\n-            let handle_data: *c_void = uvll::get_data_for_uv_handle(handle);\n-            assert!(handle_data.is_not_null());\n-            let cb = transmute::<&*c_void, &~CB>(&handle_data);\n-            return &**cb;\n-        }\n-    }\n-\n     pub fn install_watcher_data(&mut self) {\n         unsafe {\n             let data = ~WatcherData {\n@@ -255,6 +223,7 @@ impl<H, W: Watcher + NativeHandle<*H>> WatcherInterop for W {\n                 connect_cb: None,\n                 close_cb: None,\n                 alloc_cb: None,\n+                idle_cb: None\n             };\n             let data = transmute::<~WatcherData, *c_void>(data);\n             uvll::set_data_for_uv_handle(self.native_handle(), data);"}]}