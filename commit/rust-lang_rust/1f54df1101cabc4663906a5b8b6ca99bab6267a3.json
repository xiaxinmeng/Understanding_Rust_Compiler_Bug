{"sha": "1f54df1101cabc4663906a5b8b6ca99bab6267a3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFmNTRkZjExMDFjYWJjNDY2MzkwNmE1YjhiNmNhOTliYWI2MjY3YTM=", "commit": {"author": {"name": "Michael Woerister", "email": "michaelwoerister@posteo", "date": "2017-08-10T14:10:04Z"}, "committer": {"name": "Michael Woerister", "email": "michaelwoerister@posteo", "date": "2017-08-11T10:17:07Z"}, "message": "Encapsulate sub-table access in TypeckTables and validate keys on each access.", "tree": {"sha": "aab690ab10fb69acdb3d68dd3169dbbdc6f24dfe", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/aab690ab10fb69acdb3d68dd3169dbbdc6f24dfe"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1f54df1101cabc4663906a5b8b6ca99bab6267a3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1f54df1101cabc4663906a5b8b6ca99bab6267a3", "html_url": "https://github.com/rust-lang/rust/commit/1f54df1101cabc4663906a5b8b6ca99bab6267a3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1f54df1101cabc4663906a5b8b6ca99bab6267a3/comments", "author": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bdfd78db8ad4f5520414f346fdfbfb5449d5be48", "url": "https://api.github.com/repos/rust-lang/rust/commits/bdfd78db8ad4f5520414f346fdfbfb5449d5be48", "html_url": "https://github.com/rust-lang/rust/commit/bdfd78db8ad4f5520414f346fdfbfb5449d5be48"}], "stats": {"total": 779, "additions": 463, "deletions": 316}, "files": [{"sha": "45b2a4a1e9667a076e3ece26a1097b902887e086", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 1, "deletions": 67, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/1f54df1101cabc4663906a5b8b6ca99bab6267a3/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f54df1101cabc4663906a5b8b6ca99bab6267a3/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=1f54df1101cabc4663906a5b8b6ca99bab6267a3", "patch": "@@ -11,8 +11,7 @@\n //! This module contains `HashStable` implementations for various data types\n //! from rustc::ty in no particular order.\n \n-use hir::def_id::DefId;\n-use ich::{self, StableHashingContext, NodeIdHashingMode};\n+use ich::StableHashingContext;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher,\n                                            StableHasherResult};\n use std::hash as std_hash;\n@@ -612,71 +611,6 @@ impl_stable_hash_for!(struct ty::ExistentialProjection<'tcx> {\n     ty\n });\n \n-\n-impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n-for ty::TypeckTables<'gcx> {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n-                                          hasher: &mut StableHasher<W>) {\n-        let ty::TypeckTables {\n-            local_id_root,\n-            ref type_dependent_defs,\n-            ref node_types,\n-            ref node_substs,\n-            ref adjustments,\n-            ref pat_binding_modes,\n-            ref upvar_capture_map,\n-            ref closure_tys,\n-            ref closure_kinds,\n-            ref liberated_fn_sigs,\n-            ref fru_field_types,\n-\n-            ref cast_kinds,\n-\n-            ref used_trait_imports,\n-            tainted_by_errors,\n-            ref free_region_map,\n-        } = *self;\n-\n-        hcx.with_node_id_hashing_mode(NodeIdHashingMode::HashDefPath, |hcx| {\n-            ich::hash_stable_itemlocalmap(hcx, hasher, type_dependent_defs);\n-            ich::hash_stable_itemlocalmap(hcx, hasher, node_types);\n-            ich::hash_stable_itemlocalmap(hcx, hasher, node_substs);\n-            ich::hash_stable_itemlocalmap(hcx, hasher, adjustments);\n-            ich::hash_stable_itemlocalmap(hcx, hasher, pat_binding_modes);\n-            ich::hash_stable_hashmap(hcx, hasher, upvar_capture_map, |hcx, up_var_id| {\n-                let ty::UpvarId {\n-                    var_id,\n-                    closure_expr_id\n-                } = *up_var_id;\n-\n-                let var_def_id = DefId {\n-                    krate: local_id_root.krate,\n-                    index: var_id,\n-                };\n-                let closure_def_id = DefId {\n-                    krate: local_id_root.krate,\n-                    index: closure_expr_id,\n-                };\n-                (hcx.def_path_hash(var_def_id), hcx.def_path_hash(closure_def_id))\n-            });\n-\n-            ich::hash_stable_itemlocalmap(hcx, hasher, closure_tys);\n-            ich::hash_stable_itemlocalmap(hcx, hasher, closure_kinds);\n-            ich::hash_stable_itemlocalmap(hcx, hasher, liberated_fn_sigs);\n-            ich::hash_stable_itemlocalmap(hcx, hasher, fru_field_types);\n-            ich::hash_stable_itemlocalmap(hcx, hasher, cast_kinds);\n-\n-            ich::hash_stable_hashset(hcx, hasher, used_trait_imports, |hcx, def_id| {\n-                hcx.def_path_hash(*def_id)\n-            });\n-\n-            tainted_by_errors.hash_stable(hcx, hasher);\n-            free_region_map.hash_stable(hcx, hasher);\n-        })\n-    }\n-}\n-\n impl_stable_hash_for!(enum ty::fast_reject::SimplifiedType {\n     BoolSimplifiedType,\n     CharSimplifiedType,"}, {"sha": "1a8d570bde03765c9f642db4e27ecee9cf63a734", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/1f54df1101cabc4663906a5b8b6ca99bab6267a3/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f54df1101cabc4663906a5b8b6ca99bab6267a3/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=1f54df1101cabc4663906a5b8b6ca99bab6267a3", "patch": "@@ -1331,11 +1331,10 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     {\n         if let Some(tables) = self.in_progress_tables {\n             if let Some(id) = self.tcx.hir.as_local_node_id(def_id) {\n-                let tables = tables.borrow();\n                 let hir_id = self.tcx.hir.node_to_hir_id(id);\n-                tables.validate_hir_id(hir_id);\n-                return tables.closure_kinds\n-                             .get(&hir_id.local_id)\n+                return tables.borrow()\n+                             .closure_kinds()\n+                             .get(hir_id)\n                              .cloned()\n                              .map(|(kind, _)| kind);\n             }\n@@ -1355,10 +1354,8 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     pub fn fn_sig(&self, def_id: DefId) -> ty::PolyFnSig<'tcx> {\n         if let Some(tables) = self.in_progress_tables {\n             if let Some(id) = self.tcx.hir.as_local_node_id(def_id) {\n-                let tables = tables.borrow();\n                 let hir_id = self.tcx.hir.node_to_hir_id(id);\n-                tables.validate_hir_id(hir_id);\n-                if let Some(&ty) = tables.closure_tys.get(&hir_id.local_id) {\n+                if let Some(&ty) = tables.borrow().closure_tys().get(hir_id) {\n                     return ty;\n                 }\n             }"}, {"sha": "0081555095b2f35d7edd6eae7abed52935d0d795", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1f54df1101cabc4663906a5b8b6ca99bab6267a3/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f54df1101cabc4663906a5b8b6ca99bab6267a3/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=1f54df1101cabc4663906a5b8b6ca99bab6267a3", "patch": "@@ -94,8 +94,8 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n         }\n     }\n \n-    fn lookup_and_handle_method(&mut self, id: hir::ItemLocalId) {\n-        self.check_def_id(self.tables.type_dependent_defs[&id].def_id());\n+    fn lookup_and_handle_method(&mut self, id: hir::HirId) {\n+        self.check_def_id(self.tables.type_dependent_defs()[id].def_id());\n     }\n \n     fn handle_field_access(&mut self, lhs: &hir::Expr, name: ast::Name) {\n@@ -241,7 +241,7 @@ impl<'a, 'tcx> Visitor<'tcx> for MarkSymbolVisitor<'a, 'tcx> {\n                 self.handle_definition(def);\n             }\n             hir::ExprMethodCall(..) => {\n-                self.lookup_and_handle_method(expr.hir_id.local_id);\n+                self.lookup_and_handle_method(expr.hir_id);\n             }\n             hir::ExprField(ref lhs, ref name) => {\n                 self.handle_field_access(&lhs, name.node);"}, {"sha": "6b7280cf0ac43fc2ec8210ecf02387d9aa34c26b", "filename": "src/librustc/middle/effect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1f54df1101cabc4663906a5b8b6ca99bab6267a3/src%2Flibrustc%2Fmiddle%2Feffect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f54df1101cabc4663906a5b8b6ca99bab6267a3/src%2Flibrustc%2Fmiddle%2Feffect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Feffect.rs?ref=1f54df1101cabc4663906a5b8b6ca99bab6267a3", "patch": "@@ -166,7 +166,7 @@ impl<'a, 'tcx> Visitor<'tcx> for EffectCheckVisitor<'a, 'tcx> {\n     fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n         match expr.node {\n             hir::ExprMethodCall(..) => {\n-                let def_id = self.tables.type_dependent_defs[&expr.hir_id.local_id].def_id();\n+                let def_id = self.tables.type_dependent_defs()[expr.hir_id].def_id();\n                 let sig = self.tcx.fn_sig(def_id);\n                 debug!(\"effect: method call case, signature is {:?}\",\n                         sig);"}, {"sha": "324f9a6e9061f2da68e58178538516eb720383fd", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1f54df1101cabc4663906a5b8b6ca99bab6267a3/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f54df1101cabc4663906a5b8b6ca99bab6267a3/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=1f54df1101cabc4663906a5b8b6ca99bab6267a3", "patch": "@@ -537,7 +537,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n             }\n             ty::TyError => { }\n             _ => {\n-                let def_id = self.mc.tables.type_dependent_defs[&call.hir_id.local_id].def_id();\n+                let def_id = self.mc.tables.type_dependent_defs()[call.hir_id].def_id();\n                 match OverloadedCallType::from_method_id(self.tcx(), def_id) {\n                     FnMutOverloadedCall => {\n                         let call_scope_r = self.tcx().node_scope_region(call.id);\n@@ -797,8 +797,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                pat);\n         return_if_err!(self.mc.cat_pattern(cmt_discr, pat, |cmt_pat, pat| {\n             if let PatKind::Binding(..) = pat.node {\n-                self.mc.tables.validate_hir_id(pat.hir_id);\n-                let bm = *self.mc.tables.pat_binding_modes.get(&pat.hir_id.local_id)\n+                let bm = *self.mc.tables.pat_binding_modes().get(pat.hir_id)\n                                                           .expect(\"missing binding mode\");\n                 match bm {\n                     ty::BindByReference(..) =>\n@@ -824,8 +823,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n         return_if_err!(mc.cat_pattern(cmt_discr.clone(), pat, |cmt_pat, pat| {\n             if let PatKind::Binding(_, def_id, ..) = pat.node {\n                 debug!(\"binding cmt_pat={:?} pat={:?} match_mode={:?}\", cmt_pat, pat, match_mode);\n-                mc.tables.validate_hir_id(pat.hir_id);\n-                let bm = *mc.tables.pat_binding_modes.get(&pat.hir_id.local_id)\n+                let bm = *mc.tables.pat_binding_modes().get(pat.hir_id)\n                                                      .expect(\"missing binding mode\");\n \n                 // pat_ty: the type of the binding being produced."}, {"sha": "1f3f9fce8542434d911eaa10bc7c285030e84931", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1f54df1101cabc4663906a5b8b6ca99bab6267a3/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f54df1101cabc4663906a5b8b6ca99bab6267a3/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=1f54df1101cabc4663906a5b8b6ca99bab6267a3", "patch": "@@ -334,10 +334,8 @@ impl MutabilityCategory {\n         let ret = match tcx.hir.get(id) {\n             hir_map::NodeLocal(p) => match p.node {\n                 PatKind::Binding(..) => {\n-\n-                    tables.validate_hir_id(p.hir_id);\n-                    let bm = *tables.pat_binding_modes\n-                                    .get(&p.hir_id.local_id)\n+                    let bm = *tables.pat_binding_modes()\n+                                    .get(p.hir_id)\n                                     .expect(\"missing binding mode\");\n                     if bm == ty::BindByValue(hir::MutMutable) {\n                         McDeclared\n@@ -485,10 +483,9 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n         // fundamental fix to this conflated use of the node id.\n         let ret_ty = match pat.node {\n             PatKind::Binding(..) => {\n-                self.tables.validate_hir_id(pat.hir_id);\n                 let bm = *self.tables\n-                              .pat_binding_modes\n-                              .get(&pat.hir_id.local_id)\n+                              .pat_binding_modes()\n+                              .get(pat.hir_id)\n                               .expect(\"missing binding mode\");\n \n                 if let ty::BindByReference(_) = bm {\n@@ -698,7 +695,6 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n                  -> McResult<cmt<'tcx>>\n     {\n         let fn_hir_id = self.tcx.hir.node_to_hir_id(fn_node_id);\n-        self.tables.validate_hir_id(fn_hir_id);\n \n         // An upvar can have up to 3 components. We translate first to a\n         // `Categorization::Upvar`, which is itself a fiction -- it represents the reference to the\n@@ -723,7 +719,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n         // FnMut          | copied -> &'env mut  | upvar -> &'env mut -> &'up bk\n         // FnOnce         | copied               | upvar -> &'up bk\n \n-        let kind = match self.tables.closure_kinds.get(&fn_hir_id.local_id) {\n+        let kind = match self.tables.closure_kinds().get(fn_hir_id) {\n             Some(&(kind, _)) => kind,\n             None => span_bug!(span, \"missing closure kind\")\n         };"}, {"sha": "bd9a413ca617342b6e47e482f9fa9755e1788cab", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1f54df1101cabc4663906a5b8b6ca99bab6267a3/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f54df1101cabc4663906a5b8b6ca99bab6267a3/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=1f54df1101cabc4663906a5b8b6ca99bab6267a3", "patch": "@@ -110,7 +110,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ReachableContext<'a, 'tcx> {\n                 Some(self.tables.qpath_def(qpath, expr.hir_id))\n             }\n             hir::ExprMethodCall(..) => {\n-                Some(self.tables.type_dependent_defs[&expr.hir_id.local_id])\n+                Some(self.tables.type_dependent_defs()[expr.hir_id])\n             }\n             _ => None\n         };"}, {"sha": "c5b0f11b823a1e50bb270bb6211a6ad10cd31e31", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1f54df1101cabc4663906a5b8b6ca99bab6267a3/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f54df1101cabc4663906a5b8b6ca99bab6267a3/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=1f54df1101cabc4663906a5b8b6ca99bab6267a3", "patch": "@@ -684,8 +684,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                         if let Some(tables) = self.in_progress_tables {\n                             let tables = tables.borrow();\n                             let closure_hir_id = self.tcx.hir.node_to_hir_id(node_id);\n-                            tables.validate_hir_id(closure_hir_id);\n-                            match tables.closure_kinds.get(&closure_hir_id.local_id) {\n+                            match tables.closure_kinds().get(closure_hir_id) {\n                                 Some(&(ty::ClosureKind::FnOnce, Some((span, name)))) => {\n                                     err.span_note(span, &format!(\n                                         \"closure is `FnOnce` because it moves the \\"}, {"sha": "ac851f182a0f233fa2d23310c3c59371a74494ea", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 308, "deletions": 47, "changes": 355, "blob_url": "https://github.com/rust-lang/rust/blob/1f54df1101cabc4663906a5b8b6ca99bab6267a3/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f54df1101cabc4663906a5b8b6ca99bab6267a3/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=1f54df1101cabc4663906a5b8b6ca99bab6267a3", "patch": "@@ -20,6 +20,7 @@ use hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n use hir::map as hir_map;\n use hir::map::DefPathHash;\n use lint::{self, Lint};\n+use ich::{self, StableHashingContext, NodeIdHashingMode};\n use middle::free_region::FreeRegionMap;\n use middle::lang_items;\n use middle::resolve_lifetime;\n@@ -45,19 +46,22 @@ use ty::BindingMode;\n use util::nodemap::{NodeMap, NodeSet, DefIdSet, ItemLocalMap};\n use util::nodemap::{FxHashMap, FxHashSet};\n use rustc_data_structures::accumulate_vec::AccumulateVec;\n+use rustc_data_structures::stable_hasher::{HashStable, StableHasher,\n+                                           StableHasherResult};\n \n use arena::{TypedArena, DroplessArena};\n use rustc_data_structures::indexed_vec::IndexVec;\n use std::borrow::Borrow;\n use std::cell::{Cell, RefCell};\n use std::cmp::Ordering;\n+use std::collections::hash_map::{self, Entry};\n use std::hash::{Hash, Hasher};\n use std::mem;\n use std::ops::Deref;\n use std::iter;\n use std::rc::Rc;\n use syntax::abi;\n-use syntax::ast::{self, Name};\n+use syntax::ast::{self, Name, NodeId};\n use syntax::attr;\n use syntax::codemap::MultiSpan;\n use syntax::symbol::{Symbol, keywords};\n@@ -207,57 +211,142 @@ pub struct CommonTypes<'tcx> {\n     pub re_erased: Region<'tcx>,\n }\n \n+pub struct LocalTableInContext<'a, V: 'a> {\n+    local_id_root: DefId,\n+    data: &'a ItemLocalMap<V>\n+}\n+\n+/// Validate that the given HirId (respectively its `local_id` part) can be\n+/// safely used as a key in the tables of a TypeckTable. For that to be\n+/// the case, the HirId must have the same `owner` as all the other IDs in\n+/// this table (signified by `local_id_root`). Otherwise the HirId\n+/// would be in a different frame of reference and using its `local_id`\n+/// would result in lookup errors, or worse, in silently wrong data being\n+/// stored/returned.\n+fn validate_hir_id_for_typeck_tables(table_id_root: DefId, hir_id: hir::HirId) {\n+    #[cfg(debug_assertions)]\n+    {\n+        if table_id_root.is_local() {\n+            if hir_id.owner != table_id_root.index {\n+                ty::tls::with(|tcx| {\n+                    let node_id = tcx.hir\n+                                     .definitions()\n+                                     .find_node_for_hir_id(hir_id);\n+\n+                    bug!(\"node {} with HirId::owner {:?} cannot be placed in \\\n+                          TypeckTables with local_id_root {:?}\",\n+                          tcx.hir.node_to_string(node_id),\n+                          DefId::local(hir_id.owner),\n+                          table_id_root)\n+                });\n+            }\n+        }\n+    }\n+}\n+\n+impl<'a, V> LocalTableInContext<'a, V> {\n+    pub fn contains_key(&self, id: hir::HirId) -> bool {\n+        validate_hir_id_for_typeck_tables(self.local_id_root, id);\n+        self.data.contains_key(&id.local_id)\n+    }\n+\n+    pub fn get(&self, id: hir::HirId) -> Option<&V> {\n+        validate_hir_id_for_typeck_tables(self.local_id_root, id);\n+        self.data.get(&id.local_id)\n+    }\n+\n+    pub fn iter(&self) -> hash_map::Iter<hir::ItemLocalId, V> {\n+        self.data.iter()\n+    }\n+}\n+\n+impl<'a, V> ::std::ops::Index<hir::HirId> for LocalTableInContext<'a, V> {\n+    type Output = V;\n+\n+    fn index(&self, key: hir::HirId) -> &V {\n+        self.get(key).expect(\"LocalTableInContext: key not found\")\n+    }\n+}\n+\n+pub struct LocalTableInContextMut<'a, V: 'a> {\n+    local_id_root: DefId,\n+    data: &'a mut ItemLocalMap<V>\n+}\n+\n+impl<'a, V> LocalTableInContextMut<'a, V> {\n+\n+    pub fn get_mut(&mut self, id: hir::HirId) -> Option<&mut V> {\n+        validate_hir_id_for_typeck_tables(self.local_id_root, id);\n+        self.data.get_mut(&id.local_id)\n+    }\n+\n+    pub fn entry(&mut self, id: hir::HirId) -> Entry<hir::ItemLocalId, V> {\n+        validate_hir_id_for_typeck_tables(self.local_id_root, id);\n+        self.data.entry(id.local_id)\n+    }\n+\n+    pub fn insert(&mut self, id: hir::HirId, val: V) -> Option<V> {\n+        validate_hir_id_for_typeck_tables(self.local_id_root, id);\n+        self.data.insert(id.local_id, val)\n+    }\n+\n+    pub fn remove(&mut self, id: hir::HirId) -> Option<V> {\n+        validate_hir_id_for_typeck_tables(self.local_id_root, id);\n+        self.data.remove(&id.local_id)\n+    }\n+}\n+\n #[derive(RustcEncodable, RustcDecodable)]\n pub struct TypeckTables<'tcx> {\n     /// The HirId::owner all ItemLocalIds in this table are relative to.\n     pub local_id_root: DefId,\n \n     /// Resolved definitions for `<T>::X` associated paths and\n     /// method calls, including those of overloaded operators.\n-    pub type_dependent_defs: ItemLocalMap<Def>,\n+    type_dependent_defs: ItemLocalMap<Def>,\n \n     /// Stores the types for various nodes in the AST.  Note that this table\n     /// is not guaranteed to be populated until after typeck.  See\n     /// typeck::check::fn_ctxt for details.\n-    pub node_types: ItemLocalMap<Ty<'tcx>>,\n+    node_types: ItemLocalMap<Ty<'tcx>>,\n \n     /// Stores the type parameters which were substituted to obtain the type\n     /// of this node.  This only applies to nodes that refer to entities\n     /// parameterized by type parameters, such as generic fns, types, or\n     /// other items.\n-    pub node_substs: ItemLocalMap<&'tcx Substs<'tcx>>,\n+    node_substs: ItemLocalMap<&'tcx Substs<'tcx>>,\n \n-    pub adjustments: ItemLocalMap<Vec<ty::adjustment::Adjustment<'tcx>>>,\n+    adjustments: ItemLocalMap<Vec<ty::adjustment::Adjustment<'tcx>>>,\n \n     // Stores the actual binding mode for all instances of hir::BindingAnnotation.\n-    pub pat_binding_modes: ItemLocalMap<BindingMode>,\n+    pat_binding_modes: ItemLocalMap<BindingMode>,\n \n     /// Borrows\n     pub upvar_capture_map: ty::UpvarCaptureMap<'tcx>,\n \n     /// Records the type of each closure.\n-    pub closure_tys: ItemLocalMap<ty::PolyFnSig<'tcx>>,\n+    closure_tys: ItemLocalMap<ty::PolyFnSig<'tcx>>,\n \n     /// Records the kind of each closure and the span and name of the variable\n     /// that caused the closure to be this kind.\n-    pub closure_kinds: ItemLocalMap<(ty::ClosureKind, Option<(Span, ast::Name)>)>,\n+    closure_kinds: ItemLocalMap<(ty::ClosureKind, Option<(Span, ast::Name)>)>,\n \n     /// For each fn, records the \"liberated\" types of its arguments\n     /// and return type. Liberated means that all bound regions\n     /// (including late-bound regions) are replaced with free\n     /// equivalents. This table is not used in trans (since regions\n     /// are erased there) and hence is not serialized to metadata.\n-    pub liberated_fn_sigs: ItemLocalMap<ty::FnSig<'tcx>>,\n+    liberated_fn_sigs: ItemLocalMap<ty::FnSig<'tcx>>,\n \n     /// For each FRU expression, record the normalized types of the fields\n     /// of the struct - this is needed because it is non-trivial to\n     /// normalize while preserving regions. This table is used only in\n     /// MIR construction and hence is not serialized to metadata.\n-    pub fru_field_types: ItemLocalMap<Vec<Ty<'tcx>>>,\n+    fru_field_types: ItemLocalMap<Vec<Ty<'tcx>>>,\n \n     /// Maps a cast expression to its kind. This is keyed on the\n     /// *from* expression of the cast, not the cast itself.\n-    pub cast_kinds: ItemLocalMap<ty::cast::CastKind>,\n+    cast_kinds: ItemLocalMap<ty::cast::CastKind>,\n \n     /// Set of trait imports actually used in the method resolution.\n     /// This is used for warning unused imports.\n@@ -288,7 +377,6 @@ impl<'tcx> TypeckTables<'tcx> {\n             liberated_fn_sigs: ItemLocalMap(),\n             fru_field_types: ItemLocalMap(),\n             cast_kinds: ItemLocalMap(),\n-            lints: lint::LintTable::new(),\n             used_trait_imports: DefIdSet(),\n             tainted_by_errors: false,\n             free_region_map: FreeRegionMap::new(),\n@@ -300,12 +388,40 @@ impl<'tcx> TypeckTables<'tcx> {\n         match *qpath {\n             hir::QPath::Resolved(_, ref path) => path.def,\n             hir::QPath::TypeRelative(..) => {\n-                self.validate_hir_id(id);\n+                validate_hir_id_for_typeck_tables(self.local_id_root, id);\n                 self.type_dependent_defs.get(&id.local_id).cloned().unwrap_or(Def::Err)\n             }\n         }\n     }\n \n+    pub fn type_dependent_defs(&self) -> LocalTableInContext<Def> {\n+        LocalTableInContext {\n+            local_id_root: self.local_id_root,\n+            data: &self.type_dependent_defs\n+        }\n+    }\n+\n+    pub fn type_dependent_defs_mut(&mut self) -> LocalTableInContextMut<Def> {\n+        LocalTableInContextMut {\n+            local_id_root: self.local_id_root,\n+            data: &mut self.type_dependent_defs\n+        }\n+    }\n+\n+    pub fn node_types(&self) -> LocalTableInContext<Ty<'tcx>> {\n+        LocalTableInContext {\n+            local_id_root: self.local_id_root,\n+            data: &self.node_types\n+        }\n+    }\n+\n+    pub fn node_types_mut(&mut self) -> LocalTableInContextMut<Ty<'tcx>> {\n+        LocalTableInContextMut {\n+            local_id_root: self.local_id_root,\n+            data: &mut self.node_types\n+        }\n+    }\n+\n     pub fn node_id_to_type(&self, id: hir::HirId) -> Ty<'tcx> {\n         match self.node_id_to_type_opt(id) {\n             Some(ty) => ty,\n@@ -320,15 +436,27 @@ impl<'tcx> TypeckTables<'tcx> {\n     }\n \n     pub fn node_id_to_type_opt(&self, id: hir::HirId) -> Option<Ty<'tcx>> {\n-        self.validate_hir_id(id);\n+        validate_hir_id_for_typeck_tables(self.local_id_root, id);\n         self.node_types.get(&id.local_id).cloned()\n     }\n \n+    pub fn node_substs_mut(&mut self) -> LocalTableInContextMut<&'tcx Substs<'tcx>> {\n+        LocalTableInContextMut {\n+            local_id_root: self.local_id_root,\n+            data: &mut self.node_substs\n+        }\n+    }\n+\n     pub fn node_substs(&self, id: hir::HirId) -> &'tcx Substs<'tcx> {\n-        self.validate_hir_id(id);\n+        validate_hir_id_for_typeck_tables(self.local_id_root, id);\n         self.node_substs.get(&id.local_id).cloned().unwrap_or(Substs::empty())\n     }\n \n+    pub fn node_substs_opt(&self, id: hir::HirId) -> Option<&'tcx Substs<'tcx>> {\n+        validate_hir_id_for_typeck_tables(self.local_id_root, id);\n+        self.node_substs.get(&id.local_id).cloned()\n+    }\n+\n     // Returns the type of a pattern as a monotype. Like @expr_ty, this function\n     // doesn't provide type parameter substitutions.\n     pub fn pat_ty(&self, pat: &hir::Pat) -> Ty<'tcx> {\n@@ -357,9 +485,24 @@ impl<'tcx> TypeckTables<'tcx> {\n         self.node_id_to_type_opt(expr.hir_id)\n     }\n \n+    pub fn adjustments(&self) -> LocalTableInContext<Vec<ty::adjustment::Adjustment<'tcx>>> {\n+        LocalTableInContext {\n+            local_id_root: self.local_id_root,\n+            data: &self.adjustments\n+        }\n+    }\n+\n+    pub fn adjustments_mut(&mut self)\n+                           -> LocalTableInContextMut<Vec<ty::adjustment::Adjustment<'tcx>>> {\n+        LocalTableInContextMut {\n+            local_id_root: self.local_id_root,\n+            data: &mut self.adjustments\n+        }\n+    }\n+\n     pub fn expr_adjustments(&self, expr: &hir::Expr)\n                             -> &[ty::adjustment::Adjustment<'tcx>] {\n-        self.validate_hir_id(expr.hir_id);\n+        validate_hir_id_for_typeck_tables(self.local_id_root, expr.hir_id);\n         self.adjustments.get(&expr.hir_id.local_id).map_or(&[], |a| &a[..])\n     }\n \n@@ -385,50 +528,168 @@ impl<'tcx> TypeckTables<'tcx> {\n             return false;\n         }\n \n-        self.validate_hir_id(expr.hir_id);\n-        match self.type_dependent_defs.get(&expr.hir_id.local_id) {\n+        match self.type_dependent_defs().get(expr.hir_id) {\n             Some(&Def::Method(_)) => true,\n             _ => false\n         }\n     }\n \n+    pub fn pat_binding_modes(&self) -> LocalTableInContext<BindingMode> {\n+        LocalTableInContext {\n+            local_id_root: self.local_id_root,\n+            data: &self.pat_binding_modes\n+        }\n+    }\n+\n+    pub fn pat_binding_modes_mut(&mut self)\n+                           -> LocalTableInContextMut<BindingMode> {\n+        LocalTableInContextMut {\n+            local_id_root: self.local_id_root,\n+            data: &mut self.pat_binding_modes\n+        }\n+    }\n+\n     pub fn upvar_capture(&self, upvar_id: ty::UpvarId) -> ty::UpvarCapture<'tcx> {\n         self.upvar_capture_map[&upvar_id]\n     }\n \n-    /// Validate that the given HirId (respectively its `local_id` part) can be\n-    /// safely used as a key in the tables of this TypeckTable. For that to be\n-    /// the case, the HirId must have the same `owner` as all the other IDs in\n-    /// this table (signified by the `local_id_root` field). Otherwise the HirId\n-    /// would be in a different frame of reference and using its `local_id`\n-    /// would result in lookup errors, or worse, in silently wrong data being\n-    /// stored/returned.\n-    ///\n-    /// Therefore it is advised to call this method anytime before using a given\n-    /// HirId::local_id as a key.\n-    #[inline]\n-    pub fn validate_hir_id(&self, hir_id: hir::HirId) {\n-        #[cfg(debug_assertions)]\n-        {\n-            if self.local_id_root.is_local() {\n-                if hir_id.owner != self.local_id_root.index {\n-                    ty::tls::with(|tcx| {\n-                        let node_id = tcx.hir\n-                                         .definitions()\n-                                         .find_node_for_hir_id(hir_id);\n-\n-                        bug!(\"node {} with HirId::owner {:?} cannot be placed in \\\n-                              TypeckTables with local_id_root {:?}\",\n-                              tcx.hir.node_to_string(node_id),\n-                              DefId::local(hir_id.owner),\n-                              self.local_id_root)\n-                    });\n-                }\n-            }\n+    pub fn closure_tys(&self) -> LocalTableInContext<ty::PolyFnSig<'tcx>> {\n+        LocalTableInContext {\n+            local_id_root: self.local_id_root,\n+            data: &self.closure_tys\n+        }\n+    }\n+\n+    pub fn closure_tys_mut(&mut self)\n+                           -> LocalTableInContextMut<ty::PolyFnSig<'tcx>> {\n+        LocalTableInContextMut {\n+            local_id_root: self.local_id_root,\n+            data: &mut self.closure_tys\n+        }\n+    }\n+\n+    pub fn closure_kinds(&self) -> LocalTableInContext<(ty::ClosureKind,\n+                                                        Option<(Span, ast::Name)>)> {\n+        LocalTableInContext {\n+            local_id_root: self.local_id_root,\n+            data: &self.closure_kinds\n+        }\n+    }\n+\n+    pub fn closure_kinds_mut(&mut self)\n+            -> LocalTableInContextMut<(ty::ClosureKind, Option<(Span, ast::Name)>)> {\n+        LocalTableInContextMut {\n+            local_id_root: self.local_id_root,\n+            data: &mut self.closure_kinds\n+        }\n+    }\n+\n+    pub fn liberated_fn_sigs(&self) -> LocalTableInContext<ty::FnSig<'tcx>> {\n+        LocalTableInContext {\n+            local_id_root: self.local_id_root,\n+            data: &self.liberated_fn_sigs\n+        }\n+    }\n+\n+    pub fn liberated_fn_sigs_mut(&mut self) -> LocalTableInContextMut<ty::FnSig<'tcx>> {\n+        LocalTableInContextMut {\n+            local_id_root: self.local_id_root,\n+            data: &mut self.liberated_fn_sigs\n+        }\n+    }\n+\n+    pub fn fru_field_types(&self) -> LocalTableInContext<Vec<Ty<'tcx>>> {\n+        LocalTableInContext {\n+            local_id_root: self.local_id_root,\n+            data: &self.fru_field_types\n+        }\n+    }\n+\n+    pub fn fru_field_types_mut(&mut self) -> LocalTableInContextMut<Vec<Ty<'tcx>>> {\n+        LocalTableInContextMut {\n+            local_id_root: self.local_id_root,\n+            data: &mut self.fru_field_types\n+        }\n+    }\n+\n+    pub fn cast_kinds(&self) -> LocalTableInContext<ty::cast::CastKind> {\n+        LocalTableInContext {\n+            local_id_root: self.local_id_root,\n+            data: &self.cast_kinds\n+        }\n+    }\n+\n+    pub fn cast_kinds_mut(&mut self) -> LocalTableInContextMut<ty::cast::CastKind> {\n+        LocalTableInContextMut {\n+            local_id_root: self.local_id_root,\n+            data: &mut self.cast_kinds\n         }\n     }\n }\n \n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for TypeckTables<'gcx> {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        let ty::TypeckTables {\n+            local_id_root,\n+            ref type_dependent_defs,\n+            ref node_types,\n+            ref node_substs,\n+            ref adjustments,\n+            ref pat_binding_modes,\n+            ref upvar_capture_map,\n+            ref closure_tys,\n+            ref closure_kinds,\n+            ref liberated_fn_sigs,\n+            ref fru_field_types,\n+\n+            ref cast_kinds,\n+\n+            ref used_trait_imports,\n+            tainted_by_errors,\n+            ref free_region_map,\n+        } = *self;\n+\n+        hcx.with_node_id_hashing_mode(NodeIdHashingMode::HashDefPath, |hcx| {\n+            ich::hash_stable_itemlocalmap(hcx, hasher, type_dependent_defs);\n+            ich::hash_stable_itemlocalmap(hcx, hasher, node_types);\n+            ich::hash_stable_itemlocalmap(hcx, hasher, node_substs);\n+            ich::hash_stable_itemlocalmap(hcx, hasher, adjustments);\n+            ich::hash_stable_itemlocalmap(hcx, hasher, pat_binding_modes);\n+            ich::hash_stable_hashmap(hcx, hasher, upvar_capture_map, |hcx, up_var_id| {\n+                let ty::UpvarId {\n+                    var_id,\n+                    closure_expr_id\n+                } = *up_var_id;\n+\n+                let var_def_id = DefId {\n+                    krate: local_id_root.krate,\n+                    index: var_id,\n+                };\n+                let closure_def_id = DefId {\n+                    krate: local_id_root.krate,\n+                    index: closure_expr_id,\n+                };\n+                (hcx.def_path_hash(var_def_id), hcx.def_path_hash(closure_def_id))\n+            });\n+\n+            ich::hash_stable_itemlocalmap(hcx, hasher, closure_tys);\n+            ich::hash_stable_itemlocalmap(hcx, hasher, closure_kinds);\n+            ich::hash_stable_itemlocalmap(hcx, hasher, liberated_fn_sigs);\n+            ich::hash_stable_itemlocalmap(hcx, hasher, fru_field_types);\n+            ich::hash_stable_itemlocalmap(hcx, hasher, cast_kinds);\n+\n+            ich::hash_stable_hashset(hcx, hasher, used_trait_imports, |hcx, def_id| {\n+                hcx.def_path_hash(*def_id)\n+            });\n+\n+            tainted_by_errors.hash_stable(hcx, hasher);\n+            free_region_map.hash_stable(hcx, hasher);\n+        })\n+    }\n+}\n+\n impl<'tcx> CommonTypes<'tcx> {\n     fn new(interners: &CtxtInterners<'tcx>) -> CommonTypes<'tcx> {\n         let mk = |sty| interners.intern_ty(sty, None);"}, {"sha": "412af05f5bdfa4cffe3517b04ad8203fb47d6e39", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1f54df1101cabc4663906a5b8b6ca99bab6267a3/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f54df1101cabc4663906a5b8b6ca99bab6267a3/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=1f54df1101cabc4663906a5b8b6ca99bab6267a3", "patch": "@@ -600,9 +600,8 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                     ty::TypeVariants::TyClosure(id, _) => {\n                         let node_id = self.tcx.hir.as_local_node_id(id).unwrap();\n                         let hir_id = self.tcx.hir.node_to_hir_id(node_id);\n-                        self.tables.validate_hir_id(hir_id);\n                         if let Some(&(ty::ClosureKind::FnOnce, Some((span, name)))) =\n-                            self.tables.closure_kinds.get(&hir_id.local_id)\n+                            self.tables.closure_kinds().get(hir_id)\n                         {\n                             err.span_note(span, &format!(\n                                 \"closure cannot be invoked more than once because \\\n@@ -904,10 +903,9 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n \n         match pat.node {\n             hir::PatKind::Binding(..) => {\n-                self.tables.validate_hir_id(pat.hir_id);\n                 *self.tables\n-                     .pat_binding_modes\n-                     .get(&pat.hir_id.local_id)\n+                     .pat_binding_modes()\n+                     .get(pat.hir_id)\n                      .expect(\"missing binding mode\")\n             }\n             _ => bug!(\"local is not a binding: {:?}\", pat)"}, {"sha": "ea7deef472425632798f9e6848752942e5d97050", "filename": "src/librustc_const_eval/check_match.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/1f54df1101cabc4663906a5b8b6ca99bab6267a3/src%2Flibrustc_const_eval%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f54df1101cabc4663906a5b8b6ca99bab6267a3/src%2Flibrustc_const_eval%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fcheck_match.rs?ref=1f54df1101cabc4663906a5b8b6ca99bab6267a3", "patch": "@@ -269,10 +269,9 @@ impl<'a, 'tcx> MatchVisitor<'a, 'tcx> {\n fn check_for_bindings_named_the_same_as_variants(cx: &MatchVisitor, pat: &Pat) {\n     pat.walk(|p| {\n         if let PatKind::Binding(_, _, name, None) = p.node {\n-            cx.tables.validate_hir_id(p.hir_id);\n             let bm = *cx.tables\n-                        .pat_binding_modes\n-                        .get(&p.hir_id.local_id)\n+                        .pat_binding_modes()\n+                        .get(p.hir_id)\n                         .expect(\"missing binding mode\");\n \n             if bm != ty::BindByValue(hir::MutImmutable) {\n@@ -464,10 +463,9 @@ fn check_legality_of_move_bindings(cx: &MatchVisitor,\n     for pat in pats {\n         pat.each_binding(|_, id, span, _path| {\n             let hir_id = cx.tcx.hir.node_to_hir_id(id);\n-            cx.tables.validate_hir_id(hir_id);\n             let bm = *cx.tables\n-                        .pat_binding_modes\n-                        .get(&hir_id.local_id)\n+                        .pat_binding_modes()\n+                        .get(hir_id)\n                         .expect(\"missing binding mode\");\n             if let ty::BindByReference(..) = bm {\n                 by_ref_span = Some(span);\n@@ -501,10 +499,9 @@ fn check_legality_of_move_bindings(cx: &MatchVisitor,\n     for pat in pats {\n         pat.walk(|p| {\n             if let PatKind::Binding(_, _, _, ref sub) = p.node {\n-                cx.tables.validate_hir_id(p.hir_id);\n                 let bm = *cx.tables\n-                            .pat_binding_modes\n-                            .get(&p.hir_id.local_id)\n+                            .pat_binding_modes()\n+                            .get(p.hir_id)\n                             .expect(\"missing binding mode\");\n                 match bm {\n                     ty::BindByValue(..) => {"}, {"sha": "d151e817040a9a2733b628eca38798f2ec653fa6", "filename": "src/librustc_const_eval/pattern.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1f54df1101cabc4663906a5b8b6ca99bab6267a3/src%2Flibrustc_const_eval%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f54df1101cabc4663906a5b8b6ca99bab6267a3/src%2Flibrustc_const_eval%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fpattern.rs?ref=1f54df1101cabc4663906a5b8b6ca99bab6267a3", "patch": "@@ -381,8 +381,8 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                     ty::TyRef(r, _) => Some(r),\n                     _ => None,\n                 };\n-                let bm = *self.tables.pat_binding_modes.get(&pat.hir_id.local_id)\n-                                                       .expect(\"missing binding mode\");\n+                let bm = *self.tables.pat_binding_modes().get(pat.hir_id)\n+                                                         .expect(\"missing binding mode\");\n                 let (mutability, mode) = match bm {\n                     ty::BindByValue(hir::MutMutable) =>\n                         (Mutability::Mut, BindingMode::ByValue),"}, {"sha": "cef35be59cd1030e8f54f7a55069ab903070d4f5", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1f54df1101cabc4663906a5b8b6ca99bab6267a3/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f54df1101cabc4663906a5b8b6ca99bab6267a3/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=1f54df1101cabc4663906a5b8b6ca99bab6267a3", "patch": "@@ -935,7 +935,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnconditionalRecursion {\n             // Check for method calls and overloaded operators.\n             if cx.tables.is_method_call(expr) {\n                 let hir_id = cx.tcx.hir.definitions().node_to_hir_id(id);\n-                let def_id = cx.tables.type_dependent_defs[&hir_id.local_id].def_id();\n+                let def_id = cx.tables.type_dependent_defs()[hir_id].def_id();\n                 let substs = cx.tables.node_substs(hir_id);\n                 if method_call_refers_to_method(cx, method, def_id, substs, id) {\n                     return true;"}, {"sha": "65973d99c547c6d82a3602195a147f069d88f370", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1f54df1101cabc4663906a5b8b6ca99bab6267a3/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f54df1101cabc4663906a5b8b6ca99bab6267a3/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=1f54df1101cabc4663906a5b8b6ca99bab6267a3", "patch": "@@ -46,8 +46,7 @@ impl UnusedMut {\n         for p in pats {\n             p.each_binding(|_, id, span, path1| {\n                 let hir_id = cx.tcx.hir.node_to_hir_id(id);\n-                cx.tables.validate_hir_id(hir_id);\n-                let bm = match cx.tables.pat_binding_modes.get(&hir_id.local_id) {\n+                let bm = match cx.tables.pat_binding_modes().get(hir_id) {\n                     Some(&bm) => bm,\n                     None => span_bug!(span, \"missing binding mode\"),\n                 };"}, {"sha": "14392ae70e4e34a9f847254c20dbfa7258c140df", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1f54df1101cabc4663906a5b8b6ca99bab6267a3/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f54df1101cabc4663906a5b8b6ca99bab6267a3/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=1f54df1101cabc4663906a5b8b6ca99bab6267a3", "patch": "@@ -91,8 +91,7 @@ pub fn mir_build<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Mir<'t\n             // fetch the fully liberated fn signature (that is, all bound\n             // types/lifetimes replaced)\n             let fn_hir_id = tcx.hir.node_to_hir_id(id);\n-            cx.tables().validate_hir_id(fn_hir_id);\n-            let fn_sig = cx.tables().liberated_fn_sigs[&fn_hir_id.local_id].clone();\n+            let fn_sig = cx.tables().liberated_fn_sigs()[fn_hir_id].clone();\n \n             let ty = tcx.type_of(tcx.hir.local_def_id(id));\n             let mut abi = fn_sig.abi;"}, {"sha": "5b3e4b1ddc37a53bf1e53edd0adf32cb9080bc0c", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/1f54df1101cabc4663906a5b8b6ca99bab6267a3/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f54df1101cabc4663906a5b8b6ca99bab6267a3/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=1f54df1101cabc4663906a5b8b6ca99bab6267a3", "patch": "@@ -387,11 +387,10 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                                 substs: substs,\n                                 fields: field_refs,\n                                 base: base.as_ref().map(|base| {\n-                                    cx.tables().validate_hir_id(expr.hir_id);\n                                     FruInfo {\n                                         base: base.to_ref(),\n                                         field_types: cx.tables()\n-                                                       .fru_field_types[&expr.hir_id.local_id]\n+                                                       .fru_field_types()[expr.hir_id]\n                                                        .clone(),\n                                     }\n                                 }),\n@@ -551,10 +550,9 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         hir::ExprCast(ref source, _) => {\n             // Check to see if this cast is a \"coercion cast\", where the cast is actually done\n             // using a coercion (or is a no-op).\n-            cx.tables().validate_hir_id(source.hir_id);\n             if let Some(&TyCastKind::CoercionCast) = cx.tables()\n-                                                       .cast_kinds\n-                                                       .get(&source.hir_id.local_id) {\n+                                                       .cast_kinds()\n+                                                       .get(source.hir_id) {\n                 // Convert the lexpr to a vexpr.\n                 ExprKind::Use { source: source.to_ref() }\n             } else {\n@@ -586,8 +584,7 @@ fn method_callee<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                                  -> Expr<'tcx> {\n     let temp_lifetime = cx.region_maps.temporary_scope(expr.id);\n     let (def_id, substs) = custom_callee.unwrap_or_else(|| {\n-        cx.tables().validate_hir_id(expr.hir_id);\n-        (cx.tables().type_dependent_defs[&expr.hir_id.local_id].def_id(),\n+        (cx.tables().type_dependent_defs()[expr.hir_id].def_id(),\n          cx.tables().node_substs(expr.hir_id))\n     });\n     Expr {"}, {"sha": "a390448f43a9b8cb732546b11b0dd8b6865daa26", "filename": "src/librustc_passes/consts.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1f54df1101cabc4663906a5b8b6ca99bab6267a3/src%2Flibrustc_passes%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f54df1101cabc4663906a5b8b6ca99bab6267a3/src%2Flibrustc_passes%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fconsts.rs?ref=1f54df1101cabc4663906a5b8b6ca99bab6267a3", "patch": "@@ -320,8 +320,7 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Expr, node\n         }\n         hir::ExprCast(ref from, _) => {\n             debug!(\"Checking const cast(id={})\", from.id);\n-            v.tables.validate_hir_id(from.hir_id);\n-            match v.tables.cast_kinds.get(&from.hir_id.local_id) {\n+            match v.tables.cast_kinds().get(from.hir_id) {\n                 None => span_bug!(e.span, \"no kind for cast\"),\n                 Some(&CastKind::PtrAddrCast) | Some(&CastKind::FnPtrAddrCast) => {\n                     v.promotable = false;\n@@ -388,8 +387,7 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Expr, node\n             }\n         }\n         hir::ExprMethodCall(..) => {\n-            v.tables.validate_hir_id(e.hir_id);\n-            let def_id = v.tables.type_dependent_defs[&e.hir_id.local_id].def_id();\n+            let def_id = v.tables.type_dependent_defs()[e.hir_id].def_id();\n             match v.tcx.associated_item(def_id).container {\n                 ty::ImplContainer(_) => v.handle_const_fn_call(def_id, node_ty),\n                 ty::TraitContainer(_) => v.promotable = false"}, {"sha": "6f8c6a5ed3b03fad44841e10c35f233d4d5fcab5", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1f54df1101cabc4663906a5b8b6ca99bab6267a3/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f54df1101cabc4663906a5b8b6ca99bab6267a3/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=1f54df1101cabc4663906a5b8b6ca99bab6267a3", "patch": "@@ -649,7 +649,7 @@ impl<'a, 'tcx> TypePrivacyVisitor<'a, 'tcx> {\n         if self.tables.node_substs(id).visit_with(self) {\n             return true;\n         }\n-        if let Some(adjustments) = self.tables.adjustments.get(&id.local_id) {\n+        if let Some(adjustments) = self.tables.adjustments().get(id) {\n             for adjustment in adjustments {\n                 if adjustment.target.visit_with(self) {\n                     return true;\n@@ -748,8 +748,7 @@ impl<'a, 'tcx> Visitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n             }\n             hir::ExprMethodCall(_, span, _) => {\n                 // Method calls have to be checked specially.\n-                self.tables.validate_hir_id(expr.hir_id);\n-                let def_id = self.tables.type_dependent_defs[&expr.hir_id.local_id].def_id();\n+                let def_id = self.tables.type_dependent_defs()[expr.hir_id].def_id();\n                 self.span = span;\n                 if self.tcx.type_of(def_id).visit_with(self) {\n                     return;\n@@ -766,8 +765,7 @@ impl<'a, 'tcx> Visitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n         // we have to check it additionally.\n         if let hir::QPath::TypeRelative(..) = *qpath {\n             let hir_id = self.tcx.hir.node_to_hir_id(id);\n-            self.tables.validate_hir_id(hir_id);\n-            if let Some(def) = self.tables.type_dependent_defs.get(&hir_id.local_id).cloned() {\n+            if let Some(def) = self.tables.type_dependent_defs().get(hir_id).cloned() {\n                 if let Some(assoc_item) = self.tcx.opt_associated_item(def.def_id()) {\n                     if let ty::ImplContainer(impl_def_id) = assoc_item.container {\n                         if self.tcx.type_of(impl_def_id).visit_with(self) {"}, {"sha": "8baea0fd83db8bc84dfae8f0e37933511eea63de", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1f54df1101cabc4663906a5b8b6ca99bab6267a3/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f54df1101cabc4663906a5b8b6ca99bab6267a3/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=1f54df1101cabc4663906a5b8b6ca99bab6267a3", "patch": "@@ -550,8 +550,8 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                 }\n             }\n             ast::ExprKind::MethodCall(..) => {\n-                let local_id = self.tcx.hir.definitions().node_to_hir_id(expr.id).local_id;\n-                let method_id = self.tables.type_dependent_defs[&local_id].def_id();\n+                let expr_hir_id = self.tcx.hir.definitions().node_to_hir_id(expr.id);\n+                let method_id = self.tables.type_dependent_defs()[expr_hir_id].def_id();\n                 let (def_id, decl_id) = match self.tcx.associated_item(method_id).container {\n                     ty::ImplContainer(_) => (Some(method_id), None),\n                     ty::TraitContainer(_) => (None, Some(method_id)),"}, {"sha": "b49b9377e8c56095370a006a19ba8cd5c4016fe1", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1f54df1101cabc4663906a5b8b6ca99bab6267a3/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f54df1101cabc4663906a5b8b6ca99bab6267a3/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=1f54df1101cabc4663906a5b8b6ca99bab6267a3", "patch": "@@ -118,11 +118,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 // identical to what could be scraped from the HIR, but this will change with\n                 // default binding modes (#42640).\n                 let bm = ty::BindingMode::convert(ba);\n-                {\n-                    let mut inh_tables = self.inh.tables.borrow_mut();\n-                    inh_tables.validate_hir_id(pat.hir_id);\n-                    inh_tables.pat_binding_modes.insert(pat.hir_id.local_id, bm);\n-                }\n+                self.inh\n+                    .tables\n+                    .borrow_mut()\n+                    .pat_binding_modes_mut()\n+                    .insert(pat.hir_id, bm);\n                 let typ = self.local_ty(pat.span, pat.id);\n                 match bm {\n                     ty::BindByReference(mutbl) => {"}, {"sha": "b18b11f3d906992c2f4bfb09dc5c775672fd893b", "filename": "src/librustc_typeck/check/cast.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1f54df1101cabc4663906a5b8b6ca99bab6267a3/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f54df1101cabc4663906a5b8b6ca99bab6267a3/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs?ref=1f54df1101cabc4663906a5b8b6ca99bab6267a3", "patch": "@@ -330,16 +330,13 @@ impl<'a, 'gcx, 'tcx> CastCheck<'tcx> {\n         } else if self.try_coercion_cast(fcx) {\n             self.trivial_cast_lint(fcx);\n             debug!(\" -> CoercionCast\");\n-            let mut tables = fcx.tables.borrow_mut();\n-            tables.validate_hir_id(self.expr.hir_id);\n-            tables.cast_kinds.insert(self.expr.hir_id.local_id, CastKind::CoercionCast);\n+            fcx.tables.borrow_mut().cast_kinds_mut().insert(self.expr.hir_id,\n+                                                            CastKind::CoercionCast);\n         } else {\n             match self.do_check(fcx) {\n                 Ok(k) => {\n                     debug!(\" -> {:?}\", k);\n-                    let mut tables = fcx.tables.borrow_mut();\n-                    tables.validate_hir_id(self.expr.hir_id);\n-                    tables.cast_kinds.insert(self.expr.hir_id.local_id, k);\n+                    fcx.tables.borrow_mut().cast_kinds_mut().insert(self.expr.hir_id, k);\n                 }\n                 Err(e) => self.report_cast_error(fcx, e),\n             };"}, {"sha": "61795a7e623d3f253f019c7ec70c857fc124083f", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1f54df1101cabc4663906a5b8b6ca99bab6267a3/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f54df1101cabc4663906a5b8b6ca99bab6267a3/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=1f54df1101cabc4663906a5b8b6ca99bab6267a3", "patch": "@@ -104,11 +104,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         {\n             let mut tables = self.tables.borrow_mut();\n-            tables.validate_hir_id(expr.hir_id);\n-            tables.closure_tys.insert(expr.hir_id.local_id, sig);\n+            tables.closure_tys_mut().insert(expr.hir_id, sig);\n             match opt_kind {\n                 Some(kind) => {\n-                    tables.closure_kinds.insert(expr.hir_id.local_id, (kind, None));\n+                    tables.closure_kinds_mut().insert(expr.hir_id, (kind, None));\n                 }\n                 None => {}\n             }"}, {"sha": "53f3d811fae4fb9d3ebba7d8f441197c40ca7e8e", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1f54df1101cabc4663906a5b8b6ca99bab6267a3/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f54df1101cabc4663906a5b8b6ca99bab6267a3/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=1f54df1101cabc4663906a5b8b6ca99bab6267a3", "patch": "@@ -844,7 +844,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // First try to coerce the new expression to the type of the previous ones,\n         // but only if the new expression has no coercion already applied to it.\n         let mut first_error = None;\n-        if !self.tables.borrow().adjustments.contains_key(&new.hir_id.local_id) {\n+        if !self.tables.borrow().adjustments().contains_key(new.hir_id) {\n             let result = self.commit_if_ok(|_| coerce.coerce(new_ty, prev_ty));\n             match result {\n                 Ok(ok) => {"}, {"sha": "355e6cdbbe074b2093cc3d4012bc0bee7b1938eb", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1f54df1101cabc4663906a5b8b6ca99bab6267a3/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f54df1101cabc4663906a5b8b6ca99bab6267a3/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=1f54df1101cabc4663906a5b8b6ca99bab6267a3", "patch": "@@ -451,8 +451,8 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n             // tables borrowed during (`deref_mut`) method resolution.\n             let previous_adjustments = self.tables\n                                            .borrow_mut()\n-                                           .adjustments\n-                                           .remove(&expr.hir_id.local_id);\n+                                           .adjustments_mut()\n+                                           .remove(expr.hir_id);\n             if let Some(mut adjustments) = previous_adjustments {\n                 let pref = LvaluePreference::PreferMutLvalue;\n                 for adjustment in &mut adjustments {\n@@ -469,7 +469,7 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n                     }\n                     source = adjustment.target;\n                 }\n-                self.tables.borrow_mut().adjustments.insert(expr.hir_id.local_id, adjustments);\n+                self.tables.borrow_mut().adjustments_mut().insert(expr.hir_id, adjustments);\n             }\n \n             match expr.node {\n@@ -529,8 +529,8 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n         let base_expr_ty = self.node_ty(base_expr.hir_id);\n         if let Some(adjustments) = self.tables\n                                        .borrow_mut()\n-                                       .adjustments\n-                                       .get_mut(&base_expr.hir_id.local_id) {\n+                                       .adjustments_mut()\n+                                       .get_mut(base_expr.hir_id) {\n             let mut source = base_expr_ty;\n             for adjustment in &mut adjustments[..] {\n                 if let Adjust::Borrow(AutoBorrow::Ref(..)) = adjustment.kind {"}, {"sha": "5de4a35bdc724ce687d616d294101c2bfca2d937", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1f54df1101cabc4663906a5b8b6ca99bab6267a3/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f54df1101cabc4663906a5b8b6ca99bab6267a3/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=1f54df1101cabc4663906a5b8b6ca99bab6267a3", "patch": "@@ -829,9 +829,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n             };\n \n             let closure_kind = {\n-                let tables = self.tables.borrow();\n-                tables.validate_hir_id(closure_id);\n-                match tables.closure_kinds.get(&closure_id.local_id) {\n+                match self.tables.borrow().closure_kinds().get(closure_id) {\n                     Some(&(k, _)) => k,\n                     None => {\n                         return Err(MethodError::ClosureAmbiguity(trait_def_id));"}, {"sha": "483b5bb1020949a5aeae61cb8eeafcd5e21fd6a3", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 18, "deletions": 36, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/1f54df1101cabc4663906a5b8b6ca99bab6267a3/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f54df1101cabc4663906a5b8b6ca99bab6267a3/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=1f54df1101cabc4663906a5b8b6ca99bab6267a3", "patch": "@@ -744,7 +744,7 @@ fn closure_kind<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                           -> ty::ClosureKind {\n     let node_id = tcx.hir.as_local_node_id(def_id).unwrap();\n     let hir_id = tcx.hir.node_to_hir_id(node_id);\n-    tcx.typeck_tables_of(def_id).closure_kinds[&hir_id.local_id].0\n+    tcx.typeck_tables_of(def_id).closure_kinds()[hir_id].0\n }\n \n fn adt_destructor<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n@@ -1028,12 +1028,8 @@ fn check_fn<'a, 'gcx, 'tcx>(inherited: &'a Inherited<'a, 'gcx, 'tcx>,\n         fcx.write_ty(arg.hir_id, arg_ty);\n     }\n \n-    {\n-        let mut inh_tables = inherited.tables.borrow_mut();\n-        let fn_hir_id = fcx.tcx.hir.node_to_hir_id(fn_id);\n-        inh_tables.validate_hir_id(fn_hir_id);\n-        inh_tables.liberated_fn_sigs.insert(fn_hir_id.local_id, fn_sig);\n-    }\n+    let fn_hir_id = fcx.tcx.hir.node_to_hir_id(fn_id);\n+    inherited.tables.borrow_mut().liberated_fn_sigs_mut().insert(fn_hir_id, fn_sig);\n \n     fcx.check_return_expr(&body.value);\n \n@@ -1816,11 +1812,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     pub fn write_ty(&self, id: hir::HirId, ty: Ty<'tcx>) {\n         debug!(\"write_ty({:?}, {:?}) in fcx {}\",\n                id, self.resolve_type_vars_if_possible(&ty), self.tag());\n-        {\n-            let mut tables = self.tables.borrow_mut();\n-            tables.validate_hir_id(id);\n-            tables.node_types.insert(id.local_id, ty);\n-        }\n+        self.tables.borrow_mut().node_types_mut().insert(id, ty);\n \n         if ty.references_error() {\n             self.has_errors.set(true);\n@@ -1833,11 +1825,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     pub fn write_method_call(&self,\n                              hir_id: hir::HirId,\n                              method: MethodCallee<'tcx>) {\n-        {\n-            let mut tables = self.tables.borrow_mut();\n-            tables.validate_hir_id(hir_id);\n-            tables.type_dependent_defs.insert(hir_id.local_id, Def::Method(method.def_id));\n-        }\n+        self.tables\n+            .borrow_mut()\n+            .type_dependent_defs_mut()\n+            .insert(hir_id, Def::Method(method.def_id));\n         self.write_substs(hir_id, method.substs);\n     }\n \n@@ -1848,9 +1839,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                    substs,\n                    self.tag());\n \n-            let mut tables = self.tables.borrow_mut();\n-            tables.validate_hir_id(node_id);\n-            tables.node_substs.insert(node_id.local_id, substs);\n+            self.tables.borrow_mut().node_substs_mut().insert(node_id, substs);\n         }\n     }\n \n@@ -1861,9 +1850,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             return;\n         }\n \n-        let mut tables = self.tables.borrow_mut();\n-        tables.validate_hir_id(expr.hir_id);\n-        match tables.adjustments.entry(expr.hir_id.local_id) {\n+        match self.tables.borrow_mut().adjustments_mut().entry(expr.hir_id) {\n             Entry::Vacant(entry) => { entry.insert(adj); },\n             Entry::Occupied(mut entry) => {\n                 debug!(\" - composing on top of {:?}\", entry.get());\n@@ -2017,9 +2004,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn node_ty(&self, id: hir::HirId) -> Ty<'tcx> {\n-        let tables = self.tables.borrow();\n-        tables.validate_hir_id(id);\n-        match tables.node_types.get(&id.local_id) {\n+        match self.tables.borrow().node_types().get(id) {\n             Some(&t) => t,\n             None if self.err_count_since_creation() != 0 => self.tcx.types.err,\n             None => {\n@@ -2682,7 +2667,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // While we don't allow *arbitrary* coercions here, we *do* allow\n         // coercions from ! to `expected`.\n         if ty.is_never() {\n-            assert!(!self.tables.borrow().adjustments.contains_key(&expr.hir_id.local_id),\n+            assert!(!self.tables.borrow().adjustments().contains_key(expr.hir_id),\n                     \"expression with never type wound up being adjusted\");\n             let adj_ty = self.next_diverging_ty_var(\n                 TypeVariableOrigin::AdjustmentType(expr.span));\n@@ -3408,9 +3393,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         self.normalize_associated_types_in(expr.span, &f.ty(self.tcx, substs))\n                     }).collect();\n \n-                    let mut tables = self.tables.borrow_mut();\n-                    tables.validate_hir_id(expr.hir_id);\n-                    tables.fru_field_types.insert(expr.hir_id.local_id, fru_field_types);\n+                    self.tables\n+                        .borrow_mut()\n+                        .fru_field_types_mut()\n+                        .insert(expr.hir_id, fru_field_types);\n                 }\n                 _ => {\n                     span_err!(self.tcx.sess, base_expr.span, E0436,\n@@ -4043,9 +4029,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n                 // Write back the new resolution.\n                 let hir_id = self.tcx.hir.node_to_hir_id(node_id);\n-                let mut tables = self.tables.borrow_mut();\n-                tables.validate_hir_id(hir_id);\n-                tables.type_dependent_defs.insert(hir_id.local_id, def);\n+                self.tables.borrow_mut().type_dependent_defs_mut().insert(hir_id, def);\n \n                 (def, ty)\n             }\n@@ -4087,9 +4071,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         // Write back the new resolution.\n         let hir_id = self.tcx.hir.node_to_hir_id(node_id);\n-        let mut tables = self.tables.borrow_mut();\n-        tables.validate_hir_id(hir_id);\n-        tables.type_dependent_defs.insert(hir_id.local_id, def);\n+        self.tables.borrow_mut().type_dependent_defs_mut().insert(hir_id, def);\n         (def, Some(ty), slice::ref_slice(&**item_segment))\n     }\n "}, {"sha": "a4e1fdaf39e29a4a306d23dcba5a198c8b918e24", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1f54df1101cabc4663906a5b8b6ca99bab6267a3/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f54df1101cabc4663906a5b8b6ca99bab6267a3/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=1f54df1101cabc4663906a5b8b6ca99bab6267a3", "patch": "@@ -210,10 +210,12 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         // some cases applied on the RHS, on top of which we need\n                         // to autoref, which is not allowed by apply_adjustments.\n                         // self.apply_adjustments(rhs_expr, vec![autoref]);\n-                        let mut tables = self.tables.borrow_mut();\n-                        tables.validate_hir_id(rhs_expr.hir_id);\n-                        tables.adjustments.entry(rhs_expr.hir_id.local_id)\n-                            .or_insert(vec![]).push(autoref);\n+                        self.tables\n+                            .borrow_mut()\n+                            .adjustments_mut()\n+                            .entry(rhs_expr.hir_id)\n+                            .or_insert(vec![])\n+                            .push(autoref);\n                     }\n                 }\n                 self.write_method_call(expr.hir_id, method);"}, {"sha": "b187075a36d27f7840b6f8a3706308bccda61e9e", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 9, "deletions": 14, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/1f54df1101cabc4663906a5b8b6ca99bab6267a3/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f54df1101cabc4663906a5b8b6ca99bab6267a3/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=1f54df1101cabc4663906a5b8b6ca99bab6267a3", "patch": "@@ -309,10 +309,8 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n         let old_call_site_scope = self.set_call_site_scope(Some(call_site));\n \n         let fn_sig = {\n-            let tables = self.tables.borrow();\n             let fn_hir_id = self.tcx.hir.node_to_hir_id(id);\n-            tables.validate_hir_id(fn_hir_id);\n-            match tables.liberated_fn_sigs.get(&fn_hir_id.local_id) {\n+            match self.tables.borrow().liberated_fn_sigs().get(fn_hir_id) {\n                 Some(f) => f.clone(),\n                 None => {\n                     bug!(\"No fn-sig entry for id={}\", id);\n@@ -1121,14 +1119,12 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n         // report errors later on in the writeback phase.\n         let ty0 = self.resolve_node_type(hir_id);\n \n-        let ty = {\n-            let tables = self.tables.borrow();\n-            tables.validate_hir_id(hir_id);\n-            tables.adjustments\n-                  .get(&hir_id.local_id)\n-                  .and_then(|adj| adj.last())\n-                  .map_or(ty0, |adj| adj.target)\n-        };\n+        let ty = self.tables\n+                     .borrow()\n+                     .adjustments()\n+                     .get(hir_id)\n+                     .and_then(|adj| adj.last())\n+                     .map_or(ty0, |adj| adj.target);\n         let ty = self.resolve_type(ty);\n         debug!(\"constrain_regions_in_type_of_node(\\\n                 ty={}, ty0={}, id={:?}, minimum_lifetime={:?})\",\n@@ -1207,9 +1203,8 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n                 match sub_pat.node {\n                     // `ref x` pattern\n                     PatKind::Binding(..) => {\n-                        mc.tables.validate_hir_id(sub_pat.hir_id);\n-                        let bm = *mc.tables.pat_binding_modes.get(&sub_pat.hir_id.local_id)\n-                                                             .expect(\"missing binding mode\");\n+                        let bm = *mc.tables.pat_binding_modes().get(sub_pat.hir_id)\n+                                                               .expect(\"missing binding mode\");\n                         if let ty::BindByReference(mutbl) = bm {\n                             self.link_region_from_node_type(sub_pat.span, sub_pat.hir_id,\n                                                             mutbl, sub_cmt);"}, {"sha": "6db5c5b1cb0af84916ee8ef3b363831fff173040", "filename": "src/librustc_typeck/check/upvar.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1f54df1101cabc4663906a5b8b6ca99bab6267a3/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f54df1101cabc4663906a5b8b6ca99bab6267a3/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs?ref=1f54df1101cabc4663906a5b8b6ca99bab6267a3", "patch": "@@ -103,8 +103,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         let infer_kind = match self.tables\n                                    .borrow_mut()\n-                                   .closure_kinds\n-                                   .entry(closure_hir_id.local_id) {\n+                                   .closure_kinds_mut()\n+                                   .entry(closure_hir_id) {\n             Entry::Occupied(_) => false,\n             Entry::Vacant(entry) => {\n                 debug!(\"check_closure: adding closure {:?} as Fn\", closure_node_id);\n@@ -162,8 +162,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                             .remove(&closure_def_id.index) {\n                     self.tables\n                         .borrow_mut()\n-                        .closure_kinds\n-                        .insert(closure_hir_id.local_id, kind);\n+                        .closure_kinds_mut()\n+                        .insert(closure_hir_id, kind);\n                 }\n             }\n             self.tables.borrow_mut().upvar_capture_map.extend(\n@@ -482,9 +482,7 @@ impl<'a, 'gcx, 'tcx> InferBorrowKind<'a, 'gcx, 'tcx> {\n         let closure_kind = self.adjust_closure_kinds.get(&closure_id).cloned()\n             .or_else(|| {\n                 let closure_id = self.fcx.tcx.hir.def_index_to_hir_id(closure_id);\n-                let fcx_tables = self.fcx.tables.borrow();\n-                fcx_tables.validate_hir_id(closure_id);\n-                fcx_tables.closure_kinds.get(&closure_id.local_id).cloned()\n+                self.fcx.tables.borrow().closure_kinds().get(closure_id).cloned()\n             });\n \n         if let Some((existing_kind, _)) = closure_kind {"}, {"sha": "0e7083b72f5faebb24d46dc7825e21102b37de37", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 55, "deletions": 48, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/1f54df1101cabc4663906a5b8b6ca99bab6267a3/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f54df1101cabc4663906a5b8b6ca99bab6267a3/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=1f54df1101cabc4663906a5b8b6ca99bab6267a3", "patch": "@@ -93,8 +93,7 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n     fn write_ty_to_tables(&mut self, hir_id: hir::HirId, ty: Ty<'gcx>) {\n         debug!(\"write_ty_to_tables({:?}, {:?})\", hir_id,  ty);\n         assert!(!ty.needs_infer());\n-        self.tables.validate_hir_id(hir_id);\n-        self.tables.node_types.insert(hir_id.local_id, ty);\n+        self.tables.node_types_mut().insert(hir_id, ty);\n     }\n \n     // Hacky hack: During type-checking, we treat *all* operators\n@@ -110,9 +109,8 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n \n                 if inner_ty.is_scalar() {\n                     let mut tables = self.fcx.tables.borrow_mut();\n-                    tables.validate_hir_id(e.hir_id);\n-                    tables.type_dependent_defs.remove(&e.hir_id.local_id);\n-                    tables.node_substs.remove(&e.hir_id.local_id);\n+                    tables.type_dependent_defs_mut().remove(e.hir_id);\n+                    tables.node_substs_mut().remove(e.hir_id);\n                 }\n             }\n             hir::ExprBinary(ref op, ref lhs, ref rhs) |\n@@ -125,19 +123,19 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n \n                 if lhs_ty.is_scalar() && rhs_ty.is_scalar() {\n                     let mut tables = self.fcx.tables.borrow_mut();\n-                    tables.validate_hir_id(e.hir_id);\n-                    tables.type_dependent_defs.remove(&e.hir_id.local_id);\n-                    tables.node_substs.remove(&e.hir_id.local_id);\n+                    tables.type_dependent_defs_mut().remove(e.hir_id);\n+                    tables.node_substs_mut().remove(e.hir_id);\n \n                     match e.node {\n                         hir::ExprBinary(..) => {\n                             if !op.node.is_by_value() {\n-                                tables.adjustments.get_mut(&lhs.hir_id.local_id).map(|a| a.pop());\n-                                tables.adjustments.get_mut(&rhs.hir_id.local_id).map(|a| a.pop());\n+                                let mut adjustments = tables.adjustments_mut();\n+                                adjustments.get_mut(lhs.hir_id).map(|a| a.pop());\n+                                adjustments.get_mut(rhs.hir_id).map(|a| a.pop());\n                             }\n                         },\n                         hir::ExprAssignOp(..) => {\n-                            tables.adjustments.get_mut(&lhs.hir_id.local_id).map(|a| a.pop());\n+                            tables.adjustments_mut().get_mut(lhs.hir_id).map(|a| a.pop());\n                         },\n                         _ => {},\n                     }\n@@ -186,14 +184,13 @@ impl<'cx, 'gcx, 'tcx> Visitor<'gcx> for WritebackCx<'cx, 'gcx, 'tcx> {\n     fn visit_pat(&mut self, p: &'gcx hir::Pat) {\n         match p.node {\n             hir::PatKind::Binding(..) => {\n-                let bm = {\n-                    let fcx_tables = self.fcx.tables.borrow();\n-                    fcx_tables.validate_hir_id(p.hir_id);\n-                    *fcx_tables.pat_binding_modes.get(&p.hir_id.local_id)\n-                                                 .expect(\"missing binding mode\")\n-                };\n-                self.tables.validate_hir_id(p.hir_id);\n-                self.tables.pat_binding_modes.insert(p.hir_id.local_id, bm);\n+                let bm = *self.fcx\n+                              .tables\n+                              .borrow()\n+                              .pat_binding_modes()\n+                              .get(p.hir_id)\n+                              .expect(\"missing binding mode\");\n+                self.tables.pat_binding_modes_mut().insert(p.hir_id, bm);\n             }\n             _ => {}\n         };\n@@ -233,23 +230,36 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n         let fcx_tables = self.fcx.tables.borrow();\n         debug_assert_eq!(fcx_tables.local_id_root, self.tables.local_id_root);\n \n-        for (&id, closure_ty) in fcx_tables.closure_tys.iter() {\n+        for (&id, closure_ty) in fcx_tables.closure_tys().iter() {\n             let hir_id = hir::HirId {\n                 owner: fcx_tables.local_id_root.index,\n                 local_id: id,\n             };\n             let closure_ty = self.resolve(closure_ty, &hir_id);\n-            self.tables.closure_tys.insert(id, closure_ty);\n+            self.tables.closure_tys_mut().insert(hir_id, closure_ty);\n         }\n \n-        for (&id, &closure_kind) in fcx_tables.closure_kinds.iter() {\n-            self.tables.closure_kinds.insert(id, closure_kind);\n+        for (&id, &closure_kind) in fcx_tables.closure_kinds().iter() {\n+            let hir_id = hir::HirId {\n+                owner: fcx_tables.local_id_root.index,\n+                local_id: id,\n+            };\n+            self.tables.closure_kinds_mut().insert(hir_id, closure_kind);\n         }\n     }\n \n     fn visit_cast_types(&mut self) {\n-        self.tables.cast_kinds.extend(\n-            self.fcx.tables.borrow().cast_kinds.iter().map(|(&key, &value)| (key, value)));\n+        let fcx_tables = self.fcx.tables.borrow();\n+        let fcx_cast_kinds = fcx_tables.cast_kinds();\n+        let mut self_cast_kinds = self.tables.cast_kinds_mut();\n+\n+        for (&local_id, &cast_kind) in fcx_cast_kinds.iter() {\n+            let hir_id = hir::HirId {\n+                owner: fcx_tables.local_id_root.index,\n+                local_id,\n+            };\n+            self_cast_kinds.insert(hir_id, cast_kind);\n+        }\n     }\n \n     fn visit_free_region_map(&mut self) {\n@@ -293,20 +303,18 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n             });\n \n             let hir_id = self.tcx().hir.node_to_hir_id(node_id);\n-            self.tables.validate_hir_id(hir_id);\n-            self.tables.node_types.insert(hir_id.local_id, outside_ty);\n+            self.tables.node_types_mut().insert(hir_id, outside_ty);\n         }\n     }\n \n     fn visit_node_id(&mut self, span: Span, hir_id: hir::HirId) {\n-        {\n-            let mut fcx_tables = self.fcx.tables.borrow_mut();\n-            fcx_tables.validate_hir_id(hir_id);\n-            // Export associated path extensions and method resultions.\n-            if let Some(def) = fcx_tables.type_dependent_defs.remove(&hir_id.local_id) {\n-                self.tables.validate_hir_id(hir_id);\n-                self.tables.type_dependent_defs.insert(hir_id.local_id, def);\n-            }\n+        // Export associated path extensions and method resultions.\n+        if let Some(def) = self.fcx\n+                               .tables\n+                               .borrow_mut()\n+                               .type_dependent_defs_mut()\n+                               .remove(hir_id) {\n+            self.tables.type_dependent_defs_mut().insert(hir_id, def);\n         }\n \n         // Resolve any borrowings for the node with id `node_id`\n@@ -319,20 +327,20 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n         debug!(\"Node {:?} has type {:?}\", hir_id, n_ty);\n \n         // Resolve any substitutions\n-        if let Some(&substs) = self.fcx.tables.borrow().node_substs.get(&hir_id.local_id) {\n+        if let Some(substs) = self.fcx.tables.borrow().node_substs_opt(hir_id) {\n             let substs = self.resolve(&substs, &span);\n             debug!(\"write_substs_to_tcx({:?}, {:?})\", hir_id, substs);\n             assert!(!substs.needs_infer());\n-            self.tables.node_substs.insert(hir_id.local_id, substs);\n+            self.tables.node_substs_mut().insert(hir_id, substs);\n         }\n     }\n \n     fn visit_adjustments(&mut self, span: Span, hir_id: hir::HirId) {\n-        let adjustment = {\n-            let mut fcx_tables = self.fcx.tables.borrow_mut();\n-            fcx_tables.validate_hir_id(hir_id);\n-            fcx_tables.adjustments.remove(&hir_id.local_id)\n-        };\n+        let adjustment = self.fcx\n+                             .tables\n+                             .borrow_mut()\n+                             .adjustments_mut()\n+                             .remove(hir_id);\n         match adjustment {\n             None => {\n                 debug!(\"No adjustments for node {:?}\", hir_id);\n@@ -341,8 +349,7 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n             Some(adjustment) => {\n                 let resolved_adjustment = self.resolve(&adjustment, &span);\n                 debug!(\"Adjustments for node {:?}: {:?}\", hir_id, resolved_adjustment);\n-                self.tables.validate_hir_id(hir_id);\n-                self.tables.adjustments.insert(hir_id.local_id, resolved_adjustment);\n+                self.tables.adjustments_mut().insert(hir_id, resolved_adjustment);\n             }\n         }\n     }\n@@ -351,27 +358,27 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n         let fcx_tables = self.fcx.tables.borrow();\n         debug_assert_eq!(fcx_tables.local_id_root, self.tables.local_id_root);\n \n-        for (&local_id, fn_sig) in fcx_tables.liberated_fn_sigs.iter() {\n+        for (&local_id, fn_sig) in fcx_tables.liberated_fn_sigs().iter() {\n             let hir_id = hir::HirId {\n                 owner: fcx_tables.local_id_root.index,\n                 local_id,\n             };\n             let fn_sig = self.resolve(fn_sig, &hir_id);\n-            self.tables.liberated_fn_sigs.insert(local_id, fn_sig.clone());\n+            self.tables.liberated_fn_sigs_mut().insert(hir_id, fn_sig.clone());\n         }\n     }\n \n     fn visit_fru_field_types(&mut self) {\n         let fcx_tables = self.fcx.tables.borrow();\n         debug_assert_eq!(fcx_tables.local_id_root, self.tables.local_id_root);\n \n-        for (&local_id, ftys) in fcx_tables.fru_field_types.iter() {\n+        for (&local_id, ftys) in fcx_tables.fru_field_types().iter() {\n             let hir_id = hir::HirId {\n                 owner: fcx_tables.local_id_root.index,\n                 local_id,\n             };\n             let ftys = self.resolve(ftys, &hir_id);\n-            self.tables.fru_field_types.insert(local_id, ftys);\n+            self.tables.fru_field_types_mut().insert(hir_id, ftys);\n         }\n     }\n "}, {"sha": "91b41eb33a17d71d6ac22baa06306d408e8a21da", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1f54df1101cabc4663906a5b8b6ca99bab6267a3/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f54df1101cabc4663906a5b8b6ca99bab6267a3/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=1f54df1101cabc4663906a5b8b6ca99bab6267a3", "patch": "@@ -1240,9 +1240,7 @@ fn fn_sig<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         }\n \n         NodeExpr(&hir::Expr { node: hir::ExprClosure(..), hir_id, .. }) => {\n-            let tables = tcx.typeck_tables_of(def_id);\n-            tables.validate_hir_id(hir_id);\n-            tables.closure_tys[&hir_id.local_id]\n+            tcx.typeck_tables_of(def_id).closure_tys()[hir_id]\n         }\n \n         x => {"}]}