{"sha": "9539627ac76ca37d617a329dbd79c50c59cf59ee", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk1Mzk2MjdhYzc2Y2EzN2Q2MTdhMzI5ZGJkNzljNTBjNTljZjU5ZWU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-04-10T12:42:46Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-04-10T12:42:46Z"}, "message": "Auto merge of #24034 - alexcrichton:cloexec, r=aturon\n\nThe commit messages have more details as to what's going on, but this is a breaking change for any libraries which expect file descriptors to be inherited by default.\r\n\r\nCloses #12148", "tree": {"sha": "56ee8a716909e505bf222745b656aa4888977441", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/56ee8a716909e505bf222745b656aa4888977441"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9539627ac76ca37d617a329dbd79c50c59cf59ee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9539627ac76ca37d617a329dbd79c50c59cf59ee", "html_url": "https://github.com/rust-lang/rust/commit/9539627ac76ca37d617a329dbd79c50c59cf59ee", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9539627ac76ca37d617a329dbd79c50c59cf59ee/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e4f9ddb878992a9a4edd2667423c29b129ce4301", "url": "https://api.github.com/repos/rust-lang/rust/commits/e4f9ddb878992a9a4edd2667423c29b129ce4301", "html_url": "https://github.com/rust-lang/rust/commit/e4f9ddb878992a9a4edd2667423c29b129ce4301"}, {"sha": "eadc3bcd676277d72c211bde6c20f7036339fd84", "url": "https://api.github.com/repos/rust-lang/rust/commits/eadc3bcd676277d72c211bde6c20f7036339fd84", "html_url": "https://github.com/rust-lang/rust/commit/eadc3bcd676277d72c211bde6c20f7036339fd84"}], "stats": {"total": 704, "additions": 391, "deletions": 313}, "files": [{"sha": "90eabaee77b6b28e47b89ed8226c07c28c0638cf", "filename": "src/libstd/process.rs", "status": "modified", "additions": 11, "deletions": 15, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/9539627ac76ca37d617a329dbd79c50c59cf59ee/src%2Flibstd%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9539627ac76ca37d617a329dbd79c50c59cf59ee/src%2Flibstd%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprocess.rs?ref=9539627ac76ca37d617a329dbd79c50c59cf59ee", "patch": "@@ -19,13 +19,13 @@ use io::prelude::*;\n use ffi::OsStr;\n use fmt;\n use io::{self, Error, ErrorKind};\n-use libc;\n use path;\n use sync::mpsc::{channel, Receiver};\n use sys::pipe2::{self, AnonPipe};\n use sys::process2::Command as CommandImp;\n use sys::process2::Process as ProcessImp;\n use sys::process2::ExitStatus as ExitStatusImp;\n+use sys::process2::Stdio as StdioImp2;\n use sys_common::{AsInner, AsInnerMut};\n use thread;\n \n@@ -229,13 +229,13 @@ impl Command {\n \n     fn spawn_inner(&self, default_io: StdioImp) -> io::Result<Child> {\n         let (their_stdin, our_stdin) = try!(\n-            setup_io(self.stdin.as_ref().unwrap_or(&default_io), 0, true)\n+            setup_io(self.stdin.as_ref().unwrap_or(&default_io), true)\n         );\n         let (their_stdout, our_stdout) = try!(\n-            setup_io(self.stdout.as_ref().unwrap_or(&default_io), 1, false)\n+            setup_io(self.stdout.as_ref().unwrap_or(&default_io), false)\n         );\n         let (their_stderr, our_stderr) = try!(\n-            setup_io(self.stderr.as_ref().unwrap_or(&default_io), 2, false)\n+            setup_io(self.stderr.as_ref().unwrap_or(&default_io), false)\n         );\n \n         match ProcessImp::spawn(&self.inner, their_stdin, their_stdout, their_stderr) {\n@@ -328,23 +328,19 @@ impl AsInnerMut<CommandImp> for Command {\n     fn as_inner_mut(&mut self) -> &mut CommandImp { &mut self.inner }\n }\n \n-fn setup_io(io: &StdioImp, fd: libc::c_int, readable: bool)\n-            -> io::Result<(Option<AnonPipe>, Option<AnonPipe>)>\n+fn setup_io(io: &StdioImp, readable: bool)\n+            -> io::Result<(StdioImp2, Option<AnonPipe>)>\n {\n     use self::StdioImp::*;\n     Ok(match *io {\n-        Null => {\n-            (None, None)\n-        }\n-        Inherit => {\n-            (Some(AnonPipe::from_fd(fd)), None)\n-        }\n+        Null => (StdioImp2::None, None),\n+        Inherit => (StdioImp2::Inherit, None),\n         Piped => {\n-            let (reader, writer) = try!(unsafe { pipe2::anon_pipe() });\n+            let (reader, writer) = try!(pipe2::anon_pipe());\n             if readable {\n-                (Some(reader), Some(writer))\n+                (StdioImp2::Piped(reader), Some(writer))\n             } else {\n-                (Some(writer), Some(reader))\n+                (StdioImp2::Piped(writer), Some(reader))\n             }\n         }\n     })"}, {"sha": "aa4bf821207648a3c4fe7cab02c37115bc2bae81", "filename": "src/libstd/sys/unix/c.rs", "status": "modified", "additions": 21, "deletions": 23, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/9539627ac76ca37d617a329dbd79c50c59cf59ee/src%2Flibstd%2Fsys%2Funix%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9539627ac76ca37d617a329dbd79c50c59cf59ee/src%2Flibstd%2Fsys%2Funix%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fc.rs?ref=9539627ac76ca37d617a329dbd79c50c59cf59ee", "patch": "@@ -26,39 +26,35 @@ use libc;\n           target_os = \"dragonfly\",\n           target_os = \"bitrig\",\n           target_os = \"openbsd\"))]\n-pub const FIONBIO: libc::c_ulong = 0x8004667e;\n-#[cfg(any(all(target_os = \"linux\",\n-              any(target_arch = \"x86\",\n-                  target_arch = \"x86_64\",\n-                  target_arch = \"arm\",\n-                  target_arch = \"aarch64\")),\n-          target_os = \"android\"))]\n-pub const FIONBIO: libc::c_ulong = 0x5421;\n-#[cfg(all(target_os = \"linux\",\n-          any(target_arch = \"mips\",\n-              target_arch = \"mipsel\",\n-              target_arch = \"powerpc\")))]\n-pub const FIONBIO: libc::c_ulong = 0x667e;\n-\n-#[cfg(any(target_os = \"macos\",\n-          target_os = \"ios\",\n-          target_os = \"freebsd\",\n-          target_os = \"dragonfly\",\n-          target_os = \"bitrig\",\n-          target_os = \"openbsd\"))]\n-pub const FIOCLEX: libc::c_ulong = 0x20006601;\n+mod consts {\n+    use libc;\n+    pub const FIONBIO: libc::c_ulong = 0x8004667e;\n+    pub const FIOCLEX: libc::c_ulong = 0x20006601;\n+    pub const FIONCLEX: libc::c_ulong = 0x20006602;\n+}\n #[cfg(any(all(target_os = \"linux\",\n               any(target_arch = \"x86\",\n                   target_arch = \"x86_64\",\n                   target_arch = \"arm\",\n                   target_arch = \"aarch64\")),\n           target_os = \"android\"))]\n-pub const FIOCLEX: libc::c_ulong = 0x5451;\n+mod consts {\n+    use libc;\n+    pub const FIONBIO: libc::c_ulong = 0x5421;\n+    pub const FIOCLEX: libc::c_ulong = 0x5451;\n+    pub const FIONCLEX: libc::c_ulong = 0x5450;\n+}\n #[cfg(all(target_os = \"linux\",\n           any(target_arch = \"mips\",\n               target_arch = \"mipsel\",\n               target_arch = \"powerpc\")))]\n-pub const FIOCLEX: libc::c_ulong = 0x6601;\n+mod consts {\n+    use libc;\n+    pub const FIONBIO: libc::c_ulong = 0x667e;\n+    pub const FIOCLEX: libc::c_ulong = 0x6601;\n+    pub const FIONCLEX: libc::c_ulong = 0x6600;\n+}\n+pub use self::consts::*;\n \n #[cfg(any(target_os = \"macos\",\n           target_os = \"ios\",\n@@ -163,6 +159,8 @@ extern {\n     pub fn utimes(filename: *const libc::c_char,\n                   times: *const libc::timeval) -> libc::c_int;\n     pub fn gai_strerror(errcode: libc::c_int) -> *const libc::c_char;\n+    pub fn setgroups(ngroups: libc::c_int,\n+                     ptr: *const libc::c_void) -> libc::c_int;\n }\n \n #[cfg(any(target_os = \"macos\", target_os = \"ios\"))]"}, {"sha": "d86c77624e833eb5c559c2654c7a5941343d3bcf", "filename": "src/libstd/sys/unix/fd.rs", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/9539627ac76ca37d617a329dbd79c50c59cf59ee/src%2Flibstd%2Fsys%2Funix%2Ffd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9539627ac76ca37d617a329dbd79c50c59cf59ee/src%2Flibstd%2Fsys%2Funix%2Ffd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ffd.rs?ref=9539627ac76ca37d617a329dbd79c50c59cf59ee", "patch": "@@ -13,6 +13,7 @@ use core::prelude::*;\n use io;\n use libc::{self, c_int, size_t, c_void};\n use mem;\n+use sys::c;\n use sys::cvt;\n use sys_common::AsInner;\n \n@@ -51,6 +52,13 @@ impl FileDesc {\n         }));\n         Ok(ret as usize)\n     }\n+\n+    pub fn set_cloexec(&self) {\n+        unsafe {\n+            let ret = c::ioctl(self.fd, c::FIOCLEX);\n+            debug_assert_eq!(ret, 0);\n+        }\n+    }\n }\n \n impl AsInner<c_int> for FileDesc {\n@@ -59,14 +67,11 @@ impl AsInner<c_int> for FileDesc {\n \n impl Drop for FileDesc {\n     fn drop(&mut self) {\n-        // closing stdio file handles makes no sense, so never do it. Also, note\n-        // that errors are ignored when closing a file descriptor. The reason\n-        // for this is that if an error occurs we don't actually know if the\n-        // file descriptor was closed or not, and if we retried (for something\n-        // like EINTR), we might close another valid file descriptor (opened\n-        // after we closed ours.\n-        if self.fd > libc::STDERR_FILENO {\n-            let _ = unsafe { libc::close(self.fd) };\n-        }\n+        // Note that errors are ignored when closing a file descriptor. The\n+        // reason for this is that if an error occurs we don't actually know if\n+        // the file descriptor was closed or not, and if we retried (for\n+        // something like EINTR), we might close another valid file descriptor\n+        // (opened after we closed ours.\n+        let _ = unsafe { libc::close(self.fd) };\n     }\n }"}, {"sha": "ac121f1c82e09ddedade920cbea8f2e6a8300935", "filename": "src/libstd/sys/unix/fs2.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9539627ac76ca37d617a329dbd79c50c59cf59ee/src%2Flibstd%2Fsys%2Funix%2Ffs2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9539627ac76ca37d617a329dbd79c50c59cf59ee/src%2Flibstd%2Fsys%2Funix%2Ffs2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ffs2.rs?ref=9539627ac76ca37d617a329dbd79c50c59cf59ee", "patch": "@@ -205,19 +205,27 @@ impl OpenOptions {\n \n impl File {\n     pub fn open(path: &Path, opts: &OpenOptions) -> io::Result<File> {\n+        let path = try!(cstr(path));\n+        File::open_c(&path, opts)\n+    }\n+\n+    pub fn open_c(path: &CStr, opts: &OpenOptions) -> io::Result<File> {\n         let flags = opts.flags | match (opts.read, opts.write) {\n             (true, true) => libc::O_RDWR,\n             (false, true) => libc::O_WRONLY,\n             (true, false) |\n             (false, false) => libc::O_RDONLY,\n         };\n-        let path = try!(cstr(path));\n         let fd = try!(cvt_r(|| unsafe {\n             libc::open(path.as_ptr(), flags, opts.mode)\n         }));\n-        Ok(File(FileDesc::new(fd)))\n+        let fd = FileDesc::new(fd);\n+        fd.set_cloexec();\n+        Ok(File(fd))\n     }\n \n+    pub fn into_fd(self) -> FileDesc { self.0 }\n+\n     pub fn file_attr(&self) -> io::Result<FileAttr> {\n         let mut stat: libc::stat = unsafe { mem::zeroed() };\n         try!(cvt(unsafe { libc::fstat(self.0.raw(), &mut stat) }));"}, {"sha": "2e1cbb2a1e127094269b6dee8d70fe60eab33685", "filename": "src/libstd/sys/unix/net.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/9539627ac76ca37d617a329dbd79c50c59cf59ee/src%2Flibstd%2Fsys%2Funix%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9539627ac76ca37d617a329dbd79c50c59cf59ee/src%2Flibstd%2Fsys%2Funix%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fnet.rs?ref=9539627ac76ca37d617a329dbd79c50c59cf59ee", "patch": "@@ -47,7 +47,9 @@ impl Socket {\n         };\n         unsafe {\n             let fd = try!(cvt(libc::socket(fam, ty, 0)));\n-            Ok(Socket(FileDesc::new(fd)))\n+            let fd = FileDesc::new(fd);\n+            fd.set_cloexec();\n+            Ok(Socket(fd))\n         }\n     }\n \n@@ -56,13 +58,16 @@ impl Socket {\n         let fd = try!(cvt_r(|| unsafe {\n             libc::accept(self.0.raw(), storage, len)\n         }));\n-        Ok(Socket(FileDesc::new(fd)))\n+        let fd = FileDesc::new(fd);\n+        fd.set_cloexec();\n+        Ok(Socket(fd))\n     }\n \n     pub fn duplicate(&self) -> io::Result<Socket> {\n-        cvt(unsafe { libc::dup(self.0.raw()) }).map(|fd| {\n-            Socket(FileDesc::new(fd))\n-        })\n+        let fd = try!(cvt(unsafe { libc::dup(self.0.raw()) }));\n+        let fd = FileDesc::new(fd);\n+        fd.set_cloexec();\n+        Ok(Socket(fd))\n     }\n \n     pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> {"}, {"sha": "e9d8c69fefb52035cbdb2a341211dcbf76ccab48", "filename": "src/libstd/sys/unix/pipe2.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/9539627ac76ca37d617a329dbd79c50c59cf59ee/src%2Flibstd%2Fsys%2Funix%2Fpipe2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9539627ac76ca37d617a329dbd79c50c59cf59ee/src%2Flibstd%2Fsys%2Funix%2Fpipe2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fpipe2.rs?ref=9539627ac76ca37d617a329dbd79c50c59cf59ee", "patch": "@@ -20,19 +20,20 @@ use libc;\n \n pub struct AnonPipe(FileDesc);\n \n-pub unsafe fn anon_pipe() -> io::Result<(AnonPipe, AnonPipe)> {\n+pub fn anon_pipe() -> io::Result<(AnonPipe, AnonPipe)> {\n     let mut fds = [0; 2];\n-    if libc::pipe(fds.as_mut_ptr()) == 0 {\n-        Ok((AnonPipe::from_fd(fds[0]),\n-            AnonPipe::from_fd(fds[1])))\n+    if unsafe { libc::pipe(fds.as_mut_ptr()) == 0 } {\n+        Ok((AnonPipe::from_fd(fds[0]), AnonPipe::from_fd(fds[1])))\n     } else {\n         Err(io::Error::last_os_error())\n     }\n }\n \n impl AnonPipe {\n     pub fn from_fd(fd: libc::c_int) -> AnonPipe {\n-        AnonPipe(FileDesc::new(fd))\n+        let fd = FileDesc::new(fd);\n+        fd.set_cloexec();\n+        AnonPipe(fd)\n     }\n \n     pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> {\n@@ -43,7 +44,7 @@ impl AnonPipe {\n         self.0.write(buf)\n     }\n \n-    pub fn raw(&self) -> libc::c_int {\n-        self.0.raw()\n+    pub fn into_fd(self) -> FileDesc {\n+        self.0\n     }\n }"}, {"sha": "0b4e871454db044d347fc3b03a421e39c358d254", "filename": "src/libstd/sys/unix/process2.rs", "status": "modified", "additions": 198, "deletions": 230, "changes": 428, "blob_url": "https://github.com/rust-lang/rust/blob/9539627ac76ca37d617a329dbd79c50c59cf59ee/src%2Flibstd%2Fsys%2Funix%2Fprocess2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9539627ac76ca37d617a329dbd79c50c59cf59ee/src%2Flibstd%2Fsys%2Funix%2Fprocess2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fprocess2.rs?ref=9539627ac76ca37d617a329dbd79c50c59cf59ee", "patch": "@@ -13,14 +13,14 @@ use os::unix::prelude::*;\n \n use collections::HashMap;\n use env;\n-use ffi::{OsString, OsStr, CString};\n+use ffi::{OsString, OsStr, CString, CStr};\n use fmt;\n use io::{self, Error, ErrorKind};\n use libc::{self, pid_t, c_void, c_int, gid_t, uid_t};\n-use mem;\n use ptr;\n use sys::pipe2::AnonPipe;\n use sys::{self, retry, c, cvt};\n+use sys::fs2::{File, OpenOptions};\n \n ////////////////////////////////////////////////////////////////////////////////\n // Command\n@@ -119,6 +119,12 @@ pub struct Process {\n     pid: pid_t\n }\n \n+pub enum Stdio {\n+    Inherit,\n+    Piped(AnonPipe),\n+    None,\n+}\n+\n const CLOEXEC_MSG_FOOTER: &'static [u8] = b\"NOEX\";\n \n impl Process {\n@@ -128,221 +134,185 @@ impl Process {\n     }\n \n     pub fn spawn(cfg: &Command,\n-                 in_fd: Option<AnonPipe>, out_fd: Option<AnonPipe>, err_fd: Option<AnonPipe>)\n-                 -> io::Result<Process>\n-    {\n-        use libc::funcs::posix88::unistd::{fork, dup2, close, chdir, execvp};\n-\n-        mod rustrt {\n-            extern {\n-                pub fn rust_unset_sigprocmask();\n+                 in_fd: Stdio,\n+                 out_fd: Stdio,\n+                 err_fd: Stdio) -> io::Result<Process> {\n+        let dirp = cfg.cwd.as_ref().map(|c| c.as_ptr()).unwrap_or(ptr::null());\n+\n+        let (envp, _a, _b) = make_envp(cfg.env.as_ref());\n+        let (argv, _a) = make_argv(&cfg.program, &cfg.args);\n+        let (input, output) = try!(sys::pipe2::anon_pipe());\n+\n+        let pid = unsafe {\n+            match libc::fork() {\n+                0 => {\n+                    drop(input);\n+                    Process::child_after_fork(cfg, output, argv, envp, dirp,\n+                                              in_fd, out_fd, err_fd)\n+                }\n+                n if n < 0 => return Err(Error::last_os_error()),\n+                n => n,\n+            }\n+        };\n+\n+        let p = Process{ pid: pid };\n+        drop(output);\n+        let mut bytes = [0; 8];\n+\n+        // loop to handle EINTR\n+        loop {\n+            match input.read(&mut bytes) {\n+                Ok(0) => return Ok(p),\n+                Ok(8) => {\n+                    assert!(combine(CLOEXEC_MSG_FOOTER) == combine(&bytes[4.. 8]),\n+                            \"Validation on the CLOEXEC pipe failed: {:?}\", bytes);\n+                    let errno = combine(&bytes[0.. 4]);\n+                    assert!(p.wait().is_ok(),\n+                            \"wait() should either return Ok or panic\");\n+                    return Err(Error::from_raw_os_error(errno))\n+                }\n+                Err(ref e) if e.kind() == ErrorKind::Interrupted => {}\n+                Err(e) => {\n+                    assert!(p.wait().is_ok(),\n+                            \"wait() should either return Ok or panic\");\n+                    panic!(\"the CLOEXEC pipe failed: {:?}\", e)\n+                },\n+                Ok(..) => { // pipe I/O up to PIPE_BUF bytes should be atomic\n+                    assert!(p.wait().is_ok(),\n+                            \"wait() should either return Ok or panic\");\n+                    panic!(\"short read on the CLOEXEC pipe\")\n+                }\n             }\n         }\n \n-        unsafe fn set_cloexec(fd: c_int) {\n-            let ret = c::ioctl(fd, c::FIOCLEX);\n-            assert_eq!(ret, 0);\n-        }\n+        fn combine(arr: &[u8]) -> i32 {\n+            let a = arr[0] as u32;\n+            let b = arr[1] as u32;\n+            let c = arr[2] as u32;\n+            let d = arr[3] as u32;\n \n-        #[cfg(all(target_os = \"android\", target_arch = \"aarch64\"))]\n-        unsafe fn getdtablesize() -> c_int {\n-            libc::sysconf(libc::consts::os::sysconf::_SC_OPEN_MAX) as c_int\n+            ((a << 24) | (b << 16) | (c << 8) | (d << 0)) as i32\n         }\n+    }\n \n-        #[cfg(not(all(target_os = \"android\", target_arch = \"aarch64\")))]\n-        unsafe fn getdtablesize() -> c_int {\n-            libc::funcs::bsd44::getdtablesize()\n+    // And at this point we've reached a special time in the life of the\n+    // child. The child must now be considered hamstrung and unable to\n+    // do anything other than syscalls really. Consider the following\n+    // scenario:\n+    //\n+    //      1. Thread A of process 1 grabs the malloc() mutex\n+    //      2. Thread B of process 1 forks(), creating thread C\n+    //      3. Thread C of process 2 then attempts to malloc()\n+    //      4. The memory of process 2 is the same as the memory of\n+    //         process 1, so the mutex is locked.\n+    //\n+    // This situation looks a lot like deadlock, right? It turns out\n+    // that this is what pthread_atfork() takes care of, which is\n+    // presumably implemented across platforms. The first thing that\n+    // threads to *before* forking is to do things like grab the malloc\n+    // mutex, and then after the fork they unlock it.\n+    //\n+    // Despite this information, libnative's spawn has been witnessed to\n+    // deadlock on both OSX and FreeBSD. I'm not entirely sure why, but\n+    // all collected backtraces point at malloc/free traffic in the\n+    // child spawned process.\n+    //\n+    // For this reason, the block of code below should contain 0\n+    // invocations of either malloc of free (or their related friends).\n+    //\n+    // As an example of not having malloc/free traffic, we don't close\n+    // this file descriptor by dropping the FileDesc (which contains an\n+    // allocation). Instead we just close it manually. This will never\n+    // have the drop glue anyway because this code never returns (the\n+    // child will either exec() or invoke libc::exit)\n+    unsafe fn child_after_fork(cfg: &Command,\n+                               mut output: AnonPipe,\n+                               argv: *const *const libc::c_char,\n+                               envp: *const libc::c_void,\n+                               dirp: *const libc::c_char,\n+                               in_fd: Stdio,\n+                               out_fd: Stdio,\n+                               err_fd: Stdio) -> ! {\n+        fn fail(output: &mut AnonPipe) -> ! {\n+            let errno = sys::os::errno() as u32;\n+            let bytes = [\n+                (errno >> 24) as u8,\n+                (errno >> 16) as u8,\n+                (errno >>  8) as u8,\n+                (errno >>  0) as u8,\n+                CLOEXEC_MSG_FOOTER[0], CLOEXEC_MSG_FOOTER[1],\n+                CLOEXEC_MSG_FOOTER[2], CLOEXEC_MSG_FOOTER[3]\n+            ];\n+            // pipe I/O up to PIPE_BUF bytes should be atomic, and then we want\n+            // to be sure we *don't* run at_exit destructors as we're being torn\n+            // down regardless\n+            assert!(output.write(&bytes).is_ok());\n+            unsafe { libc::_exit(1) }\n         }\n \n-        let dirp = cfg.cwd.as_ref().map(|c| c.as_ptr()).unwrap_or(ptr::null());\n-\n-        with_envp(cfg.env.as_ref(), |envp: *const c_void| {\n-            with_argv(&cfg.program, &cfg.args, |argv: *const *const libc::c_char| unsafe {\n-                let (input, mut output) = try!(sys::pipe2::anon_pipe());\n-\n-                // We may use this in the child, so perform allocations before the\n-                // fork\n-                let devnull = b\"/dev/null\\0\";\n-\n-                set_cloexec(output.raw());\n-\n-                let pid = fork();\n-                if pid < 0 {\n-                    return Err(Error::last_os_error())\n-                } else if pid > 0 {\n-                    #[inline]\n-                    fn combine(arr: &[u8]) -> i32 {\n-                        let a = arr[0] as u32;\n-                        let b = arr[1] as u32;\n-                        let c = arr[2] as u32;\n-                        let d = arr[3] as u32;\n-\n-                        ((a << 24) | (b << 16) | (c << 8) | (d << 0)) as i32\n-                    }\n-\n-                    let p = Process{ pid: pid };\n-                    drop(output);\n-                    let mut bytes = [0; 8];\n-\n-                    // loop to handle EINTER\n-                    loop {\n-                        match input.read(&mut bytes) {\n-                            Ok(8) => {\n-                                assert!(combine(CLOEXEC_MSG_FOOTER) == combine(&bytes[4.. 8]),\n-                                        \"Validation on the CLOEXEC pipe failed: {:?}\", bytes);\n-                                let errno = combine(&bytes[0.. 4]);\n-                                assert!(p.wait().is_ok(),\n-                                        \"wait() should either return Ok or panic\");\n-                                return Err(Error::from_raw_os_error(errno))\n-                            }\n-                            Ok(0) => return Ok(p),\n-                            Err(ref e) if e.kind() == ErrorKind::Interrupted => {}\n-                            Err(e) => {\n-                                assert!(p.wait().is_ok(),\n-                                        \"wait() should either return Ok or panic\");\n-                                panic!(\"the CLOEXEC pipe failed: {:?}\", e)\n-                            },\n-                            Ok(..) => { // pipe I/O up to PIPE_BUF bytes should be atomic\n-                                assert!(p.wait().is_ok(),\n-                                        \"wait() should either return Ok or panic\");\n-                                panic!(\"short read on the CLOEXEC pipe\")\n-                            }\n-                        }\n+        let setup = |src: Stdio, dst: c_int| {\n+            let fd = match src {\n+                Stdio::Inherit => return true,\n+                Stdio::Piped(pipe) => pipe.into_fd(),\n+\n+                // If a stdio file descriptor is set to be ignored, we open up\n+                // /dev/null into that file descriptor. Otherwise, the first\n+                // file descriptor opened up in the child would be numbered as\n+                // one of the stdio file descriptors, which is likely to wreak\n+                // havoc.\n+                Stdio::None => {\n+                    let mut opts = OpenOptions::new();\n+                    opts.read(dst == libc::STDIN_FILENO);\n+                    opts.write(dst != libc::STDIN_FILENO);\n+                    let devnull = CStr::from_ptr(b\"/dev/null\\0\".as_ptr()\n+                                                    as *const _);\n+                    if let Ok(f) = File::open_c(devnull, &opts) {\n+                        f.into_fd()\n+                    } else {\n+                        return false\n                     }\n                 }\n+            };\n+            retry(|| libc::dup2(fd.raw(), dst)) != -1\n+        };\n \n-                // And at this point we've reached a special time in the life of the\n-                // child. The child must now be considered hamstrung and unable to\n-                // do anything other than syscalls really. Consider the following\n-                // scenario:\n-                //\n-                //      1. Thread A of process 1 grabs the malloc() mutex\n-                //      2. Thread B of process 1 forks(), creating thread C\n-                //      3. Thread C of process 2 then attempts to malloc()\n-                //      4. The memory of process 2 is the same as the memory of\n-                //         process 1, so the mutex is locked.\n-                //\n-                // This situation looks a lot like deadlock, right? It turns out\n-                // that this is what pthread_atfork() takes care of, which is\n-                // presumably implemented across platforms. The first thing that\n-                // threads to *before* forking is to do things like grab the malloc\n-                // mutex, and then after the fork they unlock it.\n-                //\n-                // Despite this information, libnative's spawn has been witnessed to\n-                // deadlock on both OSX and FreeBSD. I'm not entirely sure why, but\n-                // all collected backtraces point at malloc/free traffic in the\n-                // child spawned process.\n-                //\n-                // For this reason, the block of code below should contain 0\n-                // invocations of either malloc of free (or their related friends).\n-                //\n-                // As an example of not having malloc/free traffic, we don't close\n-                // this file descriptor by dropping the FileDesc (which contains an\n-                // allocation). Instead we just close it manually. This will never\n-                // have the drop glue anyway because this code never returns (the\n-                // child will either exec() or invoke libc::exit)\n-                let _ = libc::close(input.raw());\n-\n-                fn fail(output: &mut AnonPipe) -> ! {\n-                    let errno = sys::os::errno() as u32;\n-                    let bytes = [\n-                        (errno >> 24) as u8,\n-                        (errno >> 16) as u8,\n-                        (errno >>  8) as u8,\n-                        (errno >>  0) as u8,\n-                        CLOEXEC_MSG_FOOTER[0], CLOEXEC_MSG_FOOTER[1],\n-                        CLOEXEC_MSG_FOOTER[2], CLOEXEC_MSG_FOOTER[3]\n-                    ];\n-                    // pipe I/O up to PIPE_BUF bytes should be atomic\n-                    assert!(output.write(&bytes).is_ok());\n-                    unsafe { libc::_exit(1) }\n-                }\n-\n-                rustrt::rust_unset_sigprocmask();\n-\n-                // If a stdio file descriptor is set to be ignored, we don't\n-                // actually close it, but rather open up /dev/null into that\n-                // file descriptor. Otherwise, the first file descriptor opened\n-                // up in the child would be numbered as one of the stdio file\n-                // descriptors, which is likely to wreak havoc.\n-                let setup = |src: Option<AnonPipe>, dst: c_int| {\n-                    let src = match src {\n-                        None => {\n-                            let flags = if dst == libc::STDIN_FILENO {\n-                                libc::O_RDONLY\n-                            } else {\n-                                libc::O_RDWR\n-                            };\n-                            libc::open(devnull.as_ptr() as *const _, flags, 0)\n-                        }\n-                        Some(obj) => {\n-                            let fd = obj.raw();\n-                            // Leak the memory and the file descriptor. We're in the\n-                            // child now an all our resources are going to be\n-                            // cleaned up very soon\n-                            mem::forget(obj);\n-                            fd\n-                        }\n-                    };\n-                    src != -1 && retry(|| dup2(src, dst)) != -1\n-                };\n-\n-                if !setup(in_fd, libc::STDIN_FILENO) { fail(&mut output) }\n-                if !setup(out_fd, libc::STDOUT_FILENO) { fail(&mut output) }\n-                if !setup(err_fd, libc::STDERR_FILENO) { fail(&mut output) }\n-\n-                // close all other fds\n-                for fd in (3..getdtablesize()).rev() {\n-                    if fd != output.raw() {\n-                        let _ = close(fd as c_int);\n-                    }\n-                }\n+        if !setup(in_fd, libc::STDIN_FILENO) { fail(&mut output) }\n+        if !setup(out_fd, libc::STDOUT_FILENO) { fail(&mut output) }\n+        if !setup(err_fd, libc::STDERR_FILENO) { fail(&mut output) }\n \n-                match cfg.gid {\n-                    Some(u) => {\n-                        if libc::setgid(u as libc::gid_t) != 0 {\n-                            fail(&mut output);\n-                        }\n-                    }\n-                    None => {}\n-                }\n-                match cfg.uid {\n-                    Some(u) => {\n-                        // When dropping privileges from root, the `setgroups` call\n-                        // will remove any extraneous groups. If we don't call this,\n-                        // then even though our uid has dropped, we may still have\n-                        // groups that enable us to do super-user things. This will\n-                        // fail if we aren't root, so don't bother checking the\n-                        // return value, this is just done as an optimistic\n-                        // privilege dropping function.\n-                        extern {\n-                            fn setgroups(ngroups: libc::c_int,\n-                                         ptr: *const libc::c_void) -> libc::c_int;\n-                        }\n-                        let _ = setgroups(0, ptr::null());\n-\n-                        if libc::setuid(u as libc::uid_t) != 0 {\n-                            fail(&mut output);\n-                        }\n-                    }\n-                    None => {}\n-                }\n-                if cfg.detach {\n-                    // Don't check the error of setsid because it fails if we're the\n-                    // process leader already. We just forked so it shouldn't return\n-                    // error, but ignore it anyway.\n-                    let _ = libc::setsid();\n-                }\n-                if !dirp.is_null() && chdir(dirp) == -1 {\n-                    fail(&mut output);\n-                }\n-                if !envp.is_null() {\n-                    *sys::os::environ() = envp as *const _;\n-                }\n-                let _ = execvp(*argv, argv as *mut _);\n+        if let Some(u) = cfg.gid {\n+            if libc::setgid(u as libc::gid_t) != 0 {\n                 fail(&mut output);\n-            })\n-        })\n+            }\n+        }\n+        if let Some(u) = cfg.uid {\n+            // When dropping privileges from root, the `setgroups` call\n+            // will remove any extraneous groups. If we don't call this,\n+            // then even though our uid has dropped, we may still have\n+            // groups that enable us to do super-user things. This will\n+            // fail if we aren't root, so don't bother checking the\n+            // return value, this is just done as an optimistic\n+            // privilege dropping function.\n+            let _ = c::setgroups(0, ptr::null());\n+\n+            if libc::setuid(u as libc::uid_t) != 0 {\n+                fail(&mut output);\n+            }\n+        }\n+        if cfg.detach {\n+            // Don't check the error of setsid because it fails if we're the\n+            // process leader already. We just forked so it shouldn't return\n+            // error, but ignore it anyway.\n+            let _ = libc::setsid();\n+        }\n+        if !dirp.is_null() && libc::chdir(dirp) == -1 {\n+            fail(&mut output);\n+        }\n+        if !envp.is_null() {\n+            *sys::os::environ() = envp as *const _;\n+        }\n+        let _ = libc::execvp(*argv, argv as *mut _);\n+        fail(&mut output)\n     }\n \n     pub fn wait(&self) -> io::Result<ExitStatus> {\n@@ -364,8 +334,8 @@ impl Process {\n     }\n }\n \n-fn with_argv<T,F>(prog: &CString, args: &[CString], cb: F) -> T\n-    where F : FnOnce(*const *const libc::c_char) -> T\n+fn make_argv(prog: &CString, args: &[CString])\n+             -> (*const *const libc::c_char, Vec<*const libc::c_char>)\n {\n     let mut ptrs: Vec<*const libc::c_char> = Vec::with_capacity(args.len()+1);\n \n@@ -380,40 +350,38 @@ fn with_argv<T,F>(prog: &CString, args: &[CString], cb: F) -> T\n     // Add a terminating null pointer (required by libc).\n     ptrs.push(ptr::null());\n \n-    cb(ptrs.as_ptr())\n+    (ptrs.as_ptr(), ptrs)\n }\n \n-fn with_envp<T, F>(env: Option<&HashMap<OsString, OsString>>, cb: F) -> T\n-    where F : FnOnce(*const c_void) -> T\n+fn make_envp(env: Option<&HashMap<OsString, OsString>>)\n+             -> (*const c_void, Vec<Vec<u8>>, Vec<*const libc::c_char>)\n {\n     // On posixy systems we can pass a char** for envp, which is a\n     // null-terminated array of \"k=v\\0\" strings. Since we must create\n     // these strings locally, yet expose a raw pointer to them, we\n     // create a temporary vector to own the CStrings that outlives the\n     // call to cb.\n-    match env {\n-        Some(env) => {\n-            let mut tmps = Vec::with_capacity(env.len());\n-\n-            for pair in env {\n-                let mut kv = Vec::new();\n-                kv.push_all(pair.0.as_bytes());\n-                kv.push('=' as u8);\n-                kv.push_all(pair.1.as_bytes());\n-                kv.push(0); // terminating null\n-                tmps.push(kv);\n-            }\n+    if let Some(env) = env {\n+        let mut tmps = Vec::with_capacity(env.len());\n+\n+        for pair in env {\n+            let mut kv = Vec::new();\n+            kv.push_all(pair.0.as_bytes());\n+            kv.push('=' as u8);\n+            kv.push_all(pair.1.as_bytes());\n+            kv.push(0); // terminating null\n+            tmps.push(kv);\n+        }\n \n-            // As with `with_argv`, this is unsafe, since cb could leak the pointers.\n-            let mut ptrs: Vec<*const libc::c_char> =\n-                tmps.iter()\n-                    .map(|tmp| tmp.as_ptr() as *const libc::c_char)\n-                    .collect();\n-            ptrs.push(ptr::null());\n+        let mut ptrs: Vec<*const libc::c_char> =\n+            tmps.iter()\n+                .map(|tmp| tmp.as_ptr() as *const libc::c_char)\n+                .collect();\n+        ptrs.push(ptr::null());\n \n-            cb(ptrs.as_ptr() as *const c_void)\n-        }\n-        _ => cb(ptr::null())\n+        (ptrs.as_ptr() as *const _, tmps, ptrs)\n+    } else {\n+        (0 as *const _, Vec::new(), Vec::new())\n     }\n }\n "}, {"sha": "ed41c95978289f508a481ec922f7ddc6128b5733", "filename": "src/libstd/sys/windows/pipe2.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/9539627ac76ca37d617a329dbd79c50c59cf59ee/src%2Flibstd%2Fsys%2Fwindows%2Fpipe2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9539627ac76ca37d617a329dbd79c50c59cf59ee/src%2Flibstd%2Fsys%2Fwindows%2Fpipe2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fpipe2.rs?ref=9539627ac76ca37d617a329dbd79c50c59cf59ee", "patch": "@@ -22,22 +22,24 @@ pub struct AnonPipe {\n     fd: c_int\n }\n \n-pub unsafe fn anon_pipe() -> io::Result<(AnonPipe, AnonPipe)> {\n+pub fn anon_pipe() -> io::Result<(AnonPipe, AnonPipe)> {\n     // Windows pipes work subtly differently than unix pipes, and their\n     // inheritance has to be handled in a different way that I do not\n     // fully understand. Here we explicitly make the pipe non-inheritable,\n     // which means to pass it to a subprocess they need to be duplicated\n     // first, as in std::run.\n     let mut fds = [0; 2];\n-    match libc::pipe(fds.as_mut_ptr(), 1024 as ::libc::c_uint,\n-    (libc::O_BINARY | libc::O_NOINHERIT) as c_int) {\n-        0 => {\n-            assert!(fds[0] != -1 && fds[0] != 0);\n-            assert!(fds[1] != -1 && fds[1] != 0);\n+    unsafe {\n+        match libc::pipe(fds.as_mut_ptr(), 1024 as ::libc::c_uint,\n+                         (libc::O_BINARY | libc::O_NOINHERIT) as c_int) {\n+            0 => {\n+                assert!(fds[0] != -1 && fds[0] != 0);\n+                assert!(fds[1] != -1 && fds[1] != 0);\n \n-            Ok((AnonPipe::from_fd(fds[0]), AnonPipe::from_fd(fds[1])))\n+                Ok((AnonPipe::from_fd(fds[0]), AnonPipe::from_fd(fds[1])))\n+            }\n+            _ => Err(io::Error::last_os_error()),\n         }\n-        _ => Err(io::Error::last_os_error()),\n     }\n }\n "}, {"sha": "7495392192170ab91914a6bd9196c2954f2737a2", "filename": "src/libstd/sys/windows/process2.rs", "status": "modified", "additions": 33, "deletions": 14, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/9539627ac76ca37d617a329dbd79c50c59cf59ee/src%2Flibstd%2Fsys%2Fwindows%2Fprocess2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9539627ac76ca37d617a329dbd79c50c59cf59ee/src%2Flibstd%2Fsys%2Fwindows%2Fprocess2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fprocess2.rs?ref=9539627ac76ca37d617a329dbd79c50c59cf59ee", "patch": "@@ -105,11 +105,18 @@ pub struct Process {\n     handle: Handle,\n }\n \n+pub enum Stdio {\n+    Inherit,\n+    Piped(AnonPipe),\n+    None,\n+}\n+\n impl Process {\n     #[allow(deprecated)]\n     pub fn spawn(cfg: &Command,\n-                 in_fd: Option<AnonPipe>, out_fd: Option<AnonPipe>, err_fd: Option<AnonPipe>)\n-                 -> io::Result<Process>\n+                 in_fd: Stdio,\n+                 out_fd: Stdio,\n+                 err_fd: Stdio) -> io::Result<Process>\n     {\n         use libc::types::os::arch::extra::{DWORD, HANDLE, STARTUPINFO};\n         use libc::consts::os::extra::{\n@@ -156,13 +163,16 @@ impl Process {\n \n             let cur_proc = GetCurrentProcess();\n \n-            // Similarly to unix, we don't actually leave holes for the stdio file\n-            // descriptors, but rather open up /dev/null equivalents. These\n-            // equivalents are drawn from libuv's windows process spawning.\n-            let set_fd = |fd: &Option<AnonPipe>, slot: &mut HANDLE,\n+            let set_fd = |fd: &Stdio, slot: &mut HANDLE,\n                           is_stdin: bool| {\n                 match *fd {\n-                    None => {\n+                    Stdio::Inherit => {}\n+\n+                    // Similarly to unix, we don't actually leave holes for the\n+                    // stdio file descriptors, but rather open up /dev/null\n+                    // equivalents. These equivalents are drawn from libuv's\n+                    // windows process spawning.\n+                    Stdio::None => {\n                         let access = if is_stdin {\n                             libc::FILE_GENERIC_READ\n                         } else {\n@@ -188,11 +198,8 @@ impl Process {\n                             return Err(Error::last_os_error())\n                         }\n                     }\n-                    Some(ref pipe) => {\n+                    Stdio::Piped(ref pipe) => {\n                         let orig = pipe.raw();\n-                        if orig == INVALID_HANDLE_VALUE {\n-                            return Err(Error::last_os_error())\n-                        }\n                         if DuplicateHandle(cur_proc, orig, cur_proc, slot,\n                                            0, TRUE, DUPLICATE_SAME_ACCESS) == FALSE {\n                             return Err(Error::last_os_error())\n@@ -235,9 +242,15 @@ impl Process {\n                 })\n             });\n \n-            assert!(CloseHandle(si.hStdInput) != 0);\n-            assert!(CloseHandle(si.hStdOutput) != 0);\n-            assert!(CloseHandle(si.hStdError) != 0);\n+            if !in_fd.inherited() {\n+                assert!(CloseHandle(si.hStdInput) != 0);\n+            }\n+            if !out_fd.inherited() {\n+                assert!(CloseHandle(si.hStdOutput) != 0);\n+            }\n+            if !err_fd.inherited() {\n+                assert!(CloseHandle(si.hStdError) != 0);\n+            }\n \n             match create_err {\n                 Some(err) => return Err(err),\n@@ -296,6 +309,12 @@ impl Process {\n     }\n }\n \n+impl Stdio {\n+    fn inherited(&self) -> bool {\n+        match *self { Stdio::Inherit => true, _ => false }\n+    }\n+}\n+\n #[derive(PartialEq, Eq, Clone, Copy, Debug)]\n pub struct ExitStatus(i32);\n "}, {"sha": "cbf7830513ac9bb6f6d958d6bf27e5e514651614", "filename": "src/test/run-pass/fds-are-cloexec.rs", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/9539627ac76ca37d617a329dbd79c50c59cf59ee/src%2Ftest%2Frun-pass%2Ffds-are-cloexec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9539627ac76ca37d617a329dbd79c50c59cf59ee/src%2Ftest%2Frun-pass%2Ffds-are-cloexec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffds-are-cloexec.rs?ref=9539627ac76ca37d617a329dbd79c50c59cf59ee", "patch": "@@ -0,0 +1,76 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-windows\n+// ignore-android\n+\n+#![feature(libc)]\n+\n+extern crate libc;\n+\n+use std::env;\n+use std::fs::{self, File};\n+use std::io;\n+use std::net::{TcpListener, TcpStream, UdpSocket};\n+use std::os::unix::prelude::*;\n+use std::process::Command;\n+use std::thread;\n+\n+fn main() {\n+    let args = env::args().collect::<Vec<_>>();\n+    if args.len() == 1 {\n+        parent()\n+    } else {\n+        child(&args)\n+    }\n+}\n+\n+fn parent() {\n+    let file = File::open(\"Makefile\").unwrap();\n+    let _dir = fs::read_dir(\"/\").unwrap();\n+    let tcp1 = TcpListener::bind(\"127.0.0.1:0\").unwrap();\n+    assert_eq!(tcp1.as_raw_fd(), file.as_raw_fd() + 2);\n+    let tcp2 = tcp1.try_clone().unwrap();\n+    let addr = tcp1.local_addr().unwrap();\n+    let t = thread::scoped(|| TcpStream::connect(addr).unwrap());\n+    let tcp3 = tcp1.accept().unwrap().0;\n+    let tcp4 = t.join();\n+    let tcp5 = tcp3.try_clone().unwrap();\n+    let tcp6 = tcp4.try_clone().unwrap();\n+    let udp1 = UdpSocket::bind(\"127.0.0.1:0\").unwrap();\n+    let udp2 = udp1.try_clone().unwrap();\n+\n+    let status = Command::new(env::args().next().unwrap())\n+                        .arg(file.as_raw_fd().to_string())\n+                        .arg((file.as_raw_fd() + 1).to_string())\n+                        .arg(tcp1.as_raw_fd().to_string())\n+                        .arg(tcp2.as_raw_fd().to_string())\n+                        .arg(tcp3.as_raw_fd().to_string())\n+                        .arg(tcp4.as_raw_fd().to_string())\n+                        .arg(tcp5.as_raw_fd().to_string())\n+                        .arg(tcp6.as_raw_fd().to_string())\n+                        .arg(udp1.as_raw_fd().to_string())\n+                        .arg(udp2.as_raw_fd().to_string())\n+                        .status()\n+                        .unwrap();\n+    assert!(status.success());\n+}\n+\n+fn child(args: &[String]) {\n+    let mut b = [0u8; 2];\n+    for arg in &args[1..] {\n+        let fd: libc::c_int = arg.parse().unwrap();\n+        unsafe {\n+            assert_eq!(libc::read(fd, b.as_mut_ptr() as *mut _, 2), -1);\n+            assert_eq!(io::Error::last_os_error().raw_os_error(),\n+                       Some(libc::EBADF));\n+        }\n+    }\n+}"}]}