{"sha": "b355906919927ab3c879becd14392f023af883a1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIzNTU5MDY5MTk5MjdhYjNjODc5YmVjZDE0MzkyZjAyM2FmODgzYTE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-08-19T12:21:56Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-08-19T12:21:56Z"}, "message": "Auto merge of #51131 - qnighy:unsized-locals, r=eddyb\n\nImplement Unsized Rvalues\n\nThis PR is the first step to implement RFC1909: unsized rvalues (#48055).\n\n## Implemented\n\n- `Sized` is removed for arguments and local bindings. (under `#![feature(unsized_locals)]`)\n- Unsized locations are allowed in MIR\n- Unsized places and operands are correctly translated at codegen\n\n## Not implemented in this PR\n\n- Additional `Sized` checks:\n  - tuple struct constructor (accidentally compiles now)\n  - closure arguments at closure generation (accidentally compiles now)\n  - upvars (ICEs now)\n- Generating vtable for `fn method(self)` (ICEs now)\n- VLAs: `[e; n]` where `n` isn't const\n- Reduce unnecessary allocations\n\n## Current status\n\n- [x] Fix `__rust_probestack` (rust-lang-nursery/compiler-builtins#244)\n  - [x] Get the fix merged\n- [x] `#![feature(unsized_locals)]`\n  - [x] Give it a tracking issue number\n- [x] Lift sized checks in typeck and MIR-borrowck\n  - [ ] <del>Forbid `A(unsized-expr)`</del> will be another PR\n- [x] Minimum working codegen\n- [x] Add more examples and fill in unimplemented codegen paths\n- [ ] <del>Loosen object-safety rules (will be another PR)</del>\n- [ ] <del>Implement `Box<FnOnce>` (will be another PR)</del>\n- [ ] <del>Reduce temporaries (will be another PR)</del>", "tree": {"sha": "a66236f67a3ca25946b81f6306aa8f5368c83363", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a66236f67a3ca25946b81f6306aa8f5368c83363"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b355906919927ab3c879becd14392f023af883a1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b355906919927ab3c879becd14392f023af883a1", "html_url": "https://github.com/rust-lang/rust/commit/b355906919927ab3c879becd14392f023af883a1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b355906919927ab3c879becd14392f023af883a1/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8928de74394f320d1109da6731b12638a2167945", "url": "https://api.github.com/repos/rust-lang/rust/commits/8928de74394f320d1109da6731b12638a2167945", "html_url": "https://github.com/rust-lang/rust/commit/8928de74394f320d1109da6731b12638a2167945"}, {"sha": "c488d59addf6bc66725a2ca7314629ee0f92b4e5", "url": "https://api.github.com/repos/rust-lang/rust/commits/c488d59addf6bc66725a2ca7314629ee0f92b4e5", "html_url": "https://github.com/rust-lang/rust/commit/c488d59addf6bc66725a2ca7314629ee0f92b4e5"}], "stats": {"total": 840, "additions": 776, "deletions": 64}, "files": [{"sha": "7a5fe5b7f28cdfc153c7f961389e7c9e4438daf4", "filename": "src/doc/unstable-book/src/language-features/unsized-locals.md", "status": "added", "additions": 180, "deletions": 0, "changes": 180, "blob_url": "https://github.com/rust-lang/rust/blob/b355906919927ab3c879becd14392f023af883a1/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Funsized-locals.md", "raw_url": "https://github.com/rust-lang/rust/raw/b355906919927ab3c879becd14392f023af883a1/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Funsized-locals.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Funsized-locals.md?ref=b355906919927ab3c879becd14392f023af883a1", "patch": "@@ -0,0 +1,180 @@\n+# `unsized_locals`\n+\n+The tracking issue for this feature is: [#48055]\n+\n+[#48055]: https://github.com/rust-lang/rust/issues/48055\n+\n+------------------------\n+\n+This implements [RFC1909]. When turned on, you can have unsized arguments and locals:\n+\n+[RFC1909]: https://github.com/rust-lang/rfcs/blob/master/text/1909-coercions.md\n+\n+```rust\n+#![feature(unsized_locals)]\n+\n+use std::any::Any;\n+\n+fn main() {\n+    let x: Box<dyn Any> = Box::new(42);\n+    let x: dyn Any = *x;\n+    //  ^ unsized local variable\n+    //               ^^ unsized temporary\n+    foo(x);\n+}\n+\n+fn foo(_: dyn Any) {}\n+//     ^^^^^^ unsized argument\n+```\n+\n+The RFC still forbids the following unsized expressions:\n+\n+```rust,ignore\n+#![feature(unsized_locals)]\n+\n+use std::any::Any;\n+\n+struct MyStruct<T: ?Sized> {\n+    content: T,\n+}\n+\n+struct MyTupleStruct<T: ?Sized>(T);\n+\n+fn answer() -> Box<dyn Any> {\n+    Box::new(42)\n+}\n+\n+fn main() {\n+    // You CANNOT have unsized statics.\n+    static X: dyn Any = *answer();  // ERROR\n+    const Y: dyn Any = *answer();  // ERROR\n+\n+    // You CANNOT have struct initialized unsized.\n+    MyStruct { content: *answer() };  // ERROR\n+    MyTupleStruct(*answer());  // ERROR\n+    (42, *answer());  // ERROR\n+\n+    // You CANNOT have unsized return types.\n+    fn my_function() -> dyn Any { *answer() }  // ERROR\n+\n+    // You CAN have unsized local variables...\n+    let mut x: dyn Any = *answer();  // OK\n+    // ...but you CANNOT reassign to them.\n+    x = *answer();  // ERROR\n+\n+    // You CANNOT even initialize them separately.\n+    let y: dyn Any;  // OK\n+    y = *answer();  // ERROR\n+\n+    // Not mentioned in the RFC, but by-move captured variables are also Sized.\n+    let x: dyn Any = *answer();\n+    (move || {  // ERROR\n+        let y = x;\n+    })();\n+\n+    // You CAN create a closure with unsized arguments,\n+    // but you CANNOT call it.\n+    // This is an implementation detail and may be changed in the future.\n+    let f = |x: dyn Any| {};\n+    f(*answer());  // ERROR\n+}\n+```\n+\n+However, the current implementation allows `MyTupleStruct(..)` to be unsized. This will be fixed in the future.\n+\n+## By-value trait objects\n+\n+With this feature, you can have by-value `self` arguments without `Self: Sized` bounds.\n+\n+```rust\n+#![feature(unsized_locals)]\n+\n+trait Foo {\n+    fn foo(self) {}\n+}\n+\n+impl<T: ?Sized> Foo for T {}\n+\n+fn main() {\n+    let slice: Box<[i32]> = Box::new([1, 2, 3]);\n+    <[i32] as Foo>::foo(*slice);\n+}\n+```\n+\n+And `Foo` will also be object-safe. However, this object-safety is not yet implemented.\n+\n+```rust,ignore\n+#![feature(unsized_locals)]\n+\n+trait Foo {\n+    fn foo(self) {}\n+}\n+\n+impl<T: ?Sized> Foo for T {}\n+\n+fn main () {\n+    let slice: Box<dyn Foo> = Box::new([1, 2, 3]);\n+    // doesn't compile yet\n+    <dyn Foo as Foo>::foo(*slice);\n+}\n+```\n+\n+Unfortunately, this is not implemented yet.\n+\n+One of the objectives of this feature is to allow `Box<dyn FnOnce>`, instead of `Box<dyn FnBox>` in the future. See [#28796] for details.\n+\n+[#28796]: https://github.com/rust-lang/rust/issues/28796\n+\n+## Variable length arrays\n+\n+The RFC also describes an extension to the array literal syntax: `[e; dyn n]`. In the syntax, `n` isn't necessarily a constant expression. The array is dynamically allocated on the stack and has the type of `[T]`, instead of `[T; n]`.\n+\n+```rust,ignore\n+#![feature(unsized_locals)]\n+\n+fn mergesort<T: Ord>(a: &mut [T]) {\n+    let mut tmp = [T; dyn a.len()];\n+    // ...\n+}\n+\n+fn main() {\n+    let mut a = [3, 1, 5, 6];\n+    mergesort(&mut a);\n+    assert_eq!(a, [1, 3, 5, 6]);\n+}\n+```\n+\n+VLAs are not implemented yet. The syntax isn't final, either. We may need an alternative syntax for Rust 2015 because, in Rust 2015, expressions like `[e; dyn(1)]` would be ambiguous. One possible alternative proposed in the RFC is `[e; n]`: if `n` captures one or more local variables, then it is considered as `[e; dyn n]`.\n+\n+## Advisory on stack usage\n+\n+It's advised not to casually use the `#![feature(unsized_locals)]` feature. Typical use-cases are:\n+\n+- When you need a by-value trait objects.\n+- When you really need a fast allocation of small temporary arrays.\n+\n+Another pitfall is repetitive allocation and temporaries. Currently the compiler simply extends the stack frame every time it encounters an unsized assignment. So for example, the code\n+\n+```rust\n+#![feature(unsized_locals)]\n+\n+fn main() {\n+    let x: Box<[i32]> = Box::new([1, 2, 3, 4, 5]);\n+    let _x = {{{{{{{{{{*x}}}}}}}}}};\n+}\n+```\n+\n+and the code\n+\n+```rust\n+#![feature(unsized_locals)]\n+\n+fn main() {\n+    for _ in 0..10 {\n+        let x: Box<[i32]> = Box::new([1, 2, 3, 4, 5]);\n+        let _x = *x;\n+    }\n+}\n+```\n+\n+will unnecessarily extend the stack frame."}, {"sha": "92c66ef39eaa2bf99b6e9947969830ba80c715a9", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b355906919927ab3c879becd14392f023af883a1/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355906919927ab3c879becd14392f023af883a1/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=b355906919927ab3c879becd14392f023af883a1", "patch": "@@ -1454,6 +1454,15 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             }\n             ObligationCauseCode::VariableType(_) => {\n                 err.note(\"all local variables must have a statically known size\");\n+                if !self.tcx.features().unsized_locals {\n+                    err.help(\"unsized locals are gated as an unstable feature\");\n+                }\n+            }\n+            ObligationCauseCode::SizedArgumentType => {\n+                err.note(\"all function arguments must have a statically known size\");\n+                if !self.tcx.features().unsized_locals {\n+                    err.help(\"unsized locals are gated as an unstable feature\");\n+                }\n             }\n             ObligationCauseCode::SizedReturnType => {\n                 err.note(\"the return type of a function must have a \\"}, {"sha": "ef14d6d05c207f5ba93b1f166572892ffd9d1951", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b355906919927ab3c879becd14392f023af883a1/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355906919927ab3c879becd14392f023af883a1/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=b355906919927ab3c879becd14392f023af883a1", "patch": "@@ -185,6 +185,8 @@ pub enum ObligationCauseCode<'tcx> {\n     StructInitializerSized,\n     /// Type of each variable must be Sized\n     VariableType(ast::NodeId),\n+    /// Argument type must be Sized\n+    SizedArgumentType,\n     /// Return type must be Sized\n     SizedReturnType,\n     /// Yield type must be Sized"}, {"sha": "9292b42eb525e751a8308c6eb348a9aa4537621e", "filename": "src/librustc/traits/structural_impls.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b355906919927ab3c879becd14392f023af883a1/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355906919927ab3c879becd14392f023af883a1/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs?ref=b355906919927ab3c879becd14392f023af883a1", "patch": "@@ -203,6 +203,7 @@ impl<'a, 'tcx> Lift<'tcx> for traits::ObligationCauseCode<'a> {\n             super::StructInitializerSized => Some(super::StructInitializerSized),\n             super::VariableType(id) => Some(super::VariableType(id)),\n             super::ReturnType(id) => Some(super::ReturnType(id)),\n+            super::SizedArgumentType => Some(super::SizedArgumentType),\n             super::SizedReturnType => Some(super::SizedReturnType),\n             super::SizedYieldType => Some(super::SizedYieldType),\n             super::RepeatVec => Some(super::RepeatVec),"}, {"sha": "79343505c78a5b41705667d8ddf35c5994635df9", "filename": "src/librustc_codegen_llvm/abi.rs", "status": "modified", "additions": 36, "deletions": 12, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/b355906919927ab3c879becd14392f023af883a1/src%2Flibrustc_codegen_llvm%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355906919927ab3c879becd14392f023af883a1/src%2Flibrustc_codegen_llvm%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fabi.rs?ref=b355906919927ab3c879becd14392f023af883a1", "patch": "@@ -187,8 +187,10 @@ impl ArgTypeExt<'ll, 'tcx> for ArgType<'tcx, Ty<'tcx>> {\n             return;\n         }\n         let cx = bx.cx;\n-        if self.is_indirect() {\n-            OperandValue::Ref(val, self.layout.align).store(bx, dst)\n+        if self.is_sized_indirect() {\n+            OperandValue::Ref(val, None, self.layout.align).store(bx, dst)\n+        } else if self.is_unsized_indirect() {\n+            bug!(\"unsized ArgType must be handled through store_fn_arg\");\n         } else if let PassMode::Cast(cast) = self.mode {\n             // FIXME(eddyb): Figure out when the simpler Store is safe, clang\n             // uses it for i16 -> {i8, i8}, but not for i24 -> {i8, i8, i8}.\n@@ -246,7 +248,10 @@ impl ArgTypeExt<'ll, 'tcx> for ArgType<'tcx, Ty<'tcx>> {\n             PassMode::Pair(..) => {\n                 OperandValue::Pair(next(), next()).store(bx, dst);\n             }\n-            PassMode::Direct(_) | PassMode::Indirect(_) | PassMode::Cast(_) => {\n+            PassMode::Indirect(_, Some(_)) => {\n+                OperandValue::Ref(next(), Some(next()), self.layout.align).store(bx, dst);\n+            }\n+            PassMode::Direct(_) | PassMode::Indirect(_, None) | PassMode::Cast(_) => {\n                 self.store(bx, next(), dst);\n             }\n         }\n@@ -302,6 +307,10 @@ impl<'tcx> FnTypeExt<'tcx> for FnType<'tcx, Ty<'tcx>> {\n             // Don't pass the vtable, it's not an argument of the virtual fn.\n             // Instead, pass just the (thin pointer) first field of `*dyn Trait`.\n             if arg_idx == Some(0) {\n+                if layout.is_unsized() {\n+                    unimplemented!(\"by-value trait object is not \\\n+                                    yet implemented in #![feature(unsized_locals)]\");\n+                }\n                 // FIXME(eddyb) `layout.field(cx, 0)` is not enough because e.g.\n                 // `Box<dyn Trait>` has a few newtype wrappers around the raw\n                 // pointer, so we'd have to \"dig down\" to find `*dyn Trait`.\n@@ -538,7 +547,7 @@ impl<'tcx> FnTypeExt<'tcx> for FnType<'tcx, Ty<'tcx>> {\n                 }\n \n                 let size = arg.layout.size;\n-                if size > layout::Pointer.size(cx) {\n+                if arg.layout.is_unsized() || size > layout::Pointer.size(cx) {\n                     arg.make_indirect();\n                 } else {\n                     // We want to pass small aggregates as immediates, but using\n@@ -554,7 +563,7 @@ impl<'tcx> FnTypeExt<'tcx> for FnType<'tcx, Ty<'tcx>> {\n             for arg in &mut self.args {\n                 fixup(arg);\n             }\n-            if let PassMode::Indirect(ref mut attrs) = self.ret.mode {\n+            if let PassMode::Indirect(ref mut attrs, _) = self.ret.mode {\n                 attrs.set(ArgAttribute::StructRet);\n             }\n             return;\n@@ -571,7 +580,7 @@ impl<'tcx> FnTypeExt<'tcx> for FnType<'tcx, Ty<'tcx>> {\n             if let PassMode::Pair(_, _) = arg.mode { 2 } else { 1 }\n         ).sum();\n         let mut llargument_tys = Vec::with_capacity(\n-            if let PassMode::Indirect(_) = self.ret.mode { 1 } else { 0 } + args_capacity\n+            if let PassMode::Indirect(..) = self.ret.mode { 1 } else { 0 } + args_capacity\n         );\n \n         let llreturn_ty = match self.ret.mode {\n@@ -580,7 +589,7 @@ impl<'tcx> FnTypeExt<'tcx> for FnType<'tcx, Ty<'tcx>> {\n                 self.ret.layout.immediate_llvm_type(cx)\n             }\n             PassMode::Cast(cast) => cast.llvm_type(cx),\n-            PassMode::Indirect(_) => {\n+            PassMode::Indirect(..) => {\n                 llargument_tys.push(self.ret.memory_ty(cx).ptr_to());\n                 Type::void(cx)\n             }\n@@ -600,8 +609,15 @@ impl<'tcx> FnTypeExt<'tcx> for FnType<'tcx, Ty<'tcx>> {\n                     llargument_tys.push(arg.layout.scalar_pair_element_llvm_type(cx, 1, true));\n                     continue;\n                 }\n+                PassMode::Indirect(_, Some(_)) => {\n+                    let ptr_ty = cx.tcx.mk_mut_ptr(arg.layout.ty);\n+                    let ptr_layout = cx.layout_of(ptr_ty);\n+                    llargument_tys.push(ptr_layout.scalar_pair_element_llvm_type(cx, 0, true));\n+                    llargument_tys.push(ptr_layout.scalar_pair_element_llvm_type(cx, 1, true));\n+                    continue;\n+                }\n                 PassMode::Cast(cast) => cast.llvm_type(cx),\n-                PassMode::Indirect(_) => arg.memory_ty(cx).ptr_to(),\n+                PassMode::Indirect(_, None) => arg.memory_ty(cx).ptr_to(),\n             };\n             llargument_tys.push(llarg_ty);\n         }\n@@ -640,7 +656,7 @@ impl<'tcx> FnTypeExt<'tcx> for FnType<'tcx, Ty<'tcx>> {\n             PassMode::Direct(ref attrs) => {\n                 attrs.apply_llfn(llvm::AttributePlace::ReturnValue, llfn);\n             }\n-            PassMode::Indirect(ref attrs) => apply(attrs),\n+            PassMode::Indirect(ref attrs, _) => apply(attrs),\n             _ => {}\n         }\n         for arg in &self.args {\n@@ -650,7 +666,11 @@ impl<'tcx> FnTypeExt<'tcx> for FnType<'tcx, Ty<'tcx>> {\n             match arg.mode {\n                 PassMode::Ignore => {}\n                 PassMode::Direct(ref attrs) |\n-                PassMode::Indirect(ref attrs) => apply(attrs),\n+                PassMode::Indirect(ref attrs, None) => apply(attrs),\n+                PassMode::Indirect(ref attrs, Some(ref extra_attrs)) => {\n+                    apply(attrs);\n+                    apply(extra_attrs);\n+                }\n                 PassMode::Pair(ref a, ref b) => {\n                     apply(a);\n                     apply(b);\n@@ -670,7 +690,7 @@ impl<'tcx> FnTypeExt<'tcx> for FnType<'tcx, Ty<'tcx>> {\n             PassMode::Direct(ref attrs) => {\n                 attrs.apply_callsite(llvm::AttributePlace::ReturnValue, callsite);\n             }\n-            PassMode::Indirect(ref attrs) => apply(attrs),\n+            PassMode::Indirect(ref attrs, _) => apply(attrs),\n             _ => {}\n         }\n         if let layout::Abi::Scalar(ref scalar) = self.ret.layout.abi {\n@@ -694,7 +714,11 @@ impl<'tcx> FnTypeExt<'tcx> for FnType<'tcx, Ty<'tcx>> {\n             match arg.mode {\n                 PassMode::Ignore => {}\n                 PassMode::Direct(ref attrs) |\n-                PassMode::Indirect(ref attrs) => apply(attrs),\n+                PassMode::Indirect(ref attrs, None) => apply(attrs),\n+                PassMode::Indirect(ref attrs, Some(ref extra_attrs)) => {\n+                    apply(attrs);\n+                    apply(extra_attrs);\n+                }\n                 PassMode::Pair(ref a, ref b) => {\n                     apply(a);\n                     apply(b);"}, {"sha": "cfbc2ab90072ddee7c4a217a7951517741c43b0e", "filename": "src/librustc_codegen_llvm/builder.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/b355906919927ab3c879becd14392f023af883a1/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355906919927ab3c879becd14392f023af883a1/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbuilder.rs?ref=b355906919927ab3c879becd14392f023af883a1", "patch": "@@ -445,6 +445,25 @@ impl Builder<'a, 'll, 'tcx> {\n         }\n     }\n \n+    pub fn array_alloca(&self,\n+                        ty: &'ll Type,\n+                        len: &'ll Value,\n+                        name: &str,\n+                        align: Align) -> &'ll Value {\n+        self.count_insn(\"alloca\");\n+        unsafe {\n+            let alloca = if name.is_empty() {\n+                llvm::LLVMBuildArrayAlloca(self.llbuilder, ty, len, noname())\n+            } else {\n+                let name = SmallCStr::new(name);\n+                llvm::LLVMBuildArrayAlloca(self.llbuilder, ty, len,\n+                                           name.as_ptr())\n+            };\n+            llvm::LLVMSetAlignment(alloca, align.abi() as c_uint);\n+            alloca\n+        }\n+    }\n+\n     pub fn load(&self, ptr: &'ll Value, align: Align) -> &'ll Value {\n         self.count_insn(\"load\");\n         unsafe {"}, {"sha": "be3e0d9d4b1ed3a6a92d33f7eb7aae27b656397f", "filename": "src/librustc_codegen_llvm/intrinsic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b355906919927ab3c879becd14392f023af883a1/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355906919927ab3c879becd14392f023af883a1/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs?ref=b355906919927ab3c879becd14392f023af883a1", "patch": "@@ -605,7 +605,7 @@ pub fn codegen_intrinsic_call(\n                         // etc.\n                         assert!(!bx.cx.type_needs_drop(arg.layout.ty));\n                         let (ptr, align) = match arg.val {\n-                            OperandValue::Ref(ptr, align) => (ptr, align),\n+                            OperandValue::Ref(ptr, None, align) => (ptr, align),\n                             _ => bug!()\n                         };\n                         let arg = PlaceRef::new_sized(ptr, arg.layout, align);"}, {"sha": "d3039a05b6db84d070e8eed5f7ce4ba2a6c608f8", "filename": "src/librustc_codegen_llvm/llvm/ffi.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b355906919927ab3c879becd14392f023af883a1/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355906919927ab3c879becd14392f023af883a1/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs?ref=b355906919927ab3c879becd14392f023af883a1", "patch": "@@ -875,6 +875,11 @@ extern \"C\" {\n \n     // Memory\n     pub fn LLVMBuildAlloca(B: &Builder<'a>, Ty: &'a Type, Name: *const c_char) -> &'a Value;\n+    pub fn LLVMBuildArrayAlloca(B: &Builder<'a>,\n+                                Ty: &'a Type,\n+                                Val: &'a Value,\n+                                Name: *const c_char)\n+                                -> &'a Value;\n     pub fn LLVMBuildLoad(B: &Builder<'a>, PointerVal: &'a Value, Name: *const c_char) -> &'a Value;\n \n     pub fn LLVMBuildStore(B: &Builder<'a>, Val: &'a Value, Ptr: &'a Value) -> &'a Value;"}, {"sha": "5f718ae456c4138ff8217f402e147288b9156c55", "filename": "src/librustc_codegen_llvm/mir/block.rs", "status": "modified", "additions": 24, "deletions": 10, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/b355906919927ab3c879becd14392f023af883a1/src%2Flibrustc_codegen_llvm%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355906919927ab3c879becd14392f023af883a1/src%2Flibrustc_codegen_llvm%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fblock.rs?ref=b355906919927ab3c879becd14392f023af883a1", "patch": "@@ -225,14 +225,14 @@ impl FunctionCx<'a, 'll, 'tcx> {\n \n             mir::TerminatorKind::Return => {\n                 let llval = match self.fn_ty.ret.mode {\n-                    PassMode::Ignore | PassMode::Indirect(_) => {\n+                    PassMode::Ignore | PassMode::Indirect(..) => {\n                         bx.ret_void();\n                         return;\n                     }\n \n                     PassMode::Direct(_) | PassMode::Pair(..) => {\n                         let op = self.codegen_consume(&bx, &mir::Place::Local(mir::RETURN_PLACE));\n-                        if let Ref(llval, align) = op.val {\n+                        if let Ref(llval, _, align) = op.val {\n                             bx.load(llval, align)\n                         } else {\n                             op.immediate_or_packed_pair(&bx)\n@@ -245,18 +245,19 @@ impl FunctionCx<'a, 'll, 'tcx> {\n                             LocalRef::Operand(None) => bug!(\"use of return before def\"),\n                             LocalRef::Place(cg_place) => {\n                                 OperandRef {\n-                                    val: Ref(cg_place.llval, cg_place.align),\n+                                    val: Ref(cg_place.llval, None, cg_place.align),\n                                     layout: cg_place.layout\n                                 }\n                             }\n+                            LocalRef::UnsizedPlace(_) => bug!(\"return type must be sized\"),\n                         };\n                         let llslot = match op.val {\n                             Immediate(_) | Pair(..) => {\n                                 let scratch = PlaceRef::alloca(&bx, self.fn_ty.ret.layout, \"ret\");\n                                 op.val.store(&bx, scratch);\n                                 scratch.llval\n                             }\n-                            Ref(llval, align) => {\n+                            Ref(llval, _, align) => {\n                                 assert_eq!(align.abi(), op.layout.align.abi(),\n                                            \"return place is unaligned!\");\n                                 llval\n@@ -601,11 +602,11 @@ impl FunctionCx<'a, 'll, 'tcx> {\n                     // The callee needs to own the argument memory if we pass it\n                     // by-ref, so make a local copy of non-immediate constants.\n                     match (arg, op.val) {\n-                        (&mir::Operand::Copy(_), Ref(..)) |\n-                        (&mir::Operand::Constant(_), Ref(..)) => {\n+                        (&mir::Operand::Copy(_), Ref(_, None, _)) |\n+                        (&mir::Operand::Constant(_), Ref(_, None, _)) => {\n                             let tmp = PlaceRef::alloca(&bx, op.layout, \"const\");\n                             op.val.store(&bx, tmp);\n-                            op.val = Ref(tmp.llval, tmp.align);\n+                            op.val = Ref(tmp.llval, None, tmp.align);\n                         }\n                         _ => {}\n                     }\n@@ -657,13 +658,22 @@ impl FunctionCx<'a, 'll, 'tcx> {\n                 }\n                 _ => bug!(\"codegen_argument: {:?} invalid for pair arugment\", op)\n             }\n+        } else if arg.is_unsized_indirect() {\n+            match op.val {\n+                Ref(a, Some(b), _) => {\n+                    llargs.push(a);\n+                    llargs.push(b);\n+                    return;\n+                }\n+                _ => bug!(\"codegen_argument: {:?} invalid for unsized indirect argument\", op)\n+            }\n         }\n \n         // Force by-ref if we have to load through a cast pointer.\n         let (mut llval, align, by_ref) = match op.val {\n             Immediate(_) | Pair(..) => {\n                 match arg.mode {\n-                    PassMode::Indirect(_) | PassMode::Cast(_) => {\n+                    PassMode::Indirect(..) | PassMode::Cast(_) => {\n                         let scratch = PlaceRef::alloca(bx, arg.layout, \"arg\");\n                         op.val.store(bx, scratch);\n                         (scratch.llval, scratch.align, true)\n@@ -673,7 +683,7 @@ impl FunctionCx<'a, 'll, 'tcx> {\n                     }\n                 }\n             }\n-            Ref(llval, align) => {\n+            Ref(llval, _, align) => {\n                 if arg.is_indirect() && align.abi() < arg.layout.align.abi() {\n                     // `foo(packed.large_field)`. We can't pass the (unaligned) field directly. I\n                     // think that ATM (Rust 1.16) we only pass temporaries, but we shouldn't\n@@ -721,12 +731,14 @@ impl FunctionCx<'a, 'll, 'tcx> {\n         let tuple = self.codegen_operand(bx, operand);\n \n         // Handle both by-ref and immediate tuples.\n-        if let Ref(llval, align) = tuple.val {\n+        if let Ref(llval, None, align) = tuple.val {\n             let tuple_ptr = PlaceRef::new_sized(llval, tuple.layout, align);\n             for i in 0..tuple.layout.fields.count() {\n                 let field_ptr = tuple_ptr.project_field(bx, i);\n                 self.codegen_argument(bx, field_ptr.load(bx), llargs, &args[i]);\n             }\n+        } else if let Ref(_, Some(_), _) = tuple.val {\n+            bug!(\"closure arguments must be sized\")\n         } else {\n             // If the tuple is immediate, the elements are as well.\n             for i in 0..tuple.layout.fields.count() {\n@@ -820,6 +832,7 @@ impl FunctionCx<'a, 'll, 'tcx> {\n         let dest = if let mir::Place::Local(index) = *dest {\n             match self.locals[index] {\n                 LocalRef::Place(dest) => dest,\n+                LocalRef::UnsizedPlace(_) => bug!(\"return type must be sized\"),\n                 LocalRef::Operand(None) => {\n                     // Handle temporary places, specifically Operand ones, as\n                     // they don't have allocas\n@@ -871,6 +884,7 @@ impl FunctionCx<'a, 'll, 'tcx> {\n         if let mir::Place::Local(index) = *dst {\n             match self.locals[index] {\n                 LocalRef::Place(place) => self.codegen_transmute_into(bx, src, place),\n+                LocalRef::UnsizedPlace(_) => bug!(\"transmute must not involve unsized locals\"),\n                 LocalRef::Operand(None) => {\n                     let dst_layout = bx.cx.layout_of(self.monomorphized_place_ty(dst));\n                     assert!(!dst_layout.ty.has_erasable_regions());"}, {"sha": "5991bb80c30e64b9d0435fea4e6449b6ec766e69", "filename": "src/librustc_codegen_llvm/mir/mod.rs", "status": "modified", "additions": 47, "deletions": 13, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/b355906919927ab3c879becd14392f023af883a1/src%2Flibrustc_codegen_llvm%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355906919927ab3c879becd14392f023af883a1/src%2Flibrustc_codegen_llvm%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fmod.rs?ref=b355906919927ab3c879becd14392f023af883a1", "patch": "@@ -180,6 +180,11 @@ impl FunctionCx<'a, 'll, 'tcx> {\n \n enum LocalRef<'ll, 'tcx> {\n     Place(PlaceRef<'ll, 'tcx>),\n+    /// `UnsizedPlace(p)`: `p` itself is a thin pointer (indirect place).\n+    /// `*p` is the fat pointer that references the actual unsized place.\n+    /// Every time it is initialized, we have to reallocate the place\n+    /// and update the fat pointer. That's the reason why it is indirect.\n+    UnsizedPlace(PlaceRef<'ll, 'tcx>),\n     Operand(Option<OperandRef<'ll, 'tcx>>),\n }\n \n@@ -275,17 +280,24 @@ pub fn codegen_mir(\n                 }\n \n                 debug!(\"alloc: {:?} ({}) -> place\", local, name);\n-                let place = PlaceRef::alloca(&bx, layout, &name.as_str());\n-                if dbg {\n-                    let (scope, span) = fx.debug_loc(mir::SourceInfo {\n-                        span: decl.source_info.span,\n-                        scope: decl.visibility_scope,\n-                    });\n-                    declare_local(&bx, &fx.debug_context, name, layout.ty, scope.unwrap(),\n-                        VariableAccess::DirectVariable { alloca: place.llval },\n-                        VariableKind::LocalVariable, span);\n+                if layout.is_unsized() {\n+                    let indirect_place =\n+                        PlaceRef::alloca_unsized_indirect(&bx, layout, &name.as_str());\n+                    // FIXME: add an appropriate debuginfo\n+                    LocalRef::UnsizedPlace(indirect_place)\n+                } else {\n+                    let place = PlaceRef::alloca(&bx, layout, &name.as_str());\n+                    if dbg {\n+                        let (scope, span) = fx.debug_loc(mir::SourceInfo {\n+                            span: decl.source_info.span,\n+                            scope: decl.visibility_scope,\n+                        });\n+                        declare_local(&bx, &fx.debug_context, name, layout.ty, scope.unwrap(),\n+                            VariableAccess::DirectVariable { alloca: place.llval },\n+                            VariableKind::LocalVariable, span);\n+                    }\n+                    LocalRef::Place(place)\n                 }\n-                LocalRef::Place(place)\n             } else {\n                 // Temporary or return place\n                 if local == mir::RETURN_PLACE && fx.fn_ty.ret.is_indirect() {\n@@ -294,7 +306,13 @@ pub fn codegen_mir(\n                     LocalRef::Place(PlaceRef::new_sized(llretptr, layout, layout.align))\n                 } else if memory_locals.contains(local) {\n                     debug!(\"alloc: {:?} -> place\", local);\n-                    LocalRef::Place(PlaceRef::alloca(&bx, layout, &format!(\"{:?}\", local)))\n+                    if layout.is_unsized() {\n+                        let indirect_place =\n+                            PlaceRef::alloca_unsized_indirect(&bx, layout, &format!(\"{:?}\", local));\n+                        LocalRef::UnsizedPlace(indirect_place)\n+                    } else {\n+                        LocalRef::Place(PlaceRef::alloca(&bx, layout, &format!(\"{:?}\", local)))\n+                    }\n                 } else {\n                     // If this is an immediate local, we do not create an\n                     // alloca in advance. Instead we wait until we see the\n@@ -523,14 +541,26 @@ fn arg_local_refs(\n             }\n         }\n \n-        let place = if arg.is_indirect() {\n+        let place = if arg.is_sized_indirect() {\n             // Don't copy an indirect argument to an alloca, the caller\n             // already put it in a temporary alloca and gave it up.\n             // FIXME: lifetimes\n             let llarg = llvm::get_param(bx.llfn(), llarg_idx as c_uint);\n             bx.set_value_name(llarg, &name);\n             llarg_idx += 1;\n             PlaceRef::new_sized(llarg, arg.layout, arg.layout.align)\n+        } else if arg.is_unsized_indirect() {\n+            // As the storage for the indirect argument lives during\n+            // the whole function call, we just copy the fat pointer.\n+            let llarg = llvm::get_param(bx.llfn(), llarg_idx as c_uint);\n+            llarg_idx += 1;\n+            let llextra = llvm::get_param(bx.llfn(), llarg_idx as c_uint);\n+            llarg_idx += 1;\n+            let indirect_operand = OperandValue::Pair(llarg, llextra);\n+\n+            let tmp = PlaceRef::alloca_unsized_indirect(bx, arg.layout, &name);\n+            indirect_operand.store(&bx, tmp);\n+            tmp\n         } else {\n             let tmp = PlaceRef::alloca(bx, arg.layout, &name);\n             arg.store_fn_arg(bx, &mut llarg_idx, tmp);\n@@ -632,7 +662,11 @@ fn arg_local_refs(\n                 );\n             }\n         });\n-        LocalRef::Place(place)\n+        if arg.is_unsized_indirect() {\n+            LocalRef::UnsizedPlace(place)\n+        } else {\n+            LocalRef::Place(place)\n+        }\n     }).collect()\n }\n "}, {"sha": "9537379813d522eaf08cc18f9b535c8557d8a0f3", "filename": "src/librustc_codegen_llvm/mir/operand.rs", "status": "modified", "additions": 39, "deletions": 3, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/b355906919927ab3c879becd14392f023af883a1/src%2Flibrustc_codegen_llvm%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355906919927ab3c879becd14392f023af883a1/src%2Flibrustc_codegen_llvm%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Foperand.rs?ref=b355906919927ab3c879becd14392f023af883a1", "patch": "@@ -21,6 +21,8 @@ use common::{CodegenCx, C_undef, C_usize};\n use builder::{Builder, MemFlags};\n use value::Value;\n use type_of::LayoutLlvmExt;\n+use type_::Type;\n+use glue;\n \n use std::fmt;\n \n@@ -35,7 +37,9 @@ use super::place::PlaceRef;\n pub enum OperandValue<'ll> {\n     /// A reference to the actual operand. The data is guaranteed\n     /// to be valid for the operand's lifetime.\n-    Ref(&'ll Value, Align),\n+    /// The second value, if any, is the extra data (vtable or length)\n+    /// which indicates that it refers to an unsized rvalue.\n+    Ref(&'ll Value, Option<&'ll Value>, Align),\n     /// A single LLVM value.\n     Immediate(&'ll Value),\n     /// A pair of immediate LLVM values. Used by fat pointers too.\n@@ -283,10 +287,13 @@ impl OperandValue<'ll> {\n             return;\n         }\n         match self {\n-            OperandValue::Ref(r, source_align) => {\n+            OperandValue::Ref(r, None, source_align) => {\n                 base::memcpy_ty(bx, dest.llval, r, dest.layout,\n                                 source_align.min(dest.align), flags)\n             }\n+            OperandValue::Ref(_, Some(_), _) => {\n+                bug!(\"cannot directly store unsized values\");\n+            }\n             OperandValue::Immediate(s) => {\n                 let val = base::from_immediate(bx, s);\n                 bx.store_with_flags(val, dest.llval, dest.align, flags);\n@@ -300,6 +307,35 @@ impl OperandValue<'ll> {\n             }\n         }\n     }\n+\n+    pub fn store_unsized(self, bx: &Builder<'a, 'll, 'tcx>, indirect_dest: PlaceRef<'ll, 'tcx>) {\n+        debug!(\"OperandRef::store_unsized: operand={:?}, indirect_dest={:?}\", self, indirect_dest);\n+        let flags = MemFlags::empty();\n+\n+        // `indirect_dest` must have `*mut T` type. We extract `T` out of it.\n+        let unsized_ty = indirect_dest.layout.ty.builtin_deref(true)\n+            .unwrap_or_else(|| bug!(\"indirect_dest has non-pointer type: {:?}\", indirect_dest)).ty;\n+\n+        let (llptr, llextra) =\n+            if let OperandValue::Ref(llptr, Some(llextra), _) = self {\n+                (llptr, llextra)\n+            } else {\n+                bug!(\"store_unsized called with a sized value\")\n+            };\n+\n+        // FIXME: choose an appropriate alignment, or use dynamic align somehow\n+        let max_align = Align::from_bits(128, 128).unwrap();\n+        let min_align = Align::from_bits(8, 8).unwrap();\n+\n+        // Allocate an appropriate region on the stack, and copy the value into it\n+        let (llsize, _) = glue::size_and_align_of_dst(&bx, unsized_ty, Some(llextra));\n+        let lldst = bx.array_alloca(Type::i8(bx.cx), llsize, \"unsized_tmp\", max_align);\n+        base::call_memcpy(&bx, lldst, llptr, llsize, min_align, flags);\n+\n+        // Store the allocated region and the extra to the indirect place.\n+        let indirect_operand = OperandValue::Pair(lldst, llextra);\n+        indirect_operand.store(&bx, indirect_dest);\n+    }\n }\n \n impl FunctionCx<'a, 'll, 'tcx> {\n@@ -320,7 +356,7 @@ impl FunctionCx<'a, 'll, 'tcx> {\n                 LocalRef::Operand(None) => {\n                     bug!(\"use of {:?} before def\", place);\n                 }\n-                LocalRef::Place(..) => {\n+                LocalRef::Place(..) | LocalRef::UnsizedPlace(..) => {\n                     // use path below\n                 }\n             }"}, {"sha": "89d41dcc8e9946029ab19d81c80cacf7aa584832", "filename": "src/librustc_codegen_llvm/mir/place.rs", "status": "modified", "additions": 20, "deletions": 3, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/b355906919927ab3c879becd14392f023af883a1/src%2Flibrustc_codegen_llvm%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355906919927ab3c879becd14392f023af883a1/src%2Flibrustc_codegen_llvm%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fplace.rs?ref=b355906919927ab3c879becd14392f023af883a1", "patch": "@@ -48,6 +48,7 @@ impl PlaceRef<'ll, 'tcx> {\n         layout: TyLayout<'tcx>,\n         align: Align,\n     ) -> PlaceRef<'ll, 'tcx> {\n+        assert!(!layout.is_unsized());\n         PlaceRef {\n             llval,\n             llextra: None,\n@@ -77,10 +78,21 @@ impl PlaceRef<'ll, 'tcx> {\n     pub fn alloca(bx: &Builder<'a, 'll, 'tcx>, layout: TyLayout<'tcx>, name: &str)\n                   -> PlaceRef<'ll, 'tcx> {\n         debug!(\"alloca({:?}: {:?})\", name, layout);\n+        assert!(!layout.is_unsized(), \"tried to statically allocate unsized place\");\n         let tmp = bx.alloca(layout.llvm_type(bx.cx), name, layout.align);\n         Self::new_sized(tmp, layout, layout.align)\n     }\n \n+    /// Returns a place for an indirect reference to an unsized place.\n+    pub fn alloca_unsized_indirect(bx: &Builder<'a, 'll, 'tcx>, layout: TyLayout<'tcx>, name: &str)\n+                  -> PlaceRef<'ll, 'tcx> {\n+        debug!(\"alloca_unsized_indirect({:?}: {:?})\", name, layout);\n+        assert!(layout.is_unsized(), \"tried to allocate indirect place for sized values\");\n+        let ptr_ty = bx.cx.tcx.mk_mut_ptr(layout.ty);\n+        let ptr_layout = bx.cx.layout_of(ptr_ty);\n+        Self::alloca(bx, ptr_layout, name)\n+    }\n+\n     pub fn len(&self, cx: &CodegenCx<'ll, 'tcx>) -> &'ll Value {\n         if let layout::FieldPlacement::Array { count, .. } = self.layout.fields {\n             if self.layout.is_unsized() {\n@@ -97,7 +109,7 @@ impl PlaceRef<'ll, 'tcx> {\n     pub fn load(&self, bx: &Builder<'a, 'll, 'tcx>) -> OperandRef<'ll, 'tcx> {\n         debug!(\"PlaceRef::load: {:?}\", self);\n \n-        assert_eq!(self.llextra, None);\n+        assert_eq!(self.llextra.is_some(), self.layout.is_unsized());\n \n         if self.layout.is_zst() {\n             return OperandRef::new_zst(bx.cx, self.layout);\n@@ -119,7 +131,9 @@ impl PlaceRef<'ll, 'tcx> {\n             }\n         };\n \n-        let val = if self.layout.is_llvm_immediate() {\n+        let val = if let Some(llextra) = self.llextra {\n+            OperandValue::Ref(self.llval, Some(llextra), self.align)\n+        } else if self.layout.is_llvm_immediate() {\n             let mut const_llval = None;\n             unsafe {\n                 if let Some(global) = llvm::LLVMIsAGlobalVariable(self.llval) {\n@@ -149,7 +163,7 @@ impl PlaceRef<'ll, 'tcx> {\n             };\n             OperandValue::Pair(load(0, a), load(1, b))\n         } else {\n-            OperandValue::Ref(self.llval, self.align)\n+            OperandValue::Ref(self.llval, None, self.align)\n         };\n \n         OperandRef { val, layout: self.layout }\n@@ -424,6 +438,9 @@ impl FunctionCx<'a, 'll, 'tcx> {\n                 LocalRef::Place(place) => {\n                     return place;\n                 }\n+                LocalRef::UnsizedPlace(place) => {\n+                    return place.load(bx).deref(&cx);\n+                }\n                 LocalRef::Operand(..) => {\n                     bug!(\"using operand local {:?} as place\", place);\n                 }"}, {"sha": "84427d8b40f79f70aff82a69eb5777f437dc6374", "filename": "src/librustc_codegen_llvm/mir/rvalue.rs", "status": "modified", "additions": 24, "deletions": 1, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/b355906919927ab3c879becd14392f023af883a1/src%2Flibrustc_codegen_llvm%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355906919927ab3c879becd14392f023af883a1/src%2Flibrustc_codegen_llvm%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Frvalue.rs?ref=b355906919927ab3c879becd14392f023af883a1", "patch": "@@ -83,10 +83,13 @@ impl FunctionCx<'a, 'll, 'tcx> {\n                         base::coerce_unsized_into(&bx, scratch, dest);\n                         scratch.storage_dead(&bx);\n                     }\n-                    OperandValue::Ref(llref, align) => {\n+                    OperandValue::Ref(llref, None, align) => {\n                         let source = PlaceRef::new_sized(llref, operand.layout, align);\n                         base::coerce_unsized_into(&bx, source, dest);\n                     }\n+                    OperandValue::Ref(_, Some(_), _) => {\n+                        bug!(\"unsized coercion on an unsized rvalue\")\n+                    }\n                 }\n                 bx\n             }\n@@ -175,6 +178,26 @@ impl FunctionCx<'a, 'll, 'tcx> {\n         }\n     }\n \n+    pub fn codegen_rvalue_unsized(&mut self,\n+                        bx: Builder<'a, 'll, 'tcx>,\n+                        indirect_dest: PlaceRef<'ll, 'tcx>,\n+                        rvalue: &mir::Rvalue<'tcx>)\n+                        -> Builder<'a, 'll, 'tcx>\n+    {\n+        debug!(\"codegen_rvalue_unsized(indirect_dest.llval={:?}, rvalue={:?})\",\n+               indirect_dest.llval, rvalue);\n+\n+        match *rvalue {\n+            mir::Rvalue::Use(ref operand) => {\n+                let cg_operand = self.codegen_operand(&bx, operand);\n+                cg_operand.val.store_unsized(&bx, indirect_dest);\n+                bx\n+            }\n+\n+            _ => bug!(\"unsized assignment other than Rvalue::Use\"),\n+        }\n+    }\n+\n     pub fn codegen_rvalue_operand(&mut self,\n                                 bx: Builder<'a, 'll, 'tcx>,\n                                 rvalue: &mir::Rvalue<'tcx>)"}, {"sha": "dd62a12553caa24f9009d305abc61364a1c6d641", "filename": "src/librustc_codegen_llvm/mir/statement.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b355906919927ab3c879becd14392f023af883a1/src%2Flibrustc_codegen_llvm%2Fmir%2Fstatement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355906919927ab3c879becd14392f023af883a1/src%2Flibrustc_codegen_llvm%2Fmir%2Fstatement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fstatement.rs?ref=b355906919927ab3c879becd14392f023af883a1", "patch": "@@ -31,6 +31,9 @@ impl FunctionCx<'a, 'll, 'tcx> {\n                         LocalRef::Place(cg_dest) => {\n                             self.codegen_rvalue(bx, cg_dest, rvalue)\n                         }\n+                        LocalRef::UnsizedPlace(cg_indirect_dest) => {\n+                            self.codegen_rvalue_unsized(bx, cg_indirect_dest, rvalue)\n+                        }\n                         LocalRef::Operand(None) => {\n                             let (bx, operand) = self.codegen_rvalue_operand(bx, rvalue);\n                             self.locals[index] = LocalRef::Operand(Some(operand));\n@@ -61,12 +64,16 @@ impl FunctionCx<'a, 'll, 'tcx> {\n             mir::StatementKind::StorageLive(local) => {\n                 if let LocalRef::Place(cg_place) = self.locals[local] {\n                     cg_place.storage_live(&bx);\n+                } else if let LocalRef::UnsizedPlace(cg_indirect_place) = self.locals[local] {\n+                    cg_indirect_place.storage_live(&bx);\n                 }\n                 bx\n             }\n             mir::StatementKind::StorageDead(local) => {\n                 if let LocalRef::Place(cg_place) = self.locals[local] {\n                     cg_place.storage_dead(&bx);\n+                } else if let LocalRef::UnsizedPlace(cg_indirect_place) = self.locals[local] {\n+                    cg_indirect_place.storage_dead(&bx);\n                 }\n                 bx\n             }"}, {"sha": "ab83cfe25b590b92a1f9c7b42566905be70e5015", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 34, "deletions": 11, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/b355906919927ab3c879becd14392f023af883a1/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355906919927ab3c879becd14392f023af883a1/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=b355906919927ab3c879becd14392f023af883a1", "patch": "@@ -903,11 +903,13 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                     );\n                 }\n                 self.check_rvalue(mir, rv, location);\n-                let trait_ref = ty::TraitRef {\n-                    def_id: tcx.lang_items().sized_trait().unwrap(),\n-                    substs: tcx.mk_substs_trait(place_ty, &[]),\n-                };\n-                self.prove_trait_ref(trait_ref, location.interesting());\n+                if !self.tcx().features().unsized_locals {\n+                    let trait_ref = ty::TraitRef {\n+                        def_id: tcx.lang_items().sized_trait().unwrap(),\n+                        substs: tcx.mk_substs_trait(place_ty, &[]),\n+                    };\n+                    self.prove_trait_ref(trait_ref, location.interesting());\n+                }\n             }\n             StatementKind::SetDiscriminant {\n                 ref place,\n@@ -962,6 +964,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         mir: &Mir<'tcx>,\n         term: &Terminator<'tcx>,\n         term_location: Location,\n+        errors_buffer: &mut Option<&mut Vec<Diagnostic>>,\n     ) {\n         debug!(\"check_terminator: {:?}\", term);\n         let tcx = self.tcx();\n@@ -1041,7 +1044,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                     &sig,\n                 );\n                 let sig = self.normalize(sig, term_location);\n-                self.check_call_dest(mir, term, &sig, destination, term_location);\n+                self.check_call_dest(mir, term, &sig, destination, term_location, errors_buffer);\n \n                 self.prove_predicates(\n                     sig.inputs().iter().map(|ty| ty::Predicate::WellFormed(ty)),\n@@ -1115,6 +1118,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         sig: &ty::FnSig<'tcx>,\n         destination: &Option<(Place<'tcx>, BasicBlock)>,\n         term_location: Location,\n+        errors_buffer: &mut Option<&mut Vec<Diagnostic>>,\n     ) {\n         let tcx = self.tcx();\n         match *destination {\n@@ -1143,6 +1147,13 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                         terr\n                     );\n                 }\n+\n+                // When `#![feature(unsized_locals)]` is not enabled,\n+                // this check is done at `check_local`.\n+                if self.tcx().features().unsized_locals {\n+                    let span = term.source_info.span;\n+                    self.ensure_place_sized(dest_ty, span, errors_buffer);\n+                }\n             }\n             None => {\n                 // FIXME(canndrew): This is_never should probably be an is_uninhabited\n@@ -1309,14 +1320,26 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n             LocalKind::Var | LocalKind::Temp => {}\n         }\n \n-        let span = local_decl.source_info.span;\n-        let ty = local_decl.ty;\n+        // When `#![feature(unsized_locals)]` is enabled, only function calls\n+        // are checked in `check_call_dest`.\n+        if !self.tcx().features().unsized_locals {\n+            let span = local_decl.source_info.span;\n+            let ty = local_decl.ty;\n+            self.ensure_place_sized(ty, span, errors_buffer);\n+        }\n+    }\n+\n+    fn ensure_place_sized(&mut self,\n+                          ty: Ty<'tcx>,\n+                          span: Span,\n+                          errors_buffer: &mut Option<&mut Vec<Diagnostic>>) {\n+        let tcx = self.tcx();\n \n         // Erase the regions from `ty` to get a global type.  The\n         // `Sized` bound in no way depends on precise regions, so this\n         // shouldn't affect `is_sized`.\n-        let gcx = self.tcx().global_tcx();\n-        let erased_ty = gcx.lift(&self.tcx().erase_regions(&ty)).unwrap();\n+        let gcx = tcx.global_tcx();\n+        let erased_ty = gcx.lift(&tcx.erase_regions(&ty)).unwrap();\n         if !erased_ty.is_sized(gcx.at(span), self.param_env) {\n             // in current MIR construction, all non-control-flow rvalue\n             // expressions evaluate through `as_temp` or `into` a return\n@@ -1838,7 +1861,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                 location.statement_index += 1;\n             }\n \n-            self.check_terminator(mir, block_data.terminator(), location);\n+            self.check_terminator(mir, block_data.terminator(), location, &mut errors_buffer);\n             self.check_iscleanup(mir, block_data);\n         }\n     }"}, {"sha": "78ed4b2d615a4449067e7dcf466e83a16081576c", "filename": "src/librustc_target/abi/call/mod.rs", "status": "modified", "additions": 27, "deletions": 5, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/b355906919927ab3c879becd14392f023af883a1/src%2Flibrustc_target%2Fabi%2Fcall%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355906919927ab3c879becd14392f023af883a1/src%2Flibrustc_target%2Fabi%2Fcall%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Fmod.rs?ref=b355906919927ab3c879becd14392f023af883a1", "patch": "@@ -44,7 +44,9 @@ pub enum PassMode {\n     /// a single uniform or a pair of registers.\n     Cast(CastTarget),\n     /// Pass the argument indirectly via a hidden pointer.\n-    Indirect(ArgAttributes),\n+    /// The second value, if any, is for the extra data (vtable or length)\n+    /// which indicates that it refers to an unsized rvalue.\n+    Indirect(ArgAttributes, Option<ArgAttributes>),\n }\n \n // Hack to disable non_upper_case_globals only for the bitflags! and not for the rest\n@@ -368,13 +370,19 @@ impl<'a, Ty> ArgType<'a, Ty> {\n         // i686-pc-windows-msvc, it results in wrong stack offsets.\n         // attrs.pointee_align = Some(self.layout.align);\n \n-        self.mode = PassMode::Indirect(attrs);\n+        let extra_attrs = if self.layout.is_unsized() {\n+            Some(ArgAttributes::new())\n+        } else {\n+            None\n+        };\n+\n+        self.mode = PassMode::Indirect(attrs, extra_attrs);\n     }\n \n     pub fn make_indirect_byval(&mut self) {\n         self.make_indirect();\n         match self.mode {\n-            PassMode::Indirect(ref mut attrs) => {\n+            PassMode::Indirect(ref mut attrs, _) => {\n                 attrs.set(ArgAttribute::ByVal);\n             }\n             _ => unreachable!()\n@@ -409,7 +417,21 @@ impl<'a, Ty> ArgType<'a, Ty> {\n \n     pub fn is_indirect(&self) -> bool {\n         match self.mode {\n-            PassMode::Indirect(_) => true,\n+            PassMode::Indirect(..) => true,\n+            _ => false\n+        }\n+    }\n+\n+    pub fn is_sized_indirect(&self) -> bool {\n+        match self.mode {\n+            PassMode::Indirect(_, None) => true,\n+            _ => false\n+        }\n+    }\n+\n+    pub fn is_unsized_indirect(&self) -> bool {\n+        match self.mode {\n+            PassMode::Indirect(_, Some(_)) => true,\n             _ => false\n         }\n     }\n@@ -506,7 +528,7 @@ impl<'a, Ty> FnType<'a, Ty> {\n             a => return Err(format!(\"unrecognized arch \\\"{}\\\" in target specification\", a))\n         }\n \n-        if let PassMode::Indirect(ref mut attrs) = self.ret.mode {\n+        if let PassMode::Indirect(ref mut attrs, _) = self.ret.mode {\n             attrs.set(ArgAttribute::StructRet);\n         }\n "}, {"sha": "1dcaafcf77fcf77527a45c51674ec5133c8ea52b", "filename": "src/librustc_target/abi/call/x86.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b355906919927ab3c879becd14392f023af883a1/src%2Flibrustc_target%2Fabi%2Fcall%2Fx86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355906919927ab3c879becd14392f023af883a1/src%2Flibrustc_target%2Fabi%2Fcall%2Fx86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Fx86.rs?ref=b355906919927ab3c879becd14392f023af883a1", "patch": "@@ -99,9 +99,10 @@ pub fn compute_abi_info<'a, Ty, C>(cx: C, fty: &mut FnType<'a, Ty>, flavor: Flav\n         for arg in &mut fty.args {\n             let attrs = match arg.mode {\n                 PassMode::Ignore |\n-                PassMode::Indirect(_) => continue,\n+                PassMode::Indirect(_, None) => continue,\n                 PassMode::Direct(ref mut attrs) => attrs,\n                 PassMode::Pair(..) |\n+                PassMode::Indirect(_, Some(_)) |\n                 PassMode::Cast(_) => {\n                     unreachable!(\"x86 shouldn't be passing arguments by {:?}\", arg.mode)\n                 }"}, {"sha": "27b427f7f89fb168be404198aaa0e567c5fcb6c5", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b355906919927ab3c879becd14392f023af883a1/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355906919927ab3c879becd14392f023af883a1/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=b355906919927ab3c879becd14392f023af883a1", "patch": "@@ -961,8 +961,10 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for GatherLocalsVisitor<'a, 'gcx, 'tcx> {\n         if let PatKind::Binding(_, _, ident, _) = p.node {\n             let var_ty = self.assign(p.span, p.id, None);\n \n-            self.fcx.require_type_is_sized(var_ty, p.span,\n-                                           traits::VariableType(p.id));\n+            if !self.fcx.tcx.features().unsized_locals {\n+                self.fcx.require_type_is_sized(var_ty, p.span,\n+                                               traits::VariableType(p.id));\n+            }\n \n             debug!(\"Pattern binding {} is assigned to {} with type {:?}\",\n                    ident,\n@@ -1048,8 +1050,8 @@ fn check_fn<'a, 'gcx, 'tcx>(inherited: &'a Inherited<'a, 'gcx, 'tcx>,\n         // The check for a non-trivial pattern is a hack to avoid duplicate warnings\n         // for simple cases like `fn foo(x: Trait)`,\n         // where we would error once on the parameter as a whole, and once on the binding `x`.\n-        if arg.pat.simple_ident().is_none() {\n-            fcx.require_type_is_sized(arg_ty, decl.output.span(), traits::MiscObligation);\n+        if arg.pat.simple_ident().is_none() && !fcx.tcx.features().unsized_locals {\n+            fcx.require_type_is_sized(arg_ty, decl.output.span(), traits::SizedArgumentType);\n         }\n \n         fcx.write_ty(arg.hir_id, arg_ty);"}, {"sha": "e8245a553eb485b730de0caf81f9c00addbd3570", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b355906919927ab3c879becd14392f023af883a1/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355906919927ab3c879becd14392f023af883a1/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=b355906919927ab3c879becd14392f023af883a1", "patch": "@@ -503,6 +503,9 @@ declare_features! (\n \n     // Allows `Self` in type definitions\n     (active, self_in_typedefs, \"1.30.0\", Some(49303), None),\n+\n+    // unsized rvalues at arguments and parameters\n+    (active, unsized_locals, \"1.30.0\", Some(48055), None),\n );\n \n declare_features! ("}, {"sha": "a09ccbb407e9847e832fc07a107a2c6a95792d1b", "filename": "src/test/compile-fail/unsized-locals/unsized-exprs.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/b355906919927ab3c879becd14392f023af883a1/src%2Ftest%2Fcompile-fail%2Funsized-locals%2Funsized-exprs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355906919927ab3c879becd14392f023af883a1/src%2Ftest%2Fcompile-fail%2Funsized-locals%2Funsized-exprs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsized-locals%2Funsized-exprs.rs?ref=b355906919927ab3c879becd14392f023af883a1", "patch": "@@ -0,0 +1,36 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(unsized_tuple_coercion, unsized_locals)]\n+\n+struct A<X: ?Sized>(X);\n+\n+fn udrop<T: ?Sized>(_x: T) {}\n+fn foo() -> Box<[u8]> {\n+    Box::new(*b\"foo\")\n+}\n+fn tfoo() -> Box<(i32, [u8])> {\n+    Box::new((42, *b\"foo\"))\n+}\n+fn afoo() -> Box<A<[u8]>> {\n+    Box::new(A(*b\"foo\"))\n+}\n+\n+impl std::ops::Add<i32> for A<[u8]> {\n+    type Output = ();\n+    fn add(self, _rhs: i32) -> Self::Output {}\n+}\n+\n+fn main() {\n+    udrop::<(i32, [u8])>((42, *foo()));\n+    //~^ERROR E0277\n+    udrop::<A<[u8]>>(A { 0: *foo() });\n+    //~^ERROR E0277\n+}"}, {"sha": "40d6e54bd892fe3ae8d2a587444f213cf7873fe1", "filename": "src/test/compile-fail/unsized-locals/unsized-exprs2.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/b355906919927ab3c879becd14392f023af883a1/src%2Ftest%2Fcompile-fail%2Funsized-locals%2Funsized-exprs2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355906919927ab3c879becd14392f023af883a1/src%2Ftest%2Fcompile-fail%2Funsized-locals%2Funsized-exprs2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsized-locals%2Funsized-exprs2.rs?ref=b355906919927ab3c879becd14392f023af883a1", "patch": "@@ -0,0 +1,36 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(unsized_tuple_coercion, unsized_locals)]\n+\n+struct A<X: ?Sized>(X);\n+\n+fn udrop<T: ?Sized>(_x: T) {}\n+fn foo() -> Box<[u8]> {\n+    Box::new(*b\"foo\")\n+}\n+fn tfoo() -> Box<(i32, [u8])> {\n+    Box::new((42, *b\"foo\"))\n+}\n+fn afoo() -> Box<A<[u8]>> {\n+    Box::new(A(*b\"foo\"))\n+}\n+\n+impl std::ops::Add<i32> for A<[u8]> {\n+    type Output = ();\n+    fn add(self, _rhs: i32) -> Self::Output {}\n+}\n+\n+fn main() {\n+    udrop::<[u8]>(foo()[..]);\n+    //~^ERROR cannot move out of indexed content\n+    // FIXME: should be error\n+    udrop::<A<[u8]>>(A(*foo()));\n+}"}, {"sha": "e1fda427b4e73e9c5a8756972eace8a4e306e469", "filename": "src/test/run-pass-valgrind/unsized-locals/long-live-the-unsized-temporary.rs", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/b355906919927ab3c879becd14392f023af883a1/src%2Ftest%2Frun-pass-valgrind%2Funsized-locals%2Flong-live-the-unsized-temporary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355906919927ab3c879becd14392f023af883a1/src%2Ftest%2Frun-pass-valgrind%2Funsized-locals%2Flong-live-the-unsized-temporary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-valgrind%2Funsized-locals%2Flong-live-the-unsized-temporary.rs?ref=b355906919927ab3c879becd14392f023af883a1", "patch": "@@ -0,0 +1,65 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(unsized_locals)]\n+\n+use std::fmt;\n+\n+fn gen_foo() -> Box<fmt::Display> {\n+    Box::new(Box::new(\"foo\"))\n+}\n+\n+fn foo(x: fmt::Display) {\n+    assert_eq!(x.to_string(), \"foo\");\n+}\n+\n+fn foo_indirect(x: fmt::Display) {\n+    foo(x);\n+}\n+\n+fn main() {\n+    foo(*gen_foo());\n+    foo_indirect(*gen_foo());\n+\n+    {\n+        let x: fmt::Display = *gen_foo();\n+        foo(x);\n+    }\n+\n+    {\n+        let x: fmt::Display = *gen_foo();\n+        let y: fmt::Display = *gen_foo();\n+        foo(x);\n+        foo(y);\n+    }\n+\n+    {\n+        let mut cnt: usize = 3;\n+        let x = loop {\n+            let x: fmt::Display = *gen_foo();\n+            if cnt == 0 {\n+                break x;\n+            } else {\n+                cnt -= 1;\n+            }\n+        };\n+        foo(x);\n+    }\n+\n+    {\n+        let x: fmt::Display = *gen_foo();\n+        let x = if true {\n+            x\n+        } else {\n+            *gen_foo()\n+        };\n+        foo(x);\n+    }\n+}"}, {"sha": "6ed39a78648a26935fb52a91a4e4fdd09da31591", "filename": "src/test/run-pass/unsized-locals/reference-unsized-locals.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/b355906919927ab3c879becd14392f023af883a1/src%2Ftest%2Frun-pass%2Funsized-locals%2Freference-unsized-locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355906919927ab3c879becd14392f023af883a1/src%2Ftest%2Frun-pass%2Funsized-locals%2Freference-unsized-locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funsized-locals%2Freference-unsized-locals.rs?ref=b355906919927ab3c879becd14392f023af883a1", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(unsized_locals)]\n+\n+fn main() {\n+    let foo: Box<[u8]> = Box::new(*b\"foo\");\n+    let foo: [u8] = *foo;\n+    assert_eq!(&foo, b\"foo\" as &[u8]);\n+}"}, {"sha": "0b1aa6225eb50ef1e520a23bce26cd0964fa657e", "filename": "src/test/run-pass/unsized-locals/simple-unsized-locals.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b355906919927ab3c879becd14392f023af883a1/src%2Ftest%2Frun-pass%2Funsized-locals%2Fsimple-unsized-locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355906919927ab3c879becd14392f023af883a1/src%2Ftest%2Frun-pass%2Funsized-locals%2Fsimple-unsized-locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funsized-locals%2Fsimple-unsized-locals.rs?ref=b355906919927ab3c879becd14392f023af883a1", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(unsized_locals)]\n+\n+fn main() {\n+    let foo: Box<[u8]> = Box::new(*b\"foo\");\n+    let _foo: [u8] = *foo;\n+}"}, {"sha": "9a5e534db25b33a1681d2b8c5e0e16cce6122877", "filename": "src/test/run-pass/unsized-locals/unsized-exprs.rs", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/b355906919927ab3c879becd14392f023af883a1/src%2Ftest%2Frun-pass%2Funsized-locals%2Funsized-exprs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355906919927ab3c879becd14392f023af883a1/src%2Ftest%2Frun-pass%2Funsized-locals%2Funsized-exprs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funsized-locals%2Funsized-exprs.rs?ref=b355906919927ab3c879becd14392f023af883a1", "patch": "@@ -0,0 +1,45 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(unsized_tuple_coercion, unsized_locals)]\n+\n+struct A<X: ?Sized>(X);\n+\n+fn udrop<T: ?Sized>(_x: T) {}\n+fn foo() -> Box<[u8]> {\n+    Box::new(*b\"foo\")\n+}\n+fn tfoo() -> Box<(i32, [u8])> {\n+    Box::new((42, *b\"foo\"))\n+}\n+fn afoo() -> Box<A<[u8]>> {\n+    Box::new(A(*b\"foo\"))\n+}\n+\n+impl std::ops::Add<i32> for A<[u8]> {\n+    type Output = ();\n+    fn add(self, _rhs: i32) -> Self::Output {}\n+}\n+\n+fn main() {\n+    udrop::<[u8]>(loop {\n+        break *foo();\n+    });\n+    udrop::<[u8]>(if true {\n+        *foo()\n+    } else {\n+        *foo()\n+    });\n+    udrop::<[u8]>({*foo()});\n+    #[allow(unused_parens)]\n+    udrop::<[u8]>((*foo()));\n+    udrop::<[u8]>((*tfoo()).1);\n+    *afoo() + 42;\n+}"}, {"sha": "0314fe1d686621bf483a64ae773ee0b5e40bac39", "filename": "src/test/run-pass/unsized-locals/unsized-parameters.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b355906919927ab3c879becd14392f023af883a1/src%2Ftest%2Frun-pass%2Funsized-locals%2Funsized-parameters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355906919927ab3c879becd14392f023af883a1/src%2Ftest%2Frun-pass%2Funsized-locals%2Funsized-parameters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funsized-locals%2Funsized-parameters.rs?ref=b355906919927ab3c879becd14392f023af883a1", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(unsized_locals)]\n+\n+pub fn f0(_f: dyn FnOnce()) {}\n+pub fn f1(_s: str) {}\n+pub fn f2((_x, _y): (i32, [i32])) {}\n+\n+fn main() {\n+    let foo = \"foo\".to_string().into_boxed_str();\n+    f1(*foo);\n+}"}, {"sha": "09e3cb8c126a3e18deb54a98c85b2a409fde6f74", "filename": "src/test/ui/associated-types/associated-types-unsized.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b355906919927ab3c879becd14392f023af883a1/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-unsized.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b355906919927ab3c879becd14392f023af883a1/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-unsized.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-unsized.stderr?ref=b355906919927ab3c879becd14392f023af883a1", "patch": "@@ -8,6 +8,7 @@ LL |     let x = t.get(); //~ ERROR the size for values of type\n    = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n    = help: consider adding a `where <T as Get>::Value: std::marker::Sized` bound\n    = note: all local variables must have a statically known size\n+   = help: unsized locals are gated as an unstable feature\n \n error: aborting due to previous error\n "}, {"sha": "ab9020222ea2b4f7b7e149a1618b5b3f25ca4786", "filename": "src/test/ui/error-codes/E0277.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b355906919927ab3c879becd14392f023af883a1/src%2Ftest%2Fui%2Ferror-codes%2FE0277.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b355906919927ab3c879becd14392f023af883a1/src%2Ftest%2Fui%2Ferror-codes%2FE0277.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0277.stderr?ref=b355906919927ab3c879becd14392f023af883a1", "patch": "@@ -8,6 +8,7 @@ LL | fn f(p: Path) { }\n    = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n    = note: required because it appears within the type `std::path::Path`\n    = note: all local variables must have a statically known size\n+   = help: unsized locals are gated as an unstable feature\n \n error[E0277]: the trait bound `i32: Foo` is not satisfied\n   --> $DIR/E0277.rs:27:5"}, {"sha": "7f1f22fa38fb1f1254256a16b824c17c70fbbf31", "filename": "src/test/ui/feature-gate-unsized_locals.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/b355906919927ab3c879becd14392f023af883a1/src%2Ftest%2Fui%2Ffeature-gate-unsized_locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355906919927ab3c879becd14392f023af883a1/src%2Ftest%2Fui%2Ffeature-gate-unsized_locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-unsized_locals.rs?ref=b355906919927ab3c879becd14392f023af883a1", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn f(f: FnOnce()) {}\n+//~^ ERROR E0277\n+\n+fn main() {\n+}"}, {"sha": "a0440a373d2fc939e8696a1f83a0ac5bf1a74241", "filename": "src/test/ui/feature-gate-unsized_locals.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b355906919927ab3c879becd14392f023af883a1/src%2Ftest%2Fui%2Ffeature-gate-unsized_locals.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b355906919927ab3c879becd14392f023af883a1/src%2Ftest%2Fui%2Ffeature-gate-unsized_locals.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-unsized_locals.stderr?ref=b355906919927ab3c879becd14392f023af883a1", "patch": "@@ -0,0 +1,14 @@\n+error[E0277]: the size for values of type `(dyn std::ops::FnOnce() + 'static)` cannot be known at compilation time\n+  --> $DIR/feature-gate-unsized_locals.rs:11:6\n+   |\n+LL | fn f(f: FnOnce()) {}\n+   |      ^ doesn't have a size known at compile-time\n+   |\n+   = help: the trait `std::marker::Sized` is not implemented for `(dyn std::ops::FnOnce() + 'static)`\n+   = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n+   = note: all local variables must have a statically known size\n+   = help: unsized locals are gated as an unstable feature\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "877e0eaedf1435a0b5d4aba0fd657148275c8682", "filename": "src/test/ui/issues/issue-15756.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b355906919927ab3c879becd14392f023af883a1/src%2Ftest%2Fui%2Fissues%2Fissue-15756.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b355906919927ab3c879becd14392f023af883a1/src%2Ftest%2Fui%2Fissues%2Fissue-15756.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-15756.stderr?ref=b355906919927ab3c879becd14392f023af883a1", "patch": "@@ -7,6 +7,7 @@ LL |     &mut something\n    = help: the trait `std::marker::Sized` is not implemented for `[T]`\n    = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n    = note: all local variables must have a statically known size\n+   = help: unsized locals are gated as an unstable feature\n \n error: aborting due to previous error\n "}, {"sha": "269a69dde3345bdd930e902c5f5b338ebc843060", "filename": "src/test/ui/issues/issue-27078.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b355906919927ab3c879becd14392f023af883a1/src%2Ftest%2Fui%2Fissues%2Fissue-27078.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b355906919927ab3c879becd14392f023af883a1/src%2Ftest%2Fui%2Fissues%2Fissue-27078.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-27078.stderr?ref=b355906919927ab3c879becd14392f023af883a1", "patch": "@@ -8,6 +8,7 @@ LL |     fn foo(self) -> &'static i32 {\n    = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n    = help: consider adding a `where Self: std::marker::Sized` bound\n    = note: all local variables must have a statically known size\n+   = help: unsized locals are gated as an unstable feature\n \n error: aborting due to previous error\n "}, {"sha": "9bc937b97c9a1649b43cf0836a15fcfb56d33490", "filename": "src/test/ui/issues/issue-38954.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b355906919927ab3c879becd14392f023af883a1/src%2Ftest%2Fui%2Fissues%2Fissue-38954.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b355906919927ab3c879becd14392f023af883a1/src%2Ftest%2Fui%2Fissues%2Fissue-38954.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-38954.stderr?ref=b355906919927ab3c879becd14392f023af883a1", "patch": "@@ -6,6 +6,8 @@ LL | fn _test(ref _p: str) {}\n    |\n    = help: the trait `std::marker::Sized` is not implemented for `str`\n    = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n+   = note: all function arguments must have a statically known size\n+   = help: unsized locals are gated as an unstable feature\n \n error: aborting due to previous error\n "}, {"sha": "e4a34fdaf48a46375f02469571ec843d5de14619", "filename": "src/test/ui/issues/issue-41229-ref-str.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b355906919927ab3c879becd14392f023af883a1/src%2Ftest%2Fui%2Fissues%2Fissue-41229-ref-str.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b355906919927ab3c879becd14392f023af883a1/src%2Ftest%2Fui%2Fissues%2Fissue-41229-ref-str.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-41229-ref-str.stderr?ref=b355906919927ab3c879becd14392f023af883a1", "patch": "@@ -6,6 +6,8 @@ LL | pub fn example(ref s: str) {}\n    |\n    = help: the trait `std::marker::Sized` is not implemented for `str`\n    = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n+   = note: all function arguments must have a statically known size\n+   = help: unsized locals are gated as an unstable feature\n \n error: aborting due to previous error\n "}, {"sha": "912d791b6bc3a4b3a27746307a5a33e0a04c2c3a", "filename": "src/test/ui/issues/issue-42312.stderr", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b355906919927ab3c879becd14392f023af883a1/src%2Ftest%2Fui%2Fissues%2Fissue-42312.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b355906919927ab3c879becd14392f023af883a1/src%2Ftest%2Fui%2Fissues%2Fissue-42312.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-42312.stderr?ref=b355906919927ab3c879becd14392f023af883a1", "patch": "@@ -7,6 +7,8 @@ LL |     fn baz(_: Self::Target) where Self: Deref {}\n    = help: the trait `std::marker::Sized` is not implemented for `<Self as std::ops::Deref>::Target`\n    = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n    = help: consider adding a `where <Self as std::ops::Deref>::Target: std::marker::Sized` bound\n+   = note: all function arguments must have a statically known size\n+   = help: unsized locals are gated as an unstable feature\n \n error[E0277]: the size for values of type `(dyn std::string::ToString + 'static)` cannot be known at compilation time\n   --> $DIR/issue-42312.rs:18:23\n@@ -16,6 +18,8 @@ LL | pub fn f(_: ToString) {}\n    |\n    = help: the trait `std::marker::Sized` is not implemented for `(dyn std::string::ToString + 'static)`\n    = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n+   = note: all function arguments must have a statically known size\n+   = help: unsized locals are gated as an unstable feature\n \n error: aborting due to 2 previous errors\n "}, {"sha": "63dabd86ca89ed539e1beeacf1bfddb27dd23710", "filename": "src/test/ui/issues/issue-5883.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b355906919927ab3c879becd14392f023af883a1/src%2Ftest%2Fui%2Fissues%2Fissue-5883.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b355906919927ab3c879becd14392f023af883a1/src%2Ftest%2Fui%2Fissues%2Fissue-5883.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-5883.stderr?ref=b355906919927ab3c879becd14392f023af883a1", "patch": "@@ -7,6 +7,7 @@ LL | fn new_struct(r: A+'static)\n    = help: the trait `std::marker::Sized` is not implemented for `(dyn A + 'static)`\n    = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n    = note: all local variables must have a statically known size\n+   = help: unsized locals are gated as an unstable feature\n \n error[E0277]: the size for values of type `(dyn A + 'static)` cannot be known at compilation time\n   --> $DIR/issue-5883.rs:18:8"}, {"sha": "9e7fca0508ef8732278bfce408236a03b1f87394", "filename": "src/test/ui/resolve/issue-5035-2.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b355906919927ab3c879becd14392f023af883a1/src%2Ftest%2Fui%2Fresolve%2Fissue-5035-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b355906919927ab3c879becd14392f023af883a1/src%2Ftest%2Fui%2Fresolve%2Fissue-5035-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fissue-5035-2.stderr?ref=b355906919927ab3c879becd14392f023af883a1", "patch": "@@ -7,6 +7,7 @@ LL | fn foo(_x: K) {}\n    = help: the trait `std::marker::Sized` is not implemented for `(dyn I + 'static)`\n    = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n    = note: all local variables must have a statically known size\n+   = help: unsized locals are gated as an unstable feature\n \n error: aborting due to previous error\n "}, {"sha": "57eff3fb13708878f3b0082c46a98be1d8bc7c86", "filename": "src/test/ui/str/str-array-assignment.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b355906919927ab3c879becd14392f023af883a1/src%2Ftest%2Fui%2Fstr%2Fstr-array-assignment.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b355906919927ab3c879becd14392f023af883a1/src%2Ftest%2Fui%2Fstr%2Fstr-array-assignment.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstr%2Fstr-array-assignment.stderr?ref=b355906919927ab3c879becd14392f023af883a1", "patch": "@@ -30,6 +30,7 @@ LL |   let v = s[..2];\n    = help: the trait `std::marker::Sized` is not implemented for `str`\n    = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n    = note: all local variables must have a statically known size\n+   = help: unsized locals are gated as an unstable feature\n \n error[E0308]: mismatched types\n   --> $DIR/str-array-assignment.rs:19:17"}, {"sha": "ecabf9af27b381a628df2110b2aec1731a20fb7c", "filename": "src/test/ui/traits/trait-bounds-not-on-bare-trait.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b355906919927ab3c879becd14392f023af883a1/src%2Ftest%2Fui%2Ftraits%2Ftrait-bounds-not-on-bare-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b355906919927ab3c879becd14392f023af883a1/src%2Ftest%2Fui%2Ftraits%2Ftrait-bounds-not-on-bare-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-bounds-not-on-bare-trait.stderr?ref=b355906919927ab3c879becd14392f023af883a1", "patch": "@@ -7,6 +7,7 @@ LL | fn foo(_x: Foo + Send) {\n    = help: the trait `std::marker::Sized` is not implemented for `(dyn Foo + std::marker::Send + 'static)`\n    = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n    = note: all local variables must have a statically known size\n+   = help: unsized locals are gated as an unstable feature\n \n error: aborting due to previous error\n "}, {"sha": "5a09533269288ab705bd7f761f2b4c8b278667d4", "filename": "src/test/ui/unsized6.stderr", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b355906919927ab3c879becd14392f023af883a1/src%2Ftest%2Fui%2Funsized6.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b355906919927ab3c879becd14392f023af883a1/src%2Ftest%2Fui%2Funsized6.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsized6.stderr?ref=b355906919927ab3c879becd14392f023af883a1", "patch": "@@ -8,6 +8,7 @@ LL |     let y: Y;\n    = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n    = help: consider adding a `where Y: std::marker::Sized` bound\n    = note: all local variables must have a statically known size\n+   = help: unsized locals are gated as an unstable feature\n \n error[E0277]: the size for values of type `X` cannot be known at compilation time\n   --> $DIR/unsized6.rs:17:12\n@@ -41,6 +42,7 @@ LL |     let y: X;\n    = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n    = help: consider adding a `where X: std::marker::Sized` bound\n    = note: all local variables must have a statically known size\n+   = help: unsized locals are gated as an unstable feature\n \n error[E0277]: the size for values of type `Y` cannot be known at compilation time\n   --> $DIR/unsized6.rs:27:12\n@@ -63,6 +65,7 @@ LL |     let y: X = *x1;\n    = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n    = help: consider adding a `where X: std::marker::Sized` bound\n    = note: all local variables must have a statically known size\n+   = help: unsized locals are gated as an unstable feature\n \n error[E0277]: the size for values of type `X` cannot be known at compilation time\n   --> $DIR/unsized6.rs:34:9\n@@ -74,6 +77,7 @@ LL |     let y = *x2;\n    = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n    = help: consider adding a `where X: std::marker::Sized` bound\n    = note: all local variables must have a statically known size\n+   = help: unsized locals are gated as an unstable feature\n \n error[E0277]: the size for values of type `X` cannot be known at compilation time\n   --> $DIR/unsized6.rs:36:10\n@@ -85,6 +89,7 @@ LL |     let (y, z) = (*x3, 4);\n    = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n    = help: consider adding a `where X: std::marker::Sized` bound\n    = note: all local variables must have a statically known size\n+   = help: unsized locals are gated as an unstable feature\n \n error[E0277]: the size for values of type `X` cannot be known at compilation time\n   --> $DIR/unsized6.rs:40:9\n@@ -96,6 +101,7 @@ LL |     let y: X = *x1;\n    = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n    = help: consider adding a `where X: std::marker::Sized` bound\n    = note: all local variables must have a statically known size\n+   = help: unsized locals are gated as an unstable feature\n \n error[E0277]: the size for values of type `X` cannot be known at compilation time\n   --> $DIR/unsized6.rs:42:9\n@@ -107,6 +113,7 @@ LL |     let y = *x2;\n    = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n    = help: consider adding a `where X: std::marker::Sized` bound\n    = note: all local variables must have a statically known size\n+   = help: unsized locals are gated as an unstable feature\n \n error[E0277]: the size for values of type `X` cannot be known at compilation time\n   --> $DIR/unsized6.rs:44:10\n@@ -118,6 +125,7 @@ LL |     let (y, z) = (*x3, 4);\n    = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n    = help: consider adding a `where X: std::marker::Sized` bound\n    = note: all local variables must have a statically known size\n+   = help: unsized locals are gated as an unstable feature\n \n error[E0277]: the size for values of type `X` cannot be known at compilation time\n   --> $DIR/unsized6.rs:48:18\n@@ -129,6 +137,7 @@ LL | fn g1<X: ?Sized>(x: X) {}\n    = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n    = help: consider adding a `where X: std::marker::Sized` bound\n    = note: all local variables must have a statically known size\n+   = help: unsized locals are gated as an unstable feature\n \n error[E0277]: the size for values of type `X` cannot be known at compilation time\n   --> $DIR/unsized6.rs:50:22\n@@ -140,6 +149,7 @@ LL | fn g2<X: ?Sized + T>(x: X) {}\n    = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n    = help: consider adding a `where X: std::marker::Sized` bound\n    = note: all local variables must have a statically known size\n+   = help: unsized locals are gated as an unstable feature\n \n error: aborting due to 13 previous errors\n "}]}