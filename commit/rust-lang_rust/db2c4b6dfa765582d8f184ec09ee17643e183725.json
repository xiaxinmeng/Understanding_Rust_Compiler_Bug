{"sha": "db2c4b6dfa765582d8f184ec09ee17643e183725", "node_id": "C_kwDOAAsO6NoAKGRiMmM0YjZkZmE3NjU1ODJkOGYxODRlYzA5ZWUxNzY0M2UxODM3MjU", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-04-17T02:50:46Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-04-17T02:54:38Z"}, "message": "implement strerror_r", "tree": {"sha": "8fdccef9fbdf8eb32775d275631f4bdb9a97a033", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8fdccef9fbdf8eb32775d275631f4bdb9a97a033"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/db2c4b6dfa765582d8f184ec09ee17643e183725", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/db2c4b6dfa765582d8f184ec09ee17643e183725", "html_url": "https://github.com/rust-lang/rust/commit/db2c4b6dfa765582d8f184ec09ee17643e183725", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/db2c4b6dfa765582d8f184ec09ee17643e183725/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d1f31f913c266ee82ded3524057beb10f925042e", "url": "https://api.github.com/repos/rust-lang/rust/commits/d1f31f913c266ee82ded3524057beb10f925042e", "html_url": "https://github.com/rust-lang/rust/commit/d1f31f913c266ee82ded3524057beb10f925042e"}], "stats": {"total": 111, "additions": 77, "deletions": 34}, "files": [{"sha": "b052463bb022d3114b791e15cfd71ca313cb4384", "filename": "src/helpers.rs", "status": "modified", "additions": 61, "deletions": 34, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/db2c4b6dfa765582d8f184ec09ee17643e183725/src%2Fhelpers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db2c4b6dfa765582d8f184ec09ee17643e183725/src%2Fhelpers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fhelpers.rs?ref=db2c4b6dfa765582d8f184ec09ee17643e183725", "patch": "@@ -21,6 +21,27 @@ use crate::*;\n \n impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {}\n \n+const UNIX_IO_ERROR_TABLE: &[(std::io::ErrorKind, &str)] = {\n+    use std::io::ErrorKind::*;\n+    &[\n+        (ConnectionRefused, \"ECONNREFUSED\"),\n+        (ConnectionReset, \"ECONNRESET\"),\n+        (PermissionDenied, \"EPERM\"),\n+        (BrokenPipe, \"EPIPE\"),\n+        (NotConnected, \"ENOTCONN\"),\n+        (ConnectionAborted, \"ECONNABORTED\"),\n+        (AddrNotAvailable, \"EADDRNOTAVAIL\"),\n+        (AddrInUse, \"EADDRINUSE\"),\n+        (NotFound, \"ENOENT\"),\n+        (Interrupted, \"EINTR\"),\n+        (InvalidInput, \"EINVAL\"),\n+        (TimedOut, \"ETIMEDOUT\"),\n+        (AlreadyExists, \"EEXIST\"),\n+        (WouldBlock, \"EWOULDBLOCK\"),\n+        (DirectoryNotEmpty, \"ENOTEMPTY\"),\n+    ]\n+};\n+\n /// Gets an instance for a path.\n fn try_resolve_did<'mir, 'tcx>(tcx: TyCtxt<'tcx>, path: &[&str]) -> Option<DefId> {\n     tcx.crates(()).iter().find(|&&krate| tcx.crate_name(krate).as_str() == path[0]).and_then(\n@@ -502,39 +523,21 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         this.read_scalar(&errno_place.into())?.check_init()\n     }\n \n-    /// Sets the last OS error using a `std::io::ErrorKind`. This function tries to produce the most\n-    /// similar OS error from the `std::io::ErrorKind` and sets it as the last OS error.\n-    fn set_last_error_from_io_error(&mut self, err_kind: std::io::ErrorKind) -> InterpResult<'tcx> {\n-        use std::io::ErrorKind::*;\n-        let this = self.eval_context_mut();\n+    /// This function tries to produce the most similar OS error from the `std::io::ErrorKind`\n+    /// as a platform-specific errnum.\n+    fn io_error_to_errnum(&self, err_kind: std::io::ErrorKind) -> InterpResult<'tcx, Scalar<Tag>> {\n+        let this = self.eval_context_ref();\n         let target = &this.tcx.sess.target;\n-        let target_os = &target.os;\n-        let last_error = if target.families.iter().any(|f| f == \"unix\") {\n-            this.eval_libc(match err_kind {\n-                ConnectionRefused => \"ECONNREFUSED\",\n-                ConnectionReset => \"ECONNRESET\",\n-                PermissionDenied => \"EPERM\",\n-                BrokenPipe => \"EPIPE\",\n-                NotConnected => \"ENOTCONN\",\n-                ConnectionAborted => \"ECONNABORTED\",\n-                AddrNotAvailable => \"EADDRNOTAVAIL\",\n-                AddrInUse => \"EADDRINUSE\",\n-                NotFound => \"ENOENT\",\n-                Interrupted => \"EINTR\",\n-                InvalidInput => \"EINVAL\",\n-                TimedOut => \"ETIMEDOUT\",\n-                AlreadyExists => \"EEXIST\",\n-                WouldBlock => \"EWOULDBLOCK\",\n-                DirectoryNotEmpty => \"ENOTEMPTY\",\n-                _ => {\n-                    throw_unsup_format!(\n-                        \"io error {:?} cannot be translated into a raw os error\",\n-                        err_kind\n-                    )\n+        if target.families.iter().any(|f| f == \"unix\") {\n+            for &(kind, name) in UNIX_IO_ERROR_TABLE {\n+                if err_kind == kind {\n+                    return this.eval_libc(name);\n                 }\n-            })?\n+            }\n+            throw_unsup_format!(\"io error {:?} cannot be translated into a raw os error\", err_kind)\n         } else if target.families.iter().any(|f| f == \"windows\") {\n             // FIXME: we have to finish implementing the Windows equivalent of this.\n+            use std::io::ErrorKind::*;\n             this.eval_windows(\n                 \"c\",\n                 match err_kind {\n@@ -546,14 +549,38 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                             err_kind\n                         ),\n                 },\n-            )?\n+            )\n         } else {\n             throw_unsup_format!(\n-                \"setting the last OS error from an io::Error is unsupported for {}.\",\n-                target_os\n+                \"converting io::Error into errnum is unsupported for OS {}\",\n+                target.os\n             )\n-        };\n-        this.set_last_error(last_error)\n+        }\n+    }\n+\n+    /// The inverse of `io_error_to_errnum`.\n+    fn errnum_to_io_error(&self, errnum: Scalar<Tag>) -> InterpResult<'tcx, std::io::ErrorKind> {\n+        let this = self.eval_context_ref();\n+        let target = &this.tcx.sess.target;\n+        if target.families.iter().any(|f| f == \"unix\") {\n+            let errnum = errnum.to_i32()?;\n+            for &(kind, name) in UNIX_IO_ERROR_TABLE {\n+                if errnum == this.eval_libc_i32(name)? {\n+                    return Ok(kind);\n+                }\n+            }\n+            throw_unsup_format!(\"raw errnum {:?} cannot be translated into io::Error\", errnum)\n+        } else {\n+            throw_unsup_format!(\n+                \"converting errnum into io::Error is unsupported for OS {}\",\n+                target.os\n+            )\n+        }\n+    }\n+\n+    /// Sets the last OS error using a `std::io::ErrorKind`.\n+    fn set_last_error_from_io_error(&mut self, err_kind: std::io::ErrorKind) -> InterpResult<'tcx> {\n+        self.set_last_error(self.io_error_to_errnum(err_kind)?)\n     }\n \n     /// Helper function that consumes an `std::io::Result<T>` and returns an"}, {"sha": "16619d4aeb771cf4638757684b13741ffa5bc970", "filename": "src/shims/posix/foreign_items.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/db2c4b6dfa765582d8f184ec09ee17643e183725/src%2Fshims%2Fposix%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db2c4b6dfa765582d8f184ec09ee17643e183725/src%2Fshims%2Fposix%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fposix%2Fforeign_items.rs?ref=db2c4b6dfa765582d8f184ec09ee17643e183725", "patch": "@@ -1,3 +1,5 @@\n+use std::ffi::OsStr;\n+\n use log::trace;\n \n use rustc_middle::mir;\n@@ -421,6 +423,18 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 // We do not support forking, so there is nothing to do here.\n                 this.write_null(dest)?;\n             }\n+            \"strerror_r\" | \"__xpg_strerror_r\" => {\n+                let &[ref errnum, ref buf, ref buflen] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let errnum = this.read_scalar(errnum)?.check_init()?;\n+                let buf = this.read_pointer(buf)?;\n+                let buflen = this.read_scalar(buflen)?.to_machine_usize(this)?;\n+\n+                let error = this.errnum_to_io_error(errnum)?;\n+                let formatted = error.to_string();\n+                let (complete, _) = this.write_os_str_to_c_str(OsStr::new(&formatted), buf, buflen)?;\n+                let ret = if complete { 0 } else { this.eval_libc_i32(\"ERANGE\")? };\n+                this.write_int(ret, dest)?;\n+            }\n \n             // Incomplete shims that we \"stub out\" just to get pre-main initialization code to work.\n             // These shims are enabled only when the caller is in the standard library."}, {"sha": "bc78cb560f00af5b66ee1e96910fd4b7beb0b02f", "filename": "tests/run-pass/fs.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/db2c4b6dfa765582d8f184ec09ee17643e183725/tests%2Frun-pass%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db2c4b6dfa765582d8f184ec09ee17643e183725/tests%2Frun-pass%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Ffs.rs?ref=db2c4b6dfa765582d8f184ec09ee17643e183725", "patch": "@@ -335,6 +335,8 @@ fn test_errors() {\n     // The following tests also check that the `__errno_location()` shim is working properly.\n     // Opening a non-existing file should fail with a \"not found\" error.\n     assert_eq!(ErrorKind::NotFound, File::open(&path).unwrap_err().kind());\n+    // Make sure we can also format this.\n+    format!(\"{0:?}: {0}\", File::open(&path).unwrap_err());\n     // Removing a non-existing file should fail with a \"not found\" error.\n     assert_eq!(ErrorKind::NotFound, remove_file(&path).unwrap_err().kind());\n     // Reading the metadata of a non-existing file should fail with a \"not found\" error."}]}