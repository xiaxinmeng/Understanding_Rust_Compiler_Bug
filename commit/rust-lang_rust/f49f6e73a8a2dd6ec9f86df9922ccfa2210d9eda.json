{"sha": "f49f6e73a8a2dd6ec9f86df9922ccfa2210d9eda", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY0OWY2ZTczYThhMmRkNmVjOWY4NmRmOTkyMmNjZmEyMjEwZDllZGE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-09-23T15:00:53Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-09-23T15:00:53Z"}, "message": "Auto merge of #54229 - davidtwco:issue-52534, r=pnkfelix\n\n[nll] borrows that must be valid for a free lifetime should explain why\n\nFixes #52534.\n\nr? @nikomatsakis", "tree": {"sha": "c690cdcb18ef4d4ab0260686d22c509a1b2a7cdf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c690cdcb18ef4d4ab0260686d22c509a1b2a7cdf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f49f6e73a8a2dd6ec9f86df9922ccfa2210d9eda", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f49f6e73a8a2dd6ec9f86df9922ccfa2210d9eda", "html_url": "https://github.com/rust-lang/rust/commit/f49f6e73a8a2dd6ec9f86df9922ccfa2210d9eda", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f49f6e73a8a2dd6ec9f86df9922ccfa2210d9eda/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "be91c35f3466843713b9b6c5a7238ba83aef3602", "url": "https://api.github.com/repos/rust-lang/rust/commits/be91c35f3466843713b9b6c5a7238ba83aef3602", "html_url": "https://github.com/rust-lang/rust/commit/be91c35f3466843713b9b6c5a7238ba83aef3602"}, {"sha": "b342f0017931180097f17905da8640f674165255", "url": "https://api.github.com/repos/rust-lang/rust/commits/b342f0017931180097f17905da8640f674165255", "html_url": "https://github.com/rust-lang/rust/commit/b342f0017931180097f17905da8640f674165255"}], "stats": {"total": 1769, "additions": 1338, "deletions": 431}, "files": [{"sha": "98d9a0a7c6f5e3b376a4fb87d3783311fc1802bd", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f49f6e73a8a2dd6ec9f86df9922ccfa2210d9eda/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f49f6e73a8a2dd6ec9f86df9922ccfa2210d9eda/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=f49f6e73a8a2dd6ec9f86df9922ccfa2210d9eda", "patch": "@@ -1883,6 +1883,18 @@ impl<'tcx> Place<'tcx> {\n     pub fn elem(self, elem: PlaceElem<'tcx>) -> Place<'tcx> {\n         Place::Projection(Box::new(PlaceProjection { base: self, elem }))\n     }\n+\n+    /// Find the innermost `Local` from this `Place`.\n+    pub fn local(&self) -> Option<Local> {\n+        match self {\n+            Place::Local(local) |\n+            Place::Projection(box Projection {\n+                base: Place::Local(local),\n+                elem: ProjectionElem::Deref,\n+            }) => Some(*local),\n+            _ => None,\n+        }\n+    }\n }\n \n impl<'tcx> Debug for Place<'tcx> {"}, {"sha": "8fb5ed66a82ef311525424b086190e97d29e87fd", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/f49f6e73a8a2dd6ec9f86df9922ccfa2210d9eda/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f49f6e73a8a2dd6ec9f86df9922ccfa2210d9eda/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=f49f6e73a8a2dd6ec9f86df9922ccfa2210d9eda", "patch": "@@ -1324,6 +1324,23 @@ impl_stable_hash_for!(struct DebruijnIndex { private });\n \n /// Region utilities\n impl RegionKind {\n+    /// Is this region named by the user?\n+    pub fn has_name(&self) -> bool {\n+        match *self {\n+            RegionKind::ReEarlyBound(ebr) => ebr.has_name(),\n+            RegionKind::ReLateBound(_, br) => br.is_named(),\n+            RegionKind::ReFree(fr) => fr.bound_region.is_named(),\n+            RegionKind::ReScope(..) => false,\n+            RegionKind::ReStatic => true,\n+            RegionKind::ReVar(..) => false,\n+            RegionKind::ReSkolemized(_, br) => br.is_named(),\n+            RegionKind::ReEmpty => false,\n+            RegionKind::ReErased => false,\n+            RegionKind::ReClosureBound(..) => false,\n+            RegionKind::ReCanonical(..) => false,\n+        }\n+    }\n+\n     pub fn is_late_bound(&self) -> bool {\n         match *self {\n             ty::ReLateBound(..) => true,"}, {"sha": "59dd90dbd329a8e8cb5277fde0123216d4f0c281", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 45, "deletions": 7, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/f49f6e73a8a2dd6ec9f86df9922ccfa2210d9eda/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f49f6e73a8a2dd6ec9f86df9922ccfa2210d9eda/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=f49f6e73a8a2dd6ec9f86df9922ccfa2210d9eda", "patch": "@@ -34,7 +34,14 @@ use hir;\n thread_local! {\n     /// Mechanism for highlighting of specific regions for display in NLL region inference errors.\n     /// Contains region to highlight and counter for number to use when highlighting.\n-    static HIGHLIGHT_REGION: Cell<Option<(RegionVid, usize)>> = Cell::new(None)\n+    static HIGHLIGHT_REGION_FOR_REGIONVID: Cell<Option<(RegionVid, usize)>> = Cell::new(None)\n+}\n+\n+thread_local! {\n+    /// Mechanism for highlighting of specific regions for display in NLL's 'borrow does not live\n+    /// long enough' errors. Contains a region to highlight and a counter to use.\n+    static HIGHLIGHT_REGION_FOR_BOUND_REGION: Cell<Option<(ty::BoundRegion, usize)>> =\n+        Cell::new(None)\n }\n \n macro_rules! gen_display_debug_body {\n@@ -564,12 +571,34 @@ pub fn parameterized<F: fmt::Write>(f: &mut F,\n     PrintContext::new().parameterized(f, substs, did, projections)\n }\n \n-fn get_highlight_region() -> Option<(RegionVid, usize)> {\n-    HIGHLIGHT_REGION.with(|hr| hr.get())\n+fn get_highlight_region_for_regionvid() -> Option<(RegionVid, usize)> {\n+    HIGHLIGHT_REGION_FOR_REGIONVID.with(|hr| hr.get())\n }\n \n-pub fn with_highlight_region<R>(r: RegionVid, counter: usize, op: impl FnOnce() -> R) -> R {\n-    HIGHLIGHT_REGION.with(|hr| {\n+pub fn with_highlight_region_for_regionvid<R>(\n+    r: RegionVid,\n+    counter: usize,\n+    op: impl FnOnce() -> R\n+) -> R {\n+    HIGHLIGHT_REGION_FOR_REGIONVID.with(|hr| {\n+        assert_eq!(hr.get(), None);\n+        hr.set(Some((r, counter)));\n+        let r = op();\n+        hr.set(None);\n+        r\n+    })\n+}\n+\n+fn get_highlight_region_for_bound_region() -> Option<(ty::BoundRegion, usize)> {\n+    HIGHLIGHT_REGION_FOR_BOUND_REGION.with(|hr| hr.get())\n+}\n+\n+pub fn with_highlight_region_for_bound_region<R>(\n+    r: ty::BoundRegion,\n+    counter: usize,\n+    op: impl Fn() -> R\n+) -> R {\n+    HIGHLIGHT_REGION_FOR_BOUND_REGION.with(|hr| {\n         assert_eq!(hr.get(), None);\n         hr.set(Some((r, counter)));\n         let r = op();\n@@ -726,6 +755,15 @@ define_print! {\n                 return self.print_debug(f, cx);\n             }\n \n+            if let Some((region, counter)) = get_highlight_region_for_bound_region() {\n+                if *self == region {\n+                    return match *self {\n+                        BrNamed(_, name) => write!(f, \"{}\", name),\n+                        BrAnon(_) | BrFresh(_) | BrEnv => write!(f, \"'{}\", counter)\n+                    };\n+                }\n+            }\n+\n             match *self {\n                 BrNamed(_, name) => write!(f, \"{}\", name),\n                 BrAnon(_) | BrFresh(_) | BrEnv => Ok(())\n@@ -748,7 +786,7 @@ define_print! {\n define_print! {\n     () ty::RegionKind, (self, f, cx) {\n         display {\n-            if cx.is_verbose || get_highlight_region().is_some() {\n+            if cx.is_verbose || get_highlight_region_for_regionvid().is_some() {\n                 return self.print_debug(f, cx);\n             }\n \n@@ -923,7 +961,7 @@ impl fmt::Debug for ty::FloatVid {\n \n impl fmt::Debug for ty::RegionVid {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        if let Some((region, counter)) = get_highlight_region() {\n+        if let Some((region, counter)) = get_highlight_region_for_regionvid() {\n             debug!(\"RegionVid.fmt: region={:?} self={:?} counter={:?}\", region, self, counter);\n             return if *self == region {\n                 write!(f, \"'{:?}\", counter)"}, {"sha": "3fdb7d7f27d7ed623d87c523a6b788c792041255", "filename": "src/librustc_mir/borrow_check/error_reporting.rs", "status": "modified", "additions": 609, "deletions": 93, "changes": 702, "blob_url": "https://github.com/rust-lang/rust/blob/f49f6e73a8a2dd6ec9f86df9922ccfa2210d9eda/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f49f6e73a8a2dd6ec9f86df9922ccfa2210d9eda/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs?ref=f49f6e73a8a2dd6ec9f86df9922ccfa2210d9eda", "patch": "@@ -10,22 +10,26 @@\n \n use borrow_check::{WriteKind, StorageDeadOrDrop};\n use borrow_check::prefixes::IsPrefixOf;\n+use borrow_check::nll::explain_borrow::BorrowExplanation;\n use rustc::middle::region::ScopeTree;\n-use rustc::mir::VarBindingForm;\n-use rustc::mir::{BindingForm, BorrowKind, ClearCrossCrate, Field, Local};\n-use rustc::mir::{FakeReadCause, LocalDecl, LocalKind, Location, Operand, Place};\n-use rustc::mir::{ProjectionElem, Rvalue, Statement, StatementKind};\n+use rustc::mir::{\n+    self, AggregateKind, BindingForm, BorrowKind, ClearCrossCrate, FakeReadCause, Field, Local,\n+    LocalDecl, LocalKind, Location, Operand, Place, ProjectionElem, Rvalue, Statement,\n+    StatementKind, TerminatorKind, VarBindingForm,\n+};\n+use rustc::hir;\n+use rustc::hir::def_id::DefId;\n use rustc::ty;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::sync::Lrc;\n use rustc_errors::{Applicability, DiagnosticBuilder};\n+use rustc::util::ppaux::with_highlight_region_for_bound_region;\n use syntax_pos::Span;\n \n use super::borrow_set::BorrowData;\n use super::{Context, MirBorrowckCtxt};\n use super::{InitializationRequiringAction, PrefixSet};\n \n-use borrow_check::nll::explain_borrow::BorrowContainsPointReason;\n use dataflow::drop_flag_effects;\n use dataflow::move_paths::indexes::MoveOutIndex;\n use dataflow::move_paths::MovePathIndex;\n@@ -70,7 +74,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 Some(name) => format!(\"`{}`\", name),\n                 None => \"value\".to_owned(),\n             };\n-            let mut err = self.tcx.cannot_act_on_uninitialized_variable(\n+            let mut err = self.infcx.tcx.cannot_act_on_uninitialized_variable(\n                 span,\n                 desired_action.as_noun(),\n                 &self\n@@ -97,7 +101,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n             let msg = \"\"; //FIXME: add \"partially \" or \"collaterally \"\n \n-            let mut err = self.tcx.cannot_act_on_moved_value(\n+            let mut err = self.infcx.tcx.cannot_act_on_moved_value(\n                 span,\n                 desired_action.as_noun(),\n                 msg,\n@@ -149,9 +153,9 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             if let Some(ty) = self.retrieve_type_for_place(place) {\n                 let needs_note = match ty.sty {\n                     ty::Closure(id, _) => {\n-                        let tables = self.tcx.typeck_tables_of(id);\n-                        let node_id = self.tcx.hir.as_local_node_id(id).unwrap();\n-                        let hir_id = self.tcx.hir.node_to_hir_id(node_id);\n+                        let tables = self.infcx.tcx.typeck_tables_of(id);\n+                        let node_id = self.infcx.tcx.hir.as_local_node_id(id).unwrap();\n+                        let hir_id = self.infcx.tcx.hir.node_to_hir_id(node_id);\n                         if tables.closure_kind_origins().get(hir_id).is_some() {\n                             false\n                         } else {\n@@ -198,7 +202,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         (place, _span): (&Place<'tcx>, Span),\n         borrow: &BorrowData<'tcx>,\n     ) {\n-        let tcx = self.tcx;\n+        let tcx = self.infcx.tcx;\n         let value_msg = match self.describe_place(place) {\n             Some(name) => format!(\"`{}`\", name),\n             None => \"value\".to_owned(),\n@@ -226,7 +230,8 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n         move_spans.var_span_label(&mut err, \"move occurs due to use in closure\");\n \n-        self.explain_why_borrow_contains_point(context, borrow, None, &mut err);\n+        self.explain_why_borrow_contains_point(context, borrow, None)\n+            .emit(self.infcx.tcx, &mut err);\n         err.buffer(&mut self.errors_buffer);\n     }\n \n@@ -236,7 +241,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         (place, _span): (&Place<'tcx>, Span),\n         borrow: &BorrowData<'tcx>,\n     ) {\n-        let tcx = self.tcx;\n+        let tcx = self.infcx.tcx;\n \n         let borrow_spans = self.retrieve_borrow_spans(borrow);\n         let borrow_span = borrow_spans.args_or_use();\n@@ -263,7 +268,8 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             format!(\"borrow occurs due to use of `{}` in closure\", desc_place)\n         });\n \n-        self.explain_why_borrow_contains_point(context, borrow, None, &mut err);\n+        self.explain_why_borrow_contains_point(context, borrow, None)\n+            .emit(self.infcx.tcx, &mut err);\n         err.buffer(&mut self.errors_buffer);\n     }\n \n@@ -281,7 +287,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         let span = borrow_spans.args_or_use();\n \n         let desc_place = self.describe_place(place).unwrap_or(\"_\".to_owned());\n-        let tcx = self.tcx;\n+        let tcx = self.infcx.tcx;\n \n         // FIXME: supply non-\"\" `opt_via` when appropriate\n         let mut err = match (\n@@ -390,7 +396,8 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             );\n         }\n \n-        self.explain_why_borrow_contains_point(context, issued_borrow, None, &mut err);\n+        self.explain_why_borrow_contains_point(context, issued_borrow, None)\n+            .emit(self.infcx.tcx, &mut err);\n \n         err.buffer(&mut self.errors_buffer);\n     }\n@@ -417,7 +424,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         );\n \n         let drop_span = place_span.1;\n-        let scope_tree = self.tcx.region_scope_tree(self.mir_def_id);\n+        let scope_tree = self.infcx.tcx.region_scope_tree(self.mir_def_id);\n         let root_place = self\n             .prefixes(&borrow.borrowed_place, PrefixSet::All)\n             .last()\n@@ -445,47 +452,39 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         self.access_place_error_reported\n             .insert((root_place.clone(), borrow_span));\n \n-        let borrow_reason = self.find_why_borrow_contains_point(context, borrow);\n-\n-        if let Some(WriteKind::StorageDeadOrDrop(StorageDeadOrDrop::Destructor)) = kind\n-        {\n+        if let Some(WriteKind::StorageDeadOrDrop(StorageDeadOrDrop::Destructor)) = kind {\n             // If a borrow of path `B` conflicts with drop of `D` (and\n             // we're not in the uninteresting case where `B` is a\n             // prefix of `D`), then report this as a more interesting\n             // destructor conflict.\n             if !borrow.borrowed_place.is_prefix_of(place_span.0) {\n-                self.report_borrow_conflicts_with_destructor(\n-                    context, borrow, borrow_reason, place_span, kind);\n+                self.report_borrow_conflicts_with_destructor(context, borrow, place_span, kind);\n                 return;\n             }\n         }\n \n-        let mut err = match &self.describe_place(&borrow.borrowed_place) {\n-            Some(_) if self.is_place_thread_local(root_place) => {\n-                self.report_thread_local_value_does_not_live_long_enough(drop_span, borrow_span)\n-            }\n+        let err = match &self.describe_place(&borrow.borrowed_place) {\n+            Some(_) if self.is_place_thread_local(root_place) =>\n+                self.report_thread_local_value_does_not_live_long_enough(drop_span, borrow_span),\n             Some(name) => self.report_local_value_does_not_live_long_enough(\n                 context,\n                 name,\n                 &scope_tree,\n                 &borrow,\n-                borrow_reason,\n                 drop_span,\n-                borrow_span,\n+                borrow_spans,\n                 kind.map(|k| (k, place_span.0)),\n             ),\n             None => self.report_temporary_value_does_not_live_long_enough(\n                 context,\n                 &scope_tree,\n                 &borrow,\n-                borrow_reason,\n                 drop_span,\n+                borrow_spans,\n                 proper_span,\n             ),\n         };\n \n-        borrow_spans.args_span_label(&mut err, \"value captured here\");\n-\n         err.buffer(&mut self.errors_buffer);\n     }\n \n@@ -495,68 +494,102 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         name: &String,\n         scope_tree: &Lrc<ScopeTree>,\n         borrow: &BorrowData<'tcx>,\n-        reason: BorrowContainsPointReason<'tcx>,\n         drop_span: Span,\n-        borrow_span: Span,\n+        borrow_spans: UseSpans,\n         kind_place: Option<(WriteKind, &Place<'tcx>)>,\n     ) -> DiagnosticBuilder<'cx> {\n         debug!(\n             \"report_local_value_does_not_live_long_enough(\\\n-             {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}\\\n+             {:?}, {:?}, {:?}, {:?}, {:?}, {:?}\\\n              )\",\n-            context, name, scope_tree, borrow, reason, drop_span, borrow_span\n+            context, name, scope_tree, borrow, drop_span, borrow_spans\n         );\n \n-        let mut err = self.tcx.path_does_not_live_long_enough(\n+        let borrow_span = borrow_spans.var_or_use();\n+        let mut err = self.infcx.tcx.path_does_not_live_long_enough(\n             borrow_span,\n             &format!(\"`{}`\", name),\n             Origin::Mir,\n         );\n \n-        err.span_label(borrow_span, \"borrowed value does not live long enough\");\n-        err.span_label(\n-            drop_span,\n-            format!(\"`{}` dropped here while still borrowed\", name),\n-        );\n+        let explanation = self.explain_why_borrow_contains_point(context, borrow, kind_place);\n+        if let Some(annotation) = self.annotate_argument_and_return_for_borrow(borrow) {\n+            let region_name = annotation.emit(&mut err);\n+\n+            err.span_label(\n+                borrow_span,\n+                format!(\"`{}` would have to be valid for `{}`...\", name, region_name)\n+            );\n+\n+            if let Some(fn_node_id) = self.infcx.tcx.hir.as_local_node_id(self.mir_def_id) {\n+                err.span_label(\n+                    drop_span,\n+                    format!(\n+                        \"...but `{}` will be dropped here, when the function `{}` returns\",\n+                        name, self.infcx.tcx.hir.name(fn_node_id),\n+                    )\n+                );\n+\n+                err.note(\n+                    \"functions cannot return a borrow to data owned within the function's scope, \\\n+                     functions can only return borrows to data passed as arguments\",\n+                );\n+                err.note(\n+                    \"to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch04-02-\\\n+                     references-and-borrowing.html#dangling-references>\",\n+                );\n+            } else {\n+                err.span_label(\n+                    drop_span,\n+                    format!(\"...but `{}` dropped here while still borrowed\", name)\n+                );\n+            }\n+\n+            if let BorrowExplanation::MustBeValidFor(..) = explanation { } else {\n+                explanation.emit(self.infcx.tcx, &mut err);\n+            }\n+        } else {\n+            err.span_label(borrow_span, \"borrowed value does not live long enough\");\n+            err.span_label(drop_span, format!(\"`{}` dropped here while still borrowed\", name));\n+\n+            borrow_spans.args_span_label(&mut err, \"value captured here\");\n+\n+            explanation.emit(self.infcx.tcx, &mut err);\n+        }\n \n-        self.report_why_borrow_contains_point(&mut err, reason, kind_place);\n         err\n     }\n \n     pub(super) fn report_borrow_conflicts_with_destructor(\n         &mut self,\n         context: Context,\n         borrow: &BorrowData<'tcx>,\n-        borrow_reason: BorrowContainsPointReason<'tcx>,\n-        place_span: (&Place<'tcx>, Span),\n+        (place, drop_span): (&Place<'tcx>, Span),\n         kind: Option<WriteKind>,\n     ) {\n         debug!(\n             \"report_borrow_conflicts_with_destructor(\\\n-             {:?}, {:?}, {:?}, {:?} {:?}\\\n+             {:?}, {:?}, ({:?}, {:?}), {:?}\\\n              )\",\n-            context, borrow, borrow_reason, place_span, kind,\n+            context, borrow, place, drop_span, kind,\n         );\n \n         let borrow_spans = self.retrieve_borrow_spans(borrow);\n         let borrow_span = borrow_spans.var_or_use();\n \n-        let mut err = self.tcx.cannot_borrow_across_destructor(borrow_span, Origin::Mir);\n-\n-        let drop_span = place_span.1;\n+        let mut err = self.infcx.tcx.cannot_borrow_across_destructor(borrow_span, Origin::Mir);\n \n         let (what_was_dropped, dropped_ty) = {\n-            let place = place_span.0;\n             let desc = match self.describe_place(place) {\n                 Some(name) => format!(\"`{}`\", name.as_str()),\n                 None => format!(\"temporary value\"),\n             };\n-            let ty = place.ty(self.mir, self.tcx).to_ty(self.tcx);\n+            let ty = place.ty(self.mir, self.infcx.tcx).to_ty(self.infcx.tcx);\n             (desc, ty)\n         };\n \n         let label = match dropped_ty.sty {\n-            ty::Adt(adt, _) if adt.has_dtor(self.tcx) && !adt.is_box() => {\n+            ty::Adt(adt, _) if adt.has_dtor(self.infcx.tcx) && !adt.is_box() => {\n                 match self.describe_place(&borrow.borrowed_place) {\n                     Some(borrowed) =>\n                         format!(\"here, drop of {D} needs exclusive access to `{B}`, \\\n@@ -571,17 +604,19 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         };\n         err.span_label(drop_span, label);\n \n-        // Only give this note and suggestion if they could be relevant\n-        match borrow_reason {\n-            BorrowContainsPointReason::Liveness {..}\n-            | BorrowContainsPointReason::DropLiveness {..} => {\n+        // Only give this note and suggestion if they could be relevant.\n+        let explanation = self.explain_why_borrow_contains_point(\n+            context, borrow, kind.map(|k| (k, place)),\n+        );\n+        match explanation {\n+            BorrowExplanation::UsedLater {..} |\n+            BorrowExplanation::UsedLaterWhenDropped {..} => {\n                 err.note(\"consider using a `let` binding to create a longer lived value\");\n-            }\n-            BorrowContainsPointReason::OutlivesFreeRegion {..} => (),\n+            },\n+            _ => {},\n         }\n \n-        self.report_why_borrow_contains_point(\n-            &mut err, borrow_reason, kind.map(|k| (k, place_span.0)));\n+        explanation.emit(self.infcx.tcx, &mut err);\n \n         err.buffer(&mut self.errors_buffer);\n     }\n@@ -598,15 +633,16 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             drop_span, borrow_span\n         );\n \n-        let mut err = self\n-            .tcx\n-            .thread_local_value_does_not_live_long_enough(borrow_span, Origin::Mir);\n+        let mut err = self.infcx.tcx.thread_local_value_does_not_live_long_enough(\n+            borrow_span, Origin::Mir\n+        );\n \n         err.span_label(\n             borrow_span,\n             \"thread-local variables cannot be borrowed beyond the end of the function\",\n         );\n         err.span_label(drop_span, \"end of enclosing function is here\");\n+\n         err\n     }\n \n@@ -615,33 +651,37 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         context: Context,\n         scope_tree: &Lrc<ScopeTree>,\n         borrow: &BorrowData<'tcx>,\n-        reason: BorrowContainsPointReason<'tcx>,\n         drop_span: Span,\n+        borrow_spans: UseSpans,\n         proper_span: Span,\n     ) -> DiagnosticBuilder<'cx> {\n         debug!(\n             \"report_temporary_value_does_not_live_long_enough(\\\n-             {:?}, {:?}, {:?}, {:?}, {:?}, {:?}\\\n+             {:?}, {:?}, {:?}, {:?}, {:?}\\\n              )\",\n-            context, scope_tree, borrow, reason, drop_span, proper_span\n+            context, scope_tree, borrow, drop_span, proper_span\n         );\n \n-        let tcx = self.tcx;\n+        let tcx = self.infcx.tcx;\n         let mut err =\n             tcx.path_does_not_live_long_enough(proper_span, \"borrowed value\", Origin::Mir);\n         err.span_label(proper_span, \"temporary value does not live long enough\");\n         err.span_label(drop_span, \"temporary value only lives until here\");\n \n-        // Only give this note and suggestion if they could be relevant\n-        match reason {\n-            BorrowContainsPointReason::Liveness {..}\n-            | BorrowContainsPointReason::DropLiveness {..} => {\n+        let explanation = self.explain_why_borrow_contains_point(context, borrow, None);\n+        match explanation {\n+            BorrowExplanation::UsedLater(..) |\n+            BorrowExplanation::UsedLaterInLoop(..) |\n+            BorrowExplanation::UsedLaterWhenDropped(..) => {\n+                // Only give this note and suggestion if it could be relevant.\n                 err.note(\"consider using a `let` binding to create a longer lived value\");\n-            }\n-            BorrowContainsPointReason::OutlivesFreeRegion {..} => (),\n+            },\n+            _ => {},\n         }\n+        explanation.emit(self.infcx.tcx, &mut err);\n+\n+        borrow_spans.args_span_label(&mut err, \"value captured here\");\n \n-        self.report_why_borrow_contains_point(&mut err, reason, None);\n         err\n     }\n \n@@ -715,7 +755,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n             // check for inits\n             let mut any_match = false;\n-            drop_flag_effects::for_location_inits(self.tcx, self.mir, self.move_data, l, |m| {\n+            drop_flag_effects::for_location_inits(self.infcx.tcx, self.mir, self.move_data, l, |m| {\n                 if m == mpi {\n                     any_match = true;\n                 }\n@@ -739,7 +779,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         let loan_spans = self.retrieve_borrow_spans(loan);\n         let loan_span = loan_spans.args_or_use();\n \n-        let tcx = self.tcx;\n+        let tcx = self.infcx.tcx;\n         let mut err = tcx.cannot_assign_to_borrowed(\n             span,\n             loan_span,\n@@ -749,7 +789,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n         loan_spans.var_span_label(&mut err, \"borrow occurs due to use in closure\");\n \n-        self.explain_why_borrow_contains_point(context, loan, None, &mut err);\n+        self.explain_why_borrow_contains_point(context, loan, None).emit(self.infcx.tcx, &mut err);\n \n         err.buffer(&mut self.errors_buffer);\n     }\n@@ -801,7 +841,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             Some(decl) => (self.describe_place(err_place), decl.source_info.span),\n         };\n \n-        let mut err = self.tcx.cannot_reassign_immutable(\n+        let mut err = self.infcx.tcx.cannot_reassign_immutable(\n             span,\n             place_description.as_ref().map(AsRef::as_ref).unwrap_or(\"_\"),\n             from_arg,\n@@ -879,13 +919,13 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 self.append_local_to_string(local, buf)?;\n             }\n             Place::Static(ref static_) => {\n-                buf.push_str(&self.tcx.item_name(static_.def_id).to_string());\n+                buf.push_str(&self.infcx.tcx.item_name(static_.def_id).to_string());\n             }\n             Place::Projection(ref proj) => {\n                 match proj.elem {\n                     ProjectionElem::Deref => {\n                         let upvar_field_projection =\n-                            place.is_upvar_field_projection(self.mir, &self.tcx);\n+                            place.is_upvar_field_projection(self.mir, &self.infcx.tcx);\n                         if let Some(field) = upvar_field_projection {\n                             let var_index = field.index();\n                             let name = self.mir.upvar_decls[var_index].debug_name.to_string();\n@@ -947,7 +987,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                         autoderef = true;\n \n                         let upvar_field_projection =\n-                            place.is_upvar_field_projection(self.mir, &self.tcx);\n+                            place.is_upvar_field_projection(self.mir, &self.infcx.tcx);\n                         if let Some(field) = upvar_field_projection {\n                             let var_index = field.index();\n                             let name = self.mir.upvar_decls[var_index].debug_name.to_string();\n@@ -1062,10 +1102,10 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     // the local code in the current crate, so this returns an `Option` in case\n                     // the closure comes from another crate. But in that case we wouldn't\n                     // be borrowck'ing it, so we can just unwrap:\n-                    let node_id = self.tcx.hir.as_local_node_id(def_id).unwrap();\n-                    let freevar = self.tcx.with_freevars(node_id, |fv| fv[field.index()]);\n+                    let node_id = self.infcx.tcx.hir.as_local_node_id(def_id).unwrap();\n+                    let freevar = self.infcx.tcx.with_freevars(node_id, |fv| fv[field.index()]);\n \n-                    self.tcx.hir.name(freevar.var_id()).to_string()\n+                    self.infcx.tcx.hir.name(freevar.var_id()).to_string()\n                 }\n                 _ => {\n                     // Might need a revision when the fields in trait RFC is implemented\n@@ -1098,7 +1138,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n     /// Check if a place is a thread-local static.\n     pub fn is_place_thread_local(&self, place: &Place<'tcx>) -> bool {\n         if let Place::Static(statik) = place {\n-            let attrs = self.tcx.get_attrs(statik.def_id);\n+            let attrs = self.infcx.tcx.get_attrs(statik.def_id);\n             let is_thread_local = attrs.iter().any(|attr| attr.check_name(\"thread_local\"));\n \n             debug!(\n@@ -1126,6 +1166,481 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             None\n         }\n     }\n+\n+    /// Annotate argument and return type of function and closure with (synthesized) lifetime for\n+    /// borrow of local value that does not live long enough.\n+    fn annotate_argument_and_return_for_borrow(\n+        &self,\n+        borrow: &BorrowData<'tcx>,\n+    ) -> Option<AnnotatedBorrowFnSignature> {\n+        // Define a fallback for when we can't match a closure.\n+        let fallback = || {\n+            let is_closure = self.infcx.tcx.is_closure(self.mir_def_id);\n+            if is_closure {\n+                None\n+            } else {\n+                 let ty = self.infcx.tcx.type_of(self.mir_def_id);\n+                 match ty.sty {\n+                     ty::TyKind::FnDef(_, _) | ty::TyKind::FnPtr(_) =>\n+                        self.annotate_fn_sig(\n+                            self.mir_def_id,\n+                            self.infcx.tcx.fn_sig(self.mir_def_id)\n+                        ),\n+                    _ => None,\n+                }\n+            }\n+        };\n+\n+        // In order to determine whether we need to annotate, we need to check whether the reserve\n+        // place was an assignment into a temporary.\n+        //\n+        // If it was, we check whether or not that temporary is eventually assigned into the return\n+        // place. If it was, we can add annotations about the function's return type and arguments\n+        // and it'll make sense.\n+        let location = borrow.reserve_location;\n+        debug!(\"annotate_argument_and_return_for_borrow: location={:?}\", location);\n+        match &self.mir[location.block].statements.get(location.statement_index) {\n+            Some(&Statement {\n+                kind: StatementKind::Assign(ref reservation, _),\n+                ..\n+            }) => {\n+                debug!(\"annotate_argument_and_return_for_borrow: reservation={:?}\", reservation);\n+                // Check that the initial assignment of the reserve location is into a temporary.\n+                let mut target = *match reservation {\n+                    Place::Local(local) if self.mir.local_kind(*local) == LocalKind::Temp => local,\n+                    _ => return None,\n+                };\n+\n+                // Next, look through the rest of the block, checking if we are assigning the\n+                // `target` (that is, the place that contains our borrow) to anything.\n+                let mut annotated_closure = None;\n+                for stmt in &self.mir[location.block].statements[location.statement_index + 1..] {\n+                    debug!(\n+                        \"annotate_argument_and_return_for_borrow: target={:?} stmt={:?}\",\n+                        target, stmt\n+                    );\n+                    if let StatementKind::Assign(\n+                        Place::Local(assigned_to),\n+                        rvalue,\n+                    ) = &stmt.kind {\n+                        debug!(\"annotate_argument_and_return_for_borrow: assigned_to={:?} \\\n+                               rvalue={:?}\", assigned_to, rvalue);\n+                        // Check if our `target` was captured by a closure.\n+                        if let Rvalue::Aggregate(\n+                                box AggregateKind::Closure(def_id, substs),\n+                                operands,\n+                        ) = rvalue {\n+                            for operand in operands {\n+                                let assigned_from = match operand {\n+                                    Operand::Copy(assigned_from) |\n+                                    Operand::Move(assigned_from) => assigned_from,\n+                                    _ => continue,\n+                                };\n+                                debug!(\n+                                    \"annotate_argument_and_return_for_borrow: assigned_from={:?}\",\n+                                    assigned_from\n+                                );\n+\n+                                // Find the local from the operand.\n+                                let assigned_from_local = match assigned_from.local() {\n+                                    Some(local) => local,\n+                                    None => continue,\n+                                };\n+\n+                                if assigned_from_local != target {\n+                                    continue;\n+                                }\n+\n+                                // If a closure captured our `target` and then assigned\n+                                // into a place then we should annotate the closure in\n+                                // case it ends up being assigned into the return place.\n+                                annotated_closure = self.annotate_fn_sig(\n+                                    *def_id,\n+                                    self.infcx.closure_sig(*def_id, *substs)\n+                                );\n+                                debug!(\n+                                    \"annotate_argument_and_return_for_borrow: \\\n+                                     annotated_closure={:?} assigned_from_local={:?} \\\n+                                     assigned_to={:?}\",\n+                                     annotated_closure, assigned_from_local, assigned_to\n+                                );\n+\n+                                if *assigned_to == mir::RETURN_PLACE {\n+                                    // If it was assigned directly into the return place, then\n+                                    // return now.\n+                                    return annotated_closure;\n+                                } else {\n+                                    // Otherwise, update the target.\n+                                    target = *assigned_to;\n+                                }\n+                            }\n+\n+                            // If none of our closure's operands matched, then skip to the next\n+                            // statement.\n+                            continue;\n+                        }\n+\n+                        // Otherwise, look at other types of assignment.\n+                        let assigned_from = match rvalue {\n+                            Rvalue::Ref(_, _, assigned_from) => assigned_from,\n+                            Rvalue::Use(operand) => match operand {\n+                                Operand::Copy(assigned_from) |\n+                                Operand::Move(assigned_from) => assigned_from,\n+                                _ => continue,\n+                            },\n+                            _ => continue,\n+                        };\n+                        debug!(\n+                            \"annotate_argument_and_return_for_borrow: \\\n+                             assigned_from={:?}\", assigned_from,\n+                        );\n+\n+                        // Find the local from the rvalue.\n+                        let assigned_from_local = match assigned_from.local() {\n+                            Some(local) => local,\n+                            None => continue,\n+                        };\n+                        debug!(\n+                            \"annotate_argument_and_return_for_borrow: \\\n+                             assigned_from_local={:?}\", assigned_from_local,\n+                        );\n+\n+                        // Check if our local matches the target - if so, we've assigned our\n+                        // borrow to a new place.\n+                        if assigned_from_local != target {\n+                            continue;\n+                        }\n+\n+                        // If we assigned our `target` into a new place, then we should\n+                        // check if it was the return place.\n+                        debug!(\n+                            \"annotate_argument_and_return_for_borrow: \\\n+                             assigned_from_local={:?} assigned_to={:?}\",\n+                             assigned_from_local, assigned_to\n+                        );\n+                        if *assigned_to == mir::RETURN_PLACE {\n+                            // If it was then return the annotated closure if there was one,\n+                            // else, annotate this function.\n+                            return annotated_closure.or_else(fallback);\n+                        }\n+\n+                        // If we didn't assign into the return place, then we just update\n+                        // the target.\n+                        target = *assigned_to;\n+                    }\n+                }\n+\n+                // Check the terminator if we didn't find anything in the statements.\n+                let terminator = &self.mir[location.block].terminator();\n+                debug!(\n+                    \"annotate_argument_and_return_for_borrow: target={:?} terminator={:?}\",\n+                    target, terminator\n+                );\n+                if let TerminatorKind::Call {\n+                    destination: Some((Place::Local(assigned_to), _)),\n+                    args,\n+                    ..\n+                } = &terminator.kind {\n+                    debug!(\n+                        \"annotate_argument_and_return_for_borrow: assigned_to={:?} args={:?}\",\n+                        assigned_to, args\n+                    );\n+                    for operand in args {\n+                        let assigned_from = match operand {\n+                            Operand::Copy(assigned_from) |\n+                            Operand::Move(assigned_from) => assigned_from,\n+                            _ => continue,\n+                        };\n+                        debug!(\n+                            \"annotate_argument_and_return_for_borrow: assigned_from={:?}\",\n+                            assigned_from,\n+                        );\n+\n+                        if let Some(assigned_from_local) = assigned_from.local() {\n+                            debug!(\n+                                \"annotate_argument_and_return_for_borrow: assigned_from_local={:?}\",\n+                                assigned_from_local,\n+                            );\n+\n+                            if *assigned_to == mir::RETURN_PLACE &&\n+                                assigned_from_local == target\n+                            {\n+                                return annotated_closure.or_else(fallback);\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+            _ => {}\n+        }\n+\n+        // If we haven't found an assignment into the return place, then we need not add\n+        // any annotations.\n+        debug!(\"annotate_argument_and_return_for_borrow: none found\");\n+        None\n+    }\n+\n+    /// Annotate the first argument and return type of a function signature if they are\n+    /// references.\n+    fn annotate_fn_sig(\n+        &self,\n+        did: DefId,\n+        sig: ty::PolyFnSig<'tcx>,\n+    ) -> Option<AnnotatedBorrowFnSignature> {\n+        debug!(\"annotate_fn_sig: did={:?} sig={:?}\", did, sig);\n+        let is_closure = self.infcx.tcx.is_closure(did);\n+        let fn_node_id = self.infcx.tcx.hir.as_local_node_id(did)?;\n+        let fn_decl = self.infcx.tcx.hir.fn_decl(fn_node_id)?;\n+\n+        // We need to work out which arguments to highlight. We do this by looking\n+        // at the return type, where there are three cases:\n+        //\n+        // 1. If there are named arguments, then we should highlight the return type and\n+        //    highlight any of the arguments that are also references with that lifetime.\n+        //    If there are no arguments that have the same lifetime as the return type,\n+        //    then don't highlight anything.\n+        // 2. The return type is a reference with an anonymous lifetime. If this is\n+        //    the case, then we can take advantage of (and teach) the lifetime elision\n+        //    rules.\n+        //\n+        //    We know that an error is being reported. So the arguments and return type\n+        //    must satisfy the elision rules. Therefore, if there is a single argument\n+        //    then that means the return type and first (and only) argument have the same\n+        //    lifetime and the borrow isn't meeting that, we can highlight the argument\n+        //    and return type.\n+        //\n+        //    If there are multiple arguments then the first argument must be self (else\n+        //    it would not satisfy the elision rules), so we can highlight self and the\n+        //    return type.\n+        // 3. The return type is not a reference. In this case, we don't highlight\n+        //    anything.\n+        let return_ty = sig.output();\n+        match return_ty.skip_binder().sty {\n+            ty::TyKind::Ref(return_region, _, _) if return_region.has_name() && !is_closure => {\n+                // This is case 1 from above, return type is a named reference so we need to\n+                // search for relevant arguments.\n+                let mut arguments = Vec::new();\n+                for (index, argument) in sig.inputs().skip_binder().iter().enumerate() {\n+                    if let ty::TyKind::Ref(argument_region, _, _) = argument.sty {\n+                        if argument_region == return_region {\n+                            // Need to use the `rustc::ty` types to compare against the\n+                            // `return_region`. Then use the `rustc::hir` type to get only\n+                            // the lifetime span.\n+                            match &fn_decl.inputs[index].node {\n+                                hir::TyKind::Rptr(lifetime, _) => {\n+                                    // With access to the lifetime, we can get\n+                                    // the span of it.\n+                                    arguments.push((*argument, lifetime.span));\n+                                },\n+                                _ => bug!(\"ty type is a ref but hir type is not\"),\n+                            }\n+                        }\n+                    }\n+                }\n+\n+                // We need to have arguments. This shouldn't happen, but it's worth checking.\n+                if arguments.is_empty() {\n+                    return None;\n+                }\n+\n+                // We use a mix of the HIR and the Ty types to get information\n+                // as the HIR doesn't have full types for closure arguments.\n+                let return_ty = *sig.output().skip_binder();\n+                let mut return_span = fn_decl.output.span();\n+                if let hir::FunctionRetTy::Return(ty) = fn_decl.output {\n+                    if let hir::TyKind::Rptr(lifetime, _) = ty.into_inner().node {\n+                        return_span = lifetime.span;\n+                    }\n+                }\n+\n+                Some(AnnotatedBorrowFnSignature::NamedFunction {\n+                    arguments,\n+                    return_ty,\n+                    return_span,\n+                })\n+            },\n+            ty::TyKind::Ref(_, _, _) if is_closure => {\n+                // This is case 2 from above but only for closures, return type is anonymous\n+                // reference so we select\n+                // the first argument.\n+                let argument_span = fn_decl.inputs.first()?.span;\n+                let argument_ty = sig.inputs().skip_binder().first()?;\n+\n+                // Closure arguments are wrapped in a tuple, so we need to get the first\n+                // from that.\n+                if let ty::TyKind::Tuple(elems) = argument_ty.sty {\n+                    let argument_ty = elems.first()?;\n+                    if let ty::TyKind::Ref(_, _, _) = argument_ty.sty {\n+                        return Some(AnnotatedBorrowFnSignature::Closure {\n+                            argument_ty,\n+                            argument_span,\n+                        });\n+                    }\n+                }\n+\n+                None\n+            },\n+            ty::TyKind::Ref(_, _, _) => {\n+                // This is also case 2 from above but for functions, return type is still an\n+                // anonymous reference so we select the first argument.\n+                let argument_span = fn_decl.inputs.first()?.span;\n+                let argument_ty = sig.inputs().skip_binder().first()?;\n+\n+                let return_span = fn_decl.output.span();\n+                let return_ty = *sig.output().skip_binder();\n+\n+                // We expect the first argument to be a reference.\n+                match argument_ty.sty {\n+                    ty::TyKind::Ref(_, _, _) => {},\n+                    _ => return None,\n+                }\n+\n+                Some(AnnotatedBorrowFnSignature::AnonymousFunction {\n+                    argument_ty,\n+                    argument_span,\n+                    return_ty,\n+                    return_span,\n+                })\n+            },\n+            _ => {\n+                // This is case 3 from above, return type is not a reference so don't highlight\n+                // anything.\n+                None\n+            },\n+        }\n+    }\n+}\n+\n+#[derive(Debug)]\n+enum AnnotatedBorrowFnSignature<'tcx> {\n+    NamedFunction {\n+        arguments: Vec<(ty::Ty<'tcx>, Span)>,\n+        return_ty: ty::Ty<'tcx>,\n+        return_span: Span,\n+    },\n+    AnonymousFunction {\n+        argument_ty: ty::Ty<'tcx>,\n+        argument_span: Span,\n+        return_ty: ty::Ty<'tcx>,\n+        return_span: Span,\n+    },\n+    Closure {\n+        argument_ty: ty::Ty<'tcx>,\n+        argument_span: Span,\n+    }\n+}\n+\n+impl<'tcx> AnnotatedBorrowFnSignature<'tcx> {\n+    /// Annotate the provided diagnostic with information about borrow from the fn signature that\n+    /// helps explain.\n+    fn emit(\n+        &self,\n+        diag: &mut DiagnosticBuilder<'_>\n+    ) -> String {\n+        match self {\n+            AnnotatedBorrowFnSignature::Closure { argument_ty, argument_span } => {\n+                diag.span_label(\n+                    *argument_span,\n+                    format!(\"has type `{}`\", self.get_name_for_ty(argument_ty, 0)),\n+                );\n+\n+                self.get_region_name_for_ty(argument_ty, 0)\n+            },\n+            AnnotatedBorrowFnSignature::AnonymousFunction {\n+                argument_ty,\n+                argument_span,\n+                return_ty,\n+                return_span,\n+            } => {\n+                let argument_ty_name = self.get_name_for_ty(argument_ty, 0);\n+                diag.span_label(\n+                    *argument_span,\n+                    format!(\"has type `{}`\", argument_ty_name)\n+                );\n+\n+                let return_ty_name = self.get_name_for_ty(return_ty, 0);\n+                let types_equal = return_ty_name == argument_ty_name;\n+                diag.span_label(\n+                    *return_span,\n+                    format!(\n+                        \"{}has type `{}`\",\n+                        if types_equal { \"also \" } else { \"\" },\n+                        return_ty_name,\n+                    )\n+                );\n+\n+                diag.note(\n+                    \"argument and return type have the same lifetime due to lifetime elision rules\",\n+                );\n+                diag.note(\n+                    \"to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch10-03-\\\n+                     lifetime-syntax.html#lifetime-elision>\",\n+                );\n+\n+                self.get_region_name_for_ty(return_ty, 0)\n+            },\n+            AnnotatedBorrowFnSignature::NamedFunction {\n+                arguments,\n+                return_ty,\n+                return_span,\n+            } => {\n+                // Region of return type and arguments checked to be the same earlier.\n+                let region_name = self.get_region_name_for_ty(return_ty, 0);\n+                for (_, argument_span) in arguments {\n+                    diag.span_label(\n+                        *argument_span,\n+                        format!(\"has lifetime `{}`\", region_name)\n+                    );\n+                }\n+\n+                diag.span_label(\n+                    *return_span,\n+                    format!(\n+                        \"also has lifetime `{}`\",\n+                        region_name,\n+                    )\n+                );\n+\n+                diag.help(\n+                    &format!(\n+                        \"use data from the highlighted arguments which match the `{}` lifetime of \\\n+                         the return type\",\n+                         region_name,\n+                    ),\n+                );\n+\n+                region_name\n+            },\n+        }\n+    }\n+\n+    /// Return the name of the provided `Ty` (that must be a reference) with a synthesized lifetime\n+    /// name where required.\n+    fn get_name_for_ty(&self, ty: ty::Ty<'tcx>, counter: usize) -> String {\n+        // We need to add synthesized lifetimes where appropriate. We do\n+        // this by hooking into the pretty printer and telling it to label the\n+        // lifetimes without names with the value `'0`.\n+        match ty.sty {\n+            ty::TyKind::Ref(ty::RegionKind::ReLateBound(_, br), _, _) |\n+            ty::TyKind::Ref(ty::RegionKind::ReSkolemized(_, br), _, _) =>\n+                with_highlight_region_for_bound_region(*br, counter, || format!(\"{}\", ty)),\n+            _ => format!(\"{}\", ty),\n+        }\n+    }\n+\n+    /// Return the name of the provided `Ty` (that must be a reference)'s region with a\n+    /// synthesized lifetime name where required.\n+    fn get_region_name_for_ty(&self, ty: ty::Ty<'tcx>, counter: usize) -> String {\n+        match ty.sty {\n+            ty::TyKind::Ref(region, _, _) => match region {\n+                ty::RegionKind::ReLateBound(_, br) |\n+                ty::RegionKind::ReSkolemized(_, br) =>\n+                    with_highlight_region_for_bound_region(*br, counter, || format!(\"{}\", region)),\n+                _ => format!(\"{}\", region),\n+            }\n+            _ => bug!(\"ty for annotation of borrow region is not a reference\"),\n+        }\n+    }\n }\n \n // The span(s) associated to a use of a place.\n@@ -1214,9 +1729,11 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             if let AggregateKind::Closure(def_id, _) = **kind {\n                 debug!(\"find_closure_move_span: found closure {:?}\", places);\n \n-                if let Some(node_id) = self.tcx.hir.as_local_node_id(def_id) {\n-                    if let Closure(_, _, _, args_span, _) = self.tcx.hir.expect_expr(node_id).node {\n-                        if let Some(var_span) = self.tcx.with_freevars(node_id, |freevars| {\n+                if let Some(node_id) = self.infcx.tcx.hir.as_local_node_id(def_id) {\n+                    if let Closure(\n+                        _, _, _, args_span, _\n+                    ) = self.infcx.tcx.hir.expect_expr(node_id).node {\n+                        if let Some(var_span) = self.infcx.tcx.with_freevars(node_id, |freevars| {\n                             for (v, place) in freevars.iter().zip(places) {\n                                 match place {\n                                     Operand::Copy(place) | Operand::Move(place)\n@@ -1253,7 +1770,6 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n     pub(super) fn borrow_spans(&self, use_span: Span, location: Location) -> UseSpans {\n         use self::UseSpans::*;\n         use rustc::hir::ExprKind::Closure;\n-        use rustc::mir::AggregateKind;\n \n         let local = match self.mir[location.block]\n             .statements\n@@ -1276,16 +1792,16 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 if let AggregateKind::Closure(def_id, _) = **kind {\n                     debug!(\"find_closure_borrow_span: found closure {:?}\", places);\n \n-                    return if let Some(node_id) = self.tcx.hir.as_local_node_id(def_id) {\n+                    return if let Some(node_id) = self.infcx.tcx.hir.as_local_node_id(def_id) {\n                         let args_span = if let Closure(_, _, _, span, _) =\n-                            self.tcx.hir.expect_expr(node_id).node\n+                            self.infcx.tcx.hir.expect_expr(node_id).node\n                         {\n                             span\n                         } else {\n                             return OtherUse(use_span);\n                         };\n \n-                        self.tcx\n+                        self.infcx.tcx\n                             .with_freevars(node_id, |freevars| {\n                                 for (v, place) in freevars.iter().zip(places) {\n                                     match *place {"}, {"sha": "06884875598df8a3eb9b419eed4647659f42286f", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 29, "deletions": 28, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/f49f6e73a8a2dd6ec9f86df9922ccfa2210d9eda/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f49f6e73a8a2dd6ec9f86df9922ccfa2210d9eda/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=f49f6e73a8a2dd6ec9f86df9922ccfa2210d9eda", "patch": "@@ -247,8 +247,8 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n     let dominators = mir.dominators();\n \n     let mut mbcx = MirBorrowckCtxt {\n-        tcx: tcx,\n-        mir: mir,\n+        infcx,\n+        mir,\n         mir_def_id: def_id,\n         move_data: &mdpe.move_data,\n         param_env: param_env,\n@@ -369,7 +369,7 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n         }\n \n         for diag in mbcx.errors_buffer.drain(..) {\n-            DiagnosticBuilder::new_diagnostic(mbcx.tcx.sess.diagnostic(), diag).emit();\n+            DiagnosticBuilder::new_diagnostic(mbcx.infcx.tcx.sess.diagnostic(), diag).emit();\n         }\n     }\n \n@@ -384,7 +384,7 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n }\n \n pub struct MirBorrowckCtxt<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n-    tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n+    infcx: &'cx InferCtxt<'cx, 'gcx, 'tcx>,\n     mir: &'cx Mir<'tcx>,\n     mir_def_id: DefId,\n     move_data: &'cx MoveData<'tcx>,\n@@ -612,13 +612,14 @@ impl<'cx, 'gcx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx\n                 target: _,\n                 unwind: _,\n             } => {\n-                let gcx = self.tcx.global_tcx();\n+                let gcx = self.infcx.tcx.global_tcx();\n \n                 // Compute the type with accurate region information.\n-                let drop_place_ty = drop_place.ty(self.mir, self.tcx);\n+                let drop_place_ty = drop_place.ty(self.mir, self.infcx.tcx);\n \n                 // Erase the regions.\n-                let drop_place_ty = self.tcx.erase_regions(&drop_place_ty).to_ty(self.tcx);\n+                let drop_place_ty = self.infcx.tcx.erase_regions(&drop_place_ty)\n+                    .to_ty(self.infcx.tcx);\n \n                 // \"Lift\" into the gcx -- once regions are erased, this type should be in the\n                 // global arenas; this \"lift\" operation basically just asserts that is true, but\n@@ -953,7 +954,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             return;\n         }\n \n-        let gcx = self.tcx.global_tcx();\n+        let gcx = self.infcx.tcx.global_tcx();\n         let drop_field = |mir: &mut MirBorrowckCtxt<'cx, 'gcx, 'tcx>,\n                           (index, field): (usize, ty::Ty<'gcx>)| {\n             let field_ty = gcx.normalize_erasing_regions(mir.param_env, field);\n@@ -971,7 +972,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             // individual fields instead. This way if `foo` has a\n             // destructor but `bar` does not, we will only check for\n             // borrows of `x.foo` and not `x.bar`. See #47703.\n-            ty::Adt(def, substs) if def.is_struct() && !def.has_dtor(self.tcx) => {\n+            ty::Adt(def, substs) if def.is_struct() && !def.has_dtor(self.infcx.tcx) => {\n                 def.all_fields()\n                     .map(|field| field.ty(gcx, substs))\n                     .enumerate()\n@@ -991,7 +992,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     && !self.mir.upvar_decls.is_empty() =>\n             {\n                 substs\n-                    .upvar_tys(def, self.tcx)\n+                    .upvar_tys(def, self.infcx.tcx)\n                     .enumerate()\n                     .for_each(|field| drop_field(self, field));\n             }\n@@ -1002,7 +1003,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     && !self.mir.upvar_decls.is_empty() =>\n             {\n                 substs\n-                    .upvar_tys(def, self.tcx)\n+                    .upvar_tys(def, self.infcx.tcx)\n                     .enumerate()\n                     .for_each(|field| drop_field(self, field));\n             }\n@@ -1168,7 +1169,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         );\n \n         let mut error_reported = false;\n-        let tcx = self.tcx;\n+        let tcx = self.infcx.tcx;\n         let mir = self.mir;\n         let location = self.location_table.start_index(context.loc);\n         let borrow_set = self.borrow_set.clone();\n@@ -1206,7 +1207,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 (Read(kind), BorrowKind::Unique) | (Read(kind), BorrowKind::Mut { .. }) => {\n                     // Reading from mere reservations of mutable-borrows is OK.\n                     if !is_active(&this.dominators, borrow, context.loc) {\n-                        assert!(allow_two_phase_borrow(&this.tcx, borrow.kind));\n+                        assert!(allow_two_phase_borrow(&this.infcx.tcx, borrow.kind));\n                         return Control::Continue;\n                     }\n \n@@ -1338,7 +1339,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     BorrowKind::Shared => (Deep, Read(ReadKind::Borrow(bk))),\n                     BorrowKind::Unique | BorrowKind::Mut { .. } => {\n                         let wk = WriteKind::MutableBorrow(bk);\n-                        if allow_two_phase_borrow(&self.tcx, bk) {\n+                        if allow_two_phase_borrow(&self.infcx.tcx, bk) {\n                             (Deep, Reservation(wk))\n                         } else {\n                             (Deep, Write(wk))\n@@ -1413,7 +1414,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     | AggregateKind::Generator(def_id, _, _) => {\n                         let BorrowCheckResult {\n                             used_mut_upvars, ..\n-                        } = self.tcx.mir_borrowck(def_id);\n+                        } = self.infcx.tcx.mir_borrowck(def_id);\n                         debug!(\"{:?} used_mut_upvars={:?}\", def_id, used_mut_upvars);\n                         for field in used_mut_upvars {\n                             // This relies on the current way that by-value\n@@ -1427,7 +1428,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                                 Operand::Move(ref place @ Place::Projection(_))\n                                 | Operand::Copy(ref place @ Place::Projection(_)) => {\n                                     if let Some(field) = place.is_upvar_field_projection(\n-                                            self.mir, &self.tcx) {\n+                                            self.mir, &self.infcx.tcx) {\n                                         self.used_mut_upvars.push(field);\n                                     }\n                                 }\n@@ -1546,11 +1547,11 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         // that is merged.\n         let sd = if might_be_alive { Deep } else { Shallow(None) };\n \n-        if places_conflict::places_conflict(self.tcx, self.mir, place, root_place, sd) {\n+        if places_conflict::places_conflict(self.infcx.tcx, self.mir, place, root_place, sd) {\n             debug!(\"check_for_invalidation_at_exit({:?}): INVALID\", place);\n             // FIXME: should be talking about the region lifetime instead\n             // of just a span here.\n-            let span = self.tcx.sess.source_map().end_point(span);\n+            let span = self.infcx.tcx.sess.source_map().end_point(span);\n             self.report_borrowed_value_does_not_live_long_enough(\n                 context,\n                 borrow,\n@@ -1566,7 +1567,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         debug!(\"check_for_local_borrow({:?})\", borrow);\n \n         if borrow_of_local_data(&borrow.borrowed_place) {\n-            let err = self.tcx\n+            let err = self.infcx.tcx\n                 .cannot_borrow_across_generator_yield(\n                     self.retrieve_borrow_spans(borrow).var_or_use(),\n                     yield_span,\n@@ -1583,7 +1584,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         span: Span,\n         flow_state: &Flows<'cx, 'gcx, 'tcx>,\n     ) {\n-        if !self.tcx.two_phase_borrows() {\n+        if !self.infcx.tcx.two_phase_borrows() {\n             return;\n         }\n \n@@ -1845,7 +1846,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                             // if type of `P` has a dtor, then\n                             // assigning to `P.f` requires `P` itself\n                             // be already initialized\n-                            let tcx = self.tcx;\n+                            let tcx = self.infcx.tcx;\n                             match base.ty(self.mir, tcx).to_ty(tcx).sty {\n                                 ty::Adt(def, _) if def.has_dtor(tcx) => {\n                                     self.check_if_path_or_subpath_is_moved(\n@@ -1929,7 +1930,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             | Write(wk @ WriteKind::StorageDeadOrDrop(_))\n             | Write(wk @ WriteKind::MutableBorrow(BorrowKind::Shared)) => {\n                 if let Err(_place_err) = self.is_mutable(place, is_local_mutation_allowed) {\n-                    if self.tcx.migrate_borrowck() {\n+                    if self.infcx.tcx.migrate_borrowck() {\n                         // rust-lang/rust#46908: In pure NLL mode this\n                         // code path should be unreachable (and thus\n                         // we signal an ICE in the else branch\n@@ -1952,7 +1953,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                             location,\n                         );\n                     } else {\n-                        self.tcx.sess.delay_span_bug(\n+                        self.infcx.tcx.sess.delay_span_bug(\n                             span,\n                             &format!(\n                                 \"Accessing `{:?}` with the kind `{:?}` shouldn't be possible\",\n@@ -2020,7 +2021,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 place: place @ Place::Projection(_),\n                 is_local_mutation_allowed: _,\n             } => {\n-                if let Some(field) = place.is_upvar_field_projection(self.mir, &self.tcx) {\n+                if let Some(field) = place.is_upvar_field_projection(self.mir, &self.infcx.tcx) {\n                     self.used_mut_upvars.push(field);\n                 }\n             }\n@@ -2070,7 +2071,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 is_local_mutation_allowed,\n             }),\n             Place::Static(ref static_) => {\n-                if self.tcx.is_static(static_.def_id) != Some(hir::Mutability::MutMutable) {\n+                if self.infcx.tcx.is_static(static_.def_id) != Some(hir::Mutability::MutMutable) {\n                     Err(place)\n                 } else {\n                     Ok(RootPlace {\n@@ -2082,7 +2083,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             Place::Projection(ref proj) => {\n                 match proj.elem {\n                     ProjectionElem::Deref => {\n-                        let base_ty = proj.base.ty(self.mir, self.tcx).to_ty(self.tcx);\n+                        let base_ty = proj.base.ty(self.mir, self.infcx.tcx).to_ty(self.infcx.tcx);\n \n                         // Check the kind of deref to decide\n                         match base_ty.sty {\n@@ -2094,7 +2095,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                                     // unique path to the `&mut`\n                                     hir::MutMutable => {\n                                         let mode = match place.is_upvar_field_projection(\n-                                            self.mir, &self.tcx)\n+                                            self.mir, &self.infcx.tcx)\n                                         {\n                                             Some(field)\n                                                 if {\n@@ -2140,7 +2141,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     | ProjectionElem::Subslice { .. }\n                     | ProjectionElem::Downcast(..) => {\n                         let upvar_field_projection = place.is_upvar_field_projection(\n-                            self.mir, &self.tcx);\n+                            self.mir, &self.infcx.tcx);\n                         if let Some(field) = upvar_field_projection {\n                             let decl = &self.mir.upvar_decls[field.index()];\n                             debug!("}, {"sha": "8a97f25ef58136372916f015d08804140a6158ff", "filename": "src/librustc_mir/borrow_check/move_errors.rs", "status": "modified", "additions": 23, "deletions": 22, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/f49f6e73a8a2dd6ec9f86df9922ccfa2210d9eda/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f49f6e73a8a2dd6ec9f86df9922ccfa2210d9eda/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs?ref=f49f6e73a8a2dd6ec9f86df9922ccfa2210d9eda", "patch": "@@ -244,30 +244,31 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n             let origin = Origin::Mir;\n             debug!(\"report: original_path={:?} span={:?}, kind={:?} \\\n                    original_path.is_upvar_field_projection={:?}\", original_path, span, kind,\n-                   original_path.is_upvar_field_projection(self.mir, &self.tcx));\n+                   original_path.is_upvar_field_projection(self.mir, &self.infcx.tcx));\n             (\n                 match kind {\n                     IllegalMoveOriginKind::Static => {\n-                        self.tcx.cannot_move_out_of(span, \"static item\", origin)\n+                        self.infcx.tcx.cannot_move_out_of(span, \"static item\", origin)\n                     }\n                     IllegalMoveOriginKind::BorrowedContent { target_place: place } => {\n                         // Inspect the type of the content behind the\n                         // borrow to provide feedback about why this\n                         // was a move rather than a copy.\n-                        let ty = place.ty(self.mir, self.tcx).to_ty(self.tcx);\n+                        let ty = place.ty(self.mir, self.infcx.tcx).to_ty(self.infcx.tcx);\n                         let is_upvar_field_projection =\n                             self.prefixes(&original_path, PrefixSet::All)\n-                            .any(|p| p.is_upvar_field_projection(self.mir, &self.tcx)\n+                            .any(|p| p.is_upvar_field_projection(self.mir, &self.infcx.tcx)\n                                  .is_some());\n                         match ty.sty {\n-                            ty::Array(..) | ty::Slice(..) => self\n-                                .tcx\n-                                .cannot_move_out_of_interior_noncopy(span, ty, None, origin),\n+                            ty::Array(..) | ty::Slice(..) =>\n+                                self.infcx.tcx.cannot_move_out_of_interior_noncopy(\n+                                    span, ty, None, origin\n+                                ),\n                             ty::Closure(def_id, closure_substs)\n                                 if !self.mir.upvar_decls.is_empty() && is_upvar_field_projection\n                             => {\n                                 let closure_kind_ty =\n-                                    closure_substs.closure_kind_ty(def_id, self.tcx);\n+                                    closure_substs.closure_kind_ty(def_id, self.infcx.tcx);\n                                 let closure_kind = closure_kind_ty.to_opt_closure_kind();\n                                 let place_description = match closure_kind {\n                                     Some(ty::ClosureKind::Fn) => {\n@@ -285,37 +286,38 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n                                        place_description={:?}\", closure_kind_ty, closure_kind,\n                                        place_description);\n \n-                                let mut diag = self.tcx.cannot_move_out_of(\n+                                let mut diag = self.infcx.tcx.cannot_move_out_of(\n                                     span, place_description, origin);\n \n                                 for prefix in self.prefixes(&original_path, PrefixSet::All) {\n                                     if let Some(field) = prefix.is_upvar_field_projection(\n-                                            self.mir, &self.tcx) {\n+                                            self.mir, &self.infcx.tcx) {\n                                         let upvar_decl = &self.mir.upvar_decls[field.index()];\n                                         let upvar_hir_id =\n                                             upvar_decl.var_hir_id.assert_crate_local();\n                                         let upvar_node_id =\n-                                            self.tcx.hir.hir_to_node_id(upvar_hir_id);\n-                                        let upvar_span = self.tcx.hir.span(upvar_node_id);\n+                                            self.infcx.tcx.hir.hir_to_node_id(upvar_hir_id);\n+                                        let upvar_span = self.infcx.tcx.hir.span(upvar_node_id);\n                                         diag.span_label(upvar_span, \"captured outer variable\");\n                                         break;\n                                     }\n                                 }\n \n                                 diag\n                             }\n-                            _ => self\n-                                .tcx\n-                                .cannot_move_out_of(span, \"borrowed content\", origin),\n+                            _ => self.infcx.tcx.cannot_move_out_of(\n+                                span, \"borrowed content\", origin\n+                            ),\n                         }\n                     }\n                     IllegalMoveOriginKind::InteriorOfTypeWithDestructor { container_ty: ty } => {\n-                        self.tcx\n+                        self.infcx.tcx\n                             .cannot_move_out_of_interior_of_drop(span, ty, origin)\n                     }\n-                    IllegalMoveOriginKind::InteriorOfSliceOrArray { ty, is_index } => self\n-                        .tcx\n-                        .cannot_move_out_of_interior_noncopy(span, ty, Some(*is_index), origin),\n+                    IllegalMoveOriginKind::InteriorOfSliceOrArray { ty, is_index } =>\n+                        self.infcx.tcx.cannot_move_out_of_interior_noncopy(\n+                            span, ty, Some(*is_index), origin\n+                        ),\n                 },\n                 span,\n             )\n@@ -331,7 +333,7 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n         err: &mut DiagnosticBuilder<'a>,\n         span: Span,\n     ) {\n-        let snippet = self.tcx.sess.source_map().span_to_snippet(span).unwrap();\n+        let snippet = self.infcx.tcx.sess.source_map().span_to_snippet(span).unwrap();\n         match error {\n             GroupedMoveError::MovesFromPlace {\n                 mut binds_to,\n@@ -394,8 +396,7 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n                     ..\n                 }))\n             ) = bind_to.is_user_variable {\n-                let pat_snippet = self\n-                    .tcx.sess.source_map()\n+                let pat_snippet = self.infcx.tcx.sess.source_map()\n                     .span_to_snippet(pat_span)\n                     .unwrap();\n                 if pat_snippet.starts_with('&') {"}, {"sha": "30555dbf26082a45c324ba286bc4947f6aa99cf6", "filename": "src/librustc_mir/borrow_check/mutability_errors.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/f49f6e73a8a2dd6ec9f86df9922ccfa2210d9eda/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f49f6e73a8a2dd6ec9f86df9922ccfa2210d9eda/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs?ref=f49f6e73a8a2dd6ec9f86df9922ccfa2210d9eda", "patch": "@@ -71,11 +71,11 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n                 elem: ProjectionElem::Field(upvar_index, _),\n             }) => {\n                 debug_assert!(is_closure_or_generator(\n-                    base.ty(self.mir, self.tcx).to_ty(self.tcx)\n+                    base.ty(self.mir, self.infcx.tcx).to_ty(self.infcx.tcx)\n                 ));\n \n                 item_msg = format!(\"`{}`\", access_place_desc.unwrap());\n-                if access_place.is_upvar_field_projection(self.mir, &self.tcx).is_some() {\n+                if access_place.is_upvar_field_projection(self.mir, &self.infcx.tcx).is_some() {\n                     reason = \", as it is not declared as mutable\".to_string();\n                 } else {\n                     let name = self.mir.upvar_decls[upvar_index.index()].debug_name;\n@@ -91,11 +91,11 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n                     item_msg = format!(\"`{}`\", access_place_desc.unwrap());\n                     debug_assert!(self.mir.local_decls[Local::new(1)].ty.is_region_ptr());\n                     debug_assert!(is_closure_or_generator(\n-                        the_place_err.ty(self.mir, self.tcx).to_ty(self.tcx)\n+                        the_place_err.ty(self.mir, self.infcx.tcx).to_ty(self.infcx.tcx)\n                     ));\n \n                     reason = if access_place.is_upvar_field_projection(self.mir,\n-                                                                       &self.tcx).is_some() {\n+                                                                       &self.infcx.tcx).is_some() {\n                         \", as it is a captured variable in a `Fn` closure\".to_string()\n                     } else {\n                         \", as `Fn` closures cannot mutate their captured variables\".to_string()\n@@ -116,7 +116,7 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n                     reason = \", as it is immutable for the pattern guard\".to_string();\n                 } else {\n                     let pointer_type =\n-                        if base.ty(self.mir, self.tcx).to_ty(self.tcx).is_region_ptr() {\n+                        if base.ty(self.mir, self.infcx.tcx).to_ty(self.infcx.tcx).is_region_ptr() {\n                             \"`&` reference\"\n                         } else {\n                             \"`*const` pointer\"\n@@ -145,7 +145,7 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n                     reason = String::new();\n                 } else {\n                     item_msg = format!(\"`{}`\", access_place_desc.unwrap());\n-                    let static_name = &self.tcx.item_name(*def_id);\n+                    let static_name = &self.infcx.tcx.item_name(*def_id);\n                     reason = format!(\", as `{}` is an immutable static item\", static_name);\n                 }\n             }\n@@ -177,14 +177,14 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n \n         let span = match error_access {\n             AccessKind::Move => {\n-                err = self.tcx\n+                err = self.infcx.tcx\n                     .cannot_move_out_of(span, &(item_msg + &reason), Origin::Mir);\n                 act = \"move\";\n                 acted_on = \"moved\";\n                 span\n             }\n             AccessKind::Mutate => {\n-                err = self.tcx\n+                err = self.infcx.tcx\n                     .cannot_assign(span, &(item_msg + &reason), Origin::Mir);\n                 act = \"assign\";\n                 acted_on = \"written\";\n@@ -196,7 +196,7 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n \n                 let borrow_spans = self.borrow_spans(span, location);\n                 let borrow_span = borrow_spans.args_or_use();\n-                err = self.tcx.cannot_borrow_path_as_mutable_because(\n+                err = self.infcx.tcx.cannot_borrow_path_as_mutable_because(\n                     borrow_span,\n                     &item_msg,\n                     &reason,\n@@ -242,16 +242,16 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n                 elem: ProjectionElem::Field(upvar_index, _),\n             }) => {\n                 debug_assert!(is_closure_or_generator(\n-                    base.ty(self.mir, self.tcx).to_ty(self.tcx)\n+                    base.ty(self.mir, self.infcx.tcx).to_ty(self.infcx.tcx)\n                 ));\n \n                 err.span_label(span, format!(\"cannot {ACT}\", ACT = act));\n \n                 let upvar_hir_id = self.mir.upvar_decls[upvar_index.index()]\n                     .var_hir_id\n                     .assert_crate_local();\n-                let upvar_node_id = self.tcx.hir.hir_to_node_id(upvar_hir_id);\n-                if let Some(Node::Binding(pat)) = self.tcx.hir.find(upvar_node_id) {\n+                let upvar_node_id = self.infcx.tcx.hir.hir_to_node_id(upvar_hir_id);\n+                if let Some(Node::Binding(pat)) = self.infcx.tcx.hir.find(upvar_node_id) {\n                     if let hir::PatKind::Binding(\n                         hir::BindingAnnotation::Unannotated,\n                         _,\n@@ -274,7 +274,7 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n             // a local variable, then just suggest the user remove it.\n             Place::Local(_)\n                 if {\n-                    if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(span) {\n+                    if let Ok(snippet) = self.infcx.tcx.sess.source_map().span_to_snippet(span) {\n                         snippet.starts_with(\"&mut \")\n                     } else {\n                         false\n@@ -317,15 +317,15 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n                 let local_decl = &self.mir.local_decls[*local];\n                 let suggestion = match local_decl.is_user_variable.as_ref().unwrap() {\n                     ClearCrossCrate::Set(mir::BindingForm::ImplicitSelf) => {\n-                        Some(suggest_ampmut_self(self.tcx, local_decl))\n+                        Some(suggest_ampmut_self(self.infcx.tcx, local_decl))\n                     }\n \n                     ClearCrossCrate::Set(mir::BindingForm::Var(mir::VarBindingForm {\n                         binding_mode: ty::BindingMode::BindByValue(_),\n                         opt_ty_info,\n                         ..\n                     })) => Some(suggest_ampmut(\n-                        self.tcx,\n+                        self.infcx.tcx,\n                         self.mir,\n                         *local,\n                         local_decl,\n@@ -337,7 +337,7 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n                         ..\n                     })) => {\n                         let pattern_span = local_decl.source_info.span;\n-                        suggest_ref_mut(self.tcx, pattern_span)\n+                        suggest_ref_mut(self.infcx.tcx, pattern_span)\n                             .map(|replacement| (pattern_span, replacement))\n                     }\n \n@@ -426,11 +426,11 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n                                 ..\n                             }\n                         ) = &self.mir.basic_blocks()[location.block].terminator {\n-                            if self.tcx.parent(id) == self.tcx.lang_items().index_trait() {\n-\n+                            let index_trait = self.infcx.tcx.lang_items().index_trait();\n+                            if self.infcx.tcx.parent(id) == index_trait {\n                                 let mut found = false;\n-                                self.tcx.for_each_relevant_impl(\n-                                    self.tcx.lang_items().index_mut_trait().unwrap(),\n+                                self.infcx.tcx.for_each_relevant_impl(\n+                                    self.infcx.tcx.lang_items().index_mut_trait().unwrap(),\n                                     substs.type_at(0),\n                                     |_relevant_impl| {\n                                         found = true;"}, {"sha": "d4adff7c443cbcd18eb2f123f260a2f27ed6a31f", "filename": "src/librustc_mir/borrow_check/nll/explain_borrow/find_use.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f49f6e73a8a2dd6ec9f86df9922ccfa2210d9eda/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Ffind_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f49f6e73a8a2dd6ec9f86df9922ccfa2210d9eda/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Ffind_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Ffind_use.rs?ref=f49f6e73a8a2dd6ec9f86df9922ccfa2210d9eda", "patch": "@@ -121,9 +121,7 @@ struct DefUseVisitor<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n \n enum DefUseResult {\n     Def,\n-\n     UseLive { local: Local },\n-\n     UseDrop { local: Local },\n }\n "}, {"sha": "755148b69925320286c8c95c1efb2f14d48e49c2", "filename": "src/librustc_mir/borrow_check/nll/explain_borrow/mod.rs", "status": "modified", "additions": 97, "deletions": 115, "changes": 212, "blob_url": "https://github.com/rust-lang/rust/blob/f49f6e73a8a2dd6ec9f86df9922ccfa2210d9eda/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f49f6e73a8a2dd6ec9f86df9922ccfa2210d9eda/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs?ref=f49f6e73a8a2dd6ec9f86df9922ccfa2210d9eda", "patch": "@@ -11,26 +11,71 @@\n use borrow_check::borrow_set::BorrowData;\n use borrow_check::nll::region_infer::Cause;\n use borrow_check::{Context, MirBorrowckCtxt, WriteKind};\n-use rustc::mir::{FakeReadCause, Local, Location, Place, TerminatorKind};\n+use rustc::ty::{Region, TyCtxt};\n+use rustc::mir::{FakeReadCause, Location, Place, TerminatorKind};\n use rustc_errors::DiagnosticBuilder;\n-use rustc::ty::Region;\n+use syntax_pos::Span;\n+use syntax_pos::symbol::Symbol;\n \n mod find_use;\n \n-#[derive(Copy, Clone, Debug)]\n-pub enum BorrowContainsPointReason<'tcx> {\n-    Liveness {\n-        local: Local,\n-        location: Location,\n-        in_loop: bool,\n-    },\n-    DropLiveness {\n-        local: Local,\n-        location: Location,\n-    },\n-    OutlivesFreeRegion {\n-        outlived_region: Option<Region<'tcx>>,\n-    },\n+pub(in borrow_check) enum BorrowExplanation<'tcx> {\n+    UsedLater(bool, Option<FakeReadCause>, Span),\n+    UsedLaterInLoop(bool, Span),\n+    UsedLaterWhenDropped(Span, Symbol, bool),\n+    MustBeValidFor(Region<'tcx>),\n+    Unexplained,\n+}\n+\n+impl<'tcx> BorrowExplanation<'tcx> {\n+    pub(in borrow_check) fn emit<'cx, 'gcx>(\n+        &self,\n+        tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n+        err: &mut DiagnosticBuilder<'_>\n+    ) {\n+        match *self {\n+            BorrowExplanation::UsedLater(is_in_closure, fake_read_cause, var_or_use_span) => {\n+                let message = if is_in_closure {\n+                    \"borrow later captured here by closure\"\n+                } else if let Some(FakeReadCause::ForLet) = fake_read_cause {\n+                    \"borrow later stored here\"\n+                } else {\n+                    \"borrow later used here\"\n+                };\n+                err.span_label(var_or_use_span, message);\n+            },\n+            BorrowExplanation::UsedLaterInLoop(is_in_closure, var_or_use_span) => {\n+                let message = if is_in_closure {\n+                    \"borrow captured here by closure in later iteration of loop\"\n+                } else {\n+                    \"borrow used here in later iteration of loop\"\n+                };\n+                err.span_label(var_or_use_span, message);\n+            },\n+            BorrowExplanation::UsedLaterWhenDropped(span, local_name, should_note_order) => {\n+                err.span_label(\n+                    span,\n+                    format!(\"borrow later used here, when `{}` is dropped\", local_name),\n+                );\n+\n+                if should_note_order {\n+                    err.note(\n+                        \"values in a scope are dropped \\\n+                         in the opposite order they are defined\",\n+                    );\n+                }\n+            },\n+            BorrowExplanation::MustBeValidFor(region) => {\n+                tcx.note_and_explain_free_region(\n+                    err,\n+                    \"borrowed value must be valid for \",\n+                    region,\n+                    \"...\",\n+                );\n+            },\n+            _ => {},\n+        }\n+    }\n }\n \n impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n@@ -53,140 +98,78 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         context: Context,\n         borrow: &BorrowData<'tcx>,\n         kind_place: Option<(WriteKind, &Place<'tcx>)>,\n-        err: &mut DiagnosticBuilder<'_>,\n-    ) {\n-        let reason = self.find_why_borrow_contains_point(context, borrow);\n-        self.report_why_borrow_contains_point(err, reason, kind_place);\n-    }\n-\n-    /// Finds the reason that [explain_why_borrow_contains_point] will report\n-    /// but doesn't add it to any message. This is a separate function in case\n-    /// the caller wants to change the error they report based on the reason\n-    /// that will be reported.\n-    pub(in borrow_check) fn find_why_borrow_contains_point(\n-        &self,\n-        context: Context,\n-        borrow: &BorrowData<'tcx>\n-    ) -> BorrowContainsPointReason<'tcx> {\n-        use self::BorrowContainsPointReason::*;\n-\n+    ) -> BorrowExplanation<'tcx> {\n         debug!(\n             \"find_why_borrow_contains_point(context={:?}, borrow={:?})\",\n             context, borrow,\n         );\n \n         let regioncx = &self.nonlexical_regioncx;\n         let mir = self.mir;\n-        let tcx = self.tcx;\n+        let tcx = self.infcx.tcx;\n \n         let borrow_region_vid = regioncx.to_region_vid(borrow.region);\n-\n         debug!(\n             \"explain_why_borrow_contains_point: borrow_region_vid={:?}\",\n             borrow_region_vid\n         );\n \n         let region_sub = regioncx.find_sub_region_live_at(borrow_region_vid, context.loc);\n-\n         debug!(\n             \"explain_why_borrow_contains_point: region_sub={:?}\",\n             region_sub\n         );\n \n-        match find_use::find(mir, regioncx, tcx, region_sub, context.loc) {\n-            Some(Cause::LiveVar(local, location)) => Liveness {\n-                local,\n-                location,\n-                in_loop: self.is_borrow_location_in_loop(context.loc),\n-            },\n-            Some(Cause::DropVar(local, location)) => DropLiveness {\n-                local,\n-                location,\n-            },\n-            None => OutlivesFreeRegion {\n-                outlived_region: regioncx.to_error_region(region_sub),\n-            },\n-        }\n-    }\n-\n-    /// Adds annotations to `err` for the explanation `reason`. This is a\n-    /// separate method so that the caller can change their error message based\n-    /// on the reason that is going to be reported.\n-    pub (in borrow_check) fn report_why_borrow_contains_point(\n-        &self,\n-        err: &mut DiagnosticBuilder,\n-        reason: BorrowContainsPointReason<'tcx>,\n-        kind_place: Option<(WriteKind, &Place<'tcx>)>,\n-    ) {\n-        use self::BorrowContainsPointReason::*;\n-\n-        debug!(\n-            \"find_why_borrow_contains_point(reason={:?}, kind_place={:?})\",\n-            reason, kind_place,\n-        );\n-\n-        let mir = self.mir;\n-\n-        match reason {\n-            Liveness { local, location, in_loop } => {\n+         match find_use::find(mir, regioncx, tcx, region_sub, context.loc) {\n+            Some(Cause::LiveVar(local, location)) => {\n                 let span = mir.source_info(location).span;\n                 let spans = self.move_spans(&Place::Local(local), location)\n                     .or_else(|| self.borrow_spans(span, location));\n-                let message = if in_loop {\n-                    if spans.for_closure() {\n-                        \"borrow captured here by closure in later iteration of loop\"\n-                    } else {\n-                        \"borrow used here in later iteration of loop\"\n-                    }\n+\n+                if self.is_borrow_location_in_loop(context.loc) {\n+                    BorrowExplanation::UsedLaterInLoop(spans.for_closure(), spans.var_or_use())\n                 } else {\n-                    if spans.for_closure() {\n-                        \"borrow later captured here by closure\"\n-                    } else {\n-                        // Check if the location represents a `FakeRead`, and adapt the error\n-                        // message to the `FakeReadCause` it is from: in particular,\n-                        // the ones inserted in optimized `let var = <expr>` patterns.\n-                        match self.retrieve_fake_read_cause_for_location(&location) {\n-                            Some(FakeReadCause::ForLet) => \"borrow later stored here\",\n-                            _ => \"borrow later used here\"\n-                        }\n-                    }\n-                };\n-                err.span_label(spans.var_or_use(), message);\n+                    // Check if the location represents a `FakeRead`, and adapt the error\n+                    // message to the `FakeReadCause` it is from: in particular,\n+                    // the ones inserted in optimized `let var = <expr>` patterns.\n+                    BorrowExplanation::UsedLater(\n+                        spans.for_closure(),\n+                        self.retrieve_fake_read_cause_for_location(&location),\n+                        spans.var_or_use()\n+                    )\n+                }\n             }\n-            DropLiveness { local, location } => match &mir.local_decls[local].name {\n-                Some(local_name) => {\n-                    err.span_label(\n-                        mir.source_info(location).span,\n-                        format!(\"borrow later used here, when `{}` is dropped\", local_name),\n-                    );\n \n+            Some(Cause::DropVar(local, location)) => match &mir.local_decls[local].name {\n+                Some(local_name) => {\n+                    let mut should_note_order = false;\n                     if let Some((WriteKind::StorageDeadOrDrop(_), place)) = kind_place {\n                         if let Place::Local(borrowed_local) = place {\n                             let dropped_local_scope = mir.local_decls[local].visibility_scope;\n                             let borrowed_local_scope =\n-                            mir.local_decls[*borrowed_local].visibility_scope;\n+                                mir.local_decls[*borrowed_local].visibility_scope;\n \n                             if mir.is_sub_scope(borrowed_local_scope, dropped_local_scope) {\n-                                err.note(\n-                                \"values in a scope are dropped \\\n-                                                     in the opposite order they are defined\",\n-                                );\n+                                should_note_order = true;\n                             }\n                         }\n                     }\n-                }\n \n-                None => {}\n-            }\n-            OutlivesFreeRegion { outlived_region: Some(region) } => {\n-                self.tcx.note_and_explain_free_region(\n-                    err,\n-                    \"borrowed value must be valid for \",\n-                    region,\n-                    \"...\",\n-                );\n-            }\n-            OutlivesFreeRegion { outlived_region: None } => (),\n+                    BorrowExplanation::UsedLaterWhenDropped(\n+                        mir.source_info(location).span,\n+                        *local_name,\n+                        should_note_order\n+                    )\n+                },\n+\n+                None => BorrowExplanation::Unexplained,\n+            },\n+\n+            None => if let Some(region) = regioncx.to_error_region(region_sub) {\n+                BorrowExplanation::MustBeValidFor(region)\n+            } else {\n+                BorrowExplanation::Unexplained\n+            },\n         }\n     }\n \n@@ -262,4 +245,3 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         false\n     }\n }\n-"}, {"sha": "31d7c7c631e1791f177d6996164b415ca7dc553b", "filename": "src/librustc_mir/borrow_check/nll/region_infer/error_reporting/mod.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f49f6e73a8a2dd6ec9f86df9922ccfa2210d9eda/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f49f6e73a8a2dd6ec9f86df9922ccfa2210d9eda/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs?ref=f49f6e73a8a2dd6ec9f86df9922ccfa2210d9eda", "patch": "@@ -339,10 +339,11 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         );\n \n         let counter = &mut 1;\n-        let fr_name = self.give_region_a_name(\n-            infcx, mir, mir_def_id, fr, counter, &mut diag);\n+        let fr_name = self.give_region_a_name(infcx, mir, mir_def_id, fr, counter);\n+        fr_name.highlight_region_name(&mut diag);\n         let outlived_fr_name = self.give_region_a_name(\n-            infcx, mir, mir_def_id, outlived_fr, counter, &mut diag);\n+            infcx, mir, mir_def_id, outlived_fr, counter);\n+        outlived_fr_name.highlight_region_name(&mut diag);\n \n         let mir_def_name = if infcx.tcx.is_closure(mir_def_id) { \"closure\" } else { \"function\" };\n \n@@ -430,10 +431,12 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                     // Otherwise, we should suggest adding a constraint on the return type.\n                     let span = infcx.tcx.def_span(*did);\n                     if let Ok(snippet) = infcx.tcx.sess.source_map().span_to_snippet(span) {\n-                        let suggestable_fr_name = match fr_name {\n-                            RegionName::Named(name) => format!(\"{}\", name),\n-                            RegionName::Synthesized(_) => \"'_\".to_string(),\n+                        let suggestable_fr_name = if fr_name.was_named() {\n+                            format!(\"{}\", fr_name)\n+                        } else {\n+                            \"'_\".to_string()\n                         };\n+\n                         diag.span_suggestion_with_applicability(\n                             span,\n                             &format!("}, {"sha": "be05e006608a26da38adaa291e9c7dbfb0cf68b9", "filename": "src/librustc_mir/borrow_check/nll/region_infer/error_reporting/region_name.rs", "status": "modified", "additions": 163, "deletions": 122, "changes": 285, "blob_url": "https://github.com/rust-lang/rust/blob/f49f6e73a8a2dd6ec9f86df9922ccfa2210d9eda/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f49f6e73a8a2dd6ec9f86df9922ccfa2210d9eda/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs?ref=f49f6e73a8a2dd6ec9f86df9922ccfa2210d9eda", "patch": "@@ -18,36 +18,109 @@ use rustc::infer::InferCtxt;\n use rustc::mir::Mir;\n use rustc::ty::subst::{Substs, UnpackedKind};\n use rustc::ty::{self, RegionKind, RegionVid, Ty, TyCtxt};\n-use rustc::util::ppaux::with_highlight_region;\n+use rustc::util::ppaux::with_highlight_region_for_regionvid;\n use rustc_errors::DiagnosticBuilder;\n use syntax::ast::{Name, DUMMY_NODE_ID};\n use syntax::symbol::keywords;\n use syntax_pos::Span;\n use syntax_pos::symbol::InternedString;\n \n-/// Name of a region used in error reporting. Variants denote the source of the region name -\n-/// whether it was synthesized for the error message and therefore should not be used in\n-/// suggestions; or whether it was found from the region.\n #[derive(Debug)]\n-pub(crate) enum RegionName {\n-    Named(InternedString),\n-    Synthesized(InternedString),\n+crate struct RegionName {\n+    name: InternedString,\n+    source: RegionNameSource,\n+}\n+\n+#[derive(Debug)]\n+crate enum RegionNameSource {\n+    NamedEarlyBoundRegion(Span),\n+    NamedFreeRegion(Span),\n+    Static,\n+    SynthesizedFreeEnvRegion(Span, String),\n+    CannotMatchHirTy(Span, String),\n+    MatchedHirTy(Span),\n+    MatchedAdtAndSegment(Span),\n+    AnonRegionFromUpvar(Span, String),\n+    AnonRegionFromOutput(Span, String, String),\n }\n \n impl RegionName {\n-    fn as_interned_string(&self) -> &InternedString {\n-        match self {\n-            RegionName::Named(name) | RegionName::Synthesized(name) => name,\n+    #[allow(dead_code)]\n+    crate fn was_named(&self) -> bool {\n+        match self.source {\n+            RegionNameSource::NamedEarlyBoundRegion(..) |\n+            RegionNameSource::NamedFreeRegion(..) |\n+            RegionNameSource::Static => true,\n+            RegionNameSource::SynthesizedFreeEnvRegion(..) |\n+            RegionNameSource::CannotMatchHirTy(..) |\n+            RegionNameSource::MatchedHirTy(..) |\n+            RegionNameSource::MatchedAdtAndSegment(..) |\n+            RegionNameSource::AnonRegionFromUpvar(..) |\n+            RegionNameSource::AnonRegionFromOutput(..) => false,\n+        }\n+    }\n+\n+    #[allow(dead_code)]\n+    crate fn was_synthesized(&self) -> bool {\n+        !self.was_named()\n+    }\n+\n+    #[allow(dead_code)]\n+    crate fn name(&self) -> &InternedString {\n+        &self.name\n+    }\n+\n+    crate fn highlight_region_name(\n+        &self,\n+        diag: &mut DiagnosticBuilder<'_>\n+    ) {\n+        match &self.source {\n+            RegionNameSource::NamedFreeRegion(span) |\n+            RegionNameSource::NamedEarlyBoundRegion(span) => {\n+                diag.span_label(\n+                    *span,\n+                    format!(\"lifetime `{}` defined here\", self),\n+                );\n+            },\n+            RegionNameSource::SynthesizedFreeEnvRegion(span, note) => {\n+                diag.span_label(\n+                    *span,\n+                    format!(\"lifetime `{}` represents this closure's body\", self),\n+                );\n+                diag.note(&note);\n+            },\n+            RegionNameSource::CannotMatchHirTy(span, type_name) => {\n+                diag.span_label(*span, format!(\"has type `{}`\", type_name));\n+            },\n+            RegionNameSource::MatchedHirTy(span) => {\n+                diag.span_label(\n+                    *span,\n+                    format!(\"let's call the lifetime of this reference `{}`\", self),\n+                );\n+            },\n+            RegionNameSource::MatchedAdtAndSegment(span) => {\n+                diag.span_label(*span, format!(\"let's call this `{}`\", self));\n+            },\n+            RegionNameSource::AnonRegionFromUpvar(span, upvar_name) => {\n+                diag.span_label(\n+                    *span,\n+                    format!(\"lifetime `{}` appears in the type of `{}`\", self, upvar_name),\n+                );\n+            },\n+            RegionNameSource::AnonRegionFromOutput(span, mir_description, type_name) => {\n+                diag.span_label(\n+                    *span,\n+                    format!(\"return type{} is {}\", mir_description, type_name),\n+                );\n+            },\n+            RegionNameSource::Static => {},\n         }\n     }\n }\n \n impl Display for RegionName {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        match self {\n-            RegionName::Named(name) | RegionName::Synthesized(name) =>\n-                write!(f, \"{}\", name),\n-        }\n+        write!(f, \"{}\", self.name)\n     }\n }\n \n@@ -84,26 +157,25 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         mir_def_id: DefId,\n         fr: RegionVid,\n         counter: &mut usize,\n-        diag: &mut DiagnosticBuilder,\n     ) -> RegionName {\n         debug!(\"give_region_a_name(fr={:?}, counter={})\", fr, counter);\n \n         assert!(self.universal_regions.is_universal_region(fr));\n \n-        let value = self.give_name_from_error_region(infcx.tcx, mir_def_id, fr, counter, diag)\n+        let value = self.give_name_from_error_region(infcx.tcx, mir_def_id, fr, counter)\n             .or_else(|| {\n                 self.give_name_if_anonymous_region_appears_in_arguments(\n-                    infcx, mir, mir_def_id, fr, counter, diag,\n+                    infcx, mir, mir_def_id, fr, counter,\n                 )\n             })\n             .or_else(|| {\n                 self.give_name_if_anonymous_region_appears_in_upvars(\n-                    infcx.tcx, mir, fr, counter, diag,\n+                    infcx.tcx, mir, fr, counter,\n                 )\n             })\n             .or_else(|| {\n                 self.give_name_if_anonymous_region_appears_in_output(\n-                    infcx, mir, mir_def_id, fr, counter, diag,\n+                    infcx, mir, mir_def_id, fr, counter,\n                 )\n             })\n             .unwrap_or_else(|| span_bug!(mir.span, \"can't make a name for free region {:?}\", fr));\n@@ -122,31 +194,35 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         mir_def_id: DefId,\n         fr: RegionVid,\n         counter: &mut usize,\n-        diag: &mut DiagnosticBuilder<'_>,\n     ) -> Option<RegionName> {\n         let error_region = self.to_error_region(fr)?;\n \n         debug!(\"give_region_a_name: error_region = {:?}\", error_region);\n         match error_region {\n             ty::ReEarlyBound(ebr) => {\n                 if ebr.has_name() {\n-                    let name = RegionName::Named(ebr.name);\n-                    self.highlight_named_span(tcx, error_region, &name, diag);\n-                    Some(name)\n+                    let span = self.get_named_span(tcx, error_region, &ebr.name);\n+                    Some(RegionName {\n+                        name: ebr.name,\n+                        source: RegionNameSource::NamedEarlyBoundRegion(span)\n+                    })\n                 } else {\n                     None\n                 }\n             }\n \n-            ty::ReStatic => Some(RegionName::Named(\n-                keywords::StaticLifetime.name().as_interned_str()\n-            )),\n+            ty::ReStatic => Some(RegionName {\n+                name: keywords::StaticLifetime.name().as_interned_str(),\n+                source: RegionNameSource::Static\n+            }),\n \n             ty::ReFree(free_region) => match free_region.bound_region {\n                 ty::BoundRegion::BrNamed(_, name) => {\n-                    let name = RegionName::Named(name);\n-                    self.highlight_named_span(tcx, error_region, &name, diag);\n-                    Some(name)\n+                    let span = self.get_named_span(tcx, error_region, &name);\n+                    Some(RegionName {\n+                        name,\n+                        source: RegionNameSource::NamedFreeRegion(span),\n+                    })\n                 },\n \n                 ty::BoundRegion::BrEnv => {\n@@ -162,13 +238,6 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                             bug!(\"Closure is not defined by a closure expr\");\n                         };\n                         let region_name = self.synthesize_region_name(counter);\n-                        diag.span_label(\n-                            args_span,\n-                            format!(\n-                                \"lifetime `{}` represents this closure's body\",\n-                                region_name\n-                            ),\n-                        );\n \n                         let closure_kind_ty = substs.closure_kind_ty(def_id, tcx);\n                         let note = match closure_kind_ty.to_opt_closure_kind() {\n@@ -186,9 +255,13 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                             None => bug!(\"Closure kind not inferred in borrow check\"),\n                         };\n \n-                        diag.note(note);\n-\n-                        Some(region_name)\n+                        Some(RegionName {\n+                            name: region_name,\n+                            source: RegionNameSource::SynthesizedFreeEnvRegion(\n+                                args_span,\n+                                note.to_string()\n+                            ),\n+                        })\n                     } else {\n                         // Can't have BrEnv in functions, constants or generators.\n                         bug!(\"BrEnv outside of closure.\");\n@@ -209,27 +282,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         }\n     }\n \n-    /// Get the span of a named region.\n-    pub(super) fn get_span_of_named_region(\n-        &self,\n-        tcx: TyCtxt<'_, '_, 'tcx>,\n-        error_region: &RegionKind,\n-        name: &RegionName,\n-    ) -> Span {\n-        let scope = error_region.free_region_binding_scope(tcx);\n-        let node = tcx.hir.as_local_node_id(scope).unwrap_or(DUMMY_NODE_ID);\n-\n-        let span = tcx.sess.source_map().def_span(tcx.hir.span(node));\n-        if let Some(param) = tcx.hir.get_generics(scope).and_then(|generics| {\n-            generics.get_named(name.as_interned_string())\n-        }) {\n-            param.span\n-        } else {\n-            span\n-        }\n-    }\n-\n-    /// Highlight a named span to provide context for error messages that\n+    /// Get a span of a named region to provide context for error messages that\n     /// mention that span, for example:\n     ///\n     /// ```\n@@ -243,19 +296,24 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     ///  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ argument requires that `'b` must\n     ///  |                                                         outlive `'a`\n     /// ```\n-    fn highlight_named_span(\n+    fn get_named_span(\n         &self,\n         tcx: TyCtxt<'_, '_, 'tcx>,\n         error_region: &RegionKind,\n-        name: &RegionName,\n-        diag: &mut DiagnosticBuilder<'_>,\n-    ) {\n-        let span = self.get_span_of_named_region(tcx, error_region, name);\n+        name: &InternedString,\n+    ) -> Span {\n+        let scope = error_region.free_region_binding_scope(tcx);\n+        let node = tcx.hir.as_local_node_id(scope).unwrap_or(DUMMY_NODE_ID);\n \n-        diag.span_label(\n-            span,\n-            format!(\"lifetime `{}` defined here\", name),\n-        );\n+        let span = tcx.sess.source_map().def_span(tcx.hir.span(node));\n+        if let Some(param) = tcx.hir\n+            .get_generics(scope)\n+            .and_then(|generics| generics.get_named(name))\n+        {\n+            param.span\n+        } else {\n+            span\n+        }\n     }\n \n     /// Find an argument that contains `fr` and label it with a fully\n@@ -273,7 +331,6 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         mir_def_id: DefId,\n         fr: RegionVid,\n         counter: &mut usize,\n-        diag: &mut DiagnosticBuilder<'_>,\n     ) -> Option<RegionName> {\n         let implicit_inputs = self.universal_regions.defining_ty.implicit_inputs();\n         let argument_index = self.get_argument_index_for_region(infcx.tcx, fr)?;\n@@ -288,12 +345,11 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             arg_ty,\n             argument_index,\n             counter,\n-            diag,\n         ) {\n             return Some(region_name);\n         }\n \n-        self.give_name_if_we_cannot_match_hir_ty(infcx, mir, fr, arg_ty, counter, diag)\n+        self.give_name_if_we_cannot_match_hir_ty(infcx, mir, fr, arg_ty, counter)\n     }\n \n     fn give_name_if_we_can_match_hir_ty_from_argument(\n@@ -305,7 +361,6 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         argument_ty: Ty<'tcx>,\n         argument_index: usize,\n         counter: &mut usize,\n-        diag: &mut DiagnosticBuilder<'_>,\n     ) -> Option<RegionName> {\n         let mir_node_id = infcx.tcx.hir.as_local_node_id(mir_def_id)?;\n         let fn_decl = infcx.tcx.hir.fn_decl(mir_node_id)?;\n@@ -320,7 +375,6 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 needle_fr,\n                 argument_ty,\n                 counter,\n-                diag,\n             ),\n \n             _ => self.give_name_if_we_can_match_hir_ty(\n@@ -329,7 +383,6 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 argument_ty,\n                 argument_hir_ty,\n                 counter,\n-                diag,\n             ),\n         }\n     }\n@@ -352,9 +405,8 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         needle_fr: RegionVid,\n         argument_ty: Ty<'tcx>,\n         counter: &mut usize,\n-        diag: &mut DiagnosticBuilder<'_>,\n     ) -> Option<RegionName> {\n-        let type_name = with_highlight_region(needle_fr, *counter, || {\n+        let type_name = with_highlight_region_for_regionvid(needle_fr, *counter, || {\n             infcx.extract_type_name(&argument_ty)\n         });\n \n@@ -366,12 +418,14 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             // Only add a label if we can confirm that a region was labelled.\n             let argument_index = self.get_argument_index_for_region(infcx.tcx, needle_fr)?;\n             let (_, span) = self.get_argument_name_and_span_for_region(mir, argument_index);\n-            diag.span_label(span, format!(\"has type `{}`\", type_name));\n \n-            // This counter value will already have been used, so this function will increment it\n-            // so the next value will be used next and return the region name that would have been\n-            // used.\n-            Some(self.synthesize_region_name(counter))\n+            Some(RegionName {\n+                // This counter value will already have been used, so this function will increment\n+                // it so the next value will be used next and return the region name that would\n+                // have been used.\n+                name: self.synthesize_region_name(counter),\n+                source: RegionNameSource::CannotMatchHirTy(span, type_name),\n+            })\n         } else {\n             None\n         };\n@@ -407,7 +461,6 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         argument_ty: Ty<'tcx>,\n         argument_hir_ty: &hir::Ty,\n         counter: &mut usize,\n-        diag: &mut DiagnosticBuilder<'_>,\n     ) -> Option<RegionName> {\n         let search_stack: &mut Vec<(Ty<'tcx>, &hir::Ty)> = &mut Vec::new();\n \n@@ -432,15 +485,10 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                         let source_map = tcx.sess.source_map();\n                         let ampersand_span = source_map.start_point(hir_ty.span);\n \n-                        diag.span_label(\n-                            ampersand_span,\n-                            format!(\n-                                \"let's call the lifetime of this reference `{}`\",\n-                                region_name\n-                            ),\n-                        );\n-\n-                        return Some(region_name);\n+                        return Some(RegionName {\n+                            name: region_name,\n+                            source: RegionNameSource::MatchedHirTy(ampersand_span),\n+                        });\n                     }\n \n                     // Otherwise, let's descend into the referent types.\n@@ -464,7 +512,6 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                                 needle_fr,\n                                 last_segment,\n                                 counter,\n-                                diag,\n                                 search_stack,\n                             ) {\n                                 return Some(name);\n@@ -509,7 +556,6 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         needle_fr: RegionVid,\n         last_segment: &'hir hir::PathSegment,\n         counter: &mut usize,\n-        diag: &mut DiagnosticBuilder<'_>,\n         search_stack: &mut Vec<(Ty<'tcx>, &'hir hir::Ty)>,\n     ) -> Option<RegionName> {\n         // Did the user give explicit arguments? (e.g., `Foo<..>`)\n@@ -521,11 +567,10 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             | hir::LifetimeName::Underscore => {\n                 let region_name = self.synthesize_region_name(counter);\n                 let ampersand_span = lifetime.span;\n-                diag.span_label(\n-                    ampersand_span,\n-                    format!(\"let's call this `{}`\", region_name)\n-                );\n-                return Some(region_name);\n+                return Some(RegionName {\n+                    name: region_name,\n+                    source: RegionNameSource::MatchedAdtAndSegment(ampersand_span),\n+                });\n             }\n \n             hir::LifetimeName::Implicit => {\n@@ -600,22 +645,16 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         mir: &Mir<'tcx>,\n         fr: RegionVid,\n         counter: &mut usize,\n-        diag: &mut DiagnosticBuilder<'_>,\n     ) -> Option<RegionName> {\n         let upvar_index = self.get_upvar_index_for_region(tcx, fr)?;\n         let (upvar_name, upvar_span) =\n             self.get_upvar_name_and_span_for_region(tcx, mir, upvar_index);\n         let region_name = self.synthesize_region_name(counter);\n \n-        diag.span_label(\n-            upvar_span,\n-            format!(\n-                \"lifetime `{}` appears in the type of `{}`\",\n-                region_name, upvar_name\n-            ),\n-        );\n-\n-        Some(region_name)\n+        Some(RegionName {\n+            name: region_name,\n+            source: RegionNameSource::AnonRegionFromUpvar(upvar_span, upvar_name.to_string()),\n+        })\n     }\n \n     /// Check for arguments appearing in the (closure) return type. It\n@@ -629,7 +668,6 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         mir_def_id: DefId,\n         fr: RegionVid,\n         counter: &mut usize,\n-        diag: &mut DiagnosticBuilder<'_>,\n     ) -> Option<RegionName> {\n         let tcx = infcx.tcx;\n \n@@ -645,7 +683,8 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             return None;\n         }\n \n-        let type_name = with_highlight_region(fr, *counter, || infcx.extract_type_name(&return_ty));\n+        let type_name = with_highlight_region_for_regionvid(\n+            fr, *counter, || infcx.extract_type_name(&return_ty));\n \n         let mir_node_id = tcx.hir.as_local_node_id(mir_def_id).expect(\"non-local mir\");\n \n@@ -666,23 +705,25 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 (mir.span, \"\")\n             };\n \n-        diag.span_label(\n-            return_span,\n-            format!(\"return type{} is {}\", mir_description, type_name),\n-        );\n-\n-        // This counter value will already have been used, so this function will increment it\n-        // so the next value will be used next and return the region name that would have been\n-        // used.\n-        Some(self.synthesize_region_name(counter))\n+        Some(RegionName {\n+            // This counter value will already have been used, so this function will increment it\n+            // so the next value will be used next and return the region name that would have been\n+            // used.\n+            name: self.synthesize_region_name(counter),\n+            source: RegionNameSource::AnonRegionFromOutput(\n+                return_span,\n+                mir_description.to_string(),\n+                type_name\n+            ),\n+        })\n     }\n \n     /// Create a synthetic region named `'1`, incrementing the\n     /// counter.\n-    fn synthesize_region_name(&self, counter: &mut usize) -> RegionName {\n+    fn synthesize_region_name(&self, counter: &mut usize) -> InternedString {\n         let c = *counter;\n         *counter += 1;\n \n-        RegionName::Synthesized(Name::intern(&format!(\"'{:?}\", c)).as_interned_str())\n+        Name::intern(&format!(\"'{:?}\", c)).as_interned_str()\n     }\n }"}, {"sha": "f73e08eb13521120b0266e9819d22633f8ea134c", "filename": "src/librustc_mir/borrow_check/prefixes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f49f6e73a8a2dd6ec9f86df9922ccfa2210d9eda/src%2Flibrustc_mir%2Fborrow_check%2Fprefixes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f49f6e73a8a2dd6ec9f86df9922ccfa2210d9eda/src%2Flibrustc_mir%2Fborrow_check%2Fprefixes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fprefixes.rs?ref=f49f6e73a8a2dd6ec9f86df9922ccfa2210d9eda", "patch": "@@ -79,7 +79,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             next: Some(place),\n             kind,\n             mir: self.mir,\n-            tcx: self.tcx,\n+            tcx: self.infcx.tcx,\n         }\n     }\n }"}, {"sha": "d6cbe47a66efd18abc938f697b546f269416ea49", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f49f6e73a8a2dd6ec9f86df9922ccfa2210d9eda/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f49f6e73a8a2dd6ec9f86df9922ccfa2210d9eda/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=f49f6e73a8a2dd6ec9f86df9922ccfa2210d9eda", "patch": "@@ -1848,7 +1848,7 @@ impl<'a> Parser<'a> {\n             P(Ty {\n                 id: ast::DUMMY_NODE_ID,\n                 node: TyKind::Infer,\n-                span: self.span,\n+                span: self.prev_span,\n             })\n         };\n         Ok(Arg {"}, {"sha": "3d2c95013ab0fba127fc513c6beed6eea3d10372", "filename": "src/test/ui/issues/issue-30438-c.nll.stderr", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/f49f6e73a8a2dd6ec9f86df9922ccfa2210d9eda/src%2Ftest%2Fui%2Fissues%2Fissue-30438-c.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f49f6e73a8a2dd6ec9f86df9922ccfa2210d9eda/src%2Ftest%2Fui%2Fissues%2Fissue-30438-c.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-30438-c.nll.stderr?ref=f49f6e73a8a2dd6ec9f86df9922ccfa2210d9eda", "patch": "@@ -1,17 +1,20 @@\n error[E0597]: `x` does not live long enough\n   --> $DIR/issue-30438-c.rs:19:5\n    |\n+LL | fn silly<'y, 'z>(_s: &'y Test<'z>) -> &'y <Test<'z> as Trait>::Out where 'z: 'static {\n+   |                       --               -- also has lifetime `'y`\n+   |                       |\n+   |                       has lifetime `'y`\n+LL |     let x = Test { s: \"this cannot last\" };\n LL |     &x\n-   |     ^^ borrowed value does not live long enough\n+   |     ^^ `x` would have to be valid for `'y`...\n LL |     //~^ ERROR: `x` does not live long enough\n LL | }\n-   | - `x` dropped here while still borrowed\n-   |\n-note: borrowed value must be valid for the lifetime 'y as defined on the function body at 17:10...\n-  --> $DIR/issue-30438-c.rs:17:10\n+   | - ...but `x` will be dropped here, when the function `silly` returns\n    |\n-LL | fn silly<'y, 'z>(_s: &'y Test<'z>) -> &'y <Test<'z> as Trait>::Out where 'z: 'static {\n-   |          ^^\n+   = help: use data from the highlighted arguments which match the `'y` lifetime of the return type\n+   = note: functions cannot return a borrow to data owned within the function's scope, functions can only return borrows to data passed as arguments\n+   = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch04-02-references-and-borrowing.html#dangling-references>\n \n error: aborting due to previous error\n "}, {"sha": "c35a14ca70443a97a8ad07e1ae3b34cbadd08d49", "filename": "src/test/ui/nll/borrowed-universal-error-2.stderr", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/f49f6e73a8a2dd6ec9f86df9922ccfa2210d9eda/src%2Ftest%2Fui%2Fnll%2Fborrowed-universal-error-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f49f6e73a8a2dd6ec9f86df9922ccfa2210d9eda/src%2Ftest%2Fui%2Fnll%2Fborrowed-universal-error-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fborrowed-universal-error-2.stderr?ref=f49f6e73a8a2dd6ec9f86df9922ccfa2210d9eda", "patch": "@@ -1,17 +1,20 @@\n error[E0597]: `v` does not live long enough\n   --> $DIR/borrowed-universal-error-2.rs:16:5\n    |\n+LL | fn foo<'a>(x: &'a (u32,)) -> &'a u32 {\n+   |                --             -- also has lifetime `'a`\n+   |                |\n+   |                has lifetime `'a`\n+LL |     let v = 22;\n LL |     &v\n-   |     ^^ borrowed value does not live long enough\n+   |     ^^ `v` would have to be valid for `'a`...\n LL |     //~^ ERROR `v` does not live long enough [E0597]\n LL | }\n-   | - `v` dropped here while still borrowed\n-   |\n-note: borrowed value must be valid for the lifetime 'a as defined on the function body at 14:8...\n-  --> $DIR/borrowed-universal-error-2.rs:14:8\n+   | - ...but `v` will be dropped here, when the function `foo` returns\n    |\n-LL | fn foo<'a>(x: &'a (u32,)) -> &'a u32 {\n-   |        ^^\n+   = help: use data from the highlighted arguments which match the `'a` lifetime of the return type\n+   = note: functions cannot return a borrow to data owned within the function's scope, functions can only return borrows to data passed as arguments\n+   = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch04-02-references-and-borrowing.html#dangling-references>\n \n error: aborting due to previous error\n "}, {"sha": "cd6c10335ccc672badcccdd47faee72e81f3b6c5", "filename": "src/test/ui/nll/issue-52534-1.rs", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/f49f6e73a8a2dd6ec9f86df9922ccfa2210d9eda/src%2Ftest%2Fui%2Fnll%2Fissue-52534-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f49f6e73a8a2dd6ec9f86df9922ccfa2210d9eda/src%2Ftest%2Fui%2Fnll%2Fissue-52534-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-52534-1.rs?ref=f49f6e73a8a2dd6ec9f86df9922ccfa2210d9eda", "patch": "@@ -0,0 +1,53 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(nll)]\n+#![allow(warnings)]\n+\n+struct Test;\n+\n+impl Test {\n+    fn bar(&self, x: &u32) -> &u32 {\n+        let x = 22;\n+        &x\n+    }\n+}\n+\n+fn foo(x: &u32) -> &u32 {\n+    let x = 22;\n+    &x\n+}\n+\n+fn baz(x: &u32) -> &&u32 {\n+    let x = 22;\n+    &&x\n+}\n+\n+fn foobazbar<'a>(x: u32, y: &'a u32) -> &'a u32 {\n+    let x = 22;\n+    &x\n+}\n+\n+fn foobar<'a>(x: &'a u32) -> &'a u32 {\n+    let x = 22;\n+    &x\n+}\n+\n+fn foobaz<'a, 'b>(x: &'a u32, y: &'b u32) -> &'a u32 {\n+    let x = 22;\n+    &x\n+}\n+\n+fn foobarbaz<'a, 'b>(x: &'a u32, y: &'b u32, z: &'a u32) -> &'a u32 {\n+    let x = 22;\n+    &x\n+}\n+\n+fn main() { }"}, {"sha": "e2f8134e3be0e055312ca38b506b806f26c44144", "filename": "src/test/ui/nll/issue-52534-1.stderr", "status": "added", "additions": 140, "deletions": 0, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/f49f6e73a8a2dd6ec9f86df9922ccfa2210d9eda/src%2Ftest%2Fui%2Fnll%2Fissue-52534-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f49f6e73a8a2dd6ec9f86df9922ccfa2210d9eda/src%2Ftest%2Fui%2Fnll%2Fissue-52534-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-52534-1.stderr?ref=f49f6e73a8a2dd6ec9f86df9922ccfa2210d9eda", "patch": "@@ -0,0 +1,140 @@\n+error[E0597]: `x` does not live long enough\n+  --> $DIR/issue-52534-1.rs:19:9\n+   |\n+LL |     fn bar(&self, x: &u32) -> &u32 {\n+   |            -----              ---- has type `&'0 u32`\n+   |            |\n+   |            has type `&'0 Test`\n+LL |         let x = 22;\n+LL |         &x\n+   |         ^^ `x` would have to be valid for `'0`...\n+LL |     }\n+   |     - ...but `x` will be dropped here, when the function `bar` returns\n+   |\n+   = note: argument and return type have the same lifetime due to lifetime elision rules\n+   = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch10-03-lifetime-syntax.html#lifetime-elision>\n+   = note: functions cannot return a borrow to data owned within the function's scope, functions can only return borrows to data passed as arguments\n+   = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch04-02-references-and-borrowing.html#dangling-references>\n+\n+error[E0597]: `x` does not live long enough\n+  --> $DIR/issue-52534-1.rs:25:5\n+   |\n+LL | fn foo(x: &u32) -> &u32 {\n+   |           ----     ---- also has type `&'0 u32`\n+   |           |\n+   |           has type `&'0 u32`\n+LL |     let x = 22;\n+LL |     &x\n+   |     ^^ `x` would have to be valid for `'0`...\n+LL | }\n+   | - ...but `x` will be dropped here, when the function `foo` returns\n+   |\n+   = note: argument and return type have the same lifetime due to lifetime elision rules\n+   = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch10-03-lifetime-syntax.html#lifetime-elision>\n+   = note: functions cannot return a borrow to data owned within the function's scope, functions can only return borrows to data passed as arguments\n+   = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch04-02-references-and-borrowing.html#dangling-references>\n+\n+error[E0597]: `x` does not live long enough\n+  --> $DIR/issue-52534-1.rs:30:6\n+   |\n+LL | fn baz(x: &u32) -> &&u32 {\n+   |           ----     ----- has type `&'0 &'0 u32`\n+   |           |\n+   |           has type `&'0 u32`\n+LL |     let x = 22;\n+LL |     &&x\n+   |      ^^ `x` would have to be valid for `'0`...\n+LL | }\n+   | - ...but `x` will be dropped here, when the function `baz` returns\n+   |\n+   = note: argument and return type have the same lifetime due to lifetime elision rules\n+   = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch10-03-lifetime-syntax.html#lifetime-elision>\n+   = note: functions cannot return a borrow to data owned within the function's scope, functions can only return borrows to data passed as arguments\n+   = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch04-02-references-and-borrowing.html#dangling-references>\n+\n+error[E0597]: borrowed value does not live long enough\n+  --> $DIR/issue-52534-1.rs:30:6\n+   |\n+LL |     &&x\n+   |      ^^ temporary value does not live long enough\n+LL | }\n+   | - temporary value only lives until here\n+   |\n+note: borrowed value must be valid for the anonymous lifetime #1 defined on the function body at 28:1...\n+  --> $DIR/issue-52534-1.rs:28:1\n+   |\n+LL | / fn baz(x: &u32) -> &&u32 {\n+LL | |     let x = 22;\n+LL | |     &&x\n+LL | | }\n+   | |_^\n+\n+error[E0597]: `x` does not live long enough\n+  --> $DIR/issue-52534-1.rs:35:5\n+   |\n+LL | fn foobazbar<'a>(x: u32, y: &'a u32) -> &'a u32 {\n+   |                              --          -- also has lifetime `'a`\n+   |                              |\n+   |                              has lifetime `'a`\n+LL |     let x = 22;\n+LL |     &x\n+   |     ^^ `x` would have to be valid for `'a`...\n+LL | }\n+   | - ...but `x` will be dropped here, when the function `foobazbar` returns\n+   |\n+   = help: use data from the highlighted arguments which match the `'a` lifetime of the return type\n+   = note: functions cannot return a borrow to data owned within the function's scope, functions can only return borrows to data passed as arguments\n+   = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch04-02-references-and-borrowing.html#dangling-references>\n+\n+error[E0597]: `x` does not live long enough\n+  --> $DIR/issue-52534-1.rs:40:5\n+   |\n+LL | fn foobar<'a>(x: &'a u32) -> &'a u32 {\n+   |                   --          -- also has lifetime `'a`\n+   |                   |\n+   |                   has lifetime `'a`\n+LL |     let x = 22;\n+LL |     &x\n+   |     ^^ `x` would have to be valid for `'a`...\n+LL | }\n+   | - ...but `x` will be dropped here, when the function `foobar` returns\n+   |\n+   = help: use data from the highlighted arguments which match the `'a` lifetime of the return type\n+   = note: functions cannot return a borrow to data owned within the function's scope, functions can only return borrows to data passed as arguments\n+   = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch04-02-references-and-borrowing.html#dangling-references>\n+\n+error[E0597]: `x` does not live long enough\n+  --> $DIR/issue-52534-1.rs:45:5\n+   |\n+LL | fn foobaz<'a, 'b>(x: &'a u32, y: &'b u32) -> &'a u32 {\n+   |                       -- has lifetime `'a`    -- also has lifetime `'a`\n+LL |     let x = 22;\n+LL |     &x\n+   |     ^^ `x` would have to be valid for `'a`...\n+LL | }\n+   | - ...but `x` will be dropped here, when the function `foobaz` returns\n+   |\n+   = help: use data from the highlighted arguments which match the `'a` lifetime of the return type\n+   = note: functions cannot return a borrow to data owned within the function's scope, functions can only return borrows to data passed as arguments\n+   = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch04-02-references-and-borrowing.html#dangling-references>\n+\n+error[E0597]: `x` does not live long enough\n+  --> $DIR/issue-52534-1.rs:50:5\n+   |\n+LL | fn foobarbaz<'a, 'b>(x: &'a u32, y: &'b u32, z: &'a u32) -> &'a u32 {\n+   |                          --                      --          -- also has lifetime `'a`\n+   |                          |                       |\n+   |                          has lifetime `'a`       has lifetime `'a`\n+LL |     let x = 22;\n+LL |     &x\n+   |     ^^ `x` would have to be valid for `'a`...\n+LL | }\n+   | - ...but `x` will be dropped here, when the function `foobarbaz` returns\n+   |\n+   = help: use data from the highlighted arguments which match the `'a` lifetime of the return type\n+   = note: functions cannot return a borrow to data owned within the function's scope, functions can only return borrows to data passed as arguments\n+   = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch04-02-references-and-borrowing.html#dangling-references>\n+\n+error: aborting due to 8 previous errors\n+\n+For more information about this error, try `rustc --explain E0597`."}, {"sha": "4eac6feac0d9cea7fa2d09e2f98bd04af87010af", "filename": "src/test/ui/nll/issue-52534-2.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/f49f6e73a8a2dd6ec9f86df9922ccfa2210d9eda/src%2Ftest%2Fui%2Fnll%2Fissue-52534-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f49f6e73a8a2dd6ec9f86df9922ccfa2210d9eda/src%2Ftest%2Fui%2Fnll%2Fissue-52534-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-52534-2.rs?ref=f49f6e73a8a2dd6ec9f86df9922ccfa2210d9eda", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(nll)]\n+#![allow(warnings)]\n+\n+fn foo(x: &u32) -> &u32 {\n+    let y;\n+\n+    {\n+        let x = 32;\n+        y = &x\n+    }\n+\n+    println!(\"{}\", y);\n+    x\n+}\n+\n+fn main() { }"}, {"sha": "51cd7c7bf3b40a46a21671e6bdcdbca2c5e5c790", "filename": "src/test/ui/nll/issue-52534-2.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f49f6e73a8a2dd6ec9f86df9922ccfa2210d9eda/src%2Ftest%2Fui%2Fnll%2Fissue-52534-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f49f6e73a8a2dd6ec9f86df9922ccfa2210d9eda/src%2Ftest%2Fui%2Fnll%2Fissue-52534-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-52534-2.stderr?ref=f49f6e73a8a2dd6ec9f86df9922ccfa2210d9eda", "patch": "@@ -0,0 +1,14 @@\n+error[E0597]: `x` does not live long enough\n+  --> $DIR/issue-52534-2.rs:19:9\n+   |\n+LL |         y = &x\n+   |         ^^^^^^ borrowed value does not live long enough\n+LL |     }\n+   |     - `x` dropped here while still borrowed\n+LL | \n+LL |     println!(\"{}\", y);\n+   |                    - borrow later used here\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0597`."}, {"sha": "273c9b3c8020c9121b235cb82d6e4badf01d269c", "filename": "src/test/ui/nll/issue-52534.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/f49f6e73a8a2dd6ec9f86df9922ccfa2210d9eda/src%2Ftest%2Fui%2Fnll%2Fissue-52534.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f49f6e73a8a2dd6ec9f86df9922ccfa2210d9eda/src%2Ftest%2Fui%2Fnll%2Fissue-52534.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-52534.rs?ref=f49f6e73a8a2dd6ec9f86df9922ccfa2210d9eda", "patch": "@@ -0,0 +1,30 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(nll)]\n+#![allow(warnings)]\n+\n+fn foo(_: impl FnOnce(&u32) -> &u32) {\n+}\n+\n+fn baz(_: impl FnOnce(&u32, u32) -> &u32) {\n+}\n+\n+fn bar() {\n+    let x = 22;\n+    foo(|a| &x)\n+}\n+\n+fn foobar() {\n+    let y = 22;\n+    baz(|first, second| &y)\n+}\n+\n+fn main() { }"}, {"sha": "00d72546ebc4c66fa94d1426ed8c4732cb652122", "filename": "src/test/ui/nll/issue-52534.stderr", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/f49f6e73a8a2dd6ec9f86df9922ccfa2210d9eda/src%2Ftest%2Fui%2Fnll%2Fissue-52534.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f49f6e73a8a2dd6ec9f86df9922ccfa2210d9eda/src%2Ftest%2Fui%2Fnll%2Fissue-52534.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-52534.stderr?ref=f49f6e73a8a2dd6ec9f86df9922ccfa2210d9eda", "patch": "@@ -0,0 +1,29 @@\n+error[E0597]: `x` does not live long enough\n+  --> $DIR/issue-52534.rs:22:14\n+   |\n+LL |     foo(|a| &x)\n+   |          -   ^ `x` would have to be valid for `'0`...\n+   |          |\n+   |          has type `&'0 u32`\n+LL | }\n+   | - ...but `x` will be dropped here, when the function `bar` returns\n+   |\n+   = note: functions cannot return a borrow to data owned within the function's scope, functions can only return borrows to data passed as arguments\n+   = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch04-02-references-and-borrowing.html#dangling-references>\n+\n+error[E0597]: `y` does not live long enough\n+  --> $DIR/issue-52534.rs:27:26\n+   |\n+LL |     baz(|first, second| &y)\n+   |          -----           ^ `y` would have to be valid for `'0`...\n+   |          |\n+   |          has type `&'0 u32`\n+LL | }\n+   | - ...but `y` will be dropped here, when the function `foobar` returns\n+   |\n+   = note: functions cannot return a borrow to data owned within the function's scope, functions can only return borrows to data passed as arguments\n+   = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch04-02-references-and-borrowing.html#dangling-references>\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0597`."}]}