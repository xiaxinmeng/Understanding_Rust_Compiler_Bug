{"sha": "8eb4fc60579cc2138adbf6eaeb86ccfeefc81713", "node_id": "C_kwDOAAsO6NoAKDhlYjRmYzYwNTc5Y2MyMTM4YWRiZjZlYWViODZjY2ZlZWZjODE3MTM", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-05-27T03:15:08Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-05-27T03:15:08Z"}, "message": "Rollup merge of #97066 - petrochenkov:nofragkind, r=camelid\n\nrustdoc: Remove `ItemFragment(Kind)`\n\nAnd stop using `write!` when rendering URL fragments to avoid impossible errors.", "tree": {"sha": "a2085cf28dc86bf153f1c96bec3830adb81d5475", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a2085cf28dc86bf153f1c96bec3830adb81d5475"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8eb4fc60579cc2138adbf6eaeb86ccfeefc81713", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJikEI8CRBK7hj4Ov3rIwAAHYUIAFArkqiB2L3yighBdHTSuu1E\ni2A51Vdtosr1RLjalVZ02IU4OQytATFM6vGy345KHPjfSH21XQoBpsU3CNHPeQwu\n5PoqIkw7X01C+VnrhV7yrBH3v8X6vWIAiI9AvsR5WLK0b8k3MfR/4c+ZW290QtLA\nGjsn7qbKPClID95W2SWWJ2zfXe3QHV1KSTRLdEf25uuR9f0lCMQt6EorspFJYVak\nwD1LerrwSLT+Kw44q7c67TEmvNdHVhxpqN5nqMMiJyIK7ZTR8FmHsre3BtNTQQbt\nSK9CeBrfUimqOfSZix5daMYHoGtK+ljU64fPGsGUd+WhMs6NpaHTRM2vonRWvnA=\n=stbt\n-----END PGP SIGNATURE-----\n", "payload": "tree a2085cf28dc86bf153f1c96bec3830adb81d5475\nparent e3813e46a26af1534bef47f257e57bd908fbb3ce\nparent 3f21c31bf4f3ebab5e982a2cff8befbf1763294b\nauthor Michael Goulet <michael@errs.io> 1653621308 -0700\ncommitter GitHub <noreply@github.com> 1653621308 -0700\n\nRollup merge of #97066 - petrochenkov:nofragkind, r=camelid\n\nrustdoc: Remove `ItemFragment(Kind)`\n\nAnd stop using `write!` when rendering URL fragments to avoid impossible errors.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8eb4fc60579cc2138adbf6eaeb86ccfeefc81713", "html_url": "https://github.com/rust-lang/rust/commit/8eb4fc60579cc2138adbf6eaeb86ccfeefc81713", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8eb4fc60579cc2138adbf6eaeb86ccfeefc81713/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e3813e46a26af1534bef47f257e57bd908fbb3ce", "url": "https://api.github.com/repos/rust-lang/rust/commits/e3813e46a26af1534bef47f257e57bd908fbb3ce", "html_url": "https://github.com/rust-lang/rust/commit/e3813e46a26af1534bef47f257e57bd908fbb3ce"}, {"sha": "3f21c31bf4f3ebab5e982a2cff8befbf1763294b", "url": "https://api.github.com/repos/rust-lang/rust/commits/3f21c31bf4f3ebab5e982a2cff8befbf1763294b", "html_url": "https://github.com/rust-lang/rust/commit/3f21c31bf4f3ebab5e982a2cff8befbf1763294b"}], "stats": {"total": 167, "additions": 53, "deletions": 114}, "files": [{"sha": "99b4eacedc222665045c95954e11ed9137c7659c", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8eb4fc60579cc2138adbf6eaeb86ccfeefc81713/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8eb4fc60579cc2138adbf6eaeb86ccfeefc81713/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=8eb4fc60579cc2138adbf6eaeb86ccfeefc81713", "patch": "@@ -525,7 +525,7 @@ impl Item {\n                 if let Ok((mut href, ..)) = href(*did, cx) {\n                     debug!(?href);\n                     if let Some(ref fragment) = *fragment {\n-                        fragment.render(&mut href, cx.tcx()).unwrap()\n+                        fragment.render(&mut href, cx.tcx())\n                     }\n                     Some(RenderedLink {\n                         original_text: s.clone(),"}, {"sha": "83d8fe9ef1110835bef6e47a4de37b2ad8ff04aa", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 52, "deletions": 113, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/8eb4fc60579cc2138adbf6eaeb86ccfeefc81713/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8eb4fc60579cc2138adbf6eaeb86ccfeefc81713/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=8eb4fc60579cc2138adbf6eaeb86ccfeefc81713", "patch": "@@ -20,7 +20,6 @@ use rustc_span::BytePos;\n use smallvec::{smallvec, SmallVec};\n \n use std::borrow::Cow;\n-use std::fmt::Write;\n use std::mem;\n use std::ops::Range;\n \n@@ -220,80 +219,43 @@ enum MalformedGenerics {\n \n #[derive(Clone, Debug, Hash, PartialEq, Eq)]\n pub(crate) enum UrlFragment {\n-    Item(ItemFragment),\n+    Item(DefId),\n     UserWritten(String),\n }\n \n impl UrlFragment {\n     /// Render the fragment, including the leading `#`.\n-    pub(crate) fn render(&self, s: &mut String, tcx: TyCtxt<'_>) -> std::fmt::Result {\n+    pub(crate) fn render(&self, s: &mut String, tcx: TyCtxt<'_>) {\n+        s.push('#');\n         match self {\n-            UrlFragment::Item(frag) => frag.render(s, tcx),\n-            UrlFragment::UserWritten(raw) => write!(s, \"#{}\", raw),\n-        }\n-    }\n-}\n-\n-#[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n-pub(crate) struct ItemFragment(FragmentKind, DefId);\n-\n-#[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n-pub(crate) enum FragmentKind {\n-    Method,\n-    TyMethod,\n-    AssociatedConstant,\n-    AssociatedType,\n-\n-    StructField,\n-    Variant,\n-    VariantField,\n-}\n-\n-impl FragmentKind {\n-    fn from_def_id(tcx: TyCtxt<'_>, def_id: DefId) -> FragmentKind {\n-        match tcx.def_kind(def_id) {\n-            DefKind::AssocFn => {\n-                if tcx.associated_item(def_id).defaultness.has_value() {\n-                    FragmentKind::Method\n-                } else {\n-                    FragmentKind::TyMethod\n-                }\n-            }\n-            DefKind::AssocConst => FragmentKind::AssociatedConstant,\n-            DefKind::AssocTy => FragmentKind::AssociatedType,\n-            DefKind::Variant => FragmentKind::Variant,\n-            DefKind::Field => {\n-                if tcx.def_kind(tcx.parent(def_id)) == DefKind::Variant {\n-                    FragmentKind::VariantField\n-                } else {\n-                    FragmentKind::StructField\n-                }\n-            }\n-            kind => bug!(\"unexpected associated item kind: {:?}\", kind),\n-        }\n-    }\n-}\n-\n-impl ItemFragment {\n-    /// Render the fragment, including the leading `#`.\n-    pub(crate) fn render(&self, s: &mut String, tcx: TyCtxt<'_>) -> std::fmt::Result {\n-        write!(s, \"#\")?;\n-        match *self {\n-            ItemFragment(kind, def_id) => {\n-                let name = tcx.item_name(def_id);\n-                match kind {\n-                    FragmentKind::Method => write!(s, \"method.{}\", name),\n-                    FragmentKind::TyMethod => write!(s, \"tymethod.{}\", name),\n-                    FragmentKind::AssociatedConstant => write!(s, \"associatedconstant.{}\", name),\n-                    FragmentKind::AssociatedType => write!(s, \"associatedtype.{}\", name),\n-                    FragmentKind::StructField => write!(s, \"structfield.{}\", name),\n-                    FragmentKind::Variant => write!(s, \"variant.{}\", name),\n-                    FragmentKind::VariantField => {\n-                        let variant = tcx.item_name(tcx.parent(def_id));\n-                        write!(s, \"variant.{}.field.{}\", variant, name)\n+            &UrlFragment::Item(def_id) => {\n+                let kind = match tcx.def_kind(def_id) {\n+                    DefKind::AssocFn => {\n+                        if tcx.associated_item(def_id).defaultness.has_value() {\n+                            \"method.\"\n+                        } else {\n+                            \"tymethod.\"\n+                        }\n                     }\n-                }\n+                    DefKind::AssocConst => \"associatedconstant.\",\n+                    DefKind::AssocTy => \"associatedtype.\",\n+                    DefKind::Variant => \"variant.\",\n+                    DefKind::Field => {\n+                        let parent_id = tcx.parent(def_id);\n+                        if tcx.def_kind(parent_id) == DefKind::Variant {\n+                            s.push_str(\"variant.\");\n+                            s.push_str(tcx.item_name(parent_id).as_str());\n+                            \".field.\"\n+                        } else {\n+                            \"structfield.\"\n+                        }\n+                    }\n+                    kind => bug!(\"unexpected associated item kind: {:?}\", kind),\n+                };\n+                s.push_str(kind);\n+                s.push_str(tcx.item_name(def_id).as_str());\n             }\n+            UrlFragment::UserWritten(raw) => s.push_str(&raw),\n         }\n     }\n }\n@@ -315,11 +277,6 @@ struct DiagnosticInfo<'a> {\n     link_range: Range<usize>,\n }\n \n-#[derive(Clone, Debug, Hash)]\n-struct CachedLink {\n-    res: (Res, Option<UrlFragment>),\n-}\n-\n struct LinkCollector<'a, 'tcx> {\n     cx: &'a mut DocContext<'tcx>,\n     /// A stack of modules used to decide what scope to resolve in.\n@@ -329,7 +286,7 @@ struct LinkCollector<'a, 'tcx> {\n     mod_ids: Vec<DefId>,\n     /// Cache the resolved links so we can avoid resolving (and emitting errors for) the same link.\n     /// The link will be `None` if it could not be resolved (i.e. the error was cached).\n-    visited_links: FxHashMap<ResolutionInfo, Option<CachedLink>>,\n+    visited_links: FxHashMap<ResolutionInfo, Option<(Res, Option<UrlFragment>)>>,\n }\n \n impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n@@ -1097,6 +1054,9 @@ impl LinkCollector<'_, '_> {\n                 extra_fragment: extra_fragment.clone(),\n             },\n             diag_info.clone(), // this struct should really be Copy, but Range is not :(\n+            // For reference-style links we want to report only one error so unsuccessful\n+            // resolutions are cached, for other links we want to report an error every\n+            // time so they are not cached.\n             matches!(ori_link.kind, LinkType::Reference | LinkType::Shortcut),\n         )?;\n \n@@ -1123,7 +1083,7 @@ impl LinkCollector<'_, '_> {\n \n         match res {\n             Res::Primitive(prim) => {\n-                if let Some(UrlFragment::Item(ItemFragment(_, id))) = fragment {\n+                if let Some(UrlFragment::Item(id)) = fragment {\n                     // We're actually resolving an associated item of a primitive, so we need to\n                     // verify the disambiguator (if any) matches the type of the associated item.\n                     // This case should really follow the same flow as the `Res::Def` branch below,\n@@ -1171,12 +1131,11 @@ impl LinkCollector<'_, '_> {\n                 })\n             }\n             Res::Def(kind, id) => {\n-                let (kind_for_dis, id_for_dis) =\n-                    if let Some(UrlFragment::Item(ItemFragment(_, id))) = fragment {\n-                        (self.cx.tcx.def_kind(id), id)\n-                    } else {\n-                        (kind, id)\n-                    };\n+                let (kind_for_dis, id_for_dis) = if let Some(UrlFragment::Item(id)) = fragment {\n+                    (self.cx.tcx.def_kind(id), id)\n+                } else {\n+                    (kind, id)\n+                };\n                 self.verify_disambiguator(\n                     path_str,\n                     ori_link,\n@@ -1294,53 +1253,33 @@ impl LinkCollector<'_, '_> {\n         &mut self,\n         key: ResolutionInfo,\n         diag: DiagnosticInfo<'_>,\n-        cache_resolution_failure: bool,\n+        // If errors are cached then they are only reported on first ocurrence\n+        // which we want in some cases but not in others.\n+        cache_errors: bool,\n     ) -> Option<(Res, Option<UrlFragment>)> {\n-        if let Some(ref cached) = self.visited_links.get(&key) {\n-            match cached {\n-                Some(cached) => {\n-                    return Some(cached.res.clone());\n-                }\n-                None if cache_resolution_failure => return None,\n-                None => {\n-                    // Although we hit the cache and found a resolution error, this link isn't\n-                    // supposed to cache those. Run link resolution again to emit the expected\n-                    // resolution error.\n-                }\n+        if let Some(res) = self.visited_links.get(&key) {\n+            if res.is_some() || cache_errors {\n+                return res.clone();\n             }\n         }\n \n         let res = self.resolve_with_disambiguator(&key, diag.clone()).and_then(|(res, def_id)| {\n             let fragment = match (&key.extra_fragment, def_id) {\n                 (Some(_), Some(def_id)) => {\n-                    report_anchor_conflict(self.cx, diag, Res::from_def_id(self.cx.tcx, def_id));\n+                    report_anchor_conflict(self.cx, diag, def_id);\n                     return None;\n                 }\n                 (Some(u_frag), None) => Some(UrlFragment::UserWritten(u_frag.clone())),\n-                (None, Some(def_id)) => Some(UrlFragment::Item(ItemFragment(\n-                    FragmentKind::from_def_id(self.cx.tcx, def_id),\n-                    def_id,\n-                ))),\n+                (None, Some(def_id)) => Some(UrlFragment::Item(def_id)),\n                 (None, None) => None,\n             };\n             Some((res, fragment))\n         });\n \n-        // Cache only if resolved successfully - don't silence duplicate errors\n-        if let Some(res) = res {\n-            // Store result for the actual namespace\n-            self.visited_links.insert(key, Some(CachedLink { res: res.clone() }));\n-\n-            Some(res)\n-        } else {\n-            if cache_resolution_failure {\n-                // For reference-style links we only want to report one resolution error\n-                // so let's cache them as well.\n-                self.visited_links.insert(key, None);\n-            }\n-\n-            None\n+        if res.is_some() || cache_errors {\n+            self.visited_links.insert(key, res.clone());\n         }\n+        res\n     }\n \n     /// After parsing the disambiguator, resolve the main part of the link.\n@@ -1916,8 +1855,8 @@ fn report_multiple_anchors(cx: &DocContext<'_>, diag_info: DiagnosticInfo<'_>) {\n     anchor_failure(cx, diag_info, &msg, 1)\n }\n \n-fn report_anchor_conflict(cx: &DocContext<'_>, diag_info: DiagnosticInfo<'_>, res: Res) {\n-    let (link, kind) = (diag_info.ori_link, res.descr());\n+fn report_anchor_conflict(cx: &DocContext<'_>, diag_info: DiagnosticInfo<'_>, def_id: DefId) {\n+    let (link, kind) = (diag_info.ori_link, Res::from_def_id(cx.tcx, def_id).descr());\n     let msg = format!(\"`{link}` contains an anchor, but links to {kind}s are already anchored\");\n     anchor_failure(cx, diag_info, &msg, 0)\n }"}]}