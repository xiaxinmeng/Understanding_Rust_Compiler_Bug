{"sha": "a14ec73cd2d15a2454113011835557ccf447f14d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmExNGVjNzNjZDJkMTVhMjQ1NDExMzAxMTgzNTU1N2NjZjQ0N2YxNGQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-03-19T18:43:10Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-03-19T18:43:10Z"}, "message": "auto merge of #5356 : jld/rust/enum-less-magic, r=graydon\n\nFixes #1645.", "tree": {"sha": "ee0bb50556592980927583b079c16bdf54eb13a6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ee0bb50556592980927583b079c16bdf54eb13a6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a14ec73cd2d15a2454113011835557ccf447f14d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a14ec73cd2d15a2454113011835557ccf447f14d", "html_url": "https://github.com/rust-lang/rust/commit/a14ec73cd2d15a2454113011835557ccf447f14d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a14ec73cd2d15a2454113011835557ccf447f14d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "58209910bd70512e4a880bb25ed296dddc48e0b7", "url": "https://api.github.com/repos/rust-lang/rust/commits/58209910bd70512e4a880bb25ed296dddc48e0b7", "html_url": "https://github.com/rust-lang/rust/commit/58209910bd70512e4a880bb25ed296dddc48e0b7"}, {"sha": "a301db7eef71d8f74ba9bd61b9dc4559b3ffc1aa", "url": "https://api.github.com/repos/rust-lang/rust/commits/a301db7eef71d8f74ba9bd61b9dc4559b3ffc1aa", "html_url": "https://github.com/rust-lang/rust/commit/a301db7eef71d8f74ba9bd61b9dc4559b3ffc1aa"}], "stats": {"total": 112, "additions": 74, "deletions": 38}, "files": [{"sha": "8ebf20ff68cf1c9f699f4bd51052f816b49d6d34", "filename": "src/librustc/middle/trans/adt.rs", "status": "modified", "additions": 48, "deletions": 38, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/a14ec73cd2d15a2454113011835557ccf447f14d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a14ec73cd2d15a2454113011835557ccf447f14d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs?ref=a14ec73cd2d15a2454113011835557ccf447f14d", "patch": "@@ -23,10 +23,6 @@\n  * Having everything in one place will enable improvements to data\n  * structure representation; possibilities include:\n  *\n- * - Aligning enum bodies correctly, which in turn makes possible SIMD\n- *   vector types (which are strict-alignment even on x86) and ports\n- *   to strict-alignment architectures (PowerPC, SPARC, etc.).\n- *\n  * - User-specified alignment (e.g., cacheline-aligning parts of\n  *   concurrently accessed data structures); LLVM can't represent this\n  *   directly, so we'd have to insert padding fields in any structure\n@@ -82,10 +78,8 @@ pub enum Repr {\n      */\n     Univariant(Struct, bool),\n     /**\n-     * General-case enums: discriminant as int, followed by fields.\n-     * The fields start immediately after the discriminant, meaning\n-     * that they may not be correctly aligned for the platform's ABI;\n-     * see above.\n+     * General-case enums: for each case there is a struct, and they\n+     * all start with a field for the discriminant.\n      */\n     General(~[Struct])\n }\n@@ -156,7 +150,8 @@ pub fn represent_type(cx: @CrateContext, t: ty::t) -> @Repr {\n                                       discriminants\",\n                                      ty::item_path_str(cx.tcx, def_id)))\n                 }\n-                General(cases.map(|c| mk_struct(cx, c.tys)))\n+                let discr = ~[ty::mk_int(cx.tcx)];\n+                General(cases.map(|c| mk_struct(cx, discr + c.tys)))\n             }\n         }\n         _ => cx.sess.bug(~\"adt::represent_type called on non-ADT type\")\n@@ -191,20 +186,44 @@ fn generic_fields_of(cx: @CrateContext, r: &Repr, sizing: bool)\n     -> ~[TypeRef] {\n     match *r {\n         CEnum(*) => ~[T_enum_discrim(cx)],\n-        Univariant(ref st, _dtor) => {\n-            if sizing {\n-                st.fields.map(|&ty| type_of::sizing_type_of(cx, ty))\n-            } else {\n-                st.fields.map(|&ty| type_of::type_of(cx, ty))\n-            }\n-        }\n+        Univariant(ref st, _dtor) => struct_llfields(cx, st, sizing),\n         General(ref sts) => {\n-            ~[T_enum_discrim(cx),\n-              T_array(T_i8(), sts.map(|st| st.size).max() /*bad*/as uint)]\n+            // To get \"the\" type of a general enum, we pick the case\n+            // with the largest alignment (so it will always align\n+            // correctly in containing structures) and pad it out.\n+            fail_unless!(sts.len() >= 1);\n+            let mut most_aligned = None;\n+            let mut largest_align = 0;\n+            let mut largest_size = 0;\n+            for sts.each |st| {\n+                if largest_size < st.size {\n+                    largest_size = st.size;\n+                }\n+                if largest_align < st.align {\n+                    // Clang breaks ties by size; it is unclear if\n+                    // that accomplishes anything important.\n+                    largest_align = st.align;\n+                    most_aligned = Some(st);\n+                }\n+            }\n+            let most_aligned = most_aligned.get();\n+            let padding = largest_size - most_aligned.size;\n+\n+            struct_llfields(cx, most_aligned, sizing)\n+                + [T_array(T_i8(), padding /*bad*/as uint)]\n         }\n     }\n }\n \n+fn struct_llfields(cx: @CrateContext, st: &Struct, sizing: bool)\n+    -> ~[TypeRef] {\n+    if sizing {\n+        st.fields.map(|&ty| type_of::sizing_type_of(cx, ty))\n+    } else {\n+        st.fields.map(|&ty| type_of::type_of(cx, ty))\n+    }\n+}\n+\n /**\n  * Obtain a representation of the discriminant sufficient to translate\n  * destructuring; this may or may not involve the actual discriminant.\n@@ -309,7 +328,7 @@ pub fn num_args(r: &Repr, discr: int) -> uint {\n             fail_unless!(discr == 0);\n             st.fields.len() - (if dtor { 1 } else { 0 })\n         }\n-        General(ref cases) => cases[discr as uint].fields.len()\n+        General(ref cases) => cases[discr as uint].fields.len() - 1\n     }\n }\n \n@@ -328,8 +347,7 @@ pub fn trans_field_ptr(bcx: block, r: &Repr, val: ValueRef, discr: int,\n             struct_field_ptr(bcx, st, val, ix, false)\n         }\n         General(ref cases) => {\n-            struct_field_ptr(bcx, &cases[discr as uint],\n-                                 GEPi(bcx, val, [0, 1]), ix, true)\n+            struct_field_ptr(bcx, &cases[discr as uint], val, ix + 1, true)\n         }\n     }\n }\n@@ -371,13 +389,12 @@ pub fn trans_drop_flag_ptr(bcx: block, r: &Repr, val: ValueRef) -> ValueRef {\n  * depending on which case of an enum it is.\n  *\n  * To understand the alignment situation, consider `enum E { V64(u64),\n- * V32(u32, u32) }` on win32.  The type should have 8-byte alignment\n- * to accommodate the u64 (currently it doesn't; this is a known bug),\n- * but `V32(x, y)` would have LLVM type `{i32, i32, i32}`, which is\n- * 4-byte aligned.\n+ * V32(u32, u32) }` on win32.  The type has 8-byte alignment to\n+ * accommodate the u64, but `V32(x, y)` would have LLVM type `{i32,\n+ * i32, i32}`, which is 4-byte aligned.\n  *\n  * Currently the returned value has the same size as the type, but\n- * this may be changed in the future to avoid allocating unnecessary\n+ * this could be changed in the future to avoid allocating unnecessary\n  * space after values of shorter-than-maximum cases.\n  */\n pub fn trans_const(ccx: @CrateContext, r: &Repr, discr: int,\n@@ -395,14 +412,9 @@ pub fn trans_const(ccx: @CrateContext, r: &Repr, discr: int,\n         General(ref cases) => {\n             let case = &cases[discr as uint];\n             let max_sz = cases.map(|s| s.size).max();\n-            let body = build_const_struct(ccx, case, vals);\n-\n-            // The unary packed struct has alignment 1 regardless of\n-            // its contents, so it will always be located at the\n-            // expected offset at runtime.\n-            C_struct([C_int(ccx, discr),\n-                      C_packed_struct([C_struct(body)]),\n-                      padding(max_sz - case.size)])\n+            let contents = build_const_struct(ccx, case,\n+                                              ~[C_int(ccx, discr)] + vals);\n+            C_struct(contents + [padding(max_sz - case.size)])\n         }\n     }\n }\n@@ -472,11 +484,9 @@ pub fn const_get_discrim(ccx: @CrateContext, r: &Repr, val: ValueRef)\n pub fn const_get_field(ccx: @CrateContext, r: &Repr, val: ValueRef,\n                        _discr: int, ix: uint) -> ValueRef {\n     match *r {\n-        CEnum(*) => ccx.sess.bug(~\"element access in C-like enum \\\n-                                             const\"),\n+        CEnum(*) => ccx.sess.bug(~\"element access in C-like enum const\"),\n         Univariant(*) => const_struct_field(ccx, val, ix),\n-        General(*) => const_struct_field(ccx, const_get_elt(ccx, val,\n-                                                            [1, 0]), ix)\n+        General(*) => const_struct_field(ccx, val, ix + 1)\n     }\n }\n "}, {"sha": "5da643670231346a51f1b2412661498964a98e33", "filename": "src/test/run-pass/enum-alignment.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/a14ec73cd2d15a2454113011835557ccf447f14d/src%2Ftest%2Frun-pass%2Fenum-alignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a14ec73cd2d15a2454113011835557ccf447f14d/src%2Ftest%2Frun-pass%2Fenum-alignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fenum-alignment.rs?ref=a14ec73cd2d15a2454113011835557ccf447f14d", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn addr_of<T>(ptr: &T) -> uint {\n+    let ptr = ptr::addr_of(ptr);\n+    unsafe { ptr as uint }\n+}\n+\n+fn is_aligned<T>(ptr: &T) -> bool {\n+    (addr_of(ptr) % sys::min_align_of::<T>()) == 0\n+}\n+\n+pub fn main() {\n+    let x = Some(0u64);\n+    match x {\n+        None => fail!(),\n+        Some(ref y) => fail_unless!(is_aligned(y))\n+    }\n+}"}]}