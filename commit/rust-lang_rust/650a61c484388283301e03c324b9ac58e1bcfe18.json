{"sha": "650a61c484388283301e03c324b9ac58e1bcfe18", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY1MGE2MWM0ODQzODgyODMzMDFlMDNjMzI0YjlhYzU4ZTFiY2ZlMTg=", "commit": {"author": {"name": "David Wood", "email": "david@davidtw.co", "date": "2018-09-11T14:38:35Z"}, "committer": {"name": "David Wood", "email": "david@davidtw.co", "date": "2018-09-23T11:50:22Z"}, "message": "Refactor MirBorrowckCtxt to take infcx instead of tcx.", "tree": {"sha": "6cdd46594e9c3dbc28f14368ea968ea6e033c5f7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6cdd46594e9c3dbc28f14368ea968ea6e033c5f7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/650a61c484388283301e03c324b9ac58e1bcfe18", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEEWwgxPGhT5b/6kagXAXYLT59T8VQFAlunff4ACgkQAXYLT59T\n8VROwxAAsl2/We9b0nZfeaIZ9oQJUp2H3Z5vOPqMkapwB53kRmipUCs4RXwYBvuX\nA7RqBtrUh1JbcIOY0E09hTZUDDyW97S3cODuiPivwEMcBYysXuiRulXfAV6ZWACs\np4rbO/1KtuHGCmZqxIWc6TcKJwAtv3IGgT3ieVLHjpHJrR39LZAtEuT7oR1jB0b4\n9M28PbgNFH0Hb022w001KlahfG7hgXXOK4jWzhOqU0RQsZoCjJjbMJd+cuZj4kF/\ntBhVK5XvN3emxPBogBzXwTnnPyIpYyImN6jlFtgsz6i/T3LrO67rO+puDp0FHf6X\nUW7IoPn/AJkomFQqPZ19dTGHy/KOlqwKVOxj/Jba3FDCBWNoA3o4bzFoCNPySVK5\nbOe02n4jB35IXI+m+ZQCmDsp0c4PRyCqafiCQyL/sO6aG/4XNGMHQlDhpHC6HmJH\nGLSuepOz4+Jwi842ICL7OXva3gTYxXeKAcCqFWfa9RsoU2qxi6/iLCUma9miZfVj\nKJRvjKDSHGOPrYH931XIgPdWWS/N3QgudLs7U5qTOpZGMdFMRtDLpIMa1YxOsB/c\nc5TqTjGQwcURmytgF4U81syzEINEJ2QxTini1TqZ+TxA+q4CyeGUmPC3lSBu0Q88\n7Kbge0qchLD7y3I9jBKavgBvwphVr1g9t1p87b13bEc82B6WMmc=\n=gekT\n-----END PGP SIGNATURE-----", "payload": "tree 6cdd46594e9c3dbc28f14368ea968ea6e033c5f7\nparent 9e3889e2ea6b69f84b6034e506e6967ffef408cf\nauthor David Wood <david@davidtw.co> 1536676715 +0200\ncommitter David Wood <david@davidtw.co> 1537703422 +0200\n\nRefactor MirBorrowckCtxt to take infcx instead of tcx.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/650a61c484388283301e03c324b9ac58e1bcfe18", "html_url": "https://github.com/rust-lang/rust/commit/650a61c484388283301e03c324b9ac58e1bcfe18", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/650a61c484388283301e03c324b9ac58e1bcfe18/comments", "author": {"login": "davidtwco", "id": 1295100, "node_id": "MDQ6VXNlcjEyOTUxMDA=", "avatar_url": "https://avatars.githubusercontent.com/u/1295100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidtwco", "html_url": "https://github.com/davidtwco", "followers_url": "https://api.github.com/users/davidtwco/followers", "following_url": "https://api.github.com/users/davidtwco/following{/other_user}", "gists_url": "https://api.github.com/users/davidtwco/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidtwco/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidtwco/subscriptions", "organizations_url": "https://api.github.com/users/davidtwco/orgs", "repos_url": "https://api.github.com/users/davidtwco/repos", "events_url": "https://api.github.com/users/davidtwco/events{/privacy}", "received_events_url": "https://api.github.com/users/davidtwco/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidtwco", "id": 1295100, "node_id": "MDQ6VXNlcjEyOTUxMDA=", "avatar_url": "https://avatars.githubusercontent.com/u/1295100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidtwco", "html_url": "https://github.com/davidtwco", "followers_url": "https://api.github.com/users/davidtwco/followers", "following_url": "https://api.github.com/users/davidtwco/following{/other_user}", "gists_url": "https://api.github.com/users/davidtwco/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidtwco/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidtwco/subscriptions", "organizations_url": "https://api.github.com/users/davidtwco/orgs", "repos_url": "https://api.github.com/users/davidtwco/repos", "events_url": "https://api.github.com/users/davidtwco/events{/privacy}", "received_events_url": "https://api.github.com/users/davidtwco/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9e3889e2ea6b69f84b6034e506e6967ffef408cf", "url": "https://api.github.com/repos/rust-lang/rust/commits/9e3889e2ea6b69f84b6034e506e6967ffef408cf", "html_url": "https://github.com/rust-lang/rust/commit/9e3889e2ea6b69f84b6034e506e6967ffef408cf"}], "stats": {"total": 221, "additions": 113, "deletions": 108}, "files": [{"sha": "0cbbbbd2285370c9937b467afd9d4a1ae5617040", "filename": "src/librustc_mir/borrow_check/error_reporting.rs", "status": "modified", "additions": 40, "deletions": 36, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/650a61c484388283301e03c324b9ac58e1bcfe18/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/650a61c484388283301e03c324b9ac58e1bcfe18/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs?ref=650a61c484388283301e03c324b9ac58e1bcfe18", "patch": "@@ -72,7 +72,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 Some(name) => format!(\"`{}`\", name),\n                 None => \"value\".to_owned(),\n             };\n-            let mut err = self.tcx.cannot_act_on_uninitialized_variable(\n+            let mut err = self.infcx.tcx.cannot_act_on_uninitialized_variable(\n                 span,\n                 desired_action.as_noun(),\n                 &self\n@@ -99,7 +99,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n             let msg = \"\"; //FIXME: add \"partially \" or \"collaterally \"\n \n-            let mut err = self.tcx.cannot_act_on_moved_value(\n+            let mut err = self.infcx.tcx.cannot_act_on_moved_value(\n                 span,\n                 desired_action.as_noun(),\n                 msg,\n@@ -151,9 +151,9 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             if let Some(ty) = self.retrieve_type_for_place(place) {\n                 let needs_note = match ty.sty {\n                     ty::Closure(id, _) => {\n-                        let tables = self.tcx.typeck_tables_of(id);\n-                        let node_id = self.tcx.hir.as_local_node_id(id).unwrap();\n-                        let hir_id = self.tcx.hir.node_to_hir_id(node_id);\n+                        let tables = self.infcx.tcx.typeck_tables_of(id);\n+                        let node_id = self.infcx.tcx.hir.as_local_node_id(id).unwrap();\n+                        let hir_id = self.infcx.tcx.hir.node_to_hir_id(node_id);\n                         if tables.closure_kind_origins().get(hir_id).is_some() {\n                             false\n                         } else {\n@@ -200,7 +200,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         (place, _span): (&Place<'tcx>, Span),\n         borrow: &BorrowData<'tcx>,\n     ) {\n-        let tcx = self.tcx;\n+        let tcx = self.infcx.tcx;\n         let value_msg = match self.describe_place(place) {\n             Some(name) => format!(\"`{}`\", name),\n             None => \"value\".to_owned(),\n@@ -228,7 +228,8 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n         move_spans.var_span_label(&mut err, \"move occurs due to use in closure\");\n \n-        self.explain_why_borrow_contains_point(context, borrow, None).emit(self.tcx, &mut err);\n+        self.explain_why_borrow_contains_point(context, borrow, None)\n+            .emit(self.infcx.tcx, &mut err);\n         err.buffer(&mut self.errors_buffer);\n     }\n \n@@ -238,7 +239,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         (place, _span): (&Place<'tcx>, Span),\n         borrow: &BorrowData<'tcx>,\n     ) {\n-        let tcx = self.tcx;\n+        let tcx = self.infcx.tcx;\n \n         let borrow_spans = self.retrieve_borrow_spans(borrow);\n         let borrow_span = borrow_spans.args_or_use();\n@@ -265,7 +266,8 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             format!(\"borrow occurs due to use of `{}` in closure\", desc_place)\n         });\n \n-        self.explain_why_borrow_contains_point(context, borrow, None).emit(self.tcx, &mut err);\n+        self.explain_why_borrow_contains_point(context, borrow, None)\n+            .emit(self.infcx.tcx, &mut err);\n         err.buffer(&mut self.errors_buffer);\n     }\n \n@@ -283,7 +285,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         let span = borrow_spans.args_or_use();\n \n         let desc_place = self.describe_place(place).unwrap_or(\"_\".to_owned());\n-        let tcx = self.tcx;\n+        let tcx = self.infcx.tcx;\n \n         // FIXME: supply non-\"\" `opt_via` when appropriate\n         let mut err = match (\n@@ -393,7 +395,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         }\n \n         self.explain_why_borrow_contains_point(context, issued_borrow, None)\n-            .emit(self.tcx, &mut err);\n+            .emit(self.infcx.tcx, &mut err);\n \n         err.buffer(&mut self.errors_buffer);\n     }\n@@ -420,7 +422,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         );\n \n         let drop_span = place_span.1;\n-        let scope_tree = self.tcx.region_scope_tree(self.mir_def_id);\n+        let scope_tree = self.infcx.tcx.region_scope_tree(self.mir_def_id);\n         let root_place = self\n             .prefixes(&borrow.borrowed_place, PrefixSet::All)\n             .last()\n@@ -503,7 +505,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             context, name, scope_tree, borrow, drop_span, borrow_span\n         );\n \n-        let mut err = self.tcx.path_does_not_live_long_enough(\n+        let mut err = self.infcx.tcx.path_does_not_live_long_enough(\n             borrow_span,\n             &format!(\"`{}`\", name),\n             Origin::Mir,\n@@ -516,7 +518,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         );\n \n         self.explain_why_borrow_contains_point(context, borrow, kind_place)\n-            .emit(self.tcx, &mut err);\n+            .emit(self.infcx.tcx, &mut err);\n \n         err\n     }\n@@ -594,9 +596,9 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             drop_span, borrow_span\n         );\n \n-        let mut err = self\n-            .tcx\n-            .thread_local_value_does_not_live_long_enough(borrow_span, Origin::Mir);\n+        let mut err = self.infcx.tcx.thread_local_value_does_not_live_long_enough(\n+            borrow_span, Origin::Mir\n+        );\n \n         err.span_label(\n             borrow_span,\n@@ -622,7 +624,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             context, scope_tree, borrow, drop_span, proper_span\n         );\n \n-        let tcx = self.tcx;\n+        let tcx = self.infcx.tcx;\n         let mut err =\n             tcx.path_does_not_live_long_enough(proper_span, \"borrowed value\", Origin::Mir);\n         err.span_label(proper_span, \"temporary value does not live long enough\");\n@@ -638,7 +640,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             },\n             _ => {},\n         }\n-        explanation.emit(self.tcx, &mut err);\n+        explanation.emit(self.infcx.tcx, &mut err);\n \n         err\n     }\n@@ -713,7 +715,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n             // check for inits\n             let mut any_match = false;\n-            drop_flag_effects::for_location_inits(self.tcx, self.mir, self.move_data, l, |m| {\n+            drop_flag_effects::for_location_inits(self.infcx.tcx, self.mir, self.move_data, l, |m| {\n                 if m == mpi {\n                     any_match = true;\n                 }\n@@ -737,7 +739,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         let loan_spans = self.retrieve_borrow_spans(loan);\n         let loan_span = loan_spans.args_or_use();\n \n-        let tcx = self.tcx;\n+        let tcx = self.infcx.tcx;\n         let mut err = tcx.cannot_assign_to_borrowed(\n             span,\n             loan_span,\n@@ -747,7 +749,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n         loan_spans.var_span_label(&mut err, \"borrow occurs due to use in closure\");\n \n-        self.explain_why_borrow_contains_point(context, loan, None).emit(self.tcx, &mut err);\n+        self.explain_why_borrow_contains_point(context, loan, None).emit(self.infcx.tcx, &mut err);\n \n         err.buffer(&mut self.errors_buffer);\n     }\n@@ -799,7 +801,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             Some(decl) => (self.describe_place(err_place), decl.source_info.span),\n         };\n \n-        let mut err = self.tcx.cannot_reassign_immutable(\n+        let mut err = self.infcx.tcx.cannot_reassign_immutable(\n             span,\n             place_description.as_ref().map(AsRef::as_ref).unwrap_or(\"_\"),\n             from_arg,\n@@ -877,13 +879,13 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 self.append_local_to_string(local, buf)?;\n             }\n             Place::Static(ref static_) => {\n-                buf.push_str(&self.tcx.item_name(static_.def_id).to_string());\n+                buf.push_str(&self.infcx.tcx.item_name(static_.def_id).to_string());\n             }\n             Place::Projection(ref proj) => {\n                 match proj.elem {\n                     ProjectionElem::Deref => {\n                         let upvar_field_projection =\n-                            place.is_upvar_field_projection(self.mir, &self.tcx);\n+                            place.is_upvar_field_projection(self.mir, &self.infcx.tcx);\n                         if let Some(field) = upvar_field_projection {\n                             let var_index = field.index();\n                             let name = self.mir.upvar_decls[var_index].debug_name.to_string();\n@@ -945,7 +947,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                         autoderef = true;\n \n                         let upvar_field_projection =\n-                            place.is_upvar_field_projection(self.mir, &self.tcx);\n+                            place.is_upvar_field_projection(self.mir, &self.infcx.tcx);\n                         if let Some(field) = upvar_field_projection {\n                             let var_index = field.index();\n                             let name = self.mir.upvar_decls[var_index].debug_name.to_string();\n@@ -1060,10 +1062,10 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     // the local code in the current crate, so this returns an `Option` in case\n                     // the closure comes from another crate. But in that case we wouldn't\n                     // be borrowck'ing it, so we can just unwrap:\n-                    let node_id = self.tcx.hir.as_local_node_id(def_id).unwrap();\n-                    let freevar = self.tcx.with_freevars(node_id, |fv| fv[field.index()]);\n+                    let node_id = self.infcx.tcx.hir.as_local_node_id(def_id).unwrap();\n+                    let freevar = self.infcx.tcx.with_freevars(node_id, |fv| fv[field.index()]);\n \n-                    self.tcx.hir.name(freevar.var_id()).to_string()\n+                    self.infcx.tcx.hir.name(freevar.var_id()).to_string()\n                 }\n                 _ => {\n                     // Might need a revision when the fields in trait RFC is implemented\n@@ -1096,7 +1098,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n     /// Check if a place is a thread-local static.\n     pub fn is_place_thread_local(&self, place: &Place<'tcx>) -> bool {\n         if let Place::Static(statik) = place {\n-            let attrs = self.tcx.get_attrs(statik.def_id);\n+            let attrs = self.infcx.tcx.get_attrs(statik.def_id);\n             let is_thread_local = attrs.iter().any(|attr| attr.check_name(\"thread_local\"));\n \n             debug!(\n@@ -1212,9 +1214,11 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             if let AggregateKind::Closure(def_id, _) = **kind {\n                 debug!(\"find_closure_move_span: found closure {:?}\", places);\n \n-                if let Some(node_id) = self.tcx.hir.as_local_node_id(def_id) {\n-                    if let Closure(_, _, _, args_span, _) = self.tcx.hir.expect_expr(node_id).node {\n-                        if let Some(var_span) = self.tcx.with_freevars(node_id, |freevars| {\n+                if let Some(node_id) = self.infcx.tcx.hir.as_local_node_id(def_id) {\n+                    if let Closure(\n+                        _, _, _, args_span, _\n+                    ) = self.infcx.tcx.hir.expect_expr(node_id).node {\n+                        if let Some(var_span) = self.infcx.tcx.with_freevars(node_id, |freevars| {\n                             for (v, place) in freevars.iter().zip(places) {\n                                 match place {\n                                     Operand::Copy(place) | Operand::Move(place)\n@@ -1274,16 +1278,16 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 if let AggregateKind::Closure(def_id, _) = **kind {\n                     debug!(\"find_closure_borrow_span: found closure {:?}\", places);\n \n-                    return if let Some(node_id) = self.tcx.hir.as_local_node_id(def_id) {\n+                    return if let Some(node_id) = self.infcx.tcx.hir.as_local_node_id(def_id) {\n                         let args_span = if let Closure(_, _, _, span, _) =\n-                            self.tcx.hir.expect_expr(node_id).node\n+                            self.infcx.tcx.hir.expect_expr(node_id).node\n                         {\n                             span\n                         } else {\n                             return OtherUse(use_span);\n                         };\n \n-                        self.tcx\n+                        self.infcx.tcx\n                             .with_freevars(node_id, |freevars| {\n                                 for (v, place) in freevars.iter().zip(places) {\n                                     match *place {"}, {"sha": "5a08d227998d566adef2966d5d515d91a8dce349", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/650a61c484388283301e03c324b9ac58e1bcfe18/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/650a61c484388283301e03c324b9ac58e1bcfe18/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=650a61c484388283301e03c324b9ac58e1bcfe18", "patch": "@@ -247,8 +247,8 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n     let dominators = mir.dominators();\n \n     let mut mbcx = MirBorrowckCtxt {\n-        tcx: tcx,\n-        mir: mir,\n+        infcx,\n+        mir,\n         mir_def_id: def_id,\n         move_data: &mdpe.move_data,\n         param_env: param_env,\n@@ -369,7 +369,7 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n         }\n \n         for diag in mbcx.errors_buffer.drain(..) {\n-            DiagnosticBuilder::new_diagnostic(mbcx.tcx.sess.diagnostic(), diag).emit();\n+            DiagnosticBuilder::new_diagnostic(mbcx.infcx.tcx.sess.diagnostic(), diag).emit();\n         }\n     }\n \n@@ -384,7 +384,7 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n }\n \n pub struct MirBorrowckCtxt<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n-    tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n+    infcx: &'cx InferCtxt<'cx, 'gcx, 'tcx>,\n     mir: &'cx Mir<'tcx>,\n     mir_def_id: DefId,\n     move_data: &'cx MoveData<'tcx>,\n@@ -612,13 +612,13 @@ impl<'cx, 'gcx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx\n                 target: _,\n                 unwind: _,\n             } => {\n-                let gcx = self.tcx.global_tcx();\n+                let gcx = self.infcx.tcx.global_tcx();\n \n                 // Compute the type with accurate region information.\n-                let drop_place_ty = drop_place.ty(self.mir, self.tcx);\n+                let drop_place_ty = drop_place.ty(self.mir, self.infcx.tcx);\n \n                 // Erase the regions.\n-                let drop_place_ty = self.tcx.erase_regions(&drop_place_ty).to_ty(self.tcx);\n+                let drop_place_ty = self.infcx.tcx.erase_regions(&drop_place_ty).to_ty(self.infcx.tcx);\n \n                 // \"Lift\" into the gcx -- once regions are erased, this type should be in the\n                 // global arenas; this \"lift\" operation basically just asserts that is true, but\n@@ -953,7 +953,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             return;\n         }\n \n-        let gcx = self.tcx.global_tcx();\n+        let gcx = self.infcx.tcx.global_tcx();\n         let drop_field = |mir: &mut MirBorrowckCtxt<'cx, 'gcx, 'tcx>,\n                           (index, field): (usize, ty::Ty<'gcx>)| {\n             let field_ty = gcx.normalize_erasing_regions(mir.param_env, field);\n@@ -971,7 +971,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             // individual fields instead. This way if `foo` has a\n             // destructor but `bar` does not, we will only check for\n             // borrows of `x.foo` and not `x.bar`. See #47703.\n-            ty::Adt(def, substs) if def.is_struct() && !def.has_dtor(self.tcx) => {\n+            ty::Adt(def, substs) if def.is_struct() && !def.has_dtor(self.infcx.tcx) => {\n                 def.all_fields()\n                     .map(|field| field.ty(gcx, substs))\n                     .enumerate()\n@@ -991,7 +991,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     && !self.mir.upvar_decls.is_empty() =>\n             {\n                 substs\n-                    .upvar_tys(def, self.tcx)\n+                    .upvar_tys(def, self.infcx.tcx)\n                     .enumerate()\n                     .for_each(|field| drop_field(self, field));\n             }\n@@ -1002,7 +1002,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     && !self.mir.upvar_decls.is_empty() =>\n             {\n                 substs\n-                    .upvar_tys(def, self.tcx)\n+                    .upvar_tys(def, self.infcx.tcx)\n                     .enumerate()\n                     .for_each(|field| drop_field(self, field));\n             }\n@@ -1168,7 +1168,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         );\n \n         let mut error_reported = false;\n-        let tcx = self.tcx;\n+        let tcx = self.infcx.tcx;\n         let mir = self.mir;\n         let location = self.location_table.start_index(context.loc);\n         let borrow_set = self.borrow_set.clone();\n@@ -1206,7 +1206,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 (Read(kind), BorrowKind::Unique) | (Read(kind), BorrowKind::Mut { .. }) => {\n                     // Reading from mere reservations of mutable-borrows is OK.\n                     if !is_active(&this.dominators, borrow, context.loc) {\n-                        assert!(allow_two_phase_borrow(&this.tcx, borrow.kind));\n+                        assert!(allow_two_phase_borrow(&this.infcx.tcx, borrow.kind));\n                         return Control::Continue;\n                     }\n \n@@ -1338,7 +1338,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     BorrowKind::Shared => (Deep, Read(ReadKind::Borrow(bk))),\n                     BorrowKind::Unique | BorrowKind::Mut { .. } => {\n                         let wk = WriteKind::MutableBorrow(bk);\n-                        if allow_two_phase_borrow(&self.tcx, bk) {\n+                        if allow_two_phase_borrow(&self.infcx.tcx, bk) {\n                             (Deep, Reservation(wk))\n                         } else {\n                             (Deep, Write(wk))\n@@ -1413,7 +1413,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     | AggregateKind::Generator(def_id, _, _) => {\n                         let BorrowCheckResult {\n                             used_mut_upvars, ..\n-                        } = self.tcx.mir_borrowck(def_id);\n+                        } = self.infcx.tcx.mir_borrowck(def_id);\n                         debug!(\"{:?} used_mut_upvars={:?}\", def_id, used_mut_upvars);\n                         for field in used_mut_upvars {\n                             // This relies on the current way that by-value\n@@ -1427,7 +1427,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                                 Operand::Move(ref place @ Place::Projection(_))\n                                 | Operand::Copy(ref place @ Place::Projection(_)) => {\n                                     if let Some(field) = place.is_upvar_field_projection(\n-                                            self.mir, &self.tcx) {\n+                                            self.mir, &self.infcx.tcx) {\n                                         self.used_mut_upvars.push(field);\n                                     }\n                                 }\n@@ -1546,11 +1546,11 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         // that is merged.\n         let sd = if might_be_alive { Deep } else { Shallow(None) };\n \n-        if places_conflict::places_conflict(self.tcx, self.mir, place, root_place, sd) {\n+        if places_conflict::places_conflict(self.infcx.tcx, self.mir, place, root_place, sd) {\n             debug!(\"check_for_invalidation_at_exit({:?}): INVALID\", place);\n             // FIXME: should be talking about the region lifetime instead\n             // of just a span here.\n-            let span = self.tcx.sess.source_map().end_point(span);\n+            let span = self.infcx.tcx.sess.source_map().end_point(span);\n             self.report_borrowed_value_does_not_live_long_enough(\n                 context,\n                 borrow,\n@@ -1566,7 +1566,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         debug!(\"check_for_local_borrow({:?})\", borrow);\n \n         if borrow_of_local_data(&borrow.borrowed_place) {\n-            let err = self.tcx\n+            let err = self.infcx.tcx\n                 .cannot_borrow_across_generator_yield(\n                     self.retrieve_borrow_spans(borrow).var_or_use(),\n                     yield_span,\n@@ -1583,7 +1583,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         span: Span,\n         flow_state: &Flows<'cx, 'gcx, 'tcx>,\n     ) {\n-        if !self.tcx.two_phase_borrows() {\n+        if !self.infcx.tcx.two_phase_borrows() {\n             return;\n         }\n \n@@ -1845,7 +1845,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                             // if type of `P` has a dtor, then\n                             // assigning to `P.f` requires `P` itself\n                             // be already initialized\n-                            let tcx = self.tcx;\n+                            let tcx = self.infcx.tcx;\n                             match base.ty(self.mir, tcx).to_ty(tcx).sty {\n                                 ty::Adt(def, _) if def.has_dtor(tcx) => {\n                                     self.check_if_path_or_subpath_is_moved(\n@@ -1929,7 +1929,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             | Write(wk @ WriteKind::StorageDeadOrDrop(_))\n             | Write(wk @ WriteKind::MutableBorrow(BorrowKind::Shared)) => {\n                 if let Err(_place_err) = self.is_mutable(place, is_local_mutation_allowed) {\n-                    if self.tcx.migrate_borrowck() {\n+                    if self.infcx.tcx.migrate_borrowck() {\n                         // rust-lang/rust#46908: In pure NLL mode this\n                         // code path should be unreachable (and thus\n                         // we signal an ICE in the else branch\n@@ -1952,7 +1952,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                             location,\n                         );\n                     } else {\n-                        self.tcx.sess.delay_span_bug(\n+                        self.infcx.tcx.sess.delay_span_bug(\n                             span,\n                             &format!(\n                                 \"Accessing `{:?}` with the kind `{:?}` shouldn't be possible\",\n@@ -2020,7 +2020,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 place: place @ Place::Projection(_),\n                 is_local_mutation_allowed: _,\n             } => {\n-                if let Some(field) = place.is_upvar_field_projection(self.mir, &self.tcx) {\n+                if let Some(field) = place.is_upvar_field_projection(self.mir, &self.infcx.tcx) {\n                     self.used_mut_upvars.push(field);\n                 }\n             }\n@@ -2070,7 +2070,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 is_local_mutation_allowed,\n             }),\n             Place::Static(ref static_) => {\n-                if self.tcx.is_static(static_.def_id) != Some(hir::Mutability::MutMutable) {\n+                if self.infcx.tcx.is_static(static_.def_id) != Some(hir::Mutability::MutMutable) {\n                     Err(place)\n                 } else {\n                     Ok(RootPlace {\n@@ -2082,7 +2082,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             Place::Projection(ref proj) => {\n                 match proj.elem {\n                     ProjectionElem::Deref => {\n-                        let base_ty = proj.base.ty(self.mir, self.tcx).to_ty(self.tcx);\n+                        let base_ty = proj.base.ty(self.mir, self.infcx.tcx).to_ty(self.infcx.tcx);\n \n                         // Check the kind of deref to decide\n                         match base_ty.sty {\n@@ -2094,7 +2094,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                                     // unique path to the `&mut`\n                                     hir::MutMutable => {\n                                         let mode = match place.is_upvar_field_projection(\n-                                            self.mir, &self.tcx)\n+                                            self.mir, &self.infcx.tcx)\n                                         {\n                                             Some(field)\n                                                 if {\n@@ -2140,7 +2140,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     | ProjectionElem::Subslice { .. }\n                     | ProjectionElem::Downcast(..) => {\n                         let upvar_field_projection = place.is_upvar_field_projection(\n-                            self.mir, &self.tcx);\n+                            self.mir, &self.infcx.tcx);\n                         if let Some(field) = upvar_field_projection {\n                             let decl = &self.mir.upvar_decls[field.index()];\n                             debug!("}, {"sha": "8a97f25ef58136372916f015d08804140a6158ff", "filename": "src/librustc_mir/borrow_check/move_errors.rs", "status": "modified", "additions": 23, "deletions": 22, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/650a61c484388283301e03c324b9ac58e1bcfe18/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/650a61c484388283301e03c324b9ac58e1bcfe18/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs?ref=650a61c484388283301e03c324b9ac58e1bcfe18", "patch": "@@ -244,30 +244,31 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n             let origin = Origin::Mir;\n             debug!(\"report: original_path={:?} span={:?}, kind={:?} \\\n                    original_path.is_upvar_field_projection={:?}\", original_path, span, kind,\n-                   original_path.is_upvar_field_projection(self.mir, &self.tcx));\n+                   original_path.is_upvar_field_projection(self.mir, &self.infcx.tcx));\n             (\n                 match kind {\n                     IllegalMoveOriginKind::Static => {\n-                        self.tcx.cannot_move_out_of(span, \"static item\", origin)\n+                        self.infcx.tcx.cannot_move_out_of(span, \"static item\", origin)\n                     }\n                     IllegalMoveOriginKind::BorrowedContent { target_place: place } => {\n                         // Inspect the type of the content behind the\n                         // borrow to provide feedback about why this\n                         // was a move rather than a copy.\n-                        let ty = place.ty(self.mir, self.tcx).to_ty(self.tcx);\n+                        let ty = place.ty(self.mir, self.infcx.tcx).to_ty(self.infcx.tcx);\n                         let is_upvar_field_projection =\n                             self.prefixes(&original_path, PrefixSet::All)\n-                            .any(|p| p.is_upvar_field_projection(self.mir, &self.tcx)\n+                            .any(|p| p.is_upvar_field_projection(self.mir, &self.infcx.tcx)\n                                  .is_some());\n                         match ty.sty {\n-                            ty::Array(..) | ty::Slice(..) => self\n-                                .tcx\n-                                .cannot_move_out_of_interior_noncopy(span, ty, None, origin),\n+                            ty::Array(..) | ty::Slice(..) =>\n+                                self.infcx.tcx.cannot_move_out_of_interior_noncopy(\n+                                    span, ty, None, origin\n+                                ),\n                             ty::Closure(def_id, closure_substs)\n                                 if !self.mir.upvar_decls.is_empty() && is_upvar_field_projection\n                             => {\n                                 let closure_kind_ty =\n-                                    closure_substs.closure_kind_ty(def_id, self.tcx);\n+                                    closure_substs.closure_kind_ty(def_id, self.infcx.tcx);\n                                 let closure_kind = closure_kind_ty.to_opt_closure_kind();\n                                 let place_description = match closure_kind {\n                                     Some(ty::ClosureKind::Fn) => {\n@@ -285,37 +286,38 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n                                        place_description={:?}\", closure_kind_ty, closure_kind,\n                                        place_description);\n \n-                                let mut diag = self.tcx.cannot_move_out_of(\n+                                let mut diag = self.infcx.tcx.cannot_move_out_of(\n                                     span, place_description, origin);\n \n                                 for prefix in self.prefixes(&original_path, PrefixSet::All) {\n                                     if let Some(field) = prefix.is_upvar_field_projection(\n-                                            self.mir, &self.tcx) {\n+                                            self.mir, &self.infcx.tcx) {\n                                         let upvar_decl = &self.mir.upvar_decls[field.index()];\n                                         let upvar_hir_id =\n                                             upvar_decl.var_hir_id.assert_crate_local();\n                                         let upvar_node_id =\n-                                            self.tcx.hir.hir_to_node_id(upvar_hir_id);\n-                                        let upvar_span = self.tcx.hir.span(upvar_node_id);\n+                                            self.infcx.tcx.hir.hir_to_node_id(upvar_hir_id);\n+                                        let upvar_span = self.infcx.tcx.hir.span(upvar_node_id);\n                                         diag.span_label(upvar_span, \"captured outer variable\");\n                                         break;\n                                     }\n                                 }\n \n                                 diag\n                             }\n-                            _ => self\n-                                .tcx\n-                                .cannot_move_out_of(span, \"borrowed content\", origin),\n+                            _ => self.infcx.tcx.cannot_move_out_of(\n+                                span, \"borrowed content\", origin\n+                            ),\n                         }\n                     }\n                     IllegalMoveOriginKind::InteriorOfTypeWithDestructor { container_ty: ty } => {\n-                        self.tcx\n+                        self.infcx.tcx\n                             .cannot_move_out_of_interior_of_drop(span, ty, origin)\n                     }\n-                    IllegalMoveOriginKind::InteriorOfSliceOrArray { ty, is_index } => self\n-                        .tcx\n-                        .cannot_move_out_of_interior_noncopy(span, ty, Some(*is_index), origin),\n+                    IllegalMoveOriginKind::InteriorOfSliceOrArray { ty, is_index } =>\n+                        self.infcx.tcx.cannot_move_out_of_interior_noncopy(\n+                            span, ty, Some(*is_index), origin\n+                        ),\n                 },\n                 span,\n             )\n@@ -331,7 +333,7 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n         err: &mut DiagnosticBuilder<'a>,\n         span: Span,\n     ) {\n-        let snippet = self.tcx.sess.source_map().span_to_snippet(span).unwrap();\n+        let snippet = self.infcx.tcx.sess.source_map().span_to_snippet(span).unwrap();\n         match error {\n             GroupedMoveError::MovesFromPlace {\n                 mut binds_to,\n@@ -394,8 +396,7 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n                     ..\n                 }))\n             ) = bind_to.is_user_variable {\n-                let pat_snippet = self\n-                    .tcx.sess.source_map()\n+                let pat_snippet = self.infcx.tcx.sess.source_map()\n                     .span_to_snippet(pat_span)\n                     .unwrap();\n                 if pat_snippet.starts_with('&') {"}, {"sha": "30555dbf26082a45c324ba286bc4947f6aa99cf6", "filename": "src/librustc_mir/borrow_check/mutability_errors.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/650a61c484388283301e03c324b9ac58e1bcfe18/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/650a61c484388283301e03c324b9ac58e1bcfe18/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs?ref=650a61c484388283301e03c324b9ac58e1bcfe18", "patch": "@@ -71,11 +71,11 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n                 elem: ProjectionElem::Field(upvar_index, _),\n             }) => {\n                 debug_assert!(is_closure_or_generator(\n-                    base.ty(self.mir, self.tcx).to_ty(self.tcx)\n+                    base.ty(self.mir, self.infcx.tcx).to_ty(self.infcx.tcx)\n                 ));\n \n                 item_msg = format!(\"`{}`\", access_place_desc.unwrap());\n-                if access_place.is_upvar_field_projection(self.mir, &self.tcx).is_some() {\n+                if access_place.is_upvar_field_projection(self.mir, &self.infcx.tcx).is_some() {\n                     reason = \", as it is not declared as mutable\".to_string();\n                 } else {\n                     let name = self.mir.upvar_decls[upvar_index.index()].debug_name;\n@@ -91,11 +91,11 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n                     item_msg = format!(\"`{}`\", access_place_desc.unwrap());\n                     debug_assert!(self.mir.local_decls[Local::new(1)].ty.is_region_ptr());\n                     debug_assert!(is_closure_or_generator(\n-                        the_place_err.ty(self.mir, self.tcx).to_ty(self.tcx)\n+                        the_place_err.ty(self.mir, self.infcx.tcx).to_ty(self.infcx.tcx)\n                     ));\n \n                     reason = if access_place.is_upvar_field_projection(self.mir,\n-                                                                       &self.tcx).is_some() {\n+                                                                       &self.infcx.tcx).is_some() {\n                         \", as it is a captured variable in a `Fn` closure\".to_string()\n                     } else {\n                         \", as `Fn` closures cannot mutate their captured variables\".to_string()\n@@ -116,7 +116,7 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n                     reason = \", as it is immutable for the pattern guard\".to_string();\n                 } else {\n                     let pointer_type =\n-                        if base.ty(self.mir, self.tcx).to_ty(self.tcx).is_region_ptr() {\n+                        if base.ty(self.mir, self.infcx.tcx).to_ty(self.infcx.tcx).is_region_ptr() {\n                             \"`&` reference\"\n                         } else {\n                             \"`*const` pointer\"\n@@ -145,7 +145,7 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n                     reason = String::new();\n                 } else {\n                     item_msg = format!(\"`{}`\", access_place_desc.unwrap());\n-                    let static_name = &self.tcx.item_name(*def_id);\n+                    let static_name = &self.infcx.tcx.item_name(*def_id);\n                     reason = format!(\", as `{}` is an immutable static item\", static_name);\n                 }\n             }\n@@ -177,14 +177,14 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n \n         let span = match error_access {\n             AccessKind::Move => {\n-                err = self.tcx\n+                err = self.infcx.tcx\n                     .cannot_move_out_of(span, &(item_msg + &reason), Origin::Mir);\n                 act = \"move\";\n                 acted_on = \"moved\";\n                 span\n             }\n             AccessKind::Mutate => {\n-                err = self.tcx\n+                err = self.infcx.tcx\n                     .cannot_assign(span, &(item_msg + &reason), Origin::Mir);\n                 act = \"assign\";\n                 acted_on = \"written\";\n@@ -196,7 +196,7 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n \n                 let borrow_spans = self.borrow_spans(span, location);\n                 let borrow_span = borrow_spans.args_or_use();\n-                err = self.tcx.cannot_borrow_path_as_mutable_because(\n+                err = self.infcx.tcx.cannot_borrow_path_as_mutable_because(\n                     borrow_span,\n                     &item_msg,\n                     &reason,\n@@ -242,16 +242,16 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n                 elem: ProjectionElem::Field(upvar_index, _),\n             }) => {\n                 debug_assert!(is_closure_or_generator(\n-                    base.ty(self.mir, self.tcx).to_ty(self.tcx)\n+                    base.ty(self.mir, self.infcx.tcx).to_ty(self.infcx.tcx)\n                 ));\n \n                 err.span_label(span, format!(\"cannot {ACT}\", ACT = act));\n \n                 let upvar_hir_id = self.mir.upvar_decls[upvar_index.index()]\n                     .var_hir_id\n                     .assert_crate_local();\n-                let upvar_node_id = self.tcx.hir.hir_to_node_id(upvar_hir_id);\n-                if let Some(Node::Binding(pat)) = self.tcx.hir.find(upvar_node_id) {\n+                let upvar_node_id = self.infcx.tcx.hir.hir_to_node_id(upvar_hir_id);\n+                if let Some(Node::Binding(pat)) = self.infcx.tcx.hir.find(upvar_node_id) {\n                     if let hir::PatKind::Binding(\n                         hir::BindingAnnotation::Unannotated,\n                         _,\n@@ -274,7 +274,7 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n             // a local variable, then just suggest the user remove it.\n             Place::Local(_)\n                 if {\n-                    if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(span) {\n+                    if let Ok(snippet) = self.infcx.tcx.sess.source_map().span_to_snippet(span) {\n                         snippet.starts_with(\"&mut \")\n                     } else {\n                         false\n@@ -317,15 +317,15 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n                 let local_decl = &self.mir.local_decls[*local];\n                 let suggestion = match local_decl.is_user_variable.as_ref().unwrap() {\n                     ClearCrossCrate::Set(mir::BindingForm::ImplicitSelf) => {\n-                        Some(suggest_ampmut_self(self.tcx, local_decl))\n+                        Some(suggest_ampmut_self(self.infcx.tcx, local_decl))\n                     }\n \n                     ClearCrossCrate::Set(mir::BindingForm::Var(mir::VarBindingForm {\n                         binding_mode: ty::BindingMode::BindByValue(_),\n                         opt_ty_info,\n                         ..\n                     })) => Some(suggest_ampmut(\n-                        self.tcx,\n+                        self.infcx.tcx,\n                         self.mir,\n                         *local,\n                         local_decl,\n@@ -337,7 +337,7 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n                         ..\n                     })) => {\n                         let pattern_span = local_decl.source_info.span;\n-                        suggest_ref_mut(self.tcx, pattern_span)\n+                        suggest_ref_mut(self.infcx.tcx, pattern_span)\n                             .map(|replacement| (pattern_span, replacement))\n                     }\n \n@@ -426,11 +426,11 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n                                 ..\n                             }\n                         ) = &self.mir.basic_blocks()[location.block].terminator {\n-                            if self.tcx.parent(id) == self.tcx.lang_items().index_trait() {\n-\n+                            let index_trait = self.infcx.tcx.lang_items().index_trait();\n+                            if self.infcx.tcx.parent(id) == index_trait {\n                                 let mut found = false;\n-                                self.tcx.for_each_relevant_impl(\n-                                    self.tcx.lang_items().index_mut_trait().unwrap(),\n+                                self.infcx.tcx.for_each_relevant_impl(\n+                                    self.infcx.tcx.lang_items().index_mut_trait().unwrap(),\n                                     substs.type_at(0),\n                                     |_relevant_impl| {\n                                         found = true;"}, {"sha": "755148b69925320286c8c95c1efb2f14d48e49c2", "filename": "src/librustc_mir/borrow_check/nll/explain_borrow/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/650a61c484388283301e03c324b9ac58e1bcfe18/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/650a61c484388283301e03c324b9ac58e1bcfe18/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs?ref=650a61c484388283301e03c324b9ac58e1bcfe18", "patch": "@@ -106,7 +106,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n         let regioncx = &self.nonlexical_regioncx;\n         let mir = self.mir;\n-        let tcx = self.tcx;\n+        let tcx = self.infcx.tcx;\n \n         let borrow_region_vid = regioncx.to_region_vid(borrow.region);\n         debug!("}, {"sha": "f73e08eb13521120b0266e9819d22633f8ea134c", "filename": "src/librustc_mir/borrow_check/prefixes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/650a61c484388283301e03c324b9ac58e1bcfe18/src%2Flibrustc_mir%2Fborrow_check%2Fprefixes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/650a61c484388283301e03c324b9ac58e1bcfe18/src%2Flibrustc_mir%2Fborrow_check%2Fprefixes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fprefixes.rs?ref=650a61c484388283301e03c324b9ac58e1bcfe18", "patch": "@@ -79,7 +79,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             next: Some(place),\n             kind,\n             mir: self.mir,\n-            tcx: self.tcx,\n+            tcx: self.infcx.tcx,\n         }\n     }\n }"}]}