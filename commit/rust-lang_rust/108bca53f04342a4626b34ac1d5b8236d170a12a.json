{"sha": "108bca53f04342a4626b34ac1d5b8236d170a12a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEwOGJjYTUzZjA0MzQyYTQ2MjZiMzRhYzFkNWI4MjM2ZDE3MGExMmE=", "commit": {"author": {"name": "P1start", "email": "rewi-github@whanau.org", "date": "2014-12-03T09:47:53Z"}, "committer": {"name": "P1start", "email": "rewi-github@whanau.org", "date": "2014-12-04T00:47:35Z"}, "message": "Make the parser\u2019s \u2018expected <foo>, found <bar>\u2019 errors more accurate\n\nAs an example of what this changes, the following code:\n\n    let x: [int ..4];\n\nCurrently spits out \u2018expected `]`, found `..`\u2019. However, a comma would also be\nvalid there, as would a number of other tokens. This change adjusts the parser\nto produce more accurate errors, so that that example now produces \u2018expected one\nof `(`, `+`, `,`, `::`, or `]`, found `..`\u2019.", "tree": {"sha": "aae9d6fe5650fbe061c011e6f77e8d386627cb69", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/aae9d6fe5650fbe061c011e6f77e8d386627cb69"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/108bca53f04342a4626b34ac1d5b8236d170a12a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/108bca53f04342a4626b34ac1d5b8236d170a12a", "html_url": "https://github.com/rust-lang/rust/commit/108bca53f04342a4626b34ac1d5b8236d170a12a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/108bca53f04342a4626b34ac1d5b8236d170a12a/comments", "author": {"login": "ftxqxd", "id": 2055302, "node_id": "MDQ6VXNlcjIwNTUzMDI=", "avatar_url": "https://avatars.githubusercontent.com/u/2055302?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ftxqxd", "html_url": "https://github.com/ftxqxd", "followers_url": "https://api.github.com/users/ftxqxd/followers", "following_url": "https://api.github.com/users/ftxqxd/following{/other_user}", "gists_url": "https://api.github.com/users/ftxqxd/gists{/gist_id}", "starred_url": "https://api.github.com/users/ftxqxd/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ftxqxd/subscriptions", "organizations_url": "https://api.github.com/users/ftxqxd/orgs", "repos_url": "https://api.github.com/users/ftxqxd/repos", "events_url": "https://api.github.com/users/ftxqxd/events{/privacy}", "received_events_url": "https://api.github.com/users/ftxqxd/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ftxqxd", "id": 2055302, "node_id": "MDQ6VXNlcjIwNTUzMDI=", "avatar_url": "https://avatars.githubusercontent.com/u/2055302?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ftxqxd", "html_url": "https://github.com/ftxqxd", "followers_url": "https://api.github.com/users/ftxqxd/followers", "following_url": "https://api.github.com/users/ftxqxd/following{/other_user}", "gists_url": "https://api.github.com/users/ftxqxd/gists{/gist_id}", "starred_url": "https://api.github.com/users/ftxqxd/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ftxqxd/subscriptions", "organizations_url": "https://api.github.com/users/ftxqxd/orgs", "repos_url": "https://api.github.com/users/ftxqxd/repos", "events_url": "https://api.github.com/users/ftxqxd/events{/privacy}", "received_events_url": "https://api.github.com/users/ftxqxd/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3a325c666d2cb7e297bf3057ff2442f96a79428b", "url": "https://api.github.com/repos/rust-lang/rust/commits/3a325c666d2cb7e297bf3057ff2442f96a79428b", "html_url": "https://github.com/rust-lang/rust/commit/3a325c666d2cb7e297bf3057ff2442f96a79428b"}], "stats": {"total": 250, "additions": 155, "deletions": 95}, "files": [{"sha": "c9d78eccdc70a401d0a1375ad472b015ed9628b3", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 115, "deletions": 68, "changes": 183, "blob_url": "https://github.com/rust-lang/rust/blob/108bca53f04342a4626b34ac1d5b8236d170a12a/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/108bca53f04342a4626b34ac1d5b8236d170a12a/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=108bca53f04342a4626b34ac1d5b8236d170a12a", "patch": "@@ -87,6 +87,7 @@ use std::mem;\n use std::num::Float;\n use std::rc::Rc;\n use std::iter;\n+use std::slice;\n \n bitflags! {\n     flags Restrictions: u8 {\n@@ -303,6 +304,22 @@ pub struct Parser<'a> {\n     /// name is not known. This does not change while the parser is descending\n     /// into modules, and sub-parsers have new values for this name.\n     pub root_module_name: Option<String>,\n+    pub expected_tokens: Vec<TokenType>,\n+}\n+\n+#[deriving(PartialEq, Eq, Clone)]\n+pub enum TokenType {\n+    Token(token::Token),\n+    Operator,\n+}\n+\n+impl TokenType {\n+    fn to_string(&self) -> String {\n+        match *self {\n+            TokenType::Token(ref t) => format!(\"`{}`\", Parser::token_to_string(t)),\n+            TokenType::Operator => \"an operator\".into_string(),\n+        }\n+    }\n }\n \n fn is_plain_ident_or_underscore(t: &token::Token) -> bool {\n@@ -347,6 +364,7 @@ impl<'a> Parser<'a> {\n             open_braces: Vec::new(),\n             owns_directory: true,\n             root_module_name: None,\n+            expected_tokens: Vec::new(),\n         }\n     }\n \n@@ -375,14 +393,18 @@ impl<'a> Parser<'a> {\n     /// Expect and consume the token t. Signal an error if\n     /// the next token is not t.\n     pub fn expect(&mut self, t: &token::Token) {\n-        if self.token == *t {\n-            self.bump();\n+        if self.expected_tokens.is_empty() {\n+            if self.token == *t {\n+                self.bump();\n+            } else {\n+                let token_str = Parser::token_to_string(t);\n+                let this_token_str = self.this_token_to_string();\n+                self.fatal(format!(\"expected `{}`, found `{}`\",\n+                                   token_str,\n+                                   this_token_str).as_slice())\n+            }\n         } else {\n-            let token_str = Parser::token_to_string(t);\n-            let this_token_str = self.this_token_to_string();\n-            self.fatal(format!(\"expected `{}`, found `{}`\",\n-                               token_str,\n-                               this_token_str).as_slice())\n+            self.expect_one_of(slice::ref_slice(t), &[]);\n         }\n     }\n \n@@ -392,15 +414,20 @@ impl<'a> Parser<'a> {\n     pub fn expect_one_of(&mut self,\n                          edible: &[token::Token],\n                          inedible: &[token::Token]) {\n-        fn tokens_to_string(tokens: &[token::Token]) -> String {\n+        fn tokens_to_string(tokens: &[TokenType]) -> String {\n             let mut i = tokens.iter();\n             // This might be a sign we need a connect method on Iterator.\n             let b = i.next()\n-                     .map_or(\"\".to_string(), |t| Parser::token_to_string(t));\n-            i.fold(b, |b,a| {\n-                let mut b = b;\n-                b.push_str(\"`, `\");\n-                b.push_str(Parser::token_to_string(a).as_slice());\n+                     .map_or(\"\".into_string(), |t| t.to_string());\n+            i.enumerate().fold(b, |mut b, (i, ref a)| {\n+                if tokens.len() > 2 && i == tokens.len() - 2 {\n+                    b.push_str(\", or \");\n+                } else if tokens.len() == 2 && i == tokens.len() - 2 {\n+                    b.push_str(\" or \");\n+                } else {\n+                    b.push_str(\", \");\n+                }\n+                b.push_str(&*a.to_string());\n                 b\n             })\n         }\n@@ -409,17 +436,21 @@ impl<'a> Parser<'a> {\n         } else if inedible.contains(&self.token) {\n             // leave it in the input\n         } else {\n-            let mut expected = edible.iter().map(|x| x.clone()).collect::<Vec<_>>();\n-            expected.push_all(inedible);\n+            let mut expected = edible.iter().map(|x| TokenType::Token(x.clone()))\n+                                            .collect::<Vec<_>>();\n+            expected.extend(inedible.iter().map(|x| TokenType::Token(x.clone())));\n+            expected.push_all(&*self.expected_tokens);\n+            expected.sort_by(|a, b| a.to_string().cmp(&b.to_string()));\n+            expected.dedup();\n             let expect = tokens_to_string(expected.as_slice());\n             let actual = self.this_token_to_string();\n             self.fatal(\n                 (if expected.len() != 1 {\n-                    (format!(\"expected one of `{}`, found `{}`\",\n+                    (format!(\"expected one of {}, found `{}`\",\n                              expect,\n                              actual))\n                 } else {\n-                    (format!(\"expected `{}`, found `{}`\",\n+                    (format!(\"expected {}, found `{}`\",\n                              expect,\n                              actual))\n                 }).as_slice()\n@@ -514,10 +545,20 @@ impl<'a> Parser<'a> {\n         spanned(lo, hi, node)\n     }\n \n+    /// Check if the next token is `tok`, and return `true` if so.\n+    ///\n+    /// This method is will automatically add `tok` to `expected_tokens` if `tok` is not\n+    /// encountered.\n+    pub fn check(&mut self, tok: &token::Token) -> bool {\n+        let is_present = self.token == *tok;\n+        if !is_present { self.expected_tokens.push(TokenType::Token(tok.clone())); }\n+        is_present\n+    }\n+\n     /// Consume token 'tok' if it exists. Returns true if the given\n     /// token was present, false otherwise.\n     pub fn eat(&mut self, tok: &token::Token) -> bool {\n-        let is_present = self.token == *tok;\n+        let is_present = self.check(tok);\n         if is_present { self.bump() }\n         is_present\n     }\n@@ -739,7 +780,7 @@ impl<'a> Parser<'a> {\n         // commas in generic parameters, because it can stop either after\n         // parsing a type or after parsing a comma.\n         for i in iter::count(0u, 1) {\n-            if self.token == token::Gt\n+            if self.check(&token::Gt)\n                 || self.token == token::BinOp(token::Shr)\n                 || self.token == token::Ge\n                 || self.token == token::BinOpEq(token::Shr) {\n@@ -798,7 +839,7 @@ impl<'a> Parser<'a> {\n               }\n               _ => ()\n             }\n-            if sep.trailing_sep_allowed && self.token == *ket { break; }\n+            if sep.trailing_sep_allowed && self.check(ket) { break; }\n             v.push(f(self));\n         }\n         return v;\n@@ -881,6 +922,7 @@ impl<'a> Parser<'a> {\n         self.span = next.sp;\n         self.token = next.tok;\n         self.tokens_consumed += 1u;\n+        self.expected_tokens.clear();\n     }\n \n     /// Advance the parser by one token and return the bumped token.\n@@ -999,7 +1041,7 @@ impl<'a> Parser<'a> {\n             self.parse_proc_type(lifetime_defs)\n         } else if self.token_is_bare_fn_keyword() || self.token_is_closure_keyword() {\n             self.parse_ty_bare_fn_or_ty_closure(lifetime_defs)\n-        } else if self.token == token::ModSep ||\n+        } else if self.check(&token::ModSep) ||\n                   self.token.is_ident() ||\n                   self.token.is_path()\n         {\n@@ -1101,7 +1143,7 @@ impl<'a> Parser<'a> {\n     /// Parses an optional unboxed closure kind (`&:`, `&mut:`, or `:`).\n     pub fn parse_optional_unboxed_closure_kind(&mut self)\n                                                -> Option<UnboxedClosureKind> {\n-        if self.token == token::BinOp(token::And) &&\n+        if self.check(&token::BinOp(token::And)) &&\n                 self.look_ahead(1, |t| t.is_keyword(keywords::Mut)) &&\n                 self.look_ahead(2, |t| *t == token::Colon) {\n             self.bump();\n@@ -1211,7 +1253,8 @@ impl<'a> Parser<'a> {\n                                   lifetime_defs: Vec<ast::LifetimeDef>)\n                                   -> Vec<ast::LifetimeDef>\n     {\n-        if self.eat(&token::Lt) {\n+        if self.token == token::Lt {\n+            self.bump();\n             if lifetime_defs.is_empty() {\n                 self.warn(\"deprecated syntax; use the `for` keyword now \\\n                             (e.g. change `fn<'a>` to `for<'a> fn`)\");\n@@ -1430,7 +1473,7 @@ impl<'a> Parser<'a> {\n \n         let lo = self.span.lo;\n \n-        let t = if self.token == token::OpenDelim(token::Paren) {\n+        let t = if self.check(&token::OpenDelim(token::Paren)) {\n             self.bump();\n \n             // (t) is a parenthesized ty\n@@ -1440,7 +1483,7 @@ impl<'a> Parser<'a> {\n             let mut last_comma = false;\n             while self.token != token::CloseDelim(token::Paren) {\n                 ts.push(self.parse_ty_sum());\n-                if self.token == token::Comma {\n+                if self.check(&token::Comma) {\n                     last_comma = true;\n                     self.bump();\n                 } else {\n@@ -1464,11 +1507,11 @@ impl<'a> Parser<'a> {\n                 _ => self.obsolete(last_span, ObsoleteOwnedType)\n             }\n             TyTup(vec![self.parse_ty()])\n-        } else if self.token == token::BinOp(token::Star) {\n+        } else if self.check(&token::BinOp(token::Star)) {\n             // STAR POINTER (bare pointer?)\n             self.bump();\n             TyPtr(self.parse_ptr())\n-        } else if self.token == token::OpenDelim(token::Bracket) {\n+        } else if self.check(&token::OpenDelim(token::Bracket)) {\n             // VECTOR\n             self.expect(&token::OpenDelim(token::Bracket));\n             let t = self.parse_ty_sum();\n@@ -1481,7 +1524,7 @@ impl<'a> Parser<'a> {\n             };\n             self.expect(&token::CloseDelim(token::Bracket));\n             t\n-        } else if self.token == token::BinOp(token::And) ||\n+        } else if self.check(&token::BinOp(token::And)) ||\n                   self.token == token::AndAnd {\n             // BORROWED POINTER\n             self.expect_and();\n@@ -1492,7 +1535,7 @@ impl<'a> Parser<'a> {\n                   self.token_is_closure_keyword() {\n             // BARE FUNCTION OR CLOSURE\n             self.parse_ty_bare_fn_or_ty_closure(Vec::new())\n-        } else if self.token == token::BinOp(token::Or) ||\n+        } else if self.check(&token::BinOp(token::Or)) ||\n                   self.token == token::OrOr ||\n                   (self.token == token::Lt &&\n                    self.look_ahead(1, |t| {\n@@ -1509,7 +1552,7 @@ impl<'a> Parser<'a> {\n             TyTypeof(e)\n         } else if self.eat_keyword(keywords::Proc) {\n             self.parse_proc_type(Vec::new())\n-        } else if self.token == token::Lt {\n+        } else if self.check(&token::Lt) {\n             // QUALIFIED PATH `<TYPE as TRAIT_REF>::item`\n             self.bump();\n             let self_type = self.parse_ty_sum();\n@@ -1523,7 +1566,7 @@ impl<'a> Parser<'a> {\n                 trait_ref: P(trait_ref),\n                 item_name: item_name,\n             }))\n-        } else if self.token == token::ModSep ||\n+        } else if self.check(&token::ModSep) ||\n                   self.token.is_ident() ||\n                   self.token.is_path() {\n             // NAMED TYPE\n@@ -1532,7 +1575,8 @@ impl<'a> Parser<'a> {\n             // TYPE TO BE INFERRED\n             TyInfer\n         } else {\n-            let msg = format!(\"expected type, found token {}\", self.token);\n+            let this_token_str = self.this_token_to_string();\n+            let msg = format!(\"expected type, found `{}`\", this_token_str);\n             self.fatal(msg.as_slice());\n         };\n \n@@ -1635,7 +1679,7 @@ impl<'a> Parser<'a> {\n     }\n \n     pub fn maybe_parse_fixed_vstore(&mut self) -> Option<P<ast::Expr>> {\n-        if self.token == token::Comma &&\n+        if self.check(&token::Comma) &&\n                 self.look_ahead(1, |t| *t == token::DotDot) {\n             self.bump();\n             self.bump();\n@@ -1959,9 +2003,10 @@ impl<'a> Parser<'a> {\n                 token::Gt => { return res; }\n                 token::BinOp(token::Shr) => { return res; }\n                 _ => {\n+                    let this_token_str = self.this_token_to_string();\n                     let msg = format!(\"expected `,` or `>` after lifetime \\\n-                                      name, got: {}\",\n-                                      self.token);\n+                                      name, found `{}`\",\n+                                      this_token_str);\n                     self.fatal(msg.as_slice());\n                 }\n             }\n@@ -2126,7 +2171,7 @@ impl<'a> Parser<'a> {\n                     es.push(self.parse_expr());\n                     self.commit_expr(&**es.last().unwrap(), &[],\n                                      &[token::Comma, token::CloseDelim(token::Paren)]);\n-                    if self.token == token::Comma {\n+                    if self.check(&token::Comma) {\n                         trailing_comma = true;\n \n                         self.bump();\n@@ -2167,22 +2212,22 @@ impl<'a> Parser<'a> {\n             token::OpenDelim(token::Bracket) => {\n                 self.bump();\n \n-                if self.token == token::CloseDelim(token::Bracket) {\n+                if self.check(&token::CloseDelim(token::Bracket)) {\n                     // Empty vector.\n                     self.bump();\n                     ex = ExprVec(Vec::new());\n                 } else {\n                     // Nonempty vector.\n                     let first_expr = self.parse_expr();\n-                    if self.token == token::Comma &&\n+                    if self.check(&token::Comma) &&\n                         self.look_ahead(1, |t| *t == token::DotDot) {\n                         // Repeating vector syntax: [ 0, ..512 ]\n                         self.bump();\n                         self.bump();\n                         let count = self.parse_expr();\n                         self.expect(&token::CloseDelim(token::Bracket));\n                         ex = ExprRepeat(first_expr, count);\n-                    } else if self.token == token::Comma {\n+                    } else if self.check(&token::Comma) {\n                         // Vector with two or more elements.\n                         self.bump();\n                         let remaining_exprs = self.parse_seq_to_end(\n@@ -2284,15 +2329,15 @@ impl<'a> Parser<'a> {\n                         ex = ExprBreak(None);\n                     }\n                     hi = self.span.hi;\n-                } else if self.token == token::ModSep ||\n+                } else if self.check(&token::ModSep) ||\n                         self.token.is_ident() &&\n                         !self.token.is_keyword(keywords::True) &&\n                         !self.token.is_keyword(keywords::False) {\n                     let pth =\n                         self.parse_path(LifetimeAndTypesWithColons);\n \n                     // `!`, as an operator, is prefix, so we know this isn't that\n-                    if self.token == token::Not {\n+                    if self.check(&token::Not) {\n                         // MACRO INVOCATION expression\n                         self.bump();\n \n@@ -2309,7 +2354,7 @@ impl<'a> Parser<'a> {\n                                                            tts,\n                                                            EMPTY_CTXT));\n                     }\n-                    if self.token == token::OpenDelim(token::Brace) {\n+                    if self.check(&token::OpenDelim(token::Brace)) {\n                         // This is a struct literal, unless we're prohibited\n                         // from parsing struct literals here.\n                         if !self.restrictions.contains(RESTRICTION_NO_STRUCT_LITERAL) {\n@@ -2840,6 +2885,7 @@ impl<'a> Parser<'a> {\n             self.restrictions.contains(RESTRICTION_NO_BAR_OP) {\n             return lhs;\n         }\n+        self.expected_tokens.push(TokenType::Operator);\n \n         let cur_opt = self.token.to_binop();\n         match cur_opt {\n@@ -3079,7 +3125,7 @@ impl<'a> Parser<'a> {\n \n     /// Parse the RHS of a local variable declaration (e.g. '= 14;')\n     fn parse_initializer(&mut self) -> Option<P<Expr>> {\n-        if self.token == token::Eq {\n+        if self.check(&token::Eq) {\n             self.bump();\n             Some(self.parse_expr())\n         } else {\n@@ -3092,7 +3138,7 @@ impl<'a> Parser<'a> {\n         let mut pats = Vec::new();\n         loop {\n             pats.push(self.parse_pat());\n-            if self.token == token::BinOp(token::Or) { self.bump(); }\n+            if self.check(&token::BinOp(token::Or)) { self.bump(); }\n             else { return pats; }\n         };\n     }\n@@ -3114,11 +3160,11 @@ impl<'a> Parser<'a> {\n             }\n \n             if before_slice {\n-                if self.token == token::DotDot {\n+                if self.check(&token::DotDot) {\n                     self.bump();\n \n-                    if self.token == token::Comma ||\n-                            self.token == token::CloseDelim(token::Bracket) {\n+                    if self.check(&token::Comma) ||\n+                            self.check(&token::CloseDelim(token::Bracket)) {\n                         slice = Some(P(ast::Pat {\n                             id: ast::DUMMY_NODE_ID,\n                             node: PatWild(PatWildMulti),\n@@ -3135,7 +3181,7 @@ impl<'a> Parser<'a> {\n             }\n \n             let subpat = self.parse_pat();\n-            if before_slice && self.token == token::DotDot {\n+            if before_slice && self.check(&token::DotDot) {\n                 self.bump();\n                 slice = Some(subpat);\n                 before_slice = false;\n@@ -3160,13 +3206,13 @@ impl<'a> Parser<'a> {\n             } else {\n                 self.expect(&token::Comma);\n                 // accept trailing commas\n-                if self.token == token::CloseDelim(token::Brace) { break }\n+                if self.check(&token::CloseDelim(token::Brace)) { break }\n             }\n \n             let lo = self.span.lo;\n             let hi;\n \n-            if self.token == token::DotDot {\n+            if self.check(&token::DotDot) {\n                 self.bump();\n                 if self.token != token::CloseDelim(token::Brace) {\n                     let token_str = self.this_token_to_string();\n@@ -3187,7 +3233,7 @@ impl<'a> Parser<'a> {\n \n             let fieldname = self.parse_ident();\n \n-            let (subpat, is_shorthand) = if self.token == token::Colon {\n+            let (subpat, is_shorthand) = if self.check(&token::Colon) {\n                 match bind_type {\n                     BindByRef(..) | BindByValue(MutMutable) => {\n                         let token_str = self.this_token_to_string();\n@@ -3267,15 +3313,15 @@ impl<'a> Parser<'a> {\n           token::OpenDelim(token::Paren) => {\n             // parse (pat,pat,pat,...) as tuple\n             self.bump();\n-            if self.token == token::CloseDelim(token::Paren) {\n+            if self.check(&token::CloseDelim(token::Paren)) {\n                 self.bump();\n                 pat = PatTup(vec![]);\n             } else {\n                 let mut fields = vec!(self.parse_pat());\n                 if self.look_ahead(1, |t| *t != token::CloseDelim(token::Paren)) {\n-                    while self.token == token::Comma {\n+                    while self.check(&token::Comma) {\n                         self.bump();\n-                        if self.token == token::CloseDelim(token::Paren) { break; }\n+                        if self.check(&token::CloseDelim(token::Paren)) { break; }\n                         fields.push(self.parse_pat());\n                     }\n                 }\n@@ -3318,7 +3364,7 @@ impl<'a> Parser<'a> {\n             // These expressions are limited to literals (possibly\n             // preceded by unary-minus) or identifiers.\n             let val = self.parse_literal_maybe_minus();\n-            if (self.token == token::DotDotDot) &&\n+            if (self.check(&token::DotDotDot)) &&\n                     self.look_ahead(1, |t| {\n                         *t != token::Comma && *t != token::CloseDelim(token::Bracket)\n                     }) {\n@@ -3621,7 +3667,7 @@ impl<'a> Parser<'a> {\n             let hi = self.span.hi;\n \n             if id.name == token::special_idents::invalid.name {\n-                if self.token == token::Dot {\n+                if self.check(&token::Dot) {\n                     let span = self.span;\n                     let token_string = self.this_token_to_string();\n                     self.span_err(span,\n@@ -3934,7 +3980,7 @@ impl<'a> Parser<'a> {\n \n         let bounds = self.parse_colon_then_ty_param_bounds();\n \n-        let default = if self.token == token::Eq {\n+        let default = if self.check(&token::Eq) {\n             self.bump();\n             Some(self.parse_ty_sum())\n         }\n@@ -4334,7 +4380,7 @@ impl<'a> Parser<'a> {\n                 (optional_unboxed_closure_kind, args)\n             }\n         };\n-        let output = if self.token == token::RArrow {\n+        let output = if self.check(&token::RArrow) {\n             self.parse_ret_ty()\n         } else {\n             Return(P(Ty {\n@@ -4359,7 +4405,7 @@ impl<'a> Parser<'a> {\n                                      seq_sep_trailing_allowed(token::Comma),\n                                      |p| p.parse_fn_block_arg());\n \n-        let output = if self.token == token::RArrow {\n+        let output = if self.check(&token::RArrow) {\n             self.parse_ret_ty()\n         } else {\n             Return(P(Ty {\n@@ -4616,7 +4662,7 @@ impl<'a> Parser<'a> {\n                                    token::get_ident(class_name)).as_slice());\n             }\n             self.bump();\n-        } else if self.token == token::OpenDelim(token::Paren) {\n+        } else if self.check(&token::OpenDelim(token::Paren)) {\n             // It's a tuple-like struct.\n             is_tuple_like = true;\n             fields = self.parse_unspanned_seq(\n@@ -4801,7 +4847,7 @@ impl<'a> Parser<'a> {\n     fn parse_item_mod(&mut self, outer_attrs: &[Attribute]) -> ItemInfo {\n         let id_span = self.span;\n         let id = self.parse_ident();\n-        if self.token == token::Semi {\n+        if self.check(&token::Semi) {\n             self.bump();\n             // This mod is in an external file. Let's go get it!\n             let (m, attrs) = self.eval_src_mod(id, outer_attrs, id_span);\n@@ -5044,7 +5090,8 @@ impl<'a> Parser<'a> {\n         let (maybe_path, ident) = match self.token {\n             token::Ident(..) => {\n                 let the_ident = self.parse_ident();\n-                let path = if self.eat(&token::Eq) {\n+                let path = if self.token == token::Eq {\n+                    self.bump();\n                     let path = self.parse_str();\n                     let span = self.span;\n                     self.obsolete(span, ObsoleteExternCrateRenaming);\n@@ -5184,7 +5231,7 @@ impl<'a> Parser<'a> {\n                                 token::get_ident(ident)).as_slice());\n                 }\n                 kind = StructVariantKind(struct_def);\n-            } else if self.token == token::OpenDelim(token::Paren) {\n+            } else if self.check(&token::OpenDelim(token::Paren)) {\n                 all_nullary = false;\n                 let arg_tys = self.parse_enum_variant_seq(\n                     &token::OpenDelim(token::Paren),\n@@ -5348,7 +5395,7 @@ impl<'a> Parser<'a> {\n                                         visibility,\n                                         maybe_append(attrs, extra_attrs));\n                 return IoviItem(item);\n-            } else if self.token == token::OpenDelim(token::Brace) {\n+            } else if self.check(&token::OpenDelim(token::Brace)) {\n                 return self.parse_item_foreign_mod(lo, opt_abi, visibility, attrs);\n             }\n \n@@ -5629,7 +5676,7 @@ impl<'a> Parser<'a> {\n     fn parse_view_path(&mut self) -> P<ViewPath> {\n         let lo = self.span.lo;\n \n-        if self.token == token::OpenDelim(token::Brace) {\n+        if self.check(&token::OpenDelim(token::Brace)) {\n             // use {foo,bar}\n             let idents = self.parse_unspanned_seq(\n                 &token::OpenDelim(token::Brace),\n@@ -5653,7 +5700,7 @@ impl<'a> Parser<'a> {\n             self.bump();\n             let path_lo = self.span.lo;\n             path = vec!(self.parse_ident());\n-            while self.token == token::ModSep {\n+            while self.check(&token::ModSep) {\n                 self.bump();\n                 let id = self.parse_ident();\n                 path.push(id);\n@@ -5677,7 +5724,7 @@ impl<'a> Parser<'a> {\n \n           token::ModSep => {\n             // foo::bar or foo::{a,b,c} or foo::*\n-            while self.token == token::ModSep {\n+            while self.check(&token::ModSep) {\n                 self.bump();\n \n                 match self.token {\n@@ -5846,7 +5893,7 @@ impl<'a> Parser<'a> {\n         loop {\n             match self.parse_foreign_item(attrs, macros_allowed) {\n                 IoviNone(returned_attrs) => {\n-                    if self.token == token::CloseDelim(token::Brace) {\n+                    if self.check(&token::CloseDelim(token::Brace)) {\n                         attrs = returned_attrs;\n                         break\n                     }"}, {"sha": "489f892726a3b4895ac8b03592dfb65a08b3b609", "filename": "src/test/compile-fail/better-expected.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/108bca53f04342a4626b34ac1d5b8236d170a12a/src%2Ftest%2Fcompile-fail%2Fbetter-expected.rs", "raw_url": "https://github.com/rust-lang/rust/raw/108bca53f04342a4626b34ac1d5b8236d170a12a/src%2Ftest%2Fcompile-fail%2Fbetter-expected.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbetter-expected.rs?ref=108bca53f04342a4626b34ac1d5b8236d170a12a", "patch": "@@ -0,0 +1,13 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    let x: [int ..3]; //~ ERROR expected one of `(`, `+`, `,`, `::`, or `]`, found `..`\n+}"}, {"sha": "621b480fe77d37b5fb2f35357c831a6ae43f26b3", "filename": "src/test/compile-fail/column-offset-1-based.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/108bca53f04342a4626b34ac1d5b8236d170a12a/src%2Ftest%2Fcompile-fail%2Fcolumn-offset-1-based.rs", "raw_url": "https://github.com/rust-lang/rust/raw/108bca53f04342a4626b34ac1d5b8236d170a12a/src%2Ftest%2Fcompile-fail%2Fcolumn-offset-1-based.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcolumn-offset-1-based.rs?ref=108bca53f04342a4626b34ac1d5b8236d170a12a", "patch": "@@ -8,4 +8,4 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-# //~ ERROR 11:1: 11:2 error: expected `[`, found `<eof>`\n+# //~ ERROR 11:1: 11:2 error: expected one of `!` or `[`, found `<eof>`"}, {"sha": "a598252f1b65e99c20e45a23594c19aa44283862", "filename": "src/test/compile-fail/empty-impl-semicolon.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/108bca53f04342a4626b34ac1d5b8236d170a12a/src%2Ftest%2Fcompile-fail%2Fempty-impl-semicolon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/108bca53f04342a4626b34ac1d5b8236d170a12a/src%2Ftest%2Fcompile-fail%2Fempty-impl-semicolon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fempty-impl-semicolon.rs?ref=108bca53f04342a4626b34ac1d5b8236d170a12a", "patch": "@@ -8,4 +8,4 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-impl Foo; //~ ERROR expected `{`, found `;`\n+impl Foo; //~ ERROR expected one of `(`, `+`, `::`, or `{`, found `;`"}, {"sha": "a8704f7545f06a25311c942ab2573e8d0f83fa58", "filename": "src/test/compile-fail/issue-1655.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/108bca53f04342a4626b34ac1d5b8236d170a12a/src%2Ftest%2Fcompile-fail%2Fissue-1655.rs", "raw_url": "https://github.com/rust-lang/rust/raw/108bca53f04342a4626b34ac1d5b8236d170a12a/src%2Ftest%2Fcompile-fail%2Fissue-1655.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-1655.rs?ref=108bca53f04342a4626b34ac1d5b8236d170a12a", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern:expected `[`, found `vec`\n+// error-pattern:expected one of `!` or `[`, found `vec`\n mod blade_runner {\n     #vec[doc(\n         brief = \"Blade Runner is probably the best movie ever\","}, {"sha": "6b67814aab33f930291a278e118bc392f894041f", "filename": "src/test/compile-fail/issue-19096.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/108bca53f04342a4626b34ac1d5b8236d170a12a/src%2Ftest%2Fcompile-fail%2Fissue-19096.rs", "raw_url": "https://github.com/rust-lang/rust/raw/108bca53f04342a4626b34ac1d5b8236d170a12a/src%2Ftest%2Fcompile-fail%2Fissue-19096.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-19096.rs?ref=108bca53f04342a4626b34ac1d5b8236d170a12a", "patch": "@@ -12,5 +12,5 @@\n \n fn main() {\n     let t = (42i, 42i);\n-    t.0::<int>; //~ ERROR expected one of `;`, `}`, found `::`\n+    t.0::<int>; //~ ERROR expected one of `.`, `;`, `}`, or an operator, found `::`\n }"}, {"sha": "16834f491659bdedb7ce6a04c5bcbfa4f15c8411", "filename": "src/test/compile-fail/issue-3036.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/108bca53f04342a4626b34ac1d5b8236d170a12a/src%2Ftest%2Fcompile-fail%2Fissue-3036.rs", "raw_url": "https://github.com/rust-lang/rust/raw/108bca53f04342a4626b34ac1d5b8236d170a12a/src%2Ftest%2Fcompile-fail%2Fissue-3036.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3036.rs?ref=108bca53f04342a4626b34ac1d5b8236d170a12a", "patch": "@@ -13,4 +13,4 @@\n fn main()\n {\n     let x = 3\n-} //~ ERROR: expected `;`, found `}`\n+} //~ ERROR: expected one of `.`, `;`, or an operator, found `}`"}, {"sha": "3e073d34f3261914fa34010a811ea6fc420cc98a", "filename": "src/test/compile-fail/match-vec-invalid.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/108bca53f04342a4626b34ac1d5b8236d170a12a/src%2Ftest%2Fcompile-fail%2Fmatch-vec-invalid.rs", "raw_url": "https://github.com/rust-lang/rust/raw/108bca53f04342a4626b34ac1d5b8236d170a12a/src%2Ftest%2Fcompile-fail%2Fmatch-vec-invalid.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmatch-vec-invalid.rs?ref=108bca53f04342a4626b34ac1d5b8236d170a12a", "patch": "@@ -11,7 +11,7 @@\n fn main() {\n     let a = Vec::new();\n     match a {\n-        [1, tail.., tail..] => {}, //~ ERROR: expected `,`, found `..`\n+        [1, tail.., tail..] => {}, //~ ERROR: expected one of `!`, `,`, or `@`, found `..`\n         _ => ()\n     }\n }"}, {"sha": "7add747fbfa53055c01f98e9eb2c9c79c2a19d0e", "filename": "src/test/compile-fail/multitrait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/108bca53f04342a4626b34ac1d5b8236d170a12a/src%2Ftest%2Fcompile-fail%2Fmultitrait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/108bca53f04342a4626b34ac1d5b8236d170a12a/src%2Ftest%2Fcompile-fail%2Fmultitrait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmultitrait.rs?ref=108bca53f04342a4626b34ac1d5b8236d170a12a", "patch": "@@ -12,7 +12,7 @@ struct S {\n  y: int\n }\n \n-impl Cmp, ToString for S { //~ ERROR: expected `{`, found `,`\n+impl Cmp, ToString for S { //~ ERROR: expected one of `(`, `+`, `::`, or `{`, found `,`\n   fn eq(&&other: S) { false }\n   fn to_string(&self) -> String { \"hi\".to_string() }\n }"}, {"sha": "a78e82bb73ca457d3c623afe0c32f1f631be29cd", "filename": "src/test/compile-fail/mut-patterns.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/108bca53f04342a4626b34ac1d5b8236d170a12a/src%2Ftest%2Fcompile-fail%2Fmut-patterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/108bca53f04342a4626b34ac1d5b8236d170a12a/src%2Ftest%2Fcompile-fail%2Fmut-patterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmut-patterns.rs?ref=108bca53f04342a4626b34ac1d5b8236d170a12a", "patch": "@@ -12,5 +12,5 @@\n \n pub fn main() {\n     struct Foo { x: int }\n-    let mut Foo { x: x } = Foo { x: 3 }; //~ ERROR: expected `;`, found `{`\n+    let mut Foo { x: x } = Foo { x: 3 }; //~ ERROR: expected one of `:`, `;`, `=`, or `@`, found `{`\n }"}, {"sha": "729b45df8b430823377fed370fd455d23c6def1e", "filename": "src/test/compile-fail/omitted-arg-in-item-fn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/108bca53f04342a4626b34ac1d5b8236d170a12a/src%2Ftest%2Fcompile-fail%2Fomitted-arg-in-item-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/108bca53f04342a4626b34ac1d5b8236d170a12a/src%2Ftest%2Fcompile-fail%2Fomitted-arg-in-item-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fomitted-arg-in-item-fn.rs?ref=108bca53f04342a4626b34ac1d5b8236d170a12a", "patch": "@@ -8,5 +8,5 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn foo(x) { //~ ERROR expected `:`, found `)`\n+fn foo(x) { //~ ERROR expected one of `!`, `:`, or `@`, found `)`\n }"}, {"sha": "7fe073a4c3d69360475d619033946fd58df3e71d", "filename": "src/test/compile-fail/pat-range-bad-dots.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/108bca53f04342a4626b34ac1d5b8236d170a12a/src%2Ftest%2Fcompile-fail%2Fpat-range-bad-dots.rs", "raw_url": "https://github.com/rust-lang/rust/raw/108bca53f04342a4626b34ac1d5b8236d170a12a/src%2Ftest%2Fcompile-fail%2Fpat-range-bad-dots.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fpat-range-bad-dots.rs?ref=108bca53f04342a4626b34ac1d5b8236d170a12a", "patch": "@@ -10,7 +10,7 @@\n \n pub fn main() {\n     match 22i {\n-        0 .. 3 => {} //~ ERROR expected `=>`, found `..`\n+        0 .. 3 => {} //~ ERROR expected one of `...`, `=>`, or `|`, found `..`\n         _ => {}\n     }\n }"}, {"sha": "3403b28fdc9c065b47eba8600cba5fd6d83c50b6", "filename": "src/test/compile-fail/raw-str-unbalanced.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/108bca53f04342a4626b34ac1d5b8236d170a12a/src%2Ftest%2Fcompile-fail%2Fraw-str-unbalanced.rs", "raw_url": "https://github.com/rust-lang/rust/raw/108bca53f04342a4626b34ac1d5b8236d170a12a/src%2Ftest%2Fcompile-fail%2Fraw-str-unbalanced.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fraw-str-unbalanced.rs?ref=108bca53f04342a4626b34ac1d5b8236d170a12a", "patch": "@@ -10,5 +10,5 @@\n \n static s: &'static str =\n     r#\"\n-      \"## //~ ERROR expected `;`, found `#`\n+      \"## //~ ERROR expected one of `.`, `;`, or an operator, found `#`\n ;"}, {"sha": "a07832d5bb7614e3e5de56a819a2b297dac55989", "filename": "src/test/compile-fail/removed-syntax-closure-lifetime.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/108bca53f04342a4626b34ac1d5b8236d170a12a/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-closure-lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/108bca53f04342a4626b34ac1d5b8236d170a12a/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-closure-lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-closure-lifetime.rs?ref=108bca53f04342a4626b34ac1d5b8236d170a12a", "patch": "@@ -8,4 +8,4 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-type closure = Box<lt/fn()>; //~ ERROR expected `,`, found `/`\n+type closure = Box<lt/fn()>; //~ ERROR expected one of `(`, `+`, `,`, `::`, or `>`, found `/`"}, {"sha": "ba1b5a616df9da414c04b5c011d2914d53bb9952", "filename": "src/test/compile-fail/removed-syntax-enum-newtype.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/108bca53f04342a4626b34ac1d5b8236d170a12a/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-enum-newtype.rs", "raw_url": "https://github.com/rust-lang/rust/raw/108bca53f04342a4626b34ac1d5b8236d170a12a/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-enum-newtype.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-enum-newtype.rs?ref=108bca53f04342a4626b34ac1d5b8236d170a12a", "patch": "@@ -8,4 +8,4 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-enum e = int; //~ ERROR expected `{`, found `=`\n+enum e = int; //~ ERROR expected one of `<` or `{`, found `=`"}, {"sha": "fe49d1f4a8d853187911b8ba6d1eddf409dc32c2", "filename": "src/test/compile-fail/removed-syntax-fixed-vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/108bca53f04342a4626b34ac1d5b8236d170a12a/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-fixed-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/108bca53f04342a4626b34ac1d5b8236d170a12a/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-fixed-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-fixed-vec.rs?ref=108bca53f04342a4626b34ac1d5b8236d170a12a", "patch": "@@ -8,4 +8,4 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-type v = [int * 3]; //~ ERROR expected `]`, found `*`\n+type v = [int * 3]; //~ ERROR expected one of `(`, `+`, `,`, `::`, or `]`, found `*`"}, {"sha": "1474cc9dd396d268f6321bb4fb6b6355939d20e0", "filename": "src/test/compile-fail/removed-syntax-larrow-init.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/108bca53f04342a4626b34ac1d5b8236d170a12a/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-larrow-init.rs", "raw_url": "https://github.com/rust-lang/rust/raw/108bca53f04342a4626b34ac1d5b8236d170a12a/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-larrow-init.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-larrow-init.rs?ref=108bca53f04342a4626b34ac1d5b8236d170a12a", "patch": "@@ -11,5 +11,5 @@\n fn removed_moves() {\n     let mut x = 0;\n     let y <- x;\n-    //~^ ERROR expected `;`, found `<-`\n+    //~^ ERROR expected one of `!`, `:`, `;`, `=`, or `@`, found `<-`\n }"}, {"sha": "552c9f2efa2de0366e6e1e957c340d079e58b06c", "filename": "src/test/compile-fail/removed-syntax-larrow-move.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/108bca53f04342a4626b34ac1d5b8236d170a12a/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-larrow-move.rs", "raw_url": "https://github.com/rust-lang/rust/raw/108bca53f04342a4626b34ac1d5b8236d170a12a/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-larrow-move.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-larrow-move.rs?ref=108bca53f04342a4626b34ac1d5b8236d170a12a", "patch": "@@ -12,5 +12,5 @@ fn removed_moves() {\n     let mut x = 0;\n     let y = 0;\n     y <- x;\n-    //~^ ERROR expected one of `;`, `}`, found `<-`\n+    //~^ ERROR expected one of `!`, `.`, `::`, `;`, `{`, `}`, or an operator, found `<-`\n }"}, {"sha": "437f871f8eabdde0023ed63f61522e76aa6fc7c7", "filename": "src/test/compile-fail/removed-syntax-mut-vec-expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/108bca53f04342a4626b34ac1d5b8236d170a12a/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-mut-vec-expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/108bca53f04342a4626b34ac1d5b8236d170a12a/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-mut-vec-expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-mut-vec-expr.rs?ref=108bca53f04342a4626b34ac1d5b8236d170a12a", "patch": "@@ -11,5 +11,5 @@\n fn f() {\n     let v = [mut 1, 2, 3, 4];\n     //~^  ERROR expected identifier, found keyword `mut`\n-    //~^^ ERROR expected `]`, found `1`\n+    //~^^ ERROR expected one of `!`, `,`, `.`, `::`, `]`, `{`, or an operator, found `1`\n }"}, {"sha": "af469fadf986d34b828006a85a17b90a73837b46", "filename": "src/test/compile-fail/removed-syntax-mut-vec-ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/108bca53f04342a4626b34ac1d5b8236d170a12a/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-mut-vec-ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/108bca53f04342a4626b34ac1d5b8236d170a12a/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-mut-vec-ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-mut-vec-ty.rs?ref=108bca53f04342a4626b34ac1d5b8236d170a12a", "patch": "@@ -10,4 +10,4 @@\n \n type v = [mut int];\n     //~^  ERROR expected identifier, found keyword `mut`\n-    //~^^ ERROR expected `]`, found `int`\n+    //~^^ ERROR expected one of `(`, `+`, `,`, `::`, or `]`, found `int`"}, {"sha": "1a1c4c9b40a159bcb15ae051e688602d9b2e9f5c", "filename": "src/test/compile-fail/removed-syntax-ptr-lifetime.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/108bca53f04342a4626b34ac1d5b8236d170a12a/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-ptr-lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/108bca53f04342a4626b34ac1d5b8236d170a12a/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-ptr-lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-ptr-lifetime.rs?ref=108bca53f04342a4626b34ac1d5b8236d170a12a", "patch": "@@ -8,4 +8,4 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-type bptr = &lifetime/int; //~ ERROR expected `;`, found `/`\n+type bptr = &lifetime/int; //~ ERROR expected one of `(`, `+`, `::`, or `;`, found `/`"}, {"sha": "ae5a68575f72f1bec9c5693a6e6270003360dcd1", "filename": "src/test/compile-fail/removed-syntax-record.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/108bca53f04342a4626b34ac1d5b8236d170a12a/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-record.rs", "raw_url": "https://github.com/rust-lang/rust/raw/108bca53f04342a4626b34ac1d5b8236d170a12a/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-record.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-record.rs?ref=108bca53f04342a4626b34ac1d5b8236d170a12a", "patch": "@@ -8,4 +8,4 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-type t = { f: () }; //~ ERROR expected type, found token OpenDelim(Brace)\n+type t = { f: () }; //~ ERROR expected type, found `{`"}, {"sha": "c5559c4ea9621f5aac6e93e4c9d5c326291fa680", "filename": "src/test/compile-fail/removed-syntax-uniq-mut-expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/108bca53f04342a4626b34ac1d5b8236d170a12a/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-uniq-mut-expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/108bca53f04342a4626b34ac1d5b8236d170a12a/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-uniq-mut-expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-uniq-mut-expr.rs?ref=108bca53f04342a4626b34ac1d5b8236d170a12a", "patch": "@@ -11,5 +11,5 @@\n fn f() {\n     let a_box = box mut 42;\n     //~^  ERROR expected identifier, found keyword `mut`\n-    //~^^ ERROR expected `;`, found `42`\n+    //~^^ ERROR expected one of `!`, `.`, `::`, `;`, `{`, or an operator, found `42`\n }"}, {"sha": "8c3db89bad236a14ca2f39896ff9c993684a2fab", "filename": "src/test/compile-fail/removed-syntax-uniq-mut-ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/108bca53f04342a4626b34ac1d5b8236d170a12a/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-uniq-mut-ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/108bca53f04342a4626b34ac1d5b8236d170a12a/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-uniq-mut-ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-uniq-mut-ty.rs?ref=108bca53f04342a4626b34ac1d5b8236d170a12a", "patch": "@@ -10,4 +10,4 @@\n \n type mut_box = Box<mut int>;\n     //~^  ERROR expected identifier, found keyword `mut`\n-    //~^^ ERROR expected `,`, found `int`\n+    //~^^ ERROR expected one of `(`, `+`, `,`, `::`, or `>`, found `int`"}, {"sha": "c7f31045cb6a2a60ae4d843c8260b51579d94a72", "filename": "src/test/compile-fail/removed-syntax-with-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/108bca53f04342a4626b34ac1d5b8236d170a12a/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-with-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/108bca53f04342a4626b34ac1d5b8236d170a12a/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-with-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-with-1.rs?ref=108bca53f04342a4626b34ac1d5b8236d170a12a", "patch": "@@ -16,5 +16,5 @@ fn removed_with() {\n \n     let a = S { foo: (), bar: () };\n     let b = S { foo: () with a };\n-    //~^ ERROR expected one of `,`, `}`, found `with`\n+    //~^ ERROR expected one of `,`, `.`, `}`, or an operator, found `with`\n }"}, {"sha": "a37197b889de80dec1437bae8d69a307bcd075f0", "filename": "src/test/compile-fail/struct-literal-in-for.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/108bca53f04342a4626b34ac1d5b8236d170a12a/src%2Ftest%2Fcompile-fail%2Fstruct-literal-in-for.rs", "raw_url": "https://github.com/rust-lang/rust/raw/108bca53f04342a4626b34ac1d5b8236d170a12a/src%2Ftest%2Fcompile-fail%2Fstruct-literal-in-for.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstruct-literal-in-for.rs?ref=108bca53f04342a4626b34ac1d5b8236d170a12a", "patch": "@@ -20,7 +20,7 @@ impl Foo {\n \n fn main() {\n     for x in Foo {\n-        x: 3    //~ ERROR expected one of `;`, `}`\n+        x: 3    //~ ERROR expected one of `!`, `.`, `::`, `;`, `{`, `}`, or an operator, found `:`\n     }.hi() {\n         println!(\"yo\");\n     }"}, {"sha": "9759e4f7bdaa991745a61f4d5a7e06344a2e4238", "filename": "src/test/compile-fail/struct-literal-in-if.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/108bca53f04342a4626b34ac1d5b8236d170a12a/src%2Ftest%2Fcompile-fail%2Fstruct-literal-in-if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/108bca53f04342a4626b34ac1d5b8236d170a12a/src%2Ftest%2Fcompile-fail%2Fstruct-literal-in-if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstruct-literal-in-if.rs?ref=108bca53f04342a4626b34ac1d5b8236d170a12a", "patch": "@@ -20,7 +20,7 @@ impl Foo {\n \n fn main() {\n     if Foo {\n-        x: 3    //~ ERROR expected one of `;`, `}`\n+        x: 3    //~ ERROR expected one of `!`, `.`, `::`, `;`, `{`, `}`, or an operator, found `:`\n     }.hi() {\n         println!(\"yo\");\n     }"}, {"sha": "297d3f7347f48bdd5779fe19cf1066a59b9485ca", "filename": "src/test/compile-fail/struct-literal-in-match-discriminant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/108bca53f04342a4626b34ac1d5b8236d170a12a/src%2Ftest%2Fcompile-fail%2Fstruct-literal-in-match-discriminant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/108bca53f04342a4626b34ac1d5b8236d170a12a/src%2Ftest%2Fcompile-fail%2Fstruct-literal-in-match-discriminant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstruct-literal-in-match-discriminant.rs?ref=108bca53f04342a4626b34ac1d5b8236d170a12a", "patch": "@@ -14,7 +14,7 @@ struct Foo {\n \n fn main() {\n     match Foo {\n-        x: 3    //~ ERROR expected `=>`\n+        x: 3    //~ ERROR expected one of `!`, `=>`, `@`, or `|`, found `:`\n     } {\n         Foo {\n             x: x"}, {"sha": "5b1679cf9a142c4272b3c61a9cf7acca5d03fc3d", "filename": "src/test/compile-fail/struct-literal-in-while.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/108bca53f04342a4626b34ac1d5b8236d170a12a/src%2Ftest%2Fcompile-fail%2Fstruct-literal-in-while.rs", "raw_url": "https://github.com/rust-lang/rust/raw/108bca53f04342a4626b34ac1d5b8236d170a12a/src%2Ftest%2Fcompile-fail%2Fstruct-literal-in-while.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstruct-literal-in-while.rs?ref=108bca53f04342a4626b34ac1d5b8236d170a12a", "patch": "@@ -20,7 +20,7 @@ impl Foo {\n \n fn main() {\n     while Foo {\n-        x: 3    //~ ERROR expected one of `;`, `}`\n+        x: 3    //~ ERROR expected one of `!`, `.`, `::`, `;`, `{`, `}`, or an operator, found `:`\n     }.hi() {\n         println!(\"yo\");\n     }"}]}