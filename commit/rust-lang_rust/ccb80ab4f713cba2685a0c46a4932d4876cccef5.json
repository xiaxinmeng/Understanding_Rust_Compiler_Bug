{"sha": "ccb80ab4f713cba2685a0c46a4932d4876cccef5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNjYjgwYWI0ZjcxM2NiYTI2ODVhMGM0NmE0OTMyZDQ4NzZjY2NlZjU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-09-20T09:01:13Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-09-20T09:01:13Z"}, "message": "auto merge of #9321 : chris-morgan/rust/lowercase-nan-methods, r=brson\n\nThis is for consistency in naming conventions.\r\n\r\n- ``std::num::Float::NaN()`` is changed to ``nan()``;\r\n- ``std::num::Float.is_NaN()`` is changed to ``is_nan()``; and\r\n- ``std::num::strconv::NumStrConv::NaN()`` is changed to ``nan()``.\r\n\r\nFixes #9319.", "tree": {"sha": "9c377458c57dfb4a1ec01192ea72cb42f31a5358", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9c377458c57dfb4a1ec01192ea72cb42f31a5358"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ccb80ab4f713cba2685a0c46a4932d4876cccef5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ccb80ab4f713cba2685a0c46a4932d4876cccef5", "html_url": "https://github.com/rust-lang/rust/commit/ccb80ab4f713cba2685a0c46a4932d4876cccef5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ccb80ab4f713cba2685a0c46a4932d4876cccef5/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e5fdc7dee52033f1097019d3aafe838db9ab5e3e", "url": "https://api.github.com/repos/rust-lang/rust/commits/e5fdc7dee52033f1097019d3aafe838db9ab5e3e", "html_url": "https://github.com/rust-lang/rust/commit/e5fdc7dee52033f1097019d3aafe838db9ab5e3e"}, {"sha": "d9874c0885118d1b4f55ca928dc5ba6d0adf88c6", "url": "https://api.github.com/repos/rust-lang/rust/commits/d9874c0885118d1b4f55ca928dc5ba6d0adf88c6", "html_url": "https://github.com/rust-lang/rust/commit/d9874c0885118d1b4f55ca928dc5ba6d0adf88c6"}], "stats": {"total": 276, "additions": 138, "deletions": 138}, "files": [{"sha": "8fc98ac10c7beac7da165bde9d31e4a2e610b058", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ccb80ab4f713cba2685a0c46a4932d4876cccef5/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccb80ab4f713cba2685a0c46a4932d4876cccef5/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=ccb80ab4f713cba2685a0c46a4932d4876cccef5", "patch": "@@ -126,7 +126,7 @@ pub fn check_arms(cx: &MatchCheckCtxt, arms: &[Arm]) {\n                     Some(&DefStatic(did, false)) => {\n                         let const_expr = lookup_const_by_id(cx.tcx, did).unwrap();\n                         match eval_const_expr(cx.tcx, const_expr) {\n-                            const_float(f) if f.is_NaN() => true,\n+                            const_float(f) if f.is_nan() => true,\n                             _ => false\n                         }\n                     }\n@@ -136,7 +136,7 @@ pub fn check_arms(cx: &MatchCheckCtxt, arms: &[Arm]) {\n             do walk_pat(*pat) |p| {\n                 if pat_matches_nan(p) {\n                     cx.tcx.sess.span_warn(p.span, \"unmatchable NaN in pattern, \\\n-                                                   use the is_NaN method in a guard instead\");\n+                                                   use the is_nan method in a guard instead\");\n                 }\n                 true\n             };"}, {"sha": "a2a0a1ab13b5c908f8a9ac3676a768aee88754f6", "filename": "src/libstd/num/f32.rs", "status": "modified", "additions": 36, "deletions": 36, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/ccb80ab4f713cba2685a0c46a4932d4876cccef5/src%2Flibstd%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccb80ab4f713cba2685a0c46a4932d4876cccef5/src%2Flibstd%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff32.rs?ref=ccb80ab4f713cba2685a0c46a4932d4876cccef5", "patch": "@@ -207,8 +207,8 @@ impl Orderable for f32 {\n     #[inline]\n     fn min(&self, other: &f32) -> f32 {\n         match () {\n-            _ if self.is_NaN()  => *self,\n-            _ if other.is_NaN() => *other,\n+            _ if self.is_nan()  => *self,\n+            _ if other.is_nan() => *other,\n             _ if *self < *other => *self,\n             _                   => *other,\n         }\n@@ -218,8 +218,8 @@ impl Orderable for f32 {\n     #[inline]\n     fn max(&self, other: &f32) -> f32 {\n         match () {\n-            _ if self.is_NaN()  => *self,\n-            _ if other.is_NaN() => *other,\n+            _ if self.is_nan()  => *self,\n+            _ if other.is_nan() => *other,\n             _ if *self > *other => *self,\n             _                   => *other,\n         }\n@@ -230,7 +230,7 @@ impl Orderable for f32 {\n     #[inline]\n     fn clamp(&self, mn: &f32, mx: &f32) -> f32 {\n         match () {\n-            _ if self.is_NaN()   => *self,\n+            _ if self.is_nan()   => *self,\n             _ if !(*self <= *mx) => *mx,\n             _ if !(*self >= *mn) => *mn,\n             _                    => *self,\n@@ -314,7 +314,7 @@ impl Signed for f32 {\n     ///\n     #[inline]\n     fn signum(&self) -> f32 {\n-        if self.is_NaN() { NaN } else { copysign(1.0, *self) }\n+        if self.is_nan() { NaN } else { copysign(1.0, *self) }\n     }\n \n     /// Returns `true` if the number is positive, including `+0.0` and `infinity`\n@@ -471,7 +471,7 @@ impl Hyperbolic for f32 {\n     #[inline]\n     fn acosh(&self) -> f32 {\n         match *self {\n-            x if x < 1.0 => Float::NaN(),\n+            x if x < 1.0 => Float::nan(),\n             x => (x + ((x * x) - 1.0).sqrt()).ln(),\n         }\n     }\n@@ -593,7 +593,7 @@ impl Primitive for f32 {\n \n impl Float for f32 {\n     #[inline]\n-    fn NaN() -> f32 { 0.0 / 0.0 }\n+    fn nan() -> f32 { 0.0 / 0.0 }\n \n     #[inline]\n     fn infinity() -> f32 { 1.0 / 0.0 }\n@@ -606,7 +606,7 @@ impl Float for f32 {\n \n     /// Returns `true` if the number is NaN\n     #[inline]\n-    fn is_NaN(&self) -> bool { *self != *self }\n+    fn is_nan(&self) -> bool { *self != *self }\n \n     /// Returns `true` if the number is infinite\n     #[inline]\n@@ -617,7 +617,7 @@ impl Float for f32 {\n     /// Returns `true` if the number is neither infinite or NaN\n     #[inline]\n     fn is_finite(&self) -> bool {\n-        !(self.is_NaN() || self.is_infinite())\n+        !(self.is_nan() || self.is_infinite())\n     }\n \n     /// Returns `true` if the number is neither zero, infinite, subnormal or NaN\n@@ -949,10 +949,10 @@ mod tests {\n         assert_eq!(8f32.clamp(&2f32, &4f32), 4f32);\n         assert_eq!(3f32.clamp(&2f32, &4f32), 3f32);\n \n-        let nan: f32 = Float::NaN();\n-        assert!(3f32.clamp(&nan, &4f32).is_NaN());\n-        assert!(3f32.clamp(&2f32, &nan).is_NaN());\n-        assert!(nan.clamp(&2f32, &4f32).is_NaN());\n+        let nan: f32 = Float::nan();\n+        assert!(3f32.clamp(&nan, &4f32).is_nan());\n+        assert!(3f32.clamp(&2f32, &nan).is_nan());\n+        assert!(nan.clamp(&2f32, &4f32).is_nan());\n     }\n \n     #[test]\n@@ -1032,25 +1032,25 @@ mod tests {\n \n         let inf: f32 = Float::infinity();\n         let neg_inf: f32 = Float::neg_infinity();\n-        let nan: f32 = Float::NaN();\n+        let nan: f32 = Float::nan();\n         assert_eq!(inf.asinh(), inf);\n         assert_eq!(neg_inf.asinh(), neg_inf);\n-        assert!(nan.asinh().is_NaN());\n+        assert!(nan.asinh().is_nan());\n         assert_approx_eq!(2.0f32.asinh(), 1.443635475178810342493276740273105f32);\n         assert_approx_eq!((-2.0f32).asinh(), -1.443635475178810342493276740273105f32);\n     }\n \n     #[test]\n     fn test_acosh() {\n         assert_eq!(1.0f32.acosh(), 0.0f32);\n-        assert!(0.999f32.acosh().is_NaN());\n+        assert!(0.999f32.acosh().is_nan());\n \n         let inf: f32 = Float::infinity();\n         let neg_inf: f32 = Float::neg_infinity();\n-        let nan: f32 = Float::NaN();\n+        let nan: f32 = Float::nan();\n         assert_eq!(inf.acosh(), inf);\n-        assert!(neg_inf.acosh().is_NaN());\n-        assert!(nan.acosh().is_NaN());\n+        assert!(neg_inf.acosh().is_nan());\n+        assert!(nan.acosh().is_nan());\n         assert_approx_eq!(2.0f32.acosh(), 1.31695789692481670862504634730796844f32);\n         assert_approx_eq!(3.0f32.acosh(), 1.76274717403908605046521864995958461f32);\n     }\n@@ -1065,15 +1065,15 @@ mod tests {\n         assert_eq!(1.0f32.atanh(), inf32);\n         assert_eq!((-1.0f32).atanh(), neg_inf32);\n \n-        assert!(2f64.atanh().atanh().is_NaN());\n-        assert!((-2f64).atanh().atanh().is_NaN());\n+        assert!(2f64.atanh().atanh().is_nan());\n+        assert!((-2f64).atanh().atanh().is_nan());\n \n         let inf64: f32 = Float::infinity();\n         let neg_inf64: f32 = Float::neg_infinity();\n-        let nan32: f32 = Float::NaN();\n-        assert!(inf64.atanh().is_NaN());\n-        assert!(neg_inf64.atanh().is_NaN());\n-        assert!(nan32.atanh().is_NaN());\n+        let nan32: f32 = Float::nan();\n+        assert!(inf64.atanh().is_nan());\n+        assert!(neg_inf64.atanh().is_nan());\n+        assert!(nan32.atanh().is_nan());\n \n         assert_approx_eq!(0.5f32.atanh(), 0.54930614433405484569762261846126285f32);\n         assert_approx_eq!((-0.5f32).atanh(), -0.54930614433405484569762261846126285f32);\n@@ -1125,7 +1125,7 @@ mod tests {\n         assert_eq!((-1f32).abs(), 1f32);\n         assert_eq!(neg_infinity.abs(), infinity);\n         assert_eq!((1f32/neg_infinity).abs(), 0f32);\n-        assert!(NaN.abs().is_NaN());\n+        assert!(NaN.abs().is_nan());\n     }\n \n     #[test]\n@@ -1142,8 +1142,8 @@ mod tests {\n \n     #[test] #[ignore(cfg(windows))] // FIXME #8663\n     fn test_abs_sub_nowin() {\n-        assert!(NaN.abs_sub(&-1f32).is_NaN());\n-        assert!(1f32.abs_sub(&NaN).is_NaN());\n+        assert!(NaN.abs_sub(&-1f32).is_nan());\n+        assert!(1f32.abs_sub(&NaN).is_nan());\n     }\n \n     #[test]\n@@ -1155,7 +1155,7 @@ mod tests {\n         assert_eq!((-1f32).signum(), -1f32);\n         assert_eq!(neg_infinity.signum(), -1f32);\n         assert_eq!((1f32/neg_infinity).signum(), -1f32);\n-        assert!(NaN.signum().is_NaN());\n+        assert!(NaN.signum().is_nan());\n     }\n \n     #[test]\n@@ -1200,7 +1200,7 @@ mod tests {\n \n     #[test]\n     fn test_is_normal() {\n-        let nan: f32 = Float::NaN();\n+        let nan: f32 = Float::nan();\n         let inf: f32 = Float::infinity();\n         let neg_inf: f32 = Float::neg_infinity();\n         let zero: f32 = Zero::zero();\n@@ -1217,7 +1217,7 @@ mod tests {\n \n     #[test]\n     fn test_classify() {\n-        let nan: f32 = Float::NaN();\n+        let nan: f32 = Float::nan();\n         let inf: f32 = Float::infinity();\n         let neg_inf: f32 = Float::neg_infinity();\n         let zero: f32 = Zero::zero();\n@@ -1246,10 +1246,10 @@ mod tests {\n \n         let inf: f32 = Float::infinity();\n         let neg_inf: f32 = Float::neg_infinity();\n-        let nan: f32 = Float::NaN();\n+        let nan: f32 = Float::nan();\n         assert_eq!(Float::ldexp(inf, -123), inf);\n         assert_eq!(Float::ldexp(neg_inf, -123), neg_inf);\n-        assert!(Float::ldexp(nan, -123).is_NaN());\n+        assert!(Float::ldexp(nan, -123).is_nan());\n     }\n \n     #[test]\n@@ -1273,9 +1273,9 @@ mod tests {\n     fn test_frexp_nowin() {\n         let inf: f32 = Float::infinity();\n         let neg_inf: f32 = Float::neg_infinity();\n-        let nan: f32 = Float::NaN();\n+        let nan: f32 = Float::nan();\n         assert_eq!(match inf.frexp() { (x, _) => x }, inf)\n         assert_eq!(match neg_inf.frexp() { (x, _) => x }, neg_inf)\n-        assert!(match nan.frexp() { (x, _) => x.is_NaN() })\n+        assert!(match nan.frexp() { (x, _) => x.is_nan() })\n     }\n }"}, {"sha": "826102cd43402e03ab05d9b41eef29916941c21a", "filename": "src/libstd/num/f64.rs", "status": "modified", "additions": 42, "deletions": 42, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/ccb80ab4f713cba2685a0c46a4932d4876cccef5/src%2Flibstd%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccb80ab4f713cba2685a0c46a4932d4876cccef5/src%2Flibstd%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff64.rs?ref=ccb80ab4f713cba2685a0c46a4932d4876cccef5", "patch": "@@ -230,8 +230,8 @@ impl Orderable for f64 {\n     #[inline]\n     fn min(&self, other: &f64) -> f64 {\n         match () {\n-            _ if self.is_NaN()  => *self,\n-            _ if other.is_NaN() => *other,\n+            _ if self.is_nan()  => *self,\n+            _ if other.is_nan() => *other,\n             _ if *self < *other => *self,\n             _                   => *other,\n         }\n@@ -241,8 +241,8 @@ impl Orderable for f64 {\n     #[inline]\n     fn max(&self, other: &f64) -> f64 {\n         match () {\n-            _ if self.is_NaN()  => *self,\n-            _ if other.is_NaN() => *other,\n+            _ if self.is_nan()  => *self,\n+            _ if other.is_nan() => *other,\n             _ if *self > *other => *self,\n             _                   => *other,\n         }\n@@ -253,7 +253,7 @@ impl Orderable for f64 {\n     #[inline]\n     fn clamp(&self, mn: &f64, mx: &f64) -> f64 {\n         match () {\n-            _ if self.is_NaN()   => *self,\n+            _ if self.is_nan()   => *self,\n             _ if !(*self <= *mx) => *mx,\n             _ if !(*self >= *mn) => *mn,\n             _                    => *self,\n@@ -331,7 +331,7 @@ impl Signed for f64 {\n     ///\n     #[inline]\n     fn signum(&self) -> f64 {\n-        if self.is_NaN() { NaN } else { copysign(1.0, *self) }\n+        if self.is_nan() { NaN } else { copysign(1.0, *self) }\n     }\n \n     /// Returns `true` if the number is positive, including `+0.0` and `infinity`\n@@ -488,7 +488,7 @@ impl Hyperbolic for f64 {\n     #[inline]\n     fn acosh(&self) -> f64 {\n         match *self {\n-            x if x < 1.0 => Float::NaN(),\n+            x if x < 1.0 => Float::nan(),\n             x => (x + ((x * x) - 1.0).sqrt()).ln(),\n         }\n     }\n@@ -640,7 +640,7 @@ impl Primitive for f64 {\n \n impl Float for f64 {\n     #[inline]\n-    fn NaN() -> f64 { 0.0 / 0.0 }\n+    fn nan() -> f64 { 0.0 / 0.0 }\n \n     #[inline]\n     fn infinity() -> f64 { 1.0 / 0.0 }\n@@ -653,7 +653,7 @@ impl Float for f64 {\n \n     /// Returns `true` if the number is NaN\n     #[inline]\n-    fn is_NaN(&self) -> bool { *self != *self }\n+    fn is_nan(&self) -> bool { *self != *self }\n \n     /// Returns `true` if the number is infinite\n     #[inline]\n@@ -664,7 +664,7 @@ impl Float for f64 {\n     /// Returns `true` if the number is neither infinite or NaN\n     #[inline]\n     fn is_finite(&self) -> bool {\n-        !(self.is_NaN() || self.is_infinite())\n+        !(self.is_nan() || self.is_infinite())\n     }\n \n     /// Returns `true` if the number is neither zero, infinite, subnormal or NaN\n@@ -983,19 +983,19 @@ mod tests {\n         assert_eq!(1f64.min(&2f64), 1f64);\n         assert_eq!(2f64.min(&1f64), 1f64);\n \n-        let nan: f64 = Float::NaN();\n-        assert!(1f64.min(&nan).is_NaN());\n-        assert!(nan.min(&1f64).is_NaN());\n+        let nan: f64 = Float::nan();\n+        assert!(1f64.min(&nan).is_nan());\n+        assert!(nan.min(&1f64).is_nan());\n     }\n \n     #[test]\n     fn test_max() {\n         assert_eq!(1f64.max(&2f64), 2f64);\n         assert_eq!(2f64.max(&1f64), 2f64);\n \n-        let nan: f64 = Float::NaN();\n-        assert!(1f64.max(&nan).is_NaN());\n-        assert!(nan.max(&1f64).is_NaN());\n+        let nan: f64 = Float::nan();\n+        assert!(1f64.max(&nan).is_nan());\n+        assert!(nan.max(&1f64).is_nan());\n     }\n \n     #[test]\n@@ -1004,10 +1004,10 @@ mod tests {\n         assert_eq!(8f64.clamp(&2f64, &4f64), 4f64);\n         assert_eq!(3f64.clamp(&2f64, &4f64), 3f64);\n \n-        let nan: f64 = Float::NaN();\n-        assert!(3f64.clamp(&nan, &4f64).is_NaN());\n-        assert!(3f64.clamp(&2f64, &nan).is_NaN());\n-        assert!(nan.clamp(&2f64, &4f64).is_NaN());\n+        let nan: f64 = Float::nan();\n+        assert!(3f64.clamp(&nan, &4f64).is_nan());\n+        assert!(3f64.clamp(&2f64, &nan).is_nan());\n+        assert!(nan.clamp(&2f64, &4f64).is_nan());\n     }\n \n     #[test]\n@@ -1087,25 +1087,25 @@ mod tests {\n \n         let inf: f64 = Float::infinity();\n         let neg_inf: f64 = Float::neg_infinity();\n-        let nan: f64 = Float::NaN();\n+        let nan: f64 = Float::nan();\n         assert_eq!(inf.asinh(), inf);\n         assert_eq!(neg_inf.asinh(), neg_inf);\n-        assert!(nan.asinh().is_NaN());\n+        assert!(nan.asinh().is_nan());\n         assert_approx_eq!(2.0f64.asinh(), 1.443635475178810342493276740273105f64);\n         assert_approx_eq!((-2.0f64).asinh(), -1.443635475178810342493276740273105f64);\n     }\n \n     #[test]\n     fn test_acosh() {\n         assert_eq!(1.0f64.acosh(), 0.0f64);\n-        assert!(0.999f64.acosh().is_NaN());\n+        assert!(0.999f64.acosh().is_nan());\n \n         let inf: f64 = Float::infinity();\n         let neg_inf: f64 = Float::neg_infinity();\n-        let nan: f64 = Float::NaN();\n+        let nan: f64 = Float::nan();\n         assert_eq!(inf.acosh(), inf);\n-        assert!(neg_inf.acosh().is_NaN());\n-        assert!(nan.acosh().is_NaN());\n+        assert!(neg_inf.acosh().is_nan());\n+        assert!(nan.acosh().is_nan());\n         assert_approx_eq!(2.0f64.acosh(), 1.31695789692481670862504634730796844f64);\n         assert_approx_eq!(3.0f64.acosh(), 1.76274717403908605046521864995958461f64);\n     }\n@@ -1117,14 +1117,14 @@ mod tests {\n \n         let inf: f64 = Float::infinity();\n         let neg_inf: f64 = Float::neg_infinity();\n-        let nan: f64 = Float::NaN();\n+        let nan: f64 = Float::nan();\n         assert_eq!(1.0f64.atanh(), inf);\n         assert_eq!((-1.0f64).atanh(), neg_inf);\n-        assert!(2f64.atanh().atanh().is_NaN());\n-        assert!((-2f64).atanh().atanh().is_NaN());\n-        assert!(inf.atanh().is_NaN());\n-        assert!(neg_inf.atanh().is_NaN());\n-        assert!(nan.atanh().is_NaN());\n+        assert!(2f64.atanh().atanh().is_nan());\n+        assert!((-2f64).atanh().atanh().is_nan());\n+        assert!(inf.atanh().is_nan());\n+        assert!(neg_inf.atanh().is_nan());\n+        assert!(nan.atanh().is_nan());\n         assert_approx_eq!(0.5f64.atanh(), 0.54930614433405484569762261846126285f64);\n         assert_approx_eq!((-0.5f64).atanh(), -0.54930614433405484569762261846126285f64);\n     }\n@@ -1175,7 +1175,7 @@ mod tests {\n         assert_eq!((-1f64).abs(), 1f64);\n         assert_eq!(neg_infinity.abs(), infinity);\n         assert_eq!((1f64/neg_infinity).abs(), 0f64);\n-        assert!(NaN.abs().is_NaN());\n+        assert!(NaN.abs().is_nan());\n     }\n \n     #[test]\n@@ -1192,8 +1192,8 @@ mod tests {\n \n     #[test] #[ignore(cfg(windows))] // FIXME #8663\n     fn test_abs_sub_nowin() {\n-        assert!(NaN.abs_sub(&-1f64).is_NaN());\n-        assert!(1f64.abs_sub(&NaN).is_NaN());\n+        assert!(NaN.abs_sub(&-1f64).is_nan());\n+        assert!(1f64.abs_sub(&NaN).is_nan());\n     }\n \n     #[test]\n@@ -1205,7 +1205,7 @@ mod tests {\n         assert_eq!((-1f64).signum(), -1f64);\n         assert_eq!(neg_infinity.signum(), -1f64);\n         assert_eq!((1f64/neg_infinity).signum(), -1f64);\n-        assert!(NaN.signum().is_NaN());\n+        assert!(NaN.signum().is_nan());\n     }\n \n     #[test]\n@@ -1250,7 +1250,7 @@ mod tests {\n \n     #[test]\n     fn test_is_normal() {\n-        let nan: f64 = Float::NaN();\n+        let nan: f64 = Float::nan();\n         let inf: f64 = Float::infinity();\n         let neg_inf: f64 = Float::neg_infinity();\n         let zero: f64 = Zero::zero();\n@@ -1267,7 +1267,7 @@ mod tests {\n \n     #[test]\n     fn test_classify() {\n-        let nan: f64 = Float::NaN();\n+        let nan: f64 = Float::nan();\n         let inf: f64 = Float::infinity();\n         let neg_inf: f64 = Float::neg_infinity();\n         let zero: f64 = Zero::zero();\n@@ -1295,10 +1295,10 @@ mod tests {\n \n         let inf: f64 = Float::infinity();\n         let neg_inf: f64 = Float::neg_infinity();\n-        let nan: f64 = Float::NaN();\n+        let nan: f64 = Float::nan();\n         assert_eq!(Float::ldexp(inf, -123), inf);\n         assert_eq!(Float::ldexp(neg_inf, -123), neg_inf);\n-        assert!(Float::ldexp(nan, -123).is_NaN());\n+        assert!(Float::ldexp(nan, -123).is_nan());\n     }\n \n     #[test]\n@@ -1322,9 +1322,9 @@ mod tests {\n     fn test_frexp_nowin() {\n         let inf: f64 = Float::infinity();\n         let neg_inf: f64 = Float::neg_infinity();\n-        let nan: f64 = Float::NaN();\n+        let nan: f64 = Float::nan();\n         assert_eq!(match inf.frexp() { (x, _) => x }, inf)\n         assert_eq!(match neg_inf.frexp() { (x, _) => x }, neg_inf)\n-        assert!(match nan.frexp() { (x, _) => x.is_NaN() })\n+        assert!(match nan.frexp() { (x, _) => x.is_nan() })\n     }\n }"}, {"sha": "dc46d4fec32ff3d391de94bbb2241ce2fc69a776", "filename": "src/libstd/num/float.rs", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/ccb80ab4f713cba2685a0c46a4932d4876cccef5/src%2Flibstd%2Fnum%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccb80ab4f713cba2685a0c46a4932d4876cccef5/src%2Flibstd%2Fnum%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ffloat.rs?ref=ccb80ab4f713cba2685a0c46a4932d4876cccef5", "patch": "@@ -807,8 +807,8 @@ impl Primitive for float {\n \n impl Float for float {\n     #[inline]\n-    fn NaN() -> float {\n-        let value: f64 = Float::NaN();\n+    fn nan() -> float {\n+        let value: f64 = Float::nan();\n         value as float\n     }\n \n@@ -832,7 +832,7 @@ impl Float for float {\n \n     /// Returns `true` if the number is NaN\n     #[inline]\n-    fn is_NaN(&self) -> bool { (*self as f64).is_NaN() }\n+    fn is_nan(&self) -> bool { (*self as f64).is_nan() }\n \n     /// Returns `true` if the number is infinite\n     #[inline]\n@@ -973,10 +973,10 @@ mod tests {\n         assert_eq!(1f.clamp(&2f, &4f), 2f);\n         assert_eq!(8f.clamp(&2f, &4f), 4f);\n         assert_eq!(3f.clamp(&2f, &4f), 3f);\n-        let nan: float = Float::NaN();\n-        assert!(3f.clamp(&nan, &4f).is_NaN());\n-        assert!(3f.clamp(&2f, &nan).is_NaN());\n-        assert!(nan.clamp(&2f, &4f).is_NaN());\n+        let nan: float = Float::nan();\n+        assert!(3f.clamp(&nan, &4f).is_nan());\n+        assert!(3f.clamp(&2f, &nan).is_nan());\n+        assert!(nan.clamp(&2f, &4f).is_nan());\n     }\n \n     #[test]\n@@ -1056,25 +1056,25 @@ mod tests {\n \n         let inf: float = Float::infinity();\n         let neg_inf: float = Float::neg_infinity();\n-        let nan: float = Float::NaN();\n+        let nan: float = Float::nan();\n         assert_eq!(inf.asinh(), inf);\n         assert_eq!(neg_inf.asinh(), neg_inf);\n-        assert!(nan.asinh().is_NaN());\n+        assert!(nan.asinh().is_nan());\n         assert_approx_eq!(2.0f.asinh(), 1.443635475178810342493276740273105f);\n         assert_approx_eq!((-2.0f).asinh(), -1.443635475178810342493276740273105f);\n     }\n \n     #[test]\n     fn test_acosh() {\n         assert_eq!(1.0f.acosh(), 0.0f);\n-        assert!(0.999f.acosh().is_NaN());\n+        assert!(0.999f.acosh().is_nan());\n \n         let inf: float = Float::infinity();\n         let neg_inf: float = Float::neg_infinity();\n-        let nan: float = Float::NaN();\n+        let nan: float = Float::nan();\n         assert_eq!(inf.acosh(), inf);\n-        assert!(neg_inf.acosh().is_NaN());\n-        assert!(nan.acosh().is_NaN());\n+        assert!(neg_inf.acosh().is_nan());\n+        assert!(nan.acosh().is_nan());\n         assert_approx_eq!(2.0f.acosh(), 1.31695789692481670862504634730796844f);\n         assert_approx_eq!(3.0f.acosh(), 1.76274717403908605046521864995958461f);\n     }\n@@ -1088,14 +1088,14 @@ mod tests {\n         let neg_inf: float = Float::neg_infinity();\n         let inf64: f64 = Float::infinity();\n         let neg_inf64: f64 = Float::neg_infinity();\n-        let nan: float = Float::NaN();\n+        let nan: float = Float::nan();\n         assert_eq!(1.0f.atanh(), inf);\n         assert_eq!((-1.0f).atanh(), neg_inf);\n-        assert!(2f64.atanh().atanh().is_NaN());\n-        assert!((-2f64).atanh().atanh().is_NaN());\n-        assert!(inf64.atanh().is_NaN());\n-        assert!(neg_inf64.atanh().is_NaN());\n-        assert!(nan.atanh().is_NaN());\n+        assert!(2f64.atanh().atanh().is_nan());\n+        assert!((-2f64).atanh().atanh().is_nan());\n+        assert!(inf64.atanh().is_nan());\n+        assert!(neg_inf64.atanh().is_nan());\n+        assert!(nan.atanh().is_nan());\n         assert_approx_eq!(0.5f.atanh(), 0.54930614433405484569762261846126285f);\n         assert_approx_eq!((-0.5f).atanh(), -0.54930614433405484569762261846126285f);\n     }\n@@ -1146,7 +1146,7 @@ mod tests {\n         assert_eq!((-1f).abs(), 1f);\n         assert_eq!(neg_infinity.abs(), infinity);\n         assert_eq!((1f/neg_infinity).abs(), 0f);\n-        assert!(NaN.abs().is_NaN());\n+        assert!(NaN.abs().is_nan());\n     }\n \n     #[test]\n@@ -1163,8 +1163,8 @@ mod tests {\n \n     #[test] #[ignore(cfg(windows))] // FIXME #8663\n     fn test_abs_sub_nowin() {\n-        assert!(NaN.abs_sub(&-1f).is_NaN());\n-        assert!(1f.abs_sub(&NaN).is_NaN());\n+        assert!(NaN.abs_sub(&-1f).is_nan());\n+        assert!(1f.abs_sub(&NaN).is_nan());\n     }\n \n     #[test]\n@@ -1176,7 +1176,7 @@ mod tests {\n         assert_eq!((-1f).signum(), -1f);\n         assert_eq!(neg_infinity.signum(), -1f);\n         assert_eq!((1f/neg_infinity).signum(), -1f);\n-        assert!(NaN.signum().is_NaN());\n+        assert!(NaN.signum().is_nan());\n     }\n \n     #[test]\n@@ -1221,7 +1221,7 @@ mod tests {\n \n     #[test]\n     fn test_is_normal() {\n-        let nan: float = Float::NaN();\n+        let nan: float = Float::nan();\n         let inf: float = Float::infinity();\n         let neg_inf: float = Float::neg_infinity();\n         let zero: float = Zero::zero();\n@@ -1238,7 +1238,7 @@ mod tests {\n \n     #[test]\n     fn test_classify() {\n-        let nan: float = Float::NaN();\n+        let nan: float = Float::nan();\n         let inf: float = Float::infinity();\n         let neg_inf: float = Float::neg_infinity();\n         let zero: float = Zero::zero();\n@@ -1267,10 +1267,10 @@ mod tests {\n \n         let inf: float = Float::infinity();\n         let neg_inf: float = Float::neg_infinity();\n-        let nan: float = Float::NaN();\n+        let nan: float = Float::nan();\n         assert_eq!(Float::ldexp(inf, -123), inf);\n         assert_eq!(Float::ldexp(neg_inf, -123), neg_inf);\n-        assert!(Float::ldexp(nan, -123).is_NaN());\n+        assert!(Float::ldexp(nan, -123).is_nan());\n     }\n \n     #[test]\n@@ -1294,10 +1294,10 @@ mod tests {\n     fn test_frexp_nowin() {\n         let inf: float = Float::infinity();\n         let neg_inf: float = Float::neg_infinity();\n-        let nan: float = Float::NaN();\n+        let nan: float = Float::nan();\n         assert_eq!(match inf.frexp() { (x, _) => x }, inf);\n         assert_eq!(match neg_inf.frexp() { (x, _) => x }, neg_inf);\n-        assert!(match nan.frexp() { (x, _) => x.is_NaN() })\n+        assert!(match nan.frexp() { (x, _) => x.is_nan() })\n     }\n \n     #[test]\n@@ -1328,7 +1328,7 @@ mod tests {\n         assert_eq!(from_str::<float>(\"-inf\"), Some(neg_infinity));\n         // note: NaN != NaN, hence this slightly complex test\n         match from_str::<float>(\"NaN\") {\n-            Some(f) => assert!(f.is_NaN()),\n+            Some(f) => assert!(f.is_nan()),\n             None => fail!()\n         }\n         // note: -0 == 0, hence these slightly more complex tests\n@@ -1375,7 +1375,7 @@ mod tests {\n         assert_eq!(from_str_hex(\"-inf\"), Some(neg_infinity));\n         // note: NaN != NaN, hence this slightly complex test\n         match from_str_hex(\"NaN\") {\n-            Some(f) => assert!(f.is_NaN()),\n+            Some(f) => assert!(f.is_nan()),\n             None => fail!()\n         }\n         // note: -0 == 0, hence these slightly more complex tests"}, {"sha": "634c86104fbabee655406cd294221715b650329d", "filename": "src/libstd/num/num.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ccb80ab4f713cba2685a0c46a4932d4876cccef5/src%2Flibstd%2Fnum%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccb80ab4f713cba2685a0c46a4932d4876cccef5/src%2Flibstd%2Fnum%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fnum.rs?ref=ccb80ab4f713cba2685a0c46a4932d4876cccef5", "patch": "@@ -320,12 +320,12 @@ pub trait Float: Real\n                + Primitive\n                + ApproxEq<Self> {\n     // FIXME (#5527): These should be associated constants\n-    fn NaN() -> Self;\n+    fn nan() -> Self;\n     fn infinity() -> Self;\n     fn neg_infinity() -> Self;\n     fn neg_zero() -> Self;\n \n-    fn is_NaN(&self) -> bool;\n+    fn is_nan(&self) -> bool;\n     fn is_infinite(&self) -> bool;\n     fn is_finite(&self) -> bool;\n     fn is_normal(&self) -> bool;"}, {"sha": "94156f6e81ffb8219be1fa5cc64ea89924f89d05", "filename": "src/libstd/num/strconv.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ccb80ab4f713cba2685a0c46a4932d4876cccef5/src%2Flibstd%2Fnum%2Fstrconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccb80ab4f713cba2685a0c46a4932d4876cccef5/src%2Flibstd%2Fnum%2Fstrconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fstrconv.rs?ref=ccb80ab4f713cba2685a0c46a4932d4876cccef5", "patch": "@@ -42,7 +42,7 @@ pub enum SignFormat {\n }\n \n pub trait NumStrConv {\n-    fn NaN()      -> Option<Self>;\n+    fn nan()      -> Option<Self>;\n     fn inf()      -> Option<Self>;\n     fn neg_inf()  -> Option<Self>;\n     fn neg_zero() -> Option<Self>;\n@@ -54,7 +54,7 @@ pub trait NumStrConv {\n macro_rules! impl_NumStrConv_Floating (($t:ty) => (\n     impl NumStrConv for $t {\n         #[inline]\n-        fn NaN()      -> Option<$t> { Some( 0.0 / 0.0) }\n+        fn nan()      -> Option<$t> { Some( 0.0 / 0.0) }\n         #[inline]\n         fn inf()      -> Option<$t> { Some( 1.0 / 0.0) }\n         #[inline]\n@@ -71,7 +71,7 @@ macro_rules! impl_NumStrConv_Floating (($t:ty) => (\n \n macro_rules! impl_NumStrConv_Integer (($t:ty) => (\n     impl NumStrConv for $t {\n-        #[inline] fn NaN()      -> Option<$t> { None }\n+        #[inline] fn nan()      -> Option<$t> { None }\n         #[inline] fn inf()      -> Option<$t> { None }\n         #[inline] fn neg_inf()  -> Option<$t> { None }\n         #[inline] fn neg_zero() -> Option<$t> { None }\n@@ -515,7 +515,7 @@ pub fn from_str_bytes_common<T:NumCast+Zero+One+Eq+Ord+Div<T,T>+\n                 return None;\n             }\n         } else if buf == NAN_BUF {\n-            return NumStrConv::NaN();\n+            return NumStrConv::nan();\n         }\n     }\n "}, {"sha": "db72740f483c2dfecae8a01ccf26bee344a2d496", "filename": "src/test/compile-fail/issue-6804.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ccb80ab4f713cba2685a0c46a4932d4876cccef5/src%2Ftest%2Fcompile-fail%2Fissue-6804.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccb80ab4f713cba2685a0c46a4932d4876cccef5/src%2Ftest%2Fcompile-fail%2Fissue-6804.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-6804.rs?ref=ccb80ab4f713cba2685a0c46a4932d4876cccef5", "patch": "@@ -8,12 +8,12 @@ fn main() {\n         NaN => {},\n         _ => {},\n     };\n-    //~^^^ WARNING unmatchable NaN in pattern, use the is_NaN method in a guard instead\n+    //~^^^ WARNING unmatchable NaN in pattern, use the is_nan method in a guard instead\n     match [x, 1.0] {\n         [NaN, _] => {},\n         _ => {},\n     };\n-    //~^^^ WARNING unmatchable NaN in pattern, use the is_NaN method in a guard instead\n+    //~^^^ WARNING unmatchable NaN in pattern, use the is_nan method in a guard instead\n }\n \n // At least one error is needed so that compilation fails"}, {"sha": "b34cc7863b254bdaa834ea4d104d27b54dc1b2ee", "filename": "src/test/run-pass/float-nan.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/ccb80ab4f713cba2685a0c46a4932d4876cccef5/src%2Ftest%2Frun-pass%2Ffloat-nan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccb80ab4f713cba2685a0c46a4932d4876cccef5/src%2Ftest%2Frun-pass%2Ffloat-nan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffloat-nan.rs?ref=ccb80ab4f713cba2685a0c46a4932d4876cccef5", "patch": "@@ -13,8 +13,8 @@ extern mod extra;\n use std::num::Float;\n \n pub fn main() {\n-  let nan: float = Float::NaN();\n-  assert!((nan).is_NaN());\n+  let nan: float = Float::nan();\n+  assert!((nan).is_nan());\n \n   let inf: float = Float::infinity();\n   let neg_inf: float = Float::neg_infinity();\n@@ -73,22 +73,22 @@ pub fn main() {\n   assert!(!(-inf < nan));\n   assert!(!(-nan < nan));\n \n-  assert!((nan + inf).is_NaN());\n-  assert!((nan + -inf).is_NaN());\n-  assert!((nan + 0.).is_NaN());\n-  assert!((nan + 1.).is_NaN());\n-  assert!((nan * 1.).is_NaN());\n-  assert!((nan / 1.).is_NaN());\n-  assert!((nan / 0.).is_NaN());\n-  assert!((0f/0f).is_NaN());\n-  assert!((-inf + inf).is_NaN());\n-  assert!((inf - inf).is_NaN());\n+  assert!((nan + inf).is_nan());\n+  assert!((nan + -inf).is_nan());\n+  assert!((nan + 0.).is_nan());\n+  assert!((nan + 1.).is_nan());\n+  assert!((nan * 1.).is_nan());\n+  assert!((nan / 1.).is_nan());\n+  assert!((nan / 0.).is_nan());\n+  assert!((0f/0f).is_nan());\n+  assert!((-inf + inf).is_nan());\n+  assert!((inf - inf).is_nan());\n \n-  assert!(!(-1f).is_NaN());\n-  assert!(!(0f).is_NaN());\n-  assert!(!(0.1f).is_NaN());\n-  assert!(!(1f).is_NaN());\n-  assert!(!(inf).is_NaN());\n-  assert!(!(-inf).is_NaN());\n-  assert!(!(1./-inf).is_NaN());\n+  assert!(!(-1f).is_nan());\n+  assert!(!(0f).is_nan());\n+  assert!(!(0.1f).is_nan());\n+  assert!(!(1f).is_nan());\n+  assert!(!(inf).is_nan());\n+  assert!(!(-inf).is_nan());\n+  assert!(!(1./-inf).is_nan());\n }"}]}