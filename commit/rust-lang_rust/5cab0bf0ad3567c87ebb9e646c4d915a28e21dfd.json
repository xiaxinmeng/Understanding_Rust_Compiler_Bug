{"sha": "5cab0bf0ad3567c87ebb9e646c4d915a28e21dfd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVjYWIwYmYwYWQzNTY3Yzg3ZWJiOWU2NDZjNGQ5MTVhMjhlMjFkZmQ=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-12-01T22:28:43Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-12-17T14:34:54Z"}, "message": "rustc_trans: always require alignment for load/store/memcpy.", "tree": {"sha": "c0f3f16074f83fdc42c026d42ac2f2526a4581b7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c0f3f16074f83fdc42c026d42ac2f2526a4581b7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5cab0bf0ad3567c87ebb9e646c4d915a28e21dfd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5cab0bf0ad3567c87ebb9e646c4d915a28e21dfd", "html_url": "https://github.com/rust-lang/rust/commit/5cab0bf0ad3567c87ebb9e646c4d915a28e21dfd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5cab0bf0ad3567c87ebb9e646c4d915a28e21dfd/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "16307465d5ab0ab0d51f57816a69c8f1eebce199", "url": "https://api.github.com/repos/rust-lang/rust/commits/16307465d5ab0ab0d51f57816a69c8f1eebce199", "html_url": "https://github.com/rust-lang/rust/commit/16307465d5ab0ab0d51f57816a69c8f1eebce199"}], "stats": {"total": 117, "additions": 56, "deletions": 61}, "files": [{"sha": "78ab25f222e50ed8e7a6cb991ba1fe4c9fe55200", "filename": "src/librustc_trans/abi.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5cab0bf0ad3567c87ebb9e646c4d915a28e21dfd/src%2Flibrustc_trans%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cab0bf0ad3567c87ebb9e646c4d915a28e21dfd/src%2Flibrustc_trans%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fabi.rs?ref=5cab0bf0ad3567c87ebb9e646c4d915a28e21dfd", "patch": "@@ -568,7 +568,7 @@ impl<'a, 'tcx> ArgType<'tcx> {\n             let can_store_through_cast_ptr = false;\n             if can_store_through_cast_ptr {\n                 let cast_dst = bcx.pointercast(dst.llval, cast.llvm_type(ccx).ptr_to());\n-                bcx.store(val, cast_dst, Some(self.layout.align));\n+                bcx.store(val, cast_dst, self.layout.align);\n             } else {\n                 // The actual return type is a struct, but the ABI\n                 // adaptation code has cast it into some scalar type.  The\n@@ -585,19 +585,20 @@ impl<'a, 'tcx> ArgType<'tcx> {\n                 //   bitcasting to the struct type yields invalid cast errors.\n \n                 // We instead thus allocate some scratch space...\n-                let llscratch = bcx.alloca(cast.llvm_type(ccx), \"abi_cast\", cast.align(ccx));\n                 let scratch_size = cast.size(ccx);\n+                let scratch_align = cast.align(ccx);\n+                let llscratch = bcx.alloca(cast.llvm_type(ccx), \"abi_cast\", scratch_align);\n                 bcx.lifetime_start(llscratch, scratch_size);\n \n                 // ...where we first store the value...\n-                bcx.store(val, llscratch, None);\n+                bcx.store(val, llscratch, scratch_align);\n \n                 // ...and then memcpy it to the intended destination.\n                 base::call_memcpy(bcx,\n                                   bcx.pointercast(dst.llval, Type::i8p(ccx)),\n                                   bcx.pointercast(llscratch, Type::i8p(ccx)),\n                                   C_usize(ccx, self.layout.size.bytes()),\n-                                  self.layout.align.min(cast.align(ccx)));\n+                                  self.layout.align.min(scratch_align));\n \n                 bcx.lifetime_end(llscratch, scratch_size);\n             }"}, {"sha": "911ec56188752c5abaab0416bd0affcf1de69ecd", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5cab0bf0ad3567c87ebb9e646c4d915a28e21dfd/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cab0bf0ad3567c87ebb9e646c4d915a28e21dfd/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=5cab0bf0ad3567c87ebb9e646c4d915a28e21dfd", "patch": "@@ -316,7 +316,7 @@ pub fn coerce_unsized_into<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n \n                 if src_f.layout.ty == dst_f.layout.ty {\n                     memcpy_ty(bcx, dst_f.llval, src_f.llval, src_f.layout,\n-                        Some(src_f.align.min(dst_f.align)));\n+                        src_f.align.min(dst_f.align));\n                 } else {\n                     coerce_unsized_into(bcx, src_f, dst_f);\n                 }\n@@ -430,14 +430,13 @@ pub fn memcpy_ty<'a, 'tcx>(\n     dst: ValueRef,\n     src: ValueRef,\n     layout: TyLayout<'tcx>,\n-    align: Option<Align>,\n+    align: Align,\n ) {\n     let size = layout.size.bytes();\n     if size == 0 {\n         return;\n     }\n \n-    let align = align.unwrap_or(layout.align);\n     call_memcpy(bcx, dst, src, C_usize(bcx.ccx, size), align);\n }\n "}, {"sha": "5b697d6b99c95d7a42a96b91291bed6a373610fe", "filename": "src/librustc_trans/builder.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5cab0bf0ad3567c87ebb9e646c4d915a28e21dfd/src%2Flibrustc_trans%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cab0bf0ad3567c87ebb9e646c4d915a28e21dfd/src%2Flibrustc_trans%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbuilder.rs?ref=5cab0bf0ad3567c87ebb9e646c4d915a28e21dfd", "patch": "@@ -518,13 +518,11 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         }\n     }\n \n-    pub fn load(&self, ptr: ValueRef, align: Option<Align>) -> ValueRef {\n+    pub fn load(&self, ptr: ValueRef, align: Align) -> ValueRef {\n         self.count_insn(\"load\");\n         unsafe {\n             let load = llvm::LLVMBuildLoad(self.llbuilder, ptr, noname());\n-            if let Some(align) = align {\n-                llvm::LLVMSetAlignment(load, align.abi() as c_uint);\n-            }\n+            llvm::LLVMSetAlignment(load, align.abi() as c_uint);\n             load\n         }\n     }\n@@ -573,16 +571,14 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         }\n     }\n \n-    pub fn store(&self, val: ValueRef, ptr: ValueRef, align: Option<Align>) -> ValueRef {\n+    pub fn store(&self, val: ValueRef, ptr: ValueRef, align: Align) -> ValueRef {\n         debug!(\"Store {:?} -> {:?}\", Value(val), Value(ptr));\n         assert!(!self.llbuilder.is_null());\n         self.count_insn(\"store\");\n         let ptr = self.check_store(val, ptr);\n         unsafe {\n             let store = llvm::LLVMBuildStore(self.llbuilder, val, ptr);\n-            if let Some(align) = align {\n-                llvm::LLVMSetAlignment(store, align.abi() as c_uint);\n-            }\n+            llvm::LLVMSetAlignment(store, align.abi() as c_uint);\n             store\n         }\n     }"}, {"sha": "f1cb8b224b3dc29ce9c74541bd8da2d05f97edd4", "filename": "src/librustc_trans/intrinsic.rs", "status": "modified", "additions": 26, "deletions": 19, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/5cab0bf0ad3567c87ebb9e646c4d915a28e21dfd/src%2Flibrustc_trans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cab0bf0ad3567c87ebb9e646c4d915a28e21dfd/src%2Flibrustc_trans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fintrinsic.rs?ref=5cab0bf0ad3567c87ebb9e646c4d915a28e21dfd", "patch": "@@ -254,7 +254,7 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n                 bcx.volatile_store(b, dst.project_field(bcx, 1).llval);\n             } else {\n                 let val = if let OperandValue::Ref(ptr, align) = args[1].val {\n-                    bcx.load(ptr, Some(align))\n+                    bcx.load(ptr, align)\n                 } else {\n                     if dst.layout.is_zst() {\n                         return;\n@@ -330,9 +330,9 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n                             let overflow = bcx.zext(bcx.extract_value(pair, 1), Type::bool(ccx));\n \n                             let dest = result.project_field(bcx, 0);\n-                            bcx.store(val, dest.llval, dest.non_abi_align());\n+                            bcx.store(val, dest.llval, dest.align);\n                             let dest = result.project_field(bcx, 1);\n-                            bcx.store(overflow, dest.llval, dest.non_abi_align());\n+                            bcx.store(overflow, dest.llval, dest.align);\n \n                             return;\n                         },\n@@ -473,9 +473,9 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n                         let success = bcx.zext(bcx.extract_value(pair, 1), Type::bool(bcx.ccx));\n \n                         let dest = result.project_field(bcx, 0);\n-                        bcx.store(val, dest.llval, dest.non_abi_align());\n+                        bcx.store(val, dest.llval, dest.align);\n                         let dest = result.project_field(bcx, 1);\n-                        bcx.store(success, dest.llval, dest.non_abi_align());\n+                        bcx.store(success, dest.llval, dest.align);\n                         return;\n                     } else {\n                         return invalid_monomorphization(ty);\n@@ -544,7 +544,7 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n             let tp_ty = substs.type_at(0);\n             let dst = args[0].deref(bcx.ccx);\n             let val = if let OperandValue::Ref(ptr, align) = args[1].val {\n-                bcx.load(ptr, Some(align))\n+                bcx.load(ptr, align)\n             } else {\n                 from_immediate(bcx, args[1].immediate())\n             };\n@@ -677,7 +677,7 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n                     for i in 0..elems.len() {\n                         let dest = result.project_field(bcx, i);\n                         let val = bcx.extract_value(val, i as u64);\n-                        bcx.store(val, dest.llval, dest.non_abi_align());\n+                        bcx.store(val, dest.llval, dest.align);\n                     }\n                     return;\n                 }\n@@ -688,8 +688,8 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n \n     if !fn_ty.ret.is_ignore() {\n         if let PassMode::Cast(ty) = fn_ty.ret.mode {\n-            let ptr = bcx.pointercast(llresult, ty.llvm_type(ccx).ptr_to());\n-            bcx.store(llval, ptr, Some(ccx.align_of(ret_ty)));\n+            let ptr = bcx.pointercast(result.llval, ty.llvm_type(ccx).ptr_to());\n+            bcx.store(llval, ptr, result.align);\n         } else {\n             OperandRef::from_immediate_or_packed_pair(bcx, llval, result.layout)\n                 .val.store(bcx, result);\n@@ -758,7 +758,8 @@ fn try_intrinsic<'a, 'tcx>(\n ) {\n     if bcx.sess().no_landing_pads() {\n         bcx.call(func, &[data], None);\n-        bcx.store(C_null(Type::i8p(&bcx.ccx)), dest, None);\n+        let ptr_align = bcx.tcx().data_layout.pointer_align;\n+        bcx.store(C_null(Type::i8p(&bcx.ccx)), dest, ptr_align);\n     } else if wants_msvc_seh(bcx.sess()) {\n         trans_msvc_try(bcx, ccx, func, data, local_ptr, dest);\n     } else {\n@@ -833,7 +834,8 @@ fn trans_msvc_try<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n         //\n         // More information can be found in libstd's seh.rs implementation.\n         let i64p = Type::i64(ccx).ptr_to();\n-        let slot = bcx.alloca(i64p, \"slot\", ccx.data_layout().pointer_align);\n+        let ptr_align = bcx.tcx().data_layout.pointer_align;\n+        let slot = bcx.alloca(i64p, \"slot\", ptr_align);\n         bcx.invoke(func, &[data], normal.llbb(), catchswitch.llbb(),\n             None);\n \n@@ -848,13 +850,15 @@ fn trans_msvc_try<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n             None => bug!(\"msvc_try_filter not defined\"),\n         };\n         let tok = catchpad.catch_pad(cs, &[tydesc, C_i32(ccx, 0), slot]);\n-        let addr = catchpad.load(slot, None);\n-        let arg1 = catchpad.load(addr, None);\n+        let addr = catchpad.load(slot, ptr_align);\n+\n+        let i64_align = bcx.tcx().data_layout.i64_align;\n+        let arg1 = catchpad.load(addr, i64_align);\n         let val1 = C_i32(ccx, 1);\n-        let arg2 = catchpad.load(catchpad.inbounds_gep(addr, &[val1]), None);\n+        let arg2 = catchpad.load(catchpad.inbounds_gep(addr, &[val1]), i64_align);\n         let local_ptr = catchpad.bitcast(local_ptr, i64p);\n-        catchpad.store(arg1, local_ptr, None);\n-        catchpad.store(arg2, catchpad.inbounds_gep(local_ptr, &[val1]), None);\n+        catchpad.store(arg1, local_ptr, i64_align);\n+        catchpad.store(arg2, catchpad.inbounds_gep(local_ptr, &[val1]), i64_align);\n         catchpad.catch_ret(tok, caught.llbb());\n \n         caught.ret(C_i32(ccx, 1));\n@@ -863,7 +867,8 @@ fn trans_msvc_try<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n     // Note that no invoke is used here because by definition this function\n     // can't panic (that's what it's catching).\n     let ret = bcx.call(llfn, &[func, data, local_ptr], None);\n-    bcx.store(ret, dest, None);\n+    let i32_align = bcx.tcx().data_layout.i32_align;\n+    bcx.store(ret, dest, i32_align);\n }\n \n // Definition of the standard \"try\" function for Rust using the GNU-like model\n@@ -923,14 +928,16 @@ fn trans_gnu_try<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n         let vals = catch.landing_pad(lpad_ty, bcx.ccx.eh_personality(), 1, catch.llfn());\n         catch.add_clause(vals, C_null(Type::i8p(ccx)));\n         let ptr = catch.extract_value(vals, 0);\n-        catch.store(ptr, catch.bitcast(local_ptr, Type::i8p(ccx).ptr_to()), None);\n+        let ptr_align = bcx.tcx().data_layout.pointer_align;\n+        catch.store(ptr, catch.bitcast(local_ptr, Type::i8p(ccx).ptr_to()), ptr_align);\n         catch.ret(C_i32(ccx, 1));\n     });\n \n     // Note that no invoke is used here because by definition this function\n     // can't panic (that's what it's catching).\n     let ret = bcx.call(llfn, &[func, data, local_ptr], None);\n-    bcx.store(ret, dest, None);\n+    let i32_align = bcx.tcx().data_layout.i32_align;\n+    bcx.store(ret, dest, i32_align);\n }\n \n // Helper function to give a Block to a closure to translate a shim function."}, {"sha": "4be2774d3c20c7ea079dcc6b490c719578effda3", "filename": "src/librustc_trans/meth.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5cab0bf0ad3567c87ebb9e646c4d915a28e21dfd/src%2Flibrustc_trans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cab0bf0ad3567c87ebb9e646c4d915a28e21dfd/src%2Flibrustc_trans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmeth.rs?ref=5cab0bf0ad3567c87ebb9e646c4d915a28e21dfd", "patch": "@@ -40,7 +40,8 @@ impl<'a, 'tcx> VirtualIndex {\n         debug!(\"get_fn({:?}, {:?})\", Value(llvtable), self);\n \n         let llvtable = bcx.pointercast(llvtable, fn_ty.llvm_type(bcx.ccx).ptr_to().ptr_to());\n-        let ptr = bcx.load(bcx.inbounds_gep(llvtable, &[C_usize(bcx.ccx, self.0)]), None);\n+        let ptr_align = bcx.tcx().data_layout.pointer_align;\n+        let ptr = bcx.load(bcx.inbounds_gep(llvtable, &[C_usize(bcx.ccx, self.0)]), ptr_align);\n         bcx.nonnull_metadata(ptr);\n         // Vtable loads are invariant\n         bcx.set_invariant_load(ptr);\n@@ -52,7 +53,8 @@ impl<'a, 'tcx> VirtualIndex {\n         debug!(\"get_int({:?}, {:?})\", Value(llvtable), self);\n \n         let llvtable = bcx.pointercast(llvtable, Type::isize(bcx.ccx).ptr_to());\n-        let ptr = bcx.load(bcx.inbounds_gep(llvtable, &[C_usize(bcx.ccx, self.0)]), None);\n+        let usize_align = bcx.tcx().data_layout.pointer_align;\n+        let ptr = bcx.load(bcx.inbounds_gep(llvtable, &[C_usize(bcx.ccx, self.0)]), usize_align);\n         // Vtable loads are invariant\n         bcx.set_invariant_load(ptr);\n         ptr"}, {"sha": "eba2928d84c18a73553338f2537eab941fcd352c", "filename": "src/librustc_trans/mir/block.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5cab0bf0ad3567c87ebb9e646c4d915a28e21dfd/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cab0bf0ad3567c87ebb9e646c4d915a28e21dfd/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fblock.rs?ref=5cab0bf0ad3567c87ebb9e646c4d915a28e21dfd", "patch": "@@ -216,7 +216,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                     PassMode::Direct(_) | PassMode::Pair(..) => {\n                         let op = self.trans_consume(&bcx, &mir::Place::Local(mir::RETURN_PLACE));\n                         if let Ref(llval, align) = op.val {\n-                            bcx.load(llval, Some(align))\n+                            bcx.load(llval, align)\n                         } else {\n                             op.immediate_or_packed_pair(&bcx)\n                         }\n@@ -247,7 +247,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                         };\n                         bcx.load(\n                             bcx.pointercast(llslot, cast_ty.llvm_type(bcx.ccx).ptr_to()),\n-                            Some(self.fn_ty.ret.layout.align))\n+                            self.fn_ty.ret.layout.align)\n                     }\n                 };\n                 bcx.ret(llval);\n@@ -653,7 +653,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                     // have scary latent bugs around.\n \n                     let scratch = PlaceRef::alloca(bcx, arg.layout, \"arg\");\n-                    base::memcpy_ty(bcx, scratch.llval, llval, op.layout, Some(align));\n+                    base::memcpy_ty(bcx, scratch.llval, llval, op.layout, align);\n                     (scratch.llval, scratch.align, true)\n                 } else {\n                     (llval, align, true)\n@@ -665,14 +665,14 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n             // Have to load the argument, maybe while casting it.\n             if let PassMode::Cast(ty) = arg.mode {\n                 llval = bcx.load(bcx.pointercast(llval, ty.llvm_type(bcx.ccx).ptr_to()),\n-                                 Some(align.min(arg.layout.align)));\n+                                 align.min(arg.layout.align));\n             } else {\n                 // We can't use `PlaceRef::load` here because the argument\n                 // may have a type we don't treat as immediate, but the ABI\n                 // used for this call is passing it by-value. In that case,\n                 // the load would just produce `OperandValue::Ref` instead\n                 // of the `OperandValue::Immediate` we need for the call.\n-                llval = bcx.load(llval, Some(align));\n+                llval = bcx.load(llval, align);\n                 if let layout::Abi::Scalar(ref scalar) = arg.layout.abi {\n                     if scalar.is_bool() {\n                         bcx.range_metadata(llval, 0..2);"}, {"sha": "917ff87a674b6cc7121f1878637e07a5065f030c", "filename": "src/librustc_trans/mir/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5cab0bf0ad3567c87ebb9e646c4d915a28e21dfd/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cab0bf0ad3567c87ebb9e646c4d915a28e21dfd/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fmod.rs?ref=5cab0bf0ad3567c87ebb9e646c4d915a28e21dfd", "patch": "@@ -530,11 +530,11 @@ fn arg_local_refs<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n             // doesn't actually strip the offset when splitting the closure\n             // environment into its components so it ends up out of bounds.\n             let env_ptr = if !env_ref {\n-                let alloc = PlaceRef::alloca(bcx,\n+                let scratch = PlaceRef::alloca(bcx,\n                     bcx.ccx.layout_of(tcx.mk_mut_ptr(arg.layout.ty)),\n                     \"__debuginfo_env_ptr\");\n-                bcx.store(place.llval, alloc.llval, None);\n-                alloc.llval\n+                bcx.store(place.llval, scratch.llval, scratch.align);\n+                scratch.llval\n             } else {\n                 place.llval\n             };"}, {"sha": "c88235371f907d51d9749d86a6d60475ffca48e2", "filename": "src/librustc_trans/mir/operand.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5cab0bf0ad3567c87ebb9e646c4d915a28e21dfd/src%2Flibrustc_trans%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cab0bf0ad3567c87ebb9e646c4d915a28e21dfd/src%2Flibrustc_trans%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Foperand.rs?ref=5cab0bf0ad3567c87ebb9e646c4d915a28e21dfd", "patch": "@@ -223,9 +223,9 @@ impl<'a, 'tcx> OperandValue {\n         match self {\n             OperandValue::Ref(r, source_align) =>\n                 base::memcpy_ty(bcx, dest.llval, r, dest.layout,\n-                                Some(source_align.min(dest.align))),\n+                                source_align.min(dest.align)),\n             OperandValue::Immediate(s) => {\n-                bcx.store(base::from_immediate(bcx, s), dest.llval, dest.non_abi_align());\n+                bcx.store(base::from_immediate(bcx, s), dest.llval, dest.align);\n             }\n             OperandValue::Pair(a, b) => {\n                 for (i, &x) in [a, b].iter().enumerate() {\n@@ -234,7 +234,7 @@ impl<'a, 'tcx> OperandValue {\n                     if common::val_ty(x) == Type::i1(bcx.ccx) {\n                         llptr = bcx.pointercast(llptr, Type::i8p(bcx.ccx));\n                     }\n-                    bcx.store(base::from_immediate(bcx, x), llptr, dest.non_abi_align());\n+                    bcx.store(base::from_immediate(bcx, x), llptr, dest.align);\n                 }\n             }\n         }"}, {"sha": "b556b6a132312f0f98a02f7ce39d50264318fddf", "filename": "src/librustc_trans/mir/place.rs", "status": "modified", "additions": 3, "deletions": 11, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5cab0bf0ad3567c87ebb9e646c4d915a28e21dfd/src%2Flibrustc_trans%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cab0bf0ad3567c87ebb9e646c4d915a28e21dfd/src%2Flibrustc_trans%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fplace.rs?ref=5cab0bf0ad3567c87ebb9e646c4d915a28e21dfd", "patch": "@@ -81,14 +81,6 @@ impl<'a, 'tcx> PlaceRef<'tcx> {\n         !self.llextra.is_null()\n     }\n \n-    pub fn non_abi_align(self) -> Option<Align> {\n-        if self.align.abi() >= self.layout.align.abi() {\n-            None\n-        } else {\n-            Some(self.align)\n-        }\n-    }\n-\n     pub fn load(&self, bcx: &Builder<'a, 'tcx>) -> OperandRef<'tcx> {\n         debug!(\"PlaceRef::load: {:?}\", self);\n \n@@ -135,7 +127,7 @@ impl<'a, 'tcx> PlaceRef<'tcx> {\n             let llval = if !const_llval.is_null() {\n                 const_llval\n             } else {\n-                let load = bcx.load(self.llval, self.non_abi_align());\n+                let load = bcx.load(self.llval, self.align);\n                 if let layout::Abi::Scalar(ref scalar) = self.layout.abi {\n                     scalar_load_metadata(load, scalar);\n                 }\n@@ -149,7 +141,7 @@ impl<'a, 'tcx> PlaceRef<'tcx> {\n                 if scalar.is_bool() {\n                     llptr = bcx.pointercast(llptr, Type::i8p(bcx.ccx));\n                 }\n-                let load = bcx.load(llptr, self.non_abi_align());\n+                let load = bcx.load(llptr, self.align);\n                 scalar_load_metadata(load, scalar);\n                 if scalar.is_bool() {\n                     bcx.trunc(load, Type::i1(bcx.ccx))\n@@ -338,7 +330,7 @@ impl<'a, 'tcx> PlaceRef<'tcx> {\n                     .discriminant_for_variant(bcx.tcx(), variant_index)\n                     .to_u128_unchecked() as u64;\n                 bcx.store(C_int(ptr.layout.llvm_type(bcx.ccx), to as i64),\n-                    ptr.llval, ptr.non_abi_align());\n+                    ptr.llval, ptr.align);\n             }\n             layout::Variants::NicheFilling {\n                 dataful_variant,"}, {"sha": "9d705eda9fbef1e87d2b0b654beea1cfa747bb18", "filename": "src/librustc_trans/mir/rvalue.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5cab0bf0ad3567c87ebb9e646c4d915a28e21dfd/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cab0bf0ad3567c87ebb9e646c4d915a28e21dfd/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Frvalue.rs?ref=5cab0bf0ad3567c87ebb9e646c4d915a28e21dfd", "patch": "@@ -104,9 +104,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 let start = dest.project_index(&bcx, C_usize(bcx.ccx, 0)).llval;\n \n                 if let OperandValue::Immediate(v) = tr_elem.val {\n-                    let align = dest.non_abi_align()\n-                        .unwrap_or(tr_elem.layout.align);\n-                    let align = C_i32(bcx.ccx, align.abi() as i32);\n+                    let align = C_i32(bcx.ccx, dest.align.abi() as i32);\n                     let size = C_usize(bcx.ccx, dest.layout.size.bytes());\n \n                     // Use llvm.memset.p0i8.* to initialize all zero arrays"}]}