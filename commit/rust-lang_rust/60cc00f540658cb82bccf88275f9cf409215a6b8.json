{"sha": "60cc00f540658cb82bccf88275f9cf409215a6b8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYwY2MwMGY1NDA2NThjYjgyYmNjZjg4Mjc1ZjljZjQwOTIxNWE2Yjg=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2020-11-22T11:10:50Z"}, "committer": {"name": "Mark Rousskov", "email": "mark.simulacrum@gmail.com", "date": "2021-08-20T21:27:50Z"}, "message": "move `fallback_if_possible` and friends to fallback.rs\n\nAlong the way, simplify and document the logic more clearly.", "tree": {"sha": "74d6783601e316041ceacee9a47cd1c94b23a8e0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/74d6783601e316041ceacee9a47cd1c94b23a8e0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/60cc00f540658cb82bccf88275f9cf409215a6b8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/60cc00f540658cb82bccf88275f9cf409215a6b8", "html_url": "https://github.com/rust-lang/rust/commit/60cc00f540658cb82bccf88275f9cf409215a6b8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/60cc00f540658cb82bccf88275f9cf409215a6b8/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "faf84263f2acd638801069beea0d4b9dd662c111", "url": "https://api.github.com/repos/rust-lang/rust/commits/faf84263f2acd638801069beea0d4b9dd662c111", "html_url": "https://github.com/rust-lang/rust/commit/faf84263f2acd638801069beea0d4b9dd662c111"}], "stats": {"total": 252, "additions": 127, "deletions": 125}, "files": [{"sha": "80f1a0d325466be9686b934d130f53b147d4924d", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 18, "deletions": 23, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/60cc00f540658cb82bccf88275f9cf409215a6b8/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60cc00f540658cb82bccf88275f9cf409215a6b8/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=60cc00f540658cb82bccf88275f9cf409215a6b8", "patch": "@@ -23,7 +23,7 @@ use rustc_middle::infer::unify_key::{ConstVarValue, ConstVariableValue};\n use rustc_middle::infer::unify_key::{ConstVariableOrigin, ConstVariableOriginKind, ToType};\n use rustc_middle::mir::interpret::EvalToConstValueResult;\n use rustc_middle::traits::select;\n-use rustc_middle::ty::error::{ExpectedFound, TypeError, UnconstrainedNumeric};\n+use rustc_middle::ty::error::{ExpectedFound, TypeError};\n use rustc_middle::ty::fold::{TypeFoldable, TypeFolder};\n use rustc_middle::ty::relate::RelateResult;\n use rustc_middle::ty::subst::{GenericArg, GenericArgKind, InternalSubsts, SubstsRef};\n@@ -679,13 +679,30 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         t.fold_with(&mut self.freshener())\n     }\n \n+    /// Returns whether `ty` is a diverging type variable or not.\n+    /// (If `ty` is not a type variable at all, returns not diverging.)\n+    ///\n+    /// No attempt is made to resolve `ty`.\n     pub fn type_var_diverges(&'a self, ty: Ty<'_>) -> Diverging {\n         match *ty.kind() {\n             ty::Infer(ty::TyVar(vid)) => self.inner.borrow_mut().type_variables().var_diverges(vid),\n             _ => Diverging::NotDiverging,\n         }\n     }\n \n+    /// Returns the origin of the type variable identified by `vid`, or `None`\n+    /// if this is not a type variable.\n+    ///\n+    /// No attempt is made to resolve `ty`.\n+    pub fn type_var_origin(&'a self, ty: Ty<'tcx>) -> Option<TypeVariableOrigin> {\n+        match *ty.kind() {\n+            ty::Infer(ty::TyVar(vid)) => {\n+                Some(*self.inner.borrow_mut().type_variables().var_origin(vid))\n+            }\n+            _ => None,\n+        }\n+    }\n+\n     pub fn freshener<'b>(&'b self) -> TypeFreshener<'b, 'tcx> {\n         freshen::TypeFreshener::new(self, false)\n     }\n@@ -695,28 +712,6 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         freshen::TypeFreshener::new(self, true)\n     }\n \n-    pub fn type_is_unconstrained_numeric(&'a self, ty: Ty<'_>) -> UnconstrainedNumeric {\n-        use rustc_middle::ty::error::UnconstrainedNumeric::Neither;\n-        use rustc_middle::ty::error::UnconstrainedNumeric::{UnconstrainedFloat, UnconstrainedInt};\n-        match *ty.kind() {\n-            ty::Infer(ty::IntVar(vid)) => {\n-                if self.inner.borrow_mut().int_unification_table().probe_value(vid).is_some() {\n-                    Neither\n-                } else {\n-                    UnconstrainedInt\n-                }\n-            }\n-            ty::Infer(ty::FloatVar(vid)) => {\n-                if self.inner.borrow_mut().float_unification_table().probe_value(vid).is_some() {\n-                    Neither\n-                } else {\n-                    UnconstrainedFloat\n-                }\n-            }\n-            _ => Neither,\n-        }\n-    }\n-\n     pub fn unsolved_variables(&self) -> Vec<Ty<'tcx>> {\n         let mut inner = self.inner.borrow_mut();\n         let mut vars: Vec<Ty<'_>> = inner"}, {"sha": "1aa6c84dbc414586ed0b28d8ee00e11b3545cd2b", "filename": "compiler/rustc_middle/src/ty/error.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/60cc00f540658cb82bccf88275f9cf409215a6b8/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60cc00f540658cb82bccf88275f9cf409215a6b8/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs?ref=60cc00f540658cb82bccf88275f9cf409215a6b8", "patch": "@@ -71,12 +71,6 @@ pub enum TypeError<'tcx> {\n     TargetFeatureCast(DefId),\n }\n \n-pub enum UnconstrainedNumeric {\n-    UnconstrainedFloat,\n-    UnconstrainedInt,\n-    Neither,\n-}\n-\n /// Explains the source of a type err in a short, human readable way. This is meant to be placed\n /// in parentheses after some larger message. You should also invoke `note_and_explain_type_err()`\n /// afterwards to present additional details, particularly when it comes to lifetime-related"}, {"sha": "69a8970ae094e8c4cdca183a83eb0fe7e08677f8", "filename": "compiler/rustc_typeck/src/check/fallback.rs", "status": "modified", "additions": 108, "deletions": 3, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/60cc00f540658cb82bccf88275f9cf409215a6b8/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffallback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60cc00f540658cb82bccf88275f9cf409215a6b8/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffallback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffallback.rs?ref=60cc00f540658cb82bccf88275f9cf409215a6b8", "patch": "@@ -1,5 +1,6 @@\n-use crate::check::FallbackMode;\n use crate::check::FnCtxt;\n+use rustc_infer::infer::type_variable::Diverging;\n+use rustc_middle::ty::{self, Ty};\n \n impl<'tcx> FnCtxt<'_, 'tcx> {\n     pub(super) fn type_inference_fallback(&self) {\n@@ -12,8 +13,9 @@ impl<'tcx> FnCtxt<'_, 'tcx> {\n         // The first time, we do *not* replace opaque types.\n         for ty in &self.unsolved_variables() {\n             debug!(\"unsolved_variable = {:?}\", ty);\n-            fallback_has_occurred |= self.fallback_if_possible(ty, FallbackMode::NoOpaque);\n+            fallback_has_occurred |= self.fallback_if_possible(ty);\n         }\n+\n         // We now see if we can make progress. This might\n         // cause us to unify inference variables for opaque types,\n         // since we may have unified some other type variables\n@@ -43,10 +45,113 @@ impl<'tcx> FnCtxt<'_, 'tcx> {\n         // unconstrained opaque type variables, in addition to performing\n         // other kinds of fallback.\n         for ty in &self.unsolved_variables() {\n-            fallback_has_occurred |= self.fallback_if_possible(ty, FallbackMode::All);\n+            fallback_has_occurred |= self.fallback_opaque_type_vars(ty);\n         }\n \n         // See if we can make any more progress.\n         self.select_obligations_where_possible(fallback_has_occurred, |_| {});\n     }\n+\n+    // Tries to apply a fallback to `ty` if it is an unsolved variable.\n+    //\n+    // - Unconstrained ints are replaced with `i32`.\n+    //\n+    // - Unconstrained floats are replaced with with `f64`.\n+    //\n+    // - Non-numerics get replaced with `!` when `#![feature(never_type_fallback)]`\n+    //   is enabled. Otherwise, they are replaced with `()`.\n+    //\n+    // Fallback becomes very dubious if we have encountered type-checking errors.\n+    // In that case, fallback to Error.\n+    // The return value indicates whether fallback has occurred.\n+    fn fallback_if_possible(&self, ty: Ty<'tcx>) -> bool {\n+        // Careful: we do NOT shallow-resolve `ty`. We know that `ty`\n+        // is an unsolved variable, and we determine its fallback based\n+        // solely on how it was created, not what other type variables\n+        // it may have been unified with since then.\n+        //\n+        // The reason this matters is that other attempts at fallback may\n+        // (in principle) conflict with this fallback, and we wish to generate\n+        // a type error in that case. (However, this actually isn't true right now,\n+        // because we're only using the builtin fallback rules. This would be\n+        // true if we were using user-supplied fallbacks. But it's still useful\n+        // to write the code to detect bugs.)\n+        //\n+        // (Note though that if we have a general type variable `?T` that is then unified\n+        // with an integer type variable `?I` that ultimately never gets\n+        // resolved to a special integral type, `?T` is not considered unsolved,\n+        // but `?I` is. The same is true for float variables.)\n+        let fallback = match ty.kind() {\n+            _ if self.is_tainted_by_errors() => self.tcx.ty_error(),\n+            ty::Infer(ty::IntVar(_)) => self.tcx.types.i32,\n+            ty::Infer(ty::FloatVar(_)) => self.tcx.types.f64,\n+            _ => match self.type_var_diverges(ty) {\n+                Diverging::Diverges => self.tcx.mk_diverging_default(),\n+                Diverging::NotDiverging => return false,\n+            },\n+        };\n+        debug!(\"fallback_if_possible(ty={:?}): defaulting to `{:?}`\", ty, fallback);\n+\n+        let span = self\n+            .infcx\n+            .type_var_origin(ty)\n+            .map(|origin| origin.span)\n+            .unwrap_or(rustc_span::DUMMY_SP);\n+        self.demand_eqtype(span, ty, fallback);\n+        true\n+    }\n+\n+    /// Second round of fallback: Unconstrained type variables\n+    /// created from the instantiation of an opaque\n+    /// type fall back to the opaque type itself. This is a\n+    /// somewhat incomplete attempt to manage \"identity passthrough\"\n+    /// for `impl Trait` types.\n+    ///\n+    /// For example, in this code:\n+    ///\n+    ///```\n+    /// type MyType = impl Copy;\n+    /// fn defining_use() -> MyType { true }\n+    /// fn other_use() -> MyType { defining_use() }\n+    /// ```\n+    ///\n+    /// `defining_use` will constrain the instantiated inference\n+    /// variable to `bool`, while `other_use` will constrain\n+    /// the instantiated inference variable to `MyType`.\n+    ///\n+    /// When we process opaque types during writeback, we\n+    /// will handle cases like `other_use`, and not count\n+    /// them as defining usages\n+    ///\n+    /// However, we also need to handle cases like this:\n+    ///\n+    /// ```rust\n+    /// pub type Foo = impl Copy;\n+    /// fn produce() -> Option<Foo> {\n+    ///     None\n+    ///  }\n+    ///  ```\n+    ///\n+    /// In the above snippet, the inference variable created by\n+    /// instantiating `Option<Foo>` will be completely unconstrained.\n+    /// We treat this as a non-defining use by making the inference\n+    /// variable fall back to the opaque type itself.\n+    fn fallback_opaque_type_vars(&self, ty: Ty<'tcx>) -> bool {\n+        let span = self\n+            .infcx\n+            .type_var_origin(ty)\n+            .map(|origin| origin.span)\n+            .unwrap_or(rustc_span::DUMMY_SP);\n+        let oty = self.inner.borrow().opaque_types_vars.get(ty).map(|v| *v);\n+        if let Some(opaque_ty) = oty {\n+            debug!(\n+                \"fallback_opaque_type_vars(ty={:?}): falling back to opaque type {:?}\",\n+                ty, opaque_ty\n+            );\n+            self.demand_eqtype(span, ty, opaque_ty);\n+            true\n+        } else {\n+            return false;\n+        }\n+    }\n }"}, {"sha": "bb80f0879a4aa4bff7c88ec3524234296c91051b", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/_impl.rs", "status": "modified", "additions": 1, "deletions": 83, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/60cc00f540658cb82bccf88275f9cf409215a6b8/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60cc00f540658cb82bccf88275f9cf409215a6b8/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs?ref=60cc00f540658cb82bccf88275f9cf409215a6b8", "patch": "@@ -4,7 +4,7 @@ use crate::astconv::{\n };\n use crate::check::callee::{self, DeferredCallResolution};\n use crate::check::method::{self, MethodCallee, SelfSource};\n-use crate::check::{BreakableCtxt, Diverges, Expectation, FallbackMode, FnCtxt, LocalTy};\n+use crate::check::{BreakableCtxt, Diverges, Expectation, FnCtxt, LocalTy};\n \n use rustc_ast::TraitObjectSyntax;\n use rustc_data_structures::captures::Captures;\n@@ -17,7 +17,6 @@ use rustc_hir::lang_items::LangItem;\n use rustc_hir::{ExprKind, GenericArg, Node, QPath, TyKind};\n use rustc_infer::infer::canonical::{Canonical, OriginalQueryValues, QueryResponse};\n use rustc_infer::infer::error_reporting::TypeAnnotationNeeded::E0282;\n-use rustc_infer::infer::type_variable::Diverging;\n use rustc_infer::infer::{InferOk, InferResult};\n use rustc_middle::ty::adjustment::{Adjust, Adjustment, AutoBorrow, AutoBorrowMutability};\n use rustc_middle::ty::fold::TypeFoldable;\n@@ -636,87 +635,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n-    // Tries to apply a fallback to `ty` if it is an unsolved variable.\n-    //\n-    // - Unconstrained ints are replaced with `i32`.\n-    //\n-    // - Unconstrained floats are replaced with with `f64`.\n-    //\n-    // - Non-numerics get replaced with `!` when `#![feature(never_type_fallback)]`\n-    //   is enabled. Otherwise, they are replaced with `()`.\n-    //\n-    // Fallback becomes very dubious if we have encountered type-checking errors.\n-    // In that case, fallback to Error.\n-    // The return value indicates whether fallback has occurred.\n-    pub(in super::super) fn fallback_if_possible(&self, ty: Ty<'tcx>, mode: FallbackMode) -> bool {\n-        use rustc_middle::ty::error::UnconstrainedNumeric::Neither;\n-        use rustc_middle::ty::error::UnconstrainedNumeric::{UnconstrainedFloat, UnconstrainedInt};\n-\n-        assert!(ty.is_ty_infer());\n-        let fallback = match self.type_is_unconstrained_numeric(ty) {\n-            _ if self.is_tainted_by_errors() => self.tcx().ty_error(),\n-            UnconstrainedInt => self.tcx.types.i32,\n-            UnconstrainedFloat => self.tcx.types.f64,\n-            Neither => match self.type_var_diverges(ty) {\n-                Diverging::Diverges => self.tcx.mk_diverging_default(),\n-\n-                Diverging::NotDiverging => {\n-                    // This type variable was created from the instantiation of an opaque\n-                    // type. The fact that we're attempting to perform fallback for it\n-                    // means that the function neither constrained it to a concrete\n-                    // type, nor to the opaque type itself.\n-                    //\n-                    // For example, in this code:\n-                    //\n-                    //```\n-                    // type MyType = impl Copy;\n-                    // fn defining_use() -> MyType { true }\n-                    // fn other_use() -> MyType { defining_use() }\n-                    // ```\n-                    //\n-                    // `defining_use` will constrain the instantiated inference\n-                    // variable to `bool`, while `other_use` will constrain\n-                    // the instantiated inference variable to `MyType`.\n-                    //\n-                    // When we process opaque types during writeback, we\n-                    // will handle cases like `other_use`, and not count\n-                    // them as defining usages\n-                    //\n-                    // However, we also need to handle cases like this:\n-                    //\n-                    // ```rust\n-                    // pub type Foo = impl Copy;\n-                    // fn produce() -> Option<Foo> {\n-                    //     None\n-                    //  }\n-                    //  ```\n-                    //\n-                    // In the above snippet, the inference variable created by\n-                    // instantiating `Option<Foo>` will be completely unconstrained.\n-                    // We treat this as a non-defining use by making the inference\n-                    // variable fall back to the opaque type itself.\n-                    if let FallbackMode::All = mode {\n-                        if let Some(opaque_ty) = self.infcx.inner.borrow().opaque_types_vars.get(ty)\n-                        {\n-                            debug!(\n-                                \"fallback_if_possible: falling back opaque type var {:?} to {:?}\",\n-                                ty, opaque_ty\n-                            );\n-                            *opaque_ty\n-                        } else {\n-                            return false;\n-                        }\n-                    } else {\n-                        return false;\n-                    }\n-                }\n-            },\n-        };\n-        debug!(\"fallback_if_possible: defaulting `{:?}` to `{:?}`\", ty, fallback);\n-        self.demand_eqtype(rustc_span::DUMMY_SP, ty, fallback);\n-        true\n-    }\n-\n     pub(in super::super) fn select_all_obligations_or_error(&self) {\n         debug!(\"select_all_obligations_or_error\");\n         if let Err(errors) = self"}, {"sha": "ad7e96e2833b84b65fb00e28fa918532d8740e43", "filename": "compiler/rustc_typeck/src/check/mod.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/60cc00f540658cb82bccf88275f9cf409215a6b8/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60cc00f540658cb82bccf88275f9cf409215a6b8/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs?ref=60cc00f540658cb82bccf88275f9cf409215a6b8", "patch": "@@ -872,16 +872,6 @@ enum TupleArgumentsFlag {\n     TupleArguments,\n }\n \n-/// Controls how we perform fallback for unconstrained\n-/// type variables.\n-enum FallbackMode {\n-    /// Do not fallback type variables to opaque types.\n-    NoOpaque,\n-    /// Perform all possible kinds of fallback, including\n-    /// turning type variables to opaque types.\n-    All,\n-}\n-\n /// A wrapper for `InferCtxt`'s `in_progress_typeck_results` field.\n #[derive(Copy, Clone)]\n struct MaybeInProgressTables<'a, 'tcx> {"}]}