{"sha": "771dd54ea6c09ac32093a46a0d9ed80502ce3b02", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc3MWRkNTRlYTZjMDlhYzMyMDkzYTQ2YTBkOWVkODA1MDJjZTNiMDI=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-12-23T10:52:47Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-12-30T14:32:42Z"}, "message": "Rename `Polytype` to `TypeScheme` to differentiate type schemes (early bound) from higher-ranked things (late-bound), which also use the `Poly` prefix.", "tree": {"sha": "ac9fe663dceeacd928424bee1856ceb51f05add7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ac9fe663dceeacd928424bee1856ceb51f05add7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/771dd54ea6c09ac32093a46a0d9ed80502ce3b02", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/771dd54ea6c09ac32093a46a0d9ed80502ce3b02", "html_url": "https://github.com/rust-lang/rust/commit/771dd54ea6c09ac32093a46a0d9ed80502ce3b02", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/771dd54ea6c09ac32093a46a0d9ed80502ce3b02/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "986f654f3b087809fbf9b1168708e46b4211da84", "url": "https://api.github.com/repos/rust-lang/rust/commits/986f654f3b087809fbf9b1168708e46b4211da84", "html_url": "https://github.com/rust-lang/rust/commit/986f654f3b087809fbf9b1168708e46b4211da84"}], "stats": {"total": 311, "additions": 158, "deletions": 153}, "files": [{"sha": "0cbc94f379d80394e17ea054dbcdce97bb81b603", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/771dd54ea6c09ac32093a46a0d9ed80502ce3b02/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/771dd54ea6c09ac32093a46a0d9ed80502ce3b02/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=771dd54ea6c09ac32093a46a0d9ed80502ce3b02", "patch": "@@ -226,7 +226,7 @@ pub fn get_struct_field_attrs(cstore: &cstore::CStore, def: ast::DefId) -> HashM\n \n pub fn get_type<'tcx>(tcx: &ty::ctxt<'tcx>,\n                       def: ast::DefId)\n-                      -> ty::Polytype<'tcx> {\n+                      -> ty::TypeScheme<'tcx> {\n     let cstore = &tcx.sess.cstore;\n     let cdata = cstore.get_crate_data(def.krate);\n     decoder::get_type(&*cdata, def.node, tcx)\n@@ -239,7 +239,7 @@ pub fn get_trait_def<'tcx>(tcx: &ty::ctxt<'tcx>, def: ast::DefId) -> ty::TraitDe\n }\n \n pub fn get_field_type<'tcx>(tcx: &ty::ctxt<'tcx>, class_id: ast::DefId,\n-                            def: ast::DefId) -> ty::Polytype<'tcx> {\n+                            def: ast::DefId) -> ty::TypeScheme<'tcx> {\n     let cstore = &tcx.sess.cstore;\n     let cdata = cstore.get_crate_data(class_id.krate);\n     let all_items = reader::get_doc(rbml::Doc::new(cdata.data()), tag_items);\n@@ -257,7 +257,7 @@ pub fn get_field_type<'tcx>(tcx: &ty::ctxt<'tcx>, class_id: ast::DefId,\n                     def)).to_string()\n         });\n     let ty = decoder::item_type(def, the_field, tcx, &*cdata);\n-    ty::Polytype {\n+    ty::TypeScheme {\n         generics: ty::Generics::empty(),\n         ty: ty,\n     }"}, {"sha": "ce04a9029929d74fd10dc2469a577a7f306750c0", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/771dd54ea6c09ac32093a46a0d9ed80502ce3b02/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/771dd54ea6c09ac32093a46a0d9ed80502ce3b02/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=771dd54ea6c09ac32093a46a0d9ed80502ce3b02", "patch": "@@ -387,7 +387,7 @@ pub fn get_trait_def<'tcx>(cdata: Cmd,\n }\n \n pub fn get_type<'tcx>(cdata: Cmd, id: ast::NodeId, tcx: &ty::ctxt<'tcx>)\n-    -> ty::Polytype<'tcx> {\n+    -> ty::TypeScheme<'tcx> {\n \n     let item = lookup_item(id, cdata.data());\n \n@@ -396,7 +396,7 @@ pub fn get_type<'tcx>(cdata: Cmd, id: ast::NodeId, tcx: &ty::ctxt<'tcx>)\n \n     let generics = doc_generics(item, tcx, cdata, tag_item_generics);\n \n-    ty::Polytype {\n+    ty::TypeScheme {\n         generics: generics,\n         ty: t\n     }"}, {"sha": "6d79419b38634ce369b0dbcbfa5fdd1691f91120", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/771dd54ea6c09ac32093a46a0d9ed80502ce3b02/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/771dd54ea6c09ac32093a46a0d9ed80502ce3b02/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=771dd54ea6c09ac32093a46a0d9ed80502ce3b02", "patch": "@@ -142,7 +142,7 @@ fn encode_item_variances(rbml_w: &mut Encoder,\n \n fn encode_bounds_and_type<'a, 'tcx>(rbml_w: &mut Encoder,\n                                     ecx: &EncodeContext<'a, 'tcx>,\n-                                    pty: &ty::Polytype<'tcx>) {\n+                                    pty: &ty::TypeScheme<'tcx>) {\n     encode_generics(rbml_w, ecx, &pty.generics, tag_item_generics);\n     encode_type(ecx, rbml_w, pty.ty);\n }"}, {"sha": "a135701a9c435f5fef65a166e83222bd2107663c", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/771dd54ea6c09ac32093a46a0d9ed80502ce3b02/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/771dd54ea6c09ac32093a46a0d9ed80502ce3b02/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=771dd54ea6c09ac32093a46a0d9ed80502ce3b02", "patch": "@@ -838,8 +838,8 @@ trait rbml_writer_helpers<'tcx> {\n                           predicate: &ty::Predicate<'tcx>);\n     fn emit_trait_ref<'a>(&mut self, ecx: &e::EncodeContext<'a, 'tcx>,\n                           ty: &ty::TraitRef<'tcx>);\n-    fn emit_polytype<'a>(&mut self, ecx: &e::EncodeContext<'a, 'tcx>,\n-                         pty: ty::Polytype<'tcx>);\n+    fn emit_type_scheme<'a>(&mut self, ecx: &e::EncodeContext<'a, 'tcx>,\n+                            type_scheme: ty::TypeScheme<'tcx>);\n     fn emit_substs<'a>(&mut self, ecx: &e::EncodeContext<'a, 'tcx>,\n                        substs: &subst::Substs<'tcx>);\n     fn emit_existential_bounds(&mut self, ecx: &e::EncodeContext, bounds: &ty::ExistentialBounds);\n@@ -951,33 +951,33 @@ impl<'a, 'tcx> rbml_writer_helpers<'tcx> for Encoder<'a> {\n         });\n     }\n \n-    fn emit_polytype<'b>(&mut self,\n-                         ecx: &e::EncodeContext<'b, 'tcx>,\n-                         pty: ty::Polytype<'tcx>) {\n+    fn emit_type_scheme<'b>(&mut self,\n+                            ecx: &e::EncodeContext<'b, 'tcx>,\n+                            type_scheme: ty::TypeScheme<'tcx>) {\n         use serialize::Encoder;\n \n-        self.emit_struct(\"Polytype\", 2, |this| {\n+        self.emit_struct(\"TypeScheme\", 2, |this| {\n             this.emit_struct_field(\"generics\", 0, |this| {\n                 this.emit_struct(\"Generics\", 2, |this| {\n                     this.emit_struct_field(\"types\", 0, |this| {\n                         Ok(encode_vec_per_param_space(\n-                            this, &pty.generics.types,\n+                            this, &type_scheme.generics.types,\n                             |this, def| this.emit_type_param_def(ecx, def)))\n                     });\n                     this.emit_struct_field(\"regions\", 1, |this| {\n                         Ok(encode_vec_per_param_space(\n-                            this, &pty.generics.regions,\n+                            this, &type_scheme.generics.regions,\n                             |this, def| def.encode(this).unwrap()))\n                     });\n                     this.emit_struct_field(\"predicates\", 2, |this| {\n                         Ok(encode_vec_per_param_space(\n-                            this, &pty.generics.predicates,\n+                            this, &type_scheme.generics.predicates,\n                             |this, def| this.emit_predicate(ecx, def)))\n                     })\n                 })\n             });\n             this.emit_struct_field(\"ty\", 1, |this| {\n-                Ok(this.emit_ty(ecx, pty.ty))\n+                Ok(this.emit_ty(ecx, type_scheme.ty))\n             })\n         });\n     }\n@@ -1252,11 +1252,11 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n     }\n \n     let lid = ast::DefId { krate: ast::LOCAL_CRATE, node: id };\n-    for &pty in tcx.tcache.borrow().get(&lid).iter() {\n+    for &type_scheme in tcx.tcache.borrow().get(&lid).iter() {\n         rbml_w.tag(c::tag_table_tcache, |rbml_w| {\n             rbml_w.id(id);\n             rbml_w.tag(c::tag_table_val, |rbml_w| {\n-                rbml_w.emit_polytype(ecx, pty.clone());\n+                rbml_w.emit_type_scheme(ecx, type_scheme.clone());\n             })\n         })\n     }\n@@ -1369,8 +1369,8 @@ trait rbml_decoder_decoder_helpers<'tcx> {\n                                    -> ty::TypeParameterDef<'tcx>;\n     fn read_predicate<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n                               -> ty::Predicate<'tcx>;\n-    fn read_polytype<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n-                             -> ty::Polytype<'tcx>;\n+    fn read_type_scheme<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n+                                -> ty::TypeScheme<'tcx>;\n     fn read_existential_bounds<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n                                        -> ty::ExistentialBounds;\n     fn read_substs<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n@@ -1591,10 +1591,10 @@ impl<'a, 'tcx> rbml_decoder_decoder_helpers<'tcx> for reader::Decoder<'a> {\n         }).unwrap()\n     }\n \n-    fn read_polytype<'b, 'c>(&mut self, dcx: &DecodeContext<'b, 'c, 'tcx>)\n-                             -> ty::Polytype<'tcx> {\n-        self.read_struct(\"Polytype\", 2, |this| {\n-            Ok(ty::Polytype {\n+    fn read_type_scheme<'b, 'c>(&mut self, dcx: &DecodeContext<'b, 'c, 'tcx>)\n+                                -> ty::TypeScheme<'tcx> {\n+        self.read_struct(\"TypeScheme\", 2, |this| {\n+            Ok(ty::TypeScheme {\n                 generics: this.read_struct_field(\"generics\", 0, |this| {\n                     this.read_struct(\"Generics\", 2, |this| {\n                         Ok(ty::Generics {\n@@ -1939,9 +1939,9 @@ fn decode_side_tables(dcx: &DecodeContext,\n                            .insert(id, capture_mode);\n                     }\n                     c::tag_table_tcache => {\n-                        let pty = val_dsr.read_polytype(dcx);\n+                        let type_scheme = val_dsr.read_type_scheme(dcx);\n                         let lid = ast::DefId { krate: ast::LOCAL_CRATE, node: id };\n-                        dcx.tcx.tcache.borrow_mut().insert(lid, pty);\n+                        dcx.tcx.tcache.borrow_mut().insert(lid, type_scheme);\n                     }\n                     c::tag_table_param_defs => {\n                         let bounds = val_dsr.read_type_param_def(dcx);"}, {"sha": "c082c12da5bfa7c5833219a68d6b377e7e88aea0", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/771dd54ea6c09ac32093a46a0d9ed80502ce3b02/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/771dd54ea6c09ac32093a46a0d9ed80502ce3b02/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=771dd54ea6c09ac32093a46a0d9ed80502ce3b02", "patch": "@@ -695,7 +695,7 @@ pub struct ctxt<'tcx> {\n     pub map: ast_map::Map<'tcx>,\n     pub intrinsic_defs: RefCell<DefIdMap<Ty<'tcx>>>,\n     pub freevars: RefCell<FreevarMap>,\n-    pub tcache: RefCell<DefIdMap<Polytype<'tcx>>>,\n+    pub tcache: RefCell<DefIdMap<TypeScheme<'tcx>>>,\n     pub rcache: RefCell<FnvHashMap<creader_cache_key, Ty<'tcx>>>,\n     pub short_names_cache: RefCell<FnvHashMap<Ty<'tcx>, String>>,\n     pub tc_cache: RefCell<FnvHashMap<Ty<'tcx>, TypeContents>>,\n@@ -2029,18 +2029,23 @@ impl<'tcx> ParameterEnvironment<'tcx> {\n     }\n }\n \n-/// A polytype.\n+/// A \"type scheme\", in ML terminology, is a type combined with some\n+/// set of generic types that the type is, well, generic over. In Rust\n+/// terms, it is the \"type\" of a fn item or struct -- this type will\n+/// include various generic parameters that must be substituted when\n+/// the item/struct is referenced. That is called converting the type\n+/// scheme to a monotype.\n ///\n /// - `generics`: the set of type parameters and their bounds\n /// - `ty`: the base types, which may reference the parameters defined\n ///   in `generics`\n #[deriving(Clone, Show)]\n-pub struct Polytype<'tcx> {\n+pub struct TypeScheme<'tcx> {\n     pub generics: Generics<'tcx>,\n     pub ty: Ty<'tcx>\n }\n \n-/// As `Polytype` but for a trait ref.\n+/// As `TypeScheme` but for a trait ref.\n pub struct TraitDef<'tcx> {\n     pub unsafety: ast::Unsafety,\n \n@@ -5102,7 +5107,7 @@ pub fn enum_variant_with_id<'tcx>(cx: &ctxt<'tcx>,\n // the type cache. Returns the type parameters and type.\n pub fn lookup_item_type<'tcx>(cx: &ctxt<'tcx>,\n                               did: ast::DefId)\n-                              -> Polytype<'tcx> {\n+                              -> TypeScheme<'tcx> {\n     lookup_locally_or_in_crate_store(\n         \"tcache\", did, &mut *cx.tcache.borrow_mut(),\n         || csearch::get_type(cx, did))"}, {"sha": "ae8324d9a4f158a09bcf380059515a84cfda7a3d", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/771dd54ea6c09ac32093a46a0d9ed80502ce3b02/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/771dd54ea6c09ac32093a46a0d9ed80502ce3b02/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=771dd54ea6c09ac32093a46a0d9ed80502ce3b02", "patch": "@@ -929,9 +929,9 @@ impl<'tcx> Repr<'tcx> for ast::DefId {\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for ty::Polytype<'tcx> {\n+impl<'tcx> Repr<'tcx> for ty::TypeScheme<'tcx> {\n     fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n-        format!(\"Polytype {{generics: {}, ty: {}}}\",\n+        format!(\"TypeScheme {{generics: {}, ty: {}}}\",\n                 self.generics.repr(tcx),\n                 self.ty.repr(tcx))\n     }"}, {"sha": "c0697c2a238dff1c162493a00f3f0d5ddcebb130", "filename": "src/librustc_trans/trans/callee.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/771dd54ea6c09ac32093a46a0d9ed80502ce3b02/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/771dd54ea6c09ac32093a46a0d9ed80502ce3b02/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs?ref=771dd54ea6c09ac32093a46a0d9ed80502ce3b02", "patch": "@@ -514,8 +514,8 @@ pub fn trans_fn_ref_with_substs<'blk, 'tcx>(\n         return val;\n     }\n \n-    // Polytype of the function item (may have type params)\n-    let fn_tpt = ty::lookup_item_type(tcx, def_id);\n+    // Type scheme of the function item (may have type params)\n+    let fn_type_scheme = ty::lookup_item_type(tcx, def_id);\n \n     // Find the actual function pointer.\n     let mut val = {\n@@ -524,7 +524,7 @@ pub fn trans_fn_ref_with_substs<'blk, 'tcx>(\n             get_item_val(ccx, def_id.node)\n         } else {\n             // External reference.\n-            trans_external_path(ccx, def_id, fn_tpt.ty)\n+            trans_external_path(ccx, def_id, fn_type_scheme.ty)\n         }\n     };\n \n@@ -551,7 +551,7 @@ pub fn trans_fn_ref_with_substs<'blk, 'tcx>(\n     // This can occur on either a crate-local or crate-external\n     // reference. It also occurs when testing libcore and in some\n     // other weird situations. Annoying.\n-    let llty = type_of::type_of_fn_from_ty(ccx, fn_tpt.ty);\n+    let llty = type_of::type_of_fn_from_ty(ccx, fn_type_scheme.ty);\n     let llptrty = llty.ptr_to();\n     if val_ty(val) != llptrty {\n         debug!(\"trans_fn_ref_with_vtables(): casting pointer!\");"}, {"sha": "859cb88ea9a1ca5bc7a7a5343537ae455d73acaa", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/771dd54ea6c09ac32093a46a0d9ed80502ce3b02/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/771dd54ea6c09ac32093a46a0d9ed80502ce3b02/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=771dd54ea6c09ac32093a46a0d9ed80502ce3b02", "patch": "@@ -16,11 +16,11 @@\n //! somewhat differently during the collect and check phases,\n //! particularly with respect to looking up the types of top-level\n //! items.  In the collect phase, the crate context is used as the\n-//! `AstConv` instance; in this phase, the `get_item_ty()` function\n+//! `AstConv` instance; in this phase, the `get_item_type_scheme()` function\n //! triggers a recursive call to `ty_of_item()`  (note that\n //! `ast_ty_to_ty()` will detect recursive types and report an error).\n //! In the check phase, when the FnCtxt is used as the `AstConv`,\n-//! `get_item_ty()` just looks up the item type in `tcx.tcache`.\n+//! `get_item_type_scheme()` just looks up the item type in `tcx.tcache`.\n //!\n //! The `RegionScope` trait controls what happens when the user does\n //! not specify a region in some location where a region is required\n@@ -70,7 +70,7 @@ use syntax::print::pprust;\n \n pub trait AstConv<'tcx> {\n     fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx>;\n-    fn get_item_ty(&self, id: ast::DefId) -> ty::Polytype<'tcx>;\n+    fn get_item_type_scheme(&self, id: ast::DefId) -> ty::TypeScheme<'tcx>;\n     fn get_trait_def(&self, id: ast::DefId) -> Rc<ty::TraitDef<'tcx>>;\n \n     /// Return an (optional) substitution to convert bound type parameters that\n@@ -650,10 +650,10 @@ pub fn ast_path_to_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n     -> TypeAndSubsts<'tcx>\n {\n     let tcx = this.tcx();\n-    let ty::Polytype {\n+    let ty::TypeScheme {\n         generics,\n         ty: decl_ty\n-    } = this.get_item_ty(did);\n+    } = this.get_item_type_scheme(did);\n \n     let substs = ast_path_substs_for_ty(this,\n                                         rscope,\n@@ -678,10 +678,10 @@ pub fn ast_path_to_ty_relaxed<'tcx,AC,RS>(\n     where AC : AstConv<'tcx>, RS : RegionScope\n {\n     let tcx = this.tcx();\n-    let ty::Polytype {\n+    let ty::TypeScheme {\n         generics,\n         ty: decl_ty\n-    } = this.get_item_ty(did);\n+    } = this.get_item_type_scheme(did);\n \n     let wants_params =\n         generics.has_type_params(TypeSpace) || generics.has_region_params(TypeSpace);"}, {"sha": "4fbae637800684219d062f7c299250dfb9295f8f", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/771dd54ea6c09ac32093a46a0d9ed80502ce3b02/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/771dd54ea6c09ac32093a46a0d9ed80502ce3b02/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=771dd54ea6c09ac32093a46a0d9ed80502ce3b02", "patch": "@@ -79,9 +79,9 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n         }\n         ast::PatEnum(..) | ast::PatIdent(..) if pat_is_const(&tcx.def_map, pat) => {\n             let const_did = tcx.def_map.borrow()[pat.id].clone().def_id();\n-            let const_pty = ty::lookup_item_type(tcx, const_did);\n-            fcx.write_ty(pat.id, const_pty.ty);\n-            demand::suptype(fcx, pat.span, expected, const_pty.ty);\n+            let const_scheme = ty::lookup_item_type(tcx, const_did);\n+            fcx.write_ty(pat.id, const_scheme.ty);\n+            demand::suptype(fcx, pat.span, expected, const_scheme.ty);\n         }\n         ast::PatIdent(bm, ref path, ref sub) if pat_is_binding(&tcx.def_map, pat) => {\n             let typ = fcx.local_ty(pat.span, pat.id);\n@@ -395,16 +395,16 @@ pub fn check_pat_enum<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>, pat: &ast::Pat,\n     let enum_def = def.variant_def_ids()\n         .map_or_else(|| def.def_id(), |(enum_def, _)| enum_def);\n \n-    let ctor_pty = ty::lookup_item_type(tcx, enum_def);\n-    let path_ty = if ty::is_fn_ty(ctor_pty.ty) {\n-        ty::Polytype {\n-            ty: ty::ty_fn_ret(ctor_pty.ty).unwrap(),\n-            ..ctor_pty\n+    let ctor_scheme = ty::lookup_item_type(tcx, enum_def);\n+    let path_scheme = if ty::is_fn_ty(ctor_scheme.ty) {\n+        ty::TypeScheme {\n+            ty: ty::ty_fn_ret(ctor_scheme.ty).unwrap(),\n+            ..ctor_scheme\n         }\n     } else {\n-        ctor_pty\n+        ctor_scheme\n     };\n-    instantiate_path(pcx.fcx, path, path_ty, def, pat.span, pat.id);\n+    instantiate_path(pcx.fcx, path, path_scheme, def, pat.span, pat.id);\n \n     let pat_ty = fcx.node_ty(pat.id);\n     demand::eqtype(fcx, pat.span, expected, pat_ty);"}, {"sha": "bb1b24f4b487a713ae194bc3df39cec3d03afc45", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/771dd54ea6c09ac32093a46a0d9ed80502ce3b02/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/771dd54ea6c09ac32093a46a0d9ed80502ce3b02/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=771dd54ea6c09ac32093a46a0d9ed80502ce3b02", "patch": "@@ -91,7 +91,7 @@ use middle::pat_util::{mod, pat_id_map};\n use middle::region::CodeExtent;\n use middle::subst::{mod, Subst, Substs, VecPerParamSpace, ParamSpace};\n use middle::traits;\n-use middle::ty::{FnSig, VariantInfo, Polytype};\n+use middle::ty::{FnSig, VariantInfo, TypeScheme};\n use middle::ty::{Disr, ParamTy, ParameterEnvironment};\n use middle::ty::{mod, Ty};\n use middle::ty::liberate_late_bound_regions;\n@@ -1510,7 +1510,7 @@ fn check_cast(fcx: &FnCtxt,\n impl<'a, 'tcx> AstConv<'tcx> for FnCtxt<'a, 'tcx> {\n     fn tcx(&self) -> &ty::ctxt<'tcx> { self.ccx.tcx }\n \n-    fn get_item_ty(&self, id: ast::DefId) -> ty::Polytype<'tcx> {\n+    fn get_item_type_scheme(&self, id: ast::DefId) -> ty::TypeScheme<'tcx> {\n         ty::lookup_item_type(self.tcx(), id)\n     }\n \n@@ -1739,22 +1739,22 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             def_id: ast::DefId)\n                             -> TypeAndSubsts<'tcx>\n     {\n-        let polytype =\n+        let type_scheme =\n             ty::lookup_item_type(self.tcx(), def_id);\n         let substs =\n             self.infcx().fresh_substs_for_generics(\n                 span,\n-                &polytype.generics);\n+                &type_scheme.generics);\n         let bounds =\n-            polytype.generics.to_bounds(self.tcx(), &substs);\n+            type_scheme.generics.to_bounds(self.tcx(), &substs);\n         self.add_obligations_for_parameters(\n             traits::ObligationCause::new(\n                 span,\n                 self.body_id,\n                 traits::ItemObligation(def_id)),\n             &bounds);\n         let monotype =\n-            polytype.ty.subst(self.tcx(), &substs);\n+            type_scheme.ty.subst(self.tcx(), &substs);\n \n         TypeAndSubsts {\n             ty: monotype,\n@@ -3829,7 +3829,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n       }\n       ast::ExprPath(ref pth) => {\n           let defn = lookup_def(fcx, pth.span, id);\n-          let pty = polytype_for_def(fcx, expr.span, defn);\n+          let pty = type_scheme_for_def(fcx, expr.span, defn);\n           instantiate_path(fcx, pth, pty, defn, expr.span, expr.id);\n \n           // We always require that the type provided as the value for\n@@ -4922,10 +4922,10 @@ pub fn lookup_def(fcx: &FnCtxt, sp: Span, id: ast::NodeId) -> def::Def {\n }\n \n // Returns the type parameter count and the type for the given definition.\n-pub fn polytype_for_def<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n-                                  sp: Span,\n-                                  defn: def::Def)\n-                                  -> Polytype<'tcx> {\n+pub fn type_scheme_for_def<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n+                                     sp: Span,\n+                                     defn: def::Def)\n+                                     -> TypeScheme<'tcx> {\n     match defn {\n       def::DefLocal(nid) | def::DefUpvar(nid, _, _) => {\n           let typ = fcx.local_ty(sp, nid);\n@@ -4969,15 +4969,15 @@ pub fn polytype_for_def<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n // number of type parameters and type.\n pub fn instantiate_path<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                   path: &ast::Path,\n-                                  polytype: Polytype<'tcx>,\n+                                  type_scheme: TypeScheme<'tcx>,\n                                   def: def::Def,\n                                   span: Span,\n                                   node_id: ast::NodeId) {\n-    debug!(\"instantiate_path(path={}, def={}, node_id={}, polytype={})\",\n+    debug!(\"instantiate_path(path={}, def={}, node_id={}, type_scheme={})\",\n            path.repr(fcx.tcx()),\n            def.repr(fcx.tcx()),\n            node_id,\n-           polytype.repr(fcx.tcx()));\n+           type_scheme.repr(fcx.tcx()));\n \n     // We need to extract the type parameters supplied by the user in\n     // the path `path`. Due to the current setup, this is a bit of a\n@@ -5102,8 +5102,8 @@ pub fn instantiate_path<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n \n     // Next, examine the definition, and determine how many type\n     // parameters we expect from each space.\n-    let type_defs = &polytype.generics.types;\n-    let region_defs = &polytype.generics.regions;\n+    let type_defs = &type_scheme.generics.types;\n+    let region_defs = &type_scheme.generics.regions;\n \n     // Now that we have categorized what space the parameters for each\n     // segment belong to, let's sort out the parameters that the user\n@@ -5151,12 +5151,12 @@ pub fn instantiate_path<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     // the fn itself). Those should be replaced with fresh variables\n     // now. These can appear either on the type being referenced, or\n     // on the associated bounds.\n-    let bounds = polytype.generics.to_bounds(fcx.tcx(), &substs);\n+    let bounds = type_scheme.generics.to_bounds(fcx.tcx(), &substs);\n     let (ty_late_bound, bounds) =\n         fcx.infcx().replace_late_bound_regions_with_fresh_var(\n             span,\n             infer::FnCall,\n-            &ty::Binder((polytype.ty, bounds))).0;\n+            &ty::Binder((type_scheme.ty, bounds))).0;\n \n     debug!(\"after late-bounds have been replaced: ty_late_bound={}\", ty_late_bound.repr(fcx.tcx()));\n     debug!(\"after late-bounds have been replaced: bounds={}\", bounds.repr(fcx.tcx()));"}, {"sha": "3ddc81d40a5daa87d2f6128b504e7084f8dc33bc", "filename": "src/librustc_typeck/check/wf.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/771dd54ea6c09ac32093a46a0d9ed80502ce3b02/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/771dd54ea6c09ac32093a46a0d9ed80502ce3b02/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs?ref=771dd54ea6c09ac32093a46a0d9ed80502ce3b02", "patch": "@@ -147,8 +147,8 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n                                                         item.span,\n                                                         region::CodeExtent::from_node_id(item.id),\n                                                         Some(&mut this.cache));\n-            let polytype = ty::lookup_item_type(fcx.tcx(), local_def(item.id));\n-            let item_ty = polytype.ty.subst(fcx.tcx(), &fcx.inh.param_env.free_substs);\n+            let type_scheme = ty::lookup_item_type(fcx.tcx(), local_def(item.id));\n+            let item_ty = type_scheme.ty.subst(fcx.tcx(), &fcx.inh.param_env.free_substs);\n             bounds_checker.check_traits_in_ty(item_ty);\n         });\n     }\n@@ -313,14 +313,14 @@ impl<'cx,'tcx> TypeFolder<'tcx> for BoundsChecker<'cx,'tcx> {\n         match t.sty{\n             ty::ty_struct(type_id, substs) |\n             ty::ty_enum(type_id, substs) => {\n-                let polytype = ty::lookup_item_type(self.fcx.tcx(), type_id);\n+                let type_scheme = ty::lookup_item_type(self.fcx.tcx(), type_id);\n \n                 if self.binding_count == 0 {\n                     self.fcx.add_obligations_for_parameters(\n                         traits::ObligationCause::new(self.span,\n                                                      self.fcx.body_id,\n                                                      traits::ItemObligation(type_id)),\n-                        &polytype.generics.to_bounds(self.tcx(), substs));\n+                        &type_scheme.generics.to_bounds(self.tcx(), substs));\n                 } else {\n                     // There are two circumstances in which we ignore\n                     // region obligations.\n@@ -344,7 +344,7 @@ impl<'cx,'tcx> TypeFolder<'tcx> for BoundsChecker<'cx,'tcx> {\n                     //\n                     // (I believe we should do the same for traits, but\n                     // that will require an RFC. -nmatsakis)\n-                    let bounds = polytype.generics.to_bounds(self.tcx(), substs);\n+                    let bounds = type_scheme.generics.to_bounds(self.tcx(), substs);\n                     let bounds = filter_to_trait_obligations(bounds);\n                     self.fcx.add_obligations_for_parameters(\n                         traits::ObligationCause::new(self.span,"}, {"sha": "30039f2ecc1cf5e724a3c50d3e4ced784895b3d9", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/771dd54ea6c09ac32093a46a0d9ed80502ce3b02/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/771dd54ea6c09ac32093a46a0d9ed80502ce3b02/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=771dd54ea6c09ac32093a46a0d9ed80502ce3b02", "patch": "@@ -23,7 +23,7 @@ use middle::ty::RegionEscape;\n use middle::ty::{ImplContainer, ImplOrTraitItemId, MethodTraitItemId};\n use middle::ty::{ParameterEnvironment, TypeTraitItemId, lookup_item_type};\n use middle::ty::{Ty, ty_bool, ty_char, ty_closure, ty_enum, ty_err};\n-use middle::ty::{ty_param, Polytype, ty_ptr};\n+use middle::ty::{ty_param, TypeScheme, ty_ptr};\n use middle::ty::{ty_rptr, ty_struct, ty_trait, ty_tup};\n use middle::ty::{ty_str, ty_vec, ty_float, ty_infer, ty_int, ty_open};\n use middle::ty::{ty_uint, ty_unboxed_closure, ty_uniq, ty_bare_fn};\n@@ -206,7 +206,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n         debug!(\"instantiate_default_methods(impl_id={}, trait_ref={})\",\n                impl_id, trait_ref.repr(tcx));\n \n-        let impl_poly_type = ty::lookup_item_type(tcx, impl_id);\n+        let impl_type_scheme = ty::lookup_item_type(tcx, impl_id);\n \n         let prov = ty::provided_trait_methods(tcx, trait_ref.def_id);\n         for trait_method in prov.iter() {\n@@ -221,7 +221,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n                 Rc::new(subst_receiver_types_in_method_ty(\n                     tcx,\n                     impl_id,\n-                    &impl_poly_type,\n+                    &impl_type_scheme,\n                     trait_ref,\n                     new_did,\n                     &**trait_method,\n@@ -233,7 +233,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n             // construct the polytype for the method based on the\n             // method_ty.  it will have all the generics from the\n             // impl, plus its own.\n-            let new_polytype = ty::Polytype {\n+            let new_polytype = ty::TypeScheme {\n                 generics: new_method_ty.generics.clone(),\n                 ty: ty::mk_bare_fn(tcx, Some(new_did),\n                                    tcx.mk_bare_fn(new_method_ty.fty.clone()))\n@@ -275,7 +275,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n     }\n \n     fn get_self_type_for_implementation(&self, impl_did: DefId)\n-                                        -> Polytype<'tcx> {\n+                                        -> TypeScheme<'tcx> {\n         self.crate_context.tcx.tcache.borrow()[impl_did].clone()\n     }\n \n@@ -535,7 +535,7 @@ fn enforce_trait_manually_implementable(tcx: &ty::ctxt, sp: Span, trait_def_id:\n \n fn subst_receiver_types_in_method_ty<'tcx>(tcx: &ty::ctxt<'tcx>,\n                                            impl_id: ast::DefId,\n-                                           impl_poly_type: &ty::Polytype<'tcx>,\n+                                           impl_type_scheme: &ty::TypeScheme<'tcx>,\n                                            trait_ref: &ty::TraitRef<'tcx>,\n                                            new_def_id: ast::DefId,\n                                            method: &ty::Method<'tcx>,\n@@ -554,10 +554,10 @@ fn subst_receiver_types_in_method_ty<'tcx>(tcx: &ty::ctxt<'tcx>,\n     for &space in [subst::TypeSpace, subst::SelfSpace].iter() {\n         method_generics.types.replace(\n             space,\n-            impl_poly_type.generics.types.get_slice(space).to_vec());\n+            impl_type_scheme.generics.types.get_slice(space).to_vec());\n         method_generics.regions.replace(\n             space,\n-            impl_poly_type.generics.regions.get_slice(space).to_vec());\n+            impl_type_scheme.generics.regions.get_slice(space).to_vec());\n     }\n \n     debug!(\"subst_receiver_types_in_method_ty: method_generics={}\","}, {"sha": "74cfbb117e9a36794c694e7f9ea1519c7ad34ac1", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 66, "deletions": 66, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/771dd54ea6c09ac32093a46a0d9ed80502ce3b02/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/771dd54ea6c09ac32093a46a0d9ed80502ce3b02/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=771dd54ea6c09ac32093a46a0d9ed80502ce3b02", "patch": "@@ -23,8 +23,8 @@ Unlike most of the types that are present in Rust, the types computed\n for each item are in fact polytypes.  In \"layman's terms\", this means\n that they are generic types that may have type parameters (more\n mathematically phrased, they are universally quantified over a set of\n-type parameters).  Polytypes are represented by an instance of\n-`ty::Polytype`.  This combines the core type along with a list of the\n+type parameters).  TypeSchemes are represented by an instance of\n+`ty::TypeScheme`.  This combines the core type along with a list of the\n bounds for each parameter.  Type parameters themselves are represented\n as `ty_param()` instances.\n \n@@ -43,7 +43,7 @@ use middle::resolve_lifetime;\n use middle::subst;\n use middle::subst::{Substs};\n use middle::ty::{AsPredicate, ImplContainer, ImplOrTraitItemContainer, TraitContainer};\n-use middle::ty::{mod, RegionEscape, Ty, Polytype};\n+use middle::ty::{mod, RegionEscape, Ty, TypeScheme};\n use middle::ty_fold::{mod, TypeFolder, TypeFoldable};\n use middle::infer;\n use rscope::*;\n@@ -70,8 +70,8 @@ use syntax::visit;\n pub fn collect_item_types(ccx: &CrateCtxt) {\n     fn collect_intrinsic_type(ccx: &CrateCtxt,\n                               lang_item: ast::DefId) {\n-        let ty::Polytype { ty, .. } =\n-            ccx.get_item_ty(lang_item);\n+        let ty::TypeScheme { ty, .. } =\n+            ccx.get_item_type_scheme(lang_item);\n         ccx.tcx.intrinsic_defs.borrow_mut().insert(lang_item, ty);\n     }\n \n@@ -154,7 +154,7 @@ impl<'a,'tcx> ToTy<'tcx> for CrateCtxt<'a,'tcx> {\n impl<'a, 'tcx> AstConv<'tcx> for CrateCtxt<'a, 'tcx> {\n     fn tcx(&self) -> &ty::ctxt<'tcx> { self.tcx }\n \n-    fn get_item_ty(&self, id: ast::DefId) -> ty::Polytype<'tcx> {\n+    fn get_item_type_scheme(&self, id: ast::DefId) -> ty::TypeScheme<'tcx> {\n         if id.krate != ast::LOCAL_CRATE {\n             return csearch::get_type(self.tcx, id)\n         }\n@@ -170,8 +170,8 @@ impl<'a, 'tcx> AstConv<'tcx> for CrateCtxt<'a, 'tcx> {\n             }\n             x => {\n                 self.tcx.sess.bug(format!(\"unexpected sort of node \\\n-                                           in get_item_ty(): {}\",\n-                                          x)[]);\n+                                           in get_item_type_scheme(): {}\",\n+                                          x).as_slice());\n             }\n         }\n     }\n@@ -227,28 +227,28 @@ pub fn get_enum_variant_types<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n             }\n \n             ast::StructVariantKind(ref struct_def) => {\n-                let pty = Polytype {\n+                let scheme = TypeScheme {\n                     generics: ty_generics_for_type_or_impl(\n                         ccx,\n                         generics,\n                         DontCreateTypeParametersForAssociatedTypes),\n                     ty: enum_ty\n                 };\n \n-                convert_struct(ccx, &**struct_def, pty, variant.node.id);\n+                convert_struct(ccx, &**struct_def, scheme, variant.node.id);\n                 enum_ty\n             }\n         };\n \n-        let pty = Polytype {\n+        let scheme = TypeScheme {\n             generics: ty_generics_for_type_or_impl(\n                           ccx,\n                           generics,\n                           DontCreateTypeParametersForAssociatedTypes),\n             ty: result_ty\n         };\n \n-        tcx.tcache.borrow_mut().insert(variant_def_id, pty);\n+        tcx.tcache.borrow_mut().insert(variant_def_id, scheme);\n \n         write_ty_to_tcx(tcx, variant.node.id, result_ty);\n     }\n@@ -353,7 +353,7 @@ fn collect_trait_methods<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     fn make_method_ty<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>, m: &ty::Method<'tcx>) {\n         ccx.tcx.tcache.borrow_mut().insert(\n             m.def_id,\n-            Polytype {\n+            TypeScheme {\n                 generics: m.generics.clone(),\n                 ty: ty::mk_bare_fn(ccx.tcx, Some(m.def_id), ccx.tcx.mk_bare_fn(m.fty.clone())) });\n     }\n@@ -416,7 +416,7 @@ pub fn convert_field<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     write_ty_to_tcx(ccx.tcx, v.node.id, tt);\n     /* add the field to the tcache */\n     ccx.tcx.tcache.borrow_mut().insert(local_def(v.node.id),\n-                                       ty::Polytype {\n+                                       ty::TypeScheme {\n                                            generics: struct_generics.clone(),\n                                            ty: tt\n                                        });\n@@ -536,7 +536,7 @@ fn convert_methods<'a,'tcx,'i,I>(ccx: &CrateCtxt<'a, 'tcx>,\n                 fty.repr(tcx));\n         tcx.tcache.borrow_mut().insert(\n             m_def_id,\n-            Polytype {\n+            TypeScheme {\n                 generics: mty.generics.clone(),\n                 ty: fty\n             });\n@@ -1034,11 +1034,11 @@ pub fn convert(ccx: &CrateCtxt, it: &ast::Item) {\n         // These don't define types.\n         ast::ItemForeignMod(_) | ast::ItemMod(_) | ast::ItemMac(_) => {}\n         ast::ItemEnum(ref enum_definition, ref generics) => {\n-            let pty = ty_of_item(ccx, it);\n-            write_ty_to_tcx(tcx, it.id, pty.ty);\n+            let scheme = ty_of_item(ccx, it);\n+            write_ty_to_tcx(tcx, it.id, scheme.ty);\n             get_enum_variant_types(ccx,\n-                                   pty.ty,\n-                                   enum_definition.variants[],\n+                                   scheme.ty,\n+                                   enum_definition.variants.as_slice(),\n                                    generics);\n         },\n         ast::ItemImpl(_,\n@@ -1058,7 +1058,7 @@ pub fn convert(ccx: &CrateCtxt, it: &ast::Item) {\n             tcx.tcache\n                .borrow_mut()\n                .insert(local_def(it.id),\n-                       Polytype {\n+                       TypeScheme {\n                         generics: ty_generics.clone(),\n                         ty: selfty,\n                        });\n@@ -1105,7 +1105,7 @@ pub fn convert(ccx: &CrateCtxt, it: &ast::Item) {\n                         tcx.tcache\n                            .borrow_mut()\n                            .insert(local_def(typedef.id),\n-                                   Polytype {\n+                                   TypeScheme {\n                                     generics: ty::Generics::empty(),\n                                     ty: typ,\n                                    });\n@@ -1202,12 +1202,12 @@ pub fn convert(ccx: &CrateCtxt, it: &ast::Item) {\n         },\n         ast::ItemStruct(ref struct_def, _) => {\n             // Write the class type.\n-            let pty = ty_of_item(ccx, it);\n-            write_ty_to_tcx(tcx, it.id, pty.ty);\n+            let scheme = ty_of_item(ccx, it);\n+            write_ty_to_tcx(tcx, it.id, scheme.ty);\n \n-            tcx.tcache.borrow_mut().insert(local_def(it.id), pty.clone());\n+            tcx.tcache.borrow_mut().insert(local_def(it.id), scheme.clone());\n \n-            convert_struct(ccx, &**struct_def, pty, it.id);\n+            convert_struct(ccx, &**struct_def, scheme, it.id);\n         },\n         ast::ItemTy(_, ref generics) => {\n             ensure_no_ty_param_bounds(ccx, it.span, generics, \"type\");\n@@ -1218,22 +1218,22 @@ pub fn convert(ccx: &CrateCtxt, it: &ast::Item) {\n             // This call populates the type cache with the converted type\n             // of the item in passing. All we have to do here is to write\n             // it into the node type table.\n-            let pty = ty_of_item(ccx, it);\n-            write_ty_to_tcx(tcx, it.id, pty.ty);\n+            let scheme = ty_of_item(ccx, it);\n+            write_ty_to_tcx(tcx, it.id, scheme.ty);\n         },\n     }\n }\n \n pub fn convert_struct<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                 struct_def: &ast::StructDef,\n-                                pty: ty::Polytype<'tcx>,\n+                                scheme: ty::TypeScheme<'tcx>,\n                                 id: ast::NodeId) {\n     let tcx = ccx.tcx;\n \n     // Write the type of each of the members and check for duplicate fields.\n     let mut seen_fields: FnvHashMap<ast::Name, Span> = FnvHashMap::new();\n     let field_tys = struct_def.fields.iter().map(|f| {\n-        let result = convert_field(ccx, &pty.generics, f, local_def(id));\n+        let result = convert_field(ccx, &scheme.generics, f, local_def(id));\n \n         if result.name != special_idents::unnamed_field.name {\n             let dup = match seen_fields.get(&result.name) {\n@@ -1258,7 +1258,7 @@ pub fn convert_struct<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n \n     tcx.struct_fields.borrow_mut().insert(local_def(id), Rc::new(field_tys));\n \n-    let substs = mk_item_substs(ccx, &pty.generics);\n+    let substs = mk_item_substs(ccx, &scheme.generics);\n     let selfty = ty::mk_struct(tcx, local_def(id), tcx.mk_substs(substs));\n \n     // If this struct is enum-like or tuple-like, create the type of its\n@@ -1270,7 +1270,7 @@ pub fn convert_struct<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                 // Enum-like.\n                 write_ty_to_tcx(tcx, ctor_id, selfty);\n \n-                tcx.tcache.borrow_mut().insert(local_def(ctor_id), pty);\n+                tcx.tcache.borrow_mut().insert(local_def(ctor_id), scheme);\n             } else if struct_def.fields[0].node.kind.is_unnamed() {\n                 // Tuple-like.\n                 let inputs: Vec<_> = struct_def.fields.iter().map(\n@@ -1282,8 +1282,8 @@ pub fn convert_struct<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                                 selfty);\n                 write_ty_to_tcx(tcx, ctor_id, ctor_fn_ty);\n                 tcx.tcache.borrow_mut().insert(local_def(ctor_id),\n-                                  Polytype {\n-                    generics: pty.generics,\n+                                  TypeScheme {\n+                    generics: scheme.generics,\n                     ty: ctor_fn_ty\n                 });\n             }\n@@ -1302,10 +1302,10 @@ pub fn convert_foreign(ccx: &CrateCtxt, i: &ast::ForeignItem) {\n     // convenient way to extract the ABI. - ndm\n     let abi = ccx.tcx.map.get_foreign_abi(i.id);\n \n-    let pty = ty_of_foreign_item(ccx, i, abi);\n-    write_ty_to_tcx(ccx.tcx, i.id, pty.ty);\n+    let scheme = ty_of_foreign_item(ccx, i, abi);\n+    write_ty_to_tcx(ccx.tcx, i.id, scheme.ty);\n \n-    ccx.tcx.tcache.borrow_mut().insert(local_def(i.id), pty);\n+    ccx.tcx.tcache.borrow_mut().insert(local_def(i.id), scheme);\n }\n \n fn get_trait_def<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n@@ -1429,19 +1429,19 @@ pub fn trait_def_of_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n }\n \n pub fn ty_of_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>, it: &ast::Item)\n-                            -> ty::Polytype<'tcx> {\n+                            -> ty::TypeScheme<'tcx> {\n     let def_id = local_def(it.id);\n     let tcx = ccx.tcx;\n-    if let Some(pty) = tcx.tcache.borrow().get(&def_id) {\n-        return pty.clone();\n+    if let Some(scheme) = tcx.tcache.borrow().get(&def_id) {\n+        return scheme.clone();\n     }\n     match it.node {\n         ast::ItemStatic(ref t, _, _) | ast::ItemConst(ref t, _) => {\n             let typ = ccx.to_ty(&ExplicitRscope, &**t);\n-            let pty = no_params(typ);\n+            let scheme = no_params(typ);\n \n-            tcx.tcache.borrow_mut().insert(local_def(it.id), pty.clone());\n-            return pty;\n+            tcx.tcache.borrow_mut().insert(local_def(it.id), scheme.clone());\n+            return scheme;\n         }\n         ast::ItemFn(ref decl, unsafety, abi, ref generics, _) => {\n             let ty_generics = ty_generics_for_fn_or_method(\n@@ -1456,27 +1456,27 @@ pub fn ty_of_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>, it: &ast::Item)\n                 };\n                 astconv::ty_of_bare_fn(&fcx, unsafety, abi, &**decl)\n             };\n-            let pty = Polytype {\n+            let scheme = TypeScheme {\n                 generics: ty_generics,\n                 ty: ty::mk_bare_fn(ccx.tcx, Some(local_def(it.id)), ccx.tcx.mk_bare_fn(tofd))\n             };\n             debug!(\"type of {} (id {}) is {}\",\n                     token::get_ident(it.ident),\n                     it.id,\n-                    pty.repr(tcx));\n+                    scheme.repr(tcx));\n \n-            ccx.tcx.tcache.borrow_mut().insert(local_def(it.id), pty.clone());\n-            return pty;\n+            ccx.tcx.tcache.borrow_mut().insert(local_def(it.id), scheme.clone());\n+            return scheme;\n         }\n         ast::ItemTy(ref t, ref generics) => {\n             match tcx.tcache.borrow_mut().get(&local_def(it.id)) {\n-                Some(pty) => return pty.clone(),\n+                Some(scheme) => return scheme.clone(),\n                 None => { }\n             }\n \n-            let pty = {\n+            let scheme = {\n                 let ty = ccx.to_ty(&ExplicitRscope, &**t);\n-                Polytype {\n+                TypeScheme {\n                     generics: ty_generics_for_type_or_impl(\n                                   ccx,\n                                   generics,\n@@ -1485,8 +1485,8 @@ pub fn ty_of_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>, it: &ast::Item)\n                 }\n             };\n \n-            tcx.tcache.borrow_mut().insert(local_def(it.id), pty.clone());\n-            return pty;\n+            tcx.tcache.borrow_mut().insert(local_def(it.id), scheme.clone());\n+            return scheme;\n         }\n         ast::ItemEnum(_, ref generics) => {\n             // Create a new generic polytype.\n@@ -1496,13 +1496,13 @@ pub fn ty_of_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>, it: &ast::Item)\n                 DontCreateTypeParametersForAssociatedTypes);\n             let substs = mk_item_substs(ccx, &ty_generics);\n             let t = ty::mk_enum(tcx, local_def(it.id), tcx.mk_substs(substs));\n-            let pty = Polytype {\n+            let scheme = TypeScheme {\n                 generics: ty_generics,\n                 ty: t\n             };\n \n-            tcx.tcache.borrow_mut().insert(local_def(it.id), pty.clone());\n-            return pty;\n+            tcx.tcache.borrow_mut().insert(local_def(it.id), scheme.clone());\n+            return scheme;\n         }\n         ast::ItemTrait(..) => {\n             tcx.sess.span_bug(it.span, \"invoked ty_of_item on trait\");\n@@ -1514,13 +1514,13 @@ pub fn ty_of_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>, it: &ast::Item)\n                 DontCreateTypeParametersForAssociatedTypes);\n             let substs = mk_item_substs(ccx, &ty_generics);\n             let t = ty::mk_struct(tcx, local_def(it.id), tcx.mk_substs(substs));\n-            let pty = Polytype {\n+            let scheme = TypeScheme {\n                 generics: ty_generics,\n                 ty: t\n             };\n \n-            tcx.tcache.borrow_mut().insert(local_def(it.id), pty.clone());\n-            return pty;\n+            tcx.tcache.borrow_mut().insert(local_def(it.id), scheme.clone());\n+            return scheme;\n         }\n         ast::ItemImpl(..) | ast::ItemMod(_) |\n         ast::ItemForeignMod(_) | ast::ItemMac(_) => panic!(),\n@@ -1529,7 +1529,7 @@ pub fn ty_of_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>, it: &ast::Item)\n \n pub fn ty_of_foreign_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                     it: &ast::ForeignItem,\n-                                    abi: abi::Abi) -> ty::Polytype<'tcx>\n+                                    abi: abi::Abi) -> ty::TypeScheme<'tcx>\n {\n     match it.node {\n         ast::ForeignItemFn(ref fn_decl, ref generics) => {\n@@ -1540,7 +1540,7 @@ pub fn ty_of_foreign_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                   abi)\n         }\n         ast::ForeignItemStatic(ref t, _) => {\n-            ty::Polytype {\n+            ty::TypeScheme {\n                 generics: ty::Generics::empty(),\n                 ty: ast_ty_to_ty(ccx, &ExplicitRscope, &**t)\n             }\n@@ -2107,7 +2107,7 @@ pub fn ty_of_foreign_fn_decl<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                        def_id: ast::DefId,\n                                        ast_generics: &ast::Generics,\n                                        abi: abi::Abi)\n-                                       -> ty::Polytype<'tcx> {\n+                                       -> ty::TypeScheme<'tcx> {\n     for i in decl.inputs.iter() {\n         match (*i).pat.node {\n             ast::PatIdent(_, _, _) => (),\n@@ -2144,16 +2144,16 @@ pub fn ty_of_foreign_fn_decl<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n             abi: abi,\n             unsafety: ast::Unsafety::Unsafe,\n             sig: ty::Binder(ty::FnSig {inputs: input_tys,\n-                            output: output,\n-                            variadic: decl.variadic})\n-        }));\n-    let pty = Polytype {\n+                                       output: output,\n+                                       variadic: decl.variadic}),\n+        });\n+    let scheme = TypeScheme {\n         generics: ty_generics_for_fn_or_method,\n         ty: t_fn\n     };\n \n-    ccx.tcx.tcache.borrow_mut().insert(def_id, pty.clone());\n-    return pty;\n+    ccx.tcx.tcache.borrow_mut().insert(def_id, scheme.clone());\n+    return scheme;\n }\n \n pub fn mk_item_substs<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,"}, {"sha": "a903c8b0d55aa41767e34e5528bc5dc801e81976", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/771dd54ea6c09ac32093a46a0d9ed80502ce3b02/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/771dd54ea6c09ac32093a46a0d9ed80502ce3b02/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=771dd54ea6c09ac32093a46a0d9ed80502ce3b02", "patch": "@@ -159,8 +159,8 @@ fn lookup_def_ccx(ccx: &CrateCtxt, sp: Span, id: ast::NodeId)\n     lookup_def_tcx(ccx.tcx, sp, id)\n }\n \n-fn no_params<'tcx>(t: Ty<'tcx>) -> ty::Polytype<'tcx> {\n-    ty::Polytype {\n+fn no_params<'tcx>(t: Ty<'tcx>) -> ty::TypeScheme<'tcx> {\n+    ty::TypeScheme {\n         generics: ty::Generics {\n             types: VecPerParamSpace::empty(),\n             regions: VecPerParamSpace::empty(),"}]}