{"sha": "df6052c4f88fbc9118411967d236576ae45d7dc5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRmNjA1MmM0Zjg4ZmJjOTExODQxMTk2N2QyMzY1NzZhZTQ1ZDdkYzU=", "commit": {"author": {"name": "Josh Matthews", "email": "josh@joshmatthews.net", "date": "2011-12-19T04:32:38Z"}, "committer": {"name": "Josh Matthews", "email": "josh@joshmatthews.net", "date": "2011-12-19T04:53:44Z"}, "message": "Remove source line generation craziness. Ensure incorrect subprogram caches are not conflated. Generate ast_map entries for object members and resource constructors and destructors.", "tree": {"sha": "bc8abe8d78602eef42f1743c21149ce6f8f89c66", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bc8abe8d78602eef42f1743c21149ce6f8f89c66"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/df6052c4f88fbc9118411967d236576ae45d7dc5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/df6052c4f88fbc9118411967d236576ae45d7dc5", "html_url": "https://github.com/rust-lang/rust/commit/df6052c4f88fbc9118411967d236576ae45d7dc5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/df6052c4f88fbc9118411967d236576ae45d7dc5/comments", "author": {"login": "jdm", "id": 27658, "node_id": "MDQ6VXNlcjI3NjU4", "avatar_url": "https://avatars.githubusercontent.com/u/27658?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jdm", "html_url": "https://github.com/jdm", "followers_url": "https://api.github.com/users/jdm/followers", "following_url": "https://api.github.com/users/jdm/following{/other_user}", "gists_url": "https://api.github.com/users/jdm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jdm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jdm/subscriptions", "organizations_url": "https://api.github.com/users/jdm/orgs", "repos_url": "https://api.github.com/users/jdm/repos", "events_url": "https://api.github.com/users/jdm/events{/privacy}", "received_events_url": "https://api.github.com/users/jdm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jdm", "id": 27658, "node_id": "MDQ6VXNlcjI3NjU4", "avatar_url": "https://avatars.githubusercontent.com/u/27658?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jdm", "html_url": "https://github.com/jdm", "followers_url": "https://api.github.com/users/jdm/followers", "following_url": "https://api.github.com/users/jdm/following{/other_user}", "gists_url": "https://api.github.com/users/jdm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jdm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jdm/subscriptions", "organizations_url": "https://api.github.com/users/jdm/orgs", "repos_url": "https://api.github.com/users/jdm/repos", "events_url": "https://api.github.com/users/jdm/events{/privacy}", "received_events_url": "https://api.github.com/users/jdm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c6f16ed2c418268f2acbb8728f265b3b960f8efd", "url": "https://api.github.com/repos/rust-lang/rust/commits/c6f16ed2c418268f2acbb8728f265b3b960f8efd", "html_url": "https://github.com/rust-lang/rust/commit/c6f16ed2c418268f2acbb8728f265b3b960f8efd"}], "stats": {"total": 562, "additions": 172, "deletions": 390}, "files": [{"sha": "63b7131d15d7671318ee4bbf6c5ce31fbf4129d7", "filename": "src/comp/middle/ast_map.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/df6052c4f88fbc9118411967d236576ae45d7dc5/src%2Fcomp%2Fmiddle%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df6052c4f88fbc9118411967d236576ae45d7dc5/src%2Fcomp%2Fmiddle%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fast_map.rs?ref=df6052c4f88fbc9118411967d236576ae45d7dc5", "patch": "@@ -7,13 +7,15 @@ import syntax::{visit, codemap};\n tag ast_node {\n     node_item(@item);\n     node_obj_ctor(@item);\n+    node_obj_method(@method);\n     node_native_item(@native_item);\n     node_method(@method);\n     node_expr(@expr);\n     // Locals are numbered, because the alias analysis needs to know in which\n     // order they are introduced.\n     node_arg(arg, uint);\n     node_local(uint);\n+    node_res_ctor(@item);\n }\n \n type map = std::map::hashmap<node_id, ast_node>;\n@@ -63,9 +65,17 @@ fn map_arm(cx: ctx, arm: arm) {\n fn map_item(cx: ctx, i: @item) {\n     cx.map.insert(i.id, node_item(i));\n     alt i.node {\n-      item_obj(_, _, ctor_id) { cx.map.insert(ctor_id, node_obj_ctor(i)); }\n+      item_obj(ob, _, ctor_id) {\n+        cx.map.insert(ctor_id, node_obj_ctor(i));\n+        for m in ob.methods {\n+            cx.map.insert(m.node.id, node_obj_method(m));\n+        }\n+      }\n       item_impl(_, _, ms) {\n         for m in ms { cx.map.insert(m.node.id, node_method(m)); }\n+      item_res(_, dtor_id, _, ctor_id) {\n+        cx.map.insert(ctor_id, node_res_ctor(i));\n+        cx.map.insert(dtor_id, node_item(i));\n       }\n       _ { }\n     }"}, {"sha": "12b26410c88cb76ef585d4ffdd734f87a551ae9a", "filename": "src/comp/middle/debuginfo.rs", "status": "modified", "additions": 57, "deletions": 88, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/df6052c4f88fbc9118411967d236576ae45d7dc5/src%2Fcomp%2Fmiddle%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df6052c4f88fbc9118411967d236576ae45d7dc5/src%2Fcomp%2Fmiddle%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fdebuginfo.rs?ref=df6052c4f88fbc9118411967d236576ae45d7dc5", "patch": "@@ -11,10 +11,7 @@ import util::ppaux::ty_to_str;\n export create_local_var;\n export create_function;\n export create_arg;\n-export add_line_info;\n export update_source_pos;\n-export invalidate_source_pos;\n-export revalidate_source_pos;\n export debug_ctxt;\n \n const LLVMDebugVersion: int = (9 << 16);\n@@ -98,7 +95,7 @@ type metadata<T> = {node: ValueRef, data: T};\n \n type file_md = {path: str};\n type compile_unit_md = {path: str};\n-type subprogram_md = {name: str, file: str};\n+type subprogram_md = {path: str};\n type local_var_md = {id: ast::node_id};\n type tydesc_md = {hash: uint};\n type block_md = {start: codemap::loc, end: codemap::loc};\n@@ -232,7 +229,7 @@ fn create_block(cx: @block_ctxt) -> @metadata<block_md> {\n     }\n \n     let parent = alt cx.parent {\n-      trans_common::parent_none. { function_metadata_from_block(cx).node }\n+      trans_common::parent_none. { create_function(cx.fcx).node }\n       trans_common::parent_some(bcx) { create_block(cx).node }\n     };\n     let file_node = create_file(bcx_ccx(cx), fname);\n@@ -595,14 +592,6 @@ fn create_ty(cx: @crate_ctxt, t: ty::t, ty: @ast::ty) -> @metadata<tydesc_md> {\n     };\n }\n \n-fn function_metadata_from_block(bcx: @block_ctxt) -> @metadata<subprogram_md> {\n-    let cx = bcx_ccx(bcx);\n-    let fcx = bcx_fcx(bcx);\n-    let fn_node = cx.ast_map.get(fcx.id);\n-    let fn_item = alt fn_node { ast_map::node_item(item) { item } };\n-    ret create_function(fcx, fn_item, fcx.llfn);\n-}\n-\n fn filename_from_span(cx: @crate_ctxt, sp: codemap::span) -> str {\n     codemap::lookup_char_pos(cx.sess.get_codemap(), sp.lo).filename\n }\n@@ -640,7 +629,7 @@ fn create_local_var(bcx: @block_ctxt, local: @ast::local)\n     let tymd = create_ty(cx, ty, local.node.ty);\n     let filemd = create_file(cx, loc.filename);\n     let context = alt bcx.parent {\n-      trans_common::parent_none. { function_metadata_from_block(bcx).node }\n+      trans_common::parent_none. { create_function(bcx.fcx).node }\n       trans_common::parent_some(_) { create_block(bcx).node }\n     };\n     let mdnode = create_var(tg, context, name, filemd.node,\n@@ -662,7 +651,6 @@ fn create_local_var(bcx: @block_ctxt, local: @ast::local)\n     ret mdval;\n }\n \n-//FIXME: consolidate with create_local_var\n fn create_arg(bcx: @block_ctxt, arg: ast::arg)\n     -> @metadata<argument_md> unsafe {\n     let fcx = bcx_fcx(bcx);\n@@ -683,9 +671,7 @@ fn create_arg(bcx: @block_ctxt, arg: ast::arg)\n     let ty = trans::node_id_type(cx, arg.id);\n     let tymd = create_ty(cx, ty, arg.ty);\n     let filemd = create_file(cx, loc.filename);\n-    let fn_node = cx.ast_map.get(fcx.id);\n-    let fn_item = alt fn_node { ast_map::node_item(item) { item } };\n-    let context = create_function(fcx, fn_item, fcx.llfn);\n+    let context = create_function(bcx.fcx);\n     let mdnode = create_var(tg, context.node, arg.ident, filemd.node,\n                             loc.line as int, tymd.node);\n     let mdval = @{node: mdnode, data: {id: arg.id}};\n@@ -700,92 +686,76 @@ fn create_arg(bcx: @block_ctxt, arg: ast::arg)\n     ret mdval;\n }\n \n-fn update_source_pos(cx: @block_ctxt, s: codemap::span) -> @debug_source_pos {\n-    let dsp = @debug_source_pos(cx);\n+fn update_source_pos(cx: @block_ctxt, s: codemap::span) {\n     if !bcx_ccx(cx).sess.get_opts().debuginfo {\n-        ret dsp;\n+        ret;\n     }\n     let cm = bcx_ccx(cx).sess.get_codemap();\n-    if vec::is_empty(cx.source_pos.pos) {\n-        cx.source_pos.usable = true;\n-    }\n-    cx.source_pos.pos += [codemap::lookup_char_pos(cm, s.lo)]; //XXX maybe hi\n-    ret dsp;\n+    let blockmd = create_block(cx);\n+    let loc = codemap::lookup_char_pos(cm, s.lo);\n+    let scopedata = [lli32(loc.line as int),\n+                     lli32(loc.col as int),\n+                     blockmd.node,\n+                     llnull()];\n+    let dbgscope = llmdnode(scopedata);\n+    llvm::LLVMSetCurrentDebugLocation(trans_build::B(cx), dbgscope);\n }\n \n-fn invalidate_source_pos(cx: @block_ctxt) -> @invalidated_source_pos {\n-    let isp = @invalidated_source_pos(cx);\n-    if !bcx_ccx(cx).sess.get_opts().debuginfo {\n-        ret isp;\n-    }\n-    cx.source_pos.usable = false;\n-    ret isp;\n-}\n+fn create_function(fcx: @fn_ctxt) -> @metadata<subprogram_md> {\n+    let cx = fcx_ccx(fcx);\n+    let dbg_cx = option::get(cx.dbg_cx);\n \n-fn revalidate_source_pos(cx: @block_ctxt) {\n-    if !bcx_ccx(cx).sess.get_opts().debuginfo {\n-        ret;\n-    }\n-    cx.source_pos.usable = true;\n-}\n+    log \"~~\";\n+    log fcx.id;\n+    log cx.sess.span_str(fcx.sp);\n \n-fn reset_source_pos(cx: @block_ctxt) {\n-    if !bcx_ccx(cx).sess.get_opts().debuginfo {\n-        ret;\n-    }\n-    vec::pop(cx.source_pos.pos);\n-}\n+    let (ident, ret_ty, id) = alt cx.ast_map.get(fcx.id) {\n+      ast_map::node_item(item) {\n+        alt item.node {\n+          ast::item_fn(f, _) | ast::item_res(f, _, _, _) {\n+            (item.ident, f.decl.output, item.id)\n+          }\n+        }\n+      }\n+      ast_map::node_obj_method(method) {\n+        (method.node.ident, method.node.meth.decl.output, method.node.id)\n+      }\n+      ast_map::node_res_ctor(item) {\n+        alt item.node { ast::item_res(f, _, _, ctor_id) {\n+          (item.ident, f.decl.output, ctor_id)\n+        }}\n+      }\n+      ast_map::node_expr(expr) {\n+        alt expr.node {\n+          ast::expr_fn(f) {\n+            (dbg_cx.names.next(\"fn\"), f.decl.output, expr.id)\n+          }\n+        }\n+      }\n+    };\n \n-resource debug_source_pos(bcx: @block_ctxt) {\n-    reset_source_pos(bcx);\n-}\n-resource invalidated_source_pos(bcx: @block_ctxt) {\n-    revalidate_source_pos(bcx);\n-}\n+    log ident;\n+    log id;\n+\n+    let path = str::connect(fcx.lcx.path + [ident], \"::\");\n \n-fn add_line_info(cx: @block_ctxt, llinstr: ValueRef) {\n-    if !bcx_ccx(cx).sess.get_opts().debuginfo ||\n-       !cx.source_pos.usable ||\n-       vec::is_empty(cx.source_pos.pos) {\n-        ret;\n-    }\n-    let loc = option::get(vec::last(cx.source_pos.pos));\n-    let blockmd = create_block(cx);\n-    let kind = \"dbg\";\n-    str::as_buf(kind, {|sbuf| \n-        let kind_id = llvm::LLVMGetMDKindID(sbuf,\n-                                            str::byte_len(kind));\n-        let scopedata = [lli32(loc.line as int),\n-                         lli32(loc.col as int),\n-                         blockmd.node,\n-                         llnull()];\n-        let dbgscope = llmdnode(scopedata);\n-        llvm::LLVMSetMetadata(llinstr, kind_id, dbgscope)\n-    });\n-}\n-\n-fn create_function(fcx: @fn_ctxt, item: @ast::item, llfndecl: ValueRef)\n-    -> @metadata<subprogram_md> {\n-    let cx = fcx_ccx(fcx);\n     let cache = get_cache(cx);\n     alt cached_metadata::<@metadata<subprogram_md>>(\n-        cache, SubprogramTag, {|md| md.data.name == item.ident &&\n+        cache, SubprogramTag, {|md| md.data.path == path &&\n                                     /*md.data.path == ??*/ true}) {\n       option::some(md) { ret md; }\n       option::none. {}\n     }\n \n     let loc = codemap::lookup_char_pos(cx.sess.get_codemap(),\n-                                       item.span.lo);\n+                                       fcx.sp.lo);\n     let file_node = create_file(cx, loc.filename).node;\n-    let mangled = cx.item_symbols.get(item.id);\n-    let ret_ty = alt item.node {\n-      ast::item_fn(f, _) { f.decl.output }\n-    };\n+    let key = cx.item_symbols.contains_key(fcx.id) ? fcx.id : id;\n+    let mangled = cx.item_symbols.get(key);\n     let ty_node = if cx.sess.get_opts().extra_debuginfo {\n         alt ret_ty.node {\n           ast::ty_nil. { llnull() }\n-          _ { create_ty(cx, ty::node_id_to_type(ccx_tcx(cx), item.id),\n+          _ { create_ty(cx, ty::node_id_to_type(ccx_tcx(cx), id),\n                         ret_ty).node }\n         }\n     } else {\n@@ -798,8 +768,8 @@ fn create_function(fcx: @fn_ctxt, item: @ast::item, llfndecl: ValueRef)\n     let fn_metadata = [lltag(SubprogramTag),\n                        llunused(),\n                        file_node,\n-                       llstr(item.ident),\n-                       llstr(item.ident), //XXX fully-qualified C++ name\n+                       llstr(ident),\n+                       llstr(path), //XXX fully-qualified C++ name\n                        llstr(mangled), //XXX MIPS name?????\n                        file_node,\n                        lli32(loc.line as int),\n@@ -811,15 +781,14 @@ fn create_function(fcx: @fn_ctxt, item: @ast::item, llfndecl: ValueRef)\n                        llnull(), // base type with vtbl\n                        lli1(false), // artificial\n                        lli1(cx.sess.get_opts().optimize != 0u),\n-                       llfndecl\n+                       fcx.llfn\n                        //list of template params\n                        //func decl descriptor\n                        //list of func vars\n                       ];\n     let val = llmdnode(fn_metadata);\n     add_named_metadata(cx, \"llvm.dbg.sp\", val);\n-    let mdval = @{node: val, data: {name: item.ident,\n-                                    file: loc.filename}};\n+    let mdval = @{node: val, data: {path: path}};\n     update_cache(cache, SubprogramTag, subprogram_metadata(mdval));\n     ret mdval;\n }"}, {"sha": "7828390ee4fb6fea29b9c284459382070993f255", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 9, "deletions": 33, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/df6052c4f88fbc9118411967d236576ae45d7dc5/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df6052c4f88fbc9118411967d236576ae45d7dc5/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=df6052c4f88fbc9118411967d236576ae45d7dc5", "patch": "@@ -3519,7 +3519,7 @@ fn trans_temp_expr(bcx: @block_ctxt, e: @ast::expr) -> result {\n // - exprs with non-immediate type never get dest=by_val\n fn trans_expr(bcx: @block_ctxt, e: @ast::expr, dest: dest) -> @block_ctxt {\n     let tcx = bcx_tcx(bcx);\n-    let _s = debuginfo::update_source_pos(bcx, e.span);\n+    debuginfo::update_source_pos(bcx, e.span);\n \n     if expr_is_lval(bcx, e) {\n         ret lval_to_dps(bcx, e, dest);\n@@ -4014,7 +4014,7 @@ fn trans_stmt(cx: @block_ctxt, s: ast::stmt) -> @block_ctxt {\n     }\n \n     let bcx = cx;\n-    let _s = debuginfo::update_source_pos(cx, s.span);\n+    debuginfo::update_source_pos(cx, s.span);\n     \n     alt s.node {\n       ast::stmt_expr(e, _) { bcx = trans_expr(cx, e, ignore); }\n@@ -4041,19 +4041,6 @@ fn trans_stmt(cx: @block_ctxt, s: ast::stmt) -> @block_ctxt {\n     ret bcx;\n }\n \n-fn source_pos_from_block_parent(parent: block_parent)\n-    -> (bool, [codemap::loc]) {\n-    alt parent {\n-      parent_none. { (false, []) }\n-      parent_some(bcx) { (bcx.source_pos.usable,\n-                          alt vec::last(bcx.source_pos.pos) {\n-                            option::some(p) { [p] }\n-                            option::none. { [] }\n-                          })\n-                       }\n-    }\n-}\n-\n // You probably don't want to use this one. See the\n // next three functions instead.\n fn new_block_ctxt(cx: @fn_ctxt, parent: block_parent, kind: block_kind,\n@@ -4065,7 +4052,6 @@ fn new_block_ctxt(cx: @fn_ctxt, parent: block_parent, kind: block_kind,\n     }\n     let llbb: BasicBlockRef =\n         str::as_buf(s, {|buf| llvm::LLVMAppendBasicBlock(cx.llfn, buf) });\n-    let (usable, pos) = source_pos_from_block_parent(parent);\n     let bcx = @{llbb: llbb,\n                 mutable terminated: false,\n                 mutable unreachable: false,\n@@ -4075,8 +4061,7 @@ fn new_block_ctxt(cx: @fn_ctxt, parent: block_parent, kind: block_kind,\n                 mutable lpad_dirty: true,\n                 mutable lpad: option::none,\n                 sp: cx.sp,\n-                fcx: cx,\n-                source_pos: {mutable usable: usable, mutable pos: pos}};\n+                fcx: cx};\n     alt parent {\n       parent_some(cx) {\n         if cx.unreachable { Unreachable(bcx); }\n@@ -4111,7 +4096,6 @@ fn new_sub_block_ctxt(bcx: @block_ctxt, n: str) -> @block_ctxt {\n }\n \n fn new_raw_block_ctxt(fcx: @fn_ctxt, llbb: BasicBlockRef) -> @block_ctxt {\n-    let (usable, pos) = source_pos_from_block_parent(parent_none);\n     ret @{llbb: llbb,\n           mutable terminated: false,\n           mutable unreachable: false,\n@@ -4121,8 +4105,7 @@ fn new_raw_block_ctxt(fcx: @fn_ctxt, llbb: BasicBlockRef) -> @block_ctxt {\n           mutable lpad_dirty: true,\n           mutable lpad: option::none,\n           sp: fcx.sp,\n-          fcx: fcx,\n-          source_pos: {mutable usable: usable, mutable pos: pos}};\n+          fcx: fcx};\n }\n \n \n@@ -4180,7 +4163,6 @@ fn block_locals(b: ast::blk, it: block(@ast::local)) {\n }\n \n fn llstaticallocas_block_ctxt(fcx: @fn_ctxt) -> @block_ctxt {\n-    let (usable, pos) = source_pos_from_block_parent(parent_none);\n     ret @{llbb: fcx.llstaticallocas,\n           mutable terminated: false,\n           mutable unreachable: false,\n@@ -4190,12 +4172,10 @@ fn llstaticallocas_block_ctxt(fcx: @fn_ctxt) -> @block_ctxt {\n           mutable lpad_dirty: true,\n           mutable lpad: option::none,\n           sp: fcx.sp,\n-          fcx: fcx,\n-          source_pos: {mutable usable: usable, mutable pos: pos}};\n+          fcx: fcx};\n }\n \n fn llderivedtydescs_block_ctxt(fcx: @fn_ctxt) -> @block_ctxt {\n-    let (usable, pos) = source_pos_from_block_parent(parent_none);\n     ret @{llbb: fcx.llderivedtydescs,\n           mutable terminated: false,\n           mutable unreachable: false,\n@@ -4205,8 +4185,7 @@ fn llderivedtydescs_block_ctxt(fcx: @fn_ctxt) -> @block_ctxt {\n           mutable lpad_dirty: true,\n           mutable lpad: option::none,\n           sp: fcx.sp,\n-          fcx: fcx,\n-          source_pos: {mutable usable: usable, mutable pos: pos}};\n+          fcx: fcx};\n }\n \n \n@@ -4281,13 +4260,13 @@ fn trans_block_dps(bcx: @block_ctxt, b: ast::blk, dest: dest)\n     let bcx = bcx;\n     block_locals(b) {|local| bcx = alloc_local(bcx, local); };\n     for s: @ast::stmt in b.node.stmts {\n-        let _s = debuginfo::update_source_pos(bcx, b.span);\n+        debuginfo::update_source_pos(bcx, b.span);\n         bcx = trans_stmt(bcx, *s);\n     }\n     alt b.node.expr {\n       some(e) {\n         let bt = ty::type_is_bot(bcx_tcx(bcx), ty::expr_ty(bcx_tcx(bcx), e));\n-        let _s = debuginfo::update_source_pos(bcx, e.span);\n+        debuginfo::update_source_pos(bcx, e.span);\n         bcx = trans_expr(bcx, e, bt ? ignore : dest);\n       }\n       _ { assert dest == ignore || bcx.unreachable; }\n@@ -4585,10 +4564,7 @@ fn trans_fn(cx: @local_ctxt, sp: span, f: ast::_fn, llfndecl: ValueRef,\n     let fcx = option::none;\n     trans_closure(cx, sp, f, llfndecl, ty_self, ty_params, id, {|new_fcx| fcx = option::some(new_fcx);});\n     if cx.ccx.sess.get_opts().extra_debuginfo {\n-        let item = alt option::get(cx.ccx.ast_map.find(id)) {\n-            ast_map::node_item(item) { item }\n-        };\n-        debuginfo::create_function(option::get(fcx), item, llfndecl);\n+        debuginfo::create_function(option::get(fcx));\n     }\n     if do_time {\n         let end = time::get_time();"}, {"sha": "af709ec5420e06f8816f2637536f9b50da16815d", "filename": "src/comp/middle/trans_build.rs", "status": "modified", "additions": 94, "deletions": 263, "changes": 357, "blob_url": "https://github.com/rust-lang/rust/blob/df6052c4f88fbc9118411967d236576ae45d7dc5/src%2Fcomp%2Fmiddle%2Ftrans_build.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df6052c4f88fbc9118411967d236576ae45d7dc5/src%2Fcomp%2Fmiddle%2Ftrans_build.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_build.rs?ref=df6052c4f88fbc9118411967d236576ae45d7dc5", "patch": "@@ -25,54 +25,47 @@ fn RetVoid(cx: @block_ctxt) {\n     if cx.unreachable { ret; }\n     assert (!cx.terminated);\n     cx.terminated = true;\n-    let instr = llvm::LLVMBuildRetVoid(B(cx));\n-    debuginfo::add_line_info(cx, instr);\n+    llvm::LLVMBuildRetVoid(B(cx));\n }\n \n fn Ret(cx: @block_ctxt, V: ValueRef) {\n     if cx.unreachable { ret; }\n     assert (!cx.terminated);\n     cx.terminated = true;\n-    let instr = llvm::LLVMBuildRet(B(cx), V);\n-    debuginfo::add_line_info(cx, instr);\n+    llvm::LLVMBuildRet(B(cx), V);\n }\n \n fn AggregateRet(cx: @block_ctxt, RetVals: [ValueRef]) {\n     if cx.unreachable { ret; }\n     assert (!cx.terminated);\n     cx.terminated = true;\n     unsafe {\n-        let instr = llvm::LLVMBuildAggregateRet(B(cx), vec::to_ptr(RetVals),\n-                                                vec::len(RetVals));\n-        debuginfo::add_line_info(cx, instr);\n+        llvm::LLVMBuildAggregateRet(B(cx), vec::to_ptr(RetVals),\n+                                    vec::len(RetVals));\n     }\n }\n \n fn Br(cx: @block_ctxt, Dest: BasicBlockRef) {\n     if cx.unreachable { ret; }\n     assert (!cx.terminated);\n     cx.terminated = true;\n-    let instr = llvm::LLVMBuildBr(B(cx), Dest);\n-    debuginfo::add_line_info(cx, instr);\n+    llvm::LLVMBuildBr(B(cx), Dest);\n }\n \n fn CondBr(cx: @block_ctxt, If: ValueRef, Then: BasicBlockRef,\n           Else: BasicBlockRef) {\n     if cx.unreachable { ret; }\n     assert (!cx.terminated);\n     cx.terminated = true;\n-    let instr = llvm::LLVMBuildCondBr(B(cx), If, Then, Else);\n-    debuginfo::add_line_info(cx, instr);\n+    llvm::LLVMBuildCondBr(B(cx), If, Then, Else);\n }\n \n fn Switch(cx: @block_ctxt, V: ValueRef, Else: BasicBlockRef, NumCases: uint)\n     -> ValueRef {\n     if cx.unreachable { ret _Undef(V); }\n     assert !cx.terminated;\n     cx.terminated = true;\n-    let instr = llvm::LLVMBuildSwitch(B(cx), V, Else, NumCases);\n-    debuginfo::add_line_info(cx, instr);\n-    ret instr;\n+    ret llvm::LLVMBuildSwitch(B(cx), V, Else, NumCases);\n }\n \n fn AddCase(S: ValueRef, OnVal: ValueRef, Dest: BasicBlockRef) {\n@@ -84,8 +77,7 @@ fn IndirectBr(cx: @block_ctxt, Addr: ValueRef, NumDests: uint) {\n     if cx.unreachable { ret; }\n     assert (!cx.terminated);\n     cx.terminated = true;\n-    let instr = llvm::LLVMBuildIndirectBr(B(cx), Addr, NumDests);\n-    debuginfo::add_line_info(cx, instr);\n+    llvm::LLVMBuildIndirectBr(B(cx), Addr, NumDests);\n }\n \n // This is a really awful way to get a zero-length c-string, but better (and a\n@@ -105,14 +97,10 @@ fn Invoke(cx: @block_ctxt, Fn: ValueRef, Args: [ValueRef],\n                                           vec::len(Args), Then, Catch,\n                                           noname());\n         if bcx_ccx(cx).sess.get_opts().debuginfo {\n-            /*llvm::LLVMAddAttribute(option::get(vec::last(llargs)),\n-            lib::llvm::LLVMStructRetAttribute as\n-            lib::llvm::llvm::Attribute);*/\n             llvm::LLVMAddInstrAttribute(instr, 1u,\n                                         lib::llvm::LLVMStructRetAttribute as\n                                             lib::llvm::llvm::Attribute);\n         }\n-        debuginfo::add_line_info(cx, instr);\n     }\n }\n \n@@ -125,7 +113,6 @@ fn FastInvoke(cx: @block_ctxt, Fn: ValueRef, Args: [ValueRef],\n         let v = llvm::LLVMBuildInvoke(B(cx), Fn, vec::to_ptr(Args),\n                                       vec::len(Args), Then, Catch, noname());\n         llvm::LLVMSetInstructionCallConv(v, lib::llvm::LLVMFastCallConv);\n-        debuginfo::add_line_info(cx, v);\n     }\n }\n \n@@ -142,254 +129,183 @@ fn _Undef(val: ValueRef) -> ValueRef {\n /* Arithmetic */\n fn Add(cx: @block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { ret _Undef(LHS); }\n-    let instr = llvm::LLVMBuildAdd(B(cx), LHS, RHS, noname());\n-    debuginfo::add_line_info(cx, instr);\n-    ret instr;\n+    ret llvm::LLVMBuildAdd(B(cx), LHS, RHS, noname());\n }\n \n fn NSWAdd(cx: @block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { ret _Undef(LHS); }\n-    let instr = llvm::LLVMBuildNSWAdd(B(cx), LHS, RHS, noname());\n-    debuginfo::add_line_info(cx, instr);\n-    ret instr;\n+    ret llvm::LLVMBuildNSWAdd(B(cx), LHS, RHS, noname());\n }\n \n fn NUWAdd(cx: @block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { ret _Undef(LHS); }\n-    let instr = llvm::LLVMBuildNUWAdd(B(cx), LHS, RHS, noname());\n-    debuginfo::add_line_info(cx, instr);\n-    ret instr;\n+    ret llvm::LLVMBuildNUWAdd(B(cx), LHS, RHS, noname());\n }\n \n fn FAdd(cx: @block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { ret _Undef(LHS); }\n-    let instr = llvm::LLVMBuildFAdd(B(cx), LHS, RHS, noname());\n-    debuginfo::add_line_info(cx, instr);\n-    ret instr;\n+    ret llvm::LLVMBuildFAdd(B(cx), LHS, RHS, noname());\n }\n \n fn Sub(cx: @block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { ret _Undef(LHS); }\n-    let instr = llvm::LLVMBuildSub(B(cx), LHS, RHS, noname());\n-    debuginfo::add_line_info(cx, instr);\n-    ret instr;\n+    ret llvm::LLVMBuildSub(B(cx), LHS, RHS, noname());\n }\n \n fn NSWSub(cx: @block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { ret _Undef(LHS); }\n-    let instr = llvm::LLVMBuildNSWSub(B(cx), LHS, RHS, noname());\n-    debuginfo::add_line_info(cx, instr);\n-    ret instr;\n+    ret llvm::LLVMBuildNSWSub(B(cx), LHS, RHS, noname());\n }\n \n fn NUWSub(cx: @block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { ret _Undef(LHS); }\n-    let instr = llvm::LLVMBuildNUWSub(B(cx), LHS, RHS, noname());\n-    debuginfo::add_line_info(cx, instr);\n-    ret instr;\n+    ret llvm::LLVMBuildNUWSub(B(cx), LHS, RHS, noname());\n }\n \n fn FSub(cx: @block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { ret _Undef(LHS); }\n-    let instr = llvm::LLVMBuildFSub(B(cx), LHS, RHS, noname());\n-    debuginfo::add_line_info(cx, instr);\n-    ret instr;\n+    ret llvm::LLVMBuildFSub(B(cx), LHS, RHS, noname());\n }\n \n fn Mul(cx: @block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { ret _Undef(LHS); }\n-    let instr = llvm::LLVMBuildMul(B(cx), LHS, RHS, noname());\n-    debuginfo::add_line_info(cx, instr);\n-    ret instr;\n+    ret llvm::LLVMBuildMul(B(cx), LHS, RHS, noname());\n }\n \n fn NSWMul(cx: @block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { ret _Undef(LHS); }\n-    let instr = llvm::LLVMBuildNSWMul(B(cx), LHS, RHS, noname());\n-    debuginfo::add_line_info(cx, instr);\n-    ret instr;\n+    ret llvm::LLVMBuildNSWMul(B(cx), LHS, RHS, noname());\n }\n \n fn NUWMul(cx: @block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { ret _Undef(LHS); }\n-    let instr = llvm::LLVMBuildNUWMul(B(cx), LHS, RHS, noname());\n-    debuginfo::add_line_info(cx, instr);\n-    ret instr;\n+    ret llvm::LLVMBuildNUWMul(B(cx), LHS, RHS, noname());\n }\n \n fn FMul(cx: @block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { ret _Undef(LHS); }\n-    let instr = llvm::LLVMBuildFMul(B(cx), LHS, RHS, noname());\n-    debuginfo::add_line_info(cx, instr);\n-    ret instr;\n+    ret llvm::LLVMBuildFMul(B(cx), LHS, RHS, noname());\n }\n \n fn UDiv(cx: @block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { ret _Undef(LHS); }\n-    let instr = llvm::LLVMBuildUDiv(B(cx), LHS, RHS, noname());\n-    debuginfo::add_line_info(cx, instr);\n-    ret instr;\n+    ret llvm::LLVMBuildUDiv(B(cx), LHS, RHS, noname());\n }\n \n fn SDiv(cx: @block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { ret _Undef(LHS); }\n-    let instr = llvm::LLVMBuildSDiv(B(cx), LHS, RHS, noname());\n-    debuginfo::add_line_info(cx, instr);\n-    ret instr;\n+    ret llvm::LLVMBuildSDiv(B(cx), LHS, RHS, noname());\n }\n \n fn ExactSDiv(cx: @block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { ret _Undef(LHS); }\n-    let instr = llvm::LLVMBuildExactSDiv(B(cx), LHS, RHS, noname());\n-    debuginfo::add_line_info(cx, instr);\n-    ret instr;\n+    ret llvm::LLVMBuildExactSDiv(B(cx), LHS, RHS, noname());\n }\n \n fn FDiv(cx: @block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { ret _Undef(LHS); }\n-    let instr = llvm::LLVMBuildFDiv(B(cx), LHS, RHS, noname());\n-    debuginfo::add_line_info(cx, instr);\n-    ret instr;\n+    ret llvm::LLVMBuildFDiv(B(cx), LHS, RHS, noname());\n }\n \n fn URem(cx: @block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { ret _Undef(LHS); }\n-    let instr = llvm::LLVMBuildURem(B(cx), LHS, RHS, noname());\n-    debuginfo::add_line_info(cx, instr);\n-    ret instr;\n+    ret llvm::LLVMBuildURem(B(cx), LHS, RHS, noname());\n }\n \n fn SRem(cx: @block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { ret _Undef(LHS); }\n-    let instr = llvm::LLVMBuildSRem(B(cx), LHS, RHS, noname());\n-    debuginfo::add_line_info(cx, instr);\n-    ret instr;\n+    ret llvm::LLVMBuildSRem(B(cx), LHS, RHS, noname());\n }\n \n fn FRem(cx: @block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { ret _Undef(LHS); }\n-    let instr = llvm::LLVMBuildFRem(B(cx), LHS, RHS, noname());\n-    debuginfo::add_line_info(cx, instr);\n-    ret instr;\n+    ret llvm::LLVMBuildFRem(B(cx), LHS, RHS, noname());\n }\n \n fn Shl(cx: @block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { ret _Undef(LHS); }\n-    let instr = llvm::LLVMBuildShl(B(cx), LHS, RHS, noname());\n-    debuginfo::add_line_info(cx, instr);\n-    ret instr;\n+    ret llvm::LLVMBuildShl(B(cx), LHS, RHS, noname());\n }\n \n fn LShr(cx: @block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { ret _Undef(LHS); }\n-    let instr = llvm::LLVMBuildLShr(B(cx), LHS, RHS, noname());\n-    debuginfo::add_line_info(cx, instr);\n-    ret instr;\n+    ret llvm::LLVMBuildLShr(B(cx), LHS, RHS, noname());\n }\n \n fn AShr(cx: @block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { ret _Undef(LHS); }\n-    let instr = llvm::LLVMBuildAShr(B(cx), LHS, RHS, noname());\n-    debuginfo::add_line_info(cx, instr);\n-    ret instr;\n+    ret llvm::LLVMBuildAShr(B(cx), LHS, RHS, noname());\n }\n \n fn And(cx: @block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { ret _Undef(LHS); }\n-    let instr = llvm::LLVMBuildAnd(B(cx), LHS, RHS, noname());\n-    debuginfo::add_line_info(cx, instr);\n-    ret instr;\n+    ret llvm::LLVMBuildAnd(B(cx), LHS, RHS, noname());\n }\n \n fn Or(cx: @block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { ret _Undef(LHS); }\n-    let instr = llvm::LLVMBuildOr(B(cx), LHS, RHS, noname());\n-    debuginfo::add_line_info(cx, instr);\n-    ret instr;\n+    ret llvm::LLVMBuildOr(B(cx), LHS, RHS, noname());\n }\n \n fn Xor(cx: @block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { ret _Undef(LHS); }\n-    let instr = llvm::LLVMBuildXor(B(cx), LHS, RHS, noname());\n-    debuginfo::add_line_info(cx, instr);\n-    ret instr;\n+    ret llvm::LLVMBuildXor(B(cx), LHS, RHS, noname());\n }\n \n fn BinOp(cx: @block_ctxt, Op: Opcode, LHS: ValueRef, RHS: ValueRef) ->\n    ValueRef {\n     if cx.unreachable { ret _Undef(LHS); }\n-    let instr = llvm::LLVMBuildBinOp(B(cx), Op, LHS, RHS, noname());\n-    debuginfo::add_line_info(cx, instr);\n-    ret instr;\n+    ret llvm::LLVMBuildBinOp(B(cx), Op, LHS, RHS, noname());\n }\n \n fn Neg(cx: @block_ctxt, V: ValueRef) -> ValueRef {\n     if cx.unreachable { ret _Undef(V); }\n-    let instr = llvm::LLVMBuildNeg(B(cx), V, noname());\n-    debuginfo::add_line_info(cx, instr);\n-    ret instr;\n+    ret llvm::LLVMBuildNeg(B(cx), V, noname());\n }\n \n fn NSWNeg(cx: @block_ctxt, V: ValueRef) -> ValueRef {\n     if cx.unreachable { ret _Undef(V); }\n-    let instr = llvm::LLVMBuildNSWNeg(B(cx), V, noname());\n-    debuginfo::add_line_info(cx, instr);\n-    ret instr;\n+    ret llvm::LLVMBuildNSWNeg(B(cx), V, noname());\n }\n \n fn NUWNeg(cx: @block_ctxt, V: ValueRef) -> ValueRef {\n     if cx.unreachable { ret _Undef(V); }\n-    let instr = llvm::LLVMBuildNUWNeg(B(cx), V, noname());\n-    debuginfo::add_line_info(cx, instr);\n-    ret instr;\n+    ret llvm::LLVMBuildNUWNeg(B(cx), V, noname());\n }\n fn FNeg(cx: @block_ctxt, V: ValueRef) -> ValueRef {\n     if cx.unreachable { ret _Undef(V); }\n-    let instr = llvm::LLVMBuildFNeg(B(cx), V, noname());\n-    debuginfo::add_line_info(cx, instr);\n-    ret instr;\n+    ret llvm::LLVMBuildFNeg(B(cx), V, noname());\n }\n \n fn Not(cx: @block_ctxt, V: ValueRef) -> ValueRef {\n     if cx.unreachable { ret _Undef(V); }\n-    let instr = llvm::LLVMBuildNot(B(cx), V, noname());\n-    debuginfo::add_line_info(cx, instr);\n-    ret instr;\n+    ret llvm::LLVMBuildNot(B(cx), V, noname());\n }\n \n /* Memory */\n fn Malloc(cx: @block_ctxt, Ty: TypeRef) -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(T_ptr(T_i8())); }\n-    let instr = llvm::LLVMBuildMalloc(B(cx), Ty, noname());\n-    debuginfo::add_line_info(cx, instr);\n-    ret instr;\n+    ret llvm::LLVMBuildMalloc(B(cx), Ty, noname());\n }\n \n fn ArrayMalloc(cx: @block_ctxt, Ty: TypeRef, Val: ValueRef) -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(T_ptr(T_i8())); }\n-    let instr = llvm::LLVMBuildArrayMalloc(B(cx), Ty, Val, noname());\n-    debuginfo::add_line_info(cx, instr);\n-    ret instr;\n+    ret llvm::LLVMBuildArrayMalloc(B(cx), Ty, Val, noname());\n }\n \n fn Alloca(cx: @block_ctxt, Ty: TypeRef) -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(T_ptr(Ty)); }\n-    let instr = llvm::LLVMBuildAlloca(B(cx), Ty, noname());\n-    debuginfo::add_line_info(cx, instr);\n-    ret instr;\n+    ret llvm::LLVMBuildAlloca(B(cx), Ty, noname());\n }\n \n fn ArrayAlloca(cx: @block_ctxt, Ty: TypeRef, Val: ValueRef) -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(T_ptr(Ty)); }\n-    let instr = llvm::LLVMBuildArrayAlloca(B(cx), Ty, Val, noname());\n-    debuginfo::add_line_info(cx, instr);\n-    ret instr;\n+    ret llvm::LLVMBuildArrayAlloca(B(cx), Ty, Val, noname());\n }\n \n fn Free(cx: @block_ctxt, PointerVal: ValueRef) {\n     if cx.unreachable { ret; }\n-    let instr = llvm::LLVMBuildFree(B(cx), PointerVal);\n-    debuginfo::add_line_info(cx, instr);\n+    llvm::LLVMBuildFree(B(cx), PointerVal);\n }\n \n fn Load(cx: @block_ctxt, PointerVal: ValueRef) -> ValueRef {\n@@ -400,24 +316,19 @@ fn Load(cx: @block_ctxt, PointerVal: ValueRef) -> ValueRef {\n             llvm::LLVMGetElementType(ty) } else { ccx.int_type };\n         ret llvm::LLVMGetUndef(eltty);\n     }\n-    let instr = llvm::LLVMBuildLoad(B(cx), PointerVal, noname());\n-    debuginfo::add_line_info(cx, instr);\n-    ret instr;\n+    ret llvm::LLVMBuildLoad(B(cx), PointerVal, noname());\n }\n \n fn Store(cx: @block_ctxt, Val: ValueRef, Ptr: ValueRef) {\n     if cx.unreachable { ret; }\n-    let instr = llvm::LLVMBuildStore(B(cx), Val, Ptr);\n-    debuginfo::add_line_info(cx, instr);\n+    llvm::LLVMBuildStore(B(cx), Val, Ptr);\n }\n \n fn GEP(cx: @block_ctxt, Pointer: ValueRef, Indices: [ValueRef]) -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(T_ptr(T_nil())); }\n     unsafe {\n-        let instr = llvm::LLVMBuildGEP(B(cx), Pointer, vec::to_ptr(Indices),\n-                                       vec::len(Indices), noname());\n-        //debuginfo::add_line_info(cx, instr);\n-        ret instr;\n+        ret llvm::LLVMBuildGEP(B(cx), Pointer, vec::to_ptr(Indices),\n+                               vec::len(Indices), noname());\n     }\n }\n \n@@ -433,195 +344,143 @@ fn InBoundsGEP(cx: @block_ctxt, Pointer: ValueRef, Indices: [ValueRef]) ->\n    ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(T_ptr(T_nil())); }\n     unsafe {\n-        let instr = llvm::LLVMBuildInBoundsGEP(B(cx), Pointer,\n-                                               vec::to_ptr(Indices),\n-                                               vec::len(Indices), noname());\n-        //debuginfo::add_line_info(cx, instr);\n-        ret instr;\n+        ret llvm::LLVMBuildInBoundsGEP(B(cx), Pointer,\n+                                       vec::to_ptr(Indices),\n+                                       vec::len(Indices), noname());\n     }\n }\n \n fn StructGEP(cx: @block_ctxt, Pointer: ValueRef, Idx: uint) -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(T_ptr(T_nil())); }\n-    let instr = llvm::LLVMBuildStructGEP(B(cx), Pointer, Idx, noname());\n-    //debuginfo::add_line_info(cx, instr);\n-    ret instr;\n+    ret llvm::LLVMBuildStructGEP(B(cx), Pointer, Idx, noname());\n }\n \n fn GlobalString(cx: @block_ctxt, _Str: sbuf) -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(T_ptr(T_i8())); }\n-    let instr = llvm::LLVMBuildGlobalString(B(cx), _Str, noname());\n-    debuginfo::add_line_info(cx, instr);\n-    ret instr;\n+    ret llvm::LLVMBuildGlobalString(B(cx), _Str, noname());\n }\n \n fn GlobalStringPtr(cx: @block_ctxt, _Str: sbuf) -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(T_ptr(T_i8())); }\n-    let instr = llvm::LLVMBuildGlobalStringPtr(B(cx), _Str, noname());\n-    debuginfo::add_line_info(cx, instr);\n-    ret instr;\n+    ret llvm::LLVMBuildGlobalStringPtr(B(cx), _Str, noname());\n }\n \n /* Casts */\n fn Trunc(cx: @block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(DestTy); }\n-    let instr = llvm::LLVMBuildTrunc(B(cx), Val, DestTy, noname());\n-    //debuginfo::add_line_info(cx, instr);\n-    ret instr;\n+    ret llvm::LLVMBuildTrunc(B(cx), Val, DestTy, noname());\n }\n \n fn ZExt(cx: @block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(DestTy); }\n-    let instr = llvm::LLVMBuildZExt(B(cx), Val, DestTy, noname());\n-    //debuginfo::add_line_info(cx, instr);\n-    ret instr;\n+    ret llvm::LLVMBuildZExt(B(cx), Val, DestTy, noname());\n }\n \n fn SExt(cx: @block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(DestTy); }\n-    let instr = llvm::LLVMBuildSExt(B(cx), Val, DestTy, noname());\n-    //debuginfo::add_line_info(cx, instr);\n-    ret instr;\n+    ret llvm::LLVMBuildSExt(B(cx), Val, DestTy, noname());\n }\n \n fn FPToUI(cx: @block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(DestTy); }\n-    let instr = llvm::LLVMBuildFPToUI(B(cx), Val, DestTy, noname());\n-    //debuginfo::add_line_info(cx, instr);\n-    ret instr;\n+    ret llvm::LLVMBuildFPToUI(B(cx), Val, DestTy, noname());\n }\n \n fn FPToSI(cx: @block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(DestTy); }\n-    let instr = llvm::LLVMBuildFPToSI(B(cx), Val, DestTy, noname());\n-    //debuginfo::add_line_info(cx, instr);\n-    ret instr;\n+    ret llvm::LLVMBuildFPToSI(B(cx), Val, DestTy, noname());\n }\n \n fn UIToFP(cx: @block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(DestTy); }\n-    let instr = llvm::LLVMBuildUIToFP(B(cx), Val, DestTy, noname());\n-    //debuginfo::add_line_info(cx, instr);\n-    ret instr;\n+    ret llvm::LLVMBuildUIToFP(B(cx), Val, DestTy, noname());\n }\n \n fn SIToFP(cx: @block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(DestTy); }\n-    let instr = llvm::LLVMBuildSIToFP(B(cx), Val, DestTy, noname());\n-    //debuginfo::add_line_info(cx, instr);\n-    ret instr;\n+    ret llvm::LLVMBuildSIToFP(B(cx), Val, DestTy, noname());\n }\n \n fn FPTrunc(cx: @block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(DestTy); }\n-    let instr = llvm::LLVMBuildFPTrunc(B(cx), Val, DestTy, noname());\n-    //debuginfo::add_line_info(cx, instr);\n-    ret instr;\n+    ret llvm::LLVMBuildFPTrunc(B(cx), Val, DestTy, noname());\n }\n \n fn FPExt(cx: @block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(DestTy); }\n-    let instr = llvm::LLVMBuildFPExt(B(cx), Val, DestTy, noname());\n-    //debuginfo::add_line_info(cx, instr);\n-    ret instr;\n+    ret llvm::LLVMBuildFPExt(B(cx), Val, DestTy, noname());\n }\n \n fn PtrToInt(cx: @block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(DestTy); }\n-    let instr = llvm::LLVMBuildPtrToInt(B(cx), Val, DestTy, noname());\n-    //debuginfo::add_line_info(cx, instr);\n-    ret instr;\n+    ret llvm::LLVMBuildPtrToInt(B(cx), Val, DestTy, noname());\n }\n \n fn IntToPtr(cx: @block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(DestTy); }\n-    let instr = llvm::LLVMBuildIntToPtr(B(cx), Val, DestTy, noname());\n-    //debuginfo::add_line_info(cx, instr);\n-    ret instr;\n+    ret llvm::LLVMBuildIntToPtr(B(cx), Val, DestTy, noname());\n }\n \n fn BitCast(cx: @block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(DestTy); }\n-    let instr = llvm::LLVMBuildBitCast(B(cx), Val, DestTy, noname());\n-    //debuginfo::add_line_info(cx, instr);\n-    ret instr;\n+    ret llvm::LLVMBuildBitCast(B(cx), Val, DestTy, noname());\n }\n \n fn ZExtOrBitCast(cx: @block_ctxt, Val: ValueRef, DestTy: TypeRef) ->\n    ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(DestTy); }\n-    let instr = llvm::LLVMBuildZExtOrBitCast(B(cx), Val, DestTy, noname());\n-    //debuginfo::add_line_info(cx, instr);\n-    ret instr;\n+    ret llvm::LLVMBuildZExtOrBitCast(B(cx), Val, DestTy, noname());\n }\n \n fn SExtOrBitCast(cx: @block_ctxt, Val: ValueRef, DestTy: TypeRef) ->\n    ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(DestTy); }\n-    let instr = llvm::LLVMBuildSExtOrBitCast(B(cx), Val, DestTy, noname());\n-    //debuginfo::add_line_info(cx, instr);\n-    ret instr;\n+    ret llvm::LLVMBuildSExtOrBitCast(B(cx), Val, DestTy, noname());\n }\n \n fn TruncOrBitCast(cx: @block_ctxt, Val: ValueRef, DestTy: TypeRef) ->\n    ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(DestTy); }\n-    let instr = llvm::LLVMBuildTruncOrBitCast(B(cx), Val, DestTy, noname());\n-    //debuginfo::add_line_info(cx, instr);\n-    ret instr;\n+    ret llvm::LLVMBuildTruncOrBitCast(B(cx), Val, DestTy, noname());\n }\n \n fn Cast(cx: @block_ctxt, Op: Opcode, Val: ValueRef, DestTy: TypeRef,\n         _Name: sbuf) -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(DestTy); }\n-    let instr = llvm::LLVMBuildCast(B(cx), Op, Val, DestTy, noname());\n-    //debuginfo::add_line_info(cx, instr);\n-    ret instr;\n+    ret llvm::LLVMBuildCast(B(cx), Op, Val, DestTy, noname());\n }\n \n fn PointerCast(cx: @block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(DestTy); }\n-    let instr = llvm::LLVMBuildPointerCast(B(cx), Val, DestTy, noname());\n-    //debuginfo::add_line_info(cx, instr);\n-    ret instr;\n+    ret llvm::LLVMBuildPointerCast(B(cx), Val, DestTy, noname());\n }\n \n fn IntCast(cx: @block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(DestTy); }\n-    let instr = llvm::LLVMBuildIntCast(B(cx), Val, DestTy, noname());\n-    //debuginfo::add_line_info(cx, instr);\n-    ret instr;\n+    ret llvm::LLVMBuildIntCast(B(cx), Val, DestTy, noname());\n }\n \n fn FPCast(cx: @block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(DestTy); }\n-    let instr = llvm::LLVMBuildFPCast(B(cx), Val, DestTy, noname());\n-    //debuginfo::add_line_info(cx, instr);\n-    ret instr;\n+    ret llvm::LLVMBuildFPCast(B(cx), Val, DestTy, noname());\n }\n \n \n /* Comparisons */\n fn ICmp(cx: @block_ctxt, Op: uint, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(T_i1()); }\n-    let instr = llvm::LLVMBuildICmp(B(cx), Op, LHS, RHS, noname());\n-    debuginfo::add_line_info(cx, instr);\n-    ret instr;\n+    ret llvm::LLVMBuildICmp(B(cx), Op, LHS, RHS, noname());\n }\n \n fn FCmp(cx: @block_ctxt, Op: uint, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(T_i1()); }\n-    let instr = llvm::LLVMBuildFCmp(B(cx), Op, LHS, RHS, noname());\n-    debuginfo::add_line_info(cx, instr);\n-    ret instr;\n+    ret llvm::LLVMBuildFCmp(B(cx), Op, LHS, RHS, noname());\n }\n \n /* Miscellaneous instructions */\n fn EmptyPhi(cx: @block_ctxt, Ty: TypeRef) -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(Ty); }\n-    let instr = llvm::LLVMBuildPhi(B(cx), Ty, noname());\n-    debuginfo::add_line_info(cx, instr);\n-    ret instr;\n+    ret llvm::LLVMBuildPhi(B(cx), Ty, noname());\n }\n \n fn Phi(cx: @block_ctxt, Ty: TypeRef, vals: [ValueRef], bbs: [BasicBlockRef])\n@@ -656,7 +515,9 @@ fn _UndefReturn(cx: @block_ctxt, Fn: ValueRef) -> ValueRef {\n fn add_span_comment(bcx: @block_ctxt, sp: span, text: str) {\n     let ccx = bcx_ccx(bcx);\n     if (!ccx.sess.get_opts().no_asm_comments) {\n-        add_comment(bcx, text + \" (\" + ccx.sess.span_str(sp) + \")\");\n+        let s = text + \" (\" + ccx.sess.span_str(sp) + \")\";\n+        log s;\n+        add_comment(bcx, s);\n     }\n }\n \n@@ -676,10 +537,8 @@ fn add_comment(bcx: @block_ctxt, text: str) {\n fn Call(cx: @block_ctxt, Fn: ValueRef, Args: [ValueRef]) -> ValueRef {\n     if cx.unreachable { ret _UndefReturn(cx, Fn); }\n     unsafe {\n-        let instr = llvm::LLVMBuildCall(B(cx), Fn, vec::to_ptr(Args),\n-                                        vec::len(Args), noname());\n-        debuginfo::add_line_info(cx, instr);\n-        ret instr;\n+        ret llvm::LLVMBuildCall(B(cx), Fn, vec::to_ptr(Args),\n+                                vec::len(Args), noname());\n     }\n }\n \n@@ -689,7 +548,6 @@ fn FastCall(cx: @block_ctxt, Fn: ValueRef, Args: [ValueRef]) -> ValueRef {\n         let v = llvm::LLVMBuildCall(B(cx), Fn, vec::to_ptr(Args),\n                                     vec::len(Args), noname());\n         llvm::LLVMSetInstructionCallConv(v, lib::llvm::LLVMFastCallConv);\n-        debuginfo::add_line_info(cx, v);\n         ret v;\n     }\n }\n@@ -701,84 +559,64 @@ fn CallWithConv(cx: @block_ctxt, Fn: ValueRef, Args: [ValueRef], Conv: uint)\n         let v = llvm::LLVMBuildCall(B(cx), Fn, vec::to_ptr(Args),\n                                     vec::len(Args), noname());\n         llvm::LLVMSetInstructionCallConv(v, Conv);\n-        debuginfo::add_line_info(cx, v);\n         ret v;\n     }\n }\n \n fn Select(cx: @block_ctxt, If: ValueRef, Then: ValueRef, Else: ValueRef) ->\n    ValueRef {\n     if cx.unreachable { ret _Undef(Then); }\n-    let instr = llvm::LLVMBuildSelect(B(cx), If, Then, Else, noname());\n-    debuginfo::add_line_info(cx, instr);\n-    ret instr;\n+    ret llvm::LLVMBuildSelect(B(cx), If, Then, Else, noname());\n }\n \n fn VAArg(cx: @block_ctxt, list: ValueRef, Ty: TypeRef) -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(Ty); }\n-    let instr = llvm::LLVMBuildVAArg(B(cx), list, Ty, noname());\n-    debuginfo::add_line_info(cx, instr);\n-    ret instr;\n+    ret llvm::LLVMBuildVAArg(B(cx), list, Ty, noname());\n }\n \n fn ExtractElement(cx: @block_ctxt, VecVal: ValueRef, Index: ValueRef) ->\n    ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(T_nil()); }\n-    let instr = llvm::LLVMBuildExtractElement(B(cx), VecVal, Index, noname());\n-    debuginfo::add_line_info(cx, instr);\n-    ret instr;\n+    ret llvm::LLVMBuildExtractElement(B(cx), VecVal, Index, noname());\n }\n \n fn InsertElement(cx: @block_ctxt, VecVal: ValueRef, EltVal: ValueRef,\n                  Index: ValueRef) {\n     if cx.unreachable { ret; }\n-    let instr = llvm::LLVMBuildInsertElement(B(cx), VecVal, EltVal, Index,\n-                                             noname());\n-    debuginfo::add_line_info(cx, instr);\n+    llvm::LLVMBuildInsertElement(B(cx), VecVal, EltVal, Index, noname());\n }\n \n fn ShuffleVector(cx: @block_ctxt, V1: ValueRef, V2: ValueRef,\n                  Mask: ValueRef) {\n     if cx.unreachable { ret; }\n-    let instr = llvm::LLVMBuildShuffleVector(B(cx), V1, V2, Mask, noname());\n-    debuginfo::add_line_info(cx, instr);\n+    llvm::LLVMBuildShuffleVector(B(cx), V1, V2, Mask, noname());\n }\n \n fn ExtractValue(cx: @block_ctxt, AggVal: ValueRef, Index: uint) -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(T_nil()); }\n-    let instr = llvm::LLVMBuildExtractValue(B(cx), AggVal, Index, noname());\n-    debuginfo::add_line_info(cx, instr);\n-    ret instr;\n+    ret llvm::LLVMBuildExtractValue(B(cx), AggVal, Index, noname());\n }\n \n fn InsertValue(cx: @block_ctxt, AggVal: ValueRef, EltVal: ValueRef,\n                Index: uint) {\n     if cx.unreachable { ret; }\n-    let instr = llvm::LLVMBuildInsertValue(B(cx), AggVal, EltVal, Index,\n-                                           noname());\n-    debuginfo::add_line_info(cx, instr);\n+    llvm::LLVMBuildInsertValue(B(cx), AggVal, EltVal, Index, noname());\n }\n \n fn IsNull(cx: @block_ctxt, Val: ValueRef) -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(T_i1()); }\n-    let instr = llvm::LLVMBuildIsNull(B(cx), Val, noname());\n-    debuginfo::add_line_info(cx, instr);\n-    ret instr;\n+    ret llvm::LLVMBuildIsNull(B(cx), Val, noname());\n }\n \n fn IsNotNull(cx: @block_ctxt, Val: ValueRef) -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(T_i1()); }\n-    let instr = llvm::LLVMBuildIsNotNull(B(cx), Val, noname());\n-    debuginfo::add_line_info(cx, instr);\n-    ret instr;\n+    ret llvm::LLVMBuildIsNotNull(B(cx), Val, noname());\n }\n \n fn PtrDiff(cx: @block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     let ccx = cx.fcx.lcx.ccx;\n     if cx.unreachable { ret llvm::LLVMGetUndef(ccx.int_type); }\n-    let instr = llvm::LLVMBuildPtrDiff(B(cx), LHS, RHS, noname());\n-    debuginfo::add_line_info(cx, instr);\n-    ret instr;\n+    ret llvm::LLVMBuildPtrDiff(B(cx), LHS, RHS, noname());\n }\n \n fn Trap(cx: @block_ctxt) {\n@@ -793,19 +631,14 @@ fn Trap(cx: @block_ctxt) {\n     assert (T as int != 0);\n     let Args: [ValueRef] = [];\n     unsafe {\n-        let instr = llvm::LLVMBuildCall(b, T, vec::to_ptr(Args),\n-                                        vec::len(Args), noname());\n-        debuginfo::add_line_info(cx, instr);\n+        llvm::LLVMBuildCall(b, T, vec::to_ptr(Args), vec::len(Args), noname());\n     }\n }\n \n fn LandingPad(cx: @block_ctxt, Ty: TypeRef, PersFn: ValueRef,\n               NumClauses: uint) -> ValueRef {\n     assert !cx.terminated && !cx.unreachable;\n-    let instr = llvm::LLVMBuildLandingPad(B(cx), Ty, PersFn, NumClauses,\n-                                          noname());\n-    debuginfo::add_line_info(cx, instr);\n-    ret instr;\n+    ret llvm::LLVMBuildLandingPad(B(cx), Ty, PersFn, NumClauses, noname());\n }\n \n fn SetCleanup(_cx: @block_ctxt, LandingPad: ValueRef) {\n@@ -815,9 +648,7 @@ fn SetCleanup(_cx: @block_ctxt, LandingPad: ValueRef) {\n fn Resume(cx: @block_ctxt, Exn: ValueRef) -> ValueRef {\n     assert (!cx.terminated);\n     cx.terminated = true;\n-    let instr = llvm::LLVMBuildResume(B(cx), Exn);\n-    debuginfo::add_line_info(cx, instr);\n-    ret instr;\n+    ret llvm::LLVMBuildResume(B(cx), Exn);\n }\n \n //"}, {"sha": "f30184124b050defd6d2d7ad44d234e25c4404cf", "filename": "src/comp/middle/trans_common.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/df6052c4f88fbc9118411967d236576ae45d7dc5/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df6052c4f88fbc9118411967d236576ae45d7dc5/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_common.rs?ref=df6052c4f88fbc9118411967d236576ae45d7dc5", "patch": "@@ -385,9 +385,7 @@ type block_ctxt =\n      mutable lpad_dirty: bool,\n      mutable lpad: option::t<BasicBlockRef>,\n      sp: span,\n-     fcx: @fn_ctxt,\n-     source_pos: {mutable usable: bool,\n-                  mutable pos: [syntax::codemap::loc]}};\n+     fcx: @fn_ctxt};\n \n // FIXME: we should be able to use option::t<@block_parent> here but\n // the infinite-tag check in rustboot gets upset."}, {"sha": "dba2b67410ec9a29e39a24c639ca08ef4820266b", "filename": "src/comp/middle/trans_vec.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/df6052c4f88fbc9118411967d236576ae45d7dc5/src%2Fcomp%2Fmiddle%2Ftrans_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df6052c4f88fbc9118411967d236576ae45d7dc5/src%2Fcomp%2Fmiddle%2Ftrans_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_vec.rs?ref=df6052c4f88fbc9118411967d236576ae45d7dc5", "patch": "@@ -27,7 +27,6 @@ fn pointer_add(bcx: @block_ctxt, ptr: ValueRef, bytes: ValueRef) -> ValueRef {\n }\n \n fn alloc_raw(bcx: @block_ctxt, fill: ValueRef, alloc: ValueRef) -> result {\n-    let _s = debuginfo::invalidate_source_pos(bcx);\n     let ccx = bcx_ccx(bcx);\n     let llvecty = ccx.opaque_vec_type;\n     let vecsize = Add(bcx, alloc, llsize_of(ccx, llvecty));\n@@ -46,7 +45,6 @@ type alloc_result =\n      llunitty: TypeRef};\n \n fn alloc(bcx: @block_ctxt, vec_ty: ty::t, elts: uint) -> alloc_result {\n-    let _s = debuginfo::invalidate_source_pos(bcx);\n     let ccx = bcx_ccx(bcx);\n     let unit_ty = ty::sequence_element_type(bcx_tcx(bcx), vec_ty);\n     let llunitty = type_of_or_i8(bcx, unit_ty);"}]}