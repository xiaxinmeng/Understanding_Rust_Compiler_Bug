{"sha": "65cdfa4a21f203379d83642329cf74ea6371adf4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY1Y2RmYTRhMjFmMjAzMzc5ZDgzNjQyMzI5Y2Y3NGVhNjM3MWFkZjQ=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-09-16T01:44:44Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-09-16T01:44:44Z"}, "message": "docs: Modernize tutorial snippets", "tree": {"sha": "97cfc8983f1bc3d66e65d6610a76d2b48ec473fd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/97cfc8983f1bc3d66e65d6610a76d2b48ec473fd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/65cdfa4a21f203379d83642329cf74ea6371adf4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/65cdfa4a21f203379d83642329cf74ea6371adf4", "html_url": "https://github.com/rust-lang/rust/commit/65cdfa4a21f203379d83642329cf74ea6371adf4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/65cdfa4a21f203379d83642329cf74ea6371adf4/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "da5033f99193cda3c95f5518d9591faae1ce5e6a", "url": "https://api.github.com/repos/rust-lang/rust/commits/da5033f99193cda3c95f5518d9591faae1ce5e6a", "html_url": "https://github.com/rust-lang/rust/commit/da5033f99193cda3c95f5518d9591faae1ce5e6a"}], "stats": {"total": 218, "additions": 110, "deletions": 108}, "files": [{"sha": "6541cb097ae1585955a7039dca1f2e9d1c12ab8b", "filename": "doc/tutorial.md", "status": "modified", "additions": 110, "deletions": 108, "changes": 218, "blob_url": "https://github.com/rust-lang/rust/blob/65cdfa4a21f203379d83642329cf74ea6371adf4/doc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/65cdfa4a21f203379d83642329cf74ea6371adf4/doc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial.md?ref=65cdfa4a21f203379d83642329cf74ea6371adf4", "patch": "@@ -815,33 +815,33 @@ Enum variants need not have type parameters. This, for example, is\n equivalent to a C enum:\n \n ~~~~\n-enum direction {\n-    north,\n-    east,\n-    south,\n-    west\n+enum Direction {\n+    North,\n+    East,\n+    South,\n+    West\n }\n ~~~~\n \n-This will define `north`, `east`, `south`, and `west` as constants,\n-all of which have type `direction`.\n+This will define `North`, `East`, `South`, and `West` as constants,\n+all of which have type `Direction`.\n \n When an enum is C-like, that is, when none of the variants have\n parameters, it is possible to explicitly set the discriminator values\n to an integer value:\n \n ~~~~\n-enum color {\n-  red = 0xff0000,\n-  green = 0x00ff00,\n-  blue = 0x0000ff\n+enum Color {\n+  Red = 0xff0000,\n+  Green = 0x00ff00,\n+  Blue = 0x0000ff\n }\n ~~~~\n \n If an explicit discriminator is not specified for a variant, the value\n defaults to the value of the previous variant plus one. If the first\n variant does not have a discriminator, it defaults to 0. For example,\n-the value of `north` is 0, `east` is 1, etc.\n+the value of `North` is 0, `East` is 1, etc.\n \n When an enum is C-like the `as` cast operator can be used to get the\n discriminator's value.\n@@ -853,21 +853,21 @@ used to define new types in such a way that the new name is not just a\n synonym for an existing type, but its own distinct type. If you say:\n \n ~~~~\n-enum gizmo_id = int;\n+enum GizmoId = int;\n ~~~~\n \n That is a shorthand for this:\n \n ~~~~\n-enum gizmo_id { gizmo_id(int) }\n+enum GizmoId { GizmoId(int) }\n ~~~~\n \n Enum types like this can have their content extracted with the\n dereference (`*`) unary operator:\n \n ~~~~\n-# enum gizmo_id = int;\n-let my_gizmo_id = gizmo_id(10);\n+# enum GizmoId = int;\n+let my_gizmo_id = GizmoId(10);\n let id_int: int = *my_gizmo_id;\n ~~~~\n \n@@ -878,27 +878,27 @@ get at their contents. All variant constructors can be used as\n patterns, as in this definition of `area`:\n \n ~~~~\n-# type point = {x: float, y: float};\n-# enum shape { circle(point, float), rectangle(point, point) }\n-fn area(sh: shape) -> float {\n+# type Point = {x: float, y: float};\n+# enum Shape { Circle(Point, float), Rectangle(Point, Point) }\n+fn area(sh: Shape) -> float {\n     match sh {\n-        circle(_, size) => float::consts::pi * size * size,\n-        rectangle({x, y}, {x: x2, y: y2}) => (x2 - x) * (y2 - y)\n+        Circle(_, size) => float::consts::pi * size * size,\n+        Rectangle({x, y}, {x: x2, y: y2}) => (x2 - x) * (y2 - y)\n     }\n }\n ~~~~\n \n Another example, matching nullary enum variants:\n \n ~~~~\n-# type point = {x: float, y: float};\n-# enum direction { north, east, south, west }\n-fn point_from_direction(dir: direction) -> point {\n+# type Point = {x: float, y: float};\n+# enum Direction { North, East, South, West }\n+fn point_from_direction(dir: Direction) -> Point {\n     match dir {\n-        north => {x:  0f, y:  1f},\n-        east  => {x:  1f, y:  0f},\n-        south => {x:  0f, y: -1f},\n-        west  => {x: -1f, y:  0f}\n+        North => {x:  0f, y:  1f},\n+        East  => {x:  1f, y:  0f},\n+        South => {x:  0f, y: -1f},\n+        West  => {x: -1f, y:  0f}\n     }\n }\n ~~~~\n@@ -1133,18 +1133,18 @@ values of the same type. Like other types in Rust, vectors can be\n stored on the stack, the local heap, or the exchange heap.\n \n ~~~\n-enum crayon {\n-    almond, antique_brass, apricot,\n-    aquamarine, asparagus, atomic_tangerine,\n-    banana_mania, beaver, bittersweet\n+enum Crayon {\n+    Almond, AntiqueBrass, Apricot,\n+    Aquamarine, Asparagus, AtomicTangerine,\n+    BananaMania, Beaver, Bittersweet\n }\n \n // A stack vector of crayons\n-let stack_crayons: &[crayon] = &[almond, antique_brass, apricot];\n+let stack_crayons: &[Crayon] = &[Almond, AntiqueBrass, Apricot];\n // A local heap (shared) vector of crayons\n-let local_crayons: @[crayon] = @[aquamarine, asparagus, atomic_tangerine];\n+let local_crayons: @[Crayon] = @[Aquamarine, Asparagus, AtomicTangerine];\n // An exchange heap (unique) vector of crayons\n-let exchange_crayons: ~[crayon] = ~[banana_mania, beaver, bittersweet];\n+let exchange_crayons: ~[Crayon] = ~[BananaMania, Beaver, Bittersweet];\n ~~~\n \n > ***Note:*** Until recently Rust only had unique vectors, using the\n@@ -1161,15 +1161,15 @@ Vector literals are enclosed in square brackets and dereferencing is\n also done with square brackets (zero-based):\n \n ~~~~\n-# enum crayon { almond, antique_brass, apricot,\n-#               aquamarine, asparagus, atomic_tangerine,\n-#               banana_mania, beaver, bittersweet };\n-# fn draw_scene(c: crayon) { }\n+# enum Crayon { Almond, AntiqueBrass, Apricot,\n+#               Aquamarine, Asparagus, AtomicTangerine,\n+#               BananaMania, Beaver, Bittersweet };\n+# fn draw_scene(c: Crayon) { }\n \n-let crayons = ~[banana_mania, beaver, bittersweet];\n+let crayons = ~[BananaMania, Beaver, Bittersweet];\n match crayons[0] {\n-\t   bittersweet => draw_scene(crayons[0]),\n-       _ => ()\n+    Bittersweet => draw_scene(crayons[0]),\n+    _ => ()\n }\n ~~~~\n \n@@ -1179,23 +1179,23 @@ elements. Mutable vector literals are written `~[mut]` (empty) or `~[mut\n 1, 2, 3]` (with elements).\n \n ~~~~\n-# enum crayon { almond, antique_brass, apricot,\n-#               aquamarine, asparagus, atomic_tangerine,\n-#               banana_mania, beaver, bittersweet };\n+# enum Crayon { Almond, AntiqueBrass, Apricot,\n+#               Aquamarine, Asparagus, AtomicTangerine,\n+#               BananaMania, Beaver, Bittersweet };\n \n-let crayons = ~[mut banana_mania, beaver, bittersweet];\n-crayons[0] = atomic_tangerine;\n+let crayons = ~[mut BananaMania, Beaver, Bittersweet];\n+crayons[0] = AtomicTangerine;\n ~~~~\n \n The `+` operator means concatenation when applied to vector types.\n \n ~~~~\n-# enum crayon { almond, antique_brass, apricot,\n-#               aquamarine, asparagus, atomic_tangerine,\n-#               banana_mania, beaver, bittersweet };\n+# enum Crayon { Almond, AntiqueBrass, Apricot,\n+#               Aquamarine, Asparagus, AtomicTangerine,\n+#               BananaMania, Beaver, Bittersweet };\n \n-let my_crayons = ~[almond, antique_brass, apricot];\n-let your_crayons = ~[banana_mania, beaver, bittersweet];\n+let my_crayons = ~[Almond, AntiqueBrass, Apricot];\n+let your_crayons = ~[BananaMania, Beaver, Bittersweet];\n \n let our_crayons = my_crayons + your_crayons;\n ~~~~\n@@ -1204,12 +1204,12 @@ The `+=` operator also works as expected, provided the assignee\n lives in a mutable slot.\n \n ~~~~\n-# enum crayon { almond, antique_brass, apricot,\n-#               aquamarine, asparagus, atomic_tangerine,\n-#               banana_mania, beaver, bittersweet };\n+# enum Crayon { Almond, AntiqueBrass, Apricot,\n+#               Aquamarine, Asparagus, AtomicTangerine,\n+#               BananaMania, Beaver, Bittersweet };\n \n-let mut my_crayons = ~[almond, antique_brass, apricot];\n-let your_crayons = ~[banana_mania, beaver, bittersweet];\n+let mut my_crayons = ~[Almond, AntiqueBrass, Apricot];\n+let your_crayons = ~[BananaMania, Beaver, Bittersweet];\n \n my_crayons += your_crayons;\n ~~~~\n@@ -1223,17 +1223,17 @@ brief look at a few common ones.\n \n ~~~\n # use io::println;\n-# enum crayon {\n-#     almond, antique_brass, apricot,\n-#     aquamarine, asparagus, atomic_tangerine,\n-#     banana_mania, beaver, bittersweet\n+# enum Crayon {\n+#     Almond, AntiqueBrass, Apricot,\n+#     Aquamarine, Asparagus, AtomicTangerine,\n+#     BananaMania, Beaver, Bittersweet\n # }\n-# fn unwrap_crayon(c: crayon) -> int { 0 }\n+# fn unwrap_crayon(c: Crayon) -> int { 0 }\n # fn eat_crayon_wax(i: int) { }\n-# fn store_crayon_in_nasal_cavity(i: uint, c: crayon) { }\n-# fn crayon_to_str(c: crayon) -> ~str { ~\"\" }\n+# fn store_crayon_in_nasal_cavity(i: uint, c: Crayon) { }\n+# fn crayon_to_str(c: Crayon) -> ~str { ~\"\" }\n \n-let crayons = ~[almond, antique_brass, apricot];\n+let crayons = ~[Almond, AntiqueBrass, Apricot];\n \n // Check the length of the vector\n assert crayons.len() == 3;\n@@ -1625,7 +1625,7 @@ For example, we could declare the trait `to_str` for things that\n can be converted to a string, with a single method of the same name:\n \n ~~~~\n-trait to_str {\n+trait ToStr {\n     fn to_str() -> ~str;\n }\n ~~~~\n@@ -1637,11 +1637,11 @@ is used. This defines implementations of `to_str` for the `int` and\n `~str` types.\n \n ~~~~\n-# trait to_str { fn to_str() -> ~str; }\n-impl int: to_str {\n+# trait ToStr { fn to_str() -> ~str; }\n+impl int: ToStr {\n     fn to_str() -> ~str { int::to_str(self, 10u) }\n }\n-impl ~str: to_str {\n+impl ~str: ToStr {\n     fn to_str() -> ~str { self }\n }\n ~~~~\n@@ -1662,8 +1662,8 @@ known at compile time, it is possible to specify 'bounds' for type\n parameters.\n \n ~~~~\n-# trait to_str { fn to_str() -> ~str; }\n-fn comma_sep<T: to_str>(elts: ~[T]) -> ~str {\n+# trait ToStr { fn to_str() -> ~str; }\n+fn comma_sep<T: ToStr>(elts: ~[T]) -> ~str {\n     let mut result = ~\"\", first = true;\n     for elts.each |elt| {\n         if first { first = false; }\n@@ -1688,11 +1688,11 @@ Traits may contain type parameters. A trait for\n generalized sequence types is:\n \n ~~~~\n-trait seq<T> {\n+trait Seq<T> {\n     fn len() -> uint;\n     fn iter(fn(T));\n }\n-impl<T> ~[T]: seq<T> {\n+impl<T> ~[T]: Seq<T> {\n     fn len() -> uint { vec::len(self) }\n     fn iter(b: fn(T)) {\n         for self.each |elt| { b(elt); }\n@@ -1716,11 +1716,11 @@ type parameter. An implementation of the trait for any given type\n trait describes types that support an equality operation:\n \n ~~~~\n-trait eq {\n+trait Eq {\n   fn equals(&&other: self) -> bool;\n }\n \n-impl int: eq {\n+impl int: Eq {\n   fn equals(&&other: int) -> bool { other == self }\n }\n ~~~~\n@@ -1735,14 +1735,14 @@ values of *an* unknown type that conforms to a given trait.\n However, consider this function:\n \n ~~~~\n-# type circle = int; type rectangle = int;\n-# trait drawable { fn draw(); }\n-# impl int: drawable { fn draw() {} }\n+# type Circle = int; type Rectangle = int;\n+# trait Drawable { fn draw(); }\n+# impl int: Drawable { fn draw() {} }\n # fn new_circle() -> int { 1 }\n-fn draw_all<T: drawable>(shapes: ~[T]) {\n+fn draw_all<T: Drawable>(shapes: ~[T]) {\n     for shapes.each |shape| { shape.draw(); }\n }\n-# let c: circle = new_circle();\n+# let c: Circle = new_circle();\n # draw_all(~[c]);\n ~~~~\n \n@@ -1754,8 +1754,8 @@ When this is needed, a trait name can be used as a type, causing\n the function to be written simply like this:\n \n ~~~~\n-# trait drawable { fn draw(); }\n-fn draw_all(shapes: ~[drawable]) {\n+# trait Drawable { fn draw(); }\n+fn draw_all(shapes: ~[Drawable]) {\n     for shapes.each |shape| { shape.draw(); }\n }\n ~~~~\n@@ -1772,15 +1772,15 @@ To construct such a value, you use the `as` operator to cast a value\n to a trait type:\n \n ~~~~\n-# type circle = int; type rectangle = int;\n-# trait drawable { fn draw(); }\n-# impl int: drawable { fn draw() {} }\n+# type Circle = int; type Rectangle = int;\n+# trait Drawable { fn draw(); }\n+# impl int: Drawable { fn draw() {} }\n # fn new_circle() -> int { 1 }\n # fn new_rectangle() -> int { 2 }\n-# fn draw_all(shapes: ~[drawable]) {}\n-let c: circle = new_circle();\n-let r: rectangle = new_rectangle();\n-draw_all(~[c as drawable, r as drawable]);\n+# fn draw_all(shapes: ~[Drawable]) {}\n+let c: Circle = new_circle();\n+let r: Rectangle = new_rectangle();\n+draw_all(~[c as Drawable, r as Drawable]);\n ~~~~\n \n This will store the value into a box, along with information about the\n@@ -1893,7 +1893,7 @@ It is possible to provide more specific information when using an\n external crate.\n \n ~~~~ {.ignore}\n-use myfarm (name = \"farm\", vers = \"2.7\");\n+extern mod myfarm (name = \"farm\", vers = \"2.7\");\n ~~~~\n \n When a comma-separated list of name/value pairs is given after `use`,\n@@ -1936,8 +1936,7 @@ fn world() -> ~str { ~\"world\" }\n \n ~~~~ {.ignore}\n // main.rs\n-extern mod std;\n-use mylib;\n+extern mod mylib;\n fn main() { io::println(~\"hello \" + mylib::world()); }\n ~~~~\n \n@@ -1984,9 +1983,9 @@ restricted with `export` directives at the top of the module or file.\n ~~~~\n mod enc {\n     export encrypt, decrypt;\n-    const super_secret_number: int = 10;\n-    fn encrypt(n: int) -> int { n + super_secret_number }\n-    fn decrypt(n: int) -> int { n - super_secret_number }\n+    const SUPER_SECRET_NUMBER: int = 10;\n+    fn encrypt(n: int) -> int { n + SUPER_SECRET_NUMBER }\n+    fn decrypt(n: int) -> int { n - SUPER_SECRET_NUMBER }\n }\n ~~~~\n \n@@ -2012,8 +2011,7 @@ fn main() {\n \n You don't want to write things like that, but it *is* very practical\n to not have to worry about name clashes between types, values, and\n-modules. This allows us to have a module `core::str`, for example, even\n-though `str` is a built-in type name.\n+modules.\n \n ## Resolution\n \n@@ -2027,29 +2025,33 @@ Identifiers can shadow each other. In this program, `x` is of type\n `int`:\n \n ~~~~\n-type t = ~str;\n+type MyType = ~str;\n fn main() {\n-    type t = int;\n-    let x: t;\n+    type MyType = int;\n+    let x: MyType;\n }\n ~~~~\n \n An `use` directive will only import into the namespaces for which\n identifiers are actually found. Consider this example:\n \n ~~~~\n-type bar = uint;\n mod foo { fn bar() {} }\n-mod baz {\n-    use foo::bar;\n-    const x: bar = 20u;\n+fn baz() {\n+    let bar = 10u;\n+\n+    {\n+        use foo::bar;\n+        let quux = bar;\n+    }\n }\n ~~~~\n \n-When resolving the type name `bar` in the `const` definition, the\n-resolver will first look at the module context for `baz`. This has an\n-import named `bar`, but that's a function, not a type, So it continues\n-to the top level and finds a type named `bar` defined there.\n+When resolving the type name `bar` in the `quux` definition, the\n+resolver will first look at local block context for `baz`. This has an\n+import named `bar`, but that's function, not a value, So it continues\n+to the `baz` function context and finds a value named `bar` defined\n+there.\n \n Normally, multiple definitions of the same identifier in a scope are\n disallowed. Local variables defined with `let` are an exception to"}]}