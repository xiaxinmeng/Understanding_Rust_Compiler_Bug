{"sha": "b75803ad31772d105d86f8ebee0cbc8844a4fa29", "node_id": "C_kwDOAAsO6NoAKGI3NTgwM2FkMzE3NzJkMTA1ZDg2ZjhlYmVlMGNiYzg4NDRhNGZhMjk", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-01-30T16:57:48Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-01-30T16:57:48Z"}, "message": "Auto merge of #14057 - jonas-schievink:improve-match-to-let-else, r=jonas-schievink\n\nfeat: Improve \"match to let else\" assist\n\nCloses https://github.com/rust-lang/rust-analyzer/issues/13540\n\nHandles complex `let` patterns (rather than just idents), and diverging block expressions have their `{`/`}` stripped to create nicer code.", "tree": {"sha": "5e41d21ba1f6597c80fce0dc6262b55dbfabfce9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5e41d21ba1f6597c80fce0dc6262b55dbfabfce9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b75803ad31772d105d86f8ebee0cbc8844a4fa29", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b75803ad31772d105d86f8ebee0cbc8844a4fa29", "html_url": "https://github.com/rust-lang/rust/commit/b75803ad31772d105d86f8ebee0cbc8844a4fa29", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b75803ad31772d105d86f8ebee0cbc8844a4fa29/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f1b257f4eb4fef74b42fd7135d1cf3884e8b51c9", "url": "https://api.github.com/repos/rust-lang/rust/commits/f1b257f4eb4fef74b42fd7135d1cf3884e8b51c9", "html_url": "https://github.com/rust-lang/rust/commit/f1b257f4eb4fef74b42fd7135d1cf3884e8b51c9"}, {"sha": "6321b25a21935bce6f2498b19958762e8d120081", "url": "https://api.github.com/repos/rust-lang/rust/commits/6321b25a21935bce6f2498b19958762e8d120081", "html_url": "https://github.com/rust-lang/rust/commit/6321b25a21935bce6f2498b19958762e8d120081"}], "stats": {"total": 85, "additions": 62, "deletions": 23}, "files": [{"sha": "65c2479e9f29bb8ba560bc05bf686f1bf40eae3e", "filename": "crates/ide-assists/src/handlers/convert_match_to_let_else.rs", "status": "modified", "additions": 62, "deletions": 23, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/b75803ad31772d105d86f8ebee0cbc8844a4fa29/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_match_to_let_else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75803ad31772d105d86f8ebee0cbc8844a4fa29/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_match_to_let_else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_match_to_let_else.rs?ref=b75803ad31772d105d86f8ebee0cbc8844a4fa29", "patch": "@@ -30,24 +30,23 @@ use crate::{\n // ```\n pub(crate) fn convert_match_to_let_else(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n     let let_stmt: ast::LetStmt = ctx.find_node_at_offset()?;\n-    let binding = find_binding(let_stmt.pat()?)?;\n+    let binding = let_stmt.pat()?;\n \n-    let initializer = match let_stmt.initializer() {\n-        Some(ast::Expr::MatchExpr(it)) => it,\n-        _ => return None,\n-    };\n+    let Some(ast::Expr::MatchExpr(initializer)) = let_stmt.initializer() else { return None };\n     let initializer_expr = initializer.expr()?;\n \n-    let (extracting_arm, diverging_arm) = match find_arms(ctx, &initializer) {\n-        Some(it) => it,\n-        None => return None,\n-    };\n+    let Some((extracting_arm, diverging_arm)) = find_arms(ctx, &initializer) else { return None };\n     if extracting_arm.guard().is_some() {\n         cov_mark::hit!(extracting_arm_has_guard);\n         return None;\n     }\n \n-    let diverging_arm_expr = diverging_arm.expr()?;\n+    let diverging_arm_expr = match diverging_arm.expr()? {\n+        ast::Expr::BlockExpr(block) if block.modifier().is_none() && block.label().is_none() => {\n+            block.to_string()\n+        }\n+        other => format!(\"{{ {other} }}\"),\n+    };\n     let extracting_arm_pat = extracting_arm.pat()?;\n     let extracted_variable = find_extracted_variable(ctx, &extracting_arm)?;\n \n@@ -56,24 +55,16 @@ pub(crate) fn convert_match_to_let_else(acc: &mut Assists, ctx: &AssistContext<'\n         \"Convert match to let-else\",\n         let_stmt.syntax().text_range(),\n         |builder| {\n-            let extracting_arm_pat = rename_variable(&extracting_arm_pat, extracted_variable, binding);\n+            let extracting_arm_pat =\n+                rename_variable(&extracting_arm_pat, extracted_variable, binding);\n             builder.replace(\n                 let_stmt.syntax().text_range(),\n-                format!(\"let {extracting_arm_pat} = {initializer_expr} else {{ {diverging_arm_expr} }};\")\n+                format!(\"let {extracting_arm_pat} = {initializer_expr} else {diverging_arm_expr};\"),\n             )\n         },\n     )\n }\n \n-// Given a pattern, find the name introduced to the surrounding scope.\n-fn find_binding(pat: ast::Pat) -> Option<ast::IdentPat> {\n-    if let ast::Pat::IdentPat(ident) = pat {\n-        Some(ident)\n-    } else {\n-        None\n-    }\n-}\n-\n // Given a match expression, find extracting and diverging arms.\n fn find_arms(\n     ctx: &AssistContext<'_>,\n@@ -124,7 +115,7 @@ fn find_extracted_variable(ctx: &AssistContext<'_>, arm: &ast::MatchArm) -> Opti\n }\n \n // Rename `extracted` with `binding` in `pat`.\n-fn rename_variable(pat: &ast::Pat, extracted: ast::Name, binding: ast::IdentPat) -> SyntaxNode {\n+fn rename_variable(pat: &ast::Pat, extracted: ast::Name, binding: ast::Pat) -> SyntaxNode {\n     let syntax = pat.syntax().clone_for_update();\n     let extracted_syntax = syntax.covering_element(extracted.syntax().text_range());\n \n@@ -136,7 +127,7 @@ fn rename_variable(pat: &ast::Pat, extracted: ast::Name, binding: ast::IdentPat)\n         if let Some(name_ref) = record_pat_field.field_name() {\n             ted::replace(\n                 record_pat_field.syntax(),\n-                ast::make::record_pat_field(ast::make::name_ref(&name_ref.text()), binding.into())\n+                ast::make::record_pat_field(ast::make::name_ref(&name_ref.text()), binding)\n                     .syntax()\n                     .clone_for_update(),\n             );\n@@ -410,4 +401,52 @@ fn foo(opt: Option<i32>) -> Option<i32> {\n     \"#,\n         );\n     }\n+\n+    #[test]\n+    fn complex_pattern() {\n+        check_assist(\n+            convert_match_to_let_else,\n+            r#\"\n+//- minicore: option\n+fn f() {\n+    let (x, y) = $0match Some((0, 1)) {\n+        Some(it) => it,\n+        None => return,\n+    };\n+}\n+\"#,\n+            r#\"\n+fn f() {\n+    let Some((x, y)) = Some((0, 1)) else { return };\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn diverging_block() {\n+        check_assist(\n+            convert_match_to_let_else,\n+            r#\"\n+//- minicore: option\n+fn f() {\n+    let x = $0match Some(()) {\n+        Some(it) => it,\n+        None => {//comment\n+            println!(\"nope\");\n+            return\n+        },\n+    };\n+}\n+\"#,\n+            r#\"\n+fn f() {\n+    let Some(x) = Some(()) else {//comment\n+            println!(\"nope\");\n+            return\n+        };\n+}\n+\"#,\n+        );\n+    }\n }"}]}