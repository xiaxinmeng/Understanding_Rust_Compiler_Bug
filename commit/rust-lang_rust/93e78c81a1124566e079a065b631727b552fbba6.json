{"sha": "93e78c81a1124566e079a065b631727b552fbba6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkzZTc4YzgxYTExMjQ1NjZlMDc5YTA2NWI2MzE3MjdiNTUyZmJiYTY=", "commit": {"author": {"name": "Zaki Manian", "email": "zaki@manian.org", "date": "2017-09-03T04:33:26Z"}, "committer": {"name": "Zaki Manian", "email": "zaki@manian.org", "date": "2017-09-03T04:33:26Z"}, "message": "RustFmt changes", "tree": {"sha": "9c18acce57e37f758f3891c244f9f528c921a65a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9c18acce57e37f758f3891c244f9f528c921a65a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/93e78c81a1124566e079a065b631727b552fbba6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/93e78c81a1124566e079a065b631727b552fbba6", "html_url": "https://github.com/rust-lang/rust/commit/93e78c81a1124566e079a065b631727b552fbba6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/93e78c81a1124566e079a065b631727b552fbba6/comments", "author": {"login": "zmanian", "id": 93434, "node_id": "MDQ6VXNlcjkzNDM0", "avatar_url": "https://avatars.githubusercontent.com/u/93434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zmanian", "html_url": "https://github.com/zmanian", "followers_url": "https://api.github.com/users/zmanian/followers", "following_url": "https://api.github.com/users/zmanian/following{/other_user}", "gists_url": "https://api.github.com/users/zmanian/gists{/gist_id}", "starred_url": "https://api.github.com/users/zmanian/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zmanian/subscriptions", "organizations_url": "https://api.github.com/users/zmanian/orgs", "repos_url": "https://api.github.com/users/zmanian/repos", "events_url": "https://api.github.com/users/zmanian/events{/privacy}", "received_events_url": "https://api.github.com/users/zmanian/received_events", "type": "User", "site_admin": false}, "committer": {"login": "zmanian", "id": 93434, "node_id": "MDQ6VXNlcjkzNDM0", "avatar_url": "https://avatars.githubusercontent.com/u/93434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zmanian", "html_url": "https://github.com/zmanian", "followers_url": "https://api.github.com/users/zmanian/followers", "following_url": "https://api.github.com/users/zmanian/following{/other_user}", "gists_url": "https://api.github.com/users/zmanian/gists{/gist_id}", "starred_url": "https://api.github.com/users/zmanian/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zmanian/subscriptions", "organizations_url": "https://api.github.com/users/zmanian/orgs", "repos_url": "https://api.github.com/users/zmanian/repos", "events_url": "https://api.github.com/users/zmanian/events{/privacy}", "received_events_url": "https://api.github.com/users/zmanian/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "27e55c96ceaf489f74bcbe13c066a9d6b1b18c16", "url": "https://api.github.com/repos/rust-lang/rust/commits/27e55c96ceaf489f74bcbe13c066a9d6b1b18c16", "html_url": "https://github.com/rust-lang/rust/commit/27e55c96ceaf489f74bcbe13c066a9d6b1b18c16"}], "stats": {"total": 105, "additions": 53, "deletions": 52}, "files": [{"sha": "be6a750fec921d51ee39a45b57474b1d0599d672", "filename": "clippy_lints/src/is_unit_expr.rs", "status": "modified", "additions": 53, "deletions": 52, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/93e78c81a1124566e079a065b631727b552fbba6/clippy_lints%2Fsrc%2Fis_unit_expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93e78c81a1124566e079a065b631727b552fbba6/clippy_lints%2Fsrc%2Fis_unit_expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fis_unit_expr.rs?ref=93e78c81a1124566e079a065b631727b552fbba6", "patch": "@@ -4,18 +4,21 @@ use std::ops::Deref;\n use syntax::ext::quote::rt::Span;\n \n \n-/// **What it does:** Checks for \n+/// **What it does:** Checks for\n ///  - () being assigned to a variable\n ///  - () being passed to a function\n ///\n-/// **Why is this bad?** It is extremely unlikely that a user intended to assign '()' to valiable. Instead,\n-///   Unit is what a block evaluates to when it returns nothing. This is typically caused by a trailing \n-///   unintended semicolon. \n+/// **Why is this bad?** It is extremely unlikely that a user intended to\n+/// assign '()' to valiable. Instead,\n+/// Unit is what a block evaluates to when it returns nothing. This is\n+/// typically caused by a trailing\n+///   unintended semicolon.\n ///\n /// **Known problems:** None.\n ///\n /// **Example:**\n-/// * `let x = {\"foo\" ;}` when the user almost certainly intended `let x ={\"foo\"}`\n+/// * `let x = {\"foo\" ;}` when the user almost certainly intended `let x\n+/// ={\"foo\"}`\n \n declare_lint! {\n     pub UNIT_EXPR,\n@@ -35,81 +38,79 @@ impl LintPass for UnitExpr {\n impl EarlyLintPass for UnitExpr {\n     fn check_expr(&mut self, cx: &EarlyContext, expr: &Expr) {\n         if let ExprKind::Assign(ref _left, ref right) = expr.node {\n-            if let Some(span) = is_unit_expr(right){\n-                    cx.span_lint(UNIT_EXPR, span, \"Consider removing the trailing semicolon\");\n+            if let Some(span) = is_unit_expr(right) {\n+                cx.span_lint(UNIT_EXPR, span, \"Consider removing the trailing semicolon\");\n             }\n         }\n         if let ExprKind::MethodCall(ref _left, ref args) = expr.node {\n-            for ref arg in args{\n-                if let Some(span) = is_unit_expr(arg){\n+            for ref arg in args {\n+                if let Some(span) = is_unit_expr(arg) {\n                     cx.span_lint(UNIT_EXPR, span, \"Consider removing the trailing semicolon\");\n-                }            \n+                }\n             }\n         }\n-        if let ExprKind::Call( _, ref args) = expr.node{\n-            for ref arg in args{\n-                if let Some(span) = is_unit_expr(arg){\n-                       cx.span_lint(UNIT_EXPR, span, \"Consider removing the trailing semicolon\");\n-                }            \n-            }        \n+        if let ExprKind::Call(_, ref args) = expr.node {\n+            for ref arg in args {\n+                if let Some(span) = is_unit_expr(arg) {\n+                    cx.span_lint(UNIT_EXPR, span, \"Consider removing the trailing semicolon\");\n+                }\n+            }\n         }\n     }\n \n     fn check_stmt(&mut self, cx: &EarlyContext, stmt: &Stmt) {\n-        if let StmtKind::Local(ref local) = stmt.node{\n-            if local.pat.node == PatKind::Wild {return;}\n-            if let Some(ref expr) = local.init{\n-                if let Some(span) = is_unit_expr(expr){\n-                    cx.span_lint(UNIT_EXPR, span, \"Consider removing the trailing semicolon\");  \n+        if let StmtKind::Local(ref local) = stmt.node {\n+            if local.pat.node == PatKind::Wild {\n+                return;\n             }\n+            if let Some(ref expr) = local.init {\n+                if let Some(span) = is_unit_expr(expr) {\n+                    cx.span_lint(UNIT_EXPR, span, \"Consider removing the trailing semicolon\");\n+                }\n+            }\n+        }\n     }\n }\n-}\n-}\n-fn is_unit_expr(expr: &Expr)->Option<Span>{\n-    match expr.node{\n-         ExprKind::Block(ref block) => {\n-             if check_last_stmt_in_block(block){\n-                 return Some(block.stmts[block.stmts.len()-1].span.clone());\n-             } else{\n-                 return None;\n-             }\n+fn is_unit_expr(expr: &Expr) -> Option<Span> {\n+    match expr.node {\n+        ExprKind::Block(ref block) => if check_last_stmt_in_block(block) {\n+            return Some(block.stmts[block.stmts.len() - 1].span.clone());\n+        } else {\n+            return None;\n         },\n-        ExprKind::If(_, ref then, ref else_)=>{\n+        ExprKind::If(_, ref then, ref else_) => {\n             let check_then = check_last_stmt_in_block(then);\n-            if let Some(ref else_) = *else_{\n+            if let Some(ref else_) = *else_ {\n                 let check_else = is_unit_expr(else_.deref());\n-                if let Some(ref expr_else) = check_else{\n+                if let Some(ref expr_else) = check_else {\n                     return Some(expr_else.clone());\n-                }else{\n+                } else {\n                     return Some(expr.span.clone());\n                 }\n-            } \n-            if check_then { \n+            }\n+            if check_then {\n                 return Some(expr.span.clone());\n-\n-            } else{\n+            } else {\n                 return Some(expr.span.clone());\n             }\n         },\n-        ExprKind::Match(ref _pattern, ref arms ) =>{\n-            for ref arm in arms{\n-                if let Some(expr) = is_unit_expr(&arm.body){\n+        ExprKind::Match(ref _pattern, ref arms) => {\n+            for ref arm in arms {\n+                if let Some(expr) = is_unit_expr(&arm.body) {\n                     return Some(expr);\n                 }\n             }\n             return None;\n-        }\n+        },\n         _ => return None,\n     }\n }\n \n-fn check_last_stmt_in_block(block: &Block)->bool{\n-    let ref final_stmt = &block.stmts[block.stmts.len()-1];\n-        if let StmtKind::Expr(_) = final_stmt.node{\n-                return false;\n-            }\n-            else{\n-              return true; \n-            }\n-}\n\\ No newline at end of file\n+fn check_last_stmt_in_block(block: &Block) -> bool {\n+    let ref final_stmt = &block.stmts[block.stmts.len() - 1];\n+    if let StmtKind::Expr(_) = final_stmt.node {\n+        return false;\n+    } else {\n+        return true;\n+    }\n+}"}]}