{"sha": "48f3507763c646e2353e84f6b0e7269784588d17", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ4ZjM1MDc3NjNjNjQ2ZTIzNTNlODRmNmIwZTcyNjk3ODQ1ODhkMTc=", "commit": {"author": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2015-08-06T21:52:40Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2015-08-17T21:41:39Z"}, "message": "Use error codes for platform-intrinsic typeck errors.", "tree": {"sha": "bb6688ecbcf948f0c3d1be21b7ad397e9879e2af", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bb6688ecbcf948f0c3d1be21b7ad397e9879e2af"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/48f3507763c646e2353e84f6b0e7269784588d17", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/48f3507763c646e2353e84f6b0e7269784588d17", "html_url": "https://github.com/rust-lang/rust/commit/48f3507763c646e2353e84f6b0e7269784588d17", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/48f3507763c646e2353e84f6b0e7269784588d17/comments", "author": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dbcd9f00d1d66e9f245c3b934fe9530982430824", "url": "https://api.github.com/repos/rust-lang/rust/commits/dbcd9f00d1d66e9f245c3b934fe9530982430824", "html_url": "https://github.com/rust-lang/rust/commit/dbcd9f00d1d66e9f245c3b934fe9530982430824"}], "stats": {"total": 172, "additions": 88, "deletions": 84}, "files": [{"sha": "0df497877ae178d386b9d757dc22796c542b8c5d", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 82, "deletions": 83, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/48f3507763c646e2353e84f6b0e7269784588d17/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48f3507763c646e2353e84f6b0e7269784588d17/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=48f3507763c646e2353e84f6b0e7269784588d17", "patch": "@@ -29,6 +29,41 @@ use syntax::ast_util::local_def;\n use syntax::codemap::Span;\n use syntax::parse::token;\n \n+fn equate_intrinsic_type<'a, 'tcx>(tcx: &ty::ctxt<'tcx>, it: &ast::ForeignItem,\n+                                   maybe_infcx: Option<&infer::InferCtxt<'a, 'tcx>>,\n+                                   n_tps: usize,\n+                                   abi: abi::Abi,\n+                                   inputs: Vec<ty::Ty<'tcx>>,\n+                                   output: ty::FnOutput<'tcx>) {\n+    let fty = tcx.mk_fn(None, tcx.mk_bare_fn(ty::BareFnTy {\n+        unsafety: ast::Unsafety::Unsafe,\n+        abi: abi,\n+        sig: ty::Binder(FnSig {\n+            inputs: inputs,\n+            output: output,\n+            variadic: false,\n+        }),\n+    }));\n+    let i_ty = tcx.lookup_item_type(local_def(it.id));\n+    let i_n_tps = i_ty.generics.types.len(subst::FnSpace);\n+    if i_n_tps != n_tps {\n+        span_err!(tcx.sess, it.span, E0094,\n+            \"intrinsic has wrong number of type \\\n+             parameters: found {}, expected {}\",\n+             i_n_tps, n_tps);\n+    } else {\n+        require_same_types(tcx,\n+                           maybe_infcx,\n+                           false,\n+                           it.span,\n+                           i_ty.ty,\n+                           fty,\n+                           || {\n+                format!(\"intrinsic has wrong type: expected `{}`\",\n+                         fty)\n+            });\n+    }\n+}\n \n /// Remember to add all intrinsics here, in librustc_trans/trans/intrinsic.rs,\n /// and in libcore/intrinsics.rs\n@@ -312,34 +347,15 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &ast::ForeignItem) {\n         };\n         (n_tps, inputs, ty::FnConverging(output))\n     };\n-    let fty = tcx.mk_fn(None, tcx.mk_bare_fn(ty::BareFnTy {\n-        unsafety: ast::Unsafety::Unsafe,\n-        abi: abi::RustIntrinsic,\n-        sig: ty::Binder(FnSig {\n-            inputs: inputs,\n-            output: output,\n-            variadic: false,\n-        }),\n-    }));\n-    let i_ty = ccx.tcx.lookup_item_type(local_def(it.id));\n-    let i_n_tps = i_ty.generics.types.len(subst::FnSpace);\n-    if i_n_tps != n_tps {\n-        span_err!(tcx.sess, it.span, E0094,\n-            \"intrinsic has wrong number of type \\\n-             parameters: found {}, expected {}\",\n-             i_n_tps, n_tps);\n-    } else {\n-        require_same_types(tcx,\n-                           None,\n-                           false,\n-                           it.span,\n-                           i_ty.ty,\n-                           fty,\n-                           || {\n-                format!(\"intrinsic has wrong type: expected `{}`\",\n-                         fty)\n-            });\n-    }\n+    equate_intrinsic_type(\n+        tcx,\n+        it,\n+        None,\n+        n_tps,\n+        abi::RustIntrinsic,\n+        inputs,\n+        output\n+        )\n }\n \n /// Type-check `extern \"platform-intrinsic\" { ... }` functions.\n@@ -391,10 +407,10 @@ pub fn check_platform_intrinsic_type(ccx: &CrateCtxt,\n                 Some(intr) => {\n                     // this function is a platform specific intrinsic\n                     if i_n_tps != 0 {\n-                        tcx.sess.span_err(it.span,\n-                                         &format!(\"intrinsic has wrong number of type parameters: \\\n-                                                    found {}, expected 0\",\n-                                                   i_n_tps));\n+                        span_err!(tcx.sess, it.span, E0440,\n+                                  \"platform-specific intrinsic has wrong number of type \\\n+                                   parameters: found {}, expected 0\",\n+                                  i_n_tps);\n                         return\n                     }\n \n@@ -412,40 +428,23 @@ pub fn check_platform_intrinsic_type(ccx: &CrateCtxt,\n                     return\n                 }\n                 None => {\n-                    tcx.sess.span_err(it.span,\n-                                      &format!(\"unrecognized intrinsic function: `{}`\", name));\n+                    span_err!(tcx.sess, it.span, E0441,\n+                              \"unrecognized platform-specific intrinsic function: `{}`\", name);\n                     return;\n                 }\n             }\n         }\n     };\n \n-    let fty = tcx.mk_fn(None, tcx.mk_bare_fn(ty::BareFnTy {\n-        unsafety: ast::Unsafety::Unsafe,\n-        abi: abi::PlatformIntrinsic,\n-        sig: ty::Binder(FnSig {\n-            inputs: inputs,\n-            output: ty::FnConverging(output),\n-            variadic: false,\n-        }),\n-    }));\n-    if i_n_tps != n_tps {\n-        span_err!(tcx.sess, it.span, E0094,\n-            \"intrinsic has wrong number of type \\\n-             parameters: found {}, expected {}\",\n-             i_n_tps, n_tps);\n-    } else {\n-        require_same_types(tcx,\n-                           infer_ctxt.as_ref(),\n-                           false,\n-                           it.span,\n-                           i_ty.ty,\n-                           fty,\n-                           || {\n-                format!(\"intrinsic has wrong type: expected `{}`\",\n-                         fty)\n-            });\n-    }\n+    equate_intrinsic_type(\n+        tcx,\n+        it,\n+        infer_ctxt.as_ref(),\n+        n_tps,\n+        abi::PlatformIntrinsic,\n+        inputs,\n+        ty::FnConverging(output)\n+        )\n }\n \n // walk the expected type and the actual type in lock step, checking they're\n@@ -459,53 +458,53 @@ fn match_intrinsic_type_to_type<'tcx, 'a>(\n         expected: &'a intrinsics::Type, t: ty::Ty<'tcx>)\n {\n     use intrinsics::Type::*;\n+\n+    let simple_error = |real: &str, expected: &str| {\n+        span_err!(tcx.sess, span, E0442,\n+                  \"intrinsic {} has wrong type: found {}, expected {}\",\n+                  position, real, expected)\n+    };\n+\n     match *expected {\n         Integer(bits) => match (bits, &t.sty) {\n             (8, &ty::TyInt(ast::TyI8)) | (8, &ty::TyUint(ast::TyU8)) |\n             (16, &ty::TyInt(ast::TyI16)) | (16, &ty::TyUint(ast::TyU16)) |\n             (32, &ty::TyInt(ast::TyI32)) | (32, &ty::TyUint(ast::TyU32)) |\n             (64, &ty::TyInt(ast::TyI64)) | (64, &ty::TyUint(ast::TyU64)) => {},\n-            _ => tcx.sess.span_err(span,\n-                                   &format!(\"intrinsic {} has wrong type: found `{}`, \\\n-                                             expected `i{n}` or `u{n}`\",\n-                                            position,\n-                                            t, n = bits)),\n+            _ => simple_error(&format!(\"`{}`\", t),\n+                              &format!(\"`i{n}` or `u{n}`\", n = bits)),\n         },\n         Float(bits) => match (bits, &t.sty) {\n             (32, &ty::TyFloat(ast::TyF32)) |\n             (64, &ty::TyFloat(ast::TyF64)) => {},\n-            _ => tcx.sess.span_err(span,\n-                                   &format!(\"intrinsic {} has wrong type: found `{}`, \\\n-                                             expected `f{n}`\",\n-                                            position,\n-                                            t, n = bits)),\n+            _ => simple_error(&format!(\"`{}`\", t),\n+                              &format!(\"`f{n}`\", n = bits)),\n         },\n         Pointer(_) => unimplemented!(),\n         Vector(ref inner_expected, len) => {\n             if !t.is_simd(tcx) {\n-                tcx.sess.span_err(span,\n-                                  &format!(\"intrinsic {} has wrong type: found non-simd type {}, \\\n-                                           expected simd type\",\n-                                           position, t));\n+                simple_error(&format!(\"non-simd type `{}`\", t),\n+                             \"simd type\");\n                 return;\n             }\n             let t_len = t.simd_size(tcx);\n             if len as usize != t_len {\n-                tcx.sess.span_err(span,\n-                                  &format!(\"intrinsic {} has wrong type: found \\\n-                                            vector with length {}, expected length {}\",\n-                                           position,\n-                                           t_len, len));\n+                simple_error(&format!(\"vector with length {}\", t_len),\n+                             &format!(\"length {}\", len));\n                 return;\n             }\n             let t_ty = t.simd_type(tcx);\n             {\n+                // check that a given structural type always has the same an intrinsic definition\n                 let previous = structural_to_nominal.entry(expected).or_insert(t);\n                 if *previous != t {\n-                    tcx.sess.span_err(span,\n-                                      &format!(\"intrinsic {} has wrong type: found `{}`, \\\n-                                                but already seen this vector type as `{}`\",\n-                                               position, t, previous));\n+                    // this gets its own error code because it is non-trivial\n+                    span_err!(tcx.sess, span, E0443,\n+                              \"intrinsic {} has wrong type: found `{}`, expected `{}` which \\\n+                               was used for this vector type previously in this signature\",\n+                              position,\n+                              t,\n+                              *previous);\n                     return;\n                 }\n             }"}, {"sha": "e8660e57a3ca32c64348b0efa1709c3879d6f881", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/48f3507763c646e2353e84f6b0e7269784588d17/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48f3507763c646e2353e84f6b0e7269784588d17/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=48f3507763c646e2353e84f6b0e7269784588d17", "patch": "@@ -2801,5 +2801,10 @@ register_diagnostics! {\n     E0399, // trait items need to be implemented because the associated\n            // type `{}` was overridden\n     E0436,  // functional record update requires a struct\n-    E0439 // invalid `simd_shuffle`, needs length: `{}`\n+    E0439, // invalid `simd_shuffle`, needs length: `{}`\n+    E0440, // platform-specific intrinsic has wrong number of type parameters\n+    E0441, // unrecognized platform-specific intrinsic function\n+    E0442, // intrinsic {} has wrong type: found {}, expected {}\n+    E0443, // intrinsic {} has wrong type: found `{}`, expected `{}` which\n+           // was used for this vector type previously in this signature\n }"}]}