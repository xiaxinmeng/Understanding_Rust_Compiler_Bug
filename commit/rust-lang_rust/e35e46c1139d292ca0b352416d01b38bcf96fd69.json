{"sha": "e35e46c1139d292ca0b352416d01b38bcf96fd69", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUzNWU0NmMxMTM5ZDI5MmNhMGIzNTI0MTZkMDFiMzhiY2Y5NmZkNjk=", "commit": {"author": {"name": "Aman Arora", "email": "me@aman-arora.com", "date": "2020-11-07T06:04:27Z"}, "committer": {"name": "Roxane", "email": "roxane.fruytier@hotmail.com", "date": "2020-11-30T00:20:28Z"}, "message": "Be cautious of calling upvar_tys before mir", "tree": {"sha": "29a5b1aa2ccc5868877bf02132fd9885915da28e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/29a5b1aa2ccc5868877bf02132fd9885915da28e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e35e46c1139d292ca0b352416d01b38bcf96fd69", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e35e46c1139d292ca0b352416d01b38bcf96fd69", "html_url": "https://github.com/rust-lang/rust/commit/e35e46c1139d292ca0b352416d01b38bcf96fd69", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e35e46c1139d292ca0b352416d01b38bcf96fd69/comments", "author": {"login": "arora-aman", "id": 4193035, "node_id": "MDQ6VXNlcjQxOTMwMzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4193035?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arora-aman", "html_url": "https://github.com/arora-aman", "followers_url": "https://api.github.com/users/arora-aman/followers", "following_url": "https://api.github.com/users/arora-aman/following{/other_user}", "gists_url": "https://api.github.com/users/arora-aman/gists{/gist_id}", "starred_url": "https://api.github.com/users/arora-aman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arora-aman/subscriptions", "organizations_url": "https://api.github.com/users/arora-aman/orgs", "repos_url": "https://api.github.com/users/arora-aman/repos", "events_url": "https://api.github.com/users/arora-aman/events{/privacy}", "received_events_url": "https://api.github.com/users/arora-aman/received_events", "type": "User", "site_admin": false}, "committer": {"login": "roxelo", "id": 12419401, "node_id": "MDQ6VXNlcjEyNDE5NDAx", "avatar_url": "https://avatars.githubusercontent.com/u/12419401?v=4", "gravatar_id": "", "url": "https://api.github.com/users/roxelo", "html_url": "https://github.com/roxelo", "followers_url": "https://api.github.com/users/roxelo/followers", "following_url": "https://api.github.com/users/roxelo/following{/other_user}", "gists_url": "https://api.github.com/users/roxelo/gists{/gist_id}", "starred_url": "https://api.github.com/users/roxelo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/roxelo/subscriptions", "organizations_url": "https://api.github.com/users/roxelo/orgs", "repos_url": "https://api.github.com/users/roxelo/repos", "events_url": "https://api.github.com/users/roxelo/events{/privacy}", "received_events_url": "https://api.github.com/users/roxelo/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5da2bf197d301f83716a209cb28ea2b403c8a20c", "url": "https://api.github.com/repos/rust-lang/rust/commits/5da2bf197d301f83716a209cb28ea2b403c8a20c", "html_url": "https://github.com/rust-lang/rust/commit/5da2bf197d301f83716a209cb28ea2b403c8a20c"}], "stats": {"total": 236, "additions": 131, "deletions": 105}, "files": [{"sha": "00fea91fdfcb81d342042cf7d656b761e7efcd9d", "filename": "compiler/rustc_middle/src/ty/layout.rs", "status": "modified", "additions": 129, "deletions": 99, "changes": 228, "blob_url": "https://github.com/rust-lang/rust/blob/e35e46c1139d292ca0b352416d01b38bcf96fd69/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e35e46c1139d292ca0b352416d01b38bcf96fd69/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs?ref=e35e46c1139d292ca0b352416d01b38bcf96fd69", "patch": "@@ -2105,118 +2105,148 @@ where\n     }\n \n     fn field(this: TyAndLayout<'tcx>, cx: &C, i: usize) -> C::TyAndLayout {\n-        let tcx = cx.tcx();\n-        let tag_layout = |tag: &Scalar| -> C::TyAndLayout {\n-            let layout = Layout::scalar(cx, tag.clone());\n-            MaybeResult::from(Ok(TyAndLayout {\n-                layout: tcx.intern_layout(layout),\n-                ty: tag.value.to_ty(tcx),\n-            }))\n-        };\n+        enum TyMaybeWithLayout<C: LayoutOf> {\n+            Ty(C::Ty),\n+            TyAndLayout(C::TyAndLayout),\n+        }\n \n-        cx.layout_of(match *this.ty.kind() {\n-            ty::Bool\n-            | ty::Char\n-            | ty::Int(_)\n-            | ty::Uint(_)\n-            | ty::Float(_)\n-            | ty::FnPtr(_)\n-            | ty::Never\n-            | ty::FnDef(..)\n-            | ty::GeneratorWitness(..)\n-            | ty::Foreign(..)\n-            | ty::Dynamic(..) => bug!(\"TyAndLayout::field_type({:?}): not applicable\", this),\n-\n-            // Potentially-fat pointers.\n-            ty::Ref(_, pointee, _) | ty::RawPtr(ty::TypeAndMut { ty: pointee, .. }) => {\n-                assert!(i < this.fields.count());\n-\n-                // Reuse the fat `*T` type as its own thin pointer data field.\n-                // This provides information about, e.g., DST struct pointees\n-                // (which may have no non-DST form), and will work as long\n-                // as the `Abi` or `FieldsShape` is checked by users.\n-                if i == 0 {\n-                    let nil = tcx.mk_unit();\n-                    let ptr_ty = if this.ty.is_unsafe_ptr() {\n-                        tcx.mk_mut_ptr(nil)\n-                    } else {\n-                        tcx.mk_mut_ref(tcx.lifetimes.re_static, nil)\n-                    };\n-                    return MaybeResult::from(cx.layout_of(ptr_ty).to_result().map(\n-                        |mut ptr_layout| {\n-                            ptr_layout.ty = this.ty;\n-                            ptr_layout\n-                        },\n-                    ));\n-                }\n+        fn ty_and_layout_kind<\n+            C: LayoutOf<Ty = Ty<'tcx>, TyAndLayout: MaybeResult<TyAndLayout<'tcx>>>\n+                + HasTyCtxt<'tcx>\n+                + HasParamEnv<'tcx>,\n+        >(\n+            this: TyAndLayout<'tcx>,\n+            cx: &C,\n+            i: usize,\n+            ty: C::Ty,\n+        ) -> TyMaybeWithLayout<C> {\n+            let tcx = cx.tcx();\n+            let tag_layout = |tag: &Scalar| -> C::TyAndLayout {\n+                let layout = Layout::scalar(cx, tag.clone());\n+                MaybeResult::from(Ok(TyAndLayout {\n+                    layout: tcx.intern_layout(layout),\n+                    ty: tag.value.to_ty(tcx),\n+                }))\n+            };\n \n-                match tcx.struct_tail_erasing_lifetimes(pointee, cx.param_env()).kind() {\n-                    ty::Slice(_) | ty::Str => tcx.types.usize,\n-                    ty::Dynamic(_, _) => {\n-                        tcx.mk_imm_ref(tcx.lifetimes.re_static, tcx.mk_array(tcx.types.usize, 3))\n-                        /* FIXME: use actual fn pointers\n-                        Warning: naively computing the number of entries in the\n-                        vtable by counting the methods on the trait + methods on\n-                        all parent traits does not work, because some methods can\n-                        be not object safe and thus excluded from the vtable.\n-                        Increase this counter if you tried to implement this but\n-                        failed to do it without duplicating a lot of code from\n-                        other places in the compiler: 2\n-                        tcx.mk_tup(&[\n-                            tcx.mk_array(tcx.types.usize, 3),\n-                            tcx.mk_array(Option<fn()>),\n-                        ])\n-                        */\n+            match *ty.kind() {\n+                ty::Bool\n+                | ty::Char\n+                | ty::Int(_)\n+                | ty::Uint(_)\n+                | ty::Float(_)\n+                | ty::FnPtr(_)\n+                | ty::Never\n+                | ty::FnDef(..)\n+                | ty::GeneratorWitness(..)\n+                | ty::Foreign(..)\n+                | ty::Dynamic(..) => bug!(\"TyAndLayout::field_type({:?}): not applicable\", this),\n+\n+                // Potentially-fat pointers.\n+                ty::Ref(_, pointee, _) | ty::RawPtr(ty::TypeAndMut { ty: pointee, .. }) => {\n+                    assert!(i < this.fields.count());\n+\n+                    // Reuse the fat `*T` type as its own thin pointer data field.\n+                    // This provides information about, e.g., DST struct pointees\n+                    // (which may have no non-DST form), and will work as long\n+                    // as the `Abi` or `FieldsShape` is checked by users.\n+                    if i == 0 {\n+                        let nil = tcx.mk_unit();\n+                        let ptr_ty = if ty.is_unsafe_ptr() {\n+                            tcx.mk_mut_ptr(nil)\n+                        } else {\n+                            tcx.mk_mut_ref(tcx.lifetimes.re_static, nil)\n+                        };\n+                        return TyMaybeWithLayout::TyAndLayout(MaybeResult::from(\n+                            cx.layout_of(ptr_ty).to_result().map(|mut ptr_layout| {\n+                                ptr_layout.ty = ty;\n+                                ptr_layout\n+                            }),\n+                        ));\n                     }\n-                    _ => bug!(\"TyAndLayout::field_type({:?}): not applicable\", this),\n-                }\n-            }\n \n-            // Arrays and slices.\n-            ty::Array(element, _) | ty::Slice(element) => element,\n-            ty::Str => tcx.types.u8,\n-\n-            // Tuples, generators and closures.\n-            ty::Closure(_, ref substs) => substs.as_closure().upvar_tys().nth(i).unwrap(),\n-\n-            ty::Generator(def_id, ref substs, _) => match this.variants {\n-                Variants::Single { index } => substs\n-                    .as_generator()\n-                    .state_tys(def_id, tcx)\n-                    .nth(index.as_usize())\n-                    .unwrap()\n-                    .nth(i)\n-                    .unwrap(),\n-                Variants::Multiple { ref tag, tag_field, .. } => {\n-                    if i == tag_field {\n-                        return tag_layout(tag);\n+                    match tcx.struct_tail_erasing_lifetimes(pointee, cx.param_env()).kind() {\n+                        ty::Slice(_) | ty::Str => TyMaybeWithLayout::Ty(tcx.types.usize),\n+                        ty::Dynamic(_, _) => {\n+                            TyMaybeWithLayout::Ty(tcx.mk_imm_ref(\n+                                tcx.lifetimes.re_static,\n+                                tcx.mk_array(tcx.types.usize, 3),\n+                            ))\n+                            /* FIXME: use actual fn pointers\n+                            Warning: naively computing the number of entries in the\n+                            vtable by counting the methods on the trait + methods on\n+                            all parent traits does not work, because some methods can\n+                            be not object safe and thus excluded from the vtable.\n+                            Increase this counter if you tried to implement this but\n+                            failed to do it without duplicating a lot of code from\n+                            other places in the compiler: 2\n+                            tcx.mk_tup(&[\n+                                tcx.mk_array(tcx.types.usize, 3),\n+                                tcx.mk_array(Option<fn()>),\n+                            ])\n+                            */\n+                        }\n+                        _ => bug!(\"TyAndLayout::field_type({:?}): not applicable\", this),\n                     }\n-                    substs.as_generator().prefix_tys().nth(i).unwrap()\n                 }\n-            },\n \n-            ty::Tuple(tys) => tys[i].expect_ty(),\n+                // Arrays and slices.\n+                ty::Array(element, _) | ty::Slice(element) => TyMaybeWithLayout::Ty(element),\n+                ty::Str => TyMaybeWithLayout::Ty(tcx.types.u8),\n \n-            // ADTs.\n-            ty::Adt(def, substs) => {\n-                match this.variants {\n-                    Variants::Single { index } => def.variants[index].fields[i].ty(tcx, substs),\n+                // Tuples, generators and closures.\n+                ty::Closure(_, ref substs) => {\n+                    ty_and_layout_kind(this, cx, i, substs.as_closure().tupled_upvars_ty())\n+                }\n+\n+                ty::Generator(def_id, ref substs, _) => match this.variants {\n+                    Variants::Single { index } => TyMaybeWithLayout::Ty(\n+                        substs\n+                            .as_generator()\n+                            .state_tys(def_id, tcx)\n+                            .nth(index.as_usize())\n+                            .unwrap()\n+                            .nth(i)\n+                            .unwrap(),\n+                    ),\n+                    Variants::Multiple { ref tag, tag_field, .. } => {\n+                        if i == tag_field {\n+                            return TyMaybeWithLayout::TyAndLayout(tag_layout(tag));\n+                        }\n+                        TyMaybeWithLayout::Ty(substs.as_generator().prefix_tys().nth(i).unwrap())\n+                    }\n+                },\n+\n+                ty::Tuple(tys) => TyMaybeWithLayout::Ty(tys[i].expect_ty()),\n+\n+                // ADTs.\n+                ty::Adt(def, substs) => {\n+                    match this.variants {\n+                        Variants::Single { index } => {\n+                            TyMaybeWithLayout::Ty(def.variants[index].fields[i].ty(tcx, substs))\n+                        }\n \n-                    // Discriminant field for enums (where applicable).\n-                    Variants::Multiple { ref tag, .. } => {\n-                        assert_eq!(i, 0);\n-                        return tag_layout(tag);\n+                        // Discriminant field for enums (where applicable).\n+                        Variants::Multiple { ref tag, .. } => {\n+                            assert_eq!(i, 0);\n+                            return TyMaybeWithLayout::TyAndLayout(tag_layout(tag));\n+                        }\n                     }\n                 }\n+\n+                ty::Projection(_)\n+                | ty::Bound(..)\n+                | ty::Placeholder(..)\n+                | ty::Opaque(..)\n+                | ty::Param(_)\n+                | ty::Infer(_)\n+                | ty::Error(_) => bug!(\"TyAndLayout::field_type: unexpected type `{}`\", this.ty),\n             }\n+        }\n \n-            ty::Projection(_)\n-            | ty::Bound(..)\n-            | ty::Placeholder(..)\n-            | ty::Opaque(..)\n-            | ty::Param(_)\n-            | ty::Infer(_)\n-            | ty::Error(_) => bug!(\"TyAndLayout::field_type: unexpected type `{}`\", this.ty),\n+        cx.layout_of(match ty_and_layout_kind(this, cx, i, this.ty) {\n+            TyMaybeWithLayout::Ty(result) => result,\n+            TyMaybeWithLayout::TyAndLayout(result) => return result,\n         })\n     }\n "}, {"sha": "64f82817d3944e4636237b96c744f4d9d38e3bd3", "filename": "compiler/rustc_ty_utils/src/needs_drop.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e35e46c1139d292ca0b352416d01b38bcf96fd69/compiler%2Frustc_ty_utils%2Fsrc%2Fneeds_drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e35e46c1139d292ca0b352416d01b38bcf96fd69/compiler%2Frustc_ty_utils%2Fsrc%2Fneeds_drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Fneeds_drop.rs?ref=e35e46c1139d292ca0b352416d01b38bcf96fd69", "patch": "@@ -94,16 +94,12 @@ where\n                     _ if component.is_copy_modulo_regions(tcx.at(DUMMY_SP), self.param_env) => (),\n \n                     ty::Closure(_, substs) => {\n-                        for upvar_ty in substs.as_closure().upvar_tys() {\n-                            queue_type(self, upvar_ty);\n-                        }\n+                        queue_type(self, substs.as_closure().tupled_upvars_ty());\n                     }\n \n                     ty::Generator(def_id, substs, _) => {\n                         let substs = substs.as_generator();\n-                        for upvar_ty in substs.upvar_tys() {\n-                            queue_type(self, upvar_ty);\n-                        }\n+                        queue_type(self, substs.tupled_upvars_ty());\n \n                         let witness = substs.witness();\n                         let interior_tys = match witness.kind() {"}]}