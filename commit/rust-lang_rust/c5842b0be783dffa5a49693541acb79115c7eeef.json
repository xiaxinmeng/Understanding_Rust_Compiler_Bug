{"sha": "c5842b0be783dffa5a49693541acb79115c7eeef", "node_id": "C_kwDOAAsO6NoAKGM1ODQyYjBiZTc4M2RmZmE1YTQ5NjkzNTQxYWNiNzkxMTVjN2VlZWY", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-11-08T14:37:40Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-11-08T14:37:40Z"}, "message": "Auto merge of #103965 - petrochenkov:effvisperf3, r=oli-obk\n\nresolve: More detailed effective visibility tracking for imports\n\nPer-`DefId` tracking is not enough, due to glob imports in particular, which have a single `DefId` for the whole glob import item.\nWe need to track this stuff per every introduced name (`NameBinding`).\n\nAlso drop `extern` blocks from the effective visibility table, they are nominally private and it doesn't make sense to keep them there.\n\nLater commits add some debug-only invariant checking and optimiaztions to mitigate regressions in https://github.com/rust-lang/rust/pull/103965#issuecomment-1304256445.\n\nThis is a bugfix and continuation of https://github.com/rust-lang/rust/pull/102026.", "tree": {"sha": "2e91a490f87f50dcba4289e8b04db5ae446417e3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2e91a490f87f50dcba4289e8b04db5ae446417e3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c5842b0be783dffa5a49693541acb79115c7eeef", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c5842b0be783dffa5a49693541acb79115c7eeef", "html_url": "https://github.com/rust-lang/rust/commit/c5842b0be783dffa5a49693541acb79115c7eeef", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c5842b0be783dffa5a49693541acb79115c7eeef/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ddfe1e87f7c85c03773c29180a931447fcd03b65", "url": "https://api.github.com/repos/rust-lang/rust/commits/ddfe1e87f7c85c03773c29180a931447fcd03b65", "html_url": "https://github.com/rust-lang/rust/commit/ddfe1e87f7c85c03773c29180a931447fcd03b65"}, {"sha": "43bea6cf69501dee3d71e4440d947182a67137a0", "url": "https://api.github.com/repos/rust-lang/rust/commits/43bea6cf69501dee3d71e4440d947182a67137a0", "html_url": "https://github.com/rust-lang/rust/commit/43bea6cf69501dee3d71e4440d947182a67137a0"}], "stats": {"total": 472, "additions": 339, "deletions": 133}, "files": [{"sha": "3a91522d362298400438eb5ee0446c2f10522d7c", "filename": "compiler/rustc_middle/src/middle/privacy.rs", "status": "modified", "additions": 103, "deletions": 21, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/c5842b0be783dffa5a49693541acb79115c7eeef/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5842b0be783dffa5a49693541acb79115c7eeef/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fprivacy.rs?ref=c5842b0be783dffa5a49693541acb79115c7eeef", "patch": "@@ -1,12 +1,14 @@\n //! A pass that checks to make sure private fields and methods aren't used\n //! outside their scopes. This pass will also generate a set of exported items\n //! which are available for use externally when compiled as a library.\n-use crate::ty::{DefIdTree, Visibility};\n+use crate::ty::{DefIdTree, TyCtxt, Visibility};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n+use rustc_hir::def::DefKind;\n use rustc_macros::HashStable;\n use rustc_query_system::ich::StableHashingContext;\n use rustc_span::def_id::LocalDefId;\n+use std::hash::Hash;\n \n /// Represents the levels of effective visibility an item can have.\n ///\n@@ -74,9 +76,9 @@ impl EffectiveVisibility {\n }\n \n /// Holds a map of effective visibilities for reachable HIR nodes.\n-#[derive(Default, Clone, Debug)]\n-pub struct EffectiveVisibilities {\n-    map: FxHashMap<LocalDefId, EffectiveVisibility>,\n+#[derive(Clone, Debug)]\n+pub struct EffectiveVisibilities<Id = LocalDefId> {\n+    map: FxHashMap<Id, EffectiveVisibility>,\n }\n \n impl EffectiveVisibilities {\n@@ -111,12 +113,30 @@ impl EffectiveVisibilities {\n         })\n     }\n \n-    pub fn effective_vis(&self, id: LocalDefId) -> Option<&EffectiveVisibility> {\n-        self.map.get(&id)\n-    }\n-\n-    pub fn iter(&self) -> impl Iterator<Item = (&LocalDefId, &EffectiveVisibility)> {\n-        self.map.iter()\n+    // FIXME: Share code with `fn update`.\n+    pub fn update_eff_vis(\n+        &mut self,\n+        def_id: LocalDefId,\n+        eff_vis: &EffectiveVisibility,\n+        tree: impl DefIdTree,\n+    ) {\n+        use std::collections::hash_map::Entry;\n+        match self.map.entry(def_id) {\n+            Entry::Occupied(mut occupied) => {\n+                let old_eff_vis = occupied.get_mut();\n+                for l in Level::all_levels() {\n+                    let vis_at_level = eff_vis.at_level(l);\n+                    let old_vis_at_level = old_eff_vis.at_level_mut(l);\n+                    if vis_at_level != old_vis_at_level\n+                        && vis_at_level.is_at_least(*old_vis_at_level, tree)\n+                    {\n+                        *old_vis_at_level = *vis_at_level\n+                    }\n+                }\n+                old_eff_vis\n+            }\n+            Entry::Vacant(vacant) => vacant.insert(*eff_vis),\n+        };\n     }\n \n     pub fn set_public_at_level(\n@@ -137,26 +157,82 @@ impl EffectiveVisibilities {\n         self.map.insert(id, effective_vis);\n     }\n \n+    pub fn check_invariants(&self, tcx: TyCtxt<'_>, early: bool) {\n+        if !cfg!(debug_assertions) {\n+            return;\n+        }\n+        for (&def_id, ev) in &self.map {\n+            // More direct visibility levels can never go farther than less direct ones,\n+            // neither of effective visibilities can go farther than nominal visibility,\n+            // and all effective visibilities are larger or equal than private visibility.\n+            let private_vis = Visibility::Restricted(tcx.parent_module_from_def_id(def_id));\n+            let span = tcx.def_span(def_id.to_def_id());\n+            if !ev.direct.is_at_least(private_vis, tcx) {\n+                span_bug!(span, \"private {:?} > direct {:?}\", private_vis, ev.direct);\n+            }\n+            if !ev.reexported.is_at_least(ev.direct, tcx) {\n+                span_bug!(span, \"direct {:?} > reexported {:?}\", ev.direct, ev.reexported);\n+            }\n+            if !ev.reachable.is_at_least(ev.reexported, tcx) {\n+                span_bug!(span, \"reexported {:?} > reachable {:?}\", ev.reexported, ev.reachable);\n+            }\n+            if !ev.reachable_through_impl_trait.is_at_least(ev.reachable, tcx) {\n+                span_bug!(\n+                    span,\n+                    \"reachable {:?} > reachable_through_impl_trait {:?}\",\n+                    ev.reachable,\n+                    ev.reachable_through_impl_trait\n+                );\n+            }\n+            let nominal_vis = tcx.visibility(def_id);\n+            let def_kind = tcx.opt_def_kind(def_id);\n+            // FIXME: `rustc_privacy` is not yet updated for the new logic and can set\n+            // effective visibilities that are larger than the nominal one.\n+            if !nominal_vis.is_at_least(ev.reachable_through_impl_trait, tcx) && early {\n+                span_bug!(\n+                    span,\n+                    \"{:?}: reachable_through_impl_trait {:?} > nominal {:?}\",\n+                    def_id,\n+                    ev.reachable_through_impl_trait,\n+                    nominal_vis\n+                );\n+            }\n+            // Fully private items are never put into the table, this is important for performance.\n+            // FIXME: Fully private `mod` items are currently put into the table.\n+            if ev.reachable_through_impl_trait == private_vis && def_kind != Some(DefKind::Mod) {\n+                span_bug!(span, \"fully private item in the table {:?}: {:?}\", def_id, ev.direct);\n+            }\n+        }\n+    }\n+}\n+\n+impl<Id: Eq + Hash> EffectiveVisibilities<Id> {\n+    pub fn iter(&self) -> impl Iterator<Item = (&Id, &EffectiveVisibility)> {\n+        self.map.iter()\n+    }\n+\n+    pub fn effective_vis(&self, id: Id) -> Option<&EffectiveVisibility> {\n+        self.map.get(&id)\n+    }\n+\n     // `parent_id` is not necessarily a parent in source code tree,\n     // it is the node from which the maximum effective visibility is inherited.\n     pub fn update(\n         &mut self,\n-        id: LocalDefId,\n+        id: Id,\n         nominal_vis: Visibility,\n-        default_vis: impl FnOnce() -> Visibility,\n-        parent_id: LocalDefId,\n+        default_vis: Visibility,\n+        inherited_eff_vis: Option<EffectiveVisibility>,\n         level: Level,\n         tree: impl DefIdTree,\n     ) -> bool {\n         let mut changed = false;\n-        let mut current_effective_vis = self.effective_vis(id).copied().unwrap_or_else(|| {\n-            if id.is_top_level_module() {\n-                EffectiveVisibility::from_vis(Visibility::Public)\n-            } else {\n-                EffectiveVisibility::from_vis(default_vis())\n-            }\n-        });\n-        if let Some(inherited_effective_vis) = self.effective_vis(parent_id) {\n+        let mut current_effective_vis = self\n+            .map\n+            .get(&id)\n+            .copied()\n+            .unwrap_or_else(|| EffectiveVisibility::from_vis(default_vis));\n+        if let Some(inherited_effective_vis) = inherited_eff_vis {\n             let mut inherited_effective_vis_at_prev_level =\n                 *inherited_effective_vis.at_level(level);\n             let mut calculated_effective_vis = inherited_effective_vis_at_prev_level;\n@@ -194,6 +270,12 @@ impl EffectiveVisibilities {\n     }\n }\n \n+impl<Id> Default for EffectiveVisibilities<Id> {\n+    fn default() -> Self {\n+        EffectiveVisibilities { map: Default::default() }\n+    }\n+}\n+\n impl<'a> HashStable<StableHashingContext<'a>> for EffectiveVisibilities {\n     fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         let EffectiveVisibilities { ref map } = *self;"}, {"sha": "e17f85c1aae0f14920eb49f14b32ecaa3bbfb281", "filename": "compiler/rustc_privacy/src/lib.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c5842b0be783dffa5a49693541acb79115c7eeef/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5842b0be783dffa5a49693541acb79115c7eeef/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_privacy%2Fsrc%2Flib.rs?ref=c5842b0be783dffa5a49693541acb79115c7eeef", "patch": "@@ -959,13 +959,21 @@ impl<'tcx, 'a> Visitor<'tcx> for TestReachabilityVisitor<'tcx, 'a> {\n                 for variant in def.variants.iter() {\n                     let variant_id = self.tcx.hir().local_def_id(variant.id);\n                     self.effective_visibility_diagnostic(variant_id);\n+                    if let Some(ctor_hir_id) = variant.data.ctor_hir_id() {\n+                        let ctor_def_id = self.tcx.hir().local_def_id(ctor_hir_id);\n+                        self.effective_visibility_diagnostic(ctor_def_id);\n+                    }\n                     for field in variant.data.fields() {\n                         let def_id = self.tcx.hir().local_def_id(field.hir_id);\n                         self.effective_visibility_diagnostic(def_id);\n                     }\n                 }\n             }\n             hir::ItemKind::Struct(ref def, _) | hir::ItemKind::Union(ref def, _) => {\n+                if let Some(ctor_hir_id) = def.ctor_hir_id() {\n+                    let ctor_def_id = self.tcx.hir().local_def_id(ctor_hir_id);\n+                    self.effective_visibility_diagnostic(ctor_def_id);\n+                }\n                 for field in def.fields() {\n                     let def_id = self.tcx.hir().local_def_id(field.hir_id);\n                     self.effective_visibility_diagnostic(def_id);\n@@ -2131,6 +2139,7 @@ fn effective_visibilities(tcx: TyCtxt<'_>, (): ()) -> &EffectiveVisibilities {\n         changed: false,\n     };\n \n+    visitor.effective_visibilities.check_invariants(tcx, true);\n     loop {\n         tcx.hir().walk_toplevel_module(&mut visitor);\n         if visitor.changed {\n@@ -2139,6 +2148,7 @@ fn effective_visibilities(tcx: TyCtxt<'_>, (): ()) -> &EffectiveVisibilities {\n             break;\n         }\n     }\n+    visitor.effective_visibilities.check_invariants(tcx, false);\n \n     let mut check_visitor =\n         TestReachabilityVisitor { tcx, effective_visibilities: &visitor.effective_visibilities };"}, {"sha": "fa6d34be0cc37c00a794031984ab513bb54d67f0", "filename": "compiler/rustc_resolve/src/effective_visibilities.rs", "status": "modified", "additions": 131, "deletions": 91, "changes": 222, "blob_url": "https://github.com/rust-lang/rust/blob/c5842b0be783dffa5a49693541acb79115c7eeef/compiler%2Frustc_resolve%2Fsrc%2Feffective_visibilities.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5842b0be783dffa5a49693541acb79115c7eeef/compiler%2Frustc_resolve%2Fsrc%2Feffective_visibilities.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Feffective_visibilities.rs?ref=c5842b0be783dffa5a49693541acb79115c7eeef", "patch": "@@ -1,16 +1,38 @@\n-use crate::{ImportKind, NameBindingKind, Resolver};\n+use crate::{ImportKind, NameBinding, NameBindingKind, Resolver, ResolverTree};\n use rustc_ast::ast;\n use rustc_ast::visit;\n use rustc_ast::visit::Visitor;\n use rustc_ast::Crate;\n use rustc_ast::EnumDef;\n+use rustc_data_structures::intern::Interned;\n use rustc_hir::def_id::LocalDefId;\n use rustc_hir::def_id::CRATE_DEF_ID;\n-use rustc_middle::middle::privacy::Level;\n-use rustc_middle::ty::{DefIdTree, Visibility};\n+use rustc_middle::middle::privacy::{EffectiveVisibilities, EffectiveVisibility, Level};\n+use rustc_middle::ty::Visibility;\n+\n+type ImportId<'a> = Interned<'a, NameBinding<'a>>;\n+\n+#[derive(Clone, Copy)]\n+enum ParentId<'a> {\n+    Def(LocalDefId),\n+    Import(ImportId<'a>),\n+}\n+\n+impl ParentId<'_> {\n+    fn level(self) -> Level {\n+        match self {\n+            ParentId::Def(_) => Level::Direct,\n+            ParentId::Import(_) => Level::Reexported,\n+        }\n+    }\n+}\n \n pub struct EffectiveVisibilitiesVisitor<'r, 'a> {\n     r: &'r mut Resolver<'a>,\n+    /// While walking import chains we need to track effective visibilities per-binding, and def id\n+    /// keys in `Resolver::effective_visibilities` are not enough for that, because multiple\n+    /// bindings can correspond to a single def id in imports. So we keep a separate table.\n+    import_effective_visibilities: EffectiveVisibilities<ImportId<'a>>,\n     changed: bool,\n }\n \n@@ -19,21 +41,57 @@ impl<'r, 'a> EffectiveVisibilitiesVisitor<'r, 'a> {\n     /// For now, this doesn't resolve macros (FIXME) and cannot resolve Impl, as we\n     /// need access to a TyCtxt for that.\n     pub fn compute_effective_visibilities<'c>(r: &'r mut Resolver<'a>, krate: &'c Crate) {\n-        let mut visitor = EffectiveVisibilitiesVisitor { r, changed: false };\n+        let mut visitor = EffectiveVisibilitiesVisitor {\n+            r,\n+            import_effective_visibilities: Default::default(),\n+            changed: false,\n+        };\n \n-        visitor.update(CRATE_DEF_ID, Visibility::Public, CRATE_DEF_ID, Level::Direct);\n+        visitor.update(CRATE_DEF_ID, CRATE_DEF_ID);\n         visitor.set_bindings_effective_visibilities(CRATE_DEF_ID);\n \n         while visitor.changed {\n-            visitor.reset();\n+            visitor.changed = false;\n             visit::walk_crate(&mut visitor, krate);\n         }\n \n+        // Update visibilities for import def ids. These are not used during the\n+        // `EffectiveVisibilitiesVisitor` pass, because we have more detailed binding-based\n+        // information, but are used by later passes. Effective visibility of an import def id\n+        // is the maximum value among visibilities of bindings corresponding to that def id.\n+        for (binding, eff_vis) in visitor.import_effective_visibilities.iter() {\n+            let NameBindingKind::Import { import, .. } = binding.kind else { unreachable!() };\n+            if let Some(node_id) = import.id() {\n+                let mut update = |node_id| {\n+                    r.effective_visibilities.update_eff_vis(\n+                        r.local_def_id(node_id),\n+                        eff_vis,\n+                        ResolverTree(&r.definitions, &r.crate_loader),\n+                    )\n+                };\n+                update(node_id);\n+                if let ImportKind::Single { additional_ids: (id1, id2), .. } = import.kind {\n+                    // In theory all the single import IDs have individual visibilities and\n+                    // effective visibilities, but in practice these IDs go straigth to HIR\n+                    // where all their few uses assume that their (effective) visibility\n+                    // applies to the whole syntactic `use` item. So they all get the same\n+                    // value which is the maximum of all bindings. Maybe HIR for imports\n+                    // shouldn't use three IDs at all.\n+                    if id1 != ast::DUMMY_NODE_ID {\n+                        update(id1);\n+                    }\n+                    if id2 != ast::DUMMY_NODE_ID {\n+                        update(id2);\n+                    }\n+                }\n+            }\n+        }\n+\n         info!(\"resolve::effective_visibilities: {:#?}\", r.effective_visibilities);\n     }\n \n-    fn reset(&mut self) {\n-        self.changed = false;\n+    fn nearest_normal_mod(&mut self, def_id: LocalDefId) -> LocalDefId {\n+        self.r.get_nearest_non_block_module(def_id.to_def_id()).nearest_parent_mod().expect_local()\n     }\n \n     /// Update effective visibilities of bindings in the given module,\n@@ -48,92 +106,83 @@ impl<'r, 'a> EffectiveVisibilitiesVisitor<'r, 'a> {\n                 // Set the given effective visibility level to `Level::Direct` and\n                 // sets the rest of the `use` chain to `Level::Reexported` until\n                 // we hit the actual exported item.\n+                let mut parent_id = ParentId::Def(module_id);\n+                while let NameBindingKind::Import { binding: nested_binding, .. } = binding.kind {\n+                    let binding_id = ImportId::new_unchecked(binding);\n+                    self.update_import(binding_id, parent_id);\n \n-                // FIXME: tag and is_public() condition should be removed, but assertions occur.\n-                let tag = if binding.is_import() { Level::Reexported } else { Level::Direct };\n-                if binding.vis.is_public() {\n-                    let mut prev_parent_id = module_id;\n-                    let mut level = Level::Direct;\n-                    while let NameBindingKind::Import { binding: nested_binding, import, .. } =\n-                        binding.kind\n-                    {\n-                        let mut update = |node_id| {\n-                            self.update(\n-                                self.r.local_def_id(node_id),\n-                                binding.vis.expect_local(),\n-                                prev_parent_id,\n-                                level,\n-                            )\n-                        };\n-                        match import.kind {\n-                            ImportKind::Single { id, additional_ids, .. } => {\n-                                // In theory all the import IDs have individual visibilities and\n-                                // effective visibilities, but in practice these IDs go straigth to\n-                                // HIR where all their few uses assume that their (effective)\n-                                // visibility applies to the whole syntactic `use` item. So we\n-                                // update them all to the maximum value among the potential\n-                                // individual effective visibilities. Maybe HIR for imports\n-                                // shouldn't use three IDs at all.\n-                                update(id);\n-                                update(additional_ids.0);\n-                                update(additional_ids.1);\n-                                prev_parent_id = self.r.local_def_id(id);\n-                            }\n-                            ImportKind::Glob { id, .. } | ImportKind::ExternCrate { id, .. } => {\n-                                update(id);\n-                                prev_parent_id = self.r.local_def_id(id);\n-                            }\n-                            ImportKind::MacroUse => {\n-                                // In theory we should reset the parent id to something private\n-                                // here, but `macro_use` imports always refer to external items,\n-                                // so it doesn't matter and we can just do nothing.\n-                            }\n-                            ImportKind::MacroExport => {\n-                                // In theory we should reset the parent id to something public\n-                                // here, but it has the same effect as leaving the previous parent,\n-                                // so we can just do nothing.\n-                            }\n-                        }\n-\n-                        level = Level::Reexported;\n-                        binding = nested_binding;\n-                    }\n+                    parent_id = ParentId::Import(binding_id);\n+                    binding = nested_binding;\n                 }\n \n                 if let Some(def_id) = binding.res().opt_def_id().and_then(|id| id.as_local()) {\n-                    self.update(def_id, binding.vis.expect_local(), module_id, tag);\n+                    self.update_def(def_id, binding.vis.expect_local(), parent_id);\n                 }\n             }\n         }\n     }\n \n-    fn update(\n-        &mut self,\n-        def_id: LocalDefId,\n+    fn effective_vis(&self, parent_id: ParentId<'a>) -> Option<EffectiveVisibility> {\n+        match parent_id {\n+            ParentId::Def(def_id) => self.r.effective_visibilities.effective_vis(def_id),\n+            ParentId::Import(binding) => self.import_effective_visibilities.effective_vis(binding),\n+        }\n+        .copied()\n+    }\n+\n+    /// The update is guaranteed to not change the table and we can skip it.\n+    fn is_noop_update(\n+        &self,\n+        parent_id: ParentId<'a>,\n         nominal_vis: Visibility,\n-        parent_id: LocalDefId,\n-        tag: Level,\n-    ) {\n-        let module_id = self\n-            .r\n-            .get_nearest_non_block_module(def_id.to_def_id())\n-            .nearest_parent_mod()\n-            .expect_local();\n-        if nominal_vis == Visibility::Restricted(module_id)\n-            || self.r.visibilities[&parent_id] == Visibility::Restricted(module_id)\n-        {\n+        default_vis: Visibility,\n+    ) -> bool {\n+        nominal_vis == default_vis\n+            || match parent_id {\n+                ParentId::Def(def_id) => self.r.visibilities[&def_id],\n+                ParentId::Import(binding) => binding.vis.expect_local(),\n+            } == default_vis\n+    }\n+\n+    fn update_import(&mut self, binding: ImportId<'a>, parent_id: ParentId<'a>) {\n+        let NameBindingKind::Import { import, .. } = binding.kind else { unreachable!() };\n+        let nominal_vis = binding.vis.expect_local();\n+        let default_vis = Visibility::Restricted(\n+            import\n+                .id()\n+                .map(|id| self.nearest_normal_mod(self.r.local_def_id(id)))\n+                .unwrap_or(CRATE_DEF_ID),\n+        );\n+        if self.is_noop_update(parent_id, nominal_vis, default_vis) {\n             return;\n         }\n-        let mut effective_visibilities = std::mem::take(&mut self.r.effective_visibilities);\n-        self.changed |= effective_visibilities.update(\n+        self.changed |= self.import_effective_visibilities.update(\n+            binding,\n+            nominal_vis,\n+            default_vis,\n+            self.effective_vis(parent_id),\n+            parent_id.level(),\n+            ResolverTree(&self.r.definitions, &self.r.crate_loader),\n+        );\n+    }\n+\n+    fn update_def(&mut self, def_id: LocalDefId, nominal_vis: Visibility, parent_id: ParentId<'a>) {\n+        let default_vis = Visibility::Restricted(self.nearest_normal_mod(def_id));\n+        if self.is_noop_update(parent_id, nominal_vis, default_vis) {\n+            return;\n+        }\n+        self.changed |= self.r.effective_visibilities.update(\n             def_id,\n             nominal_vis,\n-            || Visibility::Restricted(module_id),\n-            parent_id,\n-            tag,\n-            &*self.r,\n+            if def_id == CRATE_DEF_ID { Visibility::Public } else { default_vis },\n+            self.effective_vis(parent_id),\n+            parent_id.level(),\n+            ResolverTree(&self.r.definitions, &self.r.crate_loader),\n         );\n-        self.r.effective_visibilities = effective_visibilities;\n+    }\n+\n+    fn update(&mut self, def_id: LocalDefId, parent_id: LocalDefId) {\n+        self.update_def(def_id, self.r.visibilities[&def_id], ParentId::Def(parent_id));\n     }\n }\n \n@@ -151,12 +200,6 @@ impl<'r, 'ast> Visitor<'ast> for EffectiveVisibilitiesVisitor<'ast, 'r> {\n                 \"ast::ItemKind::MacCall encountered, this should not anymore appear at this stage\"\n             ),\n \n-            // Foreign modules inherit level from parents.\n-            ast::ItemKind::ForeignMod(..) => {\n-                let parent_id = self.r.local_parent(def_id);\n-                self.update(def_id, Visibility::Public, parent_id, Level::Direct);\n-            }\n-\n             ast::ItemKind::Mod(..) => {\n                 self.set_bindings_effective_visibilities(def_id);\n                 visit::walk_item(self, item);\n@@ -167,18 +210,14 @@ impl<'r, 'ast> Visitor<'ast> for EffectiveVisibilitiesVisitor<'ast, 'r> {\n                 for variant in variants {\n                     let variant_def_id = self.r.local_def_id(variant.id);\n                     for field in variant.data.fields() {\n-                        let field_def_id = self.r.local_def_id(field.id);\n-                        let vis = self.r.visibilities[&field_def_id];\n-                        self.update(field_def_id, vis, variant_def_id, Level::Direct);\n+                        self.update(self.r.local_def_id(field.id), variant_def_id);\n                     }\n                 }\n             }\n \n             ast::ItemKind::Struct(ref def, _) | ast::ItemKind::Union(ref def, _) => {\n                 for field in def.fields() {\n-                    let field_def_id = self.r.local_def_id(field.id);\n-                    let vis = self.r.visibilities[&field_def_id];\n-                    self.update(field_def_id, vis, def_id, Level::Direct);\n+                    self.update(self.r.local_def_id(field.id), def_id);\n                 }\n             }\n \n@@ -194,6 +233,7 @@ impl<'r, 'ast> Visitor<'ast> for EffectiveVisibilitiesVisitor<'ast, 'r> {\n             | ast::ItemKind::TyAlias(..)\n             | ast::ItemKind::TraitAlias(..)\n             | ast::ItemKind::MacroDef(..)\n+            | ast::ItemKind::ForeignMod(..)\n             | ast::ItemKind::Fn(..) => return,\n         }\n     }"}, {"sha": "a1ff477c6fefbf99859477c43bc3181b61559fc2", "filename": "compiler/rustc_resolve/src/lib.rs", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/c5842b0be783dffa5a49693541acb79115c7eeef/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5842b0be783dffa5a49693541acb79115c7eeef/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flib.rs?ref=c5842b0be783dffa5a49693541acb79115c7eeef", "patch": "@@ -1106,17 +1106,30 @@ impl<'a> AsMut<Resolver<'a>> for Resolver<'a> {\n     }\n }\n \n-impl<'a, 'b> DefIdTree for &'a Resolver<'b> {\n+/// A minimal subset of resolver that can implemenent `DefIdTree`, sometimes\n+/// required to satisfy borrow checker by avoiding borrowing the whole resolver.\n+#[derive(Clone, Copy)]\n+struct ResolverTree<'a, 'b>(&'a Definitions, &'a CrateLoader<'b>);\n+\n+impl DefIdTree for ResolverTree<'_, '_> {\n     #[inline]\n     fn opt_parent(self, id: DefId) -> Option<DefId> {\n+        let ResolverTree(definitions, crate_loader) = self;\n         match id.as_local() {\n-            Some(id) => self.definitions.def_key(id).parent,\n-            None => self.cstore().def_key(id).parent,\n+            Some(id) => definitions.def_key(id).parent,\n+            None => crate_loader.cstore().def_key(id).parent,\n         }\n         .map(|index| DefId { index, ..id })\n     }\n }\n \n+impl<'a, 'b> DefIdTree for &'a Resolver<'b> {\n+    #[inline]\n+    fn opt_parent(self, id: DefId) -> Option<DefId> {\n+        ResolverTree(&self.definitions, &self.crate_loader).opt_parent(id)\n+    }\n+}\n+\n impl Resolver<'_> {\n     fn opt_local_def_id(&self, node: NodeId) -> Option<LocalDefId> {\n         self.node_id_to_def_id.get(&node).copied()"}, {"sha": "4479b0d8f61baf5bd75f911c9e8e8ddb5390006e", "filename": "src/test/ui/privacy/effective_visibilities.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c5842b0be783dffa5a49693541acb79115c7eeef/src%2Ftest%2Fui%2Fprivacy%2Feffective_visibilities.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5842b0be783dffa5a49693541acb79115c7eeef/src%2Ftest%2Fui%2Fprivacy%2Feffective_visibilities.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Feffective_visibilities.rs?ref=c5842b0be783dffa5a49693541acb79115c7eeef", "patch": "@@ -6,7 +6,7 @@ mod outer { //~ ERROR Direct: pub(crate), Reexported: pub(crate), Reachable: pub\n     pub mod inner1 { //~ ERROR Direct: pub(crate), Reexported: pub, Reachable: pub, ReachableThroughImplTrait: pub\n \n         #[rustc_effective_visibility]\n-        extern \"C\" {} //~ ERROR Direct: pub(crate), Reexported: pub, Reachable: pub, ReachableThroughImplTrait: pub\n+        extern \"C\" {} //~ ERROR not in the table\n \n         #[rustc_effective_visibility]\n         pub trait PubTrait { //~ ERROR Direct: pub(crate), Reexported: pub, Reachable: pub, ReachableThroughImplTrait: pub\n@@ -18,6 +18,7 @@ mod outer { //~ ERROR Direct: pub(crate), Reexported: pub(crate), Reachable: pub\n \n         #[rustc_effective_visibility]\n         struct PrivStruct; //~ ERROR not in the table\n+                           //~| ERROR not in the table\n \n         #[rustc_effective_visibility]\n         pub union PubUnion { //~ ERROR Direct: pub(crate), Reexported: pub, Reachable: pub, ReachableThroughImplTrait: pub\n@@ -31,6 +32,7 @@ mod outer { //~ ERROR Direct: pub(crate), Reexported: pub(crate), Reachable: pub\n         pub enum Enum { //~ ERROR Direct: pub(crate), Reexported: pub, Reachable: pub, ReachableThroughImplTrait: pub\n             #[rustc_effective_visibility]\n             A( //~ ERROR Direct: pub(crate), Reexported: pub, Reachable: pub, ReachableThroughImplTrait: pub\n+               //~| ERROR Direct: pub(crate), Reexported: pub, Reachable: pub, ReachableThroughImplTrait: pub\n                 #[rustc_effective_visibility]\n                 PubUnion,  //~ ERROR Direct: pub(crate), Reexported: pub, Reachable: pub, ReachableThroughImplTrait: pub\n             ),"}, {"sha": "019aaf8086a6a82d91f35dcee4a981c5aff8f2d6", "filename": "src/test/ui/privacy/effective_visibilities.stderr", "status": "modified", "additions": 29, "deletions": 17, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/c5842b0be783dffa5a49693541acb79115c7eeef/src%2Ftest%2Fui%2Fprivacy%2Feffective_visibilities.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c5842b0be783dffa5a49693541acb79115c7eeef/src%2Ftest%2Fui%2Fprivacy%2Feffective_visibilities.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Feffective_visibilities.stderr?ref=c5842b0be783dffa5a49693541acb79115c7eeef", "patch": "@@ -10,7 +10,7 @@ error: Direct: pub(crate), Reexported: pub, Reachable: pub, ReachableThroughImpl\n LL |     pub mod inner1 {\n    |     ^^^^^^^^^^^^^^\n \n-error: Direct: pub(crate), Reexported: pub, Reachable: pub, ReachableThroughImplTrait: pub\n+error: not in the table\n   --> $DIR/effective_visibilities.rs:9:9\n    |\n LL |         extern \"C\" {}\n@@ -28,92 +28,104 @@ error: not in the table\n LL |         struct PrivStruct;\n    |         ^^^^^^^^^^^^^^^^^\n \n+error: not in the table\n+  --> $DIR/effective_visibilities.rs:20:9\n+   |\n+LL |         struct PrivStruct;\n+   |         ^^^^^^^^^^^^^^^^^\n+\n error: Direct: pub(crate), Reexported: pub, Reachable: pub, ReachableThroughImplTrait: pub\n-  --> $DIR/effective_visibilities.rs:23:9\n+  --> $DIR/effective_visibilities.rs:24:9\n    |\n LL |         pub union PubUnion {\n    |         ^^^^^^^^^^^^^^^^^^\n \n error: not in the table\n-  --> $DIR/effective_visibilities.rs:25:13\n+  --> $DIR/effective_visibilities.rs:26:13\n    |\n LL |             a: u8,\n    |             ^^^^^\n \n error: Direct: pub(crate), Reexported: pub, Reachable: pub, ReachableThroughImplTrait: pub\n-  --> $DIR/effective_visibilities.rs:27:13\n+  --> $DIR/effective_visibilities.rs:28:13\n    |\n LL |             pub b: u8,\n    |             ^^^^^^^^^\n \n error: Direct: pub(crate), Reexported: pub, Reachable: pub, ReachableThroughImplTrait: pub\n-  --> $DIR/effective_visibilities.rs:31:9\n+  --> $DIR/effective_visibilities.rs:32:9\n    |\n LL |         pub enum Enum {\n    |         ^^^^^^^^^^^^^\n \n error: Direct: pub(crate), Reexported: pub, Reachable: pub, ReachableThroughImplTrait: pub\n-  --> $DIR/effective_visibilities.rs:33:13\n+  --> $DIR/effective_visibilities.rs:34:13\n+   |\n+LL |             A(\n+   |             ^\n+\n+error: Direct: pub(crate), Reexported: pub, Reachable: pub, ReachableThroughImplTrait: pub\n+  --> $DIR/effective_visibilities.rs:34:13\n    |\n LL |             A(\n    |             ^\n \n error: Direct: pub(crate), Reexported: pub, Reachable: pub, ReachableThroughImplTrait: pub\n-  --> $DIR/effective_visibilities.rs:35:17\n+  --> $DIR/effective_visibilities.rs:37:17\n    |\n LL |                 PubUnion,\n    |                 ^^^^^^^^\n \n error: not in the table\n-  --> $DIR/effective_visibilities.rs:41:5\n+  --> $DIR/effective_visibilities.rs:43:5\n    |\n LL |     macro_rules! none_macro {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^\n \n error: Direct: pub(self), Reexported: pub, Reachable: pub, ReachableThroughImplTrait: pub\n-  --> $DIR/effective_visibilities.rs:47:5\n+  --> $DIR/effective_visibilities.rs:49:5\n    |\n LL |     macro_rules! public_macro {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: Direct: pub(crate), Reexported: pub(crate), Reachable: pub, ReachableThroughImplTrait: pub\n-  --> $DIR/effective_visibilities.rs:52:5\n+  --> $DIR/effective_visibilities.rs:54:5\n    |\n LL |     pub struct ReachableStruct {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: Direct: pub(crate), Reexported: pub(crate), Reachable: pub, ReachableThroughImplTrait: pub\n-  --> $DIR/effective_visibilities.rs:54:9\n+  --> $DIR/effective_visibilities.rs:56:9\n    |\n LL |         pub a: u8,\n    |         ^^^^^^^^^\n \n error: Direct: pub, Reexported: pub, Reachable: pub, ReachableThroughImplTrait: pub\n-  --> $DIR/effective_visibilities.rs:59:9\n+  --> $DIR/effective_visibilities.rs:61:9\n    |\n LL | pub use outer::inner1;\n    |         ^^^^^^^^^^^^^\n \n error: Direct: pub(crate), Reexported: pub, Reachable: pub, ReachableThroughImplTrait: pub\n-  --> $DIR/effective_visibilities.rs:65:5\n+  --> $DIR/effective_visibilities.rs:67:5\n    |\n LL |     pub type HalfPublicImport = u8;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: Direct: pub(crate), Reexported: pub(crate), Reachable: pub(crate), ReachableThroughImplTrait: pub(crate)\n-  --> $DIR/effective_visibilities.rs:68:5\n+  --> $DIR/effective_visibilities.rs:70:5\n    |\n LL |     pub(crate) const HalfPublicImport: u8 = 0;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: Direct: pub, Reexported: pub, Reachable: pub, ReachableThroughImplTrait: pub\n-  --> $DIR/effective_visibilities.rs:72:9\n+  --> $DIR/effective_visibilities.rs:74:9\n    |\n LL | pub use half_public_import::HalfPublicImport;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: Direct: pub, Reexported: pub, Reachable: pub, ReachableThroughImplTrait: pub\n-  --> $DIR/effective_visibilities.rs:72:9\n+  --> $DIR/effective_visibilities.rs:74:9\n    |\n LL | pub use half_public_import::HalfPublicImport;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -130,5 +142,5 @@ error: Direct: pub(crate), Reexported: pub, Reachable: pub, ReachableThroughImpl\n LL |             type B;\n    |             ^^^^^^\n \n-error: aborting due to 22 previous errors\n+error: aborting due to 24 previous errors\n "}, {"sha": "eb9dcd6cd1fa4cecdc32f1baaa907bbee7487294", "filename": "src/test/ui/privacy/effective_visibilities_glob.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/c5842b0be783dffa5a49693541acb79115c7eeef/src%2Ftest%2Fui%2Fprivacy%2Feffective_visibilities_glob.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5842b0be783dffa5a49693541acb79115c7eeef/src%2Ftest%2Fui%2Fprivacy%2Feffective_visibilities_glob.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Feffective_visibilities_glob.rs?ref=c5842b0be783dffa5a49693541acb79115c7eeef", "patch": "@@ -0,0 +1,21 @@\n+// Effective visibility tracking for imports is fine-grained, so `S2` is not fully exported\n+// even if its parent import (`m::*`) is fully exported as a `use` item.\n+\n+#![feature(rustc_attrs)]\n+\n+mod m {\n+    #[rustc_effective_visibility]\n+    pub struct S1 {} //~ ERROR Direct: pub(crate), Reexported: pub, Reachable: pub, ReachableThroughImplTrait: pub\n+    #[rustc_effective_visibility]\n+    pub struct S2 {} //~ ERROR Direct: pub(crate), Reexported: pub(crate), Reachable: pub(crate), ReachableThroughImplTrait: pub(crate)\n+}\n+\n+mod glob {\n+    #[rustc_effective_visibility]\n+    pub use crate::m::*; //~ ERROR Direct: pub(crate), Reexported: pub, Reachable: pub, ReachableThroughImplTrait: pub\n+}\n+\n+#[rustc_effective_visibility]\n+pub use glob::S1; //~ ERROR Direct: pub, Reexported: pub, Reachable: pub, ReachableThroughImplTrait: pub\n+\n+fn main() {}"}, {"sha": "0496cd5df8db01b0934cad4e3475129eba0fe598", "filename": "src/test/ui/privacy/effective_visibilities_glob.stderr", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/c5842b0be783dffa5a49693541acb79115c7eeef/src%2Ftest%2Fui%2Fprivacy%2Feffective_visibilities_glob.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c5842b0be783dffa5a49693541acb79115c7eeef/src%2Ftest%2Fui%2Fprivacy%2Feffective_visibilities_glob.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Feffective_visibilities_glob.stderr?ref=c5842b0be783dffa5a49693541acb79115c7eeef", "patch": "@@ -0,0 +1,26 @@\n+error: Direct: pub(crate), Reexported: pub, Reachable: pub, ReachableThroughImplTrait: pub\n+  --> $DIR/effective_visibilities_glob.rs:8:5\n+   |\n+LL |     pub struct S1 {}\n+   |     ^^^^^^^^^^^^^\n+\n+error: Direct: pub(crate), Reexported: pub(crate), Reachable: pub(crate), ReachableThroughImplTrait: pub(crate)\n+  --> $DIR/effective_visibilities_glob.rs:10:5\n+   |\n+LL |     pub struct S2 {}\n+   |     ^^^^^^^^^^^^^\n+\n+error: Direct: pub(crate), Reexported: pub, Reachable: pub, ReachableThroughImplTrait: pub\n+  --> $DIR/effective_visibilities_glob.rs:15:13\n+   |\n+LL |     pub use crate::m::*;\n+   |             ^^^^^^^^\n+\n+error: Direct: pub, Reexported: pub, Reachable: pub, ReachableThroughImplTrait: pub\n+  --> $DIR/effective_visibilities_glob.rs:19:9\n+   |\n+LL | pub use glob::S1;\n+   |         ^^^^^^^^\n+\n+error: aborting due to 4 previous errors\n+"}]}