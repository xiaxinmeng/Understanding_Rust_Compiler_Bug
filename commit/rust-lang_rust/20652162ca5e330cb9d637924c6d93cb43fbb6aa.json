{"sha": "20652162ca5e330cb9d637924c6d93cb43fbb6aa", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIwNjUyMTYyY2E1ZTMzMGNiOWQ2Mzc5MjRjNmQ5M2NiNDNmYmI2YWE=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-04-29T05:30:54Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-05-11T01:14:58Z"}, "message": "rustc: More interning for data used in Ty<'tcx>.", "tree": {"sha": "a448be3895c6865ba828471f76309e234479295c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a448be3895c6865ba828471f76309e234479295c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/20652162ca5e330cb9d637924c6d93cb43fbb6aa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/20652162ca5e330cb9d637924c6d93cb43fbb6aa", "html_url": "https://github.com/rust-lang/rust/commit/20652162ca5e330cb9d637924c6d93cb43fbb6aa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/20652162ca5e330cb9d637924c6d93cb43fbb6aa/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8f72d8127fd91911b80b8b8b9e0f51f6e001d748", "url": "https://api.github.com/repos/rust-lang/rust/commits/8f72d8127fd91911b80b8b8b9e0f51f6e001d748", "html_url": "https://github.com/rust-lang/rust/commit/8f72d8127fd91911b80b8b8b9e0f51f6e001d748"}], "stats": {"total": 729, "additions": 402, "deletions": 327}, "files": [{"sha": "fdb4c3500c6c1d4f5fc72559f6719fc23c271c05", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/20652162ca5e330cb9d637924c6d93cb43fbb6aa/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20652162ca5e330cb9d637924c6d93cb43fbb6aa/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=20652162ca5e330cb9d637924c6d93cb43fbb6aa", "patch": "@@ -1016,7 +1016,7 @@ pub fn drain_fulfillment_cx<T>(&self,\n     pub fn fresh_substs_for_generics(&self,\n                                      span: Span,\n                                      generics: &ty::Generics<'tcx>)\n-                                     -> subst::Substs<'tcx>\n+                                     -> &'tcx subst::Substs<'tcx>\n     {\n         let type_params = subst::VecPerParamSpace::empty();\n \n@@ -1034,7 +1034,7 @@ pub fn drain_fulfillment_cx<T>(&self,\n                 generics.types.get_slice(*space));\n         }\n \n-        return substs;\n+        self.tcx.mk_substs(substs)\n     }\n \n     /// Given a set of generics defined on a trait, returns a substitution mapping each output\n@@ -1533,7 +1533,7 @@ pub fn drain_fulfillment_cx<T>(&self,\n \n     pub fn closure_type(&self,\n                         def_id: DefId,\n-                        substs: &ty::ClosureSubsts<'tcx>)\n+                        substs: ty::ClosureSubsts<'tcx>)\n                         -> ty::ClosureTy<'tcx>\n     {\n         let closure_ty ="}, {"sha": "de38c51aabefa16390124bbddcc8f27f2559efac", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/20652162ca5e330cb9d637924c6d93cb43fbb6aa/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20652162ca5e330cb9d637924c6d93cb43fbb6aa/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=20652162ca5e330cb9d637924c6d93cb43fbb6aa", "patch": "@@ -1462,7 +1462,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n     fn fn_ret(&self, id: NodeId) -> ty::PolyFnOutput<'tcx> {\n         let fn_ty = self.ir.tcx.node_id_to_type(id);\n         match fn_ty.sty {\n-            ty::TyClosure(closure_def_id, ref substs) =>\n+            ty::TyClosure(closure_def_id, substs) =>\n                 self.ir.tcx.closure_type(closure_def_id, substs).sig.output(),\n             _ => fn_ty.fn_ret()\n         }"}, {"sha": "458cb28144adbced7573fad926b5568d1c70154e", "filename": "src/librustc/mir/repr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/20652162ca5e330cb9d637924c6d93cb43fbb6aa/src%2Flibrustc%2Fmir%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20652162ca5e330cb9d637924c6d93cb43fbb6aa/src%2Flibrustc%2Fmir%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Frepr.rs?ref=20652162ca5e330cb9d637924c6d93cb43fbb6aa", "patch": "@@ -816,7 +816,7 @@ pub enum AggregateKind<'tcx> {\n     Vec,\n     Tuple,\n     Adt(AdtDef<'tcx>, usize, &'tcx Substs<'tcx>),\n-    Closure(DefId, &'tcx ClosureSubsts<'tcx>),\n+    Closure(DefId, ClosureSubsts<'tcx>),\n }\n \n #[derive(Copy, Clone, Debug, PartialEq, Eq, RustcEncodable, RustcDecodable)]"}, {"sha": "7041945a873005019d32f8229dd64051901e6e0d", "filename": "src/librustc/mir/tcx.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/20652162ca5e330cb9d637924c6d93cb43fbb6aa/src%2Flibrustc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20652162ca5e330cb9d637924c6d93cb43fbb6aa/src%2Flibrustc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftcx.rs?ref=20652162ca5e330cb9d637924c6d93cb43fbb6aa", "patch": "@@ -82,10 +82,9 @@ impl<'tcx> TypeFoldable<'tcx> for LvalueTy<'tcx> {\n         match *self {\n             LvalueTy::Ty { ty } => LvalueTy::Ty { ty: ty.fold_with(folder) },\n             LvalueTy::Downcast { adt_def, substs, variant_index } => {\n-                let substs = substs.fold_with(folder);\n                 LvalueTy::Downcast {\n                     adt_def: adt_def,\n-                    substs: folder.tcx().mk_substs(substs),\n+                    substs: substs.fold_with(folder),\n                     variant_index: variant_index\n                 }\n             }\n@@ -209,8 +208,7 @@ impl<'a, 'tcx> Mir<'tcx> {\n                         Some(def.type_scheme(tcx).ty.subst(tcx, substs))\n                     }\n                     AggregateKind::Closure(did, substs) => {\n-                        Some(tcx.mk_closure_from_closure_substs(\n-                            did, Box::new(substs.clone())))\n+                        Some(tcx.mk_closure_from_closure_substs(did, substs))\n                     }\n                 }\n             }"}, {"sha": "88460651352537357a6b7e0183110aa8a1e76681", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/20652162ca5e330cb9d637924c6d93cb43fbb6aa/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20652162ca5e330cb9d637924c6d93cb43fbb6aa/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=20652162ca5e330cb9d637924c6d93cb43fbb6aa", "patch": "@@ -197,7 +197,7 @@ macro_rules! make_mir_visitor {\n             }\n \n             fn visit_closure_substs(&mut self,\n-                                    substs: & $($mutability)* &'tcx ClosureSubsts<'tcx>) {\n+                                    substs: & $($mutability)* ClosureSubsts<'tcx>) {\n                 self.super_closure_substs(substs);\n             }\n \n@@ -681,7 +681,7 @@ macro_rules! make_mir_visitor {\n             }\n \n             fn super_closure_substs(&mut self,\n-                                    _substs: & $($mutability)* &'tcx ClosureSubsts<'tcx>) {\n+                                    _substs: & $($mutability)* ClosureSubsts<'tcx>) {\n             }\n \n             fn super_const_val(&mut self, _substs: & $($mutability)* ConstVal) {"}, {"sha": "4c338219ffbf7faa00fe8a70991e3d79a2b291fd", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/20652162ca5e330cb9d637924c6d93cb43fbb6aa/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20652162ca5e330cb9d637924c6d93cb43fbb6aa/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=20652162ca5e330cb9d637924c6d93cb43fbb6aa", "patch": "@@ -259,7 +259,7 @@ fn consider_unification_despite_ambiguity<'cx, 'gcx, 'tcx>(\n     debug!(\"consider_unification_despite_ambiguity: self_ty.sty={:?}\",\n            self_ty.sty);\n     match self_ty.sty {\n-        ty::TyClosure(closure_def_id, ref substs) => {\n+        ty::TyClosure(closure_def_id, substs) => {\n             let closure_typer = selcx.closure_typer();\n             let closure_type = closure_typer.closure_type(closure_def_id, substs);\n             let ty::Binder((_, ret_type)) =\n@@ -1021,7 +1021,7 @@ fn confirm_closure_candidate<'cx, 'gcx, 'tcx>(\n     -> (Ty<'tcx>, Vec<PredicateObligation<'tcx>>)\n {\n     let closure_typer = selcx.closure_typer();\n-    let closure_type = closure_typer.closure_type(vtable.closure_def_id, &vtable.substs);\n+    let closure_type = closure_typer.closure_type(vtable.closure_def_id, vtable.substs);\n     let Normalized {\n         value: closure_type,\n         mut obligations"}, {"sha": "7d9a256a6e080a19c525b6cef79071b06d1c29aa", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/20652162ca5e330cb9d637924c6d93cb43fbb6aa/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20652162ca5e330cb9d637924c6d93cb43fbb6aa/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=20652162ca5e330cb9d637924c6d93cb43fbb6aa", "patch": "@@ -197,7 +197,7 @@ enum SelectionCandidate<'tcx> {\n     /// Implementation of a `Fn`-family trait by one of the anonymous types\n     /// generated for a `||` expression. The ty::ClosureKind informs the\n     /// confirmation step what ClosureKind obligation to emit.\n-    ClosureCandidate(/* closure */ DefId, &'tcx ty::ClosureSubsts<'tcx>, ty::ClosureKind),\n+    ClosureCandidate(/* closure */ DefId, ty::ClosureSubsts<'tcx>, ty::ClosureKind),\n \n     /// Implementation of a `Fn`-family trait by one of the anonymous\n     /// types generated for a fn pointer type (e.g., `fn(int)->int`)\n@@ -1270,7 +1270,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         // type/region parameters\n         let self_ty = *obligation.self_ty().skip_binder();\n         let (closure_def_id, substs) = match self_ty.sty {\n-            ty::TyClosure(id, ref substs) => (id, substs),\n+            ty::TyClosure(id, substs) => (id, substs),\n             ty::TyInfer(ty::TyVar(_)) => {\n                 debug!(\"assemble_unboxed_closure_candidates: ambiguous self-type\");\n                 candidates.ambiguous = true;\n@@ -1707,16 +1707,16 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n \n             ty::TyStr | ty::TySlice(_) | ty::TyTrait(..) => Never,\n \n-            ty::TyTuple(ref tys) => {\n+            ty::TyTuple(tys) => {\n                 // FIXME(#33242) we only need to constrain the last field\n-                Where(ty::Binder(tys.clone()))\n+                Where(ty::Binder(tys.to_vec()))\n             }\n \n             ty::TyStruct(def, substs) | ty::TyEnum(def, substs) => {\n                 let sized_crit = def.sized_constraint(self.tcx());\n                 // (*) binder moved here\n                 Where(ty::Binder(match sized_crit.sty {\n-                    ty::TyTuple(ref tys) => tys.to_owned().subst(self.tcx(), substs),\n+                    ty::TyTuple(tys) => tys.to_vec().subst(self.tcx(), substs),\n                     ty::TyBool => vec![],\n                     _ => vec![sized_crit.subst(self.tcx(), substs)]\n                 }))\n@@ -1763,9 +1763,9 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 Where(ty::Binder(vec![element_ty]))\n             }\n \n-            ty::TyTuple(ref tys) => {\n+            ty::TyTuple(tys) => {\n                 // (*) binder moved here\n-                Where(ty::Binder(tys.clone()))\n+                Where(ty::Binder(tys.to_vec()))\n             }\n \n             ty::TyStruct(..) | ty::TyEnum(..) | ty::TyProjection(..) | ty::TyParam(..) => {\n@@ -1842,7 +1842,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n \n             ty::TyTuple(ref tys) => {\n                 // (T1, ..., Tn) -- meets any bound that all of T1...Tn meet\n-                tys.clone()\n+                tys.to_vec()\n             }\n \n             ty::TyClosure(_, ref substs) => {\n@@ -1854,7 +1854,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 // OIBIT interact? That is, there is no way to say\n                 // \"make me invariant with respect to this TYPE, but\n                 // do not act as though I can reach it\"\n-                substs.upvar_tys.clone()\n+                substs.upvar_tys.to_vec()\n             }\n \n             // for `PhantomData<T>`, we pass `T`\n@@ -2188,7 +2188,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n \n     fn vtable_impl(&mut self,\n                    impl_def_id: DefId,\n-                   mut substs: Normalized<'tcx, Substs<'tcx>>,\n+                   mut substs: Normalized<'tcx, &'tcx Substs<'tcx>>,\n                    cause: ObligationCause<'tcx>,\n                    recursion_depth: usize,\n                    skol_map: infer::SkolemizationMap,\n@@ -2221,7 +2221,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         impl_obligations.append(&mut substs.obligations);\n \n         VtableImplData { impl_def_id: impl_def_id,\n-                         substs: self.tcx().mk_substs(substs.value),\n+                         substs: substs.value,\n                          nested: impl_obligations }\n     }\n \n@@ -2311,7 +2311,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n     fn confirm_closure_candidate(&mut self,\n                                  obligation: &TraitObligation<'tcx>,\n                                  closure_def_id: DefId,\n-                                 substs: &ty::ClosureSubsts<'tcx>,\n+                                 substs: ty::ClosureSubsts<'tcx>,\n                                  kind: ty::ClosureKind)\n                                  -> Result<VtableClosureData<'tcx, PredicateObligation<'tcx>>,\n                                            SelectionError<'tcx>>\n@@ -2586,7 +2586,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                     impl_def_id: DefId,\n                     obligation: &TraitObligation<'tcx>,\n                     snapshot: &infer::CombinedSnapshot)\n-                    -> (Normalized<'tcx, Substs<'tcx>>, infer::SkolemizationMap)\n+                    -> (Normalized<'tcx, &'tcx Substs<'tcx>>, infer::SkolemizationMap)\n     {\n         match self.match_impl(impl_def_id, obligation, snapshot) {\n             Ok((substs, skol_map)) => (substs, skol_map),\n@@ -2602,7 +2602,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                   impl_def_id: DefId,\n                   obligation: &TraitObligation<'tcx>,\n                   snapshot: &infer::CombinedSnapshot)\n-                  -> Result<(Normalized<'tcx, Substs<'tcx>>,\n+                  -> Result<(Normalized<'tcx, &'tcx Substs<'tcx>>,\n                              infer::SkolemizationMap), ()>\n     {\n         let impl_trait_ref = self.tcx().impl_trait_ref(impl_def_id).unwrap();\n@@ -2752,7 +2752,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n     fn closure_trait_ref_unnormalized(&mut self,\n                                       obligation: &TraitObligation<'tcx>,\n                                       closure_def_id: DefId,\n-                                      substs: &ty::ClosureSubsts<'tcx>)\n+                                      substs: ty::ClosureSubsts<'tcx>)\n                                       -> ty::PolyTraitRef<'tcx>\n     {\n         let closure_type = self.infcx.closure_type(closure_def_id, substs);\n@@ -2773,7 +2773,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n     fn closure_trait_ref(&mut self,\n                          obligation: &TraitObligation<'tcx>,\n                          closure_def_id: DefId,\n-                         substs: &ty::ClosureSubsts<'tcx>)\n+                         substs: ty::ClosureSubsts<'tcx>)\n                          -> Normalized<'tcx, ty::PolyTraitRef<'tcx>>\n     {\n         let trait_ref = self.closure_trait_ref_unnormalized("}, {"sha": "9212c54eb7df5761d596470d9eb98990b81d2683", "filename": "src/librustc/traits/specialize/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/20652162ca5e330cb9d637924c6d93cb43fbb6aa/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20652162ca5e330cb9d637924c6d93cb43fbb6aa/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs?ref=20652162ca5e330cb9d637924c6d93cb43fbb6aa", "patch": "@@ -96,7 +96,7 @@ pub fn translate_substs<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n                       specializaiton failed to hold\")\n             })\n         }\n-        specialization_graph::Node::Trait(..) => source_trait_ref.substs.clone(),\n+        specialization_graph::Node::Trait(..) => source_trait_ref.substs,\n     };\n \n     // directly inherent the method generics, since those do not vary across impls\n@@ -171,7 +171,7 @@ pub fn specializes<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n fn fulfill_implication<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n                                        source_trait_ref: ty::TraitRef<'tcx>,\n                                        target_impl: DefId)\n-                                       -> Result<Substs<'tcx>, ()> {\n+                                       -> Result<&'tcx Substs<'tcx>, ()> {\n     infcx.commit_if_ok(|_| {\n         let selcx = &mut SelectionContext::new(&infcx);\n         let target_substs = fresh_type_vars_for_impl(&infcx, DUMMY_SP, target_impl);"}, {"sha": "8d3f7fab38f8c4b8e7fb224e01431c1c810b052c", "filename": "src/librustc/traits/structural_impls.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/20652162ca5e330cb9d637924c6d93cb43fbb6aa/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20652162ca5e330cb9d637924c6d93cb43fbb6aa/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs?ref=20652162ca5e330cb9d637924c6d93cb43fbb6aa", "patch": "@@ -173,10 +173,9 @@ impl<'tcx, O: TypeFoldable<'tcx>> TypeFoldable<'tcx> for traits::Obligation<'tcx\n \n impl<'tcx, N: TypeFoldable<'tcx>> TypeFoldable<'tcx> for traits::VtableImplData<'tcx, N> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        let substs = self.substs.fold_with(folder);\n         traits::VtableImplData {\n             impl_def_id: self.impl_def_id,\n-            substs: folder.tcx().mk_substs(substs),\n+            substs: self.substs.fold_with(folder),\n             nested: self.nested.fold_with(folder),\n         }\n     }"}, {"sha": "55fb8beee01b444a80440a879f9d235c7307f77b", "filename": "src/librustc/traits/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/20652162ca5e330cb9d637924c6d93cb43fbb6aa/src%2Flibrustc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20652162ca5e330cb9d637924c6d93cb43fbb6aa/src%2Flibrustc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Futil.rs?ref=20652162ca5e330cb9d637924c6d93cb43fbb6aa", "patch": "@@ -356,7 +356,7 @@ pub fn impl_trait_ref_and_oblig<'a, 'gcx, 'tcx>(selcx: &mut SelectionContext<'a,\n pub fn fresh_type_vars_for_impl<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n                                                 span: Span,\n                                                 impl_def_id: DefId)\n-                                                -> Substs<'tcx>\n+                                                -> &'tcx Substs<'tcx>\n {\n     let tcx = infcx.tcx;\n     let impl_generics = tcx.lookup_item_type(impl_def_id).generics;"}, {"sha": "71e49031347b8fcb4514070e1939e324e012be9a", "filename": "src/librustc/ty/adjustment.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/20652162ca5e330cb9d637924c6d93cb43fbb6aa/src%2Flibrustc%2Fty%2Fadjustment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20652162ca5e330cb9d637924c6d93cb43fbb6aa/src%2Flibrustc%2Fty%2Fadjustment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fadjustment.rs?ref=20652162ca5e330cb9d637924c6d93cb43fbb6aa", "patch": "@@ -156,9 +156,7 @@ impl<'a, 'gcx, 'tcx> ty::TyS<'tcx> {\n                 match *adjustment {\n                     AdjustReifyFnPointer => {\n                         match self.sty {\n-                            ty::TyFnDef(_, _, b) => {\n-                                tcx.mk_ty(ty::TyFnPtr(b))\n-                            }\n+                            ty::TyFnDef(_, _, f) => tcx.mk_fn_ptr(f),\n                             _ => {\n                                 bug!(\"AdjustReifyFnPointer adjustment on non-fn-item: {:?}\",\n                                      self);"}, {"sha": "a42d256dbc37f4db5819e9a2982ceca0bcaea39f", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 59, "deletions": 14, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/20652162ca5e330cb9d637924c6d93cb43fbb6aa/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20652162ca5e330cb9d637924c6d93cb43fbb6aa/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=20652162ca5e330cb9d637924c6d93cb43fbb6aa", "patch": "@@ -53,6 +53,7 @@ use hir;\n pub struct CtxtArenas<'tcx> {\n     // internings\n     type_: TypedArena<TyS<'tcx>>,\n+    type_list: TypedArena<Vec<Ty<'tcx>>>,\n     substs: TypedArena<Substs<'tcx>>,\n     bare_fn: TypedArena<BareFnTy<'tcx>>,\n     region: TypedArena<Region>,\n@@ -68,6 +69,7 @@ impl<'tcx> CtxtArenas<'tcx> {\n     pub fn new() -> CtxtArenas<'tcx> {\n         CtxtArenas {\n             type_: TypedArena::new(),\n+            type_list: TypedArena::new(),\n             substs: TypedArena::new(),\n             bare_fn: TypedArena::new(),\n             region: TypedArena::new(),\n@@ -87,6 +89,7 @@ struct CtxtInterners<'tcx> {\n     /// Specifically use a speedy hash algorithm for these hash sets,\n     /// they're accessed quite often.\n     type_: RefCell<FnvHashSet<InternedTy<'tcx>>>,\n+    type_list: RefCell<FnvHashSet<InternedTyList<'tcx>>>,\n     substs: RefCell<FnvHashSet<InternedSubsts<'tcx>>>,\n     bare_fn: RefCell<FnvHashSet<&'tcx BareFnTy<'tcx>>>,\n     region: RefCell<FnvHashSet<&'tcx Region>>,\n@@ -99,6 +102,7 @@ impl<'tcx> CtxtInterners<'tcx> {\n         CtxtInterners {\n             arenas: arenas,\n             type_: RefCell::new(FnvHashSet()),\n+            type_list: RefCell::new(FnvHashSet()),\n             substs: RefCell::new(FnvHashSet()),\n             bare_fn: RefCell::new(FnvHashSet()),\n             region: RefCell::new(FnvHashSet()),\n@@ -228,19 +232,19 @@ impl<'a, 'gcx, 'tcx> Tables<'tcx> {\n     pub fn closure_type(this: &RefCell<Self>,\n                         tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                         def_id: DefId,\n-                        substs: &ClosureSubsts<'tcx>)\n+                        substs: ClosureSubsts<'tcx>)\n                         -> ty::ClosureTy<'tcx>\n     {\n         // If this is a local def-id, it should be inserted into the\n         // tables by typeck; else, it will be retreived from\n         // the external crate metadata.\n         if let Some(ty) = this.borrow().closure_tys.get(&def_id) {\n-            return ty.subst(tcx, &substs.func_substs);\n+            return ty.subst(tcx, substs.func_substs);\n         }\n \n         let ty = tcx.sess.cstore.closure_ty(tcx.global_tcx(), def_id);\n         this.borrow_mut().closure_tys.insert(def_id, ty.clone());\n-        ty.subst(tcx, &substs.func_substs)\n+        ty.subst(tcx, substs.func_substs)\n     }\n }\n \n@@ -742,6 +746,23 @@ impl<'a, 'tcx> Lift<'tcx> for &'a Substs<'a> {\n     }\n }\n \n+impl<'a, 'tcx> Lift<'tcx> for &'a [Ty<'a>] {\n+    type Lifted = &'tcx [Ty<'tcx>];\n+    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<&'tcx [Ty<'tcx>]> {\n+        if let Some(&InternedTyList { list }) = tcx.interners.type_list.borrow().get(*self) {\n+            if *self as *const _ == list as *const _ {\n+                return Some(list);\n+            }\n+        }\n+        // Also try in the global tcx if we're not that.\n+        if !tcx.is_global() {\n+            self.lift_to_tcx(tcx.global_tcx())\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n \n pub mod tls {\n     use super::{GlobalCtxt, TyCtxt};\n@@ -914,6 +935,18 @@ impl<'tcx: 'lcx, 'lcx> Borrow<TypeVariants<'lcx>> for InternedTy<'tcx> {\n     }\n }\n \n+/// An entry in the type list interner.\n+#[derive(PartialEq, Eq, Hash)]\n+struct InternedTyList<'tcx> {\n+    list: &'tcx [Ty<'tcx>]\n+}\n+\n+impl<'tcx: 'lcx, 'lcx> Borrow<[Ty<'lcx>]> for InternedTyList<'tcx> {\n+    fn borrow<'a>(&'a self) -> &'a [Ty<'lcx>] {\n+        self.list\n+    }\n+}\n+\n /// An entry in the substs interner.\n #[derive(PartialEq, Eq, Hash)]\n struct InternedSubsts<'tcx> {\n@@ -933,6 +966,18 @@ fn bound_list_is_sorted(bounds: &[ty::PolyProjectionPredicate]) -> bool {\n }\n \n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n+    pub fn mk_type_list(self, list: Vec<Ty<'tcx>>) -> &'tcx [Ty<'tcx>] {\n+        if let Some(interned) = self.interners.type_list.borrow().get(&list[..]) {\n+            return interned.list;\n+        }\n+\n+        let list = self.interners.arenas.type_list.alloc(list);\n+        self.interners.type_list.borrow_mut().insert(InternedTyList {\n+            list: list\n+        });\n+        list\n+    }\n+\n     // Type constructors\n     pub fn mk_substs(self, substs: Substs<'tcx>) -> &'tcx Substs<'tcx> {\n         if let Some(interned) = self.interners.substs.borrow().get(&substs) {\n@@ -949,11 +994,11 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// Create an unsafe fn ty based on a safe fn ty.\n     pub fn safe_to_unsafe_fn_ty(self, bare_fn: &BareFnTy<'tcx>) -> Ty<'tcx> {\n         assert_eq!(bare_fn.unsafety, hir::Unsafety::Normal);\n-        self.mk_fn_ptr(ty::BareFnTy {\n+        self.mk_fn_ptr(self.mk_bare_fn(ty::BareFnTy {\n             unsafety: hir::Unsafety::Unsafe,\n             abi: bare_fn.abi,\n             sig: bare_fn.sig.clone()\n-        })\n+        }))\n     }\n \n     pub fn mk_bare_fn(self, bare_fn: BareFnTy<'tcx>) -> &'tcx BareFnTy<'tcx> {\n@@ -1063,7 +1108,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn mk_tup(self, ts: Vec<Ty<'tcx>>) -> Ty<'tcx> {\n-        self.mk_ty(TyTuple(ts))\n+        self.mk_ty(TyTuple(self.mk_type_list(ts)))\n     }\n \n     pub fn mk_nil(self) -> Ty<'tcx> {\n@@ -1076,12 +1121,12 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n     pub fn mk_fn_def(self, def_id: DefId,\n                      substs: &'tcx Substs<'tcx>,\n-                     fty: BareFnTy<'tcx>) -> Ty<'tcx> {\n-        self.mk_ty(TyFnDef(def_id, substs, self.mk_bare_fn(fty)))\n+                     fty: &'tcx BareFnTy<'tcx>) -> Ty<'tcx> {\n+        self.mk_ty(TyFnDef(def_id, substs, fty))\n     }\n \n-    pub fn mk_fn_ptr(self, fty: BareFnTy<'tcx>) -> Ty<'tcx> {\n-        self.mk_ty(TyFnPtr(self.mk_bare_fn(fty)))\n+    pub fn mk_fn_ptr(self, fty: &'tcx BareFnTy<'tcx>) -> Ty<'tcx> {\n+        self.mk_ty(TyFnPtr(fty))\n     }\n \n     pub fn mk_trait(self,\n@@ -1117,15 +1162,15 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                       substs: &'tcx Substs<'tcx>,\n                       tys: Vec<Ty<'tcx>>)\n                       -> Ty<'tcx> {\n-        self.mk_closure_from_closure_substs(closure_id, Box::new(ClosureSubsts {\n+        self.mk_closure_from_closure_substs(closure_id, ClosureSubsts {\n             func_substs: substs,\n-            upvar_tys: tys\n-        }))\n+            upvar_tys: self.mk_type_list(tys)\n+        })\n     }\n \n     pub fn mk_closure_from_closure_substs(self,\n                                           closure_id: DefId,\n-                                          closure_substs: Box<ClosureSubsts<'tcx>>)\n+                                          closure_substs: ClosureSubsts<'tcx>)\n                                           -> Ty<'tcx> {\n         self.mk_ty(TyClosure(closure_id, closure_substs))\n     }"}, {"sha": "14b369f244d49a77e9ed8bd1ea75cb8ca83249b3", "filename": "src/librustc/ty/fold.rs", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/20652162ca5e330cb9d637924c6d93cb43fbb6aa/src%2Flibrustc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20652162ca5e330cb9d637924c6d93cb43fbb6aa/src%2Flibrustc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffold.rs?ref=20652162ca5e330cb9d637924c6d93cb43fbb6aa", "patch": "@@ -139,8 +139,8 @@ pub trait TypeFolder<'gcx: 'tcx, 'tcx> : Sized {\n     }\n \n     fn fold_substs(&mut self,\n-                   substs: &subst::Substs<'tcx>)\n-                   -> subst::Substs<'tcx> {\n+                   substs: &'tcx subst::Substs<'tcx>)\n+                   -> &'tcx subst::Substs<'tcx> {\n         substs.super_fold_with(self)\n     }\n \n@@ -157,8 +157,8 @@ pub trait TypeFolder<'gcx: 'tcx, 'tcx> : Sized {\n     }\n \n     fn fold_bare_fn_ty(&mut self,\n-                       fty: &ty::BareFnTy<'tcx>)\n-                       -> ty::BareFnTy<'tcx>\n+                       fty: &'tcx ty::BareFnTy<'tcx>)\n+                       -> &'tcx ty::BareFnTy<'tcx>\n     {\n         fty.super_fold_with(self)\n     }\n@@ -519,13 +519,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                     _ => ty::ReStatic\n                 }\n             }\n-\n-            fn fold_substs(&mut self,\n-                           substs: &subst::Substs<'tcx>)\n-                           -> subst::Substs<'tcx> {\n-                subst::Substs { regions: substs.regions.fold_with(self),\n-                                types: substs.types.fold_with(self) }\n-            }\n         }\n     }\n }"}, {"sha": "35656fb0c2dd8a450b1205a8c16e74e3b8bfeea6", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/20652162ca5e330cb9d637924c6d93cb43fbb6aa/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20652162ca5e330cb9d637924c6d93cb43fbb6aa/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=20652162ca5e330cb9d637924c6d93cb43fbb6aa", "patch": "@@ -581,9 +581,9 @@ impl<'a, 'tcx> Struct {\n \n             // Perhaps one of the upvars of this closure is non-zero\n             // Let's recurse and find out!\n-            (_, &ty::TyClosure(_, box ty::ClosureSubsts { upvar_tys: ref tys, .. })) |\n+            (_, &ty::TyClosure(_, ty::ClosureSubsts { upvar_tys: tys, .. })) |\n             // Can we use one of the fields in this tuple?\n-            (_, &ty::TyTuple(ref tys)) => {\n+            (_, &ty::TyTuple(tys)) => {\n                 Struct::non_zero_field_path(infcx, tys.iter().cloned())\n             }\n \n@@ -844,8 +844,8 @@ impl<'a, 'tcx> Layout {\n             }\n \n             // Tuples.\n-            ty::TyClosure(_, box ty::ClosureSubsts { upvar_tys: ref tys, .. }) |\n-            ty::TyTuple(ref tys) => {\n+            ty::TyClosure(_, ty::ClosureSubsts { upvar_tys: tys, .. }) |\n+            ty::TyTuple(tys) => {\n                 let mut st = Struct::new(dl, false);\n                 st.extend(dl, tys.iter().map(|ty| ty.layout(infcx)), ty)?;\n                 Univariant { variant: st, non_zero: false }"}, {"sha": "27f74de2470e6c76c7ce1805b61212b8335377fb", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/20652162ca5e330cb9d637924c6d93cb43fbb6aa/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20652162ca5e330cb9d637924c6d93cb43fbb6aa/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=20652162ca5e330cb9d637924c6d93cb43fbb6aa", "patch": "@@ -350,7 +350,7 @@ pub struct Method<'tcx> {\n     pub name: Name,\n     pub generics: Generics<'tcx>,\n     pub predicates: GenericPredicates<'tcx>,\n-    pub fty: BareFnTy<'tcx>,\n+    pub fty: &'tcx BareFnTy<'tcx>,\n     pub explicit_self: ExplicitSelfCategory,\n     pub vis: Visibility,\n     pub defaultness: hir::Defaultness,\n@@ -362,7 +362,7 @@ impl<'tcx> Method<'tcx> {\n     pub fn new(name: Name,\n                generics: ty::Generics<'tcx>,\n                predicates: GenericPredicates<'tcx>,\n-               fty: BareFnTy<'tcx>,\n+               fty: &'tcx BareFnTy<'tcx>,\n                explicit_self: ExplicitSelfCategory,\n                vis: Visibility,\n                defaultness: hir::Defaultness,\n@@ -1213,7 +1213,7 @@ impl<'tcx> TraitRef<'tcx> {\n #[derive(Clone)]\n pub struct ParameterEnvironment<'tcx> {\n     /// See `construct_free_substs` for details.\n-    pub free_substs: Substs<'tcx>,\n+    pub free_substs: &'tcx Substs<'tcx>,\n \n     /// Each type parameter has an implicit region bound that\n     /// indicates it must outlive at least the function body (the user\n@@ -1242,7 +1242,7 @@ impl<'a, 'tcx> ParameterEnvironment<'tcx> {\n                               -> ParameterEnvironment<'tcx>\n     {\n         ParameterEnvironment {\n-            free_substs: self.free_substs.clone(),\n+            free_substs: self.free_substs,\n             implicit_region_bound: self.implicit_region_bound,\n             caller_bounds: caller_bounds,\n             free_id_outlive: self.free_id_outlive,\n@@ -1974,7 +1974,7 @@ impl<'a, 'gcx, 'tcx, 'container> FieldDefData<'tcx, 'container> {\n /// item into the monotype of an item reference.\n #[derive(Clone)]\n pub struct ItemSubsts<'tcx> {\n-    pub substs: Substs<'tcx>,\n+    pub substs: &'tcx Substs<'tcx>,\n }\n \n #[derive(Clone, Copy, PartialOrd, Ord, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]\n@@ -2059,10 +2059,6 @@ impl<'tcx> TyS<'tcx> {\n }\n \n impl<'tcx> ItemSubsts<'tcx> {\n-    pub fn empty() -> ItemSubsts<'tcx> {\n-        ItemSubsts { substs: Substs::empty() }\n-    }\n-\n     pub fn is_noop(&self) -> bool {\n         self.substs.is_noop()\n     }\n@@ -2153,7 +2149,9 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n     pub fn node_id_item_substs(self, id: NodeId) -> ItemSubsts<'gcx> {\n         match self.tables.borrow().item_substs.get(&id) {\n-            None => ItemSubsts::empty(),\n+            None => ItemSubsts {\n+                substs: self.global_tcx().mk_substs(Substs::empty())\n+            },\n             Some(ts) => ts.clone(),\n         }\n     }\n@@ -2722,7 +2720,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n     pub fn closure_type(self,\n                         def_id: DefId,\n-                        substs: &ClosureSubsts<'gcx>)\n+                        substs: ClosureSubsts<'gcx>)\n                         -> ty::ClosureTy<'gcx>\n     {\n         Tables::closure_type(&self.tables, self.global_tcx(), def_id, substs)\n@@ -2805,7 +2803,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         // regions, so it shouldn't matter what we use for the free id\n         let free_id_outlive = self.region_maps.node_extent(ast::DUMMY_NODE_ID);\n         ty::ParameterEnvironment {\n-            free_substs: Substs::empty(),\n+            free_substs: self.mk_substs(Substs::empty()),\n             caller_bounds: Vec::new(),\n             implicit_region_bound: ty::ReEmpty,\n             free_id_outlive: free_id_outlive\n@@ -2882,7 +2880,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         //\n \n         let unnormalized_env = ty::ParameterEnvironment {\n-            free_substs: free_substs,\n+            free_substs: tcx.mk_substs(free_substs),\n             implicit_region_bound: ty::ReScope(free_id_outlive),\n             caller_bounds: predicates,\n             free_id_outlive: free_id_outlive,"}, {"sha": "60f8f277d394a345022fd56a5befa38d5c252032", "filename": "src/librustc/ty/outlives.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/20652162ca5e330cb9d637924c6d93cb43fbb6aa/src%2Flibrustc%2Fty%2Foutlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20652162ca5e330cb9d637924c6d93cb43fbb6aa/src%2Flibrustc%2Fty%2Foutlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Foutlives.rs?ref=20652162ca5e330cb9d637924c6d93cb43fbb6aa", "patch": "@@ -111,7 +111,7 @@ fn compute_components(&self, ty: Ty<'tcx>, out: &mut Vec<Component<'tcx>>) {\n             // what func/type parameters are used and unused,\n             // taking into consideration UFCS and so forth.\n \n-            for &upvar_ty in &substs.upvar_tys {\n+            for &upvar_ty in substs.upvar_tys {\n                 self.compute_components(upvar_ty, out);\n             }\n         }"}, {"sha": "80c727f022127745809e6e299b2725486a76d0fb", "filename": "src/librustc/ty/relate.rs", "status": "modified", "additions": 35, "deletions": 31, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/20652162ca5e330cb9d637924c6d93cb43fbb6aa/src%2Flibrustc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20652162ca5e330cb9d637924c6d93cb43fbb6aa/src%2Flibrustc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Frelate.rs?ref=20652162ca5e330cb9d637924c6d93cb43fbb6aa", "patch": "@@ -118,9 +118,9 @@ impl<'tcx> Relate<'tcx> for ty::TypeAndMut<'tcx> {\n // like traits etc.\n fn relate_item_substs<'a, 'gcx, 'tcx, R>(relation: &mut R,\n                                          item_def_id: DefId,\n-                                         a_subst: &Substs<'tcx>,\n-                                         b_subst: &Substs<'tcx>)\n-                                         -> RelateResult<'tcx, Substs<'tcx>>\n+                                         a_subst: &'tcx Substs<'tcx>,\n+                                         b_subst: &'tcx Substs<'tcx>)\n+                                         -> RelateResult<'tcx, &'tcx Substs<'tcx>>\n     where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n {\n     debug!(\"substs: item_def_id={:?} a_subst={:?} b_subst={:?}\",\n@@ -140,9 +140,9 @@ fn relate_item_substs<'a, 'gcx, 'tcx, R>(relation: &mut R,\n \n pub fn relate_substs<'a, 'gcx, 'tcx, R>(relation: &mut R,\n                                         variances: Option<&ty::ItemVariances>,\n-                                        a_subst: &Substs<'tcx>,\n-                                        b_subst: &Substs<'tcx>)\n-                                        -> RelateResult<'tcx, Substs<'tcx>>\n+                                        a_subst: &'tcx Substs<'tcx>,\n+                                        b_subst: &'tcx Substs<'tcx>)\n+                                        -> RelateResult<'tcx, &'tcx Substs<'tcx>>\n     where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n {\n     let mut substs = Substs::empty();\n@@ -166,7 +166,7 @@ pub fn relate_substs<'a, 'gcx, 'tcx, R>(relation: &mut R,\n         substs.regions.replace(space, regions);\n     }\n \n-    Ok(substs)\n+    Ok(relation.tcx().mk_substs(substs))\n }\n \n fn relate_type_params<'a, 'gcx, 'tcx, R>(relation: &mut R,\n@@ -223,19 +223,21 @@ fn relate_region_params<'a, 'gcx, 'tcx, R>(relation: &mut R,\n         .collect()\n }\n \n-impl<'tcx> Relate<'tcx> for ty::BareFnTy<'tcx> {\n+impl<'tcx> Relate<'tcx> for &'tcx ty::BareFnTy<'tcx> {\n     fn relate<'a, 'gcx, R>(relation: &mut R,\n-                           a: &ty::BareFnTy<'tcx>,\n-                           b: &ty::BareFnTy<'tcx>)\n-                           -> RelateResult<'tcx, ty::BareFnTy<'tcx>>\n+                           a: &&'tcx ty::BareFnTy<'tcx>,\n+                           b: &&'tcx ty::BareFnTy<'tcx>)\n+                           -> RelateResult<'tcx, &'tcx ty::BareFnTy<'tcx>>\n         where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n     {\n         let unsafety = relation.relate(&a.unsafety, &b.unsafety)?;\n         let abi = relation.relate(&a.abi, &b.abi)?;\n         let sig = relation.relate(&a.sig, &b.sig)?;\n-        Ok(ty::BareFnTy {unsafety: unsafety,\n-                         abi: abi,\n-                         sig: sig})\n+        Ok(relation.tcx().mk_bare_fn(ty::BareFnTy {\n+            unsafety: unsafety,\n+            abi: abi,\n+            sig: sig\n+        }))\n     }\n }\n \n@@ -418,7 +420,7 @@ impl<'tcx> Relate<'tcx> for ty::TraitRef<'tcx> {\n             Err(TypeError::Traits(expected_found(relation, &a.def_id, &b.def_id)))\n         } else {\n             let substs = relate_item_substs(relation, a.def_id, a.substs, b.substs)?;\n-            Ok(ty::TraitRef { def_id: a.def_id, substs: relation.tcx().mk_substs(substs) })\n+            Ok(ty::TraitRef { def_id: a.def_id, substs: substs })\n         }\n     }\n }\n@@ -481,7 +483,7 @@ pub fn super_relate_tys<'a, 'gcx, 'tcx, R>(relation: &mut R,\n             if a_def == b_def =>\n         {\n             let substs = relate_item_substs(relation, a_def.did, a_substs, b_substs)?;\n-            Ok(tcx.mk_enum(a_def, tcx.mk_substs(substs)))\n+            Ok(tcx.mk_enum(a_def, substs))\n         }\n \n         (&ty::TyTrait(ref a_), &ty::TyTrait(ref b_)) =>\n@@ -495,17 +497,17 @@ pub fn super_relate_tys<'a, 'gcx, 'tcx, R>(relation: &mut R,\n             if a_def == b_def =>\n         {\n             let substs = relate_item_substs(relation, a_def.did, a_substs, b_substs)?;\n-            Ok(tcx.mk_struct(a_def, tcx.mk_substs(substs)))\n+            Ok(tcx.mk_struct(a_def, substs))\n         }\n \n-        (&ty::TyClosure(a_id, ref a_substs),\n-         &ty::TyClosure(b_id, ref b_substs))\n+        (&ty::TyClosure(a_id, a_substs),\n+         &ty::TyClosure(b_id, b_substs))\n             if a_id == b_id =>\n         {\n             // All TyClosure types with the same id represent\n             // the (anonymous) type of the same closure expression. So\n             // all of their regions should be equated.\n-            let substs = relation.relate(a_substs, b_substs)?;\n+            let substs = relation.relate(&a_substs, &b_substs)?;\n             Ok(tcx.mk_closure_from_closure_substs(a_id, substs))\n         }\n \n@@ -544,7 +546,7 @@ pub fn super_relate_tys<'a, 'gcx, 'tcx, R>(relation: &mut R,\n             Ok(tcx.mk_slice(t))\n         }\n \n-        (&ty::TyTuple(ref as_), &ty::TyTuple(ref bs)) =>\n+        (&ty::TyTuple(as_), &ty::TyTuple(bs)) =>\n         {\n             if as_.len() == bs.len() {\n                 let ts = as_.iter().zip(bs)\n@@ -564,13 +566,13 @@ pub fn super_relate_tys<'a, 'gcx, 'tcx, R>(relation: &mut R,\n             if a_def_id == b_def_id =>\n         {\n             let substs = relate_substs(relation, None, a_substs, b_substs)?;\n-            let fty = relation.relate(a_fty, b_fty)?;\n-            Ok(tcx.mk_fn_def(a_def_id, tcx.mk_substs(substs), fty))\n+            let fty = relation.relate(&a_fty, &b_fty)?;\n+            Ok(tcx.mk_fn_def(a_def_id, substs, fty))\n         }\n \n         (&ty::TyFnPtr(a_fty), &ty::TyFnPtr(b_fty)) =>\n         {\n-            let fty = relation.relate(a_fty, b_fty)?;\n+            let fty = relation.relate(&a_fty, &b_fty)?;\n             Ok(tcx.mk_fn_ptr(fty))\n         }\n \n@@ -594,18 +596,20 @@ impl<'tcx> Relate<'tcx> for ty::ClosureSubsts<'tcx> {\n                            -> RelateResult<'tcx, ty::ClosureSubsts<'tcx>>\n         where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n     {\n-        let func_substs = relate_substs(relation, None, a.func_substs, b.func_substs)?;\n+        let substs = relate_substs(relation, None, a.func_substs, b.func_substs)?;\n         let upvar_tys = relation.relate_zip(&a.upvar_tys, &b.upvar_tys)?;\n-        Ok(ty::ClosureSubsts { func_substs: relation.tcx().mk_substs(func_substs),\n-                               upvar_tys: upvar_tys })\n+        Ok(ty::ClosureSubsts {\n+            func_substs: substs,\n+            upvar_tys: relation.tcx().mk_type_list(upvar_tys)\n+        })\n     }\n }\n \n-impl<'tcx> Relate<'tcx> for Substs<'tcx> {\n+impl<'tcx> Relate<'tcx> for &'tcx Substs<'tcx> {\n     fn relate<'a, 'gcx, R>(relation: &mut R,\n-                           a: &Substs<'tcx>,\n-                           b: &Substs<'tcx>)\n-                           -> RelateResult<'tcx, Substs<'tcx>>\n+                           a: &&'tcx Substs<'tcx>,\n+                           b: &&'tcx Substs<'tcx>)\n+                           -> RelateResult<'tcx, &'tcx Substs<'tcx>>\n         where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n     {\n         relate_substs(relation, None, a, b)"}, {"sha": "088ca15acb9f5a26317b132de056a3d3c04d1900", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 71, "deletions": 40, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/20652162ca5e330cb9d637924c6d93cb43fbb6aa/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20652162ca5e330cb9d637924c6d93cb43fbb6aa/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=20652162ca5e330cb9d637924c6d93cb43fbb6aa", "patch": "@@ -128,6 +128,18 @@ impl<'tcx, T: Lift<'tcx>> Lift<'tcx> for ty::Binder<T> {\n     }\n }\n \n+impl<'a, 'tcx> Lift<'tcx> for ty::ClosureSubsts<'a> {\n+    type Lifted = ty::ClosureSubsts<'tcx>;\n+    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+        tcx.lift(&(self.func_substs, self.upvar_tys)).map(|(substs, upvar_tys)| {\n+            ty::ClosureSubsts {\n+                func_substs: substs,\n+                upvar_tys: upvar_tys\n+            }\n+        })\n+    }\n+}\n+\n impl<'tcx, T: Lift<'tcx>> Lift<'tcx> for ty::error::ExpectedFound<T> {\n     type Lifted = ty::error::ExpectedFound<T::Lifted>;\n     fn lift_to_tcx<'a, 'gcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n@@ -330,41 +342,38 @@ impl<'tcx> TypeFoldable<'tcx> for ty::TraitTy<'tcx> {\n     }\n }\n \n+impl<'tcx> TypeFoldable<'tcx> for &'tcx [Ty<'tcx>] {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n+        let tys = self.iter().map(|t| t.fold_with(folder)).collect();\n+        folder.tcx().mk_type_list(tys)\n+    }\n+\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        self.iter().any(|t| t.visit_with(visitor))\n+    }\n+}\n+\n impl<'tcx> TypeFoldable<'tcx> for Ty<'tcx> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         let sty = match self.sty {\n             ty::TyBox(typ) => ty::TyBox(typ.fold_with(folder)),\n-            ty::TyRawPtr(ref tm) => ty::TyRawPtr(tm.fold_with(folder)),\n+            ty::TyRawPtr(tm) => ty::TyRawPtr(tm.fold_with(folder)),\n             ty::TyArray(typ, sz) => ty::TyArray(typ.fold_with(folder), sz),\n             ty::TySlice(typ) => ty::TySlice(typ.fold_with(folder)),\n-            ty::TyEnum(tid, ref substs) => {\n-                let substs = substs.fold_with(folder);\n-                ty::TyEnum(tid, folder.tcx().mk_substs(substs))\n-            }\n+            ty::TyEnum(tid, substs) => ty::TyEnum(tid, substs.fold_with(folder)),\n             ty::TyTrait(ref trait_ty) => ty::TyTrait(trait_ty.fold_with(folder)),\n-            ty::TyTuple(ref ts) => ty::TyTuple(ts.fold_with(folder)),\n-            ty::TyFnDef(def_id, substs, ref f) => {\n-                let substs = substs.fold_with(folder);\n-                let bfn = f.fold_with(folder);\n+            ty::TyTuple(ts) => ty::TyTuple(ts.fold_with(folder)),\n+            ty::TyFnDef(def_id, substs, f) => {\n                 ty::TyFnDef(def_id,\n-                            folder.tcx().mk_substs(substs),\n-                            folder.tcx().mk_bare_fn(bfn))\n+                            substs.fold_with(folder),\n+                            f.fold_with(folder))\n             }\n-            ty::TyFnPtr(ref f) => {\n-                let bfn = f.fold_with(folder);\n-                ty::TyFnPtr(folder.tcx().mk_bare_fn(bfn))\n-            }\n-            ty::TyRef(r, ref tm) => {\n-                let r = r.fold_with(folder);\n-                ty::TyRef(folder.tcx().mk_region(r), tm.fold_with(folder))\n-            }\n-            ty::TyStruct(did, ref substs) => {\n-                let substs = substs.fold_with(folder);\n-                ty::TyStruct(did, folder.tcx().mk_substs(substs))\n-            }\n-            ty::TyClosure(did, ref substs) => {\n-                ty::TyClosure(did, substs.fold_with(folder))\n+            ty::TyFnPtr(f) => ty::TyFnPtr(f.fold_with(folder)),\n+            ty::TyRef(ref r, tm) => {\n+                ty::TyRef(r.fold_with(folder), tm.fold_with(folder))\n             }\n+            ty::TyStruct(did, substs) => ty::TyStruct(did, substs.fold_with(folder)),\n+            ty::TyClosure(did, substs) => ty::TyClosure(did, substs.fold_with(folder)),\n             ty::TyProjection(ref data) => ty::TyProjection(data.fold_with(folder)),\n             ty::TyBool | ty::TyChar | ty::TyStr | ty::TyInt(_) |\n             ty::TyUint(_) | ty::TyFloat(_) | ty::TyError | ty::TyInfer(_) |\n@@ -385,7 +394,7 @@ impl<'tcx> TypeFoldable<'tcx> for Ty<'tcx> {\n             ty::TySlice(typ) => typ.visit_with(visitor),\n             ty::TyEnum(_tid, ref substs) => substs.visit_with(visitor),\n             ty::TyTrait(ref trait_ty) => trait_ty.visit_with(visitor),\n-            ty::TyTuple(ref ts) => ts.visit_with(visitor),\n+            ty::TyTuple(ts) => ts.visit_with(visitor),\n             ty::TyFnDef(_, substs, ref f) => {\n                 substs.visit_with(visitor) || f.visit_with(visitor)\n             }\n@@ -405,11 +414,14 @@ impl<'tcx> TypeFoldable<'tcx> for Ty<'tcx> {\n     }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for ty::BareFnTy<'tcx> {\n+impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::BareFnTy<'tcx> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        ty::BareFnTy { sig: self.sig.fold_with(folder),\n-                       abi: self.abi,\n-                       unsafety: self.unsafety }\n+        let fty = ty::BareFnTy {\n+            sig: self.sig.fold_with(folder),\n+            abi: self.abi,\n+            unsafety: self.unsafety\n+        };\n+        folder.tcx().mk_bare_fn(fty)\n     }\n \n     fn fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n@@ -491,10 +503,9 @@ impl<'tcx> TypeFoldable<'tcx> for ty::FnSig<'tcx> {\n \n impl<'tcx> TypeFoldable<'tcx> for ty::TraitRef<'tcx> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        let substs = self.substs.fold_with(folder);\n         ty::TraitRef {\n             def_id: self.def_id,\n-            substs: folder.tcx().mk_substs(substs),\n+            substs: self.substs.fold_with(folder),\n         }\n     }\n \n@@ -546,10 +557,32 @@ impl<'tcx> TypeFoldable<'tcx> for ty::Region {\n     }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for subst::Substs<'tcx> {\n+impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::Region {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, _folder: &mut F) -> Self {\n+        *self\n+    }\n+\n+    fn fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n+        let region = folder.fold_region(**self);\n+        folder.tcx().mk_region(region)\n+    }\n+\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, _visitor: &mut V) -> bool {\n+        false\n+    }\n+\n+    fn visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        visitor.visit_region(**self)\n+    }\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for &'tcx subst::Substs<'tcx> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        subst::Substs { regions: self.regions.fold_with(folder),\n-                        types: self.types.fold_with(folder) }\n+        let substs = subst::Substs {\n+            regions: self.regions.fold_with(folder),\n+            types: self.types.fold_with(folder)\n+        };\n+        folder.tcx().mk_substs(substs)\n     }\n \n     fn fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n@@ -563,9 +596,8 @@ impl<'tcx> TypeFoldable<'tcx> for subst::Substs<'tcx> {\n \n impl<'tcx> TypeFoldable<'tcx> for ty::ClosureSubsts<'tcx> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        let func_substs = self.func_substs.fold_with(folder);\n         ty::ClosureSubsts {\n-            func_substs: folder.tcx().mk_substs(func_substs),\n+            func_substs: self.func_substs.fold_with(folder),\n             upvar_tys: self.upvar_tys.fold_with(folder),\n         }\n     }\n@@ -590,9 +622,8 @@ impl<'tcx> TypeFoldable<'tcx> for ty::ItemSubsts<'tcx> {\n impl<'tcx> TypeFoldable<'tcx> for ty::adjustment::AutoRef<'tcx> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         match *self {\n-            ty::adjustment::AutoPtr(r, m) => {\n-                let r = r.fold_with(folder);\n-                ty::adjustment::AutoPtr(folder.tcx().mk_region(r), m)\n+            ty::adjustment::AutoPtr(ref r, m) => {\n+                ty::adjustment::AutoPtr(r.fold_with(folder), m)\n             }\n             ty::adjustment::AutoUnsafe(m) => ty::adjustment::AutoUnsafe(m)\n         }"}, {"sha": "472b6f1f51a09d9919c36ebaf4e5fd2a5ace3c86", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 19, "deletions": 18, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/20652162ca5e330cb9d637924c6d93cb43fbb6aa/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20652162ca5e330cb9d637924c6d93cb43fbb6aa/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=20652162ca5e330cb9d637924c6d93cb43fbb6aa", "patch": "@@ -25,7 +25,7 @@ use syntax::abi;\n use syntax::ast::{self, Name};\n use syntax::parse::token::keywords;\n \n-use serialize::{Decodable, Decoder};\n+use serialize::{Decodable, Decoder, Encodable, Encoder};\n \n use hir;\n \n@@ -140,10 +140,10 @@ pub enum TypeVariants<'tcx> {\n \n     /// The anonymous type of a closure. Used to represent the type of\n     /// `|a| a`.\n-    TyClosure(DefId, Box<ClosureSubsts<'tcx>>),\n+    TyClosure(DefId, ClosureSubsts<'tcx>),\n \n     /// A tuple type.  For example, `(i32, bool)`.\n-    TyTuple(Vec<Ty<'tcx>>),\n+    TyTuple(&'tcx [Ty<'tcx>]),\n \n     /// The projection of an associated type.  For example,\n     /// `<T as Trait<..>>::N`.\n@@ -234,7 +234,7 @@ pub enum TypeVariants<'tcx> {\n /// closure C wind up influencing the decisions we ought to make for\n /// closure C (which would then require fixed point iteration to\n /// handle). Plus it fixes an ICE. :P\n-#[derive(Clone, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n pub struct ClosureSubsts<'tcx> {\n     /// Lifetime and type parameters from the enclosing function.\n     /// These are separated out because trans wants to pass them around\n@@ -244,22 +244,23 @@ pub struct ClosureSubsts<'tcx> {\n     /// The types of the upvars. The list parallels the freevars and\n     /// `upvar_borrows` lists. These are kept distinct so that we can\n     /// easily index into them.\n-    pub upvar_tys: Vec<Ty<'tcx>>\n+    pub upvar_tys: &'tcx [Ty<'tcx>]\n }\n \n-impl<'tcx> Decodable for &'tcx ClosureSubsts<'tcx> {\n-    fn decode<S: Decoder>(s: &mut S) -> Result<&'tcx ClosureSubsts<'tcx>, S::Error> {\n-        let closure_substs = Decodable::decode(s)?;\n-        let dummy_def_id: DefId = unsafe { mem::zeroed() };\n-\n-        cstore::tls::with_decoding_context(s, |dcx, _| {\n-            // Intern the value\n-            let ty = dcx.tcx().mk_closure_from_closure_substs(dummy_def_id,\n-                                                              Box::new(closure_substs));\n-            match ty.sty {\n-                TyClosure(_, ref closure_substs) => Ok(&**closure_substs),\n-                _ => bug!()\n-            }\n+impl<'tcx> Encodable for ClosureSubsts<'tcx> {\n+    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+        (self.func_substs, self.upvar_tys).encode(s)\n+    }\n+}\n+\n+impl<'tcx> Decodable for ClosureSubsts<'tcx> {\n+    fn decode<D: Decoder>(d: &mut D) -> Result<ClosureSubsts<'tcx>, D::Error> {\n+        let (func_substs, upvar_tys) = Decodable::decode(d)?;\n+        cstore::tls::with_decoding_context(d, |dcx, _| {\n+            Ok(ClosureSubsts {\n+                func_substs: func_substs,\n+                upvar_tys: dcx.tcx().mk_type_list(upvar_tys)\n+            })\n         })\n     }\n }"}, {"sha": "9aec6b35997780bfbf3a4685307ddec30e212d1a", "filename": "src/librustc/ty/subst.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/20652162ca5e330cb9d637924c6d93cb43fbb6aa/src%2Flibrustc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20652162ca5e330cb9d637924c6d93cb43fbb6aa/src%2Flibrustc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsubst.rs?ref=20652162ca5e330cb9d637924c6d93cb43fbb6aa", "patch": "@@ -114,8 +114,8 @@ impl<'a, 'gcx, 'tcx> Substs<'tcx> {\n         Substs { types: types, regions: regions }\n     }\n \n-    pub fn with_method_from_subst(self, other: &Substs<'tcx>) -> Substs<'tcx> {\n-        let Substs { types, regions } = self;\n+    pub fn with_method_from_subst(&self, other: &Substs<'tcx>) -> Substs<'tcx> {\n+        let Substs { types, regions } = self.clone();\n         let types = types.with_slice(FnSpace, other.types.get_slice(FnSpace));\n         let regions = regions.with_slice(FnSpace, other.regions.get_slice(FnSpace));\n         Substs { types: types, regions: regions }"}, {"sha": "ff22db4ccda449a9699174eeed69399374a56e23", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/20652162ca5e330cb9d637924c6d93cb43fbb6aa/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20652162ca5e330cb9d637924c6d93cb43fbb6aa/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=20652162ca5e330cb9d637924c6d93cb43fbb6aa", "patch": "@@ -895,14 +895,14 @@ impl<'tcx> fmt::Display for ty::TypeVariants<'tcx> {\n             TyTrait(ref data) => write!(f, \"{}\", data),\n             ty::TyProjection(ref data) => write!(f, \"{}\", data),\n             TyStr => write!(f, \"str\"),\n-            TyClosure(did, ref substs) => ty::tls::with(|tcx| {\n+            TyClosure(did, substs) => ty::tls::with(|tcx| {\n                 write!(f, \"[closure\")?;\n \n                 if let Some(node_id) = tcx.map.as_local_node_id(did) {\n                     write!(f, \"@{:?}\", tcx.map.span(node_id))?;\n                     let mut sep = \" \";\n                     tcx.with_freevars(node_id, |freevars| {\n-                        for (freevar, upvar_ty) in freevars.iter().zip(&substs.upvar_tys) {\n+                        for (freevar, upvar_ty) in freevars.iter().zip(substs.upvar_tys) {\n                             let node_id = freevar.def.var_id();\n                             write!(f,\n                                         \"{}{}:{}\","}, {"sha": "22ffebc081bbdd6ba0be3940a18822ecdf6fa79e", "filename": "src/librustc_const_eval/eval.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/20652162ca5e330cb9d637924c6d93cb43fbb6aa/src%2Flibrustc_const_eval%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20652162ca5e330cb9d637924c6d93cb43fbb6aa/src%2Flibrustc_const_eval%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Feval.rs?ref=20652162ca5e330cb9d637924c6d93cb43fbb6aa", "patch": "@@ -92,7 +92,7 @@ fn lookup_variant_by_id<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n /// This generally happens in late/trans const evaluation.\n pub fn lookup_const_by_id<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                         def_id: DefId,\n-                                        substs: Option<subst::Substs<'tcx>>)\n+                                        substs: Option<&'tcx subst::Substs<'tcx>>)\n                                         -> Option<(&'tcx Expr, Option<ty::Ty<'tcx>>)> {\n     if let Some(node_id) = tcx.map.as_local_node_id(def_id) {\n         match tcx.map.find(node_id) {\n@@ -1004,11 +1004,11 @@ fn infer<'a, 'tcx>(i: ConstInt,\n fn resolve_trait_associated_const<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                                 ti: &'tcx hir::TraitItem,\n                                                 trait_id: DefId,\n-                                                rcvr_substs: subst::Substs<'tcx>)\n+                                                rcvr_substs: &'tcx subst::Substs<'tcx>)\n                                                 -> Option<(&'tcx Expr, Option<ty::Ty<'tcx>>)>\n {\n     let trait_ref = ty::Binder(\n-        rcvr_substs.erase_regions().to_trait_ref(tcx, trait_id)\n+        rcvr_substs.clone().erase_regions().to_trait_ref(tcx, trait_id)\n     );\n     debug!(\"resolve_trait_associated_const: trait_ref={:?}\",\n            trait_ref);"}, {"sha": "fc44f808e4bffce784e6ba9c02a9a3927ca194ce", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/20652162ca5e330cb9d637924c6d93cb43fbb6aa/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20652162ca5e330cb9d637924c6d93cb43fbb6aa/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=20652162ca5e330cb9d637924c6d93cb43fbb6aa", "patch": "@@ -265,15 +265,15 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n \n     pub fn t_fn(&self, input_tys: &[Ty<'tcx>], output_ty: Ty<'tcx>) -> Ty<'tcx> {\n         let input_args = input_tys.iter().cloned().collect();\n-        self.infcx.tcx.mk_fn_ptr(ty::BareFnTy {\n+        self.infcx.tcx.mk_fn_ptr(self.infcx.tcx.mk_bare_fn(ty::BareFnTy {\n             unsafety: hir::Unsafety::Normal,\n             abi: Abi::Rust,\n             sig: ty::Binder(ty::FnSig {\n                 inputs: input_args,\n                 output: ty::FnConverging(output_ty),\n                 variadic: false,\n             }),\n-        })\n+        }))\n     }\n \n     pub fn t_nil(&self) -> Ty<'tcx> {"}, {"sha": "13cfa2a604d3e8088ddd8aec5d73f669d7961ffb", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/20652162ca5e330cb9d637924c6d93cb43fbb6aa/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20652162ca5e330cb9d637924c6d93cb43fbb6aa/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=20652162ca5e330cb9d637924c6d93cb43fbb6aa", "patch": "@@ -823,11 +823,7 @@ impl LateLintPass for UnconditionalRecursion {\n                 hir_map::NodeExpr(&hir::Expr { node: hir::ExprCall(ref callee, _), .. }) => {\n                     match tcx.def_map.borrow().get(&callee.id).map(|d| d.full_def()) {\n                         Some(Def::Method(def_id)) => {\n-                            let item_substs =\n-                                tcx.tables.borrow().item_substs\n-                                                   .get(&callee.id)\n-                                                   .cloned()\n-                                                   .unwrap_or_else(|| ty::ItemSubsts::empty());\n+                            let item_substs = tcx.node_id_item_substs(callee.id);\n                             method_call_refers_to_method(\n                                 tcx, method, def_id, &item_substs.substs, id)\n                         }"}, {"sha": "cd47d97d17075fabe949784a92878793d90fb9fd", "filename": "src/librustc_metadata/astencode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/20652162ca5e330cb9d637924c6d93cb43fbb6aa/src%2Flibrustc_metadata%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20652162ca5e330cb9d637924c6d93cb43fbb6aa/src%2Flibrustc_metadata%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fastencode.rs?ref=20652162ca5e330cb9d637924c6d93cb43fbb6aa", "patch": "@@ -1149,7 +1149,7 @@ fn decode_side_tables(dcx: &DecodeContext,\n                     }\n                     c::tag_table_item_subst => {\n                         let item_substs = ty::ItemSubsts {\n-                            substs: val_dsr.read_substs(dcx)\n+                            substs: dcx.tcx.mk_substs(val_dsr.read_substs(dcx))\n                         };\n                         dcx.tcx.tables.borrow_mut().item_substs.insert(\n                             id, item_substs);"}, {"sha": "e233dda7e91eeb91a99627601bd9ae8ee57d4c9e", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/20652162ca5e330cb9d637924c6d93cb43fbb6aa/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20652162ca5e330cb9d637924c6d93cb43fbb6aa/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=20652162ca5e330cb9d637924c6d93cb43fbb6aa", "patch": "@@ -987,7 +987,7 @@ pub fn get_impl_or_trait_item<'a, 'tcx>(intr: Rc<IdentInterner>,\n             let predicates = doc_predicates(item_doc, tcx, cdata, tag_method_ty_generics);\n             let ity = tcx.lookup_item_type(def_id).ty;\n             let fty = match ity.sty {\n-                ty::TyFnDef(_, _, fty) => fty.clone(),\n+                ty::TyFnDef(_, _, fty) => fty,\n                 _ => bug!(\n                     \"the type {:?} of the method {:?} is not a function?\",\n                     ity, name)"}, {"sha": "c94af9c5b3ae318d64332c35cc05650a275d3d45", "filename": "src/librustc_metadata/tydecode.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/20652162ca5e330cb9d637924c6d93cb43fbb6aa/src%2Flibrustc_metadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20652162ca5e330cb9d637924c6d93cb43fbb6aa/src%2Flibrustc_metadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Ftydecode.rs?ref=20652162ca5e330cb9d637924c6d93cb43fbb6aa", "patch": "@@ -502,15 +502,15 @@ impl<'a,'tcx> TyDecoder<'a,'tcx> {\n         }\n     }\n \n-    pub fn parse_bare_fn_ty(&mut self) -> ty::BareFnTy<'tcx> {\n+    pub fn parse_bare_fn_ty(&mut self) -> &'tcx ty::BareFnTy<'tcx> {\n         let unsafety = parse_unsafety(self.next());\n         let abi = self.parse_abi_set();\n         let sig = self.parse_sig();\n-        ty::BareFnTy {\n+        self.tcx.mk_bare_fn(ty::BareFnTy {\n             unsafety: unsafety,\n             abi: abi,\n             sig: sig\n-        }\n+        })\n     }\n \n     fn parse_sig(&mut self) -> ty::PolyFnSig<'tcx> {"}, {"sha": "343c452f89165aa3a12085cd3ff7e768cec7ca6e", "filename": "src/librustc_metadata/tyencode.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/20652162ca5e330cb9d637924c6d93cb43fbb6aa/src%2Flibrustc_metadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20652162ca5e330cb9d637924c6d93cb43fbb6aa/src%2Flibrustc_metadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Ftyencode.rs?ref=20652162ca5e330cb9d637924c6d93cb43fbb6aa", "patch": "@@ -110,7 +110,7 @@ pub fn enc_ty<'a, 'tcx>(w: &mut Cursor<Vec<u8>>, cx: &ctxt<'a, 'tcx>, t: Ty<'tcx\n             enc_existential_bounds(w, cx, bounds);\n             write!(w, \"]\");\n         }\n-        ty::TyTuple(ref ts) => {\n+        ty::TyTuple(ts) => {\n             write!(w, \"T[\");\n             for t in ts { enc_ty(w, cx, *t); }\n             write!(w, \"]\");\n@@ -156,10 +156,10 @@ pub fn enc_ty<'a, 'tcx>(w: &mut Cursor<Vec<u8>>, cx: &ctxt<'a, 'tcx>, t: Ty<'tcx\n             enc_substs(w, cx, substs);\n             write!(w, \"]\");\n         }\n-        ty::TyClosure(def, ref substs) => {\n+        ty::TyClosure(def, substs) => {\n             write!(w, \"k[{}|\", (cx.ds)(cx.tcx, def));\n-            enc_substs(w, cx, &substs.func_substs);\n-            for ty in &substs.upvar_tys {\n+            enc_substs(w, cx, substs.func_substs);\n+            for ty in substs.upvar_tys {\n                 enc_ty(w, cx, ty);\n             }\n             write!(w, \".\");"}, {"sha": "39e9ace5432a6b752f2d91e9f1c8cb1d3af627db", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/20652162ca5e330cb9d637924c6d93cb43fbb6aa/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20652162ca5e330cb9d637924c6d93cb43fbb6aa/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=20652162ca5e330cb9d637924c6d93cb43fbb6aa", "patch": "@@ -275,7 +275,7 @@ fn make_mirror_unadjusted<'a, 'tcx>(cx: &mut Cx<'a, 'tcx, 'tcx>,\n                     })\n                 } else { None };\n                 if let Some((adt_def, index)) = adt_data {\n-                    let substs = cx.tcx.mk_substs(cx.tcx.node_id_item_substs(fun.id).substs);\n+                    let substs = cx.tcx.node_id_item_substs(fun.id).substs;\n                     let field_refs = args.iter().enumerate().map(|(idx, e)| FieldExprRef {\n                         name: Field::new(idx),\n                         expr: e.to_ref()\n@@ -506,7 +506,7 @@ fn make_mirror_unadjusted<'a, 'tcx>(cx: &mut Cx<'a, 'tcx, 'tcx>,\n         hir::ExprClosure(..) => {\n             let closure_ty = cx.tcx.expr_ty(expr);\n             let (def_id, substs) = match closure_ty.sty {\n-                ty::TyClosure(def_id, ref substs) => (def_id, substs),\n+                ty::TyClosure(def_id, substs) => (def_id, substs),\n                 _ => {\n                     span_bug!(expr.span,\n                               \"closure expr w/o closure type: {:?}\",\n@@ -521,7 +521,7 @@ fn make_mirror_unadjusted<'a, 'tcx>(cx: &mut Cx<'a, 'tcx, 'tcx>,\n             });\n             ExprKind::Closure {\n                 closure_id: def_id,\n-                substs: &substs,\n+                substs: substs,\n                 upvars: upvars,\n             }\n         }\n@@ -672,7 +672,7 @@ fn convert_arm<'a, 'tcx>(cx: &mut Cx<'a, 'tcx, 'tcx>,\n fn convert_path_expr<'a, 'tcx>(cx: &mut Cx<'a, 'tcx, 'tcx>,\n                                expr: &'tcx hir::Expr)\n                                -> ExprKind<'tcx> {\n-    let substs = cx.tcx.mk_substs(cx.tcx.node_id_item_substs(expr.id).substs);\n+    let substs = cx.tcx.node_id_item_substs(expr.id).substs;\n     // Otherwise there may be def_map borrow conflicts\n     let def = cx.tcx.def_map.borrow()[&expr.id].full_def();\n     let def_id = match def {"}, {"sha": "1cdf077ffac09bc1262776c0fa7972dd65699687", "filename": "src/librustc_mir/hair/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/20652162ca5e330cb9d637924c6d93cb43fbb6aa/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20652162ca5e330cb9d637924c6d93cb43fbb6aa/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fmod.rs?ref=20652162ca5e330cb9d637924c6d93cb43fbb6aa", "patch": "@@ -222,7 +222,7 @@ pub enum ExprKind<'tcx> {\n     },\n     Closure {\n         closure_id: DefId,\n-        substs: &'tcx ClosureSubsts<'tcx>,\n+        substs: ClosureSubsts<'tcx>,\n         upvars: Vec<ExprRef<'tcx>>,\n     },\n     Literal {"}, {"sha": "485ca3ea84a7e8d2f093e58464781a0ed92522ec", "filename": "src/librustc_mir/transform/erase_regions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/20652162ca5e330cb9d637924c6d93cb43fbb6aa/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20652162ca5e330cb9d637924c6d93cb43fbb6aa/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs?ref=20652162ca5e330cb9d637924c6d93cb43fbb6aa", "patch": "@@ -37,7 +37,7 @@ impl<'a, 'tcx> MutVisitor<'tcx> for EraseRegionsVisitor<'a, 'tcx> {\n     }\n \n     fn visit_substs(&mut self, substs: &mut &'tcx Substs<'tcx>) {\n-        *substs = self.tcx.mk_substs(self.tcx.erase_regions(*substs));\n+        *substs = self.tcx.erase_regions(&{*substs});\n     }\n }\n "}, {"sha": "9ad06e85c4fbebeeee88813794ae5a8d2c473bbc", "filename": "src/librustc_mir/transform/type_check.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/20652162ca5e330cb9d637924c6d93cb43fbb6aa/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20652162ca5e330cb9d637924c6d93cb43fbb6aa/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs?ref=20652162ca5e330cb9d637924c6d93cb43fbb6aa", "patch": "@@ -276,8 +276,8 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx, 'tcx> {\n                     if adt_def.is_univariant() => {\n                         (&adt_def.variants[0], substs)\n                     }\n-                ty::TyTuple(ref tys) | ty::TyClosure(_, box ty::ClosureSubsts {\n-                    upvar_tys: ref tys, ..\n+                ty::TyTuple(tys) | ty::TyClosure(_, ty::ClosureSubsts {\n+                    upvar_tys: tys, ..\n                 }) => {\n                     return match tys.get(field.index()) {\n                         Some(&ty) => Ok(ty),"}, {"sha": "3fb8605412075ed957a6e6e99f64497ee6e9c1bb", "filename": "src/librustc_trans/callee.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/20652162ca5e330cb9d637924c6d93cb43fbb6aa/src%2Flibrustc_trans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20652162ca5e330cb9d637924c6d93cb43fbb6aa/src%2Flibrustc_trans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcallee.rs?ref=20652162ca5e330cb9d637924c6d93cb43fbb6aa", "patch": "@@ -100,7 +100,7 @@ impl<'tcx> Callee<'tcx> {\n     /// Trait or impl method.\n     pub fn method<'blk>(bcx: Block<'blk, 'tcx>,\n                         method: ty::MethodCallee<'tcx>) -> Callee<'tcx> {\n-        let substs = bcx.tcx().mk_substs(bcx.fcx.monomorphize(&method.substs));\n+        let substs = bcx.fcx.monomorphize(&method.substs);\n         Callee::def(bcx.ccx(), method.def_id, substs)\n     }\n \n@@ -182,7 +182,7 @@ impl<'tcx> Callee<'tcx> {\n \n                 let method_ty = def_ty(tcx, def_id, substs);\n                 let fn_ptr_ty = match method_ty.sty {\n-                    ty::TyFnDef(_, _, fty) => tcx.mk_ty(ty::TyFnPtr(fty)),\n+                    ty::TyFnDef(_, _, fty) => tcx.mk_fn_ptr(fty),\n                     _ => bug!(\"expected fn item type, found {}\",\n                               method_ty)\n                 };\n@@ -194,7 +194,7 @@ impl<'tcx> Callee<'tcx> {\n \n                 let method_ty = def_ty(tcx, def_id, substs);\n                 let fn_ptr_ty = match method_ty.sty {\n-                    ty::TyFnDef(_, _, fty) => tcx.mk_ty(ty::TyFnPtr(fty)),\n+                    ty::TyFnDef(_, _, fty) => tcx.mk_fn_ptr(fty),\n                     _ => bug!(\"expected fn item type, found {}\",\n                               method_ty)\n                 };\n@@ -252,7 +252,7 @@ impl<'tcx> Callee<'tcx> {\n     pub fn reify<'a>(self, ccx: &CrateContext<'a, 'tcx>)\n                      -> Datum<'tcx, Rvalue> {\n         let fn_ptr_ty = match self.ty.sty {\n-            ty::TyFnDef(_, _, f) => ccx.tcx().mk_ty(ty::TyFnPtr(f)),\n+            ty::TyFnDef(_, _, f) => ccx.tcx().mk_fn_ptr(f),\n             _ => self.ty\n         };\n         match self.data {\n@@ -368,11 +368,11 @@ pub fn trans_fn_pointer_shim<'a, 'tcx>(\n         variadic: false\n     };\n     let fn_ty = FnType::new(ccx, Abi::RustCall, &sig, &[]);\n-    let tuple_fn_ty = tcx.mk_fn_ptr(ty::BareFnTy {\n+    let tuple_fn_ty = tcx.mk_fn_ptr(tcx.mk_bare_fn(ty::BareFnTy {\n         unsafety: hir::Unsafety::Normal,\n         abi: Abi::RustCall,\n         sig: ty::Binder(sig)\n-    });\n+    }));\n     debug!(\"tuple_fn_ty: {:?}\", tuple_fn_ty);\n \n     //\n@@ -476,7 +476,7 @@ fn get_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         let fn_ptr_ty = match fn_ty.sty {\n             ty::TyFnDef(_, _, fty) => {\n                 // Create a fn pointer with the substituted signature.\n-                tcx.mk_ty(ty::TyFnPtr(fty))\n+                tcx.mk_fn_ptr(fty)\n             }\n             _ => bug!(\"expected fn item type, found {}\", fn_ty)\n         };\n@@ -487,7 +487,7 @@ fn get_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     // Find the actual function pointer.\n     let ty = ccx.tcx().lookup_item_type(def_id).ty;\n     let fn_ptr_ty = match ty.sty {\n-        ty::TyFnDef(_, _, fty) => {\n+        ty::TyFnDef(_, _, ref fty) => {\n             // Create a fn pointer with the normalized signature.\n             tcx.mk_fn_ptr(tcx.normalize_associated_type(fty))\n         }"}, {"sha": "04f5e71497cf533237c1175eaf1ee9529513f653", "filename": "src/librustc_trans/closure.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/20652162ca5e330cb9d637924c6d93cb43fbb6aa/src%2Flibrustc_trans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20652162ca5e330cb9d637924c6d93cb43fbb6aa/src%2Flibrustc_trans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fclosure.rs?ref=20652162ca5e330cb9d637924c6d93cb43fbb6aa", "patch": "@@ -136,13 +136,13 @@ fn get_self_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n /// necessary. If the ID does not correspond to a closure ID, returns None.\n fn get_or_create_closure_declaration<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                                closure_id: DefId,\n-                                               substs: &ty::ClosureSubsts<'tcx>)\n+                                               substs: ty::ClosureSubsts<'tcx>)\n                                                -> ValueRef {\n     // Normalize type so differences in regions and typedefs don't cause\n     // duplicate declarations\n     let tcx = ccx.tcx();\n-    let substs = tcx.erase_regions(substs);\n-    let instance = Instance::new(closure_id, &substs.func_substs);\n+    let substs = tcx.erase_regions(&substs);\n+    let instance = Instance::new(closure_id, substs.func_substs);\n \n     if let Some(&llfn) = ccx.instances().borrow().get(&instance) {\n         debug!(\"get_or_create_closure_declaration(): found closure {:?}: {:?}\",\n@@ -153,11 +153,11 @@ fn get_or_create_closure_declaration<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     let symbol = symbol_names::exported_name(ccx, &instance);\n \n     // Compute the rust-call form of the closure call method.\n-    let sig = &ty::Tables::closure_type(&tcx.tables, tcx, closure_id, &substs).sig;\n+    let sig = &ty::Tables::closure_type(&tcx.tables, tcx, closure_id, substs).sig;\n     let sig = tcx.erase_late_bound_regions(sig);\n     let sig = tcx.normalize_associated_type(&sig);\n-    let closure_type = tcx.mk_closure_from_closure_substs(closure_id, Box::new(substs));\n-    let function_type = tcx.mk_fn_ptr(ty::BareFnTy {\n+    let closure_type = tcx.mk_closure_from_closure_substs(closure_id, substs);\n+    let function_type = tcx.mk_fn_ptr(tcx.mk_bare_fn(ty::BareFnTy {\n         unsafety: hir::Unsafety::Normal,\n         abi: Abi::RustCall,\n         sig: ty::Binder(ty::FnSig {\n@@ -166,7 +166,7 @@ fn get_or_create_closure_declaration<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n             output: sig.output,\n             variadic: false\n         })\n-    });\n+    }));\n     let llfn = declare::define_internal_fn(ccx, &symbol, function_type);\n \n     // set an inline hint for all closures\n@@ -190,7 +190,7 @@ pub fn trans_closure_expr<'a, 'tcx>(dest: Dest<'a, 'tcx>,\n                                     body: &hir::Block,\n                                     id: ast::NodeId,\n                                     closure_def_id: DefId, // (*)\n-                                    closure_substs: &ty::ClosureSubsts<'tcx>)\n+                                    closure_substs: ty::ClosureSubsts<'tcx>)\n                                     -> Option<Block<'a, 'tcx>>\n {\n     // (*) Note that in the case of inlined functions, the `closure_def_id` will be the\n@@ -224,7 +224,7 @@ pub fn trans_closure_expr<'a, 'tcx>(dest: Dest<'a, 'tcx>,\n     let sig = tcx.normalize_associated_type(&sig);\n \n     let closure_type = tcx.mk_closure_from_closure_substs(closure_def_id,\n-        Box::new(closure_substs.clone()));\n+                                                          closure_substs);\n     let sig = ty::FnSig {\n         inputs: Some(get_self_type(tcx, closure_def_id, closure_type))\n                     .into_iter().chain(sig.inputs).collect(),\n@@ -285,7 +285,7 @@ pub fn trans_closure_method<'a, 'tcx>(ccx: &'a CrateContext<'a, 'tcx>,\n                                       -> ValueRef\n {\n     // If this is a closure, redirect to it.\n-    let llfn = get_or_create_closure_declaration(ccx, closure_def_id, &substs);\n+    let llfn = get_or_create_closure_declaration(ccx, closure_def_id, substs);\n \n     // If the closure is a Fn closure, but a FnOnce is needed (etc),\n     // then adapt the self type\n@@ -344,18 +344,18 @@ fn trans_fn_once_adapter_shim<'a, 'tcx>(\n \n     // Find a version of the closure type. Substitute static for the\n     // region since it doesn't really matter.\n-    let closure_ty = tcx.mk_closure_from_closure_substs(closure_def_id, Box::new(substs.clone()));\n+    let closure_ty = tcx.mk_closure_from_closure_substs(closure_def_id, substs);\n     let ref_closure_ty = tcx.mk_imm_ref(tcx.mk_region(ty::ReStatic), closure_ty);\n \n     // Make a version with the type of by-ref closure.\n     let ty::ClosureTy { unsafety, abi, mut sig } =\n-        ty::Tables::closure_type(&tcx.tables, tcx, closure_def_id, &substs);\n+        ty::Tables::closure_type(&tcx.tables, tcx, closure_def_id, substs);\n     sig.0.inputs.insert(0, ref_closure_ty); // sig has no self type as of yet\n-    let llref_fn_ty = tcx.mk_fn_ptr(ty::BareFnTy {\n+    let llref_fn_ty = tcx.mk_fn_ptr(tcx.mk_bare_fn(ty::BareFnTy {\n         unsafety: unsafety,\n         abi: abi,\n         sig: sig.clone()\n-    });\n+    }));\n     debug!(\"trans_fn_once_adapter_shim: llref_fn_ty={:?}\",\n            llref_fn_ty);\n \n@@ -369,11 +369,11 @@ fn trans_fn_once_adapter_shim<'a, 'tcx>(\n     let sig = tcx.normalize_associated_type(&sig);\n     let fn_ty = FnType::new(ccx, abi, &sig, &[]);\n \n-    let llonce_fn_ty = tcx.mk_fn_ptr(ty::BareFnTy {\n+    let llonce_fn_ty = tcx.mk_fn_ptr(tcx.mk_bare_fn(ty::BareFnTy {\n         unsafety: unsafety,\n         abi: abi,\n         sig: ty::Binder(sig)\n-    });\n+    }));\n \n     // Create the by-value helper.\n     let function_name ="}, {"sha": "05ed5abce145030f2add69a44025a82dbfa1ce1a", "filename": "src/librustc_trans/collector.rs", "status": "modified", "additions": 18, "deletions": 19, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/20652162ca5e330cb9d637924c6d93cb43fbb6aa/src%2Flibrustc_trans%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20652162ca5e330cb9d637924c6d93cb43fbb6aa/src%2Flibrustc_trans%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcollector.rs?ref=20652162ca5e330cb9d637924c6d93cb43fbb6aa", "patch": "@@ -530,7 +530,7 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n                 let exchange_malloc_fn_trans_item =\n                     create_fn_trans_item(self.scx.tcx(),\n                                          exchange_malloc_fn_def_id,\n-                                         &Substs::empty(),\n+                                         self.ccx.tcx().mk_substs(Substs::empty()),\n                                          self.param_substs);\n \n                 self.output.push(exchange_malloc_fn_trans_item);\n@@ -670,8 +670,8 @@ fn find_drop_glue_neighbors<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n         let exchange_free_fn_trans_item =\n             create_fn_trans_item(scx.tcx(),\n                                  exchange_free_fn_def_id,\n-                                 &Substs::empty(),\n-                                 &Substs::empty());\n+                                 ccx.tcx().mk_substs(Substs::empty()),\n+                                 ccx.tcx().mk_substs(Substs::empty()));\n \n         output.push(exchange_free_fn_trans_item);\n     }\n@@ -709,7 +709,7 @@ fn find_drop_glue_neighbors<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n             let trans_item = create_fn_trans_item(scx.tcx(),\n                                                   destructor_did,\n                                                   substs,\n-                                                  &Substs::empty());\n+                                                  ccx.tcx().mk_substs(Substs::empty()));\n             output.push(trans_item);\n         }\n \n@@ -747,8 +747,8 @@ fn find_drop_glue_neighbors<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n                 }\n             }\n         }\n-        ty::TyClosure(_, ref substs) => {\n-            for upvar_ty in &substs.upvar_tys {\n+        ty::TyClosure(_, substs) => {\n+            for upvar_ty in substs.upvar_tys {\n                 let upvar_ty = glue::get_drop_glue_type(scx.tcx(), upvar_ty);\n                 if glue::type_needs_drop(scx.tcx(), upvar_ty) {\n                     output.push(TransItem::DropGlue(DropGlueKind::Ty(upvar_ty)));\n@@ -762,7 +762,7 @@ fn find_drop_glue_neighbors<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n                 output.push(TransItem::DropGlue(DropGlueKind::Ty(inner_type)));\n             }\n         }\n-        ty::TyTuple(ref args) => {\n+        ty::TyTuple(args) => {\n             for arg in args {\n                 let arg = glue::get_drop_glue_type(scx.tcx(), arg);\n                 if glue::type_needs_drop(scx.tcx(), arg) {\n@@ -840,7 +840,7 @@ fn do_static_trait_method_dispatch<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n \n     let rcvr_substs = monomorphize::apply_param_substs(tcx,\n                                                        param_substs,\n-                                                       callee_substs);\n+                                                       &callee_substs);\n \n     let trait_ref = ty::Binder(rcvr_substs.to_trait_ref(tcx, trait_id));\n     let vtbl = fulfill_obligation(scx, DUMMY_SP, trait_ref);\n@@ -962,8 +962,8 @@ fn find_vtable_types_for_unsizing<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n \n fn create_fn_trans_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                   def_id: DefId,\n-                                  fn_substs: &Substs<'tcx>,\n-                                  param_substs: &Substs<'tcx>)\n+                                  fn_substs: &'tcx Substs<'tcx>,\n+                                  param_substs: &'tcx Substs<'tcx>)\n                                   -> TransItem<'tcx> {\n     debug!(\"create_fn_trans_item(def_id={}, fn_substs={:?}, param_substs={:?})\",\n             def_id_to_string(tcx, def_id),\n@@ -975,12 +975,11 @@ fn create_fn_trans_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     // ignored because we don't want to generate any code for them.\n     let concrete_substs = monomorphize::apply_param_substs(tcx,\n                                                            param_substs,\n-                                                           fn_substs);\n+                                                           &fn_substs);\n     let concrete_substs = tcx.erase_regions(&concrete_substs);\n \n     let trans_item =\n-        TransItem::Fn(Instance::new(def_id,\n-                                    &tcx.mk_substs(concrete_substs)));\n+        TransItem::Fn(Instance::new(def_id, concrete_substs));\n     return trans_item;\n }\n \n@@ -1013,9 +1012,9 @@ fn create_trans_items_for_vtable_methods<'a, 'tcx>(scx: &SharedCrateContext<'a,\n                         .filter_map(|impl_method| {\n                             if can_have_local_instance(scx.tcx(), impl_method.method.def_id) {\n                                 Some(create_fn_trans_item(scx.tcx(),\n-                                                          impl_method.method.def_id,\n-                                                          &impl_method.substs,\n-                                                          &Substs::empty()))\n+                                    impl_method.method.def_id,\n+                                    impl_method.substs,\n+                                    ccx.tcx().mk_substs(Substs::empty())))\n                             } else {\n                                 None\n                             }\n@@ -1167,7 +1166,7 @@ fn create_trans_items_for_default_impls<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n             if let Some(trait_ref) = tcx.impl_trait_ref(impl_def_id) {\n                 let default_impls = tcx.provided_trait_methods(trait_ref.def_id);\n-                let callee_substs = tcx.mk_substs(tcx.erase_regions(trait_ref.substs));\n+                let callee_substs = tcx.erase_regions(&trait_ref.substs);\n                 let overridden_methods: FnvHashSet<_> = items.iter()\n                                                              .map(|item| item.name)\n                                                              .collect();\n@@ -1195,7 +1194,7 @@ fn create_trans_items_for_default_impls<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                     }\n \n                     if can_have_local_instance(tcx, default_impl.def_id) {\n-                        let empty_substs = tcx.mk_substs(tcx.erase_regions(mth.substs));\n+                        let empty_substs = tcx.erase_regions(&mth.substs);\n                         let item = create_fn_trans_item(tcx,\n                                                         default_impl.def_id,\n                                                         callee_substs,\n@@ -1249,7 +1248,7 @@ pub fn push_unique_type_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             push_item_name(tcx, adt_def.did, output);\n             push_type_params(tcx, &substs.types, &[], output);\n         },\n-        ty::TyTuple(ref component_types) => {\n+        ty::TyTuple(component_types) => {\n             output.push('(');\n             for &component_type in component_types {\n                 push_unique_type_name(tcx, component_type, output);"}, {"sha": "f46ab8257361c48c84de18a41d13465716e946ad", "filename": "src/librustc_trans/common.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/20652162ca5e330cb9d637924c6d93cb43fbb6aa/src%2Flibrustc_trans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20652162ca5e330cb9d637924c6d93cb43fbb6aa/src%2Flibrustc_trans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcommon.rs?ref=20652162ca5e330cb9d637924c6d93cb43fbb6aa", "patch": "@@ -496,15 +496,15 @@ impl<'a, 'tcx> FunctionContext<'a, 'tcx> {\n             return Callee::def(ccx, def_id, tcx.mk_substs(Substs::empty()));\n         }\n \n-        let ty = tcx.mk_fn_ptr(ty::BareFnTy {\n+        let ty = tcx.mk_fn_ptr(tcx.mk_bare_fn(ty::BareFnTy {\n             unsafety: hir::Unsafety::Unsafe,\n             abi: Abi::C,\n             sig: ty::Binder(ty::FnSig {\n                 inputs: vec![tcx.mk_mut_ptr(tcx.types.u8)],\n                 output: ty::FnDiverging,\n                 variadic: false\n             }),\n-        });\n+        }));\n \n         let unwresume = ccx.eh_unwind_resume();\n         if let Some(llfn) = unwresume.get() {"}, {"sha": "7775ed3fc68ae015e0d58b8866ff57194be31a9b", "filename": "src/librustc_trans/consts.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/20652162ca5e330cb9d637924c6d93cb43fbb6aa/src%2Flibrustc_trans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20652162ca5e330cb9d637924c6d93cb43fbb6aa/src%2Flibrustc_trans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fconsts.rs?ref=20652162ca5e330cb9d637924c6d93cb43fbb6aa", "patch": "@@ -194,7 +194,7 @@ fn const_deref<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n fn const_fn_call<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                            def_id: DefId,\n-                           substs: Substs<'tcx>,\n+                           substs: &'tcx Substs<'tcx>,\n                            arg_vals: &[ValueRef],\n                            param_substs: &'tcx Substs<'tcx>,\n                            trueconst: TrueConst) -> Result<ValueRef, ConstEvalFailure> {\n@@ -212,10 +212,10 @@ fn const_fn_call<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     let arg_ids = args.iter().map(|arg| arg.pat.id);\n     let fn_args = arg_ids.zip(arg_vals.iter().cloned()).collect();\n \n+    let substs = ccx.tcx().mk_substs(substs.clone().erase_regions());\n     let substs = monomorphize::apply_param_substs(ccx.tcx(),\n                                                   param_substs,\n-                                                  &substs.erase_regions());\n-    let substs = ccx.tcx().mk_substs(substs);\n+                                                  &substs);\n \n     const_expr(ccx, body, substs, Some(&fn_args), trueconst).map(|(res, _)| res)\n }\n@@ -226,9 +226,10 @@ pub fn get_const_expr<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                 param_substs: &'tcx Substs<'tcx>)\n                                 -> &'tcx hir::Expr {\n     let substs = ccx.tcx().node_id_item_substs(ref_expr.id).substs;\n+    let substs = ccx.tcx().mk_substs(substs.clone().erase_regions());\n     let substs = monomorphize::apply_param_substs(ccx.tcx(),\n                                                   param_substs,\n-                                                  &substs.erase_regions());\n+                                                  &substs);\n     match lookup_const_by_id(ccx.tcx(), def_id, Some(substs)) {\n         Some((ref expr, _ty)) => expr,\n         None => {\n@@ -968,7 +969,7 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             let arg_vals = map_list(args)?;\n             let method_call = ty::MethodCall::expr(e.id);\n             let method = cx.tcx().tables.borrow().method_map[&method_call];\n-            const_fn_call(cx, method.def_id, method.substs.clone(),\n+            const_fn_call(cx, method.def_id, method.substs,\n                           &arg_vals, param_substs, trueconst)?\n         },\n         hir::ExprType(ref e, _) => const_expr(cx, &e, param_substs, fn_args, trueconst)?.0,\n@@ -986,7 +987,7 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         },\n         hir::ExprClosure(_, ref decl, ref body, _) => {\n             match ety.sty {\n-                ty::TyClosure(def_id, ref substs) => {\n+                ty::TyClosure(def_id, substs) => {\n                     closure::trans_closure_expr(closure::Dest::Ignore(cx),\n                                                 decl,\n                                                 body,"}, {"sha": "7826693c827101a0139f1fcaba87ab9e770a8feb", "filename": "src/librustc_trans/debuginfo/metadata.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/20652162ca5e330cb9d637924c6d93cb43fbb6aa/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20652162ca5e330cb9d637924c6d93cb43fbb6aa/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs?ref=20652162ca5e330cb9d637924c6d93cb43fbb6aa", "patch": "@@ -187,10 +187,10 @@ impl<'tcx> TypeMap<'tcx> {\n                 unique_type_id.push_str(\"struct \");\n                 from_def_id_and_substs(self, cx, def.did, substs, &mut unique_type_id);\n             },\n-            ty::TyTuple(ref component_types) if component_types.is_empty() => {\n+            ty::TyTuple(component_types) if component_types.is_empty() => {\n                 push_debuginfo_type_name(cx, type_, false, &mut unique_type_id);\n             },\n-            ty::TyTuple(ref component_types) => {\n+            ty::TyTuple(component_types) => {\n                 unique_type_id.push_str(\"tuple \");\n                 for &component_type in component_types {\n                     let component_type_id =\n@@ -289,12 +289,12 @@ impl<'tcx> TypeMap<'tcx> {\n                     }\n                 }\n             },\n-            ty::TyClosure(_, ref substs) if substs.upvar_tys.is_empty() => {\n+            ty::TyClosure(_, substs) if substs.upvar_tys.is_empty() => {\n                 push_debuginfo_type_name(cx, type_, false, &mut unique_type_id);\n             },\n-            ty::TyClosure(_, ref substs) => {\n+            ty::TyClosure(_, substs) => {\n                 unique_type_id.push_str(\"closure \");\n-                for upvar_type in &substs.upvar_tys {\n+                for upvar_type in substs.upvar_tys {\n                     let upvar_type_id =\n                         self.get_unique_type_id_of_type(cx, upvar_type);\n                     let upvar_type_id ="}, {"sha": "db4a82c7b0be7b90d04804f702c96ffabc3d2060", "filename": "src/librustc_trans/debuginfo/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/20652162ca5e330cb9d637924c6d93cb43fbb6aa/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20652162ca5e330cb9d637924c6d93cb43fbb6aa/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs?ref=20652162ca5e330cb9d637924c6d93cb43fbb6aa", "patch": "@@ -343,7 +343,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         }\n \n         if abi == Abi::RustCall && !sig.inputs.is_empty() {\n-            if let ty::TyTuple(ref args) = sig.inputs[sig.inputs.len() - 1].sty {\n+            if let ty::TyTuple(args) = sig.inputs[sig.inputs.len() - 1].sty {\n                 for &argument_type in args {\n                     signature.push(type_metadata(cx, argument_type, codemap::DUMMY_SP));\n                 }"}, {"sha": "63f460e4693d56be227fb0daf7a09d20018d4afa", "filename": "src/librustc_trans/debuginfo/type_names.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/20652162ca5e330cb9d637924c6d93cb43fbb6aa/src%2Flibrustc_trans%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20652162ca5e330cb9d637924c6d93cb43fbb6aa/src%2Flibrustc_trans%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Ftype_names.rs?ref=20652162ca5e330cb9d637924c6d93cb43fbb6aa", "patch": "@@ -48,7 +48,7 @@ pub fn push_debuginfo_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             push_item_name(cx, def.did, qualified, output);\n             push_type_params(cx, substs, output);\n         },\n-        ty::TyTuple(ref component_types) => {\n+        ty::TyTuple(component_types) => {\n             output.push('(');\n             for &component_type in component_types {\n                 push_debuginfo_type_name(cx, component_type, true, output);"}, {"sha": "b87456318cd169e95ab3f477b9b5d4bc9c1e272c", "filename": "src/librustc_trans/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/20652162ca5e330cb9d637924c6d93cb43fbb6aa/src%2Flibrustc_trans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20652162ca5e330cb9d637924c6d93cb43fbb6aa/src%2Flibrustc_trans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fexpr.rs?ref=20652162ca5e330cb9d637924c6d93cb43fbb6aa", "patch": "@@ -1134,7 +1134,7 @@ fn trans_rvalue_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             // the key we need to find the closure-kind and\n             // closure-type etc.\n             let (def_id, substs) = match expr_ty(bcx, expr).sty {\n-                ty::TyClosure(def_id, ref substs) => (def_id, substs),\n+                ty::TyClosure(def_id, substs) => (def_id, substs),\n                 ref t =>\n                     span_bug!(\n                         expr.span,"}, {"sha": "640ac25a5e31cc666556f6982c71dd20073a178a", "filename": "src/librustc_trans/intrinsic.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/20652162ca5e330cb9d637924c6d93cb43fbb6aa/src%2Flibrustc_trans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20652162ca5e330cb9d637924c6d93cb43fbb6aa/src%2Flibrustc_trans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fintrinsic.rs?ref=20652162ca5e330cb9d637924c6d93cb43fbb6aa", "patch": "@@ -1259,11 +1259,11 @@ fn gen_fn<'a, 'tcx>(fcx: &FunctionContext<'a, 'tcx>,\n     };\n     let fn_ty = FnType::new(ccx, Abi::Rust, &sig, &[]);\n \n-    let rust_fn_ty = ccx.tcx().mk_fn_ptr(ty::BareFnTy {\n+    let rust_fn_ty = ccx.tcx().mk_fn_ptr(ccx.tcx().mk_bare_fn(ty::BareFnTy {\n         unsafety: hir::Unsafety::Unsafe,\n         abi: Abi::Rust,\n         sig: ty::Binder(sig)\n-    });\n+    }));\n     let llfn = declare::define_internal_fn(ccx, name, rust_fn_ty);\n     let (fcx, block_arena);\n     block_arena = TypedArena::new();\n@@ -1289,15 +1289,15 @@ fn get_rust_try_fn<'a, 'tcx>(fcx: &FunctionContext<'a, 'tcx>,\n     // Define the type up front for the signature of the rust_try function.\n     let tcx = ccx.tcx();\n     let i8p = tcx.mk_mut_ptr(tcx.types.i8);\n-    let fn_ty = tcx.mk_fn_ptr(ty::BareFnTy {\n+    let fn_ty = tcx.mk_fn_ptr(tcx.mk_bare_fn(ty::BareFnTy {\n         unsafety: hir::Unsafety::Unsafe,\n         abi: Abi::Rust,\n         sig: ty::Binder(ty::FnSig {\n             inputs: vec![i8p],\n             output: ty::FnOutput::FnConverging(tcx.mk_nil()),\n             variadic: false,\n         }),\n-    });\n+    }));\n     let output = ty::FnOutput::FnConverging(tcx.types.i32);\n     let rust_try = gen_fn(fcx, \"__rust_try\", vec![fn_ty, i8p, i8p], output, trans);\n     ccx.rust_try_fn().set(Some(rust_try));"}, {"sha": "c1be6daefd3b85c7b4f17eacfa5012bf3fc76f84", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/20652162ca5e330cb9d637924c6d93cb43fbb6aa/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20652162ca5e330cb9d637924c6d93cb43fbb6aa/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=20652162ca5e330cb9d637924c6d93cb43fbb6aa", "patch": "@@ -445,7 +445,7 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                             return Ok(Const::new(C_null(llty), ty));\n                         }\n \n-                        let substs = self.ccx.tcx().mk_substs(self.monomorphize(substs));\n+                        let substs = self.monomorphize(&substs);\n                         let instance = Instance::new(def_id, substs);\n                         MirConstContext::trans_def(self.ccx, instance, vec![])\n                     }\n@@ -509,7 +509,7 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                                                     span: DUMMY_SP\n                                                 },\n                                                 DUMMY_NODE_ID, def_id,\n-                                                &self.monomorphize(substs));\n+                                                self.monomorphize(&substs));\n                 }\n \n                 let val = if let mir::AggregateKind::Adt(adt_def, index, _) = *kind {\n@@ -821,7 +821,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                     return Const::new(C_null(llty), ty);\n                 }\n \n-                let substs = bcx.tcx().mk_substs(bcx.monomorphize(substs));\n+                let substs = bcx.monomorphize(&substs);\n                 let instance = Instance::new(def_id, substs);\n                 MirConstContext::trans_def(bcx.ccx(), instance, vec![])\n             }"}, {"sha": "3fb22c6bd55da6c390cf462297319a1220c8bc7b", "filename": "src/librustc_trans/mir/rvalue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/20652162ca5e330cb9d637924c6d93cb43fbb6aa/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20652162ca5e330cb9d637924c6d93cb43fbb6aa/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Frvalue.rs?ref=20652162ca5e330cb9d637924c6d93cb43fbb6aa", "patch": "@@ -156,7 +156,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                                                             span: DUMMY_SP\n                                                         },\n                                                         DUMMY_NODE_ID, def_id,\n-                                                        &bcx.monomorphize(substs));\n+                                                        bcx.monomorphize(&substs));\n                         }\n \n                         for (i, operand) in operands.iter().enumerate() {"}, {"sha": "090867a4bf8a2ae91753f3c78bc751b8e23935c9", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/20652162ca5e330cb9d637924c6d93cb43fbb6aa/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20652162ca5e330cb9d637924c6d93cb43fbb6aa/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=20652162ca5e330cb9d637924c6d93cb43fbb6aa", "patch": "@@ -1742,7 +1742,7 @@ struct SelfInfo<'a, 'tcx> {\n pub fn ty_of_method<'tcx>(this: &AstConv<'tcx, 'tcx>,\n                           sig: &hir::MethodSig,\n                           untransformed_self_ty: Ty<'tcx>)\n-                          -> (ty::BareFnTy<'tcx>, ty::ExplicitSelfCategory) {\n+                          -> (&'tcx ty::BareFnTy<'tcx>, ty::ExplicitSelfCategory) {\n     let self_info = Some(SelfInfo {\n         untransformed_self_ty: untransformed_self_ty,\n         explicit_self: &sig.explicit_self,\n@@ -1756,8 +1756,10 @@ pub fn ty_of_method<'tcx>(this: &AstConv<'tcx, 'tcx>,\n     (bare_fn_ty, optional_explicit_self_category.unwrap())\n }\n \n-pub fn ty_of_bare_fn<'tcx>(this: &AstConv<'tcx, 'tcx>, unsafety: hir::Unsafety, abi: abi::Abi,\n-                                              decl: &hir::FnDecl) -> ty::BareFnTy<'tcx> {\n+pub fn ty_of_bare_fn<'tcx>(this: &AstConv<'tcx, 'tcx>,\n+                           unsafety: hir::Unsafety, abi: abi::Abi,\n+                           decl: &hir::FnDecl)\n+                           -> &'tcx ty::BareFnTy<'tcx> {\n     let (bare_fn_ty, _) = ty_of_method_or_bare_fn(this, unsafety, abi, None, decl);\n     bare_fn_ty\n }\n@@ -1767,7 +1769,8 @@ fn ty_of_method_or_bare_fn<'a, 'tcx>(this: &AstConv<'tcx, 'tcx>,\n                                      abi: abi::Abi,\n                                      opt_self_info: Option<SelfInfo<'a, 'tcx>>,\n                                      decl: &hir::FnDecl)\n-                                     -> (ty::BareFnTy<'tcx>, Option<ty::ExplicitSelfCategory>)\n+                                     -> (&'tcx ty::BareFnTy<'tcx>,\n+                                         Option<ty::ExplicitSelfCategory>)\n {\n     debug!(\"ty_of_method_or_bare_fn\");\n \n@@ -1813,15 +1816,15 @@ fn ty_of_method_or_bare_fn<'a, 'tcx>(this: &AstConv<'tcx, 'tcx>,\n         hir::NoReturn(..) => ty::FnDiverging\n     };\n \n-    (ty::BareFnTy {\n+    (this.tcx().mk_bare_fn(ty::BareFnTy {\n         unsafety: unsafety,\n         abi: abi,\n         sig: ty::Binder(ty::FnSig {\n             inputs: self_ty.into_iter().chain(arg_tys).collect(),\n             output: output_ty,\n             variadic: decl.variadic\n         }),\n-    }, explicit_self_category)\n+    }), explicit_self_category)\n }\n \n fn determine_self_type<'a, 'tcx>(this: &AstConv<'tcx, 'tcx>,"}, {"sha": "394ecf5fbeff117fe502d66a05e1d7044d4786c1", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/20652162ca5e330cb9d637924c6d93cb43fbb6aa/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20652162ca5e330cb9d637924c6d93cb43fbb6aa/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=20652162ca5e330cb9d637924c6d93cb43fbb6aa", "patch": "@@ -609,7 +609,9 @@ pub fn check_pat_struct(&self, pat: &'tcx hir::Pat,\n     self.check_struct_pat_fields(pat.span, fields, variant, &item_substs, etc);\n \n     self.write_ty(pat.id, pat_ty);\n-    self.write_substs(pat.id, ty::ItemSubsts { substs: item_substs.clone() });\n+    self.write_substs(pat.id, ty::ItemSubsts {\n+        substs: item_substs\n+    });\n }\n \n fn check_pat_enum(&self,"}, {"sha": "a0565a9870c92cb47a8946eeeeed5e516d169084", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/20652162ca5e330cb9d637924c6d93cb43fbb6aa/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20652162ca5e330cb9d637924c6d93cb43fbb6aa/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=20652162ca5e330cb9d637924c6d93cb43fbb6aa", "patch": "@@ -122,7 +122,7 @@ fn try_overloaded_call_step(&self,\n             return Some(CallStep::Builtin);\n         }\n \n-        ty::TyClosure(def_id, ref substs) => {\n+        ty::TyClosure(def_id, substs) => {\n             assert_eq!(def_id.krate, LOCAL_CRATE);\n \n             // Check whether this is a call to a closure where we"}, {"sha": "ad92c3fb072b75d76b3ae74c1bccd1bf3e09774f", "filename": "src/librustc_typeck/check/cast.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/20652162ca5e330cb9d637924c6d93cb43fbb6aa/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20652162ca5e330cb9d637924c6d93cb43fbb6aa/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs?ref=20652162ca5e330cb9d637924c6d93cb43fbb6aa", "patch": "@@ -320,8 +320,7 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n             (None, Some(t_cast)) => {\n                 if let ty::TyFnDef(_, _, f) = self.expr_ty.sty {\n                     // Attempt a coercion to a fn pointer type.\n-                    let res = fcx.try_coerce(self.expr,\n-                                             fcx.tcx.mk_ty(ty::TyFnPtr(f)));\n+                    let res = fcx.try_coerce(self.expr, fcx.tcx.mk_fn_ptr(f));\n                     if !res.is_ok() {\n                         return Err(CastError::NonScalar);\n                     }"}, {"sha": "c60020f51ae18fe29001b53e93a97398ef7fb2ff", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/20652162ca5e330cb9d637924c6d93cb43fbb6aa/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20652162ca5e330cb9d637924c6d93cb43fbb6aa/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=20652162ca5e330cb9d637924c6d93cb43fbb6aa", "patch": "@@ -217,7 +217,7 @@ fn deduce_sig_from_projection(&self,\n     debug!(\"deduce_sig_from_projection: arg_param_ty {:?}\", arg_param_ty);\n \n     let input_tys = match arg_param_ty.sty {\n-        ty::TyTuple(ref tys) => { (*tys).clone() }\n+        ty::TyTuple(tys) => tys.to_vec(),\n         _ => { return None; }\n     };\n     debug!(\"deduce_sig_from_projection: input_tys {:?}\", input_tys);"}, {"sha": "1e7a9c5b635932c53ab759d0c6f01f6b863b65f5", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/20652162ca5e330cb9d637924c6d93cb43fbb6aa/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20652162ca5e330cb9d637924c6d93cb43fbb6aa/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=20652162ca5e330cb9d637924c6d93cb43fbb6aa", "patch": "@@ -546,7 +546,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx, 'tcx> {\n \n         match b.sty {\n             ty::TyFnPtr(_) => {\n-                let a_fn_pointer = self.tcx.mk_ty(ty::TyFnPtr(fn_ty_a));\n+                let a_fn_pointer = self.tcx.mk_fn_ptr(fn_ty_a);\n                 self.unify_and_identity(a_fn_pointer, b).map(|(ty, _)| {\n                     (ty, AdjustReifyFnPointer)\n                 })\n@@ -667,7 +667,7 @@ pub fn try_find_coercion_lub<'b, E, I>(&self,\n         (&ty::TyFnDef(a_def_id, a_substs, a_fty),\n          &ty::TyFnDef(b_def_id, b_substs, b_fty)) => {\n             // The signature must always match.\n-            let fty = self.lub(true, trace.clone(), a_fty, b_fty)\n+            let fty = self.lub(true, trace.clone(), &a_fty, &b_fty)\n                 .map(|InferOk { value, obligations }| {\n                     // FIXME(#32730) propagate obligations\n                     assert!(obligations.is_empty());\n@@ -677,13 +677,13 @@ pub fn try_find_coercion_lub<'b, E, I>(&self,\n             if a_def_id == b_def_id {\n                 // Same function, maybe the parameters match.\n                 let substs = self.commit_if_ok(|_| {\n-                    self.lub(true, trace.clone(), a_substs, b_substs)\n+                    self.lub(true, trace.clone(), &a_substs, &b_substs)\n                         .map(|InferOk { value, obligations }| {\n                             // FIXME(#32730) propagate obligations\n                             assert!(obligations.is_empty());\n                             value\n                         })\n-                }).map(|s| self.tcx.mk_substs(s));\n+                });\n \n                 if let Ok(substs) = substs {\n                     // We have a LUB of prev_ty and new_ty, just return it."}, {"sha": "fc02506b1cd8252da39a16aa738121c3870bbe9a", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/20652162ca5e330cb9d637924c6d93cb43fbb6aa/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20652162ca5e330cb9d637924c6d93cb43fbb6aa/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=20652162ca5e330cb9d637924c6d93cb43fbb6aa", "patch": "@@ -178,7 +178,7 @@ pub fn compare_impl_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     // Create mapping from trait to skolemized.\n     let trait_to_skol_substs =\n         trait_to_impl_substs\n-        .subst(tcx, impl_to_skol_substs)\n+        .subst(tcx, impl_to_skol_substs).clone()\n         .with_method(impl_to_skol_substs.types.get_slice(subst::FnSpace).to_vec(),\n                      impl_to_skol_substs.regions.get_slice(subst::FnSpace).to_vec());\n     debug!(\"compare_impl_method: trait_to_skol_substs={:?}\",\n@@ -279,9 +279,9 @@ pub fn compare_impl_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         // type.\n \n         // Compute skolemized form of impl and trait method tys.\n-        let impl_fty = tcx.mk_fn_ptr(impl_m.fty.clone());\n+        let impl_fty = tcx.mk_fn_ptr(impl_m.fty);\n         let impl_fty = impl_fty.subst(tcx, impl_to_skol_substs);\n-        let trait_fty = tcx.mk_fn_ptr(trait_m.fty.clone());\n+        let trait_fty = tcx.mk_fn_ptr(trait_m.fty);\n         let trait_fty = trait_fty.subst(tcx, &trait_to_skol_substs);\n \n         let err = infcx.commit_if_ok(|snapshot| {\n@@ -299,11 +299,11 @@ pub fn compare_impl_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                                      impl_m_span,\n                                                      impl_m_body_id,\n                                                      &impl_sig);\n-            let impl_fty = tcx.mk_fn_ptr(ty::BareFnTy {\n+            let impl_fty = tcx.mk_fn_ptr(tcx.mk_bare_fn(ty::BareFnTy {\n                 unsafety: impl_m.fty.unsafety,\n                 abi: impl_m.fty.abi,\n                 sig: ty::Binder(impl_sig)\n-            });\n+            }));\n             debug!(\"compare_impl_method: impl_fty={:?}\",\n                    impl_fty);\n \n@@ -317,11 +317,11 @@ pub fn compare_impl_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                                      impl_m_span,\n                                                      impl_m_body_id,\n                                                      &trait_sig);\n-            let trait_fty = tcx.mk_fn_ptr(ty::BareFnTy {\n+            let trait_fty = tcx.mk_fn_ptr(tcx.mk_bare_fn(ty::BareFnTy {\n                 unsafety: trait_m.fty.unsafety,\n                 abi: trait_m.fty.abi,\n                 sig: ty::Binder(trait_sig)\n-            });\n+            }));\n \n             debug!(\"compare_impl_method: trait_fty={:?}\",\n                    trait_fty);\n@@ -442,7 +442,7 @@ pub fn compare_const_impl<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         // Create mapping from trait to skolemized.\n         let trait_to_skol_substs =\n             trait_to_impl_substs\n-            .subst(tcx, impl_to_skol_substs)\n+            .subst(tcx, impl_to_skol_substs).clone()\n             .with_method(impl_to_skol_substs.types.get_slice(subst::FnSpace).to_vec(),\n                          impl_to_skol_substs.regions.get_slice(subst::FnSpace).to_vec());\n         debug!(\"compare_const_impl: trait_to_skol_substs={:?}\","}, {"sha": "c5e7606106f11ac733cc5235a36c8223b2bc07ce", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/20652162ca5e330cb9d637924c6d93cb43fbb6aa/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20652162ca5e330cb9d637924c6d93cb43fbb6aa/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=20652162ca5e330cb9d637924c6d93cb43fbb6aa", "patch": "@@ -469,8 +469,8 @@ fn iterate_over_potentially_unsafe_regions_in_type<'a, 'b, 'tcx>(\n             Ok(())\n         }\n \n-        ty::TyTuple(ref tys) |\n-        ty::TyClosure(_, box ty::ClosureSubsts { upvar_tys: ref tys, .. }) => {\n+        ty::TyTuple(tys) |\n+        ty::TyClosure(_, ty::ClosureSubsts { upvar_tys: tys, .. }) => {\n             for ty in tys {\n                 iterate_over_potentially_unsafe_regions_in_type(cx, context, ty, depth+1)?\n             }"}, {"sha": "6243d191dcbaaca25c03bfa13d2fb0e2cd700caa", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/20652162ca5e330cb9d637924c6d93cb43fbb6aa/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20652162ca5e330cb9d637924c6d93cb43fbb6aa/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=20652162ca5e330cb9d637924c6d93cb43fbb6aa", "patch": "@@ -38,15 +38,16 @@ fn equate_intrinsic_type<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     let mut substs = Substs::empty();\n     substs.types = i_ty.generics.types.map(|def| tcx.mk_param_from_def(def));\n \n-    let fty = tcx.mk_fn_def(def_id, tcx.mk_substs(substs), ty::BareFnTy {\n+    let fty = tcx.mk_fn_def(def_id, tcx.mk_substs(substs),\n+                            tcx.mk_bare_fn(ty::BareFnTy {\n         unsafety: hir::Unsafety::Unsafe,\n         abi: abi,\n         sig: ty::Binder(FnSig {\n             inputs: inputs,\n             output: output,\n             variadic: false,\n         }),\n-    });\n+    }));\n     let i_n_tps = i_ty.generics.types.len(subst::FnSpace);\n     if i_n_tps != n_tps {\n         span_err!(tcx.sess, it.span, E0094,\n@@ -285,15 +286,15 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &hir::ForeignItem) {\n \n             \"try\" => {\n                 let mut_u8 = tcx.mk_mut_ptr(tcx.types.u8);\n-                let fn_ty = ty::BareFnTy {\n+                let fn_ty = tcx.mk_bare_fn(ty::BareFnTy {\n                     unsafety: hir::Unsafety::Normal,\n                     abi: Abi::Rust,\n                     sig: ty::Binder(FnSig {\n                         inputs: vec![mut_u8],\n                         output: ty::FnOutput::FnConverging(tcx.mk_nil()),\n                         variadic: false,\n                     }),\n-                };\n+                });\n                 (0, vec![tcx.mk_fn_ptr(fn_ty), mut_u8, mut_u8], tcx.types.i32)\n             }\n \n@@ -484,7 +485,7 @@ fn match_intrinsic_type_to_type<'tcx, 'a>(\n         }\n         Aggregate(_flatten, ref expected_contents) => {\n             match t.sty {\n-                ty::TyTuple(ref contents) => {\n+                ty::TyTuple(contents) => {\n                     if contents.len() != expected_contents.len() {\n                         simple_error(&format!(\"tuple with length {}\", contents.len()),\n                                      &format!(\"tuple with length {}\", expected_contents.len()));"}, {"sha": "47098599df25ac46d866e966fafeeb4c881fc611", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/20652162ca5e330cb9d637924c6d93cb43fbb6aa/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20652162ca5e330cb9d637924c6d93cb43fbb6aa/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=20652162ca5e330cb9d637924c6d93cb43fbb6aa", "patch": "@@ -117,11 +117,12 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx, 'tcx> {\n         // Create the method type\n         let def_id = pick.item.def_id();\n         let method_ty = pick.item.as_opt_method().unwrap();\n-        let fty = self.tcx.mk_fn_def(def_id, all_substs, ty::BareFnTy {\n+        let fty = self.tcx.mk_fn_def(def_id, all_substs,\n+                                     self.tcx.mk_bare_fn(ty::BareFnTy {\n             sig: ty::Binder(method_sig),\n             unsafety: method_ty.fty.unsafety,\n             abi: method_ty.fty.abi.clone(),\n-        });\n+        }));\n \n         // Add any trait/regions obligations specified on the method's type parameters.\n         self.add_obligations(fty, all_substs, &method_predicates);"}, {"sha": "8d6cc217b8ba2b2760e127c141b8db878c6e4b44", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/20652162ca5e330cb9d637924c6d93cb43fbb6aa/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20652162ca5e330cb9d637924c6d93cb43fbb6aa/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=20652162ca5e330cb9d637924c6d93cb43fbb6aa", "patch": "@@ -240,11 +240,12 @@ pub fn lookup_method_in_trait_adjusted(&self,\n     let fn_sig = self.instantiate_type_scheme(span, trait_ref.substs, &fn_sig);\n     let transformed_self_ty = fn_sig.inputs[0];\n     let def_id = method_item.def_id();\n-    let fty = tcx.mk_fn_def(def_id, trait_ref.substs, ty::BareFnTy {\n+    let fty = tcx.mk_fn_def(def_id, trait_ref.substs,\n+                            tcx.mk_bare_fn(ty::BareFnTy {\n         sig: ty::Binder(fn_sig),\n         unsafety: method_ty.fty.unsafety,\n         abi: method_ty.fty.abi.clone(),\n-    });\n+    }));\n \n     debug!(\"lookup_in_trait_adjusted: matched method fty={:?} obligation={:?}\",\n            fty,"}, {"sha": "edaac66763c8fdc4f58c01fb8eeb313d57e0a7ea", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/20652162ca5e330cb9d637924c6d93cb43fbb6aa/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20652162ca5e330cb9d637924c6d93cb43fbb6aa/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=20652162ca5e330cb9d637924c6d93cb43fbb6aa", "patch": "@@ -2506,7 +2506,7 @@ fn check_argument_types(&self,\n     let formal_tys = if tuple_arguments == TupleArguments {\n         let tuple_type = self.structurally_resolved_type(sp, fn_inputs[0]);\n         match tuple_type.sty {\n-            ty::TyTuple(ref arg_types) => {\n+            ty::TyTuple(arg_types) => {\n                 if arg_types.len() != args.len() {\n                     span_err!(tcx.sess, sp, E0057,\n                         \"this function takes {} parameter{} but {} parameter{} supplied\",\n@@ -2524,7 +2524,7 @@ fn check_argument_types(&self,\n                         },\n                         None => &[]\n                     };\n-                    (*arg_types).clone()\n+                    arg_types.to_vec()\n                 }\n             }\n             _ => {\n@@ -2682,7 +2682,7 @@ fn check_argument_types(&self,\n                     }, arg_ty, None);\n                 }\n                 ty::TyFnDef(_, _, f) => {\n-                    let ptr_ty = self.tcx.mk_ty(ty::TyFnPtr(f));\n+                    let ptr_ty = self.tcx.mk_fn_ptr(f);\n                     let ptr_ty = self.resolve_type_vars_if_possible(&ptr_ty);\n                     self.type_error_message(arg.span,\n                                             |t| {\n@@ -4326,6 +4326,7 @@ pub fn instantiate_path(&self,\n \n     // The things we are substituting into the type should not contain\n     // escaping late-bound regions, and nor should the base type scheme.\n+    let substs = self.tcx.mk_substs(substs);\n     assert!(!substs.has_regions_escaping_depth(0));\n     assert!(!type_scheme.has_escaping_regions());\n \n@@ -4371,7 +4372,9 @@ pub fn instantiate_path(&self,\n            node_id,\n            ty_substituted);\n     self.write_ty(node_id, ty_substituted);\n-    self.write_substs(node_id, ty::ItemSubsts { substs: substs });\n+    self.write_substs(node_id, ty::ItemSubsts {\n+        substs: substs\n+    });\n }\n \n     /// Finds the parameters that the user provided and adds them to `substs`. If too many"}, {"sha": "3069627a4212815c06397fef33e8646a5ad6da99", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/20652162ca5e330cb9d637924c6d93cb43fbb6aa/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20652162ca5e330cb9d637924c6d93cb43fbb6aa/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=20652162ca5e330cb9d637924c6d93cb43fbb6aa", "patch": "@@ -349,13 +349,13 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n     fn check_fn_or_method<'fcx>(&mut self,\n                                 fcx: &FnCtxt<'fcx,'tcx, 'tcx>,\n                                 span: Span,\n-                                fty: &ty::BareFnTy<'tcx>,\n+                                fty: &'tcx ty::BareFnTy<'tcx>,\n                                 predicates: &ty::InstantiatedPredicates<'tcx>,\n                                 free_id_outlive: CodeExtent,\n                                 implied_bounds: &mut Vec<Ty<'tcx>>)\n     {\n         let free_substs = &fcx.parameter_environment.free_substs;\n-        let fty = fcx.instantiate_type_scheme(span, free_substs, fty);\n+        let fty = fcx.instantiate_type_scheme(span, free_substs, &fty);\n         let sig = fcx.tcx.liberate_late_bound_regions(free_id_outlive, &fty.sig);\n \n         for &input_ty in &sig.inputs {"}, {"sha": "5307753613dcc88122e02f3e1da3c00f3cd5cca2", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/20652162ca5e330cb9d637924c6d93cb43fbb6aa/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20652162ca5e330cb9d637924c6d93cb43fbb6aa/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=20652162ca5e330cb9d637924c6d93cb43fbb6aa", "patch": "@@ -326,7 +326,7 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx, 'tcx> {\n                 let new_method = MethodCallee {\n                     def_id: method.def_id,\n                     ty: self.resolve(&method.ty, reason),\n-                    substs: self.tcx().mk_substs(self.resolve(method.substs, reason)),\n+                    substs: self.resolve(&method.substs, reason),\n                 };\n \n                 Some(new_method)"}, {"sha": "e49df1fc7456b8de35c3853f9ba878dad16b2e19", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/20652162ca5e330cb9d637924c6d93cb43fbb6aa/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20652162ca5e330cb9d637924c6d93cb43fbb6aa/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=20652162ca5e330cb9d637924c6d93cb43fbb6aa", "patch": "@@ -563,7 +563,7 @@ fn convert_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                               sig, untransformed_rcvr_ty);\n \n     let def_id = ccx.tcx.map.local_def_id(id);\n-    let substs = ccx.tcx.mk_substs(mk_item_substs(ccx, &ty_generics));\n+    let substs = mk_item_substs(ccx, &ty_generics);\n \n     let ty_method = ty::Method::new(name,\n                                     ty_generics,\n@@ -575,7 +575,7 @@ fn convert_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                     def_id,\n                                     container);\n \n-    let fty = ccx.tcx.mk_fn_def(def_id, substs, ty_method.fty.clone());\n+    let fty = ccx.tcx.mk_fn_def(def_id, substs, ty_method.fty);\n     debug!(\"method {} (id {}) has type {:?}\",\n             name, id, fty);\n     ccx.tcx.register_item_type(def_id, TypeScheme {\n@@ -953,16 +953,16 @@ fn convert_variant_ctor<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                 .map(|field| field.unsubst_ty())\n                 .collect();\n             let def_id = tcx.map.local_def_id(ctor_id);\n-            let substs = tcx.mk_substs(mk_item_substs(ccx, &scheme.generics));\n-            tcx.mk_fn_def(def_id, substs, ty::BareFnTy {\n+            let substs = mk_item_substs(ccx, &scheme.generics);\n+            tcx.mk_fn_def(def_id, substs, tcx.mk_bare_fn(ty::BareFnTy {\n                 unsafety: hir::Unsafety::Normal,\n                 abi: abi::Abi::Rust,\n                 sig: ty::Binder(ty::FnSig {\n                     inputs: inputs,\n                     output: ty::FnConverging(scheme.ty),\n                     variadic: false\n                 })\n-            })\n+            }))\n         }\n     };\n     write_ty_to_tcx(ccx, ctor_id, ctor_ty);\n@@ -1454,7 +1454,7 @@ fn compute_type_scheme_of_item<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n             let ty_generics = ty_generics_for_fn(ccx, generics, &ty::Generics::empty());\n             let tofd = astconv::ty_of_bare_fn(&ccx.icx(generics), unsafety, abi, &decl);\n             let def_id = ccx.tcx.map.local_def_id(it.id);\n-            let substs = tcx.mk_substs(mk_item_substs(ccx, &ty_generics));\n+            let substs = mk_item_substs(ccx, &ty_generics);\n             let ty = tcx.mk_fn_def(def_id, substs, tofd);\n             ty::TypeScheme { ty: ty, generics: ty_generics }\n         }\n@@ -1467,14 +1467,14 @@ fn compute_type_scheme_of_item<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n             let def = convert_enum_def(ccx, it, ei);\n             let ty_generics = ty_generics_for_type(ccx, generics);\n             let substs = mk_item_substs(ccx, &ty_generics);\n-            let t = tcx.mk_enum(def, tcx.mk_substs(substs));\n+            let t = tcx.mk_enum(def, substs);\n             ty::TypeScheme { ty: t, generics: ty_generics }\n         }\n         hir::ItemStruct(ref si, ref generics) => {\n             let def = convert_struct_def(ccx, it, si);\n             let ty_generics = ty_generics_for_type(ccx, generics);\n             let substs = mk_item_substs(ccx, &ty_generics);\n-            let t = tcx.mk_struct(def, tcx.mk_substs(substs));\n+            let t = tcx.mk_struct(def, substs);\n             ty::TypeScheme { ty: t, generics: ty_generics }\n         }\n         hir::ItemDefaultImpl(..) |\n@@ -2191,14 +2191,14 @@ fn compute_type_scheme_of_foreign_fn_decl<'a, 'tcx>(\n         }\n     }\n \n-    let substs = ccx.tcx.mk_substs(mk_item_substs(ccx, &ty_generics));\n-    let t_fn = ccx.tcx.mk_fn_def(id, substs, ty::BareFnTy {\n+    let substs = mk_item_substs(ccx, &ty_generics);\n+    let t_fn = ccx.tcx.mk_fn_def(id, substs, ccx.tcx.mk_bare_fn(ty::BareFnTy {\n         abi: abi,\n         unsafety: hir::Unsafety::Unsafe,\n         sig: ty::Binder(ty::FnSig {inputs: input_tys,\n                                     output: output,\n                                     variadic: decl.variadic}),\n-    });\n+    }));\n \n     ty::TypeScheme {\n         generics: ty_generics,\n@@ -2208,7 +2208,7 @@ fn compute_type_scheme_of_foreign_fn_decl<'a, 'tcx>(\n \n fn mk_item_substs<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                             ty_generics: &ty::Generics<'tcx>)\n-                            -> Substs<'tcx>\n+                            -> &'tcx Substs<'tcx>\n {\n     let types =\n         ty_generics.types.map(\n@@ -2218,7 +2218,7 @@ fn mk_item_substs<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         ty_generics.regions.map(\n             |def| def.to_early_bound_region());\n \n-    Substs::new(types, regions)\n+    ccx.tcx.mk_substs(Substs::new(types, regions))\n }\n \n /// Checks that all the type parameters on an impl"}, {"sha": "cdc3cfb7d31528632790c58acf152dc81e94ccc9", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/20652162ca5e330cb9d637924c6d93cb43fbb6aa/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20652162ca5e330cb9d637924c6d93cb43fbb6aa/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=20652162ca5e330cb9d637924c6d93cb43fbb6aa", "patch": "@@ -247,15 +247,16 @@ fn check_main_fn_ty(ccx: &CrateCtxt,\n             }\n             let main_def_id = tcx.map.local_def_id(main_id);\n             let substs = tcx.mk_substs(Substs::empty());\n-            let se_ty = tcx.mk_fn_def(main_def_id, substs, ty::BareFnTy {\n+            let se_ty = tcx.mk_fn_def(main_def_id, substs,\n+                                      tcx.mk_bare_fn(ty::BareFnTy {\n                 unsafety: hir::Unsafety::Normal,\n                 abi: Abi::Rust,\n                 sig: ty::Binder(ty::FnSig {\n                     inputs: Vec::new(),\n                     output: ty::FnConverging(tcx.mk_nil()),\n                     variadic: false\n                 })\n-            });\n+            }));\n \n             require_same_types(ccx, None, main_span, main_t, se_ty,\n                                \"main function has wrong type\");\n@@ -292,7 +293,8 @@ fn check_start_fn_ty(ccx: &CrateCtxt,\n \n             let start_def_id = ccx.tcx.map.local_def_id(start_id);\n             let substs = tcx.mk_substs(Substs::empty());\n-            let se_ty = tcx.mk_fn_def(start_def_id, substs, ty::BareFnTy {\n+            let se_ty = tcx.mk_fn_def(start_def_id, substs,\n+                                      tcx.mk_bare_fn(ty::BareFnTy {\n                 unsafety: hir::Unsafety::Normal,\n                 abi: Abi::Rust,\n                 sig: ty::Binder(ty::FnSig {\n@@ -303,7 +305,7 @@ fn check_start_fn_ty(ccx: &CrateCtxt,\n                     output: ty::FnConverging(tcx.types.isize),\n                     variadic: false,\n                 }),\n-            });\n+            }));\n \n             require_same_types(ccx, None, start_span, start_t, se_ty,\n                                \"start function has wrong type\");"}, {"sha": "a532f9744f49813346a6c7a686540a1b1fc4f729", "filename": "src/librustc_typeck/variance/constraints.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/20652162ca5e330cb9d637924c6d93cb43fbb6aa/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20652162ca5e330cb9d637924c6d93cb43fbb6aa/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs?ref=20652162ca5e330cb9d637924c6d93cb43fbb6aa", "patch": "@@ -345,7 +345,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                 self.add_constraints_from_mt(generics, mt, variance);\n             }\n \n-            ty::TyTuple(ref subtys) => {\n+            ty::TyTuple(subtys) => {\n                 for &subty in subtys {\n                     self.add_constraints_from_ty(generics, subty, variance);\n                 }"}, {"sha": "09761e368ff3799d8e8b1938af65d8c5640ed115", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/20652162ca5e330cb9d637924c6d93cb43fbb6aa/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20652162ca5e330cb9d637924c6d93cb43fbb6aa/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=20652162ca5e330cb9d637924c6d93cb43fbb6aa", "patch": "@@ -731,7 +731,7 @@ impl<'tcx> Clean<TyParamBound> for ty::TraitRef<'tcx> {\n         // collect any late bound regions\n         let mut late_bounds = vec![];\n         for &ty_s in self.substs.types.get_slice(ParamSpace::TypeSpace) {\n-            if let ty::TyTuple(ref ts) = ty_s.sty {\n+            if let ty::TyTuple(ts) = ty_s.sty {\n                 for &ty_s in ts {\n                     if let ty::TyRef(ref reg, _) = ty_s.sty {\n                         if let &ty::Region::ReLateBound(_, _) = *reg {"}]}