{"sha": "f5d8117c338a788bd24abec733fd143dfceb25a0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY1ZDgxMTdjMzM4YTc4OGJkMjRhYmVjNzMzZmQxNDNkZmNlYjI1YTA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-03-16T19:19:06Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-03-16T19:19:06Z"}, "message": "Auto merge of #82536 - sexxi-goose:handle-patterns-take-2, r=nikomatsakis\n\n2229: Handle patterns within closures correctly when `capture_disjoint_fields` is enabled\n\nThis PR fixes several issues related to handling patterns within closures when `capture_disjoint_fields` is enabled.\n1. Matching is always considered a use of the place, even with `_` patterns\n2. Compiler ICE when capturing fields in closures through `let` assignments\n\nTo do so, we\n\n- Introduced new Fake Reads\n- Delayed use of `Place` in favor of `PlaceBuilder`\n- Ensured that `PlaceBuilder` can be resolved before attempting to extract `Place` in any of the pattern matching code\n\nCloses rust-lang/project-rfc-2229/issues/27\nCloses rust-lang/project-rfc-2229/issues/24\nr? `@nikomatsakis`", "tree": {"sha": "7d7b09a0063f53177a087b6c3ae9e2fa2d2b0f87", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7d7b09a0063f53177a087b6c3ae9e2fa2d2b0f87"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f5d8117c338a788bd24abec733fd143dfceb25a0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f5d8117c338a788bd24abec733fd143dfceb25a0", "html_url": "https://github.com/rust-lang/rust/commit/f5d8117c338a788bd24abec733fd143dfceb25a0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f5d8117c338a788bd24abec733fd143dfceb25a0/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1d6754d6eb1ac349477760a2afcd51cf75ac1a1c", "url": "https://api.github.com/repos/rust-lang/rust/commits/1d6754d6eb1ac349477760a2afcd51cf75ac1a1c", "html_url": "https://github.com/rust-lang/rust/commit/1d6754d6eb1ac349477760a2afcd51cf75ac1a1c"}, {"sha": "189d2065229944258fe8f621c5e1ec4386b637d4", "url": "https://api.github.com/repos/rust-lang/rust/commits/189d2065229944258fe8f621c5e1ec4386b637d4", "html_url": "https://github.com/rust-lang/rust/commit/189d2065229944258fe8f621c5e1ec4386b637d4"}], "stats": {"total": 1600, "additions": 1473, "deletions": 127}, "files": [{"sha": "61865a67d25bb545e7c409f34d3c84fbd0ba9e6b", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/f5d8117c338a788bd24abec733fd143dfceb25a0/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5d8117c338a788bd24abec733fd143dfceb25a0/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=f5d8117c338a788bd24abec733fd143dfceb25a0", "patch": "@@ -47,6 +47,7 @@ use rustc_hir::{\n };\n use rustc_index::vec::{Idx, IndexVec};\n use rustc_macros::HashStable;\n+use rustc_middle::mir::FakeReadCause;\n use rustc_serialize::opaque::{FileEncodeResult, FileEncoder};\n use rustc_session::config::{BorrowckMode, CrateType, OutputFilenames};\n use rustc_session::lint::{Level, Lint};\n@@ -430,6 +431,30 @@ pub struct TypeckResults<'tcx> {\n     /// see `MinCaptureInformationMap` for more details.\n     pub closure_min_captures: ty::MinCaptureInformationMap<'tcx>,\n \n+    /// Tracks the fake reads required for a closure and the reason for the fake read.\n+    /// When performing pattern matching for closures, there are times we don't end up\n+    /// reading places that are mentioned in a closure (because of _ patterns). However,\n+    /// to ensure the places are initialized, we introduce fake reads.\n+    /// Consider these two examples:\n+    /// ``` (discriminant matching with only wildcard arm)\n+    /// let x: u8;\n+    /// let c = || match x { _ => () };\n+    /// ```\n+    /// In this example, we don't need to actually read/borrow `x` in `c`, and so we don't\n+    /// want to capture it. However, we do still want an error here, because `x` should have\n+    /// to be initialized at the point where c is created. Therefore, we add a \"fake read\"\n+    /// instead.\n+    /// ``` (destructured assignments)\n+    /// let c = || {\n+    ///     let (t1, t2) = t;\n+    /// }\n+    /// ```\n+    /// In the second example, we capture the disjoint fields of `t` (`t.0` & `t.1`), but\n+    /// we never capture `t`. This becomes an issue when we build MIR as we require\n+    /// information on `t` in order to create place `t.0` and `t.1`. We can solve this\n+    /// issue by fake reading `t`.\n+    pub closure_fake_reads: FxHashMap<DefId, Vec<(HirPlace<'tcx>, FakeReadCause, hir::HirId)>>,\n+\n     /// Stores the type, expression, span and optional scope span of all types\n     /// that are live across the yield of this generator (if a generator).\n     pub generator_interior_types: ty::Binder<Vec<GeneratorInteriorTypeCause<'tcx>>>,\n@@ -464,6 +489,7 @@ impl<'tcx> TypeckResults<'tcx> {\n             concrete_opaque_types: Default::default(),\n             closure_captures: Default::default(),\n             closure_min_captures: Default::default(),\n+            closure_fake_reads: Default::default(),\n             generator_interior_types: ty::Binder::dummy(Default::default()),\n             treat_byte_string_as_slice: Default::default(),\n         }\n@@ -715,6 +741,7 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for TypeckResults<'tcx> {\n             ref concrete_opaque_types,\n             ref closure_captures,\n             ref closure_min_captures,\n+            ref closure_fake_reads,\n             ref generator_interior_types,\n             ref treat_byte_string_as_slice,\n         } = *self;\n@@ -750,6 +777,7 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for TypeckResults<'tcx> {\n             concrete_opaque_types.hash_stable(hcx, hasher);\n             closure_captures.hash_stable(hcx, hasher);\n             closure_min_captures.hash_stable(hcx, hasher);\n+            closure_fake_reads.hash_stable(hcx, hasher);\n             generator_interior_types.hash_stable(hcx, hasher);\n             treat_byte_string_as_slice.hash_stable(hcx, hasher);\n         })"}, {"sha": "fbc9c30fe539c59645616852c9ba780c5b554462", "filename": "compiler/rustc_mir_build/src/build/expr/as_place.rs", "status": "modified", "additions": 54, "deletions": 26, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/f5d8117c338a788bd24abec733fd143dfceb25a0/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5d8117c338a788bd24abec733fd143dfceb25a0/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs?ref=f5d8117c338a788bd24abec733fd143dfceb25a0", "patch": "@@ -10,14 +10,15 @@ use rustc_middle::hir::place::ProjectionKind as HirProjectionKind;\n use rustc_middle::middle::region;\n use rustc_middle::mir::AssertKind::BoundsCheck;\n use rustc_middle::mir::*;\n+use rustc_middle::ty::AdtDef;\n use rustc_middle::ty::{self, CanonicalUserTypeAnnotation, Ty, TyCtxt, Variance};\n use rustc_span::Span;\n use rustc_target::abi::VariantIdx;\n \n use rustc_index::vec::Idx;\n \n /// The \"outermost\" place that holds this value.\n-#[derive(Copy, Clone)]\n+#[derive(Copy, Clone, Debug, PartialEq)]\n crate enum PlaceBase {\n     /// Denotes the start of a `Place`.\n     Local(Local),\n@@ -67,7 +68,7 @@ crate enum PlaceBase {\n ///\n /// This is used internally when building a place for an expression like `a.b.c`. The fields `b`\n /// and `c` can be progressively pushed onto the place builder that is created when converting `a`.\n-#[derive(Clone)]\n+#[derive(Clone, Debug, PartialEq)]\n crate struct PlaceBuilder<'tcx> {\n     base: PlaceBase,\n     projection: Vec<PlaceElem<'tcx>>,\n@@ -83,20 +84,23 @@ fn convert_to_hir_projections_and_truncate_for_capture<'tcx>(\n     mir_projections: &[PlaceElem<'tcx>],\n ) -> Vec<HirProjectionKind> {\n     let mut hir_projections = Vec::new();\n+    let mut variant = None;\n \n     for mir_projection in mir_projections {\n         let hir_projection = match mir_projection {\n             ProjectionElem::Deref => HirProjectionKind::Deref,\n             ProjectionElem::Field(field, _) => {\n-                // We will never encouter this for multivariant enums,\n-                // read the comment for `Downcast`.\n-                HirProjectionKind::Field(field.index() as u32, VariantIdx::new(0))\n+                let variant = variant.unwrap_or(VariantIdx::new(0));\n+                HirProjectionKind::Field(field.index() as u32, variant)\n             }\n-            ProjectionElem::Downcast(..) => {\n-                // This projections exist only for enums that have\n-                // multiple variants. Since such enums that are captured\n-                // completely, we can stop here.\n-                break;\n+            ProjectionElem::Downcast(.., idx) => {\n+                // We don't expect to see multi-variant enums here, as earlier\n+                // phases will have truncated them already. However, there can\n+                // still be downcasts, thanks to single-variant enums.\n+                // We keep track of VariantIdx so we can use this information\n+                // if the next ProjectionElem is a Field.\n+                variant = Some(*idx);\n+                continue;\n             }\n             ProjectionElem::Index(..)\n             | ProjectionElem::ConstantIndex { .. }\n@@ -106,7 +110,7 @@ fn convert_to_hir_projections_and_truncate_for_capture<'tcx>(\n                 break;\n             }\n         };\n-\n+        variant = None;\n         hir_projections.push(hir_projection);\n     }\n \n@@ -194,12 +198,12 @@ fn find_capture_matching_projections<'a, 'tcx>(\n /// Takes a PlaceBuilder and resolves the upvar (if any) within it, so that the\n /// `PlaceBuilder` now starts from `PlaceBase::Local`.\n ///\n-/// Returns a Result with the error being the HirId of the Upvar that was not found.\n+/// Returns a Result with the error being the PlaceBuilder (`from_builder`) that was not found.\n fn to_upvars_resolved_place_builder<'a, 'tcx>(\n     from_builder: PlaceBuilder<'tcx>,\n     tcx: TyCtxt<'tcx>,\n     typeck_results: &'a ty::TypeckResults<'tcx>,\n-) -> Result<PlaceBuilder<'tcx>, HirId> {\n+) -> Result<PlaceBuilder<'tcx>, PlaceBuilder<'tcx>> {\n     match from_builder.base {\n         PlaceBase::Local(_) => Ok(from_builder),\n         PlaceBase::Upvar { var_hir_id, closure_def_id, closure_kind } => {\n@@ -230,13 +234,12 @@ fn to_upvars_resolved_place_builder<'a, 'tcx>(\n                         from_builder.projection\n                     )\n                 } else {\n-                    // FIXME(project-rfc-2229#24): Handle this case properly\n                     debug!(\n                         \"No associated capture found for {:?}[{:#?}]\",\n                         var_hir_id, from_builder.projection,\n                     );\n                 }\n-                return Err(var_hir_id);\n+                return Err(from_builder);\n             };\n \n             let closure_ty = typeck_results\n@@ -300,6 +303,25 @@ impl<'tcx> PlaceBuilder<'tcx> {\n         to_upvars_resolved_place_builder(self, tcx, typeck_results).unwrap()\n     }\n \n+    /// Attempts to resolve the `PlaceBuilder`.\n+    /// On success, it will return the resolved `PlaceBuilder`.\n+    /// On failure, it will return itself.\n+    ///\n+    /// Upvars resolve may fail for a `PlaceBuilder` when attempting to\n+    /// resolve a disjoint field whose root variable is not captured\n+    /// (destructured assignments) or when attempting to resolve a root\n+    /// variable (discriminant matching with only wildcard arm) that is\n+    /// not captured. This can happen because the final mir that will be\n+    /// generated doesn't require a read for this place. Failures will only\n+    /// happen inside closures.\n+    crate fn try_upvars_resolved<'a>(\n+        self,\n+        tcx: TyCtxt<'tcx>,\n+        typeck_results: &'a ty::TypeckResults<'tcx>,\n+    ) -> Result<PlaceBuilder<'tcx>, PlaceBuilder<'tcx>> {\n+        to_upvars_resolved_place_builder(self, tcx, typeck_results)\n+    }\n+\n     crate fn base(&self) -> PlaceBase {\n         self.base\n     }\n@@ -308,15 +330,22 @@ impl<'tcx> PlaceBuilder<'tcx> {\n         self.project(PlaceElem::Field(f, ty))\n     }\n \n-    fn deref(self) -> Self {\n+    crate fn deref(self) -> Self {\n         self.project(PlaceElem::Deref)\n     }\n \n+    crate fn downcast(self, adt_def: &'tcx AdtDef, variant_index: VariantIdx) -> Self {\n+        self.project(PlaceElem::Downcast(\n+            Some(adt_def.variants[variant_index].ident.name),\n+            variant_index,\n+        ))\n+    }\n+\n     fn index(self, index: Local) -> Self {\n         self.project(PlaceElem::Index(index))\n     }\n \n-    fn project(mut self, elem: PlaceElem<'tcx>) -> Self {\n+    crate fn project(mut self, elem: PlaceElem<'tcx>) -> Self {\n         self.projection.push(elem);\n         self\n     }\n@@ -602,13 +631,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         // The \"retagging\" transformation (for Stacked Borrows) relies on this.\n         let idx = unpack!(block = self.as_temp(block, temp_lifetime, index, Mutability::Not,));\n \n-        block = self.bounds_check(\n-            block,\n-            base_place.clone().into_place(self.tcx, self.typeck_results),\n-            idx,\n-            expr_span,\n-            source_info,\n-        );\n+        block = self.bounds_check(block, base_place.clone(), idx, expr_span, source_info);\n \n         if is_outermost_index {\n             self.read_fake_borrows(block, fake_borrow_temps, source_info)\n@@ -629,7 +652,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     fn bounds_check(\n         &mut self,\n         block: BasicBlock,\n-        slice: Place<'tcx>,\n+        slice: PlaceBuilder<'tcx>,\n         index: Local,\n         expr_span: Span,\n         source_info: SourceInfo,\n@@ -641,7 +664,12 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         let lt = self.temp(bool_ty, expr_span);\n \n         // len = len(slice)\n-        self.cfg.push_assign(block, source_info, len, Rvalue::Len(slice));\n+        self.cfg.push_assign(\n+            block,\n+            source_info,\n+            len,\n+            Rvalue::Len(slice.into_place(self.tcx, self.typeck_results)),\n+        );\n         // lt = idx < len\n         self.cfg.push_assign(\n             block,"}, {"sha": "ce816b6229e4b1a09b94b9b6c7785ebeaf8bbb93", "filename": "compiler/rustc_mir_build/src/build/expr/as_rvalue.rs", "status": "modified", "additions": 37, "deletions": 1, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/f5d8117c338a788bd24abec733fd143dfceb25a0/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5d8117c338a788bd24abec733fd143dfceb25a0/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=f5d8117c338a788bd24abec733fd143dfceb25a0", "patch": "@@ -8,6 +8,7 @@ use crate::build::{BlockAnd, BlockAndExtension, Builder};\n use crate::thir::*;\n use rustc_middle::middle::region;\n use rustc_middle::mir::AssertKind;\n+use rustc_middle::mir::Place;\n use rustc_middle::mir::*;\n use rustc_middle::ty::{self, Ty, UpvarSubsts};\n use rustc_span::Span;\n@@ -164,7 +165,41 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n                 block.and(Rvalue::Aggregate(box AggregateKind::Tuple, fields))\n             }\n-            ExprKind::Closure { closure_id, substs, upvars, movability } => {\n+            ExprKind::Closure { closure_id, substs, upvars, movability, ref fake_reads } => {\n+                // Convert the closure fake reads, if any, from `ExprRef` to mir `Place`\n+                // and push the fake reads.\n+                // This must come before creating the operands. This is required in case\n+                // there is a fake read and a borrow of the same path, since otherwise the\n+                // fake read might interfere with the borrow. Consider an example like this\n+                // one:\n+                // ```\n+                // let mut x = 0;\n+                // let c = || {\n+                //     &mut x; // mutable borrow of `x`\n+                //     match x { _ => () } // fake read of `x`\n+                // };\n+                // ```\n+                // FIXME(RFC2229): Remove feature gate once diagnostics are improved\n+                if this.tcx.features().capture_disjoint_fields {\n+                    for (thir_place, cause, hir_id) in fake_reads.into_iter() {\n+                        let place_builder =\n+                            unpack!(block = this.as_place_builder(block, thir_place));\n+\n+                        if let Ok(place_builder_resolved) =\n+                            place_builder.try_upvars_resolved(this.tcx, this.typeck_results)\n+                        {\n+                            let mir_place =\n+                                place_builder_resolved.into_place(this.tcx, this.typeck_results);\n+                            this.cfg.push_fake_read(\n+                                block,\n+                                this.source_info(this.tcx.hir().span(*hir_id)),\n+                                *cause,\n+                                mir_place,\n+                            );\n+                        }\n+                    }\n+                }\n+\n                 // see (*) above\n                 let operands: Vec<_> = upvars\n                     .into_iter()\n@@ -203,6 +238,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                         }\n                     })\n                     .collect();\n+\n                 let result = match substs {\n                     UpvarSubsts::Generator(substs) => {\n                         // We implicitly set the discriminant to 0. See"}, {"sha": "539de80cab71cae30d19ae47e07183f47ae648f4", "filename": "compiler/rustc_mir_build/src/build/expr/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f5d8117c338a788bd24abec733fd143dfceb25a0/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5d8117c338a788bd24abec733fd143dfceb25a0/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fmod.rs?ref=f5d8117c338a788bd24abec733fd143dfceb25a0", "patch": "@@ -62,7 +62,7 @@\n \n mod as_constant;\n mod as_operand;\n-mod as_place;\n+pub mod as_place;\n mod as_rvalue;\n mod as_temp;\n mod category;"}, {"sha": "73fd3f0feb59117b2d308794d4393a9b96864660", "filename": "compiler/rustc_mir_build/src/build/matches/mod.rs", "status": "modified", "additions": 93, "deletions": 29, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/f5d8117c338a788bd24abec733fd143dfceb25a0/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5d8117c338a788bd24abec733fd143dfceb25a0/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs?ref=f5d8117c338a788bd24abec733fd143dfceb25a0", "patch": "@@ -5,6 +5,7 @@\n //! This also includes code for pattern bindings in `let` statements and\n //! function parameters.\n \n+use crate::build::expr::as_place::PlaceBuilder;\n use crate::build::scope::DropKind;\n use crate::build::ForGuard::{self, OutsideGuard, RefWithinGuard};\n use crate::build::{BlockAnd, BlockAndExtension, Builder};\n@@ -96,7 +97,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         let scrutinee_place =\n             unpack!(block = self.lower_scrutinee(block, scrutinee, scrutinee_span,));\n \n-        let mut arm_candidates = self.create_match_candidates(scrutinee_place, &arms);\n+        let mut arm_candidates = self.create_match_candidates(scrutinee_place.clone(), &arms);\n \n         let match_has_guard = arms.iter().any(|arm| arm.guard.is_some());\n         let mut candidates =\n@@ -121,8 +122,8 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         mut block: BasicBlock,\n         scrutinee: &Expr<'_, 'tcx>,\n         scrutinee_span: Span,\n-    ) -> BlockAnd<Place<'tcx>> {\n-        let scrutinee_place = unpack!(block = self.as_place(block, scrutinee));\n+    ) -> BlockAnd<PlaceBuilder<'tcx>> {\n+        let scrutinee_place_builder = unpack!(block = self.as_place_builder(block, scrutinee));\n         // Matching on a `scrutinee_place` with an uninhabited type doesn't\n         // generate any memory reads by itself, and so if the place \"expression\"\n         // contains unsafe operations like raw pointer dereferences or union\n@@ -140,23 +141,29 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         // check safety.\n         let cause_matched_place = FakeReadCause::ForMatchedPlace;\n         let source_info = self.source_info(scrutinee_span);\n-        self.cfg.push_fake_read(block, source_info, cause_matched_place, scrutinee_place);\n \n-        block.and(scrutinee_place)\n+        if let Ok(scrutinee_builder) =\n+            scrutinee_place_builder.clone().try_upvars_resolved(self.tcx, self.typeck_results)\n+        {\n+            let scrutinee_place = scrutinee_builder.into_place(self.tcx, self.typeck_results);\n+            self.cfg.push_fake_read(block, source_info, cause_matched_place, scrutinee_place);\n+        }\n+\n+        block.and(scrutinee_place_builder)\n     }\n \n     /// Create the initial `Candidate`s for a `match` expression.\n     fn create_match_candidates<'pat>(\n         &mut self,\n-        scrutinee: Place<'tcx>,\n+        scrutinee: PlaceBuilder<'tcx>,\n         arms: &'pat [Arm<'pat, 'tcx>],\n     ) -> Vec<(&'pat Arm<'pat, 'tcx>, Candidate<'pat, 'tcx>)> {\n         // Assemble a list of candidates: there is one candidate per pattern,\n         // which means there may be more than one candidate *per arm*.\n         arms.iter()\n             .map(|arm| {\n                 let arm_has_guard = arm.guard.is_some();\n-                let arm_candidate = Candidate::new(scrutinee, &arm.pattern, arm_has_guard);\n+                let arm_candidate = Candidate::new(scrutinee.clone(), &arm.pattern, arm_has_guard);\n                 (arm, arm_candidate)\n             })\n             .collect()\n@@ -222,7 +229,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     fn lower_match_arms(\n         &mut self,\n         destination: Place<'tcx>,\n-        scrutinee_place: Place<'tcx>,\n+        scrutinee_place_builder: PlaceBuilder<'tcx>,\n         scrutinee_span: Span,\n         arm_candidates: Vec<(&'_ Arm<'_, 'tcx>, Candidate<'_, 'tcx>)>,\n         outer_source_info: SourceInfo,\n@@ -236,12 +243,33 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 let arm_source_info = self.source_info(arm.span);\n                 let arm_scope = (arm.scope, arm_source_info);\n                 self.in_scope(arm_scope, arm.lint_level, |this| {\n+                    // `try_upvars_resolved` may fail if it is unable to resolve the given\n+                    // `PlaceBuilder` inside a closure. In this case, we don't want to include\n+                    // a scrutinee place. `scrutinee_place_builder` will fail to be resolved\n+                    // if the only match arm is a wildcard (`_`).\n+                    // Example:\n+                    // ```\n+                    // let foo = (0, 1);\n+                    // let c = || {\n+                    //    match foo { _ => () };\n+                    // };\n+                    // ```\n+                    let mut opt_scrutinee_place: Option<(Option<&Place<'tcx>>, Span)> = None;\n+                    let scrutinee_place: Place<'tcx>;\n+                    if let Ok(scrutinee_builder) = scrutinee_place_builder\n+                        .clone()\n+                        .try_upvars_resolved(this.tcx, this.typeck_results)\n+                    {\n+                        scrutinee_place =\n+                            scrutinee_builder.into_place(this.tcx, this.typeck_results);\n+                        opt_scrutinee_place = Some((Some(&scrutinee_place), scrutinee_span));\n+                    }\n                     let scope = this.declare_bindings(\n                         None,\n                         arm.span,\n                         &arm.pattern,\n                         ArmHasGuard(arm.guard.is_some()),\n-                        Some((Some(&scrutinee_place), scrutinee_span)),\n+                        opt_scrutinee_place,\n                     );\n \n                     let arm_block = this.bind_pattern(\n@@ -446,8 +474,8 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             }\n \n             _ => {\n-                let place = unpack!(block = self.as_place(block, initializer));\n-                self.place_into_pattern(block, irrefutable_pat, place, true)\n+                let place_builder = unpack!(block = self.as_place_builder(block, initializer));\n+                self.place_into_pattern(block, irrefutable_pat, place_builder, true)\n             }\n         }\n     }\n@@ -456,14 +484,12 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         &mut self,\n         block: BasicBlock,\n         irrefutable_pat: Pat<'tcx>,\n-        initializer: Place<'tcx>,\n+        initializer: PlaceBuilder<'tcx>,\n         set_match_place: bool,\n     ) -> BlockAnd<()> {\n-        let mut candidate = Candidate::new(initializer, &irrefutable_pat, false);\n-\n+        let mut candidate = Candidate::new(initializer.clone(), &irrefutable_pat, false);\n         let fake_borrow_temps =\n             self.lower_match_tree(block, irrefutable_pat.span, false, &mut [&mut candidate]);\n-\n         // For matches and function arguments, the place that is being matched\n         // can be set when creating the variables. But the place for\n         // let PATTERN = ... might not even exist until we do the assignment.\n@@ -478,7 +504,27 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                         VarBindingForm { opt_match_place: Some((ref mut match_place, _)), .. },\n                     )))) = self.local_decls[local].local_info\n                     {\n-                        *match_place = Some(initializer);\n+                        // `try_upvars_resolved` may fail if it is unable to resolve the given\n+                        // `PlaceBuilder` inside a closure. In this case, we don't want to include\n+                        // a scrutinee place. `scrutinee_place_builder` will fail for destructured\n+                        // assignments. This is because a closure only captures the precise places\n+                        // that it will read and as a result a closure may not capture the entire\n+                        // tuple/struct and rather have individual places that will be read in the\n+                        // final MIR.\n+                        // Example:\n+                        // ```\n+                        // let foo = (0, 1);\n+                        // let c = || {\n+                        //    let (v1, v2) = foo;\n+                        // };\n+                        // ```\n+                        if let Ok(match_pair_resolved) =\n+                            initializer.clone().try_upvars_resolved(self.tcx, self.typeck_results)\n+                        {\n+                            let place =\n+                                match_pair_resolved.into_place(self.tcx, self.typeck_results);\n+                            *match_place = Some(place);\n+                        }\n                     } else {\n                         bug!(\"Let binding to non-user variable.\")\n                     }\n@@ -717,7 +763,7 @@ struct Candidate<'pat, 'tcx> {\n }\n \n impl<'tcx, 'pat> Candidate<'pat, 'tcx> {\n-    fn new(place: Place<'tcx>, pattern: &'pat Pat<'tcx>, has_guard: bool) -> Self {\n+    fn new(place: PlaceBuilder<'tcx>, pattern: &'pat Pat<'tcx>, has_guard: bool) -> Self {\n         Candidate {\n             span: pattern.span,\n             has_guard,\n@@ -791,7 +837,7 @@ struct Ascription<'tcx> {\n #[derive(Clone, Debug)]\n crate struct MatchPair<'pat, 'tcx> {\n     // this place...\n-    place: Place<'tcx>,\n+    place: PlaceBuilder<'tcx>,\n \n     // ... must match this pattern.\n     pattern: &'pat Pat<'tcx>,\n@@ -1198,7 +1244,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                         &mut otherwise,\n                         pats,\n                         or_span,\n-                        place,\n+                        place.clone(),\n                         fake_borrows,\n                     );\n                 });\n@@ -1224,12 +1270,14 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         otherwise: &mut Option<BasicBlock>,\n         pats: &'pat [Pat<'tcx>],\n         or_span: Span,\n-        place: Place<'tcx>,\n+        place: PlaceBuilder<'tcx>,\n         fake_borrows: &mut Option<FxHashSet<Place<'tcx>>>,\n     ) {\n         debug!(\"test_or_pattern:\\ncandidate={:#?}\\npats={:#?}\", candidate, pats);\n-        let mut or_candidates: Vec<_> =\n-            pats.iter().map(|pat| Candidate::new(place, pat, candidate.has_guard)).collect();\n+        let mut or_candidates: Vec<_> = pats\n+            .iter()\n+            .map(|pat| Candidate::new(place.clone(), pat, candidate.has_guard))\n+            .collect();\n         let mut or_candidate_refs: Vec<_> = or_candidates.iter_mut().collect();\n         let otherwise = if candidate.otherwise_block.is_some() {\n             &mut candidate.otherwise_block\n@@ -1412,7 +1460,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         // extract the match-pair from the highest priority candidate\n         let match_pair = &candidates.first().unwrap().match_pairs[0];\n         let mut test = self.test(match_pair);\n-        let match_place = match_pair.place;\n+        let match_place = match_pair.place.clone();\n \n         // most of the time, the test to perform is simply a function\n         // of the main candidate; but for a test like SwitchInt, we\n@@ -1438,7 +1486,12 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n         // Insert a Shallow borrow of any places that is switched on.\n         if let Some(fb) = fake_borrows {\n-            fb.insert(match_place);\n+            if let Ok(match_place_resolved) =\n+                match_place.clone().try_upvars_resolved(self.tcx, self.typeck_results)\n+            {\n+                let resolved_place = match_place_resolved.into_place(self.tcx, self.typeck_results);\n+                fb.insert(resolved_place);\n+            }\n         }\n \n         // perform the test, branching to one of N blocks. For each of\n@@ -1456,7 +1509,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         // encounter a candidate where the test is not relevant; at\n         // that point, we stop sorting.\n         while let Some(candidate) = candidates.first_mut() {\n-            if let Some(idx) = self.sort_candidate(&match_place, &test, candidate) {\n+            if let Some(idx) = self.sort_candidate(&match_place.clone(), &test, candidate) {\n                 let (candidate, rest) = candidates.split_first_mut().unwrap();\n                 target_candidates[idx].push(candidate);\n                 candidates = rest;\n@@ -1753,23 +1806,34 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 }\n                 Guard::IfLet(pat, scrutinee) => {\n                     let scrutinee_span = scrutinee.span;\n-                    let scrutinee_place =\n+                    let scrutinee_place_builder =\n                         unpack!(block = self.lower_scrutinee(block, scrutinee, scrutinee_span));\n-                    let mut guard_candidate = Candidate::new(scrutinee_place, &pat, false);\n+                    let mut guard_candidate =\n+                        Candidate::new(scrutinee_place_builder.clone(), &pat, false);\n                     let wildcard = Pat::wildcard_from_ty(pat.ty);\n-                    let mut otherwise_candidate = Candidate::new(scrutinee_place, &wildcard, false);\n+                    let mut otherwise_candidate =\n+                        Candidate::new(scrutinee_place_builder.clone(), &wildcard, false);\n                     let fake_borrow_temps = self.lower_match_tree(\n                         block,\n                         pat.span,\n                         false,\n                         &mut [&mut guard_candidate, &mut otherwise_candidate],\n                     );\n+                    let mut opt_scrutinee_place: Option<(Option<&Place<'tcx>>, Span)> = None;\n+                    let scrutinee_place: Place<'tcx>;\n+                    if let Ok(scrutinee_builder) =\n+                        scrutinee_place_builder.try_upvars_resolved(self.tcx, self.typeck_results)\n+                    {\n+                        scrutinee_place =\n+                            scrutinee_builder.into_place(self.tcx, self.typeck_results);\n+                        opt_scrutinee_place = Some((Some(&scrutinee_place), scrutinee_span));\n+                    }\n                     self.declare_bindings(\n                         None,\n                         pat.span.to(arm_span.unwrap()),\n                         pat,\n                         ArmHasGuard(false),\n-                        Some((Some(&scrutinee_place), scrutinee.span)),\n+                        opt_scrutinee_place,\n                     );\n                     let post_guard_block = self.bind_pattern(\n                         self.source_info(pat.span),"}, {"sha": "3ad143a57ff561525ae39ef06d457a5bf97b8990", "filename": "compiler/rustc_mir_build/src/build/matches/simplify.rs", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/f5d8117c338a788bd24abec733fd143dfceb25a0/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5d8117c338a788bd24abec733fd143dfceb25a0/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fsimplify.rs?ref=f5d8117c338a788bd24abec733fd143dfceb25a0", "patch": "@@ -12,11 +12,11 @@\n //! sort of test: for example, testing which variant an enum is, or\n //! testing a value against a constant.\n \n+use crate::build::expr::as_place::PlaceBuilder;\n use crate::build::matches::{Ascription, Binding, Candidate, MatchPair};\n use crate::build::Builder;\n use crate::thir::{self, *};\n use rustc_hir::RangeEnd;\n-use rustc_middle::mir::Place;\n use rustc_middle::ty;\n use rustc_middle::ty::layout::IntegerExt;\n use rustc_target::abi::{Integer, Size};\n@@ -68,11 +68,12 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             let match_pairs = mem::take(&mut candidate.match_pairs);\n \n             if let [MatchPair { pattern: Pat { kind: box PatKind::Or { pats }, .. }, place }] =\n-                *match_pairs\n+                &*match_pairs\n             {\n                 existing_bindings.extend_from_slice(&new_bindings);\n                 mem::swap(&mut candidate.bindings, &mut existing_bindings);\n-                candidate.subcandidates = self.create_or_subcandidates(candidate, place, pats);\n+                candidate.subcandidates =\n+                    self.create_or_subcandidates(candidate, place.clone(), pats);\n                 return true;\n             }\n \n@@ -125,12 +126,12 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     fn create_or_subcandidates<'pat>(\n         &mut self,\n         candidate: &Candidate<'pat, 'tcx>,\n-        place: Place<'tcx>,\n+        place: PlaceBuilder<'tcx>,\n         pats: &'pat [Pat<'tcx>],\n     ) -> Vec<Candidate<'pat, 'tcx>> {\n         pats.iter()\n             .map(|pat| {\n-                let mut candidate = Candidate::new(place, pat, candidate.has_guard);\n+                let mut candidate = Candidate::new(place.clone(), pat, candidate.has_guard);\n                 self.simplify_candidate(&mut candidate);\n                 candidate\n             })\n@@ -154,11 +155,10 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 ascription: thir::pattern::Ascription { variance, user_ty, user_ty_span },\n             } => {\n                 // Apply the type ascription to the value at `match_pair.place`, which is the\n-                // value being matched, taking the variance field into account.\n                 candidate.ascriptions.push(Ascription {\n                     span: user_ty_span,\n                     user_ty,\n-                    source: match_pair.place,\n+                    source: match_pair.place.clone().into_place(self.tcx, self.typeck_results),\n                     variance,\n                 });\n \n@@ -177,7 +177,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     name,\n                     mutability,\n                     span: match_pair.pattern.span,\n-                    source: match_pair.place,\n+                    source: match_pair.place.clone().into_place(self.tcx, self.typeck_results),\n                     var_id: var,\n                     var_ty: ty,\n                     binding_mode: mode,\n@@ -264,8 +264,10 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 }) && (adt_def.did.is_local()\n                     || !adt_def.is_variant_list_non_exhaustive());\n                 if irrefutable {\n-                    let place = tcx.mk_place_downcast(match_pair.place, adt_def, variant_index);\n-                    candidate.match_pairs.extend(self.field_match_pairs(place, subpatterns));\n+                    let place_builder = match_pair.place.downcast(adt_def, variant_index);\n+                    candidate\n+                        .match_pairs\n+                        .extend(self.field_match_pairs(place_builder, subpatterns));\n                     Ok(())\n                 } else {\n                     Err(match_pair)\n@@ -290,8 +292,8 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             }\n \n             PatKind::Deref { ref subpattern } => {\n-                let place = tcx.mk_place_deref(match_pair.place);\n-                candidate.match_pairs.push(MatchPair::new(place, subpattern));\n+                let place_builder = match_pair.place.deref();\n+                candidate.match_pairs.push(MatchPair::new(place_builder, subpattern));\n                 Ok(())\n             }\n "}, {"sha": "6820d4ba35ae37b594a185c53134ff61d691bb17", "filename": "compiler/rustc_mir_build/src/build/matches/test.rs", "status": "modified", "additions": 15, "deletions": 7, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/f5d8117c338a788bd24abec733fd143dfceb25a0/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5d8117c338a788bd24abec733fd143dfceb25a0/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs?ref=f5d8117c338a788bd24abec733fd143dfceb25a0", "patch": "@@ -5,6 +5,7 @@\n // identify what tests are needed, perform the tests, and then filter\n // the candidates based on the result.\n \n+use crate::build::expr::as_place::PlaceBuilder;\n use crate::build::matches::{Candidate, MatchPair, Test, TestKind};\n use crate::build::Builder;\n use crate::thir::pattern::compare_const_vals;\n@@ -81,7 +82,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n     pub(super) fn add_cases_to_switch<'pat>(\n         &mut self,\n-        test_place: &Place<'tcx>,\n+        test_place: &PlaceBuilder<'tcx>,\n         candidate: &Candidate<'pat, 'tcx>,\n         switch_ty: Ty<'tcx>,\n         options: &mut FxIndexMap<&'tcx ty::Const<'tcx>, u128>,\n@@ -123,7 +124,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n     pub(super) fn add_variants_to_switch<'pat>(\n         &mut self,\n-        test_place: &Place<'tcx>,\n+        test_place: &PlaceBuilder<'tcx>,\n         candidate: &Candidate<'pat, 'tcx>,\n         variants: &mut BitSet<VariantIdx>,\n     ) -> bool {\n@@ -151,10 +152,18 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     pub(super) fn perform_test(\n         &mut self,\n         block: BasicBlock,\n-        place: Place<'tcx>,\n+        place_builder: PlaceBuilder<'tcx>,\n         test: &Test<'tcx>,\n         make_target_blocks: impl FnOnce(&mut Self) -> Vec<BasicBlock>,\n     ) {\n+        let place: Place<'tcx>;\n+        if let Ok(test_place_builder) =\n+            place_builder.try_upvars_resolved(self.tcx, self.typeck_results)\n+        {\n+            place = test_place_builder.into_place(self.tcx, self.typeck_results);\n+        } else {\n+            return;\n+        }\n         debug!(\n             \"perform_test({:?}, {:?}: {:?}, {:?})\",\n             block,\n@@ -481,7 +490,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// tighter match code if we do something a bit different.\n     pub(super) fn sort_candidate<'pat>(\n         &mut self,\n-        test_place: &Place<'tcx>,\n+        test_place: &PlaceBuilder<'tcx>,\n         test: &Test<'tcx>,\n         candidate: &mut Candidate<'pat, 'tcx>,\n     ) -> Option<usize> {\n@@ -728,7 +737,6 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         candidate: &mut Candidate<'pat, 'tcx>,\n     ) {\n         let match_pair = candidate.match_pairs.remove(match_pair_index);\n-        let tcx = self.tcx;\n \n         // So, if we have a match-pattern like `x @ Enum::Variant(P1, P2)`,\n         // we want to create a set of derived match-patterns like\n@@ -737,10 +745,10 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             Some(adt_def.variants[variant_index].ident.name),\n             variant_index,\n         );\n-        let downcast_place = tcx.mk_place_elem(match_pair.place, elem); // `(x as Variant)`\n+        let downcast_place = match_pair.place.project(elem); // `(x as Variant)`\n         let consequent_match_pairs = subpatterns.iter().map(|subpattern| {\n             // e.g., `(x as Variant).0`\n-            let place = tcx.mk_place_field(downcast_place, subpattern.field, subpattern.pattern.ty);\n+            let place = downcast_place.clone().field(subpattern.field, subpattern.pattern.ty);\n             // e.g., `(x as Variant).0 @ P1`\n             MatchPair::new(place, &subpattern.pattern)\n         });"}, {"sha": "d49a00a566053751bbdd8c550b004edc96f60f62", "filename": "compiler/rustc_mir_build/src/build/matches/util.rs", "status": "modified", "additions": 19, "deletions": 15, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/f5d8117c338a788bd24abec733fd143dfceb25a0/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5d8117c338a788bd24abec733fd143dfceb25a0/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Futil.rs?ref=f5d8117c338a788bd24abec733fd143dfceb25a0", "patch": "@@ -1,3 +1,4 @@\n+use crate::build::expr::as_place::PlaceBuilder;\n use crate::build::matches::MatchPair;\n use crate::build::Builder;\n use crate::thir::*;\n@@ -9,13 +10,13 @@ use std::convert::TryInto;\n impl<'a, 'tcx> Builder<'a, 'tcx> {\n     crate fn field_match_pairs<'pat>(\n         &mut self,\n-        place: Place<'tcx>,\n+        place: PlaceBuilder<'tcx>,\n         subpatterns: &'pat [FieldPat<'tcx>],\n     ) -> Vec<MatchPair<'pat, 'tcx>> {\n         subpatterns\n             .iter()\n             .map(|fieldpat| {\n-                let place = self.tcx.mk_place_field(place, fieldpat.field, fieldpat.pattern.ty);\n+                let place = place.clone().field(fieldpat.field, fieldpat.pattern.ty);\n                 MatchPair::new(place, &fieldpat.pattern)\n             })\n             .collect()\n@@ -24,34 +25,37 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     crate fn prefix_slice_suffix<'pat>(\n         &mut self,\n         match_pairs: &mut SmallVec<[MatchPair<'pat, 'tcx>; 1]>,\n-        place: &Place<'tcx>,\n+        place: &PlaceBuilder<'tcx>,\n         prefix: &'pat [Pat<'tcx>],\n         opt_slice: Option<&'pat Pat<'tcx>>,\n         suffix: &'pat [Pat<'tcx>],\n     ) {\n         let tcx = self.tcx;\n-        let (min_length, exact_size) = match place.ty(&self.local_decls, tcx).ty.kind() {\n+        let (min_length, exact_size) = match place\n+            .clone()\n+            .into_place(tcx, self.typeck_results)\n+            .ty(&self.local_decls, tcx)\n+            .ty\n+            .kind()\n+        {\n             ty::Array(_, length) => (length.eval_usize(tcx, self.param_env), true),\n             _ => ((prefix.len() + suffix.len()).try_into().unwrap(), false),\n         };\n \n         match_pairs.extend(prefix.iter().enumerate().map(|(idx, subpattern)| {\n             let elem =\n                 ProjectionElem::ConstantIndex { offset: idx as u64, min_length, from_end: false };\n-            let place = tcx.mk_place_elem(*place, elem);\n+            let place = place.clone().project(elem);\n             MatchPair::new(place, subpattern)\n         }));\n \n         if let Some(subslice_pat) = opt_slice {\n             let suffix_len = suffix.len() as u64;\n-            let subslice = tcx.mk_place_elem(\n-                *place,\n-                ProjectionElem::Subslice {\n-                    from: prefix.len() as u64,\n-                    to: if exact_size { min_length - suffix_len } else { suffix_len },\n-                    from_end: !exact_size,\n-                },\n-            );\n+            let subslice = place.clone().project(ProjectionElem::Subslice {\n+                from: prefix.len() as u64,\n+                to: if exact_size { min_length - suffix_len } else { suffix_len },\n+                from_end: !exact_size,\n+            });\n             match_pairs.push(MatchPair::new(subslice, subslice_pat));\n         }\n \n@@ -62,7 +66,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 min_length,\n                 from_end: !exact_size,\n             };\n-            let place = tcx.mk_place_elem(*place, elem);\n+            let place = place.clone().project(elem);\n             MatchPair::new(place, subpattern)\n         }));\n     }\n@@ -91,7 +95,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n }\n \n impl<'pat, 'tcx> MatchPair<'pat, 'tcx> {\n-    crate fn new(place: Place<'tcx>, pattern: &'pat Pat<'tcx>) -> MatchPair<'pat, 'tcx> {\n+    crate fn new(place: PlaceBuilder<'tcx>, pattern: &'pat Pat<'tcx>) -> MatchPair<'pat, 'tcx> {\n         MatchPair { place, pattern }\n     }\n }"}, {"sha": "4bc497f5ce29c269162072891bea87232a3ab238", "filename": "compiler/rustc_mir_build/src/build/mod.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f5d8117c338a788bd24abec733fd143dfceb25a0/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5d8117c338a788bd24abec733fd143dfceb25a0/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs?ref=f5d8117c338a788bd24abec733fd143dfceb25a0", "patch": "@@ -1,4 +1,5 @@\n use crate::build;\n+use crate::build::expr::as_place::PlaceBuilder;\n use crate::build::scope::DropKind;\n use crate::thir::{build_thir, Arena, BindingMode, Expr, LintLevel, Pat, PatKind};\n use rustc_attr::{self as attr, UnwindAttr};\n@@ -1004,7 +1005,10 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                             matches::ArmHasGuard(false),\n                             Some((Some(&place), span)),\n                         );\n-                        unpack!(block = self.place_into_pattern(block, pattern, place, false));\n+                        let place_builder = PlaceBuilder::from(local);\n+                        unpack!(\n+                            block = self.place_into_pattern(block, pattern, place_builder, false)\n+                        );\n                     }\n                 }\n                 self.source_scope = original_source_scope;"}, {"sha": "43d63d59ed964c8ad6b90ec937b006d75170a797", "filename": "compiler/rustc_mir_build/src/thir/cx/expr.rs", "status": "modified", "additions": 35, "deletions": 8, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/f5d8117c338a788bd24abec733fd143dfceb25a0/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5d8117c338a788bd24abec733fd143dfceb25a0/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs?ref=f5d8117c338a788bd24abec733fd143dfceb25a0", "patch": "@@ -5,6 +5,7 @@ use rustc_data_structures::stack::ensure_sufficient_stack;\n use rustc_hir as hir;\n use rustc_hir::def::{CtorKind, CtorOf, DefKind, Res};\n use rustc_index::vec::Idx;\n+use rustc_middle::hir::place::Place as HirPlace;\n use rustc_middle::hir::place::PlaceBase as HirPlaceBase;\n use rustc_middle::hir::place::ProjectionKind as HirProjectionKind;\n use rustc_middle::mir::interpret::Scalar;\n@@ -452,7 +453,21 @@ impl<'thir, 'tcx> Cx<'thir, 'tcx> {\n                         .zip(substs.upvar_tys())\n                         .map(|(captured_place, ty)| self.capture_upvar(expr, captured_place, ty)),\n                 );\n-                ExprKind::Closure { closure_id: def_id, substs, upvars, movability }\n+\n+                // Convert the closure fake reads, if any, from hir `Place` to ExprRef\n+                let fake_reads = match self.typeck_results.closure_fake_reads.get(&def_id) {\n+                    Some(fake_reads) => fake_reads\n+                        .iter()\n+                        .map(|(place, cause, hir_id)| {\n+                            let expr = self.convert_captured_hir_place(expr, place.clone());\n+                            let expr_ref: &'thir Expr<'thir, 'tcx> = self.arena.alloc(expr);\n+                            (expr_ref, *cause, *hir_id)\n+                        })\n+                        .collect(),\n+                    None => Vec::new(),\n+                };\n+\n+                ExprKind::Closure { closure_id: def_id, substs, upvars, movability, fake_reads }\n             }\n \n             hir::ExprKind::Path(ref qpath) => {\n@@ -1012,22 +1027,20 @@ impl<'thir, 'tcx> Cx<'thir, 'tcx> {\n         ExprKind::Deref { arg: ref_expr }\n     }\n \n-    fn capture_upvar(\n+    fn convert_captured_hir_place(\n         &mut self,\n         closure_expr: &'tcx hir::Expr<'tcx>,\n-        captured_place: &'tcx ty::CapturedPlace<'tcx>,\n-        upvar_ty: Ty<'tcx>,\n+        place: HirPlace<'tcx>,\n     ) -> Expr<'thir, 'tcx> {\n-        let upvar_capture = captured_place.info.capture_kind;\n         let temp_lifetime = self.region_scope_tree.temporary_scope(closure_expr.hir_id.local_id);\n-        let var_ty = captured_place.place.base_ty;\n+        let var_ty = place.base_ty;\n \n         // The result of capture analysis in `rustc_typeck/check/upvar.rs`represents a captured path\n         // as it's seen for use within the closure and not at the time of closure creation.\n         //\n         // That is we see expect to see it start from a captured upvar and not something that is local\n         // to the closure's parent.\n-        let var_hir_id = match captured_place.place.base {\n+        let var_hir_id = match place.base {\n             HirPlaceBase::Upvar(upvar_id) => upvar_id.var_path.hir_id,\n             base => bug!(\"Expected an upvar, found {:?}\", base),\n         };\n@@ -1039,7 +1052,7 @@ impl<'thir, 'tcx> Cx<'thir, 'tcx> {\n             kind: self.convert_var(var_hir_id),\n         };\n \n-        for proj in captured_place.place.projections.iter() {\n+        for proj in place.projections.iter() {\n             let kind = match proj.kind {\n                 HirProjectionKind::Deref => {\n                     ExprKind::Deref { arg: self.arena.alloc(captured_place_expr) }\n@@ -1062,6 +1075,20 @@ impl<'thir, 'tcx> Cx<'thir, 'tcx> {\n                 Expr { temp_lifetime, ty: proj.ty, span: closure_expr.span, kind };\n         }\n \n+        captured_place_expr\n+    }\n+\n+    fn capture_upvar(\n+        &mut self,\n+        closure_expr: &'tcx hir::Expr<'tcx>,\n+        captured_place: &'tcx ty::CapturedPlace<'tcx>,\n+        upvar_ty: Ty<'tcx>,\n+    ) -> Expr<'thir, 'tcx> {\n+        let upvar_capture = captured_place.info.capture_kind;\n+        let captured_place_expr =\n+            self.convert_captured_hir_place(closure_expr, captured_place.place.clone());\n+        let temp_lifetime = self.region_scope_tree.temporary_scope(closure_expr.hir_id.local_id);\n+\n         match upvar_capture {\n             ty::UpvarCapture::ByValue(_) => captured_place_expr,\n             ty::UpvarCapture::ByRef(upvar_borrow) => {"}, {"sha": "6f20195db0b5eee6d09bbeb2a5d7c188f23c66ac", "filename": "compiler/rustc_mir_build/src/thir/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f5d8117c338a788bd24abec733fd143dfceb25a0/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5d8117c338a788bd24abec733fd143dfceb25a0/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fmod.rs?ref=f5d8117c338a788bd24abec733fd143dfceb25a0", "patch": "@@ -9,7 +9,7 @@ use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_middle::infer::canonical::Canonical;\n use rustc_middle::middle::region;\n-use rustc_middle::mir::{BinOp, BorrowKind, Field, UnOp};\n+use rustc_middle::mir::{BinOp, BorrowKind, FakeReadCause, Field, UnOp};\n use rustc_middle::ty::adjustment::PointerCast;\n use rustc_middle::ty::subst::SubstsRef;\n use rustc_middle::ty::{AdtDef, Const, Ty, UpvarSubsts, UserType};\n@@ -281,6 +281,7 @@ pub enum ExprKind<'thir, 'tcx> {\n         substs: UpvarSubsts<'tcx>,\n         upvars: &'thir [Expr<'thir, 'tcx>],\n         movability: Option<hir::Movability>,\n+        fake_reads: Vec<(&'thir Expr<'thir, 'tcx>, FakeReadCause, hir::HirId)>,\n     },\n     Literal {\n         literal: &'tcx Const<'tcx>,"}, {"sha": "e79349796d226338d5c3557db02a139b97e8cbba", "filename": "compiler/rustc_typeck/src/check/upvar.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f5d8117c338a788bd24abec733fd143dfceb25a0/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5d8117c338a788bd24abec733fd143dfceb25a0/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs?ref=f5d8117c338a788bd24abec733fd143dfceb25a0", "patch": "@@ -41,6 +41,7 @@ use rustc_hir::def_id::LocalDefId;\n use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n use rustc_infer::infer::UpvarRegion;\n use rustc_middle::hir::place::{Place, PlaceBase, PlaceWithHirId, Projection, ProjectionKind};\n+use rustc_middle::mir::FakeReadCause;\n use rustc_middle::ty::fold::TypeFoldable;\n use rustc_middle::ty::{self, Ty, TyCtxt, TypeckResults, UpvarSubsts};\n use rustc_session::lint;\n@@ -145,6 +146,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             current_closure_kind: ty::ClosureKind::LATTICE_BOTTOM,\n             current_origin: None,\n             capture_information: Default::default(),\n+            fake_reads: Default::default(),\n         };\n         euv::ExprUseVisitor::new(\n             &mut delegate,\n@@ -246,6 +248,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let final_tupled_upvars_type = self.tcx.mk_tup(final_upvar_tys.iter());\n         self.demand_suptype(span, substs.tupled_upvars_ty(), final_tupled_upvars_type);\n \n+        let fake_reads = delegate\n+            .fake_reads\n+            .into_iter()\n+            .map(|(place, cause, hir_id)| (place, cause, hir_id))\n+            .collect();\n+        self.typeck_results.borrow_mut().closure_fake_reads.insert(closure_def_id, fake_reads);\n+\n         // If we are also inferred the closure kind here,\n         // process any deferred resolutions.\n         let deferred_call_resolutions = self.remove_deferred_call_resolutions(closure_def_id);\n@@ -1148,6 +1157,7 @@ struct InferBorrowKind<'a, 'tcx> {\n     /// Place { V1, [ProjectionKind::Field(Index=1, Variant=0)] } : CaptureKind { E2, MutableBorrow }\n     /// ```\n     capture_information: InferredCaptureInformation<'tcx>,\n+    fake_reads: Vec<(Place<'tcx>, FakeReadCause, hir::HirId)>,\n }\n \n impl<'a, 'tcx> InferBorrowKind<'a, 'tcx> {\n@@ -1409,6 +1419,12 @@ impl<'a, 'tcx> InferBorrowKind<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> euv::Delegate<'tcx> for InferBorrowKind<'a, 'tcx> {\n+    fn fake_read(&mut self, place: Place<'tcx>, cause: FakeReadCause, diag_expr_id: hir::HirId) {\n+        if let PlaceBase::Upvar(_) = place.base {\n+            self.fake_reads.push((place, cause, diag_expr_id));\n+        }\n+    }\n+\n     fn consume(\n         &mut self,\n         place_with_id: &PlaceWithHirId<'tcx>,"}, {"sha": "d3866df44ff31231045b9a50baad10be4ddfebc5", "filename": "compiler/rustc_typeck/src/check/writeback.rs", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/f5d8117c338a788bd24abec733fd143dfceb25a0/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5d8117c338a788bd24abec733fd143dfceb25a0/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwriteback.rs?ref=f5d8117c338a788bd24abec733fd143dfceb25a0", "patch": "@@ -4,11 +4,15 @@\n \n use crate::check::FnCtxt;\n \n+use rustc_data_structures::stable_map::FxHashMap;\n use rustc_errors::ErrorReported;\n use rustc_hir as hir;\n+use rustc_hir::def_id::DefId;\n use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n use rustc_infer::infer::error_reporting::TypeAnnotationNeeded::E0282;\n use rustc_infer::infer::InferCtxt;\n+use rustc_middle::hir::place::Place as HirPlace;\n+use rustc_middle::mir::FakeReadCause;\n use rustc_middle::ty::adjustment::{Adjust, Adjustment, PointerCast};\n use rustc_middle::ty::fold::{TypeFoldable, TypeFolder};\n use rustc_middle::ty::{self, Ty, TyCtxt};\n@@ -56,6 +60,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n         wbcx.visit_body(body);\n         wbcx.visit_min_capture_map();\n+        wbcx.visit_fake_reads_map();\n         wbcx.visit_upvar_capture_map();\n         wbcx.visit_closures();\n         wbcx.visit_liberated_fn_sigs();\n@@ -363,6 +368,27 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n         self.typeck_results.closure_min_captures = min_captures_wb;\n     }\n \n+    fn visit_fake_reads_map(&mut self) {\n+        let mut resolved_closure_fake_reads: FxHashMap<\n+            DefId,\n+            Vec<(HirPlace<'tcx>, FakeReadCause, hir::HirId)>,\n+        > = Default::default();\n+        for (closure_def_id, fake_reads) in\n+            self.fcx.typeck_results.borrow().closure_fake_reads.iter()\n+        {\n+            let mut resolved_fake_reads = Vec::<(HirPlace<'tcx>, FakeReadCause, hir::HirId)>::new();\n+            for (place, cause, hir_id) in fake_reads.iter() {\n+                let locatable =\n+                    self.tcx().hir().local_def_id_to_hir_id(closure_def_id.expect_local());\n+\n+                let resolved_fake_read = self.resolve(place.clone(), &locatable);\n+                resolved_fake_reads.push((resolved_fake_read, *cause, *hir_id));\n+            }\n+            resolved_closure_fake_reads.insert(*closure_def_id, resolved_fake_reads);\n+        }\n+        self.typeck_results.closure_fake_reads = resolved_closure_fake_reads;\n+    }\n+\n     fn visit_upvar_capture_map(&mut self) {\n         for (upvar_id, upvar_capture) in self.fcx.typeck_results.borrow().upvar_capture_map.iter() {\n             let new_upvar_capture = match *upvar_capture {"}, {"sha": "dced4aac049adc7fd6a58f36f9a863d1887278bd", "filename": "compiler/rustc_typeck/src/expr_use_visitor.rs", "status": "modified", "additions": 119, "deletions": 2, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/f5d8117c338a788bd24abec733fd143dfceb25a0/compiler%2Frustc_typeck%2Fsrc%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5d8117c338a788bd24abec733fd143dfceb25a0/compiler%2Frustc_typeck%2Fsrc%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fexpr_use_visitor.rs?ref=f5d8117c338a788bd24abec733fd143dfceb25a0", "patch": "@@ -5,15 +5,17 @@\n pub use self::ConsumeMode::*;\n \n // Export these here so that Clippy can use them.\n-pub use rustc_middle::hir::place::{PlaceBase, PlaceWithHirId, Projection};\n+pub use rustc_middle::hir::place::{Place, PlaceBase, PlaceWithHirId, Projection};\n \n+use rustc_data_structures::fx::FxIndexMap;\n use rustc_hir as hir;\n use rustc_hir::def::Res;\n use rustc_hir::def_id::LocalDefId;\n use rustc_hir::PatKind;\n use rustc_index::vec::Idx;\n use rustc_infer::infer::InferCtxt;\n use rustc_middle::hir::place::ProjectionKind;\n+use rustc_middle::mir::FakeReadCause;\n use rustc_middle::ty::{self, adjustment, TyCtxt};\n use rustc_target::abi::VariantIdx;\n \n@@ -51,6 +53,9 @@ pub trait Delegate<'tcx> {\n     // The path at `assignee_place` is being assigned to.\n     // `diag_expr_id` is the id used for diagnostics (see `consume` for more details).\n     fn mutate(&mut self, assignee_place: &PlaceWithHirId<'tcx>, diag_expr_id: hir::HirId);\n+\n+    // The `place` should be a fake read because of specified `cause`.\n+    fn fake_read(&mut self, place: Place<'tcx>, cause: FakeReadCause, diag_expr_id: hir::HirId);\n }\n \n #[derive(Copy, Clone, PartialEq, Debug)]\n@@ -229,7 +234,61 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n \n             hir::ExprKind::Match(ref discr, arms, _) => {\n                 let discr_place = return_if_err!(self.mc.cat_expr(&discr));\n-                self.borrow_expr(&discr, ty::ImmBorrow);\n+\n+                // Matching should not always be considered a use of the place, hence\n+                // discr does not necessarily need to be borrowed.\n+                // We only want to borrow discr if the pattern contain something other\n+                // than wildcards.\n+                let ExprUseVisitor { ref mc, body_owner: _, delegate: _ } = *self;\n+                let mut needs_to_be_read = false;\n+                for arm in arms.iter() {\n+                    return_if_err!(mc.cat_pattern(discr_place.clone(), &arm.pat, |place, pat| {\n+                        match &pat.kind {\n+                            PatKind::Binding(.., opt_sub_pat) => {\n+                                // If the opt_sub_pat is None, than the binding does not count as\n+                                // a wildcard for the purpose of borrowing discr.\n+                                if opt_sub_pat.is_none() {\n+                                    needs_to_be_read = true;\n+                                }\n+                            }\n+                            PatKind::TupleStruct(..)\n+                            | PatKind::Path(..)\n+                            | PatKind::Struct(..)\n+                            | PatKind::Tuple(..) => {\n+                                // If the PatKind is a TupleStruct, Struct or Tuple then we want to check\n+                                // whether the Variant is a MultiVariant or a SingleVariant. We only want\n+                                // to borrow discr if it is a MultiVariant.\n+                                // If it is a SingleVariant and creates a binding we will handle that when\n+                                // this callback gets called again.\n+                                if let ty::Adt(def, _) = place.place.base_ty.kind() {\n+                                    if def.variants.len() > 1 {\n+                                        needs_to_be_read = true;\n+                                    }\n+                                }\n+                            }\n+                            PatKind::Lit(_) => {\n+                                // If the PatKind is a Lit then we want\n+                                // to borrow discr.\n+                                needs_to_be_read = true;\n+                            }\n+                            _ => {}\n+                        }\n+                    }));\n+                }\n+\n+                if needs_to_be_read {\n+                    self.borrow_expr(&discr, ty::ImmBorrow);\n+                } else {\n+                    self.delegate.fake_read(\n+                        discr_place.place.clone(),\n+                        FakeReadCause::ForMatchedPlace,\n+                        discr_place.hir_id,\n+                    );\n+\n+                    // We always want to walk the discriminant. We want to make sure, for instance,\n+                    // that the discriminant has been initialized.\n+                    self.walk_expr(&discr);\n+                }\n \n                 // treatment of the discriminant is handled while walking the arms.\n                 for arm in arms {\n@@ -518,6 +577,11 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n     }\n \n     fn walk_arm(&mut self, discr_place: &PlaceWithHirId<'tcx>, arm: &hir::Arm<'_>) {\n+        self.delegate.fake_read(\n+            discr_place.place.clone(),\n+            FakeReadCause::ForMatchedPlace,\n+            discr_place.hir_id,\n+        );\n         self.walk_pat(discr_place, &arm.pat);\n \n         if let Some(hir::Guard::If(ref e)) = arm.guard {\n@@ -530,6 +594,11 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n     /// Walks a pat that occurs in isolation (i.e., top-level of fn argument or\n     /// let binding, and *not* a match arm or nested pat.)\n     fn walk_irrefutable_pat(&mut self, discr_place: &PlaceWithHirId<'tcx>, pat: &hir::Pat<'_>) {\n+        self.delegate.fake_read(\n+            discr_place.place.clone(),\n+            FakeReadCause::ForLet,\n+            discr_place.hir_id,\n+        );\n         self.walk_pat(discr_place, pat);\n     }\n \n@@ -597,6 +666,14 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n     /// - When reporting the Place back to the Delegate, ensure that the UpvarId uses the enclosing\n     /// closure as the DefId.\n     fn walk_captures(&mut self, closure_expr: &hir::Expr<'_>) {\n+        fn upvar_is_local_variable(\n+            upvars: Option<&'tcx FxIndexMap<hir::HirId, hir::Upvar>>,\n+            upvar_id: &hir::HirId,\n+            body_owner_is_closure: bool,\n+        ) -> bool {\n+            upvars.map(|upvars| !upvars.contains_key(upvar_id)).unwrap_or(body_owner_is_closure)\n+        }\n+\n         debug!(\"walk_captures({:?})\", closure_expr);\n \n         let closure_def_id = self.tcx().hir().local_def_id(closure_expr.hir_id).to_def_id();\n@@ -608,6 +685,46 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n             ty::Closure(..) | ty::Generator(..)\n         );\n \n+        // If we have a nested closure, we want to include the fake reads present in the nested closure.\n+        if let Some(fake_reads) = self.mc.typeck_results.closure_fake_reads.get(&closure_def_id) {\n+            for (fake_read, cause, hir_id) in fake_reads.iter() {\n+                match fake_read.base {\n+                    PlaceBase::Upvar(upvar_id) => {\n+                        if upvar_is_local_variable(\n+                            upvars,\n+                            &upvar_id.var_path.hir_id,\n+                            body_owner_is_closure,\n+                        ) {\n+                            // The nested closure might be fake reading the current (enclosing) closure's local variables.\n+                            // The only places we want to fake read before creating the parent closure are the ones that\n+                            // are not local to it/ defined by it.\n+                            //\n+                            // ```rust,ignore(cannot-test-this-because-pseduo-code)\n+                            // let v1 = (0, 1);\n+                            // let c = || { // fake reads: v1\n+                            //    let v2 = (0, 1);\n+                            //    let e = || { // fake reads: v1, v2\n+                            //       let (_, t1) = v1;\n+                            //       let (_, t2) = v2;\n+                            //    }\n+                            // }\n+                            // ```\n+                            // This check is performed when visiting the body of the outermost closure (`c`) and ensures\n+                            // that we don't add a fake read of v2 in c.\n+                            continue;\n+                        }\n+                    }\n+                    _ => {\n+                        bug!(\n+                            \"Do not know how to get HirId out of Rvalue and StaticItem {:?}\",\n+                            fake_read.base\n+                        );\n+                    }\n+                };\n+                self.delegate.fake_read(fake_read.clone(), *cause, *hir_id);\n+            }\n+        }\n+\n         if let Some(min_captures) = self.mc.typeck_results.closure_min_captures.get(&closure_def_id)\n         {\n             for (var_hir_id, min_list) in min_captures.iter() {"}, {"sha": "2ed0149b9db7d47fa441b71db68dc80e885febc2", "filename": "src/test/ui/closures/2229_closure_analysis/diagnostics/closure-origin-single-variant-diagnostics.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f5d8117c338a788bd24abec733fd143dfceb25a0/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fclosure-origin-single-variant-diagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5d8117c338a788bd24abec733fd143dfceb25a0/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fclosure-origin-single-variant-diagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fclosure-origin-single-variant-diagnostics.rs?ref=f5d8117c338a788bd24abec733fd143dfceb25a0", "patch": "@@ -13,12 +13,8 @@ fn main() {\n     let mut point = SingleVariant::Point(10, -10);\n \n     let c = || {\n-        // FIXME(project-rfc-2229#24): Change this to be a destructure pattern\n-        // once this is fixed, to remove the warning.\n-        if let SingleVariant::Point(ref mut x, _) = point {\n-            //~^ WARNING: irrefutable `if let` pattern\n-            *x += 1;\n-        }\n+        let SingleVariant::Point(ref mut x, _) = point;\n+        *x += 1;\n     };\n \n     let b = c;"}, {"sha": "402f5e4f33e6f30bbf29239d4fcade7aceac5d5b", "filename": "src/test/ui/closures/2229_closure_analysis/diagnostics/closure-origin-single-variant-diagnostics.stderr", "status": "modified", "additions": 5, "deletions": 18, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/f5d8117c338a788bd24abec733fd143dfceb25a0/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fclosure-origin-single-variant-diagnostics.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f5d8117c338a788bd24abec733fd143dfceb25a0/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fclosure-origin-single-variant-diagnostics.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fclosure-origin-single-variant-diagnostics.stderr?ref=f5d8117c338a788bd24abec733fd143dfceb25a0", "patch": "@@ -7,33 +7,20 @@ LL | #![feature(capture_disjoint_fields)]\n    = note: `#[warn(incomplete_features)]` on by default\n    = note: see issue #53488 <https://github.com/rust-lang/rust/issues/53488> for more information\n \n-warning: irrefutable `if let` pattern\n-  --> $DIR/closure-origin-single-variant-diagnostics.rs:18:9\n-   |\n-LL | /         if let SingleVariant::Point(ref mut x, _) = point {\n-LL | |\n-LL | |             *x += 1;\n-LL | |         }\n-   | |_________^\n-   |\n-   = note: `#[warn(irrefutable_let_patterns)]` on by default\n-   = note: this pattern will always match, so the `if let` is useless\n-   = help: consider replacing the `if let` with a `let`\n-\n error[E0382]: use of moved value: `c`\n-  --> $DIR/closure-origin-single-variant-diagnostics.rs:25:13\n+  --> $DIR/closure-origin-single-variant-diagnostics.rs:21:13\n    |\n LL |     let b = c;\n    |             - value moved here\n LL |     let a = c;\n    |             ^ value used here after move\n    |\n note: closure cannot be moved more than once as it is not `Copy` due to moving the variable `point.0` out of its environment\n-  --> $DIR/closure-origin-single-variant-diagnostics.rs:18:53\n+  --> $DIR/closure-origin-single-variant-diagnostics.rs:16:50\n    |\n-LL |         if let SingleVariant::Point(ref mut x, _) = point {\n-   |                                                     ^^^^^\n+LL |         let SingleVariant::Point(ref mut x, _) = point;\n+   |                                                  ^^^^^\n \n-error: aborting due to previous error; 2 warnings emitted\n+error: aborting due to previous error; 1 warning emitted\n \n For more information about this error, try `rustc --explain E0382`."}, {"sha": "609a11a578ae81eca6f8b79c7a18e77a5195ff0c", "filename": "src/test/ui/closures/2229_closure_analysis/pattern-matching-should-fail.rs", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/f5d8117c338a788bd24abec733fd143dfceb25a0/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fpattern-matching-should-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5d8117c338a788bd24abec733fd143dfceb25a0/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fpattern-matching-should-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fpattern-matching-should-fail.rs?ref=f5d8117c338a788bd24abec733fd143dfceb25a0", "patch": "@@ -0,0 +1,84 @@\n+#![feature(capture_disjoint_fields)]\n+//~^ WARNING: the feature `capture_disjoint_fields` is incomplete\n+//~| `#[warn(incomplete_features)]` on by default\n+//~| see issue #53488 <https://github.com/rust-lang/rust/issues/53488>\n+#![feature(never_type)]\n+\n+// Should fake read the discriminant and throw an error\n+fn test1() {\n+    let x: !;\n+    let c1 = || match x { };\n+    //~^ ERROR: use of possibly-uninitialized variable: `x`\n+}\n+\n+// Should fake read the discriminant and throw an error\n+fn test2() {\n+    let x: !;\n+    let c2 = || match x { _ => () };\n+    //~^ ERROR: borrow of possibly-uninitialized variable: `x`\n+}\n+\n+// Testing single variant patterns\n+enum SingleVariant {\n+    Points(u32)\n+}\n+\n+// Should fake read the discriminant and throw an error\n+fn test3() {\n+    let variant: !;\n+    let c = || {\n+    //~^ ERROR: borrow of possibly-uninitialized variable: `variant`\n+        match variant {\n+            SingleVariant::Points(_) => {}\n+        }\n+    };\n+    c();\n+}\n+\n+// Should fake read the discriminant and throw an error\n+fn test4() {\n+    let variant: !;\n+    let c = || {\n+    //~^ ERROR: borrow of possibly-uninitialized variable: `variant`\n+        match variant {\n+            SingleVariant::Points(a) => {\n+                println!(\"{:?}\", a);\n+            }\n+        }\n+    };\n+    c();\n+}\n+\n+fn test5() {\n+    let t: !;\n+    let g: !;\n+\n+    let a = || {\n+        match g { };\n+        //~^ ERROR: use of possibly-uninitialized variable: `g`\n+        let c = ||  {\n+            match t { };\n+            //~^ ERROR: use of possibly-uninitialized variable: `t`\n+        };\n+\n+        c();\n+    };\n+\n+}\n+\n+// Should fake read the discriminant and throw an error\n+fn test6() {\n+    let x: u8;\n+    let c1 = || match x { };\n+    //~^ ERROR: use of possibly-uninitialized variable: `x`\n+    //~| ERROR: non-exhaustive patterns: type `u8` is non-empty\n+}\n+\n+fn main() {\n+    test1();\n+    test2();\n+    test3();\n+    test4();\n+    test5();\n+    test6();\n+}"}, {"sha": "c225abb58b7311a625fb70332510bb5f9eb57fdf", "filename": "src/test/ui/closures/2229_closure_analysis/pattern-matching-should-fail.stderr", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/f5d8117c338a788bd24abec733fd143dfceb25a0/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fpattern-matching-should-fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f5d8117c338a788bd24abec733fd143dfceb25a0/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fpattern-matching-should-fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fpattern-matching-should-fail.stderr?ref=f5d8117c338a788bd24abec733fd143dfceb25a0", "patch": "@@ -0,0 +1,72 @@\n+warning: the feature `capture_disjoint_fields` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/pattern-matching-should-fail.rs:1:12\n+   |\n+LL | #![feature(capture_disjoint_fields)]\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+   = note: see issue #53488 <https://github.com/rust-lang/rust/issues/53488> for more information\n+\n+error[E0004]: non-exhaustive patterns: type `u8` is non-empty\n+  --> $DIR/pattern-matching-should-fail.rs:72:23\n+   |\n+LL |     let c1 = || match x { };\n+   |                       ^\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `u8`\n+\n+error[E0381]: use of possibly-uninitialized variable: `x`\n+  --> $DIR/pattern-matching-should-fail.rs:10:23\n+   |\n+LL |     let c1 = || match x { };\n+   |                       ^ use of possibly-uninitialized `x`\n+\n+error[E0381]: borrow of possibly-uninitialized variable: `x`\n+  --> $DIR/pattern-matching-should-fail.rs:17:14\n+   |\n+LL |     let c2 = || match x { _ => () };\n+   |              ^^       - borrow occurs due to use in closure\n+   |              |\n+   |              use of possibly-uninitialized `x`\n+\n+error[E0381]: borrow of possibly-uninitialized variable: `variant`\n+  --> $DIR/pattern-matching-should-fail.rs:29:13\n+   |\n+LL |     let c = || {\n+   |             ^^ use of possibly-uninitialized `variant`\n+LL |\n+LL |         match variant {\n+   |               ------- borrow occurs due to use in closure\n+\n+error[E0381]: borrow of possibly-uninitialized variable: `variant`\n+  --> $DIR/pattern-matching-should-fail.rs:41:13\n+   |\n+LL |     let c = || {\n+   |             ^^ use of possibly-uninitialized `variant`\n+LL |\n+LL |         match variant {\n+   |               ------- borrow occurs due to use in closure\n+\n+error[E0381]: use of possibly-uninitialized variable: `g`\n+  --> $DIR/pattern-matching-should-fail.rs:57:15\n+   |\n+LL |         match g { };\n+   |               ^ use of possibly-uninitialized `g`\n+\n+error[E0381]: use of possibly-uninitialized variable: `t`\n+  --> $DIR/pattern-matching-should-fail.rs:60:19\n+   |\n+LL |             match t { };\n+   |                   ^ use of possibly-uninitialized `t`\n+\n+error[E0381]: use of possibly-uninitialized variable: `x`\n+  --> $DIR/pattern-matching-should-fail.rs:72:23\n+   |\n+LL |     let c1 = || match x { };\n+   |                       ^ use of possibly-uninitialized `x`\n+\n+error: aborting due to 8 previous errors; 1 warning emitted\n+\n+Some errors have detailed explanations: E0004, E0381.\n+For more information about an error, try `rustc --explain E0004`."}, {"sha": "0a877dd366c7fc93952567df43b1f0f04b9caaa1", "filename": "src/test/ui/closures/2229_closure_analysis/patterns-capture-analysis.rs", "status": "added", "additions": 139, "deletions": 0, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/f5d8117c338a788bd24abec733fd143dfceb25a0/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fpatterns-capture-analysis.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5d8117c338a788bd24abec733fd143dfceb25a0/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fpatterns-capture-analysis.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fpatterns-capture-analysis.rs?ref=f5d8117c338a788bd24abec733fd143dfceb25a0", "patch": "@@ -0,0 +1,139 @@\n+#![feature(capture_disjoint_fields)]\n+//~^ WARNING: the feature `capture_disjoint_fields` is incomplete\n+//~| NOTE: `#[warn(incomplete_features)]` on by default\n+//~| NOTE: see issue #53488 <https://github.com/rust-lang/rust/issues/53488>\n+#![feature(rustc_attrs)]\n+\n+// Should capture the discriminant since a variant of a multivariant enum is\n+// mentioned in the match arm; the discriminant is captured by the closure regardless\n+// of if it creates a binding\n+fn test_1_should_capture() {\n+    let variant = Some(2229);\n+    let c =  #[rustc_capture_analysis]\n+    //~^ ERROR: attributes on expressions are experimental\n+    //~| NOTE: see issue #15701 <https://github.com/rust-lang/rust/issues/15701>\n+\n+    || {\n+    //~^ First Pass analysis includes:\n+    //~| Min Capture analysis includes:\n+        match variant {\n+        //~^ NOTE: Capturing variant[] -> ImmBorrow\n+        //~| NOTE: Min Capture variant[] -> ImmBorrow\n+            Some(_) => {}\n+            _ => {}\n+        }\n+    };\n+    c();\n+}\n+\n+// Should not capture the discriminant since only a wildcard is mentioned in the\n+// match arm\n+fn test_2_should_not_capture() {\n+    let variant = Some(2229);\n+    let c =  #[rustc_capture_analysis]\n+    //~^ ERROR: attributes on expressions are experimental\n+    //~| NOTE: see issue #15701 <https://github.com/rust-lang/rust/issues/15701>\n+    || {\n+    //~^ First Pass analysis includes:\n+        match variant {\n+            _ => {}\n+        }\n+    };\n+    c();\n+}\n+\n+// Testing single variant patterns\n+enum SingleVariant {\n+    Points(u32)\n+}\n+\n+// Should not capture the discriminant since the single variant mentioned\n+// in the match arm does not trigger a binding\n+fn test_3_should_not_capture_single_variant() {\n+    let variant = SingleVariant::Points(1);\n+    let c =  #[rustc_capture_analysis]\n+    //~^ ERROR: attributes on expressions are experimental\n+    //~| NOTE: see issue #15701 <https://github.com/rust-lang/rust/issues/15701>\n+    || {\n+    //~^ First Pass analysis includes:\n+        match variant {\n+            SingleVariant::Points(_) => {}\n+        }\n+    };\n+    c();\n+}\n+\n+// Should not capture the discriminant since the single variant mentioned\n+// in the match arm does not trigger a binding\n+fn test_6_should_capture_single_variant() {\n+    let variant = SingleVariant::Points(1);\n+    let c =  #[rustc_capture_analysis]\n+    //~^ ERROR: attributes on expressions are experimental\n+    //~| NOTE: see issue #15701 <https://github.com/rust-lang/rust/issues/15701>\n+    || {\n+    //~^ First Pass analysis includes:\n+    //~| Min Capture analysis includes:\n+        match variant {\n+            //~^ NOTE: Capturing variant[] -> ImmBorrow\n+            //~| NOTE: Capturing variant[(0, 0)] -> ImmBorrow\n+            //~| NOTE: Min Capture variant[] -> ImmBorrow\n+            SingleVariant::Points(a) => {\n+                println!(\"{:?}\", a);\n+            }\n+        }\n+    };\n+    c();\n+}\n+\n+// Should not capture the discriminant since only wildcards are mentioned in the\n+// match arm\n+fn test_4_should_not_capture_array() {\n+    let array: [i32; 3] = [0; 3];\n+    let c =  #[rustc_capture_analysis]\n+    //~^ ERROR: attributes on expressions are experimental\n+    //~| NOTE: see issue #15701 <https://github.com/rust-lang/rust/issues/15701>\n+    || {\n+    //~^ First Pass analysis includes:\n+        match array {\n+            [_,_,_] => {}\n+        }\n+    };\n+    c();\n+}\n+\n+// Testing MultiVariant patterns\n+enum MVariant {\n+    A,\n+    B,\n+    C,\n+}\n+\n+// Should capture the discriminant since a variant of the multi variant enum is\n+// mentioned in the match arm; the discriminant is captured by the closure\n+// regardless of if it creates a binding\n+fn test_5_should_capture_multi_variant() {\n+    let variant = MVariant::A;\n+    let c =  #[rustc_capture_analysis]\n+    //~^ ERROR: attributes on expressions are experimental\n+    //~| NOTE: see issue #15701 <https://github.com/rust-lang/rust/issues/15701>\n+    || {\n+    //~^ First Pass analysis includes:\n+    //~| Min Capture analysis includes:\n+        match variant {\n+        //~^ NOTE: Capturing variant[] -> ImmBorrow\n+        //~| NOTE: Min Capture variant[] -> ImmBorrow\n+            MVariant::A => {}\n+            _ => {}\n+        }\n+    };\n+    c();\n+}\n+\n+fn main() {\n+    test_1_should_capture();\n+    test_2_should_not_capture();\n+    test_3_should_not_capture_single_variant();\n+    test_6_should_capture_single_variant();\n+    test_4_should_not_capture_array();\n+    test_5_should_capture_multi_variant();\n+}"}, {"sha": "ad3e96a5753e337c58e0c6ecb66184b83f12c5ed", "filename": "src/test/ui/closures/2229_closure_analysis/patterns-capture-analysis.stderr", "status": "added", "additions": 212, "deletions": 0, "changes": 212, "blob_url": "https://github.com/rust-lang/rust/blob/f5d8117c338a788bd24abec733fd143dfceb25a0/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fpatterns-capture-analysis.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f5d8117c338a788bd24abec733fd143dfceb25a0/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fpatterns-capture-analysis.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fpatterns-capture-analysis.stderr?ref=f5d8117c338a788bd24abec733fd143dfceb25a0", "patch": "@@ -0,0 +1,212 @@\n+error[E0658]: attributes on expressions are experimental\n+  --> $DIR/patterns-capture-analysis.rs:12:14\n+   |\n+LL |     let c =  #[rustc_capture_analysis]\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: see issue #15701 <https://github.com/rust-lang/rust/issues/15701> for more information\n+   = help: add `#![feature(stmt_expr_attributes)]` to the crate attributes to enable\n+\n+error[E0658]: attributes on expressions are experimental\n+  --> $DIR/patterns-capture-analysis.rs:33:14\n+   |\n+LL |     let c =  #[rustc_capture_analysis]\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: see issue #15701 <https://github.com/rust-lang/rust/issues/15701> for more information\n+   = help: add `#![feature(stmt_expr_attributes)]` to the crate attributes to enable\n+\n+error[E0658]: attributes on expressions are experimental\n+  --> $DIR/patterns-capture-analysis.rs:54:14\n+   |\n+LL |     let c =  #[rustc_capture_analysis]\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: see issue #15701 <https://github.com/rust-lang/rust/issues/15701> for more information\n+   = help: add `#![feature(stmt_expr_attributes)]` to the crate attributes to enable\n+\n+error[E0658]: attributes on expressions are experimental\n+  --> $DIR/patterns-capture-analysis.rs:70:14\n+   |\n+LL |     let c =  #[rustc_capture_analysis]\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: see issue #15701 <https://github.com/rust-lang/rust/issues/15701> for more information\n+   = help: add `#![feature(stmt_expr_attributes)]` to the crate attributes to enable\n+\n+error[E0658]: attributes on expressions are experimental\n+  --> $DIR/patterns-capture-analysis.rs:92:14\n+   |\n+LL |     let c =  #[rustc_capture_analysis]\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: see issue #15701 <https://github.com/rust-lang/rust/issues/15701> for more information\n+   = help: add `#![feature(stmt_expr_attributes)]` to the crate attributes to enable\n+\n+error[E0658]: attributes on expressions are experimental\n+  --> $DIR/patterns-capture-analysis.rs:116:14\n+   |\n+LL |     let c =  #[rustc_capture_analysis]\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: see issue #15701 <https://github.com/rust-lang/rust/issues/15701> for more information\n+   = help: add `#![feature(stmt_expr_attributes)]` to the crate attributes to enable\n+\n+warning: the feature `capture_disjoint_fields` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/patterns-capture-analysis.rs:1:12\n+   |\n+LL | #![feature(capture_disjoint_fields)]\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+   = note: see issue #53488 <https://github.com/rust-lang/rust/issues/53488> for more information\n+\n+error: First Pass analysis includes:\n+  --> $DIR/patterns-capture-analysis.rs:16:5\n+   |\n+LL | /     || {\n+LL | |\n+LL | |\n+LL | |         match variant {\n+...  |\n+LL | |         }\n+LL | |     };\n+   | |_____^\n+   |\n+note: Capturing variant[] -> ImmBorrow\n+  --> $DIR/patterns-capture-analysis.rs:19:15\n+   |\n+LL |         match variant {\n+   |               ^^^^^^^\n+\n+error: Min Capture analysis includes:\n+  --> $DIR/patterns-capture-analysis.rs:16:5\n+   |\n+LL | /     || {\n+LL | |\n+LL | |\n+LL | |         match variant {\n+...  |\n+LL | |         }\n+LL | |     };\n+   | |_____^\n+   |\n+note: Min Capture variant[] -> ImmBorrow\n+  --> $DIR/patterns-capture-analysis.rs:19:15\n+   |\n+LL |         match variant {\n+   |               ^^^^^^^\n+\n+error: First Pass analysis includes:\n+  --> $DIR/patterns-capture-analysis.rs:36:5\n+   |\n+LL | /     || {\n+LL | |\n+LL | |         match variant {\n+LL | |             _ => {}\n+LL | |         }\n+LL | |     };\n+   | |_____^\n+\n+error: First Pass analysis includes:\n+  --> $DIR/patterns-capture-analysis.rs:57:5\n+   |\n+LL | /     || {\n+LL | |\n+LL | |         match variant {\n+LL | |             SingleVariant::Points(_) => {}\n+LL | |         }\n+LL | |     };\n+   | |_____^\n+\n+error: First Pass analysis includes:\n+  --> $DIR/patterns-capture-analysis.rs:73:5\n+   |\n+LL | /     || {\n+LL | |\n+LL | |\n+LL | |         match variant {\n+...  |\n+LL | |         }\n+LL | |     };\n+   | |_____^\n+   |\n+note: Capturing variant[] -> ImmBorrow\n+  --> $DIR/patterns-capture-analysis.rs:76:15\n+   |\n+LL |         match variant {\n+   |               ^^^^^^^\n+note: Capturing variant[(0, 0)] -> ImmBorrow\n+  --> $DIR/patterns-capture-analysis.rs:76:15\n+   |\n+LL |         match variant {\n+   |               ^^^^^^^\n+\n+error: Min Capture analysis includes:\n+  --> $DIR/patterns-capture-analysis.rs:73:5\n+   |\n+LL | /     || {\n+LL | |\n+LL | |\n+LL | |         match variant {\n+...  |\n+LL | |         }\n+LL | |     };\n+   | |_____^\n+   |\n+note: Min Capture variant[] -> ImmBorrow\n+  --> $DIR/patterns-capture-analysis.rs:76:15\n+   |\n+LL |         match variant {\n+   |               ^^^^^^^\n+\n+error: First Pass analysis includes:\n+  --> $DIR/patterns-capture-analysis.rs:95:5\n+   |\n+LL | /     || {\n+LL | |\n+LL | |         match array {\n+LL | |             [_,_,_] => {}\n+LL | |         }\n+LL | |     };\n+   | |_____^\n+\n+error: First Pass analysis includes:\n+  --> $DIR/patterns-capture-analysis.rs:119:5\n+   |\n+LL | /     || {\n+LL | |\n+LL | |\n+LL | |         match variant {\n+...  |\n+LL | |         }\n+LL | |     };\n+   | |_____^\n+   |\n+note: Capturing variant[] -> ImmBorrow\n+  --> $DIR/patterns-capture-analysis.rs:122:15\n+   |\n+LL |         match variant {\n+   |               ^^^^^^^\n+\n+error: Min Capture analysis includes:\n+  --> $DIR/patterns-capture-analysis.rs:119:5\n+   |\n+LL | /     || {\n+LL | |\n+LL | |\n+LL | |         match variant {\n+...  |\n+LL | |         }\n+LL | |     };\n+   | |_____^\n+   |\n+note: Min Capture variant[] -> ImmBorrow\n+  --> $DIR/patterns-capture-analysis.rs:122:15\n+   |\n+LL |         match variant {\n+   |               ^^^^^^^\n+\n+error: aborting due to 15 previous errors; 1 warning emitted\n+\n+For more information about this error, try `rustc --explain E0658`."}, {"sha": "eaea0dbfb5e8c4d4f141a386808f7f17bade1891", "filename": "src/test/ui/closures/2229_closure_analysis/run_pass/capture_with_wildcard_match.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/f5d8117c338a788bd24abec733fd143dfceb25a0/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fcapture_with_wildcard_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5d8117c338a788bd24abec733fd143dfceb25a0/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fcapture_with_wildcard_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fcapture_with_wildcard_match.rs?ref=f5d8117c338a788bd24abec733fd143dfceb25a0", "patch": "@@ -0,0 +1,28 @@\n+//check-pass\n+#![feature(capture_disjoint_fields)]\n+//~^ WARNING: the feature `capture_disjoint_fields` is incomplete\n+\n+fn test1() {\n+    let foo : [Vec<u8>; 3] = [\"String\".into(), \"String\".into(), \"String\".into()];\n+    let c = || {\n+        match foo { _ => () };\n+    };\n+    drop(foo);\n+    c();\n+}\n+\n+fn test2() {\n+    let foo : Option<[Vec<u8>; 3]> = Some([\"String\".into(), \"String\".into(), \"String\".into()]);\n+    let c = || {\n+        match foo {\n+            Some(_) => 1,\n+            _ => 2\n+        };\n+    };\n+    c();\n+}\n+\n+fn main() {\n+    test1();\n+    test2();\n+}"}, {"sha": "2c17a189afbbc9b9b118f030e7d3a2aa70f66dde", "filename": "src/test/ui/closures/2229_closure_analysis/run_pass/capture_with_wildcard_match.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f5d8117c338a788bd24abec733fd143dfceb25a0/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fcapture_with_wildcard_match.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f5d8117c338a788bd24abec733fd143dfceb25a0/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fcapture_with_wildcard_match.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fcapture_with_wildcard_match.stderr?ref=f5d8117c338a788bd24abec733fd143dfceb25a0", "patch": "@@ -0,0 +1,11 @@\n+warning: the feature `capture_disjoint_fields` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/capture_with_wildcard_match.rs:2:12\n+   |\n+LL | #![feature(capture_disjoint_fields)]\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+   = note: see issue #53488 <https://github.com/rust-lang/rust/issues/53488> for more information\n+\n+warning: 1 warning emitted\n+"}, {"sha": "3ad083a92d569690522072d3b28c47ec83eecdaf", "filename": "src/test/ui/closures/2229_closure_analysis/run_pass/destructure-pattern-closure-within-closure.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/f5d8117c338a788bd24abec733fd143dfceb25a0/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fdestructure-pattern-closure-within-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5d8117c338a788bd24abec733fd143dfceb25a0/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fdestructure-pattern-closure-within-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fdestructure-pattern-closure-within-closure.rs?ref=f5d8117c338a788bd24abec733fd143dfceb25a0", "patch": "@@ -0,0 +1,22 @@\n+//check-pass\n+#![feature(capture_disjoint_fields)]\n+//~^ WARNING: the feature `capture_disjoint_fields` is incomplete\n+#![warn(unused)]\n+\n+fn main() {\n+    let t = (String::from(\"Hello\"), String::from(\"World\"));\n+    let g = (String::from(\"Mr\"), String::from(\"Goose\"));\n+\n+    let a = || {\n+        let (_, g2) = g;\n+        //~^ WARN unused variable: `g2`\n+        let c = ||  {\n+            let (_, t2) = t;\n+            //~^ WARN unused variable: `t2`\n+        };\n+\n+        c();\n+    };\n+\n+    a();\n+}"}, {"sha": "c4abf934123b376e9b9efd669c167f06afb6b43f", "filename": "src/test/ui/closures/2229_closure_analysis/run_pass/destructure-pattern-closure-within-closure.stderr", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/f5d8117c338a788bd24abec733fd143dfceb25a0/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fdestructure-pattern-closure-within-closure.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f5d8117c338a788bd24abec733fd143dfceb25a0/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fdestructure-pattern-closure-within-closure.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fdestructure-pattern-closure-within-closure.stderr?ref=f5d8117c338a788bd24abec733fd143dfceb25a0", "patch": "@@ -0,0 +1,30 @@\n+warning: the feature `capture_disjoint_fields` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/destructure-pattern-closure-within-closure.rs:2:12\n+   |\n+LL | #![feature(capture_disjoint_fields)]\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+   = note: see issue #53488 <https://github.com/rust-lang/rust/issues/53488> for more information\n+\n+warning: unused variable: `t2`\n+  --> $DIR/destructure-pattern-closure-within-closure.rs:14:21\n+   |\n+LL |             let (_, t2) = t;\n+   |                     ^^ help: if this is intentional, prefix it with an underscore: `_t2`\n+   |\n+note: the lint level is defined here\n+  --> $DIR/destructure-pattern-closure-within-closure.rs:4:9\n+   |\n+LL | #![warn(unused)]\n+   |         ^^^^^^\n+   = note: `#[warn(unused_variables)]` implied by `#[warn(unused)]`\n+\n+warning: unused variable: `g2`\n+  --> $DIR/destructure-pattern-closure-within-closure.rs:11:17\n+   |\n+LL |         let (_, g2) = g;\n+   |                 ^^ help: if this is intentional, prefix it with an underscore: `_g2`\n+\n+warning: 3 warnings emitted\n+"}, {"sha": "65527648b2c991e7f185bdadd27434b25e91fb72", "filename": "src/test/ui/closures/2229_closure_analysis/run_pass/destructure_patterns.rs", "status": "added", "additions": 123, "deletions": 0, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/f5d8117c338a788bd24abec733fd143dfceb25a0/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fdestructure_patterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5d8117c338a788bd24abec733fd143dfceb25a0/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fdestructure_patterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fdestructure_patterns.rs?ref=f5d8117c338a788bd24abec733fd143dfceb25a0", "patch": "@@ -0,0 +1,123 @@\n+//check-pass\n+#![feature(capture_disjoint_fields)]\n+//~^ WARNING: the feature `capture_disjoint_fields` is incomplete\n+#![warn(unused)]\n+\n+struct Point {\n+    x: u32,\n+    y: u32,\n+}\n+\n+fn test1() {\n+    let t = (String::from(\"Hello\"), String::from(\"World\"));\n+\n+    let c = ||  {\n+        let (t1, t2) = t;\n+        //~^ WARN unused variable: `t1`\n+        //~| WARN unused variable: `t2`\n+    };\n+\n+    c();\n+}\n+\n+fn test2() {\n+    let t = (String::from(\"Hello\"), String::from(\"World\"));\n+\n+    let c = ||  {\n+        let (t1, _) = t;\n+        //~^ WARN unused variable: `t1`\n+    };\n+\n+    c();\n+}\n+\n+fn test3() {\n+    let t = (String::from(\"Hello\"), String::from(\"World\"));\n+\n+    let c = ||  {\n+        let (_, t2) = t;\n+        //~^ WARN unused variable: `t2`\n+    };\n+\n+    c();\n+}\n+\n+fn test4() {\n+    let t = (String::from(\"Hello\"), String::from(\"World\"));\n+    //~^ WARN unused variable: `t`\n+\n+    let c = ||  {\n+        let (_, _) = t;\n+    };\n+\n+    c();\n+}\n+\n+fn test5() {\n+    let t = (String::new(), String::new());\n+    let _c = ||  {\n+        let _a = match t {\n+            (t1, _) => t1,\n+        };\n+    };\n+}\n+\n+fn test6() {\n+    let t = (String::new(), String::new());\n+    let _c = ||  {\n+        let _a = match t {\n+            (_, t2) => t2,\n+        };\n+    };\n+}\n+\n+fn test7() {\n+    let t = (String::new(), String::new());\n+    let _c = ||  {\n+        let _a = match t {\n+            (t1, t2) => (t1, t2),\n+        };\n+    };\n+}\n+\n+fn test8() {\n+    let x = 0;\n+    //~^ WARN unused variable: `x`\n+    let tup = (1, 2);\n+    //~^ WARN unused variable: `tup`\n+    let p = Point { x: 10, y: 20 };\n+\n+    let c = || {\n+        let _ = x;\n+        let Point { x, y } = p;\n+        //~^ WARN unused variable: `x`\n+        println!(\"{}\", y);\n+        let (_, _) = tup;\n+    };\n+\n+    c();\n+}\n+\n+fn test9() {\n+    let _z = 9;\n+    let t = (String::from(\"Hello\"), String::from(\"World\"));\n+\n+    let c = ||  {\n+        let (_, t) = t;\n+        println!(\"{}\", t);\n+    };\n+\n+    c();\n+}\n+\n+fn main() {\n+    test1();\n+    test2();\n+    test3();\n+    test4();\n+    test5();\n+    test6();\n+    test7();\n+    test8();\n+    test9();\n+}"}, {"sha": "fcfe9ee95f185726d7377bd894c864dc2e5cae49", "filename": "src/test/ui/closures/2229_closure_analysis/run_pass/destructure_patterns.stderr", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/f5d8117c338a788bd24abec733fd143dfceb25a0/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fdestructure_patterns.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f5d8117c338a788bd24abec733fd143dfceb25a0/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fdestructure_patterns.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fdestructure_patterns.stderr?ref=f5d8117c338a788bd24abec733fd143dfceb25a0", "patch": "@@ -0,0 +1,66 @@\n+warning: the feature `capture_disjoint_fields` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/destructure_patterns.rs:2:12\n+   |\n+LL | #![feature(capture_disjoint_fields)]\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+   = note: see issue #53488 <https://github.com/rust-lang/rust/issues/53488> for more information\n+\n+warning: unused variable: `t1`\n+  --> $DIR/destructure_patterns.rs:15:14\n+   |\n+LL |         let (t1, t2) = t;\n+   |              ^^ help: if this is intentional, prefix it with an underscore: `_t1`\n+   |\n+note: the lint level is defined here\n+  --> $DIR/destructure_patterns.rs:4:9\n+   |\n+LL | #![warn(unused)]\n+   |         ^^^^^^\n+   = note: `#[warn(unused_variables)]` implied by `#[warn(unused)]`\n+\n+warning: unused variable: `t2`\n+  --> $DIR/destructure_patterns.rs:15:18\n+   |\n+LL |         let (t1, t2) = t;\n+   |                  ^^ help: if this is intentional, prefix it with an underscore: `_t2`\n+\n+warning: unused variable: `t1`\n+  --> $DIR/destructure_patterns.rs:27:14\n+   |\n+LL |         let (t1, _) = t;\n+   |              ^^ help: if this is intentional, prefix it with an underscore: `_t1`\n+\n+warning: unused variable: `t2`\n+  --> $DIR/destructure_patterns.rs:38:17\n+   |\n+LL |         let (_, t2) = t;\n+   |                 ^^ help: if this is intentional, prefix it with an underscore: `_t2`\n+\n+warning: unused variable: `t`\n+  --> $DIR/destructure_patterns.rs:46:9\n+   |\n+LL |     let t = (String::from(\"Hello\"), String::from(\"World\"));\n+   |         ^ help: if this is intentional, prefix it with an underscore: `_t`\n+\n+warning: unused variable: `x`\n+  --> $DIR/destructure_patterns.rs:92:21\n+   |\n+LL |         let Point { x, y } = p;\n+   |                     ^ help: try ignoring the field: `x: _`\n+\n+warning: unused variable: `x`\n+  --> $DIR/destructure_patterns.rs:84:9\n+   |\n+LL |     let x = 0;\n+   |         ^ help: if this is intentional, prefix it with an underscore: `_x`\n+\n+warning: unused variable: `tup`\n+  --> $DIR/destructure_patterns.rs:86:9\n+   |\n+LL |     let tup = (1, 2);\n+   |         ^^^ help: if this is intentional, prefix it with an underscore: `_tup`\n+\n+warning: 9 warnings emitted\n+"}, {"sha": "dae50854d82fb1b8982515f0bbb3f6da7e4cca5b", "filename": "src/test/ui/closures/2229_closure_analysis/run_pass/drop_then_use_fake_reads.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f5d8117c338a788bd24abec733fd143dfceb25a0/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fdrop_then_use_fake_reads.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5d8117c338a788bd24abec733fd143dfceb25a0/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fdrop_then_use_fake_reads.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fdrop_then_use_fake_reads.rs?ref=f5d8117c338a788bd24abec733fd143dfceb25a0", "patch": "@@ -0,0 +1,12 @@\n+//check-pass\n+#![feature(capture_disjoint_fields)]\n+//~^ WARNING: the feature `capture_disjoint_fields` is incomplete\n+#![feature(rustc_attrs)]\n+\n+fn main() {\n+    let mut x = 1;\n+    let c = || {\n+        drop(&mut x);\n+        match x { _ => () }\n+    };\n+}"}, {"sha": "7f811875d1363c425d65caf565b8b19319ef1eb6", "filename": "src/test/ui/closures/2229_closure_analysis/run_pass/drop_then_use_fake_reads.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f5d8117c338a788bd24abec733fd143dfceb25a0/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fdrop_then_use_fake_reads.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f5d8117c338a788bd24abec733fd143dfceb25a0/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fdrop_then_use_fake_reads.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fdrop_then_use_fake_reads.stderr?ref=f5d8117c338a788bd24abec733fd143dfceb25a0", "patch": "@@ -0,0 +1,11 @@\n+warning: the feature `capture_disjoint_fields` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/drop_then_use_fake_reads.rs:2:12\n+   |\n+LL | #![feature(capture_disjoint_fields)]\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+   = note: see issue #53488 <https://github.com/rust-lang/rust/issues/53488> for more information\n+\n+warning: 1 warning emitted\n+"}, {"sha": "9c086fe4bdfe780650ab2c6f2717a5142e4b6f03", "filename": "src/test/ui/closures/2229_closure_analysis/run_pass/lit-pattern-matching-with-methods.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/f5d8117c338a788bd24abec733fd143dfceb25a0/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Flit-pattern-matching-with-methods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5d8117c338a788bd24abec733fd143dfceb25a0/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Flit-pattern-matching-with-methods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Flit-pattern-matching-with-methods.rs?ref=f5d8117c338a788bd24abec733fd143dfceb25a0", "patch": "@@ -0,0 +1,31 @@\n+//check-pass\n+#![feature(capture_disjoint_fields)]\n+//~^ WARNING: the feature `capture_disjoint_fields` is incomplete\n+#![warn(unused)]\n+#![feature(rustc_attrs)]\n+#![feature(btree_drain_filter)]\n+\n+use std::collections::BTreeMap;\n+use std::panic::{catch_unwind, AssertUnwindSafe};\n+\n+fn main() {\n+    let mut map = BTreeMap::new();\n+    map.insert(\"a\", ());\n+    map.insert(\"b\", ());\n+    map.insert(\"c\", ());\n+\n+    {\n+        let mut it = map.drain_filter(|_, _| true);\n+        catch_unwind(AssertUnwindSafe(|| while it.next().is_some() {})).unwrap_err();\n+        let result = catch_unwind(AssertUnwindSafe(|| it.next()));\n+        assert!(matches!(result, Ok(None)));\n+    }\n+\n+    {\n+        let mut it = map.drain_filter(|_, _| true);\n+        catch_unwind(AssertUnwindSafe(|| while let Some(_) = it.next() {})).unwrap_err();\n+        let result = catch_unwind(AssertUnwindSafe(|| it.next()));\n+        assert!(matches!(result, Ok(None)));\n+    }\n+\n+}"}, {"sha": "bc046ecad6867d20142d8d0cd6b660d47a24a18b", "filename": "src/test/ui/closures/2229_closure_analysis/run_pass/lit-pattern-matching-with-methods.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f5d8117c338a788bd24abec733fd143dfceb25a0/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Flit-pattern-matching-with-methods.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f5d8117c338a788bd24abec733fd143dfceb25a0/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Flit-pattern-matching-with-methods.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Flit-pattern-matching-with-methods.stderr?ref=f5d8117c338a788bd24abec733fd143dfceb25a0", "patch": "@@ -0,0 +1,11 @@\n+warning: the feature `capture_disjoint_fields` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/lit-pattern-matching-with-methods.rs:2:12\n+   |\n+LL | #![feature(capture_disjoint_fields)]\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+   = note: see issue #53488 <https://github.com/rust-lang/rust/issues/53488> for more information\n+\n+warning: 1 warning emitted\n+"}, {"sha": "d260a448926d63cf7b2f1be0c53254e6f76923a2", "filename": "src/test/ui/closures/2229_closure_analysis/run_pass/struct-pattern-matching-with-methods.rs", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/f5d8117c338a788bd24abec733fd143dfceb25a0/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fstruct-pattern-matching-with-methods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5d8117c338a788bd24abec733fd143dfceb25a0/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fstruct-pattern-matching-with-methods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fstruct-pattern-matching-with-methods.rs?ref=f5d8117c338a788bd24abec733fd143dfceb25a0", "patch": "@@ -0,0 +1,49 @@\n+//check-pass\n+#![feature(capture_disjoint_fields)]\n+//~^ WARNING: the feature `capture_disjoint_fields` is incomplete\n+#![warn(unused)]\n+#![feature(rustc_attrs)]\n+\n+#[derive(Debug, Clone, Copy)]\n+enum PointType {\n+    TwoD { x: u32, y: u32 },\n+\n+    ThreeD{ x: u32, y: u32, z: u32 }\n+}\n+\n+// Testing struct patterns\n+struct Points {\n+    points: Vec<PointType>,\n+}\n+\n+impl Points {\n+    pub fn test1(&mut self) -> Vec<usize> {\n+        (0..self.points.len())\n+            .filter_map(|i| {\n+                let idx = i as usize;\n+                match self.test2(idx) {\n+                    PointType::TwoD { .. } => Some(i),\n+                    PointType::ThreeD { .. } => None,\n+                }\n+            })\n+            .collect()\n+    }\n+\n+    pub fn test2(&mut self, i: usize) -> PointType {\n+        self.points[i]\n+    }\n+}\n+\n+fn main() {\n+    let mut points = Points {\n+        points: Vec::<PointType>::new()\n+    };\n+\n+    points.points.push(PointType::ThreeD { x:0, y:0, z:0 });\n+    points.points.push(PointType::TwoD{ x:0, y:0 });\n+    points.points.push(PointType::ThreeD{ x:0, y:0, z:0 });\n+    points.points.push(PointType::TwoD{ x:0, y:0 });\n+\n+    println!(\"{:?}\", points.test1());\n+    println!(\"{:?}\", points.points);\n+}"}, {"sha": "3e4303a3710df961c03aaa85fbc494f7d77c8a66", "filename": "src/test/ui/closures/2229_closure_analysis/run_pass/struct-pattern-matching-with-methods.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f5d8117c338a788bd24abec733fd143dfceb25a0/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fstruct-pattern-matching-with-methods.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f5d8117c338a788bd24abec733fd143dfceb25a0/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fstruct-pattern-matching-with-methods.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fstruct-pattern-matching-with-methods.stderr?ref=f5d8117c338a788bd24abec733fd143dfceb25a0", "patch": "@@ -0,0 +1,11 @@\n+warning: the feature `capture_disjoint_fields` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/struct-pattern-matching-with-methods.rs:2:12\n+   |\n+LL | #![feature(capture_disjoint_fields)]\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+   = note: see issue #53488 <https://github.com/rust-lang/rust/issues/53488> for more information\n+\n+warning: 1 warning emitted\n+"}, {"sha": "b3bee79254ec4b2cc9ea2a2af877fb27719ba3d6", "filename": "src/test/ui/closures/2229_closure_analysis/run_pass/tuple-struct-pattern-matching-with-methods.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/f5d8117c338a788bd24abec733fd143dfceb25a0/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Ftuple-struct-pattern-matching-with-methods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5d8117c338a788bd24abec733fd143dfceb25a0/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Ftuple-struct-pattern-matching-with-methods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Ftuple-struct-pattern-matching-with-methods.rs?ref=f5d8117c338a788bd24abec733fd143dfceb25a0", "patch": "@@ -0,0 +1,44 @@\n+//check-pass\n+#![feature(capture_disjoint_fields)]\n+//~^ WARNING: the feature `capture_disjoint_fields` is incomplete\n+\n+#[derive(Copy, Clone)]\n+enum PointType {\n+    TwoD(u32, u32),\n+    ThreeD(u32, u32, u32)\n+}\n+\n+// Testing tuple struct patterns\n+struct Points {\n+    points: Vec<PointType>,\n+}\n+\n+impl Points {\n+    pub fn test1(&mut self) -> Vec<usize> {\n+        (0..self.points.len())\n+            .filter_map(|i| {\n+                match self.test2(i) {\n+                    PointType::TwoD (..) => Some(i),\n+                    PointType::ThreeD (..) => None,\n+                }\n+            })\n+            .collect()\n+    }\n+\n+    pub fn test2(&mut self, i: usize) -> PointType {\n+        self.points[i]\n+    }\n+}\n+\n+fn main() {\n+    let mut points = Points {\n+        points: Vec::<PointType>::new()\n+    };\n+\n+    points.points.push(PointType::ThreeD(0,0,0));\n+    points.points.push(PointType::TwoD(0,0));\n+    points.points.push(PointType::ThreeD(0,0,1));\n+    points.points.push(PointType::TwoD(0,1));\n+\n+    println!(\"{:?}\", points.test1());\n+}"}, {"sha": "ded0e37b0f366eea3303cdd6440cab14bb53f73f", "filename": "src/test/ui/closures/2229_closure_analysis/run_pass/tuple-struct-pattern-matching-with-methods.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f5d8117c338a788bd24abec733fd143dfceb25a0/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Ftuple-struct-pattern-matching-with-methods.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f5d8117c338a788bd24abec733fd143dfceb25a0/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Ftuple-struct-pattern-matching-with-methods.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Ftuple-struct-pattern-matching-with-methods.stderr?ref=f5d8117c338a788bd24abec733fd143dfceb25a0", "patch": "@@ -0,0 +1,11 @@\n+warning: the feature `capture_disjoint_fields` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/tuple-struct-pattern-matching-with-methods.rs:2:12\n+   |\n+LL | #![feature(capture_disjoint_fields)]\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+   = note: see issue #53488 <https://github.com/rust-lang/rust/issues/53488> for more information\n+\n+warning: 1 warning emitted\n+"}, {"sha": "0e6da8f4f18894c2205ca7e1ff3d32b62391edfd", "filename": "src/test/ui/closures/2229_closure_analysis/run_pass/use_of_mutable_borrow_and_fake_reads.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f5d8117c338a788bd24abec733fd143dfceb25a0/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fuse_of_mutable_borrow_and_fake_reads.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5d8117c338a788bd24abec733fd143dfceb25a0/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fuse_of_mutable_borrow_and_fake_reads.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fuse_of_mutable_borrow_and_fake_reads.rs?ref=f5d8117c338a788bd24abec733fd143dfceb25a0", "patch": "@@ -0,0 +1,12 @@\n+//check-pass\n+#![feature(capture_disjoint_fields)]\n+//~^ WARNING: the feature `capture_disjoint_fields` is incomplete\n+#![feature(rustc_attrs)]\n+\n+fn main() {\n+    let mut x = 0;\n+    let c = || {\n+        &mut x; // mutable borrow of `x`\n+        match x { _ => () } // fake read of `x`\n+    };\n+}"}, {"sha": "7d16d77bf737ec6c94e2ece89fcd9c69877a075a", "filename": "src/test/ui/closures/2229_closure_analysis/run_pass/use_of_mutable_borrow_and_fake_reads.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f5d8117c338a788bd24abec733fd143dfceb25a0/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fuse_of_mutable_borrow_and_fake_reads.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f5d8117c338a788bd24abec733fd143dfceb25a0/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fuse_of_mutable_borrow_and_fake_reads.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fuse_of_mutable_borrow_and_fake_reads.stderr?ref=f5d8117c338a788bd24abec733fd143dfceb25a0", "patch": "@@ -0,0 +1,11 @@\n+warning: the feature `capture_disjoint_fields` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/use_of_mutable_borrow_and_fake_reads.rs:2:12\n+   |\n+LL | #![feature(capture_disjoint_fields)]\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+   = note: see issue #53488 <https://github.com/rust-lang/rust/issues/53488> for more information\n+\n+warning: 1 warning emitted\n+"}, {"sha": "972167575475e6048f101cee80594eecc1f6d034", "filename": "src/tools/clippy/clippy_lints/src/escape.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f5d8117c338a788bd24abec733fd143dfceb25a0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fescape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5d8117c338a788bd24abec733fd143dfceb25a0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fescape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fescape.rs?ref=f5d8117c338a788bd24abec733fd143dfceb25a0", "patch": "@@ -2,6 +2,7 @@ use rustc_hir::intravisit;\n use rustc_hir::{self, AssocItemKind, Body, FnDecl, HirId, HirIdSet, Impl, ItemKind, Node};\n use rustc_infer::infer::TyCtxtInferExt;\n use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::mir::FakeReadCause;\n use rustc_middle::ty::{self, TraitRef, Ty};\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::source_map::Span;\n@@ -184,6 +185,8 @@ impl<'a, 'tcx> Delegate<'tcx> for EscapeDelegate<'a, 'tcx> {\n             }\n         }\n     }\n+\n+    fn fake_read(&mut self, _: rustc_typeck::expr_use_visitor::Place<'tcx>, _: FakeReadCause, _: HirId) { }\n }\n \n impl<'a, 'tcx> EscapeDelegate<'a, 'tcx> {"}, {"sha": "cb56512db60fee29b266b2372ec8daa699304e24", "filename": "src/tools/clippy/clippy_lints/src/loops/mut_range_bound.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f5d8117c338a788bd24abec733fd143dfceb25a0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fmut_range_bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5d8117c338a788bd24abec733fd143dfceb25a0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fmut_range_bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fmut_range_bound.rs?ref=f5d8117c338a788bd24abec733fd143dfceb25a0", "patch": "@@ -4,6 +4,7 @@ use if_chain::if_chain;\n use rustc_hir::{BindingAnnotation, Expr, HirId, Node, PatKind};\n use rustc_infer::infer::TyCtxtInferExt;\n use rustc_lint::LateContext;\n+use rustc_middle::mir::FakeReadCause;\n use rustc_middle::ty;\n use rustc_span::source_map::Span;\n use rustc_typeck::expr_use_visitor::{ConsumeMode, Delegate, ExprUseVisitor, PlaceBase, PlaceWithHirId};\n@@ -106,6 +107,8 @@ impl<'tcx> Delegate<'tcx> for MutatePairDelegate<'_, 'tcx> {\n             }\n         }\n     }\n+\n+    fn fake_read(&mut self, _: rustc_typeck::expr_use_visitor::Place<'tcx>, _: FakeReadCause, _:HirId) { }\n }\n \n impl MutatePairDelegate<'_, '_> {"}, {"sha": "d439577f9c33b9918dbf0e1d6fda38924c842a85", "filename": "src/tools/clippy/clippy_lints/src/needless_pass_by_value.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f5d8117c338a788bd24abec733fd143dfceb25a0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5d8117c338a788bd24abec733fd143dfceb25a0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_pass_by_value.rs?ref=f5d8117c338a788bd24abec733fd143dfceb25a0", "patch": "@@ -11,6 +11,7 @@ use rustc_hir::intravisit::FnKind;\n use rustc_hir::{BindingAnnotation, Body, FnDecl, GenericArg, HirId, Impl, ItemKind, Node, PatKind, QPath, TyKind};\n use rustc_infer::infer::TyCtxtInferExt;\n use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::mir::FakeReadCause;\n use rustc_middle::ty::{self, TypeFoldable};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::symbol::kw;\n@@ -333,4 +334,6 @@ impl<'tcx> euv::Delegate<'tcx> for MovedVariablesCtxt {\n     fn borrow(&mut self, _: &euv::PlaceWithHirId<'tcx>, _: HirId, _: ty::BorrowKind) {}\n \n     fn mutate(&mut self, _: &euv::PlaceWithHirId<'tcx>, _: HirId) {}\n+\n+    fn fake_read(&mut self, _: rustc_typeck::expr_use_visitor::Place<'tcx>, _: FakeReadCause, _: HirId) { }\n }"}, {"sha": "0b1ab6b7ea188407e64ea32271737365e7903ef6", "filename": "src/tools/clippy/clippy_utils/src/usage.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f5d8117c338a788bd24abec733fd143dfceb25a0/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fusage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5d8117c338a788bd24abec733fd143dfceb25a0/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fusage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fusage.rs?ref=f5d8117c338a788bd24abec733fd143dfceb25a0", "patch": "@@ -7,6 +7,7 @@ use rustc_hir::intravisit::{NestedVisitorMap, Visitor};\n use rustc_hir::{Expr, ExprKind, HirId, Path};\n use rustc_infer::infer::TyCtxtInferExt;\n use rustc_lint::LateContext;\n+use rustc_middle::mir::FakeReadCause;\n use rustc_middle::hir::map::Map;\n use rustc_middle::ty;\n use rustc_typeck::expr_use_visitor::{ConsumeMode, Delegate, ExprUseVisitor, PlaceBase, PlaceWithHirId};\n@@ -77,6 +78,8 @@ impl<'tcx> Delegate<'tcx> for MutVarsDelegate {\n     fn mutate(&mut self, cmt: &PlaceWithHirId<'tcx>, _: HirId) {\n         self.update(&cmt)\n     }\n+\n+    fn fake_read(&mut self, _: rustc_typeck::expr_use_visitor::Place<'tcx>, _: FakeReadCause, _:HirId) { }\n }\n \n pub struct ParamBindingIdCollector {"}]}