{"sha": "244cdaa457d80b3e1ef90795a48833f948ac0db9", "node_id": "C_kwDOAAsO6NoAKDI0NGNkYWE0NTdkODBiM2UxZWY5MDc5NWE0ODgzM2Y5NDhhYzBkYjk", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2023-03-22T16:58:51Z"}, "committer": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2023-03-23T05:57:09Z"}, "message": "Remove AliasRelationDirection::Supertype", "tree": {"sha": "ce30e96a9b7191dbe69e43346c25657fb4088d68", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ce30e96a9b7191dbe69e43346c25657fb4088d68"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/244cdaa457d80b3e1ef90795a48833f948ac0db9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/244cdaa457d80b3e1ef90795a48833f948ac0db9", "html_url": "https://github.com/rust-lang/rust/commit/244cdaa457d80b3e1ef90795a48833f948ac0db9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/244cdaa457d80b3e1ef90795a48833f948ac0db9/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f6fd7546804dd25d4996196dbc9653bde2b4a131", "url": "https://api.github.com/repos/rust-lang/rust/commits/f6fd7546804dd25d4996196dbc9653bde2b4a131", "html_url": "https://github.com/rust-lang/rust/commit/f6fd7546804dd25d4996196dbc9653bde2b4a131"}], "stats": {"total": 190, "additions": 99, "deletions": 91}, "files": [{"sha": "88a28e26005d62f54ecb2120364ab94b96cbae75", "filename": "compiler/rustc_infer/src/infer/combine.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/244cdaa457d80b3e1ef90795a48833f948ac0db9/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/244cdaa457d80b3e1ef90795a48833f948ac0db9/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs?ref=244cdaa457d80b3e1ef90795a48833f948ac0db9", "patch": "@@ -128,7 +128,7 @@ impl<'tcx> InferCtxt<'tcx> {\n             (_, ty::Alias(AliasKind::Projection, _)) | (ty::Alias(AliasKind::Projection, _), _)\n                 if self.tcx.trait_solver_next() =>\n             {\n-                relation.register_type_equate_obligation(a, b);\n+                relation.register_type_relate_obligation(a, b);\n                 Ok(a)\n             }\n \n@@ -848,18 +848,18 @@ pub trait ObligationEmittingRelation<'tcx>: TypeRelation<'tcx> {\n         })]);\n     }\n \n-    /// Register an obligation that both types must be equal to each other.\n-    ///\n-    /// If they aren't equal then the relation doesn't hold.\n-    fn register_type_equate_obligation(&mut self, a: Ty<'tcx>, b: Ty<'tcx>) {\n+    /// Register an obligation that both types must be related to each other according to\n+    /// the [`ty::AliasRelationDirection`] given by [`ObligationEmittingRelation::alias_relate_direction`]\n+    fn register_type_relate_obligation(&mut self, a: Ty<'tcx>, b: Ty<'tcx>) {\n         self.register_predicates([ty::Binder::dummy(ty::PredicateKind::AliasRelate(\n             a.into(),\n             b.into(),\n             self.alias_relate_direction(),\n         ))]);\n     }\n \n-    /// Relation direction emitted for `AliasRelate` predicates\n+    /// Relation direction emitted for `AliasRelate` predicates, corresponding to the direction\n+    /// of the relation.\n     fn alias_relate_direction(&self) -> ty::AliasRelationDirection;\n }\n "}, {"sha": "61d1b69be5581f2f78e48c71d0c9c04cf2e67c34", "filename": "compiler/rustc_infer/src/infer/nll_relate/mod.rs", "status": "modified", "additions": 24, "deletions": 6, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/244cdaa457d80b3e1ef90795a48833f948ac0db9/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/244cdaa457d80b3e1ef90795a48833f948ac0db9/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs?ref=244cdaa457d80b3e1ef90795a48833f948ac0db9", "patch": "@@ -779,13 +779,31 @@ where\n     }\n \n     fn alias_relate_direction(&self) -> ty::AliasRelationDirection {\n-        match self.ambient_variance {\n-            ty::Variance::Covariant => ty::AliasRelationDirection::Subtype,\n-            ty::Variance::Contravariant => ty::AliasRelationDirection::Supertype,\n-            ty::Variance::Invariant => ty::AliasRelationDirection::Equate,\n-            // FIXME(deferred_projection_equality): Implement this when we trigger it\n+        unreachable!(\"manually overridden to handle ty::Variance::Contravariant ambient variance\")\n+    }\n+\n+    fn register_type_relate_obligation(&mut self, a: Ty<'tcx>, b: Ty<'tcx>) {\n+        self.register_predicates([ty::Binder::dummy(match self.ambient_variance {\n+            ty::Variance::Covariant => ty::PredicateKind::AliasRelate(\n+                a.into(),\n+                b.into(),\n+                ty::AliasRelationDirection::Subtype,\n+            ),\n+            // a :> b is b <: a\n+            ty::Variance::Contravariant => ty::PredicateKind::AliasRelate(\n+                b.into(),\n+                a.into(),\n+                ty::AliasRelationDirection::Subtype,\n+            ),\n+            ty::Variance::Invariant => ty::PredicateKind::AliasRelate(\n+                a.into(),\n+                b.into(),\n+                ty::AliasRelationDirection::Equate,\n+            ),\n+            // FIXME(deferred_projection_equality): Implement this when we trigger it.\n+            // Probably just need to do nothing here.\n             ty::Variance::Bivariant => unreachable!(),\n-        }\n+        })]);\n     }\n }\n "}, {"sha": "7ea242f55b0f1eeedbeb5ead1fb01053c2f197b0", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/244cdaa457d80b3e1ef90795a48833f948ac0db9/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/244cdaa457d80b3e1ef90795a48833f948ac0db9/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=244cdaa457d80b3e1ef90795a48833f948ac0db9", "patch": "@@ -648,25 +648,13 @@ pub enum PredicateKind<'tcx> {\n pub enum AliasRelationDirection {\n     Equate,\n     Subtype,\n-    Supertype,\n-}\n-\n-impl AliasRelationDirection {\n-    pub fn invert(self) -> Self {\n-        match self {\n-            AliasRelationDirection::Equate => AliasRelationDirection::Equate,\n-            AliasRelationDirection::Subtype => AliasRelationDirection::Supertype,\n-            AliasRelationDirection::Supertype => AliasRelationDirection::Subtype,\n-        }\n-    }\n }\n \n impl std::fmt::Display for AliasRelationDirection {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         match self {\n             AliasRelationDirection::Equate => write!(f, \" == \"),\n             AliasRelationDirection::Subtype => write!(f, \" <: \"),\n-            AliasRelationDirection::Supertype => write!(f, \" :> \"),\n         }\n     }\n }"}, {"sha": "75b304cce4e0908ff09e3129b7e0820fccba2fb1", "filename": "compiler/rustc_trait_selection/src/solve/eval_ctxt.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/244cdaa457d80b3e1ef90795a48833f948ac0db9/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/244cdaa457d80b3e1ef90795a48833f948ac0db9/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt.rs?ref=244cdaa457d80b3e1ef90795a48833f948ac0db9", "patch": "@@ -459,6 +459,25 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n             })\n     }\n \n+    #[instrument(level = \"debug\", skip(self, param_env), ret)]\n+    pub(super) fn sub<T: ToTrace<'tcx>>(\n+        &mut self,\n+        param_env: ty::ParamEnv<'tcx>,\n+        sub: T,\n+        sup: T,\n+    ) -> Result<(), NoSolution> {\n+        self.infcx\n+            .at(&ObligationCause::dummy(), param_env)\n+            .sub(DefineOpaqueTypes::No, sub, sup)\n+            .map(|InferOk { value: (), obligations }| {\n+                self.add_goals(obligations.into_iter().map(|o| o.into()));\n+            })\n+            .map_err(|e| {\n+                debug!(?e, \"failed to subtype\");\n+                NoSolution\n+            })\n+    }\n+\n     /// Equates two values returning the nested goals without adding them\n     /// to the nested goals of the `EvalCtxt`.\n     ///"}, {"sha": "4c87d36ca0dc1da97bd628c6faa9bcaf10be17e2", "filename": "compiler/rustc_trait_selection/src/solve/mod.rs", "status": "modified", "additions": 50, "deletions": 67, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/244cdaa457d80b3e1ef90795a48833f948ac0db9/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/244cdaa457d80b3e1ef90795a48833f948ac0db9/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs?ref=244cdaa457d80b3e1ef90795a48833f948ac0db9", "patch": "@@ -17,7 +17,6 @@\n \n use rustc_hir::def_id::DefId;\n use rustc_infer::infer::canonical::{Canonical, CanonicalVarValues};\n-use rustc_infer::infer::{DefineOpaqueTypes, InferOk};\n use rustc_infer::traits::query::NoSolution;\n use rustc_middle::traits::solve::{\n     CanonicalGoal, CanonicalResponse, Certainty, ExternalConstraints, ExternalConstraintsData,\n@@ -101,11 +100,7 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n             // That won't actually reflect in the query response, so it seems moot.\n             self.evaluate_added_goals_and_make_canonical_response(Certainty::AMBIGUOUS)\n         } else {\n-            let InferOk { value: (), obligations } = self\n-                .infcx\n-                .at(&ObligationCause::dummy(), goal.param_env)\n-                .sub(DefineOpaqueTypes::No, goal.predicate.a, goal.predicate.b)?;\n-            self.add_goals(obligations.into_iter().map(|pred| pred.into()));\n+            self.sub(goal.param_env, goal.predicate.a, goal.predicate.b)?;\n             self.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n         }\n     }\n@@ -161,44 +156,41 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n         goal: Goal<'tcx, (ty::Term<'tcx>, ty::Term<'tcx>, ty::AliasRelationDirection)>,\n     ) -> QueryResult<'tcx> {\n         let tcx = self.tcx();\n-\n-        let evaluate_normalizes_to = |ecx: &mut EvalCtxt<'_, 'tcx>, alias, other, direction| {\n-            debug!(\"evaluate_normalizes_to(alias={:?}, other={:?})\", alias, other);\n-            let result = ecx.probe(|ecx| {\n-                let other = match direction {\n-                    // This is purely an optimization.\n-                    ty::AliasRelationDirection::Equate => other,\n-\n-                    ty::AliasRelationDirection::Subtype | ty::AliasRelationDirection::Supertype => {\n-                        let fresh = ecx.next_term_infer_of_kind(other);\n-                        let (sub, sup) = if direction == ty::AliasRelationDirection::Subtype {\n-                            (fresh, other)\n-                        } else {\n-                            (other, fresh)\n-                        };\n-                        ecx.add_goals(\n-                            ecx.infcx\n-                                .at(&ObligationCause::dummy(), goal.param_env)\n-                                .sub(DefineOpaqueTypes::No, sub, sup)?\n-                                .into_obligations()\n-                                .into_iter()\n-                                .map(|o| o.into()),\n-                        );\n-                        fresh\n-                    }\n-                };\n-                ecx.add_goal(goal.with(\n-                    tcx,\n-                    ty::Binder::dummy(ty::ProjectionPredicate {\n-                        projection_ty: alias,\n-                        term: other,\n-                    }),\n-                ));\n-                ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n-            });\n-            debug!(\"evaluate_normalizes_to({alias}, {other}, {direction:?}) -> {result:?}\");\n-            result\n-        };\n+        // We may need to invert the alias relation direction if dealing an alias on the RHS.\n+        enum Invert {\n+            No,\n+            Yes,\n+        }\n+        let evaluate_normalizes_to =\n+            |ecx: &mut EvalCtxt<'_, 'tcx>, alias, other, direction, invert| {\n+                debug!(\"evaluate_normalizes_to(alias={:?}, other={:?})\", alias, other);\n+                let result = ecx.probe(|ecx| {\n+                    let other = match direction {\n+                        // This is purely an optimization.\n+                        ty::AliasRelationDirection::Equate => other,\n+\n+                        ty::AliasRelationDirection::Subtype => {\n+                            let fresh = ecx.next_term_infer_of_kind(other);\n+                            let (sub, sup) = match invert {\n+                                Invert::No => (fresh, other),\n+                                Invert::Yes => (other, fresh),\n+                            };\n+                            ecx.sub(goal.param_env, sub, sup)?;\n+                            fresh\n+                        }\n+                    };\n+                    ecx.add_goal(goal.with(\n+                        tcx,\n+                        ty::Binder::dummy(ty::ProjectionPredicate {\n+                            projection_ty: alias,\n+                            term: other,\n+                        }),\n+                    ));\n+                    ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n+                });\n+                debug!(\"evaluate_normalizes_to({alias}, {other}, {direction:?}) -> {result:?}\");\n+                result\n+            };\n \n         let (lhs, rhs, direction) = goal.predicate;\n \n@@ -212,46 +204,37 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n             (None, None) => bug!(\"`AliasRelate` goal without an alias on either lhs or rhs\"),\n \n             // RHS is not a projection, only way this is true is if LHS normalizes-to RHS\n-            (Some(alias_lhs), None) => evaluate_normalizes_to(self, alias_lhs, rhs, direction),\n+            (Some(alias_lhs), None) => {\n+                evaluate_normalizes_to(self, alias_lhs, rhs, direction, Invert::No)\n+            }\n \n             // LHS is not a projection, only way this is true is if RHS normalizes-to LHS\n             (None, Some(alias_rhs)) => {\n-                evaluate_normalizes_to(self, alias_rhs, lhs, direction.invert())\n+                evaluate_normalizes_to(self, alias_rhs, lhs, direction, Invert::Yes)\n             }\n \n             (Some(alias_lhs), Some(alias_rhs)) => {\n                 debug!(\"compute_alias_relate_goal: both sides are aliases\");\n \n                 let candidates = vec![\n                     // LHS normalizes-to RHS\n-                    evaluate_normalizes_to(self, alias_lhs, rhs, direction),\n+                    evaluate_normalizes_to(self, alias_lhs, rhs, direction, Invert::No),\n                     // RHS normalizes-to RHS\n-                    evaluate_normalizes_to(self, alias_rhs, lhs, direction.invert()),\n+                    evaluate_normalizes_to(self, alias_rhs, lhs, direction, Invert::Yes),\n                     // Relate via substs\n                     self.probe(|ecx| {\n                         debug!(\n                             \"compute_alias_relate_goal: alias defids are equal, equating substs\"\n                         );\n \n-                        ecx.add_goals(\n-                            match direction {\n-                                ty::AliasRelationDirection::Equate => ecx\n-                                    .infcx\n-                                    .at(&ObligationCause::dummy(), goal.param_env)\n-                                    .eq(DefineOpaqueTypes::No, alias_lhs, alias_rhs),\n-                                ty::AliasRelationDirection::Subtype => ecx\n-                                    .infcx\n-                                    .at(&ObligationCause::dummy(), goal.param_env)\n-                                    .sub(DefineOpaqueTypes::No, alias_lhs, alias_rhs),\n-                                ty::AliasRelationDirection::Supertype => ecx\n-                                    .infcx\n-                                    .at(&ObligationCause::dummy(), goal.param_env)\n-                                    .sup(DefineOpaqueTypes::No, alias_lhs, alias_rhs),\n-                            }?\n-                            .into_obligations()\n-                            .into_iter()\n-                            .map(|o| o.into()),\n-                        );\n+                        match direction {\n+                            ty::AliasRelationDirection::Equate => {\n+                                ecx.eq(goal.param_env, alias_lhs, alias_rhs)?;\n+                            }\n+                            ty::AliasRelationDirection::Subtype => {\n+                                ecx.sub(goal.param_env, alias_lhs, alias_rhs)?;\n+                            }\n+                        }\n \n                         ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n                     }),"}]}