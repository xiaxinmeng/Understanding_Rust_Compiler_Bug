{"sha": "cc3e6ecbfd4e95c7fe37df676bc05993885fa181", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNjM2U2ZWNiZmQ0ZTk1YzdmZTM3ZGY2NzZiYzA1OTkzODg1ZmExODE=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-12-30T23:30:14Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2014-01-02T22:16:07Z"}, "message": "libsyntax: De-`@mut` `Parser::last_span`", "tree": {"sha": "5f9db7cd6e25fe90b40b92be9b601db651af8677", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5f9db7cd6e25fe90b40b92be9b601db651af8677"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cc3e6ecbfd4e95c7fe37df676bc05993885fa181", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cc3e6ecbfd4e95c7fe37df676bc05993885fa181", "html_url": "https://github.com/rust-lang/rust/commit/cc3e6ecbfd4e95c7fe37df676bc05993885fa181", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cc3e6ecbfd4e95c7fe37df676bc05993885fa181/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0c6cee55eaf3871c4bb659fea9b3ada9ad1f9b2b", "url": "https://api.github.com/repos/rust-lang/rust/commits/0c6cee55eaf3871c4bb659fea9b3ada9ad1f9b2b", "html_url": "https://github.com/rust-lang/rust/commit/0c6cee55eaf3871c4bb659fea9b3ada9ad1f9b2b"}], "stats": {"total": 66, "additions": 32, "deletions": 34}, "files": [{"sha": "0d78acadcae4b44f5f136ae5663b8f4b0775b24e", "filename": "src/libsyntax/ext/asm.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cc3e6ecbfd4e95c7fe37df676bc05993885fa181/src%2Flibsyntax%2Fext%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc3e6ecbfd4e95c7fe37df676bc05993885fa181/src%2Flibsyntax%2Fext%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fasm.rs?ref=cc3e6ecbfd4e95c7fe37df676bc05993885fa181", "patch": "@@ -77,10 +77,10 @@ pub fn expand_asm(cx: &mut ExtCtxt, sp: Span, tts: &[ast::token_tree])\n                     let (constraint, _str_style) = p.parse_str();\n \n                     if constraint.starts_with(\"+\") {\n-                        cx.span_unimpl(*p.last_span,\n+                        cx.span_unimpl(p.last_span,\n                                        \"'+' (read+write) output operand constraint modifier\");\n                     } else if !constraint.starts_with(\"=\") {\n-                        cx.span_err(*p.last_span, \"output operand constraint lacks '='\");\n+                        cx.span_err(p.last_span, \"output operand constraint lacks '='\");\n                     }\n \n                     p.expect(&token::LPAREN);\n@@ -102,9 +102,9 @@ pub fn expand_asm(cx: &mut ExtCtxt, sp: Span, tts: &[ast::token_tree])\n                     let (constraint, _str_style) = p.parse_str();\n \n                     if constraint.starts_with(\"=\") {\n-                        cx.span_err(*p.last_span, \"input operand constraint contains '='\");\n+                        cx.span_err(p.last_span, \"input operand constraint contains '='\");\n                     } else if constraint.starts_with(\"+\") {\n-                        cx.span_err(*p.last_span, \"input operand constraint contains '+'\");\n+                        cx.span_err(p.last_span, \"input operand constraint contains '+'\");\n                     }\n \n                     p.expect(&token::LPAREN);"}, {"sha": "0f4cc2ae5cdbee29a53b638ae2440781a96f957f", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 28, "deletions": 30, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/cc3e6ecbfd4e95c7fe37df676bc05993885fa181/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc3e6ecbfd4e95c7fe37df676bc05993885fa181/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=cc3e6ecbfd4e95c7fe37df676bc05993885fa181", "patch": "@@ -286,9 +286,7 @@ struct ParsedItemsAndViewItems {\n \n /* ident is handled by common.rs */\n \n-pub fn Parser(sess: @mut ParseSess,\n-              cfg: ast::CrateConfig,\n-              rdr: @mut reader)\n+pub fn Parser(sess: @mut ParseSess, cfg: ast::CrateConfig, rdr: @mut reader)\n            -> Parser {\n     let tok0 = rdr.next_token();\n     let interner = get_ident_interner();\n@@ -305,7 +303,7 @@ pub fn Parser(sess: @mut ParseSess,\n         cfg: cfg,\n         token: tok0.tok,\n         span: span,\n-        last_span: @mut span,\n+        last_span: span,\n         last_token: @mut None,\n         buffer: @mut ([\n             placeholder.clone(),\n@@ -334,7 +332,7 @@ pub struct Parser {\n     // the span of the current token:\n     span: Span,\n     // the span of the prior token:\n-    last_span: @mut Span,\n+    last_span: Span,\n     // the previous token or None (only stashed sometimes).\n     last_token: @mut Option<~token::Token>,\n     buffer: @mut [TokenAndSpan, ..4],\n@@ -373,8 +371,8 @@ impl Parser {\n \n     pub fn unexpected_last(&mut self, t: &token::Token) -> ! {\n         let token_str = Parser::token_to_str(t);\n-        self.span_fatal(*self.last_span, format!(\"unexpected token: `{}`\",\n-                                                 token_str));\n+        self.span_fatal(self.last_span, format!(\"unexpected token: `{}`\",\n+                                                token_str));\n     }\n \n     pub fn unexpected(&mut self) -> ! {\n@@ -728,7 +726,7 @@ impl Parser {\n \n     // advance the parser by one token\n     pub fn bump(&mut self) {\n-        *self.last_span = self.span;\n+        self.last_span = self.span;\n         // Stash token for error recovery (sometimes; clone is not necessarily cheap).\n         *self.last_token = if is_ident_or_path(&self.token) {\n             Some(~self.token.clone())\n@@ -940,7 +938,7 @@ impl Parser {\n \n                     // Re-parse the region here. What a hack.\n                     if region.is_some() {\n-                        self.span_err(*self.last_span,\n+                        self.span_err(self.last_span,\n                                       \"lifetime declarations must precede \\\n                                        the lifetime associated with a \\\n                                        closure\");\n@@ -1281,13 +1279,13 @@ impl Parser {\n         match self.token {\n             token::LIFETIME(..) => {\n                 let lifetime = self.parse_lifetime();\n-                self.obsolete(*self.last_span, ObsoleteBoxedClosure);\n+                self.obsolete(self.last_span, ObsoleteBoxedClosure);\n                 return self.parse_ty_closure(Some(sigil), Some(lifetime));\n             }\n \n             token::IDENT(..) => {\n                 if self.token_is_old_style_closure_keyword() {\n-                    self.obsolete(*self.last_span, ObsoleteBoxedClosure);\n+                    self.obsolete(self.last_span, ObsoleteBoxedClosure);\n                     return self.parse_ty_closure(Some(sigil), None);\n                 }\n             }\n@@ -1310,7 +1308,7 @@ impl Parser {\n         let opt_lifetime = self.parse_opt_lifetime();\n \n         if self.token_is_old_style_closure_keyword() {\n-            self.obsolete(*self.last_span, ObsoleteClosureType);\n+            self.obsolete(self.last_span, ObsoleteClosureType);\n             return self.parse_ty_closure(Some(BorrowedSigil), opt_lifetime);\n         }\n \n@@ -1350,7 +1348,7 @@ impl Parser {\n         } else {\n             debug!(\"parse_arg_general ident_to_pat\");\n             ast_util::ident_to_pat(ast::DUMMY_NODE_ID,\n-                                   *self.last_span,\n+                                   self.last_span,\n                                    special_idents::invalid)\n         };\n \n@@ -1649,7 +1647,7 @@ impl Parser {\n         if self.eat_keyword(keywords::Mut) {\n             MutMutable\n         } else if self.eat_keyword(keywords::Const) {\n-            self.obsolete(*self.last_span, ObsoleteConstPointer);\n+            self.obsolete(self.last_span, ObsoleteConstPointer);\n             MutImmutable\n         } else {\n             MutImmutable\n@@ -2630,11 +2628,11 @@ impl Parser {\n         } else {\n             // This is an obsolete 'continue' expression\n             if opt_ident.is_some() {\n-                self.span_err(*self.last_span,\n+                self.span_err(self.last_span,\n                               \"a label may not be used with a `loop` expression\");\n             }\n \n-            self.obsolete(*self.last_span, ObsoleteLoopAsContinue);\n+            self.obsolete(self.last_span, ObsoleteLoopAsContinue);\n             let lo = self.span.lo;\n             let ex = if Parser::token_is_lifetime(&self.token) {\n                 let lifetime = self.get_lifetime();\n@@ -2848,7 +2846,7 @@ impl Parser {\n                 subpat = @ast::Pat {\n                     id: ast::DUMMY_NODE_ID,\n                     node: PatIdent(bind_type, fieldpath, None),\n-                    span: *self.last_span\n+                    span: self.last_span\n                 };\n             }\n             fields.push(ast::FieldPat { ident: fieldname, pat: subpat });\n@@ -3138,7 +3136,7 @@ impl Parser {\n                        binding_mode: ast::BindingMode)\n                        -> ast::Pat_ {\n         if !is_plain_ident(&self.token) {\n-            self.span_fatal(*self.last_span,\n+            self.span_fatal(self.last_span,\n                             \"expected identifier, found path\");\n         }\n         // why a path here, and not just an identifier?\n@@ -3157,7 +3155,7 @@ impl Parser {\n         // will direct us over to parse_enum_variant()\n         if self.token == token::LPAREN {\n             self.span_fatal(\n-                *self.last_span,\n+                self.last_span,\n                 \"expected identifier, found enum pattern\");\n         }\n \n@@ -3223,7 +3221,7 @@ impl Parser {\n         fn check_expected_item(p: &mut Parser, found_attrs: bool) {\n             // If we have attributes then we should have an item\n             if found_attrs {\n-                p.span_err(*p.last_span, \"expected item after attributes\");\n+                p.span_err(p.last_span, \"expected item after attributes\");\n             }\n         }\n \n@@ -3383,7 +3381,7 @@ impl Parser {\n             match self.token {\n                 token::SEMI => {\n                     if !attributes_box.is_empty() {\n-                        self.span_err(*self.last_span, \"expected item after attributes\");\n+                        self.span_err(self.last_span, \"expected item after attributes\");\n                         attributes_box = ~[];\n                     }\n                     self.bump(); // empty\n@@ -3461,7 +3459,7 @@ impl Parser {\n         }\n \n         if !attributes_box.is_empty() {\n-            self.span_err(*self.last_span, \"expected item after attributes\");\n+            self.span_err(self.last_span, \"expected item after attributes\");\n         }\n \n         let hi = self.span.hi;\n@@ -3709,7 +3707,7 @@ impl Parser {\n           token::TILDE => {\n             maybe_parse_explicit_self(|mutability| {\n                 if mutability != MutImmutable {\n-                    self.span_err(*self.last_span,\n+                    self.span_err(self.last_span,\n                                   \"mutability declaration not allowed here\");\n                 }\n                 sty_uniq(MutImmutable)\n@@ -3983,7 +3981,7 @@ impl Parser {\n \n         let mut meths = ~[];\n         let inner_attrs = if self.eat(&token::SEMI) {\n-            self.obsolete(*self.last_span, ObsoleteEmptyImpl);\n+            self.obsolete(self.last_span, ObsoleteEmptyImpl);\n             None\n         } else {\n             self.expect(&token::LBRACE);\n@@ -4166,7 +4164,7 @@ impl Parser {\n \n         if first && attrs_remaining_len > 0u {\n             // We parsed attributes for the first item but didn't find it\n-            self.span_err(*self.last_span, \"expected item after attributes\");\n+            self.span_err(self.last_span, \"expected item after attributes\");\n         }\n \n         ast::_mod { view_items: view_items, items: items }\n@@ -4300,7 +4298,7 @@ impl Parser {\n         // Parse obsolete purity.\n         let purity = self.parse_fn_purity();\n         if purity != impure_fn {\n-            self.obsolete(*self.last_span, ObsoleteUnsafeExternFn);\n+            self.obsolete(self.last_span, ObsoleteUnsafeExternFn);\n         }\n \n         let (ident, generics) = self.parse_fn_header();\n@@ -4360,7 +4358,7 @@ impl Parser {\n             foreign_items: foreign_items\n         } = self.parse_foreign_items(first_item_attrs, true);\n         if (! attrs_remaining.is_empty()) {\n-            self.span_err(*self.last_span,\n+            self.span_err(self.last_span,\n                           \"expected item after attributes\");\n         }\n         assert!(self.token == token::RBRACE);\n@@ -4418,7 +4416,7 @@ impl Parser {\n         if items_allowed && self.eat(&token::LBRACE) {\n             // `extern mod foo { ... }` is obsolete.\n             if named {\n-                self.obsolete(*self.last_span, ObsoleteNamedExternModule);\n+                self.obsolete(self.last_span, ObsoleteNamedExternModule);\n             }\n \n             let abis = opt_abis.unwrap_or(AbiSet::C());\n@@ -4863,7 +4861,7 @@ impl Parser {\n                 s.push_str(\"priv\")\n             }\n             s.push_char('`');\n-            self.span_fatal(*self.last_span, s);\n+            self.span_fatal(self.last_span, s);\n         }\n         return iovi_none(attrs);\n     }\n@@ -5018,7 +5016,7 @@ impl Parser {\n         let mut vp = ~[self.parse_view_path()];\n         while self.token == token::COMMA {\n             self.bump();\n-            self.obsolete(*self.last_span, ObsoleteMultipleImport);\n+            self.obsolete(self.last_span, ObsoleteMultipleImport);\n             vp.push(self.parse_view_path());\n         }\n         return vp;"}]}