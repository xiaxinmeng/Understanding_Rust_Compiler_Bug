{"sha": "c6b0803202c95abd614c8ea448f7c7ff948da31a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM2YjA4MDMyMDJjOTVhYmQ2MTRjOGVhNDQ4ZjdjN2ZmOTQ4ZGEzMWE=", "commit": {"author": {"name": "Nikita Popov", "email": "nikita.ppv@gmail.com", "date": "2020-01-05T18:16:58Z"}, "committer": {"name": "Nikita Popov", "email": "nikita.ppv@gmail.com", "date": "2020-02-12T14:34:16Z"}, "message": "Add support for new pass manager\n\nThe new pass manager can be enabled using\n-Z new-llvm-pass-manager=on.", "tree": {"sha": "ff563ab4d941505fce9c69f570f21db541c91ca5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ff563ab4d941505fce9c69f570f21db541c91ca5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c6b0803202c95abd614c8ea448f7c7ff948da31a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c6b0803202c95abd614c8ea448f7c7ff948da31a", "html_url": "https://github.com/rust-lang/rust/commit/c6b0803202c95abd614c8ea448f7c7ff948da31a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c6b0803202c95abd614c8ea448f7c7ff948da31a/comments", "author": {"login": "nikic", "id": 216080, "node_id": "MDQ6VXNlcjIxNjA4MA==", "avatar_url": "https://avatars.githubusercontent.com/u/216080?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikic", "html_url": "https://github.com/nikic", "followers_url": "https://api.github.com/users/nikic/followers", "following_url": "https://api.github.com/users/nikic/following{/other_user}", "gists_url": "https://api.github.com/users/nikic/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikic/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikic/subscriptions", "organizations_url": "https://api.github.com/users/nikic/orgs", "repos_url": "https://api.github.com/users/nikic/repos", "events_url": "https://api.github.com/users/nikic/events{/privacy}", "received_events_url": "https://api.github.com/users/nikic/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikic", "id": 216080, "node_id": "MDQ6VXNlcjIxNjA4MA==", "avatar_url": "https://avatars.githubusercontent.com/u/216080?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikic", "html_url": "https://github.com/nikic", "followers_url": "https://api.github.com/users/nikic/followers", "following_url": "https://api.github.com/users/nikic/following{/other_user}", "gists_url": "https://api.github.com/users/nikic/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikic/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikic/subscriptions", "organizations_url": "https://api.github.com/users/nikic/orgs", "repos_url": "https://api.github.com/users/nikic/repos", "events_url": "https://api.github.com/users/nikic/events{/privacy}", "received_events_url": "https://api.github.com/users/nikic/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "737f08bc28363626cf4036f646cb182b61d05bd3", "url": "https://api.github.com/repos/rust-lang/rust/commits/737f08bc28363626cf4036f646cb182b61d05bd3", "html_url": "https://github.com/rust-lang/rust/commit/737f08bc28363626cf4036f646cb182b61d05bd3"}], "stats": {"total": 445, "additions": 422, "deletions": 23}, "files": [{"sha": "e3d69fc5c76dfcc87f39ec1b6c9c558959b7380c", "filename": "src/librustc_codegen_llvm/back/lto.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c6b0803202c95abd614c8ea448f7c7ff948da31a/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6b0803202c95abd614c8ea448f7c7ff948da31a/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs?ref=c6b0803202c95abd614c8ea448f7c7ff948da31a", "patch": "@@ -584,6 +584,20 @@ pub(crate) fn run_pass_manager(\n     //      tools/lto/LTOCodeGenerator.cpp\n     debug!(\"running the pass manager\");\n     unsafe {\n+        if write::should_use_new_llvm_pass_manager(config) {\n+            let opt_stage = if thin { llvm::OptStage::ThinLTO } else { llvm::OptStage::FatLTO };\n+            let opt_level = config.opt_level.unwrap_or(config::OptLevel::No);\n+            // See comment below for why this is necessary.\n+            let opt_level = if let config::OptLevel::No = opt_level {\n+                config::OptLevel::Less\n+            } else {\n+                opt_level\n+            };\n+            write::optimize_with_new_llvm_pass_manager(module, config, opt_level, opt_stage);\n+            debug!(\"lto done\");\n+            return;\n+        }\n+\n         let pm = llvm::LLVMCreatePassManager();\n         llvm::LLVMAddAnalysisPasses(module.module_llvm.tm, pm);\n "}, {"sha": "9008970847a59987204b4dd3e6ca4261eef0db86", "filename": "src/librustc_codegen_llvm/back/write.rs", "status": "modified", "additions": 107, "deletions": 18, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/c6b0803202c95abd614c8ea448f7c7ff948da31a/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6b0803202c95abd614c8ea448f7c7ff948da31a/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs?ref=c6b0803202c95abd614c8ea448f7c7ff948da31a", "patch": "@@ -111,6 +111,18 @@ pub fn to_llvm_opt_settings(\n     }\n }\n \n+fn to_pass_builder_opt_level(cfg: config::OptLevel) -> llvm::PassBuilderOptLevel {\n+    use config::OptLevel::*;\n+    match cfg {\n+        No => llvm::PassBuilderOptLevel::O0,\n+        Less => llvm::PassBuilderOptLevel::O1,\n+        Default => llvm::PassBuilderOptLevel::O2,\n+        Aggressive => llvm::PassBuilderOptLevel::O3,\n+        Size => llvm::PassBuilderOptLevel::Os,\n+        SizeMin => llvm::PassBuilderOptLevel::Oz,\n+    }\n+}\n+\n // If find_features is true this won't access `sess.crate_types` by assuming\n // that `is_pie_binary` is false. When we discover LLVM target features\n // `sess.crate_types` is uninitialized so we cannot access it.\n@@ -303,6 +315,88 @@ unsafe extern \"C\" fn diagnostic_handler(info: &DiagnosticInfo, user: *mut c_void\n     }\n }\n \n+fn get_pgo_gen_path(config: &ModuleConfig) -> Option<CString> {\n+    match config.pgo_gen {\n+        SwitchWithOptPath::Enabled(ref opt_dir_path) => {\n+            let path = if let Some(dir_path) = opt_dir_path {\n+                dir_path.join(\"default_%m.profraw\")\n+            } else {\n+                PathBuf::from(\"default_%m.profraw\")\n+            };\n+\n+            Some(CString::new(format!(\"{}\", path.display())).unwrap())\n+        }\n+        SwitchWithOptPath::Disabled => None,\n+    }\n+}\n+\n+fn get_pgo_use_path(config: &ModuleConfig) -> Option<CString> {\n+    config\n+        .pgo_use\n+        .as_ref()\n+        .map(|path_buf| CString::new(path_buf.to_string_lossy().as_bytes()).unwrap())\n+}\n+\n+pub(crate) fn should_use_new_llvm_pass_manager(config: &ModuleConfig) -> bool {\n+    // We only support the new pass manager starting with LLVM 9.\n+    if llvm_util::get_major_version() < 9 {\n+        return false;\n+    }\n+\n+    // The new pass manager is disabled by default.\n+    config.new_llvm_pass_manager.unwrap_or(false)\n+}\n+\n+pub(crate) unsafe fn optimize_with_new_llvm_pass_manager(\n+    module: &ModuleCodegen<ModuleLlvm>,\n+    config: &ModuleConfig,\n+    opt_level: config::OptLevel,\n+    opt_stage: llvm::OptStage,\n+) {\n+    let unroll_loops =\n+        opt_level != config::OptLevel::Size && opt_level != config::OptLevel::SizeMin;\n+    let using_thin_buffers = opt_stage == llvm::OptStage::PreLinkThinLTO || config.bitcode_needed();\n+    let pgo_gen_path = get_pgo_gen_path(config);\n+    let pgo_use_path = get_pgo_use_path(config);\n+    let is_lto = opt_stage == llvm::OptStage::ThinLTO || opt_stage == llvm::OptStage::FatLTO;\n+    // Sanitizer instrumentation is only inserted during the pre-link optimization stage.\n+    let sanitizer_options = if !is_lto {\n+        config.sanitizer.as_ref().map(|s| llvm::SanitizerOptions {\n+            sanitize_memory: *s == Sanitizer::Memory,\n+            sanitize_thread: *s == Sanitizer::Thread,\n+            sanitize_address: *s == Sanitizer::Address,\n+            sanitize_recover: config.sanitizer_recover.contains(s),\n+            sanitize_memory_track_origins: config.sanitizer_memory_track_origins as c_int,\n+        })\n+    } else {\n+        None\n+    };\n+\n+    // FIXME: NewPM doesn't provide a facility to pass custom InlineParams.\n+    // We would have to add upstream support for this first, before we can support\n+    // config.inline_threshold and our more aggressive default thresholds.\n+    // FIXME: NewPM uses an different and more explicit way to textually represent\n+    // pass pipelines. It would probably make sense to expose this, but it would\n+    // require a different format than the current -C passes.\n+    llvm::LLVMRustOptimizeWithNewPassManager(\n+        module.module_llvm.llmod(),\n+        &*module.module_llvm.tm,\n+        to_pass_builder_opt_level(opt_level),\n+        opt_stage,\n+        config.no_prepopulate_passes,\n+        config.verify_llvm_ir,\n+        using_thin_buffers,\n+        config.merge_functions,\n+        unroll_loops,\n+        config.vectorize_slp,\n+        config.vectorize_loop,\n+        config.no_builtins,\n+        sanitizer_options.as_ref(),\n+        pgo_gen_path.as_ref().map_or(std::ptr::null(), |s| s.as_ptr()),\n+        pgo_use_path.as_ref().map_or(std::ptr::null(), |s| s.as_ptr()),\n+    );\n+}\n+\n // Unsafe due to LLVM calls.\n pub(crate) unsafe fn optimize(\n     cgcx: &CodegenContext<LlvmCodegenBackend>,\n@@ -327,6 +421,17 @@ pub(crate) unsafe fn optimize(\n     }\n \n     if let Some(opt_level) = config.opt_level {\n+        if should_use_new_llvm_pass_manager(config) {\n+            let opt_stage = match cgcx.lto {\n+                Lto::Fat => llvm::OptStage::PreLinkFatLTO,\n+                Lto::Thin | Lto::ThinLocal => llvm::OptStage::PreLinkThinLTO,\n+                _ if cgcx.opts.cg.linker_plugin_lto.enabled() => llvm::OptStage::PreLinkThinLTO,\n+                _ => llvm::OptStage::PreLinkNoLTO,\n+            };\n+            optimize_with_new_llvm_pass_manager(module, config, opt_level, opt_stage);\n+            return Ok(());\n+        }\n+\n         // Create the two optimizing pass managers. These mirror what clang\n         // does, and are by populated by LLVM's default PassManagerBuilder.\n         // Each manager has a different set of passes, but they also share\n@@ -757,24 +862,8 @@ pub unsafe fn with_llvm_pmb(\n     let opt_size =\n         config.opt_size.map(|x| to_llvm_opt_settings(x).1).unwrap_or(llvm::CodeGenOptSizeNone);\n     let inline_threshold = config.inline_threshold;\n-\n-    let pgo_gen_path = match config.pgo_gen {\n-        SwitchWithOptPath::Enabled(ref opt_dir_path) => {\n-            let path = if let Some(dir_path) = opt_dir_path {\n-                dir_path.join(\"default_%m.profraw\")\n-            } else {\n-                PathBuf::from(\"default_%m.profraw\")\n-            };\n-\n-            Some(CString::new(format!(\"{}\", path.display())).unwrap())\n-        }\n-        SwitchWithOptPath::Disabled => None,\n-    };\n-\n-    let pgo_use_path = config\n-        .pgo_use\n-        .as_ref()\n-        .map(|path_buf| CString::new(path_buf.to_string_lossy().as_bytes()).unwrap());\n+    let pgo_gen_path = get_pgo_gen_path(config);\n+    let pgo_use_path = get_pgo_use_path(config);\n \n     llvm::LLVMRustConfigurePassManagerBuilder(\n         builder,"}, {"sha": "f570e808f56f4bdfaa0e8fa60ca088e22aa60e45", "filename": "src/librustc_codegen_llvm/llvm/ffi.rs", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/c6b0803202c95abd614c8ea448f7c7ff948da31a/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6b0803202c95abd614c8ea448f7c7ff948da31a/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs?ref=c6b0803202c95abd614c8ea448f7c7ff948da31a", "patch": "@@ -402,6 +402,38 @@ pub enum CodeGenOptLevel {\n     Aggressive,\n }\n \n+/// LLVMRustPassBuilderOptLevel\n+#[repr(C)]\n+pub enum PassBuilderOptLevel {\n+    O0,\n+    O1,\n+    O2,\n+    O3,\n+    Os,\n+    Oz,\n+}\n+\n+/// LLVMRustOptStage\n+#[derive(PartialEq)]\n+#[repr(C)]\n+pub enum OptStage {\n+    PreLinkNoLTO,\n+    PreLinkThinLTO,\n+    PreLinkFatLTO,\n+    ThinLTO,\n+    FatLTO,\n+}\n+\n+/// LLVMRustSanitizerOptions\n+#[repr(C)]\n+pub struct SanitizerOptions {\n+    pub sanitize_memory: bool,\n+    pub sanitize_thread: bool,\n+    pub sanitize_address: bool,\n+    pub sanitize_recover: bool,\n+    pub sanitize_memory_track_origins: c_int,\n+}\n+\n /// LLVMRelocMode\n #[derive(Copy, Clone, PartialEq)]\n #[repr(C)]\n@@ -1896,6 +1928,23 @@ extern \"C\" {\n         Output: *const c_char,\n         FileType: FileType,\n     ) -> LLVMRustResult;\n+    pub fn LLVMRustOptimizeWithNewPassManager(\n+        M: &'a Module,\n+        TM: &'a TargetMachine,\n+        OptLevel: PassBuilderOptLevel,\n+        OptStage: OptStage,\n+        NoPrepopulatePasses: bool,\n+        VerifyIR: bool,\n+        UseThinLTOBuffers: bool,\n+        MergeFunctions: bool,\n+        UnrollLoops: bool,\n+        SLPVectorize: bool,\n+        LoopVectorize: bool,\n+        DisableSimplifyLibCalls: bool,\n+        SanitizerOptions: Option<&SanitizerOptions>,\n+        PGOGenPath: *const c_char,\n+        PGOUsePath: *const c_char,\n+    );\n     pub fn LLVMRustPrintModule(\n         M: &'a Module,\n         Output: *const c_char,"}, {"sha": "92f795acc543805912c670656eb2e9239289190d", "filename": "src/librustc_codegen_ssa/back/write.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c6b0803202c95abd614c8ea448f7c7ff948da31a/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6b0803202c95abd614c8ea448f7c7ff948da31a/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs?ref=c6b0803202c95abd614c8ea448f7c7ff948da31a", "patch": "@@ -88,6 +88,7 @@ pub struct ModuleConfig {\n     pub vectorize_slp: bool,\n     pub merge_functions: bool,\n     pub inline_threshold: Option<usize>,\n+    pub new_llvm_pass_manager: Option<bool>,\n     // Instead of creating an object file by doing LLVM codegen, just\n     // make the object file bitcode. Provides easy compatibility with\n     // emscripten's ecc compiler, when used as the linker.\n@@ -132,6 +133,7 @@ impl ModuleConfig {\n             vectorize_slp: false,\n             merge_functions: false,\n             inline_threshold: None,\n+            new_llvm_pass_manager: None,\n         }\n     }\n \n@@ -140,6 +142,7 @@ impl ModuleConfig {\n         self.no_prepopulate_passes = sess.opts.cg.no_prepopulate_passes;\n         self.no_builtins = no_builtins || sess.target.target.options.no_builtins;\n         self.inline_threshold = sess.opts.cg.inline_threshold;\n+        self.new_llvm_pass_manager = sess.opts.debugging_opts.new_llvm_pass_manager;\n         self.obj_is_bitcode =\n             sess.target.target.options.obj_is_bitcode || sess.opts.cg.linker_plugin_lto.enabled();\n         let embed_bitcode ="}, {"sha": "a794670d7b8fe58b4ba4a6e9b094f1df2d312146", "filename": "src/librustc_session/options.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6b0803202c95abd614c8ea448f7c7ff948da31a/src%2Flibrustc_session%2Foptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6b0803202c95abd614c8ea448f7c7ff948da31a/src%2Flibrustc_session%2Foptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_session%2Foptions.rs?ref=c6b0803202c95abd614c8ea448f7c7ff948da31a", "patch": "@@ -968,4 +968,6 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n         \"compile without linking\"),\n     link_only: bool = (false, parse_bool, [TRACKED],\n         \"link the `.rlink` file generated by `-Z no-link`\"),\n+    new_llvm_pass_manager: Option<bool> = (None, parse_opt_bool, [TRACKED],\n+        \"use new LLVM pass manager\"),\n }"}, {"sha": "15e2251d763214789e515070d8b870bfddd78f5c", "filename": "src/rustllvm/PassWrapper.cpp", "status": "modified", "additions": 243, "deletions": 1, "changes": 244, "blob_url": "https://github.com/rust-lang/rust/blob/c6b0803202c95abd614c8ea448f7c7ff948da31a/src%2Frustllvm%2FPassWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/c6b0803202c95abd614c8ea448f7c7ff948da31a/src%2Frustllvm%2FPassWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FPassWrapper.cpp?ref=c6b0803202c95abd614c8ea448f7c7ff948da31a", "patch": "@@ -12,6 +12,11 @@\n #include \"llvm/IR/AutoUpgrade.h\"\n #include \"llvm/IR/AssemblyAnnotationWriter.h\"\n #include \"llvm/IR/IntrinsicInst.h\"\n+#include \"llvm/IR/Verifier.h\"\n+#include \"llvm/Passes/PassBuilder.h\"\n+#if LLVM_VERSION_GE(9, 0)\n+#include \"llvm/Passes/StandardInstrumentations.h\"\n+#endif\n #include \"llvm/Support/CBindingWrapping.h\"\n #include \"llvm/Support/FileSystem.h\"\n #include \"llvm/Support/Host.h\"\n@@ -32,9 +37,12 @@\n #include \"llvm/Transforms/Instrumentation/ThreadSanitizer.h\"\n #include \"llvm/Transforms/Instrumentation/MemorySanitizer.h\"\n #endif\n+#if LLVM_VERSION_GE(9, 0)\n+#include \"llvm/Transforms/Utils/CanonicalizeAliases.h\"\n+#endif\n+#include \"llvm/Transforms/Utils/NameAnonGlobals.h\"\n \n using namespace llvm;\n-using namespace llvm::legacy;\n \n typedef struct LLVMOpaquePass *LLVMPassRef;\n typedef struct LLVMOpaqueTargetMachine *LLVMTargetMachineRef;\n@@ -314,6 +322,34 @@ static CodeGenOpt::Level fromRust(LLVMRustCodeGenOptLevel Level) {\n   }\n }\n \n+enum class LLVMRustPassBuilderOptLevel {\n+  O0,\n+  O1,\n+  O2,\n+  O3,\n+  Os,\n+  Oz,\n+};\n+\n+static PassBuilder::OptimizationLevel fromRust(LLVMRustPassBuilderOptLevel Level) {\n+  switch (Level) {\n+  case LLVMRustPassBuilderOptLevel::O0:\n+    return PassBuilder::O0;\n+  case LLVMRustPassBuilderOptLevel::O1:\n+    return PassBuilder::O1;\n+  case LLVMRustPassBuilderOptLevel::O2:\n+    return PassBuilder::O2;\n+  case LLVMRustPassBuilderOptLevel::O3:\n+    return PassBuilder::O3;\n+  case LLVMRustPassBuilderOptLevel::Os:\n+    return PassBuilder::Os;\n+  case LLVMRustPassBuilderOptLevel::Oz:\n+    return PassBuilder::Oz;\n+  default:\n+    report_fatal_error(\"Bad PassBuilderOptLevel.\");\n+  }\n+}\n+\n enum class LLVMRustRelocMode {\n   Default,\n   Static,\n@@ -604,6 +640,212 @@ LLVMRustWriteOutputFile(LLVMTargetMachineRef Target, LLVMPassManagerRef PMR,\n   return LLVMRustResult::Success;\n }\n \n+enum class LLVMRustOptStage {\n+  PreLinkNoLTO,\n+  PreLinkThinLTO,\n+  PreLinkFatLTO,\n+  ThinLTO,\n+  FatLTO,\n+};\n+\n+struct LLVMRustSanitizerOptions {\n+  bool SanitizeMemory;\n+  bool SanitizeThread;\n+  bool SanitizeAddress;\n+  bool SanitizeRecover;\n+  int SanitizeMemoryTrackOrigins;\n+};\n+\n+extern \"C\" void\n+LLVMRustOptimizeWithNewPassManager(\n+    LLVMModuleRef ModuleRef,\n+    LLVMTargetMachineRef TMRef,\n+    LLVMRustPassBuilderOptLevel OptLevelRust,\n+    LLVMRustOptStage OptStage,\n+    bool NoPrepopulatePasses, bool VerifyIR, bool UseThinLTOBuffers,\n+    bool MergeFunctions, bool UnrollLoops, bool SLPVectorize, bool LoopVectorize,\n+    bool DisableSimplifyLibCalls,\n+    LLVMRustSanitizerOptions *SanitizerOptions,\n+    const char *PGOGenPath, const char *PGOUsePath) {\n+#if LLVM_VERSION_GE(9, 0)\n+  Module *TheModule = unwrap(ModuleRef);\n+  TargetMachine *TM = unwrap(TMRef);\n+  PassBuilder::OptimizationLevel OptLevel = fromRust(OptLevelRust);\n+\n+  // FIXME: MergeFunctions is not supported by NewPM yet.\n+  (void) MergeFunctions;\n+\n+  PipelineTuningOptions PTO;\n+  PTO.LoopUnrolling = UnrollLoops;\n+  PTO.LoopInterleaving = UnrollLoops;\n+  PTO.LoopVectorization = LoopVectorize;\n+  PTO.SLPVectorization = SLPVectorize;\n+\n+  PassInstrumentationCallbacks PIC;\n+  StandardInstrumentations SI;\n+  SI.registerCallbacks(PIC);\n+\n+  Optional<PGOOptions> PGOOpt;\n+  if (PGOGenPath) {\n+    assert(!PGOUsePath);\n+    PGOOpt = PGOOptions(PGOGenPath, \"\", \"\", PGOOptions::IRInstr);\n+  } else if (PGOUsePath) {\n+    assert(!PGOGenPath);\n+    PGOOpt = PGOOptions(PGOUsePath, \"\", \"\", PGOOptions::IRUse);\n+  }\n+\n+  PassBuilder PB(TM, PTO, PGOOpt, &PIC);\n+\n+  // FIXME: We may want to expose this as an option.\n+  bool DebugPassManager = false;\n+  LoopAnalysisManager LAM(DebugPassManager);\n+  FunctionAnalysisManager FAM(DebugPassManager);\n+  CGSCCAnalysisManager CGAM(DebugPassManager);\n+  ModuleAnalysisManager MAM(DebugPassManager);\n+\n+  FAM.registerPass([&] { return PB.buildDefaultAAPipeline(); });\n+\n+  Triple TargetTriple(TheModule->getTargetTriple());\n+  std::unique_ptr<TargetLibraryInfoImpl> TLII(new TargetLibraryInfoImpl(TargetTriple));\n+  if (DisableSimplifyLibCalls)\n+    TLII->disableAllFunctions();\n+  FAM.registerPass([&] { return TargetLibraryAnalysis(*TLII); });\n+\n+  PB.registerModuleAnalyses(MAM);\n+  PB.registerCGSCCAnalyses(CGAM);\n+  PB.registerFunctionAnalyses(FAM);\n+  PB.registerLoopAnalyses(LAM);\n+  PB.crossRegisterProxies(LAM, FAM, CGAM, MAM);\n+\n+  // We manually collect pipeline callbacks so we can apply them at O0, where the\n+  // PassBuilder does not create a pipeline.\n+  std::vector<std::function<void(ModulePassManager &)>> PipelineStartEPCallbacks;\n+  std::vector<std::function<void(FunctionPassManager &, PassBuilder::OptimizationLevel)>>\n+      OptimizerLastEPCallbacks;\n+\n+  if (VerifyIR) {\n+    PipelineStartEPCallbacks.push_back([VerifyIR](ModulePassManager &MPM) {\n+        MPM.addPass(VerifierPass());\n+    });\n+  }\n+\n+  if (SanitizerOptions) {\n+    if (SanitizerOptions->SanitizeMemory) {\n+      MemorySanitizerOptions Options(\n+          SanitizerOptions->SanitizeMemoryTrackOrigins,\n+          SanitizerOptions->SanitizeRecover,\n+          /*CompileKernel=*/false);\n+#if LLVM_VERSION_GE(10, 0)\n+      PipelineStartEPCallbacks.push_back([Options](ModulePassManager &MPM) {\n+        MPM.addPass(MemorySanitizerPass(Options));\n+      });\n+#endif\n+      OptimizerLastEPCallbacks.push_back(\n+        [Options](FunctionPassManager &FPM, PassBuilder::OptimizationLevel Level) {\n+          FPM.addPass(MemorySanitizerPass(Options));\n+        }\n+      );\n+    }\n+\n+    if (SanitizerOptions->SanitizeThread) {\n+#if LLVM_VERSION_GE(10, 0)\n+      PipelineStartEPCallbacks.push_back([](ModulePassManager &MPM) {\n+        MPM.addPass(ThreadSanitizerPass());\n+      });\n+#endif\n+      OptimizerLastEPCallbacks.push_back(\n+        [](FunctionPassManager &FPM, PassBuilder::OptimizationLevel Level) {\n+          FPM.addPass(ThreadSanitizerPass());\n+        }\n+      );\n+    }\n+\n+    if (SanitizerOptions->SanitizeAddress) {\n+      // FIXME: Rust does not expose the UseAfterScope option.\n+      PipelineStartEPCallbacks.push_back([&](ModulePassManager &MPM) {\n+        MPM.addPass(RequireAnalysisPass<ASanGlobalsMetadataAnalysis, Module>());\n+      });\n+      OptimizerLastEPCallbacks.push_back(\n+        [SanitizerOptions](FunctionPassManager &FPM, PassBuilder::OptimizationLevel Level) {\n+          FPM.addPass(AddressSanitizerPass(\n+              /*CompileKernel=*/false, SanitizerOptions->SanitizeRecover));\n+        }\n+      );\n+      PipelineStartEPCallbacks.push_back(\n+        [SanitizerOptions](ModulePassManager &MPM) {\n+          MPM.addPass(ModuleAddressSanitizerPass(\n+              /*CompileKernel=*/false, SanitizerOptions->SanitizeRecover));\n+        }\n+      );\n+    }\n+  }\n+\n+  ModulePassManager MPM(DebugPassManager);\n+  if (!NoPrepopulatePasses) {\n+    if (OptLevel == PassBuilder::O0) {\n+      for (const auto &C : PipelineStartEPCallbacks)\n+        C(MPM);\n+\n+      if (!OptimizerLastEPCallbacks.empty()) {\n+        FunctionPassManager FPM(DebugPassManager);\n+        for (const auto &C : OptimizerLastEPCallbacks)\n+          C(FPM, OptLevel);\n+        MPM.addPass(createModuleToFunctionPassAdaptor(std::move(FPM)));\n+      }\n+\n+      MPM.addPass(AlwaysInlinerPass(/*InsertLifetimeIntrinsics=*/false));\n+\n+#if LLVM_VERSION_GE(10, 0)\n+      if (PGOOpt) {\n+        PB.addPGOInstrPassesForO0(\n+            MPM, DebugPassManager, PGOOpt->Action == PGOOptions::IRInstr,\n+            /*IsCS=*/false, PGOOpt->ProfileFile, PGOOpt->ProfileRemappingFile);\n+      }\n+#endif\n+    } else {\n+      for (const auto &C : PipelineStartEPCallbacks)\n+        PB.registerPipelineStartEPCallback(C);\n+      for (const auto &C : OptimizerLastEPCallbacks)\n+        PB.registerOptimizerLastEPCallback(C);\n+\n+      switch (OptStage) {\n+      case LLVMRustOptStage::PreLinkNoLTO:\n+        MPM = PB.buildPerModuleDefaultPipeline(OptLevel, DebugPassManager);\n+        break;\n+      case LLVMRustOptStage::PreLinkThinLTO:\n+        MPM = PB.buildThinLTOPreLinkDefaultPipeline(OptLevel, DebugPassManager);\n+        break;\n+      case LLVMRustOptStage::PreLinkFatLTO:\n+        MPM = PB.buildLTOPreLinkDefaultPipeline(OptLevel, DebugPassManager);\n+        break;\n+      case LLVMRustOptStage::ThinLTO:\n+        // FIXME: Does it make sense to pass the ModuleSummaryIndex?\n+        // It only seems to be needed for C++ specific optimizations.\n+        MPM = PB.buildThinLTODefaultPipeline(OptLevel, DebugPassManager, nullptr);\n+        break;\n+      case LLVMRustOptStage::FatLTO:\n+        MPM = PB.buildLTODefaultPipeline(OptLevel, DebugPassManager, nullptr);\n+        break;\n+      }\n+    }\n+  }\n+\n+  if (UseThinLTOBuffers) {\n+    MPM.addPass(CanonicalizeAliasesPass());\n+    MPM.addPass(NameAnonGlobalPass());\n+  }\n+\n+  // Upgrade all calls to old intrinsics first.\n+  for (Module::iterator I = TheModule->begin(), E = TheModule->end(); I != E;)\n+    UpgradeCallsToIntrinsic(&*I++); // must be post-increment, as we remove\n+\n+  MPM.run(*TheModule, MAM);\n+#else\n+  // The new pass manager has been available for a long time,\n+  // but we don't bother supporting it on old LLVM versions.\n+  report_fatal_error(\"New pass manager only supported since LLVM 9\");\n+#endif\n+}\n \n // Callback to demangle function name\n // Parameters:"}, {"sha": "8ea41c5d44bb1fe410807d3324a003fc8504d2ca", "filename": "src/test/codegen/sanitizer-memory-track-orgins.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c6b0803202c95abd614c8ea448f7c7ff948da31a/src%2Ftest%2Fcodegen%2Fsanitizer-memory-track-orgins.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6b0803202c95abd614c8ea448f7c7ff948da31a/src%2Ftest%2Fcodegen%2Fsanitizer-memory-track-orgins.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fsanitizer-memory-track-orgins.rs?ref=c6b0803202c95abd614c8ea448f7c7ff948da31a", "patch": "@@ -15,10 +15,10 @@\n #![crate_type=\"lib\"]\n \n // MSAN-0-NOT: @__msan_track_origins\n-// MSAN-1:     @__msan_track_origins = weak_odr local_unnamed_addr constant i32 1\n-// MSAN-2:     @__msan_track_origins = weak_odr local_unnamed_addr constant i32 2\n-// MSAN-1-LTO: @__msan_track_origins = weak_odr local_unnamed_addr constant i32 1\n-// MSAN-2-LTO: @__msan_track_origins = weak_odr local_unnamed_addr constant i32 2\n+// MSAN-1:     @__msan_track_origins = weak_odr {{.*}}constant i32 1\n+// MSAN-2:     @__msan_track_origins = weak_odr {{.*}}constant i32 2\n+// MSAN-1-LTO: @__msan_track_origins = weak_odr {{.*}}constant i32 1\n+// MSAN-2-LTO: @__msan_track_origins = weak_odr {{.*}}constant i32 2\n //\n // MSAN-0-LABEL: define void @copy(\n // MSAN-1-LABEL: define void @copy("}]}