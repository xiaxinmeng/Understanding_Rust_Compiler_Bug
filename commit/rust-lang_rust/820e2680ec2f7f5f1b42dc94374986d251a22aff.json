{"sha": "820e2680ec2f7f5f1b42dc94374986d251a22aff", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgyMGUyNjgwZWMyZjdmNWYxYjQyZGM5NDM3NDk4NmQyNTFhMjJhZmY=", "commit": {"author": {"name": "R\u00e9my Rakic", "email": "remy.rakic+github@gmail.com", "date": "2021-08-23T21:31:01Z"}, "committer": {"name": "R\u00e9my Rakic", "email": "remy.rakic+github@gmail.com", "date": "2021-08-23T21:31:01Z"}, "message": "handle ascription type op in NLL HRTB diagnostics\n\nRefactors the `type_op_ascribe_user_type` query into a version which\naccepts a span, and uses it in the nicer NLL HRTB bound region errors.", "tree": {"sha": "e3b69803434a77b8bb07c066ff94bf8b8bfae223", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e3b69803434a77b8bb07c066ff94bf8b8bfae223"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/820e2680ec2f7f5f1b42dc94374986d251a22aff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/820e2680ec2f7f5f1b42dc94374986d251a22aff", "html_url": "https://github.com/rust-lang/rust/commit/820e2680ec2f7f5f1b42dc94374986d251a22aff", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/820e2680ec2f7f5f1b42dc94374986d251a22aff/comments", "author": {"login": "lqd", "id": 247183, "node_id": "MDQ6VXNlcjI0NzE4Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/247183?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lqd", "html_url": "https://github.com/lqd", "followers_url": "https://api.github.com/users/lqd/followers", "following_url": "https://api.github.com/users/lqd/following{/other_user}", "gists_url": "https://api.github.com/users/lqd/gists{/gist_id}", "starred_url": "https://api.github.com/users/lqd/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lqd/subscriptions", "organizations_url": "https://api.github.com/users/lqd/orgs", "repos_url": "https://api.github.com/users/lqd/repos", "events_url": "https://api.github.com/users/lqd/events{/privacy}", "received_events_url": "https://api.github.com/users/lqd/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lqd", "id": 247183, "node_id": "MDQ6VXNlcjI0NzE4Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/247183?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lqd", "html_url": "https://github.com/lqd", "followers_url": "https://api.github.com/users/lqd/followers", "following_url": "https://api.github.com/users/lqd/following{/other_user}", "gists_url": "https://api.github.com/users/lqd/gists{/gist_id}", "starred_url": "https://api.github.com/users/lqd/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lqd/subscriptions", "organizations_url": "https://api.github.com/users/lqd/orgs", "repos_url": "https://api.github.com/users/lqd/repos", "events_url": "https://api.github.com/users/lqd/events{/privacy}", "received_events_url": "https://api.github.com/users/lqd/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "52c881ff5240bf0f09557a3c100f40704b5db836", "url": "https://api.github.com/repos/rust-lang/rust/commits/52c881ff5240bf0f09557a3c100f40704b5db836", "html_url": "https://github.com/rust-lang/rust/commit/52c881ff5240bf0f09557a3c100f40704b5db836"}], "stats": {"total": 92, "additions": 72, "deletions": 20}, "files": [{"sha": "ac30093ba826015fba0f9859172857b2f2d3861b", "filename": "compiler/rustc_mir/src/borrow_check/diagnostics/bound_region_errors.rs", "status": "modified", "additions": 37, "deletions": 5, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/820e2680ec2f7f5f1b42dc94374986d251a22aff/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fbound_region_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/820e2680ec2f7f5f1b42dc94374986d251a22aff/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fbound_region_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fbound_region_errors.rs?ref=820e2680ec2f7f5f1b42dc94374986d251a22aff", "patch": "@@ -9,7 +9,7 @@ use rustc_middle::ty::{self, Ty, TyCtxt, TypeFoldable};\n use rustc_span::Span;\n use rustc_trait_selection::traits::query::type_op;\n use rustc_trait_selection::traits::{SelectionContext, TraitEngineExt as _};\n-use rustc_traits::type_op_prove_predicate_with_span;\n+use rustc_traits::{type_op_ascribe_user_type_with_span, type_op_prove_predicate_with_span};\n \n use std::fmt;\n use std::rc::Rc;\n@@ -104,10 +104,11 @@ impl<'tcx, T: Copy + fmt::Display + TypeFoldable<'tcx> + 'tcx> ToUniverseInfo<'t\n impl<'tcx> ToUniverseInfo<'tcx>\n     for Canonical<'tcx, ty::ParamEnvAnd<'tcx, type_op::AscribeUserType<'tcx>>>\n {\n-    fn to_universe_info(self, _base_universe: ty::UniverseIndex) -> UniverseInfo<'tcx> {\n-        // Ascribe user type isn't usually called on types that have different\n-        // bound regions.\n-        UniverseInfo::other()\n+    fn to_universe_info(self, base_universe: ty::UniverseIndex) -> UniverseInfo<'tcx> {\n+        UniverseInfo(UniverseInfoInner::TypeOp(Rc::new(AscribeUserTypeQuery {\n+            canonical_query: self,\n+            base_universe,\n+        })))\n     }\n }\n \n@@ -267,6 +268,37 @@ where\n     }\n }\n \n+struct AscribeUserTypeQuery<'tcx> {\n+    canonical_query: Canonical<'tcx, ty::ParamEnvAnd<'tcx, type_op::AscribeUserType<'tcx>>>,\n+    base_universe: ty::UniverseIndex,\n+}\n+\n+impl TypeOpInfo<'tcx> for AscribeUserTypeQuery<'tcx> {\n+    fn fallback_error(&self, tcx: TyCtxt<'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n+        // FIXME: This error message isn't great, but it doesn't show up in the existing UI tests,\n+        // and is only the fallback when the nice error fails. Consider improving this some more.\n+        tcx.sess.struct_span_err(span, \"higher-ranked lifetime error\")\n+    }\n+\n+    fn base_universe(&self) -> ty::UniverseIndex {\n+        self.base_universe\n+    }\n+\n+    fn nice_error(\n+        &self,\n+        tcx: TyCtxt<'tcx>,\n+        span: Span,\n+        placeholder_region: ty::Region<'tcx>,\n+        error_region: Option<ty::Region<'tcx>>,\n+    ) -> Option<DiagnosticBuilder<'tcx>> {\n+        tcx.infer_ctxt().enter_with_canonical(span, &self.canonical_query, |ref infcx, key, _| {\n+            let mut fulfill_cx = <dyn TraitEngine<'_>>::new(tcx);\n+            type_op_ascribe_user_type_with_span(infcx, &mut *fulfill_cx, key, Some(span)).ok()?;\n+            try_extract_error_from_fulfill_cx(fulfill_cx, infcx, placeholder_region, error_region)\n+        })\n+    }\n+}\n+\n fn try_extract_error_from_fulfill_cx<'tcx>(\n     mut fulfill_cx: Box<dyn TraitEngine<'tcx> + 'tcx>,\n     infcx: &InferCtxt<'_, 'tcx>,"}, {"sha": "48c46c3069328e584d86ecca8ad052c54c62526f", "filename": "compiler/rustc_traits/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/820e2680ec2f7f5f1b42dc94374986d251a22aff/compiler%2Frustc_traits%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/820e2680ec2f7f5f1b42dc94374986d251a22aff/compiler%2Frustc_traits%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Flib.rs?ref=820e2680ec2f7f5f1b42dc94374986d251a22aff", "patch": "@@ -19,7 +19,7 @@ mod normalize_erasing_regions;\n mod normalize_projection_ty;\n mod type_op;\n \n-pub use type_op::type_op_prove_predicate_with_span;\n+pub use type_op::{type_op_ascribe_user_type_with_span, type_op_prove_predicate_with_span};\n \n use rustc_middle::ty::query::Providers;\n "}, {"sha": "a76fb842616152af6da34f435c8a1b6a4dd69073", "filename": "compiler/rustc_traits/src/type_op.rs", "status": "modified", "additions": 34, "deletions": 14, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/820e2680ec2f7f5f1b42dc94374986d251a22aff/compiler%2Frustc_traits%2Fsrc%2Ftype_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/820e2680ec2f7f5f1b42dc94374986d251a22aff/compiler%2Frustc_traits%2Fsrc%2Ftype_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Ftype_op.rs?ref=820e2680ec2f7f5f1b42dc94374986d251a22aff", "patch": "@@ -40,18 +40,28 @@ fn type_op_ascribe_user_type<'tcx>(\n     canonicalized: Canonical<'tcx, ParamEnvAnd<'tcx, AscribeUserType<'tcx>>>,\n ) -> Result<&'tcx Canonical<'tcx, QueryResponse<'tcx, ()>>, NoSolution> {\n     tcx.infer_ctxt().enter_canonical_trait_query(&canonicalized, |infcx, fulfill_cx, key| {\n-        let (param_env, AscribeUserType { mir_ty, def_id, user_substs }) = key.into_parts();\n-\n-        debug!(\n-            \"type_op_ascribe_user_type: mir_ty={:?} def_id={:?} user_substs={:?}\",\n-            mir_ty, def_id, user_substs\n-        );\n+        type_op_ascribe_user_type_with_span(infcx, fulfill_cx, key, None)\n+    })\n+}\n \n-        let mut cx = AscribeUserTypeCx { infcx, param_env, fulfill_cx };\n-        cx.relate_mir_and_user_ty(mir_ty, def_id, user_substs)?;\n+/// The core of the `type_op_ascribe_user_type` query: for diagnostics purposes in NLL HRTB errors,\n+/// this query can be re-run to better track the span of the obligation cause, and improve the error\n+/// message. Do not call directly unless you're in that very specific context.\n+pub fn type_op_ascribe_user_type_with_span<'a, 'tcx: 'a>(\n+    infcx: &'a InferCtxt<'a, 'tcx>,\n+    fulfill_cx: &'a mut dyn TraitEngine<'tcx>,\n+    key: ParamEnvAnd<'tcx, AscribeUserType<'tcx>>,\n+    span: Option<Span>,\n+) -> Result<(), NoSolution> {\n+    let (param_env, AscribeUserType { mir_ty, def_id, user_substs }) = key.into_parts();\n+    debug!(\n+        \"type_op_ascribe_user_type: mir_ty={:?} def_id={:?} user_substs={:?}\",\n+        mir_ty, def_id, user_substs\n+    );\n \n-        Ok(())\n-    })\n+    let mut cx = AscribeUserTypeCx { infcx, param_env, fulfill_cx };\n+    cx.relate_mir_and_user_ty(mir_ty, def_id, user_substs, span)?;\n+    Ok(())\n }\n \n struct AscribeUserTypeCx<'me, 'tcx> {\n@@ -85,10 +95,15 @@ impl AscribeUserTypeCx<'me, 'tcx> {\n         Ok(())\n     }\n \n-    fn prove_predicate(&mut self, predicate: Predicate<'tcx>) {\n+    fn prove_predicate(&mut self, predicate: Predicate<'tcx>, span: Option<Span>) {\n+        let cause = if let Some(span) = span {\n+            ObligationCause::dummy_with_span(span)\n+        } else {\n+            ObligationCause::dummy()\n+        };\n         self.fulfill_cx.register_predicate_obligation(\n             self.infcx,\n-            Obligation::new(ObligationCause::dummy(), self.param_env, predicate),\n+            Obligation::new(cause, self.param_env, predicate),\n         );\n     }\n \n@@ -108,6 +123,7 @@ impl AscribeUserTypeCx<'me, 'tcx> {\n         mir_ty: Ty<'tcx>,\n         def_id: DefId,\n         user_substs: UserSubsts<'tcx>,\n+        span: Option<Span>,\n     ) -> Result<(), NoSolution> {\n         let UserSubsts { user_self_ty, substs } = user_substs;\n         let tcx = self.tcx();\n@@ -129,7 +145,7 @@ impl AscribeUserTypeCx<'me, 'tcx> {\n         debug!(?instantiated_predicates.predicates);\n         for instantiated_predicate in instantiated_predicates.predicates {\n             let instantiated_predicate = self.normalize(instantiated_predicate);\n-            self.prove_predicate(instantiated_predicate);\n+            self.prove_predicate(instantiated_predicate, span);\n         }\n \n         if let Some(UserSelfTy { impl_def_id, self_ty }) = user_self_ty {\n@@ -141,6 +157,7 @@ impl AscribeUserTypeCx<'me, 'tcx> {\n \n             self.prove_predicate(\n                 ty::PredicateKind::WellFormed(impl_self_ty.into()).to_predicate(self.tcx()),\n+                span,\n             );\n         }\n \n@@ -155,7 +172,10 @@ impl AscribeUserTypeCx<'me, 'tcx> {\n         // them?  This would only be relevant if some input\n         // type were ill-formed but did not appear in `ty`,\n         // which...could happen with normalization...\n-        self.prove_predicate(ty::PredicateKind::WellFormed(ty.into()).to_predicate(self.tcx()));\n+        self.prove_predicate(\n+            ty::PredicateKind::WellFormed(ty.into()).to_predicate(self.tcx()),\n+            span,\n+        );\n         Ok(())\n     }\n }"}]}