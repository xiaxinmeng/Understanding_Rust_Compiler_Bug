{"sha": "3d9923d0d5b1c3e9ad9756751cb54ec22492cff1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNkOTkyM2QwZDViMWMzZTlhZDk3NTY3NTFjYjU0ZWMyMjQ5MmNmZjE=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-01-06T02:36:30Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-01-06T02:36:30Z"}, "message": "rollup merge of #20424: jroesch/tuple-struct-where-clause-fix\n\nFixes #17904. All the cases that I believe we should support are detailed in the test case, let me know if there is there is any more desired behavior. cc @japaric.\n\nr? @nikomatsakis or whoever is appropriate.", "tree": {"sha": "07c524bb20a48c89c9389a424064a173d50a31f0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/07c524bb20a48c89c9389a424064a173d50a31f0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3d9923d0d5b1c3e9ad9756751cb54ec22492cff1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3d9923d0d5b1c3e9ad9756751cb54ec22492cff1", "html_url": "https://github.com/rust-lang/rust/commit/3d9923d0d5b1c3e9ad9756751cb54ec22492cff1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3d9923d0d5b1c3e9ad9756751cb54ec22492cff1/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0dd07429ab71e832de1206a5f07a81f2c71f8c13", "url": "https://api.github.com/repos/rust-lang/rust/commits/0dd07429ab71e832de1206a5f07a81f2c71f8c13", "html_url": "https://github.com/rust-lang/rust/commit/0dd07429ab71e832de1206a5f07a81f2c71f8c13"}, {"sha": "c02fac471a9126e971617449a55930b0d69058c0", "url": "https://api.github.com/repos/rust-lang/rust/commits/c02fac471a9126e971617449a55930b0d69058c0", "html_url": "https://github.com/rust-lang/rust/commit/c02fac471a9126e971617449a55930b0d69058c0"}], "stats": {"total": 169, "additions": 127, "deletions": 42}, "files": [{"sha": "8e4a385923ab548182854701078409a4c5c451b6", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 89, "deletions": 40, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/3d9923d0d5b1c3e9ad9756751cb54ec22492cff1/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d9923d0d5b1c3e9ad9756751cb54ec22492cff1/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=3d9923d0d5b1c3e9ad9756751cb54ec22492cff1", "patch": "@@ -4885,67 +4885,116 @@ impl<'a> Parser<'a> {\n             self.span_err(ty.span, \"`virtual` structs have been removed from the language\");\n         }\n \n-        self.parse_where_clause(&mut generics);\n+        // There is a special case worth noting here, as reported in issue #17904.\n+        // If we are parsing a tuple struct it is the case that the where clause\n+        // should follow the field list. Like so:\n+        //\n+        // struct Foo<T>(T) where T: Copy;\n+        //\n+        // If we are parsing a normal record-style struct it is the case\n+        // that the where clause comes before the body, and after the generics.\n+        // So if we look ahead and see a brace or a where-clause we begin\n+        // parsing a record style struct.\n+        //\n+        // Otherwise if we look ahead and see a paren we parse a tuple-style\n+        // struct.\n+\n+        let (fields, ctor_id) = if self.token.is_keyword(keywords::Where) {\n+            self.parse_where_clause(&mut generics);\n+            if self.eat(&token::Semi) {\n+                // If we see a: `struct Foo<T> where T: Copy;` style decl.\n+                (Vec::new(), Some(ast::DUMMY_NODE_ID))\n+            } else {\n+                // If we see: `struct Foo<T> where T: Copy { ... }`\n+                (self.parse_record_struct_body(&class_name), None)\n+            }\n+        // No `where` so: `struct Foo<T>;`\n+        } else if self.eat(&token::Semi) {\n+            (Vec::new(), Some(ast::DUMMY_NODE_ID))\n+        // Record-style struct definition\n+        } else if self.token == token::OpenDelim(token::Brace) {\n+            let fields = self.parse_record_struct_body(&class_name);\n+            (fields, None)\n+        // Tuple-style struct definition with optional where-clause.\n+        } else {\n+            let fields = self.parse_tuple_struct_body(&class_name, &mut generics);\n+            (fields, Some(ast::DUMMY_NODE_ID))\n+        };\n \n-        let mut fields: Vec<StructField>;\n-        let is_tuple_like;\n+        (class_name,\n+         ItemStruct(P(ast::StructDef {\n+             fields: fields,\n+             ctor_id: ctor_id,\n+         }), generics),\n+         None)\n+    }\n \n+    pub fn parse_record_struct_body(&mut self, class_name: &ast::Ident) -> Vec<StructField> {\n+        let mut fields = Vec::new();\n         if self.eat(&token::OpenDelim(token::Brace)) {\n-            // It's a record-like struct.\n-            is_tuple_like = false;\n-            fields = Vec::new();\n             while self.token != token::CloseDelim(token::Brace) {\n                 fields.push(self.parse_struct_decl_field(true));\n             }\n+\n             if fields.len() == 0 {\n                 self.fatal(format!(\"unit-like struct definition should be \\\n-                                    written as `struct {};`\",\n-                                   token::get_ident(class_name))[]);\n+                    written as `struct {};`\",\n+                    token::get_ident(class_name.clone()))[]);\n             }\n+\n             self.bump();\n-        } else if self.check(&token::OpenDelim(token::Paren)) {\n-            // It's a tuple-like struct.\n-            is_tuple_like = true;\n-            fields = self.parse_unspanned_seq(\n+        } else {\n+            let token_str = self.this_token_to_string();\n+            self.fatal(format!(\"expected `where`, or `{}` after struct \\\n+                                name, found `{}`\", \"{\",\n+                                token_str)[]);\n+        }\n+\n+        fields\n+    }\n+\n+    pub fn parse_tuple_struct_body(&mut self,\n+                                   class_name: &ast::Ident,\n+                                   generics: &mut ast::Generics)\n+                                   -> Vec<StructField> {\n+        // This is the case where we find `struct Foo<T>(T) where T: Copy;`\n+        if self.check(&token::OpenDelim(token::Paren)) {\n+            let fields = self.parse_unspanned_seq(\n                 &token::OpenDelim(token::Paren),\n                 &token::CloseDelim(token::Paren),\n                 seq_sep_trailing_allowed(token::Comma),\n                 |p| {\n-                let attrs = p.parse_outer_attributes();\n-                let lo = p.span.lo;\n-                let struct_field_ = ast::StructField_ {\n-                    kind: UnnamedField(p.parse_visibility()),\n-                    id: ast::DUMMY_NODE_ID,\n-                    ty: p.parse_ty_sum(),\n-                    attrs: attrs,\n-                };\n-                spanned(lo, p.span.hi, struct_field_)\n-            });\n+                    let attrs = p.parse_outer_attributes();\n+                    let lo = p.span.lo;\n+                    let struct_field_ = ast::StructField_ {\n+                        kind: UnnamedField(p.parse_visibility()),\n+                        id: ast::DUMMY_NODE_ID,\n+                        ty: p.parse_ty_sum(),\n+                        attrs: attrs,\n+                    };\n+                    spanned(lo, p.span.hi, struct_field_)\n+                });\n+\n             if fields.len() == 0 {\n                 self.fatal(format!(\"unit-like struct definition should be \\\n-                                    written as `struct {};`\",\n-                                   token::get_ident(class_name))[]);\n+                    written as `struct {};`\",\n+                    token::get_ident(class_name.clone()))[]);\n             }\n+\n+            self.parse_where_clause(generics);\n             self.expect(&token::Semi);\n-        } else if self.eat(&token::Semi) {\n-            // It's a unit-like struct.\n-            is_tuple_like = true;\n-            fields = Vec::new();\n+            fields\n+        // This is the case where we just see struct Foo<T> where T: Copy;\n+        } else if self.token.is_keyword(keywords::Where) {\n+            self.parse_where_clause(generics);\n+            self.expect(&token::Semi);\n+            Vec::new()\n+        // This case is where we see: `struct Foo<T>;`\n         } else {\n             let token_str = self.this_token_to_string();\n-            self.fatal(format!(\"expected `{}`, `(`, or `;` after struct \\\n-                                name, found `{}`\", \"{\",\n-                               token_str)[])\n+            self.fatal(format!(\"expected `where`, `{}`, `(`, or `;` after struct \\\n+                name, found `{}`\", \"{\", token_str)[]);\n         }\n-\n-        let _ = ast::DUMMY_NODE_ID;  // FIXME: Workaround for crazy bug.\n-        let new_id = ast::DUMMY_NODE_ID;\n-        (class_name,\n-         ItemStruct(P(ast::StructDef {\n-             fields: fields,\n-             ctor_id: if is_tuple_like { Some(new_id) } else { None },\n-         }), generics),\n-         None)\n     }\n \n     /// Parse a structure field declaration"}, {"sha": "effd6e8218d25fd38cbbd62cee3457697e276239", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3d9923d0d5b1c3e9ad9756751cb54ec22492cff1/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d9923d0d5b1c3e9ad9756751cb54ec22492cff1/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=3d9923d0d5b1c3e9ad9756751cb54ec22492cff1", "patch": "@@ -1056,7 +1056,6 @@ impl<'a> State<'a> {\n                         span: codemap::Span) -> IoResult<()> {\n         try!(self.print_ident(ident));\n         try!(self.print_generics(generics));\n-        try!(self.print_where_clause(generics));\n         if ast_util::struct_def_is_tuple_like(struct_def) {\n             if !struct_def.fields.is_empty() {\n                 try!(self.popen());\n@@ -1075,10 +1074,12 @@ impl<'a> State<'a> {\n                 ));\n                 try!(self.pclose());\n             }\n+            try!(self.print_where_clause(generics));\n             try!(word(&mut self.s, \";\"));\n             try!(self.end());\n             self.end() // close the outer-box\n         } else {\n+            try!(self.print_where_clause(generics));\n             try!(self.nbsp());\n             try!(self.bopen());\n             try!(self.hardbreak_if_not_bol());"}, {"sha": "96ba712bbae8b7eacdb00d73f961a995b411606a", "filename": "src/test/compile-fail/issue-17904.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/3d9923d0d5b1c3e9ad9756751cb54ec22492cff1/src%2Ftest%2Fcompile-fail%2Fissue-17904.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d9923d0d5b1c3e9ad9756751cb54ec22492cff1/src%2Ftest%2Fcompile-fail%2Fissue-17904.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17904.rs?ref=3d9923d0d5b1c3e9ad9756751cb54ec22492cff1", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct Baz<U> where U: Eq(U); //This is parsed as the new Fn* style parenthesis syntax.\n+struct Baz<U> where U: Eq(U) -> R; // Notice this parses as well.\n+struct Baz<U>(U) where U: Eq; // This rightfully signals no error as well.\n+struct Foo<T> where T: Copy, (T); //~ ERROR unexpected token in `where` clause\n+struct Bar<T> { x: T } where T: Copy //~ ERROR expected item, found `where`\n+\n+fn main() {}"}, {"sha": "92dbea0424b6f6627bcd1faccf790bd64faae656", "filename": "src/test/compile-fail/unsized.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d9923d0d5b1c3e9ad9756751cb54ec22492cff1/src%2Ftest%2Fcompile-fail%2Funsized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d9923d0d5b1c3e9ad9756751cb54ec22492cff1/src%2Ftest%2Fcompile-fail%2Funsized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsized.rs?ref=3d9923d0d5b1c3e9ad9756751cb54ec22492cff1", "patch": "@@ -10,7 +10,7 @@\n \n // Test syntax checks for `type` keyword.\n \n-struct S1 for type; //~ ERROR expected `{`, `(`, or `;` after struct name, found `for`\n+struct S1 for type; //~ ERROR expected `where`, `{`, `(`, or `;` after struct name, found `for`\n \n pub fn main() {\n }"}, {"sha": "3ce347d67e3d91f173ffbe55c69a5403dbac12f5", "filename": "src/test/run-pass/issue-17904.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3d9923d0d5b1c3e9ad9756751cb54ec22492cff1/src%2Ftest%2Frun-pass%2Fissue-17904.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d9923d0d5b1c3e9ad9756751cb54ec22492cff1/src%2Ftest%2Frun-pass%2Fissue-17904.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-17904.rs?ref=3d9923d0d5b1c3e9ad9756751cb54ec22492cff1", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct Foo<T> where T: Copy;\n+struct Bar<T>(T) where T: Copy;\n+struct Bleh<T, U>(T, U) where T: Copy, U: Sized;\n+struct Baz<T> where T: Copy {\n+    field: T\n+}\n+\n+fn main() {}"}]}