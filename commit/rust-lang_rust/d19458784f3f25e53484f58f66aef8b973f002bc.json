{"sha": "d19458784f3f25e53484f58f66aef8b973f002bc", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQxOTQ1ODc4NGYzZjI1ZTUzNDg0ZjU4ZjY2YWVmOGI5NzNmMDAyYmM=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2020-04-17T01:05:13Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-04-17T01:05:13Z"}, "message": "Rollup merge of #70910 - rakshith-ravi:master, r=cuviper\n\nHides default fns inside Fuse impl to avoid exposing it to any crate\n\nFixes #70796\n\n@cuviper I've added some default, private traits to do the job for us. If required, I can expose them to a specific visibility if you want to call these functions for #70332\n\nr? @cuviper", "tree": {"sha": "cadc8be922554d6ba256c05534c979eb74006f43", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cadc8be922554d6ba256c05534c979eb74006f43"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d19458784f3f25e53484f58f66aef8b973f002bc", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJemQDJCRBK7hj4Ov3rIwAAdHIIAAKAWwR0YmBdkjwpZnc+Pick\nUiEpPZMQ3q6Luszsz2SBn55WjacvcINCgEHRpmKmxNb4Lur1ZAhUziMzfGZST+wT\nrEp2AiLLPcIeDxq/XoPuHZZ5JhjsH3GCMCr8C6WOOXvZjROhNFk9ZDx+K57jVqN+\nJXLBmjm37fDxh9KGRQ6gETlt+vuEIJiMFyb+IOP3reNeFMoz9Zr/QBHpwRWEO++m\nPHNfv0sWSSXw+vWIl+cwYSASIckAe5/MPFbqPhOqMasQUwOvK9pPG0Ug6Deq1rQ2\n1bwiK5DH2ZxziyIQJDgKeuREwBzp1UGia3NIxZhtoeWhR0PwFVCYrAutLFD00Cs=\n=ooMe\n-----END PGP SIGNATURE-----\n", "payload": "tree cadc8be922554d6ba256c05534c979eb74006f43\nparent abd72f7fc2ced909ef21b9eb8029a392c4211c66\nparent abe5973b9d1202f1a6460c0116f22fc33c9506c5\nauthor Dylan DPC <dylan.dpc@gmail.com> 1587085513 +0200\ncommitter GitHub <noreply@github.com> 1587085513 +0200\n\nRollup merge of #70910 - rakshith-ravi:master, r=cuviper\n\nHides default fns inside Fuse impl to avoid exposing it to any crate\n\nFixes #70796\n\n@cuviper I've added some default, private traits to do the job for us. If required, I can expose them to a specific visibility if you want to call these functions for #70332\n\nr? @cuviper\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d19458784f3f25e53484f58f66aef8b973f002bc", "html_url": "https://github.com/rust-lang/rust/commit/d19458784f3f25e53484f58f66aef8b973f002bc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d19458784f3f25e53484f58f66aef8b973f002bc/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "abd72f7fc2ced909ef21b9eb8029a392c4211c66", "url": "https://api.github.com/repos/rust-lang/rust/commits/abd72f7fc2ced909ef21b9eb8029a392c4211c66", "html_url": "https://github.com/rust-lang/rust/commit/abd72f7fc2ced909ef21b9eb8029a392c4211c66"}, {"sha": "abe5973b9d1202f1a6460c0116f22fc33c9506c5", "url": "https://api.github.com/repos/rust-lang/rust/commits/abe5973b9d1202f1a6460c0116f22fc33c9506c5", "html_url": "https://github.com/rust-lang/rust/commit/abe5973b9d1202f1a6460c0116f22fc33c9506c5"}], "stats": {"total": 307, "additions": 244, "deletions": 63}, "files": [{"sha": "502fc2e631502a2c5637a482c746a6ab95b58b05", "filename": "src/libcore/iter/adapters/fuse.rs", "status": "modified", "additions": 244, "deletions": 63, "changes": 307, "blob_url": "https://github.com/rust-lang/rust/blob/d19458784f3f25e53484f58f66aef8b973f002bc/src%2Flibcore%2Fiter%2Fadapters%2Ffuse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d19458784f3f25e53484f58f66aef8b973f002bc/src%2Flibcore%2Fiter%2Fadapters%2Ffuse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fadapters%2Ffuse.rs?ref=d19458784f3f25e53484f58f66aef8b973f002bc", "patch": "@@ -44,13 +44,213 @@ macro_rules! fuse {\n     };\n }\n \n+// NOTE: for `I: FusedIterator`, we assume that the iterator is always `Some`.\n+// Implementing this as a directly-expanded macro helps codegen performance.\n+macro_rules! unchecked {\n+    ($self:ident) => {\n+        match $self {\n+            Fuse { iter: Some(iter) } => iter,\n+            // SAFETY: the specialized iterator never sets `None`\n+            Fuse { iter: None } => unsafe { intrinsics::unreachable() },\n+        }\n+    };\n+}\n+\n+// Any implementation here is made internal to avoid exposing default fns outside this trait\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<I> Iterator for Fuse<I>\n where\n     I: Iterator,\n {\n     type Item = <I as Iterator>::Item;\n \n+    #[inline]\n+    fn next(&mut self) -> Option<Self::Item> {\n+        FuseImpl::next(self)\n+    }\n+\n+    #[inline]\n+    fn nth(&mut self, n: usize) -> Option<I::Item> {\n+        FuseImpl::nth(self, n)\n+    }\n+\n+    #[inline]\n+    fn last(self) -> Option<Self::Item> {\n+        FuseImpl::last(self)\n+    }\n+\n+    #[inline]\n+    fn count(self) -> usize {\n+        FuseImpl::count(self)\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        FuseImpl::size_hint(self)\n+    }\n+\n+    #[inline]\n+    fn try_fold<Acc, Fold, R>(&mut self, acc: Acc, fold: Fold) -> R\n+    where\n+        Self: Sized,\n+        Fold: FnMut(Acc, Self::Item) -> R,\n+        R: Try<Ok = Acc>,\n+    {\n+        FuseImpl::try_fold(self, acc, fold)\n+    }\n+\n+    #[inline]\n+    fn fold<Acc, Fold>(self, acc: Acc, fold: Fold) -> Acc\n+    where\n+        Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        FuseImpl::fold(self, acc, fold)\n+    }\n+\n+    #[inline]\n+    fn find<P>(&mut self, predicate: P) -> Option<Self::Item>\n+    where\n+        P: FnMut(&Self::Item) -> bool,\n+    {\n+        FuseImpl::find(self, predicate)\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I> DoubleEndedIterator for Fuse<I>\n+where\n+    I: DoubleEndedIterator,\n+{\n+    #[inline]\n+    fn next_back(&mut self) -> Option<<I as Iterator>::Item> {\n+        FuseImpl::next_back(self)\n+    }\n+\n+    #[inline]\n+    fn nth_back(&mut self, n: usize) -> Option<<I as Iterator>::Item> {\n+        FuseImpl::nth_back(self, n)\n+    }\n+\n+    #[inline]\n+    fn try_rfold<Acc, Fold, R>(&mut self, acc: Acc, fold: Fold) -> R\n+    where\n+        Self: Sized,\n+        Fold: FnMut(Acc, Self::Item) -> R,\n+        R: Try<Ok = Acc>,\n+    {\n+        FuseImpl::try_rfold(self, acc, fold)\n+    }\n+\n+    #[inline]\n+    fn rfold<Acc, Fold>(self, acc: Acc, fold: Fold) -> Acc\n+    where\n+        Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        FuseImpl::rfold(self, acc, fold)\n+    }\n+\n+    #[inline]\n+    fn rfind<P>(&mut self, predicate: P) -> Option<Self::Item>\n+    where\n+        P: FnMut(&Self::Item) -> bool,\n+    {\n+        FuseImpl::rfind(self, predicate)\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I> ExactSizeIterator for Fuse<I>\n+where\n+    I: ExactSizeIterator,\n+{\n+    fn len(&self) -> usize {\n+        FuseImpl::len(self)\n+    }\n+\n+    fn is_empty(&self) -> bool {\n+        FuseImpl::is_empty(self)\n+    }\n+}\n+\n+unsafe impl<I> TrustedRandomAccess for Fuse<I>\n+where\n+    I: TrustedRandomAccess,\n+{\n+    unsafe fn get_unchecked(&mut self, i: usize) -> I::Item {\n+        match self.iter {\n+            Some(ref mut iter) => iter.get_unchecked(i),\n+            // SAFETY: the caller asserts there is an item at `i`, so we're not exhausted.\n+            None => intrinsics::unreachable(),\n+        }\n+    }\n+\n+    fn may_have_side_effect() -> bool {\n+        I::may_have_side_effect()\n+    }\n+}\n+\n+// Fuse specialization trait\n+#[doc(hidden)]\n+trait FuseImpl<I> {\n+    type Item;\n+\n+    // Functions specific to any normal Iterators\n+    fn next(&mut self) -> Option<Self::Item>;\n+    fn nth(&mut self, n: usize) -> Option<Self::Item>;\n+    fn last(self) -> Option<Self::Item>;\n+    fn count(self) -> usize;\n+    fn size_hint(&self) -> (usize, Option<usize>);\n+    fn try_fold<Acc, Fold, R>(&mut self, acc: Acc, fold: Fold) -> R\n+    where\n+        Self: Sized,\n+        Fold: FnMut(Acc, Self::Item) -> R,\n+        R: Try<Ok = Acc>;\n+    fn fold<Acc, Fold>(self, acc: Acc, fold: Fold) -> Acc\n+    where\n+        Fold: FnMut(Acc, Self::Item) -> Acc;\n+    fn find<P>(&mut self, predicate: P) -> Option<Self::Item>\n+    where\n+        P: FnMut(&Self::Item) -> bool;\n+\n+    // Functions specific to DoubleEndedIterators\n+    fn next_back(&mut self) -> Option<Self::Item>\n+    where\n+        I: DoubleEndedIterator;\n+    fn nth_back(&mut self, n: usize) -> Option<Self::Item>\n+    where\n+        I: DoubleEndedIterator;\n+    fn try_rfold<Acc, Fold, R>(&mut self, acc: Acc, fold: Fold) -> R\n+    where\n+        Self: Sized,\n+        Fold: FnMut(Acc, Self::Item) -> R,\n+        R: Try<Ok = Acc>,\n+        I: DoubleEndedIterator;\n+    fn rfold<Acc, Fold>(self, acc: Acc, fold: Fold) -> Acc\n+    where\n+        Fold: FnMut(Acc, Self::Item) -> Acc,\n+        I: DoubleEndedIterator;\n+    fn rfind<P>(&mut self, predicate: P) -> Option<Self::Item>\n+    where\n+        P: FnMut(&Self::Item) -> bool,\n+        I: DoubleEndedIterator;\n+\n+    // Functions specific to ExactSizeIterator\n+    fn len(&self) -> usize\n+    where\n+        I: ExactSizeIterator;\n+    fn is_empty(&self) -> bool\n+    where\n+        I: ExactSizeIterator;\n+}\n+\n+// General Fuse impl\n+#[doc(hidden)]\n+impl<I> FuseImpl<I> for Fuse<I>\n+where\n+    I: Iterator,\n+{\n+    type Item = <I as Iterator>::Item;\n+\n     #[inline]\n     default fn next(&mut self) -> Option<<I as Iterator>::Item> {\n         fuse!(self.iter.next())\n@@ -117,20 +317,20 @@ where\n     {\n         fuse!(self.iter.find(predicate))\n     }\n-}\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<I> DoubleEndedIterator for Fuse<I>\n-where\n-    I: DoubleEndedIterator,\n-{\n     #[inline]\n-    default fn next_back(&mut self) -> Option<<I as Iterator>::Item> {\n+    default fn next_back(&mut self) -> Option<<I as Iterator>::Item>\n+    where\n+        I: DoubleEndedIterator,\n+    {\n         fuse!(self.iter.next_back())\n     }\n \n     #[inline]\n-    default fn nth_back(&mut self, n: usize) -> Option<<I as Iterator>::Item> {\n+    default fn nth_back(&mut self, n: usize) -> Option<<I as Iterator>::Item>\n+    where\n+        I: DoubleEndedIterator,\n+    {\n         fuse!(self.iter.nth_back(n))\n     }\n \n@@ -140,6 +340,7 @@ where\n         Self: Sized,\n         Fold: FnMut(Acc, Self::Item) -> R,\n         R: Try<Ok = Acc>,\n+        I: DoubleEndedIterator,\n     {\n         if let Some(ref mut iter) = self.iter {\n             acc = iter.try_rfold(acc, fold)?;\n@@ -152,6 +353,7 @@ where\n     default fn rfold<Acc, Fold>(self, mut acc: Acc, fold: Fold) -> Acc\n     where\n         Fold: FnMut(Acc, Self::Item) -> Acc,\n+        I: DoubleEndedIterator,\n     {\n         if let Some(iter) = self.iter {\n             acc = iter.rfold(acc, fold);\n@@ -163,45 +365,36 @@ where\n     default fn rfind<P>(&mut self, predicate: P) -> Option<Self::Item>\n     where\n         P: FnMut(&Self::Item) -> bool,\n+        I: DoubleEndedIterator,\n     {\n         fuse!(self.iter.rfind(predicate))\n     }\n-}\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<I> ExactSizeIterator for Fuse<I>\n-where\n-    I: ExactSizeIterator,\n-{\n-    default fn len(&self) -> usize {\n+    #[inline]\n+    default fn len(&self) -> usize\n+    where\n+        I: ExactSizeIterator,\n+    {\n         match self.iter {\n             Some(ref iter) => iter.len(),\n             None => 0,\n         }\n     }\n \n-    default fn is_empty(&self) -> bool {\n+    #[inline]\n+    default fn is_empty(&self) -> bool\n+    where\n+        I: ExactSizeIterator,\n+    {\n         match self.iter {\n             Some(ref iter) => iter.is_empty(),\n             None => true,\n         }\n     }\n }\n \n-// NOTE: for `I: FusedIterator`, we assume that the iterator is always `Some`.\n-// Implementing this as a directly-expanded macro helps codegen performance.\n-macro_rules! unchecked {\n-    ($self:ident) => {\n-        match $self {\n-            Fuse { iter: Some(iter) } => iter,\n-            // SAFETY: the specialized iterator never sets `None`\n-            Fuse { iter: None } => unsafe { intrinsics::unreachable() },\n-        }\n-    };\n-}\n-\n-#[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl<I> Iterator for Fuse<I>\n+#[doc(hidden)]\n+impl<I> FuseImpl<I> for Fuse<I>\n where\n     I: FusedIterator,\n {\n@@ -255,20 +448,20 @@ where\n     {\n         unchecked!(self).find(predicate)\n     }\n-}\n \n-#[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl<I> DoubleEndedIterator for Fuse<I>\n-where\n-    I: DoubleEndedIterator + FusedIterator,\n-{\n     #[inline]\n-    fn next_back(&mut self) -> Option<<I as Iterator>::Item> {\n+    fn next_back(&mut self) -> Option<<I as Iterator>::Item>\n+    where\n+        I: DoubleEndedIterator,\n+    {\n         unchecked!(self).next_back()\n     }\n \n     #[inline]\n-    fn nth_back(&mut self, n: usize) -> Option<<I as Iterator>::Item> {\n+    fn nth_back(&mut self, n: usize) -> Option<<I as Iterator>::Item>\n+    where\n+        I: DoubleEndedIterator,\n+    {\n         unchecked!(self).nth_back(n)\n     }\n \n@@ -278,6 +471,7 @@ where\n         Self: Sized,\n         Fold: FnMut(Acc, Self::Item) -> R,\n         R: Try<Ok = Acc>,\n+        I: DoubleEndedIterator,\n     {\n         unchecked!(self).try_rfold(init, fold)\n     }\n@@ -286,6 +480,7 @@ where\n     fn rfold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n     where\n         Fold: FnMut(Acc, Self::Item) -> Acc,\n+        I: DoubleEndedIterator,\n     {\n         unchecked!(self).rfold(init, fold)\n     }\n@@ -294,38 +489,24 @@ where\n     fn rfind<P>(&mut self, predicate: P) -> Option<Self::Item>\n     where\n         P: FnMut(&Self::Item) -> bool,\n+        I: DoubleEndedIterator,\n     {\n         unchecked!(self).rfind(predicate)\n     }\n-}\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<I> ExactSizeIterator for Fuse<I>\n-where\n-    I: ExactSizeIterator + FusedIterator,\n-{\n-    fn len(&self) -> usize {\n+    #[inline]\n+    fn len(&self) -> usize\n+    where\n+        I: ExactSizeIterator,\n+    {\n         unchecked!(self).len()\n     }\n \n-    fn is_empty(&self) -> bool {\n+    #[inline]\n+    fn is_empty(&self) -> bool\n+    where\n+        I: ExactSizeIterator,\n+    {\n         unchecked!(self).is_empty()\n     }\n }\n-\n-unsafe impl<I> TrustedRandomAccess for Fuse<I>\n-where\n-    I: TrustedRandomAccess,\n-{\n-    unsafe fn get_unchecked(&mut self, i: usize) -> I::Item {\n-        match self.iter {\n-            Some(ref mut iter) => iter.get_unchecked(i),\n-            // SAFETY: the caller asserts there is an item at `i`, so we're not exhausted.\n-            None => intrinsics::unreachable(),\n-        }\n-    }\n-\n-    fn may_have_side_effect() -> bool {\n-        I::may_have_side_effect()\n-    }\n-}"}]}