{"sha": "e3acb341b2ff743e186c032326d24bfa8827bedc", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUzYWNiMzQxYjJmZjc0M2UxODZjMDMyMzI2ZDI0YmZhODgyN2JlZGM=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2018-06-26T22:59:07Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2018-07-14T11:57:14Z"}, "message": "Remove some tests using AST comparisons, fix other tests", "tree": {"sha": "c7080793f49bb9c75752cee93830a5b49bf9d0e8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c7080793f49bb9c75752cee93830a5b49bf9d0e8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e3acb341b2ff743e186c032326d24bfa8827bedc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e3acb341b2ff743e186c032326d24bfa8827bedc", "html_url": "https://github.com/rust-lang/rust/commit/e3acb341b2ff743e186c032326d24bfa8827bedc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e3acb341b2ff743e186c032326d24bfa8827bedc/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5987fe8f75c443d4f73603fa5a3af8ab41ee1b01", "url": "https://api.github.com/repos/rust-lang/rust/commits/5987fe8f75c443d4f73603fa5a3af8ab41ee1b01", "html_url": "https://github.com/rust-lang/rust/commit/5987fe8f75c443d4f73603fa5a3af8ab41ee1b01"}], "stats": {"total": 311, "additions": 34, "deletions": 277}, "files": [{"sha": "bf790e6143a9ccd5dab30d4cc0648714eba3cc8b", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e3acb341b2ff743e186c032326d24bfa8827bedc/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3acb341b2ff743e186c032326d24bfa8827bedc/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=e3acb341b2ff743e186c032326d24bfa8827bedc", "patch": "@@ -1842,7 +1842,8 @@ mod tests {\n                 tok: token::Ident(id, false),\n                 sp: Span::new(BytePos(21), BytePos(23), NO_EXPANSION),\n             };\n-            assert_eq!(tok1, tok2);\n+            assert_eq!(tok1.tok, tok2.tok);\n+            assert_eq!(tok1.sp, tok2.sp);\n             assert_eq!(string_reader.next_token().tok, token::Whitespace);\n             // the 'main' id is already read:\n             assert_eq!(string_reader.pos.clone(), BytePos(28));\n@@ -1852,7 +1853,8 @@ mod tests {\n                 tok: mk_ident(\"main\"),\n                 sp: Span::new(BytePos(24), BytePos(28), NO_EXPANSION),\n             };\n-            assert_eq!(tok3, tok4);\n+            assert_eq!(tok3.tok, tok4.tok);\n+            assert_eq!(tok3.sp, tok4.sp);\n             // the lparen is already read:\n             assert_eq!(string_reader.pos.clone(), BytePos(29))\n         })"}, {"sha": "1754e5f1b9ad8613fcd37e85ed1af4228c4a7f7e", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 26, "deletions": 204, "changes": 230, "blob_url": "https://github.com/rust-lang/rust/blob/e3acb341b2ff743e186c032326d24bfa8827bedc/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3acb341b2ff743e186c032326d24bfa8827bedc/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=e3acb341b2ff743e186c032326d24bfa8827bedc", "patch": "@@ -673,65 +673,47 @@ fn integer_lit(s: &str, suffix: Option<Symbol>, diag: Option<(Span, &Handler)>)\n     })\n }\n \n+/// `SeqSep` : a sequence separator (token)\n+/// and whether a trailing separator is allowed.\n+pub struct SeqSep {\n+    pub sep: Option<token::Token>,\n+    pub trailing_sep_allowed: bool,\n+}\n+\n+impl SeqSep {\n+    pub fn trailing_allowed(t: token::Token) -> SeqSep {\n+        SeqSep {\n+            sep: Some(t),\n+            trailing_sep_allowed: true,\n+        }\n+    }\n+\n+    pub fn none() -> SeqSep {\n+        SeqSep {\n+            sep: None,\n+            trailing_sep_allowed: false,\n+        }\n+    }\n+}\n+\n #[cfg(test)]\n mod tests {\n     use super::*;\n-    use syntax_pos::{self, Span, BytePos, Pos, NO_EXPANSION};\n-    use codemap::{respan, Spanned};\n+    use syntax_pos::{Span, BytePos, Pos, NO_EXPANSION};\n     use ast::{self, Ident, PatKind};\n-    use rustc_target::spec::abi::Abi;\n     use attr::first_attr_value_str_by_name;\n     use parse;\n-    use parse::parser::Parser;\n     use print::pprust::item_to_string;\n-    use ptr::P;\n     use tokenstream::{self, TokenTree};\n-    use util::parser_testing::{string_to_stream, string_to_parser};\n-    use util::parser_testing::{string_to_expr, string_to_item, string_to_stmt};\n-    use util::ThinVec;\n+    use util::parser_testing::string_to_stream;\n+    use util::parser_testing::{string_to_expr, string_to_item};\n     use with_globals;\n \n     // produce a syntax_pos::span\n     fn sp(a: u32, b: u32) -> Span {\n         Span::new(BytePos(a), BytePos(b), NO_EXPANSION)\n     }\n \n-    fn str2seg(s: &str, lo: u32, hi: u32) -> ast::PathSegment {\n-        ast::PathSegment::from_ident(Ident::new(Symbol::intern(s), sp(lo, hi)))\n-    }\n-\n-    #[test] fn path_exprs_1() {\n-        with_globals(|| {\n-            assert!(string_to_expr(\"a\".to_string()) ==\n-                    P(ast::Expr{\n-                        id: ast::DUMMY_NODE_ID,\n-                        node: ast::ExprKind::Path(None, ast::Path {\n-                            span: sp(0, 1),\n-                            segments: vec![str2seg(\"a\", 0, 1)],\n-                        }),\n-                        span: sp(0, 1),\n-                        attrs: ThinVec::new(),\n-                    }))\n-        })\n-    }\n-\n-    #[test] fn path_exprs_2 () {\n-        with_globals(|| {\n-            assert!(string_to_expr(\"::a::b\".to_string()) ==\n-                    P(ast::Expr {\n-                        id: ast::DUMMY_NODE_ID,\n-                        node: ast::ExprKind::Path(None, ast::Path {\n-                            span: sp(0, 6),\n-                            segments: vec![ast::PathSegment::crate_root(sp(0, 0)),\n-                                        str2seg(\"a\", 2, 3),\n-                                        str2seg(\"b\", 5, 6)]\n-                        }),\n-                        span: sp(0, 6),\n-                        attrs: ThinVec::new(),\n-                    }))\n-        })\n-    }\n-\n     #[should_panic]\n     #[test] fn bad_path_expr_1() {\n         with_globals(|| {\n@@ -832,143 +814,6 @@ mod tests {\n         })\n     }\n \n-    #[test] fn ret_expr() {\n-        with_globals(|| {\n-            assert!(string_to_expr(\"return d\".to_string()) ==\n-                    P(ast::Expr{\n-                        id: ast::DUMMY_NODE_ID,\n-                        node:ast::ExprKind::Ret(Some(P(ast::Expr{\n-                            id: ast::DUMMY_NODE_ID,\n-                            node:ast::ExprKind::Path(None, ast::Path{\n-                                span: sp(7, 8),\n-                                segments: vec![str2seg(\"d\", 7, 8)],\n-                            }),\n-                            span:sp(7,8),\n-                            attrs: ThinVec::new(),\n-                        }))),\n-                        span:sp(0,8),\n-                        attrs: ThinVec::new(),\n-                    }))\n-        })\n-    }\n-\n-    #[test] fn parse_stmt_1 () {\n-        with_globals(|| {\n-            assert!(string_to_stmt(\"b;\".to_string()) ==\n-                    Some(ast::Stmt {\n-                        node: ast::StmtKind::Expr(P(ast::Expr {\n-                            id: ast::DUMMY_NODE_ID,\n-                            node: ast::ExprKind::Path(None, ast::Path {\n-                                span:sp(0,1),\n-                                segments: vec![str2seg(\"b\", 0, 1)],\n-                                }),\n-                            span: sp(0,1),\n-                            attrs: ThinVec::new()})),\n-                        id: ast::DUMMY_NODE_ID,\n-                        span: sp(0,1)}))\n-        })\n-    }\n-\n-    fn parser_done(p: Parser){\n-        assert_eq!(p.token.clone(), token::Eof);\n-    }\n-\n-    #[test] fn parse_ident_pat () {\n-        with_globals(|| {\n-            let sess = ParseSess::new(FilePathMapping::empty());\n-            let mut parser = string_to_parser(&sess, \"b\".to_string());\n-            assert!(panictry!(parser.parse_pat())\n-                    == P(ast::Pat{\n-                    id: ast::DUMMY_NODE_ID,\n-                    node: PatKind::Ident(ast::BindingMode::ByValue(ast::Mutability::Immutable),\n-                                         Ident::new(Symbol::intern(\"b\"), sp(0, 1)),\n-                                         None),\n-                    span: sp(0,1)}));\n-            parser_done(parser);\n-        })\n-    }\n-\n-    // check the contents of the tt manually:\n-    #[test] fn parse_fundecl () {\n-        with_globals(|| {\n-            // this test depends on the intern order of \"fn\" and \"i32\"\n-            let item = string_to_item(\"fn a (b : i32) { b; }\".to_string()).map(|m| {\n-                m.map(|mut m| {\n-                    m.tokens = None;\n-                    m\n-                })\n-            });\n-            assert_eq!(item,\n-                    Some(\n-                        P(ast::Item{ident:Ident::from_str(\"a\"),\n-                                attrs:Vec::new(),\n-                                id: ast::DUMMY_NODE_ID,\n-                                tokens: None,\n-                                node: ast::ItemKind::Fn(P(ast::FnDecl {\n-                                    inputs: vec![ast::Arg{\n-                                        ty: P(ast::Ty{id: ast::DUMMY_NODE_ID,\n-                                                    node: ast::TyKind::Path(None, ast::Path{\n-                                            span:sp(10,13),\n-                                            segments: vec![str2seg(\"i32\", 10, 13)],\n-                                            }),\n-                                            span:sp(10,13)\n-                                        }),\n-                                        pat: P(ast::Pat {\n-                                            id: ast::DUMMY_NODE_ID,\n-                                            node: PatKind::Ident(\n-                                                ast::BindingMode::ByValue(\n-                                                    ast::Mutability::Immutable),\n-                                                Ident::new(Symbol::intern(\"b\"), sp(6, 7)),\n-                                                None\n-                                            ),\n-                                            span: sp(6,7)\n-                                        }),\n-                                            id: ast::DUMMY_NODE_ID\n-                                        }],\n-                                    output: ast::FunctionRetTy::Default(sp(15, 15)),\n-                                    variadic: false\n-                                }),\n-                                        ast::FnHeader {\n-                                            unsafety: ast::Unsafety::Normal,\n-                                            asyncness: ast::IsAsync::NotAsync,\n-                                            constness: Spanned {\n-                                                span: sp(0,2),\n-                                                node: ast::Constness::NotConst,\n-                                            },\n-                                            abi: Abi::Rust,\n-                                        },\n-                                        ast::Generics{\n-                                            params: Vec::new(),\n-                                            where_clause: ast::WhereClause {\n-                                                id: ast::DUMMY_NODE_ID,\n-                                                predicates: Vec::new(),\n-                                                span: syntax_pos::DUMMY_SP,\n-                                            },\n-                                            span: syntax_pos::DUMMY_SP,\n-                                        },\n-                                        P(ast::Block {\n-                                            stmts: vec![ast::Stmt {\n-                                                node: ast::StmtKind::Semi(P(ast::Expr{\n-                                                    id: ast::DUMMY_NODE_ID,\n-                                                    node: ast::ExprKind::Path(None,\n-                                                        ast::Path{\n-                                                            span:sp(17,18),\n-                                                            segments: vec![str2seg(\"b\", 17, 18)],\n-                                                        }),\n-                                                    span: sp(17,18),\n-                                                    attrs: ThinVec::new()})),\n-                                                id: ast::DUMMY_NODE_ID,\n-                                                span: sp(17,19)}],\n-                                            id: ast::DUMMY_NODE_ID,\n-                                            rules: ast::BlockCheckMode::Default, // no idea\n-                                            span: sp(15,21),\n-                                            recovered: false,\n-                                        })),\n-                                vis: respan(sp(0, 0), ast::VisibilityKind::Inherited),\n-                                span: sp(0,21)})));\n-        })\n-    }\n-\n     #[test] fn parse_use() {\n         with_globals(|| {\n             let use_s = \"use foo::bar::baz;\";\n@@ -1133,26 +978,3 @@ mod tests {\n         });\n     }\n }\n-\n-/// `SeqSep` : a sequence separator (token)\n-/// and whether a trailing separator is allowed.\n-pub struct SeqSep {\n-    pub sep: Option<token::Token>,\n-    pub trailing_sep_allowed: bool,\n-}\n-\n-impl SeqSep {\n-    pub fn trailing_allowed(t: token::Token) -> SeqSep {\n-        SeqSep {\n-            sep: Some(t),\n-            trailing_sep_allowed: true,\n-        }\n-    }\n-\n-    pub fn none() -> SeqSep {\n-        SeqSep {\n-            sep: None,\n-            trailing_sep_allowed: false,\n-        }\n-    }\n-}"}, {"sha": "46b7f2d7bda778b76fde850199e8b3d969221ea0", "filename": "src/libsyntax/util/parser_testing.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e3acb341b2ff743e186c032326d24bfa8827bedc/src%2Flibsyntax%2Futil%2Fparser_testing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3acb341b2ff743e186c032326d24bfa8827bedc/src%2Flibsyntax%2Futil%2Fparser_testing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fparser_testing.rs?ref=e3acb341b2ff743e186c032326d24bfa8827bedc", "patch": "@@ -63,14 +63,6 @@ pub fn string_to_item (source_str : String) -> Option<P<ast::Item>> {\n     })\n }\n \n-/// Parse a string, return a stmt\n-pub fn string_to_stmt(source_str : String) -> Option<ast::Stmt> {\n-    let ps = ParseSess::new(FilePathMapping::empty());\n-    with_error_checking_parse(source_str, &ps, |p| {\n-        p.parse_stmt()\n-    })\n-}\n-\n /// Parse a string, return a pat. Uses \"irrefutable\"... which doesn't\n /// (currently) affect parsing.\n pub fn string_to_pat(source_str: String) -> P<ast::Pat> {"}, {"sha": "ff9663cdd3cc5d8b0055f1dd8acb2f4ba9427456", "filename": "src/libsyntax_ext/format_foreign.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e3acb341b2ff743e186c032326d24bfa8827bedc/src%2Flibsyntax_ext%2Fformat_foreign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3acb341b2ff743e186c032326d24bfa8827bedc/src%2Flibsyntax_ext%2Fformat_foreign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fformat_foreign.rs?ref=e3acb341b2ff743e186c032326d24bfa8827bedc", "patch": "@@ -12,7 +12,7 @@ pub mod printf {\n     use super::strcursor::StrCursor as Cur;\n \n     /// Represents a single `printf`-style substitution.\n-    #[derive(Clone, Debug)]\n+    #[derive(Clone, PartialEq, Debug)]\n     pub enum Substitution<'a> {\n         /// A formatted output substitution.\n         Format(Format<'a>),\n@@ -40,7 +40,7 @@ pub mod printf {\n         }\n     }\n \n-    #[derive(Clone, Debug)]\n+    #[derive(Clone, PartialEq, Debug)]\n     /// A single `printf`-style formatting directive.\n     pub struct Format<'a> {\n         /// The entire original formatting directive.\n@@ -213,7 +213,7 @@ pub mod printf {\n     }\n \n     /// A general number used in a `printf` formatting directive.\n-    #[derive(Copy, Clone, Debug)]\n+    #[derive(Copy, Clone, PartialEq, Debug)]\n     pub enum Num {\n         // The range of these values is technically bounded by `NL_ARGMAX`... but, at least for GNU\n         // libc, it apparently has no real fixed limit.  A `u16` is used here on the basis that it\n@@ -739,7 +739,7 @@ pub mod printf {\n pub mod shell {\n     use super::strcursor::StrCursor as Cur;\n \n-    #[derive(Clone, Debug)]\n+    #[derive(Clone, PartialEq, Debug)]\n     pub enum Substitution<'a> {\n         Ordinal(u8),\n         Name(&'a str),"}, {"sha": "798c214bc471569468aaaeabba782560d838263a", "filename": "src/test/run-pass-fulldeps/issue-35829.rs", "status": "removed", "additions": 0, "deletions": 59, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/5987fe8f75c443d4f73603fa5a3af8ab41ee1b01/src%2Ftest%2Frun-pass-fulldeps%2Fissue-35829.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5987fe8f75c443d4f73603fa5a3af8ab41ee1b01/src%2Ftest%2Frun-pass-fulldeps%2Fissue-35829.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fissue-35829.rs?ref=5987fe8f75c443d4f73603fa5a3af8ab41ee1b01", "patch": "@@ -1,59 +0,0 @@\n-// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// ignore-stage1\n-// ignore-cross-compile\n-#![feature(quote, rustc_private)]\n-\n-extern crate syntax;\n-extern crate rustc_data_structures;\n-\n-use syntax::ext::base::{ExtCtxt, DummyResolver};\n-use syntax::ext::expand::ExpansionConfig;\n-use syntax::parse::ParseSess;\n-use syntax::codemap::{FilePathMapping, dummy_spanned};\n-use syntax::print::pprust::expr_to_string;\n-use syntax::ast::{ExprKind, LitKind, RangeLimits};\n-use syntax::ptr::P;\n-\n-use rustc_data_structures::sync::Lrc;\n-\n-fn main() {\n-    syntax::with_globals(|| run());\n-}\n-\n-fn run() {\n-    let parse_sess = ParseSess::new(FilePathMapping::empty());\n-    let exp_cfg = ExpansionConfig::default(\"issue_35829\".to_owned());\n-    let mut resolver = DummyResolver;\n-    let cx = ExtCtxt::new(&parse_sess, exp_cfg, &mut resolver);\n-\n-    // check byte string\n-    let byte_string = quote_expr!(&cx, b\"one\");\n-    let byte_string_lit_kind = LitKind::ByteStr(Lrc::new(b\"one\".to_vec()));\n-    assert_eq!(byte_string.node, ExprKind::Lit(P(dummy_spanned(byte_string_lit_kind))));\n-\n-    // check raw byte string\n-    let raw_byte_string = quote_expr!(&cx, br###\"#\"two\"#\"###);\n-    let raw_byte_string_lit_kind = LitKind::ByteStr(Lrc::new(b\"#\\\"two\\\"#\".to_vec()));\n-    assert_eq!(raw_byte_string.node, ExprKind::Lit(P(dummy_spanned(raw_byte_string_lit_kind))));\n-\n-    // check dotdoteq\n-    let closed_range = quote_expr!(&cx, 0 ..= 1);\n-    assert_eq!(closed_range.node, ExprKind::Range(\n-        Some(quote_expr!(&cx, 0)),\n-        Some(quote_expr!(&cx, 1)),\n-        RangeLimits::Closed\n-    ));\n-\n-    // test case from 35829\n-    let expr_35829 = quote_expr!(&cx, std::io::stdout().write(b\"one\"));\n-    assert_eq!(expr_to_string(&expr_35829), r#\"std::io::stdout().write(b\"one\")\"#);\n-}"}]}