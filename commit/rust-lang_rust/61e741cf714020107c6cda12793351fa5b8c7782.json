{"sha": "61e741cf714020107c6cda12793351fa5b8c7782", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYxZTc0MWNmNzE0MDIwMTA3YzZjZGExMjc5MzM1MWZhNWI4Yzc3ODI=", "commit": {"author": {"name": "Luqman Aden", "email": "me@luqman.ca", "date": "2013-07-25T06:33:43Z"}, "committer": {"name": "Luqman Aden", "email": "me@luqman.ca", "date": "2013-07-25T09:57:52Z"}, "message": "libstd: Implement {peer, socket}_name for new rt tcp & udp.", "tree": {"sha": "9d603295e8567bb9648fef359bc58e4194132e15", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9d603295e8567bb9648fef359bc58e4194132e15"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/61e741cf714020107c6cda12793351fa5b8c7782", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/61e741cf714020107c6cda12793351fa5b8c7782", "html_url": "https://github.com/rust-lang/rust/commit/61e741cf714020107c6cda12793351fa5b8c7782", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/61e741cf714020107c6cda12793351fa5b8c7782/comments", "author": {"login": "luqmana", "id": 287063, "node_id": "MDQ6VXNlcjI4NzA2Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/287063?v=4", "gravatar_id": "", "url": "https://api.github.com/users/luqmana", "html_url": "https://github.com/luqmana", "followers_url": "https://api.github.com/users/luqmana/followers", "following_url": "https://api.github.com/users/luqmana/following{/other_user}", "gists_url": "https://api.github.com/users/luqmana/gists{/gist_id}", "starred_url": "https://api.github.com/users/luqmana/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/luqmana/subscriptions", "organizations_url": "https://api.github.com/users/luqmana/orgs", "repos_url": "https://api.github.com/users/luqmana/repos", "events_url": "https://api.github.com/users/luqmana/events{/privacy}", "received_events_url": "https://api.github.com/users/luqmana/received_events", "type": "User", "site_admin": false}, "committer": {"login": "luqmana", "id": 287063, "node_id": "MDQ6VXNlcjI4NzA2Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/287063?v=4", "gravatar_id": "", "url": "https://api.github.com/users/luqmana", "html_url": "https://github.com/luqmana", "followers_url": "https://api.github.com/users/luqmana/followers", "following_url": "https://api.github.com/users/luqmana/following{/other_user}", "gists_url": "https://api.github.com/users/luqmana/gists{/gist_id}", "starred_url": "https://api.github.com/users/luqmana/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/luqmana/subscriptions", "organizations_url": "https://api.github.com/users/luqmana/orgs", "repos_url": "https://api.github.com/users/luqmana/repos", "events_url": "https://api.github.com/users/luqmana/events{/privacy}", "received_events_url": "https://api.github.com/users/luqmana/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4a726f0573dcfcd01ae9b37266014df0e26f2e22", "url": "https://api.github.com/repos/rust-lang/rust/commits/4a726f0573dcfcd01ae9b37266014df0e26f2e22", "html_url": "https://github.com/rust-lang/rust/commit/4a726f0573dcfcd01ae9b37266014df0e26f2e22"}], "stats": {"total": 340, "additions": 227, "deletions": 113}, "files": [{"sha": "5251b6d9ded9e157a6768391cf1fe46b3c46d237", "filename": "src/libstd/rt/io/net/tcp.rs", "status": "modified", "additions": 36, "deletions": 2, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/61e741cf714020107c6cda12793351fa5b8c7782/src%2Flibstd%2Frt%2Fio%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61e741cf714020107c6cda12793351fa5b8c7782/src%2Flibstd%2Frt%2Fio%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fnet%2Ftcp.rs?ref=61e741cf714020107c6cda12793351fa5b8c7782", "patch": "@@ -14,8 +14,9 @@ use rt::io::net::ip::IpAddr;\n use rt::io::{Reader, Writer, Listener};\n use rt::io::{io_error, read_error, EndOfFile};\n use rt::rtio::{IoFactory, IoFactoryObject,\n-               RtioTcpListener, RtioTcpListenerObject,\n-               RtioTcpStream, RtioTcpStreamObject};\n+               RtioSocket, RtioTcpListener,\n+               RtioTcpListenerObject, RtioTcpStream,\n+               RtioTcpStreamObject};\n use rt::local::Local;\n \n pub struct TcpStream(~RtioTcpStreamObject);\n@@ -42,6 +43,28 @@ impl TcpStream {\n             }\n         }\n     }\n+\n+    pub fn peer_name(&mut self) -> Option<IpAddr> {\n+        match (***self).peer_name() {\n+            Ok(pn) => Some(pn),\n+            Err(ioerr) => {\n+                rtdebug!(\"failed to get peer name: %?\", ioerr);\n+                io_error::cond.raise(ioerr);\n+                None\n+            }\n+        }\n+    }\n+\n+    pub fn socket_name(&mut self) -> Option<IpAddr> {\n+        match (***self).socket_name() {\n+            Ok(sn) => Some(sn),\n+            Err(ioerr) => {\n+                rtdebug!(\"failed to get socket name: %?\", ioerr);\n+                io_error::cond.raise(ioerr);\n+                None\n+            }\n+        }\n+    }\n }\n \n impl Reader for TcpStream {\n@@ -90,6 +113,17 @@ impl TcpListener {\n             }\n         }\n     }\n+\n+    pub fn socket_name(&mut self) -> Option<IpAddr> {\n+        match (***self).socket_name() {\n+            Ok(sn) => Some(sn),\n+            Err(ioerr) => {\n+                rtdebug!(\"failed to get socket name: %?\", ioerr);\n+                io_error::cond.raise(ioerr);\n+                None\n+            }\n+        }\n+    }\n }\n \n impl Listener<TcpStream> for TcpListener {"}, {"sha": "d78adbbbe4da6eb9b3b96b89a84dfacc67622e19", "filename": "src/libstd/rt/io/net/udp.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/61e741cf714020107c6cda12793351fa5b8c7782/src%2Flibstd%2Frt%2Fio%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61e741cf714020107c6cda12793351fa5b8c7782/src%2Flibstd%2Frt%2Fio%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fnet%2Fudp.rs?ref=61e741cf714020107c6cda12793351fa5b8c7782", "patch": "@@ -13,7 +13,7 @@ use result::{Ok, Err};\n use rt::io::net::ip::IpAddr;\n use rt::io::{Reader, Writer};\n use rt::io::{io_error, read_error, EndOfFile};\n-use rt::rtio::{RtioUdpSocketObject, RtioUdpSocket, IoFactory, IoFactoryObject};\n+use rt::rtio::{RtioSocket, RtioUdpSocketObject, RtioUdpSocket, IoFactory, IoFactoryObject};\n use rt::local::Local;\n \n pub struct UdpSocket(~RtioUdpSocketObject);\n@@ -53,6 +53,17 @@ impl UdpSocket {\n     pub fn connect(self, other: IpAddr) -> UdpStream {\n         UdpStream { socket: self, connectedTo: other }\n     }\n+\n+    pub fn socket_name(&mut self) -> Option<IpAddr> {\n+        match (***self).socket_name() {\n+            Ok(sn) => Some(sn),\n+            Err(ioerr) => {\n+                rtdebug!(\"failed to get socket name: %?\", ioerr);\n+                io_error::cond.raise(ioerr);\n+                None\n+            }\n+        }\n+    }\n }\n \n pub struct UdpStream {"}, {"sha": "73b38c4a40db2dde35b33d3c8bbd837ce3a6bf2f", "filename": "src/libstd/rt/rtio.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/61e741cf714020107c6cda12793351fa5b8c7782/src%2Flibstd%2Frt%2Frtio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61e741cf714020107c6cda12793351fa5b8c7782/src%2Flibstd%2Frt%2Frtio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Frtio.rs?ref=61e741cf714020107c6cda12793351fa5b8c7782", "patch": "@@ -59,15 +59,15 @@ pub trait RtioTcpListener : RtioSocket {\n pub trait RtioTcpStream : RtioSocket {\n     fn read(&mut self, buf: &mut [u8]) -> Result<uint, IoError>;\n     fn write(&mut self, buf: &[u8]) -> Result<(), IoError>;\n-    fn peer_name(&mut self) -> IpAddr;\n+    fn peer_name(&mut self) -> Result<IpAddr, IoError>;\n     fn control_congestion(&mut self);\n     fn nodelay(&mut self);\n     fn keepalive(&mut self, delay_in_seconds: uint);\n     fn letdie(&mut self);\n }\n \n pub trait RtioSocket {\n-    fn socket_name(&mut self) -> IpAddr;\n+    fn socket_name(&mut self) -> Result<IpAddr, IoError>;\n }\n \n pub trait RtioUdpSocket : RtioSocket {"}, {"sha": "47e0a240e45450fe6914d4b4166dc1b91657ab48", "filename": "src/libstd/rt/uv/async.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/61e741cf714020107c6cda12793351fa5b8c7782/src%2Flibstd%2Frt%2Fuv%2Fasync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61e741cf714020107c6cda12793351fa5b8c7782/src%2Flibstd%2Frt%2Fuv%2Fasync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fasync.rs?ref=61e741cf714020107c6cda12793351fa5b8c7782", "patch": "@@ -34,7 +34,7 @@ impl AsyncWatcher {\n \n         extern fn async_cb(handle: *uvll::uv_async_t, status: c_int) {\n             let mut watcher: AsyncWatcher = NativeHandle::from_native_handle(handle);\n-            let status = status_to_maybe_uv_error(watcher.native_handle(), status);\n+            let status = status_to_maybe_uv_error(watcher, status);\n             let data = watcher.get_watcher_data();\n             let cb = data.async_cb.get_ref();\n             (*cb)(watcher, status);"}, {"sha": "b73be9f7250dbead2c7905c5497127e3210d1a93", "filename": "src/libstd/rt/uv/idle.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/61e741cf714020107c6cda12793351fa5b8c7782/src%2Flibstd%2Frt%2Fuv%2Fidle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61e741cf714020107c6cda12793351fa5b8c7782/src%2Flibstd%2Frt%2Fuv%2Fidle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fidle.rs?ref=61e741cf714020107c6cda12793351fa5b8c7782", "patch": "@@ -43,7 +43,7 @@ impl IdleWatcher {\n             let mut idle_watcher: IdleWatcher = NativeHandle::from_native_handle(handle);\n             let data = idle_watcher.get_watcher_data();\n             let cb: &IdleCallback = data.idle_cb.get_ref();\n-            let status = status_to_maybe_uv_error(handle, status);\n+            let status = status_to_maybe_uv_error(idle_watcher, status);\n             (*cb)(idle_watcher, status);\n         }\n     }"}, {"sha": "aacd747087e944f4358ed5364acc8ee2d2b2f182", "filename": "src/libstd/rt/uv/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/61e741cf714020107c6cda12793351fa5b8c7782/src%2Flibstd%2Frt%2Fuv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61e741cf714020107c6cda12793351fa5b8c7782/src%2Flibstd%2Frt%2Fuv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fmod.rs?ref=61e741cf714020107c6cda12793351fa5b8c7782", "patch": "@@ -282,14 +282,14 @@ pub fn uv_error_to_io_error(uverr: UvError) -> IoError {\n }\n \n /// Given a uv handle, convert a callback status to a UvError\n-// XXX: Follow the pattern below by parameterizing over T: Watcher, not T\n-pub fn status_to_maybe_uv_error<T>(handle: *T, status: c_int) -> Option<UvError> {\n+pub fn status_to_maybe_uv_error<T, U: Watcher + NativeHandle<*T>>(handle: U,\n+                                                                 status: c_int) -> Option<UvError> {\n     if status != -1 {\n         None\n     } else {\n         unsafe {\n             rtdebug!(\"handle: %x\", handle as uint);\n-            let loop_ = uvll::get_loop_for_uv_handle(handle);\n+            let loop_ = uvll::get_loop_for_uv_handle(handle.native_handle());\n             rtdebug!(\"loop: %x\", loop_ as uint);\n             let err = uvll::last_error(loop_);\n             Some(UvError(err))"}, {"sha": "dbfe36acbebf76a9c071111f85ede2c2245f5383", "filename": "src/libstd/rt/uv/net.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/61e741cf714020107c6cda12793351fa5b8c7782/src%2Flibstd%2Frt%2Fuv%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61e741cf714020107c6cda12793351fa5b8c7782/src%2Flibstd%2Frt%2Fuv%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fnet.rs?ref=61e741cf714020107c6cda12793351fa5b8c7782", "patch": "@@ -22,7 +22,7 @@ use str;\n use from_str::{FromStr};\n use num;\n \n-enum UvIpAddr {\n+pub enum UvIpAddr {\n     UvIpv4(*sockaddr_in),\n     UvIpv6(*sockaddr_in6),\n }\n@@ -32,8 +32,8 @@ fn sockaddr_to_UvIpAddr(addr: *uvll::sockaddr) -> UvIpAddr {\n         assert!((is_ip4_addr(addr) || is_ip6_addr(addr)));\n         assert!(!(is_ip4_addr(addr) && is_ip6_addr(addr)));\n         match addr {\n-            _ if is_ip4_addr(addr) => UvIpv4(as_sockaddr_in(addr)),\n-            _ if is_ip6_addr(addr) => UvIpv6(as_sockaddr_in6(addr)),\n+            _ if is_ip4_addr(addr) => UvIpv4(addr as *uvll::sockaddr_in),\n+            _ if is_ip6_addr(addr) => UvIpv6(addr as *uvll::sockaddr_in6),\n             _ => fail!(),\n         }\n     }\n@@ -133,7 +133,7 @@ fn uv_ip_as_ip<T>(addr: UvIpAddr, f: &fn(IpAddr) -> T) -> T {\n     f(ip)\n }\n \n-fn uv_ip_to_ip(addr: UvIpAddr) -> IpAddr {\n+pub fn uv_ip_to_ip(addr: UvIpAddr) -> IpAddr {\n     use util;\n     uv_ip_as_ip(addr, util::id)\n }\n@@ -154,7 +154,7 @@ fn test_ip6_conversion() {\n     assert_eq!(ip6, ip_as_uv_ip(ip6, uv_ip_to_ip));\n }\n \n-// uv_stream t is the parent class of uv_tcp_t, uv_pipe_t, uv_tty_t\n+// uv_stream_t is the parent class of uv_tcp_t, uv_pipe_t, uv_tty_t\n // and uv_file_t\n pub struct StreamWatcher(*uvll::uv_stream_t);\n impl Watcher for StreamWatcher { }\n@@ -180,7 +180,7 @@ impl StreamWatcher {\n             rtdebug!(\"buf len: %d\", buf.len as int);\n             let mut stream_watcher: StreamWatcher = NativeHandle::from_native_handle(stream);\n             let cb = stream_watcher.get_watcher_data().read_cb.get_ref();\n-            let status = status_to_maybe_uv_error(stream, nread as c_int);\n+            let status = status_to_maybe_uv_error(stream_watcher, nread as c_int);\n             (*cb)(stream_watcher, nread as int, buf, status);\n         }\n     }\n@@ -210,7 +210,7 @@ impl StreamWatcher {\n             let mut stream_watcher = write_request.stream();\n             write_request.delete();\n             let cb = stream_watcher.get_watcher_data().write_cb.take_unwrap();\n-            let status = status_to_maybe_uv_error(stream_watcher.native_handle(), status);\n+            let status = status_to_maybe_uv_error(stream_watcher, status);\n             cb(stream_watcher, status);\n         }\n     }\n@@ -302,7 +302,7 @@ impl TcpWatcher {\n                 let mut stream_watcher = connect_request.stream();\n                 connect_request.delete();\n                 let cb = stream_watcher.get_watcher_data().connect_cb.take_unwrap();\n-                let status = status_to_maybe_uv_error(stream_watcher.native_handle(), status);\n+                let status = status_to_maybe_uv_error(stream_watcher, status);\n                 cb(stream_watcher, status);\n             }\n         }\n@@ -325,7 +325,7 @@ impl TcpWatcher {\n             rtdebug!(\"connection_cb\");\n             let mut stream_watcher: StreamWatcher = NativeHandle::from_native_handle(handle);\n             let cb = stream_watcher.get_watcher_data().connect_cb.get_ref();\n-            let status = status_to_maybe_uv_error(handle, status);\n+            let status = status_to_maybe_uv_error(stream_watcher, status);\n             (*cb)(stream_watcher, status);\n         }\n     }\n@@ -402,7 +402,7 @@ impl UdpWatcher {\n             rtdebug!(\"buf len: %d\", buf.len as int);\n             let mut udp_watcher: UdpWatcher = NativeHandle::from_native_handle(handle);\n             let cb = udp_watcher.get_watcher_data().udp_recv_cb.get_ref();\n-            let status = status_to_maybe_uv_error(handle, nread as c_int);\n+            let status = status_to_maybe_uv_error(udp_watcher, nread as c_int);\n             let addr = uv_ip_to_ip(sockaddr_to_UvIpAddr(addr));\n             (*cb)(udp_watcher, nread as int, buf, addr, flags as uint, status);\n         }\n@@ -437,7 +437,7 @@ impl UdpWatcher {\n             let mut udp_watcher = send_request.handle();\n             send_request.delete();\n             let cb = udp_watcher.get_watcher_data().udp_send_cb.take_unwrap();\n-            let status = status_to_maybe_uv_error(udp_watcher.native_handle(), status);\n+            let status = status_to_maybe_uv_error(udp_watcher, status);\n             cb(udp_watcher, status);\n         }\n     }"}, {"sha": "eaa5e77a6da2fe71b3a67a11105dc5acee18c4f5", "filename": "src/libstd/rt/uv/timer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/61e741cf714020107c6cda12793351fa5b8c7782/src%2Flibstd%2Frt%2Fuv%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61e741cf714020107c6cda12793351fa5b8c7782/src%2Flibstd%2Frt%2Fuv%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Ftimer.rs?ref=61e741cf714020107c6cda12793351fa5b8c7782", "patch": "@@ -43,7 +43,7 @@ impl TimerWatcher {\n             let mut watcher: TimerWatcher = NativeHandle::from_native_handle(handle);\n             let data = watcher.get_watcher_data();\n             let cb = data.timer_cb.get_ref();\n-            let status = status_to_maybe_uv_error(handle, status);\n+            let status = status_to_maybe_uv_error(watcher, status);\n             (*cb)(watcher, status);\n         }\n     }"}, {"sha": "9f2316d62271e80a13ed19ab124eae92a42d239d", "filename": "src/libstd/rt/uv/uvio.rs", "status": "modified", "additions": 118, "deletions": 16, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/61e741cf714020107c6cda12793351fa5b8c7782/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61e741cf714020107c6cda12793351fa5b8c7782/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs?ref=61e741cf714020107c6cda12793351fa5b8c7782", "patch": "@@ -19,6 +19,7 @@ use rt::io::IoError;\n use rt::io::net::ip::IpAddr;\n use rt::uv::*;\n use rt::uv::idle::IdleWatcher;\n+use rt::uv::net::{UvIpv4, UvIpv6};\n use rt::rtio::*;\n use rt::sched::Scheduler;\n use rt::io::{standard_error, OtherIoError};\n@@ -220,7 +221,9 @@ impl IoFactory for UvIoFactory {\n                 rtdebug!(\"connect: in connect callback\");\n                 if status.is_none() {\n                     rtdebug!(\"status is none\");\n-                    let res = Ok(~UvTcpStream(stream_watcher));\n+                    let tcp_watcher =\n+                        NativeHandle::from_native_handle(stream_watcher.native_handle());\n+                    let res = Ok(~UvTcpStream(tcp_watcher));\n \n                     // Store the stream in the task's stack\n                     unsafe { (*result_cell_ptr).put_back(res); }\n@@ -286,7 +289,6 @@ impl IoFactory for UvIoFactory {\n     }\n }\n \n-// FIXME #6090: Prefer newtype structs but Drop doesn't work\n pub struct UvTcpListener {\n     watcher: TcpWatcher,\n     listening: bool,\n@@ -320,8 +322,33 @@ impl Drop for UvTcpListener {\n }\n \n impl RtioSocket for UvTcpListener {\n-    // XXX implement\n-    fn socket_name(&mut self) -> IpAddr { fail!(); }\n+    fn socket_name(&mut self) -> Result<IpAddr, IoError> {\n+        // Allocate a sockaddr_storage\n+        // since we don't know if it's ipv4 or ipv6\n+        let r_addr = unsafe { uvll::malloc_sockaddr_storage() };\n+\n+        let r = unsafe {\n+            uvll::rust_uv_tcp_getsockname(self.watcher.native_handle(),\n+                                          r_addr as *uvll::sockaddr_storage)\n+        };\n+\n+        if r != 0 {\n+            let status = status_to_maybe_uv_error(self.watcher, r);\n+            return Err(uv_error_to_io_error(status.unwrap()));\n+        }\n+\n+        let addr = unsafe {\n+            if uvll::is_ip6_addr(r_addr as *uvll::sockaddr) {\n+                net::uv_ip_to_ip(UvIpv6(r_addr as *uvll::sockaddr_in6))\n+            } else {\n+                net::uv_ip_to_ip(UvIpv4(r_addr as *uvll::sockaddr_in))\n+            }\n+        };\n+\n+        unsafe { uvll::free_sockaddr_storage(r_addr); }\n+\n+        Ok(addr)\n+    }\n }\n \n impl RtioTcpListener for UvTcpListener {\n@@ -344,9 +371,8 @@ impl RtioTcpListener for UvTcpListener {\n             let maybe_stream = if status.is_none() {\n                 let mut loop_ = server_stream_watcher.event_loop();\n                 let client_tcp_watcher = TcpWatcher::new(&mut loop_);\n-                let client_tcp_watcher = client_tcp_watcher.as_stream();\n                 // XXX: Need's to be surfaced in interface\n-                server_stream_watcher.accept(client_tcp_watcher);\n+                server_stream_watcher.accept(client_tcp_watcher.as_stream());\n                 Ok(~UvTcpStream(client_tcp_watcher))\n             } else {\n                 Err(standard_error(OtherIoError))\n@@ -365,16 +391,15 @@ impl RtioTcpListener for UvTcpListener {\n     fn dont_accept_simultaneously(&mut self) { fail!(); }\n }\n \n-// FIXME #6090: Prefer newtype structs but Drop doesn't work\n-pub struct UvTcpStream(StreamWatcher);\n+pub struct UvTcpStream(TcpWatcher);\n \n impl Drop for UvTcpStream {\n     fn drop(&self) {\n         rtdebug!(\"closing tcp stream\");\n         let scheduler = Local::take::<Scheduler>();\n         do scheduler.deschedule_running_task_and_then |_, task| {\n             let task_cell = Cell::new(task);\n-            do self.close {\n+            do self.as_stream().close {\n                 let scheduler = Local::take::<Scheduler>();\n                 scheduler.resume_blocked_task_immediately(task_cell.take());\n             }\n@@ -383,8 +408,33 @@ impl Drop for UvTcpStream {\n }\n \n impl RtioSocket for UvTcpStream {\n-    // XXX implement\n-    fn socket_name(&mut self) -> IpAddr { fail!(); }\n+    fn socket_name(&mut self) -> Result<IpAddr, IoError> {\n+        // Allocate a sockaddr_storage\n+        // since we don't know if it's ipv4 or ipv6\n+        let r_addr = unsafe { uvll::malloc_sockaddr_storage() };\n+\n+        let r = unsafe {\n+            uvll::rust_uv_tcp_getsockname(self.native_handle(),\n+                                          r_addr as *uvll::sockaddr_storage)\n+        };\n+\n+        if r != 0 {\n+            let status = status_to_maybe_uv_error(**self, r);\n+            return Err(uv_error_to_io_error(status.unwrap()));\n+        }\n+\n+        let addr = unsafe {\n+            if uvll::is_ip6_addr(r_addr as *uvll::sockaddr) {\n+                net::uv_ip_to_ip(UvIpv6(r_addr as *uvll::sockaddr_in6))\n+            } else {\n+                net::uv_ip_to_ip(UvIpv4(r_addr as *uvll::sockaddr_in))\n+            }\n+        };\n+\n+        unsafe { uvll::free_sockaddr_storage(r_addr); }\n+\n+        Ok(addr)\n+    }\n }\n \n impl RtioTcpStream for UvTcpStream {\n@@ -404,7 +454,7 @@ impl RtioTcpStream for UvTcpStream {\n             let alloc: AllocCallback = |_| unsafe {\n                 slice_to_uv_buf(*buf_ptr)\n             };\n-            let mut watcher = **self;\n+            let mut watcher = self.as_stream();\n             do watcher.read_start(alloc) |mut watcher, nread, _buf, status| {\n \n                 // Stop reading so that no read callbacks are\n@@ -440,7 +490,7 @@ impl RtioTcpStream for UvTcpStream {\n         do scheduler.deschedule_running_task_and_then |_, task| {\n             let task_cell = Cell::new(task);\n             let buf = unsafe { slice_to_uv_buf(*buf_ptr) };\n-            let mut watcher = **self;\n+            let mut watcher = self.as_stream();\n             do watcher.write(buf) |_watcher, status| {\n                 let result = if status.is_none() {\n                     Ok(())\n@@ -459,8 +509,35 @@ impl RtioTcpStream for UvTcpStream {\n         return result_cell.take();\n     }\n \n+    fn peer_name(&mut self) -> Result<IpAddr, IoError> {\n+        // Allocate a sockaddr_storage\n+        // since we don't know if it's ipv4 or ipv6\n+        let r_addr = unsafe { uvll::malloc_sockaddr_storage() };\n+\n+        let r = unsafe {\n+            uvll::rust_uv_tcp_getpeername(self.native_handle(),\n+                                          r_addr as *uvll::sockaddr_storage)\n+        };\n+\n+        if r != 0 {\n+            let status = status_to_maybe_uv_error(**self, r);\n+            return Err(uv_error_to_io_error(status.unwrap()));\n+        }\n+\n+        let addr = unsafe {\n+            if uvll::is_ip6_addr(r_addr as *uvll::sockaddr) {\n+                net::uv_ip_to_ip(UvIpv6(r_addr as *uvll::sockaddr_in6))\n+            } else {\n+                net::uv_ip_to_ip(UvIpv4(r_addr as *uvll::sockaddr_in))\n+            }\n+        };\n+\n+        unsafe { uvll::free_sockaddr_storage(r_addr); }\n+\n+        Ok(addr)\n+    }\n+\n     // XXX implement\n-    fn peer_name(&mut self) -> IpAddr { fail!(); }\n     fn control_congestion(&mut self) { fail!(); }\n     fn nodelay(&mut self) { fail!(); }\n     fn keepalive(&mut self, _delay_in_seconds: uint) { fail!(); }\n@@ -484,8 +561,33 @@ impl Drop for UvUdpSocket {\n }\n \n impl RtioSocket for UvUdpSocket {\n-    // XXX implement\n-    fn socket_name(&mut self) -> IpAddr { fail!(); }\n+    fn socket_name(&mut self) -> Result<IpAddr, IoError> {\n+        // Allocate a sockaddr_storage\n+        // since we don't know if it's ipv4 or ipv6\n+        let r_addr = unsafe { uvll::malloc_sockaddr_storage() };\n+\n+        let r = unsafe {\n+            uvll::rust_uv_udp_getsockname(self.native_handle(),\n+                                          r_addr as *uvll::sockaddr_storage)\n+        };\n+\n+        if r != 0 {\n+            let status = status_to_maybe_uv_error(**self, r);\n+            return Err(uv_error_to_io_error(status.unwrap()));\n+        }\n+\n+        let addr = unsafe {\n+            if uvll::is_ip6_addr(r_addr as *uvll::sockaddr) {\n+                net::uv_ip_to_ip(UvIpv6(r_addr as *uvll::sockaddr_in6))\n+            } else {\n+                net::uv_ip_to_ip(UvIpv4(r_addr as *uvll::sockaddr_in))\n+            }\n+        };\n+\n+        unsafe { uvll::free_sockaddr_storage(r_addr); }\n+\n+        Ok(addr)\n+    }\n }\n \n impl RtioUdpSocket for UvUdpSocket {"}, {"sha": "72d96e59c3699a7f58133df52f321aed6596e9f7", "filename": "src/libstd/rt/uv/uvll.rs", "status": "modified", "additions": 17, "deletions": 31, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/61e741cf714020107c6cda12793351fa5b8c7782/src%2Flibstd%2Frt%2Fuv%2Fuvll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61e741cf714020107c6cda12793351fa5b8c7782/src%2Flibstd%2Frt%2Fuv%2Fuvll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fuvll.rs?ref=61e741cf714020107c6cda12793351fa5b8c7782", "patch": "@@ -77,6 +77,7 @@ pub type uv_udp_recv_cb = *u8;\n pub type sockaddr = c_void;\n pub type sockaddr_in = c_void;\n pub type sockaddr_in6 = c_void;\n+pub type sockaddr_storage = c_void;\n pub type uv_membership = c_void;\n \n #[deriving(Eq)]\n@@ -233,14 +234,10 @@ pub unsafe fn get_udp_handle_from_send_req(send_req: *uv_udp_send_t) -> *uv_udp_\n     return rust_uv_get_udp_handle_from_send_req(send_req);\n }\n \n-pub unsafe fn udp_get_sockname(handle: *uv_udp_t, name: *sockaddr_in) -> c_int {\n+pub unsafe fn udp_get_sockname(handle: *uv_udp_t, name: *sockaddr_storage) -> c_int {\n     return rust_uv_udp_getsockname(handle, name);\n }\n \n-pub unsafe fn udp_get_sockname6(handle: *uv_udp_t, name: *sockaddr_in6) -> c_int {\n-    return rust_uv_udp_getsockname6(handle, name);\n-}\n-\n pub unsafe fn udp_set_membership(handle: *uv_udp_t, multicast_addr: *c_char,\n                                  interface_addr: *c_char, membership: uv_membership) -> c_int {\n     return rust_uv_udp_set_membership(handle, multicast_addr, interface_addr, membership);\n@@ -280,22 +277,14 @@ pub unsafe fn tcp_bind6(tcp_server_ptr: *uv_tcp_t, addr_ptr: *sockaddr_in6) -> c\n     return rust_uv_tcp_bind6(tcp_server_ptr, addr_ptr);\n }\n \n-pub unsafe fn tcp_getpeername(tcp_handle_ptr: *uv_tcp_t, name: *sockaddr_in) -> c_int {\n+pub unsafe fn tcp_getpeername(tcp_handle_ptr: *uv_tcp_t, name: *sockaddr_storage) -> c_int {\n     return rust_uv_tcp_getpeername(tcp_handle_ptr, name);\n }\n \n-pub unsafe fn tcp_getpeername6(tcp_handle_ptr: *uv_tcp_t, name: *sockaddr_in6) ->c_int {\n-    return rust_uv_tcp_getpeername6(tcp_handle_ptr, name);\n-}\n-\n-pub unsafe fn tcp_getsockname(handle: *uv_tcp_t, name: *sockaddr_in) -> c_int {\n+pub unsafe fn tcp_getsockname(handle: *uv_tcp_t, name: *sockaddr_storage) -> c_int {\n     return rust_uv_tcp_getsockname(handle, name);\n }\n \n-pub unsafe fn tcp_getsockname6(handle: *uv_tcp_t, name: *sockaddr_in6) -> c_int {\n-    return rust_uv_tcp_getsockname6(handle, name);\n-}\n-\n pub unsafe fn tcp_nodelay(handle: *uv_tcp_t, enable: c_int) -> c_int {\n     return rust_uv_tcp_nodelay(handle, enable);\n }\n@@ -373,14 +362,6 @@ pub unsafe fn is_ip6_addr(addr: *sockaddr) -> bool {\n     match rust_uv_is_ipv6_sockaddr(addr) { 0 => false, _ => true }\n }\n \n-pub unsafe fn as_sockaddr_in(addr: *sockaddr) -> *sockaddr_in {\n-    return rust_uv_sockaddr_as_sockaddr_in(addr);\n-}\n-\n-pub unsafe fn as_sockaddr_in6(addr: *sockaddr) -> *sockaddr_in6 {\n-    return rust_uv_sockaddr_as_sockaddr_in6(addr);\n-}\n-\n pub unsafe fn malloc_ip4_addr(ip: &str, port: int) -> *sockaddr_in {\n     do ip.as_c_str |ip_buf| {\n         rust_uv_ip4_addrp(ip_buf as *u8, port as libc::c_int)\n@@ -392,6 +373,14 @@ pub unsafe fn malloc_ip6_addr(ip: &str, port: int) -> *sockaddr_in6 {\n     }\n }\n \n+pub unsafe fn malloc_sockaddr_storage() -> *sockaddr_storage {\n+    rust_uv_malloc_sockaddr_storage()\n+}\n+\n+pub unsafe fn free_sockaddr_storage(ss: *sockaddr_storage) {\n+    rust_uv_free_sockaddr_storage(ss);\n+}\n+\n pub unsafe fn free_ip4_addr(addr: *sockaddr_in) {\n     rust_uv_free_ip4_addr(addr);\n }\n@@ -520,10 +509,8 @@ extern {\n     fn rust_uv_tcp_connect6(req: *uv_connect_t, handle: *uv_tcp_t, cb: *u8,\n                             addr: *sockaddr_in6) -> c_int;\n     fn rust_uv_tcp_bind6(tcp_server: *uv_tcp_t, addr: *sockaddr_in6) -> c_int;\n-    fn rust_uv_tcp_getpeername(tcp_handle_ptr: *uv_tcp_t, name: *sockaddr_in) -> c_int;\n-    fn rust_uv_tcp_getpeername6(tcp_handle_ptr: *uv_tcp_t, name: *sockaddr_in6) ->c_int;\n-    fn rust_uv_tcp_getsockname(handle: *uv_tcp_t, name: *sockaddr_in) -> c_int;\n-    fn rust_uv_tcp_getsockname6(handle: *uv_tcp_t, name: *sockaddr_in6) -> c_int;\n+    fn rust_uv_tcp_getpeername(tcp_handle_ptr: *uv_tcp_t, name: *sockaddr_storage) -> c_int;\n+    fn rust_uv_tcp_getsockname(handle: *uv_tcp_t, name: *sockaddr_storage) -> c_int;\n     fn rust_uv_tcp_nodelay(handle: *uv_tcp_t, enable: c_int) -> c_int;\n     fn rust_uv_tcp_keepalive(handle: *uv_tcp_t, enable: c_int, delay: c_uint) -> c_int;\n     fn rust_uv_tcp_simultaneous_accepts(handle: *uv_tcp_t, enable: c_int) -> c_int;\n@@ -538,8 +525,7 @@ extern {\n     fn rust_uv_udp_recv_start(server: *uv_udp_t, on_alloc: *u8, on_recv: *u8) -> c_int;\n     fn rust_uv_udp_recv_stop(server: *uv_udp_t) -> c_int;\n     fn rust_uv_get_udp_handle_from_send_req(req: *uv_udp_send_t) -> *uv_udp_t;\n-    fn rust_uv_udp_getsockname(handle: *uv_udp_t, name: *sockaddr_in) -> c_int;\n-    fn rust_uv_udp_getsockname6(handle: *uv_udp_t, name: *sockaddr_in6) -> c_int;\n+    fn rust_uv_udp_getsockname(handle: *uv_udp_t, name: *sockaddr_storage) -> c_int;\n     fn rust_uv_udp_set_membership(handle: *uv_udp_t, multicast_addr: *c_char,\n                                   interface_addr: *c_char, membership: uv_membership) -> c_int;\n     fn rust_uv_udp_set_multicast_loop(handle: *uv_udp_t, on: c_int) -> c_int;\n@@ -548,8 +534,8 @@ extern {\n \n     fn rust_uv_is_ipv4_sockaddr(addr: *sockaddr) -> c_int;\n     fn rust_uv_is_ipv6_sockaddr(addr: *sockaddr) -> c_int;\n-    fn rust_uv_sockaddr_as_sockaddr_in(addr: *sockaddr) -> *sockaddr_in;\n-    fn rust_uv_sockaddr_as_sockaddr_in6(addr: *sockaddr) -> *sockaddr_in6;\n+    fn rust_uv_malloc_sockaddr_storage() -> *sockaddr_storage;\n+    fn rust_uv_free_sockaddr_storage(ss: *sockaddr_storage);\n \n     fn rust_uv_listen(stream: *c_void, backlog: c_int, cb: *u8) -> c_int;\n     fn rust_uv_accept(server: *c_void, client: *c_void) -> c_int;"}, {"sha": "a7f5db9dc5f17611c4af523fc999ee1223d22e56", "filename": "src/rt/rust_uv.cpp", "status": "modified", "additions": 22, "deletions": 38, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/61e741cf714020107c6cda12793351fa5b8c7782/src%2Frt%2Frust_uv.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/61e741cf714020107c6cda12793351fa5b8c7782/src%2Frt%2Frust_uv.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_uv.cpp?ref=61e741cf714020107c6cda12793351fa5b8c7782", "patch": "@@ -282,29 +282,19 @@ rust_uv_tcp_bind6\n \n extern \"C\" int\n rust_uv_tcp_getpeername\n-(uv_tcp_t* handle, sockaddr_in* name) {\n+(uv_tcp_t* handle, sockaddr_storage* name) {\n+    // sockaddr_storage is big enough to hold either\n+    // sockaddr_in or sockaddr_in6\n     int namelen = sizeof(sockaddr_in);\n     return uv_tcp_getpeername(handle, (sockaddr*)name, &namelen);\n }\n \n-extern \"C\" int\n-rust_uv_tcp_getpeername6\n-(uv_tcp_t* handle, sockaddr_in6* name) {\n-    int namelen = sizeof(sockaddr_in6);\n-    return uv_tcp_getpeername(handle, (sockaddr*)name, &namelen);\n-}\n-\n extern \"C\" int\n rust_uv_tcp_getsockname\n-(uv_tcp_t* handle, sockaddr_in* name) {\n-    int namelen = sizeof(sockaddr_in);\n-    return uv_tcp_getsockname(handle, (sockaddr*)name, &namelen);\n-}\n-\n-extern \"C\" int\n-rust_uv_tcp_getsockname6\n-(uv_tcp_t* handle, sockaddr_in6* name) {\n-    int namelen = sizeof(sockaddr_in6);\n+(uv_tcp_t* handle, sockaddr_storage* name) {\n+    // sockaddr_storage is big enough to hold either\n+    // sockaddr_in or sockaddr_in6\n+    int namelen = sizeof(sockaddr_storage);\n     return uv_tcp_getsockname(handle, (sockaddr*)name, &namelen);\n }\n \n@@ -370,15 +360,10 @@ rust_uv_get_udp_handle_from_send_req(uv_udp_send_t* send_req) {\n \n extern \"C\" int\n rust_uv_udp_getsockname\n-(uv_udp_t* handle, sockaddr_in* name) {\n-    int namelen = sizeof(sockaddr_in);\n-    return uv_udp_getsockname(handle, (sockaddr*)name, &namelen);\n-}\n-\n-extern \"C\" int\n-rust_uv_udp_getsockname6\n-(uv_udp_t* handle, sockaddr_in6* name) {\n-    int namelen = sizeof(sockaddr_in6);\n+(uv_udp_t* handle, sockaddr_storage* name) {\n+    // sockaddr_storage is big enough to hold either\n+    // sockaddr_in or sockaddr_in6\n+    int namelen = sizeof(sockaddr_storage);\n     return uv_udp_getsockname(handle, (sockaddr*)name, &namelen);\n }\n \n@@ -609,6 +594,17 @@ rust_uv_ip6_addrp(const char* ip, int port) {\n   return addrp;\n }\n \n+extern \"C\" struct sockaddr_storage *\n+rust_uv_malloc_sockaddr_storage() {\n+    struct sockaddr_storage *ss = (sockaddr_storage *)malloc(sizeof(struct sockaddr_storage));\n+    return ss;\n+}\n+\n+extern \"C\" void\n+rust_uv_free_sockaddr_storage(struct sockaddr_storage *ss) {\n+    free(ss);\n+}\n+\n extern \"C\" void\n rust_uv_free_ip4_addr(sockaddr_in *addrp) {\n   free(addrp);\n@@ -669,18 +665,6 @@ rust_uv_is_ipv6_sockaddr(sockaddr* addr) {\n     return addr->sa_family == AF_INET6;\n }\n \n-extern \"C\" sockaddr_in*\n-rust_uv_sockaddr_as_sockaddr_in(sockaddr* addr) {\n-//    return (sockaddr_in*)addr->sa_data;\n-    return (sockaddr_in*)addr;\n-}\n-\n-extern \"C\" sockaddr_in6*\n-rust_uv_sockaddr_as_sockaddr_in6(sockaddr* addr) {\n-    //return (sockaddr_in6*)addr->sa_data;\n-    return (sockaddr_in6*)addr;\n-}\n-\n extern \"C\" bool\n rust_uv_is_ipv4_addrinfo(addrinfo* input) {\n     return input->ai_family == AF_INET;"}, {"sha": "804f448d261c1a12d2231931f528b95188aa6762", "filename": "src/rt/rustrt.def.in", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/61e741cf714020107c6cda12793351fa5b8c7782/src%2Frt%2Frustrt.def.in", "raw_url": "https://github.com/rust-lang/rust/raw/61e741cf714020107c6cda12793351fa5b8c7782/src%2Frt%2Frustrt.def.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frustrt.def.in?ref=61e741cf714020107c6cda12793351fa5b8c7782", "patch": "@@ -106,7 +106,6 @@ rust_uv_tcp_bind\n rust_uv_tcp_connect6\n rust_uv_tcp_bind6\n rust_uv_tcp_getsockname\n-rust_uv_tcp_getsockname6\n rust_uv_tcp_nodelay\n rust_uv_tcp_keepalive\n rust_uv_tcp_simultaneous_accepts\n@@ -119,15 +118,14 @@ rust_uv_udp_recv_start\n rust_uv_udp_recv_stop\n rust_uv_get_udp_handle_from_send_req\n rust_uv_udp_getsockname\n-rust_uv_udp_getsockname6\n rust_uv_udp_set_membership\n rust_uv_udp_set_multicast_loop\n rust_uv_udp_set_multicast_ttl\n rust_uv_udp_set_broadcast\n rust_uv_is_ipv4_sockaddr\n rust_uv_is_ipv6_sockaddr\n-rust_uv_sockaddr_as_sockaddr_in\n-rust_uv_sockaddr_as_sockaddr_in6\n+rust_uv_malloc_sockaddr_storage\n+rust_uv_free_sockaddr_storage\n rust_uv_listen\n rust_uv_accept\n rust_uv_write\n@@ -204,7 +202,6 @@ rust_update_gc_metadata\n rust_uv_ip4_port\n rust_uv_ip6_port\n rust_uv_tcp_getpeername\n-rust_uv_tcp_getpeername6\n linenoise\n linenoiseSetCompletionCallback\n linenoiseAddCompletion\n@@ -267,4 +264,4 @@ rust_drop_global_args_lock\n rust_set_exit_status_newrt\n rust_get_exit_status_newrt\n rust_take_change_dir_lock\n-rust_drop_change_dir_lock\n\\ No newline at end of file\n+rust_drop_change_dir_lock"}]}