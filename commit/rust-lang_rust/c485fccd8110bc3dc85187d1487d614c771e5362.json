{"sha": "c485fccd8110bc3dc85187d1487d614c771e5362", "node_id": "C_kwDOAAsO6NoAKGM0ODVmY2NkODExMGJjM2RjODUxODdkMTQ4N2Q2MTRjNzcxZTUzNjI", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-07-03T16:02:35Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-08-30T17:05:59Z"}, "message": "Remove EntryKind.", "tree": {"sha": "5890fc457e4fb19269ade1cb5ff500bbf5a495f3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5890fc457e4fb19269ade1cb5ff500bbf5a495f3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c485fccd8110bc3dc85187d1487d614c771e5362", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c485fccd8110bc3dc85187d1487d614c771e5362", "html_url": "https://github.com/rust-lang/rust/commit/c485fccd8110bc3dc85187d1487d614c771e5362", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c485fccd8110bc3dc85187d1487d614c771e5362/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "affb12210d4ab5fc914c6b3e7aa81c79a341d502", "url": "https://api.github.com/repos/rust-lang/rust/commits/affb12210d4ab5fc914c6b3e7aa81c79a341d502", "html_url": "https://github.com/rust-lang/rust/commit/affb12210d4ab5fc914c6b3e7aa81c79a341d502"}], "stats": {"total": 180, "additions": 32, "deletions": 148}, "files": [{"sha": "8ebc0c4700e2e5b2391276569d4ca6c24a86796d", "filename": "compiler/rustc_metadata/src/rmeta/decoder.rs", "status": "modified", "additions": 21, "deletions": 35, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/c485fccd8110bc3dc85187d1487d614c771e5362/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c485fccd8110bc3dc85187d1487d614c771e5362/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs?ref=c485fccd8110bc3dc85187d1487d614c771e5362", "patch": "@@ -785,26 +785,11 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n         self.opt_item_ident(item_index, sess).expect(\"no encoded ident for item\")\n     }\n \n-    fn maybe_kind(self, item_id: DefIndex) -> Option<EntryKind> {\n-        self.root.tables.kind.get(self, item_id).map(|k| k.decode(self))\n-    }\n-\n     #[inline]\n     pub(super) fn map_encoded_cnum_to_current(self, cnum: CrateNum) -> CrateNum {\n         if cnum == LOCAL_CRATE { self.cnum } else { self.cnum_map[cnum] }\n     }\n \n-    fn kind(self, item_id: DefIndex) -> EntryKind {\n-        self.maybe_kind(item_id).unwrap_or_else(|| {\n-            bug!(\n-                \"CrateMetadata::kind({:?}): id not found, in crate {:?} with number {}\",\n-                item_id,\n-                self.root.name,\n-                self.cnum,\n-            )\n-        })\n-    }\n-\n     fn def_kind(self, item_id: DefIndex) -> DefKind {\n         self.root.tables.opt_def_kind.get(self, item_id).unwrap_or_else(|| {\n             bug!(\n@@ -856,11 +841,11 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n         )\n     }\n \n-    fn get_variant(self, kind: &EntryKind, index: DefIndex, parent_did: DefId) -> ty::VariantDef {\n+    fn get_variant(self, kind: &DefKind, index: DefIndex, parent_did: DefId) -> ty::VariantDef {\n         let adt_kind = match kind {\n-            EntryKind::Variant => ty::AdtKind::Enum,\n-            EntryKind::Struct => ty::AdtKind::Struct,\n-            EntryKind::Union => ty::AdtKind::Union,\n+            DefKind::Variant => ty::AdtKind::Enum,\n+            DefKind::Struct => ty::AdtKind::Struct,\n+            DefKind::Union => ty::AdtKind::Union,\n             _ => bug!(),\n         };\n \n@@ -896,13 +881,13 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n     }\n \n     fn get_adt_def(self, item_id: DefIndex, tcx: TyCtxt<'tcx>) -> ty::AdtDef<'tcx> {\n-        let kind = self.kind(item_id);\n+        let kind = self.def_kind(item_id);\n         let did = self.local_def_id(item_id);\n \n         let adt_kind = match kind {\n-            EntryKind::Enum => ty::AdtKind::Enum,\n-            EntryKind::Struct => ty::AdtKind::Struct,\n-            EntryKind::Union => ty::AdtKind::Union,\n+            DefKind::Enum => ty::AdtKind::Enum,\n+            DefKind::Struct => ty::AdtKind::Struct,\n+            DefKind::Union => ty::AdtKind::Union,\n             _ => bug!(\"get_adt_def called on a non-ADT {:?}\", did),\n         };\n         let repr = self.root.tables.repr_options.get(self, item_id).unwrap().decode(self);\n@@ -914,7 +899,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n                 .get(self, item_id)\n                 .unwrap_or_else(LazyArray::empty)\n                 .decode(self)\n-                .map(|index| self.get_variant(&self.kind(index), index, did))\n+                .map(|index| self.get_variant(&self.def_kind(index), index, did))\n                 .collect()\n         } else {\n             std::iter::once(self.get_variant(&kind, item_id, did)).collect()\n@@ -1129,10 +1114,10 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n     fn get_associated_item(self, id: DefIndex) -> ty::AssocItem {\n         let name = self.item_name(id);\n \n-        let kind = match self.kind(id) {\n-            EntryKind::AssocConst => ty::AssocKind::Const,\n-            EntryKind::AssocFn => ty::AssocKind::Fn,\n-            EntryKind::AssocType => ty::AssocKind::Type,\n+        let kind = match self.def_kind(id) {\n+            DefKind::AssocConst => ty::AssocKind::Const,\n+            DefKind::AssocFn => ty::AssocKind::Fn,\n+            DefKind::AssocTy => ty::AssocKind::Type,\n             _ => bug!(\"cannot get associated-item of `{:?}`\", self.def_key(id)),\n         };\n         let has_self = self.get_fn_has_self_parameter(id);\n@@ -1149,8 +1134,8 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n     }\n \n     fn get_ctor_def_id_and_kind(self, node_id: DefIndex) -> Option<(DefId, CtorKind)> {\n-        match self.kind(node_id) {\n-            EntryKind::Struct | EntryKind::Variant => {\n+        match self.def_kind(node_id) {\n+            DefKind::Struct | DefKind::Variant => {\n                 let vdata = self.root.tables.variant_data.get(self, node_id).unwrap().decode(self);\n                 vdata.ctor.map(|index| (self.local_def_id(index), vdata.ctor_kind))\n             }\n@@ -1339,18 +1324,19 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n     }\n \n     fn get_macro(self, id: DefIndex, sess: &Session) -> ast::MacroDef {\n-        match self.kind(id) {\n-            EntryKind::MacroDef => {\n+        match self.def_kind(id) {\n+            DefKind::Macro(_) => {\n                 self.root.tables.macro_definition.get(self, id).unwrap().decode((self, sess))\n             }\n             _ => bug!(),\n         }\n     }\n \n     fn is_foreign_item(self, id: DefIndex) -> bool {\n-        match self.kind(id) {\n-            EntryKind::ForeignStatic | EntryKind::ForeignFn => true,\n-            _ => false,\n+        if let Some(parent) = self.def_key(id).parent {\n+            matches!(self.def_kind(parent), DefKind::ForeignMod)\n+        } else {\n+            false\n         }\n     }\n "}, {"sha": "927db8a6ab628d8d1d86001081e079365543ca8b", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 11, "deletions": 78, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/c485fccd8110bc3dc85187d1487d614c771e5362/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c485fccd8110bc3dc85187d1487d614c771e5362/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=c485fccd8110bc3dc85187d1487d614c771e5362", "patch": "@@ -16,7 +16,6 @@ use rustc_hir::def_id::{\n use rustc_hir::definitions::DefPathData;\n use rustc_hir::intravisit::{self, Visitor};\n use rustc_hir::lang_items;\n-use rustc_hir::{AnonConst, GenericParamKind};\n use rustc_middle::hir::nested_filter;\n use rustc_middle::middle::dependency_format::Linkage;\n use rustc_middle::middle::exported_symbols::{\n@@ -1207,7 +1206,6 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         };\n \n         record!(self.tables.variant_data[def_id] <- data);\n-        record!(self.tables.kind[def_id] <- EntryKind::Variant);\n         self.tables.constness.set(def_id.index, hir::Constness::Const);\n         record_array!(self.tables.children[def_id] <- variant.fields.iter().map(|f| {\n             assert!(f.did.is_local());\n@@ -1236,7 +1234,6 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         };\n \n         record!(self.tables.variant_data[def_id] <- data);\n-        record!(self.tables.kind[def_id] <- EntryKind::Variant);\n         self.tables.constness.set(def_id.index, hir::Constness::Const);\n         if variant.ctor_kind == CtorKind::Fn {\n             record!(self.tables.fn_sig[def_id] <- tcx.fn_sig(def_id));\n@@ -1260,7 +1257,6 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         };\n \n         record_array!(self.tables.module_reexports[def_id] <- reexports);\n-        record!(self.tables.kind[def_id] <- EntryKind::Mod);\n         if self.is_proc_macro {\n             // Encode this here because we don't do it in encode_def_ids.\n             record!(self.tables.expn_that_defined[def_id] <- tcx.expn_that_defined(local_def_id));\n@@ -1302,7 +1298,6 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n         record!(self.tables.repr_options[def_id] <- adt_def.repr());\n         record!(self.tables.variant_data[def_id] <- data);\n-        record!(self.tables.kind[def_id] <- EntryKind::Struct);\n         self.tables.constness.set(def_id.index, hir::Constness::Const);\n         if variant.ctor_kind == CtorKind::Fn {\n             record!(self.tables.fn_sig[def_id] <- tcx.fn_sig(def_id));\n@@ -1327,9 +1322,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         self.tables.assoc_container.set(def_id.index, trait_item.container);\n \n         match trait_item.kind {\n-            ty::AssocKind::Const => {\n-                record!(self.tables.kind[def_id] <- EntryKind::AssocConst);\n-            }\n+            ty::AssocKind::Const => {}\n             ty::AssocKind::Fn => {\n                 let hir::TraitItemKind::Fn(m_sig, m) = &ast_item.kind else { bug!() };\n                 match *m {\n@@ -1345,11 +1338,9 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                 if trait_item.fn_has_self_parameter {\n                     self.tables.fn_has_self_parameter.set(def_id.index, ());\n                 }\n-                record!(self.tables.kind[def_id] <- EntryKind::AssocFn );\n             }\n             ty::AssocKind::Type => {\n                 self.encode_explicit_item_bounds(def_id);\n-                record!(self.tables.kind[def_id] <- EntryKind::AssocType);\n             }\n         }\n         if trait_item.kind == ty::AssocKind::Fn {\n@@ -1367,9 +1358,6 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         self.tables.assoc_container.set(def_id.index, impl_item.container);\n \n         match impl_item.kind {\n-            ty::AssocKind::Const => {\n-                record!(self.tables.kind[def_id] <- EntryKind::AssocConst);\n-            }\n             ty::AssocKind::Fn => {\n                 let hir::ImplItemKind::Fn(ref sig, body) = ast_item.kind else { bug!() };\n                 self.tables.asyncness.set(def_id.index, sig.header.asyncness);\n@@ -1384,11 +1372,8 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                 if impl_item.fn_has_self_parameter {\n                     self.tables.fn_has_self_parameter.set(def_id.index, ());\n                 }\n-                record!(self.tables.kind[def_id] <- EntryKind::AssocFn);\n-            }\n-            ty::AssocKind::Type => {\n-                record!(self.tables.kind[def_id] <- EntryKind::AssocType);\n             }\n+            ty::AssocKind::Const | ty::AssocKind::Type => {}\n         }\n         if let Some(trait_item_def_id) = impl_item.trait_item_def_id {\n             self.tables.trait_item_def_id.set(def_id.index, trait_item_def_id.into());\n@@ -1502,33 +1487,24 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n         debug!(\"EncodeContext::encode_info_for_item({:?})\", def_id);\n \n-        let entry_kind = match item.kind {\n-            hir::ItemKind::Static(..) => EntryKind::Static,\n-            hir::ItemKind::Const(..) => EntryKind::Const,\n+        match item.kind {\n             hir::ItemKind::Fn(ref sig, .., body) => {\n                 self.tables.asyncness.set(def_id.index, sig.header.asyncness);\n                 record_array!(self.tables.fn_arg_names[def_id] <- self.tcx.hir().body_param_names(body));\n                 self.tables.constness.set(def_id.index, sig.header.constness);\n-                EntryKind::Fn\n             }\n             hir::ItemKind::Macro(ref macro_def, _) => {\n                 record!(self.tables.macro_definition[def_id] <- macro_def);\n-                EntryKind::MacroDef\n             }\n             hir::ItemKind::Mod(ref m) => {\n                 return self.encode_info_for_mod(item.def_id, m);\n             }\n-            hir::ItemKind::ForeignMod { .. } => EntryKind::ForeignMod,\n-            hir::ItemKind::GlobalAsm(..) => EntryKind::GlobalAsm,\n-            hir::ItemKind::TyAlias(..) => EntryKind::Type,\n             hir::ItemKind::OpaqueTy(..) => {\n                 self.encode_explicit_item_bounds(def_id);\n-                EntryKind::OpaqueTy\n             }\n             hir::ItemKind::Enum(..) => {\n                 let adt_def = self.tcx.adt_def(def_id);\n                 record!(self.tables.repr_options[def_id] <- adt_def.repr());\n-                EntryKind::Enum\n             }\n             hir::ItemKind::Struct(ref struct_def, _) => {\n                 let adt_def = self.tcx.adt_def(def_id);\n@@ -1549,7 +1525,6 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                     ctor,\n                     is_non_exhaustive: variant.is_field_list_non_exhaustive(),\n                 });\n-                EntryKind::Struct\n             }\n             hir::ItemKind::Union(..) => {\n                 let adt_def = self.tcx.adt_def(def_id);\n@@ -1562,7 +1537,6 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                     ctor: None,\n                     is_non_exhaustive: variant.is_field_list_non_exhaustive(),\n                 });\n-                EntryKind::Union\n             }\n             hir::ItemKind::Impl(hir::Impl { defaultness, constness, .. }) => {\n                 self.tables.impl_defaultness.set(def_id.index, *defaultness);\n@@ -1588,26 +1562,24 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n                 let polarity = self.tcx.impl_polarity(def_id);\n                 self.tables.impl_polarity.set(def_id.index, polarity);\n-\n-                EntryKind::Impl\n             }\n             hir::ItemKind::Trait(..) => {\n                 let trait_def = self.tcx.trait_def(def_id);\n                 record!(self.tables.trait_def[def_id] <- trait_def);\n-\n-                EntryKind::Trait\n             }\n             hir::ItemKind::TraitAlias(..) => {\n                 let trait_def = self.tcx.trait_def(def_id);\n                 record!(self.tables.trait_def[def_id] <- trait_def);\n-\n-                EntryKind::TraitAlias\n             }\n             hir::ItemKind::ExternCrate(_) | hir::ItemKind::Use(..) => {\n                 bug!(\"cannot encode info for item {:?}\", item)\n             }\n+            hir::ItemKind::Static(..)\n+            | hir::ItemKind::Const(..)\n+            | hir::ItemKind::ForeignMod { .. }\n+            | hir::ItemKind::GlobalAsm(..)\n+            | hir::ItemKind::TyAlias(..) => {}\n         };\n-        record!(self.tables.kind[def_id] <- entry_kind);\n         // FIXME(eddyb) there should be a nicer way to do this.\n         match item.kind {\n             hir::ItemKind::Enum(..) => record_array!(self.tables.children[def_id] <-\n@@ -1653,8 +1625,6 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         match item.kind {\n             hir::ItemKind::Enum(..) => {\n                 let def = self.tcx.adt_def(item.def_id.to_def_id());\n-                self.encode_fields(def);\n-\n                 for (i, variant) in def.variants().iter_enumerated() {\n                     self.encode_enum_variant_info(def, i);\n \n@@ -1665,18 +1635,12 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             }\n             hir::ItemKind::Struct(ref struct_def, _) => {\n                 let def = self.tcx.adt_def(item.def_id.to_def_id());\n-                self.encode_fields(def);\n-\n                 // If the struct has a constructor, encode it.\n                 if let Some(ctor_hir_id) = struct_def.ctor_hir_id() {\n                     let ctor_def_id = self.tcx.hir().local_def_id(ctor_hir_id);\n                     self.encode_struct_ctor(def, ctor_def_id.to_def_id());\n                 }\n             }\n-            hir::ItemKind::Union(..) => {\n-                let def = self.tcx.adt_def(item.def_id.to_def_id());\n-                self.encode_fields(def);\n-            }\n             hir::ItemKind::Impl { .. } => {\n                 for &trait_item_def_id in\n                     self.tcx.associated_item_def_ids(item.def_id.to_def_id()).iter()\n@@ -1705,26 +1669,18 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             ty::Generator(..) => {\n                 let data = self.tcx.generator_kind(def_id).unwrap();\n                 let generator_diagnostic_data = typeck_result.get_generator_diagnostic_data();\n-                record!(self.tables.kind[def_id.to_def_id()] <- EntryKind::Generator);\n                 record!(self.tables.generator_kind[def_id.to_def_id()] <- data);\n                 record!(self.tables.generator_diagnostic_data[def_id.to_def_id()]  <- generator_diagnostic_data);\n             }\n \n             ty::Closure(_, substs) => {\n-                record!(self.tables.kind[def_id.to_def_id()] <- EntryKind::Closure);\n                 record!(self.tables.fn_sig[def_id.to_def_id()] <- substs.as_closure().sig());\n             }\n \n             _ => bug!(\"closure that is neither generator nor closure\"),\n         }\n     }\n \n-    fn encode_info_for_anon_const(&mut self, id: hir::HirId) {\n-        let def_id = self.tcx.hir().local_def_id(id);\n-        debug!(\"EncodeContext::encode_info_for_anon_const({:?})\", def_id);\n-        record!(self.tables.kind[def_id.to_def_id()] <- EntryKind::AnonConst);\n-    }\n-\n     fn encode_native_libraries(&mut self) -> LazyArray<NativeLib> {\n         empty_proc_macro!(self);\n         let used_libraries = self.tcx.native_libraries(LOCAL_CRATE);\n@@ -1821,7 +1777,6 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                 let def_id = id.to_def_id();\n                 self.tables.opt_def_kind.set(def_id.index, DefKind::Macro(macro_kind));\n                 self.tables.proc_macro.set(def_id.index, macro_kind);\n-                record!(self.tables.kind[def_id] <- EntryKind::ProcMacro);\n                 self.encode_attrs(id);\n                 record!(self.tables.def_keys[def_id] <- def_key);\n                 record!(self.tables.def_ident_span[def_id] <- span);\n@@ -2059,15 +2014,9 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                     hir::Constness::NotConst\n                 };\n                 self.tables.constness.set(def_id.index, constness);\n-                record!(self.tables.kind[def_id] <- EntryKind::ForeignFn);\n                 record!(self.tables.fn_sig[def_id] <- tcx.fn_sig(def_id));\n             }\n-            hir::ForeignItemKind::Static(..) => {\n-                record!(self.tables.kind[def_id] <- EntryKind::ForeignStatic);\n-            }\n-            hir::ForeignItemKind::Type => {\n-                record!(self.tables.kind[def_id] <- EntryKind::ForeignType);\n-            }\n+            hir::ForeignItemKind::Static(..) | hir::ForeignItemKind::Type => {}\n         }\n         if let hir::ForeignItemKind::Fn(..) = nitem.kind {\n             if tcx.is_intrinsic(def_id) {\n@@ -2088,10 +2037,6 @@ impl<'a, 'tcx> Visitor<'tcx> for EncodeContext<'a, 'tcx> {\n         intravisit::walk_expr(self, ex);\n         self.encode_info_for_expr(ex);\n     }\n-    fn visit_anon_const(&mut self, c: &'tcx AnonConst) {\n-        intravisit::walk_anon_const(self, c);\n-        self.encode_info_for_anon_const(c.hir_id);\n-    }\n     fn visit_item(&mut self, item: &'tcx hir::Item<'tcx>) {\n         intravisit::walk_item(self, item);\n         match item.kind {\n@@ -2110,24 +2055,12 @@ impl<'a, 'tcx> Visitor<'tcx> for EncodeContext<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n-    fn encode_fields(&mut self, adt_def: ty::AdtDef<'tcx>) {\n-        for (variant_index, variant) in adt_def.variants().iter_enumerated() {\n-            for (field_index, _field) in variant.fields.iter().enumerate() {\n-                let variant = &adt_def.variant(variant_index);\n-                let field = &variant.fields[field_index];\n-                let def_id = field.did;\n-                debug!(\"EncodeContext::encode_field({:?})\", def_id);\n-                record!(self.tables.kind[def_id] <- EntryKind::Field);\n-            }\n-        }\n-    }\n-\n     fn encode_info_for_generics(&mut self, generics: &hir::Generics<'tcx>) {\n         for param in generics.params {\n             let def_id = self.tcx.hir().local_def_id(param.hir_id);\n             match param.kind {\n-                GenericParamKind::Lifetime { .. } | GenericParamKind::Type { .. } => {}\n-                GenericParamKind::Const { ref default, .. } => {\n+                hir::GenericParamKind::Lifetime { .. } | hir::GenericParamKind::Type { .. } => {}\n+                hir::GenericParamKind::Const { ref default, .. } => {\n                     let def_id = def_id.to_def_id();\n                     if default.is_some() {\n                         record!(self.tables.const_param_default[def_id] <- self.tcx.const_param_default(def_id))"}, {"sha": "04136b6813426f4a4cf5d19c22a3775a6e5d6d0a", "filename": "compiler/rustc_metadata/src/rmeta/mod.rs", "status": "modified", "additions": 0, "deletions": 35, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/c485fccd8110bc3dc85187d1487d614c771e5362/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c485fccd8110bc3dc85187d1487d614c771e5362/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs?ref=c485fccd8110bc3dc85187d1487d614c771e5362", "patch": "@@ -334,7 +334,6 @@ macro_rules! define_tables {\n }\n \n define_tables! {\n-    kind: Table<DefIndex, LazyValue<EntryKind>>,\n     attributes: Table<DefIndex, LazyArray<ast::Attribute>>,\n     children: Table<DefIndex, LazyArray<DefIndex>>,\n \n@@ -402,39 +401,6 @@ define_tables! {\n     module_reexports: Table<DefIndex, LazyArray<ModChild>>,\n }\n \n-#[derive(Copy, Clone, MetadataEncodable, MetadataDecodable)]\n-enum EntryKind {\n-    AnonConst,\n-    Const,\n-    Static,\n-    ForeignStatic,\n-    ForeignMod,\n-    ForeignType,\n-    GlobalAsm,\n-    Type,\n-    TypeParam,\n-    ConstParam,\n-    OpaqueTy,\n-    Enum,\n-    Field,\n-    Variant,\n-    Struct,\n-    Union,\n-    Fn,\n-    ForeignFn,\n-    Mod,\n-    MacroDef,\n-    ProcMacro,\n-    Closure,\n-    Generator,\n-    Trait,\n-    Impl,\n-    AssocFn,\n-    AssocType,\n-    AssocConst,\n-    TraitAlias,\n-}\n-\n #[derive(TyEncodable, TyDecodable)]\n struct VariantData {\n     ctor_kind: CtorKind,\n@@ -466,7 +432,6 @@ pub fn provide(providers: &mut Providers) {\n \n trivially_parameterized_over_tcx! {\n     VariantData,\n-    EntryKind,\n     RawDefId,\n     TraitImpls,\n     IncoherentImpls,"}]}