{"sha": "3717646366a91ee9ca0b574973ec090670f9a4f8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM3MTc2NDYzNjZhOTFlZTljYTBiNTc0OTczZWMwOTA2NzBmOWE0Zjg=", "commit": {"author": {"name": "Yoshua Wuyts", "email": "yoshuawuyts@gmail.com", "date": "2020-07-18T15:11:46Z"}, "committer": {"name": "Yoshua Wuyts", "email": "yoshuawuyts@gmail.com", "date": "2020-10-16T21:36:15Z"}, "message": "Add std::thread::available_concurrency", "tree": {"sha": "d75ffb448c031781280e4b4eeb474c767fd14181", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d75ffb448c031781280e4b4eeb474c767fd14181"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3717646366a91ee9ca0b574973ec090670f9a4f8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3717646366a91ee9ca0b574973ec090670f9a4f8", "html_url": "https://github.com/rust-lang/rust/commit/3717646366a91ee9ca0b574973ec090670f9a4f8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3717646366a91ee9ca0b574973ec090670f9a4f8/comments", "author": {"login": "yoshuawuyts", "id": 2467194, "node_id": "MDQ6VXNlcjI0NjcxOTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/2467194?v=4", "gravatar_id": "", "url": "https://api.github.com/users/yoshuawuyts", "html_url": "https://github.com/yoshuawuyts", "followers_url": "https://api.github.com/users/yoshuawuyts/followers", "following_url": "https://api.github.com/users/yoshuawuyts/following{/other_user}", "gists_url": "https://api.github.com/users/yoshuawuyts/gists{/gist_id}", "starred_url": "https://api.github.com/users/yoshuawuyts/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/yoshuawuyts/subscriptions", "organizations_url": "https://api.github.com/users/yoshuawuyts/orgs", "repos_url": "https://api.github.com/users/yoshuawuyts/repos", "events_url": "https://api.github.com/users/yoshuawuyts/events{/privacy}", "received_events_url": "https://api.github.com/users/yoshuawuyts/received_events", "type": "User", "site_admin": false}, "committer": {"login": "yoshuawuyts", "id": 2467194, "node_id": "MDQ6VXNlcjI0NjcxOTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/2467194?v=4", "gravatar_id": "", "url": "https://api.github.com/users/yoshuawuyts", "html_url": "https://github.com/yoshuawuyts", "followers_url": "https://api.github.com/users/yoshuawuyts/followers", "following_url": "https://api.github.com/users/yoshuawuyts/following{/other_user}", "gists_url": "https://api.github.com/users/yoshuawuyts/gists{/gist_id}", "starred_url": "https://api.github.com/users/yoshuawuyts/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/yoshuawuyts/subscriptions", "organizations_url": "https://api.github.com/users/yoshuawuyts/orgs", "repos_url": "https://api.github.com/users/yoshuawuyts/repos", "events_url": "https://api.github.com/users/yoshuawuyts/events{/privacy}", "received_events_url": "https://api.github.com/users/yoshuawuyts/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a8d6da3f57f9cc85ddbe1d73e72e3523de7ac245", "url": "https://api.github.com/repos/rust-lang/rust/commits/a8d6da3f57f9cc85ddbe1d73e72e3523de7ac245", "html_url": "https://github.com/rust-lang/rust/commit/a8d6da3f57f9cc85ddbe1d73e72e3523de7ac245"}], "stats": {"total": 267, "additions": 166, "deletions": 101}, "files": [{"sha": "4e805e4f599a85239aa3f01b1ec72afa37d2fbfb", "filename": "library/std/src/thread/available_concurrency.rs", "status": "added", "additions": 157, "deletions": 0, "changes": 157, "blob_url": "https://github.com/rust-lang/rust/blob/3717646366a91ee9ca0b574973ec090670f9a4f8/library%2Fstd%2Fsrc%2Fthread%2Favailable_concurrency.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3717646366a91ee9ca0b574973ec090670f9a4f8/library%2Fstd%2Fsrc%2Fthread%2Favailable_concurrency.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fthread%2Favailable_concurrency.rs?ref=3717646366a91ee9ca0b574973ec090670f9a4f8", "patch": "@@ -0,0 +1,157 @@\n+use crate::io;\n+use crate::num::NonZeroUsize;\n+\n+/// Returns the number of hardware threads available to the program.\n+///\n+/// This value should be considered only a hint.\n+///\n+/// # Platform-specific behavior\n+///\n+/// If interpreted as the number of actual hardware threads, it may undercount on\n+/// Windows systems with more than 64 hardware threads. If interpreted as the\n+/// available concurrency for that process, it may overcount on Windows systems\n+/// when limited by a process wide affinity mask or job object limitations, and\n+/// it may overcount on Linux systems when limited by a process wide affinity\n+/// mask or affected by cgroups limits.\n+///\n+/// # Errors\n+///\n+/// This function will return an error in the following situations, but is not\n+/// limited to just these cases:\n+///\n+/// - If the number of hardware threads is not known for the target platform.\n+/// - The process lacks permissions to view the number of hardware threads\n+///   available.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// # #![allow(dead_code)]\n+/// #![feature(available_concurrency)]\n+/// use std::thread;\n+///\n+/// let count = thread::available_concurrency().map(|n| n.get()).unwrap_or(1);\n+/// ```\n+#[unstable(feature = \"available_concurrency\", issue = \"74479\")]\n+pub fn available_concurrency() -> io::Result<NonZeroUsize> {\n+    available_concurrency_internal()\n+}\n+\n+cfg_if::cfg_if! {\n+    if #[cfg(windows)] {\n+        #[allow(nonstandard_style)]\n+        fn available_concurrency_internal() -> io::Result<NonZeroUsize> {\n+            #[repr(C)]\n+            struct SYSTEM_INFO {\n+                wProcessorArchitecture: u16,\n+                wReserved: u16,\n+                dwPageSize: u32,\n+                lpMinimumApplicationAddress: *mut u8,\n+                lpMaximumApplicationAddress: *mut u8,\n+                dwActiveProcessorMask: *mut u8,\n+                dwNumberOfProcessors: u32,\n+                dwProcessorType: u32,\n+                dwAllocationGranularity: u32,\n+                wProcessorLevel: u16,\n+                wProcessorRevision: u16,\n+            }\n+            extern \"system\" {\n+                fn GetSystemInfo(info: *mut SYSTEM_INFO) -> i32;\n+            }\n+            let res = unsafe {\n+                let mut sysinfo = crate::mem::zeroed();\n+                GetSystemInfo(&mut sysinfo);\n+                sysinfo.dwNumberOfProcessors as usize\n+            };\n+            match res {\n+                0 => Err(io::Error::new(io::ErrorKind::NotFound, \"The number of hardware threads is not known for the target platform\")),\n+                cpus => Ok(unsafe { NonZeroUsize::new_unchecked(cpus) }),\n+            }\n+        }\n+    } else if #[cfg(any(\n+        target_os = \"android\",\n+        target_os = \"cloudabi\",\n+        target_os = \"emscripten\",\n+        target_os = \"fuchsia\",\n+        target_os = \"ios\",\n+        target_os = \"linux\",\n+        target_os = \"macos\",\n+        target_os = \"solaris\",\n+        target_os = \"illumos\",\n+    ))] {\n+        fn available_concurrency_internal() -> io::Result<NonZeroUsize> {\n+            match unsafe { libc::sysconf(libc::_SC_NPROCESSORS_ONLN) } {\n+                -1 => Err(io::Error::last_os_error()),\n+                0 => Err(io::Error::new(io::ErrorKind::NotFound, \"The number of hardware threads is not known for the target platform\")),\n+                cpus => Ok(unsafe { NonZeroUsize::new_unchecked(cpus as usize) }),\n+            }\n+        }\n+    } else if #[cfg(any(target_os = \"freebsd\", target_os = \"dragonfly\", target_os = \"netbsd\"))] {\n+        fn available_concurrency_internal() -> io::Result<NonZeroUsize> {\n+            use crate::ptr;\n+\n+            let mut cpus: libc::c_uint = 0;\n+            let mut cpus_size = crate::mem::size_of_val(&cpus);\n+\n+            unsafe {\n+                cpus = libc::sysconf(libc::_SC_NPROCESSORS_ONLN) as libc::c_uint;\n+            }\n+\n+            // Fallback approach in case of errors or no hardware threads.\n+            if cpus < 1 {\n+                let mut mib = [libc::CTL_HW, libc::HW_NCPU, 0, 0];\n+                let res = unsafe {\n+                    libc::sysctl(\n+                        mib.as_mut_ptr(),\n+                        2,\n+                        &mut cpus as *mut _ as *mut _,\n+                        &mut cpus_size as *mut _ as *mut _,\n+                        ptr::null_mut(),\n+                        0,\n+                    )\n+                };\n+\n+                // Handle errors if any.\n+                if res == -1 {\n+                    return Err(io::Error::last_os_error());\n+                } else if cpus == 0 {\n+                    return Err(io::Error::new(io::ErrorKind::NotFound, \"The number of hardware threads is not known for the target platform\"));\n+                }\n+            }\n+            Ok(unsafe { NonZeroUsize::new_unchecked(cpus as usize) })\n+        }\n+    } else if #[cfg(target_os = \"openbsd\")] {\n+        fn available_concurrency_internal() -> io::Result<NonZeroUsize> {\n+            use crate::ptr;\n+\n+            let mut cpus: libc::c_uint = 0;\n+            let mut cpus_size = crate::mem::size_of_val(&cpus);\n+            let mut mib = [libc::CTL_HW, libc::HW_NCPU, 0, 0];\n+\n+            let res = unsafe {\n+                libc::sysctl(\n+                    mib.as_mut_ptr(),\n+                    2,\n+                    &mut cpus as *mut _ as *mut _,\n+                    &mut cpus_size as *mut _ as *mut _,\n+                    ptr::null_mut(),\n+                    0,\n+                )\n+            };\n+\n+            // Handle errors if any.\n+            if res == -1 {\n+                return Err(io::Error::last_os_error());\n+            } else if cpus == 0 {\n+                return Err(io::Error::new(io::ErrorKind::NotFound, \"The number of hardware threads is not known for the target platform\"));\n+            }\n+\n+            Ok(unsafe { NonZeroUsize::new_unchecked(cpus as usize) })\n+        }\n+    } else {\n+        // FIXME: implement on vxWorks, Redox, HermitCore, Haiku, l4re\n+        fn available_concurrency_internal() -> io::Result<NonZeroUsize> {\n+            Err(io::Error::new(io::ErrorKind::NotFound, \"The number of hardware threads is not known for the target platform\"))\n+        }\n+    }\n+}"}, {"sha": "45c10266ba2551a513f830292eb6a821da39d03d", "filename": "library/std/src/thread/mod.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3717646366a91ee9ca0b574973ec090670f9a4f8/library%2Fstd%2Fsrc%2Fthread%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3717646366a91ee9ca0b574973ec090670f9a4f8/library%2Fstd%2Fsrc%2Fthread%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fthread%2Fmod.rs?ref=3717646366a91ee9ca0b574973ec090670f9a4f8", "patch": "@@ -175,9 +175,15 @@ use crate::time::Duration;\n #[macro_use]\n mod local;\n \n+#[unstable(feature = \"available_concurrency\", issue = \"74479\")]\n+mod available_concurrency;\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use self::local::{AccessError, LocalKey};\n \n+#[unstable(feature = \"available_concurrency\", issue = \"74479\")]\n+pub use available_concurrency::available_concurrency;\n+\n // The types used by the thread_local! macro to access TLS keys. Note that there\n // are two types, the \"OS\" type and the \"fast\" type. The OS thread local key\n // type is accessed via platform-specific API calls and is slow, while the fast"}, {"sha": "7e9bd50f5566e04514699476ca85025bdeaae5fa", "filename": "library/test/src/helpers/concurrency.rs", "status": "modified", "additions": 2, "deletions": 101, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/3717646366a91ee9ca0b574973ec090670f9a4f8/library%2Ftest%2Fsrc%2Fhelpers%2Fconcurrency.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3717646366a91ee9ca0b574973ec090670f9a4f8/library%2Ftest%2Fsrc%2Fhelpers%2Fconcurrency.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Ftest%2Fsrc%2Fhelpers%2Fconcurrency.rs?ref=3717646366a91ee9ca0b574973ec090670f9a4f8", "patch": "@@ -1,6 +1,7 @@\n //! Helper module which helps to determine amount of threads to be used\n //! during tests execution.\n use std::env;\n+use std::thread;\n \n #[allow(deprecated)]\n pub fn get_concurrency() -> usize {\n@@ -12,106 +13,6 @@ pub fn get_concurrency() -> usize {\n                 _ => panic!(\"RUST_TEST_THREADS is `{}`, should be a positive integer.\", s),\n             }\n         }\n-        Err(..) => num_cpus(),\n-    }\n-}\n-\n-cfg_if::cfg_if! {\n-    if #[cfg(windows)] {\n-        #[allow(nonstandard_style)]\n-        fn num_cpus() -> usize {\n-            #[repr(C)]\n-            struct SYSTEM_INFO {\n-                wProcessorArchitecture: u16,\n-                wReserved: u16,\n-                dwPageSize: u32,\n-                lpMinimumApplicationAddress: *mut u8,\n-                lpMaximumApplicationAddress: *mut u8,\n-                dwActiveProcessorMask: *mut u8,\n-                dwNumberOfProcessors: u32,\n-                dwProcessorType: u32,\n-                dwAllocationGranularity: u32,\n-                wProcessorLevel: u16,\n-                wProcessorRevision: u16,\n-            }\n-            extern \"system\" {\n-                fn GetSystemInfo(info: *mut SYSTEM_INFO) -> i32;\n-            }\n-            unsafe {\n-                let mut sysinfo = std::mem::zeroed();\n-                GetSystemInfo(&mut sysinfo);\n-                sysinfo.dwNumberOfProcessors as usize\n-            }\n-        }\n-    } else if #[cfg(any(\n-        target_os = \"android\",\n-        target_os = \"cloudabi\",\n-        target_os = \"emscripten\",\n-        target_os = \"fuchsia\",\n-        target_os = \"ios\",\n-        target_os = \"linux\",\n-        target_os = \"macos\",\n-        target_os = \"solaris\",\n-        target_os = \"illumos\",\n-    ))] {\n-        fn num_cpus() -> usize {\n-            unsafe { libc::sysconf(libc::_SC_NPROCESSORS_ONLN) as usize }\n-        }\n-    } else if #[cfg(any(target_os = \"freebsd\", target_os = \"dragonfly\", target_os = \"netbsd\"))] {\n-        fn num_cpus() -> usize {\n-            use std::ptr;\n-\n-            let mut cpus: libc::c_uint = 0;\n-            let mut cpus_size = std::mem::size_of_val(&cpus);\n-\n-            unsafe {\n-                cpus = libc::sysconf(libc::_SC_NPROCESSORS_ONLN) as libc::c_uint;\n-            }\n-            if cpus < 1 {\n-                let mut mib = [libc::CTL_HW, libc::HW_NCPU, 0, 0];\n-                unsafe {\n-                    libc::sysctl(\n-                        mib.as_mut_ptr(),\n-                        2,\n-                        &mut cpus as *mut _ as *mut _,\n-                        &mut cpus_size as *mut _ as *mut _,\n-                        ptr::null_mut(),\n-                        0,\n-                    );\n-                }\n-                if cpus < 1 {\n-                    cpus = 1;\n-                }\n-            }\n-            cpus as usize\n-        }\n-    } else if #[cfg(target_os = \"openbsd\")] {\n-        fn num_cpus() -> usize {\n-            use std::ptr;\n-\n-            let mut cpus: libc::c_uint = 0;\n-            let mut cpus_size = std::mem::size_of_val(&cpus);\n-            let mut mib = [libc::CTL_HW, libc::HW_NCPU, 0, 0];\n-\n-            unsafe {\n-                libc::sysctl(\n-                    mib.as_mut_ptr(),\n-                    2,\n-                    &mut cpus as *mut _ as *mut _,\n-                    &mut cpus_size as *mut _ as *mut _,\n-                    ptr::null_mut(),\n-                    0,\n-                );\n-            }\n-            if cpus < 1 {\n-                cpus = 1;\n-            }\n-            cpus as usize\n-        }\n-    } else {\n-        // FIXME: implement on vxWorks, Redox, HermitCore, Haiku, l4re\n-        fn num_cpus() -> usize {\n-            1\n-        }\n+        Err(..) => thread::available_concurrency().map(|n| n.get()).unwrap_or(1),\n     }\n }"}, {"sha": "9c5bb8957b5480cc02407b52e9db7c9e8cd23f99", "filename": "library/test/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3717646366a91ee9ca0b574973ec090670f9a4f8/library%2Ftest%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3717646366a91ee9ca0b574973ec090670f9a4f8/library%2Ftest%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Ftest%2Fsrc%2Flib.rs?ref=3717646366a91ee9ca0b574973ec090670f9a4f8", "patch": "@@ -24,6 +24,7 @@\n #![feature(rustc_private)]\n #![feature(nll)]\n #![feature(bool_to_option)]\n+#![feature(available_concurrency)]\n #![feature(set_stdio)]\n #![feature(panic_unwind)]\n #![feature(staged_api)]"}]}