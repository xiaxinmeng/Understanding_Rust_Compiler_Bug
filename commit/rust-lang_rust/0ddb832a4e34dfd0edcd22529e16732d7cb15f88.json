{"sha": "0ddb832a4e34dfd0edcd22529e16732d7cb15f88", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBkZGI4MzJhNGUzNGRmZDBlZGNkMjI1MjllMTY3MzJkN2NiMTVmODg=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-02-18T02:16:51Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-02-18T02:16:51Z"}, "message": "Teach trans and llvm to cooperate on producing tidier diagnostic names in trans.ty_str.", "tree": {"sha": "56cb574c4e52b19f4cc7dbca423dd29bcab9b073", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/56cb574c4e52b19f4cc7dbca423dd29bcab9b073"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0ddb832a4e34dfd0edcd22529e16732d7cb15f88", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0ddb832a4e34dfd0edcd22529e16732d7cb15f88", "html_url": "https://github.com/rust-lang/rust/commit/0ddb832a4e34dfd0edcd22529e16732d7cb15f88", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0ddb832a4e34dfd0edcd22529e16732d7cb15f88/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "10befcd9a4d9f68e2dbec84c4a86450a021143fb", "url": "https://api.github.com/repos/rust-lang/rust/commits/10befcd9a4d9f68e2dbec84c4a86450a021143fb", "html_url": "https://github.com/rust-lang/rust/commit/10befcd9a4d9f68e2dbec84c4a86450a021143fb"}], "stats": {"total": 339, "additions": 226, "deletions": 113}, "files": [{"sha": "751507d67443f373c3f40911cf8cca65557c5d4a", "filename": "src/comp/lib/llvm.rs", "status": "modified", "additions": 62, "deletions": 9, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/0ddb832a4e34dfd0edcd22529e16732d7cb15f88/src%2Fcomp%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ddb832a4e34dfd0edcd22529e16732d7cb15f88/src%2Fcomp%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Flib%2Fllvm.rs?ref=0ddb832a4e34dfd0edcd22529e16732d7cb15f88", "patch": "@@ -1151,18 +1151,70 @@ fn mk_type_handle() -> type_handle {\n     ret rec(llth=th, dtor=type_handle_dtor(th));\n }\n \n-fn type_to_str(TypeRef ty) -> str {\n+\n+state obj type_names(std.map.hashmap[TypeRef, str] type_names,\n+                    std.map.hashmap[str, TypeRef] named_types) {\n+\n+    fn associate(str s, TypeRef t) {\n+        check (!named_types.contains_key(s));\n+        check (!type_names.contains_key(t));\n+        type_names.insert(t, s);\n+        named_types.insert(s, t);\n+    }\n+\n+    fn type_has_name(TypeRef t) -> bool {\n+        ret type_names.contains_key(t);\n+    }\n+\n+    fn get_name(TypeRef t) -> str {\n+        ret type_names.get(t);\n+    }\n+\n+    fn name_has_type(str s) -> bool {\n+        ret named_types.contains_key(s);\n+    }\n+\n+    fn get_type(str s) -> TypeRef {\n+        ret named_types.get(s);\n+    }\n+}\n+\n+fn mk_type_names() -> type_names {\n+    auto nt = util.common.new_str_hash[TypeRef]();\n+\n+    fn hash(&TypeRef t) -> uint {\n+        ret t as uint;\n+    }\n+\n+    fn eq(&TypeRef a, &TypeRef b) -> bool {\n+        ret (a as uint) == (b as uint);\n+    }\n+\n+    let std.map.hashfn[TypeRef] hasher = hash;\n+    let std.map.eqfn[TypeRef] eqer = eq;\n+    auto tn = std.map.mk_hashmap[TypeRef,str](hasher, eqer);\n+\n+    ret type_names(tn, nt);\n+}\n+\n+fn type_to_str(type_names names, TypeRef ty) -> str {\n     let vec[TypeRef] v = vec();\n-    ret type_to_str_inner(v, ty);\n+    ret type_to_str_inner(names, v, ty);\n }\n \n-fn type_to_str_inner(vec[TypeRef] outer0, TypeRef ty) -> str {\n+fn type_to_str_inner(type_names names,\n+                     vec[TypeRef] outer0, TypeRef ty) -> str {\n+\n+    if (names.type_has_name(ty)) {\n+        ret names.get_name(ty);\n+    }\n \n     auto outer = outer0 + vec(ty);\n \n     let int kind = llvm.LLVMGetTypeKind(ty);\n \n-    fn tys_str(vec[TypeRef] outer, vec[TypeRef] tys) -> str {\n+    fn tys_str(type_names names,\n+               vec[TypeRef] outer, vec[TypeRef] tys) -> str {\n         let str s = \"\";\n         let bool first = true;\n         for (TypeRef t in tys) {\n@@ -1171,7 +1223,7 @@ fn type_to_str_inner(vec[TypeRef] outer0, TypeRef ty) -> str {\n             } else {\n                 s += \", \";\n             }\n-            s += type_to_str_inner(outer, t);\n+            s += type_to_str_inner(names, outer, t);\n         }\n         ret s;\n     }\n@@ -1200,9 +1252,9 @@ fn type_to_str_inner(vec[TypeRef] outer0, TypeRef ty) -> str {\n             let vec[TypeRef] args =\n                 _vec.init_elt[TypeRef](0 as TypeRef, n_args);\n             llvm.LLVMGetParamTypes(ty, _vec.buf[TypeRef](args));\n-            s += tys_str(outer, args);\n+            s += tys_str(names, outer, args);\n             s += \") -> \";\n-            s += type_to_str_inner(outer, out_ty);\n+            s += type_to_str_inner(names, outer, out_ty);\n             ret s;\n         }\n \n@@ -1212,7 +1264,7 @@ fn type_to_str_inner(vec[TypeRef] outer0, TypeRef ty) -> str {\n             let vec[TypeRef] elts =\n                 _vec.init_elt[TypeRef](0 as TypeRef, n_elts);\n             llvm.LLVMGetStructElementTypes(ty, _vec.buf[TypeRef](elts));\n-            s += tys_str(outer, elts);\n+            s += tys_str(names, outer, elts);\n             s += \"}\";\n             ret s;\n         }\n@@ -1228,7 +1280,8 @@ fn type_to_str_inner(vec[TypeRef] outer0, TypeRef ty) -> str {\n                     ret \"*\\\\\" + util.common.istr(n as int);\n                 }\n             }\n-            ret \"*\" + type_to_str_inner(outer, llvm.LLVMGetElementType(ty));\n+            ret \"*\" + type_to_str_inner(names, outer,\n+                                        llvm.LLVMGetElementType(ty));\n         }\n \n         case (12) { ret \"Opaque\"; }"}, {"sha": "538dfdbe1cf2c9e1792187e3fff2ef2d219b1bd1", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 164, "deletions": 104, "changes": 268, "blob_url": "https://github.com/rust-lang/rust/blob/0ddb832a4e34dfd0edcd22529e16732d7cb15f88/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ddb832a4e34dfd0edcd22529e16732d7cb15f88/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=0ddb832a4e34dfd0edcd22529e16732d7cb15f88", "patch": "@@ -28,9 +28,11 @@ import lib.llvm.llvm;\n import lib.llvm.builder;\n import lib.llvm.target_data;\n import lib.llvm.type_handle;\n+import lib.llvm.type_names;\n import lib.llvm.mk_pass_manager;\n import lib.llvm.mk_target_data;\n import lib.llvm.mk_type_handle;\n+import lib.llvm.mk_type_names;\n import lib.llvm.llvm.ModuleRef;\n import lib.llvm.llvm.ValueRef;\n import lib.llvm.llvm.TypeRef;\n@@ -64,6 +66,7 @@ type tag_info = rec(type_handle th,\n state type crate_ctxt = rec(session.session sess,\n                             ModuleRef llmod,\n                             target_data td,\n+                            type_names tn,\n                             ValueRef crate_ptr,\n                             hashmap[str, ValueRef] upcalls,\n                             hashmap[str, ValueRef] intrinsics,\n@@ -133,16 +136,16 @@ fn res(@block_ctxt bcx, ValueRef val) -> result {\n             mutable val = val);\n }\n \n-fn ty_str(TypeRef t) -> str {\n-    ret lib.llvm.type_to_str(t);\n+fn ty_str(type_names tn, TypeRef t) -> str {\n+    ret lib.llvm.type_to_str(tn, t);\n }\n \n fn val_ty(ValueRef v) -> TypeRef {\n     ret llvm.LLVMTypeOf(v);\n }\n \n-fn val_str(ValueRef v) -> str {\n-    ret ty_str(val_ty(v));\n+fn val_str(type_names tn, ValueRef v) -> str {\n+    ret ty_str(tn, val_ty(v));\n }\n \n \n@@ -215,9 +218,9 @@ fn T_fn(vec[TypeRef] inputs, TypeRef output) -> TypeRef {\n                               False);\n }\n \n-fn T_fn_pair(TypeRef tfn) -> TypeRef {\n+fn T_fn_pair(type_names tn, TypeRef tfn) -> TypeRef {\n     ret T_struct(vec(T_ptr(tfn),\n-                     T_opaque_closure_ptr()));\n+                     T_opaque_closure_ptr(tn)));\n }\n \n fn T_ptr(TypeRef t) -> TypeRef {\n@@ -234,34 +237,55 @@ fn T_opaque() -> TypeRef {\n     ret llvm.LLVMOpaqueType();\n }\n \n-fn T_task() -> TypeRef {\n-    ret T_struct(vec(T_int(),      // Refcount\n-                     T_int(),      // Delegate pointer\n-                     T_int(),      // Stack segment pointer\n-                     T_int(),      // Runtime SP\n-                     T_int(),      // Rust SP\n-                     T_int(),      // GC chain\n-                     T_int(),      // Domain pointer\n-                     T_int()       // Crate cache pointer\n-                     ));\n+fn T_task(type_names tn) -> TypeRef {\n+    auto s = \"task\";\n+    if (tn.name_has_type(s)) {\n+        ret tn.get_type(s);\n+    }\n+\n+    auto t = T_struct(vec(T_int(),      // Refcount\n+                          T_int(),      // Delegate pointer\n+                          T_int(),      // Stack segment pointer\n+                          T_int(),      // Runtime SP\n+                          T_int(),      // Rust SP\n+                          T_int(),      // GC chain\n+                          T_int(),      // Domain pointer\n+                          T_int()       // Crate cache pointer\n+                          ));\n+    tn.associate(s, t);\n+    ret t;\n }\n \n-fn T_glue_fn() -> TypeRef {\n+fn T_glue_fn(type_names tn) -> TypeRef {\n+    auto s = \"glue_fn\";\n+    if (tn.name_has_type(s)) {\n+        ret tn.get_type(s);\n+    }\n+\n     // Bit of a kludge: pick the fn typeref out of the tydesc..\n     let vec[TypeRef] tydesc_elts = _vec.init_elt[TypeRef](T_nil(), 10u);\n-    llvm.LLVMGetStructElementTypes(T_tydesc(),\n+    llvm.LLVMGetStructElementTypes(T_tydesc(tn),\n                                    _vec.buf[TypeRef](tydesc_elts));\n-    ret llvm.LLVMGetElementType(tydesc_elts.(abi.tydesc_field_drop_glue_off));\n+    auto t =\n+        llvm.LLVMGetElementType\n+        (tydesc_elts.(abi.tydesc_field_drop_glue_off));\n+    tn.associate(s, t);\n+    ret t;\n }\n \n-fn T_tydesc() -> TypeRef {\n+fn T_tydesc(type_names tn) -> TypeRef {\n+\n+    auto s = \"tydesc\";\n+    if (tn.name_has_type(s)) {\n+        ret tn.get_type(s);\n+    }\n \n     auto th = mk_type_handle();\n     auto abs_tydesc = llvm.LLVMResolveTypeHandle(th.llth);\n     auto tydescpp = T_ptr(T_ptr(abs_tydesc));\n     auto pvoid = T_ptr(T_i8());\n     auto glue_fn_ty = T_ptr(T_fn(vec(T_ptr(T_nil()),\n-                                     T_taskptr(),\n+                                     T_taskptr(tn),\n                                      T_ptr(T_nil()),\n                                      tydescpp,\n                                      pvoid), T_void()));\n@@ -277,7 +301,9 @@ fn T_tydesc() -> TypeRef {\n                                glue_fn_ty));      // is_stateful\n \n     llvm.LLVMRefineType(abs_tydesc, tydesc);\n-    ret llvm.LLVMResolveTypeHandle(th.llth);\n+    auto t = llvm.LLVMResolveTypeHandle(th.llth);\n+    tn.associate(s, t);\n+    ret t;\n }\n \n fn T_array(TypeRef t, uint n) -> TypeRef {\n@@ -300,67 +326,90 @@ fn T_box(TypeRef t) -> TypeRef {\n     ret T_struct(vec(T_int(), t));\n }\n \n-fn T_crate() -> TypeRef {\n-    ret T_struct(vec(T_int(),      // ptrdiff_t image_base_off\n-                     T_int(),      // uintptr_t self_addr\n-                     T_int(),      // ptrdiff_t debug_abbrev_off\n-                     T_int(),      // size_t debug_abbrev_sz\n-                     T_int(),      // ptrdiff_t debug_info_off\n-                     T_int(),      // size_t debug_info_sz\n-                     T_int(),      // size_t activate_glue_off\n-                     T_int(),      // size_t yield_glue_off\n-                     T_int(),      // size_t unwind_glue_off\n-                     T_int(),      // size_t gc_glue_off\n-                     T_int(),      // size_t main_exit_task_glue_off\n-                     T_int(),      // int n_rust_syms\n-                     T_int(),      // int n_c_syms\n-                     T_int()       // int n_libs\n-                     ));\n+fn T_crate(type_names tn) -> TypeRef {\n+    auto s = \"crate\";\n+    if (tn.name_has_type(s)) {\n+        ret tn.get_type(s);\n+    }\n+\n+    auto t = T_struct(vec(T_int(),      // ptrdiff_t image_base_off\n+                          T_int(),      // uintptr_t self_addr\n+                          T_int(),      // ptrdiff_t debug_abbrev_off\n+                          T_int(),      // size_t debug_abbrev_sz\n+                          T_int(),      // ptrdiff_t debug_info_off\n+                          T_int(),      // size_t debug_info_sz\n+                          T_int(),      // size_t activate_glue_off\n+                          T_int(),      // size_t yield_glue_off\n+                          T_int(),      // size_t unwind_glue_off\n+                          T_int(),      // size_t gc_glue_off\n+                          T_int(),      // size_t main_exit_task_glue_off\n+                          T_int(),      // int n_rust_syms\n+                          T_int(),      // int n_c_syms\n+                          T_int()       // int n_libs\n+                          ));\n+    tn.associate(s, t);\n+    ret t;\n }\n \n fn T_double() -> TypeRef {\n     ret llvm.LLVMDoubleType();\n }\n \n-fn T_taskptr() -> TypeRef {\n-    ret T_ptr(T_task());\n+fn T_taskptr(type_names tn) -> TypeRef {\n+    ret T_ptr(T_task(tn));\n }\n \n-fn T_typaram_ptr() -> TypeRef {\n-    ret T_ptr(T_i8());\n+fn T_typaram_ptr(type_names tn) -> TypeRef {\n+    auto s = \"typaram\";\n+    if (tn.name_has_type(s)) {\n+        ret tn.get_type(s);\n+    }\n+\n+    auto t = T_ptr(T_i8());\n+    tn.associate(s, t);\n+    ret t;\n }\n \n-fn T_closure_ptr(TypeRef lltarget_ty,\n+fn T_closure_ptr(type_names tn,\n+                 TypeRef lltarget_ty,\n                  TypeRef llbindings_ty) -> TypeRef {\n-    ret T_ptr(T_box(T_struct(vec(T_ptr(T_tydesc()),\n+    ret T_ptr(T_box(T_struct(vec(T_ptr(T_tydesc(tn)),\n                                  lltarget_ty,\n                                  llbindings_ty)\n                              // FIXME: add captured typarams.\n                              )));\n }\n \n-fn T_opaque_closure_ptr() -> TypeRef {\n-    ret T_closure_ptr(T_struct(vec(T_ptr(T_nil()),\n-                                   T_ptr(T_nil()))),\n-                      T_nil());\n+fn T_opaque_closure_ptr(type_names tn) -> TypeRef {\n+    auto s = \"*closure\";\n+    if (tn.name_has_type(s)) {\n+        ret tn.get_type(s);\n+    }\n+    auto t = T_closure_ptr(tn, T_struct(vec(T_ptr(T_nil()),\n+                                            T_ptr(T_nil()))),\n+                           T_nil());\n+    tn.associate(s, t);\n+    ret t;\n }\n \n-fn T_captured_tydescs(uint n) -> TypeRef {\n-    ret T_struct(_vec.init_elt[TypeRef](T_ptr(T_tydesc()), n));\n+fn T_captured_tydescs(type_names tn, uint n) -> TypeRef {\n+    ret T_struct(_vec.init_elt[TypeRef](T_ptr(T_tydesc(tn)), n));\n }\n \n-fn T_obj(uint n_captured_tydescs, TypeRef llfields_ty) -> TypeRef {\n-    ret T_struct(vec(T_ptr(T_tydesc()),\n-                     T_captured_tydescs(n_captured_tydescs),\n+fn T_obj(type_names tn, uint n_captured_tydescs,\n+         TypeRef llfields_ty) -> TypeRef {\n+    ret T_struct(vec(T_ptr(T_tydesc(tn)),\n+                     T_captured_tydescs(tn, n_captured_tydescs),\n                      llfields_ty));\n }\n \n-fn T_obj_ptr(uint n_captured_tydescs, TypeRef llfields_ty) -> TypeRef {\n-    ret T_ptr(T_box(T_obj(n_captured_tydescs, llfields_ty)));\n+fn T_obj_ptr(type_names tn, uint n_captured_tydescs,\n+             TypeRef llfields_ty) -> TypeRef {\n+    ret T_ptr(T_box(T_obj(tn, n_captured_tydescs, llfields_ty)));\n }\n \n-fn T_opaque_obj_ptr() -> TypeRef {\n-    ret T_obj_ptr(0u, T_nil());\n+fn T_opaque_obj_ptr(type_names tn) -> TypeRef {\n+    ret T_obj_ptr(tn, 0u, T_nil());\n }\n \n \n@@ -377,7 +426,7 @@ fn type_of_explicit_args(@crate_ctxt cx,\n     for (ty.arg arg in inputs) {\n         if (ty.type_has_dynamic_size(arg.ty)) {\n             check (arg.mode == ast.alias);\n-            atys += T_typaram_ptr();\n+            atys += T_typaram_ptr(cx.tn);\n         } else {\n             let TypeRef t = type_of(cx, arg.ty);\n             alt (arg.mode) {\n@@ -409,13 +458,13 @@ fn type_of_fn_full(@crate_ctxt cx,\n \n     // Arg 0: Output pointer.\n     if (ty.type_has_dynamic_size(output)) {\n-        atys += T_typaram_ptr();\n+        atys += T_typaram_ptr(cx.tn);\n     } else {\n         atys += T_ptr(type_of(cx, output));\n     }\n \n     // Arg 1: Task pointer.\n-    atys += T_taskptr();\n+    atys += T_taskptr(cx.tn);\n \n     // Arg 2: Env (closure-bindings / self-obj)\n     alt (obj_self) {\n@@ -424,7 +473,7 @@ fn type_of_fn_full(@crate_ctxt cx,\n             atys += t;\n         }\n         case (_) {\n-            atys += T_opaque_closure_ptr();\n+            atys += T_opaque_closure_ptr(cx.tn);\n         }\n     }\n \n@@ -434,7 +483,7 @@ fn type_of_fn_full(@crate_ctxt cx,\n             ty.count_ty_params(plain_ty(ty.ty_fn(inputs, output)));\n         auto i = 0u;\n         while (i < ty_param_count) {\n-            atys += T_ptr(T_tydesc());\n+            atys += T_ptr(T_tydesc(cx.tn));\n             i += 1u;\n         }\n     }\n@@ -443,7 +492,8 @@ fn type_of_fn_full(@crate_ctxt cx,\n         // If it's an iter, the 'output' type of the iter is actually the\n         // *input* type of the function we're given as our iter-block\n         // argument.\n-        atys += T_fn_pair(type_of_fn_full(cx, false, none[TypeRef],\n+        atys += T_fn_pair(cx.tn,\n+                          type_of_fn_full(cx, false, none[TypeRef],\n                                           vec(rec(mode=ast.val, ty=output)),\n                                           plain_ty(ty.ty_nil)));\n     }\n@@ -515,10 +565,10 @@ fn type_of_inner(@crate_ctxt cx, @ty.t t) -> TypeRef {\n         }\n         case (ty.ty_fn(?args, ?out)) {\n             // FIXME: put iter in ty_fn.\n-            ret T_fn_pair(type_of_fn(cx, false, args, out));\n+            ret T_fn_pair(cx.tn, type_of_fn(cx, false, args, out));\n         }\n         case (ty.ty_native_fn(?args, ?out)) {\n-            ret T_fn_pair(type_of_native_fn(cx, args, out));\n+            ret T_fn_pair(cx.tn, type_of_native_fn(cx, args, out));\n         }\n         case (ty.ty_obj(?meths)) {\n             auto th = mk_type_handle();\n@@ -536,7 +586,7 @@ fn type_of_inner(@crate_ctxt cx, @ty.t t) -> TypeRef {\n             }\n             let TypeRef vtbl = T_struct(mtys);\n             let TypeRef pair = T_struct(vec(T_ptr(vtbl),\n-                                            T_opaque_obj_ptr()));\n+                                            T_opaque_obj_ptr(cx.tn)));\n \n             auto abs_pair = llvm.LLVMResolveTypeHandle(th.llth);\n             llvm.LLVMRefineType(abs_pair, pair);\n@@ -548,9 +598,9 @@ fn type_of_inner(@crate_ctxt cx, @ty.t t) -> TypeRef {\n             fail;\n         }\n         case (ty.ty_param(_)) {\n-            ret T_typaram_ptr();\n+            ret T_typaram_ptr(cx.tn);\n         }\n-        case (ty.ty_type) { ret T_ptr(T_tydesc()); }\n+        case (ty.ty_type) { ret T_ptr(T_tydesc(cx.tn)); }\n     }\n     fail;\n }\n@@ -686,19 +736,19 @@ fn decl_fastcall_fn(ModuleRef llmod, str name, TypeRef llty) -> ValueRef {\n     ret decl_fn(llmod, name, lib.llvm.LLVMFastCallConv, llty);\n }\n \n-fn decl_glue(ModuleRef llmod, str s) -> ValueRef {\n-    ret decl_cdecl_fn(llmod, s, T_fn(vec(T_taskptr()), T_void()));\n+fn decl_glue(ModuleRef llmod, type_names tn, str s) -> ValueRef {\n+    ret decl_cdecl_fn(llmod, s, T_fn(vec(T_taskptr(tn)), T_void()));\n }\n \n-fn decl_upcall_glue(ModuleRef llmod, uint _n) -> ValueRef {\n+fn decl_upcall_glue(ModuleRef llmod, type_names tn, uint _n) -> ValueRef {\n     // It doesn't actually matter what type we come up with here, at the\n     // moment, as we cast the upcall function pointers to int before passing\n     // them to the indirect upcall-invocation glue.  But eventually we'd like\n     // to call them directly, once we have a calling convention worked out.\n     let int n = _n as int;\n     let str s = abi.upcall_glue_name(n);\n     let vec[TypeRef] args =\n-        vec(T_taskptr(), // taskptr\n+        vec(T_taskptr(tn), // taskptr\n             T_int())     // callee\n         + _vec.init_elt[TypeRef](T_int(), n as uint);\n \n@@ -709,7 +759,7 @@ fn get_upcall(@crate_ctxt cx, str name, int n_args) -> ValueRef {\n     if (cx.upcalls.contains_key(name)) {\n         ret cx.upcalls.get(name);\n     }\n-    auto inputs = vec(T_taskptr());\n+    auto inputs = vec(T_taskptr(cx.tn));\n     inputs += _vec.init_elt[TypeRef](T_int(), n_args as uint);\n     auto output = T_int();\n     auto f = decl_cdecl_fn(cx.llmod, name, T_fn(inputs, output));\n@@ -1064,7 +1114,8 @@ fn get_tydesc(&@block_ctxt cx, @ty.t t) -> result {\n \n         auto root = cx.fcx.ccx.tydescs.get(t);\n \n-        auto tydescs = cx.build.Alloca(T_array(T_ptr(T_tydesc()), n_params));\n+        auto tydescs = cx.build.Alloca(T_array(T_ptr(T_tydesc(cx.fcx.ccx.tn)),\n+                                               n_params));\n \n         auto i = 0;\n         auto tdp = cx.build.GEP(tydescs, vec(C_int(0), C_int(i)));\n@@ -1089,7 +1140,8 @@ fn get_tydesc(&@block_ctxt cx, @ty.t t) -> result {\n                                   C_int((1u + n_params) as int),\n                                   bcx.build.PtrToInt(tydescs, T_int())));\n \n-        ret res(v.bcx, v.bcx.build.IntToPtr(v.val, T_ptr(T_tydesc())));\n+        ret res(v.bcx, v.bcx.build.IntToPtr(v.val,\n+                                            T_ptr(T_tydesc(cx.fcx.ccx.tn))));\n     }\n \n     // Otherwise, generate a tydesc if necessary, and return it.\n@@ -1107,7 +1159,7 @@ fn make_tydesc(@crate_ctxt cx, @ty.t t, vec[ast.def_id] typaram_defs) {\n     auto drop_glue = make_generic_glue(cx, t, \"drop\", dg, typaram_defs);\n \n     auto llty = type_of(cx, t);\n-    auto glue_fn_ty = T_ptr(T_glue_fn());\n+    auto glue_fn_ty = T_ptr(T_glue_fn(cx.tn));\n \n     // FIXME: this adjustment has to do with the ridiculous encoding of\n     // glue-pointer-constants in the tydesc records: They are tydesc-relative\n@@ -1120,8 +1172,9 @@ fn make_tydesc(@crate_ctxt cx, @ty.t t, vec[ast.def_id] typaram_defs) {\n     }\n \n     auto name = sanitize(cx.names.next(\"tydesc_\" + ty.ty_to_str(t)));\n-    auto gvar = llvm.LLVMAddGlobal(cx.llmod, T_tydesc(), _str.buf(name));\n-    auto tydesc = C_struct(vec(C_null(T_ptr(T_ptr(T_tydesc()))),\n+    auto gvar = llvm.LLVMAddGlobal(cx.llmod, T_tydesc(cx.tn),\n+                                   _str.buf(name));\n+    auto tydesc = C_struct(vec(C_null(T_ptr(T_ptr(T_tydesc(cx.tn)))),\n                                llsize_of(llty),\n                                llalign_of(llty),\n                                off(gvar, take_glue),  // take_glue_off\n@@ -1142,7 +1195,7 @@ fn make_tydesc(@crate_ctxt cx, @ty.t t, vec[ast.def_id] typaram_defs) {\n fn make_generic_glue(@crate_ctxt cx, @ty.t t, str name,\n                      val_and_ty_fn helper,\n                      vec[ast.def_id] typaram_defs) -> ValueRef {\n-    auto llfnty = T_glue_fn();\n+    auto llfnty = T_glue_fn(cx.tn);\n \n     auto fn_name = cx.names.next(\"_rust_\" + name) + sep() + ty.ty_to_str(t);\n     fn_name = sanitize(fn_name);\n@@ -2793,7 +2846,8 @@ fn trans_bind(@block_ctxt cx, @ast.expr f,\n             let @ty.t bindings_ty = plain_ty(ty.ty_tup(bound_tys));\n             let TypeRef lltarget_ty = type_of(bcx.fcx.ccx, ty.expr_ty(f));\n             let TypeRef llbindings_ty = type_of(bcx.fcx.ccx, bindings_ty);\n-            let TypeRef llclosure_ty = T_closure_ptr(lltarget_ty,\n+            let TypeRef llclosure_ty = T_closure_ptr(cx.fcx.ccx.tn,\n+                                                     lltarget_ty,\n                                                      llbindings_ty);\n \n             // Malloc a box for the body.\n@@ -2854,9 +2908,11 @@ fn trans_bind(@block_ctxt cx, @ast.expr f,\n             auto pair_box = bcx.build.GEP(pair_v,\n                                           vec(C_int(0),\n                                               C_int(abi.fn_field_box)));\n-            bcx.build.Store(bcx.build.PointerCast(box,\n-                                                  T_opaque_closure_ptr()),\n-                            pair_box);\n+            bcx.build.Store\n+                (bcx.build.PointerCast\n+                 (box,\n+                  T_opaque_closure_ptr(bcx.fcx.ccx.tn)),\n+                 pair_box);\n \n             find_scope_cx(cx).cleanups +=\n                 clean(bind drop_slot(_, pair_v, pair_ty));\n@@ -2903,7 +2959,8 @@ fn trans_args(@block_ctxt cx,\n         }\n     }\n     if (ty.type_has_dynamic_size(retty)) {\n-        llargs += bcx.build.PointerCast(llretslot, T_typaram_ptr());\n+        llargs += bcx.build.PointerCast(llretslot,\n+                                        T_typaram_ptr(cx.fcx.ccx.tn));\n     } else if (ty.count_ty_params(retty) != 0u) {\n         // It's possible that the callee has some generic-ness somewhere in\n         // its return value -- say a method signature within an obj or a fn\n@@ -2979,7 +3036,8 @@ fn trans_args(@block_ctxt cx,\n         }\n \n         if (ty.type_has_dynamic_size(args.(i).ty)) {\n-            val = bcx.build.PointerCast(val, T_typaram_ptr());\n+            val = bcx.build.PointerCast(val,\n+                                        T_typaram_ptr(cx.fcx.ccx.tn));\n         }\n \n         llargs += val;\n@@ -2993,7 +3051,7 @@ fn trans_call(@block_ctxt cx, @ast.expr f,\n               vec[@ast.expr] args, &ast.ann ann) -> result {\n     auto f_res = trans_lval(cx, f);\n     auto faddr = f_res.res.val;\n-    auto llenv = C_null(T_opaque_closure_ptr());\n+    auto llenv = C_null(T_opaque_closure_ptr(cx.fcx.ccx.tn));\n \n     alt (f_res.llobj) {\n         case (some[ValueRef](_)) {\n@@ -3036,7 +3094,6 @@ fn trans_call(@block_ctxt cx, @ast.expr f,\n         find_scope_cx(cx).cleanups += clean(bind drop_ty(_, retval, ret_ty));\n     }\n \n-    // log \"call-result type: \" + val_str(retval);\n     ret res(bcx, retval);\n }\n \n@@ -3767,7 +3824,7 @@ fn populate_fn_ctxt_from_llself(@block_ctxt cx, ValueRef llself) {\n     }\n \n     auto n_typarams = _vec.len[ast.ty_param](cx.fcx.ccx.obj_typarams);\n-    let TypeRef llobj_box_ty = T_obj_ptr(n_typarams,\n+    let TypeRef llobj_box_ty = T_obj_ptr(cx.fcx.ccx.tn, n_typarams,\n                                          T_struct(llfield_tys));\n \n     auto box_cell =\n@@ -3925,7 +3982,7 @@ fn trans_obj(@crate_ctxt cx, &ast._obj ob, ast.def_id oid,\n                                       C_int(abi.obj_field_box)));\n     bcx.build.Store(vtbl, pair_vtbl);\n \n-    let TypeRef llbox_ty = T_opaque_obj_ptr();\n+    let TypeRef llbox_ty = T_opaque_obj_ptr(cx.tn);\n \n     if (_vec.len[ast.ty_param](ty_params) == 0u &&\n         _vec.len[ty.arg](arg_tys) == 0u) {\n@@ -4175,7 +4232,7 @@ fn decl_fn_and_pair(@crate_ctxt cx,\n     let ValueRef gvar = llvm.LLVMAddGlobal(cx.llmod, llpairty,\n                                            _str.buf(ps));\n     auto pair = C_struct(vec(llfn,\n-                             C_null(T_opaque_closure_ptr())));\n+                             C_null(T_opaque_closure_ptr(cx.tn))));\n \n     llvm.LLVMSetInitializer(gvar, pair);\n     llvm.LLVMSetGlobalConstant(gvar, True);\n@@ -4438,7 +4495,7 @@ fn trans_exit_task_glue(@crate_ctxt cx) {\n     let ValueRef lltaskptr = llvm.LLVMGetParam(llfn, 0u);\n     auto fcx = @rec(llfn=llfn,\n                     lltaskptr=lltaskptr,\n-                    llenv=C_null(T_opaque_closure_ptr()),\n+                    llenv=C_null(T_opaque_closure_ptr(cx.tn)),\n                     llretptr=C_null(T_ptr(T_nil())),\n                     mutable llself=none[ValueRef],\n                     mutable lliterbody=none[ValueRef],\n@@ -4454,9 +4511,9 @@ fn trans_exit_task_glue(@crate_ctxt cx) {\n }\n \n fn create_typedefs(@crate_ctxt cx) {\n-    llvm.LLVMAddTypeName(cx.llmod, _str.buf(\"rust_crate\"), T_crate());\n-    llvm.LLVMAddTypeName(cx.llmod, _str.buf(\"rust_task\"), T_task());\n-    llvm.LLVMAddTypeName(cx.llmod, _str.buf(\"rust_tydesc\"), T_tydesc());\n+    llvm.LLVMAddTypeName(cx.llmod, _str.buf(\"crate\"), T_crate(cx.tn));\n+    llvm.LLVMAddTypeName(cx.llmod, _str.buf(\"task\"), T_task(cx.tn));\n+    llvm.LLVMAddTypeName(cx.llmod, _str.buf(\"tydesc\"), T_tydesc(cx.tn));\n }\n \n fn create_crate_constant(@crate_ctxt cx) {\n@@ -4568,8 +4625,8 @@ fn check_module(ModuleRef llmod) {\n     // TODO: run the linter here also, once there are llvm-c bindings for it.\n }\n \n-fn make_no_op_type_glue(ModuleRef llmod) -> ValueRef {\n-    auto ty = T_fn(vec(T_taskptr(), T_ptr(T_i8())), T_void());\n+fn make_no_op_type_glue(ModuleRef llmod, type_names tn) -> ValueRef {\n+    auto ty = T_fn(vec(T_taskptr(tn), T_ptr(T_i8())), T_void());\n     auto fun = decl_fastcall_fn(llmod, abi.no_op_type_glue_name(), ty);\n     auto bb_name = _str.buf(\"_rust_no_op_type_glue_bb\");\n     auto llbb = llvm.LLVMAppendBasicBlock(fun, bb_name);\n@@ -4663,9 +4720,9 @@ fn make_bzero_glue(ModuleRef llmod) -> ValueRef {\n     ret fun;\n }\n \n-fn make_glues(ModuleRef llmod) -> @glue_fns {\n-    ret @rec(activate_glue = decl_glue(llmod, abi.activate_glue_name()),\n-             yield_glue = decl_glue(llmod, abi.yield_glue_name()),\n+fn make_glues(ModuleRef llmod, type_names tn) -> @glue_fns {\n+    ret @rec(activate_glue = decl_glue(llmod, tn, abi.activate_glue_name()),\n+             yield_glue = decl_glue(llmod, tn, abi.yield_glue_name()),\n              /*\n               * Note: the signature passed to decl_cdecl_fn here looks unusual\n               * because it is. It corresponds neither to an upcall signature\n@@ -4677,12 +4734,13 @@ fn make_glues(ModuleRef llmod) -> @glue_fns {\n               * this is the signature required to retrieve it.\n               */\n              exit_task_glue = decl_cdecl_fn(llmod, abi.exit_task_glue_name(),\n-                                            T_fn(vec(T_taskptr()), T_void())),\n+                                            T_fn(vec(T_taskptr(tn)),\n+                                                 T_void())),\n \n              upcall_glues =\n-             _vec.init_fn[ValueRef](bind decl_upcall_glue(llmod, _),\n+             _vec.init_fn[ValueRef](bind decl_upcall_glue(llmod, tn, _),\n                                     abi.n_upcall_glues as uint),\n-             no_op_type_glue = make_no_op_type_glue(llmod),\n+             no_op_type_glue = make_no_op_type_glue(llmod, tn),\n              memcpy_glue = make_memcpy_glue(llmod),\n              bzero_glue = make_bzero_glue(llmod));\n }\n@@ -4696,14 +4754,15 @@ fn trans_crate(session.session sess, @ast.crate crate, str output,\n     llvm.LLVMSetDataLayout(llmod, _str.buf(x86.get_data_layout()));\n     llvm.LLVMSetTarget(llmod, _str.buf(x86.get_target_triple()));\n     auto td = mk_target_data(x86.get_data_layout());\n+    auto tn = mk_type_names();\n     let ValueRef crate_ptr =\n-        llvm.LLVMAddGlobal(llmod, T_crate(), _str.buf(\"rust_crate\"));\n+        llvm.LLVMAddGlobal(llmod, T_crate(tn), _str.buf(\"rust_crate\"));\n \n     llvm.LLVMSetModuleInlineAsm(llmod, _str.buf(x86.get_module_asm()));\n \n     auto intrinsics = declare_intrinsics(llmod);\n \n-    auto glues = make_glues(llmod);\n+    auto glues = make_glues(llmod, tn);\n     auto hasher = ty.hash_ty;\n     auto eqer = ty.eq_ty;\n     auto tydescs = map.mk_hashmap[@ty.t,ValueRef](hasher, eqer);\n@@ -4713,6 +4772,7 @@ fn trans_crate(session.session sess, @ast.crate crate, str output,\n     auto cx = @rec(sess = sess,\n                    llmod = llmod,\n                    td = td,\n+                   tn = tn,\n                    crate_ptr = crate_ptr,\n                    upcalls = new_str_hash[ValueRef](),\n                    intrinsics = intrinsics,"}]}