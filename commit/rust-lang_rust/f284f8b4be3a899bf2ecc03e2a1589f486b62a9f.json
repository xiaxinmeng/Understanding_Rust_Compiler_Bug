{"sha": "f284f8b4be3a899bf2ecc03e2a1589f486b62a9f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYyODRmOGI0YmUzYTg5OWJmMmVjYzAzZTJhMTU4OWY0ODZiNjJhOWY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-12-12T02:11:31Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-12-12T02:11:31Z"}, "message": "Auto merge of #67246 - JohnTitor:rollup-nfa7skn, r=JohnTitor\n\nRollup of 8 pull requests\n\nSuccessful merges:\n\n - #62514 (Clarify `Box<T>` representation and its use in FFI)\n - #66983 (Fix `unused_parens` triggers on macro by example code)\n - #67215 (Fix `-Z print-type-sizes`'s handling of zero-sized fields.)\n - #67230 (Remove irelevant comment on `register_dtor`)\n - #67236 (resolve: Always resolve visibilities on impl items)\n - #67237 (Some small readability improvements)\n - #67238 (Small std::borrow::Cow improvements)\n - #67239 (Make TinyList::remove iterate instead of recurse)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "f384ae1a43bfcacfdce90d2723d50fe09bd4ca96", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f384ae1a43bfcacfdce90d2723d50fe09bd4ca96"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f284f8b4be3a899bf2ecc03e2a1589f486b62a9f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f284f8b4be3a899bf2ecc03e2a1589f486b62a9f", "html_url": "https://github.com/rust-lang/rust/commit/f284f8b4be3a899bf2ecc03e2a1589f486b62a9f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f284f8b4be3a899bf2ecc03e2a1589f486b62a9f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "de0abf7599023b71dd72b44f0165e86c040ee7ea", "url": "https://api.github.com/repos/rust-lang/rust/commits/de0abf7599023b71dd72b44f0165e86c040ee7ea", "html_url": "https://github.com/rust-lang/rust/commit/de0abf7599023b71dd72b44f0165e86c040ee7ea"}, {"sha": "685d4cc7463afe2674dac4ac4298c93157965c2a", "url": "https://api.github.com/repos/rust-lang/rust/commits/685d4cc7463afe2674dac4ac4298c93157965c2a", "html_url": "https://github.com/rust-lang/rust/commit/685d4cc7463afe2674dac4ac4298c93157965c2a"}], "stats": {"total": 320, "additions": 220, "deletions": 100}, "files": [{"sha": "fc9604519684682afd284ecb3d33fa595362c536", "filename": "src/liballoc/borrow.rs", "status": "modified", "additions": 5, "deletions": 13, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f284f8b4be3a899bf2ecc03e2a1589f486b62a9f/src%2Fliballoc%2Fborrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f284f8b4be3a899bf2ecc03e2a1589f486b62a9f/src%2Fliballoc%2Fborrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fborrow.rs?ref=f284f8b4be3a899bf2ecc03e2a1589f486b62a9f", "patch": "@@ -195,14 +195,10 @@ impl<B: ?Sized + ToOwned> Clone for Cow<'_, B> {\n     }\n \n     fn clone_from(&mut self, source: &Self) {\n-        if let Owned(ref mut dest) = *self {\n-            if let Owned(ref o) = *source {\n-                o.borrow().clone_into(dest);\n-                return;\n-            }\n+        match (self, source) {\n+            (&mut Owned(ref mut dest), &Owned(ref o)) => o.borrow().clone_into(dest),\n+            (t, s) => *t = s.clone(),\n         }\n-\n-        *self = source.clone();\n     }\n }\n \n@@ -449,9 +445,7 @@ impl<'a> AddAssign<&'a str> for Cow<'a, str> {\n     fn add_assign(&mut self, rhs: &'a str) {\n         if self.is_empty() {\n             *self = Cow::Borrowed(rhs)\n-        } else if rhs.is_empty() {\n-            return;\n-        } else {\n+        } else if !rhs.is_empty() {\n             if let Cow::Borrowed(lhs) = *self {\n                 let mut s = String::with_capacity(lhs.len() + rhs.len());\n                 s.push_str(lhs);\n@@ -467,9 +461,7 @@ impl<'a> AddAssign<Cow<'a, str>> for Cow<'a, str> {\n     fn add_assign(&mut self, rhs: Cow<'a, str>) {\n         if self.is_empty() {\n             *self = rhs\n-        } else if rhs.is_empty() {\n-            return;\n-        } else {\n+        } else if !rhs.is_empty() {\n             if let Cow::Borrowed(lhs) = *self {\n                 let mut s = String::with_capacity(lhs.len() + rhs.len());\n                 s.push_str(lhs);"}, {"sha": "1c39a3721f465cd1e758360f06387a755cdacd44", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/f284f8b4be3a899bf2ecc03e2a1589f486b62a9f/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f284f8b4be3a899bf2ecc03e2a1589f486b62a9f/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=f284f8b4be3a899bf2ecc03e2a1589f486b62a9f", "patch": "@@ -61,7 +61,60 @@\n //! T` obtained from [`Box::<T>::into_raw`] may be deallocated using the\n //! [`Global`] allocator with [`Layout::for_value(&*value)`].\n //!\n+//! So long as `T: Sized`, a `Box<T>` is guaranteed to be represented\n+//! as a single pointer and is also ABI-compatible with C pointers\n+//! (i.e. the C type `T*`). This means that if you have extern \"C\"\n+//! Rust functions that will be called from C, you can define those\n+//! Rust functions using `Box<T>` types, and use `T*` as corresponding\n+//! type on the C side. As an example, consider this C header which\n+//! declares functions that create and destroy some kind of `Foo`\n+//! value:\n //!\n+//! ```c\n+//! /* C header */\n+//!\n+//! /* Returns ownership to the caller */\n+//! struct Foo* foo_new(void);\n+//!\n+//! /* Takes ownership from the caller; no-op when invoked with NULL */\n+//! void foo_delete(struct Foo*);\n+//! ```\n+//!\n+//! These two functions might be implemented in Rust as follows. Here, the\n+//! `struct Foo*` type from C is translated to `Box<Foo>`, which captures\n+//! the ownership constraints. Note also that the nullable argument to\n+//! `foo_delete` is represented in Rust as `Option<Box<Foo>>`, since `Box<Foo>`\n+//! cannot be null.\n+//!\n+//! ```\n+//! #[repr(C)]\n+//! pub struct Foo;\n+//!\n+//! #[no_mangle]\n+//! pub extern \"C\" fn foo_new() -> Box<Foo> {\n+//!     Box::new(Foo)\n+//! }\n+//!\n+//! #[no_mangle]\n+//! pub extern \"C\" fn foo_delete(_: Option<Box<Foo>>) {}\n+//! ```\n+//!\n+//! Even though `Box<T>` has the same representation and C ABI as a C pointer,\n+//! this does not mean that you can convert an arbitrary `T*` into a `Box<T>`\n+//! and expect things to work. `Box<T>` values will always be fully aligned,\n+//! non-null pointers. Moreover, the destructor for `Box<T>` will attempt to\n+//! free the value with the global allocator. In general, the best practice\n+//! is to only use `Box<T>` for pointers that originated from the global\n+//! allocator.\n+//!\n+//! **Important.** At least at present, you should avoid using\n+//! `Box<T>` types for functions that are defined in C but invoked\n+//! from Rust. In those cases, you should directly mirror the C types\n+//! as closely as possible. Using types like `Box<T>` where the C\n+//! definition is just using `T*` can lead to undefined behavior, as\n+//! described in [rust-lang/unsafe-code-guidelines#198][ucg#198].\n+//!\n+//! [ucg#198]: https://github.com/rust-lang/unsafe-code-guidelines/issues/198\n //! [dereferencing]: ../../std/ops/trait.Deref.html\n //! [`Box`]: struct.Box.html\n //! [`Box<T>`]: struct.Box.html"}, {"sha": "62a5c245a54297d8bf784951ac7209d7f4253fb7", "filename": "src/liballoc/tests/cow_str.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f284f8b4be3a899bf2ecc03e2a1589f486b62a9f/src%2Fliballoc%2Ftests%2Fcow_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f284f8b4be3a899bf2ecc03e2a1589f486b62a9f/src%2Fliballoc%2Ftests%2Fcow_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fcow_str.rs?ref=f284f8b4be3a899bf2ecc03e2a1589f486b62a9f", "patch": "@@ -138,4 +138,7 @@ fn check_cow_clone_from() {\n     let c2: Cow<'_, str> = Cow::Owned(s);\n     c1.clone_from(&c2);\n     assert!(c1.into_owned().capacity() >= 25);\n+    let mut c3: Cow<'_, str> = Cow::Borrowed(\"bye\");\n+    c3.clone_from(&c2);\n+    assert_eq!(c2, c3);\n }"}, {"sha": "5c63eebf595f9e59d32690b46488513db72ddade", "filename": "src/libcore/char/methods.rs", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f284f8b4be3a899bf2ecc03e2a1589f486b62a9f/src%2Flibcore%2Fchar%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f284f8b4be3a899bf2ecc03e2a1589f486b62a9f/src%2Flibcore%2Fchar%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar%2Fmethods.rs?ref=f284f8b4be3a899bf2ecc03e2a1589f486b62a9f", "patch": "@@ -553,8 +553,7 @@ impl char {\n     pub fn is_alphabetic(self) -> bool {\n         match self {\n             'a'..='z' | 'A'..='Z' => true,\n-            c if c > '\\x7f' => derived_property::Alphabetic(c),\n-            _ => false,\n+            c => c > '\\x7f' && derived_property::Alphabetic(c),\n         }\n     }\n \n@@ -585,8 +584,7 @@ impl char {\n     pub fn is_lowercase(self) -> bool {\n         match self {\n             'a'..='z' => true,\n-            c if c > '\\x7f' => derived_property::Lowercase(c),\n-            _ => false,\n+            c => c > '\\x7f' && derived_property::Lowercase(c),\n         }\n     }\n \n@@ -617,8 +615,7 @@ impl char {\n     pub fn is_uppercase(self) -> bool {\n         match self {\n             'A'..='Z' => true,\n-            c if c > '\\x7f' => derived_property::Uppercase(c),\n-            _ => false,\n+            c => c > '\\x7f' && derived_property::Uppercase(c),\n         }\n     }\n \n@@ -646,8 +643,7 @@ impl char {\n     pub fn is_whitespace(self) -> bool {\n         match self {\n             ' ' | '\\x09'..='\\x0d' => true,\n-            c if c > '\\x7f' => property::White_Space(c),\n-            _ => false,\n+            c => c > '\\x7f' && property::White_Space(c),\n         }\n     }\n \n@@ -744,8 +740,7 @@ impl char {\n     pub fn is_numeric(self) -> bool {\n         match self {\n             '0'..='9' => true,\n-            c if c > '\\x7f' => general_category::N(c),\n-            _ => false,\n+            c => c > '\\x7f' && general_category::N(c),\n         }\n     }\n "}, {"sha": "1037da14b5f627371d6678d799639d023590dee2", "filename": "src/libcore/str/pattern.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f284f8b4be3a899bf2ecc03e2a1589f486b62a9f/src%2Flibcore%2Fstr%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f284f8b4be3a899bf2ecc03e2a1589f486b62a9f/src%2Flibcore%2Fstr%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fpattern.rs?ref=f284f8b4be3a899bf2ecc03e2a1589f486b62a9f", "patch": "@@ -296,12 +296,7 @@ unsafe impl<'a> Searcher<'a> for CharSearcher<'a> {\n     fn next_match(&mut self) -> Option<(usize, usize)> {\n         loop {\n             // get the haystack after the last character found\n-            let bytes = if let Some(slice) = self.haystack.as_bytes()\n-                                                 .get(self.finger..self.finger_back) {\n-                slice\n-            } else {\n-                return None;\n-            };\n+            let bytes = self.haystack.as_bytes().get(self.finger..self.finger_back)?;\n             // the last byte of the utf8 encoded needle\n             let last_byte = unsafe { *self.utf8_encoded.get_unchecked(self.utf8_size - 1) };\n             if let Some(index) = memchr::memchr(last_byte, bytes) {"}, {"sha": "78cbc1240b182654cb23cc45f26d1e3a61753833", "filename": "src/librustc_data_structures/tiny_list.rs", "status": "modified", "additions": 16, "deletions": 24, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/f284f8b4be3a899bf2ecc03e2a1589f486b62a9f/src%2Flibrustc_data_structures%2Ftiny_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f284f8b4be3a899bf2ecc03e2a1589f486b62a9f/src%2Flibrustc_data_structures%2Ftiny_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Ftiny_list.rs?ref=f284f8b4be3a899bf2ecc03e2a1589f486b62a9f", "patch": "@@ -16,41 +16,29 @@ mod tests;\n \n #[derive(Clone)]\n pub struct TinyList<T: PartialEq> {\n-    head: Option<Element<T>>\n+    head: Option<Element<T>>,\n }\n \n impl<T: PartialEq> TinyList<T> {\n     #[inline]\n     pub fn new() -> TinyList<T> {\n-        TinyList {\n-            head: None\n-        }\n+        TinyList { head: None }\n     }\n \n     #[inline]\n     pub fn new_single(data: T) -> TinyList<T> {\n-        TinyList {\n-            head: Some(Element {\n-                data,\n-                next: None,\n-            })\n-        }\n+        TinyList { head: Some(Element { data, next: None }) }\n     }\n \n     #[inline]\n     pub fn insert(&mut self, data: T) {\n-        self.head = Some(Element {\n-            data,\n-            next: self.head.take().map(Box::new)\n-        });\n+        self.head = Some(Element { data, next: self.head.take().map(Box::new) });\n     }\n \n     #[inline]\n     pub fn remove(&mut self, data: &T) -> bool {\n         self.head = match self.head {\n-            Some(ref mut head) if head.data == *data => {\n-                head.next.take().map(|x| *x)\n-            }\n+            Some(ref mut head) if head.data == *data => head.next.take().map(|x| *x),\n             Some(ref mut head) => return head.remove_next(data),\n             None => return false,\n         };\n@@ -88,12 +76,16 @@ struct Element<T: PartialEq> {\n \n impl<T: PartialEq> Element<T> {\n     fn remove_next(&mut self, data: &T) -> bool {\n-        let new_next = match self.next {\n-            Some(ref mut next) if next.data == *data => next.next.take(),\n-            Some(ref mut next) => return next.remove_next(data),\n-            None => return false,\n-        };\n-        self.next = new_next;\n-        true\n+        let mut n = self;\n+        loop {\n+            match n.next {\n+                Some(ref mut next) if next.data == *data => {\n+                    n.next = next.next.take();\n+                    return true;\n+                }\n+                Some(ref mut next) => n = next,\n+                None => return false,\n+            }\n+        }\n     }\n }"}, {"sha": "e6f39cca6dc3a10dd1621227fc20ff52764f3742", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f284f8b4be3a899bf2ecc03e2a1589f486b62a9f/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f284f8b4be3a899bf2ecc03e2a1589f486b62a9f/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=f284f8b4be3a899bf2ecc03e2a1589f486b62a9f", "patch": "@@ -355,7 +355,9 @@ impl UnusedParens {\n         match value.kind {\n             ast::ExprKind::Paren(ref inner) => {\n                 if !Self::is_expr_parens_necessary(inner, followed_by_block) &&\n-                    value.attrs.is_empty() {\n+                    value.attrs.is_empty() &&\n+                    !value.span.from_expansion()\n+                {\n                     let expr_text = if let Ok(snippet) = cx.sess().source_map()\n                         .span_to_snippet(value.span) {\n                             snippet"}, {"sha": "e2578d67e730cea82ff5bf1d4babc3c93d8acb7b", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/f284f8b4be3a899bf2ecc03e2a1589f486b62a9f/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f284f8b4be3a899bf2ecc03e2a1589f486b62a9f/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=f284f8b4be3a899bf2ecc03e2a1589f486b62a9f", "patch": "@@ -647,8 +647,6 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                 self.r.define(parent, ident, TypeNS, imported_binding);\n             }\n \n-            ItemKind::GlobalAsm(..) => {}\n-\n             ItemKind::Mod(..) if ident.name == kw::Invalid => {} // Crate root\n \n             ItemKind::Mod(..) => {\n@@ -667,9 +665,6 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                 self.parent_scope.module = module;\n             }\n \n-            // Handled in `rustc_metadata::{native_libs,link_args}`\n-            ItemKind::ForeignMod(..) => {}\n-\n             // These items live in the value namespace.\n             ItemKind::Static(..) => {\n                 let res = Res::Def(DefKind::Static, self.r.definitions.local_def_id(item.id));\n@@ -765,12 +760,6 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                 self.insert_field_names_local(def_id, vdata);\n             }\n \n-            ItemKind::Impl(.., ref impl_items) => {\n-                for impl_item in impl_items {\n-                    self.resolve_visibility(&impl_item.vis);\n-                }\n-            }\n-\n             ItemKind::Trait(..) => {\n                 let def_id = self.r.definitions.local_def_id(item.id);\n \n@@ -785,6 +774,9 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                 self.parent_scope.module = module;\n             }\n \n+            // These items do not add names to modules.\n+            ItemKind::Impl(..) | ItemKind::ForeignMod(..) | ItemKind::GlobalAsm(..) => {}\n+\n             ItemKind::MacroDef(..) | ItemKind::Mac(_) => unreachable!(),\n         }\n     }\n@@ -1118,7 +1110,6 @@ macro_rules! method {\n }\n \n impl<'a, 'b> Visitor<'b> for BuildReducedGraphVisitor<'a, 'b> {\n-    method!(visit_impl_item: ast::ImplItem, ast::ImplItemKind::Macro, walk_impl_item);\n     method!(visit_expr:      ast::Expr,     ast::ExprKind::Mac,       walk_expr);\n     method!(visit_pat:       ast::Pat,      ast::PatKind::Mac,        walk_pat);\n     method!(visit_ty:        ast::Ty,       ast::TyKind::Mac,         walk_ty);\n@@ -1202,6 +1193,15 @@ impl<'a, 'b> Visitor<'b> for BuildReducedGraphVisitor<'a, 'b> {\n         visit::walk_trait_item(self, item);\n     }\n \n+    fn visit_impl_item(&mut self, item: &'b ast::ImplItem) {\n+        if let ast::ImplItemKind::Macro(..) = item.kind {\n+            self.visit_invoc(item.id);\n+        } else {\n+            self.resolve_visibility(&item.vis);\n+            visit::walk_impl_item(self, item);\n+        }\n+    }\n+\n     fn visit_token(&mut self, t: Token) {\n         if let token::Interpolated(nt) = t.kind {\n             if let token::NtExpr(ref expr) = *nt {"}, {"sha": "764d6d8eaee30c0cc478b6f67797aad6d98f2c2d", "filename": "src/librustc_session/code_stats.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f284f8b4be3a899bf2ecc03e2a1589f486b62a9f/src%2Flibrustc_session%2Fcode_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f284f8b4be3a899bf2ecc03e2a1589f486b62a9f/src%2Flibrustc_session%2Fcode_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_session%2Fcode_stats.rs?ref=f284f8b4be3a899bf2ecc03e2a1589f486b62a9f", "patch": "@@ -132,9 +132,12 @@ impl CodeStats {\n \n                 let mut min_offset = discr_size;\n \n-                // We want to print fields by increasing offset.\n+                // We want to print fields by increasing offset. We also want\n+                // zero-sized fields before non-zero-sized fields, otherwise\n+                // the loop below goes wrong; hence the `f.size` in the sort\n+                // key.\n                 let mut fields = fields.clone();\n-                fields.sort_by_key(|f| f.offset);\n+                fields.sort_by_key(|f| (f.offset, f.size));\n \n                 for field in fields.iter() {\n                     let FieldInfo { ref name, offset, size, align } = *field;\n@@ -146,7 +149,7 @@ impl CodeStats {\n                     }\n \n                     if offset < min_offset {\n-                        // if this happens something is very wrong\n+                        // If this happens it's probably a union.\n                         println!(\"print-type-size {}field `.{}`: {} bytes, \\\n                                   offset: {} bytes, \\\n                                   alignment: {} bytes\","}, {"sha": "0861432f8a92338b08b794e981cac9a74e1f5ce5", "filename": "src/libstd/sys/unix/fast_thread_local.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f284f8b4be3a899bf2ecc03e2a1589f486b62a9f/src%2Flibstd%2Fsys%2Funix%2Ffast_thread_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f284f8b4be3a899bf2ecc03e2a1589f486b62a9f/src%2Flibstd%2Fsys%2Funix%2Ffast_thread_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ffast_thread_local.rs?ref=f284f8b4be3a899bf2ecc03e2a1589f486b62a9f", "patch": "@@ -8,8 +8,6 @@\n // Note, however, that we run on lots older linuxes, as well as cross\n // compiling from a newer linux to an older linux, so we also have a\n // fallback implementation to use as well.\n-//\n-// Due to rust-lang/rust#18804, make sure this is not generic!\n #[cfg(any(\n     target_os = \"linux\",\n     target_os = \"fuchsia\","}, {"sha": "0a951cfa91c58f44ae915ade591f03be84df19ab", "filename": "src/test/ui/lint/issue-47775-nested-macro-unnecessary-parens-arg.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f284f8b4be3a899bf2ecc03e2a1589f486b62a9f/src%2Ftest%2Fui%2Flint%2Fissue-47775-nested-macro-unnecessary-parens-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f284f8b4be3a899bf2ecc03e2a1589f486b62a9f/src%2Ftest%2Fui%2Flint%2Fissue-47775-nested-macro-unnecessary-parens-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fissue-47775-nested-macro-unnecessary-parens-arg.rs?ref=f284f8b4be3a899bf2ecc03e2a1589f486b62a9f", "patch": "@@ -17,10 +17,7 @@ macro_rules! the_worship_the_heart_lifts_above {\n \n macro_rules! and_the_heavens_reject_not {\n     () => {\n-        // \u2193 But let's test that we still lint for unused parens around\n-        // function args inside of simple, one-deep macros.\n         #[allow(dead_code)] fn the_night_for_the_morrow() -> Option<isize> { Some((2)) }\n-        //~^ WARN unnecessary parentheses around function argument\n     }\n }\n "}, {"sha": "57cdcd70e9db4ae88c1b9715c2775a826b93b4e5", "filename": "src/test/ui/lint/issue-47775-nested-macro-unnecessary-parens-arg.stderr", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/de0abf7599023b71dd72b44f0165e86c040ee7ea/src%2Ftest%2Fui%2Flint%2Fissue-47775-nested-macro-unnecessary-parens-arg.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/de0abf7599023b71dd72b44f0165e86c040ee7ea/src%2Ftest%2Fui%2Flint%2Fissue-47775-nested-macro-unnecessary-parens-arg.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fissue-47775-nested-macro-unnecessary-parens-arg.stderr?ref=de0abf7599023b71dd72b44f0165e86c040ee7ea", "patch": "@@ -1,15 +0,0 @@\n-warning: unnecessary parentheses around function argument\n-  --> $DIR/issue-47775-nested-macro-unnecessary-parens-arg.rs:22:83\n-   |\n-LL |         #[allow(dead_code)] fn the_night_for_the_morrow() -> Option<isize> { Some((2)) }\n-   |                                                                                   ^^^ help: remove these parentheses\n-...\n-LL | and_the_heavens_reject_not!();\n-   | ------------------------------ in this macro invocation\n-   |\n-note: lint level defined here\n-  --> $DIR/issue-47775-nested-macro-unnecessary-parens-arg.rs:3:9\n-   |\n-LL | #![warn(unused_parens)]\n-   |         ^^^^^^^^^^^^^\n-"}, {"sha": "12ffb6d3c66552526bfef134f7c42d8a0bb049a5", "filename": "src/test/ui/lint/lint-unnecessary-parens.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f284f8b4be3a899bf2ecc03e2a1589f486b62a9f/src%2Ftest%2Fui%2Flint%2Flint-unnecessary-parens.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f284f8b4be3a899bf2ecc03e2a1589f486b62a9f/src%2Ftest%2Fui%2Flint%2Flint-unnecessary-parens.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-unnecessary-parens.rs?ref=f284f8b4be3a899bf2ecc03e2a1589f486b62a9f", "patch": "@@ -25,6 +25,12 @@ fn passes_unused_parens_lint() -> &'static (dyn Trait) {\n     panic!()\n }\n \n+macro_rules! baz {\n+    ($($foo:expr),+) => {\n+        ($($foo),*)\n+    }\n+}\n+\n fn main() {\n     foo();\n     bar((true)); //~ ERROR unnecessary parentheses around function argument\n@@ -55,4 +61,7 @@ fn main() {\n     let mut _a = (0); //~ ERROR unnecessary parentheses around assigned value\n     _a = (0); //~ ERROR unnecessary parentheses around assigned value\n     _a += (1); //~ ERROR unnecessary parentheses around assigned value\n+\n+    let _a = baz!(3, 4);\n+    let _b = baz!(3);\n }"}, {"sha": "541ae7aa4b54a0738a3595bb0250e7b95efd5892", "filename": "src/test/ui/lint/lint-unnecessary-parens.stderr", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/f284f8b4be3a899bf2ecc03e2a1589f486b62a9f/src%2Ftest%2Fui%2Flint%2Flint-unnecessary-parens.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f284f8b4be3a899bf2ecc03e2a1589f486b62a9f/src%2Ftest%2Fui%2Flint%2Flint-unnecessary-parens.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-unnecessary-parens.stderr?ref=f284f8b4be3a899bf2ecc03e2a1589f486b62a9f", "patch": "@@ -23,69 +23,69 @@ LL | fn unused_parens_around_return_type() -> (u32) {\n    |                                          ^^^^^ help: remove these parentheses\n \n error: unnecessary parentheses around function argument\n-  --> $DIR/lint-unnecessary-parens.rs:30:9\n+  --> $DIR/lint-unnecessary-parens.rs:36:9\n    |\n LL |     bar((true));\n    |         ^^^^^^ help: remove these parentheses\n \n error: unnecessary parentheses around `if` condition\n-  --> $DIR/lint-unnecessary-parens.rs:32:8\n+  --> $DIR/lint-unnecessary-parens.rs:38:8\n    |\n LL |     if (true) {}\n    |        ^^^^^^ help: remove these parentheses\n \n error: unnecessary parentheses around `while` condition\n-  --> $DIR/lint-unnecessary-parens.rs:33:11\n+  --> $DIR/lint-unnecessary-parens.rs:39:11\n    |\n LL |     while (true) {}\n    |           ^^^^^^ help: remove these parentheses\n \n warning: denote infinite loops with `loop { ... }`\n-  --> $DIR/lint-unnecessary-parens.rs:33:5\n+  --> $DIR/lint-unnecessary-parens.rs:39:5\n    |\n LL |     while (true) {}\n    |     ^^^^^^^^^^^^ help: use `loop`\n    |\n    = note: `#[warn(while_true)]` on by default\n \n error: unnecessary parentheses around `match` head expression\n-  --> $DIR/lint-unnecessary-parens.rs:35:11\n+  --> $DIR/lint-unnecessary-parens.rs:41:11\n    |\n LL |     match (true) {\n    |           ^^^^^^ help: remove these parentheses\n \n error: unnecessary parentheses around `let` head expression\n-  --> $DIR/lint-unnecessary-parens.rs:38:16\n+  --> $DIR/lint-unnecessary-parens.rs:44:16\n    |\n LL |     if let 1 = (1) {}\n    |                ^^^ help: remove these parentheses\n \n error: unnecessary parentheses around `let` head expression\n-  --> $DIR/lint-unnecessary-parens.rs:39:19\n+  --> $DIR/lint-unnecessary-parens.rs:45:19\n    |\n LL |     while let 1 = (2) {}\n    |                   ^^^ help: remove these parentheses\n \n error: unnecessary parentheses around method argument\n-  --> $DIR/lint-unnecessary-parens.rs:53:24\n+  --> $DIR/lint-unnecessary-parens.rs:59:24\n    |\n LL |     X { y: false }.foo((true));\n    |                        ^^^^^^ help: remove these parentheses\n \n error: unnecessary parentheses around assigned value\n-  --> $DIR/lint-unnecessary-parens.rs:55:18\n+  --> $DIR/lint-unnecessary-parens.rs:61:18\n    |\n LL |     let mut _a = (0);\n    |                  ^^^ help: remove these parentheses\n \n error: unnecessary parentheses around assigned value\n-  --> $DIR/lint-unnecessary-parens.rs:56:10\n+  --> $DIR/lint-unnecessary-parens.rs:62:10\n    |\n LL |     _a = (0);\n    |          ^^^ help: remove these parentheses\n \n error: unnecessary parentheses around assigned value\n-  --> $DIR/lint-unnecessary-parens.rs:57:11\n+  --> $DIR/lint-unnecessary-parens.rs:63:11\n    |\n LL |     _a += (1);\n    |           ^^^ help: remove these parentheses"}, {"sha": "2ad488e8d8fb90ebd0ab106bb5a70e5fc787e526", "filename": "src/test/ui/print_type_sizes/zero-sized-fields.rs", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/f284f8b4be3a899bf2ecc03e2a1589f486b62a9f/src%2Ftest%2Fui%2Fprint_type_sizes%2Fzero-sized-fields.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f284f8b4be3a899bf2ecc03e2a1589f486b62a9f/src%2Ftest%2Fui%2Fprint_type_sizes%2Fzero-sized-fields.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprint_type_sizes%2Fzero-sized-fields.rs?ref=f284f8b4be3a899bf2ecc03e2a1589f486b62a9f", "patch": "@@ -0,0 +1,46 @@\n+// compile-flags: -Z print-type-sizes\n+// build-pass (FIXME(62277): could be check-pass?)\n+\n+// At one point, zero-sized fields such as those in this file were causing\n+// incorrect output from `-Z print-type-sizes`.\n+\n+#![feature(start)]\n+\n+struct S1 {\n+    x: u32,\n+    y: u32,\n+    tag: (),\n+}\n+\n+struct Void();\n+struct Empty {}\n+\n+struct S5<TagW, TagZ> {\n+    tagw: TagW,\n+    w: u32,\n+    unit: (),\n+    x: u32,\n+    void: Void,\n+    y: u32,\n+    empty: Empty,\n+    z: u32,\n+    tagz: TagZ,\n+}\n+\n+#[start]\n+fn start(_: isize, _: *const *const u8) -> isize {\n+    let _s1: S1 = S1 { x: 0, y: 0, tag: () };\n+\n+    let _s5: S5<(), Empty> = S5 {\n+        tagw: (),\n+        w: 1,\n+        unit: (),\n+        x: 2,\n+        void: Void(),\n+        y: 3,\n+        empty: Empty {},\n+        z: 4,\n+        tagz: Empty {},\n+    };\n+    0\n+}"}, {"sha": "72f59c4bb57bf6bf801cf86d2afce46d250478e2", "filename": "src/test/ui/print_type_sizes/zero-sized-fields.stdout", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f284f8b4be3a899bf2ecc03e2a1589f486b62a9f/src%2Ftest%2Fui%2Fprint_type_sizes%2Fzero-sized-fields.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/f284f8b4be3a899bf2ecc03e2a1589f486b62a9f/src%2Ftest%2Fui%2Fprint_type_sizes%2Fzero-sized-fields.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprint_type_sizes%2Fzero-sized-fields.stdout?ref=f284f8b4be3a899bf2ecc03e2a1589f486b62a9f", "patch": "@@ -0,0 +1,16 @@\n+print-type-size type: `S5<(), Empty>`: 16 bytes, alignment: 4 bytes\n+print-type-size     field `.tagw`: 0 bytes\n+print-type-size     field `.unit`: 0 bytes\n+print-type-size     field `.void`: 0 bytes\n+print-type-size     field `.empty`: 0 bytes\n+print-type-size     field `.tagz`: 0 bytes\n+print-type-size     field `.w`: 4 bytes\n+print-type-size     field `.x`: 4 bytes\n+print-type-size     field `.y`: 4 bytes\n+print-type-size     field `.z`: 4 bytes\n+print-type-size type: `S1`: 8 bytes, alignment: 4 bytes\n+print-type-size     field `.tag`: 0 bytes\n+print-type-size     field `.x`: 4 bytes\n+print-type-size     field `.y`: 4 bytes\n+print-type-size type: `Empty`: 0 bytes, alignment: 1 bytes\n+print-type-size type: `Void`: 0 bytes, alignment: 1 bytes"}, {"sha": "9b4fe498239b6b32500896f78dc8ceeb3c64062b", "filename": "src/test/ui/resolve/impl-items-vis-unresolved.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/f284f8b4be3a899bf2ecc03e2a1589f486b62a9f/src%2Ftest%2Fui%2Fresolve%2Fimpl-items-vis-unresolved.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f284f8b4be3a899bf2ecc03e2a1589f486b62a9f/src%2Ftest%2Fui%2Fresolve%2Fimpl-items-vis-unresolved.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fimpl-items-vis-unresolved.rs?ref=f284f8b4be3a899bf2ecc03e2a1589f486b62a9f", "patch": "@@ -0,0 +1,25 @@\n+// Visibilities on impl items expanded from macros are resolved (issue #64705).\n+\n+macro_rules! perftools_inline {\n+    ($($item:tt)*) => (\n+        $($item)*\n+    );\n+}\n+\n+mod state {\n+    pub struct RawFloatState;\n+    impl RawFloatState {\n+        perftools_inline! {\n+            pub(super) fn new() {} // OK\n+        }\n+    }\n+}\n+\n+pub struct RawFloatState;\n+impl RawFloatState {\n+    perftools_inline! {\n+        pub(super) fn new() {} //~ ERROR failed to resolve: there are too many initial `super`s\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "8e285e53124007009761f5dde046d9d752b5d651", "filename": "src/test/ui/resolve/impl-items-vis-unresolved.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f284f8b4be3a899bf2ecc03e2a1589f486b62a9f/src%2Ftest%2Fui%2Fresolve%2Fimpl-items-vis-unresolved.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f284f8b4be3a899bf2ecc03e2a1589f486b62a9f/src%2Ftest%2Fui%2Fresolve%2Fimpl-items-vis-unresolved.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fimpl-items-vis-unresolved.stderr?ref=f284f8b4be3a899bf2ecc03e2a1589f486b62a9f", "patch": "@@ -0,0 +1,9 @@\n+error[E0433]: failed to resolve: there are too many initial `super`s.\n+  --> $DIR/impl-items-vis-unresolved.rs:21:13\n+   |\n+LL |         pub(super) fn new() {}\n+   |             ^^^^^ there are too many initial `super`s.\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0433`."}]}