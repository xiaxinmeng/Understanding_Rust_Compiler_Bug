{"sha": "d0c6a6d642410b379142cd9e8f271c142882671d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQwYzZhNmQ2NDI0MTBiMzc5MTQyY2Q5ZThmMjcxYzE0Mjg4MjY3MWQ=", "commit": {"author": {"name": "Nick Cameron", "email": "nrc@ncameron.org", "date": "2018-10-07T23:38:33Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-10-07T23:38:33Z"}, "message": "Merge pull request #3067 from topecongiro/refactor-toexpr\n\nAdd println!-like heuristic to the fail attribute", "tree": {"sha": "ce656aad58efd16cfaf76bbe56bd1ad117c2bafb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ce656aad58efd16cfaf76bbe56bd1ad117c2bafb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d0c6a6d642410b379142cd9e8f271c142882671d", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJbupj6CRBK7hj4Ov3rIwAAdHIIAKYWyfcPm+oXChlsECQpUKBz\nHqgQvLFlGlsV50JdoOLItiuFMIxWMwWLJo5kkn5KswQ/gU2LyydLAunMSrx+Udft\nzEqM+kJm0uTFxRkSKL60Tly5BgwRuJilvOq9CIQ/Hzw2Wlfi5ObJhJaMmKRaOEl7\n/sdbch8XKyWZ7/EW+yCSkfNv/XYK8xP+iY8frbAinloJkjTZMxuVRkXBXok97cI2\nwLWSH+DYhzOrHuAYnatN9YRVPtba4BEqgXXyTOG0kuqtrRcEuvMoOYroI5yaOHf6\nWTHw5ngCVFsP6yjnLTnEOt4F42epWOdM7DK0WqkGRo4tZD4S5CBkII0BV3vy6yM=\n=5EYi\n-----END PGP SIGNATURE-----\n", "payload": "tree ce656aad58efd16cfaf76bbe56bd1ad117c2bafb\nparent b32cf4aad8e4dc53ee7d552c5206227a8d1eb9ba\nparent bc835b71fd5d385b2bb8377ecadbe2a61d0973a6\nauthor Nick Cameron <nrc@ncameron.org> 1538955513 +1300\ncommitter GitHub <noreply@github.com> 1538955513 +1300\n\nMerge pull request #3067 from topecongiro/refactor-toexpr\n\nAdd println!-like heuristic to the fail attribute"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d0c6a6d642410b379142cd9e8f271c142882671d", "html_url": "https://github.com/rust-lang/rust/commit/d0c6a6d642410b379142cd9e8f271c142882671d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d0c6a6d642410b379142cd9e8f271c142882671d/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b32cf4aad8e4dc53ee7d552c5206227a8d1eb9ba", "url": "https://api.github.com/repos/rust-lang/rust/commits/b32cf4aad8e4dc53ee7d552c5206227a8d1eb9ba", "html_url": "https://github.com/rust-lang/rust/commit/b32cf4aad8e4dc53ee7d552c5206227a8d1eb9ba"}, {"sha": "bc835b71fd5d385b2bb8377ecadbe2a61d0973a6", "url": "https://api.github.com/repos/rust-lang/rust/commits/bc835b71fd5d385b2bb8377ecadbe2a61d0973a6", "html_url": "https://github.com/rust-lang/rust/commit/bc835b71fd5d385b2bb8377ecadbe2a61d0973a6"}], "stats": {"total": 706, "additions": 371, "deletions": 335}, "files": [{"sha": "42e0938d78298068c52ec23714871bde2d8ae3b2", "filename": ".travis.yml", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d0c6a6d642410b379142cd9e8f271c142882671d/.travis.yml", "raw_url": "https://github.com/rust-lang/rust/raw/d0c6a6d642410b379142cd9e8f271c142882671d/.travis.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.travis.yml?ref=d0c6a6d642410b379142cd9e8f271c142882671d", "patch": "@@ -35,20 +35,12 @@ matrix:\n     - env: INTEGRATION=stdsimd\n     - env: INTEGRATION=tempdir\n   allow_failures:\n-    # Needs `edition = \"2018\"` in rustfmt.toml\n-    - env: INTEGRATION=chalk\n-    # Fails tests, don't know why\n-    - env: INTEGRATION=crater\n     # Doesn't build\n     - env: INTEGRATION=futures-rs\n     # Doesn't build - seems to be because of an option\n     - env: INTEGRATION=packed_simd\n-    # Weird bug I can't reproduce: #2969\n-    - env: INTEGRATION=rand\n     # Test failure\n     - env: INTEGRATION=rust-clippy\n-    # Build failure\n-    - env: INTEGRATION=rust-semverver\n \n script:\n   - |"}, {"sha": "19c6bdc24841a212d7bf796f9c70381e349672a3", "filename": "src/attr.rs", "status": "modified", "additions": 13, "deletions": 48, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/d0c6a6d642410b379142cd9e8f271c142882671d/src%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0c6a6d642410b379142cd9e8f271c142882671d/src%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fattr.rs?ref=d0c6a6d642410b379142cd9e8f271c142882671d", "patch": "@@ -15,12 +15,12 @@ use config::lists::*;\n use config::IndentStyle;\n use expr::rewrite_literal;\n use lists::{definitive_tactic, itemize_list, write_list, ListFormatting, Separator};\n+use overflow;\n use rewrite::{Rewrite, RewriteContext};\n use shape::Shape;\n use types::{rewrite_path, PathContext};\n use utils::{count_newlines, mk_sp};\n \n-use std::borrow::Cow;\n use syntax::ast;\n use syntax::source_map::{BytePos, Span, DUMMY_SP};\n \n@@ -216,56 +216,21 @@ impl Rewrite for ast::MetaItem {\n             }\n             ast::MetaItemKind::List(ref list) => {\n                 let path = rewrite_path(context, PathContext::Type, None, &self.ident, shape)?;\n-\n-                let has_comma = ::expr::span_ends_with_comma(context, self.span);\n-                let trailing_comma = if has_comma { \",\" } else { \"\" };\n-                let combine = list.len() == 1 && match list[0].node {\n-                    ast::NestedMetaItemKind::Literal(..) => false,\n-                    ast::NestedMetaItemKind::MetaItem(ref inner_meta_item) => {\n-                        match inner_meta_item.node {\n-                            ast::MetaItemKind::List(..) => rewrite_path(\n-                                context,\n-                                PathContext::Type,\n-                                None,\n-                                &inner_meta_item.ident,\n-                                shape,\n-                            )\n-                            .map_or(false, |s| s.len() + path.len() + 2 <= shape.width),\n-                            _ => false,\n-                        }\n-                    }\n-                };\n-\n-                let argument_shape = argument_shape(\n-                    path.len() + 1,\n-                    2 + trailing_comma.len(),\n-                    combine,\n-                    shape,\n+                let has_trailing_comma = ::expr::span_ends_with_comma(context, self.span);\n+                overflow::rewrite_with_parens(\n                     context,\n-                )?;\n-                let item_str = format_arg_list(\n+                    &path,\n                     list.iter(),\n-                    |nested_meta_item| nested_meta_item.span.lo(),\n-                    |nested_meta_item| nested_meta_item.span.hi(),\n-                    |nested_meta_item| nested_meta_item.rewrite(context, argument_shape),\n+                    // 1 = \"]\"\n+                    shape.sub_width(1)?,\n                     self.span,\n-                    context,\n-                    argument_shape,\n-                    // 3 = \"()\" and \"]\"\n-                    shape\n-                        .offset_left(path.len())?\n-                        .sub_width(3 + trailing_comma.len())?,\n-                    Some(context.config.width_heuristics().fn_call_width),\n-                    combine,\n-                )?;\n-\n-                let indent = if item_str.starts_with('\\n') {\n-                    shape.indent.to_string_with_newline(context.config)\n-                } else {\n-                    Cow::Borrowed(\"\")\n-                };\n-\n-                format!(\"{}({}{}{})\", path, item_str, trailing_comma, indent)\n+                    context.config.width_heuristics().fn_call_width,\n+                    Some(if has_trailing_comma {\n+                        SeparatorTactic::Always\n+                    } else {\n+                        SeparatorTactic::Never\n+                    }),\n+                )?\n             }\n             ast::MetaItemKind::NameValue(ref literal) => {\n                 let path = rewrite_path(context, PathContext::Type, None, &self.ident, shape)?;"}, {"sha": "bde08931d18e0aae2d93fbd6cdff86d87ddda19e", "filename": "src/closures.rs", "status": "modified", "additions": 7, "deletions": 12, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/d0c6a6d642410b379142cd9e8f271c142882671d/src%2Fclosures.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0c6a6d642410b379142cd9e8f271c142882671d/src%2Fclosures.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fclosures.rs?ref=d0c6a6d642410b379142cd9e8f271c142882671d", "patch": "@@ -13,9 +13,10 @@ use syntax::parse::classify;\n use syntax::source_map::Span;\n use syntax::{ast, ptr};\n \n-use expr::{block_contains_comment, is_simple_block, is_unsafe_block, rewrite_cond, ToExpr};\n+use expr::{block_contains_comment, is_simple_block, is_unsafe_block, rewrite_cond};\n use items::{span_hi_for_arg, span_lo_for_arg};\n use lists::{definitive_tactic, itemize_list, write_list, ListFormatting, Separator};\n+use overflow::OverflowableItem;\n use rewrite::{Rewrite, RewriteContext};\n use shape::Shape;\n use source_map::SpanUtils;\n@@ -358,18 +359,12 @@ pub fn rewrite_last_closure(\n }\n \n /// Returns true if the given vector of arguments has more than one `ast::ExprKind::Closure`.\n-pub fn args_have_many_closure<T>(args: &[&T]) -> bool\n-where\n-    T: ToExpr,\n-{\n+pub fn args_have_many_closure(args: &[OverflowableItem]) -> bool {\n     args.iter()\n-        .filter(|arg| {\n-            arg.to_expr()\n-                .map(|e| match e.node {\n-                    ast::ExprKind::Closure(..) => true,\n-                    _ => false,\n-                })\n-                .unwrap_or(false)\n+        .filter_map(|arg| arg.to_expr())\n+        .filter(|expr| match expr.node {\n+            ast::ExprKind::Closure(..) => true,\n+            _ => false,\n         })\n         .count()\n         > 1"}, {"sha": "09ab3da6920a99cfcaf9d2b15a8d2034d479eadd", "filename": "src/expr.rs", "status": "modified", "additions": 26, "deletions": 154, "changes": 180, "blob_url": "https://github.com/rust-lang/rust/blob/d0c6a6d642410b379142cd9e8f271c142882671d/src%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0c6a6d642410b379142cd9e8f271c142882671d/src%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fexpr.rs?ref=d0c6a6d642410b379142cd9e8f271c142882671d", "patch": "@@ -27,17 +27,17 @@ use lists::{\n     definitive_tactic, itemize_list, shape_for_tactic, struct_lit_formatting, struct_lit_shape,\n     struct_lit_tactic, write_list, ListFormatting, ListItem, Separator,\n };\n-use macros::{rewrite_macro, MacroArg, MacroPosition};\n+use macros::{rewrite_macro, MacroPosition};\n use matches::rewrite_match;\n-use overflow;\n+use overflow::{self, IntoOverflowableItem, OverflowableItem};\n use pairs::{rewrite_all_pairs, rewrite_pair, PairParts};\n-use patterns::{can_be_overflowed_pat, is_short_pattern, TuplePatField};\n+use patterns::is_short_pattern;\n use rewrite::{Rewrite, RewriteContext};\n use shape::{Indent, Shape};\n use source_map::{LineRangeUtils, SpanUtils};\n use spanned::Spanned;\n use string::{rewrite_string, StringFormat};\n-use types::{can_be_overflowed_type, rewrite_path, PathContext};\n+use types::{rewrite_path, PathContext};\n use utils::{\n     colon_spaces, contains_skip, count_newlines, first_line_ends_with, first_line_width,\n     inner_attributes, last_line_extendable, last_line_width, mk_sp, outer_attributes,\n@@ -73,7 +73,7 @@ pub fn format_expr(\n     let expr_rw = match expr.node {\n         ast::ExprKind::Array(ref expr_vec) => rewrite_array(\n             \"\",\n-            &ptr_vec_to_ref_vec(expr_vec),\n+            expr_vec.iter(),\n             expr.span,\n             context,\n             shape,\n@@ -110,7 +110,7 @@ pub fn format_expr(\n             shape,\n         ),\n         ast::ExprKind::Tup(ref items) => {\n-            rewrite_tuple(context, &ptr_vec_to_ref_vec(items), expr.span, shape)\n+            rewrite_tuple(context, items.iter(), expr.span, shape, items.len() == 1)\n         }\n         ast::ExprKind::If(..)\n         | ast::ExprKind::IfLet(..)\n@@ -391,11 +391,11 @@ pub fn format_expr(\n         })\n }\n \n-pub fn rewrite_array<T: Rewrite + Spanned + ToExpr>(\n-    name: &str,\n-    exprs: &[&T],\n+pub fn rewrite_array<'a, T: 'a + IntoOverflowableItem<'a>>(\n+    name: &'a str,\n+    exprs: impl Iterator<Item = &'a T>,\n     span: Span,\n-    context: &RewriteContext,\n+    context: &'a RewriteContext,\n     shape: Shape,\n     force_separator_tactic: Option<SeparatorTactic>,\n     delim_token: Option<DelimToken>,\n@@ -1259,54 +1259,6 @@ fn rewrite_string_lit(context: &RewriteContext, span: Span, shape: Shape) -> Opt\n     )\n }\n \n-/// In case special-case style is required, returns an offset from which we start horizontal layout.\n-pub fn maybe_get_args_offset<T: ToExpr>(callee_str: &str, args: &[&T]) -> Option<(bool, usize)> {\n-    if let Some(&(_, num_args_before)) = SPECIAL_MACRO_WHITELIST\n-        .iter()\n-        .find(|&&(s, _)| s == callee_str)\n-    {\n-        let all_simple = args.len() > num_args_before && is_every_expr_simple(args);\n-\n-        Some((all_simple, num_args_before))\n-    } else {\n-        None\n-    }\n-}\n-\n-/// A list of `format!`-like macros, that take a long format string and a list of arguments to\n-/// format.\n-///\n-/// Organized as a list of `(&str, usize)` tuples, giving the name of the macro and the number of\n-/// arguments before the format string (none for `format!(\"format\", ...)`, one for `assert!(result,\n-/// \"format\", ...)`, two for `assert_eq!(left, right, \"format\", ...)`).\n-const SPECIAL_MACRO_WHITELIST: &[(&str, usize)] = &[\n-    // format! like macros\n-    // From the Rust Standard Library.\n-    (\"eprint!\", 0),\n-    (\"eprintln!\", 0),\n-    (\"format!\", 0),\n-    (\"format_args!\", 0),\n-    (\"print!\", 0),\n-    (\"println!\", 0),\n-    (\"panic!\", 0),\n-    (\"unreachable!\", 0),\n-    // From the `log` crate.\n-    (\"debug!\", 0),\n-    (\"error!\", 0),\n-    (\"info!\", 0),\n-    (\"warn!\", 0),\n-    // write! like macros\n-    (\"assert!\", 1),\n-    (\"debug_assert!\", 1),\n-    (\"write!\", 1),\n-    (\"writeln!\", 1),\n-    // assert_eq! like macros\n-    (\"assert_eq!\", 2),\n-    (\"assert_ne!\", 2),\n-    (\"debug_assert_eq!\", 2),\n-    (\"debug_assert_ne!\", 2),\n-];\n-\n fn choose_separator_tactic(context: &RewriteContext, span: Span) -> Option<SeparatorTactic> {\n     if context.inside_macro() {\n         if span_ends_with_comma(context, span) {\n@@ -1329,15 +1281,15 @@ pub fn rewrite_call(\n     overflow::rewrite_with_parens(\n         context,\n         callee,\n-        &ptr_vec_to_ref_vec(args),\n+        args.iter(),\n         shape,\n         span,\n         context.config.width_heuristics().fn_call_width,\n         choose_separator_tactic(context, span),\n     )\n }\n \n-fn is_simple_expr(expr: &ast::Expr) -> bool {\n+pub fn is_simple_expr(expr: &ast::Expr) -> bool {\n     match expr.node {\n         ast::ExprKind::Lit(..) => true,\n         ast::ExprKind::Path(ref qself, ref path) => qself.is_none() && path.segments.len() <= 1,\n@@ -1355,10 +1307,8 @@ fn is_simple_expr(expr: &ast::Expr) -> bool {\n     }\n }\n \n-pub fn is_every_expr_simple<T: ToExpr>(lists: &[&T]) -> bool {\n-    lists\n-        .iter()\n-        .all(|arg| arg.to_expr().map_or(false, is_simple_expr))\n+pub fn is_every_expr_simple(lists: &[OverflowableItem]) -> bool {\n+    lists.iter().all(OverflowableItem::is_simple)\n }\n \n pub fn can_be_overflowed_expr(context: &RewriteContext, expr: &ast::Expr, args_len: usize) -> bool {\n@@ -1720,19 +1670,16 @@ pub fn rewrite_field(\n     }\n }\n \n-fn rewrite_tuple_in_visual_indent_style<'a, T>(\n+fn rewrite_tuple_in_visual_indent_style<'a, T: 'a + IntoOverflowableItem<'a>>(\n     context: &RewriteContext,\n-    items: &[&T],\n+    mut items: impl Iterator<Item = &'a T>,\n     span: Span,\n     shape: Shape,\n-) -> Option<String>\n-where\n-    T: Rewrite + Spanned + ToExpr + 'a,\n-{\n-    let mut items = items.iter();\n+    is_singleton_tuple: bool,\n+) -> Option<String> {\n     // In case of length 1, need a trailing comma\n     debug!(\"rewrite_tuple_in_visual_indent_style {:?}\", shape);\n-    if items.len() == 1 {\n+    if is_singleton_tuple {\n         // 3 = \"(\" + \",)\"\n         let nested_shape = shape.sub_width(3)?.visual_indent(1);\n         return items\n@@ -1771,15 +1718,13 @@ where\n     Some(format!(\"({})\", list_str))\n }\n \n-pub fn rewrite_tuple<'a, T>(\n-    context: &RewriteContext,\n-    items: &[&T],\n+pub fn rewrite_tuple<'a, T: 'a + IntoOverflowableItem<'a>>(\n+    context: &'a RewriteContext,\n+    items: impl Iterator<Item = &'a T>,\n     span: Span,\n     shape: Shape,\n-) -> Option<String>\n-where\n-    T: Rewrite + Spanned + ToExpr + 'a,\n-{\n+    is_singleton_tuple: bool,\n+) -> Option<String> {\n     debug!(\"rewrite_tuple {:?}\", shape);\n     if context.use_block_indent() {\n         // We use the same rule as function calls for rewriting tuples.\n@@ -1789,7 +1734,7 @@ where\n             } else {\n                 Some(SeparatorTactic::Never)\n             }\n-        } else if items.len() == 1 {\n+        } else if is_singleton_tuple {\n             Some(SeparatorTactic::Always)\n         } else {\n             None\n@@ -1804,7 +1749,7 @@ where\n             force_tactic,\n         )\n     } else {\n-        rewrite_tuple_in_visual_indent_style(context, items, span, shape)\n+        rewrite_tuple_in_visual_indent_style(context, items, span, shape, is_singleton_tuple)\n     }\n }\n \n@@ -1995,79 +1940,6 @@ fn rewrite_expr_addrof(\n     rewrite_unary_prefix(context, operator_str, expr, shape)\n }\n \n-pub trait ToExpr {\n-    fn to_expr(&self) -> Option<&ast::Expr>;\n-    fn can_be_overflowed(&self, context: &RewriteContext, len: usize) -> bool;\n-}\n-\n-impl ToExpr for ast::Expr {\n-    fn to_expr(&self) -> Option<&ast::Expr> {\n-        Some(self)\n-    }\n-\n-    fn can_be_overflowed(&self, context: &RewriteContext, len: usize) -> bool {\n-        can_be_overflowed_expr(context, self, len)\n-    }\n-}\n-\n-impl ToExpr for ast::Ty {\n-    fn to_expr(&self) -> Option<&ast::Expr> {\n-        None\n-    }\n-\n-    fn can_be_overflowed(&self, context: &RewriteContext, len: usize) -> bool {\n-        can_be_overflowed_type(context, self, len)\n-    }\n-}\n-\n-impl<'a> ToExpr for TuplePatField<'a> {\n-    fn to_expr(&self) -> Option<&ast::Expr> {\n-        None\n-    }\n-\n-    fn can_be_overflowed(&self, context: &RewriteContext, len: usize) -> bool {\n-        can_be_overflowed_pat(context, self, len)\n-    }\n-}\n-\n-impl<'a> ToExpr for ast::StructField {\n-    fn to_expr(&self) -> Option<&ast::Expr> {\n-        None\n-    }\n-\n-    fn can_be_overflowed(&self, _: &RewriteContext, _: usize) -> bool {\n-        false\n-    }\n-}\n-\n-impl<'a> ToExpr for MacroArg {\n-    fn to_expr(&self) -> Option<&ast::Expr> {\n-        match *self {\n-            MacroArg::Expr(ref expr) => Some(expr),\n-            _ => None,\n-        }\n-    }\n-\n-    fn can_be_overflowed(&self, context: &RewriteContext, len: usize) -> bool {\n-        match *self {\n-            MacroArg::Expr(ref expr) => can_be_overflowed_expr(context, expr, len),\n-            MacroArg::Ty(ref ty) => can_be_overflowed_type(context, ty, len),\n-            MacroArg::Pat(..) => false,\n-            MacroArg::Item(..) => len == 1,\n-        }\n-    }\n-}\n-\n-impl ToExpr for ast::GenericParam {\n-    fn to_expr(&self) -> Option<&ast::Expr> {\n-        None\n-    }\n-\n-    fn can_be_overflowed(&self, _: &RewriteContext, _: usize) -> bool {\n-        false\n-    }\n-}\n-\n pub fn is_method_call(expr: &ast::Expr) -> bool {\n     match expr.node {\n         ast::ExprKind::MethodCall(..) => true,"}, {"sha": "f74458fdaa65d2b01331faf7efeb2cc92418e3c5", "filename": "src/items.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d0c6a6d642410b379142cd9e8f271c142882671d/src%2Fitems.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0c6a6d642410b379142cd9e8f271c142882671d/src%2Fitems.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fitems.rs?ref=d0c6a6d642410b379142cd9e8f271c142882671d", "patch": "@@ -1391,11 +1391,10 @@ fn format_tuple_struct(\n         format_empty_struct_or_tuple(context, inner_span, offset, &mut result, \"(\", \")\");\n     } else {\n         let shape = Shape::indented(offset, context.config).sub_width(1)?;\n-        let fields = &fields.iter().collect::<Vec<_>>();\n         result = overflow::rewrite_with_parens(\n             context,\n             &result,\n-            fields,\n+            fields.iter(),\n             shape,\n             span,\n             context.config.width_heuristics().fn_call_width,\n@@ -2492,7 +2491,7 @@ fn rewrite_generics(\n         return Some(ident.to_owned());\n     }\n \n-    let params = &generics.params.iter().map(|e| &*e).collect::<Vec<_>>();\n+    let params = generics.params.iter();\n     overflow::rewrite_with_angle_brackets(context, ident, params, shape, generics.span)\n }\n "}, {"sha": "e77eacb5c346c7a1d614d0e567192e72ebf0f4af", "filename": "src/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d0c6a6d642410b379142cd9e8f271c142882671d/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0c6a6d642410b379142cd9e8f271c142882671d/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=d0c6a6d642410b379142cd9e8f271c142882671d", "patch": "@@ -100,8 +100,7 @@ pub enum ErrorKind {\n     #[fail(\n         display = \"line formatted, but exceeded maximum width \\\n                    (maximum: {} (see `max_width` option), found: {})\",\n-        _0,\n-        _1\n+        _0, _1\n     )]\n     LineOverflow(usize, usize),\n     /// Line ends in whitespace."}, {"sha": "886e929c43f2c17f9b5c3f40c4ebb210dc14fd0e", "filename": "src/macros.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d0c6a6d642410b379142cd9e8f271c142882671d/src%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0c6a6d642410b379142cd9e8f271c142882671d/src%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmacros.rs?ref=d0c6a6d642410b379142cd9e8f271c142882671d", "patch": "@@ -278,7 +278,7 @@ pub fn rewrite_macro_inner(\n             overflow::rewrite_with_parens(\n                 context,\n                 &macro_name,\n-                &arg_vec.iter().map(|e| &*e).collect::<Vec<_>>(),\n+                arg_vec.iter(),\n                 shape,\n                 mac.span,\n                 context.config.width_heuristics().fn_call_width,\n@@ -334,11 +334,9 @@ pub fn rewrite_macro_inner(\n                         force_trailing_comma = Some(SeparatorTactic::Vertical);\n                     };\n                 }\n-                // Convert `MacroArg` into `ast::Expr`, as `rewrite_array` only accepts the latter.\n-                let arg_vec = &arg_vec.iter().map(|e| &*e).collect::<Vec<_>>();\n                 let rewrite = rewrite_array(\n                     macro_name,\n-                    arg_vec,\n+                    arg_vec.iter(),\n                     mac.span,\n                     context,\n                     shape,"}, {"sha": "a7fc9728666769162579e33d9d5aba5a6d785675", "filename": "src/overflow.rs", "status": "modified", "additions": 288, "deletions": 75, "changes": 363, "blob_url": "https://github.com/rust-lang/rust/blob/d0c6a6d642410b379142cd9e8f271c142882671d/src%2Foverflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0c6a6d642410b379142cd9e8f271c142882671d/src%2Foverflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Foverflow.rs?ref=d0c6a6d642410b379142cd9e8f271c142882671d", "patch": "@@ -9,38 +9,248 @@\n // except according to those terms.\n \n //! Rewrite a list some items with overflow.\n-// FIXME: Replace `ToExpr` with some enum.\n \n use config::lists::*;\n-use syntax::ast;\n use syntax::parse::token::DelimToken;\n use syntax::source_map::Span;\n+use syntax::{ast, ptr};\n \n use closures;\n-use expr::{is_every_expr_simple, is_method_call, is_nested_call, maybe_get_args_offset, ToExpr};\n+use expr::{\n+    can_be_overflowed_expr, is_every_expr_simple, is_method_call, is_nested_call, is_simple_expr,\n+};\n use lists::{definitive_tactic, itemize_list, write_list, ListFormatting, ListItem, Separator};\n+use macros::MacroArg;\n+use patterns::{can_be_overflowed_pat, TuplePatField};\n use rewrite::{Rewrite, RewriteContext};\n use shape::Shape;\n use source_map::SpanUtils;\n use spanned::Spanned;\n+use types::{can_be_overflowed_type, SegmentParam};\n use utils::{count_newlines, extra_offset, first_line_width, last_line_width, mk_sp};\n \n use std::cmp::min;\n \n const SHORT_ITEM_THRESHOLD: usize = 10;\n \n-pub fn rewrite_with_parens<T>(\n-    context: &RewriteContext,\n-    ident: &str,\n-    items: &[&T],\n+/// A list of `format!`-like macros, that take a long format string and a list of arguments to\n+/// format.\n+///\n+/// Organized as a list of `(&str, usize)` tuples, giving the name of the macro and the number of\n+/// arguments before the format string (none for `format!(\"format\", ...)`, one for `assert!(result,\n+/// \"format\", ...)`, two for `assert_eq!(left, right, \"format\", ...)`).\n+const SPECIAL_MACRO_WHITELIST: &[(&str, usize)] = &[\n+    // format! like macros\n+    // From the Rust Standard Library.\n+    (\"eprint!\", 0),\n+    (\"eprintln!\", 0),\n+    (\"format!\", 0),\n+    (\"format_args!\", 0),\n+    (\"print!\", 0),\n+    (\"println!\", 0),\n+    (\"panic!\", 0),\n+    (\"unreachable!\", 0),\n+    // From the `log` crate.\n+    (\"debug!\", 0),\n+    (\"error!\", 0),\n+    (\"info!\", 0),\n+    (\"warn!\", 0),\n+    // write! like macros\n+    (\"assert!\", 1),\n+    (\"debug_assert!\", 1),\n+    (\"write!\", 1),\n+    (\"writeln!\", 1),\n+    // assert_eq! like macros\n+    (\"assert_eq!\", 2),\n+    (\"assert_ne!\", 2),\n+    (\"debug_assert_eq!\", 2),\n+    (\"debug_assert_ne!\", 2),\n+];\n+\n+const SPECIAL_ATTR_WHITELIST: &[(&str, usize)] = &[\n+    // From the `failure` crate.\n+    (\"fail\", 0),\n+];\n+\n+#[derive(Debug)]\n+pub enum OverflowableItem<'a> {\n+    Expr(&'a ast::Expr),\n+    GenericParam(&'a ast::GenericParam),\n+    MacroArg(&'a MacroArg),\n+    NestedMetaItem(&'a ast::NestedMetaItem),\n+    SegmentParam(&'a SegmentParam<'a>),\n+    StructField(&'a ast::StructField),\n+    TuplePatField(&'a TuplePatField<'a>),\n+    Ty(&'a ast::Ty),\n+}\n+\n+impl<'a> Rewrite for OverflowableItem<'a> {\n+    fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n+        self.map(|item| item.rewrite(context, shape))\n+    }\n+}\n+\n+impl<'a> Spanned for OverflowableItem<'a> {\n+    fn span(&self) -> Span {\n+        self.map(|item| item.span())\n+    }\n+}\n+\n+impl<'a> OverflowableItem<'a> {\n+    pub fn map<F, T>(&self, f: F) -> T\n+    where\n+        F: Fn(&IntoOverflowableItem<'a>) -> T,\n+    {\n+        match self {\n+            OverflowableItem::Expr(expr) => f(*expr),\n+            OverflowableItem::GenericParam(gp) => f(*gp),\n+            OverflowableItem::MacroArg(macro_arg) => f(*macro_arg),\n+            OverflowableItem::NestedMetaItem(nmi) => f(*nmi),\n+            OverflowableItem::SegmentParam(sp) => f(*sp),\n+            OverflowableItem::StructField(sf) => f(*sf),\n+            OverflowableItem::TuplePatField(pat) => f(*pat),\n+            OverflowableItem::Ty(ty) => f(*ty),\n+        }\n+    }\n+\n+    pub fn is_simple(&self) -> bool {\n+        match self {\n+            OverflowableItem::Expr(expr) => is_simple_expr(expr),\n+            OverflowableItem::MacroArg(MacroArg::Expr(expr)) => is_simple_expr(expr),\n+            OverflowableItem::NestedMetaItem(nested_meta_item) => match nested_meta_item.node {\n+                ast::NestedMetaItemKind::Literal(..) => true,\n+                ast::NestedMetaItemKind::MetaItem(ref meta_item) => match meta_item.node {\n+                    ast::MetaItemKind::Word => true,\n+                    _ => false,\n+                },\n+            },\n+            _ => false,\n+        }\n+    }\n+\n+    pub fn is_expr(&self) -> bool {\n+        match self {\n+            OverflowableItem::Expr(..) => true,\n+            OverflowableItem::MacroArg(MacroArg::Expr(..)) => true,\n+            _ => false,\n+        }\n+    }\n+\n+    pub fn is_nested_call(&self) -> bool {\n+        match self {\n+            OverflowableItem::Expr(expr) => is_nested_call(expr),\n+            OverflowableItem::MacroArg(MacroArg::Expr(expr)) => is_nested_call(expr),\n+            _ => false,\n+        }\n+    }\n+\n+    pub fn to_expr(&self) -> Option<&'a ast::Expr> {\n+        match self {\n+            OverflowableItem::Expr(expr) => Some(expr),\n+            OverflowableItem::MacroArg(macro_arg) => match macro_arg {\n+                MacroArg::Expr(ref expr) => Some(expr),\n+                _ => None,\n+            },\n+            _ => None,\n+        }\n+    }\n+\n+    pub fn can_be_overflowed(&self, context: &RewriteContext, len: usize) -> bool {\n+        match self {\n+            OverflowableItem::Expr(expr) => can_be_overflowed_expr(context, expr, len),\n+            OverflowableItem::MacroArg(macro_arg) => match macro_arg {\n+                MacroArg::Expr(ref expr) => can_be_overflowed_expr(context, expr, len),\n+                MacroArg::Ty(ref ty) => can_be_overflowed_type(context, ty, len),\n+                MacroArg::Pat(..) => false,\n+                MacroArg::Item(..) => len == 1,\n+            },\n+            OverflowableItem::NestedMetaItem(nested_meta_item) if len == 1 => {\n+                match nested_meta_item.node {\n+                    ast::NestedMetaItemKind::Literal(..) => false,\n+                    ast::NestedMetaItemKind::MetaItem(..) => true,\n+                }\n+            }\n+            OverflowableItem::SegmentParam(seg) => match seg {\n+                SegmentParam::Type(ty) => can_be_overflowed_type(context, ty, len),\n+                _ => false,\n+            },\n+            OverflowableItem::TuplePatField(pat) => can_be_overflowed_pat(context, pat, len),\n+            OverflowableItem::Ty(ty) => can_be_overflowed_type(context, ty, len),\n+            _ => false,\n+        }\n+    }\n+\n+    fn whitelist(&self) -> &'static [(&'static str, usize)] {\n+        match self {\n+            OverflowableItem::MacroArg(..) => SPECIAL_MACRO_WHITELIST,\n+            OverflowableItem::NestedMetaItem(..) => SPECIAL_ATTR_WHITELIST,\n+            _ => &[],\n+        }\n+    }\n+}\n+\n+pub trait IntoOverflowableItem<'a>: Rewrite + Spanned {\n+    fn into_overflowable_item(&'a self) -> OverflowableItem<'a>;\n+}\n+\n+impl<'a, T: 'a + IntoOverflowableItem<'a>> IntoOverflowableItem<'a> for ptr::P<T> {\n+    fn into_overflowable_item(&'a self) -> OverflowableItem<'a> {\n+        (**self).into_overflowable_item()\n+    }\n+}\n+\n+macro impl_into_overflowable_item_for_ast_node {\n+    ($($ast_node:ident),*) => {\n+        $(\n+            impl<'a> IntoOverflowableItem<'a> for ast::$ast_node {\n+                fn into_overflowable_item(&'a self) -> OverflowableItem<'a> {\n+                    OverflowableItem::$ast_node(self)\n+                }\n+            }\n+        )*\n+    }\n+}\n+\n+macro impl_into_overflowable_item_for_rustfmt_types {\n+    ([$($ty:ident),*], [$($ty_with_lifetime:ident),*]) => {\n+        $(\n+            impl<'a> IntoOverflowableItem<'a> for $ty {\n+                fn into_overflowable_item(&'a self) -> OverflowableItem<'a> {\n+                    OverflowableItem::$ty(self)\n+                }\n+            }\n+        )*\n+        $(\n+            impl<'a> IntoOverflowableItem<'a> for $ty_with_lifetime<'a> {\n+                fn into_overflowable_item(&'a self) -> OverflowableItem<'a> {\n+                    OverflowableItem::$ty_with_lifetime(self)\n+                }\n+            }\n+        )*\n+    }\n+}\n+\n+impl_into_overflowable_item_for_ast_node!(Expr, GenericParam, NestedMetaItem, StructField, Ty);\n+impl_into_overflowable_item_for_rustfmt_types!([MacroArg], [SegmentParam, TuplePatField]);\n+\n+pub fn into_overflowable_list<'a, T>(\n+    iter: impl Iterator<Item = &'a T>,\n+) -> impl Iterator<Item = OverflowableItem<'a>>\n+where\n+    T: 'a + IntoOverflowableItem<'a>,\n+{\n+    iter.map(|x| IntoOverflowableItem::into_overflowable_item(x))\n+}\n+\n+pub fn rewrite_with_parens<'a, T: 'a + IntoOverflowableItem<'a>>(\n+    context: &'a RewriteContext,\n+    ident: &'a str,\n+    items: impl Iterator<Item = &'a T>,\n     shape: Shape,\n     span: Span,\n     item_max_width: usize,\n     force_separator_tactic: Option<SeparatorTactic>,\n-) -> Option<String>\n-where\n-    T: Rewrite + ToExpr + Spanned,\n-{\n+) -> Option<String> {\n     Context::new(\n         context,\n         items,\n@@ -56,16 +266,13 @@ where\n     .rewrite(shape)\n }\n \n-pub fn rewrite_with_angle_brackets<T>(\n-    context: &RewriteContext,\n-    ident: &str,\n-    items: &[&T],\n+pub fn rewrite_with_angle_brackets<'a, T: 'a + IntoOverflowableItem<'a>>(\n+    context: &'a RewriteContext,\n+    ident: &'a str,\n+    items: impl Iterator<Item = &'a T>,\n     shape: Shape,\n     span: Span,\n-) -> Option<String>\n-where\n-    T: Rewrite + ToExpr + Spanned,\n-{\n+) -> Option<String> {\n     Context::new(\n         context,\n         items,\n@@ -81,18 +288,15 @@ where\n     .rewrite(shape)\n }\n \n-pub fn rewrite_with_square_brackets<T>(\n-    context: &RewriteContext,\n-    name: &str,\n-    items: &[&T],\n+pub fn rewrite_with_square_brackets<'a, T: 'a + IntoOverflowableItem<'a>>(\n+    context: &'a RewriteContext,\n+    name: &'a str,\n+    items: impl Iterator<Item = &'a T>,\n     shape: Shape,\n     span: Span,\n     force_separator_tactic: Option<SeparatorTactic>,\n     delim_token: Option<DelimToken>,\n-) -> Option<String>\n-where\n-    T: Rewrite + ToExpr + Spanned,\n-{\n+) -> Option<String> {\n     let (lhs, rhs) = match delim_token {\n         Some(DelimToken::Paren) => (\"(\", \")\"),\n         Some(DelimToken::Brace) => (\"{\", \"}\"),\n@@ -113,9 +317,9 @@ where\n     .rewrite(shape)\n }\n \n-struct Context<'a, T: 'a> {\n+struct Context<'a> {\n     context: &'a RewriteContext<'a>,\n-    items: &'a [&'a T],\n+    items: Vec<OverflowableItem<'a>>,\n     ident: &'a str,\n     prefix: &'static str,\n     suffix: &'static str,\n@@ -128,10 +332,10 @@ struct Context<'a, T: 'a> {\n     custom_delims: Option<(&'a str, &'a str)>,\n }\n \n-impl<'a, T: 'a + Rewrite + ToExpr + Spanned> Context<'a, T> {\n-    pub fn new(\n+impl<'a> Context<'a> {\n+    pub fn new<T: 'a + IntoOverflowableItem<'a>>(\n         context: &'a RewriteContext,\n-        items: &'a [&'a T],\n+        items: impl Iterator<Item = &'a T>,\n         ident: &'a str,\n         shape: Shape,\n         span: Span,\n@@ -140,7 +344,7 @@ impl<'a, T: 'a + Rewrite + ToExpr + Spanned> Context<'a, T> {\n         item_max_width: usize,\n         force_separator_tactic: Option<SeparatorTactic>,\n         custom_delims: Option<(&'a str, &'a str)>,\n-    ) -> Context<'a, T> {\n+    ) -> Context<'a> {\n         let used_width = extra_offset(ident, shape);\n         // 1 = `()`\n         let one_line_width = shape.width.saturating_sub(used_width + 2);\n@@ -153,7 +357,7 @@ impl<'a, T: 'a + Rewrite + ToExpr + Spanned> Context<'a, T> {\n         let nested_shape = shape_from_indent_style(context, shape, used_width + 2, used_width + 1);\n         Context {\n             context,\n-            items,\n+            items: into_overflowable_list(items).collect(),\n             ident,\n             one_line_shape,\n             nested_shape,\n@@ -167,7 +371,7 @@ impl<'a, T: 'a + Rewrite + ToExpr + Spanned> Context<'a, T> {\n         }\n     }\n \n-    fn last_item(&self) -> Option<&&T> {\n+    fn last_item(&self) -> Option<&OverflowableItem> {\n         self.items.last()\n     }\n \n@@ -185,23 +389,24 @@ impl<'a, T: 'a + Rewrite + ToExpr + Spanned> Context<'a, T> {\n         shape: Shape,\n     ) -> Option<String> {\n         let last_item = self.last_item()?;\n-        let rewrite = if let Some(expr) = last_item.to_expr() {\n-            match expr.node {\n-                // When overflowing the closure which consists of a single control flow expression,\n-                // force to use block if its condition uses multi line.\n-                ast::ExprKind::Closure(..) => {\n-                    // If the argument consists of multiple closures, we do not overflow\n-                    // the last closure.\n-                    if closures::args_have_many_closure(self.items) {\n-                        None\n-                    } else {\n-                        closures::rewrite_last_closure(self.context, expr, shape)\n+        let rewrite = match last_item {\n+            OverflowableItem::Expr(ref expr) => {\n+                match expr.node {\n+                    // When overflowing the closure which consists of a single control flow\n+                    // expression, force to use block if its condition uses multi line.\n+                    ast::ExprKind::Closure(..) => {\n+                        // If the argument consists of multiple closures, we do not overflow\n+                        // the last closure.\n+                        if closures::args_have_many_closure(&self.items) {\n+                            None\n+                        } else {\n+                            closures::rewrite_last_closure(self.context, expr, shape)\n+                        }\n                     }\n+                    _ => expr.rewrite(self.context, shape),\n                 }\n-                _ => expr.rewrite(self.context, shape),\n             }\n-        } else {\n-            last_item.rewrite(self.context, shape)\n+            item @ _ => item.rewrite(self.context, shape),\n         };\n \n         if let Some(rewrite) = rewrite {\n@@ -225,23 +430,24 @@ impl<'a, T: 'a + Rewrite + ToExpr + Spanned> Context<'a, T> {\n     fn try_overflow_last_item(&self, list_items: &mut Vec<ListItem>) -> DefinitiveListTactic {\n         // 1 = \"(\"\n         let combine_arg_with_callee = self.items.len() == 1\n-            && self.items[0].to_expr().is_some()\n+            && self.items[0].is_expr()\n             && self.ident.len() < self.context.config.tab_spaces();\n-        let overflow_last = combine_arg_with_callee || can_be_overflowed(self.context, self.items);\n+        let overflow_last = combine_arg_with_callee || can_be_overflowed(self.context, &self.items);\n \n         // Replace the last item with its first line to see if it fits with\n         // first arguments.\n         let placeholder = if overflow_last {\n             let old_value = *self.context.force_one_line_chain.borrow();\n-            if !combine_arg_with_callee {\n-                if let Some(ref expr) = self.last_item().and_then(|item| item.to_expr()) {\n-                    if is_method_call(expr) {\n-                        self.context.force_one_line_chain.replace(true);\n-                    }\n+            match self.last_item() {\n+                Some(OverflowableItem::Expr(expr))\n+                    if !combine_arg_with_callee && is_method_call(expr) =>\n+                {\n+                    self.context.force_one_line_chain.replace(true);\n                 }\n+                _ => (),\n             }\n             let result = last_item_shape(\n-                self.items,\n+                &self.items,\n                 list_items,\n                 self.one_line_shape,\n                 self.item_max_width,\n@@ -316,7 +522,7 @@ impl<'a, T: 'a + Rewrite + ToExpr + Spanned> Context<'a, T> {\n \n                     if tactic == DefinitiveListTactic::Vertical {\n                         if let Some((all_simple, num_args_before)) =\n-                            maybe_get_args_offset(self.ident, self.items)\n+                            maybe_get_args_offset(self.ident, &self.items)\n                         {\n                             let one_line = all_simple\n                                 && definitive_tactic(\n@@ -335,7 +541,7 @@ impl<'a, T: 'a + Rewrite + ToExpr + Spanned> Context<'a, T> {\n                             if one_line {\n                                 tactic = DefinitiveListTactic::SpecialMacro(num_args_before);\n                             };\n-                        } else if is_every_expr_simple(self.items) && no_long_items(list_items) {\n+                        } else if is_every_expr_simple(&self.items) && no_long_items(list_items) {\n                             tactic = DefinitiveListTactic::Mixed;\n                         }\n                     }\n@@ -465,31 +671,20 @@ fn need_block_indent(s: &str, shape: Shape) -> bool {\n     })\n }\n \n-fn can_be_overflowed<'a, T>(context: &RewriteContext, items: &[&T]) -> bool\n-where\n-    T: Rewrite + Spanned + ToExpr + 'a,\n-{\n+fn can_be_overflowed<'a>(context: &RewriteContext, items: &[OverflowableItem]) -> bool {\n     items\n         .last()\n         .map_or(false, |x| x.can_be_overflowed(context, items.len()))\n }\n \n /// Returns a shape for the last argument which is going to be overflowed.\n-fn last_item_shape<T>(\n-    lists: &[&T],\n+fn last_item_shape(\n+    lists: &[OverflowableItem],\n     items: &[ListItem],\n     shape: Shape,\n     args_max_width: usize,\n-) -> Option<Shape>\n-where\n-    T: Rewrite + Spanned + ToExpr,\n-{\n-    let is_nested_call = lists\n-        .iter()\n-        .next()\n-        .and_then(|item| item.to_expr())\n-        .map_or(false, is_nested_call);\n-    if items.len() == 1 && !is_nested_call {\n+) -> Option<Shape> {\n+    if items.len() == 1 && !lists.get(0)?.is_nested_call() {\n         return Some(shape);\n     }\n     let offset = items.iter().rev().skip(1).fold(0, |acc, i| {\n@@ -528,3 +723,21 @@ fn no_long_items(list: &[ListItem]) -> bool {\n     list.iter()\n         .all(|item| item.inner_as_ref().len() <= SHORT_ITEM_THRESHOLD)\n }\n+\n+/// In case special-case style is required, returns an offset from which we start horizontal layout.\n+pub fn maybe_get_args_offset(callee_str: &str, args: &[OverflowableItem]) -> Option<(bool, usize)> {\n+    if let Some(&(_, num_args_before)) = args\n+        .get(0)?\n+        .whitelist()\n+        .iter()\n+        .find(|&&(s, _)| s == callee_str)\n+    {\n+        let all_simple = args.len() > num_args_before\n+            && is_every_expr_simple(&args[0..num_args_before])\n+            && is_every_expr_simple(&args[num_args_before + 1..]);\n+\n+        Some((all_simple, num_args_before))\n+    } else {\n+        None\n+    }\n+}"}, {"sha": "bd4af3f7bba41c83db630d040aaefcec13e7abfe", "filename": "src/patterns.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d0c6a6d642410b379142cd9e8f271c142882671d/src%2Fpatterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0c6a6d642410b379142cd9e8f271c142882671d/src%2Fpatterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fpatterns.rs?ref=d0c6a6d642410b379142cd9e8f271c142882671d", "patch": "@@ -264,6 +264,7 @@ impl Rewrite for FieldPat {\n     }\n }\n \n+#[derive(Debug)]\n pub enum TuplePatField<'a> {\n     Pat(&'a ptr::P<ast::Pat>),\n     Dotdot(Span),\n@@ -359,12 +360,11 @@ fn rewrite_tuple_pat(\n     // add comma if `(x,)`\n     let add_comma = path_str.is_none() && pat_vec.len() == 1 && dotdot_pos.is_none() && !condensed;\n     let path_str = path_str.unwrap_or_default();\n-    let pat_ref_vec = pat_vec.iter().collect::<Vec<_>>();\n \n     overflow::rewrite_with_parens(\n         &context,\n         &path_str,\n-        &pat_ref_vec,\n+        pat_vec.iter(),\n         shape,\n         span,\n         context.config.max_width(),"}, {"sha": "d151c922e812a18512ef48c1bb885dc72d9c521a", "filename": "src/rewrite.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d0c6a6d642410b379142cd9e8f271c142882671d/src%2Frewrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0c6a6d642410b379142cd9e8f271c142882671d/src%2Frewrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frewrite.rs?ref=d0c6a6d642410b379142cd9e8f271c142882671d", "patch": "@@ -11,6 +11,7 @@\n // A generic trait to abstract the rewriting of an element (of the AST).\n \n use syntax::parse::ParseSess;\n+use syntax::ptr;\n use syntax::source_map::{SourceMap, Span};\n \n use config::{Config, IndentStyle};\n@@ -25,6 +26,12 @@ pub trait Rewrite {\n     fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String>;\n }\n \n+impl<T: Rewrite> Rewrite for ptr::P<T> {\n+    fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n+        (**self).rewrite(context, shape)\n+    }\n+}\n+\n #[derive(Clone)]\n pub struct RewriteContext<'a> {\n     pub parse_session: &'a ParseSess,"}, {"sha": "2488f3b428d80e565275040332ea1d3bd4efa946", "filename": "src/spanned.rs", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d0c6a6d642410b379142cd9e8f271c142882671d/src%2Fspanned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0c6a6d642410b379142cd9e8f271c142882671d/src%2Fspanned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fspanned.rs?ref=d0c6a6d642410b379142cd9e8f271c142882671d", "patch": "@@ -8,8 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use syntax::ast;\n-use syntax::source_map::Span;\n+use syntax::{\n+    ast, ptr,\n+    source_map::{self, Span},\n+};\n \n use macros::MacroArg;\n use utils::{mk_sp, outer_attributes};\n@@ -21,6 +23,18 @@ pub trait Spanned {\n     fn span(&self) -> Span;\n }\n \n+impl<T: Spanned> Spanned for ptr::P<T> {\n+    fn span(&self) -> Span {\n+        (**self).span()\n+    }\n+}\n+\n+impl<T> Spanned for source_map::Spanned<T> {\n+    fn span(&self) -> Span {\n+        self.span\n+    }\n+}\n+\n macro_rules! span_with_attrs_lo_hi {\n     ($this:ident, $lo:expr, $hi:expr) => {{\n         let attrs = outer_attributes(&$this.attrs);"}, {"sha": "e7282c13317ed0faecc1d7198fc14fb54545fb74", "filename": "src/types.rs", "status": "modified", "additions": 6, "deletions": 22, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/d0c6a6d642410b379142cd9e8f271c142882671d/src%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0c6a6d642410b379142cd9e8f271c142882671d/src%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftypes.rs?ref=d0c6a6d642410b379142cd9e8f271c142882671d", "patch": "@@ -17,7 +17,7 @@ use syntax::source_map::{self, BytePos, Span};\n use syntax::symbol::keywords;\n \n use config::{IndentStyle, TypeDensity};\n-use expr::{rewrite_assign_rhs, rewrite_tuple, rewrite_unary_prefix, ToExpr};\n+use expr::{rewrite_assign_rhs, rewrite_tuple, rewrite_unary_prefix};\n use lists::{definitive_tactic, itemize_list, write_list, ListFormatting, Separator};\n use macros::{rewrite_macro, MacroPosition};\n use overflow;\n@@ -141,7 +141,7 @@ where\n }\n \n #[derive(Debug)]\n-enum SegmentParam<'a> {\n+pub enum SegmentParam<'a> {\n     LifeTime(&'a ast::Lifetime),\n     Type(&'a ast::Ty),\n     Binding(&'a ast::TypeBinding),\n@@ -166,19 +166,6 @@ impl<'a> Spanned for SegmentParam<'a> {\n     }\n }\n \n-impl<'a> ToExpr for SegmentParam<'a> {\n-    fn to_expr(&self) -> Option<&ast::Expr> {\n-        None\n-    }\n-\n-    fn can_be_overflowed(&self, context: &RewriteContext, len: usize) -> bool {\n-        match *self {\n-            SegmentParam::Type(ty) => ty.can_be_overflowed(context, len),\n-            _ => false,\n-        }\n-    }\n-}\n-\n impl<'a> Rewrite for SegmentParam<'a> {\n     fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n         match *self {\n@@ -252,7 +239,7 @@ fn rewrite_segment(\n                 let generics_str = overflow::rewrite_with_angle_brackets(\n                     context,\n                     \"\",\n-                    &param_list.iter().map(|e| &*e).collect::<Vec<_>>(),\n+                    param_list.iter(),\n                     shape,\n                     mk_sp(*span_lo, span_hi),\n                 )?;\n@@ -664,12 +651,9 @@ impl Rewrite for ast::Ty {\n                 ty.rewrite(context, Shape::legacy(budget, shape.indent + 1))\n                     .map(|ty_str| format!(\"[{}]\", ty_str))\n             }\n-            ast::TyKind::Tup(ref items) => rewrite_tuple(\n-                context,\n-                &::utils::ptr_vec_to_ref_vec(items),\n-                self.span,\n-                shape,\n-            ),\n+            ast::TyKind::Tup(ref items) => {\n+                rewrite_tuple(context, items.iter(), self.span, shape, items.len() == 1)\n+            }\n             ast::TyKind::Path(ref q_self, ref path) => {\n                 rewrite_path(context, PathContext::Type, q_self.as_ref(), path, shape)\n             }"}, {"sha": "57809b143f5146b3e389893c944b6164dd0534e3", "filename": "tests/target/enum.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d0c6a6d642410b379142cd9e8f271c142882671d/tests%2Ftarget%2Fenum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0c6a6d642410b379142cd9e8f271c142882671d/tests%2Ftarget%2Fenum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fenum.rs?ref=d0c6a6d642410b379142cd9e8f271c142882671d", "patch": "@@ -256,9 +256,7 @@ pub enum QlError {\n     // (kind, input, expected)\n     #[fail(\n         display = \"Could not find {}: Found: {}, expected: {:?}\",\n-        0,\n-        1,\n-        2\n+        0, 1, 2\n     )]\n     ResolveError(&'static str, String, Option<String>),\n }"}]}