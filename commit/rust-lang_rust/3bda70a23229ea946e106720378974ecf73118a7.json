{"sha": "3bda70a23229ea946e106720378974ecf73118a7", "node_id": "C_kwDOAAsO6NoAKDNiZGE3MGEyMzIyOWVhOTQ2ZTEwNjcyMDM3ODk3NGVjZjczMTE4YTc", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-04-20T12:11:09Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-04-20T12:11:09Z"}, "message": "Auto merge of #12041 - jonas-schievink:prefer-core-cfg-attr-no-std, r=jonas-schievink\n\nfeat: prefer core/alloc over std in auto-imports if `#[no_std]` is conditional\n\nWe already did this if `#![no_std]` was present, this PR makes it work with `#![cfg_attr(not(test), no_std)]` too, which is very common in libraries.\n\nFixes https://github.com/rust-lang/rust-analyzer/issues/12035\ncc https://github.com/rust-lang/rust-analyzer/issues/10718", "tree": {"sha": "e8a019ceaa6d476cdae3ab59712ea060cb10a309", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e8a019ceaa6d476cdae3ab59712ea060cb10a309"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3bda70a23229ea946e106720378974ecf73118a7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3bda70a23229ea946e106720378974ecf73118a7", "html_url": "https://github.com/rust-lang/rust/commit/3bda70a23229ea946e106720378974ecf73118a7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3bda70a23229ea946e106720378974ecf73118a7/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "34c3e0b0672f8a2bed571b844f1ace6f83f5fae3", "url": "https://api.github.com/repos/rust-lang/rust/commits/34c3e0b0672f8a2bed571b844f1ace6f83f5fae3", "html_url": "https://github.com/rust-lang/rust/commit/34c3e0b0672f8a2bed571b844f1ace6f83f5fae3"}, {"sha": "dd4a92176ceb35ddc0014bdb452be00b26a1fc9e", "url": "https://api.github.com/repos/rust-lang/rust/commits/dd4a92176ceb35ddc0014bdb452be00b26a1fc9e", "html_url": "https://github.com/rust-lang/rust/commit/dd4a92176ceb35ddc0014bdb452be00b26a1fc9e"}], "stats": {"total": 70, "additions": 66, "deletions": 4}, "files": [{"sha": "df6dcb024b5eafb9b71b12d7517903b075da81de", "filename": "crates/hir_def/src/db.rs", "status": "modified", "additions": 38, "deletions": 1, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/3bda70a23229ea946e106720378974ecf73118a7/crates%2Fhir_def%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bda70a23229ea946e106720378974ecf73118a7/crates%2Fhir_def%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fdb.rs?ref=3bda70a23229ea946e106720378974ecf73118a7", "patch": "@@ -18,7 +18,7 @@ use crate::{\n     generics::GenericParams,\n     import_map::ImportMap,\n     intern::Interned,\n-    item_tree::ItemTree,\n+    item_tree::{AttrOwner, ItemTree},\n     lang_item::{LangItemTarget, LangItems},\n     nameres::DefMap,\n     visibility::{self, Visibility},\n@@ -184,6 +184,8 @@ pub trait DefDatabase: InternDatabase + AstDatabase + Upcast<dyn AstDatabase> {\n \n     #[salsa::transparent]\n     fn crate_limits(&self, crate_id: CrateId) -> CrateLimits;\n+\n+    fn crate_supports_no_std(&self, crate_id: CrateId) -> bool;\n }\n \n fn crate_def_map_wait(db: &dyn DefDatabase, krate: CrateId) -> Arc<DefMap> {\n@@ -204,3 +206,38 @@ fn crate_limits(db: &dyn DefDatabase, crate_id: CrateId) -> CrateLimits {\n         recursion_limit: def_map.recursion_limit().unwrap_or(128),\n     }\n }\n+\n+fn crate_supports_no_std(db: &dyn DefDatabase, crate_id: CrateId) -> bool {\n+    let file = db.crate_graph()[crate_id].root_file_id;\n+    let item_tree = db.file_item_tree(file.into());\n+    let attrs = item_tree.raw_attrs(AttrOwner::TopLevel);\n+    for attr in &**attrs {\n+        match attr.path().as_ident().and_then(|id| id.as_text()) {\n+            Some(ident) if ident == \"no_std\" => return true,\n+            Some(ident) if ident == \"cfg_attr\" => {}\n+            _ => continue,\n+        }\n+\n+        // This is a `cfg_attr`; check if it could possibly expand to `no_std`.\n+        // Syntax is: `#[cfg_attr(condition(cfg, style), attr0, attr1, <...>)]`\n+        let tt = match attr.token_tree_value() {\n+            Some(tt) => &tt.token_trees,\n+            None => continue,\n+        };\n+\n+        let segments = tt.split(|tt| match tt {\n+            tt::TokenTree::Leaf(tt::Leaf::Punct(p)) if p.char == ',' => true,\n+            _ => false,\n+        });\n+        for output in segments.skip(1) {\n+            match output {\n+                [tt::TokenTree::Leaf(tt::Leaf::Ident(ident))] if ident.text == \"no_std\" => {\n+                    return true\n+                }\n+                _ => {}\n+            }\n+        }\n+    }\n+\n+    false\n+}"}, {"sha": "89e961f84fad26f9d22374b16b1711ac2a3c659d", "filename": "crates/hir_def/src/find_path.rs", "status": "modified", "additions": 28, "deletions": 3, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/3bda70a23229ea946e106720378974ecf73118a7/crates%2Fhir_def%2Fsrc%2Ffind_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bda70a23229ea946e106720378974ecf73118a7/crates%2Fhir_def%2Fsrc%2Ffind_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Ffind_path.rs?ref=3bda70a23229ea946e106720378974ecf73118a7", "patch": "@@ -43,8 +43,7 @@ impl ModPathExt for ModPath {\n         self.segments().first() == Some(&known::std)\n     }\n \n-    // When std library is present, paths starting with `std::`\n-    // should be preferred over paths starting with `core::` and `alloc::`\n+    // Can we replace the first segment with `std::` and still get a valid, identical path?\n     fn can_start_with_std(&self) -> bool {\n         let first_segment = self.segments().first();\n         first_segment == Some(&known::alloc) || first_segment == Some(&known::core)\n@@ -203,7 +202,7 @@ fn find_path_inner_(\n     }\n \n     // - otherwise, look for modules containing (reexporting) it and import it from one of those\n-    let prefer_no_std = db.attrs(crate_root.into()).by_key(\"no_std\").exists();\n+    let prefer_no_std = db.crate_supports_no_std(crate_root.krate);\n     let mut best_path = None;\n     let mut best_path_len = max_len;\n \n@@ -830,6 +829,32 @@ pub mod fmt {\n \n //- /zzz.rs crate:core\n \n+pub mod fmt {\n+    pub struct Error;\n+}\n+        \"#,\n+            \"core::fmt::Error\",\n+            \"core::fmt::Error\",\n+            \"core::fmt::Error\",\n+            \"core::fmt::Error\",\n+        );\n+\n+        // Should also work (on a best-effort basis) if `no_std` is conditional.\n+        check_found_path(\n+            r#\"\n+//- /main.rs crate:main deps:core,std\n+#![cfg_attr(not(test), no_std)]\n+\n+$0\n+\n+//- /std.rs crate:std deps:core\n+\n+pub mod fmt {\n+    pub use core::fmt::Error;\n+}\n+\n+//- /zzz.rs crate:core\n+\n pub mod fmt {\n     pub struct Error;\n }"}]}