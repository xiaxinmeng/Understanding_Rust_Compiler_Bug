{"sha": "29979ad0439dff3a9e8e3e74fda6c4f300f69df8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI5OTc5YWQwNDM5ZGZmM2E5ZThlM2U3NGZkYTZjNGYzMDBmNjlkZjg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-10-24T23:09:14Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-10-24T23:09:14Z"}, "message": "Auto merge of #6190 - montrivo:manual_result_unwrap_or, r=ebroto\n\nmanual_unwrap_or / support Result::unwrap_or\n\nImplements partially #5923.\n\nchangelog: support Result::unwrap_or in manual_unwrap_or", "tree": {"sha": "5a1e494657ea537c0095ed2c337cdb19be6b56cb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5a1e494657ea537c0095ed2c337cdb19be6b56cb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/29979ad0439dff3a9e8e3e74fda6c4f300f69df8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/29979ad0439dff3a9e8e3e74fda6c4f300f69df8", "html_url": "https://github.com/rust-lang/rust/commit/29979ad0439dff3a9e8e3e74fda6c4f300f69df8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/29979ad0439dff3a9e8e3e74fda6c4f300f69df8/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5c78d26e5e4d96d346e9c365b71ad59449782958", "url": "https://api.github.com/repos/rust-lang/rust/commits/5c78d26e5e4d96d346e9c365b71ad59449782958", "html_url": "https://github.com/rust-lang/rust/commit/5c78d26e5e4d96d346e9c365b71ad59449782958"}, {"sha": "0d21ae0e194fd8f7f1f67bf1921910e0ca21a32c", "url": "https://api.github.com/repos/rust-lang/rust/commits/0d21ae0e194fd8f7f1f67bf1921910e0ca21a32c", "html_url": "https://github.com/rust-lang/rust/commit/0d21ae0e194fd8f7f1f67bf1921910e0ca21a32c"}], "stats": {"total": 348, "additions": 311, "deletions": 37}, "files": [{"sha": "22aa37e41fec0e4124b7b3ba316c4bfc91e777f9", "filename": "clippy_lints/src/manual_unwrap_or.rs", "status": "modified", "additions": 52, "deletions": 28, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/29979ad0439dff3a9e8e3e74fda6c4f300f69df8/clippy_lints%2Fsrc%2Fmanual_unwrap_or.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29979ad0439dff3a9e8e3e74fda6c4f300f69df8/clippy_lints%2Fsrc%2Fmanual_unwrap_or.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmanual_unwrap_or.rs?ref=29979ad0439dff3a9e8e3e74fda6c4f300f69df8", "patch": "@@ -1,16 +1,17 @@\n use crate::consts::constant_simple;\n use crate::utils;\n+use crate::utils::sugg;\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n-use rustc_hir::{def, Arm, Expr, ExprKind, PatKind, QPath};\n+use rustc_hir::{def, Arm, Expr, ExprKind, Pat, PatKind, QPath};\n use rustc_lint::LintContext;\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::lint::in_external_macro;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n \n declare_clippy_lint! {\n     /// **What it does:**\n-    /// Finds patterns that reimplement `Option::unwrap_or`.\n+    /// Finds patterns that reimplement `Option::unwrap_or` or `Result::unwrap_or`.\n     ///\n     /// **Why is this bad?**\n     /// Concise code helps focusing on behavior instead of boilerplate.\n@@ -33,7 +34,7 @@ declare_clippy_lint! {\n     /// ```\n     pub MANUAL_UNWRAP_OR,\n     complexity,\n-    \"finds patterns that can be encoded more concisely with `Option::unwrap_or`\"\n+    \"finds patterns that can be encoded more concisely with `Option::unwrap_or` or `Result::unwrap_or`\"\n }\n \n declare_lint_pass!(ManualUnwrapOr => [MANUAL_UNWRAP_OR]);\n@@ -43,32 +44,50 @@ impl LateLintPass<'_> for ManualUnwrapOr {\n         if in_external_macro(cx.sess(), expr.span) {\n             return;\n         }\n-        lint_option_unwrap_or_case(cx, expr);\n+        lint_manual_unwrap_or(cx, expr);\n     }\n }\n \n-fn lint_option_unwrap_or_case<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) {\n-    fn applicable_none_arm<'a>(arms: &'a [Arm<'a>]) -> Option<&'a Arm<'a>> {\n+#[derive(Copy, Clone)]\n+enum Case {\n+    Option,\n+    Result,\n+}\n+\n+impl Case {\n+    fn unwrap_fn_path(&self) -> &str {\n+        match self {\n+            Case::Option => \"Option::unwrap_or\",\n+            Case::Result => \"Result::unwrap_or\",\n+        }\n+    }\n+}\n+\n+fn lint_manual_unwrap_or<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) {\n+    fn applicable_or_arm<'a>(arms: &'a [Arm<'a>]) -> Option<&'a Arm<'a>> {\n         if_chain! {\n             if arms.len() == 2;\n             if arms.iter().all(|arm| arm.guard.is_none());\n-            if let Some((idx, none_arm)) = arms.iter().enumerate().find(|(_, arm)|\n-                if let PatKind::Path(ref qpath) = arm.pat.kind {\n-                    utils::match_qpath(qpath, &utils::paths::OPTION_NONE)\n-                } else {\n-                    false\n+            if let Some((idx, or_arm)) = arms.iter().enumerate().find(|(_, arm)|\n+                match arm.pat.kind {\n+                    PatKind::Path(ref some_qpath) =>\n+                        utils::match_qpath(some_qpath, &utils::paths::OPTION_NONE),\n+                    PatKind::TupleStruct(ref err_qpath, &[Pat { kind: PatKind::Wild, .. }], _) =>\n+                        utils::match_qpath(err_qpath, &utils::paths::RESULT_ERR),\n+                    _ => false,\n                 }\n             );\n-            let some_arm = &arms[1 - idx];\n-            if let PatKind::TupleStruct(ref some_qpath, &[some_binding], _) = some_arm.pat.kind;\n-            if utils::match_qpath(some_qpath, &utils::paths::OPTION_SOME);\n-            if let PatKind::Binding(_, binding_hir_id, ..) = some_binding.kind;\n-            if let ExprKind::Path(QPath::Resolved(_, body_path)) = some_arm.body.kind;\n+            let unwrap_arm = &arms[1 - idx];\n+            if let PatKind::TupleStruct(ref unwrap_qpath, &[unwrap_pat], _) = unwrap_arm.pat.kind;\n+            if utils::match_qpath(unwrap_qpath, &utils::paths::OPTION_SOME)\n+                || utils::match_qpath(unwrap_qpath, &utils::paths::RESULT_OK);\n+            if let PatKind::Binding(_, binding_hir_id, ..) = unwrap_pat.kind;\n+            if let ExprKind::Path(QPath::Resolved(_, body_path)) = unwrap_arm.body.kind;\n             if let def::Res::Local(body_path_hir_id) = body_path.res;\n             if body_path_hir_id == binding_hir_id;\n-            if !utils::usage::contains_return_break_continue_macro(none_arm.body);\n+            if !utils::usage::contains_return_break_continue_macro(or_arm.body);\n             then {\n-                Some(none_arm)\n+                Some(or_arm)\n             } else {\n                 None\n             }\n@@ -78,24 +97,29 @@ fn lint_option_unwrap_or_case<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tc\n     if_chain! {\n         if let ExprKind::Match(scrutinee, match_arms, _) = expr.kind;\n         let ty = cx.typeck_results().expr_ty(scrutinee);\n-        if utils::is_type_diagnostic_item(cx, ty, sym!(option_type));\n-        if let Some(none_arm) = applicable_none_arm(match_arms);\n-        if let Some(scrutinee_snippet) = utils::snippet_opt(cx, scrutinee.span);\n-        if let Some(none_body_snippet) = utils::snippet_opt(cx, none_arm.body.span);\n+        if let Some(case) = if utils::is_type_diagnostic_item(cx, ty, sym!(option_type)) {\n+            Some(Case::Option)\n+        } else if utils::is_type_diagnostic_item(cx, ty, sym!(result_type)) {\n+            Some(Case::Result)\n+        } else {\n+            None\n+        };\n+        if let Some(or_arm) = applicable_or_arm(match_arms);\n+        if let Some(or_body_snippet) = utils::snippet_opt(cx, or_arm.body.span);\n         if let Some(indent) = utils::indent_of(cx, expr.span);\n-        if constant_simple(cx, cx.typeck_results(), none_arm.body).is_some();\n+        if constant_simple(cx, cx.typeck_results(), or_arm.body).is_some();\n         then {\n-            let reindented_none_body =\n-                utils::reindent_multiline(none_body_snippet.into(), true, Some(indent));\n+            let reindented_or_body =\n+                utils::reindent_multiline(or_body_snippet.into(), true, Some(indent));\n             utils::span_lint_and_sugg(\n                 cx,\n                 MANUAL_UNWRAP_OR, expr.span,\n-                \"this pattern reimplements `Option::unwrap_or`\",\n+                &format!(\"this pattern reimplements `{}`\", case.unwrap_fn_path()),\n                 \"replace with\",\n                 format!(\n                     \"{}.unwrap_or({})\",\n-                    scrutinee_snippet,\n-                    reindented_none_body,\n+                    sugg::Sugg::hir(cx, scrutinee, \"..\").maybe_par(),\n+                    reindented_or_body,\n                 ),\n                 Applicability::MachineApplicable,\n             );"}, {"sha": "da865a66c45fc139c3f148c4337039643651e8a4", "filename": "src/lintlist/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29979ad0439dff3a9e8e3e74fda6c4f300f69df8/src%2Flintlist%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29979ad0439dff3a9e8e3e74fda6c4f300f69df8/src%2Flintlist%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flintlist%2Fmod.rs?ref=29979ad0439dff3a9e8e3e74fda6c4f300f69df8", "patch": "@@ -1190,7 +1190,7 @@ vec![\n     Lint {\n         name: \"manual_unwrap_or\",\n         group: \"complexity\",\n-        desc: \"finds patterns that can be encoded more concisely with `Option::unwrap_or`\",\n+        desc: \"finds patterns that can be encoded more concisely with `Option::unwrap_or` or `Result::unwrap_or`\",\n         deprecation: None,\n         module: \"manual_unwrap_or\",\n     },"}, {"sha": "5aa5a43cb92cf672da6888096fed8bd4ceb9db3b", "filename": "tests/ui/manual_unwrap_or.fixed", "status": "modified", "additions": 72, "deletions": 1, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/29979ad0439dff3a9e8e3e74fda6c4f300f69df8/tests%2Fui%2Fmanual_unwrap_or.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/29979ad0439dff3a9e8e3e74fda6c4f300f69df8/tests%2Fui%2Fmanual_unwrap_or.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_unwrap_or.fixed?ref=29979ad0439dff3a9e8e3e74fda6c4f300f69df8", "patch": "@@ -1,7 +1,8 @@\n // run-rustfix\n #![allow(dead_code)]\n+#![allow(unused_variables)]\n \n-fn unwrap_or() {\n+fn option_unwrap_or() {\n     // int case\n     Some(1).unwrap_or(42);\n \n@@ -65,4 +66,74 @@ fn unwrap_or() {\n     };\n }\n \n+fn result_unwrap_or() {\n+    // int case\n+    Ok::<i32, &str>(1).unwrap_or(42);\n+\n+    // int case, scrutinee is a binding\n+    let a = Ok::<i32, &str>(1);\n+    a.unwrap_or(42);\n+\n+    // int case, suggestion must surround Result expr with parenthesis\n+    (Ok(1) as Result<i32, &str>).unwrap_or(42);\n+\n+    // method call case, suggestion must not surround Result expr `s.method()` with parenthesis\n+    struct S {}\n+    impl S {\n+        fn method(self) -> Option<i32> {\n+            Some(42)\n+        }\n+    }\n+    let s = S {};\n+    s.method().unwrap_or(42);\n+\n+    // int case reversed\n+    Ok::<i32, &str>(1).unwrap_or(42);\n+\n+    // richer none expr\n+    Ok::<i32, &str>(1).unwrap_or(1 + 42);\n+\n+    // multiline case\n+    #[rustfmt::skip]\n+    Ok::<i32, &str>(1).unwrap_or({\n+        42 + 42\n+            + 42 + 42 + 42\n+            + 42 + 42 + 42\n+    });\n+\n+    // string case\n+    Ok::<&str, &str>(\"Bob\").unwrap_or(\"Alice\");\n+\n+    // don't lint\n+    match Ok::<i32, &str>(1) {\n+        Ok(i) => i + 2,\n+        Err(_) => 42,\n+    };\n+    match Ok::<i32, &str>(1) {\n+        Ok(i) => i,\n+        Err(_) => return,\n+    };\n+    for j in 0..4 {\n+        match Ok::<i32, &str>(j) {\n+            Ok(i) => i,\n+            Err(_) => continue,\n+        };\n+        match Ok::<i32, &str>(j) {\n+            Ok(i) => i,\n+            Err(_) => break,\n+        };\n+    }\n+\n+    // don't lint, Err value is used\n+    match Ok::<&str, &str>(\"Alice\") {\n+        Ok(s) => s,\n+        Err(s) => s,\n+    };\n+    // could lint, but unused_variables takes care of it\n+    match Ok::<&str, &str>(\"Alice\") {\n+        Ok(s) => s,\n+        Err(s) => \"Bob\",\n+    };\n+}\n+\n fn main() {}"}, {"sha": "df534031f54c32c83991357f07cb3826f021323c", "filename": "tests/ui/manual_unwrap_or.rs", "status": "modified", "additions": 96, "deletions": 1, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/29979ad0439dff3a9e8e3e74fda6c4f300f69df8/tests%2Fui%2Fmanual_unwrap_or.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29979ad0439dff3a9e8e3e74fda6c4f300f69df8/tests%2Fui%2Fmanual_unwrap_or.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_unwrap_or.rs?ref=29979ad0439dff3a9e8e3e74fda6c4f300f69df8", "patch": "@@ -1,7 +1,8 @@\n // run-rustfix\n #![allow(dead_code)]\n+#![allow(unused_variables)]\n \n-fn unwrap_or() {\n+fn option_unwrap_or() {\n     // int case\n     match Some(1) {\n         Some(i) => i,\n@@ -80,4 +81,98 @@ fn unwrap_or() {\n     };\n }\n \n+fn result_unwrap_or() {\n+    // int case\n+    match Ok::<i32, &str>(1) {\n+        Ok(i) => i,\n+        Err(_) => 42,\n+    };\n+\n+    // int case, scrutinee is a binding\n+    let a = Ok::<i32, &str>(1);\n+    match a {\n+        Ok(i) => i,\n+        Err(_) => 42,\n+    };\n+\n+    // int case, suggestion must surround Result expr with parenthesis\n+    match Ok(1) as Result<i32, &str> {\n+        Ok(i) => i,\n+        Err(_) => 42,\n+    };\n+\n+    // method call case, suggestion must not surround Result expr `s.method()` with parenthesis\n+    struct S {}\n+    impl S {\n+        fn method(self) -> Option<i32> {\n+            Some(42)\n+        }\n+    }\n+    let s = S {};\n+    match s.method() {\n+        Some(i) => i,\n+        None => 42,\n+    };\n+\n+    // int case reversed\n+    match Ok::<i32, &str>(1) {\n+        Err(_) => 42,\n+        Ok(i) => i,\n+    };\n+\n+    // richer none expr\n+    match Ok::<i32, &str>(1) {\n+        Ok(i) => i,\n+        Err(_) => 1 + 42,\n+    };\n+\n+    // multiline case\n+    #[rustfmt::skip]\n+    match Ok::<i32, &str>(1) {\n+        Ok(i) => i,\n+        Err(_) => {\n+            42 + 42\n+                + 42 + 42 + 42\n+                + 42 + 42 + 42\n+        }\n+    };\n+\n+    // string case\n+    match Ok::<&str, &str>(\"Bob\") {\n+        Ok(i) => i,\n+        Err(_) => \"Alice\",\n+    };\n+\n+    // don't lint\n+    match Ok::<i32, &str>(1) {\n+        Ok(i) => i + 2,\n+        Err(_) => 42,\n+    };\n+    match Ok::<i32, &str>(1) {\n+        Ok(i) => i,\n+        Err(_) => return,\n+    };\n+    for j in 0..4 {\n+        match Ok::<i32, &str>(j) {\n+            Ok(i) => i,\n+            Err(_) => continue,\n+        };\n+        match Ok::<i32, &str>(j) {\n+            Ok(i) => i,\n+            Err(_) => break,\n+        };\n+    }\n+\n+    // don't lint, Err value is used\n+    match Ok::<&str, &str>(\"Alice\") {\n+        Ok(s) => s,\n+        Err(s) => s,\n+    };\n+    // could lint, but unused_variables takes care of it\n+    match Ok::<&str, &str>(\"Alice\") {\n+        Ok(s) => s,\n+        Err(s) => \"Bob\",\n+    };\n+}\n+\n fn main() {}"}, {"sha": "fc174c4c2705dc3c6d7ea4b6df6b889b7b881c8c", "filename": "tests/ui/manual_unwrap_or.stderr", "status": "modified", "additions": 90, "deletions": 6, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/29979ad0439dff3a9e8e3e74fda6c4f300f69df8/tests%2Fui%2Fmanual_unwrap_or.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/29979ad0439dff3a9e8e3e74fda6c4f300f69df8/tests%2Fui%2Fmanual_unwrap_or.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_unwrap_or.stderr?ref=29979ad0439dff3a9e8e3e74fda6c4f300f69df8", "patch": "@@ -1,5 +1,5 @@\n error: this pattern reimplements `Option::unwrap_or`\n-  --> $DIR/manual_unwrap_or.rs:6:5\n+  --> $DIR/manual_unwrap_or.rs:7:5\n    |\n LL | /     match Some(1) {\n LL | |         Some(i) => i,\n@@ -10,7 +10,7 @@ LL | |     };\n    = note: `-D clippy::manual-unwrap-or` implied by `-D warnings`\n \n error: this pattern reimplements `Option::unwrap_or`\n-  --> $DIR/manual_unwrap_or.rs:12:5\n+  --> $DIR/manual_unwrap_or.rs:13:5\n    |\n LL | /     match Some(1) {\n LL | |         None => 42,\n@@ -19,7 +19,7 @@ LL | |     };\n    | |_____^ help: replace with: `Some(1).unwrap_or(42)`\n \n error: this pattern reimplements `Option::unwrap_or`\n-  --> $DIR/manual_unwrap_or.rs:18:5\n+  --> $DIR/manual_unwrap_or.rs:19:5\n    |\n LL | /     match Some(1) {\n LL | |         Some(i) => i,\n@@ -28,7 +28,7 @@ LL | |     };\n    | |_____^ help: replace with: `Some(1).unwrap_or(1 + 42)`\n \n error: this pattern reimplements `Option::unwrap_or`\n-  --> $DIR/manual_unwrap_or.rs:25:5\n+  --> $DIR/manual_unwrap_or.rs:26:5\n    |\n LL | /     match Some(1) {\n LL | |         Some(i) => i,\n@@ -49,13 +49,97 @@ LL |     });\n    |\n \n error: this pattern reimplements `Option::unwrap_or`\n-  --> $DIR/manual_unwrap_or.rs:35:5\n+  --> $DIR/manual_unwrap_or.rs:36:5\n    |\n LL | /     match Some(\"Bob\") {\n LL | |         Some(i) => i,\n LL | |         None => \"Alice\",\n LL | |     };\n    | |_____^ help: replace with: `Some(\"Bob\").unwrap_or(\"Alice\")`\n \n-error: aborting due to 5 previous errors\n+error: this pattern reimplements `Result::unwrap_or`\n+  --> $DIR/manual_unwrap_or.rs:86:5\n+   |\n+LL | /     match Ok::<i32, &str>(1) {\n+LL | |         Ok(i) => i,\n+LL | |         Err(_) => 42,\n+LL | |     };\n+   | |_____^ help: replace with: `Ok::<i32, &str>(1).unwrap_or(42)`\n+\n+error: this pattern reimplements `Result::unwrap_or`\n+  --> $DIR/manual_unwrap_or.rs:93:5\n+   |\n+LL | /     match a {\n+LL | |         Ok(i) => i,\n+LL | |         Err(_) => 42,\n+LL | |     };\n+   | |_____^ help: replace with: `a.unwrap_or(42)`\n+\n+error: this pattern reimplements `Result::unwrap_or`\n+  --> $DIR/manual_unwrap_or.rs:99:5\n+   |\n+LL | /     match Ok(1) as Result<i32, &str> {\n+LL | |         Ok(i) => i,\n+LL | |         Err(_) => 42,\n+LL | |     };\n+   | |_____^ help: replace with: `(Ok(1) as Result<i32, &str>).unwrap_or(42)`\n+\n+error: this pattern reimplements `Option::unwrap_or`\n+  --> $DIR/manual_unwrap_or.rs:112:5\n+   |\n+LL | /     match s.method() {\n+LL | |         Some(i) => i,\n+LL | |         None => 42,\n+LL | |     };\n+   | |_____^ help: replace with: `s.method().unwrap_or(42)`\n+\n+error: this pattern reimplements `Result::unwrap_or`\n+  --> $DIR/manual_unwrap_or.rs:118:5\n+   |\n+LL | /     match Ok::<i32, &str>(1) {\n+LL | |         Err(_) => 42,\n+LL | |         Ok(i) => i,\n+LL | |     };\n+   | |_____^ help: replace with: `Ok::<i32, &str>(1).unwrap_or(42)`\n+\n+error: this pattern reimplements `Result::unwrap_or`\n+  --> $DIR/manual_unwrap_or.rs:124:5\n+   |\n+LL | /     match Ok::<i32, &str>(1) {\n+LL | |         Ok(i) => i,\n+LL | |         Err(_) => 1 + 42,\n+LL | |     };\n+   | |_____^ help: replace with: `Ok::<i32, &str>(1).unwrap_or(1 + 42)`\n+\n+error: this pattern reimplements `Result::unwrap_or`\n+  --> $DIR/manual_unwrap_or.rs:131:5\n+   |\n+LL | /     match Ok::<i32, &str>(1) {\n+LL | |         Ok(i) => i,\n+LL | |         Err(_) => {\n+LL | |             42 + 42\n+...  |\n+LL | |         }\n+LL | |     };\n+   | |_____^\n+   |\n+help: replace with\n+   |\n+LL |     Ok::<i32, &str>(1).unwrap_or({\n+LL |         42 + 42\n+LL |             + 42 + 42 + 42\n+LL |             + 42 + 42 + 42\n+LL |     });\n+   |\n+\n+error: this pattern reimplements `Result::unwrap_or`\n+  --> $DIR/manual_unwrap_or.rs:141:5\n+   |\n+LL | /     match Ok::<&str, &str>(\"Bob\") {\n+LL | |         Ok(i) => i,\n+LL | |         Err(_) => \"Alice\",\n+LL | |     };\n+   | |_____^ help: replace with: `Ok::<&str, &str>(\"Bob\").unwrap_or(\"Alice\")`\n+\n+error: aborting due to 13 previous errors\n "}]}