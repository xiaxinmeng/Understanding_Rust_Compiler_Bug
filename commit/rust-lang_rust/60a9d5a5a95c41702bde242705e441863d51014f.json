{"sha": "60a9d5a5a95c41702bde242705e441863d51014f", "node_id": "C_kwDOAAsO6NoAKDYwYTlkNWE1YTk1YzQxNzAyYmRlMjQyNzA1ZTQ0MTg2M2Q1MTAxNGY", "commit": {"author": {"name": "Julian Frimmel", "email": "julian.frimmel@gmail.com", "date": "2021-10-19T05:37:25Z"}, "committer": {"name": "Julian", "email": "julian.frimmel@gmail.com", "date": "2021-11-09T09:02:09Z"}, "message": "Re-enable `copy[_nonoverlapping]()` runtime checks\n\nThis commit re-enables the debug checks for valid usages of the two\nfunctions `copy()` and `copy_nonoverlapping()`. Those checks were com-\nmented out in #79684 in order to make the functions const. All that's\nbeen left was a FIXME, that could not be resolved until there is was way\nto only do the checks at runtime.\nSince #89247 there is such a way: `const_eval_select()`. This commit\nuses that new intrinsic in order to either do nothing (at compile time)\nor to do the old checks (at runtime).\n\nThe change itself is rather small: in order to make the checks usable\nwith `const_eval_select`, they are moved into a local function (one for\n`copy` and one for `copy_nonoverlapping` to keep symmetry).\n\nThe change does not break referential transparency, as there is nothing\nyou can do at compile time, which you cannot do on runtime without get-\nting undefined behavior. The CTFE-engine won't allow missuses. The other\nway round is also fine.", "tree": {"sha": "5d0723708d8cd072b5ca1a1da9ea4f16082efdcc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5d0723708d8cd072b5ca1a1da9ea4f16082efdcc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/60a9d5a5a95c41702bde242705e441863d51014f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/60a9d5a5a95c41702bde242705e441863d51014f", "html_url": "https://github.com/rust-lang/rust/commit/60a9d5a5a95c41702bde242705e441863d51014f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/60a9d5a5a95c41702bde242705e441863d51014f/comments", "author": {"login": "jfrimmel", "id": 31166235, "node_id": "MDQ6VXNlcjMxMTY2MjM1", "avatar_url": "https://avatars.githubusercontent.com/u/31166235?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jfrimmel", "html_url": "https://github.com/jfrimmel", "followers_url": "https://api.github.com/users/jfrimmel/followers", "following_url": "https://api.github.com/users/jfrimmel/following{/other_user}", "gists_url": "https://api.github.com/users/jfrimmel/gists{/gist_id}", "starred_url": "https://api.github.com/users/jfrimmel/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jfrimmel/subscriptions", "organizations_url": "https://api.github.com/users/jfrimmel/orgs", "repos_url": "https://api.github.com/users/jfrimmel/repos", "events_url": "https://api.github.com/users/jfrimmel/events{/privacy}", "received_events_url": "https://api.github.com/users/jfrimmel/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jfrimmel", "id": 31166235, "node_id": "MDQ6VXNlcjMxMTY2MjM1", "avatar_url": "https://avatars.githubusercontent.com/u/31166235?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jfrimmel", "html_url": "https://github.com/jfrimmel", "followers_url": "https://api.github.com/users/jfrimmel/followers", "following_url": "https://api.github.com/users/jfrimmel/following{/other_user}", "gists_url": "https://api.github.com/users/jfrimmel/gists{/gist_id}", "starred_url": "https://api.github.com/users/jfrimmel/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jfrimmel/subscriptions", "organizations_url": "https://api.github.com/users/jfrimmel/orgs", "repos_url": "https://api.github.com/users/jfrimmel/repos", "events_url": "https://api.github.com/users/jfrimmel/events{/privacy}", "received_events_url": "https://api.github.com/users/jfrimmel/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "60952bc3da442cf2ea11dcc9c80a461a659bbcd7", "url": "https://api.github.com/repos/rust-lang/rust/commits/60952bc3da442cf2ea11dcc9c80a461a659bbcd7", "html_url": "https://github.com/rust-lang/rust/commit/60952bc3da442cf2ea11dcc9c80a461a659bbcd7"}], "stats": {"total": 62, "additions": 47, "deletions": 15}, "files": [{"sha": "0f57fb5b14180432c3481a91c94b66b74495673f", "filename": "library/core/src/intrinsics.rs", "status": "modified", "additions": 46, "deletions": 14, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/60a9d5a5a95c41702bde242705e441863d51014f/library%2Fcore%2Fsrc%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a9d5a5a95c41702bde242705e441863d51014f/library%2Fcore%2Fsrc%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fintrinsics.rs?ref=60a9d5a5a95c41702bde242705e441863d51014f", "patch": "@@ -1951,6 +1951,19 @@ pub(crate) fn is_aligned_and_not_null<T>(ptr: *const T) -> bool {\n     !ptr.is_null() && ptr as usize % mem::align_of::<T>() == 0\n }\n \n+/// Checks whether the regions of memory starting at `src` and `dst` of size\n+/// `count * size_of::<T>()` do *not* overlap.\n+#[cfg(debug_assertions)]\n+pub(crate) fn is_nonoverlapping<T>(src: *const T, dst: *const T, count: usize) -> bool {\n+    let src_usize = src as usize;\n+    let dst_usize = dst as usize;\n+    let size = mem::size_of::<T>().checked_mul(count).unwrap();\n+    let diff = if src_usize > dst_usize { src_usize - dst_usize } else { dst_usize - src_usize };\n+    // If the absolute distance between the ptrs is at least as big as the size of the buffer,\n+    // they do not overlap.\n+    diff >= size\n+}\n+\n /// Copies `count * size_of::<T>()` bytes from `src` to `dst`. The source\n /// and destination must *not* overlap.\n ///\n@@ -2042,15 +2055,24 @@ pub const unsafe fn copy_nonoverlapping<T>(src: *const T, dst: *mut T, count: us\n         pub fn copy_nonoverlapping<T>(src: *const T, dst: *mut T, count: usize);\n     }\n \n-    // FIXME: Perform these checks only at run time\n-    /*if cfg!(debug_assertions)\n-        && !(is_aligned_and_not_null(src)\n-            && is_aligned_and_not_null(dst)\n-            && is_nonoverlapping(src, dst, count))\n-    {\n-        // Not panicking to keep codegen impact smaller.\n-        abort();\n-    }*/\n+    #[cfg(debug_assertions)]\n+    fn runtime_check<T>(src: *const T, dst: *mut T, count: usize) {\n+        if !is_aligned_and_not_null(src)\n+            || !is_aligned_and_not_null(dst)\n+            || !is_nonoverlapping(src, dst, count)\n+        {\n+            // Not panicking to keep codegen impact smaller.\n+            abort();\n+        }\n+    }\n+    #[cfg(debug_assertions)]\n+    const fn compiletime_check<T>(_src: *const T, _dst: *mut T, _count: usize) {}\n+    #[cfg(debug_assertions)]\n+    // SAFETY: runtime debug-assertions are a best-effort basis; it's fine to\n+    // not do them during compile time\n+    unsafe {\n+        const_eval_select((src, dst, count), compiletime_check, runtime_check);\n+    }\n \n     // SAFETY: the safety contract for `copy_nonoverlapping` must be\n     // upheld by the caller.\n@@ -2127,11 +2149,21 @@ pub const unsafe fn copy<T>(src: *const T, dst: *mut T, count: usize) {\n         fn copy<T>(src: *const T, dst: *mut T, count: usize);\n     }\n \n-    // FIXME: Perform these checks only at run time\n-    /*if cfg!(debug_assertions) && !(is_aligned_and_not_null(src) && is_aligned_and_not_null(dst)) {\n-        // Not panicking to keep codegen impact smaller.\n-        abort();\n-    }*/\n+    #[cfg(debug_assertions)]\n+    fn runtime_check<T>(src: *const T, dst: *mut T) {\n+        if !is_aligned_and_not_null(src) || !is_aligned_and_not_null(dst) {\n+            // Not panicking to keep codegen impact smaller.\n+            abort();\n+        }\n+    }\n+    #[cfg(debug_assertions)]\n+    const fn compiletime_check<T>(_src: *const T, _dst: *mut T) {}\n+    #[cfg(debug_assertions)]\n+    // SAFETY: runtime debug-assertions are a best-effort basis; it's fine to\n+    // not do them during compile time\n+    unsafe {\n+        const_eval_select((src, dst), compiletime_check, runtime_check);\n+    }\n \n     // SAFETY: the safety contract for `copy` must be upheld by the caller.\n     unsafe { copy(src, dst, count) }"}, {"sha": "df9a12695cee981d4cabe49b8a760adc786fe5a9", "filename": "library/core/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60a9d5a5a95c41702bde242705e441863d51014f/library%2Fcore%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a9d5a5a95c41702bde242705e441863d51014f/library%2Fcore%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Flib.rs?ref=60a9d5a5a95c41702bde242705e441863d51014f", "patch": "@@ -105,7 +105,7 @@\n #![feature(const_caller_location)]\n #![feature(const_cell_into_inner)]\n #![feature(const_discriminant)]\n-#![cfg_attr(not(bootstrap), feature(const_eval_select))]\n+#![feature(const_eval_select)]\n #![feature(const_float_bits_conv)]\n #![feature(const_float_classify)]\n #![feature(const_fmt_arguments_new)]"}]}