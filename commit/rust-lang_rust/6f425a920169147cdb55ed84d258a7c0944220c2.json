{"sha": "6f425a920169147cdb55ed84d258a7c0944220c2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZmNDI1YTkyMDE2OTE0N2NkYjU1ZWQ4NGQyNThhN2MwOTQ0MjIwYzI=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-05-08T21:15:48Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-05-24T16:01:27Z"}, "message": "implement the chalk traits, albeit with many placeholders", "tree": {"sha": "300480854b958887f50c366a601ef907e87c356c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/300480854b958887f50c366a601ef907e87c356c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6f425a920169147cdb55ed84d258a7c0944220c2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6f425a920169147cdb55ed84d258a7c0944220c2", "html_url": "https://github.com/rust-lang/rust/commit/6f425a920169147cdb55ed84d258a7c0944220c2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6f425a920169147cdb55ed84d258a7c0944220c2/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d022dd48cceaceffa931f87490c7921aa3c3f8b1", "url": "https://api.github.com/repos/rust-lang/rust/commits/d022dd48cceaceffa931f87490c7921aa3c3f8b1", "html_url": "https://github.com/rust-lang/rust/commit/d022dd48cceaceffa931f87490c7921aa3c3f8b1"}], "stats": {"total": 1036, "additions": 881, "deletions": 155}, "files": [{"sha": "42eccaec9d0820ae02ec30219f2d0968709464c4", "filename": "src/librustc/Cargo.toml", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6f425a920169147cdb55ed84d258a7c0944220c2/src%2Flibrustc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/6f425a920169147cdb55ed84d258a7c0944220c2/src%2Flibrustc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2FCargo.toml?ref=6f425a920169147cdb55ed84d258a7c0944220c2", "patch": "@@ -26,6 +26,7 @@ syntax = { path = \"../libsyntax\" }\n syntax_pos = { path = \"../libsyntax_pos\" }\n backtrace = \"0.3.3\"\n byteorder = { version = \"1.1\", features = [\"i128\"]}\n+chalk-engine = { version = \"0.6.0\", default-features=false }\n \n # Note that these dependencies are a lie, they're just here to get linkage to\n # work.\n@@ -56,3 +57,5 @@ byteorder = { version = \"1.1\", features = [\"i128\"]}\n #        compiles, then please feel free to do so!\n flate2 = \"1.0\"\n tempdir = \"0.3\"\n+\n+"}, {"sha": "c67f09c88bdc55554494664807c93be99037597b", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6f425a920169147cdb55ed84d258a7c0944220c2/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f425a920169147cdb55ed84d258a7c0944220c2/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=6f425a920169147cdb55ed84d258a7c0944220c2", "patch": "@@ -89,6 +89,7 @@ extern crate rustc_errors as errors;\n extern crate syntax_pos;\n extern crate jobserver;\n extern crate proc_macro;\n+extern crate chalk_engine;\n \n extern crate serialize as rustc_serialize; // used by deriving\n "}, {"sha": "4178fdb352d514c87bc01dcae1cf546cd7131f3e", "filename": "src/librustc/macros.rs", "status": "modified", "additions": 36, "deletions": 9, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/6f425a920169147cdb55ed84d258a7c0944220c2/src%2Flibrustc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f425a920169147cdb55ed84d258a7c0944220c2/src%2Flibrustc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmacros.rs?ref=6f425a920169147cdb55ed84d258a7c0944220c2", "patch": "@@ -250,25 +250,52 @@ macro_rules! BraceStructLiftImpl {\n macro_rules! EnumLiftImpl {\n     (impl<$($p:tt),*> Lift<$tcx:tt> for $s:path {\n         type Lifted = $lifted:ty;\n-        $(\n-            ($variant:path) ( $( $variant_arg:ident),* )\n-        ),*\n-        $(,)*\n+        $($variants:tt)*\n     } $(where $($wc:tt)*)*) => {\n         impl<$($p),*> $crate::ty::Lift<$tcx> for $s\n             $(where $($wc)*)*\n         {\n             type Lifted = $lifted;\n \n             fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<$lifted> {\n-                match self {\n-                    $($variant ( $($variant_arg),* ) => {\n-                        Some($variant ( $(tcx.lift($variant_arg)?),* ))\n-                    })*\n-                }\n+                EnumLiftImpl!(@Variants(self, tcx) input($($variants)*) output())\n             }\n         }\n     };\n+\n+    (@Variants($this:expr, $tcx:expr) input() output($($output:tt)*)) => {\n+        match $this {\n+            $($output)*\n+        }\n+    };\n+\n+    (@Variants($this:expr, $tcx:expr)\n+     input( ($variant:path) ( $($variant_arg:ident),* ) , $($input:tt)*)\n+     output( $($output:tt)*) ) => {\n+        EnumLiftImpl!(\n+            @Variants($this, $tcx)\n+                input($($input)*)\n+                output(\n+                    $variant ( $($variant_arg),* ) => {\n+                        Some($variant ( $($tcx.lift($variant_arg)?),* ))\n+                    }\n+                    $($output)*\n+                )\n+        )\n+    };\n+\n+    (@Variants($this:expr, $tcx:expr)\n+     input( ($variant:path), $($input:tt)*)\n+     output( $($output:tt)*) ) => {\n+        EnumLiftImpl!(\n+            @Variants($this, $tcx)\n+                input($($input)*)\n+                output(\n+                    $variant => { Some($variant) }\n+                    $($output)*\n+                )\n+        )\n+    };\n }\n \n #[macro_export]"}, {"sha": "3bd4e11b0e8b9708abd8324bc970cc3d69c86045", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 61, "deletions": 1, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/6f425a920169147cdb55ed84d258a7c0944220c2/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f425a920169147cdb55ed84d258a7c0944220c2/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=6f425a920169147cdb55ed84d258a7c0944220c2", "patch": "@@ -17,17 +17,21 @@ pub use self::FulfillmentErrorCode::*;\n pub use self::Vtable::*;\n pub use self::ObligationCauseCode::*;\n \n+use chalk_engine;\n use hir;\n use hir::def_id::DefId;\n use infer::outlives::env::OutlivesEnvironment;\n use middle::region;\n use middle::const_val::ConstEvalErr;\n use ty::subst::Substs;\n-use ty::{self, AdtKind, Slice, Ty, TyCtxt, GenericParamDefKind, TypeFoldable, ToPredicate};\n+use ty::{self, AdtKind, Slice, Ty, TyCtxt, GenericParamDefKind, ToPredicate};\n use ty::error::{ExpectedFound, TypeError};\n+use ty::fold::{TypeFolder, TypeFoldable, TypeVisitor};\n+use infer::canonical::{Canonical, Canonicalize};\n use infer::{InferCtxt};\n \n use rustc_data_structures::sync::Lrc;\n+use std::fmt::Debug;\n use std::rc::Rc;\n use syntax::ast;\n use syntax_pos::{Span, DUMMY_SP};\n@@ -1003,3 +1007,59 @@ pub fn provide(providers: &mut ty::maps::Providers) {\n         ..*providers\n     };\n }\n+\n+impl<'gcx: 'tcx, 'tcx> Canonicalize<'gcx, 'tcx> for ty::ParamEnvAnd<'tcx, Goal<'tcx>> {\n+    // we ought to intern this, but I'm too lazy just now\n+    type Canonicalized = Canonical<'gcx, ty::ParamEnvAnd<'gcx, Goal<'gcx>>>;\n+\n+    fn intern(\n+        _gcx: TyCtxt<'_, 'gcx, 'gcx>,\n+        value: Canonical<'gcx, Self::Lifted>,\n+    ) -> Self::Canonicalized {\n+        value\n+    }\n+}\n+\n+pub trait ExClauseFold<'tcx>\n+where\n+    Self: chalk_engine::context::Context + Clone,\n+{\n+    fn fold_ex_clause_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(\n+        ex_clause: &chalk_engine::ExClause<Self>,\n+        folder: &mut F,\n+    ) -> chalk_engine::ExClause<Self>;\n+\n+    fn visit_ex_clause_with<'gcx: 'tcx, V: TypeVisitor<'tcx>>(\n+        ex_clause: &chalk_engine::ExClause<Self>,\n+        visitor: &mut V,\n+    ) -> bool;\n+}\n+\n+pub trait ExClauseLift<'tcx>\n+where\n+    Self: chalk_engine::context::Context + Clone,\n+{\n+    type LiftedExClause: Debug + 'tcx;\n+\n+    fn lift_ex_clause_to_tcx<'a, 'gcx>(\n+        ex_clause: &chalk_engine::ExClause<Self>,\n+        tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    ) -> Option<Self::LiftedExClause>;\n+}\n+\n+impl<'gcx: 'tcx, 'tcx, C> Canonicalize<'gcx, 'tcx> for chalk_engine::ExClause<C>\n+where\n+    C: chalk_engine::context::Context + Clone,\n+    C: ExClauseLift<'gcx> + ExClauseFold<'tcx>,\n+    C::Substitution: Clone,\n+    C::RegionConstraint: Clone,\n+{\n+    type Canonicalized = Canonical<'gcx, C::LiftedExClause>;\n+\n+    fn intern(\n+        _gcx: TyCtxt<'_, 'gcx, 'gcx>,\n+        value: Canonical<'gcx, Self::Lifted>,\n+    ) -> Self::Canonicalized {\n+        value\n+    }\n+}"}, {"sha": "d1304a0a3f8871483a6f6c1546a9acd945010a5e", "filename": "src/librustc/traits/structural_impls.rs", "status": "modified", "additions": 214, "deletions": 144, "changes": 358, "blob_url": "https://github.com/rust-lang/rust/blob/6f425a920169147cdb55ed84d258a7c0944220c2/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f425a920169147cdb55ed84d258a7c0944220c2/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs?ref=6f425a920169147cdb55ed84d258a7c0944220c2", "patch": "@@ -8,11 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use chalk_engine;\n use rustc_data_structures::accumulate_vec::AccumulateVec;\n use traits;\n use traits::project::Normalized;\n-use ty::{self, Lift, TyCtxt};\n use ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n+use ty::{self, Lift, TyCtxt};\n \n use std::fmt;\n use std::rc::Rc;\n@@ -21,81 +22,77 @@ use std::rc::Rc;\n \n impl<'tcx, T: fmt::Debug> fmt::Debug for Normalized<'tcx, T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"Normalized({:?},{:?})\",\n-               self.value,\n-               self.obligations)\n+        write!(f, \"Normalized({:?},{:?})\", self.value, self.obligations)\n     }\n }\n \n impl<'tcx, O: fmt::Debug> fmt::Debug for traits::Obligation<'tcx, O> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         if ty::tls::with(|tcx| tcx.sess.verbose()) {\n-            write!(f, \"Obligation(predicate={:?},cause={:?},depth={})\",\n-                   self.predicate,\n-                   self.cause,\n-                   self.recursion_depth)\n+            write!(\n+                f,\n+                \"Obligation(predicate={:?},cause={:?},depth={})\",\n+                self.predicate, self.cause, self.recursion_depth\n+            )\n         } else {\n-            write!(f, \"Obligation(predicate={:?},depth={})\",\n-                   self.predicate,\n-                   self.recursion_depth)\n+            write!(\n+                f,\n+                \"Obligation(predicate={:?},depth={})\",\n+                self.predicate, self.recursion_depth\n+            )\n         }\n     }\n }\n \n impl<'tcx, N: fmt::Debug> fmt::Debug for traits::Vtable<'tcx, N> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n-            super::VtableImpl(ref v) =>\n-                write!(f, \"{:?}\", v),\n+            super::VtableImpl(ref v) => write!(f, \"{:?}\", v),\n \n-            super::VtableAutoImpl(ref t) =>\n-                write!(f, \"{:?}\", t),\n+            super::VtableAutoImpl(ref t) => write!(f, \"{:?}\", t),\n \n-            super::VtableClosure(ref d) =>\n-                write!(f, \"{:?}\", d),\n+            super::VtableClosure(ref d) => write!(f, \"{:?}\", d),\n \n-            super::VtableGenerator(ref d) =>\n-                write!(f, \"{:?}\", d),\n+            super::VtableGenerator(ref d) => write!(f, \"{:?}\", d),\n \n-            super::VtableFnPointer(ref d) =>\n-                write!(f, \"VtableFnPointer({:?})\", d),\n+            super::VtableFnPointer(ref d) => write!(f, \"VtableFnPointer({:?})\", d),\n \n-            super::VtableObject(ref d) =>\n-                write!(f, \"{:?}\", d),\n+            super::VtableObject(ref d) => write!(f, \"{:?}\", d),\n \n-            super::VtableParam(ref n) =>\n-                write!(f, \"VtableParam({:?})\", n),\n+            super::VtableParam(ref n) => write!(f, \"VtableParam({:?})\", n),\n \n-            super::VtableBuiltin(ref d) =>\n-                write!(f, \"{:?}\", d)\n+            super::VtableBuiltin(ref d) => write!(f, \"{:?}\", d),\n         }\n     }\n }\n \n impl<'tcx, N: fmt::Debug> fmt::Debug for traits::VtableImplData<'tcx, N> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"VtableImpl(impl_def_id={:?}, substs={:?}, nested={:?})\",\n-               self.impl_def_id,\n-               self.substs,\n-               self.nested)\n+        write!(\n+            f,\n+            \"VtableImpl(impl_def_id={:?}, substs={:?}, nested={:?})\",\n+            self.impl_def_id, self.substs, self.nested\n+        )\n     }\n }\n \n impl<'tcx, N: fmt::Debug> fmt::Debug for traits::VtableGeneratorData<'tcx, N> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"VtableGenerator(generator_def_id={:?}, substs={:?}, nested={:?})\",\n-               self.generator_def_id,\n-               self.substs,\n-               self.nested)\n+        write!(\n+            f,\n+            \"VtableGenerator(generator_def_id={:?}, substs={:?}, nested={:?})\",\n+            self.generator_def_id, self.substs, self.nested\n+        )\n     }\n }\n \n impl<'tcx, N: fmt::Debug> fmt::Debug for traits::VtableClosureData<'tcx, N> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"VtableClosure(closure_def_id={:?}, substs={:?}, nested={:?})\",\n-               self.closure_def_id,\n-               self.substs,\n-               self.nested)\n+        write!(\n+            f,\n+            \"VtableClosure(closure_def_id={:?}, substs={:?}, nested={:?})\",\n+            self.closure_def_id, self.substs, self.nested\n+        )\n     }\n }\n \n@@ -107,34 +104,37 @@ impl<'tcx, N: fmt::Debug> fmt::Debug for traits::VtableBuiltinData<N> {\n \n impl<'tcx, N: fmt::Debug> fmt::Debug for traits::VtableAutoImplData<N> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"VtableAutoImplData(trait_def_id={:?}, nested={:?})\",\n-               self.trait_def_id,\n-               self.nested)\n+        write!(\n+            f,\n+            \"VtableAutoImplData(trait_def_id={:?}, nested={:?})\",\n+            self.trait_def_id, self.nested\n+        )\n     }\n }\n \n impl<'tcx, N: fmt::Debug> fmt::Debug for traits::VtableObjectData<'tcx, N> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"VtableObject(upcast={:?}, vtable_base={}, nested={:?})\",\n-               self.upcast_trait_ref,\n-               self.vtable_base,\n-               self.nested)\n+        write!(\n+            f,\n+            \"VtableObject(upcast={:?}, vtable_base={}, nested={:?})\",\n+            self.upcast_trait_ref, self.vtable_base, self.nested\n+        )\n     }\n }\n \n impl<'tcx, N: fmt::Debug> fmt::Debug for traits::VtableFnPointerData<'tcx, N> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"VtableFnPointer(fn_ty={:?}, nested={:?})\",\n-               self.fn_ty,\n-               self.nested)\n+        write!(\n+            f,\n+            \"VtableFnPointer(fn_ty={:?}, nested={:?})\",\n+            self.fn_ty, self.nested\n+        )\n     }\n }\n \n impl<'tcx> fmt::Debug for traits::FulfillmentError<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"FulfillmentError({:?},{:?})\",\n-               self.obligation,\n-               self.code)\n+        write!(f, \"FulfillmentError({:?},{:?})\", self.obligation, self.code)\n     }\n }\n \n@@ -143,9 +143,10 @@ impl<'tcx> fmt::Debug for traits::FulfillmentErrorCode<'tcx> {\n         match *self {\n             super::CodeSelectionError(ref e) => write!(f, \"{:?}\", e),\n             super::CodeProjectionError(ref e) => write!(f, \"{:?}\", e),\n-            super::CodeSubtypeError(ref a, ref b) =>\n-                write!(f, \"CodeSubtypeError({:?}, {:?})\", a, b),\n-            super::CodeAmbiguity => write!(f, \"Ambiguity\")\n+            super::CodeSubtypeError(ref a, ref b) => {\n+                write!(f, \"CodeSubtypeError({:?}, {:?})\", a, b)\n+            }\n+            super::CodeAmbiguity => write!(f, \"Ambiguity\"),\n         }\n     }\n }\n@@ -166,18 +167,13 @@ impl<'a, 'tcx> Lift<'tcx> for traits::SelectionError<'a> {\n             super::Unimplemented => Some(super::Unimplemented),\n             super::OutputTypeParameterMismatch(a, b, ref err) => {\n                 tcx.lift(&(a, b)).and_then(|(a, b)| {\n-                    tcx.lift(err).map(|err| {\n-                        super::OutputTypeParameterMismatch(a, b, err)\n-                    })\n+                    tcx.lift(err)\n+                        .map(|err| super::OutputTypeParameterMismatch(a, b, err))\n                 })\n             }\n-            super::TraitNotObjectSafe(def_id) => {\n-                Some(super::TraitNotObjectSafe(def_id))\n-            }\n-            super::ConstEvalFailure(ref err) => {\n-                tcx.lift(err).map(super::ConstEvalFailure)\n-            }\n-            super::Overflow => bug!() // FIXME: ape ConstEvalFailure?\n+            super::TraitNotObjectSafe(def_id) => Some(super::TraitNotObjectSafe(def_id)),\n+            super::ConstEvalFailure(ref err) => tcx.lift(err).map(super::ConstEvalFailure),\n+            super::Overflow => bug!(), // FIXME: ape ConstEvalFailure?\n         }\n     }\n }\n@@ -195,16 +191,11 @@ impl<'a, 'tcx> Lift<'tcx> for traits::ObligationCauseCode<'a> {\n             super::ReferenceOutlivesReferent(ty) => {\n                 tcx.lift(&ty).map(super::ReferenceOutlivesReferent)\n             }\n-            super::ObjectTypeBound(ty, r) => {\n-                tcx.lift(&ty).and_then(|ty| {\n-                    tcx.lift(&r).and_then(|r| {\n-                        Some(super::ObjectTypeBound(ty, r))\n-                    })\n-                })\n-            }\n-            super::ObjectCastObligation(ty) => {\n-                tcx.lift(&ty).map(super::ObjectCastObligation)\n-            }\n+            super::ObjectTypeBound(ty, r) => tcx.lift(&ty).and_then(|ty| {\n+                tcx.lift(&r)\n+                    .and_then(|r| Some(super::ObjectTypeBound(ty, r)))\n+            }),\n+            super::ObjectCastObligation(ty) => tcx.lift(&ty).map(super::ObjectCastObligation),\n             super::AssignmentLhsSized => Some(super::AssignmentLhsSized),\n             super::TupleInitializerSized => Some(super::TupleInitializerSized),\n             super::StructInitializerSized => Some(super::StructInitializerSized),\n@@ -222,20 +213,20 @@ impl<'a, 'tcx> Lift<'tcx> for traits::ObligationCauseCode<'a> {\n             super::ImplDerivedObligation(ref cause) => {\n                 tcx.lift(cause).map(super::ImplDerivedObligation)\n             }\n-            super::CompareImplMethodObligation { item_name,\n-                                                 impl_item_def_id,\n-                                                 trait_item_def_id } => {\n-                Some(super::CompareImplMethodObligation {\n-                    item_name,\n-                    impl_item_def_id,\n-                    trait_item_def_id,\n-                })\n-            }\n+            super::CompareImplMethodObligation {\n+                item_name,\n+                impl_item_def_id,\n+                trait_item_def_id,\n+            } => Some(super::CompareImplMethodObligation {\n+                item_name,\n+                impl_item_def_id,\n+                trait_item_def_id,\n+            }),\n             super::ExprAssignable => Some(super::ExprAssignable),\n-            super::MatchExpressionArm { arm_span, source } => {\n-                Some(super::MatchExpressionArm { arm_span,\n-                                                 source: source })\n-            }\n+            super::MatchExpressionArm { arm_span, source } => Some(super::MatchExpressionArm {\n+                arm_span,\n+                source: source,\n+            }),\n             super::IfExpression => Some(super::IfExpression),\n             super::IfExpressionWithNoElse => Some(super::IfExpressionWithNoElse),\n             super::MainFunctionType => Some(super::MainFunctionType),\n@@ -252,25 +243,22 @@ impl<'a, 'tcx> Lift<'tcx> for traits::DerivedObligationCause<'a> {\n     type Lifted = traits::DerivedObligationCause<'tcx>;\n     fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n         tcx.lift(&self.parent_trait_ref).and_then(|trait_ref| {\n-            tcx.lift(&*self.parent_code).map(|code| {\n-                traits::DerivedObligationCause {\n+            tcx.lift(&*self.parent_code)\n+                .map(|code| traits::DerivedObligationCause {\n                     parent_trait_ref: trait_ref,\n-                    parent_code: Rc::new(code)\n-                }\n-            })\n+                    parent_code: Rc::new(code),\n+                })\n         })\n     }\n }\n \n impl<'a, 'tcx> Lift<'tcx> for traits::ObligationCause<'a> {\n     type Lifted = traits::ObligationCause<'tcx>;\n     fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n-        tcx.lift(&self.code).map(|code| {\n-            traits::ObligationCause {\n-                span: self.span,\n-                body_id: self.body_id,\n-                code,\n-            }\n+        tcx.lift(&self.code).map(|code| traits::ObligationCause {\n+            span: self.span,\n+            body_id: self.body_id,\n+            code,\n         })\n     }\n }\n@@ -283,75 +271,63 @@ impl<'a, 'tcx> Lift<'tcx> for traits::Vtable<'a, ()> {\n             traits::VtableImpl(traits::VtableImplData {\n                 impl_def_id,\n                 substs,\n-                nested\n-            }) => {\n-                tcx.lift(&substs).map(|substs| {\n-                    traits::VtableImpl(traits::VtableImplData {\n-                        impl_def_id,\n-                        substs,\n-                        nested,\n-                    })\n+                nested,\n+            }) => tcx.lift(&substs).map(|substs| {\n+                traits::VtableImpl(traits::VtableImplData {\n+                    impl_def_id,\n+                    substs,\n+                    nested,\n                 })\n-            }\n+            }),\n             traits::VtableAutoImpl(t) => Some(traits::VtableAutoImpl(t)),\n             traits::VtableGenerator(traits::VtableGeneratorData {\n                 generator_def_id,\n                 substs,\n-                nested\n-            }) => {\n-                tcx.lift(&substs).map(|substs| {\n-                    traits::VtableGenerator(traits::VtableGeneratorData {\n-                        generator_def_id: generator_def_id,\n-                        substs: substs,\n-                        nested: nested\n-                    })\n+                nested,\n+            }) => tcx.lift(&substs).map(|substs| {\n+                traits::VtableGenerator(traits::VtableGeneratorData {\n+                    generator_def_id: generator_def_id,\n+                    substs: substs,\n+                    nested: nested,\n                 })\n-            }\n+            }),\n             traits::VtableClosure(traits::VtableClosureData {\n                 closure_def_id,\n                 substs,\n-                nested\n-            }) => {\n-                tcx.lift(&substs).map(|substs| {\n-                    traits::VtableClosure(traits::VtableClosureData {\n-                        closure_def_id,\n-                        substs,\n-                        nested,\n-                    })\n+                nested,\n+            }) => tcx.lift(&substs).map(|substs| {\n+                traits::VtableClosure(traits::VtableClosureData {\n+                    closure_def_id,\n+                    substs,\n+                    nested,\n                 })\n-            }\n+            }),\n             traits::VtableFnPointer(traits::VtableFnPointerData { fn_ty, nested }) => {\n                 tcx.lift(&fn_ty).map(|fn_ty| {\n-                    traits::VtableFnPointer(traits::VtableFnPointerData {\n-                        fn_ty,\n-                        nested,\n-                    })\n+                    traits::VtableFnPointer(traits::VtableFnPointerData { fn_ty, nested })\n                 })\n             }\n             traits::VtableParam(n) => Some(traits::VtableParam(n)),\n             traits::VtableBuiltin(n) => Some(traits::VtableBuiltin(n)),\n             traits::VtableObject(traits::VtableObjectData {\n                 upcast_trait_ref,\n                 vtable_base,\n-                nested\n-            }) => {\n-                tcx.lift(&upcast_trait_ref).map(|trait_ref| {\n-                    traits::VtableObject(traits::VtableObjectData {\n-                        upcast_trait_ref: trait_ref,\n-                        vtable_base,\n-                        nested,\n-                    })\n+                nested,\n+            }) => tcx.lift(&upcast_trait_ref).map(|trait_ref| {\n+                traits::VtableObject(traits::VtableObjectData {\n+                    upcast_trait_ref: trait_ref,\n+                    vtable_base,\n+                    nested,\n                 })\n-            }\n+            }),\n         }\n     }\n }\n \n ///////////////////////////////////////////////////////////////////////////\n // TypeFoldable implementations.\n \n-impl<'tcx, O: TypeFoldable<'tcx>> TypeFoldable<'tcx> for traits::Obligation<'tcx, O>\n-{\n+impl<'tcx, O: TypeFoldable<'tcx>> TypeFoldable<'tcx> for traits::Obligation<'tcx, O> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         traits::Obligation {\n             cause: self.cause.clone(),\n@@ -536,6 +512,14 @@ EnumTypeFoldableImpl! {\n     }\n }\n \n+EnumLiftImpl! {\n+    impl<'a, 'tcx> Lift<'tcx> for traits::WhereClauseAtom<'a> {\n+        type Lifted = traits::WhereClauseAtom<'tcx>;\n+        (traits::WhereClauseAtom::Implemented)(trait_ref),\n+        (traits::WhereClauseAtom::ProjectionEq)(projection),\n+    }\n+}\n+\n EnumTypeFoldableImpl! {\n     impl<'tcx> TypeFoldable<'tcx> for traits::DomainGoal<'tcx> {\n         (traits::DomainGoal::Holds)(wc),\n@@ -549,7 +533,21 @@ EnumTypeFoldableImpl! {\n     }\n }\n \n-CloneTypeFoldableImpls! {\n+EnumLiftImpl! {\n+    impl<'a, 'tcx> Lift<'tcx> for traits::DomainGoal<'a> {\n+        type Lifted = traits::DomainGoal<'tcx>;\n+        (traits::DomainGoal::Holds)(wc),\n+        (traits::DomainGoal::WellFormed)(wc),\n+        (traits::DomainGoal::FromEnv)(wc),\n+        (traits::DomainGoal::WellFormedTy)(ty),\n+        (traits::DomainGoal::Normalize)(projection),\n+        (traits::DomainGoal::FromEnvTy)(ty),\n+        (traits::DomainGoal::RegionOutlives)(predicate),\n+        (traits::DomainGoal::TypeOutlives)(predicate),\n+    }\n+}\n+\n+CloneTypeFoldableAndLiftImpls! {\n     traits::QuantifierKind,\n }\n \n@@ -564,9 +562,23 @@ EnumTypeFoldableImpl! {\n     }\n }\n \n+EnumLiftImpl! {\n+    impl<'a, 'tcx> Lift<'tcx> for traits::Goal<'a> {\n+        type Lifted = traits::Goal<'tcx>;\n+        (traits::Goal::Implies)(hypotheses, goal),\n+        (traits::Goal::And)(goal1, goal2),\n+        (traits::Goal::Not)(goal),\n+        (traits::Goal::DomainGoal)(domain_goal),\n+        (traits::Goal::Quantified)(kind, goal),\n+        (traits::Goal::CannotProve),\n+    }\n+}\n+\n impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::Slice<traits::Goal<'tcx>> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        let v = self.iter().map(|t| t.fold_with(folder)).collect::<AccumulateVec<[_; 8]>>();\n+        let v = self.iter()\n+            .map(|t| t.fold_with(folder))\n+            .collect::<AccumulateVec<[_; 8]>>();\n         folder.tcx().intern_goals(&v)\n     }\n \n@@ -602,11 +614,69 @@ EnumTypeFoldableImpl! {\n \n impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::Slice<traits::Clause<'tcx>> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        let v = self.iter().map(|t| t.fold_with(folder)).collect::<AccumulateVec<[_; 8]>>();\n+        let v = self.iter()\n+            .map(|t| t.fold_with(folder))\n+            .collect::<AccumulateVec<[_; 8]>>();\n         folder.tcx().intern_clauses(&v)\n     }\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n         self.iter().any(|t| t.visit_with(visitor))\n     }\n }\n+\n+impl<'tcx, C> TypeFoldable<'tcx> for chalk_engine::ExClause<C>\n+where\n+    C: traits::ExClauseFold<'tcx>,\n+    C::Substitution: Clone,\n+    C::RegionConstraint: Clone,\n+{\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n+        <C as traits::ExClauseFold>::fold_ex_clause_with(\n+            self,\n+            folder,\n+        )\n+    }\n+\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        <C as traits::ExClauseFold>::visit_ex_clause_with(\n+            self,\n+            visitor,\n+        )\n+    }\n+}\n+\n+impl<'tcx, C> Lift<'tcx> for chalk_engine::ExClause<C>\n+where\n+    C: chalk_engine::context::Context + Clone,\n+    C: traits::ExClauseLift<'tcx>,\n+{\n+    type Lifted = C::LiftedExClause;\n+\n+    fn lift_to_tcx<'a, 'gcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+        <C as traits::ExClauseLift>::lift_ex_clause_to_tcx(self, tcx)\n+    }\n+}\n+\n+EnumTypeFoldableImpl! {\n+    impl<'tcx, C> TypeFoldable<'tcx> for chalk_engine::DelayedLiteral<C> {\n+        (chalk_engine::DelayedLiteral::CannotProve)(a),\n+        (chalk_engine::DelayedLiteral::Negative)(a),\n+        (chalk_engine::DelayedLiteral::Positive)(a, b),\n+    } where\n+        C: chalk_engine::context::Context + Clone,\n+        C::CanonicalConstrainedSubst: TypeFoldable<'tcx>,\n+}\n+\n+EnumTypeFoldableImpl! {\n+    impl<'tcx, C> TypeFoldable<'tcx> for chalk_engine::Literal<C> {\n+        (chalk_engine::Literal::Negative)(a),\n+        (chalk_engine::Literal::Positive)(a),\n+    } where\n+        C: chalk_engine::context::Context + Clone,\n+        C::GoalInEnvironment: Clone + TypeFoldable<'tcx>,\n+}\n+\n+CloneTypeFoldableAndLiftImpls! {\n+    chalk_engine::TableIndex,\n+}"}, {"sha": "2ffc6e9205fad7aeb185c02c782bc7e5965f8389", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/6f425a920169147cdb55ed84d258a7c0944220c2/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f425a920169147cdb55ed84d258a7c0944220c2/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=6f425a920169147cdb55ed84d258a7c0944220c2", "patch": "@@ -1512,6 +1512,51 @@ impl<'a, 'tcx> Lift<'tcx> for Region<'a> {\n     }\n }\n \n+impl<'a, 'tcx> Lift<'tcx> for &'a Goal<'a> {\n+    type Lifted = &'tcx Goal<'tcx>;\n+    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<&'tcx Goal<'tcx>> {\n+        if tcx.interners.arena.in_arena(*self as *const _) {\n+            return Some(unsafe { mem::transmute(*self) });\n+        }\n+        // Also try in the global tcx if we're not that.\n+        if !tcx.is_global() {\n+            self.lift_to_tcx(tcx.global_tcx())\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx> Lift<'tcx> for &'a Slice<Goal<'a>> {\n+    type Lifted = &'tcx Slice<Goal<'tcx>>;\n+    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<&'tcx Slice<Goal<'tcx>>> {\n+        if tcx.interners.arena.in_arena(*self as *const _) {\n+            return Some(unsafe { mem::transmute(*self) });\n+        }\n+        // Also try in the global tcx if we're not that.\n+        if !tcx.is_global() {\n+            self.lift_to_tcx(tcx.global_tcx())\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx> Lift<'tcx> for &'a Slice<Clause<'a>> {\n+    type Lifted = &'tcx Slice<Clause<'tcx>>;\n+    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<&'tcx Slice<Clause<'tcx>>> {\n+        if tcx.interners.arena.in_arena(*self as *const _) {\n+            return Some(unsafe { mem::transmute(*self) });\n+        }\n+        // Also try in the global tcx if we're not that.\n+        if !tcx.is_global() {\n+            self.lift_to_tcx(tcx.global_tcx())\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n impl<'a, 'tcx> Lift<'tcx> for &'a Const<'a> {\n     type Lifted = &'tcx Const<'tcx>;\n     fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<&'tcx Const<'tcx>> {"}, {"sha": "134983911100ebaebdf4ab3a4b66d36e55467034", "filename": "src/librustc_traits/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6f425a920169147cdb55ed84d258a7c0944220c2/src%2Flibrustc_traits%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/6f425a920169147cdb55ed84d258a7c0944220c2/src%2Flibrustc_traits%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2FCargo.toml?ref=6f425a920169147cdb55ed84d258a7c0944220c2", "patch": "@@ -16,3 +16,4 @@ rustc = { path = \"../librustc\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n syntax = { path = \"../libsyntax\" }\n syntax_pos = { path = \"../libsyntax_pos\" }\n+chalk-engine = { version = \"0.6.0\", default-features=false }"}, {"sha": "fb6583363a677bf372fcd123be263db1e7f5840b", "filename": "src/librustc_traits/chalk_context.rs", "status": "added", "additions": 514, "deletions": 0, "changes": 514, "blob_url": "https://github.com/rust-lang/rust/blob/6f425a920169147cdb55ed84d258a7c0944220c2/src%2Flibrustc_traits%2Fchalk_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f425a920169147cdb55ed84d258a7c0944220c2/src%2Flibrustc_traits%2Fchalk_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fchalk_context.rs?ref=6f425a920169147cdb55ed84d258a7c0944220c2", "patch": "@@ -0,0 +1,514 @@\n+use chalk_engine::fallible::Fallible as ChalkEngineFallible;\n+use chalk_engine::{context, hh::HhGoal, DelayedLiteral, ExClause};\n+use rustc::infer::canonical::{\n+    Canonical, CanonicalVarValues, Canonicalize, QueryRegionConstraint, QueryResult,\n+};\n+use rustc::infer::{InferCtxt, InferOk, LateBoundRegionConversionTime};\n+use rustc::traits::{DomainGoal, ExClauseFold, ExClauseLift, Goal, ProgramClause, QuantifierKind};\n+use rustc::ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n+use rustc::ty::subst::Kind;\n+use rustc::ty::{self, TyCtxt};\n+\n+use std::fmt::{self, Debug};\n+use std::marker::PhantomData;\n+\n+use syntax_pos::DUMMY_SP;\n+\n+#[derive(Copy, Clone, Debug)]\n+crate struct ChalkArenas<'gcx> {\n+    _phantom: PhantomData<&'gcx ()>,\n+}\n+\n+#[derive(Copy, Clone)]\n+crate struct ChalkContext<'cx, 'gcx: 'cx> {\n+    _arenas: ChalkArenas<'gcx>,\n+    _tcx: TyCtxt<'cx, 'gcx, 'gcx>,\n+}\n+\n+#[derive(Copy, Clone)]\n+crate struct ChalkInferenceContext<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n+    infcx: &'cx InferCtxt<'cx, 'gcx, 'tcx>,\n+}\n+\n+#[derive(Copy, Clone, Debug)]\n+crate struct UniverseMap;\n+\n+#[derive(Clone, Debug, PartialEq, Eq, Hash)]\n+crate struct ConstrainedSubst<'tcx> {\n+    subst: CanonicalVarValues<'tcx>,\n+    constraints: Vec<QueryRegionConstraint<'tcx>>,\n+}\n+\n+BraceStructTypeFoldableImpl! {\n+    impl<'tcx> TypeFoldable<'tcx> for ConstrainedSubst<'tcx> {\n+        subst, constraints\n+    }\n+}\n+\n+impl context::Context for ChalkArenas<'tcx> {\n+    type CanonicalExClause = Canonical<'tcx, ExClause<Self>>;\n+\n+    type CanonicalGoalInEnvironment = Canonical<'tcx, ty::ParamEnvAnd<'tcx, Goal<'tcx>>>;\n+\n+    // u-canonicalization not yet implemented\n+    type UCanonicalGoalInEnvironment = Canonical<'tcx, ty::ParamEnvAnd<'tcx, Goal<'tcx>>>;\n+\n+    type CanonicalConstrainedSubst = Canonical<'tcx, ConstrainedSubst<'tcx>>;\n+\n+    // u-canonicalization not yet implemented\n+    type UniverseMap = UniverseMap;\n+\n+    type Solution = Canonical<'tcx, QueryResult<'tcx, ()>>;\n+\n+    type InferenceNormalizedSubst = CanonicalVarValues<'tcx>;\n+\n+    type GoalInEnvironment = ty::ParamEnvAnd<'tcx, Goal<'tcx>>;\n+\n+    type RegionConstraint = QueryRegionConstraint<'tcx>;\n+\n+    type Substitution = CanonicalVarValues<'tcx>;\n+\n+    type Environment = ty::ParamEnv<'tcx>;\n+\n+    type Goal = Goal<'tcx>;\n+\n+    type DomainGoal = DomainGoal<'tcx>;\n+\n+    type BindersGoal = ty::Binder<&'tcx Goal<'tcx>>;\n+\n+    type Parameter = Kind<'tcx>;\n+\n+    type ProgramClause = ProgramClause<'tcx>;\n+\n+    type ProgramClauses = Vec<ProgramClause<'tcx>>;\n+\n+    type UnificationResult = InferOk<'tcx, ()>;\n+\n+    fn into_goal(domain_goal: DomainGoal<'tcx>) -> Goal<'tcx> {\n+        Goal::DomainGoal(domain_goal)\n+    }\n+\n+    fn cannot_prove() -> Goal<'tcx> {\n+        Goal::CannotProve\n+    }\n+\n+    fn goal_in_environment(\n+        env: &ty::ParamEnv<'tcx>,\n+        goal: Goal<'tcx>,\n+    ) -> ty::ParamEnvAnd<'tcx, Goal<'tcx>> {\n+        env.and(goal)\n+    }\n+}\n+\n+impl context::AggregateOps<ChalkArenas<'gcx>> for ChalkContext<'cx, 'gcx> {\n+    fn make_solution(\n+        &self,\n+        _root_goal: &Canonical<'gcx, ty::ParamEnvAnd<'gcx, Goal<'gcx>>>,\n+        _simplified_answers: impl context::AnswerStream<ChalkArenas<'gcx>>,\n+    ) -> Option<Canonical<'gcx, QueryResult<'gcx, ()>>> {\n+        unimplemented!()\n+    }\n+}\n+\n+impl context::ContextOps<ChalkArenas<'gcx>> for ChalkContext<'cx, 'gcx> {\n+    /// True if this is a coinductive goal -- e.g., proving an auto trait.\n+    fn is_coinductive(&self, _goal: &Canonical<'gcx, ty::ParamEnvAnd<'gcx, Goal<'gcx>>>) -> bool {\n+        unimplemented!()\n+    }\n+\n+    /// Create an inference table for processing a new goal and instantiate that goal\n+    /// in that context, returning \"all the pieces\".\n+    ///\n+    /// More specifically: given a u-canonical goal `arg`, creates a\n+    /// new inference table `T` and populates it with the universes\n+    /// found in `arg`. Then, creates a substitution `S` that maps\n+    /// each bound variable in `arg` to a fresh inference variable\n+    /// from T. Returns:\n+    ///\n+    /// - the table `T`\n+    /// - the substitution `S`\n+    /// - the environment and goal found by substitution `S` into `arg`\n+    fn instantiate_ucanonical_goal<R>(\n+        &self,\n+        _arg: &Canonical<'gcx, ty::ParamEnvAnd<'gcx, Goal<'gcx>>>,\n+        _op: impl context::WithInstantiatedUCanonicalGoal<ChalkArenas<'gcx>, Output = R>,\n+    ) -> R {\n+        unimplemented!()\n+    }\n+\n+    fn instantiate_ex_clause<R>(\n+        &self,\n+        _num_universes: usize,\n+        _canonical_ex_clause: &Canonical<'gcx, ChalkExClause<'gcx>>,\n+        _op: impl context::WithInstantiatedExClause<ChalkArenas<'gcx>, Output = R>,\n+    ) -> R {\n+        unimplemented!()\n+    }\n+\n+    /// True if this solution has no region constraints.\n+    fn empty_constraints(ccs: &Canonical<'gcx, ConstrainedSubst<'gcx>>) -> bool {\n+        ccs.value.constraints.is_empty()\n+    }\n+\n+    fn inference_normalized_subst_from_ex_clause(\n+        canon_ex_clause: &'a Canonical<'gcx, ChalkExClause<'gcx>>,\n+    ) -> &'a CanonicalVarValues<'gcx> {\n+        &canon_ex_clause.value.subst\n+    }\n+\n+    fn inference_normalized_subst_from_subst(\n+        canon_subst: &'a Canonical<'gcx, ConstrainedSubst<'gcx>>,\n+    ) -> &'a CanonicalVarValues<'gcx> {\n+        &canon_subst.value.subst\n+    }\n+\n+    fn canonical(\n+        u_canon: &'a Canonical<'gcx, ty::ParamEnvAnd<'gcx, Goal<'gcx>>>,\n+    ) -> &'a Canonical<'gcx, ty::ParamEnvAnd<'gcx, Goal<'gcx>>> {\n+        u_canon\n+    }\n+\n+    fn is_trivial_substitution(\n+        _u_canon: &Canonical<'gcx, ty::ParamEnvAnd<'gcx, Goal<'gcx>>>,\n+        _canonical_subst: &Canonical<'gcx, ConstrainedSubst<'gcx>>,\n+    ) -> bool {\n+        unimplemented!()\n+    }\n+\n+    fn num_universes(_: &Canonical<'gcx, ty::ParamEnvAnd<'gcx, Goal<'gcx>>>) -> usize {\n+        0 // FIXME\n+    }\n+\n+    /// Convert a goal G *from* the canonical universes *into* our\n+    /// local universes. This will yield a goal G' that is the same\n+    /// but for the universes of universally quantified names.\n+    fn map_goal_from_canonical(\n+        _map: &UniverseMap,\n+        value: &Canonical<'gcx, ty::ParamEnvAnd<'gcx, Goal<'gcx>>>,\n+    ) -> Canonical<'gcx, ty::ParamEnvAnd<'gcx, Goal<'gcx>>> {\n+        *value // FIXME universe maps not implemented yet\n+    }\n+\n+    fn map_subst_from_canonical(\n+        _map: &UniverseMap,\n+        value: &Canonical<'gcx, ConstrainedSubst<'gcx>>,\n+    ) -> Canonical<'gcx, ConstrainedSubst<'gcx>> {\n+        value.clone() // FIXME universe maps not implemented yet\n+    }\n+}\n+\n+//impl context::UCanonicalGoalInEnvironment<ChalkContext<'cx, 'gcx>>\n+//    for Canonical<'gcx, ty::ParamEnvAnd<'gcx, Goal<'gcx>>>\n+//{\n+//    fn canonical(&self) -> &Canonical<'gcx, ty::ParamEnvAnd<'gcx, Goal<'gcx>>> {\n+//        self\n+//    }\n+//\n+//    fn is_trivial_substitution(\n+//        &self,\n+//        canonical_subst: &Canonical<'tcx, ConstrainedSubst<'tcx>>,\n+//    ) -> bool {\n+//        let subst = &canonical_subst.value.subst;\n+//        assert_eq!(self.canonical.variables.len(), subst.var_values.len());\n+//        subst\n+//            .var_values\n+//            .iter_enumerated()\n+//            .all(|(cvar, kind)| match kind.unpack() {\n+//                Kind::Lifetime(r) => match r {\n+//                    ty::ReCanonical(cvar1) => cvar == cvar1,\n+//                    _ => false,\n+//                },\n+//                Kind::Type(ty) => match ty.sty {\n+//                    ty::TyInfer(ty::InferTy::CanonicalTy(cvar1)) => cvar == cvar1,\n+//                    _ => false,\n+//                },\n+//            })\n+//    }\n+//\n+//    fn num_universes(&self) -> usize {\n+//        0 // FIXME\n+//    }\n+//}\n+\n+impl context::InferenceTable<ChalkArenas<'gcx>, ChalkArenas<'tcx>>\n+    for ChalkInferenceContext<'cx, 'gcx, 'tcx>\n+{\n+    fn into_hh_goal(&mut self, goal: Goal<'tcx>) -> ChalkHhGoal<'tcx> {\n+        match goal {\n+            Goal::Implies(..) => panic!(\"FIXME rust-lang-nursery/chalk#94\"),\n+            Goal::And(left, right) => HhGoal::And(*left, *right),\n+            Goal::Not(subgoal) => HhGoal::Not(*subgoal),\n+            Goal::DomainGoal(d) => HhGoal::DomainGoal(d),\n+            Goal::Quantified(QuantifierKind::Universal, binder) => HhGoal::ForAll(binder),\n+            Goal::Quantified(QuantifierKind::Existential, binder) => HhGoal::Exists(binder),\n+            Goal::CannotProve => HhGoal::CannotProve,\n+        }\n+    }\n+\n+    fn add_clauses(\n+        &mut self,\n+        _env: &ty::ParamEnv<'tcx>,\n+        _clauses: Vec<ProgramClause<'tcx>>,\n+    ) -> ty::ParamEnv<'tcx> {\n+        panic!(\"FIXME no method to add clauses to ParamEnv yet\")\n+    }\n+}\n+\n+impl context::ResolventOps<ChalkArenas<'gcx>, ChalkArenas<'tcx>>\n+    for ChalkInferenceContext<'cx, 'gcx, 'tcx>\n+{\n+    fn resolvent_clause(\n+        &mut self,\n+        _environment: &ty::ParamEnv<'tcx>,\n+        _goal: &DomainGoal<'tcx>,\n+        _subst: &CanonicalVarValues<'tcx>,\n+        _clause: &ProgramClause<'tcx>,\n+    ) -> chalk_engine::fallible::Fallible<Canonical<'gcx, ChalkExClause<'gcx>>> {\n+        panic!()\n+    }\n+\n+    fn apply_answer_subst(\n+        &mut self,\n+        _ex_clause: ChalkExClause<'tcx>,\n+        _selected_goal: &ty::ParamEnvAnd<'tcx, Goal<'tcx>>,\n+        _answer_table_goal: &Canonical<'gcx, ty::ParamEnvAnd<'gcx, Goal<'gcx>>>,\n+        _canonical_answer_subst: &Canonical<'gcx, ConstrainedSubst<'gcx>>,\n+    ) -> chalk_engine::fallible::Fallible<ChalkExClause<'tcx>> {\n+        panic!()\n+    }\n+}\n+\n+impl context::TruncateOps<ChalkArenas<'gcx>, ChalkArenas<'tcx>>\n+    for ChalkInferenceContext<'cx, 'gcx, 'tcx>\n+{\n+    fn truncate_goal(\n+        &mut self,\n+        subgoal: &ty::ParamEnvAnd<'tcx, Goal<'tcx>>,\n+    ) -> Option<ty::ParamEnvAnd<'tcx, Goal<'tcx>>> {\n+        Some(*subgoal) // FIXME we should truncate at some point!\n+    }\n+\n+    fn truncate_answer(\n+        &mut self,\n+        subst: &CanonicalVarValues<'tcx>,\n+    ) -> Option<CanonicalVarValues<'tcx>> {\n+        Some(subst.clone()) // FIXME we should truncate at some point!\n+    }\n+}\n+\n+impl context::UnificationOps<ChalkArenas<'gcx>, ChalkArenas<'tcx>>\n+    for ChalkInferenceContext<'cx, 'gcx, 'tcx>\n+{\n+    fn program_clauses(\n+        &self,\n+        _environment: &ty::ParamEnv<'tcx>,\n+        goal: &DomainGoal<'tcx>,\n+    ) -> Vec<ProgramClause<'tcx>> {\n+        use rustc::traits::DomainGoal::*;\n+        use rustc::traits::WhereClauseAtom::*;\n+\n+        match goal {\n+            Holds(Implemented(_trait_predicate)) => {\n+                // These come from:\n+                //\n+                // - Trait definitions (implied bounds)\n+                // - Implementations of the trait itself\n+                panic!()\n+            }\n+\n+            Holds(ProjectionEq(_projection_predicate)) => {\n+                // These come from:\n+                panic!()\n+            }\n+\n+            WellFormed(Implemented(_trait_predicate)) => {\n+                // These come from -- the trait decl.\n+                panic!()\n+            }\n+\n+            WellFormed(ProjectionEq(_projection_predicate)) => panic!(),\n+\n+            FromEnv(Implemented(_trait_predicate)) => panic!(),\n+\n+            FromEnv(ProjectionEq(_projection_predicate)) => panic!(),\n+\n+            WellFormedTy(_ty) => panic!(),\n+\n+            FromEnvTy(_ty) => panic!(),\n+\n+            RegionOutlives(_region_outlives) => panic!(),\n+\n+            TypeOutlives(_type_outlives) => panic!(),\n+\n+            Normalize(_) => panic!(),\n+        }\n+    }\n+\n+    fn instantiate_binders_universally(\n+        &mut self,\n+        _arg: &ty::Binder<&'tcx Goal<'tcx>>,\n+    ) -> Goal<'tcx> {\n+        panic!(\"FIXME -- universal instantiation needs sgrif's branch\")\n+    }\n+\n+    fn instantiate_binders_existentially(\n+        &mut self,\n+        arg: &ty::Binder<&'tcx Goal<'tcx>>,\n+    ) -> Goal<'tcx> {\n+        let (value, _map) = self.infcx.replace_late_bound_regions_with_fresh_var(\n+            DUMMY_SP,\n+            LateBoundRegionConversionTime::HigherRankedType,\n+            arg,\n+        );\n+        *value\n+    }\n+\n+    fn debug_ex_clause(&mut self, value: &'v ChalkExClause<'tcx>) -> Box<dyn Debug + 'v> {\n+        let string = format!(\"{:?}\", self.infcx.resolve_type_vars_if_possible(value));\n+        Box::new(string)\n+    }\n+\n+    fn canonicalize_goal(\n+        &mut self,\n+        value: &ty::ParamEnvAnd<'tcx, Goal<'tcx>>,\n+    ) -> Canonical<'gcx, ty::ParamEnvAnd<'gcx, Goal<'gcx>>> {\n+        self.infcx.canonicalize_query(value).0\n+    }\n+\n+    fn canonicalize_ex_clause(\n+        &mut self,\n+        value: &ChalkExClause<'tcx>,\n+    ) -> Canonical<'gcx, ChalkExClause<'gcx>> {\n+        self.infcx.canonicalize_response(value).0\n+    }\n+\n+    fn canonicalize_constrained_subst(\n+        &mut self,\n+        subst: CanonicalVarValues<'tcx>,\n+        constraints: Vec<QueryRegionConstraint<'tcx>>,\n+    ) -> Canonical<'gcx, ConstrainedSubst<'gcx>> {\n+        self.infcx\n+            .canonicalize_response(&ConstrainedSubst { subst, constraints })\n+            .0\n+    }\n+\n+    fn u_canonicalize_goal(\n+        &mut self,\n+        value: &Canonical<'gcx, ty::ParamEnvAnd<'gcx, Goal<'gcx>>>,\n+    ) -> (\n+        Canonical<'gcx, ty::ParamEnvAnd<'gcx, Goal<'gcx>>>,\n+        UniverseMap,\n+    ) {\n+        (value.clone(), UniverseMap)\n+    }\n+\n+    fn invert_goal(\n+        &mut self,\n+        _value: &ty::ParamEnvAnd<'tcx, Goal<'tcx>>,\n+    ) -> Option<ty::ParamEnvAnd<'tcx, Goal<'tcx>>> {\n+        panic!(\"goal inversion not yet implemented\")\n+    }\n+\n+    fn unify_parameters(\n+        &mut self,\n+        _environment: &ty::ParamEnv<'tcx>,\n+        _a: &Kind<'tcx>,\n+        _b: &Kind<'tcx>,\n+    ) -> ChalkEngineFallible<InferOk<'tcx, ()>> {\n+        panic!()\n+    }\n+\n+    fn sink_answer_subset(\n+        &self,\n+        value: &Canonical<'gcx, ConstrainedSubst<'gcx>>,\n+    ) -> Canonical<'tcx, ConstrainedSubst<'tcx>> {\n+        value.clone()\n+    }\n+\n+    fn lift_delayed_literal(\n+        &self,\n+        _value: DelayedLiteral<ChalkArenas<'tcx>>,\n+    ) -> DelayedLiteral<ChalkArenas<'gcx>> {\n+        panic!(\"lift\")\n+    }\n+\n+    fn into_ex_clause(&mut self, _result: InferOk<'tcx, ()>, _ex_clause: &mut ChalkExClause<'tcx>) {\n+        panic!(\"TBD\")\n+    }\n+}\n+\n+type ChalkHhGoal<'tcx> = HhGoal<ChalkArenas<'tcx>>;\n+\n+type ChalkExClause<'tcx> = ExClause<ChalkArenas<'tcx>>;\n+\n+impl Debug for ChalkContext<'cx, 'gcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"ChalkContext\")\n+    }\n+}\n+\n+impl Debug for ChalkInferenceContext<'cx, 'gcx, 'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"ChalkInferenceContext\")\n+    }\n+}\n+\n+impl ExClauseLift<'gcx> for ChalkArenas<'a> {\n+    type LiftedExClause = ChalkExClause<'gcx>;\n+\n+    fn lift_ex_clause_to_tcx(\n+        _ex_clause: &ChalkExClause<'a>,\n+        _tcx: TyCtxt<'_, '_, 'tcx>,\n+    ) -> Option<Self::LiftedExClause> {\n+        panic!()\n+    }\n+}\n+\n+impl ExClauseFold<'tcx> for ChalkArenas<'tcx> {\n+    fn fold_ex_clause_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(\n+        ex_clause: &ChalkExClause<'tcx>,\n+        folder: &mut F,\n+    ) -> ChalkExClause<'tcx> {\n+        ExClause {\n+            subst: ex_clause.subst.fold_with(folder),\n+            delayed_literals: ex_clause.delayed_literals.fold_with(folder),\n+            constraints: ex_clause.constraints.fold_with(folder),\n+            subgoals: ex_clause.subgoals.fold_with(folder),\n+        }\n+    }\n+\n+    fn visit_ex_clause_with<'gcx: 'tcx, V: TypeVisitor<'tcx>>(\n+        ex_clause: &ExClause<Self>,\n+        visitor: &mut V,\n+    ) -> bool {\n+        let ExClause {\n+            subst,\n+            delayed_literals,\n+            constraints,\n+            subgoals,\n+        } = ex_clause;\n+        subst.visit_with(visitor)\n+            && delayed_literals.visit_with(visitor)\n+            && constraints.visit_with(visitor)\n+            && subgoals.visit_with(visitor)\n+    }\n+}\n+\n+BraceStructLiftImpl! {\n+    impl<'a, 'tcx> Lift<'tcx> for ConstrainedSubst<'a> {\n+        type Lifted = ConstrainedSubst<'tcx>;\n+\n+        subst, constraints\n+    }\n+}\n+\n+impl<'gcx: 'tcx, 'tcx> Canonicalize<'gcx, 'tcx> for ConstrainedSubst<'tcx> {\n+    type Canonicalized = Canonical<'gcx, ConstrainedSubst<'gcx>>;\n+\n+    fn intern(\n+        _gcx: TyCtxt<'_, 'gcx, 'gcx>,\n+        value: Canonical<'gcx, ConstrainedSubst<'gcx>>,\n+    ) -> Self::Canonicalized {\n+        value\n+    }\n+}"}, {"sha": "733d8e1708ec08c2a4bca4ec91a06737cd86813d", "filename": "src/librustc_traits/lib.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6f425a920169147cdb55ed84d258a7c0944220c2/src%2Flibrustc_traits%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f425a920169147cdb55ed84d258a7c0944220c2/src%2Flibrustc_traits%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Flib.rs?ref=6f425a920169147cdb55ed84d258a7c0944220c2", "patch": "@@ -11,9 +11,13 @@\n //! New recursive solver modeled on Chalk's recursive solver. Most of\n //! the guts are broken up into modules; see the comments in those modules.\n \n+#![feature(crate_in_paths)]\n #![feature(crate_visibility_modifier)]\n+#![feature(extern_prelude)]\n #![feature(iterator_find_map)]\n+#![feature(in_band_lifetimes)]\n \n+extern crate chalk_engine;\n #[macro_use]\n extern crate log;\n #[macro_use]\n@@ -22,6 +26,7 @@ extern crate rustc_data_structures;\n extern crate syntax;\n extern crate syntax_pos;\n \n+mod chalk_context;\n mod dropck_outlives;\n mod evaluate_obligation;\n mod normalize_projection_ty;"}, {"sha": "32f18a62abe596cd83289a169725b25b35516a11", "filename": "src/librustc_traits/lowering.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f425a920169147cdb55ed84d258a7c0944220c2/src%2Flibrustc_traits%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f425a920169147cdb55ed84d258a7c0944220c2/src%2Flibrustc_traits%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Flowering.rs?ref=6f425a920169147cdb55ed84d258a7c0944220c2", "patch": "@@ -22,7 +22,7 @@ use syntax::ast;\n \n use std::iter;\n \n-trait Lower<T> {\n+crate trait Lower<T> {\n     /// Lower a rustc construction (e.g. `ty::TraitPredicate`) to a chalk-like type.\n     fn lower(&self) -> T;\n }"}]}