{"sha": "dd4fa906fcc3f21eca8d8ce958b4728ed62581e1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRkNGZhOTA2ZmNjM2YyMWVjYThkOGNlOTU4YjQ3MjhlZDYyNTgxZTE=", "commit": {"author": {"name": "Kasey Carrothers", "email": "kaseyc.808@gmail.com", "date": "2014-09-26T06:49:17Z"}, "committer": {"name": "Kasey Carrothers", "email": "kaseyc.808@gmail.com", "date": "2014-10-09T01:35:29Z"}, "message": "Clean up the implementations of Bitv and BitvSet.\n\nFunctions that add bits now ensure that any unused bits are set to 0.\n`into_bitv` sanitizes the nbits of the Bitv/BitvSet it returns by setting the nbits to the current capacity.\nFix a bug with `union_with` and `symmetric_difference` with due to not updating nbits properly\nAdd test cases to the _with functions\nRemove `get_mut_ref`\n\nThis is a [breaking-change]. The things you will need to fix are:\n\n1. BitvSet's `unwrap()` has been renamed to `into_bitv`\n2. BitvSet's `get_mut_ref()` has been removed. Use `into_bitv()` and `from_bitv()` instead.", "tree": {"sha": "59bf1c4db9a2a28bdcb7344f84acac9b747fa0e0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/59bf1c4db9a2a28bdcb7344f84acac9b747fa0e0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dd4fa906fcc3f21eca8d8ce958b4728ed62581e1", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dd4fa906fcc3f21eca8d8ce958b4728ed62581e1", "html_url": "https://github.com/rust-lang/rust/commit/dd4fa906fcc3f21eca8d8ce958b4728ed62581e1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dd4fa906fcc3f21eca8d8ce958b4728ed62581e1/comments", "author": {"login": "kaseyc", "id": 2405952, "node_id": "MDQ6VXNlcjI0MDU5NTI=", "avatar_url": "https://avatars.githubusercontent.com/u/2405952?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kaseyc", "html_url": "https://github.com/kaseyc", "followers_url": "https://api.github.com/users/kaseyc/followers", "following_url": "https://api.github.com/users/kaseyc/following{/other_user}", "gists_url": "https://api.github.com/users/kaseyc/gists{/gist_id}", "starred_url": "https://api.github.com/users/kaseyc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kaseyc/subscriptions", "organizations_url": "https://api.github.com/users/kaseyc/orgs", "repos_url": "https://api.github.com/users/kaseyc/repos", "events_url": "https://api.github.com/users/kaseyc/events{/privacy}", "received_events_url": "https://api.github.com/users/kaseyc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "kaseyc", "id": 2405952, "node_id": "MDQ6VXNlcjI0MDU5NTI=", "avatar_url": "https://avatars.githubusercontent.com/u/2405952?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kaseyc", "html_url": "https://github.com/kaseyc", "followers_url": "https://api.github.com/users/kaseyc/followers", "following_url": "https://api.github.com/users/kaseyc/following{/other_user}", "gists_url": "https://api.github.com/users/kaseyc/gists{/gist_id}", "starred_url": "https://api.github.com/users/kaseyc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kaseyc/subscriptions", "organizations_url": "https://api.github.com/users/kaseyc/orgs", "repos_url": "https://api.github.com/users/kaseyc/repos", "events_url": "https://api.github.com/users/kaseyc/events{/privacy}", "received_events_url": "https://api.github.com/users/kaseyc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "63fe80e1ffd036e99e1c707116774ac10203e2f1", "url": "https://api.github.com/repos/rust-lang/rust/commits/63fe80e1ffd036e99e1c707116774ac10203e2f1", "html_url": "https://github.com/rust-lang/rust/commit/63fe80e1ffd036e99e1c707116774ac10203e2f1"}], "stats": {"total": 188, "additions": 131, "deletions": 57}, "files": [{"sha": "8f9873d77d17e5b69fdf8fae78a3694996ba4717", "filename": "src/libcollections/bitv.rs", "status": "modified", "additions": 131, "deletions": 57, "changes": 188, "blob_url": "https://github.com/rust-lang/rust/blob/dd4fa906fcc3f21eca8d8ce958b4728ed62581e1/src%2Flibcollections%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd4fa906fcc3f21eca8d8ce958b4728ed62581e1/src%2Flibcollections%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbitv.rs?ref=dd4fa906fcc3f21eca8d8ce958b4728ed62581e1", "patch": "@@ -235,11 +235,20 @@ impl Bitv {\n     /// }\n     /// ```\n     pub fn with_capacity(nbits: uint, init: bool) -> Bitv {\n-        Bitv {\n+        let mut bitv = Bitv {\n             storage: Vec::from_elem((nbits + uint::BITS - 1) / uint::BITS,\n                                     if init { !0u } else { 0u }),\n             nbits: nbits\n+        };\n+\n+        // Zero out any unused bits in the highest word if necessary\n+        let used_bits = bitv.nbits % uint::BITS;\n+        if init && used_bits != 0 {\n+            let largest_used_word = (bitv.nbits + uint::BITS - 1) / uint::BITS - 1;\n+            *bitv.storage.get_mut(largest_used_word) &= (1 << used_bits) - 1;\n         }\n+\n+        bitv\n     }\n \n     /// Retrieves the value at index `i`.\n@@ -629,9 +638,9 @@ impl Bitv {\n     /// ```\n     pub fn reserve(&mut self, size: uint) {\n         let old_size = self.storage.len();\n-        let size = (size + uint::BITS - 1) / uint::BITS;\n-        if old_size < size {\n-            self.storage.grow(size - old_size, 0);\n+        let new_size = (size + uint::BITS - 1) / uint::BITS;\n+        if old_size < new_size {\n+            self.storage.grow(new_size - old_size, 0);\n         }\n     }\n \n@@ -686,8 +695,15 @@ impl Bitv {\n         }\n         // Allocate new words, if needed\n         if new_nwords > self.storage.len() {\n-          let to_add = new_nwords - self.storage.len();\n-          self.storage.grow(to_add, full_value);\n+            let to_add = new_nwords - self.storage.len();\n+            self.storage.grow(to_add, full_value);\n+\n+            // Zero out and unused bits in the new tail word\n+            if value {\n+                let tail_word = new_nwords - 1;\n+                let used_bits = new_nbits % uint::BITS;\n+                *self.storage.get_mut(tail_word) &= (1 << used_bits) - 1;\n+            }\n         }\n         // Adjust internal bit count\n         self.nbits = new_nbits;\n@@ -970,9 +986,8 @@ impl<'a> RandomAccessIterator<bool> for Bits<'a> {\n /// }\n ///\n /// // Can convert back to a `Bitv`\n-/// let bv: Bitv = s.unwrap();\n-/// assert!(bv.eq_vec([true, true, false, true,\n-///                    false, false, false, false]));\n+/// let bv: Bitv = s.into_bitv();\n+/// assert!(bv.get(3));\n /// ```\n #[deriving(Clone)]\n pub struct BitvSet(Bitv);\n@@ -993,7 +1008,8 @@ impl FromIterator<bool> for BitvSet {\n impl Extendable<bool> for BitvSet {\n     #[inline]\n     fn extend<I: Iterator<bool>>(&mut self, iterator: I) {\n-        self.get_mut_ref().extend(iterator);\n+        let &BitvSet(ref mut self_bitv) = self;\n+        self_bitv.extend(iterator);\n     }\n }\n \n@@ -1049,7 +1065,8 @@ impl BitvSet {\n     /// ```\n     #[inline]\n     pub fn with_capacity(nbits: uint) -> BitvSet {\n-        BitvSet(Bitv::with_capacity(nbits, false))\n+        let bitv = Bitv::with_capacity(nbits, false);\n+        BitvSet::from_bitv(bitv)\n     }\n \n     /// Creates a new bit vector set from the given bit vector.\n@@ -1068,7 +1085,9 @@ impl BitvSet {\n     /// }\n     /// ```\n     #[inline]\n-    pub fn from_bitv(bitv: Bitv) -> BitvSet {\n+    pub fn from_bitv(mut bitv: Bitv) -> BitvSet {\n+        // Mark every bit as valid\n+        bitv.nbits = bitv.capacity();\n         BitvSet(bitv)\n     }\n \n@@ -1102,7 +1121,10 @@ impl BitvSet {\n     /// ```\n     pub fn reserve(&mut self, size: uint) {\n         let &BitvSet(ref mut bitv) = self;\n-        bitv.reserve(size)\n+        bitv.reserve(size);\n+        if bitv.nbits < size {\n+            bitv.nbits = bitv.capacity();\n+        }\n     }\n \n     /// Consumes this set to return the underlying bit vector.\n@@ -1116,11 +1138,12 @@ impl BitvSet {\n     /// s.insert(0);\n     /// s.insert(3);\n     ///\n-    /// let bv = s.unwrap();\n-    /// assert!(bv.eq_vec([true, false, false, true]));\n+    /// let bv = s.into_bitv();\n+    /// assert!(bv.get(0));\n+    /// assert!(bv.get(3));\n     /// ```\n     #[inline]\n-    pub fn unwrap(self) -> Bitv {\n+    pub fn into_bitv(self) -> Bitv {\n         let BitvSet(bitv) = self;\n         bitv\n     }\n@@ -1144,38 +1167,15 @@ impl BitvSet {\n         bitv\n     }\n \n-    /// Returns a mutable reference to the underlying bit vector.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::BitvSet;\n-    ///\n-    /// let mut s = BitvSet::new();\n-    /// s.insert(0);\n-    /// assert_eq!(s.contains(&0), true);\n-    /// {\n-    ///     // Will free the set during bv's lifetime\n-    ///     let bv = s.get_mut_ref();\n-    ///     bv.set(0, false);\n-    /// }\n-    /// assert_eq!(s.contains(&0), false);\n-    /// ```\n-    #[inline]\n-    pub fn get_mut_ref<'a>(&'a mut self) -> &'a mut Bitv {\n-        let &BitvSet(ref mut bitv) = self;\n-        bitv\n-    }\n-\n     #[inline]\n     fn other_op(&mut self, other: &BitvSet, f: |uint, uint| -> uint) {\n+        // Expand the vector if necessary\n+        self.reserve(other.capacity());\n+\n         // Unwrap Bitvs\n         let &BitvSet(ref mut self_bitv) = self;\n         let &BitvSet(ref other_bitv) = other;\n \n-        // Expand the vector if necessary\n-        self_bitv.reserve(other_bitv.capacity());\n-\n         // virtually pad other with 0's for equal lengths\n         let mut other_words = {\n             let (_, result) = match_words(self_bitv, other_bitv);\n@@ -1376,9 +1376,10 @@ impl BitvSet {\n     ///\n     /// let mut a = BitvSet::from_bitv(bitv::from_bytes([a]));\n     /// let b = BitvSet::from_bitv(bitv::from_bytes([b]));\n+    /// let res = BitvSet::from_bitv(bitv::from_bytes([res]));\n     ///\n     /// a.union_with(&b);\n-    /// assert_eq!(a.unwrap(), bitv::from_bytes([res]));\n+    /// assert_eq!(a, res);\n     /// ```\n     #[inline]\n     pub fn union_with(&mut self, other: &BitvSet) {\n@@ -1399,9 +1400,10 @@ impl BitvSet {\n     ///\n     /// let mut a = BitvSet::from_bitv(bitv::from_bytes([a]));\n     /// let b = BitvSet::from_bitv(bitv::from_bytes([b]));\n+    /// let res = BitvSet::from_bitv(bitv::from_bytes([res]));\n     ///\n     /// a.intersect_with(&b);\n-    /// assert_eq!(a.unwrap(), bitv::from_bytes([res]));\n+    /// assert_eq!(a, res);\n     /// ```\n     #[inline]\n     pub fn intersect_with(&mut self, other: &BitvSet) {\n@@ -1424,15 +1426,17 @@ impl BitvSet {\n     ///\n     /// let mut bva = BitvSet::from_bitv(bitv::from_bytes([a]));\n     /// let bvb = BitvSet::from_bitv(bitv::from_bytes([b]));\n+    /// let bva_b = BitvSet::from_bitv(bitv::from_bytes([a_b]));\n+    /// let bvb_a = BitvSet::from_bitv(bitv::from_bytes([b_a]));\n     ///\n     /// bva.difference_with(&bvb);\n-    /// assert_eq!(bva.unwrap(), bitv::from_bytes([a_b]));\n+    /// assert_eq!(bva, bva_b);\n     ///\n     /// let bva = BitvSet::from_bitv(bitv::from_bytes([a]));\n     /// let mut bvb = BitvSet::from_bitv(bitv::from_bytes([b]));\n     ///\n     /// bvb.difference_with(&bva);\n-    /// assert_eq!(bvb.unwrap(), bitv::from_bytes([b_a]));\n+    /// assert_eq!(bvb, bvb_a);\n     /// ```\n     #[inline]\n     pub fn difference_with(&mut self, other: &BitvSet) {\n@@ -1454,9 +1458,10 @@ impl BitvSet {\n     ///\n     /// let mut a = BitvSet::from_bitv(bitv::from_bytes([a]));\n     /// let b = BitvSet::from_bitv(bitv::from_bytes([b]));\n+    /// let res = BitvSet::from_bitv(bitv::from_bytes([res]));\n     ///\n     /// a.symmetric_difference_with(&b);\n-    /// assert_eq!(a.unwrap(), bitv::from_bytes([res]));\n+    /// assert_eq!(a, res);\n     /// ```\n     #[inline]\n     pub fn symmetric_difference_with(&mut self, other: &BitvSet) {\n@@ -1538,20 +1543,14 @@ impl MutableSet<uint> for BitvSet {\n         if self.contains(&value) {\n             return false;\n         }\n+\n+        // Ensure we have enough space to hold the new element\n         if value >= self.capacity() {\n             let new_cap = cmp::max(value + 1, self.capacity() * 2);\n             self.reserve(new_cap);\n         }\n+\n         let &BitvSet(ref mut bitv) = self;\n-        if value >= bitv.nbits {\n-            // If we are increasing nbits, make sure we mask out any previously-unconsidered bits\n-            let old_rem = bitv.nbits % uint::BITS;\n-            if old_rem != 0 {\n-                let old_last_word = (bitv.nbits + uint::BITS - 1) / uint::BITS - 1;\n-                *bitv.storage.get_mut(old_last_word) &= (1 << old_rem) - 1;\n-            }\n-            bitv.nbits = value + 1;\n-        }\n         bitv.set(value, true);\n         return true;\n     }\n@@ -2225,14 +2224,15 @@ mod tests {\n         assert!(a.insert(160));\n         assert!(a.insert(19));\n         assert!(a.insert(24));\n+        assert!(a.insert(200));\n \n         assert!(b.insert(1));\n         assert!(b.insert(5));\n         assert!(b.insert(9));\n         assert!(b.insert(13));\n         assert!(b.insert(19));\n \n-        let expected = [1, 3, 5, 9, 11, 13, 19, 24, 160];\n+        let expected = [1, 3, 5, 9, 11, 13, 19, 24, 160, 200];\n         let actual = a.union(&b).collect::<Vec<uint>>();\n         assert_eq!(actual.as_slice(), expected.as_slice());\n     }\n@@ -2281,6 +2281,27 @@ mod tests {\n         assert!(c.is_disjoint(&b))\n     }\n \n+    #[test]\n+    fn test_bitv_set_union_with() {\n+        //a should grow to include larger elements\n+        let mut a = BitvSet::new();\n+        a.insert(0);\n+        let mut b = BitvSet::new();\n+        b.insert(5);\n+        let expected = BitvSet::from_bitv(from_bytes([0b10000100]));\n+        a.union_with(&b);\n+        assert_eq!(a, expected);\n+\n+        // Standard\n+        let mut a = BitvSet::from_bitv(from_bytes([0b10100010]));\n+        let mut b = BitvSet::from_bitv(from_bytes([0b01100010]));\n+        let c = a.clone();\n+        a.union_with(&b);\n+        b.union_with(&c);\n+        assert_eq!(a.len(), 4);\n+        assert_eq!(b.len(), 4);\n+    }\n+\n     #[test]\n     fn test_bitv_set_intersect_with() {\n         // Explicitly 0'ed bits\n@@ -2311,6 +2332,59 @@ mod tests {\n         assert_eq!(b.len(), 2);\n     }\n \n+    #[test]\n+    fn test_bitv_set_difference_with() {\n+        // Explicitly 0'ed bits\n+        let mut a = BitvSet::from_bitv(from_bytes([0b00000000]));\n+        let b = BitvSet::from_bitv(from_bytes([0b10100010]));\n+        a.difference_with(&b);\n+        assert!(a.is_empty());\n+\n+        // Uninitialized bits should behave like 0's\n+        let mut a = BitvSet::new();\n+        let b = BitvSet::from_bitv(from_bytes([0b11111111]));\n+        a.difference_with(&b);\n+        assert!(a.is_empty());\n+\n+        // Standard\n+        let mut a = BitvSet::from_bitv(from_bytes([0b10100010]));\n+        let mut b = BitvSet::from_bitv(from_bytes([0b01100010]));\n+        let c = a.clone();\n+        a.difference_with(&b);\n+        b.difference_with(&c);\n+        assert_eq!(a.len(), 1);\n+        assert_eq!(b.len(), 1);\n+    }\n+\n+    #[test]\n+    fn test_bitv_set_symmetric_difference_with() {\n+        //a should grow to include larger elements\n+        let mut a = BitvSet::new();\n+        a.insert(0);\n+        a.insert(1);\n+        let mut b = BitvSet::new();\n+        b.insert(1);\n+        b.insert(5);\n+        let expected = BitvSet::from_bitv(from_bytes([0b10000100]));\n+        a.symmetric_difference_with(&b);\n+        assert_eq!(a, expected);\n+\n+        let mut a = BitvSet::from_bitv(from_bytes([0b10100010]));\n+        let b = BitvSet::new();\n+        let c = a.clone();\n+        a.symmetric_difference_with(&b);\n+        assert_eq!(a, c);\n+\n+        // Standard\n+        let mut a = BitvSet::from_bitv(from_bytes([0b11100010]));\n+        let mut b = BitvSet::from_bitv(from_bytes([0b01101010]));\n+        let c = a.clone();\n+        a.symmetric_difference_with(&b);\n+        b.symmetric_difference_with(&c);\n+        assert_eq!(a.len(), 2);\n+        assert_eq!(b.len(), 2);\n+    }\n+\n     #[test]\n     fn test_bitv_set_eq() {\n         let a = BitvSet::from_bitv(from_bytes([0b10100010]));"}]}