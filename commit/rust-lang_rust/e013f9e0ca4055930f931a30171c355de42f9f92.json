{"sha": "e013f9e0ca4055930f931a30171c355de42f9f92", "node_id": "C_kwDOAAsO6NoAKGUwMTNmOWUwY2E0MDU1OTMwZjkzMWEzMDE3MWMzNTVkZTQyZjlmOTI", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-05-09T11:49:09Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-05-09T11:49:09Z"}, "message": "Auto merge of #96815 - SparrowLii:promote_const, r=oli-obk\n\noptimize `promote_consts` by caching the results of `validate_local`\n\nFrom the FIXME in the impl of `promote_consts`. Early return the `validate_local` should save some compile time.\n\n`qualif_local` is similar to this, but requires futher changing because there are different types of qualif checks. If this PR is effective, I will do it as well.", "tree": {"sha": "e4c6b675959522c6d5c1aae2add14b2c567deba5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e4c6b675959522c6d5c1aae2add14b2c567deba5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e013f9e0ca4055930f931a30171c355de42f9f92", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e013f9e0ca4055930f931a30171c355de42f9f92", "html_url": "https://github.com/rust-lang/rust/commit/e013f9e0ca4055930f931a30171c355de42f9f92", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e013f9e0ca4055930f931a30171c355de42f9f92/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8a2fe75d0e6e024aa434e5b9c40adb2567f362b8", "url": "https://api.github.com/repos/rust-lang/rust/commits/8a2fe75d0e6e024aa434e5b9c40adb2567f362b8", "html_url": "https://github.com/rust-lang/rust/commit/8a2fe75d0e6e024aa434e5b9c40adb2567f362b8"}, {"sha": "b890037af3eb71fcdacec9ad6d92646715d18836", "url": "https://api.github.com/repos/rust-lang/rust/commits/b890037af3eb71fcdacec9ad6d92646715d18836", "html_url": "https://github.com/rust-lang/rust/commit/b890037af3eb71fcdacec9ad6d92646715d18836"}], "stats": {"total": 94, "additions": 52, "deletions": 42}, "files": [{"sha": "f88538f61ec6eb43d6aaf4cb1b7aea98af3d6650", "filename": "compiler/rustc_const_eval/src/transform/promote_consts.rs", "status": "modified", "additions": 52, "deletions": 42, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/e013f9e0ca4055930f931a30171c355de42f9f92/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e013f9e0ca4055930f931a30171c355de42f9f92/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fpromote_consts.rs?ref=e013f9e0ca4055930f931a30171c355de42f9f92", "patch": "@@ -60,9 +60,9 @@ impl<'tcx> MirPass<'tcx> for PromoteTemps<'tcx> {\n \n         let mut rpo = traversal::reverse_postorder(body);\n         let ccx = ConstCx::new(tcx, body);\n-        let (temps, all_candidates) = collect_temps_and_candidates(&ccx, &mut rpo);\n+        let (mut temps, all_candidates) = collect_temps_and_candidates(&ccx, &mut rpo);\n \n-        let promotable_candidates = validate_candidates(&ccx, &temps, &all_candidates);\n+        let promotable_candidates = validate_candidates(&ccx, &mut temps, &all_candidates);\n \n         let promoted = promote_candidates(body, tcx, temps, promotable_candidates);\n         self.promoted_fragments.set(promoted);\n@@ -77,7 +77,7 @@ pub enum TempState {\n     /// One direct assignment and any number of direct uses.\n     /// A borrow of this temp is promotable if the assigned\n     /// value is qualified as constant.\n-    Defined { location: Location, uses: usize },\n+    Defined { location: Location, uses: usize, valid: Result<(), ()> },\n     /// Any other combination of assignments/uses.\n     Unpromotable,\n     /// This temp was part of an rvalue which got extracted\n@@ -133,7 +133,7 @@ impl<'tcx> Visitor<'tcx> for Collector<'_, 'tcx> {\n             match context {\n                 PlaceContext::MutatingUse(MutatingUseContext::Store)\n                 | PlaceContext::MutatingUse(MutatingUseContext::Call) => {\n-                    *temp = TempState::Defined { location, uses: 0 };\n+                    *temp = TempState::Defined { location, uses: 0, valid: Err(()) };\n                     return;\n                 }\n                 _ => { /* mark as unpromotable below */ }\n@@ -188,7 +188,7 @@ pub fn collect_temps_and_candidates<'tcx>(\n /// This wraps an `Item`, and has access to all fields of that `Item` via `Deref` coercion.\n struct Validator<'a, 'tcx> {\n     ccx: &'a ConstCx<'a, 'tcx>,\n-    temps: &'a IndexVec<Local, TempState>,\n+    temps: &'a mut IndexVec<Local, TempState>,\n }\n \n impl<'a, 'tcx> std::ops::Deref for Validator<'a, 'tcx> {\n@@ -202,7 +202,7 @@ impl<'a, 'tcx> std::ops::Deref for Validator<'a, 'tcx> {\n struct Unpromotable;\n \n impl<'tcx> Validator<'_, 'tcx> {\n-    fn validate_candidate(&self, candidate: Candidate) -> Result<(), Unpromotable> {\n+    fn validate_candidate(&mut self, candidate: Candidate) -> Result<(), Unpromotable> {\n         let loc = candidate.location;\n         let statement = &self.body[loc.block].statements[loc.statement_index];\n         match &statement.kind {\n@@ -234,7 +234,7 @@ impl<'tcx> Validator<'_, 'tcx> {\n     }\n \n     // FIXME(eddyb) maybe cache this?\n-    fn qualif_local<Q: qualifs::Qualif>(&self, local: Local) -> bool {\n+    fn qualif_local<Q: qualifs::Qualif>(&mut self, local: Local) -> bool {\n         if let TempState::Defined { location: loc, .. } = self.temps[local] {\n             let num_stmts = self.body[loc.block].statements.len();\n \n@@ -272,40 +272,50 @@ impl<'tcx> Validator<'_, 'tcx> {\n         }\n     }\n \n-    // FIXME(eddyb) maybe cache this?\n-    fn validate_local(&self, local: Local) -> Result<(), Unpromotable> {\n-        if let TempState::Defined { location: loc, .. } = self.temps[local] {\n-            let block = &self.body[loc.block];\n-            let num_stmts = block.statements.len();\n-\n-            if loc.statement_index < num_stmts {\n-                let statement = &block.statements[loc.statement_index];\n-                match &statement.kind {\n-                    StatementKind::Assign(box (_, rhs)) => self.validate_rvalue(rhs),\n-                    _ => {\n-                        span_bug!(\n-                            statement.source_info.span,\n-                            \"{:?} is not an assignment\",\n-                            statement\n-                        );\n-                    }\n-                }\n-            } else {\n-                let terminator = block.terminator();\n-                match &terminator.kind {\n-                    TerminatorKind::Call { func, args, .. } => self.validate_call(func, args),\n-                    TerminatorKind::Yield { .. } => Err(Unpromotable),\n-                    kind => {\n-                        span_bug!(terminator.source_info.span, \"{:?} not promotable\", kind);\n+    fn validate_local(&mut self, local: Local) -> Result<(), Unpromotable> {\n+        if let TempState::Defined { location: loc, uses, valid } = self.temps[local] {\n+            valid.or_else(|_| {\n+                let ok = {\n+                    let block = &self.body[loc.block];\n+                    let num_stmts = block.statements.len();\n+\n+                    if loc.statement_index < num_stmts {\n+                        let statement = &block.statements[loc.statement_index];\n+                        match &statement.kind {\n+                            StatementKind::Assign(box (_, rhs)) => self.validate_rvalue(rhs),\n+                            _ => {\n+                                span_bug!(\n+                                    statement.source_info.span,\n+                                    \"{:?} is not an assignment\",\n+                                    statement\n+                                );\n+                            }\n+                        }\n+                    } else {\n+                        let terminator = block.terminator();\n+                        match &terminator.kind {\n+                            TerminatorKind::Call { func, args, .. } => {\n+                                self.validate_call(func, args)\n+                            }\n+                            TerminatorKind::Yield { .. } => Err(Unpromotable),\n+                            kind => {\n+                                span_bug!(terminator.source_info.span, \"{:?} not promotable\", kind);\n+                            }\n+                        }\n                     }\n-                }\n-            }\n+                };\n+                self.temps[local] = match ok {\n+                    Ok(()) => TempState::Defined { location: loc, uses, valid: Ok(()) },\n+                    Err(_) => TempState::Unpromotable,\n+                };\n+                ok\n+            })\n         } else {\n             Err(Unpromotable)\n         }\n     }\n \n-    fn validate_place(&self, place: PlaceRef<'tcx>) -> Result<(), Unpromotable> {\n+    fn validate_place(&mut self, place: PlaceRef<'tcx>) -> Result<(), Unpromotable> {\n         match place.last_projection() {\n             None => self.validate_local(place.local),\n             Some((place_base, elem)) => {\n@@ -417,7 +427,7 @@ impl<'tcx> Validator<'_, 'tcx> {\n         }\n     }\n \n-    fn validate_operand(&self, operand: &Operand<'tcx>) -> Result<(), Unpromotable> {\n+    fn validate_operand(&mut self, operand: &Operand<'tcx>) -> Result<(), Unpromotable> {\n         match operand {\n             Operand::Copy(place) | Operand::Move(place) => self.validate_place(place.as_ref()),\n \n@@ -447,7 +457,7 @@ impl<'tcx> Validator<'_, 'tcx> {\n         }\n     }\n \n-    fn validate_ref(&self, kind: BorrowKind, place: &Place<'tcx>) -> Result<(), Unpromotable> {\n+    fn validate_ref(&mut self, kind: BorrowKind, place: &Place<'tcx>) -> Result<(), Unpromotable> {\n         match kind {\n             // Reject these borrow types just to be safe.\n             // FIXME(RalfJung): could we allow them? Should we? No point in it until we have a usecase.\n@@ -480,7 +490,7 @@ impl<'tcx> Validator<'_, 'tcx> {\n         Ok(())\n     }\n \n-    fn validate_rvalue(&self, rvalue: &Rvalue<'tcx>) -> Result<(), Unpromotable> {\n+    fn validate_rvalue(&mut self, rvalue: &Rvalue<'tcx>) -> Result<(), Unpromotable> {\n         match rvalue {\n             Rvalue::Use(operand) | Rvalue::Repeat(operand, _) => {\n                 self.validate_operand(operand)?;\n@@ -623,7 +633,7 @@ impl<'tcx> Validator<'_, 'tcx> {\n     }\n \n     fn validate_call(\n-        &self,\n+        &mut self,\n         callee: &Operand<'tcx>,\n         args: &[Operand<'tcx>],\n     ) -> Result<(), Unpromotable> {\n@@ -665,10 +675,10 @@ impl<'tcx> Validator<'_, 'tcx> {\n // FIXME(eddyb) remove the differences for promotability in `static`, `const`, `const fn`.\n pub fn validate_candidates(\n     ccx: &ConstCx<'_, '_>,\n-    temps: &IndexVec<Local, TempState>,\n+    temps: &mut IndexVec<Local, TempState>,\n     candidates: &[Candidate],\n ) -> Vec<Candidate> {\n-    let validator = Validator { ccx, temps };\n+    let mut validator = Validator { ccx, temps };\n \n     candidates\n         .iter()\n@@ -720,7 +730,7 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n     fn promote_temp(&mut self, temp: Local) -> Local {\n         let old_keep_original = self.keep_original;\n         let loc = match self.temps[temp] {\n-            TempState::Defined { location, uses } if uses > 0 => {\n+            TempState::Defined { location, uses, .. } if uses > 0 => {\n                 if uses > 1 {\n                     self.keep_original = true;\n                 }"}]}