{"sha": "f93827f9e446e52619953c3ad2aa6604dfc9f986", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY5MzgyN2Y5ZTQ0NmU1MjYxOTk1M2MzYWQyYWE2NjA0ZGZjOWY5ODY=", "commit": {"author": {"name": "AnthonyMikh", "email": "anthony.mikh@yandex.ru", "date": "2019-09-25T21:31:16Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-09-25T21:31:16Z"}, "message": "Simplify `Emitter::fix_multispan_in_std_macros`\n\n1. Rewrite `if let` into `match` to return earl and avoid indenting giant block \r\n2. Assign `spans_updated` only once", "tree": {"sha": "c741f63e2f503aa4625231291818510ae793d4dd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c741f63e2f503aa4625231291818510ae793d4dd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f93827f9e446e52619953c3ad2aa6604dfc9f986", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdi9ykCRBK7hj4Ov3rIwAAdHIIAH2vNTF/x7aEXvUSC6cNqknl\nQsU9jWmceyvU9NCPVG1JfO75hQUpogwrR/DSDuMPcvBhkL4uOEuVLlWV1QkgayOC\ns2L223xIfrQllFontx2MHdrjIWVxGl+pBQordAQmuoNBFlgSUG3B7rQdydiyijd2\nejckRRpO0HRReT6sISKOCyCc3DaPO/JqnUP7n226MMa2CvKqMdTbXg9DAVdZyed+\n4g+Vx+lwpW3ctuNBz+aR0ibul77M0KNdkhCNXozOkYrWnjwGnEJDzwJa/EtshwuN\no1hYemROc3IRrU4CxE1vmMQ6WhIr6eGXdcUKcoBLFbW1o5kQAoOf++MlqXL7F0U=\n=zSpx\n-----END PGP SIGNATURE-----\n", "payload": "tree c741f63e2f503aa4625231291818510ae793d4dd\nparent 9b447e2f9fb9b0d3366de90b2de72541b195e99d\nauthor AnthonyMikh <anthony.mikh@yandex.ru> 1569447076 +0300\ncommitter GitHub <noreply@github.com> 1569447076 +0300\n\nSimplify `Emitter::fix_multispan_in_std_macros`\n\n1. Rewrite `if let` into `match` to return earl and avoid indenting giant block \r\n2. Assign `spans_updated` only once"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f93827f9e446e52619953c3ad2aa6604dfc9f986", "html_url": "https://github.com/rust-lang/rust/commit/f93827f9e446e52619953c3ad2aa6604dfc9f986", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f93827f9e446e52619953c3ad2aa6604dfc9f986/comments", "author": {"login": "AnthonyMikh", "id": 19252795, "node_id": "MDQ6VXNlcjE5MjUyNzk1", "avatar_url": "https://avatars.githubusercontent.com/u/19252795?v=4", "gravatar_id": "", "url": "https://api.github.com/users/AnthonyMikh", "html_url": "https://github.com/AnthonyMikh", "followers_url": "https://api.github.com/users/AnthonyMikh/followers", "following_url": "https://api.github.com/users/AnthonyMikh/following{/other_user}", "gists_url": "https://api.github.com/users/AnthonyMikh/gists{/gist_id}", "starred_url": "https://api.github.com/users/AnthonyMikh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/AnthonyMikh/subscriptions", "organizations_url": "https://api.github.com/users/AnthonyMikh/orgs", "repos_url": "https://api.github.com/users/AnthonyMikh/repos", "events_url": "https://api.github.com/users/AnthonyMikh/events{/privacy}", "received_events_url": "https://api.github.com/users/AnthonyMikh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9b447e2f9fb9b0d3366de90b2de72541b195e99d", "url": "https://api.github.com/repos/rust-lang/rust/commits/9b447e2f9fb9b0d3366de90b2de72541b195e99d", "html_url": "https://github.com/rust-lang/rust/commit/9b447e2f9fb9b0d3366de90b2de72541b195e99d"}], "stats": {"total": 129, "additions": 65, "deletions": 64}, "files": [{"sha": "efb5c63bd08475ec2f9830976955f4e86db2ba75", "filename": "src/librustc_errors/emitter.rs", "status": "modified", "additions": 65, "deletions": 64, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/f93827f9e446e52619953c3ad2aa6604dfc9f986/src%2Flibrustc_errors%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f93827f9e446e52619953c3ad2aa6604dfc9f986/src%2Flibrustc_errors%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Femitter.rs?ref=f93827f9e446e52619953c3ad2aa6604dfc9f986", "patch": "@@ -295,81 +295,82 @@ pub trait Emitter {\n                                    source_map: &Option<Lrc<SourceMapperDyn>>,\n                                    span: &mut MultiSpan,\n                                    always_backtrace: bool) -> bool {\n-        let mut spans_updated = false;\n+        let sm = match source_map {\n+            Some(ref sm) => sm,\n+            None => return false,\n+        };\n \n-        if let Some(ref sm) = source_map {\n-            let mut before_after: Vec<(Span, Span)> = vec![];\n-            let mut new_labels: Vec<(Span, String)> = vec![];\n+        let mut before_after: Vec<(Span, Span)> = vec![];\n+        let mut new_labels: Vec<(Span, String)> = vec![];\n \n-            // First, find all the spans in <*macros> and point instead at their use site\n-            for sp in span.primary_spans() {\n-                if sp.is_dummy() {\n+        // First, find all the spans in <*macros> and point instead at their use site\n+        for sp in span.primary_spans() {\n+            if sp.is_dummy() {\n+                continue;\n+            }\n+            let call_sp = sm.call_span_if_macro(*sp);\n+            if call_sp != *sp && !always_backtrace {\n+                before_after.push((*sp, call_sp));\n+            }\n+            let backtrace_len = sp.macro_backtrace().len();\n+            for (i, trace) in sp.macro_backtrace().iter().rev().enumerate() {\n+                // Only show macro locations that are local\n+                // and display them like a span_note\n+                if trace.def_site_span.is_dummy() {\n                     continue;\n                 }\n-                let call_sp = sm.call_span_if_macro(*sp);\n-                if call_sp != *sp && !always_backtrace {\n-                    before_after.push((*sp, call_sp));\n+                if always_backtrace {\n+                    new_labels.push((trace.def_site_span,\n+                                        format!(\"in this expansion of `{}`{}\",\n+                                                trace.macro_decl_name,\n+                                                if backtrace_len > 2 {\n+                                                    // if backtrace_len == 1 it'll be pointed\n+                                                    // at by \"in this macro invocation\"\n+                                                    format!(\" (#{})\", i + 1)\n+                                                } else {\n+                                                    String::new()\n+                                                })));\n                 }\n-                let backtrace_len = sp.macro_backtrace().len();\n-                for (i, trace) in sp.macro_backtrace().iter().rev().enumerate() {\n-                    // Only show macro locations that are local\n-                    // and display them like a span_note\n-                    if trace.def_site_span.is_dummy() {\n-                        continue;\n-                    }\n-                    if always_backtrace {\n-                        new_labels.push((trace.def_site_span,\n-                                            format!(\"in this expansion of `{}`{}\",\n-                                                    trace.macro_decl_name,\n-                                                    if backtrace_len > 2 {\n-                                                        // if backtrace_len == 1 it'll be pointed\n-                                                        // at by \"in this macro invocation\"\n-                                                        format!(\" (#{})\", i + 1)\n-                                                    } else {\n-                                                        String::new()\n-                                                    })));\n-                    }\n-                    // Check to make sure we're not in any <*macros>\n-                    if !sm.span_to_filename(trace.def_site_span).is_macros() &&\n-                        !trace.macro_decl_name.starts_with(\"desugaring of \") &&\n-                        !trace.macro_decl_name.starts_with(\"#[\") ||\n-                        always_backtrace {\n-                        new_labels.push((trace.call_site,\n-                                            format!(\"in this macro invocation{}\",\n-                                                    if backtrace_len > 2 && always_backtrace {\n-                                                        // only specify order when the macro\n-                                                        // backtrace is multiple levels deep\n-                                                        format!(\" (#{})\", i + 1)\n-                                                    } else {\n-                                                        String::new()\n-                                                    })));\n-                        if !always_backtrace {\n-                            break;\n-                        }\n+                // Check to make sure we're not in any <*macros>\n+                if !sm.span_to_filename(trace.def_site_span).is_macros() &&\n+                    !trace.macro_decl_name.starts_with(\"desugaring of \") &&\n+                    !trace.macro_decl_name.starts_with(\"#[\") ||\n+                    always_backtrace {\n+                    new_labels.push((trace.call_site,\n+                                        format!(\"in this macro invocation{}\",\n+                                                if backtrace_len > 2 && always_backtrace {\n+                                                    // only specify order when the macro\n+                                                    // backtrace is multiple levels deep\n+                                                    format!(\" (#{})\", i + 1)\n+                                                } else {\n+                                                    String::new()\n+                                                })));\n+                    if !always_backtrace {\n+                        break;\n                     }\n                 }\n             }\n-            for (label_span, label_text) in new_labels {\n-                span.push_span_label(label_span, label_text);\n+        }\n+        for (label_span, label_text) in new_labels {\n+            span.push_span_label(label_span, label_text);\n+        }\n+        for sp_label in span.span_labels() {\n+            if sp_label.span.is_dummy() {\n+                continue;\n             }\n-            for sp_label in span.span_labels() {\n-                if sp_label.span.is_dummy() {\n-                    continue;\n-                }\n-                if sm.span_to_filename(sp_label.span.clone()).is_macros() &&\n-                    !always_backtrace\n-                {\n-                    let v = sp_label.span.macro_backtrace();\n-                    if let Some(use_site) = v.last() {\n-                        before_after.push((sp_label.span.clone(), use_site.call_site.clone()));\n-                    }\n+            if sm.span_to_filename(sp_label.span.clone()).is_macros() &&\n+                !always_backtrace\n+            {\n+                let v = sp_label.span.macro_backtrace();\n+                if let Some(use_site) = v.last() {\n+                    before_after.push((sp_label.span.clone(), use_site.call_site.clone()));\n                 }\n             }\n-            // After we have them, make sure we replace these 'bad' def sites with their use sites\n-            for (before, after) in before_after {\n-                span.replace(before, after);\n-                spans_updated = true;\n-            }\n+        }\n+        // After we have them, make sure we replace these 'bad' def sites with their use sites\n+        let spans_updated = !before_after.is_empty();\n+        for (before, after) in before_after {\n+            span.replace(before, after);\n         }\n \n         spans_updated"}]}