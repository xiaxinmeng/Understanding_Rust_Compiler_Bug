{"sha": "e0876fdfc1976f74526c486deb77523edbc216aa", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUwODc2ZmRmYzE5NzZmNzQ1MjZjNDg2ZGViNzc1MjNlZGJjMjE2YWE=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-11-20T20:59:37Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-11-21T18:27:13Z"}, "message": "libsyntax: Implement `deriving` for enums with N-ary variants. r=brson", "tree": {"sha": "c31cf448b3c2bf8ee6408ae835272e4a8f366984", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c31cf448b3c2bf8ee6408ae835272e4a8f366984"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e0876fdfc1976f74526c486deb77523edbc216aa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e0876fdfc1976f74526c486deb77523edbc216aa", "html_url": "https://github.com/rust-lang/rust/commit/e0876fdfc1976f74526c486deb77523edbc216aa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e0876fdfc1976f74526c486deb77523edbc216aa/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "809bd3e5efa00a7a3f924bc3999568d67574e4e7", "url": "https://api.github.com/repos/rust-lang/rust/commits/809bd3e5efa00a7a3f924bc3999568d67574e4e7", "html_url": "https://github.com/rust-lang/rust/commit/809bd3e5efa00a7a3f924bc3999568d67574e4e7"}], "stats": {"total": 208, "additions": 168, "deletions": 40}, "files": [{"sha": "f08bc3cc7bdcd911ecc330b27173d4bbcc058d4c", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e0876fdfc1976f74526c486deb77523edbc216aa/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0876fdfc1976f74526c486deb77523edbc216aa/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=e0876fdfc1976f74526c486deb77523edbc216aa", "patch": "@@ -157,10 +157,21 @@ fn mk_copy(cx: ext_ctxt, sp: span, e: @ast::expr) -> @ast::expr {\n fn mk_managed(cx: ext_ctxt, sp: span, e: @ast::expr) -> @ast::expr {\n     mk_expr(cx, sp, ast::expr_unary(ast::box(ast::m_imm), e))\n }\n+fn mk_pat(cx: ext_ctxt, span: span, +pat: ast::pat_) -> @ast::pat {\n+    @{ id: cx.next_id(), node: move pat, span: span }\n+}\n fn mk_pat_ident(cx: ext_ctxt, span: span, ident: ast::ident) -> @ast::pat {\n-    let path = build::mk_raw_path(span, ~[ ident ]);\n+    let path = mk_raw_path(span, ~[ ident ]);\n     let pat = ast::pat_ident(ast::bind_by_value, path, None);\n-    @{ id: cx.next_id(), node: move pat, span: span }\n+    mk_pat(cx, span, move pat)\n+}\n+fn mk_pat_enum(cx: ext_ctxt,\n+               span: span,\n+               path: @ast::path,\n+               +subpats: ~[@ast::pat])\n+            -> @ast::pat {\n+    let pat = ast::pat_enum(path, Some(move subpats));\n+    mk_pat(cx, span, move pat)\n }\n fn mk_bool(cx: ext_ctxt, span: span, value: bool) -> @ast::expr {\n     let lit_expr = ast::expr_lit(@{ node: ast::lit_bool(value), span: span });"}, {"sha": "f3c2acff9326e20474f2194506fabc4b7cd40f48", "filename": "src/libsyntax/ext/deriving.rs", "status": "modified", "additions": 140, "deletions": 38, "changes": 178, "blob_url": "https://github.com/rust-lang/rust/blob/e0876fdfc1976f74526c486deb77523edbc216aa/src%2Flibsyntax%2Fext%2Fderiving.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0876fdfc1976f74526c486deb77523edbc216aa/src%2Flibsyntax%2Fext%2Fderiving.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving.rs?ref=e0876fdfc1976f74526c486deb77523edbc216aa", "patch": "@@ -1,13 +1,15 @@\n /// The compiler code necessary to implement the #[deriving_eq] and\n /// #[deriving_ord] extensions.\n \n-use ast::{and, bind_by_value, binop, blk, default_blk, deref, enum_def, expr};\n+use ast::{and, bind_by_ref, binop, blk, default_blk, deref, enum_def};\n+use ast::{enum_variant_kind, expr};\n use ast::{expr_, expr_addr_of, expr_binary, expr_call, expr_field, expr_lit};\n use ast::{expr_match, expr_path, expr_unary, ident, infer, item, item_};\n use ast::{item_class, item_enum, item_impl, lit_bool, m_imm, meta_item};\n use ast::{method, named_field, or, pat, pat_ident, pat_wild, path, public};\n-use ast::{pure_fn, re_anon, return_val, struct_def, sty_region, ty_path};\n-use ast::{ty_rptr, unnamed_field};\n+use ast::{pure_fn, re_anon, return_val, struct_def, struct_variant_kind};\n+use ast::{sty_region, tuple_variant_kind, ty_path};\n+use ast::{ty_rptr, unnamed_field, variant};\n use base::ext_ctxt;\n use codemap::span;\n use parse::token::special_idents::clownshoes_extensions;\n@@ -174,6 +176,99 @@ fn create_derived_impl(cx: ext_ctxt,\n     return create_impl_item(cx, span, move impl_item);\n }\n \n+fn create_enum_variant_pattern(cx: ext_ctxt,\n+                               span: span,\n+                               variant: &ast::variant,\n+                               prefix: ~str)\n+                            -> @ast::pat {\n+    let variant_ident = variant.node.name;\n+    match variant.node.kind {\n+        tuple_variant_kind(ref variant_args) => {\n+            if variant_args.len() == 0 {\n+                return build::mk_pat_ident(cx, span, variant_ident);\n+            }\n+\n+            let subpats = dvec::DVec();\n+            for variant_args.each |_variant_arg| {\n+                // Create the subidentifier.\n+                let index = subpats.len().to_str();\n+                let ident = cx.ident_of(prefix + index);\n+\n+                // Create the subpattern.\n+                let subpath = build::mk_raw_path(span, ~[ ident ]);\n+                let subpat = pat_ident(bind_by_ref(m_imm), subpath, None);\n+                let subpat = build::mk_pat(cx, span, move subpat);\n+                subpats.push(subpat);\n+            }\n+\n+            let matching_path = build::mk_raw_path(span, ~[ variant_ident ]);\n+            let subpats = dvec::unwrap(move subpats);\n+            return build::mk_pat_enum(cx, span, matching_path, move subpats);\n+        }\n+        struct_variant_kind(*) => {\n+            cx.span_unimpl(span, ~\"struct variants for `deriving`\");\n+        }\n+        enum_variant_kind(*) => {\n+            cx.span_unimpl(span, ~\"enum variants for `deriving`\");\n+        }\n+    }\n+}\n+\n+fn call_substructure_method(cx: ext_ctxt,\n+                            span: span,\n+                            self_field: @expr,\n+                            other_field_ref: @expr,\n+                            method_ident: ident,\n+                            junction: Junction,\n+                            chain_expr: &mut Option<@expr>) {\n+    // Call the substructure method.\n+    let self_method = build::mk_access_(cx, span, self_field, method_ident);\n+    let self_call = build::mk_call_(cx,\n+                                    span,\n+                                    self_method,\n+                                    ~[ other_field_ref ]);\n+\n+    // Connect to the outer expression if necessary.\n+    *chain_expr = match *chain_expr {\n+        None => Some(self_call),\n+        Some(copy old_outer_expr) => {\n+            let binop = junction.to_binop();\n+            let chain_expr = build::mk_binary(cx,\n+                                              span,\n+                                              binop,\n+                                              old_outer_expr,\n+                                              self_call);\n+            Some(chain_expr)\n+        }\n+    };\n+}\n+\n+fn finish_chain_expr(cx: ext_ctxt,\n+                     span: span,\n+                     chain_expr: Option<@expr>,\n+                     junction: Junction)\n+                  -> @expr {\n+    match chain_expr {\n+        None => {\n+            match junction {\n+                Conjunction => build::mk_bool(cx, span, true),\n+                Disjunction => build::mk_bool(cx, span, false),\n+            }\n+        }\n+        Some(ref outer_expr) => *outer_expr,\n+    }\n+}\n+\n+fn variant_arg_count(cx: ext_ctxt, span: span, variant: &variant) -> uint {\n+    match variant.node.kind {\n+        tuple_variant_kind(args) => args.len(),\n+        struct_variant_kind(struct_def) => struct_def.fields.len(),\n+        enum_variant_kind(*) => {\n+            cx.span_bug(span, ~\"variant_arg_count: enum variants deprecated\")\n+        }\n+    }\n+}\n+\n fn expand_deriving_struct_def(cx: ext_ctxt,\n                               span: span,\n                               struct_def: &struct_def,\n@@ -209,8 +304,6 @@ fn expand_deriving_struct_method(cx: ext_ctxt,\n     let self_ident = cx.ident_of(~\"self\");\n     let other_ident = cx.ident_of(~\"__other\");\n \n-    let binop = junction.to_binop();\n-\n     // Create the body of the method.\n     let mut outer_expr = None;\n     for struct_def.fields.each |struct_field| {\n@@ -232,27 +325,13 @@ fn expand_deriving_struct_method(cx: ext_ctxt,\n                                                   ident);\n \n                 // Call the substructure method.\n-                let self_method = build::mk_access_(cx,\n-                                                    span,\n-                                                    self_field,\n-                                                    method_ident);\n-                let self_call = build::mk_call_(cx,\n-                                                span,\n-                                                self_method,\n-                                                ~[ other_field_ref ]);\n-\n-                // Connect to the outer expression if necessary.\n-                outer_expr = match outer_expr {\n-                    None => Some(self_call),\n-                    Some(old_outer_expr) => {\n-                        let chain_expr = build::mk_binary(cx,\n-                                                          span,\n-                                                          binop,\n-                                                          old_outer_expr,\n-                                                          self_call);\n-                        Some(chain_expr)\n-                    }\n-                };\n+                call_substructure_method(cx,\n+                                         span,\n+                                         self_field,\n+                                         other_field_ref,\n+                                         method_ident,\n+                                         junction,\n+                                         &mut outer_expr);\n             }\n             unnamed_field => {\n                 cx.span_unimpl(span, ~\"unnamed fields with `deriving_eq`\");\n@@ -261,12 +340,7 @@ fn expand_deriving_struct_method(cx: ext_ctxt,\n     }\n \n     // Create the method itself.\n-    let body;\n-    match outer_expr {\n-        None => cx.span_unimpl(span, ~\"empty structs with `deriving_eq`\"),\n-        Some(outer_expr) => body = outer_expr,\n-    }\n-\n+    let body = finish_chain_expr(cx, span, outer_expr, junction);\n     return create_method(cx, span, method_ident, type_ident, body);\n }\n \n@@ -305,8 +379,6 @@ fn expand_deriving_enum_method(cx: ext_ctxt,\n     let self_ident = cx.ident_of(~\"self\");\n     let other_ident = cx.ident_of(~\"__other\");\n \n-    let _binop = junction.to_binop();\n-\n     let is_eq;\n     match junction {\n         Conjunction => is_eq = true,\n@@ -317,13 +389,40 @@ fn expand_deriving_enum_method(cx: ext_ctxt,\n     let self_arms = dvec::DVec();\n     for enum_definition.variants.each |self_variant| {\n         let other_arms = dvec::DVec();\n-        let self_variant_ident = self_variant.node.name;\n \n         // Create the matching pattern.\n-        let matching_pat = build::mk_pat_ident(cx, span, self_variant_ident);\n+        let matching_pat = create_enum_variant_pattern(cx,\n+                                                       span,\n+                                                       self_variant,\n+                                                       ~\"__other\");\n \n         // Create the matching pattern body.\n-        let matching_body_expr = build::mk_bool(cx, span, is_eq);\n+        let mut matching_body_expr = None;\n+        for uint::range(0, variant_arg_count(cx, span, self_variant)) |i| {\n+            // Create the expression for the other field.\n+            let other_field_ident = cx.ident_of(~\"__other\" + i.to_str());\n+            let other_field = build::mk_path(cx,\n+                                             span,\n+                                             ~[ other_field_ident ]);\n+\n+            // Create the expression for this field.\n+            let self_field_ident = cx.ident_of(~\"__self\" + i.to_str());\n+            let self_field = build::mk_path(cx, span, ~[ self_field_ident ]);\n+\n+            // Call the substructure method.\n+            call_substructure_method(cx,\n+                                     span,\n+                                     self_field,\n+                                     other_field,\n+                                     method_ident,\n+                                     junction,\n+                                     &mut matching_body_expr);\n+        }\n+\n+        let matching_body_expr = finish_chain_expr(cx,\n+                                                   span,\n+                                                   matching_body_expr,\n+                                                   junction);\n         let matching_body_block = build::mk_simple_block(cx,\n                                                          span,\n                                                          matching_body_expr);\n@@ -358,7 +457,10 @@ fn expand_deriving_enum_method(cx: ext_ctxt,\n         other_arms.push(move nonmatching_arm);\n \n         // Create the self pattern.\n-        let self_pat = build::mk_pat_ident(cx, span, self_variant_ident);\n+        let self_pat = create_enum_variant_pattern(cx,\n+                                                   span,\n+                                                   self_variant,\n+                                                   ~\"__self\");\n \n         // Create the self pattern body.\n         let other_expr = build::mk_path(cx, span, ~[ other_ident ]);"}, {"sha": "ed231d427fb477e593b6b1e8308099896d940e5a", "filename": "src/test/run-pass/deriving-via-extension-enum.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e0876fdfc1976f74526c486deb77523edbc216aa/src%2Ftest%2Frun-pass%2Fderiving-via-extension-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0876fdfc1976f74526c486deb77523edbc216aa/src%2Ftest%2Frun-pass%2Fderiving-via-extension-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-via-extension-enum.rs?ref=e0876fdfc1976f74526c486deb77523edbc216aa", "patch": "@@ -0,0 +1,15 @@\n+#[deriving_eq]\n+enum Foo {\n+    Bar(int, int),\n+    Baz(float, float)\n+}\n+\n+fn main() {\n+    let a = Bar(1, 2);\n+    let b = Bar(1, 2);\n+    assert a == b;\n+    assert !(a != b);\n+    assert a.eq(&b);\n+    assert !a.ne(&b);\n+}\n+"}]}