{"sha": "aa0b350c9798ca1ca1b0b82aec66f7ee2bac76ff", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFhMGIzNTBjOTc5OGNhMWNhMWIwYjgyYWVjNjZmN2VlMmJhYzc2ZmY=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2014-09-30T22:45:17Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2014-10-02T13:59:31Z"}, "message": "docs: remove mentions of Gc.", "tree": {"sha": "1197d597ba3ecd0f4d9654f7a3c7fbc4d4f8bd15", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1197d597ba3ecd0f4d9654f7a3c7fbc4d4f8bd15"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/aa0b350c9798ca1ca1b0b82aec66f7ee2bac76ff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/aa0b350c9798ca1ca1b0b82aec66f7ee2bac76ff", "html_url": "https://github.com/rust-lang/rust/commit/aa0b350c9798ca1ca1b0b82aec66f7ee2bac76ff", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/aa0b350c9798ca1ca1b0b82aec66f7ee2bac76ff/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "39de8464ed16e00c716faff2782fef6babbb090b", "url": "https://api.github.com/repos/rust-lang/rust/commits/39de8464ed16e00c716faff2782fef6babbb090b", "html_url": "https://github.com/rust-lang/rust/commit/39de8464ed16e00c716faff2782fef6babbb090b"}], "stats": {"total": 130, "additions": 20, "deletions": 110}, "files": [{"sha": "dd9c687172247425a74dc68e6811d6c3764348b4", "filename": "src/doc/guide-pointers.md", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/aa0b350c9798ca1ca1b0b82aec66f7ee2bac76ff/src%2Fdoc%2Fguide-pointers.md", "raw_url": "https://github.com/rust-lang/rust/raw/aa0b350c9798ca1ca1b0b82aec66f7ee2bac76ff/src%2Fdoc%2Fguide-pointers.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-pointers.md?ref=aa0b350c9798ca1ca1b0b82aec66f7ee2bac76ff", "patch": "@@ -632,19 +632,6 @@ This part is coming soon.\n \n This part is coming soon.\n \n-# Gc\n-\n-The `Gc<T>` type exists for historical reasons, and is [still used\n-internally](https://github.com/rust-lang/rust/issues/7929) by the compiler.\n-It is not even a 'real' garbage collected type at the moment.\n-\n-In the future, Rust may have a real garbage collected type, and so it\n-has not yet been removed for that reason.\n-\n-## Best practices\n-\n-There is currently no legitimate use case for the `Gc<T>` type.\n-\n # Raw Pointers\n \n This part is coming soon."}, {"sha": "578ff0edf144bef03fab520475352de5ac0c2862", "filename": "src/doc/guide-runtime.md", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/aa0b350c9798ca1ca1b0b82aec66f7ee2bac76ff/src%2Fdoc%2Fguide-runtime.md", "raw_url": "https://github.com/rust-lang/rust/raw/aa0b350c9798ca1ca1b0b82aec66f7ee2bac76ff/src%2Fdoc%2Fguide-runtime.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-runtime.md?ref=aa0b350c9798ca1ca1b0b82aec66f7ee2bac76ff", "patch": "@@ -31,7 +31,6 @@ list):\n * Task synchronization\n * Task-local storage\n * Logging\n-* Local heaps (GC heaps)\n * Task unwinding\n \n ## What is the runtime accomplishing?"}, {"sha": "fe6664bd8480a68a93b8b44eac241cba65a0b106", "filename": "src/doc/guide-unsafe.md", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aa0b350c9798ca1ca1b0b82aec66f7ee2bac76ff/src%2Fdoc%2Fguide-unsafe.md", "raw_url": "https://github.com/rust-lang/rust/raw/aa0b350c9798ca1ca1b0b82aec66f7ee2bac76ff/src%2Fdoc%2Fguide-unsafe.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-unsafe.md?ref=aa0b350c9798ca1ca1b0b82aec66f7ee2bac76ff", "patch": "@@ -208,9 +208,7 @@ pub struct Unique<T> {\n // Implement methods for creating and using the values in the box.\n \n // NB: For simplicity and correctness, we require that T has kind Send\n-// (owned boxes relax this restriction, and can contain managed (GC) boxes).\n-// This is because, as implemented, the garbage collector would not know\n-// about any shared boxes stored in the malloc'd region of memory.\n+// (owned boxes relax this restriction).\n impl<T: Send> Unique<T> {\n     pub fn new(value: T) -> Unique<T> {\n         unsafe {"}, {"sha": "ecd583937f4aa44ff011e36b83910ea7f9d683dc", "filename": "src/doc/reference.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa0b350c9798ca1ca1b0b82aec66f7ee2bac76ff/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/aa0b350c9798ca1ca1b0b82aec66f7ee2bac76ff/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=aa0b350c9798ca1ca1b0b82aec66f7ee2bac76ff", "patch": "@@ -3381,7 +3381,7 @@ fn main() {\n \n ```\n \n-Patterns can also dereference pointers by using the `&`, `box` or `@` symbols,\n+Patterns can also dereference pointers by using the `&`, `box` symbols,\n as appropriate. For example, these two matches on `x: &int` are equivalent:\n \n ```"}, {"sha": "882b6bc842644d760c168a0ac8b6216c3ccf4d1b", "filename": "src/librustc/middle/borrowck/doc.rs", "status": "modified", "additions": 18, "deletions": 92, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/aa0b350c9798ca1ca1b0b82aec66f7ee2bac76ff/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa0b350c9798ca1ca1b0b82aec66f7ee2bac76ff/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fdoc.rs?ref=aa0b350c9798ca1ca1b0b82aec66f7ee2bac76ff", "patch": "@@ -74,7 +74,7 @@ to an `LV` of `(*a).f`.\n Here is the formal grammar for the types we'll consider:\n \n ```text\n-TY = () | S<'LT...> | Box<TY> | & 'LT MQ TY | @ MQ TY\n+TY = () | S<'LT...> | Box<TY> | & 'LT MQ TY\n MQ = mut | imm | const\n ```\n \n@@ -263,9 +263,7 @@ compatible with the aliasability of `LV`. The goal is to prevent\n `&mut` borrows of aliasability data.\n \n 3. `LIFETIME(LV, LT, MQ)`: The lifetime of the borrow does not exceed\n-the lifetime of the value being borrowed. This pass is also\n-responsible for inserting root annotations to keep managed values\n-alive.\n+the lifetime of the value being borrowed.\n \n 4. `RESTRICTIONS(LV, LT, ACTIONS) = RS`: This pass checks and computes the\n restrictions to maintain memory safety. These are the restrictions\n@@ -316,17 +314,13 @@ MUTABILITY(*LV, MQ)                 // M-Deref-Unique\n \n ### Checking mutability of immutable pointer types\n \n-Immutable pointer types like `&T` and `@T` can only\n+Immutable pointer types like `&T` can only\n be borrowed if MQ is immutable or const:\n \n ```text\n MUTABILITY(*LV, MQ)                // M-Deref-Borrowed-Imm\n   TYPE(LV) = &Ty\n   MQ == imm | const\n-\n-MUTABILITY(*LV, MQ)                // M-Deref-Managed-Imm\n-  TYPE(LV) = @Ty\n-  MQ == imm | const\n ```\n \n ### Checking mutability of mutable pointer types\n@@ -390,11 +384,10 @@ ALIASABLE(*LV, MQ)                 // M-Deref-Borrowed-Mut\n ## Checking lifetime\n \n These rules aim to ensure that no data is borrowed for a scope that exceeds\n-its lifetime. In addition, these rules manage the rooting of `@` values.\n-These two computations wind up being intimately related. Formally, we define\n-a predicate `LIFETIME(LV, LT, MQ)`, which states that \"the lvalue `LV` can be\n-safely borrowed for the lifetime `LT` with mutability `MQ`\". The Rust\n-code corresponding to this predicate is the module\n+its lifetime. These two computations wind up being intimately related.\n+Formally, we define a predicate `LIFETIME(LV, LT, MQ)`, which states that\n+\"the lvalue `LV` can be safely borrowed for the lifetime `LT` with mutability\n+`MQ`\". The Rust code corresponding to this predicate is the module\n `middle::borrowck::gather_loans::lifetime`.\n \n ### The Scope function\n@@ -423,14 +416,6 @@ the pointer itself `LV` goes out of scope:\n   SCOPE(*LV) = SCOPE(LV) if LV has type Box<T>\n ```\n \n-The scope of a managed referent is also the scope of the pointer.  This\n-is a conservative approximation, since there may be other aliases for\n-that same managed box that would cause it to live longer:\n-\n-```text\n-  SCOPE(*LV) = SCOPE(LV) if LV has type @T\n-```\n-\n The scope of a borrowed referent is the scope associated with the\n pointer.  This is a conservative approximation, since the data that\n the pointer points at may actually live longer:\n@@ -477,59 +462,6 @@ LIFETIME(*LV, LT, MQ)               // L-Deref-Borrowed\n   LT <= LT'\n ```\n \n-### Checking lifetime for derefs of managed, immutable pointers\n-\n-Managed pointers are valid so long as the data within them is\n-*rooted*. There are two ways that this can be achieved. The first is\n-when the user guarantees such a root will exist. For this to be true,\n-three conditions must be met:\n-\n-```text\n-LIFETIME(*LV, LT, MQ)               // L-Deref-Managed-Imm-User-Root\n-  TYPE(LV) = @Ty\n-  LT <= SCOPE(LV)                   // (1)\n-  LV is immutable                   // (2)\n-  LV is not moved or not movable    // (3)\n-```\n-\n-Condition (1) guarantees that the managed box will be rooted for at\n-least the lifetime `LT` of the borrow, presuming that no mutation or\n-moves occur. Conditions (2) and (3) then serve to guarantee that the\n-value is not mutated or moved. Note that lvalues are either\n-(ultimately) owned by a local variable, in which case we can check\n-whether that local variable is ever moved in its scope, or they are\n-owned by the referent of an (immutable, due to condition 2) managed or\n-references, in which case moves are not permitted because the\n-location is aliasable.\n-\n-If the conditions of `L-Deref-Managed-Imm-User-Root` are not met, then\n-there is a second alternative. The compiler can attempt to root the\n-managed pointer itself. This permits great flexibility, because the\n-location `LV` where the managed pointer is found does not matter, but\n-there are some limitations. The lifetime of the borrow can only extend\n-to the innermost enclosing loop or function body. This guarantees that\n-the compiler never requires an unbounded amount of stack space to\n-perform the rooting; if this condition were violated, the compiler\n-might have to accumulate a list of rooted objects, for example if the\n-borrow occurred inside the body of a loop but the scope of the borrow\n-extended outside the loop. More formally, the requirement is that\n-there is no path starting from the borrow that leads back to the\n-borrow without crossing the exit from the scope `LT`.\n-\n-The rule for compiler rooting is as follows:\n-\n-```text\n-LIFETIME(*LV, LT, MQ)               // L-Deref-Managed-Imm-Compiler-Root\n-  TYPE(LV) = @Ty\n-  LT <= innermost enclosing loop/func\n-  ROOT LV at *LV for LT\n-```\n-\n-Here I have written `ROOT LV at *LV FOR LT` to indicate that the code\n-makes a note in a side-table that the box `LV` must be rooted into the\n-stack when `*LV` is evaluated, and that this root can be released when\n-the scope `LT` exits.\n-\n ## Computing the restrictions\n \n The final rules govern the computation of *restrictions*, meaning that\n@@ -599,22 +531,18 @@ RESTRICTIONS(*LV, LT, ACTIONS) = RS, (*LV, ACTIONS)    // R-Deref-Send-Pointer\n   RESTRICTIONS(LV, LT, ACTIONS|MUTATE|CLAIM) = RS\n ```\n \n-### Restrictions for loans of immutable managed/borrowed referents\n+### Restrictions for loans of immutable borrowed referents\n \n-Immutable managed/borrowed referents are freely aliasable, meaning that\n+Immutable borrowed referents are freely aliasable, meaning that\n the compiler does not prevent you from copying the pointer.  This\n implies that issuing restrictions is useless. We might prevent the\n user from acting on `*LV` itself, but there could be another path\n `*LV1` that refers to the exact same memory, and we would not be\n-restricting that path. Therefore, the rule for `&Ty` and `@Ty`\n-pointers always returns an empty set of restrictions, and it only\n-permits restricting `MUTATE` and `CLAIM` actions:\n+restricting that path. Therefore, the rule for `&Ty` pointers\n+always returns an empty set of restrictions, and it only permits\n+restricting `MUTATE` and `CLAIM` actions:\n \n ```text\n-RESTRICTIONS(*LV, LT, ACTIONS) = []                    // R-Deref-Imm-Managed\n-  TYPE(LV) = @Ty\n-  ACTIONS subset of [MUTATE, CLAIM]\n-\n RESTRICTIONS(*LV, LT, ACTIONS) = []                    // R-Deref-Imm-Borrowed\n   TYPE(LV) = &LT' Ty\n   LT <= LT'                                            // (1)\n@@ -623,8 +551,8 @@ RESTRICTIONS(*LV, LT, ACTIONS) = []                    // R-Deref-Imm-Borrowed\n \n The reason that we can restrict `MUTATE` and `CLAIM` actions even\n without a restrictions list is that it is never legal to mutate nor to\n-borrow mutably the contents of a `&Ty` or `@Ty` pointer. In other\n-words, those restrictions are already inherent in the type.\n+borrow mutably the contents of a `&Ty` pointer. In other words,\n+those restrictions are already inherent in the type.\n \n Clause (1) in the rule for `&Ty` deserves mention. Here I\n specify that the lifetime of the loan must be less than the lifetime\n@@ -729,13 +657,12 @@ are affine.)\n Freeze pointers are read-only. There may be `&mut` or `&` aliases, and\n we can not prevent *anything* but moves in that case. So the\n `RESTRICTIONS` function is only defined if `ACTIONS` is the empty set.\n-Because moves from a `&const` or `@const` lvalue are never legal, it\n-is not necessary to add any restrictions at all to the final\n-result.\n+Because moves from a `&const` lvalue are never legal, it is not\n+necessary to add any restrictions at all to the final result.\n \n ```text\n     RESTRICTIONS(*LV, LT, []) = []                         // R-Deref-Freeze-Borrowed\n-      TYPE(LV) = &const Ty or @const Ty\n+      TYPE(LV) = &const Ty\n ```\n \n ### Restrictions for loans of mutable borrowed referents\n@@ -957,8 +884,7 @@ moves and the declaration of uninitialized variables. For each of\n these points, we create a bit in the dataflow set. Assignments to a\n variable `x` or path `a.b.c` kill the move/uninitialization bits for\n those paths and any subpaths (e.g., `x`, `x.y`, `a.b.c`, `*a.b.c`).\n-The bits are also killed when the root variables (`x`, `a`) go out of\n-scope. Bits are unioned when two control-flow paths join. Thus, the\n+Bits are unioned when two control-flow paths join. Thus, the\n presence of a bit indicates that the move may have occurred without an\n intervening assignment to the same memory. At each use of a variable,\n we examine the bits in scope, and check that none of them are"}]}