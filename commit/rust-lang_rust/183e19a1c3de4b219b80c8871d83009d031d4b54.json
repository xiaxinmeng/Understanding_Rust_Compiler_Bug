{"sha": "183e19a1c3de4b219b80c8871d83009d031d4b54", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE4M2UxOWExYzNkZTRiMjE5YjgwYzg4NzFkODMwMDlkMDMxZDRiNTQ=", "commit": {"author": {"name": "Maxwell Anderson", "email": "maxwell.brayden.anderson@gmail.com", "date": "2018-10-27T18:50:12Z"}, "committer": {"name": "Maxwell Anderson", "email": "maxwell.brayden.anderson@gmail.com", "date": "2018-10-27T18:50:12Z"}, "message": "Merge remote-tracking branch 'upstream/master'", "tree": {"sha": "a051ea493e41520daeb21d69cb3f782765b1b183", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a051ea493e41520daeb21d69cb3f782765b1b183"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/183e19a1c3de4b219b80c8871d83009d031d4b54", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/183e19a1c3de4b219b80c8871d83009d031d4b54", "html_url": "https://github.com/rust-lang/rust/commit/183e19a1c3de4b219b80c8871d83009d031d4b54", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/183e19a1c3de4b219b80c8871d83009d031d4b54/comments", "author": {"login": "Zaechus", "id": 19353212, "node_id": "MDQ6VXNlcjE5MzUzMjEy", "avatar_url": "https://avatars.githubusercontent.com/u/19353212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zaechus", "html_url": "https://github.com/Zaechus", "followers_url": "https://api.github.com/users/Zaechus/followers", "following_url": "https://api.github.com/users/Zaechus/following{/other_user}", "gists_url": "https://api.github.com/users/Zaechus/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zaechus/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zaechus/subscriptions", "organizations_url": "https://api.github.com/users/Zaechus/orgs", "repos_url": "https://api.github.com/users/Zaechus/repos", "events_url": "https://api.github.com/users/Zaechus/events{/privacy}", "received_events_url": "https://api.github.com/users/Zaechus/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Zaechus", "id": 19353212, "node_id": "MDQ6VXNlcjE5MzUzMjEy", "avatar_url": "https://avatars.githubusercontent.com/u/19353212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zaechus", "html_url": "https://github.com/Zaechus", "followers_url": "https://api.github.com/users/Zaechus/followers", "following_url": "https://api.github.com/users/Zaechus/following{/other_user}", "gists_url": "https://api.github.com/users/Zaechus/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zaechus/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zaechus/subscriptions", "organizations_url": "https://api.github.com/users/Zaechus/orgs", "repos_url": "https://api.github.com/users/Zaechus/repos", "events_url": "https://api.github.com/users/Zaechus/events{/privacy}", "received_events_url": "https://api.github.com/users/Zaechus/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b1abc81a60e05bb2cf46850b977b7fa4ba34a6de", "url": "https://api.github.com/repos/rust-lang/rust/commits/b1abc81a60e05bb2cf46850b977b7fa4ba34a6de", "html_url": "https://github.com/rust-lang/rust/commit/b1abc81a60e05bb2cf46850b977b7fa4ba34a6de"}, {"sha": "457e7f12e9fc028eae182f23b279194e5344b676", "url": "https://api.github.com/repos/rust-lang/rust/commits/457e7f12e9fc028eae182f23b279194e5344b676", "html_url": "https://github.com/rust-lang/rust/commit/457e7f12e9fc028eae182f23b279194e5344b676"}], "stats": {"total": 1377, "additions": 1285, "deletions": 92}, "files": [{"sha": "09972a12f8d3ab9a11ca1dd8be40e80df331ee92", "filename": ".travis.yml", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/183e19a1c3de4b219b80c8871d83009d031d4b54/.travis.yml", "raw_url": "https://github.com/rust-lang/rust/raw/183e19a1c3de4b219b80c8871d83009d031d4b54/.travis.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.travis.yml?ref=183e19a1c3de4b219b80c8871d83009d031d4b54", "patch": "@@ -9,6 +9,13 @@ os:\n \n sudo: false\n \n+branches:\n+  # Don't build these branches\n+  except:\n+    # Used by bors\n+    - trying.tmp\n+    - staging.tmp\n+\n env:\n  global:\n    - RUST_BACKTRACE=1\n@@ -56,7 +63,8 @@ matrix:\n     - env: INTEGRATION=chronotope/chrono\n     - env: INTEGRATION=serde-rs/serde\n     - env: INTEGRATION=Geal/nom\n-    - env: INTEGRATION=hyperium/hyper\n+# uncomment once https://github.com/rust-lang/rust/issues/55376 is fixed\n+#    - env: INTEGRATION=hyperium/hyper\n   allow_failures:\n   - os: windows\n     env: BASE_TEST=true"}, {"sha": "5d9d470925fdb56f5c0eca84ec4d49a319d10f08", "filename": "CHANGELOG.md", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/183e19a1c3de4b219b80c8871d83009d031d4b54/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/183e19a1c3de4b219b80c8871d83009d031d4b54/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=183e19a1c3de4b219b80c8871d83009d031d4b54", "patch": "@@ -744,6 +744,7 @@ All notable changes to this project will be documented in this file.\n [`match_same_arms`]: https://rust-lang-nursery.github.io/rust-clippy/master/index.html#match_same_arms\n [`match_wild_err_arm`]: https://rust-lang-nursery.github.io/rust-clippy/master/index.html#match_wild_err_arm\n [`maybe_infinite_iter`]: https://rust-lang-nursery.github.io/rust-clippy/master/index.html#maybe_infinite_iter\n+[`mem_discriminant_non_enum`]: https://rust-lang-nursery.github.io/rust-clippy/master/index.html#mem_discriminant_non_enum\n [`mem_forget`]: https://rust-lang-nursery.github.io/rust-clippy/master/index.html#mem_forget\n [`mem_replace_option_with_none`]: https://rust-lang-nursery.github.io/rust-clippy/master/index.html#mem_replace_option_with_none\n [`min_max`]: https://rust-lang-nursery.github.io/rust-clippy/master/index.html#min_max\n@@ -812,6 +813,7 @@ All notable changes to this project will be documented in this file.\n [`range_plus_one`]: https://rust-lang-nursery.github.io/rust-clippy/master/index.html#range_plus_one\n [`range_step_by_zero`]: https://rust-lang-nursery.github.io/rust-clippy/master/index.html#range_step_by_zero\n [`range_zip_with_len`]: https://rust-lang-nursery.github.io/rust-clippy/master/index.html#range_zip_with_len\n+[`redundant_clone`]: https://rust-lang-nursery.github.io/rust-clippy/master/index.html#redundant_clone\n [`redundant_closure`]: https://rust-lang-nursery.github.io/rust-clippy/master/index.html#redundant_closure\n [`redundant_closure_call`]: https://rust-lang-nursery.github.io/rust-clippy/master/index.html#redundant_closure_call\n [`redundant_field_names`]: https://rust-lang-nursery.github.io/rust-clippy/master/index.html#redundant_field_names\n@@ -893,6 +895,7 @@ All notable changes to this project will be documented in this file.\n [`while_immutable_condition`]: https://rust-lang-nursery.github.io/rust-clippy/master/index.html#while_immutable_condition\n [`while_let_loop`]: https://rust-lang-nursery.github.io/rust-clippy/master/index.html#while_let_loop\n [`while_let_on_iterator`]: https://rust-lang-nursery.github.io/rust-clippy/master/index.html#while_let_on_iterator\n+[`wildcard_dependencies`]: https://rust-lang-nursery.github.io/rust-clippy/master/index.html#wildcard_dependencies\n [`write_literal`]: https://rust-lang-nursery.github.io/rust-clippy/master/index.html#write_literal\n [`write_with_newline`]: https://rust-lang-nursery.github.io/rust-clippy/master/index.html#write_with_newline\n [`writeln_empty_string`]: https://rust-lang-nursery.github.io/rust-clippy/master/index.html#writeln_empty_string"}, {"sha": "b4091cdab6c61a846032ce221cb70e49d0c7afa7", "filename": "README.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/183e19a1c3de4b219b80c8871d83009d031d4b54/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/183e19a1c3de4b219b80c8871d83009d031d4b54/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=183e19a1c3de4b219b80c8871d83009d031d4b54", "patch": "@@ -9,7 +9,7 @@ We are currently in the process of discussing Clippy 1.0 via the RFC process in\n \n A collection of lints to catch common mistakes and improve your [Rust](https://github.com/rust-lang/rust) code.\n \n-[There are 280 lints included in this crate!](https://rust-lang-nursery.github.io/rust-clippy/master/index.html)\n+[There are 283 lints included in this crate!](https://rust-lang-nursery.github.io/rust-clippy/master/index.html)\n \n We have a bunch of lint categories to allow you to choose how much Clippy is supposed to ~~annoy~~ help you:\n "}, {"sha": "fb0b326c713b0c1c14d2c791b256dca8f27249a9", "filename": "appveyor.yml", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/183e19a1c3de4b219b80c8871d83009d031d4b54/appveyor.yml", "raw_url": "https://github.com/rust-lang/rust/raw/183e19a1c3de4b219b80c8871d83009d031d4b54/appveyor.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/appveyor.yml?ref=183e19a1c3de4b219b80c8871d83009d031d4b54", "patch": "@@ -7,6 +7,13 @@ environment:\n         #- TARGET: x86_64-pc-windows-gnu\n         - TARGET: x86_64-pc-windows-msvc\n \n+branches:\n+    # Don't build these branches\n+    except:\n+        # Used by bors\n+        - trying.tmp\n+        - staging.tmp\n+\n install:\n     - curl -sSf -o rustup-init.exe https://win.rustup.rs/\n     - rustup-init.exe -y --default-host %TARGET% --default-toolchain nightly"}, {"sha": "4e6e85f45fe607f5e5910370a8c8e4a526ba02ce", "filename": "bors.toml", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/183e19a1c3de4b219b80c8871d83009d031d4b54/bors.toml", "raw_url": "https://github.com/rust-lang/rust/raw/183e19a1c3de4b219b80c8871d83009d031d4b54/bors.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/bors.toml?ref=183e19a1c3de4b219b80c8871d83009d031d4b54", "patch": "@@ -0,0 +1,4 @@\n+status = [\n+  \"continuous-integration/travis-ci/push\",\n+  \"continuous-integration/appveyor/branch\"\n+]"}, {"sha": "a481d46cce072c5ec0bfc4e60ca6aefaa1ed4367", "filename": "clippy_lints/src/arithmetic.rs", "status": "modified", "additions": 47, "deletions": 8, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/183e19a1c3de4b219b80c8871d83009d031d4b54/clippy_lints%2Fsrc%2Farithmetic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/183e19a1c3de4b219b80c8871d83009d031d4b54/clippy_lints%2Fsrc%2Farithmetic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Farithmetic.rs?ref=183e19a1c3de4b219b80c8871d83009d031d4b54", "patch": "@@ -51,7 +51,9 @@ declare_clippy_lint! {\n \n #[derive(Copy, Clone, Default)]\n pub struct Arithmetic {\n-    span: Option<Span>,\n+    expr_span: Option<Span>,\n+    /// This field is used to check whether expressions are constants, such as in enum discriminants and consts\n+    const_span: Option<Span>,\n }\n \n impl LintPass for Arithmetic {\n@@ -62,9 +64,15 @@ impl LintPass for Arithmetic {\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Arithmetic {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr) {\n-        if self.span.is_some() {\n+        if self.expr_span.is_some() {\n             return;\n         }\n+\n+        if let Some(span) = self.const_span {\n+            if span.contains(expr.span) {\n+                return;\n+            }\n+        }\n         match expr.node {\n             hir::ExprKind::Binary(ref op, ref l, ref r) => {\n                 match op.node {\n@@ -86,29 +94,60 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Arithmetic {\n                 let (l_ty, r_ty) = (cx.tables.expr_ty(l), cx.tables.expr_ty(r));\n                 if l_ty.is_integral() && r_ty.is_integral() {\n                     span_lint(cx, INTEGER_ARITHMETIC, expr.span, \"integer arithmetic detected\");\n-                    self.span = Some(expr.span);\n+                    self.expr_span = Some(expr.span);\n                 } else if l_ty.is_floating_point() && r_ty.is_floating_point() {\n                     span_lint(cx, FLOAT_ARITHMETIC, expr.span, \"floating-point arithmetic detected\");\n-                    self.span = Some(expr.span);\n+                    self.expr_span = Some(expr.span);\n                 }\n             },\n             hir::ExprKind::Unary(hir::UnOp::UnNeg, ref arg) => {\n                 let ty = cx.tables.expr_ty(arg);\n                 if ty.is_integral() {\n                     span_lint(cx, INTEGER_ARITHMETIC, expr.span, \"integer arithmetic detected\");\n-                    self.span = Some(expr.span);\n+                    self.expr_span = Some(expr.span);\n                 } else if ty.is_floating_point() {\n                     span_lint(cx, FLOAT_ARITHMETIC, expr.span, \"floating-point arithmetic detected\");\n-                    self.span = Some(expr.span);\n+                    self.expr_span = Some(expr.span);\n                 }\n             },\n             _ => (),\n         }\n     }\n \n     fn check_expr_post(&mut self, _: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr) {\n-        if Some(expr.span) == self.span {\n-            self.span = None;\n+        if Some(expr.span) == self.expr_span {\n+            self.expr_span = None;\n+        }\n+    }\n+\n+    fn check_body(&mut self, cx: &LateContext<'_, '_>, body: &hir::Body) {\n+        let body_owner = cx.tcx.hir.body_owner(body.id());\n+\n+        match cx.tcx.hir.body_owner_kind(body_owner) {\n+            hir::BodyOwnerKind::Static(_)\n+            | hir::BodyOwnerKind::Const => {\n+                let body_span = cx.tcx.hir.span(body_owner);\n+\n+                if let Some(span) = self.const_span {\n+                    if span.contains(body_span) {\n+                        return;\n+                    }\n+                }\n+                self.const_span = Some(body_span);\n+            }\n+            hir::BodyOwnerKind::Fn => (),\n+        }\n+    }\n+\n+    fn check_body_post(&mut self, cx: &LateContext<'_, '_>, body: &hir::Body) {\n+        let body_owner = cx.tcx.hir.body_owner(body.id());\n+        let body_span = cx.tcx.hir.span(body_owner);\n+\n+        if let Some(span) = self.const_span {\n+            if span.contains(body_span) {\n+                return;\n+            }\n         }\n+        self.const_span = None;\n     }\n }"}, {"sha": "f960ab5958ce59e581e832c31a6a248be83985b3", "filename": "clippy_lints/src/indexing_slicing.rs", "status": "modified", "additions": 36, "deletions": 15, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/183e19a1c3de4b219b80c8871d83009d031d4b54/clippy_lints%2Fsrc%2Findexing_slicing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/183e19a1c3de4b219b80c8871d83009d031d4b54/clippy_lints%2Fsrc%2Findexing_slicing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Findexing_slicing.rs?ref=183e19a1c3de4b219b80c8871d83009d031d4b54", "patch": "@@ -108,19 +108,40 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for IndexingSlicing {\n         if let ExprKind::Index(ref array, ref index) = &expr.node {\n             let ty = cx.tables.expr_ty(array);\n             if let Some(range) = higher::range(cx, index) {\n+\n                 // Ranged indexes, i.e. &x[n..m], &x[n..], &x[..n] and &x[..]\n                 if let ty::Array(_, s) = ty.sty {\n                     let size: u128 = s.assert_usize(cx.tcx).unwrap().into();\n-                    // Index is a constant range.\n-                    if let Some((start, end)) = to_const_range(cx, range, size) {\n-                        if start > size || end > size {\n+\n+                    let const_range = to_const_range(cx, range, size);\n+\n+                    if let (Some(start), _) = const_range {\n+                        if start > size {\n                             utils::span_lint(\n                                 cx,\n                                 OUT_OF_BOUNDS_INDEXING,\n-                                expr.span,\n+                                range.start.map_or(expr.span, |start| start.span),\n                                 \"range is out of bounds\",\n                             );\n+                            return;\n                         }\n+                    }\n+\n+                    if let (_, Some(end)) = const_range {\n+                        if end > size {\n+                            utils::span_lint(\n+                                cx,\n+                                OUT_OF_BOUNDS_INDEXING,\n+                                range.end.map_or(expr.span, |end| end.span),\n+                                \"range is out of bounds\",\n+                            );\n+                            return;\n+                        }\n+                    }\n+\n+                    if let (Some(_), Some(_)) = const_range {\n+                        // early return because both start and end are constants\n+                        // and we have proven above that they are in bounds\n                         return;\n                     }\n                 }\n@@ -161,34 +182,34 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for IndexingSlicing {\n     }\n }\n \n-/// Returns an option containing a tuple with the start and end (exclusive) of\n-/// the range.\n+/// Returns a tuple of options with the start and end (exclusive) values of\n+/// the range. If the start or end is not constant, None is returned.\n fn to_const_range<'a, 'tcx>(\n     cx: &LateContext<'a, 'tcx>,\n     range: Range<'_>,\n     array_size: u128,\n-) -> Option<(u128, u128)> {\n+) -> (Option<u128>, Option<u128>) {\n     let s = range\n         .start\n         .map(|expr| constant(cx, cx.tables, expr).map(|(c, _)| c));\n     let start = match s {\n-        Some(Some(Constant::Int(x))) => x,\n-        Some(_) => return None,\n-        None => 0,\n+        Some(Some(Constant::Int(x))) => Some(x),\n+        Some(_) => None,\n+        None => Some(0),\n     };\n \n     let e = range\n         .end\n         .map(|expr| constant(cx, cx.tables, expr).map(|(c, _)| c));\n     let end = match e {\n         Some(Some(Constant::Int(x))) => if range.limits == RangeLimits::Closed {\n-            x + 1\n+            Some(x + 1)\n         } else {\n-            x\n+            Some(x)\n         },\n-        Some(_) => return None,\n-        None => array_size,\n+        Some(_) => None,\n+        None => Some(array_size),\n     };\n \n-    Some((start, end))\n+    (start, end)\n }"}, {"sha": "eaff87e78f8b93fb1154a7e85ab9992bbdd749c3", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/183e19a1c3de4b219b80c8871d83009d031d4b54/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/183e19a1c3de4b219b80c8871d83009d031d4b54/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=183e19a1c3de4b219b80c8871d83009d031d4b54", "patch": "@@ -144,6 +144,7 @@ pub mod loops;\n pub mod map_clone;\n pub mod map_unit_fn;\n pub mod matches;\n+pub mod mem_discriminant;\n pub mod mem_forget;\n pub mod mem_replace;\n pub mod methods;\n@@ -178,6 +179,7 @@ pub mod ptr;\n pub mod ptr_offset_with_cast;\n pub mod question_mark;\n pub mod ranges;\n+pub mod redundant_clone;\n pub mod redundant_field_names;\n pub mod redundant_pattern_matching;\n pub mod reference;\n@@ -200,6 +202,7 @@ pub mod unused_label;\n pub mod unwrap;\n pub mod use_self;\n pub mod vec;\n+pub mod wildcard_dependencies;\n pub mod write;\n pub mod zero_div_zero;\n // end lints modules, do not remove this comment, it\u2019s used in `update_lints`\n@@ -391,12 +394,13 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry<'_>, conf: &Conf) {\n     reg.register_early_lint_pass(box int_plus_one::IntPlusOne);\n     reg.register_late_lint_pass(box overflow_check_conditional::OverflowCheckConditional);\n     reg.register_late_lint_pass(box unused_label::UnusedLabel);\n-    reg.register_late_lint_pass(box new_without_default::NewWithoutDefault);\n+    reg.register_late_lint_pass(box new_without_default::NewWithoutDefault::default());\n     reg.register_late_lint_pass(box blacklisted_name::BlackListedName::new(conf.blacklisted_names.clone()));\n     reg.register_late_lint_pass(box functions::Functions::new(conf.too_many_arguments_threshold));\n     reg.register_early_lint_pass(box doc::Doc::new(conf.doc_valid_idents.clone()));\n     reg.register_late_lint_pass(box neg_multiply::NegMultiply);\n     reg.register_early_lint_pass(box unsafe_removed_from_name::UnsafeNameRemoval);\n+    reg.register_late_lint_pass(box mem_discriminant::MemDiscriminant);\n     reg.register_late_lint_pass(box mem_forget::MemForget);\n     reg.register_late_lint_pass(box mem_replace::MemReplace);\n     reg.register_late_lint_pass(box arithmetic::Arithmetic::default());\n@@ -438,6 +442,7 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry<'_>, conf: &Conf) {\n     reg.register_late_lint_pass(box question_mark::Pass);\n     reg.register_late_lint_pass(box suspicious_trait_impl::SuspiciousImpl);\n     reg.register_early_lint_pass(box multiple_crate_versions::Pass);\n+    reg.register_early_lint_pass(box wildcard_dependencies::Pass);\n     reg.register_late_lint_pass(box map_unit_fn::Pass);\n     reg.register_late_lint_pass(box infallible_destructuring_match::Pass);\n     reg.register_late_lint_pass(box inherent_impl::Pass::default());\n@@ -448,6 +453,7 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry<'_>, conf: &Conf) {\n     reg.register_late_lint_pass(box indexing_slicing::IndexingSlicing);\n     reg.register_late_lint_pass(box non_copy_const::NonCopyConst);\n     reg.register_late_lint_pass(box ptr_offset_with_cast::Pass);\n+    reg.register_late_lint_pass(box redundant_clone::RedundantClone);\n \n     reg.register_lint_group(\"clippy::restriction\", Some(\"clippy_restriction\"), vec![\n         arithmetic::FLOAT_ARITHMETIC,\n@@ -610,6 +616,7 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry<'_>, conf: &Conf) {\n         matches::MATCH_REF_PATS,\n         matches::MATCH_WILD_ERR_ARM,\n         matches::SINGLE_MATCH,\n+        mem_discriminant::MEM_DISCRIMINANT_NON_ENUM,\n         mem_replace::MEM_REPLACE_OPTION_WITH_NONE,\n         methods::CHARS_LAST_CMP,\n         methods::CHARS_NEXT_CMP,\n@@ -922,6 +929,7 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry<'_>, conf: &Conf) {\n         loops::NEVER_LOOP,\n         loops::REVERSE_RANGE_LOOP,\n         loops::WHILE_IMMUTABLE_CONDITION,\n+        mem_discriminant::MEM_DISCRIMINANT_NON_ENUM,\n         methods::CLONE_DOUBLE_REF,\n         methods::TEMPORARY_CSTRING_AS_PTR,\n         minmax::MIN_MAX,\n@@ -967,13 +975,15 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry<'_>, conf: &Conf) {\n \n     reg.register_lint_group(\"clippy::cargo\", Some(\"clippy_cargo\"), vec![\n         multiple_crate_versions::MULTIPLE_CRATE_VERSIONS,\n+        wildcard_dependencies::WILDCARD_DEPENDENCIES,\n     ]);\n \n     reg.register_lint_group(\"clippy::nursery\", Some(\"clippy_nursery\"), vec![\n         attrs::EMPTY_LINE_AFTER_OUTER_ATTR,\n         fallible_impl_from::FALLIBLE_IMPL_FROM,\n         mutex_atomic::MUTEX_INTEGER,\n         needless_borrow::NEEDLESS_BORROW,\n+        redundant_clone::REDUNDANT_CLONE,\n         unwrap::PANICKING_UNWRAP,\n         unwrap::UNNECESSARY_UNWRAP,\n     ]);"}, {"sha": "0d1b960cc1f58fa37a5a3755d5f21f457d8e183a", "filename": "clippy_lints/src/loops.rs", "status": "modified", "additions": 33, "deletions": 5, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/183e19a1c3de4b219b80c8871d83009d031d4b54/clippy_lints%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/183e19a1c3de4b219b80c8871d83009d031d4b54/clippy_lints%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops.rs?ref=183e19a1c3de4b219b80c8871d83009d031d4b54", "patch": "@@ -1068,7 +1068,7 @@ fn check_for_loop_range<'a, 'tcx>(\n \n             // linting condition: we only indexed one variable, and indexed it directly\n             if visitor.indexed_indirectly.is_empty() && visitor.indexed_directly.len() == 1 {\n-                let (indexed, indexed_extent) = visitor\n+                let (indexed, (indexed_extent, indexed_ty)) = visitor\n                     .indexed_directly\n                     .into_iter()\n                     .next()\n@@ -1119,7 +1119,7 @@ fn check_for_loop_range<'a, 'tcx>(\n                         }\n                     }\n \n-                    if is_len_call(end, indexed) {\n+                    if is_len_call(end, indexed) || is_end_eq_array_len(cx, end, limits, indexed_ty) {\n                         String::new()\n                     } else {\n                         match limits {\n@@ -1207,6 +1207,28 @@ fn is_len_call(expr: &Expr, var: Name) -> bool {\n     false\n }\n \n+fn is_end_eq_array_len(\n+    cx: &LateContext<'_, '_>,\n+    end: &Expr,\n+    limits: ast::RangeLimits,\n+    indexed_ty: Ty<'_>,\n+) -> bool {\n+    if_chain! {\n+        if let ExprKind::Lit(ref lit) = end.node;\n+        if let ast::LitKind::Int(end_int, _) = lit.node;\n+        if let ty::TyKind::Array(_, arr_len_const) = indexed_ty.sty;\n+        if let Some(arr_len) = arr_len_const.assert_usize(cx.tcx);\n+        then {\n+            return match limits {\n+                ast::RangeLimits::Closed => end_int + 1 >= arr_len.into(),\n+                ast::RangeLimits::HalfOpen => end_int >= arr_len.into(),\n+            };\n+        }\n+    }\n+\n+    false\n+}\n+\n fn check_for_loop_reverse_range<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, arg: &'tcx Expr, expr: &'tcx Expr) {\n     // if this for loop is iterating over a two-sided range...\n     if let Some(higher::Range {\n@@ -1678,7 +1700,7 @@ struct VarVisitor<'a, 'tcx: 'a> {\n     indexed_indirectly: FxHashMap<Name, Option<region::Scope>>,\n     /// subset of `indexed` of vars that are indexed directly: `v[i]`\n     /// this will not contain cases like `v[calc_index(i)]` or `v[(i + 4) % N]`\n-    indexed_directly: FxHashMap<Name, Option<region::Scope>>,\n+    indexed_directly: FxHashMap<Name, (Option<region::Scope>, Ty<'tcx>)>,\n     /// Any names that are used outside an index operation.\n     /// Used to detect things like `&mut vec` used together with `vec[i]`\n     referenced: FxHashSet<Name>,\n@@ -1725,7 +1747,10 @@ impl<'a, 'tcx> VarVisitor<'a, 'tcx> {\n                                 self.indexed_indirectly.insert(seqvar.segments[0].ident.name, Some(extent));\n                             }\n                             if index_used_directly {\n-                                self.indexed_directly.insert(seqvar.segments[0].ident.name, Some(extent));\n+                                self.indexed_directly.insert(\n+                                    seqvar.segments[0].ident.name,\n+                                    (Some(extent), self.cx.tables.node_id_to_type(seqexpr.hir_id)),\n+                                );\n                             }\n                             return false;  // no need to walk further *on the variable*\n                         }\n@@ -1734,7 +1759,10 @@ impl<'a, 'tcx> VarVisitor<'a, 'tcx> {\n                                 self.indexed_indirectly.insert(seqvar.segments[0].ident.name, None);\n                             }\n                             if index_used_directly {\n-                                self.indexed_directly.insert(seqvar.segments[0].ident.name, None);\n+                                self.indexed_directly.insert(\n+                                    seqvar.segments[0].ident.name,\n+                                    (None, self.cx.tables.node_id_to_type(seqexpr.hir_id)),\n+                                );\n                             }\n                             return false;  // no need to walk further *on the variable*\n                         }"}, {"sha": "c53c276991d1d02817f449ef7ac2ecf4321d6228", "filename": "clippy_lints/src/mem_discriminant.rs", "status": "added", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/183e19a1c3de4b219b80c8871d83009d031d4b54/clippy_lints%2Fsrc%2Fmem_discriminant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/183e19a1c3de4b219b80c8871d83009d031d4b54/clippy_lints%2Fsrc%2Fmem_discriminant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmem_discriminant.rs?ref=183e19a1c3de4b219b80c8871d83009d031d4b54", "patch": "@@ -0,0 +1,95 @@\n+// Copyright 2014-2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+\n+use crate::rustc::hir::{Expr, ExprKind};\n+use crate::rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n+use crate::rustc::{declare_tool_lint, lint_array};\n+use crate::rustc_errors::Applicability;\n+use crate::utils::{match_def_path, opt_def_id, paths, snippet, span_lint_and_then, walk_ptrs_ty_depth};\n+use if_chain::if_chain;\n+\n+use std::iter;\n+\n+/// **What it does:** Checks for calls of `mem::discriminant()` on a non-enum type.\n+///\n+/// **Why is this bad?** The value of `mem::discriminant()` on non-enum types\n+/// is unspecified.\n+///\n+/// **Known problems:** None.\n+///\n+/// **Example:**\n+/// ```rust\n+/// mem::discriminant(&\"hello\");\n+/// mem::discriminant(&&Some(2));\n+/// ```\n+declare_clippy_lint! {\n+    pub MEM_DISCRIMINANT_NON_ENUM,\n+    correctness,\n+    \"calling mem::descriminant on non-enum type\"\n+}\n+\n+pub struct MemDiscriminant;\n+\n+impl LintPass for MemDiscriminant {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array![MEM_DISCRIMINANT_NON_ENUM]\n+    }\n+}\n+\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MemDiscriminant {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n+        if_chain! {\n+            if let ExprKind::Call(ref func, ref func_args) = expr.node;\n+            // is `mem::discriminant`\n+            if let ExprKind::Path(ref func_qpath) = func.node;\n+            if let Some(def_id) = opt_def_id(cx.tables.qpath_def(func_qpath, func.hir_id));\n+            if match_def_path(cx.tcx, def_id, &paths::MEM_DISCRIMINANT);\n+            // type is non-enum\n+            let ty_param = cx.tables.node_substs(func.hir_id).type_at(0);\n+            if !ty_param.is_enum();\n+\n+            then {\n+                span_lint_and_then(\n+                    cx,\n+                    MEM_DISCRIMINANT_NON_ENUM,\n+                    expr.span,\n+                    &format!(\"calling `mem::discriminant` on non-enum type `{}`\", ty_param),\n+                    |db| {\n+                        // if this is a reference to an enum, suggest dereferencing\n+                        let (base_ty, ptr_depth) = walk_ptrs_ty_depth(ty_param);\n+                        if ptr_depth >= 1 && base_ty.is_enum() {\n+                            let param = &func_args[0];\n+\n+                            // cancel out '&'s first\n+                            let mut derefs_needed = ptr_depth;\n+                            let mut cur_expr = param;\n+                            while derefs_needed > 0  {\n+                                if let ExprKind::AddrOf(_, ref inner_expr) = cur_expr.node {\n+                                    derefs_needed -= 1;\n+                                    cur_expr = inner_expr;\n+                                } else {\n+                                    break;\n+                                }\n+                            }\n+\n+                            let derefs: String = iter::repeat('*').take(derefs_needed).collect();\n+                            db.span_suggestion_with_applicability(\n+                                param.span,\n+                                \"try dereferencing\",\n+                                format!(\"{}{}\", derefs, snippet(cx, cur_expr.span, \"<param>\")),\n+                                Applicability::MachineApplicable,\n+                            );\n+                        }\n+                    },\n+                )\n+            }\n+        }\n+    }\n+}"}, {"sha": "01f97264d0b537894e890b5883d80a1c0031f1c5", "filename": "clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/183e19a1c3de4b219b80c8871d83009d031d4b54/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/183e19a1c3de4b219b80c8871d83009d031d4b54/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=183e19a1c3de4b219b80c8871d83009d031d4b54", "patch": "@@ -452,8 +452,7 @@ declare_clippy_lint! {\n /// **Why is this bad?** As a convention, `new` methods are used to make a new\n /// instance of a type.\n ///\n-/// **Known problems:** The lint fires when the return type is wrapping `Self`.\n-/// Example: `fn new() -> Result<Self, E> {}`\n+/// **Known problems:** None.\n ///\n /// **Example:**\n /// ```rust\n@@ -936,10 +935,15 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n         if let hir::ImplItemKind::Method(_, _) = implitem.node {\n             let ret_ty = return_ty(cx, implitem.id);\n \n-            // if return type is impl trait\n+            // walk the return type and check for Self (this does not check associated types)\n+            for inner_type in ret_ty.walk() {\n+                if same_tys(cx, ty, inner_type) { return; }\n+            }\n+\n+            // if return type is impl trait, check the associated types\n             if let TyKind::Opaque(def_id, _) = ret_ty.sty {\n \n-                // then one of the associated types must be Self\n+                // one of the associated types must be Self\n                 for predicate in cx.tcx.predicates_of(def_id).predicates.iter() {\n                     match predicate {\n                         (Predicate::Projection(poly_projection_predicate), _) => {"}, {"sha": "c554c8729ce3fd6a4dd5e745c1dde06c07ce56b7", "filename": "clippy_lints/src/multiple_crate_versions.rs", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/183e19a1c3de4b219b80c8871d83009d031d4b54/clippy_lints%2Fsrc%2Fmultiple_crate_versions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/183e19a1c3de4b219b80c8871d83009d031d4b54/clippy_lints%2Fsrc%2Fmultiple_crate_versions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmultiple_crate_versions.rs?ref=183e19a1c3de4b219b80c8871d83009d031d4b54", "patch": "@@ -7,12 +7,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n //! lint on multiple versions of a crate being used\n \n use crate::rustc::lint::{EarlyContext, EarlyLintPass, LintArray, LintPass};\n use crate::rustc::{declare_tool_lint, lint_array};\n-use crate::syntax::ast::*;\n+use crate::syntax::{ast::*, source_map::DUMMY_SP};\n use crate::utils::span_lint;\n \n use cargo_metadata;\n@@ -50,16 +49,11 @@ impl LintPass for Pass {\n }\n \n impl EarlyLintPass for Pass {\n-    fn check_crate(&mut self, cx: &EarlyContext<'_>, krate: &Crate) {\n+    fn check_crate(&mut self, cx: &EarlyContext<'_>, _: &Crate) {\n         let metadata = if let Ok(metadata) = cargo_metadata::metadata_deps(None, true) {\n             metadata\n         } else {\n-            span_lint(\n-                cx,\n-                MULTIPLE_CRATE_VERSIONS,\n-                krate.span,\n-                \"could not read cargo metadata\"\n-            );\n+            span_lint(cx, MULTIPLE_CRATE_VERSIONS, DUMMY_SP, \"could not read cargo metadata\");\n \n             return;\n         };\n@@ -76,7 +70,7 @@ impl EarlyLintPass for Pass {\n                 span_lint(\n                     cx,\n                     MULTIPLE_CRATE_VERSIONS,\n-                    krate.span,\n+                    DUMMY_SP,\n                     &format!(\"multiple versions for dependency `{}`: {}\", name, versions),\n                 );\n             }"}, {"sha": "21b966a6bd956255ebdd35bf901641f4dc35fd58", "filename": "clippy_lints/src/new_without_default.rs", "status": "modified", "additions": 33, "deletions": 4, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/183e19a1c3de4b219b80c8871d83009d031d4b54/clippy_lints%2Fsrc%2Fnew_without_default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/183e19a1c3de4b219b80c8871d83009d031d4b54/clippy_lints%2Fsrc%2Fnew_without_default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fnew_without_default.rs?ref=183e19a1c3de4b219b80c8871d83009d031d4b54", "patch": "@@ -11,6 +11,7 @@\n use crate::rustc::hir::def_id::DefId;\n use crate::rustc::hir;\n use crate::rustc::lint::{LateContext, LateLintPass, LintArray, LintPass, in_external_macro, LintContext};\n+use crate::rustc::util::nodemap::NodeSet;\n use crate::rustc::{declare_tool_lint, lint_array};\n use if_chain::if_chain;\n use crate::rustc::ty::{self, Ty};\n@@ -91,8 +92,10 @@ declare_clippy_lint! {\n     \"`fn new() -> Self` without `#[derive]`able `Default` implementation\"\n }\n \n-#[derive(Copy, Clone)]\n-pub struct NewWithoutDefault;\n+#[derive(Clone, Default)]\n+pub struct NewWithoutDefault {\n+    impling_types: Option<NodeSet>,\n+}\n \n impl LintPass for NewWithoutDefault {\n     fn get_lints(&self) -> LintArray {\n@@ -130,13 +133,39 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NewWithoutDefault {\n                             return;\n                         }\n                         if sig.decl.inputs.is_empty() && name == \"new\" && cx.access_levels.is_reachable(id) {\n+                            let self_did = cx.tcx.hir.local_def_id(cx.tcx.hir.get_parent(id));\n                             let self_ty = cx.tcx\n-                                .type_of(cx.tcx.hir.local_def_id(cx.tcx.hir.get_parent(id)));\n+                                .type_of(self_did);\n                             if_chain! {\n                                 if same_tys(cx, self_ty, return_ty(cx, id));\n                                 if let Some(default_trait_id) = get_trait_def_id(cx, &paths::DEFAULT_TRAIT);\n-                                if !implements_trait(cx, self_ty, default_trait_id, &[]);\n                                 then {\n+                                    if self.impling_types.is_none() {\n+                                        let mut impls = NodeSet();\n+                                        cx.tcx.for_each_impl(default_trait_id, |d| {\n+                                            if let Some(ty_def) = cx.tcx.type_of(d).ty_adt_def() {\n+                                                if let Some(node_id) = cx.tcx.hir.as_local_node_id(ty_def.did) {\n+                                                    impls.insert(node_id);\n+                                                }\n+                                            }\n+                                        });\n+                                        self.impling_types = Some(impls);\n+                                    }\n+\n+                                    // Check if a Default implementation exists for the Self type, regardless of\n+                                    // generics\n+                                    if_chain! {\n+                                        if let Some(ref impling_types) = self.impling_types;\n+                                        if let Some(self_def) = cx.tcx.type_of(self_did).ty_adt_def();\n+                                        if self_def.did.is_local();\n+                                        then {\n+                                            let self_id = cx.tcx.hir.local_def_id_to_node_id(self_def.did.to_local());\n+                                            if impling_types.contains(&self_id) {\n+                                                return;\n+                                            }\n+                                        }\n+                                    }\n+\n                                     if let Some(sp) = can_derive_default(self_ty, cx, default_trait_id) {\n                                         span_lint_and_then(\n                                             cx,"}, {"sha": "8c8959159217c46615a9334187f02c03b9994205", "filename": "clippy_lints/src/redundant_clone.rs", "status": "added", "additions": 290, "deletions": 0, "changes": 290, "blob_url": "https://github.com/rust-lang/rust/blob/183e19a1c3de4b219b80c8871d83009d031d4b54/clippy_lints%2Fsrc%2Fredundant_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/183e19a1c3de4b219b80c8871d83009d031d4b54/clippy_lints%2Fsrc%2Fredundant_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fredundant_clone.rs?ref=183e19a1c3de4b219b80c8871d83009d031d4b54", "patch": "@@ -0,0 +1,290 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use crate::rustc::hir::intravisit::FnKind;\n+use crate::rustc::hir::{def_id, Body, FnDecl};\n+use crate::rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n+use crate::rustc::mir::{\n+    self, traversal,\n+    visit::{PlaceContext, Visitor},\n+    TerminatorKind,\n+};\n+use crate::rustc::ty;\n+use crate::rustc::{declare_tool_lint, lint_array};\n+use crate::rustc_errors::Applicability;\n+use crate::syntax::{\n+    ast::NodeId,\n+    source_map::{BytePos, Span},\n+};\n+use crate::utils::{\n+    in_macro, is_copy, match_def_path, match_type, paths, snippet_opt, span_lint_node, span_lint_node_and_then,\n+    walk_ptrs_ty_depth,\n+};\n+use if_chain::if_chain;\n+use std::convert::TryFrom;\n+\n+macro_rules! unwrap_or_continue {\n+    ($x:expr) => {\n+        match $x {\n+            Some(x) => x,\n+            None => continue,\n+        }\n+    };\n+}\n+\n+/// **What it does:** Checks for a redudant `clone()` (and its relatives) which clones an owned\n+/// value that is going to be dropped without further use.\n+///\n+/// **Why is this bad?** It is not always possible for the compiler to eliminate useless\n+/// allocations and deallocations generated by redundant `clone()`s.\n+///\n+/// **Known problems:**\n+///\n+/// * Suggestions made by this lint could require NLL to be enabled.\n+/// * False-positive if there is a borrow preventing the value from moving out.\n+///\n+/// ```rust\n+/// let x = String::new();\n+///\n+/// let y = &x;\n+///\n+/// foo(x.clone()); // This lint suggests to remove this `clone()`\n+/// ```\n+///\n+/// **Example:**\n+/// ```rust\n+/// {\n+///     let x = Foo::new();\n+///     call(x.clone());\n+///     call(x.clone()); // this can just pass `x`\n+/// }\n+///\n+/// [\"lorem\", \"ipsum\"].join(\" \").to_string()\n+///\n+/// Path::new(\"/a/b\").join(\"c\").to_path_buf()\n+/// ```\n+declare_clippy_lint! {\n+    pub REDUNDANT_CLONE,\n+    nursery,\n+    \"`clone()` of an owned value that is going to be dropped immediately\"\n+}\n+\n+pub struct RedundantClone;\n+\n+impl LintPass for RedundantClone {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(REDUNDANT_CLONE)\n+    }\n+}\n+\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for RedundantClone {\n+    fn check_fn(\n+        &mut self,\n+        cx: &LateContext<'a, 'tcx>,\n+        _: FnKind<'tcx>,\n+        _: &'tcx FnDecl,\n+        body: &'tcx Body,\n+        _: Span,\n+        _: NodeId,\n+    ) {\n+        let def_id = cx.tcx.hir.body_owner_def_id(body.id());\n+        let mir = cx.tcx.optimized_mir(def_id);\n+\n+        for (bb, bbdata) in mir.basic_blocks().iter_enumerated() {\n+            let terminator = bbdata.terminator();\n+\n+            if in_macro(terminator.source_info.span) {\n+                continue;\n+            }\n+\n+            // Give up on loops\n+            if terminator.successors().any(|s| *s == bb) {\n+                continue;\n+            }\n+\n+            let (fn_def_id, arg, arg_ty, _) = unwrap_or_continue!(is_call_with_ref_arg(cx, mir, &terminator.kind));\n+\n+            let from_borrow = match_def_path(cx.tcx, fn_def_id, &paths::CLONE_TRAIT_METHOD)\n+                || match_def_path(cx.tcx, fn_def_id, &paths::TO_OWNED_METHOD)\n+                || (match_def_path(cx.tcx, fn_def_id, &paths::TO_STRING_METHOD)\n+                    && match_type(cx, arg_ty, &paths::STRING));\n+\n+            let from_deref = !from_borrow\n+                && (match_def_path(cx.tcx, fn_def_id, &paths::PATH_TO_PATH_BUF)\n+                    || match_def_path(cx.tcx, fn_def_id, &paths::OS_STR_TO_OS_STRING));\n+\n+            if !from_borrow && !from_deref {\n+                continue;\n+            }\n+\n+            // _1 in MIR `{ _2 = &_1; clone(move _2); }` or `{ _2 = _1; to_path_buf(_2); } (from_deref)\n+            // In case of `from_deref`, `arg` is already a reference since it is `deref`ed in the previous\n+            // block.\n+            let cloned = unwrap_or_continue!(find_stmt_assigns_to(arg, from_borrow, bbdata.statements.iter().rev()));\n+\n+            // _1 in MIR `{ _2 = &_1; _3 = deref(move _2); } -> { _4 = _3; to_path_buf(move _4); }`\n+            let referent = if from_deref {\n+                let ps = mir.predecessors_for(bb);\n+                if ps.len() != 1 {\n+                    continue;\n+                }\n+                let pred_terminator = mir[ps[0]].terminator();\n+\n+                let pred_arg = if_chain! {\n+                    if let Some((pred_fn_def_id, pred_arg, pred_arg_ty, Some(res))) =\n+                        is_call_with_ref_arg(cx, mir, &pred_terminator.kind);\n+                    if *res == mir::Place::Local(cloned);\n+                    if match_def_path(cx.tcx, pred_fn_def_id, &paths::DEREF_TRAIT_METHOD);\n+                    if match_type(cx, pred_arg_ty, &paths::PATH_BUF)\n+                        || match_type(cx, pred_arg_ty, &paths::OS_STRING);\n+                    then {\n+                        pred_arg\n+                    } else {\n+                        continue;\n+                    }\n+                };\n+\n+                unwrap_or_continue!(find_stmt_assigns_to(pred_arg, true, mir[ps[0]].statements.iter().rev()))\n+            } else {\n+                cloned\n+            };\n+\n+            let used_later = traversal::ReversePostorder::new(&mir, bb).skip(1).any(|(tbb, tdata)| {\n+                // Give up on loops\n+                if tdata.terminator().successors().any(|s| *s == bb) {\n+                    return true;\n+                }\n+\n+                let mut vis = LocalUseVisitor {\n+                    local: referent,\n+                    used_other_than_drop: false,\n+                };\n+                vis.visit_basic_block_data(tbb, tdata);\n+                vis.used_other_than_drop\n+            });\n+\n+            if !used_later {\n+                let span = terminator.source_info.span;\n+                let node = if let mir::ClearCrossCrate::Set(scope_local_data) = &mir.source_scope_local_data {\n+                    scope_local_data[terminator.source_info.scope].lint_root\n+                } else {\n+                    unreachable!()\n+                };\n+\n+                if_chain! {\n+                    if let Some(snip) = snippet_opt(cx, span);\n+                    if let Some(dot) = snip.rfind('.');\n+                    then {\n+                        let sugg_span = span.with_lo(\n+                            span.lo() + BytePos(u32::try_from(dot).unwrap())\n+                        );\n+\n+                        span_lint_node_and_then(cx, REDUNDANT_CLONE, node, sugg_span, \"redundant clone\", |db| {\n+                            db.span_suggestion_with_applicability(\n+                                sugg_span,\n+                                \"remove this\",\n+                                String::new(),\n+                                Applicability::MaybeIncorrect,\n+                            );\n+                            db.span_note(\n+                                span.with_hi(span.lo() + BytePos(u32::try_from(dot).unwrap())),\n+                                \"this value is dropped without further use\",\n+                            );\n+                        });\n+                    } else {\n+                        span_lint_node(cx, REDUNDANT_CLONE, node, span, \"redundant clone\");\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+/// If `kind` is `y = func(x: &T)` where `T: !Copy`, returns `(DefId of func, x, T, y)`.\n+fn is_call_with_ref_arg<'tcx>(\n+    cx: &LateContext<'_, 'tcx>,\n+    mir: &'tcx mir::Mir<'tcx>,\n+    kind: &'tcx mir::TerminatorKind<'tcx>,\n+) -> Option<(def_id::DefId, mir::Local, ty::Ty<'tcx>, Option<&'tcx mir::Place<'tcx>>)> {\n+    if_chain! {\n+        if let TerminatorKind::Call { func, args, destination, .. } = kind;\n+        if args.len() == 1;\n+        if let mir::Operand::Move(mir::Place::Local(local)) = &args[0];\n+        if let ty::FnDef(def_id, _) = func.ty(&*mir, cx.tcx).sty;\n+        if let (inner_ty, 1) = walk_ptrs_ty_depth(args[0].ty(&*mir, cx.tcx));\n+        if !is_copy(cx, inner_ty);\n+        then {\n+            Some((def_id, *local, inner_ty, destination.as_ref().map(|(dest, _)| dest)))\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n+/// Finds the first `to = (&)from`, and returns `Some(from)`.\n+fn find_stmt_assigns_to<'a, 'tcx: 'a>(\n+    to: mir::Local,\n+    by_ref: bool,\n+    mut stmts: impl Iterator<Item = &'a mir::Statement<'tcx>>,\n+) -> Option<mir::Local> {\n+    stmts.find_map(|stmt| {\n+        if let mir::StatementKind::Assign(mir::Place::Local(local), v) = &stmt.kind {\n+            if *local == to {\n+                if by_ref {\n+                    if let mir::Rvalue::Ref(_, _, mir::Place::Local(r)) = **v {\n+                        return Some(r);\n+                    }\n+                } else if let mir::Rvalue::Use(mir::Operand::Copy(mir::Place::Local(r))) = **v {\n+                    return Some(r);\n+                }\n+            }\n+        }\n+\n+        None\n+    })\n+}\n+\n+struct LocalUseVisitor {\n+    local: mir::Local,\n+    used_other_than_drop: bool,\n+}\n+\n+impl<'tcx> mir::visit::Visitor<'tcx> for LocalUseVisitor {\n+    fn visit_basic_block_data(&mut self, block: mir::BasicBlock, data: &mir::BasicBlockData<'tcx>) {\n+        let statements = &data.statements;\n+        for (statement_index, statement) in statements.iter().enumerate() {\n+            self.visit_statement(block, statement, mir::Location { block, statement_index });\n+\n+            // Once flagged, skip remaining statements\n+            if self.used_other_than_drop {\n+                return;\n+            }\n+        }\n+\n+        self.visit_terminator(\n+            block,\n+            data.terminator(),\n+            mir::Location {\n+                block,\n+                statement_index: statements.len(),\n+            },\n+        );\n+    }\n+\n+    fn visit_local(&mut self, local: &mir::Local, ctx: PlaceContext<'tcx>, _: mir::Location) {\n+        match ctx {\n+            PlaceContext::Drop | PlaceContext::StorageDead => return,\n+            _ => {},\n+        }\n+\n+        if *local == self.local {\n+            self.used_other_than_drop = true;\n+        }\n+    }\n+}"}, {"sha": "035ca2b04964b7d8ee4c16841999ee9c16e2e346", "filename": "clippy_lints/src/types.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/183e19a1c3de4b219b80c8871d83009d031d4b54/clippy_lints%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/183e19a1c3de4b219b80c8871d83009d031d4b54/clippy_lints%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes.rs?ref=183e19a1c3de4b219b80c8871d83009d031d4b54", "patch": "@@ -1920,7 +1920,6 @@ enum ImplicitHasherType<'tcx> {\n \n impl<'tcx> ImplicitHasherType<'tcx> {\n     /// Checks that `ty` is a target type without a BuildHasher.\n-    #[allow(clippy::new_ret_no_self)]\n     fn new<'a>(cx: &LateContext<'a, 'tcx>, hir_ty: &hir::Ty) -> Option<Self> {\n         if let TyKind::Path(QPath::Resolved(None, ref path)) = hir_ty.node {\n             let params: Vec<_> = path.segments.last().as_ref()?.args.as_ref()?"}, {"sha": "a8b7e820681471e3a6dd0e6d49009d87d47aa9bc", "filename": "clippy_lints/src/use_self.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/183e19a1c3de4b219b80c8871d83009d031d4b54/clippy_lints%2Fsrc%2Fuse_self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/183e19a1c3de4b219b80c8871d83009d031d4b54/clippy_lints%2Fsrc%2Fuse_self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fuse_self.rs?ref=183e19a1c3de4b219b80c8871d83009d031d4b54", "patch": "@@ -226,6 +226,6 @@ impl<'a, 'tcx> Visitor<'tcx> for UseSelfVisitor<'a, 'tcx> {\n     }\n \n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n-        NestedVisitorMap::OnlyBodies(&self.cx.tcx.hir)\n+        NestedVisitorMap::All(&self.cx.tcx.hir)\n     }\n }"}, {"sha": "54ca0736c52ed2e833e85495b55229fc1e1835ab", "filename": "clippy_lints/src/utils/inspector.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/183e19a1c3de4b219b80c8871d83009d031d4b54/clippy_lints%2Fsrc%2Futils%2Finspector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/183e19a1c3de4b219b80c8871d83009d031d4b54/clippy_lints%2Fsrc%2Futils%2Finspector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finspector.rs?ref=183e19a1c3de4b219b80c8871d83009d031d4b54", "patch": "@@ -19,12 +19,12 @@ use crate::rustc::hir::print;\n use crate::syntax::ast::Attribute;\n use crate::utils::get_attr;\n \n-/// **What it does:** Dumps every ast/hir node which has the `#[clippy_dump]`\n+/// **What it does:** Dumps every ast/hir node which has the `#[clippy::dump]`\n /// attribute\n ///\n /// **Example:**\n /// ```rust\n-/// #[clippy_dump]\n+/// #[clippy::dump]\n /// extern crate foo;\n /// ```\n ///"}, {"sha": "1a8db837f32b510d6987428d445a09cb152c08e1", "filename": "clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/183e19a1c3de4b219b80c8871d83009d031d4b54/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/183e19a1c3de4b219b80c8871d83009d031d4b54/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=183e19a1c3de4b219b80c8871d83009d031d4b54", "patch": "@@ -562,6 +562,23 @@ pub fn span_lint_and_then<'a, 'tcx: 'a, T: LintContext<'tcx>, F>(\n     db.docs_link(lint);\n }\n \n+pub fn span_lint_node(cx: &LateContext<'_, '_>, lint: &'static Lint, node: NodeId, sp: Span, msg: &str) {\n+    DiagnosticWrapper(cx.tcx.struct_span_lint_node(lint, node, sp, msg)).docs_link(lint);\n+}\n+\n+pub fn span_lint_node_and_then(\n+    cx: &LateContext<'_, '_>,\n+    lint: &'static Lint,\n+    node: NodeId,\n+    sp: Span,\n+    msg: &str,\n+    f: impl FnOnce(&mut DiagnosticBuilder<'_>),\n+) {\n+    let mut db = DiagnosticWrapper(cx.tcx.struct_span_lint_node(lint, node, sp, msg));\n+    f(&mut db.0);\n+    db.docs_link(lint);\n+}\n+\n /// Add a span lint with a suggestion on how to fix it.\n ///\n /// These suggestions can be parsed by rustfix to allow it to automatically fix your code."}, {"sha": "8941d3031562b1331b6bc63130c70028db3b0e7e", "filename": "clippy_lints/src/utils/paths.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/183e19a1c3de4b219b80c8871d83009d031d4b54/clippy_lints%2Fsrc%2Futils%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/183e19a1c3de4b219b80c8871d83009d031d4b54/clippy_lints%2Fsrc%2Futils%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fpaths.rs?ref=183e19a1c3de4b219b80c8871d83009d031d4b54", "patch": "@@ -23,6 +23,7 @@ pub const BTREEMAP: [&str; 5] = [\"alloc\", \"collections\", \"btree\", \"map\", \"BTreeM\n pub const BTREEMAP_ENTRY: [&str; 5] = [\"alloc\", \"collections\", \"btree\", \"map\", \"Entry\"];\n pub const BTREESET: [&str; 5] = [\"alloc\", \"collections\", \"btree\", \"set\", \"BTreeSet\"];\n pub const CLONE_TRAIT: [&str; 3] = [\"core\", \"clone\", \"Clone\"];\n+pub const CLONE_TRAIT_METHOD: [&str; 4] = [\"core\", \"clone\", \"Clone\", \"clone\"];\n pub const CMP_MAX: [&str; 3] = [\"core\", \"cmp\", \"max\"];\n pub const CMP_MIN: [&str; 3] = [\"core\", \"cmp\", \"min\"];\n pub const COW: [&str; 3] = [\"alloc\", \"borrow\", \"Cow\"];\n@@ -31,6 +32,7 @@ pub const C_VOID: [&str; 3] = [\"core\", \"ffi\", \"c_void\"];\n pub const C_VOID_LIBC: [&str; 2] = [\"libc\", \"c_void\"];\n pub const DEFAULT_TRAIT: [&str; 3] = [\"core\", \"default\", \"Default\"];\n pub const DEFAULT_TRAIT_METHOD: [&str; 4] = [\"core\", \"default\", \"Default\", \"default\"];\n+pub const DEREF_TRAIT_METHOD: [&str; 5] = [\"core\", \"ops\", \"deref\", \"Deref\", \"deref\"];\n pub const DISPLAY_FMT_METHOD: [&str; 4] = [\"core\", \"fmt\", \"Display\", \"fmt\"];\n pub const DOUBLE_ENDED_ITERATOR: [&str; 4] = [\"core\", \"iter\", \"traits\", \"DoubleEndedIterator\"];\n pub const DROP: [&str; 3] = [\"core\", \"mem\", \"drop\"];\n@@ -55,6 +57,7 @@ pub const LATE_CONTEXT: [&str; 4] = [\"rustc\", \"lint\", \"context\", \"LateContext\"];\n pub const LINKED_LIST: [&str; 4] = [\"alloc\", \"collections\", \"linked_list\", \"LinkedList\"];\n pub const LINT: [&str; 3] = [\"rustc\", \"lint\", \"Lint\"];\n pub const LINT_ARRAY: [&str; 3] = [\"rustc\", \"lint\", \"LintArray\"];\n+pub const MEM_DISCRIMINANT: [&str; 3] = [\"core\", \"mem\", \"discriminant\"];\n pub const MEM_FORGET: [&str; 3] = [\"core\", \"mem\", \"forget\"];\n pub const MEM_REPLACE: [&str; 3] = [\"core\", \"mem\", \"replace\"];\n pub const MEM_UNINIT: [&str; 3] = [\"core\", \"mem\", \"uninitialized\"];\n@@ -66,7 +69,11 @@ pub const OPTION: [&str; 3] = [\"core\", \"option\", \"Option\"];\n pub const OPTION_NONE: [&str; 4] = [\"core\", \"option\", \"Option\", \"None\"];\n pub const OPTION_SOME: [&str; 4] = [\"core\", \"option\", \"Option\", \"Some\"];\n pub const ORD: [&str; 3] = [\"core\", \"cmp\", \"Ord\"];\n+pub const OS_STRING: [&str; 4] = [\"std\", \"ffi\", \"os_str\", \"OsString\"];\n+pub const OS_STR_TO_OS_STRING: [&str; 5] = [\"std\", \"ffi\", \"os_str\", \"OsStr\", \"to_os_string\"];\n pub const PARTIAL_ORD: [&str; 3] = [\"core\", \"cmp\", \"PartialOrd\"];\n+pub const PATH_BUF: [&str; 3] = [\"std\", \"path\", \"PathBuf\"];\n+pub const PATH_TO_PATH_BUF: [&str; 4] = [\"std\", \"path\", \"Path\", \"to_path_buf\"];\n pub const PTR_NULL: [&str; 2] = [\"ptr\", \"null\"];\n pub const PTR_NULL_MUT: [&str; 2] = [\"ptr\", \"null_mut\"];\n pub const RANGE: [&str; 3] = [\"core\", \"ops\", \"Range\"];\n@@ -99,7 +106,9 @@ pub const SLICE_INTO_VEC: [&str; 4] = [\"alloc\", \"slice\", \"<impl [T]>\", \"into_vec\n pub const SLICE_ITER: [&str; 3] = [\"core\", \"slice\", \"Iter\"];\n pub const STRING: [&str; 3] = [\"alloc\", \"string\", \"String\"];\n pub const TO_OWNED: [&str; 3] = [\"alloc\", \"borrow\", \"ToOwned\"];\n+pub const TO_OWNED_METHOD: [&str; 4] = [\"alloc\", \"borrow\", \"ToOwned\", \"to_owned\"];\n pub const TO_STRING: [&str; 3] = [\"alloc\", \"string\", \"ToString\"];\n+pub const TO_STRING_METHOD: [&str; 4] = [\"alloc\", \"string\", \"ToString\", \"to_string\"];\n pub const TRANSMUTE: [&str; 4] = [\"core\", \"intrinsics\", \"\", \"transmute\"];\n pub const TRY_INTO_RESULT: [&str; 4] = [\"std\", \"ops\", \"Try\", \"into_result\"];\n pub const UNINIT: [&str; 4] = [\"core\", \"intrinsics\", \"\", \"uninit\"];"}, {"sha": "59f3cc78afed15c329154081e219d818ec050735", "filename": "clippy_lints/src/wildcard_dependencies.rs", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/183e19a1c3de4b219b80c8871d83009d031d4b54/clippy_lints%2Fsrc%2Fwildcard_dependencies.rs", "raw_url": "https://github.com/rust-lang/rust/raw/183e19a1c3de4b219b80c8871d83009d031d4b54/clippy_lints%2Fsrc%2Fwildcard_dependencies.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fwildcard_dependencies.rs?ref=183e19a1c3de4b219b80c8871d83009d031d4b54", "patch": "@@ -0,0 +1,69 @@\n+// Copyright 2014-2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use crate::rustc::lint::{EarlyContext, EarlyLintPass, LintArray, LintPass};\n+use crate::rustc::{declare_tool_lint, lint_array};\n+use crate::syntax::{ast::*, source_map::DUMMY_SP};\n+use crate::utils::span_lint;\n+\n+use cargo_metadata;\n+use semver;\n+\n+/// **What it does:** Checks for wildcard dependencies in the `Cargo.toml`.\n+///\n+/// **Why is this bad?** [As the edition guide says](https://rust-lang-nursery.github.io/edition-guide/rust-2018/cargo-and-crates-io/crates-io-disallows-wildcard-dependencies.html),\n+/// it is highly unlikely that you work with any possible version of your dependency,\n+/// and wildcard dependencies would cause unnecessary breakage in the ecosystem.\n+///\n+/// **Known problems:** None.\n+///\n+/// **Example:**\n+///\n+/// ```toml\n+/// [dependencies]\n+/// regex = \"*\"\n+/// ```\n+declare_clippy_lint! {\n+    pub WILDCARD_DEPENDENCIES,\n+    cargo,\n+    \"wildcard dependencies being used\"\n+}\n+\n+pub struct Pass;\n+\n+impl LintPass for Pass {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(WILDCARD_DEPENDENCIES)\n+    }\n+}\n+\n+impl EarlyLintPass for Pass {\n+    fn check_crate(&mut self, cx: &EarlyContext<'_>, _: &Crate) {\n+        let metadata = if let Ok(metadata) = cargo_metadata::metadata(None) {\n+            metadata\n+        } else {\n+            span_lint(cx, WILDCARD_DEPENDENCIES, DUMMY_SP, \"could not read cargo metadata\");\n+            return;\n+        };\n+\n+        for dep in &metadata.packages[0].dependencies {\n+            // VersionReq::any() does not work\n+            if let Ok(wildcard_ver) = semver::VersionReq::parse(\"*\") {\n+                if dep.req == wildcard_ver {\n+                    span_lint(\n+                        cx,\n+                        WILDCARD_DEPENDENCIES,\n+                        DUMMY_SP,\n+                        &format!(\"wildcard dependency for `{}`\", dep.name),\n+                    );\n+                }\n+            }\n+        }\n+    }\n+}"}, {"sha": "61a601468fb7d42d790118446cfd316b588e602a", "filename": "tests/ui/arithmetic.rs", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/183e19a1c3de4b219b80c8871d83009d031d4b54/tests%2Fui%2Farithmetic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/183e19a1c3de4b219b80c8871d83009d031d4b54/tests%2Fui%2Farithmetic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Farithmetic.rs?ref=183e19a1c3de4b219b80c8871d83009d031d4b54", "patch": "@@ -37,4 +37,36 @@ fn main() {\n     f / 2.0;\n     f - 2.0 * 4.2;\n     -f;\n+\n+    // No errors for the following items because they are constant expressions\n+    enum Foo {\n+        Bar = -2,\n+    }\n+    struct Baz([i32; 1 + 1]);\n+    union Qux {\n+        field: [i32; 1 + 1],\n+    }\n+    type Alias = [i32; 1 + 1];\n+\n+    const FOO: i32 = -2;\n+    static BAR: i32 = -2;\n+\n+    let _: [i32; 1 + 1] = [0, 0];\n+\n+    let _: [i32; 1 + 1] = {\n+        let a: [i32; 1 + 1] = [0, 0];\n+        a\n+    };\n+\n+    trait Trait {\n+        const ASSOC: i32 = 1 + 1;\n+    }\n+\n+    impl Trait for Foo {\n+        const ASSOC: i32 = {\n+            let _: [i32; 1 + 1];\n+            fn foo() {}\n+            1 + 1\n+        };\n+    }\n }"}, {"sha": "695209de53f3beda36fd7867dafe15d56b7d32a5", "filename": "tests/ui/for_loop.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/183e19a1c3de4b219b80c8871d83009d031d4b54/tests%2Fui%2Ffor_loop.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/183e19a1c3de4b219b80c8871d83009d031d4b54/tests%2Fui%2Ffor_loop.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffor_loop.stderr?ref=183e19a1c3de4b219b80c8871d83009d031d4b54", "patch": "@@ -97,8 +97,8 @@ error: the loop variable `j` is only used to index `STATIC`.\n     |              ^^^^\n help: consider using an iterator\n     |\n-110 |     for <item> in STATIC.iter().take(4) {\n-    |         ^^^^^^    ^^^^^^^^^^^^^^^^^^^^^\n+110 |     for <item> in &STATIC {\n+    |         ^^^^^^    ^^^^^^^\n \n error: the loop variable `j` is only used to index `CONST`.\n    --> $DIR/for_loop.rs:114:14\n@@ -107,8 +107,8 @@ error: the loop variable `j` is only used to index `CONST`.\n     |              ^^^^\n help: consider using an iterator\n     |\n-114 |     for <item> in CONST.iter().take(4) {\n-    |         ^^^^^^    ^^^^^^^^^^^^^^^^^^^^\n+114 |     for <item> in &CONST {\n+    |         ^^^^^^    ^^^^^^\n \n error: the loop variable `i` is used to index `vec`\n    --> $DIR/for_loop.rs:118:14"}, {"sha": "ff154091bb82a674e14e1dfb93b7b5d9dd3b1e97", "filename": "tests/ui/indexing_slicing.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/183e19a1c3de4b219b80c8871d83009d031d4b54/tests%2Fui%2Findexing_slicing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/183e19a1c3de4b219b80c8871d83009d031d4b54/tests%2Fui%2Findexing_slicing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Findexing_slicing.rs?ref=183e19a1c3de4b219b80c8871d83009d031d4b54", "patch": "@@ -91,4 +91,9 @@ fn main() {\n     x[M]; // Ok, should not produce stderr.\n     v[N];\n     v[M];\n+\n+    // issue 3102\n+    let num = 1;\n+    &x[num..10]; // should trigger out of bounds error\n+    &x[10..num]; // should trigger out of bounds error\n }"}, {"sha": "14e9627e57344c0bde16b83e538048ac13d88465", "filename": "tests/ui/indexing_slicing.stderr", "status": "modified", "additions": 69, "deletions": 31, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/183e19a1c3de4b219b80c8871d83009d031d4b54/tests%2Fui%2Findexing_slicing.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/183e19a1c3de4b219b80c8871d83009d031d4b54/tests%2Fui%2Findexing_slicing.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Findexing_slicing.stderr?ref=183e19a1c3de4b219b80c8871d83009d031d4b54", "patch": "@@ -1,3 +1,29 @@\n+error: index out of bounds: the len is 4 but the index is 4\n+  --> $DIR/indexing_slicing.rs:28:5\n+   |\n+28 |     x[4]; // Ok, let rustc's `const_err` lint handle `usize` indexing on arrays.\n+   |     ^^^^\n+   |\n+   = note: #[deny(const_err)] on by default\n+\n+error: index out of bounds: the len is 4 but the index is 8\n+  --> $DIR/indexing_slicing.rs:29:5\n+   |\n+29 |     x[1 << 3]; // Ok, let rustc's `const_err` lint handle `usize` indexing on arrays.\n+   |     ^^^^^^^^^\n+\n+error: index out of bounds: the len is 0 but the index is 0\n+  --> $DIR/indexing_slicing.rs:59:5\n+   |\n+59 |     empty[0]; // Ok, let rustc's `const_err` lint handle `usize` indexing on arrays.\n+   |     ^^^^^^^^\n+\n+error: index out of bounds: the len is 4 but the index is 15\n+  --> $DIR/indexing_slicing.rs:90:5\n+   |\n+90 |     x[N]; // Ok, let rustc's `const_err` lint handle `usize` indexing on arrays.\n+   |     ^^^^\n+\n error: indexing may panic.\n   --> $DIR/indexing_slicing.rs:23:5\n    |\n@@ -48,18 +74,18 @@ error: slicing may panic.\n    = help: Consider using `.get(n..)` or .get_mut(n..)` instead\n \n error: range is out of bounds\n-  --> $DIR/indexing_slicing.rs:30:6\n+  --> $DIR/indexing_slicing.rs:30:11\n    |\n 30 |     &x[..=4];\n-   |      ^^^^^^^\n+   |           ^\n    |\n    = note: `-D clippy::out-of-bounds-indexing` implied by `-D warnings`\n \n error: range is out of bounds\n-  --> $DIR/indexing_slicing.rs:31:6\n+  --> $DIR/indexing_slicing.rs:31:11\n    |\n 31 |     &x[1..5];\n-   |      ^^^^^^^\n+   |           ^\n \n error: slicing may panic.\n   --> $DIR/indexing_slicing.rs:32:6\n@@ -70,34 +96,34 @@ error: slicing may panic.\n    = help: Consider using `.get(..n)`or `.get_mut(..n)` instead\n \n error: range is out of bounds\n-  --> $DIR/indexing_slicing.rs:32:6\n+  --> $DIR/indexing_slicing.rs:32:8\n    |\n 32 |     &x[5..][..10]; // Two lint reports, one for [5..] and another for [..10].\n-   |      ^^^^^^\n+   |        ^\n \n error: range is out of bounds\n-  --> $DIR/indexing_slicing.rs:33:6\n+  --> $DIR/indexing_slicing.rs:33:8\n    |\n 33 |     &x[5..];\n-   |      ^^^^^^\n+   |        ^\n \n error: range is out of bounds\n-  --> $DIR/indexing_slicing.rs:34:6\n+  --> $DIR/indexing_slicing.rs:34:10\n    |\n 34 |     &x[..5];\n-   |      ^^^^^^\n+   |          ^\n \n error: range is out of bounds\n-  --> $DIR/indexing_slicing.rs:35:6\n+  --> $DIR/indexing_slicing.rs:35:8\n    |\n 35 |     &x[5..].iter().map(|x| 2 * x).collect::<Vec<i32>>();\n-   |      ^^^^^^\n+   |        ^\n \n error: range is out of bounds\n-  --> $DIR/indexing_slicing.rs:36:6\n+  --> $DIR/indexing_slicing.rs:36:12\n    |\n 36 |     &x[0..=4];\n-   |      ^^^^^^^^\n+   |            ^\n \n error: slicing may panic.\n   --> $DIR/indexing_slicing.rs:37:6\n@@ -148,46 +174,46 @@ error: slicing may panic.\n    = help: Consider using `.get(..n)`or `.get_mut(..n)` instead\n \n error: range is out of bounds\n-  --> $DIR/indexing_slicing.rs:60:6\n+  --> $DIR/indexing_slicing.rs:60:12\n    |\n 60 |     &empty[1..5];\n-   |      ^^^^^^^^^^^\n+   |            ^\n \n error: range is out of bounds\n-  --> $DIR/indexing_slicing.rs:61:6\n+  --> $DIR/indexing_slicing.rs:61:16\n    |\n 61 |     &empty[0..=4];\n-   |      ^^^^^^^^^^^^\n+   |                ^\n \n error: range is out of bounds\n-  --> $DIR/indexing_slicing.rs:62:6\n+  --> $DIR/indexing_slicing.rs:62:15\n    |\n 62 |     &empty[..=4];\n-   |      ^^^^^^^^^^^\n+   |               ^\n \n error: range is out of bounds\n-  --> $DIR/indexing_slicing.rs:63:6\n+  --> $DIR/indexing_slicing.rs:63:12\n    |\n 63 |     &empty[1..];\n-   |      ^^^^^^^^^^\n+   |            ^\n \n error: range is out of bounds\n-  --> $DIR/indexing_slicing.rs:64:6\n+  --> $DIR/indexing_slicing.rs:64:14\n    |\n 64 |     &empty[..4];\n-   |      ^^^^^^^^^^\n+   |              ^\n \n error: range is out of bounds\n-  --> $DIR/indexing_slicing.rs:65:6\n+  --> $DIR/indexing_slicing.rs:65:16\n    |\n 65 |     &empty[0..=0];\n-   |      ^^^^^^^^^^^^\n+   |                ^\n \n error: range is out of bounds\n-  --> $DIR/indexing_slicing.rs:66:6\n+  --> $DIR/indexing_slicing.rs:66:15\n    |\n 66 |     &empty[..=0];\n-   |      ^^^^^^^^^^^\n+   |               ^\n \n error: indexing may panic.\n   --> $DIR/indexing_slicing.rs:74:5\n@@ -230,10 +256,10 @@ error: slicing may panic.\n    = help: Consider using `.get(..n)`or `.get_mut(..n)` instead\n \n error: range is out of bounds\n-  --> $DIR/indexing_slicing.rs:78:6\n+  --> $DIR/indexing_slicing.rs:78:8\n    |\n 78 |     &x[10..][..100]; // Two lint reports, one for [10..] and another for [..100].\n-   |      ^^^^^^^\n+   |        ^^\n \n error: slicing may panic.\n   --> $DIR/indexing_slicing.rs:79:6\n@@ -267,5 +293,17 @@ error: indexing may panic.\n    |\n    = help: Consider using `.get(n)` or `.get_mut(n)` instead\n \n-error: aborting due to 37 previous errors\n+error: range is out of bounds\n+  --> $DIR/indexing_slicing.rs:97:13\n+   |\n+97 |     &x[num..10]; // should trigger out of bounds error\n+   |             ^^\n+\n+error: range is out of bounds\n+  --> $DIR/indexing_slicing.rs:98:8\n+   |\n+98 |     &x[10..num]; // should trigger out of bounds error\n+   |        ^^\n+\n+error: aborting due to 43 previous errors\n "}, {"sha": "5ddd90ac8b57350d9ec94ac59b96a13270d44582", "filename": "tests/ui/mem_discriminant.rs", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/183e19a1c3de4b219b80c8871d83009d031d4b54/tests%2Fui%2Fmem_discriminant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/183e19a1c3de4b219b80c8871d83009d031d4b54/tests%2Fui%2Fmem_discriminant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmem_discriminant.rs?ref=183e19a1c3de4b219b80c8871d83009d031d4b54", "patch": "@@ -0,0 +1,55 @@\n+// Copyright 2014-2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+\n+#![deny(clippy::mem_discriminant_non_enum)]\n+\n+use std::mem;\n+\n+enum Foo {\n+    One(usize),\n+    Two(u8),\n+}\n+\n+struct A(Foo);\n+\n+fn main() {\n+    // bad\n+    mem::discriminant(&\"hello\");\n+    mem::discriminant(&&Some(2));\n+    mem::discriminant(&&None::<u8>);\n+    mem::discriminant(&&Foo::One(5));\n+    mem::discriminant(&&Foo::Two(5));\n+    mem::discriminant(&A(Foo::One(0)));\n+\n+    let ro = &Some(3);\n+    let rro = &ro;\n+    mem::discriminant(&ro);\n+    mem::discriminant(rro);\n+    mem::discriminant(&rro);\n+\n+    macro_rules! mem_discriminant_but_in_a_macro {\n+        ($param:expr) => (mem::discriminant($param))\n+    }\n+\n+    mem_discriminant_but_in_a_macro!(&rro);\n+\n+    let rrrrro = &&&rro;\n+    mem::discriminant(&rrrrro);\n+    mem::discriminant(*rrrrro);\n+\n+    // ok\n+    mem::discriminant(&Some(2));\n+    mem::discriminant(&None::<u8>);\n+    mem::discriminant(&Foo::One(5));\n+    mem::discriminant(&Foo::Two(5));\n+    mem::discriminant(ro);\n+    mem::discriminant(*rro);\n+    mem::discriminant(****rrrrro);\n+}"}, {"sha": "6414e4c96d63bdacb54d42d4644c26b51221ae7c", "filename": "tests/ui/mem_discriminant.stderr", "status": "added", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/183e19a1c3de4b219b80c8871d83009d031d4b54/tests%2Fui%2Fmem_discriminant.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/183e19a1c3de4b219b80c8871d83009d031d4b54/tests%2Fui%2Fmem_discriminant.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmem_discriminant.stderr?ref=183e19a1c3de4b219b80c8871d83009d031d4b54", "patch": "@@ -0,0 +1,104 @@\n+error: calling `mem::discriminant` on non-enum type `&str`\n+  --> $DIR/mem_discriminant.rs:24:5\n+   |\n+24 |     mem::discriminant(&\"hello\");\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: lint level defined here\n+  --> $DIR/mem_discriminant.rs:11:9\n+   |\n+11 | #![deny(clippy::mem_discriminant_non_enum)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: calling `mem::discriminant` on non-enum type `&std::option::Option<i32>`\n+  --> $DIR/mem_discriminant.rs:25:5\n+   |\n+25 |     mem::discriminant(&&Some(2));\n+   |     ^^^^^^^^^^^^^^^^^^---------^\n+   |                       |\n+   |                       help: try dereferencing: `&Some(2)`\n+\n+error: calling `mem::discriminant` on non-enum type `&std::option::Option<u8>`\n+  --> $DIR/mem_discriminant.rs:26:5\n+   |\n+26 |     mem::discriminant(&&None::<u8>);\n+   |     ^^^^^^^^^^^^^^^^^^------------^\n+   |                       |\n+   |                       help: try dereferencing: `&None::<u8>`\n+\n+error: calling `mem::discriminant` on non-enum type `&Foo`\n+  --> $DIR/mem_discriminant.rs:27:5\n+   |\n+27 |     mem::discriminant(&&Foo::One(5));\n+   |     ^^^^^^^^^^^^^^^^^^-------------^\n+   |                       |\n+   |                       help: try dereferencing: `&Foo::One(5)`\n+\n+error: calling `mem::discriminant` on non-enum type `&Foo`\n+  --> $DIR/mem_discriminant.rs:28:5\n+   |\n+28 |     mem::discriminant(&&Foo::Two(5));\n+   |     ^^^^^^^^^^^^^^^^^^-------------^\n+   |                       |\n+   |                       help: try dereferencing: `&Foo::Two(5)`\n+\n+error: calling `mem::discriminant` on non-enum type `A`\n+  --> $DIR/mem_discriminant.rs:29:5\n+   |\n+29 |     mem::discriminant(&A(Foo::One(0)));\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: calling `mem::discriminant` on non-enum type `&std::option::Option<i32>`\n+  --> $DIR/mem_discriminant.rs:33:5\n+   |\n+33 |     mem::discriminant(&ro);\n+   |     ^^^^^^^^^^^^^^^^^^---^\n+   |                       |\n+   |                       help: try dereferencing: `ro`\n+\n+error: calling `mem::discriminant` on non-enum type `&std::option::Option<i32>`\n+  --> $DIR/mem_discriminant.rs:34:5\n+   |\n+34 |     mem::discriminant(rro);\n+   |     ^^^^^^^^^^^^^^^^^^---^\n+   |                       |\n+   |                       help: try dereferencing: `*rro`\n+\n+error: calling `mem::discriminant` on non-enum type `&&std::option::Option<i32>`\n+  --> $DIR/mem_discriminant.rs:35:5\n+   |\n+35 |     mem::discriminant(&rro);\n+   |     ^^^^^^^^^^^^^^^^^^----^\n+   |                       |\n+   |                       help: try dereferencing: `*rro`\n+\n+error: calling `mem::discriminant` on non-enum type `&&std::option::Option<i32>`\n+  --> $DIR/mem_discriminant.rs:38:27\n+   |\n+38 |         ($param:expr) => (mem::discriminant($param))\n+   |                           ^^^^^^^^^^^^^^^^^^^^^^^^^\n+...\n+41 |     mem_discriminant_but_in_a_macro!(&rro);\n+   |     ---------------------------------------\n+   |     |                                |\n+   |     |                                help: try dereferencing: `*rro`\n+   |     in this macro invocation\n+\n+error: calling `mem::discriminant` on non-enum type `&&&&&std::option::Option<i32>`\n+  --> $DIR/mem_discriminant.rs:44:5\n+   |\n+44 |     mem::discriminant(&rrrrro);\n+   |     ^^^^^^^^^^^^^^^^^^-------^\n+   |                       |\n+   |                       help: try dereferencing: `****rrrrro`\n+\n+error: calling `mem::discriminant` on non-enum type `&&&std::option::Option<i32>`\n+  --> $DIR/mem_discriminant.rs:45:5\n+   |\n+45 |     mem::discriminant(*rrrrro);\n+   |     ^^^^^^^^^^^^^^^^^^-------^\n+   |                       |\n+   |                       help: try dereferencing: `****rrrrro`\n+\n+error: aborting due to 12 previous errors\n+"}, {"sha": "c1992bba548054c0eaea9d55d5d01595320f0fa2", "filename": "tests/ui/needless_range_loop.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/183e19a1c3de4b219b80c8871d83009d031d4b54/tests%2Fui%2Fneedless_range_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/183e19a1c3de4b219b80c8871d83009d031d4b54/tests%2Fui%2Fneedless_range_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_range_loop.rs?ref=183e19a1c3de4b219b80c8871d83009d031d4b54", "patch": "@@ -13,7 +13,7 @@ fn calc_idx(i: usize) -> usize {\n }\n \n fn main() {\n-    let ns = [2, 3, 5, 7];\n+    let ns = vec![2, 3, 5, 7];\n \n     for i in 3..10 {\n         println!(\"{}\", ns[i]);\n@@ -76,4 +76,18 @@ fn main() {\n     for i in x..=x + 4 {\n         vec[i] += 1;\n     }\n+\n+    let arr = [1,2,3];\n+\n+    for i in 0..3 {\n+        println!(\"{}\", arr[i]);\n+    }\n+\n+    for i in 0..2 {\n+        println!(\"{}\", arr[i]);\n+    }\n+\n+    for i in 1..3 {\n+        println!(\"{}\", arr[i]);\n+    }\n }"}, {"sha": "688e9fc3a2c59c30d8f17361f19455df8c6f7d24", "filename": "tests/ui/needless_range_loop.stderr", "status": "modified", "additions": 31, "deletions": 1, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/183e19a1c3de4b219b80c8871d83009d031d4b54/tests%2Fui%2Fneedless_range_loop.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/183e19a1c3de4b219b80c8871d83009d031d4b54/tests%2Fui%2Fneedless_range_loop.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_range_loop.stderr?ref=183e19a1c3de4b219b80c8871d83009d031d4b54", "patch": "@@ -50,5 +50,35 @@ help: consider using an iterator\n 76 |     for <item> in vec.iter_mut().skip(x).take(4 + 1) {\n    |         ^^^^^^    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: aborting due to 5 previous errors\n+error: the loop variable `i` is only used to index `arr`.\n+  --> $DIR/needless_range_loop.rs:82:14\n+   |\n+82 |     for i in 0..3 {\n+   |              ^^^^\n+help: consider using an iterator\n+   |\n+82 |     for <item> in &arr {\n+   |         ^^^^^^    ^^^^\n+\n+error: the loop variable `i` is only used to index `arr`.\n+  --> $DIR/needless_range_loop.rs:86:14\n+   |\n+86 |     for i in 0..2 {\n+   |              ^^^^\n+help: consider using an iterator\n+   |\n+86 |     for <item> in arr.iter().take(2) {\n+   |         ^^^^^^    ^^^^^^^^^^^^^^^^^^\n+\n+error: the loop variable `i` is only used to index `arr`.\n+  --> $DIR/needless_range_loop.rs:90:14\n+   |\n+90 |     for i in 1..3 {\n+   |              ^^^^\n+help: consider using an iterator\n+   |\n+90 |     for <item> in arr.iter().skip(1) {\n+   |         ^^^^^^    ^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 8 previous errors\n "}, {"sha": "bed43f550f218539dd2d7b5868a9d63b2b8fc3e2", "filename": "tests/ui/new_ret_no_self.rs", "status": "modified", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/183e19a1c3de4b219b80c8871d83009d031d4b54/tests%2Fui%2Fnew_ret_no_self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/183e19a1c3de4b219b80c8871d83009d031d4b54/tests%2Fui%2Fnew_ret_no_self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fnew_ret_no_self.rs?ref=183e19a1c3de4b219b80c8871d83009d031d4b54", "patch": "@@ -91,3 +91,87 @@ impl V {\n         unimplemented!();\n     }\n }\n+\n+struct TupleReturnerOk;\n+\n+impl TupleReturnerOk {\n+    // should not trigger lint\n+    pub fn new() -> (Self, u32) { unimplemented!(); }\n+}\n+\n+struct TupleReturnerOk2;\n+\n+impl TupleReturnerOk2 {\n+    // should not trigger lint (it doesn't matter which element in the tuple is Self)\n+    pub fn new() -> (u32, Self) { unimplemented!(); }\n+}\n+\n+struct TupleReturnerOk3;\n+\n+impl TupleReturnerOk3 {\n+    // should not trigger lint (tuple can contain multiple Self)\n+    pub fn new() -> (Self, Self) { unimplemented!(); }\n+}\n+\n+struct TupleReturnerBad;\n+\n+impl TupleReturnerBad {\n+    // should trigger lint\n+    pub fn new() -> (u32, u32) { unimplemented!(); }\n+}\n+\n+struct MutPointerReturnerOk;\n+\n+impl MutPointerReturnerOk {\n+    // should not trigger lint\n+    pub fn new() -> *mut Self { unimplemented!(); }\n+}\n+\n+struct MutPointerReturnerOk2;\n+\n+impl MutPointerReturnerOk2 {\n+    // should not trigger lint\n+    pub fn new() -> *const Self { unimplemented!(); }\n+}\n+\n+struct MutPointerReturnerBad;\n+\n+impl MutPointerReturnerBad {\n+    // should trigger lint\n+    pub fn new() -> *mut V { unimplemented!(); }\n+}\n+\n+struct GenericReturnerOk;\n+\n+impl GenericReturnerOk {\n+    // should not trigger lint\n+    pub fn new() -> Option<Self> { unimplemented!(); }\n+}\n+\n+struct GenericReturnerBad;\n+\n+impl GenericReturnerBad {\n+    // should trigger lint\n+    pub fn new() -> Option<u32> { unimplemented!(); }\n+}\n+\n+struct NestedReturnerOk;\n+\n+impl NestedReturnerOk {\n+    // should not trigger lint\n+    pub fn new() -> (Option<Self>, u32) { unimplemented!(); }\n+}\n+\n+struct NestedReturnerOk2;\n+\n+impl NestedReturnerOk2 {\n+    // should not trigger lint\n+    pub fn new() -> ((Self, u32), u32) { unimplemented!(); }\n+}\n+\n+struct NestedReturnerOk3;\n+\n+impl NestedReturnerOk3 {\n+    // should not trigger lint\n+    pub fn new() -> Option<(Self, u32)> { unimplemented!(); }\n+}"}, {"sha": "bab9627ca225cd1de6a8f86aa5a70d06c4832757", "filename": "tests/ui/new_ret_no_self.stderr", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/183e19a1c3de4b219b80c8871d83009d031d4b54/tests%2Fui%2Fnew_ret_no_self.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/183e19a1c3de4b219b80c8871d83009d031d4b54/tests%2Fui%2Fnew_ret_no_self.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fnew_ret_no_self.stderr?ref=183e19a1c3de4b219b80c8871d83009d031d4b54", "patch": "@@ -24,5 +24,23 @@ error: methods called `new` usually return `Self`\n 92 | |     }\n    | |_____^\n \n-error: aborting due to 3 previous errors\n+error: methods called `new` usually return `Self`\n+   --> $DIR/new_ret_no_self.rs:120:5\n+    |\n+120 |     pub fn new() -> (u32, u32) { unimplemented!(); }\n+    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: methods called `new` usually return `Self`\n+   --> $DIR/new_ret_no_self.rs:141:5\n+    |\n+141 |     pub fn new() -> *mut V { unimplemented!(); }\n+    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: methods called `new` usually return `Self`\n+   --> $DIR/new_ret_no_self.rs:155:5\n+    |\n+155 |     pub fn new() -> Option<u32> { unimplemented!(); }\n+    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 6 previous errors\n "}, {"sha": "16b9bd5c71bfba82a479cc7f9334bd28ff5a3ec5", "filename": "tests/ui/new_without_default.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/183e19a1c3de4b219b80c8871d83009d031d4b54/tests%2Fui%2Fnew_without_default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/183e19a1c3de4b219b80c8871d83009d031d4b54/tests%2Fui%2Fnew_without_default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fnew_without_default.rs?ref=183e19a1c3de4b219b80c8871d83009d031d4b54", "patch": "@@ -107,4 +107,13 @@ impl IgnoreUnsafeNew {\n     pub unsafe fn new() -> Self { IgnoreUnsafeNew }\n }\n \n+#[derive(Default)]\n+pub struct OptionRefWrapper<'a, T: 'a>(Option<&'a T>);\n+\n+impl<'a, T: 'a> OptionRefWrapper<'a, T> {\n+    pub fn new() -> Self {\n+        OptionRefWrapper(None)\n+    }\n+}\n+\n fn main() {}"}, {"sha": "deedde3823162bae9b6941cffe012d926de483ac", "filename": "tests/ui/redundant_clone.rs", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/183e19a1c3de4b219b80c8871d83009d031d4b54/tests%2Fui%2Fredundant_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/183e19a1c3de4b219b80c8871d83009d031d4b54/tests%2Fui%2Fredundant_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fredundant_clone.rs?ref=183e19a1c3de4b219b80c8871d83009d031d4b54", "patch": "@@ -0,0 +1,47 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![warn(clippy::redundant_clone)]\n+\n+use std::path::Path;\n+use std::ffi::OsString;\n+\n+fn main() {\n+    let _ = [\"lorem\", \"ipsum\"].join(\" \").to_string();\n+\n+    let s = String::from(\"foo\");\n+    let _ = s.clone();\n+\n+    let s = String::from(\"foo\");\n+    let _ = s.to_string();\n+\n+    let s = String::from(\"foo\");\n+    let _ = s.to_owned();\n+\n+    let _ = Path::new(\"/a/b/\").join(\"c\").to_owned();\n+\n+    let _ = Path::new(\"/a/b/\").join(\"c\").to_path_buf();\n+\n+    let _ = OsString::new().to_owned();\n+\n+    let _ = OsString::new().to_os_string();\n+\n+    // Check that lint level works\n+    #[allow(clippy::redundant_clone)] let _ = String::new().to_string();\n+}\n+\n+#[derive(Clone)]\n+struct Alpha;\n+fn double(a: Alpha) -> (Alpha, Alpha) {\n+    if true {\n+        (a.clone(), a.clone())\n+    } else {\n+        (Alpha, a)\n+    }\n+}"}, {"sha": "db452822f89154ce6c3f36c6f6defa384fb2ac23", "filename": "tests/ui/redundant_clone.stderr", "status": "added", "additions": 111, "deletions": 0, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/183e19a1c3de4b219b80c8871d83009d031d4b54/tests%2Fui%2Fredundant_clone.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/183e19a1c3de4b219b80c8871d83009d031d4b54/tests%2Fui%2Fredundant_clone.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fredundant_clone.stderr?ref=183e19a1c3de4b219b80c8871d83009d031d4b54", "patch": "@@ -0,0 +1,111 @@\n+error: redundant clone\n+  --> $DIR/redundant_clone.rs:16:41\n+   |\n+16 |     let _ = [\"lorem\", \"ipsum\"].join(\" \").to_string();\n+   |                                         ^^^^^^^^^^^^ help: remove this\n+   |\n+   = note: `-D clippy::redundant-clone` implied by `-D warnings`\n+note: this value is dropped without further use\n+  --> $DIR/redundant_clone.rs:16:13\n+   |\n+16 |     let _ = [\"lorem\", \"ipsum\"].join(\" \").to_string();\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: redundant clone\n+  --> $DIR/redundant_clone.rs:19:14\n+   |\n+19 |     let _ = s.clone();\n+   |              ^^^^^^^^ help: remove this\n+   |\n+note: this value is dropped without further use\n+  --> $DIR/redundant_clone.rs:19:13\n+   |\n+19 |     let _ = s.clone();\n+   |             ^\n+\n+error: redundant clone\n+  --> $DIR/redundant_clone.rs:22:14\n+   |\n+22 |     let _ = s.to_string();\n+   |              ^^^^^^^^^^^^ help: remove this\n+   |\n+note: this value is dropped without further use\n+  --> $DIR/redundant_clone.rs:22:13\n+   |\n+22 |     let _ = s.to_string();\n+   |             ^\n+\n+error: redundant clone\n+  --> $DIR/redundant_clone.rs:25:14\n+   |\n+25 |     let _ = s.to_owned();\n+   |              ^^^^^^^^^^^ help: remove this\n+   |\n+note: this value is dropped without further use\n+  --> $DIR/redundant_clone.rs:25:13\n+   |\n+25 |     let _ = s.to_owned();\n+   |             ^\n+\n+error: redundant clone\n+  --> $DIR/redundant_clone.rs:27:41\n+   |\n+27 |     let _ = Path::new(\"/a/b/\").join(\"c\").to_owned();\n+   |                                         ^^^^^^^^^^^ help: remove this\n+   |\n+note: this value is dropped without further use\n+  --> $DIR/redundant_clone.rs:27:13\n+   |\n+27 |     let _ = Path::new(\"/a/b/\").join(\"c\").to_owned();\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: redundant clone\n+  --> $DIR/redundant_clone.rs:29:41\n+   |\n+29 |     let _ = Path::new(\"/a/b/\").join(\"c\").to_path_buf();\n+   |                                         ^^^^^^^^^^^^^^ help: remove this\n+   |\n+note: this value is dropped without further use\n+  --> $DIR/redundant_clone.rs:29:13\n+   |\n+29 |     let _ = Path::new(\"/a/b/\").join(\"c\").to_path_buf();\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: redundant clone\n+  --> $DIR/redundant_clone.rs:31:28\n+   |\n+31 |     let _ = OsString::new().to_owned();\n+   |                            ^^^^^^^^^^^ help: remove this\n+   |\n+note: this value is dropped without further use\n+  --> $DIR/redundant_clone.rs:31:13\n+   |\n+31 |     let _ = OsString::new().to_owned();\n+   |             ^^^^^^^^^^^^^^^\n+\n+error: redundant clone\n+  --> $DIR/redundant_clone.rs:33:28\n+   |\n+33 |     let _ = OsString::new().to_os_string();\n+   |                            ^^^^^^^^^^^^^^^ help: remove this\n+   |\n+note: this value is dropped without further use\n+  --> $DIR/redundant_clone.rs:33:13\n+   |\n+33 |     let _ = OsString::new().to_os_string();\n+   |             ^^^^^^^^^^^^^^^\n+\n+error: redundant clone\n+  --> $DIR/redundant_clone.rs:43:22\n+   |\n+43 |         (a.clone(), a.clone())\n+   |                      ^^^^^^^^ help: remove this\n+   |\n+note: this value is dropped without further use\n+  --> $DIR/redundant_clone.rs:43:21\n+   |\n+43 |         (a.clone(), a.clone())\n+   |                     ^\n+\n+error: aborting due to 9 previous errors\n+"}, {"sha": "073d64d5a4bf34aa943a0bab7e8b18b6d1af8eaa", "filename": "tests/ui/use_self.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/183e19a1c3de4b219b80c8871d83009d031d4b54/tests%2Fui%2Fuse_self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/183e19a1c3de4b219b80c8871d83009d031d4b54/tests%2Fui%2Fuse_self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fuse_self.rs?ref=183e19a1c3de4b219b80c8871d83009d031d4b54", "patch": "@@ -205,3 +205,17 @@ mod issue2894 {\n         }\n     }\n }\n+\n+mod existential {\n+    struct Foo;\n+\n+    impl Foo {\n+        fn bad(foos: &[Self]) -> impl Iterator<Item=&Foo> {\n+            foos.iter()\n+        }\n+\n+        fn good(foos: &[Self]) -> impl Iterator<Item=&Self> {\n+            foos.iter()\n+        }\n+    }\n+}"}, {"sha": "b71c7a9a4c51bda39be0ac711fd2af80bdcde8c3", "filename": "tests/ui/use_self.stderr", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/183e19a1c3de4b219b80c8871d83009d031d4b54/tests%2Fui%2Fuse_self.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/183e19a1c3de4b219b80c8871d83009d031d4b54/tests%2Fui%2Fuse_self.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fuse_self.stderr?ref=183e19a1c3de4b219b80c8871d83009d031d4b54", "patch": "@@ -120,5 +120,11 @@ error: unnecessary structure name repetition\n 119 |         fn mul(self, rhs: Bad) -> Bad {\n     |                                   ^^^ help: use the applicable keyword: `Self`\n \n-error: aborting due to 20 previous errors\n+error: unnecessary structure name repetition\n+   --> $DIR/use_self.rs:213:54\n+    |\n+213 |         fn bad(foos: &[Self]) -> impl Iterator<Item=&Foo> {\n+    |                                                      ^^^ help: use the applicable keyword: `Self`\n+\n+error: aborting due to 21 previous errors\n "}]}