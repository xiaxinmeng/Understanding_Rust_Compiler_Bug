{"sha": "cbe429c7a5fba9f77d76f214a45c03b67a1328c1", "node_id": "C_kwDOAAsO6NoAKGNiZTQyOWM3YTVmYmE5Zjc3ZDc2ZjIxNGE0NWMwM2I2N2ExMzI4YzE", "commit": {"author": {"name": "Dylan DPC", "email": "99973273+Dylan-DPC@users.noreply.github.com", "date": "2023-06-07T12:31:28Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-06-07T12:31:28Z"}, "message": "Rollup merge of #112076 - compiler-errors:bidirectional-alias-eq, r=lcnr\n\nFall back to bidirectional normalizes-to if no subst-relate candidate in alias-relate goal\n\nSometimes we get into the case where the choice of normalizes-to branch in alias-relate are both valid, but we cannot make a choice of which one to take because they are different -- either returning equivalent but permuted region constraints, or equivalent opaque type definitions but differing modulo normalization.\n\nIn this case, we can make progress by considering a fourth candidate where we compute both normalizes-to branches together and canonicalize that as a response. This is essentially the AND intersection of both normalizes-to branches. In an ideal world, we'd be returning something more like the OR intersection of both branches, but we have no way of representing that either for regions (maybe eventually) or opaques (don't see that happening ever).\n\nThis is incomplete, so like the subst-relate fallback it's only considered outside of coherence. But it doesn't seem like a dramatic strengthening of inference or anything, and is useful for helping opaque type inference succeed when the hidden type is a projection.\n\n## Example\n\nConsider the goal - `AliasRelate(Tait, <[i32; 32] as IntoIterator>::IntoIter)`.\n\nWe have three ways of currently solving this goal:\n1. SubstRelate - fails because we can't directly equate the substs of different alias kinds.\n2. NormalizesToRhs - `Tait normalizes-to <[i32; 32] as IntoIterator>::IntoIter`\n    * Ends up infering opaque definition - `Tait := <[i32; 32] as IntoIterator>::IntoIter`\n3. NormalizesToLhs - `<[i32; 32] as IntoIterator>::IntoIter normalizes-to Tait`\n    * Find impl candidate, substitute the associated type - `std::array::IntoIter<i32, 32>`\n    * Equate `std::array::IntoIter<i32, 32>` and `Tait`\n        * Ends up infering opaque definition - `Tait := std::array::IntoIter<i32, 32>`\n\nThe problem here is that 2 and 3 are essentially both valid, since we have aliases that normalize on both sides, but due to lazy norm, they end up inferring different opaque type definitions that are only equal *after* normalizing them further.\n\n---\n\nr? `@lcnr`", "tree": {"sha": "63239b37325b12270d1045d99d729f24ab405dd4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/63239b37325b12270d1045d99d729f24ab405dd4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cbe429c7a5fba9f77d76f214a45c03b67a1328c1", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJkgHigCRBK7hj4Ov3rIwAAXdcIAI/y6j5u/JokMQAO+0JZvu0D\n8nmaeXMhYc5qhWYZzHS7wXsEUMVHlPXo/jOXixm/E6ix20iSBAZNG1SUqiY3sq/8\nRVEbMFEAAULBcxkDsq7eXKiJVjOyXdkoigNOBFOLo4IszoB+QBFmYbpVVoAu7Zz6\nK3HK0gde1//pko26k7vUbMjVt+7fwfqnoblQ83Jo2gCiN4LYonzINAUtFsuMNwUU\nfMo4+w4GmHzQAGo2KT9Ic5hu9LlvgoaZLX1LK+ENnfzjH7+DXrdFnmD6NBaF0rT6\noFy9rdG+Wd9L5UbXOnQ/OrqKy/26nitVb4oIdZFOl/cn156smt9PdzAm0E5VNTU=\n=FhsQ\n-----END PGP SIGNATURE-----\n", "payload": "tree 63239b37325b12270d1045d99d729f24ab405dd4\nparent e94bda3bf13303671427363d1cd93ac5e089f090\nparent 3ea7c512bd1587006a1c196df841e9b7ec60fb0b\nauthor Dylan DPC <99973273+Dylan-DPC@users.noreply.github.com> 1686141088 +0530\ncommitter GitHub <noreply@github.com> 1686141088 +0530\n\nRollup merge of #112076 - compiler-errors:bidirectional-alias-eq, r=lcnr\n\nFall back to bidirectional normalizes-to if no subst-relate candidate in alias-relate goal\n\nSometimes we get into the case where the choice of normalizes-to branch in alias-relate are both valid, but we cannot make a choice of which one to take because they are different -- either returning equivalent but permuted region constraints, or equivalent opaque type definitions but differing modulo normalization.\n\nIn this case, we can make progress by considering a fourth candidate where we compute both normalizes-to branches together and canonicalize that as a response. This is essentially the AND intersection of both normalizes-to branches. In an ideal world, we'd be returning something more like the OR intersection of both branches, but we have no way of representing that either for regions (maybe eventually) or opaques (don't see that happening ever).\n\nThis is incomplete, so like the subst-relate fallback it's only considered outside of coherence. But it doesn't seem like a dramatic strengthening of inference or anything, and is useful for helping opaque type inference succeed when the hidden type is a projection.\n\n## Example\n\nConsider the goal - `AliasRelate(Tait, <[i32; 32] as IntoIterator>::IntoIter)`.\n\nWe have three ways of currently solving this goal:\n1. SubstRelate - fails because we can't directly equate the substs of different alias kinds.\n2. NormalizesToRhs - `Tait normalizes-to <[i32; 32] as IntoIterator>::IntoIter`\n    * Ends up infering opaque definition - `Tait := <[i32; 32] as IntoIterator>::IntoIter`\n3. NormalizesToLhs - `<[i32; 32] as IntoIterator>::IntoIter normalizes-to Tait`\n    * Find impl candidate, substitute the associated type - `std::array::IntoIter<i32, 32>`\n    * Equate `std::array::IntoIter<i32, 32>` and `Tait`\n        * Ends up infering opaque definition - `Tait := std::array::IntoIter<i32, 32>`\n\nThe problem here is that 2 and 3 are essentially both valid, since we have aliases that normalize on both sides, but due to lazy norm, they end up inferring different opaque type definitions that are only equal *after* normalizing them further.\n\n---\n\nr? `@lcnr`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cbe429c7a5fba9f77d76f214a45c03b67a1328c1", "html_url": "https://github.com/rust-lang/rust/commit/cbe429c7a5fba9f77d76f214a45c03b67a1328c1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cbe429c7a5fba9f77d76f214a45c03b67a1328c1/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e94bda3bf13303671427363d1cd93ac5e089f090", "url": "https://api.github.com/repos/rust-lang/rust/commits/e94bda3bf13303671427363d1cd93ac5e089f090", "html_url": "https://github.com/rust-lang/rust/commit/e94bda3bf13303671427363d1cd93ac5e089f090"}, {"sha": "3ea7c512bd1587006a1c196df841e9b7ec60fb0b", "url": "https://api.github.com/repos/rust-lang/rust/commits/3ea7c512bd1587006a1c196df841e9b7ec60fb0b", "html_url": "https://github.com/rust-lang/rust/commit/3ea7c512bd1587006a1c196df841e9b7ec60fb0b"}], "stats": {"total": 405, "additions": 269, "deletions": 136}, "files": [{"sha": "66a4d36a1e5a7b0628c4e429025ce8c5b84bf594", "filename": "compiler/rustc_trait_selection/src/solve/alias_relate.rs", "status": "added", "additions": 195, "deletions": 0, "changes": 195, "blob_url": "https://github.com/rust-lang/rust/blob/cbe429c7a5fba9f77d76f214a45c03b67a1328c1/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Falias_relate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbe429c7a5fba9f77d76f214a45c03b67a1328c1/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Falias_relate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Falias_relate.rs?ref=cbe429c7a5fba9f77d76f214a45c03b67a1328c1", "patch": "@@ -0,0 +1,195 @@\n+use super::{EvalCtxt, SolverMode};\n+use rustc_infer::traits::query::NoSolution;\n+use rustc_middle::traits::solve::{Certainty, Goal, QueryResult};\n+use rustc_middle::ty;\n+\n+/// We may need to invert the alias relation direction if dealing an alias on the RHS.\n+#[derive(Debug)]\n+enum Invert {\n+    No,\n+    Yes,\n+}\n+\n+impl<'tcx> EvalCtxt<'_, 'tcx> {\n+    #[instrument(level = \"debug\", skip(self), ret)]\n+    pub(super) fn compute_alias_relate_goal(\n+        &mut self,\n+        goal: Goal<'tcx, (ty::Term<'tcx>, ty::Term<'tcx>, ty::AliasRelationDirection)>,\n+    ) -> QueryResult<'tcx> {\n+        let tcx = self.tcx();\n+        let Goal { param_env, predicate: (lhs, rhs, direction) } = goal;\n+        if lhs.is_infer() || rhs.is_infer() {\n+            bug!(\n+                \"`AliasRelate` goal with an infer var on lhs or rhs which should have been instantiated\"\n+            );\n+        }\n+\n+        match (lhs.to_alias_ty(tcx), rhs.to_alias_ty(tcx)) {\n+            (None, None) => bug!(\"`AliasRelate` goal without an alias on either lhs or rhs\"),\n+\n+            // RHS is not a projection, only way this is true is if LHS normalizes-to RHS\n+            (Some(alias_lhs), None) => self.assemble_normalizes_to_candidate(\n+                param_env,\n+                alias_lhs,\n+                rhs,\n+                direction,\n+                Invert::No,\n+            ),\n+\n+            // LHS is not a projection, only way this is true is if RHS normalizes-to LHS\n+            (None, Some(alias_rhs)) => self.assemble_normalizes_to_candidate(\n+                param_env,\n+                alias_rhs,\n+                lhs,\n+                direction,\n+                Invert::Yes,\n+            ),\n+\n+            (Some(alias_lhs), Some(alias_rhs)) => {\n+                debug!(\"both sides are aliases\");\n+\n+                let mut candidates = Vec::new();\n+                // LHS normalizes-to RHS\n+                candidates.extend(self.assemble_normalizes_to_candidate(\n+                    param_env,\n+                    alias_lhs,\n+                    rhs,\n+                    direction,\n+                    Invert::No,\n+                ));\n+                // RHS normalizes-to RHS\n+                candidates.extend(self.assemble_normalizes_to_candidate(\n+                    param_env,\n+                    alias_rhs,\n+                    lhs,\n+                    direction,\n+                    Invert::Yes,\n+                ));\n+                // Relate via substs\n+                let subst_relate_response = self\n+                    .assemble_subst_relate_candidate(param_env, alias_lhs, alias_rhs, direction);\n+                candidates.extend(subst_relate_response);\n+                debug!(?candidates);\n+\n+                if let Some(merged) = self.try_merge_responses(&candidates) {\n+                    Ok(merged)\n+                } else {\n+                    // When relating two aliases and we have ambiguity, we prefer\n+                    // relating the generic arguments of the aliases over normalizing\n+                    // them. This is necessary for inference during typeck.\n+                    //\n+                    // As this is incomplete, we must not do so during coherence.\n+                    match self.solver_mode() {\n+                        SolverMode::Normal => {\n+                            if let Ok(subst_relate_response) = subst_relate_response {\n+                                Ok(subst_relate_response)\n+                            } else if let Ok(bidirectional_normalizes_to_response) = self\n+                                .assemble_bidirectional_normalizes_to_candidate(\n+                                    param_env, lhs, rhs, direction,\n+                                )\n+                            {\n+                                Ok(bidirectional_normalizes_to_response)\n+                            } else {\n+                                self.flounder(&candidates)\n+                            }\n+                        }\n+                        SolverMode::Coherence => self.flounder(&candidates),\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    #[instrument(level = \"debug\", skip(self), ret)]\n+    fn assemble_normalizes_to_candidate(\n+        &mut self,\n+        param_env: ty::ParamEnv<'tcx>,\n+        alias: ty::AliasTy<'tcx>,\n+        other: ty::Term<'tcx>,\n+        direction: ty::AliasRelationDirection,\n+        invert: Invert,\n+    ) -> QueryResult<'tcx> {\n+        self.probe(|ecx| {\n+            ecx.normalizes_to_inner(param_env, alias, other, direction, invert)?;\n+            ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n+        })\n+    }\n+\n+    fn normalizes_to_inner(\n+        &mut self,\n+        param_env: ty::ParamEnv<'tcx>,\n+        alias: ty::AliasTy<'tcx>,\n+        other: ty::Term<'tcx>,\n+        direction: ty::AliasRelationDirection,\n+        invert: Invert,\n+    ) -> Result<(), NoSolution> {\n+        let other = match direction {\n+            // This is purely an optimization.\n+            ty::AliasRelationDirection::Equate => other,\n+\n+            ty::AliasRelationDirection::Subtype => {\n+                let fresh = self.next_term_infer_of_kind(other);\n+                let (sub, sup) = match invert {\n+                    Invert::No => (fresh, other),\n+                    Invert::Yes => (other, fresh),\n+                };\n+                self.sub(param_env, sub, sup)?;\n+                fresh\n+            }\n+        };\n+        self.add_goal(Goal::new(\n+            self.tcx(),\n+            param_env,\n+            ty::Binder::dummy(ty::ProjectionPredicate { projection_ty: alias, term: other }),\n+        ));\n+\n+        Ok(())\n+    }\n+\n+    fn assemble_subst_relate_candidate(\n+        &mut self,\n+        param_env: ty::ParamEnv<'tcx>,\n+        alias_lhs: ty::AliasTy<'tcx>,\n+        alias_rhs: ty::AliasTy<'tcx>,\n+        direction: ty::AliasRelationDirection,\n+    ) -> QueryResult<'tcx> {\n+        self.probe(|ecx| {\n+            match direction {\n+                ty::AliasRelationDirection::Equate => {\n+                    ecx.eq(param_env, alias_lhs, alias_rhs)?;\n+                }\n+                ty::AliasRelationDirection::Subtype => {\n+                    ecx.sub(param_env, alias_lhs, alias_rhs)?;\n+                }\n+            }\n+\n+            ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n+        })\n+    }\n+\n+    fn assemble_bidirectional_normalizes_to_candidate(\n+        &mut self,\n+        param_env: ty::ParamEnv<'tcx>,\n+        lhs: ty::Term<'tcx>,\n+        rhs: ty::Term<'tcx>,\n+        direction: ty::AliasRelationDirection,\n+    ) -> QueryResult<'tcx> {\n+        self.probe(|ecx| {\n+            ecx.normalizes_to_inner(\n+                param_env,\n+                lhs.to_alias_ty(ecx.tcx()).unwrap(),\n+                rhs,\n+                direction,\n+                Invert::No,\n+            )?;\n+            ecx.normalizes_to_inner(\n+                param_env,\n+                rhs.to_alias_ty(ecx.tcx()).unwrap(),\n+                lhs,\n+                direction,\n+                Invert::Yes,\n+            )?;\n+            ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n+        })\n+    }\n+}"}, {"sha": "f4c29c837b8841a5ec71ef21079dfc350f94d3a1", "filename": "compiler/rustc_trait_selection/src/solve/mod.rs", "status": "modified", "additions": 1, "deletions": 136, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/cbe429c7a5fba9f77d76f214a45c03b67a1328c1/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbe429c7a5fba9f77d76f214a45c03b67a1328c1/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs?ref=cbe429c7a5fba9f77d76f214a45c03b67a1328c1", "patch": "@@ -20,6 +20,7 @@ use rustc_middle::ty::{\n     CoercePredicate, RegionOutlivesPredicate, SubtypePredicate, TypeOutlivesPredicate,\n };\n \n+mod alias_relate;\n mod assembly;\n mod canonicalize;\n mod eval_ctxt;\n@@ -154,142 +155,6 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n         }\n     }\n \n-    #[instrument(level = \"debug\", skip(self), ret)]\n-    fn compute_alias_relate_goal(\n-        &mut self,\n-        goal: Goal<'tcx, (ty::Term<'tcx>, ty::Term<'tcx>, ty::AliasRelationDirection)>,\n-    ) -> QueryResult<'tcx> {\n-        let tcx = self.tcx();\n-        // We may need to invert the alias relation direction if dealing an alias on the RHS.\n-        #[derive(Debug)]\n-        enum Invert {\n-            No,\n-            Yes,\n-        }\n-        let evaluate_normalizes_to =\n-            |ecx: &mut EvalCtxt<'_, 'tcx>, alias, other, direction, invert| {\n-                let span = tracing::span!(\n-                    tracing::Level::DEBUG,\n-                    \"compute_alias_relate_goal(evaluate_normalizes_to)\",\n-                    ?alias,\n-                    ?other,\n-                    ?direction,\n-                    ?invert\n-                );\n-                let _enter = span.enter();\n-                let result = ecx.probe(|ecx| {\n-                    let other = match direction {\n-                        // This is purely an optimization.\n-                        ty::AliasRelationDirection::Equate => other,\n-\n-                        ty::AliasRelationDirection::Subtype => {\n-                            let fresh = ecx.next_term_infer_of_kind(other);\n-                            let (sub, sup) = match invert {\n-                                Invert::No => (fresh, other),\n-                                Invert::Yes => (other, fresh),\n-                            };\n-                            ecx.sub(goal.param_env, sub, sup)?;\n-                            fresh\n-                        }\n-                    };\n-                    ecx.add_goal(goal.with(\n-                        tcx,\n-                        ty::Binder::dummy(ty::ProjectionPredicate {\n-                            projection_ty: alias,\n-                            term: other,\n-                        }),\n-                    ));\n-                    ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n-                });\n-                debug!(?result);\n-                result\n-            };\n-\n-        let (lhs, rhs, direction) = goal.predicate;\n-\n-        if lhs.is_infer() || rhs.is_infer() {\n-            bug!(\n-                \"`AliasRelate` goal with an infer var on lhs or rhs which should have been instantiated\"\n-            );\n-        }\n-\n-        match (lhs.to_alias_ty(tcx), rhs.to_alias_ty(tcx)) {\n-            (None, None) => bug!(\"`AliasRelate` goal without an alias on either lhs or rhs\"),\n-\n-            // RHS is not a projection, only way this is true is if LHS normalizes-to RHS\n-            (Some(alias_lhs), None) => {\n-                evaluate_normalizes_to(self, alias_lhs, rhs, direction, Invert::No)\n-            }\n-\n-            // LHS is not a projection, only way this is true is if RHS normalizes-to LHS\n-            (None, Some(alias_rhs)) => {\n-                evaluate_normalizes_to(self, alias_rhs, lhs, direction, Invert::Yes)\n-            }\n-\n-            (Some(alias_lhs), Some(alias_rhs)) => {\n-                debug!(\"both sides are aliases\");\n-\n-                let mut candidates = Vec::new();\n-                // LHS normalizes-to RHS\n-                candidates.extend(evaluate_normalizes_to(\n-                    self,\n-                    alias_lhs,\n-                    rhs,\n-                    direction,\n-                    Invert::No,\n-                ));\n-                // RHS normalizes-to RHS\n-                candidates.extend(evaluate_normalizes_to(\n-                    self,\n-                    alias_rhs,\n-                    lhs,\n-                    direction,\n-                    Invert::Yes,\n-                ));\n-                // Relate via substs\n-                let subst_relate_response = self.probe(|ecx| {\n-                    let span = tracing::span!(\n-                        tracing::Level::DEBUG,\n-                        \"compute_alias_relate_goal(relate_via_substs)\",\n-                        ?alias_lhs,\n-                        ?alias_rhs,\n-                        ?direction\n-                    );\n-                    let _enter = span.enter();\n-\n-                    match direction {\n-                        ty::AliasRelationDirection::Equate => {\n-                            ecx.eq(goal.param_env, alias_lhs, alias_rhs)?;\n-                        }\n-                        ty::AliasRelationDirection::Subtype => {\n-                            ecx.sub(goal.param_env, alias_lhs, alias_rhs)?;\n-                        }\n-                    }\n-\n-                    ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n-                });\n-                candidates.extend(subst_relate_response);\n-                debug!(?candidates);\n-\n-                if let Some(merged) = self.try_merge_responses(&candidates) {\n-                    Ok(merged)\n-                } else {\n-                    // When relating two aliases and we have ambiguity, we prefer\n-                    // relating the generic arguments of the aliases over normalizing\n-                    // them. This is necessary for inference during typeck.\n-                    //\n-                    // As this is incomplete, we must not do so during coherence.\n-                    match (self.solver_mode(), subst_relate_response) {\n-                        (SolverMode::Normal, Ok(response)) => Ok(response),\n-                        (SolverMode::Normal, Err(NoSolution)) | (SolverMode::Coherence, _) => {\n-                            self.flounder(&candidates)\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n     #[instrument(level = \"debug\", skip(self), ret)]\n     fn compute_const_arg_has_type_goal(\n         &mut self,"}, {"sha": "99a3d02bd1aeae101b641c99bc084e0e4b8cabec", "filename": "tests/ui/traits/new-solver/tait-eq-proj-2.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/cbe429c7a5fba9f77d76f214a45c03b67a1328c1/tests%2Fui%2Ftraits%2Fnew-solver%2Ftait-eq-proj-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbe429c7a5fba9f77d76f214a45c03b67a1328c1/tests%2Fui%2Ftraits%2Fnew-solver%2Ftait-eq-proj-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnew-solver%2Ftait-eq-proj-2.rs?ref=cbe429c7a5fba9f77d76f214a45c03b67a1328c1", "patch": "@@ -0,0 +1,21 @@\n+// compile-flags: -Ztrait-solver=next\n+// check-pass\n+\n+#![feature(type_alias_impl_trait)]\n+\n+// Similar to tests/ui/traits/new-solver/tait-eq-proj.rs\n+// but check the alias-sub relation in the other direction.\n+\n+type Tait = impl Iterator<Item = impl Sized>;\n+\n+fn mk<T>() -> T { todo!() }\n+\n+fn a() {\n+    let x: Tait = mk();\n+    let mut array = mk();\n+    let mut z = IntoIterator::into_iter(array);\n+    z = x;\n+    array = [0i32; 32];\n+}\n+\n+fn main() {}"}, {"sha": "01141b2819a8d5af026f6f248ecc627a9f6a3a6f", "filename": "tests/ui/traits/new-solver/tait-eq-proj.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/cbe429c7a5fba9f77d76f214a45c03b67a1328c1/tests%2Fui%2Ftraits%2Fnew-solver%2Ftait-eq-proj.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbe429c7a5fba9f77d76f214a45c03b67a1328c1/tests%2Fui%2Ftraits%2Fnew-solver%2Ftait-eq-proj.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnew-solver%2Ftait-eq-proj.rs?ref=cbe429c7a5fba9f77d76f214a45c03b67a1328c1", "patch": "@@ -0,0 +1,35 @@\n+// compile-flags: -Ztrait-solver=next\n+// check-pass\n+\n+#![feature(type_alias_impl_trait)]\n+\n+type Tait = impl Iterator<Item = impl Sized>;\n+\n+/*\n+\n+Consider the goal - AliasRelate(Tait, <[i32; 32] as IntoIterator>::IntoIter)\n+which is registered on the line above.\n+\n+A. SubstRelate - fails (of course).\n+\n+B. NormalizesToRhs - Tait normalizes-to <[i32; 32] as IntoIterator>::IntoIter\n+    * infer definition - Tait := <[i32; 32] as IntoIterator>::IntoIter\n+\n+C. NormalizesToLhs - <[i32; 32] as IntoIterator>::IntoIter normalizes-to Tait\n+    * Find impl candidate, after substitute - std::array::IntoIter<i32, 32>\n+    * Equate std::array::IntoIter<i32, 32> and Tait\n+        * infer definition - Tait := std::array::IntoIter<i32, 32>\n+\n+B and C are not equal, but they are equivalent modulo normalization.\n+\n+We get around this by evaluating both the NormalizesToRhs and NormalizesToLhs\n+goals together. Essentially:\n+    A alias-relate B if A normalizes-to B and B normalizes-to A.\n+\n+*/\n+\n+fn a() {\n+    let _: Tait = IntoIterator::into_iter([0i32; 32]);\n+}\n+\n+fn main() {}"}, {"sha": "532c4c39bd499f79e75f766523126522d65345fd", "filename": "tests/ui/traits/new-solver/tait-eq-tait.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/cbe429c7a5fba9f77d76f214a45c03b67a1328c1/tests%2Fui%2Ftraits%2Fnew-solver%2Ftait-eq-tait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbe429c7a5fba9f77d76f214a45c03b67a1328c1/tests%2Fui%2Ftraits%2Fnew-solver%2Ftait-eq-tait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnew-solver%2Ftait-eq-tait.rs?ref=cbe429c7a5fba9f77d76f214a45c03b67a1328c1", "patch": "@@ -0,0 +1,17 @@\n+// compile-flags: -Ztrait-solver=next\n+// check-pass\n+\n+// Not exactly sure if this is the inference behavior we *want*,\n+// but it is a side-effect of the lazy normalization of TAITs.\n+\n+#![feature(type_alias_impl_trait)]\n+\n+type Tait = impl Sized;\n+type Tait2 = impl Sized;\n+\n+fn mk<T>() -> T { todo!() }\n+\n+fn main() {\n+    let x: Tait = 1u32;\n+    let y: Tait2 = x;\n+}"}]}