{"sha": "f64c23fdfd2a6c22d809d573f3db91ec2677952e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY2NGMyM2ZkZmQyYTZjMjJkODA5ZDU3M2YzZGI5MWVjMjY3Nzk1MmU=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-06-28T17:49:51Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-06-30T07:34:03Z"}, "message": "Descend into ty_boxes in type_use\n\ntype_use was failing to look into ty_boxes, which caused monomorphize\nto coalesce instances that shouldn't have been coalesced (because they\nshould actually use different type glue)\n\nCloses #2734", "tree": {"sha": "2974e907321841ff892665cb392d12bdefad0ee1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2974e907321841ff892665cb392d12bdefad0ee1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f64c23fdfd2a6c22d809d573f3db91ec2677952e", "comment_count": 4, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f64c23fdfd2a6c22d809d573f3db91ec2677952e", "html_url": "https://github.com/rust-lang/rust/commit/f64c23fdfd2a6c22d809d573f3db91ec2677952e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f64c23fdfd2a6c22d809d573f3db91ec2677952e/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "328fd30cf4c0f34ad6ea97d8a1468935d0a60101", "url": "https://api.github.com/repos/rust-lang/rust/commits/328fd30cf4c0f34ad6ea97d8a1468935d0a60101", "html_url": "https://github.com/rust-lang/rust/commit/328fd30cf4c0f34ad6ea97d8a1468935d0a60101"}], "stats": {"total": 71, "additions": 46, "deletions": 25}, "files": [{"sha": "2978cd04b96eec7f7a33bf7fc283976cf19b61cf", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 26, "deletions": 22, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/f64c23fdfd2a6c22d809d573f3db91ec2677952e/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f64c23fdfd2a6c22d809d573f3db91ec2677952e/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=f64c23fdfd2a6c22d809d573f3db91ec2677952e", "patch": "@@ -242,7 +242,7 @@ fn trans_free(cx: block, v: ValueRef) -> block {\n }\n \n fn trans_unique_free(cx: block, v: ValueRef) -> block {\n-    let _icx = cx.insn_ctxt(\"trans_shared_free\");\n+    let _icx = cx.insn_ctxt(\"trans_unique_free\");\n     Call(cx, cx.ccx().upcalls.exchange_free,\n          ~[PointerCast(cx, v, T_ptr(T_i8()))]);\n     ret cx;\n@@ -422,12 +422,12 @@ fn get_tydesc(ccx: @crate_ctxt, t: ty::t,\n \n fn get_static_tydesc(ccx: @crate_ctxt, t: ty::t) -> @tydesc_info {\n     alt ccx.tydescs.find(t) {\n-      some(inf) { ret inf; }\n-      none {\n+      some(inf) { inf }\n+      _ {\n         ccx.stats.n_static_tydescs += 1u;\n         let inf = declare_tydesc(ccx, t);\n         ccx.tydescs.insert(t, inf);\n-        ret inf;\n+        inf\n       }\n     }\n }\n@@ -490,16 +490,15 @@ fn note_unique_llvm_symbol(ccx: @crate_ctxt, sym: str) {\n // Generates the declaration for (but doesn't emit) a type descriptor.\n fn declare_tydesc(ccx: @crate_ctxt, t: ty::t) -> @tydesc_info {\n     let _icx = ccx.insn_ctxt(\"declare_tydesc\");\n-    log(debug, \"+++ declare_tydesc \" + ty_to_str(ccx.tcx, t));\n     let llty = type_of(ccx, t);\n     let llsize = llsize_of(ccx, llty);\n     let llalign = llalign_of(ccx, llty);\n-    let mut name;\n     //XXX this triggers duplicate LLVM symbols\n-    if false /*ccx.sess.opts.debuginfo*/ {\n-        name = mangle_internal_name_by_type_only(ccx, t, @\"tydesc\");\n-    } else { name = mangle_internal_name_by_seq(ccx, @\"tydesc\"); }\n+    let name = if false /*ccx.sess.opts.debuginfo*/ {\n+        mangle_internal_name_by_type_only(ccx, t, @\"tydesc\")\n+    } else { mangle_internal_name_by_seq(ccx, @\"tydesc\") };\n     note_unique_llvm_symbol(ccx, name);\n+    log(debug, #fmt(\"+++ declare_tydesc %s %s\", ty_to_str(ccx.tcx, t), name));\n     let gvar = str::as_c_str(name, {|buf|\n         llvm::LLVMAddGlobal(ccx.llmod, ccx.tydesc_type, buf)\n     });\n@@ -613,14 +612,14 @@ fn emit_tydescs(ccx: @crate_ctxt) {\n                             drop_glue, // drop_glue\n                             free_glue, // free_glue\n                             visit_glue, // visit_glue\n-                            C_int(ccx, 0), // ununsed\n-                            C_int(ccx, 0), // ununsed\n-                            C_int(ccx, 0), // ununsed\n-                            C_int(ccx, 0), // ununsed\n+                            C_int(ccx, 0), // unused\n+                            C_int(ccx, 0), // unused\n+                            C_int(ccx, 0), // unused\n+                            C_int(ccx, 0), // unused\n                             C_shape(ccx, shape), // shape\n                             shape_tables, // shape_tables\n-                            C_int(ccx, 0), // ununsed\n-                            C_int(ccx, 0)]); // unused\n+                            C_int(ccx, 0), // unused\n+                            C_int(ccx, 0)]/~); // unused\n \n         let gvar = ti.tydesc;\n         llvm::LLVMSetInitializer(gvar, tydesc);\n@@ -704,8 +703,10 @@ fn make_free_glue(bcx: block, v: ValueRef, t: ty::t) {\n       }\n       ty::ty_opaque_box {\n         let v = PointerCast(bcx, v, type_of(ccx, t));\n-        let td = Load(bcx, GEPi(bcx, v, ~[0u, abi::box_field_tydesc]));\n-        let valptr = GEPi(bcx, v, ~[0u, abi::box_field_body]);\n+        let td = Load(bcx, GEPi(bcx, v, [0u, abi::box_field_tydesc]/~));\n+        let valptr = GEPi(bcx, v, [0u, abi::box_field_body]/~);\n+        // Generate code that, dynamically, indexes into the\n+        // tydesc and calls the drop glue that got set dynamically\n         call_tydesc_glue_full(bcx, valptr, td, abi::tydesc_field_drop_glue,\n                               none);\n         trans_free(bcx, v)\n@@ -1194,6 +1195,7 @@ fn call_tydesc_glue_full(++cx: block, v: ValueRef, tydesc: ValueRef,\n     let llfn = {\n         alt static_glue_fn {\n           none {\n+            // Select out the glue function to call from the tydesc\n             let llfnptr = GEPi(cx, tydesc, ~[0u, field]);\n             Load(cx, llfnptr)\n           }\n@@ -2136,11 +2138,6 @@ fn monomorphic_fn(ccx: @crate_ctxt, fn_id: ast::def_id,\n         }\n     });\n \n-    #debug[\"monomorphic_fn(fn_id=%? (%s), real_substs=%?, substs=%?\",\n-           fn_id, ty::item_path_str(ccx.tcx, fn_id),\n-           real_substs.map({|s| ty_to_str(ccx.tcx, s)}),\n-           substs.map({|s| ty_to_str(ccx.tcx, s)})];\n-\n     for real_substs.each() {|s| assert !ty::type_has_params(s); };\n     for substs.each() {|s| assert !ty::type_has_params(s); };\n \n@@ -2150,6 +2147,13 @@ fn monomorphic_fn(ccx: @crate_ctxt, fn_id: ast::def_id,\n                 {|p| alt p { mono_precise(_, _) { false } _ { true } } }) {\n         must_cast = true;\n     }\n+\n+    #debug[\"monomorphic_fn(fn_id=%? (%s), real_substs=%?, substs=%?, \\\n+           hash_id = %?\",\n+           fn_id, ty::item_path_str(ccx.tcx, fn_id),\n+           real_substs.map({|s| ty_to_str(ccx.tcx, s)}),\n+           substs.map({|s| ty_to_str(ccx.tcx, s)}), hash_id];\n+\n     alt ccx.monomorphized.find(hash_id) {\n       some(val) {\n         ret {val: val, must_cast: must_cast};"}, {"sha": "20747a91f140a94f57fe13d8531a5dcb70564132", "filename": "src/rustc/middle/trans/type_use.rs", "status": "modified", "additions": 20, "deletions": 3, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/f64c23fdfd2a6c22d809d573f3db91ec2677952e/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f64c23fdfd2a6c22d809d573f3db91ec2677952e/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs?ref=f64c23fdfd2a6c22d809d573f3db91ec2677952e", "patch": "@@ -117,8 +117,14 @@ fn type_needs_inner(cx: ctx, use: uint, ty: ty::t,\n     ty::maybe_walk_ty(ty) {|ty|\n         if ty::type_has_params(ty) {\n             alt ty::get(ty).struct {\n-              ty::ty_fn(_) | ty::ty_ptr(_) | ty::ty_rptr(_, _) |\n-              ty::ty_box(_) | ty::ty_iface(_, _) { false }\n+                /*\n+                  This previously included ty_box -- that was wrong\n+                  because if we cast an @T to an iface (for example) and return\n+                  it, we depend on the drop glue for T (we have to write the\n+                  right tydesc into the result)\n+                 */\n+              ty::ty_fn(_) | ty::ty_ptr(_) | ty::ty_rptr(_, _)\n+               | ty::ty_iface(_, _) { false }\n               ty::ty_enum(did, substs) {\n                 if option::is_none(list::find(enums_seen, {|id| id == did})) {\n                     let seen = @cons(did, enums_seen);\n@@ -151,10 +157,21 @@ fn mark_for_expr(cx: ctx, e: @expr) {\n       expr_vec(_, _) |\n       expr_rec(_, _) | expr_tup(_) |\n       expr_unary(box(_), _) | expr_unary(uniq(_), _) |\n-      expr_cast(_, _) | expr_binary(add, _, _) |\n+      expr_binary(add, _, _) |\n       expr_copy(_) | expr_move(_, _) {\n         node_type_needs(cx, use_repr, e.id);\n       }\n+      expr_cast(base, _) {\n+        let result_t = ty::node_id_to_type(cx.ccx.tcx, e.id);\n+        alt ty::get(result_t).struct {\n+            ty::ty_iface(*) {\n+              // When we're casting to an iface, we need the\n+              // tydesc for the expr that's being cast.\n+              node_type_needs(cx, use_tydesc, base.id);\n+            }\n+            _ {}\n+        }\n+      }\n       expr_binary(op, lhs, _) {\n         alt op {\n           eq | lt | le | ne | ge | gt {"}]}