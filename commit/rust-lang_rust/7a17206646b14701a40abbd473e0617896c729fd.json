{"sha": "7a17206646b14701a40abbd473e0617896c729fd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdhMTcyMDY2NDZiMTQ3MDFhNDBhYmJkNDczZTA2MTc4OTZjNzI5ZmQ=", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-07-19T17:57:55Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-07-19T17:58:26Z"}, "message": "Add doc-link resolution test infra", "tree": {"sha": "dde8169b92f54a311b4290fa9768315859cd5bd3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dde8169b92f54a311b4290fa9768315859cd5bd3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7a17206646b14701a40abbd473e0617896c729fd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7a17206646b14701a40abbd473e0617896c729fd", "html_url": "https://github.com/rust-lang/rust/commit/7a17206646b14701a40abbd473e0617896c729fd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7a17206646b14701a40abbd473e0617896c729fd/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ea105f9396a9dab68e71efb06016b7c76c83ba7c", "url": "https://api.github.com/repos/rust-lang/rust/commits/ea105f9396a9dab68e71efb06016b7c76c83ba7c", "html_url": "https://github.com/rust-lang/rust/commit/ea105f9396a9dab68e71efb06016b7c76c83ba7c"}], "stats": {"total": 248, "additions": 179, "deletions": 69}, "files": [{"sha": "042bef3700fc4e35a40143ba79b4c0961e4bf562", "filename": "crates/ide/src/doc_links.rs", "status": "modified", "additions": 102, "deletions": 69, "changes": 171, "blob_url": "https://github.com/rust-lang/rust/blob/7a17206646b14701a40abbd473e0617896c729fd/crates%2Fide%2Fsrc%2Fdoc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a17206646b14701a40abbd473e0617896c729fd/crates%2Fide%2Fsrc%2Fdoc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fdoc_links.rs?ref=7a17206646b14701a40abbd473e0617896c729fd", "patch": "@@ -5,6 +5,8 @@ use std::{\n     iter::once,\n };\n \n+mod intra_doc_links;\n+\n use itertools::Itertools;\n use pulldown_cmark::{BrokenLink, CowStr, Event, InlineStr, LinkType, Options, Parser, Tag};\n use pulldown_cmark_to_cmark::{cmark_with_options, Options as CmarkOptions};\n@@ -21,7 +23,10 @@ use ide_db::{\n };\n use syntax::{ast, match_ast, AstNode, SyntaxKind::*, SyntaxNode, TextRange, T};\n \n-use crate::{FilePosition, Semantics};\n+use crate::{\n+    doc_links::intra_doc_links::{parse_intra_doc_link, strip_prefixes_suffixes},\n+    FilePosition, Semantics,\n+};\n \n pub(crate) type DocumentationLink = String;\n \n@@ -396,63 +401,6 @@ fn map_links<'e>(\n     })\n }\n \n-const TYPES: ([&str; 9], [&str; 0]) =\n-    ([\"type\", \"struct\", \"enum\", \"mod\", \"trait\", \"union\", \"module\", \"prim\", \"primitive\"], []);\n-const VALUES: ([&str; 8], [&str; 1]) =\n-    ([\"value\", \"function\", \"fn\", \"method\", \"const\", \"static\", \"mod\", \"module\"], [\"()\"]);\n-const MACROS: ([&str; 2], [&str; 1]) = ([\"macro\", \"derive\"], [\"!\"]);\n-\n-/// Extract the specified namespace from an intra-doc-link if one exists.\n-///\n-/// # Examples\n-///\n-/// * `struct MyStruct` -> (\"MyStruct\", `Namespace::Types`)\n-/// * `panic!` -> (\"panic\", `Namespace::Macros`)\n-/// * `fn@from_intra_spec` -> (\"from_intra_spec\", `Namespace::Values`)\n-fn parse_intra_doc_link(s: &str) -> (&str, Option<hir::Namespace>) {\n-    let s = s.trim_matches('`');\n-\n-    [\n-        (hir::Namespace::Types, (TYPES.0.iter(), TYPES.1.iter())),\n-        (hir::Namespace::Values, (VALUES.0.iter(), VALUES.1.iter())),\n-        (hir::Namespace::Macros, (MACROS.0.iter(), MACROS.1.iter())),\n-    ]\n-    .iter()\n-    .cloned()\n-    .find_map(|(ns, (mut prefixes, mut suffixes))| {\n-        if let Some(prefix) = prefixes.find(|&&prefix| {\n-            s.starts_with(prefix)\n-                && s.chars().nth(prefix.len()).map_or(false, |c| c == '@' || c == ' ')\n-        }) {\n-            Some((&s[prefix.len() + 1..], ns))\n-        } else {\n-            suffixes.find_map(|&suffix| s.strip_suffix(suffix).zip(Some(ns)))\n-        }\n-    })\n-    .map_or((s, None), |(s, ns)| (s, Some(ns)))\n-}\n-\n-fn strip_prefixes_suffixes(s: &str) -> &str {\n-    [\n-        (TYPES.0.iter(), TYPES.1.iter()),\n-        (VALUES.0.iter(), VALUES.1.iter()),\n-        (MACROS.0.iter(), MACROS.1.iter()),\n-    ]\n-    .iter()\n-    .cloned()\n-    .find_map(|(mut prefixes, mut suffixes)| {\n-        if let Some(prefix) = prefixes.find(|&&prefix| {\n-            s.starts_with(prefix)\n-                && s.chars().nth(prefix.len()).map_or(false, |c| c == '@' || c == ' ')\n-        }) {\n-            Some(&s[prefix.len() + 1..])\n-        } else {\n-            suffixes.find_map(|&suffix| s.strip_suffix(suffix))\n-        }\n-    })\n-    .unwrap_or(s)\n-}\n-\n /// Get the root URL for the documentation of a crate.\n ///\n /// ```\n@@ -537,10 +485,13 @@ fn get_symbol_fragment(db: &dyn HirDatabase, field_or_assoc: &FieldOrAssocItem)\n #[cfg(test)]\n mod tests {\n     use expect_test::{expect, Expect};\n+    use ide_db::base_db::FileRange;\n \n-    use crate::fixture;\n+    use crate::{display::TryToNav, fixture};\n \n-    fn check(ra_fixture: &str, expect: Expect) {\n+    use super::*;\n+\n+    fn check_external_docs(ra_fixture: &str, expect: Expect) {\n         let (analysis, position) = fixture::position(ra_fixture);\n         let url = analysis.external_docs(position).unwrap().expect(\"could not find url for symbol\");\n \n@@ -549,7 +500,7 @@ mod tests {\n \n     #[test]\n     fn test_doc_url_crate() {\n-        check(\n+        check_external_docs(\n             r#\"\n //- /main.rs crate:main deps:test\n use test$0::Foo;\n@@ -562,7 +513,7 @@ pub struct Foo;\n \n     #[test]\n     fn test_doc_url_struct() {\n-        check(\n+        check_external_docs(\n             r#\"\n pub struct Fo$0o;\n \"#,\n@@ -572,7 +523,7 @@ pub struct Fo$0o;\n \n     #[test]\n     fn test_doc_url_fn() {\n-        check(\n+        check_external_docs(\n             r#\"\n pub fn fo$0o() {}\n \"#,\n@@ -582,7 +533,7 @@ pub fn fo$0o() {}\n \n     #[test]\n     fn test_doc_url_inherent_method() {\n-        check(\n+        check_external_docs(\n             r#\"\n pub struct Foo;\n \n@@ -597,7 +548,7 @@ impl Foo {\n \n     #[test]\n     fn test_doc_url_trait_provided_method() {\n-        check(\n+        check_external_docs(\n             r#\"\n pub trait Bar {\n     fn met$0hod() {}\n@@ -610,7 +561,7 @@ pub trait Bar {\n \n     #[test]\n     fn test_doc_url_trait_required_method() {\n-        check(\n+        check_external_docs(\n             r#\"\n pub trait Foo {\n     fn met$0hod();\n@@ -623,7 +574,7 @@ pub trait Foo {\n \n     #[test]\n     fn test_doc_url_field() {\n-        check(\n+        check_external_docs(\n             r#\"\n pub struct Foo {\n     pub fie$0ld: ()\n@@ -636,7 +587,7 @@ pub struct Foo {\n \n     #[test]\n     fn test_module() {\n-        check(\n+        check_external_docs(\n             r#\"\n pub mod foo {\n     pub mod ba$0r {}\n@@ -655,7 +606,7 @@ pub mod foo {\n         //\n         // That is, we should point inside the module, rather than at the\n         // re-export.\n-        check(\n+        check_external_docs(\n             r#\"\n pub mod wrapper {\n     pub use module::Item;\n@@ -672,4 +623,86 @@ fn foo() {\n             expect![[r#\"https://docs.rs/test/*/test/wrapper/struct.Item.html\"#]],\n         )\n     }\n+\n+    fn check_doc_links(ra_fixture: &str) {\n+        fn node_to_def(\n+            sema: &Semantics<RootDatabase>,\n+            node: &SyntaxNode,\n+        ) -> Option<Option<(Option<hir::Documentation>, Definition)>> {\n+            Some(match_ast! {\n+                match node {\n+                    ast::SourceFile(it)  => sema.to_def(&it).map(|def| (def.docs(sema.db), Definition::ModuleDef(hir::ModuleDef::Module(def)))),\n+                    ast::Module(it)      => sema.to_def(&it).map(|def| (def.docs(sema.db), Definition::ModuleDef(hir::ModuleDef::Module(def)))),\n+                    ast::Fn(it)          => sema.to_def(&it).map(|def| (def.docs(sema.db), Definition::ModuleDef(hir::ModuleDef::Function(def)))),\n+                    ast::Struct(it)      => sema.to_def(&it).map(|def| (def.docs(sema.db), Definition::ModuleDef(hir::ModuleDef::Adt(hir::Adt::Struct(def))))),\n+                    ast::Union(it)       => sema.to_def(&it).map(|def| (def.docs(sema.db), Definition::ModuleDef(hir::ModuleDef::Adt(hir::Adt::Union(def))))),\n+                    ast::Enum(it)        => sema.to_def(&it).map(|def| (def.docs(sema.db), Definition::ModuleDef(hir::ModuleDef::Adt(hir::Adt::Enum(def))))),\n+                    ast::Variant(it)     => sema.to_def(&it).map(|def| (def.docs(sema.db), Definition::ModuleDef(hir::ModuleDef::Variant(def)))),\n+                    ast::Trait(it)       => sema.to_def(&it).map(|def| (def.docs(sema.db), Definition::ModuleDef(hir::ModuleDef::Trait(def)))),\n+                    ast::Static(it)      => sema.to_def(&it).map(|def| (def.docs(sema.db), Definition::ModuleDef(hir::ModuleDef::Static(def)))),\n+                    ast::Const(it)       => sema.to_def(&it).map(|def| (def.docs(sema.db), Definition::ModuleDef(hir::ModuleDef::Const(def)))),\n+                    ast::TypeAlias(it)   => sema.to_def(&it).map(|def| (def.docs(sema.db), Definition::ModuleDef(hir::ModuleDef::TypeAlias(def)))),\n+                    ast::Impl(it)        => sema.to_def(&it).map(|def| (def.docs(sema.db), Definition::SelfType(def))),\n+                    ast::RecordField(it) => sema.to_def(&it).map(|def| (def.docs(sema.db), Definition::Field(def))),\n+                    ast::TupleField(it)  => sema.to_def(&it).map(|def| (def.docs(sema.db), Definition::Field(def))),\n+                    ast::Macro(it)       => sema.to_def(&it).map(|def| (def.docs(sema.db), Definition::Macro(def))),\n+                    // ast::Use(it) => sema.to_def(&it).map(|def| (Box::new(it) as _, def.attrs(sema.db))),\n+                    _ => return None,\n+                }\n+            })\n+        }\n+        let key_fn = |&(FileRange { file_id, range }, _): &_| (file_id, range.start());\n+\n+        let (analysis, position, mut expected) = fixture::annotations(ra_fixture);\n+        expected.sort_by_key(key_fn);\n+        let sema = &Semantics::new(&*analysis.db);\n+        let (docs, cursor_def) = sema\n+            .parse(position.file_id)\n+            .syntax()\n+            .token_at_offset(position.offset)\n+            .next()\n+            .unwrap()\n+            .ancestors()\n+            .find_map(|it| node_to_def(sema, &it))\n+            .expect(\"no def found\")\n+            .unwrap();\n+        let docs = docs.expect(\"no docs found for cursor def\");\n+        let defs = extract_definitions_from_markdown(docs.as_str());\n+        let actual: Vec<_> = defs\n+            .into_iter()\n+            .map(|(_, link, ns)| {\n+                let def = resolve_doc_path_for_def(sema.db, cursor_def, &link, ns)\n+                    .unwrap_or_else(|| panic!(\"Failed to resolve {}\", link));\n+                let nav_target = def.try_to_nav(sema.db).unwrap();\n+                let range = FileRange {\n+                    file_id: nav_target.file_id,\n+                    range: nav_target.focus_or_full_range(),\n+                };\n+                (range, link)\n+            })\n+            .sorted_by_key(key_fn)\n+            .collect();\n+        assert_eq!(expected, actual);\n+    }\n+\n+    #[test]\n+    fn test_trait_items() {\n+        check_doc_links(\n+            r#\"\n+/// [`Trait`]\n+/// [`Trait::Type`]\n+/// [`Trait::CONST`]\n+/// [`Trait::func`]\n+trait Trait$0 {\n+   // ^^^^^ Trait\n+    type Type;\n+      // ^^^^ Trait::Type\n+    const CONST: usize;\n+       // ^^^^^ Trait::CONST\n+    fn func();\n+    // ^^^^ Trait::func\n+}\n+        \"#,\n+        )\n+    }\n }"}, {"sha": "c6a090a060d5ab881aac8cb20b71165416c9d605", "filename": "crates/ide/src/doc_links/intra_doc_links.rs", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/7a17206646b14701a40abbd473e0617896c729fd/crates%2Fide%2Fsrc%2Fdoc_links%2Fintra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a17206646b14701a40abbd473e0617896c729fd/crates%2Fide%2Fsrc%2Fdoc_links%2Fintra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fdoc_links%2Fintra_doc_links.rs?ref=7a17206646b14701a40abbd473e0617896c729fd", "patch": "@@ -0,0 +1,77 @@\n+const TYPES: ([&str; 9], [&str; 0]) =\n+    ([\"type\", \"struct\", \"enum\", \"mod\", \"trait\", \"union\", \"module\", \"prim\", \"primitive\"], []);\n+const VALUES: ([&str; 8], [&str; 1]) =\n+    ([\"value\", \"function\", \"fn\", \"method\", \"const\", \"static\", \"mod\", \"module\"], [\"()\"]);\n+const MACROS: ([&str; 2], [&str; 1]) = ([\"macro\", \"derive\"], [\"!\"]);\n+\n+/// Extract the specified namespace from an intra-doc-link if one exists.\n+///\n+/// # Examples\n+///\n+/// * `struct MyStruct` -> (\"MyStruct\", `Namespace::Types`)\n+/// * `panic!` -> (\"panic\", `Namespace::Macros`)\n+/// * `fn@from_intra_spec` -> (\"from_intra_spec\", `Namespace::Values`)\n+pub(super) fn parse_intra_doc_link(s: &str) -> (&str, Option<hir::Namespace>) {\n+    let s = s.trim_matches('`');\n+\n+    [\n+        (hir::Namespace::Types, (TYPES.0.iter(), TYPES.1.iter())),\n+        (hir::Namespace::Values, (VALUES.0.iter(), VALUES.1.iter())),\n+        (hir::Namespace::Macros, (MACROS.0.iter(), MACROS.1.iter())),\n+    ]\n+    .iter()\n+    .cloned()\n+    .find_map(|(ns, (mut prefixes, mut suffixes))| {\n+        if let Some(prefix) = prefixes.find(|&&prefix| {\n+            s.starts_with(prefix)\n+                && s.chars().nth(prefix.len()).map_or(false, |c| c == '@' || c == ' ')\n+        }) {\n+            Some((&s[prefix.len() + 1..], ns))\n+        } else {\n+            suffixes.find_map(|&suffix| s.strip_suffix(suffix).zip(Some(ns)))\n+        }\n+    })\n+    .map_or((s, None), |(s, ns)| (s, Some(ns)))\n+}\n+\n+pub(super) fn strip_prefixes_suffixes(s: &str) -> &str {\n+    [\n+        (TYPES.0.iter(), TYPES.1.iter()),\n+        (VALUES.0.iter(), VALUES.1.iter()),\n+        (MACROS.0.iter(), MACROS.1.iter()),\n+    ]\n+    .iter()\n+    .cloned()\n+    .find_map(|(mut prefixes, mut suffixes)| {\n+        if let Some(prefix) = prefixes.find(|&&prefix| {\n+            s.starts_with(prefix)\n+                && s.chars().nth(prefix.len()).map_or(false, |c| c == '@' || c == ' ')\n+        }) {\n+            Some(&s[prefix.len() + 1..])\n+        } else {\n+            suffixes.find_map(|&suffix| s.strip_suffix(suffix))\n+        }\n+    })\n+    .unwrap_or(s)\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use expect_test::{expect, Expect};\n+\n+    use super::*;\n+\n+    fn check(link: &str, expected: Expect) {\n+        let (l, a) = parse_intra_doc_link(link);\n+        let a = a.map_or_else(String::new, |a| format!(\" ({:?})\", a));\n+        expected.assert_eq(&format!(\"{}{}\", l, a));\n+    }\n+\n+    #[test]\n+    fn test_name() {\n+        check(\"foo\", expect![[r#\"foo\"#]]);\n+        check(\"struct Struct\", expect![[r#\"Struct (Types)\"#]]);\n+        check(\"makro!\", expect![[r#\"makro (Macros)\"#]]);\n+        check(\"fn@function\", expect![[r#\"function (Values)\"#]]);\n+    }\n+}"}]}