{"sha": "edc846f29eac8a45555f19a9fd951ed414398776", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVkYzg0NmYyOWVhYzhhNDU1NTVmMTlhOWZkOTUxZWQ0MTQzOTg3NzY=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-08-02T22:09:06Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-08-02T22:09:06Z"}, "message": "Rollup merge of #63121 - estebank:formatting-pos, r=alexcrichton\n\nOn `format!()` arg count mismatch provide extra info\n\nWhen positional width and precision formatting flags are present in a\nformatting string that has an argument count mismatch, provide extra\ninformation pointing at them making it easiser to understand where the\nproblem may lay:\n\n```\nerror: 4 positional arguments in format string, but there are 3 arguments\n  --> $DIR/ifmt-bad-arg.rs:78:15\n   |\nLL |     println!(\"{} {:.*} {}\", 1, 3.2, 4);\n   |               ^^ ^^--^ ^^      --- this parameter corresponds to the precision flag\n   |                    |\n   |                    this precision flag adds an extra required argument at position 1, which is why there are 4 arguments expected\n   |\n   = note: positional arguments are zero-based\n   = note: for information about formatting flags, visit https://doc.rust-lang.org/std/fmt/index.html\n\nerror: 4 positional arguments in format string, but there are 3 arguments\n  --> $DIR/ifmt-bad-arg.rs:81:15\n   |\nLL |     println!(\"{} {:07$.*} {}\", 1, 3.2, 4);\n   |               ^^ ^^-----^ ^^      --- this parameter corresponds to the precision flag\n   |                    |  |\n   |                    |  this precision flag adds an extra required argument at position 1, which is why there are 4 arguments expected\n   |                    this width flag expects an `usize` argument at position 7, but there are 3 arguments\n   |\n   = note: positional arguments are zero-based\n   = note: for information about formatting flags, visit https://doc.rust-lang.org/std/fmt/index.html\n\nerror: invalid reference to positional argument 7 (there are 3 arguments)\n  --> $DIR/ifmt-bad-arg.rs:84:18\n   |\nLL |     println!(\"{} {:07$} {}\", 1, 3.2, 4);\n   |                  ^^^--^\n   |                     |\n   |                     this width flag expects an `usize` argument at position 7, but there are 3 arguments\n   |\n   = note: positional arguments are zero-based\n   = note: for information about formatting flags, visit https://doc.rust-lang.org/std/fmt/index.html\n```\n\nFix #49384.", "tree": {"sha": "0be1fc6ac0861dd9dcb59c83e9327e7b657c20ac", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0be1fc6ac0861dd9dcb59c83e9327e7b657c20ac"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/edc846f29eac8a45555f19a9fd951ed414398776", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdRLSCCRBK7hj4Ov3rIwAAdHIIAGlZcF7qJQXO8654Ge/6TRjg\nKKhFmITkZjGbL2UN03Z8+rnq7v+tibvP9PGuQe5CT04RosAj63HyyGuTxNzi09au\no/FVQgKlgl3mEhsDQvyeWY1ldVa8GFxWGQ9dCgbFDhKOOHDQ/ztAIIN8TWWXz7Za\nXfNTtWhPd6lU/b5zPiVu4bbpZ16mVT9F0fw/5pqKyckI2jxnw0YaucAO1lBMVPWp\nnSl0pE4JpisoneWEsm6HtPGBxR9frldQOz/MhVf4s10ewN5T0ozbTAs5JeKHhHHX\nAJE5hiDamMoqDBrXlSvE/tLHGidwAgWLSdspiNUN/slrluP1Lq5Exh749tbMRsA=\n=xVtg\n-----END PGP SIGNATURE-----\n", "payload": "tree 0be1fc6ac0861dd9dcb59c83e9327e7b657c20ac\nparent a2735a3e0dd58e4b41b933731928678b7a2da700\nparent 22ea38dd792ec9983084a101ca6159999a9b851a\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1564783746 +0200\ncommitter GitHub <noreply@github.com> 1564783746 +0200\n\nRollup merge of #63121 - estebank:formatting-pos, r=alexcrichton\n\nOn `format!()` arg count mismatch provide extra info\n\nWhen positional width and precision formatting flags are present in a\nformatting string that has an argument count mismatch, provide extra\ninformation pointing at them making it easiser to understand where the\nproblem may lay:\n\n```\nerror: 4 positional arguments in format string, but there are 3 arguments\n  --> $DIR/ifmt-bad-arg.rs:78:15\n   |\nLL |     println!(\"{} {:.*} {}\", 1, 3.2, 4);\n   |               ^^ ^^--^ ^^      --- this parameter corresponds to the precision flag\n   |                    |\n   |                    this precision flag adds an extra required argument at position 1, which is why there are 4 arguments expected\n   |\n   = note: positional arguments are zero-based\n   = note: for information about formatting flags, visit https://doc.rust-lang.org/std/fmt/index.html\n\nerror: 4 positional arguments in format string, but there are 3 arguments\n  --> $DIR/ifmt-bad-arg.rs:81:15\n   |\nLL |     println!(\"{} {:07$.*} {}\", 1, 3.2, 4);\n   |               ^^ ^^-----^ ^^      --- this parameter corresponds to the precision flag\n   |                    |  |\n   |                    |  this precision flag adds an extra required argument at position 1, which is why there are 4 arguments expected\n   |                    this width flag expects an `usize` argument at position 7, but there are 3 arguments\n   |\n   = note: positional arguments are zero-based\n   = note: for information about formatting flags, visit https://doc.rust-lang.org/std/fmt/index.html\n\nerror: invalid reference to positional argument 7 (there are 3 arguments)\n  --> $DIR/ifmt-bad-arg.rs:84:18\n   |\nLL |     println!(\"{} {:07$} {}\", 1, 3.2, 4);\n   |                  ^^^--^\n   |                     |\n   |                     this width flag expects an `usize` argument at position 7, but there are 3 arguments\n   |\n   = note: positional arguments are zero-based\n   = note: for information about formatting flags, visit https://doc.rust-lang.org/std/fmt/index.html\n```\n\nFix #49384.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/edc846f29eac8a45555f19a9fd951ed414398776", "html_url": "https://github.com/rust-lang/rust/commit/edc846f29eac8a45555f19a9fd951ed414398776", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/edc846f29eac8a45555f19a9fd951ed414398776/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a2735a3e0dd58e4b41b933731928678b7a2da700", "url": "https://api.github.com/repos/rust-lang/rust/commits/a2735a3e0dd58e4b41b933731928678b7a2da700", "html_url": "https://github.com/rust-lang/rust/commit/a2735a3e0dd58e4b41b933731928678b7a2da700"}, {"sha": "22ea38dd792ec9983084a101ca6159999a9b851a", "url": "https://api.github.com/repos/rust-lang/rust/commits/22ea38dd792ec9983084a101ca6159999a9b851a", "html_url": "https://github.com/rust-lang/rust/commit/22ea38dd792ec9983084a101ca6159999a9b851a"}], "stats": {"total": 658, "additions": 463, "deletions": 195}, "files": [{"sha": "985abaf2c1bd568bd74b8b661c1b1ead6e06cfe4", "filename": "src/libfmt_macros/lib.rs", "status": "modified", "additions": 48, "deletions": 24, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/edc846f29eac8a45555f19a9fd951ed414398776/src%2Flibfmt_macros%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edc846f29eac8a45555f19a9fd951ed414398776/src%2Flibfmt_macros%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfmt_macros%2Flib.rs?ref=edc846f29eac8a45555f19a9fd951ed414398776", "patch": "@@ -56,16 +56,20 @@ pub struct Argument<'a> {\n /// Specification for the formatting of an argument in the format string.\n #[derive(Copy, Clone, PartialEq)]\n pub struct FormatSpec<'a> {\n-    /// Optionally specified character to fill alignment with\n+    /// Optionally specified character to fill alignment with.\n     pub fill: Option<char>,\n-    /// Optionally specified alignment\n+    /// Optionally specified alignment.\n     pub align: Alignment,\n-    /// Packed version of various flags provided\n+    /// Packed version of various flags provided.\n     pub flags: u32,\n-    /// The integer precision to use\n+    /// The integer precision to use.\n     pub precision: Count,\n-    /// The string width requested for the resulting format\n+    /// The span of the precision formatting flag (for diagnostics).\n+    pub precision_span: Option<InnerSpan>,\n+    /// The string width requested for the resulting format.\n     pub width: Count,\n+    /// The span of the width formatting flag (for diagnostics).\n+    pub width_span: Option<InnerSpan>,\n     /// The descriptor string representing the name of the format desired for\n     /// this argument, this can be empty or any number of characters, although\n     /// it is required to be one word.\n@@ -282,19 +286,24 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Optionally consumes the specified character. If the character is not at\n-    /// the current position, then the current iterator isn't moved and false is\n-    /// returned, otherwise the character is consumed and true is returned.\n+    /// the current position, then the current iterator isn't moved and `false` is\n+    /// returned, otherwise the character is consumed and `true` is returned.\n     fn consume(&mut self, c: char) -> bool {\n-        if let Some(&(_, maybe)) = self.cur.peek() {\n+        self.consume_pos(c).is_some()\n+    }\n+\n+    /// Optionally consumes the specified character. If the character is not at\n+    /// the current position, then the current iterator isn't moved and `None` is\n+    /// returned, otherwise the character is consumed and the current position is\n+    /// returned.\n+    fn consume_pos(&mut self, c: char) -> Option<usize> {\n+        if let Some(&(pos, maybe)) = self.cur.peek() {\n             if c == maybe {\n                 self.cur.next();\n-                true\n-            } else {\n-                false\n+                return Some(pos);\n             }\n-        } else {\n-            false\n         }\n+        None\n     }\n \n     fn to_span_index(&self, pos: usize) -> InnerOffset {\n@@ -462,7 +471,9 @@ impl<'a> Parser<'a> {\n             align: AlignUnknown,\n             flags: 0,\n             precision: CountImplied,\n+            precision_span: None,\n             width: CountImplied,\n+            width_span: None,\n             ty: &self.input[..0],\n         };\n         if !self.consume(':') {\n@@ -499,6 +510,7 @@ impl<'a> Parser<'a> {\n         }\n         // Width and precision\n         let mut havewidth = false;\n+\n         if self.consume('0') {\n             // small ambiguity with '0$' as a format string. In theory this is a\n             // '0' flag and then an ill-formatted format string with just a '$'\n@@ -512,17 +524,28 @@ impl<'a> Parser<'a> {\n             }\n         }\n         if !havewidth {\n-            spec.width = self.count();\n+            let width_span_start = if let Some((pos, _)) = self.cur.peek() {\n+                *pos\n+            } else {\n+                0\n+            };\n+            let (w, sp) = self.count(width_span_start);\n+            spec.width = w;\n+            spec.width_span = sp;\n         }\n-        if self.consume('.') {\n-            if self.consume('*') {\n+        if let Some(start) = self.consume_pos('.') {\n+            if let Some(end) = self.consume_pos('*') {\n                 // Resolve `CountIsNextParam`.\n                 // We can do this immediately as `position` is resolved later.\n                 let i = self.curarg;\n                 self.curarg += 1;\n                 spec.precision = CountIsParam(i);\n+                spec.precision_span =\n+                    Some(self.to_span_index(start).to(self.to_span_index(end + 1)));\n             } else {\n-                spec.precision = self.count();\n+                let (p, sp) = self.count(start);\n+                spec.precision = p;\n+                spec.precision_span = sp;\n             }\n         }\n         // Optional radix followed by the actual format specifier\n@@ -551,24 +574,25 @@ impl<'a> Parser<'a> {\n     /// Parses a Count parameter at the current position. This does not check\n     /// for 'CountIsNextParam' because that is only used in precision, not\n     /// width.\n-    fn count(&mut self) -> Count {\n+    fn count(&mut self, start: usize) -> (Count, Option<InnerSpan>) {\n         if let Some(i) = self.integer() {\n-            if self.consume('$') {\n-                CountIsParam(i)\n+            if let Some(end) = self.consume_pos('$') {\n+                let span = self.to_span_index(start).to(self.to_span_index(end + 1));\n+                (CountIsParam(i), Some(span))\n             } else {\n-                CountIs(i)\n+                (CountIs(i), None)\n             }\n         } else {\n             let tmp = self.cur.clone();\n             let word = self.word();\n             if word.is_empty() {\n                 self.cur = tmp;\n-                CountImplied\n+                (CountImplied, None)\n             } else if self.consume('$') {\n-                CountIsName(Symbol::intern(word))\n+                (CountIsName(Symbol::intern(word)), None)\n             } else {\n                 self.cur = tmp;\n-                CountImplied\n+                (CountImplied, None)\n             }\n         }\n     }"}, {"sha": "e2ddb8810e90a64cd58ed4076b5613ec745152fb", "filename": "src/libfmt_macros/tests.rs", "status": "modified", "additions": 187, "deletions": 146, "changes": 333, "blob_url": "https://github.com/rust-lang/rust/blob/edc846f29eac8a45555f19a9fd951ed414398776/src%2Flibfmt_macros%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edc846f29eac8a45555f19a9fd951ed414398776/src%2Flibfmt_macros%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfmt_macros%2Ftests.rs?ref=edc846f29eac8a45555f19a9fd951ed414398776", "patch": "@@ -12,6 +12,8 @@ fn fmtdflt() -> FormatSpec<'static> {\n         flags: 0,\n         precision: CountImplied,\n         width: CountImplied,\n+        precision_span: None,\n+        width_span: None,\n         ty: \"\",\n     };\n }\n@@ -79,165 +81,204 @@ fn format_position_nothing_else() {\n }\n #[test]\n fn format_type() {\n-    same(\"{3:a}\",\n-         &[NextArgument(Argument {\n-               position: ArgumentIs(3),\n-               format: FormatSpec {\n-                   fill: None,\n-                   align: AlignUnknown,\n-                   flags: 0,\n-                   precision: CountImplied,\n-                   width: CountImplied,\n-                   ty: \"a\",\n-               },\n-           })]);\n+    same(\n+        \"{3:a}\",\n+        &[NextArgument(Argument {\n+            position: ArgumentIs(3),\n+            format: FormatSpec {\n+                fill: None,\n+                align: AlignUnknown,\n+                flags: 0,\n+                precision: CountImplied,\n+                width: CountImplied,\n+                precision_span: None,\n+                width_span: None,\n+                ty: \"a\",\n+            },\n+        })]);\n }\n #[test]\n fn format_align_fill() {\n-    same(\"{3:>}\",\n-         &[NextArgument(Argument {\n-               position: ArgumentIs(3),\n-               format: FormatSpec {\n-                   fill: None,\n-                   align: AlignRight,\n-                   flags: 0,\n-                   precision: CountImplied,\n-                   width: CountImplied,\n-                   ty: \"\",\n-               },\n-           })]);\n-    same(\"{3:0<}\",\n-         &[NextArgument(Argument {\n-               position: ArgumentIs(3),\n-               format: FormatSpec {\n-                   fill: Some('0'),\n-                   align: AlignLeft,\n-                   flags: 0,\n-                   precision: CountImplied,\n-                   width: CountImplied,\n-                   ty: \"\",\n-               },\n-           })]);\n-    same(\"{3:*<abcd}\",\n-         &[NextArgument(Argument {\n-               position: ArgumentIs(3),\n-               format: FormatSpec {\n-                   fill: Some('*'),\n-                   align: AlignLeft,\n-                   flags: 0,\n-                   precision: CountImplied,\n-                   width: CountImplied,\n-                   ty: \"abcd\",\n-               },\n-           })]);\n+    same(\n+        \"{3:>}\",\n+        &[NextArgument(Argument {\n+            position: ArgumentIs(3),\n+            format: FormatSpec {\n+                fill: None,\n+                align: AlignRight,\n+                flags: 0,\n+                precision: CountImplied,\n+                width: CountImplied,\n+                precision_span: None,\n+                width_span: None,\n+                ty: \"\",\n+            },\n+        })]);\n+    same(\n+        \"{3:0<}\",\n+        &[NextArgument(Argument {\n+            position: ArgumentIs(3),\n+            format: FormatSpec {\n+                fill: Some('0'),\n+                align: AlignLeft,\n+                flags: 0,\n+                precision: CountImplied,\n+                width: CountImplied,\n+                precision_span: None,\n+                width_span: None,\n+                ty: \"\",\n+            },\n+        })]);\n+    same(\n+        \"{3:*<abcd}\",\n+        &[NextArgument(Argument {\n+            position: ArgumentIs(3),\n+            format: FormatSpec {\n+                fill: Some('*'),\n+                align: AlignLeft,\n+                flags: 0,\n+                precision: CountImplied,\n+                width: CountImplied,\n+                precision_span: None,\n+                width_span: None,\n+                ty: \"abcd\",\n+            },\n+        })]);\n }\n #[test]\n fn format_counts() {\n     use syntax_pos::{GLOBALS, Globals, edition};\n     GLOBALS.set(&Globals::new(edition::DEFAULT_EDITION), || {\n-    same(\"{:10s}\",\n-         &[NextArgument(Argument {\n-               position: ArgumentImplicitlyIs(0),\n-               format: FormatSpec {\n-                   fill: None,\n-                   align: AlignUnknown,\n-                   flags: 0,\n-                   precision: CountImplied,\n-                   width: CountIs(10),\n-                   ty: \"s\",\n-               },\n-           })]);\n-    same(\"{:10$.10s}\",\n-         &[NextArgument(Argument {\n-               position: ArgumentImplicitlyIs(0),\n-               format: FormatSpec {\n-                   fill: None,\n-                   align: AlignUnknown,\n-                   flags: 0,\n-                   precision: CountIs(10),\n-                   width: CountIsParam(10),\n-                   ty: \"s\",\n-               },\n-           })]);\n-    same(\"{:.*s}\",\n-         &[NextArgument(Argument {\n-               position: ArgumentImplicitlyIs(1),\n-               format: FormatSpec {\n-                   fill: None,\n-                   align: AlignUnknown,\n-                   flags: 0,\n-                   precision: CountIsParam(0),\n-                   width: CountImplied,\n-                   ty: \"s\",\n-               },\n-           })]);\n-    same(\"{:.10$s}\",\n-         &[NextArgument(Argument {\n-               position: ArgumentImplicitlyIs(0),\n-               format: FormatSpec {\n-                   fill: None,\n-                   align: AlignUnknown,\n-                   flags: 0,\n-                   precision: CountIsParam(10),\n-                   width: CountImplied,\n-                   ty: \"s\",\n-               },\n-           })]);\n-    same(\"{:a$.b$s}\",\n-         &[NextArgument(Argument {\n-               position: ArgumentImplicitlyIs(0),\n-               format: FormatSpec {\n-                   fill: None,\n-                   align: AlignUnknown,\n-                   flags: 0,\n-                   precision: CountIsName(Symbol::intern(\"b\")),\n-                   width: CountIsName(Symbol::intern(\"a\")),\n-                   ty: \"s\",\n-               },\n-           })]);\n+    same(\n+        \"{:10s}\",\n+        &[NextArgument(Argument {\n+            position: ArgumentImplicitlyIs(0),\n+            format: FormatSpec {\n+                fill: None,\n+                align: AlignUnknown,\n+                flags: 0,\n+                precision: CountImplied,\n+                width: CountIs(10),\n+                precision_span: None,\n+                width_span: None,\n+                ty: \"s\",\n+            },\n+        })]);\n+    same(\n+        \"{:10$.10s}\",\n+        &[NextArgument(Argument {\n+            position: ArgumentImplicitlyIs(0),\n+            format: FormatSpec {\n+                fill: None,\n+                align: AlignUnknown,\n+                flags: 0,\n+                precision: CountIs(10),\n+                width: CountIsParam(10),\n+                precision_span: None,\n+                width_span: Some(InnerSpan::new(3, 6)),\n+                ty: \"s\",\n+            },\n+        })]);\n+    same(\n+        \"{:.*s}\",\n+        &[NextArgument(Argument {\n+            position: ArgumentImplicitlyIs(1),\n+            format: FormatSpec {\n+                fill: None,\n+                align: AlignUnknown,\n+                flags: 0,\n+                precision: CountIsParam(0),\n+                width: CountImplied,\n+                precision_span: Some(InnerSpan::new(3, 5)),\n+                width_span: None,\n+                ty: \"s\",\n+            },\n+        })]);\n+    same(\n+        \"{:.10$s}\",\n+        &[NextArgument(Argument {\n+            position: ArgumentImplicitlyIs(0),\n+            format: FormatSpec {\n+                fill: None,\n+                align: AlignUnknown,\n+                flags: 0,\n+                precision: CountIsParam(10),\n+                width: CountImplied,\n+                precision_span: Some(InnerSpan::new(3, 7)),\n+                width_span: None,\n+                ty: \"s\",\n+            },\n+        })]);\n+    same(\n+        \"{:a$.b$s}\",\n+        &[NextArgument(Argument {\n+            position: ArgumentImplicitlyIs(0),\n+            format: FormatSpec {\n+                fill: None,\n+                align: AlignUnknown,\n+                flags: 0,\n+                precision: CountIsName(Symbol::intern(\"b\")),\n+                width: CountIsName(Symbol::intern(\"a\")),\n+                precision_span: None,\n+                width_span: None,\n+                ty: \"s\",\n+            },\n+        })]);\n     });\n }\n #[test]\n fn format_flags() {\n-    same(\"{:-}\",\n-         &[NextArgument(Argument {\n-               position: ArgumentImplicitlyIs(0),\n-               format: FormatSpec {\n-                   fill: None,\n-                   align: AlignUnknown,\n-                   flags: (1 << FlagSignMinus as u32),\n-                   precision: CountImplied,\n-                   width: CountImplied,\n-                   ty: \"\",\n-               },\n-           })]);\n-    same(\"{:+#}\",\n-         &[NextArgument(Argument {\n-               position: ArgumentImplicitlyIs(0),\n-               format: FormatSpec {\n-                   fill: None,\n-                   align: AlignUnknown,\n-                   flags: (1 << FlagSignPlus as u32) | (1 << FlagAlternate as u32),\n-                   precision: CountImplied,\n-                   width: CountImplied,\n-                   ty: \"\",\n-               },\n-           })]);\n+    same(\n+        \"{:-}\",\n+        &[NextArgument(Argument {\n+            position: ArgumentImplicitlyIs(0),\n+            format: FormatSpec {\n+                fill: None,\n+                align: AlignUnknown,\n+                flags: (1 << FlagSignMinus as u32),\n+                precision: CountImplied,\n+                width: CountImplied,\n+                precision_span: None,\n+                width_span: None,\n+                ty: \"\",\n+            },\n+        })]);\n+    same(\n+        \"{:+#}\",\n+        &[NextArgument(Argument {\n+            position: ArgumentImplicitlyIs(0),\n+            format: FormatSpec {\n+                fill: None,\n+                align: AlignUnknown,\n+                flags: (1 << FlagSignPlus as u32) | (1 << FlagAlternate as u32),\n+                precision: CountImplied,\n+                width: CountImplied,\n+                precision_span: None,\n+                width_span: None,\n+                ty: \"\",\n+            },\n+        })]);\n }\n #[test]\n fn format_mixture() {\n-    same(\"abcd {3:a} efg\",\n-         &[String(\"abcd \"),\n-           NextArgument(Argument {\n-               position: ArgumentIs(3),\n-               format: FormatSpec {\n-                   fill: None,\n-                   align: AlignUnknown,\n-                   flags: 0,\n-                   precision: CountImplied,\n-                   width: CountImplied,\n-                   ty: \"a\",\n-               },\n-           }),\n-           String(\" efg\")]);\n+    same(\n+        \"abcd {3:a} efg\",\n+        &[\n+            String(\"abcd \"),\n+            NextArgument(Argument {\n+                position: ArgumentIs(3),\n+                format: FormatSpec {\n+                    fill: None,\n+                    align: AlignUnknown,\n+                    flags: 0,\n+                    precision: CountImplied,\n+                    width: CountImplied,\n+                    precision_span: None,\n+                    width_span: None,\n+                    ty: \"a\",\n+                },\n+            }),\n+            String(\" efg\"),\n+        ],\n+    );\n }"}, {"sha": "fe9cad1e32fcad09ceb83268bd6062675a4e9c51", "filename": "src/libsyntax_ext/format.rs", "status": "modified", "additions": 122, "deletions": 24, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/edc846f29eac8a45555f19a9fd951ed414398776/src%2Flibsyntax_ext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edc846f29eac8a45555f19a9fd951ed414398776/src%2Flibsyntax_ext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fformat.rs?ref=edc846f29eac8a45555f19a9fd951ed414398776", "patch": "@@ -109,6 +109,8 @@ struct Context<'a, 'b> {\n     invalid_refs: Vec<(usize, usize)>,\n     /// Spans of all the formatting arguments, in order.\n     arg_spans: Vec<Span>,\n+    /// All the formatting arguments that have formatting flags set, in order for diagnostics.\n+    arg_with_formatting: Vec<parse::FormatSpec<'a>>,\n     /// Whether this formatting string is a literal or it comes from a macro.\n     is_literal: bool,\n }\n@@ -273,31 +275,44 @@ impl<'a, 'b> Context<'a, 'b> {\n         } else {\n             MultiSpan::from_span(self.fmtsp)\n         };\n-        let refs_len = self.invalid_refs.len();\n-        let mut refs = self\n+        let refs = self\n             .invalid_refs\n             .iter()\n             .map(|(r, pos)| (r.to_string(), self.arg_spans.get(*pos)));\n \n-        if self.names.is_empty() && !numbered_position_args {\n+        let mut zero_based_note = false;\n+\n+        let count = self.pieces.len() + self.arg_with_formatting\n+            .iter()\n+            .filter(|fmt| fmt.precision_span.is_some())\n+            .count();\n+        if self.names.is_empty() && !numbered_position_args && count != self.args.len() {\n             e = self.ecx.mut_span_err(\n                 sp,\n                 &format!(\n                     \"{} positional argument{} in format string, but {}\",\n-                         self.pieces.len(),\n-                         if self.pieces.len() > 1 { \"s\" } else { \"\" },\n-                    self.describe_num_args()\n+                    count,\n+                    if count > 1 { \"s\" } else { \"\" },\n+                    self.describe_num_args(),\n                 ),\n             );\n         } else {\n-            let (arg_list, mut sp) = if refs_len == 1 {\n-                let (reg, pos) = refs.next().unwrap();\n+            let (mut refs, spans): (Vec<_>, Vec<_>) = refs.unzip();\n+            // Avoid `invalid reference to positional arguments 7 and 7 (there is 1 argument)`\n+            // for `println!(\"{7:7$}\", 1);`\n+            refs.sort();\n+            refs.dedup();\n+            let (arg_list, mut sp) = if refs.len() == 1 {\n+                let spans: Vec<_> = spans.into_iter().filter_map(|sp| sp.map(|sp| *sp)).collect();\n                 (\n-                    format!(\"argument {}\", reg),\n-                    MultiSpan::from_span(*pos.unwrap_or(&self.fmtsp)),\n+                    format!(\"argument {}\", refs[0]),\n+                    if spans.is_empty() {\n+                        MultiSpan::from_span(self.fmtsp)\n+                    } else {\n+                        MultiSpan::from_spans(spans)\n+                    },\n                 )\n             } else {\n-                let (mut refs, spans): (Vec<_>, Vec<_>) = refs.unzip();\n                 let pos = MultiSpan::from_spans(spans.into_iter().map(|s| *s.unwrap()).collect());\n                 let reg = refs.pop().unwrap();\n                 (\n@@ -317,9 +332,70 @@ impl<'a, 'b> Context<'a, 'b> {\n                 &format!(\"invalid reference to positional {} ({})\",\n                          arg_list,\n                          self.describe_num_args()));\n-            e.note(\"positional arguments are zero-based\");\n+            zero_based_note = true;\n         };\n \n+        for fmt in &self.arg_with_formatting {\n+            if let Some(span) = fmt.precision_span {\n+                let span = self.fmtsp.from_inner(span);\n+                match fmt.precision {\n+                    parse::CountIsParam(pos) if pos > self.args.len() => {\n+                        e.span_label(span, &format!(\n+                            \"this precision flag expects an `usize` argument at position {}, \\\n+                             but {}\",\n+                            pos,\n+                            self.describe_num_args(),\n+                        ));\n+                        zero_based_note = true;\n+                    }\n+                    parse::CountIsParam(pos) => {\n+                        let count = self.pieces.len() + self.arg_with_formatting\n+                            .iter()\n+                            .filter(|fmt| fmt.precision_span.is_some())\n+                            .count();\n+                        e.span_label(span, &format!(\n+                            \"this precision flag adds an extra required argument at position {}, \\\n+                             which is why there {} expected\",\n+                            pos,\n+                            if count == 1 {\n+                                \"is 1 argument\".to_string()\n+                            } else {\n+                                format!(\"are {} arguments\", count)\n+                            },\n+                        ));\n+                        e.span_label(\n+                            self.args[pos].span,\n+                            \"this parameter corresponds to the precision flag\",\n+                        );\n+                        zero_based_note = true;\n+                    }\n+                    _ => {}\n+                }\n+            }\n+            if let Some(span) = fmt.width_span {\n+                let span = self.fmtsp.from_inner(span);\n+                match fmt.width {\n+                    parse::CountIsParam(pos) if pos > self.args.len() => {\n+                        e.span_label(span, &format!(\n+                            \"this width flag expects an `usize` argument at position {}, \\\n+                             but {}\",\n+                            pos,\n+                            self.describe_num_args(),\n+                        ));\n+                        zero_based_note = true;\n+                    }\n+                    _ => {}\n+                }\n+            }\n+        }\n+        if zero_based_note {\n+            e.note(\"positional arguments are zero-based\");\n+        }\n+        if !self.arg_with_formatting.is_empty() {\n+            e.note(\"for information about formatting flags, visit \\\n+                    https://doc.rust-lang.org/std/fmt/index.html\");\n+        }\n+\n         e.emit();\n     }\n \n@@ -435,10 +511,11 @@ impl<'a, 'b> Context<'a, 'b> {\n \n     /// Builds a static `rt::Argument` from a `parse::Piece` or append\n     /// to the `literal` string.\n-    fn build_piece(&mut self,\n-                   piece: &parse::Piece<'_>,\n-                   arg_index_consumed: &mut Vec<usize>)\n-                   -> Option<P<ast::Expr>> {\n+    fn build_piece(\n+        &mut self,\n+        piece: &parse::Piece<'a>,\n+        arg_index_consumed: &mut Vec<usize>,\n+    ) -> Option<P<ast::Expr>> {\n         let sp = self.macsp;\n         match *piece {\n             parse::String(s) => {\n@@ -496,7 +573,9 @@ impl<'a, 'b> Context<'a, 'b> {\n                         align: parse::AlignUnknown,\n                         flags: 0,\n                         precision: parse::CountImplied,\n+                        precision_span: None,\n                         width: parse::CountImplied,\n+                        width_span: None,\n                         ty: arg.format.ty,\n                     },\n                 };\n@@ -506,6 +585,9 @@ impl<'a, 'b> Context<'a, 'b> {\n                 let pos_simple =\n                     arg.position.index() == simple_arg.position.index();\n \n+                if arg.format.precision_span.is_some() || arg.format.width_span.is_some() {\n+                    self.arg_with_formatting.push(arg.format);\n+                }\n                 if !pos_simple || arg.format != simple_arg.format || fill != ' ' {\n                     self.all_pieces_simple = false;\n                 }\n@@ -530,7 +612,7 @@ impl<'a, 'b> Context<'a, 'b> {\n                 let path = self.ecx.path_global(sp, Context::rtpath(self.ecx, \"FormatSpec\"));\n                 let fmt = self.ecx.expr_struct(\n                     sp,\n-                                         path,\n+                    path,\n                     vec![\n                         self.ecx.field_imm(sp, self.ecx.ident_of(\"fill\"), fill),\n                         self.ecx.field_imm(sp, self.ecx.ident_of(\"align\"), align),\n@@ -657,12 +739,13 @@ impl<'a, 'b> Context<'a, 'b> {\n         self.ecx.expr_call_global(self.macsp, path, fn_args)\n     }\n \n-    fn format_arg(ecx: &ExtCtxt<'_>,\n-                  macsp: Span,\n-                  mut sp: Span,\n-                  ty: &ArgumentType,\n-                  arg: ast::Ident)\n-                  -> P<ast::Expr> {\n+    fn format_arg(\n+        ecx: &ExtCtxt<'_>,\n+        macsp: Span,\n+        mut sp: Span,\n+        ty: &ArgumentType,\n+        arg: ast::Ident,\n+    ) -> P<ast::Expr> {\n         sp = sp.apply_mark(ecx.current_expansion.id);\n         let arg = ecx.expr_ident(sp, arg);\n         let trait_ = match *ty {\n@@ -678,7 +761,21 @@ impl<'a, 'b> Context<'a, 'b> {\n                     \"x\" => \"LowerHex\",\n                     \"X\" => \"UpperHex\",\n                     _ => {\n-                        ecx.span_err(sp, &format!(\"unknown format trait `{}`\", *tyname));\n+                        let mut err = ecx.struct_span_err(\n+                            sp,\n+                            &format!(\"unknown format trait `{}`\", *tyname),\n+                        );\n+                        err.note(\"the only appropriate formatting traits are:\\n\\\n+                                  - ``, which uses the `Display` trait\\n\\\n+                                  - `?`, which uses the `Debug` trait\\n\\\n+                                  - `e`, which uses the `LowerExp` trait\\n\\\n+                                  - `E`, which uses the `UpperExp` trait\\n\\\n+                                  - `o`, which uses the `Octal` trait\\n\\\n+                                  - `p`, which uses the `Pointer` trait\\n\\\n+                                  - `b`, which uses the `Binary` trait\\n\\\n+                                  - `x`, which uses the `LowerHex` trait\\n\\\n+                                  - `X`, which uses the `UpperHex` trait\");\n+                        err.emit();\n                         return DummyResult::raw_expr(sp, true);\n                     }\n                 }\n@@ -941,6 +1038,7 @@ pub fn expand_preparsed_format_args(\n         fmtsp: fmt.span,\n         invalid_refs: Vec::new(),\n         arg_spans,\n+        arg_with_formatting: Vec::new(),\n         is_literal,\n     };\n "}, {"sha": "02a7433d9469daa2e218cf79d68b6c7a90c4e405", "filename": "src/libsyntax_pos/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/edc846f29eac8a45555f19a9fd951ed414398776/src%2Flibsyntax_pos%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edc846f29eac8a45555f19a9fd951ed414398776/src%2Flibsyntax_pos%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Flib.rs?ref=edc846f29eac8a45555f19a9fd951ed414398776", "patch": "@@ -1402,6 +1402,7 @@ pub struct MalformedSourceMapPositions {\n     pub end_pos: BytePos\n }\n \n+/// Range inside of a `Span` used for diagnostics when we only have access to relative positions.\n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n pub struct InnerSpan {\n     pub start: usize,"}, {"sha": "ba897f171af25aa3c0ba5a28e820b0bcb66d0d10", "filename": "src/test/ui/if/ifmt-bad-arg.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/edc846f29eac8a45555f19a9fd951ed414398776/src%2Ftest%2Fui%2Fif%2Fifmt-bad-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edc846f29eac8a45555f19a9fd951ed414398776/src%2Ftest%2Fui%2Fif%2Fifmt-bad-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fif%2Fifmt-bad-arg.rs?ref=edc846f29eac8a45555f19a9fd951ed414398776", "patch": "@@ -75,4 +75,15 @@ ninth number: {\n tenth number: {}\",\n         1, 2, 3, 4, 5, 6, 7, 8, 9, 10);\n     //~^^ ERROR: invalid format string\n+    println!(\"{} {:.*} {}\", 1, 3.2, 4);\n+    //~^ ERROR 4 positional arguments in format string, but there are 3 arguments\n+    //~| ERROR mismatched types\n+    println!(\"{} {:07$.*} {}\", 1, 3.2, 4);\n+    //~^ ERROR 4 positional arguments in format string, but there are 3 arguments\n+    //~| ERROR mismatched types\n+    println!(\"{} {:07$} {}\", 1, 3.2, 4);\n+    //~^ ERROR invalid reference to positional argument 7 (there are 3 arguments)\n+    println!(\"{:foo}\", 1); //~ ERROR unknown format trait `foo`\n+    println!(\"{5} {:4$} {6:7$}\", 1);\n+    //~^ ERROR invalid reference to positional arguments 4, 5, 6 and 7 (there is 1 argument)\n }"}, {"sha": "336ea2254bf5a698e90b843c3e0c8a0a97d829d0", "filename": "src/test/ui/if/ifmt-bad-arg.stderr", "status": "modified", "additions": 83, "deletions": 1, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/edc846f29eac8a45555f19a9fd951ed414398776/src%2Ftest%2Fui%2Fif%2Fifmt-bad-arg.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/edc846f29eac8a45555f19a9fd951ed414398776/src%2Ftest%2Fui%2Fif%2Fifmt-bad-arg.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fif%2Fifmt-bad-arg.stderr?ref=edc846f29eac8a45555f19a9fd951ed414398776", "patch": "@@ -220,5 +220,87 @@ LL | tenth number: {}\",\n    |\n    = note: if you intended to print `{`, you can escape it using `{{`\n \n-error: aborting due to 28 previous errors\n+error: 4 positional arguments in format string, but there are 3 arguments\n+  --> $DIR/ifmt-bad-arg.rs:78:15\n+   |\n+LL |     println!(\"{} {:.*} {}\", 1, 3.2, 4);\n+   |               ^^ ^^--^ ^^      --- this parameter corresponds to the precision flag\n+   |                    |\n+   |                    this precision flag adds an extra required argument at position 1, which is why there are 4 arguments expected\n+   |\n+   = note: positional arguments are zero-based\n+   = note: for information about formatting flags, visit https://doc.rust-lang.org/std/fmt/index.html\n+\n+error: 4 positional arguments in format string, but there are 3 arguments\n+  --> $DIR/ifmt-bad-arg.rs:81:15\n+   |\n+LL |     println!(\"{} {:07$.*} {}\", 1, 3.2, 4);\n+   |               ^^ ^^^----^ ^^      --- this parameter corresponds to the precision flag\n+   |                     | |\n+   |                     | this precision flag adds an extra required argument at position 1, which is why there are 4 arguments expected\n+   |                     this width flag expects an `usize` argument at position 7, but there are 3 arguments\n+   |\n+   = note: positional arguments are zero-based\n+   = note: for information about formatting flags, visit https://doc.rust-lang.org/std/fmt/index.html\n+\n+error: invalid reference to positional argument 7 (there are 3 arguments)\n+  --> $DIR/ifmt-bad-arg.rs:84:18\n+   |\n+LL |     println!(\"{} {:07$} {}\", 1, 3.2, 4);\n+   |                  ^^^--^\n+   |                     |\n+   |                     this width flag expects an `usize` argument at position 7, but there are 3 arguments\n+   |\n+   = note: positional arguments are zero-based\n+   = note: for information about formatting flags, visit https://doc.rust-lang.org/std/fmt/index.html\n+\n+error: unknown format trait `foo`\n+  --> $DIR/ifmt-bad-arg.rs:86:24\n+   |\n+LL |     println!(\"{:foo}\", 1);\n+   |                        ^\n+   |\n+   = note: the only appropriate formatting traits are:\n+           - ``, which uses the `Display` trait\n+           - `?`, which uses the `Debug` trait\n+           - `e`, which uses the `LowerExp` trait\n+           - `E`, which uses the `UpperExp` trait\n+           - `o`, which uses the `Octal` trait\n+           - `p`, which uses the `Pointer` trait\n+           - `b`, which uses the `Binary` trait\n+           - `x`, which uses the `LowerHex` trait\n+           - `X`, which uses the `UpperHex` trait\n+\n+error: invalid reference to positional arguments 4, 5, 6 and 7 (there is 1 argument)\n+  --> $DIR/ifmt-bad-arg.rs:87:15\n+   |\n+LL |     println!(\"{5} {:4$} {6:7$}\", 1);\n+   |               ^^^ ^^--^ ^^^--^\n+   |                     |      |\n+   |                     |      this width flag expects an `usize` argument at position 7, but there is 1 argument\n+   |                     this width flag expects an `usize` argument at position 4, but there is 1 argument\n+   |\n+   = note: positional arguments are zero-based\n+   = note: for information about formatting flags, visit https://doc.rust-lang.org/std/fmt/index.html\n+\n+error[E0308]: mismatched types\n+  --> $DIR/ifmt-bad-arg.rs:78:32\n+   |\n+LL |     println!(\"{} {:.*} {}\", 1, 3.2, 4);\n+   |                                ^^^ expected usize, found floating-point number\n+   |\n+   = note: expected type `&usize`\n+              found type `&{float}`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/ifmt-bad-arg.rs:81:35\n+   |\n+LL |     println!(\"{} {:07$.*} {}\", 1, 3.2, 4);\n+   |                                   ^^^ expected usize, found floating-point number\n+   |\n+   = note: expected type `&usize`\n+              found type `&{float}`\n+\n+error: aborting due to 35 previous errors\n \n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "7853b5ca0c9a6c642bf27d11bdad689e07399c5a", "filename": "src/test/ui/if/ifmt-unknown-trait.stderr", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/edc846f29eac8a45555f19a9fd951ed414398776/src%2Ftest%2Fui%2Fif%2Fifmt-unknown-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/edc846f29eac8a45555f19a9fd951ed414398776/src%2Ftest%2Fui%2Fif%2Fifmt-unknown-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fif%2Fifmt-unknown-trait.stderr?ref=edc846f29eac8a45555f19a9fd951ed414398776", "patch": "@@ -3,6 +3,17 @@ error: unknown format trait `notimplemented`\n    |\n LL |     format!(\"{:notimplemented}\", \"3\");\n    |                                  ^^^\n+   |\n+   = note: the only appropriate formatting traits are:\n+           - ``, which uses the `Display` trait\n+           - `?`, which uses the `Debug` trait\n+           - `e`, which uses the `LowerExp` trait\n+           - `E`, which uses the `UpperExp` trait\n+           - `o`, which uses the `Octal` trait\n+           - `p`, which uses the `Pointer` trait\n+           - `b`, which uses the `Binary` trait\n+           - `x`, which uses the `LowerHex` trait\n+           - `X`, which uses the `UpperHex` trait\n \n error: aborting due to previous error\n "}]}