{"sha": "2a17b84cbc9cbd36ad79bb1708d1714f1cf3787b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJhMTdiODRjYmM5Y2JkMzZhZDc5YmIxNzA4ZDE3MTRmMWNmMzc4N2I=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-04-15T12:40:38Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-04-15T12:40:38Z"}, "message": "rustc: provide adt_sized_constraint as an on-demand query.", "tree": {"sha": "c7650e330d6143962de41d2bb271baa246504ac6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c7650e330d6143962de41d2bb271baa246504ac6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2a17b84cbc9cbd36ad79bb1708d1714f1cf3787b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2a17b84cbc9cbd36ad79bb1708d1714f1cf3787b", "html_url": "https://github.com/rust-lang/rust/commit/2a17b84cbc9cbd36ad79bb1708d1714f1cf3787b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2a17b84cbc9cbd36ad79bb1708d1714f1cf3787b/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5f13a3b540ab6024665322d716e487c800645f24", "url": "https://api.github.com/repos/rust-lang/rust/commits/5f13a3b540ab6024665322d716e487c800645f24", "html_url": "https://github.com/rust-lang/rust/commit/5f13a3b540ab6024665322d716e487c800645f24"}], "stats": {"total": 138, "additions": 61, "deletions": 77}, "files": [{"sha": "09eacb40aef7e28dba37b92563f9c476e2967ded", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 60, "deletions": 77, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/2a17b84cbc9cbd36ad79bb1708d1714f1cf3787b/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a17b84cbc9cbd36ad79bb1708d1714f1cf3787b/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=2a17b84cbc9cbd36ad79bb1708d1714f1cf3787b", "patch": "@@ -1695,85 +1695,21 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n     /// Due to normalization being eager, this applies even if\n     /// the associated type is behind a pointer, e.g. issue #31299.\n     pub fn sized_constraint(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Ty<'tcx> {\n-        self.calculate_sized_constraint_inner(tcx.global_tcx(), &mut Vec::new())\n-    }\n-\n-    /// Calculates the Sized-constraint.\n-    ///\n-    /// As the Sized-constraint of enums can be a *set* of types,\n-    /// the Sized-constraint may need to be a set also. Because introducing\n-    /// a new type of IVar is currently a complex affair, the Sized-constraint\n-    /// may be a tuple.\n-    ///\n-    /// In fact, there are only a few options for the constraint:\n-    ///     - `bool`, if the type is always Sized\n-    ///     - an obviously-unsized type\n-    ///     - a type parameter or projection whose Sizedness can't be known\n-    ///     - a tuple of type parameters or projections, if there are multiple\n-    ///       such.\n-    ///     - a TyError, if a type contained itself. The representability\n-    ///       check should catch this case.\n-    fn calculate_sized_constraint_inner(&self,\n-                                        tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                        stack: &mut Vec<DefId>)\n-                                        -> Ty<'tcx>\n-    {\n-        if let Some(ty) = tcx.maps.adt_sized_constraint.borrow().get(&self.did) {\n-            return ty;\n-        }\n-\n-        // Follow the memoization pattern: push the computation of\n-        // DepNode::SizedConstraint as our current task.\n-        let _task = tcx.dep_graph.in_task(DepNode::SizedConstraint(self.did));\n-\n-        if stack.contains(&self.did) {\n-            debug!(\"calculate_sized_constraint: {:?} is recursive\", self);\n-            // This should be reported as an error by `check_representable`.\n-            //\n-            // Consider the type as Sized in the meanwhile to avoid\n-            // further errors.\n-            tcx.maps.adt_sized_constraint.borrow_mut().insert(self.did, tcx.types.err);\n-            return tcx.types.err;\n-        }\n-\n-        stack.push(self.did);\n-\n-        let tys : Vec<_> =\n-            self.variants.iter().flat_map(|v| {\n-                v.fields.last()\n-            }).flat_map(|f| {\n-                let ty = tcx.item_type(f.did);\n-                self.sized_constraint_for_ty(tcx, stack, ty)\n-            }).collect();\n-\n-        let self_ = stack.pop().unwrap();\n-        assert_eq!(self_, self.did);\n-\n-        let ty = match tys.len() {\n-            _ if tys.references_error() => tcx.types.err,\n-            0 => tcx.types.bool,\n-            1 => tys[0],\n-            _ => tcx.intern_tup(&tys[..], false)\n-        };\n-\n-        let old = tcx.maps.adt_sized_constraint.borrow().get(&self.did).cloned();\n-        match old {\n-            Some(old_ty) => {\n-                debug!(\"calculate_sized_constraint: {:?} recurred\", self);\n-                assert_eq!(old_ty, tcx.types.err);\n-                old_ty\n-            }\n-            None => {\n-                debug!(\"calculate_sized_constraint: {:?} => {:?}\", self, ty);\n-                tcx.maps.adt_sized_constraint.borrow_mut().insert(self.did, ty);\n-                ty\n+        match queries::adt_sized_constraint::try_get(tcx, DUMMY_SP, self.did) {\n+            Ok(ty) => ty,\n+            Err(_) => {\n+                debug!(\"adt_sized_constraint: {:?} is recursive\", self);\n+                // This should be reported as an error by `check_representable`.\n+                //\n+                // Consider the type as Sized in the meanwhile to avoid\n+                // further errors.\n+                tcx.types.err\n             }\n         }\n     }\n \n     fn sized_constraint_for_ty(&self,\n                                tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                               stack: &mut Vec<DefId>,\n                                ty: Ty<'tcx>)\n                                -> Vec<Ty<'tcx>> {\n         let result = match ty.sty {\n@@ -1791,23 +1727,23 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n             TyTuple(ref tys, _) => {\n                 match tys.last() {\n                     None => vec![],\n-                    Some(ty) => self.sized_constraint_for_ty(tcx, stack, ty)\n+                    Some(ty) => self.sized_constraint_for_ty(tcx, ty)\n                 }\n             }\n \n             TyAdt(adt, substs) => {\n                 // recursive case\n                 let adt_ty =\n-                    adt.calculate_sized_constraint_inner(tcx, stack)\n+                    adt.sized_constraint(tcx)\n                        .subst(tcx, substs);\n                 debug!(\"sized_constraint_for_ty({:?}) intermediate = {:?}\",\n                        ty, adt_ty);\n                 if let ty::TyTuple(ref tys, _) = adt_ty.sty {\n                     tys.iter().flat_map(|ty| {\n-                        self.sized_constraint_for_ty(tcx, stack, ty)\n+                        self.sized_constraint_for_ty(tcx, ty)\n                     }).collect()\n                 } else {\n-                    self.sized_constraint_for_ty(tcx, stack, adt_ty)\n+                    self.sized_constraint_for_ty(tcx, adt_ty)\n                 }\n             }\n \n@@ -2703,9 +2639,56 @@ fn associated_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n     panic!(\"associated item not found for def_id: {:?}\", def_id);\n }\n \n+/// Calculates the Sized-constraint.\n+///\n+/// As the Sized-constraint of enums can be a *set* of types,\n+/// the Sized-constraint may need to be a set also. Because introducing\n+/// a new type of IVar is currently a complex affair, the Sized-constraint\n+/// may be a tuple.\n+///\n+/// In fact, there are only a few options for the constraint:\n+///     - `bool`, if the type is always Sized\n+///     - an obviously-unsized type\n+///     - a type parameter or projection whose Sizedness can't be known\n+///     - a tuple of type parameters or projections, if there are multiple\n+///       such.\n+///     - a TyError, if a type contained itself. The representability\n+///       check should catch this case.\n+fn adt_sized_constraint<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                  def_id: DefId)\n+                                  -> Ty<'tcx> {\n+    let def = tcx.lookup_adt_def(def_id);\n+\n+    let tys: Vec<_> = def.variants.iter().flat_map(|v| {\n+        v.fields.last()\n+    }).flat_map(|f| {\n+        let ty = tcx.item_type(f.did);\n+        def.sized_constraint_for_ty(tcx, ty)\n+    }).collect();\n+\n+    let ty = match tys.len() {\n+        _ if tys.references_error() => tcx.types.err,\n+        0 => tcx.types.bool,\n+        1 => tys[0],\n+        _ => tcx.intern_tup(&tys[..], false)\n+    };\n+\n+    debug!(\"adt_sized_constraint: {:?} => {:?}\", def, ty);\n+\n+    ty\n+}\n+\n pub fn provide(providers: &mut ty::maps::Providers) {\n     *providers = ty::maps::Providers {\n         associated_item,\n+        adt_sized_constraint,\n+        ..*providers\n+    };\n+}\n+\n+pub fn provide_extern(providers: &mut ty::maps::Providers) {\n+    *providers = ty::maps::Providers {\n+        adt_sized_constraint,\n         ..*providers\n     };\n }"}, {"sha": "48d9719e76c4d0faa0924006d8e7fdd1c01280de", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2a17b84cbc9cbd36ad79bb1708d1714f1cf3787b/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a17b84cbc9cbd36ad79bb1708d1714f1cf3787b/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=2a17b84cbc9cbd36ad79bb1708d1714f1cf3787b", "patch": "@@ -898,6 +898,7 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n \n     let mut extern_providers = ty::maps::Providers::default();\n     cstore::provide(&mut extern_providers);\n+    ty::provide_extern(&mut extern_providers);\n \n     TyCtxt::create_and_enter(sess,\n                              local_providers,"}]}