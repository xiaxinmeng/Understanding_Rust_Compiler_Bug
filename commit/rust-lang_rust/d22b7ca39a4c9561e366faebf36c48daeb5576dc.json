{"sha": "d22b7ca39a4c9561e366faebf36c48daeb5576dc", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQyMmI3Y2EzOWE0Yzk1NjFlMzY2ZmFlYmYzNmM0OGRhZWI1NTc2ZGM=", "commit": {"author": {"name": "Elliott Slaughter", "email": "eslaughter@mozilla.com", "date": "2012-09-06T18:25:24Z"}, "committer": {"name": "Elliott Slaughter", "email": "eslaughter@mozilla.com", "date": "2012-09-07T16:21:22Z"}, "message": "gc: Documentation.", "tree": {"sha": "c9d839df94739c082fa6c083e084dc8be5b4fc15", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c9d839df94739c082fa6c083e084dc8be5b4fc15"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d22b7ca39a4c9561e366faebf36c48daeb5576dc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d22b7ca39a4c9561e366faebf36c48daeb5576dc", "html_url": "https://github.com/rust-lang/rust/commit/d22b7ca39a4c9561e366faebf36c48daeb5576dc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d22b7ca39a4c9561e366faebf36c48daeb5576dc/comments", "author": null, "committer": null, "parents": [{"sha": "8d17308ecaa8e49960c1ebcbb6ff99efae0eb4db", "url": "https://api.github.com/repos/rust-lang/rust/commits/8d17308ecaa8e49960c1ebcbb6ff99efae0eb4db", "html_url": "https://github.com/rust-lang/rust/commit/8d17308ecaa8e49960c1ebcbb6ff99efae0eb4db"}], "stats": {"total": 52, "additions": 52, "deletions": 0}, "files": [{"sha": "cdf258aa0aba2b567fa43fccf2e6012c32e588bd", "filename": "src/libcore/gc.rs", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/d22b7ca39a4c9561e366faebf36c48daeb5576dc/src%2Flibcore%2Fgc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d22b7ca39a4c9561e366faebf36c48daeb5576dc/src%2Flibcore%2Fgc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fgc.rs?ref=d22b7ca39a4c9561e366faebf36c48daeb5576dc", "patch": "@@ -1,3 +1,30 @@\n+/*! Precise Garbage Collector\n+\n+The precise GC exposes two functions, gc and\n+cleanup_stack_for_failure. The gc function is the entry point to the\n+garbage collector itself. The cleanup_stack_for_failure is the entry\n+point for GC-based cleanup.\n+\n+Precise GC depends on changes to LLVM's GC which add support for\n+automatic rooting and addrspace-based metadata marking. Rather than\n+explicitly rooting pointers with LLVM's gcroot intrinsic, the GC\n+merely creates allocas for pointers, and allows an LLVM pass to\n+automatically infer roots based on the allocas present in a function\n+(and live at a given location). The compiler communicates the type of\n+the pointer to LLVM by setting the addrspace of the pointer type. The\n+compiler then emits a map from addrspace to tydesc, which LLVM then\n+uses to match pointers with their tydesc. The GC reads the metadata\n+table produced by LLVM, and uses it to determine which glue functions\n+to call to free objects on their respective heaps.\n+\n+GC-based cleanup is a replacement for landing pads which relies on the\n+GC infrastructure to find pointers on the stack to cleanup. Whereas\n+the normal GC needs to walk task-local heap allocations, the cleanup\n+code needs to walk exchange heap allocations and stack-allocations\n+with destructors.\n+\n+*/\n+\n import stackwalk::Word;\n import libc::size_t;\n import libc::uintptr_t;\n@@ -27,6 +54,7 @@ extern mod rustrt {\n     fn rust_get_stack_segment() -> *StackSegment;\n }\n \n+// Is fp contained in segment?\n unsafe fn is_frame_in_segment(fp: *Word, segment: *StackSegment) -> bool {\n     let begin: Word = unsafe::reinterpret_cast(&segment);\n     let end: Word = unsafe::reinterpret_cast(&(*segment).end);\n@@ -37,6 +65,8 @@ unsafe fn is_frame_in_segment(fp: *Word, segment: *StackSegment) -> bool {\n \n type SafePoint = { sp_meta: *Word, fn_meta: *Word };\n \n+// Returns the safe point metadata for the given program counter, if\n+// any.\n unsafe fn is_safe_point(pc: *Word) -> Option<SafePoint> {\n     let module_meta = rustrt::rust_gc_metadata();\n     let num_safe_points_ptr: *u32 = unsafe::reinterpret_cast(&module_meta);\n@@ -48,6 +78,7 @@ unsafe fn is_safe_point(pc: *Word) -> Option<SafePoint> {\n         return None;\n     }\n \n+    // FIXME (#2997): Use binary rather than linear search.\n     let mut sp = 0 as Word;\n     while sp < num_safe_points {\n         let sp_loc = *ptr::offset(safe_points, sp*3) as *Word;\n@@ -74,6 +105,8 @@ unsafe fn align_to_pointer<T>(ptr: *T) -> *T {\n     return unsafe::reinterpret_cast(&ptr);\n }\n \n+// Walks the list of roots for the given safe point, and calls visitor\n+// on each root.\n unsafe fn walk_safe_point(fp: *Word, sp: SafePoint, visitor: Visitor) {\n     let fp_bytes: *u8 = unsafe::reinterpret_cast(&fp);\n     let sp_meta_u32s: *u32 = unsafe::reinterpret_cast(&sp.sp_meta);\n@@ -127,6 +160,10 @@ const stack:           Memory = 4;\n \n const need_cleanup:    Memory = exchange_heap | stack;\n \n+// Find and return the segment containing the given frame pointer. At\n+// stack segment boundaries, returns true for boundary, so that the\n+// caller can do any special handling to identify where the correct\n+// return address is in the stack frame.\n unsafe fn find_segment_for_frame(fp: *Word, segment: *StackSegment)\n     -> {segment: *StackSegment, boundary: bool} {\n     // Check if frame is in either current frame or previous frame.\n@@ -154,6 +191,8 @@ unsafe fn find_segment_for_frame(fp: *Word, segment: *StackSegment)\n     return {segment: segment, boundary: false};\n }\n \n+// Walks stack, searching for roots of the requested type, and passes\n+// each root to the visitor.\n unsafe fn walk_gc_roots(mem: Memory, sentinel: **Word, visitor: Visitor) {\n     let mut segment = rustrt::rust_get_stack_segment();\n     let mut last_ret: *Word = ptr::null();\n@@ -168,6 +207,15 @@ unsafe fn walk_gc_roots(mem: Memory, sentinel: **Word, visitor: Visitor) {\n             let {segment: next_segment, boundary: boundary} =\n                 find_segment_for_frame(frame.fp, segment);\n             segment = next_segment;\n+            // Each stack segment is bounded by a morestack frame. The\n+            // morestack frame includes two return addresses, one for\n+            // morestack itself, at the normal offset from the frame\n+            // pointer, and then a second return address for the\n+            // function prologue (which called morestack after\n+            // determining that it had hit the end of the stack).\n+            // Since morestack itself takes two parameters, the offset\n+            // for this second return address is 3 greater than the\n+            // return address for morestack.\n             let ret_offset = if boundary { 4 } else { 1 };\n             last_ret = *ptr::offset(frame.fp, ret_offset) as *Word;\n \n@@ -238,6 +286,10 @@ fn expect_sentinel() -> bool { true }\n #[cfg(nogc)]\n fn expect_sentinel() -> bool { false }\n \n+// Entry point for GC-based cleanup. Walks stack looking for exchange\n+// heap and stack allocations requiring drop, and runs all\n+// destructors.\n+//\n // This should only be called from fail, as it will drop the roots\n // which are *live* on the stack, rather than dropping those that are\n // dead."}]}