{"sha": "3d3d3732c0cbab77172c461d7d2d914fbc1652bc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNkM2QzNzMyYzBjYmFiNzcxNzJjNDYxZDdkMmQ5MTRmYmMxNjUyYmM=", "commit": {"author": {"name": "Philipp Krones", "email": "9744647+flip1995@users.noreply.github.com", "date": "2018-06-15T15:44:44Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-06-15T15:44:44Z"}, "message": "Merge pull request #2803 from Nemo157/trivially_copy_pass_by_ref\n\nNew Lint: Pass small trivially copyable objects by value", "tree": {"sha": "0f47c91a85bfb686cf151683aa39d57f359e1862", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0f47c91a85bfb686cf151683aa39d57f359e1862"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3d3d3732c0cbab77172c461d7d2d914fbc1652bc", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJbI97sCRBK7hj4Ov3rIwAAdHIIAAC9Zku/SBN3YXjzjbT4Rkxq\n851+5epRGDEgKCfoPpFLK05ZTYYKOEgcZAx8paVIXr7fNZ/EB0V6nmyNV7LVhjnc\nqeV/2VRqfwC3co6aRmRp4smWZj97IR5FOrRs0lbU0J1+huZAZaGiMPC1XyEBDb/7\nVbWiZgnmRY5Y7C51WSBFWikadTkchC+0ryfZTvOI76wZKJf+cmUfQkAhR9Y1VjM9\n0NJoX4FnoOBBChbFyJQQ7YMIGA3UwRVaEZGecq8YfLZEJR1s2YSxZgHPnF4sdFU5\n4vH1tWnSU/TL60u5HZTNAmIu3H8eemtCp1MEMTNUFemPtGxZPRlmVF+TAjAmnQg=\n=w/pY\n-----END PGP SIGNATURE-----\n", "payload": "tree 0f47c91a85bfb686cf151683aa39d57f359e1862\nparent 0c231128467514141a28cd51d4ecabe1431dd8b1\nparent 621fdcc3bcea3828cd25ee0801c39bc9c2bbafce\nauthor Philipp Krones <9744647+flip1995@users.noreply.github.com> 1529077484 +0200\ncommitter GitHub <noreply@github.com> 1529077484 +0200\n\nMerge pull request #2803 from Nemo157/trivially_copy_pass_by_ref\n\nNew Lint: Pass small trivially copyable objects by value"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3d3d3732c0cbab77172c461d7d2d914fbc1652bc", "html_url": "https://github.com/rust-lang/rust/commit/3d3d3732c0cbab77172c461d7d2d914fbc1652bc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3d3d3732c0cbab77172c461d7d2d914fbc1652bc/comments", "author": {"login": "flip1995", "id": 9744647, "node_id": "MDQ6VXNlcjk3NDQ2NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/9744647?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flip1995", "html_url": "https://github.com/flip1995", "followers_url": "https://api.github.com/users/flip1995/followers", "following_url": "https://api.github.com/users/flip1995/following{/other_user}", "gists_url": "https://api.github.com/users/flip1995/gists{/gist_id}", "starred_url": "https://api.github.com/users/flip1995/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flip1995/subscriptions", "organizations_url": "https://api.github.com/users/flip1995/orgs", "repos_url": "https://api.github.com/users/flip1995/repos", "events_url": "https://api.github.com/users/flip1995/events{/privacy}", "received_events_url": "https://api.github.com/users/flip1995/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0c231128467514141a28cd51d4ecabe1431dd8b1", "url": "https://api.github.com/repos/rust-lang/rust/commits/0c231128467514141a28cd51d4ecabe1431dd8b1", "html_url": "https://github.com/rust-lang/rust/commit/0c231128467514141a28cd51d4ecabe1431dd8b1"}, {"sha": "621fdcc3bcea3828cd25ee0801c39bc9c2bbafce", "url": "https://api.github.com/repos/rust-lang/rust/commits/621fdcc3bcea3828cd25ee0801c39bc9c2bbafce", "html_url": "https://github.com/rust-lang/rust/commit/621fdcc3bcea3828cd25ee0801c39bc9c2bbafce"}], "stats": {"total": 533, "additions": 431, "deletions": 102}, "files": [{"sha": "d3741d7880128b652f67985f35c6a102b69463fc", "filename": "clippy_lints/src/approx_const.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3d3d3732c0cbab77172c461d7d2d914fbc1652bc/clippy_lints%2Fsrc%2Fapprox_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d3d3732c0cbab77172c461d7d2d914fbc1652bc/clippy_lints%2Fsrc%2Fapprox_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fapprox_const.rs?ref=3d3d3732c0cbab77172c461d7d2d914fbc1652bc", "patch": "@@ -71,14 +71,14 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n \n fn check_lit(cx: &LateContext, lit: &Lit, e: &Expr) {\n     match lit.node {\n-        LitKind::Float(ref s, FloatTy::F32) => check_known_consts(cx, e, s, \"f32\"),\n-        LitKind::Float(ref s, FloatTy::F64) => check_known_consts(cx, e, s, \"f64\"),\n-        LitKind::FloatUnsuffixed(ref s) => check_known_consts(cx, e, s, \"f{32, 64}\"),\n+        LitKind::Float(s, FloatTy::F32) => check_known_consts(cx, e, s, \"f32\"),\n+        LitKind::Float(s, FloatTy::F64) => check_known_consts(cx, e, s, \"f64\"),\n+        LitKind::FloatUnsuffixed(s) => check_known_consts(cx, e, s, \"f{32, 64}\"),\n         _ => (),\n     }\n }\n \n-fn check_known_consts(cx: &LateContext, e: &Expr, s: &symbol::Symbol, module: &str) {\n+fn check_known_consts(cx: &LateContext, e: &Expr, s: symbol::Symbol, module: &str) {\n     let s = s.as_str();\n     if s.parse::<f64>().is_ok() {\n         for &(constant, name, min_digits) in KNOWN_CONSTS {"}, {"sha": "46ec02a3473e20241bdb344b5640c3f190be4c47", "filename": "clippy_lints/src/attrs.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3d3d3732c0cbab77172c461d7d2d914fbc1652bc/clippy_lints%2Fsrc%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d3d3732c0cbab77172c461d7d2d914fbc1652bc/clippy_lints%2Fsrc%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fattrs.rs?ref=3d3d3732c0cbab77172c461d7d2d914fbc1652bc", "patch": "@@ -151,7 +151,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for AttrPass {\n \n     fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx Item) {\n         if is_relevant_item(cx.tcx, item) {\n-            check_attrs(cx, item.span, &item.name, &item.attrs)\n+            check_attrs(cx, item.span, item.name, &item.attrs)\n         }\n         match item.node {\n             ItemExternCrate(_) | ItemUse(_, _) => {\n@@ -195,13 +195,13 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for AttrPass {\n \n     fn check_impl_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx ImplItem) {\n         if is_relevant_impl(cx.tcx, item) {\n-            check_attrs(cx, item.span, &item.name, &item.attrs)\n+            check_attrs(cx, item.span, item.name, &item.attrs)\n         }\n     }\n \n     fn check_trait_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx TraitItem) {\n         if is_relevant_trait(cx.tcx, item) {\n-            check_attrs(cx, item.span, &item.name, &item.attrs)\n+            check_attrs(cx, item.span, item.name, &item.attrs)\n         }\n     }\n }\n@@ -260,7 +260,7 @@ fn is_relevant_expr(tcx: TyCtxt, tables: &ty::TypeckTables, expr: &Expr) -> bool\n     }\n }\n \n-fn check_attrs(cx: &LateContext, span: Span, name: &Name, attrs: &[Attribute]) {\n+fn check_attrs(cx: &LateContext, span: Span, name: Name, attrs: &[Attribute]) {\n     if in_macro(span) {\n         return;\n     }"}, {"sha": "9f548b9e32088bfedf8b334601ff10c409a11bcc", "filename": "clippy_lints/src/bit_mask.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/3d3d3732c0cbab77172c461d7d2d914fbc1652bc/clippy_lints%2Fsrc%2Fbit_mask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d3d3732c0cbab77172c461d7d2d914fbc1652bc/clippy_lints%2Fsrc%2Fbit_mask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fbit_mask.rs?ref=3d3d3732c0cbab77172c461d7d2d914fbc1652bc", "patch": "@@ -112,9 +112,9 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for BitMask {\n         if let ExprBinary(ref cmp, ref left, ref right) = e.node {\n             if cmp.node.is_comparison() {\n                 if let Some(cmp_opt) = fetch_int_literal(cx, right) {\n-                    check_compare(cx, left, cmp.node, cmp_opt, &e.span)\n+                    check_compare(cx, left, cmp.node, cmp_opt, e.span)\n                 } else if let Some(cmp_val) = fetch_int_literal(cx, left) {\n-                    check_compare(cx, right, invert_cmp(cmp.node), cmp_val, &e.span)\n+                    check_compare(cx, right, invert_cmp(cmp.node), cmp_val, e.span)\n                 }\n             }\n         }\n@@ -156,7 +156,7 @@ fn invert_cmp(cmp: BinOp_) -> BinOp_ {\n }\n \n \n-fn check_compare(cx: &LateContext, bit_op: &Expr, cmp_op: BinOp_, cmp_value: u128, span: &Span) {\n+fn check_compare(cx: &LateContext, bit_op: &Expr, cmp_op: BinOp_, cmp_value: u128, span: Span) {\n     if let ExprBinary(ref op, ref left, ref right) = bit_op.node {\n         if op.node != BiBitAnd && op.node != BiBitOr {\n             return;\n@@ -167,15 +167,15 @@ fn check_compare(cx: &LateContext, bit_op: &Expr, cmp_op: BinOp_, cmp_value: u12\n     }\n }\n \n-fn check_bit_mask(cx: &LateContext, bit_op: BinOp_, cmp_op: BinOp_, mask_value: u128, cmp_value: u128, span: &Span) {\n+fn check_bit_mask(cx: &LateContext, bit_op: BinOp_, cmp_op: BinOp_, mask_value: u128, cmp_value: u128, span: Span) {\n     match cmp_op {\n         BiEq | BiNe => match bit_op {\n             BiBitAnd => if mask_value & cmp_value != cmp_value {\n                 if cmp_value != 0 {\n                     span_lint(\n                         cx,\n                         BAD_BIT_MASK,\n-                        *span,\n+                        span,\n                         &format!(\n                             \"incompatible bit mask: `_ & {}` can never be equal to `{}`\",\n                             mask_value,\n@@ -184,13 +184,13 @@ fn check_bit_mask(cx: &LateContext, bit_op: BinOp_, cmp_op: BinOp_, mask_value:\n                     );\n                 }\n             } else if mask_value == 0 {\n-                span_lint(cx, BAD_BIT_MASK, *span, \"&-masking with zero\");\n+                span_lint(cx, BAD_BIT_MASK, span, \"&-masking with zero\");\n             },\n             BiBitOr => if mask_value | cmp_value != cmp_value {\n                 span_lint(\n                     cx,\n                     BAD_BIT_MASK,\n-                    *span,\n+                    span,\n                     &format!(\n                         \"incompatible bit mask: `_ | {}` can never be equal to `{}`\",\n                         mask_value,\n@@ -205,63 +205,63 @@ fn check_bit_mask(cx: &LateContext, bit_op: BinOp_, cmp_op: BinOp_, mask_value:\n                 span_lint(\n                     cx,\n                     BAD_BIT_MASK,\n-                    *span,\n+                    span,\n                     &format!(\n                         \"incompatible bit mask: `_ & {}` will always be lower than `{}`\",\n                         mask_value,\n                         cmp_value\n                     ),\n                 );\n             } else if mask_value == 0 {\n-                span_lint(cx, BAD_BIT_MASK, *span, \"&-masking with zero\");\n+                span_lint(cx, BAD_BIT_MASK, span, \"&-masking with zero\");\n             },\n             BiBitOr => if mask_value >= cmp_value {\n                 span_lint(\n                     cx,\n                     BAD_BIT_MASK,\n-                    *span,\n+                    span,\n                     &format!(\n                         \"incompatible bit mask: `_ | {}` will never be lower than `{}`\",\n                         mask_value,\n                         cmp_value\n                     ),\n                 );\n             } else {\n-                check_ineffective_lt(cx, *span, mask_value, cmp_value, \"|\");\n+                check_ineffective_lt(cx, span, mask_value, cmp_value, \"|\");\n             },\n-            BiBitXor => check_ineffective_lt(cx, *span, mask_value, cmp_value, \"^\"),\n+            BiBitXor => check_ineffective_lt(cx, span, mask_value, cmp_value, \"^\"),\n             _ => (),\n         },\n         BiLe | BiGt => match bit_op {\n             BiBitAnd => if mask_value <= cmp_value {\n                 span_lint(\n                     cx,\n                     BAD_BIT_MASK,\n-                    *span,\n+                    span,\n                     &format!(\n                         \"incompatible bit mask: `_ & {}` will never be higher than `{}`\",\n                         mask_value,\n                         cmp_value\n                     ),\n                 );\n             } else if mask_value == 0 {\n-                span_lint(cx, BAD_BIT_MASK, *span, \"&-masking with zero\");\n+                span_lint(cx, BAD_BIT_MASK, span, \"&-masking with zero\");\n             },\n             BiBitOr => if mask_value > cmp_value {\n                 span_lint(\n                     cx,\n                     BAD_BIT_MASK,\n-                    *span,\n+                    span,\n                     &format!(\n                         \"incompatible bit mask: `_ | {}` will always be higher than `{}`\",\n                         mask_value,\n                         cmp_value\n                     ),\n                 );\n             } else {\n-                check_ineffective_gt(cx, *span, mask_value, cmp_value, \"|\");\n+                check_ineffective_gt(cx, span, mask_value, cmp_value, \"|\");\n             },\n-            BiBitXor => check_ineffective_gt(cx, *span, mask_value, cmp_value, \"^\"),\n+            BiBitXor => check_ineffective_gt(cx, span, mask_value, cmp_value, \"^\"),\n             _ => (),\n         },\n         _ => (),"}, {"sha": "19761fbe8649de34880fdf5a03f5ad33c4884633", "filename": "clippy_lints/src/eq_op.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3d3d3732c0cbab77172c461d7d2d914fbc1652bc/clippy_lints%2Fsrc%2Feq_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d3d3732c0cbab77172c461d7d2d914fbc1652bc/clippy_lints%2Fsrc%2Feq_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Feq_op.rs?ref=3d3d3732c0cbab77172c461d7d2d914fbc1652bc", "patch": "@@ -52,7 +52,7 @@ impl LintPass for EqOp {\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for EqOp {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr) {\n-        if let ExprBinary(ref op, ref left, ref right) = e.node {\n+        if let ExprBinary(op, ref left, ref right) = e.node {\n             if in_macro(e.span) {\n                 return;\n             }\n@@ -157,7 +157,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for EqOp {\n }\n \n \n-fn is_valid_operator(op: &BinOp) -> bool {\n+fn is_valid_operator(op: BinOp) -> bool {\n     match op.node {\n         BiSub | BiDiv | BiEq | BiLt | BiLe | BiGt | BiGe | BiNe | BiAnd | BiOr | BiBitXor | BiBitAnd | BiBitOr => true,\n         _ => false,"}, {"sha": "c33a3b50185feb30f10d8193f423b1d55eac9ff6", "filename": "clippy_lints/src/excessive_precision.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3d3d3732c0cbab77172c461d7d2d914fbc1652bc/clippy_lints%2Fsrc%2Fexcessive_precision.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d3d3732c0cbab77172c461d7d2d914fbc1652bc/clippy_lints%2Fsrc%2Fexcessive_precision.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fexcessive_precision.rs?ref=3d3d3732c0cbab77172c461d7d2d914fbc1652bc", "patch": "@@ -46,9 +46,9 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ExcessivePrecision {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr) {\n         if_chain! {\n             let ty = cx.tables.expr_ty(expr);\n-            if let TypeVariants::TyFloat(ref fty) = ty.sty;\n+            if let TypeVariants::TyFloat(fty) = ty.sty;\n             if let hir::ExprLit(ref lit) = expr.node;\n-            if let LitKind::Float(ref sym, _) | LitKind::FloatUnsuffixed(ref sym) = lit.node;\n+            if let LitKind::Float(sym, _) | LitKind::FloatUnsuffixed(sym) = lit.node;\n             if let Some(sugg) = self.check(sym, fty);\n             then {\n                 span_lint_and_sugg(\n@@ -66,7 +66,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ExcessivePrecision {\n \n impl ExcessivePrecision {\n     // None if nothing to lint, Some(suggestion) if lint neccessary\n-    fn check(&self, sym: &Symbol, fty: &FloatTy) -> Option<String> {\n+    fn check(&self, sym: Symbol, fty: FloatTy) -> Option<String> {\n         let max = max_digits(fty);\n         let sym_str = sym.as_str();\n         if dot_zero_exclusion(&sym_str) {\n@@ -79,7 +79,7 @@ impl ExcessivePrecision {\n         let digits = count_digits(&sym_str);\n         if digits > max as usize {\n             let formatter = FloatFormat::new(&sym_str);\n-            let sr = match *fty {\n+            let sr = match fty {\n                 FloatTy::F32 => sym_str.parse::<f32>().map(|f| formatter.format(f)),\n                 FloatTy::F64 => sym_str.parse::<f64>().map(|f| formatter.format(f)),\n             };\n@@ -115,7 +115,7 @@ fn dot_zero_exclusion(s: &str) -> bool {\n     }\n }\n \n-fn max_digits(fty: &FloatTy) -> u32 {\n+fn max_digits(fty: FloatTy) -> u32 {\n     match fty {\n         FloatTy::F32 => f32::DIGITS,\n         FloatTy::F64 => f64::DIGITS,"}, {"sha": "904d0b1d245463937bc2c5c18a94b16f9c0ce12d", "filename": "clippy_lints/src/functions.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3d3d3732c0cbab77172c461d7d2d914fbc1652bc/clippy_lints%2Fsrc%2Ffunctions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d3d3732c0cbab77172c461d7d2d914fbc1652bc/clippy_lints%2Fsrc%2Ffunctions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffunctions.rs?ref=3d3d3732c0cbab77172c461d7d2d914fbc1652bc", "patch": "@@ -126,7 +126,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Functions {\n }\n \n impl<'a, 'tcx> Functions {\n-    fn check_arg_number(&self, cx: &LateContext, decl: &hir::FnDecl, span: Span) {\n+    fn check_arg_number(self, cx: &LateContext, decl: &hir::FnDecl, span: Span) {\n         let args = decl.inputs.len() as u64;\n         if args > self.threshold {\n             span_lint(\n@@ -139,7 +139,7 @@ impl<'a, 'tcx> Functions {\n     }\n \n     fn check_raw_ptr(\n-        &self,\n+        self,\n         cx: &LateContext<'a, 'tcx>,\n         unsafety: hir::Unsafety,\n         decl: &'tcx hir::FnDecl,"}, {"sha": "1325ad66857b5360ee687dbb21453757bfb6855a", "filename": "clippy_lints/src/inline_fn_without_body.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3d3d3732c0cbab77172c461d7d2d914fbc1652bc/clippy_lints%2Fsrc%2Finline_fn_without_body.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d3d3732c0cbab77172c461d7d2d914fbc1652bc/clippy_lints%2Fsrc%2Finline_fn_without_body.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Finline_fn_without_body.rs?ref=3d3d3732c0cbab77172c461d7d2d914fbc1652bc", "patch": "@@ -38,12 +38,12 @@ impl LintPass for Pass {\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n     fn check_trait_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx TraitItem) {\n         if let TraitItemKind::Method(_, TraitMethod::Required(_)) = item.node {\n-            check_attrs(cx, &item.name, &item.attrs);\n+            check_attrs(cx, item.name, &item.attrs);\n         }\n     }\n }\n \n-fn check_attrs(cx: &LateContext, name: &Name, attrs: &[Attribute]) {\n+fn check_attrs(cx: &LateContext, name: Name, attrs: &[Attribute]) {\n     for attr in attrs {\n         if attr.name() != \"inline\" {\n             continue;"}, {"sha": "bac479deda66032481a72b9a1de3b760efa780c1", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3d3d3732c0cbab77172c461d7d2d914fbc1652bc/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d3d3732c0cbab77172c461d7d2d914fbc1652bc/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=3d3d3732c0cbab77172c461d7d2d914fbc1652bc", "patch": "@@ -196,6 +196,7 @@ pub mod suspicious_trait_impl;\n pub mod swap;\n pub mod temporary_assignment;\n pub mod transmute;\n+pub mod trivially_copy_pass_by_ref;\n pub mod types;\n pub mod unicode;\n pub mod unsafe_removed_from_name;\n@@ -399,6 +400,10 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry) {\n     reg.register_late_lint_pass(box large_enum_variant::LargeEnumVariant::new(conf.enum_variant_size_threshold));\n     reg.register_late_lint_pass(box explicit_write::Pass);\n     reg.register_late_lint_pass(box needless_pass_by_value::NeedlessPassByValue);\n+    reg.register_late_lint_pass(box trivially_copy_pass_by_ref::TriviallyCopyPassByRef::new(\n+            conf.trivial_copy_size_limit,\n+            &reg.sess.target,\n+    ));\n     reg.register_early_lint_pass(box literal_representation::LiteralDigitGrouping);\n     reg.register_early_lint_pass(box literal_representation::LiteralRepresentation::new(\n             conf.literal_representation_threshold\n@@ -672,6 +677,7 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry) {\n         transmute::TRANSMUTE_PTR_TO_REF,\n         transmute::USELESS_TRANSMUTE,\n         transmute::WRONG_TRANSMUTE,\n+        trivially_copy_pass_by_ref::TRIVIALLY_COPY_PASS_BY_REF,\n         types::ABSURD_EXTREME_COMPARISONS,\n         types::BORROWED_BOX,\n         types::BOX_VEC,\n@@ -916,6 +922,7 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry) {\n         methods::SINGLE_CHAR_PATTERN,\n         misc::CMP_OWNED,\n         mutex_atomic::MUTEX_ATOMIC,\n+        trivially_copy_pass_by_ref::TRIVIALLY_COPY_PASS_BY_REF,\n         types::BOX_VEC,\n         vec::USELESS_VEC,\n     ]);"}, {"sha": "09b66b872e9167d9ca97b9c682bcc304751fa813", "filename": "clippy_lints/src/literal_representation.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/3d3d3732c0cbab77172c461d7d2d914fbc1652bc/clippy_lints%2Fsrc%2Fliteral_representation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d3d3732c0cbab77172c461d7d2d914fbc1652bc/clippy_lints%2Fsrc%2Fliteral_representation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fliteral_representation.rs?ref=3d3d3732c0cbab77172c461d7d2d914fbc1652bc", "patch": "@@ -227,36 +227,36 @@ enum WarningType {\n }\n \n impl WarningType {\n-    pub fn display(&self, grouping_hint: &str, cx: &EarlyContext, span: &syntax_pos::Span) {\n-        match *self {\n+    pub fn display(&self, grouping_hint: &str, cx: &EarlyContext, span: syntax_pos::Span) {\n+        match self {\n             WarningType::UnreadableLiteral => span_lint_and_sugg(\n                 cx,\n                 UNREADABLE_LITERAL,\n-                *span,\n+                span,\n                 \"long literal lacking separators\",\n                 \"consider\",\n                 grouping_hint.to_owned(),\n             ),\n             WarningType::LargeDigitGroups => span_lint_and_sugg(\n                 cx,\n                 LARGE_DIGIT_GROUPS,\n-                *span,\n+                span,\n                 \"digit groups should be smaller\",\n                 \"consider\",\n                 grouping_hint.to_owned(),\n             ),\n             WarningType::InconsistentDigitGrouping => span_lint_and_sugg(\n                 cx,\n                 INCONSISTENT_DIGIT_GROUPING,\n-                *span,\n+                span,\n                 \"digits grouped inconsistently by underscores\",\n                 \"consider\",\n                 grouping_hint.to_owned(),\n             ),\n             WarningType::DecimalRepresentation => span_lint_and_sugg(\n                 cx,\n                 DECIMAL_LITERAL_REPRESENTATION,\n-                *span,\n+                span,\n                 \"integer literal has a better hexadecimal representation\",\n                 \"consider\",\n                 grouping_hint.to_owned(),\n@@ -291,7 +291,7 @@ impl EarlyLintPass for LiteralDigitGrouping {\n }\n \n impl LiteralDigitGrouping {\n-    fn check_lit(&self, cx: &EarlyContext, lit: &Lit) {\n+    fn check_lit(self, cx: &EarlyContext, lit: &Lit) {\n         match lit.node {\n             LitKind::Int(..) => {\n                 // Lint integral literals.\n@@ -302,7 +302,7 @@ impl LiteralDigitGrouping {\n                     then {\n                         let digit_info = DigitInfo::new(&src, false);\n                         let _ = Self::do_lint(digit_info.digits).map_err(|warning_type| {\n-                            warning_type.display(&digit_info.grouping_hint(), cx, &lit.span)\n+                            warning_type.display(&digit_info.grouping_hint(), cx, lit.span)\n                         });\n                     }\n                 }\n@@ -337,15 +337,15 @@ impl LiteralDigitGrouping {\n                                             if !consistent {\n                                                 WarningType::InconsistentDigitGrouping.display(&digit_info.grouping_hint(),\n                                                 cx,\n-                                                &lit.span);\n+                                                lit.span);\n                                             }\n                                         })\n                                     .map_err(|warning_type| warning_type.display(&digit_info.grouping_hint(),\n                                     cx,\n-                                    &lit.span));\n+                                    lit.span));\n                                 }\n                             })\n-                        .map_err(|warning_type| warning_type.display(&digit_info.grouping_hint(), cx, &lit.span));\n+                        .map_err(|warning_type| warning_type.display(&digit_info.grouping_hint(), cx, lit.span));\n                     }\n                 }\n             },\n@@ -436,7 +436,7 @@ impl LiteralRepresentation {\n             threshold,\n         }\n     }\n-    fn check_lit(&self, cx: &EarlyContext, lit: &Lit) {\n+    fn check_lit(self, cx: &EarlyContext, lit: &Lit) {\n         // Lint integral literals.\n         if_chain! {\n             if let LitKind::Int(..) = lit.node;\n@@ -457,7 +457,7 @@ impl LiteralRepresentation {\n                     let hex = format!(\"{:#X}\", val);\n                     let digit_info = DigitInfo::new(&hex[..], false);\n                     let _ = Self::do_lint(digit_info.digits).map_err(|warning_type| {\n-                        warning_type.display(&digit_info.grouping_hint(), cx, &lit.span)\n+                        warning_type.display(&digit_info.grouping_hint(), cx, lit.span)\n                     });\n                 }\n             }"}, {"sha": "cfea6053fac9a38b611b0a4f7863a57490ee37e5", "filename": "clippy_lints/src/loops.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/3d3d3732c0cbab77172c461d7d2d914fbc1652bc/clippy_lints%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d3d3732c0cbab77172c461d7d2d914fbc1652bc/clippy_lints%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops.rs?ref=3d3d3732c0cbab77172c461d7d2d914fbc1652bc", "patch": "@@ -412,7 +412,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n         // check for never_loop\n         match expr.node {\n             ExprWhile(_, ref block, _) | ExprLoop(ref block, _, _) => {\n-                match never_loop_block(block, &expr.id) {\n+                match never_loop_block(block, expr.id) {\n                     NeverLoopResult::AlwaysBreak =>\n                         span_lint(cx, NEVER_LOOP, expr.span, \"this loop never actually loops\"),\n                     NeverLoopResult::MayContinueMainLoop | NeverLoopResult::Otherwise => (),\n@@ -575,7 +575,7 @@ fn combine_branches(b1: NeverLoopResult, b2: NeverLoopResult) -> NeverLoopResult\n     }\n }\n \n-fn never_loop_block(block: &Block, main_loop_id: &NodeId) -> NeverLoopResult {\n+fn never_loop_block(block: &Block, main_loop_id: NodeId) -> NeverLoopResult {\n     let stmts = block.stmts.iter().map(stmt_to_expr);\n     let expr = once(block.expr.as_ref().map(|p| &**p));\n     let mut iter = stmts.chain(expr).filter_map(|e| e);\n@@ -596,7 +596,7 @@ fn decl_to_expr(decl: &Decl) -> Option<&Expr> {\n     }\n }\n \n-fn never_loop_expr(expr: &Expr, main_loop_id: &NodeId) -> NeverLoopResult {\n+fn never_loop_expr(expr: &Expr, main_loop_id: NodeId) -> NeverLoopResult {\n     match expr.node {\n         ExprBox(ref e) |\n         ExprUnary(_, ref e) |\n@@ -643,7 +643,7 @@ fn never_loop_expr(expr: &Expr, main_loop_id: &NodeId) -> NeverLoopResult {\n         ExprAgain(d) => {\n             let id = d.target_id\n                 .expect(\"target id can only be missing in the presence of compilation errors\");\n-            if id == *main_loop_id {\n+            if id == main_loop_id {\n                 NeverLoopResult::MayContinueMainLoop\n             } else {\n                 NeverLoopResult::AlwaysBreak\n@@ -668,17 +668,17 @@ fn never_loop_expr(expr: &Expr, main_loop_id: &NodeId) -> NeverLoopResult {\n     }\n }\n \n-fn never_loop_expr_seq<'a, T: Iterator<Item=&'a Expr>>(es: &mut T, main_loop_id: &NodeId) -> NeverLoopResult {\n+fn never_loop_expr_seq<'a, T: Iterator<Item=&'a Expr>>(es: &mut T, main_loop_id: NodeId) -> NeverLoopResult {\n     es.map(|e| never_loop_expr(e, main_loop_id))\n         .fold(NeverLoopResult::Otherwise, combine_seq)\n }\n \n-fn never_loop_expr_all<'a, T: Iterator<Item=&'a Expr>>(es: &mut T, main_loop_id: &NodeId) -> NeverLoopResult {\n+fn never_loop_expr_all<'a, T: Iterator<Item=&'a Expr>>(es: &mut T, main_loop_id: NodeId) -> NeverLoopResult {\n     es.map(|e| never_loop_expr(e, main_loop_id))\n         .fold(NeverLoopResult::Otherwise, combine_both)\n }\n \n-fn never_loop_expr_branch<'a, T: Iterator<Item=&'a Expr>>(e: &mut T, main_loop_id: &NodeId) -> NeverLoopResult {\n+fn never_loop_expr_branch<'a, T: Iterator<Item=&'a Expr>>(e: &mut T, main_loop_id: NodeId) -> NeverLoopResult {\n     e.map(|e| never_loop_expr(e, main_loop_id))\n         .fold(NeverLoopResult::AlwaysBreak, combine_branches)\n }\n@@ -1032,7 +1032,7 @@ fn check_for_loop_range<'a, 'tcx>(\n                 };\n \n                 let take = if let Some(end) = *end {\n-                    if is_len_call(end, &indexed) {\n+                    if is_len_call(end, indexed) {\n                         \"\".to_owned()\n                     } else {\n                         match limits {\n@@ -1096,14 +1096,14 @@ fn check_for_loop_range<'a, 'tcx>(\n     }\n }\n \n-fn is_len_call(expr: &Expr, var: &Name) -> bool {\n+fn is_len_call(expr: &Expr, var: Name) -> bool {\n     if_chain! {\n         if let ExprMethodCall(ref method, _, ref len_args) = expr.node;\n         if len_args.len() == 1;\n         if method.name == \"len\";\n         if let ExprPath(QPath::Resolved(_, ref path)) = len_args[0].node;\n         if path.segments.len() == 1;\n-        if path.segments[0].name == *var;\n+        if path.segments[0].name == var;\n         then {\n             return true;\n         }"}, {"sha": "6d93e5bbd095d51f88e6f840d7041f8fd42505af", "filename": "clippy_lints/src/methods.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3d3d3732c0cbab77172c461d7d2d914fbc1652bc/clippy_lints%2Fsrc%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d3d3732c0cbab77172c461d7d2d914fbc1652bc/clippy_lints%2Fsrc%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods.rs?ref=3d3d3732c0cbab77172c461d7d2d914fbc1652bc", "patch": "@@ -2079,8 +2079,8 @@ impl SelfKind {\n         }\n     }\n \n-    fn description(&self) -> &'static str {\n-        match *self {\n+    fn description(self) -> &'static str {\n+        match self {\n             SelfKind::Value => \"self by value\",\n             SelfKind::Ref => \"self by reference\",\n             SelfKind::RefMut => \"self by mutable reference\",\n@@ -2164,13 +2164,13 @@ enum OutType {\n }\n \n impl OutType {\n-    fn matches(&self, ty: &hir::FunctionRetTy) -> bool {\n+    fn matches(self, ty: &hir::FunctionRetTy) -> bool {\n         match (self, ty) {\n-            (&OutType::Unit, &hir::DefaultReturn(_)) => true,\n-            (&OutType::Unit, &hir::Return(ref ty)) if ty.node == hir::TyTup(vec![].into()) => true,\n-            (&OutType::Bool, &hir::Return(ref ty)) if is_bool(ty) => true,\n-            (&OutType::Any, &hir::Return(ref ty)) if ty.node != hir::TyTup(vec![].into()) => true,\n-            (&OutType::Ref, &hir::Return(ref ty)) => matches!(ty.node, hir::TyRptr(_, _)),\n+            (OutType::Unit, &hir::DefaultReturn(_)) => true,\n+            (OutType::Unit, &hir::Return(ref ty)) if ty.node == hir::TyTup(vec![].into()) => true,\n+            (OutType::Bool, &hir::Return(ref ty)) if is_bool(ty) => true,\n+            (OutType::Any, &hir::Return(ref ty)) if ty.node != hir::TyTup(vec![].into()) => true,\n+            (OutType::Ref, &hir::Return(ref ty)) => matches!(ty.node, hir::TyRptr(_, _)),\n             _ => false,\n         }\n     }"}, {"sha": "fcd88f9f21906cf21ae3e3418ffc684750238bf3", "filename": "clippy_lints/src/misc_early.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d3d3732c0cbab77172c461d7d2d914fbc1652bc/clippy_lints%2Fsrc%2Fmisc_early.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d3d3732c0cbab77172c461d7d2d914fbc1652bc/clippy_lints%2Fsrc%2Fmisc_early.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc_early.rs?ref=3d3d3732c0cbab77172c461d7d2d914fbc1652bc", "patch": "@@ -349,7 +349,7 @@ impl EarlyLintPass for MiscEarly {\n }\n \n impl MiscEarly {\n-    fn check_lit(&self, cx: &EarlyContext, lit: &Lit) {\n+    fn check_lit(self, cx: &EarlyContext, lit: &Lit) {\n         if_chain! {\n             if let LitKind::Int(value, ..) = lit.node;\n             if let Some(src) = snippet_opt(cx, lit.span);"}, {"sha": "e3ccfec46857f597beb5608ed08ff321830154ed", "filename": "clippy_lints/src/suspicious_trait_impl.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3d3d3732c0cbab77172c461d7d2d914fbc1652bc/clippy_lints%2Fsrc%2Fsuspicious_trait_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d3d3732c0cbab77172c461d7d2d914fbc1652bc/clippy_lints%2Fsrc%2Fsuspicious_trait_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fsuspicious_trait_impl.rs?ref=3d3d3732c0cbab77172c461d7d2d914fbc1652bc", "patch": "@@ -92,7 +92,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for SuspiciousImpl {\n             if let Some(impl_trait) = check_binop(\n                 cx,\n                 expr,\n-                &binop.node,\n+                binop.node,\n                 &[\"Add\", \"Sub\", \"Mul\", \"Div\"],\n                 &[BiAdd, BiSub, BiMul, BiDiv],\n             ) {\n@@ -110,7 +110,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for SuspiciousImpl {\n             if let Some(impl_trait) = check_binop(\n                 cx,\n                 expr,\n-                &binop.node,\n+                binop.node,\n                 &[\n                     \"AddAssign\",\n                     \"SubAssign\",\n@@ -144,7 +144,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for SuspiciousImpl {\n fn check_binop<'a>(\n     cx: &LateContext,\n     expr: &hir::Expr,\n-    binop: &hir::BinOp_,\n+    binop: hir::BinOp_,\n     traits: &[&'a str],\n     expected_ops: &[hir::BinOp_],\n ) -> Option<&'a str> {\n@@ -169,7 +169,7 @@ fn check_binop<'a>(\n         if let hir::map::Node::NodeItem(item) = cx.tcx.hir.get(parent_impl);\n         if let hir::Item_::ItemImpl(_, _, _, _, Some(ref trait_ref), _, _) = item.node;\n         if let Some(idx) = trait_ids.iter().position(|&tid| tid == trait_ref.path.def.def_id());\n-        if *binop != expected_ops[idx];\n+        if binop != expected_ops[idx];\n         then{\n             return Some(traits[idx])\n         }"}, {"sha": "4c8d0c9dab8e141e1c18155532d47a7c9b7828e9", "filename": "clippy_lints/src/trivially_copy_pass_by_ref.rs", "status": "added", "additions": 144, "deletions": 0, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/3d3d3732c0cbab77172c461d7d2d914fbc1652bc/clippy_lints%2Fsrc%2Ftrivially_copy_pass_by_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d3d3732c0cbab77172c461d7d2d914fbc1652bc/clippy_lints%2Fsrc%2Ftrivially_copy_pass_by_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftrivially_copy_pass_by_ref.rs?ref=3d3d3732c0cbab77172c461d7d2d914fbc1652bc", "patch": "@@ -0,0 +1,144 @@\n+use std::cmp;\n+\n+use rustc::hir::*;\n+use rustc::hir::map::*;\n+use rustc::hir::intravisit::FnKind;\n+use rustc::lint::*;\n+use rustc::ty::TypeVariants;\n+use rustc::session::config::Config as SessionConfig;\n+use rustc_target::spec::abi::Abi;\n+use rustc_target::abi::LayoutOf;\n+use syntax::ast::NodeId;\n+use syntax_pos::Span;\n+use crate::utils::{in_macro, is_copy, is_self, span_lint_and_sugg, snippet};\n+\n+/// **What it does:** Checks for functions taking arguments by reference, where\n+/// the argument type is `Copy` and small enough to be more efficient to always\n+/// pass by value.\n+///\n+/// **Why is this bad?** In many calling conventions instances of structs will\n+/// be passed through registers if they fit into two or less general purpose\n+/// registers.\n+///\n+/// **Known problems:** This lint is target register size dependent, it is\n+/// limited to 32-bit to try and reduce portability problems between 32 and\n+/// 64-bit, but if you are compiling for 8 or 16-bit targets then the limit\n+/// will be different.\n+///\n+/// The configuration option `trivial_copy_size_limit` can be set to override\n+/// this limit for a project.\n+///\n+/// **Example:**\n+/// ```rust\n+/// fn foo(v: &u32) {\n+///     assert_eq!(v, 42);\n+/// }\n+/// // should be\n+/// fn foo(v: u32) {\n+///     assert_eq!(v, 42);\n+/// }\n+/// ```\n+declare_clippy_lint! {\n+    pub TRIVIALLY_COPY_PASS_BY_REF,\n+    perf,\n+    \"functions taking small copyable arguments by reference\"\n+}\n+\n+pub struct TriviallyCopyPassByRef {\n+    limit: u64,\n+}\n+\n+impl TriviallyCopyPassByRef {\n+    pub fn new(limit: Option<u64>, target: &SessionConfig) -> Self {\n+        let limit = limit.unwrap_or_else(|| {\n+            let bit_width = target.usize_ty.bit_width().expect(\"usize should have a width\") as u64;\n+            // Cap the calculated bit width at 32-bits to reduce\n+            // portability problems between 32 and 64-bit targets\n+            let bit_width = cmp::min(bit_width, 32);\n+            let byte_width = bit_width / 8;\n+            // Use a limit of 2 times the register bit width\n+            byte_width * 2\n+        });\n+        Self { limit }\n+    }\n+}\n+\n+impl LintPass for TriviallyCopyPassByRef {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array![TRIVIALLY_COPY_PASS_BY_REF]\n+    }\n+}\n+\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TriviallyCopyPassByRef {\n+    fn check_fn(\n+        &mut self,\n+        cx: &LateContext<'a, 'tcx>,\n+        kind: FnKind<'tcx>,\n+        decl: &'tcx FnDecl,\n+        body: &'tcx Body,\n+        span: Span,\n+        node_id: NodeId,\n+    ) {\n+        if in_macro(span) {\n+            return;\n+        }\n+\n+        match kind {\n+            FnKind::ItemFn(.., abi, _, attrs) => {\n+                if abi != Abi::Rust {\n+                    return;\n+                }\n+                for a in attrs {\n+                    if a.meta_item_list().is_some() && a.name() == \"proc_macro_derive\" {\n+                        return;\n+                    }\n+                }\n+            },\n+            FnKind::Method(..) => (),\n+            _ => return,\n+        }\n+\n+        // Exclude non-inherent impls\n+        if let Some(NodeItem(item)) = cx.tcx.hir.find(cx.tcx.hir.get_parent_node(node_id)) {\n+            if matches!(item.node, ItemImpl(_, _, _, _, Some(_), _, _) |\n+                ItemTrait(..))\n+            {\n+                return;\n+            }\n+        }\n+\n+        let fn_def_id = cx.tcx.hir.local_def_id(node_id);\n+\n+        let fn_sig = cx.tcx.fn_sig(fn_def_id);\n+        let fn_sig = cx.tcx.erase_late_bound_regions(&fn_sig);\n+\n+        for ((input, &ty), arg) in decl.inputs.iter().zip(fn_sig.inputs()).zip(&body.arguments) {\n+            // All spans generated from a proc-macro invocation are the same...\n+            if span == input.span {\n+                return;\n+            }\n+\n+            if_chain! {\n+                if let TypeVariants::TyRef(_, ty, Mutability::MutImmutable) = ty.sty;\n+                if is_copy(cx, ty);\n+                if let Some(size) = cx.layout_of(ty).ok().map(|l| l.size.bytes());\n+                if size <= self.limit;\n+                if let Ty_::TyRptr(_, MutTy { ty: ref decl_ty, .. }) = input.node;\n+                then {\n+                    let value_type = if is_self(arg) {\n+                        \"self\".into()\n+                    } else {\n+                        snippet(cx, decl_ty.span, \"_\").into()\n+                    };\n+                    span_lint_and_sugg(\n+                        cx,\n+                        TRIVIALLY_COPY_PASS_BY_REF,\n+                        input.span,\n+                        \"this argument is passed by reference, but would be more efficient if passed by value\",\n+                        \"consider passing by value instead\",\n+                        value_type);\n+                }\n+            }\n+        }\n+    }\n+}"}, {"sha": "0888aef89feea3068bf06da4962b715039c02fbb", "filename": "clippy_lints/src/types.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3d3d3732c0cbab77172c461d7d2d914fbc1652bc/clippy_lints%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d3d3732c0cbab77172c461d7d2d914fbc1652bc/clippy_lints%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes.rs?ref=3d3d3732c0cbab77172c461d7d2d914fbc1652bc", "patch": "@@ -1606,12 +1606,12 @@ fn node_as_const_fullint<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr)\n     }\n }\n \n-fn err_upcast_comparison(cx: &LateContext, span: &Span, expr: &Expr, always: bool) {\n+fn err_upcast_comparison(cx: &LateContext, span: Span, expr: &Expr, always: bool) {\n     if let ExprCast(ref cast_val, _) = expr.node {\n         span_lint(\n             cx,\n             INVALID_UPCAST_COMPARISONS,\n-            *span,\n+            span,\n             &format!(\n                 \"because of the numeric bounds on `{}` prior to casting, this expression is always {}\",\n                 snippet(cx, cast_val.span, \"the expression\"),\n@@ -1623,7 +1623,7 @@ fn err_upcast_comparison(cx: &LateContext, span: &Span, expr: &Expr, always: boo\n \n fn upcast_comparison_bounds_err<'a, 'tcx>(\n     cx: &LateContext<'a, 'tcx>,\n-    span: &Span,\n+    span: Span,\n     rel: comparisons::Rel,\n     lhs_bounds: Option<(FullInt, FullInt)>,\n     lhs: &'tcx Expr,\n@@ -1684,8 +1684,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for InvalidUpcastComparisons {\n             let lhs_bounds = numeric_cast_precast_bounds(cx, normalized_lhs);\n             let rhs_bounds = numeric_cast_precast_bounds(cx, normalized_rhs);\n \n-            upcast_comparison_bounds_err(cx, &expr.span, rel, lhs_bounds, normalized_lhs, normalized_rhs, false);\n-            upcast_comparison_bounds_err(cx, &expr.span, rel, rhs_bounds, normalized_rhs, normalized_lhs, true);\n+            upcast_comparison_bounds_err(cx, expr.span, rel, lhs_bounds, normalized_lhs, normalized_rhs, false);\n+            upcast_comparison_bounds_err(cx, expr.span, rel, rhs_bounds, normalized_rhs, normalized_lhs, true);\n         }\n     }\n }"}, {"sha": "56a8377d7dd82e0093e7c427f68f8fabd2f04e2e", "filename": "clippy_lints/src/unsafe_removed_from_name.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3d3d3732c0cbab77172c461d7d2d914fbc1652bc/clippy_lints%2Fsrc%2Funsafe_removed_from_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d3d3732c0cbab77172c461d7d2d914fbc1652bc/clippy_lints%2Fsrc%2Funsafe_removed_from_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funsafe_removed_from_name.rs?ref=3d3d3732c0cbab77172c461d7d2d914fbc1652bc", "patch": "@@ -36,12 +36,12 @@ impl LintPass for UnsafeNameRemoval {\n impl EarlyLintPass for UnsafeNameRemoval {\n     fn check_item(&mut self, cx: &EarlyContext, item: &Item) {\n         if let ItemKind::Use(ref use_tree) = item.node {\n-            check_use_tree(use_tree, cx, &item.span);\n+            check_use_tree(use_tree, cx, item.span);\n         }\n     }\n }\n \n-fn check_use_tree(use_tree: &UseTree, cx: &EarlyContext, span: &Span) {\n+fn check_use_tree(use_tree: &UseTree, cx: &EarlyContext, span: Span) {\n     match use_tree.kind {\n         UseTreeKind::Simple(Some(new_name)) => {\n             let old_name = use_tree\n@@ -62,14 +62,14 @@ fn check_use_tree(use_tree: &UseTree, cx: &EarlyContext, span: &Span) {\n     }\n }\n \n-fn unsafe_to_safe_check(old_name: Ident, new_name: Ident, cx: &EarlyContext, span: &Span) {\n+fn unsafe_to_safe_check(old_name: Ident, new_name: Ident, cx: &EarlyContext, span: Span) {\n     let old_str = old_name.name.as_str();\n     let new_str = new_name.name.as_str();\n     if contains_unsafe(&old_str) && !contains_unsafe(&new_str) {\n         span_lint(\n             cx,\n             UNSAFE_REMOVED_FROM_NAME,\n-            *span,\n+            span,\n             &format!(\"removed \\\"unsafe\\\" from the name of `{}` in use as `{}`\", old_str, new_str),\n         );\n     }"}, {"sha": "d3c7d9013232714810e3df59ad1221132b665b0d", "filename": "clippy_lints/src/utils/conf.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d3d3732c0cbab77172c461d7d2d914fbc1652bc/clippy_lints%2Fsrc%2Futils%2Fconf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d3d3732c0cbab77172c461d7d2d914fbc1652bc/clippy_lints%2Fsrc%2Futils%2Fconf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fconf.rs?ref=3d3d3732c0cbab77172c461d7d2d914fbc1652bc", "patch": "@@ -156,6 +156,8 @@ define_Conf! {\n     (verbose_bit_mask_threshold, \"verbose_bit_mask_threshold\", 1 => u64),\n     /// Lint: DECIMAL_LITERAL_REPRESENTATION. The lower bound for linting decimal literals\n     (literal_representation_threshold, \"literal_representation_threshold\", 16384 => u64),\n+    /// Lint: TRIVIALLY_COPY_PASS_BY_REF. The maximum size (in bytes) to consider a `Copy` type for passing by value instead of by reference.\n+    (trivial_copy_size_limit, \"trivial_copy_size_limit\", None => Option<u64>),\n }\n \n /// Search for the configuration file."}, {"sha": "ddac8bd3835e83d02c8fa404f1b4b745a8c243ae", "filename": "clippy_lints/src/utils/hir_utils.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/3d3d3732c0cbab77172c461d7d2d914fbc1652bc/clippy_lints%2Fsrc%2Futils%2Fhir_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d3d3732c0cbab77172c461d7d2d914fbc1652bc/clippy_lints%2Fsrc%2Futils%2Fhir_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fhir_utils.rs?ref=3d3d3732c0cbab77172c461d7d2d914fbc1652bc", "patch": "@@ -349,7 +349,7 @@ impl<'a, 'tcx: 'a> SpanlessHash<'a, 'tcx> {\n                 let c: fn(_) -> _ = ExprAgain;\n                 c.hash(&mut self.s);\n                 if let Some(i) = i.label {\n-                    self.hash_name(&i.name);\n+                    self.hash_name(i.name);\n                 }\n             },\n             ExprYield(ref e) => {\n@@ -386,7 +386,7 @@ impl<'a, 'tcx: 'a> SpanlessHash<'a, 'tcx> {\n                 let c: fn(_, _) -> _ = ExprBreak;\n                 c.hash(&mut self.s);\n                 if let Some(i) = i.label {\n-                    self.hash_name(&i.name);\n+                    self.hash_name(i.name);\n                 }\n                 if let Some(ref j) = *j {\n                     self.hash_expr(&*j);\n@@ -419,7 +419,7 @@ impl<'a, 'tcx: 'a> SpanlessHash<'a, 'tcx> {\n                 let c: fn(_, _) -> _ = ExprField;\n                 c.hash(&mut self.s);\n                 self.hash_expr(e);\n-                self.hash_name(&f.name);\n+                self.hash_name(f.name);\n             },\n             ExprIndex(ref a, ref i) => {\n                 let c: fn(_, _) -> _ = ExprIndex;\n@@ -450,7 +450,7 @@ impl<'a, 'tcx: 'a> SpanlessHash<'a, 'tcx> {\n                 c.hash(&mut self.s);\n                 self.hash_block(b);\n                 if let Some(i) = *i {\n-                    self.hash_name(&i.name);\n+                    self.hash_name(i.name);\n                 }\n             },\n             ExprMatch(ref e, ref arms, ref s) => {\n@@ -471,7 +471,7 @@ impl<'a, 'tcx: 'a> SpanlessHash<'a, 'tcx> {\n             ExprMethodCall(ref path, ref _tys, ref args) => {\n                 let c: fn(_, _, _) -> _ = ExprMethodCall;\n                 c.hash(&mut self.s);\n-                self.hash_name(&path.name);\n+                self.hash_name(path.name);\n                 self.hash_exprs(args);\n             },\n             ExprRepeat(ref e, ref l_id) => {\n@@ -502,7 +502,7 @@ impl<'a, 'tcx: 'a> SpanlessHash<'a, 'tcx> {\n                 self.hash_qpath(path);\n \n                 for f in fields {\n-                    self.hash_name(&f.ident.name);\n+                    self.hash_name(f.ident.name);\n                     self.hash_expr(&f.expr);\n                 }\n \n@@ -541,7 +541,7 @@ impl<'a, 'tcx: 'a> SpanlessHash<'a, 'tcx> {\n                 self.hash_expr(cond);\n                 self.hash_block(b);\n                 if let Some(l) = l {\n-                    self.hash_name(&l.name);\n+                    self.hash_name(l.name);\n                 }\n             },\n         }\n@@ -553,7 +553,7 @@ impl<'a, 'tcx: 'a> SpanlessHash<'a, 'tcx> {\n         }\n     }\n \n-    pub fn hash_name(&mut self, n: &Name) {\n+    pub fn hash_name(&mut self, n: Name) {\n         n.as_str().hash(&mut self.s);\n     }\n \n@@ -563,7 +563,7 @@ impl<'a, 'tcx: 'a> SpanlessHash<'a, 'tcx> {\n                 self.hash_path(path);\n             },\n             QPath::TypeRelative(_, ref path) => {\n-                self.hash_name(&path.name);\n+                self.hash_name(path.name);\n             },\n         }\n         // self.cx.tables.qpath_def(p, id).hash(&mut self.s);\n@@ -572,7 +572,7 @@ impl<'a, 'tcx: 'a> SpanlessHash<'a, 'tcx> {\n     pub fn hash_path(&mut self, p: &Path) {\n         p.is_global().hash(&mut self.s);\n         for p in &p.segments {\n-            self.hash_name(&p.name);\n+            self.hash_name(p.name);\n         }\n     }\n "}, {"sha": "3b96f1fd000bb0323c3ab37ae533ffd5637cc78f", "filename": "tests/ui-toml/toml_trivially_copy/clippy.toml", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3d3d3732c0cbab77172c461d7d2d914fbc1652bc/tests%2Fui-toml%2Ftoml_trivially_copy%2Fclippy.toml", "raw_url": "https://github.com/rust-lang/rust/raw/3d3d3732c0cbab77172c461d7d2d914fbc1652bc/tests%2Fui-toml%2Ftoml_trivially_copy%2Fclippy.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-toml%2Ftoml_trivially_copy%2Fclippy.toml?ref=3d3d3732c0cbab77172c461d7d2d914fbc1652bc", "patch": "@@ -0,0 +1 @@\n+trivial-copy-size-limit = 2"}, {"sha": "bee092a5765a9844637aa92c194aeeff1f4afcbc", "filename": "tests/ui-toml/toml_trivially_copy/test.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/3d3d3732c0cbab77172c461d7d2d914fbc1652bc/tests%2Fui-toml%2Ftoml_trivially_copy%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d3d3732c0cbab77172c461d7d2d914fbc1652bc/tests%2Fui-toml%2Ftoml_trivially_copy%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-toml%2Ftoml_trivially_copy%2Ftest.rs?ref=3d3d3732c0cbab77172c461d7d2d914fbc1652bc", "patch": "@@ -0,0 +1,19 @@\n+#![allow(many_single_char_names)]\n+\n+#[derive(Copy, Clone)]\n+struct Foo(u8);\n+\n+#[derive(Copy, Clone)]\n+struct Bar(u32);\n+\n+fn good(a: &mut u32, b: u32, c: &Bar, d: &u32) {\n+}\n+\n+fn bad(x: &u16, y: &Foo) {\n+}\n+\n+fn main() {\n+    let (mut a, b, c, d, x, y) = (0, 0, Bar(0), 0, 0, Foo(0));\n+    good(&mut a, b, &c, &d);\n+    bad(&x, &y);\n+}"}, {"sha": "2d36c47c5da1bf5ded3456f86c276e604ba0b1e5", "filename": "tests/ui-toml/toml_trivially_copy/test.stderr", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3d3d3732c0cbab77172c461d7d2d914fbc1652bc/tests%2Fui-toml%2Ftoml_trivially_copy%2Ftest.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3d3d3732c0cbab77172c461d7d2d914fbc1652bc/tests%2Fui-toml%2Ftoml_trivially_copy%2Ftest.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-toml%2Ftoml_trivially_copy%2Ftest.stderr?ref=3d3d3732c0cbab77172c461d7d2d914fbc1652bc", "patch": "@@ -0,0 +1,16 @@\n+error: this argument is passed by reference, but would be more efficient if passed by value\n+  --> $DIR/test.rs:12:11\n+   |\n+12 | fn bad(x: &u16, y: &Foo) {\n+   |           ^^^^ help: consider passing by value instead: `u16`\n+   |\n+   = note: `-D trivially-copy-pass-by-ref` implied by `-D warnings`\n+\n+error: this argument is passed by reference, but would be more efficient if passed by value\n+  --> $DIR/test.rs:12:20\n+   |\n+12 | fn bad(x: &u16, y: &Foo) {\n+   |                    ^^^^ help: consider passing by value instead: `Foo`\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "05a04fb377ad70c7ee8bf61d366707bfb19e1be0", "filename": "tests/ui-toml/toml_unknown_key/conf_unknown_key.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d3d3732c0cbab77172c461d7d2d914fbc1652bc/tests%2Fui-toml%2Ftoml_unknown_key%2Fconf_unknown_key.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3d3d3732c0cbab77172c461d7d2d914fbc1652bc/tests%2Fui-toml%2Ftoml_unknown_key%2Fconf_unknown_key.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-toml%2Ftoml_unknown_key%2Fconf_unknown_key.stderr?ref=3d3d3732c0cbab77172c461d7d2d914fbc1652bc", "patch": "@@ -1,4 +1,4 @@\n-error: error reading Clippy's configuration file `$DIR/clippy.toml`: unknown field `foobar`, expected one of `blacklisted-names`, `cyclomatic-complexity-threshold`, `doc-valid-idents`, `too-many-arguments-threshold`, `type-complexity-threshold`, `single-char-binding-names-threshold`, `too-large-for-stack`, `enum-variant-name-threshold`, `enum-variant-size-threshold`, `verbose-bit-mask-threshold`, `literal-representation-threshold`, `third-party`\n+error: error reading Clippy's configuration file `$DIR/clippy.toml`: unknown field `foobar`, expected one of `blacklisted-names`, `cyclomatic-complexity-threshold`, `doc-valid-idents`, `too-many-arguments-threshold`, `type-complexity-threshold`, `single-char-binding-names-threshold`, `too-large-for-stack`, `enum-variant-name-threshold`, `enum-variant-size-threshold`, `verbose-bit-mask-threshold`, `literal-representation-threshold`, `trivial-copy-size-limit`, `third-party`\n \n error: aborting due to previous error\n "}, {"sha": "5b491573c3f9202f0939e6d0d57d4d703432f925", "filename": "tests/ui/clone_on_copy_mut.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3d3d3732c0cbab77172c461d7d2d914fbc1652bc/tests%2Fui%2Fclone_on_copy_mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d3d3732c0cbab77172c461d7d2d914fbc1652bc/tests%2Fui%2Fclone_on_copy_mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fclone_on_copy_mut.rs?ref=3d3d3732c0cbab77172c461d7d2d914fbc1652bc", "patch": "@@ -5,6 +5,7 @@ pub fn dec_read_dec(i: &mut i32) -> i32 {\n     ret\n }\n \n+#[allow(trivially_copy_pass_by_ref)]\n pub fn minus_1(i: &i32) -> i32 {\n     dec_read_dec(&mut i.clone())\n }"}, {"sha": "6e0b6f8cacd7eba46f055252407c88d9546d315a", "filename": "tests/ui/eta.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d3d3732c0cbab77172c461d7d2d914fbc1652bc/tests%2Fui%2Feta.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d3d3732c0cbab77172c461d7d2d914fbc1652bc/tests%2Fui%2Feta.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Feta.rs?ref=3d3d3732c0cbab77172c461d7d2d914fbc1652bc", "patch": "@@ -1,6 +1,6 @@\n \n \n-#![allow(unknown_lints, unused, no_effect, redundant_closure_call, many_single_char_names, needless_pass_by_value, option_map_unit_fn)]\n+#![allow(unknown_lints, unused, no_effect, redundant_closure_call, many_single_char_names, needless_pass_by_value, option_map_unit_fn, trivially_copy_pass_by_ref)]\n #![warn(redundant_closure, needless_borrow)]\n \n fn main() {"}, {"sha": "2e2ccd9f1ae87706f3bb41e87c785e98081a7757", "filename": "tests/ui/infinite_iter.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d3d3732c0cbab77172c461d7d2d914fbc1652bc/tests%2Fui%2Finfinite_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d3d3732c0cbab77172c461d7d2d914fbc1652bc/tests%2Fui%2Finfinite_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Finfinite_iter.rs?ref=3d3d3732c0cbab77172c461d7d2d914fbc1652bc", "patch": "@@ -1,7 +1,7 @@\n #![feature(iterator_for_each)]\n \n use std::iter::repeat;\n-\n+#[allow(trivially_copy_pass_by_ref)]\n fn square_is_lower_64(x: &u32) -> bool { x * x < 64 }\n \n #[allow(maybe_infinite_iter)]"}, {"sha": "aa4f8b53f6c7cd7a057d98584c185e8b770309e5", "filename": "tests/ui/infinite_loop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d3d3732c0cbab77172c461d7d2d914fbc1652bc/tests%2Fui%2Finfinite_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d3d3732c0cbab77172c461d7d2d914fbc1652bc/tests%2Fui%2Finfinite_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Finfinite_loop.rs?ref=3d3d3732c0cbab77172c461d7d2d914fbc1652bc", "patch": "@@ -1,4 +1,4 @@\n-\n+#![allow(trivially_copy_pass_by_ref)]\n \n \n fn fn_val(i: i32) -> i32 { unimplemented!() }"}, {"sha": "d2de1cb8ed851c5f0590b92c63b51cb8534e258c", "filename": "tests/ui/lifetimes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d3d3732c0cbab77172c461d7d2d914fbc1652bc/tests%2Fui%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d3d3732c0cbab77172c461d7d2d914fbc1652bc/tests%2Fui%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flifetimes.rs?ref=3d3d3732c0cbab77172c461d7d2d914fbc1652bc", "patch": "@@ -2,7 +2,7 @@\n \n \n #![warn(needless_lifetimes, extra_unused_lifetimes)]\n-#![allow(dead_code, needless_pass_by_value)]\n+#![allow(dead_code, needless_pass_by_value, trivially_copy_pass_by_ref)]\n \n fn distinct_lifetimes<'a, 'b>(_x: &'a u8, _y: &'b u8, _z: u8) { }\n "}, {"sha": "3fc464083c443d1726dc655a6101d8dee3231159", "filename": "tests/ui/mut_from_ref.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d3d3732c0cbab77172c461d7d2d914fbc1652bc/tests%2Fui%2Fmut_from_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d3d3732c0cbab77172c461d7d2d914fbc1652bc/tests%2Fui%2Fmut_from_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmut_from_ref.rs?ref=3d3d3732c0cbab77172c461d7d2d914fbc1652bc", "patch": "@@ -1,6 +1,6 @@\n \n \n-#![allow(unused)]\n+#![allow(unused, trivially_copy_pass_by_ref)]\n #![warn(mut_from_ref)]\n \n struct Foo;"}, {"sha": "34185f6a9c2b94a1dd7ec6c54580d7c3bea5887c", "filename": "tests/ui/mut_reference.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d3d3732c0cbab77172c461d7d2d914fbc1652bc/tests%2Fui%2Fmut_reference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d3d3732c0cbab77172c461d7d2d914fbc1652bc/tests%2Fui%2Fmut_reference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmut_reference.rs?ref=3d3d3732c0cbab77172c461d7d2d914fbc1652bc", "patch": "@@ -1,7 +1,7 @@\n \n \n \n-#![allow(unused_variables)]\n+#![allow(unused_variables, trivially_copy_pass_by_ref)]\n \n fn takes_an_immutable_reference(a: &i32) {}\n fn takes_a_mutable_reference(a: &mut i32) {}"}, {"sha": "b086f0214a9c27ed5104f33941a269916d604d98", "filename": "tests/ui/needless_borrow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d3d3732c0cbab77172c461d7d2d914fbc1652bc/tests%2Fui%2Fneedless_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d3d3732c0cbab77172c461d7d2d914fbc1652bc/tests%2Fui%2Fneedless_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_borrow.rs?ref=3d3d3732c0cbab77172c461d7d2d914fbc1652bc", "patch": "@@ -1,6 +1,6 @@\n use std::borrow::Cow;\n \n-\n+#[allow(trivially_copy_pass_by_ref)]\n fn x(y: &i32) -> i32 {\n     *y\n }"}, {"sha": "aba4aa5ea327bee3e51fcdbef32e2ca678c306a1", "filename": "tests/ui/trivially_copy_pass_by_ref.rs", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/3d3d3732c0cbab77172c461d7d2d914fbc1652bc/tests%2Fui%2Ftrivially_copy_pass_by_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d3d3732c0cbab77172c461d7d2d914fbc1652bc/tests%2Fui%2Ftrivially_copy_pass_by_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftrivially_copy_pass_by_ref.rs?ref=3d3d3732c0cbab77172c461d7d2d914fbc1652bc", "patch": "@@ -0,0 +1,57 @@\n+#![allow(many_single_char_names, blacklisted_name)]\n+\n+#[derive(Copy, Clone)]\n+struct Foo(u32);\n+\n+#[derive(Copy, Clone)]\n+struct Bar([u8; 24]);\n+\n+type Baz = u32;\n+\n+fn good(a: &mut u32, b: u32, c: &Bar) {\n+}\n+\n+fn bad(x: &u32, y: &Foo, z: &Baz) {\n+}\n+\n+impl Foo {\n+    fn good(self, a: &mut u32, b: u32, c: &Bar) {\n+    }\n+\n+    fn good2(&mut self) {\n+    }\n+\n+    fn bad(&self, x: &u32, y: &Foo, z: &Baz) {\n+    }\n+\n+    fn bad2(x: &u32, y: &Foo, z: &Baz) {\n+    }\n+}\n+\n+impl AsRef<u32> for Foo {\n+    fn as_ref(&self) -> &u32 {\n+        &self.0\n+    }\n+}\n+\n+impl Bar {\n+    fn good(&self, a: &mut u32, b: u32, c: &Bar) {\n+    }\n+\n+    fn bad2(x: &u32, y: &Foo, z: &Baz) {\n+    }\n+}\n+\n+fn main() {\n+    let (mut foo, bar) = (Foo(0), Bar([0; 24]));\n+    let (mut a, b, c, x, y, z) = (0, 0, Bar([0; 24]), 0, Foo(0), 0);\n+    good(&mut a, b, &c);\n+    bad(&x, &y, &z);\n+    foo.good(&mut a, b, &c);\n+    foo.good2();\n+    foo.bad(&x, &y, &z);\n+    Foo::bad2(&x, &y, &z);\n+    bar.good(&mut a, b, &c);\n+    Bar::bad2(&x, &y, &z);\n+    foo.as_ref();\n+}"}, {"sha": "c6ab968a7c5f97d29e58cc83afa35dd0d90635d6", "filename": "tests/ui/trivially_copy_pass_by_ref.stderr", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/3d3d3732c0cbab77172c461d7d2d914fbc1652bc/tests%2Fui%2Ftrivially_copy_pass_by_ref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3d3d3732c0cbab77172c461d7d2d914fbc1652bc/tests%2Fui%2Ftrivially_copy_pass_by_ref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftrivially_copy_pass_by_ref.stderr?ref=3d3d3732c0cbab77172c461d7d2d914fbc1652bc", "patch": "@@ -0,0 +1,82 @@\n+error: this argument is passed by reference, but would be more efficient if passed by value\n+  --> $DIR/trivially_copy_pass_by_ref.rs:14:11\n+   |\n+14 | fn bad(x: &u32, y: &Foo, z: &Baz) {\n+   |           ^^^^ help: consider passing by value instead: `u32`\n+   |\n+   = note: `-D trivially-copy-pass-by-ref` implied by `-D warnings`\n+\n+error: this argument is passed by reference, but would be more efficient if passed by value\n+  --> $DIR/trivially_copy_pass_by_ref.rs:14:20\n+   |\n+14 | fn bad(x: &u32, y: &Foo, z: &Baz) {\n+   |                    ^^^^ help: consider passing by value instead: `Foo`\n+\n+error: this argument is passed by reference, but would be more efficient if passed by value\n+  --> $DIR/trivially_copy_pass_by_ref.rs:14:29\n+   |\n+14 | fn bad(x: &u32, y: &Foo, z: &Baz) {\n+   |                             ^^^^ help: consider passing by value instead: `Baz`\n+\n+error: this argument is passed by reference, but would be more efficient if passed by value\n+  --> $DIR/trivially_copy_pass_by_ref.rs:24:12\n+   |\n+24 |     fn bad(&self, x: &u32, y: &Foo, z: &Baz) {\n+   |            ^^^^^ help: consider passing by value instead: `self`\n+\n+error: this argument is passed by reference, but would be more efficient if passed by value\n+  --> $DIR/trivially_copy_pass_by_ref.rs:24:22\n+   |\n+24 |     fn bad(&self, x: &u32, y: &Foo, z: &Baz) {\n+   |                      ^^^^ help: consider passing by value instead: `u32`\n+\n+error: this argument is passed by reference, but would be more efficient if passed by value\n+  --> $DIR/trivially_copy_pass_by_ref.rs:24:31\n+   |\n+24 |     fn bad(&self, x: &u32, y: &Foo, z: &Baz) {\n+   |                               ^^^^ help: consider passing by value instead: `Foo`\n+\n+error: this argument is passed by reference, but would be more efficient if passed by value\n+  --> $DIR/trivially_copy_pass_by_ref.rs:24:40\n+   |\n+24 |     fn bad(&self, x: &u32, y: &Foo, z: &Baz) {\n+   |                                        ^^^^ help: consider passing by value instead: `Baz`\n+\n+error: this argument is passed by reference, but would be more efficient if passed by value\n+  --> $DIR/trivially_copy_pass_by_ref.rs:27:16\n+   |\n+27 |     fn bad2(x: &u32, y: &Foo, z: &Baz) {\n+   |                ^^^^ help: consider passing by value instead: `u32`\n+\n+error: this argument is passed by reference, but would be more efficient if passed by value\n+  --> $DIR/trivially_copy_pass_by_ref.rs:27:25\n+   |\n+27 |     fn bad2(x: &u32, y: &Foo, z: &Baz) {\n+   |                         ^^^^ help: consider passing by value instead: `Foo`\n+\n+error: this argument is passed by reference, but would be more efficient if passed by value\n+  --> $DIR/trivially_copy_pass_by_ref.rs:27:34\n+   |\n+27 |     fn bad2(x: &u32, y: &Foo, z: &Baz) {\n+   |                                  ^^^^ help: consider passing by value instead: `Baz`\n+\n+error: this argument is passed by reference, but would be more efficient if passed by value\n+  --> $DIR/trivially_copy_pass_by_ref.rs:41:16\n+   |\n+41 |     fn bad2(x: &u32, y: &Foo, z: &Baz) {\n+   |                ^^^^ help: consider passing by value instead: `u32`\n+\n+error: this argument is passed by reference, but would be more efficient if passed by value\n+  --> $DIR/trivially_copy_pass_by_ref.rs:41:25\n+   |\n+41 |     fn bad2(x: &u32, y: &Foo, z: &Baz) {\n+   |                         ^^^^ help: consider passing by value instead: `Foo`\n+\n+error: this argument is passed by reference, but would be more efficient if passed by value\n+  --> $DIR/trivially_copy_pass_by_ref.rs:41:34\n+   |\n+41 |     fn bad2(x: &u32, y: &Foo, z: &Baz) {\n+   |                                  ^^^^ help: consider passing by value instead: `Baz`\n+\n+error: aborting due to 13 previous errors\n+"}, {"sha": "8b166a34d299fc239e02f9c9c15250192ee538e2", "filename": "tests/ui/unused_lt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d3d3732c0cbab77172c461d7d2d914fbc1652bc/tests%2Fui%2Funused_lt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d3d3732c0cbab77172c461d7d2d914fbc1652bc/tests%2Fui%2Funused_lt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funused_lt.rs?ref=3d3d3732c0cbab77172c461d7d2d914fbc1652bc", "patch": "@@ -1,6 +1,6 @@\n \n \n-#![allow(unused, dead_code, needless_lifetimes, needless_pass_by_value)]\n+#![allow(unused, dead_code, needless_lifetimes, needless_pass_by_value, trivially_copy_pass_by_ref)]\n #![warn(extra_unused_lifetimes)]\n \n fn empty() {"}, {"sha": "7508cdc7b4336452636578ae4c047daf7633ab28", "filename": "tests/ui/useless_asref.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d3d3732c0cbab77172c461d7d2d914fbc1652bc/tests%2Fui%2Fuseless_asref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d3d3732c0cbab77172c461d7d2d914fbc1652bc/tests%2Fui%2Fuseless_asref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fuseless_asref.rs?ref=3d3d3732c0cbab77172c461d7d2d914fbc1652bc", "patch": "@@ -1,5 +1,5 @@\n #![deny(useless_asref)]\n-\n+#![allow(trivially_copy_pass_by_ref)]\n use std::fmt::Debug;\n \n struct FakeAsRef;"}, {"sha": "07a93d6889bf0cc1787cf751323fa113d254b4fe", "filename": "tests/ui/wrong_self_convention.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d3d3732c0cbab77172c461d7d2d914fbc1652bc/tests%2Fui%2Fwrong_self_convention.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d3d3732c0cbab77172c461d7d2d914fbc1652bc/tests%2Fui%2Fwrong_self_convention.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fwrong_self_convention.rs?ref=3d3d3732c0cbab77172c461d7d2d914fbc1652bc", "patch": "@@ -3,7 +3,7 @@\n \n #![warn(wrong_self_convention)]\n #![warn(wrong_pub_self_convention)]\n-#![allow(dead_code)]\n+#![allow(dead_code, trivially_copy_pass_by_ref)]\n \n fn main() {}\n "}]}