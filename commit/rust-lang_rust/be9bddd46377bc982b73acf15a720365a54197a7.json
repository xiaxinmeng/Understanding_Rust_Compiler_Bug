{"sha": "be9bddd46377bc982b73acf15a720365a54197a7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJlOWJkZGQ0NjM3N2JjOTgyYjczYWNmMTVhNzIwMzY1YTU0MTk3YTc=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-03-22T04:20:48Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-03-22T17:29:17Z"}, "message": "libcore: Remove `pure` from libcore. rs=depure", "tree": {"sha": "55aeffb471ddf4d96860c8ab4e5ad448c0e0f7f0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/55aeffb471ddf4d96860c8ab4e5ad448c0e0f7f0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/be9bddd46377bc982b73acf15a720365a54197a7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/be9bddd46377bc982b73acf15a720365a54197a7", "html_url": "https://github.com/rust-lang/rust/commit/be9bddd46377bc982b73acf15a720365a54197a7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/be9bddd46377bc982b73acf15a720365a54197a7/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4634f7edaefafa3e5ece93499e08992b4c8c7145", "url": "https://api.github.com/repos/rust-lang/rust/commits/4634f7edaefafa3e5ece93499e08992b4c8c7145", "html_url": "https://github.com/rust-lang/rust/commit/4634f7edaefafa3e5ece93499e08992b4c8c7145"}], "stats": {"total": 3127, "additions": 1551, "deletions": 1576}, "files": [{"sha": "29b7e35e24b7f26abc7e0ce7b9943edf5c78a78d", "filename": "src/libcore/at_vec.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/be9bddd46377bc982b73acf15a720365a54197a7/src%2Flibcore%2Fat_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be9bddd46377bc982b73acf15a720365a54197a7/src%2Flibcore%2Fat_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fat_vec.rs?ref=be9bddd46377bc982b73acf15a720365a54197a7", "patch": "@@ -38,7 +38,7 @@ pub mod rustrt {\n \n /// Returns the number of elements the vector can hold without reallocating\n #[inline(always)]\n-pub pure fn capacity<T>(v: @[const T]) -> uint {\n+pub fn capacity<T>(v: @[const T]) -> uint {\n     unsafe {\n         let repr: **raw::VecRepr =\n             ::cast::reinterpret_cast(&addr_of(&v));\n@@ -59,8 +59,7 @@ pub pure fn capacity<T>(v: @[const T]) -> uint {\n  *             onto the vector being constructed.\n  */\n #[inline(always)]\n-pub pure fn build_sized<A>(size: uint,\n-                           builder: &fn(push: &pure fn(v: A))) -> @[A] {\n+pub fn build_sized<A>(size: uint, builder: &fn(push: &fn(v: A))) -> @[A] {\n     let mut vec: @[const A] = @[];\n     unsafe { raw::reserve(&mut vec, size); }\n     builder(|+x| unsafe { raw::push(&mut vec, x) });\n@@ -78,7 +77,7 @@ pub pure fn build_sized<A>(size: uint,\n  *             onto the vector being constructed.\n  */\n #[inline(always)]\n-pub pure fn build<A>(builder: &fn(push: &pure fn(v: A))) -> @[A] {\n+pub fn build<A>(builder: &fn(push: &fn(v: A))) -> @[A] {\n     build_sized(4, builder)\n }\n \n@@ -95,14 +94,15 @@ pub pure fn build<A>(builder: &fn(push: &pure fn(v: A))) -> @[A] {\n  *             onto the vector being constructed.\n  */\n #[inline(always)]\n-pub pure fn build_sized_opt<A>(size: Option<uint>,\n-                               builder: &fn(push: &pure fn(v: A))) -> @[A] {\n+pub fn build_sized_opt<A>(size: Option<uint>,\n+                          builder: &fn(push: &fn(v: A)))\n+                       -> @[A] {\n     build_sized(size.get_or_default(4), builder)\n }\n \n // Appending\n #[inline(always)]\n-pub pure fn append<T:Copy>(lhs: @[T], rhs: &[const T]) -> @[T] {\n+pub fn append<T:Copy>(lhs: @[T], rhs: &[const T]) -> @[T] {\n     do build_sized(lhs.len() + rhs.len()) |push| {\n         for vec::each(lhs) |x| { push(*x); }\n         for uint::range(0, rhs.len()) |i| { push(rhs[i]); }\n@@ -111,7 +111,7 @@ pub pure fn append<T:Copy>(lhs: @[T], rhs: &[const T]) -> @[T] {\n \n \n /// Apply a function to each element of a vector and return the results\n-pub pure fn map<T, U>(v: &[T], f: &fn(x: &T) -> U) -> @[U] {\n+pub fn map<T, U>(v: &[T], f: &fn(x: &T) -> U) -> @[U] {\n     do build_sized(v.len()) |push| {\n         for vec::each(v) |elem| {\n             push(f(elem));\n@@ -125,7 +125,7 @@ pub pure fn map<T, U>(v: &[T], f: &fn(x: &T) -> U) -> @[U] {\n  * Creates an immutable vector of size `n_elts` and initializes the elements\n  * to the value returned by the function `op`.\n  */\n-pub pure fn from_fn<T>(n_elts: uint, op: iter::InitOp<T>) -> @[T] {\n+pub fn from_fn<T>(n_elts: uint, op: iter::InitOp<T>) -> @[T] {\n     do build_sized(n_elts) |push| {\n         let mut i: uint = 0u;\n         while i < n_elts { push(op(i)); i += 1u; }\n@@ -138,7 +138,7 @@ pub pure fn from_fn<T>(n_elts: uint, op: iter::InitOp<T>) -> @[T] {\n  * Creates an immutable vector of size `n_elts` and initializes the elements\n  * to the value `t`.\n  */\n-pub pure fn from_elem<T:Copy>(n_elts: uint, t: T) -> @[T] {\n+pub fn from_elem<T:Copy>(n_elts: uint, t: T) -> @[T] {\n     do build_sized(n_elts) |push| {\n         let mut i: uint = 0u;\n         while i < n_elts { push(copy t); i += 1u; }\n@@ -176,7 +176,7 @@ pub mod traits {\n \n     impl<T:Copy> Add<&'self [const T],@[T]> for @[T] {\n         #[inline(always)]\n-        pure fn add(&self, rhs: & &'self [const T]) -> @[T] {\n+        fn add(&self, rhs: & &'self [const T]) -> @[T] {\n             append(*self, (*rhs))\n         }\n     }"}, {"sha": "2b669a285b31cc0157ddf6949bbe8944f60ede9c", "filename": "src/libcore/bool.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/be9bddd46377bc982b73acf15a720365a54197a7/src%2Flibcore%2Fbool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be9bddd46377bc982b73acf15a720365a54197a7/src%2Flibcore%2Fbool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fbool.rs?ref=be9bddd46377bc982b73acf15a720365a54197a7", "patch": "@@ -17,39 +17,39 @@ use from_str::FromStr;\n #[cfg(notest)] use cmp;\n \n /// Negation / inverse\n-pub pure fn not(v: bool) -> bool { !v }\n+pub fn not(v: bool) -> bool { !v }\n \n /// Conjunction\n-pub pure fn and(a: bool, b: bool) -> bool { a && b }\n+pub fn and(a: bool, b: bool) -> bool { a && b }\n \n /// Disjunction\n-pub pure fn or(a: bool, b: bool) -> bool { a || b }\n+pub fn or(a: bool, b: bool) -> bool { a || b }\n \n /**\n  * Exclusive or\n  *\n  * Identical to `or(and(a, not(b)), and(not(a), b))`\n  */\n-pub pure fn xor(a: bool, b: bool) -> bool { (a && !b) || (!a && b) }\n+pub fn xor(a: bool, b: bool) -> bool { (a && !b) || (!a && b) }\n \n /// Implication in the logic, i.e. from `a` follows `b`\n-pub pure fn implies(a: bool, b: bool) -> bool { !a || b }\n+pub fn implies(a: bool, b: bool) -> bool { !a || b }\n \n /// true if truth values `a` and `b` are indistinguishable in the logic\n-pub pure fn eq(a: bool, b: bool) -> bool { a == b }\n+pub fn eq(a: bool, b: bool) -> bool { a == b }\n \n /// true if truth values `a` and `b` are distinguishable in the logic\n-pub pure fn ne(a: bool, b: bool) -> bool { a != b }\n+pub fn ne(a: bool, b: bool) -> bool { a != b }\n \n /// true if `v` represents truth in the logic\n-pub pure fn is_true(v: bool) -> bool { v }\n+pub fn is_true(v: bool) -> bool { v }\n \n /// true if `v` represents falsehood in the logic\n-pub pure fn is_false(v: bool) -> bool { !v }\n+pub fn is_false(v: bool) -> bool { !v }\n \n /// Parse logic value from `s`\n impl FromStr for bool {\n-    pure fn from_str(s: &str) -> Option<bool> {\n+    fn from_str(s: &str) -> Option<bool> {\n         if s == \"true\" {\n             Some(true)\n         } else if s == \"false\" {\n@@ -61,7 +61,7 @@ impl FromStr for bool {\n }\n \n /// Convert `v` into a string\n-pub pure fn to_str(v: bool) -> ~str { if v { ~\"true\" } else { ~\"false\" } }\n+pub fn to_str(v: bool) -> ~str { if v { ~\"true\" } else { ~\"false\" } }\n \n /**\n  * Iterates over all truth values by passing them to `blk` in an unspecified\n@@ -73,12 +73,12 @@ pub fn all_values(blk: &fn(v: bool)) {\n }\n \n /// converts truth value to an 8 bit byte\n-pub pure fn to_bit(v: bool) -> u8 { if v { 1u8 } else { 0u8 } }\n+pub fn to_bit(v: bool) -> u8 { if v { 1u8 } else { 0u8 } }\n \n #[cfg(notest)]\n impl cmp::Eq for bool {\n-    pure fn eq(&self, other: &bool) -> bool { (*self) == (*other) }\n-    pure fn ne(&self, other: &bool) -> bool { (*self) != (*other) }\n+    fn eq(&self, other: &bool) -> bool { (*self) == (*other) }\n+    fn ne(&self, other: &bool) -> bool { (*self) != (*other) }\n }\n \n #[test]"}, {"sha": "bf5f93159381a7dc4b3f9d5407910fa26f55dd9e", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/be9bddd46377bc982b73acf15a720365a54197a7/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be9bddd46377bc982b73acf15a720365a54197a7/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=be9bddd46377bc982b73acf15a720365a54197a7", "patch": "@@ -21,22 +21,22 @@ pub struct Cell<T> {\n }\n \n impl<T:cmp::Eq> cmp::Eq for Cell<T> {\n-    pure fn eq(&self, other: &Cell<T>) -> bool {\n+    fn eq(&self, other: &Cell<T>) -> bool {\n         unsafe {\n             let frozen_self: &Option<T> = transmute(&mut self.value);\n             let frozen_other: &Option<T> = transmute(&mut other.value);\n             frozen_self == frozen_other\n         }\n     }\n-    pure fn ne(&self, other: &Cell<T>) -> bool { !self.eq(other) }\n+    fn ne(&self, other: &Cell<T>) -> bool { !self.eq(other) }\n }\n \n /// Creates a new full cell with the given value.\n pub fn Cell<T>(value: T) -> Cell<T> {\n     Cell { value: Some(value) }\n }\n \n-pub pure fn empty_cell<T>() -> Cell<T> {\n+pub fn empty_cell<T>() -> Cell<T> {\n     Cell { value: None }\n }\n \n@@ -61,7 +61,7 @@ pub impl<T> Cell<T> {\n     }\n \n     /// Returns true if the cell is empty and false if the cell is full.\n-    pure fn is_empty(&self) -> bool {\n+    fn is_empty(&self) -> bool {\n         self.value.is_none()\n     }\n "}, {"sha": "027329a235544bb7f49fa0b267c7ced30f0e3c58", "filename": "src/libcore/char.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/be9bddd46377bc982b73acf15a720365a54197a7/src%2Flibcore%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be9bddd46377bc982b73acf15a720365a54197a7/src%2Flibcore%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar.rs?ref=be9bddd46377bc982b73acf15a720365a54197a7", "patch": "@@ -61,7 +61,7 @@ pub use is_XID_continue = unicode::derived_property::XID_Continue;\n  * in terms of the Unicode General Category 'Ll'\n  */\n #[inline(always)]\n-pub pure fn is_lowercase(c: char) -> bool {\n+pub fn is_lowercase(c: char) -> bool {\n     return unicode::general_category::Ll(c);\n }\n \n@@ -70,7 +70,7 @@ pub pure fn is_lowercase(c: char) -> bool {\n  * in terms of the Unicode General Category 'Lu'.\n  */\n #[inline(always)]\n-pub pure fn is_uppercase(c: char) -> bool {\n+pub fn is_uppercase(c: char) -> bool {\n     return unicode::general_category::Lu(c);\n }\n \n@@ -80,7 +80,7 @@ pub pure fn is_uppercase(c: char) -> bool {\n  * additional 'Cc'-category control codes in the range [0x09, 0x0d]\n  */\n #[inline(always)]\n-pub pure fn is_whitespace(c: char) -> bool {\n+pub fn is_whitespace(c: char) -> bool {\n     return ('\\x09' <= c && c <= '\\x0d')\n         || unicode::general_category::Zs(c)\n         || unicode::general_category::Zl(c)\n@@ -93,7 +93,7 @@ pub pure fn is_whitespace(c: char) -> bool {\n  * and the Derived Core Property 'Alphabetic'.\n  */\n #[inline(always)]\n-pub pure fn is_alphanumeric(c: char) -> bool {\n+pub fn is_alphanumeric(c: char) -> bool {\n     return unicode::derived_property::Alphabetic(c) ||\n         unicode::general_category::Nd(c) ||\n         unicode::general_category::Nl(c) ||\n@@ -102,13 +102,13 @@ pub pure fn is_alphanumeric(c: char) -> bool {\n \n /// Indicates whether the character is an ASCII character\n #[inline(always)]\n-pub pure fn is_ascii(c: char) -> bool {\n+pub fn is_ascii(c: char) -> bool {\n    c - ('\\x7F' & c) == '\\x00'\n }\n \n /// Indicates whether the character is numeric (Nd, Nl, or No)\n #[inline(always)]\n-pub pure fn is_digit(c: char) -> bool {\n+pub fn is_digit(c: char) -> bool {\n     return unicode::general_category::Nd(c) ||\n         unicode::general_category::Nl(c) ||\n         unicode::general_category::No(c);\n@@ -127,7 +127,7 @@ pub pure fn is_digit(c: char) -> bool {\n  * Note: This just wraps `to_digit()`.\n  */\n #[inline(always)]\n-pub pure fn is_digit_radix(c: char, radix: uint) -> bool {\n+pub fn is_digit_radix(c: char, radix: uint) -> bool {\n     match to_digit(c, radix) {\n         Some(_) => true,\n         None    => false\n@@ -148,7 +148,7 @@ pub pure fn is_digit_radix(c: char, radix: uint) -> bool {\n  * Fails if given a `radix` outside the range `[0..36]`.\n  */\n #[inline]\n-pub pure fn to_digit(c: char, radix: uint) -> Option<uint> {\n+pub fn to_digit(c: char, radix: uint) -> Option<uint> {\n     if radix > 36 {\n         fail!(fmt!(\"to_digit: radix %? is to high (maximum 36)\", radix));\n     }\n@@ -171,7 +171,7 @@ pub pure fn to_digit(c: char, radix: uint) -> Option<uint> {\n  * Fails if given an `radix` > 36.\n  */\n #[inline]\n-pub pure fn from_digit(num: uint, radix: uint) -> Option<char> {\n+pub fn from_digit(num: uint, radix: uint) -> Option<char> {\n     if radix > 36 {\n         fail!(fmt!(\"from_digit: radix %? is to high (maximum 36)\", num));\n     }\n@@ -195,7 +195,7 @@ pub pure fn from_digit(num: uint, radix: uint) -> Option<char> {\n  *   - chars in [0x100,0xffff] get 4-digit escapes: `\\\\uNNNN`\n  *   - chars above 0x10000 get 8-digit escapes: `\\\\UNNNNNNNN`\n  */\n-pub pure fn escape_unicode(c: char) -> ~str {\n+pub fn escape_unicode(c: char) -> ~str {\n     let s = u32::to_str_radix(c as u32, 16u);\n     let (c, pad) = (if c <= '\\xff' { ('x', 2u) }\n                     else if c <= '\\uffff' { ('u', 4u) }\n@@ -223,7 +223,7 @@ pub pure fn escape_unicode(c: char) -> ~str {\n  *   - Any other chars in the range [0x20,0x7e] are not escaped.\n  *   - Any other chars are given hex unicode escapes; see `escape_unicode`.\n  */\n-pub pure fn escape_default(c: char) -> ~str {\n+pub fn escape_default(c: char) -> ~str {\n     match c {\n       '\\t' => ~\"\\\\t\",\n       '\\r' => ~\"\\\\r\",\n@@ -244,16 +244,16 @@ pub pure fn escape_default(c: char) -> ~str {\n  * -1 if a < b, 0 if a == b, +1 if a > b\n  */\n #[inline(always)]\n-pub pure fn cmp(a: char, b: char) -> int {\n+pub fn cmp(a: char, b: char) -> int {\n     return  if b > a { -1 }\n     else if b < a { 1 }\n     else { 0 }\n }\n \n #[cfg(notest)]\n impl Eq for char {\n-    pure fn eq(&self, other: &char) -> bool { (*self) == (*other) }\n-    pure fn ne(&self, other: &char) -> bool { (*self) != (*other) }\n+    fn eq(&self, other: &char) -> bool { (*self) == (*other) }\n+    fn ne(&self, other: &char) -> bool { (*self) != (*other) }\n }\n \n #[test]"}, {"sha": "7c45ecae63234cb183866ea8bbdb438625da9c82", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/be9bddd46377bc982b73acf15a720365a54197a7/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be9bddd46377bc982b73acf15a720365a54197a7/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=be9bddd46377bc982b73acf15a720365a54197a7", "patch": "@@ -33,73 +33,73 @@ and `Eq` to overload the `==` and `!=` operators.\n */\n #[lang=\"eq\"]\n pub trait Eq {\n-    pure fn eq(&self, other: &Self) -> bool;\n-    pure fn ne(&self, other: &Self) -> bool;\n+    fn eq(&self, other: &Self) -> bool;\n+    fn ne(&self, other: &Self) -> bool;\n }\n \n #[deriving(Eq)]\n pub enum Ordering { Less, Equal, Greater }\n \n /// Trait for types that form a total order\n pub trait TotalOrd {\n-    pure fn cmp(&self, other: &Self) -> Ordering;\n+    fn cmp(&self, other: &Self) -> Ordering;\n }\n \n #[inline(always)]\n-pure fn icmp<T: Ord>(a: &T, b: &T) -> Ordering {\n+fn icmp<T: Ord>(a: &T, b: &T) -> Ordering {\n     if *a < *b { Less }\n     else if *a > *b { Greater }\n     else { Equal }\n }\n \n impl TotalOrd for u8 {\n     #[inline(always)]\n-    pure fn cmp(&self, other: &u8) -> Ordering { icmp(self, other) }\n+    fn cmp(&self, other: &u8) -> Ordering { icmp(self, other) }\n }\n \n impl TotalOrd for u16 {\n     #[inline(always)]\n-    pure fn cmp(&self, other: &u16) -> Ordering { icmp(self, other) }\n+    fn cmp(&self, other: &u16) -> Ordering { icmp(self, other) }\n }\n \n impl TotalOrd for u32 {\n     #[inline(always)]\n-    pure fn cmp(&self, other: &u32) -> Ordering { icmp(self, other) }\n+    fn cmp(&self, other: &u32) -> Ordering { icmp(self, other) }\n }\n \n impl TotalOrd for u64 {\n     #[inline(always)]\n-    pure fn cmp(&self, other: &u64) -> Ordering { icmp(self, other) }\n+    fn cmp(&self, other: &u64) -> Ordering { icmp(self, other) }\n }\n \n impl TotalOrd for i8 {\n     #[inline(always)]\n-    pure fn cmp(&self, other: &i8) -> Ordering { icmp(self, other) }\n+    fn cmp(&self, other: &i8) -> Ordering { icmp(self, other) }\n }\n \n impl TotalOrd for i16 {\n     #[inline(always)]\n-    pure fn cmp(&self, other: &i16) -> Ordering { icmp(self, other) }\n+    fn cmp(&self, other: &i16) -> Ordering { icmp(self, other) }\n }\n \n impl TotalOrd for i32 {\n     #[inline(always)]\n-    pure fn cmp(&self, other: &i32) -> Ordering { icmp(self, other) }\n+    fn cmp(&self, other: &i32) -> Ordering { icmp(self, other) }\n }\n \n impl TotalOrd for i64 {\n     #[inline(always)]\n-    pure fn cmp(&self, other: &i64) -> Ordering { icmp(self, other) }\n+    fn cmp(&self, other: &i64) -> Ordering { icmp(self, other) }\n }\n \n impl TotalOrd for int {\n     #[inline(always)]\n-    pure fn cmp(&self, other: &int) -> Ordering { icmp(self, other) }\n+    fn cmp(&self, other: &int) -> Ordering { icmp(self, other) }\n }\n \n impl TotalOrd for uint {\n     #[inline(always)]\n-    pure fn cmp(&self, other: &uint) -> Ordering { icmp(self, other) }\n+    fn cmp(&self, other: &uint) -> Ordering { icmp(self, other) }\n }\n \n /**\n@@ -114,39 +114,39 @@ impl TotalOrd for uint {\n */\n #[lang=\"ord\"]\n pub trait Ord {\n-    pure fn lt(&self, other: &Self) -> bool;\n-    pure fn le(&self, other: &Self) -> bool;\n-    pure fn ge(&self, other: &Self) -> bool;\n-    pure fn gt(&self, other: &Self) -> bool;\n+    fn lt(&self, other: &Self) -> bool;\n+    fn le(&self, other: &Self) -> bool;\n+    fn ge(&self, other: &Self) -> bool;\n+    fn gt(&self, other: &Self) -> bool;\n }\n \n #[inline(always)]\n-pub pure fn lt<T:Ord>(v1: &T, v2: &T) -> bool {\n+pub fn lt<T:Ord>(v1: &T, v2: &T) -> bool {\n     (*v1).lt(v2)\n }\n \n #[inline(always)]\n-pub pure fn le<T:Ord>(v1: &T, v2: &T) -> bool {\n+pub fn le<T:Ord>(v1: &T, v2: &T) -> bool {\n     (*v1).le(v2)\n }\n \n #[inline(always)]\n-pub pure fn eq<T:Eq>(v1: &T, v2: &T) -> bool {\n+pub fn eq<T:Eq>(v1: &T, v2: &T) -> bool {\n     (*v1).eq(v2)\n }\n \n #[inline(always)]\n-pub pure fn ne<T:Eq>(v1: &T, v2: &T) -> bool {\n+pub fn ne<T:Eq>(v1: &T, v2: &T) -> bool {\n     (*v1).ne(v2)\n }\n \n #[inline(always)]\n-pub pure fn ge<T:Ord>(v1: &T, v2: &T) -> bool {\n+pub fn ge<T:Ord>(v1: &T, v2: &T) -> bool {\n     (*v1).ge(v2)\n }\n \n #[inline(always)]\n-pub pure fn gt<T:Ord>(v1: &T, v2: &T) -> bool {\n+pub fn gt<T:Ord>(v1: &T, v2: &T) -> bool {\n     (*v1).gt(v2)\n }\n \n@@ -155,16 +155,16 @@ pub pure fn gt<T:Ord>(v1: &T, v2: &T) -> bool {\n /// container types; e.g. it is often desirable to be able to use `&str`\n /// values to look up entries in a container with `~str` keys.\n pub trait Equiv<T> {\n-    pure fn equiv(&self, other: &T) -> bool;\n+    fn equiv(&self, other: &T) -> bool;\n }\n \n #[inline(always)]\n-pub pure fn min<T:Ord>(v1: T, v2: T) -> T {\n+pub fn min<T:Ord>(v1: T, v2: T) -> T {\n     if v1 < v2 { v1 } else { v2 }\n }\n \n #[inline(always)]\n-pub pure fn max<T:Ord>(v1: T, v2: T) -> T {\n+pub fn max<T:Ord>(v1: T, v2: T) -> T {\n     if v1 > v2 { v1 } else { v2 }\n }\n "}, {"sha": "6dadca8dc57ba3c72bd199db83b054eb1c9b0334", "filename": "src/libcore/comm.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/be9bddd46377bc982b73acf15a720365a54197a7/src%2Flibcore%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be9bddd46377bc982b73acf15a720365a54197a7/src%2Flibcore%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcomm.rs?ref=be9bddd46377bc982b73acf15a720365a54197a7", "patch": "@@ -50,7 +50,7 @@ pub trait GenericPort<T> {\n /// Ports that can `peek`\n pub trait Peekable<T> {\n     /// Returns true if a message is available\n-    pure fn peek(&self) -> bool;\n+    fn peek(&self) -> bool;\n }\n \n /// Returns the index of an endpoint that is ready to receive.\n@@ -148,7 +148,7 @@ fn chan_try_send<T:Owned>(self: &Chan<T>, x: T) -> bool {\n pub impl<T: Owned> Port<T> {\n     fn recv(&self) -> T { port_recv(self) }\n     fn try_recv(&self) -> Option<T> { port_try_recv(self) }\n-    pure fn peek(&self) -> bool { port_peek(self) }\n+    fn peek(&self) -> bool { port_peek(self) }\n }\n \n impl<T: Owned> GenericPort<T> for Port<T> {\n@@ -180,11 +180,11 @@ fn port_try_recv<T:Owned>(self: &Port<T>) -> Option<T> {\n }\n \n impl<T: Owned> Peekable<T> for Port<T> {\n-    pure fn peek(&self) -> bool { port_peek(self) }\n+    fn peek(&self) -> bool { port_peek(self) }\n }\n \n #[inline(always)]\n-pure fn port_peek<T:Owned>(self: &Port<T>) -> bool {\n+fn port_peek<T:Owned>(self: &Port<T>) -> bool {\n     unsafe {\n         let mut endp = None;\n         endp <-> self.endp;\n@@ -198,7 +198,7 @@ pure fn port_peek<T:Owned>(self: &Port<T>) -> bool {\n }\n \n impl<T: Owned> Selectable for Port<T> {\n-    pure fn header(&self) -> *PacketHeader {\n+    fn header(&self) -> *PacketHeader {\n         unsafe {\n             match self.endp {\n               Some(ref endp) => endp.header(),\n@@ -223,7 +223,7 @@ pub fn PortSet<T: Owned>() -> PortSet<T>{\n pub impl<T:Owned> PortSet<T> {\n     fn recv(&self) -> T { port_set_recv(self) }\n     fn try_recv(&self) -> Option<T> { port_set_try_recv(self) }\n-    pure fn peek(&self) -> bool { port_set_peek(self) }\n+    fn peek(&self) -> bool { port_set_peek(self) }\n }\n \n pub impl<T: Owned> PortSet<T> {\n@@ -272,11 +272,11 @@ fn port_set_try_recv<T:Owned>(self: &PortSet<T>) -> Option<T> {\n }\n \n impl<T: Owned> Peekable<T> for PortSet<T> {\n-    pure fn peek(&self) -> bool { port_set_peek(self) }\n+    fn peek(&self) -> bool { port_set_peek(self) }\n }\n \n #[inline(always)]\n-pure fn port_set_peek<T:Owned>(self: &PortSet<T>) -> bool {\n+fn port_set_peek<T:Owned>(self: &PortSet<T>) -> bool {\n     // It'd be nice to use self.port.each, but that version isn't\n     // pure.\n     for uint::range(0, vec::uniq_len(&const self.ports)) |i| {"}, {"sha": "1cda04ee06ec1b61ed494df6f5cda150e402990e", "filename": "src/libcore/container.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/be9bddd46377bc982b73acf15a720365a54197a7/src%2Flibcore%2Fcontainer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be9bddd46377bc982b73acf15a720365a54197a7/src%2Flibcore%2Fcontainer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcontainer.rs?ref=be9bddd46377bc982b73acf15a720365a54197a7", "patch": "@@ -14,10 +14,10 @@ use option::Option;\n \n pub trait Container {\n     /// Return the number of elements in the container\n-    pure fn len(&const self) -> uint;\n+    fn len(&const self) -> uint;\n \n     /// Return true if the container contains no elements\n-    pure fn is_empty(&const self) -> bool;\n+    fn is_empty(&const self) -> bool;\n }\n \n pub trait Mutable: Container {\n@@ -27,19 +27,19 @@ pub trait Mutable: Container {\n \n pub trait Map<K, V>: Mutable {\n     /// Return true if the map contains a value for the specified key\n-    pure fn contains_key(&self, key: &K) -> bool;\n+    fn contains_key(&self, key: &K) -> bool;\n \n     /// Visit all keys\n-    pure fn each_key(&self, f: &fn(&K) -> bool);\n+    fn each_key(&self, f: &fn(&K) -> bool);\n \n     /// Visit all values\n-    pure fn each_value(&self, f: &fn(&V) -> bool);\n+    fn each_value(&self, f: &fn(&V) -> bool);\n \n     /// Iterate over the map and mutate the contained values\n     fn mutate_values(&mut self, f: &fn(&K, &mut V) -> bool);\n \n     /// Return the value corresponding to the key in the map\n-    pure fn find(&self, key: &K) -> Option<&'self V>;\n+    fn find(&self, key: &K) -> Option<&'self V>;\n \n     /// Insert a key-value pair into the map. An existing value for a\n     /// key is replaced by the new value. Return true if the key did\n@@ -53,7 +53,7 @@ pub trait Map<K, V>: Mutable {\n \n pub trait Set<T>: Mutable {\n     /// Return true if the set contains a value\n-    pure fn contains(&self, value: &T) -> bool;\n+    fn contains(&self, value: &T) -> bool;\n \n     /// Add a value to the set. Return true if the value was not already\n     /// present in the set.\n@@ -65,23 +65,23 @@ pub trait Set<T>: Mutable {\n \n     /// Return true if the set has no elements in common with `other`.\n     /// This is equivalent to checking for an empty intersection.\n-    pure fn is_disjoint(&self, other: &Self) -> bool;\n+    fn is_disjoint(&self, other: &Self) -> bool;\n \n     /// Return true if the set is a subset of another\n-    pure fn is_subset(&self, other: &Self) -> bool;\n+    fn is_subset(&self, other: &Self) -> bool;\n \n     /// Return true if the set is a superset of another\n-    pure fn is_superset(&self, other: &Self) -> bool;\n+    fn is_superset(&self, other: &Self) -> bool;\n \n     /// Visit the values representing the difference\n-    pure fn difference(&self, other: &Self, f: &fn(&T) -> bool);\n+    fn difference(&self, other: &Self, f: &fn(&T) -> bool);\n \n     /// Visit the values representing the symmetric difference\n-    pure fn symmetric_difference(&self, other: &Self, f: &fn(&T) -> bool);\n+    fn symmetric_difference(&self, other: &Self, f: &fn(&T) -> bool);\n \n     /// Visit the values representing the intersection\n-    pure fn intersection(&self, other: &Self, f: &fn(&T) -> bool);\n+    fn intersection(&self, other: &Self, f: &fn(&T) -> bool);\n \n     /// Visit the values representing the union\n-    pure fn union(&self, other: &Self, f: &fn(&T) -> bool);\n+    fn union(&self, other: &Self, f: &fn(&T) -> bool);\n }"}, {"sha": "ff86e8d1ffcdb35c9c1338578280d4fa9293ed58", "filename": "src/libcore/dlist.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/be9bddd46377bc982b73acf15a720365a54197a7/src%2Flibcore%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be9bddd46377bc982b73acf15a720365a54197a7/src%2Flibcore%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fdlist.rs?ref=be9bddd46377bc982b73acf15a720365a54197a7", "patch": "@@ -42,7 +42,7 @@ pub struct DList<T> {\n }\n \n priv impl<T> DListNode<T> {\n-    pure fn assert_links(@mut self) {\n+    fn assert_links(@mut self) {\n         match self.next {\n             Some(neighbour) => match neighbour.prev {\n               Some(me) => if !managed::mut_ptr_eq(self, me) {\n@@ -66,24 +66,24 @@ priv impl<T> DListNode<T> {\n \n pub impl<T> DListNode<T> {\n     /// Get the next node in the list, if there is one.\n-    pure fn next_link(@mut self) -> DListLink<T> {\n+    fn next_link(@mut self) -> DListLink<T> {\n         self.assert_links();\n         self.next\n     }\n     /// Get the next node in the list, failing if there isn't one.\n-    pure fn next_node(@mut self) -> @mut DListNode<T> {\n+    fn next_node(@mut self) -> @mut DListNode<T> {\n         match self.next_link() {\n             Some(nobe) => nobe,\n             None       => fail!(~\"This dlist node has no next neighbour.\")\n         }\n     }\n     /// Get the previous node in the list, if there is one.\n-    pure fn prev_link(@mut self) -> DListLink<T> {\n+    fn prev_link(@mut self) -> DListLink<T> {\n         self.assert_links();\n         self.prev\n     }\n     /// Get the previous node in the list, failing if there isn't one.\n-    pure fn prev_node(@mut self) -> @mut DListNode<T> {\n+    fn prev_node(@mut self) -> @mut DListNode<T> {\n         match self.prev_link() {\n             Some(nobe) => nobe,\n             None       => fail!(~\"This dlist node has no previous neighbour.\")\n@@ -92,17 +92,17 @@ pub impl<T> DListNode<T> {\n }\n \n /// Creates a new dlist node with the given data.\n-pub pure fn new_dlist_node<T>(data: T) -> @mut DListNode<T> {\n+pub fn new_dlist_node<T>(data: T) -> @mut DListNode<T> {\n     @mut DListNode { data: data, linked: false, prev: None, next: None }\n }\n \n /// Creates a new, empty dlist.\n-pub pure fn DList<T>() -> @mut DList<T> {\n+pub fn DList<T>() -> @mut DList<T> {\n     @mut DList { size: 0, hd: None, tl: None }\n }\n \n /// Creates a new dlist with a single element\n-pub pure fn from_elem<T>(data: T) -> @mut DList<T> {\n+pub fn from_elem<T>(data: T) -> @mut DList<T> {\n     let list = DList();\n     unsafe { list.push(data); }\n     list\n@@ -126,15 +126,15 @@ pub fn concat<T>(lists: @mut DList<@mut DList<T>>) -> @mut DList<T> {\n }\n \n priv impl<T> DList<T> {\n-    pure fn new_link(data: T) -> DListLink<T> {\n+    fn new_link(data: T) -> DListLink<T> {\n         Some(@mut DListNode {\n             data: data,\n             linked: true,\n             prev: None,\n             next: None\n         })\n     }\n-    pure fn assert_mine(@mut self, nobe: @mut DListNode<T>) {\n+    fn assert_mine(@mut self, nobe: @mut DListNode<T>) {\n         // These asserts could be stronger if we had node-root back-pointers,\n         // but those wouldn't allow for O(1) append.\n         if self.size == 0 {\n@@ -212,9 +212,9 @@ priv impl<T> DList<T> {\n \n pub impl<T> DList<T> {\n     /// Get the size of the list. O(1).\n-    pure fn len(@mut self) -> uint { self.size }\n+    fn len(@mut self) -> uint { self.size }\n     /// Returns true if the list is empty. O(1).\n-    pure fn is_empty(@mut self) -> bool { self.len() == 0 }\n+    fn is_empty(@mut self) -> bool { self.len() == 0 }\n \n     /// Add data to the head of the list. O(1).\n     fn push_head(@mut self, data: T) {\n@@ -316,20 +316,20 @@ pub impl<T> DList<T> {\n         tl\n     }\n     /// Get the node at the list's head. O(1).\n-    pure fn peek_n(@mut self) -> DListLink<T> { self.hd }\n+    fn peek_n(@mut self) -> DListLink<T> { self.hd }\n     /// Get the node at the list's tail. O(1).\n-    pure fn peek_tail_n(@mut self) -> DListLink<T> { self.tl }\n+    fn peek_tail_n(@mut self) -> DListLink<T> { self.tl }\n \n     /// Get the node at the list's head, failing if empty. O(1).\n-    pure fn head_n(@mut self) -> @mut DListNode<T> {\n+    fn head_n(@mut self) -> @mut DListNode<T> {\n         match self.hd {\n             Some(nobe) => nobe,\n             None       => fail!(\n                 ~\"Attempted to get the head of an empty dlist.\")\n         }\n     }\n     /// Get the node at the list's tail, failing if empty. O(1).\n-    pure fn tail_n(@mut self) -> @mut DListNode<T> {\n+    fn tail_n(@mut self) -> @mut DListNode<T> {\n         match self.tl {\n             Some(nobe) => nobe,\n             None       => fail!(\n@@ -399,7 +399,7 @@ pub impl<T> DList<T> {\n     }\n \n     /// Iterate over nodes.\n-    pure fn each_node(@mut self, f: &fn(@mut DListNode<T>) -> bool) {\n+    fn each_node(@mut self, f: &fn(@mut DListNode<T>) -> bool) {\n         let mut link = self.peek_n();\n         while link.is_some() {\n             let nobe = link.get();\n@@ -471,23 +471,23 @@ pub impl<T:Copy> DList<T> {\n     }\n \n     /// Get data at the list's head. O(1).\n-    pure fn peek(@mut self) -> Option<T> {\n+    fn peek(@mut self) -> Option<T> {\n         self.peek_n().map(|nobe| nobe.data)\n     }\n \n     /// Get data at the list's tail. O(1).\n-    pure fn peek_tail(@mut self) -> Option<T> {\n+    fn peek_tail(@mut self) -> Option<T> {\n         self.peek_tail_n().map (|nobe| nobe.data)\n     }\n \n     /// Get data at the list's head, failing if empty. O(1).\n-    pure fn head(@mut self) -> T { self.head_n().data }\n+    fn head(@mut self) -> T { self.head_n().data }\n \n     /// Get data at the list's tail, failing if empty. O(1).\n-    pure fn tail(@mut self) -> T { self.tail_n().data }\n+    fn tail(@mut self) -> T { self.tail_n().data }\n \n     /// Get the elements of the list as a vector. O(n).\n-    pure fn to_vec(@mut self) -> ~[T] {\n+    fn to_vec(@mut self) -> ~[T] {\n         let mut v = vec::with_capacity(self.size);\n         unsafe {\n             // Take this out of the unchecked when iter's functions are pure\n@@ -507,7 +507,7 @@ impl<T> BaseIter<T> for @mut DList<T> {\n     * allow for e.g. breadth-first search with in-place enqueues), but\n     * removing the current node is forbidden.\n     */\n-    pure fn each(&self, f: &fn(v: &T) -> bool) {\n+    fn each(&self, f: &fn(v: &T) -> bool) {\n         let mut link = self.peek_n();\n         while option::is_some(&link) {\n             let nobe = option::get(link);\n@@ -536,7 +536,7 @@ impl<T> BaseIter<T> for @mut DList<T> {\n     }\n \n     #[inline(always)]\n-    pure fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n+    fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n }\n \n #[cfg(test)]"}, {"sha": "1cf2c5e1fff2939cd7de8ea3f0a503773e4ef490", "filename": "src/libcore/either.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/be9bddd46377bc982b73acf15a720365a54197a7/src%2Flibcore%2Feither.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be9bddd46377bc982b73acf15a720365a54197a7/src%2Flibcore%2Feither.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Feither.rs?ref=be9bddd46377bc982b73acf15a720365a54197a7", "patch": "@@ -87,7 +87,7 @@ pub fn partition<T, U>(eithers: ~[Either<T, U>])\n }\n \n #[inline(always)]\n-pub pure fn flip<T, U>(eith: Either<T, U>) -> Either<U, T> {\n+pub fn flip<T, U>(eith: Either<T, U>) -> Either<U, T> {\n     //! Flips between left and right of a given either\n \n     match eith {\n@@ -97,7 +97,7 @@ pub pure fn flip<T, U>(eith: Either<T, U>) -> Either<U, T> {\n }\n \n #[inline(always)]\n-pub pure fn to_result<T, U>(eith: Either<T, U>)\n+pub fn to_result<T, U>(eith: Either<T, U>)\n     -> Result<U, T> {\n     /*!\n      * Converts either::t to a result::t\n@@ -113,21 +113,21 @@ pub pure fn to_result<T, U>(eith: Either<T, U>)\n }\n \n #[inline(always)]\n-pub pure fn is_left<T, U>(eith: &Either<T, U>) -> bool {\n+pub fn is_left<T, U>(eith: &Either<T, U>) -> bool {\n     //! Checks whether the given value is a left\n \n     match *eith { Left(_) => true, _ => false }\n }\n \n #[inline(always)]\n-pub pure fn is_right<T, U>(eith: &Either<T, U>) -> bool {\n+pub fn is_right<T, U>(eith: &Either<T, U>) -> bool {\n     //! Checks whether the given value is a right\n \n     match *eith { Right(_) => true, _ => false }\n }\n \n #[inline(always)]\n-pub pure fn unwrap_left<T,U>(eith: Either<T,U>) -> T {\n+pub fn unwrap_left<T,U>(eith: Either<T,U>) -> T {\n     //! Retrieves the value in the left branch. Fails if the either is Right.\n \n     match eith {\n@@ -137,7 +137,7 @@ pub pure fn unwrap_left<T,U>(eith: Either<T,U>) -> T {\n }\n \n #[inline(always)]\n-pub pure fn unwrap_right<T,U>(eith: Either<T,U>) -> U {\n+pub fn unwrap_right<T,U>(eith: Either<T,U>) -> U {\n     //! Retrieves the value in the right branch. Fails if the either is Left.\n \n     match eith {"}, {"sha": "ebf6d212466a5f7ce2a37c93e971a28ce2f49b28", "filename": "src/libcore/from_str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/be9bddd46377bc982b73acf15a720365a54197a7/src%2Flibcore%2Ffrom_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be9bddd46377bc982b73acf15a720365a54197a7/src%2Flibcore%2Ffrom_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffrom_str.rs?ref=be9bddd46377bc982b73acf15a720365a54197a7", "patch": "@@ -13,5 +13,5 @@\n use option::Option;\n \n pub trait FromStr {\n-    pure fn from_str(s: &str) -> Option<Self>;\n+    fn from_str(s: &str) -> Option<Self>;\n }"}, {"sha": "1bfa0e9522ddd4a08ef8f10658ae7375732bcb88", "filename": "src/libcore/hash.rs", "status": "modified", "additions": 20, "deletions": 22, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/be9bddd46377bc982b73acf15a720365a54197a7/src%2Flibcore%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be9bddd46377bc982b73acf15a720365a54197a7/src%2Flibcore%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash.rs?ref=be9bddd46377bc982b73acf15a720365a54197a7", "patch": "@@ -50,17 +50,17 @@ pub trait Hash {\n      * function and require most types to only implement the\n      * IterBytes trait, that feeds SipHash.\n      */\n-    pure fn hash_keyed(&self, k0: u64, k1: u64) -> u64;\n+    fn hash_keyed(&self, k0: u64, k1: u64) -> u64;\n }\n \n // When we have default methods, won't need this.\n pub trait HashUtil {\n-    pure fn hash(&self) -> u64;\n+    fn hash(&self) -> u64;\n }\n \n impl<A:Hash> HashUtil for A {\n     #[inline(always)]\n-    pure fn hash(&self) -> u64 { self.hash_keyed(0,0) }\n+    fn hash(&self) -> u64 { self.hash_keyed(0,0) }\n }\n \n /// Streaming hash-functions should implement this.\n@@ -75,7 +75,7 @@ pub trait Streaming {\n \n impl<A:IterBytes> Hash for A {\n     #[inline(always)]\n-    pure fn hash_keyed(&self, k0: u64, k1: u64) -> u64 {\n+    fn hash_keyed(&self, k0: u64, k1: u64) -> u64 {\n         unsafe {\n             let s = &State(k0, k1);\n             for self.iter_bytes(true) |bytes| {\n@@ -86,9 +86,8 @@ impl<A:IterBytes> Hash for A {\n     }\n }\n \n-pure fn hash_keyed_2<A: IterBytes,\n-                     B: IterBytes>(a: &A, b: &B,\n-                                   k0: u64, k1: u64) -> u64 {\n+fn hash_keyed_2<A: IterBytes,\n+                B: IterBytes>(a: &A, b: &B, k0: u64, k1: u64) -> u64 {\n     unsafe {\n         let s = &State(k0, k1);\n         for a.iter_bytes(true) |bytes| { s.input(bytes); }\n@@ -97,10 +96,9 @@ pure fn hash_keyed_2<A: IterBytes,\n     }\n }\n \n-pure fn hash_keyed_3<A: IterBytes,\n-                     B: IterBytes,\n-                     C: IterBytes>(a: &A, b: &B, c: &C,\n-                                   k0: u64, k1: u64) -> u64 {\n+fn hash_keyed_3<A: IterBytes,\n+                B: IterBytes,\n+                C: IterBytes>(a: &A, b: &B, c: &C, k0: u64, k1: u64) -> u64 {\n     unsafe {\n         let s = &State(k0, k1);\n         for a.iter_bytes(true) |bytes| { s.input(bytes); }\n@@ -110,11 +108,11 @@ pure fn hash_keyed_3<A: IterBytes,\n     }\n }\n \n-pure fn hash_keyed_4<A: IterBytes,\n-                     B: IterBytes,\n-                     C: IterBytes,\n-                     D: IterBytes>(a: &A, b: &B, c: &C, d: &D,\n-                                   k0: u64, k1: u64) -> u64 {\n+fn hash_keyed_4<A: IterBytes,\n+                B: IterBytes,\n+                C: IterBytes,\n+                D: IterBytes>(a: &A, b: &B, c: &C, d: &D, k0: u64, k1: u64)\n+                           -> u64 {\n     unsafe {\n         let s = &State(k0, k1);\n         for a.iter_bytes(true) |bytes| { s.input(bytes); }\n@@ -125,12 +123,12 @@ pure fn hash_keyed_4<A: IterBytes,\n     }\n }\n \n-pure fn hash_keyed_5<A: IterBytes,\n-                     B: IterBytes,\n-                     C: IterBytes,\n-                     D: IterBytes,\n-                     E: IterBytes>(a: &A, b: &B, c: &C, d: &D, e: &E,\n-                                   k0: u64, k1: u64) -> u64 {\n+fn hash_keyed_5<A: IterBytes,\n+                B: IterBytes,\n+                C: IterBytes,\n+                D: IterBytes,\n+                E: IterBytes>(a: &A, b: &B, c: &C, d: &D, e: &E,\n+                              k0: u64, k1: u64) -> u64 {\n     unsafe {\n         let s = &State(k0, k1);\n         for a.iter_bytes(true) |bytes| { s.input(bytes); }"}, {"sha": "64806cd21aaecb9f34b71559e477becf3373601c", "filename": "src/libcore/hashmap.rs", "status": "modified", "additions": 49, "deletions": 58, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/be9bddd46377bc982b73acf15a720365a54197a7/src%2Flibcore%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be9bddd46377bc982b73acf15a720365a54197a7/src%2Flibcore%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhashmap.rs?ref=be9bddd46377bc982b73acf15a720365a54197a7", "patch": "@@ -48,7 +48,7 @@ pub mod linear {\n     }\n \n     #[inline(always)]\n-    pure fn resize_at(capacity: uint) -> uint {\n+    fn resize_at(capacity: uint) -> uint {\n         ((capacity as float) * 3. / 4.) as uint\n     }\n \n@@ -59,7 +59,7 @@ pub mod linear {\n                                           initial_capacity)\n     }\n \n-    pure fn linear_map_with_capacity_and_keys<K:Eq + Hash,V>(\n+    fn linear_map_with_capacity_and_keys<K:Eq + Hash,V>(\n         k0: u64, k1: u64,\n         initial_capacity: uint) -> LinearMap<K, V> {\n         LinearMap {\n@@ -72,21 +72,21 @@ pub mod linear {\n \n     priv impl<K:Hash + IterBytes + Eq,V> LinearMap<K, V> {\n         #[inline(always)]\n-        pure fn to_bucket(&self, h: uint) -> uint {\n+        fn to_bucket(&self, h: uint) -> uint {\n             // A good hash function with entropy spread over all of the\n             // bits is assumed. SipHash is more than good enough.\n             h % self.buckets.len()\n         }\n \n         #[inline(always)]\n-        pure fn next_bucket(&self, idx: uint, len_buckets: uint) -> uint {\n+        fn next_bucket(&self, idx: uint, len_buckets: uint) -> uint {\n             let n = (idx + 1) % len_buckets;\n             debug!(\"next_bucket(%?, %?) = %?\", idx, len_buckets, n);\n             n\n         }\n \n         #[inline(always)]\n-        pure fn bucket_sequence(&self, hash: uint,\n+        fn bucket_sequence(&self, hash: uint,\n                                 op: &fn(uint) -> bool) -> uint {\n             let start_idx = self.to_bucket(hash);\n             let len_buckets = self.buckets.len();\n@@ -103,24 +103,24 @@ pub mod linear {\n         }\n \n         #[inline(always)]\n-        pure fn bucket_for_key(&self, k: &K) -> SearchResult {\n+        fn bucket_for_key(&self, k: &K) -> SearchResult {\n             let hash = k.hash_keyed(self.k0, self.k1) as uint;\n             self.bucket_for_key_with_hash(hash, k)\n         }\n \n         #[inline(always)]\n-        pure fn bucket_for_key_equiv<Q:Hash + IterBytes + Equiv<K>>(\n-                &self,\n-                k: &Q)\n-             -> SearchResult {\n+        fn bucket_for_key_equiv<Q:Hash + IterBytes + Equiv<K>>(&self,\n+                                                               k: &Q)\n+                                                            -> SearchResult {\n             let hash = k.hash_keyed(self.k0, self.k1) as uint;\n             self.bucket_for_key_with_hash_equiv(hash, k)\n         }\n \n         #[inline(always)]\n-        pure fn bucket_for_key_with_hash(&self,\n-                                         hash: uint,\n-                                         k: &K) -> SearchResult {\n+        fn bucket_for_key_with_hash(&self,\n+                                    hash: uint,\n+                                    k: &K)\n+                                 -> SearchResult {\n             let _ = for self.bucket_sequence(hash) |i| {\n                 match self.buckets[i] {\n                     Some(ref bkt) => if bkt.hash == hash && *k == bkt.key {\n@@ -133,10 +133,10 @@ pub mod linear {\n         }\n \n         #[inline(always)]\n-        pure fn bucket_for_key_with_hash_equiv<Q:Equiv<K>>(&self,\n-                                                           hash: uint,\n-                                                           k: &Q)\n-                                                        -> SearchResult {\n+        fn bucket_for_key_with_hash_equiv<Q:Equiv<K>>(&self,\n+                                                      hash: uint,\n+                                                      k: &Q)\n+                                                   -> SearchResult {\n             let _ = for self.bucket_sequence(hash) |i| {\n                 match self.buckets[i] {\n                     Some(ref bkt) => {\n@@ -185,7 +185,7 @@ pub mod linear {\n         }\n \n         #[inline(always)]\n-        pure fn value_for_bucket(&self, idx: uint) -> &'self V {\n+        fn value_for_bucket(&self, idx: uint) -> &'self V {\n             match self.buckets[idx] {\n                 Some(ref bkt) => &bkt.value,\n                 None => fail!(~\"LinearMap::find: internal logic error\"),\n@@ -273,7 +273,7 @@ pub mod linear {\n         BaseIter<(&'self K, &'self V)> for LinearMap<K, V>\n     {\n         /// Visit all key-value pairs\n-        pure fn each(&self, blk: &fn(&(&'self K, &'self V)) -> bool) {\n+        fn each(&self, blk: &fn(&(&'self K, &'self V)) -> bool) {\n             for uint::range(0, self.buckets.len()) |i| {\n                 let mut broke = false;\n                 do self.buckets[i].map |bucket| {\n@@ -284,16 +284,16 @@ pub mod linear {\n                 if broke { break; }\n             }\n         }\n-        pure fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n+        fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n     }\n \n \n     impl<K:Hash + IterBytes + Eq,V> Container for LinearMap<K, V> {\n         /// Return the number of elements in the map\n-        pure fn len(&const self) -> uint { self.size }\n+        fn len(&const self) -> uint { self.size }\n \n         /// Return true if the map contains no elements\n-        pure fn is_empty(&const self) -> bool { self.len() == 0 }\n+        fn is_empty(&const self) -> bool { self.len() == 0 }\n     }\n \n     impl<K:Hash + IterBytes + Eq,V> Mutable for LinearMap<K, V> {\n@@ -308,20 +308,20 @@ pub mod linear {\n \n     impl<K:Hash + IterBytes + Eq,V> Map<K, V> for LinearMap<K, V> {\n         /// Return true if the map contains a value for the specified key\n-        pure fn contains_key(&self, k: &K) -> bool {\n+        fn contains_key(&self, k: &K) -> bool {\n             match self.bucket_for_key(k) {\n                 FoundEntry(_) => {true}\n                 TableFull | FoundHole(_) => {false}\n             }\n         }\n \n         /// Visit all keys\n-        pure fn each_key(&self, blk: &fn(k: &K) -> bool) {\n+        fn each_key(&self, blk: &fn(k: &K) -> bool) {\n             self.each(|&(k, _)| blk(k))\n         }\n \n         /// Visit all values\n-        pure fn each_value(&self, blk: &fn(v: &V) -> bool) {\n+        fn each_value(&self, blk: &fn(v: &V) -> bool) {\n             self.each(|&(_, v)| blk(v))\n         }\n \n@@ -339,7 +339,7 @@ pub mod linear {\n         }\n \n         /// Return the value corresponding to the key in the map\n-        pure fn find(&self, k: &K) -> Option<&'self V> {\n+        fn find(&self, k: &K) -> Option<&'self V> {\n             match self.bucket_for_key(k) {\n                 FoundEntry(idx) => Some(self.value_for_bucket(idx)),\n                 TableFull | FoundHole(_) => None,\n@@ -487,7 +487,7 @@ pub mod linear {\n             }\n         }\n \n-        pure fn get(&self, k: &K) -> &'self V {\n+        fn get(&self, k: &K) -> &'self V {\n             match self.find(k) {\n                 Some(v) => v,\n                 None => fail!(fmt!(\"No entry found for key: %?\", k)),\n@@ -496,10 +496,8 @@ pub mod linear {\n \n         /// Return true if the map contains a value for the specified key,\n         /// using equivalence\n-        pure fn contains_key_equiv<Q:Hash + IterBytes + Equiv<K>>(\n-                &self,\n-                key: &Q)\n-             -> bool {\n+        fn contains_key_equiv<Q:Hash + IterBytes + Equiv<K>>(&self, key: &Q)\n+                                                          -> bool {\n             match self.bucket_for_key_equiv(key) {\n                 FoundEntry(_) => {true}\n                 TableFull | FoundHole(_) => {false}\n@@ -508,8 +506,8 @@ pub mod linear {\n \n         /// Return the value corresponding to the key in the map, using\n         /// equivalence\n-        pure fn find_equiv<Q:Hash + IterBytes + Equiv<K>>(&self, k: &Q)\n-                                                       -> Option<&'self V> {\n+        fn find_equiv<Q:Hash + IterBytes + Equiv<K>>(&self, k: &Q)\n+                                                  -> Option<&'self V> {\n             match self.bucket_for_key_equiv(k) {\n                 FoundEntry(idx) => Some(self.value_for_bucket(idx)),\n                 TableFull | FoundHole(_) => None,\n@@ -518,7 +516,7 @@ pub mod linear {\n     }\n \n     impl<K:Hash + IterBytes + Eq,V:Eq> Eq for LinearMap<K, V> {\n-        pure fn eq(&self, other: &LinearMap<K, V>) -> bool {\n+        fn eq(&self, other: &LinearMap<K, V>) -> bool {\n             if self.len() != other.len() { return false; }\n \n             for self.each |&(key, value)| {\n@@ -531,7 +529,7 @@ pub mod linear {\n             true\n         }\n \n-        pure fn ne(&self, other: &LinearMap<K, V>) -> bool { !self.eq(other) }\n+        fn ne(&self, other: &LinearMap<K, V>) -> bool { !self.eq(other) }\n     }\n \n     pub struct LinearSet<T> {\n@@ -540,25 +538,21 @@ pub mod linear {\n \n     impl<T:Hash + IterBytes + Eq> BaseIter<T> for LinearSet<T> {\n         /// Visit all values in order\n-        pure fn each(&self, f: &fn(&T) -> bool) { self.map.each_key(f) }\n-        pure fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n+        fn each(&self, f: &fn(&T) -> bool) { self.map.each_key(f) }\n+        fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n     }\n \n     impl<T:Hash + IterBytes + Eq> Eq for LinearSet<T> {\n-        pure fn eq(&self, other: &LinearSet<T>) -> bool {\n-            self.map == other.map\n-        }\n-        pure fn ne(&self, other: &LinearSet<T>) -> bool {\n-            self.map != other.map\n-        }\n+        fn eq(&self, other: &LinearSet<T>) -> bool { self.map == other.map }\n+        fn ne(&self, other: &LinearSet<T>) -> bool { self.map != other.map }\n     }\n \n     impl<T:Hash + IterBytes + Eq> Container for LinearSet<T> {\n         /// Return the number of elements in the set\n-        pure fn len(&const self) -> uint { self.map.len() }\n+        fn len(&const self) -> uint { self.map.len() }\n \n         /// Return true if the set contains no elements\n-        pure fn is_empty(&const self) -> bool { self.map.is_empty() }\n+        fn is_empty(&const self) -> bool { self.map.is_empty() }\n     }\n \n     impl<T:Hash + IterBytes + Eq> Mutable for LinearSet<T> {\n@@ -568,9 +562,7 @@ pub mod linear {\n \n     impl<T:Hash + IterBytes + Eq> Set<T> for LinearSet<T> {\n         /// Return true if the set contains a value\n-        pure fn contains(&self, value: &T) -> bool {\n-            self.map.contains_key(value)\n-        }\n+        fn contains(&self, value: &T) -> bool { self.map.contains_key(value) }\n \n         /// Add a value to the set. Return true if the value was not already\n         /// present in the set.\n@@ -582,22 +574,22 @@ pub mod linear {\n \n         /// Return true if the set has no elements in common with `other`.\n         /// This is equivalent to checking for an empty intersection.\n-        pure fn is_disjoint(&self, other: &LinearSet<T>) -> bool {\n+        fn is_disjoint(&self, other: &LinearSet<T>) -> bool {\n             iter::all(self, |v| !other.contains(v))\n         }\n \n         /// Return true if the set is a subset of another\n-        pure fn is_subset(&self, other: &LinearSet<T>) -> bool {\n+        fn is_subset(&self, other: &LinearSet<T>) -> bool {\n             iter::all(self, |v| other.contains(v))\n         }\n \n         /// Return true if the set is a superset of another\n-        pure fn is_superset(&self, other: &LinearSet<T>) -> bool {\n+        fn is_superset(&self, other: &LinearSet<T>) -> bool {\n             other.is_subset(self)\n         }\n \n         /// Visit the values representing the difference\n-        pure fn difference(&self, other: &LinearSet<T>, f: &fn(&T) -> bool) {\n+        fn difference(&self, other: &LinearSet<T>, f: &fn(&T) -> bool) {\n             for self.each |v| {\n                 if !other.contains(v) {\n                     if !f(v) { return }\n@@ -606,16 +598,15 @@ pub mod linear {\n         }\n \n         /// Visit the values representing the symmetric difference\n-        pure fn symmetric_difference(&self, other: &LinearSet<T>,\n-                                     f: &fn(&T) -> bool) {\n+        fn symmetric_difference(&self,\n+                                other: &LinearSet<T>,\n+                                f: &fn(&T) -> bool) {\n             self.difference(other, f);\n             other.difference(self, f);\n         }\n \n         /// Visit the values representing the intersection\n-        pure fn intersection(&self,\n-                             other: &LinearSet<T>,\n-                             f: &fn(&T) -> bool) {\n+        fn intersection(&self, other: &LinearSet<T>, f: &fn(&T) -> bool) {\n             for self.each |v| {\n                 if other.contains(v) {\n                     if !f(v) { return }\n@@ -624,7 +615,7 @@ pub mod linear {\n         }\n \n         /// Visit the values representing the union\n-        pure fn union(&self, other: &LinearSet<T>, f: &fn(&T) -> bool) {\n+        fn union(&self, other: &LinearSet<T>, f: &fn(&T) -> bool) {\n             for self.each |v| {\n                 if !f(v) { return }\n             }"}, {"sha": "fb305560ba333c32cb88dc2cab9c8edc755d55da", "filename": "src/libcore/io.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/be9bddd46377bc982b73acf15a720365a54197a7/src%2Flibcore%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be9bddd46377bc982b73acf15a720365a54197a7/src%2Flibcore%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fio.rs?ref=be9bddd46377bc982b73acf15a720365a54197a7", "patch": "@@ -646,11 +646,11 @@ impl Reader for BytesReader<'self> {\n     fn tell(&self) -> uint { self.pos }\n }\n \n-pub pure fn with_bytes_reader<t>(bytes: &[u8], f: &fn(@Reader) -> t) -> t {\n+pub fn with_bytes_reader<t>(bytes: &[u8], f: &fn(@Reader) -> t) -> t {\n     f(@BytesReader { bytes: bytes, pos: 0u } as @Reader)\n }\n \n-pub pure fn with_str_reader<T>(s: &str, f: &fn(@Reader) -> T) -> T {\n+pub fn with_str_reader<T>(s: &str, f: &fn(@Reader) -> T) -> T {\n     str::byte_slice(s, |bytes| with_bytes_reader(bytes, f))\n }\n \n@@ -1165,18 +1165,18 @@ impl Writer for BytesWriter {\n     fn get_type(&self) -> WriterType { File }\n }\n \n-pub pure fn BytesWriter() -> BytesWriter {\n+pub fn BytesWriter() -> BytesWriter {\n     BytesWriter { bytes: ~[], mut pos: 0u }\n }\n \n-pub pure fn with_bytes_writer(f: &fn(@Writer)) -> ~[u8] {\n+pub fn with_bytes_writer(f: &fn(@Writer)) -> ~[u8] {\n     let wr = @BytesWriter();\n     f(wr as @Writer);\n     let @BytesWriter{bytes, _} = wr;\n     return bytes;\n }\n \n-pub pure fn with_str_writer(f: &fn(@Writer)) -> ~str {\n+pub fn with_str_writer(f: &fn(@Writer)) -> ~str {\n     let mut v = with_bytes_writer(f);\n \n     // FIXME (#3758): This should not be needed."}, {"sha": "f94c62d23ece330572016d9aba8fed3698098a97", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 50, "deletions": 63, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/be9bddd46377bc982b73acf15a720365a54197a7/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be9bddd46377bc982b73acf15a720365a54197a7/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=be9bddd46377bc982b73acf15a720365a54197a7", "patch": "@@ -23,54 +23,53 @@ use vec;\n pub type InitOp<T> = &'self fn(uint) -> T;\n \n pub trait BaseIter<A> {\n-    pure fn each(&self, blk: &fn(v: &A) -> bool);\n-    pure fn size_hint(&self) -> Option<uint>;\n+    fn each(&self, blk: &fn(v: &A) -> bool);\n+    fn size_hint(&self) -> Option<uint>;\n }\n \n pub trait ReverseIter<A>: BaseIter<A> {\n-    pure fn each_reverse(&self, blk: &fn(&A) -> bool);\n+    fn each_reverse(&self, blk: &fn(&A) -> bool);\n }\n \n pub trait MutableIter<A>: BaseIter<A> {\n     fn each_mut(&mut self, blk: &fn(&mut A) -> bool);\n }\n \n pub trait ExtendedIter<A> {\n-    pure fn eachi(&self, blk: &fn(uint, v: &A) -> bool);\n-    pure fn all(&self, blk: &fn(&A) -> bool) -> bool;\n-    pure fn any(&self, blk: &fn(&A) -> bool) -> bool;\n-    pure fn foldl<B>(&self, b0: B, blk: &fn(&B, &A) -> B) -> B;\n-    pure fn position(&self, f: &fn(&A) -> bool) -> Option<uint>;\n-    pure fn map_to_vec<B>(&self, op: &fn(&A) -> B) -> ~[B];\n-    pure fn flat_map_to_vec<B,IB: BaseIter<B>>(&self, op: &fn(&A) -> IB)\n-        -> ~[B];\n+    fn eachi(&self, blk: &fn(uint, v: &A) -> bool);\n+    fn all(&self, blk: &fn(&A) -> bool) -> bool;\n+    fn any(&self, blk: &fn(&A) -> bool) -> bool;\n+    fn foldl<B>(&self, b0: B, blk: &fn(&B, &A) -> B) -> B;\n+    fn position(&self, f: &fn(&A) -> bool) -> Option<uint>;\n+    fn map_to_vec<B>(&self, op: &fn(&A) -> B) -> ~[B];\n+    fn flat_map_to_vec<B,IB: BaseIter<B>>(&self, op: &fn(&A) -> IB) -> ~[B];\n }\n \n pub trait EqIter<A:Eq> {\n-    pure fn contains(&self, x: &A) -> bool;\n-    pure fn count(&self, x: &A) -> uint;\n+    fn contains(&self, x: &A) -> bool;\n+    fn count(&self, x: &A) -> uint;\n }\n \n pub trait Times {\n-    pure fn times(&self, it: &fn() -> bool);\n+    fn times(&self, it: &fn() -> bool);\n }\n \n pub trait CopyableIter<A:Copy> {\n-    pure fn filter_to_vec(&self, pred: &fn(&A) -> bool) -> ~[A];\n-    pure fn to_vec(&self) -> ~[A];\n-    pure fn find(&self, p: &fn(&A) -> bool) -> Option<A>;\n+    fn filter_to_vec(&self, pred: &fn(&A) -> bool) -> ~[A];\n+    fn to_vec(&self) -> ~[A];\n+    fn find(&self, p: &fn(&A) -> bool) -> Option<A>;\n }\n \n pub trait CopyableOrderedIter<A:Copy + Ord> {\n-    pure fn min(&self) -> A;\n-    pure fn max(&self) -> A;\n+    fn min(&self) -> A;\n+    fn max(&self) -> A;\n }\n \n pub trait CopyableNonstrictIter<A:Copy> {\n     // Like \"each\", but copies out the value. If the receiver is mutated while\n     // iterating over it, the semantics must not be memory-unsafe but are\n     // otherwise undefined.\n-    pure fn each_val(&const self, f: &fn(A) -> bool);\n+    fn each_val(&const self, f: &fn(A) -> bool);\n }\n \n // A trait for sequences that can be built by imperatively pushing elements\n@@ -89,13 +88,11 @@ pub trait Buildable<A> {\n      *             as an argument a function that will push an element\n      *             onto the sequence being constructed.\n      */\n-     pure fn build_sized(size: uint,\n-                         builder: &fn(push: &pure fn(A))) -> Self;\n+     fn build_sized(size: uint, builder: &fn(push: &fn(A))) -> Self;\n }\n \n #[inline(always)]\n-pub pure fn eachi<A,IA:BaseIter<A>>(self: &IA,\n-                                    blk: &fn(uint, &A) -> bool) {\n+pub fn eachi<A,IA:BaseIter<A>>(self: &IA, blk: &fn(uint, &A) -> bool) {\n     let mut i = 0;\n     for self.each |a| {\n         if !blk(i, a) { break; }\n@@ -104,26 +101,25 @@ pub pure fn eachi<A,IA:BaseIter<A>>(self: &IA,\n }\n \n #[inline(always)]\n-pub pure fn all<A,IA:BaseIter<A>>(self: &IA,\n-                                  blk: &fn(&A) -> bool) -> bool {\n+pub fn all<A,IA:BaseIter<A>>(self: &IA, blk: &fn(&A) -> bool) -> bool {\n     for self.each |a| {\n         if !blk(a) { return false; }\n     }\n     return true;\n }\n \n #[inline(always)]\n-pub pure fn any<A,IA:BaseIter<A>>(self: &IA,\n-                                  blk: &fn(&A) -> bool) -> bool {\n+pub fn any<A,IA:BaseIter<A>>(self: &IA, blk: &fn(&A) -> bool) -> bool {\n     for self.each |a| {\n         if blk(a) { return true; }\n     }\n     return false;\n }\n \n #[inline(always)]\n-pub pure fn filter_to_vec<A:Copy,IA:BaseIter<A>>(\n-    self: &IA, prd: &fn(&A) -> bool) -> ~[A] {\n+pub fn filter_to_vec<A:Copy,IA:BaseIter<A>>(self: &IA,\n+                                            prd: &fn(&A) -> bool)\n+                                         -> ~[A] {\n     do vec::build_sized_opt(self.size_hint()) |push| {\n         for self.each |a| {\n             if prd(a) { push(*a); }\n@@ -132,9 +128,7 @@ pub pure fn filter_to_vec<A:Copy,IA:BaseIter<A>>(\n }\n \n #[inline(always)]\n-pub pure fn map_to_vec<A,B,IA:BaseIter<A>>(self: &IA,\n-                                           op: &fn(&A) -> B)\n-    -> ~[B] {\n+pub fn map_to_vec<A,B,IA:BaseIter<A>>(self: &IA, op: &fn(&A) -> B) -> ~[B] {\n     do vec::build_sized_opt(self.size_hint()) |push| {\n         for self.each |a| {\n             push(op(a));\n@@ -143,8 +137,9 @@ pub pure fn map_to_vec<A,B,IA:BaseIter<A>>(self: &IA,\n }\n \n #[inline(always)]\n-pub pure fn flat_map_to_vec<A,B,IA:BaseIter<A>,IB:BaseIter<B>>(\n-    self: &IA, op: &fn(&A) -> IB) -> ~[B] {\n+pub fn flat_map_to_vec<A,B,IA:BaseIter<A>,IB:BaseIter<B>>(self: &IA,\n+                                                          op: &fn(&A) -> IB)\n+                                                       -> ~[B] {\n     do vec::build |push| {\n         for self.each |a| {\n             for op(a).each |&b| {\n@@ -155,9 +150,8 @@ pub pure fn flat_map_to_vec<A,B,IA:BaseIter<A>,IB:BaseIter<B>>(\n }\n \n #[inline(always)]\n-pub pure fn foldl<A,B,IA:BaseIter<A>>(self: &IA, b0: B,\n-                                      blk: &fn(&B, &A) -> B)\n-    -> B {\n+pub fn foldl<A,B,IA:BaseIter<A>>(self: &IA, b0: B, blk: &fn(&B, &A) -> B)\n+                              -> B {\n     let mut b = b0;\n     for self.each |a| {\n         b = blk(&b, a);\n@@ -166,20 +160,20 @@ pub pure fn foldl<A,B,IA:BaseIter<A>>(self: &IA, b0: B,\n }\n \n #[inline(always)]\n-pub pure fn to_vec<A:Copy,IA:BaseIter<A>>(self: &IA) -> ~[A] {\n+pub fn to_vec<A:Copy,IA:BaseIter<A>>(self: &IA) -> ~[A] {\n     foldl::<A,~[A],IA>(self, ~[], |r, a| vec::append(copy (*r), ~[*a]))\n }\n \n #[inline(always)]\n-pub pure fn contains<A:Eq,IA:BaseIter<A>>(self: &IA, x: &A) -> bool {\n+pub fn contains<A:Eq,IA:BaseIter<A>>(self: &IA, x: &A) -> bool {\n     for self.each |a| {\n         if *a == *x { return true; }\n     }\n     return false;\n }\n \n #[inline(always)]\n-pub pure fn count<A:Eq,IA:BaseIter<A>>(self: &IA, x: &A) -> uint {\n+pub fn count<A:Eq,IA:BaseIter<A>>(self: &IA, x: &A) -> uint {\n     do foldl(self, 0) |count, value| {\n         if *value == *x {\n             *count + 1\n@@ -190,9 +184,8 @@ pub pure fn count<A:Eq,IA:BaseIter<A>>(self: &IA, x: &A) -> uint {\n }\n \n #[inline(always)]\n-pub pure fn position<A,IA:BaseIter<A>>(self: &IA, f: &fn(&A) -> bool)\n-    -> Option<uint>\n-{\n+pub fn position<A,IA:BaseIter<A>>(self: &IA, f: &fn(&A) -> bool)\n+                               -> Option<uint> {\n     let mut i = 0;\n     for self.each |a| {\n         if f(a) { return Some(i); }\n@@ -206,7 +199,7 @@ pub pure fn position<A,IA:BaseIter<A>>(self: &IA, f: &fn(&A) -> bool)\n // it would have to be implemented with foldr, which is too inefficient.\n \n #[inline(always)]\n-pub pure fn repeat(times: uint, blk: &fn() -> bool) {\n+pub fn repeat(times: uint, blk: &fn() -> bool) {\n     let mut i = 0;\n     while i < times {\n         if !blk() { break }\n@@ -215,7 +208,7 @@ pub pure fn repeat(times: uint, blk: &fn() -> bool) {\n }\n \n #[inline(always)]\n-pub pure fn min<A:Copy + Ord,IA:BaseIter<A>>(self: &IA) -> A {\n+pub fn min<A:Copy + Ord,IA:BaseIter<A>>(self: &IA) -> A {\n     match do foldl::<A,Option<A>,IA>(self, None) |a, b| {\n         match a {\n           &Some(ref a_) if *a_ < *b => {\n@@ -230,7 +223,7 @@ pub pure fn min<A:Copy + Ord,IA:BaseIter<A>>(self: &IA) -> A {\n }\n \n #[inline(always)]\n-pub pure fn max<A:Copy + Ord,IA:BaseIter<A>>(self: &IA) -> A {\n+pub fn max<A:Copy + Ord,IA:BaseIter<A>>(self: &IA) -> A {\n     match do foldl::<A,Option<A>,IA>(self, None) |a, b| {\n         match a {\n           &Some(ref a_) if *a_ > *b => {\n@@ -245,8 +238,8 @@ pub pure fn max<A:Copy + Ord,IA:BaseIter<A>>(self: &IA) -> A {\n }\n \n #[inline(always)]\n-pub pure fn find<A:Copy,IA:BaseIter<A>>(self: &IA,\n-                                   f: &fn(&A) -> bool) -> Option<A> {\n+pub fn find<A:Copy,IA:BaseIter<A>>(self: &IA, f: &fn(&A) -> bool)\n+                                -> Option<A> {\n     for self.each |i| {\n         if f(i) { return Some(*i) }\n     }\n@@ -266,8 +259,7 @@ pub pure fn find<A:Copy,IA:BaseIter<A>>(self: &IA,\n  *             onto the sequence being constructed.\n  */\n #[inline(always)]\n-pub pure fn build<A,B: Buildable<A>>(builder: &fn(push: &pure fn(A)))\n-    -> B {\n+pub fn build<A,B: Buildable<A>>(builder: &fn(push: &fn(A))) -> B {\n     Buildable::build_sized(4, builder)\n }\n \n@@ -285,10 +277,8 @@ pub pure fn build<A,B: Buildable<A>>(builder: &fn(push: &pure fn(A)))\n  *             onto the sequence being constructed.\n  */\n #[inline(always)]\n-pub pure fn build_sized_opt<A,B: Buildable<A>>(\n-    size: Option<uint>,\n-    builder: &fn(push: &pure fn(A))) -> B {\n-\n+pub fn build_sized_opt<A,B: Buildable<A>>(size: Option<uint>,\n+                                          builder: &fn(push: &fn(A))) -> B {\n     Buildable::build_sized(size.get_or_default(4), builder)\n }\n \n@@ -312,8 +302,7 @@ pub fn map<T,IT: BaseIter<T>,U,BU: Buildable<U>>(v: &IT, f: &fn(&T) -> U)\n  * to the value returned by the function `op`.\n  */\n #[inline(always)]\n-pub pure fn from_fn<T,BT: Buildable<T>>(n_elts: uint,\n-                                        op: InitOp<T>) -> BT {\n+pub fn from_fn<T,BT: Buildable<T>>(n_elts: uint, op: InitOp<T>) -> BT {\n     do Buildable::build_sized(n_elts) |push| {\n         let mut i: uint = 0u;\n         while i < n_elts { push(op(i)); i += 1u; }\n@@ -327,8 +316,7 @@ pub pure fn from_fn<T,BT: Buildable<T>>(n_elts: uint,\n  * to the value `t`.\n  */\n #[inline(always)]\n-pub pure fn from_elem<T:Copy,BT:Buildable<T>>(n_elts: uint,\n-                                                t: T) -> BT {\n+pub fn from_elem<T:Copy,BT:Buildable<T>>(n_elts: uint, t: T) -> BT {\n     do Buildable::build_sized(n_elts) |push| {\n         let mut i: uint = 0;\n         while i < n_elts { push(t); i += 1; }\n@@ -337,8 +325,8 @@ pub pure fn from_elem<T:Copy,BT:Buildable<T>>(n_elts: uint,\n \n /// Appends two generic sequences.\n #[inline(always)]\n-pub pure fn append<T:Copy,IT:BaseIter<T>,BT:Buildable<T>>(\n-    lhs: &IT, rhs: &IT) -> BT {\n+pub fn append<T:Copy,IT:BaseIter<T>,BT:Buildable<T>>(lhs: &IT, rhs: &IT)\n+                                                  -> BT {\n     let size_opt = lhs.size_hint().chain_ref(\n         |sz1| rhs.size_hint().map(|sz2| *sz1+*sz2));\n     do build_sized_opt(size_opt) |push| {\n@@ -350,8 +338,7 @@ pub pure fn append<T:Copy,IT:BaseIter<T>,BT:Buildable<T>>(\n /// Copies a generic sequence, possibly converting it to a different\n /// type of sequence.\n #[inline(always)]\n-pub pure fn copy_seq<T:Copy,IT:BaseIter<T>,BT:Buildable<T>>(\n-    v: &IT) -> BT {\n+pub fn copy_seq<T:Copy,IT:BaseIter<T>,BT:Buildable<T>>(v: &IT) -> BT {\n     do build_sized_opt(v.size_hint()) |push| {\n         for v.each |x| { push(*x); }\n     }"}, {"sha": "30ebeda3f5cdc1f089d61f9c9beb617de741188a", "filename": "src/libcore/managed.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/be9bddd46377bc982b73acf15a720365a54197a7/src%2Flibcore%2Fmanaged.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be9bddd46377bc982b73acf15a720365a54197a7/src%2Flibcore%2Fmanaged.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmanaged.rs?ref=be9bddd46377bc982b73acf15a720365a54197a7", "patch": "@@ -37,55 +37,55 @@ pub mod raw {\n }\n \n #[inline(always)]\n-pub pure fn ptr_eq<T>(a: @T, b: @T) -> bool {\n+pub fn ptr_eq<T>(a: @T, b: @T) -> bool {\n     //! Determine if two shared boxes point to the same object\n     unsafe { ptr::addr_of(&(*a)) == ptr::addr_of(&(*b)) }\n }\n \n #[inline(always)]\n-pub pure fn mut_ptr_eq<T>(a: @mut T, b: @mut T) -> bool {\n+pub fn mut_ptr_eq<T>(a: @mut T, b: @mut T) -> bool {\n     //! Determine if two mutable shared boxes point to the same object\n     unsafe { ptr::addr_of(&(*a)) == ptr::addr_of(&(*b)) }\n }\n \n #[cfg(notest)]\n impl<T:Eq> Eq for @T {\n     #[inline(always)]\n-    pure fn eq(&self, other: &@T) -> bool { *(*self) == *(*other) }\n+    fn eq(&self, other: &@T) -> bool { *(*self) == *(*other) }\n     #[inline(always)]\n-    pure fn ne(&self, other: &@T) -> bool { *(*self) != *(*other) }\n+    fn ne(&self, other: &@T) -> bool { *(*self) != *(*other) }\n }\n \n #[cfg(notest)]\n impl<T:Eq> Eq for @mut T {\n     #[inline(always)]\n-    pure fn eq(&self, other: &@mut T) -> bool { *(*self) == *(*other) }\n+    fn eq(&self, other: &@mut T) -> bool { *(*self) == *(*other) }\n     #[inline(always)]\n-    pure fn ne(&self, other: &@mut T) -> bool { *(*self) != *(*other) }\n+    fn ne(&self, other: &@mut T) -> bool { *(*self) != *(*other) }\n }\n \n #[cfg(notest)]\n impl<T:Ord> Ord for @T {\n     #[inline(always)]\n-    pure fn lt(&self, other: &@T) -> bool { *(*self) < *(*other) }\n+    fn lt(&self, other: &@T) -> bool { *(*self) < *(*other) }\n     #[inline(always)]\n-    pure fn le(&self, other: &@T) -> bool { *(*self) <= *(*other) }\n+    fn le(&self, other: &@T) -> bool { *(*self) <= *(*other) }\n     #[inline(always)]\n-    pure fn ge(&self, other: &@T) -> bool { *(*self) >= *(*other) }\n+    fn ge(&self, other: &@T) -> bool { *(*self) >= *(*other) }\n     #[inline(always)]\n-    pure fn gt(&self, other: &@T) -> bool { *(*self) > *(*other) }\n+    fn gt(&self, other: &@T) -> bool { *(*self) > *(*other) }\n }\n \n #[cfg(notest)]\n impl<T:Ord> Ord for @mut T {\n     #[inline(always)]\n-    pure fn lt(&self, other: &@mut T) -> bool { *(*self) < *(*other) }\n+    fn lt(&self, other: &@mut T) -> bool { *(*self) < *(*other) }\n     #[inline(always)]\n-    pure fn le(&self, other: &@mut T) -> bool { *(*self) <= *(*other) }\n+    fn le(&self, other: &@mut T) -> bool { *(*self) <= *(*other) }\n     #[inline(always)]\n-    pure fn ge(&self, other: &@mut T) -> bool { *(*self) >= *(*other) }\n+    fn ge(&self, other: &@mut T) -> bool { *(*self) >= *(*other) }\n     #[inline(always)]\n-    pure fn gt(&self, other: &@mut T) -> bool { *(*self) > *(*other) }\n+    fn gt(&self, other: &@mut T) -> bool { *(*self) > *(*other) }\n }\n \n #[test]"}, {"sha": "fc4e52891dd26005e1d22c38f661b1aba99f2893", "filename": "src/libcore/mutable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/be9bddd46377bc982b73acf15a720365a54197a7/src%2Flibcore%2Fmutable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be9bddd46377bc982b73acf15a720365a54197a7/src%2Flibcore%2Fmutable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmutable.rs?ref=be9bddd46377bc982b73acf15a720365a54197a7", "patch": "@@ -55,7 +55,7 @@ pub impl<T> Data<T> {\n         }\n     }\n \n-    pure fn borrow_const<R>(&self, op: &fn(t: &const T) -> R) -> R {\n+    fn borrow_const<R>(&self, op: &fn(t: &const T) -> R) -> R {\n         op(&const self.value)\n     }\n "}, {"sha": "8c52ac9593a274c81a2b7938737fc7b33e8982b7", "filename": "src/libcore/nil.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/be9bddd46377bc982b73acf15a720365a54197a7/src%2Flibcore%2Fnil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be9bddd46377bc982b73acf15a720365a54197a7/src%2Flibcore%2Fnil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnil.rs?ref=be9bddd46377bc982b73acf15a720365a54197a7", "patch": "@@ -20,25 +20,25 @@ use cmp::{Eq, Ord, TotalOrd, Ordering, Equal};\n #[cfg(notest)]\n impl Eq for () {\n     #[inline(always)]\n-    pure fn eq(&self, _other: &()) -> bool { true }\n+    fn eq(&self, _other: &()) -> bool { true }\n     #[inline(always)]\n-    pure fn ne(&self, _other: &()) -> bool { false }\n+    fn ne(&self, _other: &()) -> bool { false }\n }\n \n #[cfg(notest)]\n impl Ord for () {\n     #[inline(always)]\n-    pure fn lt(&self, _other: &()) -> bool { false }\n+    fn lt(&self, _other: &()) -> bool { false }\n     #[inline(always)]\n-    pure fn le(&self, _other: &()) -> bool { true }\n+    fn le(&self, _other: &()) -> bool { true }\n     #[inline(always)]\n-    pure fn ge(&self, _other: &()) -> bool { true }\n+    fn ge(&self, _other: &()) -> bool { true }\n     #[inline(always)]\n-    pure fn gt(&self, _other: &()) -> bool { false }\n+    fn gt(&self, _other: &()) -> bool { false }\n }\n \n #[cfg(notest)]\n impl TotalOrd for () {\n     #[inline(always)]\n-    pure fn cmp(&self, _other: &()) -> Ordering { Equal }\n+    fn cmp(&self, _other: &()) -> Ordering { Equal }\n }"}, {"sha": "719e5620d02ca70d8e33e2a057b8695aa66634a0", "filename": "src/libcore/num/f32.rs", "status": "modified", "additions": 72, "deletions": 70, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/be9bddd46377bc982b73acf15a720365a54197a7/src%2Flibcore%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be9bddd46377bc982b73acf15a720365a54197a7/src%2Flibcore%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff32.rs?ref=be9bddd46377bc982b73acf15a720365a54197a7", "patch": "@@ -33,7 +33,7 @@ macro_rules! delegate(\n             ),*\n         ) -> $rv:ty = $bound_name:path\n     ) => (\n-        pub pure fn $name($( $arg : $arg_ty ),*) -> $rv {\n+        pub fn $name($( $arg : $arg_ty ),*) -> $rv {\n             unsafe {\n                 $bound_name($( $arg ),*)\n             }\n@@ -109,65 +109,67 @@ pub const infinity: f32 = 1.0_f32/0.0_f32;\n pub const neg_infinity: f32 = -1.0_f32/0.0_f32;\n \n #[inline(always)]\n-pub pure fn is_NaN(f: f32) -> bool { f != f }\n+pub fn is_NaN(f: f32) -> bool { f != f }\n \n #[inline(always)]\n-pub pure fn add(x: f32, y: f32) -> f32 { return x + y; }\n+pub fn add(x: f32, y: f32) -> f32 { return x + y; }\n \n #[inline(always)]\n-pub pure fn sub(x: f32, y: f32) -> f32 { return x - y; }\n+pub fn sub(x: f32, y: f32) -> f32 { return x - y; }\n \n #[inline(always)]\n-pub pure fn mul(x: f32, y: f32) -> f32 { return x * y; }\n+pub fn mul(x: f32, y: f32) -> f32 { return x * y; }\n \n #[inline(always)]\n-pub pure fn div(x: f32, y: f32) -> f32 { return x / y; }\n+pub fn div(x: f32, y: f32) -> f32 { return x / y; }\n \n #[inline(always)]\n-pub pure fn rem(x: f32, y: f32) -> f32 { return x % y; }\n+pub fn rem(x: f32, y: f32) -> f32 { return x % y; }\n \n #[inline(always)]\n-pub pure fn lt(x: f32, y: f32) -> bool { return x < y; }\n+pub fn lt(x: f32, y: f32) -> bool { return x < y; }\n \n #[inline(always)]\n-pub pure fn le(x: f32, y: f32) -> bool { return x <= y; }\n+pub fn le(x: f32, y: f32) -> bool { return x <= y; }\n \n #[inline(always)]\n-pub pure fn eq(x: f32, y: f32) -> bool { return x == y; }\n+pub fn eq(x: f32, y: f32) -> bool { return x == y; }\n \n #[inline(always)]\n-pub pure fn ne(x: f32, y: f32) -> bool { return x != y; }\n+pub fn ne(x: f32, y: f32) -> bool { return x != y; }\n \n #[inline(always)]\n-pub pure fn ge(x: f32, y: f32) -> bool { return x >= y; }\n+pub fn ge(x: f32, y: f32) -> bool { return x >= y; }\n \n #[inline(always)]\n-pub pure fn gt(x: f32, y: f32) -> bool { return x > y; }\n+pub fn gt(x: f32, y: f32) -> bool { return x > y; }\n \n /// Returns `x` rounded down\n #[inline(always)]\n-pub pure fn floor(x: f32) -> f32 { unsafe { floorf32(x) } }\n+pub fn floor(x: f32) -> f32 { unsafe { floorf32(x) } }\n \n // FIXME (#1999): replace the predicates below with llvm intrinsics or\n // calls to the libmath macros in the rust runtime for performance.\n \n /// Returns true if `x` is a positive number, including +0.0f320 and +Infinity\n #[inline(always)]\n-pub pure fn is_positive(x: f32) -> bool\n-    { return x > 0.0f32 || (1.0f32/x) == infinity; }\n+pub fn is_positive(x: f32) -> bool {\n+    x > 0.0f32 || (1.0f32/x) == infinity\n+}\n \n /// Returns true if `x` is a negative number, including -0.0f320 and -Infinity\n #[inline(always)]\n-pub pure fn is_negative(x: f32) -> bool\n-    { return x < 0.0f32 || (1.0f32/x) == neg_infinity; }\n+pub fn is_negative(x: f32) -> bool {\n+    x < 0.0f32 || (1.0f32/x) == neg_infinity\n+}\n \n /**\n  * Returns true if `x` is a negative number, including -0.0f320 and -Infinity\n  *\n  * This is the same as `f32::is_negative`.\n  */\n #[inline(always)]\n-pub pure fn is_nonpositive(x: f32) -> bool {\n+pub fn is_nonpositive(x: f32) -> bool {\n   return x < 0.0f32 || (1.0f32/x) == neg_infinity;\n }\n \n@@ -177,25 +179,25 @@ pub pure fn is_nonpositive(x: f32) -> bool {\n  * This is the same as `f32::is_positive`.)\n  */\n #[inline(always)]\n-pub pure fn is_nonnegative(x: f32) -> bool {\n+pub fn is_nonnegative(x: f32) -> bool {\n   return x > 0.0f32 || (1.0f32/x) == infinity;\n }\n \n /// Returns true if `x` is a zero number (positive or negative zero)\n #[inline(always)]\n-pub pure fn is_zero(x: f32) -> bool {\n+pub fn is_zero(x: f32) -> bool {\n     return x == 0.0f32 || x == -0.0f32;\n }\n \n /// Returns true if `x`is an infinite number\n #[inline(always)]\n-pub pure fn is_infinite(x: f32) -> bool {\n+pub fn is_infinite(x: f32) -> bool {\n     return x == infinity || x == neg_infinity;\n }\n \n /// Returns true if `x`is a finite number\n #[inline(always)]\n-pub pure fn is_finite(x: f32) -> bool {\n+pub fn is_finite(x: f32) -> bool {\n     return !(is_NaN(x) || is_infinite(x));\n }\n \n@@ -246,97 +248,97 @@ pub mod consts {\n }\n \n #[inline(always)]\n-pub pure fn signbit(x: f32) -> int {\n+pub fn signbit(x: f32) -> int {\n     if is_negative(x) { return 1; } else { return 0; }\n }\n \n #[inline(always)]\n-pub pure fn logarithm(n: f32, b: f32) -> f32 {\n+pub fn logarithm(n: f32, b: f32) -> f32 {\n     return log2(n) / log2(b);\n }\n \n #[cfg(notest)]\n impl cmp::Eq for f32 {\n     #[inline(always)]\n-    pure fn eq(&self, other: &f32) -> bool { (*self) == (*other) }\n+    fn eq(&self, other: &f32) -> bool { (*self) == (*other) }\n     #[inline(always)]\n-    pure fn ne(&self, other: &f32) -> bool { (*self) != (*other) }\n+    fn ne(&self, other: &f32) -> bool { (*self) != (*other) }\n }\n \n #[cfg(notest)]\n impl cmp::Ord for f32 {\n     #[inline(always)]\n-    pure fn lt(&self, other: &f32) -> bool { (*self) < (*other) }\n+    fn lt(&self, other: &f32) -> bool { (*self) < (*other) }\n     #[inline(always)]\n-    pure fn le(&self, other: &f32) -> bool { (*self) <= (*other) }\n+    fn le(&self, other: &f32) -> bool { (*self) <= (*other) }\n     #[inline(always)]\n-    pure fn ge(&self, other: &f32) -> bool { (*self) >= (*other) }\n+    fn ge(&self, other: &f32) -> bool { (*self) >= (*other) }\n     #[inline(always)]\n-    pure fn gt(&self, other: &f32) -> bool { (*self) > (*other) }\n+    fn gt(&self, other: &f32) -> bool { (*self) > (*other) }\n }\n \n impl num::Zero for f32 {\n     #[inline(always)]\n-    pure fn zero() -> f32 { 0.0 }\n+    fn zero() -> f32 { 0.0 }\n }\n \n impl num::One for f32 {\n     #[inline(always)]\n-    pure fn one() -> f32 { 1.0 }\n+    fn one() -> f32 { 1.0 }\n }\n \n impl NumCast for f32 {\n     /**\n      * Cast `n` to an `f32`\n      */\n     #[inline(always)]\n-    pure fn from<N:NumCast>(n: N) -> f32 { n.to_f32() }\n+    fn from<N:NumCast>(n: N) -> f32 { n.to_f32() }\n \n-    #[inline(always)] pure fn to_u8(&self)    -> u8    { *self as u8    }\n-    #[inline(always)] pure fn to_u16(&self)   -> u16   { *self as u16   }\n-    #[inline(always)] pure fn to_u32(&self)   -> u32   { *self as u32   }\n-    #[inline(always)] pure fn to_u64(&self)   -> u64   { *self as u64   }\n-    #[inline(always)] pure fn to_uint(&self)  -> uint  { *self as uint  }\n+    #[inline(always)] fn to_u8(&self)    -> u8    { *self as u8    }\n+    #[inline(always)] fn to_u16(&self)   -> u16   { *self as u16   }\n+    #[inline(always)] fn to_u32(&self)   -> u32   { *self as u32   }\n+    #[inline(always)] fn to_u64(&self)   -> u64   { *self as u64   }\n+    #[inline(always)] fn to_uint(&self)  -> uint  { *self as uint  }\n \n-    #[inline(always)] pure fn to_i8(&self)    -> i8    { *self as i8    }\n-    #[inline(always)] pure fn to_i16(&self)   -> i16   { *self as i16   }\n-    #[inline(always)] pure fn to_i32(&self)   -> i32   { *self as i32   }\n-    #[inline(always)] pure fn to_i64(&self)   -> i64   { *self as i64   }\n-    #[inline(always)] pure fn to_int(&self)   -> int   { *self as int   }\n+    #[inline(always)] fn to_i8(&self)    -> i8    { *self as i8    }\n+    #[inline(always)] fn to_i16(&self)   -> i16   { *self as i16   }\n+    #[inline(always)] fn to_i32(&self)   -> i32   { *self as i32   }\n+    #[inline(always)] fn to_i64(&self)   -> i64   { *self as i64   }\n+    #[inline(always)] fn to_int(&self)   -> int   { *self as int   }\n \n-    #[inline(always)] pure fn to_f32(&self)   -> f32   { *self          }\n-    #[inline(always)] pure fn to_f64(&self)   -> f64   { *self as f64   }\n-    #[inline(always)] pure fn to_float(&self) -> float { *self as float }\n+    #[inline(always)] fn to_f32(&self)   -> f32   { *self          }\n+    #[inline(always)] fn to_f64(&self)   -> f64   { *self as f64   }\n+    #[inline(always)] fn to_float(&self) -> float { *self as float }\n }\n \n #[cfg(notest)]\n impl ops::Add<f32,f32> for f32 {\n-    pure fn add(&self, other: &f32) -> f32 { *self + *other }\n+    fn add(&self, other: &f32) -> f32 { *self + *other }\n }\n #[cfg(notest)]\n impl ops::Sub<f32,f32> for f32 {\n-    pure fn sub(&self, other: &f32) -> f32 { *self - *other }\n+    fn sub(&self, other: &f32) -> f32 { *self - *other }\n }\n #[cfg(notest)]\n impl ops::Mul<f32,f32> for f32 {\n-    pure fn mul(&self, other: &f32) -> f32 { *self * *other }\n+    fn mul(&self, other: &f32) -> f32 { *self * *other }\n }\n #[cfg(notest)]\n impl ops::Div<f32,f32> for f32 {\n-    pure fn div(&self, other: &f32) -> f32 { *self / *other }\n+    fn div(&self, other: &f32) -> f32 { *self / *other }\n }\n #[cfg(notest)]\n impl ops::Modulo<f32,f32> for f32 {\n-    pure fn modulo(&self, other: &f32) -> f32 { *self % *other }\n+    fn modulo(&self, other: &f32) -> f32 { *self % *other }\n }\n #[cfg(notest)]\n impl ops::Neg<f32> for f32 {\n-    pure fn neg(&self) -> f32 { -*self }\n+    fn neg(&self) -> f32 { -*self }\n }\n \n impl num::Round for f32 {\n     #[inline(always)]\n-    pure fn round(&self, mode: num::RoundMode) -> f32 {\n+    fn round(&self, mode: num::RoundMode) -> f32 {\n         match mode {\n             num::RoundDown                           => floor(*self),\n             num::RoundUp                             => ceil(*self),\n@@ -348,11 +350,11 @@ impl num::Round for f32 {\n     }\n \n     #[inline(always)]\n-    pure fn floor(&self) -> f32 { floor(*self) }\n+    fn floor(&self) -> f32 { floor(*self) }\n     #[inline(always)]\n-    pure fn ceil(&self) -> f32 { ceil(*self) }\n+    fn ceil(&self) -> f32 { ceil(*self) }\n     #[inline(always)]\n-    pure fn fract(&self) -> f32 {\n+    fn fract(&self) -> f32 {\n         if is_negative(*self) {\n             (*self) - ceil(*self)\n         } else {\n@@ -373,7 +375,7 @@ impl num::Round for f32 {\n  * * num - The float value\n  */\n #[inline(always)]\n-pub pure fn to_str(num: f32) -> ~str {\n+pub fn to_str(num: f32) -> ~str {\n     let (r, _) = strconv::to_str_common(\n         &num, 10u, true, strconv::SignNeg, strconv::DigAll);\n     r\n@@ -387,7 +389,7 @@ pub pure fn to_str(num: f32) -> ~str {\n  * * num - The float value\n  */\n #[inline(always)]\n-pub pure fn to_str_hex(num: f32) -> ~str {\n+pub fn to_str_hex(num: f32) -> ~str {\n     let (r, _) = strconv::to_str_common(\n         &num, 16u, true, strconv::SignNeg, strconv::DigAll);\n     r\n@@ -408,7 +410,7 @@ pub pure fn to_str_hex(num: f32) -> ~str {\n  * are expected, use `to_str_radix_special()` instead.\n  */\n #[inline(always)]\n-pub pure fn to_str_radix(num: f32, rdx: uint) -> ~str {\n+pub fn to_str_radix(num: f32, rdx: uint) -> ~str {\n     let (r, special) = strconv::to_str_common(\n         &num, rdx, true, strconv::SignNeg, strconv::DigAll);\n     if special { fail!(~\"number has a special value, \\\n@@ -426,7 +428,7 @@ pub pure fn to_str_radix(num: f32, rdx: uint) -> ~str {\n  * * radix - The base to use\n  */\n #[inline(always)]\n-pub pure fn to_str_radix_special(num: f32, rdx: uint) -> (~str, bool) {\n+pub fn to_str_radix_special(num: f32, rdx: uint) -> (~str, bool) {\n     strconv::to_str_common(&num, rdx, true,\n                            strconv::SignNeg, strconv::DigAll)\n }\n@@ -441,7 +443,7 @@ pub pure fn to_str_radix_special(num: f32, rdx: uint) -> (~str, bool) {\n  * * digits - The number of significant digits\n  */\n #[inline(always)]\n-pub pure fn to_str_exact(num: f32, dig: uint) -> ~str {\n+pub fn to_str_exact(num: f32, dig: uint) -> ~str {\n     let (r, _) = strconv::to_str_common(\n         &num, 10u, true, strconv::SignNeg, strconv::DigExact(dig));\n     r\n@@ -457,20 +459,20 @@ pub pure fn to_str_exact(num: f32, dig: uint) -> ~str {\n  * * digits - The number of significant digits\n  */\n #[inline(always)]\n-pub pure fn to_str_digits(num: f32, dig: uint) -> ~str {\n+pub fn to_str_digits(num: f32, dig: uint) -> ~str {\n     let (r, _) = strconv::to_str_common(\n         &num, 10u, true, strconv::SignNeg, strconv::DigMax(dig));\n     r\n }\n \n impl to_str::ToStr for f32 {\n     #[inline(always)]\n-    pure fn to_str(&self) -> ~str { to_str_digits(*self, 8) }\n+    fn to_str(&self) -> ~str { to_str_digits(*self, 8) }\n }\n \n impl num::ToStrRadix for f32 {\n     #[inline(always)]\n-    pure fn to_str_radix(&self, rdx: uint) -> ~str {\n+    fn to_str_radix(&self, rdx: uint) -> ~str {\n         to_str_radix(*self, rdx)\n     }\n }\n@@ -503,7 +505,7 @@ impl num::ToStrRadix for f32 {\n  * `Some(n)` where `n` is the floating-point number represented by `num`.\n  */\n #[inline(always)]\n-pub pure fn from_str(num: &str) -> Option<f32> {\n+pub fn from_str(num: &str) -> Option<f32> {\n     strconv::from_str_common(num, 10u, true, true, true,\n                              strconv::ExpDec, false)\n }\n@@ -536,7 +538,7 @@ pub pure fn from_str(num: &str) -> Option<f32> {\n  * `Some(n)` where `n` is the floating-point number represented by `[num]`.\n  */\n #[inline(always)]\n-pub pure fn from_str_hex(num: &str) -> Option<f32> {\n+pub fn from_str_hex(num: &str) -> Option<f32> {\n     strconv::from_str_common(num, 16u, true, true, true,\n                              strconv::ExpBin, false)\n }\n@@ -561,19 +563,19 @@ pub pure fn from_str_hex(num: &str) -> Option<f32> {\n  * `Some(n)` where `n` is the floating-point number represented by `num`.\n  */\n #[inline(always)]\n-pub pure fn from_str_radix(num: &str, rdx: uint) -> Option<f32> {\n+pub fn from_str_radix(num: &str, rdx: uint) -> Option<f32> {\n     strconv::from_str_common(num, rdx, true, true, false,\n                              strconv::ExpNone, false)\n }\n \n impl from_str::FromStr for f32 {\n     #[inline(always)]\n-    pure fn from_str(val: &str) -> Option<f32> { from_str(val) }\n+    fn from_str(val: &str) -> Option<f32> { from_str(val) }\n }\n \n impl num::FromStrRadix for f32 {\n     #[inline(always)]\n-    pure fn from_str_radix(val: &str, rdx: uint) -> Option<f32> {\n+    fn from_str_radix(val: &str, rdx: uint) -> Option<f32> {\n         from_str_radix(val, rdx)\n     }\n }"}, {"sha": "6a581ddfa9424e6f18aa637fc955513279a8d9a9", "filename": "src/libcore/num/f64.rs", "status": "modified", "additions": 68, "deletions": 68, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/be9bddd46377bc982b73acf15a720365a54197a7/src%2Flibcore%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be9bddd46377bc982b73acf15a720365a54197a7/src%2Flibcore%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff64.rs?ref=be9bddd46377bc982b73acf15a720365a54197a7", "patch": "@@ -34,7 +34,7 @@ macro_rules! delegate(\n             ),*\n         ) -> $rv:ty = $bound_name:path\n     ) => (\n-        pub pure fn $name($( $arg : $arg_ty ),*) -> $rv {\n+        pub fn $name($( $arg : $arg_ty ),*) -> $rv {\n             unsafe {\n                 $bound_name($( $arg ),*)\n             }\n@@ -136,49 +136,49 @@ pub const infinity: f64 = 1.0_f64/0.0_f64;\n pub const neg_infinity: f64 = -1.0_f64/0.0_f64;\n \n #[inline(always)]\n-pub pure fn is_NaN(f: f64) -> bool { f != f }\n+pub fn is_NaN(f: f64) -> bool { f != f }\n \n #[inline(always)]\n-pub pure fn add(x: f64, y: f64) -> f64 { return x + y; }\n+pub fn add(x: f64, y: f64) -> f64 { return x + y; }\n \n #[inline(always)]\n-pub pure fn sub(x: f64, y: f64) -> f64 { return x - y; }\n+pub fn sub(x: f64, y: f64) -> f64 { return x - y; }\n \n #[inline(always)]\n-pub pure fn mul(x: f64, y: f64) -> f64 { return x * y; }\n+pub fn mul(x: f64, y: f64) -> f64 { return x * y; }\n \n #[inline(always)]\n-pub pure fn div(x: f64, y: f64) -> f64 { return x / y; }\n+pub fn div(x: f64, y: f64) -> f64 { return x / y; }\n \n #[inline(always)]\n-pub pure fn rem(x: f64, y: f64) -> f64 { return x % y; }\n+pub fn rem(x: f64, y: f64) -> f64 { return x % y; }\n \n #[inline(always)]\n-pub pure fn lt(x: f64, y: f64) -> bool { return x < y; }\n+pub fn lt(x: f64, y: f64) -> bool { return x < y; }\n \n #[inline(always)]\n-pub pure fn le(x: f64, y: f64) -> bool { return x <= y; }\n+pub fn le(x: f64, y: f64) -> bool { return x <= y; }\n \n #[inline(always)]\n-pub pure fn eq(x: f64, y: f64) -> bool { return x == y; }\n+pub fn eq(x: f64, y: f64) -> bool { return x == y; }\n \n #[inline(always)]\n-pub pure fn ne(x: f64, y: f64) -> bool { return x != y; }\n+pub fn ne(x: f64, y: f64) -> bool { return x != y; }\n \n #[inline(always)]\n-pub pure fn ge(x: f64, y: f64) -> bool { return x >= y; }\n+pub fn ge(x: f64, y: f64) -> bool { return x >= y; }\n \n #[inline(always)]\n-pub pure fn gt(x: f64, y: f64) -> bool { return x > y; }\n+pub fn gt(x: f64, y: f64) -> bool { return x > y; }\n \n /// Returns true if `x` is a positive number, including +0.0f640 and +Infinity\n #[inline(always)]\n-pub pure fn is_positive(x: f64) -> bool\n+pub fn is_positive(x: f64) -> bool\n     { return x > 0.0f64 || (1.0f64/x) == infinity; }\n \n /// Returns true if `x` is a negative number, including -0.0f640 and -Infinity\n #[inline(always)]\n-pub pure fn is_negative(x: f64) -> bool\n+pub fn is_negative(x: f64) -> bool\n     { return x < 0.0f64 || (1.0f64/x) == neg_infinity; }\n \n /**\n@@ -187,7 +187,7 @@ pub pure fn is_negative(x: f64) -> bool\n  * This is the same as `f64::is_negative`.\n  */\n #[inline(always)]\n-pub pure fn is_nonpositive(x: f64) -> bool {\n+pub fn is_nonpositive(x: f64) -> bool {\n   return x < 0.0f64 || (1.0f64/x) == neg_infinity;\n }\n \n@@ -197,31 +197,31 @@ pub pure fn is_nonpositive(x: f64) -> bool {\n  * This is the same as `f64::positive`.\n  */\n #[inline(always)]\n-pub pure fn is_nonnegative(x: f64) -> bool {\n+pub fn is_nonnegative(x: f64) -> bool {\n   return x > 0.0f64 || (1.0f64/x) == infinity;\n }\n \n /// Returns true if `x` is a zero number (positive or negative zero)\n #[inline(always)]\n-pub pure fn is_zero(x: f64) -> bool {\n+pub fn is_zero(x: f64) -> bool {\n     return x == 0.0f64 || x == -0.0f64;\n }\n \n /// Returns true if `x`is an infinite number\n #[inline(always)]\n-pub pure fn is_infinite(x: f64) -> bool {\n+pub fn is_infinite(x: f64) -> bool {\n     return x == infinity || x == neg_infinity;\n }\n \n /// Returns true if `x` is a finite number\n #[inline(always)]\n-pub pure fn is_finite(x: f64) -> bool {\n+pub fn is_finite(x: f64) -> bool {\n     return !(is_NaN(x) || is_infinite(x));\n }\n \n /// Returns `x` rounded down\n #[inline(always)]\n-pub pure fn floor(x: f64) -> f64 { unsafe { floorf64(x) } }\n+pub fn floor(x: f64) -> f64 { unsafe { floorf64(x) } }\n \n // FIXME (#1999): add is_normal, is_subnormal, and fpclassify\n \n@@ -270,97 +270,97 @@ pub mod consts {\n }\n \n #[inline(always)]\n-pub pure fn signbit(x: f64) -> int {\n+pub fn signbit(x: f64) -> int {\n     if is_negative(x) { return 1; } else { return 0; }\n }\n \n #[inline(always)]\n-pub pure fn logarithm(n: f64, b: f64) -> f64 {\n+pub fn logarithm(n: f64, b: f64) -> f64 {\n     return log2(n) / log2(b);\n }\n \n #[cfg(notest)]\n impl cmp::Eq for f64 {\n     #[inline(always)]\n-    pure fn eq(&self, other: &f64) -> bool { (*self) == (*other) }\n+    fn eq(&self, other: &f64) -> bool { (*self) == (*other) }\n     #[inline(always)]\n-    pure fn ne(&self, other: &f64) -> bool { (*self) != (*other) }\n+    fn ne(&self, other: &f64) -> bool { (*self) != (*other) }\n }\n \n #[cfg(notest)]\n impl cmp::Ord for f64 {\n     #[inline(always)]\n-    pure fn lt(&self, other: &f64) -> bool { (*self) < (*other) }\n+    fn lt(&self, other: &f64) -> bool { (*self) < (*other) }\n     #[inline(always)]\n-    pure fn le(&self, other: &f64) -> bool { (*self) <= (*other) }\n+    fn le(&self, other: &f64) -> bool { (*self) <= (*other) }\n     #[inline(always)]\n-    pure fn ge(&self, other: &f64) -> bool { (*self) >= (*other) }\n+    fn ge(&self, other: &f64) -> bool { (*self) >= (*other) }\n     #[inline(always)]\n-    pure fn gt(&self, other: &f64) -> bool { (*self) > (*other) }\n+    fn gt(&self, other: &f64) -> bool { (*self) > (*other) }\n }\n \n impl NumCast for f64 {\n     /**\n      * Cast `n` to an `f64`\n      */\n     #[inline(always)]\n-    pure fn from<N:NumCast>(n: N) -> f64 { n.to_f64() }\n+    fn from<N:NumCast>(n: N) -> f64 { n.to_f64() }\n \n-    #[inline(always)] pure fn to_u8(&self)    -> u8    { *self as u8    }\n-    #[inline(always)] pure fn to_u16(&self)   -> u16   { *self as u16   }\n-    #[inline(always)] pure fn to_u32(&self)   -> u32   { *self as u32   }\n-    #[inline(always)] pure fn to_u64(&self)   -> u64   { *self as u64   }\n-    #[inline(always)] pure fn to_uint(&self)  -> uint  { *self as uint  }\n+    #[inline(always)] fn to_u8(&self)    -> u8    { *self as u8    }\n+    #[inline(always)] fn to_u16(&self)   -> u16   { *self as u16   }\n+    #[inline(always)] fn to_u32(&self)   -> u32   { *self as u32   }\n+    #[inline(always)] fn to_u64(&self)   -> u64   { *self as u64   }\n+    #[inline(always)] fn to_uint(&self)  -> uint  { *self as uint  }\n \n-    #[inline(always)] pure fn to_i8(&self)    -> i8    { *self as i8    }\n-    #[inline(always)] pure fn to_i16(&self)   -> i16   { *self as i16   }\n-    #[inline(always)] pure fn to_i32(&self)   -> i32   { *self as i32   }\n-    #[inline(always)] pure fn to_i64(&self)   -> i64   { *self as i64   }\n-    #[inline(always)] pure fn to_int(&self)   -> int   { *self as int   }\n+    #[inline(always)] fn to_i8(&self)    -> i8    { *self as i8    }\n+    #[inline(always)] fn to_i16(&self)   -> i16   { *self as i16   }\n+    #[inline(always)] fn to_i32(&self)   -> i32   { *self as i32   }\n+    #[inline(always)] fn to_i64(&self)   -> i64   { *self as i64   }\n+    #[inline(always)] fn to_int(&self)   -> int   { *self as int   }\n \n-    #[inline(always)] pure fn to_f32(&self)   -> f32   { *self as f32   }\n-    #[inline(always)] pure fn to_f64(&self)   -> f64   { *self          }\n-    #[inline(always)] pure fn to_float(&self) -> float { *self as float }\n+    #[inline(always)] fn to_f32(&self)   -> f32   { *self as f32   }\n+    #[inline(always)] fn to_f64(&self)   -> f64   { *self          }\n+    #[inline(always)] fn to_float(&self) -> float { *self as float }\n }\n \n impl num::Zero for f64 {\n     #[inline(always)]\n-    pure fn zero() -> f64 { 0.0 }\n+    fn zero() -> f64 { 0.0 }\n }\n \n impl num::One for f64 {\n     #[inline(always)]\n-    pure fn one() -> f64 { 1.0 }\n+    fn one() -> f64 { 1.0 }\n }\n \n #[cfg(notest)]\n impl ops::Add<f64,f64> for f64 {\n-    pure fn add(&self, other: &f64) -> f64 { *self + *other }\n+    fn add(&self, other: &f64) -> f64 { *self + *other }\n }\n #[cfg(notest)]\n impl ops::Sub<f64,f64> for f64 {\n-    pure fn sub(&self, other: &f64) -> f64 { *self - *other }\n+    fn sub(&self, other: &f64) -> f64 { *self - *other }\n }\n #[cfg(notest)]\n impl ops::Mul<f64,f64> for f64 {\n-    pure fn mul(&self, other: &f64) -> f64 { *self * *other }\n+    fn mul(&self, other: &f64) -> f64 { *self * *other }\n }\n #[cfg(notest)]\n impl ops::Div<f64,f64> for f64 {\n-    pure fn div(&self, other: &f64) -> f64 { *self / *other }\n+    fn div(&self, other: &f64) -> f64 { *self / *other }\n }\n #[cfg(notest)]\n impl ops::Modulo<f64,f64> for f64 {\n-    pure fn modulo(&self, other: &f64) -> f64 { *self % *other }\n+    fn modulo(&self, other: &f64) -> f64 { *self % *other }\n }\n #[cfg(notest)]\n impl ops::Neg<f64> for f64 {\n-    pure fn neg(&self) -> f64 { -*self }\n+    fn neg(&self) -> f64 { -*self }\n }\n \n impl num::Round for f64 {\n     #[inline(always)]\n-    pure fn round(&self, mode: num::RoundMode) -> f64 {\n+    fn round(&self, mode: num::RoundMode) -> f64 {\n         match mode {\n             num::RoundDown                           => floor(*self),\n             num::RoundUp                             => ceil(*self),\n@@ -372,11 +372,11 @@ impl num::Round for f64 {\n     }\n \n     #[inline(always)]\n-    pure fn floor(&self) -> f64 { floor(*self) }\n+    fn floor(&self) -> f64 { floor(*self) }\n     #[inline(always)]\n-    pure fn ceil(&self) -> f64 { ceil(*self) }\n+    fn ceil(&self) -> f64 { ceil(*self) }\n     #[inline(always)]\n-    pure fn fract(&self) -> f64 {\n+    fn fract(&self) -> f64 {\n         if is_negative(*self) {\n             (*self) - ceil(*self)\n         } else {\n@@ -397,7 +397,7 @@ impl num::Round for f64 {\n  * * num - The float value\n  */\n #[inline(always)]\n-pub pure fn to_str(num: f64) -> ~str {\n+pub fn to_str(num: f64) -> ~str {\n     let (r, _) = strconv::to_str_common(\n         &num, 10u, true, strconv::SignNeg, strconv::DigAll);\n     r\n@@ -411,7 +411,7 @@ pub pure fn to_str(num: f64) -> ~str {\n  * * num - The float value\n  */\n #[inline(always)]\n-pub pure fn to_str_hex(num: f64) -> ~str {\n+pub fn to_str_hex(num: f64) -> ~str {\n     let (r, _) = strconv::to_str_common(\n         &num, 16u, true, strconv::SignNeg, strconv::DigAll);\n     r\n@@ -432,7 +432,7 @@ pub pure fn to_str_hex(num: f64) -> ~str {\n  * are expected, use `to_str_radix_special()` instead.\n  */\n #[inline(always)]\n-pub pure fn to_str_radix(num: f64, rdx: uint) -> ~str {\n+pub fn to_str_radix(num: f64, rdx: uint) -> ~str {\n     let (r, special) = strconv::to_str_common(\n         &num, rdx, true, strconv::SignNeg, strconv::DigAll);\n     if special { fail!(~\"number has a special value, \\\n@@ -450,7 +450,7 @@ pub pure fn to_str_radix(num: f64, rdx: uint) -> ~str {\n  * * radix - The base to use\n  */\n #[inline(always)]\n-pub pure fn to_str_radix_special(num: f64, rdx: uint) -> (~str, bool) {\n+pub fn to_str_radix_special(num: f64, rdx: uint) -> (~str, bool) {\n     strconv::to_str_common(&num, rdx, true,\n                            strconv::SignNeg, strconv::DigAll)\n }\n@@ -465,7 +465,7 @@ pub pure fn to_str_radix_special(num: f64, rdx: uint) -> (~str, bool) {\n  * * digits - The number of significant digits\n  */\n #[inline(always)]\n-pub pure fn to_str_exact(num: f64, dig: uint) -> ~str {\n+pub fn to_str_exact(num: f64, dig: uint) -> ~str {\n     let (r, _) = strconv::to_str_common(\n         &num, 10u, true, strconv::SignNeg, strconv::DigExact(dig));\n     r\n@@ -481,20 +481,20 @@ pub pure fn to_str_exact(num: f64, dig: uint) -> ~str {\n  * * digits - The number of significant digits\n  */\n #[inline(always)]\n-pub pure fn to_str_digits(num: f64, dig: uint) -> ~str {\n+pub fn to_str_digits(num: f64, dig: uint) -> ~str {\n     let (r, _) = strconv::to_str_common(\n         &num, 10u, true, strconv::SignNeg, strconv::DigMax(dig));\n     r\n }\n \n impl to_str::ToStr for f64 {\n     #[inline(always)]\n-    pure fn to_str(&self) -> ~str { to_str_digits(*self, 8) }\n+    fn to_str(&self) -> ~str { to_str_digits(*self, 8) }\n }\n \n impl num::ToStrRadix for f64 {\n     #[inline(always)]\n-    pure fn to_str_radix(&self, rdx: uint) -> ~str {\n+    fn to_str_radix(&self, rdx: uint) -> ~str {\n         to_str_radix(*self, rdx)\n     }\n }\n@@ -527,7 +527,7 @@ impl num::ToStrRadix for f64 {\n  * `Some(n)` where `n` is the floating-point number represented by `num`.\n  */\n #[inline(always)]\n-pub pure fn from_str(num: &str) -> Option<f64> {\n+pub fn from_str(num: &str) -> Option<f64> {\n     strconv::from_str_common(num, 10u, true, true, true,\n                              strconv::ExpDec, false)\n }\n@@ -560,7 +560,7 @@ pub pure fn from_str(num: &str) -> Option<f64> {\n  * `Some(n)` where `n` is the floating-point number represented by `[num]`.\n  */\n #[inline(always)]\n-pub pure fn from_str_hex(num: &str) -> Option<f64> {\n+pub fn from_str_hex(num: &str) -> Option<f64> {\n     strconv::from_str_common(num, 16u, true, true, true,\n                              strconv::ExpBin, false)\n }\n@@ -585,19 +585,19 @@ pub pure fn from_str_hex(num: &str) -> Option<f64> {\n  * `Some(n)` where `n` is the floating-point number represented by `num`.\n  */\n #[inline(always)]\n-pub pure fn from_str_radix(num: &str, rdx: uint) -> Option<f64> {\n+pub fn from_str_radix(num: &str, rdx: uint) -> Option<f64> {\n     strconv::from_str_common(num, rdx, true, true, false,\n                              strconv::ExpNone, false)\n }\n \n impl from_str::FromStr for f64 {\n     #[inline(always)]\n-    pure fn from_str(val: &str) -> Option<f64> { from_str(val) }\n+    fn from_str(val: &str) -> Option<f64> { from_str(val) }\n }\n \n impl num::FromStrRadix for f64 {\n     #[inline(always)]\n-    pure fn from_str_radix(val: &str, rdx: uint) -> Option<f64> {\n+    fn from_str_radix(val: &str, rdx: uint) -> Option<f64> {\n         from_str_radix(val, rdx)\n     }\n }"}, {"sha": "4e9a1b62b6ece4bc20428eb5a97f1ddff637d63a", "filename": "src/libcore/num/float.rs", "status": "modified", "additions": 60, "deletions": 60, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/be9bddd46377bc982b73acf15a720365a54197a7/src%2Flibcore%2Fnum%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be9bddd46377bc982b73acf15a720365a54197a7/src%2Flibcore%2Fnum%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ffloat.rs?ref=be9bddd46377bc982b73acf15a720365a54197a7", "patch": "@@ -103,7 +103,7 @@ pub mod consts {\n  * * num - The float value\n  */\n #[inline(always)]\n-pub pure fn to_str(num: float) -> ~str {\n+pub fn to_str(num: float) -> ~str {\n     let (r, _) = strconv::to_str_common(\n         &num, 10u, true, strconv::SignNeg, strconv::DigAll);\n     r\n@@ -117,7 +117,7 @@ pub pure fn to_str(num: float) -> ~str {\n  * * num - The float value\n  */\n #[inline(always)]\n-pub pure fn to_str_hex(num: float) -> ~str {\n+pub fn to_str_hex(num: float) -> ~str {\n     let (r, _) = strconv::to_str_common(\n         &num, 16u, true, strconv::SignNeg, strconv::DigAll);\n     r\n@@ -138,7 +138,7 @@ pub pure fn to_str_hex(num: float) -> ~str {\n  * are expected, use `to_str_radix_special()` instead.\n  */\n #[inline(always)]\n-pub pure fn to_str_radix(num: float, radix: uint) -> ~str {\n+pub fn to_str_radix(num: float, radix: uint) -> ~str {\n     let (r, special) = strconv::to_str_common(\n         &num, radix, true, strconv::SignNeg, strconv::DigAll);\n     if special { fail!(~\"number has a special value, \\\n@@ -156,7 +156,7 @@ pub pure fn to_str_radix(num: float, radix: uint) -> ~str {\n  * * radix - The base to use\n  */\n #[inline(always)]\n-pub pure fn to_str_radix_special(num: float, radix: uint) -> (~str, bool) {\n+pub fn to_str_radix_special(num: float, radix: uint) -> (~str, bool) {\n     strconv::to_str_common(&num, radix, true,\n                            strconv::SignNeg, strconv::DigAll)\n }\n@@ -171,7 +171,7 @@ pub pure fn to_str_radix_special(num: float, radix: uint) -> (~str, bool) {\n  * * digits - The number of significant digits\n  */\n #[inline(always)]\n-pub pure fn to_str_exact(num: float, digits: uint) -> ~str {\n+pub fn to_str_exact(num: float, digits: uint) -> ~str {\n     let (r, _) = strconv::to_str_common(\n         &num, 10u, true, strconv::SignNeg, strconv::DigExact(digits));\n     r\n@@ -193,20 +193,20 @@ pub fn test_to_str_exact_do_decimal() {\n  * * digits - The number of significant digits\n  */\n #[inline(always)]\n-pub pure fn to_str_digits(num: float, digits: uint) -> ~str {\n+pub fn to_str_digits(num: float, digits: uint) -> ~str {\n     let (r, _) = strconv::to_str_common(\n         &num, 10u, true, strconv::SignNeg, strconv::DigMax(digits));\n     r\n }\n \n impl to_str::ToStr for float {\n     #[inline(always)]\n-    pure fn to_str(&self) -> ~str { to_str_digits(*self, 8) }\n+    fn to_str(&self) -> ~str { to_str_digits(*self, 8) }\n }\n \n impl num::ToStrRadix for float {\n     #[inline(always)]\n-    pure fn to_str_radix(&self, radix: uint) -> ~str {\n+    fn to_str_radix(&self, radix: uint) -> ~str {\n         to_str_radix(*self, radix)\n     }\n }\n@@ -239,7 +239,7 @@ impl num::ToStrRadix for float {\n  * `Some(n)` where `n` is the floating-point number represented by `num`.\n  */\n #[inline(always)]\n-pub pure fn from_str(num: &str) -> Option<float> {\n+pub fn from_str(num: &str) -> Option<float> {\n     strconv::from_str_common(num, 10u, true, true, true,\n                              strconv::ExpDec, false)\n }\n@@ -272,7 +272,7 @@ pub pure fn from_str(num: &str) -> Option<float> {\n  * `Some(n)` where `n` is the floating-point number represented by `[num]`.\n  */\n #[inline(always)]\n-pub pure fn from_str_hex(num: &str) -> Option<float> {\n+pub fn from_str_hex(num: &str) -> Option<float> {\n     strconv::from_str_common(num, 16u, true, true, true,\n                              strconv::ExpBin, false)\n }\n@@ -297,19 +297,19 @@ pub pure fn from_str_hex(num: &str) -> Option<float> {\n  * `Some(n)` where `n` is the floating-point number represented by `num`.\n  */\n #[inline(always)]\n-pub pure fn from_str_radix(num: &str, radix: uint) -> Option<float> {\n+pub fn from_str_radix(num: &str, radix: uint) -> Option<float> {\n     strconv::from_str_common(num, radix, true, true, false,\n                              strconv::ExpNone, false)\n }\n \n impl from_str::FromStr for float {\n     #[inline(always)]\n-    pure fn from_str(val: &str) -> Option<float> { from_str(val) }\n+    fn from_str(val: &str) -> Option<float> { from_str(val) }\n }\n \n impl num::FromStrRadix for float {\n     #[inline(always)]\n-    pure fn from_str_radix(val: &str, radix: uint) -> Option<float> {\n+    fn from_str_radix(val: &str, radix: uint) -> Option<float> {\n         from_str_radix(val, radix)\n     }\n }\n@@ -330,7 +330,7 @@ impl num::FromStrRadix for float {\n  *\n  * `NaN` if both `x` and `pow` are `0u`, otherwise `x^pow`\n  */\n-pub pure fn pow_with_uint(base: uint, pow: uint) -> float {\n+pub fn pow_with_uint(base: uint, pow: uint) -> float {\n     if base == 0u {\n         if pow == 0u {\n             return NaN as float;\n@@ -351,98 +351,98 @@ pub pure fn pow_with_uint(base: uint, pow: uint) -> float {\n }\n \n #[inline(always)]\n-pub pure fn is_positive(x: float) -> bool { f64::is_positive(x as f64) }\n+pub fn is_positive(x: float) -> bool { f64::is_positive(x as f64) }\n #[inline(always)]\n-pub pure fn is_negative(x: float) -> bool { f64::is_negative(x as f64) }\n+pub fn is_negative(x: float) -> bool { f64::is_negative(x as f64) }\n #[inline(always)]\n-pub pure fn is_nonpositive(x: float) -> bool { f64::is_nonpositive(x as f64) }\n+pub fn is_nonpositive(x: float) -> bool { f64::is_nonpositive(x as f64) }\n #[inline(always)]\n-pub pure fn is_nonnegative(x: float) -> bool { f64::is_nonnegative(x as f64) }\n+pub fn is_nonnegative(x: float) -> bool { f64::is_nonnegative(x as f64) }\n #[inline(always)]\n-pub pure fn is_zero(x: float) -> bool { f64::is_zero(x as f64) }\n+pub fn is_zero(x: float) -> bool { f64::is_zero(x as f64) }\n #[inline(always)]\n-pub pure fn is_infinite(x: float) -> bool { f64::is_infinite(x as f64) }\n+pub fn is_infinite(x: float) -> bool { f64::is_infinite(x as f64) }\n #[inline(always)]\n-pub pure fn is_finite(x: float) -> bool { f64::is_finite(x as f64) }\n+pub fn is_finite(x: float) -> bool { f64::is_finite(x as f64) }\n #[inline(always)]\n-pub pure fn is_NaN(x: float) -> bool { f64::is_NaN(x as f64) }\n+pub fn is_NaN(x: float) -> bool { f64::is_NaN(x as f64) }\n \n #[inline(always)]\n-pub pure fn abs(x: float) -> float {\n+pub fn abs(x: float) -> float {\n     unsafe { f64::abs(x as f64) as float }\n }\n #[inline(always)]\n-pub pure fn sqrt(x: float) -> float {\n+pub fn sqrt(x: float) -> float {\n     unsafe { f64::sqrt(x as f64) as float }\n }\n #[inline(always)]\n-pub pure fn atan(x: float) -> float {\n+pub fn atan(x: float) -> float {\n     unsafe { f64::atan(x as f64) as float }\n }\n #[inline(always)]\n-pub pure fn sin(x: float) -> float {\n+pub fn sin(x: float) -> float {\n     unsafe { f64::sin(x as f64) as float }\n }\n #[inline(always)]\n-pub pure fn cos(x: float) -> float {\n+pub fn cos(x: float) -> float {\n     unsafe { f64::cos(x as f64) as float }\n }\n #[inline(always)]\n-pub pure fn tan(x: float) -> float {\n+pub fn tan(x: float) -> float {\n     unsafe { f64::tan(x as f64) as float }\n }\n \n #[cfg(notest)]\n impl Eq for float {\n-    pure fn eq(&self, other: &float) -> bool { (*self) == (*other) }\n-    pure fn ne(&self, other: &float) -> bool { (*self) != (*other) }\n+    fn eq(&self, other: &float) -> bool { (*self) == (*other) }\n+    fn ne(&self, other: &float) -> bool { (*self) != (*other) }\n }\n \n #[cfg(notest)]\n impl Ord for float {\n-    pure fn lt(&self, other: &float) -> bool { (*self) < (*other) }\n-    pure fn le(&self, other: &float) -> bool { (*self) <= (*other) }\n-    pure fn ge(&self, other: &float) -> bool { (*self) >= (*other) }\n-    pure fn gt(&self, other: &float) -> bool { (*self) > (*other) }\n+    fn lt(&self, other: &float) -> bool { (*self) < (*other) }\n+    fn le(&self, other: &float) -> bool { (*self) <= (*other) }\n+    fn ge(&self, other: &float) -> bool { (*self) >= (*other) }\n+    fn gt(&self, other: &float) -> bool { (*self) > (*other) }\n }\n \n impl num::Zero for float {\n     #[inline(always)]\n-    pure fn zero() -> float { 0.0 }\n+    fn zero() -> float { 0.0 }\n }\n \n impl num::One for float {\n     #[inline(always)]\n-    pure fn one() -> float { 1.0 }\n+    fn one() -> float { 1.0 }\n }\n \n impl NumCast for float {\n     /**\n      * Cast `n` to a `float`\n      */\n     #[inline(always)]\n-    pure fn from<N:NumCast>(n: N) -> float { n.to_float() }\n+    fn from<N:NumCast>(n: N) -> float { n.to_float() }\n \n-    #[inline(always)] pure fn to_u8(&self)    -> u8    { *self as u8    }\n-    #[inline(always)] pure fn to_u16(&self)   -> u16   { *self as u16   }\n-    #[inline(always)] pure fn to_u32(&self)   -> u32   { *self as u32   }\n-    #[inline(always)] pure fn to_u64(&self)   -> u64   { *self as u64   }\n-    #[inline(always)] pure fn to_uint(&self)  -> uint  { *self as uint  }\n+    #[inline(always)] fn to_u8(&self)    -> u8    { *self as u8    }\n+    #[inline(always)] fn to_u16(&self)   -> u16   { *self as u16   }\n+    #[inline(always)] fn to_u32(&self)   -> u32   { *self as u32   }\n+    #[inline(always)] fn to_u64(&self)   -> u64   { *self as u64   }\n+    #[inline(always)] fn to_uint(&self)  -> uint  { *self as uint  }\n \n-    #[inline(always)] pure fn to_i8(&self)    -> i8    { *self as i8    }\n-    #[inline(always)] pure fn to_i16(&self)   -> i16   { *self as i16   }\n-    #[inline(always)] pure fn to_i32(&self)   -> i32   { *self as i32   }\n-    #[inline(always)] pure fn to_i64(&self)   -> i64   { *self as i64   }\n-    #[inline(always)] pure fn to_int(&self)   -> int   { *self as int   }\n+    #[inline(always)] fn to_i8(&self)    -> i8    { *self as i8    }\n+    #[inline(always)] fn to_i16(&self)   -> i16   { *self as i16   }\n+    #[inline(always)] fn to_i32(&self)   -> i32   { *self as i32   }\n+    #[inline(always)] fn to_i64(&self)   -> i64   { *self as i64   }\n+    #[inline(always)] fn to_int(&self)   -> int   { *self as int   }\n \n-    #[inline(always)] pure fn to_f32(&self)   -> f32   { *self as f32   }\n-    #[inline(always)] pure fn to_f64(&self)   -> f64   { *self as f64   }\n-    #[inline(always)] pure fn to_float(&self) -> float { *self          }\n+    #[inline(always)] fn to_f32(&self)   -> f32   { *self as f32   }\n+    #[inline(always)] fn to_f64(&self)   -> f64   { *self as f64   }\n+    #[inline(always)] fn to_float(&self) -> float { *self          }\n }\n \n impl num::Round for float {\n     #[inline(always)]\n-    pure fn round(&self, mode: num::RoundMode) -> float {\n+    fn round(&self, mode: num::RoundMode) -> float {\n         match mode {\n             num::RoundDown\n                 => f64::floor(*self as f64) as float,\n@@ -460,11 +460,11 @@ impl num::Round for float {\n     }\n \n     #[inline(always)]\n-    pure fn floor(&self) -> float { f64::floor(*self as f64) as float}\n+    fn floor(&self) -> float { f64::floor(*self as f64) as float}\n     #[inline(always)]\n-    pure fn ceil(&self) -> float { f64::ceil(*self as f64) as float}\n+    fn ceil(&self) -> float { f64::ceil(*self as f64) as float}\n     #[inline(always)]\n-    pure fn fract(&self) -> float {\n+    fn fract(&self) -> float {\n         if is_negative(*self) {\n             (*self) - (f64::ceil(*self as f64) as float)\n         } else {\n@@ -475,27 +475,27 @@ impl num::Round for float {\n \n #[cfg(notest)]\n impl ops::Add<float,float> for float {\n-    pure fn add(&self, other: &float) -> float { *self + *other }\n+    fn add(&self, other: &float) -> float { *self + *other }\n }\n #[cfg(notest)]\n impl ops::Sub<float,float> for float {\n-    pure fn sub(&self, other: &float) -> float { *self - *other }\n+    fn sub(&self, other: &float) -> float { *self - *other }\n }\n #[cfg(notest)]\n impl ops::Mul<float,float> for float {\n-    pure fn mul(&self, other: &float) -> float { *self * *other }\n+    fn mul(&self, other: &float) -> float { *self * *other }\n }\n #[cfg(notest)]\n impl ops::Div<float,float> for float {\n-    pure fn div(&self, other: &float) -> float { *self / *other }\n+    fn div(&self, other: &float) -> float { *self / *other }\n }\n #[cfg(notest)]\n impl ops::Modulo<float,float> for float {\n-    pure fn modulo(&self, other: &float) -> float { *self % *other }\n+    fn modulo(&self, other: &float) -> float { *self % *other }\n }\n #[cfg(notest)]\n impl ops::Neg<float> for float {\n-    pure fn neg(&self) -> float { -*self }\n+    fn neg(&self) -> float { -*self }\n }\n \n #[test]"}, {"sha": "4d5ac92311ef8e02f1024c343b1319364c25407a", "filename": "src/libcore/num/int-template.rs", "status": "modified", "additions": 44, "deletions": 44, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/be9bddd46377bc982b73acf15a720365a54197a7/src%2Flibcore%2Fnum%2Fint-template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be9bddd46377bc982b73acf15a720365a54197a7/src%2Flibcore%2Fnum%2Fint-template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fint-template.rs?ref=be9bddd46377bc982b73acf15a720365a54197a7", "patch": "@@ -28,13 +28,13 @@ pub const min_value: T = (-1 as T) << (bits - 1);\n pub const max_value: T = min_value - 1 as T;\n \n #[inline(always)]\n-pub pure fn add(x: T, y: T) -> T { x + y }\n+pub fn add(x: T, y: T) -> T { x + y }\n #[inline(always)]\n-pub pure fn sub(x: T, y: T) -> T { x - y }\n+pub fn sub(x: T, y: T) -> T { x - y }\n #[inline(always)]\n-pub pure fn mul(x: T, y: T) -> T { x * y }\n+pub fn mul(x: T, y: T) -> T { x * y }\n #[inline(always)]\n-pub pure fn div(x: T, y: T) -> T { x / y }\n+pub fn div(x: T, y: T) -> T { x / y }\n \n /**\n  * Returns the remainder of y / x.\n@@ -57,29 +57,29 @@ pub pure fn div(x: T, y: T) -> T { x / y }\n  *\n  */\n #[inline(always)]\n-pub pure fn rem(x: T, y: T) -> T { x % y }\n+pub fn rem(x: T, y: T) -> T { x % y }\n \n #[inline(always)]\n-pub pure fn lt(x: T, y: T) -> bool { x < y }\n+pub fn lt(x: T, y: T) -> bool { x < y }\n #[inline(always)]\n-pub pure fn le(x: T, y: T) -> bool { x <= y }\n+pub fn le(x: T, y: T) -> bool { x <= y }\n #[inline(always)]\n-pub pure fn eq(x: T, y: T) -> bool { x == y }\n+pub fn eq(x: T, y: T) -> bool { x == y }\n #[inline(always)]\n-pub pure fn ne(x: T, y: T) -> bool { x != y }\n+pub fn ne(x: T, y: T) -> bool { x != y }\n #[inline(always)]\n-pub pure fn ge(x: T, y: T) -> bool { x >= y }\n+pub fn ge(x: T, y: T) -> bool { x >= y }\n #[inline(always)]\n-pub pure fn gt(x: T, y: T) -> bool { x > y }\n+pub fn gt(x: T, y: T) -> bool { x > y }\n \n #[inline(always)]\n-pub pure fn is_positive(x: T) -> bool { x > 0 as T }\n+pub fn is_positive(x: T) -> bool { x > 0 as T }\n #[inline(always)]\n-pub pure fn is_negative(x: T) -> bool { x < 0 as T }\n+pub fn is_negative(x: T) -> bool { x < 0 as T }\n #[inline(always)]\n-pub pure fn is_nonpositive(x: T) -> bool { x <= 0 as T }\n+pub fn is_nonpositive(x: T) -> bool { x <= 0 as T }\n #[inline(always)]\n-pub pure fn is_nonnegative(x: T) -> bool { x >= 0 as T }\n+pub fn is_nonnegative(x: T) -> bool { x >= 0 as T }\n \n /**\n  * Iterate over the range [`lo`..`hi`)\n@@ -100,7 +100,7 @@ pub pure fn is_nonnegative(x: T) -> bool { x >= 0 as T }\n  */\n #[inline(always)]\n /// Iterate over the range [`start`,`start`+`step`..`stop`)\n-pub pure fn range_step(start: T, stop: T, step: T, it: &fn(T) -> bool) {\n+pub fn range_step(start: T, stop: T, step: T, it: &fn(T) -> bool) {\n     let mut i = start;\n     if step == 0 {\n         fail!(~\"range_step called with step == 0\");\n@@ -119,116 +119,116 @@ pub pure fn range_step(start: T, stop: T, step: T, it: &fn(T) -> bool) {\n \n #[inline(always)]\n /// Iterate over the range [`lo`..`hi`)\n-pub pure fn range(lo: T, hi: T, it: &fn(T) -> bool) {\n+pub fn range(lo: T, hi: T, it: &fn(T) -> bool) {\n     range_step(lo, hi, 1 as T, it);\n }\n \n #[inline(always)]\n /// Iterate over the range [`hi`..`lo`)\n-pub pure fn range_rev(hi: T, lo: T, it: &fn(T) -> bool) {\n+pub fn range_rev(hi: T, lo: T, it: &fn(T) -> bool) {\n     range_step(hi, lo, -1 as T, it);\n }\n \n /// Computes the bitwise complement\n #[inline(always)]\n-pub pure fn compl(i: T) -> T {\n+pub fn compl(i: T) -> T {\n     -1 as T ^ i\n }\n \n /// Computes the absolute value\n #[inline(always)]\n-pub pure fn abs(i: T) -> T {\n+pub fn abs(i: T) -> T {\n     if is_negative(i) { -i } else { i }\n }\n \n #[cfg(notest)]\n impl Ord for T {\n     #[inline(always)]\n-    pure fn lt(&self, other: &T) -> bool { return (*self) < (*other); }\n+    fn lt(&self, other: &T) -> bool { return (*self) < (*other); }\n     #[inline(always)]\n-    pure fn le(&self, other: &T) -> bool { return (*self) <= (*other); }\n+    fn le(&self, other: &T) -> bool { return (*self) <= (*other); }\n     #[inline(always)]\n-    pure fn ge(&self, other: &T) -> bool { return (*self) >= (*other); }\n+    fn ge(&self, other: &T) -> bool { return (*self) >= (*other); }\n     #[inline(always)]\n-    pure fn gt(&self, other: &T) -> bool { return (*self) > (*other); }\n+    fn gt(&self, other: &T) -> bool { return (*self) > (*other); }\n }\n \n #[cfg(notest)]\n impl Eq for T {\n     #[inline(always)]\n-    pure fn eq(&self, other: &T) -> bool { return (*self) == (*other); }\n+    fn eq(&self, other: &T) -> bool { return (*self) == (*other); }\n     #[inline(always)]\n-    pure fn ne(&self, other: &T) -> bool { return (*self) != (*other); }\n+    fn ne(&self, other: &T) -> bool { return (*self) != (*other); }\n }\n \n impl num::Zero for T {\n     #[inline(always)]\n-    pure fn zero() -> T { 0 }\n+    fn zero() -> T { 0 }\n }\n \n impl num::One for T {\n     #[inline(always)]\n-    pure fn one() -> T { 1 }\n+    fn one() -> T { 1 }\n }\n \n #[cfg(notest)]\n impl ops::Add<T,T> for T {\n-    pure fn add(&self, other: &T) -> T { *self + *other }\n+    fn add(&self, other: &T) -> T { *self + *other }\n }\n #[cfg(notest)]\n impl ops::Sub<T,T> for T {\n-    pure fn sub(&self, other: &T) -> T { *self - *other }\n+    fn sub(&self, other: &T) -> T { *self - *other }\n }\n #[cfg(notest)]\n impl ops::Mul<T,T> for T {\n-    pure fn mul(&self, other: &T) -> T { *self * *other }\n+    fn mul(&self, other: &T) -> T { *self * *other }\n }\n #[cfg(notest)]\n impl ops::Div<T,T> for T {\n-    pure fn div(&self, other: &T) -> T { *self / *other }\n+    fn div(&self, other: &T) -> T { *self / *other }\n }\n #[cfg(notest)]\n impl ops::Modulo<T,T> for T {\n-    pure fn modulo(&self, other: &T) -> T { *self % *other }\n+    fn modulo(&self, other: &T) -> T { *self % *other }\n }\n #[cfg(notest)]\n impl ops::Neg<T> for T {\n-    pure fn neg(&self) -> T { -*self }\n+    fn neg(&self) -> T { -*self }\n }\n \n // String conversion functions and impl str -> num\n \n /// Parse a string as a number in base 10.\n #[inline(always)]\n-pub pure fn from_str(s: &str) -> Option<T> {\n+pub fn from_str(s: &str) -> Option<T> {\n     strconv::from_str_common(s, 10u, true, false, false,\n                          strconv::ExpNone, false)\n }\n \n /// Parse a string as a number in the given base.\n #[inline(always)]\n-pub pure fn from_str_radix(s: &str, radix: uint) -> Option<T> {\n+pub fn from_str_radix(s: &str, radix: uint) -> Option<T> {\n     strconv::from_str_common(s, radix, true, false, false,\n                          strconv::ExpNone, false)\n }\n \n /// Parse a byte slice as a number in the given base.\n #[inline(always)]\n-pub pure fn parse_bytes(buf: &[u8], radix: uint) -> Option<T> {\n+pub fn parse_bytes(buf: &[u8], radix: uint) -> Option<T> {\n     strconv::from_str_bytes_common(buf, radix, true, false, false,\n                                strconv::ExpNone, false)\n }\n \n impl FromStr for T {\n     #[inline(always)]\n-    pure fn from_str(s: &str) -> Option<T> {\n+    fn from_str(s: &str) -> Option<T> {\n         from_str(s)\n     }\n }\n \n impl FromStrRadix for T {\n     #[inline(always)]\n-    pure fn from_str_radix(s: &str, radix: uint) -> Option<T> {\n+    fn from_str_radix(s: &str, radix: uint) -> Option<T> {\n         from_str_radix(s, radix)\n     }\n }\n@@ -237,38 +237,38 @@ impl FromStrRadix for T {\n \n /// Convert to a string as a byte slice in a given base.\n #[inline(always)]\n-pub pure fn to_str_bytes<U>(n: T, radix: uint, f: &fn(v: &[u8]) -> U) -> U {\n+pub fn to_str_bytes<U>(n: T, radix: uint, f: &fn(v: &[u8]) -> U) -> U {\n     let (buf, _) = strconv::to_str_bytes_common(&n, radix, false,\n                             strconv::SignNeg, strconv::DigAll);\n     f(buf)\n }\n \n /// Convert to a string in base 10.\n #[inline(always)]\n-pub pure fn to_str(num: T) -> ~str {\n+pub fn to_str(num: T) -> ~str {\n     let (buf, _) = strconv::to_str_common(&num, 10u, false,\n                                       strconv::SignNeg, strconv::DigAll);\n     buf\n }\n \n /// Convert to a string in a given base.\n #[inline(always)]\n-pub pure fn to_str_radix(num: T, radix: uint) -> ~str {\n+pub fn to_str_radix(num: T, radix: uint) -> ~str {\n     let (buf, _) = strconv::to_str_common(&num, radix, false,\n                                       strconv::SignNeg, strconv::DigAll);\n     buf\n }\n \n impl ToStr for T {\n     #[inline(always)]\n-    pure fn to_str(&self) -> ~str {\n+    fn to_str(&self) -> ~str {\n         to_str(*self)\n     }\n }\n \n impl ToStrRadix for T {\n     #[inline(always)]\n-    pure fn to_str_radix(&self, radix: uint) -> ~str {\n+    fn to_str_radix(&self, radix: uint) -> ~str {\n         to_str_radix(*self, radix)\n     }\n }"}, {"sha": "9914807c98f6f4408e4b4ac28ed8bd725a5c6632", "filename": "src/libcore/num/int-template/i16.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/be9bddd46377bc982b73acf15a720365a54197a7/src%2Flibcore%2Fnum%2Fint-template%2Fi16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be9bddd46377bc982b73acf15a720365a54197a7/src%2Flibcore%2Fnum%2Fint-template%2Fi16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fint-template%2Fi16.rs?ref=be9bddd46377bc982b73acf15a720365a54197a7", "patch": "@@ -22,23 +22,23 @@ impl NumCast for i16 {\n      * Cast `n` to a `i16`\n      */\n     #[inline(always)]\n-    pure fn from<N:NumCast>(n: N) -> i16 { n.to_i16() }\n+    fn from<N:NumCast>(n: N) -> i16 { n.to_i16() }\n \n-    #[inline(always)] pure fn to_u8(&self)    -> u8    { *self as u8    }\n-    #[inline(always)] pure fn to_u16(&self)   -> u16   { *self as u16   }\n-    #[inline(always)] pure fn to_u32(&self)   -> u32   { *self as u32   }\n-    #[inline(always)] pure fn to_u64(&self)   -> u64   { *self as u64   }\n-    #[inline(always)] pure fn to_uint(&self)  -> uint  { *self as uint  }\n+    #[inline(always)] fn to_u8(&self)    -> u8    { *self as u8    }\n+    #[inline(always)] fn to_u16(&self)   -> u16   { *self as u16   }\n+    #[inline(always)] fn to_u32(&self)   -> u32   { *self as u32   }\n+    #[inline(always)] fn to_u64(&self)   -> u64   { *self as u64   }\n+    #[inline(always)] fn to_uint(&self)  -> uint  { *self as uint  }\n \n-    #[inline(always)] pure fn to_i8(&self)    -> i8    { *self as i8    }\n-    #[inline(always)] pure fn to_i16(&self)   -> i16   { *self          }\n-    #[inline(always)] pure fn to_i32(&self)   -> i32   { *self as i32   }\n-    #[inline(always)] pure fn to_i64(&self)   -> i64   { *self as i64   }\n-    #[inline(always)] pure fn to_int(&self)   -> int   { *self as int   }\n+    #[inline(always)] fn to_i8(&self)    -> i8    { *self as i8    }\n+    #[inline(always)] fn to_i16(&self)   -> i16   { *self          }\n+    #[inline(always)] fn to_i32(&self)   -> i32   { *self as i32   }\n+    #[inline(always)] fn to_i64(&self)   -> i64   { *self as i64   }\n+    #[inline(always)] fn to_int(&self)   -> int   { *self as int   }\n \n-    #[inline(always)] pure fn to_f32(&self)   -> f32   { *self as f32   }\n-    #[inline(always)] pure fn to_f64(&self)   -> f64   { *self as f64   }\n-    #[inline(always)] pure fn to_float(&self) -> float { *self as float }\n+    #[inline(always)] fn to_f32(&self)   -> f32   { *self as f32   }\n+    #[inline(always)] fn to_f64(&self)   -> f64   { *self as f64   }\n+    #[inline(always)] fn to_float(&self) -> float { *self as float }\n }\n \n #[test]"}, {"sha": "c02facd47db25a95ddc2c535344191dbf0098009", "filename": "src/libcore/num/int-template/i32.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/be9bddd46377bc982b73acf15a720365a54197a7/src%2Flibcore%2Fnum%2Fint-template%2Fi32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be9bddd46377bc982b73acf15a720365a54197a7/src%2Flibcore%2Fnum%2Fint-template%2Fi32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fint-template%2Fi32.rs?ref=be9bddd46377bc982b73acf15a720365a54197a7", "patch": "@@ -22,23 +22,23 @@ impl NumCast for i32 {\n      * Cast `n` to a `i32`\n      */\n     #[inline(always)]\n-    pure fn from<N:NumCast>(n: N) -> i32 { n.to_i32() }\n+    fn from<N:NumCast>(n: N) -> i32 { n.to_i32() }\n \n-    #[inline(always)] pure fn to_u8(&self)    -> u8    { *self as u8    }\n-    #[inline(always)] pure fn to_u16(&self)   -> u16   { *self as u16   }\n-    #[inline(always)] pure fn to_u32(&self)   -> u32   { *self as u32   }\n-    #[inline(always)] pure fn to_u64(&self)   -> u64   { *self as u64   }\n-    #[inline(always)] pure fn to_uint(&self)  -> uint  { *self as uint  }\n+    #[inline(always)] fn to_u8(&self)    -> u8    { *self as u8    }\n+    #[inline(always)] fn to_u16(&self)   -> u16   { *self as u16   }\n+    #[inline(always)] fn to_u32(&self)   -> u32   { *self as u32   }\n+    #[inline(always)] fn to_u64(&self)   -> u64   { *self as u64   }\n+    #[inline(always)] fn to_uint(&self)  -> uint  { *self as uint  }\n \n-    #[inline(always)] pure fn to_i8(&self)    -> i8    { *self as i8    }\n-    #[inline(always)] pure fn to_i16(&self)   -> i16   { *self as i16   }\n-    #[inline(always)] pure fn to_i32(&self)   -> i32   { *self          }\n-    #[inline(always)] pure fn to_i64(&self)   -> i64   { *self as i64   }\n-    #[inline(always)] pure fn to_int(&self)   -> int   { *self as int   }\n+    #[inline(always)] fn to_i8(&self)    -> i8    { *self as i8    }\n+    #[inline(always)] fn to_i16(&self)   -> i16   { *self as i16   }\n+    #[inline(always)] fn to_i32(&self)   -> i32   { *self          }\n+    #[inline(always)] fn to_i64(&self)   -> i64   { *self as i64   }\n+    #[inline(always)] fn to_int(&self)   -> int   { *self as int   }\n \n-    #[inline(always)] pure fn to_f32(&self)   -> f32   { *self as f32   }\n-    #[inline(always)] pure fn to_f64(&self)   -> f64   { *self as f64   }\n-    #[inline(always)] pure fn to_float(&self) -> float { *self as float }\n+    #[inline(always)] fn to_f32(&self)   -> f32   { *self as f32   }\n+    #[inline(always)] fn to_f64(&self)   -> f64   { *self as f64   }\n+    #[inline(always)] fn to_float(&self) -> float { *self as float }\n }\n \n #[test]"}, {"sha": "c285ba23c27899e444f9a0ba1a21e133f249d8fb", "filename": "src/libcore/num/int-template/i64.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/be9bddd46377bc982b73acf15a720365a54197a7/src%2Flibcore%2Fnum%2Fint-template%2Fi64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be9bddd46377bc982b73acf15a720365a54197a7/src%2Flibcore%2Fnum%2Fint-template%2Fi64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fint-template%2Fi64.rs?ref=be9bddd46377bc982b73acf15a720365a54197a7", "patch": "@@ -22,23 +22,23 @@ impl NumCast for i64 {\n      * Cast `n` to a `i64`\n      */\n     #[inline(always)]\n-    pure fn from<N:NumCast>(n: N) -> i64 { n.to_i64() }\n+    fn from<N:NumCast>(n: N) -> i64 { n.to_i64() }\n \n-    #[inline(always)] pure fn to_u8(&self)    -> u8    { *self as u8    }\n-    #[inline(always)] pure fn to_u16(&self)   -> u16   { *self as u16   }\n-    #[inline(always)] pure fn to_u32(&self)   -> u32   { *self as u32   }\n-    #[inline(always)] pure fn to_u64(&self)   -> u64   { *self as u64   }\n-    #[inline(always)] pure fn to_uint(&self)  -> uint  { *self as uint  }\n+    #[inline(always)] fn to_u8(&self)    -> u8    { *self as u8    }\n+    #[inline(always)] fn to_u16(&self)   -> u16   { *self as u16   }\n+    #[inline(always)] fn to_u32(&self)   -> u32   { *self as u32   }\n+    #[inline(always)] fn to_u64(&self)   -> u64   { *self as u64   }\n+    #[inline(always)] fn to_uint(&self)  -> uint  { *self as uint  }\n \n-    #[inline(always)] pure fn to_i8(&self)    -> i8    { *self as i8    }\n-    #[inline(always)] pure fn to_i16(&self)   -> i16   { *self as i16   }\n-    #[inline(always)] pure fn to_i32(&self)   -> i32   { *self as i32   }\n-    #[inline(always)] pure fn to_i64(&self)   -> i64   { *self          }\n-    #[inline(always)] pure fn to_int(&self)   -> int   { *self as int   }\n+    #[inline(always)] fn to_i8(&self)    -> i8    { *self as i8    }\n+    #[inline(always)] fn to_i16(&self)   -> i16   { *self as i16   }\n+    #[inline(always)] fn to_i32(&self)   -> i32   { *self as i32   }\n+    #[inline(always)] fn to_i64(&self)   -> i64   { *self          }\n+    #[inline(always)] fn to_int(&self)   -> int   { *self as int   }\n \n-    #[inline(always)] pure fn to_f32(&self)   -> f32   { *self as f32   }\n-    #[inline(always)] pure fn to_f64(&self)   -> f64   { *self as f64   }\n-    #[inline(always)] pure fn to_float(&self) -> float { *self as float }\n+    #[inline(always)] fn to_f32(&self)   -> f32   { *self as f32   }\n+    #[inline(always)] fn to_f64(&self)   -> f64   { *self as f64   }\n+    #[inline(always)] fn to_float(&self) -> float { *self as float }\n }\n \n #[test]"}, {"sha": "2733a064563269d26b8928f202f5b0dff9419641", "filename": "src/libcore/num/int-template/i8.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/be9bddd46377bc982b73acf15a720365a54197a7/src%2Flibcore%2Fnum%2Fint-template%2Fi8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be9bddd46377bc982b73acf15a720365a54197a7/src%2Flibcore%2Fnum%2Fint-template%2Fi8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fint-template%2Fi8.rs?ref=be9bddd46377bc982b73acf15a720365a54197a7", "patch": "@@ -22,23 +22,23 @@ impl NumCast for i8 {\n      * Cast `n` to a `i8`\n      */\n     #[inline(always)]\n-    pure fn from<N:NumCast>(n: N) -> i8 { n.to_i8() }\n+    fn from<N:NumCast>(n: N) -> i8 { n.to_i8() }\n \n-    #[inline(always)] pure fn to_u8(&self)    -> u8    { *self as u8    }\n-    #[inline(always)] pure fn to_u16(&self)   -> u16   { *self as u16   }\n-    #[inline(always)] pure fn to_u32(&self)   -> u32   { *self as u32   }\n-    #[inline(always)] pure fn to_u64(&self)   -> u64   { *self as u64   }\n-    #[inline(always)] pure fn to_uint(&self)  -> uint  { *self as uint  }\n+    #[inline(always)] fn to_u8(&self)    -> u8    { *self as u8    }\n+    #[inline(always)] fn to_u16(&self)   -> u16   { *self as u16   }\n+    #[inline(always)] fn to_u32(&self)   -> u32   { *self as u32   }\n+    #[inline(always)] fn to_u64(&self)   -> u64   { *self as u64   }\n+    #[inline(always)] fn to_uint(&self)  -> uint  { *self as uint  }\n \n-    #[inline(always)] pure fn to_i8(&self)    -> i8    { *self          }\n-    #[inline(always)] pure fn to_i16(&self)   -> i16   { *self as i16   }\n-    #[inline(always)] pure fn to_i32(&self)   -> i32   { *self as i32   }\n-    #[inline(always)] pure fn to_i64(&self)   -> i64   { *self as i64   }\n-    #[inline(always)] pure fn to_int(&self)   -> int   { *self as int   }\n+    #[inline(always)] fn to_i8(&self)    -> i8    { *self          }\n+    #[inline(always)] fn to_i16(&self)   -> i16   { *self as i16   }\n+    #[inline(always)] fn to_i32(&self)   -> i32   { *self as i32   }\n+    #[inline(always)] fn to_i64(&self)   -> i64   { *self as i64   }\n+    #[inline(always)] fn to_int(&self)   -> int   { *self as int   }\n \n-    #[inline(always)] pure fn to_f32(&self)   -> f32   { *self as f32   }\n-    #[inline(always)] pure fn to_f64(&self)   -> f64   { *self as f64   }\n-    #[inline(always)] pure fn to_float(&self) -> float { *self as float }\n+    #[inline(always)] fn to_f32(&self)   -> f32   { *self as f32   }\n+    #[inline(always)] fn to_f64(&self)   -> f64   { *self as f64   }\n+    #[inline(always)] fn to_float(&self) -> float { *self as float }\n }\n \n #[test]"}, {"sha": "29e1e52348eb9eb821a839f209092dfecb13ec6d", "filename": "src/libcore/num/int-template/int.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/be9bddd46377bc982b73acf15a720365a54197a7/src%2Flibcore%2Fnum%2Fint-template%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be9bddd46377bc982b73acf15a720365a54197a7/src%2Flibcore%2Fnum%2Fint-template%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fint-template%2Fint.rs?ref=be9bddd46377bc982b73acf15a720365a54197a7", "patch": "@@ -19,7 +19,7 @@ mod inst {\n     pub const bits: uint = ::uint::bits;\n \n     /// Returns `base` raised to the power of `exponent`\n-    pub pure fn pow(base: int, exponent: uint) -> int {\n+    pub fn pow(base: int, exponent: uint) -> int {\n         if exponent == 0u {\n             //Not mathemtically true if ~[base == 0]\n             return 1;\n@@ -63,23 +63,23 @@ impl NumCast for int {\n      * Cast `n` to a `int`\n      */\n     #[inline(always)]\n-    pure fn from<N:NumCast>(n: N) -> int { n.to_int() }\n+    fn from<N:NumCast>(n: N) -> int { n.to_int() }\n \n-    #[inline(always)] pure fn to_u8(&self)    -> u8    { *self as u8    }\n-    #[inline(always)] pure fn to_u16(&self)   -> u16   { *self as u16   }\n-    #[inline(always)] pure fn to_u32(&self)   -> u32   { *self as u32   }\n-    #[inline(always)] pure fn to_u64(&self)   -> u64   { *self as u64   }\n-    #[inline(always)] pure fn to_uint(&self)  -> uint  { *self as uint  }\n+    #[inline(always)] fn to_u8(&self)    -> u8    { *self as u8    }\n+    #[inline(always)] fn to_u16(&self)   -> u16   { *self as u16   }\n+    #[inline(always)] fn to_u32(&self)   -> u32   { *self as u32   }\n+    #[inline(always)] fn to_u64(&self)   -> u64   { *self as u64   }\n+    #[inline(always)] fn to_uint(&self)  -> uint  { *self as uint  }\n \n-    #[inline(always)] pure fn to_i8(&self)    -> i8    { *self as i8    }\n-    #[inline(always)] pure fn to_i16(&self)   -> i16   { *self as i16   }\n-    #[inline(always)] pure fn to_i32(&self)   -> i32   { *self as i32   }\n-    #[inline(always)] pure fn to_i64(&self)   -> i64   { *self as i64   }\n-    #[inline(always)] pure fn to_int(&self)   -> int   { *self          }\n+    #[inline(always)] fn to_i8(&self)    -> i8    { *self as i8    }\n+    #[inline(always)] fn to_i16(&self)   -> i16   { *self as i16   }\n+    #[inline(always)] fn to_i32(&self)   -> i32   { *self as i32   }\n+    #[inline(always)] fn to_i64(&self)   -> i64   { *self as i64   }\n+    #[inline(always)] fn to_int(&self)   -> int   { *self          }\n \n-    #[inline(always)] pure fn to_f32(&self)   -> f32   { *self as f32   }\n-    #[inline(always)] pure fn to_f64(&self)   -> f64   { *self as f64   }\n-    #[inline(always)] pure fn to_float(&self) -> float { *self as float }\n+    #[inline(always)] fn to_f32(&self)   -> f32   { *self as f32   }\n+    #[inline(always)] fn to_f64(&self)   -> f64   { *self as f64   }\n+    #[inline(always)] fn to_float(&self) -> float { *self as float }\n }\n \n #[test]"}, {"sha": "32d48aac0b342d55e0ed11bb8e3b9df8b732005f", "filename": "src/libcore/num/num.rs", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/be9bddd46377bc982b73acf15a720365a54197a7/src%2Flibcore%2Fnum%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be9bddd46377bc982b73acf15a720365a54197a7/src%2Flibcore%2Fnum%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fnum.rs?ref=be9bddd46377bc982b73acf15a720365a54197a7", "patch": "@@ -17,28 +17,28 @@ use kinds::Copy;\n pub mod strconv;\n \n pub trait IntConvertible {\n-    pure fn to_int(&self) -> int;\n-    pure fn from_int(n: int) -> Self;\n+    fn to_int(&self) -> int;\n+    fn from_int(n: int) -> Self;\n }\n \n pub trait Zero {\n-    pure fn zero() -> Self;\n+    fn zero() -> Self;\n }\n \n pub trait One {\n-    pure fn one() -> Self;\n+    fn one() -> Self;\n }\n \n-pub pure fn abs<T:Ord + Zero + Neg<T>>(v: T) -> T {\n+pub fn abs<T:Ord + Zero + Neg<T>>(v: T) -> T {\n     if v < Zero::zero() { v.neg() } else { v }\n }\n \n pub trait Round {\n-    pure fn round(&self, mode: RoundMode) -> Self;\n+    fn round(&self, mode: RoundMode) -> Self;\n \n-    pure fn floor(&self) -> Self;\n-    pure fn ceil(&self)  -> Self;\n-    pure fn fract(&self) -> Self;\n+    fn floor(&self) -> Self;\n+    fn ceil(&self)  -> Self;\n+    fn fract(&self) -> Self;\n }\n \n pub enum RoundMode {\n@@ -59,39 +59,39 @@ pub enum RoundMode {\n  * ~~~\n  */\n #[inline(always)]\n-pub pure fn cast<T:NumCast,U:NumCast>(n: T) -> U {\n+pub fn cast<T:NumCast,U:NumCast>(n: T) -> U {\n     NumCast::from(n)\n }\n \n /**\n  * An interface for generic numeric type casts\n  */\n pub trait NumCast {\n-    pure fn from<T:NumCast>(n: T) -> Self;\n-\n-    pure fn to_u8(&self) -> u8;\n-    pure fn to_u16(&self) -> u16;\n-    pure fn to_u32(&self) -> u32;\n-    pure fn to_u64(&self) -> u64;\n-    pure fn to_uint(&self) -> uint;\n-\n-    pure fn to_i8(&self) -> i8;\n-    pure fn to_i16(&self) -> i16;\n-    pure fn to_i32(&self) -> i32;\n-    pure fn to_i64(&self) -> i64;\n-    pure fn to_int(&self) -> int;\n-\n-    pure fn to_f32(&self) -> f32;\n-    pure fn to_f64(&self) -> f64;\n-    pure fn to_float(&self) -> float;\n+    fn from<T:NumCast>(n: T) -> Self;\n+\n+    fn to_u8(&self) -> u8;\n+    fn to_u16(&self) -> u16;\n+    fn to_u32(&self) -> u32;\n+    fn to_u64(&self) -> u64;\n+    fn to_uint(&self) -> uint;\n+\n+    fn to_i8(&self) -> i8;\n+    fn to_i16(&self) -> i16;\n+    fn to_i32(&self) -> i32;\n+    fn to_i64(&self) -> i64;\n+    fn to_int(&self) -> int;\n+\n+    fn to_f32(&self) -> f32;\n+    fn to_f64(&self) -> f64;\n+    fn to_float(&self) -> float;\n }\n \n pub trait ToStrRadix {\n-    pub pure fn to_str_radix(&self, radix: uint) -> ~str;\n+    pub fn to_str_radix(&self, radix: uint) -> ~str;\n }\n \n pub trait FromStrRadix {\n-    pub pure fn from_str_radix(str: &str, radix: uint) -> Option<Self>;\n+    pub fn from_str_radix(str: &str, radix: uint) -> Option<Self>;\n }\n \n // Generic math functions:\n@@ -109,7 +109,7 @@ pub trait FromStrRadix {\n  * - If code written to use this function doesn't care about it, it's\n  *   probably assuming that `x^0` always equals `1`.\n  */\n-pub pure fn pow_with_uint<T:NumCast+One+Zero+Copy+Div<T,T>+Mul<T,T>>(\n+pub fn pow_with_uint<T:NumCast+One+Zero+Copy+Div<T,T>+Mul<T,T>>(\n     radix: uint, pow: uint) -> T {\n     let _0: T = Zero::zero();\n     let _1: T = One::one();"}, {"sha": "e39d52d86f2cdbf7f784ec39571833d0228636ed", "filename": "src/libcore/num/strconv.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/be9bddd46377bc982b73acf15a720365a54197a7/src%2Flibcore%2Fnum%2Fstrconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be9bddd46377bc982b73acf15a720365a54197a7/src%2Flibcore%2Fnum%2Fstrconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fstrconv.rs?ref=be9bddd46377bc982b73acf15a720365a54197a7", "patch": "@@ -37,78 +37,78 @@ pub enum SignFormat {\n }\n \n #[inline(always)]\n-pure fn is_NaN<T:Eq>(num: &T) -> bool {\n+fn is_NaN<T:Eq>(num: &T) -> bool {\n     *num != *num\n }\n \n #[inline(always)]\n-pure fn is_inf<T:Eq+NumStrConv>(num: &T) -> bool {\n+fn is_inf<T:Eq+NumStrConv>(num: &T) -> bool {\n     match NumStrConv::inf() {\n         None    => false,\n         Some(n) => *num == n\n     }\n }\n \n #[inline(always)]\n-pure fn is_neg_inf<T:Eq+NumStrConv>(num: &T) -> bool {\n+fn is_neg_inf<T:Eq+NumStrConv>(num: &T) -> bool {\n     match NumStrConv::neg_inf() {\n         None    => false,\n         Some(n) => *num == n\n     }\n }\n \n #[inline(always)]\n-pure fn is_neg_zero<T:Eq+One+Zero+NumStrConv+Div<T,T>>(num: &T) -> bool {\n+fn is_neg_zero<T:Eq+One+Zero+NumStrConv+Div<T,T>>(num: &T) -> bool {\n     let _0: T = Zero::zero();\n     let _1: T = One::one();\n \n     *num == _0 && is_neg_inf(&(_1 / *num))\n }\n \n pub trait NumStrConv {\n-    pure fn NaN()      -> Option<Self>;\n-    pure fn inf()      -> Option<Self>;\n-    pure fn neg_inf()  -> Option<Self>;\n-    pure fn neg_zero() -> Option<Self>;\n+    fn NaN()      -> Option<Self>;\n+    fn inf()      -> Option<Self>;\n+    fn neg_inf()  -> Option<Self>;\n+    fn neg_zero() -> Option<Self>;\n \n-    pure fn round_to_zero(&self)   -> Self;\n-    pure fn fractional_part(&self) -> Self;\n+    fn round_to_zero(&self)   -> Self;\n+    fn fractional_part(&self) -> Self;\n }\n \n macro_rules! impl_NumStrConv_Floating (($t:ty) => (\n     impl NumStrConv for $t {\n         #[inline(always)]\n-        pure fn NaN()      -> Option<$t> { Some( 0.0 / 0.0) }\n+        fn NaN()      -> Option<$t> { Some( 0.0 / 0.0) }\n         #[inline(always)]\n-        pure fn inf()      -> Option<$t> { Some( 1.0 / 0.0) }\n+        fn inf()      -> Option<$t> { Some( 1.0 / 0.0) }\n         #[inline(always)]\n-        pure fn neg_inf()  -> Option<$t> { Some(-1.0 / 0.0) }\n+        fn neg_inf()  -> Option<$t> { Some(-1.0 / 0.0) }\n         #[inline(always)]\n-        pure fn neg_zero() -> Option<$t> { Some(-0.0      ) }\n+        fn neg_zero() -> Option<$t> { Some(-0.0      ) }\n \n         #[inline(always)]\n-        pure fn round_to_zero(&self) -> $t {\n+        fn round_to_zero(&self) -> $t {\n             ( if *self < 0.0 { f64::ceil(*self as f64)  }\n               else           { f64::floor(*self as f64) }\n             ) as $t\n         }\n \n         #[inline(always)]\n-        pure fn fractional_part(&self) -> $t {\n+        fn fractional_part(&self) -> $t {\n             *self - self.round_to_zero()\n         }\n     }\n ))\n \n macro_rules! impl_NumStrConv_Integer (($t:ty) => (\n     impl NumStrConv for $t {\n-        #[inline(always)] pure fn NaN()      -> Option<$t> { None }\n-        #[inline(always)] pure fn inf()      -> Option<$t> { None }\n-        #[inline(always)] pure fn neg_inf()  -> Option<$t> { None }\n-        #[inline(always)] pure fn neg_zero() -> Option<$t> { None }\n+        #[inline(always)] fn NaN()      -> Option<$t> { None }\n+        #[inline(always)] fn inf()      -> Option<$t> { None }\n+        #[inline(always)] fn neg_inf()  -> Option<$t> { None }\n+        #[inline(always)] fn neg_zero() -> Option<$t> { None }\n \n-        #[inline(always)] pure fn round_to_zero(&self)   -> $t { *self }\n-        #[inline(always)] pure fn fractional_part(&self) -> $t {     0 }\n+        #[inline(always)] fn round_to_zero(&self)   -> $t { *self }\n+        #[inline(always)] fn fractional_part(&self) -> $t {     0 }\n     }\n ))\n \n@@ -161,7 +161,7 @@ impl_NumStrConv_Integer!(u64)\n  * # Failure\n  * - Fails if `radix` < 2 or `radix` > 36.\n  */\n-pub pure fn to_str_bytes_common<T:NumCast+Zero+One+Eq+Ord+NumStrConv+Copy+\n+pub fn to_str_bytes_common<T:NumCast+Zero+One+Eq+Ord+NumStrConv+Copy+\n                                   Div<T,T>+Neg<T>+Modulo<T,T>+Mul<T,T>>(\n         num: &T, radix: uint, negative_zero: bool,\n         sign: SignFormat, digits: SignificantDigits) -> (~[u8], bool) {\n@@ -383,7 +383,7 @@ pub pure fn to_str_bytes_common<T:NumCast+Zero+One+Eq+Ord+NumStrConv+Copy+\n  * `to_str_bytes_common()`, for details see there.\n  */\n #[inline(always)]\n-pub pure fn to_str_common<T:NumCast+Zero+One+Eq+Ord+NumStrConv+Copy+\n+pub fn to_str_common<T:NumCast+Zero+One+Eq+Ord+NumStrConv+Copy+\n                             Div<T,T>+Neg<T>+Modulo<T,T>+Mul<T,T>>(\n         num: &T, radix: uint, negative_zero: bool,\n         sign: SignFormat, digits: SignificantDigits) -> (~str, bool) {\n@@ -439,7 +439,7 @@ priv const DIGIT_E_RADIX: uint = ('e' as uint) - ('a' as uint) + 11u;\n  * - Could accept option to allow ignoring underscores, allowing for numbers\n  *   formated like `FF_AE_FF_FF`.\n  */\n-pub pure fn from_str_bytes_common<T:NumCast+Zero+One+Ord+Copy+Div<T,T>+\n+pub fn from_str_bytes_common<T:NumCast+Zero+One+Ord+Copy+Div<T,T>+\n                                     Mul<T,T>+Sub<T,T>+Neg<T>+Add<T,T>+\n                                     NumStrConv>(\n         buf: &[u8], radix: uint, negative: bool, fractional: bool,\n@@ -628,7 +628,7 @@ pub pure fn from_str_bytes_common<T:NumCast+Zero+One+Ord+Copy+Div<T,T>+\n  * `from_str_bytes_common()`, for details see there.\n  */\n #[inline(always)]\n-pub pure fn from_str_common<T:NumCast+Zero+One+Ord+Copy+Div<T,T>+Mul<T,T>+\n+pub fn from_str_common<T:NumCast+Zero+One+Ord+Copy+Div<T,T>+Mul<T,T>+\n                               Sub<T,T>+Neg<T>+Add<T,T>+NumStrConv>(\n         buf: &str, radix: uint, negative: bool, fractional: bool,\n         special: bool, exponent: ExponentFormat, empty_zero: bool"}, {"sha": "b8e713ff3aba5d6fc332a9eb36ee8ed36b59807e", "filename": "src/libcore/num/uint-template.rs", "status": "modified", "additions": 43, "deletions": 43, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/be9bddd46377bc982b73acf15a720365a54197a7/src%2Flibcore%2Fnum%2Fuint-template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be9bddd46377bc982b73acf15a720365a54197a7/src%2Flibcore%2Fnum%2Fuint-template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fuint-template.rs?ref=be9bddd46377bc982b73acf15a720365a54197a7", "patch": "@@ -30,44 +30,44 @@ pub const min_value: T = 0 as T;\n pub const max_value: T = 0 as T - 1 as T;\n \n #[inline(always)]\n-pub pure fn add(x: T, y: T) -> T { x + y }\n+pub fn add(x: T, y: T) -> T { x + y }\n #[inline(always)]\n-pub pure fn sub(x: T, y: T) -> T { x - y }\n+pub fn sub(x: T, y: T) -> T { x - y }\n #[inline(always)]\n-pub pure fn mul(x: T, y: T) -> T { x * y }\n+pub fn mul(x: T, y: T) -> T { x * y }\n #[inline(always)]\n-pub pure fn div(x: T, y: T) -> T { x / y }\n+pub fn div(x: T, y: T) -> T { x / y }\n #[inline(always)]\n-pub pure fn rem(x: T, y: T) -> T { x % y }\n+pub fn rem(x: T, y: T) -> T { x % y }\n \n #[inline(always)]\n-pub pure fn lt(x: T, y: T) -> bool { x < y }\n+pub fn lt(x: T, y: T) -> bool { x < y }\n #[inline(always)]\n-pub pure fn le(x: T, y: T) -> bool { x <= y }\n+pub fn le(x: T, y: T) -> bool { x <= y }\n #[inline(always)]\n-pub pure fn eq(x: T, y: T) -> bool { x == y }\n+pub fn eq(x: T, y: T) -> bool { x == y }\n #[inline(always)]\n-pub pure fn ne(x: T, y: T) -> bool { x != y }\n+pub fn ne(x: T, y: T) -> bool { x != y }\n #[inline(always)]\n-pub pure fn ge(x: T, y: T) -> bool { x >= y }\n+pub fn ge(x: T, y: T) -> bool { x >= y }\n #[inline(always)]\n-pub pure fn gt(x: T, y: T) -> bool { x > y }\n+pub fn gt(x: T, y: T) -> bool { x > y }\n \n #[inline(always)]\n-pub pure fn is_positive(x: T) -> bool { x > 0 as T }\n+pub fn is_positive(x: T) -> bool { x > 0 as T }\n #[inline(always)]\n-pub pure fn is_negative(x: T) -> bool { x < 0 as T }\n+pub fn is_negative(x: T) -> bool { x < 0 as T }\n #[inline(always)]\n-pub pure fn is_nonpositive(x: T) -> bool { x <= 0 as T }\n+pub fn is_nonpositive(x: T) -> bool { x <= 0 as T }\n #[inline(always)]\n-pub pure fn is_nonnegative(x: T) -> bool { x >= 0 as T }\n+pub fn is_nonnegative(x: T) -> bool { x >= 0 as T }\n \n #[inline(always)]\n /**\n  * Iterate over the range [`start`,`start`+`step`..`stop`)\n  *\n  */\n-pub pure fn range_step(start: T,\n+pub fn range_step(start: T,\n                        stop: T,\n                        step: T_SIGNED,\n                        it: &fn(T) -> bool) {\n@@ -91,110 +91,110 @@ pub pure fn range_step(start: T,\n \n #[inline(always)]\n /// Iterate over the range [`lo`..`hi`)\n-pub pure fn range(lo: T, hi: T, it: &fn(T) -> bool) {\n+pub fn range(lo: T, hi: T, it: &fn(T) -> bool) {\n     range_step(lo, hi, 1 as T_SIGNED, it);\n }\n \n #[inline(always)]\n /// Iterate over the range [`hi`..`lo`)\n-pub pure fn range_rev(hi: T, lo: T, it: &fn(T) -> bool) {\n+pub fn range_rev(hi: T, lo: T, it: &fn(T) -> bool) {\n     range_step(hi, lo, -1 as T_SIGNED, it);\n }\n \n /// Computes the bitwise complement\n #[inline(always)]\n-pub pure fn compl(i: T) -> T {\n+pub fn compl(i: T) -> T {\n     max_value ^ i\n }\n \n #[cfg(notest)]\n impl Ord for T {\n     #[inline(always)]\n-    pure fn lt(&self, other: &T) -> bool { (*self) < (*other) }\n+    fn lt(&self, other: &T) -> bool { (*self) < (*other) }\n     #[inline(always)]\n-    pure fn le(&self, other: &T) -> bool { (*self) <= (*other) }\n+    fn le(&self, other: &T) -> bool { (*self) <= (*other) }\n     #[inline(always)]\n-    pure fn ge(&self, other: &T) -> bool { (*self) >= (*other) }\n+    fn ge(&self, other: &T) -> bool { (*self) >= (*other) }\n     #[inline(always)]\n-    pure fn gt(&self, other: &T) -> bool { (*self) > (*other) }\n+    fn gt(&self, other: &T) -> bool { (*self) > (*other) }\n }\n \n #[cfg(notest)]\n impl Eq for T {\n     #[inline(always)]\n-    pure fn eq(&self, other: &T) -> bool { return (*self) == (*other); }\n+    fn eq(&self, other: &T) -> bool { return (*self) == (*other); }\n     #[inline(always)]\n-    pure fn ne(&self, other: &T) -> bool { return (*self) != (*other); }\n+    fn ne(&self, other: &T) -> bool { return (*self) != (*other); }\n }\n \n impl num::Zero for T {\n     #[inline(always)]\n-    pure fn zero() -> T { 0 }\n+    fn zero() -> T { 0 }\n }\n \n impl num::One for T {\n     #[inline(always)]\n-    pure fn one() -> T { 1 }\n+    fn one() -> T { 1 }\n }\n \n #[cfg(notest)]\n impl ops::Add<T,T> for T {\n-    pure fn add(&self, other: &T) -> T { *self + *other }\n+    fn add(&self, other: &T) -> T { *self + *other }\n }\n #[cfg(notest)]\n impl ops::Sub<T,T> for T {\n-    pure fn sub(&self, other: &T) -> T { *self - *other }\n+    fn sub(&self, other: &T) -> T { *self - *other }\n }\n #[cfg(notest)]\n impl ops::Mul<T,T> for T {\n-    pure fn mul(&self, other: &T) -> T { *self * *other }\n+    fn mul(&self, other: &T) -> T { *self * *other }\n }\n #[cfg(notest)]\n impl ops::Div<T,T> for T {\n-    pure fn div(&self, other: &T) -> T { *self / *other }\n+    fn div(&self, other: &T) -> T { *self / *other }\n }\n #[cfg(notest)]\n impl ops::Modulo<T,T> for T {\n-    pure fn modulo(&self, other: &T) -> T { *self % *other }\n+    fn modulo(&self, other: &T) -> T { *self % *other }\n }\n #[cfg(notest)]\n impl ops::Neg<T> for T {\n-    pure fn neg(&self) -> T { -*self }\n+    fn neg(&self) -> T { -*self }\n }\n \n // String conversion functions and impl str -> num\n \n /// Parse a string as a number in base 10.\n #[inline(always)]\n-pub pure fn from_str(s: &str) -> Option<T> {\n+pub fn from_str(s: &str) -> Option<T> {\n     strconv::from_str_common(s, 10u, false, false, false,\n                              strconv::ExpNone, false)\n }\n \n /// Parse a string as a number in the given base.\n #[inline(always)]\n-pub pure fn from_str_radix(s: &str, radix: uint) -> Option<T> {\n+pub fn from_str_radix(s: &str, radix: uint) -> Option<T> {\n     strconv::from_str_common(s, radix, false, false, false,\n                              strconv::ExpNone, false)\n }\n \n /// Parse a byte slice as a number in the given base.\n #[inline(always)]\n-pub pure fn parse_bytes(buf: &[u8], radix: uint) -> Option<T> {\n+pub fn parse_bytes(buf: &[u8], radix: uint) -> Option<T> {\n     strconv::from_str_bytes_common(buf, radix, false, false, false,\n                                    strconv::ExpNone, false)\n }\n \n impl FromStr for T {\n     #[inline(always)]\n-    pure fn from_str(s: &str) -> Option<T> {\n+    fn from_str(s: &str) -> Option<T> {\n         from_str(s)\n     }\n }\n \n impl FromStrRadix for T {\n     #[inline(always)]\n-    pure fn from_str_radix(s: &str, radix: uint) -> Option<T> {\n+    fn from_str_radix(s: &str, radix: uint) -> Option<T> {\n         from_str_radix(s, radix)\n     }\n }\n@@ -203,38 +203,38 @@ impl FromStrRadix for T {\n \n /// Convert to a string as a byte slice in a given base.\n #[inline(always)]\n-pub pure fn to_str_bytes<U>(n: T, radix: uint, f: &fn(v: &[u8]) -> U) -> U {\n+pub fn to_str_bytes<U>(n: T, radix: uint, f: &fn(v: &[u8]) -> U) -> U {\n     let (buf, _) = strconv::to_str_bytes_common(&n, radix, false,\n                             strconv::SignNeg, strconv::DigAll);\n     f(buf)\n }\n \n /// Convert to a string in base 10.\n #[inline(always)]\n-pub pure fn to_str(num: T) -> ~str {\n+pub fn to_str(num: T) -> ~str {\n     let (buf, _) = strconv::to_str_common(&num, 10u, false,\n                             strconv::SignNeg, strconv::DigAll);\n     buf\n }\n \n /// Convert to a string in a given base.\n #[inline(always)]\n-pub pure fn to_str_radix(num: T, radix: uint) -> ~str {\n+pub fn to_str_radix(num: T, radix: uint) -> ~str {\n     let (buf, _) = strconv::to_str_common(&num, radix, false,\n                             strconv::SignNeg, strconv::DigAll);\n     buf\n }\n \n impl ToStr for T {\n     #[inline(always)]\n-    pure fn to_str(&self) -> ~str {\n+    fn to_str(&self) -> ~str {\n         to_str(*self)\n     }\n }\n \n impl ToStrRadix for T {\n     #[inline(always)]\n-    pure fn to_str_radix(&self, radix: uint) -> ~str {\n+    fn to_str_radix(&self, radix: uint) -> ~str {\n         to_str_radix(*self, radix)\n     }\n }"}, {"sha": "bdd951201362118b8ac79e8b48670297aa2470fb", "filename": "src/libcore/num/uint-template/u16.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/be9bddd46377bc982b73acf15a720365a54197a7/src%2Flibcore%2Fnum%2Fuint-template%2Fu16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be9bddd46377bc982b73acf15a720365a54197a7/src%2Flibcore%2Fnum%2Fuint-template%2Fu16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fuint-template%2Fu16.rs?ref=be9bddd46377bc982b73acf15a720365a54197a7", "patch": "@@ -24,23 +24,23 @@ impl NumCast for u16 {\n      * Cast `n` to a `u16`\n      */\n     #[inline(always)]\n-    pure fn from<N:NumCast>(n: N) -> u16 { n.to_u16() }\n+    fn from<N:NumCast>(n: N) -> u16 { n.to_u16() }\n \n-    #[inline(always)] pure fn to_u8(&self)    -> u8    { *self as u8    }\n-    #[inline(always)] pure fn to_u16(&self)   -> u16   { *self          }\n-    #[inline(always)] pure fn to_u32(&self)   -> u32   { *self as u32   }\n-    #[inline(always)] pure fn to_u64(&self)   -> u64   { *self as u64   }\n-    #[inline(always)] pure fn to_uint(&self)  -> uint  { *self as uint  }\n+    #[inline(always)] fn to_u8(&self)    -> u8    { *self as u8    }\n+    #[inline(always)] fn to_u16(&self)   -> u16   { *self          }\n+    #[inline(always)] fn to_u32(&self)   -> u32   { *self as u32   }\n+    #[inline(always)] fn to_u64(&self)   -> u64   { *self as u64   }\n+    #[inline(always)] fn to_uint(&self)  -> uint  { *self as uint  }\n \n-    #[inline(always)] pure fn to_i8(&self)    -> i8    { *self as i8    }\n-    #[inline(always)] pure fn to_i16(&self)   -> i16   { *self as i16   }\n-    #[inline(always)] pure fn to_i32(&self)   -> i32   { *self as i32   }\n-    #[inline(always)] pure fn to_i64(&self)   -> i64   { *self as i64   }\n-    #[inline(always)] pure fn to_int(&self)   -> int   { *self as int   }\n+    #[inline(always)] fn to_i8(&self)    -> i8    { *self as i8    }\n+    #[inline(always)] fn to_i16(&self)   -> i16   { *self as i16   }\n+    #[inline(always)] fn to_i32(&self)   -> i32   { *self as i32   }\n+    #[inline(always)] fn to_i64(&self)   -> i64   { *self as i64   }\n+    #[inline(always)] fn to_int(&self)   -> int   { *self as int   }\n \n-    #[inline(always)] pure fn to_f32(&self)   -> f32   { *self as f32   }\n-    #[inline(always)] pure fn to_f64(&self)   -> f64   { *self as f64   }\n-    #[inline(always)] pure fn to_float(&self) -> float { *self as float }\n+    #[inline(always)] fn to_f32(&self)   -> f32   { *self as f32   }\n+    #[inline(always)] fn to_f64(&self)   -> f64   { *self as f64   }\n+    #[inline(always)] fn to_float(&self) -> float { *self as float }\n }\n \n #[test]"}, {"sha": "7bef51489f22188f2e4e63b9011f23421111ec5d", "filename": "src/libcore/num/uint-template/u32.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/be9bddd46377bc982b73acf15a720365a54197a7/src%2Flibcore%2Fnum%2Fuint-template%2Fu32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be9bddd46377bc982b73acf15a720365a54197a7/src%2Flibcore%2Fnum%2Fuint-template%2Fu32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fuint-template%2Fu32.rs?ref=be9bddd46377bc982b73acf15a720365a54197a7", "patch": "@@ -24,23 +24,23 @@ impl NumCast for u32 {\n      * Cast `n` to a `u32`\n      */\n     #[inline(always)]\n-    pure fn from<N:NumCast>(n: N) -> u32 { n.to_u32() }\n+    fn from<N:NumCast>(n: N) -> u32 { n.to_u32() }\n \n-    #[inline(always)] pure fn to_u8(&self)    -> u8    { *self as u8    }\n-    #[inline(always)] pure fn to_u16(&self)   -> u16   { *self as u16   }\n-    #[inline(always)] pure fn to_u32(&self)   -> u32   { *self          }\n-    #[inline(always)] pure fn to_u64(&self)   -> u64   { *self as u64   }\n-    #[inline(always)] pure fn to_uint(&self)  -> uint  { *self as uint  }\n+    #[inline(always)] fn to_u8(&self)    -> u8    { *self as u8    }\n+    #[inline(always)] fn to_u16(&self)   -> u16   { *self as u16   }\n+    #[inline(always)] fn to_u32(&self)   -> u32   { *self          }\n+    #[inline(always)] fn to_u64(&self)   -> u64   { *self as u64   }\n+    #[inline(always)] fn to_uint(&self)  -> uint  { *self as uint  }\n \n-    #[inline(always)] pure fn to_i8(&self)    -> i8    { *self as i8    }\n-    #[inline(always)] pure fn to_i16(&self)   -> i16   { *self as i16   }\n-    #[inline(always)] pure fn to_i32(&self)   -> i32   { *self as i32   }\n-    #[inline(always)] pure fn to_i64(&self)   -> i64   { *self as i64   }\n-    #[inline(always)] pure fn to_int(&self)   -> int   { *self as int   }\n+    #[inline(always)] fn to_i8(&self)    -> i8    { *self as i8    }\n+    #[inline(always)] fn to_i16(&self)   -> i16   { *self as i16   }\n+    #[inline(always)] fn to_i32(&self)   -> i32   { *self as i32   }\n+    #[inline(always)] fn to_i64(&self)   -> i64   { *self as i64   }\n+    #[inline(always)] fn to_int(&self)   -> int   { *self as int   }\n \n-    #[inline(always)] pure fn to_f32(&self)   -> f32   { *self as f32   }\n-    #[inline(always)] pure fn to_f64(&self)   -> f64   { *self as f64   }\n-    #[inline(always)] pure fn to_float(&self) -> float { *self as float }\n+    #[inline(always)] fn to_f32(&self)   -> f32   { *self as f32   }\n+    #[inline(always)] fn to_f64(&self)   -> f64   { *self as f64   }\n+    #[inline(always)] fn to_float(&self) -> float { *self as float }\n }\n \n #[test]"}, {"sha": "fecafe37f3d935b93acfaaf050bbfe8228c802b6", "filename": "src/libcore/num/uint-template/u64.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/be9bddd46377bc982b73acf15a720365a54197a7/src%2Flibcore%2Fnum%2Fuint-template%2Fu64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be9bddd46377bc982b73acf15a720365a54197a7/src%2Flibcore%2Fnum%2Fuint-template%2Fu64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fuint-template%2Fu64.rs?ref=be9bddd46377bc982b73acf15a720365a54197a7", "patch": "@@ -24,23 +24,23 @@ impl NumCast for u64 {\n      * Cast `n` to a `u64`\n      */\n     #[inline(always)]\n-    pure fn from<N:NumCast>(n: N) -> u64 { n.to_u64() }\n+    fn from<N:NumCast>(n: N) -> u64 { n.to_u64() }\n \n-    #[inline(always)] pure fn to_u8(&self)    -> u8    { *self as u8    }\n-    #[inline(always)] pure fn to_u16(&self)   -> u16   { *self as u16   }\n-    #[inline(always)] pure fn to_u32(&self)   -> u32   { *self as u32   }\n-    #[inline(always)] pure fn to_u64(&self)   -> u64   { *self          }\n-    #[inline(always)] pure fn to_uint(&self)  -> uint  { *self as uint  }\n+    #[inline(always)] fn to_u8(&self)    -> u8    { *self as u8    }\n+    #[inline(always)] fn to_u16(&self)   -> u16   { *self as u16   }\n+    #[inline(always)] fn to_u32(&self)   -> u32   { *self as u32   }\n+    #[inline(always)] fn to_u64(&self)   -> u64   { *self          }\n+    #[inline(always)] fn to_uint(&self)  -> uint  { *self as uint  }\n \n-    #[inline(always)] pure fn to_i8(&self)    -> i8    { *self as i8    }\n-    #[inline(always)] pure fn to_i16(&self)   -> i16   { *self as i16   }\n-    #[inline(always)] pure fn to_i32(&self)   -> i32   { *self as i32   }\n-    #[inline(always)] pure fn to_i64(&self)   -> i64   { *self as i64   }\n-    #[inline(always)] pure fn to_int(&self)   -> int   { *self as int   }\n+    #[inline(always)] fn to_i8(&self)    -> i8    { *self as i8    }\n+    #[inline(always)] fn to_i16(&self)   -> i16   { *self as i16   }\n+    #[inline(always)] fn to_i32(&self)   -> i32   { *self as i32   }\n+    #[inline(always)] fn to_i64(&self)   -> i64   { *self as i64   }\n+    #[inline(always)] fn to_int(&self)   -> int   { *self as int   }\n \n-    #[inline(always)] pure fn to_f32(&self)   -> f32   { *self as f32   }\n-    #[inline(always)] pure fn to_f64(&self)   -> f64   { *self as f64   }\n-    #[inline(always)] pure fn to_float(&self) -> float { *self as float }\n+    #[inline(always)] fn to_f32(&self)   -> f32   { *self as f32   }\n+    #[inline(always)] fn to_f64(&self)   -> f64   { *self as f64   }\n+    #[inline(always)] fn to_float(&self) -> float { *self as float }\n }\n \n #[test]"}, {"sha": "0d48de67334a525fa9b9583ee1be60265aa641fd", "filename": "src/libcore/num/uint-template/u8.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/be9bddd46377bc982b73acf15a720365a54197a7/src%2Flibcore%2Fnum%2Fuint-template%2Fu8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be9bddd46377bc982b73acf15a720365a54197a7/src%2Flibcore%2Fnum%2Fuint-template%2Fu8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fuint-template%2Fu8.rs?ref=be9bddd46377bc982b73acf15a720365a54197a7", "patch": "@@ -23,31 +23,31 @@ mod inst {\n     // Type-specific functions here. These must be reexported by the\n     // parent module so that they appear in core::u8 and not core::u8::u8;\n \n-    pub pure fn is_ascii(x: T) -> bool { return 0 as T == x & 128 as T; }\n+    pub fn is_ascii(x: T) -> bool { return 0 as T == x & 128 as T; }\n }\n \n impl NumCast for u8 {\n     /**\n      * Cast `n` to a `u8`\n      */\n     #[inline(always)]\n-    pure fn from<N:NumCast>(n: N) -> u8 { n.to_u8() }\n+    fn from<N:NumCast>(n: N) -> u8 { n.to_u8() }\n \n-    #[inline(always)] pure fn to_u8(&self)    -> u8    { *self          }\n-    #[inline(always)] pure fn to_u16(&self)   -> u16   { *self as u16   }\n-    #[inline(always)] pure fn to_u32(&self)   -> u32   { *self as u32   }\n-    #[inline(always)] pure fn to_u64(&self)   -> u64   { *self as u64   }\n-    #[inline(always)] pure fn to_uint(&self)  -> uint  { *self as uint  }\n+    #[inline(always)] fn to_u8(&self)    -> u8    { *self          }\n+    #[inline(always)] fn to_u16(&self)   -> u16   { *self as u16   }\n+    #[inline(always)] fn to_u32(&self)   -> u32   { *self as u32   }\n+    #[inline(always)] fn to_u64(&self)   -> u64   { *self as u64   }\n+    #[inline(always)] fn to_uint(&self)  -> uint  { *self as uint  }\n \n-    #[inline(always)] pure fn to_i8(&self)    -> i8    { *self as i8    }\n-    #[inline(always)] pure fn to_i16(&self)   -> i16   { *self as i16   }\n-    #[inline(always)] pure fn to_i32(&self)   -> i32   { *self as i32   }\n-    #[inline(always)] pure fn to_i64(&self)   -> i64   { *self as i64   }\n-    #[inline(always)] pure fn to_int(&self)   -> int   { *self as int   }\n+    #[inline(always)] fn to_i8(&self)    -> i8    { *self as i8    }\n+    #[inline(always)] fn to_i16(&self)   -> i16   { *self as i16   }\n+    #[inline(always)] fn to_i32(&self)   -> i32   { *self as i32   }\n+    #[inline(always)] fn to_i64(&self)   -> i64   { *self as i64   }\n+    #[inline(always)] fn to_int(&self)   -> int   { *self as int   }\n \n-    #[inline(always)] pure fn to_f32(&self)   -> f32   { *self as f32   }\n-    #[inline(always)] pure fn to_f64(&self)   -> f64   { *self as f64   }\n-    #[inline(always)] pure fn to_float(&self) -> float { *self as float }\n+    #[inline(always)] fn to_f32(&self)   -> f32   { *self as f32   }\n+    #[inline(always)] fn to_f64(&self)   -> f64   { *self as f64   }\n+    #[inline(always)] fn to_float(&self) -> float { *self as float }\n }\n \n #[test]"}, {"sha": "f3f27a4e48ab65d44c9be730110c4592ebb5d422", "filename": "src/libcore/num/uint-template/uint.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/be9bddd46377bc982b73acf15a720365a54197a7/src%2Flibcore%2Fnum%2Fuint-template%2Fuint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be9bddd46377bc982b73acf15a720365a54197a7/src%2Flibcore%2Fnum%2Fuint-template%2Fuint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fuint-template%2Fuint.rs?ref=be9bddd46377bc982b73acf15a720365a54197a7", "patch": "@@ -45,7 +45,7 @@ pub mod inst {\n     *\n     * The smallest integer `q` such that `x/y <= q`.\n     */\n-    pub pure fn div_ceil(x: uint, y: uint) -> uint {\n+    pub fn div_ceil(x: uint, y: uint) -> uint {\n         let div = x / y;\n         if x % y == 0u { div }\n         else { div + 1u }\n@@ -63,7 +63,7 @@ pub mod inst {\n     *\n     * The integer `q` closest to `x/y`.\n     */\n-    pub pure fn div_round(x: uint, y: uint) -> uint {\n+    pub fn div_round(x: uint, y: uint) -> uint {\n         let div = x / y;\n         if x % y * 2u  < y { div }\n         else { div + 1u }\n@@ -84,7 +84,7 @@ pub mod inst {\n     * The smallest integer `q` such that `x/y <= q`. This\n     * is either `x/y` or `x/y + 1`.\n     */\n-    pub pure fn div_floor(x: uint, y: uint) -> uint { return x / y; }\n+    pub fn div_floor(x: uint, y: uint) -> uint { return x / y; }\n \n     /**\n     * Iterate over the range [`lo`..`hi`), or stop when requested\n@@ -101,7 +101,7 @@ pub mod inst {\n     * `true` If execution proceeded correctly, `false` if it was interrupted,\n     * that is if `it` returned `false` at any point.\n     */\n-    pub pure fn iterate(lo: uint, hi: uint, it: &fn(uint) -> bool) -> bool {\n+    pub fn iterate(lo: uint, hi: uint, it: &fn(uint) -> bool) -> bool {\n         let mut i = lo;\n         while i < hi {\n             if (!it(i)) { return false; }\n@@ -122,7 +122,7 @@ pub mod inst {\n         * use with integer literals of inferred integer-type as\n         * the self-value (eg. `for 100.times { ... }`).\n         */\n-        pure fn times(&self, it: &fn() -> bool) {\n+        fn times(&self, it: &fn() -> bool) {\n             let mut i = *self;\n             while i > 0 {\n                 if !it() { break }\n@@ -133,7 +133,7 @@ pub mod inst {\n \n     /// Returns the smallest power of 2 greater than or equal to `n`\n     #[inline(always)]\n-    pub pure fn next_power_of_two(n: uint) -> uint {\n+    pub fn next_power_of_two(n: uint) -> uint {\n         let halfbits: uint = sys::size_of::<uint>() * 4u;\n         let mut tmp: uint = n - 1u;\n         let mut shift: uint = 1u;\n@@ -215,23 +215,23 @@ impl NumCast for uint {\n      * Cast `n` to a `uint`\n      */\n     #[inline(always)]\n-    pure fn from<N:NumCast>(n: N) -> uint { n.to_uint() }\n+    fn from<N:NumCast>(n: N) -> uint { n.to_uint() }\n \n-    #[inline(always)] pure fn to_u8(&self)    -> u8    { *self as u8    }\n-    #[inline(always)] pure fn to_u16(&self)   -> u16   { *self as u16   }\n-    #[inline(always)] pure fn to_u32(&self)   -> u32   { *self as u32   }\n-    #[inline(always)] pure fn to_u64(&self)   -> u64   { *self as u64   }\n-    #[inline(always)] pure fn to_uint(&self)  -> uint  { *self          }\n+    #[inline(always)] fn to_u8(&self)    -> u8    { *self as u8    }\n+    #[inline(always)] fn to_u16(&self)   -> u16   { *self as u16   }\n+    #[inline(always)] fn to_u32(&self)   -> u32   { *self as u32   }\n+    #[inline(always)] fn to_u64(&self)   -> u64   { *self as u64   }\n+    #[inline(always)] fn to_uint(&self)  -> uint  { *self          }\n \n-    #[inline(always)] pure fn to_i8(&self)    -> i8    { *self as i8    }\n-    #[inline(always)] pure fn to_i16(&self)   -> i16   { *self as i16   }\n-    #[inline(always)] pure fn to_i32(&self)   -> i32   { *self as i32   }\n-    #[inline(always)] pure fn to_i64(&self)   -> i64   { *self as i64   }\n-    #[inline(always)] pure fn to_int(&self)   -> int   { *self as int   }\n+    #[inline(always)] fn to_i8(&self)    -> i8    { *self as i8    }\n+    #[inline(always)] fn to_i16(&self)   -> i16   { *self as i16   }\n+    #[inline(always)] fn to_i32(&self)   -> i32   { *self as i32   }\n+    #[inline(always)] fn to_i64(&self)   -> i64   { *self as i64   }\n+    #[inline(always)] fn to_int(&self)   -> int   { *self as int   }\n \n-    #[inline(always)] pure fn to_f32(&self)   -> f32   { *self as f32   }\n-    #[inline(always)] pure fn to_f64(&self)   -> f64   { *self as f64   }\n-    #[inline(always)] pure fn to_float(&self) -> float { *self as float }\n+    #[inline(always)] fn to_f32(&self)   -> f32   { *self as f32   }\n+    #[inline(always)] fn to_f64(&self)   -> f64   { *self as f64   }\n+    #[inline(always)] fn to_float(&self) -> float { *self as float }\n }\n \n #[test]"}, {"sha": "2f7fe1e4aa8bf519d004c543c0e75facdce0d632", "filename": "src/libcore/ops.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/be9bddd46377bc982b73acf15a720365a54197a7/src%2Flibcore%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be9bddd46377bc982b73acf15a720365a54197a7/src%2Flibcore%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops.rs?ref=be9bddd46377bc982b73acf15a720365a54197a7", "patch": "@@ -17,65 +17,65 @@ pub trait Drop {\n \n #[lang=\"add\"]\n pub trait Add<RHS,Result> {\n-    pure fn add(&self, rhs: &RHS) -> Result;\n+    fn add(&self, rhs: &RHS) -> Result;\n }\n \n #[lang=\"sub\"]\n pub trait Sub<RHS,Result> {\n-    pure fn sub(&self, rhs: &RHS) -> Result;\n+    fn sub(&self, rhs: &RHS) -> Result;\n }\n \n #[lang=\"mul\"]\n pub trait Mul<RHS,Result> {\n-    pure fn mul(&self, rhs: &RHS) -> Result;\n+    fn mul(&self, rhs: &RHS) -> Result;\n }\n \n #[lang=\"div\"]\n pub trait Div<RHS,Result> {\n-    pure fn div(&self, rhs: &RHS) -> Result;\n+    fn div(&self, rhs: &RHS) -> Result;\n }\n \n #[lang=\"modulo\"]\n pub trait Modulo<RHS,Result> {\n-    pure fn modulo(&self, rhs: &RHS) -> Result;\n+    fn modulo(&self, rhs: &RHS) -> Result;\n }\n \n #[lang=\"neg\"]\n pub trait Neg<Result> {\n-    pure fn neg(&self) -> Result;\n+    fn neg(&self) -> Result;\n }\n \n #[lang=\"not\"]\n pub trait Not<Result> {\n-    pure fn not(&self) -> Result;\n+    fn not(&self) -> Result;\n }\n \n #[lang=\"bitand\"]\n pub trait BitAnd<RHS,Result> {\n-    pure fn bitand(&self, rhs: &RHS) -> Result;\n+    fn bitand(&self, rhs: &RHS) -> Result;\n }\n \n #[lang=\"bitor\"]\n pub trait BitOr<RHS,Result> {\n-    pure fn bitor(&self, rhs: &RHS) -> Result;\n+    fn bitor(&self, rhs: &RHS) -> Result;\n }\n \n #[lang=\"bitxor\"]\n pub trait BitXor<RHS,Result> {\n-    pure fn bitxor(&self, rhs: &RHS) -> Result;\n+    fn bitxor(&self, rhs: &RHS) -> Result;\n }\n \n #[lang=\"shl\"]\n pub trait Shl<RHS,Result> {\n-    pure fn shl(&self, rhs: &RHS) -> Result;\n+    fn shl(&self, rhs: &RHS) -> Result;\n }\n \n #[lang=\"shr\"]\n pub trait Shr<RHS,Result> {\n-    pure fn shr(&self, rhs: &RHS) -> Result;\n+    fn shr(&self, rhs: &RHS) -> Result;\n }\n \n #[lang=\"index\"]\n pub trait Index<Index,Result> {\n-    pure fn index(&self, index: Index) -> Result;\n+    fn index(&self, index: Index) -> Result;\n }"}, {"sha": "dd92333b61dbe8051dff25b59137d9c23d0daa7b", "filename": "src/libcore/option.rs", "status": "modified", "additions": 38, "deletions": 38, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/be9bddd46377bc982b73acf15a720365a54197a7/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be9bddd46377bc982b73acf15a720365a54197a7/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=be9bddd46377bc982b73acf15a720365a54197a7", "patch": "@@ -59,7 +59,7 @@ pub enum Option<T> {\n }\n \n impl<T:Ord> Ord for Option<T> {\n-    pure fn lt(&self, other: &Option<T>) -> bool {\n+    fn lt(&self, other: &Option<T>) -> bool {\n         match (self, other) {\n             (&None, &None) => false,\n             (&None, &Some(_)) => true,\n@@ -68,7 +68,7 @@ impl<T:Ord> Ord for Option<T> {\n         }\n     }\n \n-    pure fn le(&self, other: &Option<T>) -> bool {\n+    fn le(&self, other: &Option<T>) -> bool {\n         match (self, other) {\n             (&None, &None) => true,\n             (&None, &Some(_)) => true,\n@@ -77,18 +77,18 @@ impl<T:Ord> Ord for Option<T> {\n         }\n     }\n \n-    pure fn ge(&self, other: &Option<T>) -> bool {\n+    fn ge(&self, other: &Option<T>) -> bool {\n         ! (self < other)\n     }\n \n-    pure fn gt(&self, other: &Option<T>) -> bool {\n+    fn gt(&self, other: &Option<T>) -> bool {\n         ! (self <= other)\n     }\n }\n \n impl<T: Copy + Add<T,T>> Add<Option<T>, Option<T>> for Option<T> {\n     #[inline(always)]\n-    pure fn add(&self, other: &Option<T>) -> Option<T> {\n+    fn add(&self, other: &Option<T>) -> Option<T> {\n         match (*self, *other) {\n             (None, None) => None,\n             (_, None) => *self,\n@@ -99,7 +99,7 @@ impl<T: Copy + Add<T,T>> Add<Option<T>, Option<T>> for Option<T> {\n }\n \n #[inline(always)]\n-pub pure fn get<T:Copy>(opt: Option<T>) -> T {\n+pub fn get<T:Copy>(opt: Option<T>) -> T {\n     /*!\n     Gets the value out of an option\n \n@@ -122,7 +122,7 @@ pub pure fn get<T:Copy>(opt: Option<T>) -> T {\n }\n \n #[inline(always)]\n-pub pure fn get_ref<T>(opt: &'r Option<T>) -> &'r T {\n+pub fn get_ref<T>(opt: &'r Option<T>) -> &'r T {\n     /*!\n     Gets an immutable reference to the value inside an option.\n \n@@ -143,7 +143,7 @@ pub pure fn get_ref<T>(opt: &'r Option<T>) -> &'r T {\n     }\n }\n \n-pub pure fn get_mut_ref<T>(opt: &'r mut Option<T>) -> &'r mut T {\n+pub fn get_mut_ref<T>(opt: &'r mut Option<T>) -> &'r mut T {\n     /*!\n     Gets a mutable reference to the value inside an option.\n \n@@ -165,14 +165,14 @@ pub pure fn get_mut_ref<T>(opt: &'r mut Option<T>) -> &'r mut T {\n }\n \n #[inline(always)]\n-pub pure fn map<T, U>(opt: &'r Option<T>, f: &fn(x: &'r T) -> U) -> Option<U> {\n+pub fn map<T, U>(opt: &'r Option<T>, f: &fn(x: &'r T) -> U) -> Option<U> {\n     //! Maps a `some` value by reference from one type to another\n \n     match *opt { Some(ref x) => Some(f(x)), None => None }\n }\n \n #[inline(always)]\n-pub pure fn map_consume<T, U>(opt: Option<T>,\n+pub fn map_consume<T, U>(opt: Option<T>,\n                               f: &fn(v: T) -> U) -> Option<U> {\n     /*!\n      * As `map`, but consumes the option and gives `f` ownership to avoid\n@@ -182,7 +182,7 @@ pub pure fn map_consume<T, U>(opt: Option<T>,\n }\n \n #[inline(always)]\n-pub pure fn chain<T, U>(opt: Option<T>,\n+pub fn chain<T, U>(opt: Option<T>,\n                         f: &fn(t: T) -> Option<U>) -> Option<U> {\n     /*!\n      * Update an optional value by optionally running its content through a\n@@ -196,7 +196,7 @@ pub pure fn chain<T, U>(opt: Option<T>,\n }\n \n #[inline(always)]\n-pub pure fn chain_ref<T, U>(opt: &Option<T>,\n+pub fn chain_ref<T, U>(opt: &Option<T>,\n                             f: &fn(x: &T) -> Option<U>) -> Option<U> {\n     /*!\n      * Update an optional value by optionally running its content by reference\n@@ -207,7 +207,7 @@ pub pure fn chain_ref<T, U>(opt: &Option<T>,\n }\n \n #[inline(always)]\n-pub pure fn or<T>(opta: Option<T>, optb: Option<T>) -> Option<T> {\n+pub fn or<T>(opta: Option<T>, optb: Option<T>) -> Option<T> {\n     /*!\n      * Returns the leftmost Some() value, or None if both are None.\n      */\n@@ -218,7 +218,7 @@ pub pure fn or<T>(opta: Option<T>, optb: Option<T>) -> Option<T> {\n }\n \n #[inline(always)]\n-pub pure fn while_some<T>(x: Option<T>, blk: &fn(v: T) -> Option<T>) {\n+pub fn while_some<T>(x: Option<T>, blk: &fn(v: T) -> Option<T>) {\n     //! Applies a function zero or more times until the result is none.\n \n     let mut opt = x;\n@@ -228,43 +228,43 @@ pub pure fn while_some<T>(x: Option<T>, blk: &fn(v: T) -> Option<T>) {\n }\n \n #[inline(always)]\n-pub pure fn is_none<T>(opt: &const Option<T>) -> bool {\n+pub fn is_none<T>(opt: &const Option<T>) -> bool {\n     //! Returns true if the option equals `none`\n \n     match *opt { None => true, Some(_) => false }\n }\n \n #[inline(always)]\n-pub pure fn is_some<T>(opt: &const Option<T>) -> bool {\n+pub fn is_some<T>(opt: &const Option<T>) -> bool {\n     //! Returns true if the option contains some value\n \n     !is_none(opt)\n }\n \n #[inline(always)]\n-pub pure fn get_or_zero<T:Copy + Zero>(opt: Option<T>) -> T {\n+pub fn get_or_zero<T:Copy + Zero>(opt: Option<T>) -> T {\n     //! Returns the contained value or zero (for this type)\n \n     match opt { Some(copy x) => x, None => Zero::zero() }\n }\n \n #[inline(always)]\n-pub pure fn get_or_default<T:Copy>(opt: Option<T>, def: T) -> T {\n+pub fn get_or_default<T:Copy>(opt: Option<T>, def: T) -> T {\n     //! Returns the contained value or a default\n \n     match opt { Some(copy x) => x, None => def }\n }\n \n #[inline(always)]\n-pub pure fn map_default<T, U>(opt: &'r Option<T>, def: U,\n+pub fn map_default<T, U>(opt: &'r Option<T>, def: U,\n                               f: &fn(&'r T) -> U) -> U {\n     //! Applies a function to the contained value or returns a default\n \n     match *opt { None => def, Some(ref t) => f(t) }\n }\n \n #[inline(always)]\n-pub pure fn unwrap<T>(opt: Option<T>) -> T {\n+pub fn unwrap<T>(opt: Option<T>) -> T {\n     /*!\n     Moves a value out of an option type and returns it.\n \n@@ -302,7 +302,7 @@ pub fn swap_unwrap<T>(opt: &mut Option<T>) -> T {\n }\n \n #[inline(always)]\n-pub pure fn expect<T>(opt: Option<T>, reason: &str) -> T {\n+pub fn expect<T>(opt: Option<T>, reason: &str) -> T {\n     //! As unwrap, but with a specified failure message.\n     match opt {\n         Some(val) => val,\n@@ -313,12 +313,12 @@ pub pure fn expect<T>(opt: Option<T>, reason: &str) -> T {\n impl<T> BaseIter<T> for Option<T> {\n     /// Performs an operation on the contained value by reference\n     #[inline(always)]\n-    pure fn each(&self, f: &fn(x: &'self T) -> bool) {\n+    fn each(&self, f: &fn(x: &'self T) -> bool) {\n         match *self { None => (), Some(ref t) => { f(t); } }\n     }\n \n     #[inline(always)]\n-    pure fn size_hint(&self) -> Option<uint> {\n+    fn size_hint(&self) -> Option<uint> {\n         if self.is_some() { Some(1) } else { Some(0) }\n     }\n }\n@@ -333,42 +333,42 @@ impl<T> MutableIter<T> for Option<T> {\n pub impl<T> Option<T> {\n     /// Returns true if the option equals `none`\n     #[inline(always)]\n-    pure fn is_none(&const self) -> bool { is_none(self) }\n+    fn is_none(&const self) -> bool { is_none(self) }\n \n     /// Returns true if the option contains some value\n     #[inline(always)]\n-    pure fn is_some(&const self) -> bool { is_some(self) }\n+    fn is_some(&const self) -> bool { is_some(self) }\n \n     /**\n      * Update an optional value by optionally running its content by reference\n      * through a function that returns an option.\n      */\n     #[inline(always)]\n-    pure fn chain_ref<U>(&self, f: &fn(x: &T) -> Option<U>) -> Option<U> {\n+    fn chain_ref<U>(&self, f: &fn(x: &T) -> Option<U>) -> Option<U> {\n         chain_ref(self, f)\n     }\n \n     /// Maps a `some` value from one type to another by reference\n     #[inline(always)]\n-    pure fn map<U>(&self, f: &fn(&'self T) -> U) -> Option<U> { map(self, f) }\n+    fn map<U>(&self, f: &fn(&'self T) -> U) -> Option<U> { map(self, f) }\n \n     /// As `map`, but consumes the option and gives `f` ownership to avoid\n     /// copying.\n     #[inline(always)]\n-    pure fn map_consume<U>(self, f: &fn(v: T) -> U) -> Option<U> {\n+    fn map_consume<U>(self, f: &fn(v: T) -> U) -> Option<U> {\n         map_consume(self, f)\n     }\n \n     /// Applies a function to the contained value or returns a default\n     #[inline(always)]\n-    pure fn map_default<U>(&self, def: U, f: &fn(&'self T) -> U) -> U {\n+    fn map_default<U>(&self, def: U, f: &fn(&'self T) -> U) -> U {\n         map_default(self, def, f)\n     }\n \n     /// As `map_default`, but consumes the option and gives `f`\n     /// ownership to avoid copying.\n     #[inline(always)]\n-    pure fn map_consume_default<U>(self, def: U, f: &fn(v: T) -> U) -> U {\n+    fn map_consume_default<U>(self, def: U, f: &fn(v: T) -> U) -> U {\n         match self { None => def, Some(v) => f(v) }\n     }\n \n@@ -403,7 +403,7 @@ pub impl<T> Option<T> {\n     case explicitly.\n      */\n     #[inline(always)]\n-    pure fn get_ref(&self) -> &'self T { get_ref(self) }\n+    fn get_ref(&self) -> &'self T { get_ref(self) }\n \n     /**\n     Gets a mutable reference to the value inside an option.\n@@ -420,7 +420,7 @@ pub impl<T> Option<T> {\n     case explicitly.\n      */\n     #[inline(always)]\n-    pure fn get_mut_ref(&mut self) -> &'self mut T { get_mut_ref(self) }\n+    fn get_mut_ref(&mut self) -> &'self mut T { get_mut_ref(self) }\n \n     /**\n      * Gets the value out of an option without copying.\n@@ -430,7 +430,7 @@ pub impl<T> Option<T> {\n      * Fails if the value equals `none`\n      */\n     #[inline(always)]\n-    pure fn unwrap(self) -> T { unwrap(self) }\n+    fn unwrap(self) -> T { unwrap(self) }\n \n     /**\n      * The option dance. Moves a value out of an option type and returns it,\n@@ -452,7 +452,7 @@ pub impl<T> Option<T> {\n      * Fails if the value equals `none`\n      */\n     #[inline(always)]\n-    pure fn expect(self, reason: &str) -> T { expect(self, reason) }\n+    fn expect(self, reason: &str) -> T { expect(self, reason) }\n }\n \n pub impl<T:Copy> Option<T> {\n@@ -471,21 +471,21 @@ pub impl<T:Copy> Option<T> {\n     case explicitly.\n     */\n     #[inline(always)]\n-    pure fn get(self) -> T { get(self) }\n+    fn get(self) -> T { get(self) }\n \n     #[inline(always)]\n-    pure fn get_or_default(self, def: T) -> T { get_or_default(self, def) }\n+    fn get_or_default(self, def: T) -> T { get_or_default(self, def) }\n \n     /// Applies a function zero or more times until the result is none.\n     #[inline(always)]\n-    pure fn while_some(self, blk: &fn(v: T) -> Option<T>) {\n+    fn while_some(self, blk: &fn(v: T) -> Option<T>) {\n         while_some(self, blk)\n     }\n }\n \n pub impl<T:Copy + Zero> Option<T> {\n     #[inline(always)]\n-    pure fn get_or_zero(self) -> T { get_or_zero(self) }\n+    fn get_or_zero(self) -> T { get_or_zero(self) }\n }\n \n #[test]"}, {"sha": "c483ec79e21d99e71a114daeb0330c36b319b2f9", "filename": "src/libcore/owned.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/be9bddd46377bc982b73acf15a720365a54197a7/src%2Flibcore%2Fowned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be9bddd46377bc982b73acf15a720365a54197a7/src%2Flibcore%2Fowned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fowned.rs?ref=be9bddd46377bc982b73acf15a720365a54197a7", "patch": "@@ -15,20 +15,20 @@\n #[cfg(notest)]\n impl<T:Eq> Eq for ~T {\n     #[inline(always)]\n-    pure fn eq(&self, other: &~T) -> bool { *(*self) == *(*other) }\n+    fn eq(&self, other: &~T) -> bool { *(*self) == *(*other) }\n     #[inline(always)]\n-    pure fn ne(&self, other: &~T) -> bool { *(*self) != *(*other) }\n+    fn ne(&self, other: &~T) -> bool { *(*self) != *(*other) }\n }\n \n #[cfg(notest)]\n impl<T:Ord> Ord for ~T {\n     #[inline(always)]\n-    pure fn lt(&self, other: &~T) -> bool { *(*self) < *(*other) }\n+    fn lt(&self, other: &~T) -> bool { *(*self) < *(*other) }\n     #[inline(always)]\n-    pure fn le(&self, other: &~T) -> bool { *(*self) <= *(*other) }\n+    fn le(&self, other: &~T) -> bool { *(*self) <= *(*other) }\n     #[inline(always)]\n-    pure fn ge(&self, other: &~T) -> bool { *(*self) >= *(*other) }\n+    fn ge(&self, other: &~T) -> bool { *(*self) >= *(*other) }\n     #[inline(always)]\n-    pure fn gt(&self, other: &~T) -> bool { *(*self) > *(*other) }\n+    fn gt(&self, other: &~T) -> bool { *(*self) > *(*other) }\n }\n "}, {"sha": "5181c08bba0fce2782c6ff016ad1cef5c70c46a0", "filename": "src/libcore/path.rs", "status": "modified", "additions": 64, "deletions": 64, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/be9bddd46377bc982b73acf15a720365a54197a7/src%2Flibcore%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be9bddd46377bc982b73acf15a720365a54197a7/src%2Flibcore%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpath.rs?ref=be9bddd46377bc982b73acf15a720365a54197a7", "patch": "@@ -28,7 +28,7 @@ pub struct WindowsPath {\n     components: ~[~str],\n }\n \n-pub pure fn WindowsPath(s: &str) -> WindowsPath {\n+pub fn WindowsPath(s: &str) -> WindowsPath {\n     GenericPath::from_str(s)\n }\n \n@@ -38,50 +38,50 @@ pub struct PosixPath {\n     components: ~[~str],\n }\n \n-pub pure fn PosixPath(s: &str) -> PosixPath {\n+pub fn PosixPath(s: &str) -> PosixPath {\n     GenericPath::from_str(s)\n }\n \n pub trait GenericPath {\n-    pure fn from_str(&str) -> Self;\n+    fn from_str(&str) -> Self;\n \n-    pure fn dirname(&self) -> ~str;\n-    pure fn filename(&self) -> Option<~str>;\n-    pure fn filestem(&self) -> Option<~str>;\n-    pure fn filetype(&self) -> Option<~str>;\n+    fn dirname(&self) -> ~str;\n+    fn filename(&self) -> Option<~str>;\n+    fn filestem(&self) -> Option<~str>;\n+    fn filetype(&self) -> Option<~str>;\n \n-    pure fn with_dirname(&self, (&str)) -> Self;\n-    pure fn with_filename(&self, (&str)) -> Self;\n-    pure fn with_filestem(&self, (&str)) -> Self;\n-    pure fn with_filetype(&self, (&str)) -> Self;\n+    fn with_dirname(&self, (&str)) -> Self;\n+    fn with_filename(&self, (&str)) -> Self;\n+    fn with_filestem(&self, (&str)) -> Self;\n+    fn with_filetype(&self, (&str)) -> Self;\n \n-    pure fn dir_path(&self) -> Self;\n-    pure fn file_path(&self) -> Self;\n+    fn dir_path(&self) -> Self;\n+    fn file_path(&self) -> Self;\n \n-    pure fn push(&self, (&str)) -> Self;\n-    pure fn push_rel(&self, (&Self)) -> Self;\n-    pure fn push_many(&self, (&[~str])) -> Self;\n-    pure fn pop(&self) -> Self;\n+    fn push(&self, (&str)) -> Self;\n+    fn push_rel(&self, (&Self)) -> Self;\n+    fn push_many(&self, (&[~str])) -> Self;\n+    fn pop(&self) -> Self;\n \n-    pure fn unsafe_join(&self, (&Self)) -> Self;\n-    pure fn is_restricted(&self) -> bool;\n+    fn unsafe_join(&self, (&Self)) -> Self;\n+    fn is_restricted(&self) -> bool;\n \n-    pure fn normalize(&self) -> Self;\n+    fn normalize(&self) -> Self;\n }\n \n #[cfg(windows)]\n pub type Path = WindowsPath;\n \n #[cfg(windows)]\n-pub pure fn Path(s: &str) -> Path {\n+pub fn Path(s: &str) -> Path {\n     WindowsPath(s)\n }\n \n #[cfg(unix)]\n pub type Path = PosixPath;\n \n #[cfg(unix)]\n-pub pure fn Path(s: &str) -> Path {\n+pub fn Path(s: &str) -> Path {\n     PosixPath(s)\n }\n \n@@ -367,7 +367,7 @@ pub impl Path {\n }\n \n impl ToStr for PosixPath {\n-    pure fn to_str(&self) -> ~str {\n+    fn to_str(&self) -> ~str {\n         let mut s = ~\"\";\n         if self.is_absolute {\n             s += \"/\";\n@@ -380,14 +380,14 @@ impl ToStr for PosixPath {\n // PosixPath and WindowsPath, most of their methods are common.\n impl GenericPath for PosixPath {\n \n-    pure fn from_str(s: &str) -> PosixPath {\n+    fn from_str(s: &str) -> PosixPath {\n         let mut components = str::split_nonempty(s, |c| c == '/');\n         let is_absolute = (s.len() != 0 && s[0] == '/' as u8);\n         return PosixPath { is_absolute: is_absolute,\n                            components: components }\n     }\n \n-    pure fn dirname(&self) -> ~str {\n+    fn dirname(&self) -> ~str {\n         unsafe {\n             let s = self.dir_path().to_str();\n             if s.len() == 0 {\n@@ -398,14 +398,14 @@ impl GenericPath for PosixPath {\n         }\n     }\n \n-    pure fn filename(&self) -> Option<~str> {\n+    fn filename(&self) -> Option<~str> {\n         match self.components.len() {\n           0 => None,\n           n => Some(copy self.components[n - 1])\n         }\n     }\n \n-    pure fn filestem(&self) -> Option<~str> {\n+    fn filestem(&self) -> Option<~str> {\n         match self.filename() {\n           None => None,\n           Some(ref f) => {\n@@ -417,7 +417,7 @@ impl GenericPath for PosixPath {\n         }\n     }\n \n-    pure fn filetype(&self) -> Option<~str> {\n+    fn filetype(&self) -> Option<~str> {\n         match self.filename() {\n           None => None,\n           Some(ref f) => {\n@@ -429,29 +429,29 @@ impl GenericPath for PosixPath {\n         }\n     }\n \n-    pure fn with_dirname(&self, d: &str) -> PosixPath {\n+    fn with_dirname(&self, d: &str) -> PosixPath {\n         let dpath = PosixPath(d);\n         match self.filename() {\n           Some(ref f) => dpath.push(*f),\n           None => dpath\n         }\n     }\n \n-    pure fn with_filename(&self, f: &str) -> PosixPath {\n+    fn with_filename(&self, f: &str) -> PosixPath {\n         unsafe {\n             fail_unless!(! str::any(f, |c| windows::is_sep(c as u8)));\n             self.dir_path().push(f)\n         }\n     }\n \n-    pure fn with_filestem(&self, s: &str) -> PosixPath {\n+    fn with_filestem(&self, s: &str) -> PosixPath {\n         match self.filetype() {\n           None => self.with_filename(s),\n           Some(ref t) => self.with_filename(str::from_slice(s) + *t)\n         }\n     }\n \n-    pure fn with_filetype(&self, t: &str) -> PosixPath {\n+    fn with_filetype(&self, t: &str) -> PosixPath {\n         if t.len() == 0 {\n             match self.filestem() {\n               None => copy *self,\n@@ -466,15 +466,15 @@ impl GenericPath for PosixPath {\n         }\n     }\n \n-    pure fn dir_path(&self) -> PosixPath {\n+    fn dir_path(&self) -> PosixPath {\n         if self.components.len() != 0 {\n             self.pop()\n         } else {\n             copy *self\n         }\n     }\n \n-    pure fn file_path(&self) -> PosixPath {\n+    fn file_path(&self) -> PosixPath {\n         let cs = match self.filename() {\n           None => ~[],\n           Some(ref f) => ~[copy *f]\n@@ -483,12 +483,12 @@ impl GenericPath for PosixPath {\n                            components: cs }\n     }\n \n-    pure fn push_rel(&self, other: &PosixPath) -> PosixPath {\n+    fn push_rel(&self, other: &PosixPath) -> PosixPath {\n         fail_unless!(!other.is_absolute);\n         self.push_many(other.components)\n     }\n \n-    pure fn unsafe_join(&self, other: &PosixPath) -> PosixPath {\n+    fn unsafe_join(&self, other: &PosixPath) -> PosixPath {\n         if other.is_absolute {\n             PosixPath { is_absolute: true,\n                         components: copy other.components }\n@@ -497,11 +497,11 @@ impl GenericPath for PosixPath {\n         }\n     }\n \n-    pure fn is_restricted(&self) -> bool {\n+    fn is_restricted(&self) -> bool {\n         false\n     }\n \n-    pure fn push_many(&self, cs: &[~str]) -> PosixPath {\n+    fn push_many(&self, cs: &[~str]) -> PosixPath {\n         let mut v = copy self.components;\n         for cs.each |e| {\n             let mut ss = str::split_nonempty(\n@@ -513,14 +513,14 @@ impl GenericPath for PosixPath {\n                     components: v }\n     }\n \n-    pure fn push(&self, s: &str) -> PosixPath {\n+    fn push(&self, s: &str) -> PosixPath {\n         let mut v = copy self.components;\n         let mut ss = str::split_nonempty(s, |c| windows::is_sep(c as u8));\n         unsafe { v.push_all_move(ss); }\n         PosixPath { components: v, ..copy *self }\n     }\n \n-    pure fn pop(&self) -> PosixPath {\n+    fn pop(&self) -> PosixPath {\n         let mut cs = copy self.components;\n         if cs.len() != 0 {\n             unsafe { cs.pop(); }\n@@ -532,7 +532,7 @@ impl GenericPath for PosixPath {\n                           //..self }\n     }\n \n-    pure fn normalize(&self) -> PosixPath {\n+    fn normalize(&self) -> PosixPath {\n         return PosixPath {\n             is_absolute: self.is_absolute,\n             components: normalize(self.components)\n@@ -543,7 +543,7 @@ impl GenericPath for PosixPath {\n \n \n impl ToStr for WindowsPath {\n-    pure fn to_str(&self) -> ~str {\n+    fn to_str(&self) -> ~str {\n         let mut s = ~\"\";\n         match self.host {\n           Some(ref h) => { s += \"\\\\\\\\\"; s += *h; }\n@@ -563,7 +563,7 @@ impl ToStr for WindowsPath {\n \n impl GenericPath for WindowsPath {\n \n-    pure fn from_str(s: &str) -> WindowsPath {\n+    fn from_str(s: &str) -> WindowsPath {\n         let host;\n         let device;\n         let rest;\n@@ -599,7 +599,7 @@ impl GenericPath for WindowsPath {\n                              components: components }\n     }\n \n-    pure fn dirname(&self) -> ~str {\n+    fn dirname(&self) -> ~str {\n         unsafe {\n             let s = self.dir_path().to_str();\n             if s.len() == 0 {\n@@ -610,14 +610,14 @@ impl GenericPath for WindowsPath {\n         }\n     }\n \n-    pure fn filename(&self) -> Option<~str> {\n+    fn filename(&self) -> Option<~str> {\n         match self.components.len() {\n           0 => None,\n           n => Some(copy self.components[n - 1])\n         }\n     }\n \n-    pure fn filestem(&self) -> Option<~str> {\n+    fn filestem(&self) -> Option<~str> {\n         match self.filename() {\n           None => None,\n           Some(ref f) => {\n@@ -629,7 +629,7 @@ impl GenericPath for WindowsPath {\n         }\n     }\n \n-    pure fn filetype(&self) -> Option<~str> {\n+    fn filetype(&self) -> Option<~str> {\n         match self.filename() {\n           None => None,\n           Some(ref f) => {\n@@ -641,27 +641,27 @@ impl GenericPath for WindowsPath {\n         }\n     }\n \n-    pure fn with_dirname(&self, d: &str) -> WindowsPath {\n+    fn with_dirname(&self, d: &str) -> WindowsPath {\n         let dpath = WindowsPath(d);\n         match self.filename() {\n           Some(ref f) => dpath.push(*f),\n           None => dpath\n         }\n     }\n \n-    pure fn with_filename(&self, f: &str) -> WindowsPath {\n+    fn with_filename(&self, f: &str) -> WindowsPath {\n         fail_unless!(! str::any(f, |c| windows::is_sep(c as u8)));\n         self.dir_path().push(f)\n     }\n \n-    pure fn with_filestem(&self, s: &str) -> WindowsPath {\n+    fn with_filestem(&self, s: &str) -> WindowsPath {\n         match self.filetype() {\n           None => self.with_filename(s),\n           Some(ref t) => self.with_filename(str::from_slice(s) + *t)\n         }\n     }\n \n-    pure fn with_filetype(&self, t: &str) -> WindowsPath {\n+    fn with_filetype(&self, t: &str) -> WindowsPath {\n         if t.len() == 0 {\n             match self.filestem() {\n               None => copy *self,\n@@ -677,15 +677,15 @@ impl GenericPath for WindowsPath {\n         }\n     }\n \n-    pure fn dir_path(&self) -> WindowsPath {\n+    fn dir_path(&self) -> WindowsPath {\n         if self.components.len() != 0 {\n             self.pop()\n         } else {\n             copy *self\n         }\n     }\n \n-    pure fn file_path(&self) -> WindowsPath {\n+    fn file_path(&self) -> WindowsPath {\n         let cs = match self.filename() {\n           None => ~[],\n           Some(ref f) => ~[copy *f]\n@@ -696,12 +696,12 @@ impl GenericPath for WindowsPath {\n                              components: cs }\n     }\n \n-    pure fn push_rel(&self, other: &WindowsPath) -> WindowsPath {\n+    fn push_rel(&self, other: &WindowsPath) -> WindowsPath {\n         fail_unless!(!other.is_absolute);\n         self.push_many(other.components)\n     }\n \n-    pure fn unsafe_join(&self, other: &WindowsPath) -> WindowsPath {\n+    fn unsafe_join(&self, other: &WindowsPath) -> WindowsPath {\n         /* rhs not absolute is simple push */\n         if !other.is_absolute {\n             return self.push_many(other.components);\n@@ -743,7 +743,7 @@ impl GenericPath for WindowsPath {\n         }\n     }\n \n-    pure fn is_restricted(&self) -> bool {\n+    fn is_restricted(&self) -> bool {\n         match self.filestem() {\n             Some(stem) => {\n                 match stem.to_lower() {\n@@ -756,7 +756,7 @@ impl GenericPath for WindowsPath {\n         }\n     }\n \n-    pure fn push_many(&self, cs: &[~str]) -> WindowsPath {\n+    fn push_many(&self, cs: &[~str]) -> WindowsPath {\n         let mut v = copy self.components;\n         for cs.each |e| {\n             let mut ss = str::split_nonempty(\n@@ -773,14 +773,14 @@ impl GenericPath for WindowsPath {\n         }\n     }\n \n-    pure fn push(&self, s: &str) -> WindowsPath {\n+    fn push(&self, s: &str) -> WindowsPath {\n         let mut v = copy self.components;\n         let mut ss = str::split_nonempty(s, |c| windows::is_sep(c as u8));\n         unsafe { v.push_all_move(ss); }\n         return WindowsPath { components: v, ..copy *self }\n     }\n \n-    pure fn pop(&self) -> WindowsPath {\n+    fn pop(&self) -> WindowsPath {\n         let mut cs = copy self.components;\n         if cs.len() != 0 {\n             unsafe { cs.pop(); }\n@@ -793,7 +793,7 @@ impl GenericPath for WindowsPath {\n         }\n     }\n \n-    pure fn normalize(&self) -> WindowsPath {\n+    fn normalize(&self) -> WindowsPath {\n         return WindowsPath {\n             host: copy self.host,\n             device: match self.device {\n@@ -807,7 +807,7 @@ impl GenericPath for WindowsPath {\n }\n \n \n-pub pure fn normalize(components: &[~str]) -> ~[~str] {\n+pub fn normalize(components: &[~str]) -> ~[~str] {\n     let mut cs = ~[];\n     unsafe {\n         for components.each |c| {\n@@ -831,11 +831,11 @@ pub mod windows {\n     use option::{None, Option, Some};\n \n     #[inline(always)]\n-    pub pure fn is_sep(u: u8) -> bool {\n+    pub fn is_sep(u: u8) -> bool {\n         u == '/' as u8 || u == '\\\\' as u8\n     }\n \n-    pub pure fn extract_unc_prefix(s: &str) -> Option<(~str,~str)> {\n+    pub fn extract_unc_prefix(s: &str) -> Option<(~str,~str)> {\n         if (s.len() > 1 &&\n             (s[0] == '\\\\' as u8 || s[0] == '/' as u8) &&\n             s[0] == s[1]) {\n@@ -852,7 +852,7 @@ pub mod windows {\n         None\n     }\n \n-    pub pure fn extract_drive_prefix(s: &str) -> Option<(~str,~str)> {\n+    pub fn extract_drive_prefix(s: &str) -> Option<(~str,~str)> {\n         unsafe {\n             if (s.len() > 1 &&\n                 libc::isalpha(s[0] as libc::c_int) != 0 &&"}, {"sha": "710f2c51ee8c73dbae149d5225fb5db06016a4d3", "filename": "src/libcore/pipes.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/be9bddd46377bc982b73acf15a720365a54197a7/src%2Flibcore%2Fpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be9bddd46377bc982b73acf15a720365a54197a7/src%2Flibcore%2Fpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpipes.rs?ref=be9bddd46377bc982b73acf15a720365a54197a7", "patch": "@@ -111,10 +111,10 @@ enum State {\n }\n \n impl Eq for State {\n-    pure fn eq(&self, other: &State) -> bool {\n+    fn eq(&self, other: &State) -> bool {\n         ((*self) as uint) == ((*other) as uint)\n     }\n-    pure fn ne(&self, other: &State) -> bool { !(*self).eq(other) }\n+    fn ne(&self, other: &State) -> bool { !(*self).eq(other) }\n }\n \n pub struct BufferHeader {\n@@ -551,7 +551,7 @@ pub fn try_recv<T:Owned,Tbuffer:Owned>(p: RecvPacketBuffered<T, Tbuffer>)\n }\n \n /// Returns true if messages are available.\n-pub pure fn peek<T:Owned,Tb:Owned>(p: &RecvPacketBuffered<T, Tb>) -> bool {\n+pub fn peek<T:Owned,Tb:Owned>(p: &RecvPacketBuffered<T, Tb>) -> bool {\n     match unsafe {(*p.header()).state} {\n       Empty | Terminated => false,\n       Blocked => fail!(~\"peeking on blocked packet\"),\n@@ -723,11 +723,11 @@ pub fn select2<A:Owned,Ab:Owned,B:Owned,Bb:Owned>(\n \n #[doc(hidden)]\n pub trait Selectable {\n-    pure fn header(&self) -> *PacketHeader;\n+    fn header(&self) -> *PacketHeader;\n }\n \n impl Selectable for *PacketHeader {\n-    pure fn header(&self) -> *PacketHeader { *self }\n+    fn header(&self) -> *PacketHeader { *self }\n }\n \n /// Returns the index of an endpoint that is ready to receive.\n@@ -812,7 +812,7 @@ pub impl<T,Tbuffer> SendPacketBuffered<T,Tbuffer> {\n         option::unwrap(p)\n     }\n \n-    pure fn header(&self) -> *PacketHeader {\n+    fn header(&self) -> *PacketHeader {\n         match self.p {\n           Some(packet) => unsafe {\n             let packet = &*packet;\n@@ -879,7 +879,7 @@ pub impl<T:Owned,Tbuffer:Owned> RecvPacketBuffered<T, Tbuffer> {\n }\n \n impl<T:Owned,Tbuffer:Owned> Selectable for RecvPacketBuffered<T, Tbuffer> {\n-    pure fn header(&self) -> *PacketHeader {\n+    fn header(&self) -> *PacketHeader {\n         match self.p {\n           Some(packet) => unsafe {\n             let packet = &*packet;"}, {"sha": "fa96467cb0f674642c6cf969b7024166b67e1918", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 34, "deletions": 34, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/be9bddd46377bc982b73acf15a720365a54197a7/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be9bddd46377bc982b73acf15a720365a54197a7/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=be9bddd46377bc982b73acf15a720365a54197a7", "patch": "@@ -51,27 +51,27 @@ pub mod rusti {\n \n /// Get an unsafe pointer to a value\n #[inline(always)]\n-pub pure fn addr_of<T>(val: &T) -> *T { unsafe { rusti::addr_of(*val) } }\n+pub fn addr_of<T>(val: &T) -> *T { unsafe { rusti::addr_of(*val) } }\n \n /// Calculate the offset from a pointer\n #[inline(always)]\n-pub pure fn offset<T>(ptr: *T, count: uint) -> *T {\n+pub fn offset<T>(ptr: *T, count: uint) -> *T {\n     unsafe {\n         (ptr as uint + count * sys::size_of::<T>()) as *T\n     }\n }\n \n /// Calculate the offset from a const pointer\n #[inline(always)]\n-pub pure fn const_offset<T>(ptr: *const T, count: uint) -> *const T {\n+pub fn const_offset<T>(ptr: *const T, count: uint) -> *const T {\n     unsafe {\n         (ptr as uint + count * sys::size_of::<T>()) as *T\n     }\n }\n \n /// Calculate the offset from a mut pointer\n #[inline(always)]\n-pub pure fn mut_offset<T>(ptr: *mut T, count: uint) -> *mut T {\n+pub fn mut_offset<T>(ptr: *mut T, count: uint) -> *mut T {\n     (ptr as uint + count * sys::size_of::<T>()) as *mut T\n }\n \n@@ -93,19 +93,19 @@ pub unsafe fn position<T>(buf: *T, f: &fn(&T) -> bool) -> uint {\n \n /// Create an unsafe null pointer\n #[inline(always)]\n-pub pure fn null<T>() -> *T { unsafe { cast::reinterpret_cast(&0u) } }\n+pub fn null<T>() -> *T { unsafe { cast::reinterpret_cast(&0u) } }\n \n /// Create an unsafe mutable null pointer\n #[inline(always)]\n-pub pure fn mut_null<T>() -> *mut T { unsafe { cast::reinterpret_cast(&0u) } }\n+pub fn mut_null<T>() -> *mut T { unsafe { cast::reinterpret_cast(&0u) } }\n \n /// Returns true if the pointer is equal to the null pointer.\n #[inline(always)]\n-pub pure fn is_null<T>(ptr: *const T) -> bool { ptr == null() }\n+pub fn is_null<T>(ptr: *const T) -> bool { ptr == null() }\n \n /// Returns true if the pointer is not equal to the null pointer.\n #[inline(always)]\n-pub pure fn is_not_null<T>(ptr: *const T) -> bool { !is_null(ptr) }\n+pub fn is_not_null<T>(ptr: *const T) -> bool { !is_null(ptr) }\n \n /**\n  * Copies data from one location to another\n@@ -138,7 +138,7 @@ pub unsafe fn set_memory<T>(dst: *mut T, c: int, count: uint) {\n   reinterpret_cast.\n */\n #[inline(always)]\n-pub pure fn to_unsafe_ptr<T>(thing: &T) -> *T {\n+pub fn to_unsafe_ptr<T>(thing: &T) -> *T {\n     unsafe { cast::reinterpret_cast(&thing) }\n }\n \n@@ -148,7 +148,7 @@ pub pure fn to_unsafe_ptr<T>(thing: &T) -> *T {\n   reinterpret_cast.\n */\n #[inline(always)]\n-pub pure fn to_const_unsafe_ptr<T>(thing: &const T) -> *const T {\n+pub fn to_const_unsafe_ptr<T>(thing: &const T) -> *const T {\n     unsafe { cast::reinterpret_cast(&thing) }\n }\n \n@@ -158,7 +158,7 @@ pub pure fn to_const_unsafe_ptr<T>(thing: &const T) -> *const T {\n   reinterpret_cast.\n */\n #[inline(always)]\n-pub pure fn to_mut_unsafe_ptr<T>(thing: &mut T) -> *mut T {\n+pub fn to_mut_unsafe_ptr<T>(thing: &mut T) -> *mut T {\n     unsafe { cast::reinterpret_cast(&thing) }\n }\n \n@@ -170,15 +170,15 @@ pub pure fn to_mut_unsafe_ptr<T>(thing: &mut T) -> *mut T {\n   (I couldn't think of a cutesy name for this one.)\n */\n #[inline(always)]\n-pub pure fn to_uint<T>(thing: &T) -> uint {\n+pub fn to_uint<T>(thing: &T) -> uint {\n     unsafe {\n         cast::reinterpret_cast(&thing)\n     }\n }\n \n /// Determine if two borrowed pointers point to the same thing.\n #[inline(always)]\n-pub pure fn ref_eq<T>(thing: &'a T, other: &'b T) -> bool {\n+pub fn ref_eq<T>(thing: &'a T, other: &'b T) -> bool {\n     to_uint(thing) == to_uint(other)\n }\n \n@@ -223,85 +223,85 @@ pub unsafe fn array_each<T>(arr: **T, cb: &fn(*T)) {\n }\n \n pub trait Ptr<T> {\n-    pure fn is_null(&const self) -> bool;\n-    pure fn is_not_null(&const self) -> bool;\n-    pure fn offset(&self, count: uint) -> Self;\n+    fn is_null(&const self) -> bool;\n+    fn is_not_null(&const self) -> bool;\n+    fn offset(&self, count: uint) -> Self;\n }\n \n /// Extension methods for immutable pointers\n impl<T> Ptr<T> for *T {\n     /// Returns true if the pointer is equal to the null pointer.\n     #[inline(always)]\n-    pure fn is_null(&const self) -> bool { is_null(*self) }\n+    fn is_null(&const self) -> bool { is_null(*self) }\n \n     /// Returns true if the pointer is not equal to the null pointer.\n     #[inline(always)]\n-    pure fn is_not_null(&const self) -> bool { is_not_null(*self) }\n+    fn is_not_null(&const self) -> bool { is_not_null(*self) }\n \n     /// Calculates the offset from a pointer.\n     #[inline(always)]\n-    pure fn offset(&self, count: uint) -> *T { offset(*self, count) }\n+    fn offset(&self, count: uint) -> *T { offset(*self, count) }\n }\n \n /// Extension methods for mutable pointers\n impl<T> Ptr<T> for *mut T {\n     /// Returns true if the pointer is equal to the null pointer.\n     #[inline(always)]\n-    pure fn is_null(&const self) -> bool { is_null(*self) }\n+    fn is_null(&const self) -> bool { is_null(*self) }\n \n     /// Returns true if the pointer is not equal to the null pointer.\n     #[inline(always)]\n-    pure fn is_not_null(&const self) -> bool { is_not_null(*self) }\n+    fn is_not_null(&const self) -> bool { is_not_null(*self) }\n \n     /// Calculates the offset from a mutable pointer.\n     #[inline(always)]\n-    pure fn offset(&self, count: uint) -> *mut T { mut_offset(*self, count) }\n+    fn offset(&self, count: uint) -> *mut T { mut_offset(*self, count) }\n }\n \n // Equality for pointers\n #[cfg(notest)]\n impl<T> Eq for *const T {\n     #[inline(always)]\n-    pure fn eq(&self, other: &*const T) -> bool {\n+    fn eq(&self, other: &*const T) -> bool {\n         unsafe {\n             let a: uint = cast::reinterpret_cast(&(*self));\n             let b: uint = cast::reinterpret_cast(&(*other));\n             return a == b;\n         }\n     }\n     #[inline(always)]\n-    pure fn ne(&self, other: &*const T) -> bool { !(*self).eq(other) }\n+    fn ne(&self, other: &*const T) -> bool { !(*self).eq(other) }\n }\n \n // Comparison for pointers\n #[cfg(notest)]\n impl<T> Ord for *const T {\n     #[inline(always)]\n-    pure fn lt(&self, other: &*const T) -> bool {\n+    fn lt(&self, other: &*const T) -> bool {\n         unsafe {\n             let a: uint = cast::reinterpret_cast(&(*self));\n             let b: uint = cast::reinterpret_cast(&(*other));\n             return a < b;\n         }\n     }\n     #[inline(always)]\n-    pure fn le(&self, other: &*const T) -> bool {\n+    fn le(&self, other: &*const T) -> bool {\n         unsafe {\n             let a: uint = cast::reinterpret_cast(&(*self));\n             let b: uint = cast::reinterpret_cast(&(*other));\n             return a <= b;\n         }\n     }\n     #[inline(always)]\n-    pure fn ge(&self, other: &*const T) -> bool {\n+    fn ge(&self, other: &*const T) -> bool {\n         unsafe {\n             let a: uint = cast::reinterpret_cast(&(*self));\n             let b: uint = cast::reinterpret_cast(&(*other));\n             return a >= b;\n         }\n     }\n     #[inline(always)]\n-    pure fn gt(&self, other: &*const T) -> bool {\n+    fn gt(&self, other: &*const T) -> bool {\n         unsafe {\n             let a: uint = cast::reinterpret_cast(&(*self));\n             let b: uint = cast::reinterpret_cast(&(*other));\n@@ -314,11 +314,11 @@ impl<T> Ord for *const T {\n #[cfg(notest)]\n impl<T:Eq> Eq for &'self const T {\n     #[inline(always)]\n-    pure fn eq(&self, other: & &'self const T) -> bool {\n+    fn eq(&self, other: & &'self const T) -> bool {\n         return *(*self) == *(*other);\n     }\n     #[inline(always)]\n-    pure fn ne(&self, other: & &'self const T) -> bool {\n+    fn ne(&self, other: & &'self const T) -> bool {\n         return *(*self) != *(*other);\n     }\n }\n@@ -327,19 +327,19 @@ impl<T:Eq> Eq for &'self const T {\n #[cfg(notest)]\n impl<T:Ord> Ord for &'self const T {\n     #[inline(always)]\n-    pure fn lt(&self, other: & &'self const T) -> bool {\n+    fn lt(&self, other: & &'self const T) -> bool {\n         *(*self) < *(*other)\n     }\n     #[inline(always)]\n-    pure fn le(&self, other: & &'self const T) -> bool {\n+    fn le(&self, other: & &'self const T) -> bool {\n         *(*self) <= *(*other)\n     }\n     #[inline(always)]\n-    pure fn ge(&self, other: & &'self const T) -> bool {\n+    fn ge(&self, other: & &'self const T) -> bool {\n         *(*self) >= *(*other)\n     }\n     #[inline(always)]\n-    pure fn gt(&self, other: & &'self const T) -> bool {\n+    fn gt(&self, other: & &'self const T) -> bool {\n         *(*self) > *(*other)\n     }\n }"}, {"sha": "fbdda02dcdc78e9ecbfe9b004ee1327fc860d427", "filename": "src/libcore/rand.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/be9bddd46377bc982b73acf15a720365a54197a7/src%2Flibcore%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be9bddd46377bc982b73acf15a720365a54197a7/src%2Flibcore%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frand.rs?ref=be9bddd46377bc982b73acf15a720365a54197a7", "patch": "@@ -527,12 +527,12 @@ impl Rng for XorShiftState {\n     }\n }\n \n-pub pure fn xorshift() -> @Rng {\n+pub fn xorshift() -> @Rng {\n     // constants taken from http://en.wikipedia.org/wiki/Xorshift\n     seeded_xorshift(123456789u32, 362436069u32, 521288629u32, 88675123u32)\n }\n \n-pub pure fn seeded_xorshift(x: u32, y: u32, z: u32, w: u32) -> @Rng {\n+pub fn seeded_xorshift(x: u32, y: u32, z: u32, w: u32) -> @Rng {\n     @XorShiftState { x: x, y: y, z: z, w: w } as @Rng\n }\n "}, {"sha": "5dd2eaf5533d4cd78b732f527a6a6d781a3f2b48", "filename": "src/libcore/result.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/be9bddd46377bc982b73acf15a720365a54197a7/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be9bddd46377bc982b73acf15a720365a54197a7/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=be9bddd46377bc982b73acf15a720365a54197a7", "patch": "@@ -36,7 +36,7 @@ pub enum Result<T, U> {\n  * If the result is an error\n  */\n #[inline(always)]\n-pub pure fn get<T:Copy,U>(res: &Result<T, U>) -> T {\n+pub fn get<T:Copy,U>(res: &Result<T, U>) -> T {\n     match *res {\n       Ok(copy t) => t,\n       Err(ref the_err) => unsafe {\n@@ -53,7 +53,7 @@ pub pure fn get<T:Copy,U>(res: &Result<T, U>) -> T {\n  * If the result is an error\n  */\n #[inline(always)]\n-pub pure fn get_ref<T, U>(res: &'a Result<T, U>) -> &'a T {\n+pub fn get_ref<T, U>(res: &'a Result<T, U>) -> &'a T {\n     match *res {\n         Ok(ref t) => t,\n         Err(ref the_err) => unsafe {\n@@ -70,7 +70,7 @@ pub pure fn get_ref<T, U>(res: &'a Result<T, U>) -> &'a T {\n  * If the result is not an error\n  */\n #[inline(always)]\n-pub pure fn get_err<T, U: Copy>(res: &Result<T, U>) -> U {\n+pub fn get_err<T, U: Copy>(res: &Result<T, U>) -> U {\n     match *res {\n       Err(copy u) => u,\n       Ok(_) => fail!(~\"get_err called on ok result\")\n@@ -79,7 +79,7 @@ pub pure fn get_err<T, U: Copy>(res: &Result<T, U>) -> U {\n \n /// Returns true if the result is `ok`\n #[inline(always)]\n-pub pure fn is_ok<T, U>(res: &Result<T, U>) -> bool {\n+pub fn is_ok<T, U>(res: &Result<T, U>) -> bool {\n     match *res {\n       Ok(_) => true,\n       Err(_) => false\n@@ -88,7 +88,7 @@ pub pure fn is_ok<T, U>(res: &Result<T, U>) -> bool {\n \n /// Returns true if the result is `err`\n #[inline(always)]\n-pub pure fn is_err<T, U>(res: &Result<T, U>) -> bool {\n+pub fn is_err<T, U>(res: &Result<T, U>) -> bool {\n     !is_ok(res)\n }\n \n@@ -99,7 +99,7 @@ pub pure fn is_err<T, U>(res: &Result<T, U>) -> bool {\n  * result variants are converted to `either::left`.\n  */\n #[inline(always)]\n-pub pure fn to_either<T:Copy,U:Copy>(res: &Result<U, T>)\n+pub fn to_either<T:Copy,U:Copy>(res: &Result<U, T>)\n     -> Either<T, U> {\n     match *res {\n       Ok(copy res) => either::Right(res),\n@@ -122,7 +122,7 @@ pub pure fn to_either<T:Copy,U:Copy>(res: &Result<U, T>)\n  *     }\n  */\n #[inline(always)]\n-pub pure fn chain<T, U, V>(res: Result<T, V>, op: &fn(T)\n+pub fn chain<T, U, V>(res: Result<T, V>, op: &fn(T)\n     -> Result<U, V>) -> Result<U, V> {\n     match res {\n         Ok(t) => op(t),\n@@ -139,7 +139,7 @@ pub pure fn chain<T, U, V>(res: Result<T, V>, op: &fn(T)\n  * successful result while handling an error.\n  */\n #[inline(always)]\n-pub pure fn chain_err<T, U, V>(\n+pub fn chain_err<T, U, V>(\n     res: Result<T, V>,\n     op: &fn(t: V) -> Result<T, U>)\n     -> Result<T, U> {\n@@ -164,7 +164,7 @@ pub pure fn chain_err<T, U, V>(\n  *     }\n  */\n #[inline(always)]\n-pub pure fn iter<T, E>(res: &Result<T, E>, f: &fn(&T)) {\n+pub fn iter<T, E>(res: &Result<T, E>, f: &fn(&T)) {\n     match *res {\n       Ok(ref t) => f(t),\n       Err(_) => ()\n@@ -180,7 +180,7 @@ pub pure fn iter<T, E>(res: &Result<T, E>, f: &fn(&T)) {\n  * handling an error.\n  */\n #[inline(always)]\n-pub pure fn iter_err<T, E>(res: &Result<T, E>, f: &fn(&E)) {\n+pub fn iter_err<T, E>(res: &Result<T, E>, f: &fn(&E)) {\n     match *res {\n       Ok(_) => (),\n       Err(ref e) => f(e)\n@@ -202,7 +202,7 @@ pub pure fn iter_err<T, E>(res: &Result<T, E>, f: &fn(&E)) {\n  *     }\n  */\n #[inline(always)]\n-pub pure fn map<T, E: Copy, U: Copy>(res: &Result<T, E>, op: &fn(&T) -> U)\n+pub fn map<T, E: Copy, U: Copy>(res: &Result<T, E>, op: &fn(&T) -> U)\n   -> Result<U, E> {\n     match *res {\n       Ok(ref t) => Ok(op(t)),\n@@ -219,7 +219,7 @@ pub pure fn map<T, E: Copy, U: Copy>(res: &Result<T, E>, op: &fn(&T) -> U)\n  * successful result while handling an error.\n  */\n #[inline(always)]\n-pub pure fn map_err<T:Copy,E,F:Copy>(res: &Result<T, E>, op: &fn(&E) -> F)\n+pub fn map_err<T:Copy,E,F:Copy>(res: &Result<T, E>, op: &fn(&E) -> F)\n   -> Result<T, F> {\n     match *res {\n       Ok(copy t) => Ok(t),\n@@ -229,53 +229,53 @@ pub pure fn map_err<T:Copy,E,F:Copy>(res: &Result<T, E>, op: &fn(&E) -> F)\n \n pub impl<T, E> Result<T, E> {\n     #[inline(always)]\n-    pure fn get_ref(&self) -> &'self T { get_ref(self) }\n+    fn get_ref(&self) -> &'self T { get_ref(self) }\n \n     #[inline(always)]\n-    pure fn is_ok(&self) -> bool { is_ok(self) }\n+    fn is_ok(&self) -> bool { is_ok(self) }\n \n     #[inline(always)]\n-    pure fn is_err(&self) -> bool { is_err(self) }\n+    fn is_err(&self) -> bool { is_err(self) }\n \n     #[inline(always)]\n-    pure fn iter(&self, f: &fn(&T)) { iter(self, f) }\n+    fn iter(&self, f: &fn(&T)) { iter(self, f) }\n \n     #[inline(always)]\n-    pure fn iter_err(&self, f: &fn(&E)) { iter_err(self, f) }\n+    fn iter_err(&self, f: &fn(&E)) { iter_err(self, f) }\n \n     #[inline(always)]\n-    pure fn unwrap(self) -> T { unwrap(self) }\n+    fn unwrap(self) -> T { unwrap(self) }\n \n     #[inline(always)]\n-    pure fn unwrap_err(self) -> E { unwrap_err(self) }\n+    fn unwrap_err(self) -> E { unwrap_err(self) }\n \n     #[inline(always)]\n-    pure fn chain<U>(self, op: &fn(T) -> Result<U,E>) -> Result<U,E> {\n+    fn chain<U>(self, op: &fn(T) -> Result<U,E>) -> Result<U,E> {\n         chain(self, op)\n     }\n \n     #[inline(always)]\n-    pure fn chain_err<F>(self, op: &fn(E) -> Result<T,F>) -> Result<T,F> {\n+    fn chain_err<F>(self, op: &fn(E) -> Result<T,F>) -> Result<T,F> {\n         chain_err(self, op)\n     }\n }\n \n pub impl<T:Copy,E> Result<T, E> {\n     #[inline(always)]\n-    pure fn get(&self) -> T { get(self) }\n+    fn get(&self) -> T { get(self) }\n \n     #[inline(always)]\n-    pure fn map_err<F:Copy>(&self, op: &fn(&E) -> F) -> Result<T,F> {\n+    fn map_err<F:Copy>(&self, op: &fn(&E) -> F) -> Result<T,F> {\n         map_err(self, op)\n     }\n }\n \n pub impl<T, E: Copy> Result<T, E> {\n     #[inline(always)]\n-    pure fn get_err(&self) -> E { get_err(self) }\n+    fn get_err(&self) -> E { get_err(self) }\n \n     #[inline(always)]\n-    pure fn map<U:Copy>(&self, op: &fn(&T) -> U) -> Result<U,E> {\n+    fn map<U:Copy>(&self, op: &fn(&T) -> U) -> Result<U,E> {\n         map(self, op)\n     }\n }\n@@ -375,7 +375,7 @@ pub fn iter_vec2<S,T,U:Copy>(ss: &[S], ts: &[T],\n \n /// Unwraps a result, assuming it is an `ok(T)`\n #[inline(always)]\n-pub pure fn unwrap<T, U>(res: Result<T, U>) -> T {\n+pub fn unwrap<T, U>(res: Result<T, U>) -> T {\n     match res {\n       Ok(t) => t,\n       Err(_) => fail!(~\"unwrap called on an err result\")\n@@ -384,7 +384,7 @@ pub pure fn unwrap<T, U>(res: Result<T, U>) -> T {\n \n /// Unwraps a result, assuming it is an `err(U)`\n #[inline(always)]\n-pub pure fn unwrap_err<T, U>(res: Result<T, U>) -> U {\n+pub fn unwrap_err<T, U>(res: Result<T, U>) -> U {\n     match res {\n       Err(u) => u,\n       Ok(_) => fail!(~\"unwrap called on an ok result\")"}, {"sha": "4150366dacfa32f1142d68acf91b55575c7d117a", "filename": "src/libcore/rt/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/be9bddd46377bc982b73acf15a720365a54197a7/src%2Flibcore%2Frt%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be9bddd46377bc982b73acf15a720365a54197a7/src%2Flibcore%2Frt%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fcontext.rs?ref=be9bddd46377bc982b73acf15a720365a54197a7", "patch": "@@ -184,7 +184,7 @@ fn align_down(sp: *mut uint) -> *mut uint {\n \n // XXX: ptr::offset is positive ints only\n #[inline(always)]\n-pub pure fn mut_offset<T>(ptr: *mut T, count: int) -> *mut T {\n+pub fn mut_offset<T>(ptr: *mut T, count: int) -> *mut T {\n     use core::sys::size_of;\n     unsafe {\n         (ptr as int + count * (size_of::<T>() as int)) as *mut T"}, {"sha": "4d87bdb02e81a4dbe4fa255478459544f50f1831", "filename": "src/libcore/rt/uv.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/be9bddd46377bc982b73acf15a720365a54197a7/src%2Flibcore%2Frt%2Fuv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be9bddd46377bc982b73acf15a720365a54197a7/src%2Flibcore%2Frt%2Fuv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fuv.rs?ref=be9bddd46377bc982b73acf15a720365a54197a7", "patch": "@@ -518,7 +518,7 @@ struct UvError(uvll::uv_err_t);\n \n impl UvError {\n \n-    pure fn name(&self) -> ~str {\n+    fn name(&self) -> ~str {\n         unsafe {\n             let inner = match self { &UvError(ref a) => a };\n             let name_str = uvll::err_name(inner);\n@@ -527,7 +527,7 @@ impl UvError {\n         }\n     }\n \n-    pure fn desc(&self) -> ~str {\n+    fn desc(&self) -> ~str {\n         unsafe {\n             let inner = match self { &UvError(ref a) => a };\n             let desc_str = uvll::strerror(inner);\n@@ -538,7 +538,7 @@ impl UvError {\n }\n \n impl ToStr for UvError {\n-    pure fn to_str(&self) -> ~str {\n+    fn to_str(&self) -> ~str {\n         fmt!(\"%s: %s\", self.name(), self.desc())\n     }\n }"}, {"sha": "d9202f4c61cf23e42acbfcf9de11a36058428c57", "filename": "src/libcore/str.rs", "status": "modified", "additions": 216, "deletions": 216, "changes": 432, "blob_url": "https://github.com/rust-lang/rust/blob/be9bddd46377bc982b73acf15a720365a54197a7/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be9bddd46377bc982b73acf15a720365a54197a7/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=be9bddd46377bc982b73acf15a720365a54197a7", "patch": "@@ -44,27 +44,27 @@ Section: Creating a string\n  *\n  * Fails if invalid UTF-8\n  */\n-pub pure fn from_bytes(vv: &[const u8]) -> ~str {\n+pub fn from_bytes(vv: &[const u8]) -> ~str {\n     fail_unless!(is_utf8(vv));\n     return unsafe { raw::from_bytes(vv) };\n }\n \n /// Copy a slice into a new unique str\n-pub pure fn from_slice(s: &str) -> ~str {\n+pub fn from_slice(s: &str) -> ~str {\n     unsafe { raw::slice_bytes_unique(s, 0, len(s)) }\n }\n \n impl ToStr for ~str {\n     #[inline(always)]\n-    pure fn to_str(&self) -> ~str { copy *self }\n+    fn to_str(&self) -> ~str { copy *self }\n }\n impl ToStr for &'self str {\n     #[inline(always)]\n-    pure fn to_str(&self) -> ~str { ::str::from_slice(*self) }\n+    fn to_str(&self) -> ~str { ::str::from_slice(*self) }\n }\n impl ToStr for @str {\n     #[inline(always)]\n-    pure fn to_str(&self) -> ~str { ::str::from_slice(*self) }\n+    fn to_str(&self) -> ~str { ::str::from_slice(*self) }\n }\n \n /**\n@@ -74,7 +74,7 @@ impl ToStr for @str {\n  *\n  * Fails if invalid UTF-8\n  */\n-pub pure fn from_byte(b: u8) -> ~str {\n+pub fn from_byte(b: u8) -> ~str {\n     fail_unless!(b < 128u8);\n     unsafe { ::cast::transmute(~[b, 0u8]) }\n }\n@@ -151,14 +151,14 @@ pub fn push_char(s: &mut ~str, ch: char) {\n }\n \n /// Convert a char to a string\n-pub pure fn from_char(ch: char) -> ~str {\n+pub fn from_char(ch: char) -> ~str {\n     let mut buf = ~\"\";\n     unsafe { push_char(&mut buf, ch); }\n     buf\n }\n \n /// Convert a vector of chars to a string\n-pub pure fn from_chars(chs: &[char]) -> ~str {\n+pub fn from_chars(chs: &[char]) -> ~str {\n     let mut buf = ~\"\";\n     unsafe {\n         reserve(&mut buf, chs.len());\n@@ -206,7 +206,7 @@ pub fn push_str(lhs: &mut ~str, rhs: &str) {\n \n /// Concatenate two strings together\n #[inline(always)]\n-pub pure fn append(lhs: ~str, rhs: &str) -> ~str {\n+pub fn append(lhs: ~str, rhs: &str) -> ~str {\n     let mut v = lhs;\n     unsafe {\n         push_str_no_overallocate(&mut v, rhs);\n@@ -216,7 +216,7 @@ pub pure fn append(lhs: ~str, rhs: &str) -> ~str {\n \n \n /// Concatenate a vector of strings\n-pub pure fn concat(v: &[~str]) -> ~str {\n+pub fn concat(v: &[~str]) -> ~str {\n     let mut s: ~str = ~\"\";\n     for vec::each(v) |ss| {\n         unsafe { push_str(&mut s, *ss) };\n@@ -225,7 +225,7 @@ pub pure fn concat(v: &[~str]) -> ~str {\n }\n \n /// Concatenate a vector of strings, placing a given separator between each\n-pub pure fn connect(v: &[~str], sep: &str) -> ~str {\n+pub fn connect(v: &[~str], sep: &str) -> ~str {\n     let mut s = ~\"\", first = true;\n     for vec::each(v) |ss| {\n         if first { first = false; } else { unsafe { push_str(&mut s, sep); } }\n@@ -235,7 +235,7 @@ pub pure fn connect(v: &[~str], sep: &str) -> ~str {\n }\n \n /// Concatenate a vector of strings, placing a given separator between each\n-pub pure fn connect_slices(v: &[&str], sep: &str) -> ~str {\n+pub fn connect_slices(v: &[&str], sep: &str) -> ~str {\n     let mut s = ~\"\", first = true;\n     for vec::each(v) |ss| {\n         if first { first = false; } else { unsafe { push_str(&mut s, sep); } }\n@@ -245,7 +245,7 @@ pub pure fn connect_slices(v: &[&str], sep: &str) -> ~str {\n }\n \n /// Given a string, make a new string with repeated copies of it\n-pub pure fn repeat(ss: &str, nn: uint) -> ~str {\n+pub fn repeat(ss: &str, nn: uint) -> ~str {\n     let mut acc = ~\"\";\n     for nn.times { acc += ss; }\n     acc\n@@ -313,7 +313,7 @@ pub fn unshift_char(s: &mut ~str, ch: char) {\n  * * chars_to_trim - A vector of chars\n  *\n  */\n-pub pure fn trim_left_chars(s: &'a str, chars_to_trim: &[char]) -> &'a str {\n+pub fn trim_left_chars(s: &'a str, chars_to_trim: &[char]) -> &'a str {\n     if chars_to_trim.is_empty() { return s; }\n \n     match find(s, |c| !chars_to_trim.contains(&c)) {\n@@ -331,7 +331,7 @@ pub pure fn trim_left_chars(s: &'a str, chars_to_trim: &[char]) -> &'a str {\n  * * chars_to_trim - A vector of chars\n  *\n  */\n-pub pure fn trim_right_chars(s: &'a str, chars_to_trim: &[char]) -> &'a str {\n+pub fn trim_right_chars(s: &'a str, chars_to_trim: &[char]) -> &'a str {\n     if chars_to_trim.is_empty() { return s; }\n \n     match rfind(s, |c| !chars_to_trim.contains(&c)) {\n@@ -352,20 +352,20 @@ pub pure fn trim_right_chars(s: &'a str, chars_to_trim: &[char]) -> &'a str {\n  * * chars_to_trim - A vector of chars\n  *\n  */\n-pub pure fn trim_chars(s: &'a str, chars_to_trim: &[char]) -> &'a str {\n+pub fn trim_chars(s: &'a str, chars_to_trim: &[char]) -> &'a str {\n     trim_left_chars(trim_right_chars(s, chars_to_trim), chars_to_trim)\n }\n \n /// Returns a string with leading whitespace removed\n-pub pure fn trim_left(s: &'a str) -> &'a str {\n+pub fn trim_left(s: &'a str) -> &'a str {\n     match find(s, |c| !char::is_whitespace(c)) {\n       None => \"\",\n       Some(first) => unsafe { raw::slice_bytes(s, first, len(s)) }\n     }\n }\n \n /// Returns a string with trailing whitespace removed\n-pub pure fn trim_right(s: &'a str) -> &'a str {\n+pub fn trim_right(s: &'a str) -> &'a str {\n     match rfind(s, |c| !char::is_whitespace(c)) {\n       None => \"\",\n       Some(last) => {\n@@ -376,7 +376,7 @@ pub pure fn trim_right(s: &'a str) -> &'a str {\n }\n \n /// Returns a string with leading and trailing whitespace removed\n-pub pure fn trim(s: &'a str) -> &'a str { trim_left(trim_right(s)) }\n+pub fn trim(s: &'a str) -> &'a str { trim_left(trim_right(s)) }\n \n /*\n Section: Transforming strings\n@@ -387,7 +387,7 @@ Section: Transforming strings\n  *\n  * The result vector is not null-terminated.\n  */\n-pub pure fn to_bytes(s: &str) -> ~[u8] {\n+pub fn to_bytes(s: &str) -> ~[u8] {\n     unsafe {\n         let mut v: ~[u8] = ::cast::transmute(from_slice(s));\n         vec::raw::set_len(&mut v, len(s));\n@@ -397,14 +397,14 @@ pub pure fn to_bytes(s: &str) -> ~[u8] {\n \n /// Work with the string as a byte slice, not including trailing null.\n #[inline(always)]\n-pub pure fn byte_slice<T>(s: &str, f: &fn(v: &[u8]) -> T) -> T {\n+pub fn byte_slice<T>(s: &str, f: &fn(v: &[u8]) -> T) -> T {\n     do as_buf(s) |p,n| {\n         unsafe { vec::raw::buf_as_slice(p, n-1u, f) }\n     }\n }\n \n /// Convert a string to a vector of characters\n-pub pure fn chars(s: &str) -> ~[char] {\n+pub fn chars(s: &str) -> ~[char] {\n     let mut buf = ~[], i = 0;\n     let len = len(s);\n     while i < len {\n@@ -421,7 +421,7 @@ pub pure fn chars(s: &str) -> ~[char] {\n  * Returns a string containing `n` characters starting at byte offset\n  * `begin`.\n  */\n-pub pure fn substr(s: &'a str, begin: uint, n: uint) -> &'a str {\n+pub fn substr(s: &'a str, begin: uint, n: uint) -> &'a str {\n     slice(s, begin, begin + count_bytes(s, begin, n))\n }\n \n@@ -431,15 +431,15 @@ pub pure fn substr(s: &'a str, begin: uint, n: uint) -> &'a str {\n  * Fails when `begin` and `end` do not point to valid characters or beyond\n  * the last character of the string\n  */\n-pub pure fn slice(s: &'a str, begin: uint, end: uint) -> &'a str {\n+pub fn slice(s: &'a str, begin: uint, end: uint) -> &'a str {\n     fail_unless!(is_char_boundary(s, begin));\n     fail_unless!(is_char_boundary(s, end));\n     unsafe { raw::slice_bytes(s, begin, end) }\n }\n \n /// Splits a string into substrings at each occurrence of a given\n /// character.\n-pub pure fn split_char(s: &str, sep: char) -> ~[~str] {\n+pub fn split_char(s: &str, sep: char) -> ~[~str] {\n     split_char_inner(s, sep, len(s), true, true)\n }\n \n@@ -449,25 +449,25 @@ pub pure fn split_char(s: &str, sep: char) -> ~[~str] {\n  *\n  * The byte must be a valid UTF-8/ASCII byte\n  */\n-pub pure fn splitn_char(s: &str, sep: char, count: uint) -> ~[~str] {\n+pub fn splitn_char(s: &str, sep: char, count: uint) -> ~[~str] {\n     split_char_inner(s, sep, count, true, true)\n }\n \n /// Like `split_char`, but omits empty strings from the returned vector\n-pub pure fn split_char_nonempty(s: &str, sep: char) -> ~[~str] {\n+pub fn split_char_nonempty(s: &str, sep: char) -> ~[~str] {\n     split_char_inner(s, sep, len(s), false, false)\n }\n \n /**\n  * Like `split_char`, but a trailing empty string is omitted\n  * (e.g. `split_char_no_trailing(\"A B \",' ') == ~[~\"A\",~\"B\"]`)\n  */\n-pub pure fn split_char_no_trailing(s: &str, sep: char) -> ~[~str] {\n+pub fn split_char_no_trailing(s: &str, sep: char) -> ~[~str] {\n     split_char_inner(s, sep, len(s), true, false)\n }\n \n-pure fn split_char_inner(s: &str, sep: char, count: uint, allow_empty: bool,\n-                         allow_trailing_empty: bool) -> ~[~str] {\n+fn split_char_inner(s: &str, sep: char, count: uint, allow_empty: bool,\n+                    allow_trailing_empty: bool) -> ~[~str] {\n     if sep < 128u as char {\n         let b = sep as u8, l = len(s);\n         let mut result = ~[], done = 0u;\n@@ -496,23 +496,23 @@ pure fn split_char_inner(s: &str, sep: char, count: uint, allow_empty: bool,\n \n \n /// Splits a string into substrings using a character function\n-pub pure fn split(s: &str, sepfn: &fn(char) -> bool) -> ~[~str] {\n+pub fn split(s: &str, sepfn: &fn(char) -> bool) -> ~[~str] {\n     split_inner(s, sepfn, len(s), true, true)\n }\n \n /**\n  * Splits a string into substrings using a character function, cutting at\n  * most `count` times.\n  */\n-pub pure fn splitn(s: &str,\n+pub fn splitn(s: &str,\n                    sepfn: &fn(char) -> bool,\n                    count: uint)\n                 -> ~[~str] {\n     split_inner(s, sepfn, count, true, true)\n }\n \n /// Like `split`, but omits empty strings from the returned vector\n-pub pure fn split_nonempty(s: &str, sepfn: &fn(char) -> bool) -> ~[~str] {\n+pub fn split_nonempty(s: &str, sepfn: &fn(char) -> bool) -> ~[~str] {\n     split_inner(s, sepfn, len(s), false, false)\n }\n \n@@ -521,7 +521,7 @@ pub pure fn split_nonempty(s: &str, sepfn: &fn(char) -> bool) -> ~[~str] {\n  * Like `split`, but a trailing empty string is omitted\n  * (e.g. `split_no_trailing(\"A B \",' ') == ~[~\"A\",~\"B\"]`)\n  */\n-pub pure fn split_no_trailing(s: &str, sepfn: &fn(char) -> bool) -> ~[~str] {\n+pub fn split_no_trailing(s: &str, sepfn: &fn(char) -> bool) -> ~[~str] {\n     split_inner(s, sepfn, len(s), true, false)\n }\n \n@@ -551,7 +551,7 @@ pure fn split_inner(s: &str, sepfn: &fn(cc: char) -> bool, count: uint,\n }\n \n // See Issue #1932 for why this is a naive search\n-pure fn iter_matches(s: &'a str, sep: &'b str, f: &fn(uint, uint)) {\n+fn iter_matches(s: &'a str, sep: &'b str, f: &fn(uint, uint)) {\n     let sep_len = len(sep), l = len(s);\n     fail_unless!(sep_len > 0u);\n     let mut i = 0u, match_start = 0u, match_i = 0u;\n@@ -578,7 +578,7 @@ pure fn iter_matches(s: &'a str, sep: &'b str, f: &fn(uint, uint)) {\n     }\n }\n \n-pure fn iter_between_matches(s: &'a str, sep: &'b str, f: &fn(uint, uint)) {\n+fn iter_between_matches(s: &'a str, sep: &'b str, f: &fn(uint, uint)) {\n     let mut last_end = 0u;\n     do iter_matches(s, sep) |from, to| {\n         f(last_end, from);\n@@ -596,15 +596,15 @@ pure fn iter_between_matches(s: &'a str, sep: &'b str, f: &fn(uint, uint)) {\n  * fail_unless!([\"\", \"XXX\", \"YYY\", \"\"] == split_str(\".XXX.YYY.\", \".\"))\n  * ~~~\n  */\n-pub pure fn split_str(s: &'a str, sep: &'b str) -> ~[~str] {\n+pub fn split_str(s: &'a str, sep: &'b str) -> ~[~str] {\n     let mut result = ~[];\n     do iter_between_matches(s, sep) |from, to| {\n         unsafe { result.push(raw::slice_bytes_unique(s, from, to)); }\n     }\n     result\n }\n \n-pub pure fn split_str_nonempty(s: &'a str, sep: &'b str) -> ~[~str] {\n+pub fn split_str_nonempty(s: &'a str, sep: &'b str) -> ~[~str] {\n     let mut result = ~[];\n     do iter_between_matches(s, sep) |from, to| {\n         if to > from {\n@@ -651,15 +651,15 @@ pub fn levdistance(s: &str, t: &str) -> uint {\n /**\n  * Splits a string into a vector of the substrings separated by LF ('\\n').\n  */\n-pub pure fn lines(s: &str) -> ~[~str] {\n+pub fn lines(s: &str) -> ~[~str] {\n     split_char_no_trailing(s, '\\n')\n }\n \n /**\n  * Splits a string into a vector of the substrings separated by LF ('\\n')\n  * and/or CR LF (\"\\r\\n\")\n  */\n-pub pure fn lines_any(s: &str) -> ~[~str] {\n+pub fn lines_any(s: &str) -> ~[~str] {\n     vec::map(lines(s), |s| {\n         let l = len(*s);\n         let mut cp = copy *s;\n@@ -671,7 +671,7 @@ pub pure fn lines_any(s: &str) -> ~[~str] {\n }\n \n /// Splits a string into a vector of the substrings separated by whitespace\n-pub pure fn words(s: &str) -> ~[~str] {\n+pub fn words(s: &str) -> ~[~str] {\n     split_nonempty(s, char::is_whitespace)\n }\n \n@@ -710,14 +710,14 @@ pub fn split_within(ss: &str, lim: uint) -> ~[~str] {\n \n \n /// Convert a string to lowercase. ASCII only\n-pub pure fn to_lower(s: &str) -> ~str {\n+pub fn to_lower(s: &str) -> ~str {\n     map(s,\n         |c| unsafe{(libc::tolower(c as libc::c_char)) as char}\n     )\n }\n \n /// Convert a string to uppercase. ASCII only\n-pub pure fn to_upper(s: &str) -> ~str {\n+pub fn to_upper(s: &str) -> ~str {\n     map(s,\n         |c| unsafe{(libc::toupper(c as libc::c_char)) as char}\n     )\n@@ -736,7 +736,7 @@ pub pure fn to_upper(s: &str) -> ~str {\n  *\n  * The original string with all occurances of `from` replaced with `to`\n  */\n-pub pure fn replace(s: &str, from: &str, to: &str) -> ~str {\n+pub fn replace(s: &str, from: &str, to: &str) -> ~str {\n     let mut result = ~\"\", first = true;\n     do iter_between_matches(s, from) |start, end| {\n         if first {\n@@ -756,7 +756,7 @@ Section: Comparing strings\n /// Bytewise slice equality\n #[cfg(notest)]\n #[lang=\"str_eq\"]\n-pub pure fn eq_slice(a: &str, b: &str) -> bool {\n+pub fn eq_slice(a: &str, b: &str) -> bool {\n     do as_buf(a) |ap, alen| {\n         do as_buf(b) |bp, blen| {\n             if (alen != blen) { false }\n@@ -772,7 +772,7 @@ pub pure fn eq_slice(a: &str, b: &str) -> bool {\n }\n \n #[cfg(test)]\n-pub pure fn eq_slice(a: &str, b: &str) -> bool {\n+pub fn eq_slice(a: &str, b: &str) -> bool {\n     do as_buf(a) |ap, alen| {\n         do as_buf(b) |bp, blen| {\n             if (alen != blen) { false }\n@@ -790,16 +790,16 @@ pub pure fn eq_slice(a: &str, b: &str) -> bool {\n /// Bytewise string equality\n #[cfg(notest)]\n #[lang=\"uniq_str_eq\"]\n-pub pure fn eq(a: &~str, b: &~str) -> bool {\n+pub fn eq(a: &~str, b: &~str) -> bool {\n     eq_slice(*a, *b)\n }\n \n #[cfg(test)]\n-pub pure fn eq(a: &~str, b: &~str) -> bool {\n+pub fn eq(a: &~str, b: &~str) -> bool {\n     eq_slice(*a, *b)\n }\n \n-pure fn cmp(a: &str, b: &str) -> Ordering {\n+fn cmp(a: &str, b: &str) -> Ordering {\n     let low = uint::min(a.len(), b.len());\n \n     for uint::range(0, low) |idx| {\n@@ -815,21 +815,21 @@ pure fn cmp(a: &str, b: &str) -> Ordering {\n \n #[cfg(notest)]\n impl TotalOrd for &'self str {\n-    pure fn cmp(&self, other: & &'self str) -> Ordering { cmp(*self, *other) }\n+    fn cmp(&self, other: & &'self str) -> Ordering { cmp(*self, *other) }\n }\n \n #[cfg(notest)]\n impl TotalOrd for ~str {\n-    pure fn cmp(&self, other: &~str) -> Ordering { cmp(*self, *other) }\n+    fn cmp(&self, other: &~str) -> Ordering { cmp(*self, *other) }\n }\n \n #[cfg(notest)]\n impl TotalOrd for @str {\n-    pure fn cmp(&self, other: &@str) -> Ordering { cmp(*self, *other) }\n+    fn cmp(&self, other: &@str) -> Ordering { cmp(*self, *other) }\n }\n \n /// Bytewise slice less than\n-pure fn lt(a: &str, b: &str) -> bool {\n+fn lt(a: &str, b: &str) -> bool {\n     let (a_len, b_len) = (a.len(), b.len());\n     let mut end = uint::min(a_len, b_len);\n \n@@ -845,90 +845,90 @@ pure fn lt(a: &str, b: &str) -> bool {\n }\n \n /// Bytewise less than or equal\n-pub pure fn le(a: &str, b: &str) -> bool {\n+pub fn le(a: &str, b: &str) -> bool {\n     !lt(b, a)\n }\n \n /// Bytewise greater than or equal\n-pure fn ge(a: &str, b: &str) -> bool {\n+fn ge(a: &str, b: &str) -> bool {\n     !lt(a, b)\n }\n \n /// Bytewise greater than\n-pure fn gt(a: &str, b: &str) -> bool {\n+fn gt(a: &str, b: &str) -> bool {\n     !le(a, b)\n }\n \n #[cfg(notest)]\n impl Eq for &'self str {\n     #[inline(always)]\n-    pure fn eq(&self, other: & &'self str) -> bool {\n+    fn eq(&self, other: & &'self str) -> bool {\n         eq_slice((*self), (*other))\n     }\n     #[inline(always)]\n-    pure fn ne(&self, other: & &'self str) -> bool { !(*self).eq(other) }\n+    fn ne(&self, other: & &'self str) -> bool { !(*self).eq(other) }\n }\n \n #[cfg(notest)]\n impl Eq for ~str {\n     #[inline(always)]\n-    pure fn eq(&self, other: &~str) -> bool {\n+    fn eq(&self, other: &~str) -> bool {\n         eq_slice((*self), (*other))\n     }\n     #[inline(always)]\n-    pure fn ne(&self, other: &~str) -> bool { !(*self).eq(other) }\n+    fn ne(&self, other: &~str) -> bool { !(*self).eq(other) }\n }\n \n #[cfg(notest)]\n impl Eq for @str {\n     #[inline(always)]\n-    pure fn eq(&self, other: &@str) -> bool {\n+    fn eq(&self, other: &@str) -> bool {\n         eq_slice((*self), (*other))\n     }\n     #[inline(always)]\n-    pure fn ne(&self, other: &@str) -> bool { !(*self).eq(other) }\n+    fn ne(&self, other: &@str) -> bool { !(*self).eq(other) }\n }\n \n #[cfg(notest)]\n impl Ord for ~str {\n     #[inline(always)]\n-    pure fn lt(&self, other: &~str) -> bool { lt((*self), (*other)) }\n+    fn lt(&self, other: &~str) -> bool { lt((*self), (*other)) }\n     #[inline(always)]\n-    pure fn le(&self, other: &~str) -> bool { le((*self), (*other)) }\n+    fn le(&self, other: &~str) -> bool { le((*self), (*other)) }\n     #[inline(always)]\n-    pure fn ge(&self, other: &~str) -> bool { ge((*self), (*other)) }\n+    fn ge(&self, other: &~str) -> bool { ge((*self), (*other)) }\n     #[inline(always)]\n-    pure fn gt(&self, other: &~str) -> bool { gt((*self), (*other)) }\n+    fn gt(&self, other: &~str) -> bool { gt((*self), (*other)) }\n }\n \n #[cfg(notest)]\n impl Ord for &'self str {\n     #[inline(always)]\n-    pure fn lt(&self, other: & &'self str) -> bool { lt((*self), (*other)) }\n+    fn lt(&self, other: & &'self str) -> bool { lt((*self), (*other)) }\n     #[inline(always)]\n-    pure fn le(&self, other: & &'self str) -> bool { le((*self), (*other)) }\n+    fn le(&self, other: & &'self str) -> bool { le((*self), (*other)) }\n     #[inline(always)]\n-    pure fn ge(&self, other: & &'self str) -> bool { ge((*self), (*other)) }\n+    fn ge(&self, other: & &'self str) -> bool { ge((*self), (*other)) }\n     #[inline(always)]\n-    pure fn gt(&self, other: & &'self str) -> bool { gt((*self), (*other)) }\n+    fn gt(&self, other: & &'self str) -> bool { gt((*self), (*other)) }\n }\n \n #[cfg(notest)]\n impl Ord for @str {\n     #[inline(always)]\n-    pure fn lt(&self, other: &@str) -> bool { lt((*self), (*other)) }\n+    fn lt(&self, other: &@str) -> bool { lt((*self), (*other)) }\n     #[inline(always)]\n-    pure fn le(&self, other: &@str) -> bool { le((*self), (*other)) }\n+    fn le(&self, other: &@str) -> bool { le((*self), (*other)) }\n     #[inline(always)]\n-    pure fn ge(&self, other: &@str) -> bool { ge((*self), (*other)) }\n+    fn ge(&self, other: &@str) -> bool { ge((*self), (*other)) }\n     #[inline(always)]\n-    pure fn gt(&self, other: &@str) -> bool { gt((*self), (*other)) }\n+    fn gt(&self, other: &@str) -> bool { gt((*self), (*other)) }\n }\n \n #[cfg(notest)]\n impl Equiv<~str> for &'self str {\n     #[inline(always)]\n-    pure fn equiv(&self, other: &~str) -> bool { eq_slice(*self, *other) }\n+    fn equiv(&self, other: &~str) -> bool { eq_slice(*self, *other) }\n }\n \n /*\n@@ -939,20 +939,20 @@ Section: Iterating through strings\n  * Return true if a predicate matches all characters or if the string\n  * contains no characters\n  */\n-pub pure fn all(s: &str, it: &fn(char) -> bool) -> bool {\n+pub fn all(s: &str, it: &fn(char) -> bool) -> bool {\n     all_between(s, 0u, len(s), it)\n }\n \n /**\n  * Return true if a predicate matches any character (and false if it\n  * matches none or there are no characters)\n  */\n-pub pure fn any(ss: &str, pred: &fn(char) -> bool) -> bool {\n+pub fn any(ss: &str, pred: &fn(char) -> bool) -> bool {\n     !all(ss, |cc| !pred(cc))\n }\n \n /// Apply a function to each character\n-pub pure fn map(ss: &str, ff: &fn(char) -> char) -> ~str {\n+pub fn map(ss: &str, ff: &fn(char) -> char) -> ~str {\n     let mut result = ~\"\";\n     unsafe {\n         reserve(&mut result, len(ss));\n@@ -965,13 +965,13 @@ pub pure fn map(ss: &str, ff: &fn(char) -> char) -> ~str {\n \n /// Iterate over the bytes in a string\n #[inline(always)]\n-pub pure fn each(s: &str, it: &fn(u8) -> bool) {\n+pub fn each(s: &str, it: &fn(u8) -> bool) {\n     eachi(s, |_i, b| it(b))\n }\n \n /// Iterate over the bytes in a string, with indices\n #[inline(always)]\n-pub pure fn eachi(s: &str, it: &fn(uint, u8) -> bool) {\n+pub fn eachi(s: &str, it: &fn(uint, u8) -> bool) {\n     let mut pos = 0;\n     let len = s.len();\n \n@@ -983,13 +983,13 @@ pub pure fn eachi(s: &str, it: &fn(uint, u8) -> bool) {\n \n /// Iterate over the bytes in a string in reverse\n #[inline(always)]\n-pub pure fn each_reverse(s: &str, it: &fn(u8) -> bool) {\n+pub fn each_reverse(s: &str, it: &fn(u8) -> bool) {\n     eachi_reverse(s, |_i, b| it(b) )\n }\n \n /// Iterate over the bytes in a string in reverse, with indices\n #[inline(always)]\n-pub pure fn eachi_reverse(s: &str, it: &fn(uint, u8) -> bool) {\n+pub fn eachi_reverse(s: &str, it: &fn(uint, u8) -> bool) {\n     let mut pos = s.len();\n     while pos > 0 {\n         pos -= 1;\n@@ -999,13 +999,13 @@ pub pure fn eachi_reverse(s: &str, it: &fn(uint, u8) -> bool) {\n \n /// Iterates over the chars in a string\n #[inline(always)]\n-pub pure fn each_char(s: &str, it: &fn(char) -> bool) {\n+pub fn each_char(s: &str, it: &fn(char) -> bool) {\n     each_chari(s, |_i, c| it(c))\n }\n \n /// Iterates over the chars in a string, with indices\n #[inline(always)]\n-pub pure fn each_chari(s: &str, it: &fn(uint, char) -> bool) {\n+pub fn each_chari(s: &str, it: &fn(uint, char) -> bool) {\n     let mut pos = 0;\n     let mut ch_pos = 0u;\n     let len = s.len();\n@@ -1019,7 +1019,7 @@ pub pure fn each_chari(s: &str, it: &fn(uint, char) -> bool) {\n \n /// Iterates over the chars in a string in reverse\n #[inline(always)]\n-pub pure fn each_char_reverse(s: &str, it: &fn(char) -> bool) {\n+pub fn each_char_reverse(s: &str, it: &fn(char) -> bool) {\n     let mut pos = 0;\n     let len = s.char_len();\n     while pos > 0 {\n@@ -1031,7 +1031,7 @@ pub pure fn each_char_reverse(s: &str, it: &fn(char) -> bool) {\n \n // Iterates over the chars in a string in reverse, with indices\n #[inline(always)]\n-pub pure fn each_chari_reverse(s: &str, it: &fn(uint, char) -> bool) {\n+pub fn each_chari_reverse(s: &str, it: &fn(uint, char) -> bool) {\n     let mut ch_pos = s.char_len();\n     for s.each_char_reverse |ch| {\n         ch_pos -= 1;\n@@ -1040,28 +1040,28 @@ pub pure fn each_chari_reverse(s: &str, it: &fn(uint, char) -> bool) {\n }\n \n /// Apply a function to each substring after splitting by character\n-pub pure fn split_char_each(ss: &str, cc: char, ff: &fn(v: &str) -> bool) {\n+pub fn split_char_each(ss: &str, cc: char, ff: &fn(v: &str) -> bool) {\n     vec::each(split_char(ss, cc), |s| ff(*s))\n }\n \n /**\n  * Apply a function to each substring after splitting by character, up to\n  * `count` times\n  */\n-pub pure fn splitn_char_each(ss: &str, sep: char, count: uint,\n+pub fn splitn_char_each(ss: &str, sep: char, count: uint,\n                          ff: &fn(v: &str) -> bool) {\n     vec::each(splitn_char(ss, sep, count), |s| ff(*s))\n }\n \n /// Apply a function to each word\n-pub pure fn words_each(ss: &str, ff: &fn(v: &str) -> bool) {\n+pub fn words_each(ss: &str, ff: &fn(v: &str) -> bool) {\n     vec::each(words(ss), |s| ff(*s))\n }\n \n /**\n  * Apply a function to each line (by '\\n')\n  */\n-pub pure fn lines_each(ss: &str, ff: &fn(v: &str) -> bool) {\n+pub fn lines_each(ss: &str, ff: &fn(v: &str) -> bool) {\n     vec::each(lines(ss), |s| ff(*s))\n }\n \n@@ -1082,7 +1082,7 @@ Section: Searching\n  * An `option` containing the byte index of the first matching character\n  * or `none` if there is no match\n  */\n-pub pure fn find_char(s: &str, c: char) -> Option<uint> {\n+pub fn find_char(s: &str, c: char) -> Option<uint> {\n     find_char_between(s, c, 0u, len(s))\n }\n \n@@ -1106,7 +1106,7 @@ pub pure fn find_char(s: &str, c: char) -> Option<uint> {\n  * `start` must be less than or equal to `len(s)`. `start` must be the\n  * index of a character boundary, as defined by `is_char_boundary`.\n  */\n-pub pure fn find_char_from(s: &str, c: char, start: uint) -> Option<uint> {\n+pub fn find_char_from(s: &str, c: char, start: uint) -> Option<uint> {\n     find_char_between(s, c, start, len(s))\n }\n \n@@ -1131,7 +1131,7 @@ pub pure fn find_char_from(s: &str, c: char, start: uint) -> Option<uint> {\n  * or equal to `len(s)`. `start` must be the index of a character boundary,\n  * as defined by `is_char_boundary`.\n  */\n-pub pure fn find_char_between(s: &str, c: char, start: uint, end: uint)\n+pub fn find_char_between(s: &str, c: char, start: uint, end: uint)\n     -> Option<uint> {\n     if c < 128u as char {\n         fail_unless!(start <= end);\n@@ -1161,7 +1161,7 @@ pub pure fn find_char_between(s: &str, c: char, start: uint, end: uint)\n  * An `option` containing the byte index of the last matching character\n  * or `none` if there is no match\n  */\n-pub pure fn rfind_char(s: &str, c: char) -> Option<uint> {\n+pub fn rfind_char(s: &str, c: char) -> Option<uint> {\n     rfind_char_between(s, c, len(s), 0u)\n }\n \n@@ -1185,7 +1185,7 @@ pub pure fn rfind_char(s: &str, c: char) -> Option<uint> {\n  * `start` must be less than or equal to `len(s)`. `start` must be\n  * the index of a character boundary, as defined by `is_char_boundary`.\n  */\n-pub pure fn rfind_char_from(s: &str, c: char, start: uint) -> Option<uint> {\n+pub fn rfind_char_from(s: &str, c: char, start: uint) -> Option<uint> {\n     rfind_char_between(s, c, start, 0u)\n }\n \n@@ -1210,7 +1210,7 @@ pub pure fn rfind_char_from(s: &str, c: char, start: uint) -> Option<uint> {\n  * or equal to `len(s)`. `start` must be the index of a character boundary,\n  * as defined by `is_char_boundary`.\n  */\n-pub pure fn rfind_char_between(s: &str, c: char, start: uint, end: uint)\n+pub fn rfind_char_between(s: &str, c: char, start: uint, end: uint)\n     -> Option<uint> {\n     if c < 128u as char {\n         fail_unless!(start >= end);\n@@ -1241,7 +1241,7 @@ pub pure fn rfind_char_between(s: &str, c: char, start: uint, end: uint)\n  * An `option` containing the byte index of the first matching character\n  * or `none` if there is no match\n  */\n-pub pure fn find(s: &str, f: &fn(char) -> bool) -> Option<uint> {\n+pub fn find(s: &str, f: &fn(char) -> bool) -> Option<uint> {\n     find_between(s, 0u, len(s), f)\n }\n \n@@ -1265,7 +1265,7 @@ pub pure fn find(s: &str, f: &fn(char) -> bool) -> Option<uint> {\n  * `start` must be less than or equal to `len(s)`. `start` must be the\n  * index of a character boundary, as defined by `is_char_boundary`.\n  */\n-pub pure fn find_from(s: &str, start: uint, f: &fn(char)\n+pub fn find_from(s: &str, start: uint, f: &fn(char)\n     -> bool) -> Option<uint> {\n     find_between(s, start, len(s), f)\n }\n@@ -1292,7 +1292,7 @@ pub pure fn find_from(s: &str, start: uint, f: &fn(char)\n  * or equal to `len(s)`. `start` must be the index of a character\n  * boundary, as defined by `is_char_boundary`.\n  */\n-pub pure fn find_between(s: &str,\n+pub fn find_between(s: &str,\n                          start: uint,\n                          end: uint,\n                          f: &fn(char) -> bool)\n@@ -1323,7 +1323,7 @@ pub pure fn find_between(s: &str,\n  * An option containing the byte index of the last matching character\n  * or `none` if there is no match\n  */\n-pub pure fn rfind(s: &str, f: &fn(char) -> bool) -> Option<uint> {\n+pub fn rfind(s: &str, f: &fn(char) -> bool) -> Option<uint> {\n     rfind_between(s, len(s), 0u, f)\n }\n \n@@ -1347,7 +1347,7 @@ pub pure fn rfind(s: &str, f: &fn(char) -> bool) -> Option<uint> {\n  * `start` must be less than or equal to `len(s)', `start` must be the\n  * index of a character boundary, as defined by `is_char_boundary`\n  */\n-pub pure fn rfind_from(s: &str, start: uint, f: &fn(char) -> bool)\n+pub fn rfind_from(s: &str, start: uint, f: &fn(char) -> bool)\n     -> Option<uint> {\n     rfind_between(s, start, 0u, f)\n }\n@@ -1374,7 +1374,7 @@ pub pure fn rfind_from(s: &str, start: uint, f: &fn(char) -> bool)\n  * than or equal to `len(s)`. `start` must be the index of a character\n  * boundary, as defined by `is_char_boundary`\n  */\n-pub pure fn rfind_between(s: &str, start: uint, end: uint,\n+pub fn rfind_between(s: &str, start: uint, end: uint,\n                           f: &fn(char) -> bool)\n     -> Option<uint> {\n     fail_unless!(start >= end);\n@@ -1390,7 +1390,7 @@ pub pure fn rfind_between(s: &str, start: uint, end: uint,\n }\n \n // Utility used by various searching functions\n-pure fn match_at(haystack: &'a str, needle: &'b str, at: uint) -> bool {\n+fn match_at(haystack: &'a str, needle: &'b str, at: uint) -> bool {\n     let mut i = at;\n     for each(needle) |c| { if haystack[i] != c { return false; } i += 1u; }\n     return true;\n@@ -1409,7 +1409,7 @@ pure fn match_at(haystack: &'a str, needle: &'b str, at: uint) -> bool {\n  * An `option` containing the byte index of the first matching substring\n  * or `none` if there is no match\n  */\n-pub pure fn find_str(haystack: &'a str, needle: &'b str) -> Option<uint> {\n+pub fn find_str(haystack: &'a str, needle: &'b str) -> Option<uint> {\n     find_str_between(haystack, needle, 0u, len(haystack))\n }\n \n@@ -1432,7 +1432,7 @@ pub pure fn find_str(haystack: &'a str, needle: &'b str) -> Option<uint> {\n  *\n  * `start` must be less than or equal to `len(s)`\n  */\n-pub pure fn find_str_from(haystack: &'a str, needle: &'b str, start: uint)\n+pub fn find_str_from(haystack: &'a str, needle: &'b str, start: uint)\n   -> Option<uint> {\n     find_str_between(haystack, needle, start, len(haystack))\n }\n@@ -1457,7 +1457,7 @@ pub pure fn find_str_from(haystack: &'a str, needle: &'b str, start: uint)\n  * `start` must be less than or equal to `end` and `end` must be less than\n  * or equal to `len(s)`.\n  */\n-pub pure fn find_str_between(haystack: &'a str, needle: &'b str, start: uint,\n+pub fn find_str_between(haystack: &'a str, needle: &'b str, start: uint,\n                          end:uint)\n   -> Option<uint> {\n     // See Issue #1932 for why this is a naive search\n@@ -1483,7 +1483,7 @@ pub pure fn find_str_between(haystack: &'a str, needle: &'b str, start: uint,\n  * * haystack - The string to look in\n  * * needle - The string to look for\n  */\n-pub pure fn contains(haystack: &'a str, needle: &'b str) -> bool {\n+pub fn contains(haystack: &'a str, needle: &'b str) -> bool {\n     find_str(haystack, needle).is_some()\n }\n \n@@ -1495,7 +1495,7 @@ pub pure fn contains(haystack: &'a str, needle: &'b str) -> bool {\n  * * haystack - The string to look in\n  * * needle - The char to look for\n  */\n-pub pure fn contains_char(haystack: &str, needle: char) -> bool {\n+pub fn contains_char(haystack: &str, needle: char) -> bool {\n     find_char(haystack, needle).is_some()\n }\n \n@@ -1507,7 +1507,7 @@ pub pure fn contains_char(haystack: &str, needle: char) -> bool {\n  * * haystack - The string to look in\n  * * needle - The string to look for\n  */\n-pub pure fn starts_with(haystack: &'a str, needle: &'b str) -> bool {\n+pub fn starts_with(haystack: &'a str, needle: &'b str) -> bool {\n     let haystack_len = len(haystack), needle_len = len(needle);\n     if needle_len == 0u { true }\n     else if needle_len > haystack_len { false }\n@@ -1522,7 +1522,7 @@ pub pure fn starts_with(haystack: &'a str, needle: &'b str) -> bool {\n  * * haystack - The string to look in\n  * * needle - The string to look for\n  */\n-pub pure fn ends_with(haystack: &'a str, needle: &'b str) -> bool {\n+pub fn ends_with(haystack: &'a str, needle: &'b str) -> bool {\n     let haystack_len = len(haystack), needle_len = len(needle);\n     if needle_len == 0u { true }\n     else if needle_len > haystack_len { false }\n@@ -1534,21 +1534,21 @@ Section: String properties\n */\n \n /// Determines if a string contains only ASCII characters\n-pub pure fn is_ascii(s: &str) -> bool {\n+pub fn is_ascii(s: &str) -> bool {\n     let mut i: uint = len(s);\n     while i > 0u { i -= 1u; if !u8::is_ascii(s[i]) { return false; } }\n     return true;\n }\n \n /// Returns true if the string has length 0\n-pub pure fn is_empty(s: &str) -> bool { len(s) == 0u }\n+pub fn is_empty(s: &str) -> bool { len(s) == 0u }\n \n /**\n  * Returns true if the string contains only whitespace\n  *\n  * Whitespace characters are determined by `char::is_whitespace`\n  */\n-pub pure fn is_whitespace(s: &str) -> bool {\n+pub fn is_whitespace(s: &str) -> bool {\n     return all(s, char::is_whitespace);\n }\n \n@@ -1557,24 +1557,24 @@ pub pure fn is_whitespace(s: &str) -> bool {\n  *\n  * Alphanumeric characters are determined by `char::is_alphanumeric`\n  */\n-pure fn is_alphanumeric(s: &str) -> bool {\n+fn is_alphanumeric(s: &str) -> bool {\n     return all(s, char::is_alphanumeric);\n }\n \n /// Returns the string length/size in bytes not counting the null terminator\n-pub pure fn len(s: &str) -> uint {\n+pub fn len(s: &str) -> uint {\n     do as_buf(s) |_p, n| { n - 1u }\n }\n \n /// Returns the number of characters that a string holds\n-pub pure fn char_len(s: &str) -> uint { count_chars(s, 0u, len(s)) }\n+pub fn char_len(s: &str) -> uint { count_chars(s, 0u, len(s)) }\n \n /*\n Section: Misc\n */\n \n /// Determines if a vector of bytes contains valid UTF-8\n-pub pure fn is_utf8(v: &[const u8]) -> bool {\n+pub fn is_utf8(v: &[const u8]) -> bool {\n     let mut i = 0u;\n     let total = vec::len::<u8>(v);\n     while i < total {\n@@ -1592,7 +1592,7 @@ pub pure fn is_utf8(v: &[const u8]) -> bool {\n }\n \n /// Determines if a vector of `u16` contains valid UTF-16\n-pub pure fn is_utf16(v: &[u16]) -> bool {\n+pub fn is_utf16(v: &[u16]) -> bool {\n     let len = vec::len(v);\n     let mut i = 0u;\n     while (i < len) {\n@@ -1613,7 +1613,7 @@ pub pure fn is_utf16(v: &[u16]) -> bool {\n }\n \n /// Converts to a vector of `u16` encoded as UTF-16\n-pub pure fn to_utf16(s: &str) -> ~[u16] {\n+pub fn to_utf16(s: &str) -> ~[u16] {\n     let mut u = ~[];\n     for s.each_char |ch| {\n         // Arithmetic with u32 literals is easier on the eyes than chars.\n@@ -1638,7 +1638,7 @@ pub pure fn to_utf16(s: &str) -> ~[u16] {\n     u\n }\n \n-pub pure fn utf16_chars(v: &[u16], f: &fn(char)) {\n+pub fn utf16_chars(v: &[u16], f: &fn(char)) {\n     let len = vec::len(v);\n     let mut i = 0u;\n     while (i < len && v[i] != 0u16) {\n@@ -1663,7 +1663,7 @@ pub pure fn utf16_chars(v: &[u16], f: &fn(char)) {\n }\n \n \n-pub pure fn from_utf16(v: &[u16]) -> ~str {\n+pub fn from_utf16(v: &[u16]) -> ~str {\n     let mut buf = ~\"\";\n     unsafe {\n         reserve(&mut buf, vec::len(v));\n@@ -1672,7 +1672,7 @@ pub pure fn from_utf16(v: &[u16]) -> ~str {\n     buf\n }\n \n-pub pure fn with_capacity(capacity: uint) -> ~str {\n+pub fn with_capacity(capacity: uint) -> ~str {\n     let mut buf = ~\"\";\n     unsafe { reserve(&mut buf, capacity); }\n     buf\n@@ -1691,7 +1691,7 @@ pub pure fn with_capacity(capacity: uint) -> ~str {\n  *\n  * The number of Unicode characters in `s` between the given indices.\n  */\n-pub pure fn count_chars(s: &str, start: uint, end: uint) -> uint {\n+pub fn count_chars(s: &str, start: uint, end: uint) -> uint {\n     fail_unless!(is_char_boundary(s, start));\n     fail_unless!(is_char_boundary(s, end));\n     let mut i = start, len = 0u;\n@@ -1704,7 +1704,7 @@ pub pure fn count_chars(s: &str, start: uint, end: uint) -> uint {\n }\n \n /// Counts the number of bytes taken by the `n` in `s` starting from `start`.\n-pub pure fn count_bytes(s: &'b str, start: uint, n: uint) -> uint {\n+pub fn count_bytes(s: &'b str, start: uint, n: uint) -> uint {\n     fail_unless!(is_char_boundary(s, start));\n     let mut end = start, cnt = n;\n     let l = len(s);\n@@ -1718,7 +1718,7 @@ pub pure fn count_bytes(s: &'b str, start: uint, n: uint) -> uint {\n }\n \n /// Given a first byte, determine how many bytes are in this UTF-8 character\n-pub pure fn utf8_char_width(b: u8) -> uint {\n+pub fn utf8_char_width(b: u8) -> uint {\n     let byte: uint = b as uint;\n     if byte < 128u { return 1u; }\n     // Not a valid start byte\n@@ -1734,7 +1734,7 @@ pub pure fn utf8_char_width(b: u8) -> uint {\n  * Returns false if the index points into the middle of a multi-byte\n  * character sequence.\n  */\n-pub pure fn is_char_boundary(s: &str, index: uint) -> bool {\n+pub fn is_char_boundary(s: &str, index: uint) -> bool {\n     if index == len(s) { return true; }\n     let b = s[index];\n     return b < 128u8 || b >= 192u8;\n@@ -1789,7 +1789,7 @@ pub pure fn is_char_boundary(s: &str, index: uint) -> bool {\n  * If `i` is greater than or equal to the length of the string.\n  * If `i` is not the index of the beginning of a valid UTF-8 character.\n  */\n-pub pure fn char_range_at(s: &str, i: uint) -> CharRange {\n+pub fn char_range_at(s: &str, i: uint) -> CharRange {\n     let b0 = s[i];\n     let w = utf8_char_width(b0);\n     fail_unless!((w != 0u));\n@@ -1812,7 +1812,7 @@ pub pure fn char_range_at(s: &str, i: uint) -> CharRange {\n }\n \n /// Plucks the `n`th character from the beginning of a string\n-pub pure fn char_at(s: &str, i: uint) -> char {\n+pub fn char_at(s: &str, i: uint) -> char {\n     return char_range_at(s, i).ch;\n }\n \n@@ -1826,7 +1826,7 @@ pub struct CharRange {\n  *\n  * This function can be used to iterate over a unicode string in reverse.\n  */\n-pure fn char_range_at_reverse(ss: &str, start: uint) -> CharRange {\n+fn char_range_at_reverse(ss: &str, start: uint) -> CharRange {\n     let mut prev = start;\n \n     // while there is a previous byte == 10......\n@@ -1842,7 +1842,7 @@ pure fn char_range_at_reverse(ss: &str, start: uint) -> CharRange {\n }\n \n /// Plucks the `n`th character from the end of a string\n-pub pure fn char_at_reverse(s: &str, i: uint) -> char {\n+pub fn char_at_reverse(s: &str, i: uint) -> char {\n     char_range_at_reverse(s, i).ch\n }\n \n@@ -1868,7 +1868,7 @@ pub pure fn char_at_reverse(s: &str, i: uint) -> char {\n  * `true` If execution proceeded correctly, `false` if it was interrupted,\n  * that is if `it` returned `false` at any point.\n  */\n-pub pure fn all_between(s: &str, start: uint, end: uint,\n+pub fn all_between(s: &str, start: uint, end: uint,\n                     it: &fn(char) -> bool) -> bool {\n     fail_unless!(is_char_boundary(s, start));\n     let mut i = start;\n@@ -1901,7 +1901,7 @@ pub pure fn all_between(s: &str, start: uint, end: uint,\n  *\n  * `true` if `it` returns `true` for any character\n  */\n-pub pure fn any_between(s: &str, start: uint, end: uint,\n+pub fn any_between(s: &str, start: uint, end: uint,\n                     it: &fn(char) -> bool) -> bool {\n     !all_between(s, start, end, |c| !it(c))\n }\n@@ -1940,7 +1940,7 @@ pub const nan_buf: [u8*3] = ['N' as u8, 'a' as u8, 'N' as u8];\n  * let i = str::as_bytes(\"Hello World\") { |bytes| vec::len(bytes) };\n  * ~~~\n  */\n-pub pure fn as_bytes<T>(s: &const ~str, f: &fn(&~[u8]) -> T) -> T {\n+pub fn as_bytes<T>(s: &const ~str, f: &fn(&~[u8]) -> T) -> T {\n     unsafe {\n         let v: *~[u8] = cast::transmute(copy s);\n         f(&*v)\n@@ -1952,7 +1952,7 @@ pub pure fn as_bytes<T>(s: &const ~str, f: &fn(&~[u8]) -> T) -> T {\n  *\n  * The byte slice does not include the null terminator.\n  */\n-pub pure fn as_bytes_slice(s: &'a str) -> &'a [u8] {\n+pub fn as_bytes_slice(s: &'a str) -> &'a [u8] {\n     unsafe {\n         let (ptr, len): (*u8, uint) = ::cast::reinterpret_cast(&s);\n         let outgoing_tuple: (*u8, uint) = (ptr, len - 1);\n@@ -1975,7 +1975,7 @@ pub pure fn as_bytes_slice(s: &'a str) -> &'a [u8] {\n  * let s = str::as_c_str(\"PATH\", { |path| libc::getenv(path) });\n  * ~~~\n  */\n-pub pure fn as_c_str<T>(s: &str, f: &fn(*libc::c_char) -> T) -> T {\n+pub fn as_c_str<T>(s: &str, f: &fn(*libc::c_char) -> T) -> T {\n     do as_buf(s) |buf, len| {\n         // NB: len includes the trailing null.\n         fail_unless!(len > 0);\n@@ -1997,7 +1997,7 @@ pub pure fn as_c_str<T>(s: &str, f: &fn(*libc::c_char) -> T) -> T {\n  * to full strings, or suffixes of them.\n  */\n #[inline(always)]\n-pub pure fn as_buf<T>(s: &str, f: &fn(*u8, uint) -> T) -> T {\n+pub fn as_buf<T>(s: &str, f: &fn(*u8, uint) -> T) -> T {\n     unsafe {\n         let v : *(*u8,uint) = ::cast::reinterpret_cast(&ptr::addr_of(&s));\n         let (buf,len) = *v;\n@@ -2056,7 +2056,7 @@ pub fn reserve_at_least(s: &mut ~str, n: uint) {\n  * Returns the number of single-byte characters the string can hold without\n  * reallocating\n  */\n-pub pure fn capacity(s: &const ~str) -> uint {\n+pub fn capacity(s: &const ~str) -> uint {\n     do as_bytes(s) |buf| {\n         let vcap = vec::capacity(buf);\n         fail_unless!(vcap > 0u);\n@@ -2065,7 +2065,7 @@ pub pure fn capacity(s: &const ~str) -> uint {\n }\n \n /// Escape each char in `s` with char::escape_default.\n-pub pure fn escape_default(s: &str) -> ~str {\n+pub fn escape_default(s: &str) -> ~str {\n     let mut out: ~str = ~\"\";\n     unsafe {\n         reserve_at_least(&mut out, str::len(s));\n@@ -2077,7 +2077,7 @@ pub pure fn escape_default(s: &str) -> ~str {\n }\n \n /// Escape each char in `s` with char::escape_unicode.\n-pub pure fn escape_unicode(s: &str) -> ~str {\n+pub fn escape_unicode(s: &str) -> ~str {\n     let mut out: ~str = ~\"\";\n     unsafe {\n         reserve_at_least(&mut out, str::len(s));\n@@ -2263,7 +2263,7 @@ pub mod traits {\n \n     impl Add<&'self str,~str> for ~str {\n         #[inline(always)]\n-        pure fn add(&self, rhs: & &'self str) -> ~str {\n+        fn add(&self, rhs: & &'self str) -> ~str {\n             append(copy *self, (*rhs))\n         }\n     }\n@@ -2273,44 +2273,44 @@ pub mod traits {\n pub mod traits {}\n \n pub trait StrSlice {\n-    pure fn all(&self, it: &fn(char) -> bool) -> bool;\n-    pure fn any(&self, it: &fn(char) -> bool) -> bool;\n-    pure fn contains(&self, needle: &'a str) -> bool;\n-    pure fn contains_char(&self, needle: char) -> bool;\n-    pure fn each(&self, it: &fn(u8) -> bool);\n-    pure fn eachi(&self, it: &fn(uint, u8) -> bool);\n-    pure fn each_reverse(&self, it: &fn(u8) -> bool);\n-    pure fn eachi_reverse(&self, it: &fn(uint, u8) -> bool);\n-    pure fn each_char(&self, it: &fn(char) -> bool);\n-    pure fn each_chari(&self, it: &fn(uint, char) -> bool);\n-    pure fn each_char_reverse(&self, it: &fn(char) -> bool);\n-    pure fn each_chari_reverse(&self, it: &fn(uint, char) -> bool);\n-    pure fn ends_with(&self, needle: &str) -> bool;\n-    pure fn is_empty(&self) -> bool;\n-    pure fn is_whitespace(&self) -> bool;\n-    pure fn is_alphanumeric(&self) -> bool;\n-    pure fn len(&self) -> uint;\n-    pure fn char_len(&self) -> uint;\n-    pure fn slice(&self, begin: uint, end: uint) -> &'self str;\n-    pure fn split(&self, sepfn: &fn(char) -> bool) -> ~[~str];\n-    pure fn split_char(&self, sep: char) -> ~[~str];\n-    pure fn split_str(&self, sep: &'a str) -> ~[~str];\n-    pure fn starts_with(&self, needle: &'a str) -> bool;\n-    pure fn substr(&self, begin: uint, n: uint) -> &'self str;\n-    pure fn to_lower(&self) -> ~str;\n-    pure fn to_upper(&self) -> ~str;\n-    pure fn escape_default(&self) -> ~str;\n-    pure fn escape_unicode(&self) -> ~str;\n-    pure fn trim(&self) -> &'self str;\n-    pure fn trim_left(&self) -> &'self str;\n-    pure fn trim_right(&self) -> &'self str;\n-    pure fn trim_chars(&self, chars_to_trim: &[char]) -> &'self str;\n-    pure fn trim_left_chars(&self, chars_to_trim: &[char]) -> &'self str;\n-    pure fn trim_right_chars(&self, chars_to_trim: &[char]) -> &'self str;\n-    pure fn to_owned(&self) -> ~str;\n-    pure fn to_managed(&self) -> @str;\n-    pure fn char_at(&self, i: uint) -> char;\n-    pure fn char_at_reverse(&self, i: uint) -> char;\n+    fn all(&self, it: &fn(char) -> bool) -> bool;\n+    fn any(&self, it: &fn(char) -> bool) -> bool;\n+    fn contains(&self, needle: &'a str) -> bool;\n+    fn contains_char(&self, needle: char) -> bool;\n+    fn each(&self, it: &fn(u8) -> bool);\n+    fn eachi(&self, it: &fn(uint, u8) -> bool);\n+    fn each_reverse(&self, it: &fn(u8) -> bool);\n+    fn eachi_reverse(&self, it: &fn(uint, u8) -> bool);\n+    fn each_char(&self, it: &fn(char) -> bool);\n+    fn each_chari(&self, it: &fn(uint, char) -> bool);\n+    fn each_char_reverse(&self, it: &fn(char) -> bool);\n+    fn each_chari_reverse(&self, it: &fn(uint, char) -> bool);\n+    fn ends_with(&self, needle: &str) -> bool;\n+    fn is_empty(&self) -> bool;\n+    fn is_whitespace(&self) -> bool;\n+    fn is_alphanumeric(&self) -> bool;\n+    fn len(&self) -> uint;\n+    fn char_len(&self) -> uint;\n+    fn slice(&self, begin: uint, end: uint) -> &'self str;\n+    fn split(&self, sepfn: &fn(char) -> bool) -> ~[~str];\n+    fn split_char(&self, sep: char) -> ~[~str];\n+    fn split_str(&self, sep: &'a str) -> ~[~str];\n+    fn starts_with(&self, needle: &'a str) -> bool;\n+    fn substr(&self, begin: uint, n: uint) -> &'self str;\n+    fn to_lower(&self) -> ~str;\n+    fn to_upper(&self) -> ~str;\n+    fn escape_default(&self) -> ~str;\n+    fn escape_unicode(&self) -> ~str;\n+    fn trim(&self) -> &'self str;\n+    fn trim_left(&self) -> &'self str;\n+    fn trim_right(&self) -> &'self str;\n+    fn trim_chars(&self, chars_to_trim: &[char]) -> &'self str;\n+    fn trim_left_chars(&self, chars_to_trim: &[char]) -> &'self str;\n+    fn trim_right_chars(&self, chars_to_trim: &[char]) -> &'self str;\n+    fn to_owned(&self) -> ~str;\n+    fn to_managed(&self) -> @str;\n+    fn char_at(&self, i: uint) -> char;\n+    fn char_at_reverse(&self, i: uint) -> char;\n     fn to_bytes(&self) -> ~[u8];\n }\n \n@@ -2321,86 +2321,86 @@ impl StrSlice for &'self str {\n      * contains no characters\n      */\n     #[inline]\n-    pure fn all(&self, it: &fn(char) -> bool) -> bool { all(*self, it) }\n+    fn all(&self, it: &fn(char) -> bool) -> bool { all(*self, it) }\n     /**\n      * Return true if a predicate matches any character (and false if it\n      * matches none or there are no characters)\n      */\n     #[inline]\n-    pure fn any(&self, it: &fn(char) -> bool) -> bool { any(*self, it) }\n+    fn any(&self, it: &fn(char) -> bool) -> bool { any(*self, it) }\n     /// Returns true if one string contains another\n     #[inline]\n-    pure fn contains(&self, needle: &'a str) -> bool {\n+    fn contains(&self, needle: &'a str) -> bool {\n         contains(*self, needle)\n     }\n     /// Returns true if a string contains a char\n     #[inline]\n-    pure fn contains_char(&self, needle: char) -> bool {\n+    fn contains_char(&self, needle: char) -> bool {\n         contains_char(*self, needle)\n     }\n     /// Iterate over the bytes in a string\n     #[inline]\n-    pure fn each(&self, it: &fn(u8) -> bool) { each(*self, it) }\n+    fn each(&self, it: &fn(u8) -> bool) { each(*self, it) }\n     /// Iterate over the bytes in a string, with indices\n     #[inline]\n-    pure fn eachi(&self, it: &fn(uint, u8) -> bool) { eachi(*self, it) }\n+    fn eachi(&self, it: &fn(uint, u8) -> bool) { eachi(*self, it) }\n     /// Iterate over the bytes in a string\n     #[inline]\n-    pure fn each_reverse(&self, it: &fn(u8) -> bool) {\n+    fn each_reverse(&self, it: &fn(u8) -> bool) {\n         each_reverse(*self, it)\n     }\n     /// Iterate over the bytes in a string, with indices\n     #[inline]\n-    pure fn eachi_reverse(&self, it: &fn(uint, u8) -> bool) {\n+    fn eachi_reverse(&self, it: &fn(uint, u8) -> bool) {\n         eachi_reverse(*self, it)\n     }\n     /// Iterate over the chars in a string\n     #[inline]\n-    pure fn each_char(&self, it: &fn(char) -> bool) { each_char(*self, it) }\n+    fn each_char(&self, it: &fn(char) -> bool) { each_char(*self, it) }\n     /// Iterate over the chars in a string, with indices\n     #[inline]\n-    pure fn each_chari(&self, it: &fn(uint, char) -> bool) {\n+    fn each_chari(&self, it: &fn(uint, char) -> bool) {\n         each_chari(*self, it)\n     }\n     /// Iterate over the chars in a string in reverse\n     #[inline]\n-    pure fn each_char_reverse(&self, it: &fn(char) -> bool) {\n+    fn each_char_reverse(&self, it: &fn(char) -> bool) {\n         each_char_reverse(*self, it)\n     }\n     /// Iterate over the chars in a string in reverse, with indices from the\n     /// end\n     #[inline]\n-    pure fn each_chari_reverse(&self, it: &fn(uint, char) -> bool) {\n+    fn each_chari_reverse(&self, it: &fn(uint, char) -> bool) {\n         each_chari_reverse(*self, it)\n     }\n     /// Returns true if one string ends with another\n     #[inline]\n-    pure fn ends_with(&self, needle: &str) -> bool {\n+    fn ends_with(&self, needle: &str) -> bool {\n         ends_with(*self, needle)\n     }\n     /// Returns true if the string has length 0\n     #[inline]\n-    pure fn is_empty(&self) -> bool { is_empty(*self) }\n+    fn is_empty(&self) -> bool { is_empty(*self) }\n     /**\n      * Returns true if the string contains only whitespace\n      *\n      * Whitespace characters are determined by `char::is_whitespace`\n      */\n     #[inline]\n-    pure fn is_whitespace(&self) -> bool { is_whitespace(*self) }\n+    fn is_whitespace(&self) -> bool { is_whitespace(*self) }\n     /**\n      * Returns true if the string contains only alphanumerics\n      *\n      * Alphanumeric characters are determined by `char::is_alphanumeric`\n      */\n     #[inline]\n-    pure fn is_alphanumeric(&self) -> bool { is_alphanumeric(*self) }\n+    fn is_alphanumeric(&self) -> bool { is_alphanumeric(*self) }\n     /// Returns the size in bytes not counting the null terminator\n     #[inline]\n-    pure fn len(&self) -> uint { len(*self) }\n+    fn len(&self) -> uint { len(*self) }\n     /// Returns the number of characters that a string holds\n     #[inline]\n-    pure fn char_len(&self) -> uint { char_len(*self) }\n+    fn char_len(&self) -> uint { char_len(*self) }\n     /**\n      * Returns a slice of the given string from the byte range\n      * [`begin`..`end`)\n@@ -2409,28 +2409,28 @@ impl StrSlice for &'self str {\n      * beyond the last character of the string\n      */\n     #[inline]\n-    pure fn slice(&self, begin: uint, end: uint) -> &'self str {\n+    fn slice(&self, begin: uint, end: uint) -> &'self str {\n         slice(*self, begin, end)\n     }\n     /// Splits a string into substrings using a character function\n     #[inline]\n-    pure fn split(&self, sepfn: &fn(char) -> bool) -> ~[~str] {\n+    fn split(&self, sepfn: &fn(char) -> bool) -> ~[~str] {\n         split(*self, sepfn)\n     }\n     /**\n      * Splits a string into substrings at each occurrence of a given character\n      */\n     #[inline]\n-    pure fn split_char(&self, sep: char) -> ~[~str] { split_char(*self, sep) }\n+    fn split_char(&self, sep: char) -> ~[~str] { split_char(*self, sep) }\n     /**\n      * Splits a string into a vector of the substrings separated by a given\n      * string\n      */\n     #[inline]\n-    pure fn split_str(&self, sep: &'a str) -> ~[~str] { split_str(*self, sep) }\n+    fn split_str(&self, sep: &'a str) -> ~[~str] { split_str(*self, sep) }\n     /// Returns true if one string starts with another\n     #[inline]\n-    pure fn starts_with(&self, needle: &'a str) -> bool {\n+    fn starts_with(&self, needle: &'a str) -> bool {\n         starts_with(*self, needle)\n     }\n     /**\n@@ -2440,62 +2440,62 @@ impl StrSlice for &'self str {\n      * `begin`.\n      */\n     #[inline]\n-    pure fn substr(&self, begin: uint, n: uint) -> &'self str {\n+    fn substr(&self, begin: uint, n: uint) -> &'self str {\n         substr(*self, begin, n)\n     }\n     /// Convert a string to lowercase\n     #[inline]\n-    pure fn to_lower(&self) -> ~str { to_lower(*self) }\n+    fn to_lower(&self) -> ~str { to_lower(*self) }\n     /// Convert a string to uppercase\n     #[inline]\n-    pure fn to_upper(&self) -> ~str { to_upper(*self) }\n+    fn to_upper(&self) -> ~str { to_upper(*self) }\n     /// Escape each char in `s` with char::escape_default.\n     #[inline]\n-    pure fn escape_default(&self) -> ~str { escape_default(*self) }\n+    fn escape_default(&self) -> ~str { escape_default(*self) }\n     /// Escape each char in `s` with char::escape_unicode.\n     #[inline]\n-    pure fn escape_unicode(&self) -> ~str { escape_unicode(*self) }\n+    fn escape_unicode(&self) -> ~str { escape_unicode(*self) }\n \n     /// Returns a string with leading and trailing whitespace removed\n     #[inline]\n-    pure fn trim(&self) -> &'self str { trim(*self) }\n+    fn trim(&self) -> &'self str { trim(*self) }\n     /// Returns a string with leading whitespace removed\n     #[inline]\n-    pure fn trim_left(&self) -> &'self str { trim_left(*self) }\n+    fn trim_left(&self) -> &'self str { trim_left(*self) }\n     /// Returns a string with trailing whitespace removed\n     #[inline]\n-    pure fn trim_right(&self) -> &'self str { trim_right(*self) }\n+    fn trim_right(&self) -> &'self str { trim_right(*self) }\n \n     #[inline]\n-    pure fn trim_chars(&self, chars_to_trim: &[char]) -> &'self str {\n+    fn trim_chars(&self, chars_to_trim: &[char]) -> &'self str {\n         trim_chars(*self, chars_to_trim)\n     }\n     #[inline]\n-    pure fn trim_left_chars(&self, chars_to_trim: &[char]) -> &'self str {\n+    fn trim_left_chars(&self, chars_to_trim: &[char]) -> &'self str {\n         trim_left_chars(*self, chars_to_trim)\n     }\n     #[inline]\n-    pure fn trim_right_chars(&self, chars_to_trim: &[char]) -> &'self str {\n+    fn trim_right_chars(&self, chars_to_trim: &[char]) -> &'self str {\n         trim_right_chars(*self, chars_to_trim)\n     }\n \n \n     #[inline]\n-    pure fn to_owned(&self) -> ~str { from_slice(*self) }\n+    fn to_owned(&self) -> ~str { from_slice(*self) }\n \n     #[inline]\n-    pure fn to_managed(&self) -> @str {\n+    fn to_managed(&self) -> @str {\n         let v = at_vec::from_fn(self.len() + 1, |i| {\n             if i == self.len() { 0 } else { self[i] }\n         });\n         unsafe { ::cast::transmute(v) }\n     }\n \n     #[inline]\n-    pure fn char_at(&self, i: uint) -> char { char_at(*self, i) }\n+    fn char_at(&self, i: uint) -> char { char_at(*self, i) }\n \n     #[inline]\n-    pure fn char_at_reverse(&self, i: uint) -> char {\n+    fn char_at_reverse(&self, i: uint) -> char {\n         char_at_reverse(*self, i)\n     }\n "}, {"sha": "706cb10dba9f774c2e405f615eb9f7e8259f60ca", "filename": "src/libcore/sys.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/be9bddd46377bc982b73acf15a720365a54197a7/src%2Flibcore%2Fsys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be9bddd46377bc982b73acf15a720365a54197a7/src%2Flibcore%2Fsys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsys.rs?ref=be9bddd46377bc982b73acf15a720365a54197a7", "patch": "@@ -60,15 +60,15 @@ pub mod rustrt {\n \n /// Compares contents of two pointers using the default method.\n /// Equivalent to `*x1 == *x2`.  Useful for hashtables.\n-pub pure fn shape_eq<T:Eq>(x1: &T, x2: &T) -> bool {\n+pub fn shape_eq<T:Eq>(x1: &T, x2: &T) -> bool {\n     *x1 == *x2\n }\n \n-pub pure fn shape_lt<T:Ord>(x1: &T, x2: &T) -> bool {\n+pub fn shape_lt<T:Ord>(x1: &T, x2: &T) -> bool {\n     *x1 < *x2\n }\n \n-pub pure fn shape_le<T:Ord>(x1: &T, x2: &T) -> bool {\n+pub fn shape_le<T:Ord>(x1: &T, x2: &T) -> bool {\n     *x1 <= *x2\n }\n \n@@ -79,13 +79,13 @@ pub pure fn shape_le<T:Ord>(x1: &T, x2: &T) -> bool {\n  * performing dark magick.\n  */\n #[inline(always)]\n-pub pure fn get_type_desc<T>() -> *TypeDesc {\n+pub fn get_type_desc<T>() -> *TypeDesc {\n     unsafe { rusti::get_tydesc::<T>() as *TypeDesc }\n }\n \n /// Returns the size of a type\n #[inline(always)]\n-pub pure fn size_of<T>() -> uint {\n+pub fn size_of<T>() -> uint {\n     unsafe { rusti::size_of::<T>() }\n }\n \n@@ -95,7 +95,7 @@ pub pure fn size_of<T>() -> uint {\n  * Useful for building structures containing variable-length arrays.\n  */\n #[inline(always)]\n-pub pure fn nonzero_size_of<T>() -> uint {\n+pub fn nonzero_size_of<T>() -> uint {\n     let s = size_of::<T>();\n     if s == 0 { 1 } else { s }\n }\n@@ -107,26 +107,26 @@ pub pure fn nonzero_size_of<T>() -> uint {\n  * than the preferred alignment.\n  */\n #[inline(always)]\n-pub pure fn min_align_of<T>() -> uint {\n+pub fn min_align_of<T>() -> uint {\n     unsafe { rusti::min_align_of::<T>() }\n }\n \n /// Returns the preferred alignment of a type\n #[inline(always)]\n-pub pure fn pref_align_of<T>() -> uint {\n+pub fn pref_align_of<T>() -> uint {\n     unsafe { rusti::pref_align_of::<T>() }\n }\n \n /// Returns the refcount of a shared box (as just before calling this)\n #[inline(always)]\n-pub pure fn refcount<T>(t: @T) -> uint {\n+pub fn refcount<T>(t: @T) -> uint {\n     unsafe {\n         let ref_ptr: *uint = cast::reinterpret_cast(&t);\n         *ref_ptr - 1\n     }\n }\n \n-pub pure fn log_str<T>(t: &T) -> ~str {\n+pub fn log_str<T>(t: &T) -> ~str {\n     unsafe {\n         do io::with_str_writer |wr| {\n             repr::write_repr(wr, t)\n@@ -135,7 +135,7 @@ pub pure fn log_str<T>(t: &T) -> ~str {\n }\n \n /** Initiate task failure */\n-pub pure fn begin_unwind(msg: ~str, file: ~str, line: uint) -> ! {\n+pub fn begin_unwind(msg: ~str, file: ~str, line: uint) -> ! {\n     do str::as_buf(msg) |msg_buf, _msg_len| {\n         do str::as_buf(file) |file_buf, _file_len| {\n             unsafe {\n@@ -148,15 +148,15 @@ pub pure fn begin_unwind(msg: ~str, file: ~str, line: uint) -> ! {\n }\n \n // FIXME #4427: Temporary until rt::rt_fail_ goes away\n-pub pure fn begin_unwind_(msg: *c_char, file: *c_char, line: size_t) -> ! {\n+pub fn begin_unwind_(msg: *c_char, file: *c_char, line: size_t) -> ! {\n     unsafe {\n         gc::cleanup_stack_for_failure();\n         rustrt::rust_upcall_fail(msg, file, line);\n         cast::transmute(())\n     }\n }\n \n-pub pure fn fail_assert(msg: &str, file: &str, line: uint) -> ! {\n+pub fn fail_assert(msg: &str, file: &str, line: uint) -> ! {\n     unsafe {\n         let (msg, file) = (msg.to_owned(), file.to_owned());\n         begin_unwind(~\"assertion failed: \" + msg, file, line)"}, {"sha": "59f4942b3a4a7396c40771f63e7698e389e40abe", "filename": "src/libcore/task/local_data_priv.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/be9bddd46377bc982b73acf15a720365a54197a7/src%2Flibcore%2Ftask%2Flocal_data_priv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be9bddd46377bc982b73acf15a720365a54197a7/src%2Flibcore%2Ftask%2Flocal_data_priv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Flocal_data_priv.rs?ref=be9bddd46377bc982b73acf15a720365a54197a7", "patch": "@@ -24,14 +24,14 @@ pub trait LocalData { }\n impl<T:Durable> LocalData for @T { }\n \n impl Eq for @LocalData {\n-    pure fn eq(&self, other: &@LocalData) -> bool {\n+    fn eq(&self, other: &@LocalData) -> bool {\n         unsafe {\n             let ptr_a: (uint, uint) = cast::reinterpret_cast(&(*self));\n             let ptr_b: (uint, uint) = cast::reinterpret_cast(other);\n             return ptr_a == ptr_b;\n         }\n     }\n-    pure fn ne(&self, other: &@LocalData) -> bool { !(*self).eq(other) }\n+    fn ne(&self, other: &@LocalData) -> bool { !(*self).eq(other) }\n }\n \n // If TLS is used heavily in future, this could be made more efficient with a"}, {"sha": "a38b44afb513fe77d596ea75c063fad9499227df", "filename": "src/libcore/task/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/be9bddd46377bc982b73acf15a720365a54197a7/src%2Flibcore%2Ftask%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be9bddd46377bc982b73acf15a720365a54197a7/src%2Flibcore%2Ftask%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fmod.rs?ref=be9bddd46377bc982b73acf15a720365a54197a7", "patch": "@@ -78,13 +78,13 @@ pub enum TaskResult {\n }\n \n impl Eq for TaskResult {\n-    pure fn eq(&self, other: &TaskResult) -> bool {\n+    fn eq(&self, other: &TaskResult) -> bool {\n         match ((*self), (*other)) {\n             (Success, Success) | (Failure, Failure) => true,\n             (Success, _) | (Failure, _) => false\n         }\n     }\n-    pure fn ne(&self, other: &TaskResult) -> bool { !(*self).eq(other) }\n+    fn ne(&self, other: &TaskResult) -> bool { !(*self).eq(other) }\n }\n \n /// Scheduler modes"}, {"sha": "b97a682c4e5caf1d1715e231a113a6f4643b57f4", "filename": "src/libcore/task/spawn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/be9bddd46377bc982b73acf15a720365a54197a7/src%2Flibcore%2Ftask%2Fspawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be9bddd46377bc982b73acf15a720365a54197a7/src%2Flibcore%2Ftask%2Fspawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fspawn.rs?ref=be9bddd46377bc982b73acf15a720365a54197a7", "patch": "@@ -126,7 +126,7 @@ type TaskGroupArc = unstable::Exclusive<Option<TaskGroupData>>;\n type TaskGroupInner = &'self mut Option<TaskGroupData>;\n \n // A taskgroup is 'dead' when nothing can cause it to fail; only members can.\n-pure fn taskgroup_is_dead(tg: &TaskGroupData) -> bool {\n+fn taskgroup_is_dead(tg: &TaskGroupData) -> bool {\n     (&const tg.members).is_empty()\n }\n "}, {"sha": "f379878c8eb0bee3dbbf964a284cbd3a1868a879", "filename": "src/libcore/to_bytes.rs", "status": "modified", "additions": 34, "deletions": 34, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/be9bddd46377bc982b73acf15a720365a54197a7/src%2Flibcore%2Fto_bytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be9bddd46377bc982b73acf15a720365a54197a7/src%2Flibcore%2Fto_bytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fto_bytes.rs?ref=be9bddd46377bc982b73acf15a720365a54197a7", "patch": "@@ -43,12 +43,12 @@ pub trait IterBytes {\n      * left-to-right in declaration order, regardless of\n      * underlying memory endianness.\n      */\n-    pure fn iter_bytes(&self, lsb0: bool, f: Cb);\n+    fn iter_bytes(&self, lsb0: bool, f: Cb);\n }\n \n impl IterBytes for bool {\n     #[inline(always)]\n-    pure fn iter_bytes(&self, _lsb0: bool, f: Cb) {\n+    fn iter_bytes(&self, _lsb0: bool, f: Cb) {\n         f([\n             *self as u8\n         ]);\n@@ -57,7 +57,7 @@ impl IterBytes for bool {\n \n impl IterBytes for u8 {\n     #[inline(always)]\n-    pure fn iter_bytes(&self, _lsb0: bool, f: Cb) {\n+    fn iter_bytes(&self, _lsb0: bool, f: Cb) {\n         f([\n             *self\n         ]);\n@@ -66,7 +66,7 @@ impl IterBytes for u8 {\n \n impl IterBytes for u16 {\n     #[inline(always)]\n-    pure fn iter_bytes(&self, lsb0: bool, f: Cb) {\n+    fn iter_bytes(&self, lsb0: bool, f: Cb) {\n         if lsb0 {\n             f([\n                 *self as u8,\n@@ -83,7 +83,7 @@ impl IterBytes for u16 {\n \n impl IterBytes for u32 {\n     #[inline(always)]\n-    pure fn iter_bytes(&self, lsb0: bool, f: Cb) {\n+    fn iter_bytes(&self, lsb0: bool, f: Cb) {\n         if lsb0 {\n             f([\n                 *self as u8,\n@@ -104,7 +104,7 @@ impl IterBytes for u32 {\n \n impl IterBytes for u64 {\n     #[inline(always)]\n-    pure fn iter_bytes(&self, lsb0: bool, f: Cb) {\n+    fn iter_bytes(&self, lsb0: bool, f: Cb) {\n         if lsb0 {\n             f([\n                 *self as u8,\n@@ -133,35 +133,35 @@ impl IterBytes for u64 {\n \n impl IterBytes for i8 {\n     #[inline(always)]\n-    pure fn iter_bytes(&self, lsb0: bool, f: Cb) {\n+    fn iter_bytes(&self, lsb0: bool, f: Cb) {\n         (*self as u8).iter_bytes(lsb0, f)\n     }\n }\n \n impl IterBytes for i16 {\n     #[inline(always)]\n-    pure fn iter_bytes(&self, lsb0: bool, f: Cb) {\n+    fn iter_bytes(&self, lsb0: bool, f: Cb) {\n         (*self as u16).iter_bytes(lsb0, f)\n     }\n }\n \n impl IterBytes for i32 {\n     #[inline(always)]\n-    pure fn iter_bytes(&self, lsb0: bool, f: Cb) {\n+    fn iter_bytes(&self, lsb0: bool, f: Cb) {\n         (*self as u32).iter_bytes(lsb0, f)\n     }\n }\n \n impl IterBytes for i64 {\n     #[inline(always)]\n-    pure fn iter_bytes(&self, lsb0: bool, f: Cb) {\n+    fn iter_bytes(&self, lsb0: bool, f: Cb) {\n         (*self as u64).iter_bytes(lsb0, f)\n     }\n }\n \n impl IterBytes for char {\n     #[inline(always)]\n-    pure fn iter_bytes(&self, lsb0: bool, f: Cb) {\n+    fn iter_bytes(&self, lsb0: bool, f: Cb) {\n         (*self as u32).iter_bytes(lsb0, f)\n     }\n }\n@@ -172,7 +172,7 @@ pub mod x32 {\n \n     impl IterBytes for uint {\n         #[inline(always)]\n-        pure fn iter_bytes(&self, lsb0: bool, f: Cb) {\n+        fn iter_bytes(&self, lsb0: bool, f: Cb) {\n             (*self as u32).iter_bytes(lsb0, f)\n         }\n     }\n@@ -184,22 +184,22 @@ pub mod x64 {\n \n     impl IterBytes for uint {\n         #[inline(always)]\n-        pure fn iter_bytes(&self, lsb0: bool, f: Cb) {\n+        fn iter_bytes(&self, lsb0: bool, f: Cb) {\n             (*self as u64).iter_bytes(lsb0, f)\n         }\n     }\n }\n \n impl IterBytes for int {\n     #[inline(always)]\n-    pure fn iter_bytes(&self, lsb0: bool, f: Cb) {\n+    fn iter_bytes(&self, lsb0: bool, f: Cb) {\n         (*self as uint).iter_bytes(lsb0, f)\n     }\n }\n \n impl<A:IterBytes> IterBytes for &'self [A] {\n     #[inline(always)]\n-    pure fn iter_bytes(&self, lsb0: bool, f: Cb) {\n+    fn iter_bytes(&self, lsb0: bool, f: Cb) {\n         for (*self).each |elt| {\n             do elt.iter_bytes(lsb0) |bytes| {\n                 f(bytes)\n@@ -210,7 +210,7 @@ impl<A:IterBytes> IterBytes for &'self [A] {\n \n impl<A:IterBytes,B:IterBytes> IterBytes for (A,B) {\n   #[inline(always)]\n-  pure fn iter_bytes(&self, lsb0: bool, f: Cb) {\n+  fn iter_bytes(&self, lsb0: bool, f: Cb) {\n     match *self {\n       (ref a, ref b) => {\n         iter_bytes_2(a, b, lsb0, f);\n@@ -221,7 +221,7 @@ impl<A:IterBytes,B:IterBytes> IterBytes for (A,B) {\n \n impl<A:IterBytes,B:IterBytes,C:IterBytes> IterBytes for (A,B,C) {\n   #[inline(always)]\n-  pure fn iter_bytes(&self, lsb0: bool, f: Cb) {\n+  fn iter_bytes(&self, lsb0: bool, f: Cb) {\n     match *self {\n       (ref a, ref b, ref c) => {\n         iter_bytes_3(a, b, c, lsb0, f);\n@@ -231,33 +231,33 @@ impl<A:IterBytes,B:IterBytes,C:IterBytes> IterBytes for (A,B,C) {\n }\n \n // Move this to vec, probably.\n-pure fn borrow<A>(a: &'x [A]) -> &'x [A] {\n+fn borrow<A>(a: &'x [A]) -> &'x [A] {\n     a\n }\n \n impl<A:IterBytes> IterBytes for ~[A] {\n     #[inline(always)]\n-    pure fn iter_bytes(&self, lsb0: bool, f: Cb) {\n+    fn iter_bytes(&self, lsb0: bool, f: Cb) {\n         borrow(*self).iter_bytes(lsb0, f)\n     }\n }\n \n impl<A:IterBytes> IterBytes for @[A] {\n     #[inline(always)]\n-    pure fn iter_bytes(&self, lsb0: bool, f: Cb) {\n+    fn iter_bytes(&self, lsb0: bool, f: Cb) {\n         borrow(*self).iter_bytes(lsb0, f)\n     }\n }\n \n-pub pure fn iter_bytes_2<A:IterBytes,B:IterBytes>(a: &A, b: &B,\n+pub fn iter_bytes_2<A:IterBytes,B:IterBytes>(a: &A, b: &B,\n                                             lsb0: bool, z: Cb) {\n     let mut flag = true;\n     a.iter_bytes(lsb0, |bytes| {flag = z(bytes); flag});\n     if !flag { return; }\n     b.iter_bytes(lsb0, |bytes| {flag = z(bytes); flag});\n }\n \n-pub pure fn iter_bytes_3<A: IterBytes,\n+pub fn iter_bytes_3<A: IterBytes,\n                 B: IterBytes,\n                 C: IterBytes>(a: &A, b: &B, c: &C,\n                               lsb0: bool, z: Cb) {\n@@ -269,7 +269,7 @@ pub pure fn iter_bytes_3<A: IterBytes,\n     c.iter_bytes(lsb0, |bytes| {flag = z(bytes); flag});\n }\n \n-pub pure fn iter_bytes_4<A: IterBytes,\n+pub fn iter_bytes_4<A: IterBytes,\n                 B: IterBytes,\n                 C: IterBytes,\n                 D: IterBytes>(a: &A, b: &B, c: &C,\n@@ -285,7 +285,7 @@ pub pure fn iter_bytes_4<A: IterBytes,\n     d.iter_bytes(lsb0, |bytes| {flag = z(bytes); flag});\n }\n \n-pub pure fn iter_bytes_5<A: IterBytes,\n+pub fn iter_bytes_5<A: IterBytes,\n                 B: IterBytes,\n                 C: IterBytes,\n                 D: IterBytes,\n@@ -304,7 +304,7 @@ pub pure fn iter_bytes_5<A: IterBytes,\n     e.iter_bytes(lsb0, |bytes| {flag = z(bytes); flag});\n }\n \n-pub pure fn iter_bytes_6<A: IterBytes,\n+pub fn iter_bytes_6<A: IterBytes,\n                 B: IterBytes,\n                 C: IterBytes,\n                 D: IterBytes,\n@@ -326,7 +326,7 @@ pub pure fn iter_bytes_6<A: IterBytes,\n     f.iter_bytes(lsb0, |bytes| {flag = z(bytes); flag});\n }\n \n-pub pure fn iter_bytes_7<A: IterBytes,\n+pub fn iter_bytes_7<A: IterBytes,\n                 B: IterBytes,\n                 C: IterBytes,\n                 D: IterBytes,\n@@ -354,7 +354,7 @@ pub pure fn iter_bytes_7<A: IterBytes,\n \n impl IterBytes for &'self str {\n     #[inline(always)]\n-    pure fn iter_bytes(&self, _lsb0: bool, f: Cb) {\n+    fn iter_bytes(&self, _lsb0: bool, f: Cb) {\n         do str::byte_slice(*self) |bytes| {\n             f(bytes);\n         }\n@@ -363,7 +363,7 @@ impl IterBytes for &'self str {\n \n impl IterBytes for ~str {\n     #[inline(always)]\n-    pure fn iter_bytes(&self, _lsb0: bool, f: Cb) {\n+    fn iter_bytes(&self, _lsb0: bool, f: Cb) {\n         do str::byte_slice(*self) |bytes| {\n             f(bytes);\n         }\n@@ -372,7 +372,7 @@ impl IterBytes for ~str {\n \n impl IterBytes for @str {\n     #[inline(always)]\n-    pure fn iter_bytes(&self, _lsb0: bool, f: Cb) {\n+    fn iter_bytes(&self, _lsb0: bool, f: Cb) {\n         do str::byte_slice(*self) |bytes| {\n             f(bytes);\n         }\n@@ -381,7 +381,7 @@ impl IterBytes for @str {\n \n impl<A:IterBytes> IterBytes for Option<A> {\n     #[inline(always)]\n-    pure fn iter_bytes(&self, lsb0: bool, f: Cb) {\n+    fn iter_bytes(&self, lsb0: bool, f: Cb) {\n         match *self {\n           Some(ref a) => iter_bytes_2(&0u8, a, lsb0, f),\n           None => 1u8.iter_bytes(lsb0, f)\n@@ -391,21 +391,21 @@ impl<A:IterBytes> IterBytes for Option<A> {\n \n impl<A:IterBytes> IterBytes for &'self A {\n     #[inline(always)]\n-    pure fn iter_bytes(&self, lsb0: bool, f: Cb) {\n+    fn iter_bytes(&self, lsb0: bool, f: Cb) {\n         (**self).iter_bytes(lsb0, f);\n     }\n }\n \n impl<A:IterBytes> IterBytes for @A {\n     #[inline(always)]\n-    pure fn iter_bytes(&self, lsb0: bool, f: Cb) {\n+    fn iter_bytes(&self, lsb0: bool, f: Cb) {\n         (**self).iter_bytes(lsb0, f);\n     }\n }\n \n impl<A:IterBytes> IterBytes for ~A {\n     #[inline(always)]\n-    pure fn iter_bytes(&self, lsb0: bool, f: Cb) {\n+    fn iter_bytes(&self, lsb0: bool, f: Cb) {\n         (**self).iter_bytes(lsb0, f);\n     }\n }\n@@ -414,7 +414,7 @@ impl<A:IterBytes> IterBytes for ~A {\n // to the target; it just gives you the pointer-bytes.\n impl<A> IterBytes for *const A {\n     #[inline(always)]\n-    pure fn iter_bytes(&self, lsb0: bool, f: Cb) {\n+    fn iter_bytes(&self, lsb0: bool, f: Cb) {\n         (*self as uint).iter_bytes(lsb0, f);\n     }\n }"}, {"sha": "576f794483d20f69d3e35e67c7af8a4c41af36ad", "filename": "src/libcore/to_str.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/be9bddd46377bc982b73acf15a720365a54197a7/src%2Flibcore%2Fto_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be9bddd46377bc982b73acf15a720365a54197a7/src%2Flibcore%2Fto_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fto_str.rs?ref=be9bddd46377bc982b73acf15a720365a54197a7", "patch": "@@ -17,23 +17,23 @@ The `ToStr` trait for converting to strings\n use str;\n \n pub trait ToStr {\n-    pure fn to_str(&self) -> ~str;\n+    fn to_str(&self) -> ~str;\n }\n \n impl ToStr for bool {\n     #[inline(always)]\n-    pure fn to_str(&self) -> ~str { ::bool::to_str(*self) }\n+    fn to_str(&self) -> ~str { ::bool::to_str(*self) }\n }\n impl ToStr for () {\n     #[inline(always)]\n-    pure fn to_str(&self) -> ~str { ~\"()\" }\n+    fn to_str(&self) -> ~str { ~\"()\" }\n }\n \n // FIXME #4898: impl for one-tuples\n \n impl<A:ToStr,B:ToStr> ToStr for (A, B) {\n     #[inline(always)]\n-    pure fn to_str(&self) -> ~str {\n+    fn to_str(&self) -> ~str {\n         // FIXME(#4760): this causes an llvm assertion\n         //let &(ref a, ref b) = self;\n         match *self {\n@@ -45,7 +45,7 @@ impl<A:ToStr,B:ToStr> ToStr for (A, B) {\n }\n impl<A:ToStr,B:ToStr,C:ToStr> ToStr for (A, B, C) {\n     #[inline(always)]\n-    pure fn to_str(&self) -> ~str {\n+    fn to_str(&self) -> ~str {\n         // FIXME(#4760): this causes an llvm assertion\n         //let &(ref a, ref b, ref c) = self;\n         match *self {\n@@ -62,7 +62,7 @@ impl<A:ToStr,B:ToStr,C:ToStr> ToStr for (A, B, C) {\n \n impl<A:ToStr> ToStr for &'self [A] {\n     #[inline(always)]\n-    pure fn to_str(&self) -> ~str {\n+    fn to_str(&self) -> ~str {\n         unsafe {\n             // FIXME #4568\n             // Bleh -- not really unsafe\n@@ -83,7 +83,7 @@ impl<A:ToStr> ToStr for &'self [A] {\n \n impl<A:ToStr> ToStr for ~[A] {\n     #[inline(always)]\n-    pure fn to_str(&self) -> ~str {\n+    fn to_str(&self) -> ~str {\n         unsafe {\n             // FIXME #4568\n             // Bleh -- not really unsafe\n@@ -104,7 +104,7 @@ impl<A:ToStr> ToStr for ~[A] {\n \n impl<A:ToStr> ToStr for @[A] {\n     #[inline(always)]\n-    pure fn to_str(&self) -> ~str {\n+    fn to_str(&self) -> ~str {\n         unsafe {\n             // FIXME #4568\n             // Bleh -- not really unsafe"}, {"sha": "258de5c81db1aa1ffd3b236a435da909e3b8ff21", "filename": "src/libcore/trie.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/be9bddd46377bc982b73acf15a720365a54197a7/src%2Flibcore%2Ftrie.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be9bddd46377bc982b73acf15a720365a54197a7/src%2Flibcore%2Ftrie.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftrie.rs?ref=be9bddd46377bc982b73acf15a720365a54197a7", "patch": "@@ -32,29 +32,29 @@ pub struct TrieMap<T> {\n impl<T> BaseIter<(uint, &'self T)> for TrieMap<T> {\n     /// Visit all key-value pairs in order\n     #[inline(always)]\n-    pure fn each(&self, f: &fn(&(uint, &'self T)) -> bool) {\n+    fn each(&self, f: &fn(&(uint, &'self T)) -> bool) {\n         self.root.each(f);\n     }\n     #[inline(always)]\n-    pure fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n+    fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n }\n \n impl<T> ReverseIter<(uint, &'self T)> for TrieMap<T> {\n     /// Visit all key-value pairs in reverse order\n     #[inline(always)]\n-    pure fn each_reverse(&self, f: &fn(&(uint, &'self T)) -> bool) {\n+    fn each_reverse(&self, f: &fn(&(uint, &'self T)) -> bool) {\n         self.root.each_reverse(f);\n     }\n }\n \n impl<T> Container for TrieMap<T> {\n     /// Return the number of elements in the map\n     #[inline(always)]\n-    pure fn len(&const self) -> uint { self.length }\n+    fn len(&const self) -> uint { self.length }\n \n     /// Return true if the map contains no elements\n     #[inline(always)]\n-    pure fn is_empty(&const self) -> bool { self.len() == 0 }\n+    fn is_empty(&const self) -> bool { self.len() == 0 }\n }\n \n impl<T> Mutable for TrieMap<T> {\n@@ -69,19 +69,19 @@ impl<T> Mutable for TrieMap<T> {\n impl<T> Map<uint, T> for TrieMap<T> {\n     /// Return true if the map contains a value for the specified key\n     #[inline(always)]\n-    pure fn contains_key(&self, key: &uint) -> bool {\n+    fn contains_key(&self, key: &uint) -> bool {\n         self.find(key).is_some()\n     }\n \n     /// Visit all keys in order\n     #[inline(always)]\n-    pure fn each_key(&self, f: &fn(&uint) -> bool) {\n+    fn each_key(&self, f: &fn(&uint) -> bool) {\n         self.each(|&(k, _)| f(&k))\n     }\n \n     /// Visit all values in order\n     #[inline(always)]\n-    pure fn each_value(&self, f: &fn(&T) -> bool) {\n+    fn each_value(&self, f: &fn(&T) -> bool) {\n         self.each(|&(_, v)| f(v))\n     }\n \n@@ -93,7 +93,7 @@ impl<T> Map<uint, T> for TrieMap<T> {\n \n     /// Return the value corresponding to the key in the map\n     #[inline(hint)]\n-    pure fn find(&self, key: &uint) -> Option<&'self T> {\n+    fn find(&self, key: &uint) -> Option<&'self T> {\n         let mut node: &'self TrieNode<T> = &self.root;\n         let mut idx = 0;\n         loop {\n@@ -139,19 +139,19 @@ impl<T> Map<uint, T> for TrieMap<T> {\n pub impl<T> TrieMap<T> {\n     /// Create an empty TrieMap\n     #[inline(always)]\n-    pure fn new() -> TrieMap<T> {\n+    fn new() -> TrieMap<T> {\n         TrieMap{root: TrieNode::new(), length: 0}\n     }\n \n     /// Visit all keys in reverse order\n     #[inline(always)]\n-    pure fn each_key_reverse(&self, f: &fn(&uint) -> bool) {\n+    fn each_key_reverse(&self, f: &fn(&uint) -> bool) {\n         self.each_reverse(|&(k, _)| f(&k))\n     }\n \n     /// Visit all values in reverse order\n     #[inline(always)]\n-    pure fn each_value_reverse(&self, f: &fn(&T) -> bool) {\n+    fn each_value_reverse(&self, f: &fn(&T) -> bool) {\n         self.each_reverse(|&(_, v)| f(v))\n     }\n }\n@@ -162,25 +162,25 @@ pub struct TrieSet {\n \n impl BaseIter<uint> for TrieSet {\n     /// Visit all values in order\n-    pure fn each(&self, f: &fn(&uint) -> bool) { self.map.each_key(f) }\n-    pure fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n+    fn each(&self, f: &fn(&uint) -> bool) { self.map.each_key(f) }\n+    fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n }\n \n impl ReverseIter<uint> for TrieSet {\n     /// Visit all values in reverse order\n-    pure fn each_reverse(&self, f: &fn(&uint) -> bool) {\n+    fn each_reverse(&self, f: &fn(&uint) -> bool) {\n         self.map.each_key_reverse(f)\n     }\n }\n \n impl Container for TrieSet {\n     /// Return the number of elements in the set\n     #[inline(always)]\n-    pure fn len(&const self) -> uint { self.map.len() }\n+    fn len(&const self) -> uint { self.map.len() }\n \n     /// Return true if the set contains no elements\n     #[inline(always)]\n-    pure fn is_empty(&const self) -> bool { self.map.is_empty() }\n+    fn is_empty(&const self) -> bool { self.map.is_empty() }\n }\n \n impl Mutable for TrieSet {\n@@ -192,13 +192,13 @@ impl Mutable for TrieSet {\n impl TrieSet {\n     /// Create an empty TrieSet\n     #[inline(always)]\n-    pure fn new() -> TrieSet {\n+    fn new() -> TrieSet {\n         TrieSet{map: TrieMap::new()}\n     }\n \n     /// Return true if the set contains a value\n     #[inline(always)]\n-    pure fn contains(&self, value: &uint) -> bool {\n+    fn contains(&self, value: &uint) -> bool {\n         self.map.contains_key(value)\n     }\n \n@@ -220,7 +220,7 @@ struct TrieNode<T> {\n \n impl<T> TrieNode<T> {\n     #[inline(always)]\n-    pure fn new() -> TrieNode<T> {\n+    fn new() -> TrieNode<T> {\n         // FIXME: #5244: [Nothing, ..SIZE] should be possible without Copy\n         TrieNode{count: 0,\n                  children: [Nothing, Nothing, Nothing, Nothing,\n@@ -231,7 +231,7 @@ impl<T> TrieNode<T> {\n }\n \n impl<T> TrieNode<T> {\n-    pure fn each(&self, f: &fn(&(uint, &'self T)) -> bool) -> bool {\n+    fn each(&self, f: &fn(&(uint, &'self T)) -> bool) -> bool {\n         for uint::range(0, self.children.len()) |idx| {\n             match self.children[idx] {\n                 Internal(ref x) => if !x.each(f) { return false },\n@@ -242,7 +242,7 @@ impl<T> TrieNode<T> {\n         true\n     }\n \n-    pure fn each_reverse(&self, f: &fn(&(uint, &'self T)) -> bool) -> bool {\n+    fn each_reverse(&self, f: &fn(&(uint, &'self T)) -> bool) -> bool {\n         for uint::range_rev(self.children.len(), 0) |idx| {\n             match self.children[idx - 1] {\n                 Internal(ref x) => if !x.each_reverse(f) { return false },\n@@ -269,7 +269,7 @@ impl<T> TrieNode<T> {\n \n // if this was done via a trait, the key could be generic\n #[inline(always)]\n-pure fn chunk(n: uint, idx: uint) -> uint {\n+fn chunk(n: uint, idx: uint) -> uint {\n     let sh = uint::bits - (SHIFT * (idx + 1));\n     (n >> sh) & MASK\n }"}, {"sha": "fc7834a7514acd1dcfc02baaf8f8d221c26a9b3b", "filename": "src/libcore/tuple.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/be9bddd46377bc982b73acf15a720365a54197a7/src%2Flibcore%2Ftuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be9bddd46377bc982b73acf15a720365a54197a7/src%2Flibcore%2Ftuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftuple.rs?ref=be9bddd46377bc982b73acf15a720365a54197a7", "patch": "@@ -16,50 +16,50 @@ use vec;\n #[cfg(notest)] use cmp::{Eq, Ord};\n \n pub trait CopyableTuple<T, U> {\n-    pure fn first(&self) -> T;\n-    pure fn second(&self) -> U;\n-    pure fn swap(&self) -> (U, T);\n+    fn first(&self) -> T;\n+    fn second(&self) -> U;\n+    fn swap(&self) -> (U, T);\n }\n \n impl<T:Copy,U:Copy> CopyableTuple<T, U> for (T, U) {\n \n     /// Return the first element of self\n     #[inline(always)]\n-    pure fn first(&self) -> T {\n+    fn first(&self) -> T {\n         let (t, _) = *self;\n         return t;\n     }\n \n     /// Return the second element of self\n     #[inline(always)]\n-    pure fn second(&self) -> U {\n+    fn second(&self) -> U {\n         let (_, u) = *self;\n         return u;\n     }\n \n     /// Return the results of swapping the two elements of self\n     #[inline(always)]\n-    pure fn swap(&self) -> (U, T) {\n+    fn swap(&self) -> (U, T) {\n         let (t, u) = *self;\n         return (u, t);\n     }\n \n }\n \n pub trait ImmutableTuple<T, U> {\n-    pure fn first_ref(&self) -> &'self T;\n-    pure fn second_ref(&self) -> &'self U;\n+    fn first_ref(&self) -> &'self T;\n+    fn second_ref(&self) -> &'self U;\n }\n \n impl<T, U> ImmutableTuple<T, U> for (T, U) {\n     #[inline(always)]\n-    pure fn first_ref(&self) -> &'self T {\n+    fn first_ref(&self) -> &'self T {\n         match *self {\n             (ref t, _) => t,\n         }\n     }\n     #[inline(always)]\n-    pure fn second_ref(&self) -> &'self U {\n+    fn second_ref(&self) -> &'self U {\n         match *self {\n             (_, ref u) => u,\n         }\n@@ -117,7 +117,7 @@ impl<A:Copy,B:Copy> ExtendedTupleOps<A,B> for (~[A], ~[B]) {\n #[cfg(notest)]\n impl<A:Eq,B:Eq> Eq for (A, B) {\n     #[inline(always)]\n-    pure fn eq(&self, other: &(A, B)) -> bool {\n+    fn eq(&self, other: &(A, B)) -> bool {\n         match (*self) {\n             (ref self_a, ref self_b) => match other {\n                 &(ref other_a, ref other_b) => {\n@@ -127,13 +127,13 @@ impl<A:Eq,B:Eq> Eq for (A, B) {\n         }\n     }\n     #[inline(always)]\n-    pure fn ne(&self, other: &(A, B)) -> bool { !(*self).eq(other) }\n+    fn ne(&self, other: &(A, B)) -> bool { !(*self).eq(other) }\n }\n \n #[cfg(notest)]\n impl<A:Ord,B:Ord> Ord for (A, B) {\n     #[inline(always)]\n-    pure fn lt(&self, other: &(A, B)) -> bool {\n+    fn lt(&self, other: &(A, B)) -> bool {\n         match (*self) {\n             (ref self_a, ref self_b) => {\n                 match (*other) {\n@@ -148,17 +148,17 @@ impl<A:Ord,B:Ord> Ord for (A, B) {\n         }\n     }\n     #[inline(always)]\n-    pure fn le(&self, other: &(A, B)) -> bool { !(*other).lt(&(*self)) }\n+    fn le(&self, other: &(A, B)) -> bool { !(*other).lt(&(*self)) }\n     #[inline(always)]\n-    pure fn ge(&self, other: &(A, B)) -> bool { !(*self).lt(other) }\n+    fn ge(&self, other: &(A, B)) -> bool { !(*self).lt(other) }\n     #[inline(always)]\n-    pure fn gt(&self, other: &(A, B)) -> bool { (*other).lt(&(*self))  }\n+    fn gt(&self, other: &(A, B)) -> bool { (*other).lt(&(*self))  }\n }\n \n #[cfg(notest)]\n impl<A:Eq,B:Eq,C:Eq> Eq for (A, B, C) {\n     #[inline(always)]\n-    pure fn eq(&self, other: &(A, B, C)) -> bool {\n+    fn eq(&self, other: &(A, B, C)) -> bool {\n         match (*self) {\n             (ref self_a, ref self_b, ref self_c) => match other {\n                 &(ref other_a, ref other_b, ref other_c) => {\n@@ -169,13 +169,13 @@ impl<A:Eq,B:Eq,C:Eq> Eq for (A, B, C) {\n         }\n     }\n     #[inline(always)]\n-    pure fn ne(&self, other: &(A, B, C)) -> bool { !(*self).eq(other) }\n+    fn ne(&self, other: &(A, B, C)) -> bool { !(*self).eq(other) }\n }\n \n #[cfg(notest)]\n impl<A:Ord,B:Ord,C:Ord> Ord for (A, B, C) {\n     #[inline(always)]\n-    pure fn lt(&self, other: &(A, B, C)) -> bool {\n+    fn lt(&self, other: &(A, B, C)) -> bool {\n         match (*self) {\n             (ref self_a, ref self_b, ref self_c) => {\n                 match (*other) {\n@@ -192,11 +192,11 @@ impl<A:Ord,B:Ord,C:Ord> Ord for (A, B, C) {\n         }\n     }\n     #[inline(always)]\n-    pure fn le(&self, other: &(A, B, C)) -> bool { !(*other).lt(&(*self)) }\n+    fn le(&self, other: &(A, B, C)) -> bool { !(*other).lt(&(*self)) }\n     #[inline(always)]\n-    pure fn ge(&self, other: &(A, B, C)) -> bool { !(*self).lt(other) }\n+    fn ge(&self, other: &(A, B, C)) -> bool { !(*self).lt(other) }\n     #[inline(always)]\n-    pure fn gt(&self, other: &(A, B, C)) -> bool { (*other).lt(&(*self))  }\n+    fn gt(&self, other: &(A, B, C)) -> bool { (*other).lt(&(*self))  }\n }\n \n #[test]"}, {"sha": "9f2ab66d5c20745f464e9dca9c1d1dcf769084ec", "filename": "src/libcore/unicode.rs", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/be9bddd46377bc982b73acf15a720365a54197a7/src%2Flibcore%2Funicode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be9bddd46377bc982b73acf15a720365a54197a7/src%2Flibcore%2Funicode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funicode.rs?ref=be9bddd46377bc982b73acf15a720365a54197a7", "patch": "@@ -11,15 +11,15 @@\n #[doc(hidden)]; // FIXME #3538\n \n pub mod general_category {\n-    pub pure fn Cc(c: char) -> bool {\n+    pub fn Cc(c: char) -> bool {\n         return match c {\n               '\\x00' .. '\\x1f'\n             | '\\x7f' .. '\\x9f' => true,\n             _ => false\n         };\n     }\n \n-    pub pure fn Cf(c: char) -> bool {\n+    pub fn Cf(c: char) -> bool {\n         return match c {\n               '\\xad'\n             | '\\u0600' .. '\\u0603'\n@@ -38,21 +38,21 @@ pub mod general_category {\n         };\n     }\n \n-    pub pure fn Co(c: char) -> bool {\n+    pub fn Co(c: char) -> bool {\n         return match c {\n           '\\ue000' .. '\\uf8ff' => true,\n           _ => false\n         };\n     }\n \n-    pub pure fn Cs(c: char) -> bool {\n+    pub fn Cs(c: char) -> bool {\n         return match c {\n               '\\ud800' .. '\\udfff' => true,\n             _ => false\n         };\n     }\n \n-    pub pure fn Ll(c: char) -> bool {\n+    pub fn Ll(c: char) -> bool {\n         return match c {\n               '\\x61' .. '\\x7a'\n             | '\\xaa'\n@@ -657,7 +657,7 @@ pub mod general_category {\n         };\n     }\n \n-    pub pure fn Lm(c: char) -> bool {\n+    pub fn Lm(c: char) -> bool {\n         return match c {\n               '\\u02b0' .. '\\u02c1'\n             | '\\u02c6' .. '\\u02d1'\n@@ -713,7 +713,7 @@ pub mod general_category {\n         };\n     }\n \n-    pub pure fn Lo(c: char) -> bool {\n+    pub fn Lo(c: char) -> bool {\n         return match c {\n               '\\u01bb'\n             | '\\u01c0' .. '\\u01c3'\n@@ -899,7 +899,7 @@ pub mod general_category {\n         };\n     }\n \n-    pub pure fn Lt(c: char) -> bool {\n+    pub fn Lt(c: char) -> bool {\n         return match c {\n               '\\u01c5'\n             | '\\u01c8'\n@@ -916,7 +916,7 @@ pub mod general_category {\n         };\n     }\n \n-    pub pure fn Lu(c: char) -> bool {\n+    pub fn Lu(c: char) -> bool {\n         return match c {\n               '\\x41' .. '\\x5a'\n             | '\\xc0' .. '\\xd6'\n@@ -1508,7 +1508,7 @@ pub mod general_category {\n         };\n     }\n \n-    pub pure fn Mc(c: char) -> bool {\n+    pub fn Mc(c: char) -> bool {\n         return match c {\n               '\\u0903'\n             | '\\u093b'\n@@ -1619,7 +1619,7 @@ pub mod general_category {\n         };\n     }\n \n-    pub pure fn Me(c: char) -> bool {\n+    pub fn Me(c: char) -> bool {\n         return match c {\n               '\\u0488' .. '\\u0489'\n             | '\\u20dd' .. '\\u20e0'\n@@ -1630,7 +1630,7 @@ pub mod general_category {\n         };\n     }\n \n-    pub pure fn Mn(c: char) -> bool {\n+    pub fn Mn(c: char) -> bool {\n         return match c {\n               '\\u0300' .. '\\u036f'\n             | '\\u0483' .. '\\u0487'\n@@ -1823,7 +1823,7 @@ pub mod general_category {\n         };\n     }\n \n-    pub pure fn Nd(c: char) -> bool {\n+    pub fn Nd(c: char) -> bool {\n         return match c {\n               '\\x30' .. '\\x39'\n             | '\\u0660' .. '\\u0669'\n@@ -1867,7 +1867,7 @@ pub mod general_category {\n         };\n     }\n \n-    pub pure fn Nl(c: char) -> bool {\n+    pub fn Nl(c: char) -> bool {\n         return match c {\n               '\\u16ee' .. '\\u16f0'\n             | '\\u2160' .. '\\u2182'\n@@ -1886,7 +1886,7 @@ pub mod general_category {\n         };\n     }\n \n-    pub pure fn No(c: char) -> bool {\n+    pub fn No(c: char) -> bool {\n         return match c {\n               '\\xb2' .. '\\xb3'\n             | '\\xb9'\n@@ -1934,7 +1934,7 @@ pub mod general_category {\n         };\n     }\n \n-    pub pure fn Pc(c: char) -> bool {\n+    pub fn Pc(c: char) -> bool {\n         return match c {\n               '\\x5f'\n             | '\\u203f' .. '\\u2040'\n@@ -1947,7 +1947,7 @@ pub mod general_category {\n         };\n     }\n \n-    pub pure fn Pd(c: char) -> bool {\n+    pub fn Pd(c: char) -> bool {\n         return match c {\n               '\\x2d'\n             | '\\u058a'\n@@ -1969,7 +1969,7 @@ pub mod general_category {\n         };\n     }\n \n-    pub pure fn Pe(c: char) -> bool {\n+    pub fn Pe(c: char) -> bool {\n         return match c {\n               '\\x29'\n             | '\\x5d'\n@@ -2046,7 +2046,7 @@ pub mod general_category {\n         };\n     }\n \n-    pub pure fn Pf(c: char) -> bool {\n+    pub fn Pf(c: char) -> bool {\n         return match c {\n               '\\xbb'\n             | '\\u2019'\n@@ -2063,7 +2063,7 @@ pub mod general_category {\n         };\n     }\n \n-    pub pure fn Pi(c: char) -> bool {\n+    pub fn Pi(c: char) -> bool {\n         return match c {\n               '\\xab'\n             | '\\u2018'\n@@ -2081,7 +2081,7 @@ pub mod general_category {\n         };\n     }\n \n-    pub pure fn Po(c: char) -> bool {\n+    pub fn Po(c: char) -> bool {\n         return match c {\n               '\\x21' .. '\\x23'\n             | '\\x25' .. '\\x27'\n@@ -2214,7 +2214,7 @@ pub mod general_category {\n         };\n     }\n \n-    pub pure fn Ps(c: char) -> bool {\n+    pub fn Ps(c: char) -> bool {\n         return match c {\n               '\\x28'\n             | '\\x5b'\n@@ -2293,7 +2293,7 @@ pub mod general_category {\n         };\n     }\n \n-    pub pure fn Sc(c: char) -> bool {\n+    pub fn Sc(c: char) -> bool {\n         return match c {\n               '\\x24'\n             | '\\xa2' .. '\\xa5'\n@@ -2316,7 +2316,7 @@ pub mod general_category {\n         };\n     }\n \n-    pub pure fn Sk(c: char) -> bool {\n+    pub fn Sk(c: char) -> bool {\n         return match c {\n               '\\x5e'\n             | '\\x60'\n@@ -2350,7 +2350,7 @@ pub mod general_category {\n         };\n     }\n \n-    pub pure fn Sm(c: char) -> bool {\n+    pub fn Sm(c: char) -> bool {\n         return match c {\n               '\\x2b'\n             | '\\x3c' .. '\\x3e'\n@@ -2421,7 +2421,7 @@ pub mod general_category {\n         };\n     }\n \n-    pub pure fn So(c: char) -> bool {\n+    pub fn So(c: char) -> bool {\n         return match c {\n               '\\xa6' .. '\\xa7'\n             | '\\xa9'\n@@ -2540,21 +2540,21 @@ pub mod general_category {\n         };\n     }\n \n-    pub pure fn Zl(c: char) -> bool {\n+    pub fn Zl(c: char) -> bool {\n         return match c {\n           '\\u2028' => true,\n           _ => false\n         };\n     }\n \n-    pub pure fn Zp(c: char) -> bool {\n+    pub fn Zp(c: char) -> bool {\n         return match c {\n           '\\u2029' => true,\n           _ => false\n         };\n     }\n \n-    pub pure fn Zs(c: char) -> bool {\n+    pub fn Zs(c: char) -> bool {\n         return match c {\n               '\\x20'\n             | '\\xa0'\n@@ -2572,7 +2572,7 @@ pub mod general_category {\n }\n mod derived_property {\n     /// Check if a character has the alphabetic unicode property\n-    pub pure fn Alphabetic(c: char) -> bool {\n+    pub fn Alphabetic(c: char) -> bool {\n         return match c {\n               '\\x41' .. '\\x5a'\n             | '\\x61' .. '\\x7a'\n@@ -3310,7 +3310,7 @@ mod derived_property {\n         };\n     }\n \n-    pub pure fn XID_Continue(c: char) -> bool {\n+    pub fn XID_Continue(c: char) -> bool {\n         return match c {\n               '\\x30' .. '\\x39'\n             | '\\x41' .. '\\x5a'\n@@ -4181,7 +4181,7 @@ mod derived_property {\n         };\n     }\n \n-    pub pure fn XID_Start(c: char) -> bool {\n+    pub fn XID_Start(c: char) -> bool {\n         return match c {\n               '\\x41' .. '\\x5a'\n             | '\\x61' .. '\\x7a'"}, {"sha": "69f2b86436921d8b92ea14a267077de27dca60bd", "filename": "src/libcore/unstable/extfmt.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/be9bddd46377bc982b73acf15a720365a54197a7/src%2Flibcore%2Funstable%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be9bddd46377bc982b73acf15a720365a54197a7/src%2Flibcore%2Funstable%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funstable%2Fextfmt.rs?ref=be9bddd46377bc982b73acf15a720365a54197a7", "patch": "@@ -140,7 +140,7 @@ pub mod ct {\n     }\n \n     pub impl<T> Parsed<T> {\n-        pure fn new(val: T, next: uint) -> Parsed<T> {\n+        fn new(val: T, next: uint) -> Parsed<T> {\n             Parsed {val: val, next: next}\n         }\n     }\n@@ -496,7 +496,7 @@ pub mod rt {\n         ty: Ty,\n     }\n \n-    pub pure fn conv_int(cv: Conv, i: int) -> ~str {\n+    pub fn conv_int(cv: Conv, i: int) -> ~str {\n         let radix = 10;\n         let prec = get_int_precision(cv);\n         let mut s : ~str = int_to_str_prec(i, radix, prec);\n@@ -509,7 +509,7 @@ pub mod rt {\n         }\n         return unsafe { pad(cv, s, PadSigned) };\n     }\n-    pub pure fn conv_uint(cv: Conv, u: uint) -> ~str {\n+    pub fn conv_uint(cv: Conv, u: uint) -> ~str {\n         let prec = get_int_precision(cv);\n         let mut rs =\n             match cv.ty {\n@@ -521,17 +521,17 @@ pub mod rt {\n             };\n         return unsafe { pad(cv, rs, PadUnsigned) };\n     }\n-    pub pure fn conv_bool(cv: Conv, b: bool) -> ~str {\n+    pub fn conv_bool(cv: Conv, b: bool) -> ~str {\n         let s = if b { ~\"true\" } else { ~\"false\" };\n         // run the boolean conversion through the string conversion logic,\n         // giving it the same rules for precision, etc.\n         return conv_str(cv, s);\n     }\n-    pub pure fn conv_char(cv: Conv, c: char) -> ~str {\n+    pub fn conv_char(cv: Conv, c: char) -> ~str {\n         let mut s = str::from_char(c);\n         return unsafe { pad(cv, s, PadNozero) };\n     }\n-    pub pure fn conv_str(cv: Conv, s: &str) -> ~str {\n+    pub fn conv_str(cv: Conv, s: &str) -> ~str {\n         // For strings, precision is the maximum characters\n         // displayed\n         let mut unpadded = match cv.precision {\n@@ -544,7 +544,7 @@ pub mod rt {\n         };\n         return unsafe { pad(cv, unpadded, PadNozero) };\n     }\n-    pub pure fn conv_float(cv: Conv, f: float) -> ~str {\n+    pub fn conv_float(cv: Conv, f: float) -> ~str {\n         let (to_str, digits) = match cv.precision {\n               CountIs(c) => (float::to_str_exact, c as uint),\n               CountImplied => (float::to_str_digits, 6u)\n@@ -559,14 +559,14 @@ pub mod rt {\n         }\n         return unsafe { pad(cv, s, PadFloat) };\n     }\n-    pub pure fn conv_poly<T>(cv: Conv, v: &T) -> ~str {\n+    pub fn conv_poly<T>(cv: Conv, v: &T) -> ~str {\n         let s = sys::log_str(v);\n         return conv_str(cv, s);\n     }\n \n     // Convert an int to string with minimum number of digits. If precision is\n     // 0 and num is 0 then the result is the empty string.\n-    pub pure fn int_to_str_prec(num: int, radix: uint, prec: uint) -> ~str {\n+    pub fn int_to_str_prec(num: int, radix: uint, prec: uint) -> ~str {\n         return if num < 0 {\n                 ~\"-\" + uint_to_str_prec(-num as uint, radix, prec)\n             } else { uint_to_str_prec(num as uint, radix, prec) };\n@@ -575,7 +575,7 @@ pub mod rt {\n     // Convert a uint to string with a minimum number of digits.  If precision\n     // is 0 and num is 0 then the result is the empty string. Could move this\n     // to uint: but it doesn't seem all that useful.\n-    pub pure fn uint_to_str_prec(num: uint, radix: uint,\n+    pub fn uint_to_str_prec(num: uint, radix: uint,\n                                  prec: uint) -> ~str {\n         return if prec == 0u && num == 0u {\n                 ~\"\"\n@@ -589,7 +589,7 @@ pub mod rt {\n                 } else { s }\n             };\n     }\n-    pub pure fn get_int_precision(cv: Conv) -> uint {\n+    pub fn get_int_precision(cv: Conv) -> uint {\n         return match cv.precision {\n               CountIs(c) => c as uint,\n               CountImplied => 1u\n@@ -619,7 +619,7 @@ pub mod rt {\n           PadFloat    => (true, true),\n           PadUnsigned => (true, false)\n         };\n-        pure fn have_precision(cv: Conv) -> bool {\n+        fn have_precision(cv: Conv) -> bool {\n             return match cv.precision { CountImplied => false, _ => true };\n         }\n         let zero_padding = {\n@@ -649,7 +649,7 @@ pub mod rt {\n         }\n         return padstr + s;\n     }\n-    pub pure fn have_flag(flags: u32, f: u32) -> bool {\n+    pub fn have_flag(flags: u32, f: u32) -> bool {\n         flags & f != 0\n     }\n }"}, {"sha": "739314bf619086cf5b86b30b0f26d586608eea87", "filename": "src/libcore/util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/be9bddd46377bc982b73acf15a720365a54197a7/src%2Flibcore%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be9bddd46377bc982b73acf15a720365a54197a7/src%2Flibcore%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Futil.rs?ref=be9bddd46377bc982b73acf15a720365a54197a7", "patch": "@@ -18,11 +18,11 @@ use prelude::*;\n \n /// The identity function.\n #[inline(always)]\n-pub pure fn id<T>(x: T) -> T { x }\n+pub fn id<T>(x: T) -> T { x }\n \n /// Ignores a value.\n #[inline(always)]\n-pub pure fn ignore<T>(_x: T) { }\n+pub fn ignore<T>(_x: T) { }\n \n /// Sets `*ptr` to `new_value`, invokes `op()`, and then restores the\n /// original value of `*ptr`."}, {"sha": "56d547874d8dede7f3e8fe852dfcf80c56728a2b", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 228, "deletions": 231, "changes": 459, "blob_url": "https://github.com/rust-lang/rust/blob/be9bddd46377bc982b73acf15a720365a54197a7/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be9bddd46377bc982b73acf15a720365a54197a7/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=be9bddd46377bc982b73acf15a720365a54197a7", "patch": "@@ -47,12 +47,12 @@ pub mod rustrt {\n }\n \n /// Returns true if a vector contains no elements\n-pub pure fn is_empty<T>(v: &[const T]) -> bool {\n+pub fn is_empty<T>(v: &[const T]) -> bool {\n     as_const_buf(v, |_p, len| len == 0u)\n }\n \n /// Returns true if two vectors have the same length\n-pub pure fn same_length<T, U>(xs: &[const T], ys: &[const U]) -> bool {\n+pub fn same_length<T, U>(xs: &[const T], ys: &[const U]) -> bool {\n     xs.len() == ys.len()\n }\n \n@@ -105,7 +105,7 @@ pub fn reserve_at_least<T>(v: &mut ~[T], n: uint) {\n \n /// Returns the number of elements the vector can hold without reallocating\n #[inline(always)]\n-pub pure fn capacity<T>(v: &const ~[T]) -> uint {\n+pub fn capacity<T>(v: &const ~[T]) -> uint {\n     unsafe {\n         let repr: **raw::VecRepr = ::cast::transmute(v);\n         (**repr).unboxed.alloc / sys::nonzero_size_of::<T>()\n@@ -114,12 +114,12 @@ pub pure fn capacity<T>(v: &const ~[T]) -> uint {\n \n /// Returns the length of a vector\n #[inline(always)]\n-pub pure fn len<T>(v: &[const T]) -> uint {\n+pub fn len<T>(v: &[const T]) -> uint {\n     as_const_buf(v, |_p, len| len)\n }\n \n // A botch to tide us over until core and std are fully demuted.\n-pub pure fn uniq_len<T>(v: &const ~[T]) -> uint {\n+pub fn uniq_len<T>(v: &const ~[T]) -> uint {\n     unsafe {\n         let v: &~[T] = ::cast::transmute(v);\n         as_const_buf(*v, |_p, len| len)\n@@ -132,7 +132,7 @@ pub pure fn uniq_len<T>(v: &const ~[T]) -> uint {\n  * Creates an immutable vector of size `n_elts` and initializes the elements\n  * to the value returned by the function `op`.\n  */\n-pub pure fn from_fn<T>(n_elts: uint, op: iter::InitOp<T>) -> ~[T] {\n+pub fn from_fn<T>(n_elts: uint, op: iter::InitOp<T>) -> ~[T] {\n     unsafe {\n         let mut v = with_capacity(n_elts);\n         do as_mut_buf(v) |p, _len| {\n@@ -154,16 +154,16 @@ pub pure fn from_fn<T>(n_elts: uint, op: iter::InitOp<T>) -> ~[T] {\n  * Creates an immutable vector of size `n_elts` and initializes the elements\n  * to the value `t`.\n  */\n-pub pure fn from_elem<T:Copy>(n_elts: uint, t: T) -> ~[T] {\n+pub fn from_elem<T:Copy>(n_elts: uint, t: T) -> ~[T] {\n     from_fn(n_elts, |_i| copy t)\n }\n \n /// Creates a new unique vector with the same contents as the slice\n-pub pure fn from_slice<T:Copy>(t: &[T]) -> ~[T] {\n+pub fn from_slice<T:Copy>(t: &[T]) -> ~[T] {\n     from_fn(t.len(), |i| t[i])\n }\n \n-pub pure fn with_capacity<T>(capacity: uint) -> ~[T] {\n+pub fn with_capacity<T>(capacity: uint) -> ~[T] {\n     let mut vec = ~[];\n     unsafe { reserve(&mut vec, capacity); }\n     vec\n@@ -182,8 +182,7 @@ pub pure fn with_capacity<T>(capacity: uint) -> ~[T] {\n  *             onto the vector being constructed.\n  */\n #[inline(always)]\n-pub pure fn build_sized<A>(size: uint,\n-                       builder: &fn(push: &pure fn(v: A))) -> ~[A] {\n+pub fn build_sized<A>(size: uint, builder: &fn(push: &fn(v: A))) -> ~[A] {\n     let mut vec = with_capacity(size);\n     builder(|x| unsafe { vec.push(x) });\n     vec\n@@ -200,7 +199,7 @@ pub pure fn build_sized<A>(size: uint,\n  *             onto the vector being constructed.\n  */\n #[inline(always)]\n-pub pure fn build<A>(builder: &fn(push: &pure fn(v: A))) -> ~[A] {\n+pub fn build<A>(builder: &fn(push: &fn(v: A))) -> ~[A] {\n     build_sized(4, builder)\n }\n \n@@ -217,54 +216,55 @@ pub pure fn build<A>(builder: &fn(push: &pure fn(v: A))) -> ~[A] {\n  *             onto the vector being constructed.\n  */\n #[inline(always)]\n-pub pure fn build_sized_opt<A>(size: Option<uint>,\n-                           builder: &fn(push: &pure fn(v: A))) -> ~[A] {\n+pub fn build_sized_opt<A>(size: Option<uint>,\n+                          builder: &fn(push: &fn(v: A)))\n+                       -> ~[A] {\n     build_sized(size.get_or_default(4), builder)\n }\n \n // Accessors\n \n /// Returns the first element of a vector\n-pub pure fn head<T>(v: &'r [T]) -> &'r T {\n+pub fn head<T>(v: &'r [T]) -> &'r T {\n     if v.len() == 0 { fail!(~\"head: empty vector\") }\n     &v[0]\n }\n \n /// Returns `Some(x)` where `x` is the first element of the slice `v`,\n /// or `None` if the vector is empty.\n-pub pure fn head_opt<T>(v: &'r [T]) -> Option<&'r T> {\n+pub fn head_opt<T>(v: &'r [T]) -> Option<&'r T> {\n     if v.len() == 0 { None } else { Some(&v[0]) }\n }\n \n /// Returns a vector containing all but the first element of a slice\n-pub pure fn tail<T>(v: &'r [T]) -> &'r [T] { slice(v, 1, v.len()) }\n+pub fn tail<T>(v: &'r [T]) -> &'r [T] { slice(v, 1, v.len()) }\n \n /// Returns a vector containing all but the first `n` elements of a slice\n-pub pure fn tailn<T>(v: &'r [T], n: uint) -> &'r [T] { slice(v, n, v.len()) }\n+pub fn tailn<T>(v: &'r [T], n: uint) -> &'r [T] { slice(v, n, v.len()) }\n \n /// Returns a vector containing all but the last element of a slice\n-pub pure fn init<T>(v: &'r [T]) -> &'r [T] { slice(v, 0, v.len() - 1) }\n+pub fn init<T>(v: &'r [T]) -> &'r [T] { slice(v, 0, v.len() - 1) }\n \n /// Returns a vector containing all but the last `n' elements of a slice\n-pub pure fn initn<T>(v: &'r [T], n: uint) -> &'r [T] {\n+pub fn initn<T>(v: &'r [T], n: uint) -> &'r [T] {\n     slice(v, 0, v.len() - n)\n }\n \n /// Returns the last element of the slice `v`, failing if the slice is empty.\n-pub pure fn last<T>(v: &'r [T]) -> &'r T {\n+pub fn last<T>(v: &'r [T]) -> &'r T {\n     if v.len() == 0 { fail!(~\"last: empty vector\") }\n     &v[v.len() - 1]\n }\n \n /// Returns `Some(x)` where `x` is the last element of the slice `v`, or\n /// `None` if the vector is empty.\n-pub pure fn last_opt<T>(v: &'r [T]) -> Option<&'r T> {\n+pub fn last_opt<T>(v: &'r [T]) -> Option<&'r T> {\n     if v.len() == 0 { None } else { Some(&v[v.len() - 1]) }\n }\n \n /// Return a slice that points into another slice.\n #[inline(always)]\n-pub pure fn slice<T>(v: &'r [T], start: uint, end: uint) -> &'r [T] {\n+pub fn slice<T>(v: &'r [T], start: uint, end: uint) -> &'r [T] {\n     fail_unless!(start <= end);\n     fail_unless!(end <= len(v));\n     do as_imm_buf(v) |p, _len| {\n@@ -278,10 +278,7 @@ pub pure fn slice<T>(v: &'r [T], start: uint, end: uint) -> &'r [T] {\n \n /// Return a slice that points into another slice.\n #[inline(always)]\n-pub pure fn mut_slice<T>(v: &'r mut [T],\n-                         start: uint,\n-                         end: uint)\n-                      -> &'r mut [T] {\n+pub fn mut_slice<T>(v: &'r mut [T], start: uint, end: uint) -> &'r mut [T] {\n     fail_unless!(start <= end);\n     fail_unless!(end <= v.len());\n     do as_mut_buf(v) |p, _len| {\n@@ -295,10 +292,8 @@ pub pure fn mut_slice<T>(v: &'r mut [T],\n \n /// Return a slice that points into another slice.\n #[inline(always)]\n-pub pure fn const_slice<T>(v: &'r [const T],\n-                           start: uint,\n-                           end: uint)\n-                        -> &'r [const T] {\n+pub fn const_slice<T>(v: &'r [const T], start: uint, end: uint)\n+                   -> &'r [const T] {\n     fail_unless!(start <= end);\n     fail_unless!(end <= len(v));\n     do as_const_buf(v) |p, _len| {\n@@ -434,7 +429,7 @@ pub fn partition<T>(v: ~[T], f: &fn(&T) -> bool) -> (~[T], ~[T]) {\n  * Partitions a vector into two new vectors: those that satisfies the\n  * predicate, and those that do not.\n  */\n-pub pure fn partitioned<T:Copy>(v: &[T], f: &fn(&T) -> bool) -> (~[T], ~[T]) {\n+pub fn partitioned<T:Copy>(v: &[T], f: &fn(&T) -> bool) -> (~[T], ~[T]) {\n     let mut lefts  = ~[];\n     let mut rights = ~[];\n \n@@ -713,7 +708,7 @@ pub fn dedup<T:Eq>(v: &mut ~[T]) {\n \n // Appending\n #[inline(always)]\n-pub pure fn append<T:Copy>(lhs: ~[T], rhs: &[const T]) -> ~[T] {\n+pub fn append<T:Copy>(lhs: ~[T], rhs: &[const T]) -> ~[T] {\n     let mut v = lhs;\n     unsafe {\n         v.push_all(rhs);\n@@ -722,7 +717,7 @@ pub pure fn append<T:Copy>(lhs: ~[T], rhs: &[const T]) -> ~[T] {\n }\n \n #[inline(always)]\n-pub pure fn append_one<T>(lhs: ~[T], x: T) -> ~[T] {\n+pub fn append_one<T>(lhs: ~[T], x: T) -> ~[T] {\n     let mut v = lhs;\n     unsafe { v.push(x); }\n     v\n@@ -788,7 +783,7 @@ pub fn grow_set<T:Copy>(v: &mut ~[T], index: uint, initval: &T, val: T) {\n // Functional utilities\n \n /// Apply a function to each element of a vector and return the results\n-pub pure fn map<T, U>(v: &[T], f: &fn(t: &T) -> U) -> ~[U] {\n+pub fn map<T, U>(v: &[T], f: &fn(t: &T) -> U) -> ~[U] {\n     let mut result = with_capacity(len(v));\n     for each(v) |elem| {\n         unsafe {\n@@ -807,7 +802,7 @@ pub fn map_consume<T, U>(v: ~[T], f: &fn(v: T) -> U) -> ~[U] {\n }\n \n /// Apply a function to each element of a vector and return the results\n-pub pure fn mapi<T, U>(v: &[T], f: &fn(uint, t: &T) -> U) -> ~[U] {\n+pub fn mapi<T, U>(v: &[T], f: &fn(uint, t: &T) -> U) -> ~[U] {\n     let mut i = 0;\n     do map(v) |e| {\n         i += 1;\n@@ -819,14 +814,14 @@ pub pure fn mapi<T, U>(v: &[T], f: &fn(uint, t: &T) -> U) -> ~[U] {\n  * Apply a function to each element of a vector and return a concatenation\n  * of each result vector\n  */\n-pub pure fn flat_map<T, U>(v: &[T], f: &fn(t: &T) -> ~[U]) -> ~[U] {\n+pub fn flat_map<T, U>(v: &[T], f: &fn(t: &T) -> ~[U]) -> ~[U] {\n     let mut result = ~[];\n     for each(v) |elem| { unsafe{ result.push_all_move(f(elem)); } }\n     result\n }\n \n /// Apply a function to each pair of elements and return the results\n-pub pure fn map2<T:Copy,U:Copy,V>(v0: &[T], v1: &[U],\n+pub fn map2<T:Copy,U:Copy,V>(v0: &[T], v1: &[U],\n                                   f: &fn(t: &T, v: &U) -> V) -> ~[V] {\n     let v0_len = len(v0);\n     if v0_len != len(v1) { fail!(); }\n@@ -860,7 +855,7 @@ pub fn filter_map<T, U>(\n     result\n }\n \n-pub pure fn filter_mapped<T, U: Copy>(\n+pub fn filter_mapped<T, U: Copy>(\n     v: &[T],\n     f: &fn(t: &T) -> Option<U>) -> ~[U]\n {\n@@ -904,7 +899,7 @@ pub fn filter<T>(v: ~[T], f: &fn(t: &T) -> bool) -> ~[T] {\n  * Apply function `f` to each element of `v` and return a vector containing\n  * only those elements for which `f` returned true.\n  */\n-pub pure fn filtered<T:Copy>(v: &[T], f: &fn(t: &T) -> bool) -> ~[T] {\n+pub fn filtered<T:Copy>(v: &[T], f: &fn(t: &T) -> bool) -> ~[T] {\n     let mut result = ~[];\n     for each(v) |elem| {\n         if f(elem) { unsafe { result.push(*elem); } }\n@@ -915,7 +910,7 @@ pub pure fn filtered<T:Copy>(v: &[T], f: &fn(t: &T) -> bool) -> ~[T] {\n /**\n  * Like `filter()`, but in place.  Preserves order of `v`.  Linear time.\n  */\n-pub fn retain<T>(v: &mut ~[T], f: &pure fn(t: &T) -> bool) {\n+pub fn retain<T>(v: &mut ~[T], f: &fn(t: &T) -> bool) {\n     let len = v.len();\n     let mut deleted: uint = 0;\n \n@@ -937,14 +932,14 @@ pub fn retain<T>(v: &mut ~[T], f: &pure fn(t: &T) -> bool) {\n  *\n  * Flattens a vector of vectors of T into a single vector of T.\n  */\n-pub pure fn concat<T:Copy>(v: &[~[T]]) -> ~[T] {\n+pub fn concat<T:Copy>(v: &[~[T]]) -> ~[T] {\n     let mut r = ~[];\n     for each(v) |inner| { unsafe { r.push_all(*inner); } }\n     r\n }\n \n /// Concatenate a vector of vectors, placing a given separator between each\n-pub pure fn connect<T:Copy>(v: &[~[T]], sep: &T) -> ~[T] {\n+pub fn connect<T:Copy>(v: &[~[T]], sep: &T) -> ~[T] {\n     let mut r: ~[T] = ~[];\n     let mut first = true;\n     for each(v) |inner| {\n@@ -971,7 +966,7 @@ pub pure fn connect<T:Copy>(v: &[~[T]], sep: &T) -> ~[T] {\n  * ~~~\n  *\n  */\n-pub pure fn foldl<T, U>(z: T, v: &[U], p: &fn(t: T, u: &U) -> T) -> T {\n+pub fn foldl<T, U>(z: T, v: &[U], p: &fn(t: T, u: &U) -> T) -> T {\n     let mut accum = z;\n     let mut i = 0;\n     let l = v.len();\n@@ -1003,7 +998,7 @@ pub pure fn foldl<T, U>(z: T, v: &[U], p: &fn(t: T, u: &U) -> T) -> T {\n  * ~~~\n  *\n  */\n-pub pure fn foldr<T, U: Copy>(v: &[T], z: U, p: &fn(t: &T, u: U) -> U) -> U {\n+pub fn foldr<T, U: Copy>(v: &[T], z: U, p: &fn(t: &T, u: U) -> U) -> U {\n     let mut accum = z;\n     for v.each_reverse |elt| {\n         accum = p(elt, accum);\n@@ -1016,7 +1011,7 @@ pub pure fn foldr<T, U: Copy>(v: &[T], z: U, p: &fn(t: &T, u: U) -> U) -> U {\n  *\n  * If the vector contains no elements then false is returned.\n  */\n-pub pure fn any<T>(v: &[T], f: &fn(t: &T) -> bool) -> bool {\n+pub fn any<T>(v: &[T], f: &fn(t: &T) -> bool) -> bool {\n     for each(v) |elem| { if f(elem) { return true; } }\n     false\n }\n@@ -1026,7 +1021,7 @@ pub pure fn any<T>(v: &[T], f: &fn(t: &T) -> bool) -> bool {\n  *\n  * If the vectors contains no elements then false is returned.\n  */\n-pub pure fn any2<T, U>(v0: &[T], v1: &[U],\n+pub fn any2<T, U>(v0: &[T], v1: &[U],\n                    f: &fn(a: &T, b: &U) -> bool) -> bool {\n     let v0_len = len(v0);\n     let v1_len = len(v1);\n@@ -1043,7 +1038,7 @@ pub pure fn any2<T, U>(v0: &[T], v1: &[U],\n  *\n  * If the vector contains no elements then true is returned.\n  */\n-pub pure fn all<T>(v: &[T], f: &fn(t: &T) -> bool) -> bool {\n+pub fn all<T>(v: &[T], f: &fn(t: &T) -> bool) -> bool {\n     for each(v) |elem| { if !f(elem) { return false; } }\n     true\n }\n@@ -1053,7 +1048,7 @@ pub pure fn all<T>(v: &[T], f: &fn(t: &T) -> bool) -> bool {\n  *\n  * If the vector contains no elements then true is returned.\n  */\n-pub pure fn alli<T>(v: &[T], f: &fn(uint, t: &T) -> bool) -> bool {\n+pub fn alli<T>(v: &[T], f: &fn(uint, t: &T) -> bool) -> bool {\n     for eachi(v) |i, elem| { if !f(i, elem) { return false; } }\n     true\n }\n@@ -1063,7 +1058,7 @@ pub pure fn alli<T>(v: &[T], f: &fn(uint, t: &T) -> bool) -> bool {\n  *\n  * If the vectors are not the same size then false is returned.\n  */\n-pub pure fn all2<T, U>(v0: &[T], v1: &[U],\n+pub fn all2<T, U>(v0: &[T], v1: &[U],\n                    f: &fn(t: &T, u: &U) -> bool) -> bool {\n     let v0_len = len(v0);\n     if v0_len != len(v1) { return false; }\n@@ -1073,13 +1068,13 @@ pub pure fn all2<T, U>(v0: &[T], v1: &[U],\n }\n \n /// Return true if a vector contains an element with the given value\n-pub pure fn contains<T:Eq>(v: &[T], x: &T) -> bool {\n+pub fn contains<T:Eq>(v: &[T], x: &T) -> bool {\n     for each(v) |elt| { if *x == *elt { return true; } }\n     false\n }\n \n /// Returns the number of elements that are equal to a given value\n-pub pure fn count<T:Eq>(v: &[T], x: &T) -> uint {\n+pub fn count<T:Eq>(v: &[T], x: &T) -> uint {\n     let mut cnt = 0u;\n     for each(v) |elt| { if *x == *elt { cnt += 1u; } }\n     cnt\n@@ -1092,7 +1087,7 @@ pub pure fn count<T:Eq>(v: &[T], x: &T) -> uint {\n  * When function `f` returns true then an option containing the element\n  * is returned. If `f` matches no elements then none is returned.\n  */\n-pub pure fn find<T:Copy>(v: &[T], f: &fn(t: &T) -> bool) -> Option<T> {\n+pub fn find<T:Copy>(v: &[T], f: &fn(t: &T) -> bool) -> Option<T> {\n     find_between(v, 0u, len(v), f)\n }\n \n@@ -1103,7 +1098,7 @@ pub pure fn find<T:Copy>(v: &[T], f: &fn(t: &T) -> bool) -> Option<T> {\n  * [`start`, `end`). When function `f` returns true then an option containing\n  * the element is returned. If `f` matches no elements then none is returned.\n  */\n-pub pure fn find_between<T:Copy>(v: &[T], start: uint, end: uint,\n+pub fn find_between<T:Copy>(v: &[T], start: uint, end: uint,\n                       f: &fn(t: &T) -> bool) -> Option<T> {\n     position_between(v, start, end, f).map(|i| v[*i])\n }\n@@ -1115,7 +1110,7 @@ pub pure fn find_between<T:Copy>(v: &[T], start: uint, end: uint,\n  * `f` returns true then an option containing the element is returned. If `f`\n  * matches no elements then none is returned.\n  */\n-pub pure fn rfind<T:Copy>(v: &[T], f: &fn(t: &T) -> bool) -> Option<T> {\n+pub fn rfind<T:Copy>(v: &[T], f: &fn(t: &T) -> bool) -> Option<T> {\n     rfind_between(v, 0u, len(v), f)\n }\n \n@@ -1126,13 +1121,16 @@ pub pure fn rfind<T:Copy>(v: &[T], f: &fn(t: &T) -> bool) -> Option<T> {\n  * [`start`, `end`). When function `f` returns true then an option containing\n  * the element is returned. If `f` matches no elements then none is return.\n  */\n-pub pure fn rfind_between<T:Copy>(v: &[T], start: uint, end: uint,\n-                               f: &fn(t: &T) -> bool) -> Option<T> {\n+pub fn rfind_between<T:Copy>(v: &[T],\n+                             start: uint,\n+                             end: uint,\n+                             f: &fn(t: &T) -> bool)\n+                          -> Option<T> {\n     rposition_between(v, start, end, f).map(|i| v[*i])\n }\n \n /// Find the first index containing a matching value\n-pub pure fn position_elem<T:Eq>(v: &[T], x: &T) -> Option<uint> {\n+pub fn position_elem<T:Eq>(v: &[T], x: &T) -> Option<uint> {\n     position(v, |y| *x == *y)\n }\n \n@@ -1143,7 +1141,7 @@ pub pure fn position_elem<T:Eq>(v: &[T], x: &T) -> Option<uint> {\n  * then an option containing the index is returned. If `f` matches no elements\n  * then none is returned.\n  */\n-pub pure fn position<T>(v: &[T], f: &fn(t: &T) -> bool) -> Option<uint> {\n+pub fn position<T>(v: &[T], f: &fn(t: &T) -> bool) -> Option<uint> {\n     position_between(v, 0u, len(v), f)\n }\n \n@@ -1154,8 +1152,11 @@ pub pure fn position<T>(v: &[T], f: &fn(t: &T) -> bool) -> Option<uint> {\n  * [`start`, `end`). When function `f` returns true then an option containing\n  * the index is returned. If `f` matches no elements then none is returned.\n  */\n-pub pure fn position_between<T>(v: &[T], start: uint, end: uint,\n-                            f: &fn(t: &T) -> bool) -> Option<uint> {\n+pub fn position_between<T>(v: &[T],\n+                           start: uint,\n+                           end: uint,\n+                           f: &fn(t: &T) -> bool)\n+                        -> Option<uint> {\n     fail_unless!(start <= end);\n     fail_unless!(end <= len(v));\n     let mut i = start;\n@@ -1164,7 +1165,7 @@ pub pure fn position_between<T>(v: &[T], start: uint, end: uint,\n }\n \n /// Find the last index containing a matching value\n-pure fn rposition_elem<T:Eq>(v: &[T], x: &T) -> Option<uint> {\n+pub fn rposition_elem<T:Eq>(v: &[T], x: &T) -> Option<uint> {\n     rposition(v, |y| *x == *y)\n }\n \n@@ -1175,7 +1176,7 @@ pure fn rposition_elem<T:Eq>(v: &[T], x: &T) -> Option<uint> {\n  * `f` returns true then an option containing the index is returned. If `f`\n  * matches no elements then none is returned.\n  */\n-pub pure fn rposition<T>(v: &[T], f: &fn(t: &T) -> bool) -> Option<uint> {\n+pub fn rposition<T>(v: &[T], f: &fn(t: &T) -> bool) -> Option<uint> {\n     rposition_between(v, 0u, len(v), f)\n }\n \n@@ -1187,7 +1188,7 @@ pub pure fn rposition<T>(v: &[T], f: &fn(t: &T) -> bool) -> Option<uint> {\n  * containing the index is returned. If `f` matches no elements then none is\n  * returned.\n  */\n-pub pure fn rposition_between<T>(v: &[T], start: uint, end: uint,\n+pub fn rposition_between<T>(v: &[T], start: uint, end: uint,\n                              f: &fn(t: &T) -> bool) -> Option<uint> {\n     fail_unless!(start <= end);\n     fail_unless!(end <= len(v));\n@@ -1206,7 +1207,7 @@ pub pure fn rposition_between<T>(v: &[T], start: uint, end: uint,\n /**\n  * Convert a vector of pairs into a pair of vectors, by reference. As unzip().\n  */\n-pure fn unzip_slice<T:Copy,U:Copy>(v: &[(T, U)]) -> (~[T], ~[U]) {\n+pub fn unzip_slice<T:Copy,U:Copy>(v: &[(T, U)]) -> (~[T], ~[U]) {\n     let mut ts = ~[], us = ~[];\n     for each(v) |p| {\n         let (t, u) = *p;\n@@ -1226,7 +1227,7 @@ pure fn unzip_slice<T:Copy,U:Copy>(v: &[(T, U)]) -> (~[T], ~[U]) {\n  * and the i-th element of the second vector contains the second element\n  * of the i-th tuple of the input vector.\n  */\n-pub pure fn unzip<T,U>(v: ~[(T, U)]) -> (~[T], ~[U]) {\n+pub fn unzip<T,U>(v: ~[(T, U)]) -> (~[T], ~[U]) {\n     let mut ts = ~[], us = ~[];\n     unsafe {\n         do consume(v) |_i, p| {\n@@ -1241,7 +1242,7 @@ pub pure fn unzip<T,U>(v: ~[(T, U)]) -> (~[T], ~[U]) {\n /**\n  * Convert two vectors to a vector of pairs, by reference. As zip().\n  */\n-pub pure fn zip_slice<T:Copy,U:Copy>(v: &[const T], u: &[const U])\n+pub fn zip_slice<T:Copy,U:Copy>(v: &[const T], u: &[const U])\n         -> ~[(T, U)] {\n     let mut zipped = ~[];\n     let sz = len(v);\n@@ -1259,7 +1260,7 @@ pub pure fn zip_slice<T:Copy,U:Copy>(v: &[const T], u: &[const U])\n  * Returns a vector of tuples, where the i-th tuple contains contains the\n  * i-th elements from each of the input vectors.\n  */\n-pub pure fn zip<T, U>(mut v: ~[T], mut u: ~[U]) -> ~[(T, U)] {\n+pub fn zip<T, U>(mut v: ~[T], mut u: ~[U]) -> ~[(T, U)] {\n     let mut i = len(v);\n     fail_unless!(i == len(u));\n     let mut w = with_capacity(i);\n@@ -1292,7 +1293,7 @@ pub fn reverse<T>(v: &mut [T]) {\n }\n \n /// Returns a vector with the order of elements reversed\n-pub pure fn reversed<T:Copy>(v: &[const T]) -> ~[T] {\n+pub fn reversed<T:Copy>(v: &[const T]) -> ~[T] {\n     let mut rs: ~[T] = ~[];\n     let mut i = len::<T>(v);\n     if i == 0 { return (rs); } else { i -= 1; }\n@@ -1342,7 +1343,7 @@ pub pure fn reversed<T:Copy>(v: &[const T]) -> ~[T] {\n  * ~~~\n  */\n #[inline(always)]\n-pub pure fn each<T>(v: &'r [T], f: &fn(&'r T) -> bool) {\n+pub fn each<T>(v: &'r [T], f: &fn(&'r T) -> bool) {\n     //             ^^^^\n     // NB---this CANNOT be &[const T]!  The reason\n     // is that you are passing it to `f()` using\n@@ -1380,7 +1381,7 @@ pub fn each_mut<T>(v: &'r mut [T], f: &fn(elem: &'r mut T) -> bool) {\n /// Like `each()`, but for the case where you have a vector that *may or may\n /// not* have mutable contents.\n #[inline(always)]\n-pub pure fn each_const<T>(v: &[const T], f: &fn(elem: &const T) -> bool) {\n+pub fn each_const<T>(v: &[const T], f: &fn(elem: &const T) -> bool) {\n     let mut i = 0;\n     let n = v.len();\n     while i < n {\n@@ -1397,7 +1398,7 @@ pub pure fn each_const<T>(v: &[const T], f: &fn(elem: &const T) -> bool) {\n  * Return true to continue, false to break.\n  */\n #[inline(always)]\n-pub pure fn eachi<T>(v: &'r [T], f: &fn(uint, v: &'r T) -> bool) {\n+pub fn eachi<T>(v: &'r [T], f: &fn(uint, v: &'r T) -> bool) {\n     let mut i = 0;\n     for each(v) |p| {\n         if !f(i, p) { return; }\n@@ -1411,7 +1412,7 @@ pub pure fn eachi<T>(v: &'r [T], f: &fn(uint, v: &'r T) -> bool) {\n  * Return true to continue, false to break.\n  */\n #[inline(always)]\n-pub pure fn each_reverse<T>(v: &'r [T], blk: &fn(v: &'r T) -> bool) {\n+pub fn each_reverse<T>(v: &'r [T], blk: &fn(v: &'r T) -> bool) {\n     eachi_reverse(v, |_i, v| blk(v))\n }\n \n@@ -1421,7 +1422,7 @@ pub pure fn each_reverse<T>(v: &'r [T], blk: &fn(v: &'r T) -> bool) {\n  * Return true to continue, false to break.\n  */\n #[inline(always)]\n-pub pure fn eachi_reverse<T>(v: &'r [T], blk: &fn(i: uint, v: &'r T) -> bool) {\n+pub fn eachi_reverse<T>(v: &'r [T], blk: &fn(i: uint, v: &'r T) -> bool) {\n     let mut i = v.len();\n     while i > 0 {\n         i -= 1;\n@@ -1439,7 +1440,7 @@ pub pure fn eachi_reverse<T>(v: &'r [T], blk: &fn(i: uint, v: &'r T) -> bool) {\n  * Both vectors must have the same length\n  */\n #[inline]\n-pub pure fn each2<U, T>(v1: &[U], v2: &[T], f: &fn(u: &U, t: &T) -> bool) {\n+pub fn each2<U, T>(v1: &[U], v2: &[T], f: &fn(u: &U, t: &T) -> bool) {\n     fail_unless!(len(v1) == len(v2));\n     for uint::range(0u, len(v1)) |i| {\n         if !f(&v1[i], &v2[i]) {\n@@ -1458,7 +1459,7 @@ pub pure fn each2<U, T>(v1: &[U], v2: &[T], f: &fn(u: &U, t: &T) -> bool) {\n  * The total number of permutations produced is `len(v)!`.  If `v` contains\n  * repeated elements, then some permutations are repeated.\n  */\n-pub pure fn each_permutation<T:Copy>(v: &[T], put: &fn(ts: &[T]) -> bool) {\n+pub fn each_permutation<T:Copy>(v: &[T], put: &fn(ts: &[T]) -> bool) {\n     let ln = len(v);\n     if ln <= 1 {\n         put(v);\n@@ -1482,7 +1483,7 @@ pub pure fn each_permutation<T:Copy>(v: &[T], put: &fn(ts: &[T]) -> bool) {\n     }\n }\n \n-pub pure fn windowed<TT:Copy>(nn: uint, xx: &[TT]) -> ~[~[TT]] {\n+pub fn windowed<TT:Copy>(nn: uint, xx: &[TT]) -> ~[~[TT]] {\n     let mut ww = ~[];\n     fail_unless!(1u <= nn);\n     for vec::eachi (xx) |ii, _x| {\n@@ -1503,9 +1504,9 @@ pub pure fn windowed<TT:Copy>(nn: uint, xx: &[TT]) -> ~[~[TT]] {\n  * foreign interop.\n  */\n #[inline(always)]\n-pub pure fn as_imm_buf<T,U>(s: &[T],\n-                            /* NB---this CANNOT be const, see below */\n-                            f: &fn(*T, uint) -> U) -> U {\n+pub fn as_imm_buf<T,U>(s: &[T],\n+                       /* NB---this CANNOT be const, see below */\n+                       f: &fn(*T, uint) -> U) -> U {\n \n     // NB---Do not change the type of s to `&[const T]`.  This is\n     // unsound.  The reason is that we are going to create immutable pointers\n@@ -1523,9 +1524,7 @@ pub pure fn as_imm_buf<T,U>(s: &[T],\n \n /// Similar to `as_imm_buf` but passing a `*const T`\n #[inline(always)]\n-pub pure fn as_const_buf<T,U>(s: &[const T],\n-                          f: &fn(*const T, uint) -> U) -> U {\n-\n+pub fn as_const_buf<T,U>(s: &[const T], f: &fn(*const T, uint) -> U) -> U {\n     unsafe {\n         let v : *(*const T,uint) =\n             ::cast::reinterpret_cast(&addr_of(&s));\n@@ -1536,9 +1535,7 @@ pub pure fn as_const_buf<T,U>(s: &[const T],\n \n /// Similar to `as_imm_buf` but passing a `*mut T`\n #[inline(always)]\n-pub pure fn as_mut_buf<T,U>(s: &mut [T],\n-                        f: &fn(*mut T, uint) -> U) -> U {\n-\n+pub fn as_mut_buf<T,U>(s: &mut [T], f: &fn(*mut T, uint) -> U) -> U {\n     unsafe {\n         let v : *(*mut T,uint) =\n             ::cast::reinterpret_cast(&addr_of(&s));\n@@ -1549,7 +1546,7 @@ pub pure fn as_mut_buf<T,U>(s: &mut [T],\n \n // Equality\n \n-pure fn eq<T:Eq>(a: &[T], b: &[T]) -> bool {\n+fn eq<T:Eq>(a: &[T], b: &[T]) -> bool {\n     let (a_len, b_len) = (a.len(), b.len());\n     if a_len != b_len { return false; }\n \n@@ -1565,37 +1562,37 @@ pure fn eq<T:Eq>(a: &[T], b: &[T]) -> bool {\n #[cfg(notest)]\n impl<T:Eq> Eq for &'self [T] {\n     #[inline(always)]\n-    pure fn eq(&self, other: & &'self [T]) -> bool { eq((*self), (*other)) }\n+    fn eq(&self, other: & &'self [T]) -> bool { eq((*self), (*other)) }\n     #[inline(always)]\n-    pure fn ne(&self, other: & &'self [T]) -> bool { !(*self).eq(other) }\n+    fn ne(&self, other: & &'self [T]) -> bool { !(*self).eq(other) }\n }\n \n \n #[cfg(notest)]\n impl<T:Eq> Eq for ~[T] {\n     #[inline(always)]\n-    pure fn eq(&self, other: &~[T]) -> bool { eq((*self), (*other)) }\n+    fn eq(&self, other: &~[T]) -> bool { eq((*self), (*other)) }\n     #[inline(always)]\n-    pure fn ne(&self, other: &~[T]) -> bool { !(*self).eq(other) }\n+    fn ne(&self, other: &~[T]) -> bool { !(*self).eq(other) }\n }\n \n #[cfg(notest)]\n impl<T:Eq> Eq for @[T] {\n     #[inline(always)]\n-    pure fn eq(&self, other: &@[T]) -> bool { eq((*self), (*other)) }\n+    fn eq(&self, other: &@[T]) -> bool { eq((*self), (*other)) }\n     #[inline(always)]\n-    pure fn ne(&self, other: &@[T]) -> bool { !(*self).eq(other) }\n+    fn ne(&self, other: &@[T]) -> bool { !(*self).eq(other) }\n }\n \n #[cfg(notest)]\n impl<T:Eq> Equiv<~[T]> for &'self [T] {\n     #[inline(always)]\n-    pure fn equiv(&self, other: &~[T]) -> bool { eq(*self, *other) }\n+    fn equiv(&self, other: &~[T]) -> bool { eq(*self, *other) }\n }\n \n // Lexicographical comparison\n \n-pure fn cmp<T: TotalOrd>(a: &[T], b: &[T]) -> Ordering {\n+fn cmp<T: TotalOrd>(a: &[T], b: &[T]) -> Ordering {\n     let low = uint::min(a.len(), b.len());\n \n     for uint::range(0, low) |idx| {\n@@ -1612,22 +1609,22 @@ pure fn cmp<T: TotalOrd>(a: &[T], b: &[T]) -> Ordering {\n #[cfg(notest)]\n impl<T: TotalOrd> TotalOrd for &'self [T] {\n     #[inline(always)]\n-    pure fn cmp(&self, other: & &'self [T]) -> Ordering { cmp(*self, *other) }\n+    fn cmp(&self, other: & &'self [T]) -> Ordering { cmp(*self, *other) }\n }\n \n #[cfg(notest)]\n impl<T: TotalOrd> TotalOrd for ~[T] {\n     #[inline(always)]\n-    pure fn cmp(&self, other: &~[T]) -> Ordering { cmp(*self, *other) }\n+    fn cmp(&self, other: &~[T]) -> Ordering { cmp(*self, *other) }\n }\n \n #[cfg(notest)]\n impl<T: TotalOrd> TotalOrd for @[T] {\n     #[inline(always)]\n-    pure fn cmp(&self, other: &@[T]) -> Ordering { cmp(*self, *other) }\n+    fn cmp(&self, other: &@[T]) -> Ordering { cmp(*self, *other) }\n }\n \n-pure fn lt<T:Ord>(a: &[T], b: &[T]) -> bool {\n+fn lt<T:Ord>(a: &[T], b: &[T]) -> bool {\n     let (a_len, b_len) = (a.len(), b.len());\n     let mut end = uint::min(a_len, b_len);\n \n@@ -1642,44 +1639,44 @@ pure fn lt<T:Ord>(a: &[T], b: &[T]) -> bool {\n     a_len < b_len\n }\n \n-pure fn le<T:Ord>(a: &[T], b: &[T]) -> bool { !lt(b, a) }\n-pure fn ge<T:Ord>(a: &[T], b: &[T]) -> bool { !lt(a, b) }\n-pure fn gt<T:Ord>(a: &[T], b: &[T]) -> bool { lt(b, a)  }\n+fn le<T:Ord>(a: &[T], b: &[T]) -> bool { !lt(b, a) }\n+fn ge<T:Ord>(a: &[T], b: &[T]) -> bool { !lt(a, b) }\n+fn gt<T:Ord>(a: &[T], b: &[T]) -> bool { lt(b, a)  }\n \n #[cfg(notest)]\n impl<T:Ord> Ord for &'self [T] {\n     #[inline(always)]\n-    pure fn lt(&self, other: & &'self [T]) -> bool { lt((*self), (*other)) }\n+    fn lt(&self, other: & &'self [T]) -> bool { lt((*self), (*other)) }\n     #[inline(always)]\n-    pure fn le(&self, other: & &'self [T]) -> bool { le((*self), (*other)) }\n+    fn le(&self, other: & &'self [T]) -> bool { le((*self), (*other)) }\n     #[inline(always)]\n-    pure fn ge(&self, other: & &'self [T]) -> bool { ge((*self), (*other)) }\n+    fn ge(&self, other: & &'self [T]) -> bool { ge((*self), (*other)) }\n     #[inline(always)]\n-    pure fn gt(&self, other: & &'self [T]) -> bool { gt((*self), (*other)) }\n+    fn gt(&self, other: & &'self [T]) -> bool { gt((*self), (*other)) }\n }\n \n #[cfg(notest)]\n impl<T:Ord> Ord for ~[T] {\n     #[inline(always)]\n-    pure fn lt(&self, other: &~[T]) -> bool { lt((*self), (*other)) }\n+    fn lt(&self, other: &~[T]) -> bool { lt((*self), (*other)) }\n     #[inline(always)]\n-    pure fn le(&self, other: &~[T]) -> bool { le((*self), (*other)) }\n+    fn le(&self, other: &~[T]) -> bool { le((*self), (*other)) }\n     #[inline(always)]\n-    pure fn ge(&self, other: &~[T]) -> bool { ge((*self), (*other)) }\n+    fn ge(&self, other: &~[T]) -> bool { ge((*self), (*other)) }\n     #[inline(always)]\n-    pure fn gt(&self, other: &~[T]) -> bool { gt((*self), (*other)) }\n+    fn gt(&self, other: &~[T]) -> bool { gt((*self), (*other)) }\n }\n \n #[cfg(notest)]\n impl<T:Ord> Ord for @[T] {\n     #[inline(always)]\n-    pure fn lt(&self, other: &@[T]) -> bool { lt((*self), (*other)) }\n+    fn lt(&self, other: &@[T]) -> bool { lt((*self), (*other)) }\n     #[inline(always)]\n-    pure fn le(&self, other: &@[T]) -> bool { le((*self), (*other)) }\n+    fn le(&self, other: &@[T]) -> bool { le((*self), (*other)) }\n     #[inline(always)]\n-    pure fn ge(&self, other: &@[T]) -> bool { ge((*self), (*other)) }\n+    fn ge(&self, other: &@[T]) -> bool { ge((*self), (*other)) }\n     #[inline(always)]\n-    pure fn gt(&self, other: &@[T]) -> bool { gt((*self), (*other)) }\n+    fn gt(&self, other: &@[T]) -> bool { gt((*self), (*other)) }\n }\n \n #[cfg(notest)]\n@@ -1690,7 +1687,7 @@ pub mod traits {\n \n     impl<T:Copy> Add<&'self [const T],~[T]> for ~[T] {\n         #[inline(always)]\n-        pure fn add(&self, rhs: & &'self [const T]) -> ~[T] {\n+        fn add(&self, rhs: & &'self [const T]) -> ~[T] {\n             append(copy *self, (*rhs))\n         }\n     }\n@@ -1699,22 +1696,22 @@ pub mod traits {\n impl<T> Container for &'self [const T] {\n     /// Returns true if a vector contains no elements\n     #[inline]\n-    pure fn is_empty(&const self) -> bool { is_empty(*self) }\n+    fn is_empty(&const self) -> bool { is_empty(*self) }\n \n     /// Returns the length of a vector\n     #[inline]\n-    pure fn len(&const self) -> uint { len(*self) }\n+    fn len(&const self) -> uint { len(*self) }\n }\n \n pub trait CopyableVector<T> {\n-    pure fn to_owned(&self) -> ~[T];\n+    fn to_owned(&self) -> ~[T];\n }\n \n /// Extension methods for vectors\n impl<T: Copy> CopyableVector<T> for &'self [const T] {\n     /// Returns a copy of `v`.\n     #[inline]\n-    pure fn to_owned(&self) -> ~[T] {\n+    fn to_owned(&self) -> ~[T] {\n         let mut result = ~[];\n         // FIXME: #4568\n         unsafe {\n@@ -1729,93 +1726,93 @@ impl<T: Copy> CopyableVector<T> for &'self [const T] {\n }\n \n pub trait ImmutableVector<T> {\n-    pure fn slice(&self, start: uint, end: uint) -> &'self [T];\n-    pure fn head(&self) -> &'self T;\n-    pure fn head_opt(&self) -> Option<&'self T>;\n-    pure fn tail(&self) -> &'self [T];\n-    pure fn tailn(&self, n: uint) -> &'self [T];\n-    pure fn init(&self) -> &'self [T];\n-    pure fn initn(&self, n: uint) -> &'self [T];\n-    pure fn last(&self) -> &'self T;\n-    pure fn last_opt(&self) -> Option<&'self T>;\n-    pure fn each_reverse(&self, blk: &fn(&T) -> bool);\n-    pure fn eachi_reverse(&self, blk: &fn(uint, &T) -> bool);\n-    pure fn foldr<U: Copy>(&self, z: U, p: &fn(t: &T, u: U) -> U) -> U;\n-    pure fn map<U>(&self, f: &fn(t: &T) -> U) -> ~[U];\n-    pure fn mapi<U>(&self, f: &fn(uint, t: &T) -> U) -> ~[U];\n+    fn slice(&self, start: uint, end: uint) -> &'self [T];\n+    fn head(&self) -> &'self T;\n+    fn head_opt(&self) -> Option<&'self T>;\n+    fn tail(&self) -> &'self [T];\n+    fn tailn(&self, n: uint) -> &'self [T];\n+    fn init(&self) -> &'self [T];\n+    fn initn(&self, n: uint) -> &'self [T];\n+    fn last(&self) -> &'self T;\n+    fn last_opt(&self) -> Option<&'self T>;\n+    fn each_reverse(&self, blk: &fn(&T) -> bool);\n+    fn eachi_reverse(&self, blk: &fn(uint, &T) -> bool);\n+    fn foldr<U: Copy>(&self, z: U, p: &fn(t: &T, u: U) -> U) -> U;\n+    fn map<U>(&self, f: &fn(t: &T) -> U) -> ~[U];\n+    fn mapi<U>(&self, f: &fn(uint, t: &T) -> U) -> ~[U];\n     fn map_r<U>(&self, f: &fn(x: &T) -> U) -> ~[U];\n-    pure fn alli(&self, f: &fn(uint, t: &T) -> bool) -> bool;\n-    pure fn flat_map<U>(&self, f: &fn(t: &T) -> ~[U]) -> ~[U];\n-    pure fn filter_mapped<U:Copy>(&self, f: &fn(t: &T) -> Option<U>) -> ~[U];\n+    fn alli(&self, f: &fn(uint, t: &T) -> bool) -> bool;\n+    fn flat_map<U>(&self, f: &fn(t: &T) -> ~[U]) -> ~[U];\n+    fn filter_mapped<U:Copy>(&self, f: &fn(t: &T) -> Option<U>) -> ~[U];\n }\n \n /// Extension methods for vectors\n impl<T> ImmutableVector<T> for &'self [T] {\n     /// Return a slice that points into another slice.\n     #[inline]\n-    pure fn slice(&self, start: uint, end: uint) -> &'self [T] {\n+    fn slice(&self, start: uint, end: uint) -> &'self [T] {\n         slice(*self, start, end)\n     }\n \n     /// Returns the first element of a vector, failing if the vector is empty.\n     #[inline]\n-    pure fn head(&self) -> &'self T { head(*self) }\n+    fn head(&self) -> &'self T { head(*self) }\n \n     /// Returns the first element of a vector\n     #[inline]\n-    pure fn head_opt(&self) -> Option<&'self T> { head_opt(*self) }\n+    fn head_opt(&self) -> Option<&'self T> { head_opt(*self) }\n \n     /// Returns all but the first element of a vector\n     #[inline]\n-    pure fn tail(&self) -> &'self [T] { tail(*self) }\n+    fn tail(&self) -> &'self [T] { tail(*self) }\n \n     /// Returns all but the first `n' elements of a vector\n     #[inline]\n-    pure fn tailn(&self, n: uint) -> &'self [T] { tailn(*self, n) }\n+    fn tailn(&self, n: uint) -> &'self [T] { tailn(*self, n) }\n \n     /// Returns all but the last elemnt of a vector\n     #[inline]\n-    pure fn init(&self) -> &'self [T] { init(*self) }\n+    fn init(&self) -> &'self [T] { init(*self) }\n \n     /// Returns all but the last `n' elemnts of a vector\n     #[inline]\n-    pure fn initn(&self, n: uint) -> &'self [T] { initn(*self, n) }\n+    fn initn(&self, n: uint) -> &'self [T] { initn(*self, n) }\n \n     /// Returns the last element of a `v`, failing if the vector is empty.\n     #[inline]\n-    pure fn last(&self) -> &'self T { last(*self) }\n+    fn last(&self) -> &'self T { last(*self) }\n \n     /// Returns the last element of a `v`, failing if the vector is empty.\n     #[inline]\n-    pure fn last_opt(&self) -> Option<&'self T> { last_opt(*self) }\n+    fn last_opt(&self) -> Option<&'self T> { last_opt(*self) }\n \n     /// Iterates over a vector's elements in reverse.\n     #[inline]\n-    pure fn each_reverse(&self, blk: &fn(&T) -> bool) {\n+    fn each_reverse(&self, blk: &fn(&T) -> bool) {\n         each_reverse(*self, blk)\n     }\n \n     /// Iterates over a vector's elements and indices in reverse.\n     #[inline]\n-    pure fn eachi_reverse(&self, blk: &fn(uint, &T) -> bool) {\n+    fn eachi_reverse(&self, blk: &fn(uint, &T) -> bool) {\n         eachi_reverse(*self, blk)\n     }\n \n     /// Reduce a vector from right to left\n     #[inline]\n-    pure fn foldr<U:Copy>(&self, z: U, p: &fn(t: &T, u: U) -> U) -> U {\n+    fn foldr<U:Copy>(&self, z: U, p: &fn(t: &T, u: U) -> U) -> U {\n         foldr(*self, z, p)\n     }\n \n     /// Apply a function to each element of a vector and return the results\n     #[inline]\n-    pure fn map<U>(&self, f: &fn(t: &T) -> U) -> ~[U] { map(*self, f) }\n+    fn map<U>(&self, f: &fn(t: &T) -> U) -> ~[U] { map(*self, f) }\n \n     /**\n      * Apply a function to the index and value of each element in the vector\n      * and return the results\n      */\n-    pure fn mapi<U>(&self, f: &fn(uint, t: &T) -> U) -> ~[U] {\n+    fn mapi<U>(&self, f: &fn(uint, t: &T) -> U) -> ~[U] {\n         mapi(*self, f)\n     }\n \n@@ -1835,15 +1832,15 @@ impl<T> ImmutableVector<T> for &'self [T] {\n      *\n      *     If the vector is empty, true is returned.\n      */\n-    pure fn alli(&self, f: &fn(uint, t: &T) -> bool) -> bool {\n+    fn alli(&self, f: &fn(uint, t: &T) -> bool) -> bool {\n         alli(*self, f)\n     }\n     /**\n      * Apply a function to each element of a vector and return a concatenation\n      * of each result vector\n      */\n     #[inline]\n-    pure fn flat_map<U>(&self, f: &fn(t: &T) -> ~[U]) -> ~[U] {\n+    fn flat_map<U>(&self, f: &fn(t: &T) -> ~[U]) -> ~[U] {\n         flat_map(*self, f)\n     }\n     /**\n@@ -1853,16 +1850,16 @@ impl<T> ImmutableVector<T> for &'self [T] {\n      * the resulting vector.\n      */\n     #[inline]\n-    pure fn filter_mapped<U:Copy>(&self, f: &fn(t: &T) -> Option<U>) -> ~[U] {\n+    fn filter_mapped<U:Copy>(&self, f: &fn(t: &T) -> Option<U>) -> ~[U] {\n         filter_mapped(*self, f)\n     }\n }\n \n pub trait ImmutableEqVector<T:Eq> {\n-    pure fn position(&self, f: &fn(t: &T) -> bool) -> Option<uint>;\n-    pure fn position_elem(&self, t: &T) -> Option<uint>;\n-    pure fn rposition(&self, f: &fn(t: &T) -> bool) -> Option<uint>;\n-    pure fn rposition_elem(&self, t: &T) -> Option<uint>;\n+    fn position(&self, f: &fn(t: &T) -> bool) -> Option<uint>;\n+    fn position_elem(&self, t: &T) -> Option<uint>;\n+    fn rposition(&self, f: &fn(t: &T) -> bool) -> Option<uint>;\n+    fn rposition_elem(&self, t: &T) -> Option<uint>;\n }\n \n impl<T:Eq> ImmutableEqVector<T> for &'self [T] {\n@@ -1874,13 +1871,13 @@ impl<T:Eq> ImmutableEqVector<T> for &'self [T] {\n      * elements then none is returned.\n      */\n     #[inline]\n-    pure fn position(&self, f: &fn(t: &T) -> bool) -> Option<uint> {\n+    fn position(&self, f: &fn(t: &T) -> bool) -> Option<uint> {\n         position(*self, f)\n     }\n \n     /// Find the first index containing a matching value\n     #[inline]\n-    pure fn position_elem(&self, x: &T) -> Option<uint> {\n+    fn position_elem(&self, x: &T) -> Option<uint> {\n         position_elem(*self, x)\n     }\n \n@@ -1892,21 +1889,21 @@ impl<T:Eq> ImmutableEqVector<T> for &'self [T] {\n      * returned. If `f` matches no elements then none is returned.\n      */\n     #[inline]\n-    pure fn rposition(&self, f: &fn(t: &T) -> bool) -> Option<uint> {\n+    fn rposition(&self, f: &fn(t: &T) -> bool) -> Option<uint> {\n         rposition(*self, f)\n     }\n \n     /// Find the last index containing a matching value\n     #[inline]\n-    pure fn rposition_elem(&self, t: &T) -> Option<uint> {\n+    fn rposition_elem(&self, t: &T) -> Option<uint> {\n         rposition_elem(*self, t)\n     }\n }\n \n pub trait ImmutableCopyableVector<T> {\n-    pure fn filtered(&self, f: &fn(&T) -> bool) -> ~[T];\n-    pure fn rfind(&self, f: &fn(t: &T) -> bool) -> Option<T>;\n-    pure fn partitioned(&self, f: &fn(&T) -> bool) -> (~[T], ~[T]);\n+    fn filtered(&self, f: &fn(&T) -> bool) -> ~[T];\n+    fn rfind(&self, f: &fn(t: &T) -> bool) -> Option<T>;\n+    fn partitioned(&self, f: &fn(&T) -> bool) -> (~[T], ~[T]);\n }\n \n /// Extension methods for vectors\n@@ -1919,7 +1916,7 @@ impl<T:Copy> ImmutableCopyableVector<T> for &'self [T] {\n      * containing only those elements for which `f` returned true.\n      */\n     #[inline]\n-    pure fn filtered(&self, f: &fn(t: &T) -> bool) -> ~[T] {\n+    fn filtered(&self, f: &fn(t: &T) -> bool) -> ~[T] {\n         filtered(*self, f)\n     }\n \n@@ -1931,7 +1928,7 @@ impl<T:Copy> ImmutableCopyableVector<T> for &'self [T] {\n      * returned. If `f` matches no elements then none is returned.\n      */\n     #[inline]\n-    pure fn rfind(&self, f: &fn(t: &T) -> bool) -> Option<T> {\n+    fn rfind(&self, f: &fn(t: &T) -> bool) -> Option<T> {\n         rfind(*self, f)\n     }\n \n@@ -1940,7 +1937,7 @@ impl<T:Copy> ImmutableCopyableVector<T> for &'self [T] {\n      * those that do not.\n      */\n     #[inline]\n-    pure fn partitioned(&self, f: &fn(&T) -> bool) -> (~[T], ~[T]) {\n+    fn partitioned(&self, f: &fn(&T) -> bool) -> (~[T], ~[T]) {\n         partitioned(*self, f)\n     }\n }\n@@ -1955,10 +1952,10 @@ pub trait OwnedVector<T> {\n     fn remove(&mut self, i: uint) -> T;\n     fn swap_remove(&mut self, index: uint) -> T;\n     fn truncate(&mut self, newlen: uint);\n-    fn retain(&mut self, f: &pure fn(t: &T) -> bool);\n+    fn retain(&mut self, f: &fn(t: &T) -> bool);\n     fn consume(self, f: &fn(uint, v: T));\n     fn filter(self, f: &fn(t: &T) -> bool) -> ~[T];\n-    fn partition(self, f: &pure fn(&T) -> bool) -> (~[T], ~[T]);\n+    fn partition(self, f: &fn(&T) -> bool) -> (~[T], ~[T]);\n     fn grow_fn(&mut self, n: uint, op: iter::InitOp<T>);\n }\n \n@@ -2009,7 +2006,7 @@ impl<T> OwnedVector<T> for ~[T] {\n     }\n \n     #[inline]\n-    fn retain(&mut self, f: &pure fn(t: &T) -> bool) {\n+    fn retain(&mut self, f: &fn(t: &T) -> bool) {\n         retain(self, f);\n     }\n \n@@ -2258,7 +2255,7 @@ pub mod bytes {\n     use vec;\n \n     /// Bytewise string comparison\n-    pub pure fn memcmp(a: &~[u8], b: &~[u8]) -> int {\n+    pub fn memcmp(a: &~[u8], b: &~[u8]) -> int {\n         let a_len = a.len();\n         let b_len = b.len();\n         let n = uint::min(a_len, b_len) as libc::size_t;\n@@ -2279,22 +2276,22 @@ pub mod bytes {\n     }\n \n     /// Bytewise less than or equal\n-    pub pure fn lt(a: &~[u8], b: &~[u8]) -> bool { memcmp(a, b) < 0 }\n+    pub fn lt(a: &~[u8], b: &~[u8]) -> bool { memcmp(a, b) < 0 }\n \n     /// Bytewise less than or equal\n-    pub pure fn le(a: &~[u8], b: &~[u8]) -> bool { memcmp(a, b) <= 0 }\n+    pub fn le(a: &~[u8], b: &~[u8]) -> bool { memcmp(a, b) <= 0 }\n \n     /// Bytewise equality\n-    pub pure fn eq(a: &~[u8], b: &~[u8]) -> bool { memcmp(a, b) == 0 }\n+    pub fn eq(a: &~[u8], b: &~[u8]) -> bool { memcmp(a, b) == 0 }\n \n     /// Bytewise inequality\n-    pub pure fn ne(a: &~[u8], b: &~[u8]) -> bool { memcmp(a, b) != 0 }\n+    pub fn ne(a: &~[u8], b: &~[u8]) -> bool { memcmp(a, b) != 0 }\n \n     /// Bytewise greater than or equal\n-    pub pure fn ge(a: &~[u8], b: &~[u8]) -> bool { memcmp(a, b) >= 0 }\n+    pub fn ge(a: &~[u8], b: &~[u8]) -> bool { memcmp(a, b) >= 0 }\n \n     /// Bytewise greater than\n-    pub pure fn gt(a: &~[u8], b: &~[u8]) -> bool { memcmp(a, b) > 0 }\n+    pub fn gt(a: &~[u8], b: &~[u8]) -> bool { memcmp(a, b) > 0 }\n \n     /**\n       * Copies data from one vector to another.\n@@ -2314,25 +2311,25 @@ pub mod bytes {\n \n impl<A> iter::BaseIter<A> for &'self [A] {\n     #[inline(always)]\n-    pure fn each(&self, blk: &fn(v: &'self A) -> bool) { each(*self, blk) }\n+    fn each(&self, blk: &fn(v: &'self A) -> bool) { each(*self, blk) }\n     #[inline(always)]\n-    pure fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n+    fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n }\n \n // FIXME(#4148): This should be redundant\n impl<A> iter::BaseIter<A> for ~[A] {\n     #[inline(always)]\n-    pure fn each(&self, blk: &fn(v: &'self A) -> bool) { each(*self, blk) }\n+    fn each(&self, blk: &fn(v: &'self A) -> bool) { each(*self, blk) }\n     #[inline(always)]\n-    pure fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n+    fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n }\n \n // FIXME(#4148): This should be redundant\n impl<A> iter::BaseIter<A> for @[A] {\n     #[inline(always)]\n-    pure fn each(&self, blk: &fn(v: &'self A) -> bool) { each(*self, blk) }\n+    fn each(&self, blk: &fn(v: &'self A) -> bool) { each(*self, blk) }\n     #[inline(always)]\n-    pure fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n+    fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n }\n \n impl<A> iter::MutableIter<A> for &'self mut [A] {\n@@ -2359,150 +2356,150 @@ impl<A> iter::MutableIter<A> for @mut [A] {\n }\n \n impl<A> iter::ExtendedIter<A> for &'self [A] {\n-    pub pure fn eachi(&self, blk: &fn(uint, v: &A) -> bool) {\n+    pub fn eachi(&self, blk: &fn(uint, v: &A) -> bool) {\n         iter::eachi(self, blk)\n     }\n-    pub pure fn all(&self, blk: &fn(&A) -> bool) -> bool {\n+    pub fn all(&self, blk: &fn(&A) -> bool) -> bool {\n         iter::all(self, blk)\n     }\n-    pub pure fn any(&self, blk: &fn(&A) -> bool) -> bool {\n+    pub fn any(&self, blk: &fn(&A) -> bool) -> bool {\n         iter::any(self, blk)\n     }\n-    pub pure fn foldl<B>(&self, b0: B, blk: &fn(&B, &A) -> B) -> B {\n+    pub fn foldl<B>(&self, b0: B, blk: &fn(&B, &A) -> B) -> B {\n         iter::foldl(self, b0, blk)\n     }\n-    pub pure fn position(&self, f: &fn(&A) -> bool) -> Option<uint> {\n+    pub fn position(&self, f: &fn(&A) -> bool) -> Option<uint> {\n         iter::position(self, f)\n     }\n-    pure fn map_to_vec<B>(&self, op: &fn(&A) -> B) -> ~[B] {\n+    fn map_to_vec<B>(&self, op: &fn(&A) -> B) -> ~[B] {\n         iter::map_to_vec(self, op)\n     }\n-    pure fn flat_map_to_vec<B,IB:BaseIter<B>>(&self, op: &fn(&A) -> IB)\n+    fn flat_map_to_vec<B,IB:BaseIter<B>>(&self, op: &fn(&A) -> IB)\n         -> ~[B] {\n         iter::flat_map_to_vec(self, op)\n     }\n }\n \n // FIXME(#4148): This should be redundant\n impl<A> iter::ExtendedIter<A> for ~[A] {\n-    pub pure fn eachi(&self, blk: &fn(uint, v: &A) -> bool) {\n+    pub fn eachi(&self, blk: &fn(uint, v: &A) -> bool) {\n         iter::eachi(self, blk)\n     }\n-    pub pure fn all(&self, blk: &fn(&A) -> bool) -> bool {\n+    pub fn all(&self, blk: &fn(&A) -> bool) -> bool {\n         iter::all(self, blk)\n     }\n-    pub pure fn any(&self, blk: &fn(&A) -> bool) -> bool {\n+    pub fn any(&self, blk: &fn(&A) -> bool) -> bool {\n         iter::any(self, blk)\n     }\n-    pub pure fn foldl<B>(&self, b0: B, blk: &fn(&B, &A) -> B) -> B {\n+    pub fn foldl<B>(&self, b0: B, blk: &fn(&B, &A) -> B) -> B {\n         iter::foldl(self, b0, blk)\n     }\n-    pub pure fn position(&self, f: &fn(&A) -> bool) -> Option<uint> {\n+    pub fn position(&self, f: &fn(&A) -> bool) -> Option<uint> {\n         iter::position(self, f)\n     }\n-    pure fn map_to_vec<B>(&self, op: &fn(&A) -> B) -> ~[B] {\n+    fn map_to_vec<B>(&self, op: &fn(&A) -> B) -> ~[B] {\n         iter::map_to_vec(self, op)\n     }\n-    pure fn flat_map_to_vec<B,IB:BaseIter<B>>(&self, op: &fn(&A) -> IB)\n+    fn flat_map_to_vec<B,IB:BaseIter<B>>(&self, op: &fn(&A) -> IB)\n         -> ~[B] {\n         iter::flat_map_to_vec(self, op)\n     }\n }\n \n // FIXME(#4148): This should be redundant\n impl<A> iter::ExtendedIter<A> for @[A] {\n-    pub pure fn eachi(&self, blk: &fn(uint, v: &A) -> bool) {\n+    pub fn eachi(&self, blk: &fn(uint, v: &A) -> bool) {\n         iter::eachi(self, blk)\n     }\n-    pub pure fn all(&self, blk: &fn(&A) -> bool) -> bool {\n+    pub fn all(&self, blk: &fn(&A) -> bool) -> bool {\n         iter::all(self, blk)\n     }\n-    pub pure fn any(&self, blk: &fn(&A) -> bool) -> bool {\n+    pub fn any(&self, blk: &fn(&A) -> bool) -> bool {\n         iter::any(self, blk)\n     }\n-    pub pure fn foldl<B>(&self, b0: B, blk: &fn(&B, &A) -> B) -> B {\n+    pub fn foldl<B>(&self, b0: B, blk: &fn(&B, &A) -> B) -> B {\n         iter::foldl(self, b0, blk)\n     }\n-    pub pure fn position(&self, f: &fn(&A) -> bool) -> Option<uint> {\n+    pub fn position(&self, f: &fn(&A) -> bool) -> Option<uint> {\n         iter::position(self, f)\n     }\n-    pure fn map_to_vec<B>(&self, op: &fn(&A) -> B) -> ~[B] {\n+    fn map_to_vec<B>(&self, op: &fn(&A) -> B) -> ~[B] {\n         iter::map_to_vec(self, op)\n     }\n-    pure fn flat_map_to_vec<B,IB:BaseIter<B>>(&self, op: &fn(&A) -> IB)\n+    fn flat_map_to_vec<B,IB:BaseIter<B>>(&self, op: &fn(&A) -> IB)\n         -> ~[B] {\n         iter::flat_map_to_vec(self, op)\n     }\n }\n \n impl<A:Eq> iter::EqIter<A> for &'self [A] {\n-    pub pure fn contains(&self, x: &A) -> bool { iter::contains(self, x) }\n-    pub pure fn count(&self, x: &A) -> uint { iter::count(self, x) }\n+    pub fn contains(&self, x: &A) -> bool { iter::contains(self, x) }\n+    pub fn count(&self, x: &A) -> uint { iter::count(self, x) }\n }\n \n // FIXME(#4148): This should be redundant\n impl<A:Eq> iter::EqIter<A> for ~[A] {\n-    pub pure fn contains(&self, x: &A) -> bool { iter::contains(self, x) }\n-    pub pure fn count(&self, x: &A) -> uint { iter::count(self, x) }\n+    pub fn contains(&self, x: &A) -> bool { iter::contains(self, x) }\n+    pub fn count(&self, x: &A) -> uint { iter::count(self, x) }\n }\n \n // FIXME(#4148): This should be redundant\n impl<A:Eq> iter::EqIter<A> for @[A] {\n-    pub pure fn contains(&self, x: &A) -> bool { iter::contains(self, x) }\n-    pub pure fn count(&self, x: &A) -> uint { iter::count(self, x) }\n+    pub fn contains(&self, x: &A) -> bool { iter::contains(self, x) }\n+    pub fn count(&self, x: &A) -> uint { iter::count(self, x) }\n }\n \n impl<A:Copy> iter::CopyableIter<A> for &'self [A] {\n-    pure fn filter_to_vec(&self, pred: &fn(&A) -> bool) -> ~[A] {\n+    fn filter_to_vec(&self, pred: &fn(&A) -> bool) -> ~[A] {\n         iter::filter_to_vec(self, pred)\n     }\n-    pure fn to_vec(&self) -> ~[A] { iter::to_vec(self) }\n-    pub pure fn find(&self, f: &fn(&A) -> bool) -> Option<A> {\n+    fn to_vec(&self) -> ~[A] { iter::to_vec(self) }\n+    pub fn find(&self, f: &fn(&A) -> bool) -> Option<A> {\n         iter::find(self, f)\n     }\n }\n \n // FIXME(#4148): This should be redundant\n impl<A:Copy> iter::CopyableIter<A> for ~[A] {\n-    pure fn filter_to_vec(&self, pred: &fn(&A) -> bool) -> ~[A] {\n+    fn filter_to_vec(&self, pred: &fn(&A) -> bool) -> ~[A] {\n         iter::filter_to_vec(self, pred)\n     }\n-    pure fn to_vec(&self) -> ~[A] { iter::to_vec(self) }\n-    pub pure fn find(&self, f: &fn(&A) -> bool) -> Option<A> {\n+    fn to_vec(&self) -> ~[A] { iter::to_vec(self) }\n+    pub fn find(&self, f: &fn(&A) -> bool) -> Option<A> {\n         iter::find(self, f)\n     }\n }\n \n // FIXME(#4148): This should be redundant\n impl<A:Copy> iter::CopyableIter<A> for @[A] {\n-    pure fn filter_to_vec(&self, pred: &fn(&A) -> bool) -> ~[A] {\n+    fn filter_to_vec(&self, pred: &fn(&A) -> bool) -> ~[A] {\n         iter::filter_to_vec(self, pred)\n     }\n-    pure fn to_vec(&self) -> ~[A] { iter::to_vec(self) }\n-    pub pure fn find(&self, f: &fn(&A) -> bool) -> Option<A> {\n+    fn to_vec(&self) -> ~[A] { iter::to_vec(self) }\n+    pub fn find(&self, f: &fn(&A) -> bool) -> Option<A> {\n         iter::find(self, f)\n     }\n }\n \n impl<A:Copy + Ord> iter::CopyableOrderedIter<A> for &'self [A] {\n-    pure fn min(&self) -> A { iter::min(self) }\n-    pure fn max(&self) -> A { iter::max(self) }\n+    fn min(&self) -> A { iter::min(self) }\n+    fn max(&self) -> A { iter::max(self) }\n }\n \n // FIXME(#4148): This should be redundant\n impl<A:Copy + Ord> iter::CopyableOrderedIter<A> for ~[A] {\n-    pure fn min(&self) -> A { iter::min(self) }\n-    pure fn max(&self) -> A { iter::max(self) }\n+    fn min(&self) -> A { iter::min(self) }\n+    fn max(&self) -> A { iter::max(self) }\n }\n \n // FIXME(#4148): This should be redundant\n impl<A:Copy + Ord> iter::CopyableOrderedIter<A> for @[A] {\n-    pure fn min(&self) -> A { iter::min(self) }\n-    pure fn max(&self) -> A { iter::max(self) }\n+    fn min(&self) -> A { iter::min(self) }\n+    fn max(&self) -> A { iter::max(self) }\n }\n \n impl<A:Copy> iter::CopyableNonstrictIter<A> for &'self [A] {\n-    pure fn each_val(&const self, f: &fn(A) -> bool) {\n+    fn each_val(&const self, f: &fn(A) -> bool) {\n         let mut i = 0;\n         while i < self.len() {\n             if !f(copy self[i]) { break; }\n@@ -2513,7 +2510,7 @@ impl<A:Copy> iter::CopyableNonstrictIter<A> for &'self [A] {\n \n // FIXME(#4148): This should be redundant\n impl<A:Copy> iter::CopyableNonstrictIter<A> for ~[A] {\n-    pure fn each_val(&const self, f: &fn(A) -> bool) {\n+    fn each_val(&const self, f: &fn(A) -> bool) {\n         let mut i = 0;\n         while i < uniq_len(self) {\n             if !f(copy self[i]) { break; }\n@@ -2524,7 +2521,7 @@ impl<A:Copy> iter::CopyableNonstrictIter<A> for ~[A] {\n \n // FIXME(#4148): This should be redundant\n impl<A:Copy> iter::CopyableNonstrictIter<A> for @[A] {\n-    pure fn each_val(&const self, f: &fn(A) -> bool) {\n+    fn each_val(&const self, f: &fn(A) -> bool) {\n         let mut i = 0;\n         while i < self.len() {\n             if !f(copy self[i]) { break; }\n@@ -2559,11 +2556,11 @@ mod tests {\n \n     fn square_ref(n: &uint) -> uint { square(*n) }\n \n-    pure fn is_three(n: &uint) -> bool { *n == 3u }\n+    fn is_three(n: &uint) -> bool { *n == 3u }\n \n-    pure fn is_odd(n: &uint) -> bool { *n % 2u == 1u }\n+    fn is_odd(n: &uint) -> bool { *n % 2u == 1u }\n \n-    pure fn is_equal(x: &uint, y:&uint) -> bool { *x == *y }\n+    fn is_equal(x: &uint, y:&uint) -> bool { *x == *y }\n \n     fn square_if_odd_r(n: &uint) -> Option<uint> {\n         if *n % 2u == 1u { Some(*n * *n) } else { None }"}]}