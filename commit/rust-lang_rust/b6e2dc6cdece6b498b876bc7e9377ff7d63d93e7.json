{"sha": "b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI2ZTJkYzZjZGVjZTZiNDk4Yjg3NmJjN2U5Mzc3ZmY3ZDYzZDkzZTc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-10-16T00:18:13Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-10-16T00:18:13Z"}, "message": "Auto merge of #78001 - Dylan-DPC:rollup-zq3kxth, r=Dylan-DPC\n\nRollup of 14 pull requests\n\nSuccessful merges:\n\n - #75023 (ensure arguments are included in count mismatch span)\n - #75265 (Add `str::{Split,RSplit,SplitN,RSplitN,SplitTerminator,RSplitTerminator,SplitInclusive}::as_str` methods)\n - #75675 (mangling: mangle impl params w/ v0 scheme)\n - #76084 (Refactor io/buffered.rs into submodules)\n - #76119 (Stabilize move_ref_pattern)\n - #77493 (ICEs should always print the top of the query stack)\n - #77619 (Use futex-based thread-parker for Wasm32.)\n - #77646 (For backtrace, use StaticMutex instead of a raw sys Mutex.)\n - #77648 (Static mutex is static)\n - #77657 (Cleanup cloudabi mutexes and condvars)\n - #77672 (Simplify doc-cfg rendering based on the current context)\n - #77780 (rustc_parse: fix spans on cast and range exprs with attrs)\n - #77935 (BTreeMap: make PartialCmp/PartialEq explicit and tested)\n - #77980 (Fix intra doc link for needs_drop)\n\nFailed merges:\n\nr? `@ghost`", "tree": {"sha": "b0cade8eff84561b5f9a195b67829b7af2c866c0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b0cade8eff84561b5f9a195b67829b7af2c866c0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7", "html_url": "https://github.com/rust-lang/rust/commit/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dd7fc54ebdca419ad9d3ab1e9f5ed14e770768ea", "url": "https://api.github.com/repos/rust-lang/rust/commits/dd7fc54ebdca419ad9d3ab1e9f5ed14e770768ea", "html_url": "https://github.com/rust-lang/rust/commit/dd7fc54ebdca419ad9d3ab1e9f5ed14e770768ea"}, {"sha": "e688b4d51cc9b41b18b240f5f6358daa8179e8fa", "url": "https://api.github.com/repos/rust-lang/rust/commits/e688b4d51cc9b41b18b240f5f6358daa8179e8fa", "html_url": "https://github.com/rust-lang/rust/commit/e688b4d51cc9b41b18b240f5f6358daa8179e8fa"}], "stats": {"total": 5193, "additions": 2898, "deletions": 2295}, "files": [{"sha": "d99e335a77a000ca076fca569d4d11fd2ad52486", "filename": "compiler/rustc_driver/src/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/compiler%2Frustc_driver%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/compiler%2Frustc_driver%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver%2Fsrc%2Flib.rs?ref=b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7", "patch": "@@ -1258,9 +1258,9 @@ pub fn report_ice(info: &panic::PanicInfo<'_>, bug_report_url: &str) {\n     // If backtraces are enabled, also print the query stack\n     let backtrace = env::var_os(\"RUST_BACKTRACE\").map(|x| &x != \"0\").unwrap_or(false);\n \n-    if backtrace {\n-        TyCtxt::try_print_query_stack(&handler);\n-    }\n+    let num_frames = if backtrace { None } else { Some(2) };\n+\n+    TyCtxt::try_print_query_stack(&handler, num_frames);\n \n     #[cfg(windows)]\n     unsafe {"}, {"sha": "2c22b86af9246045d7b7710c8860b46d9af2fdf5", "filename": "compiler/rustc_error_codes/src/error_codes/E0007.md", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0007.md", "raw_url": "https://github.com/rust-lang/rust/raw/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0007.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0007.md?ref=b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7", "patch": "@@ -1,3 +1,5 @@\n+#### Note: this error code is no longer emitted by the compiler.\n+\n This error indicates that the bindings in a match arm would require a value to\n be moved into more than one location, thus violating unique ownership. Code\n like the following is invalid as it requires the entire `Option<String>` to be\n@@ -6,11 +8,13 @@ inner `String` to be moved into a variable called `s`.\n \n Erroneous code example:\n \n-```compile_fail,E0007\n+```compile_fail,E0382\n+#![feature(bindings_after_at)]\n+\n let x = Some(\"s\".to_string());\n \n match x {\n-    op_string @ Some(s) => {}, // error: cannot bind by-move with sub-bindings\n+    op_string @ Some(s) => {}, // error: use of moved value\n     None => {},\n }\n ```"}, {"sha": "4401ec0a04ea57028ca516088f7d457dae8d88aa", "filename": "compiler/rustc_feature/src/accepted.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/compiler%2Frustc_feature%2Fsrc%2Faccepted.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/compiler%2Frustc_feature%2Fsrc%2Faccepted.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Faccepted.rs?ref=b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7", "patch": "@@ -270,6 +270,9 @@ declare_features! (\n     (accepted, track_caller, \"1.46.0\", Some(47809), None),\n     /// Allows `#[doc(alias = \"...\")]`.\n     (accepted, doc_alias, \"1.48.0\", Some(50146), None),\n+    /// Allows patterns with concurrent by-move and by-ref bindings.\n+    /// For example, you can write `Foo(a, ref b)` where `a` is by-move and `b` is by-ref.\n+    (accepted, move_ref_pattern, \"1.48.0\", Some(68354), None),\n \n     // -------------------------------------------------------------------------\n     // feature-group-end: accepted features"}, {"sha": "7fbd070a609b7512aabcc1fd6178aa1162ace5f7", "filename": "compiler/rustc_feature/src/active.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/compiler%2Frustc_feature%2Fsrc%2Factive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/compiler%2Frustc_feature%2Fsrc%2Factive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Factive.rs?ref=b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7", "patch": "@@ -526,10 +526,6 @@ declare_features! (\n     /// For example, you can write `x @ Some(y)`.\n     (active, bindings_after_at, \"1.41.0\", Some(65490), None),\n \n-    /// Allows patterns with concurrent by-move and by-ref bindings.\n-    /// For example, you can write `Foo(a, ref b)` where `a` is by-move and `b` is by-ref.\n-    (active, move_ref_pattern, \"1.42.0\", Some(68354), None),\n-\n     /// Allows `impl const Trait for T` syntax.\n     (active, const_trait_impl, \"1.42.0\", Some(67792), None),\n "}, {"sha": "52727e3a619494dadbadcc8ddafd1df5b967a03e", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7", "patch": "@@ -2742,4 +2742,32 @@ impl<'hir> Node<'hir> {\n             _ => None,\n         }\n     }\n+\n+    pub fn hir_id(&self) -> Option<HirId> {\n+        match self {\n+            Node::Item(Item { hir_id, .. })\n+            | Node::ForeignItem(ForeignItem { hir_id, .. })\n+            | Node::TraitItem(TraitItem { hir_id, .. })\n+            | Node::ImplItem(ImplItem { hir_id, .. })\n+            | Node::Field(StructField { hir_id, .. })\n+            | Node::AnonConst(AnonConst { hir_id, .. })\n+            | Node::Expr(Expr { hir_id, .. })\n+            | Node::Stmt(Stmt { hir_id, .. })\n+            | Node::Ty(Ty { hir_id, .. })\n+            | Node::Binding(Pat { hir_id, .. })\n+            | Node::Pat(Pat { hir_id, .. })\n+            | Node::Arm(Arm { hir_id, .. })\n+            | Node::Block(Block { hir_id, .. })\n+            | Node::Local(Local { hir_id, .. })\n+            | Node::MacroDef(MacroDef { hir_id, .. })\n+            | Node::Lifetime(Lifetime { hir_id, .. })\n+            | Node::Param(Param { hir_id, .. })\n+            | Node::GenericParam(GenericParam { hir_id, .. }) => Some(*hir_id),\n+            Node::TraitRef(TraitRef { hir_ref_id, .. }) => Some(*hir_ref_id),\n+            Node::PathSegment(PathSegment { hir_id, .. }) => *hir_id,\n+            Node::Variant(Variant { id, .. }) => Some(*id),\n+            Node::Ctor(variant) => variant.ctor_hir_id(),\n+            Node::Crate(_) | Node::Visibility(_) => None,\n+        }\n+    }\n }"}, {"sha": "4a2c97b4a400f6a2b5f9c5acced34241cdd37476", "filename": "compiler/rustc_middle/src/ty/instance.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/compiler%2Frustc_middle%2Fsrc%2Fty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/compiler%2Frustc_middle%2Fsrc%2Fty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Finstance.rs?ref=b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7", "patch": "@@ -291,7 +291,17 @@ impl<'tcx> Instance<'tcx> {\n     }\n \n     pub fn mono(tcx: TyCtxt<'tcx>, def_id: DefId) -> Instance<'tcx> {\n-        Instance::new(def_id, tcx.empty_substs_for_def_id(def_id))\n+        let substs = InternalSubsts::for_item(tcx, def_id, |param, _| match param.kind {\n+            ty::GenericParamDefKind::Lifetime => tcx.lifetimes.re_erased.into(),\n+            ty::GenericParamDefKind::Type { .. } => {\n+                bug!(\"Instance::mono: {:?} has type parameters\", def_id)\n+            }\n+            ty::GenericParamDefKind::Const { .. } => {\n+                bug!(\"Instance::mono: {:?} has const parameters\", def_id)\n+            }\n+        });\n+\n+        Instance::new(def_id, substs)\n     }\n \n     #[inline]"}, {"sha": "27bf22dac75cb6fd0bcc30f7899c5eb0a9ce476d", "filename": "compiler/rustc_middle/src/ty/query/plumbing.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fplumbing.rs?ref=b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7", "patch": "@@ -124,20 +124,23 @@ impl<'tcx> TyCtxt<'tcx> {\n         })\n     }\n \n-    pub fn try_print_query_stack(handler: &Handler) {\n+    pub fn try_print_query_stack(handler: &Handler, num_frames: Option<usize>) {\n         eprintln!(\"query stack during panic:\");\n \n         // Be careful reyling on global state here: this code is called from\n         // a panic hook, which means that the global `Handler` may be in a weird\n         // state if it was responsible for triggering the panic.\n+        let mut i = 0;\n         ty::tls::with_context_opt(|icx| {\n             if let Some(icx) = icx {\n                 let query_map = icx.tcx.queries.try_collect_active_jobs();\n \n                 let mut current_query = icx.query;\n-                let mut i = 0;\n \n                 while let Some(query) = current_query {\n+                    if Some(i) == num_frames {\n+                        break;\n+                    }\n                     let query_info =\n                         if let Some(info) = query_map.as_ref().and_then(|map| map.get(&query)) {\n                             info\n@@ -163,7 +166,11 @@ impl<'tcx> TyCtxt<'tcx> {\n             }\n         });\n \n-        eprintln!(\"end of query stack\");\n+        if num_frames == None || num_frames >= Some(i) {\n+            eprintln!(\"end of query stack\");\n+        } else {\n+            eprintln!(\"we're just showing a limited slice of the query stack\");\n+        }\n     }\n }\n "}, {"sha": "b0f0f0ba57fad745d638307aabe7b76f338832a7", "filename": "compiler/rustc_middle/src/ty/util.rs", "status": "modified", "additions": 2, "deletions": 16, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs?ref=b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7", "patch": "@@ -6,9 +6,9 @@ use crate::mir::interpret::{sign_extend, truncate};\n use crate::ty::fold::TypeFolder;\n use crate::ty::layout::IntegerExt;\n use crate::ty::query::TyCtxtAt;\n-use crate::ty::subst::{GenericArgKind, InternalSubsts, Subst, SubstsRef};\n+use crate::ty::subst::{GenericArgKind, Subst, SubstsRef};\n use crate::ty::TyKind::*;\n-use crate::ty::{self, DefIdTree, GenericParamDefKind, List, Ty, TyCtxt, TypeFoldable};\n+use crate::ty::{self, DefIdTree, List, Ty, TyCtxt, TypeFoldable};\n use rustc_apfloat::Float as _;\n use rustc_ast as ast;\n use rustc_attr::{self as attr, SignedInt, UnsignedInt};\n@@ -509,20 +509,6 @@ impl<'tcx> TyCtxt<'tcx> {\n         Some(ty::Binder::bind(env_ty))\n     }\n \n-    /// Given the `DefId` of some item that has no type or const parameters, make\n-    /// a suitable \"empty substs\" for it.\n-    pub fn empty_substs_for_def_id(self, item_def_id: DefId) -> SubstsRef<'tcx> {\n-        InternalSubsts::for_item(self, item_def_id, |param, _| match param.kind {\n-            GenericParamDefKind::Lifetime => self.lifetimes.re_erased.into(),\n-            GenericParamDefKind::Type { .. } => {\n-                bug!(\"empty_substs_for_def_id: {:?} has type parameters\", item_def_id)\n-            }\n-            GenericParamDefKind::Const { .. } => {\n-                bug!(\"empty_substs_for_def_id: {:?} has const parameters\", item_def_id)\n-            }\n-        })\n-    }\n-\n     /// Returns `true` if the node pointed to by `def_id` is a `static` item.\n     pub fn is_static(self, def_id: DefId) -> bool {\n         self.static_mutability(def_id).is_some()"}, {"sha": "69de7c7e2ee0bce7acf2f4633665fe3f92cff731", "filename": "compiler/rustc_mir_build/src/thir/pattern/check_match.rs", "status": "modified", "additions": 4, "deletions": 66, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs?ref=b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7", "patch": "@@ -71,13 +71,13 @@ impl<'tcx> Visitor<'tcx> for MatchVisitor<'_, 'tcx> {\n             hir::LocalSource::AwaitDesugar => (\"`await` future binding\", None),\n         };\n         self.check_irrefutable(&loc.pat, msg, sp);\n-        self.check_patterns(false, &loc.pat);\n+        self.check_patterns(&loc.pat);\n     }\n \n     fn visit_param(&mut self, param: &'tcx hir::Param<'tcx>) {\n         intravisit::walk_param(self, param);\n         self.check_irrefutable(&param.pat, \"function argument\", None);\n-        self.check_patterns(false, &param.pat);\n+        self.check_patterns(&param.pat);\n     }\n }\n \n@@ -119,10 +119,7 @@ impl PatCtxt<'_, '_> {\n }\n \n impl<'tcx> MatchVisitor<'_, 'tcx> {\n-    fn check_patterns(&mut self, has_guard: bool, pat: &Pat<'_>) {\n-        if !self.tcx.features().move_ref_pattern {\n-            check_legality_of_move_bindings(self, has_guard, pat);\n-        }\n+    fn check_patterns(&mut self, pat: &Pat<'_>) {\n         pat.walk_always(|pat| check_borrow_conflicts_in_at_patterns(self, pat));\n         if !self.tcx.features().bindings_after_at {\n             check_legality_of_bindings_in_at_patterns(self, pat);\n@@ -165,7 +162,7 @@ impl<'tcx> MatchVisitor<'_, 'tcx> {\n     ) {\n         for arm in arms {\n             // Check the arm for some things unrelated to exhaustiveness.\n-            self.check_patterns(arm.guard.is_some(), &arm.pat);\n+            self.check_patterns(&arm.pat);\n         }\n \n         let mut cx = self.new_cx(scrut.hir_id);\n@@ -601,65 +598,6 @@ fn is_binding_by_move(cx: &MatchVisitor<'_, '_>, hir_id: HirId, span: Span) -> b\n     !cx.typeck_results.node_type(hir_id).is_copy_modulo_regions(cx.tcx.at(span), cx.param_env)\n }\n \n-/// Check the legality of legality of by-move bindings.\n-fn check_legality_of_move_bindings(cx: &mut MatchVisitor<'_, '_>, has_guard: bool, pat: &Pat<'_>) {\n-    let sess = cx.tcx.sess;\n-    let typeck_results = cx.typeck_results;\n-\n-    // Find all by-ref spans.\n-    let mut by_ref_spans = Vec::new();\n-    pat.each_binding(|_, hir_id, span, _| {\n-        if let Some(ty::BindByReference(_)) =\n-            typeck_results.extract_binding_mode(sess, hir_id, span)\n-        {\n-            by_ref_spans.push(span);\n-        }\n-    });\n-\n-    // Find bad by-move spans:\n-    let by_move_spans = &mut Vec::new();\n-    let mut check_move = |p: &Pat<'_>, sub: Option<&Pat<'_>>| {\n-        // Check legality of moving out of the enum.\n-        //\n-        // `x @ Foo(..)` is legal, but `x @ Foo(y)` isn't.\n-        if sub.map_or(false, |p| p.contains_bindings()) {\n-            struct_span_err!(sess, p.span, E0007, \"cannot bind by-move with sub-bindings\")\n-                .span_label(p.span, \"binds an already bound by-move value by moving it\")\n-                .emit();\n-        } else if !has_guard && !by_ref_spans.is_empty() {\n-            by_move_spans.push(p.span);\n-        }\n-    };\n-    pat.walk_always(|p| {\n-        if let hir::PatKind::Binding(.., sub) = &p.kind {\n-            if let Some(ty::BindByValue(_)) =\n-                typeck_results.extract_binding_mode(sess, p.hir_id, p.span)\n-            {\n-                if is_binding_by_move(cx, p.hir_id, p.span) {\n-                    check_move(p, sub.as_deref());\n-                }\n-            }\n-        }\n-    });\n-\n-    // Found some bad by-move spans, error!\n-    if !by_move_spans.is_empty() {\n-        let mut err = feature_err(\n-            &sess.parse_sess,\n-            sym::move_ref_pattern,\n-            by_move_spans.clone(),\n-            \"binding by-move and by-ref in the same pattern is unstable\",\n-        );\n-        for span in by_ref_spans.iter() {\n-            err.span_label(*span, \"by-ref pattern here\");\n-        }\n-        for span in by_move_spans.iter() {\n-            err.span_label(*span, \"by-move pattern here\");\n-        }\n-        err.emit();\n-    }\n-}\n-\n /// Check that there are no borrow or move conflicts in `binding @ subpat` patterns.\n ///\n /// For example, this would reject:"}, {"sha": "17cbaf65420f6e0a1ab440c9a240509d13a7f961", "filename": "compiler/rustc_parse/src/parser/expr.rs", "status": "modified", "additions": 17, "deletions": 7, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs?ref=b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7", "patch": "@@ -246,11 +246,7 @@ impl<'a> Parser<'a> {\n                 this.parse_assoc_expr_with(prec + prec_adjustment, LhsExpr::NotYetParsed)\n             })?;\n \n-            // Make sure that the span of the parent node is larger than the span of lhs and rhs,\n-            // including the attributes.\n-            let lhs_span =\n-                lhs.attrs.iter().find(|a| a.style == AttrStyle::Outer).map_or(lhs_span, |a| a.span);\n-            let span = lhs_span.to(rhs.span);\n+            let span = self.mk_expr_sp(&lhs, lhs_span, rhs.span);\n             lhs = match op {\n                 AssocOp::Add\n                 | AssocOp::Subtract\n@@ -411,7 +407,7 @@ impl<'a> Parser<'a> {\n             None\n         };\n         let rhs_span = rhs.as_ref().map_or(cur_op_span, |x| x.span);\n-        let span = lhs.span.to(rhs_span);\n+        let span = self.mk_expr_sp(&lhs, lhs.span, rhs_span);\n         let limits =\n             if op == AssocOp::DotDot { RangeLimits::HalfOpen } else { RangeLimits::Closed };\n         Ok(self.mk_expr(span, self.mk_range(Some(lhs), rhs, limits)?, AttrVec::new()))\n@@ -571,7 +567,11 @@ impl<'a> Parser<'a> {\n         expr_kind: fn(P<Expr>, P<Ty>) -> ExprKind,\n     ) -> PResult<'a, P<Expr>> {\n         let mk_expr = |this: &mut Self, rhs: P<Ty>| {\n-            this.mk_expr(lhs_span.to(rhs.span), expr_kind(lhs, rhs), AttrVec::new())\n+            this.mk_expr(\n+                this.mk_expr_sp(&lhs, lhs_span, rhs.span),\n+                expr_kind(lhs, rhs),\n+                AttrVec::new(),\n+            )\n         };\n \n         // Save the state of the parser before parsing type normally, in case there is a\n@@ -2324,4 +2324,14 @@ impl<'a> Parser<'a> {\n     pub(super) fn mk_expr_err(&self, span: Span) -> P<Expr> {\n         self.mk_expr(span, ExprKind::Err, AttrVec::new())\n     }\n+\n+    /// Create expression span ensuring the span of the parent node\n+    /// is larger than the span of lhs and rhs, including the attributes.\n+    fn mk_expr_sp(&self, lhs: &P<Expr>, lhs_span: Span, rhs_span: Span) -> Span {\n+        lhs.attrs\n+            .iter()\n+            .find(|a| a.style == AttrStyle::Outer)\n+            .map_or(lhs_span, |a| a.span)\n+            .to(rhs_span)\n+    }\n }"}, {"sha": "48341f71d33eae4ee02a72dc3950f6b192583c08", "filename": "compiler/rustc_parse/src/parser/item.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs?ref=b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7", "patch": "@@ -1744,7 +1744,7 @@ impl<'a> Parser<'a> {\n             }\n         };\n \n-        let span = lo.to(self.token.span);\n+        let span = lo.until(self.token.span);\n \n         Ok(Param {\n             attrs: attrs.into(),"}, {"sha": "2c9caf73b8e425318ff856fbc5aca328f9125a55", "filename": "compiler/rustc_symbol_mangling/src/legacy.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/compiler%2Frustc_symbol_mangling%2Fsrc%2Flegacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/compiler%2Frustc_symbol_mangling%2Fsrc%2Flegacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_symbol_mangling%2Fsrc%2Flegacy.rs?ref=b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7", "patch": "@@ -115,7 +115,6 @@ fn get_symbol_hash<'tcx>(\n         }\n \n         // also include any type parameters (for generic items)\n-        assert!(!substs.has_erasable_regions());\n         substs.hash_stable(&mut hcx, &mut hasher);\n \n         if let Some(instantiating_crate) = instantiating_crate {"}, {"sha": "822a835293474a654ad5c1d0118e9e0fa752b0f1", "filename": "compiler/rustc_symbol_mangling/src/test.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/compiler%2Frustc_symbol_mangling%2Fsrc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/compiler%2Frustc_symbol_mangling%2Fsrc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_symbol_mangling%2Fsrc%2Ftest.rs?ref=b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7", "patch": "@@ -6,7 +6,7 @@\n \n use rustc_hir as hir;\n use rustc_middle::ty::print::with_no_trimmed_paths;\n-use rustc_middle::ty::{Instance, TyCtxt};\n+use rustc_middle::ty::{subst::InternalSubsts, Instance, TyCtxt};\n use rustc_span::symbol::{sym, Symbol};\n \n const SYMBOL_NAME: Symbol = sym::rustc_symbol_name;\n@@ -36,8 +36,11 @@ impl SymbolNamesTest<'tcx> {\n         let def_id = tcx.hir().local_def_id(hir_id);\n         for attr in tcx.get_attrs(def_id.to_def_id()).iter() {\n             if tcx.sess.check_name(attr, SYMBOL_NAME) {\n-                // for now, can only use on monomorphic names\n-                let instance = Instance::mono(tcx, def_id.to_def_id());\n+                let def_id = def_id.to_def_id();\n+                let instance = Instance::new(\n+                    def_id,\n+                    tcx.erase_regions(&InternalSubsts::identity_for_item(tcx, def_id)),\n+                );\n                 let mangled = tcx.symbol_name(instance);\n                 tcx.sess.span_err(attr.span, &format!(\"symbol-name({})\", mangled));\n                 if let Ok(demangling) = rustc_demangle::try_demangle(mangled.name) {"}, {"sha": "16d0b86903ea889e9ad054f07fc179fc02249ed8", "filename": "compiler/rustc_symbol_mangling/src/v0.rs", "status": "modified", "additions": 42, "deletions": 23, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/compiler%2Frustc_symbol_mangling%2Fsrc%2Fv0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/compiler%2Frustc_symbol_mangling%2Fsrc%2Fv0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_symbol_mangling%2Fsrc%2Fv0.rs?ref=b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7", "patch": "@@ -259,7 +259,7 @@ impl Printer<'tcx> for SymbolMangler<'tcx> {\n     }\n \n     fn print_impl_path(\n-        self,\n+        mut self,\n         impl_def_id: DefId,\n         substs: &'tcx [GenericArg<'tcx>],\n         mut self_ty: Ty<'tcx>,\n@@ -284,12 +284,37 @@ impl Printer<'tcx> for SymbolMangler<'tcx> {\n             }\n         }\n \n-        self.path_append_impl(\n-            |cx| cx.print_def_path(parent_def_id, &[]),\n-            &key.disambiguated_data,\n-            self_ty,\n-            impl_trait_ref,\n-        )\n+        self.push(match impl_trait_ref {\n+            Some(_) => \"X\",\n+            None => \"M\",\n+        });\n+\n+        // Encode impl generic params if the substitutions contain parameters (implying\n+        // polymorphization is enabled) and this isn't an inherent impl.\n+        if impl_trait_ref.is_some() && substs.iter().any(|a| a.has_param_types_or_consts()) {\n+            self = self.path_generic_args(\n+                |this| {\n+                    this.path_append_ns(\n+                        |cx| cx.print_def_path(parent_def_id, &[]),\n+                        'I',\n+                        key.disambiguated_data.disambiguator as u64,\n+                        \"\",\n+                    )\n+                },\n+                substs,\n+            )?;\n+        } else {\n+            self.push_disambiguator(key.disambiguated_data.disambiguator as u64);\n+            self = self.print_def_path(parent_def_id, &[])?;\n+        }\n+\n+        self = self_ty.print(self)?;\n+\n+        if let Some(trait_ref) = impl_trait_ref {\n+            self = self.print_def_path(trait_ref.def_id, trait_ref.substs)?;\n+        }\n+\n+        Ok(self)\n     }\n \n     fn print_region(mut self, region: ty::Region<'_>) -> Result<Self::Region, Self::Error> {\n@@ -538,6 +563,7 @@ impl Printer<'tcx> for SymbolMangler<'tcx> {\n         self.push_ident(&name);\n         Ok(self)\n     }\n+\n     fn path_qualified(\n         mut self,\n         self_ty: Ty<'tcx>,\n@@ -552,24 +578,16 @@ impl Printer<'tcx> for SymbolMangler<'tcx> {\n     }\n \n     fn path_append_impl(\n-        mut self,\n-        print_prefix: impl FnOnce(Self) -> Result<Self::Path, Self::Error>,\n-        disambiguated_data: &DisambiguatedDefPathData,\n-        self_ty: Ty<'tcx>,\n-        trait_ref: Option<ty::TraitRef<'tcx>>,\n+        self,\n+        _: impl FnOnce(Self) -> Result<Self::Path, Self::Error>,\n+        _: &DisambiguatedDefPathData,\n+        _: Ty<'tcx>,\n+        _: Option<ty::TraitRef<'tcx>>,\n     ) -> Result<Self::Path, Self::Error> {\n-        self.push(match trait_ref {\n-            Some(_) => \"X\",\n-            None => \"M\",\n-        });\n-        self.push_disambiguator(disambiguated_data.disambiguator as u64);\n-        self = print_prefix(self)?;\n-        self = self_ty.print(self)?;\n-        if let Some(trait_ref) = trait_ref {\n-            self = self.print_def_path(trait_ref.def_id, trait_ref.substs)?;\n-        }\n-        Ok(self)\n+        // Inlined into `print_impl_path`\n+        unreachable!()\n     }\n+\n     fn path_append(\n         self,\n         print_prefix: impl FnOnce(Self) -> Result<Self::Path, Self::Error>,\n@@ -603,6 +621,7 @@ impl Printer<'tcx> for SymbolMangler<'tcx> {\n             name.as_ref().map_or(\"\", |s| &s[..]),\n         )\n     }\n+\n     fn path_generic_args(\n         mut self,\n         print_prefix: impl FnOnce(Self) -> Result<Self::Path, Self::Error>,"}, {"sha": "a38fb9642b92e0c323c46465a1011102dd5d7126", "filename": "compiler/rustc_typeck/src/check/callee.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcallee.rs?ref=b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7", "patch": "@@ -285,10 +285,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         arg_exprs: &'tcx [hir::Expr<'tcx>],\n         expected: Expectation<'tcx>,\n     ) -> Ty<'tcx> {\n-        let (fn_sig, def_span) = match *callee_ty.kind() {\n-            ty::FnDef(def_id, _) => {\n-                (callee_ty.fn_sig(self.tcx), self.tcx.hir().span_if_local(def_id))\n-            }\n+        let (fn_sig, def_id) = match *callee_ty.kind() {\n+            ty::FnDef(def_id, _) => (callee_ty.fn_sig(self.tcx), Some(def_id)),\n             ty::FnPtr(sig) => (sig, None),\n             ref t => {\n                 let mut unit_variant = None;\n@@ -427,7 +425,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             arg_exprs,\n             fn_sig.c_variadic,\n             TupleArgumentsFlag::DontTupleArguments,\n-            def_span,\n+            def_id,\n         );\n \n         fn_sig.output()"}, {"sha": "fd2f5eb5018d45fb8df64a4d14e4fe11b1983767", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/checks.rs", "status": "modified", "additions": 22, "deletions": 5, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs?ref=b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7", "patch": "@@ -19,7 +19,7 @@ use rustc_middle::ty::fold::TypeFoldable;\n use rustc_middle::ty::{self, Ty};\n use rustc_session::Session;\n use rustc_span::symbol::{sym, Ident};\n-use rustc_span::{self, Span};\n+use rustc_span::{self, MultiSpan, Span};\n use rustc_trait_selection::traits::{self, ObligationCauseCode};\n \n use std::mem::replace;\n@@ -83,7 +83,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             args_no_rcvr,\n             method.sig.c_variadic,\n             tuple_arguments,\n-            self.tcx.hir().span_if_local(method.def_id),\n+            Some(method.def_id),\n         );\n         method.sig.output()\n     }\n@@ -99,7 +99,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         args: &'tcx [hir::Expr<'tcx>],\n         c_variadic: bool,\n         tuple_arguments: TupleArgumentsFlag,\n-        def_span: Option<Span>,\n+        def_id: Option<DefId>,\n     ) {\n         let tcx = self.tcx;\n         // Grab the argument types, supplying fresh type variables\n@@ -172,9 +172,26 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 );\n             }\n \n-            if let Some(def_s) = def_span.map(|sp| tcx.sess.source_map().guess_head_span(sp)) {\n-                err.span_label(def_s, \"defined here\");\n+            if let Some(def_id) = def_id {\n+                if let Some(node) = tcx.hir().get_if_local(def_id) {\n+                    let mut spans: MultiSpan = node\n+                        .ident()\n+                        .map(|ident| ident.span)\n+                        .unwrap_or_else(|| tcx.hir().span(node.hir_id().unwrap()))\n+                        .into();\n+\n+                    if let Some(id) = node.body_id() {\n+                        let body = tcx.hir().body(id);\n+                        for param in body.params {\n+                            spans.push_span_label(param.span, String::new());\n+                        }\n+                    }\n+\n+                    let def_kind = tcx.def_kind(def_id);\n+                    err.span_note(spans, &format!(\"{} defined here\", def_kind.descr(def_id)));\n+                }\n             }\n+\n             if sugg_unit {\n                 let sugg_span = tcx.sess.source_map().end_point(expr.span);\n                 // remove closing `)` from the span"}, {"sha": "903faf3fa969adbd5ff3def6f9459e0ff84fb6db", "filename": "library/alloc/src/collections/btree/node.rs", "status": "modified", "additions": 29, "deletions": 7, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs?ref=b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7", "patch": "@@ -257,8 +257,13 @@ impl<K, V> Root<K, V> {\n ///   `NodeRef` points to an internal node, and when this is `LeafOrInternal` the\n ///   `NodeRef` could be pointing to either type of node.\n pub struct NodeRef<BorrowType, K, V, Type> {\n-    /// The number of levels below the node.\n+    /// The number of levels below the node, a property of the node that cannot be\n+    /// entirely described by `Type` and that the node does not store itself either.\n+    /// Unconstrained if `Type` is `LeafOrInternal`, must be zero if `Type` is `Leaf`,\n+    /// and must be non-zero if `Type` is `Internal`.\n     height: usize,\n+    /// The pointer to the leaf or internal node. The definition of `InternalNode`\n+    /// ensures that the pointer is valid either way.\n     node: NonNull<LeafNode<K, V>>,\n     _marker: PhantomData<(BorrowType, Type)>,\n }\n@@ -315,8 +320,8 @@ impl<BorrowType, K, V, Type> NodeRef<BorrowType, K, V, Type> {\n         unsafe { usize::from((*self.as_leaf_ptr()).len) }\n     }\n \n-    /// Returns the height of this node in the whole tree. Zero height denotes the\n-    /// leaf level.\n+    /// Returns the height of this node with respect to the leaf level. Zero height means the\n+    /// node is a leaf itself.\n     pub fn height(&self) -> usize {\n         self.height\n     }\n@@ -584,9 +589,11 @@ impl<'a, K, V, Type> NodeRef<marker::ValMut<'a>, K, V, Type> {\n         // to avoid aliasing with outstanding references to other elements,\n         // in particular, those returned to the caller in earlier iterations.\n         let leaf = self.node.as_ptr();\n+        let keys = unsafe { &raw const (*leaf).keys };\n+        let vals = unsafe { &raw mut (*leaf).vals };\n         // We must coerce to unsized array pointers because of Rust issue #74679.\n-        let keys: *const [_] = unsafe { &raw const (*leaf).keys };\n-        let vals: *mut [_] = unsafe { &raw mut (*leaf).vals };\n+        let keys: *const [_] = keys;\n+        let vals: *mut [_] = vals;\n         // SAFETY: The keys and values of a node must always be initialized up to length.\n         let key = unsafe { (&*keys.get_unchecked(idx)).assume_init_ref() };\n         let val = unsafe { (&mut *vals.get_unchecked_mut(idx)).assume_init_mut() };\n@@ -817,19 +824,34 @@ impl<BorrowType, K, V, NodeType> Handle<NodeRef<BorrowType, K, V, NodeType>, mar\n     }\n }\n \n+impl<BorrowType, K, V, NodeType> NodeRef<BorrowType, K, V, NodeType> {\n+    /// Could be a public implementation of PartialEq, but only used in this module.\n+    fn eq(&self, other: &Self) -> bool {\n+        let Self { node, height, _marker: _ } = self;\n+        if *node == other.node {\n+            debug_assert_eq!(*height, other.height);\n+            true\n+        } else {\n+            false\n+        }\n+    }\n+}\n+\n impl<BorrowType, K, V, NodeType, HandleType> PartialEq\n     for Handle<NodeRef<BorrowType, K, V, NodeType>, HandleType>\n {\n     fn eq(&self, other: &Self) -> bool {\n-        self.node.node == other.node.node && self.idx == other.idx\n+        let Self { node, idx, _marker: _ } = self;\n+        node.eq(&other.node) && *idx == other.idx\n     }\n }\n \n impl<BorrowType, K, V, NodeType, HandleType> PartialOrd\n     for Handle<NodeRef<BorrowType, K, V, NodeType>, HandleType>\n {\n     fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n-        if self.node.node == other.node.node { Some(self.idx.cmp(&other.idx)) } else { None }\n+        let Self { node, idx, _marker: _ } = self;\n+        if node.eq(&other.node) { Some(idx.cmp(&other.idx)) } else { None }\n     }\n }\n "}, {"sha": "2ef9aad0ccdcfbf0bf1563abf51feb6111a643ec", "filename": "library/alloc/src/collections/btree/node/tests.rs", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode%2Ftests.rs?ref=b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7", "patch": "@@ -1,4 +1,5 @@\n use super::*;\n+use core::cmp::Ordering::*;\n \n #[test]\n fn test_splitpoint() {\n@@ -24,6 +25,38 @@ fn test_splitpoint() {\n     }\n }\n \n+#[test]\n+fn test_partial_cmp_eq() {\n+    let mut root1: Root<i32, ()> = Root::new_leaf();\n+    let mut leaf1 = unsafe { root1.leaf_node_as_mut() };\n+    leaf1.push(1, ());\n+    root1.push_internal_level();\n+    let root2: Root<i32, ()> = Root::new_leaf();\n+\n+    let leaf_edge_1a = root1.node_as_ref().first_leaf_edge().forget_node_type();\n+    let leaf_edge_1b = root1.node_as_ref().last_leaf_edge().forget_node_type();\n+    let top_edge_1 = root1.node_as_ref().first_edge();\n+    let top_edge_2 = root2.node_as_ref().first_edge();\n+\n+    assert!(leaf_edge_1a == leaf_edge_1a);\n+    assert!(leaf_edge_1a != leaf_edge_1b);\n+    assert!(leaf_edge_1a != top_edge_1);\n+    assert!(leaf_edge_1a != top_edge_2);\n+    assert!(top_edge_1 == top_edge_1);\n+    assert!(top_edge_1 != top_edge_2);\n+\n+    assert_eq!(leaf_edge_1a.partial_cmp(&leaf_edge_1a), Some(Equal));\n+    assert_eq!(leaf_edge_1a.partial_cmp(&leaf_edge_1b), Some(Less));\n+    assert_eq!(leaf_edge_1a.partial_cmp(&top_edge_1), None);\n+    assert_eq!(leaf_edge_1a.partial_cmp(&top_edge_2), None);\n+    assert_eq!(top_edge_1.partial_cmp(&top_edge_1), Some(Equal));\n+    assert_eq!(top_edge_1.partial_cmp(&top_edge_2), None);\n+\n+    root1.pop_internal_level();\n+    unsafe { root1.into_ref().deallocate_and_ascend() };\n+    unsafe { root2.into_ref().deallocate_and_ascend() };\n+}\n+\n #[test]\n #[cfg(target_arch = \"x86_64\")]\n fn test_sizes() {"}, {"sha": "2a7c105e807f46961f03afb0e420909441930ce3", "filename": "library/core/src/intrinsics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/library%2Fcore%2Fsrc%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/library%2Fcore%2Fsrc%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fintrinsics.rs?ref=b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7", "patch": "@@ -1082,7 +1082,7 @@ extern \"rust-intrinsic\" {\n     /// If the actual type neither requires drop glue nor implements\n     /// `Copy`, then the return value of this function is unspecified.\n     ///\n-    /// The stabilized version of this intrinsic is [`needs_drop`].\n+    /// The stabilized version of this intrinsic is [`mem::needs_drop`](crate::mem::needs_drop).\n     #[rustc_const_stable(feature = \"const_needs_drop\", since = \"1.40.0\")]\n     pub fn needs_drop<T>() -> bool;\n "}, {"sha": "97f27566eb0f4206bafce53a071be19ed6bd5a6e", "filename": "library/core/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/library%2Fcore%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/library%2Fcore%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Flib.rs?ref=b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7", "patch": "@@ -126,6 +126,8 @@\n #![feature(staged_api)]\n #![feature(std_internals)]\n #![feature(stmt_expr_attributes)]\n+#![feature(str_split_as_str)]\n+#![feature(str_split_inclusive_as_str)]\n #![feature(transparent_unions)]\n #![feature(unboxed_closures)]\n #![feature(unsized_locals)]"}, {"sha": "bee86df520c80a04aa8c9c9b5f842dcd30cb5843", "filename": "library/core/src/str/iter.rs", "status": "modified", "additions": 164, "deletions": 0, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/library%2Fcore%2Fsrc%2Fstr%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/library%2Fcore%2Fsrc%2Fstr%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fstr%2Fiter.rs?ref=b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7", "patch": "@@ -690,6 +690,17 @@ impl<'a, P: Pattern<'a>> SplitInternal<'a, P> {\n             },\n         }\n     }\n+\n+    #[inline]\n+    fn as_str(&self) -> &'a str {\n+        // `Self::get_end` doesn't change `self.start`\n+        if self.finished {\n+            return \"\";\n+        }\n+\n+        // SAFETY: `self.start` and `self.end` always lie on unicode boundaries.\n+        unsafe { self.matcher.haystack().get_unchecked(self.start..self.end) }\n+    }\n }\n \n generate_pattern_iterators! {\n@@ -710,6 +721,48 @@ generate_pattern_iterators! {\n     delegate double ended;\n }\n \n+impl<'a, P: Pattern<'a>> Split<'a, P> {\n+    /// Returns remainder of the splitted string\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(str_split_as_str)]\n+    /// let mut split = \"Mary had a little lamb\".split(' ');\n+    /// assert_eq!(split.as_str(), \"Mary had a little lamb\");\n+    /// split.next();\n+    /// assert_eq!(split.as_str(), \"had a little lamb\");\n+    /// split.by_ref().for_each(drop);\n+    /// assert_eq!(split.as_str(), \"\");\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"str_split_as_str\", issue = \"77998\")]\n+    pub fn as_str(&self) -> &'a str {\n+        self.0.as_str()\n+    }\n+}\n+\n+impl<'a, P: Pattern<'a>> RSplit<'a, P> {\n+    /// Returns remainder of the splitted string\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(str_split_as_str)]\n+    /// let mut split = \"Mary had a little lamb\".rsplit(' ');\n+    /// assert_eq!(split.as_str(), \"Mary had a little lamb\");\n+    /// split.next();\n+    /// assert_eq!(split.as_str(), \"Mary had a little\");\n+    /// split.by_ref().for_each(drop);\n+    /// assert_eq!(split.as_str(), \"\");\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"str_split_as_str\", issue = \"77998\")]\n+    pub fn as_str(&self) -> &'a str {\n+        self.0.as_str()\n+    }\n+}\n+\n generate_pattern_iterators! {\n     forward:\n         /// Created with the method [`split_terminator`].\n@@ -728,6 +781,48 @@ generate_pattern_iterators! {\n     delegate double ended;\n }\n \n+impl<'a, P: Pattern<'a>> SplitTerminator<'a, P> {\n+    /// Returns remainder of the splitted string\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(str_split_as_str)]\n+    /// let mut split = \"A..B..\".split_terminator('.');\n+    /// assert_eq!(split.as_str(), \"A..B..\");\n+    /// split.next();\n+    /// assert_eq!(split.as_str(), \".B..\");\n+    /// split.by_ref().for_each(drop);\n+    /// assert_eq!(split.as_str(), \"\");\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"str_split_as_str\", issue = \"77998\")]\n+    pub fn as_str(&self) -> &'a str {\n+        self.0.as_str()\n+    }\n+}\n+\n+impl<'a, P: Pattern<'a>> RSplitTerminator<'a, P> {\n+    /// Returns remainder of the splitted string\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(str_split_as_str)]\n+    /// let mut split = \"A..B..\".rsplit_terminator('.');\n+    /// assert_eq!(split.as_str(), \"A..B..\");\n+    /// split.next();\n+    /// assert_eq!(split.as_str(), \"A..B\");\n+    /// split.by_ref().for_each(drop);\n+    /// assert_eq!(split.as_str(), \"\");\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"str_split_as_str\", issue = \"77998\")]\n+    pub fn as_str(&self) -> &'a str {\n+        self.0.as_str()\n+    }\n+}\n+\n derive_pattern_clone! {\n     clone SplitNInternal\n     with |s| SplitNInternal { iter: s.iter.clone(), ..*s }\n@@ -784,6 +879,11 @@ impl<'a, P: Pattern<'a>> SplitNInternal<'a, P> {\n             }\n         }\n     }\n+\n+    #[inline]\n+    fn as_str(&self) -> &'a str {\n+        self.iter.as_str()\n+    }\n }\n \n generate_pattern_iterators! {\n@@ -804,6 +904,48 @@ generate_pattern_iterators! {\n     delegate single ended;\n }\n \n+impl<'a, P: Pattern<'a>> SplitN<'a, P> {\n+    /// Returns remainder of the splitted string\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(str_split_as_str)]\n+    /// let mut split = \"Mary had a little lamb\".splitn(3, ' ');\n+    /// assert_eq!(split.as_str(), \"Mary had a little lamb\");\n+    /// split.next();\n+    /// assert_eq!(split.as_str(), \"had a little lamb\");\n+    /// split.by_ref().for_each(drop);\n+    /// assert_eq!(split.as_str(), \"\");\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"str_split_as_str\", issue = \"77998\")]\n+    pub fn as_str(&self) -> &'a str {\n+        self.0.as_str()\n+    }\n+}\n+\n+impl<'a, P: Pattern<'a>> RSplitN<'a, P> {\n+    /// Returns remainder of the splitted string\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(str_split_as_str)]\n+    /// let mut split = \"Mary had a little lamb\".rsplitn(3, ' ');\n+    /// assert_eq!(split.as_str(), \"Mary had a little lamb\");\n+    /// split.next();\n+    /// assert_eq!(split.as_str(), \"Mary had a little\");\n+    /// split.by_ref().for_each(drop);\n+    /// assert_eq!(split.as_str(), \"\");\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"str_split_as_str\", issue = \"77998\")]\n+    pub fn as_str(&self) -> &'a str {\n+        self.0.as_str()\n+    }\n+}\n+\n derive_pattern_clone! {\n     clone MatchIndicesInternal\n     with |s| MatchIndicesInternal(s.0.clone())\n@@ -1134,6 +1276,28 @@ impl<'a, P: Pattern<'a, Searcher: ReverseSearcher<'a>>> DoubleEndedIterator\n #[unstable(feature = \"split_inclusive\", issue = \"72360\")]\n impl<'a, P: Pattern<'a>> FusedIterator for SplitInclusive<'a, P> {}\n \n+impl<'a, P: Pattern<'a>> SplitInclusive<'a, P> {\n+    /// Returns remainder of the splitted string\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(str_split_inclusive_as_str)]\n+    /// #![feature(split_inclusive)]\n+    /// let mut split = \"Mary had a little lamb\".split_inclusive(' ');\n+    /// assert_eq!(split.as_str(), \"Mary had a little lamb\");\n+    /// split.next();\n+    /// assert_eq!(split.as_str(), \"had a little lamb\");\n+    /// split.by_ref().for_each(drop);\n+    /// assert_eq!(split.as_str(), \"\");\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"str_split_inclusive_as_str\", issue = \"77998\")]\n+    pub fn as_str(&self) -> &'a str {\n+        self.0.as_str()\n+    }\n+}\n+\n /// An iterator of [`u16`] over the string encoded as UTF-16.\n ///\n /// This struct is created by the [`encode_utf16`] method on [`str`]."}, {"sha": "a9d8a4e2a81c1e03173b671bb99857f5a3e7da89", "filename": "library/std/src/backtrace.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/library%2Fstd%2Fsrc%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/library%2Fstd%2Fsrc%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fbacktrace.rs?ref=b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7", "patch": "@@ -303,7 +303,8 @@ impl Backtrace {\n     // Capture a backtrace which start just before the function addressed by\n     // `ip`\n     fn create(ip: usize) -> Backtrace {\n-        let _lock = lock();\n+        // SAFETY: We don't attempt to lock this reentrantly.\n+        let _lock = unsafe { lock() };\n         let mut frames = Vec::new();\n         let mut actual_start = None;\n         unsafe {\n@@ -408,7 +409,8 @@ impl Capture {\n         // Use the global backtrace lock to synchronize this as it's a\n         // requirement of the `backtrace` crate, and then actually resolve\n         // everything.\n-        let _lock = lock();\n+        // SAFETY: We don't attempt to lock this reentrantly.\n+        let _lock = unsafe { lock() };\n         for frame in self.frames.iter_mut() {\n             let symbols = &mut frame.symbols;\n             let frame = match &frame.frame {"}, {"sha": "97c4b879793b71cd4f7ac958788586bf253f7930", "filename": "library/std/src/io/buffered.rs", "status": "removed", "additions": 0, "deletions": 1438, "changes": 1438, "blob_url": "https://github.com/rust-lang/rust/blob/dd7fc54ebdca419ad9d3ab1e9f5ed14e770768ea/library%2Fstd%2Fsrc%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd7fc54ebdca419ad9d3ab1e9f5ed14e770768ea/library%2Fstd%2Fsrc%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fbuffered.rs?ref=dd7fc54ebdca419ad9d3ab1e9f5ed14e770768ea", "patch": "@@ -1,1438 +0,0 @@\n-//! Buffering wrappers for I/O traits\n-\n-#[cfg(test)]\n-mod tests;\n-\n-use crate::io::prelude::*;\n-\n-use crate::cmp;\n-use crate::error;\n-use crate::fmt;\n-use crate::io::{\n-    self, Error, ErrorKind, Initializer, IoSlice, IoSliceMut, SeekFrom, DEFAULT_BUF_SIZE,\n-};\n-use crate::memchr;\n-\n-/// The `BufReader<R>` struct adds buffering to any reader.\n-///\n-/// It can be excessively inefficient to work directly with a [`Read`] instance.\n-/// For example, every call to [`read`][`TcpStream::read`] on [`TcpStream`]\n-/// results in a system call. A `BufReader<R>` performs large, infrequent reads on\n-/// the underlying [`Read`] and maintains an in-memory buffer of the results.\n-///\n-/// `BufReader<R>` can improve the speed of programs that make *small* and\n-/// *repeated* read calls to the same file or network socket. It does not\n-/// help when reading very large amounts at once, or reading just one or a few\n-/// times. It also provides no advantage when reading from a source that is\n-/// already in memory, like a [`Vec`]`<u8>`.\n-///\n-/// When the `BufReader<R>` is dropped, the contents of its buffer will be\n-/// discarded. Creating multiple instances of a `BufReader<R>` on the same\n-/// stream can cause data loss. Reading from the underlying reader after\n-/// unwrapping the `BufReader<R>` with [`BufReader::into_inner`] can also cause\n-/// data loss.\n-///\n-/// [`TcpStream::read`]: Read::read\n-/// [`TcpStream`]: crate::net::TcpStream\n-///\n-/// # Examples\n-///\n-/// ```no_run\n-/// use std::io::prelude::*;\n-/// use std::io::BufReader;\n-/// use std::fs::File;\n-///\n-/// fn main() -> std::io::Result<()> {\n-///     let f = File::open(\"log.txt\")?;\n-///     let mut reader = BufReader::new(f);\n-///\n-///     let mut line = String::new();\n-///     let len = reader.read_line(&mut line)?;\n-///     println!(\"First line is {} bytes long\", len);\n-///     Ok(())\n-/// }\n-/// ```\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct BufReader<R> {\n-    inner: R,\n-    buf: Box<[u8]>,\n-    pos: usize,\n-    cap: usize,\n-}\n-\n-impl<R: Read> BufReader<R> {\n-    /// Creates a new `BufReader<R>` with a default buffer capacity. The default is currently 8 KB,\n-    /// but may change in the future.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::io::BufReader;\n-    /// use std::fs::File;\n-    ///\n-    /// fn main() -> std::io::Result<()> {\n-    ///     let f = File::open(\"log.txt\")?;\n-    ///     let reader = BufReader::new(f);\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn new(inner: R) -> BufReader<R> {\n-        BufReader::with_capacity(DEFAULT_BUF_SIZE, inner)\n-    }\n-\n-    /// Creates a new `BufReader<R>` with the specified buffer capacity.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Creating a buffer with ten bytes of capacity:\n-    ///\n-    /// ```no_run\n-    /// use std::io::BufReader;\n-    /// use std::fs::File;\n-    ///\n-    /// fn main() -> std::io::Result<()> {\n-    ///     let f = File::open(\"log.txt\")?;\n-    ///     let reader = BufReader::with_capacity(10, f);\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn with_capacity(capacity: usize, inner: R) -> BufReader<R> {\n-        unsafe {\n-            let mut buffer = Vec::with_capacity(capacity);\n-            buffer.set_len(capacity);\n-            inner.initializer().initialize(&mut buffer);\n-            BufReader { inner, buf: buffer.into_boxed_slice(), pos: 0, cap: 0 }\n-        }\n-    }\n-}\n-\n-impl<R> BufReader<R> {\n-    /// Gets a reference to the underlying reader.\n-    ///\n-    /// It is inadvisable to directly read from the underlying reader.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::io::BufReader;\n-    /// use std::fs::File;\n-    ///\n-    /// fn main() -> std::io::Result<()> {\n-    ///     let f1 = File::open(\"log.txt\")?;\n-    ///     let reader = BufReader::new(f1);\n-    ///\n-    ///     let f2 = reader.get_ref();\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn get_ref(&self) -> &R {\n-        &self.inner\n-    }\n-\n-    /// Gets a mutable reference to the underlying reader.\n-    ///\n-    /// It is inadvisable to directly read from the underlying reader.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::io::BufReader;\n-    /// use std::fs::File;\n-    ///\n-    /// fn main() -> std::io::Result<()> {\n-    ///     let f1 = File::open(\"log.txt\")?;\n-    ///     let mut reader = BufReader::new(f1);\n-    ///\n-    ///     let f2 = reader.get_mut();\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn get_mut(&mut self) -> &mut R {\n-        &mut self.inner\n-    }\n-\n-    /// Returns a reference to the internally buffered data.\n-    ///\n-    /// Unlike [`fill_buf`], this will not attempt to fill the buffer if it is empty.\n-    ///\n-    /// [`fill_buf`]: BufRead::fill_buf\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::io::{BufReader, BufRead};\n-    /// use std::fs::File;\n-    ///\n-    /// fn main() -> std::io::Result<()> {\n-    ///     let f = File::open(\"log.txt\")?;\n-    ///     let mut reader = BufReader::new(f);\n-    ///     assert!(reader.buffer().is_empty());\n-    ///\n-    ///     if reader.fill_buf()?.len() > 0 {\n-    ///         assert!(!reader.buffer().is_empty());\n-    ///     }\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"bufreader_buffer\", since = \"1.37.0\")]\n-    pub fn buffer(&self) -> &[u8] {\n-        &self.buf[self.pos..self.cap]\n-    }\n-\n-    /// Returns the number of bytes the internal buffer can hold at once.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::io::{BufReader, BufRead};\n-    /// use std::fs::File;\n-    ///\n-    /// fn main() -> std::io::Result<()> {\n-    ///     let f = File::open(\"log.txt\")?;\n-    ///     let mut reader = BufReader::new(f);\n-    ///\n-    ///     let capacity = reader.capacity();\n-    ///     let buffer = reader.fill_buf()?;\n-    ///     assert!(buffer.len() <= capacity);\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"buffered_io_capacity\", since = \"1.46.0\")]\n-    pub fn capacity(&self) -> usize {\n-        self.buf.len()\n-    }\n-\n-    /// Unwraps this `BufReader<R>`, returning the underlying reader.\n-    ///\n-    /// Note that any leftover data in the internal buffer is lost. Therefore,\n-    /// a following read from the underlying reader may lead to data loss.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::io::BufReader;\n-    /// use std::fs::File;\n-    ///\n-    /// fn main() -> std::io::Result<()> {\n-    ///     let f1 = File::open(\"log.txt\")?;\n-    ///     let reader = BufReader::new(f1);\n-    ///\n-    ///     let f2 = reader.into_inner();\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn into_inner(self) -> R {\n-        self.inner\n-    }\n-\n-    /// Invalidates all data in the internal buffer.\n-    #[inline]\n-    fn discard_buffer(&mut self) {\n-        self.pos = 0;\n-        self.cap = 0;\n-    }\n-}\n-\n-impl<R: Seek> BufReader<R> {\n-    /// Seeks relative to the current position. If the new position lies within the buffer,\n-    /// the buffer will not be flushed, allowing for more efficient seeks.\n-    /// This method does not return the location of the underlying reader, so the caller\n-    /// must track this information themselves if it is required.\n-    #[unstable(feature = \"bufreader_seek_relative\", issue = \"31100\")]\n-    pub fn seek_relative(&mut self, offset: i64) -> io::Result<()> {\n-        let pos = self.pos as u64;\n-        if offset < 0 {\n-            if let Some(new_pos) = pos.checked_sub((-offset) as u64) {\n-                self.pos = new_pos as usize;\n-                return Ok(());\n-            }\n-        } else {\n-            if let Some(new_pos) = pos.checked_add(offset as u64) {\n-                if new_pos <= self.cap as u64 {\n-                    self.pos = new_pos as usize;\n-                    return Ok(());\n-                }\n-            }\n-        }\n-        self.seek(SeekFrom::Current(offset)).map(drop)\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<R: Read> Read for BufReader<R> {\n-    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n-        // If we don't have any buffered data and we're doing a massive read\n-        // (larger than our internal buffer), bypass our internal buffer\n-        // entirely.\n-        if self.pos == self.cap && buf.len() >= self.buf.len() {\n-            self.discard_buffer();\n-            return self.inner.read(buf);\n-        }\n-        let nread = {\n-            let mut rem = self.fill_buf()?;\n-            rem.read(buf)?\n-        };\n-        self.consume(nread);\n-        Ok(nread)\n-    }\n-\n-    fn read_vectored(&mut self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n-        let total_len = bufs.iter().map(|b| b.len()).sum::<usize>();\n-        if self.pos == self.cap && total_len >= self.buf.len() {\n-            self.discard_buffer();\n-            return self.inner.read_vectored(bufs);\n-        }\n-        let nread = {\n-            let mut rem = self.fill_buf()?;\n-            rem.read_vectored(bufs)?\n-        };\n-        self.consume(nread);\n-        Ok(nread)\n-    }\n-\n-    fn is_read_vectored(&self) -> bool {\n-        self.inner.is_read_vectored()\n-    }\n-\n-    // we can't skip unconditionally because of the large buffer case in read.\n-    unsafe fn initializer(&self) -> Initializer {\n-        self.inner.initializer()\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<R: Read> BufRead for BufReader<R> {\n-    fn fill_buf(&mut self) -> io::Result<&[u8]> {\n-        // If we've reached the end of our internal buffer then we need to fetch\n-        // some more data from the underlying reader.\n-        // Branch using `>=` instead of the more correct `==`\n-        // to tell the compiler that the pos..cap slice is always valid.\n-        if self.pos >= self.cap {\n-            debug_assert!(self.pos == self.cap);\n-            self.cap = self.inner.read(&mut self.buf)?;\n-            self.pos = 0;\n-        }\n-        Ok(&self.buf[self.pos..self.cap])\n-    }\n-\n-    fn consume(&mut self, amt: usize) {\n-        self.pos = cmp::min(self.pos + amt, self.cap);\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<R> fmt::Debug for BufReader<R>\n-where\n-    R: fmt::Debug,\n-{\n-    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        fmt.debug_struct(\"BufReader\")\n-            .field(\"reader\", &self.inner)\n-            .field(\"buffer\", &format_args!(\"{}/{}\", self.cap - self.pos, self.buf.len()))\n-            .finish()\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<R: Seek> Seek for BufReader<R> {\n-    /// Seek to an offset, in bytes, in the underlying reader.\n-    ///\n-    /// The position used for seeking with [`SeekFrom::Current`]`(_)` is the\n-    /// position the underlying reader would be at if the `BufReader<R>` had no\n-    /// internal buffer.\n-    ///\n-    /// Seeking always discards the internal buffer, even if the seek position\n-    /// would otherwise fall within it. This guarantees that calling\n-    /// [`BufReader::into_inner()`] immediately after a seek yields the underlying reader\n-    /// at the same position.\n-    ///\n-    /// To seek without discarding the internal buffer, use [`BufReader::seek_relative`].\n-    ///\n-    /// See [`std::io::Seek`] for more details.\n-    ///\n-    /// Note: In the edge case where you're seeking with [`SeekFrom::Current`]`(n)`\n-    /// where `n` minus the internal buffer length overflows an `i64`, two\n-    /// seeks will be performed instead of one. If the second seek returns\n-    /// [`Err`], the underlying reader will be left at the same position it would\n-    /// have if you called `seek` with [`SeekFrom::Current`]`(0)`.\n-    ///\n-    /// [`std::io::Seek`]: Seek\n-    fn seek(&mut self, pos: SeekFrom) -> io::Result<u64> {\n-        let result: u64;\n-        if let SeekFrom::Current(n) = pos {\n-            let remainder = (self.cap - self.pos) as i64;\n-            // it should be safe to assume that remainder fits within an i64 as the alternative\n-            // means we managed to allocate 8 exbibytes and that's absurd.\n-            // But it's not out of the realm of possibility for some weird underlying reader to\n-            // support seeking by i64::MIN so we need to handle underflow when subtracting\n-            // remainder.\n-            if let Some(offset) = n.checked_sub(remainder) {\n-                result = self.inner.seek(SeekFrom::Current(offset))?;\n-            } else {\n-                // seek backwards by our remainder, and then by the offset\n-                self.inner.seek(SeekFrom::Current(-remainder))?;\n-                self.discard_buffer();\n-                result = self.inner.seek(SeekFrom::Current(n))?;\n-            }\n-        } else {\n-            // Seeking with Start/End doesn't care about our buffer length.\n-            result = self.inner.seek(pos)?;\n-        }\n-        self.discard_buffer();\n-        Ok(result)\n-    }\n-\n-    /// Returns the current seek position from the start of the stream.\n-    ///\n-    /// The value returned is equivalent to `self.seek(SeekFrom::Current(0))`\n-    /// but does not flush the internal buffer. Due to this optimization the\n-    /// function does not guarantee that calling `.into_inner()` immediately\n-    /// afterwards will yield the underlying reader at the same position. Use\n-    /// [`BufReader::seek`] instead if you require that guarantee.\n-    ///\n-    /// # Panics\n-    ///\n-    /// This function will panic if the position of the inner reader is smaller\n-    /// than the amount of buffered data. That can happen if the inner reader\n-    /// has an incorrect implementation of [`Seek::stream_position`], or if the\n-    /// position has gone out of sync due to calling [`Seek::seek`] directly on\n-    /// the underlying reader.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```no_run\n-    /// #![feature(seek_convenience)]\n-    /// use std::{\n-    ///     io::{self, BufRead, BufReader, Seek},\n-    ///     fs::File,\n-    /// };\n-    ///\n-    /// fn main() -> io::Result<()> {\n-    ///     let mut f = BufReader::new(File::open(\"foo.txt\")?);\n-    ///\n-    ///     let before = f.stream_position()?;\n-    ///     f.read_line(&mut String::new())?;\n-    ///     let after = f.stream_position()?;\n-    ///\n-    ///     println!(\"The first line was {} bytes long\", after - before);\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    fn stream_position(&mut self) -> io::Result<u64> {\n-        let remainder = (self.cap - self.pos) as u64;\n-        self.inner.stream_position().map(|pos| {\n-            pos.checked_sub(remainder).expect(\n-                \"overflow when subtracting remaining buffer size from inner stream position\",\n-            )\n-        })\n-    }\n-}\n-\n-/// Wraps a writer and buffers its output.\n-///\n-/// It can be excessively inefficient to work directly with something that\n-/// implements [`Write`]. For example, every call to\n-/// [`write`][`TcpStream::write`] on [`TcpStream`] results in a system call. A\n-/// `BufWriter<W>` keeps an in-memory buffer of data and writes it to an underlying\n-/// writer in large, infrequent batches.\n-///\n-/// `BufWriter<W>` can improve the speed of programs that make *small* and\n-/// *repeated* write calls to the same file or network socket. It does not\n-/// help when writing very large amounts at once, or writing just one or a few\n-/// times. It also provides no advantage when writing to a destination that is\n-/// in memory, like a [`Vec`]<u8>`.\n-///\n-/// It is critical to call [`flush`] before `BufWriter<W>` is dropped. Though\n-/// dropping will attempt to flush the contents of the buffer, any errors\n-/// that happen in the process of dropping will be ignored. Calling [`flush`]\n-/// ensures that the buffer is empty and thus dropping will not even attempt\n-/// file operations.\n-///\n-/// # Examples\n-///\n-/// Let's write the numbers one through ten to a [`TcpStream`]:\n-///\n-/// ```no_run\n-/// use std::io::prelude::*;\n-/// use std::net::TcpStream;\n-///\n-/// let mut stream = TcpStream::connect(\"127.0.0.1:34254\").unwrap();\n-///\n-/// for i in 0..10 {\n-///     stream.write(&[i+1]).unwrap();\n-/// }\n-/// ```\n-///\n-/// Because we're not buffering, we write each one in turn, incurring the\n-/// overhead of a system call per byte written. We can fix this with a\n-/// `BufWriter<W>`:\n-///\n-/// ```no_run\n-/// use std::io::prelude::*;\n-/// use std::io::BufWriter;\n-/// use std::net::TcpStream;\n-///\n-/// let mut stream = BufWriter::new(TcpStream::connect(\"127.0.0.1:34254\").unwrap());\n-///\n-/// for i in 0..10 {\n-///     stream.write(&[i+1]).unwrap();\n-/// }\n-/// stream.flush().unwrap();\n-/// ```\n-///\n-/// By wrapping the stream with a `BufWriter<W>`, these ten writes are all grouped\n-/// together by the buffer and will all be written out in one system call when\n-/// the `stream` is flushed.\n-///\n-/// [`TcpStream::write`]: Write::write\n-/// [`TcpStream`]: crate::net::TcpStream\n-/// [`flush`]: Write::flush\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct BufWriter<W: Write> {\n-    inner: Option<W>,\n-    buf: Vec<u8>,\n-    // #30888: If the inner writer panics in a call to write, we don't want to\n-    // write the buffered data a second time in BufWriter's destructor. This\n-    // flag tells the Drop impl if it should skip the flush.\n-    panicked: bool,\n-}\n-\n-/// An error returned by [`BufWriter::into_inner`] which combines an error that\n-/// happened while writing out the buffer, and the buffered writer object\n-/// which may be used to recover from the condition.\n-///\n-/// # Examples\n-///\n-/// ```no_run\n-/// use std::io::BufWriter;\n-/// use std::net::TcpStream;\n-///\n-/// let mut stream = BufWriter::new(TcpStream::connect(\"127.0.0.1:34254\").unwrap());\n-///\n-/// // do stuff with the stream\n-///\n-/// // we want to get our `TcpStream` back, so let's try:\n-///\n-/// let stream = match stream.into_inner() {\n-///     Ok(s) => s,\n-///     Err(e) => {\n-///         // Here, e is an IntoInnerError\n-///         panic!(\"An error occurred\");\n-///     }\n-/// };\n-/// ```\n-#[derive(Debug)]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct IntoInnerError<W>(W, Error);\n-\n-impl<W: Write> BufWriter<W> {\n-    /// Creates a new `BufWriter<W>` with a default buffer capacity. The default is currently 8 KB,\n-    /// but may change in the future.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::io::BufWriter;\n-    /// use std::net::TcpStream;\n-    ///\n-    /// let mut buffer = BufWriter::new(TcpStream::connect(\"127.0.0.1:34254\").unwrap());\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn new(inner: W) -> BufWriter<W> {\n-        BufWriter::with_capacity(DEFAULT_BUF_SIZE, inner)\n-    }\n-\n-    /// Creates a new `BufWriter<W>` with the specified buffer capacity.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Creating a buffer with a buffer of a hundred bytes.\n-    ///\n-    /// ```no_run\n-    /// use std::io::BufWriter;\n-    /// use std::net::TcpStream;\n-    ///\n-    /// let stream = TcpStream::connect(\"127.0.0.1:34254\").unwrap();\n-    /// let mut buffer = BufWriter::with_capacity(100, stream);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn with_capacity(capacity: usize, inner: W) -> BufWriter<W> {\n-        BufWriter { inner: Some(inner), buf: Vec::with_capacity(capacity), panicked: false }\n-    }\n-\n-    /// Send data in our local buffer into the inner writer, looping as\n-    /// necessary until either it's all been sent or an error occurs.\n-    ///\n-    /// Because all the data in the buffer has been reported to our owner as\n-    /// \"successfully written\" (by returning nonzero success values from\n-    /// `write`), any 0-length writes from `inner` must be reported as i/o\n-    /// errors from this method.\n-    fn flush_buf(&mut self) -> io::Result<()> {\n-        /// Helper struct to ensure the buffer is updated after all the writes\n-        /// are complete. It tracks the number of written bytes and drains them\n-        /// all from the front of the buffer when dropped.\n-        struct BufGuard<'a> {\n-            buffer: &'a mut Vec<u8>,\n-            written: usize,\n-        }\n-\n-        impl<'a> BufGuard<'a> {\n-            fn new(buffer: &'a mut Vec<u8>) -> Self {\n-                Self { buffer, written: 0 }\n-            }\n-\n-            /// The unwritten part of the buffer\n-            fn remaining(&self) -> &[u8] {\n-                &self.buffer[self.written..]\n-            }\n-\n-            /// Flag some bytes as removed from the front of the buffer\n-            fn consume(&mut self, amt: usize) {\n-                self.written += amt;\n-            }\n-\n-            /// true if all of the bytes have been written\n-            fn done(&self) -> bool {\n-                self.written >= self.buffer.len()\n-            }\n-        }\n-\n-        impl Drop for BufGuard<'_> {\n-            fn drop(&mut self) {\n-                if self.written > 0 {\n-                    self.buffer.drain(..self.written);\n-                }\n-            }\n-        }\n-\n-        let mut guard = BufGuard::new(&mut self.buf);\n-        let inner = self.inner.as_mut().unwrap();\n-        while !guard.done() {\n-            self.panicked = true;\n-            let r = inner.write(guard.remaining());\n-            self.panicked = false;\n-\n-            match r {\n-                Ok(0) => {\n-                    return Err(Error::new(\n-                        ErrorKind::WriteZero,\n-                        \"failed to write the buffered data\",\n-                    ));\n-                }\n-                Ok(n) => guard.consume(n),\n-                Err(ref e) if e.kind() == io::ErrorKind::Interrupted => {}\n-                Err(e) => return Err(e),\n-            }\n-        }\n-        Ok(())\n-    }\n-\n-    /// Buffer some data without flushing it, regardless of the size of the\n-    /// data. Writes as much as possible without exceeding capacity. Returns\n-    /// the number of bytes written.\n-    fn write_to_buf(&mut self, buf: &[u8]) -> usize {\n-        let available = self.buf.capacity() - self.buf.len();\n-        let amt_to_buffer = available.min(buf.len());\n-        self.buf.extend_from_slice(&buf[..amt_to_buffer]);\n-        amt_to_buffer\n-    }\n-\n-    /// Gets a reference to the underlying writer.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::io::BufWriter;\n-    /// use std::net::TcpStream;\n-    ///\n-    /// let mut buffer = BufWriter::new(TcpStream::connect(\"127.0.0.1:34254\").unwrap());\n-    ///\n-    /// // we can use reference just like buffer\n-    /// let reference = buffer.get_ref();\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn get_ref(&self) -> &W {\n-        self.inner.as_ref().unwrap()\n-    }\n-\n-    /// Gets a mutable reference to the underlying writer.\n-    ///\n-    /// It is inadvisable to directly write to the underlying writer.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::io::BufWriter;\n-    /// use std::net::TcpStream;\n-    ///\n-    /// let mut buffer = BufWriter::new(TcpStream::connect(\"127.0.0.1:34254\").unwrap());\n-    ///\n-    /// // we can use reference just like buffer\n-    /// let reference = buffer.get_mut();\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn get_mut(&mut self) -> &mut W {\n-        self.inner.as_mut().unwrap()\n-    }\n-\n-    /// Returns a reference to the internally buffered data.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::io::BufWriter;\n-    /// use std::net::TcpStream;\n-    ///\n-    /// let buf_writer = BufWriter::new(TcpStream::connect(\"127.0.0.1:34254\").unwrap());\n-    ///\n-    /// // See how many bytes are currently buffered\n-    /// let bytes_buffered = buf_writer.buffer().len();\n-    /// ```\n-    #[stable(feature = \"bufreader_buffer\", since = \"1.37.0\")]\n-    pub fn buffer(&self) -> &[u8] {\n-        &self.buf\n-    }\n-\n-    /// Returns the number of bytes the internal buffer can hold without flushing.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::io::BufWriter;\n-    /// use std::net::TcpStream;\n-    ///\n-    /// let buf_writer = BufWriter::new(TcpStream::connect(\"127.0.0.1:34254\").unwrap());\n-    ///\n-    /// // Check the capacity of the inner buffer\n-    /// let capacity = buf_writer.capacity();\n-    /// // Calculate how many bytes can be written without flushing\n-    /// let without_flush = capacity - buf_writer.buffer().len();\n-    /// ```\n-    #[stable(feature = \"buffered_io_capacity\", since = \"1.46.0\")]\n-    pub fn capacity(&self) -> usize {\n-        self.buf.capacity()\n-    }\n-\n-    /// Unwraps this `BufWriter<W>`, returning the underlying writer.\n-    ///\n-    /// The buffer is written out before returning the writer.\n-    ///\n-    /// # Errors\n-    ///\n-    /// An [`Err`] will be returned if an error occurs while flushing the buffer.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::io::BufWriter;\n-    /// use std::net::TcpStream;\n-    ///\n-    /// let mut buffer = BufWriter::new(TcpStream::connect(\"127.0.0.1:34254\").unwrap());\n-    ///\n-    /// // unwrap the TcpStream and flush the buffer\n-    /// let stream = buffer.into_inner().unwrap();\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn into_inner(mut self) -> Result<W, IntoInnerError<BufWriter<W>>> {\n-        match self.flush_buf() {\n-            Err(e) => Err(IntoInnerError(self, e)),\n-            Ok(()) => Ok(self.inner.take().unwrap()),\n-        }\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<W: Write> Write for BufWriter<W> {\n-    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n-        if self.buf.len() + buf.len() > self.buf.capacity() {\n-            self.flush_buf()?;\n-        }\n-        // FIXME: Why no len > capacity? Why not buffer len == capacity? #72919\n-        if buf.len() >= self.buf.capacity() {\n-            self.panicked = true;\n-            let r = self.get_mut().write(buf);\n-            self.panicked = false;\n-            r\n-        } else {\n-            self.buf.extend_from_slice(buf);\n-            Ok(buf.len())\n-        }\n-    }\n-\n-    fn write_all(&mut self, buf: &[u8]) -> io::Result<()> {\n-        // Normally, `write_all` just calls `write` in a loop. We can do better\n-        // by calling `self.get_mut().write_all()` directly, which avoids\n-        // round trips through the buffer in the event of a series of partial\n-        // writes in some circumstances.\n-        if self.buf.len() + buf.len() > self.buf.capacity() {\n-            self.flush_buf()?;\n-        }\n-        // FIXME: Why no len > capacity? Why not buffer len == capacity? #72919\n-        if buf.len() >= self.buf.capacity() {\n-            self.panicked = true;\n-            let r = self.get_mut().write_all(buf);\n-            self.panicked = false;\n-            r\n-        } else {\n-            self.buf.extend_from_slice(buf);\n-            Ok(())\n-        }\n-    }\n-\n-    fn write_vectored(&mut self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n-        let total_len = bufs.iter().map(|b| b.len()).sum::<usize>();\n-        if self.buf.len() + total_len > self.buf.capacity() {\n-            self.flush_buf()?;\n-        }\n-        // FIXME: Why no len > capacity? Why not buffer len == capacity? #72919\n-        if total_len >= self.buf.capacity() {\n-            self.panicked = true;\n-            let r = self.get_mut().write_vectored(bufs);\n-            self.panicked = false;\n-            r\n-        } else {\n-            bufs.iter().for_each(|b| self.buf.extend_from_slice(b));\n-            Ok(total_len)\n-        }\n-    }\n-\n-    fn is_write_vectored(&self) -> bool {\n-        self.get_ref().is_write_vectored()\n-    }\n-\n-    fn flush(&mut self) -> io::Result<()> {\n-        self.flush_buf().and_then(|()| self.get_mut().flush())\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<W: Write> fmt::Debug for BufWriter<W>\n-where\n-    W: fmt::Debug,\n-{\n-    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        fmt.debug_struct(\"BufWriter\")\n-            .field(\"writer\", &self.inner.as_ref().unwrap())\n-            .field(\"buffer\", &format_args!(\"{}/{}\", self.buf.len(), self.buf.capacity()))\n-            .finish()\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<W: Write + Seek> Seek for BufWriter<W> {\n-    /// Seek to the offset, in bytes, in the underlying writer.\n-    ///\n-    /// Seeking always writes out the internal buffer before seeking.\n-    fn seek(&mut self, pos: SeekFrom) -> io::Result<u64> {\n-        self.flush_buf()?;\n-        self.get_mut().seek(pos)\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<W: Write> Drop for BufWriter<W> {\n-    fn drop(&mut self) {\n-        if self.inner.is_some() && !self.panicked {\n-            // dtors should not panic, so we ignore a failed flush\n-            let _r = self.flush_buf();\n-        }\n-    }\n-}\n-\n-impl<W> IntoInnerError<W> {\n-    /// Returns the error which caused the call to [`BufWriter::into_inner()`]\n-    /// to fail.\n-    ///\n-    /// This error was returned when attempting to write the internal buffer.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::io::BufWriter;\n-    /// use std::net::TcpStream;\n-    ///\n-    /// let mut stream = BufWriter::new(TcpStream::connect(\"127.0.0.1:34254\").unwrap());\n-    ///\n-    /// // do stuff with the stream\n-    ///\n-    /// // we want to get our `TcpStream` back, so let's try:\n-    ///\n-    /// let stream = match stream.into_inner() {\n-    ///     Ok(s) => s,\n-    ///     Err(e) => {\n-    ///         // Here, e is an IntoInnerError, let's log the inner error.\n-    ///         //\n-    ///         // We'll just 'log' to stdout for this example.\n-    ///         println!(\"{}\", e.error());\n-    ///\n-    ///         panic!(\"An unexpected error occurred.\");\n-    ///     }\n-    /// };\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn error(&self) -> &Error {\n-        &self.1\n-    }\n-\n-    /// Returns the buffered writer instance which generated the error.\n-    ///\n-    /// The returned object can be used for error recovery, such as\n-    /// re-inspecting the buffer.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::io::BufWriter;\n-    /// use std::net::TcpStream;\n-    ///\n-    /// let mut stream = BufWriter::new(TcpStream::connect(\"127.0.0.1:34254\").unwrap());\n-    ///\n-    /// // do stuff with the stream\n-    ///\n-    /// // we want to get our `TcpStream` back, so let's try:\n-    ///\n-    /// let stream = match stream.into_inner() {\n-    ///     Ok(s) => s,\n-    ///     Err(e) => {\n-    ///         // Here, e is an IntoInnerError, let's re-examine the buffer:\n-    ///         let buffer = e.into_inner();\n-    ///\n-    ///         // do stuff to try to recover\n-    ///\n-    ///         // afterwards, let's just return the stream\n-    ///         buffer.into_inner().unwrap()\n-    ///     }\n-    /// };\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn into_inner(self) -> W {\n-        self.0\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<W> From<IntoInnerError<W>> for Error {\n-    fn from(iie: IntoInnerError<W>) -> Error {\n-        iie.1\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<W: Send + fmt::Debug> error::Error for IntoInnerError<W> {\n-    #[allow(deprecated, deprecated_in_future)]\n-    fn description(&self) -> &str {\n-        error::Error::description(self.error())\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<W> fmt::Display for IntoInnerError<W> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        self.error().fmt(f)\n-    }\n-}\n-\n-/// Private helper struct for implementing the line-buffered writing logic.\n-/// This shim temporarily wraps a BufWriter, and uses its internals to\n-/// implement a line-buffered writer (specifically by using the internal\n-/// methods like write_to_buf and flush_buf). In this way, a more\n-/// efficient abstraction can be created than one that only had access to\n-/// `write` and `flush`, without needlessly duplicating a lot of the\n-/// implementation details of BufWriter. This also allows existing\n-/// `BufWriters` to be temporarily given line-buffering logic; this is what\n-/// enables Stdout to be alternately in line-buffered or block-buffered mode.\n-#[derive(Debug)]\n-pub(super) struct LineWriterShim<'a, W: Write> {\n-    buffer: &'a mut BufWriter<W>,\n-}\n-\n-impl<'a, W: Write> LineWriterShim<'a, W> {\n-    pub fn new(buffer: &'a mut BufWriter<W>) -> Self {\n-        Self { buffer }\n-    }\n-\n-    /// Get a mutable reference to the inner writer (that is, the writer\n-    /// wrapped by the BufWriter). Be careful with this writer, as writes to\n-    /// it will bypass the buffer.\n-    fn inner_mut(&mut self) -> &mut W {\n-        self.buffer.get_mut()\n-    }\n-\n-    /// Get the content currently buffered in self.buffer\n-    fn buffered(&self) -> &[u8] {\n-        self.buffer.buffer()\n-    }\n-\n-    /// Flush the buffer iff the last byte is a newline (indicating that an\n-    /// earlier write only succeeded partially, and we want to retry flushing\n-    /// the buffered line before continuing with a subsequent write)\n-    fn flush_if_completed_line(&mut self) -> io::Result<()> {\n-        match self.buffered().last().copied() {\n-            Some(b'\\n') => self.buffer.flush_buf(),\n-            _ => Ok(()),\n-        }\n-    }\n-}\n-\n-impl<'a, W: Write> Write for LineWriterShim<'a, W> {\n-    /// Write some data into this BufReader with line buffering. This means\n-    /// that, if any newlines are present in the data, the data up to the last\n-    /// newline is sent directly to the underlying writer, and data after it\n-    /// is buffered. Returns the number of bytes written.\n-    ///\n-    /// This function operates on a \"best effort basis\"; in keeping with the\n-    /// convention of `Write::write`, it makes at most one attempt to write\n-    /// new data to the underlying writer. If that write only reports a partial\n-    /// success, the remaining data will be buffered.\n-    ///\n-    /// Because this function attempts to send completed lines to the underlying\n-    /// writer, it will also flush the existing buffer if it ends with a\n-    /// newline, even if the incoming data does not contain any newlines.\n-    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n-        let newline_idx = match memchr::memrchr(b'\\n', buf) {\n-            // If there are no new newlines (that is, if this write is less than\n-            // one line), just do a regular buffered write (which may flush if\n-            // we exceed the inner buffer's size)\n-            None => {\n-                self.flush_if_completed_line()?;\n-                return self.buffer.write(buf);\n-            }\n-            // Otherwise, arrange for the lines to be written directly to the\n-            // inner writer.\n-            Some(newline_idx) => newline_idx + 1,\n-        };\n-\n-        // Flush existing content to prepare for our write. We have to do this\n-        // before attempting to write `buf` in order to maintain consistency;\n-        // if we add `buf` to the buffer then try to flush it all at once,\n-        // we're obligated to return Ok(), which would mean suppressing any\n-        // errors that occur during flush.\n-        self.buffer.flush_buf()?;\n-\n-        // This is what we're going to try to write directly to the inner\n-        // writer. The rest will be buffered, if nothing goes wrong.\n-        let lines = &buf[..newline_idx];\n-\n-        // Write `lines` directly to the inner writer. In keeping with the\n-        // `write` convention, make at most one attempt to add new (unbuffered)\n-        // data. Because this write doesn't touch the BufWriter state directly,\n-        // and the buffer is known to be empty, we don't need to worry about\n-        // self.buffer.panicked here.\n-        let flushed = self.inner_mut().write(lines)?;\n-\n-        // If buffer returns Ok(0), propagate that to the caller without\n-        // doing additional buffering; otherwise we're just guaranteeing\n-        // an \"ErrorKind::WriteZero\" later.\n-        if flushed == 0 {\n-            return Ok(0);\n-        }\n-\n-        // Now that the write has succeeded, buffer the rest (or as much of\n-        // the rest as possible). If there were any unwritten newlines, we\n-        // only buffer out to the last unwritten newline that fits in the\n-        // buffer; this helps prevent flushing partial lines on subsequent\n-        // calls to LineWriterShim::write.\n-\n-        // Handle the cases in order of most-common to least-common, under\n-        // the presumption that most writes succeed in totality, and that most\n-        // writes are smaller than the buffer.\n-        // - Is this a partial line (ie, no newlines left in the unwritten tail)\n-        // - If not, does the data out to the last unwritten newline fit in\n-        //   the buffer?\n-        // - If not, scan for the last newline that *does* fit in the buffer\n-        let tail = if flushed >= newline_idx {\n-            &buf[flushed..]\n-        } else if newline_idx - flushed <= self.buffer.capacity() {\n-            &buf[flushed..newline_idx]\n-        } else {\n-            let scan_area = &buf[flushed..];\n-            let scan_area = &scan_area[..self.buffer.capacity()];\n-            match memchr::memrchr(b'\\n', scan_area) {\n-                Some(newline_idx) => &scan_area[..newline_idx + 1],\n-                None => scan_area,\n-            }\n-        };\n-\n-        let buffered = self.buffer.write_to_buf(tail);\n-        Ok(flushed + buffered)\n-    }\n-\n-    fn flush(&mut self) -> io::Result<()> {\n-        self.buffer.flush()\n-    }\n-\n-    /// Write some vectored data into this BufReader with line buffering. This\n-    /// means that, if any newlines are present in the data, the data up to\n-    /// and including the buffer containing the last newline is sent directly\n-    /// to the inner writer, and the data after it is buffered. Returns the\n-    /// number of bytes written.\n-    ///\n-    /// This function operates on a \"best effort basis\"; in keeping with the\n-    /// convention of `Write::write`, it makes at most one attempt to write\n-    /// new data to the underlying writer.\n-    ///\n-    /// Because this function attempts to send completed lines to the underlying\n-    /// writer, it will also flush the existing buffer if it contains any\n-    /// newlines.\n-    ///\n-    /// Because sorting through an array of `IoSlice` can be a bit convoluted,\n-    /// This method differs from write in the following ways:\n-    ///\n-    /// - It attempts to write the full content of all the buffers up to and\n-    ///   including the one containing the last newline. This means that it\n-    ///   may attempt to write a partial line, that buffer has data past the\n-    ///   newline.\n-    /// - If the write only reports partial success, it does not attempt to\n-    ///   find the precise location of the written bytes and buffer the rest.\n-    ///\n-    /// If the underlying vector doesn't support vectored writing, we instead\n-    /// simply write the first non-empty buffer with `write`. This way, we\n-    /// get the benefits of more granular partial-line handling without losing\n-    /// anything in efficiency\n-    fn write_vectored(&mut self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n-        // If there's no specialized behavior for write_vectored, just use\n-        // write. This has the benefit of more granular partial-line handling.\n-        if !self.is_write_vectored() {\n-            return match bufs.iter().find(|buf| !buf.is_empty()) {\n-                Some(buf) => self.write(buf),\n-                None => Ok(0),\n-            };\n-        }\n-\n-        // Find the buffer containing the last newline\n-        let last_newline_buf_idx = bufs\n-            .iter()\n-            .enumerate()\n-            .rev()\n-            .find_map(|(i, buf)| memchr::memchr(b'\\n', buf).map(|_| i));\n-\n-        // If there are no new newlines (that is, if this write is less than\n-        // one line), just do a regular buffered write\n-        let last_newline_buf_idx = match last_newline_buf_idx {\n-            // No newlines; just do a normal buffered write\n-            None => {\n-                self.flush_if_completed_line()?;\n-                return self.buffer.write_vectored(bufs);\n-            }\n-            Some(i) => i,\n-        };\n-\n-        // Flush existing content to prepare for our write\n-        self.buffer.flush_buf()?;\n-\n-        // This is what we're going to try to write directly to the inner\n-        // writer. The rest will be buffered, if nothing goes wrong.\n-        let (lines, tail) = bufs.split_at(last_newline_buf_idx + 1);\n-\n-        // Write `lines` directly to the inner writer. In keeping with the\n-        // `write` convention, make at most one attempt to add new (unbuffered)\n-        // data. Because this write doesn't touch the BufWriter state directly,\n-        // and the buffer is known to be empty, we don't need to worry about\n-        // self.panicked here.\n-        let flushed = self.inner_mut().write_vectored(lines)?;\n-\n-        // If inner returns Ok(0), propagate that to the caller without\n-        // doing additional buffering; otherwise we're just guaranteeing\n-        // an \"ErrorKind::WriteZero\" later.\n-        if flushed == 0 {\n-            return Ok(0);\n-        }\n-\n-        // Don't try to reconstruct the exact amount written; just bail\n-        // in the event of a partial write\n-        let lines_len = lines.iter().map(|buf| buf.len()).sum();\n-        if flushed < lines_len {\n-            return Ok(flushed);\n-        }\n-\n-        // Now that the write has succeeded, buffer the rest (or as much of the\n-        // rest as possible)\n-        let buffered: usize = tail\n-            .iter()\n-            .filter(|buf| !buf.is_empty())\n-            .map(|buf| self.buffer.write_to_buf(buf))\n-            .take_while(|&n| n > 0)\n-            .sum();\n-\n-        Ok(flushed + buffered)\n-    }\n-\n-    fn is_write_vectored(&self) -> bool {\n-        self.buffer.is_write_vectored()\n-    }\n-\n-    /// Write some data into this BufReader with line buffering. This means\n-    /// that, if any newlines are present in the data, the data up to the last\n-    /// newline is sent directly to the underlying writer, and data after it\n-    /// is buffered.\n-    ///\n-    /// Because this function attempts to send completed lines to the underlying\n-    /// writer, it will also flush the existing buffer if it contains any\n-    /// newlines, even if the incoming data does not contain any newlines.\n-    fn write_all(&mut self, buf: &[u8]) -> io::Result<()> {\n-        match memchr::memrchr(b'\\n', buf) {\n-            // If there are no new newlines (that is, if this write is less than\n-            // one line), just do a regular buffered write (which may flush if\n-            // we exceed the inner buffer's size)\n-            None => {\n-                self.flush_if_completed_line()?;\n-                self.buffer.write_all(buf)\n-            }\n-            Some(newline_idx) => {\n-                let (lines, tail) = buf.split_at(newline_idx + 1);\n-\n-                if self.buffered().is_empty() {\n-                    self.inner_mut().write_all(lines)?;\n-                } else {\n-                    // If there is any buffered data, we add the incoming lines\n-                    // to that buffer before flushing, which saves us at least\n-                    // one write call. We can't really do this with `write`,\n-                    // since we can't do this *and* not suppress errors *and*\n-                    // report a consistent state to the caller in a return\n-                    // value, but here in write_all it's fine.\n-                    self.buffer.write_all(lines)?;\n-                    self.buffer.flush_buf()?;\n-                }\n-\n-                self.buffer.write_all(tail)\n-            }\n-        }\n-    }\n-}\n-\n-/// Wraps a writer and buffers output to it, flushing whenever a newline\n-/// (`0x0a`, `'\\n'`) is detected.\n-///\n-/// The [`BufWriter`] struct wraps a writer and buffers its output.\n-/// But it only does this batched write when it goes out of scope, or when the\n-/// internal buffer is full. Sometimes, you'd prefer to write each line as it's\n-/// completed, rather than the entire buffer at once. Enter `LineWriter`. It\n-/// does exactly that.\n-///\n-/// Like [`BufWriter`], a `LineWriter`\u2019s buffer will also be flushed when the\n-/// `LineWriter` goes out of scope or when its internal buffer is full.\n-///\n-/// If there's still a partial line in the buffer when the `LineWriter` is\n-/// dropped, it will flush those contents.\n-///\n-/// # Examples\n-///\n-/// We can use `LineWriter` to write one line at a time, significantly\n-/// reducing the number of actual writes to the file.\n-///\n-/// ```no_run\n-/// use std::fs::{self, File};\n-/// use std::io::prelude::*;\n-/// use std::io::LineWriter;\n-///\n-/// fn main() -> std::io::Result<()> {\n-///     let road_not_taken = b\"I shall be telling this with a sigh\n-/// Somewhere ages and ages hence:\n-/// Two roads diverged in a wood, and I -\n-/// I took the one less traveled by,\n-/// And that has made all the difference.\";\n-///\n-///     let file = File::create(\"poem.txt\")?;\n-///     let mut file = LineWriter::new(file);\n-///\n-///     file.write_all(b\"I shall be telling this with a sigh\")?;\n-///\n-///     // No bytes are written until a newline is encountered (or\n-///     // the internal buffer is filled).\n-///     assert_eq!(fs::read_to_string(\"poem.txt\")?, \"\");\n-///     file.write_all(b\"\\n\")?;\n-///     assert_eq!(\n-///         fs::read_to_string(\"poem.txt\")?,\n-///         \"I shall be telling this with a sigh\\n\",\n-///     );\n-///\n-///     // Write the rest of the poem.\n-///     file.write_all(b\"Somewhere ages and ages hence:\n-/// Two roads diverged in a wood, and I -\n-/// I took the one less traveled by,\n-/// And that has made all the difference.\")?;\n-///\n-///     // The last line of the poem doesn't end in a newline, so\n-///     // we have to flush or drop the `LineWriter` to finish\n-///     // writing.\n-///     file.flush()?;\n-///\n-///     // Confirm the whole poem was written.\n-///     assert_eq!(fs::read(\"poem.txt\")?, &road_not_taken[..]);\n-///     Ok(())\n-/// }\n-/// ```\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct LineWriter<W: Write> {\n-    inner: BufWriter<W>,\n-}\n-\n-impl<W: Write> LineWriter<W> {\n-    /// Creates a new `LineWriter`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::fs::File;\n-    /// use std::io::LineWriter;\n-    ///\n-    /// fn main() -> std::io::Result<()> {\n-    ///     let file = File::create(\"poem.txt\")?;\n-    ///     let file = LineWriter::new(file);\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn new(inner: W) -> LineWriter<W> {\n-        // Lines typically aren't that long, don't use a giant buffer\n-        LineWriter::with_capacity(1024, inner)\n-    }\n-\n-    /// Creates a new `LineWriter` with a specified capacity for the internal\n-    /// buffer.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::fs::File;\n-    /// use std::io::LineWriter;\n-    ///\n-    /// fn main() -> std::io::Result<()> {\n-    ///     let file = File::create(\"poem.txt\")?;\n-    ///     let file = LineWriter::with_capacity(100, file);\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn with_capacity(capacity: usize, inner: W) -> LineWriter<W> {\n-        LineWriter { inner: BufWriter::with_capacity(capacity, inner) }\n-    }\n-\n-    /// Gets a reference to the underlying writer.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::fs::File;\n-    /// use std::io::LineWriter;\n-    ///\n-    /// fn main() -> std::io::Result<()> {\n-    ///     let file = File::create(\"poem.txt\")?;\n-    ///     let file = LineWriter::new(file);\n-    ///\n-    ///     let reference = file.get_ref();\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn get_ref(&self) -> &W {\n-        self.inner.get_ref()\n-    }\n-\n-    /// Gets a mutable reference to the underlying writer.\n-    ///\n-    /// Caution must be taken when calling methods on the mutable reference\n-    /// returned as extra writes could corrupt the output stream.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::fs::File;\n-    /// use std::io::LineWriter;\n-    ///\n-    /// fn main() -> std::io::Result<()> {\n-    ///     let file = File::create(\"poem.txt\")?;\n-    ///     let mut file = LineWriter::new(file);\n-    ///\n-    ///     // we can use reference just like file\n-    ///     let reference = file.get_mut();\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn get_mut(&mut self) -> &mut W {\n-        self.inner.get_mut()\n-    }\n-\n-    /// Unwraps this `LineWriter`, returning the underlying writer.\n-    ///\n-    /// The internal buffer is written out before returning the writer.\n-    ///\n-    /// # Errors\n-    ///\n-    /// An [`Err`] will be returned if an error occurs while flushing the buffer.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::fs::File;\n-    /// use std::io::LineWriter;\n-    ///\n-    /// fn main() -> std::io::Result<()> {\n-    ///     let file = File::create(\"poem.txt\")?;\n-    ///\n-    ///     let writer: LineWriter<File> = LineWriter::new(file);\n-    ///\n-    ///     let file: File = writer.into_inner()?;\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn into_inner(self) -> Result<W, IntoInnerError<LineWriter<W>>> {\n-        self.inner\n-            .into_inner()\n-            .map_err(|IntoInnerError(buf, e)| IntoInnerError(LineWriter { inner: buf }, e))\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<W: Write> Write for LineWriter<W> {\n-    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n-        LineWriterShim::new(&mut self.inner).write(buf)\n-    }\n-\n-    fn flush(&mut self) -> io::Result<()> {\n-        self.inner.flush()\n-    }\n-\n-    fn write_vectored(&mut self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n-        LineWriterShim::new(&mut self.inner).write_vectored(bufs)\n-    }\n-\n-    fn is_write_vectored(&self) -> bool {\n-        self.inner.is_write_vectored()\n-    }\n-\n-    fn write_all(&mut self, buf: &[u8]) -> io::Result<()> {\n-        LineWriterShim::new(&mut self.inner).write_all(buf)\n-    }\n-\n-    fn write_all_vectored(&mut self, bufs: &mut [IoSlice<'_>]) -> io::Result<()> {\n-        LineWriterShim::new(&mut self.inner).write_all_vectored(bufs)\n-    }\n-\n-    fn write_fmt(&mut self, fmt: fmt::Arguments<'_>) -> io::Result<()> {\n-        LineWriterShim::new(&mut self.inner).write_fmt(fmt)\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<W: Write> fmt::Debug for LineWriter<W>\n-where\n-    W: fmt::Debug,\n-{\n-    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        fmt.debug_struct(\"LineWriter\")\n-            .field(\"writer\", &self.inner.inner)\n-            .field(\n-                \"buffer\",\n-                &format_args!(\"{}/{}\", self.inner.buf.len(), self.inner.buf.capacity()),\n-            )\n-            .finish()\n-    }\n-}"}, {"sha": "8fe29f08a7bd72b52311d33997a3273fac7ac87f", "filename": "library/std/src/io/buffered/bufreader.rs", "status": "added", "additions": 423, "deletions": 0, "changes": 423, "blob_url": "https://github.com/rust-lang/rust/blob/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Fbufreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Fbufreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Fbufreader.rs?ref=b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7", "patch": "@@ -0,0 +1,423 @@\n+use crate::cmp;\n+use crate::fmt;\n+use crate::io::{self, BufRead, Initializer, IoSliceMut, Read, Seek, SeekFrom, DEFAULT_BUF_SIZE};\n+\n+/// The `BufReader<R>` struct adds buffering to any reader.\n+///\n+/// It can be excessively inefficient to work directly with a [`Read`] instance.\n+/// For example, every call to [`read`][`TcpStream::read`] on [`TcpStream`]\n+/// results in a system call. A `BufReader<R>` performs large, infrequent reads on\n+/// the underlying [`Read`] and maintains an in-memory buffer of the results.\n+///\n+/// `BufReader<R>` can improve the speed of programs that make *small* and\n+/// *repeated* read calls to the same file or network socket. It does not\n+/// help when reading very large amounts at once, or reading just one or a few\n+/// times. It also provides no advantage when reading from a source that is\n+/// already in memory, like a [`Vec`]`<u8>`.\n+///\n+/// When the `BufReader<R>` is dropped, the contents of its buffer will be\n+/// discarded. Creating multiple instances of a `BufReader<R>` on the same\n+/// stream can cause data loss. Reading from the underlying reader after\n+/// unwrapping the `BufReader<R>` with [`BufReader::into_inner`] can also cause\n+/// data loss.\n+///\n+/// [`TcpStream::read`]: Read::read\n+/// [`TcpStream`]: crate::net::TcpStream\n+///\n+/// # Examples\n+///\n+/// ```no_run\n+/// use std::io::prelude::*;\n+/// use std::io::BufReader;\n+/// use std::fs::File;\n+///\n+/// fn main() -> std::io::Result<()> {\n+///     let f = File::open(\"log.txt\")?;\n+///     let mut reader = BufReader::new(f);\n+///\n+///     let mut line = String::new();\n+///     let len = reader.read_line(&mut line)?;\n+///     println!(\"First line is {} bytes long\", len);\n+///     Ok(())\n+/// }\n+/// ```\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct BufReader<R> {\n+    inner: R,\n+    buf: Box<[u8]>,\n+    pos: usize,\n+    cap: usize,\n+}\n+\n+impl<R: Read> BufReader<R> {\n+    /// Creates a new `BufReader<R>` with a default buffer capacity. The default is currently 8 KB,\n+    /// but may change in the future.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::io::BufReader;\n+    /// use std::fs::File;\n+    ///\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let f = File::open(\"log.txt\")?;\n+    ///     let reader = BufReader::new(f);\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn new(inner: R) -> BufReader<R> {\n+        BufReader::with_capacity(DEFAULT_BUF_SIZE, inner)\n+    }\n+\n+    /// Creates a new `BufReader<R>` with the specified buffer capacity.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Creating a buffer with ten bytes of capacity:\n+    ///\n+    /// ```no_run\n+    /// use std::io::BufReader;\n+    /// use std::fs::File;\n+    ///\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let f = File::open(\"log.txt\")?;\n+    ///     let reader = BufReader::with_capacity(10, f);\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn with_capacity(capacity: usize, inner: R) -> BufReader<R> {\n+        unsafe {\n+            let mut buffer = Vec::with_capacity(capacity);\n+            buffer.set_len(capacity);\n+            inner.initializer().initialize(&mut buffer);\n+            BufReader { inner, buf: buffer.into_boxed_slice(), pos: 0, cap: 0 }\n+        }\n+    }\n+}\n+\n+impl<R> BufReader<R> {\n+    /// Gets a reference to the underlying reader.\n+    ///\n+    /// It is inadvisable to directly read from the underlying reader.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::io::BufReader;\n+    /// use std::fs::File;\n+    ///\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let f1 = File::open(\"log.txt\")?;\n+    ///     let reader = BufReader::new(f1);\n+    ///\n+    ///     let f2 = reader.get_ref();\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn get_ref(&self) -> &R {\n+        &self.inner\n+    }\n+\n+    /// Gets a mutable reference to the underlying reader.\n+    ///\n+    /// It is inadvisable to directly read from the underlying reader.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::io::BufReader;\n+    /// use std::fs::File;\n+    ///\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let f1 = File::open(\"log.txt\")?;\n+    ///     let mut reader = BufReader::new(f1);\n+    ///\n+    ///     let f2 = reader.get_mut();\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn get_mut(&mut self) -> &mut R {\n+        &mut self.inner\n+    }\n+\n+    /// Returns a reference to the internally buffered data.\n+    ///\n+    /// Unlike [`fill_buf`], this will not attempt to fill the buffer if it is empty.\n+    ///\n+    /// [`fill_buf`]: BufRead::fill_buf\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::io::{BufReader, BufRead};\n+    /// use std::fs::File;\n+    ///\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let f = File::open(\"log.txt\")?;\n+    ///     let mut reader = BufReader::new(f);\n+    ///     assert!(reader.buffer().is_empty());\n+    ///\n+    ///     if reader.fill_buf()?.len() > 0 {\n+    ///         assert!(!reader.buffer().is_empty());\n+    ///     }\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[stable(feature = \"bufreader_buffer\", since = \"1.37.0\")]\n+    pub fn buffer(&self) -> &[u8] {\n+        &self.buf[self.pos..self.cap]\n+    }\n+\n+    /// Returns the number of bytes the internal buffer can hold at once.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::io::{BufReader, BufRead};\n+    /// use std::fs::File;\n+    ///\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let f = File::open(\"log.txt\")?;\n+    ///     let mut reader = BufReader::new(f);\n+    ///\n+    ///     let capacity = reader.capacity();\n+    ///     let buffer = reader.fill_buf()?;\n+    ///     assert!(buffer.len() <= capacity);\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[stable(feature = \"buffered_io_capacity\", since = \"1.46.0\")]\n+    pub fn capacity(&self) -> usize {\n+        self.buf.len()\n+    }\n+\n+    /// Unwraps this `BufReader<R>`, returning the underlying reader.\n+    ///\n+    /// Note that any leftover data in the internal buffer is lost. Therefore,\n+    /// a following read from the underlying reader may lead to data loss.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::io::BufReader;\n+    /// use std::fs::File;\n+    ///\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let f1 = File::open(\"log.txt\")?;\n+    ///     let reader = BufReader::new(f1);\n+    ///\n+    ///     let f2 = reader.into_inner();\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn into_inner(self) -> R {\n+        self.inner\n+    }\n+\n+    /// Invalidates all data in the internal buffer.\n+    #[inline]\n+    fn discard_buffer(&mut self) {\n+        self.pos = 0;\n+        self.cap = 0;\n+    }\n+}\n+\n+impl<R: Seek> BufReader<R> {\n+    /// Seeks relative to the current position. If the new position lies within the buffer,\n+    /// the buffer will not be flushed, allowing for more efficient seeks.\n+    /// This method does not return the location of the underlying reader, so the caller\n+    /// must track this information themselves if it is required.\n+    #[unstable(feature = \"bufreader_seek_relative\", issue = \"31100\")]\n+    pub fn seek_relative(&mut self, offset: i64) -> io::Result<()> {\n+        let pos = self.pos as u64;\n+        if offset < 0 {\n+            if let Some(new_pos) = pos.checked_sub((-offset) as u64) {\n+                self.pos = new_pos as usize;\n+                return Ok(());\n+            }\n+        } else {\n+            if let Some(new_pos) = pos.checked_add(offset as u64) {\n+                if new_pos <= self.cap as u64 {\n+                    self.pos = new_pos as usize;\n+                    return Ok(());\n+                }\n+            }\n+        }\n+        self.seek(SeekFrom::Current(offset)).map(drop)\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<R: Read> Read for BufReader<R> {\n+    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n+        // If we don't have any buffered data and we're doing a massive read\n+        // (larger than our internal buffer), bypass our internal buffer\n+        // entirely.\n+        if self.pos == self.cap && buf.len() >= self.buf.len() {\n+            self.discard_buffer();\n+            return self.inner.read(buf);\n+        }\n+        let nread = {\n+            let mut rem = self.fill_buf()?;\n+            rem.read(buf)?\n+        };\n+        self.consume(nread);\n+        Ok(nread)\n+    }\n+\n+    fn read_vectored(&mut self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n+        let total_len = bufs.iter().map(|b| b.len()).sum::<usize>();\n+        if self.pos == self.cap && total_len >= self.buf.len() {\n+            self.discard_buffer();\n+            return self.inner.read_vectored(bufs);\n+        }\n+        let nread = {\n+            let mut rem = self.fill_buf()?;\n+            rem.read_vectored(bufs)?\n+        };\n+        self.consume(nread);\n+        Ok(nread)\n+    }\n+\n+    fn is_read_vectored(&self) -> bool {\n+        self.inner.is_read_vectored()\n+    }\n+\n+    // we can't skip unconditionally because of the large buffer case in read.\n+    unsafe fn initializer(&self) -> Initializer {\n+        self.inner.initializer()\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<R: Read> BufRead for BufReader<R> {\n+    fn fill_buf(&mut self) -> io::Result<&[u8]> {\n+        // If we've reached the end of our internal buffer then we need to fetch\n+        // some more data from the underlying reader.\n+        // Branch using `>=` instead of the more correct `==`\n+        // to tell the compiler that the pos..cap slice is always valid.\n+        if self.pos >= self.cap {\n+            debug_assert!(self.pos == self.cap);\n+            self.cap = self.inner.read(&mut self.buf)?;\n+            self.pos = 0;\n+        }\n+        Ok(&self.buf[self.pos..self.cap])\n+    }\n+\n+    fn consume(&mut self, amt: usize) {\n+        self.pos = cmp::min(self.pos + amt, self.cap);\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<R> fmt::Debug for BufReader<R>\n+where\n+    R: fmt::Debug,\n+{\n+    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        fmt.debug_struct(\"BufReader\")\n+            .field(\"reader\", &self.inner)\n+            .field(\"buffer\", &format_args!(\"{}/{}\", self.cap - self.pos, self.buf.len()))\n+            .finish()\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<R: Seek> Seek for BufReader<R> {\n+    /// Seek to an offset, in bytes, in the underlying reader.\n+    ///\n+    /// The position used for seeking with [`SeekFrom::Current`]`(_)` is the\n+    /// position the underlying reader would be at if the `BufReader<R>` had no\n+    /// internal buffer.\n+    ///\n+    /// Seeking always discards the internal buffer, even if the seek position\n+    /// would otherwise fall within it. This guarantees that calling\n+    /// [`BufReader::into_inner()`] immediately after a seek yields the underlying reader\n+    /// at the same position.\n+    ///\n+    /// To seek without discarding the internal buffer, use [`BufReader::seek_relative`].\n+    ///\n+    /// See [`std::io::Seek`] for more details.\n+    ///\n+    /// Note: In the edge case where you're seeking with [`SeekFrom::Current`]`(n)`\n+    /// where `n` minus the internal buffer length overflows an `i64`, two\n+    /// seeks will be performed instead of one. If the second seek returns\n+    /// [`Err`], the underlying reader will be left at the same position it would\n+    /// have if you called `seek` with [`SeekFrom::Current`]`(0)`.\n+    ///\n+    /// [`std::io::Seek`]: Seek\n+    fn seek(&mut self, pos: SeekFrom) -> io::Result<u64> {\n+        let result: u64;\n+        if let SeekFrom::Current(n) = pos {\n+            let remainder = (self.cap - self.pos) as i64;\n+            // it should be safe to assume that remainder fits within an i64 as the alternative\n+            // means we managed to allocate 8 exbibytes and that's absurd.\n+            // But it's not out of the realm of possibility for some weird underlying reader to\n+            // support seeking by i64::MIN so we need to handle underflow when subtracting\n+            // remainder.\n+            if let Some(offset) = n.checked_sub(remainder) {\n+                result = self.inner.seek(SeekFrom::Current(offset))?;\n+            } else {\n+                // seek backwards by our remainder, and then by the offset\n+                self.inner.seek(SeekFrom::Current(-remainder))?;\n+                self.discard_buffer();\n+                result = self.inner.seek(SeekFrom::Current(n))?;\n+            }\n+        } else {\n+            // Seeking with Start/End doesn't care about our buffer length.\n+            result = self.inner.seek(pos)?;\n+        }\n+        self.discard_buffer();\n+        Ok(result)\n+    }\n+\n+    /// Returns the current seek position from the start of the stream.\n+    ///\n+    /// The value returned is equivalent to `self.seek(SeekFrom::Current(0))`\n+    /// but does not flush the internal buffer. Due to this optimization the\n+    /// function does not guarantee that calling `.into_inner()` immediately\n+    /// afterwards will yield the underlying reader at the same position. Use\n+    /// [`BufReader::seek`] instead if you require that guarantee.\n+    ///\n+    /// # Panics\n+    ///\n+    /// This function will panic if the position of the inner reader is smaller\n+    /// than the amount of buffered data. That can happen if the inner reader\n+    /// has an incorrect implementation of [`Seek::stream_position`], or if the\n+    /// position has gone out of sync due to calling [`Seek::seek`] directly on\n+    /// the underlying reader.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```no_run\n+    /// #![feature(seek_convenience)]\n+    /// use std::{\n+    ///     io::{self, BufRead, BufReader, Seek},\n+    ///     fs::File,\n+    /// };\n+    ///\n+    /// fn main() -> io::Result<()> {\n+    ///     let mut f = BufReader::new(File::open(\"foo.txt\")?);\n+    ///\n+    ///     let before = f.stream_position()?;\n+    ///     f.read_line(&mut String::new())?;\n+    ///     let after = f.stream_position()?;\n+    ///\n+    ///     println!(\"The first line was {} bytes long\", after - before);\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    fn stream_position(&mut self) -> io::Result<u64> {\n+        let remainder = (self.cap - self.pos) as u64;\n+        self.inner.stream_position().map(|pos| {\n+            pos.checked_sub(remainder).expect(\n+                \"overflow when subtracting remaining buffer size from inner stream position\",\n+            )\n+        })\n+    }\n+}"}, {"sha": "8ce795a05ed3643466871daf95653b51645c055c", "filename": "library/std/src/io/buffered/bufwriter.rs", "status": "added", "additions": 387, "deletions": 0, "changes": 387, "blob_url": "https://github.com/rust-lang/rust/blob/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Fbufwriter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Fbufwriter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Fbufwriter.rs?ref=b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7", "patch": "@@ -0,0 +1,387 @@\n+use crate::fmt;\n+use crate::io::{\n+    self, Error, ErrorKind, IntoInnerError, IoSlice, Seek, SeekFrom, Write, DEFAULT_BUF_SIZE,\n+};\n+\n+/// Wraps a writer and buffers its output.\n+///\n+/// It can be excessively inefficient to work directly with something that\n+/// implements [`Write`]. For example, every call to\n+/// [`write`][`TcpStream::write`] on [`TcpStream`] results in a system call. A\n+/// `BufWriter<W>` keeps an in-memory buffer of data and writes it to an underlying\n+/// writer in large, infrequent batches.\n+///\n+/// `BufWriter<W>` can improve the speed of programs that make *small* and\n+/// *repeated* write calls to the same file or network socket. It does not\n+/// help when writing very large amounts at once, or writing just one or a few\n+/// times. It also provides no advantage when writing to a destination that is\n+/// in memory, like a [`Vec`]<u8>`.\n+///\n+/// It is critical to call [`flush`] before `BufWriter<W>` is dropped. Though\n+/// dropping will attempt to flush the contents of the buffer, any errors\n+/// that happen in the process of dropping will be ignored. Calling [`flush`]\n+/// ensures that the buffer is empty and thus dropping will not even attempt\n+/// file operations.\n+///\n+/// # Examples\n+///\n+/// Let's write the numbers one through ten to a [`TcpStream`]:\n+///\n+/// ```no_run\n+/// use std::io::prelude::*;\n+/// use std::net::TcpStream;\n+///\n+/// let mut stream = TcpStream::connect(\"127.0.0.1:34254\").unwrap();\n+///\n+/// for i in 0..10 {\n+///     stream.write(&[i+1]).unwrap();\n+/// }\n+/// ```\n+///\n+/// Because we're not buffering, we write each one in turn, incurring the\n+/// overhead of a system call per byte written. We can fix this with a\n+/// `BufWriter<W>`:\n+///\n+/// ```no_run\n+/// use std::io::prelude::*;\n+/// use std::io::BufWriter;\n+/// use std::net::TcpStream;\n+///\n+/// let mut stream = BufWriter::new(TcpStream::connect(\"127.0.0.1:34254\").unwrap());\n+///\n+/// for i in 0..10 {\n+///     stream.write(&[i+1]).unwrap();\n+/// }\n+/// stream.flush().unwrap();\n+/// ```\n+///\n+/// By wrapping the stream with a `BufWriter<W>`, these ten writes are all grouped\n+/// together by the buffer and will all be written out in one system call when\n+/// the `stream` is flushed.\n+///\n+/// [`TcpStream::write`]: Write::write\n+/// [`TcpStream`]: crate::net::TcpStream\n+/// [`flush`]: Write::flush\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct BufWriter<W: Write> {\n+    inner: Option<W>,\n+    buf: Vec<u8>,\n+    // #30888: If the inner writer panics in a call to write, we don't want to\n+    // write the buffered data a second time in BufWriter's destructor. This\n+    // flag tells the Drop impl if it should skip the flush.\n+    panicked: bool,\n+}\n+\n+impl<W: Write> BufWriter<W> {\n+    /// Creates a new `BufWriter<W>` with a default buffer capacity. The default is currently 8 KB,\n+    /// but may change in the future.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::io::BufWriter;\n+    /// use std::net::TcpStream;\n+    ///\n+    /// let mut buffer = BufWriter::new(TcpStream::connect(\"127.0.0.1:34254\").unwrap());\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn new(inner: W) -> BufWriter<W> {\n+        BufWriter::with_capacity(DEFAULT_BUF_SIZE, inner)\n+    }\n+\n+    /// Creates a new `BufWriter<W>` with the specified buffer capacity.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Creating a buffer with a buffer of a hundred bytes.\n+    ///\n+    /// ```no_run\n+    /// use std::io::BufWriter;\n+    /// use std::net::TcpStream;\n+    ///\n+    /// let stream = TcpStream::connect(\"127.0.0.1:34254\").unwrap();\n+    /// let mut buffer = BufWriter::with_capacity(100, stream);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn with_capacity(capacity: usize, inner: W) -> BufWriter<W> {\n+        BufWriter { inner: Some(inner), buf: Vec::with_capacity(capacity), panicked: false }\n+    }\n+\n+    /// Send data in our local buffer into the inner writer, looping as\n+    /// necessary until either it's all been sent or an error occurs.\n+    ///\n+    /// Because all the data in the buffer has been reported to our owner as\n+    /// \"successfully written\" (by returning nonzero success values from\n+    /// `write`), any 0-length writes from `inner` must be reported as i/o\n+    /// errors from this method.\n+    pub(super) fn flush_buf(&mut self) -> io::Result<()> {\n+        /// Helper struct to ensure the buffer is updated after all the writes\n+        /// are complete. It tracks the number of written bytes and drains them\n+        /// all from the front of the buffer when dropped.\n+        struct BufGuard<'a> {\n+            buffer: &'a mut Vec<u8>,\n+            written: usize,\n+        }\n+\n+        impl<'a> BufGuard<'a> {\n+            fn new(buffer: &'a mut Vec<u8>) -> Self {\n+                Self { buffer, written: 0 }\n+            }\n+\n+            /// The unwritten part of the buffer\n+            fn remaining(&self) -> &[u8] {\n+                &self.buffer[self.written..]\n+            }\n+\n+            /// Flag some bytes as removed from the front of the buffer\n+            fn consume(&mut self, amt: usize) {\n+                self.written += amt;\n+            }\n+\n+            /// true if all of the bytes have been written\n+            fn done(&self) -> bool {\n+                self.written >= self.buffer.len()\n+            }\n+        }\n+\n+        impl Drop for BufGuard<'_> {\n+            fn drop(&mut self) {\n+                if self.written > 0 {\n+                    self.buffer.drain(..self.written);\n+                }\n+            }\n+        }\n+\n+        let mut guard = BufGuard::new(&mut self.buf);\n+        let inner = self.inner.as_mut().unwrap();\n+        while !guard.done() {\n+            self.panicked = true;\n+            let r = inner.write(guard.remaining());\n+            self.panicked = false;\n+\n+            match r {\n+                Ok(0) => {\n+                    return Err(Error::new(\n+                        ErrorKind::WriteZero,\n+                        \"failed to write the buffered data\",\n+                    ));\n+                }\n+                Ok(n) => guard.consume(n),\n+                Err(ref e) if e.kind() == io::ErrorKind::Interrupted => {}\n+                Err(e) => return Err(e),\n+            }\n+        }\n+        Ok(())\n+    }\n+\n+    /// Buffer some data without flushing it, regardless of the size of the\n+    /// data. Writes as much as possible without exceeding capacity. Returns\n+    /// the number of bytes written.\n+    pub(super) fn write_to_buf(&mut self, buf: &[u8]) -> usize {\n+        let available = self.buf.capacity() - self.buf.len();\n+        let amt_to_buffer = available.min(buf.len());\n+        self.buf.extend_from_slice(&buf[..amt_to_buffer]);\n+        amt_to_buffer\n+    }\n+\n+    /// Gets a reference to the underlying writer.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::io::BufWriter;\n+    /// use std::net::TcpStream;\n+    ///\n+    /// let mut buffer = BufWriter::new(TcpStream::connect(\"127.0.0.1:34254\").unwrap());\n+    ///\n+    /// // we can use reference just like buffer\n+    /// let reference = buffer.get_ref();\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn get_ref(&self) -> &W {\n+        self.inner.as_ref().unwrap()\n+    }\n+\n+    /// Gets a mutable reference to the underlying writer.\n+    ///\n+    /// It is inadvisable to directly write to the underlying writer.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::io::BufWriter;\n+    /// use std::net::TcpStream;\n+    ///\n+    /// let mut buffer = BufWriter::new(TcpStream::connect(\"127.0.0.1:34254\").unwrap());\n+    ///\n+    /// // we can use reference just like buffer\n+    /// let reference = buffer.get_mut();\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn get_mut(&mut self) -> &mut W {\n+        self.inner.as_mut().unwrap()\n+    }\n+\n+    /// Returns a reference to the internally buffered data.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::io::BufWriter;\n+    /// use std::net::TcpStream;\n+    ///\n+    /// let buf_writer = BufWriter::new(TcpStream::connect(\"127.0.0.1:34254\").unwrap());\n+    ///\n+    /// // See how many bytes are currently buffered\n+    /// let bytes_buffered = buf_writer.buffer().len();\n+    /// ```\n+    #[stable(feature = \"bufreader_buffer\", since = \"1.37.0\")]\n+    pub fn buffer(&self) -> &[u8] {\n+        &self.buf\n+    }\n+\n+    /// Returns the number of bytes the internal buffer can hold without flushing.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::io::BufWriter;\n+    /// use std::net::TcpStream;\n+    ///\n+    /// let buf_writer = BufWriter::new(TcpStream::connect(\"127.0.0.1:34254\").unwrap());\n+    ///\n+    /// // Check the capacity of the inner buffer\n+    /// let capacity = buf_writer.capacity();\n+    /// // Calculate how many bytes can be written without flushing\n+    /// let without_flush = capacity - buf_writer.buffer().len();\n+    /// ```\n+    #[stable(feature = \"buffered_io_capacity\", since = \"1.46.0\")]\n+    pub fn capacity(&self) -> usize {\n+        self.buf.capacity()\n+    }\n+\n+    /// Unwraps this `BufWriter<W>`, returning the underlying writer.\n+    ///\n+    /// The buffer is written out before returning the writer.\n+    ///\n+    /// # Errors\n+    ///\n+    /// An [`Err`] will be returned if an error occurs while flushing the buffer.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::io::BufWriter;\n+    /// use std::net::TcpStream;\n+    ///\n+    /// let mut buffer = BufWriter::new(TcpStream::connect(\"127.0.0.1:34254\").unwrap());\n+    ///\n+    /// // unwrap the TcpStream and flush the buffer\n+    /// let stream = buffer.into_inner().unwrap();\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn into_inner(mut self) -> Result<W, IntoInnerError<BufWriter<W>>> {\n+        match self.flush_buf() {\n+            Err(e) => Err(IntoInnerError::new(self, e)),\n+            Ok(()) => Ok(self.inner.take().unwrap()),\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<W: Write> Write for BufWriter<W> {\n+    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n+        if self.buf.len() + buf.len() > self.buf.capacity() {\n+            self.flush_buf()?;\n+        }\n+        // FIXME: Why no len > capacity? Why not buffer len == capacity? #72919\n+        if buf.len() >= self.buf.capacity() {\n+            self.panicked = true;\n+            let r = self.get_mut().write(buf);\n+            self.panicked = false;\n+            r\n+        } else {\n+            self.buf.extend_from_slice(buf);\n+            Ok(buf.len())\n+        }\n+    }\n+\n+    fn write_all(&mut self, buf: &[u8]) -> io::Result<()> {\n+        // Normally, `write_all` just calls `write` in a loop. We can do better\n+        // by calling `self.get_mut().write_all()` directly, which avoids\n+        // round trips through the buffer in the event of a series of partial\n+        // writes in some circumstances.\n+        if self.buf.len() + buf.len() > self.buf.capacity() {\n+            self.flush_buf()?;\n+        }\n+        // FIXME: Why no len > capacity? Why not buffer len == capacity? #72919\n+        if buf.len() >= self.buf.capacity() {\n+            self.panicked = true;\n+            let r = self.get_mut().write_all(buf);\n+            self.panicked = false;\n+            r\n+        } else {\n+            self.buf.extend_from_slice(buf);\n+            Ok(())\n+        }\n+    }\n+\n+    fn write_vectored(&mut self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n+        let total_len = bufs.iter().map(|b| b.len()).sum::<usize>();\n+        if self.buf.len() + total_len > self.buf.capacity() {\n+            self.flush_buf()?;\n+        }\n+        // FIXME: Why no len > capacity? Why not buffer len == capacity? #72919\n+        if total_len >= self.buf.capacity() {\n+            self.panicked = true;\n+            let r = self.get_mut().write_vectored(bufs);\n+            self.panicked = false;\n+            r\n+        } else {\n+            bufs.iter().for_each(|b| self.buf.extend_from_slice(b));\n+            Ok(total_len)\n+        }\n+    }\n+\n+    fn is_write_vectored(&self) -> bool {\n+        self.get_ref().is_write_vectored()\n+    }\n+\n+    fn flush(&mut self) -> io::Result<()> {\n+        self.flush_buf().and_then(|()| self.get_mut().flush())\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<W: Write> fmt::Debug for BufWriter<W>\n+where\n+    W: fmt::Debug,\n+{\n+    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        fmt.debug_struct(\"BufWriter\")\n+            .field(\"writer\", &self.inner.as_ref().unwrap())\n+            .field(\"buffer\", &format_args!(\"{}/{}\", self.buf.len(), self.buf.capacity()))\n+            .finish()\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<W: Write + Seek> Seek for BufWriter<W> {\n+    /// Seek to the offset, in bytes, in the underlying writer.\n+    ///\n+    /// Seeking always writes out the internal buffer before seeking.\n+    fn seek(&mut self, pos: SeekFrom) -> io::Result<u64> {\n+        self.flush_buf()?;\n+        self.get_mut().seek(pos)\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<W: Write> Drop for BufWriter<W> {\n+    fn drop(&mut self) {\n+        if self.inner.is_some() && !self.panicked {\n+            // dtors should not panic, so we ignore a failed flush\n+            let _r = self.flush_buf();\n+        }\n+    }\n+}"}, {"sha": "502c6e3c6c0b95295ad8be675ffb948e5e552fbf", "filename": "library/std/src/io/buffered/linewriter.rs", "status": "added", "additions": 232, "deletions": 0, "changes": 232, "blob_url": "https://github.com/rust-lang/rust/blob/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Flinewriter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Flinewriter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Flinewriter.rs?ref=b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7", "patch": "@@ -0,0 +1,232 @@\n+use crate::fmt;\n+use crate::io::{self, buffered::LineWriterShim, BufWriter, IntoInnerError, IoSlice, Write};\n+\n+/// Wraps a writer and buffers output to it, flushing whenever a newline\n+/// (`0x0a`, `'\\n'`) is detected.\n+///\n+/// The [`BufWriter`] struct wraps a writer and buffers its output.\n+/// But it only does this batched write when it goes out of scope, or when the\n+/// internal buffer is full. Sometimes, you'd prefer to write each line as it's\n+/// completed, rather than the entire buffer at once. Enter `LineWriter`. It\n+/// does exactly that.\n+///\n+/// Like [`BufWriter`], a `LineWriter`\u2019s buffer will also be flushed when the\n+/// `LineWriter` goes out of scope or when its internal buffer is full.\n+///\n+/// If there's still a partial line in the buffer when the `LineWriter` is\n+/// dropped, it will flush those contents.\n+///\n+/// # Examples\n+///\n+/// We can use `LineWriter` to write one line at a time, significantly\n+/// reducing the number of actual writes to the file.\n+///\n+/// ```no_run\n+/// use std::fs::{self, File};\n+/// use std::io::prelude::*;\n+/// use std::io::LineWriter;\n+///\n+/// fn main() -> std::io::Result<()> {\n+///     let road_not_taken = b\"I shall be telling this with a sigh\n+/// Somewhere ages and ages hence:\n+/// Two roads diverged in a wood, and I -\n+/// I took the one less traveled by,\n+/// And that has made all the difference.\";\n+///\n+///     let file = File::create(\"poem.txt\")?;\n+///     let mut file = LineWriter::new(file);\n+///\n+///     file.write_all(b\"I shall be telling this with a sigh\")?;\n+///\n+///     // No bytes are written until a newline is encountered (or\n+///     // the internal buffer is filled).\n+///     assert_eq!(fs::read_to_string(\"poem.txt\")?, \"\");\n+///     file.write_all(b\"\\n\")?;\n+///     assert_eq!(\n+///         fs::read_to_string(\"poem.txt\")?,\n+///         \"I shall be telling this with a sigh\\n\",\n+///     );\n+///\n+///     // Write the rest of the poem.\n+///     file.write_all(b\"Somewhere ages and ages hence:\n+/// Two roads diverged in a wood, and I -\n+/// I took the one less traveled by,\n+/// And that has made all the difference.\")?;\n+///\n+///     // The last line of the poem doesn't end in a newline, so\n+///     // we have to flush or drop the `LineWriter` to finish\n+///     // writing.\n+///     file.flush()?;\n+///\n+///     // Confirm the whole poem was written.\n+///     assert_eq!(fs::read(\"poem.txt\")?, &road_not_taken[..]);\n+///     Ok(())\n+/// }\n+/// ```\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct LineWriter<W: Write> {\n+    inner: BufWriter<W>,\n+}\n+\n+impl<W: Write> LineWriter<W> {\n+    /// Creates a new `LineWriter`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::fs::File;\n+    /// use std::io::LineWriter;\n+    ///\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let file = File::create(\"poem.txt\")?;\n+    ///     let file = LineWriter::new(file);\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn new(inner: W) -> LineWriter<W> {\n+        // Lines typically aren't that long, don't use a giant buffer\n+        LineWriter::with_capacity(1024, inner)\n+    }\n+\n+    /// Creates a new `LineWriter` with a specified capacity for the internal\n+    /// buffer.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::fs::File;\n+    /// use std::io::LineWriter;\n+    ///\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let file = File::create(\"poem.txt\")?;\n+    ///     let file = LineWriter::with_capacity(100, file);\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn with_capacity(capacity: usize, inner: W) -> LineWriter<W> {\n+        LineWriter { inner: BufWriter::with_capacity(capacity, inner) }\n+    }\n+\n+    /// Gets a reference to the underlying writer.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::fs::File;\n+    /// use std::io::LineWriter;\n+    ///\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let file = File::create(\"poem.txt\")?;\n+    ///     let file = LineWriter::new(file);\n+    ///\n+    ///     let reference = file.get_ref();\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn get_ref(&self) -> &W {\n+        self.inner.get_ref()\n+    }\n+\n+    /// Gets a mutable reference to the underlying writer.\n+    ///\n+    /// Caution must be taken when calling methods on the mutable reference\n+    /// returned as extra writes could corrupt the output stream.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::fs::File;\n+    /// use std::io::LineWriter;\n+    ///\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let file = File::create(\"poem.txt\")?;\n+    ///     let mut file = LineWriter::new(file);\n+    ///\n+    ///     // we can use reference just like file\n+    ///     let reference = file.get_mut();\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn get_mut(&mut self) -> &mut W {\n+        self.inner.get_mut()\n+    }\n+\n+    /// Unwraps this `LineWriter`, returning the underlying writer.\n+    ///\n+    /// The internal buffer is written out before returning the writer.\n+    ///\n+    /// # Errors\n+    ///\n+    /// An [`Err`] will be returned if an error occurs while flushing the buffer.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::fs::File;\n+    /// use std::io::LineWriter;\n+    ///\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let file = File::create(\"poem.txt\")?;\n+    ///\n+    ///     let writer: LineWriter<File> = LineWriter::new(file);\n+    ///\n+    ///     let file: File = writer.into_inner()?;\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn into_inner(self) -> Result<W, IntoInnerError<LineWriter<W>>> {\n+        self.inner.into_inner().map_err(|err| err.new_wrapped(|inner| LineWriter { inner }))\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<W: Write> Write for LineWriter<W> {\n+    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n+        LineWriterShim::new(&mut self.inner).write(buf)\n+    }\n+\n+    fn flush(&mut self) -> io::Result<()> {\n+        self.inner.flush()\n+    }\n+\n+    fn write_vectored(&mut self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n+        LineWriterShim::new(&mut self.inner).write_vectored(bufs)\n+    }\n+\n+    fn is_write_vectored(&self) -> bool {\n+        self.inner.is_write_vectored()\n+    }\n+\n+    fn write_all(&mut self, buf: &[u8]) -> io::Result<()> {\n+        LineWriterShim::new(&mut self.inner).write_all(buf)\n+    }\n+\n+    fn write_all_vectored(&mut self, bufs: &mut [IoSlice<'_>]) -> io::Result<()> {\n+        LineWriterShim::new(&mut self.inner).write_all_vectored(bufs)\n+    }\n+\n+    fn write_fmt(&mut self, fmt: fmt::Arguments<'_>) -> io::Result<()> {\n+        LineWriterShim::new(&mut self.inner).write_fmt(fmt)\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<W: Write> fmt::Debug for LineWriter<W>\n+where\n+    W: fmt::Debug,\n+{\n+    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        fmt.debug_struct(\"LineWriter\")\n+            .field(\"writer\", &self.get_ref())\n+            .field(\n+                \"buffer\",\n+                &format_args!(\"{}/{}\", self.inner.buffer().len(), self.inner.capacity()),\n+            )\n+            .finish()\n+    }\n+}"}, {"sha": "a80d08db8692e32591a07342faf5442269d8cada", "filename": "library/std/src/io/buffered/linewritershim.rs", "status": "added", "additions": 270, "deletions": 0, "changes": 270, "blob_url": "https://github.com/rust-lang/rust/blob/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Flinewritershim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Flinewritershim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Flinewritershim.rs?ref=b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7", "patch": "@@ -0,0 +1,270 @@\n+use crate::io::{self, BufWriter, IoSlice, Write};\n+use crate::memchr;\n+\n+/// Private helper struct for implementing the line-buffered writing logic.\n+/// This shim temporarily wraps a BufWriter, and uses its internals to\n+/// implement a line-buffered writer (specifically by using the internal\n+/// methods like write_to_buf and flush_buf). In this way, a more\n+/// efficient abstraction can be created than one that only had access to\n+/// `write` and `flush`, without needlessly duplicating a lot of the\n+/// implementation details of BufWriter. This also allows existing\n+/// `BufWriters` to be temporarily given line-buffering logic; this is what\n+/// enables Stdout to be alternately in line-buffered or block-buffered mode.\n+#[derive(Debug)]\n+pub struct LineWriterShim<'a, W: Write> {\n+    buffer: &'a mut BufWriter<W>,\n+}\n+\n+impl<'a, W: Write> LineWriterShim<'a, W> {\n+    pub fn new(buffer: &'a mut BufWriter<W>) -> Self {\n+        Self { buffer }\n+    }\n+\n+    /// Get a mutable reference to the inner writer (that is, the writer\n+    /// wrapped by the BufWriter). Be careful with this writer, as writes to\n+    /// it will bypass the buffer.\n+    fn inner_mut(&mut self) -> &mut W {\n+        self.buffer.get_mut()\n+    }\n+\n+    /// Get the content currently buffered in self.buffer\n+    fn buffered(&self) -> &[u8] {\n+        self.buffer.buffer()\n+    }\n+\n+    /// Flush the buffer iff the last byte is a newline (indicating that an\n+    /// earlier write only succeeded partially, and we want to retry flushing\n+    /// the buffered line before continuing with a subsequent write)\n+    fn flush_if_completed_line(&mut self) -> io::Result<()> {\n+        match self.buffered().last().copied() {\n+            Some(b'\\n') => self.buffer.flush_buf(),\n+            _ => Ok(()),\n+        }\n+    }\n+}\n+\n+impl<'a, W: Write> Write for LineWriterShim<'a, W> {\n+    /// Write some data into this BufReader with line buffering. This means\n+    /// that, if any newlines are present in the data, the data up to the last\n+    /// newline is sent directly to the underlying writer, and data after it\n+    /// is buffered. Returns the number of bytes written.\n+    ///\n+    /// This function operates on a \"best effort basis\"; in keeping with the\n+    /// convention of `Write::write`, it makes at most one attempt to write\n+    /// new data to the underlying writer. If that write only reports a partial\n+    /// success, the remaining data will be buffered.\n+    ///\n+    /// Because this function attempts to send completed lines to the underlying\n+    /// writer, it will also flush the existing buffer if it ends with a\n+    /// newline, even if the incoming data does not contain any newlines.\n+    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n+        let newline_idx = match memchr::memrchr(b'\\n', buf) {\n+            // If there are no new newlines (that is, if this write is less than\n+            // one line), just do a regular buffered write (which may flush if\n+            // we exceed the inner buffer's size)\n+            None => {\n+                self.flush_if_completed_line()?;\n+                return self.buffer.write(buf);\n+            }\n+            // Otherwise, arrange for the lines to be written directly to the\n+            // inner writer.\n+            Some(newline_idx) => newline_idx + 1,\n+        };\n+\n+        // Flush existing content to prepare for our write. We have to do this\n+        // before attempting to write `buf` in order to maintain consistency;\n+        // if we add `buf` to the buffer then try to flush it all at once,\n+        // we're obligated to return Ok(), which would mean suppressing any\n+        // errors that occur during flush.\n+        self.buffer.flush_buf()?;\n+\n+        // This is what we're going to try to write directly to the inner\n+        // writer. The rest will be buffered, if nothing goes wrong.\n+        let lines = &buf[..newline_idx];\n+\n+        // Write `lines` directly to the inner writer. In keeping with the\n+        // `write` convention, make at most one attempt to add new (unbuffered)\n+        // data. Because this write doesn't touch the BufWriter state directly,\n+        // and the buffer is known to be empty, we don't need to worry about\n+        // self.buffer.panicked here.\n+        let flushed = self.inner_mut().write(lines)?;\n+\n+        // If buffer returns Ok(0), propagate that to the caller without\n+        // doing additional buffering; otherwise we're just guaranteeing\n+        // an \"ErrorKind::WriteZero\" later.\n+        if flushed == 0 {\n+            return Ok(0);\n+        }\n+\n+        // Now that the write has succeeded, buffer the rest (or as much of\n+        // the rest as possible). If there were any unwritten newlines, we\n+        // only buffer out to the last unwritten newline that fits in the\n+        // buffer; this helps prevent flushing partial lines on subsequent\n+        // calls to LineWriterShim::write.\n+\n+        // Handle the cases in order of most-common to least-common, under\n+        // the presumption that most writes succeed in totality, and that most\n+        // writes are smaller than the buffer.\n+        // - Is this a partial line (ie, no newlines left in the unwritten tail)\n+        // - If not, does the data out to the last unwritten newline fit in\n+        //   the buffer?\n+        // - If not, scan for the last newline that *does* fit in the buffer\n+        let tail = if flushed >= newline_idx {\n+            &buf[flushed..]\n+        } else if newline_idx - flushed <= self.buffer.capacity() {\n+            &buf[flushed..newline_idx]\n+        } else {\n+            let scan_area = &buf[flushed..];\n+            let scan_area = &scan_area[..self.buffer.capacity()];\n+            match memchr::memrchr(b'\\n', scan_area) {\n+                Some(newline_idx) => &scan_area[..newline_idx + 1],\n+                None => scan_area,\n+            }\n+        };\n+\n+        let buffered = self.buffer.write_to_buf(tail);\n+        Ok(flushed + buffered)\n+    }\n+\n+    fn flush(&mut self) -> io::Result<()> {\n+        self.buffer.flush()\n+    }\n+\n+    /// Write some vectored data into this BufReader with line buffering. This\n+    /// means that, if any newlines are present in the data, the data up to\n+    /// and including the buffer containing the last newline is sent directly\n+    /// to the inner writer, and the data after it is buffered. Returns the\n+    /// number of bytes written.\n+    ///\n+    /// This function operates on a \"best effort basis\"; in keeping with the\n+    /// convention of `Write::write`, it makes at most one attempt to write\n+    /// new data to the underlying writer.\n+    ///\n+    /// Because this function attempts to send completed lines to the underlying\n+    /// writer, it will also flush the existing buffer if it contains any\n+    /// newlines.\n+    ///\n+    /// Because sorting through an array of `IoSlice` can be a bit convoluted,\n+    /// This method differs from write in the following ways:\n+    ///\n+    /// - It attempts to write the full content of all the buffers up to and\n+    ///   including the one containing the last newline. This means that it\n+    ///   may attempt to write a partial line, that buffer has data past the\n+    ///   newline.\n+    /// - If the write only reports partial success, it does not attempt to\n+    ///   find the precise location of the written bytes and buffer the rest.\n+    ///\n+    /// If the underlying vector doesn't support vectored writing, we instead\n+    /// simply write the first non-empty buffer with `write`. This way, we\n+    /// get the benefits of more granular partial-line handling without losing\n+    /// anything in efficiency\n+    fn write_vectored(&mut self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n+        // If there's no specialized behavior for write_vectored, just use\n+        // write. This has the benefit of more granular partial-line handling.\n+        if !self.is_write_vectored() {\n+            return match bufs.iter().find(|buf| !buf.is_empty()) {\n+                Some(buf) => self.write(buf),\n+                None => Ok(0),\n+            };\n+        }\n+\n+        // Find the buffer containing the last newline\n+        let last_newline_buf_idx = bufs\n+            .iter()\n+            .enumerate()\n+            .rev()\n+            .find_map(|(i, buf)| memchr::memchr(b'\\n', buf).map(|_| i));\n+\n+        // If there are no new newlines (that is, if this write is less than\n+        // one line), just do a regular buffered write\n+        let last_newline_buf_idx = match last_newline_buf_idx {\n+            // No newlines; just do a normal buffered write\n+            None => {\n+                self.flush_if_completed_line()?;\n+                return self.buffer.write_vectored(bufs);\n+            }\n+            Some(i) => i,\n+        };\n+\n+        // Flush existing content to prepare for our write\n+        self.buffer.flush_buf()?;\n+\n+        // This is what we're going to try to write directly to the inner\n+        // writer. The rest will be buffered, if nothing goes wrong.\n+        let (lines, tail) = bufs.split_at(last_newline_buf_idx + 1);\n+\n+        // Write `lines` directly to the inner writer. In keeping with the\n+        // `write` convention, make at most one attempt to add new (unbuffered)\n+        // data. Because this write doesn't touch the BufWriter state directly,\n+        // and the buffer is known to be empty, we don't need to worry about\n+        // self.panicked here.\n+        let flushed = self.inner_mut().write_vectored(lines)?;\n+\n+        // If inner returns Ok(0), propagate that to the caller without\n+        // doing additional buffering; otherwise we're just guaranteeing\n+        // an \"ErrorKind::WriteZero\" later.\n+        if flushed == 0 {\n+            return Ok(0);\n+        }\n+\n+        // Don't try to reconstruct the exact amount written; just bail\n+        // in the event of a partial write\n+        let lines_len = lines.iter().map(|buf| buf.len()).sum();\n+        if flushed < lines_len {\n+            return Ok(flushed);\n+        }\n+\n+        // Now that the write has succeeded, buffer the rest (or as much of the\n+        // rest as possible)\n+        let buffered: usize = tail\n+            .iter()\n+            .filter(|buf| !buf.is_empty())\n+            .map(|buf| self.buffer.write_to_buf(buf))\n+            .take_while(|&n| n > 0)\n+            .sum();\n+\n+        Ok(flushed + buffered)\n+    }\n+\n+    fn is_write_vectored(&self) -> bool {\n+        self.buffer.is_write_vectored()\n+    }\n+\n+    /// Write some data into this BufReader with line buffering. This means\n+    /// that, if any newlines are present in the data, the data up to the last\n+    /// newline is sent directly to the underlying writer, and data after it\n+    /// is buffered.\n+    ///\n+    /// Because this function attempts to send completed lines to the underlying\n+    /// writer, it will also flush the existing buffer if it contains any\n+    /// newlines, even if the incoming data does not contain any newlines.\n+    fn write_all(&mut self, buf: &[u8]) -> io::Result<()> {\n+        match memchr::memrchr(b'\\n', buf) {\n+            // If there are no new newlines (that is, if this write is less than\n+            // one line), just do a regular buffered write (which may flush if\n+            // we exceed the inner buffer's size)\n+            None => {\n+                self.flush_if_completed_line()?;\n+                self.buffer.write_all(buf)\n+            }\n+            Some(newline_idx) => {\n+                let (lines, tail) = buf.split_at(newline_idx + 1);\n+\n+                if self.buffered().is_empty() {\n+                    self.inner_mut().write_all(lines)?;\n+                } else {\n+                    // If there is any buffered data, we add the incoming lines\n+                    // to that buffer before flushing, which saves us at least\n+                    // one write call. We can't really do this with `write`,\n+                    // since we can't do this *and* not suppress errors *and*\n+                    // report a consistent state to the caller in a return\n+                    // value, but here in write_all it's fine.\n+                    self.buffer.write_all(lines)?;\n+                    self.buffer.flush_buf()?;\n+                }\n+\n+                self.buffer.write_all(tail)\n+            }\n+        }\n+    }\n+}"}, {"sha": "f9caeaf98e2fb8f1b55f54d0719e180acab54c85", "filename": "library/std/src/io/buffered/mod.rs", "status": "added", "additions": 151, "deletions": 0, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Fmod.rs?ref=b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7", "patch": "@@ -0,0 +1,151 @@\n+//! Buffering wrappers for I/O traits\n+\n+mod bufreader;\n+mod bufwriter;\n+mod linewriter;\n+mod linewritershim;\n+\n+#[cfg(test)]\n+mod tests;\n+\n+use crate::error;\n+use crate::fmt;\n+use crate::io::Error;\n+\n+pub use bufreader::BufReader;\n+pub use bufwriter::BufWriter;\n+pub use linewriter::LineWriter;\n+use linewritershim::LineWriterShim;\n+\n+/// An error returned by [`BufWriter::into_inner`] which combines an error that\n+/// happened while writing out the buffer, and the buffered writer object\n+/// which may be used to recover from the condition.\n+///\n+/// # Examples\n+///\n+/// ```no_run\n+/// use std::io::BufWriter;\n+/// use std::net::TcpStream;\n+///\n+/// let mut stream = BufWriter::new(TcpStream::connect(\"127.0.0.1:34254\").unwrap());\n+///\n+/// // do stuff with the stream\n+///\n+/// // we want to get our `TcpStream` back, so let's try:\n+///\n+/// let stream = match stream.into_inner() {\n+///     Ok(s) => s,\n+///     Err(e) => {\n+///         // Here, e is an IntoInnerError\n+///         panic!(\"An error occurred\");\n+///     }\n+/// };\n+/// ```\n+#[derive(Debug)]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct IntoInnerError<W>(W, Error);\n+\n+impl<W> IntoInnerError<W> {\n+    /// Construct a new IntoInnerError\n+    fn new(writer: W, error: Error) -> Self {\n+        Self(writer, error)\n+    }\n+\n+    /// Helper to construct a new IntoInnerError; intended to help with\n+    /// adapters that wrap other adapters\n+    fn new_wrapped<W2>(self, f: impl FnOnce(W) -> W2) -> IntoInnerError<W2> {\n+        let Self(writer, error) = self;\n+        IntoInnerError::new(f(writer), error)\n+    }\n+\n+    /// Returns the error which caused the call to [`BufWriter::into_inner()`]\n+    /// to fail.\n+    ///\n+    /// This error was returned when attempting to write the internal buffer.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::io::BufWriter;\n+    /// use std::net::TcpStream;\n+    ///\n+    /// let mut stream = BufWriter::new(TcpStream::connect(\"127.0.0.1:34254\").unwrap());\n+    ///\n+    /// // do stuff with the stream\n+    ///\n+    /// // we want to get our `TcpStream` back, so let's try:\n+    ///\n+    /// let stream = match stream.into_inner() {\n+    ///     Ok(s) => s,\n+    ///     Err(e) => {\n+    ///         // Here, e is an IntoInnerError, let's log the inner error.\n+    ///         //\n+    ///         // We'll just 'log' to stdout for this example.\n+    ///         println!(\"{}\", e.error());\n+    ///\n+    ///         panic!(\"An unexpected error occurred.\");\n+    ///     }\n+    /// };\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn error(&self) -> &Error {\n+        &self.1\n+    }\n+\n+    /// Returns the buffered writer instance which generated the error.\n+    ///\n+    /// The returned object can be used for error recovery, such as\n+    /// re-inspecting the buffer.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::io::BufWriter;\n+    /// use std::net::TcpStream;\n+    ///\n+    /// let mut stream = BufWriter::new(TcpStream::connect(\"127.0.0.1:34254\").unwrap());\n+    ///\n+    /// // do stuff with the stream\n+    ///\n+    /// // we want to get our `TcpStream` back, so let's try:\n+    ///\n+    /// let stream = match stream.into_inner() {\n+    ///     Ok(s) => s,\n+    ///     Err(e) => {\n+    ///         // Here, e is an IntoInnerError, let's re-examine the buffer:\n+    ///         let buffer = e.into_inner();\n+    ///\n+    ///         // do stuff to try to recover\n+    ///\n+    ///         // afterwards, let's just return the stream\n+    ///         buffer.into_inner().unwrap()\n+    ///     }\n+    /// };\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn into_inner(self) -> W {\n+        self.0\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<W> From<IntoInnerError<W>> for Error {\n+    fn from(iie: IntoInnerError<W>) -> Error {\n+        iie.1\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<W: Send + fmt::Debug> error::Error for IntoInnerError<W> {\n+    #[allow(deprecated, deprecated_in_future)]\n+    fn description(&self) -> &str {\n+        error::Error::description(self.error())\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<W> fmt::Display for IntoInnerError<W> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        self.error().fmt(f)\n+    }\n+}"}, {"sha": "f09bc01701b748addda915e81d794bb3130bcb59", "filename": "library/std/src/sys/cloudabi/condvar.rs", "status": "modified", "additions": 18, "deletions": 23, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/library%2Fstd%2Fsrc%2Fsys%2Fcloudabi%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/library%2Fstd%2Fsrc%2Fsys%2Fcloudabi%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fcloudabi%2Fcondvar.rs?ref=b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7", "patch": "@@ -1,4 +1,3 @@\n-use crate::cell::UnsafeCell;\n use crate::mem;\n use crate::sync::atomic::{AtomicU32, Ordering};\n use crate::sys::cloudabi::abi;\n@@ -12,37 +11,36 @@ extern \"C\" {\n }\n \n pub struct Condvar {\n-    condvar: UnsafeCell<AtomicU32>,\n+    condvar: AtomicU32,\n }\n \n pub type MovableCondvar = Condvar;\n \n unsafe impl Send for Condvar {}\n unsafe impl Sync for Condvar {}\n \n-const NEW: Condvar =\n-    Condvar { condvar: UnsafeCell::new(AtomicU32::new(abi::CONDVAR_HAS_NO_WAITERS.0)) };\n-\n impl Condvar {\n     pub const fn new() -> Condvar {\n-        NEW\n+        Condvar { condvar: AtomicU32::new(abi::CONDVAR_HAS_NO_WAITERS.0) }\n     }\n \n     pub unsafe fn init(&mut self) {}\n \n     pub unsafe fn notify_one(&self) {\n-        let condvar = self.condvar.get();\n-        if (*condvar).load(Ordering::Relaxed) != abi::CONDVAR_HAS_NO_WAITERS.0 {\n-            let ret = abi::condvar_signal(condvar as *mut abi::condvar, abi::scope::PRIVATE, 1);\n+        if self.condvar.load(Ordering::Relaxed) != abi::CONDVAR_HAS_NO_WAITERS.0 {\n+            let ret = abi::condvar_signal(\n+                &self.condvar as *const AtomicU32 as *mut abi::condvar,\n+                abi::scope::PRIVATE,\n+                1,\n+            );\n             assert_eq!(ret, abi::errno::SUCCESS, \"Failed to signal on condition variable\");\n         }\n     }\n \n     pub unsafe fn notify_all(&self) {\n-        let condvar = self.condvar.get();\n-        if (*condvar).load(Ordering::Relaxed) != abi::CONDVAR_HAS_NO_WAITERS.0 {\n+        if self.condvar.load(Ordering::Relaxed) != abi::CONDVAR_HAS_NO_WAITERS.0 {\n             let ret = abi::condvar_signal(\n-                condvar as *mut abi::condvar,\n+                &self.condvar as *const AtomicU32 as *mut abi::condvar,\n                 abi::scope::PRIVATE,\n                 abi::nthreads::MAX,\n             );\n@@ -53,20 +51,19 @@ impl Condvar {\n     pub unsafe fn wait(&self, mutex: &Mutex) {\n         let mutex = mutex::raw(mutex);\n         assert_eq!(\n-            (*mutex).load(Ordering::Relaxed) & !abi::LOCK_KERNEL_MANAGED.0,\n+            mutex.load(Ordering::Relaxed) & !abi::LOCK_KERNEL_MANAGED.0,\n             __pthread_thread_id.0 | abi::LOCK_WRLOCKED.0,\n             \"This lock is not write-locked by this thread\"\n         );\n \n         // Call into the kernel to wait on the condition variable.\n-        let condvar = self.condvar.get();\n         let subscription = abi::subscription {\n             type_: abi::eventtype::CONDVAR,\n             union: abi::subscription_union {\n                 condvar: abi::subscription_condvar {\n-                    condvar: condvar as *mut abi::condvar,\n+                    condvar: &self.condvar as *const AtomicU32 as *mut abi::condvar,\n                     condvar_scope: abi::scope::PRIVATE,\n-                    lock: mutex as *mut abi::lock,\n+                    lock: mutex as *const AtomicU32 as *mut abi::lock,\n                     lock_scope: abi::scope::PRIVATE,\n                 },\n             },\n@@ -86,23 +83,22 @@ impl Condvar {\n     pub unsafe fn wait_timeout(&self, mutex: &Mutex, dur: Duration) -> bool {\n         let mutex = mutex::raw(mutex);\n         assert_eq!(\n-            (*mutex).load(Ordering::Relaxed) & !abi::LOCK_KERNEL_MANAGED.0,\n+            mutex.load(Ordering::Relaxed) & !abi::LOCK_KERNEL_MANAGED.0,\n             __pthread_thread_id.0 | abi::LOCK_WRLOCKED.0,\n             \"This lock is not write-locked by this thread\"\n         );\n \n         // Call into the kernel to wait on the condition variable.\n-        let condvar = self.condvar.get();\n         let timeout =\n             checked_dur2intervals(&dur).expect(\"overflow converting duration to nanoseconds\");\n         let subscriptions = [\n             abi::subscription {\n                 type_: abi::eventtype::CONDVAR,\n                 union: abi::subscription_union {\n                     condvar: abi::subscription_condvar {\n-                        condvar: condvar as *mut abi::condvar,\n+                        condvar: &self.condvar as *const AtomicU32 as *mut abi::condvar,\n                         condvar_scope: abi::scope::PRIVATE,\n-                        lock: mutex as *mut abi::lock,\n+                        lock: mutex as *const AtomicU32 as *mut abi::lock,\n                         lock_scope: abi::scope::PRIVATE,\n                     },\n                 },\n@@ -124,7 +120,7 @@ impl Condvar {\n         let mut nevents: mem::MaybeUninit<usize> = mem::MaybeUninit::uninit();\n         let ret = abi::poll(\n             subscriptions.as_ptr(),\n-            mem::MaybeUninit::first_ptr_mut(&mut events),\n+            mem::MaybeUninit::slice_as_mut_ptr(&mut events),\n             2,\n             nevents.as_mut_ptr(),\n         );\n@@ -144,9 +140,8 @@ impl Condvar {\n     }\n \n     pub unsafe fn destroy(&self) {\n-        let condvar = self.condvar.get();\n         assert_eq!(\n-            (*condvar).load(Ordering::Relaxed),\n+            self.condvar.load(Ordering::Relaxed),\n             abi::CONDVAR_HAS_NO_WAITERS.0,\n             \"Attempted to destroy a condition variable with blocked threads\"\n         );"}, {"sha": "1203d8de0c572617982342cfe526c94a22fc58fd", "filename": "library/std/src/sys/cloudabi/mutex.rs", "status": "modified", "additions": 25, "deletions": 29, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/library%2Fstd%2Fsrc%2Fsys%2Fcloudabi%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/library%2Fstd%2Fsrc%2Fsys%2Fcloudabi%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fcloudabi%2Fmutex.rs?ref=b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7", "patch": "@@ -1,4 +1,4 @@\n-use crate::cell::UnsafeCell;\n+use crate::cell::Cell;\n use crate::mem;\n use crate::mem::MaybeUninit;\n use crate::sync::atomic::{AtomicU32, Ordering};\n@@ -17,7 +17,7 @@ pub struct Mutex(RWLock);\n \n pub type MovableMutex = Mutex;\n \n-pub unsafe fn raw(m: &Mutex) -> *mut AtomicU32 {\n+pub unsafe fn raw(m: &Mutex) -> &AtomicU32 {\n     rwlock::raw(&m.0)\n }\n \n@@ -50,28 +50,23 @@ impl Mutex {\n }\n \n pub struct ReentrantMutex {\n-    lock: UnsafeCell<MaybeUninit<AtomicU32>>,\n-    recursion: UnsafeCell<MaybeUninit<u32>>,\n+    lock: AtomicU32,\n+    recursion: Cell<u32>,\n }\n \n+unsafe impl Send for ReentrantMutex {}\n+unsafe impl Sync for ReentrantMutex {}\n+\n impl ReentrantMutex {\n     pub const unsafe fn uninitialized() -> ReentrantMutex {\n-        ReentrantMutex {\n-            lock: UnsafeCell::new(MaybeUninit::uninit()),\n-            recursion: UnsafeCell::new(MaybeUninit::uninit()),\n-        }\n+        ReentrantMutex { lock: AtomicU32::new(abi::LOCK_UNLOCKED.0), recursion: Cell::new(0) }\n     }\n \n-    pub unsafe fn init(&self) {\n-        *self.lock.get() = MaybeUninit::new(AtomicU32::new(abi::LOCK_UNLOCKED.0));\n-        *self.recursion.get() = MaybeUninit::new(0);\n-    }\n+    pub unsafe fn init(&self) {}\n \n     pub unsafe fn try_lock(&self) -> bool {\n         // Attempt to acquire the lock.\n-        let lock = (*self.lock.get()).as_mut_ptr();\n-        let recursion = (*self.recursion.get()).as_mut_ptr();\n-        if let Err(old) = (*lock).compare_exchange(\n+        if let Err(old) = self.lock.compare_exchange(\n             abi::LOCK_UNLOCKED.0,\n             __pthread_thread_id.0 | abi::LOCK_WRLOCKED.0,\n             Ordering::Acquire,\n@@ -80,22 +75,22 @@ impl ReentrantMutex {\n             // If we fail to acquire the lock, it may be the case\n             // that we've already acquired it and may need to recurse.\n             if old & !abi::LOCK_KERNEL_MANAGED.0 == __pthread_thread_id.0 | abi::LOCK_WRLOCKED.0 {\n-                *recursion += 1;\n+                self.recursion.set(self.recursion.get() + 1);\n                 true\n             } else {\n                 false\n             }\n         } else {\n             // Success.\n-            assert_eq!(*recursion, 0, \"Mutex has invalid recursion count\");\n+            assert_eq!(self.recursion.get(), 0, \"Mutex has invalid recursion count\");\n             true\n         }\n     }\n \n     pub unsafe fn lock(&self) {\n         if !self.try_lock() {\n             // Call into the kernel to acquire a write lock.\n-            let lock = self.lock.get();\n+            let lock = &self.lock as *const AtomicU32;\n             let subscription = abi::subscription {\n                 type_: abi::eventtype::LOCK_WRLOCK,\n                 union: abi::subscription_union {\n@@ -116,17 +111,17 @@ impl ReentrantMutex {\n     }\n \n     pub unsafe fn unlock(&self) {\n-        let lock = (*self.lock.get()).as_mut_ptr();\n-        let recursion = (*self.recursion.get()).as_mut_ptr();\n         assert_eq!(\n-            (*lock).load(Ordering::Relaxed) & !abi::LOCK_KERNEL_MANAGED.0,\n+            self.lock.load(Ordering::Relaxed) & !abi::LOCK_KERNEL_MANAGED.0,\n             __pthread_thread_id.0 | abi::LOCK_WRLOCKED.0,\n             \"This mutex is locked by a different thread\"\n         );\n \n-        if *recursion > 0 {\n-            *recursion -= 1;\n-        } else if !(*lock)\n+        let r = self.recursion.get();\n+        if r > 0 {\n+            self.recursion.set(r - 1);\n+        } else if !self\n+            .lock\n             .compare_exchange(\n                 __pthread_thread_id.0 | abi::LOCK_WRLOCKED.0,\n                 abi::LOCK_UNLOCKED.0,\n@@ -137,19 +132,20 @@ impl ReentrantMutex {\n         {\n             // Lock is managed by kernelspace. Call into the kernel\n             // to unblock waiting threads.\n-            let ret = abi::lock_unlock(lock as *mut abi::lock, abi::scope::PRIVATE);\n+            let ret = abi::lock_unlock(\n+                &self.lock as *const AtomicU32 as *mut abi::lock,\n+                abi::scope::PRIVATE,\n+            );\n             assert_eq!(ret, abi::errno::SUCCESS, \"Failed to unlock a mutex\");\n         }\n     }\n \n     pub unsafe fn destroy(&self) {\n-        let lock = (*self.lock.get()).as_mut_ptr();\n-        let recursion = (*self.recursion.get()).as_mut_ptr();\n         assert_eq!(\n-            (*lock).load(Ordering::Relaxed),\n+            self.lock.load(Ordering::Relaxed),\n             abi::LOCK_UNLOCKED.0,\n             \"Attempted to destroy locked mutex\"\n         );\n-        assert_eq!(*recursion, 0, \"Recursion counter invalid\");\n+        assert_eq!(self.recursion.get(), 0, \"Recursion counter invalid\");\n     }\n }"}, {"sha": "508de8ba47c6e2632f48bbb7333bef08dbfcf5e4", "filename": "library/std/src/sys/cloudabi/rwlock.rs", "status": "modified", "additions": 22, "deletions": 25, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/library%2Fstd%2Fsrc%2Fsys%2Fcloudabi%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/library%2Fstd%2Fsrc%2Fsys%2Fcloudabi%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fcloudabi%2Frwlock.rs?ref=b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7", "patch": "@@ -1,4 +1,3 @@\n-use crate::cell::UnsafeCell;\n use crate::mem;\n use crate::mem::MaybeUninit;\n use crate::sync::atomic::{AtomicU32, Ordering};\n@@ -13,28 +12,25 @@ extern \"C\" {\n static mut RDLOCKS_ACQUIRED: u32 = 0;\n \n pub struct RWLock {\n-    lock: UnsafeCell<AtomicU32>,\n+    lock: AtomicU32,\n }\n \n-pub unsafe fn raw(r: &RWLock) -> *mut AtomicU32 {\n-    r.lock.get()\n+pub unsafe fn raw(r: &RWLock) -> &AtomicU32 {\n+    &r.lock\n }\n \n unsafe impl Send for RWLock {}\n unsafe impl Sync for RWLock {}\n \n-const NEW: RWLock = RWLock { lock: UnsafeCell::new(AtomicU32::new(abi::LOCK_UNLOCKED.0)) };\n-\n impl RWLock {\n     pub const fn new() -> RWLock {\n-        NEW\n+        RWLock { lock: AtomicU32::new(abi::LOCK_UNLOCKED.0) }\n     }\n \n     pub unsafe fn try_read(&self) -> bool {\n-        let lock = self.lock.get();\n         let mut old = abi::LOCK_UNLOCKED.0;\n         while let Err(cur) =\n-            (*lock).compare_exchange_weak(old, old + 1, Ordering::Acquire, Ordering::Relaxed)\n+            self.lock.compare_exchange_weak(old, old + 1, Ordering::Acquire, Ordering::Relaxed)\n         {\n             if (cur & abi::LOCK_WRLOCKED.0) != 0 {\n                 // Another thread already has a write lock.\n@@ -61,12 +57,11 @@ impl RWLock {\n     pub unsafe fn read(&self) {\n         if !self.try_read() {\n             // Call into the kernel to acquire a read lock.\n-            let lock = self.lock.get();\n             let subscription = abi::subscription {\n                 type_: abi::eventtype::LOCK_RDLOCK,\n                 union: abi::subscription_union {\n                     lock: abi::subscription_lock {\n-                        lock: lock as *mut abi::lock,\n+                        lock: &self.lock as *const AtomicU32 as *mut abi::lock,\n                         lock_scope: abi::scope::PRIVATE,\n                     },\n                 },\n@@ -96,11 +91,10 @@ impl RWLock {\n         assert!(RDLOCKS_ACQUIRED > 0, \"Bad lock count\");\n         let mut old = 1;\n         loop {\n-            let lock = self.lock.get();\n             if old == 1 | abi::LOCK_KERNEL_MANAGED.0 {\n                 // Last read lock while threads are waiting. Attempt to upgrade\n                 // to a write lock before calling into the kernel to unlock.\n-                if let Err(cur) = (*lock).compare_exchange_weak(\n+                if let Err(cur) = self.lock.compare_exchange_weak(\n                     old,\n                     __pthread_thread_id.0 | abi::LOCK_WRLOCKED.0 | abi::LOCK_KERNEL_MANAGED.0,\n                     Ordering::Acquire,\n@@ -109,7 +103,10 @@ impl RWLock {\n                     old = cur;\n                 } else {\n                     // Call into the kernel to unlock.\n-                    let ret = abi::lock_unlock(lock as *mut abi::lock, abi::scope::PRIVATE);\n+                    let ret = abi::lock_unlock(\n+                        &self.lock as *const AtomicU32 as *mut abi::lock,\n+                        abi::scope::PRIVATE,\n+                    );\n                     assert_eq!(ret, abi::errno::SUCCESS, \"Failed to write unlock a rwlock\");\n                     break;\n                 }\n@@ -122,7 +119,7 @@ impl RWLock {\n                     0,\n                     \"Attempted to read-unlock a write-locked rwlock\"\n                 );\n-                if let Err(cur) = (*lock).compare_exchange_weak(\n+                if let Err(cur) = self.lock.compare_exchange_weak(\n                     old,\n                     old - 1,\n                     Ordering::Acquire,\n@@ -140,8 +137,7 @@ impl RWLock {\n \n     pub unsafe fn try_write(&self) -> bool {\n         // Attempt to acquire the lock.\n-        let lock = self.lock.get();\n-        if let Err(old) = (*lock).compare_exchange(\n+        if let Err(old) = self.lock.compare_exchange(\n             abi::LOCK_UNLOCKED.0,\n             __pthread_thread_id.0 | abi::LOCK_WRLOCKED.0,\n             Ordering::Acquire,\n@@ -163,12 +159,11 @@ impl RWLock {\n     pub unsafe fn write(&self) {\n         if !self.try_write() {\n             // Call into the kernel to acquire a write lock.\n-            let lock = self.lock.get();\n             let subscription = abi::subscription {\n                 type_: abi::eventtype::LOCK_WRLOCK,\n                 union: abi::subscription_union {\n                     lock: abi::subscription_lock {\n-                        lock: lock as *mut abi::lock,\n+                        lock: &self.lock as *const AtomicU32 as *mut abi::lock,\n                         lock_scope: abi::scope::PRIVATE,\n                     },\n                 },\n@@ -184,14 +179,14 @@ impl RWLock {\n     }\n \n     pub unsafe fn write_unlock(&self) {\n-        let lock = self.lock.get();\n         assert_eq!(\n-            (*lock).load(Ordering::Relaxed) & !abi::LOCK_KERNEL_MANAGED.0,\n+            self.lock.load(Ordering::Relaxed) & !abi::LOCK_KERNEL_MANAGED.0,\n             __pthread_thread_id.0 | abi::LOCK_WRLOCKED.0,\n             \"This rwlock is not write-locked by this thread\"\n         );\n \n-        if !(*lock)\n+        if !self\n+            .lock\n             .compare_exchange(\n                 __pthread_thread_id.0 | abi::LOCK_WRLOCKED.0,\n                 abi::LOCK_UNLOCKED.0,\n@@ -202,15 +197,17 @@ impl RWLock {\n         {\n             // Lock is managed by kernelspace. Call into the kernel\n             // to unblock waiting threads.\n-            let ret = abi::lock_unlock(lock as *mut abi::lock, abi::scope::PRIVATE);\n+            let ret = abi::lock_unlock(\n+                &self.lock as *const AtomicU32 as *mut abi::lock,\n+                abi::scope::PRIVATE,\n+            );\n             assert_eq!(ret, abi::errno::SUCCESS, \"Failed to write unlock a rwlock\");\n         }\n     }\n \n     pub unsafe fn destroy(&self) {\n-        let lock = self.lock.get();\n         assert_eq!(\n-            (*lock).load(Ordering::Relaxed),\n+            self.lock.load(Ordering::Relaxed),\n             abi::LOCK_UNLOCKED.0,\n             \"Attempted to destroy locked rwlock\"\n         );"}, {"sha": "2392238d0a1943a9cc57b860465fab6d6d642b69", "filename": "library/std/src/sys/unix/os.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fos.rs?ref=b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7", "patch": "@@ -470,7 +470,7 @@ pub unsafe fn environ() -> *mut *const *const c_char {\n     &mut environ\n }\n \n-pub unsafe fn env_lock() -> StaticMutexGuard<'static> {\n+pub unsafe fn env_lock() -> StaticMutexGuard {\n     // It is UB to attempt to acquire this mutex reentrantly!\n     static ENV_LOCK: StaticMutex = StaticMutex::new();\n     ENV_LOCK.lock()"}, {"sha": "6eaec6f1e50df3054c6edf27313940285f6e9eca", "filename": "library/std/src/sys/vxworks/os.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fos.rs?ref=b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7", "patch": "@@ -212,7 +212,7 @@ pub unsafe fn environ() -> *mut *const *const c_char {\n     &mut environ\n }\n \n-pub unsafe fn env_lock() -> StaticMutexGuard<'static> {\n+pub unsafe fn env_lock() -> StaticMutexGuard {\n     // It is UB to attempt to acquire this mutex reentrantly!\n     static ENV_LOCK: StaticMutex = StaticMutex::new();\n     ENV_LOCK.lock()"}, {"sha": "3d8bf42f7255eec2b11660c02d5d082eb6a3e422", "filename": "library/std/src/sys/wasm/futex_atomics.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/library%2Fstd%2Fsrc%2Fsys%2Fwasm%2Ffutex_atomics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/library%2Fstd%2Fsrc%2Fsys%2Fwasm%2Ffutex_atomics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwasm%2Ffutex_atomics.rs?ref=b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7", "patch": "@@ -0,0 +1,17 @@\n+use crate::arch::wasm32;\n+use crate::convert::TryInto;\n+use crate::sync::atomic::AtomicI32;\n+use crate::time::Duration;\n+\n+pub fn futex_wait(futex: &AtomicI32, expected: i32, timeout: Option<Duration>) {\n+    let timeout = timeout.and_then(|t| t.as_nanos().try_into().ok()).unwrap_or(-1);\n+    unsafe {\n+        wasm32::memory_atomic_wait32(futex as *const AtomicI32 as *mut i32, expected, timeout);\n+    }\n+}\n+\n+pub fn futex_wake(futex: &AtomicI32) {\n+    unsafe {\n+        wasm32::memory_atomic_notify(futex as *const AtomicI32 as *mut i32, 1);\n+    }\n+}"}, {"sha": "11c6896f050b266ca6b0187871e03dce781a04b6", "filename": "library/std/src/sys/wasm/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/library%2Fstd%2Fsrc%2Fsys%2Fwasm%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/library%2Fstd%2Fsrc%2Fsys%2Fwasm%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwasm%2Fmod.rs?ref=b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7", "patch": "@@ -55,6 +55,8 @@ cfg_if::cfg_if! {\n         pub mod mutex;\n         #[path = \"rwlock_atomics.rs\"]\n         pub mod rwlock;\n+        #[path = \"futex_atomics.rs\"]\n+        pub mod futex;\n     } else {\n         #[path = \"../unsupported/condvar.rs\"]\n         pub mod condvar;"}, {"sha": "a549770d8b37823dd30112db435af4e2985a504d", "filename": "library/std/src/sys_common/backtrace.rs", "status": "modified", "additions": 5, "deletions": 17, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/library%2Fstd%2Fsrc%2Fsys_common%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/library%2Fstd%2Fsrc%2Fsys_common%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fbacktrace.rs?ref=b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7", "patch": "@@ -8,27 +8,15 @@ use crate::io;\n use crate::io::prelude::*;\n use crate::path::{self, Path, PathBuf};\n use crate::sync::atomic::{self, Ordering};\n-use crate::sys::mutex::Mutex;\n+use crate::sys_common::mutex::StaticMutex;\n \n /// Max number of frames to print.\n const MAX_NB_FRAMES: usize = 100;\n \n-pub fn lock() -> impl Drop {\n-    struct Guard;\n-    static LOCK: Mutex = Mutex::new();\n-\n-    impl Drop for Guard {\n-        fn drop(&mut self) {\n-            unsafe {\n-                LOCK.unlock();\n-            }\n-        }\n-    }\n-\n-    unsafe {\n-        LOCK.lock();\n-        Guard\n-    }\n+// SAFETY: Don't attempt to lock this reentrantly.\n+pub unsafe fn lock() -> impl Drop {\n+    static LOCK: StaticMutex = StaticMutex::new();\n+    LOCK.lock()\n }\n \n /// Prints the current backtrace."}, {"sha": "f3e7efb955a2fd65a9ba1906e53e848f10c9df4b", "filename": "library/std/src/sys_common/mutex.rs", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/library%2Fstd%2Fsrc%2Fsys_common%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/library%2Fstd%2Fsrc%2Fsys_common%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fmutex.rs?ref=b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7", "patch": "@@ -3,8 +3,7 @@ use crate::sys::mutex as imp;\n /// An OS-based mutual exclusion lock, meant for use in static variables.\n ///\n /// This mutex has a const constructor ([`StaticMutex::new`]), does not\n-/// implement `Drop` to cleanup resources, and causes UB when moved or used\n-/// reentrantly.\n+/// implement `Drop` to cleanup resources, and causes UB when used reentrantly.\n ///\n /// This mutex does not implement poisoning.\n ///\n@@ -16,31 +15,26 @@ unsafe impl Sync for StaticMutex {}\n \n impl StaticMutex {\n     /// Creates a new mutex for use.\n-    ///\n-    /// Behavior is undefined if the mutex is moved after it is\n-    /// first used with any of the functions below.\n-    /// Also, the behavior is undefined if this mutex is ever used reentrantly,\n-    /// i.e., `lock` is called by the thread currently holding the lock.\n     pub const fn new() -> Self {\n         Self(imp::Mutex::new())\n     }\n \n     /// Calls raw_lock() and then returns an RAII guard to guarantee the mutex\n     /// will be unlocked.\n     ///\n-    /// It is undefined behaviour to call this function while locked, or if the\n-    /// mutex has been moved since the last time this was called.\n+    /// It is undefined behaviour to call this function while locked by the\n+    /// same thread.\n     #[inline]\n-    pub unsafe fn lock(&self) -> StaticMutexGuard<'_> {\n+    pub unsafe fn lock(&'static self) -> StaticMutexGuard {\n         self.0.lock();\n         StaticMutexGuard(&self.0)\n     }\n }\n \n #[must_use]\n-pub struct StaticMutexGuard<'a>(&'a imp::Mutex);\n+pub struct StaticMutexGuard(&'static imp::Mutex);\n \n-impl Drop for StaticMutexGuard<'_> {\n+impl Drop for StaticMutexGuard {\n     #[inline]\n     fn drop(&mut self) {\n         unsafe {"}, {"sha": "5e75ac65de4199a95737f2021ec9e2af329b2d97", "filename": "library/std/src/sys_common/thread_parker/mod.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_parker%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_parker%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_parker%2Fmod.rs?ref=b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7", "patch": "@@ -1,5 +1,9 @@\n cfg_if::cfg_if! {\n-    if #[cfg(any(target_os = \"linux\", target_os = \"android\"))] {\n+    if #[cfg(any(\n+        target_os = \"linux\",\n+        target_os = \"android\",\n+        all(target_arch = \"wasm32\", target_feature = \"atomics\"),\n+    ))] {\n         mod futex;\n         pub use futex::Parker;\n     } else {"}, {"sha": "b659f3eab4318146b3a51c46f0862dcd4f7ea38e", "filename": "src/librustdoc/clean/cfg.rs", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/src%2Flibrustdoc%2Fclean%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/src%2Flibrustdoc%2Fclean%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fcfg.rs?ref=b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7", "patch": "@@ -201,6 +201,37 @@ impl Cfg {\n             _ => false,\n         }\n     }\n+\n+    /// Attempt to simplify this cfg by assuming that `assume` is already known to be true, will\n+    /// return `None` if simplification managed to completely eliminate any requirements from this\n+    /// `Cfg`.\n+    ///\n+    /// See `tests::test_simplify_with` for examples.\n+    pub(crate) fn simplify_with(&self, assume: &Cfg) -> Option<Cfg> {\n+        if self == assume {\n+            return None;\n+        }\n+\n+        if let Cfg::All(a) = self {\n+            let mut sub_cfgs: Vec<Cfg> = if let Cfg::All(b) = assume {\n+                a.iter().filter(|a| !b.contains(a)).cloned().collect()\n+            } else {\n+                a.iter().filter(|&a| a != assume).cloned().collect()\n+            };\n+            let len = sub_cfgs.len();\n+            return match len {\n+                0 => None,\n+                1 => sub_cfgs.pop(),\n+                _ => Some(Cfg::All(sub_cfgs)),\n+            };\n+        } else if let Cfg::All(b) = assume {\n+            if b.contains(self) {\n+                return None;\n+            }\n+        }\n+\n+        Some(self.clone())\n+    }\n }\n \n impl ops::Not for Cfg {"}, {"sha": "3a78269f19af0a5a59ad71953c4f45a7927330fe", "filename": "src/librustdoc/clean/cfg/tests.rs", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/src%2Flibrustdoc%2Fclean%2Fcfg%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/src%2Flibrustdoc%2Fclean%2Fcfg%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fcfg%2Ftests.rs?ref=b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7", "patch": "@@ -433,3 +433,39 @@ fn test_render_long_html() {\n         );\n     })\n }\n+\n+#[test]\n+fn test_simplify_with() {\n+    // This is a tiny subset of things that could be simplified, but it likely covers 90% of\n+    // real world usecases well.\n+    with_default_session_globals(|| {\n+        let foo = word_cfg(\"foo\");\n+        let bar = word_cfg(\"bar\");\n+        let baz = word_cfg(\"baz\");\n+        let quux = word_cfg(\"quux\");\n+\n+        let foobar = Cfg::All(vec![foo.clone(), bar.clone()]);\n+        let barbaz = Cfg::All(vec![bar.clone(), baz.clone()]);\n+        let foobarbaz = Cfg::All(vec![foo.clone(), bar.clone(), baz.clone()]);\n+        let bazquux = Cfg::All(vec![baz.clone(), quux.clone()]);\n+\n+        // Unrelated cfgs don't affect each other\n+        assert_eq!(foo.simplify_with(&bar).as_ref(), Some(&foo));\n+        assert_eq!(foobar.simplify_with(&bazquux).as_ref(), Some(&foobar));\n+\n+        // Identical cfgs are eliminated\n+        assert_eq!(foo.simplify_with(&foo), None);\n+        assert_eq!(foobar.simplify_with(&foobar), None);\n+\n+        // Multiple cfgs eliminate a single assumed cfg\n+        assert_eq!(foobar.simplify_with(&foo).as_ref(), Some(&bar));\n+        assert_eq!(foobar.simplify_with(&bar).as_ref(), Some(&foo));\n+\n+        // A single cfg is eliminated by multiple assumed cfg containing it\n+        assert_eq!(foo.simplify_with(&foobar), None);\n+\n+        // Multiple cfgs eliminate the matching subset of multiple assumed cfg\n+        assert_eq!(foobar.simplify_with(&barbaz).as_ref(), Some(&foo));\n+        assert_eq!(foobar.simplify_with(&foobarbaz), None);\n+    });\n+}"}, {"sha": "22ae7af617fc7b0f03d8133a953bf08899520eeb", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 71, "deletions": 33, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7", "patch": "@@ -1763,11 +1763,11 @@ crate fn shorten(s: String) -> String {\n     }\n }\n \n-fn document(w: &mut Buffer, cx: &Context, item: &clean::Item) {\n+fn document(w: &mut Buffer, cx: &Context, item: &clean::Item, parent: Option<&clean::Item>) {\n     if let Some(ref name) = item.name {\n         info!(\"Documenting {}\", name);\n     }\n-    document_stability(w, cx, item, false);\n+    document_stability(w, cx, item, false, parent);\n     document_full(w, item, cx, \"\", false);\n }\n \n@@ -1851,8 +1851,14 @@ fn document_full(w: &mut Buffer, item: &clean::Item, cx: &Context, prefix: &str,\n     }\n }\n \n-fn document_stability(w: &mut Buffer, cx: &Context, item: &clean::Item, is_hidden: bool) {\n-    let stabilities = short_stability(item, cx);\n+fn document_stability(\n+    w: &mut Buffer,\n+    cx: &Context,\n+    item: &clean::Item,\n+    is_hidden: bool,\n+    parent: Option<&clean::Item>,\n+) {\n+    let stabilities = short_stability(item, cx, parent);\n     if !stabilities.is_empty() {\n         write!(w, \"<div class='stability{}'>\", if is_hidden { \" hidden\" } else { \"\" });\n         for stability in stabilities {\n@@ -1952,7 +1958,7 @@ pub fn compare_names(mut lhs: &str, mut rhs: &str) -> Ordering {\n }\n \n fn item_module(w: &mut Buffer, cx: &Context, item: &clean::Item, items: &[clean::Item]) {\n-    document(w, cx, item);\n+    document(w, cx, item, None);\n \n     let mut indices = (0..items.len()).filter(|i| !items[*i].is_stripped()).collect::<Vec<usize>>();\n \n@@ -2111,7 +2117,7 @@ fn item_module(w: &mut Buffer, cx: &Context, item: &clean::Item, items: &[clean:\n                          <td class='docblock-short'>{stab_tags}{docs}</td>\\\n                      </tr>\",\n                     name = *myitem.name.as_ref().unwrap(),\n-                    stab_tags = stability_tags(myitem),\n+                    stab_tags = stability_tags(myitem, item),\n                     docs = MarkdownSummaryLine(doc_value, &myitem.links()).into_string(),\n                     class = myitem.type_(),\n                     add = add,\n@@ -2135,7 +2141,7 @@ fn item_module(w: &mut Buffer, cx: &Context, item: &clean::Item, items: &[clean:\n \n /// Render the stability and deprecation tags that are displayed in the item's summary at the\n /// module level.\n-fn stability_tags(item: &clean::Item) -> String {\n+fn stability_tags(item: &clean::Item, parent: &clean::Item) -> String {\n     let mut tags = String::new();\n \n     fn tag_html(class: &str, title: &str, contents: &str) -> String {\n@@ -2159,7 +2165,13 @@ fn stability_tags(item: &clean::Item) -> String {\n         tags += &tag_html(\"unstable\", \"\", \"Experimental\");\n     }\n \n-    if let Some(ref cfg) = item.attrs.cfg {\n+    let cfg = match (&item.attrs.cfg, parent.attrs.cfg.as_ref()) {\n+        (Some(cfg), Some(parent_cfg)) => cfg.simplify_with(parent_cfg),\n+        (cfg, _) => cfg.as_deref().cloned(),\n+    };\n+\n+    debug!(\"Portability {:?} - {:?} = {:?}\", item.attrs.cfg, parent.attrs.cfg, cfg);\n+    if let Some(ref cfg) = cfg {\n         tags += &tag_html(\"portability\", &cfg.render_long_plain(), &cfg.render_short_html());\n     }\n \n@@ -2168,7 +2180,7 @@ fn stability_tags(item: &clean::Item) -> String {\n \n /// Render the stability and/or deprecation warning that is displayed at the top of the item's\n /// documentation.\n-fn short_stability(item: &clean::Item, cx: &Context) -> Vec<String> {\n+fn short_stability(item: &clean::Item, cx: &Context, parent: Option<&clean::Item>) -> Vec<String> {\n     let mut stability = vec![];\n     let error_codes = cx.shared.codes;\n \n@@ -2243,7 +2255,18 @@ fn short_stability(item: &clean::Item, cx: &Context) -> Vec<String> {\n         stability.push(format!(\"<div class='stab unstable'>{}</div>\", message));\n     }\n \n-    if let Some(ref cfg) = item.attrs.cfg {\n+    let cfg = match (&item.attrs.cfg, parent.and_then(|p| p.attrs.cfg.as_ref())) {\n+        (Some(cfg), Some(parent_cfg)) => cfg.simplify_with(parent_cfg),\n+        (cfg, _) => cfg.as_deref().cloned(),\n+    };\n+\n+    debug!(\n+        \"Portability {:?} - {:?} = {:?}\",\n+        item.attrs.cfg,\n+        parent.and_then(|p| p.attrs.cfg.as_ref()),\n+        cfg\n+    );\n+    if let Some(cfg) = cfg {\n         stability.push(format!(\"<div class='stab portability'>{}</div>\", cfg.render_long_html()));\n     }\n \n@@ -2282,7 +2305,7 @@ fn item_constant(w: &mut Buffer, cx: &Context, it: &clean::Item, c: &clean::Cons\n     }\n \n     write!(w, \"</pre>\");\n-    document(w, cx, it)\n+    document(w, cx, it, None)\n }\n \n fn item_static(w: &mut Buffer, cx: &Context, it: &clean::Item, s: &clean::Static) {\n@@ -2296,7 +2319,7 @@ fn item_static(w: &mut Buffer, cx: &Context, it: &clean::Item, s: &clean::Static\n         name = it.name.as_ref().unwrap(),\n         typ = s.type_.print()\n     );\n-    document(w, cx, it)\n+    document(w, cx, it, None)\n }\n \n fn item_function(w: &mut Buffer, cx: &Context, it: &clean::Item, f: &clean::Function) {\n@@ -2329,7 +2352,7 @@ fn item_function(w: &mut Buffer, cx: &Context, it: &clean::Item, f: &clean::Func\n             .print(),\n         spotlight = spotlight_decl(&f.decl),\n     );\n-    document(w, cx, it)\n+    document(w, cx, it, None)\n }\n \n fn render_implementor(\n@@ -2354,6 +2377,7 @@ fn render_implementor(\n         w,\n         cx,\n         implementor,\n+        None,\n         AssocItemLink::Anchor(None),\n         RenderMode::Normal,\n         implementor.impl_item.stable_since().as_deref(),\n@@ -2383,6 +2407,7 @@ fn render_impls(\n                 &mut buffer,\n                 cx,\n                 i,\n+                Some(containing_item),\n                 assoc_link,\n                 RenderMode::Normal,\n                 containing_item.stable_since().as_deref(),\n@@ -2502,7 +2527,7 @@ fn item_trait(w: &mut Buffer, cx: &Context, it: &clean::Item, t: &clean::Trait,\n     });\n \n     // Trait documentation\n-    document(w, cx, it);\n+    document(w, cx, it, None);\n \n     fn write_small_section_header(w: &mut Buffer, id: &str, title: &str, extra_content: &str) {\n         write!(\n@@ -2520,14 +2545,15 @@ fn item_trait(w: &mut Buffer, cx: &Context, it: &clean::Item, t: &clean::Trait,\n \n     fn trait_item(w: &mut Buffer, cx: &Context, m: &clean::Item, t: &clean::Item) {\n         let name = m.name.as_ref().unwrap();\n+        info!(\"Documenting {} on {}\", name, t.name.as_deref().unwrap_or_default());\n         let item_type = m.type_();\n         let id = cx.derive_id(format!(\"{}.{}\", item_type, name));\n         write!(w, \"<h3 id='{id}' class='method'><code>\", id = id,);\n         render_assoc_item(w, m, AssocItemLink::Anchor(Some(&id)), ItemType::Impl);\n         write!(w, \"</code>\");\n         render_stability_since(w, m, t);\n         write!(w, \"</h3>\");\n-        document(w, cx, m);\n+        document(w, cx, m, Some(t));\n     }\n \n     if !types.is_empty() {\n@@ -2628,6 +2654,7 @@ fn item_trait(w: &mut Buffer, cx: &Context, it: &clean::Item, t: &clean::Trait,\n                     w,\n                     cx,\n                     &implementor,\n+                    None,\n                     assoc_link,\n                     RenderMode::Normal,\n                     implementor.impl_item.stable_since().as_deref(),\n@@ -2890,7 +2917,7 @@ fn item_struct(w: &mut Buffer, cx: &Context, it: &clean::Item, s: &clean::Struct\n         write!(w, \"</pre>\")\n     });\n \n-    document(w, cx, it);\n+    document(w, cx, it, None);\n     let mut fields = s\n         .fields\n         .iter()\n@@ -2925,7 +2952,7 @@ fn item_struct(w: &mut Buffer, cx: &Context, it: &clean::Item, s: &clean::Struct\n                     name = field.name.as_ref().unwrap(),\n                     ty = ty.print()\n                 );\n-                document(w, cx, field);\n+                document(w, cx, field, Some(it));\n             }\n         }\n     }\n@@ -2940,7 +2967,7 @@ fn item_union(w: &mut Buffer, cx: &Context, it: &clean::Item, s: &clean::Union,\n         write!(w, \"</pre>\")\n     });\n \n-    document(w, cx, it);\n+    document(w, cx, it, None);\n     let mut fields = s\n         .fields\n         .iter()\n@@ -2972,7 +2999,7 @@ fn item_union(w: &mut Buffer, cx: &Context, it: &clean::Item, s: &clean::Union,\n             if let Some(stability_class) = field.stability_class() {\n                 write!(w, \"<span class='stab {stab}'></span>\", stab = stability_class);\n             }\n-            document(w, cx, field);\n+            document(w, cx, field, Some(it));\n         }\n     }\n     render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All, cache)\n@@ -3027,7 +3054,7 @@ fn item_enum(w: &mut Buffer, cx: &Context, it: &clean::Item, e: &clean::Enum, ca\n         write!(w, \"</pre>\")\n     });\n \n-    document(w, cx, it);\n+    document(w, cx, it, None);\n     if !e.variants.is_empty() {\n         write!(\n             w,\n@@ -3060,7 +3087,7 @@ fn item_enum(w: &mut Buffer, cx: &Context, it: &clean::Item, e: &clean::Enum, ca\n                 }\n             }\n             write!(w, \"</code></div>\");\n-            document(w, cx, variant);\n+            document(w, cx, variant, Some(it));\n             document_non_exhaustive(w, variant);\n \n             use crate::clean::{Variant, VariantKind};\n@@ -3095,7 +3122,7 @@ fn item_enum(w: &mut Buffer, cx: &Context, it: &clean::Item, e: &clean::Enum, ca\n                             f = field.name.as_ref().unwrap(),\n                             t = ty.print()\n                         );\n-                        document(w, cx, field);\n+                        document(w, cx, field, Some(variant));\n                     }\n                 }\n                 write!(w, \"</div></div>\");\n@@ -3293,6 +3320,10 @@ fn render_assoc_items(\n     what: AssocItemRender<'_>,\n     cache: &Cache,\n ) {\n+    info!(\n+        \"Documenting associated items of {}\",\n+        containing_item.name.as_deref().unwrap_or_default()\n+    );\n     let v = match cache.impls.get(&it) {\n         Some(v) => v,\n         None => return,\n@@ -3327,6 +3358,7 @@ fn render_assoc_items(\n                 w,\n                 cx,\n                 i,\n+                Some(containing_item),\n                 AssocItemLink::Anchor(None),\n                 render_mode,\n                 containing_item.stable_since().as_deref(),\n@@ -3518,6 +3550,7 @@ fn render_impl(\n     w: &mut Buffer,\n     cx: &Context,\n     i: &Impl,\n+    parent: Option<&clean::Item>,\n     link: AssocItemLink<'_>,\n     render_mode: RenderMode,\n     outer_version: Option<&str>,\n@@ -3600,6 +3633,7 @@ fn render_impl(\n         w: &mut Buffer,\n         cx: &Context,\n         item: &clean::Item,\n+        parent: Option<&clean::Item>,\n         link: AssocItemLink<'_>,\n         render_mode: RenderMode,\n         is_default_item: bool,\n@@ -3684,7 +3718,7 @@ fn render_impl(\n                     if let Some(it) = t.items.iter().find(|i| i.name == item.name) {\n                         // We need the stability of the item from the trait\n                         // because impls can't have a stability.\n-                        document_stability(w, cx, it, is_hidden);\n+                        document_stability(w, cx, it, is_hidden, parent);\n                         if item.doc_value().is_some() {\n                             document_full(w, item, cx, \"\", is_hidden);\n                         } else if show_def_docs {\n@@ -3694,13 +3728,13 @@ fn render_impl(\n                         }\n                     }\n                 } else {\n-                    document_stability(w, cx, item, is_hidden);\n+                    document_stability(w, cx, item, is_hidden, parent);\n                     if show_def_docs {\n                         document_full(w, item, cx, \"\", is_hidden);\n                     }\n                 }\n             } else {\n-                document_stability(w, cx, item, is_hidden);\n+                document_stability(w, cx, item, is_hidden, parent);\n                 if show_def_docs {\n                     document_short(w, item, link, \"\", is_hidden);\n                 }\n@@ -3717,6 +3751,7 @@ fn render_impl(\n             w,\n             cx,\n             trait_item,\n+            parent,\n             link,\n             render_mode,\n             false,\n@@ -3732,6 +3767,7 @@ fn render_impl(\n         cx: &Context,\n         t: &clean::Trait,\n         i: &clean::Impl,\n+        parent: Option<&clean::Item>,\n         render_mode: RenderMode,\n         outer_version: Option<&str>,\n         show_def_docs: bool,\n@@ -3749,6 +3785,7 @@ fn render_impl(\n                 w,\n                 cx,\n                 trait_item,\n+                parent,\n                 assoc_link,\n                 render_mode,\n                 true,\n@@ -3771,6 +3808,7 @@ fn render_impl(\n                 cx,\n                 t,\n                 &i.inner_impl(),\n+                parent,\n                 render_mode,\n                 outer_version,\n                 show_def_docs,\n@@ -3799,7 +3837,7 @@ fn item_opaque_ty(\n         bounds = bounds(&t.bounds, false)\n     );\n \n-    document(w, cx, it);\n+    document(w, cx, it, None);\n \n     // Render any items associated directly to this alias, as otherwise they\n     // won't be visible anywhere in the docs. It would be nice to also show\n@@ -3826,7 +3864,7 @@ fn item_trait_alias(\n         bounds(&t.bounds, true)\n     );\n \n-    document(w, cx, it);\n+    document(w, cx, it, None);\n \n     // Render any items associated directly to this alias, as otherwise they\n     // won't be visible anywhere in the docs. It would be nice to also show\n@@ -3847,7 +3885,7 @@ fn item_typedef(w: &mut Buffer, cx: &Context, it: &clean::Item, t: &clean::Typed\n         type_ = t.type_.print()\n     );\n \n-    document(w, cx, it);\n+    document(w, cx, it, None);\n \n     // Render any items associated directly to this alias, as otherwise they\n     // won't be visible anywhere in the docs. It would be nice to also show\n@@ -3866,7 +3904,7 @@ fn item_foreign_type(w: &mut Buffer, cx: &Context, it: &clean::Item, cache: &Cac\n         it.name.as_ref().unwrap(),\n     );\n \n-    document(w, cx, it);\n+    document(w, cx, it, None);\n \n     render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All, cache)\n }\n@@ -4511,7 +4549,7 @@ fn item_macro(w: &mut Buffer, cx: &Context, it: &clean::Item, t: &clean::Macro)\n             None,\n         ))\n     });\n-    document(w, cx, it)\n+    document(w, cx, it, None)\n }\n \n fn item_proc_macro(w: &mut Buffer, cx: &Context, it: &clean::Item, m: &clean::ProcMacro) {\n@@ -4541,16 +4579,16 @@ fn item_proc_macro(w: &mut Buffer, cx: &Context, it: &clean::Item, m: &clean::Pr\n             write!(w, \"</pre>\");\n         }\n     }\n-    document(w, cx, it)\n+    document(w, cx, it, None)\n }\n \n fn item_primitive(w: &mut Buffer, cx: &Context, it: &clean::Item, cache: &Cache) {\n-    document(w, cx, it);\n+    document(w, cx, it, None);\n     render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All, cache)\n }\n \n fn item_keyword(w: &mut Buffer, cx: &Context, it: &clean::Item) {\n-    document(w, cx, it)\n+    document(w, cx, it, None)\n }\n \n crate const BASIC_KEYWORDS: &str = \"rust, rustlang, rust-lang\";"}, {"sha": "633df661be02642182a8de54e0f9e76e3d3c3b8d", "filename": "src/test/rustdoc/doc-cfg-simplification.rs", "status": "added", "additions": 182, "deletions": 0, "changes": 182, "blob_url": "https://github.com/rust-lang/rust/blob/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/src%2Ftest%2Frustdoc%2Fdoc-cfg-simplification.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/src%2Ftest%2Frustdoc%2Fdoc-cfg-simplification.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fdoc-cfg-simplification.rs?ref=b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7", "patch": "@@ -0,0 +1,182 @@\n+#![crate_name = \"globuliferous\"]\n+#![feature(doc_cfg)]\n+\n+// @has 'globuliferous/index.html'\n+// @count   - '//*[@class=\"stab portability\"]' 1\n+// @matches - '//*[@class=\"stab portability\"]' '^ratel$'\n+\n+// @has 'globuliferous/ratel/index.html'\n+// @count   - '//*[@class=\"stab portability\"]' 8\n+// @matches - '//*[@class=\"stab portability\"]' 'crate feature ratel'\n+// @matches - '//*[@class=\"stab portability\"]' '^zoonosology$'\n+// @matches - '//*[@class=\"stab portability\"]' '^yusho$'\n+// @matches - '//*[@class=\"stab portability\"]' '^nunciative$'\n+// @matches - '//*[@class=\"stab portability\"]' '^thionic$'\n+// @matches - '//*[@class=\"stab portability\"]' '^zincic$'\n+// @matches - '//*[@class=\"stab portability\"]' '^cosmotellurian$'\n+// @matches - '//*[@class=\"stab portability\"]' '^aposiopesis$'\n+#[doc(cfg(feature = \"ratel\"))]\n+pub mod ratel {\n+    // @has 'globuliferous/ratel/fn.ovicide.html'\n+    // @count   - '//*[@class=\"stab portability\"]' 1\n+    // @matches - '//*[@class=\"stab portability\"]' 'crate feature ratel'\n+    pub fn ovicide() {}\n+\n+    // @has 'globuliferous/ratel/fn.zoonosology.html'\n+    // @count   - '//*[@class=\"stab portability\"]' 1\n+    // @matches - '//*[@class=\"stab portability\"]' 'crate features ratel and zoonosology'\n+    #[doc(cfg(feature = \"zoonosology\"))]\n+    pub fn zoonosology() {}\n+\n+    // @has 'globuliferous/ratel/constant.DIAGRAPHICS.html'\n+    // @count   - '//*[@class=\"stab portability\"]' 1\n+    // @matches - '//*[@class=\"stab portability\"]' 'crate feature ratel'\n+    pub const DIAGRAPHICS: () = ();\n+\n+    // @has 'globuliferous/ratel/constant.YUSHO.html'\n+    // @count   - '//*[@class=\"stab portability\"]' 1\n+    // @matches - '//*[@class=\"stab portability\"]' 'crate features ratel and yusho'\n+    #[doc(cfg(feature = \"yusho\"))]\n+    pub const YUSHO: () = ();\n+\n+    // @has 'globuliferous/ratel/static.KEYBUGLE.html'\n+    // @count   - '//*[@class=\"stab portability\"]' 1\n+    // @matches - '//*[@class=\"stab portability\"]' 'crate feature ratel'\n+    pub static KEYBUGLE: () = ();\n+\n+    // @has 'globuliferous/ratel/static.NUNCIATIVE.html'\n+    // @count   - '//*[@class=\"stab portability\"]' 1\n+    // @matches - '//*[@class=\"stab portability\"]' 'crate features ratel and nunciative'\n+    #[doc(cfg(feature = \"nunciative\"))]\n+    pub static NUNCIATIVE: () = ();\n+\n+    // @has 'globuliferous/ratel/type.Wrick.html'\n+    // @count   - '//*[@class=\"stab portability\"]' 1\n+    // @matches - '//*[@class=\"stab portability\"]' 'crate feature ratel'\n+    pub type Wrick = ();\n+\n+    // @has 'globuliferous/ratel/type.Thionic.html'\n+    // @count   - '//*[@class=\"stab portability\"]' 1\n+    // @matches - '//*[@class=\"stab portability\"]' 'crate features ratel and thionic'\n+    #[doc(cfg(feature = \"thionic\"))]\n+    pub type Thionic = ();\n+\n+    // @has 'globuliferous/ratel/struct.Eventration.html'\n+    // @count   - '//*[@class=\"stab portability\"]' 1\n+    // @matches - '//*[@class=\"stab portability\"]' 'crate feature ratel'\n+    pub struct Eventration;\n+\n+    // @has 'globuliferous/ratel/struct.Zincic.html'\n+    // @count   - '//*[@class=\"stab portability\"]' 2\n+    // @matches - '//*[@class=\"stab portability\"]' 'crate features ratel and zincic'\n+    // @matches - '//*[@class=\"stab portability\"]' 'crate feature rutherford'\n+    #[doc(cfg(feature = \"zincic\"))]\n+    pub struct Zincic {\n+        pub rectigrade: (),\n+\n+        #[doc(cfg(feature = \"rutherford\"))]\n+        pub rutherford: (),\n+    }\n+\n+    // @has 'globuliferous/ratel/enum.Cosmotellurian.html'\n+    // @count   - '//*[@class=\"stab portability\"]' 10\n+    // @matches - '//*[@class=\"stab portability\"]' 'crate features ratel and cosmotellurian'\n+    // @matches - '//*[@class=\"stab portability\"]' 'crate feature biotaxy'\n+    // @matches - '//*[@class=\"stab portability\"]' 'crate feature xiphopagus'\n+    // @matches - '//*[@class=\"stab portability\"]' 'crate feature juxtapositive'\n+    // @matches - '//*[@class=\"stab portability\"]' 'crate feature fuero'\n+    // @matches - '//*[@class=\"stab portability\"]' 'crate feature palaeophile'\n+    // @matches - '//*[@class=\"stab portability\"]' 'crate feature broadcloth'\n+    // @matches - '//*[@class=\"stab portability\"]' 'crate features broadcloth and xanthocomic'\n+    // @matches - '//*[@class=\"stab portability\"]' 'crate feature broadcloth'\n+    // @matches - '//*[@class=\"stab portability\"]' 'crate features broadcloth and whosoever'\n+    #[doc(cfg(feature = \"cosmotellurian\"))]\n+    pub enum Cosmotellurian {\n+        Groundsel {\n+            jagger: (),\n+\n+            #[doc(cfg(feature = \"xiphopagus\"))]\n+            xiphopagus: (),\n+        },\n+\n+        #[doc(cfg(feature = \"biotaxy\"))]\n+        Biotaxy {\n+            glossography: (),\n+\n+            #[doc(cfg(feature = \"juxtapositive\"))]\n+            juxtapositive: (),\n+        },\n+    }\n+\n+    impl Cosmotellurian {\n+        pub fn uxoricide() {}\n+\n+        #[doc(cfg(feature = \"fuero\"))]\n+        pub fn fuero() {}\n+\n+        pub const MAMELLE: () = ();\n+\n+        #[doc(cfg(feature = \"palaeophile\"))]\n+        pub const PALAEOPHILE: () = ();\n+    }\n+\n+    #[doc(cfg(feature = \"broadcloth\"))]\n+    impl Cosmotellurian {\n+        pub fn trabeculated() {}\n+\n+        #[doc(cfg(feature = \"xanthocomic\"))]\n+        pub fn xanthocomic() {}\n+\n+        pub const BRACHIFEROUS: () = ();\n+\n+        #[doc(cfg(feature = \"whosoever\"))]\n+        pub const WHOSOEVER: () = ();\n+    }\n+\n+    // @has 'globuliferous/ratel/trait.Gnotobiology.html'\n+    // @count   - '//*[@class=\"stab portability\"]' 4\n+    // @matches - '//*[@class=\"stab portability\"]' 'crate feature ratel'\n+    // @matches - '//*[@class=\"stab portability\"]' 'crate feature unzymotic'\n+    // @matches - '//*[@class=\"stab portability\"]' 'crate feature summate'\n+    // @matches - '//*[@class=\"stab portability\"]' 'crate feature unctuous'\n+    pub trait Gnotobiology {\n+        const XYLOTHERAPY: ();\n+\n+        #[doc(cfg(feature = \"unzymotic\"))]\n+        const UNZYMOTIC: ();\n+\n+        type Lepadoid;\n+\n+        #[doc(cfg(feature = \"summate\"))]\n+        type Summate;\n+\n+        fn decalcomania();\n+\n+        #[doc(cfg(feature = \"unctuous\"))]\n+        fn unctuous();\n+    }\n+\n+    // @has 'globuliferous/ratel/trait.Aposiopesis.html'\n+    // @count   - '//*[@class=\"stab portability\"]' 4\n+    // @matches - '//*[@class=\"stab portability\"]' 'crate features ratel and aposiopesis'\n+    // @matches - '//*[@class=\"stab portability\"]' 'crate feature umbracious'\n+    // @matches - '//*[@class=\"stab portability\"]' 'crate feature uakari'\n+    // @matches - '//*[@class=\"stab portability\"]' 'crate feature rotograph'\n+    #[doc(cfg(feature = \"aposiopesis\"))]\n+    pub trait Aposiopesis {\n+        const REDHIBITION: ();\n+\n+        #[doc(cfg(feature = \"umbracious\"))]\n+        const UMBRACIOUS: ();\n+\n+        type Ophthalmoscope;\n+\n+        #[doc(cfg(feature = \"uakari\"))]\n+        type Uakari;\n+\n+        fn meseems();\n+\n+        #[doc(cfg(feature = \"rotograph\"))]\n+        fn rotograph();\n+    }\n+}"}, {"sha": "d7041ee2f1af82de5d990fd67e75306e17100fb3", "filename": "src/test/rustdoc/doc-cfg.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/src%2Ftest%2Frustdoc%2Fdoc-cfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/src%2Ftest%2Frustdoc%2Fdoc-cfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fdoc-cfg.rs?ref=b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7", "patch": "@@ -10,9 +10,8 @@ pub struct Portable;\n // @has doc_cfg/unix_only/index.html \\\n //  '//*[@id=\"main\"]/*[@class=\"stability\"]/*[@class=\"stab portability\"]' \\\n //  'This is supported on Unix only.'\n-// @matches - '//*[@class=\"module-item\"]//*[@class=\"stab portability\"]' '\\AUnix\\Z'\n-// @matches - '//*[@class=\"module-item\"]//*[@class=\"stab portability\"]' '\\AUnix and ARM\\Z'\n-// @count - '//*[@class=\"stab portability\"]' 3\n+// @matches - '//*[@class=\"module-item\"]//*[@class=\"stab portability\"]' '\\AARM\\Z'\n+// @count - '//*[@class=\"stab portability\"]' 2\n #[doc(cfg(unix))]\n pub mod unix_only {\n     // @has doc_cfg/unix_only/fn.unix_only_function.html \\\n@@ -26,7 +25,7 @@ pub mod unix_only {\n     // @has doc_cfg/unix_only/trait.ArmOnly.html \\\n     //  '//*[@id=\"main\"]/*[@class=\"stability\"]/*[@class=\"stab portability\"]' \\\n     //  'This is supported on Unix and ARM only.'\n-    // @count - '//*[@class=\"stab portability\"]' 3\n+    // @count - '//*[@class=\"stab portability\"]' 2\n     #[doc(cfg(target_arch = \"arm\"))]\n     pub trait ArmOnly {\n         fn unix_and_arm_only_function();"}, {"sha": "7b938af3c7d5017f94c2ef464932eb5e497eb63f", "filename": "src/test/rustdoc/duplicate-cfg.rs", "status": "modified", "additions": 11, "deletions": 15, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/src%2Ftest%2Frustdoc%2Fduplicate-cfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/src%2Ftest%2Frustdoc%2Fduplicate-cfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fduplicate-cfg.rs?ref=b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7", "patch": "@@ -14,45 +14,41 @@\n pub struct Foo;\n \n // @has 'foo/bar/index.html'\n-// @matches '-' '//*[@class=\"module-item\"]//*[@class=\"stab portability\"]' '^sync$'\n-// @has '-' '//*[@class=\"module-item\"]//*[@class=\"stab portability\"]/@title' 'This is supported on crate feature `sync` only'\n-\n-// @has 'foo/bar/struct.Bar.html'\n // @has '-' '//*[@class=\"stab portability\"]' 'This is supported on crate feature sync only.'\n #[doc(cfg(feature = \"sync\"))]\n pub mod bar {\n+    // @has 'foo/bar/struct.Bar.html'\n+    // @has '-' '//*[@class=\"stab portability\"]' 'This is supported on crate feature sync only.'\n     #[doc(cfg(feature = \"sync\"))]\n     pub struct Bar;\n }\n \n // @has 'foo/baz/index.html'\n-// @matches '-' '//*[@class=\"module-item\"]//*[@class=\"stab portability\"]' '^sync and send$'\n-// @has '-' '//*[@class=\"module-item\"]//*[@class=\"stab portability\"]/@title' 'This is supported on crate features `sync` and `send` only'\n-\n-// @has 'foo/baz/struct.Baz.html'\n // @has '-' '//*[@class=\"stab portability\"]' 'This is supported on crate features sync and send only.'\n #[doc(cfg(all(feature = \"sync\", feature = \"send\")))]\n pub mod baz {\n+    // @has 'foo/baz/struct.Baz.html'\n+    // @has '-' '//*[@class=\"stab portability\"]' 'This is supported on crate features sync and send only.'\n     #[doc(cfg(feature = \"sync\"))]\n     pub struct Baz;\n }\n \n-// @has 'foo/qux/struct.Qux.html'\n-// @has '-' '//*[@class=\"stab portability\"]' 'This is supported on crate features sync and send only.'\n+// @has 'foo/qux/index.html'\n+// @has '-' '//*[@class=\"stab portability\"]' 'This is supported on crate feature sync only.'\n #[doc(cfg(feature = \"sync\"))]\n pub mod qux {\n+    // @has 'foo/qux/struct.Qux.html'\n+    // @has '-' '//*[@class=\"stab portability\"]' 'This is supported on crate features sync and send only.'\n     #[doc(cfg(all(feature = \"sync\", feature = \"send\")))]\n     pub struct Qux;\n }\n \n // @has 'foo/quux/index.html'\n-// @matches '-' '//*[@class=\"module-item\"]//*[@class=\"stab portability\"]' '^sync and send and foo and bar$'\n-// @has '-' '//*[@class=\"module-item\"]//*[@class=\"stab portability\"]/@title' 'This is supported on crate feature `sync` and crate feature `send` and `foo` and `bar` only'\n-\n-// @has 'foo/quux/struct.Quux.html'\n-// @has '-' '//*[@class=\"stab portability\"]' 'This is supported on crate feature sync and crate feature send and foo and bar only.'\n+// @has '-' '//*[@class=\"stab portability\"]' 'This is supported on crate feature sync and crate feature send and foo only.'\n #[doc(cfg(all(feature = \"sync\", feature = \"send\", foo)))]\n pub mod quux {\n+    // @has 'foo/quux/struct.Quux.html'\n+    // @has '-' '//*[@class=\"stab portability\"]' 'This is supported on crate feature sync and crate feature send and foo and bar only.'\n     #[doc(cfg(all(feature = \"send\", feature = \"sync\", bar)))]\n     pub struct Quux;\n }"}, {"sha": "d0577e4864a78bb238eca750617de5665d2901dc", "filename": "src/test/ui/arg-count-mismatch.stderr", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/src%2Ftest%2Fui%2Farg-count-mismatch.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/src%2Ftest%2Fui%2Farg-count-mismatch.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Farg-count-mismatch.stderr?ref=b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7", "patch": "@@ -1,13 +1,16 @@\n error[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> $DIR/arg-count-mismatch.rs:5:28\n    |\n-LL | fn f(x: isize) { }\n-   | -------------- defined here\n-LL | \n LL | fn main() { let i: (); i = f(); }\n    |                            ^-- supplied 0 arguments\n    |                            |\n    |                            expected 1 argument\n+   |\n+note: function defined here\n+  --> $DIR/arg-count-mismatch.rs:3:4\n+   |\n+LL | fn f(x: isize) { }\n+   |    ^ --------\n \n error: aborting due to previous error\n "}, {"sha": "97f96ab69295fc06222ba745e1bb96eba4919bfe", "filename": "src/test/ui/borrowck/bindings-after-at-or-patterns-slice-patterns-box-patterns.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/src%2Ftest%2Fui%2Fborrowck%2Fbindings-after-at-or-patterns-slice-patterns-box-patterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/src%2Ftest%2Fui%2Fborrowck%2Fbindings-after-at-or-patterns-slice-patterns-box-patterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fbindings-after-at-or-patterns-slice-patterns-box-patterns.rs?ref=b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7", "patch": "@@ -3,8 +3,6 @@\n #![feature(or_patterns)]\n #![feature(box_patterns)]\n \n-#![feature(move_ref_pattern)]\n-\n enum Test {\n     Foo,\n     Bar,"}, {"sha": "96e313b39ed1ebc6e50863a2b92001d498a29e8d", "filename": "src/test/ui/borrowck/bindings-after-at-or-patterns-slice-patterns-box-patterns.stderr", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/src%2Ftest%2Fui%2Fborrowck%2Fbindings-after-at-or-patterns-slice-patterns-box-patterns.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/src%2Ftest%2Fui%2Fborrowck%2Fbindings-after-at-or-patterns-slice-patterns-box-patterns.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fbindings-after-at-or-patterns-slice-patterns-box-patterns.stderr?ref=b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7", "patch": "@@ -1,5 +1,5 @@\n error: cannot borrow value as mutable because it is also borrowed as immutable\n-  --> $DIR/bindings-after-at-or-patterns-slice-patterns-box-patterns.rs:40:9\n+  --> $DIR/bindings-after-at-or-patterns-slice-patterns-box-patterns.rs:38:9\n    |\n LL |         ref foo @ [.., ref mut bar] => (),\n    |         -------^^^^^^^^-----------^\n@@ -8,7 +8,7 @@ LL |         ref foo @ [.., ref mut bar] => (),\n    |         immutable borrow, by `foo`, occurs here\n \n error: cannot borrow value as mutable because it is also borrowed as immutable\n-  --> $DIR/bindings-after-at-or-patterns-slice-patterns-box-patterns.rs:124:9\n+  --> $DIR/bindings-after-at-or-patterns-slice-patterns-box-patterns.rs:122:9\n    |\n LL |         ref foo @ Some(box ref mut s) => (),\n    |         -------^^^^^^^^^^^^---------^\n@@ -17,7 +17,7 @@ LL |         ref foo @ Some(box ref mut s) => (),\n    |         immutable borrow, by `foo`, occurs here\n \n error[E0382]: borrow of moved value: `x`\n-  --> $DIR/bindings-after-at-or-patterns-slice-patterns-box-patterns.rs:22:5\n+  --> $DIR/bindings-after-at-or-patterns-slice-patterns-box-patterns.rs:20:5\n    |\n LL | fn bindings_after_at_slice_patterns_move_binding(x: [String; 4]) {\n    |                                                  - move occurs because `x` has type `[String; 4]`, which does not implement the `Copy` trait\n@@ -29,7 +29,7 @@ LL |     &x;\n    |     ^^ value borrowed here after move\n \n error[E0502]: cannot borrow `x` as immutable because it is also borrowed as mutable\n-  --> $DIR/bindings-after-at-or-patterns-slice-patterns-box-patterns.rs:32:5\n+  --> $DIR/bindings-after-at-or-patterns-slice-patterns-box-patterns.rs:30:5\n    |\n LL |         ref mut foo @ [.., _] => Some(foo),\n    |         --------------------- mutable borrow occurs here\n@@ -41,7 +41,7 @@ LL |     drop(r);\n    |          - mutable borrow later used here\n \n error[E0502]: cannot borrow `x` as mutable because it is also borrowed as immutable\n-  --> $DIR/bindings-after-at-or-patterns-slice-patterns-box-patterns.rs:54:5\n+  --> $DIR/bindings-after-at-or-patterns-slice-patterns-box-patterns.rs:52:5\n    |\n LL |         [ref foo @ .., ref bar] => Some(foo),\n    |          ------------ immutable borrow occurs here\n@@ -53,7 +53,7 @@ LL |     drop(r);\n    |          - immutable borrow later used here\n \n error[E0502]: cannot borrow `x` as mutable because it is also borrowed as immutable\n-  --> $DIR/bindings-after-at-or-patterns-slice-patterns-box-patterns.rs:66:5\n+  --> $DIR/bindings-after-at-or-patterns-slice-patterns-box-patterns.rs:64:5\n    |\n LL |         ref foo @ [.., ref bar] => Some(foo),\n    |         ----------------------- immutable borrow occurs here\n@@ -65,7 +65,7 @@ LL |     drop(r);\n    |          - immutable borrow later used here\n \n error[E0382]: borrow of moved value: `x`\n-  --> $DIR/bindings-after-at-or-patterns-slice-patterns-box-patterns.rs:80:5\n+  --> $DIR/bindings-after-at-or-patterns-slice-patterns-box-patterns.rs:78:5\n    |\n LL | fn bindings_after_at_or_patterns_move(x: Option<Test>) {\n    |                                       - move occurs because `x` has type `Option<Test>`, which does not implement the `Copy` trait\n@@ -80,7 +80,7 @@ LL |     &x;\n    |     ^^ value borrowed here after move\n \n error[E0502]: cannot borrow `x` as mutable because it is also borrowed as immutable\n-  --> $DIR/bindings-after-at-or-patterns-slice-patterns-box-patterns.rs:90:5\n+  --> $DIR/bindings-after-at-or-patterns-slice-patterns-box-patterns.rs:88:5\n    |\n LL |         ref foo @ Some(Test::Foo | Test::Bar) => Some(foo),\n    |         ------------------------------------- immutable borrow occurs here\n@@ -92,7 +92,7 @@ LL |     drop(r);\n    |          - immutable borrow later used here\n \n error[E0502]: cannot borrow `x` as immutable because it is also borrowed as mutable\n-  --> $DIR/bindings-after-at-or-patterns-slice-patterns-box-patterns.rs:102:5\n+  --> $DIR/bindings-after-at-or-patterns-slice-patterns-box-patterns.rs:100:5\n    |\n LL |         ref mut foo @ Some(Test::Foo | Test::Bar) => Some(foo),\n    |         ----------------------------------------- mutable borrow occurs here\n@@ -104,7 +104,7 @@ LL |     drop(r);\n    |          - mutable borrow later used here\n \n error[E0502]: cannot borrow `x` as mutable because it is also borrowed as immutable\n-  --> $DIR/bindings-after-at-or-patterns-slice-patterns-box-patterns.rs:116:5\n+  --> $DIR/bindings-after-at-or-patterns-slice-patterns-box-patterns.rs:114:5\n    |\n LL |         ref foo @ Some(box ref s) => Some(foo),\n    |         ------------------------- immutable borrow occurs here\n@@ -116,7 +116,7 @@ LL |     drop(r);\n    |          - immutable borrow later used here\n \n error[E0382]: borrow of moved value: `x`\n-  --> $DIR/bindings-after-at-or-patterns-slice-patterns-box-patterns.rs:138:5\n+  --> $DIR/bindings-after-at-or-patterns-slice-patterns-box-patterns.rs:136:5\n    |\n LL | fn bindings_after_at_slice_patterns_or_patterns_moves(x: [Option<Test>; 4]) {\n    |                                                       - move occurs because `x` has type `[Option<Test>; 4]`, which does not implement the `Copy` trait\n@@ -131,7 +131,7 @@ LL |     &x;\n    |     ^^ value borrowed here after move\n \n error[E0502]: cannot borrow `x` as mutable because it is also borrowed as immutable\n-  --> $DIR/bindings-after-at-or-patterns-slice-patterns-box-patterns.rs:148:5\n+  --> $DIR/bindings-after-at-or-patterns-slice-patterns-box-patterns.rs:146:5\n    |\n LL |         ref a @ [ref b @ .., Some(Test::Foo | Test::Bar)] => Some(a),\n    |         ------------------------------------------------- immutable borrow occurs here\n@@ -143,7 +143,7 @@ LL |     drop(r);\n    |          - immutable borrow later used here\n \n error[E0502]: cannot borrow `x` as mutable because it is also borrowed as immutable\n-  --> $DIR/bindings-after-at-or-patterns-slice-patterns-box-patterns.rs:160:5\n+  --> $DIR/bindings-after-at-or-patterns-slice-patterns-box-patterns.rs:158:5\n    |\n LL |         ref a @ [ref b @ .., Some(Test::Foo | Test::Bar)] => Some(b),\n    |                  ---------- immutable borrow occurs here\n@@ -155,7 +155,7 @@ LL |     drop(r);\n    |          - immutable borrow later used here\n \n error[E0502]: cannot borrow `x` as mutable because it is also borrowed as immutable\n-  --> $DIR/bindings-after-at-or-patterns-slice-patterns-box-patterns.rs:174:5\n+  --> $DIR/bindings-after-at-or-patterns-slice-patterns-box-patterns.rs:172:5\n    |\n LL |         [_, ref a @ Some(box ref b), ..] => Some(a),\n    |             ----------------------- immutable borrow occurs here\n@@ -167,7 +167,7 @@ LL |     drop(r);\n    |          - immutable borrow later used here\n \n error[E0502]: cannot borrow `x` as mutable because it is also borrowed as immutable\n-  --> $DIR/bindings-after-at-or-patterns-slice-patterns-box-patterns.rs:190:5\n+  --> $DIR/bindings-after-at-or-patterns-slice-patterns-box-patterns.rs:188:5\n    |\n LL |         [_, ref a @ Some(box Test::Foo | box Test::Bar), ..] => Some(a),\n    |             ------------------------------------------- immutable borrow occurs here\n@@ -179,7 +179,7 @@ LL |     drop(r);\n    |          - immutable borrow later used here\n \n error[E0502]: cannot borrow `x` as immutable because it is also borrowed as mutable\n-  --> $DIR/bindings-after-at-or-patterns-slice-patterns-box-patterns.rs:204:5\n+  --> $DIR/bindings-after-at-or-patterns-slice-patterns-box-patterns.rs:202:5\n    |\n LL |         [_, ref mut a @ Some(box Test::Foo | box Test::Bar), ..] => Some(a),\n    |             ----------------------------------------------- mutable borrow occurs here\n@@ -191,7 +191,7 @@ LL |     drop(r);\n    |          - mutable borrow later used here\n \n error[E0502]: cannot borrow `x` as mutable because it is also borrowed as immutable\n-  --> $DIR/bindings-after-at-or-patterns-slice-patterns-box-patterns.rs:218:5\n+  --> $DIR/bindings-after-at-or-patterns-slice-patterns-box-patterns.rs:216:5\n    |\n LL |         ref a @ [_, ref b @ Some(box Test::Foo | box Test::Bar), ..] => Some(a),\n    |         ------------------------------------------------------------ immutable borrow occurs here"}, {"sha": "6f2a6c359b537720954fca49d289cde8ba828b49", "filename": "src/test/ui/c-variadic/variadic-ffi-1.stderr", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/src%2Ftest%2Fui%2Fc-variadic%2Fvariadic-ffi-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/src%2Ftest%2Fui%2Fc-variadic%2Fvariadic-ffi-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fc-variadic%2Fvariadic-ffi-1.stderr?ref=b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7", "patch": "@@ -7,24 +7,30 @@ LL |     fn printf(_: *const u8, ...);\n error[E0060]: this function takes at least 2 arguments but 0 arguments were supplied\n   --> $DIR/variadic-ffi-1.rs:17:9\n    |\n-LL |     fn foo(f: isize, x: u8, ...);\n-   |     ----------------------------- defined here\n-...\n LL |         foo();\n    |         ^^^-- supplied 0 arguments\n    |         |\n    |         expected at least 2 arguments\n+   |\n+note: function defined here\n+  --> $DIR/variadic-ffi-1.rs:10:8\n+   |\n+LL |     fn foo(f: isize, x: u8, ...);\n+   |        ^^^\n \n error[E0060]: this function takes at least 2 arguments but 1 argument was supplied\n   --> $DIR/variadic-ffi-1.rs:18:9\n    |\n-LL |     fn foo(f: isize, x: u8, ...);\n-   |     ----------------------------- defined here\n-...\n LL |         foo(1);\n    |         ^^^ - supplied 1 argument\n    |         |\n    |         expected at least 2 arguments\n+   |\n+note: function defined here\n+  --> $DIR/variadic-ffi-1.rs:10:8\n+   |\n+LL |     fn foo(f: isize, x: u8, ...);\n+   |        ^^^\n \n error[E0308]: mismatched types\n   --> $DIR/variadic-ffi-1.rs:20:56"}, {"sha": "e11ba43ca2a9a879c941e7ec4bf6ae79f912a2af", "filename": "src/test/ui/c-variadic/variadic-ffi-no-fixed-args.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/src%2Ftest%2Fui%2Fc-variadic%2Fvariadic-ffi-no-fixed-args.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/src%2Ftest%2Fui%2Fc-variadic%2Fvariadic-ffi-no-fixed-args.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fc-variadic%2Fvariadic-ffi-no-fixed-args.stderr?ref=b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7", "patch": "@@ -2,7 +2,7 @@ error: C-variadic function must be declared with at least one named argument\n   --> $DIR/variadic-ffi-no-fixed-args.rs:2:12\n    |\n LL |     fn foo(...);\n-   |            ^^^^\n+   |            ^^^\n \n error: aborting due to previous error\n "}, {"sha": "b027faa9d7c3a2ba3f8f684252af589f9cd6bcb3", "filename": "src/test/ui/drop/dynamic-drop-async.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/src%2Ftest%2Fui%2Fdrop%2Fdynamic-drop-async.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/src%2Ftest%2Fui%2Fdrop%2Fdynamic-drop-async.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdrop%2Fdynamic-drop-async.rs?ref=b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7", "patch": "@@ -7,8 +7,6 @@\n // edition:2018\n // ignore-wasm32-bare compiled with panic=abort by default\n \n-#![feature(move_ref_pattern)]\n-\n #![allow(unused)]\n \n use std::{"}, {"sha": "ada61bf0df04cb7e08f563802a4ec2449440da68", "filename": "src/test/ui/drop/dynamic-drop.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/src%2Ftest%2Fui%2Fdrop%2Fdynamic-drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/src%2Ftest%2Fui%2Fdrop%2Fdynamic-drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdrop%2Fdynamic-drop.rs?ref=b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7", "patch": "@@ -2,7 +2,6 @@\n // ignore-wasm32-bare compiled with panic=abort by default\n \n #![feature(generators, generator_trait, untagged_unions)]\n-#![feature(move_ref_pattern)]\n #![feature(bindings_after_at)]\n \n #![allow(unused_assignments)]"}, {"sha": "022ac5fc113ddbf6a631ed1529ea1b4543a53924", "filename": "src/test/ui/error-codes/E0007.rs", "status": "removed", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/dd7fc54ebdca419ad9d3ab1e9f5ed14e770768ea/src%2Ftest%2Fui%2Ferror-codes%2FE0007.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd7fc54ebdca419ad9d3ab1e9f5ed14e770768ea/src%2Ftest%2Fui%2Ferror-codes%2FE0007.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0007.rs?ref=dd7fc54ebdca419ad9d3ab1e9f5ed14e770768ea", "patch": "@@ -1,11 +0,0 @@\n-#![feature(bindings_after_at)]\n-\n-fn main() {\n-    let x = Some(\"s\".to_string());\n-    match x {\n-        op_string @ Some(s) => {},\n-        //~^ ERROR E0007\n-        //~| ERROR E0382\n-        None => {},\n-    }\n-}"}, {"sha": "89c1051619438bc3b4533f52151b79df8e3daf32", "filename": "src/test/ui/error-codes/E0007.stderr", "status": "removed", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/dd7fc54ebdca419ad9d3ab1e9f5ed14e770768ea/src%2Ftest%2Fui%2Ferror-codes%2FE0007.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dd7fc54ebdca419ad9d3ab1e9f5ed14e770768ea/src%2Ftest%2Fui%2Ferror-codes%2FE0007.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0007.stderr?ref=dd7fc54ebdca419ad9d3ab1e9f5ed14e770768ea", "patch": "@@ -1,22 +0,0 @@\n-error[E0007]: cannot bind by-move with sub-bindings\n-  --> $DIR/E0007.rs:6:9\n-   |\n-LL |         op_string @ Some(s) => {},\n-   |         ^^^^^^^^^^^^^^^^^^^ binds an already bound by-move value by moving it\n-\n-error[E0382]: use of moved value\n-  --> $DIR/E0007.rs:6:26\n-   |\n-LL |     let x = Some(\"s\".to_string());\n-   |         - move occurs because `x` has type `Option<String>`, which does not implement the `Copy` trait\n-LL |     match x {\n-LL |         op_string @ Some(s) => {},\n-   |         -----------------^-\n-   |         |                |\n-   |         |                value used here after move\n-   |         value moved here\n-\n-error: aborting due to 2 previous errors\n-\n-Some errors have detailed explanations: E0007, E0382.\n-For more information about an error, try `rustc --explain E0007`."}, {"sha": "c80014d14763bb420e8397e42545acbe2a8654ce", "filename": "src/test/ui/error-codes/E0060.stderr", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/src%2Ftest%2Fui%2Ferror-codes%2FE0060.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/src%2Ftest%2Fui%2Ferror-codes%2FE0060.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0060.stderr?ref=b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7", "patch": "@@ -1,13 +1,16 @@\n error[E0060]: this function takes at least 1 argument but 0 arguments were supplied\n   --> $DIR/E0060.rs:6:14\n    |\n-LL |     fn printf(_: *const u8, ...) -> u32;\n-   |     ------------------------------------ defined here\n-...\n LL |     unsafe { printf(); }\n    |              ^^^^^^-- supplied 0 arguments\n    |              |\n    |              expected at least 1 argument\n+   |\n+note: function defined here\n+  --> $DIR/E0060.rs:2:8\n+   |\n+LL |     fn printf(_: *const u8, ...) -> u32;\n+   |        ^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "98488a2d298b90182d861a9ddabd6ad3caeee7c9", "filename": "src/test/ui/error-codes/E0061.stderr", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/src%2Ftest%2Fui%2Ferror-codes%2FE0061.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/src%2Ftest%2Fui%2Ferror-codes%2FE0061.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0061.stderr?ref=b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7", "patch": "@@ -1,24 +1,30 @@\n error[E0061]: this function takes 2 arguments but 1 argument was supplied\n   --> $DIR/E0061.rs:6:5\n    |\n-LL | fn f(a: u16, b: &str) {}\n-   | --------------------- defined here\n-...\n LL |     f(0);\n    |     ^ - supplied 1 argument\n    |     |\n    |     expected 2 arguments\n+   |\n+note: function defined here\n+  --> $DIR/E0061.rs:1:4\n+   |\n+LL | fn f(a: u16, b: &str) {}\n+   |    ^ ------  -------\n \n error[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> $DIR/E0061.rs:10:5\n    |\n-LL | fn f2(a: u16) {}\n-   | ------------- defined here\n-...\n LL |     f2();\n    |     ^^-- supplied 0 arguments\n    |     |\n    |     expected 1 argument\n+   |\n+note: function defined here\n+  --> $DIR/E0061.rs:3:4\n+   |\n+LL | fn f2(a: u16) {}\n+   |    ^^ ------\n \n error: aborting due to 2 previous errors\n "}, {"sha": "2cc1c7a2e7269bec6d6ceb6d1570e6b17e1c2019", "filename": "src/test/ui/hrtb/issue-58451.stderr", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/src%2Ftest%2Fui%2Fhrtb%2Fissue-58451.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/src%2Ftest%2Fui%2Fhrtb%2Fissue-58451.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhrtb%2Fissue-58451.stderr?ref=b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7", "patch": "@@ -1,16 +1,16 @@\n error[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> $DIR/issue-58451.rs:12:9\n    |\n-LL | / fn f<I>(i: I)\n-LL | | where\n-LL | |     I: IntoIterator,\n-LL | |     I::Item: for<'a> Into<&'a ()>,\n-   | |__________________________________- defined here\n-...\n-LL |       f(&[f()]);\n-   |           ^-- supplied 0 arguments\n-   |           |\n-   |           expected 1 argument\n+LL |     f(&[f()]);\n+   |         ^-- supplied 0 arguments\n+   |         |\n+   |         expected 1 argument\n+   |\n+note: function defined here\n+  --> $DIR/issue-58451.rs:5:4\n+   |\n+LL | fn f<I>(i: I)\n+   |    ^    ----\n \n error: aborting due to previous error\n "}, {"sha": "b10d26abe348584260c9a3c2052d1dcbbe2685e9", "filename": "src/test/ui/issues/issue-18819.stderr", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/src%2Ftest%2Fui%2Fissues%2Fissue-18819.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/src%2Ftest%2Fui%2Fissues%2Fissue-18819.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-18819.stderr?ref=b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7", "patch": "@@ -1,13 +1,16 @@\n error[E0061]: this function takes 2 arguments but 1 argument was supplied\n   --> $DIR/issue-18819.rs:16:5\n    |\n-LL | fn print_x(_: &dyn Foo<Item=bool>, extra: &str) {\n-   | ----------------------------------------------- defined here\n-...\n LL |     print_x(X);\n    |     ^^^^^^^ - supplied 1 argument\n    |     |\n    |     expected 2 arguments\n+   |\n+note: function defined here\n+  --> $DIR/issue-18819.rs:11:4\n+   |\n+LL | fn print_x(_: &dyn Foo<Item=bool>, extra: &str) {\n+   |    ^^^^^^^ ----------------------  -----------\n \n error: aborting due to previous error\n "}, {"sha": "a6f1ac9286cdac1d343358bb4a1f19df10ae198a", "filename": "src/test/ui/issues/issue-26094.stderr", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/src%2Ftest%2Fui%2Fissues%2Fissue-26094.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/src%2Ftest%2Fui%2Fissues%2Fissue-26094.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-26094.stderr?ref=b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7", "patch": "@@ -4,11 +4,14 @@ error[E0061]: this function takes 0 arguments but 1 argument was supplied\n LL |         $other(None)\n    |                ---- supplied 1 argument\n ...\n-LL | fn some_function() {}\n-   | ------------------ defined here\n-...\n LL |     some_macro!(some_function);\n    |                 ^^^^^^^^^^^^^ expected 0 arguments\n+   |\n+note: function defined here\n+  --> $DIR/issue-26094.rs:7:4\n+   |\n+LL | fn some_function() {}\n+   |    ^^^^^^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "03b9b91edefb2e61a582ebb2db3bf37fa03ab491", "filename": "src/test/ui/issues/issue-4935.stderr", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/src%2Ftest%2Fui%2Fissues%2Fissue-4935.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/src%2Ftest%2Fui%2Fissues%2Fissue-4935.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-4935.stderr?ref=b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7", "patch": "@@ -1,13 +1,16 @@\n error[E0061]: this function takes 1 argument but 2 arguments were supplied\n   --> $DIR/issue-4935.rs:5:13\n    |\n-LL | fn foo(a: usize) {}\n-   | ---------------- defined here\n-LL |\n LL | fn main() { foo(5, 6) }\n    |             ^^^ -  - supplied 2 arguments\n    |             |\n    |             expected 1 argument\n+   |\n+note: function defined here\n+  --> $DIR/issue-4935.rs:3:4\n+   |\n+LL | fn foo(a: usize) {}\n+   |    ^^^ --------\n \n error: aborting due to previous error\n "}, {"sha": "60f9eeeca27fe6f12449b447f7037debb832193d", "filename": "src/test/ui/methods/method-call-err-msg.stderr", "status": "modified", "additions": 24, "deletions": 12, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/src%2Ftest%2Fui%2Fmethods%2Fmethod-call-err-msg.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/src%2Ftest%2Fui%2Fmethods%2Fmethod-call-err-msg.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmethods%2Fmethod-call-err-msg.stderr?ref=b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7", "patch": "@@ -1,35 +1,44 @@\n error[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> $DIR/method-call-err-msg.rs:13:7\n    |\n-LL |     fn zero(self) -> Foo { self }\n-   |     -------------------- defined here\n-...\n LL |     x.zero(0)\n    |       ^^^^ - supplied 1 argument\n    |       |\n    |       expected 0 arguments\n+   |\n+note: associated function defined here\n+  --> $DIR/method-call-err-msg.rs:5:8\n+   |\n+LL |     fn zero(self) -> Foo { self }\n+   |        ^^^^ ----\n \n error[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> $DIR/method-call-err-msg.rs:14:7\n    |\n-LL |     fn one(self, _: isize) -> Foo { self }\n-   |     ----------------------------- defined here\n-...\n LL |      .one()\n    |       ^^^- supplied 0 arguments\n    |       |\n    |       expected 1 argument\n+   |\n+note: associated function defined here\n+  --> $DIR/method-call-err-msg.rs:6:8\n+   |\n+LL |     fn one(self, _: isize) -> Foo { self }\n+   |        ^^^ ----  --------\n \n error[E0061]: this function takes 2 arguments but 1 argument was supplied\n   --> $DIR/method-call-err-msg.rs:15:7\n    |\n-LL |     fn two(self, _: isize, _: isize) -> Foo { self }\n-   |     --------------------------------------- defined here\n-...\n LL |      .two(0);\n    |       ^^^ - supplied 1 argument\n    |       |\n    |       expected 2 arguments\n+   |\n+note: associated function defined here\n+  --> $DIR/method-call-err-msg.rs:7:8\n+   |\n+LL |     fn two(self, _: isize, _: isize) -> Foo { self }\n+   |        ^^^ ----  --------  --------\n \n error[E0599]: no method named `take` found for struct `Foo` in the current scope\n   --> $DIR/method-call-err-msg.rs:19:7\n@@ -53,13 +62,16 @@ LL |      .take()\n error[E0061]: this function takes 3 arguments but 0 arguments were supplied\n   --> $DIR/method-call-err-msg.rs:21:7\n    |\n-LL |     fn three<T>(self, _: T, _: T, _: T) -> Foo { self }\n-   |     ------------------------------------------ defined here\n-...\n LL |     y.three::<usize>();\n    |       ^^^^^--------- supplied 0 arguments\n    |       |\n    |       expected 3 arguments\n+   |\n+note: associated function defined here\n+  --> $DIR/method-call-err-msg.rs:8:8\n+   |\n+LL |     fn three<T>(self, _: T, _: T, _: T) -> Foo { self }\n+   |        ^^^^^    ----  ----  ----  ----\n \n error: aborting due to 5 previous errors\n "}, {"sha": "5d2ce9302ece6c125bbe987edc9174207ca3753a", "filename": "src/test/ui/mismatched_types/issue-38371.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/src%2Ftest%2Fui%2Fmismatched_types%2Fissue-38371.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/src%2Ftest%2Fui%2Fmismatched_types%2Fissue-38371.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fissue-38371.stderr?ref=b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7", "patch": "@@ -2,7 +2,7 @@ error[E0308]: mismatched types\n   --> $DIR/issue-38371.rs:4:8\n    |\n LL | fn foo(&foo: Foo) {\n-   |        ^^^^------\n+   |        ^^^^-----\n    |        |     |\n    |        |     expected due to this\n    |        expected struct `Foo`, found reference"}, {"sha": "424762551887138ec0e8dd4a8af250b5c7bcc3ed", "filename": "src/test/ui/not-enough-arguments.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/src%2Ftest%2Fui%2Fnot-enough-arguments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/src%2Ftest%2Fui%2Fnot-enough-arguments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnot-enough-arguments.rs?ref=b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7", "patch": "@@ -6,7 +6,26 @@ fn foo(a: isize, b: isize, c: isize, d:isize) {\n   panic!();\n }\n \n+// Check that all arguments are shown in the error message, even if they're across multiple lines.\n+fn bar(\n+    a: i32,\n+    b: i32,\n+    c: i32,\n+    d: i32,\n+    e: i32,\n+    f: i32,\n+) {\n+    println!(\"{}\", a);\n+    println!(\"{}\", b);\n+    println!(\"{}\", c);\n+    println!(\"{}\", d);\n+    println!(\"{}\", e);\n+    println!(\"{}\", f);\n+}\n+\n fn main() {\n   foo(1, 2, 3);\n   //~^ ERROR this function takes 4 arguments but 3\n+  bar(1, 2, 3);\n+  //~^ ERROR this function takes 6 arguments but 3\n }"}, {"sha": "df957837241489ce4d36a2356c85b1b9bc674d1e", "filename": "src/test/ui/not-enough-arguments.stderr", "status": "modified", "additions": 34, "deletions": 5, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/src%2Ftest%2Fui%2Fnot-enough-arguments.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/src%2Ftest%2Fui%2Fnot-enough-arguments.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnot-enough-arguments.stderr?ref=b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7", "patch": "@@ -1,14 +1,43 @@\n error[E0061]: this function takes 4 arguments but 3 arguments were supplied\n-  --> $DIR/not-enough-arguments.rs:10:3\n+  --> $DIR/not-enough-arguments.rs:27:3\n    |\n-LL | fn foo(a: isize, b: isize, c: isize, d:isize) {\n-   | --------------------------------------------- defined here\n-...\n LL |   foo(1, 2, 3);\n    |   ^^^ -  -  - supplied 3 arguments\n    |   |\n    |   expected 4 arguments\n+   |\n+note: function defined here\n+  --> $DIR/not-enough-arguments.rs:5:4\n+   |\n+LL | fn foo(a: isize, b: isize, c: isize, d:isize) {\n+   |    ^^^ --------  --------  --------  -------\n+\n+error[E0061]: this function takes 6 arguments but 3 arguments were supplied\n+  --> $DIR/not-enough-arguments.rs:29:3\n+   |\n+LL |   bar(1, 2, 3);\n+   |   ^^^ -  -  - supplied 3 arguments\n+   |   |\n+   |   expected 6 arguments\n+   |\n+note: function defined here\n+  --> $DIR/not-enough-arguments.rs:10:4\n+   |\n+LL | fn bar(\n+   |    ^^^\n+LL |     a: i32,\n+   |     ------\n+LL |     b: i32,\n+   |     ------\n+LL |     c: i32,\n+   |     ------\n+LL |     d: i32,\n+   |     ------\n+LL |     e: i32,\n+   |     ------\n+LL |     f: i32,\n+   |     ------\n \n-error: aborting due to previous error\n+error: aborting due to 2 previous errors\n \n For more information about this error, try `rustc --explain E0061`."}, {"sha": "3f3ddfed14a66aa15ee8ea05cd624f5c896cd565", "filename": "src/test/ui/parser/variadic-ffi-semantic-restrictions.stderr", "status": "modified", "additions": 34, "deletions": 34, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/src%2Ftest%2Fui%2Fparser%2Fvariadic-ffi-semantic-restrictions.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/src%2Ftest%2Fui%2Fparser%2Fvariadic-ffi-semantic-restrictions.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fvariadic-ffi-semantic-restrictions.stderr?ref=b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7", "patch": "@@ -2,205 +2,205 @@ error: only foreign or `unsafe extern \"C\" functions may be C-variadic\n   --> $DIR/variadic-ffi-semantic-restrictions.rs:5:19\n    |\n LL | fn f1_1(x: isize, ...) {}\n-   |                   ^^^^\n+   |                   ^^^\n \n error: C-variadic function must be declared with at least one named argument\n   --> $DIR/variadic-ffi-semantic-restrictions.rs:8:9\n    |\n LL | fn f1_2(...) {}\n-   |         ^^^^\n+   |         ^^^\n \n error: only foreign or `unsafe extern \"C\" functions may be C-variadic\n   --> $DIR/variadic-ffi-semantic-restrictions.rs:8:9\n    |\n LL | fn f1_2(...) {}\n-   |         ^^^^\n+   |         ^^^\n \n error: only foreign or `unsafe extern \"C\" functions may be C-variadic\n   --> $DIR/variadic-ffi-semantic-restrictions.rs:12:30\n    |\n LL | extern \"C\" fn f2_1(x: isize, ...) {}\n-   |                              ^^^^\n+   |                              ^^^\n \n error: C-variadic function must be declared with at least one named argument\n   --> $DIR/variadic-ffi-semantic-restrictions.rs:15:20\n    |\n LL | extern \"C\" fn f2_2(...) {}\n-   |                    ^^^^\n+   |                    ^^^\n \n error: only foreign or `unsafe extern \"C\" functions may be C-variadic\n   --> $DIR/variadic-ffi-semantic-restrictions.rs:15:20\n    |\n LL | extern \"C\" fn f2_2(...) {}\n-   |                    ^^^^\n+   |                    ^^^\n \n error: `...` must be the last argument of a C-variadic function\n   --> $DIR/variadic-ffi-semantic-restrictions.rs:19:20\n    |\n LL | extern \"C\" fn f2_3(..., x: isize) {}\n-   |                    ^^^^\n+   |                    ^^^\n \n error: only foreign or `unsafe extern \"C\" functions may be C-variadic\n   --> $DIR/variadic-ffi-semantic-restrictions.rs:19:20\n    |\n LL | extern \"C\" fn f2_3(..., x: isize) {}\n-   |                    ^^^^\n+   |                    ^^^\n \n error: only foreign or `unsafe extern \"C\" functions may be C-variadic\n   --> $DIR/variadic-ffi-semantic-restrictions.rs:23:26\n    |\n LL | extern fn f3_1(x: isize, ...) {}\n-   |                          ^^^^\n+   |                          ^^^\n \n error: C-variadic function must be declared with at least one named argument\n   --> $DIR/variadic-ffi-semantic-restrictions.rs:26:16\n    |\n LL | extern fn f3_2(...) {}\n-   |                ^^^^\n+   |                ^^^\n \n error: only foreign or `unsafe extern \"C\" functions may be C-variadic\n   --> $DIR/variadic-ffi-semantic-restrictions.rs:26:16\n    |\n LL | extern fn f3_2(...) {}\n-   |                ^^^^\n+   |                ^^^\n \n error: `...` must be the last argument of a C-variadic function\n   --> $DIR/variadic-ffi-semantic-restrictions.rs:30:16\n    |\n LL | extern fn f3_3(..., x: isize) {}\n-   |                ^^^^\n+   |                ^^^\n \n error: only foreign or `unsafe extern \"C\" functions may be C-variadic\n   --> $DIR/variadic-ffi-semantic-restrictions.rs:30:16\n    |\n LL | extern fn f3_3(..., x: isize) {}\n-   |                ^^^^\n+   |                ^^^\n \n error: C-variadic function must be declared with at least one named argument\n   --> $DIR/variadic-ffi-semantic-restrictions.rs:35:13\n    |\n LL |     fn e_f1(...);\n-   |             ^^^^\n+   |             ^^^\n \n error: `...` must be the last argument of a C-variadic function\n   --> $DIR/variadic-ffi-semantic-restrictions.rs:37:13\n    |\n LL |     fn e_f2(..., x: isize);\n-   |             ^^^^\n+   |             ^^^\n \n error: only foreign or `unsafe extern \"C\" functions may be C-variadic\n   --> $DIR/variadic-ffi-semantic-restrictions.rs:44:23\n    |\n LL |     fn i_f1(x: isize, ...) {}\n-   |                       ^^^^\n+   |                       ^^^\n \n error: C-variadic function must be declared with at least one named argument\n   --> $DIR/variadic-ffi-semantic-restrictions.rs:46:13\n    |\n LL |     fn i_f2(...) {}\n-   |             ^^^^\n+   |             ^^^\n \n error: only foreign or `unsafe extern \"C\" functions may be C-variadic\n   --> $DIR/variadic-ffi-semantic-restrictions.rs:46:13\n    |\n LL |     fn i_f2(...) {}\n-   |             ^^^^\n+   |             ^^^\n \n error: `...` must be the last argument of a C-variadic function\n   --> $DIR/variadic-ffi-semantic-restrictions.rs:49:13\n    |\n LL |     fn i_f3(..., x: isize, ...) {}\n-   |             ^^^^\n+   |             ^^^\n \n error: only foreign or `unsafe extern \"C\" functions may be C-variadic\n   --> $DIR/variadic-ffi-semantic-restrictions.rs:49:13\n    |\n LL |     fn i_f3(..., x: isize, ...) {}\n-   |             ^^^^\n+   |             ^^^\n \n error: only foreign or `unsafe extern \"C\" functions may be C-variadic\n   --> $DIR/variadic-ffi-semantic-restrictions.rs:49:28\n    |\n LL |     fn i_f3(..., x: isize, ...) {}\n-   |                            ^^^^\n+   |                            ^^^\n \n error: `...` must be the last argument of a C-variadic function\n   --> $DIR/variadic-ffi-semantic-restrictions.rs:53:13\n    |\n LL |     fn i_f4(..., x: isize, ...) {}\n-   |             ^^^^\n+   |             ^^^\n \n error: only foreign or `unsafe extern \"C\" functions may be C-variadic\n   --> $DIR/variadic-ffi-semantic-restrictions.rs:53:13\n    |\n LL |     fn i_f4(..., x: isize, ...) {}\n-   |             ^^^^\n+   |             ^^^\n \n error: only foreign or `unsafe extern \"C\" functions may be C-variadic\n   --> $DIR/variadic-ffi-semantic-restrictions.rs:53:28\n    |\n LL |     fn i_f4(..., x: isize, ...) {}\n-   |                            ^^^^\n+   |                            ^^^\n \n error: only foreign or `unsafe extern \"C\" functions may be C-variadic\n   --> $DIR/variadic-ffi-semantic-restrictions.rs:60:23\n    |\n LL |     fn t_f1(x: isize, ...) {}\n-   |                       ^^^^\n+   |                       ^^^\n \n error: only foreign or `unsafe extern \"C\" functions may be C-variadic\n   --> $DIR/variadic-ffi-semantic-restrictions.rs:62:23\n    |\n LL |     fn t_f2(x: isize, ...);\n-   |                       ^^^^\n+   |                       ^^^\n \n error: C-variadic function must be declared with at least one named argument\n   --> $DIR/variadic-ffi-semantic-restrictions.rs:64:13\n    |\n LL |     fn t_f3(...) {}\n-   |             ^^^^\n+   |             ^^^\n \n error: only foreign or `unsafe extern \"C\" functions may be C-variadic\n   --> $DIR/variadic-ffi-semantic-restrictions.rs:64:13\n    |\n LL |     fn t_f3(...) {}\n-   |             ^^^^\n+   |             ^^^\n \n error: C-variadic function must be declared with at least one named argument\n   --> $DIR/variadic-ffi-semantic-restrictions.rs:67:13\n    |\n LL |     fn t_f4(...);\n-   |             ^^^^\n+   |             ^^^\n \n error: only foreign or `unsafe extern \"C\" functions may be C-variadic\n   --> $DIR/variadic-ffi-semantic-restrictions.rs:67:13\n    |\n LL |     fn t_f4(...);\n-   |             ^^^^\n+   |             ^^^\n \n error: `...` must be the last argument of a C-variadic function\n   --> $DIR/variadic-ffi-semantic-restrictions.rs:70:13\n    |\n LL |     fn t_f5(..., x: isize) {}\n-   |             ^^^^\n+   |             ^^^\n \n error: only foreign or `unsafe extern \"C\" functions may be C-variadic\n   --> $DIR/variadic-ffi-semantic-restrictions.rs:70:13\n    |\n LL |     fn t_f5(..., x: isize) {}\n-   |             ^^^^\n+   |             ^^^\n \n error: `...` must be the last argument of a C-variadic function\n   --> $DIR/variadic-ffi-semantic-restrictions.rs:73:13\n    |\n LL |     fn t_f6(..., x: isize);\n-   |             ^^^^\n+   |             ^^^\n \n error: only foreign or `unsafe extern \"C\" functions may be C-variadic\n   --> $DIR/variadic-ffi-semantic-restrictions.rs:73:13\n    |\n LL |     fn t_f6(..., x: isize);\n-   |             ^^^^\n+   |             ^^^\n \n error: aborting due to 34 previous errors\n "}, {"sha": "ba9543bf738697fd36c0e26795f1a9bc609e480d", "filename": "src/test/ui/pattern/bindings-after-at/bind-by-move-neither-can-live-while-the-other-survives-1.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fbind-by-move-neither-can-live-while-the-other-survives-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fbind-by-move-neither-can-live-while-the-other-survives-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fbind-by-move-neither-can-live-while-the-other-survives-1.rs?ref=b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7", "patch": "@@ -3,7 +3,6 @@\n // where one side is by-ref and the other is by-move.\n \n #![feature(bindings_after_at)]\n-#![feature(move_ref_pattern)]\n \n struct X {\n     x: (),"}, {"sha": "44dbcb9a75466420d8036963d2fd966ffcc32123", "filename": "src/test/ui/pattern/bindings-after-at/bind-by-move-neither-can-live-while-the-other-survives-1.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fbind-by-move-neither-can-live-while-the-other-survives-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fbind-by-move-neither-can-live-while-the-other-survives-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fbind-by-move-neither-can-live-while-the-other-survives-1.stderr?ref=b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7", "patch": "@@ -1,5 +1,5 @@\n error: cannot move out of value because it is borrowed\n-  --> $DIR/bind-by-move-neither-can-live-while-the-other-survives-1.rs:15:14\n+  --> $DIR/bind-by-move-neither-can-live-while-the-other-survives-1.rs:14:14\n    |\n LL |         Some(ref _y @ _z) => {}\n    |              ------^^^--\n@@ -8,7 +8,7 @@ LL |         Some(ref _y @ _z) => {}\n    |              value borrowed, by `_y`, here\n \n error: borrow of moved value\n-  --> $DIR/bind-by-move-neither-can-live-while-the-other-survives-1.rs:21:14\n+  --> $DIR/bind-by-move-neither-can-live-while-the-other-survives-1.rs:20:14\n    |\n LL |         Some(_z @ ref _y) => {}\n    |              --^^^------\n@@ -18,7 +18,7 @@ LL |         Some(_z @ ref _y) => {}\n    |              move occurs because `_z` has type `X` which does not implement the `Copy` trait\n \n error: cannot move out of value because it is borrowed\n-  --> $DIR/bind-by-move-neither-can-live-while-the-other-survives-1.rs:29:14\n+  --> $DIR/bind-by-move-neither-can-live-while-the-other-survives-1.rs:28:14\n    |\n LL |         Some(ref mut _y @ _z) => {}\n    |              ----------^^^--\n@@ -27,7 +27,7 @@ LL |         Some(ref mut _y @ _z) => {}\n    |              value borrowed, by `_y`, here\n \n error: borrow of moved value\n-  --> $DIR/bind-by-move-neither-can-live-while-the-other-survives-1.rs:35:14\n+  --> $DIR/bind-by-move-neither-can-live-while-the-other-survives-1.rs:34:14\n    |\n LL |         Some(_z @ ref mut _y) => {}\n    |              --^^^----------\n@@ -37,7 +37,7 @@ LL |         Some(_z @ ref mut _y) => {}\n    |              move occurs because `_z` has type `X` which does not implement the `Copy` trait\n \n error[E0382]: borrow of moved value\n-  --> $DIR/bind-by-move-neither-can-live-while-the-other-survives-1.rs:21:19\n+  --> $DIR/bind-by-move-neither-can-live-while-the-other-survives-1.rs:20:19\n    |\n LL |         Some(_z @ ref _y) => {}\n    |              -----^^^^^^\n@@ -52,7 +52,7 @@ LL |         Some(ref _z @ ref _y) => {}\n    |              ^^^\n \n error[E0382]: borrow of moved value\n-  --> $DIR/bind-by-move-neither-can-live-while-the-other-survives-1.rs:35:19\n+  --> $DIR/bind-by-move-neither-can-live-while-the-other-survives-1.rs:34:19\n    |\n LL |         Some(_z @ ref mut _y) => {}\n    |              -----^^^^^^^^^^"}, {"sha": "3ab6f40725cfb2426c270895f5825d7e13da05d4", "filename": "src/test/ui/pattern/bindings-after-at/bind-by-move-no-subbindings-fun-param.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fbind-by-move-no-subbindings-fun-param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fbind-by-move-no-subbindings-fun-param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fbind-by-move-no-subbindings-fun-param.rs?ref=b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7", "patch": "@@ -1,7 +1,6 @@\n // See issue #12534.\n \n #![feature(bindings_after_at)]\n-#![feature(move_ref_pattern)]\n \n fn main() {}\n "}, {"sha": "f25d5a2d9b82d6cdbac5478796015a81fa092157", "filename": "src/test/ui/pattern/bindings-after-at/bind-by-move-no-subbindings-fun-param.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fbind-by-move-no-subbindings-fun-param.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fbind-by-move-no-subbindings-fun-param.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fbind-by-move-no-subbindings-fun-param.stderr?ref=b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7", "patch": "@@ -1,5 +1,5 @@\n error[E0382]: use of moved value\n-  --> $DIR/bind-by-move-no-subbindings-fun-param.rs:10:12\n+  --> $DIR/bind-by-move-no-subbindings-fun-param.rs:9:12\n    |\n LL | fn f(a @ A(u): A) -> Box<u8> {\n    |      ------^-"}, {"sha": "d014c9828da2a04bf1bb7ee2ebd31b41315b38ee", "filename": "src/test/ui/pattern/bindings-after-at/borrowck-move-and-move.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-move-and-move.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-move-and-move.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-move-and-move.rs?ref=b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7", "patch": "@@ -1,7 +1,6 @@\n // Test that moving on both sides of an `@` pattern is not allowed.\n \n #![feature(bindings_after_at)]\n-#![feature(move_ref_pattern)]\n \n fn main() {\n     struct U; // Not copy!"}, {"sha": "5039f580ff6eac482d617ee67f2db16d00ae217a", "filename": "src/test/ui/pattern/bindings-after-at/borrowck-move-and-move.stderr", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-move-and-move.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-move-and-move.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-move-and-move.stderr?ref=b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7", "patch": "@@ -1,5 +1,5 @@\n error[E0382]: use of moved value\n-  --> $DIR/borrowck-move-and-move.rs:14:13\n+  --> $DIR/borrowck-move-and-move.rs:13:13\n    |\n LL |     let a @ b = U;\n    |         ----^   - move occurs because value has type `U`, which does not implement the `Copy` trait\n@@ -8,7 +8,7 @@ LL |     let a @ b = U;\n    |         value moved here\n \n error[E0382]: use of moved value\n-  --> $DIR/borrowck-move-and-move.rs:16:17\n+  --> $DIR/borrowck-move-and-move.rs:15:17\n    |\n LL |     let a @ (b, c) = (U, U);\n    |         --------^-   ------ move occurs because value has type `(U, U)`, which does not implement the `Copy` trait\n@@ -17,7 +17,7 @@ LL |     let a @ (b, c) = (U, U);\n    |         value moved here\n \n error[E0382]: use of moved value\n-  --> $DIR/borrowck-move-and-move.rs:18:17\n+  --> $DIR/borrowck-move-and-move.rs:17:17\n    |\n LL |     let a @ (b, c) = (u(), u());\n    |         --------^-   ---------- move occurs because value has type `(U, U)`, which does not implement the `Copy` trait\n@@ -26,7 +26,7 @@ LL |     let a @ (b, c) = (u(), u());\n    |         value moved here\n \n error[E0382]: use of moved value\n-  --> $DIR/borrowck-move-and-move.rs:21:16\n+  --> $DIR/borrowck-move-and-move.rs:20:16\n    |\n LL |     match Ok(U) {\n    |           ----- move occurs because value has type `std::result::Result<U, U>`, which does not implement the `Copy` trait\n@@ -37,7 +37,7 @@ LL |         a @ Ok(b) | a @ Err(b) => {}\n    |         value moved here\n \n error[E0382]: use of moved value\n-  --> $DIR/borrowck-move-and-move.rs:21:29\n+  --> $DIR/borrowck-move-and-move.rs:20:29\n    |\n LL |     match Ok(U) {\n    |           ----- move occurs because value has type `std::result::Result<U, U>`, which does not implement the `Copy` trait\n@@ -48,7 +48,7 @@ LL |         a @ Ok(b) | a @ Err(b) => {}\n    |                     value moved here\n \n error[E0382]: use of moved value\n-  --> $DIR/borrowck-move-and-move.rs:28:22\n+  --> $DIR/borrowck-move-and-move.rs:27:22\n    |\n LL |     match [u(), u(), u(), u()] {\n    |           -------------------- move occurs because value has type `[U; 4]`, which does not implement the `Copy` trait\n@@ -59,7 +59,7 @@ LL |         xs @ [a, .., b] => {}\n    |         value moved here\n \n error[E0382]: use of moved value\n-  --> $DIR/borrowck-move-and-move.rs:32:18\n+  --> $DIR/borrowck-move-and-move.rs:31:18\n    |\n LL |     match [u(), u(), u(), u()] {\n    |           -------------------- move occurs because value has type `[U; 4]`, which does not implement the `Copy` trait\n@@ -70,7 +70,7 @@ LL |         xs @ [_, ys @ .., _] => {}\n    |         value moved here\n \n error[E0382]: use of moved value\n-  --> $DIR/borrowck-move-and-move.rs:25:16\n+  --> $DIR/borrowck-move-and-move.rs:24:16\n    |\n LL |     fn fun(a @ b: U) {}\n    |            ----^"}, {"sha": "f1ee87bc9c69b40671e55458aa4a3d25b3eb9378", "filename": "src/test/ui/pattern/bindings-after-at/borrowck-pat-at-and-box-pass.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-at-and-box-pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-at-and-box-pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-at-and-box-pass.rs?ref=b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7", "patch": "@@ -3,7 +3,6 @@\n // Test `@` patterns combined with `box` patterns.\n \n #![feature(bindings_after_at)]\n-#![feature(move_ref_pattern)]\n #![feature(box_patterns)]\n \n #[derive(Copy, Clone)]"}, {"sha": "236710ed85493d75876d2e704eb7d2af1837387c", "filename": "src/test/ui/pattern/bindings-after-at/borrowck-pat-at-and-box.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-at-and-box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-at-and-box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-at-and-box.rs?ref=b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7", "patch": "@@ -1,7 +1,6 @@\n // Test `@` patterns combined with `box` patterns.\n \n #![feature(bindings_after_at)]\n-#![feature(move_ref_pattern)]\n #![feature(box_patterns)]\n \n #[derive(Copy, Clone)]"}, {"sha": "d9a8bbfb6b103f473a4cf655c8488d29c95c654f", "filename": "src/test/ui/pattern/bindings-after-at/borrowck-pat-at-and-box.stderr", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-at-and-box.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-at-and-box.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-at-and-box.stderr?ref=b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7", "patch": "@@ -1,5 +1,5 @@\n error: cannot move out of value because it is borrowed\n-  --> $DIR/borrowck-pat-at-and-box.rs:37:9\n+  --> $DIR/borrowck-pat-at-and-box.rs:36:9\n    |\n LL |     let ref a @ box b = Box::new(NC);\n    |         -----^^^^^^^-\n@@ -8,7 +8,7 @@ LL |     let ref a @ box b = Box::new(NC);\n    |         value borrowed, by `a`, here\n \n error: cannot borrow value as mutable because it is also borrowed as immutable\n-  --> $DIR/borrowck-pat-at-and-box.rs:39:9\n+  --> $DIR/borrowck-pat-at-and-box.rs:38:9\n    |\n LL |     let ref a @ box ref mut b = Box::new(nc());\n    |         -----^^^^^^^---------\n@@ -17,7 +17,7 @@ LL |     let ref a @ box ref mut b = Box::new(nc());\n    |         immutable borrow, by `a`, occurs here\n \n error: cannot borrow value as mutable because it is also borrowed as immutable\n-  --> $DIR/borrowck-pat-at-and-box.rs:41:9\n+  --> $DIR/borrowck-pat-at-and-box.rs:40:9\n    |\n LL |     let ref a @ box ref mut b = Box::new(NC);\n    |         -----^^^^^^^---------\n@@ -26,7 +26,7 @@ LL |     let ref a @ box ref mut b = Box::new(NC);\n    |         immutable borrow, by `a`, occurs here\n \n error: cannot borrow value as mutable because it is also borrowed as immutable\n-  --> $DIR/borrowck-pat-at-and-box.rs:43:9\n+  --> $DIR/borrowck-pat-at-and-box.rs:42:9\n    |\n LL |     let ref a @ box ref mut b = Box::new(NC);\n    |         -----^^^^^^^---------\n@@ -35,7 +35,7 @@ LL |     let ref a @ box ref mut b = Box::new(NC);\n    |         immutable borrow, by `a`, occurs here\n \n error: cannot borrow value as mutable because it is also borrowed as immutable\n-  --> $DIR/borrowck-pat-at-and-box.rs:46:9\n+  --> $DIR/borrowck-pat-at-and-box.rs:45:9\n    |\n LL |     let ref a @ box ref mut b = Box::new(NC);\n    |         -----^^^^^^^---------\n@@ -44,7 +44,7 @@ LL |     let ref a @ box ref mut b = Box::new(NC);\n    |         immutable borrow, by `a`, occurs here\n \n error: cannot borrow value as immutable because it is also borrowed as mutable\n-  --> $DIR/borrowck-pat-at-and-box.rs:52:9\n+  --> $DIR/borrowck-pat-at-and-box.rs:51:9\n    |\n LL |     let ref mut a @ box ref b = Box::new(NC);\n    |         ---------^^^^^^^-----\n@@ -53,7 +53,7 @@ LL |     let ref mut a @ box ref b = Box::new(NC);\n    |         mutable borrow, by `a`, occurs here\n \n error: cannot borrow value as immutable because it is also borrowed as mutable\n-  --> $DIR/borrowck-pat-at-and-box.rs:66:9\n+  --> $DIR/borrowck-pat-at-and-box.rs:65:9\n    |\n LL |         ref mut a @ box ref b => {\n    |         ---------^^^^^^^-----\n@@ -62,7 +62,7 @@ LL |         ref mut a @ box ref b => {\n    |         mutable borrow, by `a`, occurs here\n \n error: cannot borrow value as immutable because it is also borrowed as mutable\n-  --> $DIR/borrowck-pat-at-and-box.rs:58:11\n+  --> $DIR/borrowck-pat-at-and-box.rs:57:11\n    |\n LL |     fn f5(ref mut a @ box ref b: Box<NC>) {\n    |           ---------^^^^^^^-----\n@@ -71,7 +71,7 @@ LL |     fn f5(ref mut a @ box ref b: Box<NC>) {\n    |           mutable borrow, by `a`, occurs here\n \n error[E0382]: use of moved value\n-  --> $DIR/borrowck-pat-at-and-box.rs:21:18\n+  --> $DIR/borrowck-pat-at-and-box.rs:20:18\n    |\n LL |     let a @ box &b = Box::new(&C);\n    |         ---------^   ------------ move occurs because value has type `Box<&C>`, which does not implement the `Copy` trait\n@@ -80,7 +80,7 @@ LL |     let a @ box &b = Box::new(&C);\n    |         value moved here\n \n error[E0382]: use of moved value\n-  --> $DIR/borrowck-pat-at-and-box.rs:24:17\n+  --> $DIR/borrowck-pat-at-and-box.rs:23:17\n    |\n LL |     let a @ box b = Box::new(C);\n    |         --------^   ----------- move occurs because value has type `Box<C>`, which does not implement the `Copy` trait\n@@ -89,7 +89,7 @@ LL |     let a @ box b = Box::new(C);\n    |         value moved here\n \n error[E0382]: use of moved value\n-  --> $DIR/borrowck-pat-at-and-box.rs:34:17\n+  --> $DIR/borrowck-pat-at-and-box.rs:33:17\n    |\n LL |     match Box::new(C) {\n    |           ----------- move occurs because value has type `Box<C>`, which does not implement the `Copy` trait\n@@ -100,7 +100,7 @@ LL |         a @ box b => {}\n    |         value moved here\n \n error[E0502]: cannot borrow value as mutable because it is also borrowed as immutable\n-  --> $DIR/borrowck-pat-at-and-box.rs:46:21\n+  --> $DIR/borrowck-pat-at-and-box.rs:45:21\n    |\n LL |     let ref a @ box ref mut b = Box::new(NC);\n    |         ------------^^^^^^^^^\n@@ -112,7 +112,7 @@ LL |     drop(a);\n    |          - immutable borrow later used here\n \n error[E0502]: cannot borrow value as immutable because it is also borrowed as mutable\n-  --> $DIR/borrowck-pat-at-and-box.rs:52:25\n+  --> $DIR/borrowck-pat-at-and-box.rs:51:25\n    |\n LL |     let ref mut a @ box ref b = Box::new(NC);\n    |         ----------------^^^^^\n@@ -124,7 +124,7 @@ LL |     *a = Box::new(NC);\n    |     -- mutable borrow later used here\n \n error[E0502]: cannot borrow value as immutable because it is also borrowed as mutable\n-  --> $DIR/borrowck-pat-at-and-box.rs:66:25\n+  --> $DIR/borrowck-pat-at-and-box.rs:65:25\n    |\n LL |         ref mut a @ box ref b => {\n    |         ----------------^^^^^\n@@ -136,7 +136,7 @@ LL |             *a = Box::new(NC);\n    |             -- mutable borrow later used here\n \n error[E0382]: use of moved value\n-  --> $DIR/borrowck-pat-at-and-box.rs:27:20\n+  --> $DIR/borrowck-pat-at-and-box.rs:26:20\n    |\n LL |     fn f1(a @ box &b: Box<&C>) {}\n    |           ---------^\n@@ -146,7 +146,7 @@ LL |     fn f1(a @ box &b: Box<&C>) {}\n    |           move occurs because value has type `Box<&C>`, which does not implement the `Copy` trait\n \n error[E0382]: use of moved value\n-  --> $DIR/borrowck-pat-at-and-box.rs:30:19\n+  --> $DIR/borrowck-pat-at-and-box.rs:29:19\n    |\n LL |     fn f2(a @ box b: Box<C>) {}\n    |           --------^\n@@ -156,7 +156,7 @@ LL |     fn f2(a @ box b: Box<C>) {}\n    |           move occurs because value has type `Box<C>`, which does not implement the `Copy` trait\n \n error[E0502]: cannot borrow value as immutable because it is also borrowed as mutable\n-  --> $DIR/borrowck-pat-at-and-box.rs:58:27\n+  --> $DIR/borrowck-pat-at-and-box.rs:57:27\n    |\n LL |     fn f5(ref mut a @ box ref b: Box<NC>) {\n    |           ----------------^^^^^"}, {"sha": "a22d27763d261fee7cd722636194aeb82124eafe", "filename": "src/test/ui/pattern/bindings-after-at/borrowck-pat-by-move-and-ref-inverse-promotion.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-by-move-and-ref-inverse-promotion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-by-move-and-ref-inverse-promotion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-by-move-and-ref-inverse-promotion.rs?ref=b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7", "patch": "@@ -2,7 +2,6 @@\n // Currently this logic exists in THIR match checking as opposed to borrowck.\n \n #![feature(bindings_after_at)]\n-#![feature(move_ref_pattern)]\n \n fn main() {\n     struct U;"}, {"sha": "0e09d478e3a1044d41350df40981db51b7ff0e17", "filename": "src/test/ui/pattern/bindings-after-at/borrowck-pat-by-move-and-ref-inverse-promotion.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-by-move-and-ref-inverse-promotion.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-by-move-and-ref-inverse-promotion.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-by-move-and-ref-inverse-promotion.stderr?ref=b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7", "patch": "@@ -1,5 +1,5 @@\n error: borrow of moved value\n-  --> $DIR/borrowck-pat-by-move-and-ref-inverse-promotion.rs:9:9\n+  --> $DIR/borrowck-pat-by-move-and-ref-inverse-promotion.rs:8:9\n    |\n LL |     let a @ ref b = U;\n    |         -^^^-----"}, {"sha": "3e5a543c4c36aa194bdd7d7efc220aa428eb4fb3", "filename": "src/test/ui/pattern/bindings-after-at/borrowck-pat-by-move-and-ref-inverse.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-by-move-and-ref-inverse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-by-move-and-ref-inverse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-by-move-and-ref-inverse.rs?ref=b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7", "patch": "@@ -1,7 +1,6 @@\n // Test that `by_move_binding @ pat_with_by_ref_bindings` is prevented.\n \n #![feature(bindings_after_at)]\n-#![feature(move_ref_pattern)]\n \n fn main() {\n     struct U;"}, {"sha": "282031aeb075413898a9a5e561527c2246d9d4c2", "filename": "src/test/ui/pattern/bindings-after-at/borrowck-pat-by-move-and-ref-inverse.stderr", "status": "modified", "additions": 48, "deletions": 48, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-by-move-and-ref-inverse.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-by-move-and-ref-inverse.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-by-move-and-ref-inverse.stderr?ref=b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7", "patch": "@@ -1,5 +1,5 @@\n error: borrow of moved value\n-  --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:29:9\n+  --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:28:9\n    |\n LL |     let a @ ref b = U;\n    |         -^^^-----\n@@ -9,7 +9,7 @@ LL |     let a @ ref b = U;\n    |         move occurs because `a` has type `U` which does not implement the `Copy` trait\n \n error: borrow of moved value\n-  --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:31:9\n+  --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:30:9\n    |\n LL |     let a @ (mut b @ ref mut c, d @ ref e) = (U, U);\n    |         -^^^^^^^^^^^^---------^^^^^^-----^\n@@ -20,7 +20,7 @@ LL |     let a @ (mut b @ ref mut c, d @ ref e) = (U, U);\n    |         move occurs because `a` has type `(U, U)` which does not implement the `Copy` trait\n \n error: borrow of moved value\n-  --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:31:14\n+  --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:30:14\n    |\n LL |     let a @ (mut b @ ref mut c, d @ ref e) = (U, U);\n    |              -----^^^---------\n@@ -30,7 +30,7 @@ LL |     let a @ (mut b @ ref mut c, d @ ref e) = (U, U);\n    |              move occurs because `b` has type `U` which does not implement the `Copy` trait\n \n error: borrow of moved value\n-  --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:31:33\n+  --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:30:33\n    |\n LL |     let a @ (mut b @ ref mut c, d @ ref e) = (U, U);\n    |                                 -^^^-----\n@@ -40,7 +40,7 @@ LL |     let a @ (mut b @ ref mut c, d @ ref e) = (U, U);\n    |                                 move occurs because `d` has type `U` which does not implement the `Copy` trait\n \n error: borrow of moved value\n-  --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:38:9\n+  --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:37:9\n    |\n LL |     let a @ [ref mut b, ref c] = [U, U];\n    |         -^^^^---------^^-----^\n@@ -51,7 +51,7 @@ LL |     let a @ [ref mut b, ref c] = [U, U];\n    |         move occurs because `a` has type `[U; 2]` which does not implement the `Copy` trait\n \n error: borrow of moved value\n-  --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:41:9\n+  --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:40:9\n    |\n LL |     let a @ ref b = u();\n    |         -^^^-----\n@@ -61,7 +61,7 @@ LL |     let a @ ref b = u();\n    |         move occurs because `a` has type `U` which does not implement the `Copy` trait\n \n error: borrow of moved value\n-  --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:44:9\n+  --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:43:9\n    |\n LL |     let a @ (mut b @ ref mut c, d @ ref e) = (u(), u());\n    |         -^^^^^^^^^^^^---------^^^^^^-----^\n@@ -72,7 +72,7 @@ LL |     let a @ (mut b @ ref mut c, d @ ref e) = (u(), u());\n    |         move occurs because `a` has type `(U, U)` which does not implement the `Copy` trait\n \n error: borrow of moved value\n-  --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:44:14\n+  --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:43:14\n    |\n LL |     let a @ (mut b @ ref mut c, d @ ref e) = (u(), u());\n    |              -----^^^---------\n@@ -82,7 +82,7 @@ LL |     let a @ (mut b @ ref mut c, d @ ref e) = (u(), u());\n    |              move occurs because `b` has type `U` which does not implement the `Copy` trait\n \n error: borrow of moved value\n-  --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:44:33\n+  --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:43:33\n    |\n LL |     let a @ (mut b @ ref mut c, d @ ref e) = (u(), u());\n    |                                 -^^^-----\n@@ -92,7 +92,7 @@ LL |     let a @ (mut b @ ref mut c, d @ ref e) = (u(), u());\n    |                                 move occurs because `d` has type `U` which does not implement the `Copy` trait\n \n error: borrow of moved value\n-  --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:51:9\n+  --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:50:9\n    |\n LL |     let a @ [ref mut b, ref c] = [u(), u()];\n    |         -^^^^---------^^-----^\n@@ -103,7 +103,7 @@ LL |     let a @ [ref mut b, ref c] = [u(), u()];\n    |         move occurs because `a` has type `[U; 2]` which does not implement the `Copy` trait\n \n error: borrow of moved value\n-  --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:56:9\n+  --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:55:9\n    |\n LL |         a @ Some(ref b) => {}\n    |         -^^^^^^^^-----^\n@@ -113,7 +113,7 @@ LL |         a @ Some(ref b) => {}\n    |         move occurs because `a` has type `Option<U>` which does not implement the `Copy` trait\n \n error: borrow of moved value\n-  --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:61:9\n+  --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:60:9\n    |\n LL |         a @ Some((mut b @ ref mut c, d @ ref e)) => {}\n    |         -^^^^^^^^^^^^^^^^^---------^^^^^^-----^^\n@@ -124,7 +124,7 @@ LL |         a @ Some((mut b @ ref mut c, d @ ref e)) => {}\n    |         move occurs because `a` has type `Option<(U, U)>` which does not implement the `Copy` trait\n \n error: borrow of moved value\n-  --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:61:19\n+  --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:60:19\n    |\n LL |         a @ Some((mut b @ ref mut c, d @ ref e)) => {}\n    |                   -----^^^---------\n@@ -134,7 +134,7 @@ LL |         a @ Some((mut b @ ref mut c, d @ ref e)) => {}\n    |                   move occurs because `b` has type `U` which does not implement the `Copy` trait\n \n error: borrow of moved value\n-  --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:61:38\n+  --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:60:38\n    |\n LL |         a @ Some((mut b @ ref mut c, d @ ref e)) => {}\n    |                                      -^^^-----\n@@ -144,7 +144,7 @@ LL |         a @ Some((mut b @ ref mut c, d @ ref e)) => {}\n    |                                      move occurs because `d` has type `U` which does not implement the `Copy` trait\n \n error: borrow of moved value\n-  --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:71:9\n+  --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:70:9\n    |\n LL |         mut a @ Some([ref b, ref mut c]) => {}\n    |         -----^^^^^^^^^-----^^---------^^\n@@ -155,7 +155,7 @@ LL |         mut a @ Some([ref b, ref mut c]) => {}\n    |         move occurs because `a` has type `Option<[U; 2]>` which does not implement the `Copy` trait\n \n error: borrow of moved value\n-  --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:77:9\n+  --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:76:9\n    |\n LL |         a @ Some(ref b) => {}\n    |         -^^^^^^^^-----^\n@@ -165,7 +165,7 @@ LL |         a @ Some(ref b) => {}\n    |         move occurs because `a` has type `Option<U>` which does not implement the `Copy` trait\n \n error: borrow of moved value\n-  --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:83:9\n+  --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:82:9\n    |\n LL |         a @ Some((mut b @ ref mut c, d @ ref e)) => {}\n    |         -^^^^^^^^^^^^^^^^^---------^^^^^^-----^^\n@@ -176,7 +176,7 @@ LL |         a @ Some((mut b @ ref mut c, d @ ref e)) => {}\n    |         move occurs because `a` has type `Option<(U, U)>` which does not implement the `Copy` trait\n \n error: borrow of moved value\n-  --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:83:19\n+  --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:82:19\n    |\n LL |         a @ Some((mut b @ ref mut c, d @ ref e)) => {}\n    |                   -----^^^---------\n@@ -186,7 +186,7 @@ LL |         a @ Some((mut b @ ref mut c, d @ ref e)) => {}\n    |                   move occurs because `b` has type `U` which does not implement the `Copy` trait\n \n error: borrow of moved value\n-  --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:83:38\n+  --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:82:38\n    |\n LL |         a @ Some((mut b @ ref mut c, d @ ref e)) => {}\n    |                                      -^^^-----\n@@ -196,7 +196,7 @@ LL |         a @ Some((mut b @ ref mut c, d @ ref e)) => {}\n    |                                      move occurs because `d` has type `U` which does not implement the `Copy` trait\n \n error: borrow of moved value\n-  --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:93:9\n+  --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:92:9\n    |\n LL |         mut a @ Some([ref b, ref mut c]) => {}\n    |         -----^^^^^^^^^-----^^---------^^\n@@ -207,7 +207,7 @@ LL |         mut a @ Some([ref b, ref mut c]) => {}\n    |         move occurs because `a` has type `Option<[U; 2]>` which does not implement the `Copy` trait\n \n error: borrow of moved value\n-  --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:14:11\n+  --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:13:11\n    |\n LL |     fn f1(a @ ref b: U) {}\n    |           -^^^-----\n@@ -217,7 +217,7 @@ LL |     fn f1(a @ ref b: U) {}\n    |           move occurs because `a` has type `U` which does not implement the `Copy` trait\n \n error: borrow of moved value\n-  --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:18:11\n+  --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:17:11\n    |\n LL |     fn f2(mut a @ (b @ ref c, mut d @ ref e): (U, U)) {}\n    |           -----^^^^^^^^-----^^^^^^^^^^-----^\n@@ -228,7 +228,7 @@ LL |     fn f2(mut a @ (b @ ref c, mut d @ ref e): (U, U)) {}\n    |           move occurs because `a` has type `(U, U)` which does not implement the `Copy` trait\n \n error: borrow of moved value\n-  --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:18:20\n+  --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:17:20\n    |\n LL |     fn f2(mut a @ (b @ ref c, mut d @ ref e): (U, U)) {}\n    |                    -^^^-----\n@@ -238,7 +238,7 @@ LL |     fn f2(mut a @ (b @ ref c, mut d @ ref e): (U, U)) {}\n    |                    move occurs because `b` has type `U` which does not implement the `Copy` trait\n \n error: borrow of moved value\n-  --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:18:31\n+  --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:17:31\n    |\n LL |     fn f2(mut a @ (b @ ref c, mut d @ ref e): (U, U)) {}\n    |                               -----^^^-----\n@@ -248,7 +248,7 @@ LL |     fn f2(mut a @ (b @ ref c, mut d @ ref e): (U, U)) {}\n    |                               move occurs because `d` has type `U` which does not implement the `Copy` trait\n \n error: borrow of moved value\n-  --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:25:11\n+  --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:24:11\n    |\n LL |     fn f3(a @ [ref mut b, ref c]: [U; 2]) {}\n    |           -^^^^---------^^-----^\n@@ -259,7 +259,7 @@ LL |     fn f3(a @ [ref mut b, ref c]: [U; 2]) {}\n    |           move occurs because `a` has type `[U; 2]` which does not implement the `Copy` trait\n \n error[E0382]: borrow of moved value\n-  --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:31:22\n+  --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:30:22\n    |\n LL |     let a @ (mut b @ ref mut c, d @ ref e) = (U, U);\n    |              --------^^^^^^^^^\n@@ -270,7 +270,7 @@ LL |     let a @ (mut b @ ref mut c, d @ ref e) = (U, U);\n    = note: move occurs because value has type `U`, which does not implement the `Copy` trait\n \n error[E0382]: use of moved value\n-  --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:31:33\n+  --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:30:33\n    |\n LL |     let a @ (mut b @ ref mut c, d @ ref e) = (U, U);\n    |         ------------------------^^^^^^^^^-   ------ move occurs because value has type `(U, U)`, which does not implement the `Copy` trait\n@@ -279,7 +279,7 @@ LL |     let a @ (mut b @ ref mut c, d @ ref e) = (U, U);\n    |         value moved here\n \n error[E0382]: borrow of moved value\n-  --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:31:37\n+  --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:30:37\n    |\n LL |     let a @ (mut b @ ref mut c, d @ ref e) = (U, U);\n    |                                 ----^^^^^\n@@ -290,7 +290,7 @@ LL |     let a @ (mut b @ ref mut c, d @ ref e) = (U, U);\n    = note: move occurs because value has type `U`, which does not implement the `Copy` trait\n \n error[E0382]: borrow of moved value\n-  --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:38:25\n+  --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:37:25\n    |\n LL |     let a @ [ref mut b, ref c] = [U, U];\n    |         ----------------^^^^^-   ------ move occurs because value has type `[U; 2]`, which does not implement the `Copy` trait\n@@ -299,7 +299,7 @@ LL |     let a @ [ref mut b, ref c] = [U, U];\n    |         value moved here\n \n error[E0382]: borrow of moved value\n-  --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:41:13\n+  --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:40:13\n    |\n LL |     let a @ ref b = u();\n    |         ----^^^^^   --- move occurs because value has type `U`, which does not implement the `Copy` trait\n@@ -308,7 +308,7 @@ LL |     let a @ ref b = u();\n    |         value moved here\n \n error[E0382]: borrow of moved value\n-  --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:44:22\n+  --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:43:22\n    |\n LL |     let a @ (mut b @ ref mut c, d @ ref e) = (u(), u());\n    |              --------^^^^^^^^^\n@@ -319,7 +319,7 @@ LL |     let a @ (mut b @ ref mut c, d @ ref e) = (u(), u());\n    = note: move occurs because value has type `U`, which does not implement the `Copy` trait\n \n error[E0382]: use of moved value\n-  --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:44:33\n+  --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:43:33\n    |\n LL |     let a @ (mut b @ ref mut c, d @ ref e) = (u(), u());\n    |         ------------------------^^^^^^^^^-   ---------- move occurs because value has type `(U, U)`, which does not implement the `Copy` trait\n@@ -328,7 +328,7 @@ LL |     let a @ (mut b @ ref mut c, d @ ref e) = (u(), u());\n    |         value moved here\n \n error[E0382]: borrow of moved value\n-  --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:44:37\n+  --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:43:37\n    |\n LL |     let a @ (mut b @ ref mut c, d @ ref e) = (u(), u());\n    |                                 ----^^^^^\n@@ -339,7 +339,7 @@ LL |     let a @ (mut b @ ref mut c, d @ ref e) = (u(), u());\n    = note: move occurs because value has type `U`, which does not implement the `Copy` trait\n \n error[E0382]: borrow of moved value\n-  --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:51:25\n+  --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:50:25\n    |\n LL |     let a @ [ref mut b, ref c] = [u(), u()];\n    |         ----------------^^^^^-   ---------- move occurs because value has type `[U; 2]`, which does not implement the `Copy` trait\n@@ -348,7 +348,7 @@ LL |     let a @ [ref mut b, ref c] = [u(), u()];\n    |         value moved here\n \n error[E0382]: borrow of moved value\n-  --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:61:27\n+  --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:60:27\n    |\n LL |         a @ Some((mut b @ ref mut c, d @ ref e)) => {}\n    |                   --------^^^^^^^^^\n@@ -363,7 +363,7 @@ LL |         a @ Some((ref mut b @ ref mut c, d @ ref e)) => {}\n    |                   ^^^\n \n error[E0382]: use of moved value\n-  --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:61:38\n+  --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:60:38\n    |\n LL |     match Some((U, U)) {\n    |           ------------ move occurs because value has type `Option<(U, U)>`, which does not implement the `Copy` trait\n@@ -374,7 +374,7 @@ LL |         a @ Some((mut b @ ref mut c, d @ ref e)) => {}\n    |         value moved here\n \n error[E0382]: borrow of moved value\n-  --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:61:42\n+  --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:60:42\n    |\n LL |         a @ Some((mut b @ ref mut c, d @ ref e)) => {}\n    |                                      ----^^^^^\n@@ -389,7 +389,7 @@ LL |         a @ Some((mut b @ ref mut c, ref d @ ref e)) => {}\n    |                                      ^^^\n \n error[E0382]: borrow of moved value\n-  --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:71:30\n+  --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:70:30\n    |\n LL |     match Some([U, U]) {\n    |           ------------ move occurs because value has type `Option<[U; 2]>`, which does not implement the `Copy` trait\n@@ -400,7 +400,7 @@ LL |         mut a @ Some([ref b, ref mut c]) => {}\n    |         value moved here\n \n error[E0382]: borrow of moved value\n-  --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:77:18\n+  --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:76:18\n    |\n LL |     match Some(u()) {\n    |           --------- move occurs because value has type `Option<U>`, which does not implement the `Copy` trait\n@@ -411,7 +411,7 @@ LL |         a @ Some(ref b) => {}\n    |         value moved here\n \n error[E0382]: borrow of moved value\n-  --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:83:27\n+  --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:82:27\n    |\n LL |         a @ Some((mut b @ ref mut c, d @ ref e)) => {}\n    |                   --------^^^^^^^^^\n@@ -426,7 +426,7 @@ LL |         a @ Some((ref mut b @ ref mut c, d @ ref e)) => {}\n    |                   ^^^\n \n error[E0382]: use of moved value\n-  --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:83:38\n+  --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:82:38\n    |\n LL |     match Some((u(), u())) {\n    |           ---------------- move occurs because value has type `Option<(U, U)>`, which does not implement the `Copy` trait\n@@ -437,7 +437,7 @@ LL |         a @ Some((mut b @ ref mut c, d @ ref e)) => {}\n    |         value moved here\n \n error[E0382]: borrow of moved value\n-  --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:83:42\n+  --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:82:42\n    |\n LL |         a @ Some((mut b @ ref mut c, d @ ref e)) => {}\n    |                                      ----^^^^^\n@@ -452,7 +452,7 @@ LL |         a @ Some((mut b @ ref mut c, ref d @ ref e)) => {}\n    |                                      ^^^\n \n error[E0382]: borrow of moved value\n-  --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:93:30\n+  --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:92:30\n    |\n LL |     match Some([u(), u()]) {\n    |           ---------------- move occurs because value has type `Option<[U; 2]>`, which does not implement the `Copy` trait\n@@ -463,7 +463,7 @@ LL |         mut a @ Some([ref b, ref mut c]) => {}\n    |         value moved here\n \n error[E0382]: borrow of moved value\n-  --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:14:15\n+  --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:13:15\n    |\n LL |     fn f1(a @ ref b: U) {}\n    |           ----^^^^^\n@@ -473,7 +473,7 @@ LL |     fn f1(a @ ref b: U) {}\n    |           move occurs because value has type `U`, which does not implement the `Copy` trait\n \n error[E0382]: borrow of moved value\n-  --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:18:24\n+  --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:17:24\n    |\n LL |     fn f2(mut a @ (b @ ref c, mut d @ ref e): (U, U)) {}\n    |                    ----^^^^^\n@@ -484,7 +484,7 @@ LL |     fn f2(mut a @ (b @ ref c, mut d @ ref e): (U, U)) {}\n    = note: move occurs because value has type `U`, which does not implement the `Copy` trait\n \n error[E0382]: use of moved value\n-  --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:18:31\n+  --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:17:31\n    |\n LL |     fn f2(mut a @ (b @ ref c, mut d @ ref e): (U, U)) {}\n    |           --------------------^^^^^^^^^^^^^-\n@@ -494,7 +494,7 @@ LL |     fn f2(mut a @ (b @ ref c, mut d @ ref e): (U, U)) {}\n    |           move occurs because value has type `(U, U)`, which does not implement the `Copy` trait\n \n error[E0382]: borrow of moved value\n-  --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:18:39\n+  --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:17:39\n    |\n LL |     fn f2(mut a @ (b @ ref c, mut d @ ref e): (U, U)) {}\n    |                               --------^^^^^\n@@ -505,7 +505,7 @@ LL |     fn f2(mut a @ (b @ ref c, mut d @ ref e): (U, U)) {}\n    = note: move occurs because value has type `U`, which does not implement the `Copy` trait\n \n error[E0382]: borrow of moved value\n-  --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:25:27\n+  --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:24:27\n    |\n LL |     fn f3(a @ [ref mut b, ref c]: [U; 2]) {}\n    |           ----------------^^^^^-"}, {"sha": "42c3290ddfbb21ee89630cb8adf53c0b0a421f1f", "filename": "src/test/ui/pattern/bindings-after-at/borrowck-pat-by-move-and-ref.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-by-move-and-ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-by-move-and-ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-by-move-and-ref.rs?ref=b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7", "patch": "@@ -1,7 +1,6 @@\n // Test that `ref mut? @ pat_with_by_move_bindings` is prevented.\n \n #![feature(bindings_after_at)]\n-#![feature(move_ref_pattern)]\n \n fn main() {\n     struct U;"}, {"sha": "a275705b19332fccffd2dd59ffea7af12b901634", "filename": "src/test/ui/pattern/bindings-after-at/borrowck-pat-by-move-and-ref.stderr", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-by-move-and-ref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-by-move-and-ref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-by-move-and-ref.stderr?ref=b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7", "patch": "@@ -1,5 +1,5 @@\n error: cannot move out of value because it is borrowed\n-  --> $DIR/borrowck-pat-by-move-and-ref.rs:23:9\n+  --> $DIR/borrowck-pat-by-move-and-ref.rs:22:9\n    |\n LL |     let ref a @ b = U;\n    |         -----^^^-\n@@ -8,7 +8,7 @@ LL |     let ref a @ b = U;\n    |         value borrowed, by `a`, here\n \n error: cannot move out of value because it is borrowed\n-  --> $DIR/borrowck-pat-by-move-and-ref.rs:25:9\n+  --> $DIR/borrowck-pat-by-move-and-ref.rs:24:9\n    |\n LL |     let ref a @ (ref b @ mut c, ref d @ e) = (U, U);\n    |         -----^^^^^^^^^^^^-----^^^^^^^^^^-^\n@@ -18,7 +18,7 @@ LL |     let ref a @ (ref b @ mut c, ref d @ e) = (U, U);\n    |         value borrowed, by `a`, here\n \n error: cannot move out of value because it is borrowed\n-  --> $DIR/borrowck-pat-by-move-and-ref.rs:25:18\n+  --> $DIR/borrowck-pat-by-move-and-ref.rs:24:18\n    |\n LL |     let ref a @ (ref b @ mut c, ref d @ e) = (U, U);\n    |                  -----^^^-----\n@@ -27,7 +27,7 @@ LL |     let ref a @ (ref b @ mut c, ref d @ e) = (U, U);\n    |                  value borrowed, by `b`, here\n \n error: cannot move out of value because it is borrowed\n-  --> $DIR/borrowck-pat-by-move-and-ref.rs:25:33\n+  --> $DIR/borrowck-pat-by-move-and-ref.rs:24:33\n    |\n LL |     let ref a @ (ref b @ mut c, ref d @ e) = (U, U);\n    |                                 -----^^^-\n@@ -36,7 +36,7 @@ LL |     let ref a @ (ref b @ mut c, ref d @ e) = (U, U);\n    |                                 value borrowed, by `d`, here\n \n error: cannot move out of value because it is borrowed\n-  --> $DIR/borrowck-pat-by-move-and-ref.rs:29:9\n+  --> $DIR/borrowck-pat-by-move-and-ref.rs:28:9\n    |\n LL |     let ref mut a @ [b, mut c] = [U, U];\n    |         ---------^^^^-^^-----^\n@@ -46,7 +46,7 @@ LL |     let ref mut a @ [b, mut c] = [U, U];\n    |         value borrowed, by `a`, here\n \n error: cannot move out of value because it is borrowed\n-  --> $DIR/borrowck-pat-by-move-and-ref.rs:31:9\n+  --> $DIR/borrowck-pat-by-move-and-ref.rs:30:9\n    |\n LL |     let ref a @ b = u();\n    |         -----^^^-\n@@ -55,7 +55,7 @@ LL |     let ref a @ b = u();\n    |         value borrowed, by `a`, here\n \n error: cannot move out of value because it is borrowed\n-  --> $DIR/borrowck-pat-by-move-and-ref.rs:33:9\n+  --> $DIR/borrowck-pat-by-move-and-ref.rs:32:9\n    |\n LL |     let ref a @ (ref b @ mut c, ref d @ e) = (u(), u());\n    |         -----^^^^^^^^^^^^-----^^^^^^^^^^-^\n@@ -65,7 +65,7 @@ LL |     let ref a @ (ref b @ mut c, ref d @ e) = (u(), u());\n    |         value borrowed, by `a`, here\n \n error: cannot move out of value because it is borrowed\n-  --> $DIR/borrowck-pat-by-move-and-ref.rs:33:18\n+  --> $DIR/borrowck-pat-by-move-and-ref.rs:32:18\n    |\n LL |     let ref a @ (ref b @ mut c, ref d @ e) = (u(), u());\n    |                  -----^^^-----\n@@ -74,7 +74,7 @@ LL |     let ref a @ (ref b @ mut c, ref d @ e) = (u(), u());\n    |                  value borrowed, by `b`, here\n \n error: cannot move out of value because it is borrowed\n-  --> $DIR/borrowck-pat-by-move-and-ref.rs:33:33\n+  --> $DIR/borrowck-pat-by-move-and-ref.rs:32:33\n    |\n LL |     let ref a @ (ref b @ mut c, ref d @ e) = (u(), u());\n    |                                 -----^^^-\n@@ -83,7 +83,7 @@ LL |     let ref a @ (ref b @ mut c, ref d @ e) = (u(), u());\n    |                                 value borrowed, by `d`, here\n \n error: cannot move out of value because it is borrowed\n-  --> $DIR/borrowck-pat-by-move-and-ref.rs:37:9\n+  --> $DIR/borrowck-pat-by-move-and-ref.rs:36:9\n    |\n LL |     let ref mut a @ [b, mut c] = [u(), u()];\n    |         ---------^^^^-^^-----^\n@@ -93,7 +93,7 @@ LL |     let ref mut a @ [b, mut c] = [u(), u()];\n    |         value borrowed, by `a`, here\n \n error: cannot move out of value because it is borrowed\n-  --> $DIR/borrowck-pat-by-move-and-ref.rs:41:9\n+  --> $DIR/borrowck-pat-by-move-and-ref.rs:40:9\n    |\n LL |         ref a @ Some(b) => {}\n    |         -----^^^^^^^^-^\n@@ -102,7 +102,7 @@ LL |         ref a @ Some(b) => {}\n    |         value borrowed, by `a`, here\n \n error: cannot move out of value because it is borrowed\n-  --> $DIR/borrowck-pat-by-move-and-ref.rs:46:9\n+  --> $DIR/borrowck-pat-by-move-and-ref.rs:45:9\n    |\n LL |         ref a @ Some((ref b @ mut c, ref d @ e)) => {}\n    |         -----^^^^^^^^^^^^^^^^^-----^^^^^^^^^^-^^\n@@ -112,7 +112,7 @@ LL |         ref a @ Some((ref b @ mut c, ref d @ e)) => {}\n    |         value borrowed, by `a`, here\n \n error: cannot move out of value because it is borrowed\n-  --> $DIR/borrowck-pat-by-move-and-ref.rs:46:23\n+  --> $DIR/borrowck-pat-by-move-and-ref.rs:45:23\n    |\n LL |         ref a @ Some((ref b @ mut c, ref d @ e)) => {}\n    |                       -----^^^-----\n@@ -121,7 +121,7 @@ LL |         ref a @ Some((ref b @ mut c, ref d @ e)) => {}\n    |                       value borrowed, by `b`, here\n \n error: cannot move out of value because it is borrowed\n-  --> $DIR/borrowck-pat-by-move-and-ref.rs:46:38\n+  --> $DIR/borrowck-pat-by-move-and-ref.rs:45:38\n    |\n LL |         ref a @ Some((ref b @ mut c, ref d @ e)) => {}\n    |                                      -----^^^-\n@@ -130,7 +130,7 @@ LL |         ref a @ Some((ref b @ mut c, ref d @ e)) => {}\n    |                                      value borrowed, by `d`, here\n \n error: cannot move out of value because it is borrowed\n-  --> $DIR/borrowck-pat-by-move-and-ref.rs:53:9\n+  --> $DIR/borrowck-pat-by-move-and-ref.rs:52:9\n    |\n LL |         ref mut a @ Some([b, mut c]) => {}\n    |         ---------^^^^^^^^^-^^-----^^\n@@ -140,7 +140,7 @@ LL |         ref mut a @ Some([b, mut c]) => {}\n    |         value borrowed, by `a`, here\n \n error: cannot move out of value because it is borrowed\n-  --> $DIR/borrowck-pat-by-move-and-ref.rs:58:9\n+  --> $DIR/borrowck-pat-by-move-and-ref.rs:57:9\n    |\n LL |         ref a @ Some(b) => {}\n    |         -----^^^^^^^^-^\n@@ -149,7 +149,7 @@ LL |         ref a @ Some(b) => {}\n    |         value borrowed, by `a`, here\n \n error: cannot move out of value because it is borrowed\n-  --> $DIR/borrowck-pat-by-move-and-ref.rs:63:9\n+  --> $DIR/borrowck-pat-by-move-and-ref.rs:62:9\n    |\n LL |         ref a @ Some((ref b @ mut c, ref d @ e)) => {}\n    |         -----^^^^^^^^^^^^^^^^^-----^^^^^^^^^^-^^\n@@ -159,7 +159,7 @@ LL |         ref a @ Some((ref b @ mut c, ref d @ e)) => {}\n    |         value borrowed, by `a`, here\n \n error: cannot move out of value because it is borrowed\n-  --> $DIR/borrowck-pat-by-move-and-ref.rs:63:23\n+  --> $DIR/borrowck-pat-by-move-and-ref.rs:62:23\n    |\n LL |         ref a @ Some((ref b @ mut c, ref d @ e)) => {}\n    |                       -----^^^-----\n@@ -168,7 +168,7 @@ LL |         ref a @ Some((ref b @ mut c, ref d @ e)) => {}\n    |                       value borrowed, by `b`, here\n \n error: cannot move out of value because it is borrowed\n-  --> $DIR/borrowck-pat-by-move-and-ref.rs:63:38\n+  --> $DIR/borrowck-pat-by-move-and-ref.rs:62:38\n    |\n LL |         ref a @ Some((ref b @ mut c, ref d @ e)) => {}\n    |                                      -----^^^-\n@@ -177,7 +177,7 @@ LL |         ref a @ Some((ref b @ mut c, ref d @ e)) => {}\n    |                                      value borrowed, by `d`, here\n \n error: cannot move out of value because it is borrowed\n-  --> $DIR/borrowck-pat-by-move-and-ref.rs:70:9\n+  --> $DIR/borrowck-pat-by-move-and-ref.rs:69:9\n    |\n LL |         ref mut a @ Some([b, mut c]) => {}\n    |         ---------^^^^^^^^^-^^-----^^\n@@ -187,7 +187,7 @@ LL |         ref mut a @ Some([b, mut c]) => {}\n    |         value borrowed, by `a`, here\n \n error: cannot move out of value because it is borrowed\n-  --> $DIR/borrowck-pat-by-move-and-ref.rs:14:11\n+  --> $DIR/borrowck-pat-by-move-and-ref.rs:13:11\n    |\n LL |     fn f1(ref a @ b: U) {}\n    |           -----^^^-\n@@ -196,7 +196,7 @@ LL |     fn f1(ref a @ b: U) {}\n    |           value borrowed, by `a`, here\n \n error: cannot move out of value because it is borrowed\n-  --> $DIR/borrowck-pat-by-move-and-ref.rs:16:11\n+  --> $DIR/borrowck-pat-by-move-and-ref.rs:15:11\n    |\n LL |     fn f2(ref a @ (ref b @ mut c, ref d @ e): (U, U)) {}\n    |           -----^^^^^^^^^^^^-----^^^^^^^^^^-^\n@@ -206,7 +206,7 @@ LL |     fn f2(ref a @ (ref b @ mut c, ref d @ e): (U, U)) {}\n    |           value borrowed, by `a`, here\n \n error: cannot move out of value because it is borrowed\n-  --> $DIR/borrowck-pat-by-move-and-ref.rs:16:20\n+  --> $DIR/borrowck-pat-by-move-and-ref.rs:15:20\n    |\n LL |     fn f2(ref a @ (ref b @ mut c, ref d @ e): (U, U)) {}\n    |                    -----^^^-----\n@@ -215,7 +215,7 @@ LL |     fn f2(ref a @ (ref b @ mut c, ref d @ e): (U, U)) {}\n    |                    value borrowed, by `b`, here\n \n error: cannot move out of value because it is borrowed\n-  --> $DIR/borrowck-pat-by-move-and-ref.rs:16:35\n+  --> $DIR/borrowck-pat-by-move-and-ref.rs:15:35\n    |\n LL |     fn f2(ref a @ (ref b @ mut c, ref d @ e): (U, U)) {}\n    |                                   -----^^^-\n@@ -224,7 +224,7 @@ LL |     fn f2(ref a @ (ref b @ mut c, ref d @ e): (U, U)) {}\n    |                                   value borrowed, by `d`, here\n \n error: cannot move out of value because it is borrowed\n-  --> $DIR/borrowck-pat-by-move-and-ref.rs:20:11\n+  --> $DIR/borrowck-pat-by-move-and-ref.rs:19:11\n    |\n LL |     fn f3(ref mut a @ [b, mut c]: [U; 2]) {}\n    |           ---------^^^^-^^-----^"}, {"sha": "f67cd45ca95abcc05aa08f97d38ad37984921fa9", "filename": "src/test/ui/pattern/bindings-after-at/borrowck-pat-ref-mut-and-ref.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-ref-mut-and-ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-ref-mut-and-ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-ref-mut-and-ref.rs?ref=b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7", "patch": "@@ -1,5 +1,4 @@\n #![feature(bindings_after_at)]\n-#![feature(move_ref_pattern)]\n \n enum Option<T> {\n     None,"}, {"sha": "e6231dd49badebafc514ba56e03ae3fa7cf546f0", "filename": "src/test/ui/pattern/bindings-after-at/borrowck-pat-ref-mut-and-ref.stderr", "status": "modified", "additions": 47, "deletions": 47, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-ref-mut-and-ref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-ref-mut-and-ref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-ref-mut-and-ref.stderr?ref=b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7", "patch": "@@ -1,5 +1,5 @@\n error: cannot borrow value as immutable because it is also borrowed as mutable\n-  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:11:9\n+  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:10:9\n    |\n LL |         ref mut z @ &mut Some(ref a) => {\n    |         ---------^^^^^^^^^^^^^-----^\n@@ -8,7 +8,7 @@ LL |         ref mut z @ &mut Some(ref a) => {\n    |         mutable borrow, by `z`, occurs here\n \n error: cannot borrow value as mutable more than once at a time\n-  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:35:9\n+  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:34:9\n    |\n LL |     let ref mut a @ (ref b @ ref mut c) = u(); // sub-in-sub\n    |         ---------^^^^-----------------^\n@@ -18,7 +18,7 @@ LL |     let ref mut a @ (ref b @ ref mut c) = u(); // sub-in-sub\n    |         first mutable borrow, by `a`, occurs here\n \n error: cannot borrow value as mutable because it is also borrowed as immutable\n-  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:35:22\n+  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:34:22\n    |\n LL |     let ref mut a @ (ref b @ ref mut c) = u(); // sub-in-sub\n    |                      -----^^^---------\n@@ -27,7 +27,7 @@ LL |     let ref mut a @ (ref b @ ref mut c) = u(); // sub-in-sub\n    |                      immutable borrow, by `b`, occurs here\n \n error: cannot borrow value as mutable because it is also borrowed as immutable\n-  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:39:9\n+  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:38:9\n    |\n LL |     let ref a @ ref mut b = U;\n    |         -----^^^---------\n@@ -36,7 +36,7 @@ LL |     let ref a @ ref mut b = U;\n    |         immutable borrow, by `a`, occurs here\n \n error: cannot borrow value as immutable because it is also borrowed as mutable\n-  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:41:9\n+  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:40:9\n    |\n LL |     let ref mut a @ ref b = U;\n    |         ---------^^^-----\n@@ -45,7 +45,7 @@ LL |     let ref mut a @ ref b = U;\n    |         mutable borrow, by `a`, occurs here\n \n error: cannot borrow value as mutable because it is also borrowed as immutable\n-  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:43:9\n+  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:42:9\n    |\n LL |     let ref a @ (ref mut b, ref mut c) = (U, U);\n    |         -----^^^^---------^^---------^\n@@ -55,7 +55,7 @@ LL |     let ref a @ (ref mut b, ref mut c) = (U, U);\n    |         immutable borrow, by `a`, occurs here\n \n error: cannot borrow value as immutable because it is also borrowed as mutable\n-  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:45:9\n+  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:44:9\n    |\n LL |     let ref mut a @ (ref b, ref c) = (U, U);\n    |         ---------^^^^-----^^-----^\n@@ -65,7 +65,7 @@ LL |     let ref mut a @ (ref b, ref c) = (U, U);\n    |         mutable borrow, by `a`, occurs here\n \n error: cannot borrow value as immutable because it is also borrowed as mutable\n-  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:48:9\n+  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:47:9\n    |\n LL |     let ref mut a @ ref b = u();\n    |         ---------^^^-----\n@@ -74,7 +74,7 @@ LL |     let ref mut a @ ref b = u();\n    |         mutable borrow, by `a`, occurs here\n \n error: cannot borrow value as mutable because it is also borrowed as immutable\n-  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:53:9\n+  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:52:9\n    |\n LL |     let ref a @ ref mut b = u();\n    |         -----^^^---------\n@@ -83,7 +83,7 @@ LL |     let ref a @ ref mut b = u();\n    |         immutable borrow, by `a`, occurs here\n \n error: cannot borrow value as immutable because it is also borrowed as mutable\n-  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:59:9\n+  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:58:9\n    |\n LL |     let ref mut a @ ref b = U;\n    |         ---------^^^-----\n@@ -92,7 +92,7 @@ LL |     let ref mut a @ ref b = U;\n    |         mutable borrow, by `a`, occurs here\n \n error: cannot borrow value as mutable because it is also borrowed as immutable\n-  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:63:9\n+  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:62:9\n    |\n LL |     let ref a @ ref mut b = U;\n    |         -----^^^---------\n@@ -101,7 +101,7 @@ LL |     let ref a @ ref mut b = U;\n    |         immutable borrow, by `a`, occurs here\n \n error: cannot borrow value as immutable because it is also borrowed as mutable\n-  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:69:9\n+  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:68:9\n    |\n LL |         ref mut a @ Ok(ref b) | ref mut a @ Err(ref b) => {\n    |         ---------^^^^^^-----^\n@@ -110,7 +110,7 @@ LL |         ref mut a @ Ok(ref b) | ref mut a @ Err(ref b) => {\n    |         mutable borrow, by `a`, occurs here\n \n error: cannot borrow value as immutable because it is also borrowed as mutable\n-  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:69:33\n+  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:68:33\n    |\n LL |         ref mut a @ Ok(ref b) | ref mut a @ Err(ref b) => {\n    |                                 ---------^^^^^^^-----^\n@@ -119,7 +119,7 @@ LL |         ref mut a @ Ok(ref b) | ref mut a @ Err(ref b) => {\n    |                                 mutable borrow, by `a`, occurs here\n \n error: cannot borrow value as mutable because it is also borrowed as immutable\n-  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:78:9\n+  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:77:9\n    |\n LL |         ref a @ Ok(ref mut b) | ref a @ Err(ref mut b) => {\n    |         -----^^^^^^---------^\n@@ -128,7 +128,7 @@ LL |         ref a @ Ok(ref mut b) | ref a @ Err(ref mut b) => {\n    |         immutable borrow, by `a`, occurs here\n \n error: cannot borrow value as mutable because it is also borrowed as immutable\n-  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:78:33\n+  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:77:33\n    |\n LL |         ref a @ Ok(ref mut b) | ref a @ Err(ref mut b) => {\n    |                                 -----^^^^^^^---------^\n@@ -137,7 +137,7 @@ LL |         ref a @ Ok(ref mut b) | ref a @ Err(ref mut b) => {\n    |                                 immutable borrow, by `a`, occurs here\n \n error: cannot borrow value as mutable because it is also borrowed as immutable\n-  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:89:9\n+  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:88:9\n    |\n LL |         ref a @ Ok(ref mut b) | ref a @ Err(ref mut b) if { *b = U; false } => {}\n    |         -----^^^^^^---------^\n@@ -146,7 +146,7 @@ LL |         ref a @ Ok(ref mut b) | ref a @ Err(ref mut b) if { *b = U; false }\n    |         immutable borrow, by `a`, occurs here\n \n error: cannot borrow value as mutable because it is also borrowed as immutable\n-  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:89:33\n+  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:88:33\n    |\n LL |         ref a @ Ok(ref mut b) | ref a @ Err(ref mut b) if { *b = U; false } => {}\n    |                                 -----^^^^^^^---------^\n@@ -155,7 +155,7 @@ LL |         ref a @ Ok(ref mut b) | ref a @ Err(ref mut b) if { *b = U; false }\n    |                                 immutable borrow, by `a`, occurs here\n \n error: cannot borrow value as immutable because it is also borrowed as mutable\n-  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:96:9\n+  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:95:9\n    |\n LL |         ref mut a @ Ok(ref b) | ref mut a @ Err(ref b) if { *a = Err(U); false } => {}\n    |         ---------^^^^^^-----^\n@@ -164,7 +164,7 @@ LL |         ref mut a @ Ok(ref b) | ref mut a @ Err(ref b) if { *a = Err(U); fa\n    |         mutable borrow, by `a`, occurs here\n \n error: cannot borrow value as immutable because it is also borrowed as mutable\n-  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:96:33\n+  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:95:33\n    |\n LL |         ref mut a @ Ok(ref b) | ref mut a @ Err(ref b) if { *a = Err(U); false } => {}\n    |                                 ---------^^^^^^^-----^\n@@ -173,7 +173,7 @@ LL |         ref mut a @ Ok(ref b) | ref mut a @ Err(ref b) if { *a = Err(U); fa\n    |                                 mutable borrow, by `a`, occurs here\n \n error: cannot borrow value as mutable because it is also borrowed as immutable\n-  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:103:9\n+  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:102:9\n    |\n LL |         ref a @ Ok(ref mut b) | ref a @ Err(ref mut b) if { drop(b); false } => {}\n    |         -----^^^^^^---------^\n@@ -182,7 +182,7 @@ LL |         ref a @ Ok(ref mut b) | ref a @ Err(ref mut b) if { drop(b); false\n    |         immutable borrow, by `a`, occurs here\n \n error: cannot borrow value as mutable because it is also borrowed as immutable\n-  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:103:33\n+  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:102:33\n    |\n LL |         ref a @ Ok(ref mut b) | ref a @ Err(ref mut b) if { drop(b); false } => {}\n    |                                 -----^^^^^^^---------^\n@@ -191,7 +191,7 @@ LL |         ref a @ Ok(ref mut b) | ref a @ Err(ref mut b) if { drop(b); false\n    |                                 immutable borrow, by `a`, occurs here\n \n error: cannot borrow value as immutable because it is also borrowed as mutable\n-  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:111:9\n+  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:110:9\n    |\n LL |         ref mut a @ Ok(ref b) | ref mut a @ Err(ref b) if { drop(a); false } => {}\n    |         ---------^^^^^^-----^\n@@ -200,7 +200,7 @@ LL |         ref mut a @ Ok(ref b) | ref mut a @ Err(ref b) if { drop(a); false\n    |         mutable borrow, by `a`, occurs here\n \n error: cannot borrow value as immutable because it is also borrowed as mutable\n-  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:111:33\n+  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:110:33\n    |\n LL |         ref mut a @ Ok(ref b) | ref mut a @ Err(ref b) if { drop(a); false } => {}\n    |                                 ---------^^^^^^^-----^\n@@ -209,7 +209,7 @@ LL |         ref mut a @ Ok(ref b) | ref mut a @ Err(ref b) if { drop(a); false\n    |                                 mutable borrow, by `a`, occurs here\n \n error: cannot borrow value as mutable because it is also borrowed as immutable\n-  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:119:9\n+  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:118:9\n    |\n LL |     let ref a @ (ref mut b, ref mut c) = (U, U);\n    |         -----^^^^---------^^---------^\n@@ -219,7 +219,7 @@ LL |     let ref a @ (ref mut b, ref mut c) = (U, U);\n    |         immutable borrow, by `a`, occurs here\n \n error: cannot borrow value as mutable because it is also borrowed as immutable\n-  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:124:9\n+  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:123:9\n    |\n LL |     let ref a @ (ref mut b, ref mut c) = (U, U);\n    |         -----^^^^---------^^---------^\n@@ -229,7 +229,7 @@ LL |     let ref a @ (ref mut b, ref mut c) = (U, U);\n    |         immutable borrow, by `a`, occurs here\n \n error: cannot borrow value as mutable because it is also borrowed as immutable\n-  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:131:9\n+  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:130:9\n    |\n LL |     let ref a @ (ref mut b, ref mut c) = (U, U);\n    |         -----^^^^---------^^---------^\n@@ -239,7 +239,7 @@ LL |     let ref a @ (ref mut b, ref mut c) = (U, U);\n    |         immutable borrow, by `a`, occurs here\n \n error: cannot borrow value as immutable because it is also borrowed as mutable\n-  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:136:9\n+  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:135:9\n    |\n LL |     let ref mut a @ (ref b, ref c) = (U, U);\n    |         ---------^^^^-----^^-----^\n@@ -249,7 +249,7 @@ LL |     let ref mut a @ (ref b, ref c) = (U, U);\n    |         mutable borrow, by `a`, occurs here\n \n error: cannot borrow value as mutable because it is also borrowed as immutable\n-  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:25:11\n+  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:24:11\n    |\n LL |     fn f1(ref a @ ref mut b: U) {}\n    |           -----^^^---------\n@@ -258,7 +258,7 @@ LL |     fn f1(ref a @ ref mut b: U) {}\n    |           immutable borrow, by `a`, occurs here\n \n error: cannot borrow value as immutable because it is also borrowed as mutable\n-  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:27:11\n+  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:26:11\n    |\n LL |     fn f2(ref mut a @ ref b: U) {}\n    |           ---------^^^-----\n@@ -267,7 +267,7 @@ LL |     fn f2(ref mut a @ ref b: U) {}\n    |           mutable borrow, by `a`, occurs here\n \n error: cannot borrow value as mutable because it is also borrowed as immutable\n-  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:29:11\n+  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:28:11\n    |\n LL |     fn f3(ref a @ [ref b, ref mut mid @ .., ref c]: [U; 4]) {}\n    |           -----^^^^^^^^^^^----------------^^^^^^^^\n@@ -276,7 +276,7 @@ LL |     fn f3(ref a @ [ref b, ref mut mid @ .., ref c]: [U; 4]) {}\n    |           immutable borrow, by `a`, occurs here\n \n error: cannot borrow value as mutable because it is also borrowed as immutable\n-  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:31:22\n+  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:30:22\n    |\n LL |     fn f4_also_moved(ref a @ ref mut b @ c: U) {}\n    |                      -----^^^-------------\n@@ -286,7 +286,7 @@ LL |     fn f4_also_moved(ref a @ ref mut b @ c: U) {}\n    |                      immutable borrow, by `a`, occurs here\n \n error: cannot move out of value because it is borrowed\n-  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:31:30\n+  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:30:30\n    |\n LL |     fn f4_also_moved(ref a @ ref mut b @ c: U) {}\n    |                              ---------^^^-\n@@ -295,7 +295,7 @@ LL |     fn f4_also_moved(ref a @ ref mut b @ c: U) {}\n    |                              value borrowed, by `b`, here\n \n error[E0502]: cannot borrow value as immutable because it is also borrowed as mutable\n-  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:11:31\n+  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:10:31\n    |\n LL |         ref mut z @ &mut Some(ref a) => {\n    |         ----------------------^^^^^-\n@@ -307,7 +307,7 @@ LL |             **z = None;\n    |             ---------- mutable borrow later used here\n \n error[E0502]: cannot borrow value as immutable because it is also borrowed as mutable\n-  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:48:21\n+  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:47:21\n    |\n LL |     let ref mut a @ ref b = u();\n    |         ------------^^^^^\n@@ -319,7 +319,7 @@ LL |     *a = u();\n    |     -------- mutable borrow later used here\n \n error[E0502]: cannot borrow value as mutable because it is also borrowed as immutable\n-  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:53:17\n+  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:52:17\n    |\n LL |     let ref a @ ref mut b = u();\n    |         --------^^^^^^^^^\n@@ -331,7 +331,7 @@ LL |     drop(a);\n    |          - immutable borrow later used here\n \n error[E0502]: cannot borrow value as mutable because it is also borrowed as immutable\n-  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:78:20\n+  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:77:20\n    |\n LL |         ref a @ Ok(ref mut b) | ref a @ Err(ref mut b) => {\n    |         -----------^^^^^^^^^-\n@@ -343,7 +343,7 @@ LL |             drop(a);\n    |                  - immutable borrow later used here\n \n error[E0502]: cannot borrow value as mutable because it is also borrowed as immutable\n-  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:78:45\n+  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:77:45\n    |\n LL |         ref a @ Ok(ref mut b) | ref a @ Err(ref mut b) => {\n    |                                 ------------^^^^^^^^^-\n@@ -355,55 +355,55 @@ LL |             drop(a);\n    |                  - immutable borrow later used here\n \n error[E0594]: cannot assign to `*b`, as it is immutable for the pattern guard\n-  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:89:61\n+  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:88:61\n    |\n LL |         ref a @ Ok(ref mut b) | ref a @ Err(ref mut b) if { *b = U; false } => {}\n    |                                                             ^^^^^^ cannot assign\n    |\n    = note: variables bound in patterns are immutable until the end of the pattern guard\n \n error[E0594]: cannot assign to `*a`, as it is immutable for the pattern guard\n-  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:96:61\n+  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:95:61\n    |\n LL |         ref mut a @ Ok(ref b) | ref mut a @ Err(ref b) if { *a = Err(U); false } => {}\n    |                                                             ^^^^^^^^^^^ cannot assign\n    |\n    = note: variables bound in patterns are immutable until the end of the pattern guard\n \n error[E0507]: cannot move out of `b` in pattern guard\n-  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:103:66\n+  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:102:66\n    |\n LL |         ref a @ Ok(ref mut b) | ref a @ Err(ref mut b) if { drop(b); false } => {}\n    |                                                                  ^ move occurs because `b` has type `&mut U`, which does not implement the `Copy` trait\n    |\n    = note: variables bound in patterns cannot be moved from until after the end of the pattern guard\n \n error[E0507]: cannot move out of `b` in pattern guard\n-  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:103:66\n+  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:102:66\n    |\n LL |         ref a @ Ok(ref mut b) | ref a @ Err(ref mut b) if { drop(b); false } => {}\n    |                                                                  ^ move occurs because `b` has type `&mut U`, which does not implement the `Copy` trait\n    |\n    = note: variables bound in patterns cannot be moved from until after the end of the pattern guard\n \n error[E0507]: cannot move out of `a` in pattern guard\n-  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:111:66\n+  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:110:66\n    |\n LL |         ref mut a @ Ok(ref b) | ref mut a @ Err(ref b) if { drop(a); false } => {}\n    |                                                                  ^ move occurs because `a` has type `&mut std::result::Result<U, U>`, which does not implement the `Copy` trait\n    |\n    = note: variables bound in patterns cannot be moved from until after the end of the pattern guard\n \n error[E0507]: cannot move out of `a` in pattern guard\n-  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:111:66\n+  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:110:66\n    |\n LL |         ref mut a @ Ok(ref b) | ref mut a @ Err(ref b) if { drop(a); false } => {}\n    |                                                                  ^ move occurs because `a` has type `&mut std::result::Result<U, U>`, which does not implement the `Copy` trait\n    |\n    = note: variables bound in patterns cannot be moved from until after the end of the pattern guard\n \n error[E0502]: cannot borrow value as mutable because it is also borrowed as immutable\n-  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:124:18\n+  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:123:18\n    |\n LL |     let ref a @ (ref mut b, ref mut c) = (U, U);\n    |         ---------^^^^^^^^^------------\n@@ -415,7 +415,7 @@ LL |     drop(a);\n    |          - immutable borrow later used here\n \n error[E0502]: cannot borrow value as mutable because it is also borrowed as immutable\n-  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:124:29\n+  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:123:29\n    |\n LL |     let ref a @ (ref mut b, ref mut c) = (U, U);\n    |         --------------------^^^^^^^^^-\n@@ -427,7 +427,7 @@ LL |     drop(a);\n    |          - immutable borrow later used here\n \n error[E0502]: cannot borrow value as mutable because it is also borrowed as immutable\n-  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:131:18\n+  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:130:18\n    |\n LL |     let ref a @ (ref mut b, ref mut c) = (U, U);\n    |         ---------^^^^^^^^^------------\n@@ -439,7 +439,7 @@ LL |     drop(a);\n    |          - immutable borrow later used here\n \n error[E0502]: cannot borrow value as mutable because it is also borrowed as immutable\n-  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:131:29\n+  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:130:29\n    |\n LL |     let ref a @ (ref mut b, ref mut c) = (U, U);\n    |         --------------------^^^^^^^^^-"}, {"sha": "8faaa1c881fbf8a31ff673a844bef5d21807f00a", "filename": "src/test/ui/pattern/bindings-after-at/borrowck-pat-ref-mut-twice.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-ref-mut-twice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-ref-mut-twice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-ref-mut-twice.rs?ref=b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7", "patch": "@@ -1,7 +1,6 @@\n // Test that `ref mut x @ ref mut y` and varieties of that are not allowed.\n \n #![feature(bindings_after_at)]\n-#![feature(move_ref_pattern)]\n \n fn main() {\n     struct U;"}, {"sha": "2e0f5fcabddf3094d6eae4d884ac4b479e8a4ecc", "filename": "src/test/ui/pattern/bindings-after-at/borrowck-pat-ref-mut-twice.stderr", "status": "modified", "additions": 34, "deletions": 34, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-ref-mut-twice.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-ref-mut-twice.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-ref-mut-twice.stderr?ref=b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7", "patch": "@@ -1,5 +1,5 @@\n error: cannot borrow value as mutable more than once at a time\n-  --> $DIR/borrowck-pat-ref-mut-twice.rs:28:9\n+  --> $DIR/borrowck-pat-ref-mut-twice.rs:27:9\n    |\n LL |     let ref mut a @ ref mut b = U;\n    |         ---------^^^---------\n@@ -8,7 +8,7 @@ LL |     let ref mut a @ ref mut b = U;\n    |         first mutable borrow, by `a`, occurs here\n \n error: cannot borrow value as mutable more than once at a time\n-  --> $DIR/borrowck-pat-ref-mut-twice.rs:32:9\n+  --> $DIR/borrowck-pat-ref-mut-twice.rs:31:9\n    |\n LL |     let ref mut a @ ref mut b = U;\n    |         ---------^^^---------\n@@ -17,7 +17,7 @@ LL |     let ref mut a @ ref mut b = U;\n    |         first mutable borrow, by `a`, occurs here\n \n error: cannot borrow value as mutable more than once at a time\n-  --> $DIR/borrowck-pat-ref-mut-twice.rs:35:9\n+  --> $DIR/borrowck-pat-ref-mut-twice.rs:34:9\n    |\n LL |     let ref mut a @ ref mut b = U;\n    |         ---------^^^---------\n@@ -26,7 +26,7 @@ LL |     let ref mut a @ ref mut b = U;\n    |         first mutable borrow, by `a`, occurs here\n \n error: cannot borrow value as mutable more than once at a time\n-  --> $DIR/borrowck-pat-ref-mut-twice.rs:38:9\n+  --> $DIR/borrowck-pat-ref-mut-twice.rs:37:9\n    |\n LL |     let ref mut a @ ref mut b = U;\n    |         ---------^^^---------\n@@ -35,7 +35,7 @@ LL |     let ref mut a @ ref mut b = U;\n    |         first mutable borrow, by `a`, occurs here\n \n error: cannot borrow value as mutable more than once at a time\n-  --> $DIR/borrowck-pat-ref-mut-twice.rs:42:9\n+  --> $DIR/borrowck-pat-ref-mut-twice.rs:41:9\n    |\n LL |     let ref mut a @ ref mut b = U;\n    |         ---------^^^---------\n@@ -44,7 +44,7 @@ LL |     let ref mut a @ ref mut b = U;\n    |         first mutable borrow, by `a`, occurs here\n \n error: cannot borrow value as mutable more than once at a time\n-  --> $DIR/borrowck-pat-ref-mut-twice.rs:46:9\n+  --> $DIR/borrowck-pat-ref-mut-twice.rs:45:9\n    |\n LL |       let ref mut a @ (\n    |           ^--------\n@@ -66,7 +66,7 @@ LL | |     ) = (U, [U, U, U]);\n    | |_____^\n \n error: cannot borrow value as mutable more than once at a time\n-  --> $DIR/borrowck-pat-ref-mut-twice.rs:56:9\n+  --> $DIR/borrowck-pat-ref-mut-twice.rs:55:9\n    |\n LL |       let ref mut a @ (\n    |           ^--------\n@@ -88,7 +88,7 @@ LL | |         ) = (u(), [u(), u(), u()]);\n    | |_________^\n \n error: borrow of moved value\n-  --> $DIR/borrowck-pat-ref-mut-twice.rs:66:9\n+  --> $DIR/borrowck-pat-ref-mut-twice.rs:65:9\n    |\n LL |     let a @ (ref mut b, ref mut c) = (U, U);\n    |         -^^^^---------^^---------^\n@@ -99,7 +99,7 @@ LL |     let a @ (ref mut b, ref mut c) = (U, U);\n    |         move occurs because `a` has type `(U, U)` which does not implement the `Copy` trait\n \n error: borrow of moved value\n-  --> $DIR/borrowck-pat-ref-mut-twice.rs:70:9\n+  --> $DIR/borrowck-pat-ref-mut-twice.rs:69:9\n    |\n LL |     let a @ (b, [c, d]) = &mut val; // Same as ^--\n    |         -^^^^-^^^-^^-^^\n@@ -111,7 +111,7 @@ LL |     let a @ (b, [c, d]) = &mut val; // Same as ^--\n    |         move occurs because `a` has type `&mut (U, [U; 2])` which does not implement the `Copy` trait\n \n error: borrow of moved value\n-  --> $DIR/borrowck-pat-ref-mut-twice.rs:74:9\n+  --> $DIR/borrowck-pat-ref-mut-twice.rs:73:9\n    |\n LL |     let a @ &mut ref mut b = &mut U;\n    |         -^^^^^^^^---------\n@@ -121,7 +121,7 @@ LL |     let a @ &mut ref mut b = &mut U;\n    |         move occurs because `a` has type `&mut U` which does not implement the `Copy` trait\n \n error: borrow of moved value\n-  --> $DIR/borrowck-pat-ref-mut-twice.rs:77:9\n+  --> $DIR/borrowck-pat-ref-mut-twice.rs:76:9\n    |\n LL |     let a @ &mut (ref mut b, ref mut c) = &mut (U, U);\n    |         -^^^^^^^^^---------^^---------^\n@@ -132,7 +132,7 @@ LL |     let a @ &mut (ref mut b, ref mut c) = &mut (U, U);\n    |         move occurs because `a` has type `&mut (U, U)` which does not implement the `Copy` trait\n \n error: cannot borrow value as mutable more than once at a time\n-  --> $DIR/borrowck-pat-ref-mut-twice.rs:82:9\n+  --> $DIR/borrowck-pat-ref-mut-twice.rs:81:9\n    |\n LL |         ref mut a @ Ok(ref mut b) | ref mut a @ Err(ref mut b) => {\n    |         ---------^^^^^^---------^\n@@ -141,7 +141,7 @@ LL |         ref mut a @ Ok(ref mut b) | ref mut a @ Err(ref mut b) => {\n    |         first mutable borrow, by `a`, occurs here\n \n error: cannot borrow value as mutable more than once at a time\n-  --> $DIR/borrowck-pat-ref-mut-twice.rs:82:37\n+  --> $DIR/borrowck-pat-ref-mut-twice.rs:81:37\n    |\n LL |         ref mut a @ Ok(ref mut b) | ref mut a @ Err(ref mut b) => {\n    |                                     ---------^^^^^^^---------^\n@@ -150,7 +150,7 @@ LL |         ref mut a @ Ok(ref mut b) | ref mut a @ Err(ref mut b) => {\n    |                                     first mutable borrow, by `a`, occurs here\n \n error: cannot borrow value as mutable more than once at a time\n-  --> $DIR/borrowck-pat-ref-mut-twice.rs:88:9\n+  --> $DIR/borrowck-pat-ref-mut-twice.rs:87:9\n    |\n LL |         ref mut a @ Ok(ref mut b) | ref mut a @ Err(ref mut b) => {\n    |         ---------^^^^^^---------^\n@@ -159,7 +159,7 @@ LL |         ref mut a @ Ok(ref mut b) | ref mut a @ Err(ref mut b) => {\n    |         first mutable borrow, by `a`, occurs here\n \n error: cannot borrow value as mutable more than once at a time\n-  --> $DIR/borrowck-pat-ref-mut-twice.rs:88:37\n+  --> $DIR/borrowck-pat-ref-mut-twice.rs:87:37\n    |\n LL |         ref mut a @ Ok(ref mut b) | ref mut a @ Err(ref mut b) => {\n    |                                     ---------^^^^^^^---------^\n@@ -168,7 +168,7 @@ LL |         ref mut a @ Ok(ref mut b) | ref mut a @ Err(ref mut b) => {\n    |                                     first mutable borrow, by `a`, occurs here\n \n error: cannot borrow value as mutable more than once at a time\n-  --> $DIR/borrowck-pat-ref-mut-twice.rs:95:9\n+  --> $DIR/borrowck-pat-ref-mut-twice.rs:94:9\n    |\n LL |         ref mut a @ Ok(ref mut b) | ref mut a @ Err(ref mut b) => {\n    |         ---------^^^^^^---------^\n@@ -177,7 +177,7 @@ LL |         ref mut a @ Ok(ref mut b) | ref mut a @ Err(ref mut b) => {\n    |         first mutable borrow, by `a`, occurs here\n \n error: cannot borrow value as mutable more than once at a time\n-  --> $DIR/borrowck-pat-ref-mut-twice.rs:95:37\n+  --> $DIR/borrowck-pat-ref-mut-twice.rs:94:37\n    |\n LL |         ref mut a @ Ok(ref mut b) | ref mut a @ Err(ref mut b) => {\n    |                                     ---------^^^^^^^---------^\n@@ -186,7 +186,7 @@ LL |         ref mut a @ Ok(ref mut b) | ref mut a @ Err(ref mut b) => {\n    |                                     first mutable borrow, by `a`, occurs here\n \n error: cannot borrow value as mutable more than once at a time\n-  --> $DIR/borrowck-pat-ref-mut-twice.rs:107:9\n+  --> $DIR/borrowck-pat-ref-mut-twice.rs:106:9\n    |\n LL |         ref mut a @ Ok(ref mut b) | ref mut a @ Err(ref mut b) => {\n    |         ---------^^^^^^---------^\n@@ -195,7 +195,7 @@ LL |         ref mut a @ Ok(ref mut b) | ref mut a @ Err(ref mut b) => {\n    |         first mutable borrow, by `a`, occurs here\n \n error: cannot borrow value as mutable more than once at a time\n-  --> $DIR/borrowck-pat-ref-mut-twice.rs:107:37\n+  --> $DIR/borrowck-pat-ref-mut-twice.rs:106:37\n    |\n LL |         ref mut a @ Ok(ref mut b) | ref mut a @ Err(ref mut b) => {\n    |                                     ---------^^^^^^^---------^\n@@ -204,7 +204,7 @@ LL |         ref mut a @ Ok(ref mut b) | ref mut a @ Err(ref mut b) => {\n    |                                     first mutable borrow, by `a`, occurs here\n \n error: cannot borrow value as mutable more than once at a time\n-  --> $DIR/borrowck-pat-ref-mut-twice.rs:11:11\n+  --> $DIR/borrowck-pat-ref-mut-twice.rs:10:11\n    |\n LL |     fn f1(ref mut a @ ref mut b: U) {}\n    |           ---------^^^---------\n@@ -213,7 +213,7 @@ LL |     fn f1(ref mut a @ ref mut b: U) {}\n    |           first mutable borrow, by `a`, occurs here\n \n error: cannot borrow value as mutable more than once at a time\n-  --> $DIR/borrowck-pat-ref-mut-twice.rs:13:11\n+  --> $DIR/borrowck-pat-ref-mut-twice.rs:12:11\n    |\n LL |     fn f2(ref mut a @ ref mut b: U) {}\n    |           ---------^^^---------\n@@ -222,7 +222,7 @@ LL |     fn f2(ref mut a @ ref mut b: U) {}\n    |           first mutable borrow, by `a`, occurs here\n \n error: cannot borrow value as mutable more than once at a time\n-  --> $DIR/borrowck-pat-ref-mut-twice.rs:16:9\n+  --> $DIR/borrowck-pat-ref-mut-twice.rs:15:9\n    |\n LL |           ref mut a @ [\n    |           ^--------\n@@ -240,7 +240,7 @@ LL | |         ] : [[U; 4]; 5]\n    | |_________^\n \n error: cannot borrow value as mutable more than once at a time\n-  --> $DIR/borrowck-pat-ref-mut-twice.rs:24:22\n+  --> $DIR/borrowck-pat-ref-mut-twice.rs:23:22\n    |\n LL |     fn f4_also_moved(ref mut a @ ref mut b @ c: U) {}\n    |                      ---------^^^-------------\n@@ -250,7 +250,7 @@ LL |     fn f4_also_moved(ref mut a @ ref mut b @ c: U) {}\n    |                      first mutable borrow, by `a`, occurs here\n \n error: cannot move out of value because it is borrowed\n-  --> $DIR/borrowck-pat-ref-mut-twice.rs:24:34\n+  --> $DIR/borrowck-pat-ref-mut-twice.rs:23:34\n    |\n LL |     fn f4_also_moved(ref mut a @ ref mut b @ c: U) {}\n    |                                  ---------^^^-\n@@ -259,7 +259,7 @@ LL |     fn f4_also_moved(ref mut a @ ref mut b @ c: U) {}\n    |                                  value borrowed, by `b`, here\n \n error[E0499]: cannot borrow value as mutable more than once at a time\n-  --> $DIR/borrowck-pat-ref-mut-twice.rs:28:21\n+  --> $DIR/borrowck-pat-ref-mut-twice.rs:27:21\n    |\n LL |     let ref mut a @ ref mut b = U;\n    |         ------------^^^^^^^^^\n@@ -271,7 +271,7 @@ LL |     drop(a);\n    |          - first borrow later used here\n \n error[E0499]: cannot borrow value as mutable more than once at a time\n-  --> $DIR/borrowck-pat-ref-mut-twice.rs:38:21\n+  --> $DIR/borrowck-pat-ref-mut-twice.rs:37:21\n    |\n LL |     let ref mut a @ ref mut b = U;\n    |         ------------^^^^^^^^^\n@@ -283,7 +283,7 @@ LL |     *a = U;\n    |     ------ first borrow later used here\n \n error[E0382]: borrow of moved value\n-  --> $DIR/borrowck-pat-ref-mut-twice.rs:66:25\n+  --> $DIR/borrowck-pat-ref-mut-twice.rs:65:25\n    |\n LL |     let a @ (ref mut b, ref mut c) = (U, U);\n    |         ----------------^^^^^^^^^-   ------ move occurs because value has type `(U, U)`, which does not implement the `Copy` trait\n@@ -292,7 +292,7 @@ LL |     let a @ (ref mut b, ref mut c) = (U, U);\n    |         value moved here\n \n error[E0382]: borrow of moved value\n-  --> $DIR/borrowck-pat-ref-mut-twice.rs:70:21\n+  --> $DIR/borrowck-pat-ref-mut-twice.rs:69:21\n    |\n LL |     let a @ (b, [c, d]) = &mut val; // Same as ^--\n    |         ------------^--   -------- move occurs because value has type `&mut (U, [U; 2])`, which does not implement the `Copy` trait\n@@ -301,7 +301,7 @@ LL |     let a @ (b, [c, d]) = &mut val; // Same as ^--\n    |         value moved here\n \n error[E0382]: borrow of moved value\n-  --> $DIR/borrowck-pat-ref-mut-twice.rs:74:18\n+  --> $DIR/borrowck-pat-ref-mut-twice.rs:73:18\n    |\n LL |     let a @ &mut ref mut b = &mut U;\n    |         ---------^^^^^^^^^   ------ move occurs because value has type `&mut U`, which does not implement the `Copy` trait\n@@ -310,7 +310,7 @@ LL |     let a @ &mut ref mut b = &mut U;\n    |         value moved here\n \n error[E0382]: borrow of moved value\n-  --> $DIR/borrowck-pat-ref-mut-twice.rs:77:30\n+  --> $DIR/borrowck-pat-ref-mut-twice.rs:76:30\n    |\n LL |     let a @ &mut (ref mut b, ref mut c) = &mut (U, U);\n    |         ---------------------^^^^^^^^^-   ----------- move occurs because value has type `&mut (U, U)`, which does not implement the `Copy` trait\n@@ -319,7 +319,7 @@ LL |     let a @ &mut (ref mut b, ref mut c) = &mut (U, U);\n    |         value moved here\n \n error[E0499]: cannot borrow value as mutable more than once at a time\n-  --> $DIR/borrowck-pat-ref-mut-twice.rs:95:24\n+  --> $DIR/borrowck-pat-ref-mut-twice.rs:94:24\n    |\n LL |         ref mut a @ Ok(ref mut b) | ref mut a @ Err(ref mut b) => {\n    |         ---------------^^^^^^^^^-\n@@ -331,7 +331,7 @@ LL |             *a = Err(U);\n    |             ----------- first borrow later used here\n \n error[E0499]: cannot borrow value as mutable more than once at a time\n-  --> $DIR/borrowck-pat-ref-mut-twice.rs:95:53\n+  --> $DIR/borrowck-pat-ref-mut-twice.rs:94:53\n    |\n LL |         ref mut a @ Ok(ref mut b) | ref mut a @ Err(ref mut b) => {\n    |                                     ----------------^^^^^^^^^-\n@@ -343,7 +343,7 @@ LL |             *a = Err(U);\n    |             ----------- first borrow later used here\n \n error[E0499]: cannot borrow value as mutable more than once at a time\n-  --> $DIR/borrowck-pat-ref-mut-twice.rs:107:24\n+  --> $DIR/borrowck-pat-ref-mut-twice.rs:106:24\n    |\n LL |         ref mut a @ Ok(ref mut b) | ref mut a @ Err(ref mut b) => {\n    |         ---------------^^^^^^^^^-\n@@ -355,7 +355,7 @@ LL |             drop(a);\n    |                  - first borrow later used here\n \n error[E0499]: cannot borrow value as mutable more than once at a time\n-  --> $DIR/borrowck-pat-ref-mut-twice.rs:107:53\n+  --> $DIR/borrowck-pat-ref-mut-twice.rs:106:53\n    |\n LL |         ref mut a @ Ok(ref mut b) | ref mut a @ Err(ref mut b) => {\n    |                                     ----------------^^^^^^^^^-"}, {"sha": "3954d17e1c2bcca3dbab0b101b2ba98e941aee2f", "filename": "src/test/ui/pattern/bindings-after-at/copy-and-move-mixed.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fcopy-and-move-mixed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fcopy-and-move-mixed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fcopy-and-move-mixed.rs?ref=b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7", "patch": "@@ -1,7 +1,6 @@\n // Test that mixing `Copy` and non-`Copy` types in `@` patterns is forbidden.\n \n #![feature(bindings_after_at)]\n-#![feature(move_ref_pattern)]\n \n #[derive(Copy, Clone)]\n struct C;"}, {"sha": "cc2786a13f4e8949d4631a09a76761a305bf0631", "filename": "src/test/ui/pattern/bindings-after-at/copy-and-move-mixed.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fcopy-and-move-mixed.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fcopy-and-move-mixed.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fcopy-and-move-mixed.stderr?ref=b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7", "patch": "@@ -1,5 +1,5 @@\n error[E0382]: use of moved value\n-  --> $DIR/copy-and-move-mixed.rs:12:19\n+  --> $DIR/copy-and-move-mixed.rs:11:19\n    |\n LL |     let a @ NC(b, c) = NC(C, C);\n    |         ----------^-   -------- move occurs because value has type `NC<C, C>`, which does not implement the `Copy` trait\n@@ -8,7 +8,7 @@ LL |     let a @ NC(b, c) = NC(C, C);\n    |         value moved here\n \n error[E0382]: use of moved value\n-  --> $DIR/copy-and-move-mixed.rs:15:19\n+  --> $DIR/copy-and-move-mixed.rs:14:19\n    |\n LL |     let a @ NC(b, c @ NC(d, e)) = NC(C, NC(C, C));\n    |         ----------^^^^^^^^^^^^-   --------------- move occurs because value has type `NC<C, NC<C, C>>`, which does not implement the `Copy` trait\n@@ -17,7 +17,7 @@ LL |     let a @ NC(b, c @ NC(d, e)) = NC(C, NC(C, C));\n    |         value moved here\n \n error[E0382]: use of moved value\n-  --> $DIR/copy-and-move-mixed.rs:15:29\n+  --> $DIR/copy-and-move-mixed.rs:14:29\n    |\n LL |     let a @ NC(b, c @ NC(d, e)) = NC(C, NC(C, C));\n    |                   ----------^-"}, {"sha": "276088b9a9ee9c54f573d04a880142548c8313c9", "filename": "src/test/ui/pattern/bindings-after-at/default-binding-modes-both-sides-independent.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fdefault-binding-modes-both-sides-independent.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fdefault-binding-modes-both-sides-independent.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fdefault-binding-modes-both-sides-independent.rs?ref=b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7", "patch": "@@ -8,7 +8,6 @@\n // this would create problems for the generalization aforementioned.\n \n #![feature(bindings_after_at)]\n-#![feature(move_ref_pattern)]\n \n fn main() {\n     struct NotCopy;"}, {"sha": "11d5e24f34e132df7ecd15d015d45241b0cf77a6", "filename": "src/test/ui/pattern/bindings-after-at/default-binding-modes-both-sides-independent.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fdefault-binding-modes-both-sides-independent.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fdefault-binding-modes-both-sides-independent.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fdefault-binding-modes-both-sides-independent.stderr?ref=b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7", "patch": "@@ -1,5 +1,5 @@\n error: cannot move out of value because it is borrowed\n-  --> $DIR/default-binding-modes-both-sides-independent.rs:28:9\n+  --> $DIR/default-binding-modes-both-sides-independent.rs:27:9\n    |\n LL |     let ref a @ b = NotCopy;\n    |         -----^^^-\n@@ -8,7 +8,7 @@ LL |     let ref a @ b = NotCopy;\n    |         value borrowed, by `a`, here\n \n error: cannot move out of value because it is borrowed\n-  --> $DIR/default-binding-modes-both-sides-independent.rs:31:9\n+  --> $DIR/default-binding-modes-both-sides-independent.rs:30:9\n    |\n LL |     let ref mut a @ b = NotCopy;\n    |         ---------^^^-\n@@ -17,7 +17,7 @@ LL |     let ref mut a @ b = NotCopy;\n    |         value borrowed, by `a`, here\n \n error: cannot move out of value because it is borrowed\n-  --> $DIR/default-binding-modes-both-sides-independent.rs:36:12\n+  --> $DIR/default-binding-modes-both-sides-independent.rs:35:12\n    |\n LL |         Ok(ref a @ b) | Err(b @ ref a) => {\n    |            -----^^^-\n@@ -26,7 +26,7 @@ LL |         Ok(ref a @ b) | Err(b @ ref a) => {\n    |            value borrowed, by `a`, here\n \n error: borrow of moved value\n-  --> $DIR/default-binding-modes-both-sides-independent.rs:36:29\n+  --> $DIR/default-binding-modes-both-sides-independent.rs:35:29\n    |\n LL |         Ok(ref a @ b) | Err(b @ ref a) => {\n    |                             -^^^-----\n@@ -36,7 +36,7 @@ LL |         Ok(ref a @ b) | Err(b @ ref a) => {\n    |                             move occurs because `b` has type `NotCopy` which does not implement the `Copy` trait\n \n error: cannot move out of value because it is borrowed\n-  --> $DIR/default-binding-modes-both-sides-independent.rs:44:9\n+  --> $DIR/default-binding-modes-both-sides-independent.rs:43:9\n    |\n LL |         ref a @ b => {\n    |         -----^^^-\n@@ -45,7 +45,7 @@ LL |         ref a @ b => {\n    |         value borrowed, by `a`, here\n \n error[E0505]: cannot move out of value because it is borrowed\n-  --> $DIR/default-binding-modes-both-sides-independent.rs:31:21\n+  --> $DIR/default-binding-modes-both-sides-independent.rs:30:21\n    |\n LL |     let ref mut a @ b = NotCopy;\n    |         ------------^"}, {"sha": "5445696fdff7d3e6574c7856af642f233822e2a3", "filename": "src/test/ui/pattern/move-ref-patterns/borrowck-move-ref-pattern-pass.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/src%2Ftest%2Fui%2Fpattern%2Fmove-ref-patterns%2Fborrowck-move-ref-pattern-pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/src%2Ftest%2Fui%2Fpattern%2Fmove-ref-patterns%2Fborrowck-move-ref-pattern-pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fmove-ref-patterns%2Fborrowck-move-ref-pattern-pass.rs?ref=b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7", "patch": "@@ -1,7 +1,5 @@\n // check-pass\n \n-#![feature(move_ref_pattern)]\n-\n fn main() {}\n \n struct U;"}, {"sha": "9c320edc4dc0ec0f6a6ac5021d0ef5fb6485b685", "filename": "src/test/ui/pattern/move-ref-patterns/borrowck-move-ref-pattern.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/src%2Ftest%2Fui%2Fpattern%2Fmove-ref-patterns%2Fborrowck-move-ref-pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/src%2Ftest%2Fui%2Fpattern%2Fmove-ref-patterns%2Fborrowck-move-ref-pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fmove-ref-patterns%2Fborrowck-move-ref-pattern.rs?ref=b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7", "patch": "@@ -1,5 +1,3 @@\n-#![feature(move_ref_pattern)]\n-\n fn main() {}\n \n struct U;"}, {"sha": "285c203f382df3b75e69c6e415741122779b937a", "filename": "src/test/ui/pattern/move-ref-patterns/borrowck-move-ref-pattern.stderr", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/src%2Ftest%2Fui%2Fpattern%2Fmove-ref-patterns%2Fborrowck-move-ref-pattern.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/src%2Ftest%2Fui%2Fpattern%2Fmove-ref-patterns%2Fborrowck-move-ref-pattern.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fmove-ref-patterns%2Fborrowck-move-ref-pattern.stderr?ref=b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7", "patch": "@@ -1,5 +1,5 @@\n error[E0505]: cannot move out of `arr[..]` because it is borrowed\n-  --> $DIR/borrowck-move-ref-pattern.rs:10:24\n+  --> $DIR/borrowck-move-ref-pattern.rs:8:24\n    |\n LL |     let hold_all = &arr;\n    |                    ---- borrow of `arr` occurs here\n@@ -10,7 +10,7 @@ LL |     drop(hold_all);\n    |          -------- borrow later used here\n \n error[E0384]: cannot assign twice to immutable variable `_x1`\n-  --> $DIR/borrowck-move-ref-pattern.rs:11:5\n+  --> $DIR/borrowck-move-ref-pattern.rs:9:5\n    |\n LL |     let [ref _x0_hold, _x1, ref xs_hold @ ..] = arr;\n    |                        ---\n@@ -21,7 +21,7 @@ LL |     _x1 = U;\n    |     ^^^^^^^ cannot assign twice to immutable variable\n \n error[E0505]: cannot move out of `arr[..]` because it is borrowed\n-  --> $DIR/borrowck-move-ref-pattern.rs:13:10\n+  --> $DIR/borrowck-move-ref-pattern.rs:11:10\n    |\n LL |     let [ref _x0_hold, _x1, ref xs_hold @ ..] = arr;\n    |          ------------ borrow of `arr[..]` occurs here\n@@ -32,7 +32,7 @@ LL |     drop(_x0_hold);\n    |          -------- borrow later used here\n \n error[E0502]: cannot borrow `arr[..]` as mutable because it is also borrowed as immutable\n-  --> $DIR/borrowck-move-ref-pattern.rs:15:16\n+  --> $DIR/borrowck-move-ref-pattern.rs:13:16\n    |\n LL |     let [ref _x0_hold, _x1, ref xs_hold @ ..] = arr;\n    |                             ---------------- immutable borrow occurs here\n@@ -44,7 +44,7 @@ LL |     drop(xs_hold);\n    |          ------- immutable borrow later used here\n \n error[E0505]: cannot move out of `arr[..]` because it is borrowed\n-  --> $DIR/borrowck-move-ref-pattern.rs:15:29\n+  --> $DIR/borrowck-move-ref-pattern.rs:13:29\n    |\n LL |     let [ref _x0_hold, _x1, ref xs_hold @ ..] = arr;\n    |                             ---------------- borrow of `arr[..]` occurs here\n@@ -56,7 +56,7 @@ LL |     drop(xs_hold);\n    |          ------- borrow later used here\n \n error[E0505]: cannot move out of `arr[..]` because it is borrowed\n-  --> $DIR/borrowck-move-ref-pattern.rs:15:34\n+  --> $DIR/borrowck-move-ref-pattern.rs:13:34\n    |\n LL |     let [ref _x0_hold, _x1, ref xs_hold @ ..] = arr;\n    |                             ---------------- borrow of `arr[..]` occurs here\n@@ -68,7 +68,7 @@ LL |     drop(xs_hold);\n    |          ------- borrow later used here\n \n error[E0384]: cannot assign twice to immutable variable `_x1`\n-  --> $DIR/borrowck-move-ref-pattern.rs:25:5\n+  --> $DIR/borrowck-move-ref-pattern.rs:23:5\n    |\n LL |     let (ref _x0, _x1, ref _x2, ..) = tup;\n    |                   ---\n@@ -79,7 +79,7 @@ LL |     _x1 = U;\n    |     ^^^^^^^ cannot assign twice to immutable variable\n \n error[E0502]: cannot borrow `tup.0` as mutable because it is also borrowed as immutable\n-  --> $DIR/borrowck-move-ref-pattern.rs:26:20\n+  --> $DIR/borrowck-move-ref-pattern.rs:24:20\n    |\n LL |     let (ref _x0, _x1, ref _x2, ..) = tup;\n    |          ------- immutable borrow occurs here\n@@ -91,7 +91,7 @@ LL |     *_x0 = U;\n    |     -------- immutable borrow later used here\n \n error[E0502]: cannot borrow `tup.0` as mutable because it is also borrowed as immutable\n-  --> $DIR/borrowck-move-ref-pattern.rs:27:10\n+  --> $DIR/borrowck-move-ref-pattern.rs:25:10\n    |\n LL |     let (ref _x0, _x1, ref _x2, ..) = tup;\n    |          ------- immutable borrow occurs here\n@@ -102,7 +102,7 @@ LL |     *_x0 = U;\n    |     -------- immutable borrow later used here\n \n error[E0594]: cannot assign to `*_x0` which is behind a `&` reference\n-  --> $DIR/borrowck-move-ref-pattern.rs:28:5\n+  --> $DIR/borrowck-move-ref-pattern.rs:26:5\n    |\n LL |     let (ref _x0, _x1, ref _x2, ..) = tup;\n    |          ------- help: consider changing this to be a mutable reference: `ref mut _x0`\n@@ -111,7 +111,7 @@ LL |     *_x0 = U;\n    |     ^^^^^^^^ `_x0` is a `&` reference, so the data it refers to cannot be written\n \n error[E0594]: cannot assign to `*_x2` which is behind a `&` reference\n-  --> $DIR/borrowck-move-ref-pattern.rs:29:5\n+  --> $DIR/borrowck-move-ref-pattern.rs:27:5\n    |\n LL |     let (ref _x0, _x1, ref _x2, ..) = tup;\n    |                        ------- help: consider changing this to be a mutable reference: `ref mut _x2`\n@@ -120,7 +120,7 @@ LL |     *_x2 = U;\n    |     ^^^^^^^^ `_x2` is a `&` reference, so the data it refers to cannot be written\n \n error[E0382]: use of moved value: `tup.1`\n-  --> $DIR/borrowck-move-ref-pattern.rs:30:10\n+  --> $DIR/borrowck-move-ref-pattern.rs:28:10\n    |\n LL |     let (ref _x0, _x1, ref _x2, ..) = tup;\n    |                   --- value moved here\n@@ -131,7 +131,7 @@ LL |     drop(tup.1);\n    = note: move occurs because `tup.1` has type `U`, which does not implement the `Copy` trait\n \n error[E0382]: borrow of moved value: `tup.1`\n-  --> $DIR/borrowck-move-ref-pattern.rs:31:20\n+  --> $DIR/borrowck-move-ref-pattern.rs:29:20\n    |\n LL |     drop(tup.1);\n    |          ----- value moved here\n@@ -141,7 +141,7 @@ LL |     let _x1_hold = &tup.1;\n    = note: move occurs because `tup.1` has type `U`, which does not implement the `Copy` trait\n \n error[E0502]: cannot borrow `tup.3` as immutable because it is also borrowed as mutable\n-  --> $DIR/borrowck-move-ref-pattern.rs:33:20\n+  --> $DIR/borrowck-move-ref-pattern.rs:31:20\n    |\n LL |     let (.., ref mut _x3) = tup;\n    |              ----------- mutable borrow occurs here\n@@ -152,7 +152,7 @@ LL |     drop(_x3);\n    |          --- mutable borrow later used here\n \n error[E0499]: cannot borrow `tup.3` as mutable more than once at a time\n-  --> $DIR/borrowck-move-ref-pattern.rs:34:20\n+  --> $DIR/borrowck-move-ref-pattern.rs:32:20\n    |\n LL |     let (.., ref mut _x3) = tup;\n    |              ----------- first mutable borrow occurs here\n@@ -164,7 +164,7 @@ LL |     drop(_x3);\n    |          --- first borrow later used here\n \n error[E0499]: cannot borrow `tup.3` as mutable more than once at a time\n-  --> $DIR/borrowck-move-ref-pattern.rs:35:14\n+  --> $DIR/borrowck-move-ref-pattern.rs:33:14\n    |\n LL |     let (.., ref mut _x3) = tup;\n    |              ----------- first mutable borrow occurs here\n@@ -176,7 +176,7 @@ LL |     drop(_x3);\n    |          --- first borrow later used here\n \n error[E0502]: cannot borrow `tup.3` as immutable because it is also borrowed as mutable\n-  --> $DIR/borrowck-move-ref-pattern.rs:36:14\n+  --> $DIR/borrowck-move-ref-pattern.rs:34:14\n    |\n LL |     let (.., ref mut _x3) = tup;\n    |              ----------- mutable borrow occurs here\n@@ -187,7 +187,7 @@ LL |     drop(_x3);\n    |          --- mutable borrow later used here\n \n error[E0382]: use of moved value: `tup`\n-  --> $DIR/borrowck-move-ref-pattern.rs:45:14\n+  --> $DIR/borrowck-move-ref-pattern.rs:43:14\n    |\n LL |     let mut tup = (U, U, U);\n    |         ------- move occurs because `tup` has type `(U, U, U)`, which does not implement the `Copy` trait"}, {"sha": "18663c3fe3f9681b8eb770b542d8dcbbf2013969", "filename": "src/test/ui/pattern/move-ref-patterns/by-move-sub-pat-unreachable.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/src%2Ftest%2Fui%2Fpattern%2Fmove-ref-patterns%2Fby-move-sub-pat-unreachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/src%2Ftest%2Fui%2Fpattern%2Fmove-ref-patterns%2Fby-move-sub-pat-unreachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fmove-ref-patterns%2Fby-move-sub-pat-unreachable.rs?ref=b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7", "patch": "@@ -4,7 +4,6 @@\n \n // check-pass\n \n-#![feature(move_ref_pattern)]\n #![feature(bindings_after_at)]\n \n fn main() {"}, {"sha": "fb92eb1ba32e0e74be8face458034dc4804ba961", "filename": "src/test/ui/pattern/move-ref-patterns/feature-gate-move_ref_pattern.rs", "status": "removed", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/dd7fc54ebdca419ad9d3ab1e9f5ed14e770768ea/src%2Ftest%2Fui%2Fpattern%2Fmove-ref-patterns%2Ffeature-gate-move_ref_pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd7fc54ebdca419ad9d3ab1e9f5ed14e770768ea/src%2Ftest%2Fui%2Fpattern%2Fmove-ref-patterns%2Ffeature-gate-move_ref_pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fmove-ref-patterns%2Ffeature-gate-move_ref_pattern.rs?ref=dd7fc54ebdca419ad9d3ab1e9f5ed14e770768ea", "patch": "@@ -1,23 +0,0 @@\n-fn main() {\n-    #[derive(Clone)]\n-    struct X {\n-        x: (),\n-    }\n-    let mut tup = (X { x: () }, X { x: () });\n-    match Some(tup.clone()) {\n-        Some((y, ref z)) => {}\n-        //~^ ERROR binding by-move and by-ref in the same pattern is unstable\n-        None => panic!(),\n-    }\n-\n-    let (ref a, b) = tup.clone();\n-    //~^ ERROR binding by-move and by-ref in the same pattern is unstable\n-\n-    let (a, mut b) = &tup;\n-    //~^ ERROR binding by-move and by-ref in the same pattern is unstable\n-    //~| ERROR cannot move out of a shared reference\n-\n-    let (mut a, b) = &mut tup;\n-    //~^ ERROR binding by-move and by-ref in the same pattern is unstable\n-    //~| ERROR cannot move out of a mutable reference\n-}"}, {"sha": "5335569a972b2be307885ba1ff6c847761ba9423", "filename": "src/test/ui/pattern/move-ref-patterns/feature-gate-move_ref_pattern.stderr", "status": "removed", "additions": 0, "deletions": 66, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/dd7fc54ebdca419ad9d3ab1e9f5ed14e770768ea/src%2Ftest%2Fui%2Fpattern%2Fmove-ref-patterns%2Ffeature-gate-move_ref_pattern.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dd7fc54ebdca419ad9d3ab1e9f5ed14e770768ea/src%2Ftest%2Fui%2Fpattern%2Fmove-ref-patterns%2Ffeature-gate-move_ref_pattern.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fmove-ref-patterns%2Ffeature-gate-move_ref_pattern.stderr?ref=dd7fc54ebdca419ad9d3ab1e9f5ed14e770768ea", "patch": "@@ -1,66 +0,0 @@\n-error[E0658]: binding by-move and by-ref in the same pattern is unstable\n-  --> $DIR/feature-gate-move_ref_pattern.rs:8:15\n-   |\n-LL |         Some((y, ref z)) => {}\n-   |               ^  ----- by-ref pattern here\n-   |               |\n-   |               by-move pattern here\n-   |\n-   = note: see issue #68354 <https://github.com/rust-lang/rust/issues/68354> for more information\n-   = help: add `#![feature(move_ref_pattern)]` to the crate attributes to enable\n-\n-error[E0658]: binding by-move and by-ref in the same pattern is unstable\n-  --> $DIR/feature-gate-move_ref_pattern.rs:13:17\n-   |\n-LL |     let (ref a, b) = tup.clone();\n-   |          -----  ^ by-move pattern here\n-   |          |\n-   |          by-ref pattern here\n-   |\n-   = note: see issue #68354 <https://github.com/rust-lang/rust/issues/68354> for more information\n-   = help: add `#![feature(move_ref_pattern)]` to the crate attributes to enable\n-\n-error[E0658]: binding by-move and by-ref in the same pattern is unstable\n-  --> $DIR/feature-gate-move_ref_pattern.rs:16:13\n-   |\n-LL |     let (a, mut b) = &tup;\n-   |          -  ^^^^^ by-move pattern here\n-   |          |\n-   |          by-ref pattern here\n-   |\n-   = note: see issue #68354 <https://github.com/rust-lang/rust/issues/68354> for more information\n-   = help: add `#![feature(move_ref_pattern)]` to the crate attributes to enable\n-\n-error[E0658]: binding by-move and by-ref in the same pattern is unstable\n-  --> $DIR/feature-gate-move_ref_pattern.rs:20:10\n-   |\n-LL |     let (mut a, b) = &mut tup;\n-   |          ^^^^^  - by-ref pattern here\n-   |          |\n-   |          by-move pattern here\n-   |\n-   = note: see issue #68354 <https://github.com/rust-lang/rust/issues/68354> for more information\n-   = help: add `#![feature(move_ref_pattern)]` to the crate attributes to enable\n-\n-error[E0507]: cannot move out of a shared reference\n-  --> $DIR/feature-gate-move_ref_pattern.rs:16:22\n-   |\n-LL |     let (a, mut b) = &tup;\n-   |             -----    ^^^^\n-   |             |\n-   |             data moved here\n-   |             move occurs because `b` has type `X`, which does not implement the `Copy` trait\n-\n-error[E0507]: cannot move out of a mutable reference\n-  --> $DIR/feature-gate-move_ref_pattern.rs:20:22\n-   |\n-LL |     let (mut a, b) = &mut tup;\n-   |          -----       ^^^^^^^^\n-   |          |\n-   |          data moved here\n-   |          move occurs because `a` has type `X`, which does not implement the `Copy` trait\n-\n-error: aborting due to 6 previous errors\n-\n-Some errors have detailed explanations: E0507, E0658.\n-For more information about an error, try `rustc --explain E0507`."}, {"sha": "80effc497ed93ae75c323ce344417b671d68ab2a", "filename": "src/test/ui/pattern/move-ref-patterns/issue-53840.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/src%2Ftest%2Fui%2Fpattern%2Fmove-ref-patterns%2Fissue-53840.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/src%2Ftest%2Fui%2Fpattern%2Fmove-ref-patterns%2Fissue-53840.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fmove-ref-patterns%2Fissue-53840.rs?ref=b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7", "patch": "@@ -1,7 +1,5 @@\n // check-pass\n \n-#![feature(move_ref_pattern)]\n-\n enum E {\n     Foo(String, String, String),\n }"}, {"sha": "ebb1683af7de626ab4cdf1b3c88fa25b1d010330", "filename": "src/test/ui/pattern/move-ref-patterns/move-ref-patterns-closure-captures-inside.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/src%2Ftest%2Fui%2Fpattern%2Fmove-ref-patterns%2Fmove-ref-patterns-closure-captures-inside.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/src%2Ftest%2Fui%2Fpattern%2Fmove-ref-patterns%2Fmove-ref-patterns-closure-captures-inside.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fmove-ref-patterns%2Fmove-ref-patterns-closure-captures-inside.rs?ref=b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7", "patch": "@@ -1,5 +1,3 @@\n-#![feature(move_ref_pattern)]\n-\n fn main() {\n     struct S; // Not `Copy`.\n "}, {"sha": "f19fed0891740604b5abcb1b3f70c280505eee44", "filename": "src/test/ui/pattern/move-ref-patterns/move-ref-patterns-closure-captures-inside.stderr", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/src%2Ftest%2Fui%2Fpattern%2Fmove-ref-patterns%2Fmove-ref-patterns-closure-captures-inside.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/src%2Ftest%2Fui%2Fpattern%2Fmove-ref-patterns%2Fmove-ref-patterns-closure-captures-inside.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fmove-ref-patterns%2Fmove-ref-patterns-closure-captures-inside.stderr?ref=b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7", "patch": "@@ -1,5 +1,5 @@\n error[E0382]: borrow of moved value: `tup0`\n-  --> $DIR/move-ref-patterns-closure-captures-inside.rs:33:10\n+  --> $DIR/move-ref-patterns-closure-captures-inside.rs:31:10\n    |\n LL |     let mut tup0 = (S, S);\n    |         -------- move occurs because `tup0` has type `(S, S)`, which does not implement the `Copy` trait\n@@ -14,7 +14,7 @@ LL |     drop(&tup0);\n    |          ^^^^^ value borrowed here after move\n \n error[E0382]: borrow of moved value: `tup1`\n-  --> $DIR/move-ref-patterns-closure-captures-inside.rs:34:10\n+  --> $DIR/move-ref-patterns-closure-captures-inside.rs:32:10\n    |\n LL |     let mut tup1 = (S, S, S);\n    |         -------- move occurs because `tup1` has type `(S, S, S)`, which does not implement the `Copy` trait\n@@ -29,7 +29,7 @@ LL |     drop(&tup1);\n    |          ^^^^^ value borrowed here after move\n \n error[E0382]: borrow of moved value: `tup2`\n-  --> $DIR/move-ref-patterns-closure-captures-inside.rs:35:10\n+  --> $DIR/move-ref-patterns-closure-captures-inside.rs:33:10\n    |\n LL |     let tup2 = (S, S);\n    |         ---- move occurs because `tup2` has type `(S, S)`, which does not implement the `Copy` trait\n@@ -44,7 +44,7 @@ LL |     drop(&tup2);\n    |          ^^^^^ value borrowed here after move\n \n error[E0382]: borrow of moved value: `tup3`\n-  --> $DIR/move-ref-patterns-closure-captures-inside.rs:36:10\n+  --> $DIR/move-ref-patterns-closure-captures-inside.rs:34:10\n    |\n LL |     let tup3 = (S, S, S);\n    |         ---- move occurs because `tup3` has type `(S, S, S)`, which does not implement the `Copy` trait\n@@ -59,7 +59,7 @@ LL |     drop(&tup3);\n    |          ^^^^^ value borrowed here after move\n \n error[E0382]: borrow of moved value: `tup4`\n-  --> $DIR/move-ref-patterns-closure-captures-inside.rs:41:10\n+  --> $DIR/move-ref-patterns-closure-captures-inside.rs:39:10\n    |\n LL |     let tup4 = (S, S);\n    |         ---- move occurs because `tup4` has type `(S, S)`, which does not implement the `Copy` trait\n@@ -74,7 +74,7 @@ LL |     drop(&tup4.0);\n    |          ^^^^^^^ value borrowed here after move\n \n error[E0382]: borrow of moved value: `arr0`\n-  --> $DIR/move-ref-patterns-closure-captures-inside.rs:43:10\n+  --> $DIR/move-ref-patterns-closure-captures-inside.rs:41:10\n    |\n LL |     let mut arr0 = [S, S, S];\n    |         -------- move occurs because `arr0` has type `[S; 3]`, which does not implement the `Copy` trait\n@@ -89,7 +89,7 @@ LL |     drop(&arr0);\n    |          ^^^^^ value borrowed here after move\n \n error[E0382]: borrow of moved value: `arr1`\n-  --> $DIR/move-ref-patterns-closure-captures-inside.rs:44:36\n+  --> $DIR/move-ref-patterns-closure-captures-inside.rs:42:36\n    |\n LL |     let mut arr1 = [S, S, S, S, S];\n    |         -------- move occurs because `arr1` has type `[S; 5]`, which does not implement the `Copy` trait\n@@ -104,7 +104,7 @@ LL |     let [_, mov1, mov2, mov3, _] = &arr1;\n    |                                    ^^^^^ value borrowed here after move\n \n error[E0382]: borrow of moved value: `arr2`\n-  --> $DIR/move-ref-patterns-closure-captures-inside.rs:45:10\n+  --> $DIR/move-ref-patterns-closure-captures-inside.rs:43:10\n    |\n LL |     let arr2 = [S, S, S];\n    |         ---- move occurs because `arr2` has type `[S; 3]`, which does not implement the `Copy` trait\n@@ -119,7 +119,7 @@ LL |     drop(&arr2);\n    |          ^^^^^ value borrowed here after move\n \n error[E0382]: borrow of moved value: `arr3`\n-  --> $DIR/move-ref-patterns-closure-captures-inside.rs:46:36\n+  --> $DIR/move-ref-patterns-closure-captures-inside.rs:44:36\n    |\n LL |     let arr3 = [S, S, S, S, S];\n    |         ---- move occurs because `arr3` has type `[S; 5]`, which does not implement the `Copy` trait\n@@ -134,7 +134,7 @@ LL |     let [_, mov1, mov2, mov3, _] = &arr3;\n    |                                    ^^^^^ value borrowed here after move\n \n error[E0382]: borrow of moved value: `tup0`\n-  --> $DIR/move-ref-patterns-closure-captures-inside.rs:77:10\n+  --> $DIR/move-ref-patterns-closure-captures-inside.rs:75:10\n    |\n LL |     let mut tup0: Option<(S, S)> = None;\n    |         -------- move occurs because `tup0` has type `Option<(S, S)>`, which does not implement the `Copy` trait\n@@ -148,7 +148,7 @@ LL |     drop(&tup0);\n    |          ^^^^^ value borrowed here after move\n \n error[E0382]: borrow of moved value: `tup1`\n-  --> $DIR/move-ref-patterns-closure-captures-inside.rs:78:10\n+  --> $DIR/move-ref-patterns-closure-captures-inside.rs:76:10\n    |\n LL |     let mut tup1: Option<(S, S, S)> = None;\n    |         -------- move occurs because `tup1` has type `Option<(S, S, S)>`, which does not implement the `Copy` trait\n@@ -163,7 +163,7 @@ LL |     drop(&tup1);\n    |          ^^^^^ value borrowed here after move\n \n error[E0382]: borrow of moved value: `tup2`\n-  --> $DIR/move-ref-patterns-closure-captures-inside.rs:79:10\n+  --> $DIR/move-ref-patterns-closure-captures-inside.rs:77:10\n    |\n LL |     let tup2: Option<(S, S)> = None;\n    |         ---- move occurs because `tup2` has type `Option<(S, S)>`, which does not implement the `Copy` trait\n@@ -178,7 +178,7 @@ LL |     drop(&tup2);\n    |          ^^^^^ value borrowed here after move\n \n error[E0382]: borrow of moved value: `tup3`\n-  --> $DIR/move-ref-patterns-closure-captures-inside.rs:80:10\n+  --> $DIR/move-ref-patterns-closure-captures-inside.rs:78:10\n    |\n LL |     let tup3: Option<(S, S, S)> = None;\n    |         ---- move occurs because `tup3` has type `Option<(S, S, S)>`, which does not implement the `Copy` trait\n@@ -193,7 +193,7 @@ LL |     drop(&tup3);\n    |          ^^^^^ value borrowed here after move\n \n error[E0382]: borrow of moved value: `tup4`\n-  --> $DIR/move-ref-patterns-closure-captures-inside.rs:81:21\n+  --> $DIR/move-ref-patterns-closure-captures-inside.rs:79:21\n    |\n LL |     let tup4: Option<(S, S)> = None;\n    |         ---- move occurs because `tup4` has type `Option<(S, S)>`, which does not implement the `Copy` trait\n@@ -208,7 +208,7 @@ LL |     m!((ref x, _) = &tup4);\n    |                     ^^^^^ value borrowed here after move\n \n error[E0382]: borrow of moved value: `arr0`\n-  --> $DIR/move-ref-patterns-closure-captures-inside.rs:82:10\n+  --> $DIR/move-ref-patterns-closure-captures-inside.rs:80:10\n    |\n LL |     let mut arr0: Option<[S; 3]> = None;\n    |         -------- move occurs because `arr0` has type `Option<[S; 3]>`, which does not implement the `Copy` trait\n@@ -223,7 +223,7 @@ LL |     drop(&arr0);\n    |          ^^^^^ value borrowed here after move\n \n error[E0382]: borrow of moved value: `arr1`\n-  --> $DIR/move-ref-patterns-closure-captures-inside.rs:83:35\n+  --> $DIR/move-ref-patterns-closure-captures-inside.rs:81:35\n    |\n LL |     let mut arr1: Option<[S; 5]> = None;\n    |         -------- move occurs because `arr1` has type `Option<[S; 5]>`, which does not implement the `Copy` trait\n@@ -238,7 +238,7 @@ LL |     m!([_, mov1, mov2, mov3, _] = &arr1);\n    |                                   ^^^^^ value borrowed here after move\n \n error[E0382]: borrow of moved value: `arr2`\n-  --> $DIR/move-ref-patterns-closure-captures-inside.rs:84:10\n+  --> $DIR/move-ref-patterns-closure-captures-inside.rs:82:10\n    |\n LL |     let arr2: Option<[S; 3]> = None;\n    |         ---- move occurs because `arr2` has type `Option<[S; 3]>`, which does not implement the `Copy` trait\n@@ -253,7 +253,7 @@ LL |     drop(&arr2);\n    |          ^^^^^ value borrowed here after move\n \n error[E0382]: borrow of moved value: `arr3`\n-  --> $DIR/move-ref-patterns-closure-captures-inside.rs:85:35\n+  --> $DIR/move-ref-patterns-closure-captures-inside.rs:83:35\n    |\n LL |     let arr3: Option<[S; 5]> = None;\n    |         ---- move occurs because `arr3` has type `Option<[S; 5]>`, which does not implement the `Copy` trait\n@@ -267,7 +267,7 @@ LL |     m!([_, mov1, mov2, mov3, _] = &arr3);\n    |                                   ^^^^^ value borrowed here after move\n \n error[E0382]: borrow of moved value: `tup0`\n-  --> $DIR/move-ref-patterns-closure-captures-inside.rs:113:10\n+  --> $DIR/move-ref-patterns-closure-captures-inside.rs:111:10\n    |\n LL |     let mut tup0: Option<(S, S)> = None;\n    |         -------- move occurs because `tup0` has type `Option<(S, S)>`, which does not implement the `Copy` trait\n@@ -281,7 +281,7 @@ LL |     drop(&tup0);\n    |          ^^^^^ value borrowed here after move\n \n error[E0382]: borrow of moved value: `tup1`\n-  --> $DIR/move-ref-patterns-closure-captures-inside.rs:114:10\n+  --> $DIR/move-ref-patterns-closure-captures-inside.rs:112:10\n    |\n LL |     let mut tup1: Option<(S, S, S)> = None;\n    |         -------- move occurs because `tup1` has type `Option<(S, S, S)>`, which does not implement the `Copy` trait\n@@ -296,7 +296,7 @@ LL |     drop(&tup1);\n    |          ^^^^^ value borrowed here after move\n \n error[E0382]: borrow of moved value: `tup2`\n-  --> $DIR/move-ref-patterns-closure-captures-inside.rs:115:10\n+  --> $DIR/move-ref-patterns-closure-captures-inside.rs:113:10\n    |\n LL |     let tup2: Option<(S, S)> = None;\n    |         ---- move occurs because `tup2` has type `Option<(S, S)>`, which does not implement the `Copy` trait\n@@ -311,7 +311,7 @@ LL |     drop(&tup2);\n    |          ^^^^^ value borrowed here after move\n \n error[E0382]: borrow of moved value: `tup3`\n-  --> $DIR/move-ref-patterns-closure-captures-inside.rs:116:10\n+  --> $DIR/move-ref-patterns-closure-captures-inside.rs:114:10\n    |\n LL |     let tup3: Option<(S, S, S)> = None;\n    |         ---- move occurs because `tup3` has type `Option<(S, S, S)>`, which does not implement the `Copy` trait\n@@ -326,7 +326,7 @@ LL |     drop(&tup3);\n    |          ^^^^^ value borrowed here after move\n \n error[E0382]: borrow of moved value: `tup4`\n-  --> $DIR/move-ref-patterns-closure-captures-inside.rs:117:21\n+  --> $DIR/move-ref-patterns-closure-captures-inside.rs:115:21\n    |\n LL |     let tup4: Option<(S, S)> = None;\n    |         ---- move occurs because `tup4` has type `Option<(S, S)>`, which does not implement the `Copy` trait\n@@ -341,7 +341,7 @@ LL |     m!((ref x, _) = &tup4);\n    |                     ^^^^^ value borrowed here after move\n \n error[E0382]: borrow of moved value: `arr0`\n-  --> $DIR/move-ref-patterns-closure-captures-inside.rs:118:10\n+  --> $DIR/move-ref-patterns-closure-captures-inside.rs:116:10\n    |\n LL |     let mut arr0: Option<[S; 3]> = None;\n    |         -------- move occurs because `arr0` has type `Option<[S; 3]>`, which does not implement the `Copy` trait\n@@ -356,7 +356,7 @@ LL |     drop(&arr0);\n    |          ^^^^^ value borrowed here after move\n \n error[E0382]: borrow of moved value: `arr1`\n-  --> $DIR/move-ref-patterns-closure-captures-inside.rs:119:35\n+  --> $DIR/move-ref-patterns-closure-captures-inside.rs:117:35\n    |\n LL |     let mut arr1: Option<[S; 5]> = None;\n    |         -------- move occurs because `arr1` has type `Option<[S; 5]>`, which does not implement the `Copy` trait\n@@ -371,7 +371,7 @@ LL |     m!([_, mov1, mov2, mov3, _] = &arr1);\n    |                                   ^^^^^ value borrowed here after move\n \n error[E0382]: borrow of moved value: `arr2`\n-  --> $DIR/move-ref-patterns-closure-captures-inside.rs:120:10\n+  --> $DIR/move-ref-patterns-closure-captures-inside.rs:118:10\n    |\n LL |     let arr2: Option<[S; 3]> = None;\n    |         ---- move occurs because `arr2` has type `Option<[S; 3]>`, which does not implement the `Copy` trait\n@@ -386,7 +386,7 @@ LL |     drop(&arr2);\n    |          ^^^^^ value borrowed here after move\n \n error[E0382]: borrow of moved value: `arr3`\n-  --> $DIR/move-ref-patterns-closure-captures-inside.rs:121:35\n+  --> $DIR/move-ref-patterns-closure-captures-inside.rs:119:35\n    |\n LL |     let arr3: Option<[S; 5]> = None;\n    |         ---- move occurs because `arr3` has type `Option<[S; 5]>`, which does not implement the `Copy` trait"}, {"sha": "583f70f41aa70e1c30c560070296f69cf1fbfdee", "filename": "src/test/ui/pattern/move-ref-patterns/move-ref-patterns-closure-captures-pass.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/src%2Ftest%2Fui%2Fpattern%2Fmove-ref-patterns%2Fmove-ref-patterns-closure-captures-pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/src%2Ftest%2Fui%2Fpattern%2Fmove-ref-patterns%2Fmove-ref-patterns-closure-captures-pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fmove-ref-patterns%2Fmove-ref-patterns-closure-captures-pass.rs?ref=b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7", "patch": "@@ -1,7 +1,5 @@\n // check-pass\n \n-#![feature(move_ref_pattern)]\n-\n fn main() {\n     struct U;\n     fn accept_fn_once(_: impl FnOnce()) {}"}, {"sha": "cd619cc41eb27cee082a09fe49517e57ef6392fd", "filename": "src/test/ui/pattern/move-ref-patterns/move-ref-patterns-closure-captures.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/src%2Ftest%2Fui%2Fpattern%2Fmove-ref-patterns%2Fmove-ref-patterns-closure-captures.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/src%2Ftest%2Fui%2Fpattern%2Fmove-ref-patterns%2Fmove-ref-patterns-closure-captures.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fmove-ref-patterns%2Fmove-ref-patterns-closure-captures.rs?ref=b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7", "patch": "@@ -1,5 +1,3 @@\n-#![feature(move_ref_pattern)]\n-\n fn main() {\n     struct U;\n     fn accept_fn_once(_: &impl FnOnce()) {}"}, {"sha": "d96e863939c0229589ba938d3fbd0c1a1c09cb67", "filename": "src/test/ui/pattern/move-ref-patterns/move-ref-patterns-closure-captures.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/src%2Ftest%2Fui%2Fpattern%2Fmove-ref-patterns%2Fmove-ref-patterns-closure-captures.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/src%2Ftest%2Fui%2Fpattern%2Fmove-ref-patterns%2Fmove-ref-patterns-closure-captures.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fmove-ref-patterns%2Fmove-ref-patterns-closure-captures.stderr?ref=b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7", "patch": "@@ -1,5 +1,5 @@\n error[E0525]: expected a closure that implements the `FnMut` trait, but this closure only implements `FnOnce`\n-  --> $DIR/move-ref-patterns-closure-captures.rs:11:14\n+  --> $DIR/move-ref-patterns-closure-captures.rs:9:14\n    |\n LL |     let c1 = || {\n    |              ^^ this closure implements `FnOnce`, not `FnMut`\n@@ -11,7 +11,7 @@ LL |     accept_fn_mut(&c1);\n    |     ------------- the requirement to implement `FnMut` derives from here\n \n error[E0525]: expected a closure that implements the `Fn` trait, but this closure only implements `FnOnce`\n-  --> $DIR/move-ref-patterns-closure-captures.rs:11:14\n+  --> $DIR/move-ref-patterns-closure-captures.rs:9:14\n    |\n LL |     let c1 = || {\n    |              ^^ this closure implements `FnOnce`, not `Fn`\n@@ -23,7 +23,7 @@ LL |     accept_fn(&c1);\n    |     --------- the requirement to implement `Fn` derives from here\n \n error[E0525]: expected a closure that implements the `Fn` trait, but this closure only implements `FnMut`\n-  --> $DIR/move-ref-patterns-closure-captures.rs:22:14\n+  --> $DIR/move-ref-patterns-closure-captures.rs:20:14\n    |\n LL |     let c2 = || {\n    |              ^^ this closure implements `FnMut`, not `Fn`"}, {"sha": "1dd66aad57a33f71afe27f1c0362f54c064db53b", "filename": "src/test/ui/pattern/move-ref-patterns/move-ref-patterns-default-binding-modes.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/src%2Ftest%2Fui%2Fpattern%2Fmove-ref-patterns%2Fmove-ref-patterns-default-binding-modes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/src%2Ftest%2Fui%2Fpattern%2Fmove-ref-patterns%2Fmove-ref-patterns-default-binding-modes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fmove-ref-patterns%2Fmove-ref-patterns-default-binding-modes.rs?ref=b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7", "patch": "@@ -1,5 +1,3 @@\n-#![feature(move_ref_pattern)]\n-\n fn main() {\n     struct U;\n "}, {"sha": "6952c743a3069e5d6dd1f8072abcb8d47e24f6bb", "filename": "src/test/ui/pattern/move-ref-patterns/move-ref-patterns-default-binding-modes.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/src%2Ftest%2Fui%2Fpattern%2Fmove-ref-patterns%2Fmove-ref-patterns-default-binding-modes.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/src%2Ftest%2Fui%2Fpattern%2Fmove-ref-patterns%2Fmove-ref-patterns-default-binding-modes.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fmove-ref-patterns%2Fmove-ref-patterns-default-binding-modes.stderr?ref=b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7", "patch": "@@ -1,5 +1,5 @@\n error[E0507]: cannot move out of a shared reference\n-  --> $DIR/move-ref-patterns-default-binding-modes.rs:10:22\n+  --> $DIR/move-ref-patterns-default-binding-modes.rs:8:22\n    |\n LL |     let (a, mut b) = &p;\n    |             -----    ^^\n@@ -8,7 +8,7 @@ LL |     let (a, mut b) = &p;\n    |             move occurs because `b` has type `U`, which does not implement the `Copy` trait\n \n error[E0507]: cannot move out of a mutable reference\n-  --> $DIR/move-ref-patterns-default-binding-modes.rs:14:22\n+  --> $DIR/move-ref-patterns-default-binding-modes.rs:12:22\n    |\n LL |     let (a, mut b) = &mut p;\n    |             -----    ^^^^^^"}, {"sha": "1d6d9acead1d44478b94dc291f8e7b06dd50b967", "filename": "src/test/ui/pattern/move-ref-patterns/move-ref-patterns-dynamic-semantics.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/src%2Ftest%2Fui%2Fpattern%2Fmove-ref-patterns%2Fmove-ref-patterns-dynamic-semantics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/src%2Ftest%2Fui%2Fpattern%2Fmove-ref-patterns%2Fmove-ref-patterns-dynamic-semantics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fmove-ref-patterns%2Fmove-ref-patterns-dynamic-semantics.rs?ref=b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7", "patch": "@@ -3,8 +3,6 @@\n // This test checks the dynamic semantics and drop order of pattern matching\n // where a product pattern has both a by-move and by-ref binding.\n \n-#![feature(move_ref_pattern)]\n-\n use std::cell::RefCell;\n use std::rc::Rc;\n "}, {"sha": "a3133a1a790705ea0b52d1885859ed3e0887e85d", "filename": "src/test/ui/proc-macro/invalid-punct-ident-1.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/src%2Ftest%2Fui%2Fproc-macro%2Finvalid-punct-ident-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/src%2Ftest%2Fui%2Fproc-macro%2Finvalid-punct-ident-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Finvalid-punct-ident-1.rs?ref=b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7", "patch": "@@ -9,6 +9,9 @@\n // normalize-stderr-test \"note: we would appreciate a bug report.*\\n\\n\" -> \"\"\n // normalize-stderr-test \"note: compiler flags.*\\n\\n\" -> \"\"\n // normalize-stderr-test \"note: rustc.*running on.*\\n\\n\" -> \"\"\n+// normalize-stderr-test \"query stack during panic:\\n\" -> \"\"\n+// normalize-stderr-test \"we're just showing a limited slice of the query stack\\n\" -> \"\"\n+// normalize-stderr-test \"end of query stack\\n\" -> \"\"\n \n #[macro_use]\n extern crate invalid_punct_ident;"}, {"sha": "5ef22709cb37167db23a5164d01cf861e394223e", "filename": "src/test/ui/proc-macro/invalid-punct-ident-1.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/src%2Ftest%2Fui%2Fproc-macro%2Finvalid-punct-ident-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/src%2Ftest%2Fui%2Fproc-macro%2Finvalid-punct-ident-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Finvalid-punct-ident-1.stderr?ref=b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7", "patch": "@@ -1,5 +1,5 @@\n error: proc macro panicked\n-  --> $DIR/invalid-punct-ident-1.rs:16:1\n+  --> $DIR/invalid-punct-ident-1.rs:19:1\n    |\n LL | invalid_punct!();\n    | ^^^^^^^^^^^^^^^^^"}, {"sha": "04a0a8733115a899bface3a292d1d40c08ad50f2", "filename": "src/test/ui/proc-macro/invalid-punct-ident-2.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/src%2Ftest%2Fui%2Fproc-macro%2Finvalid-punct-ident-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/src%2Ftest%2Fui%2Fproc-macro%2Finvalid-punct-ident-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Finvalid-punct-ident-2.rs?ref=b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7", "patch": "@@ -9,6 +9,9 @@\n // normalize-stderr-test \"note: we would appreciate a bug report.*\\n\\n\" -> \"\"\n // normalize-stderr-test \"note: compiler flags.*\\n\\n\" -> \"\"\n // normalize-stderr-test \"note: rustc.*running on.*\\n\\n\" -> \"\"\n+// normalize-stderr-test \"query stack during panic:\\n\" -> \"\"\n+// normalize-stderr-test \"we're just showing a limited slice of the query stack\\n\" -> \"\"\n+// normalize-stderr-test \"end of query stack\\n\" -> \"\"\n \n #[macro_use]\n extern crate invalid_punct_ident;"}, {"sha": "4bd7a5351d3a040ef714c01bb03c74542e5f48ef", "filename": "src/test/ui/proc-macro/invalid-punct-ident-2.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/src%2Ftest%2Fui%2Fproc-macro%2Finvalid-punct-ident-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/src%2Ftest%2Fui%2Fproc-macro%2Finvalid-punct-ident-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Finvalid-punct-ident-2.stderr?ref=b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7", "patch": "@@ -1,5 +1,5 @@\n error: proc macro panicked\n-  --> $DIR/invalid-punct-ident-2.rs:16:1\n+  --> $DIR/invalid-punct-ident-2.rs:19:1\n    |\n LL | invalid_ident!();\n    | ^^^^^^^^^^^^^^^^^"}, {"sha": "aebba341625aeab0b3a4310a4e188ab5dbe605e5", "filename": "src/test/ui/proc-macro/invalid-punct-ident-3.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/src%2Ftest%2Fui%2Fproc-macro%2Finvalid-punct-ident-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/src%2Ftest%2Fui%2Fproc-macro%2Finvalid-punct-ident-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Finvalid-punct-ident-3.rs?ref=b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7", "patch": "@@ -9,6 +9,9 @@\n // normalize-stderr-test \"note: we would appreciate a bug report.*\\n\\n\" -> \"\"\n // normalize-stderr-test \"note: compiler flags.*\\n\\n\" -> \"\"\n // normalize-stderr-test \"note: rustc.*running on.*\\n\\n\" -> \"\"\n+// normalize-stderr-test \"query stack during panic:\\n\" -> \"\"\n+// normalize-stderr-test \"we're just showing a limited slice of the query stack\\n\" -> \"\"\n+// normalize-stderr-test \"end of query stack\\n\" -> \"\"\n \n #[macro_use]\n extern crate invalid_punct_ident;"}, {"sha": "072d13956ac6c8e2d08041dd0bf0d7f005f6ac79", "filename": "src/test/ui/proc-macro/invalid-punct-ident-3.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/src%2Ftest%2Fui%2Fproc-macro%2Finvalid-punct-ident-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/src%2Ftest%2Fui%2Fproc-macro%2Finvalid-punct-ident-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Finvalid-punct-ident-3.stderr?ref=b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7", "patch": "@@ -1,5 +1,5 @@\n error: proc macro panicked\n-  --> $DIR/invalid-punct-ident-3.rs:16:1\n+  --> $DIR/invalid-punct-ident-3.rs:19:1\n    |\n LL | invalid_raw_ident!();\n    | ^^^^^^^^^^^^^^^^^^^^^"}, {"sha": "4a3ba9aee7453a66589c0867d5450a5746397c81", "filename": "src/test/ui/proc-macro/load-panic-backtrace.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/src%2Ftest%2Fui%2Fproc-macro%2Fload-panic-backtrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/src%2Ftest%2Fui%2Fproc-macro%2Fload-panic-backtrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fload-panic-backtrace.rs?ref=b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7", "patch": "@@ -10,6 +10,9 @@\n // normalize-stderr-test \"note: we would appreciate a bug report.*\\n\\n\" -> \"\"\n // normalize-stderr-test \"note: compiler flags.*\\n\\n\" -> \"\"\n // normalize-stderr-test \"note: rustc.*running on.*\\n\\n\" -> \"\"\n+// normalize-stderr-test \"query stack during panic:\\n\" -> \"\"\n+// normalize-stderr-test \"we're just showing a limited slice of the query stack\\n\" -> \"\"\n+// normalize-stderr-test \"end of query stack\\n\" -> \"\"\n \n #[macro_use]\n extern crate test_macros;"}, {"sha": "f825047e331686cd78490ccf12ba6c96b2ac5215", "filename": "src/test/ui/proc-macro/load-panic-backtrace.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/src%2Ftest%2Fui%2Fproc-macro%2Fload-panic-backtrace.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/src%2Ftest%2Fui%2Fproc-macro%2Fload-panic-backtrace.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fload-panic-backtrace.stderr?ref=b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7", "patch": "@@ -1,6 +1,6 @@\n at 'panic-derive', $DIR/auxiliary/test-macros.rs:43:5\n error: proc-macro derive panicked\n-  --> $DIR/load-panic-backtrace.rs:17:10\n+  --> $DIR/load-panic-backtrace.rs:20:10\n    |\n LL | #[derive(Panic)]\n    |          ^^^^^"}, {"sha": "d6c5a13b1bdb03fe465fc06b26874dd32d691af2", "filename": "src/test/ui/rfc-2005-default-binding-mode/for.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/src%2Ftest%2Fui%2Frfc-2005-default-binding-mode%2Ffor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/src%2Ftest%2Fui%2Frfc-2005-default-binding-mode%2Ffor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2005-default-binding-mode%2Ffor.rs?ref=b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7", "patch": "@@ -1,5 +1,3 @@\n-#![feature(move_ref_pattern)]\n-\n struct Foo {}\n \n pub fn main() {"}, {"sha": "9cc20a7bf3144ffa05e86a1452db184d4a4fbc9e", "filename": "src/test/ui/rfc-2005-default-binding-mode/for.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/src%2Ftest%2Fui%2Frfc-2005-default-binding-mode%2Ffor.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/src%2Ftest%2Fui%2Frfc-2005-default-binding-mode%2Ffor.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2005-default-binding-mode%2Ffor.stderr?ref=b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7", "patch": "@@ -1,5 +1,5 @@\n error[E0507]: cannot move out of a shared reference\n-  --> $DIR/for.rs:8:23\n+  --> $DIR/for.rs:6:23\n    |\n LL |     for (n, mut m) in &tups {\n    |             -----     ^^^^^"}, {"sha": "5cda17fd6a1fc31b491db066d4d59b964cffff77", "filename": "src/test/ui/span/issue-34264.stderr", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/src%2Ftest%2Fui%2Fspan%2Fissue-34264.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/src%2Ftest%2Fui%2Fspan%2Fissue-34264.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fissue-34264.stderr?ref=b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7", "patch": "@@ -53,13 +53,16 @@ LL | fn bar(_: x, y: usize) {}\n error[E0061]: this function takes 2 arguments but 3 arguments were supplied\n   --> $DIR/issue-34264.rs:7:5\n    |\n-LL | fn foo(Option<i32>, String) {}\n-   | --------------------------- defined here\n-...\n LL |     foo(Some(42), 2, \"\");\n    |     ^^^ --------  -  -- supplied 3 arguments\n    |     |\n    |     expected 2 arguments\n+   |\n+note: function defined here\n+  --> $DIR/issue-34264.rs:1:4\n+   |\n+LL | fn foo(Option<i32>, String) {}\n+   |    ^^^ -----------  ------\n \n error[E0308]: mismatched types\n   --> $DIR/issue-34264.rs:8:13\n@@ -70,13 +73,16 @@ LL |     bar(\"\", \"\");\n error[E0061]: this function takes 2 arguments but 3 arguments were supplied\n   --> $DIR/issue-34264.rs:10:5\n    |\n-LL | fn bar(x, y: usize) {}\n-   | ------------------- defined here\n-...\n LL |     bar(1, 2, 3);\n    |     ^^^ -  -  - supplied 3 arguments\n    |     |\n    |     expected 2 arguments\n+   |\n+note: function defined here\n+  --> $DIR/issue-34264.rs:3:4\n+   |\n+LL | fn bar(x, y: usize) {}\n+   |    ^^^ -  --------\n \n error: aborting due to 6 previous errors\n "}, {"sha": "b15da2cb47955c27462ad3945abc8c4126a1beb9", "filename": "src/test/ui/span/missing-unit-argument.stderr", "status": "modified", "additions": 27, "deletions": 15, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/src%2Ftest%2Fui%2Fspan%2Fmissing-unit-argument.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/src%2Ftest%2Fui%2Fspan%2Fmissing-unit-argument.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fmissing-unit-argument.stderr?ref=b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7", "patch": "@@ -12,34 +12,42 @@ LL |     let _: Result<(), String> = Ok(());\n error[E0061]: this function takes 2 arguments but 0 arguments were supplied\n   --> $DIR/missing-unit-argument.rs:12:5\n    |\n-LL | fn foo(():(), ():()) {}\n-   | -------------------- defined here\n-...\n LL |     foo();\n    |     ^^^-- supplied 0 arguments\n    |     |\n    |     expected 2 arguments\n+   |\n+note: function defined here\n+  --> $DIR/missing-unit-argument.rs:1:4\n+   |\n+LL | fn foo(():(), ():()) {}\n+   |    ^^^ -----  -----\n \n error[E0061]: this function takes 2 arguments but 1 argument was supplied\n   --> $DIR/missing-unit-argument.rs:13:5\n    |\n-LL | fn foo(():(), ():()) {}\n-   | -------------------- defined here\n-...\n LL |     foo(());\n    |     ^^^ -- supplied 1 argument\n    |     |\n    |     expected 2 arguments\n+   |\n+note: function defined here\n+  --> $DIR/missing-unit-argument.rs:1:4\n+   |\n+LL | fn foo(():(), ():()) {}\n+   |    ^^^ -----  -----\n \n error[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> $DIR/missing-unit-argument.rs:14:5\n    |\n-LL | fn bar(():()) {}\n-   | ------------- defined here\n-...\n LL |     bar();\n    |     ^^^-- supplied 0 arguments\n    |\n+note: function defined here\n+  --> $DIR/missing-unit-argument.rs:2:4\n+   |\n+LL | fn bar(():()) {}\n+   |    ^^^ -----\n help: expected the unit value `()`; create it with empty parentheses\n    |\n LL |     bar(());\n@@ -48,12 +56,14 @@ LL |     bar(());\n error[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> $DIR/missing-unit-argument.rs:15:7\n    |\n-LL |     fn baz(self, (): ()) { }\n-   |     -------------------- defined here\n-...\n LL |     S.baz();\n    |       ^^^- supplied 0 arguments\n    |\n+note: associated function defined here\n+  --> $DIR/missing-unit-argument.rs:6:8\n+   |\n+LL |     fn baz(self, (): ()) { }\n+   |        ^^^ ----  ------\n help: expected the unit value `()`; create it with empty parentheses\n    |\n LL |     S.baz(());\n@@ -62,12 +72,14 @@ LL |     S.baz(());\n error[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> $DIR/missing-unit-argument.rs:16:7\n    |\n-LL |     fn generic<T>(self, _: T) { }\n-   |     ------------------------- defined here\n-...\n LL |     S.generic::<()>();\n    |       ^^^^^^^------ supplied 0 arguments\n    |\n+note: associated function defined here\n+  --> $DIR/missing-unit-argument.rs:7:8\n+   |\n+LL |     fn generic<T>(self, _: T) { }\n+   |        ^^^^^^^    ----  ----\n help: expected the unit value `()`; create it with empty parentheses\n    |\n LL |     S.generic::<()>(());"}, {"sha": "8a9a1e5793588359990969bcc0589614bda38667", "filename": "src/test/ui/suggestions/mut-borrow-needed-by-trait.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/src%2Ftest%2Fui%2Fsuggestions%2Fmut-borrow-needed-by-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/src%2Ftest%2Fui%2Fsuggestions%2Fmut-borrow-needed-by-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fmut-borrow-needed-by-trait.stderr?ref=b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7", "patch": "@@ -13,7 +13,7 @@ error[E0277]: the trait bound `&dyn std::io::Write: std::io::Write` is not satis\n LL |     let fp = BufWriter::new(fp);\n    |              ^^^^^^^^^^^^^^ the trait `std::io::Write` is not implemented for `&dyn std::io::Write`\n    | \n-  ::: $SRC_DIR/std/src/io/buffered.rs:LL:COL\n+  ::: $SRC_DIR/std/src/io/buffered/bufwriter.rs:LL:COL\n    |\n LL | pub struct BufWriter<W: Write> {\n    |                         ----- required by this bound in `BufWriter`\n@@ -26,7 +26,7 @@ error[E0277]: the trait bound `&dyn std::io::Write: std::io::Write` is not satis\n LL |     let fp = BufWriter::new(fp);\n    |              ^^^^^^^^^^^^^^^^^^ the trait `std::io::Write` is not implemented for `&dyn std::io::Write`\n    | \n-  ::: $SRC_DIR/std/src/io/buffered.rs:LL:COL\n+  ::: $SRC_DIR/std/src/io/buffered/bufwriter.rs:LL:COL\n    |\n LL | pub struct BufWriter<W: Write> {\n    |                         ----- required by this bound in `BufWriter`\n@@ -39,7 +39,7 @@ error[E0599]: no method named `write_fmt` found for struct `BufWriter<&dyn std::\n LL |     writeln!(fp, \"hello world\").unwrap();\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ method not found in `BufWriter<&dyn std::io::Write>`\n    | \n-  ::: $SRC_DIR/std/src/io/buffered.rs:LL:COL\n+  ::: $SRC_DIR/std/src/io/buffered/bufwriter.rs:LL:COL\n    |\n LL | pub struct BufWriter<W: Write> {\n    | ------------------------------ doesn't satisfy `BufWriter<&dyn std::io::Write>: std::io::Write`"}, {"sha": "5f822f6660c092c3b01246ebe5f4f86899999aef", "filename": "src/test/ui/symbol-names/issue-75326.legacy.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/src%2Ftest%2Fui%2Fsymbol-names%2Fissue-75326.legacy.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/src%2Ftest%2Fui%2Fsymbol-names%2Fissue-75326.legacy.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsymbol-names%2Fissue-75326.legacy.stderr?ref=b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7", "patch": "@@ -0,0 +1,20 @@\n+error: symbol-name(_ZN72_$LT$issue_75326..Foo$LT$I$C$E$GT$$u20$as$u20$issue_75326..Iterator2$GT$4next17SYMBOL_HASH)\n+  --> $DIR/issue-75326.rs:43:5\n+   |\n+LL |     #[rustc_symbol_name]\n+   |     ^^^^^^^^^^^^^^^^^^^^\n+\n+error: demangling(<issue_75326::Foo<I,E> as issue_75326::Iterator2>::next::SYMBOL_HASH)\n+  --> $DIR/issue-75326.rs:43:5\n+   |\n+LL |     #[rustc_symbol_name]\n+   |     ^^^^^^^^^^^^^^^^^^^^\n+\n+error: demangling-alt(<issue_75326::Foo<I,E> as issue_75326::Iterator2>::next)\n+  --> $DIR/issue-75326.rs:43:5\n+   |\n+LL |     #[rustc_symbol_name]\n+   |     ^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 3 previous errors\n+"}, {"sha": "ce315164cefd352fa82656c441b418eed0de7a1f", "filename": "src/test/ui/symbol-names/issue-75326.rs", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/src%2Ftest%2Fui%2Fsymbol-names%2Fissue-75326.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/src%2Ftest%2Fui%2Fsymbol-names%2Fissue-75326.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsymbol-names%2Fissue-75326.rs?ref=b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7", "patch": "@@ -0,0 +1,58 @@\n+// build-fail\n+// ignore-tidy-linelength\n+// revisions: legacy v0\n+//[legacy]compile-flags: -Z symbol-mangling-version=legacy\n+//[v0]compile-flags: -Z symbol-mangling-version=v0\n+//[legacy]normalize-stderr-32bit: \"h[\\d\\w]+\" -> \"SYMBOL_HASH\"\n+//[legacy]normalize-stderr-64bit: \"h[\\d\\w]+\" -> \"SYMBOL_HASH\"\n+\n+#![feature(rustc_attrs)]\n+\n+pub(crate) struct Foo<I, E>(I, E);\n+\n+pub trait Iterator2 {\n+    type Item;\n+\n+    fn next(&mut self) -> Option<Self::Item>;\n+\n+    fn find<P>(&mut self, predicate: P) -> Option<Self::Item>\n+    where\n+        Self: Sized,\n+        P: FnMut(&Self::Item) -> bool,\n+    {\n+        unimplemented!()\n+    }\n+}\n+\n+struct Bar;\n+\n+impl Iterator2 for Bar {\n+    type Item = (u32, u16);\n+\n+    fn next(&mut self) -> Option<Self::Item> {\n+        unimplemented!()\n+    }\n+}\n+\n+impl<I, T, E> Iterator2 for Foo<I, E>\n+where\n+    I: Iterator2<Item = (T, E)>,\n+{\n+    type Item = T;\n+\n+    #[rustc_symbol_name]\n+    //[legacy]~^ ERROR symbol-name(_ZN72_$LT$issue_75326..Foo$LT$I$C$E$GT$$u20$as$u20$issue_75326..Iterator2$GT$4next\n+    //[legacy]~| ERROR demangling(<issue_75326::Foo<I,E> as issue_75326::Iterator2>::next\n+    //[legacy]~| ERROR demangling-alt(<issue_75326::Foo<I,E> as issue_75326::Iterator2>::next)\n+    //[v0]~^^^^  ERROR symbol-name(_RNvXINICs4fqI2P2rA04_11issue_75326s_0pppEINtB5_3FooppENtB5_9Iterator24nextB5_)\n+    //[v0]~|     ERROR demangling(<issue_75326[317d481089b8c8fe]::Foo<_, _> as issue_75326[317d481089b8c8fe]::Iterator2>::next)\n+    //[v0]~|     ERROR demangling-alt(<issue_75326::Foo<_, _> as issue_75326::Iterator2>::next)\n+    fn next(&mut self) -> Option<Self::Item> {\n+        self.find(|_| true)\n+    }\n+}\n+\n+fn main() {\n+    let mut a = Foo(Bar, 1u16);\n+    let _ = a.next();\n+}"}, {"sha": "59bdfa8ca36810db6a9438543e12d1b633d88d5f", "filename": "src/test/ui/symbol-names/issue-75326.v0.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/src%2Ftest%2Fui%2Fsymbol-names%2Fissue-75326.v0.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/src%2Ftest%2Fui%2Fsymbol-names%2Fissue-75326.v0.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsymbol-names%2Fissue-75326.v0.stderr?ref=b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7", "patch": "@@ -0,0 +1,20 @@\n+error: symbol-name(_RNvXINICs4fqI2P2rA04_11issue_75326s_0pppEINtB5_3FooppENtB5_9Iterator24nextB5_)\n+  --> $DIR/issue-75326.rs:43:5\n+   |\n+LL |     #[rustc_symbol_name]\n+   |     ^^^^^^^^^^^^^^^^^^^^\n+\n+error: demangling(<issue_75326[317d481089b8c8fe]::Foo<_, _> as issue_75326[317d481089b8c8fe]::Iterator2>::next)\n+  --> $DIR/issue-75326.rs:43:5\n+   |\n+LL |     #[rustc_symbol_name]\n+   |     ^^^^^^^^^^^^^^^^^^^^\n+\n+error: demangling-alt(<issue_75326::Foo<_, _> as issue_75326::Iterator2>::next)\n+  --> $DIR/issue-75326.rs:43:5\n+   |\n+LL |     #[rustc_symbol_name]\n+   |     ^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 3 previous errors\n+"}, {"sha": "20e260584513a0385c323012fb36f1805183e9b0", "filename": "src/test/ui/type-alias-enum-variants/enum-variant-priority-higher-than-other-inherent.stderr", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/src%2Ftest%2Fui%2Ftype-alias-enum-variants%2Fenum-variant-priority-higher-than-other-inherent.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/src%2Ftest%2Fui%2Ftype-alias-enum-variants%2Fenum-variant-priority-higher-than-other-inherent.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-enum-variants%2Fenum-variant-priority-higher-than-other-inherent.stderr?ref=b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7", "patch": "@@ -1,13 +1,16 @@\n error[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> $DIR/enum-variant-priority-higher-than-other-inherent.rs:21:5\n    |\n-LL |     V(u8)\n-   |     ----- defined here\n-...\n LL |     <E>::V();\n    |     ^^^^^^-- supplied 0 arguments\n    |     |\n    |     expected 1 argument\n+   |\n+note: tuple variant defined here\n+  --> $DIR/enum-variant-priority-higher-than-other-inherent.rs:5:5\n+   |\n+LL |     V(u8)\n+   |     ^^^^^\n \n error[E0308]: mismatched types\n   --> $DIR/enum-variant-priority-higher-than-other-inherent.rs:22:17"}, {"sha": "805828eece1f26f4c46cf4c9f3806b58882e0868", "filename": "src/tools/clippy/src/driver.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/src%2Ftools%2Fclippy%2Fsrc%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/src%2Ftools%2Fclippy%2Fsrc%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdriver.rs?ref=b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7", "patch": "@@ -277,9 +277,9 @@ fn report_clippy_ice(info: &panic::PanicInfo<'_>, bug_report_url: &str) {\n     // If backtraces are enabled, also print the query stack\n     let backtrace = env::var_os(\"RUST_BACKTRACE\").map_or(false, |x| &x != \"0\");\n \n-    if backtrace {\n-        TyCtxt::try_print_query_stack(&handler);\n-    }\n+    let num_frames = if backtrace { None } else { Some(2) };\n+\n+    TyCtxt::try_print_query_stack(&handler, num_frames);\n }\n \n fn toolchain_path(home: Option<String>, toolchain: Option<String>) -> Option<PathBuf> {"}, {"sha": "a1b8e2ee162cf67eb3722946e1884415b768149c", "filename": "src/tools/clippy/tests/ui/custom_ice_message.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcustom_ice_message.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcustom_ice_message.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcustom_ice_message.stderr?ref=b6e2dc6cdece6b498b876bc7e9377ff7d63d93e7", "patch": "@@ -9,3 +9,5 @@ note: we would appreciate a bug report: https://github.com/rust-lang/rust-clippy\n \n note: Clippy version: foo\n \n+query stack during panic:\n+end of query stack"}]}