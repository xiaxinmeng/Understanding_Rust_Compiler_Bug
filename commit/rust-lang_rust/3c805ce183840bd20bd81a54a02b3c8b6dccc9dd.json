{"sha": "3c805ce183840bd20bd81a54a02b3c8b6dccc9dd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNjODA1Y2UxODM4NDBiZDIwYmQ4MWE1NGEwMmIzYzhiNmRjY2M5ZGQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-06-20T02:36:49Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-06-20T02:36:49Z"}, "message": "Auto merge of #60341 - mtak-:macos-tlv-workaround, r=alexcrichton\n\nmacos tlv workaround\n\nfixes: #60141\n\nIncludes:\n* remove dead code: `requires_move_before_drop`. This hasn't been needed for a while now (oops I should have removed it in #57655)\n* redox had a copy of `fast::Key` (not sure why?). That has been removed.\n* Perform a `read_volatile` on OSX to reduce `tlv_get_addr` calls per `__getit` from (4-2 depending on context) to 1.\n\n`tlv_get_addr` is relatively expensive (~1.5ns on my machine).\n\nPreviously, in contexts where `__getit` was inlined, 4 calls to `tlv_get_addr` were performed per lookup. For some reason when `__getit` is not inlined this is reduced to 2x - and performance improves to match.\n\nAfter this PR, I have only ever seen 1x call to `tlv_get_addr` per `__getit`, and macos now benefits from situations where `__getit` is inlined.\n\nI'm not sure if the `read_volatile(&&__KEY)` trick is working around an LLVM bug, or a rustc bug, or neither.\n\nr? @alexcrichton", "tree": {"sha": "a0a847566bd4884f4909343779a67e833a5ca7d6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a0a847566bd4884f4909343779a67e833a5ca7d6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3c805ce183840bd20bd81a54a02b3c8b6dccc9dd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3c805ce183840bd20bd81a54a02b3c8b6dccc9dd", "html_url": "https://github.com/rust-lang/rust/commit/3c805ce183840bd20bd81a54a02b3c8b6dccc9dd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3c805ce183840bd20bd81a54a02b3c8b6dccc9dd/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7d107613498c500699dcf89aab7231c28a8fa3af", "url": "https://api.github.com/repos/rust-lang/rust/commits/7d107613498c500699dcf89aab7231c28a8fa3af", "html_url": "https://github.com/rust-lang/rust/commit/7d107613498c500699dcf89aab7231c28a8fa3af"}, {"sha": "b148c25cacd05a0268537ead29881357317a4073", "url": "https://api.github.com/repos/rust-lang/rust/commits/b148c25cacd05a0268537ead29881357317a4073", "html_url": "https://github.com/rust-lang/rust/commit/b148c25cacd05a0268537ead29881357317a4073"}], "stats": {"total": 433, "additions": 196, "deletions": 237}, "files": [{"sha": "05464787a05d3c594f5bdd203715bff88b460d47", "filename": "src/libstd/sys/redox/fast_thread_local.rs", "status": "modified", "additions": 1, "deletions": 108, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/3c805ce183840bd20bd81a54a02b3c8b6dccc9dd/src%2Flibstd%2Fsys%2Fredox%2Ffast_thread_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c805ce183840bd20bd81a54a02b3c8b6dccc9dd/src%2Flibstd%2Fsys%2Fredox%2Ffast_thread_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Ffast_thread_local.rs?ref=3c805ce183840bd20bd81a54a02b3c8b6dccc9dd", "patch": "@@ -1,111 +1,4 @@\n #![cfg(target_thread_local)]\n #![unstable(feature = \"thread_local_internals\", issue = \"0\")]\n \n-use crate::cell::{Cell, UnsafeCell};\n-use crate::mem;\n-use crate::ptr;\n-\n-\n-pub struct Key<T> {\n-    inner: UnsafeCell<Option<T>>,\n-\n-    // Metadata to keep track of the state of the destructor. Remember that\n-    // these variables are thread-local, not global.\n-    dtor_registered: Cell<bool>,\n-    dtor_running: Cell<bool>,\n-}\n-\n-unsafe impl<T> Sync for Key<T> { }\n-\n-impl<T> Key<T> {\n-    pub const fn new() -> Key<T> {\n-        Key {\n-            inner: UnsafeCell::new(None),\n-            dtor_registered: Cell::new(false),\n-            dtor_running: Cell::new(false)\n-        }\n-    }\n-\n-    pub fn get(&'static self) -> Option<&'static UnsafeCell<Option<T>>> {\n-        unsafe {\n-            if mem::needs_drop::<T>() && self.dtor_running.get() {\n-                return None\n-            }\n-            self.register_dtor();\n-        }\n-        Some(&self.inner)\n-    }\n-\n-    unsafe fn register_dtor(&self) {\n-        if !mem::needs_drop::<T>() || self.dtor_registered.get() {\n-            return\n-        }\n-\n-        register_dtor(self as *const _ as *mut u8,\n-                      destroy_value::<T>);\n-        self.dtor_registered.set(true);\n-    }\n-}\n-\n-pub unsafe fn register_dtor(t: *mut u8, dtor: unsafe extern fn(*mut u8)) {\n-    // The fallback implementation uses a vanilla OS-based TLS key to track\n-    // the list of destructors that need to be run for this thread. The key\n-    // then has its own destructor which runs all the other destructors.\n-    //\n-    // The destructor for DTORS is a little special in that it has a `while`\n-    // loop to continuously drain the list of registered destructors. It\n-    // *should* be the case that this loop always terminates because we\n-    // provide the guarantee that a TLS key cannot be set after it is\n-    // flagged for destruction.\n-    use crate::sys_common::thread_local as os;\n-\n-    static DTORS: os::StaticKey = os::StaticKey::new(Some(run_dtors));\n-    type List = Vec<(*mut u8, unsafe extern fn(*mut u8))>;\n-    if DTORS.get().is_null() {\n-        let v: Box<List> = box Vec::new();\n-        DTORS.set(Box::into_raw(v) as *mut u8);\n-    }\n-    let list: &mut List = &mut *(DTORS.get() as *mut List);\n-    list.push((t, dtor));\n-\n-    unsafe extern fn run_dtors(mut ptr: *mut u8) {\n-        while !ptr.is_null() {\n-            let list: Box<List> = Box::from_raw(ptr as *mut List);\n-            for (ptr, dtor) in list.into_iter() {\n-                dtor(ptr);\n-            }\n-            ptr = DTORS.get();\n-            DTORS.set(ptr::null_mut());\n-        }\n-    }\n-}\n-\n-pub unsafe extern fn destroy_value<T>(ptr: *mut u8) {\n-    let ptr = ptr as *mut Key<T>;\n-    // Right before we run the user destructor be sure to flag the\n-    // destructor as running for this thread so calls to `get` will return\n-    // `None`.\n-    (*ptr).dtor_running.set(true);\n-\n-    // The macOS implementation of TLS apparently had an odd aspect to it\n-    // where the pointer we have may be overwritten while this destructor\n-    // is running. Specifically if a TLS destructor re-accesses TLS it may\n-    // trigger a re-initialization of all TLS variables, paving over at\n-    // least some destroyed ones with initial values.\n-    //\n-    // This means that if we drop a TLS value in place on macOS that we could\n-    // revert the value to its original state halfway through the\n-    // destructor, which would be bad!\n-    //\n-    // Hence, we use `ptr::read` on macOS (to move to a \"safe\" location)\n-    // instead of drop_in_place.\n-    if cfg!(target_os = \"macos\") {\n-        ptr::read((*ptr).inner.get());\n-    } else {\n-        ptr::drop_in_place((*ptr).inner.get());\n-    }\n-}\n-\n-pub fn requires_move_before_drop() -> bool {\n-    false\n-}\n+pub use crate::sys_common::thread_local::register_dtor_fallback as register_dtor;"}, {"sha": "c34c2e6e786ec5bf38b09baa16524ff1a9636dc0", "filename": "src/libstd/sys/unix/fast_thread_local.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3c805ce183840bd20bd81a54a02b3c8b6dccc9dd/src%2Flibstd%2Fsys%2Funix%2Ffast_thread_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c805ce183840bd20bd81a54a02b3c8b6dccc9dd/src%2Flibstd%2Fsys%2Funix%2Ffast_thread_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ffast_thread_local.rs?ref=3c805ce183840bd20bd81a54a02b3c8b6dccc9dd", "patch": "@@ -82,7 +82,3 @@ pub unsafe fn register_dtor(t: *mut u8, dtor: unsafe extern fn(*mut u8)) {\n         }\n     }\n }\n-\n-pub fn requires_move_before_drop() -> bool {\n-    false\n-}"}, {"sha": "31d0bd1e72ed2056806846c362a4e98b1d3a1307", "filename": "src/libstd/sys/windows/fast_thread_local.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3c805ce183840bd20bd81a54a02b3c8b6dccc9dd/src%2Flibstd%2Fsys%2Fwindows%2Ffast_thread_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c805ce183840bd20bd81a54a02b3c8b6dccc9dd/src%2Flibstd%2Fsys%2Fwindows%2Ffast_thread_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Ffast_thread_local.rs?ref=3c805ce183840bd20bd81a54a02b3c8b6dccc9dd", "patch": "@@ -2,7 +2,3 @@\n #![cfg(target_thread_local)]\n \n pub use crate::sys_common::thread_local::register_dtor_fallback as register_dtor;\n-\n-pub fn requires_move_before_drop() -> bool {\n-    false\n-}"}, {"sha": "9b355aa2023ff64d54912ef5fb0457054fd4225f", "filename": "src/libstd/thread/local.rs", "status": "modified", "additions": 183, "deletions": 107, "changes": 290, "blob_url": "https://github.com/rust-lang/rust/blob/3c805ce183840bd20bd81a54a02b3c8b6dccc9dd/src%2Flibstd%2Fthread%2Flocal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c805ce183840bd20bd81a54a02b3c8b6dccc9dd/src%2Flibstd%2Fthread%2Flocal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Flocal.rs?ref=3c805ce183840bd20bd81a54a02b3c8b6dccc9dd", "patch": "@@ -2,10 +2,7 @@\n \n #![unstable(feature = \"thread_local_internals\", issue = \"0\")]\n \n-use crate::cell::UnsafeCell;\n use crate::fmt;\n-use crate::hint;\n-use crate::mem;\n \n /// A thread local storage key which owns its contents.\n ///\n@@ -92,10 +89,7 @@ pub struct LocalKey<T: 'static> {\n     // trivially devirtualizable by LLVM because the value of `inner` never\n     // changes and the constant should be readonly within a crate. This mainly\n     // only runs into problems when TLS statics are exported across crates.\n-    inner: unsafe fn() -> Option<&'static UnsafeCell<Option<T>>>,\n-\n-    // initialization routine to invoke to create a value\n-    init: fn() -> T,\n+    inner: unsafe fn() -> Option<&'static T>,\n }\n \n #[stable(feature = \"std_debug\", since = \"1.16.0\")]\n@@ -159,10 +153,7 @@ macro_rules! __thread_local_inner {\n             #[inline]\n             fn __init() -> $t { $init }\n \n-            unsafe fn __getit() -> $crate::option::Option<\n-                &'static $crate::cell::UnsafeCell<\n-                    $crate::option::Option<$t>>>\n-            {\n+            unsafe fn __getit() -> $crate::option::Option<&'static $t> {\n                 #[cfg(all(target_arch = \"wasm32\", not(target_feature = \"atomics\")))]\n                 static __KEY: $crate::thread::__StaticLocalKeyInner<$t> =\n                     $crate::thread::__StaticLocalKeyInner::new();\n@@ -182,11 +173,11 @@ macro_rules! __thread_local_inner {\n                 static __KEY: $crate::thread::__OsLocalKeyInner<$t> =\n                     $crate::thread::__OsLocalKeyInner::new();\n \n-                __KEY.get()\n+                __KEY.get(__init)\n             }\n \n             unsafe {\n-                $crate::thread::LocalKey::new(__getit, __init)\n+                $crate::thread::LocalKey::new(__getit)\n             }\n         }\n     };\n@@ -221,11 +212,9 @@ impl<T: 'static> LocalKey<T> {\n     #[unstable(feature = \"thread_local_internals\",\n                reason = \"recently added to create a key\",\n                issue = \"0\")]\n-    pub const unsafe fn new(inner: unsafe fn() -> Option<&'static UnsafeCell<Option<T>>>,\n-                            init: fn() -> T) -> LocalKey<T> {\n+    pub const unsafe fn new(inner: unsafe fn() -> Option<&'static T>) -> LocalKey<T> {\n         LocalKey {\n             inner,\n-            init,\n         }\n     }\n \n@@ -246,37 +235,6 @@ impl<T: 'static> LocalKey<T> {\n                                  after it is destroyed\")\n     }\n \n-    unsafe fn init(&self, slot: &UnsafeCell<Option<T>>) -> &T {\n-        // Execute the initialization up front, *then* move it into our slot,\n-        // just in case initialization fails.\n-        let value = (self.init)();\n-        let ptr = slot.get();\n-\n-        // note that this can in theory just be `*ptr = Some(value)`, but due to\n-        // the compiler will currently codegen that pattern with something like:\n-        //\n-        //      ptr::drop_in_place(ptr)\n-        //      ptr::write(ptr, Some(value))\n-        //\n-        // Due to this pattern it's possible for the destructor of the value in\n-        // `ptr` (e.g., if this is being recursively initialized) to re-access\n-        // TLS, in which case there will be a `&` and `&mut` pointer to the same\n-        // value (an aliasing violation). To avoid setting the \"I'm running a\n-        // destructor\" flag we just use `mem::replace` which should sequence the\n-        // operations a little differently and make this safe to call.\n-        mem::replace(&mut *ptr, Some(value));\n-\n-        // After storing `Some` we want to get a reference to the contents of\n-        // what we just stored. While we could use `unwrap` here and it should\n-        // always work it empirically doesn't seem to always get optimized away,\n-        // which means that using something like `try_with` can pull in\n-        // panicking code and cause a large size bloat.\n-        match *ptr {\n-            Some(ref x) => x,\n-            None => hint::unreachable_unchecked(),\n-        }\n-    }\n-\n     /// Acquires a reference to the value in this TLS key.\n     ///\n     /// This will lazily initialize the value if this thread has not referenced\n@@ -293,13 +251,68 @@ impl<T: 'static> LocalKey<T> {\n         F: FnOnce(&T) -> R,\n     {\n         unsafe {\n-            let slot = (self.inner)().ok_or(AccessError {\n+            let thread_local = (self.inner)().ok_or(AccessError {\n                 _private: (),\n             })?;\n-            Ok(f(match *slot.get() {\n-                Some(ref inner) => inner,\n-                None => self.init(slot),\n-            }))\n+            Ok(f(thread_local))\n+        }\n+    }\n+}\n+\n+mod lazy {\n+    use crate::cell::UnsafeCell;\n+    use crate::mem;\n+    use crate::hint;\n+\n+    pub struct LazyKeyInner<T> {\n+        inner: UnsafeCell<Option<T>>,\n+    }\n+\n+    impl<T> LazyKeyInner<T> {\n+        pub const fn new() -> LazyKeyInner<T> {\n+            LazyKeyInner {\n+                inner: UnsafeCell::new(None),\n+            }\n+        }\n+\n+        pub unsafe fn get(&self) -> Option<&'static T> {\n+            (*self.inner.get()).as_ref()\n+        }\n+\n+        pub unsafe fn initialize<F: FnOnce() -> T>(&self, init: F) -> &'static T {\n+            // Execute the initialization up front, *then* move it into our slot,\n+            // just in case initialization fails.\n+            let value = init();\n+            let ptr = self.inner.get();\n+\n+            // note that this can in theory just be `*ptr = Some(value)`, but due to\n+            // the compiler will currently codegen that pattern with something like:\n+            //\n+            //      ptr::drop_in_place(ptr)\n+            //      ptr::write(ptr, Some(value))\n+            //\n+            // Due to this pattern it's possible for the destructor of the value in\n+            // `ptr` (e.g., if this is being recursively initialized) to re-access\n+            // TLS, in which case there will be a `&` and `&mut` pointer to the same\n+            // value (an aliasing violation). To avoid setting the \"I'm running a\n+            // destructor\" flag we just use `mem::replace` which should sequence the\n+            // operations a little differently and make this safe to call.\n+            mem::replace(&mut *ptr, Some(value));\n+\n+            // After storing `Some` we want to get a reference to the contents of\n+            // what we just stored. While we could use `unwrap` here and it should\n+            // always work it empirically doesn't seem to always get optimized away,\n+            // which means that using something like `try_with` can pull in\n+            // panicking code and cause a large size bloat.\n+            match *ptr {\n+                Some(ref x) => x,\n+                None => hint::unreachable_unchecked(),\n+            }\n+        }\n+\n+        #[allow(unused)]\n+        pub unsafe fn take(&mut self) -> Option<T> {\n+            (*self.inner.get()).take()\n         }\n     }\n }\n@@ -309,11 +322,11 @@ impl<T: 'static> LocalKey<T> {\n #[doc(hidden)]\n #[cfg(all(target_arch = \"wasm32\", not(target_feature = \"atomics\")))]\n pub mod statik {\n-    use crate::cell::UnsafeCell;\n+    use super::lazy::LazyKeyInner;\n     use crate::fmt;\n \n     pub struct Key<T> {\n-        inner: UnsafeCell<Option<T>>,\n+        inner: LazyKeyInner<T>,\n     }\n \n     unsafe impl<T> Sync for Key<T> { }\n@@ -327,32 +340,55 @@ pub mod statik {\n     impl<T> Key<T> {\n         pub const fn new() -> Key<T> {\n             Key {\n-                inner: UnsafeCell::new(None),\n+                inner: LazyKeyInner::new(),\n             }\n         }\n \n-        pub unsafe fn get(&self) -> Option<&'static UnsafeCell<Option<T>>> {\n-            Some(&*(&self.inner as *const _))\n+        pub unsafe fn get(&self, init: fn() -> T) -> Option<&'static T> {\n+            let value = match self.inner.get() {\n+                Some(ref value) => value,\n+                None => self.inner.initialize(init),\n+            };\n+            Some(value)\n         }\n     }\n }\n \n #[doc(hidden)]\n #[cfg(target_thread_local)]\n pub mod fast {\n-    use crate::cell::{Cell, UnsafeCell};\n+    use super::lazy::LazyKeyInner;\n+    use crate::cell::Cell;\n     use crate::fmt;\n     use crate::mem;\n-    use crate::ptr;\n-    use crate::sys::fast_thread_local::{register_dtor, requires_move_before_drop};\n+    use crate::sys::fast_thread_local::register_dtor;\n \n+    #[derive(Copy, Clone)]\n+    enum DtorState {\n+        Unregistered,\n+        Registered,\n+        RunningOrHasRun,\n+    }\n+\n+    // This data structure has been carefully constructed so that the fast path\n+    // only contains one branch on x86. That optimization is necessary to avoid\n+    // duplicated tls lookups on OSX.\n+    //\n+    // LLVM issue: https://bugs.llvm.org/show_bug.cgi?id=41722\n     pub struct Key<T> {\n-        inner: UnsafeCell<Option<T>>,\n+        // If `LazyKeyInner::get` returns `None`, that indicates either:\n+        //   * The value has never been initialized\n+        //   * The value is being recursively initialized\n+        //   * The value has already been destroyed or is being destroyed\n+        // To determine which kind of `None`, check `dtor_state`.\n+        //\n+        // This is very optimizer friendly for the fast path - initialized but\n+        // not yet dropped.\n+        inner: LazyKeyInner<T>,\n \n         // Metadata to keep track of the state of the destructor. Remember that\n-        // these variables are thread-local, not global.\n-        dtor_registered: Cell<bool>,\n-        dtor_running: Cell<bool>,\n+        // this variable is thread-local, not global.\n+        dtor_state: Cell<DtorState>,\n     }\n \n     impl<T> fmt::Debug for Key<T> {\n@@ -364,54 +400,75 @@ pub mod fast {\n     impl<T> Key<T> {\n         pub const fn new() -> Key<T> {\n             Key {\n-                inner: UnsafeCell::new(None),\n-                dtor_registered: Cell::new(false),\n-                dtor_running: Cell::new(false)\n+                inner: LazyKeyInner::new(),\n+                dtor_state: Cell::new(DtorState::Unregistered),\n             }\n         }\n \n-        pub unsafe fn get(&self) -> Option<&'static UnsafeCell<Option<T>>> {\n-            if mem::needs_drop::<T>() && self.dtor_running.get() {\n-                return None\n+        pub unsafe fn get<F: FnOnce() -> T>(&self, init: F) -> Option<&'static T> {\n+            match self.inner.get() {\n+                Some(val) => Some(val),\n+                None => self.try_initialize(init),\n             }\n-            self.register_dtor();\n-            Some(&*(&self.inner as *const _))\n         }\n \n-        unsafe fn register_dtor(&self) {\n-            if !mem::needs_drop::<T>() || self.dtor_registered.get() {\n-                return\n+        // `try_initialize` is only called once per fast thread local variable,\n+        // except in corner cases where thread_local dtors reference other\n+        // thread_local's, or it is being recursively initialized.\n+        //\n+        // Macos: Inlining this function can cause two `tlv_get_addr` calls to\n+        // be performed for every call to `Key::get`. The #[cold] hint makes\n+        // that less likely.\n+        // LLVM issue: https://bugs.llvm.org/show_bug.cgi?id=41722\n+        #[cold]\n+        unsafe fn try_initialize<F: FnOnce() -> T>(&self, init: F) -> Option<&'static T> {\n+            if !mem::needs_drop::<T>() || self.try_register_dtor() {\n+                Some(self.inner.initialize(init))\n+            } else {\n+                None\n             }\n+        }\n \n-            register_dtor(self as *const _ as *mut u8,\n-                          destroy_value::<T>);\n-            self.dtor_registered.set(true);\n+        // `try_register_dtor` is only called once per fast thread local\n+        // variable, except in corner cases where thread_local dtors reference\n+        // other thread_local's, or it is being recursively initialized.\n+        unsafe fn try_register_dtor(&self) -> bool {\n+            match self.dtor_state.get() {\n+                DtorState::Unregistered => {\n+                    // dtor registration happens before initialization.\n+                    register_dtor(self as *const _ as *mut u8,\n+                                destroy_value::<T>);\n+                    self.dtor_state.set(DtorState::Registered);\n+                    true\n+                }\n+                DtorState::Registered => {\n+                    // recursively initialized\n+                    true\n+                }\n+                DtorState::RunningOrHasRun => {\n+                    false\n+                }\n+            }\n         }\n     }\n \n     unsafe extern fn destroy_value<T>(ptr: *mut u8) {\n         let ptr = ptr as *mut Key<T>;\n-        // Right before we run the user destructor be sure to flag the\n-        // destructor as running for this thread so calls to `get` will return\n-        // `None`.\n-        (*ptr).dtor_running.set(true);\n \n-        // Some implementations may require us to move the value before we drop\n-        // it as it could get re-initialized in-place during destruction.\n-        //\n-        // Hence, we use `ptr::read` on those platforms (to move to a \"safe\"\n-        // location) instead of drop_in_place.\n-        if requires_move_before_drop() {\n-            ptr::read((*ptr).inner.get());\n-        } else {\n-            ptr::drop_in_place((*ptr).inner.get());\n-        }\n+        // Right before we run the user destructor be sure to set the\n+        // `Option<T>` to `None`, and `dtor_state` to `RunningOrHasRun`. This\n+        // causes future calls to `get` to run `try_initialize_drop` again,\n+        // which will now fail, and return `None`.\n+        let value = (*ptr).inner.take();\n+        (*ptr).dtor_state.set(DtorState::RunningOrHasRun);\n+        drop(value);\n     }\n }\n \n #[doc(hidden)]\n pub mod os {\n-    use crate::cell::{Cell, UnsafeCell};\n+    use super::lazy::LazyKeyInner;\n+    use crate::cell::Cell;\n     use crate::fmt;\n     use crate::marker;\n     use crate::ptr;\n@@ -432,8 +489,8 @@ pub mod os {\n     unsafe impl<T> Sync for Key<T> { }\n \n     struct Value<T: 'static> {\n+        inner: LazyKeyInner<T>,\n         key: &'static Key<T>,\n-        value: UnsafeCell<Option<T>>,\n     }\n \n     impl<T: 'static> Key<T> {\n@@ -444,24 +501,43 @@ pub mod os {\n             }\n         }\n \n-        pub unsafe fn get(&'static self) -> Option<&'static UnsafeCell<Option<T>>> {\n+        pub unsafe fn get(&'static self, init: fn() -> T) -> Option<&'static T> {\n             let ptr = self.os.get() as *mut Value<T>;\n-            if !ptr.is_null() {\n-                if ptr as usize == 1 {\n-                    return None\n+            if ptr as usize > 1 {\n+                match (*ptr).inner.get() {\n+                    Some(ref value) => return Some(value),\n+                    None => {},\n                 }\n-                return Some(&(*ptr).value);\n+            }\n+            self.try_initialize(init)\n+        }\n+\n+        // `try_initialize` is only called once per os thread local variable,\n+        // except in corner cases where thread_local dtors reference other\n+        // thread_local's, or it is being recursively initialized.\n+        unsafe fn try_initialize(&'static self, init: fn() -> T) -> Option<&'static T> {\n+            let ptr = self.os.get() as *mut Value<T>;\n+            if ptr as usize == 1 {\n+                // destructor is running\n+                return None\n             }\n \n-            // If the lookup returned null, we haven't initialized our own\n-            // local copy, so do that now.\n-            let ptr: Box<Value<T>> = box Value {\n-                key: self,\n-                value: UnsafeCell::new(None),\n+            let ptr = if ptr.is_null() {\n+                // If the lookup returned null, we haven't initialized our own\n+                // local copy, so do that now.\n+                let ptr: Box<Value<T>> = box Value {\n+                    inner: LazyKeyInner::new(),\n+                    key: self,\n+                };\n+                let ptr = Box::into_raw(ptr);\n+                self.os.set(ptr as *mut u8);\n+                ptr\n+            } else {\n+                // recursive initialization\n+                ptr\n             };\n-            let ptr = Box::into_raw(ptr);\n-            self.os.set(ptr as *mut u8);\n-            Some(&(*ptr).value)\n+\n+            Some((*ptr).inner.initialize(init))\n         }\n     }\n "}, {"sha": "dae27c4785f15b6fd024476ebbe0221647d72f4b", "filename": "src/test/compile-fail/issue-43733-2.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3c805ce183840bd20bd81a54a02b3c8b6dccc9dd/src%2Ftest%2Fcompile-fail%2Fissue-43733-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c805ce183840bd20bd81a54a02b3c8b6dccc9dd/src%2Ftest%2Fcompile-fail%2Fissue-43733-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-43733-2.rs?ref=3c805ce183840bd20bd81a54a02b3c8b6dccc9dd", "patch": "@@ -5,15 +5,15 @@\n #[cfg(not(target_thread_local))]\n struct Key<T> {\n     _data: std::cell::UnsafeCell<Option<T>>,\n-    _flag: std::cell::Cell<bool>,\n+    _flag: std::cell::Cell<()>,\n }\n \n #[cfg(not(target_thread_local))]\n impl<T> Key<T> {\n     const fn new() -> Self {\n         Key {\n             _data: std::cell::UnsafeCell::new(None),\n-            _flag: std::cell::Cell::new(false),\n+            _flag: std::cell::Cell::new(()),\n         }\n     }\n }\n@@ -23,6 +23,6 @@ use std::thread::__FastLocalKeyInner as Key;\n \n static __KEY: Key<()> = Key::new();\n //~^ ERROR `std::cell::UnsafeCell<std::option::Option<()>>` cannot be shared between threads\n-//~| ERROR `std::cell::Cell<bool>` cannot be shared between threads safely [E0277]\n+//~| ERROR cannot be shared between threads safely [E0277]\n \n fn main() {}"}, {"sha": "a602d7667c48dd2201f643590f87d8e122075efe", "filename": "src/test/ui/issues/issue-43733.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3c805ce183840bd20bd81a54a02b3c8b6dccc9dd/src%2Ftest%2Fui%2Fissues%2Fissue-43733.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c805ce183840bd20bd81a54a02b3c8b6dccc9dd/src%2Ftest%2Fui%2Fissues%2Fissue-43733.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-43733.rs?ref=3c805ce183840bd20bd81a54a02b3c8b6dccc9dd", "patch": "@@ -13,15 +13,13 @@ static __KEY: std::thread::__FastLocalKeyInner<Foo> =\n static __KEY: std::thread::__OsLocalKeyInner<Foo> =\n     std::thread::__OsLocalKeyInner::new();\n \n-fn __getit() -> std::option::Option<\n-    &'static std::cell::UnsafeCell<\n-        std::option::Option<Foo>>>\n+fn __getit() -> std::option::Option<&'static Foo>\n {\n-    __KEY.get() //~ ERROR call to unsafe function is unsafe\n+    __KEY.get(Default::default) //~ ERROR call to unsafe function is unsafe\n }\n \n static FOO: std::thread::LocalKey<Foo> =\n-    std::thread::LocalKey::new(__getit, Default::default);\n+    std::thread::LocalKey::new(__getit);\n //~^ ERROR call to unsafe function is unsafe\n \n fn main() {"}, {"sha": "ee6a3b065d6eef292e7c55e41d1ffd938e3bcac1", "filename": "src/test/ui/issues/issue-43733.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3c805ce183840bd20bd81a54a02b3c8b6dccc9dd/src%2Ftest%2Fui%2Fissues%2Fissue-43733.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3c805ce183840bd20bd81a54a02b3c8b6dccc9dd/src%2Ftest%2Fui%2Fissues%2Fissue-43733.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-43733.stderr?ref=3c805ce183840bd20bd81a54a02b3c8b6dccc9dd", "patch": "@@ -1,16 +1,16 @@\n error[E0133]: call to unsafe function is unsafe and requires unsafe function or block\n-  --> $DIR/issue-43733.rs:20:5\n+  --> $DIR/issue-43733.rs:18:5\n    |\n-LL |     __KEY.get()\n-   |     ^^^^^^^^^^^ call to unsafe function\n+LL |     __KEY.get(Default::default)\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n    |\n    = note: consult the function's documentation for information on how to avoid undefined behavior\n \n error[E0133]: call to unsafe function is unsafe and requires unsafe function or block\n-  --> $DIR/issue-43733.rs:24:5\n+  --> $DIR/issue-43733.rs:22:5\n    |\n-LL |     std::thread::LocalKey::new(__getit, Default::default);\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n+LL |     std::thread::LocalKey::new(__getit);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n    |\n    = note: consult the function's documentation for information on how to avoid undefined behavior\n "}]}