{"sha": "ad188d4c3db34f035408afbdd6d2f3c308121f0a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFkMTg4ZDRjM2RiMzRmMDM1NDA4YWZiZGQ2ZDJmM2MzMDgxMjFmMGE=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-07-29T11:37:48Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-07-29T11:37:48Z"}, "message": "kill old tree", "tree": {"sha": "0c6cdea50ab664a361fa4c0f6b99cb53ce00529b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0c6cdea50ab664a361fa4c0f6b99cb53ce00529b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ad188d4c3db34f035408afbdd6d2f3c308121f0a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ad188d4c3db34f035408afbdd6d2f3c308121f0a", "html_url": "https://github.com/rust-lang/rust/commit/ad188d4c3db34f035408afbdd6d2f3c308121f0a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ad188d4c3db34f035408afbdd6d2f3c308121f0a/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c12450fb4e30c3418555e47d045bb9fd4318a10a", "url": "https://api.github.com/repos/rust-lang/rust/commits/c12450fb4e30c3418555e47d045bb9fd4318a10a", "html_url": "https://github.com/rust-lang/rust/commit/c12450fb4e30c3418555e47d045bb9fd4318a10a"}], "stats": {"total": 465, "additions": 21, "deletions": 444}, "files": [{"sha": "619ad62e50897b11155fd9e8e5d01015a5702805", "filename": "src/lib.rs", "status": "modified", "additions": 4, "deletions": 41, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/ad188d4c3db34f035408afbdd6d2f3c308121f0a/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad188d4c3db34f035408afbdd6d2f3c308121f0a/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=ad188d4c3db34f035408afbdd6d2f3c308121f0a", "patch": "@@ -26,52 +26,21 @@ mod yellow;\n \n pub mod syntax_kinds;\n pub use text_unit::{TextRange, TextUnit};\n-pub use tree::{File, Node, SyntaxKind, Token};\n-pub(crate) use tree::{ErrorMsg, FileBuilder, Sink, GreenBuilder};\n+pub use tree::{SyntaxKind, Token};\n+pub(crate) use tree::{Sink, GreenBuilder};\n pub use lexer::{next_token, tokenize};\n pub use yellow::SyntaxNode;\n pub(crate) use yellow::SError;\n-pub use parser::{parse, parse_green};\n+pub use parser::{parse_green};\n \n /// Utilities for simple uses of the parser.\n pub mod utils {\n     use std::fmt::Write;\n \n-    use {File, Node, SyntaxNode};\n+    use {SyntaxNode};\n     use std::collections::BTreeSet;\n     use SError;\n \n-    /// Parse a file and create a string representation of the resulting parse tree.\n-    pub fn dump_tree(file: &File) -> String {\n-        let mut result = String::new();\n-        go(file.root(), &mut result, 0);\n-        return result;\n-\n-        fn go(node: Node, buff: &mut String, level: usize) {\n-            buff.push_str(&String::from(\"  \").repeat(level));\n-            write!(buff, \"{:?}\\n\", node).unwrap();\n-            let my_errors = node.errors().filter(|e| e.after_child().is_none());\n-            let parent_errors = node.parent()\n-                .into_iter()\n-                .flat_map(|n| n.errors())\n-                .filter(|e| e.after_child() == Some(node));\n-\n-            for err in my_errors {\n-                buff.push_str(&String::from(\"  \").repeat(level));\n-                write!(buff, \"err: `{}`\\n\", err.message()).unwrap();\n-            }\n-\n-            for child in node.children() {\n-                go(child, buff, level + 1)\n-            }\n-\n-            for err in parent_errors {\n-                buff.push_str(&String::from(\"  \").repeat(level));\n-                write!(buff, \"err: `{}`\\n\", err.message()).unwrap();\n-            }\n-        }\n-    }\n-\n     /// Parse a file and create a string representation of the resulting parse tree.\n     pub fn dump_tree_green(syntax: &SyntaxNode) -> String {\n         let mut errors: BTreeSet<_> = syntax.root.errors.iter().cloned().collect();\n@@ -82,12 +51,6 @@ pub mod utils {\n         fn go(node: &SyntaxNode, buff: &mut String, level: usize, errors: &mut BTreeSet<SError>) {\n             buff.push_str(&String::from(\"  \").repeat(level));\n             write!(buff, \"{:?}\\n\", node).unwrap();\n-//            let my_errors = node.errors().filter(|e| e.after_child().is_none());\n-//            let parent_errors = node.parent()\n-//                .into_iter()\n-//                .flat_map(|n| n.errors())\n-//                .filter(|e| e.after_child() == Some(node));\n-//\n             let my_errors: Vec<_> = errors.iter().filter(|e| e.offset == node.range().start())\n                 .cloned().collect();\n             for err in my_errors {"}, {"sha": "83039c664fa1f869fe96c3f156c6cfa07c3d17a4", "filename": "src/parser/event.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ad188d4c3db34f035408afbdd6d2f3c308121f0a/src%2Fparser%2Fevent.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad188d4c3db34f035408afbdd6d2f3c308121f0a/src%2Fparser%2Fevent.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fparser%2Fevent.rs?ref=ad188d4c3db34f035408afbdd6d2f3c308121f0a", "patch": "@@ -1,5 +1,5 @@\n use {\n-    ErrorMsg, File, FileBuilder, Sink, SyntaxKind, Token, GreenBuilder,\n+    Sink, SyntaxKind, Token,\n     syntax_kinds::TOMBSTONE,\n };\n use super::is_insignificant;\n@@ -67,12 +67,6 @@ pub(crate) enum Event {\n     },\n }\n \n-pub(super) fn to_file(text: String, tokens: &[Token], events: Vec<Event>) -> File {\n-    let mut builder = FileBuilder::new(text);\n-    process(&mut builder, tokens, events);\n-    builder.finish()\n-}\n-\n pub(super) fn process(builder: &mut Sink, tokens: &[Token], events: Vec<Event>) {\n     let mut idx = 0;\n \n@@ -147,7 +141,7 @@ pub(super) fn process(builder: &mut Sink, tokens: &[Token], events: Vec<Event>)\n                 }\n                 builder.leaf(kind, len);\n             }\n-            &Event::Error { ref msg } => builder.error(ErrorMsg { msg: msg.clone() }),\n+            &Event::Error { ref msg } => builder.error(msg.clone()),\n         }\n     }\n }"}, {"sha": "b7d5e5832731b44e424be3e2d255737bafbe8c40", "filename": "src/parser/mod.rs", "status": "modified", "additions": 1, "deletions": 13, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ad188d4c3db34f035408afbdd6d2f3c308121f0a/src%2Fparser%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad188d4c3db34f035408afbdd6d2f3c308121f0a/src%2Fparser%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fparser%2Fmod.rs?ref=ad188d4c3db34f035408afbdd6d2f3c308121f0a", "patch": "@@ -7,26 +7,14 @@ mod grammar;\n \n use std::sync::Arc;\n use {\n-    File, SyntaxKind, Token,\n+    Token,\n     yellow::SyntaxNode,\n     syntax_kinds::*\n };\n use GreenBuilder;\n use parser::event::process;\n \n \n-/// Parse a sequence of tokens into the representative node tree\n-pub fn parse(text: String, tokens: &[Token]) -> File {\n-    let events = {\n-        let input = input::ParserInput::new(&text, tokens);\n-        let parser_impl = parser::imp::ParserImpl::new(&input);\n-        let mut parser = parser::Parser(parser_impl);\n-        grammar::file(&mut parser);\n-        parser.0.into_events()\n-    };\n-    event::to_file(text, tokens, events)\n-}\n-\n /// Parse a sequence of tokens into the representative node tree\n pub fn parse_green(text: String, tokens: &[Token]) -> SyntaxNode {\n     let events = {"}, {"sha": "f5d1751f9f5b7929b5444f07a26f0352b562ab81", "filename": "src/tree/file_builder.rs", "status": "modified", "additions": 3, "deletions": 147, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/ad188d4c3db34f035408afbdd6d2f3c308121f0a/src%2Ftree%2Ffile_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad188d4c3db34f035408afbdd6d2f3c308121f0a/src%2Ftree%2Ffile_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftree%2Ffile_builder.rs?ref=ad188d4c3db34f035408afbdd6d2f3c308121f0a", "patch": "@@ -12,157 +12,13 @@ use {\n     SyntaxKind, TextRange, TextUnit,\n     yellow::GreenNode\n };\n-use super::{File, NodeData, NodeIdx, SyntaxErrorData};\n use SError;\n \n pub(crate) trait Sink {\n     fn leaf(&mut self, kind: SyntaxKind, len: TextUnit);\n     fn start_internal(&mut self, kind: SyntaxKind);\n     fn finish_internal(&mut self);\n-    fn error(&mut self, err: ErrorMsg);\n-}\n-\n-#[derive(Debug)]\n-pub(crate) struct FileBuilder {\n-    text: String,\n-    nodes: Vec<NodeData>,\n-    errors: Vec<SyntaxErrorData>,\n-    in_progress: Vec<(NodeIdx, Option<NodeIdx>)>,\n-    // (parent, last_child)\n-    pos: TextUnit,\n-}\n-\n-impl Sink for FileBuilder {\n-    fn leaf(&mut self, kind: SyntaxKind, len: TextUnit) {\n-        let leaf = NodeData {\n-            kind,\n-            range: TextRange::offset_len(self.pos, len),\n-            parent: None,\n-            first_child: None,\n-            next_sibling: None,\n-        };\n-        self.pos += len;\n-        let id = self.push_child(leaf);\n-        self.add_len(id);\n-    }\n-\n-    fn start_internal(&mut self, kind: SyntaxKind) {\n-        let node = NodeData {\n-            kind,\n-            range: TextRange::offset_len(self.pos, 0.into()),\n-            parent: None,\n-            first_child: None,\n-            next_sibling: None,\n-        };\n-        let id = if self.in_progress.is_empty() {\n-            self.new_node(node)\n-        } else {\n-            self.push_child(node)\n-        };\n-        self.in_progress.push((id, None))\n-    }\n-\n-    fn finish_internal(&mut self) {\n-        let (id, _) = self.in_progress\n-            .pop()\n-            .expect(\"trying to complete a node, but there are no in-progress nodes\");\n-        if !self.in_progress.is_empty() {\n-            self.add_len(id);\n-        }\n-    }\n-\n-    fn error(&mut self, err: ErrorMsg) {\n-        let &(node, after_child) = self.in_progress.last().unwrap();\n-        self.errors.push(SyntaxErrorData {\n-            node,\n-            message: err.msg,\n-            after_child,\n-        })\n-    }\n-}\n-\n-impl FileBuilder {\n-    pub fn new(text: String) -> FileBuilder {\n-        FileBuilder {\n-            text,\n-            nodes: Vec::new(),\n-            errors: Vec::new(),\n-            in_progress: Vec::new(),\n-            pos: 0.into(),\n-        }\n-    }\n-\n-    pub fn finish(self) -> File {\n-        assert!(\n-            self.in_progress.is_empty(),\n-            \"some nodes in FileBuilder are unfinished: {:?}\",\n-            self.in_progress\n-                .iter()\n-                .map(|&(idx, _)| self.nodes[idx].kind)\n-                .collect::<Vec<_>>()\n-        );\n-        assert_eq!(\n-            self.pos,\n-            (self.text.len() as u32).into(),\n-            \"nodes in FileBuilder do not cover the whole file\"\n-        );\n-        File {\n-            text: self.text,\n-            nodes: self.nodes,\n-            errors: self.errors,\n-        }\n-    }\n-\n-    fn new_node(&mut self, data: NodeData) -> NodeIdx {\n-        let id = NodeIdx(self.nodes.len() as u32);\n-        self.nodes.push(data);\n-        id\n-    }\n-\n-    fn push_child(&mut self, mut child: NodeData) -> NodeIdx {\n-        child.parent = Some(self.current_id());\n-        let id = self.new_node(child);\n-        {\n-            let (parent, sibling) = *self.in_progress.last().unwrap();\n-            let slot = if let Some(idx) = sibling {\n-                &mut self.nodes[idx].next_sibling\n-            } else {\n-                &mut self.nodes[parent].first_child\n-            };\n-            fill(slot, id);\n-        }\n-        self.in_progress.last_mut().unwrap().1 = Some(id);\n-        id\n-    }\n-\n-    fn add_len(&mut self, child: NodeIdx) {\n-        let range = self.nodes[child].range;\n-        grow(&mut self.current_parent().range, range);\n-    }\n-\n-    fn current_id(&self) -> NodeIdx {\n-        self.in_progress.last().unwrap().0\n-    }\n-\n-    fn current_parent(&mut self) -> &mut NodeData {\n-        let idx = self.current_id();\n-        &mut self.nodes[idx]\n-    }\n-}\n-\n-fn fill<T>(slot: &mut Option<T>, value: T) {\n-    assert!(slot.is_none());\n-    *slot = Some(value);\n-}\n-\n-fn grow(left: &mut TextRange, right: TextRange) {\n-    assert_eq!(left.end(), right.start());\n-    *left = TextRange::from_to(left.start(), right.end())\n-}\n-\n-#[derive(Default)]\n-pub(crate) struct ErrorMsg {\n-    pub(crate) msg: String,\n+    fn error(&mut self, err: String);\n }\n \n pub(crate) struct GreenBuilder {\n@@ -216,8 +72,8 @@ impl Sink for GreenBuilder {\n         }\n     }\n \n-    fn error(&mut self, err: ErrorMsg) {\n-        self.errors.push(SError { message: err.msg, offset: self.pos })\n+    fn error(&mut self, message: String) {\n+        self.errors.push(SError { message, offset: self.pos })\n     }\n }\n impl SyntaxKind {"}, {"sha": "efba8282501a2b2a13ac4c3d76e76652d1b7fa82", "filename": "src/tree/mod.rs", "status": "modified", "additions": 3, "deletions": 218, "changes": 221, "blob_url": "https://github.com/rust-lang/rust/blob/ad188d4c3db34f035408afbdd6d2f3c308121f0a/src%2Ftree%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad188d4c3db34f035408afbdd6d2f3c308121f0a/src%2Ftree%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftree%2Fmod.rs?ref=ad188d4c3db34f035408afbdd6d2f3c308121f0a", "patch": "@@ -1,8 +1,8 @@\n mod file_builder;\n \n-use ::{TextRange, TextUnit};\n-use std::{fmt, cmp};\n-pub(crate) use self::file_builder::{ErrorMsg, FileBuilder, Sink, GreenBuilder};\n+use ::{TextUnit};\n+use std::{fmt};\n+pub(crate) use self::file_builder::{Sink, GreenBuilder};\n \n pub use syntax_kinds::SyntaxKind;\n \n@@ -25,218 +25,3 @@ pub struct Token {\n     /// The length of the token.\n     pub len: TextUnit,\n }\n-\n-/// The contents of a Rust source file.\n-#[derive(Debug)]\n-pub struct File {\n-    text: String,\n-    nodes: Vec<NodeData>,\n-    errors: Vec<SyntaxErrorData>,\n-}\n-\n-impl File {\n-    /// The root node of this source file.\n-    pub fn root<'f>(&'f self) -> Node<'f> {\n-        assert!(!self.nodes.is_empty());\n-        Node {\n-            file: self,\n-            idx: NodeIdx(0),\n-        }\n-    }\n-}\n-\n-/// A reference to a token in a Rust source file.\n-#[derive(Clone, Copy)]\n-pub struct Node<'f> {\n-    file: &'f File,\n-    idx: NodeIdx,\n-}\n-\n-impl<'f> Node<'f> {\n-    /// The kind of the token at this node.\n-    pub fn kind(&self) -> SyntaxKind {\n-        self.data().kind\n-    }\n-\n-    /// The text range covered by the token at this node.\n-    pub fn range(&self) -> TextRange {\n-        self.data().range\n-    }\n-\n-    /// The text at this node.\n-    pub fn text(&self) -> &'f str {\n-        &self.file.text.as_str()[self.range()]\n-    }\n-\n-    /// The parent node to this node.\n-    pub fn parent(&self) -> Option<Node<'f>> {\n-        self.as_node(self.data().parent)\n-    }\n-\n-    /// The children nodes of this node.\n-    pub fn children(&self) -> Children<'f> {\n-        Children {\n-            next: self.as_node(self.data().first_child),\n-        }\n-    }\n-\n-    /// Any errors contained in this node.\n-    pub fn errors(&self) -> SyntaxErrors<'f> {\n-        let pos = self.file.errors.iter().position(|e| e.node == self.idx);\n-        let next = pos.map(|i| ErrorIdx(i as u32)).map(|idx| SyntaxError {\n-            file: self.file,\n-            idx,\n-        });\n-        SyntaxErrors { next }\n-    }\n-\n-    fn data(&self) -> &'f NodeData {\n-        &self.file.nodes[self.idx]\n-    }\n-\n-    fn as_node(&self, idx: Option<NodeIdx>) -> Option<Node<'f>> {\n-        idx.map(|idx| Node {\n-            file: self.file,\n-            idx,\n-        })\n-    }\n-}\n-\n-impl<'f> fmt::Debug for Node<'f> {\n-    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n-        write!(fmt, \"{:?}@{:?}\", self.kind(), self.range())?;\n-        if has_short_text(self.kind()) {\n-            write!(fmt, \" \\\"{}\\\"\", self.text())?;\n-        }\n-        Ok(())\n-    }\n-}\n-\n-fn has_short_text(kind: SyntaxKind) -> bool {\n-    use syntax_kinds::*;\n-    match kind {\n-        IDENT | LIFETIME => true,\n-        _ => false,\n-    }\n-}\n-\n-impl<'f> cmp::PartialEq<Node<'f>> for Node<'f> {\n-    fn eq(&self, other: &Node<'f>) -> bool {\n-        self.idx == other.idx && ::std::ptr::eq(self.file, other.file)\n-    }\n-}\n-\n-impl<'f> cmp::Eq for Node<'f> {}\n-\n-#[derive(Clone, Copy, Debug)]\n-pub struct SyntaxError<'f> {\n-    file: &'f File,\n-    idx: ErrorIdx,\n-}\n-\n-impl<'f> SyntaxError<'f> {\n-    pub fn message(&self) -> &'f str {\n-        self.data().message.as_str()\n-    }\n-\n-    pub fn after_child(&self) -> Option<Node<'f>> {\n-        let idx = self.data().after_child?;\n-        Some(Node {\n-            file: self.file,\n-            idx,\n-        })\n-    }\n-\n-    fn data(&self) -> &'f SyntaxErrorData {\n-        &self.file.errors[self.idx]\n-    }\n-\n-    fn next(&self) -> Option<SyntaxError<'f>> {\n-        let next_idx = self.idx.0 + 1;\n-        if !((next_idx as usize) < self.file.errors.len()) {\n-            return None;\n-        }\n-        let result = SyntaxError {\n-            file: self.file,\n-            idx: ErrorIdx(next_idx),\n-        };\n-        if result.data().node != self.data().node {\n-            return None;\n-        }\n-        Some(result)\n-    }\n-}\n-\n-#[derive(Debug)]\n-pub struct Children<'f> {\n-    next: Option<Node<'f>>,\n-}\n-\n-impl<'f> Iterator for Children<'f> {\n-    type Item = Node<'f>;\n-\n-    fn next(&mut self) -> Option<Node<'f>> {\n-        let next = self.next;\n-        self.next = next.and_then(|node| node.as_node(node.data().next_sibling));\n-        next\n-    }\n-}\n-\n-#[derive(Debug)]\n-pub struct SyntaxErrors<'f> {\n-    next: Option<SyntaxError<'f>>,\n-}\n-\n-impl<'f> Iterator for SyntaxErrors<'f> {\n-    type Item = SyntaxError<'f>;\n-\n-    fn next(&mut self) -> Option<SyntaxError<'f>> {\n-        let next = self.next;\n-        self.next = next.as_ref().and_then(SyntaxError::next);\n-        next\n-    }\n-}\n-\n-#[derive(Clone, Copy, Debug, PartialEq, Eq)]\n-struct NodeIdx(u32);\n-\n-#[derive(Debug)]\n-struct NodeData {\n-    kind: SyntaxKind,\n-    range: TextRange,\n-    parent: Option<NodeIdx>,\n-    first_child: Option<NodeIdx>,\n-    next_sibling: Option<NodeIdx>,\n-}\n-\n-impl ::std::ops::Index<NodeIdx> for Vec<NodeData> {\n-    type Output = NodeData;\n-\n-    fn index(&self, NodeIdx(idx): NodeIdx) -> &NodeData {\n-        &self[idx as usize]\n-    }\n-}\n-\n-impl ::std::ops::IndexMut<NodeIdx> for Vec<NodeData> {\n-    fn index_mut(&mut self, NodeIdx(idx): NodeIdx) -> &mut NodeData {\n-        &mut self[idx as usize]\n-    }\n-}\n-\n-#[derive(Clone, Copy, Debug)]\n-struct ErrorIdx(u32);\n-\n-#[derive(Debug)]\n-struct SyntaxErrorData {\n-    node: NodeIdx,\n-    message: String,\n-    after_child: Option<NodeIdx>,\n-}\n-\n-impl ::std::ops::Index<ErrorIdx> for Vec<SyntaxErrorData> {\n-    type Output = SyntaxErrorData;\n-\n-    fn index(&self, ErrorIdx(idx): ErrorIdx) -> &SyntaxErrorData {\n-        &self[idx as usize]\n-    }\n-}"}, {"sha": "dafe1bb220760a8823969800fd917fa6a21f6684", "filename": "src/yellow/green.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ad188d4c3db34f035408afbdd6d2f3c308121f0a/src%2Fyellow%2Fgreen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad188d4c3db34f035408afbdd6d2f3c308121f0a/src%2Fyellow%2Fgreen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fyellow%2Fgreen.rs?ref=ad188d4c3db34f035408afbdd6d2f3c308121f0a", "patch": "@@ -116,13 +116,6 @@ impl GreenNode {\n             GreenNodeData::Branch(_) => false\n         }\n     }\n-\n-    pub(crate) fn leaf_text(&self) -> &str {\n-        match &self.data {\n-            GreenNodeData::Leaf(l) => l.text.as_str(),\n-            GreenNodeData::Branch(_) => panic!(\"not a leaf\")\n-        }\n-    }\n }\n \n #[derive(Debug)]"}, {"sha": "88d88e2261ebab2251975e332aa6e9ae4e10aed6", "filename": "src/yellow/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ad188d4c3db34f035408afbdd6d2f3c308121f0a/src%2Fyellow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad188d4c3db34f035408afbdd6d2f3c308121f0a/src%2Fyellow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fyellow%2Fmod.rs?ref=ad188d4c3db34f035408afbdd6d2f3c308121f0a", "patch": "@@ -4,7 +4,6 @@ mod syntax;\n \n use std::{\n     sync::{Arc, Weak},\n-    ops::Deref,\n     mem\n };\n pub(crate) use self::{"}, {"sha": "71212a08115c62d46b9a26de0201ab55840595b9", "filename": "src/yellow/red.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ad188d4c3db34f035408afbdd6d2f3c308121f0a/src%2Fyellow%2Fred.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad188d4c3db34f035408afbdd6d2f3c308121f0a/src%2Fyellow%2Fred.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fyellow%2Fred.rs?ref=ad188d4c3db34f035408afbdd6d2f3c308121f0a", "patch": "@@ -1,6 +1,6 @@\n-use std::sync::{Arc, Weak, RwLock};\n+use std::sync::{Arc, RwLock};\n use {\n-    TextUnit, SyntaxKind, TextRange,\n+    TextUnit,\n     yellow::{Ptr, GreenNode, TextLen}\n };\n "}, {"sha": "7b1a05cd9339414b6e46506518f26431c3cd171a", "filename": "src/yellow/syntax.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ad188d4c3db34f035408afbdd6d2f3c308121f0a/src%2Fyellow%2Fsyntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad188d4c3db34f035408afbdd6d2f3c308121f0a/src%2Fyellow%2Fsyntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fyellow%2Fsyntax.rs?ref=ad188d4c3db34f035408afbdd6d2f3c308121f0a", "patch": "@@ -7,7 +7,6 @@ use {\n     TextRange, TextUnit, SyntaxKind,\n     yellow::{Ptr, RedNode, GreenNode, TextLen},\n };\n-use yellow::green::GreenTrivia;\n \n #[derive(Clone)]\n pub struct SyntaxNode {"}, {"sha": "1b86fe55a2a6e9f666ea0432f7df245a1fa786e3", "filename": "tests/parser.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ad188d4c3db34f035408afbdd6d2f3c308121f0a/tests%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad188d4c3db34f035408afbdd6d2f3c308121f0a/tests%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fparser.rs?ref=ad188d4c3db34f035408afbdd6d2f3c308121f0a", "patch": "@@ -1,8 +1,8 @@\n extern crate libsyntax2;\n extern crate testutils;\n \n-use libsyntax2::{parse, tokenize, parse_green};\n-use libsyntax2::utils::{dump_tree, dump_tree_green};\n+use libsyntax2::{tokenize, parse_green};\n+use libsyntax2::utils::{dump_tree_green};\n use testutils::dir_tests;\n \n #[test]"}, {"sha": "5e4dc261fcd544b51702f912ba75873e1663a951", "filename": "tools/src/bin/parse.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ad188d4c3db34f035408afbdd6d2f3c308121f0a/tools%2Fsrc%2Fbin%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad188d4c3db34f035408afbdd6d2f3c308121f0a/tools%2Fsrc%2Fbin%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tools%2Fsrc%2Fbin%2Fparse.rs?ref=ad188d4c3db34f035408afbdd6d2f3c308121f0a", "patch": "@@ -2,14 +2,14 @@ extern crate libsyntax2;\n \n use std::io::Read;\n \n-use libsyntax2::{parse, tokenize};\n-use libsyntax2::utils::dump_tree;\n+use libsyntax2::{parse_green, tokenize};\n+use libsyntax2::utils::dump_tree_green;\n \n fn main() {\n     let text = read_input();\n     let tokens = tokenize(&text);\n-    let file = parse(text, &tokens);\n-    let tree = dump_tree(&file);\n+    let file = parse_green(text, &tokens);\n+    let tree = dump_tree_green(&file);\n     println!(\"{}\", tree);\n }\n "}]}