{"sha": "7dd4d19d49fb0697d13473ee354e6813a26b404e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdkZDRkMTlkNDlmYjA2OTdkMTM0NzNlZTM1NGU2ODEzYTI2YjQwNGU=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2016-11-12T08:38:40Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-11-12T08:38:40Z"}, "message": "Rollup merge of #37659 - nikomatsakis:sfackler-36340-fix, r=eddyb\n\nintroduce a `fudge_regions_if_ok` to address false region edges\n\nFixes #37655.\n\nr? @eddyb\ncc @sfackler", "tree": {"sha": "909d09f45a82bafb95e0d98dff0d046e27f94be7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/909d09f45a82bafb95e0d98dff0d046e27f94be7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7dd4d19d49fb0697d13473ee354e6813a26b404e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7dd4d19d49fb0697d13473ee354e6813a26b404e", "html_url": "https://github.com/rust-lang/rust/commit/7dd4d19d49fb0697d13473ee354e6813a26b404e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7dd4d19d49fb0697d13473ee354e6813a26b404e/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8d2da2bc7e78600d65357d2fb68c2de24c11ba73", "url": "https://api.github.com/repos/rust-lang/rust/commits/8d2da2bc7e78600d65357d2fb68c2de24c11ba73", "html_url": "https://github.com/rust-lang/rust/commit/8d2da2bc7e78600d65357d2fb68c2de24c11ba73"}, {"sha": "c4285359a4b94541a887dcbef659a4fdea4da91a", "url": "https://api.github.com/repos/rust-lang/rust/commits/c4285359a4b94541a887dcbef659a4fdea4da91a", "html_url": "https://github.com/rust-lang/rust/commit/c4285359a4b94541a887dcbef659a4fdea4da91a"}], "stats": {"total": 238, "additions": 192, "deletions": 46}, "files": [{"sha": "806b94486615fcd7d313796effbeeeab0ce3663f", "filename": "src/librustc/infer/fudge.rs", "status": "added", "additions": 137, "deletions": 0, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/7dd4d19d49fb0697d13473ee354e6813a26b404e/src%2Flibrustc%2Finfer%2Ffudge.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7dd4d19d49fb0697d13473ee354e6813a26b404e/src%2Flibrustc%2Finfer%2Ffudge.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ffudge.rs?ref=7dd4d19d49fb0697d13473ee354e6813a26b404e", "patch": "@@ -0,0 +1,137 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use ty::{self, TyCtxt};\n+use ty::fold::{TypeFoldable, TypeFolder};\n+\n+use super::InferCtxt;\n+use super::RegionVariableOrigin;\n+\n+impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n+    /// This rather funky routine is used while processing expected\n+    /// types. What happens here is that we want to propagate a\n+    /// coercion through the return type of a fn to its\n+    /// argument. Consider the type of `Option::Some`, which is\n+    /// basically `for<T> fn(T) -> Option<T>`. So if we have an\n+    /// expression `Some(&[1, 2, 3])`, and that has the expected type\n+    /// `Option<&[u32]>`, we would like to type check `&[1, 2, 3]`\n+    /// with the expectation of `&[u32]`. This will cause us to coerce\n+    /// from `&[u32; 3]` to `&[u32]` and make the users life more\n+    /// pleasant.\n+    ///\n+    /// The way we do this is using `fudge_regions_if_ok`. What the\n+    /// routine actually does is to start a snapshot and execute the\n+    /// closure `f`. In our example above, what this closure will do\n+    /// is to unify the expectation (`Option<&[u32]>`) with the actual\n+    /// return type (`Option<?T>`, where `?T` represents the variable\n+    /// instantiated for `T`).  This will cause `?T` to be unified\n+    /// with `&?a [u32]`, where `?a` is a fresh lifetime variable. The\n+    /// input type (`?T`) is then returned by `f()`.\n+    ///\n+    /// At this point, `fudge_regions_if_ok` will normalize all type\n+    /// variables, converting `?T` to `&?a [u32]` and end the\n+    /// snapshot.  The problem is that we can't just return this type\n+    /// out, because it references the region variable `?a`, and that\n+    /// region variable was popped when we popped the snapshot.\n+    ///\n+    /// So what we do is to keep a list (`region_vars`, in the code below)\n+    /// of region variables created during the snapshot (here, `?a`). We\n+    /// fold the return value and replace any such regions with a *new*\n+    /// region variable (e.g., `?b`) and return the result (`&?b [u32]`).\n+    /// This can then be used as the expectation for the fn argument.\n+    ///\n+    /// The important point here is that, for soundness purposes, the\n+    /// regions in question are not particularly important. We will\n+    /// use the expected types to guide coercions, but we will still\n+    /// type-check the resulting types from those coercions against\n+    /// the actual types (`?T`, `Option<?T`) -- and remember that\n+    /// after the snapshot is popped, the variable `?T` is no longer\n+    /// unified.\n+    ///\n+    /// Assumptions:\n+    /// - no new type variables are created during `f()` (asserted\n+    ///   below); this simplifies our logic since we don't have to\n+    ///   check for escaping type variables\n+    pub fn fudge_regions_if_ok<T, E, F>(&self,\n+                                        origin: &RegionVariableOrigin,\n+                                        f: F) -> Result<T, E> where\n+        F: FnOnce() -> Result<T, E>,\n+        T: TypeFoldable<'tcx>,\n+    {\n+        let (region_vars, value) = self.probe(|snapshot| {\n+            let vars_at_start = self.type_variables.borrow().num_vars();\n+\n+            match f() {\n+                Ok(value) => {\n+                    let value = self.resolve_type_vars_if_possible(&value);\n+\n+                    // At this point, `value` could in principle refer\n+                    // to regions that have been created during the\n+                    // snapshot (we assert below that `f()` does not\n+                    // create any new type variables, so there\n+                    // shouldn't be any of those). Once we exit\n+                    // `probe()`, those are going to be popped, so we\n+                    // will have to eliminate any references to them.\n+\n+                    assert_eq!(self.type_variables.borrow().num_vars(), vars_at_start,\n+                               \"type variables were created during fudge_regions_if_ok\");\n+                    let region_vars =\n+                        self.region_vars.vars_created_since_snapshot(\n+                            &snapshot.region_vars_snapshot);\n+\n+                    Ok((region_vars, value))\n+                }\n+                Err(e) => Err(e),\n+            }\n+        })?;\n+\n+        // At this point, we need to replace any of the now-popped\n+        // region variables that appear in `value` with a fresh region\n+        // variable. We can't do this during the probe because they\n+        // would just get popped then too. =)\n+\n+        // Micro-optimization: if no variables have been created, then\n+        // `value` can't refer to any of them. =) So we can just return it.\n+        if region_vars.is_empty() {\n+            return Ok(value);\n+        }\n+\n+        let mut fudger = RegionFudger {\n+            infcx: self,\n+            region_vars: &region_vars,\n+            origin: origin\n+        };\n+\n+        Ok(value.fold_with(&mut fudger))\n+    }\n+}\n+\n+pub struct RegionFudger<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n+    infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n+    region_vars: &'a Vec<ty::RegionVid>,\n+    origin: &'a RegionVariableOrigin,\n+}\n+\n+impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for RegionFudger<'a, 'gcx, 'tcx> {\n+    fn tcx<'b>(&'b self) -> TyCtxt<'b, 'gcx, 'tcx> {\n+        self.infcx.tcx\n+    }\n+\n+    fn fold_region(&mut self, r: &'tcx ty::Region) -> &'tcx ty::Region {\n+        match *r {\n+            ty::ReVar(v) if self.region_vars.contains(&v) => {\n+                self.infcx.next_region_var(self.origin.clone())\n+            }\n+            _ => {\n+                r\n+            }\n+        }\n+    }\n+}"}, {"sha": "46074f6c1f3c820016641c1ecd89a157855a9859", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 1, "deletions": 43, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/7dd4d19d49fb0697d13473ee354e6813a26b404e/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7dd4d19d49fb0697d13473ee354e6813a26b404e/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=7dd4d19d49fb0697d13473ee354e6813a26b404e", "patch": "@@ -50,6 +50,7 @@ mod bivariate;\n mod combine;\n mod equate;\n pub mod error_reporting;\n+mod fudge;\n mod glb;\n mod higher_ranked;\n pub mod lattice;\n@@ -985,49 +986,6 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         r\n     }\n \n-    /// Execute `f` and commit only the region bindings if successful.\n-    /// The function f must be very careful not to leak any non-region\n-    /// variables that get created.\n-    pub fn commit_regions_if_ok<T, E, F>(&self, f: F) -> Result<T, E> where\n-        F: FnOnce() -> Result<T, E>\n-    {\n-        debug!(\"commit_regions_if_ok()\");\n-        let CombinedSnapshot { projection_cache_snapshot,\n-                               type_snapshot,\n-                               int_snapshot,\n-                               float_snapshot,\n-                               region_vars_snapshot,\n-                               obligations_in_snapshot } = self.start_snapshot();\n-\n-        let r = self.commit_if_ok(|_| f());\n-\n-        debug!(\"commit_regions_if_ok: rolling back everything but regions\");\n-\n-        assert!(!self.obligations_in_snapshot.get());\n-        self.obligations_in_snapshot.set(obligations_in_snapshot);\n-\n-        // Roll back any non-region bindings - they should be resolved\n-        // inside `f`, with, e.g. `resolve_type_vars_if_possible`.\n-        self.projection_cache\n-            .borrow_mut()\n-            .rollback_to(projection_cache_snapshot);\n-        self.type_variables\n-            .borrow_mut()\n-            .rollback_to(type_snapshot);\n-        self.int_unification_table\n-            .borrow_mut()\n-            .rollback_to(int_snapshot);\n-        self.float_unification_table\n-            .borrow_mut()\n-            .rollback_to(float_snapshot);\n-\n-        // Commit region vars that may escape through resolved types.\n-        self.region_vars\n-            .commit(region_vars_snapshot);\n-\n-        r\n-    }\n-\n     /// Execute `f` then unroll any bindings it creates\n     pub fn probe<R, F>(&self, f: F) -> R where\n         F: FnOnce(&CombinedSnapshot) -> R,"}, {"sha": "804765ec8811e52171ce8e6e3207c9d291f44269", "filename": "src/librustc/infer/type_variable.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7dd4d19d49fb0697d13473ee354e6813a26b404e/src%2Flibrustc%2Finfer%2Ftype_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7dd4d19d49fb0697d13473ee354e6813a26b404e/src%2Flibrustc%2Finfer%2Ftype_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ftype_variable.rs?ref=7dd4d19d49fb0697d13473ee354e6813a26b404e", "patch": "@@ -184,6 +184,10 @@ impl<'tcx> TypeVariableTable<'tcx> {\n         v\n     }\n \n+    pub fn num_vars(&self) -> usize {\n+        self.values.len()\n+    }\n+\n     pub fn root_var(&mut self, vid: ty::TyVid) -> ty::TyVid {\n         self.eq_relations.find(vid)\n     }"}, {"sha": "ccc5288cc495ea17882036c044c5bc9e2116ee2f", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7dd4d19d49fb0697d13473ee354e6813a26b404e/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7dd4d19d49fb0697d13473ee354e6813a26b404e/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=7dd4d19d49fb0697d13473ee354e6813a26b404e", "patch": "@@ -86,7 +86,8 @@ use fmt_macros::{Parser, Piece, Position};\n use hir::def::{Def, CtorKind, PathResolution};\n use hir::def_id::{DefId, LOCAL_CRATE};\n use hir::pat_util;\n-use rustc::infer::{self, InferCtxt, InferOk, TypeOrigin, TypeTrace, type_variable};\n+use rustc::infer::{self, InferCtxt, InferOk, RegionVariableOrigin,\n+                   TypeOrigin, TypeTrace, type_variable};\n use rustc::ty::subst::{Kind, Subst, Substs};\n use rustc::traits::{self, Reveal};\n use rustc::ty::{ParamTy, ParameterEnvironment};\n@@ -2760,7 +2761,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                   formal_args: &[Ty<'tcx>])\n                                   -> Vec<Ty<'tcx>> {\n         let expected_args = expected_ret.only_has_type(self).and_then(|ret_ty| {\n-            self.commit_regions_if_ok(|| {\n+            self.fudge_regions_if_ok(&RegionVariableOrigin::Coercion(call_span), || {\n                 // Attempt to apply a subtyping relationship between the formal\n                 // return type (likely containing type variables if the function\n                 // is polymorphic) and the expected return type."}, {"sha": "1e0cdaa8cc435759ed5ae9159aea4917d7ed745f", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7dd4d19d49fb0697d13473ee354e6813a26b404e/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7dd4d19d49fb0697d13473ee354e6813a26b404e/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=7dd4d19d49fb0697d13473ee354e6813a26b404e", "patch": "@@ -1149,7 +1149,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n                     autoderefs: usize,\n                     autoref: &adjustment::AutoBorrow<'tcx>)\n     {\n-        debug!(\"link_autoref(autoref={:?})\", autoref);\n+        debug!(\"link_autoref(autoderefs={}, autoref={:?})\", autoderefs, autoref);\n         let mc = mc::MemCategorizationContext::new(self);\n         let expr_cmt = ignore_err!(mc.cat_expr_autoderefd(expr, autoderefs));\n         debug!(\"expr_cmt={:?}\", expr_cmt);"}, {"sha": "d229bcacc501ab3631741a21ed3dae65b27a0fc7", "filename": "src/test/run-pass/issue-37655.rs", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/7dd4d19d49fb0697d13473ee354e6813a26b404e/src%2Ftest%2Frun-pass%2Fissue-37655.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7dd4d19d49fb0697d13473ee354e6813a26b404e/src%2Ftest%2Frun-pass%2Fissue-37655.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-37655.rs?ref=7dd4d19d49fb0697d13473ee354e6813a26b404e", "patch": "@@ -0,0 +1,46 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Regression test for #37655. The problem was a false edge created by\n+// coercion that wound up requiring that `'a` (in `split()`) outlive\n+// `'b`, which shouldn't be necessary.\n+\n+#![allow(warnings)]\n+\n+trait SliceExt<T> {\n+    type Item;\n+\n+    fn get_me<I>(&self, index: I) -> &I::Output\n+        where I: SliceIndex<Self::Item>;\n+}\n+\n+impl<T> SliceExt<T> for [T] {\n+    type Item = T;\n+\n+    fn get_me<I>(&self, index: I) -> &I::Output\n+        where I: SliceIndex<T>\n+    {\n+        panic!()\n+    }\n+}\n+\n+pub trait SliceIndex<T> {\n+    type Output: ?Sized;\n+}\n+\n+impl<T> SliceIndex<T> for usize {\n+    type Output = T;\n+}\n+\n+fn foo<'a, 'b>(split: &'b [&'a [u8]]) -> &'a [u8] {\n+    split.get_me(0)\n+}\n+\n+fn main() { }"}]}