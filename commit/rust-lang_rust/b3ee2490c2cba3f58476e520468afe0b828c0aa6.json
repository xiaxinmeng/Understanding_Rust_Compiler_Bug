{"sha": "b3ee2490c2cba3f58476e520468afe0b828c0aa6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIzZWUyNDkwYzJjYmEzZjU4NDc2ZTUyMDQ2OGFmZTBiODI4YzBhYTY=", "commit": {"author": {"name": "Raph Levien", "email": "raph@google.com", "date": "2017-02-22T17:30:46Z"}, "committer": {"name": "Raph Levien", "email": "raph@google.com", "date": "2017-02-22T17:30:46Z"}, "message": "Merge branch 'master' of https://github.com/rust-lang/rust into readdir", "tree": {"sha": "7f17f972f658ed00a7c310fd1448e9ab96eb07d9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7f17f972f658ed00a7c310fd1448e9ab96eb07d9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b3ee2490c2cba3f58476e520468afe0b828c0aa6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b3ee2490c2cba3f58476e520468afe0b828c0aa6", "html_url": "https://github.com/rust-lang/rust/commit/b3ee2490c2cba3f58476e520468afe0b828c0aa6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b3ee2490c2cba3f58476e520468afe0b828c0aa6/comments", "author": {"login": "raphlinus", "id": 242367, "node_id": "MDQ6VXNlcjI0MjM2Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/242367?v=4", "gravatar_id": "", "url": "https://api.github.com/users/raphlinus", "html_url": "https://github.com/raphlinus", "followers_url": "https://api.github.com/users/raphlinus/followers", "following_url": "https://api.github.com/users/raphlinus/following{/other_user}", "gists_url": "https://api.github.com/users/raphlinus/gists{/gist_id}", "starred_url": "https://api.github.com/users/raphlinus/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/raphlinus/subscriptions", "organizations_url": "https://api.github.com/users/raphlinus/orgs", "repos_url": "https://api.github.com/users/raphlinus/repos", "events_url": "https://api.github.com/users/raphlinus/events{/privacy}", "received_events_url": "https://api.github.com/users/raphlinus/received_events", "type": "User", "site_admin": false}, "committer": {"login": "raphlinus", "id": 242367, "node_id": "MDQ6VXNlcjI0MjM2Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/242367?v=4", "gravatar_id": "", "url": "https://api.github.com/users/raphlinus", "html_url": "https://github.com/raphlinus", "followers_url": "https://api.github.com/users/raphlinus/followers", "following_url": "https://api.github.com/users/raphlinus/following{/other_user}", "gists_url": "https://api.github.com/users/raphlinus/gists{/gist_id}", "starred_url": "https://api.github.com/users/raphlinus/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/raphlinus/subscriptions", "organizations_url": "https://api.github.com/users/raphlinus/orgs", "repos_url": "https://api.github.com/users/raphlinus/repos", "events_url": "https://api.github.com/users/raphlinus/events{/privacy}", "received_events_url": "https://api.github.com/users/raphlinus/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "81b9b3c542e0f3c3df799a9d66bb0120c7dbc44c", "url": "https://api.github.com/repos/rust-lang/rust/commits/81b9b3c542e0f3c3df799a9d66bb0120c7dbc44c", "html_url": "https://github.com/rust-lang/rust/commit/81b9b3c542e0f3c3df799a9d66bb0120c7dbc44c"}, {"sha": "fc6f092c21a7a7249a9f8860f3cd10160aa36c02", "url": "https://api.github.com/repos/rust-lang/rust/commits/fc6f092c21a7a7249a9f8860f3cd10160aa36c02", "html_url": "https://github.com/rust-lang/rust/commit/fc6f092c21a7a7249a9f8860f3cd10160aa36c02"}], "stats": {"total": 12407, "additions": 7058, "deletions": 5349}, "files": [{"sha": "e9d8c84f4071505ccb75071d3dcfdf9f5962b543", "filename": "CONTRIBUTING.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/CONTRIBUTING.md", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/CONTRIBUTING.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CONTRIBUTING.md?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -199,7 +199,7 @@ Some common invocations of `x.py` are:\n   This is the fastest way to recompile after you changed only rustc source code.\n   Note however that the resulting rustc binary won't have a stdlib to link\n   against by default. You can build libstd once with `x.py build src/libstd`,\n-  but it is is only guaranteed to work if recompiled, so if there are any issues\n+  but it is only guaranteed to work if recompiled, so if there are any issues\n   recompile it.\n - `x.py test` - build the full compiler & run all tests (takes a while). This\n   is what gets run by the continuous integration system against your pull"}, {"sha": "44791b033a641a789a1efc98f24abd78b40551ef", "filename": "appveyor.yml", "status": "modified", "additions": 38, "deletions": 13, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/appveyor.yml", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/appveyor.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/appveyor.yml?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -5,17 +5,15 @@ environment:\n     secure: 1UkmbiDd15tWtYbMm5O2Uqm0b0Ur8v1MoSlydxl4ojcroPeerRMlUges0l57py8c\n   SCCACHE_DIGEST: f808afabb4a4eb1d7112bcb3fa6be03b61e93412890c88e177c667eb37f46353d7ec294e559b16f9f4b5e894f2185fe7670a0df15fd064889ecbd80f0c34166c\n   matrix:\n-  # 32/64 bit MSVC\n+  # 32/64 bit MSVC tests\n   - MSYS_BITS: 64\n-    RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-msvc --enable-extended\n-    SCRIPT: python x.py test && python x.py dist\n-    DEPLOY: 1\n+    RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-msvc\n+    SCRIPT: python x.py test\n   - MSYS_BITS: 32\n-    RUST_CONFIGURE_ARGS: --build=i686-pc-windows-msvc --target=i586-pc-windows-msvc --enable-extended\n-    SCRIPT: python x.py test --host i686-pc-windows-msvc --target i686-pc-windows-msvc && python x.py dist\n-    DEPLOY: 1\n+    RUST_CONFIGURE_ARGS: --build=i686-pc-windows-msvc --target=i586-pc-windows-msvc\n+    SCRIPT: python x.py test --host i686-pc-windows-msvc --target i686-pc-windows-msvc\n \n-  # MSVC cargotest\n+  # MSVC aux tests\n   - MSYS_BITS: 64\n     RUST_CHECK_TARGET: check-aux\n     RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-msvc\n@@ -44,16 +42,40 @@ environment:\n   # And as a final point of note, the 32-bit MinGW build using the makefiles do\n   # *not* use debug assertions and llvm assertions. This is because they take\n   # too long on appveyor and this is tested by rustbuild below.\n+  - MSYS_BITS: 32\n+    RUST_CONFIGURE_ARGS: --build=i686-pc-windows-gnu\n+    SCRIPT: python x.py test\n+    MINGW_URL: https://s3.amazonaws.com/rust-lang-ci\n+    MINGW_ARCHIVE: i686-4.9.2-release-win32-dwarf-rt_v4-rev4.7z\n+    MINGW_DIR: mingw32\n+  - MSYS_BITS: 64\n+    SCRIPT: python x.py test\n+    RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-gnu\n+    MINGW_URL: https://s3.amazonaws.com/rust-lang-ci\n+    MINGW_ARCHIVE: x86_64-4.9.2-release-win32-seh-rt_v4-rev4.7z\n+    MINGW_DIR: mingw64\n+\n+  # 32/64 bit MSVC and GNU deployment\n+  - RUST_CONFIGURE_ARGS: >\n+      --build=x86_64-pc-windows-msvc\n+      --enable-extended\n+    SCRIPT: python x.py dist\n+    DEPLOY: 1\n+  - RUST_CONFIGURE_ARGS: >\n+      --build=i686-pc-windows-msvc\n+      --target=i586-pc-windows-msvc\n+      --enable-extended\n+    SCRIPT: python x.py dist\n+    DEPLOY: 1\n   - MSYS_BITS: 32\n     RUST_CONFIGURE_ARGS: --build=i686-pc-windows-gnu --enable-extended\n-    SCRIPT: python x.py test && python x.py dist\n+    SCRIPT: python x.py dist\n     MINGW_URL: https://s3.amazonaws.com/rust-lang-ci\n     MINGW_ARCHIVE: i686-4.9.2-release-win32-dwarf-rt_v4-rev4.7z\n     MINGW_DIR: mingw32\n     DEPLOY: 1\n-\n   - MSYS_BITS: 64\n-    SCRIPT: python x.py test && python x.py dist\n+    SCRIPT: python x.py dist\n     RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-gnu --enable-extended\n     MINGW_URL: https://s3.amazonaws.com/rust-lang-ci\n     MINGW_ARCHIVE: x86_64-4.9.2-release-win32-seh-rt_v4-rev4.7z\n@@ -83,12 +105,15 @@ install:\n   # file exists in there (which it doesn't by default).\n   - if defined MINGW_URL appveyor DownloadFile %MINGW_URL%/%MINGW_ARCHIVE%\n   - if defined MINGW_URL 7z x -y %MINGW_ARCHIVE% > nul\n-  - if defined MINGW_URL set PATH=C:\\Python27;%CD%\\%MINGW_DIR%\\bin;C:\\msys64\\usr\\bin;%PATH%\n-  - if defined MINGW_URL copy C:\\Python27\\python.exe C:\\Python27\\python2.7.exe\n+  - if defined MINGW_URL set PATH=%CD%\\%MINGW_DIR%\\bin;C:\\msys64\\usr\\bin;%PATH%\n \n   # Otherwise pull in the MinGW installed on appveyor\n   - if NOT defined MINGW_URL set PATH=C:\\msys64\\mingw%MSYS_BITS%\\bin;C:\\msys64\\usr\\bin;%PATH%\n \n+  # Prefer the \"native\" Python as LLVM has trouble building with MSYS sometimes\n+  - copy C:\\Python27\\python.exe C:\\Python27\\python2.7.exe\n+  - set PATH=C:\\Python27;%PATH%\n+\n   # Download and install sccache\n   - appveyor DownloadFile https://api.pub.build.mozilla.org/tooltool/sha512/%SCCACHE_DIGEST%\n   - mv %SCCACHE_DIGEST% sccache.tar.bz2"}, {"sha": "f17095f96092088a7235f151c3048a3a5a4ce018", "filename": "src/Cargo.lock", "status": "modified", "additions": 151, "deletions": 70, "changes": 221, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.lock?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -8,10 +8,10 @@ dependencies = [\n \n [[package]]\n name = \"aho-corasick\"\n-version = \"0.5.3\"\n+version = \"0.6.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"memchr 0.1.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"memchr 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -63,21 +63,21 @@ name = \"bootstrap\"\n version = \"0.0.0\"\n dependencies = [\n  \"build_helper 0.1.0\",\n- \"cmake 0.1.18 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"cmake 0.1.20 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"filetime 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"gcc 0.3.43 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"getopts 0.2.14 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.17 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.20 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"num_cpus 0.2.13 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-serialize 0.3.19 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-serialize 0.3.22 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"toml 0.1.30 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"build-manifest\"\n version = \"0.1.0\"\n dependencies = [\n- \"rustc-serialize 0.3.19 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-serialize 0.3.22 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"toml 0.1.30 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -94,22 +94,22 @@ version = \"0.1.0\"\n \n [[package]]\n name = \"clap\"\n-version = \"2.19.3\"\n+version = \"2.20.5\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"ansi_term 0.9.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"bitflags 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.17 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"strsim 0.5.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"term_size 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"unicode-segmentation 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.20 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"strsim 0.6.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"term_size 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"unicode-segmentation 1.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"unicode-width 0.1.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"vec_map 0.6.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"cmake\"\n-version = \"0.1.18\"\n+version = \"0.1.20\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"gcc 0.3.43 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -139,20 +139,33 @@ dependencies = [\n  \"env_logger 0.3.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"filetime 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.3.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-serialize 0.3.19 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-serialize 0.3.22 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"core\"\n version = \"0.0.0\"\n \n+[[package]]\n+name = \"dtoa\"\n+version = \"0.4.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n [[package]]\n name = \"env_logger\"\n version = \"0.3.5\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"log 0.3.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"regex 0.1.80 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"env_logger\"\n+version = \"0.4.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"log 0.3.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"regex 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -164,7 +177,7 @@ name = \"filetime\"\n version = \"0.1.10\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"libc 0.2.17 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.20 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -199,17 +212,23 @@ version = \"0.0.0\"\n \n [[package]]\n name = \"handlebars\"\n-version = \"0.20.5\"\n+version = \"0.25.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"lazy_static 0.1.16 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"lazy_static 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.3.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"pest 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"quick-error 1.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"regex 0.1.80 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-serialize 0.3.19 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"regex 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-serialize 0.3.22 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde_json 0.9.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n+[[package]]\n+name = \"itoa\"\n+version = \"0.3.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n [[package]]\n name = \"kernel32-sys\"\n version = \"0.2.2\"\n@@ -221,7 +240,7 @@ dependencies = [\n \n [[package]]\n name = \"lazy_static\"\n-version = \"0.1.16\"\n+version = \"0.2.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n@@ -233,7 +252,7 @@ dependencies = [\n \n [[package]]\n name = \"libc\"\n-version = \"0.2.17\"\n+version = \"0.2.20\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n@@ -251,33 +270,47 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n name = \"mdbook\"\n-version = \"0.0.14\"\n+version = \"0.0.16\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"clap 2.19.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"env_logger 0.3.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"handlebars 0.20.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"clap 2.20.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"env_logger 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"handlebars 0.25.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.3.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"open 1.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"pulldown-cmark 0.0.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-serialize 0.3.19 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"regex 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 0.9.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde_json 0.9.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"toml 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"memchr\"\n-version = \"0.1.11\"\n+version = \"1.0.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"libc 0.2.17 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.20 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n+[[package]]\n+name = \"num-traits\"\n+version = \"0.1.36\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n [[package]]\n name = \"num_cpus\"\n version = \"0.2.13\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"libc 0.2.17 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.20 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n+[[package]]\n+name = \"open\"\n+version = \"1.2.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n [[package]]\n name = \"panic_abort\"\n version = \"0.0.0\"\n@@ -348,27 +381,27 @@ dependencies = [\n \n [[package]]\n name = \"regex\"\n-version = \"0.1.80\"\n+version = \"0.2.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"aho-corasick 0.5.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"memchr 0.1.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"regex-syntax 0.3.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"thread_local 0.2.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"utf8-ranges 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"aho-corasick 0.6.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"memchr 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"regex-syntax 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"thread_local 0.3.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"utf8-ranges 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"regex-syntax\"\n-version = \"0.3.9\"\n+version = \"0.4.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n name = \"rustbook\"\n version = \"0.1.0\"\n dependencies = [\n- \"clap 2.19.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"mdbook 0.0.14 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"clap 2.20.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"mdbook 0.0.16 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -401,7 +434,7 @@ dependencies = [\n \n [[package]]\n name = \"rustc-serialize\"\n-version = \"0.3.19\"\n+version = \"0.3.22\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n@@ -410,7 +443,7 @@ version = \"0.0.0\"\n dependencies = [\n  \"alloc_system 0.0.0\",\n  \"build_helper 0.1.0\",\n- \"cmake 0.1.18 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"cmake 0.1.20 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"core 0.0.0\",\n ]\n \n@@ -553,7 +586,7 @@ version = \"0.0.0\"\n dependencies = [\n  \"alloc_system 0.0.0\",\n  \"build_helper 0.1.0\",\n- \"cmake 0.1.18 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"cmake 0.1.20 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"core 0.0.0\",\n ]\n \n@@ -597,7 +630,7 @@ version = \"0.0.0\"\n dependencies = [\n  \"alloc_system 0.0.0\",\n  \"build_helper 0.1.0\",\n- \"cmake 0.1.18 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"cmake 0.1.20 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"core 0.0.0\",\n ]\n \n@@ -689,7 +722,7 @@ version = \"0.0.0\"\n dependencies = [\n  \"alloc_system 0.0.0\",\n  \"build_helper 0.1.0\",\n- \"cmake 0.1.18 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"cmake 0.1.20 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"core 0.0.0\",\n ]\n \n@@ -734,6 +767,22 @@ dependencies = [\n  \"syntax_pos 0.0.0\",\n ]\n \n+[[package]]\n+name = \"serde\"\n+version = \"0.9.7\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n+[[package]]\n+name = \"serde_json\"\n+version = \"0.9.6\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"dtoa 0.4.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"itoa 0.3.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"num-traits 0.1.36 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 0.9.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n [[package]]\n name = \"serialize\"\n version = \"0.0.0\"\n@@ -779,7 +828,7 @@ dependencies = [\n \n [[package]]\n name = \"strsim\"\n-version = \"0.5.2\"\n+version = \"0.6.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n@@ -819,11 +868,11 @@ version = \"0.0.0\"\n \n [[package]]\n name = \"term_size\"\n-version = \"0.2.1\"\n+version = \"0.2.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"kernel32-sys 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.17 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.20 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"winapi 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -844,19 +893,20 @@ dependencies = [\n \n [[package]]\n name = \"thread-id\"\n-version = \"2.0.0\"\n+version = \"3.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"kernel32-sys 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.17 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.20 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"thread_local\"\n-version = \"0.2.7\"\n+version = \"0.3.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"thread-id 2.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"thread-id 3.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"unreachable 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -868,29 +918,50 @@ name = \"toml\"\n version = \"0.1.30\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"rustc-serialize 0.3.19 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-serialize 0.3.22 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"toml\"\n+version = \"0.3.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"serde 0.9.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"unicode-segmentation\"\n-version = \"0.1.3\"\n+version = \"1.1.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n name = \"unicode-width\"\n version = \"0.1.4\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n+[[package]]\n+name = \"unreachable\"\n+version = \"0.1.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"void 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n [[package]]\n name = \"utf8-ranges\"\n-version = \"0.1.3\"\n+version = \"1.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n name = \"vec_map\"\n version = \"0.6.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n+[[package]]\n+name = \"void\"\n+version = \"1.0.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n [[package]]\n name = \"winapi\"\n version = \"0.2.8\"\n@@ -902,38 +973,48 @@ version = \"0.1.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [metadata]\n-\"checksum aho-corasick 0.5.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ca972c2ea5f742bfce5687b9aef75506a764f61d37f8f649047846a9686ddb66\"\n+\"checksum aho-corasick 0.6.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"0638fd549427caa90c499814196d1b9e3725eb4d15d7339d6de073a680ed0ca2\"\n \"checksum ansi_term 0.9.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"23ac7c30002a5accbf7e8987d0632fa6de155b7c3d39d0067317a391e00a2ef6\"\n \"checksum bitflags 0.5.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"4f67931368edf3a9a51d29886d245f1c3db2f1ef0dcc9e35ff70341b78c10d23\"\n \"checksum bitflags 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"aad18937a628ec6abcd26d1489012cc0e18c21798210f491af69ded9b881106d\"\n-\"checksum clap 2.19.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"95b78f3fe0fc94c13c731714363260e04b557a637166f33a4570d3189d642374\"\n-\"checksum cmake 0.1.18 (registry+https://github.com/rust-lang/crates.io-index)\" = \"0e5bcf27e097a184c1df4437654ed98df3d7a516e8508a6ba45d8b092bbdf283\"\n+\"checksum clap 2.20.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"7db281b0520e97fbd15cd615dcd8f8bcad0c26f5f7d5effe705f090f39e9a758\"\n+\"checksum cmake 0.1.20 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a3a6805df695087e7c1bcd9a82e03ad6fb864c8e67ac41b1348229ce5b7f0407\"\n+\"checksum dtoa 0.4.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"80c8b71fd71146990a9742fc06dcbbde19161a267e0ad4e572c35162f4578c90\"\n \"checksum env_logger 0.3.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"15abd780e45b3ea4f76b4e9a26ff4843258dd8a3eed2775a0e7368c2e7936c2f\"\n+\"checksum env_logger 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"99971fb1b635fe7a0ee3c4d065845bb93cca80a23b5613b5613391ece5de4144\"\n \"checksum filetime 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)\" = \"5363ab8e4139b8568a6237db5248646e5a8a2f89bd5ccb02092182b11fd3e922\"\n \"checksum gcc 0.3.43 (registry+https://github.com/rust-lang/crates.io-index)\" = \"c07c758b972368e703a562686adb39125707cc1ef3399da8c019fc6c2498a75d\"\n \"checksum getopts 0.2.14 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d9047cfbd08a437050b363d35ef160452c5fe8ea5187ae0a624708c91581d685\"\n-\"checksum handlebars 0.20.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"07f9c1d28bcfb97143c95ed0667141677b2b5675c7ba3d5b81459ad43b1073bd\"\n+\"checksum handlebars 0.25.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"b930077f1422bf853008047b55896efc1409744bfc9903f1eec1a58fcc7edeff\"\n+\"checksum itoa 0.3.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"eb2f404fbc66fd9aac13e998248505e7ecb2ad8e44ab6388684c5fb11c6c251c\"\n \"checksum kernel32-sys 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"7507624b29483431c0ba2d82aece8ca6cdba9382bff4ddd0f7490560c056098d\"\n-\"checksum lazy_static 0.1.16 (registry+https://github.com/rust-lang/crates.io-index)\" = \"cf186d1a8aa5f5bee5fd662bc9c1b949e0259e1bcc379d1f006847b0080c7417\"\n-\"checksum libc 0.2.17 (registry+https://github.com/rust-lang/crates.io-index)\" = \"044d1360593a78f5c8e5e710beccdc24ab71d1f01bc19a29bcacdba22e8475d8\"\n+\"checksum lazy_static 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"6abe0ee2e758cd6bc8a2cd56726359007748fbf4128da998b65d0b70f881e19b\"\n+\"checksum libc 0.2.20 (registry+https://github.com/rust-lang/crates.io-index)\" = \"684f330624d8c3784fb9558ca46c4ce488073a8d22450415c5eb4f4cfb0d11b5\"\n \"checksum log 0.3.6 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ab83497bf8bf4ed2a74259c1c802351fcd67a65baa86394b6ba73c36f4838054\"\n-\"checksum mdbook 0.0.14 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a629cd0194bbd0340a70db83a94b27cf9881fac8c55e6a2db983addcb7114ee4\"\n-\"checksum memchr 0.1.11 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d8b629fb514376c675b98c1421e80b151d3817ac42d7c667717d282761418d20\"\n+\"checksum mdbook 0.0.16 (registry+https://github.com/rust-lang/crates.io-index)\" = \"14e8a6aca534ac51bad1c1886b10f6d6948a14fa70b1b20a1e41c9e5c0fe3019\"\n+\"checksum memchr 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"1dbccc0e46f1ea47b9f17e6d67c5a96bd27030519c519c9c91327e31275a47b4\"\n+\"checksum num-traits 0.1.36 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a16a42856a256b39c6d3484f097f6713e14feacd9bfb02290917904fae46c81c\"\n \"checksum num_cpus 0.2.13 (registry+https://github.com/rust-lang/crates.io-index)\" = \"cee7e88156f3f9e19bdd598f8d6c9db7bf4078f99f8381f43a55b09648d1a6e3\"\n+\"checksum open 1.2.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3478ed1686bd1300c8a981a940abc92b06fac9cbef747f4c668d4e032ff7b842\"\n \"checksum pest 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"0a6dda33d67c26f0aac90d324ab2eb7239c819fc7b2552fe9faa4fe88441edc8\"\n \"checksum pulldown-cmark 0.0.8 (registry+https://github.com/rust-lang/crates.io-index)\" = \"1058d7bb927ca067656537eec4e02c2b4b70eaaa129664c5b90c111e20326f41\"\n \"checksum quick-error 1.1.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"0aad603e8d7fb67da22dbdf1f4b826ce8829e406124109e73cf1b2454b93a71c\"\n-\"checksum regex 0.1.80 (registry+https://github.com/rust-lang/crates.io-index)\" = \"4fd4ace6a8cf7860714a2c2280d6c1f7e6a413486c13298bbc86fd3da019402f\"\n-\"checksum regex-syntax 0.3.9 (registry+https://github.com/rust-lang/crates.io-index)\" = \"f9ec002c35e86791825ed294b50008eea9ddfc8def4420124fbc6b08db834957\"\n-\"checksum rustc-serialize 0.3.19 (registry+https://github.com/rust-lang/crates.io-index)\" = \"6159e4e6e559c81bd706afe9c8fd68f547d3e851ce12e76b1de7914bab61691b\"\n-\"checksum strsim 0.5.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"67f84c44fbb2f91db7fef94554e6b2ac05909c9c0b0bc23bb98d3a1aebfe7f7c\"\n-\"checksum term_size 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3f7f5f3f71b0040cecc71af239414c23fd3c73570f5ff54cf50e03cef637f2a0\"\n-\"checksum thread-id 2.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a9539db560102d1cef46b8b78ce737ff0bb64e7e18d35b2a5688f7d097d0ff03\"\n-\"checksum thread_local 0.2.7 (registry+https://github.com/rust-lang/crates.io-index)\" = \"8576dbbfcaef9641452d5cf0df9b0e7eeab7694956dd33bb61515fb8f18cfdd5\"\n+\"checksum regex 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"4278c17d0f6d62dfef0ab00028feb45bd7d2102843f80763474eeb1be8a10c01\"\n+\"checksum regex-syntax 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"2f9191b1f57603095f105d317e375d19b1c9c5c3185ea9633a99a6dcbed04457\"\n+\"checksum rustc-serialize 0.3.22 (registry+https://github.com/rust-lang/crates.io-index)\" = \"237546c689f20bb44980270c73c3b9edd0891c1be49cc1274406134a66d3957b\"\n+\"checksum serde 0.9.7 (registry+https://github.com/rust-lang/crates.io-index)\" = \"1e0ed773960f90a78567fcfbe935284adf50c5d7cf119aa2cf43bb0b4afa69bb\"\n+\"checksum serde_json 0.9.6 (registry+https://github.com/rust-lang/crates.io-index)\" = \"e095e4e94e7382b76f48e93bd845ffddda62df8dfd4c163b1bfa93d40e22e13a\"\n+\"checksum strsim 0.6.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"b4d15c810519a91cf877e7e36e63fe068815c678181439f2f29e2562147c3694\"\n+\"checksum term_size 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"71662702fe5cd2cf95edd4ad655eea42f24a87a0e44059cbaa4e55260b7bc331\"\n+\"checksum thread-id 3.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"4437c97558c70d129e40629a5b385b3fb1ffac301e63941335e4d354081ec14a\"\n+\"checksum thread_local 0.3.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"7793b722f0f77ce716e7f1acf416359ca32ff24d04ffbac4269f44a4a83be05d\"\n \"checksum toml 0.1.30 (registry+https://github.com/rust-lang/crates.io-index)\" = \"0590d72182e50e879c4da3b11c6488dae18fccb1ae0c7a3eda18e16795844796\"\n-\"checksum unicode-segmentation 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"c3bc443ded17b11305ffffe6b37e2076f328a5a8cb6aa877b1b98f77699e98b5\"\n+\"checksum toml 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"08272367dd2e766db3fa38f068067d17aa6a9dfd7259af24b3927db92f1e0c2f\"\n+\"checksum unicode-segmentation 1.1.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"18127285758f0e2c6cf325bb3f3d138a12fee27de4f23e146cd6a179f26c2cf3\"\n \"checksum unicode-width 0.1.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"bf3a113775714a22dcb774d8ea3655c53a32debae63a063acc00a91cc586245f\"\n-\"checksum utf8-ranges 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a1ca13c08c41c9c3e04224ed9ff80461d97e121589ff27c753a16cb10830ae0f\"\n+\"checksum unreachable 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"1f2ae5ddb18e1c92664717616dd9549dde73f539f01bd7b77c2edb2446bdff91\"\n+\"checksum utf8-ranges 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"662fab6525a98beff2921d7f61a39e7d59e0b425ebc7d0d9e66d316e55124122\"\n \"checksum vec_map 0.6.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"cac5efe5cb0fa14ec2f84f83c701c562ee63f6dcc680861b21d65c682adfb05f\"\n+\"checksum void 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"6a02e4885ed3bc0f2de90ea6dd45ebcbb66dacffe03547fadbb0eeae2770887d\"\n \"checksum winapi 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\" = \"167dc9d6949a9b857f3451275e911c3f44255842c1f7a76f33c55103a909087a\"\n \"checksum winapi-build 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"2d315eee3b34aca4797b2da6b13ed88266e6d612562a0c46390af8299fc699bc\""}, {"sha": "62e476bd737d3f62c02d59de2cc168021392b640", "filename": "src/bootstrap/bin/rustc.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Fbootstrap%2Fbin%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Fbootstrap%2Fbin%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbin%2Frustc.rs?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -205,6 +205,11 @@ fn main() {\n                 }\n             }\n         }\n+\n+        if target.contains(\"pc-windows-msvc\") {\n+            cmd.arg(\"-Z\").arg(\"unstable-options\");\n+            cmd.arg(\"-C\").arg(\"target-feature=+crt-static\");\n+        }\n     }\n \n     if verbose > 1 {"}, {"sha": "7ca7ef4bd720c2f8ab8a119af8bbe3c6d52b2390", "filename": "src/bootstrap/bootstrap.py", "status": "modified", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Fbootstrap%2Fbootstrap.py", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Fbootstrap%2Fbootstrap.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbootstrap.py?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -173,6 +173,8 @@ def download_stage0(self):\n             if not os.path.exists(tarball):\n                 get(\"{}/{}\".format(url, filename), tarball, verbose=self.verbose)\n             unpack(tarball, self.bin_root(), match=\"rustc\", verbose=self.verbose)\n+            self.fix_executable(self.bin_root() + \"/bin/rustc\")\n+            self.fix_executable(self.bin_root() + \"/bin/rustdoc\")\n             with open(self.rustc_stamp(), 'w') as f:\n                 f.write(self.stage0_rustc_date())\n \n@@ -185,9 +187,63 @@ def download_stage0(self):\n             if not os.path.exists(tarball):\n                 get(\"{}/{}\".format(url, filename), tarball, verbose=self.verbose)\n             unpack(tarball, self.bin_root(), match=\"cargo\", verbose=self.verbose)\n+            self.fix_executable(self.bin_root() + \"/bin/cargo\")\n             with open(self.cargo_stamp(), 'w') as f:\n                 f.write(self.stage0_cargo_rev())\n \n+    def fix_executable(self, fname):\n+        # If we're on NixOS we need to change the path to the dynamic loader\n+\n+        default_encoding = sys.getdefaultencoding()\n+        try:\n+            ostype = subprocess.check_output(['uname', '-s']).strip().decode(default_encoding)\n+        except (subprocess.CalledProcessError, WindowsError):\n+            return\n+\n+        if ostype != \"Linux\":\n+            return\n+\n+        if not os.path.exists(\"/etc/NIXOS\"):\n+            return\n+        if os.path.exists(\"/lib\"):\n+            return\n+\n+        # At this point we're pretty sure the user is running NixOS\n+        print(\"info: you seem to be running NixOS. Attempting to patch \" + fname)\n+\n+        try:\n+            interpreter = subprocess.check_output([\"patchelf\", \"--print-interpreter\", fname])\n+            interpreter = interpreter.strip().decode(default_encoding)\n+        except subprocess.CalledProcessError as e:\n+            print(\"warning: failed to call patchelf: %s\" % e)\n+            return\n+\n+        loader = interpreter.split(\"/\")[-1]\n+\n+        try:\n+            ldd_output = subprocess.check_output(['ldd', '/run/current-system/sw/bin/sh'])\n+            ldd_output = ldd_output.strip().decode(default_encoding)\n+        except subprocess.CalledProcessError as e:\n+            print(\"warning: unable to call ldd: %s\" % e)\n+            return\n+\n+        for line in ldd_output.splitlines():\n+            libname = line.split()[0]\n+            if libname.endswith(loader):\n+                loader_path = libname[:len(libname) - len(loader)]\n+                break\n+        else:\n+            print(\"warning: unable to find the path to the dynamic linker\")\n+            return\n+\n+        correct_interpreter = loader_path + loader\n+\n+        try:\n+            subprocess.check_output([\"patchelf\", \"--set-interpreter\", correct_interpreter, fname])\n+        except subprocess.CalledProcessError as e:\n+            print(\"warning: failed to call patchelf: %s\" % e)\n+            return\n+\n     def stage0_cargo_rev(self):\n         return self._cargo_rev\n "}, {"sha": "f4a667141665ba1c99e2db836bccc2342b6a85cb", "filename": "src/bootstrap/doc.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Fbootstrap%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Fbootstrap%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdoc.rs?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -115,10 +115,6 @@ pub fn standalone(build: &Build, target: &str) {\n            .arg(\"-o\").arg(&out)\n            .arg(&path);\n \n-        if filename == \"reference.md\" {\n-           cmd.arg(\"--html-in-header\").arg(&full_toc);\n-        }\n-\n         if filename == \"not_found.md\" {\n             cmd.arg(\"--markdown-no-toc\")\n                .arg(\"--markdown-css\")"}, {"sha": "f16fc2092f6161d639c7cca890f0cd87d93cba8b", "filename": "src/bootstrap/native.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Fbootstrap%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Fbootstrap%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fnative.rs?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -99,6 +99,12 @@ pub fn llvm(build: &Build, target: &str) {\n        .define(\"LLVM_TARGET_ARCH\", target.split('-').next().unwrap())\n        .define(\"LLVM_DEFAULT_TARGET_TRIPLE\", target);\n \n+    if target.contains(\"msvc\") {\n+        cfg.define(\"LLVM_USE_CRT_DEBUG\", \"MT\");\n+        cfg.define(\"LLVM_USE_CRT_RELEASE\", \"MT\");\n+        cfg.define(\"LLVM_USE_CRT_RELWITHDEBINFO\", \"MT\");\n+    }\n+\n     if target.starts_with(\"i686\") {\n         cfg.define(\"LLVM_BUILD_32_BITS\", \"ON\");\n     }"}, {"sha": "36738b81c189e4c1dd37be066f039e920b916d6a", "filename": "src/bootstrap/step.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Fbootstrap%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Fbootstrap%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fstep.rs?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -568,6 +568,15 @@ pub fn build_rules<'a>(build: &'a Build) -> Rules {\n          })\n          .default(build.config.docs)\n          .run(move |s| doc::rustbook(build, s.target, \"nomicon\"));\n+    rules.doc(\"doc-reference\", \"src/doc/reference\")\n+         .dep(move |s| {\n+             s.name(\"tool-rustbook\")\n+              .host(&build.config.build)\n+              .target(&build.config.build)\n+              .stage(0)\n+         })\n+         .default(build.config.docs)\n+         .run(move |s| doc::rustbook(build, s.target, \"reference\"));\n     rules.doc(\"doc-standalone\", \"src/doc\")\n          .dep(move |s| {\n              s.name(\"rustc\")"}, {"sha": "103ec39aa38a50789f31d073d082eb3b5a6b04ca", "filename": "src/doc/book/src/attributes.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Fdoc%2Fbook%2Fsrc%2Fattributes.md", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Fdoc%2Fbook%2Fsrc%2Fattributes.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fsrc%2Fattributes.md?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -67,4 +67,4 @@ Rust attributes are used for a number of different things. There is a full list\n of attributes [in the reference][reference]. Currently, you are not allowed to\n create your own attributes, the Rust compiler defines them.\n \n-[reference]: ../reference.html#attributes\n+[reference]: ../reference/attributes.html"}, {"sha": "853fb1ec254176cbb3956440aec18883eb451382", "filename": "src/doc/book/src/casting-between-types.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Fdoc%2Fbook%2Fsrc%2Fcasting-between-types.md", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Fdoc%2Fbook%2Fsrc%2Fcasting-between-types.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fsrc%2Fcasting-between-types.md?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -8,7 +8,7 @@ most dangerous features of Rust!\n # Coercion\n \n Coercion between types is implicit and has no syntax of its own, but can\n-be spelled out with [`as`](#Explicit%20coercions).\n+be spelled out with [`as`](#explicit-coercions).\n \n Coercion occurs in `let`, `const`, and `static` statements; in\n function call arguments; in field values in struct initialization; and in a"}, {"sha": "5426ed0ff4c9c2e4985e2007daaba4bc590103e3", "filename": "src/doc/book/src/closures.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Fdoc%2Fbook%2Fsrc%2Fclosures.md", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Fdoc%2Fbook%2Fsrc%2Fclosures.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fsrc%2Fclosures.md?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -463,7 +463,7 @@ fn factory() -> &(Fn(i32) -> i32) {\n \n Right. Because we have a reference, we need to give it a lifetime. But\n our `factory()` function takes no arguments, so\n-[elision](lifetimes.html#Lifetime%20Elision) doesn\u2019t kick in here. Then what\n+[elision](lifetimes.html#lifetime-elision) doesn\u2019t kick in here. Then what\n choices do we have? Try `'static`:\n \n ```rust,ignore"}, {"sha": "c05d808a947400202e8faa643807690c24123e8f", "filename": "src/doc/book/src/compiler-plugins.md", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Fdoc%2Fbook%2Fsrc%2Fcompiler-plugins.md", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Fdoc%2Fbook%2Fsrc%2Fcompiler-plugins.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fsrc%2Fcompiler-plugins.md?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -119,15 +119,15 @@ The advantages over a simple `fn(&str) -> u32` are:\n   a way to define new literal syntax for any data type.\n \n In addition to procedural macros, you can define new\n-[`derive`](../reference.html#derive)-like attributes and other kinds of\n+[`derive`](../reference/attributes.html#derive)-like attributes and other kinds of\n extensions.  See `Registry::register_syntax_extension` and the `SyntaxExtension`\n enum.  For a more involved macro example, see\n [`regex_macros`](https://github.com/rust-lang/regex/blob/master/regex_macros/src/lib.rs).\n \n \n ## Tips and tricks\n \n-Some of the [macro debugging tips](macros.html#Debugging%20macro%20code) are applicable.\n+Some of the [macro debugging tips](macros.html#debugging-macro-code) are applicable.\n \n You can use `syntax::parse` to turn token trees into\n higher-level syntax elements like expressions:\n@@ -165,8 +165,8 @@ quasiquote as an ordinary plugin library.\n # Lint plugins\n \n Plugins can extend [Rust's lint\n-infrastructure](../reference.html#lint-check-attributes) with additional checks for\n-code style, safety, etc. Now let's write a plugin\n+infrastructure](../reference/attributes.html#lint-check-attributes) with\n+additional checks for code style, safety, etc. Now let's write a plugin\n [`lint_plugin_test.rs`](https://github.com/rust-lang/rust/blob/master/src/test/run-pass-fulldeps/auxiliary/lint_plugin_test.rs)\n that warns about any item named `lintme`.\n \n@@ -244,9 +244,10 @@ mostly use the same infrastructure as lint plugins, and provide examples of how\n to access type information.\n \n Lints defined by plugins are controlled by the usual [attributes and compiler\n-flags](../reference.html#lint-check-attributes), e.g. `#[allow(test_lint)]` or\n-`-A test-lint`. These identifiers are derived from the first argument to\n-`declare_lint!`, with appropriate case and punctuation conversion.\n+flags](../reference/attributes.html#lint-check-attributes), e.g.\n+`#[allow(test_lint)]` or `-A test-lint`. These identifiers are derived from the\n+first argument to `declare_lint!`, with appropriate case and punctuation\n+conversion.\n \n You can run `rustc -W help foo.rs` to see a list of lints known to `rustc`,\n including those provided by plugins loaded by `foo.rs`."}, {"sha": "a64178c26f237f914da56b421067f75c063a5ec0", "filename": "src/doc/book/src/concurrency.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Fdoc%2Fbook%2Fsrc%2Fconcurrency.md", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Fdoc%2Fbook%2Fsrc%2Fconcurrency.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fsrc%2Fconcurrency.md?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -55,7 +55,7 @@ For sharing references across threads, Rust provides a wrapper type called\n `Arc<T>`. `Arc<T>` implements `Send` and `Sync` if and only if `T` implements\n both `Send` and `Sync`. For example, an object of type `Arc<RefCell<U>>` cannot\n be transferred across threads because\n-[`RefCell`](choosing-your-guarantees.html#RefCell%3CT%3E) does not implement\n+[`RefCell`](choosing-your-guarantees.html#refcellt) does not implement\n `Sync`, consequently `Arc<RefCell<U>>` would not implement `Send`.\n \n These two traits allow you to use the type system to make strong guarantees\n@@ -126,7 +126,7 @@ closure only captures a _reference to `x`_. This is a problem, because the\n thread may outlive the scope of `x`, leading to a dangling pointer.\n \n To fix this, we use a `move` closure as mentioned in the error message. `move`\n-closures are explained in depth [here](closures.html#move%20closures); basically\n+closures are explained in depth [here](closures.html#move-closures); basically\n they move variables from their environment into themselves.\n \n ```rust"}, {"sha": "c823c32a135bb272ad08328185a2d85f7928e7c0", "filename": "src/doc/book/src/error-handling.md", "status": "modified", "additions": 36, "deletions": 36, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Fdoc%2Fbook%2Fsrc%2Ferror-handling.md", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Fdoc%2Fbook%2Fsrc%2Ferror-handling.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fsrc%2Ferror-handling.md?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -21,35 +21,35 @@ sum types and combinators, and try to motivate the way Rust does error handling\n incrementally. As such, programmers with experience in other expressive type\n systems may want to jump around.\n \n-* [The Basics](#The%20Basics)\n-    * [Unwrapping explained](#Unwrapping%20explained)\n-    * [The `Option` type](#The%20Option%20type)\n-        * [Composing `Option<T>` values](#Composing%20Option%3CT%3E%20values)\n-    * [The `Result` type](#The%20Result%20type)\n-        * [Parsing integers](#Parsing%20integers)\n-        * [The `Result` type alias idiom](#The%20Result%20type%20alias%20idiom)\n-    * [A brief interlude: unwrapping isn't evil](#A%20brief%20interlude:%20unwrapping%20isnt%20evil)\n-* [Working with multiple error types](#Working%20with%20multiple%20error%20types)\n-    * [Composing `Option` and `Result`](#Composing%20Option%20and%20Result)\n-    * [The limits of combinators](#The%20limits%20of%20combinators)\n-    * [Early returns](#Early%20returns)\n-    * [The `try!` macro](#The%20try%20macro)\n-    * [Defining your own error type](#Defining%20your%20own%20error%20type)\n-* [Standard library traits used for error handling](#Standard%20library%20traits%20used%20for%20error%20handling)\n-    * [The `Error` trait](#The%20Error%20trait)\n-    * [The `From` trait](#The%20From%20trait)\n-    * [The real `try!` macro](#The%20real%20try%20macro)\n-    * [Composing custom error types](#Composing%20custom%20error%20types)\n-    * [Advice for library writers](#Advice%20for%20library%20writers)\n-* [Case study: A program to read population data](#Case%20study:%20A%20program%20to%20read%20population%20data)\n-    * [Initial setup](#Initial%20setup)\n-    * [Argument parsing](#Argument%20parsing)\n-    * [Writing the logic](#Writing%20the%20logic)\n-    * [Error handling with `Box<Error>`](#Error%20handling%20with%20Box%3CError%3E)\n-    * [Reading from stdin](#Reading%20from%20stdin)\n-    * [Error handling with a custom type](#Error%20handling%20with%20a%20custom%20type)\n-    * [Adding functionality](#Adding%20functionality)\n-* [The short story](#The%20short%20story)\n+* [The Basics](#the-basics)\n+    * [Unwrapping explained](#unwrapping-explained)\n+    * [The `Option` type](#the-option-type)\n+        * [Composing `Option<T>` values](#composing-optiont-values)\n+    * [The `Result` type](#the-result-type)\n+        * [Parsing integers](#parsing-integers)\n+        * [The `Result` type alias idiom](#the-result-type-alias-idiom)\n+    * [A brief interlude: unwrapping isn't evil](#a-brief-interlude-unwrapping-isnt-evil)\n+* [Working with multiple error types](#working-with-multiple-error-types)\n+    * [Composing `Option` and `Result`](#composing-option-and-result)\n+    * [The limits of combinators](#the-limits-of-combinators)\n+    * [Early returns](#early-returns)\n+    * [The `try!` macro](#the-try-macro)\n+    * [Defining your own error type](#defining-your-own-error-type)\n+* [Standard library traits used for error handling](#standard-library-traits-used-for-error-handling)\n+    * [The `Error` trait](#the-error-trait)\n+    * [The `From` trait](#the-from-trait)\n+    * [The real `try!` macro](#the-real-try-macro)\n+    * [Composing custom error types](#composing-custom-error-types)\n+    * [Advice for library writers](#advice-for-library-writers)\n+* [Case study: A program to read population data](#case-study-a-program-to-read-population-data)\n+    * [Initial setup](#initial-setup)\n+    * [Argument parsing](#argument-parsing)\n+    * [Writing the logic](#writing-the-logic)\n+    * [Error handling with `Box<Error>`](#error-handling-with-boxerror)\n+    * [Reading from stdin](#reading-from-stdin)\n+    * [Error handling with a custom type](#error-handling-with-a-custom-type)\n+    * [Adding functionality](#adding-functionality)\n+* [The short story](#the-short-story)\n \n # The Basics\n \n@@ -796,7 +796,7 @@ because of the return types of\n [`std::fs::File::open`](../std/fs/struct.File.html#method.open) and\n [`std::io::Read::read_to_string`](../std/io/trait.Read.html#method.read_to_string).\n (Note that they both use the [`Result` type alias\n-idiom](#The%20Result%20type%20alias%20idiom) described previously. If you\n+idiom](#the-result-type-alias-idiom) described previously. If you\n click on the `Result` type, you'll [see the type\n alias](../std/io/type.Result.html), and consequently, the underlying\n `io::Error` type.)  The third problem is described by the\n@@ -1120,7 +1120,7 @@ returns an `&Error`, which is itself a trait object. We'll revisit the\n \n For now, it suffices to show an example implementing the `Error` trait. Let's\n use the error type we defined in the\n-[previous section](#Defining%20your%20own%20error%20type):\n+[previous section](#defining-your-own-error-type):\n \n ```rust\n use std::io;\n@@ -1493,19 +1493,19 @@ representation. But certainly, this will vary depending on use cases.\n At a minimum, you should probably implement the\n [`Error`](../std/error/trait.Error.html)\n trait. This will give users of your library some minimum flexibility for\n-[composing errors](#The%20real%20try%20macro). Implementing the `Error` trait also\n+[composing errors](#the-real-try-macro). Implementing the `Error` trait also\n means that users are guaranteed the ability to obtain a string representation\n of an error (because it requires impls for both `fmt::Debug` and\n `fmt::Display`).\n \n Beyond that, it can also be useful to provide implementations of `From` on your\n error types. This allows you (the library author) and your users to\n-[compose more detailed errors](#Composing%20custom%20error%20types). For example,\n+[compose more detailed errors](#composing-custom-error-types). For example,\n [`csv::Error`](http://burntsushi.net/rustdoc/csv/enum.Error.html)\n provides `From` impls for both `io::Error` and `byteorder::Error`.\n \n Finally, depending on your tastes, you may also want to define a\n-[`Result` type alias](#The%20Result%20type%20alias%20idiom), particularly if your\n+[`Result` type alias](#the-result-type-alias-idiom), particularly if your\n library defines a single error type. This is used in the standard library\n for [`io::Result`](../std/io/type.Result.html)\n and [`fmt::Result`](../std/fmt/type.Result.html).\n@@ -1538,7 +1538,7 @@ and [`rustc-serialize`](https://crates.io/crates/rustc-serialize) crates.\n \n We're not going to spend a lot of time on setting up a project with\n Cargo because it is already covered well in [the Cargo\n-section](getting-started.html#Hello%20Cargo) and [Cargo's documentation][14].\n+section](getting-started.html#hello-cargo) and [Cargo's documentation][14].\n \n To get started from scratch, run `cargo new --bin city-pop` and make sure your\n `Cargo.toml` looks something like this:\n@@ -1729,7 +1729,7 @@ error types and you don't need any `From` implementations. The downside is that\n since `Box<Error>` is a trait object, it *erases the type*, which means the\n compiler can no longer reason about its underlying type.\n \n-[Previously](#The%20limits%20of%20combinators) we started refactoring our code by\n+[Previously](#the-limits-of-combinators) we started refactoring our code by\n changing the type of our function from `T` to `Result<T, OurErrorType>`. In\n this case, `OurErrorType` is only `Box<Error>`. But what's `T`? And can we add\n a return type to `main`?"}, {"sha": "cccefd8dfe73f5d1732586d45426578d3fc58dc3", "filename": "src/doc/book/src/ffi.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Fdoc%2Fbook%2Fsrc%2Fffi.md", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Fdoc%2Fbook%2Fsrc%2Fffi.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fsrc%2Fffi.md?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -680,7 +680,7 @@ pub extern fn hello_rust() -> *const u8 {\n \n The `extern` makes this function adhere to the C calling convention, as\n discussed above in \"[Foreign Calling\n-Conventions](ffi.html#Foreign%20calling%20conventions)\". The `no_mangle`\n+Conventions](ffi.html#foreign-calling-conventions)\". The `no_mangle`\n attribute turns off Rust's name mangling, so that it is easier to link to.\n \n # FFI and panics"}, {"sha": "d02cd776d00e3a48c4fce6de90f77bff9caaaf4d", "filename": "src/doc/book/src/generics.md", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Fdoc%2Fbook%2Fsrc%2Fgenerics.md", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Fdoc%2Fbook%2Fsrc%2Fgenerics.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fsrc%2Fgenerics.md?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -140,5 +140,51 @@ container types like [`Vec<T>`][Vec]. On the other hand, often you want to\n trade that flexibility for increased expressive power. Read about [trait\n bounds][traits] to see why and how.\n \n+## Resolving ambiguities\n+\n+Most of the time when generics are involved, the compiler can infer the\n+generic parameters automatically:\n+\n+```rust\n+// v must be a Vec<T> but we don't know what T is yet\n+let mut v = Vec::new();\n+// v just got a bool value, so T must be bool!\n+v.push(true);\n+// Debug-print v\n+println!(\"{:?}\", v);\n+```\n+\n+Sometimes though, the compiler needs a little help. For example, had we\n+omitted the last line, we would get a compile error:\n+\n+```rust,ignore\n+let v = Vec::new();\n+//      ^^^^^^^^ cannot infer type for `T`\n+//\n+// note: type annotations or generic parameter binding required\n+println!(\"{:?}\", v);\n+```\n+\n+We can solve this using either a type annotation:\n+\n+```rust\n+let v: Vec<bool> = Vec::new();\n+println!(\"{:?}\", v);\n+```\n+\n+or by binding the generic parameter `T` via the so-called\n+[\u2018turbofish\u2019][turbofish] `::<>` syntax:\n+\n+```rust\n+let v = Vec::<bool>::new();\n+println!(\"{:?}\", v);\n+```\n+\n+The second approach is useful in situations where we don\u2019t want to bind the\n+result to a variable. It can also be used to bind generic parameters in\n+functions or methods. See [Iterators \u00a7 Consumers](iterators.html#consumers)\n+for an example.\n+\n [traits]: traits.html\n [Vec]: ../std/vec/struct.Vec.html\n+[turbofish]: https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.collect"}, {"sha": "6208b1f4c123409f76683b6dd61c0742fc058117", "filename": "src/doc/book/src/getting-started.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Fdoc%2Fbook%2Fsrc%2Fgetting-started.md", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Fdoc%2Fbook%2Fsrc%2Fgetting-started.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fsrc%2Fgetting-started.md?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -236,7 +236,7 @@ language]*, which means that most things are expressions, rather than\n statements. The `;` indicates that this expression is over, and the next one is\n ready to begin. Most lines of Rust code end with a `;`.\n \n-[expression-oriented language]: glossary.html#Expression-Oriented%20Language\n+[expression-oriented language]: glossary.html#expression-oriented-language\n \n ## Compiling and Running Are Separate Steps\n "}, {"sha": "b17b89633f356406ef9e003f2ea453b64fcba0d7", "filename": "src/doc/book/src/glossary.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Fdoc%2Fbook%2Fsrc%2Fglossary.md", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Fdoc%2Fbook%2Fsrc%2Fglossary.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fsrc%2Fglossary.md?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -56,7 +56,7 @@ They can be used to manage control flow in a modular fashion.\n \n A type without a statically known size or alignment. ([more info][link])\n \n-[link]: ../nomicon/exotic-sizes.html#Dynamically%20Sized%20Types%20(DSTs)\n+[link]: ../nomicon/exotic-sizes.html#dynamically-sized-types-dsts\n \n ### Expression\n \n@@ -76,8 +76,8 @@ In an expression-oriented language, (nearly) every statement is an expression\n and therefore returns a value. Consequently, these expression statements can\n themselves form part of larger expressions.\n \n-[expression]: glossary.html#Expression\n-[statement]: glossary.html#Statement\n+[expression]: glossary.html#expression\n+[statement]: glossary.html#statement\n \n ### Statement\n "}, {"sha": "7368d2184e5c2d73af831dce3ff7f774b3b95eee", "filename": "src/doc/book/src/guessing-game.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Fdoc%2Fbook%2Fsrc%2Fguessing-game.md", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Fdoc%2Fbook%2Fsrc%2Fguessing-game.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fsrc%2Fguessing-game.md?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -119,7 +119,7 @@ there are no arguments, and `{` starts the body of the function. Because\n we didn\u2019t include a return type, it\u2019s assumed to be `()`, an empty\n [tuple][tuples].\n \n-[tuples]: primitive-types.html#Tuples\n+[tuples]: primitive-types.html#tuples\n \n ```rust,ignore\n     println!(\"Guess the number!\");\n@@ -727,7 +727,7 @@ thirty-two bit integer. Rust has [a number of built-in number types][number],\n but we\u2019ve chosen `u32`. It\u2019s a good default choice for a small positive number.\n \n [parse]: ../std/primitive.str.html#method.parse\n-[number]: primitive-types.html#Numeric%20types\n+[number]: primitive-types.html#numeric-types\n \n Just like `read_line()`, our call to `parse()` could cause an error. What if\n our string contained `A\ud83d\udc4d%`? There\u2019d be no way to convert that to a number. As"}, {"sha": "8ee6c0828ad6b7253a507a56c224749566d7b307", "filename": "src/doc/book/src/iterators.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Fdoc%2Fbook%2Fsrc%2Fiterators.md", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Fdoc%2Fbook%2Fsrc%2Fiterators.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fsrc%2Fiterators.md?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -135,10 +135,10 @@ Here's the version that does compile:\n let one_to_one_hundred = (1..101).collect::<Vec<i32>>();\n ```\n \n-If you remember, the `::<>` syntax allows us to give a type hint,\n-and so we tell it that we want a vector of integers. You don't always\n-need to use the whole type, though. Using a `_` will let you provide\n-a partial hint:\n+If you remember, the [`::<>` syntax](generics.html#resolving-ambiguities)\n+allows us to give a type hint that tells the compiler we want a vector of\n+integers. You don't always need to use the whole type, though. Using a `_`\n+will let you provide a partial hint:\n \n ```rust\n let one_to_one_hundred = (1..101).collect::<Vec<_>>();"}, {"sha": "8bca13c28f0bd2b2def24b6dc7b1ed8bbdc28abd", "filename": "src/doc/book/src/lifetimes.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Fdoc%2Fbook%2Fsrc%2Flifetimes.md", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Fdoc%2Fbook%2Fsrc%2Flifetimes.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fsrc%2Flifetimes.md?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -139,7 +139,7 @@ associated with it, but the compiler lets you elide (i.e. omit, see\n [\"Lifetime Elision\"][lifetime-elision] below) them in common cases. Before we\n get to that, though, let\u2019s look at a short example with explicit lifetimes:\n \n-[lifetime-elision]: #Lifetime%20Elision\n+[lifetime-elision]: #lifetime-elision\n \n ```rust,ignore\n fn bar<'a>(...)"}, {"sha": "93f63ddc0a562bd1583dbf9ffebddfc08667ddf7", "filename": "src/doc/book/src/macros.md", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Fdoc%2Fbook%2Fsrc%2Fmacros.md", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Fdoc%2Fbook%2Fsrc%2Fmacros.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fsrc%2Fmacros.md?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -101,7 +101,7 @@ trees, at compile time. The semicolon is optional on the last (here, only)\n case. The \"pattern\" on the left-hand side of `=>` is known as a \u2018matcher\u2019.\n These have [their own little grammar] within the language.\n \n-[their own little grammar]: ../reference.html#macros\n+[their own little grammar]: ../reference/macros.html\n \n The matcher `$x:expr` will match any Rust expression, binding that syntax tree\n to the \u2018metavariable\u2019 `$x`. The identifier `expr` is a \u2018fragment specifier\u2019;\n@@ -363,7 +363,7 @@ fn main() {\n }\n ```\n \n-[items]: ../reference.html#items\n+[items]: ../reference/items.html\n \n # Recursive macros\n \n@@ -430,7 +430,7 @@ Even when Rust code contains un-expanded macros, it can be parsed as a full\n tools that process code. It also has a few consequences for the design of\n Rust\u2019s macro system.\n \n-[ast]: glossary.html#Abstract%20Syntax%20Tree\n+[ast]: glossary.html#abstract-syntax-tree\n \n One consequence is that Rust must determine, when it parses a macro invocation,\n whether the macro stands in for\n@@ -490,7 +490,7 @@ be forced to choose between parsing `$i` and parsing `$e`. Changing the\n invocation syntax to put a distinctive token in front can solve the problem. In\n this case, you can write `$(I $i:ident)* E $e:expr`.\n \n-[item]: ../reference.html#items\n+[item]: ../reference/items.html\n \n # Scoping and macro import/export\n \n@@ -565,7 +565,7 @@ When this library is loaded with `#[macro_use] extern crate`, only `m2` will\n be imported.\n \n The Rust Reference has a [listing of macro-related\n-attributes](../reference.html#macro-related-attributes).\n+attributes](../reference/attributes.html#macro-related-attributes).\n \n # The variable `$crate`\n "}, {"sha": "fa7a259392a7e6af0ca22da903749bd54269a90e", "filename": "src/doc/book/src/mutability.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Fdoc%2Fbook%2Fsrc%2Fmutability.md", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Fdoc%2Fbook%2Fsrc%2Fmutability.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fsrc%2Fmutability.md?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -89,7 +89,7 @@ philosophy, memory safety, and the mechanism by which Rust guarantees it, the\n > * exactly one mutable reference (`&mut T`).\n \n [ownership]: ownership.html\n-[borrowing]: references-and-borrowing.html#Borrowing\n+[borrowing]: references-and-borrowing.html#borrowing\n \n So, that\u2019s the real definition of \u2018immutability\u2019: is this safe to have two\n pointers to? In `Arc<T>`\u2019s case, yes: the mutation is entirely contained inside"}, {"sha": "21ebd6333f7101bd2d2d28db0d5fa013b3606369", "filename": "src/doc/book/src/ownership.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Fdoc%2Fbook%2Fsrc%2Fownership.md", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Fdoc%2Fbook%2Fsrc%2Fownership.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fsrc%2Fownership.md?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -65,10 +65,10 @@ elements onto them.\n Vectors have a [generic type][generics] `Vec<T>`, so in this example `v` will have type\n `Vec<i32>`. We'll cover [generics] in detail in a later chapter.\n \n-[arrays]: primitive-types.html#Arrays\n+[arrays]: primitive-types.html#arrays\n [vectors]: vectors.html\n-[heap]: the-stack-and-the-heap.html#The%20Heap\n-[stack]: the-stack-and-the-heap.html#The%20Stack\n+[heap]: the-stack-and-the-heap.html#the-heap\n+[stack]: the-stack-and-the-heap.html#the-stack\n [bindings]: variable-bindings.html\n [generics]: generics.html\n \n@@ -136,7 +136,7 @@ Rust allocates memory for an integer [i32] on the [stack][sh], copies the bit\n pattern representing the value of 10 to the allocated memory and binds the\n variable name x to this memory region for future reference.\n \n-[i32]: primitive-types.html#Numeric%20types\n+[i32]: primitive-types.html#numeric-types\n \n Now consider the following code fragment:\n "}, {"sha": "8fd3d17c15e57f5a90a59ed14f6bfb016b9cbd5d", "filename": "src/doc/book/src/primitive-types.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Fdoc%2Fbook%2Fsrc%2Fprimitive-types.md", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Fdoc%2Fbook%2Fsrc%2Fprimitive-types.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fsrc%2Fprimitive-types.md?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -232,7 +232,7 @@ soon.\n You can assign one tuple into another, if they have the same contained types\n and [arity]. Tuples have the same arity when they have the same length.\n \n-[arity]: glossary.html#Arity\n+[arity]: glossary.html#arity\n \n ```rust\n let mut x = (1, 2); // x: (i32, i32)"}, {"sha": "079324d56d1e662ea82e280f2415155f902452b4", "filename": "src/doc/book/src/procedural-macros.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Fdoc%2Fbook%2Fsrc%2Fprocedural-macros.md", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Fdoc%2Fbook%2Fsrc%2Fprocedural-macros.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fsrc%2Fprocedural-macros.md?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -169,7 +169,7 @@ So this is where quotes comes in. The `ast` argument is a struct that gives us\n a representation of our type (which can be either a `struct` or an `enum`).\n Check out the [docs](https://docs.rs/syn/0.10.5/syn/struct.MacroInput.html),\n there is some useful information there. We are able to get the name of the\n-type using `ast.ident`. The `quote!` macro let's us write up the Rust code\n+type using `ast.ident`. The `quote!` macro lets us write up the Rust code\n that we wish to return and convert it into `Tokens`. `quote!` let's us use some\n really cool templating mechanics; we simply write `#name` and `quote!` will\n replace it with the variable named `name`. You can even do some repetition"}, {"sha": "6b2a145c85e512ffdf9d14733bf01509c9eda522", "filename": "src/doc/book/src/structs.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Fdoc%2Fbook%2Fsrc%2Fstructs.md", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Fdoc%2Fbook%2Fsrc%2Fstructs.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fsrc%2Fstructs.md?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -134,7 +134,7 @@ fn main() {\n     let age = 27;\n     let peter = Person { name, age };\n \n-    // Print debug struct\n+    // Debug-print struct\n     println!(\"{:?}\", peter);\n }\n ```"}, {"sha": "a06520f4ac2f31769eb18f95615e9944da7baad3", "filename": "src/doc/book/src/syntax-index.md", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Fdoc%2Fbook%2Fsrc%2Fsyntax-index.md", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Fdoc%2Fbook%2Fsrc%2Fsyntax-index.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fsrc%2Fsyntax-index.md?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -125,7 +125,7 @@\n <!-- Generics -->\n \n * `path<\u2026>` (*e.g.* `Vec<u8>`): specifies parameters to generic type *in a type*.  See [Generics].\n-* `path::<\u2026>`, `method::<\u2026>` (*e.g.* `\"42\".parse::<i32>()`): specifies parameters to generic type, function, or method *in an expression*.\n+* `path::<\u2026>`, `method::<\u2026>` (*e.g.* `\"42\".parse::<i32>()`): specifies parameters to generic type, function, or method *in an expression*.  See [Generics \u00a7 Resolving ambiguities](generics.html#resolving-ambiguities).\n * `fn ident<\u2026> \u2026`: define generic function.  See [Generics].\n * `struct ident<\u2026> \u2026`: define generic structure.  See [Generics].\n * `enum ident<\u2026> \u2026`: define generic enumeration.  See [Generics].\n@@ -196,18 +196,18 @@\n [Associated Types]: associated-types.html\n [Attributes]: attributes.html\n [Casting Between Types (`as`)]: casting-between-types.html#as\n-[Closures (`move` closures)]: closures.html#move%20closures\n+[Closures (`move` closures)]: closures.html#move-closures\n [Closures]: closures.html\n [Comments]: comments.html\n-[Crates and Modules (Defining Modules)]: crates-and-modules.html#Defining%20modules\n-[Crates and Modules (Exporting a Public Interface)]: crates-and-modules.html#Exporting%20a%20public%20interface\n-[Crates and Modules (Importing External Crates)]: crates-and-modules.html#Importing%20external%20crates\n-[Crates and Modules (Importing Modules with `use`)]: crates-and-modules.html#Importing%20modules%20with%20use\n-[Crates and Modules (Re-exporting with `pub use`)]: crates-and-modules.html#Re-exporting%20with%20pub%20use\n-[Diverging Functions]: functions.html#Diverging%20functions\n+[Crates and Modules (Defining Modules)]: crates-and-modules.html#defining-modules\n+[Crates and Modules (Exporting a Public Interface)]: crates-and-modules.html#exporting-a-public-interface\n+[Crates and Modules (Importing External Crates)]: crates-and-modules.html#importing-external-crates\n+[Crates and Modules (Importing Modules with `use`)]: crates-and-modules.html#importing-modules-with-use\n+[Crates and Modules (Re-exporting with `pub use`)]: crates-and-modules.html#re-exporting-with-pub-use\n+[Diverging Functions]: functions.html#diverging-functions\n [Enums]: enums.html\n [Foreign Function Interface]: ffi.html\n-[Functions (Early Returns)]: functions.html#Early%20returns\n+[Functions (Early Returns)]: functions.html#early-returns\n [Functions]: functions.html\n [Generics]: generics.html\n [Iterators]: iterators.html\n@@ -216,38 +216,38 @@\n [Loops (`for`)]: loops.html#for\n [Loops (`loop`)]: loops.html#loop\n [Loops (`while`)]: loops.html#while\n-[Loops (Ending Iteration Early)]: loops.html#Ending%20iteration%20early\n-[Loops (Loops Labels)]: loops.html#Loop%20labels\n+[Loops (Ending Iteration Early)]: loops.html#ending-iteration-early\n+[Loops (Loops Labels)]: loops.html#loop-labels\n [Macros]: macros.html\n [Match]: match.html\n-[Method Syntax (Method Calls)]: method-syntax.html#Method%20calls\n+[Method Syntax (Method Calls)]: method-syntax.html#method-calls\n [Method Syntax]: method-syntax.html\n [Mutability]: mutability.html\n [Operators and Overloading]: operators-and-overloading.html\n-[Patterns (`ref` and `ref mut`)]: patterns.html#ref%20and%20ref%20mut\n-[Patterns (Bindings)]: patterns.html#Bindings\n-[Patterns (Ignoring bindings)]: patterns.html#Ignoring%20bindings\n-[Patterns (Multiple patterns)]: patterns.html#Multiple%20patterns\n-[Patterns (Ranges)]: patterns.html#Ranges\n+[Patterns (`ref` and `ref mut`)]: patterns.html#ref-and-ref-mut\n+[Patterns (Bindings)]: patterns.html#bindings\n+[Patterns (Ignoring bindings)]: patterns.html#ignoring-bindings\n+[Patterns (Multiple patterns)]: patterns.html#multiple-patterns\n+[Patterns (Ranges)]: patterns.html#ranges\n [Primitive Types (`char`)]: primitive-types.html#char\n-[Primitive Types (Arrays)]: primitive-types.html#Arrays\n-[Primitive Types (Booleans)]: primitive-types.html#Booleans\n-[Primitive Types (Tuple Indexing)]: primitive-types.html#Tuple%20indexing\n-[Primitive Types (Tuples)]: primitive-types.html#Tuples\n+[Primitive Types (Arrays)]: primitive-types.html#arrays\n+[Primitive Types (Booleans)]: primitive-types.html#booleans\n+[Primitive Types (Tuple Indexing)]: primitive-types.html#tuple-indexing\n+[Primitive Types (Tuples)]: primitive-types.html#tuples\n [Raw Pointers]: raw-pointers.html\n-[Reference (Byte String Literals)]: ../reference.html#byte-string-literals\n-[Reference (Integer literals)]: ../reference.html#integer-literals\n-[Reference (Raw Byte String Literals)]: ../reference.html#raw-byte-string-literals\n-[Reference (Raw String Literals)]: ../reference.html#raw-string-literals\n+[Reference (Byte String Literals)]: ../reference/tokens.html/#byte-string-literals\n+[Reference (Integer literals)]: ../reference/tokens.html#integer-literals\n+[Reference (Raw Byte String Literals)]: ../reference/tokens.html#raw-byte-string-literals\n+[Reference (Raw String Literals)]: ../reference/tokens.html#raw-string-literals\n [References and Borrowing]: references-and-borrowing.html\n [Strings]: strings.html\n-[Structs (Update syntax)]: structs.html#Update%20syntax\n+[Structs (Update syntax)]: structs.html#update-syntax\n [Structs]: structs.html\n-[Traits (`where` clause)]: traits.html#Where%20clause\n-[Traits (Multiple Trait Bounds)]: traits.html#Multiple%20trait%20bounds\n+[Traits (`where` clause)]: traits.html#where-clause\n+[Traits (Multiple Trait Bounds)]: traits.html#multiple-trait-bounds\n [Traits]: traits.html\n [Universal Function Call Syntax]: ufcs.html\n-[Universal Function Call Syntax (Angle-bracket Form)]: ufcs.html#Angle-bracket%20Form\n+[Universal Function Call Syntax (Angle-bracket Form)]: ufcs.html#angle-bracket-form\n [Unsafe]: unsafe.html\n-[Unsized Types (`?Sized`)]: unsized-types.html#Sized\n+[Unsized Types (`?Sized`)]: unsized-types.html#sized\n [Variable Bindings]: variable-bindings.html"}, {"sha": "19a133f84b0b6ffee92eaf55645bfc1989e4263b", "filename": "src/doc/book/src/traits.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Fdoc%2Fbook%2Fsrc%2Ftraits.md", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Fdoc%2Fbook%2Fsrc%2Ftraits.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fsrc%2Ftraits.md?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -81,7 +81,7 @@ Traits are useful because they allow a type to make certain promises about its\n behavior. Generic functions can exploit this to constrain, or [bound][bounds], the types they\n accept. Consider this function, which does not compile:\n \n-[bounds]: glossary.html#Bounds\n+[bounds]: glossary.html#bounds\n \n ```rust,ignore\n fn print_area<T>(shape: T) {"}, {"sha": "1bd0f78e36853143cf391b91957ef653c1ed20a9", "filename": "src/doc/book/src/type-aliases.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Fdoc%2Fbook%2Fsrc%2Ftype-aliases.md", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Fdoc%2Fbook%2Fsrc%2Ftype-aliases.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fsrc%2Ftype-aliases.md?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -55,7 +55,7 @@ if x == y {\n This compiles without error. Values of a `Num` type are the same as a value of\n type `i32`, in every way. You can use [tuple struct] to really get a new type.\n \n-[tuple struct]: structs.html#Tuple%20structs\n+[tuple struct]: structs.html#tuple-structs\n \n You can also use type aliases with generics:\n "}, {"sha": "d6aa8b1acb72fd6c480d2e845661397e51d2b446", "filename": "src/doc/book/src/variable-bindings.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Fdoc%2Fbook%2Fsrc%2Fvariable-bindings.md", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Fdoc%2Fbook%2Fsrc%2Fvariable-bindings.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fsrc%2Fvariable-bindings.md?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -181,7 +181,7 @@ print.\n # Scope and shadowing\n \n Let\u2019s get back to bindings. Variable bindings have a scope - they are\n-constrained to live in a block they were defined in. A block is a collection\n+constrained to live in the block they were defined in. A block is a collection\n of statements enclosed by `{` and `}`. Function definitions are also blocks!\n In the following example we define two variable bindings, `x` and `y`, which\n live in different blocks. `x` can be accessed from inside the `fn main() {}`"}, {"sha": "aff078718dfb1311726529cb5199d7c2001d8288", "filename": "src/doc/book/src/vectors.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Fdoc%2Fbook%2Fsrc%2Fvectors.md", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Fdoc%2Fbook%2Fsrc%2Fvectors.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fsrc%2Fvectors.md?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -151,6 +151,6 @@ API documentation][vec].\n [vec]: ../std/vec/index.html\n [box]: ../std/boxed/index.html\n [generic]: generics.html\n-[panic]: concurrency.html#Panics\n+[panic]: concurrency.html#panics\n [get]: ../std/vec/struct.Vec.html#method.get\n [get_mut]: ../std/vec/struct.Vec.html#method.get_mut"}, {"sha": "8e803aff4d6fe3a40b12d1da2ebef7f3ec48667b", "filename": "src/doc/grammar.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Fdoc%2Fgrammar.md", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Fdoc%2Fgrammar.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fgrammar.md?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -187,7 +187,7 @@ literal : [ string_lit | char_lit | byte_string_lit | byte_lit | num_lit | bool_\n The optional `lit_suffix` production is only used for certain numeric literals,\n but is reserved for future extension. That is, the above gives the lexical\n grammar, but a Rust parser will reject everything but the 12 special cases\n-mentioned in [Number literals](reference.html#number-literals) in the\n+mentioned in [Number literals](reference/tokens.html#number-literals) in the\n reference.\n \n #### Character and string literals"}, {"sha": "982e24ef69549621e6df4a5b917ecd6b482ce973", "filename": "src/doc/index.md", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Fdoc%2Findex.md", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Fdoc%2Findex.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Findex.md?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -16,14 +16,6 @@ builds documentation for individual Rust packages.\n Rust provides a standard library with a number of features; [we host its\n documentation here][api].\n \n-## Reference Documentation\n-\n-Rust does not yet have a formal specification, but we have [a reference document\n-][ref]. It is guaranteed to be accurate, but not complete. We now have a\n-policy that all new features must be included in the reference before\n-stabilization; however, we are still back-filling things that landed before\n-then. That work is being tracked [here][38643].\n-\n ## Extended Error Documentation\n \n Many of Rust's errors come with error codes, and you can request extended\n@@ -37,11 +29,17 @@ nicknamed 'The Rust Bookshelf.'\n \n * [The Rust Programming Language][book] teaches you how to program in Rust.\n * [The Rustonomicon][nomicon] is your guidebook to the dark arts of unsafe Rust.\n+* [The Reference][ref] is not a formal spec, but is more detailed and comprehensive than the book.\n+\n+Another few words about the reference: it is guaranteed to be accurate, but not\n+complete. We now have a policy that all new features must be included in the\n+reference before stabilization; however, we are still back-filling things that\n+landed before then. That work is being tracked [here][38643].\n \n [Rust Learning]: https://github.com/ctjhoa/rust-learning\n [Docs.rs]: https://docs.rs/\n [api]: std/index.html\n-[ref]: reference.html\n+[ref]: reference/index.html\n [38643]: https://github.com/rust-lang/rust/issues/38643\n [err]: error-index.html\n [book]: book/index.html"}, {"sha": "e69264f281c9928fe8f27b9e6ebade5b95feb2a1", "filename": "src/doc/nomicon/src/drop-flags.md", "status": "modified", "additions": 2, "deletions": 14, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Fdoc%2Fnomicon%2Fsrc%2Fdrop-flags.md", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Fdoc%2Fnomicon%2Fsrc%2Fdrop-flags.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon%2Fsrc%2Fdrop-flags.md?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -79,17 +79,5 @@ if condition {\n }\n ```\n \n-As of Rust 1.0, the drop flags are actually not-so-secretly stashed in a hidden\n-field of any type that implements Drop. Rust sets the drop flag by overwriting\n-the entire value with a particular bit pattern. This is pretty obviously Not\n-The Fastest and causes a bunch of trouble with optimizing code. It's legacy from\n-a time when you could do much more complex conditional initialization.\n-\n-As such work is currently under way to move the flags out onto the stack frame\n-where they more reasonably belong. Unfortunately, this work will take some time\n-as it requires fairly substantial changes to the compiler.\n-\n-Regardless, Rust programs don't need to worry about uninitialized values on\n-the stack for correctness. Although they might care for performance. Thankfully,\n-Rust makes it easy to take control here! Uninitialized values are there, and\n-you can work with them in Safe Rust, but you're never in danger.\n+The drop flags are tracked on the stack and no longer stashed in types that\n+implement drop."}, {"sha": "30b4f09f9032de94c3c10e39e3ef112448524a1a", "filename": "src/doc/nomicon/src/lifetime-mismatch.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Fdoc%2Fnomicon%2Fsrc%2Flifetime-mismatch.md", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Fdoc%2Fnomicon%2Fsrc%2Flifetime-mismatch.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon%2Fsrc%2Flifetime-mismatch.md?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -78,4 +78,4 @@ TODO: other common problems? SEME regions stuff, mostly?\n \n \n \n-[ex2]: lifetimes.html#Example%3A%20aliasing%20a%20mutable%20reference\n+[ex2]: lifetimes.html#example-aliasing-a-mutable-reference"}, {"sha": "c02cf44189f1a704354712dbed60f2b31f73fa47", "filename": "src/doc/nomicon/src/repr-rust.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Fdoc%2Fnomicon%2Fsrc%2Frepr-rust.md", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Fdoc%2Fnomicon%2Fsrc%2Frepr-rust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon%2Fsrc%2Frepr-rust.md?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -151,4 +151,4 @@ use fairly elaborate algorithms to cache bits throughout nested types with\n special constrained representations. As such it is *especially* desirable that\n we leave enum layout unspecified today.\n \n-[dst]: exotic-sizes.html#Dynamically%20Sized%20Types%20(DSTs)\n+[dst]: exotic-sizes.html#dynamically-sized-types-dsts"}, {"sha": "fdeea17ed1124bde8b8453bd4c6b0a6035079074", "filename": "src/doc/reference.md", "status": "modified", "additions": 3, "deletions": 4410, "changes": 4413, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6"}, {"sha": "7585238efedfc33acdd9494b0269951aaf3909ec", "filename": "src/doc/reference/.gitignore", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Fdoc%2Freference%2F.gitignore", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Fdoc%2Freference%2F.gitignore", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference%2F.gitignore?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -0,0 +1 @@\n+book"}, {"sha": "a07e195a7184fefa83fecbddb79c39e1f15b99e6", "filename": "src/doc/reference/src/SUMMARY.md", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Fdoc%2Freference%2Fsrc%2FSUMMARY.md", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Fdoc%2Freference%2Fsrc%2FSUMMARY.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference%2Fsrc%2FSUMMARY.md?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -0,0 +1,58 @@\n+# The Rust Reference\n+\n+[Introduction](introduction.md)\n+\n+- [Notation](notation.md)\n+    - [Unicode productions](unicode-productions.md)\n+    - [String table productions](string-table-productions.md)\n+\n+- [Lexical structure](lexical-structure.md)\n+    - [Input format](input-format.md)\n+    - [Identifiers](identifiers.md)\n+    - [Comments](comments.md)\n+    - [Whitespace](whitespace.md)\n+    - [Tokens](tokens.md)\n+    - [Paths](paths.md)\n+\n+- [Macros](macros.md)\n+    - [Macros By Example](macros-by-example.md)\n+    - [Procedrual Macros](procedural-macros.md)\n+\n+- [Crates and source files](crates-and-source-files.md)\n+\n+- [Items and attributes](items-and-attributes.md)\n+    - [Items](items.md)\n+    - [Visibility and Privacy](visibility-and-privacy.md)\n+    - [Attributes](attributes.md)\n+\n+- [Statements and expressions](statements-and-expressions.md)\n+    - [Statements](statements.md)\n+    - [Expressions](expressions.md)\n+\n+- [Type system](type-system.md)\n+    - [Types](types.md)\n+    - [Subtyping](subtyping.md)\n+    - [Type coercions](type-coercions.md)\n+\n+- [Special traits](special-traits.md)\n+    - [The Copy trait](the-copy-trait.md)\n+    - [The Sized trait](the-sized-trait.md)\n+    - [The Drop trait](the-drop-trait.md)\n+    - [The Deref trait](the-deref-trait.md)\n+    - [The Send trait](the-send-trait.md)\n+    - [The Sync trait](the-sync-trait.md)\n+\n+- [Memory model](memory-model.md)\n+    - [Memory allocation and lifetime](memory-allocation-and-lifetime.md)\n+    - [Memory ownership](memory-ownership.md)\n+    - [Variables](variables.md)\n+\n+- [Linkage](linkage.md)\n+\n+- [Unsafety](unsafety.md)\n+    - [Unsafe functions](unsafe-functions.md)\n+    - [Unsafe blocks](unsafe-blocks.md)\n+    - [Behavior considered undefined](behavior-considered-undefined.md)\n+    - [Behavior not considered unsafe](behavior-not-considered-unsafe.md)\n+\n+[Appendix: Influences](influences.md)"}, {"sha": "da43e1cc057eb48e417db7fd5e99fecda15715fd", "filename": "src/doc/reference/src/attributes.md", "status": "added", "additions": 630, "deletions": 0, "changes": 630, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Fdoc%2Freference%2Fsrc%2Fattributes.md", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Fdoc%2Freference%2Fsrc%2Fattributes.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference%2Fsrc%2Fattributes.md?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -0,0 +1,630 @@\n+# Attributes\n+\n+Any item declaration may have an _attribute_ applied to it. Attributes in Rust\n+are modeled on Attributes in ECMA-335, with the syntax coming from ECMA-334\n+(C#). An attribute is a general, free-form metadatum that is interpreted\n+according to name, convention, and language and compiler version. Attributes\n+may appear as any of:\n+\n+* A single identifier, the attribute name\n+* An identifier followed by the equals sign '=' and a literal, providing a\n+  key/value pair\n+* An identifier followed by a parenthesized list of sub-attribute arguments\n+\n+Attributes with a bang (\"!\") after the hash (\"#\") apply to the item that the\n+attribute is declared within. Attributes that do not have a bang after the hash\n+apply to the item that follows the attribute.\n+\n+An example of attributes:\n+\n+```{.rust}\n+// General metadata applied to the enclosing module or crate.\n+#![crate_type = \"lib\"]\n+\n+// A function marked as a unit test\n+#[test]\n+fn test_foo() {\n+    /* ... */\n+}\n+\n+// A conditionally-compiled module\n+#[cfg(target_os=\"linux\")]\n+mod bar {\n+    /* ... */\n+}\n+\n+// A lint attribute used to suppress a warning/error\n+#[allow(non_camel_case_types)]\n+type int8_t = i8;\n+```\n+\n+> **Note:** At some point in the future, the compiler will distinguish between\n+> language-reserved and user-available attributes. Until then, there is\n+> effectively no difference between an attribute handled by a loadable syntax\n+> extension and the compiler.\n+\n+## Crate-only attributes\n+\n+- `crate_name` - specify the crate's crate name.\n+- `crate_type` - see [linkage](linkage.html).\n+- `feature` - see [compiler features](#compiler-features).\n+- `no_builtins` - disable optimizing certain code patterns to invocations of\n+                  library functions that are assumed to exist\n+- `no_main` - disable emitting the `main` symbol. Useful when some other\n+   object being linked to defines `main`.\n+- `no_start` - disable linking to the `native` crate, which specifies the\n+  \"start\" language item.\n+- `no_std` - disable linking to the `std` crate.\n+- `plugin` - load a list of named crates as compiler plugins, e.g.\n+             `#![plugin(foo, bar)]`. Optional arguments for each plugin,\n+             i.e. `#![plugin(foo(... args ...))]`, are provided to the plugin's\n+             registrar function.  The `plugin` feature gate is required to use\n+             this attribute.\n+- `recursion_limit` - Sets the maximum depth for potentially\n+                      infinitely-recursive compile-time operations like\n+                      auto-dereference or macro expansion. The default is\n+                      `#![recursion_limit=\"64\"]`.\n+\n+### Module-only attributes\n+\n+- `no_implicit_prelude` - disable injecting `use std::prelude::*` in this\n+  module.\n+- `path` - specifies the file to load the module from. `#[path=\"foo.rs\"] mod\n+  bar;` is equivalent to `mod bar { /* contents of foo.rs */ }`. The path is\n+  taken relative to the directory that the current module is in.\n+\n+## Function-only attributes\n+\n+- `main` - indicates that this function should be passed to the entry point,\n+  rather than the function in the crate root named `main`.\n+- `plugin_registrar` - mark this function as the registration point for\n+  [compiler plugins][plugin], such as loadable syntax extensions.\n+- `start` - indicates that this function should be used as the entry point,\n+  overriding the \"start\" language item. See the \"start\" [language\n+  item](#language-items) for more details.\n+- `test` - indicates that this function is a test function, to only be compiled\n+  in case of `--test`.\n+- `should_panic` - indicates that this test function should panic, inverting the success condition.\n+- `cold` - The function is unlikely to be executed, so optimize it (and calls\n+  to it) differently.\n+- `naked` - The function utilizes a custom ABI or custom inline ASM that requires\n+  epilogue and prologue to be skipped.\n+\n+## Static-only attributes\n+\n+- `thread_local` - on a `static mut`, this signals that the value of this\n+  static may change depending on the current thread. The exact consequences of\n+  this are implementation-defined.\n+\n+## FFI attributes\n+\n+On an `extern` block, the following attributes are interpreted:\n+\n+- `link_args` - specify arguments to the linker, rather than just the library\n+  name and type. This is feature gated and the exact behavior is\n+  implementation-defined (due to variety of linker invocation syntax).\n+- `link` - indicate that a native library should be linked to for the\n+  declarations in this block to be linked correctly. `link` supports an optional\n+  `kind` key with three possible values: `dylib`, `static`, and `framework`. See\n+  [external blocks](items.html#external-blocks) for more about external blocks. Two\n+  examples: `#[link(name = \"readline\")]` and\n+  `#[link(name = \"CoreFoundation\", kind = \"framework\")]`.\n+- `linked_from` - indicates what native library this block of FFI items is\n+  coming from. This attribute is of the form `#[linked_from = \"foo\"]` where\n+  `foo` is the name of a library in either `#[link]` or a `-l` flag. This\n+  attribute is currently required to export symbols from a Rust dynamic library\n+  on Windows, and it is feature gated behind the `linked_from` feature.\n+\n+On declarations inside an `extern` block, the following attributes are\n+interpreted:\n+\n+- `link_name` - the name of the symbol that this function or static should be\n+  imported as.\n+- `linkage` - on a static, this specifies the [linkage\n+  type](http://llvm.org/docs/LangRef.html#linkage-types).\n+\n+On `enum`s:\n+\n+- `repr` - on C-like enums, this sets the underlying type used for\n+  representation. Takes one argument, which is the primitive\n+  type this enum should be represented for, or `C`, which specifies that it\n+  should be the default `enum` size of the C ABI for that platform. Note that\n+  enum representation in C is undefined, and this may be incorrect when the C\n+  code is compiled with certain flags.\n+\n+On `struct`s:\n+\n+- `repr` - specifies the representation to use for this struct. Takes a list\n+  of options. The currently accepted ones are `C` and `packed`, which may be\n+  combined. `C` will use a C ABI compatible struct layout, and `packed` will\n+  remove any padding between fields (note that this is very fragile and may\n+  break platforms which require aligned access).\n+\n+## Macro-related attributes\n+\n+- `macro_use` on a `mod` \u2014 macros defined in this module will be visible in the\n+  module's parent, after this module has been included.\n+\n+- `macro_use` on an `extern crate` \u2014 load macros from this crate.  An optional\n+  list of names `#[macro_use(foo, bar)]` restricts the import to just those\n+  macros named.  The `extern crate` must appear at the crate root, not inside\n+  `mod`, which ensures proper function of the [`$crate` macro\n+  variable](../book/macros.html#the-variable-crate).\n+\n+- `macro_reexport` on an `extern crate` \u2014 re-export the named macros.\n+\n+- `macro_export` - export a macro for cross-crate usage.\n+\n+- `no_link` on an `extern crate` \u2014 even if we load this crate for macros, don't\n+  link it into the output.\n+\n+See the [macros section of the\n+book](../book/macros.html#scoping-and-macro-importexport) for more information on\n+macro scope.\n+\n+## Miscellaneous attributes\n+\n+- `deprecated` - mark the item as deprecated; the full attribute is \n+  `#[deprecated(since = \"crate version\", note = \"...\")`, where both arguments \n+  are optional.\n+- `export_name` - on statics and functions, this determines the name of the\n+  exported symbol.\n+- `link_section` - on statics and functions, this specifies the section of the\n+  object file that this item's contents will be placed into.\n+- `no_mangle` - on any item, do not apply the standard name mangling. Set the\n+  symbol for this item to its identifier.\n+- `simd` - on certain tuple structs, derive the arithmetic operators, which\n+  lower to the target's SIMD instructions, if any; the `simd` feature gate\n+  is necessary to use this attribute.\n+- `unsafe_destructor_blind_to_params` - on `Drop::drop` method, asserts that the\n+  destructor code (and all potential specializations of that code) will\n+  never attempt to read from nor write to any references with lifetimes\n+  that come in via generic parameters. This is a constraint we cannot\n+  currently express via the type system, and therefore we rely on the\n+  programmer to assert that it holds. Adding this to a Drop impl causes\n+  the associated destructor to be considered \"uninteresting\" by the\n+  Drop-Check rule, and thus it can help sidestep data ordering\n+  constraints that would otherwise be introduced by the Drop-Check\n+  rule. Such sidestepping of the constraints, if done incorrectly, can\n+  lead to undefined behavior (in the form of reading or writing to data\n+  outside of its dynamic extent), and thus this attribute has the word\n+  \"unsafe\" in its name. To use this, the\n+  `unsafe_destructor_blind_to_params` feature gate must be enabled.\n+- `doc` - Doc comments such as `/// foo` are equivalent to `#[doc = \"foo\"]`.\n+- `rustc_on_unimplemented` - Write a custom note to be shown along with the error\n+   when the trait is found to be unimplemented on a type.\n+   You may use format arguments like `{T}`, `{A}` to correspond to the\n+   types at the point of use corresponding to the type parameters of the\n+   trait of the same name. `{Self}` will be replaced with the type that is supposed\n+   to implement the trait but doesn't. To use this, the `on_unimplemented` feature gate\n+   must be enabled.\n+- `must_use` - on structs and enums, will warn if a value of this type isn't used or\n+   assigned to a variable. You may also include an optional message by using\n+   `#[must_use = \"message\"]` which will be given alongside the warning.\n+\n+### Conditional compilation\n+\n+Sometimes one wants to have different compiler outputs from the same code,\n+depending on build target, such as targeted operating system, or to enable\n+release builds.\n+\n+Configuration options are boolean (on or off) and are named either with a\n+single identifier (e.g. `foo`) or an identifier and a string (e.g. `foo = \"bar\"`;\n+the quotes are required and spaces around the `=` are unimportant). Note that\n+similarly-named options, such as `foo`, `foo=\"bar\"` and `foo=\"baz\"` may each be set\n+or unset independently.\n+\n+Configuration options are either provided by the compiler or passed in on the\n+command line using `--cfg` (e.g. `rustc main.rs --cfg foo --cfg 'bar=\"baz\"'`).\n+Rust code then checks for their presence using the `#[cfg(...)]` attribute:\n+\n+```\n+// The function is only included in the build when compiling for OSX\n+#[cfg(target_os = \"macos\")]\n+fn macos_only() {\n+  // ...\n+}\n+\n+// This function is only included when either foo or bar is defined\n+#[cfg(any(foo, bar))]\n+fn needs_foo_or_bar() {\n+  // ...\n+}\n+\n+// This function is only included when compiling for a unixish OS with a 32-bit\n+// architecture\n+#[cfg(all(unix, target_pointer_width = \"32\"))]\n+fn on_32bit_unix() {\n+  // ...\n+}\n+\n+// This function is only included when foo is not defined\n+#[cfg(not(foo))]\n+fn needs_not_foo() {\n+  // ...\n+}\n+```\n+\n+This illustrates some conditional compilation can be achieved using the\n+`#[cfg(...)]` attribute. `any`, `all` and `not` can be used to assemble\n+arbitrarily complex configurations through nesting.\n+\n+The following configurations must be defined by the implementation:\n+\n+* `target_arch = \"...\"` - Target CPU architecture, such as `\"x86\"`,\n+  `\"x86_64\"` `\"mips\"`, `\"powerpc\"`, `\"powerpc64\"`, `\"arm\"`, or\n+  `\"aarch64\"`. This value is closely related to the first element of\n+  the platform target triple, though it is not identical.\n+* `target_os = \"...\"` - Operating system of the target, examples\n+  include `\"windows\"`, `\"macos\"`, `\"ios\"`, `\"linux\"`, `\"android\"`,\n+  `\"freebsd\"`, `\"dragonfly\"`, `\"bitrig\"` , `\"openbsd\"` or\n+  `\"netbsd\"`. This value is closely related to the second and third\n+  element of the platform target triple, though it is not identical.\n+* `target_family = \"...\"` - Operating system family of the target, e. g.\n+  `\"unix\"` or `\"windows\"`. The value of this configuration option is defined\n+  as a configuration itself, like `unix` or `windows`.\n+* `unix` - See `target_family`.\n+* `windows` - See `target_family`.\n+* `target_env = \"..\"` - Further disambiguates the target platform with\n+  information about the ABI/libc. Presently this value is either\n+  `\"gnu\"`, `\"msvc\"`, `\"musl\"`, or the empty string. For historical\n+  reasons this value has only been defined as non-empty when needed\n+  for disambiguation. Thus on many GNU platforms this value will be\n+  empty. This value is closely related to the fourth element of the\n+  platform target triple, though it is not identical. For example,\n+  embedded ABIs such as `gnueabihf` will simply define `target_env` as\n+  `\"gnu\"`.\n+* `target_endian = \"...\"` - Endianness of the target CPU, either `\"little\"` or\n+  `\"big\"`.\n+* `target_pointer_width = \"...\"` - Target pointer width in bits. This is set\n+  to `\"32\"` for targets with 32-bit pointers, and likewise set to `\"64\"` for\n+  64-bit pointers.\n+* `target_has_atomic = \"...\"` - Set of integer sizes on which the target can perform\n+  atomic operations. Values are `\"8\"`, `\"16\"`, `\"32\"`, `\"64\"` and `\"ptr\"`.\n+* `target_vendor = \"...\"` - Vendor of the target, for example `apple`, `pc`, or\n+  simply `\"unknown\"`.\n+* `test` - Enabled when compiling the test harness (using the `--test` flag).\n+* `debug_assertions` - Enabled by default when compiling without optimizations.\n+  This can be used to enable extra debugging code in development but not in\n+  production.  For example, it controls the behavior of the standard library's\n+  `debug_assert!` macro.\n+\n+You can also set another attribute based on a `cfg` variable with `cfg_attr`:\n+\n+```rust,ignore\n+#[cfg_attr(a, b)]\n+```\n+\n+This is the same as `#[b]` if `a` is set by `cfg`, and nothing otherwise.\n+\n+Lastly, configuration options can be used in expressions by invoking the `cfg!`\n+macro: `cfg!(a)` evaluates to `true` if `a` is set, and `false` otherwise.\n+\n+### Lint check attributes\n+\n+A lint check names a potentially undesirable coding pattern, such as\n+unreachable code or omitted documentation, for the static entity to which the\n+attribute applies.\n+\n+For any lint check `C`:\n+\n+* `allow(C)` overrides the check for `C` so that violations will go\n+   unreported,\n+* `deny(C)` signals an error after encountering a violation of `C`,\n+* `forbid(C)` is the same as `deny(C)`, but also forbids changing the lint\n+   level afterwards,\n+* `warn(C)` warns about violations of `C` but continues compilation.\n+\n+The lint checks supported by the compiler can be found via `rustc -W help`,\n+along with their default settings.  [Compiler\n+plugins](../book/compiler-plugins.html#lint-plugins) can provide additional\n+lint checks.\n+\n+```{.ignore}\n+pub mod m1 {\n+    // Missing documentation is ignored here\n+    #[allow(missing_docs)]\n+    pub fn undocumented_one() -> i32 { 1 }\n+\n+    // Missing documentation signals a warning here\n+    #[warn(missing_docs)]\n+    pub fn undocumented_too() -> i32 { 2 }\n+\n+    // Missing documentation signals an error here\n+    #[deny(missing_docs)]\n+    pub fn undocumented_end() -> i32 { 3 }\n+}\n+```\n+\n+This example shows how one can use `allow` and `warn` to toggle a particular\n+check on and off:\n+\n+```{.ignore}\n+#[warn(missing_docs)]\n+pub mod m2{\n+    #[allow(missing_docs)]\n+    pub mod nested {\n+        // Missing documentation is ignored here\n+        pub fn undocumented_one() -> i32 { 1 }\n+\n+        // Missing documentation signals a warning here,\n+        // despite the allow above.\n+        #[warn(missing_docs)]\n+        pub fn undocumented_two() -> i32 { 2 }\n+    }\n+\n+    // Missing documentation signals a warning here\n+    pub fn undocumented_too() -> i32 { 3 }\n+}\n+```\n+\n+This example shows how one can use `forbid` to disallow uses of `allow` for\n+that lint check:\n+\n+```{.ignore}\n+#[forbid(missing_docs)]\n+pub mod m3 {\n+    // Attempting to toggle warning signals an error here\n+    #[allow(missing_docs)]\n+    /// Returns 2.\n+    pub fn undocumented_too() -> i32 { 2 }\n+}\n+```\n+\n+### Language items\n+\n+Some primitive Rust operations are defined in Rust code, rather than being\n+implemented directly in C or assembly language. The definitions of these\n+operations have to be easy for the compiler to find. The `lang` attribute\n+makes it possible to declare these operations. For example, the `str` module\n+in the Rust standard library defines the string equality function:\n+\n+```{.ignore}\n+#[lang = \"str_eq\"]\n+pub fn eq_slice(a: &str, b: &str) -> bool {\n+    // details elided\n+}\n+```\n+\n+The name `str_eq` has a special meaning to the Rust compiler, and the presence\n+of this definition means that it will use this definition when generating calls\n+to the string equality function.\n+\n+The set of language items is currently considered unstable. A complete\n+list of the built-in language items will be added in the future.\n+\n+### Inline attributes\n+\n+The inline attribute suggests that the compiler should place a copy of\n+the function or static in the caller, rather than generating code to\n+call the function or access the static where it is defined.\n+\n+The compiler automatically inlines functions based on internal heuristics.\n+Incorrectly inlining functions can actually make the program slower, so it\n+should be used with care.\n+\n+`#[inline]` and `#[inline(always)]` always cause the function to be serialized\n+into the crate metadata to allow cross-crate inlining.\n+\n+There are three different types of inline attributes:\n+\n+* `#[inline]` hints the compiler to perform an inline expansion.\n+* `#[inline(always)]` asks the compiler to always perform an inline expansion.\n+* `#[inline(never)]` asks the compiler to never perform an inline expansion.\n+\n+### `derive`\n+\n+The `derive` attribute allows certain traits to be automatically implemented\n+for data structures. For example, the following will create an `impl` for the\n+`PartialEq` and `Clone` traits for `Foo`, the type parameter `T` will be given\n+the `PartialEq` or `Clone` constraints for the appropriate `impl`:\n+\n+```\n+#[derive(PartialEq, Clone)]\n+struct Foo<T> {\n+    a: i32,\n+    b: T,\n+}\n+```\n+\n+The generated `impl` for `PartialEq` is equivalent to\n+\n+```\n+# struct Foo<T> { a: i32, b: T }\n+impl<T: PartialEq> PartialEq for Foo<T> {\n+    fn eq(&self, other: &Foo<T>) -> bool {\n+        self.a == other.a && self.b == other.b\n+    }\n+\n+    fn ne(&self, other: &Foo<T>) -> bool {\n+        self.a != other.a || self.b != other.b\n+    }\n+}\n+```\n+\n+You can implement `derive` for your own type through [procedural\n+macros](procedural-macros.html).\n+\n+### Compiler Features\n+\n+Certain aspects of Rust may be implemented in the compiler, but they're not\n+necessarily ready for every-day use. These features are often of \"prototype\n+quality\" or \"almost production ready\", but may not be stable enough to be\n+considered a full-fledged language feature.\n+\n+For this reason, Rust recognizes a special crate-level attribute of the form:\n+\n+```{.ignore}\n+#![feature(feature1, feature2, feature3)]\n+```\n+\n+This directive informs the compiler that the feature list: `feature1`,\n+`feature2`, and `feature3` should all be enabled. This is only recognized at a\n+crate-level, not at a module-level. Without this directive, all features are\n+considered off, and using the features will result in a compiler error.\n+\n+The currently implemented features of the reference compiler are:\n+\n+* `advanced_slice_patterns` - See the [match\n+                              expressions](expressions.html#match-expressions)\n+\t\t\t      section for discussion; the exact semantics of\n+slice patterns are subject to change, so some types are still unstable.\n+\n+* `slice_patterns` - OK, actually, slice patterns are just scary and\n+                     completely unstable.\n+\n+* `asm` - The `asm!` macro provides a means for inline assembly. This is often\n+          useful, but the exact syntax for this feature along with its\n+          semantics are likely to change, so this macro usage must be opted\n+          into.\n+\n+* `associated_consts` - Allows constants to be defined in `impl` and `trait`\n+                        blocks, so that they can be associated with a type or\n+                        trait in a similar manner to methods and associated\n+                        types.\n+\n+* `box_patterns` - Allows `box` patterns, the exact semantics of which\n+                   is subject to change.\n+\n+* `box_syntax` - Allows use of `box` expressions, the exact semantics of which\n+                 is subject to change.\n+\n+* `cfg_target_vendor` - Allows conditional compilation using the `target_vendor`\n+                        matcher which is subject to change.\n+\n+* `cfg_target_has_atomic` - Allows conditional compilation using the `target_has_atomic`\n+                            matcher which is subject to change.\n+\n+* `concat_idents` - Allows use of the `concat_idents` macro, which is in many\n+                    ways insufficient for concatenating identifiers, and may be\n+                    removed entirely for something more wholesome.\n+\n+* `custom_attribute` - Allows the usage of attributes unknown to the compiler\n+                       so that new attributes can be added in a backwards compatible\n+                       manner (RFC 572).\n+\n+* `custom_derive` - Allows the use of `#[derive(Foo,Bar)]` as sugar for\n+                    `#[derive_Foo] #[derive_Bar]`, which can be user-defined syntax\n+                    extensions.\n+\n+* `inclusive_range_syntax` - Allows use of the `a...b` and `...b` syntax for inclusive ranges.\n+\n+* `inclusive_range` - Allows use of the types that represent desugared inclusive ranges.\n+\n+* `intrinsics` - Allows use of the \"rust-intrinsics\" ABI. Compiler intrinsics\n+                 are inherently unstable and no promise about them is made.\n+\n+* `lang_items` - Allows use of the `#[lang]` attribute. Like `intrinsics`,\n+                 lang items are inherently unstable and no promise about them\n+                 is made.\n+\n+* `link_args` - This attribute is used to specify custom flags to the linker,\n+                but usage is strongly discouraged. The compiler's usage of the\n+                system linker is not guaranteed to continue in the future, and\n+                if the system linker is not used then specifying custom flags\n+                doesn't have much meaning.\n+\n+* `link_llvm_intrinsics` - Allows linking to LLVM intrinsics via\n+                           `#[link_name=\"llvm.*\"]`.\n+\n+* `linkage` - Allows use of the `linkage` attribute, which is not portable.\n+\n+* `log_syntax` - Allows use of the `log_syntax` macro attribute, which is a\n+                 nasty hack that will certainly be removed.\n+\n+* `main` - Allows use of the `#[main]` attribute, which changes the entry point\n+           into a Rust program. This capability is subject to change.\n+\n+* `macro_reexport` - Allows macros to be re-exported from one crate after being imported\n+                     from another. This feature was originally designed with the sole\n+                     use case of the Rust standard library in mind, and is subject to\n+                     change.\n+\n+* `non_ascii_idents` - The compiler supports the use of non-ascii identifiers,\n+                       but the implementation is a little rough around the\n+                       edges, so this can be seen as an experimental feature\n+                       for now until the specification of identifiers is fully\n+                       fleshed out.\n+\n+* `no_std` - Allows the `#![no_std]` crate attribute, which disables the implicit\n+             `extern crate std`. This typically requires use of the unstable APIs\n+             behind the libstd \"facade\", such as libcore and libcollections. It\n+             may also cause problems when using syntax extensions, including\n+             `#[derive]`.\n+\n+* `on_unimplemented` - Allows the `#[rustc_on_unimplemented]` attribute, which allows\n+                       trait definitions to add specialized notes to error messages\n+                       when an implementation was expected but not found.\n+\n+* `optin_builtin_traits` - Allows the definition of default and negative trait\n+                           implementations. Experimental.\n+\n+* `plugin` - Usage of [compiler plugins][plugin] for custom lints or syntax extensions.\n+             These depend on compiler internals and are subject to change.\n+\n+* `plugin_registrar` - Indicates that a crate provides [compiler plugins][plugin].\n+\n+* `quote` - Allows use of the `quote_*!` family of macros, which are\n+            implemented very poorly and will likely change significantly\n+            with a proper implementation.\n+\n+* `rustc_attrs` - Gates internal `#[rustc_*]` attributes which may be\n+                  for internal use only or have meaning added to them in the future.\n+\n+* `rustc_diagnostic_macros`- A mysterious feature, used in the implementation\n+                             of rustc, not meant for mortals.\n+\n+* `simd` - Allows use of the `#[simd]` attribute, which is overly simple and\n+           not the SIMD interface we want to expose in the long term.\n+\n+* `simd_ffi` - Allows use of SIMD vectors in signatures for foreign functions.\n+               The SIMD interface is subject to change.\n+\n+* `start` - Allows use of the `#[start]` attribute, which changes the entry point\n+            into a Rust program. This capability, especially the signature for the\n+            annotated function, is subject to change.\n+\n+* `thread_local` - The usage of the `#[thread_local]` attribute is experimental\n+                   and should be seen as unstable. This attribute is used to\n+                   declare a `static` as being unique per-thread leveraging\n+                   LLVM's implementation which works in concert with the kernel\n+                   loader and dynamic linker. This is not necessarily available\n+                   on all platforms, and usage of it is discouraged.\n+\n+* `trace_macros` - Allows use of the `trace_macros` macro, which is a nasty\n+                   hack that will certainly be removed.\n+\n+* `unboxed_closures` - Rust's new closure design, which is currently a work in\n+                       progress feature with many known bugs.\n+\n+* `allow_internal_unstable` - Allows `macro_rules!` macros to be tagged with the\n+                              `#[allow_internal_unstable]` attribute, designed\n+                              to allow `std` macros to call\n+                              `#[unstable]`/feature-gated functionality\n+                              internally without imposing on callers\n+                              (i.e. making them behave like function calls in\n+                              terms of encapsulation).\n+\n+* `default_type_parameter_fallback` - Allows type parameter defaults to\n+                                      influence type inference.\n+\n+* `stmt_expr_attributes` - Allows attributes on expressions.\n+\n+* `type_ascription` - Allows type ascription expressions `expr: Type`.\n+\n+* `abi_vectorcall` - Allows the usage of the vectorcall calling convention\n+                     (e.g. `extern \"vectorcall\" func fn_();`)\n+\n+* `abi_sysv64` - Allows the usage of the system V AMD64 calling convention\n+                 (e.g. `extern \"sysv64\" func fn_();`)\n+\n+If a feature is promoted to a language feature, then all existing programs will\n+start to receive compilation warnings about `#![feature]` directives which enabled\n+the new feature (because the directive is no longer necessary). However, if a\n+feature is decided to be removed from the language, errors will be issued (if\n+there isn't a parser error first). The directive in this case is no longer\n+necessary, and it's likely that existing code will break if the feature isn't\n+removed.\n+\n+If an unknown feature is found in a directive, it results in a compiler error.\n+An unknown feature is one which has never been recognized by the compiler."}, {"sha": "b617ee3d78fa717a2de6a0266ff5e10adc0f0121", "filename": "src/doc/reference/src/behavior-considered-undefined.md", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Fdoc%2Freference%2Fsrc%2Fbehavior-considered-undefined.md", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Fdoc%2Freference%2Fsrc%2Fbehavior-considered-undefined.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference%2Fsrc%2Fbehavior-considered-undefined.md?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -0,0 +1,35 @@\n+## Behavior considered undefined\n+\n+The following is a list of behavior which is forbidden in all Rust code,\n+including within `unsafe` blocks and `unsafe` functions. Type checking provides\n+the guarantee that these issues are never caused by safe code.\n+\n+* Data races\n+* Dereferencing a null/dangling raw pointer\n+* Reads of [undef](http://llvm.org/docs/LangRef.html#undefined-values)\n+  (uninitialized) memory\n+* Breaking the [pointer aliasing\n+  rules](http://llvm.org/docs/LangRef.html#pointer-aliasing-rules)\n+  with raw pointers (a subset of the rules used by C)\n+* `&mut T` and `&T` follow LLVM\u2019s scoped [noalias] model, except if the `&T`\n+  contains an `UnsafeCell<U>`. Unsafe code must not violate these aliasing\n+  guarantees.\n+* Mutating non-mutable data (that is, data reached through a shared reference or\n+  data owned by a `let` binding), unless that data is contained within an `UnsafeCell<U>`.\n+* Invoking undefined behavior via compiler intrinsics:\n+  * Indexing outside of the bounds of an object with `std::ptr::offset`\n+    (`offset` intrinsic), with\n+    the exception of one byte past the end which is permitted.\n+  * Using `std::ptr::copy_nonoverlapping_memory` (`memcpy32`/`memcpy64`\n+    intrinsics) on overlapping buffers\n+* Invalid values in primitive types, even in private fields/locals:\n+  * Dangling/null references or boxes\n+  * A value other than `false` (0) or `true` (1) in a `bool`\n+  * A discriminant in an `enum` not included in the type definition\n+  * A value in a `char` which is a surrogate or above `char::MAX`\n+  * Non-UTF-8 byte sequences in a `str`\n+* Unwinding into Rust from foreign code or unwinding from Rust into foreign\n+  code. Rust's failure system is not compatible with exception handling in\n+  other languages. Unwinding must be caught and handled at FFI boundaries.\n+\n+[noalias]: http://llvm.org/docs/LangRef.html#noalias"}, {"sha": "e16103372f552ac37eaac0a3159abfaaf316e401", "filename": "src/doc/reference/src/behavior-not-considered-unsafe.md", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Fdoc%2Freference%2Fsrc%2Fbehavior-not-considered-unsafe.md", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Fdoc%2Freference%2Fsrc%2Fbehavior-not-considered-unsafe.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference%2Fsrc%2Fbehavior-not-considered-unsafe.md?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -0,0 +1,15 @@\n+## Behavior not considered unsafe\n+\n+This is a list of behavior not considered *unsafe* in Rust terms, but that may\n+be undesired.\n+\n+* Deadlocks\n+* Leaks of memory and other resources\n+* Exiting without calling destructors\n+* Integer overflow\n+  - Overflow is considered \"unexpected\" behavior and is always user-error,\n+    unless the `wrapping` primitives are used. In non-optimized builds, the compiler\n+    will insert debug checks that panic on overflow, but in optimized builds overflow\n+    instead results in wrapped values. See [RFC 560] for the rationale and more details.\n+\n+[RFC 560]: https://github.com/rust-lang/rfcs/blob/master/text/0560-integer-overflow.md"}, {"sha": "784e19affd9da0d8de0fd7c8b158f76a4bda365c", "filename": "src/doc/reference/src/comments.md", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Fdoc%2Freference%2Fsrc%2Fcomments.md", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Fdoc%2Freference%2Fsrc%2Fcomments.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference%2Fsrc%2Fcomments.md?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -0,0 +1,20 @@\n+# Comments\n+\n+Comments in Rust code follow the general C++ style of line (`//`) and\n+block (`/* ... */`) comment forms. Nested block comments are supported.\n+\n+Line comments beginning with exactly _three_ slashes (`///`), and block\n+comments (`/** ... */`), are interpreted as a special syntax for `doc`\n+[attributes]. That is, they are equivalent to writing\n+`#[doc=\"...\"]` around the body of the comment, i.e., `/// Foo` turns into\n+`#[doc=\"Foo\"]`.\n+\n+Line comments beginning with `//!` and block comments `/*! ... */` are\n+doc comments that apply to the parent of the comment, rather than the item\n+that follows.  That is, they are equivalent to writing `#![doc=\"...\"]` around\n+the body of the comment. `//!` comments are usually used to document\n+modules that occupy a source file.\n+\n+Non-doc comments are interpreted as a form of whitespace.\n+\n+[attributes]: attributes.html"}, {"sha": "d41a8dc964095ebb3c270b3c701615f30e482577", "filename": "src/doc/reference/src/crates-and-source-files.md", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Fdoc%2Freference%2Fsrc%2Fcrates-and-source-files.md", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Fdoc%2Freference%2Fsrc%2Fcrates-and-source-files.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference%2Fsrc%2Fcrates-and-source-files.md?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -0,0 +1,73 @@\n+# Crates and source files\n+\n+Although Rust, like any other language, can be implemented by an interpreter as\n+well as a compiler, the only existing implementation is a compiler,\n+and the language has\n+always been designed to be compiled. For these reasons, this section assumes a\n+compiler.\n+\n+Rust's semantics obey a *phase distinction* between compile-time and\n+run-time.[^phase-distinction] Semantic rules that have a *static\n+interpretation* govern the success or failure of compilation, while\n+semantic rules\n+that have a *dynamic interpretation* govern the behavior of the program at\n+run-time.\n+\n+The compilation model centers on artifacts called _crates_. Each compilation\n+processes a single crate in source form, and if successful, produces a single\n+crate in binary form: either an executable or some sort of\n+library.[^cratesourcefile]\n+\n+A _crate_ is a unit of compilation and linking, as well as versioning,\n+distribution and runtime loading. A crate contains a _tree_ of nested\n+[module] scopes. The top level of this tree is a module that is\n+anonymous (from the point of view of paths within the module) and any item\n+within a crate has a canonical [module path] denoting its location\n+within the crate's module tree.\n+\n+The Rust compiler is always invoked with a single source file as input, and\n+always produces a single output crate. The processing of that source file may\n+result in other source files being loaded as modules. Source files have the\n+extension `.rs`.\n+\n+A Rust source file describes a module, the name and location of which &mdash;\n+in the module tree of the current crate &mdash; are defined from outside the\n+source file: either by an explicit `mod_item` in a referencing source file, or\n+by the name of the crate itself. Every source file is a module, but not every\n+module needs its own source file: [module definitions][module] can be nested\n+within one file.\n+\n+Each source file contains a sequence of zero or more `item` definitions, and\n+may optionally begin with any number of [attributes]\n+that apply to the containing module, most of which influence the behavior of\n+the compiler. The anonymous crate module can have additional attributes that\n+apply to the crate as a whole.\n+\n+```rust,no_run\n+// Specify the crate name.\n+#![crate_name = \"projx\"]\n+\n+// Specify the type of output artifact.\n+#![crate_type = \"lib\"]\n+\n+// Turn on a warning.\n+// This can be done in any module, not just the anonymous crate module.\n+#![warn(non_camel_case_types)]\n+```\n+\n+A crate that contains a `main` function can be compiled to an executable. If a\n+`main` function is present, its return type must be `()`\n+(\"[unit]\") and it must take no arguments.\n+\n+[^phase-distinction]: This distinction would also exist in an interpreter.\n+    Static checks like syntactic analysis, type checking, and lints should\n+    happen before the program is executed regardless of when it is executed.\n+\n+[^cratesourcefile]: A crate is somewhat analogous to an *assembly* in the\n+    ECMA-335 CLI model, a *library* in the SML/NJ Compilation Manager, a *unit*\n+    in the Owens and Flatt module system, or a *configuration* in Mesa.\n+\n+[module]: items.html#modules\n+[module path]: paths.html\n+[attributes]: items-and-attributes.html\n+[unit]: types.html#tuple-types\n\\ No newline at end of file"}, {"sha": "c9c0496dac61c399e1e0b21a35818305a0a6a649", "filename": "src/doc/reference/src/expressions.md", "status": "added", "additions": 863, "deletions": 0, "changes": 863, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Fdoc%2Freference%2Fsrc%2Fexpressions.md", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Fdoc%2Freference%2Fsrc%2Fexpressions.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference%2Fsrc%2Fexpressions.md?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -0,0 +1,863 @@\n+# Expressions\n+\n+An expression may have two roles: it always produces a *value*, and it may have\n+*effects* (otherwise known as \"side effects\"). An expression *evaluates to* a\n+value, and has effects during *evaluation*. Many expressions contain\n+sub-expressions (operands). The meaning of each kind of expression dictates\n+several things:\n+\n+* Whether or not to evaluate the sub-expressions when evaluating the expression\n+* The order in which to evaluate the sub-expressions\n+* How to combine the sub-expressions' values to obtain the value of the expression\n+\n+In this way, the structure of expressions dictates the structure of execution.\n+Blocks are just another kind of expression, so blocks, statements, expressions,\n+and blocks again can recursively nest inside each other to an arbitrary depth.\n+\n+### Lvalues, rvalues and temporaries\n+\n+Expressions are divided into two main categories: _lvalues_ and _rvalues_.\n+Likewise within each expression, sub-expressions may occur in _lvalue context_\n+or _rvalue context_. The evaluation of an expression depends both on its own\n+category and the context it occurs within.\n+\n+An lvalue is an expression that represents a memory location. These expressions\n+are [paths](#path-expressions) (which refer to local variables, function and\n+method arguments, or static variables), dereferences (`*expr`), [indexing\n+expressions](#index-expressions) (`expr[expr]`), and [field\n+references](#field-expressions) (`expr.f`). All other expressions are rvalues.\n+\n+The left operand of an [assignment](#assignment-expressions) or\n+[compound-assignment](#compound-assignment-expressions) expression is\n+an lvalue context, as is the single operand of a unary\n+[borrow](#unary-operator-expressions). The discriminant or subject of\n+a [match expression](#match-expressions) may be an lvalue context, if\n+ref bindings are made, but is otherwise an rvalue context. All other\n+expression contexts are rvalue contexts.\n+\n+When an lvalue is evaluated in an _lvalue context_, it denotes a memory\n+location; when evaluated in an _rvalue context_, it denotes the value held _in_\n+that memory location.\n+\n+#### Temporary lifetimes\n+\n+When an rvalue is used in an lvalue context, a temporary un-named\n+lvalue is created and used instead. The lifetime of temporary values\n+is typically the innermost enclosing statement; the tail expression of\n+a block is considered part of the statement that encloses the block.\n+\n+When a temporary rvalue is being created that is assigned into a `let`\n+declaration, however, the temporary is created with the lifetime of\n+the enclosing block instead, as using the enclosing statement (the\n+`let` declaration) would be a guaranteed error (since a pointer to the\n+temporary would be stored into a variable, but the temporary would be\n+freed before the variable could be used). The compiler uses simple\n+syntactic rules to decide which values are being assigned into a `let`\n+binding, and therefore deserve a longer temporary lifetime.\n+\n+Here are some examples:\n+\n+- `let x = foo(&temp())`. The expression `temp()` is an rvalue. As it\n+  is being borrowed, a temporary is created which will be freed after\n+  the innermost enclosing statement (the `let` declaration, in this case).\n+- `let x = temp().foo()`. This is the same as the previous example,\n+  except that the value of `temp()` is being borrowed via autoref on a\n+  method-call. Here we are assuming that `foo()` is an `&self` method\n+  defined in some trait, say `Foo`. In other words, the expression\n+  `temp().foo()` is equivalent to `Foo::foo(&temp())`.\n+- `let x = &temp()`. Here, the same temporary is being assigned into\n+  `x`, rather than being passed as a parameter, and hence the\n+  temporary's lifetime is considered to be the enclosing block.\n+- `let x = SomeStruct { foo: &temp() }`. As in the previous case, the\n+  temporary is assigned into a struct which is then assigned into a\n+  binding, and hence it is given the lifetime of the enclosing block.\n+- `let x = [ &temp() ]`. As in the previous case, the\n+  temporary is assigned into an array which is then assigned into a\n+  binding, and hence it is given the lifetime of the enclosing block.\n+- `let ref x = temp()`. In this case, the temporary is created using a ref binding,\n+  but the result is the same: the lifetime is extended to the enclosing block.\n+\n+### Moved and copied types\n+\n+When a [local variable](variables.html) is used as an\n+[rvalue](expressions.html#lvalues-rvalues-and-temporaries), the variable will\n+be copied if its type implements `Copy`. All others are moved.\n+\n+## Literal expressions\n+\n+A _literal expression_ consists of one of the [literal](tokens.html#literals) forms\n+described earlier. It directly describes a number, character, string, boolean\n+value, or the unit value.\n+\n+```text\n+();        // unit type\n+\"hello\";   // string type\n+'5';       // character type\n+5;         // integer type\n+```\n+\n+## Path expressions\n+\n+A [path](paths.html) used as an expression context denotes either a local\n+variable or an item. Path expressions are\n+[lvalues](expressions.html#lvalues-rvalues-and-temporaries).\n+\n+## Tuple expressions\n+\n+Tuples are written by enclosing zero or more comma-separated expressions in\n+parentheses. They are used to create [tuple-typed](types.html#tuple-types)\n+values.\n+\n+```{.tuple}\n+(0.0, 4.5);\n+(\"a\", 4usize, true);\n+```\n+\n+You can disambiguate a single-element tuple from a value in parentheses with a\n+comma:\n+\n+```\n+(0,); // single-element tuple\n+(0); // zero in parentheses\n+```\n+\n+## Struct expressions\n+\n+There are several forms of struct expressions. A _struct expression_\n+consists of the [path](paths.html) of a [struct item](items.html#structs), followed\n+by a brace-enclosed list of zero or more comma-separated name-value pairs,\n+providing the field values of a new instance of the struct. A field name can be\n+any identifier, and is separated from its value expression by a colon.  The\n+location denoted by a struct field is mutable if and only if the enclosing\n+struct is mutable.\n+\n+A _tuple struct expression_ consists of the [path](paths.html) of a [struct\n+item](items.html#structs), followed by a parenthesized list of one or more\n+comma-separated expressions (in other words, the path of a struct item followed\n+by a tuple expression). The struct item must be a tuple struct item.\n+\n+A _unit-like struct expression_ consists only of the [path](paths.html) of a\n+[struct item](items.html#structs).\n+\n+The following are examples of struct expressions:\n+\n+```\n+# struct Point { x: f64, y: f64 }\n+# struct NothingInMe { }\n+# struct TuplePoint(f64, f64);\n+# mod game { pub struct User<'a> { pub name: &'a str, pub age: u32, pub score: usize } }\n+# struct Cookie; fn some_fn<T>(t: T) {}\n+Point {x: 10.0, y: 20.0};\n+NothingInMe {};\n+TuplePoint(10.0, 20.0);\n+let u = game::User {name: \"Joe\", age: 35, score: 100_000};\n+some_fn::<Cookie>(Cookie);\n+```\n+\n+A struct expression forms a new value of the named struct type. Note\n+that for a given *unit-like* struct type, this will always be the same\n+value.\n+\n+A struct expression can terminate with the syntax `..` followed by an\n+expression to denote a functional update. The expression following `..` (the\n+base) must have the same struct type as the new struct type being formed.\n+The entire expression denotes the result of constructing a new struct (with\n+the same type as the base expression) with the given values for the fields that\n+were explicitly specified and the values in the base expression for all other\n+fields.\n+\n+```\n+# struct Point3d { x: i32, y: i32, z: i32 }\n+let base = Point3d {x: 1, y: 2, z: 3};\n+Point3d {y: 0, z: 10, .. base};\n+```\n+\n+#### Struct field init shorthand\n+\n+When initializing a data structure (struct, enum, union) with named fields,\n+it is allowed to write `fieldname` as a shorthand for `fieldname: fieldname`.\n+This allows a compact syntax with less duplication.\n+\n+Example:\n+\n+```\n+# struct Point3d { x: i32, y: i32, z: i32 }\n+# let x = 0;\n+# let y_value = 0;\n+# let z = 0;\n+Point3d { x: x, y: y_value, z: z };\n+Point3d { x, y: y_value, z };\n+```\n+\n+## Block expressions\n+\n+A _block expression_ is similar to a module in terms of the declarations that\n+are possible. Each block conceptually introduces a new namespace scope. Use\n+items can bring new names into scopes and declared items are in scope for only\n+the block itself.\n+\n+A block will execute each statement sequentially, and then execute the\n+expression (if given). If the block ends in a statement, its value is `()`:\n+\n+```\n+let x: () = { println!(\"Hello.\"); };\n+```\n+\n+If it ends in an expression, its value and type are that of the expression:\n+\n+```\n+let x: i32 = { println!(\"Hello.\"); 5 };\n+\n+assert_eq!(5, x);\n+```\n+\n+## Method-call expressions\n+\n+A _method call_ consists of an expression followed by a single dot, an\n+identifier, and a parenthesized expression-list. Method calls are resolved to\n+methods on specific traits, either statically dispatching to a method if the\n+exact `self`-type of the left-hand-side is known, or dynamically dispatching if\n+the left-hand-side expression is an indirect [trait\n+object](types.html#trait-objects).\n+\n+## Field expressions\n+\n+A _field expression_ consists of an expression followed by a single dot and an\n+identifier, when not immediately followed by a parenthesized expression-list\n+(the latter is a [method call expression](#method-call-expressions)). A field\n+expression denotes a field of a [struct](types.html#struct-types).\n+\n+```{.ignore .field}\n+mystruct.myfield;\n+foo().x;\n+(Struct {a: 10, b: 20}).a;\n+```\n+\n+A field access is an [lvalue](expressions.html#lvalues-rvalues-and-temporaries)\n+referring to the value of that field. When the type providing the field\n+inherits mutability, it can be [assigned](#assignment-expressions) to.\n+\n+Also, if the type of the expression to the left of the dot is a\n+pointer, it is automatically dereferenced as many times as necessary\n+to make the field access possible. In cases of ambiguity, we prefer\n+fewer autoderefs to more.\n+\n+## Array expressions\n+\n+An [array](types.html#array-and-slice-types) _expression_ is written by\n+enclosing zero or more comma-separated expressions of uniform type in square\n+brackets.\n+\n+In the `[expr ';' expr]` form, the expression after the `';'` must be a\n+constant expression that can be evaluated at compile time, such as a\n+[literal](tokens.html#literals) or a [static item](items.html#static-items).\n+\n+```\n+[1, 2, 3, 4];\n+[\"a\", \"b\", \"c\", \"d\"];\n+[0; 128];              // array with 128 zeros\n+[0u8, 0u8, 0u8, 0u8];\n+```\n+\n+## Index expressions\n+\n+[Array](types.html#array-and-slice-types)-typed expressions can be indexed by\n+writing a square-bracket-enclosed expression (the index) after them. When the\n+array is mutable, the resulting\n+[lvalue](expressions.html#lvalues-rvalues-and-temporaries) can be assigned to.\n+\n+Indices are zero-based, and may be of any integral type. Vector access is\n+bounds-checked at compile-time for constant arrays being accessed with a\n+constant index value.  Otherwise a check will be performed at run-time that\n+will put the thread in a _panicked state_ if it fails.\n+\n+```{should-fail}\n+([1, 2, 3, 4])[0];\n+\n+let x = ([\"a\", \"b\"])[10]; // compiler error: const index-expr is out of bounds\n+\n+let n = 10;\n+let y = ([\"a\", \"b\"])[n]; // panics\n+\n+let arr = [\"a\", \"b\"];\n+arr[10]; // panics\n+```\n+\n+Also, if the type of the expression to the left of the brackets is a\n+pointer, it is automatically dereferenced as many times as necessary\n+to make the indexing possible. In cases of ambiguity, we prefer fewer\n+autoderefs to more.\n+\n+## Range expressions\n+\n+The `..` operator will construct an object of one of the `std::ops::Range` variants.\n+\n+```\n+1..2;   // std::ops::Range\n+3..;    // std::ops::RangeFrom\n+..4;    // std::ops::RangeTo\n+..;     // std::ops::RangeFull\n+```\n+\n+The following expressions are equivalent.\n+\n+```\n+let x = std::ops::Range {start: 0, end: 10};\n+let y = 0..10;\n+\n+assert_eq!(x, y);\n+```\n+\n+Similarly, the `...` operator will construct an object of one of the\n+`std::ops::RangeInclusive` variants.\n+\n+```\n+# #![feature(inclusive_range_syntax)]\n+1...2;   // std::ops::RangeInclusive\n+...4;    // std::ops::RangeToInclusive\n+```\n+\n+The following expressions are equivalent.\n+\n+```\n+# #![feature(inclusive_range_syntax, inclusive_range)]\n+let x = std::ops::RangeInclusive::NonEmpty {start: 0, end: 10};\n+let y = 0...10;\n+\n+assert_eq!(x, y);\n+```\n+\n+## Unary operator expressions\n+\n+Rust defines the following unary operators. With the exception of `?`, they are\n+all written as prefix operators, before the expression they apply to.\n+\n+* `-`\n+  : Negation. Signed integer types and floating-point types support negation. It\n+    is an error to apply negation to unsigned types; for example, the compiler\n+    rejects `-1u32`.\n+* `*`\n+  : Dereference. When applied to a [pointer](types.html#pointer-types) it\n+    denotes the pointed-to location. For pointers to mutable locations, the\n+    resulting [lvalue](expressions.html#lvalues-rvalues-and-temporaries) can be\n+    assigned to.  On non-pointer types, it calls the `deref` method of the\n+    `std::ops::Deref` trait, or the `deref_mut` method of the\n+    `std::ops::DerefMut` trait (if implemented by the type and required for an\n+    outer expression that will or could mutate the dereference), and produces\n+    the result of dereferencing the `&` or `&mut` borrowed pointer returned\n+    from the overload method.\n+* `!`\n+  : Logical negation. On the boolean type, this flips between `true` and\n+    `false`. On integer types, this inverts the individual bits in the\n+    two's complement representation of the value.\n+* `&` and `&mut`\n+  : Borrowing. When applied to an lvalue, these operators produce a\n+    reference (pointer) to the lvalue. The lvalue is also placed into\n+    a borrowed state for the duration of the reference. For a shared\n+    borrow (`&`), this implies that the lvalue may not be mutated, but\n+    it may be read or shared again. For a mutable borrow (`&mut`), the\n+    lvalue may not be accessed in any way until the borrow expires.\n+    If the `&` or `&mut` operators are applied to an rvalue, a\n+    temporary value is created; the lifetime of this temporary value\n+    is defined by [syntactic rules](#temporary-lifetimes).\n+* `?`\n+  : Propagating errors if applied to `Err(_)` and unwrapping if\n+    applied to `Ok(_)`. Only works on the `Result<T, E>` type,\n+    and written in postfix notation.\n+\n+## Binary operator expressions\n+\n+Binary operators expressions are given in terms of [operator\n+precedence](#operator-precedence).\n+\n+### Arithmetic operators\n+\n+Binary arithmetic expressions are syntactic sugar for calls to built-in traits,\n+defined in the `std::ops` module of the `std` library. This means that\n+arithmetic operators can be overridden for user-defined types. The default\n+meaning of the operators on standard types is given here.\n+\n+* `+`\n+  : Addition and array/string concatenation.\n+    Calls the `add` method on the `std::ops::Add` trait.\n+* `-`\n+  : Subtraction.\n+    Calls the `sub` method on the `std::ops::Sub` trait.\n+* `*`\n+  : Multiplication.\n+    Calls the `mul` method on the `std::ops::Mul` trait.\n+* `/`\n+  : Quotient.\n+    Calls the `div` method on the `std::ops::Div` trait.\n+* `%`\n+  : Remainder.\n+    Calls the `rem` method on the `std::ops::Rem` trait.\n+\n+### Bitwise operators\n+\n+Like the [arithmetic operators](#arithmetic-operators), bitwise operators are\n+syntactic sugar for calls to methods of built-in traits. This means that\n+bitwise operators can be overridden for user-defined types. The default\n+meaning of the operators on standard types is given here. Bitwise `&`, `|` and\n+`^` applied to boolean arguments are equivalent to logical `&&`, `||` and `!=`\n+evaluated in non-lazy fashion.\n+\n+* `&`\n+  : Bitwise AND.\n+    Calls the `bitand` method of the `std::ops::BitAnd` trait.\n+* `|`\n+  : Bitwise inclusive OR.\n+    Calls the `bitor` method of the `std::ops::BitOr` trait.\n+* `^`\n+  : Bitwise exclusive OR.\n+    Calls the `bitxor` method of the `std::ops::BitXor` trait.\n+* `<<`\n+  : Left shift.\n+    Calls the `shl` method of the `std::ops::Shl` trait.\n+* `>>`\n+  : Right shift (arithmetic).\n+    Calls the `shr` method of the `std::ops::Shr` trait.\n+\n+### Lazy boolean operators\n+\n+The operators `||` and `&&` may be applied to operands of boolean type. The\n+`||` operator denotes logical 'or', and the `&&` operator denotes logical\n+'and'. They differ from `|` and `&` in that the right-hand operand is only\n+evaluated when the left-hand operand does not already determine the result of\n+the expression. That is, `||` only evaluates its right-hand operand when the\n+left-hand operand evaluates to `false`, and `&&` only when it evaluates to\n+`true`.\n+\n+### Comparison operators\n+\n+Comparison operators are, like the [arithmetic\n+operators](#arithmetic-operators), and [bitwise operators](#bitwise-operators),\n+syntactic sugar for calls to built-in traits. This means that comparison\n+operators can be overridden for user-defined types. The default meaning of the\n+operators on standard types is given here.\n+\n+* `==`\n+  : Equal to.\n+    Calls the `eq` method on the `std::cmp::PartialEq` trait.\n+* `!=`\n+  : Unequal to.\n+    Calls the `ne` method on the `std::cmp::PartialEq` trait.\n+* `<`\n+  : Less than.\n+    Calls the `lt` method on the `std::cmp::PartialOrd` trait.\n+* `>`\n+  : Greater than.\n+    Calls the `gt` method on the `std::cmp::PartialOrd` trait.\n+* `<=`\n+  : Less than or equal.\n+    Calls the `le` method on the `std::cmp::PartialOrd` trait.\n+* `>=`\n+  : Greater than or equal.\n+    Calls the `ge` method on the `std::cmp::PartialOrd` trait.\n+\n+### Type cast expressions\n+\n+A type cast expression is denoted with the binary operator `as`.\n+\n+Executing an `as` expression casts the value on the left-hand side to the type\n+on the right-hand side.\n+\n+An example of an `as` expression:\n+\n+```\n+# fn sum(values: &[f64]) -> f64 { 0.0 }\n+# fn len(values: &[f64]) -> i32 { 0 }\n+\n+fn average(values: &[f64]) -> f64 {\n+    let sum: f64 = sum(values);\n+    let size: f64 = len(values) as f64;\n+    sum / size\n+}\n+```\n+\n+Some of the conversions which can be done through the `as` operator\n+can also be done implicitly at various points in the program, such as\n+argument passing and assignment to a `let` binding with an explicit\n+type. Implicit conversions are limited to \"harmless\" conversions that\n+do not lose information and which have minimal or no risk of\n+surprising side-effects on the dynamic execution semantics.\n+\n+### Assignment expressions\n+\n+An _assignment expression_ consists of an\n+[lvalue](expressions.html#lvalues-rvalues-and-temporaries) expression followed\n+by an equals sign (`=`) and an\n+[rvalue](expressions.html#lvalues-rvalues-and-temporaries) expression.\n+\n+Evaluating an assignment expression [either copies or\n+moves](#moved-and-copied-types) its right-hand operand to its left-hand\n+operand.\n+\n+```\n+# let mut x = 0;\n+# let y = 0;\n+x = y;\n+```\n+\n+### Compound assignment expressions\n+\n+The `+`, `-`, `*`, `/`, `%`, `&`, `|`, `^`, `<<`, and `>>` operators may be\n+composed with the `=` operator. The expression `lval OP= val` is equivalent to\n+`lval = lval OP val`. For example, `x = x + 1` may be written as `x += 1`.\n+\n+Any such expression always has the [`unit`](types.html#tuple-types) type.\n+\n+### Operator precedence\n+\n+The precedence of Rust binary operators is ordered as follows, going from\n+strong to weak:\n+\n+```{.text .precedence}\n+as :\n+* / %\n++ -\n+<< >>\n+&\n+^\n+|\n+== != < > <= >=\n+&&\n+||\n+.. ...\n+<-\n+=\n+```\n+\n+Operators at the same precedence level are evaluated left-to-right. [Unary\n+operators](#unary-operator-expressions) have the same precedence level and are\n+stronger than any of the binary operators.\n+\n+## Grouped expressions\n+\n+An expression enclosed in parentheses evaluates to the result of the enclosed\n+expression. Parentheses can be used to explicitly specify evaluation order\n+within an expression.\n+\n+An example of a parenthesized expression:\n+\n+```\n+let x: i32 = (2 + 3) * 4;\n+```\n+\n+\n+## Call expressions\n+\n+A _call expression_ invokes a function, providing zero or more input variables\n+and an optional location to move the function's output into. If the function\n+eventually returns, then the expression completes.\n+\n+Some examples of call expressions:\n+\n+```\n+# fn add(x: i32, y: i32) -> i32 { 0 }\n+\n+let x: i32 = add(1i32, 2i32);\n+let pi: Result<f32, _> = \"3.14\".parse();\n+```\n+\n+## Lambda expressions\n+\n+A _lambda expression_ (sometimes called an \"anonymous function expression\")\n+defines a function and denotes it as a value, in a single expression. A lambda\n+expression is a pipe-symbol-delimited (`|`) list of identifiers followed by an\n+expression.\n+\n+A lambda expression denotes a function that maps a list of parameters\n+(`ident_list`) onto the expression that follows the `ident_list`. The\n+identifiers in the `ident_list` are the parameters to the function. These\n+parameters' types need not be specified, as the compiler infers them from\n+context.\n+\n+Lambda expressions are most useful when passing functions as arguments to other\n+functions, as an abbreviation for defining and capturing a separate function.\n+\n+Significantly, lambda expressions _capture their environment_, which regular\n+[function definitions](items.html#functions) do not. The exact type of capture\n+depends on the [function type](types.html#function-types) inferred for the\n+lambda expression. In the simplest and least-expensive form (analogous to a\n+```|| { }``` expression), the lambda expression captures its environment by\n+reference, effectively borrowing pointers to all outer variables mentioned\n+inside the function.  Alternately, the compiler may infer that a lambda\n+expression should copy or move values (depending on their type) from the\n+environment into the lambda expression's captured environment. A lambda can be\n+forced to capture its environment by moving values by prefixing it with the\n+`move` keyword.\n+\n+In this example, we define a function `ten_times` that takes a higher-order\n+function argument, and we then call it with a lambda expression as an argument,\n+followed by a lambda expression that moves values from its environment.\n+\n+```\n+fn ten_times<F>(f: F) where F: Fn(i32) {\n+    for index in 0..10 {\n+        f(index);\n+    }\n+}\n+\n+ten_times(|j| println!(\"hello, {}\", j));\n+\n+let word = \"konnichiwa\".to_owned();\n+ten_times(move |j| println!(\"{}, {}\", word, j));\n+```\n+\n+## Infinite loops\n+\n+A `loop` expression denotes an infinite loop.\n+\n+A `loop` expression may optionally have a _label_. The label is written as\n+a lifetime preceding the loop expression, as in `'foo: loop{ }`. If a\n+label is present, then labeled `break` and `continue` expressions nested\n+within this loop may exit out of this loop or return control to its head.\n+See [break expressions](#break-expressions) and [continue\n+expressions](#continue-expressions).\n+\n+## `break` expressions\n+\n+A `break` expression has an optional _label_. If the label is absent, then\n+executing a `break` expression immediately terminates the innermost loop\n+enclosing it. It is only permitted in the body of a loop. If the label is\n+present, then `break 'foo` terminates the loop with label `'foo`, which need not\n+be the innermost label enclosing the `break` expression, but must enclose it.\n+\n+## `continue` expressions\n+\n+A `continue` expression has an optional _label_. If the label is absent, then\n+executing a `continue` expression immediately terminates the current iteration\n+of the innermost loop enclosing it, returning control to the loop *head*. In\n+the case of a `while` loop, the head is the conditional expression controlling\n+the loop. In the case of a `for` loop, the head is the call-expression\n+controlling the loop. If the label is present, then `continue 'foo` returns\n+control to the head of the loop with label `'foo`, which need not be the\n+innermost label enclosing the `continue` expression, but must enclose it.\n+\n+A `continue` expression is only permitted in the body of a loop.\n+\n+## `while` loops\n+\n+A `while` loop begins by evaluating the boolean loop conditional expression.\n+If the loop conditional expression evaluates to `true`, the loop body block\n+executes and control returns to the loop conditional expression. If the loop\n+conditional expression evaluates to `false`, the `while` expression completes.\n+\n+An example:\n+\n+```\n+let mut i = 0;\n+\n+while i < 10 {\n+    println!(\"hello\");\n+    i = i + 1;\n+}\n+```\n+\n+Like `loop` expressions, `while` loops can be controlled with `break` or\n+`continue`, and may optionally have a _label_. See [infinite\n+loops](#infinite-loops), [break expressions](#break-expressions), and\n+[continue expressions](#continue-expressions) for more information.\n+\n+## `for` expressions\n+\n+A `for` expression is a syntactic construct for looping over elements provided\n+by an implementation of `std::iter::IntoIterator`.\n+\n+An example of a `for` loop over the contents of an array:\n+\n+```\n+# type Foo = i32;\n+# fn bar(f: &Foo) { }\n+# let a = 0;\n+# let b = 0;\n+# let c = 0;\n+\n+let v: &[Foo] = &[a, b, c];\n+\n+for e in v {\n+    bar(e);\n+}\n+```\n+\n+An example of a for loop over a series of integers:\n+\n+```\n+# fn bar(b:usize) { }\n+for i in 0..256 {\n+    bar(i);\n+}\n+```\n+\n+Like `loop` expressions, `for` loops can be controlled with `break` or\n+`continue`, and may optionally have a _label_. See [infinite\n+loops](#infinite-loops), [break expressions](#break-expressions), and\n+[continue expressions](#continue-expressions) for more information.\n+\n+## `if` expressions\n+\n+An `if` expression is a conditional branch in program control. The form of an\n+`if` expression is a condition expression, followed by a consequent block, any\n+number of `else if` conditions and blocks, and an optional trailing `else`\n+block. The condition expressions must have type `bool`. If a condition\n+expression evaluates to `true`, the consequent block is executed and any\n+subsequent `else if` or `else` block is skipped. If a condition expression\n+evaluates to `false`, the consequent block is skipped and any subsequent `else\n+if` condition is evaluated. If all `if` and `else if` conditions evaluate to\n+`false` then any `else` block is executed.\n+\n+## `match` expressions\n+\n+A `match` expression branches on a *pattern*. The exact form of matching that\n+occurs depends on the pattern. Patterns consist of some combination of\n+literals, destructured arrays or enum constructors, structs and tuples,\n+variable binding specifications, wildcards (`..`), and placeholders (`_`). A\n+`match` expression has a *head expression*, which is the value to compare to\n+the patterns. The type of the patterns must equal the type of the head\n+expression.\n+\n+In a pattern whose head expression has an `enum` type, a placeholder (`_`)\n+stands for a *single* data field, whereas a wildcard `..` stands for *all* the\n+fields of a particular variant.\n+\n+A `match` behaves differently depending on whether or not the head expression\n+is an [lvalue or an rvalue](expressions.html#lvalues-rvalues-and-temporaries).\n+If the head expression is an rvalue, it is first evaluated into a temporary\n+location, and the resulting value is sequentially compared to the patterns in\n+the arms until a match is found. The first arm with a matching pattern is\n+chosen as the branch target of the `match`, any variables bound by the pattern\n+are assigned to local variables in the arm's block, and control enters the\n+block.\n+\n+When the head expression is an lvalue, the match does not allocate a temporary\n+location (however, a by-value binding may copy or move from the lvalue). When\n+possible, it is preferable to match on lvalues, as the lifetime of these\n+matches inherits the lifetime of the lvalue, rather than being restricted to\n+the inside of the match.\n+\n+An example of a `match` expression:\n+\n+```\n+let x = 1;\n+\n+match x {\n+    1 => println!(\"one\"),\n+    2 => println!(\"two\"),\n+    3 => println!(\"three\"),\n+    4 => println!(\"four\"),\n+    5 => println!(\"five\"),\n+    _ => println!(\"something else\"),\n+}\n+```\n+\n+Patterns that bind variables default to binding to a copy or move of the\n+matched value (depending on the matched value's type). This can be changed to\n+bind to a reference by using the `ref` keyword, or to a mutable reference using\n+`ref mut`.\n+\n+Subpatterns can also be bound to variables by the use of the syntax `variable @\n+subpattern`. For example:\n+\n+```\n+let x = 1;\n+\n+match x {\n+    e @ 1 ... 5 => println!(\"got a range element {}\", e),\n+    _ => println!(\"anything\"),\n+}\n+```\n+\n+Patterns can also dereference pointers by using the `&`, `&mut` and `box`\n+symbols, as appropriate. For example, these two matches on `x: &i32` are\n+equivalent:\n+\n+```\n+# let x = &3;\n+let y = match *x { 0 => \"zero\", _ => \"some\" };\n+let z = match x { &0 => \"zero\", _ => \"some\" };\n+\n+assert_eq!(y, z);\n+```\n+\n+Multiple match patterns may be joined with the `|` operator. A range of values\n+may be specified with `...`. For example:\n+\n+```\n+# let x = 2;\n+\n+let message = match x {\n+    0 | 1  => \"not many\",\n+    2 ... 9 => \"a few\",\n+    _      => \"lots\"\n+};\n+```\n+\n+Range patterns only work on scalar types (like integers and characters; not\n+like arrays and structs, which have sub-components). A range pattern may not\n+be a sub-range of another range pattern inside the same `match`.\n+\n+Finally, match patterns can accept *pattern guards* to further refine the\n+criteria for matching a case. Pattern guards appear after the pattern and\n+consist of a bool-typed expression following the `if` keyword. A pattern guard\n+may refer to the variables bound within the pattern they follow.\n+\n+```\n+# let maybe_digit = Some(0);\n+# fn process_digit(i: i32) { }\n+# fn process_other(i: i32) { }\n+\n+let message = match maybe_digit {\n+    Some(x) if x < 10 => process_digit(x),\n+    Some(x) => process_other(x),\n+    None => panic!(),\n+};\n+```\n+\n+## `if let` expressions\n+\n+An `if let` expression is semantically identical to an `if` expression but in\n+place of a condition expression it expects a `let` statement with a refutable\n+pattern. If the value of the expression on the right hand side of the `let`\n+statement matches the pattern, the corresponding block will execute, otherwise\n+flow proceeds to the first `else` block that follows.\n+\n+```\n+let dish = (\"Ham\", \"Eggs\");\n+\n+// this body will be skipped because the pattern is refuted\n+if let (\"Bacon\", b) = dish {\n+    println!(\"Bacon is served with {}\", b);\n+}\n+\n+// this body will execute\n+if let (\"Ham\", b) = dish {\n+    println!(\"Ham is served with {}\", b);\n+}\n+```\n+\n+## `while let` loops\n+\n+A `while let` loop is semantically identical to a `while` loop but in place of\n+a condition expression it expects `let` statement with a refutable pattern. If\n+the value of the expression on the right hand side of the `let` statement\n+matches the pattern, the loop body block executes and control returns to the\n+pattern matching statement. Otherwise, the while expression completes.\n+\n+## `return` expressions\n+\n+Return expressions are denoted with the keyword `return`. Evaluating a `return`\n+expression moves its argument into the designated output location for the\n+current function call, destroys the current function activation frame, and\n+transfers control to the caller frame.\n+\n+An example of a `return` expression:\n+\n+```\n+fn max(a: i32, b: i32) -> i32 {\n+    if a > b {\n+        return a;\n+    }\n+    return b;\n+}\n+```"}, {"sha": "de657e3e312d5f5e8d0eaa1727c72706f18b73a0", "filename": "src/doc/reference/src/identifiers.md", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Fdoc%2Freference%2Fsrc%2Fidentifiers.md", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Fdoc%2Freference%2Fsrc%2Fidentifiers.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference%2Fsrc%2Fidentifiers.md?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -0,0 +1,24 @@\n+# Identifiers\n+\n+An identifier is any nonempty Unicode[^non_ascii_idents] string of the following form:\n+\n+Either\n+\n+   * The first character has property `XID_start`\n+   * The remaining characters have property `XID_continue`\n+\n+Or\n+\n+   * The first character is `_`\n+   * The identifier is more than one character, `_` alone is not an identifier\n+   * The remaining characters have property `XID_continue`\n+\n+that does _not_ occur in the set of [keywords].\n+\n+> **Note**: `XID_start` and `XID_continue` as character properties cover the\n+> character ranges used to form the more familiar C and Java language-family\n+> identifiers.\n+\n+[keywords]: ../grammar.html#keywords\n+[^non_ascii_idents]: Non-ASCII characters in identifiers are currently feature\n+  gated. This is expected to improve soon."}, {"sha": "46082bfc0b00641c0e6dc826a7866bf2c7dda14a", "filename": "src/doc/reference/src/influences.md", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Fdoc%2Freference%2Fsrc%2Finfluences.md", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Fdoc%2Freference%2Fsrc%2Finfluences.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference%2Fsrc%2Finfluences.md?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -0,0 +1,22 @@\n+# Influences\n+\n+Rust is not a particularly original language, with design elements coming from\n+a wide range of sources. Some of these are listed below (including elements\n+that have since been removed):\n+\n+* SML, OCaml: algebraic data types, pattern matching, type inference,\n+  semicolon statement separation\n+* C++: references, RAII, smart pointers, move semantics, monomorphization,\n+  memory model\n+* ML Kit, Cyclone: region based memory management\n+* Haskell (GHC): typeclasses, type families\n+* Newsqueak, Alef, Limbo: channels, concurrency\n+* Erlang: message passing, thread failure, <strike>linked thread failure</strike>,\n+  <strike>lightweight concurrency</strike>\n+* Swift: optional bindings\n+* Scheme: hygienic macros\n+* C#: attributes\n+* Ruby: <strike>block syntax</strike>\n+* NIL, Hermes: <strike>typestate</strike>\n+* [Unicode Annex #31](http://www.unicode.org/reports/tr31/): identifier and\n+  pattern syntax"}, {"sha": "0dbba4be92a0522043716ef02cc9be1f4f9f1384", "filename": "src/doc/reference/src/input-format.md", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Fdoc%2Freference%2Fsrc%2Finput-format.md", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Fdoc%2Freference%2Fsrc%2Finput-format.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference%2Fsrc%2Finput-format.md?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -0,0 +1,10 @@\n+# Input format\n+\n+Rust input is interpreted as a sequence of Unicode code points encoded in UTF-8.\n+Most Rust grammar rules are defined in terms of printable ASCII-range\n+code points, but a small number are defined in terms of Unicode properties or\n+explicit code point lists. [^inputformat]\n+\n+[^inputformat]: Substitute definitions for the special Unicode productions are\n+  provided to the grammar verifier, restricted to ASCII range, when verifying the\n+  grammar in this document."}, {"sha": "3a00dfa4572bf26cebf3b042f5272f1d2774dccd", "filename": "src/doc/reference/src/introduction.md", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Fdoc%2Freference%2Fsrc%2Fintroduction.md", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Fdoc%2Freference%2Fsrc%2Fintroduction.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference%2Fsrc%2Fintroduction.md?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -0,0 +1,31 @@\n+# Introduction\n+\n+This document is the primary reference for the Rust programming language. It\n+provides three kinds of material:\n+\n+  - Chapters that informally describe each language construct and their use.\n+  - Chapters that informally describe the memory model, concurrency model,\n+    runtime services, linkage model and debugging facilities.\n+  - Appendix chapters providing rationale and references to languages that\n+    influenced the design.\n+\n+This document does not serve as an introduction to the language. Background\n+familiarity with the language is assumed. A separate [book] is available to\n+help acquire such background familiarity.\n+\n+This document also does not serve as a reference to the [standard] library\n+included in the language distribution. Those libraries are documented\n+separately by extracting documentation attributes from their source code. Many\n+of the features that one might expect to be language features are library\n+features in Rust, so what you're looking for may be there, not here.\n+\n+Finally, this document is not normative. It may include details that are\n+specific to `rustc` itself, and should not be taken as a specification for\n+the Rust language. We intend to produce such a document someday, but this\n+is what we have for now.\n+\n+You may also be interested in the [grammar].\n+\n+[book]: ../book/index.html\n+[standard]: ../std/index.html\n+[grammar]: ../grammar.html"}, {"sha": "bd5018d69cc78a33e74c70a725b18474886cadaa", "filename": "src/doc/reference/src/items-and-attributes.md", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Fdoc%2Freference%2Fsrc%2Fitems-and-attributes.md", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Fdoc%2Freference%2Fsrc%2Fitems-and-attributes.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference%2Fsrc%2Fitems-and-attributes.md?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -0,0 +1,7 @@\n+# Items and attributes\n+\n+Crates contain [items], each of which may have some number of\n+[attributes] attached to it.\n+\n+[items]: items.html\n+[attributes]: attributes.html"}, {"sha": "ba3f4195ba62dd6ff2a93ffa49bb1b0c5df2b8da", "filename": "src/doc/reference/src/items.md", "status": "added", "additions": 1091, "deletions": 0, "changes": 1091, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Fdoc%2Freference%2Fsrc%2Fitems.md", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Fdoc%2Freference%2Fsrc%2Fitems.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference%2Fsrc%2Fitems.md?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -0,0 +1,1091 @@\n+# Items\n+\n+An _item_ is a component of a crate. Items are organized within a crate by a\n+nested set of [modules]. Every crate has a single \"outermost\"\n+anonymous module; all further items within the crate have [paths]\n+within the module tree of the crate.\n+\n+[modules]: #modules\n+[paths]: paths.html\n+\n+Items are entirely determined at compile-time, generally remain fixed during\n+execution, and may reside in read-only memory.\n+\n+There are several kinds of item:\n+\n+* [`extern crate` declarations](#extern-crate-declarations)\n+* [`use` declarations](#use-declarations)\n+* [modules](#modules)\n+* [function definitions](#functions)\n+* [`extern` blocks](#external-blocks)\n+* [type definitions](../grammar.html#type-definitions)\n+* [struct definitions](#structs)\n+* [enumeration definitions](#enumerations)\n+* [constant items](#constant-items)\n+* [static items](#static-items)\n+* [trait definitions](#traits)\n+* [implementations](#implementations)\n+\n+Some items form an implicit scope for the declaration of sub-items. In other\n+words, within a function or module, declarations of items can (in many cases)\n+be mixed with the statements, control blocks, and similar artifacts that\n+otherwise compose the item body. The meaning of these scoped items is the same\n+as if the item was declared outside the scope &mdash; it is still a static item\n+&mdash; except that the item's *path name* within the module namespace is\n+qualified by the name of the enclosing item, or is private to the enclosing\n+item (in the case of functions). The grammar specifies the exact locations in\n+which sub-item declarations may appear.\n+\n+## Type Parameters\n+\n+All items except modules, constants and statics may be *parameterized* by type.\n+Type parameters are given as a comma-separated list of identifiers enclosed in\n+angle brackets (`<...>`), after the name of the item and before its definition.\n+The type parameters of an item are considered \"part of the name\", not part of\n+the type of the item. A referencing [path] must (in principle) provide\n+type arguments as a list of comma-separated types enclosed within angle\n+brackets, in order to refer to the type-parameterized item. In practice, the\n+type-inference system can usually infer such argument types from context. There\n+are no general type-parametric types, only type-parametric items. That is, Rust\n+has no notion of type abstraction: there are no higher-ranked (or \"forall\") types\n+abstracted over other types, though higher-ranked types do exist for lifetimes.\n+\n+[path]: paths.html\n+\n+## Modules\n+\n+A module is a container for zero or more [items].\n+\n+[items]: items.html\n+\n+A _module item_ is a module, surrounded in braces, named, and prefixed with the\n+keyword `mod`. A module item introduces a new, named module into the tree of\n+modules making up a crate. Modules can nest arbitrarily.\n+\n+An example of a module:\n+\n+```rust\n+mod math {\n+    type Complex = (f64, f64);\n+    fn sin(f: f64) -> f64 {\n+        /* ... */\n+# panic!();\n+    }\n+    fn cos(f: f64) -> f64 {\n+        /* ... */\n+# panic!();\n+    }\n+    fn tan(f: f64) -> f64 {\n+        /* ... */\n+# panic!();\n+    }\n+}\n+```\n+\n+Modules and types share the same namespace. Declaring a named type with\n+the same name as a module in scope is forbidden: that is, a type definition,\n+trait, struct, enumeration, or type parameter can't shadow the name of a module\n+in scope, or vice versa.\n+\n+A module without a body is loaded from an external file, by default with the\n+same name as the module, plus the `.rs` extension. When a nested submodule is\n+loaded from an external file, it is loaded from a subdirectory path that\n+mirrors the module hierarchy.\n+\n+```rust,ignore\n+// Load the `vec` module from `vec.rs`\n+mod vec;\n+\n+mod thread {\n+    // Load the `local_data` module from `thread/local_data.rs`\n+    // or `thread/local_data/mod.rs`.\n+    mod local_data;\n+}\n+```\n+\n+The directories and files used for loading external file modules can be\n+influenced with the `path` attribute.\n+\n+```rust,ignore\n+#[path = \"thread_files\"]\n+mod thread {\n+    // Load the `local_data` module from `thread_files/tls.rs`\n+    #[path = \"tls.rs\"]\n+    mod local_data;\n+}\n+```\n+\n+### Extern crate declarations\n+\n+An _`extern crate` declaration_ specifies a dependency on an external crate.\n+The external crate is then bound into the declaring scope as the `ident`\n+provided in the `extern_crate_decl`.\n+\n+The external crate is resolved to a specific `soname` at compile time, and a\n+runtime linkage requirement to that `soname` is passed to the linker for\n+loading at runtime. The `soname` is resolved at compile time by scanning the\n+compiler's library path and matching the optional `crateid` provided against\n+the `crateid` attributes that were declared on the external crate when it was\n+compiled. If no `crateid` is provided, a default `name` attribute is assumed,\n+equal to the `ident` given in the `extern_crate_decl`.\n+\n+Three examples of `extern crate` declarations:\n+\n+```rust,ignore\n+extern crate pcre;\n+\n+extern crate std; // equivalent to: extern crate std as std;\n+\n+extern crate std as ruststd; // linking to 'std' under another name\n+```\n+\n+When naming Rust crates, hyphens are disallowed. However, Cargo packages may\n+make use of them. In such case, when `Cargo.toml` doesn't specify a crate name,\n+Cargo will transparently replace `-` with `_` (Refer to [RFC 940] for more\n+details).\n+\n+Here is an example:\n+\n+```rust,ignore\n+// Importing the Cargo package hello-world\n+extern crate hello_world; // hyphen replaced with an underscore\n+```\n+\n+[RFC 940]: https://github.com/rust-lang/rfcs/blob/master/text/0940-hyphens-considered-harmful.md\n+\n+### Use declarations\n+\n+A _use declaration_ creates one or more local name bindings synonymous with\n+some other [path]. Usually a `use` declaration is used to shorten the\n+path required to refer to a module item. These declarations may appear in\n+[modules] and [blocks], usually at the top.\n+\n+[path]: paths.html\n+[modules]: #modules\n+[blocks]: ../grammar.html#block-expressions\n+\n+> **Note**: Unlike in many languages,\n+> `use` declarations in Rust do *not* declare linkage dependency with external crates.\n+> Rather, [`extern crate` declarations](#extern-crate-declarations) declare linkage dependencies.\n+\n+Use declarations support a number of convenient shortcuts:\n+\n+* Rebinding the target name as a new local name, using the syntax `use p::q::r as x;`\n+* Simultaneously binding a list of paths differing only in their final element,\n+  using the glob-like brace syntax `use a::b::{c,d,e,f};`\n+* Binding all paths matching a given prefix, using the asterisk wildcard syntax\n+  `use a::b::*;`\n+* Simultaneously binding a list of paths differing only in their final element\n+  and their immediate parent module, using the `self` keyword, such as\n+  `use a::b::{self, c, d};`\n+\n+An example of `use` declarations:\n+\n+```rust\n+use std::option::Option::{Some, None};\n+use std::collections::hash_map::{self, HashMap};\n+\n+fn foo<T>(_: T){}\n+fn bar(map1: HashMap<String, usize>, map2: hash_map::HashMap<String, usize>){}\n+\n+fn main() {\n+    // Equivalent to 'foo(vec![std::option::Option::Some(1.0f64),\n+    // std::option::Option::None]);'\n+    foo(vec![Some(1.0f64), None]);\n+\n+    // Both `hash_map` and `HashMap` are in scope.\n+    let map1 = HashMap::new();\n+    let map2 = hash_map::HashMap::new();\n+    bar(map1, map2);\n+}\n+```\n+\n+Like items, `use` declarations are private to the containing module, by\n+default. Also like items, a `use` declaration can be public, if qualified by\n+the `pub` keyword. Such a `use` declaration serves to _re-export_ a name. A\n+public `use` declaration can therefore _redirect_ some public name to a\n+different target definition: even a definition with a private canonical path,\n+inside a different module. If a sequence of such redirections form a cycle or\n+cannot be resolved unambiguously, they represent a compile-time error.\n+\n+An example of re-exporting:\n+\n+```rust\n+# fn main() { }\n+mod quux {\n+    pub use quux::foo::{bar, baz};\n+\n+    pub mod foo {\n+        pub fn bar() { }\n+        pub fn baz() { }\n+    }\n+}\n+```\n+\n+In this example, the module `quux` re-exports two public names defined in\n+`foo`.\n+\n+Also note that the paths contained in `use` items are relative to the crate\n+root. So, in the previous example, the `use` refers to `quux::foo::{bar,\n+baz}`, and not simply to `foo::{bar, baz}`. This also means that top-level\n+module declarations should be at the crate root if direct usage of the declared\n+modules within `use` items is desired. It is also possible to use `self` and\n+`super` at the beginning of a `use` item to refer to the current and direct\n+parent modules respectively. All rules regarding accessing declared modules in\n+`use` declarations apply to both module declarations and `extern crate`\n+declarations.\n+\n+An example of what will and will not work for `use` items:\n+\n+```rust\n+# #![allow(unused_imports)]\n+use foo::baz::foobaz;    // good: foo is at the root of the crate\n+\n+mod foo {\n+\n+    mod example {\n+        pub mod iter {}\n+    }\n+\n+    use foo::example::iter; // good: foo is at crate root\n+//  use example::iter;      // bad:  example is not at the crate root\n+    use self::baz::foobaz;  // good: self refers to module 'foo'\n+    use foo::bar::foobar;   // good: foo is at crate root\n+\n+    pub mod bar {\n+        pub fn foobar() { }\n+    }\n+\n+    pub mod baz {\n+        use super::bar::foobar; // good: super refers to module 'foo'\n+        pub fn foobaz() { }\n+    }\n+}\n+\n+fn main() {}\n+```\n+\n+## Functions\n+\n+A _function item_ defines a sequence of [statements] and a\n+final [expression], along with a name and a set of\n+parameters. Other than a name, all these are optional.\n+Functions are declared with the keyword `fn`. Functions may declare a\n+set of *input* [*variables*][variables] as parameters, through which the caller\n+passes arguments into the function, and the *output* [*type*][type]\n+of the value the function will return to its caller on completion.\n+\n+[statements]: statements.html\n+[expression]: expressions.html\n+[variables]: variables.html\n+[type]: types.html\n+\n+A function may also be copied into a first-class *value*, in which case the\n+value has the corresponding [*function type*][function type], and can be used\n+otherwise exactly as a function item (with a minor additional cost of calling\n+the function indirectly).\n+\n+[function type]: types.html#function-types\n+\n+Every control path in a function logically ends with a `return` expression or a\n+diverging expression. If the outermost block of a function has a\n+value-producing expression in its final-expression position, that expression is\n+interpreted as an implicit `return` expression applied to the final-expression.\n+\n+An example of a function:\n+\n+```rust\n+fn add(x: i32, y: i32) -> i32 {\n+    x + y\n+}\n+```\n+\n+As with `let` bindings, function arguments are irrefutable patterns, so any\n+pattern that is valid in a let binding is also valid as an argument.\n+\n+```rust\n+fn first((value, _): (i32, i32)) -> i32 { value }\n+```\n+\n+\n+### Generic functions\n+\n+A _generic function_ allows one or more _parameterized types_ to appear in its\n+signature. Each type parameter must be explicitly declared in an\n+angle-bracket-enclosed and comma-separated list, following the function name.\n+\n+```rust,ignore\n+// foo is generic over A and B\n+\n+fn foo<A, B>(x: A, y: B) {\n+```\n+\n+Inside the function signature and body, the name of the type parameter can be\n+used as a type name. [Trait](#traits) bounds can be specified for type parameters\n+to allow methods with that trait to be called on values of that type. This is\n+specified using the `where` syntax:\n+\n+```rust,ignore\n+fn foo<T>(x: T) where T: Debug {\n+```\n+\n+When a generic function is referenced, its type is instantiated based on the\n+context of the reference. For example, calling the `foo` function here:\n+\n+```rust\n+use std::fmt::Debug;\n+\n+fn foo<T>(x: &[T]) where T: Debug {\n+    // details elided\n+    # ()\n+}\n+\n+foo(&[1, 2]);\n+```\n+\n+will instantiate type parameter `T` with `i32`.\n+\n+The type parameters can also be explicitly supplied in a trailing\n+[path] component after the function name. This might be necessary if\n+there is not sufficient context to determine the type parameters. For example,\n+`mem::size_of::<u32>() == 4`.\n+\n+[path]: paths.html\n+\n+### Diverging functions\n+\n+A special kind of function can be declared with a `!` character where the\n+output type would normally be. For example:\n+\n+```rust\n+fn my_err(s: &str) -> ! {\n+    println!(\"{}\", s);\n+    panic!();\n+}\n+```\n+\n+We call such functions \"diverging\" because they never return a value to the\n+caller. Every control path in a diverging function must end with a `panic!()` or\n+a call to another diverging function on every control path. The `!` annotation\n+does *not* denote a type.\n+\n+It might be necessary to declare a diverging function because as mentioned\n+previously, the typechecker checks that every control path in a function ends\n+with a [`return`] or diverging expression. So, if `my_err`\n+were declared without the `!` annotation, the following code would not\n+typecheck:\n+\n+[`return`]: expressions.html#return-expressions\n+\n+```rust\n+# fn my_err(s: &str) -> ! { panic!() }\n+\n+fn f(i: i32) -> i32 {\n+    if i == 42 {\n+        return 42;\n+    }\n+    else {\n+        my_err(\"Bad number!\");\n+    }\n+}\n+```\n+\n+This will not compile without the `!` annotation on `my_err`, since the `else`\n+branch of the conditional in `f` does not return an `i32`, as required by the\n+signature of `f`. Adding the `!` annotation to `my_err` informs the\n+typechecker that, should control ever enter `my_err`, no further type judgments\n+about `f` need to hold, since control will never resume in any context that\n+relies on those judgments. Thus the return type on `f` only needs to reflect\n+the `if` branch of the conditional.\n+\n+### Extern functions\n+\n+Extern functions are part of Rust's foreign function interface, providing the\n+opposite functionality to [external blocks](#external-blocks). Whereas\n+external blocks allow Rust code to call foreign code, extern functions with\n+bodies defined in Rust code _can be called by foreign code_. They are defined\n+in the same way as any other Rust function, except that they have the `extern`\n+modifier.\n+\n+```rust\n+// Declares an extern fn, the ABI defaults to \"C\"\n+extern fn new_i32() -> i32 { 0 }\n+\n+// Declares an extern fn with \"stdcall\" ABI\n+extern \"stdcall\" fn new_i32_stdcall() -> i32 { 0 }\n+```\n+\n+Unlike normal functions, extern fns have type `extern \"ABI\" fn()`. This is the\n+same type as the functions declared in an extern block.\n+\n+```rust\n+# extern fn new_i32() -> i32 { 0 }\n+let fptr: extern \"C\" fn() -> i32 = new_i32;\n+```\n+\n+Extern functions may be called directly from Rust code as Rust uses large,\n+contiguous stack segments like C.\n+\n+## Type aliases\n+\n+A _type alias_ defines a new name for an existing [type]. Type\n+aliases are declared with the keyword `type`. Every value has a single,\n+specific type, but may implement several different traits, or be compatible with\n+several different type constraints.\n+\n+[type]: types.html\n+\n+For example, the following defines the type `Point` as a synonym for the type\n+`(u8, u8)`, the type of pairs of unsigned 8 bit integers:\n+\n+```rust\n+type Point = (u8, u8);\n+let p: Point = (41, 68);\n+```\n+\n+Currently a type alias to an enum type cannot be used to qualify the\n+constructors:\n+\n+```rust\n+enum E { A }\n+type F = E;\n+let _: F = E::A;  // OK\n+// let _: F = F::A;  // Doesn't work\n+```\n+\n+## Structs\n+\n+A _struct_ is a nominal [struct type] defined with the\n+keyword `struct`.\n+\n+An example of a `struct` item and its use:\n+\n+```rust\n+struct Point {x: i32, y: i32}\n+let p = Point {x: 10, y: 11};\n+let px: i32 = p.x;\n+```\n+\n+A _tuple struct_ is a nominal [tuple type], also defined with\n+the keyword `struct`. For example:\n+\n+[struct type]: types.html#struct-types\n+[tuple type]: types.html#tuple-types\n+\n+```rust\n+struct Point(i32, i32);\n+let p = Point(10, 11);\n+let px: i32 = match p { Point(x, _) => x };\n+```\n+\n+A _unit-like struct_ is a struct without any fields, defined by leaving off\n+the list of fields entirely. Such a struct implicitly defines a constant of\n+its type with the same name. For example:\n+\n+```rust\n+struct Cookie;\n+let c = [Cookie, Cookie {}, Cookie, Cookie {}];\n+```\n+\n+is equivalent to\n+\n+```rust\n+struct Cookie {}\n+const Cookie: Cookie = Cookie {};\n+let c = [Cookie, Cookie {}, Cookie, Cookie {}];\n+```\n+\n+The precise memory layout of a struct is not specified. One can specify a\n+particular layout using the [`repr` attribute].\n+\n+[`repr` attribute]: attributes.html#ffi-attributes\n+\n+## Enumerations\n+\n+An _enumeration_ is a simultaneous definition of a nominal [enumerated\n+type] as well as a set of *constructors*, that can be used\n+to create or pattern-match values of the corresponding enumerated type.\n+\n+[enumerated type]: types.html#enumerated-types\n+\n+Enumerations are declared with the keyword `enum`.\n+\n+An example of an `enum` item and its use:\n+\n+```rust\n+enum Animal {\n+    Dog,\n+    Cat,\n+}\n+\n+let mut a: Animal = Animal::Dog;\n+a = Animal::Cat;\n+```\n+\n+Enumeration constructors can have either named or unnamed fields:\n+\n+```rust\n+enum Animal {\n+    Dog (String, f64),\n+    Cat { name: String, weight: f64 },\n+}\n+\n+let mut a: Animal = Animal::Dog(\"Cocoa\".to_string(), 37.2);\n+a = Animal::Cat { name: \"Spotty\".to_string(), weight: 2.7 };\n+```\n+\n+In this example, `Cat` is a _struct-like enum variant_,\n+whereas `Dog` is simply called an enum variant.\n+\n+Each enum value has a _discriminant_ which is an integer associated to it. You\n+can specify it explicitly:\n+\n+```rust\n+enum Foo {\n+    Bar = 123,\n+}\n+```\n+\n+The right hand side of the specification is interpreted as an `isize` value,\n+but the compiler is allowed to use a smaller type in the actual memory layout.\n+The [`repr` attribute] can be added in order to change\n+the type of the right hand side and specify the memory layout.\n+\n+[`repr` attribute]: attributes.html#ffi-attributes\n+\n+If a discriminant isn't specified, they start at zero, and add one for each\n+variant, in order.\n+\n+You can cast an enum to get its discriminant:\n+\n+```rust\n+# enum Foo { Bar = 123 }\n+let x = Foo::Bar as u32; // x is now 123u32\n+```\n+\n+This only works as long as none of the variants have data attached. If\n+it were `Bar(i32)`, this is disallowed.\n+\n+## Constant items\n+\n+A *constant item* is a named _constant value_ which is not associated with a\n+specific memory location in the program. Constants are essentially inlined\n+wherever they are used, meaning that they are copied directly into the relevant\n+context when used. References to the same constant are not necessarily\n+guaranteed to refer to the same memory address.\n+\n+Constant values must not have destructors, and otherwise permit most forms of\n+data. Constants may refer to the address of other constants, in which case the\n+address will have elided lifetimes where applicable, otherwise \u2013 in most cases \u2013\n+defaulting to the `static` lifetime. (See below on [static lifetime elision].)\n+The compiler is, however, still at liberty to translate the constant many times,\n+so the address referred to may not be stable.\n+\n+[static lifetime elision]: #static-lifetime-elision\n+\n+Constants must be explicitly typed. The type may be `bool`, `char`, a number, or\n+a type derived from those primitive types. The derived types are references with\n+the `static` lifetime, fixed-size arrays, tuples, enum variants, and structs.\n+\n+```rust\n+const BIT1: u32 = 1 << 0;\n+const BIT2: u32 = 1 << 1;\n+\n+const BITS: [u32; 2] = [BIT1, BIT2];\n+const STRING: &'static str = \"bitstring\";\n+\n+struct BitsNStrings<'a> {\n+    mybits: [u32; 2],\n+    mystring: &'a str,\n+}\n+\n+const BITS_N_STRINGS: BitsNStrings<'static> = BitsNStrings {\n+    mybits: BITS,\n+    mystring: STRING,\n+};\n+```\n+\n+## Static items\n+\n+A *static item* is similar to a *constant*, except that it represents a precise\n+memory location in the program. A static is never \"inlined\" at the usage site,\n+and all references to it refer to the same memory location. Static items have\n+the `static` lifetime, which outlives all other lifetimes in a Rust program.\n+Static items may be placed in read-only memory if they do not contain any\n+interior mutability.\n+\n+Statics may contain interior mutability through the `UnsafeCell` language item.\n+All access to a static is safe, but there are a number of restrictions on\n+statics:\n+\n+* Statics may not contain any destructors.\n+* The types of static values must ascribe to `Sync` to allow thread-safe access.\n+* Statics may not refer to other statics by value, only by reference.\n+* Constants cannot refer to statics.\n+\n+Constants should in general be preferred over statics, unless large amounts of\n+data are being stored, or single-address and mutability properties are required.\n+\n+### Mutable statics\n+\n+If a static item is declared with the `mut` keyword, then it is allowed to\n+be modified by the program. One of Rust's goals is to make concurrency bugs\n+hard to run into, and this is obviously a very large source of race conditions\n+or other bugs. For this reason, an `unsafe` block is required when either\n+reading or writing a mutable static variable. Care should be taken to ensure\n+that modifications to a mutable static are safe with respect to other threads\n+running in the same process.\n+\n+Mutable statics are still very useful, however. They can be used with C\n+libraries and can also be bound from C libraries (in an `extern` block).\n+\n+```rust\n+# fn atomic_add(_: &mut u32, _: u32) -> u32 { 2 }\n+\n+static mut LEVELS: u32 = 0;\n+\n+// This violates the idea of no shared state, and this doesn't internally\n+// protect against races, so this function is `unsafe`\n+unsafe fn bump_levels_unsafe1() -> u32 {\n+    let ret = LEVELS;\n+    LEVELS += 1;\n+    return ret;\n+}\n+\n+// Assuming that we have an atomic_add function which returns the old value,\n+// this function is \"safe\" but the meaning of the return value may not be what\n+// callers expect, so it's still marked as `unsafe`\n+unsafe fn bump_levels_unsafe2() -> u32 {\n+    return atomic_add(&mut LEVELS, 1);\n+}\n+```\n+\n+Mutable statics have the same restrictions as normal statics, except that the\n+type of the value is not required to ascribe to `Sync`.\n+\n+#### `'static` lifetime elision\n+\n+[Unstable] Both constant and static declarations of reference types have\n+*implicit* `'static` lifetimes unless an explicit lifetime is specified. As\n+such, the constant declarations involving `'static` above may be written\n+without the lifetimes. Returning to our previous example:\n+\n+```rust\n+# #![feature(static_in_const)]\n+const BIT1: u32 = 1 << 0;\n+const BIT2: u32 = 1 << 1;\n+\n+const BITS: [u32; 2] = [BIT1, BIT2];\n+const STRING: &str = \"bitstring\";\n+\n+struct BitsNStrings<'a> {\n+    mybits: [u32; 2],\n+    mystring: &'a str,\n+}\n+\n+const BITS_N_STRINGS: BitsNStrings = BitsNStrings {\n+    mybits: BITS,\n+    mystring: STRING,\n+};\n+```\n+\n+Note that if the `static` or `const` items include function or closure\n+references, which themselves include references, the compiler will first try the\n+standard elision rules ([see discussion in the nomicon][elision-nomicon]). If it\n+is unable to resolve the lifetimes by its usual rules, it will default to using\n+the `'static` lifetime. By way of example:\n+\n+[elision-nomicon]: ../nomicon/lifetime-elision.html\n+\n+```rust,ignore\n+// Resolved as `fn<'a>(&'a str) -> &'a str`.\n+const RESOLVED_SINGLE: fn(&str) -> &str = ..\n+\n+// Resolved as `Fn<'a, 'b, 'c>(&'a Foo, &'b Bar, &'c Baz) -> usize`.\n+const RESOLVED_MULTIPLE: Fn(&Foo, &Bar, &Baz) -> usize = ..\n+\n+// There is insufficient information to bound the return reference lifetime\n+// relative to the argument lifetimes, so the signature is resolved as\n+// `Fn(&'static Foo, &'static Bar) -> &'static Baz`.\n+const RESOLVED_STATIC: Fn(&Foo, &Bar) -> &Baz = ..\n+```\n+\n+### Traits\n+\n+A _trait_ describes an abstract interface that types can\n+implement. This interface consists of associated items, which come in\n+three varieties:\n+\n+- functions\n+- constants\n+- types\n+\n+Associated functions whose first parameter is named `self` are called\n+methods and may be invoked using `.` notation (e.g., `x.foo()`).\n+\n+All traits define an implicit type parameter `Self` that refers to\n+\"the type that is implementing this interface\". Traits may also\n+contain additional type parameters. These type parameters (including\n+`Self`) may be constrained by other traits and so forth as usual.\n+\n+Trait bounds on `Self` are considered \"supertraits\". These are\n+required to be acyclic.  Supertraits are somewhat different from other\n+constraints in that they affect what methods are available in the\n+vtable when the trait is used as a [trait object].\n+\n+Traits are implemented for specific types through separate\n+[implementations].\n+\n+Consider the following trait:\n+\n+```rust\n+# type Surface = i32;\n+# type BoundingBox = i32;\n+trait Shape {\n+    fn draw(&self, Surface);\n+    fn bounding_box(&self) -> BoundingBox;\n+}\n+```\n+\n+This defines a trait with two methods. All values that have\n+[implementations] of this trait in scope can have their\n+`draw` and `bounding_box` methods called, using `value.bounding_box()`\n+[syntax].\n+\n+[trait object]: types.html#trait-objects\n+[implementations]: #implementations\n+[syntax]: expressions.html#method-call-expressions\n+\n+Traits can include default implementations of methods, as in:\n+\n+```rust\n+trait Foo {\n+    fn bar(&self);\n+    fn baz(&self) { println!(\"We called baz.\"); }\n+}\n+```\n+\n+Here the `baz` method has a default implementation, so types that implement\n+`Foo` need only implement `bar`. It is also possible for implementing types\n+to override a method that has a default implementation.\n+\n+Type parameters can be specified for a trait to make it generic. These appear\n+after the trait name, using the same syntax used in [generic\n+functions](#generic-functions).\n+\n+```rust\n+trait Seq<T> {\n+    fn len(&self) -> u32;\n+    fn elt_at(&self, n: u32) -> T;\n+    fn iter<F>(&self, F) where F: Fn(T);\n+}\n+```\n+\n+It is also possible to define associated types for a trait. Consider the\n+following example of a `Container` trait. Notice how the type is available\n+for use in the method signatures:\n+\n+```rust\n+trait Container {\n+    type E;\n+    fn empty() -> Self;\n+    fn insert(&mut self, Self::E);\n+}\n+```\n+\n+In order for a type to implement this trait, it must not only provide\n+implementations for every method, but it must specify the type `E`. Here's\n+an implementation of `Container` for the standard library type `Vec`:\n+\n+```rust\n+# trait Container {\n+#     type E;\n+#     fn empty() -> Self;\n+#     fn insert(&mut self, Self::E);\n+# }\n+impl<T> Container for Vec<T> {\n+    type E = T;\n+    fn empty() -> Vec<T> { Vec::new() }\n+    fn insert(&mut self, x: T) { self.push(x); }\n+}\n+```\n+\n+Generic functions may use traits as _bounds_ on their type parameters. This\n+will have two effects:\n+\n+- Only types that have the trait may instantiate the parameter.\n+- Within the generic function, the methods of the trait can be\n+  called on values that have the parameter's type.\n+\n+For example:\n+\n+```rust\n+# type Surface = i32;\n+# trait Shape { fn draw(&self, Surface); }\n+fn draw_twice<T: Shape>(surface: Surface, sh: T) {\n+    sh.draw(surface);\n+    sh.draw(surface);\n+}\n+```\n+\n+Traits also define a [trait object] with the same\n+name as the trait. Values of this type are created by coercing from a\n+pointer of some specific type to a pointer of trait type. For example,\n+`&T` could be coerced to `&Shape` if `T: Shape` holds (and similarly\n+for `Box<T>`). This coercion can either be implicit or\n+[explicit]. Here is an example of an explicit\n+coercion:\n+\n+[trait object]: types.html#trait-objects\n+[explicit]: expressions.html#type-cast-expressions\n+\n+```rust\n+trait Shape { }\n+impl Shape for i32 { }\n+let mycircle = 0i32;\n+let myshape: Box<Shape> = Box::new(mycircle) as Box<Shape>;\n+```\n+\n+The resulting value is a box containing the value that was cast, along with\n+information that identifies the methods of the implementation that was used.\n+Values with a trait type can have [methods called] on\n+them, for any method in the trait, and can be used to instantiate type\n+parameters that are bounded by the trait.\n+\n+[methods called]: expressions.html#method-call-expressions\n+\n+Trait methods may be static, which means that they lack a `self` argument.\n+This means that they can only be called with function call syntax (`f(x)`) and\n+not method call syntax (`obj.f()`). The way to refer to the name of a static\n+method is to qualify it with the trait name, treating the trait name like a\n+module. For example:\n+\n+```rust\n+trait Num {\n+    fn from_i32(n: i32) -> Self;\n+}\n+impl Num for f64 {\n+    fn from_i32(n: i32) -> f64 { n as f64 }\n+}\n+let x: f64 = Num::from_i32(42);\n+```\n+\n+Traits may inherit from other traits. Consider the following example:\n+\n+```rust\n+trait Shape { fn area(&self) -> f64; }\n+trait Circle : Shape { fn radius(&self) -> f64; }\n+```\n+\n+The syntax `Circle : Shape` means that types that implement `Circle` must also\n+have an implementation for `Shape`. Multiple supertraits are separated by `+`,\n+`trait Circle : Shape + PartialEq { }`. In an implementation of `Circle` for a\n+given type `T`, methods can refer to `Shape` methods, since the typechecker\n+checks that any type with an implementation of `Circle` also has an\n+implementation of `Shape`:\n+\n+```rust\n+struct Foo;\n+\n+trait Shape { fn area(&self) -> f64; }\n+trait Circle : Shape { fn radius(&self) -> f64; }\n+impl Shape for Foo {\n+    fn area(&self) -> f64 {\n+        0.0\n+    }\n+}\n+impl Circle for Foo {\n+    fn radius(&self) -> f64 {\n+        println!(\"calling area: {}\", self.area());\n+\n+        0.0\n+    }\n+}\n+\n+let c = Foo;\n+c.radius();\n+```\n+\n+In type-parameterized functions, methods of the supertrait may be called on\n+values of subtrait-bound type parameters. Referring to the previous example of\n+`trait Circle : Shape`:\n+\n+```rust\n+# trait Shape { fn area(&self) -> f64; }\n+# trait Circle : Shape { fn radius(&self) -> f64; }\n+fn radius_times_area<T: Circle>(c: T) -> f64 {\n+    // `c` is both a Circle and a Shape\n+    c.radius() * c.area()\n+}\n+```\n+\n+Likewise, supertrait methods may also be called on trait objects.\n+\n+```rust,ignore\n+# trait Shape { fn area(&self) -> f64; }\n+# trait Circle : Shape { fn radius(&self) -> f64; }\n+# impl Shape for i32 { fn area(&self) -> f64 { 0.0 } }\n+# impl Circle for i32 { fn radius(&self) -> f64 { 0.0 } }\n+# let mycircle = 0i32;\n+let mycircle = Box::new(mycircle) as Box<Circle>;\n+let nonsense = mycircle.radius() * mycircle.area();\n+```\n+\n+### Implementations\n+\n+An _implementation_ is an item that implements a [trait](#traits) for a\n+specific type.\n+\n+Implementations are defined with the keyword `impl`.\n+\n+```rust\n+# #[derive(Copy, Clone)]\n+# struct Point {x: f64, y: f64};\n+# type Surface = i32;\n+# struct BoundingBox {x: f64, y: f64, width: f64, height: f64};\n+# trait Shape { fn draw(&self, Surface); fn bounding_box(&self) -> BoundingBox; }\n+# fn do_draw_circle(s: Surface, c: Circle) { }\n+struct Circle {\n+    radius: f64,\n+    center: Point,\n+}\n+\n+impl Copy for Circle {}\n+\n+impl Clone for Circle {\n+    fn clone(&self) -> Circle { *self }\n+}\n+\n+impl Shape for Circle {\n+    fn draw(&self, s: Surface) { do_draw_circle(s, *self); }\n+    fn bounding_box(&self) -> BoundingBox {\n+        let r = self.radius;\n+        BoundingBox {\n+            x: self.center.x - r,\n+            y: self.center.y - r,\n+            width: 2.0 * r,\n+            height: 2.0 * r,\n+        }\n+    }\n+}\n+```\n+\n+It is possible to define an implementation without referring to a trait. The\n+methods in such an implementation can only be used as direct calls on the values\n+of the type that the implementation targets. In such an implementation, the\n+trait type and `for` after `impl` are omitted. Such implementations are limited\n+to nominal types (enums, structs, trait objects), and the implementation must\n+appear in the same crate as the `self` type:\n+\n+```rust\n+struct Point {x: i32, y: i32}\n+\n+impl Point {\n+    fn log(&self) {\n+        println!(\"Point is at ({}, {})\", self.x, self.y);\n+    }\n+}\n+\n+let my_point = Point {x: 10, y:11};\n+my_point.log();\n+```\n+\n+When a trait _is_ specified in an `impl`, all methods declared as part of the\n+trait must be implemented, with matching types and type parameter counts.\n+\n+An implementation can take type parameters, which can be different from the\n+type parameters taken by the trait it implements. Implementation parameters\n+are written after the `impl` keyword.\n+\n+```rust\n+# trait Seq<T> { fn dummy(&self, _: T) { } }\n+impl<T> Seq<T> for Vec<T> {\n+    /* ... */\n+}\n+impl Seq<bool> for u32 {\n+    /* Treat the integer as a sequence of bits */\n+}\n+```\n+\n+### External blocks\n+\n+External blocks form the basis for Rust's foreign function interface.\n+Declarations in an external block describe symbols in external, non-Rust\n+libraries.\n+\n+Functions within external blocks are declared in the same way as other Rust\n+functions, with the exception that they may not have a body and are instead\n+terminated by a semicolon.\n+\n+Functions within external blocks may be called by Rust code, just like\n+functions defined in Rust. The Rust compiler automatically translates between\n+the Rust ABI and the foreign ABI.\n+\n+Functions within external blocks may be variadic by specifying `...` after one\n+or more named arguments in the argument list:\n+\n+```rust,ignore\n+extern {\n+    fn foo(x: i32, ...);\n+}\n+```\n+\n+A number of [attributes] control the behavior of external blocks.\n+\n+[attributes]: attributes.html#ffi-attributes\n+\n+By default external blocks assume that the library they are calling uses the\n+standard C ABI on the specific platform. Other ABIs may be specified using an\n+`abi` string, as shown here:\n+\n+```rust,ignore\n+// Interface to the Windows API\n+extern \"stdcall\" { }\n+```\n+\n+There are three ABI strings which are cross-platform, and which all compilers\n+are guaranteed to support:\n+\n+* `extern \"Rust\"` -- The default ABI when you write a normal `fn foo()` in any\n+  Rust code.\n+* `extern \"C\"` -- This is the same as `extern fn foo()`; whatever the default\n+  your C compiler supports.\n+* `extern \"system\"` -- Usually the same as `extern \"C\"`, except on Win32, in\n+  which case it's `\"stdcall\"`, or what you should use to link to the Windows API\n+  itself\n+\n+There are also some platform-specific ABI strings:\n+\n+* `extern \"cdecl\"` -- The default for x86\\_32 C code.\n+* `extern \"stdcall\"` -- The default for the Win32 API on x86\\_32.\n+* `extern \"win64\"` -- The default for C code on x86\\_64 Windows.\n+* `extern \"sysv64\"` -- The default for C code on non-Windows x86\\_64.\n+* `extern \"aapcs\"` -- The default for ARM.\n+* `extern \"fastcall\"` -- The `fastcall` ABI -- corresponds to MSVC's\n+  `__fastcall` and GCC and clang's `__attribute__((fastcall))`\n+* `extern \"vectorcall\"` -- The `vectorcall` ABI -- corresponds to MSVC's\n+  `__vectorcall` and clang's `__attribute__((vectorcall))`\n+\n+Finally, there are some rustc-specific ABI strings:\n+\n+* `extern \"rust-intrinsic\"` -- The ABI of rustc intrinsics.\n+* `extern \"rust-call\"` -- The ABI of the Fn::call trait functions.\n+* `extern \"platform-intrinsic\"` -- Specific platform intrinsics -- like, for\n+  example, `sqrt` -- have this ABI. You should never have to deal with it.\n+\n+The `link` attribute allows the name of the library to be specified. When\n+specified the compiler will attempt to link against the native library of the\n+specified name.\n+\n+```rust,ignore\n+#[link(name = \"crypto\")]\n+extern { }\n+```\n+\n+The type of a function declared in an extern block is `extern \"abi\" fn(A1, ...,\n+An) -> R`, where `A1...An` are the declared types of its arguments and `R` is\n+the declared return type.\n+\n+It is valid to add the `link` attribute on an empty extern block. You can use\n+this to satisfy the linking requirements of extern blocks elsewhere in your code\n+(including upstream crates) instead of adding the attribute to each extern block."}, {"sha": "5e1388e0d5a2bc153ef206cf0edbbeb0431cc7d7", "filename": "src/doc/reference/src/lexical-structure.md", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Fdoc%2Freference%2Fsrc%2Flexical-structure.md", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Fdoc%2Freference%2Fsrc%2Flexical-structure.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference%2Fsrc%2Flexical-structure.md?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -0,0 +1 @@\n+# Lexical structure"}, {"sha": "4755e4be8b685e91d6da895f59bd6094392d6bca", "filename": "src/doc/reference/src/linkage.md", "status": "added", "additions": 127, "deletions": 0, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Fdoc%2Freference%2Fsrc%2Flinkage.md", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Fdoc%2Freference%2Fsrc%2Flinkage.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference%2Fsrc%2Flinkage.md?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -0,0 +1,127 @@\n+# Linkage\n+\n+The Rust compiler supports various methods to link crates together both\n+statically and dynamically. This section will explore the various methods to\n+link Rust crates together, and more information about native libraries can be\n+found in the [FFI section of the book][ffi].\n+\n+[ffi]: ../book/ffi.html\n+\n+In one session of compilation, the compiler can generate multiple artifacts\n+through the usage of either command line flags or the `crate_type` attribute.\n+If one or more command line flags are specified, all `crate_type` attributes will\n+be ignored in favor of only building the artifacts specified by command line.\n+\n+* `--crate-type=bin`, `#[crate_type = \"bin\"]` - A runnable executable will be\n+  produced. This requires that there is a `main` function in the crate which\n+  will be run when the program begins executing. This will link in all Rust and\n+  native dependencies, producing a distributable binary.\n+\n+* `--crate-type=lib`, `#[crate_type = \"lib\"]` - A Rust library will be produced.\n+  This is an ambiguous concept as to what exactly is produced because a library\n+  can manifest itself in several forms. The purpose of this generic `lib` option\n+  is to generate the \"compiler recommended\" style of library. The output library\n+  will always be usable by rustc, but the actual type of library may change from\n+  time-to-time. The remaining output types are all different flavors of\n+  libraries, and the `lib` type can be seen as an alias for one of them (but the\n+  actual one is compiler-defined).\n+\n+* `--crate-type=dylib`, `#[crate_type = \"dylib\"]` - A dynamic Rust library will\n+  be produced. This is different from the `lib` output type in that this forces\n+  dynamic library generation. The resulting dynamic library can be used as a\n+  dependency for other libraries and/or executables. This output type will\n+  create `*.so` files on linux, `*.dylib` files on osx, and `*.dll` files on\n+  windows.\n+\n+* `--crate-type=staticlib`, `#[crate_type = \"staticlib\"]` - A static system\n+  library will be produced. This is different from other library outputs in that\n+  the Rust compiler will never attempt to link to `staticlib` outputs. The\n+  purpose of this output type is to create a static library containing all of\n+  the local crate's code along with all upstream dependencies. The static\n+  library is actually a `*.a` archive on linux and osx and a `*.lib` file on\n+  windows. This format is recommended for use in situations such as linking\n+  Rust code into an existing non-Rust application because it will not have\n+  dynamic dependencies on other Rust code.\n+\n+* `--crate-type=cdylib`, `#[crate_type = \"cdylib\"]` - A dynamic system\n+  library will be produced.  This is used when compiling Rust code as\n+  a dynamic library to be loaded from another language.  This output type will\n+  create `*.so` files on Linux, `*.dylib` files on OSX, and `*.dll` files on\n+  Windows.\n+\n+* `--crate-type=rlib`, `#[crate_type = \"rlib\"]` - A \"Rust library\" file will be\n+  produced. This is used as an intermediate artifact and can be thought of as a\n+  \"static Rust library\". These `rlib` files, unlike `staticlib` files, are\n+  interpreted by the Rust compiler in future linkage. This essentially means\n+  that `rustc` will look for metadata in `rlib` files like it looks for metadata\n+  in dynamic libraries. This form of output is used to produce statically linked\n+  executables as well as `staticlib` outputs.\n+\n+* `--crate-type=proc-macro`, `#[crate_type = \"proc-macro\"]` - The output\n+  produced is not specified, but if a `-L` path is provided to it then the\n+  compiler will recognize the output artifacts as a macro and it can be loaded\n+  for a program. If a crate is compiled with the `proc-macro` crate type it\n+  will forbid exporting any items in the crate other than those functions\n+  tagged `#[proc_macro_derive]` and those functions must also be placed at the\n+  crate root. Finally, the compiler will automatically set the\n+  `cfg(proc_macro)` annotation whenever any crate type of a compilation is the\n+  `proc-macro` crate type.\n+\n+Note that these outputs are stackable in the sense that if multiple are\n+specified, then the compiler will produce each form of output at once without\n+having to recompile. However, this only applies for outputs specified by the\n+same method. If only `crate_type` attributes are specified, then they will all\n+be built, but if one or more `--crate-type` command line flags are specified,\n+then only those outputs will be built.\n+\n+With all these different kinds of outputs, if crate A depends on crate B, then\n+the compiler could find B in various different forms throughout the system. The\n+only forms looked for by the compiler, however, are the `rlib` format and the\n+dynamic library format. With these two options for a dependent library, the\n+compiler must at some point make a choice between these two formats. With this\n+in mind, the compiler follows these rules when determining what format of\n+dependencies will be used:\n+\n+1. If a static library is being produced, all upstream dependencies are\n+   required to be available in `rlib` formats. This requirement stems from the\n+   reason that a dynamic library cannot be converted into a static format.\n+\n+   Note that it is impossible to link in native dynamic dependencies to a static\n+   library, and in this case warnings will be printed about all unlinked native\n+   dynamic dependencies.\n+\n+2. If an `rlib` file is being produced, then there are no restrictions on what\n+   format the upstream dependencies are available in. It is simply required that\n+   all upstream dependencies be available for reading metadata from.\n+\n+   The reason for this is that `rlib` files do not contain any of their upstream\n+   dependencies. It wouldn't be very efficient for all `rlib` files to contain a\n+   copy of `libstd.rlib`!\n+\n+3. If an executable is being produced and the `-C prefer-dynamic` flag is not\n+   specified, then dependencies are first attempted to be found in the `rlib`\n+   format. If some dependencies are not available in an rlib format, then\n+   dynamic linking is attempted (see below).\n+\n+4. If a dynamic library or an executable that is being dynamically linked is\n+   being produced, then the compiler will attempt to reconcile the available\n+   dependencies in either the rlib or dylib format to create a final product.\n+\n+   A major goal of the compiler is to ensure that a library never appears more\n+   than once in any artifact. For example, if dynamic libraries B and C were\n+   each statically linked to library A, then a crate could not link to B and C\n+   together because there would be two copies of A. The compiler allows mixing\n+   the rlib and dylib formats, but this restriction must be satisfied.\n+\n+   The compiler currently implements no method of hinting what format a library\n+   should be linked with. When dynamically linking, the compiler will attempt to\n+   maximize dynamic dependencies while still allowing some dependencies to be\n+   linked in via an rlib.\n+\n+   For most situations, having all libraries available as a dylib is recommended\n+   if dynamically linking. For other situations, the compiler will emit a\n+   warning if it is unable to determine which formats to link each library with.\n+\n+In general, `--crate-type=bin` or `--crate-type=lib` should be sufficient for\n+all compilation needs, and the other options are just available if more\n+fine-grained control is desired over the output format of a Rust crate."}, {"sha": "a007b232e4c97da06c3fa19904efda353bf8f4d2", "filename": "src/doc/reference/src/macros-by-example.md", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Fdoc%2Freference%2Fsrc%2Fmacros-by-example.md", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Fdoc%2Freference%2Fsrc%2Fmacros-by-example.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference%2Fsrc%2Fmacros-by-example.md?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -0,0 +1,88 @@\n+# Macros By Example\n+\n+`macro_rules` allows users to define syntax extension in a declarative way.  We\n+call such extensions \"macros by example\" or simply \"macros\".\n+\n+Currently, macros can expand to expressions, statements, items, or patterns.\n+\n+(A `sep_token` is any token other than `*` and `+`. A `non_special_token` is\n+any token other than a delimiter or `$`.)\n+\n+The macro expander looks up macro invocations by name, and tries each macro\n+rule in turn. It transcribes the first successful match. Matching and\n+transcription are closely related to each other, and we will describe them\n+together.\n+\n+The macro expander matches and transcribes every token that does not begin with\n+a `$` literally, including delimiters. For parsing reasons, delimiters must be\n+balanced, but they are otherwise not special.\n+\n+In the matcher, `$` _name_ `:` _designator_ matches the nonterminal in the Rust\n+syntax named by _designator_. Valid designators are:\n+\n+* `item`: an [item]\n+* `block`: a [block]\n+* `stmt`: a [statement]\n+* `pat`: a [pattern]\n+* `expr`: an [expression]\n+* `ty`: a [type]\n+* `ident`: an [identifier]\n+* `path`: a [path]\n+* `tt`: a token tree (a single [token] by matching `()`, `[]`, or `{}`)\n+* `meta`: the contents of an [attribute]\n+\n+[item]: items.html\n+[block]: expressions.html#block-expressions\n+[statement]: statements.html\n+[pattern]: expressions.html#match-expressions\n+[expression]: expressions.html\n+[type]: types.html\n+[identifier]: identifiers.html\n+[path]: paths.html\n+[token]: tokens.html\n+[attribute]: attributes.html\n+\n+In the transcriber, the\n+designator is already known, and so only the name of a matched nonterminal comes\n+after the dollar sign.\n+\n+In both the matcher and transcriber, the Kleene star-like operator indicates\n+repetition. The Kleene star operator consists of `$` and parentheses, optionally\n+followed by a separator token, followed by `*` or `+`. `*` means zero or more\n+repetitions, `+` means at least one repetition. The parentheses are not matched or\n+transcribed. On the matcher side, a name is bound to _all_ of the names it\n+matches, in a structure that mimics the structure of the repetition encountered\n+on a successful match. The job of the transcriber is to sort that structure\n+out.\n+\n+The rules for transcription of these repetitions are called \"Macro By Example\".\n+Essentially, one \"layer\" of repetition is discharged at a time, and all of them\n+must be discharged by the time a name is transcribed. Therefore, `( $( $i:ident\n+),* ) => ( $i )` is an invalid macro, but `( $( $i:ident ),* ) => ( $( $i:ident\n+),*  )` is acceptable (if trivial).\n+\n+When Macro By Example encounters a repetition, it examines all of the `$`\n+_name_ s that occur in its body. At the \"current layer\", they all must repeat\n+the same number of times, so ` ( $( $i:ident ),* ; $( $j:ident ),* ) => ( $(\n+($i,$j) ),* )` is valid if given the argument `(a,b,c ; d,e,f)`, but not\n+`(a,b,c ; d,e)`. The repetition walks through the choices at that layer in\n+lockstep, so the former input transcribes to `(a,d), (b,e), (c,f)`.\n+\n+Nested repetitions are allowed.\n+\n+### Parsing limitations\n+\n+The parser used by the macro system is reasonably powerful, but the parsing of\n+Rust syntax is restricted in two ways:\n+\n+1. Macro definitions are required to include suitable separators after parsing\n+   expressions and other bits of the Rust grammar. This implies that\n+   a macro definition like `$i:expr [ , ]` is not legal, because `[` could be part\n+   of an expression. A macro definition like `$i:expr,` or `$i:expr;` would be legal,\n+   however, because `,` and `;` are legal separators. See [RFC 550] for more information.\n+2. The parser must have eliminated all ambiguity by the time it reaches a `$`\n+   _name_ `:` _designator_. This requirement most often affects name-designator\n+   pairs when they occur at the beginning of, or immediately after, a `$(...)*`;\n+   requiring a distinctive token in front can solve the problem.\n+\n+[RFC 550]: https://github.com/rust-lang/rfcs/blob/master/text/0550-macro-future-proofing.md"}, {"sha": "9ec5f2d6945e5bd0b749264fd045daa2f08f1fc6", "filename": "src/doc/reference/src/macros.md", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Fdoc%2Freference%2Fsrc%2Fmacros.md", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Fdoc%2Freference%2Fsrc%2Fmacros.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference%2Fsrc%2Fmacros.md?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -0,0 +1,17 @@\n+# Macros\n+\n+A number of minor features of Rust are not central enough to have their own\n+syntax, and yet are not implementable as functions. Instead, they are given\n+names, and invoked through a consistent syntax: `some_extension!(...)`.\n+\n+Users of `rustc` can define new macros in two ways:\n+\n+* [Macros] define new syntax in a higher-level,\n+  declarative way.\n+* [Procedural Macros] can be used to implement custom derive.\n+\n+And one unstable way: [compiler plugins].\n+\n+[Macros]: ../book/macros.html\n+[Procedural Macros]: ../book/procedural-macros.html\n+[compiler plugins]: ../book/compiler-plugins.html"}, {"sha": "24addb1dd39d433306f0f729909b4f1dd0530c65", "filename": "src/doc/reference/src/memory-allocation-and-lifetime.md", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Fdoc%2Freference%2Fsrc%2Fmemory-allocation-and-lifetime.md", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Fdoc%2Freference%2Fsrc%2Fmemory-allocation-and-lifetime.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference%2Fsrc%2Fmemory-allocation-and-lifetime.md?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -0,0 +1,13 @@\n+# Memory allocation and lifetime\n+\n+The _items_ of a program are those functions, modules and types that have their\n+value calculated at compile-time and stored uniquely in the memory image of the\n+rust process. Items are neither dynamically allocated nor freed.\n+\n+The _heap_ is a general term that describes boxes.  The lifetime of an\n+allocation in the heap depends on the lifetime of the box values pointing to\n+it. Since box values may themselves be passed in and out of frames, or stored\n+in the heap, heap allocations may outlive the frame they are allocated within.\n+An allocation in the heap is guaranteed to reside at a single location in the\n+heap for the whole lifetime of the allocation - it will never be relocated as\n+a result of moving a box value."}, {"sha": "aa57ae6ae9bead48da8e96697c73058d78958387", "filename": "src/doc/reference/src/memory-model.md", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Fdoc%2Freference%2Fsrc%2Fmemory-model.md", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Fdoc%2Freference%2Fsrc%2Fmemory-model.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference%2Fsrc%2Fmemory-model.md?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -0,0 +1,10 @@\n+# Memory model\n+\n+A Rust program's memory consists of a static set of *items* and a *heap*.\n+Immutable portions of the heap may be safely shared between threads, mutable\n+portions may not be safely shared, but several mechanisms for effectively-safe\n+sharing of mutable values, built on unsafe code but enforcing a safe locking\n+discipline, exist in the standard library.\n+\n+Allocations in the stack consist of *variables*, and allocations in the heap\n+consist of *boxes*."}, {"sha": "aed07ef2961a56205cd0831edff59d9e24ae1e25", "filename": "src/doc/reference/src/memory-ownership.md", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Fdoc%2Freference%2Fsrc%2Fmemory-ownership.md", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Fdoc%2Freference%2Fsrc%2Fmemory-ownership.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference%2Fsrc%2Fmemory-ownership.md?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -0,0 +1,4 @@\n+## Memory ownership\n+\n+When a stack frame is exited, its local allocations are all released, and its\n+references to boxes are dropped."}, {"sha": "642bff440ad93a9265d03cbbf536b1677de922f9", "filename": "src/doc/reference/src/notation.md", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Fdoc%2Freference%2Fsrc%2Fnotation.md", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Fdoc%2Freference%2Fsrc%2Fnotation.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference%2Fsrc%2Fnotation.md?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -0,0 +1 @@\n+# Notation"}, {"sha": "e9fd07e5664b9c2046ed49ac1dda4e1b76582ca6", "filename": "src/doc/reference/src/paths.md", "status": "added", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Fdoc%2Freference%2Fsrc%2Fpaths.md", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Fdoc%2Freference%2Fsrc%2Fpaths.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference%2Fsrc%2Fpaths.md?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -0,0 +1,105 @@\n+# Paths\n+\n+A _path_ is a sequence of one or more path components _logically_ separated by\n+a namespace qualifier (`::`). If a path consists of only one component, it may\n+refer to either an [item] or a [variable] in a local control\n+scope. If a path has multiple components, it refers to an item.\n+\n+[item]: items.html\n+[variable]: variables.html\n+\n+Every item has a _canonical path_ within its crate, but the path naming an item\n+is only meaningful within a given crate. There is no global namespace across\n+crates; an item's canonical path merely identifies it within the crate.\n+\n+Two examples of simple paths consisting of only identifier components:\n+\n+```{.ignore}\n+x;\n+x::y::z;\n+```\n+\n+Path components are usually [identifiers], but they may\n+also include angle-bracket-enclosed lists of type arguments. In\n+[expression] context, the type argument list is given\n+after a `::` namespace qualifier in order to disambiguate it from a\n+relational expression involving the less-than symbol (`<`). In type\n+expression context, the final namespace qualifier is omitted.\n+\n+[identifiers]: identifiers.html\n+[expression]: expressions.html\n+\n+Two examples of paths with type arguments:\n+\n+```rust\n+# struct HashMap<K, V>(K,V);\n+# fn f() {\n+# fn id<T>(t: T) -> T { t }\n+type T = HashMap<i32,String>; // Type arguments used in a type expression\n+let x  = id::<i32>(10);       // Type arguments used in a call expression\n+# }\n+```\n+\n+Paths can be denoted with various leading qualifiers to change the meaning of\n+how it is resolved:\n+\n+* Paths starting with `::` are considered to be global paths where the\n+  components of the path start being resolved from the crate root. Each\n+  identifier in the path must resolve to an item.\n+\n+```rust\n+mod a {\n+    pub fn foo() {}\n+}\n+mod b {\n+    pub fn foo() {\n+        ::a::foo(); // call a's foo function\n+    }\n+}\n+# fn main() {}\n+```\n+\n+* Paths starting with the keyword `super` begin resolution relative to the\n+  parent module. Each further identifier must resolve to an item.\n+\n+```rust\n+mod a {\n+    pub fn foo() {}\n+}\n+mod b {\n+    pub fn foo() {\n+        super::a::foo(); // call a's foo function\n+    }\n+}\n+# fn main() {}\n+```\n+\n+* Paths starting with the keyword `self` begin resolution relative to the\n+  current module. Each further identifier must resolve to an item.\n+\n+```rust\n+fn foo() {}\n+fn bar() {\n+    self::foo();\n+}\n+# fn main() {}\n+```\n+\n+Additionally keyword `super` may be repeated several times after the first\n+`super` or `self` to refer to ancestor modules.\n+\n+```rust\n+mod a {\n+    fn foo() {}\n+\n+    mod b {\n+        mod c {\n+            fn foo() {\n+                super::super::foo(); // call a's foo function\n+                self::super::super::foo(); // call a's foo function\n+            }\n+        }\n+    }\n+}\n+# fn main() {}\n+```"}, {"sha": "b1fd35653d9e709872898c7bffdfd08ddcb41418", "filename": "src/doc/reference/src/procedural-macros.md", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Fdoc%2Freference%2Fsrc%2Fprocedural-macros.md", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Fdoc%2Freference%2Fsrc%2Fprocedural-macros.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference%2Fsrc%2Fprocedural-macros.md?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -0,0 +1,23 @@\n+## Procedural Macros\n+\n+\"Procedural macros\" are the second way to implement a macro. For now, the only\n+thing they can be used for is to implement derive on your own types. See\n+[the book][procedural macros] for a tutorial.\n+\n+[procedural macros]: ../book/procedural-macros.html\n+\n+Procedural macros involve a few different parts of the language and its\n+standard libraries. First is the `proc_macro` crate, included with Rust,\n+that defines an interface for building a procedural macro. The\n+`#[proc_macro_derive(Foo)]` attribute is used to mark the deriving\n+function. This function must have the type signature:\n+\n+```rust,ignore\n+use proc_macro::TokenStream;\n+\n+#[proc_macro_derive(Hello)]\n+pub fn hello_world(input: TokenStream) -> TokenStream\n+```\n+\n+Finally, procedural macros must be in their own crate, with the `proc-macro`\n+crate type."}, {"sha": "ae3eebe392d1dcfda0237a58a0b1ec2d608bf73a", "filename": "src/doc/reference/src/special-traits.md", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Fdoc%2Freference%2Fsrc%2Fspecial-traits.md", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Fdoc%2Freference%2Fsrc%2Fspecial-traits.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference%2Fsrc%2Fspecial-traits.md?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -0,0 +1,3 @@\n+# Special traits\n+\n+Several traits define special evaluation behavior."}, {"sha": "bb59108f17f321e83ebe25a4b699797ed9b2d86c", "filename": "src/doc/reference/src/statements-and-expressions.md", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Fdoc%2Freference%2Fsrc%2Fstatements-and-expressions.md", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Fdoc%2Freference%2Fsrc%2Fstatements-and-expressions.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference%2Fsrc%2Fstatements-and-expressions.md?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -0,0 +1,11 @@\n+# Statements and expressions\n+\n+Rust is _primarily_ an expression language. This means that most forms of\n+value-producing or effect-causing evaluation are directed by the uniform syntax\n+category of _expressions_. Each kind of expression can typically _nest_ within\n+each other kind of expression, and rules for evaluation of expressions involve\n+specifying both the value produced by the expression and the order in which its\n+sub-expressions are themselves evaluated.\n+\n+In contrast, statements in Rust serve _mostly_ to contain and explicitly\n+sequence expression evaluation."}, {"sha": "ebb7d8bfa7cd057dcf0fe9f10b45f0267296848a", "filename": "src/doc/reference/src/statements.md", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Fdoc%2Freference%2Fsrc%2Fstatements.md", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Fdoc%2Freference%2Fsrc%2Fstatements.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference%2Fsrc%2Fstatements.md?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -0,0 +1,42 @@\n+# Statements\n+\n+A _statement_ is a component of a block, which is in turn a component of an\n+outer [expression](expressions.html) or [function](items.html#functions).\n+\n+Rust has two kinds of statement: [declaration\n+statements](#declaration-statements) and [expression\n+statements](#expression-statements).\n+\n+## Declaration statements\n+\n+A _declaration statement_ is one that introduces one or more *names* into the\n+enclosing statement block. The declared names may denote new variables or new\n+items.\n+\n+### Item declarations\n+\n+An _item declaration statement_ has a syntactic form identical to an\n+[item](items.html) declaration within a module. Declaring an item &mdash; a\n+function, enumeration, struct, type, static, trait, implementation or module\n+&mdash; locally within a statement block is simply a way of restricting its\n+scope to a narrow region containing all of its uses; it is otherwise identical\n+in meaning to declaring the item outside the statement block.\n+\n+> **Note**: there is no implicit capture of the function's dynamic environment when\n+> declaring a function-local item.\n+\n+### `let` statements\n+\n+A _`let` statement_ introduces a new set of variables, given by a pattern. The\n+pattern may be followed by a type annotation, and/or an initializer expression.\n+When no type annotation is given, the compiler will infer the type, or signal\n+an error if insufficient type information is available for definite inference.\n+Any variables introduced by a variable declaration are visible from the point of\n+declaration until the end of the enclosing block scope.\n+\n+## Expression statements\n+\n+An _expression statement_ is one that evaluates an [expression](expressions.html)\n+and ignores its result. The type of an expression statement `e;` is always\n+`()`, regardless of the type of `e`. As a rule, an expression statement's\n+purpose is to trigger the effects of evaluating its expression."}, {"sha": "4e9742e3bbb805db5d2d77d712d04ee4fa422d6a", "filename": "src/doc/reference/src/string-table-productions.md", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Fdoc%2Freference%2Fsrc%2Fstring-table-productions.md", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Fdoc%2Freference%2Fsrc%2Fstring-table-productions.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference%2Fsrc%2Fstring-table-productions.md?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -0,0 +1,18 @@\n+# String table productions\n+\n+Some rules in the grammar &mdash; notably [unary\n+operators], [binary operators], and [keywords][keywords] &mdash; are\n+given in a simplified form: as a listing of a table of unquoted, printable\n+whitespace-separated strings. These cases form a subset of the rules regarding\n+the [token][tokens] rule, and are assumed to be the result of a\n+lexical-analysis phase feeding the parser, driven by a DFA, operating over the\n+disjunction of all such string table entries.\n+\n+When such a string enclosed in double-quotes (`\"`) occurs inside the grammar,\n+it is an implicit reference to a single member of such a string table\n+production. See [tokens] for more information.\n+\n+[binary operators]: expressions.html#binary-operator-expressions\n+[keywords]: ../grammar.html#keywords\n+[tokens]: tokens.html\n+[unary operators]: expressions.html#unary-operator-expressions\n\\ No newline at end of file"}, {"sha": "a43b041a69338e584d7e4369e30f226375b73a6c", "filename": "src/doc/reference/src/subtyping.md", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Fdoc%2Freference%2Fsrc%2Fsubtyping.md", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Fdoc%2Freference%2Fsrc%2Fsubtyping.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference%2Fsrc%2Fsubtyping.md?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -0,0 +1,19 @@\n+# Subtyping\n+\n+Subtyping is implicit and can occur at any stage in type checking or\n+inference. Subtyping in Rust is very restricted and occurs only due to\n+variance with respect to lifetimes and between types with higher ranked\n+lifetimes. If we were to erase lifetimes from types, then the only subtyping\n+would be due to type equality.\n+\n+Consider the following example: string literals always have `'static`\n+lifetime. Nevertheless, we can assign `s` to `t`:\n+\n+```\n+fn bar<'a>() {\n+    let s: &'static str = \"hi\";\n+    let t: &'a str = s;\n+}\n+```\n+Since `'static` \"lives longer\" than `'a`, `&'static str` is a subtype of\n+`&'a str`."}, {"sha": "d593165e48d585a2bee9a78ec0689e36757e8825", "filename": "src/doc/reference/src/the-copy-trait.md", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Fdoc%2Freference%2Fsrc%2Fthe-copy-trait.md", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Fdoc%2Freference%2Fsrc%2Fthe-copy-trait.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference%2Fsrc%2Fthe-copy-trait.md?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -0,0 +1,4 @@\n+# The `Copy` trait\n+\n+The `Copy` trait changes the semantics of a type implementing it. Values whose\n+type implements `Copy` are copied rather than moved upon assignment."}, {"sha": "a4d84ab83ea673261f4b8a7235278859d8a30998", "filename": "src/doc/reference/src/the-deref-trait.md", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Fdoc%2Freference%2Fsrc%2Fthe-deref-trait.md", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Fdoc%2Freference%2Fsrc%2Fthe-deref-trait.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference%2Fsrc%2Fthe-deref-trait.md?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -0,0 +1,7 @@\n+# The `Deref` trait\n+\n+The `Deref<Target = U>` trait allows a type to implicitly implement all the methods\n+of the type `U`. When attempting to resolve a method call, the compiler will search\n+the top-level type for the implementation of the called method. If no such method is\n+found, `.deref()` is called and the compiler continues to search for the method\n+implementation in the returned type `U`."}, {"sha": "42bf6eb0f20148cdd0e06382df43a6b65285394a", "filename": "src/doc/reference/src/the-drop-trait.md", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Fdoc%2Freference%2Fsrc%2Fthe-drop-trait.md", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Fdoc%2Freference%2Fsrc%2Fthe-drop-trait.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference%2Fsrc%2Fthe-drop-trait.md?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -0,0 +1,4 @@\n+# The `Drop` trait\n+\n+The `Drop` trait provides a destructor, to be run whenever a value of this type\n+is to be destroyed."}, {"sha": "9ec669289a5676d3213c01812d89a8a36c42025f", "filename": "src/doc/reference/src/the-send-trait.md", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Fdoc%2Freference%2Fsrc%2Fthe-send-trait.md", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Fdoc%2Freference%2Fsrc%2Fthe-send-trait.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference%2Fsrc%2Fthe-send-trait.md?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -0,0 +1,4 @@\n+# The `Send` trait\n+\n+The `Send` trait indicates that a value of this type is safe to send from one\n+thread to another."}, {"sha": "a2aa17c95f295190fa1c6777daaa0c2c09c28759", "filename": "src/doc/reference/src/the-sized-trait.md", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Fdoc%2Freference%2Fsrc%2Fthe-sized-trait.md", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Fdoc%2Freference%2Fsrc%2Fthe-sized-trait.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference%2Fsrc%2Fthe-sized-trait.md?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -0,0 +1,3 @@\n+# The `Sized` trait\n+\n+The `Sized` trait indicates that the size of this type is known at compile-time."}, {"sha": "fd9365134b29214b33d8100ef74da6ef70cc1ed9", "filename": "src/doc/reference/src/the-sync-trait.md", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Fdoc%2Freference%2Fsrc%2Fthe-sync-trait.md", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Fdoc%2Freference%2Fsrc%2Fthe-sync-trait.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference%2Fsrc%2Fthe-sync-trait.md?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -0,0 +1,4 @@\n+# The `Sync` trait\n+\n+The `Sync` trait indicates that a value of this type is safe to share between\n+multiple threads."}, {"sha": "ee92e2f8710a908a712e94086b6f0ff968bc883b", "filename": "src/doc/reference/src/theme/book.css", "status": "added", "additions": 798, "deletions": 0, "changes": 798, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Fdoc%2Freference%2Fsrc%2Ftheme%2Fbook.css", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Fdoc%2Freference%2Fsrc%2Ftheme%2Fbook.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference%2Fsrc%2Ftheme%2Fbook.css?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -0,0 +1,798 @@\n+html,\n+body {\n+  font-family: \"Open Sans\", sans-serif;\n+  color: #333;\n+}\n+.left {\n+  float: left;\n+}\n+.right {\n+  float: right;\n+}\n+.hidden {\n+  display: none;\n+}\n+h2,\n+h3 {\n+  margin-top: 2.5em;\n+}\n+h4,\n+h5 {\n+  margin-top: 2em;\n+}\n+.header + .header h3,\n+.header + .header h4,\n+.header + .header h5 {\n+  margin-top: 1em;\n+}\n+table {\n+  margin: 0 auto;\n+  border-collapse: collapse;\n+}\n+table td {\n+  padding: 3px 20px;\n+  border: 1px solid;\n+}\n+table thead td {\n+  font-weight: 700;\n+}\n+.sidebar {\n+  position: absolute;\n+  left: 0;\n+  top: 0;\n+  bottom: 0;\n+  width: 300px;\n+  overflow-y: auto;\n+  padding: 10px 10px;\n+  font-size: 0.875em;\n+  -webkit-box-sizing: border-box;\n+  -moz-box-sizing: border-box;\n+  box-sizing: border-box;\n+  -webkit-overflow-scrolling: touch;\n+  -webkit-transition: left 0.5s;\n+  -moz-transition: left 0.5s;\n+  -o-transition: left 0.5s;\n+  -ms-transition: left 0.5s;\n+  transition: left 0.5s;\n+}\n+@media only screen and (max-width: 1060px) {\n+  .sidebar {\n+    left: -300px;\n+  }\n+}\n+.sidebar code {\n+  line-height: 2em;\n+}\n+.sidebar-hidden .sidebar {\n+  left: -300px;\n+}\n+.sidebar-visible .sidebar {\n+  left: 0;\n+}\n+.chapter {\n+  list-style: none outside none;\n+  padding-left: 0;\n+  line-height: 1.9em;\n+}\n+.chapter li a {\n+  padding: 5px 0;\n+  text-decoration: none;\n+}\n+.chapter li a:hover {\n+  text-decoration: none;\n+}\n+.chapter .spacer {\n+  width: 100%;\n+  height: 3px;\n+  margin: 10px 0px;\n+}\n+.section {\n+  list-style: none outside none;\n+  padding-left: 20px;\n+  line-height: 2.5em;\n+}\n+.section li {\n+  -o-text-overflow: ellipsis;\n+  text-overflow: ellipsis;\n+  overflow: hidden;\n+  white-space: nowrap;\n+}\n+.page-wrapper {\n+  position: absolute;\n+  overflow-y: auto;\n+  left: 315px;\n+  right: 0;\n+  top: 0;\n+  bottom: 0;\n+  -webkit-box-sizing: border-box;\n+  -moz-box-sizing: border-box;\n+  box-sizing: border-box;\n+  -webkit-overflow-scrolling: touch;\n+  min-height: 100%;\n+  -webkit-transition: left 0.5s;\n+  -moz-transition: left 0.5s;\n+  -o-transition: left 0.5s;\n+  -ms-transition: left 0.5s;\n+  transition: left 0.5s;\n+}\n+@media only screen and (max-width: 1060px) {\n+  .page-wrapper {\n+    left: 15px;\n+    padding-right: 15px;\n+  }\n+}\n+.sidebar-hidden .page-wrapper {\n+  left: 15px;\n+}\n+.sidebar-visible .page-wrapper {\n+  left: 315px;\n+}\n+.page {\n+  position: absolute;\n+  top: 0;\n+  right: 0;\n+  left: 0;\n+  bottom: 0;\n+  padding-right: 15px;\n+  overflow-y: auto;\n+}\n+.content {\n+  margin-left: auto;\n+  margin-right: auto;\n+  max-width: 750px;\n+  padding-bottom: 50px;\n+}\n+.content a {\n+  text-decoration: none;\n+}\n+.content a:hover {\n+  text-decoration: underline;\n+}\n+.content img {\n+  max-width: 100%;\n+}\n+.menu-bar {\n+  position: relative;\n+  height: 50px;\n+}\n+.menu-bar i {\n+  position: relative;\n+  margin: 0 10px;\n+  z-index: 10;\n+  line-height: 50px;\n+  -webkit-transition: color 0.5s;\n+  -moz-transition: color 0.5s;\n+  -o-transition: color 0.5s;\n+  -ms-transition: color 0.5s;\n+  transition: color 0.5s;\n+}\n+.menu-bar i:hover {\n+  cursor: pointer;\n+}\n+.menu-bar .left-buttons {\n+  float: left;\n+}\n+.menu-bar .right-buttons {\n+  float: right;\n+}\n+.menu-title {\n+  display: inline-block;\n+  font-weight: 200;\n+  font-size: 20px;\n+  line-height: 50px;\n+  position: absolute;\n+  top: 0;\n+  left: 0;\n+  right: 0;\n+  bottom: 0;\n+  text-align: center;\n+  margin: 0;\n+  opacity: 0;\n+  -ms-filter: \"progid:DXImageTransform.Microsoft.Alpha(Opacity=0)\";\n+  filter: alpha(opacity=0);\n+  -webkit-transition: opacity 0.5s ease-in-out;\n+  -moz-transition: opacity 0.5s ease-in-out;\n+  -o-transition: opacity 0.5s ease-in-out;\n+  -ms-transition: opacity 0.5s ease-in-out;\n+  transition: opacity 0.5s ease-in-out;\n+}\n+.menu-bar:hover .menu-title {\n+  opacity: 1;\n+  -ms-filter: none;\n+  filter: none;\n+}\n+.nav-chapters {\n+  font-size: 2.5em;\n+  text-align: center;\n+  text-decoration: none;\n+  position: absolute;\n+  top: 50px /* Height of menu-bar */;\n+  bottom: 0;\n+  margin: 0;\n+  max-width: 150px;\n+  min-width: 90px;\n+  display: -webkit-box;\n+  display: -moz-box;\n+  display: -webkit-flex;\n+  display: -ms-flexbox;\n+  display: box;\n+  display: flex;\n+  -webkit-box-pack: center;\n+  -moz-box-pack: center;\n+  -o-box-pack: center;\n+  -ms-flex-pack: center;\n+  -webkit-justify-content: center;\n+  justify-content: center;\n+  -ms-flex-line-pack: center;\n+  -webkit-align-content: center;\n+  align-content: center;\n+  -webkit-box-orient: vertical;\n+  -moz-box-orient: vertical;\n+  -o-box-orient: vertical;\n+  -webkit-flex-direction: column;\n+  -ms-flex-direction: column;\n+  flex-direction: column;\n+  -webkit-transition: color 0.5s;\n+  -moz-transition: color 0.5s;\n+  -o-transition: color 0.5s;\n+  -ms-transition: color 0.5s;\n+  transition: color 0.5s;\n+}\n+.mobile-nav-chapters {\n+  display: none;\n+}\n+.nav-chapters:hover {\n+  text-decoration: none;\n+}\n+.previous {\n+  left: 0;\n+}\n+.next {\n+  right: 15px;\n+}\n+.theme-popup {\n+  position: relative;\n+  left: 10px;\n+  z-index: 1000;\n+  -webkit-border-radius: 4px;\n+  border-radius: 4px;\n+  font-size: 0.7em;\n+}\n+.theme-popup .theme {\n+  margin: 0;\n+  padding: 2px 10px;\n+  line-height: 25px;\n+  white-space: nowrap;\n+}\n+.theme-popup .theme:hover:first-child {\n+  border-top-left-radius: inherit;\n+  border-top-right-radius: inherit;\n+}\n+.theme-popup .theme:hover:last-child {\n+  border-bottom-left-radius: inherit;\n+  border-bottom-right-radius: inherit;\n+}\n+\n+@media only screen and (max-width: 1250px) {\n+  .nav-chapters {\n+    display: none;\n+  }\n+  .mobile-nav-chapters {\n+    font-size: 2.5em;\n+    text-align: center;\n+    text-decoration: none;\n+    max-width: 150px;\n+    min-width: 90px;\n+    -webkit-box-pack: center;\n+    -moz-box-pack: center;\n+    -o-box-pack: center;\n+    -ms-flex-pack: center;\n+    -webkit-justify-content: center;\n+    justify-content: center;\n+    -ms-flex-line-pack: center;\n+    -webkit-align-content: center;\n+    align-content: center;\n+    position: relative;\n+    display: inline-block;\n+    margin-bottom: 50px;\n+    -webkit-border-radius: 5px;\n+    border-radius: 5px;\n+  }\n+  .next {\n+    float: right;\n+  }\n+  .previous {\n+    float: left;\n+  }\n+}\n+.light {\n+  color: #333;\n+  background-color: #fff;\n+/* Inline code */\n+}\n+.light .content .header:link,\n+.light .content .header:visited {\n+  color: #333;\n+  pointer: cursor;\n+}\n+.light .content .header:link:hover,\n+.light .content .header:visited:hover {\n+  text-decoration: none;\n+}\n+.light .sidebar {\n+  background-color: #fafafa;\n+  color: #364149;\n+}\n+.light .chapter li {\n+  color: #aaa;\n+}\n+.light .chapter li a {\n+  color: #364149;\n+}\n+.light .chapter li .active,\n+.light .chapter li a:hover {\n+/* Animate color change */\n+  color: #008cff;\n+}\n+.light .chapter .spacer {\n+  background-color: #f4f4f4;\n+}\n+.light .menu-bar,\n+.light .menu-bar:visited,\n+.light .nav-chapters,\n+.light .nav-chapters:visited,\n+.light .mobile-nav-chapters,\n+.light .mobile-nav-chapters:visited {\n+  color: #ccc;\n+}\n+.light .menu-bar i:hover,\n+.light .nav-chapters:hover,\n+.light .mobile-nav-chapters i:hover {\n+  color: #333;\n+}\n+.light .mobile-nav-chapters i:hover {\n+  color: #364149;\n+}\n+.light .mobile-nav-chapters {\n+  background-color: #fafafa;\n+}\n+.light .content a:link,\n+.light a:visited {\n+  color: #4183c4;\n+}\n+.light .theme-popup {\n+  color: #333;\n+  background: #fafafa;\n+  border: 1px solid #ccc;\n+}\n+.light .theme-popup .theme:hover {\n+  background-color: #e6e6e6;\n+}\n+.light .theme-popup .default {\n+  color: #ccc;\n+}\n+.light blockquote {\n+  margin: 20px 0;\n+  padding: 0 20px;\n+  color: #333;\n+  background-color: #f2f7f9;\n+  border-top: 0.1em solid #e1edf1;\n+  border-bottom: 0.1em solid #e1edf1;\n+}\n+.light table td {\n+  border-color: #f2f2f2;\n+}\n+.light table tbody tr:nth-child(2n) {\n+  background: #f7f7f7;\n+}\n+.light table thead {\n+  background: #ccc;\n+}\n+.light table thead td {\n+  border: none;\n+}\n+.light table thead tr {\n+  border: 1px #ccc solid;\n+}\n+.light :not(pre) > .hljs {\n+  display: inline-block;\n+  vertical-align: middle;\n+  padding: 0.1em 0.3em;\n+  -webkit-border-radius: 3px;\n+  border-radius: 3px;\n+}\n+.light pre {\n+  position: relative;\n+}\n+.light pre > .buttons {\n+  position: absolute;\n+  right: 5px;\n+  top: 5px;\n+  color: #364149;\n+  cursor: pointer;\n+}\n+.light pre > .buttons :hover {\n+  color: #008cff;\n+}\n+.light pre > .buttons i {\n+  margin-left: 8px;\n+}\n+.light pre > .result {\n+  margin-top: 10px;\n+}\n+.coal {\n+  color: #98a3ad;\n+  background-color: #141617;\n+/* Inline code */\n+}\n+.coal .content .header:link,\n+.coal .content .header:visited {\n+  color: #98a3ad;\n+  pointer: cursor;\n+}\n+.coal .content .header:link:hover,\n+.coal .content .header:visited:hover {\n+  text-decoration: none;\n+}\n+.coal .sidebar {\n+  background-color: #292c2f;\n+  color: #a1adb8;\n+}\n+.coal .chapter li {\n+  color: #505254;\n+}\n+.coal .chapter li a {\n+  color: #a1adb8;\n+}\n+.coal .chapter li .active,\n+.coal .chapter li a:hover {\n+/* Animate color change */\n+  color: #3473ad;\n+}\n+.coal .chapter .spacer {\n+  background-color: #393939;\n+}\n+.coal .menu-bar,\n+.coal .menu-bar:visited,\n+.coal .nav-chapters,\n+.coal .nav-chapters:visited,\n+.coal .mobile-nav-chapters,\n+.coal .mobile-nav-chapters:visited {\n+  color: #43484d;\n+}\n+.coal .menu-bar i:hover,\n+.coal .nav-chapters:hover,\n+.coal .mobile-nav-chapters i:hover {\n+  color: #b3c0cc;\n+}\n+.coal .mobile-nav-chapters i:hover {\n+  color: #a1adb8;\n+}\n+.coal .mobile-nav-chapters {\n+  background-color: #292c2f;\n+}\n+.coal .content a:link,\n+.coal a:visited {\n+  color: #2b79a2;\n+}\n+.coal .theme-popup {\n+  color: #98a3ad;\n+  background: #141617;\n+  border: 1px solid #43484d;\n+}\n+.coal .theme-popup .theme:hover {\n+  background-color: #1f2124;\n+}\n+.coal .theme-popup .default {\n+  color: #43484d;\n+}\n+.coal blockquote {\n+  margin: 20px 0;\n+  padding: 0 20px;\n+  color: #98a3ad;\n+  background-color: #242637;\n+  border-top: 0.1em solid #2c2f44;\n+  border-bottom: 0.1em solid #2c2f44;\n+}\n+.coal table td {\n+  border-color: #1f2223;\n+}\n+.coal table tbody tr:nth-child(2n) {\n+  background: #1b1d1e;\n+}\n+.coal table thead {\n+  background: #3f4649;\n+}\n+.coal table thead td {\n+  border: none;\n+}\n+.coal table thead tr {\n+  border: 1px #3f4649 solid;\n+}\n+.coal :not(pre) > .hljs {\n+  display: inline-block;\n+  vertical-align: middle;\n+  padding: 0.1em 0.3em;\n+  -webkit-border-radius: 3px;\n+  border-radius: 3px;\n+}\n+.coal pre {\n+  position: relative;\n+}\n+.coal pre > .buttons {\n+  position: absolute;\n+  right: 5px;\n+  top: 5px;\n+  color: #a1adb8;\n+  cursor: pointer;\n+}\n+.coal pre > .buttons :hover {\n+  color: #3473ad;\n+}\n+.coal pre > .buttons i {\n+  margin-left: 8px;\n+}\n+.coal pre > .result {\n+  margin-top: 10px;\n+}\n+.navy {\n+  color: #bcbdd0;\n+  background-color: #161923;\n+/* Inline code */\n+}\n+.navy .content .header:link,\n+.navy .content .header:visited {\n+  color: #bcbdd0;\n+  pointer: cursor;\n+}\n+.navy .content .header:link:hover,\n+.navy .content .header:visited:hover {\n+  text-decoration: none;\n+}\n+.navy .sidebar {\n+  background-color: #282d3f;\n+  color: #c8c9db;\n+}\n+.navy .chapter li {\n+  color: #505274;\n+}\n+.navy .chapter li a {\n+  color: #c8c9db;\n+}\n+.navy .chapter li .active,\n+.navy .chapter li a:hover {\n+/* Animate color change */\n+  color: #2b79a2;\n+}\n+.navy .chapter .spacer {\n+  background-color: #2d334f;\n+}\n+.navy .menu-bar,\n+.navy .menu-bar:visited,\n+.navy .nav-chapters,\n+.navy .nav-chapters:visited,\n+.navy .mobile-nav-chapters,\n+.navy .mobile-nav-chapters:visited {\n+  color: #737480;\n+}\n+.navy .menu-bar i:hover,\n+.navy .nav-chapters:hover,\n+.navy .mobile-nav-chapters i:hover {\n+  color: #b7b9cc;\n+}\n+.navy .mobile-nav-chapters i:hover {\n+  color: #c8c9db;\n+}\n+.navy .mobile-nav-chapters {\n+  background-color: #282d3f;\n+}\n+.navy .content a:link,\n+.navy a:visited {\n+  color: #2b79a2;\n+}\n+.navy .theme-popup {\n+  color: #bcbdd0;\n+  background: #161923;\n+  border: 1px solid #737480;\n+}\n+.navy .theme-popup .theme:hover {\n+  background-color: #282e40;\n+}\n+.navy .theme-popup .default {\n+  color: #737480;\n+}\n+.navy blockquote {\n+  margin: 20px 0;\n+  padding: 0 20px;\n+  color: #bcbdd0;\n+  background-color: #262933;\n+  border-top: 0.1em solid #2f333f;\n+  border-bottom: 0.1em solid #2f333f;\n+}\n+.navy table td {\n+  border-color: #1f2331;\n+}\n+.navy table tbody tr:nth-child(2n) {\n+  background: #1b1f2b;\n+}\n+.navy table thead {\n+  background: #39415b;\n+}\n+.navy table thead td {\n+  border: none;\n+}\n+.navy table thead tr {\n+  border: 1px #39415b solid;\n+}\n+.navy :not(pre) > .hljs {\n+  display: inline-block;\n+  vertical-align: middle;\n+  padding: 0.1em 0.3em;\n+  -webkit-border-radius: 3px;\n+  border-radius: 3px;\n+}\n+.navy pre {\n+  position: relative;\n+}\n+.navy pre > .buttons {\n+  position: absolute;\n+  right: 5px;\n+  top: 5px;\n+  color: #c8c9db;\n+  cursor: pointer;\n+}\n+.navy pre > .buttons :hover {\n+  color: #2b79a2;\n+}\n+.navy pre > .buttons i {\n+  margin-left: 8px;\n+}\n+.navy pre > .result {\n+  margin-top: 10px;\n+}\n+.rust {\n+  color: #262625;\n+  background-color: #e1e1db;\n+/* Inline code */\n+}\n+.rust .content .header:link,\n+.rust .content .header:visited {\n+  color: #262625;\n+  pointer: cursor;\n+}\n+.rust .content .header:link:hover,\n+.rust .content .header:visited:hover {\n+  text-decoration: none;\n+}\n+.rust .sidebar {\n+  background-color: #3b2e2a;\n+  color: #c8c9db;\n+}\n+.rust .chapter li {\n+  color: #505254;\n+}\n+.rust .chapter li a {\n+  color: #c8c9db;\n+}\n+.rust .chapter li .active,\n+.rust .chapter li a:hover {\n+/* Animate color change */\n+  color: #e69f67;\n+}\n+.rust .chapter .spacer {\n+  background-color: #45373a;\n+}\n+.rust .menu-bar,\n+.rust .menu-bar:visited,\n+.rust .nav-chapters,\n+.rust .nav-chapters:visited,\n+.rust .mobile-nav-chapters,\n+.rust .mobile-nav-chapters:visited {\n+  color: #737480;\n+}\n+.rust .menu-bar i:hover,\n+.rust .nav-chapters:hover,\n+.rust .mobile-nav-chapters i:hover {\n+  color: #262625;\n+}\n+.rust .mobile-nav-chapters i:hover {\n+  color: #c8c9db;\n+}\n+.rust .mobile-nav-chapters {\n+  background-color: #3b2e2a;\n+}\n+.rust .content a:link,\n+.rust a:visited {\n+  color: #2b79a2;\n+}\n+.rust .theme-popup {\n+  color: #262625;\n+  background: #e1e1db;\n+  border: 1px solid #b38f6b;\n+}\n+.rust .theme-popup .theme:hover {\n+  background-color: #99908a;\n+}\n+.rust .theme-popup .default {\n+  color: #737480;\n+}\n+.rust blockquote {\n+  margin: 20px 0;\n+  padding: 0 20px;\n+  color: #262625;\n+  background-color: #c1c1bb;\n+  border-top: 0.1em solid #b8b8b1;\n+  border-bottom: 0.1em solid #b8b8b1;\n+}\n+.rust table td {\n+  border-color: #d7d7cf;\n+}\n+.rust table tbody tr:nth-child(2n) {\n+  background: #dbdbd4;\n+}\n+.rust table thead {\n+  background: #b3a497;\n+}\n+.rust table thead td {\n+  border: none;\n+}\n+.rust table thead tr {\n+  border: 1px #b3a497 solid;\n+}\n+.rust :not(pre) > .hljs {\n+  display: inline-block;\n+  vertical-align: middle;\n+  padding: 0.1em 0.3em;\n+  -webkit-border-radius: 3px;\n+  border-radius: 3px;\n+}\n+.rust pre {\n+  position: relative;\n+}\n+.rust pre > .buttons {\n+  position: absolute;\n+  right: 5px;\n+  top: 5px;\n+  color: #c8c9db;\n+  cursor: pointer;\n+}\n+.rust pre > .buttons :hover {\n+  color: #e69f67;\n+}\n+.rust pre > .buttons i {\n+  margin-left: 8px;\n+}\n+.rust pre > .result {\n+  margin-top: 10px;\n+}\n+\n+@media print {\n+  #sidebar {\n+    display: none;\n+  }\n+  #page-wrapper {\n+    left: 0;\n+    overflow-y: initial;\n+  }\n+  #content {\n+    max-width: none;\n+    margin: 0;\n+    padding: 0;\n+  }\n+  #menu-bar {\n+    display: none;\n+  }\n+  .page {\n+    overflow-y: initial;\n+  }\n+  .nav-chapters {\n+    display: none;\n+  }\n+  .mobile-nav-chapters {\n+    display: none;\n+  }\n+}\n+\n+div.footnote-definition p {\n+\tdisplay: inline;\n+}"}, {"sha": "ca6cde8bd2855810b9348cbd30f2e14512bfe697", "filename": "src/doc/reference/src/tokens.md", "status": "added", "additions": 326, "deletions": 0, "changes": 326, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Fdoc%2Freference%2Fsrc%2Ftokens.md", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Fdoc%2Freference%2Fsrc%2Ftokens.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference%2Fsrc%2Ftokens.md?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -0,0 +1,326 @@\n+# Tokens\n+\n+Tokens are primitive productions in the grammar defined by regular\n+(non-recursive) languages. \"Simple\" tokens are given in [string table\n+production] form, and occur in the rest of the\n+grammar as double-quoted strings. Other tokens have exact rules given.\n+\n+[string table production]: string-table-productions.html\n+\n+## Literals\n+\n+A literal is an expression consisting of a single token, rather than a sequence\n+of tokens, that immediately and directly denotes the value it evaluates to,\n+rather than referring to it by name or some other evaluation rule. A literal is\n+a form of constant expression, so is evaluated (primarily) at compile time.\n+\n+### Examples\n+\n+#### Characters and strings\n+\n+|                                              | Example         | `#` sets   | Characters  | Escapes             |\n+|----------------------------------------------|-----------------|------------|-------------|---------------------|\n+| [Character](#character-literals)             | `'H'`           | `N/A`      | All Unicode | [Quote](#quote-escapes) & [Byte](#byte-escapes) & [Unicode](#unicode-escapes) |\n+| [String](#string-literals)                   | `\"hello\"`       | `N/A`      | All Unicode | [Quote](#quote-escapes) & [Byte](#byte-escapes) & [Unicode](#unicode-escapes) |\n+| [Raw](#raw-string-literals)                  | `r#\"hello\"#`    | `0...`     | All Unicode | `N/A`                                                      |\n+| [Byte](#byte-literals)                       | `b'H'`          | `N/A`      | All ASCII   | [Quote](#quote-escapes) & [Byte](#byte-escapes)                               |\n+| [Byte string](#byte-string-literals)         | `b\"hello\"`      | `N/A`      | All ASCII   | [Quote](#quote-escapes) & [Byte](#byte-escapes)                               |\n+| [Raw byte string](#raw-byte-string-literals) | `br#\"hello\"#`   | `0...`     | All ASCII   | `N/A`                                                      |\n+\n+#### Byte escapes\n+\n+|   | Name |\n+|---|------|\n+| `\\x7F` | 8-bit character code (exactly 2 digits) |\n+| `\\n` | Newline |\n+| `\\r` | Carriage return |\n+| `\\t` | Tab |\n+| `\\\\` | Backslash |\n+| `\\0` | Null |\n+\n+#### Unicode escapes\n+\n+|   | Name |\n+|---|------|\n+| `\\u{7FFF}` | 24-bit Unicode character code (up to 6 digits) |\n+\n+#### Quote escapes\n+\n+|   | Name |\n+|---|------|\n+| `\\'` | Single quote |\n+| `\\\"` | Double quote |\n+\n+#### Numbers\n+\n+| [Number literals](#number-literals)`*` | Example | Exponentiation | Suffixes |\n+|----------------------------------------|---------|----------------|----------|\n+| Decimal integer | `98_222` | `N/A` | Integer suffixes |\n+| Hex integer | `0xff` | `N/A` | Integer suffixes |\n+| Octal integer | `0o77` | `N/A` | Integer suffixes |\n+| Binary integer | `0b1111_0000` | `N/A` | Integer suffixes |\n+| Floating-point | `123.0E+77` | `Optional` | Floating-point suffixes |\n+\n+`*` All number literals allow `_` as a visual separator: `1_234.0E+18f64`\n+\n+#### Suffixes\n+\n+| Integer | Floating-point |\n+|---------|----------------|\n+| `u8`, `i8`, `u16`, `i16`, `u32`, `i32`, `u64`, `i64`, `isize`, `usize` | `f32`, `f64` |\n+\n+### Character and string literals\n+\n+#### Character literals\n+\n+A _character literal_ is a single Unicode character enclosed within two\n+`U+0027` (single-quote) characters, with the exception of `U+0027` itself,\n+which must be _escaped_ by a preceding `U+005C` character (`\\`).\n+\n+#### String literals\n+\n+A _string literal_ is a sequence of any Unicode characters enclosed within two\n+`U+0022` (double-quote) characters, with the exception of `U+0022` itself,\n+which must be _escaped_ by a preceding `U+005C` character (`\\`).\n+\n+Line-break characters are allowed in string literals. Normally they represent\n+themselves (i.e. no translation), but as a special exception, when an unescaped\n+`U+005C` character (`\\`) occurs immediately before the newline (`U+000A`), the\n+`U+005C` character, the newline, and all whitespace at the beginning of the\n+next line are ignored. Thus `a` and `b` are equal:\n+\n+```rust\n+let a = \"foobar\";\n+let b = \"foo\\\n+         bar\";\n+\n+assert_eq!(a,b);\n+```\n+\n+#### Character escapes\n+\n+Some additional _escapes_ are available in either character or non-raw string\n+literals. An escape starts with a `U+005C` (`\\`) and continues with one of the\n+following forms:\n+\n+* An _8-bit code point escape_ starts with `U+0078` (`x`) and is\n+  followed by exactly two _hex digits_. It denotes the Unicode code point\n+  equal to the provided hex value.\n+* A _24-bit code point escape_ starts with `U+0075` (`u`) and is followed\n+  by up to six _hex digits_ surrounded by braces `U+007B` (`{`) and `U+007D`\n+  (`}`). It denotes the Unicode code point equal to the provided hex value.\n+* A _whitespace escape_ is one of the characters `U+006E` (`n`), `U+0072`\n+  (`r`), or `U+0074` (`t`), denoting the Unicode values `U+000A` (LF),\n+  `U+000D` (CR) or `U+0009` (HT) respectively.\n+* The _null escape_ is the character `U+0030` (`0`) and denotes the Unicode\n+  value `U+0000` (NUL).\n+* The _backslash escape_ is the character `U+005C` (`\\`) which must be\n+  escaped in order to denote *itself*.\n+\n+#### Raw string literals\n+\n+Raw string literals do not process any escapes. They start with the character\n+`U+0072` (`r`), followed by zero or more of the character `U+0023` (`#`) and a\n+`U+0022` (double-quote) character. The _raw string body_ can contain any sequence\n+of Unicode characters and is terminated only by another `U+0022` (double-quote)\n+character, followed by the same number of `U+0023` (`#`) characters that preceded\n+the opening `U+0022` (double-quote) character.\n+\n+All Unicode characters contained in the raw string body represent themselves,\n+the characters `U+0022` (double-quote) (except when followed by at least as\n+many `U+0023` (`#`) characters as were used to start the raw string literal) or\n+`U+005C` (`\\`) do not have any special meaning.\n+\n+Examples for string literals:\n+\n+```\n+\"foo\"; r\"foo\";                     // foo\n+\"\\\"foo\\\"\"; r#\"\"foo\"\"#;             // \"foo\"\n+\n+\"foo #\\\"# bar\";\n+r##\"foo #\"# bar\"##;                // foo #\"# bar\n+\n+\"\\x52\"; \"R\"; r\"R\";                 // R\n+\"\\\\x52\"; r\"\\x52\";                  // \\x52\n+```\n+\n+### Byte and byte string literals\n+\n+#### Byte literals\n+\n+A _byte literal_ is a single ASCII character (in the `U+0000` to `U+007F`\n+range) or a single _escape_ preceded by the characters `U+0062` (`b`) and\n+`U+0027` (single-quote), and followed by the character `U+0027`. If the character\n+`U+0027` is present within the literal, it must be _escaped_ by a preceding\n+`U+005C` (`\\`) character. It is equivalent to a `u8` unsigned 8-bit integer\n+_number literal_.\n+\n+#### Byte string literals\n+\n+A non-raw _byte string literal_ is a sequence of ASCII characters and _escapes_,\n+preceded by the characters `U+0062` (`b`) and `U+0022` (double-quote), and\n+followed by the character `U+0022`. If the character `U+0022` is present within\n+the literal, it must be _escaped_ by a preceding `U+005C` (`\\`) character.\n+Alternatively, a byte string literal can be a _raw byte string literal_, defined\n+below. A byte string literal of length `n` is equivalent to a `&'static [u8; n]` borrowed fixed-sized array\n+of unsigned 8-bit integers.\n+\n+Some additional _escapes_ are available in either byte or non-raw byte string\n+literals. An escape starts with a `U+005C` (`\\`) and continues with one of the\n+following forms:\n+\n+* A _byte escape_ escape starts with `U+0078` (`x`) and is\n+  followed by exactly two _hex digits_. It denotes the byte\n+  equal to the provided hex value.\n+* A _whitespace escape_ is one of the characters `U+006E` (`n`), `U+0072`\n+  (`r`), or `U+0074` (`t`), denoting the bytes values `0x0A` (ASCII LF),\n+  `0x0D` (ASCII CR) or `0x09` (ASCII HT) respectively.\n+* The _null escape_ is the character `U+0030` (`0`) and denotes the byte\n+  value `0x00` (ASCII NUL).\n+* The _backslash escape_ is the character `U+005C` (`\\`) which must be\n+  escaped in order to denote its ASCII encoding `0x5C`.\n+\n+#### Raw byte string literals\n+\n+Raw byte string literals do not process any escapes. They start with the\n+character `U+0062` (`b`), followed by `U+0072` (`r`), followed by zero or more\n+of the character `U+0023` (`#`), and a `U+0022` (double-quote) character. The\n+_raw string body_ can contain any sequence of ASCII characters and is terminated\n+only by another `U+0022` (double-quote) character, followed by the same number of\n+`U+0023` (`#`) characters that preceded the opening `U+0022` (double-quote)\n+character. A raw byte string literal can not contain any non-ASCII byte.\n+\n+All characters contained in the raw string body represent their ASCII encoding,\n+the characters `U+0022` (double-quote) (except when followed by at least as\n+many `U+0023` (`#`) characters as were used to start the raw string literal) or\n+`U+005C` (`\\`) do not have any special meaning.\n+\n+Examples for byte string literals:\n+\n+```\n+b\"foo\"; br\"foo\";                     // foo\n+b\"\\\"foo\\\"\"; br#\"\"foo\"\"#;             // \"foo\"\n+\n+b\"foo #\\\"# bar\";\n+br##\"foo #\"# bar\"##;                 // foo #\"# bar\n+\n+b\"\\x52\"; b\"R\"; br\"R\";                // R\n+b\"\\\\x52\"; br\"\\x52\";                  // \\x52\n+```\n+\n+### Number literals\n+\n+A _number literal_ is either an _integer literal_ or a _floating-point\n+literal_. The grammar for recognizing the two kinds of literals is mixed.\n+\n+#### Integer literals\n+\n+An _integer literal_ has one of four forms:\n+\n+* A _decimal literal_ starts with a *decimal digit* and continues with any\n+  mixture of *decimal digits* and _underscores_.\n+* A _hex literal_ starts with the character sequence `U+0030` `U+0078`\n+  (`0x`) and continues as any mixture of hex digits and underscores.\n+* An _octal literal_ starts with the character sequence `U+0030` `U+006F`\n+  (`0o`) and continues as any mixture of octal digits and underscores.\n+* A _binary literal_ starts with the character sequence `U+0030` `U+0062`\n+  (`0b`) and continues as any mixture of binary digits and underscores.\n+\n+Like any literal, an integer literal may be followed (immediately,\n+without any spaces) by an _integer suffix_, which forcibly sets the\n+type of the literal. The integer suffix must be the name of one of the\n+integral types: `u8`, `i8`, `u16`, `i16`, `u32`, `i32`, `u64`, `i64`,\n+`isize`, or `usize`.\n+\n+The type of an _unsuffixed_ integer literal is determined by type inference:\n+\n+* If an integer type can be _uniquely_ determined from the surrounding\n+  program context, the unsuffixed integer literal has that type.\n+\n+* If the program context under-constrains the type, it defaults to the\n+  signed 32-bit integer `i32`.\n+\n+* If the program context over-constrains the type, it is considered a\n+  static type error.\n+\n+Examples of integer literals of various forms:\n+\n+```\n+123i32;                            // type i32\n+123u32;                            // type u32\n+123_u32;                           // type u32\n+0xff_u8;                           // type u8\n+0o70_i16;                          // type i16\n+0b1111_1111_1001_0000_i32;         // type i32\n+0usize;                            // type usize\n+```\n+\n+Note that the Rust syntax considers `-1i8` as an application of the [unary minus\n+operator] to an integer literal `1i8`, rather than\n+a single integer literal.\n+\n+[unary minus operator]: expressions.html#unary-operator-expressions\n+\n+#### Floating-point literals\n+\n+A _floating-point literal_ has one of two forms:\n+\n+* A _decimal literal_ followed by a period character `U+002E` (`.`). This is\n+  optionally followed by another decimal literal, with an optional _exponent_.\n+* A single _decimal literal_ followed by an _exponent_.\n+\n+Like integer literals, a floating-point literal may be followed by a\n+suffix, so long as the pre-suffix part does not end with `U+002E` (`.`).\n+The suffix forcibly sets the type of the literal. There are two valid\n+_floating-point suffixes_, `f32` and `f64` (the 32-bit and 64-bit floating point\n+types), which explicitly determine the type of the literal.\n+\n+The type of an _unsuffixed_ floating-point literal is determined by\n+type inference:\n+\n+* If a floating-point type can be _uniquely_ determined from the\n+  surrounding program context, the unsuffixed floating-point literal\n+  has that type.\n+\n+* If the program context under-constrains the type, it defaults to `f64`.\n+\n+* If the program context over-constrains the type, it is considered a\n+  static type error.\n+\n+Examples of floating-point literals of various forms:\n+\n+```\n+123.0f64;        // type f64\n+0.1f64;          // type f64\n+0.1f32;          // type f32\n+12E+99_f64;      // type f64\n+let x: f64 = 2.; // type f64\n+```\n+\n+This last example is different because it is not possible to use the suffix\n+syntax with a floating point literal ending in a period. `2.f64` would attempt\n+to call a method named `f64` on `2`.\n+\n+The representation semantics of floating-point numbers are described in\n+[\"Machine Types\"].\n+\n+[\"Machine Types\"]: types.html#machine-types\n+\n+### Boolean literals\n+\n+The two values of the boolean type are written `true` and `false`.\n+\n+## Symbols\n+\n+Symbols are a general class of printable [tokens] that play structural\n+roles in a variety of grammar productions. They are a\n+set of remaining miscellaneous printable tokens that do not\n+otherwise appear as [unary operators], [binary\n+operators], or [keywords].\n+They are catalogued in [the Symbols section][symbols] of the Grammar document.\n+\n+[unary operators]: expressions.html#unary-operator-expressions\n+[binary operators]: expressions.html#binary-operator-expressions\n+[tokens]: #tokens\n+[symbols]: ../grammar.html#symbols\n+[keywords]: ../grammar.html#keywords\n\\ No newline at end of file"}, {"sha": "6301e5e83d748e2628401e0d33de625bd542655f", "filename": "src/doc/reference/src/type-coercions.md", "status": "added", "additions": 145, "deletions": 0, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Fdoc%2Freference%2Fsrc%2Ftype-coercions.md", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Fdoc%2Freference%2Fsrc%2Ftype-coercions.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference%2Fsrc%2Ftype-coercions.md?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -0,0 +1,145 @@\n+# Type coercions\n+\n+Coercions are defined in [RFC 401]. A coercion is implicit and has no syntax.\n+\n+[RFC 401]: https://github.com/rust-lang/rfcs/blob/master/text/0401-coercions.md\n+\n+## Coercion sites\n+\n+A coercion can only occur at certain coercion sites in a program; these are\n+typically places where the desired type is explicit or can be derived by\n+propagation from explicit types (without type inference). Possible coercion\n+sites are:\n+\n+* `let` statements where an explicit type is given.\n+\n+   For example, `42` is coerced to have type `i8` in the following:\n+\n+   ```rust\n+   let _: i8 = 42;\n+   ```\n+\n+* `static` and `const` statements (similar to `let` statements).\n+\n+* Arguments for function calls\n+\n+  The value being coerced is the actual parameter, and it is coerced to\n+  the type of the formal parameter.\n+\n+  For example, `42` is coerced to have type `i8` in the following:\n+\n+  ```rust\n+  fn bar(_: i8) { }\n+\n+  fn main() {\n+      bar(42);\n+  }\n+  ```\n+\n+* Instantiations of struct or variant fields\n+\n+  For example, `42` is coerced to have type `i8` in the following:\n+\n+  ```rust\n+  struct Foo { x: i8 }\n+\n+  fn main() {\n+      Foo { x: 42 };\n+  }\n+  ```\n+\n+* Function results, either the final line of a block if it is not\n+  semicolon-terminated or any expression in a `return` statement\n+\n+  For example, `42` is coerced to have type `i8` in the following:\n+\n+  ```rust\n+  fn foo() -> i8 {\n+      42\n+  }\n+  ```\n+\n+If the expression in one of these coercion sites is a coercion-propagating\n+expression, then the relevant sub-expressions in that expression are also\n+coercion sites. Propagation recurses from these new coercion sites.\n+Propagating expressions and their relevant sub-expressions are:\n+\n+* Array literals, where the array has type `[U; n]`. Each sub-expression in\n+the array literal is a coercion site for coercion to type `U`.\n+\n+* Array literals with repeating syntax, where the array has type `[U; n]`. The\n+repeated sub-expression is a coercion site for coercion to type `U`.\n+\n+* Tuples, where a tuple is a coercion site to type `(U_0, U_1, ..., U_n)`.\n+Each sub-expression is a coercion site to the respective type, e.g. the\n+zeroth sub-expression is a coercion site to type `U_0`.\n+\n+* Parenthesized sub-expressions (`(e)`): if the expression has type `U`, then\n+the sub-expression is a coercion site to `U`.\n+\n+* Blocks: if a block has type `U`, then the last expression in the block (if\n+it is not semicolon-terminated) is a coercion site to `U`. This includes\n+blocks which are part of control flow statements, such as `if`/`else`, if\n+the block has a known type.\n+\n+## Coercion types\n+\n+Coercion is allowed between the following types:\n+\n+* `T` to `U` if `T` is a subtype of `U` (*reflexive case*)\n+\n+* `T_1` to `T_3` where `T_1` coerces to `T_2` and `T_2` coerces to `T_3`\n+(*transitive case*)\n+\n+    Note that this is not fully supported yet\n+\n+* `&mut T` to `&T`\n+\n+* `*mut T` to `*const T`\n+\n+* `&T` to `*const T`\n+\n+* `&mut T` to `*mut T`\n+\n+* `&T` to `&U` if `T` implements `Deref<Target = U>`. For example:\n+\n+  ```rust\n+  use std::ops::Deref;\n+\n+  struct CharContainer {\n+      value: char,\n+  }\n+\n+  impl Deref for CharContainer {\n+      type Target = char;\n+\n+      fn deref<'a>(&'a self) -> &'a char {\n+          &self.value\n+      }\n+  }\n+\n+  fn foo(arg: &char) {}\n+\n+  fn main() {\n+      let x = &mut CharContainer { value: 'y' };\n+      foo(x); //&mut CharContainer is coerced to &char.\n+  }\n+  ```\n+\n+* `&mut T` to `&mut U` if `T` implements `DerefMut<Target = U>`.\n+\n+* TyCtor(`T`) to TyCtor(coerce_inner(`T`)), where TyCtor(`T`) is one of\n+    - `&T`\n+    - `&mut T`\n+    - `*const T`\n+    - `*mut T`\n+    - `Box<T>`\n+\n+    and where\n+    - coerce_inner(`[T, ..n]`) = `[T]`\n+    - coerce_inner(`T`) = `U` where `T` is a concrete type which implements the\n+    trait `U`.\n+\n+    In the future, coerce_inner will be recursively extended to tuples and\n+    structs. In addition, coercions from sub-traits to super-traits will be\n+    added. See [RFC 401] for more details."}, {"sha": "bed7f128e570493bc6dd5cefa9a6a75a5bdfa23a", "filename": "src/doc/reference/src/type-system.md", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Fdoc%2Freference%2Fsrc%2Ftype-system.md", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Fdoc%2Freference%2Fsrc%2Ftype-system.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference%2Fsrc%2Ftype-system.md?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -0,0 +1 @@\n+# Type system"}, {"sha": "2ddcba177e35df92ce78b81b2a5431367b524c23", "filename": "src/doc/reference/src/types.md", "status": "added", "additions": 398, "deletions": 0, "changes": 398, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Fdoc%2Freference%2Fsrc%2Ftypes.md", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Fdoc%2Freference%2Fsrc%2Ftypes.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference%2Fsrc%2Ftypes.md?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -0,0 +1,398 @@\n+# Types\n+\n+Every variable, item and value in a Rust program has a type. The _type_ of a\n+*value* defines the interpretation of the memory holding it.\n+\n+Built-in types and type-constructors are tightly integrated into the language,\n+in nontrivial ways that are not possible to emulate in user-defined types.\n+User-defined types have limited capabilities.\n+\n+## Primitive types\n+\n+The primitive types are the following:\n+\n+* The boolean type `bool` with values `true` and `false`.\n+* The machine types (integer and floating-point).\n+* The machine-dependent integer types.\n+* Arrays\n+* Tuples\n+* Slices\n+* Function pointers\n+\n+### Machine types\n+\n+The machine types are the following:\n+\n+* The unsigned word types `u8`, `u16`, `u32` and `u64`, with values drawn from\n+  the integer intervals [0, 2^8 - 1], [0, 2^16 - 1], [0, 2^32 - 1] and\n+  [0, 2^64 - 1] respectively.\n+\n+* The signed two's complement word types `i8`, `i16`, `i32` and `i64`, with\n+  values drawn from the integer intervals [-(2^(7)), 2^7 - 1],\n+  [-(2^(15)), 2^15 - 1], [-(2^(31)), 2^31 - 1], [-(2^(63)), 2^63 - 1]\n+  respectively.\n+\n+* The IEEE 754-2008 `binary32` and `binary64` floating-point types: `f32` and\n+  `f64`, respectively.\n+\n+### Machine-dependent integer types\n+\n+The `usize` type is an unsigned integer type with the same number of bits as the\n+platform's pointer type. It can represent every memory address in the process.\n+\n+The `isize` type is a signed integer type with the same number of bits as the\n+platform's pointer type. The theoretical upper bound on object and array size\n+is the maximum `isize` value. This ensures that `isize` can be used to calculate\n+differences between pointers into an object or array and can address every byte\n+within an object along with one byte past the end.\n+\n+## Textual types\n+\n+The types `char` and `str` hold textual data.\n+\n+A value of type `char` is a [Unicode scalar value](\n+http://www.unicode.org/glossary/#unicode_scalar_value) (i.e. a code point that\n+is not a surrogate), represented as a 32-bit unsigned word in the 0x0000 to\n+0xD7FF or 0xE000 to 0x10FFFF range. A `[char]` array is effectively an UCS-4 /\n+UTF-32 string.\n+\n+A value of type `str` is a Unicode string, represented as an array of 8-bit\n+unsigned bytes holding a sequence of UTF-8 code points. Since `str` is of\n+unknown size, it is not a _first-class_ type, but can only be instantiated\n+through a pointer type, such as `&str`.\n+\n+## Tuple types\n+\n+A tuple *type* is a heterogeneous product of other types, called the *elements*\n+of the tuple. It has no nominal name and is instead structurally typed.\n+\n+Tuple types and values are denoted by listing the types or values of their\n+elements, respectively, in a parenthesized, comma-separated list.\n+\n+Because tuple elements don't have a name, they can only be accessed by\n+pattern-matching or by using `N` directly as a field to access the\n+`N`th element.\n+\n+An example of a tuple type and its use:\n+\n+```\n+type Pair<'a> = (i32, &'a str);\n+let p: Pair<'static> = (10, \"ten\");\n+let (a, b) = p;\n+\n+assert_eq!(a, 10);\n+assert_eq!(b, \"ten\");\n+assert_eq!(p.0, 10);\n+assert_eq!(p.1, \"ten\");\n+```\n+\n+For historical reasons and convenience, the tuple type with no elements (`()`)\n+is often called \u2018unit\u2019 or \u2018the unit type\u2019.\n+\n+## Array, and Slice types\n+\n+Rust has two different types for a list of items:\n+\n+* `[T; N]`, an 'array'\n+* `&[T]`, a 'slice'\n+\n+An array has a fixed size, and can be allocated on either the stack or the\n+heap.\n+\n+A slice is a 'view' into an array. It doesn't own the data it points\n+to, it borrows it.\n+\n+Examples:\n+\n+```{rust}\n+// A stack-allocated array\n+let array: [i32; 3] = [1, 2, 3];\n+\n+// A heap-allocated array\n+let vector: Vec<i32> = vec![1, 2, 3];\n+\n+// A slice into an array\n+let slice: &[i32] = &vector[..];\n+```\n+\n+As you can see, the `vec!` macro allows you to create a `Vec<T>` easily. The\n+`vec!` macro is also part of the standard library, rather than the language.\n+\n+All in-bounds elements of arrays and slices are always initialized, and access\n+to an array or slice is always bounds-checked.\n+\n+## Struct types\n+\n+A `struct` *type* is a heterogeneous product of other types, called the\n+*fields* of the type.[^structtype]\n+\n+[^structtype]: `struct` types are analogous to `struct` types in C,\n+    the *record* types of the ML family,\n+    or the *struct* types of the Lisp family.\n+\n+New instances of a `struct` can be constructed with a [struct\n+expression](expressions.html#struct-expressions).\n+\n+The memory layout of a `struct` is undefined by default to allow for compiler\n+optimizations like field reordering, but it can be fixed with the\n+`#[repr(...)]` attribute. In either case, fields may be given in any order in\n+a corresponding struct *expression*; the resulting `struct` value will always\n+have the same memory layout.\n+\n+The fields of a `struct` may be qualified by [visibility\n+modifiers](visibility-and-privacy.html), to allow access to data in a\n+struct outside a module.\n+\n+A _tuple struct_ type is just like a struct type, except that the fields are\n+anonymous.\n+\n+A _unit-like struct_ type is like a struct type, except that it has no\n+fields. The one value constructed by the associated [struct\n+expression](expressions.html#struct-expressions) is the only value that inhabits such a\n+type.\n+\n+## Enumerated types\n+\n+An *enumerated type* is a nominal, heterogeneous disjoint union type, denoted\n+by the name of an [`enum` item](items.html#enumerations). [^enumtype]\n+\n+[^enumtype]: The `enum` type is analogous to a `data` constructor declaration in\n+             ML, or a *pick ADT* in Limbo.\n+\n+An [`enum` item](items.html#enumerations) declares both the type and a number of *variant\n+constructors*, each of which is independently named and takes an optional tuple\n+of arguments.\n+\n+New instances of an `enum` can be constructed by calling one of the variant\n+constructors, in a [call expression](expressions.html#call-expressions).\n+\n+Any `enum` value consumes as much memory as the largest variant constructor for\n+its corresponding `enum` type.\n+\n+Enum types cannot be denoted *structurally* as types, but must be denoted by\n+named reference to an [`enum` item](items.html#enumerations).\n+\n+## Recursive types\n+\n+Nominal types &mdash; [enumerations](#enumerated-types) and\n+[structs](#struct-types) &mdash; may be recursive. That is, each `enum`\n+constructor or `struct` field may refer, directly or indirectly, to the\n+enclosing `enum` or `struct` type itself. Such recursion has restrictions:\n+\n+* Recursive types must include a nominal type in the recursion\n+  (not mere [type definitions](../grammar.html#type-definitions),\n+   or other structural types such as [arrays](#array-and-slice-types) or [tuples](#tuple-types)).\n+* A recursive `enum` item must have at least one non-recursive constructor\n+  (in order to give the recursion a basis case).\n+* The size of a recursive type must be finite;\n+  in other words the recursive fields of the type must be [pointer types](#pointer-types).\n+* Recursive type definitions can cross module boundaries, but not module *visibility* boundaries,\n+  or crate boundaries (in order to simplify the module system and type checker).\n+\n+An example of a *recursive* type and its use:\n+\n+```\n+enum List<T> {\n+    Nil,\n+    Cons(T, Box<List<T>>)\n+}\n+\n+let a: List<i32> = List::Cons(7, Box::new(List::Cons(13, Box::new(List::Nil))));\n+```\n+\n+## Pointer types\n+\n+All pointers in Rust are explicit first-class values. They can be copied,\n+stored into data structs, and returned from functions. There are two\n+varieties of pointer in Rust:\n+\n+* References (`&`)\n+  : These point to memory _owned by some other value_.\n+    A reference type is written `&type`,\n+    or `&'a type` when you need to specify an explicit lifetime.\n+    Copying a reference is a \"shallow\" operation:\n+    it involves only copying the pointer itself.\n+    Releasing a reference has no effect on the value it points to,\n+    but a reference of a temporary value will keep it alive during the scope\n+    of the reference itself.\n+\n+* Raw pointers (`*`)\n+  : Raw pointers are pointers without safety or liveness guarantees.\n+    Raw pointers are written as `*const T` or `*mut T`,\n+    for example `*const i32` means a raw pointer to a 32-bit integer.\n+    Copying or dropping a raw pointer has no effect on the lifecycle of any\n+    other value. Dereferencing a raw pointer or converting it to any other\n+    pointer type is an [`unsafe` operation](unsafe-functions.html).\n+    Raw pointers are generally discouraged in Rust code;\n+    they exist to support interoperability with foreign code,\n+    and writing performance-critical or low-level functions.\n+\n+The standard library contains additional 'smart pointer' types beyond references\n+and raw pointers.\n+\n+## Function types\n+\n+The function type constructor `fn` forms new function types. A function type\n+consists of a possibly-empty set of function-type modifiers (such as `unsafe`\n+or `extern`), a sequence of input types and an output type.\n+\n+An example of a `fn` type:\n+\n+```\n+fn add(x: i32, y: i32) -> i32 {\n+    x + y\n+}\n+\n+let mut x = add(5,7);\n+\n+type Binop = fn(i32, i32) -> i32;\n+let bo: Binop = add;\n+x = bo(5,7);\n+```\n+\n+### Function types for specific items\n+\n+Internal to the compiler, there are also function types that are specific to a particular\n+function item. In the following snippet, for example, the internal types of the functions\n+`foo` and `bar` are different, despite the fact that they have the same signature:\n+\n+```\n+fn foo() { }\n+fn bar() { }\n+```\n+\n+The types of `foo` and `bar` can both be implicitly coerced to the fn\n+pointer type `fn()`. There is currently no syntax for unique fn types,\n+though the compiler will emit a type like `fn() {foo}` in error\n+messages to indicate \"the unique fn type for the function `foo`\".\n+\n+## Closure types\n+\n+A [lambda expression](expressions.html#lambda-expressions) produces a closure\n+value with a unique, anonymous type that cannot be written out.\n+\n+Depending on the requirements of the closure, its type implements one or\n+more of the closure traits:\n+\n+* `FnOnce`\n+  : The closure can be called once. A closure called as `FnOnce`\n+    can move out values from its environment.\n+\n+* `FnMut`\n+  : The closure can be called multiple times as mutable. A closure called as\n+    `FnMut` can mutate values from its environment. `FnMut` inherits from\n+    `FnOnce` (i.e. anything implementing `FnMut` also implements `FnOnce`).\n+\n+* `Fn`\n+  : The closure can be called multiple times through a shared reference.\n+    A closure called as `Fn` can neither move out from nor mutate values\n+    from its environment. `Fn` inherits from `FnMut`, which itself\n+    inherits from `FnOnce`.\n+\n+\n+## Trait objects\n+\n+In Rust, a type like `&SomeTrait` or `Box<SomeTrait>` is called a _trait object_.\n+Each instance of a trait object includes:\n+\n+ - a pointer to an instance of a type `T` that implements `SomeTrait`\n+ - a _virtual method table_, often just called a _vtable_, which contains, for\n+   each method of `SomeTrait` that `T` implements, a pointer to `T`'s\n+   implementation (i.e. a function pointer).\n+\n+The purpose of trait objects is to permit \"late binding\" of methods. Calling a\n+method on a trait object results in virtual dispatch at runtime: that is, a\n+function pointer is loaded from the trait object vtable and invoked indirectly.\n+The actual implementation for each vtable entry can vary on an object-by-object\n+basis.\n+\n+Note that for a trait object to be instantiated, the trait must be\n+_object-safe_. Object safety rules are defined in [RFC 255].\n+\n+[RFC 255]: https://github.com/rust-lang/rfcs/blob/master/text/0255-object-safety.md\n+\n+Given a pointer-typed expression `E` of type `&T` or `Box<T>`, where `T`\n+implements trait `R`, casting `E` to the corresponding pointer type `&R` or\n+`Box<R>` results in a value of the _trait object_ `R`. This result is\n+represented as a pair of pointers: the vtable pointer for the `T`\n+implementation of `R`, and the pointer value of `E`.\n+\n+An example of a trait object:\n+\n+```\n+trait Printable {\n+    fn stringify(&self) -> String;\n+}\n+\n+impl Printable for i32 {\n+    fn stringify(&self) -> String { self.to_string() }\n+}\n+\n+fn print(a: Box<Printable>) {\n+    println!(\"{}\", a.stringify());\n+}\n+\n+fn main() {\n+    print(Box::new(10) as Box<Printable>);\n+}\n+```\n+\n+In this example, the trait `Printable` occurs as a trait object in both the\n+type signature of `print`, and the cast expression in `main`.\n+\n+### Type parameters\n+\n+Within the body of an item that has type parameter declarations, the names of\n+its type parameters are types:\n+\n+```ignore\n+fn to_vec<A: Clone>(xs: &[A]) -> Vec<A> {\n+    if xs.is_empty() {\n+        return vec![];\n+    }\n+    let first: A = xs[0].clone();\n+    let mut rest: Vec<A> = to_vec(&xs[1..]);\n+    rest.insert(0, first);\n+    rest\n+}\n+```\n+\n+Here, `first` has type `A`, referring to `to_vec`'s `A` type parameter; and `rest`\n+has type `Vec<A>`, a vector with element type `A`.\n+\n+## Self types\n+\n+The special type `Self` has a meaning within traits and impls. In a trait definition, it refers\n+to an implicit type parameter representing the \"implementing\" type. In an impl,\n+it is an alias for the implementing type. For example, in:\n+\n+```\n+pub trait From<T> {\n+    fn from(T) -> Self;\n+}\n+\n+impl From<i32> for String {\n+    fn from(x: i32) -> Self {\n+        x.to_string()\n+    }\n+}\n+```\n+\n+The notation `Self` in the impl refers to the implementing type: `String`. In another\n+example:\n+\n+```\n+trait Printable {\n+    fn make_string(&self) -> String;\n+}\n+\n+impl Printable for String {\n+    fn make_string(&self) -> String {\n+        (*self).clone()\n+    }\n+}\n+```\n+\n+The notation `&self` is a shorthand for `self: &Self`. In this case,\n+in the impl, `Self` refers to the value of type `String` that is the\n+receiver for a call to the method `make_string`."}, {"sha": "f9d6d1d59732dda9a84b31638d49176e9beee9cd", "filename": "src/doc/reference/src/unicode-productions.md", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Fdoc%2Freference%2Fsrc%2Funicode-productions.md", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Fdoc%2Freference%2Fsrc%2Funicode-productions.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference%2Fsrc%2Funicode-productions.md?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -0,0 +1,9 @@\n+# Unicode productions\n+\n+A few productions in Rust's grammar permit Unicode code points outside the\n+ASCII range. We define these productions in terms of character properties\n+specified in the Unicode standard, rather than in terms of ASCII-range code\n+points. The grammar has a [Special Unicode Productions][unicodeproductions]\n+section that lists these productions.\n+\n+[unicodeproductions]: ../grammar.html#special-unicode-productions"}, {"sha": "754278445d51e805675301399cdca2244191a4c7", "filename": "src/doc/reference/src/unsafe-blocks.md", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Fdoc%2Freference%2Fsrc%2Funsafe-blocks.md", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Fdoc%2Freference%2Fsrc%2Funsafe-blocks.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference%2Fsrc%2Funsafe-blocks.md?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -0,0 +1,22 @@\n+# Unsafe blocks\n+\n+A block of code can be prefixed with the `unsafe` keyword, to permit calling\n+`unsafe` functions or dereferencing raw pointers within a safe function.\n+\n+When a programmer has sufficient conviction that a sequence of potentially\n+unsafe operations is actually safe, they can encapsulate that sequence (taken\n+as a whole) within an `unsafe` block. The compiler will consider uses of such\n+code safe, in the surrounding context.\n+\n+Unsafe blocks are used to wrap foreign libraries, make direct use of hardware\n+or implement features not directly present in the language. For example, Rust\n+provides the language features necessary to implement memory-safe concurrency\n+in the language but the implementation of threads and message passing is in the\n+standard library.\n+\n+Rust's type system is a conservative approximation of the dynamic safety\n+requirements, so in some cases there is a performance cost to using safe code.\n+For example, a doubly-linked list is not a tree structure and can only be\n+represented with reference-counted pointers in safe code. By using `unsafe`\n+blocks to represent the reverse links as raw pointers, it can be implemented\n+with only boxes."}, {"sha": "7a5064c08f41abf7bcefaa1ab20d7c1af3d5923f", "filename": "src/doc/reference/src/unsafe-functions.md", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Fdoc%2Freference%2Fsrc%2Funsafe-functions.md", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Fdoc%2Freference%2Fsrc%2Funsafe-functions.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference%2Fsrc%2Funsafe-functions.md?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -0,0 +1,5 @@\n+# Unsafe functions\n+\n+Unsafe functions are functions that are not safe in all contexts and/or for all\n+possible inputs. Such a function must be prefixed with the keyword `unsafe` and\n+can only be called from an `unsafe` block or another `unsafe` function."}, {"sha": "abb7a9eec584893a724b6fcde640b16679d7382b", "filename": "src/doc/reference/src/unsafety.md", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Fdoc%2Freference%2Fsrc%2Funsafety.md", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Fdoc%2Freference%2Fsrc%2Funsafety.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference%2Fsrc%2Funsafety.md?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -0,0 +1,11 @@\n+# Unsafety\n+\n+Unsafe operations are those that potentially violate the memory-safety\n+guarantees of Rust's static semantics.\n+\n+The following language level features cannot be used in the safe subset of\n+Rust:\n+\n+- Dereferencing a [raw pointer](types.html#pointer-types).\n+- Reading or writing a [mutable static variable](items.html#mutable-statics).\n+- Calling an unsafe function (including an intrinsic or foreign function)."}, {"sha": "ce3d226d0238b0e70c2dd6bcd6cb3a84fe20df74", "filename": "src/doc/reference/src/variables.md", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Fdoc%2Freference%2Fsrc%2Fvariables.md", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Fdoc%2Freference%2Fsrc%2Fvariables.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference%2Fsrc%2Fvariables.md?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -0,0 +1,31 @@\n+# Variables\n+\n+A _variable_ is a component of a stack frame, either a named function parameter,\n+an anonymous [temporary](expressions.html#lvalues-rvalues-and-temporaries), or a named local\n+variable.\n+\n+A _local variable_ (or *stack-local* allocation) holds a value directly,\n+allocated within the stack's memory. The value is a part of the stack frame.\n+\n+Local variables are immutable unless declared otherwise like: `let mut x = ...`.\n+\n+Function parameters are immutable unless declared with `mut`. The `mut` keyword\n+applies only to the following parameter (so `|mut x, y|` and `fn f(mut x:\n+Box<i32>, y: Box<i32>)` declare one mutable variable `x` and one immutable\n+variable `y`).\n+\n+Methods that take either `self` or `Box<Self>` can optionally place them in a\n+mutable variable by prefixing them with `mut` (similar to regular arguments):\n+\n+```\n+trait Changer: Sized {\n+    fn change(mut self) {}\n+    fn modify(mut self: Box<Self>) {}\n+}\n+```\n+\n+Local variables are not initialized when allocated; the entire frame worth of\n+local variables are allocated at once, on frame-entry, in an uninitialized\n+state. Subsequent statements within a function may or may not initialize the\n+local variables. Local variables can be used only after they have been\n+initialized; this is enforced by the compiler."}, {"sha": "50d3e7507d0ed365bd5c0d7638f7c39c073cc969", "filename": "src/doc/reference/src/visibility-and-privacy.md", "status": "added", "additions": 160, "deletions": 0, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Fdoc%2Freference%2Fsrc%2Fvisibility-and-privacy.md", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Fdoc%2Freference%2Fsrc%2Fvisibility-and-privacy.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference%2Fsrc%2Fvisibility-and-privacy.md?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -0,0 +1,160 @@\n+# Visibility and Privacy\n+\n+These two terms are often used interchangeably, and what they are attempting to\n+convey is the answer to the question \"Can this item be used at this location?\"\n+\n+Rust's name resolution operates on a global hierarchy of namespaces. Each level\n+in the hierarchy can be thought of as some item. The items are one of those\n+mentioned above, but also include external crates. Declaring or defining a new\n+module can be thought of as inserting a new tree into the hierarchy at the\n+location of the definition.\n+\n+To control whether interfaces can be used across modules, Rust checks each use\n+of an item to see whether it should be allowed or not. This is where privacy\n+warnings are generated, or otherwise \"you used a private item of another module\n+and weren't allowed to.\"\n+\n+By default, everything in Rust is *private*, with two exceptions: Associated\n+items in a `pub` Trait are public by default; Enum variants\n+in a `pub` enum are also public by default. When an item is declared as `pub`,\n+it can be thought of as being accessible to the outside world. For example:\n+\n+```\n+# fn main() {}\n+// Declare a private struct\n+struct Foo;\n+\n+// Declare a public struct with a private field\n+pub struct Bar {\n+    field: i32,\n+}\n+\n+// Declare a public enum with two public variants\n+pub enum State {\n+    PubliclyAccessibleState,\n+    PubliclyAccessibleState2,\n+}\n+```\n+\n+With the notion of an item being either public or private, Rust allows item\n+accesses in two cases:\n+\n+1. If an item is public, then it can be used externally through any of its\n+   public ancestors.\n+2. If an item is private, it may be accessed by the current module and its\n+   descendants.\n+\n+These two cases are surprisingly powerful for creating module hierarchies\n+exposing public APIs while hiding internal implementation details. To help\n+explain, here's a few use cases and what they would entail:\n+\n+* A library developer needs to expose functionality to crates which link\n+  against their library. As a consequence of the first case, this means that\n+  anything which is usable externally must be `pub` from the root down to the\n+  destination item. Any private item in the chain will disallow external\n+  accesses.\n+\n+* A crate needs a global available \"helper module\" to itself, but it doesn't\n+  want to expose the helper module as a public API. To accomplish this, the\n+  root of the crate's hierarchy would have a private module which then\n+  internally has a \"public API\". Because the entire crate is a descendant of\n+  the root, then the entire local crate can access this private module through\n+  the second case.\n+\n+* When writing unit tests for a module, it's often a common idiom to have an\n+  immediate child of the module to-be-tested named `mod test`. This module\n+  could access any items of the parent module through the second case, meaning\n+  that internal implementation details could also be seamlessly tested from the\n+  child module.\n+\n+In the second case, it mentions that a private item \"can be accessed\" by the\n+current module and its descendants, but the exact meaning of accessing an item\n+depends on what the item is. Accessing a module, for example, would mean\n+looking inside of it (to import more items). On the other hand, accessing a\n+function would mean that it is invoked. Additionally, path expressions and\n+import statements are considered to access an item in the sense that the\n+import/expression is only valid if the destination is in the current visibility\n+scope.\n+\n+Here's an example of a program which exemplifies the three cases outlined\n+above:\n+\n+```\n+// This module is private, meaning that no external crate can access this\n+// module. Because it is private at the root of this current crate, however, any\n+// module in the crate may access any publicly visible item in this module.\n+mod crate_helper_module {\n+\n+    // This function can be used by anything in the current crate\n+    pub fn crate_helper() {}\n+\n+    // This function *cannot* be used by anything else in the crate. It is not\n+    // publicly visible outside of the `crate_helper_module`, so only this\n+    // current module and its descendants may access it.\n+    fn implementation_detail() {}\n+}\n+\n+// This function is \"public to the root\" meaning that it's available to external\n+// crates linking against this one.\n+pub fn public_api() {}\n+\n+// Similarly to 'public_api', this module is public so external crates may look\n+// inside of it.\n+pub mod submodule {\n+    use crate_helper_module;\n+\n+    pub fn my_method() {\n+        // Any item in the local crate may invoke the helper module's public\n+        // interface through a combination of the two rules above.\n+        crate_helper_module::crate_helper();\n+    }\n+\n+    // This function is hidden to any module which is not a descendant of\n+    // `submodule`\n+    fn my_implementation() {}\n+\n+    #[cfg(test)]\n+    mod test {\n+\n+        #[test]\n+        fn test_my_implementation() {\n+            // Because this module is a descendant of `submodule`, it's allowed\n+            // to access private items inside of `submodule` without a privacy\n+            // violation.\n+            super::my_implementation();\n+        }\n+    }\n+}\n+\n+# fn main() {}\n+```\n+\n+For a Rust program to pass the privacy checking pass, all paths must be valid\n+accesses given the two rules above. This includes all use statements,\n+expressions, types, etc.\n+\n+## Re-exporting and Visibility\n+\n+Rust allows publicly re-exporting items through a `pub use` directive. Because\n+this is a public directive, this allows the item to be used in the current\n+module through the rules above. It essentially allows public access into the\n+re-exported item. For example, this program is valid:\n+\n+```\n+pub use self::implementation::api;\n+\n+mod implementation {\n+    pub mod api {\n+        pub fn f() {}\n+    }\n+}\n+\n+# fn main() {}\n+```\n+\n+This means that any external crate referencing `implementation::api::f` would\n+receive a privacy violation, while the path `api::f` would be allowed.\n+\n+When re-exporting a private item, it can be thought of as allowing the \"privacy\n+chain\" being short-circuited through the reexport instead of passing through\n+the namespace hierarchy as it normally would."}, {"sha": "2fd162bcb2da8645fd775cdaf61f951af334f8b1", "filename": "src/doc/reference/src/whitespace.md", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Fdoc%2Freference%2Fsrc%2Fwhitespace.md", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Fdoc%2Freference%2Fsrc%2Fwhitespace.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference%2Fsrc%2Fwhitespace.md?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -0,0 +1,22 @@\n+# Whitespace\n+\n+Whitespace is any non-empty string containing only characters that have the\n+`Pattern_White_Space` Unicode property, namely:\n+\n+- `U+0009` (horizontal tab, `'\\t'`)\n+- `U+000A` (line feed, `'\\n'`)\n+- `U+000B` (vertical tab)\n+- `U+000C` (form feed)\n+- `U+000D` (carriage return, `'\\r'`)\n+- `U+0020` (space, `' '`)\n+- `U+0085` (next line)\n+- `U+200E` (left-to-right mark)\n+- `U+200F` (right-to-left mark)\n+- `U+2028` (line separator)\n+- `U+2029` (paragraph separator)\n+\n+Rust is a \"free-form\" language, meaning that all forms of whitespace serve only\n+to separate _tokens_ in the grammar, and have no semantic significance.\n+\n+A Rust program has identical meaning if each whitespace element is replaced\n+with any other legal whitespace element, such as a single space character."}, {"sha": "38d843263ffda09c7c1609e684a42da31a9763df", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -102,7 +102,7 @@ const MAX_REFCOUNT: usize = (isize::MAX) as usize;\n /// [downgrade]: struct.Arc.html#method.downgrade\n /// [upgrade]: struct.Weak.html#method.upgrade\n /// [`None`]: ../../std/option/enum.Option.html#variant.None\n-/// [assoc]: ../../book/method-syntax.html#Associated%20functions\n+/// [assoc]: ../../book/method-syntax.html#associated-functions\n ///\n /// # Examples\n ///"}, {"sha": "6108a06634bb88cfaefafda0e88a76f80aa12e2d", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -215,7 +215,7 @@\n //! [downgrade]: struct.Rc.html#method.downgrade\n //! [upgrade]: struct.Weak.html#method.upgrade\n //! [`None`]: ../../std/option/enum.Option.html#variant.None\n-//! [assoc]: ../../book/method-syntax.html#Associated%20functions\n+//! [assoc]: ../../book/method-syntax.html#associated-functions\n //! [mutability]: ../../std/cell/index.html#introducing-mutability-inside-of-something-immutable\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "e92eb4ff7bdd4b565b4a81543e09b366d9230dae", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -1250,17 +1250,17 @@ impl String {\n         self.len() == 0\n     }\n \n-    /// Divide one string into two at an index.\n+    /// Splits the string into two at the given index.\n     ///\n-    /// The argument, `mid`, should be a byte offset from the start of the string. It must also\n-    /// be on the boundary of a UTF-8 code point.\n+    /// Returns a newly allocated `String`. `self` contains bytes `[0, at)`, and\n+    /// the returned `String` contains bytes `[at, len)`. `at` must be on the\n+    /// boundary of a UTF-8 code point.\n     ///\n-    /// The two strings returned go from the start of the string to `mid`, and from `mid` to the end\n-    /// of the string.\n+    /// Note that the capacity of `self` does not change.\n     ///\n     /// # Panics\n     ///\n-    /// Panics if `mid` is not on a `UTF-8` code point boundary, or if it is beyond the last\n+    /// Panics if `at` is not on a `UTF-8` code point boundary, or if it is beyond the last\n     /// code point of the string.\n     ///\n     /// # Examples\n@@ -1275,9 +1275,9 @@ impl String {\n     /// ```\n     #[inline]\n     #[stable(feature = \"string_split_off\", since = \"1.16.0\")]\n-    pub fn split_off(&mut self, mid: usize) -> String {\n-        assert!(self.is_char_boundary(mid));\n-        let other = self.vec.split_off(mid);\n+    pub fn split_off(&mut self, at: usize) -> String {\n+        assert!(self.is_char_boundary(at));\n+        let other = self.vec.split_off(at);\n         unsafe { String::from_utf8_unchecked(other) }\n     }\n "}, {"sha": "12410c08f399b3f059126492196bda0e807d886d", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -687,7 +687,7 @@ extern \"rust-intrinsic\" {\n     /// The [nomicon](../../nomicon/transmutes.html) has additional\n     /// documentation.\n     ///\n-    /// [ub]: ../../reference.html#behavior-considered-undefined\n+    /// [ub]: ../../reference/behavior-considered-undefined.html\n     ///\n     /// # Examples\n     ///"}, {"sha": "0f47378aebb7ca03d3e41465b05bb525478e588b", "filename": "src/libcore/iter/iterator.rs", "status": "modified", "additions": 25, "deletions": 9, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Flibcore%2Fiter%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Flibcore%2Fiter%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fiterator.rs?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -1603,29 +1603,33 @@ pub trait Iterator {\n         let mut i = self.len();\n \n         while let Some(v) = self.next_back() {\n-            if predicate(v) {\n-                return Some(i - 1);\n-            }\n             // No need for an overflow check here, because `ExactSizeIterator`\n             // implies that the number of elements fits into a `usize`.\n             i -= 1;\n+            if predicate(v) {\n+                return Some(i);\n+            }\n         }\n         None\n     }\n \n     /// Returns the maximum element of an iterator.\n     ///\n     /// If several elements are equally maximum, the last element is\n-    /// returned.\n+    /// returned. If the iterator is empty, [`None`] is returned.\n+    ///\n+    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n     ///\n     /// # Examples\n     ///\n     /// Basic usage:\n     ///\n     /// ```\n     /// let a = [1, 2, 3];\n+    /// let b: Vec<u32> = Vec::new();\n     ///\n     /// assert_eq!(a.iter().max(), Some(&3));\n+    /// assert_eq!(b.iter().max(), None);\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1642,16 +1646,20 @@ pub trait Iterator {\n     /// Returns the minimum element of an iterator.\n     ///\n     /// If several elements are equally minimum, the first element is\n-    /// returned.\n+    /// returned. If the iterator is empty, [`None`] is returned.\n+    ///\n+    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n     ///\n     /// # Examples\n     ///\n     /// Basic usage:\n     ///\n     /// ```\n     /// let a = [1, 2, 3];\n+    /// let b: Vec<u32> = Vec::new();\n     ///\n     /// assert_eq!(a.iter().min(), Some(&1));\n+    /// assert_eq!(b.iter().min(), None);\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1669,7 +1677,9 @@ pub trait Iterator {\n     /// specified function.\n     ///\n     /// If several elements are equally maximum, the last element is\n-    /// returned.\n+    /// returned. If the iterator is empty, [`None`] is returned.\n+    ///\n+    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n     ///\n     /// # Examples\n     ///\n@@ -1694,7 +1704,9 @@ pub trait Iterator {\n     /// specified comparison function.\n     ///\n     /// If several elements are equally maximum, the last element is\n-    /// returned.\n+    /// returned. If the iterator is empty, [`None`] is returned.\n+    ///\n+    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n     ///\n     /// # Examples\n     ///\n@@ -1719,7 +1731,9 @@ pub trait Iterator {\n     /// specified function.\n     ///\n     /// If several elements are equally minimum, the first element is\n-    /// returned.\n+    /// returned. If the iterator is empty, [`None`] is returned.\n+    ///\n+    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n     ///\n     /// # Examples\n     ///\n@@ -1743,7 +1757,9 @@ pub trait Iterator {\n     /// specified comparison function.\n     ///\n     /// If several elements are equally minimum, the first element is\n-    /// returned.\n+    /// returned. If the iterator is empty, [`None`] is returned.\n+    ///\n+    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n     ///\n     /// # Examples\n     ///"}, {"sha": "1e9eaaf5f3223761f172536c2b50ad4eb347b1f8", "filename": "src/libcore/marker.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Flibcore%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Flibcore%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmarker.rs?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -36,7 +36,7 @@ use hash::Hasher;\n ///\n /// [`Rc`]: ../../std/rc/struct.Rc.html\n /// [arc]: ../../std/sync/struct.Arc.html\n-/// [ub]: ../../reference.html#behavior-considered-undefined\n+/// [ub]: ../../reference/behavior-considered-undefined.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[lang = \"send\"]\n #[rustc_on_unimplemented = \"`{Self}` cannot be sent between threads safely\"]\n@@ -338,7 +338,7 @@ pub trait Copy : Clone {\n /// [mutex]: ../../std/sync/struct.Mutex.html\n /// [rwlock]: ../../std/sync/struct.RwLock.html\n /// [unsafecell]: ../cell/struct.UnsafeCell.html\n-/// [ub]: ../../reference.html#behavior-considered-undefined\n+/// [ub]: ../../reference/behavior-considered-undefined.html\n /// [transmute]: ../../std/mem/fn.transmute.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[lang = \"sync\"]"}, {"sha": "f4ce4697d7cf4108f8973119fc3b635bdfd904e5", "filename": "src/libcore/mem.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Flibcore%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Flibcore%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem.rs?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -167,7 +167,7 @@ pub use intrinsics::transmute;\n /// [FFI]: ../../book/ffi.html\n /// [box]: ../../std/boxed/struct.Box.html\n /// [into_raw]: ../../std/boxed/struct.Box.html#method.into_raw\n-/// [ub]: ../../reference.html#behavior-considered-undefined\n+/// [ub]: ../../reference/behavior-considered-undefined.html\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn forget<T>(t: T) {\n@@ -318,7 +318,7 @@ pub fn align_of_val<T: ?Sized>(val: &T) -> usize {\n ///\n /// [uninit]: fn.uninitialized.html\n /// [FFI]: ../../book/ffi.html\n-/// [ub]: ../../reference.html#behavior-considered-undefined\n+/// [ub]: ../../reference/behavior-considered-undefined.html\n ///\n /// # Examples\n ///\n@@ -417,7 +417,7 @@ pub unsafe fn zeroed<T>() -> T {\n /// [`Vec`]: ../../std/vec/struct.Vec.html\n /// [`vec!`]: ../../std/macro.vec.html\n /// [`Clone`]: ../../std/clone/trait.Clone.html\n-/// [ub]: ../../reference.html#behavior-considered-undefined\n+/// [ub]: ../../reference/behavior-considered-undefined.html\n /// [write]: ../ptr/fn.write.html\n /// [copy]: ../intrinsics/fn.copy.html\n /// [copy_no]: ../intrinsics/fn.copy_nonoverlapping.html\n@@ -525,7 +525,7 @@ pub fn replace<T>(dest: &mut T, mut src: T) -> T {\n /// it will not release any borrows, as borrows are based on lexical scope.\n ///\n /// This effectively does nothing for\n-/// [types which implement `Copy`](../../book/ownership.html#Copy%20types),\n+/// [types which implement `Copy`](../../book/ownership.html#copy-types),\n /// e.g. integers. Such values are copied and _then_ moved into the function,\n /// so the value persists after this function call.\n ///\n@@ -626,7 +626,7 @@ pub fn drop<T>(_x: T) { }\n /// same size. This function triggers [undefined behavior][ub] if `U` is larger than\n /// `T`.\n ///\n-/// [ub]: ../../reference.html#behavior-considered-undefined\n+/// [ub]: ../../reference/behavior-considered-undefined.html\n /// [size_of]: fn.size_of.html\n ///\n /// # Examples"}, {"sha": "a7d0d3899b181d2dd3add95f7bbb46c2bb83ced3", "filename": "src/libcore/raw.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Flibcore%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Flibcore%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fraw.rs?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -25,7 +25,7 @@\n /// Book][moreinfo] contains more details about the precise nature of\n /// these internals.\n ///\n-/// [moreinfo]: ../../book/trait-objects.html#Representation\n+/// [moreinfo]: ../../book/trait-objects.html#representation\n ///\n /// `TraitObject` is guaranteed to match layouts, but it is not the\n /// type of trait objects (e.g. the fields are not directly accessible"}, {"sha": "96d1a925425e8d322a283e9bc4ffc6a716b1eb52", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 42, "deletions": 4, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -131,7 +131,37 @@ pub enum DepNode<D: Clone + Debug> {\n     // which would yield an overly conservative dep-graph.\n     TraitItems(D),\n     ReprHints(D),\n-    TraitSelect(Vec<D>),\n+\n+    // Trait selection cache is a little funny. Given a trait\n+    // reference like `Foo: SomeTrait<Bar>`, there could be\n+    // arbitrarily many def-ids to map on in there (e.g., `Foo`,\n+    // `SomeTrait`, `Bar`). We could have a vector of them, but it\n+    // requires heap-allocation, and trait sel in general can be a\n+    // surprisingly hot path. So instead we pick two def-ids: the\n+    // trait def-id, and the first def-id in the input types. If there\n+    // is no def-id in the input types, then we use the trait def-id\n+    // again. So for example:\n+    //\n+    // - `i32: Clone` -> `TraitSelect { trait_def_id: Clone, self_def_id: Clone }`\n+    // - `u32: Clone` -> `TraitSelect { trait_def_id: Clone, self_def_id: Clone }`\n+    // - `Clone: Clone` -> `TraitSelect { trait_def_id: Clone, self_def_id: Clone }`\n+    // - `Vec<i32>: Clone` -> `TraitSelect { trait_def_id: Clone, self_def_id: Vec }`\n+    // - `String: Clone` -> `TraitSelect { trait_def_id: Clone, self_def_id: String }`\n+    // - `Foo: Trait<Bar>` -> `TraitSelect { trait_def_id: Trait, self_def_id: Foo }`\n+    // - `Foo: Trait<i32>` -> `TraitSelect { trait_def_id: Trait, self_def_id: Foo }`\n+    // - `(Foo, Bar): Trait` -> `TraitSelect { trait_def_id: Trait, self_def_id: Foo }`\n+    // - `i32: Trait<Foo>` -> `TraitSelect { trait_def_id: Trait, self_def_id: Foo }`\n+    //\n+    // You can see that we map many trait refs to the same\n+    // trait-select node.  This is not a problem, it just means\n+    // imprecision in our dep-graph tracking.  The important thing is\n+    // that for any given trait-ref, we always map to the **same**\n+    // trait-select node.\n+    TraitSelect { trait_def_id: D, input_def_id: D },\n+\n+    // For proj. cache, we just keep a list of all def-ids, since it is\n+    // not a hotspot.\n+    ProjectionCache { def_ids: Vec<D> },\n }\n \n impl<D: Clone + Debug> DepNode<D> {\n@@ -236,9 +266,17 @@ impl<D: Clone + Debug> DepNode<D> {\n             TraitImpls(ref d) => op(d).map(TraitImpls),\n             TraitItems(ref d) => op(d).map(TraitItems),\n             ReprHints(ref d) => op(d).map(ReprHints),\n-            TraitSelect(ref type_ds) => {\n-                let type_ds = try_opt!(type_ds.iter().map(|d| op(d)).collect());\n-                Some(TraitSelect(type_ds))\n+            TraitSelect { ref trait_def_id, ref input_def_id } => {\n+                op(trait_def_id).and_then(|trait_def_id| {\n+                    op(input_def_id).and_then(|input_def_id| {\n+                        Some(TraitSelect { trait_def_id: trait_def_id,\n+                                           input_def_id: input_def_id })\n+                    })\n+                })\n+            }\n+            ProjectionCache { ref def_ids } => {\n+                let def_ids: Option<Vec<E>> = def_ids.iter().map(op).collect();\n+                def_ids.map(|d| ProjectionCache { def_ids: d })\n             }\n         }\n     }"}, {"sha": "53b7be74f85037dcaea5d9e7c362f0413d41447b", "filename": "src/librustc/hir/def.rs", "status": "modified", "additions": 26, "deletions": 13, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Flibrustc%2Fhir%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Flibrustc%2Fhir%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fdef.rs?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -59,32 +59,45 @@ pub enum Def {\n     Err,\n }\n \n-/// The result of resolving a path.\n-/// Before type checking completes, `depth` represents the number of\n-/// trailing segments which are yet unresolved. Afterwards, if there\n-/// were no errors, all paths should be fully resolved, with `depth`\n-/// set to `0` and `base_def` representing the final resolution.\n-///\n+/// The result of resolving a path before lowering to HIR.\n+/// `base_def` is definition of resolved part of the\n+/// path, `unresolved_segments` is the number of unresolved\n+/// segments.\n ///     module::Type::AssocX::AssocY::MethodOrAssocType\n ///     ^~~~~~~~~~~~  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n-///     base_def      depth = 3\n+///     base_def      unresolved_segments = 3\n ///\n ///     <T as Trait>::AssocX::AssocY::MethodOrAssocType\n ///           ^~~~~~~~~~~~~~  ^~~~~~~~~~~~~~~~~~~~~~~~~\n-///           base_def        depth = 2\n+///           base_def        unresolved_segments = 2\n #[derive(Copy, Clone, Debug)]\n pub struct PathResolution {\n-    pub base_def: Def,\n-    pub depth: usize\n+    base_def: Def,\n+    unresolved_segments: usize,\n }\n \n impl PathResolution {\n-    pub fn new(def: Def) -> PathResolution {\n-        PathResolution { base_def: def, depth: 0 }\n+    pub fn new(def: Def) -> Self {\n+        PathResolution { base_def: def, unresolved_segments: 0 }\n+    }\n+\n+    pub fn with_unresolved_segments(def: Def, mut unresolved_segments: usize) -> Self {\n+        if def == Def::Err { unresolved_segments = 0 }\n+        PathResolution { base_def: def, unresolved_segments: unresolved_segments }\n+    }\n+\n+    #[inline]\n+    pub fn base_def(&self) -> Def {\n+        self.base_def\n+    }\n+\n+    #[inline]\n+    pub fn unresolved_segments(&self) -> usize {\n+        self.unresolved_segments\n     }\n \n     pub fn kind_name(&self) -> &'static str {\n-        if self.depth != 0 {\n+        if self.unresolved_segments != 0 {\n             \"associated item\"\n         } else {\n             self.base_def.kind_name()"}, {"sha": "c87ce6505fcd505e81bff483904cec8e691ff254", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -217,10 +217,10 @@ impl<'a> LoweringContext<'a> {\n \n     fn expect_full_def(&mut self, id: NodeId) -> Def {\n         self.resolver.get_resolution(id).map_or(Def::Err, |pr| {\n-            if pr.depth != 0 {\n+            if pr.unresolved_segments() != 0 {\n                 bug!(\"path not fully resolved: {:?}\", pr);\n             }\n-            pr.base_def\n+            pr.base_def()\n         })\n     }\n \n@@ -421,9 +421,9 @@ impl<'a> LoweringContext<'a> {\n         let resolution = self.resolver.get_resolution(id)\n                                       .unwrap_or(PathResolution::new(Def::Err));\n \n-        let proj_start = p.segments.len() - resolution.depth;\n+        let proj_start = p.segments.len() - resolution.unresolved_segments();\n         let path = P(hir::Path {\n-            def: resolution.base_def,\n+            def: resolution.base_def(),\n             segments: p.segments[..proj_start].iter().enumerate().map(|(i, segment)| {\n                 let param_mode = match (qself_position, param_mode) {\n                     (Some(j), ParamMode::Optional) if i < j => {\n@@ -443,7 +443,7 @@ impl<'a> LoweringContext<'a> {\n                         index: this.def_key(def_id).parent.expect(\"missing parent\")\n                     }\n                 };\n-                let type_def_id = match resolution.base_def {\n+                let type_def_id = match resolution.base_def() {\n                     Def::AssociatedTy(def_id) if i + 2 == proj_start => {\n                         Some(parent_def_id(self, def_id))\n                     }\n@@ -474,7 +474,7 @@ impl<'a> LoweringContext<'a> {\n \n         // Simple case, either no projections, or only fully-qualified.\n         // E.g. `std::mem::size_of` or `<I as Iterator>::Item`.\n-        if resolution.depth == 0 {\n+        if resolution.unresolved_segments() == 0 {\n             return hir::QPath::Resolved(qself, path);\n         }\n \n@@ -749,7 +749,7 @@ impl<'a> LoweringContext<'a> {\n                                        bound_pred.bound_lifetimes.is_empty() => {\n                                 if let Some(Def::TyParam(def_id)) =\n                                         self.resolver.get_resolution(bound_pred.bounded_ty.id)\n-                                                     .map(|d| d.base_def) {\n+                                                     .map(|d| d.base_def()) {\n                                     if let Some(node_id) =\n                                             self.resolver.definitions().as_local_node_id(def_id) {\n                                         for ty_param in &g.ty_params {\n@@ -1295,7 +1295,7 @@ impl<'a> LoweringContext<'a> {\n                 PatKind::Wild => hir::PatKind::Wild,\n                 PatKind::Ident(ref binding_mode, pth1, ref sub) => {\n                     self.with_parent_def(p.id, |this| {\n-                        match this.resolver.get_resolution(p.id).map(|d| d.base_def) {\n+                        match this.resolver.get_resolution(p.id).map(|d| d.base_def()) {\n                             // `None` can occur in body-less function signatures\n                             def @ None | def @ Some(Def::Local(_)) => {\n                                 let def_id = def.map(|d| d.def_id()).unwrap_or_else(|| {"}, {"sha": "9295fb2ee327b4f5910b4c29be7b12c8fc4491a6", "filename": "src/librustc/infer/error_reporting.rs", "status": "modified", "additions": 24, "deletions": 221, "changes": 245, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Flibrustc%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Flibrustc%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting.rs?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -65,9 +65,6 @@ use super::region_inference::ConcreteFailure;\n use super::region_inference::SubSupConflict;\n use super::region_inference::GenericBoundFailure;\n use super::region_inference::GenericKind;\n-use super::region_inference::ProcessedErrors;\n-use super::region_inference::ProcessedErrorOrigin;\n-use super::region_inference::SameRegions;\n \n use hir::map as hir_map;\n use hir;\n@@ -77,11 +74,10 @@ use infer;\n use middle::region;\n use traits::{ObligationCause, ObligationCauseCode};\n use ty::{self, TyCtxt, TypeFoldable};\n-use ty::{Region, ReFree, Issue32330};\n+use ty::{Region, Issue32330};\n use ty::error::TypeError;\n \n use std::fmt;\n-use syntax::ast;\n use syntax_pos::{Pos, Span};\n use errors::DiagnosticBuilder;\n \n@@ -255,8 +251,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n         // try to pre-process the errors, which will group some of them\n         // together into a `ProcessedErrors` group:\n-        let processed_errors = self.process_errors(errors);\n-        let errors = processed_errors.as_ref().unwrap_or(errors);\n+        let errors = self.process_errors(errors);\n \n         debug!(\"report_region_errors: {} errors after preprocessing\", errors.len());\n \n@@ -278,13 +273,6 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                                  sub_origin, sub_r,\n                                                  sup_origin, sup_r);\n                 }\n-\n-                ProcessedErrors(ref origins,\n-                                ref same_regions) => {\n-                    if !same_regions.is_empty() {\n-                        self.report_processed_errors(origins);\n-                    }\n-                }\n             }\n         }\n     }\n@@ -300,202 +288,31 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     // duplicates that will be unhelpful to the end-user. But\n     // obviously it never weeds out ALL errors.\n     fn process_errors(&self, errors: &Vec<RegionResolutionError<'tcx>>)\n-                      -> Option<Vec<RegionResolutionError<'tcx>>> {\n+                      -> Vec<RegionResolutionError<'tcx>> {\n         debug!(\"process_errors()\");\n-        let mut origins = Vec::new();\n-\n-        // we collect up ConcreteFailures and SubSupConflicts that are\n-        // relating free-regions bound on the fn-header and group them\n-        // together into this vector\n-        let mut same_regions = Vec::new();\n-\n-        // here we put errors that we will not be able to process nicely\n-        let mut other_errors = Vec::new();\n-\n-        // we collect up GenericBoundFailures in here.\n-        let mut bound_failures = Vec::new();\n-\n-        for error in errors {\n-            // Check whether we can process this error into some other\n-            // form; if not, fall through.\n-            match *error {\n-                ConcreteFailure(ref origin, sub, sup) => {\n-                    debug!(\"processing ConcreteFailure\");\n-                    if let SubregionOrigin::CompareImplMethodObligation { .. } = *origin {\n-                        // When comparing an impl method against a\n-                        // trait method, it is not helpful to suggest\n-                        // changes to the impl method.  This is\n-                        // because the impl method signature is being\n-                        // checked using the trait's environment, so\n-                        // usually the changes we suggest would\n-                        // actually have to be applied to the *trait*\n-                        // method (and it's not clear that the trait\n-                        // method is even under the user's control).\n-                    } else if let Some(same_frs) = free_regions_from_same_fn(self.tcx, sub, sup) {\n-                        origins.push(\n-                            ProcessedErrorOrigin::ConcreteFailure(\n-                                origin.clone(),\n-                                sub,\n-                                sup));\n-                        append_to_same_regions(&mut same_regions, &same_frs);\n-                        continue;\n-                    }\n-                }\n-                SubSupConflict(ref var_origin, ref sub_origin, sub, ref sup_origin, sup) => {\n-                    debug!(\"processing SubSupConflict sub: {:?} sup: {:?}\", sub, sup);\n-                    match (sub_origin, sup_origin) {\n-                        (&SubregionOrigin::CompareImplMethodObligation { .. }, _) => {\n-                            // As above, when comparing an impl method\n-                            // against a trait method, it is not helpful\n-                            // to suggest changes to the impl method.\n-                        }\n-                        (_, &SubregionOrigin::CompareImplMethodObligation { .. }) => {\n-                            // See above.\n-                        }\n-                        _ => {\n-                            if let Some(same_frs) = free_regions_from_same_fn(self.tcx, sub, sup) {\n-                                origins.push(\n-                                    ProcessedErrorOrigin::VariableFailure(\n-                                        var_origin.clone()));\n-                                append_to_same_regions(&mut same_regions, &same_frs);\n-                                continue;\n-                            }\n-                        }\n-                    }\n-                }\n-                GenericBoundFailure(ref origin, ref kind, region) => {\n-                    bound_failures.push((origin.clone(), kind.clone(), region));\n-                    continue;\n-                }\n-                ProcessedErrors(..) => {\n-                    bug!(\"should not encounter a `ProcessedErrors` yet: {:?}\", error)\n-                }\n-            }\n-\n-            // No changes to this error.\n-            other_errors.push(error.clone());\n-        }\n-\n-        // ok, let's pull together the errors, sorted in an order that\n-        // we think will help user the best\n-        let mut processed_errors = vec![];\n-\n-        // first, put the processed errors, if any\n-        if !same_regions.is_empty() {\n-            let common_scope_id = same_regions[0].scope_id;\n-            for sr in &same_regions {\n-                // Since ProcessedErrors is used to reconstruct the function\n-                // declaration, we want to make sure that they are, in fact,\n-                // from the same scope\n-                if sr.scope_id != common_scope_id {\n-                    debug!(\"returning empty result from process_errors because\n-                            {} != {}\", sr.scope_id, common_scope_id);\n-                    return None;\n-                }\n-            }\n-            assert!(origins.len() > 0);\n-            let pe = ProcessedErrors(origins, same_regions);\n-            debug!(\"errors processed: {:?}\", pe);\n-            processed_errors.push(pe);\n-        }\n-\n-        // next, put the other misc errors\n-        processed_errors.extend(other_errors);\n-\n-        // finally, put the `T: 'a` errors, but only if there were no\n-        // other errors. otherwise, these have a very high rate of\n-        // being unhelpful in practice. This is because they are\n-        // basically secondary checks that test the state of the\n-        // region graph after the rest of inference is done, and the\n-        // other kinds of errors indicate that the region constraint\n-        // graph is internally inconsistent, so these test results are\n-        // likely to be meaningless.\n-        if processed_errors.is_empty() {\n-            for (origin, kind, region) in bound_failures {\n-                processed_errors.push(GenericBoundFailure(origin, kind, region));\n-            }\n-        }\n \n-        // we should always wind up with SOME errors, unless there were no\n-        // errors to start\n-        assert!(if errors.len() > 0 {processed_errors.len() > 0} else {true});\n-\n-        return Some(processed_errors);\n-\n-        #[derive(Debug)]\n-        struct FreeRegionsFromSameFn {\n-            sub_fr: ty::FreeRegion,\n-            sup_fr: ty::FreeRegion,\n-            scope_id: ast::NodeId\n-        }\n-\n-        impl FreeRegionsFromSameFn {\n-            fn new(sub_fr: ty::FreeRegion,\n-                   sup_fr: ty::FreeRegion,\n-                   scope_id: ast::NodeId)\n-                   -> FreeRegionsFromSameFn {\n-                FreeRegionsFromSameFn {\n-                    sub_fr: sub_fr,\n-                    sup_fr: sup_fr,\n-                    scope_id: scope_id\n-                }\n-            }\n-        }\n-\n-        fn free_regions_from_same_fn<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                                                     sub: &'tcx Region,\n-                                                     sup: &'tcx Region)\n-                                                     -> Option<FreeRegionsFromSameFn> {\n-            debug!(\"free_regions_from_same_fn(sub={:?}, sup={:?})\", sub, sup);\n-            let (scope_id, fr1, fr2) = match (sub, sup) {\n-                (&ReFree(fr1), &ReFree(fr2)) => {\n-                    if fr1.scope != fr2.scope {\n-                        return None\n-                    }\n-                    assert!(fr1.scope == fr2.scope);\n-                    (fr1.scope.node_id(&tcx.region_maps), fr1, fr2)\n-                },\n-                _ => return None\n-            };\n-            let parent = tcx.hir.get_parent(scope_id);\n-            let parent_node = tcx.hir.find(parent);\n-            match parent_node {\n-                Some(node) => match node {\n-                    hir_map::NodeItem(item) => match item.node {\n-                        hir::ItemFn(..) => {\n-                            Some(FreeRegionsFromSameFn::new(fr1, fr2, scope_id))\n-                        },\n-                        _ => None\n-                    },\n-                    hir_map::NodeImplItem(..) |\n-                    hir_map::NodeTraitItem(..) => {\n-                        Some(FreeRegionsFromSameFn::new(fr1, fr2, scope_id))\n-                    },\n-                    _ => None\n-                },\n-                None => {\n-                    debug!(\"no parent node of scope_id {}\", scope_id);\n-                    None\n-                }\n-            }\n-        }\n+        // We want to avoid reporting generic-bound failures if we can\n+        // avoid it: these have a very high rate of being unhelpful in\n+        // practice. This is because they are basically secondary\n+        // checks that test the state of the region graph after the\n+        // rest of inference is done, and the other kinds of errors\n+        // indicate that the region constraint graph is internally\n+        // inconsistent, so these test results are likely to be\n+        // meaningless.\n+        //\n+        // Therefore, we filter them out of the list unless they are\n+        // the only thing in the list.\n+\n+        let is_bound_failure = |e: &RegionResolutionError<'tcx>| match *e {\n+            ConcreteFailure(..) => false,\n+            SubSupConflict(..) => false,\n+            GenericBoundFailure(..) => true,\n+        };\n \n-        fn append_to_same_regions(same_regions: &mut Vec<SameRegions>,\n-                                  same_frs: &FreeRegionsFromSameFn) {\n-            debug!(\"append_to_same_regions(same_regions={:?}, same_frs={:?})\",\n-                   same_regions, same_frs);\n-            let scope_id = same_frs.scope_id;\n-            let (sub_fr, sup_fr) = (same_frs.sub_fr, same_frs.sup_fr);\n-            for sr in same_regions.iter_mut() {\n-                if sr.contains(&sup_fr.bound_region) && scope_id == sr.scope_id {\n-                    sr.push(sub_fr.bound_region);\n-                    return\n-                }\n-            }\n-            same_regions.push(SameRegions {\n-                scope_id: scope_id,\n-                regions: vec![sub_fr.bound_region, sup_fr.bound_region]\n-            })\n+        if errors.iter().all(|e| is_bound_failure(e)) {\n+            errors.clone()\n+        } else {\n+            errors.iter().filter(|&e| !is_bound_failure(e)).cloned().collect()\n         }\n     }\n \n@@ -1072,20 +889,6 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         self.note_region_origin(&mut err, &sub_origin);\n         err.emit();\n     }\n-\n-    fn report_processed_errors(&self,\n-                               origins: &[ProcessedErrorOrigin<'tcx>]) {\n-        for origin in origins.iter() {\n-            let mut err = match *origin {\n-                ProcessedErrorOrigin::VariableFailure(ref var_origin) =>\n-                    self.report_inference_failure(var_origin.clone()),\n-                ProcessedErrorOrigin::ConcreteFailure(ref sr_origin, sub, sup) =>\n-                    self.report_concrete_failure(sr_origin.clone(), sub, sup),\n-            };\n-\n-            err.emit();\n-        }\n-    }\n }\n \n impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {"}, {"sha": "0bb9e2c7fa15c91345ea6c7ec0c7acb630d91410", "filename": "src/librustc/infer/region_inference/mod.rs", "status": "modified", "additions": 1, "deletions": 35, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Flibrustc%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Flibrustc%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_inference%2Fmod.rs?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -24,7 +24,7 @@ use rustc_data_structures::graph::{self, Direction, NodeIndex, OUTGOING};\n use rustc_data_structures::unify::{self, UnificationTable};\n use middle::free_region::FreeRegionMap;\n use ty::{self, Ty, TyCtxt};\n-use ty::{BoundRegion, Region, RegionVid};\n+use ty::{Region, RegionVid};\n use ty::{ReEmpty, ReStatic, ReFree, ReEarlyBound, ReErased};\n use ty::{ReLateBound, ReScope, ReVar, ReSkolemized, BrFresh};\n \n@@ -171,13 +171,6 @@ pub enum RegionResolutionError<'tcx> {\n                    &'tcx Region,\n                    SubregionOrigin<'tcx>,\n                    &'tcx Region),\n-\n-    /// For subsets of `ConcreteFailure` and `SubSupConflict`, we can derive\n-    /// more specific errors message by suggesting to the user where they\n-    /// should put a lifetime. In those cases we process and put those errors\n-    /// into `ProcessedErrors` before we do any reporting.\n-    ProcessedErrors(Vec<ProcessedErrorOrigin<'tcx>>,\n-                    Vec<SameRegions>),\n }\n \n #[derive(Clone, Debug)]\n@@ -186,33 +179,6 @@ pub enum ProcessedErrorOrigin<'tcx> {\n     VariableFailure(RegionVariableOrigin),\n }\n \n-/// SameRegions is used to group regions that we think are the same and would\n-/// like to indicate so to the user.\n-/// For example, the following function\n-/// ```\n-/// struct Foo { bar: i32 }\n-/// fn foo2<'a, 'b>(x: &'a Foo) -> &'b i32 {\n-///    &x.bar\n-/// }\n-/// ```\n-/// would report an error because we expect 'a and 'b to match, and so we group\n-/// 'a and 'b together inside a SameRegions struct\n-#[derive(Clone, Debug)]\n-pub struct SameRegions {\n-    pub scope_id: ast::NodeId,\n-    pub regions: Vec<BoundRegion>,\n-}\n-\n-impl SameRegions {\n-    pub fn contains(&self, other: &BoundRegion) -> bool {\n-        self.regions.contains(other)\n-    }\n-\n-    pub fn push(&mut self, other: BoundRegion) {\n-        self.regions.push(other);\n-    }\n-}\n-\n pub type CombineMap<'tcx> = FxHashMap<TwoRegions<'tcx>, RegionVid>;\n \n pub struct RegionVarBindings<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {"}, {"sha": "3403cf0477450005d7156bd027b4dd746608e029", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -777,6 +777,12 @@ pub enum StatementKind<'tcx> {\n     /// End the current live range for the storage of the local.\n     StorageDead(Lvalue<'tcx>),\n \n+    InlineAsm {\n+        asm: InlineAsm,\n+        outputs: Vec<Lvalue<'tcx>>,\n+        inputs: Vec<Operand<'tcx>>\n+    },\n+\n     /// No-op. Useful for deleting instructions without affecting statement indices.\n     Nop,\n }\n@@ -790,7 +796,10 @@ impl<'tcx> Debug for Statement<'tcx> {\n             StorageDead(ref lv) => write!(fmt, \"StorageDead({:?})\", lv),\n             SetDiscriminant{lvalue: ref lv, variant_index: index} => {\n                 write!(fmt, \"discriminant({:?}) = {:?}\", lv, index)\n-            }\n+            },\n+            InlineAsm { ref asm, ref outputs, ref inputs } => {\n+                write!(fmt, \"asm!({:?} : {:?} : {:?})\", asm, outputs, inputs)\n+            },\n             Nop => write!(fmt, \"nop\"),\n         }\n     }\n@@ -1004,12 +1013,6 @@ pub enum Rvalue<'tcx> {\n     /// that `Foo` has a destructor. These rvalues can be optimized\n     /// away after type-checking and before lowering.\n     Aggregate(AggregateKind<'tcx>, Vec<Operand<'tcx>>),\n-\n-    InlineAsm {\n-        asm: InlineAsm,\n-        outputs: Vec<Lvalue<'tcx>>,\n-        inputs: Vec<Operand<'tcx>>\n-    }\n }\n \n #[derive(Clone, Copy, Debug, PartialEq, Eq, RustcEncodable, RustcDecodable)]\n@@ -1111,10 +1114,6 @@ impl<'tcx> Debug for Rvalue<'tcx> {\n             UnaryOp(ref op, ref a) => write!(fmt, \"{:?}({:?})\", op, a),\n             Discriminant(ref lval) => write!(fmt, \"discriminant({:?})\", lval),\n             Box(ref t) => write!(fmt, \"Box({:?})\", t),\n-            InlineAsm { ref asm, ref outputs, ref inputs } => {\n-                write!(fmt, \"asm!({:?} : {:?} : {:?})\", asm, outputs, inputs)\n-            }\n-\n             Ref(_, borrow_kind, ref lv) => {\n                 let kind_str = match borrow_kind {\n                     BorrowKind::Shared => \"\","}, {"sha": "5c8d031caf60dafc365bcba535d7fb41a204b4fe", "filename": "src/librustc/mir/tcx.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Flibrustc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Flibrustc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftcx.rs?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -207,7 +207,6 @@ impl<'tcx> Rvalue<'tcx> {\n                     }\n                 }\n             }\n-            Rvalue::InlineAsm { .. } => None\n         }\n     }\n }"}, {"sha": "7cdbd5cae061fc0f8b7100ae1ec9a2cbffab6fee", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -333,6 +333,16 @@ macro_rules! make_mir_visitor {\n                     StatementKind::StorageDead(ref $($mutability)* lvalue) => {\n                         self.visit_lvalue(lvalue, LvalueContext::StorageDead, location);\n                     }\n+                    StatementKind::InlineAsm { ref $($mutability)* outputs,\n+                                               ref $($mutability)* inputs,\n+                                               asm: _ } => {\n+                        for output in & $($mutability)* outputs[..] {\n+                            self.visit_lvalue(output, LvalueContext::Store, location);\n+                        }\n+                        for input in & $($mutability)* inputs[..] {\n+                            self.visit_operand(input, location);\n+                        }\n+                    }\n                     StatementKind::Nop => {}\n                 }\n             }\n@@ -526,17 +536,6 @@ macro_rules! make_mir_visitor {\n                             self.visit_operand(operand, location);\n                         }\n                     }\n-\n-                    Rvalue::InlineAsm { ref $($mutability)* outputs,\n-                                        ref $($mutability)* inputs,\n-                                        asm: _ } => {\n-                        for output in & $($mutability)* outputs[..] {\n-                            self.visit_lvalue(output, LvalueContext::Store, location);\n-                        }\n-                        for input in & $($mutability)* inputs[..] {\n-                            self.visit_operand(input, location);\n-                        }\n-                    }\n                 }\n             }\n "}, {"sha": "58ab713ef27308e220dd15cfe15ff5f6734dbf4f", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -628,6 +628,11 @@ pub fn get_vtable_methods<'a, 'tcx>(\n                                           |_, _| tcx.mk_region(ty::ReErased),\n                                           |def, _| trait_ref.substs().type_for_def(def));\n \n+            // the trait type may have higher-ranked lifetimes in it;\n+            // so erase them if they appear, so that we get the type\n+            // at some particular call site\n+            let substs = tcx.erase_late_bound_regions_and_normalize(&ty::Binder(substs));\n+\n             // It's possible that the method relies on where clauses that\n             // do not hold for this particular set of type parameters.\n             // Note that this method could then never be called, so we"}, {"sha": "40c62762c3cf3eab68a442ac242e0e59f8680331", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -2547,7 +2547,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 // TyError and ensure they do not affect any other fields.\n                 // This could be checked after type collection for any struct\n                 // with a potentially unsized trailing field.\n-                let params = substs_a.params().iter().enumerate().map(|(i, &k)| {\n+                let params = substs_a.iter().enumerate().map(|(i, &k)| {\n                     if ty_params.contains(i) {\n                         Kind::from(tcx.types.err)\n                     } else {\n@@ -2567,7 +2567,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n \n                 // Check that the source structure with the target's\n                 // type parameters is a subtype of the target.\n-                let params = substs_a.params().iter().enumerate().map(|(i, &k)| {\n+                let params = substs_a.iter().enumerate().map(|(i, &k)| {\n                     if ty_params.contains(i) {\n                         Kind::from(substs_b.type_at(i))\n                     } else {"}, {"sha": "7937d2ccfe46da45d4c6e5d5524a6599986a7590", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 12, "deletions": 18, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -34,7 +34,6 @@ use serialize::{self, Encodable, Encoder};\n use std::borrow::Cow;\n use std::cell::{Cell, RefCell, Ref};\n use std::hash::{Hash, Hasher};\n-use std::iter;\n use std::ops::Deref;\n use std::rc::Rc;\n use std::slice;\n@@ -843,27 +842,22 @@ impl<'tcx> TraitPredicate<'tcx> {\n \n     /// Creates the dep-node for selecting/evaluating this trait reference.\n     fn dep_node(&self) -> DepNode<DefId> {\n-        // Ideally, the dep-node would just have all the input types\n-        // in it.  But they are limited to including def-ids. So as an\n-        // approximation we include the def-ids for all nominal types\n-        // found somewhere. This means that we will e.g. conflate the\n-        // dep-nodes for `u32: SomeTrait` and `u64: SomeTrait`, but we\n-        // would have distinct dep-nodes for `Vec<u32>: SomeTrait`,\n-        // `Rc<u32>: SomeTrait`, and `(Vec<u32>, Rc<u32>): SomeTrait`.\n-        // Note that it's always sound to conflate dep-nodes, it just\n-        // leads to more recompilation.\n-        let def_ids: Vec<_> =\n+        // Extact the trait-def and first def-id from inputs.  See the\n+        // docs for `DepNode::TraitSelect` for more information.\n+        let trait_def_id = self.def_id();\n+        let input_def_id =\n             self.input_types()\n                 .flat_map(|t| t.walk())\n                 .filter_map(|t| match t.sty {\n-                    ty::TyAdt(adt_def, _) =>\n-                        Some(adt_def.did),\n-                    _ =>\n-                        None\n+                    ty::TyAdt(adt_def, _) => Some(adt_def.did),\n+                    _ => None\n                 })\n-                .chain(iter::once(self.def_id()))\n-                .collect();\n-        DepNode::TraitSelect(def_ids)\n+                .next()\n+                .unwrap_or(trait_def_id);\n+        DepNode::TraitSelect {\n+            trait_def_id: trait_def_id,\n+            input_def_id: input_def_id\n+        }\n     }\n \n     pub fn input_types<'a>(&'a self) -> impl DoubleEndedIterator<Item=Ty<'tcx>> + 'a {"}, {"sha": "2e3009b4ed6dba72b0c814a700ae28dd40cb2475", "filename": "src/librustc/ty/relate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Flibrustc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Flibrustc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Frelate.rs?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -143,7 +143,7 @@ pub fn relate_substs<'a, 'gcx, 'tcx, R>(relation: &mut R,\n {\n     let tcx = relation.tcx();\n \n-    let params = a_subst.params().iter().zip(b_subst.params()).enumerate().map(|(i, (a, b))| {\n+    let params = a_subst.iter().zip(b_subst).enumerate().map(|(i, (a, b))| {\n         let variance = variances.map_or(ty::Invariant, |v| v[i]);\n         if let (Some(a_ty), Some(b_ty)) = (a.as_type(), b.as_type()) {\n             Ok(Kind::from(relation.relate_with_variance(variance, &a_ty, &b_ty)?))"}, {"sha": "c0a529b936b0fbde258a5aa22aadc5e93c06e92a", "filename": "src/librustc/ty/subst.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Flibrustc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Flibrustc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsubst.rs?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -254,12 +254,6 @@ impl<'a, 'gcx, 'tcx> Substs<'tcx> {\n         self.is_empty()\n     }\n \n-    #[inline]\n-    pub fn params(&self) -> &[Kind<'tcx>] {\n-        // FIXME (dikaiosune) this should be removed, and corresponding compilation errors fixed\n-        self\n-    }\n-\n     #[inline]\n     pub fn types(&'a self) -> impl DoubleEndedIterator<Item=Ty<'tcx>> + 'a {\n         self.iter().filter_map(|k| k.as_type())"}, {"sha": "7888a56d39dfbd5a5b3757160009e73acf2d7e61", "filename": "src/librustc_borrowck/borrowck/mir/dataflow/impls.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fimpls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fimpls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fimpls.rs?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -473,6 +473,7 @@ impl<'a, 'tcx> BitDenotation for MovingOutStatements<'a, 'tcx> {\n             }\n             mir::StatementKind::StorageLive(_) |\n             mir::StatementKind::StorageDead(_) |\n+            mir::StatementKind::InlineAsm { .. } |\n             mir::StatementKind::Nop => {}\n         }\n     }"}, {"sha": "940dd5433a0d9ee3846f762c9a8da678293be009", "filename": "src/librustc_borrowck/borrowck/mir/dataflow/sanity_check.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fsanity_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fsanity_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fsanity_check.rs?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -104,6 +104,7 @@ fn each_block<'a, 'tcx, O>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             }\n             mir::StatementKind::StorageLive(_) |\n             mir::StatementKind::StorageDead(_) |\n+            mir::StatementKind::InlineAsm { .. } |\n             mir::StatementKind::Nop => continue,\n             mir::StatementKind::SetDiscriminant{ .. } =>\n                 span_bug!(stmt.source_info.span,"}, {"sha": "35ace6628cfed4d7f244443a4feda936e20555c3", "filename": "src/librustc_borrowck/borrowck/mir/gather_moves.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgather_moves.rs?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -412,6 +412,7 @@ impl<'a, 'tcx> MoveDataBuilder<'a, 'tcx> {\n                 span_bug!(stmt.source_info.span,\n                           \"SetDiscriminant should not exist during borrowck\");\n             }\n+            StatementKind::InlineAsm { .. } |\n             StatementKind::Nop => {}\n         }\n     }\n@@ -436,8 +437,7 @@ impl<'a, 'tcx> MoveDataBuilder<'a, 'tcx> {\n             }\n             Rvalue::Ref(..) |\n             Rvalue::Discriminant(..) |\n-            Rvalue::Len(..) |\n-            Rvalue::InlineAsm { .. } => {}\n+            Rvalue::Len(..) => {}\n             Rvalue::Box(..) => {\n                 // This returns an rvalue with uninitialized contents. We can't\n                 // move out of it here because it is an rvalue - assignments always"}, {"sha": "d9283e7037f50f2dc851af5ec9cb53737709f837", "filename": "src/librustc_borrowck/borrowck/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fmod.rs?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -378,6 +378,7 @@ fn drop_flag_effects_for_location<'a, 'tcx, F>(\n             }\n             mir::StatementKind::StorageLive(_) |\n             mir::StatementKind::StorageDead(_) |\n+            mir::StatementKind::InlineAsm { .. } |\n             mir::StatementKind::Nop => {}\n         },\n         None => {"}, {"sha": "de789d5686fcfb81024bb8ebf8e66bfd4f66686d", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -726,6 +726,8 @@ pub fn phase_2_configure_and_expand<F>(sess: &Session,\n         });\n     }\n \n+    after_expand(&krate)?;\n+\n     if sess.opts.debugging_opts.input_stats {\n         println!(\"Post-expansion node count: {}\", count_nodes(&krate));\n     }\n@@ -751,14 +753,14 @@ pub fn phase_2_configure_and_expand<F>(sess: &Session,\n          || ast_validation::check_crate(sess, &krate));\n \n     time(time_passes, \"name resolution\", || -> CompileResult {\n-        // Since import resolution will eventually happen in expansion,\n-        // don't perform `after_expand` until after import resolution.\n-        after_expand(&krate)?;\n-\n         resolver.resolve_crate(&krate);\n         Ok(())\n     })?;\n \n+    if resolver.found_unresolved_macro {\n+        sess.parse_sess.span_diagnostic.abort_if_errors();\n+    }\n+\n     // Needs to go *after* expansion to be able to check the results of macro expansion.\n     time(time_passes, \"complete gated feature checking\", || {\n         sess.track_errors(|| {"}, {"sha": "7adcc0e730b15710425c9ead59b7586b2048fc87", "filename": "src/librustc_mir/build/expr/as_rvalue.rs", "status": "modified", "additions": 1, "deletions": 15, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -49,21 +49,6 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             ExprKind::Scope { extent, value } => {\n                 this.in_scope(extent, block, |this| this.as_rvalue(block, value))\n             }\n-            ExprKind::InlineAsm { asm, outputs, inputs } => {\n-                let outputs = outputs.into_iter().map(|output| {\n-                    unpack!(block = this.as_lvalue(block, output))\n-                }).collect();\n-\n-                let inputs = inputs.into_iter().map(|input| {\n-                    unpack!(block = this.as_operand(block, input))\n-                }).collect();\n-\n-                block.and(Rvalue::InlineAsm {\n-                    asm: asm.clone(),\n-                    outputs: outputs,\n-                    inputs: inputs\n-                })\n-            }\n             ExprKind::Repeat { value, count } => {\n                 let value_operand = unpack!(block = this.as_operand(block, value));\n                 block.and(Rvalue::Repeat(value_operand, count))\n@@ -238,6 +223,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             ExprKind::Break { .. } |\n             ExprKind::Continue { .. } |\n             ExprKind::Return { .. } |\n+            ExprKind::InlineAsm { .. } |\n             ExprKind::StaticRef { .. } => {\n                 // these do not have corresponding `Rvalue` variants,\n                 // so make an operand and then return that"}, {"sha": "e66f2b4e2bfc0a018df4f4e1927beac6ca80f58f", "filename": "src/librustc_mir/build/expr/into.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -232,6 +232,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             ExprKind::AssignOp { .. } |\n             ExprKind::Continue { .. } |\n             ExprKind::Break { .. } |\n+            ExprKind::InlineAsm { .. } |\n             ExprKind::Return {.. } => {\n                 this.stmt_expr(block, expr)\n             }\n@@ -257,7 +258,6 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             ExprKind::Index { .. } |\n             ExprKind::Deref { .. } |\n             ExprKind::Literal { .. } |\n-            ExprKind::InlineAsm { .. } |\n             ExprKind::Field { .. } => {\n                 debug_assert!(match Category::of(&expr.kind).unwrap() {\n                     Category::Rvalue(RvalueFunc::Into) => false,"}, {"sha": "c577aab40dbeb4a9729e23600f8db7e955325ceb", "filename": "src/librustc_mir/build/expr/stmt.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fstmt.rs?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -117,6 +117,23 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 this.exit_scope(expr_span, extent, block, return_block);\n                 this.cfg.start_new_block().unit()\n             }\n+            ExprKind::InlineAsm { asm, outputs, inputs } => {\n+                let outputs = outputs.into_iter().map(|output| {\n+                    unpack!(block = this.as_lvalue(block, output))\n+                }).collect();\n+                let inputs = inputs.into_iter().map(|input| {\n+                    unpack!(block = this.as_operand(block, input))\n+                }).collect();\n+                this.cfg.push(block, Statement {\n+                    source_info: source_info,\n+                    kind: StatementKind::InlineAsm {\n+                        asm: asm.clone(),\n+                        outputs: outputs,\n+                        inputs: inputs\n+                    },\n+                });\n+                block.unit()\n+            }\n             _ => {\n                 let expr_ty = expr.ty;\n                 let temp = this.temp(expr.ty.clone());"}, {"sha": "4459142cfb2746dcc0ead02355fe2079bf99b9c7", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -774,10 +774,6 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n                     }\n                 }\n             }\n-\n-            Rvalue::InlineAsm {..} => {\n-                self.not_const();\n-            }\n         }\n     }\n \n@@ -933,6 +929,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n                 StatementKind::SetDiscriminant { .. } |\n                 StatementKind::StorageLive(_) |\n                 StatementKind::StorageDead(_) |\n+                StatementKind::InlineAsm {..} |\n                 StatementKind::Nop => {}\n             }\n         });"}, {"sha": "8d108815e0f3c8e44439b29efc80794b95bc2d58", "filename": "src/librustc_mir/transform/type_check.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -361,9 +361,9 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                         span_mirbug!(self, stmt, \"bad assignment ({:?} = {:?}): {:?}\",\n                                      lv_ty, rv_ty, terr);\n                     }\n-                // FIXME: rvalue with undeterminable type - e.g. inline\n-                // asm.\n                 }\n+                // FIXME: rvalue with undeterminable type - e.g. AggregateKind::Array branch that\n+                // returns `None`.\n             }\n             StatementKind::SetDiscriminant{ ref lvalue, variant_index } => {\n                 let lvalue_type = lvalue.ty(mir, tcx).to_ty(tcx);\n@@ -392,6 +392,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                     }\n                 }\n             }\n+            StatementKind::InlineAsm { .. } |\n             StatementKind::Nop => {}\n         }\n     }"}, {"sha": "33b7089c38214543759808153fc3f52520bef57e", "filename": "src/librustc_passes/mir_stats.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Flibrustc_passes%2Fmir_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Flibrustc_passes%2Fmir_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fmir_stats.rs?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -128,6 +128,7 @@ impl<'a, 'tcx> mir_visit::Visitor<'tcx> for StatCollector<'a, 'tcx> {\n             StatementKind::SetDiscriminant { .. } => \"StatementKind::SetDiscriminant\",\n             StatementKind::StorageLive(..) => \"StatementKind::StorageLive\",\n             StatementKind::StorageDead(..) => \"StatementKind::StorageDead\",\n+            StatementKind::InlineAsm { .. } => \"StatementKind::InlineAsm\",\n             StatementKind::Nop => \"StatementKind::Nop\",\n         }, &statement.kind);\n         self.super_statement(block, statement, location);\n@@ -198,7 +199,6 @@ impl<'a, 'tcx> mir_visit::Visitor<'tcx> for StatCollector<'a, 'tcx> {\n \n                 \"Rvalue::Aggregate\"\n             }\n-            Rvalue::InlineAsm { .. } => \"Rvalue::InlineAsm\",\n         };\n         self.record(rvalue_kind, rvalue);\n         self.super_rvalue(rvalue, location);"}, {"sha": "c9e870188aaeccb36199b4d13a3d4178ff4961da", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 41, "deletions": 43, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -51,6 +51,7 @@ use syntax::ext::hygiene::{Mark, SyntaxContext};\n use syntax::ast::{self, Name, NodeId, Ident, SpannedIdent, FloatTy, IntTy, UintTy};\n use syntax::ext::base::SyntaxExtension;\n use syntax::ext::base::Determinacy::{Determined, Undetermined};\n+use syntax::ext::base::MacroKind;\n use syntax::symbol::{Symbol, keywords};\n use syntax::util::lev_distance::find_best_match_for_name;\n \n@@ -785,7 +786,7 @@ pub struct ModuleData<'a> {\n     normal_ancestor_id: DefId,\n \n     resolutions: RefCell<FxHashMap<(Ident, Namespace), &'a RefCell<NameResolution<'a>>>>,\n-    legacy_macro_resolutions: RefCell<Vec<(Mark, Ident, Span)>>,\n+    legacy_macro_resolutions: RefCell<Vec<(Mark, Ident, Span, MacroKind)>>,\n     macro_resolutions: RefCell<Vec<(Box<[Ident]>, Span)>>,\n \n     // Macro invocations that can expand into items in this module.\n@@ -1117,6 +1118,7 @@ pub struct Resolver<'a> {\n     macro_map: FxHashMap<DefId, Rc<SyntaxExtension>>,\n     macro_exports: Vec<Export>,\n     pub whitelisted_legacy_custom_derives: Vec<Name>,\n+    pub found_unresolved_macro: bool,\n \n     // Maps the `Mark` of an expansion to its containing module or block.\n     invocations: FxHashMap<Mark, &'a InvocationData<'a>>,\n@@ -1193,7 +1195,8 @@ impl<'a> hir::lowering::Resolver for Resolver<'a> {\n         let path: Vec<_> = segments.iter().map(|seg| Ident::with_empty_ctxt(seg.name)).collect();\n         match self.resolve_path(&path, Some(namespace), Some(span)) {\n             PathResult::Module(module) => *def = module.def().unwrap(),\n-            PathResult::NonModule(path_res) if path_res.depth == 0 => *def = path_res.base_def,\n+            PathResult::NonModule(path_res) if path_res.unresolved_segments() == 0 =>\n+                *def = path_res.base_def(),\n             PathResult::NonModule(..) => match self.resolve_path(&path, None, Some(span)) {\n                 PathResult::Failed(msg, _) => {\n                     resolve_error(self, span, ResolutionError::FailedToResolve(&msg));\n@@ -1315,6 +1318,7 @@ impl<'a> Resolver<'a> {\n             warned_proc_macros: FxHashSet(),\n             potentially_unused_imports: Vec::new(),\n             struct_constructors: DefIdMap(),\n+            found_unresolved_macro: false,\n         }\n     }\n \n@@ -1715,7 +1719,7 @@ impl<'a> Resolver<'a> {\n         let mut new_id = None;\n         if let Some(trait_ref) = opt_trait_ref {\n             let def = self.smart_resolve_path(trait_ref.ref_id, None,\n-                                              &trait_ref.path, PathSource::Trait).base_def;\n+                                              &trait_ref.path, PathSource::Trait).base_def();\n             if def != Def::Err {\n                 new_val = Some((def.def_id(), trait_ref.clone()));\n                 new_id = Some(def.def_id());\n@@ -1846,8 +1850,8 @@ impl<'a> Resolver<'a> {\n \n         pat.walk(&mut |pat| {\n             if let PatKind::Ident(binding_mode, ident, ref sub_pat) = pat.node {\n-                if sub_pat.is_some() || match self.def_map.get(&pat.id) {\n-                    Some(&PathResolution { base_def: Def::Local(..), .. }) => true,\n+                if sub_pat.is_some() || match self.def_map.get(&pat.id).map(|res| res.base_def()) {\n+                    Some(Def::Local(..)) => true,\n                     _ => false,\n                 } {\n                     let binding_info = BindingInfo { span: ident.span, binding_mode: binding_mode };\n@@ -2245,14 +2249,14 @@ impl<'a> Resolver<'a> {\n         let resolution = match self.resolve_qpath_anywhere(id, qself, path, ns, span,\n                                                            source.defer_to_typeck(),\n                                                            source.global_by_default()) {\n-            Some(resolution) if resolution.depth == 0 => {\n-                if is_expected(resolution.base_def) || resolution.base_def == Def::Err {\n+            Some(resolution) if resolution.unresolved_segments() == 0 => {\n+                if is_expected(resolution.base_def()) || resolution.base_def() == Def::Err {\n                     resolution\n                 } else {\n                     // Add a temporary hack to smooth the transition to new struct ctor\n                     // visibility rules. See #38932 for more details.\n                     let mut res = None;\n-                    if let Def::Struct(def_id) = resolution.base_def {\n+                    if let Def::Struct(def_id) = resolution.base_def() {\n                         if let Some((ctor_def, ctor_vis))\n                                 = self.struct_constructors.get(&def_id).cloned() {\n                             if is_expected(ctor_def) && self.is_accessible(ctor_vis) {\n@@ -2265,7 +2269,7 @@ impl<'a> Resolver<'a> {\n                         }\n                     }\n \n-                    res.unwrap_or_else(|| report_errors(self, Some(resolution.base_def)))\n+                    res.unwrap_or_else(|| report_errors(self, Some(resolution.base_def())))\n                 }\n             }\n             Some(resolution) if source.defer_to_typeck() => {\n@@ -2318,7 +2322,8 @@ impl<'a> Resolver<'a> {\n                 match self.resolve_qpath(id, qself, path, ns, span, global_by_default) {\n                     // If defer_to_typeck, then resolution > no resolution,\n                     // otherwise full resolution > partial resolution > no resolution.\n-                    Some(res) if res.depth == 0 || defer_to_typeck => return Some(res),\n+                    Some(res) if res.unresolved_segments() == 0 || defer_to_typeck =>\n+                        return Some(res),\n                     res => if fin_res.is_none() { fin_res = res },\n                 };\n             }\n@@ -2343,19 +2348,17 @@ impl<'a> Resolver<'a> {\n         if let Some(qself) = qself {\n             if qself.position == 0 {\n                 // FIXME: Create some fake resolution that can't possibly be a type.\n-                return Some(PathResolution {\n-                    base_def: Def::Mod(DefId::local(CRATE_DEF_INDEX)),\n-                    depth: path.len(),\n-                });\n+                return Some(PathResolution::with_unresolved_segments(\n+                    Def::Mod(DefId::local(CRATE_DEF_INDEX)), path.len()\n+                ));\n             }\n             // Make sure `A::B` in `<T as A>::B::C` is a trait item.\n             let ns = if qself.position + 1 == path.len() { ns } else { TypeNS };\n-            let mut res = self.smart_resolve_path_fragment(id, None, &path[..qself.position + 1],\n-                                                           span, PathSource::TraitItem(ns));\n-            if res.base_def != Def::Err {\n-                res.depth += path.len() - qself.position - 1;\n-            }\n-            return Some(res);\n+            let res = self.smart_resolve_path_fragment(id, None, &path[..qself.position + 1],\n+                                                       span, PathSource::TraitItem(ns));\n+            return Some(PathResolution::with_unresolved_segments(\n+                res.base_def(), res.unresolved_segments() + path.len() - qself.position - 1\n+            ));\n         }\n \n         let result = match self.resolve_path(&path, Some(ns), Some(span)) {\n@@ -2390,10 +2393,7 @@ impl<'a> Resolver<'a> {\n                     }\n                     _ => {}\n                 }\n-                PathResolution {\n-                    base_def: Def::PrimTy(prim),\n-                    depth: path.len() - 1,\n-                }\n+                PathResolution::with_unresolved_segments(Def::PrimTy(prim), path.len() - 1)\n             }\n             PathResult::Module(module) => PathResolution::new(module.def().unwrap()),\n             PathResult::Failed(msg, false) => {\n@@ -2404,16 +2404,16 @@ impl<'a> Resolver<'a> {\n             PathResult::Indeterminate => bug!(\"indetermined path result in resolve_qpath\"),\n         };\n \n-        if path.len() > 1 && !global_by_default && result.base_def != Def::Err &&\n+        if path.len() > 1 && !global_by_default && result.base_def() != Def::Err &&\n            path[0].name != keywords::CrateRoot.name() && path[0].name != \"$crate\" {\n             let unqualified_result = {\n                 match self.resolve_path(&[*path.last().unwrap()], Some(ns), None) {\n-                    PathResult::NonModule(path_res) => path_res.base_def,\n+                    PathResult::NonModule(path_res) => path_res.base_def(),\n                     PathResult::Module(module) => module.def().unwrap(),\n                     _ => return Some(result),\n                 }\n             };\n-            if result.base_def == unqualified_result {\n+            if result.base_def() == unqualified_result {\n                 let lint = lint::builtin::UNUSED_QUALIFICATIONS;\n                 self.session.add_lint(lint, id, span, \"unnecessary qualification\".to_string());\n             }\n@@ -2467,10 +2467,9 @@ impl<'a> Resolver<'a> {\n                     Some(LexicalScopeBinding::Item(binding)) => Ok(binding),\n                     Some(LexicalScopeBinding::Def(def))\n                             if opt_ns == Some(TypeNS) || opt_ns == Some(ValueNS) => {\n-                        return PathResult::NonModule(PathResolution {\n-                            base_def: def,\n-                            depth: path.len() - 1,\n-                        });\n+                        return PathResult::NonModule(PathResolution::with_unresolved_segments(\n+                            def, path.len() - 1\n+                        ));\n                     }\n                     _ => Err(if record_used.is_some() { Determined } else { Undetermined }),\n                 }\n@@ -2485,10 +2484,9 @@ impl<'a> Resolver<'a> {\n                     } else if def == Def::Err {\n                         return PathResult::NonModule(err_path_resolution());\n                     } else if opt_ns.is_some() && (is_last || maybe_assoc) {\n-                        return PathResult::NonModule(PathResolution {\n-                            base_def: def,\n-                            depth: path.len() - i - 1,\n-                        });\n+                        return PathResult::NonModule(PathResolution::with_unresolved_segments(\n+                            def, path.len() - i - 1\n+                        ));\n                     } else {\n                         return PathResult::Failed(format!(\"Not a module `{}`\", ident), is_last);\n                     }\n@@ -2497,10 +2495,9 @@ impl<'a> Resolver<'a> {\n                 Err(Determined) => {\n                     if let Some(module) = module {\n                         if opt_ns.is_some() && !module.is_normal() {\n-                            return PathResult::NonModule(PathResolution {\n-                                base_def: module.def().unwrap(),\n-                                depth: path.len() - i,\n-                            });\n+                            return PathResult::NonModule(PathResolution::with_unresolved_segments(\n+                                module.def().unwrap(), path.len() - i\n+                            ));\n                         }\n                     }\n                     let msg = if module.and_then(ModuleData::def) == self.graph_root.def() {\n@@ -2669,8 +2666,9 @@ impl<'a> Resolver<'a> {\n             if let Some(node_id) = self.current_self_type.as_ref().and_then(extract_node_id) {\n                 // Look for a field with the same name in the current self_type.\n                 if let Some(resolution) = self.def_map.get(&node_id) {\n-                    match resolution.base_def {\n-                        Def::Struct(did) | Def::Union(did) if resolution.depth == 0 => {\n+                    match resolution.base_def() {\n+                        Def::Struct(did) | Def::Union(did)\n+                                if resolution.unresolved_segments() == 0 => {\n                             if let Some(field_names) = self.field_names.get(&did) {\n                                 if field_names.iter().any(|&field_name| name == field_name) {\n                                     return Some(AssocSuggestion::Field);\n@@ -3054,7 +3052,6 @@ impl<'a> Resolver<'a> {\n \n     fn record_def(&mut self, node_id: NodeId, resolution: PathResolution) {\n         debug!(\"(recording def) recording {:?} for {}\", resolution, node_id);\n-        assert!(resolution.depth == 0 || resolution.base_def != Def::Err);\n         if let Some(prev_res) = self.def_map.insert(node_id, resolution) {\n             panic!(\"path resolved multiple times ({:?} before, {:?} now)\", prev_res, resolution);\n         }\n@@ -3068,7 +3065,8 @@ impl<'a> Resolver<'a> {\n                 ty::Visibility::Restricted(self.current_module.normal_ancestor_id)\n             }\n             ast::Visibility::Restricted { ref path, id } => {\n-                let def = self.smart_resolve_path(id, None, path, PathSource::Visibility).base_def;\n+                let def = self.smart_resolve_path(id, None, path,\n+                                                  PathSource::Visibility).base_def();\n                 if def == Def::Err {\n                     ty::Visibility::Public\n                 } else {"}, {"sha": "8d563d20549c3b8e78108d75231941ce3b54e358", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 74, "deletions": 53, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -24,6 +24,7 @@ use syntax::attr;\n use syntax::errors::DiagnosticBuilder;\n use syntax::ext::base::{self, Determinacy, MultiModifier, MultiDecorator};\n use syntax::ext::base::{NormalTT, Resolver as SyntaxResolver, SyntaxExtension};\n+use syntax::ext::base::MacroKind;\n use syntax::ext::expand::{Expansion, mark_tts};\n use syntax::ext::hygiene::Mark;\n use syntax::ext::tt::macro_rules;\n@@ -236,8 +237,8 @@ impl<'a> base::Resolver for Resolver<'a> {\n         None\n     }\n \n-    fn resolve_macro(&mut self, scope: Mark, path: &ast::Path, force: bool)\n-                     -> Result<Rc<SyntaxExtension>, Determinacy> {\n+    fn resolve_macro(&mut self, scope: Mark, path: &ast::Path, kind: MacroKind,\n+                     force: bool) -> Result<Rc<SyntaxExtension>, Determinacy> {\n         let ast::Path { ref segments, span } = *path;\n         if segments.iter().any(|segment| segment.parameters.is_some()) {\n             let kind =\n@@ -256,17 +257,21 @@ impl<'a> base::Resolver for Resolver<'a> {\n                 let msg = \"non-ident macro paths are experimental\";\n                 let feature = \"use_extern_macros\";\n                 emit_feature_err(&self.session.parse_sess, feature, span, GateIssue::Language, msg);\n+                self.found_unresolved_macro = true;\n                 return Err(Determinacy::Determined);\n             }\n \n             let ext = match self.resolve_path(&path, Some(MacroNS), None) {\n-                PathResult::NonModule(path_res) => match path_res.base_def {\n+                PathResult::NonModule(path_res) => match path_res.base_def() {\n                     Def::Err => Err(Determinacy::Determined),\n                     def @ _ => Ok(self.get_macro(def)),\n                 },\n                 PathResult::Module(..) => unreachable!(),\n                 PathResult::Indeterminate if !force => return Err(Determinacy::Undetermined),\n-                _ => Err(Determinacy::Determined),\n+                _ => {\n+                    self.found_unresolved_macro = true;\n+                    Err(Determinacy::Determined)\n+                },\n             };\n             self.current_module.macro_resolutions.borrow_mut()\n                 .push((path.into_boxed_slice(), span));\n@@ -279,40 +284,19 @@ impl<'a> base::Resolver for Resolver<'a> {\n             Some(MacroBinding::Modern(binding)) => Ok(binding.get_macro(self)),\n             None => match self.resolve_lexical_macro_path_segment(path[0], MacroNS, None) {\n                 Ok(binding) => Ok(binding.get_macro(self)),\n-                Err(Determinacy::Undetermined) if !force => return Err(Determinacy::Undetermined),\n-                _ => {\n-                    let msg = format!(\"macro undefined: `{}`\", name);\n-                    let mut err = self.session.struct_span_err(span, &msg);\n-                    self.suggest_macro_name(&name.as_str(), &mut err);\n-                    err.emit();\n-                    return Err(Determinacy::Determined);\n-                },\n+                Err(Determinacy::Undetermined) if !force =>\n+                    return Err(Determinacy::Undetermined),\n+                Err(_) => {\n+                    self.found_unresolved_macro = true;\n+                    Err(Determinacy::Determined)\n+                }\n             },\n         };\n \n-        if self.use_extern_macros {\n-            self.current_module.legacy_macro_resolutions.borrow_mut().push((scope, path[0], span));\n-        }\n-        result\n-    }\n+        self.current_module.legacy_macro_resolutions.borrow_mut()\n+            .push((scope, path[0], span, kind));\n \n-    fn resolve_derive_macro(&mut self, scope: Mark, path: &ast::Path, force: bool)\n-                            -> Result<Rc<SyntaxExtension>, Determinacy> {\n-        let ast::Path { span, .. } = *path;\n-        match self.resolve_macro(scope, path, false) {\n-            Ok(ext) => match *ext {\n-                SyntaxExtension::BuiltinDerive(..) |\n-                SyntaxExtension::ProcMacroDerive(..) => Ok(ext),\n-                _ => Err(Determinacy::Determined),\n-            },\n-            Err(Determinacy::Undetermined) if force => {\n-                let msg = format!(\"cannot find derive macro `{}` in this scope\", path);\n-                let mut err = self.session.struct_span_err(span, &msg);\n-                err.emit();\n-                Err(Determinacy::Determined)\n-            },\n-            Err(err) => Err(err),\n-        }\n+        result\n     }\n }\n \n@@ -438,37 +422,74 @@ impl<'a> Resolver<'a> {\n             }\n         }\n \n-        for &(mark, ident, span) in module.legacy_macro_resolutions.borrow().iter() {\n+        for &(mark, ident, span, kind) in module.legacy_macro_resolutions.borrow().iter() {\n             let legacy_scope = &self.invocations[&mark].legacy_scope;\n             let legacy_resolution = self.resolve_legacy_scope(legacy_scope, ident.name, true);\n             let resolution = self.resolve_lexical_macro_path_segment(ident, MacroNS, Some(span));\n-            let (legacy_resolution, resolution) = match (legacy_resolution, resolution) {\n-                (Some(legacy_resolution), Ok(resolution)) => (legacy_resolution, resolution),\n+            match (legacy_resolution, resolution) {\n+                (Some(legacy_resolution), Ok(resolution)) => {\n+                    let (legacy_span, participle) = match legacy_resolution {\n+                        MacroBinding::Modern(binding)\n+                            if binding.def() == resolution.def() => continue,\n+                        MacroBinding::Modern(binding) => (binding.span, \"imported\"),\n+                        MacroBinding::Legacy(binding) => (binding.span, \"defined\"),\n+                    };\n+                    let msg1 = format!(\"`{}` could refer to the macro {} here\", ident, participle);\n+                    let msg2 = format!(\"`{}` could also refer to the macro imported here\", ident);\n+                    self.session.struct_span_err(span, &format!(\"`{}` is ambiguous\", ident))\n+                        .span_note(legacy_span, &msg1)\n+                        .span_note(resolution.span, &msg2)\n+                        .emit();\n+                },\n                 (Some(MacroBinding::Modern(binding)), Err(_)) => {\n                     self.record_use(ident, MacroNS, binding, span);\n                     self.err_if_macro_use_proc_macro(ident.name, span, binding);\n-                    continue\n                 },\n-                _ => continue,\n-            };\n-            let (legacy_span, participle) = match legacy_resolution {\n-                MacroBinding::Modern(binding) if binding.def() == resolution.def() => continue,\n-                MacroBinding::Modern(binding) => (binding.span, \"imported\"),\n-                MacroBinding::Legacy(binding) => (binding.span, \"defined\"),\n+                (None, Err(_)) => {\n+                    let msg = match kind {\n+                        MacroKind::Bang =>\n+                            format!(\"cannot find macro `{}!` in this scope\", ident),\n+                        MacroKind::Attr =>\n+                            format!(\"cannot find attribute macro `{}` in this scope\", ident),\n+                        MacroKind::Derive =>\n+                            format!(\"cannot find derive macro `{}` in this scope\", ident),\n+                    };\n+                    let mut err = self.session.struct_span_err(span, &msg);\n+                    self.suggest_macro_name(&ident.name.as_str(), kind, &mut err);\n+                    err.emit();\n+                },\n+                _ => {},\n             };\n-            let msg1 = format!(\"`{}` could refer to the macro {} here\", ident, participle);\n-            let msg2 = format!(\"`{}` could also refer to the macro imported here\", ident);\n-            self.session.struct_span_err(span, &format!(\"`{}` is ambiguous\", ident))\n-                .span_note(legacy_span, &msg1)\n-                .span_note(resolution.span, &msg2)\n-                .emit();\n         }\n     }\n \n-    fn suggest_macro_name(&mut self, name: &str, err: &mut DiagnosticBuilder<'a>) {\n-        if let Some(suggestion) = find_best_match_for_name(self.macro_names.iter(), name, None) {\n+    fn suggest_macro_name(&mut self, name: &str, kind: MacroKind,\n+                          err: &mut DiagnosticBuilder<'a>) {\n+        let suggestion = match kind {\n+            MacroKind::Bang =>\n+                find_best_match_for_name(self.macro_names.iter(), name, None),\n+            MacroKind::Attr |\n+            MacroKind::Derive => {\n+                // Find a suggestion from the legacy namespace.\n+                // FIXME: get_macro needs an &mut Resolver, can we do it without cloning?\n+                let builtin_macros = self.builtin_macros.clone();\n+                let names = builtin_macros.iter().filter_map(|(name, binding)| {\n+                    if binding.get_macro(self).kind() == kind {\n+                        Some(name)\n+                    } else {\n+                        None\n+                    }\n+                });\n+                find_best_match_for_name(names, name, None)\n+            }\n+        };\n+        if let Some(suggestion) = suggestion {\n             if suggestion != name {\n-                err.help(&format!(\"did you mean `{}!`?\", suggestion));\n+                if let MacroKind::Bang = kind {\n+                    err.help(&format!(\"did you mean `{}!`?\", suggestion));\n+                } else {\n+                    err.help(&format!(\"did you mean `{}`?\", suggestion));\n+                }\n             } else {\n                 err.help(&format!(\"have you added the `#[macro_use]` on the module/import?\"));\n             }"}, {"sha": "40a69721495b8394ec797c0bb09d3f265a6600a9", "filename": "src/librustc_trans/back/write.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fwrite.rs?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -315,11 +315,15 @@ impl ModuleConfig {\n         // Copy what clang does by turning on loop vectorization at O2 and\n         // slp vectorization at O3. Otherwise configure other optimization aspects\n         // of this pass manager builder.\n+        // Turn off vectorization for emscripten, as it's not very well supported.\n         self.vectorize_loop = !sess.opts.cg.no_vectorize_loops &&\n                              (sess.opts.optimize == config::OptLevel::Default ||\n-                              sess.opts.optimize == config::OptLevel::Aggressive);\n+                              sess.opts.optimize == config::OptLevel::Aggressive) &&\n+                             !sess.target.target.options.is_like_emscripten;\n+\n         self.vectorize_slp = !sess.opts.cg.no_vectorize_slp &&\n-                            sess.opts.optimize == config::OptLevel::Aggressive;\n+                            sess.opts.optimize == config::OptLevel::Aggressive &&\n+                            !sess.target.target.options.is_like_emscripten;\n \n         self.merge_functions = sess.opts.optimize == config::OptLevel::Default ||\n                                sess.opts.optimize == config::OptLevel::Aggressive;"}, {"sha": "b5f948442b774d486aa95075981eab3ec1b827e1", "filename": "src/librustc_trans/collector.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Flibrustc_trans%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Flibrustc_trans%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcollector.rs?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -1090,13 +1090,16 @@ fn create_trans_items_for_vtable_methods<'a, 'tcx>(scx: &SharedCrateContext<'a,\n                                                    trait_ty: ty::Ty<'tcx>,\n                                                    impl_ty: ty::Ty<'tcx>,\n                                                    output: &mut Vec<TransItem<'tcx>>) {\n-    assert!(!trait_ty.needs_subst() && !impl_ty.needs_subst());\n+    assert!(!trait_ty.needs_subst() && !trait_ty.has_escaping_regions() &&\n+            !impl_ty.needs_subst() && !impl_ty.has_escaping_regions());\n \n     if let ty::TyDynamic(ref trait_ty, ..) = trait_ty.sty {\n         if let Some(principal) = trait_ty.principal() {\n             let poly_trait_ref = principal.with_self_ty(scx.tcx(), impl_ty);\n             let param_substs = scx.tcx().intern_substs(&[]);\n \n+            assert!(!poly_trait_ref.has_escaping_regions());\n+\n             // Walk all methods of the trait, including those of its supertraits\n             let methods = traits::get_vtable_methods(scx.tcx(), poly_trait_ref);\n             let methods = methods.filter_map(|method| method)"}, {"sha": "799f502aadbfa97cd4f844eb6e596a22119e4d40", "filename": "src/librustc_trans/context.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Flibrustc_trans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Flibrustc_trans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcontext.rs?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -208,7 +208,8 @@ impl<'gcx> DepTrackingMapConfig for ProjectionCache<'gcx> {\n                    _ => None,\n                })\n                .collect();\n-        DepNode::TraitSelect(def_ids)\n+\n+        DepNode::ProjectionCache { def_ids: def_ids }\n     }\n }\n "}, {"sha": "7e17ae5f1d389ceeb15bd713976391c2b87b9c21", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -287,8 +287,9 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                     mir::StatementKind::StorageLive(_) |\n                     mir::StatementKind::StorageDead(_) |\n                     mir::StatementKind::Nop => {}\n+                    mir::StatementKind::InlineAsm { .. } |\n                     mir::StatementKind::SetDiscriminant{ .. } => {\n-                        span_bug!(span, \"SetDiscriminant should not appear in constants?\");\n+                        span_bug!(span, \"{:?} should not appear in constants?\", statement.kind);\n                     }\n                 }\n             }"}, {"sha": "7d4f542addbb1aa4494b5e3342deead7c262e6fe", "filename": "src/librustc_trans/mir/rvalue.rs", "status": "modified", "additions": 2, "deletions": 19, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Frvalue.rs?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -16,7 +16,6 @@ use rustc::mir::tcx::LvalueTy;\n use rustc::mir;\n use middle::lang_items::ExchangeMallocFnLangItem;\n \n-use asm;\n use base;\n use builder::Builder;\n use callee::Callee;\n@@ -156,20 +155,6 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 bcx\n             }\n \n-            mir::Rvalue::InlineAsm { ref asm, ref outputs, ref inputs } => {\n-                let outputs = outputs.iter().map(|output| {\n-                    let lvalue = self.trans_lvalue(&bcx, output);\n-                    (lvalue.llval, lvalue.ty.to_ty(bcx.tcx()))\n-                }).collect();\n-\n-                let input_vals = inputs.iter().map(|input| {\n-                    self.trans_operand(&bcx, input).immediate()\n-                }).collect();\n-\n-                asm::trans_inline_asm(&bcx, asm, outputs, input_vals);\n-                bcx\n-            }\n-\n             _ => {\n                 assert!(rvalue_creates_operand(rvalue));\n                 let (bcx, temp) = self.trans_rvalue_operand(bcx, rvalue);\n@@ -468,8 +453,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 (bcx, operand)\n             }\n             mir::Rvalue::Repeat(..) |\n-            mir::Rvalue::Aggregate(..) |\n-            mir::Rvalue::InlineAsm { .. } => {\n+            mir::Rvalue::Aggregate(..) => {\n                 bug!(\"cannot generate operand from rvalue {:?}\", rvalue);\n \n             }\n@@ -669,8 +653,7 @@ pub fn rvalue_creates_operand(rvalue: &mir::Rvalue) -> bool {\n         mir::Rvalue::Use(..) =>\n             true,\n         mir::Rvalue::Repeat(..) |\n-        mir::Rvalue::Aggregate(..) |\n-        mir::Rvalue::InlineAsm { .. } =>\n+        mir::Rvalue::Aggregate(..) =>\n             false,\n     }\n "}, {"sha": "29a0648c8f8f8d48a6c95b1d4aa9570bd123ea24", "filename": "src/librustc_trans/mir/statement.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Flibrustc_trans%2Fmir%2Fstatement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Flibrustc_trans%2Fmir%2Fstatement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fstatement.rs?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -11,6 +11,7 @@\n use rustc::mir;\n \n use base;\n+use asm;\n use common;\n use builder::Builder;\n \n@@ -73,6 +74,19 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n             mir::StatementKind::StorageDead(ref lvalue) => {\n                 self.trans_storage_liveness(bcx, lvalue, base::Lifetime::End)\n             }\n+            mir::StatementKind::InlineAsm { ref asm, ref outputs, ref inputs } => {\n+                let outputs = outputs.iter().map(|output| {\n+                    let lvalue = self.trans_lvalue(&bcx, output);\n+                    (lvalue.llval, lvalue.ty.to_ty(bcx.tcx()))\n+                }).collect();\n+\n+                let input_vals = inputs.iter().map(|input| {\n+                    self.trans_operand(&bcx, input).immediate()\n+                }).collect();\n+\n+                asm::trans_inline_asm(&bcx, asm, outputs, input_vals);\n+                bcx\n+            }\n             mir::StatementKind::Nop => bcx,\n         }\n     }"}, {"sha": "ab1897101eb6ffe683c7b1d69f4be3a956d8b147", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -918,7 +918,19 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n             (_, Def::SelfTy(Some(_), Some(impl_def_id))) => {\n                 // `Self` in an impl of a trait - we have a concrete self type and a\n                 // trait reference.\n-                let trait_ref = tcx.impl_trait_ref(impl_def_id).unwrap();\n+                // FIXME: Self type is not always computed when we are here because type parameter\n+                // bounds may affect Self type and have to be converted before it.\n+                let trait_ref = if impl_def_id.is_local() {\n+                    tcx.impl_trait_refs.borrow().get(&impl_def_id).cloned().and_then(|x| x)\n+                } else {\n+                    tcx.impl_trait_ref(impl_def_id)\n+                };\n+                let trait_ref = if let Some(trait_ref) = trait_ref {\n+                    trait_ref\n+                } else {\n+                    tcx.sess.span_err(span, \"`Self` type is used before it's determined\");\n+                    return (tcx.types.err, Def::Err);\n+                };\n                 let trait_ref = if let Some(free_substs) = self.get_free_substs() {\n                     trait_ref.subst(tcx, free_substs)\n                 } else {"}, {"sha": "2d90394025d21ad909d2116e3d1a28dd923bea89", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -309,17 +309,17 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n         // parameters from the type and those from the method.\n         //\n         // FIXME -- permit users to manually specify lifetimes\n-        let supplied_start = substs.params().len() + method_generics.regions.len();\n+        let supplied_start = substs.len() + method_generics.regions.len();\n         Substs::for_item(self.tcx, pick.item.def_id, |def, _| {\n             let i = def.index as usize;\n-            if i < substs.params().len() {\n+            if i < substs.len() {\n                 substs.region_at(i)\n             } else {\n                 self.region_var_for_def(self.span, def)\n             }\n         }, |def, cur_substs| {\n             let i = def.index as usize;\n-            if i < substs.params().len() {\n+            if i < substs.len() {\n                 substs.type_at(i)\n             } else if supplied_method_types.is_empty() {\n                 self.type_var_for_def(self.span, def, cur_substs)"}, {"sha": "fd29ff0be43b44910d5f7860cd1727bd169ec289", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -1326,7 +1326,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n         } else {\n             let substs = Substs::for_item(self.tcx, method, |def, _| {\n                 let i = def.index as usize;\n-                if i < substs.params().len() {\n+                if i < substs.len() {\n                     substs.region_at(i)\n                 } else {\n                     // In general, during probe we erase regions. See\n@@ -1335,7 +1335,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                 }\n             }, |def, cur_substs| {\n                 let i = def.index as usize;\n-                if i < substs.params().len() {\n+                if i < substs.len() {\n                     substs.type_at(i)\n                 } else {\n                     self.type_var_for_def(self.span, def, cur_substs)"}, {"sha": "9d963226caf4bad488352f593cfa7731d2f86e59", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -4156,17 +4156,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         };\n \n         if self.diverges.get().always() {\n-            if let ExpectHasType(ety) = expected {\n-                // Avoid forcing a type (only `!` for now) in unreachable code.\n-                // FIXME(aburka) do we need this special case? and should it be is_uninhabited?\n-                if !ety.is_never() {\n-                    if let Some(ref e) = blk.expr {\n-                        // Coerce the tail expression to the right type.\n-                        self.demand_coerce(e, ty, ety);\n-                    }\n-                }\n-            }\n-\n             ty = self.next_diverging_ty_var(TypeVariableOrigin::DivergingBlockExpr(blk.span));\n         } else if let ExpectHasType(ety) = expected {\n             if let Some(ref e) = blk.expr {"}, {"sha": "a2922270583796ba54520c48a6710315167328dc", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -100,7 +100,7 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n \n         let gcx = fcx.tcx.global_tcx();\n         let free_substs = fcx.parameter_environment.free_substs;\n-        for (i, k) in free_substs.params().iter().enumerate() {\n+        for (i, k) in free_substs.iter().enumerate() {\n             let r = if let Some(r) = k.as_region() {\n                 r\n             } else {"}, {"sha": "fd5827b4c07537abeadc123e0550dfc61a135894", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -182,15 +182,15 @@ impl DefaultResizePolicy {\n // ----------------------\n // To protect against degenerate performance scenarios (including DOS attacks),\n // the implementation includes an adaptive behavior that can resize the map\n-// early (before it's capacity is exceeded) when suspiciously long probe or\n-// foward shifts sequences are encounted.\n+// early (before its capacity is exceeded) when suspiciously long probe or\n+// forward shifts sequences are encountered.\n //\n // With this algorithm in place it would be possible to turn a CPU attack into\n-// a memory attack due to the agressive resizing. To prevent that the\n+// a memory attack due to the aggressive resizing. To prevent that the\n // adaptive behavior only triggers when the map occupancy is half the maximum occupancy.\n-// This reduces the effectivenes of the algorithm but also makes it completelly safe.\n+// This reduces the effectiveness of the algorithm but also makes it completely safe.\n //\n-// The previous safety measure that also prevents degenerate iteractions with\n+// The previous safety measure also prevents degenerate interactions with\n // really bad quality hash algorithms that can make normal inputs look like a\n // DOS attack.\n //"}, {"sha": "dd4f1ff4f5ed7318c33850b9f341848fed948837", "filename": "src/libstd/env.rs", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Flibstd%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Flibstd%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fenv.rs?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -96,7 +96,9 @@ pub struct VarsOs { inner: os_imp::Env }\n ///\n /// While iterating, the returned iterator will panic if any key or value in the\n /// environment is not valid unicode. If this is not desired, consider using the\n-/// `env::vars_os` function.\n+/// [`env::vars_os`] function.\n+///\n+/// [`env::vars_os`]: fn.vars_os.html\n ///\n /// # Examples\n ///\n@@ -171,9 +173,12 @@ impl fmt::Debug for VarsOs {\n \n /// Fetches the environment variable `key` from the current process.\n ///\n-/// The returned result is `Ok(s)` if the environment variable is present and is\n+/// The returned result is [`Ok(s)`] if the environment variable is present and is\n /// valid unicode. If the environment variable is not present, or it is not\n-/// valid unicode, then `Err` will be returned.\n+/// valid unicode, then [`Err`] will be returned.\n+///\n+/// [`Ok(s)`]: ../result/enum.Result.html#variant.Ok\n+/// [`Err`]: ../result/enum.Result.html#variant.Err\n ///\n /// # Examples\n ///\n@@ -199,7 +204,9 @@ fn _var(key: &OsStr) -> Result<String, VarError> {\n }\n \n /// Fetches the environment variable `key` from the current process, returning\n-/// `None` if the variable isn't set.\n+/// [`None`] if the variable isn't set.\n+///\n+/// [`None`]: ../option/enum.Option.html#variant.None\n ///\n /// # Examples\n ///"}, {"sha": "544f4f9ddbed3dc9b14c015bdea4a31a1355f443", "filename": "src/libstd/f32.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Flibstd%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Flibstd%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ff32.rs?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -264,7 +264,7 @@ impl f32 {\n     ///\n     /// assert!(abs_difference <= f32::EPSILON);\n     /// ```\n-    /// [floating-point]: ../reference.html#machine-types\n+    /// [floating-point]: ../reference/types.html#machine-types\n     #[unstable(feature = \"float_extras\", reason = \"signature is undecided\",\n                issue = \"27752\")]\n     #[rustc_deprecated(since = \"1.11.0\","}, {"sha": "dd4bc253bed4b769fecc3abf0ca2c3a836e1db37", "filename": "src/libstd/f64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Flibstd%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Flibstd%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ff64.rs?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -206,7 +206,7 @@ impl f64 {\n     ///\n     /// assert!(abs_difference < 1e-10);\n     /// ```\n-    /// [floating-point]: ../reference.html#machine-types\n+    /// [floating-point]: ../reference/types.html#machine-types\n     #[unstable(feature = \"float_extras\", reason = \"signature is undecided\",\n                issue = \"27752\")]\n     #[rustc_deprecated(since = \"1.11.0\","}, {"sha": "60767ea4786618551f9720c2318db53ef7e3543c", "filename": "src/libstd/io/cursor.rs", "status": "modified", "additions": 49, "deletions": 10, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Flibstd%2Fio%2Fcursor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Flibstd%2Fio%2Fcursor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fcursor.rs?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -200,18 +200,20 @@ impl<T> Cursor<T> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> io::Seek for Cursor<T> where T: AsRef<[u8]> {\n     fn seek(&mut self, style: SeekFrom) -> io::Result<u64> {\n-        let pos = match style {\n-            SeekFrom::Start(n) => { self.pos = n; return Ok(n) }\n-            SeekFrom::End(n) => self.inner.as_ref().len() as i64 + n,\n-            SeekFrom::Current(n) => self.pos as i64 + n,\n+        let (base_pos, offset) = match style {\n+            SeekFrom::Start(n) => { self.pos = n; return Ok(n); }\n+            SeekFrom::End(n) => (self.inner.as_ref().len() as u64, n),\n+            SeekFrom::Current(n) => (self.pos, n),\n         };\n-\n-        if pos < 0 {\n-            Err(Error::new(ErrorKind::InvalidInput,\n-                           \"invalid seek to a negative position\"))\n+        let new_pos = if offset >= 0 {\n+            base_pos.checked_add(offset as u64)\n         } else {\n-            self.pos = pos as u64;\n-            Ok(self.pos)\n+            base_pos.checked_sub((offset.wrapping_neg()) as u64)\n+        };\n+        match new_pos {\n+            Some(n) => {self.pos = n; Ok(self.pos)}\n+            None => Err(Error::new(ErrorKind::InvalidInput,\n+                           \"invalid seek to a negative or overflowing position\"))\n         }\n     }\n }\n@@ -526,6 +528,43 @@ mod tests {\n         assert_eq!(r.write(&[3]).unwrap(), 0);\n     }\n \n+    #[test]\n+    fn seek_past_i64() {\n+        let buf = [0xff];\n+        let mut r = Cursor::new(&buf[..]);\n+        assert_eq!(r.seek(SeekFrom::Start(6)).unwrap(), 6);\n+        assert_eq!(r.seek(SeekFrom::Current(0x7ffffffffffffff0)).unwrap(), 0x7ffffffffffffff6);\n+        assert_eq!(r.seek(SeekFrom::Current(0x10)).unwrap(), 0x8000000000000006);\n+        assert_eq!(r.seek(SeekFrom::Current(0)).unwrap(), 0x8000000000000006);\n+        assert!(r.seek(SeekFrom::Current(0x7ffffffffffffffd)).is_err());\n+        assert_eq!(r.seek(SeekFrom::Current(-0x8000000000000000)).unwrap(), 6);\n+\n+        let mut r = Cursor::new(vec![10]);\n+        assert_eq!(r.seek(SeekFrom::Start(6)).unwrap(), 6);\n+        assert_eq!(r.seek(SeekFrom::Current(0x7ffffffffffffff0)).unwrap(), 0x7ffffffffffffff6);\n+        assert_eq!(r.seek(SeekFrom::Current(0x10)).unwrap(), 0x8000000000000006);\n+        assert_eq!(r.seek(SeekFrom::Current(0)).unwrap(), 0x8000000000000006);\n+        assert!(r.seek(SeekFrom::Current(0x7ffffffffffffffd)).is_err());\n+        assert_eq!(r.seek(SeekFrom::Current(-0x8000000000000000)).unwrap(), 6);\n+\n+        let mut buf = [0];\n+        let mut r = Cursor::new(&mut buf[..]);\n+        assert_eq!(r.seek(SeekFrom::Start(6)).unwrap(), 6);\n+        assert_eq!(r.seek(SeekFrom::Current(0x7ffffffffffffff0)).unwrap(), 0x7ffffffffffffff6);\n+        assert_eq!(r.seek(SeekFrom::Current(0x10)).unwrap(), 0x8000000000000006);\n+        assert_eq!(r.seek(SeekFrom::Current(0)).unwrap(), 0x8000000000000006);\n+        assert!(r.seek(SeekFrom::Current(0x7ffffffffffffffd)).is_err());\n+        assert_eq!(r.seek(SeekFrom::Current(-0x8000000000000000)).unwrap(), 6);\n+\n+        let mut r = Cursor::new(vec![10].into_boxed_slice());\n+        assert_eq!(r.seek(SeekFrom::Start(6)).unwrap(), 6);\n+        assert_eq!(r.seek(SeekFrom::Current(0x7ffffffffffffff0)).unwrap(), 0x7ffffffffffffff6);\n+        assert_eq!(r.seek(SeekFrom::Current(0x10)).unwrap(), 0x8000000000000006);\n+        assert_eq!(r.seek(SeekFrom::Current(0)).unwrap(), 0x8000000000000006);\n+        assert!(r.seek(SeekFrom::Current(0x7ffffffffffffffd)).is_err());\n+        assert_eq!(r.seek(SeekFrom::Current(-0x8000000000000000)).unwrap(), 6);\n+    }\n+\n     #[test]\n     fn seek_before_0() {\n         let buf = [0xff];"}, {"sha": "070690773b6c4792a05dc525ce790c9d1cdc72ce", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -189,8 +189,8 @@\n //! [`sync`]: sync/index.html\n //! [`thread`]: thread/index.html\n //! [`use std::env`]: env/index.html\n-//! [`use`]: ../book/crates-and-modules.html#Importing%20Modules%20with%20use\n-//! [crate root]: ../book/crates-and-modules.html#Basic%20terminology%3A%20Crates%20and%20Modules\n+//! [`use`]: ../book/crates-and-modules.html#importing-modules-with-use\n+//! [crate root]: ../book/crates-and-modules.html#basic-terminology-crates-and-modules\n //! [crates.io]: https://crates.io\n //! [deref coercions]: ../book/deref-coercions.html\n //! [files]: fs/struct.File.html"}, {"sha": "a1f092621cb44f506c8e8b2e360e1fe5068f3c32", "filename": "src/libstd/macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Flibstd%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Flibstd%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmacros.rs?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -441,7 +441,7 @@ pub mod builtin {\n     /// leads to less duplicated code.\n     ///\n     /// The syntax given to this macro is the same syntax as [the `cfg`\n-    /// attribute](../reference.html#conditional-compilation).\n+    /// attribute](../book/conditional-compilation.html).\n     ///\n     /// # Examples\n     ///"}, {"sha": "11197db98a39680b098af9d929f637f5954a9d7c", "filename": "src/libstd/primitive_docs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Flibstd%2Fprimitive_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Flibstd%2Fprimitive_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprimitive_docs.rs?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -490,7 +490,7 @@ mod prim_str { }\n /// assert_eq!(tuple.2, 'c');\n /// ```\n ///\n-/// For more about tuples, see [the book](../book/primitive-types.html#Tuples).\n+/// For more about tuples, see [the book](../book/primitive-types.html#tuples).\n ///\n /// # Trait implementations\n ///"}, {"sha": "1e7394c0b09e7e88f9b52fb9e2f0f57efe702b9c", "filename": "src/libstd/sync/once.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Flibstd%2Fsync%2Fonce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Flibstd%2Fsync%2Fonce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fonce.rs?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -316,7 +316,7 @@ impl Once {\n                         }\n \n                         // Once we've enqueued ourselves, wait in a loop.\n-                        // Aftewards reload the state and continue with what we\n+                        // Afterwards reload the state and continue with what we\n                         // were doing from before.\n                         while !node.signaled.load(Ordering::SeqCst) {\n                             thread::park();"}, {"sha": "36928696c4059089bfffcbbca9c4e72a1e989c2a", "filename": "src/libstd/sys/unix/os.rs", "status": "modified", "additions": 9, "deletions": 29, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fos.rs?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -483,41 +483,21 @@ pub fn home_dir() -> Option<PathBuf> {\n                   target_os = \"nacl\",\n                   target_os = \"emscripten\")))]\n     unsafe fn fallback() -> Option<OsString> {\n-        #[cfg(not(target_os = \"solaris\"))]\n-        unsafe fn getpwduid_r(me: libc::uid_t, passwd: &mut libc::passwd,\n-                              buf: &mut Vec<c_char>) -> Option<()> {\n-            let mut result = ptr::null_mut();\n-            match libc::getpwuid_r(me, passwd, buf.as_mut_ptr(),\n-                                   buf.capacity(),\n-                                   &mut result) {\n-                0 if !result.is_null() => Some(()),\n-                _ => None\n-            }\n-        }\n-\n-        #[cfg(target_os = \"solaris\")]\n-        unsafe fn getpwduid_r(me: libc::uid_t, passwd: &mut libc::passwd,\n-                              buf: &mut Vec<c_char>) -> Option<()> {\n-            // getpwuid_r semantics is different on Illumos/Solaris:\n-            // http://illumos.org/man/3c/getpwuid_r\n-            let result = libc::getpwuid_r(me, passwd, buf.as_mut_ptr(),\n-                                          buf.capacity());\n-            if result.is_null() { None } else { Some(()) }\n-        }\n-\n         let amt = match libc::sysconf(libc::_SC_GETPW_R_SIZE_MAX) {\n             n if n < 0 => 512 as usize,\n             n => n as usize,\n         };\n         let mut buf = Vec::with_capacity(amt);\n         let mut passwd: libc::passwd = mem::zeroed();\n-\n-        if getpwduid_r(libc::getuid(), &mut passwd, &mut buf).is_some() {\n-            let ptr = passwd.pw_dir as *const _;\n-            let bytes = CStr::from_ptr(ptr).to_bytes().to_vec();\n-            Some(OsStringExt::from_vec(bytes))\n-        } else {\n-            None\n+        let mut result = ptr::null_mut();\n+        match libc::getpwuid_r(libc::getuid(), &mut passwd, buf.as_mut_ptr(),\n+                               buf.capacity(), &mut result) {\n+            0 if !result.is_null() => {\n+                let ptr = passwd.pw_dir as *const _;\n+                let bytes = CStr::from_ptr(ptr).to_bytes().to_vec();\n+                Some(OsStringExt::from_vec(bytes))\n+            },\n+            _ => None,\n         }\n     }\n }"}, {"sha": "66f09a7069c130969b65a3c170c6b9f2ce64b08f", "filename": "src/libstd/thread/local.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Flibstd%2Fthread%2Flocal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Flibstd%2Fthread%2Flocal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Flocal.rs?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -28,8 +28,8 @@ use mem;\n /// # Initialization and Destruction\n ///\n /// Initialization is dynamically performed on the first call to `with()`\n-/// within a thread, and values support destructors which will be run when a\n-/// thread exits.\n+/// within a thread, and values that implement `Drop` get destructed when a\n+/// thread exits. Some caveats apply, which are explained below.\n ///\n /// # Examples\n ///"}, {"sha": "2d59051ec4a537465b80ae6d9448054b4142a696", "filename": "src/libsyntax/diagnostic_list.rs", "status": "modified", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Flibsyntax%2Fdiagnostic_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Flibsyntax%2Fdiagnostic_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic_list.rs?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -201,6 +201,74 @@ where appropriate is ongoing. Try using an unquoted name instead:\n pub fn something() {}\n ```\n \"##,\n+\n+E0583: r##\"\n+A file wasn't found for an out-of-line module.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0583\n+mod file_that_doesnt_exist; // error: file not found for module\n+\n+fn main() {}\n+```\n+\n+Please be sure that a file corresponding to the module exists. If you\n+want to use a module named `file_that_doesnt_exist`, you need to have a file\n+named `file_that_doesnt_exist.rs` or `file_that_doesnt_exist/mod.rs` in the\n+same directory.\n+\"##,\n+\n+E0585: r##\"\n+A documentation comment that doesn't document anything was found.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0585\n+fn main() {\n+    // The following doc comment will fail:\n+    /// This is a useless doc comment!\n+}\n+```\n+\n+Documentation comments need to be followed by items, including functions,\n+types, modules, etc. Examples:\n+\n+```\n+/// I'm documenting the following struct:\n+struct Foo;\n+\n+/// I'm documenting the following function:\n+fn foo() {}\n+```\n+\"##,\n+\n+E0586: r##\"\n+An inclusive range was used with no end.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0586\n+let tmp = vec![0, 1, 2, 3, 4, 4, 3, 3, 2, 1];\n+let x = &tmp[1...]; // error: inclusive range was used with no end\n+```\n+\n+An inclusive range needs an end in order to *include* it. If you just need a\n+start and no end, use a non-inclusive range (with `..`):\n+\n+```\n+let tmp = vec![0, 1, 2, 3, 4, 4, 3, 3, 2, 1];\n+let x = &tmp[1..]; // ok!\n+```\n+\n+Or put an end to your inclusive range:\n+\n+```\n+let tmp = vec![0, 1, 2, 3, 4, 4, 3, 3, 2, 1];\n+let x = &tmp[1...3]; // ok!\n+```\n+\"##,\n+\n }\n \n register_diagnostics! {\n@@ -224,4 +292,5 @@ register_diagnostics! {\n     E0555, // malformed feature attribute, expected #![feature(...)]\n     E0556, // malformed feature, expected just one word\n     E0557, // feature has been removed\n+    E0584, // file for module `..` found at both .. and ..\n }"}, {"sha": "b61ab74687bb79c3f15eacbad1d569e995956783", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 34, "deletions": 10, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -474,6 +474,17 @@ impl MacResult for DummyResult {\n pub type BuiltinDeriveFn =\n     for<'cx> fn(&'cx mut ExtCtxt, Span, &MetaItem, &Annotatable, &mut FnMut(Annotatable));\n \n+/// Represents different kinds of macro invocations that can be resolved.\n+#[derive(Clone, Copy, PartialEq, Eq)]\n+pub enum MacroKind {\n+    /// A bang macro - foo!()\n+    Bang,\n+    /// An attribute macro - #[foo]\n+    Attr,\n+    /// A derive attribute macro - #[derive(Foo)]\n+    Derive,\n+}\n+\n /// An enum representing the different kinds of syntax extensions.\n pub enum SyntaxExtension {\n     /// A syntax extension that is attached to an item and creates new items\n@@ -520,6 +531,25 @@ pub enum SyntaxExtension {\n     BuiltinDerive(BuiltinDeriveFn),\n }\n \n+impl SyntaxExtension {\n+    /// Return which kind of macro calls this syntax extension.\n+    pub fn kind(&self) -> MacroKind {\n+        match *self {\n+            SyntaxExtension::NormalTT(..) |\n+            SyntaxExtension::IdentTT(..) |\n+            SyntaxExtension::ProcMacro(..) =>\n+                MacroKind::Bang,\n+            SyntaxExtension::MultiDecorator(..) |\n+            SyntaxExtension::MultiModifier(..) |\n+            SyntaxExtension::AttrProcMacro(..) =>\n+                MacroKind::Attr,\n+            SyntaxExtension::ProcMacroDerive(..) |\n+            SyntaxExtension::BuiltinDerive(..) =>\n+                MacroKind::Derive,\n+        }\n+    }\n+}\n+\n pub type NamedSyntaxExtension = (Name, SyntaxExtension);\n \n pub trait Resolver {\n@@ -535,10 +565,8 @@ pub trait Resolver {\n     fn resolve_imports(&mut self);\n     // Resolves attribute and derive legacy macros from `#![plugin(..)]`.\n     fn find_legacy_attr_invoc(&mut self, attrs: &mut Vec<Attribute>) -> Option<Attribute>;\n-    fn resolve_macro(&mut self, scope: Mark, path: &ast::Path, force: bool)\n-                     -> Result<Rc<SyntaxExtension>, Determinacy>;\n-    fn resolve_derive_macro(&mut self, scope: Mark, path: &ast::Path, force: bool)\n-                            -> Result<Rc<SyntaxExtension>, Determinacy>;\n+    fn resolve_macro(&mut self, scope: Mark, path: &ast::Path, kind: MacroKind,\n+                     force: bool) -> Result<Rc<SyntaxExtension>, Determinacy>;\n }\n \n #[derive(Copy, Clone, Debug)]\n@@ -561,12 +589,8 @@ impl Resolver for DummyResolver {\n \n     fn resolve_imports(&mut self) {}\n     fn find_legacy_attr_invoc(&mut self, _attrs: &mut Vec<Attribute>) -> Option<Attribute> { None }\n-    fn resolve_macro(&mut self, _scope: Mark, _path: &ast::Path, _force: bool)\n-                     -> Result<Rc<SyntaxExtension>, Determinacy> {\n-        Err(Determinacy::Determined)\n-    }\n-    fn resolve_derive_macro(&mut self, _scope: Mark, _path: &ast::Path, _force: bool)\n-                            -> Result<Rc<SyntaxExtension>, Determinacy> {\n+    fn resolve_macro(&mut self, _scope: Mark, _path: &ast::Path, _kind: MacroKind,\n+                     _force: bool) -> Result<Rc<SyntaxExtension>, Determinacy> {\n         Err(Determinacy::Determined)\n     }\n }"}, {"sha": "38494378f72ada31a9c25fb4d64b2d182a97c1ae", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -282,8 +282,8 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                         let mark = Mark::fresh();\n                         derives.push(mark);\n                         let path = ast::Path::from_ident(span, Ident::with_empty_ctxt(name));\n-                        let item = match self.cx.resolver\n-                                             .resolve_macro(Mark::root(), &path, false) {\n+                        let item = match self.cx.resolver.resolve_macro(\n+                                Mark::root(), &path, MacroKind::Derive, false) {\n                             Ok(ext) => match *ext {\n                                 SyntaxExtension::BuiltinDerive(..) => item_with_markers.clone(),\n                                 _ => item.clone(),\n@@ -369,12 +369,14 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                      -> Result<Option<Rc<SyntaxExtension>>, Determinacy> {\n         let (attr, traits, item) = match invoc.kind {\n             InvocationKind::Bang { ref mac, .. } => {\n-                return self.cx.resolver.resolve_macro(scope, &mac.node.path, force).map(Some);\n+                return self.cx.resolver.resolve_macro(scope, &mac.node.path,\n+                                                      MacroKind::Bang, force).map(Some);\n             }\n             InvocationKind::Attr { attr: None, .. } => return Ok(None),\n             InvocationKind::Derive { name, span, .. } => {\n                 let path = ast::Path::from_ident(span, Ident::with_empty_ctxt(name));\n-                return self.cx.resolver.resolve_derive_macro(scope, &path, force).map(Some);\n+                return self.cx.resolver.resolve_macro(scope, &path,\n+                                                      MacroKind::Derive, force).map(Some)\n             }\n             InvocationKind::Attr { ref mut attr, ref traits, ref mut item } => (attr, traits, item),\n         };\n@@ -385,7 +387,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         };\n \n         let mut determined = true;\n-        match self.cx.resolver.resolve_macro(scope, &path, force) {\n+        match self.cx.resolver.resolve_macro(scope, &path, MacroKind::Attr, force) {\n             Ok(ext) => return Ok(Some(ext)),\n             Err(Determinacy::Undetermined) => determined = false,\n             Err(Determinacy::Determined) if force => return Err(Determinacy::Determined),\n@@ -394,7 +396,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n \n         for &(name, span) in traits {\n             let path = ast::Path::from_ident(span, Ident::with_empty_ctxt(name));\n-            match self.cx.resolver.resolve_macro(scope, &path, force) {\n+            match self.cx.resolver.resolve_macro(scope, &path, MacroKind::Derive, force) {\n                 Ok(ext) => if let SyntaxExtension::ProcMacroDerive(_, ref inert_attrs) = *ext {\n                     if inert_attrs.contains(&attr_name) {\n                         // FIXME(jseyfried) Avoid `mem::replace` here."}, {"sha": "b5b8a6bc0ef64c80f08a32ed04739606146392a4", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 82, "deletions": 40, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -219,7 +219,7 @@ fn is_ident_or_underscore(t: &token::Token) -> bool {\n pub struct ModulePath {\n     pub name: String,\n     pub path_exists: bool,\n-    pub result: Result<ModulePathSuccess, ModulePathError>,\n+    pub result: Result<ModulePathSuccess, Error>,\n }\n \n pub struct ModulePathSuccess {\n@@ -233,6 +233,63 @@ pub struct ModulePathError {\n     pub help_msg: String,\n }\n \n+pub enum Error {\n+    FileNotFoundForModule {\n+        mod_name: String,\n+        default_path: String,\n+        secondary_path: String,\n+        dir_path: String,\n+    },\n+    DuplicatePaths {\n+        mod_name: String,\n+        default_path: String,\n+        secondary_path: String,\n+    },\n+    UselessDocComment,\n+    InclusiveRangeWithNoEnd,\n+}\n+\n+impl Error {\n+    pub fn span_err<'a>(self, sp: Span, handler: &'a errors::Handler) -> DiagnosticBuilder<'a> {\n+        match self {\n+            Error::FileNotFoundForModule { ref mod_name,\n+                                           ref default_path,\n+                                           ref secondary_path,\n+                                           ref dir_path } => {\n+                let mut err = struct_span_err!(handler, sp, E0583,\n+                                               \"file not found for module `{}`\", mod_name);\n+                err.help(&format!(\"name the file either {} or {} inside the directory {:?}\",\n+                                  default_path,\n+                                  secondary_path,\n+                                  dir_path));\n+                err\n+            }\n+            Error::DuplicatePaths { ref mod_name, ref default_path, ref secondary_path } => {\n+                let mut err = struct_span_err!(handler, sp, E0584,\n+                                               \"file for module `{}` found at both {} and {}\",\n+                                               mod_name,\n+                                               default_path,\n+                                               secondary_path);\n+                err.help(\"delete or rename one of them to remove the ambiguity\");\n+                err\n+            }\n+            Error::UselessDocComment => {\n+                let mut err = struct_span_err!(handler, sp, E0585,\n+                                  \"found a documentation comment that doesn't document anything\");\n+                err.help(\"doc comments must come before what they document, maybe a comment was \\\n+                          intended with `//`?\");\n+                err\n+            }\n+            Error::InclusiveRangeWithNoEnd => {\n+                let mut err = struct_span_err!(handler, sp, E0586,\n+                                               \"inclusive range with no end\");\n+                err.help(\"inclusive ranges must be bounded at the end (`...b` or `a...b`)\");\n+                err\n+            }\n+        }\n+    }\n+}\n+\n pub enum LhsExpr {\n     NotYetParsed,\n     AttributesParsed(ThinVec<Attribute>),\n@@ -461,10 +518,7 @@ impl<'a> Parser<'a> {\n             }\n             _ => {\n                 Err(if self.prev_token_kind == PrevTokenKind::DocComment {\n-                    self.span_fatal_help(self.prev_span,\n-                        \"found a documentation comment that doesn't document anything\",\n-                        \"doc comments must come before what they document, maybe a comment was \\\n-                        intended with `//`?\")\n+                        self.span_fatal_err(self.prev_span, Error::UselessDocComment)\n                     } else {\n                         let mut err = self.fatal(&format!(\"expected identifier, found `{}`\",\n                                                           self.this_token_to_string()));\n@@ -955,6 +1009,9 @@ impl<'a> Parser<'a> {\n     pub fn span_fatal(&self, sp: Span, m: &str) -> DiagnosticBuilder<'a> {\n         self.sess.span_diagnostic.struct_span_fatal(sp, m)\n     }\n+    pub fn span_fatal_err(&self, sp: Span, err: Error) -> DiagnosticBuilder<'a> {\n+        err.span_err(sp, self.diagnostic())\n+    }\n     pub fn span_fatal_help(&self, sp: Span, m: &str, help: &str) -> DiagnosticBuilder<'a> {\n         let mut err = self.sess.span_diagnostic.struct_span_fatal(sp, m);\n         err.help(help);\n@@ -1944,10 +2001,7 @@ impl<'a> Parser<'a> {\n                     limits: RangeLimits)\n                     -> PResult<'a, ast::ExprKind> {\n         if end.is_none() && limits == RangeLimits::Closed {\n-            Err(self.span_fatal_help(self.span,\n-                                     \"inclusive range with no end\",\n-                                     \"inclusive ranges must be bounded at the end \\\n-                                      (`...b` or `a...b`)\"))\n+            Err(self.span_fatal_err(self.span, Error::InclusiveRangeWithNoEnd))\n         } else {\n             Ok(ExprKind::Range(start, end, limits))\n         }\n@@ -3862,10 +3916,7 @@ impl<'a> Parser<'a> {\n                     let unused_attrs = |attrs: &[_], s: &mut Self| {\n                         if attrs.len() > 0 {\n                             if s.prev_token_kind == PrevTokenKind::DocComment {\n-                                s.span_err_help(s.prev_span,\n-                                    \"found a documentation comment that doesn't document anything\",\n-                                    \"doc comments must come before what they document, maybe a \\\n-                                    comment was intended with `//`?\");\n+                                s.span_fatal_err(s.prev_span, Error::UselessDocComment).emit();\n                             } else {\n                                 s.span_err(s.span, \"expected statement after outer attribute\");\n                             }\n@@ -4998,10 +5049,8 @@ impl<'a> Parser<'a> {\n                 self.bump();\n             }\n             token::CloseDelim(token::Brace) => {}\n-            token::DocComment(_) => return Err(self.span_fatal_help(self.span,\n-                        \"found a documentation comment that doesn't document anything\",\n-                        \"doc comments must come before what they document, maybe a comment was \\\n-                        intended with `//`?\")),\n+            token::DocComment(_) => return Err(self.span_fatal_err(self.span,\n+                                                                   Error::UselessDocComment)),\n             _ => return Err(self.span_fatal_help(self.span,\n                     &format!(\"expected `,`, or `}}`, found `{}`\", self.this_token_to_string()),\n                     \"struct fields should be separated by commas\")),\n@@ -5162,8 +5211,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Returns either a path to a module, or .\n-    pub fn default_submod_path(id: ast::Ident, dir_path: &Path, codemap: &CodeMap) -> ModulePath\n-    {\n+    pub fn default_submod_path(id: ast::Ident, dir_path: &Path, codemap: &CodeMap) -> ModulePath {\n         let mod_name = id.to_string();\n         let default_path_str = format!(\"{}.rs\", mod_name);\n         let secondary_path_str = format!(\"{}/mod.rs\", mod_name);\n@@ -5183,19 +5231,16 @@ impl<'a> Parser<'a> {\n                 directory_ownership: DirectoryOwnership::Owned,\n                 warn: false,\n             }),\n-            (false, false) => Err(ModulePathError {\n-                err_msg: format!(\"file not found for module `{}`\", mod_name),\n-                help_msg: format!(\"name the file either {} or {} inside the directory {:?}\",\n-                                  default_path_str,\n-                                  secondary_path_str,\n-                                  dir_path.display()),\n+            (false, false) => Err(Error::FileNotFoundForModule {\n+                mod_name: mod_name.clone(),\n+                default_path: default_path_str,\n+                secondary_path: secondary_path_str,\n+                dir_path: format!(\"{}\", dir_path.display()),\n             }),\n-            (true, true) => Err(ModulePathError {\n-                err_msg: format!(\"file for module `{}` found at both {} and {}\",\n-                                 mod_name,\n-                                 default_path_str,\n-                                 secondary_path_str),\n-                help_msg: \"delete or rename one of them to remove the ambiguity\".to_owned(),\n+            (true, true) => Err(Error::DuplicatePaths {\n+                mod_name: mod_name.clone(),\n+                default_path: default_path_str,\n+                secondary_path: secondary_path_str,\n             }),\n         };\n \n@@ -5232,7 +5277,7 @@ impl<'a> Parser<'a> {\n                                   paths.name);\n                 err.span_note(id_sp, &msg);\n             }\n-            return Err(err);\n+            Err(err)\n         } else if let DirectoryOwnership::UnownedViaMod(warn) = self.directory.ownership {\n             if warn {\n                 if let Ok(result) = paths.result {\n@@ -5254,15 +5299,12 @@ impl<'a> Parser<'a> {\n                               &format!(\"... or maybe `use` the module `{}` instead \\\n                                         of possibly redeclaring it\",\n                                        paths.name));\n-                return Err(err);\n+                Err(err)\n             } else {\n-                return Err(err);\n-            };\n-        }\n-\n-        match paths.result {\n-            Ok(succ) => Ok(succ),\n-            Err(err) => Err(self.span_fatal_help(id_sp, &err.err_msg, &err.help_msg)),\n+                Err(err)\n+            }\n+        } else {\n+            paths.result.map_err(|err| self.span_fatal_err(id_sp, err))\n         }\n     }\n "}, {"sha": "ab36e9a2c2b20f0ee888b56b9e929d9637ca126a", "filename": "src/rustllvm/llvm-auto-clean-trigger", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Frustllvm%2Fllvm-auto-clean-trigger", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Frustllvm%2Fllvm-auto-clean-trigger", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2Fllvm-auto-clean-trigger?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -1,4 +1,4 @@\n # If this file is modified, then llvm will be forcibly cleaned and then rebuilt.\n # The actual contents of this file do not matter, but to trigger a change on the\n # build bots then the contents should be changed so git updates the mtime.\n-2016-12-19\n+2017-02-15"}, {"sha": "726af9864b48215022022f436320d276c500a516", "filename": "src/test/compile-fail-fulldeps/gated-quote.rs", "status": "modified", "additions": 29, "deletions": 16, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Ftest%2Fcompile-fail-fulldeps%2Fgated-quote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Ftest%2Fcompile-fail-fulldeps%2Fgated-quote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fgated-quote.rs?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -25,32 +25,45 @@ extern crate syntax;\n \n use syntax::ast;\n use syntax::parse;\n-use syntax_pos::Span;\n \n struct ParseSess;\n \n impl ParseSess {\n     fn cfg(&self) -> ast::CrateConfig { loop { } }\n     fn parse_sess<'a>(&'a self) -> &'a parse::ParseSess { loop { } }\n-    fn call_site(&self) -> Span { loop { } }\n+    fn call_site(&self) -> () { loop { } }\n     fn ident_of(&self, st: &str) -> ast::Ident { loop { } }\n     fn name_of(&self, st: &str) -> ast::Name { loop { } }\n }\n \n pub fn main() {\n     let ecx = &ParseSess;\n-    let x = quote_tokens!(ecx, 3);    //~ ERROR macro undefined: `quote_tokens`\n-    let x = quote_expr!(ecx, 3);      //~ ERROR macro undefined: `quote_expr`\n-    let x = quote_ty!(ecx, 3);        //~ ERROR macro undefined: `quote_ty`\n-    let x = quote_method!(ecx, 3);    //~ ERROR macro undefined: `quote_method`\n-    let x = quote_item!(ecx, 3);      //~ ERROR macro undefined: `quote_item`\n-    let x = quote_pat!(ecx, 3);       //~ ERROR macro undefined: `quote_pat`\n-    let x = quote_arm!(ecx, 3);       //~ ERROR macro undefined: `quote_arm`\n-    let x = quote_stmt!(ecx, 3);      //~ ERROR macro undefined: `quote_stmt`\n-    let x = quote_matcher!(ecx, 3);   //~ ERROR macro undefined: `quote_matcher`\n-    let x = quote_attr!(ecx, 3);      //~ ERROR macro undefined: `quote_attr`\n-    let x = quote_arg!(ecx, 3);       //~ ERROR macro undefined: `quote_arg`\n-    let x = quote_block!(ecx, 3);     //~ ERROR macro undefined: `quote_block`\n-    let x = quote_meta_item!(ecx, 3); //~ ERROR macro undefined: `quote_meta_item`\n-    let x = quote_path!(ecx, 3);      //~ ERROR macro undefined: `quote_path`\n+    let x = quote_tokens!(ecx, 3);\n+    //~^ ERROR cannot find macro `quote_tokens!` in this scope\n+    let x = quote_expr!(ecx, 3);\n+    //~^ ERROR cannot find macro `quote_expr!` in this scope\n+    let x = quote_ty!(ecx, 3);\n+    //~^ ERROR cannot find macro `quote_ty!` in this scope\n+    let x = quote_method!(ecx, 3);\n+    //~^ ERROR cannot find macro `quote_method!` in this scope\n+    let x = quote_item!(ecx, 3);\n+    //~^ ERROR cannot find macro `quote_item!` in this scope\n+    let x = quote_pat!(ecx, 3);\n+    //~^ ERROR cannot find macro `quote_pat!` in this scope\n+    let x = quote_arm!(ecx, 3);\n+    //~^ ERROR cannot find macro `quote_arm!` in this scope\n+    let x = quote_stmt!(ecx, 3);\n+    //~^ ERROR cannot find macro `quote_stmt!` in this scope\n+    let x = quote_matcher!(ecx, 3);\n+    //~^ ERROR cannot find macro `quote_matcher!` in this scope\n+    let x = quote_attr!(ecx, 3);\n+    //~^ ERROR cannot find macro `quote_attr!` in this scope\n+    let x = quote_arg!(ecx, 3);\n+    //~^ ERROR cannot find macro `quote_arg!` in this scope\n+    let x = quote_block!(ecx, 3);\n+    //~^ ERROR cannot find macro `quote_block!` in this scope\n+    let x = quote_meta_item!(ecx, 3);\n+    //~^ ERROR cannot find macro `quote_meta_item!` in this scope\n+    let x = quote_path!(ecx, 3);\n+    //~^ ERROR cannot find macro `quote_path!` in this scope\n }"}, {"sha": "886b6247c0a3d97df9961f2589bfbdbffbe6b664", "filename": "src/test/compile-fail-fulldeps/macro-crate-unexported-macro.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Ftest%2Fcompile-fail-fulldeps%2Fmacro-crate-unexported-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Ftest%2Fcompile-fail-fulldeps%2Fmacro-crate-unexported-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fmacro-crate-unexported-macro.rs?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -14,5 +14,6 @@\n extern crate macro_crate_test;\n \n fn main() {\n-    assert_eq!(3, unexported_macro!()); //~ ERROR macro undefined: `unexported_macro`\n+    unexported_macro!();\n+    //~^ ERROR cannot find macro `unexported_macro!` in this scope\n }"}, {"sha": "719fbdb15ef2a7f852a2f9056d7661ea12ade038", "filename": "src/test/compile-fail-fulldeps/proc-macro/auxiliary/derive-clona.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fauxiliary%2Fderive-clona.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fauxiliary%2Fderive-clona.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fauxiliary%2Fderive-clona.rs?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// force-host\n+// no-prefer-dynamic\n+\n+#![crate_type = \"proc-macro\"]\n+\n+extern crate proc_macro;\n+\n+use proc_macro::TokenStream;\n+\n+#[proc_macro_derive(Clona)]\n+pub fn derive_clonea(input: TokenStream) -> TokenStream {\n+    \"\".parse().unwrap()\n+}"}, {"sha": "64dcf72ba2029b5165dbf06c32f669c2783ba024", "filename": "src/test/compile-fail-fulldeps/proc-macro/auxiliary/derive-foo.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fauxiliary%2Fderive-foo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fauxiliary%2Fderive-foo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fauxiliary%2Fderive-foo.rs?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// force-host\n+// no-prefer-dynamic\n+\n+#![crate_type = \"proc-macro\"]\n+\n+extern crate proc_macro;\n+\n+use proc_macro::TokenStream;\n+\n+#[proc_macro_derive(FooWithLongName)]\n+pub fn derive_foo(input: TokenStream) -> TokenStream {\n+    \"\".parse().unwrap()\n+}"}, {"sha": "c9a36920a19e403a27824e3e5eeef6a1000f1e26", "filename": "src/test/compile-fail-fulldeps/proc-macro/resolve-error.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fresolve-error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fresolve-error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fresolve-error.rs?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -0,0 +1,44 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:derive-foo.rs\n+// aux-build:derive-clona.rs\n+// aux-build:attr_proc_macro.rs\n+\n+#![feature(proc_macro)]\n+\n+#[macro_use]\n+extern crate derive_foo;\n+#[macro_use]\n+extern crate derive_clona;\n+extern crate attr_proc_macro;\n+\n+use attr_proc_macro::attr_proc_macro;\n+\n+#[derive(FooWithLongNam)]\n+//~^ ERROR cannot find derive macro `FooWithLongNam` in this scope\n+//~^^ HELP did you mean `FooWithLongName`?\n+struct Foo;\n+\n+#[attr_proc_macra]\n+//~^ ERROR cannot find attribute macro `attr_proc_macra` in this scope\n+struct Bar;\n+\n+#[derive(Dlone)]\n+//~^ ERROR cannot find derive macro `Dlone` in this scope\n+//~^^ HELP did you mean `Clone`?\n+struct A;\n+\n+#[derive(Dlona)]\n+//~^ ERROR cannot find derive macro `Dlona` in this scope\n+//~^^ HELP did you mean `Clona`?\n+struct B;\n+\n+fn main() {}"}, {"sha": "3a5255d0f5fe318409b7ed41d93c2f231c942991", "filename": "src/test/compile-fail/E0583.rs", "status": "renamed", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Ftest%2Fcompile-fail%2FE0583.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Ftest%2Fcompile-fail%2FE0583.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0583.rs?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,10 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+mod module_that_doesnt_exist; //~ ERROR E0583\n+\n fn main() {\n-    &panic!()\n-    //~^ ERROR mismatched types\n-    //~| expected type `()`\n-    //~| found type `&_`\n-    //~| expected (), found reference\n }", "previous_filename": "src/test/compile-fail/issue-5500.rs"}, {"sha": "1acaf8c0b78b6075862d0294fd34c1bb3b629cfe", "filename": "src/test/compile-fail/E0585.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Ftest%2Fcompile-fail%2FE0585.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Ftest%2Fcompile-fail%2FE0585.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0585.rs?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -0,0 +1,14 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    /// Hello! I'm useless...\n+    //~^ ERROR E0585\n+}"}, {"sha": "0b063569abc1783b07a91a62a1214c2e2b7fc5a6", "filename": "src/test/compile-fail/E0586.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Ftest%2Fcompile-fail%2FE0586.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Ftest%2Fcompile-fail%2FE0586.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0586.rs?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -0,0 +1,14 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    let tmp = vec![0, 1, 2, 3, 4, 4, 3, 3, 2, 1];\n+    let x = &tmp[1...]; //~ ERROR E0586\n+}"}, {"sha": "04fdee5e3edf616bff0fceebe063aa3668df6924", "filename": "src/test/compile-fail/deriving-primitive.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Ftest%2Fcompile-fail%2Fderiving-primitive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Ftest%2Fcompile-fail%2Fderiving-primitive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderiving-primitive.rs?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[derive(FromPrimitive)] //~ERROR cannot find derive macro `FromPrimitive` in this scope\n+#[derive(FromPrimitive)] //~ ERROR cannot find derive macro `FromPrimitive` in this scope\n enum Foo {}\n \n fn main() {}"}, {"sha": "823a7426079aaedd454e5ff60141dca77746db60", "filename": "src/test/compile-fail/empty-macro-use.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Ftest%2Fcompile-fail%2Fempty-macro-use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Ftest%2Fcompile-fail%2Fempty-macro-use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fempty-macro-use.rs?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -14,5 +14,6 @@\n extern crate two_macros;\n \n pub fn main() {\n-    macro_two!();  //~ ERROR macro undefined\n+    macro_two!();\n+    //~^ ERROR cannot find macro\n }"}, {"sha": "a5bf79606248753e8f92877c667c08c203995bdf", "filename": "src/test/compile-fail/ext-nonexistent.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Ftest%2Fcompile-fail%2Fext-nonexistent.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Ftest%2Fcompile-fail%2Fext-nonexistent.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fext-nonexistent.rs?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -8,5 +8,5 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern:macro undefined\n+// error-pattern:cannot find macro\n fn main() { iamnotanextensionthatexists!(\"\"); }"}, {"sha": "bbdf248780f3397c473f9e59d267e7e3590ba8ce", "filename": "src/test/compile-fail/feature-gate-rustc-diagnostic-macros.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Ftest%2Fcompile-fail%2Ffeature-gate-rustc-diagnostic-macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Ftest%2Fcompile-fail%2Ffeature-gate-rustc-diagnostic-macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffeature-gate-rustc-diagnostic-macros.rs?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -12,12 +12,12 @@\n // gate\n \n __register_diagnostic!(E0001);\n-//~^ ERROR macro undefined: `__register_diagnostic`\n+//~^ ERROR cannot find macro `__register_diagnostic!` in this scope\n \n fn main() {\n     __diagnostic_used!(E0001);\n-    //~^ ERROR macro undefined: `__diagnostic_used`\n+    //~^ ERROR cannot find macro `__diagnostic_used!` in this scope\n }\n \n __build_diagnostic_array!(DIAGNOSTICS);\n-//~^ ERROR macro undefined: `__build_diagnostic_array`\n+//~^ ERROR cannot find macro `__build_diagnostic_array!` in this scope"}, {"sha": "f577aad04e620bf0c7e02bedb9ebdc60167a529c", "filename": "src/test/compile-fail/issue-11692-1.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Ftest%2Fcompile-fail%2Fissue-11692-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Ftest%2Fcompile-fail%2Fissue-11692-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-11692-1.rs?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -0,0 +1,14 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    print!(test!());\n+    //~^ ERROR: format argument must be a string literal\n+}"}, {"sha": "acac2d151fe9ad5ef8008d3caf10f1a5de111bf7", "filename": "src/test/compile-fail/issue-11692-2.rs", "status": "renamed", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Ftest%2Fcompile-fail%2Fissue-11692-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Ftest%2Fcompile-fail%2Fissue-11692-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-11692-2.rs?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -9,10 +9,6 @@\n // except according to those terms.\n \n fn main() {\n-    print!(test!());\n-    //~^ ERROR: macro undefined: `test`\n-    //~^^ ERROR: format argument must be a string literal\n-\n     concat!(test!());\n-    //~^ ERROR: macro undefined: `test`\n+    //~^ ERROR cannot find macro `test!` in this scope\n }", "previous_filename": "src/test/compile-fail/issue-11692.rs"}, {"sha": "9724d17bef1eaf446e77c95e0a0d7b59975fe0e1", "filename": "src/test/compile-fail/issue-17728.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Ftest%2Fcompile-fail%2Fissue-17728.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Ftest%2Fcompile-fail%2Fissue-17728.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17728.rs?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -108,9 +108,6 @@ impl Debug for Player {\n \n fn str_to_direction(to_parse: &str) -> RoomDirection {\n     match to_parse { //~ ERROR match arms have incompatible types\n-    //~^ expected enum `RoomDirection`, found enum `std::option::Option`\n-    //~| expected type `RoomDirection`\n-    //~| found type `std::option::Option<_>`\n         \"w\" | \"west\" => RoomDirection::West,\n         \"e\" | \"east\" => RoomDirection::East,\n         \"n\" | \"north\" => RoomDirection::North,\n@@ -119,7 +116,7 @@ fn str_to_direction(to_parse: &str) -> RoomDirection {\n         \"out\" => RoomDirection::Out,\n         \"up\" => RoomDirection::Up,\n         \"down\" => RoomDirection::Down,\n-        _ => None //~ NOTE match arm with an incompatible type\n+        _ => None\n     }\n }\n "}, {"sha": "a3820d20aac5b0813d55d7769ac30ecd044fcb91", "filename": "src/test/compile-fail/issue-19734.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Ftest%2Fcompile-fail%2Fissue-19734.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Ftest%2Fcompile-fail%2Fissue-19734.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-19734.rs?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -10,6 +10,9 @@\n \n fn main() {}\n \n+struct Type;\n+\n impl Type {\n-    undef!(); //~ ERROR macro undefined: `undef`\n+    undef!();\n+    //~^ ERROR cannot find macro `undef!` in this scope\n }"}, {"sha": "a56a5e8548944d01f8f7850cf4d9ccd00f53e079", "filename": "src/test/compile-fail/issue-39559.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Ftest%2Fcompile-fail%2Fissue-39559.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Ftest%2Fcompile-fail%2Fissue-39559.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-39559.rs?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+trait Dim {\n+    fn dim() -> usize;\n+}\n+\n+enum Dim3 {}\n+\n+impl Dim for Dim3 {\n+    fn dim() -> usize {\n+        3\n+    }\n+}\n+\n+pub struct Vector<T, D: Dim> {\n+    entries: [T; D::dim()]\n+    //~^ ERROR cannot use an outer type parameter in this context\n+    //~| ERROR constant evaluation error\n+}\n+\n+fn main() {\n+    let array: [usize; Dim3::dim()] = [0; Dim3::dim()];\n+}"}, {"sha": "78f95e365c44b7ef8510c649a35b1fe0ebf0d038", "filename": "src/test/compile-fail/macro-error.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Ftest%2Fcompile-fail%2Fmacro-error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Ftest%2Fcompile-fail%2Fmacro-error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmacro-error.rs?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -16,5 +16,4 @@ fn main() {\n     foo!(0); // Check that we report errors at macro definition, not expansion.\n \n     let _: cfg!(foo) = (); //~ ERROR non-type macro in type position\n-    derive!(); //~ ERROR macro undefined: `derive`\n }"}, {"sha": "ada06b0b3f452cdb3c97859e3ba551d05d4d706b", "filename": "src/test/compile-fail/macro-expansion-tests.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Ftest%2Fcompile-fail%2Fmacro-expansion-tests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Ftest%2Fcompile-fail%2Fmacro-expansion-tests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmacro-expansion-tests.rs?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -12,14 +12,16 @@ mod macros_cant_escape_fns {\n     fn f() {\n         macro_rules! m { () => { 3 + 4 } }\n     }\n-    fn g() -> i32 { m!() } //~ ERROR macro undefined\n+    fn g() -> i32 { m!() }\n+    //~^ ERROR cannot find macro\n }\n \n mod macros_cant_escape_mods {\n     mod f {\n         macro_rules! m { () => { 3 + 4 } }\n     }\n-    fn g() -> i32 { m!() } //~ ERROR macro undefined\n+    fn g() -> i32 { m!() }\n+    //~^ ERROR cannot find macro\n }\n \n mod macros_can_escape_flattened_mods_test {"}, {"sha": "4840205fee4c368a0f2f786e587ba0f3a2d995b2", "filename": "src/test/compile-fail/macro-name-typo.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Ftest%2Fcompile-fail%2Fmacro-name-typo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Ftest%2Fcompile-fail%2Fmacro-name-typo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmacro-name-typo.rs?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n fn main() {\n-    printlx!(\"oh noes!\"); //~ ERROR macro undefined\n-    //~^ HELP did you mean `println!`?\n+    printlx!(\"oh noes!\");\n+    //~^ ERROR cannot find macro\n+    //~^^ HELP did you mean `println!`?\n }"}, {"sha": "07467e06eb2df9346f1272b56466899c110c50db", "filename": "src/test/compile-fail/macro-no-implicit-reexport.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Ftest%2Fcompile-fail%2Fmacro-no-implicit-reexport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Ftest%2Fcompile-fail%2Fmacro-no-implicit-reexport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmacro-no-implicit-reexport.rs?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -15,5 +15,6 @@\n extern crate macro_non_reexport_2;\n \n fn main() {\n-    assert_eq!(reexported!(), 3);  //~ ERROR macro undefined\n+    assert_eq!(reexported!(), 3);\n+    //~^ ERROR cannot find macro `reexported!` in this scope\n }"}, {"sha": "54a74b0e134315b99bd1dfb12b49696a23b864bb", "filename": "src/test/compile-fail/macro-reexport-not-locally-visible.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Ftest%2Fcompile-fail%2Fmacro-reexport-not-locally-visible.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Ftest%2Fcompile-fail%2Fmacro-reexport-not-locally-visible.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmacro-reexport-not-locally-visible.rs?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -17,5 +17,6 @@\n extern crate macro_reexport_1;\n \n fn main() {\n-    assert_eq!(reexported!(), 3);  //~ ERROR macro undefined\n+    assert_eq!(reexported!(), 3);\n+    //~^ ERROR cannot find macro\n }"}, {"sha": "143ecb4ce5e0a0ebea0583b7d630ae4519149ada", "filename": "src/test/compile-fail/macro-use-wrong-name.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Ftest%2Fcompile-fail%2Fmacro-use-wrong-name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Ftest%2Fcompile-fail%2Fmacro-use-wrong-name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmacro-use-wrong-name.rs?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -14,5 +14,6 @@\n extern crate two_macros;\n \n pub fn main() {\n-    macro_two!();  //~ ERROR macro undefined\n+    macro_two!();\n+    //~^ ERROR cannot find macro\n }"}, {"sha": "00c8d44f3060240cc6a715329a8d03af3e34ea25", "filename": "src/test/compile-fail/macro_undefined.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Ftest%2Fcompile-fail%2Fmacro_undefined.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Ftest%2Fcompile-fail%2Fmacro_undefined.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmacro_undefined.rs?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -18,8 +18,10 @@ mod m {\n }\n \n fn main() {\n-    k!(); //~ ERROR macro undefined: `k`\n-          //~^ HELP did you mean `kl!`?\n-    kl!(); //~ ERROR macro undefined: `kl`\n-           //~^ HELP have you added the `#[macro_use]` on the module/import?\n+    k!();\n+    //~^ ERROR cannot find macro `k!` in this scope\n+    //~^^ HELP did you mean `kl!`?\n+    kl!();\n+    //~^ ERROR cannot find macro `kl!` in this scope\n+    //~^^ HELP have you added the `#[macro_use]` on the module/import?\n }"}, {"sha": "7046ee12b50e563de83d718f08bf88486667e51a", "filename": "src/test/compile-fail/macros-nonfatal-errors.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Ftest%2Fcompile-fail%2Fmacros-nonfatal-errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Ftest%2Fcompile-fail%2Fmacros-nonfatal-errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmacros-nonfatal-errors.rs?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -14,15 +14,10 @@\n #![feature(asm)]\n #![feature(trace_macros, concat_idents)]\n \n-#[derive(Zero)] //~ ERROR\n-struct CantDeriveThis;\n-\n #[derive(Default)] //~ ERROR\n enum OrDeriveThis {}\n \n fn main() {\n-    doesnt_exist!(); //~ ERROR\n-\n     asm!(invalid); //~ ERROR\n \n     concat_idents!(\"not\", \"idents\"); //~ ERROR"}, {"sha": "bfe49ea00097251e4d0639043750a199f16e2729", "filename": "src/test/compile-fail/missing-macro-use.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Ftest%2Fcompile-fail%2Fmissing-macro-use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Ftest%2Fcompile-fail%2Fmissing-macro-use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmissing-macro-use.rs?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -13,5 +13,6 @@\n extern crate two_macros;\n \n pub fn main() {\n-    macro_two!();  //~ ERROR macro undefined\n+    macro_two!();\n+    //~^ ERROR cannot find macro `macro_two!` in this scope\n }"}, {"sha": "04f98c7ab329faa751bddadfe4598d3ac6974b39", "filename": "src/test/compile-fail/resolve-self-in-impl.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Ftest%2Fcompile-fail%2Fresolve-self-in-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Ftest%2Fcompile-fail%2Fresolve-self-in-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fresolve-self-in-impl.rs?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -18,9 +18,12 @@ impl<T: Tr<Self>> Tr<T> for S {} //~ ERROR `Self` type is used before it's deter\n impl<T = Self> Tr<T> for S {} //~ ERROR `Self` type is used before it's determined\n impl Tr for S where Self: Copy {} //~ ERROR `Self` type is used before it's determined\n impl Tr for S where S<Self>: Copy {} //~ ERROR `Self` type is used before it's determined\n+impl Tr for S where Self::Assoc: Copy {} //~ ERROR `Self` type is used before it's determined\n+                                         //~^ ERROR `Self` type is used before it's determined\n impl Tr for Self {} //~ ERROR `Self` type is used before it's determined\n impl Tr for S<Self> {} //~ ERROR `Self` type is used before it's determined\n impl Self {} //~ ERROR `Self` type is used before it's determined\n impl S<Self> {} //~ ERROR `Self` type is used before it's determined\n+impl Tr<Self::Assoc> for S {} //~ ERROR `Self` type is used before it's determined\n \n fn main() {}"}, {"sha": "20d2e2ca9cfa1264961d65c59cd1760247bb7355", "filename": "src/test/compile-fail/self_type_keyword.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Ftest%2Fcompile-fail%2Fself_type_keyword.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Ftest%2Fcompile-fail%2Fself_type_keyword.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fself_type_keyword.rs?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -10,12 +10,16 @@\n \n // compile-flags: -Z continue-parse-after-error\n \n-struct Self;\n-//~^ ERROR expected identifier, found keyword `Self`\n+mod foo {\n+  struct Self;\n+  //~^ ERROR expected identifier, found keyword `Self`\n+}\n \n struct Bar<'Self>;\n //~^ ERROR lifetimes cannot use keyword names\n \n+struct Foo;\n+\n pub fn main() {\n     match 15 {\n         ref Self => (),\n@@ -25,7 +29,7 @@ pub fn main() {\n         ref mut Self => (),\n         //~^ ERROR expected identifier, found keyword `Self`\n         Self!() => (),\n-        //~^ ERROR macro undefined: `Self`\n+        //~^ ERROR cannot find macro `Self!` in this scope\n         Foo { Self } => (),\n         //~^ ERROR expected identifier, found keyword `Self`\n     }"}, {"sha": "9c1a4dbdffa846c24e266cc86e93398ea6d5fe11", "filename": "src/test/run-pass/const-enum-vec-index.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Ftest%2Frun-pass%2Fconst-enum-vec-index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Ftest%2Frun-pass%2Fconst-enum-vec-index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-enum-vec-index.rs?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -8,7 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#[derive(Copy, Clone)]\n enum E { V1(isize), V0 }\n+\n const C: &'static [E] = &[E::V0, E::V1(0xDEADBEE)];\n static C0: E = C[0];\n static C1: E = C[1];"}, {"sha": "193c66b2a2afd276272ba07587693608f51f3058", "filename": "src/test/run-pass/inference-changes-39485.rs", "status": "renamed", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Ftest%2Frun-pass%2Finference-changes-39485.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Ftest%2Frun-pass%2Finference-changes-39485.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Finference-changes-39485.rs?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -8,12 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+fn g() {\n+    &panic!()\n+}\n+\n fn f() -> isize {\n     (return 1, return 2)\n-//~^ ERROR mismatched types\n-//~| expected type `isize`\n-//~| found type `(_, _)`\n-//~| expected isize, found tuple\n }\n \n fn main() {}", "previous_filename": "src/test/compile-fail/issue-10176.rs"}, {"sha": "f77888c29554db81c6ab7ba84eb6d245d9712403", "filename": "src/test/run-pass/issue-15763.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Ftest%2Frun-pass%2Fissue-15763.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Ftest%2Frun-pass%2Fissue-15763.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-15763.rs?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -8,7 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![allow(unknown_features)]\n+#![allow(unused_features)]\n+#![allow(unreachable_code)]\n #![feature(box_syntax)]\n \n #[derive(PartialEq, Debug)]\n@@ -28,14 +29,14 @@ struct Foo {\n }\n \n fn foo() -> Result<Foo, isize> {\n-    return Ok(Foo {\n+    return Ok::<Foo, isize>(Foo {\n         x: Bar { x: 22 },\n         a: return Err(32)\n     });\n }\n \n fn baz() -> Result<Foo, isize> {\n-    Ok(Foo {\n+    Ok::<Foo, isize>(Foo {\n         x: Bar { x: 22 },\n         a: return Err(32)\n     })"}, {"sha": "dc2b21f3470e8c22e42dbffe22b4a89ded89a724", "filename": "src/test/run-pass/issue-39292.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Ftest%2Frun-pass%2Fissue-39292.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Ftest%2Frun-pass%2Fissue-39292.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-39292.rs?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Regression test for issue #39292. The object vtable was being\n+// incorrectly left with a null pointer.\n+\n+trait Foo<T> {\n+    fn print<'a>(&'a self) where T: 'a { println!(\"foo\"); }\n+}\n+\n+impl<'a> Foo<&'a ()> for () { }\n+\n+trait Bar: for<'a> Foo<&'a ()> { }\n+\n+impl Bar for () {}\n+\n+fn main() {\n+    (&() as &Bar).print(); // Segfault\n+}"}, {"sha": "8e008c639b30eb6cc00d1977f5ce1f2a6fa156be", "filename": "src/test/run-pass/project-defer-unification.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Ftest%2Frun-pass%2Fproject-defer-unification.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Ftest%2Frun-pass%2Fproject-defer-unification.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fproject-defer-unification.rs?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -11,6 +11,8 @@\n // A regression test extracted from image-0.3.11. The point of\n // failure was in `index_colors` below.\n \n+#![allow(unused)]\n+\n use std::ops::{Deref, DerefMut};\n \n #[derive(Copy, Clone)]\n@@ -92,7 +94,7 @@ pub fn index_colors<Pix>(image: &ImageBuffer<Pix, Vec<u8>>)\n                          -> ImageBuffer<Luma<u8>, Vec<u8>>\n where Pix: Pixel<Subpixel=u8> + 'static,\n {\n-    let mut indices: ImageBuffer<_,Vec<_>> = loop { };\n+    let mut indices: ImageBuffer<Luma<u8>, Vec<u8>> = loop { };\n     for (pixel, idx) in image.pixels().zip(indices.pixels_mut()) {\n         // failured occurred here ^^ because we were requiring that we\n         // could project Pixel or Subpixel from `T_indices` (type of"}, {"sha": "30239f4c0946c0234f36ab67551a0dd6195ca11e", "filename": "src/test/ui/lifetime-errors/ex1-return-one-existing-name-if-else.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Ftest%2Fui%2Flifetime-errors%2Fex1-return-one-existing-name-if-else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Ftest%2Fui%2Flifetime-errors%2Fex1-return-one-existing-name-if-else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex1-return-one-existing-name-if-else.rs?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn foo<'a>(x: &'a i32, y: &i32) -> &'a i32 {\n+    if x > y { x } else { y }\n+}\n+\n+fn main() { }"}, {"sha": "85e05422ab3b2f2e58aae9ec34194294dbc425f6", "filename": "src/test/ui/lifetime-errors/ex1-return-one-existing-name-if-else.stderr", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Ftest%2Fui%2Flifetime-errors%2Fex1-return-one-existing-name-if-else.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Ftest%2Fui%2Flifetime-errors%2Fex1-return-one-existing-name-if-else.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex1-return-one-existing-name-if-else.stderr?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -0,0 +1,25 @@\n+error[E0312]: lifetime of reference outlives lifetime of borrowed content...\n+  --> $DIR/ex1-return-one-existing-name-if-else.rs:12:27\n+   |\n+12 |     if x > y { x } else { y }\n+   |                           ^\n+   |\n+note: ...the reference is valid for the lifetime 'a as defined on the body at 11:43...\n+  --> $DIR/ex1-return-one-existing-name-if-else.rs:11:44\n+   |\n+11 |   fn foo<'a>(x: &'a i32, y: &i32) -> &'a i32 {\n+   |  ____________________________________________^ starting here...\n+12 | |     if x > y { x } else { y }\n+13 | | }\n+   | |_^ ...ending here\n+note: ...but the borrowed content is only valid for the anonymous lifetime #1 defined on the body at 11:43\n+  --> $DIR/ex1-return-one-existing-name-if-else.rs:11:44\n+   |\n+11 |   fn foo<'a>(x: &'a i32, y: &i32) -> &'a i32 {\n+   |  ____________________________________________^ starting here...\n+12 | |     if x > y { x } else { y }\n+13 | | }\n+   | |_^ ...ending here\n+\n+error: aborting due to previous error\n+"}, {"sha": "098950e13b3154f8832fd1240afde3319587b08d", "filename": "src/test/ui/lifetime-errors/ex1b-return-no-names-if-else.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Ftest%2Fui%2Flifetime-errors%2Fex1b-return-no-names-if-else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Ftest%2Fui%2Flifetime-errors%2Fex1b-return-no-names-if-else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex1b-return-no-names-if-else.rs?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn foo(x: &i32, y: &i32) -> &i32 {\n+    if x > y { x } else { y }\n+}\n+\n+fn main() { }"}, {"sha": "fccc44caac81a5f7e25b11cdb0ca893266387bd7", "filename": "src/test/ui/lifetime-errors/ex1b-return-no-names-if-else.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Ftest%2Fui%2Flifetime-errors%2Fex1b-return-no-names-if-else.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Ftest%2Fui%2Flifetime-errors%2Fex1b-return-no-names-if-else.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex1b-return-no-names-if-else.stderr?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -0,0 +1,10 @@\n+error[E0106]: missing lifetime specifier\n+  --> $DIR/ex1b-return-no-names-if-else.rs:11:29\n+   |\n+11 | fn foo(x: &i32, y: &i32) -> &i32 {\n+   |                             ^ expected lifetime parameter\n+   |\n+   = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from `x` or `y`\n+\n+error: aborting due to previous error\n+"}, {"sha": "71a1c865e09957e447621d70e0ac45e1717abe1f", "filename": "src/test/ui/lifetime-errors/ex2a-push-one-existing-name.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Ftest%2Fui%2Flifetime-errors%2Fex2a-push-one-existing-name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Ftest%2Fui%2Flifetime-errors%2Fex2a-push-one-existing-name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex2a-push-one-existing-name.rs?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct Ref<'a, T: 'a> {\n+    data: &'a T\n+}\n+\n+fn foo<'a>(x: &mut Vec<Ref<'a, i32>>, y: Ref<i32>) {\n+    x.push(y);\n+}\n+\n+fn main() { }"}, {"sha": "6f42a9f679a6a51225746d8d0f386139afc0f8f4", "filename": "src/test/ui/lifetime-errors/ex2a-push-one-existing-name.stderr", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Ftest%2Fui%2Flifetime-errors%2Fex2a-push-one-existing-name.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Ftest%2Fui%2Flifetime-errors%2Fex2a-push-one-existing-name.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex2a-push-one-existing-name.stderr?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -0,0 +1,27 @@\n+error[E0308]: mismatched types\n+  --> $DIR/ex2a-push-one-existing-name.rs:16:12\n+   |\n+16 |     x.push(y);\n+   |            ^ lifetime mismatch\n+   |\n+   = note: expected type `Ref<'a, i32>`\n+              found type `Ref<'_, i32>`\n+note: the anonymous lifetime #2 defined on the body at 15:51...\n+  --> $DIR/ex2a-push-one-existing-name.rs:15:52\n+   |\n+15 |   fn foo<'a>(x: &mut Vec<Ref<'a, i32>>, y: Ref<i32>) {\n+   |  ____________________________________________________^ starting here...\n+16 | |     x.push(y);\n+17 | | }\n+   | |_^ ...ending here\n+note: ...does not necessarily outlive the lifetime 'a as defined on the body at 15:51\n+  --> $DIR/ex2a-push-one-existing-name.rs:15:52\n+   |\n+15 |   fn foo<'a>(x: &mut Vec<Ref<'a, i32>>, y: Ref<i32>) {\n+   |  ____________________________________________________^ starting here...\n+16 | |     x.push(y);\n+17 | | }\n+   | |_^ ...ending here\n+\n+error: aborting due to previous error\n+"}, {"sha": "09038d8ce9027ce0708f2f314c58bd5e637d61e8", "filename": "src/test/ui/lifetime-errors/ex2b-push-no-existing-names.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Ftest%2Fui%2Flifetime-errors%2Fex2b-push-no-existing-names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Ftest%2Fui%2Flifetime-errors%2Fex2b-push-no-existing-names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex2b-push-no-existing-names.rs?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct Ref<'a, T: 'a> {\n+    data: &'a T\n+}\n+\n+fn foo(x: &mut Vec<Ref<i32>>, y: Ref<i32>) {\n+    x.push(y);\n+}\n+\n+fn main() { }"}, {"sha": "edc1c2362de57c597c75e923f1d8d81cca6dee04", "filename": "src/test/ui/lifetime-errors/ex2b-push-no-existing-names.stderr", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Ftest%2Fui%2Flifetime-errors%2Fex2b-push-no-existing-names.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Ftest%2Fui%2Flifetime-errors%2Fex2b-push-no-existing-names.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex2b-push-no-existing-names.stderr?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -0,0 +1,27 @@\n+error[E0308]: mismatched types\n+  --> $DIR/ex2b-push-no-existing-names.rs:16:12\n+   |\n+16 |     x.push(y);\n+   |            ^ lifetime mismatch\n+   |\n+   = note: expected type `Ref<'_, i32>`\n+              found type `Ref<'_, i32>`\n+note: the anonymous lifetime #3 defined on the body at 15:43...\n+  --> $DIR/ex2b-push-no-existing-names.rs:15:44\n+   |\n+15 |   fn foo(x: &mut Vec<Ref<i32>>, y: Ref<i32>) {\n+   |  ____________________________________________^ starting here...\n+16 | |     x.push(y);\n+17 | | }\n+   | |_^ ...ending here\n+note: ...does not necessarily outlive the anonymous lifetime #2 defined on the body at 15:43\n+  --> $DIR/ex2b-push-no-existing-names.rs:15:44\n+   |\n+15 |   fn foo(x: &mut Vec<Ref<i32>>, y: Ref<i32>) {\n+   |  ____________________________________________^ starting here...\n+16 | |     x.push(y);\n+17 | | }\n+   | |_^ ...ending here\n+\n+error: aborting due to previous error\n+"}, {"sha": "cb083f778deeb7e2e8d0e493988a60342a3efdd5", "filename": "src/test/ui/lifetime-errors/ex2c-push-inference-variable.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Ftest%2Fui%2Flifetime-errors%2Fex2c-push-inference-variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Ftest%2Fui%2Flifetime-errors%2Fex2c-push-inference-variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex2c-push-inference-variable.rs?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct Ref<'a, T: 'a> {\n+    data: &'a T\n+}\n+\n+fn foo<'a, 'b, 'c>(x: &'a mut Vec<Ref<'b, i32>>, y: Ref<'c, i32>) {\n+    let z = Ref { data: y.data };\n+    x.push(z);\n+}\n+\n+fn main() { }"}, {"sha": "755b71d4a1d9e9eabb90fbfaacda6d517096d634", "filename": "src/test/ui/lifetime-errors/ex2c-push-inference-variable.stderr", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Ftest%2Fui%2Flifetime-errors%2Fex2c-push-inference-variable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Ftest%2Fui%2Flifetime-errors%2Fex2c-push-inference-variable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex2c-push-inference-variable.stderr?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -0,0 +1,37 @@\n+error[E0495]: cannot infer an appropriate lifetime for lifetime parameter `'a` due to conflicting requirements\n+  --> $DIR/ex2c-push-inference-variable.rs:16:13\n+   |\n+16 |     let z = Ref { data: y.data };\n+   |             ^^^\n+   |\n+note: first, the lifetime cannot outlive the lifetime 'c as defined on the body at 15:66...\n+  --> $DIR/ex2c-push-inference-variable.rs:15:67\n+   |\n+15 |   fn foo<'a, 'b, 'c>(x: &'a mut Vec<Ref<'b, i32>>, y: Ref<'c, i32>) {\n+   |  ___________________________________________________________________^ starting here...\n+16 | |     let z = Ref { data: y.data };\n+17 | |     x.push(z);\n+18 | | }\n+   | |_^ ...ending here\n+note: ...so that reference does not outlive borrowed content\n+  --> $DIR/ex2c-push-inference-variable.rs:16:25\n+   |\n+16 |     let z = Ref { data: y.data };\n+   |                         ^^^^^^\n+note: but, the lifetime must be valid for the lifetime 'b as defined on the body at 15:66...\n+  --> $DIR/ex2c-push-inference-variable.rs:15:67\n+   |\n+15 |   fn foo<'a, 'b, 'c>(x: &'a mut Vec<Ref<'b, i32>>, y: Ref<'c, i32>) {\n+   |  ___________________________________________________________________^ starting here...\n+16 | |     let z = Ref { data: y.data };\n+17 | |     x.push(z);\n+18 | | }\n+   | |_^ ...ending here\n+note: ...so that expression is assignable (expected Ref<'b, i32>, found Ref<'_, i32>)\n+  --> $DIR/ex2c-push-inference-variable.rs:17:12\n+   |\n+17 |     x.push(z);\n+   |            ^\n+\n+error: aborting due to previous error\n+"}, {"sha": "bcb7583beefcf5f28d45b2c0add7323f2fe56cb0", "filename": "src/test/ui/lifetime-errors/ex2d-push-inference-variable-2.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Ftest%2Fui%2Flifetime-errors%2Fex2d-push-inference-variable-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Ftest%2Fui%2Flifetime-errors%2Fex2d-push-inference-variable-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex2d-push-inference-variable-2.rs?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct Ref<'a, T: 'a> {\n+    data: &'a T\n+}\n+\n+fn foo<'a, 'b, 'c>(x: &'a mut Vec<Ref<'b, i32>>, y: Ref<'c, i32>) {\n+    let a: &mut Vec<Ref<i32>> = x;\n+    let b = Ref { data: y.data };\n+    a.push(b);\n+}\n+\n+fn main() { }"}, {"sha": "daa6ea2d91aa3b567334a89cf84fad9a32e713ab", "filename": "src/test/ui/lifetime-errors/ex2d-push-inference-variable-2.stderr", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Ftest%2Fui%2Flifetime-errors%2Fex2d-push-inference-variable-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Ftest%2Fui%2Flifetime-errors%2Fex2d-push-inference-variable-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex2d-push-inference-variable-2.stderr?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -0,0 +1,39 @@\n+error[E0495]: cannot infer an appropriate lifetime for lifetime parameter `'a` due to conflicting requirements\n+  --> $DIR/ex2d-push-inference-variable-2.rs:17:13\n+   |\n+17 |     let b = Ref { data: y.data };\n+   |             ^^^\n+   |\n+note: first, the lifetime cannot outlive the lifetime 'c as defined on the body at 15:66...\n+  --> $DIR/ex2d-push-inference-variable-2.rs:15:67\n+   |\n+15 |   fn foo<'a, 'b, 'c>(x: &'a mut Vec<Ref<'b, i32>>, y: Ref<'c, i32>) {\n+   |  ___________________________________________________________________^ starting here...\n+16 | |     let a: &mut Vec<Ref<i32>> = x;\n+17 | |     let b = Ref { data: y.data };\n+18 | |     a.push(b);\n+19 | | }\n+   | |_^ ...ending here\n+note: ...so that reference does not outlive borrowed content\n+  --> $DIR/ex2d-push-inference-variable-2.rs:17:25\n+   |\n+17 |     let b = Ref { data: y.data };\n+   |                         ^^^^^^\n+note: but, the lifetime must be valid for the lifetime 'b as defined on the body at 15:66...\n+  --> $DIR/ex2d-push-inference-variable-2.rs:15:67\n+   |\n+15 |   fn foo<'a, 'b, 'c>(x: &'a mut Vec<Ref<'b, i32>>, y: Ref<'c, i32>) {\n+   |  ___________________________________________________________________^ starting here...\n+16 | |     let a: &mut Vec<Ref<i32>> = x;\n+17 | |     let b = Ref { data: y.data };\n+18 | |     a.push(b);\n+19 | | }\n+   | |_^ ...ending here\n+note: ...so that expression is assignable (expected &mut std::vec::Vec<Ref<'_, i32>>, found &mut std::vec::Vec<Ref<'b, i32>>)\n+  --> $DIR/ex2d-push-inference-variable-2.rs:16:33\n+   |\n+16 |     let a: &mut Vec<Ref<i32>> = x;\n+   |                                 ^\n+\n+error: aborting due to previous error\n+"}, {"sha": "2d05adb7ecd370b660bb8b13765cf071ba0e04c5", "filename": "src/test/ui/lifetime-errors/ex2e-push-inference-variable-3.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Ftest%2Fui%2Flifetime-errors%2Fex2e-push-inference-variable-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Ftest%2Fui%2Flifetime-errors%2Fex2e-push-inference-variable-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex2e-push-inference-variable-3.rs?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct Ref<'a, T: 'a> {\n+    data: &'a T\n+}\n+\n+fn foo<'a, 'b, 'c>(x: &'a mut Vec<Ref<'b, i32>>, y: Ref<'c, i32>) {\n+    let a: &mut Vec<Ref<i32>> = x;\n+    let b = Ref { data: y.data };\n+    Vec::push(a, b);\n+}\n+\n+fn main() { }"}, {"sha": "b679532a4d91086ef85d0a22b5a81541e9780e01", "filename": "src/test/ui/lifetime-errors/ex2e-push-inference-variable-3.stderr", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Ftest%2Fui%2Flifetime-errors%2Fex2e-push-inference-variable-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Ftest%2Fui%2Flifetime-errors%2Fex2e-push-inference-variable-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex2e-push-inference-variable-3.stderr?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -0,0 +1,39 @@\n+error[E0495]: cannot infer an appropriate lifetime for lifetime parameter `'a` due to conflicting requirements\n+  --> $DIR/ex2e-push-inference-variable-3.rs:17:13\n+   |\n+17 |     let b = Ref { data: y.data };\n+   |             ^^^\n+   |\n+note: first, the lifetime cannot outlive the lifetime 'c as defined on the body at 15:66...\n+  --> $DIR/ex2e-push-inference-variable-3.rs:15:67\n+   |\n+15 |   fn foo<'a, 'b, 'c>(x: &'a mut Vec<Ref<'b, i32>>, y: Ref<'c, i32>) {\n+   |  ___________________________________________________________________^ starting here...\n+16 | |     let a: &mut Vec<Ref<i32>> = x;\n+17 | |     let b = Ref { data: y.data };\n+18 | |     Vec::push(a, b);\n+19 | | }\n+   | |_^ ...ending here\n+note: ...so that reference does not outlive borrowed content\n+  --> $DIR/ex2e-push-inference-variable-3.rs:17:25\n+   |\n+17 |     let b = Ref { data: y.data };\n+   |                         ^^^^^^\n+note: but, the lifetime must be valid for the lifetime 'b as defined on the body at 15:66...\n+  --> $DIR/ex2e-push-inference-variable-3.rs:15:67\n+   |\n+15 |   fn foo<'a, 'b, 'c>(x: &'a mut Vec<Ref<'b, i32>>, y: Ref<'c, i32>) {\n+   |  ___________________________________________________________________^ starting here...\n+16 | |     let a: &mut Vec<Ref<i32>> = x;\n+17 | |     let b = Ref { data: y.data };\n+18 | |     Vec::push(a, b);\n+19 | | }\n+   | |_^ ...ending here\n+note: ...so that expression is assignable (expected &mut std::vec::Vec<Ref<'_, i32>>, found &mut std::vec::Vec<Ref<'b, i32>>)\n+  --> $DIR/ex2e-push-inference-variable-3.rs:16:33\n+   |\n+16 |     let a: &mut Vec<Ref<i32>> = x;\n+   |                                 ^\n+\n+error: aborting due to previous error\n+"}, {"sha": "c9bdcd408ead755ecd571806d107c6010e7d66d2", "filename": "src/tools/compiletest/src/runtest.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -13,6 +13,7 @@ use common::{CompileFail, ParseFail, Pretty, RunFail, RunPass, RunPassValgrind};\n use common::{Codegen, DebugInfoLldb, DebugInfoGdb, Rustdoc, CodegenUnits};\n use common::{Incremental, RunMake, Ui, MirOpt};\n use errors::{self, ErrorKind, Error};\n+use filetime::FileTime;\n use json;\n use header::TestProps;\n use header;\n@@ -2457,12 +2458,25 @@ actual:\\n\\\n         }\n     }\n \n+    fn check_mir_test_timestamp(&self, test_name: &str, output_file: &Path) {\n+        let t = |file| FileTime::from_last_modification_time(&fs::metadata(file).unwrap());\n+        let source_file = &self.testpaths.file;\n+        let output_time = t(output_file);\n+        let source_time = t(source_file);\n+        if source_time > output_time {\n+            debug!(\"source file time: {:?} output file time: {:?}\", source_time, output_time);\n+            panic!(\"test source file `{}` is newer than potentially stale output file `{}`.\",\n+                   source_file.display(), test_name);\n+        }\n+    }\n+\n     fn compare_mir_test_output(&self, test_name: &str, expected_content: &Vec<&str>) {\n         let mut output_file = PathBuf::new();\n         output_file.push(self.get_mir_dump_dir());\n         output_file.push(test_name);\n         debug!(\"comparing the contests of: {:?}\", output_file);\n         debug!(\"with: {:?}\", expected_content);\n+        self.check_mir_test_timestamp(test_name, &output_file);\n \n         let mut dumped_file = fs::File::open(output_file.clone()).unwrap();\n         let mut dumped_string = String::new();"}, {"sha": "ba5ca44526b86340be3209a2233d7dbd5324a58f", "filename": "src/tools/linkchecker/main.rs", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Ftools%2Flinkchecker%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Ftools%2Flinkchecker%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Flinkchecker%2Fmain.rs?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -65,6 +65,7 @@ enum Redirect {\n struct FileEntry {\n     source: String,\n     ids: HashSet<String>,\n+    names: HashSet<String>,\n }\n \n type Cache = HashMap<PathBuf, FileEntry>;\n@@ -81,6 +82,15 @@ impl FileEntry {\n             });\n         }\n     }\n+\n+    fn parse_names(&mut self, contents: &str) {\n+        if self.names.is_empty() {\n+            with_attrs_in_source(contents, \" name\", |fragment, _| {\n+                let frag = fragment.trim_left_matches(\"#\").to_owned();\n+                self.names.insert(frag);\n+            });\n+        }\n+    }\n }\n \n fn walk(cache: &mut Cache, root: &Path, dir: &Path, errors: &mut bool) {\n@@ -139,6 +149,9 @@ fn check(cache: &mut Cache,\n         cache.get_mut(&pretty_file)\n              .unwrap()\n              .parse_ids(&pretty_file, &contents, errors);\n+        cache.get_mut(&pretty_file)\n+             .unwrap()\n+             .parse_names(&contents);\n     }\n \n     // Search for anything that's the regex 'href[ ]*=[ ]*\".*?\"'\n@@ -209,13 +222,6 @@ fn check(cache: &mut Cache,\n                 Err(LoadError::IsRedirect) => unreachable!(),\n             };\n \n-            // we don't check the book for fragments because they're added via JS\n-            for book in [\"book/\", \"nomicon/\"].iter() {\n-                if !pretty_path.to_str().unwrap().starts_with(book) {\n-                    return;\n-                }\n-            }\n-\n             if let Some(ref fragment) = fragment {\n                 // Fragments like `#1-6` are most likely line numbers to be\n                 // interpreted by javascript, so we're ignoring these\n@@ -226,8 +232,9 @@ fn check(cache: &mut Cache,\n \n                 let entry = &mut cache.get_mut(&pretty_path).unwrap();\n                 entry.parse_ids(&pretty_path, &contents, errors);\n+                entry.parse_names(&contents);\n \n-                if !entry.ids.contains(*fragment) {\n+                if !(entry.ids.contains(*fragment) || entry.names.contains(*fragment)) {\n                     *errors = true;\n                     print!(\"{}:{}: broken link fragment  \",\n                            pretty_file.display(),\n@@ -277,6 +284,7 @@ fn load_file(cache: &mut Cache,\n                 entry.insert(FileEntry {\n                     source: contents.clone(),\n                     ids: HashSet::new(),\n+                    names: HashSet::new(),\n                 });\n             }\n             maybe"}, {"sha": "f7a452d9f7bd7fef1311a739827ddf7ab7f4a5f3", "filename": "src/tools/rustbook/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Ftools%2Frustbook%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/b3ee2490c2cba3f58476e520468afe0b828c0aa6/src%2Ftools%2Frustbook%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustbook%2FCargo.toml?ref=b3ee2490c2cba3f58476e520468afe0b828c0aa6", "patch": "@@ -8,5 +8,5 @@ license = \"MIT/Apache-2.0\"\n clap = \"2.19.3\"\n \n [dependencies.mdbook]\n-version = \"0.0.14\"\n+version = \"0.0.16\"\n default-features = false"}]}