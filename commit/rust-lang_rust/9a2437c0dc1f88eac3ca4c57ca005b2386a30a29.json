{"sha": "9a2437c0dc1f88eac3ca4c57ca005b2386a30a29", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlhMjQzN2MwZGMxZjg4ZWFjM2NhNGM1N2NhMDA1YjIzODZhMzBhMjk=", "commit": {"author": {"name": "kennytm", "email": "kennytm@gmail.com", "date": "2019-02-15T16:56:00Z"}, "committer": {"name": "kennytm", "email": "kennytm@gmail.com", "date": "2019-02-16T06:11:55Z"}, "message": "Rollup merge of #58468 - RalfJung:maybe-uninit-split, r=Centril\n\nsplit MaybeUninit into several features, expand docs a bit\n\nThis splits the `maybe_uninit` feature gate into several:\n\n* `maybe_uninit` for what we will hopefully stabilize soon-ish.\n* `maybe_uninit_ref` for creating references into `MaybeUninit`, for which the rules are not yet clear.\n* `maybe_uninit_slice` for handling slices of `MaybeUninit`, which needs more API design work.\n* `maybe_uninit_array` for creating arrays of `MaybeUninit` using a macro (because we don't have https://github.com/rust-lang/rust/issues/49147 yet).\n\nIs that an okay thing to do? The goal is to help people avoid APIs we do not want to stabilize yet. I used this to make sure rustc itself does not use `get_ref` and `get_mut`.\n\nI also extended the docs to advise against uninitialized integers -- again this is something for which the rules are still being discussed.", "tree": {"sha": "161f1a449cc0ca20c675d4318798f9b5f505c57c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/161f1a449cc0ca20c675d4318798f9b5f505c57c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9a2437c0dc1f88eac3ca4c57ca005b2386a30a29", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEZ1R8CLMp8f2GxWoQ/vbIBR0OATwFAlxnqasACgkQ/vbIBR0O\nATwFpA/+I6NeEdHWtLhr7J4fp5YZAJBm8tCIW/nzrfbD2Wwa22PdBNqX/a1YRjqM\ng8hkTANdwJbIpFLYEn5i0JCADZ1WbYX0es8cghH4XBsvRiRG21xj80HNkQHdcl+x\nD7cY/q0mqwXO8NnXtsQfKTcByfL6XY0PtlcKPv5zt4lquKTe1iCULPshRKewceRs\nxpMgneK+q0AM8melBBwYahADmYvE8TUhKM4tRKSe8nKoAiLx/p3QnA0ElkCIPNRv\nGAmwiejTZFg6jgJdOHcTHyiF562Ehulhv3Z17A9jWjE7NSe6cGpwxf+hkZoD3iRV\nJApuDbIXeCnaKqWGpx7UOznktWGxFQvJSKnNlGQ2N0Q7MnjrLgfOvy+rxCCfVtCO\nfp9Hbdad+Y16NzfeWJONVmkEn0b6iehSIs8tREyku189acnSf/H3bHYy2DWZa/os\neISxHi8DuhyQGpyV1tY9J3jka9jNpVQBKXhaeeWv9gIwFKqWcYPvY5hRuHxPq04b\nQFFnccgA6+Achm/x4qdCAz5+SD+rrAH2+gsZrEy2dCKCzq103W5Lb72N5dUxNYsN\nE9fKuM6VUd19GxxPE1jnyGAew8PBbhhnjCFXnjvRyfUKhipvY0BqxVe0rWCyOg0I\nNErPauPGkJauTFKEh+CgztP1LZF5MXg6GmJVYoFNwqqz+FUJaQE=\n=Tvke\n-----END PGP SIGNATURE-----", "payload": "tree 161f1a449cc0ca20c675d4318798f9b5f505c57c\nparent 762b988a0a7740d6a9b5f99932036a4ae03dd6cb\nparent 95ef9b4fc28ad2f5db078eb1ae233fd5be76806b\nauthor kennytm <kennytm@gmail.com> 1550249760 +0800\ncommitter kennytm <kennytm@gmail.com> 1550297515 +0800\n\nRollup merge of #58468 - RalfJung:maybe-uninit-split, r=Centril\n\nsplit MaybeUninit into several features, expand docs a bit\n\nThis splits the `maybe_uninit` feature gate into several:\n\n* `maybe_uninit` for what we will hopefully stabilize soon-ish.\n* `maybe_uninit_ref` for creating references into `MaybeUninit`, for which the rules are not yet clear.\n* `maybe_uninit_slice` for handling slices of `MaybeUninit`, which needs more API design work.\n* `maybe_uninit_array` for creating arrays of `MaybeUninit` using a macro (because we don't have https://github.com/rust-lang/rust/issues/49147 yet).\n\nIs that an okay thing to do? The goal is to help people avoid APIs we do not want to stabilize yet. I used this to make sure rustc itself does not use `get_ref` and `get_mut`.\n\nI also extended the docs to advise against uninitialized integers -- again this is something for which the rules are still being discussed.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9a2437c0dc1f88eac3ca4c57ca005b2386a30a29", "html_url": "https://github.com/rust-lang/rust/commit/9a2437c0dc1f88eac3ca4c57ca005b2386a30a29", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9a2437c0dc1f88eac3ca4c57ca005b2386a30a29/comments", "author": {"login": "kennytm", "id": 103023, "node_id": "MDQ6VXNlcjEwMzAyMw==", "avatar_url": "https://avatars.githubusercontent.com/u/103023?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kennytm", "html_url": "https://github.com/kennytm", "followers_url": "https://api.github.com/users/kennytm/followers", "following_url": "https://api.github.com/users/kennytm/following{/other_user}", "gists_url": "https://api.github.com/users/kennytm/gists{/gist_id}", "starred_url": "https://api.github.com/users/kennytm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kennytm/subscriptions", "organizations_url": "https://api.github.com/users/kennytm/orgs", "repos_url": "https://api.github.com/users/kennytm/repos", "events_url": "https://api.github.com/users/kennytm/events{/privacy}", "received_events_url": "https://api.github.com/users/kennytm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "kennytm", "id": 103023, "node_id": "MDQ6VXNlcjEwMzAyMw==", "avatar_url": "https://avatars.githubusercontent.com/u/103023?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kennytm", "html_url": "https://github.com/kennytm", "followers_url": "https://api.github.com/users/kennytm/followers", "following_url": "https://api.github.com/users/kennytm/following{/other_user}", "gists_url": "https://api.github.com/users/kennytm/gists{/gist_id}", "starred_url": "https://api.github.com/users/kennytm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kennytm/subscriptions", "organizations_url": "https://api.github.com/users/kennytm/orgs", "repos_url": "https://api.github.com/users/kennytm/repos", "events_url": "https://api.github.com/users/kennytm/events{/privacy}", "received_events_url": "https://api.github.com/users/kennytm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "762b988a0a7740d6a9b5f99932036a4ae03dd6cb", "url": "https://api.github.com/repos/rust-lang/rust/commits/762b988a0a7740d6a9b5f99932036a4ae03dd6cb", "html_url": "https://github.com/rust-lang/rust/commit/762b988a0a7740d6a9b5f99932036a4ae03dd6cb"}, {"sha": "95ef9b4fc28ad2f5db078eb1ae233fd5be76806b", "url": "https://api.github.com/repos/rust-lang/rust/commits/95ef9b4fc28ad2f5db078eb1ae233fd5be76806b", "html_url": "https://github.com/rust-lang/rust/commit/95ef9b4fc28ad2f5db078eb1ae233fd5be76806b"}], "stats": {"total": 88, "additions": 55, "deletions": 33}, "files": [{"sha": "fc1c18789247104ad53c992d9fa3e216d6fe2ca1", "filename": "src/liballoc/collections/btree/node.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9a2437c0dc1f88eac3ca4c57ca005b2386a30a29/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a2437c0dc1f88eac3ca4c57ca005b2386a30a29/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs?ref=9a2437c0dc1f88eac3ca4c57ca005b2386a30a29", "patch": "@@ -453,7 +453,7 @@ impl<BorrowType, K, V, Type> NodeRef<BorrowType, K, V, Type> {\n                     root: self.root,\n                     _marker: PhantomData\n                 },\n-                idx: unsafe { usize::from(*self.as_header().parent_idx.get_ref()) },\n+                idx: unsafe { usize::from(*self.as_header().parent_idx.as_ptr()) },\n                 _marker: PhantomData\n             })\n         } else {\n@@ -1143,7 +1143,7 @@ impl<BorrowType, K, V>\n         NodeRef {\n             height: self.node.height - 1,\n             node: unsafe {\n-                self.node.as_internal().edges.get_unchecked(self.idx).get_ref().as_ptr()\n+                (&*self.node.as_internal().edges.get_unchecked(self.idx).as_ptr()).as_ptr()\n             },\n             root: self.node.root,\n             _marker: PhantomData"}, {"sha": "440ce8ac5e842d47ad5ee631f4ecdfa56bbb6c40", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9a2437c0dc1f88eac3ca4c57ca005b2386a30a29/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a2437c0dc1f88eac3ca4c57ca005b2386a30a29/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=9a2437c0dc1f88eac3ca4c57ca005b2386a30a29", "patch": "@@ -112,7 +112,7 @@\n #![feature(rustc_const_unstable)]\n #![feature(const_vec_new)]\n #![feature(slice_partition_dedup)]\n-#![feature(maybe_uninit)]\n+#![feature(maybe_uninit, maybe_uninit_slice, maybe_uninit_array)]\n #![feature(alloc_layout_extra)]\n #![feature(try_trait)]\n "}, {"sha": "d046236b5353a0ea5357c81f0ff261bd65bde4bf", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9a2437c0dc1f88eac3ca4c57ca005b2386a30a29/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a2437c0dc1f88eac3ca4c57ca005b2386a30a29/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=9a2437c0dc1f88eac3ca4c57ca005b2386a30a29", "patch": "@@ -122,7 +122,7 @@\n #![feature(structural_match)]\n #![feature(abi_unadjusted)]\n #![feature(adx_target_feature)]\n-#![feature(maybe_uninit)]\n+#![feature(maybe_uninit, maybe_uninit_slice, maybe_uninit_array)]\n #![feature(unrestricted_attribute_tokens)]\n \n #[prelude_import]"}, {"sha": "fdbfa56000b8ebbc32c5fafea80c1e78cee8f152", "filename": "src/libcore/macros.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9a2437c0dc1f88eac3ca4c57ca005b2386a30a29/src%2Flibcore%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a2437c0dc1f88eac3ca4c57ca005b2386a30a29/src%2Flibcore%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros.rs?ref=9a2437c0dc1f88eac3ca4c57ca005b2386a30a29", "patch": "@@ -563,11 +563,11 @@ macro_rules! unimplemented {\n \n /// A macro to create an array of [`MaybeUninit`]\n ///\n-/// This macro constructs and uninitialized array of the type `[MaybeUninit<K>; N]`.\n+/// This macro constructs an uninitialized array of the type `[MaybeUninit<K>; N]`.\n ///\n /// [`MaybeUninit`]: mem/union.MaybeUninit.html\n #[macro_export]\n-#[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n+#[unstable(feature = \"maybe_uninit_array\", issue = \"53491\")]\n macro_rules! uninitialized_array {\n     // This `into_initialized` is safe because an array of `MaybeUninit` does not\n     // require initialization."}, {"sha": "e0b0e72ff9b5f0e1aeea46d4aa48946617521baa", "filename": "src/libcore/mem.rs", "status": "modified", "additions": 49, "deletions": 27, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/9a2437c0dc1f88eac3ca4c57ca005b2386a30a29/src%2Flibcore%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a2437c0dc1f88eac3ca4c57ca005b2386a30a29/src%2Flibcore%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem.rs?ref=9a2437c0dc1f88eac3ca4c57ca005b2386a30a29", "patch": "@@ -1045,17 +1045,34 @@ impl<T: ?Sized> DerefMut for ManuallyDrop<T> {\n /// ever gets used to access memory:\n ///\n /// ```rust,no_run\n-/// use std::mem;\n+/// #![feature(maybe_uninit)]\n+/// use std::mem::{self, MaybeUninit};\n ///\n /// let x: &i32 = unsafe { mem::zeroed() }; // undefined behavior!\n+/// // equivalent code with `MaybeUninit`\n+/// let x: &i32 = unsafe { MaybeUninit::zeroed().into_initialized() }; // undefined behavior!\n /// ```\n ///\n /// This is exploited by the compiler for various optimizations, such as eliding\n /// run-time checks and optimizing `enum` layout.\n ///\n-/// Not initializing memory at all (instead of zero--initializing it) causes the same\n+/// Not initializing memory at all (instead of zero-initializing it) causes the same\n /// issue: after all, the initial value of the variable might just happen to be\n-/// one that violates the invariant.\n+/// one that violates the invariant. Moreover, uninitialized memory is special\n+/// in that the compiler knows that it does not have a fixed value. This makes\n+/// it undefined behavior to have uninitialized data in a variable even if that\n+/// variable has otherwise no restrictions about which values are valid:\n+///\n+/// ```rust,no_run\n+/// #![feature(maybe_uninit)]\n+/// use std::mem::{self, MaybeUninit};\n+///\n+/// let x: i32 = unsafe { mem::uninitialized() }; // undefined behavior!\n+/// // equivalent code with `MaybeUninit`\n+/// let x: i32 = unsafe { MaybeUninit::uninitialized().into_initialized() }; // undefined behavior!\n+/// ```\n+/// (Notice that the rules around uninitialized integers are not finalized yet, but\n+/// until they are, it is advisable to avoid them.)\n ///\n /// `MaybeUninit` serves to enable unsafe code to deal with uninitialized data:\n /// it is a signal to the compiler indicating that the data here might *not*\n@@ -1065,7 +1082,8 @@ impl<T: ?Sized> DerefMut for ManuallyDrop<T> {\n /// #![feature(maybe_uninit)]\n /// use std::mem::MaybeUninit;\n ///\n-/// // Create an explicitly uninitialized reference.\n+/// // Create an explicitly uninitialized reference. The compiler knows that data inside\n+/// // a `MaybeUninit` may be invalid, and hence this is not UB:\n /// let mut x = MaybeUninit::<&i32>::uninitialized();\n /// // Set it to a valid value.\n /// x.set(&0);\n@@ -1075,6 +1093,7 @@ impl<T: ?Sized> DerefMut for ManuallyDrop<T> {\n /// ```\n ///\n /// The compiler then knows to not optimize this code.\n+// FIXME before stabilizing, explain how to initialize a struct field-by-field.\n #[allow(missing_debug_implementations)]\n #[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n // NOTE after stabilizing `MaybeUninit` proceed to deprecate `mem::{uninitialized,zeroed}`\n@@ -1134,14 +1153,31 @@ impl<T> MaybeUninit<T> {\n         }\n     }\n \n+    /// Gets a pointer to the contained value. Reading from this pointer or turning it\n+    /// into a reference will be undefined behavior unless the `MaybeUninit` is initialized.\n+    #[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n+    #[inline(always)]\n+    pub fn as_ptr(&self) -> *const T {\n+        unsafe { &*self.value as *const T }\n+    }\n+\n+    /// Gets a mutable pointer to the contained value. Reading from this pointer or turning it\n+    /// into a reference will be undefined behavior unless the `MaybeUninit` is initialized.\n+    #[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n+    #[inline(always)]\n+    pub fn as_mut_ptr(&mut self) -> *mut T {\n+        unsafe { &mut *self.value as *mut T }\n+    }\n+\n     /// Extracts the value from the `MaybeUninit` container. This is a great way\n     /// to ensure that the data will get dropped, because the resulting `T` is\n     /// subject to the usual drop handling.\n     ///\n     /// # Unsafety\n     ///\n     /// It is up to the caller to guarantee that the `MaybeUninit` really is in an initialized\n-    /// state, otherwise this will immediately cause undefined behavior.\n+    /// state. Calling this when the content is not yet fully initialized causes undefined\n+    /// behavior.\n     #[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n     #[inline(always)]\n     pub unsafe fn into_initialized(self) -> T {\n@@ -1162,8 +1198,9 @@ impl<T> MaybeUninit<T> {\n     /// # Unsafety\n     ///\n     /// It is up to the caller to guarantee that the `MaybeUninit` really is in an initialized\n-    /// state, otherwise this will immediately cause undefined behavior.\n-    #[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n+    /// state. Calling this when the content is not yet fully initialized causes undefined\n+    /// behavior.\n+    #[unstable(feature = \"maybe_uninit_ref\", issue = \"53491\")]\n     #[inline(always)]\n     pub unsafe fn get_ref(&self) -> &T {\n         &*self.value\n@@ -1174,41 +1211,26 @@ impl<T> MaybeUninit<T> {\n     /// # Unsafety\n     ///\n     /// It is up to the caller to guarantee that the `MaybeUninit` really is in an initialized\n-    /// state, otherwise this will immediately cause undefined behavior.\n+    /// state. Calling this when the content is not yet fully initialized causes undefined\n+    /// behavior.\n     // FIXME(#53491): We currently rely on the above being incorrect, i.e., we have references\n     // to uninitialized data (e.g., in `libcore/fmt/float.rs`).  We should make\n     // a final decision about the rules before stabilization.\n-    #[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n+    #[unstable(feature = \"maybe_uninit_ref\", issue = \"53491\")]\n     #[inline(always)]\n     pub unsafe fn get_mut(&mut self) -> &mut T {\n         &mut *self.value\n     }\n \n-    /// Gets a pointer to the contained value. Reading from this pointer or turning it\n-    /// into a reference will be undefined behavior unless the `MaybeUninit` is initialized.\n-    #[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n-    #[inline(always)]\n-    pub fn as_ptr(&self) -> *const T {\n-        unsafe { &*self.value as *const T }\n-    }\n-\n-    /// Get sa mutable pointer to the contained value. Reading from this pointer or turning it\n-    /// into a reference will be undefined behavior unless the `MaybeUninit` is initialized.\n-    #[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n-    #[inline(always)]\n-    pub fn as_mut_ptr(&mut self) -> *mut T {\n-        unsafe { &mut *self.value as *mut T }\n-    }\n-\n     /// Gets a pointer to the first element of the array.\n-    #[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n+    #[unstable(feature = \"maybe_uninit_slice\", issue = \"53491\")]\n     #[inline(always)]\n     pub fn first_ptr(this: &[MaybeUninit<T>]) -> *const T {\n         this as *const [MaybeUninit<T>] as *const T\n     }\n \n     /// Gets a mutable pointer to the first element of the array.\n-    #[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n+    #[unstable(feature = \"maybe_uninit_slice\", issue = \"53491\")]\n     #[inline(always)]\n     pub fn first_ptr_mut(this: &mut [MaybeUninit<T>]) -> *mut T {\n         this as *mut [MaybeUninit<T>] as *mut T"}]}