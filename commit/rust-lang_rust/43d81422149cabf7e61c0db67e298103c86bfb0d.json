{"sha": "43d81422149cabf7e61c0db67e298103c86bfb0d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQzZDgxNDIyMTQ5Y2FiZjdlNjFjMGRiNjdlMjk4MTAzYzg2YmZiMGQ=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-07-30T20:38:58Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-07-30T20:38:58Z"}, "message": "Merge #5614\n\n5614: Use split_once polyfill r=matklad a=matklad\n\n\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "8e98a36d67b2aeb58cb571c53a555f40004135be", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8e98a36d67b2aeb58cb571c53a555f40004135be"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/43d81422149cabf7e61c0db67e298103c86bfb0d", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfIy/iCRBK7hj4Ov3rIwAAdHIIAGdEYHSK6oyBwnTHBx//vW4Y\n3heXzES7ML1I4R//5+Bu+EgexlOXa/19BrQEEP85LB/JVpKa2V46FpGx4AmCDANF\nCRRow1MpDLxctgzO437J/fLtr++Wc7zJ/Ef64ro32MjqomsP4xG9fNSBSaAqWtEv\nwQqJdTXgRFhEMPIajMldaXU6lQX46vgfmIvdc+IMCpybaU/V1u1FlcoEKMwWOLIJ\nru9gWbbHxvo1rVKcoQWOJXukenQqapHhWcsy++uPh0hFt2gdfs9xpb/V2k2WZ9WD\nH8ie9P/BoiWtYI9tzvCAXwvd66HpxX1delJcBT58YL1eL99IUBfxkwhRUDfspLI=\n=dp44\n-----END PGP SIGNATURE-----\n", "payload": "tree 8e98a36d67b2aeb58cb571c53a555f40004135be\nparent 08d18e0edda948215a9bb649d022a342d01e77a8\nparent cd9f863b017a6d568b5ef45f1ce200e3148cfd03\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1596141538 +0000\ncommitter GitHub <noreply@github.com> 1596141538 +0000\n\nMerge #5614\n\n5614: Use split_once polyfill r=matklad a=matklad\n\n\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/43d81422149cabf7e61c0db67e298103c86bfb0d", "html_url": "https://github.com/rust-lang/rust/commit/43d81422149cabf7e61c0db67e298103c86bfb0d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/43d81422149cabf7e61c0db67e298103c86bfb0d/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "08d18e0edda948215a9bb649d022a342d01e77a8", "url": "https://api.github.com/repos/rust-lang/rust/commits/08d18e0edda948215a9bb649d022a342d01e77a8", "html_url": "https://github.com/rust-lang/rust/commit/08d18e0edda948215a9bb649d022a342d01e77a8"}, {"sha": "cd9f863b017a6d568b5ef45f1ce200e3148cfd03", "url": "https://api.github.com/repos/rust-lang/rust/commits/cd9f863b017a6d568b5ef45f1ce200e3148cfd03", "html_url": "https://github.com/rust-lang/rust/commit/cd9f863b017a6d568b5ef45f1ce200e3148cfd03"}], "stats": {"total": 686, "additions": 334, "deletions": 352}, "files": [{"sha": "bd50056c689f8fd95dcf2a8a37d7c7bd0a1bd048", "filename": "crates/ra_project_model/src/cfg_flag.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/43d81422149cabf7e61c0db67e298103c86bfb0d/crates%2Fra_project_model%2Fsrc%2Fcfg_flag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43d81422149cabf7e61c0db67e298103c86bfb0d/crates%2Fra_project_model%2Fsrc%2Fcfg_flag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_project_model%2Fsrc%2Fcfg_flag.rs?ref=43d81422149cabf7e61c0db67e298103c86bfb0d", "patch": "@@ -4,7 +4,7 @@\n use std::str::FromStr;\n \n use ra_cfg::CfgOptions;\n-use stdx::split_delim;\n+use stdx::split_once;\n \n #[derive(Clone, Eq, PartialEq, Debug)]\n pub enum CfgFlag {\n@@ -15,7 +15,7 @@ pub enum CfgFlag {\n impl FromStr for CfgFlag {\n     type Err = String;\n     fn from_str(s: &str) -> Result<Self, Self::Err> {\n-        let res = match split_delim(s, '=') {\n+        let res = match split_once(s, '=') {\n             Some((key, value)) => {\n                 if !(value.starts_with('\"') && value.ends_with('\"')) {\n                     return Err(format!(\"Invalid cfg ({:?}), value should be in quotes\", s));"}, {"sha": "f16e35d86bc4e82546f026a12adfcd8ec6eeeafb", "filename": "crates/rust-analyzer/src/bin/args.rs", "status": "modified", "additions": 12, "deletions": 21, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/43d81422149cabf7e61c0db67e298103c86bfb0d/crates%2Frust-analyzer%2Fsrc%2Fbin%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43d81422149cabf7e61c0db67e298103c86bfb0d/crates%2Frust-analyzer%2Fsrc%2Fbin%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fbin%2Fargs.rs?ref=43d81422149cabf7e61c0db67e298103c86bfb0d", "patch": "@@ -8,7 +8,7 @@ use std::{env, fmt::Write, path::PathBuf};\n use anyhow::{bail, Result};\n use pico_args::Arguments;\n use ra_ssr::{SsrPattern, SsrRule};\n-use rust_analyzer::cli::{BenchWhat, Position, Verbosity};\n+use rust_analyzer::cli::{AnalysisStatsCmd, BenchCmd, BenchWhat, Position, Verbosity};\n use vfs::AbsPathBuf;\n \n pub(crate) struct Args {\n@@ -24,23 +24,8 @@ pub(crate) enum Command {\n     Highlight {\n         rainbow: bool,\n     },\n-    Stats {\n-        randomize: bool,\n-        parallel: bool,\n-        memory_usage: bool,\n-        only: Option<String>,\n-        with_deps: bool,\n-        path: PathBuf,\n-        load_output_dirs: bool,\n-        with_proc_macro: bool,\n-    },\n-    Bench {\n-        memory_usage: bool,\n-        path: PathBuf,\n-        what: BenchWhat,\n-        load_output_dirs: bool,\n-        with_proc_macro: bool,\n-    },\n+    AnalysisStats(AnalysisStatsCmd),\n+    Bench(BenchCmd),\n     Diagnostics {\n         path: PathBuf,\n         load_output_dirs: bool,\n@@ -199,7 +184,7 @@ ARGS:\n                     trailing.pop().unwrap().into()\n                 };\n \n-                Command::Stats {\n+                Command::AnalysisStats(AnalysisStatsCmd {\n                     randomize,\n                     parallel,\n                     memory_usage,\n@@ -208,7 +193,7 @@ ARGS:\n                     path,\n                     load_output_dirs,\n                     with_proc_macro,\n-                }\n+                })\n             }\n             \"analysis-bench\" => {\n                 if matches.contains([\"-h\", \"--help\"]) {\n@@ -256,7 +241,13 @@ ARGS:\n                 let memory_usage = matches.contains(\"--memory-usage\");\n                 let load_output_dirs = matches.contains(\"--load-output-dirs\");\n                 let with_proc_macro = matches.contains(\"--with-proc-macro\");\n-                Command::Bench { memory_usage, path, what, load_output_dirs, with_proc_macro }\n+                Command::Bench(BenchCmd {\n+                    memory_usage,\n+                    path,\n+                    what,\n+                    load_output_dirs,\n+                    with_proc_macro,\n+                })\n             }\n             \"diagnostics\" => {\n                 if matches.contains([\"-h\", \"--help\"]) {"}, {"sha": "ff8234495fad4c2de548ac292c512da0125a5f92", "filename": "crates/rust-analyzer/src/bin/main.rs", "status": "modified", "additions": 2, "deletions": 30, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/43d81422149cabf7e61c0db67e298103c86bfb0d/crates%2Frust-analyzer%2Fsrc%2Fbin%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43d81422149cabf7e61c0db67e298103c86bfb0d/crates%2Frust-analyzer%2Fsrc%2Fbin%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fbin%2Fmain.rs?ref=43d81422149cabf7e61c0db67e298103c86bfb0d", "patch": "@@ -33,36 +33,8 @@ fn main() -> Result<()> {\n         args::Command::Parse { no_dump } => cli::parse(no_dump)?,\n         args::Command::Symbols => cli::symbols()?,\n         args::Command::Highlight { rainbow } => cli::highlight(rainbow)?,\n-        args::Command::Stats {\n-            randomize,\n-            parallel,\n-            memory_usage,\n-            only,\n-            with_deps,\n-            path,\n-            load_output_dirs,\n-            with_proc_macro,\n-        } => cli::analysis_stats(\n-            args.verbosity,\n-            memory_usage,\n-            path.as_ref(),\n-            only.as_ref().map(String::as_ref),\n-            with_deps,\n-            randomize,\n-            parallel,\n-            load_output_dirs,\n-            with_proc_macro,\n-        )?,\n-        args::Command::Bench { memory_usage, path, what, load_output_dirs, with_proc_macro } => {\n-            cli::analysis_bench(\n-                args.verbosity,\n-                path.as_ref(),\n-                what,\n-                memory_usage,\n-                load_output_dirs,\n-                with_proc_macro,\n-            )?\n-        }\n+        args::Command::AnalysisStats(cmd) => cmd.run(args.verbosity)?,\n+        args::Command::Bench(cmd) => cmd.run(args.verbosity)?,\n         args::Command::Diagnostics { path, load_output_dirs, with_proc_macro, all } => {\n             cli::diagnostics(path.as_ref(), load_output_dirs, with_proc_macro, all)?\n         }"}, {"sha": "1034d11bd89f4859886ed9fdacd68ab9ca8ceb90", "filename": "crates/rust-analyzer/src/cli.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/43d81422149cabf7e61c0db67e298103c86bfb0d/crates%2Frust-analyzer%2Fsrc%2Fcli.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43d81422149cabf7e61c0db67e298103c86bfb0d/crates%2Frust-analyzer%2Fsrc%2Fcli.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fcli.rs?ref=43d81422149cabf7e61c0db67e298103c86bfb0d", "patch": "@@ -14,8 +14,8 @@ use ra_ide::Analysis;\n use ra_prof::profile;\n use ra_syntax::{AstNode, SourceFile};\n \n-pub use analysis_bench::{analysis_bench, BenchWhat, Position};\n-pub use analysis_stats::analysis_stats;\n+pub use analysis_bench::{BenchCmd, BenchWhat, Position};\n+pub use analysis_stats::AnalysisStatsCmd;\n pub use diagnostics::diagnostics;\n pub use load_cargo::load_cargo;\n pub use ssr::{apply_ssr_rules, search_for_patterns};"}, {"sha": "c54ee5f4de18ac4c39212ef3a20ce286def0ef07", "filename": "crates/rust-analyzer/src/cli/analysis_bench.rs", "status": "modified", "additions": 69, "deletions": 66, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/43d81422149cabf7e61c0db67e298103c86bfb0d/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fanalysis_bench.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43d81422149cabf7e61c0db67e298103c86bfb0d/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fanalysis_bench.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fanalysis_bench.rs?ref=43d81422149cabf7e61c0db67e298103c86bfb0d", "patch": "@@ -1,8 +1,8 @@\n //! Benchmark operations like highlighting or goto definition.\n \n-use std::{env, path::Path, str::FromStr, sync::Arc, time::Instant};\n+use std::{env, path::PathBuf, str::FromStr, sync::Arc, time::Instant};\n \n-use anyhow::{format_err, Result};\n+use anyhow::{bail, format_err, Result};\n use ra_db::{\n     salsa::{Database, Durability},\n     FileId,\n@@ -15,6 +15,14 @@ use crate::{\n     print_memory_usage,\n };\n \n+pub struct BenchCmd {\n+    pub path: PathBuf,\n+    pub what: BenchWhat,\n+    pub memory_usage: bool,\n+    pub load_output_dirs: bool,\n+    pub with_proc_macro: bool,\n+}\n+\n pub enum BenchWhat {\n     Highlight { path: AbsPathBuf },\n     Complete(Position),\n@@ -30,85 +38,80 @@ pub struct Position {\n impl FromStr for Position {\n     type Err = anyhow::Error;\n     fn from_str(s: &str) -> Result<Self> {\n-        let (path_line, column) = rsplit_at_char(s, ':')?;\n-        let (path, line) = rsplit_at_char(path_line, ':')?;\n-        let path = env::current_dir().unwrap().join(path);\n-        let path = AbsPathBuf::assert(path);\n-        Ok(Position { path, line: line.parse()?, column: column.parse()? })\n+        let mut split = s.rsplitn(3, ':');\n+        match (split.next(), split.next(), split.next()) {\n+            (Some(column), Some(line), Some(path)) => {\n+                let path = env::current_dir().unwrap().join(path);\n+                let path = AbsPathBuf::assert(path);\n+                Ok(Position { path, line: line.parse()?, column: column.parse()? })\n+            }\n+            _ => bail!(\"position should be in file:line:column format: {:?}\", s),\n+        }\n     }\n }\n \n-fn rsplit_at_char(s: &str, c: char) -> Result<(&str, &str)> {\n-    let idx = s.rfind(c).ok_or_else(|| format_err!(\"no `{}` in {}\", c, s))?;\n-    Ok((&s[..idx], &s[idx + 1..]))\n-}\n+impl BenchCmd {\n+    pub fn run(self, verbosity: Verbosity) -> Result<()> {\n+        ra_prof::init();\n \n-pub fn analysis_bench(\n-    verbosity: Verbosity,\n-    path: &Path,\n-    what: BenchWhat,\n-    memory_usage: bool,\n-    load_output_dirs: bool,\n-    with_proc_macro: bool,\n-) -> Result<()> {\n-    ra_prof::init();\n-\n-    let start = Instant::now();\n-    eprint!(\"loading: \");\n-    let (mut host, vfs) = load_cargo(path, load_output_dirs, with_proc_macro)?;\n-    eprintln!(\"{:?}\\n\", start.elapsed());\n-\n-    let file_id = {\n-        let path = match &what {\n-            BenchWhat::Highlight { path } => path,\n-            BenchWhat::Complete(pos) | BenchWhat::GotoDef(pos) => &pos.path,\n+        let start = Instant::now();\n+        eprint!(\"loading: \");\n+        let (mut host, vfs) = load_cargo(&self.path, self.load_output_dirs, self.with_proc_macro)?;\n+        eprintln!(\"{:?}\\n\", start.elapsed());\n+\n+        let file_id = {\n+            let path = match &self.what {\n+                BenchWhat::Highlight { path } => path,\n+                BenchWhat::Complete(pos) | BenchWhat::GotoDef(pos) => &pos.path,\n+            };\n+            let path = path.clone().into();\n+            vfs.file_id(&path).ok_or_else(|| format_err!(\"Can't find {}\", path))?\n         };\n-        let path = path.clone().into();\n-        vfs.file_id(&path).ok_or_else(|| format_err!(\"Can't find {}\", path))?\n-    };\n-\n-    match &what {\n-        BenchWhat::Highlight { .. } => {\n-            let res = do_work(&mut host, file_id, |analysis| {\n-                analysis.diagnostics(file_id, true).unwrap();\n-                analysis.highlight_as_html(file_id, false).unwrap()\n-            });\n-            if verbosity.is_verbose() {\n-                println!(\"\\n{}\", res);\n-            }\n-        }\n-        BenchWhat::Complete(pos) | BenchWhat::GotoDef(pos) => {\n-            let is_completion = matches!(what, BenchWhat::Complete(..));\n \n-            let offset = host\n-                .analysis()\n-                .file_line_index(file_id)?\n-                .offset(LineCol { line: pos.line - 1, col_utf16: pos.column });\n-            let file_position = FilePosition { file_id, offset };\n-\n-            if is_completion {\n-                let options = CompletionConfig::default();\n+        match &self.what {\n+            BenchWhat::Highlight { .. } => {\n                 let res = do_work(&mut host, file_id, |analysis| {\n-                    analysis.completions(&options, file_position)\n+                    analysis.diagnostics(file_id, true).unwrap();\n+                    analysis.highlight_as_html(file_id, false).unwrap()\n                 });\n                 if verbosity.is_verbose() {\n-                    println!(\"\\n{:#?}\", res);\n+                    println!(\"\\n{}\", res);\n                 }\n-            } else {\n-                let res =\n-                    do_work(&mut host, file_id, |analysis| analysis.goto_definition(file_position));\n-                if verbosity.is_verbose() {\n-                    println!(\"\\n{:#?}\", res);\n+            }\n+            BenchWhat::Complete(pos) | BenchWhat::GotoDef(pos) => {\n+                let is_completion = matches!(self.what, BenchWhat::Complete(..));\n+\n+                let offset = host\n+                    .analysis()\n+                    .file_line_index(file_id)?\n+                    .offset(LineCol { line: pos.line - 1, col_utf16: pos.column });\n+                let file_position = FilePosition { file_id, offset };\n+\n+                if is_completion {\n+                    let options = CompletionConfig::default();\n+                    let res = do_work(&mut host, file_id, |analysis| {\n+                        analysis.completions(&options, file_position)\n+                    });\n+                    if verbosity.is_verbose() {\n+                        println!(\"\\n{:#?}\", res);\n+                    }\n+                } else {\n+                    let res = do_work(&mut host, file_id, |analysis| {\n+                        analysis.goto_definition(file_position)\n+                    });\n+                    if verbosity.is_verbose() {\n+                        println!(\"\\n{:#?}\", res);\n+                    }\n                 }\n             }\n         }\n-    }\n \n-    if memory_usage {\n-        print_memory_usage(host, vfs);\n-    }\n+        if self.memory_usage {\n+            print_memory_usage(host, vfs);\n+        }\n \n-    Ok(())\n+        Ok(())\n+    }\n }\n \n fn do_work<F: Fn(&Analysis) -> T, T>(host: &mut AnalysisHost, file_id: FileId, work: F) -> T {"}, {"sha": "721d41a58f8432ec47ccde6a7ce65407bb1bda36", "filename": "crates/rust-analyzer/src/cli/analysis_stats.rs", "status": "modified", "additions": 229, "deletions": 222, "changes": 451, "blob_url": "https://github.com/rust-lang/rust/blob/43d81422149cabf7e61c0db67e298103c86bfb0d/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fanalysis_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43d81422149cabf7e61c0db67e298103c86bfb0d/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fanalysis_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fanalysis_stats.rs?ref=43d81422149cabf7e61c0db67e298103c86bfb0d", "patch": "@@ -2,7 +2,7 @@\n //! errors.\n \n use std::{\n-    path::Path,\n+    path::PathBuf,\n     time::{SystemTime, UNIX_EPOCH},\n };\n \n@@ -39,273 +39,280 @@ impl<DB: ParallelDatabase> Clone for Snap<salsa::Snapshot<DB>> {\n     }\n }\n \n-pub fn analysis_stats(\n-    verbosity: Verbosity,\n-    memory_usage: bool,\n-    path: &Path,\n-    only: Option<&str>,\n-    with_deps: bool,\n-    randomize: bool,\n-    parallel: bool,\n-    load_output_dirs: bool,\n-    with_proc_macro: bool,\n-) -> Result<()> {\n-    let mut rng = {\n-        let seed = SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_millis() as u64;\n-        Rand32::new(seed)\n-    };\n+pub struct AnalysisStatsCmd {\n+    pub randomize: bool,\n+    pub parallel: bool,\n+    pub memory_usage: bool,\n+    pub only: Option<String>,\n+    pub with_deps: bool,\n+    pub path: PathBuf,\n+    pub load_output_dirs: bool,\n+    pub with_proc_macro: bool,\n+}\n \n-    let mut db_load_sw = StopWatch::start().memory(memory_usage);\n-    let (host, vfs) = load_cargo(path, load_output_dirs, with_proc_macro)?;\n-    let db = host.raw_database();\n-    eprintln!(\"Database loaded {}\", db_load_sw.elapsed());\n+impl AnalysisStatsCmd {\n+    pub fn run(self, verbosity: Verbosity) -> Result<()> {\n+        let mut rng = {\n+            let seed = SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_millis() as u64;\n+            Rand32::new(seed)\n+        };\n \n-    let mut analysis_sw = StopWatch::start().memory(memory_usage);\n-    let mut num_crates = 0;\n-    let mut visited_modules = FxHashSet::default();\n-    let mut visit_queue = Vec::new();\n+        let mut db_load_sw = self.stop_watch();\n+        let (host, vfs) = load_cargo(&self.path, self.load_output_dirs, self.with_proc_macro)?;\n+        let db = host.raw_database();\n+        eprintln!(\"Database loaded {}\", db_load_sw.elapsed());\n \n-    let mut krates = Crate::all(db);\n-    if randomize {\n-        shuffle(&mut rng, &mut krates);\n-    }\n-    for krate in krates {\n-        let module = krate.root_module(db).expect(\"crate without root module\");\n-        let file_id = module.definition_source(db).file_id;\n-        let file_id = file_id.original_file(db);\n-        let source_root = db.file_source_root(file_id);\n-        let source_root = db.source_root(source_root);\n-        if !source_root.is_library || with_deps {\n-            num_crates += 1;\n-            visit_queue.push(module);\n-        }\n-    }\n+        let mut analysis_sw = self.stop_watch();\n+        let mut num_crates = 0;\n+        let mut visited_modules = FxHashSet::default();\n+        let mut visit_queue = Vec::new();\n \n-    if randomize {\n-        shuffle(&mut rng, &mut visit_queue);\n-    }\n+        let mut krates = Crate::all(db);\n+        if self.randomize {\n+            shuffle(&mut rng, &mut krates);\n+        }\n+        for krate in krates {\n+            let module = krate.root_module(db).expect(\"crate without root module\");\n+            let file_id = module.definition_source(db).file_id;\n+            let file_id = file_id.original_file(db);\n+            let source_root = db.file_source_root(file_id);\n+            let source_root = db.source_root(source_root);\n+            if !source_root.is_library || self.with_deps {\n+                num_crates += 1;\n+                visit_queue.push(module);\n+            }\n+        }\n \n-    eprintln!(\"Crates in this dir: {}\", num_crates);\n-    let mut num_decls = 0;\n-    let mut funcs = Vec::new();\n-    while let Some(module) = visit_queue.pop() {\n-        if visited_modules.insert(module) {\n-            visit_queue.extend(module.children(db));\n+        if self.randomize {\n+            shuffle(&mut rng, &mut visit_queue);\n+        }\n \n-            for decl in module.declarations(db) {\n-                num_decls += 1;\n-                if let ModuleDef::Function(f) = decl {\n-                    funcs.push(f);\n-                }\n-            }\n+        eprintln!(\"Crates in this dir: {}\", num_crates);\n+        let mut num_decls = 0;\n+        let mut funcs = Vec::new();\n+        while let Some(module) = visit_queue.pop() {\n+            if visited_modules.insert(module) {\n+                visit_queue.extend(module.children(db));\n \n-            for impl_def in module.impl_defs(db) {\n-                for item in impl_def.items(db) {\n+                for decl in module.declarations(db) {\n                     num_decls += 1;\n-                    if let AssocItem::Function(f) = item {\n+                    if let ModuleDef::Function(f) = decl {\n                         funcs.push(f);\n                     }\n                 }\n+\n+                for impl_def in module.impl_defs(db) {\n+                    for item in impl_def.items(db) {\n+                        num_decls += 1;\n+                        if let AssocItem::Function(f) = item {\n+                            funcs.push(f);\n+                        }\n+                    }\n+                }\n             }\n         }\n-    }\n-    eprintln!(\"Total modules found: {}\", visited_modules.len());\n-    eprintln!(\"Total declarations: {}\", num_decls);\n-    eprintln!(\"Total functions: {}\", funcs.len());\n-    eprintln!(\"Item Collection: {}\", analysis_sw.elapsed());\n-\n-    if randomize {\n-        shuffle(&mut rng, &mut funcs);\n-    }\n+        eprintln!(\"Total modules found: {}\", visited_modules.len());\n+        eprintln!(\"Total declarations: {}\", num_decls);\n+        eprintln!(\"Total functions: {}\", funcs.len());\n+        eprintln!(\"Item Collection: {}\", analysis_sw.elapsed());\n \n-    let mut bar = match verbosity {\n-        Verbosity::Quiet | Verbosity::Spammy => ProgressReport::hidden(),\n-        _ if parallel => ProgressReport::hidden(),\n-        _ => ProgressReport::new(funcs.len() as u64),\n-    };\n+        if self.randomize {\n+            shuffle(&mut rng, &mut funcs);\n+        }\n \n-    if parallel {\n-        let mut inference_sw = StopWatch::start().memory(memory_usage);\n-        let snap = Snap(db.snapshot());\n-        funcs\n-            .par_iter()\n-            .map_with(snap, |snap, &f| {\n-                let f_id = FunctionId::from(f);\n-                snap.0.body(f_id.into());\n-                snap.0.infer(f_id.into());\n-            })\n-            .count();\n-        eprintln!(\"Parallel Inference: {}\", inference_sw.elapsed());\n-    }\n+        let mut bar = match verbosity {\n+            Verbosity::Quiet | Verbosity::Spammy => ProgressReport::hidden(),\n+            _ if self.parallel => ProgressReport::hidden(),\n+            _ => ProgressReport::new(funcs.len() as u64),\n+        };\n \n-    let mut inference_sw = StopWatch::start().memory(memory_usage);\n-    bar.tick();\n-    let mut num_exprs = 0;\n-    let mut num_exprs_unknown = 0;\n-    let mut num_exprs_partially_unknown = 0;\n-    let mut num_type_mismatches = 0;\n-    for f in funcs {\n-        let name = f.name(db);\n-        let full_name = f\n-            .module(db)\n-            .path_to_root(db)\n-            .into_iter()\n-            .rev()\n-            .filter_map(|it| it.name(db))\n-            .chain(Some(f.name(db)))\n-            .join(\"::\");\n-        if let Some(only_name) = only {\n-            if name.to_string() != only_name && full_name != only_name {\n-                continue;\n-            }\n-        }\n-        let mut msg = format!(\"processing: {}\", full_name);\n-        if verbosity.is_verbose() {\n-            let src = f.source(db);\n-            let original_file = src.file_id.original_file(db);\n-            let path = vfs.file_path(original_file);\n-            let syntax_range = src.value.syntax().text_range();\n-            format_to!(msg, \" ({} {:?})\", path, syntax_range);\n+        if self.parallel {\n+            let mut inference_sw = self.stop_watch();\n+            let snap = Snap(db.snapshot());\n+            funcs\n+                .par_iter()\n+                .map_with(snap, |snap, &f| {\n+                    let f_id = FunctionId::from(f);\n+                    snap.0.body(f_id.into());\n+                    snap.0.infer(f_id.into());\n+                })\n+                .count();\n+            eprintln!(\"Parallel Inference: {}\", inference_sw.elapsed());\n         }\n-        if verbosity.is_spammy() {\n-            bar.println(msg.to_string());\n-        }\n-        bar.set_message(&msg);\n-        let f_id = FunctionId::from(f);\n-        let body = db.body(f_id.into());\n-        let inference_result = db.infer(f_id.into());\n-        let (previous_exprs, previous_unknown, previous_partially_unknown) =\n-            (num_exprs, num_exprs_unknown, num_exprs_partially_unknown);\n-        for (expr_id, _) in body.exprs.iter() {\n-            let ty = &inference_result[expr_id];\n-            num_exprs += 1;\n-            if let Ty::Unknown = ty {\n-                num_exprs_unknown += 1;\n-            } else {\n-                let mut is_partially_unknown = false;\n-                ty.walk(&mut |ty| {\n-                    if let Ty::Unknown = ty {\n-                        is_partially_unknown = true;\n-                    }\n-                });\n-                if is_partially_unknown {\n-                    num_exprs_partially_unknown += 1;\n+\n+        let mut inference_sw = self.stop_watch();\n+        bar.tick();\n+        let mut num_exprs = 0;\n+        let mut num_exprs_unknown = 0;\n+        let mut num_exprs_partially_unknown = 0;\n+        let mut num_type_mismatches = 0;\n+        for f in funcs {\n+            let name = f.name(db);\n+            let full_name = f\n+                .module(db)\n+                .path_to_root(db)\n+                .into_iter()\n+                .rev()\n+                .filter_map(|it| it.name(db))\n+                .chain(Some(f.name(db)))\n+                .join(\"::\");\n+            if let Some(only_name) = self.only.as_deref() {\n+                if name.to_string() != only_name && full_name != only_name {\n+                    continue;\n                 }\n             }\n-            if only.is_some() && verbosity.is_spammy() {\n-                // in super-verbose mode for just one function, we print every single expression\n-                let (_, sm) = db.body_with_source_map(f_id.into());\n-                let src = sm.expr_syntax(expr_id);\n-                if let Ok(src) = src {\n-                    let node = {\n-                        let root = db.parse_or_expand(src.file_id).unwrap();\n-                        src.value.to_node(&root)\n-                    };\n-                    let original_file = src.file_id.original_file(db);\n-                    let line_index = host.analysis().file_line_index(original_file).unwrap();\n-                    let text_range = node.syntax().text_range();\n-                    let (start, end) = (\n-                        line_index.line_col(text_range.start()),\n-                        line_index.line_col(text_range.end()),\n-                    );\n-                    bar.println(format!(\n-                        \"{}:{}-{}:{}: {}\",\n-                        start.line + 1,\n-                        start.col_utf16,\n-                        end.line + 1,\n-                        end.col_utf16,\n-                        ty.display(db)\n-                    ));\n+            let mut msg = format!(\"processing: {}\", full_name);\n+            if verbosity.is_verbose() {\n+                let src = f.source(db);\n+                let original_file = src.file_id.original_file(db);\n+                let path = vfs.file_path(original_file);\n+                let syntax_range = src.value.syntax().text_range();\n+                format_to!(msg, \" ({} {:?})\", path, syntax_range);\n+            }\n+            if verbosity.is_spammy() {\n+                bar.println(msg.to_string());\n+            }\n+            bar.set_message(&msg);\n+            let f_id = FunctionId::from(f);\n+            let body = db.body(f_id.into());\n+            let inference_result = db.infer(f_id.into());\n+            let (previous_exprs, previous_unknown, previous_partially_unknown) =\n+                (num_exprs, num_exprs_unknown, num_exprs_partially_unknown);\n+            for (expr_id, _) in body.exprs.iter() {\n+                let ty = &inference_result[expr_id];\n+                num_exprs += 1;\n+                if let Ty::Unknown = ty {\n+                    num_exprs_unknown += 1;\n                 } else {\n-                    bar.println(format!(\"unknown location: {}\", ty.display(db)));\n+                    let mut is_partially_unknown = false;\n+                    ty.walk(&mut |ty| {\n+                        if let Ty::Unknown = ty {\n+                            is_partially_unknown = true;\n+                        }\n+                    });\n+                    if is_partially_unknown {\n+                        num_exprs_partially_unknown += 1;\n+                    }\n                 }\n-            }\n-            if let Some(mismatch) = inference_result.type_mismatch_for_expr(expr_id) {\n-                num_type_mismatches += 1;\n-                if verbosity.is_verbose() {\n+                if self.only.is_some() && verbosity.is_spammy() {\n+                    // in super-verbose mode for just one function, we print every single expression\n                     let (_, sm) = db.body_with_source_map(f_id.into());\n                     let src = sm.expr_syntax(expr_id);\n                     if let Ok(src) = src {\n-                        // FIXME: it might be nice to have a function (on Analysis?) that goes from Source<T> -> (LineCol, LineCol) directly\n-                        // But also, we should just turn the type mismatches into diagnostics and provide these\n-                        let root = db.parse_or_expand(src.file_id).unwrap();\n-                        let node = src.map(|e| e.to_node(&root).syntax().clone());\n-                        let original_range = original_range(db, node.as_ref());\n-                        let path = vfs.file_path(original_range.file_id);\n-                        let line_index =\n-                            host.analysis().file_line_index(original_range.file_id).unwrap();\n-                        let text_range = original_range.range;\n+                        let node = {\n+                            let root = db.parse_or_expand(src.file_id).unwrap();\n+                            src.value.to_node(&root)\n+                        };\n+                        let original_file = src.file_id.original_file(db);\n+                        let line_index = host.analysis().file_line_index(original_file).unwrap();\n+                        let text_range = node.syntax().text_range();\n                         let (start, end) = (\n                             line_index.line_col(text_range.start()),\n                             line_index.line_col(text_range.end()),\n                         );\n                         bar.println(format!(\n-                            \"{} {}:{}-{}:{}: Expected {}, got {}\",\n-                            path,\n+                            \"{}:{}-{}:{}: {}\",\n                             start.line + 1,\n                             start.col_utf16,\n                             end.line + 1,\n                             end.col_utf16,\n-                            mismatch.expected.display(db),\n-                            mismatch.actual.display(db)\n+                            ty.display(db)\n                         ));\n                     } else {\n-                        bar.println(format!(\n-                            \"{}: Expected {}, got {}\",\n-                            name,\n-                            mismatch.expected.display(db),\n-                            mismatch.actual.display(db)\n-                        ));\n+                        bar.println(format!(\"unknown location: {}\", ty.display(db)));\n+                    }\n+                }\n+                if let Some(mismatch) = inference_result.type_mismatch_for_expr(expr_id) {\n+                    num_type_mismatches += 1;\n+                    if verbosity.is_verbose() {\n+                        let (_, sm) = db.body_with_source_map(f_id.into());\n+                        let src = sm.expr_syntax(expr_id);\n+                        if let Ok(src) = src {\n+                            // FIXME: it might be nice to have a function (on Analysis?) that goes from Source<T> -> (LineCol, LineCol) directly\n+                            // But also, we should just turn the type mismatches into diagnostics and provide these\n+                            let root = db.parse_or_expand(src.file_id).unwrap();\n+                            let node = src.map(|e| e.to_node(&root).syntax().clone());\n+                            let original_range = original_range(db, node.as_ref());\n+                            let path = vfs.file_path(original_range.file_id);\n+                            let line_index =\n+                                host.analysis().file_line_index(original_range.file_id).unwrap();\n+                            let text_range = original_range.range;\n+                            let (start, end) = (\n+                                line_index.line_col(text_range.start()),\n+                                line_index.line_col(text_range.end()),\n+                            );\n+                            bar.println(format!(\n+                                \"{} {}:{}-{}:{}: Expected {}, got {}\",\n+                                path,\n+                                start.line + 1,\n+                                start.col_utf16,\n+                                end.line + 1,\n+                                end.col_utf16,\n+                                mismatch.expected.display(db),\n+                                mismatch.actual.display(db)\n+                            ));\n+                        } else {\n+                            bar.println(format!(\n+                                \"{}: Expected {}, got {}\",\n+                                name,\n+                                mismatch.expected.display(db),\n+                                mismatch.actual.display(db)\n+                            ));\n+                        }\n                     }\n                 }\n             }\n+            if verbosity.is_spammy() {\n+                bar.println(format!(\n+                    \"In {}: {} exprs, {} unknown, {} partial\",\n+                    full_name,\n+                    num_exprs - previous_exprs,\n+                    num_exprs_unknown - previous_unknown,\n+                    num_exprs_partially_unknown - previous_partially_unknown\n+                ));\n+            }\n+            bar.inc(1);\n         }\n-        if verbosity.is_spammy() {\n-            bar.println(format!(\n-                \"In {}: {} exprs, {} unknown, {} partial\",\n-                full_name,\n-                num_exprs - previous_exprs,\n-                num_exprs_unknown - previous_unknown,\n-                num_exprs_partially_unknown - previous_partially_unknown\n-            ));\n-        }\n-        bar.inc(1);\n-    }\n-    bar.finish_and_clear();\n-    eprintln!(\"Total expressions: {}\", num_exprs);\n-    eprintln!(\n-        \"Expressions of unknown type: {} ({}%)\",\n-        num_exprs_unknown,\n-        if num_exprs > 0 { num_exprs_unknown * 100 / num_exprs } else { 100 }\n-    );\n-    report_metric(\"unknown type\", num_exprs_unknown, \"#\");\n+        bar.finish_and_clear();\n+        eprintln!(\"Total expressions: {}\", num_exprs);\n+        eprintln!(\n+            \"Expressions of unknown type: {} ({}%)\",\n+            num_exprs_unknown,\n+            if num_exprs > 0 { num_exprs_unknown * 100 / num_exprs } else { 100 }\n+        );\n+        report_metric(\"unknown type\", num_exprs_unknown, \"#\");\n \n-    eprintln!(\n-        \"Expressions of partially unknown type: {} ({}%)\",\n-        num_exprs_partially_unknown,\n-        if num_exprs > 0 { num_exprs_partially_unknown * 100 / num_exprs } else { 100 }\n-    );\n+        eprintln!(\n+            \"Expressions of partially unknown type: {} ({}%)\",\n+            num_exprs_partially_unknown,\n+            if num_exprs > 0 { num_exprs_partially_unknown * 100 / num_exprs } else { 100 }\n+        );\n \n-    eprintln!(\"Type mismatches: {}\", num_type_mismatches);\n-    report_metric(\"type mismatches\", num_type_mismatches, \"#\");\n+        eprintln!(\"Type mismatches: {}\", num_type_mismatches);\n+        report_metric(\"type mismatches\", num_type_mismatches, \"#\");\n \n-    eprintln!(\"Inference: {}\", inference_sw.elapsed());\n+        eprintln!(\"Inference: {}\", inference_sw.elapsed());\n \n-    let total_span = analysis_sw.elapsed();\n-    eprintln!(\"Total: {}\", total_span);\n-    report_metric(\"total time\", total_span.time.as_millis() as u64, \"ms\");\n-    if let Some(instructions) = total_span.instructions {\n-        report_metric(\"total instructions\", instructions, \"#instr\");\n-    }\n-    if let Some(memory) = total_span.memory {\n-        report_metric(\"total memory\", memory.allocated.megabytes() as u64, \"MB\");\n-    }\n+        let total_span = analysis_sw.elapsed();\n+        eprintln!(\"Total: {}\", total_span);\n+        report_metric(\"total time\", total_span.time.as_millis() as u64, \"ms\");\n+        if let Some(instructions) = total_span.instructions {\n+            report_metric(\"total instructions\", instructions, \"#instr\");\n+        }\n+        if let Some(memory) = total_span.memory {\n+            report_metric(\"total memory\", memory.allocated.megabytes() as u64, \"MB\");\n+        }\n \n-    if memory_usage {\n-        print_memory_usage(host, vfs);\n+        if self.memory_usage {\n+            print_memory_usage(host, vfs);\n+        }\n+\n+        Ok(())\n     }\n \n-    Ok(())\n+    fn stop_watch(&self) -> StopWatch {\n+        StopWatch::start().memory(self.memory_usage)\n+    }\n }\n \n fn shuffle<T>(rng: &mut Rand32, slice: &mut [T]) {"}, {"sha": "e73b3a2119e65ceb550291a7ef25f0d6cc5e2810", "filename": "crates/rust-analyzer/src/handlers.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/43d81422149cabf7e61c0db67e298103c86bfb0d/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43d81422149cabf7e61c0db67e298103c86bfb0d/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs?ref=43d81422149cabf7e61c0db67e298103c86bfb0d", "patch": "@@ -26,7 +26,7 @@ use ra_project_model::TargetKind;\n use ra_syntax::{algo, ast, AstNode, SyntaxKind, TextRange, TextSize};\n use serde::{Deserialize, Serialize};\n use serde_json::to_value;\n-use stdx::{format_to, split_delim};\n+use stdx::{format_to, split_once};\n \n use crate::{\n     cargo_target_spec::CargoTargetSpec,\n@@ -865,7 +865,7 @@ pub(crate) fn handle_resolve_code_action(\n         .map(|it| it.into_iter().filter_map(from_proto::assist_kind).collect());\n \n     let assists = snap.analysis.resolved_assists(&snap.config.assist, frange)?;\n-    let (id_string, index) = split_delim(&params.id, ':').unwrap();\n+    let (id_string, index) = split_once(&params.id, ':').unwrap();\n     let index = index.parse::<usize>().unwrap();\n     let assist = &assists[index];\n     assert!(assist.assist.id.0 == id_string);"}, {"sha": "b65875c96e03edfaae0d7e1defabefb20dda6054", "filename": "crates/stdx/src/lib.rs", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/43d81422149cabf7e61c0db67e298103c86bfb0d/crates%2Fstdx%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43d81422149cabf7e61c0db67e298103c86bfb0d/crates%2Fstdx%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fstdx%2Fsrc%2Flib.rs?ref=43d81422149cabf7e61c0db67e298103c86bfb0d", "patch": "@@ -109,9 +109,18 @@ pub fn replace(buf: &mut String, from: char, to: &str) {\n     *buf = buf.replace(from, to)\n }\n \n-pub fn split_delim(haystack: &str, delim: char) -> Option<(&str, &str)> {\n-    let idx = haystack.find(delim)?;\n-    Some((&haystack[..idx], &haystack[idx + delim.len_utf8()..]))\n+// https://github.com/rust-lang/rust/issues/74773\n+pub fn split_once(haystack: &str, delim: char) -> Option<(&str, &str)> {\n+    let mut split = haystack.splitn(2, delim);\n+    let prefix = split.next()?;\n+    let suffix = split.next()?;\n+    Some((prefix, suffix))\n+}\n+pub fn rsplit_once(haystack: &str, delim: char) -> Option<(&str, &str)> {\n+    let mut split = haystack.rsplitn(2, delim);\n+    let suffix = split.next()?;\n+    let prefix = split.next()?;\n+    Some((prefix, suffix))\n }\n \n pub fn trim_indent(mut text: &str) -> String {"}, {"sha": "e40b61a94a4810b3a99a53eebe3cb36bbbd944c7", "filename": "crates/test_utils/src/fixture.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/43d81422149cabf7e61c0db67e298103c86bfb0d/crates%2Ftest_utils%2Fsrc%2Ffixture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43d81422149cabf7e61c0db67e298103c86bfb0d/crates%2Ftest_utils%2Fsrc%2Ffixture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftest_utils%2Fsrc%2Ffixture.rs?ref=43d81422149cabf7e61c0db67e298103c86bfb0d", "patch": "@@ -2,7 +2,7 @@\n //! rust-analyzer database from a single string.\n \n use rustc_hash::FxHashMap;\n-use stdx::{lines_with_ends, split_delim, trim_indent};\n+use stdx::{lines_with_ends, split_once, trim_indent};\n \n #[derive(Debug, Eq, PartialEq)]\n pub struct Fixture {\n@@ -71,22 +71,22 @@ impl Fixture {\n         let mut cfg_key_values = Vec::new();\n         let mut env = FxHashMap::default();\n         for component in components[1..].iter() {\n-            let (key, value) = split_delim(component, ':').unwrap();\n+            let (key, value) = split_once(component, ':').unwrap();\n             match key {\n                 \"crate\" => krate = Some(value.to_string()),\n                 \"deps\" => deps = value.split(',').map(|it| it.to_string()).collect(),\n                 \"edition\" => edition = Some(value.to_string()),\n                 \"cfg\" => {\n                     for entry in value.split(',') {\n-                        match split_delim(entry, '=') {\n+                        match split_once(entry, '=') {\n                             Some((k, v)) => cfg_key_values.push((k.to_string(), v.to_string())),\n                             None => cfg_atoms.push(entry.to_string()),\n                         }\n                     }\n                 }\n                 \"env\" => {\n                     for key in value.split(',') {\n-                        if let Some((k, v)) = split_delim(key, '=') {\n+                        if let Some((k, v)) = split_once(key, '=') {\n                             env.insert(k.into(), v.into());\n                         }\n                     }"}]}