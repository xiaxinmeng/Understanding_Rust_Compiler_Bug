{"sha": "15b9f45cca87abf30415daefaa85218756e994ed", "node_id": "C_kwDOAAsO6NoAKDE1YjlmNDVjY2E4N2FiZjMwNDE1ZGFlZmFhODUyMTg3NTZlOTk0ZWQ", "commit": {"author": {"name": "DebugSteven", "email": "debugsteven@gmail.com", "date": "2022-12-17T20:41:30Z"}, "committer": {"name": "DebugSteven", "email": "debugsteven@gmail.com", "date": "2023-01-31T22:28:19Z"}, "message": "busy waiting implementation for sleep", "tree": {"sha": "0ddd74a370cbd0b90e58206ca7d86daa96819429", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0ddd74a370cbd0b90e58206ca7d86daa96819429"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/15b9f45cca87abf30415daefaa85218756e994ed", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/15b9f45cca87abf30415daefaa85218756e994ed", "html_url": "https://github.com/rust-lang/rust/commit/15b9f45cca87abf30415daefaa85218756e994ed", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/15b9f45cca87abf30415daefaa85218756e994ed/comments", "author": {"login": "DebugSteven", "id": 10746702, "node_id": "MDQ6VXNlcjEwNzQ2NzAy", "avatar_url": "https://avatars.githubusercontent.com/u/10746702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/DebugSteven", "html_url": "https://github.com/DebugSteven", "followers_url": "https://api.github.com/users/DebugSteven/followers", "following_url": "https://api.github.com/users/DebugSteven/following{/other_user}", "gists_url": "https://api.github.com/users/DebugSteven/gists{/gist_id}", "starred_url": "https://api.github.com/users/DebugSteven/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/DebugSteven/subscriptions", "organizations_url": "https://api.github.com/users/DebugSteven/orgs", "repos_url": "https://api.github.com/users/DebugSteven/repos", "events_url": "https://api.github.com/users/DebugSteven/events{/privacy}", "received_events_url": "https://api.github.com/users/DebugSteven/received_events", "type": "User", "site_admin": false}, "committer": {"login": "DebugSteven", "id": 10746702, "node_id": "MDQ6VXNlcjEwNzQ2NzAy", "avatar_url": "https://avatars.githubusercontent.com/u/10746702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/DebugSteven", "html_url": "https://github.com/DebugSteven", "followers_url": "https://api.github.com/users/DebugSteven/followers", "following_url": "https://api.github.com/users/DebugSteven/following{/other_user}", "gists_url": "https://api.github.com/users/DebugSteven/gists{/gist_id}", "starred_url": "https://api.github.com/users/DebugSteven/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/DebugSteven/subscriptions", "organizations_url": "https://api.github.com/users/DebugSteven/orgs", "repos_url": "https://api.github.com/users/DebugSteven/repos", "events_url": "https://api.github.com/users/DebugSteven/events{/privacy}", "received_events_url": "https://api.github.com/users/DebugSteven/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0aaa9ea5c05519f8e4676333cade3183b60fcc87", "url": "https://api.github.com/repos/rust-lang/rust/commits/0aaa9ea5c05519f8e4676333cade3183b60fcc87", "html_url": "https://github.com/rust-lang/rust/commit/0aaa9ea5c05519f8e4676333cade3183b60fcc87"}], "stats": {"total": 115, "additions": 111, "deletions": 4}, "files": [{"sha": "fd4927fa10ce39b876f8e4966def8d25e5e476eb", "filename": "src/tools/miri/src/shims/unix/linux/fd.rs", "status": "modified", "additions": 57, "deletions": 1, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/15b9f45cca87abf30415daefaa85218756e994ed/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Flinux%2Ffd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15b9f45cca87abf30415daefaa85218756e994ed/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Flinux%2Ffd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Flinux%2Ffd.rs?ref=15b9f45cca87abf30415daefaa85218756e994ed", "patch": "@@ -7,6 +7,8 @@ use socketpair::SocketPair;\n \n use shims::unix::fs::EvalContextExt as _;\n \n+use std::cell::Cell;\n+\n pub mod epoll;\n pub mod event;\n pub mod socketpair;\n@@ -101,6 +103,60 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         }\n     }\n \n+    /// The `epoll_wait()` system call waits for events on the `Epoll`\n+    /// instance referred to by the file descriptor `epfd`. The buffer\n+    /// pointed to by `events` is used to return information from the ready\n+    /// list about file descriptors in the interest list that have some\n+    /// events available. Up to `maxevents` are returned by `epoll_wait()`.\n+    /// The `maxevents` argument must be greater than zero.\n+\n+    /// The `timeout` argument specifies the number of milliseconds that\n+    /// `epoll_wait()` will block. Time is measured against the\n+    /// CLOCK_MONOTONIC clock.\n+\n+    /// A call to `epoll_wait()` will block until either:\n+    /// \u2022 a file descriptor delivers an event;\n+    /// \u2022 the call is interrupted by a signal handler; or\n+    /// \u2022 the timeout expires.\n+\n+    /// Note that the timeout interval will be rounded up to the system\n+    /// clock granularity, and kernel scheduling delays mean that the\n+    /// blocking interval may overrun by a small amount. Specifying a\n+    /// timeout of -1 causes `epoll_wait()` to block indefinitely, while\n+    /// specifying a timeout equal to zero cause `epoll_wait()` to return\n+    /// immediately, even if no events are available.\n+    ///\n+    /// On success, `epoll_wait()` returns the number of file descriptors\n+    /// ready for the requested I/O, or zero if no file descriptor became\n+    /// ready during the requested timeout milliseconds. On failure,\n+    /// `epoll_wait()` returns -1 and errno is set to indicate the error.\n+    ///\n+    /// <https://man7.org/linux/man-pages/man2/epoll_wait.2.html>\n+    fn epoll_wait(\n+        &mut self,\n+        epfd: &OpTy<'tcx, Provenance>,\n+        events: &OpTy<'tcx, Provenance>,\n+        maxevents: &OpTy<'tcx, Provenance>,\n+        timeout: &OpTy<'tcx, Provenance>,\n+    ) -> InterpResult<'tcx, Scalar<Provenance>> {\n+        let this = self.eval_context_mut();\n+\n+        let epfd = this.read_scalar(epfd)?.to_i32()?;\n+        let _events = this.read_scalar(events)?.to_pointer(this)?;\n+        let _maxevents = this.read_scalar(maxevents)?.to_i32()?;\n+        let _timeout = this.read_scalar(timeout)?.to_i32()?;\n+\n+        let numevents = 0;\n+        if let Some(epfd) = this.machine.file_handler.handles.get_mut(&epfd) {\n+            let _epfd = epfd.as_epoll_handle()?;\n+\n+            // FIXME return number of events ready when scheme for marking events ready exists\n+            Ok(Scalar::from_i32(numevents))\n+        } else {\n+            Ok(Scalar::from_i32(this.handle_not_found()?))\n+        }\n+    }\n+\n     /// This function creates an `Event` that is used as an event wait/notify mechanism by\n     /// user-space applications, and by the kernel to notify user-space applications of events.\n     /// The `Event` contains an `u64` counter maintained by the kernel. The counter is initialized\n@@ -142,7 +198,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         }\n \n         let fh = &mut this.machine.file_handler;\n-        let fd = fh.insert_fd(Box::new(Event { val }));\n+        let fd = fh.insert_fd(Box::new(Event { val: Cell::new(val.into()) }));\n         Ok(Scalar::from_i32(fd))\n     }\n "}, {"sha": "b28a6e0c56eca8e27eba5e48fde7b3157d472dfe", "filename": "src/tools/miri/src/shims/unix/linux/fd/event.rs", "status": "modified", "additions": 33, "deletions": 2, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/15b9f45cca87abf30415daefaa85218756e994ed/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Flinux%2Ffd%2Fevent.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15b9f45cca87abf30415daefaa85218756e994ed/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Flinux%2Ffd%2Fevent.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Flinux%2Ffd%2Fevent.rs?ref=15b9f45cca87abf30415daefaa85218756e994ed", "patch": "@@ -2,6 +2,7 @@ use crate::shims::unix::fs::FileDescriptor;\n \n use rustc_const_eval::interpret::InterpResult;\n \n+use std::cell::Cell;\n use std::io;\n \n /// A kind of file descriptor created by `eventfd`.\n@@ -13,7 +14,9 @@ use std::io;\n /// <https://man.netbsd.org/eventfd.2>\n #[derive(Debug)]\n pub struct Event {\n-    pub val: u32,\n+    /// The object contains an unsigned 64-bit integer (uint64_t) counter that is maintained by the\n+    /// kernel. This counter is initialized with the value specified in the argument initval.\n+    pub val: Cell<u64>,\n }\n \n impl FileDescriptor for Event {\n@@ -22,7 +25,7 @@ impl FileDescriptor for Event {\n     }\n \n     fn dup(&mut self) -> io::Result<Box<dyn FileDescriptor>> {\n-        Ok(Box::new(Event { val: self.val }))\n+        Ok(Box::new(Event { val: self.val.clone() }))\n     }\n \n     fn is_tty(&self) -> bool {\n@@ -35,4 +38,32 @@ impl FileDescriptor for Event {\n     ) -> InterpResult<'tcx, io::Result<i32>> {\n         Ok(Ok(0))\n     }\n+\n+    /// A write call adds the 8-byte integer value supplied in\n+    /// its buffer to the counter.  The maximum value that may be\n+    /// stored in the counter is the largest unsigned 64-bit value\n+    /// minus 1 (i.e., 0xfffffffffffffffe).  If the addition would\n+    /// cause the counter's value to exceed the maximum, then the\n+    /// write either blocks until a read is performed on the\n+    /// file descriptor, or fails with the error EAGAIN if the\n+    /// file descriptor has been made nonblocking.\n+\n+    /// A write fails with the error EINVAL if the size of the\n+    /// supplied buffer is less than 8 bytes, or if an attempt is\n+    /// made to write the value 0xffffffffffffffff.\n+    ///\n+    /// FIXME: use endianness\n+    fn write<'tcx>(\n+        &self,\n+        _communicate_allowed: bool,\n+        bytes: &[u8],\n+    ) -> InterpResult<'tcx, io::Result<usize>> {\n+        let v1 = self.val.get();\n+        // FIXME handle blocking when addition results in exceeding the max u64 value\n+        // or fail with EAGAIN if the file descriptor is nonblocking.\n+        let v2 = v1.checked_add(u64::from_be_bytes(bytes.try_into().unwrap())).unwrap();\n+        self.val.set(v2);\n+        assert_eq!(8, bytes.len());\n+        Ok(Ok(8))\n+    }\n }"}, {"sha": "56d8d428210e211f812f21bc68eeff439a0fc08a", "filename": "src/tools/miri/src/shims/unix/linux/foreign_items.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/15b9f45cca87abf30415daefaa85218756e994ed/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Flinux%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15b9f45cca87abf30415daefaa85218756e994ed/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Flinux%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Flinux%2Fforeign_items.rs?ref=15b9f45cca87abf30415daefaa85218756e994ed", "patch": "@@ -55,6 +55,12 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                 let result = this.epoll_ctl(epfd, op, fd, event)?;\n                 this.write_scalar(result, dest)?;\n             }\n+            \"epoll_wait\" => {\n+                let [epfd, events, maxevents, timeout] =\n+                    this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let result = this.epoll_wait(epfd, events, maxevents, timeout)?;\n+                this.write_scalar(result, dest)?;\n+            }\n             \"eventfd\" => {\n                 let [val, flag] =\n                     this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;"}, {"sha": "1341484dda4753e1c4beb13b09f10969f29baae5", "filename": "src/tools/miri/tests/pass-dep/tokio/sleep.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/15b9f45cca87abf30415daefaa85218756e994ed/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Ftokio%2Fsleep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15b9f45cca87abf30415daefaa85218756e994ed/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Ftokio%2Fsleep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Ftokio%2Fsleep.rs?ref=15b9f45cca87abf30415daefaa85218756e994ed", "patch": "@@ -0,0 +1,14 @@\n+//@compile-flags: -Zmiri-disable-isolation -Zmiri-permissive-provenance -Zmiri-backtrace=full\n+//@only-target-x86_64-unknown-linux: support for tokio only on linux and x86\n+\n+use tokio::time::{sleep, Duration, Instant};\n+\n+#[tokio::main]\n+async fn main() {\n+    let start = Instant::now();\n+    sleep(Duration::from_secs(1)).await;\n+    // It takes 96 millisecond to sleep for 1 millisecond\n+    // It takes 1025 millisecond to sleep for 1 second\n+    let time_elapsed = &start.elapsed().as_millis();\n+    assert!(time_elapsed > &1000, \"{}\", time_elapsed);\n+}"}, {"sha": "0bca7cc069a78310f7e2b94516a03d679846b92f", "filename": "src/tools/miri/tests/pass-dep/tokio/tokio_mvp.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/15b9f45cca87abf30415daefaa85218756e994ed/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Ftokio%2Ftokio_mvp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15b9f45cca87abf30415daefaa85218756e994ed/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Ftokio%2Ftokio_mvp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Ftokio%2Ftokio_mvp.rs?ref=15b9f45cca87abf30415daefaa85218756e994ed", "patch": "@@ -1,5 +1,5 @@\n // Need to disable preemption to stay on the supported MVP codepath in mio.\n-//@compile-flags: -Zmiri-disable-isolation -Zmiri-permissive-provenance -Zmiri-preemption-rate=0\n+//@compile-flags: -Zmiri-disable-isolation -Zmiri-permissive-provenance\n //@only-target-x86_64-unknown-linux: support for tokio exists only on linux and x86\n \n #[tokio::main]", "previous_filename": "src/tools/miri/tests/pass-dep/tokio_mvp.rs"}]}