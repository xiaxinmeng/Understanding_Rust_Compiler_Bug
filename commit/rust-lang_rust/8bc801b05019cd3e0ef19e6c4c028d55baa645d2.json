{"sha": "8bc801b05019cd3e0ef19e6c4c028d55baa645d2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhiYzgwMWIwNTAxOWNkM2UwZWYxOWU2YzRjMDI4ZDU1YmFhNjQ1ZDI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-08-09T12:31:03Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-08-09T12:31:03Z"}, "message": "Auto merge of #75293 - poliorcetics:intra-doc-links-std-path, r=jyn514\n\nMove to intra-doc links in library/std/src/path.rs\n\nHelps with #75080.\n\n@rustbot modify labels: T-doc, A-intra-doc-links, T-rustdoc\n\nKnown issue: The following links are broken (they are inside trait impls, undocumented in this file, inheriting from the original doc):\n\n- [`Hasher`]\n- [`Self`] (referencing `../primitive.slice.html`)\n- [`Ordering`]", "tree": {"sha": "d6708cbe04c59db42c19fdd47d7c71c4050f842f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d6708cbe04c59db42c19fdd47d7c71c4050f842f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8bc801b05019cd3e0ef19e6c4c028d55baa645d2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8bc801b05019cd3e0ef19e6c4c028d55baa645d2", "html_url": "https://github.com/rust-lang/rust/commit/8bc801b05019cd3e0ef19e6c4c028d55baa645d2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8bc801b05019cd3e0ef19e6c4c028d55baa645d2/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8e738539be23a62120059b5b4443f6c235f932b4", "url": "https://api.github.com/repos/rust-lang/rust/commits/8e738539be23a62120059b5b4443f6c235f932b4", "html_url": "https://github.com/rust-lang/rust/commit/8e738539be23a62120059b5b4443f6c235f932b4"}, {"sha": "6d77e40afe0b0337fa00832d50cdf6b3cd3dfbb9", "url": "https://api.github.com/repos/rust-lang/rust/commits/6d77e40afe0b0337fa00832d50cdf6b3cd3dfbb9", "html_url": "https://github.com/rust-lang/rust/commit/6d77e40afe0b0337fa00832d50cdf6b3cd3dfbb9"}], "stats": {"total": 196, "additions": 45, "deletions": 151}, "files": [{"sha": "a468f6b4b8d547dcfb89de10f153c81c678d8c0f", "filename": "library/std/src/path.rs", "status": "modified", "additions": 45, "deletions": 151, "changes": 196, "blob_url": "https://github.com/rust-lang/rust/blob/8bc801b05019cd3e0ef19e6c4c028d55baa645d2/library%2Fstd%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bc801b05019cd3e0ef19e6c4c028d55baa645d2/library%2Fstd%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fpath.rs?ref=8bc801b05019cd3e0ef19e6c4c028d55baa645d2", "patch": "@@ -56,16 +56,8 @@\n //! let path: PathBuf = [\"c:\\\\\", \"windows\", \"system32.dll\"].iter().collect();\n //! ```\n //!\n-//! [`Component`]: ../../std/path/enum.Component.html\n-//! [`components`]: ../../std/path/struct.Path.html#method.components\n-//! [`PathBuf`]: ../../std/path/struct.PathBuf.html\n-//! [`Path`]: ../../std/path/struct.Path.html\n-//! [`push`]: ../../std/path/struct.PathBuf.html#method.push\n-//! [`String`]: ../../std/string/struct.String.html\n-//!\n-//! [`str`]: ../../std/primitive.str.html\n-//! [`OsString`]: ../../std/ffi/struct.OsString.html\n-//! [`OsStr`]: ../../std/ffi/struct.OsStr.html\n+//! [`components`]: Path::components\n+//! [`push`]: PathBuf::push\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n@@ -390,12 +382,9 @@ enum State {\n /// # }\n /// ```\n ///\n-/// [`as_os_str`]: #method.as_os_str\n-/// [`Component`]: enum.Component.html\n-/// [`kind`]: #method.kind\n-/// [`OsStr`]: ../../std/ffi/struct.OsStr.html\n-/// [`Prefix` variant]: enum.Component.html#variant.Prefix\n-/// [`Prefix`]: enum.Prefix.html\n+/// [`as_os_str`]: PrefixComponent::as_os_str\n+/// [`kind`]: PrefixComponent::kind\n+/// [`Prefix` variant]: Component::Prefix\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[derive(Copy, Clone, Eq, Debug)]\n pub struct PrefixComponent<'a> {\n@@ -411,16 +400,12 @@ impl<'a> PrefixComponent<'a> {\n     ///\n     /// See [`Prefix`]'s documentation for more information on the different\n     /// kinds of prefixes.\n-    ///\n-    /// [`Prefix`]: enum.Prefix.html\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn kind(&self) -> Prefix<'a> {\n         self.parsed\n     }\n \n     /// Returns the raw [`OsStr`] slice for this prefix.\n-    ///\n-    /// [`OsStr`]: ../../std/ffi/struct.OsStr.html\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn as_os_str(&self) -> &'a OsStr {\n         self.raw\n@@ -477,10 +462,6 @@ impl Hash for PrefixComponent<'_> {\n ///     Component::Normal(\"bar.txt\".as_ref()),\n /// ]);\n /// ```\n-///\n-/// [`Components`]: struct.Components.html\n-/// [`Path`]: struct.Path.html\n-/// [`Path::components`]: struct.Path.html#method.components\n #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub enum Component<'a> {\n@@ -490,8 +471,6 @@ pub enum Component<'a> {\n     /// for more.\n     ///\n     /// Does not occur on Unix.\n-    ///\n-    /// [`Prefix`]: enum.Prefix.html\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     Prefix(#[stable(feature = \"rust1\", since = \"1.0.0\")] PrefixComponent<'a>),\n \n@@ -529,8 +508,6 @@ impl<'a> Component<'a> {\n     /// let components: Vec<_> = path.components().map(|comp| comp.as_os_str()).collect();\n     /// assert_eq!(&components, &[\".\", \"tmp\", \"foo\", \"bar.txt\"]);\n     /// ```\n-    ///\n-    /// [`OsStr`]: ../../std/ffi/struct.OsStr.html\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn as_os_str(self) -> &'a OsStr {\n         match self {\n@@ -574,9 +551,7 @@ impl AsRef<Path> for Component<'_> {\n /// }\n /// ```\n ///\n-/// [`Component`]: enum.Component.html\n-/// [`components`]: struct.Path.html#method.components\n-/// [`Path`]: struct.Path.html\n+/// [`components`]: Path::components\n #[derive(Clone)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Components<'a> {\n@@ -602,10 +577,7 @@ pub struct Components<'a> {\n /// This `struct` is created by the [`iter`] method on [`Path`].\n /// See its documentation for more.\n ///\n-/// [`Component`]: enum.Component.html\n-/// [`iter`]: struct.Path.html#method.iter\n-/// [`OsStr`]: ../../std/ffi/struct.OsStr.html\n-/// [`Path`]: struct.Path.html\n+/// [`iter`]: Path::iter\n #[derive(Clone)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Iter<'a> {\n@@ -1002,8 +974,7 @@ impl cmp::Ord for Components<'_> {\n /// }\n /// ```\n ///\n-/// [`ancestors`]: struct.Path.html#method.ancestors\n-/// [`Path`]: struct.Path.html\n+/// [`ancestors`]: Path::ancestors\n #[derive(Copy, Clone, Debug)]\n #[stable(feature = \"path_ancestors\", since = \"1.28.0\")]\n pub struct Ancestors<'a> {\n@@ -1034,11 +1005,8 @@ impl FusedIterator for Ancestors<'_> {}\n /// the path in place. It also implements [`Deref`] to [`Path`], meaning that\n /// all methods on [`Path`] slices are available on `PathBuf` values as well.\n ///\n-/// [`String`]: ../string/struct.String.html\n-/// [`Path`]: struct.Path.html\n-/// [`push`]: struct.PathBuf.html#method.push\n-/// [`set_extension`]: struct.PathBuf.html#method.set_extension\n-/// [`Deref`]: ../ops/trait.Deref.html\n+/// [`push`]: PathBuf::push\n+/// [`set_extension`]: PathBuf::set_extension\n ///\n /// More details about the overall approach can be found in\n /// the [module documentation](index.html).\n@@ -1127,17 +1095,14 @@ impl PathBuf {\n     /// assert_eq!(capacity, path.capacity());\n     /// ```\n     ///\n-    /// [`with_capacity`]: ../ffi/struct.OsString.html#method.with_capacity\n-    /// [`OsString`]: ../ffi/struct.OsString.html\n+    /// [`with_capacity`]: OsString::with_capacity\n     #[stable(feature = \"path_buf_capacity\", since = \"1.44.0\")]\n     pub fn with_capacity(capacity: usize) -> PathBuf {\n         PathBuf { inner: OsString::with_capacity(capacity) }\n     }\n \n     /// Coerces to a [`Path`] slice.\n     ///\n-    /// [`Path`]: struct.Path.html\n-    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -1224,8 +1189,7 @@ impl PathBuf {\n     /// Returns `false` and does nothing if [`self.parent`] is [`None`].\n     /// Otherwise, returns `true`.\n     ///\n-    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n-    /// [`self.parent`]: struct.PathBuf.html#method.parent\n+    /// [`self.parent`]: Path::parent\n     ///\n     /// # Examples\n     ///\n@@ -1259,9 +1223,8 @@ impl PathBuf {\n     /// `file_name`. The new path will be a sibling of the original path.\n     /// (That is, it will have the same parent.)\n     ///\n-    /// [`self.file_name`]: struct.PathBuf.html#method.file_name\n-    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n-    /// [`pop`]: struct.PathBuf.html#method.pop\n+    /// [`self.file_name`]: Path::file_name\n+    /// [`pop`]: PathBuf::pop\n     ///\n     /// # Examples\n     ///\n@@ -1297,9 +1260,8 @@ impl PathBuf {\n     /// If [`self.extension`] is [`None`], the extension is added; otherwise\n     /// it is replaced.\n     ///\n-    /// [`self.file_name`]: struct.PathBuf.html#method.file_name\n-    /// [`self.extension`]: struct.PathBuf.html#method.extension\n-    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n+    /// [`self.file_name`]: Path::file_name\n+    /// [`self.extension`]: Path::extension\n     ///\n     /// # Examples\n     ///\n@@ -1344,8 +1306,6 @@ impl PathBuf {\n \n     /// Consumes the `PathBuf`, yielding its internal [`OsString`] storage.\n     ///\n-    /// [`OsString`]: ../ffi/struct.OsString.html\n-    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -1360,9 +1320,6 @@ impl PathBuf {\n     }\n \n     /// Converts this `PathBuf` into a [boxed][`Box`] [`Path`].\n-    ///\n-    /// [`Box`]: ../../std/boxed/struct.Box.html\n-    /// [`Path`]: struct.Path.html\n     #[stable(feature = \"into_boxed_path\", since = \"1.20.0\")]\n     pub fn into_boxed_path(self) -> Box<Path> {\n         let rw = Box::into_raw(self.inner.into_boxed_os_str()) as *mut Path;\n@@ -1371,53 +1328,47 @@ impl PathBuf {\n \n     /// Invokes [`capacity`] on the underlying instance of [`OsString`].\n     ///\n-    /// [`capacity`]: ../ffi/struct.OsString.html#method.capacity\n-    /// [`OsString`]: ../ffi/struct.OsString.html\n+    /// [`capacity`]: OsString::capacity\n     #[stable(feature = \"path_buf_capacity\", since = \"1.44.0\")]\n     pub fn capacity(&self) -> usize {\n         self.inner.capacity()\n     }\n \n     /// Invokes [`clear`] on the underlying instance of [`OsString`].\n     ///\n-    /// [`clear`]: ../ffi/struct.OsString.html#method.clear\n-    /// [`OsString`]: ../ffi/struct.OsString.html\n+    /// [`clear`]: OsString::clear\n     #[stable(feature = \"path_buf_capacity\", since = \"1.44.0\")]\n     pub fn clear(&mut self) {\n         self.inner.clear()\n     }\n \n     /// Invokes [`reserve`] on the underlying instance of [`OsString`].\n     ///\n-    /// [`reserve`]: ../ffi/struct.OsString.html#method.reserve\n-    /// [`OsString`]: ../ffi/struct.OsString.html\n+    /// [`reserve`]: OsString::reserve\n     #[stable(feature = \"path_buf_capacity\", since = \"1.44.0\")]\n     pub fn reserve(&mut self, additional: usize) {\n         self.inner.reserve(additional)\n     }\n \n     /// Invokes [`reserve_exact`] on the underlying instance of [`OsString`].\n     ///\n-    /// [`reserve_exact`]: ../ffi/struct.OsString.html#method.reserve_exact\n-    /// [`OsString`]: ../ffi/struct.OsString.html\n+    /// [`reserve_exact`]: OsString::reserve_exact\n     #[stable(feature = \"path_buf_capacity\", since = \"1.44.0\")]\n     pub fn reserve_exact(&mut self, additional: usize) {\n         self.inner.reserve_exact(additional)\n     }\n \n     /// Invokes [`shrink_to_fit`] on the underlying instance of [`OsString`].\n     ///\n-    /// [`shrink_to_fit`]: ../ffi/struct.OsString.html#method.shrink_to_fit\n-    /// [`OsString`]: ../ffi/struct.OsString.html\n+    /// [`shrink_to_fit`]: OsString::shrink_to_fit\n     #[stable(feature = \"path_buf_capacity\", since = \"1.44.0\")]\n     pub fn shrink_to_fit(&mut self) {\n         self.inner.shrink_to_fit()\n     }\n \n     /// Invokes [`shrink_to`] on the underlying instance of [`OsString`].\n     ///\n-    /// [`shrink_to`]: ../ffi/struct.OsString.html#method.shrink_to\n-    /// [`OsString`]: ../ffi/struct.OsString.html\n+    /// [`shrink_to`]: OsString::shrink_to\n     #[unstable(feature = \"shrink_to\", issue = \"56431\")]\n     pub fn shrink_to(&mut self, min_capacity: usize) {\n         self.inner.shrink_to(min_capacity)\n@@ -1703,10 +1654,6 @@ impl AsRef<OsStr> for PathBuf {\n /// pointer like `&` or [`Box`]. For an owned version of this type,\n /// see [`PathBuf`].\n ///\n-/// [`str`]: ../primitive.str.html\n-/// [`Box`]: ../boxed/struct.Box.html\n-/// [`PathBuf`]: struct.PathBuf.html\n-///\n /// More details about the overall approach can be found in\n /// the [module documentation](index.html).\n ///\n@@ -1745,8 +1692,7 @@ pub struct Path {\n /// This `struct` is created by the [`strip_prefix`] method on [`Path`].\n /// See its documentation for more.\n ///\n-/// [`strip_prefix`]: struct.Path.html#method.strip_prefix\n-/// [`Path`]: struct.Path.html\n+/// [`strip_prefix`]: Path::strip_prefix\n #[derive(Debug, Clone, PartialEq, Eq)]\n #[stable(since = \"1.7.0\", feature = \"strip_prefix\")]\n pub struct StripPrefixError(());\n@@ -1791,8 +1737,6 @@ impl Path {\n \n     /// Yields the underlying [`OsStr`] slice.\n     ///\n-    /// [`OsStr`]: ../ffi/struct.OsStr.html\n-    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -1812,7 +1756,7 @@ impl Path {\n     /// Note that validation is performed because non-UTF-8 strings are\n     /// perfectly valid for some OS.\n     ///\n-    /// [`&str`]: ../primitive.str.html\n+    /// [`&str`]: str\n     ///\n     /// # Examples\n     ///\n@@ -1832,8 +1776,8 @@ impl Path {\n     /// Any non-Unicode sequences are replaced with\n     /// [`U+FFFD REPLACEMENT CHARACTER`][U+FFFD].\n     ///\n-    /// [`Cow<str>`]: ../borrow/enum.Cow.html\n-    /// [U+FFFD]: ../char/constant.REPLACEMENT_CHARACTER.html\n+    /// [`Cow<str>`]: Cow\n+    /// [U+FFFD]: super::char::REPLACEMENT_CHARACTER\n     ///\n     /// # Examples\n     ///\n@@ -1855,8 +1799,6 @@ impl Path {\n \n     /// Converts a `Path` to an owned [`PathBuf`].\n     ///\n-    /// [`PathBuf`]: struct.PathBuf.html\n-    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -1888,7 +1830,7 @@ impl Path {\n     /// assert!(!Path::new(\"foo.txt\").is_absolute());\n     /// ```\n     ///\n-    /// [`has_root`]: #method.has_root\n+    /// [`has_root`]: Path::has_root\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[allow(deprecated)]\n     pub fn is_absolute(&self) -> bool {\n@@ -1912,7 +1854,7 @@ impl Path {\n     /// assert!(Path::new(\"foo.txt\").is_relative());\n     /// ```\n     ///\n-    /// [`is_absolute`]: #method.is_absolute\n+    /// [`is_absolute`]: Path::is_absolute\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn is_relative(&self) -> bool {\n         !self.is_absolute()\n@@ -1947,8 +1889,6 @@ impl Path {\n     ///\n     /// Returns [`None`] if the path terminates in a root or prefix.\n     ///\n-    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n-    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -2001,8 +1941,7 @@ impl Path {\n     /// assert_eq!(ancestors.next(), None);\n     /// ```\n     ///\n-    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n-    /// [`parent`]: struct.Path.html#method.parent\n+    /// [`parent`]: Path::parent\n     #[stable(feature = \"path_ancestors\", since = \"1.28.0\")]\n     pub fn ancestors(&self) -> Ancestors<'_> {\n         Ancestors { next: Some(&self) }\n@@ -2015,8 +1954,6 @@ impl Path {\n     ///\n     /// Returns [`None`] if the path terminates in `..`.\n     ///\n-    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n-    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -2045,8 +1982,7 @@ impl Path {\n     /// If `base` is not a prefix of `self` (i.e., [`starts_with`]\n     /// returns `false`), returns [`Err`].\n     ///\n-    /// [`starts_with`]: #method.starts_with\n-    /// [`Err`]: ../../std/result/enum.Result.html#variant.Err\n+    /// [`starts_with`]: Path::starts_with\n     ///\n     /// # Examples\n     ///\n@@ -2132,7 +2068,7 @@ impl Path {\n \n     /// Extracts the stem (non-extension) portion of [`self.file_name`].\n     ///\n-    /// [`self.file_name`]: struct.Path.html#method.file_name\n+    /// [`self.file_name`]: Path::file_name\n     ///\n     /// The stem is:\n     ///\n@@ -2141,8 +2077,6 @@ impl Path {\n     /// * The entire file name if the file name begins with `.` and has no other `.`s within;\n     /// * Otherwise, the portion of the file name before the final `.`\n     ///\n-    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n-    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -2165,8 +2099,7 @@ impl Path {\n     /// * [`None`], if the file name begins with `.` and has no other `.`s within;\n     /// * Otherwise, the portion of the file name after the final `.`\n     ///\n-    /// [`self.file_name`]: struct.Path.html#method.file_name\n-    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n+    /// [`self.file_name`]: Path::file_name\n     ///\n     /// # Examples\n     ///\n@@ -2185,9 +2118,6 @@ impl Path {\n     ///\n     /// See [`PathBuf::push`] for more details on what it means to adjoin a path.\n     ///\n-    /// [`PathBuf`]: struct.PathBuf.html\n-    /// [`PathBuf::push`]: struct.PathBuf.html#method.push\n-    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -2211,9 +2141,6 @@ impl Path {\n     ///\n     /// See [`PathBuf::set_file_name`] for more details.\n     ///\n-    /// [`PathBuf`]: struct.PathBuf.html\n-    /// [`PathBuf::set_file_name`]: struct.PathBuf.html#method.set_file_name\n-    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -2240,9 +2167,6 @@ impl Path {\n     ///\n     /// See [`PathBuf::set_extension`] for more details.\n     ///\n-    /// [`PathBuf`]: struct.PathBuf.html\n-    /// [`PathBuf::set_extension`]: struct.PathBuf.html#method.set_extension\n-    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -2299,8 +2223,7 @@ impl Path {\n     /// assert_eq!(components.next(), None)\n     /// ```\n     ///\n-    /// [`Component`]: enum.Component.html\n-    /// [`CurDir`]: enum.Component.html#variant.CurDir\n+    /// [`CurDir`]: Component::CurDir\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn components(&self) -> Components<'_> {\n         let prefix = parse_prefix(self.as_os_str());\n@@ -2320,8 +2243,7 @@ impl Path {\n     /// For more information about the particulars of how the path is separated\n     /// into components, see [`components`].\n     ///\n-    /// [`components`]: #method.components\n-    /// [`OsStr`]: ../ffi/struct.OsStr.html\n+    /// [`components`]: Path::components\n     ///\n     /// # Examples\n     ///\n@@ -2343,7 +2265,7 @@ impl Path {\n     /// Returns an object that implements [`Display`] for safely printing paths\n     /// that may contain non-Unicode data.\n     ///\n-    /// [`Display`]: ../fmt/trait.Display.html\n+    /// [`Display`]: fmt::Display\n     ///\n     /// # Examples\n     ///\n@@ -2366,8 +2288,6 @@ impl Path {\n     ///\n     /// This is an alias to [`fs::metadata`].\n     ///\n-    /// [`fs::metadata`]: ../fs/fn.metadata.html\n-    ///\n     /// # Examples\n     ///\n     /// ```no_run\n@@ -2386,8 +2306,6 @@ impl Path {\n     ///\n     /// This is an alias to [`fs::symlink_metadata`].\n     ///\n-    /// [`fs::symlink_metadata`]: ../fs/fn.symlink_metadata.html\n-    ///\n     /// # Examples\n     ///\n     /// ```no_run\n@@ -2407,8 +2325,6 @@ impl Path {\n     ///\n     /// This is an alias to [`fs::canonicalize`].\n     ///\n-    /// [`fs::canonicalize`]: ../fs/fn.canonicalize.html\n-    ///\n     /// # Examples\n     ///\n     /// ```no_run\n@@ -2426,8 +2342,6 @@ impl Path {\n     ///\n     /// This is an alias to [`fs::read_link`].\n     ///\n-    /// [`fs::read_link`]: ../fs/fn.read_link.html\n-    ///\n     /// # Examples\n     ///\n     /// ```no_run\n@@ -2443,15 +2357,11 @@ impl Path {\n \n     /// Returns an iterator over the entries within a directory.\n     ///\n-    /// The iterator will yield instances of [`io::Result`]`<`[`DirEntry`]`>`. New\n+    /// The iterator will yield instances of [`io::Result`]`<`[`fs::DirEntry`]`>`. New\n     /// errors may be encountered after an iterator is initially constructed.\n     ///\n     /// This is an alias to [`fs::read_dir`].\n     ///\n-    /// [`io::Result`]: ../io/type.Result.html\n-    /// [`DirEntry`]: ../fs/struct.DirEntry.html\n-    /// [`fs::read_dir`]: ../fs/fn.read_dir.html\n-    ///\n     /// # Examples\n     ///\n     /// ```no_run\n@@ -2487,9 +2397,7 @@ impl Path {\n     /// # See Also\n     ///\n     /// This is a convenience function that coerces errors to false. If you want to\n-    /// check errors, call [fs::metadata].\n-    ///\n-    /// [fs::metadata]: ../../std/fs/fn.metadata.html\n+    /// check errors, call [`fs::metadata`].\n     #[stable(feature = \"path_ext\", since = \"1.5.0\")]\n     pub fn exists(&self) -> bool {\n         fs::metadata(self).is_ok()\n@@ -2514,20 +2422,14 @@ impl Path {\n     /// # See Also\n     ///\n     /// This is a convenience function that coerces errors to false. If you want to\n-    /// check errors, call [`fs::metadata`] and handle its Result. Then call\n-    /// [`fs::Metadata::is_file`] if it was Ok.\n+    /// check errors, call [`fs::metadata`] and handle its [`Result`]. Then call\n+    /// [`fs::Metadata::is_file`] if it was [`Ok`].\n     ///\n     /// When the goal is simply to read from (or write to) the source, the most\n     /// reliable way to test the source can be read (or written to) is to open\n     /// it. Only using `is_file` can break workflows like `diff <( prog_a )` on\n-    /// a Unix-like system for example. See [`File::open`] or\n-    /// [`OpenOptions::open`] for more information.\n-    ///\n-    /// [`fs::metadata`]: ../../std/fs/fn.metadata.html\n-    /// [`fs::Metadata`]: ../../std/fs/struct.Metadata.html\n-    /// [`fs::Metadata::is_file`]: ../../std/fs/struct.Metadata.html#method.is_file\n-    /// [`File::open`]: ../../std/fs/struct.File.html#method.open\n-    /// [`OpenOptions::open`]: ../../std/fs/struct.OpenOptions.html#method.open\n+    /// a Unix-like system for example. See [`fs::File::open`] or\n+    /// [`fs::OpenOptions::open`] for more information.\n     #[stable(feature = \"path_ext\", since = \"1.5.0\")]\n     pub fn is_file(&self) -> bool {\n         fs::metadata(self).map(|m| m.is_file()).unwrap_or(false)\n@@ -2552,21 +2454,15 @@ impl Path {\n     /// # See Also\n     ///\n     /// This is a convenience function that coerces errors to false. If you want to\n-    /// check errors, call [fs::metadata] and handle its Result. Then call\n-    /// [fs::Metadata::is_dir] if it was Ok.\n-    ///\n-    /// [fs::metadata]: ../../std/fs/fn.metadata.html\n-    /// [fs::Metadata::is_dir]: ../../std/fs/struct.Metadata.html#method.is_dir\n+    /// check errors, call [`fs::metadata`] and handle its [`Result`]. Then call\n+    /// [`fs::Metadata::is_dir`] if it was [`Ok`].\n     #[stable(feature = \"path_ext\", since = \"1.5.0\")]\n     pub fn is_dir(&self) -> bool {\n         fs::metadata(self).map(|m| m.is_dir()).unwrap_or(false)\n     }\n \n     /// Converts a [`Box<Path>`][`Box`] into a [`PathBuf`] without copying or\n     /// allocating.\n-    ///\n-    /// [`Box`]: ../../std/boxed/struct.Box.html\n-    /// [`PathBuf`]: struct.PathBuf.html\n     #[stable(feature = \"into_boxed_path\", since = \"1.20.0\")]\n     pub fn into_path_buf(self: Box<Path>) -> PathBuf {\n         let rw = Box::into_raw(self) as *mut OsStr;\n@@ -2605,10 +2501,8 @@ impl fmt::Debug for Path {\n /// println!(\"{}\", path.display());\n /// ```\n ///\n-/// [`Display`]: ../../std/fmt/trait.Display.html\n-/// [`format!`]: ../../std/macro.format.html\n-/// [`Path`]: struct.Path.html\n-/// [`Path::display`]: struct.Path.html#method.display\n+/// [`Display`]: fmt::Display\n+/// [`format!`]: crate::format\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Display<'a> {\n     path: &'a Path,"}]}