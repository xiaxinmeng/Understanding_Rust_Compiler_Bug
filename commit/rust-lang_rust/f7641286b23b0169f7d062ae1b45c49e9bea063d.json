{"sha": "f7641286b23b0169f7d062ae1b45c49e9bea063d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY3NjQxMjg2YjIzYjAxNjlmN2QwNjJhZTFiNDVjNDllOWJlYTA2M2Q=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-04-13T19:22:35Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-04-24T04:15:03Z"}, "message": "Allow classes to be cast to ifaces that are in the same crate\n\nI had to xfail one existing test case (class-implements-int) because,\nI think, of the same bug described in #2272.", "tree": {"sha": "2d7772215649468a8625aa66d8176b8670c758db", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2d7772215649468a8625aa66d8176b8670c758db"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f7641286b23b0169f7d062ae1b45c49e9bea063d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f7641286b23b0169f7d062ae1b45c49e9bea063d", "html_url": "https://github.com/rust-lang/rust/commit/f7641286b23b0169f7d062ae1b45c49e9bea063d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f7641286b23b0169f7d062ae1b45c49e9bea063d/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1c39fda0eaeb2f0e7bf37f0cac3541fb0cbc285f", "url": "https://api.github.com/repos/rust-lang/rust/commits/1c39fda0eaeb2f0e7bf37f0cac3541fb0cbc285f", "html_url": "https://github.com/rust-lang/rust/commit/1c39fda0eaeb2f0e7bf37f0cac3541fb0cbc285f"}], "stats": {"total": 724, "additions": 562, "deletions": 162}, "files": [{"sha": "31f216763313d8e4f0ebbe1398e63bfcba5c815e", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f7641286b23b0169f7d062ae1b45c49e9bea063d/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7641286b23b0169f7d062ae1b45c49e9bea063d/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=f7641286b23b0169f7d062ae1b45c49e9bea063d", "patch": "@@ -448,7 +448,7 @@ fn map<T, U>(v: [T], f: fn(T) -> U) -> [U] {\n }\n \n #[doc = \"\n-Apply a function eo each element of a vector and return a concatenation\n+Apply a function to each element of a vector and return a concatenation\n of each result vector\n \"]\n fn flat_map<T, U>(v: [T], f: fn(T) -> [U]) -> [U] {"}, {"sha": "55bb480761fa821abab8e15846986bd737be9ced", "filename": "src/librustsyntax/ast.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f7641286b23b0169f7d062ae1b45c49e9bea063d/src%2Flibrustsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7641286b23b0169f7d062ae1b45c49e9bea063d/src%2Flibrustsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Fast.rs?ref=f7641286b23b0169f7d062ae1b45c49e9bea063d", "patch": "@@ -636,6 +636,10 @@ enum attr_style { attr_outer, attr_inner, }\n #[auto_serialize]\n type attribute_ = {style: attr_style, value: meta_item};\n \n+/*\n+  iface_refs appear in both impls and in classes that implement ifaces.\n+  resolve maps each iface_ref's id to its defining iface.\n+ */\n #[auto_serialize]\n type iface_ref = {path: @path, id: node_id};\n \n@@ -661,14 +665,14 @@ enum item_ {\n              node_id /* dtor id */, node_id /* ctor id */,\n              region_param),\n     item_class([ty_param], /* ty params for class */\n-               [iface_ref],   /* ifaces this class implements */\n+               [@iface_ref],   /* ifaces this class implements */\n                [@class_member], /* methods, etc. */\n                                /* (not including ctor) */\n                class_ctor,\n                region_param\n                ),\n     item_iface([ty_param], [ty_method]),\n-    item_impl([ty_param], option<@ty> /* iface */,\n+    item_impl([ty_param], option<@iface_ref> /* iface */,\n               @ty /* self */, [@method]),\n }\n "}, {"sha": "8dd1b3c7feaac6e74b2b936204dc2ace84d268d5", "filename": "src/librustsyntax/ast_util.rs", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f7641286b23b0169f7d062ae1b45c49e9bea063d/src%2Flibrustsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7641286b23b0169f7d062ae1b45c49e9bea063d/src%2Flibrustsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Fast_util.rs?ref=f7641286b23b0169f7d062ae1b45c49e9bea063d", "patch": "@@ -2,20 +2,20 @@ import codemap::span;\n import ast::*;\n \n fn spanned<T: copy>(lo: uint, hi: uint, t: T) -> spanned<T> {\n-    ret respan(mk_sp(lo, hi), t);\n+    respan(mk_sp(lo, hi), t)\n }\n \n fn respan<T: copy>(sp: span, t: T) -> spanned<T> {\n-    ret {node: t, span: sp};\n+    {node: t, span: sp}\n }\n \n fn dummy_spanned<T: copy>(t: T) -> spanned<T> {\n-    ret respan(dummy_sp(), t);\n+    respan(dummy_sp(), t)\n }\n \n /* assuming that we're not in macro expansion */\n fn mk_sp(lo: uint, hi: uint) -> span {\n-    ret {lo: lo, hi: hi, expn_info: none};\n+    {lo: lo, hi: hi, expn_info: none}\n }\n \n // make this a const, once the compiler supports it\n@@ -334,6 +334,16 @@ impl inlined_item_methods for inlined_item {\n         }\n     }\n }\n+\n+/* True if d is either a def_self, or a chain of def_upvars\n+ referring to a def_self */\n+fn is_self(d: ast::def) -> bool {\n+  alt d {\n+    def_self(_)        { true }\n+    def_upvar(_, d, _) { is_self(*d) }\n+    _                  { false }\n+  }\n+}\n // Local Variables:\n // mode: rust\n // fill-column: 78;"}, {"sha": "e5c2c59a4d2f1d4adf5ceb5d0f1e6fac236317ae", "filename": "src/librustsyntax/fold.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f7641286b23b0169f7d062ae1b45c49e9bea063d/src%2Flibrustsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7641286b23b0169f7d062ae1b45c49e9bea063d/src%2Flibrustsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Ffold.rs?ref=f7641286b23b0169f7d062ae1b45c49e9bea063d", "patch": "@@ -279,9 +279,7 @@ fn noop_fold_item_underscore(i: item_, fld: ast_fold) -> item_ {\n               let ctor_id   = fld.new_id(ctor.node.id);\n               item_class(\n                   typms,\n-                  vec::map(ifaces, {|p|\n-                      {path: fld.fold_path(p.path),\n-                       id: fld.new_id(p.id)}}),\n+                  vec::map(ifaces, {|p| fold_iface_ref(p, fld) }),\n                   vec::map(items, fld.fold_class_item),\n                   {node: {body: ctor_body,\n                           dec: ctor_decl,\n@@ -290,7 +288,8 @@ fn noop_fold_item_underscore(i: item_, fld: ast_fold) -> item_ {\n                   rp)\n           }\n           item_impl(tps, ifce, ty, methods) {\n-            item_impl(tps, option::map(ifce, fld.fold_ty), fld.fold_ty(ty),\n+              item_impl(tps, option::map(ifce, {|p| fold_iface_ref(p, fld)}),\n+                        fld.fold_ty(ty),\n                       vec::map(methods, fld.fold_method))\n           }\n           item_iface(tps, methods) { item_iface(tps, methods) }\n@@ -305,6 +304,10 @@ fn noop_fold_item_underscore(i: item_, fld: ast_fold) -> item_ {\n         };\n }\n \n+fn fold_iface_ref(&&p: @iface_ref, fld: ast_fold) -> @iface_ref {\n+    @{path: fld.fold_path(p.path), id: fld.new_id(p.id)}\n+}\n+\n fn noop_fold_method(&&m: @method, fld: ast_fold) -> @method {\n     ret @{ident: fld.fold_ident(m.ident),\n           attrs: m.attrs,"}, {"sha": "5ce5c1480f594f5108729088ca4d0871bb201b40", "filename": "src/librustsyntax/parse/parser.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f7641286b23b0169f7d062ae1b45c49e9bea063d/src%2Flibrustsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7641286b23b0169f7d062ae1b45c49e9bea063d/src%2Flibrustsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Fparse%2Fparser.rs?ref=f7641286b23b0169f7d062ae1b45c49e9bea063d", "patch": "@@ -5,6 +5,7 @@ import token::{can_begin_expr, is_ident, is_plain_ident};\n import codemap::{span,fss_none};\n import util::interner;\n import ast_util::{spanned, mk_sp, ident_to_path};\n+import ast::{node_id};\n import lexer::reader;\n import prec::{op_spec, as_prec};\n import attr::{parse_outer_attrs_or_ext,\n@@ -1788,9 +1789,6 @@ fn parse_item_iface(p: parser, attrs: [ast::attribute]) -> @ast::item {\n //    impl name<T> for [T] { ... }\n fn parse_item_impl(p: parser, attrs: [ast::attribute]) -> @ast::item {\n     let lo = p.last_span.lo;\n-    fn wrap_path(p: parser, pt: @ast::path) -> @ast::ty {\n-        @{id: p.get_id(), node: ast::ty_path(pt, p.get_id()), span: pt.span}\n-    }\n     let mut (ident, tps) = if !is_word(p, \"of\") {\n         if p.token == token::LT { (none, parse_ty_params(p)) }\n         else { (some(parse_ident(p)), parse_ty_params(p)) }\n@@ -1800,7 +1798,7 @@ fn parse_item_impl(p: parser, attrs: [ast::attribute]) -> @ast::item {\n         if option::is_none(ident) {\n             ident = some(vec::last(path.idents));\n         }\n-        some(wrap_path(p, path))\n+        some(@{path: path, id: p.get_id()})\n     } else { none };\n     let ident = alt ident {\n         some(name) { name }\n@@ -1855,9 +1853,13 @@ fn ident_to_path_tys(p: parser, i: ast::ident,\n      }\n }\n \n-fn parse_iface_ref_list(p:parser) -> [ast::iface_ref] {\n+fn parse_iface_ref(p:parser) -> @ast::iface_ref {\n+    @{path: parse_path(p), id: p.get_id()}\n+}\n+\n+fn parse_iface_ref_list(p:parser) -> [@ast::iface_ref] {\n     parse_seq_to_before_end(token::LBRACE, seq_sep(token::COMMA),\n-                   {|p| {path: parse_path(p), id: p.get_id()}}, p)\n+                            parse_iface_ref, p)\n }\n \n fn parse_item_class(p: parser, attrs: [ast::attribute]) -> @ast::item {\n@@ -1866,7 +1868,7 @@ fn parse_item_class(p: parser, attrs: [ast::attribute]) -> @ast::item {\n     let rp = parse_region_param(p);\n     let ty_params = parse_ty_params(p);\n     let class_path = ident_to_path_tys(p, class_name, ty_params);\n-    let ifaces : [ast::iface_ref] = if eat_word(p, \"implements\")\n+    let ifaces : [@ast::iface_ref] = if eat_word(p, \"implements\")\n                                        { parse_iface_ref_list(p) }\n                                     else { [] };\n     expect(p, token::LBRACE);\n@@ -1918,7 +1920,7 @@ fn parse_single_class_item(p: parser, privcy: ast::privacy)\n enum class_contents { ctor_decl(ast::fn_decl, ast::blk, codemap::span),\n                       members([@ast::class_member]) }\n \n-fn parse_class_item(p:parser, class_name_with_tps:@ast::path)\n+fn parse_class_item(p:parser, class_name_with_tps: @ast::path)\n     -> class_contents {\n     if eat_word(p, \"new\") {\n         let lo = p.last_span.lo;"}, {"sha": "e7be554fca8231f08e5e6d982270bce279d2e204", "filename": "src/librustsyntax/print/pprust.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f7641286b23b0169f7d062ae1b45c49e9bea063d/src%2Flibrustsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7641286b23b0169f7d062ae1b45c49e9bea063d/src%2Flibrustsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Fprint%2Fpprust.rs?ref=f7641286b23b0169f7d062ae1b45c49e9bea063d", "patch": "@@ -561,14 +561,11 @@ fn print_item(s: ps, &&item: @ast::item) {\n         word(s.s, item.ident);\n         print_type_params(s, tps);\n         space(s.s);\n-        alt ifce {\n-          some(ty) {\n+        option::iter(ifce, {|p|\n             word_nbsp(s, \"of\");\n-            print_type(s, ty);\n+            print_path(s, p.path, false);\n             space(s.s);\n-          }\n-          _ {}\n-        }\n+            });\n         word_nbsp(s, \"for\");\n         print_type(s, ty);\n         space(s.s);"}, {"sha": "ad6b787f18068f817df1fe088431604892366909", "filename": "src/librustsyntax/visit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f7641286b23b0169f7d062ae1b45c49e9bea063d/src%2Flibrustsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7641286b23b0169f7d062ae1b45c49e9bea063d/src%2Flibrustsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Fvisit.rs?ref=f7641286b23b0169f7d062ae1b45c49e9bea063d", "patch": "@@ -134,7 +134,7 @@ fn visit_item<E>(i: @item, e: E, v: vt<E>) {\n       }\n       item_impl(tps, ifce, ty, methods) {\n         v.visit_ty_params(tps, e, v);\n-        alt ifce { some(ty) { v.visit_ty(ty, e, v); } none {} }\n+        option::iter(ifce, {|p| visit_path(p.path, e, v)});\n         v.visit_ty(ty, e, v);\n         for methods.each {|m|\n             visit_method_helper(m, e, v)"}, {"sha": "9ba99139b902609d8ed97e98a7751d929791c5cb", "filename": "src/rustc/metadata/csearch.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f7641286b23b0169f7d062ae1b45c49e9bea063d/src%2Frustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7641286b23b0169f7d062ae1b45c49e9bea063d/src%2Frustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fcsearch.rs?ref=f7641286b23b0169f7d062ae1b45c49e9bea063d", "patch": "@@ -160,8 +160,9 @@ fn get_field_type(tcx: ty::ctxt, class_id: ast::def_id,\n     ret {bounds: @[], rp: ast::rp_none, ty: ty};\n }\n \n-fn get_impl_iface(tcx: ty::ctxt, def: ast::def_id)\n-    -> option<ty::t> {\n+// Given a def_id for an impl or class, return the iface it implements,\n+// or none if it's not for an impl or for a class that implements ifaces\n+fn get_impl_iface(tcx: ty::ctxt, def: ast::def_id) -> option<ty::t> {\n     let cstore = tcx.sess.cstore;\n     let cdata = cstore::get_crate_data(cstore, def.crate);\n     decoder::get_impl_iface(cdata, def.node, tcx)"}, {"sha": "50a1093153b197dc27378baaf3d0f0e52ab1db3b", "filename": "src/rustc/metadata/decoder.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f7641286b23b0169f7d062ae1b45c49e9bea063d/src%2Frustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7641286b23b0169f7d062ae1b45c49e9bea063d/src%2Frustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fdecoder.rs?ref=f7641286b23b0169f7d062ae1b45c49e9bea063d", "patch": "@@ -27,7 +27,6 @@ export get_class_method;\n export get_impl_method;\n export lookup_def;\n export lookup_item_name;\n-export get_impl_iface;\n export resolve_path;\n export get_crate_attributes;\n export list_crate_metadata;\n@@ -157,11 +156,9 @@ fn item_impl_iface(item: ebml::doc, tcx: ty::ctxt, cdata: cmd)\n     -> option<ty::t> {\n     let mut result = none;\n     ebml::tagged_docs(item, tag_impl_iface) {|ity|\n-        let t = parse_ty_data(ity.data, cdata.cnum, ity.start, tcx, {|did|\n-            translate_def_id(cdata, did)\n-        });\n-        result = some(t);\n-    }\n+        result = some(parse_ty_data(ity.data, cdata.cnum, ity.start, tcx,\n+                             {|did| translate_def_id(cdata, did)}));\n+    };\n     result\n }\n "}, {"sha": "dc53c10e3b62f594da28366c1aacb48f74d6cacb", "filename": "src/rustc/metadata/encoder.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f7641286b23b0169f7d062ae1b45c49e9bea063d/src%2Frustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7641286b23b0169f7d062ae1b45c49e9bea063d/src%2Frustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fencoder.rs?ref=f7641286b23b0169f7d062ae1b45c49e9bea063d", "patch": "@@ -659,9 +659,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n         }\n         alt ifce {\n           some(t) {\n-            let i_ty = alt check t.node {\n-              ty_path(_, id) { ty::node_id_to_type(tcx, id) }\n-            };\n+            let i_ty = ty::node_id_to_type(tcx, t.id);\n             ebml_w.start_tag(tag_impl_iface);\n             write_type(ecx, ebml_w, i_ty);\n             ebml_w.end_tag();"}, {"sha": "2988cdc6f40a92c64d928b8007479c2ebf97209c", "filename": "src/rustc/middle/ast_map.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f7641286b23b0169f7d062ae1b45c49e9bea063d/src%2Frustc%2Fmiddle%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7641286b23b0169f7d062ae1b45c49e9bea063d/src%2Frustc%2Fmiddle%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fast_map.rs?ref=f7641286b23b0169f7d062ae1b45c49e9bea063d", "patch": "@@ -204,16 +204,16 @@ fn map_item(i: @item, cx: ctx, v: vt) {\n             cx.map.insert(nitem.id, node_native_item(nitem, abi, @cx.path));\n         }\n       }\n-      item_class(_, _, items, ctor, _) {\n+      item_class(tps, ifces, items, ctor, _) {\n+          let (_, ms) = ast_util::split_class_items(items);\n+          // Map iface refs to their parent classes. This is\n+          // so we can find the self_ty\n+          vec::iter(ifces) {|p| cx.map.insert(p.id,\n+                                  node_item(i, item_path)); };\n           let d_id = ast_util::local_def(i.id);\n           let p = extend(cx, i.ident);\n-          for items.each {|ci|\n            // only need to handle methods\n-           alt ci.node {\n-             class_method(m) { map_method(d_id, p, m, cx); }\n-             _ {}\n-           }\n-          }\n+          vec::iter(ms) {|m| map_method(d_id, p, m, cx); }\n       }\n       _ { }\n     }"}, {"sha": "c7ba313655e8b7d2f5ce35421d036cad2069aec3", "filename": "src/rustc/middle/resolve.rs", "status": "modified", "additions": 39, "deletions": 10, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/f7641286b23b0169f7d062ae1b45c49e9bea063d/src%2Frustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7641286b23b0169f7d062ae1b45c49e9bea063d/src%2Frustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fresolve.rs?ref=f7641286b23b0169f7d062ae1b45c49e9bea063d", "patch": "@@ -9,6 +9,7 @@ import metadata::{csearch, cstore};\n import driver::session::session;\n import util::common::*;\n import std::map::{int_hash, str_hash, hashmap};\n+import vec::each;\n import syntax::codemap::span;\n import syntax::visit;\n import visit::vt;\n@@ -402,6 +403,11 @@ fn maybe_insert(e: @env, id: node_id, def: option<def>) {\n     }\n }\n \n+fn resolve_iface_ref(p: @iface_ref, sc: scopes, e: @env) {\n+    maybe_insert(e, p.id,\n+       lookup_path_strict(*e, sc, p.path.span, p.path, ns_type));\n+}\n+\n fn resolve_names(e: @env, c: @ast::crate) {\n     e.used_imports.track = true;\n     let v =\n@@ -431,9 +437,10 @@ fn resolve_names(e: @env, c: @ast::crate) {\n         alt i.node {\n            ast::item_class(_, ifaces, _, _, _) {\n              /* visit the iface paths... */\n-             for ifaces.each {|p|\n-               maybe_insert(e, p.id,\n-                 lookup_path_strict(*e, sc, p.path.span, p.path, ns_type))};\n+              for ifaces.each {|p| resolve_iface_ref(p, sc, e)};\n+           }\n+           ast::item_impl(_, ifce, _, _) {\n+               option::iter(ifce, {|p| resolve_iface_ref(p, sc, e)});\n            }\n            _ {}\n         }\n@@ -535,7 +542,7 @@ fn visit_item_with_scope(e: @env, i: @ast::item, sc: scopes, v: vt<scopes>) {\n     alt i.node {\n       ast::item_impl(tps, ifce, sty, methods) {\n         visit::visit_ty_params(tps, sc, v);\n-        alt ifce { some(ty) { v.visit_ty(ty, sc, v); } _ {} }\n+        option::iter(ifce) {|p| visit::visit_path(p.path, sc, v)};\n         v.visit_ty(sty, sc, v);\n         for methods.each {|m|\n             v.visit_ty_params(m.tps, sc, v);\n@@ -1109,20 +1116,20 @@ fn lookup_in_scope(e: env, sc: scopes, sp: span, name: ident, ns: namespace,\n                 }\n                 ret some(df);\n             }\n-                      _ {}\n-                  }\n-             if left_fn {\n-                left_fn_level2 = true;\n-            } else if ns != ns_module {\n+            _ {}\n+        }\n+        if left_fn {\n+           left_fn_level2 = true;\n+        } else if ns != ns_module {\n                 left_fn = scope_is_fn(hd);\n                 alt scope_closes(hd) {\n                   some(node_id) { closing += [node_id]; }\n                   _ { }\n                 }\n             }\n             sc = *tl;\n-          }\n         }\n+      }\n     };\n }\n \n@@ -2103,6 +2110,8 @@ fn check_exports(e: @env) {\n // Impl resolution\n \n type method_info = {did: def_id, n_tps: uint, ident: ast::ident};\n+/* what are the did and ident here? */\n+/* ident = the name of the impl */\n type _impl = {did: def_id, ident: ast::ident, methods: [@method_info]};\n type iscopes = list<@[@_impl]>;\n \n@@ -2177,6 +2186,12 @@ fn find_impls_in_view_item(e: env, vi: @ast::view_item,\n     }\n }\n \n+/*\n+  Given an item <i>, adds one record to the mutable vec\n+  <impls> if the item is an impl; zero or more records if the\n+  item is a class; and none otherwise. Each record describes\n+  one interface implemented by i.\n+ */\n fn find_impls_in_item(e: env, i: @ast::item, &impls: [@_impl],\n                       name: option<ident>,\n                       ck_exports: option<@indexed_mod>) {\n@@ -2196,6 +2211,20 @@ fn find_impls_in_item(e: env, i: @ast::item, &impls: [@_impl],\n                         })}];\n         }\n       }\n+      ast::item_class(tps, ifces, items, _, _) {\n+          let (_, mthds) = ast_util::split_class_items(items);\n+          let n_tps = tps.len();\n+          vec::iter(ifces) {|p|\n+              // The def_id, in this case, identifies the combination of\n+              // class and iface\n+              impls += [@{did: local_def(p.id),\n+                         ident: i.ident,\n+                         methods: vec::map(mthds, {|m|\n+                                      @{did: local_def(m.id),\n+                                          n_tps: n_tps + m.tps.len(),\n+                                          ident: m.ident}})}];\n+          }\n+      }\n       _ {}\n     }\n }"}, {"sha": "9219fc8d1ab91c813603cb3414f792ada2ce186d", "filename": "src/rustc/middle/trans/alt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f7641286b23b0169f7d062ae1b45c49e9bea063d/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7641286b23b0169f7d062ae1b45c49e9bea063d/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs?ref=f7641286b23b0169f7d062ae1b45c49e9bea063d", "patch": "@@ -164,7 +164,7 @@ fn enter_opt(tcx: ty::ctxt, m: match, opt: opt, col: uint,\n         alt p.node {\n           ast::pat_enum(_, subpats) {\n             if opt_eq(tcx, variant_opt(tcx, p.id), opt) {\n-              some(option::get_or_default(subpats,\n+              some(option::get_default(subpats,\n                      vec::from_elem(variant_size, dummy))) }\n             else { none }\n           }"}, {"sha": "85e2cd851764cf06b921a0c01b6147cb3f85bdbe", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f7641286b23b0169f7d062ae1b45c49e9bea063d/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7641286b23b0169f7d062ae1b45c49e9bea063d/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=f7641286b23b0169f7d062ae1b45c49e9bea063d", "patch": "@@ -1963,7 +1963,7 @@ fn monomorphic_fn(ccx: @crate_ctxt, fn_id: ast::def_id, real_substs: [ty::t],\n     let mono_ty = ty::subst_tps(ccx.tcx, substs, item_ty);\n     let llfty = type_of_fn_from_ty(ccx, mono_ty);\n \n-    let depth = option::get_or_default(ccx.monomorphizing.find(fn_id), 0u);\n+    let depth = option::get_default(ccx.monomorphizing.find(fn_id), 0u);\n     // Random cut-off -- code that needs to instantiate the same function\n     // recursively more than ten times can probably safely be assumed to be\n     // causing an infinite expansion."}, {"sha": "8b1873247d31ebed0ec37951acc1170d3edb3f34", "filename": "src/rustc/middle/trans/impl.rs", "status": "modified", "additions": 15, "deletions": 7, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/f7641286b23b0169f7d062ae1b45c49e9bea063d/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7641286b23b0169f7d062ae1b45c49e9bea063d/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs?ref=f7641286b23b0169f7d062ae1b45c49e9bea063d", "patch": "@@ -5,13 +5,13 @@ import type_of::*;\n import build::*;\n import driver::session::session;\n import syntax::ast;\n-import syntax::ast_util::local_def;\n+import syntax::ast_util::{local_def, split_class_items};\n import metadata::csearch;\n import back::{link, abi};\n import lib::llvm::llvm;\n import lib::llvm::{ValueRef, TypeRef};\n import lib::llvm::llvm::LLVMGetParam;\n-import ast_map::{path, path_mod, path_name};\n+import ast_map::{path, path_mod, path_name, node_id_to_str};\n import std::map::hashmap;\n \n fn trans_impl(ccx: @crate_ctxt, path: path, name: ast::ident,\n@@ -82,12 +82,21 @@ fn trans_vtable_callee(bcx: block, env: callee_env, vtable: ValueRef,\n     {bcx: bcx, val: mptr, kind: owned, env: env}\n }\n \n+fn method_from_methods(ms: [@ast::method], name: ast::ident) -> ast::def_id {\n+  local_def(option::get(vec::find(ms, {|m| m.ident == name})).id)\n+}\n+\n fn method_with_name(ccx: @crate_ctxt, impl_id: ast::def_id,\n                     name: ast::ident) -> ast::def_id {\n     if impl_id.crate == ast::local_crate {\n         alt check ccx.tcx.items.get(impl_id.node) {\n           ast_map::node_item(@{node: ast::item_impl(_, _, _, ms), _}, _) {\n-            local_def(option::get(vec::find(ms, {|m| m.ident == name})).id)\n+            method_from_methods(ms, name)\n+          }\n+          ast_map::node_item(@{node:\n+               ast::item_class(_, _, items, _, _), _}, _) {\n+            let (_,ms) = split_class_items(items);\n+            method_from_methods(ms, name)\n           }\n         }\n     } else {\n@@ -245,9 +254,8 @@ fn make_impl_vtable(ccx: @crate_ctxt, impl_id: ast::def_id, substs: [ty::t],\n     let tcx = ccx.tcx;\n     let ifce_id = ty::ty_to_def_id(option::get(ty::impl_iface(tcx, impl_id)));\n     let has_tps = (*ty::lookup_item_type(ccx.tcx, impl_id).bounds).len() > 0u;\n-    make_vtable(ccx, vec::map(*ty::iface_methods(tcx, ifce_id), {|im|\n-        let fty = ty::subst_tps(tcx, substs,\n-                                             ty::mk_fn(tcx, im.fty));\n+    make_vtable(ccx, vec::map(*ty::iface_methods(tcx, ifce_id)) {|im|\n+        let fty = ty::subst_tps(tcx, substs, ty::mk_fn(tcx, im.fty));\n         if (*im.tps).len() > 0u || ty::type_has_vars(fty) {\n             C_null(T_ptr(T_nil()))\n         } else {\n@@ -260,7 +268,7 @@ fn make_impl_vtable(ccx: @crate_ctxt, impl_id: ast::def_id, substs: [ty::t],\n                 trans_external_path(ccx, m_id, fty)\n             }\n         }\n-    }))\n+    })\n }\n \n fn trans_cast(bcx: block, val: @ast::expr, id: ast::node_id, dest: dest)"}, {"sha": "2d5a68d08ab8d10032b6e147f8cc15a30120201b", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 29, "deletions": 7, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/f7641286b23b0169f7d062ae1b45c49e9bea063d/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7641286b23b0169f7d062ae1b45c49e9bea063d/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=f7641286b23b0169f7d062ae1b45c49e9bea063d", "patch": "@@ -1326,6 +1326,17 @@ fn type_kind(cx: ctxt, ty: t) -> kind {\n         }\n         lowest\n       }\n+      // FIXME: (tjc) there are rules about when classes are copyable/\n+      // sendable, but I'm just treating them like records (#1726)\n+      ty_class(did, substs) {\n+          // also factor out this code, copied from the records case\n+          let mut lowest = kind_sendable;\n+          let flds = class_items_as_fields(cx, did, substs);\n+          for flds.each {|f|\n+            lowest = lower_kind(lowest, type_kind(cx, f.mt.ty));\n+          }\n+          lowest\n+      }\n       // Tuples lower to the lowest of their members.\n       ty_tup(tys) {\n         let mut lowest = kind_sendable;\n@@ -1356,7 +1367,6 @@ fn type_kind(cx: ctxt, ty: t) -> kind {\n           param_bounds_to_kind(cx.ty_param_bounds.get(did.node))\n       }\n       ty_constr(t, _) { type_kind(cx, t) }\n-      ty_class(_, _) { fail \"FIXME\"; }\n       ty_var(_) { fail \"FIXME\"; }\n       ty_self(_) { kind_noncopyable }\n     };\n@@ -2248,12 +2258,24 @@ fn iface_methods(cx: ctxt, id: ast::def_id) -> @[method] {\n \n fn impl_iface(cx: ctxt, id: ast::def_id) -> option<t> {\n     if id.crate == ast::local_crate {\n-        alt cx.items.get(id.node) {\n-          ast_map::node_item(@{node: ast::item_impl(\n-              _, some(@{node: ast::ty_path(_, id), _}), _, _), _}, _) {\n-            some(node_id_to_type(cx, id))\n-          }\n-          _ { none }\n+        alt cx.items.find(id.node) {\n+           some(ast_map::node_item(@{node: ast::item_impl(\n+              _, some(@{id: id, _}), _, _), _}, _)) {\n+              some(node_id_to_type(cx, id))\n+           }\n+           some(ast_map::node_item(@{node: ast::item_class(_, _, _, _, _),\n+                           _},_)) {\n+             alt cx.def_map.find(id.node) {\n+               some(def_ty(iface_id)) {\n+                   some(node_id_to_type(cx, id.node))\n+               }\n+               _ {\n+                 cx.sess.bug(\"impl_iface: iface ref isn't in iface map \\\n+                         and isn't bound to a def_ty\");\n+               }\n+             }\n+           }\n+           _ { none }\n         }\n     } else {\n         csearch::get_impl_iface(cx, id)"}, {"sha": "78fefd3d2369c1e6a7dae878780d3c5e3765ba49", "filename": "src/rustc/middle/typeck.rs", "status": "modified", "additions": 146, "deletions": 88, "changes": 234, "blob_url": "https://github.com/rust-lang/rust/blob/f7641286b23b0169f7d062ae1b45c49e9bea063d/src%2Frustc%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7641286b23b0169f7d062ae1b45c49e9bea063d/src%2Frustc%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck.rs?ref=f7641286b23b0169f7d062ae1b45c49e9bea063d", "patch": "@@ -20,6 +20,7 @@ import std::map;\n import std::map::{hashmap, int_hash};\n import std::serialization::{serialize_uint, deserialize_uint};\n import std::ufind;\n+import vec::each;\n import syntax::print::pprust::*;\n import util::common::indent;\n import std::list;\n@@ -43,10 +44,27 @@ type method_map = hashmap<ast::node_id, method_origin>;\n \n // Resolutions for bounds of all parameters, left to right, for a given path.\n type vtable_res = @[vtable_origin];\n+\n enum vtable_origin {\n+    /*\n+      Statically known vtable. def_id gives the class or impl item\n+      from whence comes the vtable, and tys are the type substs.\n+      vtable_res is the vtable itself\n+     */\n     vtable_static(ast::def_id, [ty::t], vtable_res),\n-    // Param number, bound number\n+    /*\n+      Dynamic vtable, comes from a parameter that has a bound on it:\n+      fn foo<T: quux, baz, bar>(a: T) -- a's vtable would have a\n+      vtable_param origin\n+\n+      The first uint is the param number (identifying T in the example),\n+      and the second is the bound number (identifying baz)\n+     */\n     vtable_param(uint, uint),\n+    /*\n+      Dynamic vtable, comes from something known to have an interface\n+      type. def_id refers to the iface item, tys are the substs\n+     */\n     vtable_iface(ast::def_id, [ty::t]),\n }\n \n@@ -119,12 +137,12 @@ type fn_ctxt =\n \n // Determines whether the given node ID is a use of the def of\n // the self ID for the current method, if there is one\n+// self IDs in an outer scope count. so that means that you can\n+// call your own private methods from nested functions inside\n+// class methods\n fn self_ref(fcx: @fn_ctxt, id: ast::node_id) -> bool {\n-    // check what def `id` was resolved to (if anything)\n-    alt fcx.ccx.tcx.def_map.find(id) {\n-      some(ast::def_self(_)) { true }\n-      _ { false }\n-    }\n+    option::map_default(fcx.ccx.tcx.def_map.find(id), false,\n+                        ast_util::is_self)\n }\n \n fn lookup_local(fcx: @fn_ctxt, sp: span, id: ast::node_id) -> ty_vid {\n@@ -465,19 +483,7 @@ fn ast_region_to_region<AC: ast_conv, RS: region_scope>(\n     get_region_reporting_err(self.tcx(), span, res)\n }\n \n-// Parses the programmer's textual representation of a type into our\n-// internal notion of a type. `getter` is a function that returns the type\n-// corresponding to a definition ID:\n-fn ast_ty_to_ty<AC: ast_conv, RS: region_scope copy>(\n-    self: AC, rscope: RS, &&ast_ty: @ast::ty) -> ty::t {\n-\n-    fn ast_mt_to_mt<AC: ast_conv, RS: region_scope copy>(\n-        self: AC, rscope: RS, mt: ast::mt) -> ty::mt {\n-\n-        ret {ty: ast_ty_to_ty(self, rscope, mt.ty), mutbl: mt.mutbl};\n-    }\n-\n-    fn instantiate<AC: ast_conv, RS: region_scope copy>(\n+fn instantiate<AC: ast_conv, RS: region_scope copy>(\n         self: AC, rscope: RS, sp: span, id: ast::def_id,\n         path_id: ast::node_id, args: [@ast::ty]) -> ty::t {\n \n@@ -511,6 +517,40 @@ fn ast_ty_to_ty<AC: ast_conv, RS: region_scope copy>(\n         let ty = ty::subst(tcx, substs, ty);\n         write_substs_to_tcx(tcx, path_id, substs.tps);\n         ret ty;\n+}\n+\n+/*\n+  Instantiates the path for the given iface reference, assuming that\n+  it's bound to a valid iface type. Returns the def_id for the defining\n+  iface\n+ */\n+fn instantiate_iface_ref(ccx: @crate_ctxt, t: @ast::iface_ref)\n+    -> ast::def_id {\n+    alt lookup_def_tcx(ccx.tcx, t.path.span, t.id) {\n+       ast::def_ty(t_id) {\n+         // tjc: will probably need to refer to\n+         // impl or class ty params too\n+         instantiate(ccx, empty_rscope, t.path.span, t_id, t.id,\n+                     t.path.types);\n+         t_id\n+       }\n+       _ {\n+          ccx.tcx.sess.span_fatal(t.path.span,\n+                     \"can only implement interface types\");\n+       }\n+    }\n+}\n+\n+// Parses the programmer's textual representation of a type into our\n+// internal notion of a type. `getter` is a function that returns the type\n+// corresponding to a definition ID:\n+fn ast_ty_to_ty<AC: ast_conv, RS: region_scope copy>(\n+    self: AC, rscope: RS, &&ast_ty: @ast::ty) -> ty::t {\n+\n+    fn ast_mt_to_mt<AC: ast_conv, RS: region_scope copy>(\n+        self: AC, rscope: RS, mt: ast::mt) -> ty::mt {\n+\n+        ret {ty: ast_ty_to_ty(self, rscope, mt.ty), mutbl: mt.mutbl};\n     }\n \n     fn mk_bounded<AC: ast_conv, RS: region_scope copy>(\n@@ -1169,6 +1209,7 @@ fn mk_substs(ccx: @crate_ctxt, atps: [ast::ty_param], rp: ast::region_param)\n fn compare_impl_method(tcx: ty::ctxt, sp: span, impl_m: ty::method,\n                        impl_tps: uint, if_m: ty::method, substs: [ty::t],\n                        self_ty: ty::t) -> ty::t {\n+\n     if impl_m.tps != if_m.tps {\n         tcx.sess.span_err(sp, \"method `\" + if_m.ident +\n                           \"` has an incompatible set of type parameters\");\n@@ -1371,39 +1412,37 @@ mod collect {\n                                    tps: [ast::ty_param],\n                                    rp: ast::region_param,\n                                    selfty: ty::t,\n-                                   t: @ast::ty,\n-                                   ms: [@ast::method]) {\n+                                   t: @ast::iface_ref,\n+                                   ms: [@ast::method]) -> ast::def_id {\n \n         let tcx = ccx.tcx;\n         let i_bounds = ty_param_bounds(ccx, tps);\n         let my_methods = convert_methods(ccx, ms, rp, i_bounds, selfty);\n-        let iface_ty = ccx.to_ty(empty_rscope, t);\n-        alt ty::get(iface_ty).struct {\n-          ty::ty_iface(did, tys) {\n-            // Store the iface type in the type node\n-            alt check t.node {\n-              ast::ty_path(_, t_id) {\n-                write_ty_to_tcx(tcx, t_id, iface_ty);\n-              }\n-            }\n-            if did.crate == ast::local_crate {\n-                ensure_iface_methods(ccx, did.node);\n-            }\n-            for vec::each(*ty::iface_methods(tcx, did)) {|if_m|\n-                alt vec::find(my_methods,\n-                              {|m| if_m.ident == m.mty.ident}) {\n-                  some({mty: m, id, span}) {\n-                    if m.purity != if_m.purity {\n-                        ccx.tcx.sess.span_err(\n-                            span, #fmt[\"method `%s`'s purity \\\n+        let did = instantiate_iface_ref(ccx, t);\n+        // not sure whether it's correct to use empty_rscope\n+        // -- tjc\n+        let tys = vec::map(t.path.types,\n+                           {|t| ccx.to_ty(empty_rscope,t)});\n+        // Store the iface type in the type node\n+        write_ty_to_tcx(tcx, t.id, ty::mk_iface(ccx.tcx, did, tys));\n+        if did.crate == ast::local_crate {\n+            ensure_iface_methods(ccx, did.node);\n+        }\n+        for vec::each(*ty::iface_methods(tcx, did)) {|if_m|\n+           alt vec::find(my_methods,\n+              {|m| if_m.ident == m.mty.ident}) {\n+             some({mty: m, id, span}) {\n+                 if m.purity != if_m.purity {\n+                         ccx.tcx.sess.span_err(\n+                           span, #fmt[\"method `%s`'s purity \\\n                                         not match the iface method's \\\n                                         purity\", m.ident]);\n-                    }\n-                    let mt = compare_impl_method(\n+                 }\n+                 let mt = compare_impl_method(\n                         ccx.tcx, span, m, vec::len(tps),\n                         if_m, tys, selfty);\n-                    let old = tcx.tcache.get(local_def(id));\n-                    if old.ty != mt {\n+                 let old = tcx.tcache.get(local_def(id));\n+                 if old.ty != mt {\n                         tcx.tcache.insert(\n                             local_def(id),\n                             {bounds: old.bounds,\n@@ -1412,27 +1451,24 @@ mod collect {\n                         write_ty_to_tcx(tcx, id, mt);\n                     }\n                   }\n-                  none {\n-                    tcx.sess.span_err(t.span, \"missing method `\" +\n+             none {\n+               tcx.sess.span_err(t.path.span, \"missing method `\" +\n                                       if_m.ident + \"`\");\n-                  }\n-                } // alt\n-            } // |if_m|\n-          } // for\n-          _ {\n-            tcx.sess.span_fatal(t.span, \"can only implement \\\n-                                         interface types\");\n-        }\n-      }\n-    }\n+             }\n+           } // alt\n+        } // |if_m|\n+        did\n+    } // fn\n \n     fn convert_class_item(ccx: @crate_ctxt,\n                           rp: ast::region_param,\n                           v: ast_util::ivar) {\n+        /* we want to do something here, b/c within the\n+         scope of the class, it's ok to refer to fields &\n+        methods unqualified */\n         /* they have these types *within the scope* of the\n          class. outside the class, it's done with expr_field */\n         let tt = ccx.to_ty(type_rscope(rp), v.ty);\n-        #debug(\"convert_class_item: %s %?\", v.ident, v.id);\n         write_ty_to_tcx(ccx.tcx, v.id, tt);\n     }\n \n@@ -1485,7 +1521,7 @@ mod collect {\n                                ty: selfty});\n             alt ifce {\n               some(t) {\n-                check_methods_against_iface(\n+                  check_methods_against_iface(\n                     ccx, tps, ast::rp_none, // NDM iface/impl regions\n                     selfty, t, ms);\n               }\n@@ -1569,29 +1605,16 @@ mod collect {\n             that it claims to implement.\n             */\n             for ifaces.each { |ifce|\n-                alt lookup_def_tcx(tcx, it.span, ifce.id) {\n-                  ast::def_ty(t_id) {\n-                    let t = ty::lookup_item_type(tcx, t_id).ty;\n-                    alt ty::get(t).struct {\n-                      ty::ty_iface(_,_) {\n-                        write_ty_to_tcx(tcx, ifce.id, t);\n-                        check_methods_against_iface(\n-                            ccx, tps, rp, selfty,\n-                            @{id: ifce.id,\n-                              node: ast::ty_path(ifce.path, ifce.id),\n-                              span: ifce.path.span},\n-                            methods);\n-                      }\n-                      _ {\n-                        tcx.sess.span_fatal(\n-                            ifce.path.span,\n-                            \"can only implement interface types\");\n-                      }\n-                    }\n-                  }\n-                  _ { tcx.sess.span_err(ifce.path.span, \"not an interface \\\n-                                                         type\"); }\n-                }\n+                let t_id = check_methods_against_iface(ccx, tps, rp, selfty,\n+                                                       ifce, methods);\n+                // FIXME: This assumes classes only implement\n+                // non-parameterized ifaces. add a test case for\n+                // a class implementing a parameterized iface.\n+                // -- tjc (#1726)\n+                let t = ty::mk_iface(tcx, t_id, []);\n+                write_ty_to_tcx(tcx, ifce.id, t);\n+                // FIXME: likewise, assuming no bounds -- tjc\n+                tcx.tcache.insert(local_def(ifce.id), no_params(t));\n             }\n           }\n           _ {\n@@ -1601,7 +1624,7 @@ mod collect {\n             let tpt = ty_of_item(ccx, it);\n             write_ty_to_tcx(tcx, it.id, tpt.ty);\n           }\n-        }\n+       }\n     }\n     fn convert_native(ccx: @crate_ctxt, i: @ast::native_item) {\n         // As above, this call populates the type table with the converted\n@@ -1696,8 +1719,7 @@ fn require_same_types(\n     alt infer::compare_tys(tcx, t1, t2) {\n       result::ok(()) { true }\n       result::err(terr) {\n-        tcx.sess.span_err(\n-            span, msg() + \": \" +\n+        tcx.sess.span_err(span, msg() + \": \" +\n             ty::type_err_to_str(tcx, terr));\n         false\n       }\n@@ -2368,12 +2390,28 @@ fn impl_self_ty(fcx: @fn_ctxt, did: ast::def_id) -> ty_param_substs_and_ty {\n     let tcx = fcx.ccx.tcx;\n \n     let {n_tps, raw_ty} = if did.crate == ast::local_crate {\n-        alt check tcx.items.get(did.node) {\n-          ast_map::node_item(@{node: ast::item_impl(ts, _, st, _),\n-                               _}, _) {\n-            {n_tps: vec::len(ts),\n+        alt check tcx.items.find(did.node) {\n+          some(ast_map::node_item(@{node: ast::item_impl(ts, _, st, _),\n+                                _}, _)) {\n+            {n_tps: ts.len(),\n              raw_ty: fcx.to_ty(st)}\n           }\n+          // Node doesn't map to an impl. It might map to a class.\n+          some(ast_map::node_item(@{node: ast::item_class(ts,\n+                                    _,_,_,rp), id: class_id, _},_)) {\n+              /* If the impl is a class, the self ty is just the class ty\n+                 (doing a no-op subst for the ty params; in the next step,\n+                 we substitute in fresh vars for them)\n+               */\n+              {n_tps: ts.len(),\n+               raw_ty: ty::mk_class(tcx, local_def(class_id),\n+                      {self_r: alt rp {\n+                          ast::rp_self { some(fcx.next_region_var()) }\n+                          ast::rp_none { none }},\n+                      tps: ty::ty_params_to_tys(tcx, ts)})}\n+          }\n+          _ { tcx.sess.bug(\"impl_self_ty: unbound item or item that \\\n+               doesn't have a self_ty\"); }\n         }\n     } else {\n         let ity = ty::lookup_item_type(tcx, did);\n@@ -4300,6 +4338,8 @@ fn check_item(ccx: @crate_ctxt, it: @ast::item) {\n           check_bare_fn(class_ccx, ctor.node.dec,\n                         ctor.node.body, ctor.node.id,\n                         some(class_t));\n+          // Write the ctor's self's type\n+          write_ty_to_tcx(tcx, ctor.node.self_id, class_t);\n \n           // typecheck the members\n           for members.each {|m| check_class_member(class_ccx, class_t, m); }\n@@ -4403,6 +4443,10 @@ mod vtable {\n         @result\n     }\n \n+    /*\n+      Look up the vtable to use when treating an item of type <t>\n+      as if it has type <iface_ty>\n+     */\n     fn lookup_vtable(fcx: @fn_ctxt, isc: resolve::iscopes, sp: span,\n                      ty: ty::t, iface_ty: ty::t, allow_unsafe: bool)\n         -> vtable_origin {\n@@ -4449,14 +4493,17 @@ mod vtable {\n             for list::each(isc) {|impls|\n                 let mut found = none;\n                 for vec::each(*impls) {|im|\n+                    /* What iface does this item implement? */\n                     let match = alt ty::impl_iface(tcx, im.did) {\n                       some(ity) {\n                         alt check ty::get(ity).struct {\n+                        /* Does it match the one we're searching for? */\n                           ty::ty_iface(id, _) { id == iface_id }\n                         }\n                       }\n                       _ { false }\n                     };\n+                    /* Found a matching iface */\n                     if match {\n                         let {substs: substs, ty: self_ty} =\n                             impl_self_ty(fcx, im.did);\n@@ -4566,10 +4613,21 @@ mod vtable {\n             let target_ty = fcx.expr_ty(ex);\n             alt ty::get(target_ty).struct {\n               ty::ty_iface(_, _) {\n+               /* Casting to an interface type.\n+                  Look up all impls for the cast expr...\n+               */\n                 let impls = cx.impl_map.get(ex.id);\n+                /*\n+                  Look up vtables for the type we're casting to,\n+                  passing in the source and target type\n+                 */\n                 let vtable = lookup_vtable(fcx, impls, ex.span,\n                                            fcx.expr_ty(src), target_ty,\n                                            true);\n+                /*\n+                  Map this expression to that vtable (that is: \"ex has\n+                  vtable <vtable>\")\n+                 */\n                 cx.vtable_map.insert(ex.id, @[vtable]);\n               }\n               _ {}"}, {"sha": "58f147ca6ff205a0d9efe77fc19571f97c0fe937", "filename": "src/rustdoc/tystr_pass.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f7641286b23b0169f7d062ae1b45c49e9bea063d/src%2Frustdoc%2Ftystr_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7641286b23b0169f7d062ae1b45c49e9bea063d/src%2Frustdoc%2Ftystr_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Ftystr_pass.rs?ref=f7641286b23b0169f7d062ae1b45c49e9bea063d", "patch": "@@ -249,8 +249,8 @@ fn fold_impl(\n           ast_map::node_item(@{\n             node: ast::item_impl(_, iface_ty, self_ty, _), _\n           }, _) {\n-            let iface_ty = option::map(iface_ty) {|iface_ty|\n-                pprust::ty_to_str(iface_ty)\n+            let iface_ty = option::map(iface_ty) {|p|\n+                pprust::path_to_str(p.path)\n             };\n             (iface_ty, some(pprust::ty_to_str(self_ty)))\n           }"}, {"sha": "faebae34694379bf509a7c765480c3f6337b632e", "filename": "src/test/compile-fail/class-cast-to-iface.rs", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/f7641286b23b0169f7d062ae1b45c49e9bea063d/src%2Ftest%2Fcompile-fail%2Fclass-cast-to-iface.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7641286b23b0169f7d062ae1b45c49e9bea063d/src%2Ftest%2Fcompile-fail%2Fclass-cast-to-iface.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fclass-cast-to-iface.rs?ref=f7641286b23b0169f7d062ae1b45c49e9bea063d", "patch": "@@ -0,0 +1,42 @@\n+// error-pattern: attempted access of field eat on type noisy\n+iface noisy {\n+  fn speak();\n+}\n+\n+class cat implements noisy {\n+  priv {\n+    let mut meows : uint;\n+    fn meow() {\n+      #error(\"Meow\");\n+      self.meows += 1u;\n+      if self.meows % 5u == 0u {\n+          self.how_hungry += 1;\n+      }\n+    }\n+  }\n+\n+  let mut how_hungry : int;\n+  let name : str;\n+\n+  new(in_x : uint, in_y : int, in_name: str)\n+    { self.meows = in_x; self.how_hungry = in_y; self.name = in_name; }\n+\n+  fn speak() { self.meow(); }\n+\n+  fn eat() -> bool {\n+    if self.how_hungry > 0 {\n+        #error(\"OM NOM NOM\");\n+        self.how_hungry -= 2;\n+        ret true;\n+    }\n+    else {\n+        #error(\"Not hungry!\");\n+        ret false;\n+    }\n+  }\n+}\n+\n+fn main() {\n+  let nyan : noisy  = cat(0u, 2, \"nyan\") as noisy;\n+  nyan.eat();\n+}\n\\ No newline at end of file"}, {"sha": "70eca5e07425d5c9ac178f624e3111896d03edb6", "filename": "src/test/compile-fail/class-implements-int.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f7641286b23b0169f7d062ae1b45c49e9bea063d/src%2Ftest%2Fcompile-fail%2Fclass-implements-int.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7641286b23b0169f7d062ae1b45c49e9bea063d/src%2Ftest%2Fcompile-fail%2Fclass-implements-int.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fclass-implements-int.rs?ref=f7641286b23b0169f7d062ae1b45c49e9bea063d", "patch": "@@ -1,5 +1,11 @@\n-// error-pattern:not an interface type\n-class cat implements int {\n+// xfail-test\n+/*\n+  tjc: currently this results in a memory leak after a call to\n+  span_fatal in typeck. I think it's the same issue as #2272, because\n+  if I make type_needs_unwind_cleanup always return true, the test passes.\n+  FIXME: Un-xfail this when #2272 is fixed.\n+ */\n+class cat implements int { //! ERROR can only implement interface types\n   let meows: uint;\n   new(in_x : uint) { self.meows = in_x; }\n }"}, {"sha": "d9129fae8048b5b967791dd82549064f3d4c2dcd", "filename": "src/test/run-pass/class-cast-to-iface-multiple-types.rs", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/f7641286b23b0169f7d062ae1b45c49e9bea063d/src%2Ftest%2Frun-pass%2Fclass-cast-to-iface-multiple-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7641286b23b0169f7d062ae1b45c49e9bea063d/src%2Ftest%2Frun-pass%2Fclass-cast-to-iface-multiple-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-cast-to-iface-multiple-types.rs?ref=f7641286b23b0169f7d062ae1b45c49e9bea063d", "patch": "@@ -0,0 +1,64 @@\n+iface noisy {\n+  fn speak() -> int;\n+}\n+\n+class dog implements noisy {\n+  priv {\n+    let barks : @mut uint;\n+    fn bark() -> int {\n+      #debug(\"Woof %u %d\", *self.barks, *self.volume);\n+      *self.barks += 1u;\n+      if *self.barks % 3u == 0u {\n+          *self.volume += 1;\n+      }\n+      if *self.barks % 10u == 0u {\n+          *self.volume -= 2;\n+      }\n+      #debug(\"Grrr %u %d\", *self.barks, *self.volume);\n+      *self.volume\n+    }\n+  }\n+\n+  let volume : @mut int;\n+\n+  new() { self.volume = @mut 0; self.barks = @mut 0u; }\n+\n+  fn speak() -> int { self.bark() }\n+}\n+\n+class cat implements noisy {\n+  priv {\n+    let meows : @mut uint;\n+    fn meow() -> uint {\n+      #debug(\"Meow\");\n+      *self.meows += 1u;\n+      if *self.meows % 5u == 0u {\n+          *self.how_hungry += 1;\n+      }\n+      *self.meows\n+    }\n+  }\n+\n+  let how_hungry : @mut int;\n+  let name : str;\n+\n+  new(in_x : uint, in_y : int, in_name: str)\n+    { self.meows = @mut in_x; self.how_hungry = @mut in_y;\n+      self.name = in_name; }\n+\n+  fn speak() -> int { self.meow() as int }\n+  fn meow_count() -> uint { *self.meows }\n+}\n+\n+fn annoy_neighbors<T: noisy>(critter: T) {\n+  uint::range(0u, 10u) {|i| critter.speak(); }\n+}\n+\n+fn main() {\n+  let nyan : cat  = cat(0u, 2, \"nyan\");\n+  let whitefang : dog = dog();\n+  annoy_neighbors(nyan as noisy);\n+  annoy_neighbors(whitefang as noisy);\n+  assert(nyan.meow_count() == 10u);\n+  assert(*whitefang.volume == 1);\n+}\n\\ No newline at end of file"}, {"sha": "90b3d67cb59ec77bdcb01176ad4b4780223848b8", "filename": "src/test/run-pass/class-cast-to-iface.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/f7641286b23b0169f7d062ae1b45c49e9bea063d/src%2Ftest%2Frun-pass%2Fclass-cast-to-iface.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7641286b23b0169f7d062ae1b45c49e9bea063d/src%2Ftest%2Frun-pass%2Fclass-cast-to-iface.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-cast-to-iface.rs?ref=f7641286b23b0169f7d062ae1b45c49e9bea063d", "patch": "@@ -0,0 +1,41 @@\n+iface noisy {\n+  fn speak();\n+}\n+\n+class cat implements noisy {\n+  priv {\n+    let mut meows : uint;\n+    fn meow() {\n+      #error(\"Meow\");\n+      self.meows += 1u;\n+      if self.meows % 5u == 0u {\n+          self.how_hungry += 1;\n+      }\n+    }\n+  }\n+\n+  let mut how_hungry : int;\n+  let name : str;\n+\n+  new(in_x : uint, in_y : int, in_name: str)\n+    { self.meows = in_x; self.how_hungry = in_y; self.name = in_name; }\n+\n+  fn speak() { self.meow(); }\n+\n+  fn eat() -> bool {\n+    if self.how_hungry > 0 {\n+        #error(\"OM NOM NOM\");\n+        self.how_hungry -= 2;\n+        ret true;\n+    }\n+    else {\n+        #error(\"Not hungry!\");\n+        ret false;\n+    }\n+  }\n+}\n+\n+fn main() {\n+  let nyan : noisy  = cat(0u, 2, \"nyan\") as noisy;\n+  nyan.speak();\n+}\n\\ No newline at end of file"}, {"sha": "5a238a46ed898bdf7536116a9b2d537abf2b7ebb", "filename": "src/test/run-pass/class-implements-multiple-ifaces.rs", "status": "added", "additions": 118, "deletions": 0, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/f7641286b23b0169f7d062ae1b45c49e9bea063d/src%2Ftest%2Frun-pass%2Fclass-implements-multiple-ifaces.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7641286b23b0169f7d062ae1b45c49e9bea063d/src%2Ftest%2Frun-pass%2Fclass-implements-multiple-ifaces.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-implements-multiple-ifaces.rs?ref=f7641286b23b0169f7d062ae1b45c49e9bea063d", "patch": "@@ -0,0 +1,118 @@\n+use std;\n+import std::map::*;\n+import vec::*;\n+\n+enum furniture { chair, couch, bed }\n+enum body_part { finger, toe, nose, ear }\n+\n+iface noisy {\n+  fn speak() -> int;\n+}\n+\n+iface scratchy {\n+  fn scratch() -> option<furniture>;\n+}\n+\n+iface bitey {\n+  fn bite() -> body_part;\n+}\n+\n+fn vec_includes<T>(xs: [T], x: T) -> bool {\n+  for each(xs) {|y| if y == x { ret true; }}\n+  ret false;\n+}\n+\n+// vtables other than the 1st one don't seem to work\n+class cat implements noisy, scratchy, bitey {\n+  priv {\n+    let meows : @mut uint;\n+    let scratched : @mut [furniture];\n+    let bite_counts : hashmap<body_part, uint>;\n+\n+    fn meow() -> uint {\n+      #debug(\"Meow: %u\", *self.meows);\n+      *self.meows += 1u;\n+      if *self.meows % 5u == 0u {\n+          *self.how_hungry += 1;\n+      }\n+      *self.meows\n+    }\n+  }\n+\n+  let how_hungry : @mut int;\n+  let name : str;\n+\n+  new(in_x : uint, in_y : int, in_name: str)\n+    { self.meows = @mut in_x; self.how_hungry = @mut in_y;\n+      self.name = in_name; self.scratched = @mut [];\n+      let hsher: hashfn<body_part> =\n+        fn@(p: body_part) -> uint { int::hash(p as int) };\n+      let eqer : eqfn<body_part> =\n+        fn@(p: body_part, q: body_part)  -> bool { p == q };\n+      let t : hashmap<body_part, uint> =\n+        hashmap::<body_part, uint>(hsher, eqer);\n+      self.bite_counts = t;\n+      iter([finger, toe, nose, ear]) {|p|\n+          self.bite_counts.insert(p, 0u);\n+      };\n+    }\n+\n+  fn speak() -> int { self.meow() as int }\n+  fn meow_count() -> uint { *self.meows }\n+  fn scratch() -> option<furniture> {\n+    let all = [chair, couch, bed];\n+    log(error, *(self.scratched));\n+    let mut rslt = none;\n+    for each(all) {|thing| if !vec_includes(*(self.scratched), thing) {\n+          *self.scratched += [thing];\n+          ret some(thing); }}\n+    rslt\n+  }\n+  fn bite() -> body_part {\n+    #error(\"In bite()\");\n+    let all = [toe, nose, ear];\n+    let mut min = finger;\n+    iter(all) {|next|\n+      #debug(\"min = %?\", min);\n+        if self.bite_counts.get(next) < self.bite_counts.get(min) {\n+            min = next;\n+          }};\n+    self.bite_counts.insert(min, self.bite_counts.get(min) + 1u);\n+    #debug(\"Bit %?\", min);\n+    min\n+  }\n+}\n+\n+fn annoy_neighbors<T: noisy>(critter: T) {\n+  uint::range(0u, 10u) {|i|\n+      let what = critter.speak();\n+      #debug(\"%u %d\", i, what);\n+  }\n+}\n+\n+fn bite_everything<T: bitey>(critter: T) -> bool {\n+  let mut left : [body_part] = [finger, toe, nose, ear];\n+  while vec::len(left) > 0u {\n+    let part = critter.bite();\n+    #debug(\"%? %?\", left, part);\n+    if vec_includes(left, part) {\n+        left = vec::filter(left, {|p| p != part});\n+    }\n+    else {\n+      ret false;\n+    }\n+  }\n+  true\n+}\n+\n+fn scratched_something<T: scratchy>(critter: T) -> bool {\n+  option::is_some(critter.scratch())\n+}\n+\n+fn main() {\n+  let nyan : cat  = cat(0u, 2, \"nyan\");\n+  annoy_neighbors(nyan as noisy);\n+  assert(nyan.meow_count() == 10u);\n+  assert(bite_everything(nyan as bitey));\n+  assert(scratched_something(nyan as scratchy));\n+}\n\\ No newline at end of file"}]}