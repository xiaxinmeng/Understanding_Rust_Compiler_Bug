{"sha": "eece58a8e35c444afba6fa34873bc0244e32cd29", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVlY2U1OGE4ZTM1YzQ0NGFmYmE2ZmEzNDg3M2JjMDI0NGUzMmNkMjk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-04-30T12:17:15Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-04-30T12:17:15Z"}, "message": "Auto merge of #71707 - Dylan-DPC:rollup-hk8itvo, r=Dylan-DPC\n\nRollup of 5 pull requests\n\nSuccessful merges:\n\n - #71205 (rustc: fix check_attr() for methods, closures and foreign functions)\n - #71540 (Suggest deref when coercing `ty::Ref` to `ty::RawPtr`)\n - #71655 (Miri: better document and fix dynamic const pattern soundness checks)\n - #71672 (document missing stable counterparts of intrinsics)\n - #71692 (Add clarification on std::cfg macro docs v. #[cfg] attribute)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "216670c2abbdba8738794745427cde400d4c0e6b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/216670c2abbdba8738794745427cde400d4c0e6b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/eece58a8e35c444afba6fa34873bc0244e32cd29", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/eece58a8e35c444afba6fa34873bc0244e32cd29", "html_url": "https://github.com/rust-lang/rust/commit/eece58a8e35c444afba6fa34873bc0244e32cd29", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/eece58a8e35c444afba6fa34873bc0244e32cd29/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bf459752d41a93eb6df0e9513de4ef807883a80c", "url": "https://api.github.com/repos/rust-lang/rust/commits/bf459752d41a93eb6df0e9513de4ef807883a80c", "html_url": "https://github.com/rust-lang/rust/commit/bf459752d41a93eb6df0e9513de4ef807883a80c"}, {"sha": "8f6eabfbaee893af88dde33294d7cc34ab2dd81a", "url": "https://api.github.com/repos/rust-lang/rust/commits/8f6eabfbaee893af88dde33294d7cc34ab2dd81a", "html_url": "https://github.com/rust-lang/rust/commit/8f6eabfbaee893af88dde33294d7cc34ab2dd81a"}], "stats": {"total": 696, "additions": 630, "deletions": 66}, "files": [{"sha": "962bcbe61985b18eeb621d9755b08350b4ebeb04", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 84, "deletions": 12, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/eece58a8e35c444afba6fa34873bc0244e32cd29/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eece58a8e35c444afba6fa34873bc0244e32cd29/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=eece58a8e35c444afba6fa34873bc0244e32cd29", "patch": "@@ -782,36 +782,43 @@ extern \"rust-intrinsic\" {\n     /// characteristics.\n     ///\n     /// The `locality` argument must be a constant integer and is a temporal locality specifier\n-    /// ranging from (0) - no locality, to (3) - extremely local keep in cache\n+    /// ranging from (0) - no locality, to (3) - extremely local keep in cache.\n+    ///\n+    /// This intrinsic does not have a stable counterpart.\n     pub fn prefetch_read_data<T>(data: *const T, locality: i32);\n     /// The `prefetch` intrinsic is a hint to the code generator to insert a prefetch instruction\n     /// if supported; otherwise, it is a no-op.\n     /// Prefetches have no effect on the behavior of the program but can change its performance\n     /// characteristics.\n     ///\n     /// The `locality` argument must be a constant integer and is a temporal locality specifier\n-    /// ranging from (0) - no locality, to (3) - extremely local keep in cache\n+    /// ranging from (0) - no locality, to (3) - extremely local keep in cache.\n+    ///\n+    /// This intrinsic does not have a stable counterpart.\n     pub fn prefetch_write_data<T>(data: *const T, locality: i32);\n     /// The `prefetch` intrinsic is a hint to the code generator to insert a prefetch instruction\n     /// if supported; otherwise, it is a no-op.\n     /// Prefetches have no effect on the behavior of the program but can change its performance\n     /// characteristics.\n     ///\n     /// The `locality` argument must be a constant integer and is a temporal locality specifier\n-    /// ranging from (0) - no locality, to (3) - extremely local keep in cache\n+    /// ranging from (0) - no locality, to (3) - extremely local keep in cache.\n+    ///\n+    /// This intrinsic does not have a stable counterpart.\n     pub fn prefetch_read_instruction<T>(data: *const T, locality: i32);\n     /// The `prefetch` intrinsic is a hint to the code generator to insert a prefetch instruction\n     /// if supported; otherwise, it is a no-op.\n     /// Prefetches have no effect on the behavior of the program but can change its performance\n     /// characteristics.\n     ///\n     /// The `locality` argument must be a constant integer and is a temporal locality specifier\n-    /// ranging from (0) - no locality, to (3) - extremely local keep in cache\n+    /// ranging from (0) - no locality, to (3) - extremely local keep in cache.\n+    ///\n+    /// This intrinsic does not have a stable counterpart.\n     pub fn prefetch_write_instruction<T>(data: *const T, locality: i32);\n }\n \n extern \"rust-intrinsic\" {\n-\n     /// An atomic fence.\n     ///\n     /// The stabilized version of this intrinsic is available in\n@@ -905,12 +912,14 @@ extern \"rust-intrinsic\" {\n     /// that `rustc_peek(potentially_uninitialized)` would actually\n     /// double-check that dataflow did indeed compute that it is\n     /// uninitialized at that point in the control flow.\n+    ///\n+    /// This intrinsic should not be used outside of the compiler.\n     pub fn rustc_peek<T>(_: T) -> T;\n \n     /// Aborts the execution of the process.\n     ///\n     /// The stabilized version of this intrinsic is\n-    /// [`std::process::abort`](../../std/process/fn.abort.html)\n+    /// [`std::process::abort`](../../std/process/fn.abort.html).\n     pub fn abort() -> !;\n \n     /// Tells LLVM that this point in the code is not reachable, enabling\n@@ -932,21 +941,29 @@ extern \"rust-intrinsic\" {\n     /// with optimization of surrounding code and reduce performance. It should\n     /// not be used if the invariant can be discovered by the optimizer on its\n     /// own, or if it does not enable any significant optimizations.\n+    ///\n+    /// This intrinsic does not have a stable counterpart.\n     pub fn assume(b: bool);\n \n     /// Hints to the compiler that branch condition is likely to be true.\n     /// Returns the value passed to it.\n     ///\n     /// Any use other than with `if` statements will probably not have an effect.\n+    ///\n+    /// This intrinsic does not have a stable counterpart.\n     pub fn likely(b: bool) -> bool;\n \n     /// Hints to the compiler that branch condition is likely to be false.\n     /// Returns the value passed to it.\n     ///\n     /// Any use other than with `if` statements will probably not have an effect.\n+    ///\n+    /// This intrinsic does not have a stable counterpart.\n     pub fn unlikely(b: bool) -> bool;\n \n     /// Executes a breakpoint trap, for inspection by a debugger.\n+    ///\n+    /// This intrinsic does not have a stable counterpart.\n     pub fn breakpoint();\n \n     /// The size of a type in bytes.\n@@ -973,6 +990,9 @@ extern \"rust-intrinsic\" {\n     /// [`std::mem::align_of`](../../std/mem/fn.align_of.html).\n     #[rustc_const_stable(feature = \"const_min_align_of\", since = \"1.40.0\")]\n     pub fn min_align_of<T>() -> usize;\n+    /// The prefered alignment of a type.\n+    ///\n+    /// This intrinsic does not have a stable counterpart.\n     #[rustc_const_unstable(feature = \"const_pref_align_of\", issue = \"none\")]\n     pub fn pref_align_of<T>() -> usize;\n \n@@ -981,6 +1001,10 @@ extern \"rust-intrinsic\" {\n     /// The stabilized version of this intrinsic is\n     /// [`std::mem::size_of_val`](../../std/mem/fn.size_of_val.html).\n     pub fn size_of_val<T: ?Sized>(_: *const T) -> usize;\n+    /// The required alignment of the referenced value.\n+    ///\n+    /// The stabilized version of this intrinsic is\n+    /// [`std::mem::align_of_val`](../../std/mem/fn.align_of_val.html).\n     pub fn min_align_of_val<T: ?Sized>(_: *const T) -> usize;\n \n     /// Gets a static string slice containing the name of a type.\n@@ -1001,22 +1025,33 @@ extern \"rust-intrinsic\" {\n \n     /// A guard for unsafe functions that cannot ever be executed if `T` is uninhabited:\n     /// This will statically either panic, or do nothing.\n+    ///\n+    /// This intrinsic does not have a stable counterpart.\n     pub fn assert_inhabited<T>();\n \n     /// A guard for unsafe functions that cannot ever be executed if `T` does not permit\n     /// zero-initialization: This will statically either panic, or do nothing.\n+    ///\n+    /// This intrinsic does not have a stable counterpart.\n     pub fn assert_zero_valid<T>();\n \n     /// A guard for unsafe functions that cannot ever be executed if `T` has invalid\n     /// bit patterns: This will statically either panic, or do nothing.\n+    ///\n+    /// This intrinsic does not have a stable counterpart.\n     pub fn assert_uninit_valid<T>();\n \n     /// Gets a reference to a static `Location` indicating where it was called.\n+    ///\n+    /// Consider using [`std::panic::Location::caller`](../../std/panic/struct.Location.html#method.caller)\n+    /// instead.\n     #[rustc_const_unstable(feature = \"const_caller_location\", issue = \"47809\")]\n     pub fn caller_location() -> &'static crate::panic::Location<'static>;\n \n     /// Moves a value out of scope without running drop glue.\n-    /// This exists solely for `mem::forget_unsized`; normal `forget` uses `ManuallyDrop` instead.\n+    ///\n+    /// This exists solely for [`mem::forget_unsized`](../../std/mem/fn.forget_unsized.html);\n+    /// normal `forget` uses `ManuallyDrop` instead.\n     pub fn forget<T: ?Sized>(_: T);\n \n     /// Reinterprets the bits of a value of one type as another type.\n@@ -1300,20 +1335,26 @@ extern \"rust-intrinsic\" {\n     ///\n     /// The volatile parameter is set to `true`, so it will not be optimized out\n     /// unless size is equal to zero.\n+    ///\n+    /// This intrinsic does not have a stable counterpart.\n     pub fn volatile_copy_nonoverlapping_memory<T>(dst: *mut T, src: *const T, count: usize);\n     /// Equivalent to the appropriate `llvm.memmove.p0i8.0i8.*` intrinsic, with\n     /// a size of `count` * `size_of::<T>()` and an alignment of\n     /// `min_align_of::<T>()`\n     ///\n     /// The volatile parameter is set to `true`, so it will not be optimized out\n     /// unless size is equal to zero.\n+    ///\n+    /// This intrinsic does not have a stable counterpart.\n     pub fn volatile_copy_memory<T>(dst: *mut T, src: *const T, count: usize);\n     /// Equivalent to the appropriate `llvm.memset.p0i8.*` intrinsic, with a\n     /// size of `count` * `size_of::<T>()` and an alignment of\n     /// `min_align_of::<T>()`.\n     ///\n     /// The volatile parameter is set to `true`, so it will not be optimized out\n     /// unless size is equal to zero.\n+    ///\n+    /// This intrinsic does not have a stable counterpart.\n     pub fn volatile_set_memory<T>(dst: *mut T, val: u8, count: usize);\n \n     /// Performs a volatile load from the `src` pointer.\n@@ -1329,9 +1370,13 @@ extern \"rust-intrinsic\" {\n \n     /// Performs a volatile load from the `src` pointer\n     /// The pointer is not required to be aligned.\n+    ///\n+    /// This intrinsic does not have a stable counterpart.\n     pub fn unaligned_volatile_load<T>(src: *const T) -> T;\n     /// Performs a volatile store to the `dst` pointer.\n     /// The pointer is not required to be aligned.\n+    ///\n+    /// This intrinsic does not have a stable counterpart.\n     pub fn unaligned_volatile_store<T>(dst: *mut T, val: T);\n \n     /// Returns the square root of an `f32`\n@@ -1539,8 +1584,12 @@ extern \"rust-intrinsic\" {\n     pub fn rintf64(x: f64) -> f64;\n \n     /// Returns the nearest integer to an `f32`.\n+    ///\n+    /// This intrinsic does not have a stable counterpart.\n     pub fn nearbyintf32(x: f32) -> f32;\n     /// Returns the nearest integer to an `f64`.\n+    ///\n+    /// This intrinsic does not have a stable counterpart.\n     pub fn nearbyintf64(x: f64) -> f64;\n \n     /// Returns the nearest integer to an `f32`. Rounds half-way cases away from zero.\n@@ -1556,28 +1605,39 @@ extern \"rust-intrinsic\" {\n \n     /// Float addition that allows optimizations based on algebraic rules.\n     /// May assume inputs are finite.\n+    ///\n+    /// This intrinsic does not have a stable counterpart.\n     pub fn fadd_fast<T: Copy>(a: T, b: T) -> T;\n \n     /// Float subtraction that allows optimizations based on algebraic rules.\n     /// May assume inputs are finite.\n+    ///\n+    /// This intrinsic does not have a stable counterpart.\n     pub fn fsub_fast<T: Copy>(a: T, b: T) -> T;\n \n     /// Float multiplication that allows optimizations based on algebraic rules.\n     /// May assume inputs are finite.\n+    ///\n+    /// This intrinsic does not have a stable counterpart.\n     pub fn fmul_fast<T: Copy>(a: T, b: T) -> T;\n \n     /// Float division that allows optimizations based on algebraic rules.\n     /// May assume inputs are finite.\n+    ///\n+    /// This intrinsic does not have a stable counterpart.\n     pub fn fdiv_fast<T: Copy>(a: T, b: T) -> T;\n \n     /// Float remainder that allows optimizations based on algebraic rules.\n     /// May assume inputs are finite.\n+    ///\n+    /// This intrinsic does not have a stable counterpart.\n     pub fn frem_fast<T: Copy>(a: T, b: T) -> T;\n \n     /// Convert with LLVM\u2019s fptoui/fptosi, which may return undef for values out of range\n     /// (<https://github.com/rust-lang/rust/issues/10184>)\n     ///\n-    /// Stabilized as `f32::to_int_unchecked` and `f64::to_int_unchecked`.\n+    /// Stabilized as [`f32::to_int_unchecked`](../../std/primitive.f32.html#method.to_int_unchecked)\n+    /// and [`f64::to_int_unchecked`](../../std/primitive.f64.html#method.to_int_unchecked).\n     pub fn float_to_int_unchecked<Float: Copy, Int: Copy>(value: Float) -> Int;\n \n     /// Returns the number of bits set in an integer type `T`\n@@ -1623,6 +1683,8 @@ extern \"rust-intrinsic\" {\n     /// Like `ctlz`, but extra-unsafe as it returns `undef` when\n     /// given an `x` with value `0`.\n     ///\n+    /// This intrinsic does not have a stable counterpart.\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -1672,6 +1734,8 @@ extern \"rust-intrinsic\" {\n     /// Like `cttz`, but extra-unsafe as it returns `undef` when\n     /// given an `x` with value `0`.\n     ///\n+    /// This intrinsic does not have a stable counterpart.\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -1728,20 +1792,22 @@ extern \"rust-intrinsic\" {\n \n     /// Performs an exact division, resulting in undefined behavior where\n     /// `x % y != 0` or `y == 0` or `x == T::MIN && y == -1`\n+    ///\n+    /// This intrinsic does not have a stable counterpart.\n     pub fn exact_div<T: Copy>(x: T, y: T) -> T;\n \n     /// Performs an unchecked division, resulting in undefined behavior\n     /// where y = 0 or x = `T::MIN` and y = -1\n     ///\n-    /// The stabilized versions of this intrinsic are available on the integer\n+    /// Safe wrappers for this intrinsic are available on the integer\n     /// primitives via the `checked_div` method. For example,\n     /// [`std::u32::checked_div`](../../std/primitive.u32.html#method.checked_div)\n     #[rustc_const_unstable(feature = \"const_int_unchecked_arith\", issue = \"none\")]\n     pub fn unchecked_div<T: Copy>(x: T, y: T) -> T;\n     /// Returns the remainder of an unchecked division, resulting in\n     /// undefined behavior where y = 0 or x = `T::MIN` and y = -1\n     ///\n-    /// The stabilized versions of this intrinsic are available on the integer\n+    /// Safe wrappers for this intrinsic are available on the integer\n     /// primitives via the `checked_rem` method. For example,\n     /// [`std::u32::checked_rem`](../../std/primitive.u32.html#method.checked_rem)\n     #[rustc_const_unstable(feature = \"const_int_unchecked_arith\", issue = \"none\")]\n@@ -1750,32 +1816,38 @@ extern \"rust-intrinsic\" {\n     /// Performs an unchecked left shift, resulting in undefined behavior when\n     /// y < 0 or y >= N, where N is the width of T in bits.\n     ///\n-    /// The stabilized versions of this intrinsic are available on the integer\n+    /// Safe wrappers for this intrinsic are available on the integer\n     /// primitives via the `checked_shl` method. For example,\n     /// [`std::u32::checked_shl`](../../std/primitive.u32.html#method.checked_shl)\n     #[rustc_const_stable(feature = \"const_int_unchecked\", since = \"1.40.0\")]\n     pub fn unchecked_shl<T: Copy>(x: T, y: T) -> T;\n     /// Performs an unchecked right shift, resulting in undefined behavior when\n     /// y < 0 or y >= N, where N is the width of T in bits.\n     ///\n-    /// The stabilized versions of this intrinsic are available on the integer\n+    /// Safe wrappers for this intrinsic are available on the integer\n     /// primitives via the `checked_shr` method. For example,\n     /// [`std::u32::checked_shr`](../../std/primitive.u32.html#method.checked_shr)\n     #[rustc_const_stable(feature = \"const_int_unchecked\", since = \"1.40.0\")]\n     pub fn unchecked_shr<T: Copy>(x: T, y: T) -> T;\n \n     /// Returns the result of an unchecked addition, resulting in\n     /// undefined behavior when `x + y > T::MAX` or `x + y < T::MIN`.\n+    ///\n+    /// This intrinsic does not have a stable counterpart.\n     #[rustc_const_unstable(feature = \"const_int_unchecked_arith\", issue = \"none\")]\n     pub fn unchecked_add<T: Copy>(x: T, y: T) -> T;\n \n     /// Returns the result of an unchecked subtraction, resulting in\n     /// undefined behavior when `x - y > T::MAX` or `x - y < T::MIN`.\n+    ///\n+    /// This intrinsic does not have a stable counterpart.\n     #[rustc_const_unstable(feature = \"const_int_unchecked_arith\", issue = \"none\")]\n     pub fn unchecked_sub<T: Copy>(x: T, y: T) -> T;\n \n     /// Returns the result of an unchecked multiplication, resulting in\n     /// undefined behavior when `x * y > T::MAX` or `x * y < T::MIN`.\n+    ///\n+    /// This intrinsic does not have a stable counterpart.\n     #[rustc_const_unstable(feature = \"const_int_unchecked_arith\", issue = \"none\")]\n     pub fn unchecked_mul<T: Copy>(x: T, y: T) -> T;\n "}, {"sha": "14bfa8bab89390b90f2135683f8b8d7a4980ade3", "filename": "src/libcore/macros/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eece58a8e35c444afba6fa34873bc0244e32cd29/src%2Flibcore%2Fmacros%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eece58a8e35c444afba6fa34873bc0244e32cd29/src%2Flibcore%2Fmacros%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros%2Fmod.rs?ref=eece58a8e35c444afba6fa34873bc0244e32cd29", "patch": "@@ -1159,6 +1159,10 @@ pub(crate) mod builtin {\n     /// The syntax given to this macro is the same syntax as the [`cfg`]\n     /// attribute.\n     ///\n+    /// `cfg!`, unlike `#[cfg]`, does not remove any code and only evaluates to true or false. For\n+    /// example, all blocks in an if/else expression need to be valid when `cfg!` is used for\n+    /// the condition, regardless of what `cfg!` is evaluating.\n+    ///\n     /// [`cfg`]: ../reference/conditional-compilation.html#the-cfg-attribute\n     ///\n     /// # Examples"}, {"sha": "1ffd493d8130ba677c939f7da69e614fc9721266", "filename": "src/libcore/panic.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eece58a8e35c444afba6fa34873bc0244e32cd29/src%2Flibcore%2Fpanic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eece58a8e35c444afba6fa34873bc0244e32cd29/src%2Flibcore%2Fpanic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpanic.rs?ref=eece58a8e35c444afba6fa34873bc0244e32cd29", "patch": "@@ -228,6 +228,8 @@ impl<'a> Location<'a> {\n     /// assert_ne!(this_location.line(), another_location.line());\n     /// assert_ne!(this_location.column(), another_location.column());\n     /// ```\n+    // FIXME: When stabilizing this method, please also update the documentation\n+    // of `intrinsics::caller_location`.\n     #[unstable(\n         feature = \"track_caller\",\n         reason = \"uses #[track_caller] which is not yet stable\","}, {"sha": "d97546e4391b536378203e772bb078526aee962c", "filename": "src/librustc_mir/const_eval/eval_queries.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eece58a8e35c444afba6fa34873bc0244e32cd29/src%2Flibrustc_mir%2Fconst_eval%2Feval_queries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eece58a8e35c444afba6fa34873bc0244e32cd29/src%2Flibrustc_mir%2Fconst_eval%2Feval_queries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval%2Feval_queries.rs?ref=eece58a8e35c444afba6fa34873bc0244e32cd29", "patch": "@@ -193,7 +193,7 @@ fn validate_and_turn_into_const<'tcx>(\n                     mplace.into(),\n                     path,\n                     &mut ref_tracking,\n-                    /*may_ref_to_static*/ is_static,\n+                    /*may_ref_to_static*/ ecx.memory.extra.can_access_statics,\n                 )?;\n             }\n         }"}, {"sha": "7c1ab261eb9c40ab71dd01ffd98015402d905062", "filename": "src/librustc_mir/const_eval/machine.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/eece58a8e35c444afba6fa34873bc0244e32cd29/src%2Flibrustc_mir%2Fconst_eval%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eece58a8e35c444afba6fa34873bc0244e32cd29/src%2Flibrustc_mir%2Fconst_eval%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval%2Fmachine.rs?ref=eece58a8e35c444afba6fa34873bc0244e32cd29", "patch": "@@ -99,7 +99,12 @@ pub struct CompileTimeInterpreter<'mir, 'tcx> {\n \n #[derive(Copy, Clone, Debug)]\n pub struct MemoryExtra {\n-    /// Whether this machine may read from statics\n+    /// We need to make sure consts never point to anything mutable, even recursively. That is\n+    /// relied on for pattern matching on consts with references.\n+    /// To achieve this, two pieces have to work together:\n+    /// * Interning makes everything outside of statics immutable.\n+    /// * Pointers to allocations inside of statics can never leak outside, to a non-static global.\n+    /// This boolean here controls the second part.\n     pub(super) can_access_statics: bool,\n }\n \n@@ -337,6 +342,10 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n             } else if static_def_id.is_some() {\n                 // Machine configuration does not allow us to read statics\n                 // (e.g., `const` initializer).\n+                // See const_eval::machine::MemoryExtra::can_access_statics for why\n+                // this check is so important: if we could read statics, we could read pointers\n+                // to mutable allocations *inside* statics. These allocations are not themselves\n+                // statics, so pointers to them can get around the check in `validity.rs`.\n                 Err(ConstEvalErrKind::ConstAccessesStatic.into())\n             } else {\n                 // Immutable global, this read is fine."}, {"sha": "8560594b583d4126232b9d32ba01a1945b2bbc2c", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eece58a8e35c444afba6fa34873bc0244e32cd29/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eece58a8e35c444afba6fa34873bc0244e32cd29/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=eece58a8e35c444afba6fa34873bc0244e32cd29", "patch": "@@ -453,7 +453,9 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n                 // thing here: one maps to `GlobalAlloc::Static`, this is the \"lazy\" ID,\n                 // and the other one is maps to `GlobalAlloc::Memory`, this is returned by\n                 // `const_eval_raw` and it is the \"resolved\" ID.\n-                // The resolved ID is never used by the interpreted progrma, it is hidden.\n+                // The resolved ID is never used by the interpreted program, it is hidden.\n+                // This is relied upon for soundness of const-patterns; a pointer to the resolved\n+                // ID would \"sidestep\" the checks that make sure consts do not point to statics!\n                 // The `GlobalAlloc::Memory` branch here is still reachable though; when a static\n                 // contains a reference to memory that was created during its evaluation (i.e., not\n                 // to another static), those inner references only exist in \"resolved\" form."}, {"sha": "df3c353220318bdd665946b662522b939f1a57ec", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 15, "deletions": 7, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/eece58a8e35c444afba6fa34873bc0244e32cd29/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eece58a8e35c444afba6fa34873bc0244e32cd29/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=eece58a8e35c444afba6fa34873bc0244e32cd29", "patch": "@@ -404,19 +404,27 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n                 // Skip validation entirely for some external statics\n                 let alloc_kind = self.ecx.tcx.alloc_map.lock().get(ptr.alloc_id);\n                 if let Some(GlobalAlloc::Static(did)) = alloc_kind {\n-                    // `extern static` cannot be validated as they have no body.\n-                    // FIXME: Statics from other crates are also skipped.\n-                    // They might be checked at a different type, but for now we\n-                    // want to avoid recursing too deeply.  This is not sound!\n-                    if !did.is_local() || self.ecx.tcx.is_foreign_item(did) {\n-                        return Ok(());\n-                    }\n+                    // See const_eval::machine::MemoryExtra::can_access_statics for why\n+                    // this check is so important.\n+                    // This check is reachable when the const just referenced the static,\n+                    // but never read it (so we never entered `before_access_global`).\n+                    // We also need to do it here instead of going on to avoid running\n+                    // into the `before_access_global` check during validation.\n                     if !self.may_ref_to_static && self.ecx.tcx.is_static(did) {\n                         throw_validation_failure!(\n                             format_args!(\"a {} pointing to a static variable\", kind),\n                             self.path\n                         );\n                     }\n+                    // `extern static` cannot be validated as they have no body.\n+                    // FIXME: Statics from other crates are also skipped.\n+                    // They might be checked at a different type, but for now we\n+                    // want to avoid recursing too deeply.  We might miss const-invalid data,\n+                    // but things are still sound otherwise (in particular re: consts\n+                    // referring to statics).\n+                    if !did.is_local() || self.ecx.tcx.is_foreign_item(did) {\n+                        return Ok(());\n+                    }\n                 }\n             }\n             // Proceed recursively even for ZST, no reason to skip them!"}, {"sha": "0fb715f450477c718fce36608123c54bbc2915ee", "filename": "src/librustc_passes/check_attr.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/eece58a8e35c444afba6fa34873bc0244e32cd29/src%2Flibrustc_passes%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eece58a8e35c444afba6fa34873bc0244e32cd29/src%2Flibrustc_passes%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fcheck_attr.rs?ref=eece58a8e35c444afba6fa34873bc0244e32cd29", "patch": "@@ -76,7 +76,7 @@ impl CheckAttrVisitor<'tcx> {\n             return;\n         }\n \n-        if target == Target::Fn {\n+        if matches!(target, Target::Fn | Target::Method(_) | Target::ForeignFn) {\n             self.tcx.codegen_fn_attrs(self.tcx.hir().local_def_id(hir_id));\n         }\n \n@@ -389,6 +389,9 @@ impl CheckAttrVisitor<'tcx> {\n                 );\n             }\n         }\n+        if target == Target::Closure {\n+            self.tcx.codegen_fn_attrs(self.tcx.hir().local_def_id(expr.hir_id));\n+        }\n     }\n \n     fn check_used(&self, attrs: &'hir [Attribute], target: Target) {"}, {"sha": "5d1a1a164855df6f84e4adea0204e4aa01d34d08", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/eece58a8e35c444afba6fa34873bc0244e32cd29/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eece58a8e35c444afba6fa34873bc0244e32cd29/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=eece58a8e35c444afba6fa34873bc0244e32cd29", "patch": "@@ -74,7 +74,7 @@ use rustc_trait_selection::traits::{self, ObligationCause, ObligationCauseCode};\n use smallvec::{smallvec, SmallVec};\n use std::ops::Deref;\n \n-struct Coerce<'a, 'tcx> {\n+pub struct Coerce<'a, 'tcx> {\n     fcx: &'a FnCtxt<'a, 'tcx>,\n     cause: ObligationCause<'tcx>,\n     use_lub: bool,\n@@ -124,15 +124,15 @@ fn success<'tcx>(\n }\n \n impl<'f, 'tcx> Coerce<'f, 'tcx> {\n-    fn new(\n+    pub fn new(\n         fcx: &'f FnCtxt<'f, 'tcx>,\n         cause: ObligationCause<'tcx>,\n         allow_two_phase: AllowTwoPhase,\n     ) -> Self {\n         Coerce { fcx, cause, allow_two_phase, use_lub: false }\n     }\n \n-    fn unify(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> InferResult<'tcx, Ty<'tcx>> {\n+    pub fn unify(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> InferResult<'tcx, Ty<'tcx>> {\n         self.commit_if_ok(|_| {\n             if self.use_lub {\n                 self.at(&self.cause, self.fcx.param_env).lub(b, a)\n@@ -771,10 +771,10 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n             ty::RawPtr(mt) => (false, mt),\n             _ => return self.unify_and(a, b, identity),\n         };\n+        coerce_mutbls(mt_a.mutbl, mutbl_b)?;\n \n         // Check that the types which they point at are compatible.\n         let a_unsafe = self.tcx.mk_ptr(ty::TypeAndMut { mutbl: mutbl_b, ty: mt_a.ty });\n-        coerce_mutbls(mt_a.mutbl, mutbl_b)?;\n         // Although references and unsafe ptrs have the same\n         // representation, we still register an Adjust::DerefRef so that\n         // regionck knows that the region for `a` must be valid here."}, {"sha": "65ef9cad874486033ce86a28d7ff484f3d15471a", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 38, "deletions": 2, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/eece58a8e35c444afba6fa34873bc0244e32cd29/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eece58a8e35c444afba6fa34873bc0244e32cd29/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=eece58a8e35c444afba6fa34873bc0244e32cd29", "patch": "@@ -1,3 +1,4 @@\n+use crate::check::coercion::Coerce;\n use crate::check::FnCtxt;\n use rustc_infer::infer::InferOk;\n use rustc_trait_selection::infer::InferCtxtExt as _;\n@@ -8,8 +9,9 @@ use rustc_ast::util::parser::PREC_POSTFIX;\n use rustc_errors::{Applicability, DiagnosticBuilder};\n use rustc_hir as hir;\n use rustc_hir::{is_range_literal, Node};\n+use rustc_middle::traits::ObligationCauseCode;\n use rustc_middle::ty::adjustment::AllowTwoPhase;\n-use rustc_middle::ty::{self, AssocItem, Ty};\n+use rustc_middle::ty::{self, AssocItem, Ty, TypeAndMut};\n use rustc_span::symbol::sym;\n use rustc_span::Span;\n \n@@ -25,7 +27,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     ) {\n         self.annotate_expected_due_to_let_ty(err, expr);\n         self.suggest_compatible_variants(err, expr, expected, expr_ty);\n-        self.suggest_ref_or_into(err, expr, expected, expr_ty);\n+        self.suggest_deref_ref_or_into(err, expr, expected, expr_ty);\n         if self.suggest_calling_boxed_future_when_appropriate(err, expr, expected, expr_ty) {\n             return;\n         }\n@@ -539,6 +541,40 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     return Some((sp, \"consider removing the borrow\", code));\n                 }\n             }\n+            (\n+                _,\n+                &ty::RawPtr(TypeAndMut { ty: _, mutbl: hir::Mutability::Not }),\n+                &ty::Ref(_, _, hir::Mutability::Not),\n+            ) => {\n+                let cause = self.cause(rustc_span::DUMMY_SP, ObligationCauseCode::ExprAssignable);\n+                // We don't ever need two-phase here since we throw out the result of the coercion\n+                let coerce = Coerce::new(self, cause, AllowTwoPhase::No);\n+\n+                if let Some(steps) =\n+                    coerce.autoderef(sp, checked_ty).skip(1).find_map(|(referent_ty, steps)| {\n+                        coerce\n+                            .unify(\n+                                coerce.tcx.mk_ptr(ty::TypeAndMut {\n+                                    mutbl: hir::Mutability::Not,\n+                                    ty: referent_ty,\n+                                }),\n+                                expected,\n+                            )\n+                            .ok()\n+                            .map(|_| steps)\n+                    })\n+                {\n+                    // The pointer type implements `Copy` trait so the suggestion is always valid.\n+                    if let Ok(code) = sm.span_to_snippet(sp) {\n+                        if code.starts_with('&') {\n+                            let derefs = \"*\".repeat(steps - 1);\n+                            let message = \"consider dereferencing the reference\";\n+                            let suggestion = format!(\"&{}{}\", derefs, code[1..].to_string());\n+                            return Some((sp, message, suggestion));\n+                        }\n+                    }\n+                }\n+            }\n             _ if sp == expr.span && !is_macro => {\n                 // Check for `Deref` implementations by constructing a predicate to\n                 // prove: `<T as Deref>::Output == U`"}, {"sha": "92ddfbff824cdc2559c0c4a891fe00e11cdfa4cd", "filename": "src/librustc_typeck/check/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eece58a8e35c444afba6fa34873bc0244e32cd29/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eece58a8e35c444afba6fa34873bc0244e32cd29/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs?ref=eece58a8e35c444afba6fa34873bc0244e32cd29", "patch": "@@ -86,7 +86,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         if let Some(mut err) = self.demand_suptype_diag(expr.span, expected_ty, ty) {\n             let expr = expr.peel_drop_temps();\n-            self.suggest_ref_or_into(&mut err, expr, expected_ty, ty);\n+            self.suggest_deref_ref_or_into(&mut err, expr, expected_ty, ty);\n             extend_err(&mut err);\n             // Error possibly reported in `check_assign` so avoid emitting error again.\n             err.emit_unless(self.is_assign_to_bool(expr, expected_ty));"}, {"sha": "adbab3d4cb620c1543af1bee8dabb76d42e8235e", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eece58a8e35c444afba6fa34873bc0244e32cd29/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eece58a8e35c444afba6fa34873bc0244e32cd29/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=eece58a8e35c444afba6fa34873bc0244e32cd29", "patch": "@@ -5029,7 +5029,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         false\n     }\n \n-    pub fn suggest_ref_or_into(\n+    pub fn suggest_deref_ref_or_into(\n         &self,\n         err: &mut DiagnosticBuilder<'_>,\n         expr: &hir::Expr<'_>,"}, {"sha": "4fc6ae66a1242d2476b64260e8acc174e252bd50", "filename": "src/test/ui/consts/miri_unleashed/auxiliary/static_cross_crate.rs", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/eece58a8e35c444afba6fa34873bc0244e32cd29/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fauxiliary%2Fstatic_cross_crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eece58a8e35c444afba6fa34873bc0244e32cd29/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fauxiliary%2Fstatic_cross_crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fauxiliary%2Fstatic_cross_crate.rs?ref=eece58a8e35c444afba6fa34873bc0244e32cd29", "patch": "@@ -0,0 +1,3 @@\n+pub static mut ZERO: [u8; 1] = [0];\n+pub static ZERO_REF: &[u8; 1] = unsafe { &ZERO };\n+pub static mut OPT_ZERO: Option<u8> = Some(0);"}, {"sha": "6b205a2f66d9ba5e273fffbc5095aabf20a2e7cd", "filename": "src/test/ui/consts/miri_unleashed/const_refers_to_static.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/eece58a8e35c444afba6fa34873bc0244e32cd29/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fconst_refers_to_static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eece58a8e35c444afba6fa34873bc0244e32cd29/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fconst_refers_to_static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fconst_refers_to_static.rs?ref=eece58a8e35c444afba6fa34873bc0244e32cd29", "patch": "@@ -7,7 +7,8 @@\n use std::sync::atomic::AtomicUsize;\n use std::sync::atomic::Ordering;\n \n-// These tests only cause an error when *using* the const.\n+// These fail during CTFE (as they read a static), so they only cause an error\n+// when *using* the const.\n \n const MUTATE_INTERIOR_MUT: usize = {\n     static FOO: AtomicUsize = AtomicUsize::new(0);"}, {"sha": "acc3b637f58bccb31939b851db75bb248bfa2d6a", "filename": "src/test/ui/consts/miri_unleashed/const_refers_to_static.stderr", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/eece58a8e35c444afba6fa34873bc0244e32cd29/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fconst_refers_to_static.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/eece58a8e35c444afba6fa34873bc0244e32cd29/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fconst_refers_to_static.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fconst_refers_to_static.stderr?ref=eece58a8e35c444afba6fa34873bc0244e32cd29", "patch": "@@ -1,47 +1,47 @@\n warning: skipping const checks\n-  --> $DIR/const_refers_to_static.rs:14:5\n+  --> $DIR/const_refers_to_static.rs:15:5\n    |\n LL |     FOO.fetch_add(1, Ordering::Relaxed)\n    |     ^^^\n \n warning: skipping const checks\n-  --> $DIR/const_refers_to_static.rs:14:5\n+  --> $DIR/const_refers_to_static.rs:15:5\n    |\n LL |     FOO.fetch_add(1, Ordering::Relaxed)\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n warning: skipping const checks\n-  --> $DIR/const_refers_to_static.rs:21:17\n+  --> $DIR/const_refers_to_static.rs:22:17\n    |\n LL |     unsafe { *(&FOO as *const _ as *const usize) }\n    |                 ^^^\n \n warning: skipping const checks\n-  --> $DIR/const_refers_to_static.rs:26:32\n+  --> $DIR/const_refers_to_static.rs:27:32\n    |\n LL | const READ_MUT: u32 = unsafe { MUTABLE };\n    |                                ^^^^^^^\n \n warning: skipping const checks\n-  --> $DIR/const_refers_to_static.rs:26:32\n+  --> $DIR/const_refers_to_static.rs:27:32\n    |\n LL | const READ_MUT: u32 = unsafe { MUTABLE };\n    |                                ^^^^^^^\n \n error[E0080]: erroneous constant used\n-  --> $DIR/const_refers_to_static.rs:31:5\n+  --> $DIR/const_refers_to_static.rs:32:5\n    |\n LL |     MUTATE_INTERIOR_MUT;\n    |     ^^^^^^^^^^^^^^^^^^^ referenced constant has errors\n \n error[E0080]: erroneous constant used\n-  --> $DIR/const_refers_to_static.rs:33:5\n+  --> $DIR/const_refers_to_static.rs:34:5\n    |\n LL |     READ_INTERIOR_MUT;\n    |     ^^^^^^^^^^^^^^^^^ referenced constant has errors\n \n error[E0080]: erroneous constant used\n-  --> $DIR/const_refers_to_static.rs:35:5\n+  --> $DIR/const_refers_to_static.rs:36:5\n    |\n LL |     READ_MUT;\n    |     ^^^^^^^^ referenced constant has errors"}, {"sha": "553d90f1891cc38d49bc7044daf3de1fc76144e9", "filename": "src/test/ui/consts/miri_unleashed/const_refers_to_static2.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/eece58a8e35c444afba6fa34873bc0244e32cd29/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fconst_refers_to_static2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eece58a8e35c444afba6fa34873bc0244e32cd29/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fconst_refers_to_static2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fconst_refers_to_static2.rs?ref=eece58a8e35c444afba6fa34873bc0244e32cd29", "patch": "@@ -6,16 +6,21 @@\n use std::sync::atomic::AtomicUsize;\n use std::sync::atomic::Ordering;\n \n-// These tests cause immediate error when *defining* the const.\n+// These only fail during validation (they do not use but just create a reference to a static),\n+// so they cause an immediate error when *defining* the const.\n \n const REF_INTERIOR_MUT: &usize = { //~ ERROR undefined behavior to use this value\n+//~| NOTE encountered a reference pointing to a static variable\n+//~| NOTE\n     static FOO: AtomicUsize = AtomicUsize::new(0);\n     unsafe { &*(&FOO as *const _ as *const usize) }\n     //~^ WARN skipping const checks\n };\n \n // ok some day perhaps\n const READ_IMMUT: &usize = { //~ ERROR it is undefined behavior to use this value\n+//~| NOTE encountered a reference pointing to a static variable\n+//~| NOTE\n     static FOO: usize = 0;\n     &FOO\n     //~^ WARN skipping const checks"}, {"sha": "33f4a42605ccecdaa60006319162cb4dbbc096b9", "filename": "src/test/ui/consts/miri_unleashed/const_refers_to_static2.stderr", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/eece58a8e35c444afba6fa34873bc0244e32cd29/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fconst_refers_to_static2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/eece58a8e35c444afba6fa34873bc0244e32cd29/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fconst_refers_to_static2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fconst_refers_to_static2.stderr?ref=eece58a8e35c444afba6fa34873bc0244e32cd29", "patch": "@@ -1,19 +1,21 @@\n warning: skipping const checks\n-  --> $DIR/const_refers_to_static2.rs:13:18\n+  --> $DIR/const_refers_to_static2.rs:16:18\n    |\n LL |     unsafe { &*(&FOO as *const _ as *const usize) }\n    |                  ^^^\n \n warning: skipping const checks\n-  --> $DIR/const_refers_to_static2.rs:20:6\n+  --> $DIR/const_refers_to_static2.rs:25:6\n    |\n LL |     &FOO\n    |      ^^^\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/const_refers_to_static2.rs:11:1\n+  --> $DIR/const_refers_to_static2.rs:12:1\n    |\n LL | / const REF_INTERIOR_MUT: &usize = {\n+LL | |\n+LL | |\n LL | |     static FOO: AtomicUsize = AtomicUsize::new(0);\n LL | |     unsafe { &*(&FOO as *const _ as *const usize) }\n LL | |\n@@ -23,9 +25,11 @@ LL | | };\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/const_refers_to_static2.rs:18:1\n+  --> $DIR/const_refers_to_static2.rs:21:1\n    |\n LL | / const READ_IMMUT: &usize = {\n+LL | |\n+LL | |\n LL | |     static FOO: usize = 0;\n LL | |     &FOO\n LL | |"}, {"sha": "8bdb48e6f122fd0b1f4e2ff257f93e0f8ba64d8c", "filename": "src/test/ui/consts/miri_unleashed/const_refers_to_static_cross_crate.rs", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/eece58a8e35c444afba6fa34873bc0244e32cd29/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fconst_refers_to_static_cross_crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eece58a8e35c444afba6fa34873bc0244e32cd29/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fconst_refers_to_static_cross_crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fconst_refers_to_static_cross_crate.rs?ref=eece58a8e35c444afba6fa34873bc0244e32cd29", "patch": "@@ -0,0 +1,81 @@\n+// compile-flags: -Zunleash-the-miri-inside-of-you -Zdeduplicate-diagnostics\n+// aux-build:static_cross_crate.rs\n+#![allow(const_err)]\n+\n+#![feature(exclusive_range_pattern, half_open_range_patterns, const_if_match, const_panic)]\n+\n+extern crate static_cross_crate;\n+\n+// Sneaky: reference to a mutable static.\n+// Allowing this would be a disaster for pattern matching, we could violate exhaustiveness checking!\n+const SLICE_MUT: &[u8; 1] = { //~ ERROR undefined behavior to use this value\n+//~| NOTE encountered a reference pointing to a static variable\n+//~| NOTE\n+    unsafe { &static_cross_crate::ZERO }\n+    //~^ WARN skipping const checks\n+};\n+\n+const U8_MUT: &u8 = { //~ ERROR undefined behavior to use this value\n+//~| NOTE encountered a reference pointing to a static variable\n+//~| NOTE\n+    unsafe { &static_cross_crate::ZERO[0] }\n+    //~^ WARN skipping const checks\n+};\n+\n+// Also test indirection that reads from other static. This causes a const_err.\n+#[warn(const_err)] //~ NOTE\n+const U8_MUT2: &u8 = { //~ NOTE\n+    unsafe { &(*static_cross_crate::ZERO_REF)[0] }\n+    //~^ WARN skipping const checks\n+    //~| WARN [const_err]\n+    //~| NOTE constant accesses static\n+};\n+#[warn(const_err)] //~ NOTE\n+const U8_MUT3: &u8 = { //~ NOTE\n+    unsafe { match static_cross_crate::OPT_ZERO { Some(ref u) => u, None => panic!() } }\n+    //~^ WARN skipping const checks\n+    //~| WARN [const_err]\n+    //~| NOTE constant accesses static\n+};\n+\n+pub fn test(x: &[u8; 1]) -> bool {\n+    match x {\n+        SLICE_MUT => true,\n+        //~^ ERROR could not evaluate constant pattern\n+        &[1..] => false,\n+    }\n+}\n+\n+pub fn test2(x: &u8) -> bool {\n+    match x {\n+        U8_MUT => true,\n+        //~^ ERROR could not evaluate constant pattern\n+        &(1..) => false,\n+    }\n+}\n+\n+// We need to use these *in a pattern* to trigger the failure... likely because\n+// the errors above otherwise stop compilation too early?\n+pub fn test3(x: &u8) -> bool {\n+    match x {\n+        U8_MUT2 => true,\n+        //~^ ERROR could not evaluate constant pattern\n+        &(1..) => false,\n+    }\n+}\n+pub fn test4(x: &u8) -> bool {\n+    match x {\n+        U8_MUT3 => true,\n+        //~^ ERROR could not evaluate constant pattern\n+        &(1..) => false,\n+    }\n+}\n+\n+fn main() {\n+    unsafe {\n+        static_cross_crate::ZERO[0] = 1;\n+    }\n+    // Now the pattern is not exhaustive any more!\n+    test(&[0]);\n+    test2(&0);\n+}"}, {"sha": "bc6375f3d5e0b7439cea0f3d2af04963e9e05253", "filename": "src/test/ui/consts/miri_unleashed/const_refers_to_static_cross_crate.stderr", "status": "added", "additions": 113, "deletions": 0, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/eece58a8e35c444afba6fa34873bc0244e32cd29/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fconst_refers_to_static_cross_crate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/eece58a8e35c444afba6fa34873bc0244e32cd29/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fconst_refers_to_static_cross_crate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fconst_refers_to_static_cross_crate.stderr?ref=eece58a8e35c444afba6fa34873bc0244e32cd29", "patch": "@@ -0,0 +1,113 @@\n+warning: skipping const checks\n+  --> $DIR/const_refers_to_static_cross_crate.rs:14:15\n+   |\n+LL |     unsafe { &static_cross_crate::ZERO }\n+   |               ^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/const_refers_to_static_cross_crate.rs:11:1\n+   |\n+LL | / const SLICE_MUT: &[u8; 1] = {\n+LL | |\n+LL | |\n+LL | |     unsafe { &static_cross_crate::ZERO }\n+LL | |\n+LL | | };\n+   | |__^ type validation failed: encountered a reference pointing to a static variable\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+\n+error: could not evaluate constant pattern\n+  --> $DIR/const_refers_to_static_cross_crate.rs:43:9\n+   |\n+LL |         SLICE_MUT => true,\n+   |         ^^^^^^^^^\n+\n+warning: skipping const checks\n+  --> $DIR/const_refers_to_static_cross_crate.rs:21:15\n+   |\n+LL |     unsafe { &static_cross_crate::ZERO[0] }\n+   |               ^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/const_refers_to_static_cross_crate.rs:18:1\n+   |\n+LL | / const U8_MUT: &u8 = {\n+LL | |\n+LL | |\n+LL | |     unsafe { &static_cross_crate::ZERO[0] }\n+LL | |\n+LL | | };\n+   | |__^ type validation failed: encountered a reference pointing to a static variable\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+\n+error: could not evaluate constant pattern\n+  --> $DIR/const_refers_to_static_cross_crate.rs:51:9\n+   |\n+LL |         U8_MUT => true,\n+   |         ^^^^^^\n+\n+warning: skipping const checks\n+  --> $DIR/const_refers_to_static_cross_crate.rs:28:17\n+   |\n+LL |     unsafe { &(*static_cross_crate::ZERO_REF)[0] }\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+warning: any use of this value will cause an error\n+  --> $DIR/const_refers_to_static_cross_crate.rs:28:14\n+   |\n+LL | / const U8_MUT2: &u8 = {\n+LL | |     unsafe { &(*static_cross_crate::ZERO_REF)[0] }\n+   | |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constant accesses static\n+LL | |\n+LL | |\n+LL | |\n+LL | | };\n+   | |__-\n+   |\n+note: the lint level is defined here\n+  --> $DIR/const_refers_to_static_cross_crate.rs:26:8\n+   |\n+LL | #[warn(const_err)]\n+   |        ^^^^^^^^^\n+\n+error: could not evaluate constant pattern\n+  --> $DIR/const_refers_to_static_cross_crate.rs:61:9\n+   |\n+LL |         U8_MUT2 => true,\n+   |         ^^^^^^^\n+\n+warning: skipping const checks\n+  --> $DIR/const_refers_to_static_cross_crate.rs:35:20\n+   |\n+LL |     unsafe { match static_cross_crate::OPT_ZERO { Some(ref u) => u, None => panic!() } }\n+   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+warning: any use of this value will cause an error\n+  --> $DIR/const_refers_to_static_cross_crate.rs:35:51\n+   |\n+LL | / const U8_MUT3: &u8 = {\n+LL | |     unsafe { match static_cross_crate::OPT_ZERO { Some(ref u) => u, None => panic!() } }\n+   | |                                                   ^^^^^^^^^^^ constant accesses static\n+LL | |\n+LL | |\n+LL | |\n+LL | | };\n+   | |__-\n+   |\n+note: the lint level is defined here\n+  --> $DIR/const_refers_to_static_cross_crate.rs:33:8\n+   |\n+LL | #[warn(const_err)]\n+   |        ^^^^^^^^^\n+\n+error: could not evaluate constant pattern\n+  --> $DIR/const_refers_to_static_cross_crate.rs:68:9\n+   |\n+LL |         U8_MUT3 => true,\n+   |         ^^^^^^^\n+\n+error: aborting due to 6 previous errors; 6 warnings emitted\n+\n+For more information about this error, try `rustc --explain E0080`."}, {"sha": "eecf2046ccbeaf45624054f2e4ccb2db740dbdd6", "filename": "src/test/ui/feature-gates/feature-gate-unboxed-closures-manual-impls.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eece58a8e35c444afba6fa34873bc0244e32cd29/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-unboxed-closures-manual-impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eece58a8e35c444afba6fa34873bc0244e32cd29/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-unboxed-closures-manual-impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-unboxed-closures-manual-impls.rs?ref=eece58a8e35c444afba6fa34873bc0244e32cd29", "patch": "@@ -8,24 +8,28 @@\n struct Foo;\n impl Fn<()> for Foo {\n //~^ ERROR the precise format of `Fn`-family traits' type parameters is subject to change\n+//~| ERROR manual implementations of `Fn` are experimental\n     extern \"rust-call\" fn call(self, args: ()) -> () {}\n     //~^ ERROR rust-call ABI is subject to change\n }\n struct Foo1;\n impl FnOnce() for Foo1 {\n //~^ ERROR associated type bindings are not allowed here\n+//~| ERROR manual implementations of `FnOnce` are experimental\n     extern \"rust-call\" fn call_once(self, args: ()) -> () {}\n     //~^ ERROR rust-call ABI is subject to change\n }\n struct Bar;\n impl FnMut<()> for Bar {\n //~^ ERROR the precise format of `Fn`-family traits' type parameters is subject to change\n+//~| ERROR manual implementations of `FnMut` are experimental\n     extern \"rust-call\" fn call_mut(&self, args: ()) -> () {}\n     //~^ ERROR rust-call ABI is subject to change\n }\n struct Baz;\n impl FnOnce<()> for Baz {\n //~^ ERROR the precise format of `Fn`-family traits' type parameters is subject to change\n+//~| ERROR manual implementations of `FnOnce` are experimental\n     extern \"rust-call\" fn call_once(&self, args: ()) -> () {}\n     //~^ ERROR rust-call ABI is subject to change\n }"}, {"sha": "22a1ce306188971b98c90c42c8fe8802697fd6b1", "filename": "src/test/ui/feature-gates/feature-gate-unboxed-closures-manual-impls.stderr", "status": "modified", "additions": 40, "deletions": 8, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/eece58a8e35c444afba6fa34873bc0244e32cd29/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-unboxed-closures-manual-impls.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/eece58a8e35c444afba6fa34873bc0244e32cd29/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-unboxed-closures-manual-impls.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-unboxed-closures-manual-impls.stderr?ref=eece58a8e35c444afba6fa34873bc0244e32cd29", "patch": "@@ -1,5 +1,5 @@\n error[E0658]: rust-call ABI is subject to change\n-  --> $DIR/feature-gate-unboxed-closures-manual-impls.rs:11:12\n+  --> $DIR/feature-gate-unboxed-closures-manual-impls.rs:12:12\n    |\n LL |     extern \"rust-call\" fn call(self, args: ()) -> () {}\n    |            ^^^^^^^^^^^\n@@ -8,7 +8,7 @@ LL |     extern \"rust-call\" fn call(self, args: ()) -> () {}\n    = help: add `#![feature(unboxed_closures)]` to the crate attributes to enable\n \n error[E0658]: rust-call ABI is subject to change\n-  --> $DIR/feature-gate-unboxed-closures-manual-impls.rs:17:12\n+  --> $DIR/feature-gate-unboxed-closures-manual-impls.rs:19:12\n    |\n LL |     extern \"rust-call\" fn call_once(self, args: ()) -> () {}\n    |            ^^^^^^^^^^^\n@@ -17,7 +17,7 @@ LL |     extern \"rust-call\" fn call_once(self, args: ()) -> () {}\n    = help: add `#![feature(unboxed_closures)]` to the crate attributes to enable\n \n error[E0658]: rust-call ABI is subject to change\n-  --> $DIR/feature-gate-unboxed-closures-manual-impls.rs:23:12\n+  --> $DIR/feature-gate-unboxed-closures-manual-impls.rs:26:12\n    |\n LL |     extern \"rust-call\" fn call_mut(&self, args: ()) -> () {}\n    |            ^^^^^^^^^^^\n@@ -26,7 +26,7 @@ LL |     extern \"rust-call\" fn call_mut(&self, args: ()) -> () {}\n    = help: add `#![feature(unboxed_closures)]` to the crate attributes to enable\n \n error[E0658]: rust-call ABI is subject to change\n-  --> $DIR/feature-gate-unboxed-closures-manual-impls.rs:29:12\n+  --> $DIR/feature-gate-unboxed-closures-manual-impls.rs:33:12\n    |\n LL |     extern \"rust-call\" fn call_once(&self, args: ()) -> () {}\n    |            ^^^^^^^^^^^\n@@ -44,13 +44,13 @@ LL | impl Fn<()> for Foo {\n    = help: add `#![feature(unboxed_closures)]` to the crate attributes to enable\n \n error[E0229]: associated type bindings are not allowed here\n-  --> $DIR/feature-gate-unboxed-closures-manual-impls.rs:15:6\n+  --> $DIR/feature-gate-unboxed-closures-manual-impls.rs:16:6\n    |\n LL | impl FnOnce() for Foo1 {\n    |      ^^^^^^^^ associated type not allowed here\n \n error[E0658]: the precise format of `Fn`-family traits' type parameters is subject to change\n-  --> $DIR/feature-gate-unboxed-closures-manual-impls.rs:21:6\n+  --> $DIR/feature-gate-unboxed-closures-manual-impls.rs:23:6\n    |\n LL | impl FnMut<()> for Bar {\n    |      ^^^^^^^^^ help: use parenthetical notation instead: `FnMut() -> ()`\n@@ -59,15 +59,47 @@ LL | impl FnMut<()> for Bar {\n    = help: add `#![feature(unboxed_closures)]` to the crate attributes to enable\n \n error[E0658]: the precise format of `Fn`-family traits' type parameters is subject to change\n-  --> $DIR/feature-gate-unboxed-closures-manual-impls.rs:27:6\n+  --> $DIR/feature-gate-unboxed-closures-manual-impls.rs:30:6\n    |\n LL | impl FnOnce<()> for Baz {\n    |      ^^^^^^^^^^ help: use parenthetical notation instead: `FnOnce() -> ()`\n    |\n    = note: see issue #29625 <https://github.com/rust-lang/rust/issues/29625> for more information\n    = help: add `#![feature(unboxed_closures)]` to the crate attributes to enable\n \n-error: aborting due to 8 previous errors\n+error[E0183]: manual implementations of `Fn` are experimental\n+  --> $DIR/feature-gate-unboxed-closures-manual-impls.rs:9:1\n+   |\n+LL | impl Fn<()> for Foo {\n+   | ^^^^^^^^^^^^^^^^^^^ manual implementations of `Fn` are experimental\n+   |\n+   = help: add `#![feature(unboxed_closures)]` to the crate attributes to enable\n+\n+error[E0183]: manual implementations of `FnMut` are experimental\n+  --> $DIR/feature-gate-unboxed-closures-manual-impls.rs:23:1\n+   |\n+LL | impl FnMut<()> for Bar {\n+   | ^^^^^^^^^^^^^^^^^^^^^^ manual implementations of `FnMut` are experimental\n+   |\n+   = help: add `#![feature(unboxed_closures)]` to the crate attributes to enable\n+\n+error[E0183]: manual implementations of `FnOnce` are experimental\n+  --> $DIR/feature-gate-unboxed-closures-manual-impls.rs:16:1\n+   |\n+LL | impl FnOnce() for Foo1 {\n+   | ^^^^^^^^^^^^^^^^^^^^^^ manual implementations of `FnOnce` are experimental\n+   |\n+   = help: add `#![feature(unboxed_closures)]` to the crate attributes to enable\n+\n+error[E0183]: manual implementations of `FnOnce` are experimental\n+  --> $DIR/feature-gate-unboxed-closures-manual-impls.rs:30:1\n+   |\n+LL | impl FnOnce<()> for Baz {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^ manual implementations of `FnOnce` are experimental\n+   |\n+   = help: add `#![feature(unboxed_closures)]` to the crate attributes to enable\n+\n+error: aborting due to 12 previous errors\n \n Some errors have detailed explanations: E0229, E0658.\n For more information about an error, try `rustc --explain E0229`."}, {"sha": "ebc5a2536f672b509c756fad5c34393927f9d7d6", "filename": "src/test/ui/feature-gates/feature-gate-unboxed-closures.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/eece58a8e35c444afba6fa34873bc0244e32cd29/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-unboxed-closures.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eece58a8e35c444afba6fa34873bc0244e32cd29/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-unboxed-closures.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-unboxed-closures.rs?ref=eece58a8e35c444afba6fa34873bc0244e32cd29", "patch": "@@ -4,6 +4,7 @@ struct Test;\n \n impl FnOnce<(u32, u32)> for Test {\n //~^ ERROR the precise format of `Fn`-family traits' type parameters is subject to change\n+//~| ERROR manual implementations of `FnOnce` are experimental\n     type Output = u32;\n \n     extern \"rust-call\" fn call_once(self, (a, b): (u32, u32)) -> u32 {"}, {"sha": "2c8915d0ac3346e43bdf9d794d8785fd918b80ac", "filename": "src/test/ui/feature-gates/feature-gate-unboxed-closures.stderr", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/eece58a8e35c444afba6fa34873bc0244e32cd29/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-unboxed-closures.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/eece58a8e35c444afba6fa34873bc0244e32cd29/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-unboxed-closures.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-unboxed-closures.stderr?ref=eece58a8e35c444afba6fa34873bc0244e32cd29", "patch": "@@ -1,5 +1,5 @@\n error[E0658]: rust-call ABI is subject to change\n-  --> $DIR/feature-gate-unboxed-closures.rs:9:12\n+  --> $DIR/feature-gate-unboxed-closures.rs:10:12\n    |\n LL |     extern \"rust-call\" fn call_once(self, (a, b): (u32, u32)) -> u32 {\n    |            ^^^^^^^^^^^\n@@ -16,6 +16,14 @@ LL | impl FnOnce<(u32, u32)> for Test {\n    = note: see issue #29625 <https://github.com/rust-lang/rust/issues/29625> for more information\n    = help: add `#![feature(unboxed_closures)]` to the crate attributes to enable\n \n-error: aborting due to 2 previous errors\n+error[E0183]: manual implementations of `FnOnce` are experimental\n+  --> $DIR/feature-gate-unboxed-closures.rs:5:1\n+   |\n+LL | impl FnOnce<(u32, u32)> for Test {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ manual implementations of `FnOnce` are experimental\n+   |\n+   = help: add `#![feature(unboxed_closures)]` to the crate attributes to enable\n+\n+error: aborting due to 3 previous errors\n \n For more information about this error, try `rustc --explain E0658`."}, {"sha": "4fc5f64ff9a4500c389738659413d7dca1012c0f", "filename": "src/test/ui/issues/issue-32122-1.fixed", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/eece58a8e35c444afba6fa34873bc0244e32cd29/src%2Ftest%2Fui%2Fissues%2Fissue-32122-1.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/eece58a8e35c444afba6fa34873bc0244e32cd29/src%2Ftest%2Fui%2Fissues%2Fissue-32122-1.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-32122-1.fixed?ref=eece58a8e35c444afba6fa34873bc0244e32cd29", "patch": "@@ -0,0 +1,17 @@\n+// run-rustfix\n+use std::ops::Deref;\n+\n+struct Foo(u8);\n+\n+impl Deref for Foo {\n+    type Target = u8;\n+    fn deref(&self) -> &Self::Target {\n+        &self.0\n+    }\n+}\n+\n+fn main() {\n+    let a = Foo(0);\n+    // Should suggest `&*` when coercing &ty to *const ty\n+    let _: *const u8 = &*a; //~ ERROR mismatched types\n+}"}, {"sha": "3c4859f07a2e7cc92e96b80732d4534b6901d760", "filename": "src/test/ui/issues/issue-32122-1.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/eece58a8e35c444afba6fa34873bc0244e32cd29/src%2Ftest%2Fui%2Fissues%2Fissue-32122-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eece58a8e35c444afba6fa34873bc0244e32cd29/src%2Ftest%2Fui%2Fissues%2Fissue-32122-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-32122-1.rs?ref=eece58a8e35c444afba6fa34873bc0244e32cd29", "patch": "@@ -0,0 +1,17 @@\n+// run-rustfix\n+use std::ops::Deref;\n+\n+struct Foo(u8);\n+\n+impl Deref for Foo {\n+    type Target = u8;\n+    fn deref(&self) -> &Self::Target {\n+        &self.0\n+    }\n+}\n+\n+fn main() {\n+    let a = Foo(0);\n+    // Should suggest `&*` when coercing &ty to *const ty\n+    let _: *const u8 = &a; //~ ERROR mismatched types\n+}"}, {"sha": "313de275c53ee625a74c0bec0ec01390d98414d2", "filename": "src/test/ui/issues/issue-32122-1.stderr", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/eece58a8e35c444afba6fa34873bc0244e32cd29/src%2Ftest%2Fui%2Fissues%2Fissue-32122-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/eece58a8e35c444afba6fa34873bc0244e32cd29/src%2Ftest%2Fui%2Fissues%2Fissue-32122-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-32122-1.stderr?ref=eece58a8e35c444afba6fa34873bc0244e32cd29", "patch": "@@ -0,0 +1,16 @@\n+error[E0308]: mismatched types\n+  --> $DIR/issue-32122-1.rs:16:24\n+   |\n+LL |     let _: *const u8 = &a;\n+   |            ---------   ^^\n+   |            |           |\n+   |            |           expected `u8`, found struct `Foo`\n+   |            |           help: consider dereferencing the reference: `&*a`\n+   |            expected due to this\n+   |\n+   = note: expected raw pointer `*const u8`\n+                found reference `&Foo`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "cee0e59297657dcd37b55295abad0cf2274373bc", "filename": "src/test/ui/issues/issue-32122-2.fixed", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/eece58a8e35c444afba6fa34873bc0244e32cd29/src%2Ftest%2Fui%2Fissues%2Fissue-32122-2.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/eece58a8e35c444afba6fa34873bc0244e32cd29/src%2Ftest%2Fui%2Fissues%2Fissue-32122-2.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-32122-2.fixed?ref=eece58a8e35c444afba6fa34873bc0244e32cd29", "patch": "@@ -0,0 +1,28 @@\n+// run-rustfix\n+use std::ops::Deref;\n+struct Bar(u8);\n+struct Foo(Bar);\n+struct Emm(Foo);\n+impl Deref for Bar{\n+    type Target = u8;\n+    fn deref(&self) -> &Self::Target {\n+        &self.0\n+    }\n+}\n+impl Deref for Foo {\n+    type Target = Bar;\n+    fn deref(&self) -> &Self::Target {\n+        &self.0\n+    }\n+}\n+impl Deref for Emm {\n+    type Target = Foo;\n+    fn deref(&self) -> &Self::Target {\n+        &self.0\n+    }\n+}\n+fn main() {\n+    let a = Emm(Foo(Bar(0)));\n+    // Should suggest `&***` even when deref is pretty deep\n+    let _: *const u8 = &***a; //~ ERROR mismatched types\n+}"}, {"sha": "39e9df4224e74a4beb436769e07d00107ef90062", "filename": "src/test/ui/issues/issue-32122-2.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/eece58a8e35c444afba6fa34873bc0244e32cd29/src%2Ftest%2Fui%2Fissues%2Fissue-32122-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eece58a8e35c444afba6fa34873bc0244e32cd29/src%2Ftest%2Fui%2Fissues%2Fissue-32122-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-32122-2.rs?ref=eece58a8e35c444afba6fa34873bc0244e32cd29", "patch": "@@ -0,0 +1,28 @@\n+// run-rustfix\n+use std::ops::Deref;\n+struct Bar(u8);\n+struct Foo(Bar);\n+struct Emm(Foo);\n+impl Deref for Bar{\n+    type Target = u8;\n+    fn deref(&self) -> &Self::Target {\n+        &self.0\n+    }\n+}\n+impl Deref for Foo {\n+    type Target = Bar;\n+    fn deref(&self) -> &Self::Target {\n+        &self.0\n+    }\n+}\n+impl Deref for Emm {\n+    type Target = Foo;\n+    fn deref(&self) -> &Self::Target {\n+        &self.0\n+    }\n+}\n+fn main() {\n+    let a = Emm(Foo(Bar(0)));\n+    // Should suggest `&***` even when deref is pretty deep\n+    let _: *const u8 = &a; //~ ERROR mismatched types\n+}"}, {"sha": "959a49507e4f510006710e42bd038bbf602269ed", "filename": "src/test/ui/issues/issue-32122-2.stderr", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/eece58a8e35c444afba6fa34873bc0244e32cd29/src%2Ftest%2Fui%2Fissues%2Fissue-32122-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/eece58a8e35c444afba6fa34873bc0244e32cd29/src%2Ftest%2Fui%2Fissues%2Fissue-32122-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-32122-2.stderr?ref=eece58a8e35c444afba6fa34873bc0244e32cd29", "patch": "@@ -0,0 +1,16 @@\n+error[E0308]: mismatched types\n+  --> $DIR/issue-32122-2.rs:27:24\n+   |\n+LL |     let _: *const u8 = &a;\n+   |            ---------   ^^\n+   |            |           |\n+   |            |           expected `u8`, found struct `Emm`\n+   |            |           help: consider dereferencing the reference: `&***a`\n+   |            expected due to this\n+   |\n+   = note: expected raw pointer `*const u8`\n+                found reference `&Emm`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "030677c879fb516cf0507e0cafd28c3e8799a0d2", "filename": "src/test/ui/issues/issue-3214.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/eece58a8e35c444afba6fa34873bc0244e32cd29/src%2Ftest%2Fui%2Fissues%2Fissue-3214.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eece58a8e35c444afba6fa34873bc0244e32cd29/src%2Ftest%2Fui%2Fissues%2Fissue-3214.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-3214.rs?ref=eece58a8e35c444afba6fa34873bc0244e32cd29", "patch": "@@ -1,10 +1,13 @@\n+// ignore-tidy-linelength\n+\n fn foo<T>() {\n     struct Foo {\n         x: T, //~ ERROR can't use generic parameters from outer function\n     }\n \n     impl<T> Drop for Foo<T> {\n         //~^ ERROR wrong number of type arguments\n+        //~| ERROR the type parameter `T` is not constrained by the impl trait, self type, or predicates\n         fn drop(&mut self) {}\n     }\n }"}, {"sha": "30bc6cb115ffc08a7f3beff28d73ffa53956aaa5", "filename": "src/test/ui/issues/issue-3214.stderr", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/eece58a8e35c444afba6fa34873bc0244e32cd29/src%2Ftest%2Fui%2Fissues%2Fissue-3214.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/eece58a8e35c444afba6fa34873bc0244e32cd29/src%2Ftest%2Fui%2Fissues%2Fissue-3214.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-3214.stderr?ref=eece58a8e35c444afba6fa34873bc0244e32cd29", "patch": "@@ -1,5 +1,5 @@\n error[E0401]: can't use generic parameters from outer function\n-  --> $DIR/issue-3214.rs:3:12\n+  --> $DIR/issue-3214.rs:5:12\n    |\n LL | fn foo<T>() {\n    |    --- - type parameter from outer function\n@@ -10,12 +10,18 @@ LL |         x: T,\n    |            ^ use of generic parameter from outer function\n \n error[E0107]: wrong number of type arguments: expected 0, found 1\n-  --> $DIR/issue-3214.rs:6:26\n+  --> $DIR/issue-3214.rs:8:26\n    |\n LL |     impl<T> Drop for Foo<T> {\n    |                          ^ unexpected type argument\n \n-error: aborting due to 2 previous errors\n+error[E0207]: the type parameter `T` is not constrained by the impl trait, self type, or predicates\n+  --> $DIR/issue-3214.rs:8:10\n+   |\n+LL |     impl<T> Drop for Foo<T> {\n+   |          ^ unconstrained type parameter\n+\n+error: aborting due to 3 previous errors\n \n-Some errors have detailed explanations: E0107, E0401.\n+Some errors have detailed explanations: E0107, E0207, E0401.\n For more information about an error, try `rustc --explain E0107`."}, {"sha": "bc70f8ffec2b288982c762941bd1b8a4543f711f", "filename": "src/test/ui/macros/issue-68060.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eece58a8e35c444afba6fa34873bc0244e32cd29/src%2Ftest%2Fui%2Fmacros%2Fissue-68060.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eece58a8e35c444afba6fa34873bc0244e32cd29/src%2Ftest%2Fui%2Fmacros%2Fissue-68060.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fissue-68060.rs?ref=eece58a8e35c444afba6fa34873bc0244e32cd29", "patch": "@@ -1,5 +1,3 @@\n-// build-fail\n-\n #![feature(track_caller)]\n \n fn main() {"}, {"sha": "3ea49e614e6337ba186d77cab71876efbdb8dc23", "filename": "src/test/ui/macros/issue-68060.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/eece58a8e35c444afba6fa34873bc0244e32cd29/src%2Ftest%2Fui%2Fmacros%2Fissue-68060.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/eece58a8e35c444afba6fa34873bc0244e32cd29/src%2Ftest%2Fui%2Fmacros%2Fissue-68060.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fissue-68060.stderr?ref=eece58a8e35c444afba6fa34873bc0244e32cd29", "patch": "@@ -1,5 +1,5 @@\n error: `#[target_feature(..)]` can only be applied to `unsafe` functions\n-  --> $DIR/issue-68060.rs:8:13\n+  --> $DIR/issue-68060.rs:6:13\n    |\n LL |             #[target_feature(enable = \"\")]\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ can only be applied to `unsafe` functions\n@@ -8,13 +8,13 @@ LL |             |_| (),\n    |             ------ not an `unsafe` function\n \n error: the feature named `` is not valid for this target\n-  --> $DIR/issue-68060.rs:8:30\n+  --> $DIR/issue-68060.rs:6:30\n    |\n LL |             #[target_feature(enable = \"\")]\n    |                              ^^^^^^^^^^^ `` is not valid for this target\n \n error[E0737]: `#[track_caller]` requires Rust ABI\n-  --> $DIR/issue-68060.rs:11:13\n+  --> $DIR/issue-68060.rs:9:13\n    |\n LL |             #[track_caller]\n    |             ^^^^^^^^^^^^^^^"}, {"sha": "1145f7786c78be36d5b10af8bd4c6428edd96d79", "filename": "src/test/ui/rfc-2091-track-caller/error-with-invalid-abi.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/eece58a8e35c444afba6fa34873bc0244e32cd29/src%2Ftest%2Fui%2Frfc-2091-track-caller%2Ferror-with-invalid-abi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eece58a8e35c444afba6fa34873bc0244e32cd29/src%2Ftest%2Fui%2Frfc-2091-track-caller%2Ferror-with-invalid-abi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2091-track-caller%2Ferror-with-invalid-abi.rs?ref=eece58a8e35c444afba6fa34873bc0244e32cd29", "patch": "@@ -4,4 +4,10 @@\n extern \"C\" fn f() {}\n //~^^ ERROR `#[track_caller]` requires Rust ABI\n \n+extern \"C\" {\n+    #[track_caller]\n+    fn g();\n+    //~^^ ERROR `#[track_caller]` requires Rust ABI\n+}\n+\n fn main() {}"}, {"sha": "e08c52fabd6b771e36f176481165b62c5e1e7b50", "filename": "src/test/ui/rfc-2091-track-caller/error-with-invalid-abi.stderr", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/eece58a8e35c444afba6fa34873bc0244e32cd29/src%2Ftest%2Fui%2Frfc-2091-track-caller%2Ferror-with-invalid-abi.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/eece58a8e35c444afba6fa34873bc0244e32cd29/src%2Ftest%2Fui%2Frfc-2091-track-caller%2Ferror-with-invalid-abi.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2091-track-caller%2Ferror-with-invalid-abi.stderr?ref=eece58a8e35c444afba6fa34873bc0244e32cd29", "patch": "@@ -4,6 +4,12 @@ error[E0737]: `#[track_caller]` requires Rust ABI\n LL | #[track_caller]\n    | ^^^^^^^^^^^^^^^\n \n-error: aborting due to previous error\n+error[E0737]: `#[track_caller]` requires Rust ABI\n+  --> $DIR/error-with-invalid-abi.rs:8:5\n+   |\n+LL |     #[track_caller]\n+   |     ^^^^^^^^^^^^^^^\n+\n+error: aborting due to 2 previous errors\n \n For more information about this error, try `rustc --explain E0737`."}, {"sha": "19c8c3dd4886b11e43c8458b4b33d08c63111789", "filename": "src/test/ui/target-feature/invalid-attribute.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/eece58a8e35c444afba6fa34873bc0244e32cd29/src%2Ftest%2Fui%2Ftarget-feature%2Finvalid-attribute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eece58a8e35c444afba6fa34873bc0244e32cd29/src%2Ftest%2Fui%2Ftarget-feature%2Finvalid-attribute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftarget-feature%2Finvalid-attribute.rs?ref=eece58a8e35c444afba6fa34873bc0244e32cd29", "patch": "@@ -65,9 +65,26 @@ trait Baz { }\n #[target_feature(enable = \"sse2\")]\n unsafe fn test() {}\n \n+trait Quux {\n+    fn foo();\n+}\n+\n+impl Quux for Foo {\n+    #[target_feature(enable = \"sse2\")]\n+    //~^ ERROR `#[target_feature(..)]` can only be applied to `unsafe` functions\n+    //~| NOTE can only be applied to `unsafe` functions\n+    fn foo() {}\n+    //~^ NOTE not an `unsafe` function\n+}\n+\n fn main() {\n     unsafe {\n         foo();\n         bar();\n     }\n+    #[target_feature(enable = \"sse2\")]\n+    //~^ ERROR `#[target_feature(..)]` can only be applied to `unsafe` functions\n+    //~| NOTE can only be applied to `unsafe` functions\n+    || {};\n+    //~^ NOTE not an `unsafe` function\n }"}, {"sha": "76273d66ac2cf2df4747c87672ae05f49912f649", "filename": "src/test/ui/target-feature/invalid-attribute.stderr", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/eece58a8e35c444afba6fa34873bc0244e32cd29/src%2Ftest%2Fui%2Ftarget-feature%2Finvalid-attribute.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/eece58a8e35c444afba6fa34873bc0244e32cd29/src%2Ftest%2Fui%2Ftarget-feature%2Finvalid-attribute.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftarget-feature%2Finvalid-attribute.stderr?ref=eece58a8e35c444afba6fa34873bc0244e32cd29", "patch": "@@ -91,5 +91,23 @@ error: cannot use `#[inline(always)]` with `#[target_feature]`\n LL | #[inline(always)]\n    | ^^^^^^^^^^^^^^^^^\n \n-error: aborting due to 12 previous errors\n+error: `#[target_feature(..)]` can only be applied to `unsafe` functions\n+  --> $DIR/invalid-attribute.rs:85:5\n+   |\n+LL |     #[target_feature(enable = \"sse2\")]\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ can only be applied to `unsafe` functions\n+...\n+LL |     || {};\n+   |     ----- not an `unsafe` function\n+\n+error: `#[target_feature(..)]` can only be applied to `unsafe` functions\n+  --> $DIR/invalid-attribute.rs:73:5\n+   |\n+LL |     #[target_feature(enable = \"sse2\")]\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ can only be applied to `unsafe` functions\n+...\n+LL |     fn foo() {}\n+   |     ----------- not an `unsafe` function\n+\n+error: aborting due to 14 previous errors\n "}]}