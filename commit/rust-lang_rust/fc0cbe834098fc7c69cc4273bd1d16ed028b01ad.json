{"sha": "fc0cbe834098fc7c69cc4273bd1d16ed028b01ad", "node_id": "C_kwDOAAsO6NoAKGZjMGNiZTgzNDA5OGZjN2M2OWNjNDI3M2JkMWQxNmVkMDI4YjAxYWQ", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2023-03-20T15:48:32Z"}, "committer": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2023-03-23T18:57:02Z"}, "message": "Don't split up TreatProjections and TreatParams anymore", "tree": {"sha": "5d840aa84a4d530ee91e5e0ee000a0392b16c042", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5d840aa84a4d530ee91e5e0ee000a0392b16c042"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fc0cbe834098fc7c69cc4273bd1d16ed028b01ad", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fc0cbe834098fc7c69cc4273bd1d16ed028b01ad", "html_url": "https://github.com/rust-lang/rust/commit/fc0cbe834098fc7c69cc4273bd1d16ed028b01ad", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fc0cbe834098fc7c69cc4273bd1d16ed028b01ad/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "df7fd9995f10627f25ccb325f693a11b3395a73c", "url": "https://api.github.com/repos/rust-lang/rust/commits/df7fd9995f10627f25ccb325f693a11b3395a73c", "html_url": "https://github.com/rust-lang/rust/commit/df7fd9995f10627f25ccb325f693a11b3395a73c"}], "stats": {"total": 133, "additions": 53, "deletions": 80}, "files": [{"sha": "3d37e0ce0c69badada2cf2cabd3884a83cc22974", "filename": "compiler/rustc_hir_analysis/src/coherence/inherent_impls.rs", "status": "modified", "additions": 3, "deletions": 13, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/fc0cbe834098fc7c69cc4273bd1d16ed028b01ad/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Finherent_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc0cbe834098fc7c69cc4273bd1d16ed028b01ad/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Finherent_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Finherent_impls.rs?ref=fc0cbe834098fc7c69cc4273bd1d16ed028b01ad", "patch": "@@ -11,7 +11,7 @@ use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n use rustc_hir::def::DefKind;\n use rustc_hir::def_id::{DefId, LocalDefId};\n-use rustc_middle::ty::fast_reject::{simplify_type, SimplifiedType, TreatParams, TreatProjections};\n+use rustc_middle::ty::fast_reject::{simplify_type, SimplifiedType, TreatParams};\n use rustc_middle::ty::{self, CrateInherentImpls, Ty, TyCtxt};\n use rustc_span::symbol::sym;\n \n@@ -97,12 +97,7 @@ impl<'tcx> InherentCollect<'tcx> {\n                 }\n             }\n \n-            if let Some(simp) = simplify_type(\n-                self.tcx,\n-                self_ty,\n-                TreatParams::AsCandidateKey,\n-                TreatProjections::AsCandidateKey,\n-            ) {\n+            if let Some(simp) = simplify_type(self.tcx, self_ty, TreatParams::AsCandidateKey) {\n                 self.impls_map.incoherent_impls.entry(simp).or_default().push(impl_def_id);\n             } else {\n                 bug!(\"unexpected self type: {:?}\", self_ty);\n@@ -162,12 +157,7 @@ impl<'tcx> InherentCollect<'tcx> {\n             }\n         }\n \n-        if let Some(simp) = simplify_type(\n-            self.tcx,\n-            ty,\n-            TreatParams::AsCandidateKey,\n-            TreatProjections::AsCandidateKey,\n-        ) {\n+        if let Some(simp) = simplify_type(self.tcx, ty, TreatParams::AsCandidateKey) {\n             self.impls_map.incoherent_impls.entry(simp).or_default().push(impl_def_id);\n         } else {\n             bug!(\"unexpected primitive type: {:?}\", ty);"}, {"sha": "dab709e17f0501163cf98c2aac1403ff40247128", "filename": "compiler/rustc_hir_typeck/src/method/probe.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fc0cbe834098fc7c69cc4273bd1d16ed028b01ad/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc0cbe834098fc7c69cc4273bd1d16ed028b01ad/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs?ref=fc0cbe834098fc7c69cc4273bd1d16ed028b01ad", "patch": "@@ -16,7 +16,6 @@ use rustc_infer::infer::canonical::{Canonical, QueryResponse};\n use rustc_infer::infer::DefineOpaqueTypes;\n use rustc_infer::infer::{self, InferOk, TyCtxtInferExt};\n use rustc_middle::middle::stability;\n-use rustc_middle::ty::fast_reject::TreatProjections;\n use rustc_middle::ty::fast_reject::{simplify_type, TreatParams};\n use rustc_middle::ty::AssocItem;\n use rustc_middle::ty::GenericParamDefKind;\n@@ -701,7 +700,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n     }\n \n     fn assemble_inherent_candidates_for_incoherent_ty(&mut self, self_ty: Ty<'tcx>) {\n-        let Some(simp) = simplify_type(self.tcx, self_ty, TreatParams::AsCandidateKey, TreatProjections::AsCandidateKey) else {\n+        let Some(simp) = simplify_type(self.tcx, self_ty, TreatParams::AsCandidateKey) else {\n             bug!(\"unexpected incoherent type: {:?}\", self_ty)\n         };\n         for &impl_def_id in self.tcx.incoherent_impls(simp) {"}, {"sha": "55f684599e7cc7bb256fadf8067adc4cc314d724", "filename": "compiler/rustc_hir_typeck/src/method/suggest.rs", "status": "modified", "additions": 6, "deletions": 14, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/fc0cbe834098fc7c69cc4273bd1d16ed028b01ad/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc0cbe834098fc7c69cc4273bd1d16ed028b01ad/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs?ref=fc0cbe834098fc7c69cc4273bd1d16ed028b01ad", "patch": "@@ -25,7 +25,6 @@ use rustc_infer::infer::{\n use rustc_middle::infer::unify_key::{ConstVariableOrigin, ConstVariableOriginKind};\n use rustc_middle::traits::util::supertraits;\n use rustc_middle::ty::fast_reject::DeepRejectCtxt;\n-use rustc_middle::ty::fast_reject::TreatProjections;\n use rustc_middle::ty::fast_reject::{simplify_type, TreatParams};\n use rustc_middle::ty::print::{with_crate_prefix, with_forced_trimmed_paths};\n use rustc_middle::ty::{self, GenericArgKind, Ty, TyCtxt, TypeVisitableExt};\n@@ -1524,7 +1523,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             .into_iter()\n             .any(|info| self.associated_value(info.def_id, item_name).is_some());\n         let found_assoc = |ty: Ty<'tcx>| {\n-            simplify_type(tcx, ty, TreatParams::AsCandidateKey, TreatProjections::AsCandidateKey)\n+            simplify_type(tcx, ty, TreatParams::AsCandidateKey)\n                 .and_then(|simp| {\n                     tcx.incoherent_impls(simp)\n                         .iter()\n@@ -2653,12 +2652,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 // FIXME: Even though negative bounds are not implemented, we could maybe handle\n                 // cases where a positive bound implies a negative impl.\n                 (candidates, Vec::new())\n-            } else if let Some(simp_rcvr_ty) = simplify_type(\n-                self.tcx,\n-                rcvr_ty,\n-                TreatParams::ForLookup,\n-                TreatProjections::ForLookup,\n-            ) {\n+            } else if let Some(simp_rcvr_ty) =\n+                simplify_type(self.tcx, rcvr_ty, TreatParams::ForLookup)\n+            {\n                 let mut potential_candidates = Vec::new();\n                 let mut explicitly_negative = Vec::new();\n                 for candidate in candidates {\n@@ -2671,12 +2667,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         })\n                         .any(|imp_did| {\n                             let imp = self.tcx.impl_trait_ref(imp_did).unwrap().subst_identity();\n-                            let imp_simp = simplify_type(\n-                                self.tcx,\n-                                imp.self_ty(),\n-                                TreatParams::ForLookup,\n-                                TreatProjections::ForLookup,\n-                            );\n+                            let imp_simp =\n+                                simplify_type(self.tcx, imp.self_ty(), TreatParams::ForLookup);\n                             imp_simp.map_or(false, |s| s == simp_rcvr_ty)\n                         })\n                     {"}, {"sha": "2652a4280d37391da594aab264c9d60a02b83b0b", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fc0cbe834098fc7c69cc4273bd1d16ed028b01ad/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc0cbe834098fc7c69cc4273bd1d16ed028b01ad/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=fc0cbe834098fc7c69cc4273bd1d16ed028b01ad", "patch": "@@ -27,7 +27,7 @@ use rustc_middle::mir::interpret;\n use rustc_middle::query::LocalCrate;\n use rustc_middle::traits::specialization_graph;\n use rustc_middle::ty::codec::TyEncoder;\n-use rustc_middle::ty::fast_reject::{self, SimplifiedType, TreatParams, TreatProjections};\n+use rustc_middle::ty::fast_reject::{self, SimplifiedType, TreatParams};\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::{self, SymbolName, Ty, TyCtxt};\n use rustc_middle::util::common::to_readable_str;\n@@ -1881,7 +1881,6 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                         self.tcx,\n                         trait_ref.self_ty(),\n                         TreatParams::AsCandidateKey,\n-                        TreatProjections::AsCandidateKey,\n                     );\n \n                     fx_hash_map"}, {"sha": "669d50a7fda6705f6ec93814278767b33ed4ad74", "filename": "compiler/rustc_middle/src/ty/fast_reject.rs", "status": "modified", "additions": 22, "deletions": 15, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/fc0cbe834098fc7c69cc4273bd1d16ed028b01ad/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffast_reject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc0cbe834098fc7c69cc4273bd1d16ed028b01ad/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffast_reject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffast_reject.rs?ref=fc0cbe834098fc7c69cc4273bd1d16ed028b01ad", "patch": "@@ -56,21 +56,22 @@ pub enum TreatParams {\n     AsCandidateKey,\n     /// Treat parameters as placeholders in the given environment. This is the\n     /// correct mode for *lookup*, as during candidate selection.\n+    ///\n+    /// This also treats projections with inference variables as infer vars\n+    /// since they could be further normalized.\n     ForLookup,\n+    /// Treat parameters as placeholders in the given environment. This is the\n+    /// correct mode for *lookup*, as during candidate selection.\n+    ///\n+    /// N.B. during deep rejection, this acts identically to `ForLookup`.\n+    NextSolverLookup,\n }\n \n /// During fast-rejection, we have the choice of treating projection types\n /// as either simplifyable or not, depending on whether we expect the projection\n /// to be normalized/rigid.\n #[derive(PartialEq, Eq, Debug, Clone, Copy)]\n pub enum TreatProjections {\n-    /// In candidates, we may be able to normalize the projection\n-    /// after instantiating the candidate and equating it with a goal.\n-    ///\n-    /// We must assume that the `impl<T> Trait<T> for <T as Id>::This`\n-    /// can apply to all self types so we don't return a simplified type\n-    /// for `<T as Id>::This`.\n-    AsCandidateKey,\n     /// In the old solver we don't try to normalize projections\n     /// when looking up impls and only access them by using the\n     /// current self type. This means that if the self type is\n@@ -107,7 +108,6 @@ pub fn simplify_type<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     ty: Ty<'tcx>,\n     treat_params: TreatParams,\n-    treat_projections: TreatProjections,\n ) -> Option<SimplifiedType> {\n     match *ty.kind() {\n         ty::Bool => Some(BoolSimplifiedType),\n@@ -136,13 +136,20 @@ pub fn simplify_type<'tcx>(\n         ty::FnPtr(f) => Some(FunctionSimplifiedType(f.skip_binder().inputs().len())),\n         ty::Placeholder(..) => Some(PlaceholderSimplifiedType),\n         ty::Param(_) => match treat_params {\n-            TreatParams::ForLookup => Some(PlaceholderSimplifiedType),\n+            TreatParams::ForLookup | TreatParams::NextSolverLookup => {\n+                Some(PlaceholderSimplifiedType)\n+            }\n             TreatParams::AsCandidateKey => None,\n         },\n-        ty::Alias(..) => match treat_projections {\n-            TreatProjections::ForLookup if !ty.needs_infer() => Some(PlaceholderSimplifiedType),\n-            TreatProjections::NextSolverLookup => Some(PlaceholderSimplifiedType),\n-            TreatProjections::AsCandidateKey | TreatProjections::ForLookup => None,\n+        ty::Alias(..) => match treat_params {\n+            // When treating `ty::Param` as a placeholder, projections also\n+            // don't unify with anything else as long as they are fully normalized.\n+            //\n+            // We will have to be careful with lazy normalization here.\n+            // FIXME(lazy_normalization): This is probably not right...\n+            TreatParams::ForLookup if !ty.has_non_region_infer() => Some(PlaceholderSimplifiedType),\n+            TreatParams::NextSolverLookup => Some(PlaceholderSimplifiedType),\n+            TreatParams::ForLookup | TreatParams::AsCandidateKey => None,\n         },\n         ty::Foreign(def_id) => Some(ForeignSimplifiedType(def_id)),\n         ty::Bound(..) | ty::Infer(_) | ty::Error(_) => None,\n@@ -310,7 +317,7 @@ impl DeepRejectCtxt {\n             // Depending on the value of `treat_obligation_params`, we either\n             // treat generic parameters like placeholders or like inference variables.\n             ty::Param(_) => match self.treat_obligation_params {\n-                TreatParams::ForLookup => false,\n+                TreatParams::ForLookup | TreatParams::NextSolverLookup => false,\n                 TreatParams::AsCandidateKey => true,\n             },\n \n@@ -348,7 +355,7 @@ impl DeepRejectCtxt {\n         let k = impl_ct.kind();\n         match obligation_ct.kind() {\n             ty::ConstKind::Param(_) => match self.treat_obligation_params {\n-                TreatParams::ForLookup => false,\n+                TreatParams::ForLookup | TreatParams::NextSolverLookup => false,\n                 TreatParams::AsCandidateKey => true,\n             },\n "}, {"sha": "6747da7abd3af571fdfb5aa362da403c44d77816", "filename": "compiler/rustc_middle/src/ty/trait_def.rs", "status": "modified", "additions": 11, "deletions": 15, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/fc0cbe834098fc7c69cc4273bd1d16ed028b01ad/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftrait_def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc0cbe834098fc7c69cc4273bd1d16ed028b01ad/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftrait_def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftrait_def.rs?ref=fc0cbe834098fc7c69cc4273bd1d16ed028b01ad", "patch": "@@ -153,12 +153,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         self_ty: Ty<'tcx>,\n     ) -> impl Iterator<Item = DefId> + 'tcx {\n         let impls = self.trait_impls_of(trait_def_id);\n-        if let Some(simp) = fast_reject::simplify_type(\n-            self,\n-            self_ty,\n-            TreatParams::AsCandidateKey,\n-            TreatProjections::AsCandidateKey,\n-        ) {\n+        if let Some(simp) = fast_reject::simplify_type(self, self_ty, TreatParams::AsCandidateKey) {\n             if let Some(impls) = impls.non_blanket_impls.get(&simp) {\n                 return impls.iter().copied();\n             }\n@@ -191,13 +186,17 @@ impl<'tcx> TyCtxt<'tcx> {\n             }\n         }\n \n+        // Note that we're using `TreatParams::ForLookup` to query `non_blanket_impls` while using\n+        // `TreatParams::AsCandidateKey` while actually adding them.\n+        let treat_params = match treat_projections {\n+            TreatProjections::NextSolverLookup => TreatParams::NextSolverLookup,\n+            TreatProjections::ForLookup => TreatParams::ForLookup,\n+        };\n         // This way, when searching for some impl for `T: Trait`, we do not look at any impls\n         // whose outer level is not a parameter or projection. Especially for things like\n         // `T: Clone` this is incredibly useful as we would otherwise look at all the impls\n         // of `Clone` for `Option<T>`, `Vec<T>`, `ConcreteType` and so on.\n-        if let Some(simp) =\n-            fast_reject::simplify_type(self, self_ty, TreatParams::ForLookup, treat_projections)\n-        {\n+        if let Some(simp) = fast_reject::simplify_type(self, self_ty, treat_params) {\n             if let Some(impls) = impls.non_blanket_impls.get(&simp) {\n                 for &impl_def_id in impls {\n                     if let result @ Some(_) = f(impl_def_id) {\n@@ -258,12 +257,9 @@ pub(super) fn trait_impls_of_provider(tcx: TyCtxt<'_>, trait_id: DefId) -> Trait\n             continue;\n         }\n \n-        if let Some(simplified_self_ty) = fast_reject::simplify_type(\n-            tcx,\n-            impl_self_ty,\n-            TreatParams::AsCandidateKey,\n-            TreatProjections::AsCandidateKey,\n-        ) {\n+        if let Some(simplified_self_ty) =\n+            fast_reject::simplify_type(tcx, impl_self_ty, TreatParams::AsCandidateKey)\n+        {\n             impls.non_blanket_impls.entry(simplified_self_ty).or_default().push(impl_def_id);\n         } else {\n             impls.blanket_impls.push(impl_def_id);"}, {"sha": "11eb968a4152e695d8e6013c18b286ff3b0d87a9", "filename": "compiler/rustc_trait_selection/src/traits/specialize/specialization_graph.rs", "status": "modified", "additions": 9, "deletions": 19, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/fc0cbe834098fc7c69cc4273bd1d16ed028b01ad/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc0cbe834098fc7c69cc4273bd1d16ed028b01ad/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs?ref=fc0cbe834098fc7c69cc4273bd1d16ed028b01ad", "patch": "@@ -3,7 +3,7 @@ use super::OverlapError;\n use crate::traits;\n use rustc_errors::ErrorGuaranteed;\n use rustc_hir::def_id::DefId;\n-use rustc_middle::ty::fast_reject::{self, SimplifiedType, TreatParams, TreatProjections};\n+use rustc_middle::ty::fast_reject::{self, SimplifiedType, TreatParams};\n use rustc_middle::ty::{self, TyCtxt, TypeVisitableExt};\n \n pub use rustc_middle::traits::specialization_graph::*;\n@@ -49,12 +49,9 @@ impl<'tcx> ChildrenExt<'tcx> for Children {\n     /// Insert an impl into this set of children without comparing to any existing impls.\n     fn insert_blindly(&mut self, tcx: TyCtxt<'tcx>, impl_def_id: DefId) {\n         let trait_ref = tcx.impl_trait_ref(impl_def_id).unwrap().skip_binder();\n-        if let Some(st) = fast_reject::simplify_type(\n-            tcx,\n-            trait_ref.self_ty(),\n-            TreatParams::AsCandidateKey,\n-            TreatProjections::AsCandidateKey,\n-        ) {\n+        if let Some(st) =\n+            fast_reject::simplify_type(tcx, trait_ref.self_ty(), TreatParams::AsCandidateKey)\n+        {\n             debug!(\"insert_blindly: impl_def_id={:?} st={:?}\", impl_def_id, st);\n             self.non_blanket_impls.entry(st).or_default().push(impl_def_id)\n         } else {\n@@ -69,12 +66,9 @@ impl<'tcx> ChildrenExt<'tcx> for Children {\n     fn remove_existing(&mut self, tcx: TyCtxt<'tcx>, impl_def_id: DefId) {\n         let trait_ref = tcx.impl_trait_ref(impl_def_id).unwrap().skip_binder();\n         let vec: &mut Vec<DefId>;\n-        if let Some(st) = fast_reject::simplify_type(\n-            tcx,\n-            trait_ref.self_ty(),\n-            TreatParams::AsCandidateKey,\n-            TreatProjections::AsCandidateKey,\n-        ) {\n+        if let Some(st) =\n+            fast_reject::simplify_type(tcx, trait_ref.self_ty(), TreatParams::AsCandidateKey)\n+        {\n             debug!(\"remove_existing: impl_def_id={:?} st={:?}\", impl_def_id, st);\n             vec = self.non_blanket_impls.get_mut(&st).unwrap();\n         } else {\n@@ -310,12 +304,8 @@ impl<'tcx> GraphExt<'tcx> for Graph {\n \n         let mut parent = trait_def_id;\n         let mut last_lint = None;\n-        let simplified = fast_reject::simplify_type(\n-            tcx,\n-            trait_ref.self_ty(),\n-            TreatParams::AsCandidateKey,\n-            TreatProjections::AsCandidateKey,\n-        );\n+        let simplified =\n+            fast_reject::simplify_type(tcx, trait_ref.self_ty(), TreatParams::AsCandidateKey);\n \n         // Descend the specialization tree, where `parent` is the current parent node.\n         loop {"}]}