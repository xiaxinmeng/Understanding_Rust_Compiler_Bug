{"sha": "8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhiOTc5NzM5NzEzZjU0ZWI5MzE1ZWQ1Zjg4YjhmMDZkNDNkMGJiYjU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-10-16T17:52:25Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-10-16T17:52:25Z"}, "message": "auto merge of #18064 : luqmana/rust/remove-reflection, r=nick29581\n\nOut goes reflection! This means your code will break if you used the `:?` format specifier, anything else from libdebug, or the `visit_tydesc` intrinsic directly.\r\n\r\nCloses #18046.\r\n\r\n[breaking-change]", "tree": {"sha": "aa374aaa783ed319e49592dcd40cf7b6416d53b8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/aa374aaa783ed319e49592dcd40cf7b6416d53b8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "html_url": "https://github.com/rust-lang/rust/commit/8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b6e0d3a5bf4c88650a22f605f822e02c6b163580", "url": "https://api.github.com/repos/rust-lang/rust/commits/b6e0d3a5bf4c88650a22f605f822e02c6b163580", "html_url": "https://github.com/rust-lang/rust/commit/b6e0d3a5bf4c88650a22f605f822e02c6b163580"}, {"sha": "78992485047f7600a0d34c5f573b30be262b2e4b", "url": "https://api.github.com/repos/rust-lang/rust/commits/78992485047f7600a0d34c5f573b30be262b2e4b", "html_url": "https://github.com/rust-lang/rust/commit/78992485047f7600a0d34c5f573b30be262b2e4b"}], "stats": {"total": 3635, "additions": 709, "deletions": 2926}, "files": [{"sha": "fd41666275b502c474b5bb85752150818b44223a", "filename": "mk/crates.mk", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/mk%2Fcrates.mk", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/mk%2Fcrates.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcrates.mk?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -51,7 +51,7 @@\n \n TARGET_CRATES := libc std green native flate arena glob term semver \\\n                  uuid serialize sync getopts collections num test time rand \\\n-                 url log regex graphviz core rbml rlibc alloc debug rustrt \\\n+                 url log regex graphviz core rbml rlibc alloc rustrt \\\n                  unicode\n HOST_CRATES := syntax rustc rustdoc fourcc hexfloat regex_macros fmt_macros \\\n \t       rustc_llvm rustc_back\n@@ -63,20 +63,19 @@ DEPS_libc := core\n DEPS_rlibc := core\n DEPS_unicode := core\n DEPS_alloc := core libc native:jemalloc\n-DEPS_debug := std\n DEPS_rustrt := alloc core libc collections native:rustrt_native\n DEPS_std := core libc rand alloc collections rustrt sync unicode \\\n \tnative:rust_builtin native:backtrace\n DEPS_graphviz := std\n DEPS_green := std native:context_switch\n DEPS_native := std\n-DEPS_syntax := std term serialize log fmt_macros debug arena libc\n+DEPS_syntax := std term serialize log fmt_macros arena libc\n DEPS_rustc := syntax flate arena serialize getopts rbml \\\n-              time log graphviz debug rustc_llvm rustc_back\n+              time log graphviz rustc_llvm rustc_back\n DEPS_rustc_llvm := native:rustllvm libc std\n DEPS_rustc_back := std syntax rustc_llvm flate log libc\n DEPS_rustdoc := rustc native:hoedown serialize getopts \\\n-                test time debug\n+                test time\n DEPS_flate := std native:miniz\n DEPS_arena := std\n DEPS_graphviz := std"}, {"sha": "dfdadb3546bac9195cc7dd44bffd191c44bf2cc0", "filename": "src/doc/reference.md", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -1177,7 +1177,7 @@ This is a list of behaviour not considered *unsafe* in Rust terms, but that may\n be undesired.\n \n * Deadlocks\n-* Reading data from private fields (`std::repr`, `format!(\"{:?}\", x)`)\n+* Reading data from private fields (`std::repr`)\n * Leaks due to reference count cycles, even in the global heap\n * Exiting without calling destructors\n * Sending signals\n@@ -2279,8 +2279,6 @@ These types help drive the compiler's analysis\n   : The lifetime parameter should be considered invariant\n * `malloc`\n   : Allocate memory on the managed heap.\n-* `opaque`\n-  : ___Needs filling in___\n * `owned_box`\n   : ___Needs filling in___\n * `stack_exhausted`\n@@ -2295,8 +2293,6 @@ These types help drive the compiler's analysis\n   : The type parameter should be considered invariant\n * `ty_desc`\n   : ___Needs filling in___\n-* `ty_visitor`\n-  : ___Needs filling in___\n \n > **Note:** This list is likely to become out of date. We should auto-generate\n > it from `librustc/middle/lang_items.rs`."}, {"sha": "c447cb46c532a81c07b76849d4386f01b70d4620", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -317,8 +317,6 @@ mod tests {\n \n         assert_eq!((*arc_v)[2], 3);\n         assert_eq!((*arc_v)[4], 5);\n-\n-        info!(\"{:?}\", arc_v);\n     }\n \n     #[test]"}, {"sha": "2df9a585fec994ff01a178163f4244e6632f15a1", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -77,7 +77,6 @@ extern crate libc;\n \n // Allow testing this library\n \n-#[cfg(test)] extern crate debug;\n #[cfg(test)] extern crate native;\n #[cfg(test)] #[phase(plugin, link)] extern crate std;\n #[cfg(test)] #[phase(plugin, link)] extern crate log;"}, {"sha": "4ac06a884a66958089d910ff18fbc91353db528c", "filename": "src/libcollections/hash/sip.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibcollections%2Fhash%2Fsip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibcollections%2Fhash%2Fsip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fhash%2Fsip.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -402,7 +402,7 @@ mod tests {\n             debug!(\"siphash test {}: {}\", t, buf);\n             let vec = u8to64_le!(vecs[t], 0);\n             let out = hash_with_keys(k0, k1, &Bytes(buf.as_slice()));\n-            debug!(\"got {:?}, expected {:?}\", out, vec);\n+            debug!(\"got {}, expected {}\", out, vec);\n             assert_eq!(vec, out);\n \n             state_full.reset();\n@@ -412,9 +412,6 @@ mod tests {\n             let v = to_hex_str(&vecs[t]);\n             debug!(\"{}: ({}) => inc={} full={}\", t, v, i, f);\n \n-            debug!(\"full state {:?}\", state_full);\n-            debug!(\"inc  state {:?}\", state_inc);\n-\n             assert_eq!(f, i);\n             assert_eq!(f, v);\n "}, {"sha": "9f9894348203b0cd3bd743572ad6eff21a843e79", "filename": "src/libcollections/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibcollections%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibcollections%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flib.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -33,7 +33,6 @@ extern crate alloc;\n \n #[cfg(test)] extern crate native;\n #[cfg(test)] extern crate test;\n-#[cfg(test)] extern crate debug;\n \n #[cfg(test)] #[phase(plugin, link)] extern crate std;\n #[cfg(test)] #[phase(plugin, link)] extern crate log;"}, {"sha": "1ae63d11fbe8d7ed482e08ab0cd5e9f33df29142", "filename": "src/libcollections/ringbuf.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibcollections%2Fringbuf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibcollections%2Fringbuf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fringbuf.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -551,21 +551,21 @@ mod tests {\n         assert_eq!(d.len(), 3u);\n         d.push(137);\n         assert_eq!(d.len(), 4u);\n-        debug!(\"{:?}\", d.front());\n+        debug!(\"{}\", d.front());\n         assert_eq!(*d.front().unwrap(), 42);\n-        debug!(\"{:?}\", d.back());\n+        debug!(\"{}\", d.back());\n         assert_eq!(*d.back().unwrap(), 137);\n         let mut i = d.pop_front();\n-        debug!(\"{:?}\", i);\n+        debug!(\"{}\", i);\n         assert_eq!(i, Some(42));\n         i = d.pop();\n-        debug!(\"{:?}\", i);\n+        debug!(\"{}\", i);\n         assert_eq!(i, Some(137));\n         i = d.pop();\n-        debug!(\"{:?}\", i);\n+        debug!(\"{}\", i);\n         assert_eq!(i, Some(137));\n         i = d.pop();\n-        debug!(\"{:?}\", i);\n+        debug!(\"{}\", i);\n         assert_eq!(i, Some(17));\n         assert_eq!(d.len(), 0u);\n         d.push(3);\n@@ -576,10 +576,10 @@ mod tests {\n         assert_eq!(d.len(), 3u);\n         d.push_front(1);\n         assert_eq!(d.len(), 4u);\n-        debug!(\"{:?}\", d.get(0));\n-        debug!(\"{:?}\", d.get(1));\n-        debug!(\"{:?}\", d.get(2));\n-        debug!(\"{:?}\", d.get(3));\n+        debug!(\"{}\", d.get(0));\n+        debug!(\"{}\", d.get(1));\n+        debug!(\"{}\", d.get(2));\n+        debug!(\"{}\", d.get(3));\n         assert_eq!(*d.get(0), 1);\n         assert_eq!(*d.get(1), 2);\n         assert_eq!(*d.get(2), 3);"}, {"sha": "3d593a0d026d09555b767306597a165df0fb3eee", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -58,17 +58,21 @@ pub struct TyDesc {\n     pub drop_glue: GlueFn,\n \n     // Called by reflection visitor to visit a value of type `T`\n+    #[cfg(stage0)]\n     pub visit_glue: GlueFn,\n \n     // Name corresponding to the type\n     pub name: &'static str,\n }\n \n+#[cfg(stage0)]\n #[lang=\"opaque\"]\n pub enum Opaque { }\n \n+#[cfg(stage0)]\n pub type Disr = u64;\n \n+#[cfg(stage0)]\n #[lang=\"ty_visitor\"]\n pub trait TyVisitor {\n     fn visit_bot(&mut self) -> bool;\n@@ -327,8 +331,6 @@ extern \"rust-intrinsic\" {\n     /// Returns `true` if a type is managed (will be allocated on the local heap)\n     pub fn owns_managed<T>() -> bool;\n \n-    pub fn visit_tydesc(td: *const TyDesc, tv: &mut TyVisitor);\n-\n     /// Calculates the offset from a pointer. The offset *must* be in-bounds of\n     /// the object, or one-byte-past-the-end. An arithmetic overflow is also\n     /// undefined behaviour."}, {"sha": "0b04a07ea888af5a667fa1ad61015c0382141c5d", "filename": "src/libdebug/fmt.rs", "status": "removed", "additions": 0, "deletions": 53, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/b6e0d3a5bf4c88650a22f605f822e02c6b163580/src%2Flibdebug%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6e0d3a5bf4c88650a22f605f822e02c6b163580/src%2Flibdebug%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibdebug%2Ffmt.rs?ref=b6e0d3a5bf4c88650a22f605f822e02c6b163580", "patch": "@@ -1,53 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Implementation of the `{:?}` format qualifier\n-//!\n-//! This module contains the `Poly` trait which is used to implement the `{:?}`\n-//! format expression in formatting macros. This trait is defined for all types\n-//! automatically, so it is likely not necessary to use this module manually\n-\n-use std::fmt;\n-\n-use repr;\n-\n-/// Format trait for the `?` character\n-pub trait Poly {\n-    /// Formats the value using the given formatter.\n-    #[experimental]\n-    fn fmt(&self, &mut fmt::Formatter) -> fmt::Result;\n-}\n-\n-#[doc(hidden)]\n-pub fn secret_poly<T: Poly>(x: &T, fmt: &mut fmt::Formatter) -> fmt::Result {\n-    // FIXME #11938 - UFCS would make us able call the this method\n-    //                directly Poly::fmt(x, fmt).\n-    x.fmt(fmt)\n-}\n-\n-impl<T> Poly for T {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        match (f.width, f.precision) {\n-            (None, None) => {\n-                match repr::write_repr(f, self) {\n-                    Ok(()) => Ok(()),\n-                    Err(..) => Err(fmt::WriteError),\n-                }\n-            }\n-\n-            // If we have a specified width for formatting, then we have to make\n-            // this allocation of a new string\n-            _ => {\n-                let s = repr::repr_to_string(self);\n-                f.pad(s.as_slice())\n-            }\n-        }\n-    }\n-}"}, {"sha": "459e1592f673417b4437a7abd583bd5bc4a42c56", "filename": "src/libdebug/lib.rs", "status": "removed", "additions": 0, "deletions": 33, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/b6e0d3a5bf4c88650a22f605f822e02c6b163580/src%2Flibdebug%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6e0d3a5bf4c88650a22f605f822e02c6b163580/src%2Flibdebug%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibdebug%2Flib.rs?ref=b6e0d3a5bf4c88650a22f605f822e02c6b163580", "patch": "@@ -1,33 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Debugging utilities for Rust programs\n-//!\n-//! This crate is intended to provide useful functionality when debugging\n-//! programs, such as reflection for printing values. This crate is currently\n-//! entirely experimental as its makeup will likely change over time.\n-//! Additionally, it is not guaranteed that functionality such as reflection\n-//! will persist into the future.\n-\n-#![crate_name = \"debug\"]\n-#![experimental]\n-#![license = \"MIT/ASL2\"]\n-#![crate_type = \"rlib\"]\n-#![crate_type = \"dylib\"]\n-#![doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n-       html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n-       html_root_url = \"http://doc.rust-lang.org/nightly/\")]\n-#![experimental]\n-#![feature(macro_rules)]\n-#![allow(experimental)]\n-\n-pub mod fmt;\n-pub mod reflect;\n-pub mod repr;"}, {"sha": "1e771a2b40a2354caa9d4c1d0cac12b3676b4235", "filename": "src/libdebug/reflect.rs", "status": "removed", "additions": 0, "deletions": 404, "changes": 404, "blob_url": "https://github.com/rust-lang/rust/blob/b6e0d3a5bf4c88650a22f605f822e02c6b163580/src%2Flibdebug%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6e0d3a5bf4c88650a22f605f822e02c6b163580/src%2Flibdebug%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibdebug%2Freflect.rs?ref=b6e0d3a5bf4c88650a22f605f822e02c6b163580", "patch": "@@ -1,404 +0,0 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-/*!\n-\n-Runtime type reflection\n-\n-*/\n-\n-#![allow(missing_doc)]\n-\n-use std::intrinsics::{Disr, Opaque, TyDesc, TyVisitor};\n-use std::mem;\n-\n-/**\n- * Trait for visitor that wishes to reflect on data.\n- *\n- * To use this, create a struct that encapsulates the set of pointers you wish\n- * to walk through a data structure, and implement both `MovePtr` for it as well\n- * as `TyVisitor`; then build a MovePtrAdaptor wrapped around your struct.\n- */\n-pub trait MovePtr {\n-    fn move_ptr(&mut self, adjustment: |*const u8| -> *const u8);\n-    fn push_ptr(&mut self);\n-    fn pop_ptr(&mut self);\n-}\n-\n-/// Helper function for alignment calculation.\n-#[inline]\n-pub fn align(size: uint, align: uint) -> uint {\n-    ((size + align) - 1u) & !(align - 1u)\n-}\n-\n-/// Adaptor to wrap around visitors implementing MovePtr.\n-pub struct MovePtrAdaptor<V> {\n-    inner: V\n-}\n-\n-impl<V:TyVisitor + MovePtr> MovePtrAdaptor<V> {\n-    pub fn new(v: V) -> MovePtrAdaptor<V> {\n-        MovePtrAdaptor { inner: v }\n-    }\n-\n-    #[inline]\n-    pub fn bump(&mut self, sz: uint) {\n-        self.inner.move_ptr(|p| ((p as uint) + sz) as *const u8)\n-    }\n-\n-    #[inline]\n-    pub fn align(&mut self, a: uint) {\n-        self.inner.move_ptr(|p| align(p as uint, a) as *const u8)\n-    }\n-\n-    #[inline]\n-    pub fn align_to<T>(&mut self) {\n-        self.align(mem::min_align_of::<T>());\n-    }\n-\n-    #[inline]\n-    pub fn bump_past<T>(&mut self) {\n-        self.bump(mem::size_of::<T>());\n-    }\n-\n-    pub fn unwrap(self) -> V { self.inner }\n-}\n-\n-/// Abstract type-directed pointer-movement using the MovePtr trait\n-impl<V:TyVisitor + MovePtr> TyVisitor for MovePtrAdaptor<V> {\n-    fn visit_bot(&mut self) -> bool {\n-        self.align_to::<()>();\n-        if ! self.inner.visit_bot() { return false; }\n-        self.bump_past::<()>();\n-        true\n-    }\n-\n-    fn visit_nil(&mut self) -> bool {\n-        self.align_to::<()>();\n-        if ! self.inner.visit_nil() { return false; }\n-        self.bump_past::<()>();\n-        true\n-    }\n-\n-    fn visit_bool(&mut self) -> bool {\n-        self.align_to::<bool>();\n-        if ! self.inner.visit_bool() { return false; }\n-        self.bump_past::<bool>();\n-        true\n-    }\n-\n-    fn visit_int(&mut self) -> bool {\n-        self.align_to::<int>();\n-        if ! self.inner.visit_int() { return false; }\n-        self.bump_past::<int>();\n-        true\n-    }\n-\n-    fn visit_i8(&mut self) -> bool {\n-        self.align_to::<i8>();\n-        if ! self.inner.visit_i8() { return false; }\n-        self.bump_past::<i8>();\n-        true\n-    }\n-\n-    fn visit_i16(&mut self) -> bool {\n-        self.align_to::<i16>();\n-        if ! self.inner.visit_i16() { return false; }\n-        self.bump_past::<i16>();\n-        true\n-    }\n-\n-    fn visit_i32(&mut self) -> bool {\n-        self.align_to::<i32>();\n-        if ! self.inner.visit_i32() { return false; }\n-        self.bump_past::<i32>();\n-        true\n-    }\n-\n-    fn visit_i64(&mut self) -> bool {\n-        self.align_to::<i64>();\n-        if ! self.inner.visit_i64() { return false; }\n-        self.bump_past::<i64>();\n-        true\n-    }\n-\n-    fn visit_uint(&mut self) -> bool {\n-        self.align_to::<uint>();\n-        if ! self.inner.visit_uint() { return false; }\n-        self.bump_past::<uint>();\n-        true\n-    }\n-\n-    fn visit_u8(&mut self) -> bool {\n-        self.align_to::<u8>();\n-        if ! self.inner.visit_u8() { return false; }\n-        self.bump_past::<u8>();\n-        true\n-    }\n-\n-    fn visit_u16(&mut self) -> bool {\n-        self.align_to::<u16>();\n-        if ! self.inner.visit_u16() { return false; }\n-        self.bump_past::<u16>();\n-        true\n-    }\n-\n-    fn visit_u32(&mut self) -> bool {\n-        self.align_to::<u32>();\n-        if ! self.inner.visit_u32() { return false; }\n-        self.bump_past::<u32>();\n-        true\n-    }\n-\n-    fn visit_u64(&mut self) -> bool {\n-        self.align_to::<u64>();\n-        if ! self.inner.visit_u64() { return false; }\n-        self.bump_past::<u64>();\n-        true\n-    }\n-\n-    fn visit_f32(&mut self) -> bool {\n-        self.align_to::<f32>();\n-        if ! self.inner.visit_f32() { return false; }\n-        self.bump_past::<f32>();\n-        true\n-    }\n-\n-    fn visit_f64(&mut self) -> bool {\n-        self.align_to::<f64>();\n-        if ! self.inner.visit_f64() { return false; }\n-        self.bump_past::<f64>();\n-        true\n-    }\n-\n-    fn visit_char(&mut self) -> bool {\n-        self.align_to::<char>();\n-        if ! self.inner.visit_char() { return false; }\n-        self.bump_past::<char>();\n-        true\n-    }\n-\n-    fn visit_estr_slice(&mut self) -> bool {\n-        self.align_to::<&'static str>();\n-        if ! self.inner.visit_estr_slice() { return false; }\n-        self.bump_past::<&'static str>();\n-        true\n-    }\n-\n-    fn visit_box(&mut self, mtbl: uint, inner: *const TyDesc) -> bool {\n-        self.align_to::<Box<u8>>();\n-        if ! self.inner.visit_box(mtbl, inner) { return false; }\n-        self.bump_past::<Box<u8>>();\n-        true\n-    }\n-\n-    fn visit_uniq(&mut self, mtbl: uint, inner: *const TyDesc) -> bool {\n-        self.align_to::<Box<u8>>();\n-        if ! self.inner.visit_uniq(mtbl, inner) { return false; }\n-        self.bump_past::<Box<u8>>();\n-        true\n-    }\n-\n-    fn visit_ptr(&mut self, mtbl: uint, inner: *const TyDesc) -> bool {\n-        self.align_to::<*const u8>();\n-        if ! self.inner.visit_ptr(mtbl, inner) { return false; }\n-        self.bump_past::<*const u8>();\n-        true\n-    }\n-\n-    fn visit_rptr(&mut self, mtbl: uint, inner: *const TyDesc) -> bool {\n-        self.align_to::<&'static u8>();\n-        if ! self.inner.visit_rptr(mtbl, inner) { return false; }\n-        self.bump_past::<&'static u8>();\n-        true\n-    }\n-\n-    fn visit_evec_slice(&mut self, mtbl: uint, inner: *const TyDesc) -> bool {\n-        self.align_to::<&'static [u8]>();\n-        if ! self.inner.visit_evec_slice(mtbl, inner) { return false; }\n-        self.bump_past::<&'static [u8]>();\n-        true\n-    }\n-\n-    fn visit_evec_fixed(&mut self, n: uint, sz: uint, align: uint,\n-                        inner: *const TyDesc) -> bool {\n-        self.align(align);\n-        if ! self.inner.visit_evec_fixed(n, sz, align, inner) {\n-            return false;\n-        }\n-        self.bump(sz);\n-        true\n-    }\n-\n-    fn visit_enter_rec(&mut self, n_fields: uint, sz: uint, align: uint) -> bool {\n-        self.align(align);\n-        if ! self.inner.visit_enter_rec(n_fields, sz, align) { return false; }\n-        true\n-    }\n-\n-    fn visit_rec_field(&mut self, i: uint, name: &str,\n-                       mtbl: uint, inner: *const TyDesc) -> bool {\n-        unsafe { self.align((*inner).align); }\n-        if ! self.inner.visit_rec_field(i, name, mtbl, inner) {\n-            return false;\n-        }\n-        unsafe { self.bump((*inner).size); }\n-        true\n-    }\n-\n-    fn visit_leave_rec(&mut self, n_fields: uint, sz: uint, align: uint) -> bool {\n-        if ! self.inner.visit_leave_rec(n_fields, sz, align) { return false; }\n-        true\n-    }\n-\n-    fn visit_enter_class(&mut self, name: &str, named_fields: bool, n_fields: uint, sz: uint,\n-                         align: uint) -> bool {\n-        self.align(align);\n-        if ! self.inner.visit_enter_class(name, named_fields, n_fields, sz, align) {\n-            return false;\n-        }\n-        true\n-    }\n-\n-    fn visit_class_field(&mut self, i: uint, name: &str, named: bool, mtbl: uint,\n-                         inner: *const TyDesc) -> bool {\n-        unsafe { self.align((*inner).align); }\n-        if ! self.inner.visit_class_field(i, name, named, mtbl, inner) {\n-            return false;\n-        }\n-        unsafe { self.bump((*inner).size); }\n-        true\n-    }\n-\n-    fn visit_leave_class(&mut self, name: &str, named_fields: bool, n_fields: uint, sz: uint,\n-                         align: uint) -> bool {\n-        if ! self.inner.visit_leave_class(name, named_fields, n_fields, sz, align) {\n-            return false;\n-        }\n-        true\n-    }\n-\n-    fn visit_enter_tup(&mut self, n_fields: uint, sz: uint, align: uint) -> bool {\n-        self.align(align);\n-        if ! self.inner.visit_enter_tup(n_fields, sz, align) { return false; }\n-        true\n-    }\n-\n-    fn visit_tup_field(&mut self, i: uint, inner: *const TyDesc) -> bool {\n-        unsafe { self.align((*inner).align); }\n-        if ! self.inner.visit_tup_field(i, inner) { return false; }\n-        unsafe { self.bump((*inner).size); }\n-        true\n-    }\n-\n-    fn visit_leave_tup(&mut self, n_fields: uint, sz: uint, align: uint) -> bool {\n-        if ! self.inner.visit_leave_tup(n_fields, sz, align) { return false; }\n-        true\n-    }\n-\n-    fn visit_enter_fn(&mut self, purity: uint, proto: uint,\n-                      n_inputs: uint, retstyle: uint) -> bool {\n-        if ! self.inner.visit_enter_fn(purity, proto, n_inputs, retstyle) {\n-            return false\n-        }\n-        true\n-    }\n-\n-    fn visit_fn_input(&mut self, i: uint, mode: uint,\n-                      inner: *const TyDesc) -> bool {\n-        if ! self.inner.visit_fn_input(i, mode, inner) { return false; }\n-        true\n-    }\n-\n-    fn visit_fn_output(&mut self, retstyle: uint, variadic: bool,\n-                       inner: *const TyDesc) -> bool {\n-        if ! self.inner.visit_fn_output(retstyle, variadic, inner) { return false; }\n-        true\n-    }\n-\n-    fn visit_leave_fn(&mut self, purity: uint, proto: uint,\n-                      n_inputs: uint, retstyle: uint) -> bool {\n-        if ! self.inner.visit_leave_fn(purity, proto, n_inputs, retstyle) {\n-            return false;\n-        }\n-        true\n-    }\n-\n-    fn visit_enter_enum(&mut self, n_variants: uint,\n-                        get_disr: unsafe extern fn(ptr: *const Opaque) -> Disr,\n-                        sz: uint, align: uint)\n-                     -> bool {\n-        self.align(align);\n-        if ! self.inner.visit_enter_enum(n_variants, get_disr, sz, align) {\n-            return false;\n-        }\n-        true\n-    }\n-\n-    fn visit_enter_enum_variant(&mut self, variant: uint,\n-                                disr_val: Disr,\n-                                n_fields: uint,\n-                                name: &str) -> bool {\n-        if ! self.inner.visit_enter_enum_variant(variant, disr_val,\n-                                                 n_fields, name) {\n-            return false;\n-        }\n-        true\n-    }\n-\n-    fn visit_enum_variant_field(&mut self, i: uint, offset: uint,\n-                                inner: *const TyDesc) -> bool {\n-        self.inner.push_ptr();\n-        self.bump(offset);\n-        if ! self.inner.visit_enum_variant_field(i, offset, inner) { return false; }\n-        self.inner.pop_ptr();\n-        true\n-    }\n-\n-    fn visit_leave_enum_variant(&mut self, variant: uint,\n-                                disr_val: Disr,\n-                                n_fields: uint,\n-                                name: &str) -> bool {\n-        if ! self.inner.visit_leave_enum_variant(variant, disr_val,\n-                                                 n_fields, name) {\n-            return false;\n-        }\n-        true\n-    }\n-\n-    fn visit_leave_enum(&mut self, n_variants: uint,\n-                        get_disr: unsafe extern fn(ptr: *const Opaque) -> Disr,\n-                        sz: uint, align: uint) -> bool {\n-        if ! self.inner.visit_leave_enum(n_variants, get_disr, sz, align) {\n-            return false;\n-        }\n-        self.bump(sz);\n-        true\n-    }\n-\n-    fn visit_trait(&mut self, name: &str) -> bool {\n-        self.align_to::<Box<TyVisitor>>();\n-        if ! self.inner.visit_trait(name) { return false; }\n-        self.bump_past::<Box<TyVisitor>>();\n-        true\n-    }\n-\n-    fn visit_param(&mut self, i: uint) -> bool {\n-        if ! self.inner.visit_param(i) { return false; }\n-        true\n-    }\n-\n-    fn visit_self(&mut self) -> bool {\n-        self.align_to::<&'static u8>();\n-        if ! self.inner.visit_self() { return false; }\n-        self.align_to::<&'static u8>();\n-        true\n-    }\n-}"}, {"sha": "e27816c81653972aec579f2c68c438e20089cf26", "filename": "src/libdebug/repr.rs", "status": "removed", "additions": 0, "deletions": 619, "changes": 619, "blob_url": "https://github.com/rust-lang/rust/blob/b6e0d3a5bf4c88650a22f605f822e02c6b163580/src%2Flibdebug%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6e0d3a5bf4c88650a22f605f822e02c6b163580/src%2Flibdebug%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibdebug%2Frepr.rs?ref=b6e0d3a5bf4c88650a22f605f822e02c6b163580", "patch": "@@ -1,619 +0,0 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-/*!\n-\n-More runtime type reflection\n-\n-*/\n-\n-use std::char;\n-use std::intrinsics::{Disr, Opaque, TyDesc, TyVisitor, get_tydesc, visit_tydesc};\n-use std::io;\n-use std::mem;\n-use std::raw;\n-\n-use reflect;\n-use reflect::{MovePtr, align};\n-\n-macro_rules! try( ($me:expr, $e:expr) => (\n-    match $e {\n-        Ok(()) => {},\n-        Err(e) => { $me.last_err = Some(e); return false; }\n-    }\n-) )\n-\n-/// Representations\n-\n-pub trait Repr {\n-    fn write_repr(&self, writer: &mut io::Writer) -> io::IoResult<()>;\n-}\n-\n-impl Repr for () {\n-    fn write_repr(&self, writer: &mut io::Writer) -> io::IoResult<()> {\n-        writer.write(\"()\".as_bytes())\n-    }\n-}\n-\n-impl Repr for bool {\n-    fn write_repr(&self, writer: &mut io::Writer) -> io::IoResult<()> {\n-        let s = if *self { \"true\" } else { \"false\" };\n-        writer.write(s.as_bytes())\n-    }\n-}\n-\n-impl Repr for int {\n-    fn write_repr(&self, writer: &mut io::Writer) -> io::IoResult<()> {\n-        write!(writer, \"{}\", *self)\n-    }\n-}\n-\n-macro_rules! int_repr(($ty:ident, $suffix:expr) => (impl Repr for $ty {\n-    fn write_repr(&self, writer: &mut io::Writer) -> io::IoResult<()> {\n-        write!(writer, \"{}{}\", *self, $suffix)\n-    }\n-}))\n-\n-int_repr!(i8, \"i8\")\n-int_repr!(i16, \"i16\")\n-int_repr!(i32, \"i32\")\n-int_repr!(i64, \"i64\")\n-int_repr!(uint, \"u\")\n-int_repr!(u8, \"u8\")\n-int_repr!(u16, \"u16\")\n-int_repr!(u32, \"u32\")\n-int_repr!(u64, \"u64\")\n-\n-macro_rules! num_repr(($ty:ident, $suffix:expr) => (impl Repr for $ty {\n-    fn write_repr(&self, writer: &mut io::Writer) -> io::IoResult<()> {\n-        let s = self.to_string();\n-        writer.write(s.as_bytes()).and_then(|()| {\n-            writer.write($suffix)\n-        })\n-    }\n-}))\n-\n-num_repr!(f32, b\"f32\")\n-num_repr!(f64, b\"f64\")\n-\n-// New implementation using reflect::MovePtr\n-\n-enum VariantState {\n-    SearchingFor(Disr),\n-    Matched,\n-    AlreadyFound\n-}\n-\n-pub struct ReprVisitor<'a> {\n-    ptr: *const u8,\n-    ptr_stk: Vec<*const u8>,\n-    var_stk: Vec<VariantState>,\n-    writer: &'a mut io::Writer+'a,\n-    last_err: Option<io::IoError>,\n-}\n-\n-impl<'a> MovePtr for ReprVisitor<'a> {\n-    #[inline]\n-    fn move_ptr(&mut self, adjustment: |*const u8| -> *const u8) {\n-        self.ptr = adjustment(self.ptr);\n-    }\n-    fn push_ptr(&mut self) {\n-        self.ptr_stk.push(self.ptr);\n-    }\n-    fn pop_ptr(&mut self) {\n-        self.ptr = self.ptr_stk.pop().unwrap();\n-    }\n-}\n-\n-impl<'a> ReprVisitor<'a> {\n-    // Various helpers for the TyVisitor impl\n-    pub fn new(ptr: *const u8, writer: &'a mut io::Writer) -> ReprVisitor<'a> {\n-        ReprVisitor {\n-            ptr: ptr,\n-            ptr_stk: vec!(),\n-            var_stk: vec!(),\n-            writer: writer,\n-            last_err: None,\n-        }\n-    }\n-\n-    #[inline]\n-    pub fn get<T>(&mut self, f: |&mut ReprVisitor, &T| -> bool) -> bool {\n-        unsafe {\n-            let ptr = self.ptr;\n-            f(self, mem::transmute::<*const u8,&T>(ptr))\n-        }\n-    }\n-\n-    #[inline]\n-    pub fn visit_inner(&mut self, inner: *const TyDesc) -> bool {\n-        let ptr = self.ptr;\n-        self.visit_ptr_inner(ptr, inner)\n-    }\n-\n-    #[inline]\n-    pub fn visit_ptr_inner(&mut self, ptr: *const u8,\n-                           inner: *const TyDesc) -> bool {\n-        unsafe {\n-            let u = ReprVisitor::new(ptr, mem::transmute_copy(&self.writer));\n-            let mut v = reflect::MovePtrAdaptor::new(u);\n-            // Obviously this should not be a thing, but blame #8401 for now\n-            visit_tydesc(inner, &mut v as &mut TyVisitor);\n-            match v.unwrap().last_err {\n-                Some(e) => {\n-                    self.last_err = Some(e);\n-                    false\n-                }\n-                None => true,\n-            }\n-        }\n-    }\n-\n-    #[inline]\n-    pub fn write<T:Repr>(&mut self) -> bool {\n-        self.get(|this, v:&T| {\n-            try!(this, v.write_repr(this.writer));\n-            true\n-        })\n-    }\n-\n-    pub fn write_escaped_slice(&mut self, slice: &str) -> bool {\n-        try!(self, self.writer.write([b'\"']));\n-        for ch in slice.chars() {\n-            if !self.write_escaped_char(ch, true) { return false }\n-        }\n-        try!(self, self.writer.write([b'\"']));\n-        true\n-    }\n-\n-    pub fn write_mut_qualifier(&mut self, mtbl: uint) -> bool {\n-        if mtbl == 0 {\n-            try!(self, self.writer.write(\"mut \".as_bytes()));\n-        } else if mtbl == 1 {\n-            // skip, this is ast::m_imm\n-        } else {\n-            fail!(\"invalid mutability value\");\n-        }\n-        true\n-    }\n-\n-    pub fn write_vec_range(&mut self, ptr: *const (), len: uint,\n-                           inner: *const TyDesc) -> bool {\n-        let mut p = ptr as *const u8;\n-        let (sz, al) = unsafe { ((*inner).size, (*inner).align) };\n-        try!(self, self.writer.write([b'[']));\n-        let mut first = true;\n-        let mut left = len;\n-        // unit structs have 0 size, and don't loop forever.\n-        let dec = if sz == 0 {1} else {sz};\n-        while left > 0 {\n-            if first {\n-                first = false;\n-            } else {\n-                try!(self, self.writer.write(\", \".as_bytes()));\n-            }\n-            self.visit_ptr_inner(p as *const u8, inner);\n-            p = align(unsafe { p.offset(sz as int) as uint }, al) as *const u8;\n-            left -= dec;\n-        }\n-        try!(self, self.writer.write([b']']));\n-        true\n-    }\n-\n-    fn write_escaped_char(&mut self, ch: char, is_str: bool) -> bool {\n-        try!(self, match ch {\n-            '\\t' => self.writer.write(\"\\\\t\".as_bytes()),\n-            '\\r' => self.writer.write(\"\\\\r\".as_bytes()),\n-            '\\n' => self.writer.write(\"\\\\n\".as_bytes()),\n-            '\\\\' => self.writer.write(\"\\\\\\\\\".as_bytes()),\n-            '\\'' => {\n-                if is_str {\n-                    self.writer.write(\"'\".as_bytes())\n-                } else {\n-                    self.writer.write(\"\\\\'\".as_bytes())\n-                }\n-            }\n-            '\"' => {\n-                if is_str {\n-                    self.writer.write(\"\\\\\\\"\".as_bytes())\n-                } else {\n-                    self.writer.write(\"\\\"\".as_bytes())\n-                }\n-            }\n-            '\\x20'...'\\x7e' => self.writer.write([ch as u8]),\n-            _ => {\n-                char::escape_unicode(ch, |c| {\n-                    let _ = self.writer.write([c as u8]);\n-                });\n-                Ok(())\n-            }\n-        });\n-        return true;\n-    }\n-}\n-\n-impl<'a> TyVisitor for ReprVisitor<'a> {\n-    fn visit_bot(&mut self) -> bool {\n-        try!(self, self.writer.write(\"!\".as_bytes()));\n-        true\n-    }\n-    fn visit_nil(&mut self) -> bool { self.write::<()>() }\n-    fn visit_bool(&mut self) -> bool { self.write::<bool>() }\n-    fn visit_int(&mut self) -> bool { self.write::<int>() }\n-    fn visit_i8(&mut self) -> bool { self.write::<i8>() }\n-    fn visit_i16(&mut self) -> bool { self.write::<i16>() }\n-    fn visit_i32(&mut self) -> bool { self.write::<i32>()  }\n-    fn visit_i64(&mut self) -> bool { self.write::<i64>() }\n-\n-    fn visit_uint(&mut self) -> bool { self.write::<uint>() }\n-    fn visit_u8(&mut self) -> bool { self.write::<u8>() }\n-    fn visit_u16(&mut self) -> bool { self.write::<u16>() }\n-    fn visit_u32(&mut self) -> bool { self.write::<u32>() }\n-    fn visit_u64(&mut self) -> bool { self.write::<u64>() }\n-\n-    fn visit_f32(&mut self) -> bool { self.write::<f32>() }\n-    fn visit_f64(&mut self) -> bool { self.write::<f64>() }\n-\n-    fn visit_char(&mut self) -> bool {\n-        self.get::<char>(|this, &ch| {\n-            try!(this, this.writer.write([b'\\'']));\n-            if !this.write_escaped_char(ch, false) { return false }\n-            try!(this, this.writer.write([b'\\'']));\n-            true\n-        })\n-    }\n-\n-    fn visit_estr_slice(&mut self) -> bool {\n-        self.get::<&str>(|this, s| this.write_escaped_slice(*s))\n-    }\n-\n-    fn visit_box(&mut self, _mtbl: uint, _inner: *const TyDesc) -> bool {\n-        try!(self, self.writer.write(\"box(GC) ???\".as_bytes()));\n-        true\n-    }\n-\n-    fn visit_uniq(&mut self, _mtbl: uint, inner: *const TyDesc) -> bool {\n-        try!(self, self.writer.write(\"box \".as_bytes()));\n-        self.get::<*const u8>(|this, b| {\n-            this.visit_ptr_inner(*b, inner)\n-        })\n-    }\n-\n-    fn visit_ptr(&mut self, mtbl: uint, _inner: *const TyDesc) -> bool {\n-        self.get::<*const u8>(|this, p| {\n-            try!(this, write!(this.writer, \"({} as *\", *p));\n-            if mtbl == 0 {\n-                try!(this, this.writer.write(\"mut \".as_bytes()));\n-            } else if mtbl == 1 {\n-                try!(this, this.writer.write(\"const \".as_bytes()));\n-            } else {\n-                fail!(\"invalid mutability value\");\n-            }\n-            try!(this, this.writer.write(\"())\".as_bytes()));\n-            true\n-        })\n-    }\n-\n-    fn visit_rptr(&mut self, mtbl: uint, inner: *const TyDesc) -> bool {\n-        try!(self, self.writer.write([b'&']));\n-        self.write_mut_qualifier(mtbl);\n-        self.get::<*const u8>(|this, p| {\n-            this.visit_ptr_inner(*p, inner)\n-        })\n-    }\n-\n-    fn visit_evec_slice(&mut self, mtbl: uint, inner: *const TyDesc) -> bool {\n-        self.get::<raw::Slice<()>>(|this, s| {\n-            try!(this, this.writer.write([b'&']));\n-            this.write_mut_qualifier(mtbl);\n-            let size = unsafe {\n-                if (*inner).size == 0 { 1 } else { (*inner).size }\n-            };\n-            this.write_vec_range(s.data, s.len * size, inner)\n-        })\n-    }\n-\n-    fn visit_evec_fixed(&mut self, n: uint, sz: uint, _align: uint,\n-                        inner: *const TyDesc) -> bool {\n-        let assumed_size = if sz == 0 { n } else { sz };\n-        self.get::<()>(|this, b| {\n-            this.write_vec_range(b, assumed_size, inner)\n-        })\n-    }\n-\n-\n-    fn visit_enter_rec(&mut self, _n_fields: uint,\n-                       _sz: uint, _align: uint) -> bool {\n-        try!(self, self.writer.write([b'{']));\n-        true\n-    }\n-\n-    fn visit_rec_field(&mut self, i: uint, name: &str,\n-                       mtbl: uint, inner: *const TyDesc) -> bool {\n-        if i != 0 {\n-            try!(self, self.writer.write(\", \".as_bytes()));\n-        }\n-        self.write_mut_qualifier(mtbl);\n-        try!(self, self.writer.write(name.as_bytes()));\n-        try!(self, self.writer.write(\": \".as_bytes()));\n-        self.visit_inner(inner);\n-        true\n-    }\n-\n-    fn visit_leave_rec(&mut self, _n_fields: uint,\n-                       _sz: uint, _align: uint) -> bool {\n-        try!(self, self.writer.write([b'}']));\n-        true\n-    }\n-\n-    fn visit_enter_class(&mut self, name: &str, named_fields: bool, n_fields: uint,\n-                         _sz: uint, _align: uint) -> bool {\n-        try!(self, self.writer.write(name.as_bytes()));\n-        if n_fields != 0 {\n-            if named_fields {\n-                try!(self, self.writer.write([b'{']));\n-            } else {\n-                try!(self, self.writer.write([b'(']));\n-            }\n-        }\n-        true\n-    }\n-\n-    fn visit_class_field(&mut self, i: uint, name: &str, named: bool,\n-                         _mtbl: uint, inner: *const TyDesc) -> bool {\n-        if i != 0 {\n-            try!(self, self.writer.write(\", \".as_bytes()));\n-        }\n-        if named {\n-            try!(self, self.writer.write(name.as_bytes()));\n-            try!(self, self.writer.write(\": \".as_bytes()));\n-        }\n-        self.visit_inner(inner);\n-        true\n-    }\n-\n-    fn visit_leave_class(&mut self, _name: &str, named_fields: bool, n_fields: uint,\n-                         _sz: uint, _align: uint) -> bool {\n-        if n_fields != 0 {\n-            if named_fields {\n-                try!(self, self.writer.write([b'}']));\n-            } else {\n-                try!(self, self.writer.write([b')']));\n-            }\n-        }\n-        true\n-    }\n-\n-    fn visit_enter_tup(&mut self, _n_fields: uint,\n-                       _sz: uint, _align: uint) -> bool {\n-        try!(self, self.writer.write([b'(']));\n-        true\n-    }\n-\n-    fn visit_tup_field(&mut self, i: uint, inner: *const TyDesc) -> bool {\n-        if i != 0 {\n-            try!(self, self.writer.write(\", \".as_bytes()));\n-        }\n-        self.visit_inner(inner);\n-        true\n-    }\n-\n-    fn visit_leave_tup(&mut self, _n_fields: uint,\n-                       _sz: uint, _align: uint) -> bool {\n-        if _n_fields == 1 {\n-            try!(self, self.writer.write([b',']));\n-        }\n-        try!(self, self.writer.write([b')']));\n-        true\n-    }\n-\n-    fn visit_enter_enum(&mut self,\n-                        _n_variants: uint,\n-                        get_disr: unsafe extern fn(ptr: *const Opaque) -> Disr,\n-                        _sz: uint,\n-                        _align: uint) -> bool {\n-        let disr = unsafe {\n-            get_disr(mem::transmute(self.ptr))\n-        };\n-        self.var_stk.push(SearchingFor(disr));\n-        true\n-    }\n-\n-    fn visit_enter_enum_variant(&mut self, _variant: uint,\n-                                disr_val: Disr,\n-                                n_fields: uint,\n-                                name: &str) -> bool {\n-        let mut write = false;\n-        match self.var_stk.pop().unwrap() {\n-            SearchingFor(sought) => {\n-                if disr_val == sought {\n-                    self.var_stk.push(Matched);\n-                    write = true;\n-                } else {\n-                    self.var_stk.push(SearchingFor(sought));\n-                }\n-            }\n-            Matched | AlreadyFound => {\n-                self.var_stk.push(AlreadyFound);\n-            }\n-        }\n-\n-        if write {\n-            try!(self, self.writer.write(name.as_bytes()));\n-            if n_fields > 0 {\n-                try!(self, self.writer.write([b'(']));\n-            }\n-        }\n-        true\n-    }\n-\n-    fn visit_enum_variant_field(&mut self,\n-                                i: uint,\n-                                _offset: uint,\n-                                inner: *const TyDesc)\n-                                -> bool {\n-        match self.var_stk[self.var_stk.len() - 1] {\n-            Matched => {\n-                if i != 0 {\n-                    try!(self, self.writer.write(\", \".as_bytes()));\n-                }\n-                if ! self.visit_inner(inner) {\n-                    return false;\n-                }\n-            }\n-            _ => ()\n-        }\n-        true\n-    }\n-\n-    fn visit_leave_enum_variant(&mut self, _variant: uint,\n-                                _disr_val: Disr,\n-                                n_fields: uint,\n-                                _name: &str) -> bool {\n-        match self.var_stk[self.var_stk.len() - 1] {\n-            Matched => {\n-                if n_fields > 0 {\n-                    try!(self, self.writer.write([b')']));\n-                }\n-            }\n-            _ => ()\n-        }\n-        true\n-    }\n-\n-    fn visit_leave_enum(&mut self,\n-                        _n_variants: uint,\n-                        _get_disr: unsafe extern fn(ptr: *const Opaque) -> Disr,\n-                        _sz: uint,\n-                        _align: uint)\n-                        -> bool {\n-        match self.var_stk.pop().unwrap() {\n-            SearchingFor(..) => fail!(\"enum value matched no variant\"),\n-            _ => true\n-        }\n-    }\n-\n-    fn visit_enter_fn(&mut self, _purity: uint, _proto: uint,\n-                      _n_inputs: uint, _retstyle: uint) -> bool {\n-        try!(self, self.writer.write(\"fn(\".as_bytes()));\n-        true\n-    }\n-\n-    fn visit_fn_input(&mut self, i: uint, _mode: uint,\n-                      inner: *const TyDesc) -> bool {\n-        if i != 0 {\n-            try!(self, self.writer.write(\", \".as_bytes()));\n-        }\n-        let name = unsafe { (*inner).name };\n-        try!(self, self.writer.write(name.as_bytes()));\n-        true\n-    }\n-\n-    fn visit_fn_output(&mut self, _retstyle: uint, variadic: bool,\n-                       inner: *const TyDesc) -> bool {\n-        if variadic {\n-            try!(self, self.writer.write(\", ...\".as_bytes()));\n-        }\n-        try!(self, self.writer.write(\")\".as_bytes()));\n-        let name = unsafe { (*inner).name };\n-        if name != \"()\" {\n-            try!(self, self.writer.write(\" -> \".as_bytes()));\n-            try!(self, self.writer.write(name.as_bytes()));\n-        }\n-        true\n-    }\n-\n-    fn visit_leave_fn(&mut self, _purity: uint, _proto: uint,\n-                      _n_inputs: uint, _retstyle: uint) -> bool { true }\n-\n-\n-    fn visit_trait(&mut self, name: &str) -> bool {\n-        try!(self, self.writer.write(name.as_bytes()));\n-        true\n-    }\n-\n-    fn visit_param(&mut self, _i: uint) -> bool { true }\n-    fn visit_self(&mut self) -> bool { true }\n-}\n-\n-pub fn write_repr<T>(writer: &mut io::Writer, object: &T) -> io::IoResult<()> {\n-    unsafe {\n-        let ptr = object as *const T as *const u8;\n-        let tydesc = get_tydesc::<T>();\n-        let u = ReprVisitor::new(ptr, writer);\n-        let mut v = reflect::MovePtrAdaptor::new(u);\n-        visit_tydesc(tydesc, &mut v as &mut TyVisitor);\n-        match v.unwrap().last_err {\n-            Some(e) => Err(e),\n-            None => Ok(()),\n-        }\n-    }\n-}\n-\n-pub fn repr_to_string<T>(t: &T) -> String {\n-    let mut result = io::MemWriter::new();\n-    write_repr(&mut result as &mut io::Writer, t).unwrap();\n-    String::from_utf8(result.unwrap()).unwrap()\n-}\n-\n-#[cfg(test)]\n-#[allow(dead_code)]\n-struct P {a: int, b: f64}\n-\n-#[test]\n-fn test_repr() {\n-    use std::io::stdio::println;\n-    use std::char::is_alphabetic;\n-    use std::mem::swap;\n-\n-    fn exact_test<T>(t: &T, e:&str) {\n-        let mut m = io::MemWriter::new();\n-        write_repr(&mut m as &mut io::Writer, t).unwrap();\n-        let s = String::from_utf8(m.unwrap()).unwrap();\n-        assert_eq!(s.as_slice(), e);\n-    }\n-\n-    exact_test(&10i, \"10\");\n-    exact_test(&true, \"true\");\n-    exact_test(&false, \"false\");\n-    exact_test(&1.234f64, \"1.234f64\");\n-    exact_test(&(\"hello\"), \"\\\"hello\\\"\");\n-\n-    exact_test(&(box 10i), \"box 10\");\n-    exact_test(&(&10i), \"&10\");\n-    let mut x = 10i;\n-    exact_test(&(&mut x), \"&mut 10\");\n-\n-    exact_test(&(0i as *const()), \"(0x0 as *const ())\");\n-    exact_test(&(0i as *mut ()), \"(0x0 as *mut ())\");\n-\n-    exact_test(&(1i,), \"(1,)\");\n-    exact_test(&(&[\"hi\", \"there\"]),\n-               \"&[\\\"hi\\\", \\\"there\\\"]\");\n-    exact_test(&(P{a:10, b:1.234}),\n-               \"repr::P{a: 10, b: 1.234f64}\");\n-    exact_test(&(box P{a:10, b:1.234}),\n-               \"box repr::P{a: 10, b: 1.234f64}\");\n-\n-    exact_test(&(&[1i, 2i]), \"&[1, 2]\");\n-    exact_test(&(&mut [1i, 2i]), \"&mut [1, 2]\");\n-\n-    exact_test(&'\\'', \"'\\\\''\");\n-    exact_test(&'\"', \"'\\\"'\");\n-    exact_test(&(\"'\"), \"\\\"'\\\"\");\n-    exact_test(&(\"\\\"\"), \"\\\"\\\\\\\"\\\"\");\n-\n-    exact_test(&println, \"fn(&str)\");\n-    exact_test(&swap::<int>, \"fn(&mut int, &mut int)\");\n-    exact_test(&is_alphabetic, \"fn(char) -> bool\");\n-\n-    struct Bar(int, int);\n-    exact_test(&(Bar(2, 2)), \"repr::test_repr::Bar(2, 2)\");\n-}"}, {"sha": "37b3458b555123a4fbf33226cd26c0b9c84440ec", "filename": "src/libgetopts/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibgetopts%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibgetopts%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgetopts%2Flib.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -91,7 +91,6 @@\n #![feature(import_shadowing)]\n #![deny(missing_doc)]\n \n-#[cfg(test)] extern crate debug;\n #[cfg(test)] #[phase(plugin, link)] extern crate log;\n \n use std::cmp::PartialEq;"}, {"sha": "88f5061bbef1713f7d3c1456402b3e9e96f66aac", "filename": "src/libnative/io/file_unix.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibnative%2Fio%2Ffile_unix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibnative%2Fio%2Ffile_unix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Ffile_unix.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -523,7 +523,7 @@ mod tests {\n                 assert_eq!(buf[2], 's' as u8);\n                 assert_eq!(buf[3], 't' as u8);\n             }\n-            r => fail!(\"invalid read: {:?}\", r)\n+            r => fail!(\"invalid read: {}\", r)\n         }\n \n         assert!(writer.inner_read(buf).is_err());\n@@ -547,7 +547,7 @@ mod tests {\n                     assert_eq!(buf[2], 's' as u8);\n                     assert_eq!(buf[3], 't' as u8);\n                 }\n-                r => fail!(\"invalid read: {:?}\", r)\n+                r => fail!(\"invalid read: {}\", r)\n             }\n         }\n     }"}, {"sha": "71a1645f9ff1512f12a18b857e3f7e21bda4ee54", "filename": "src/libnative/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibnative%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibnative%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Flib.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -67,7 +67,6 @@\n \n extern crate alloc;\n extern crate libc;\n-#[cfg(test)] extern crate debug;\n \n use std::os;\n use std::rt;"}, {"sha": "ff7d3c296203ee52d938214e40c5f100778890d9", "filename": "src/librand/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrand%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrand%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Flib.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -34,7 +34,6 @@ extern crate core;\n #[cfg(test)] #[phase(plugin, link)] extern crate std;\n #[cfg(test)] #[phase(plugin, link)] extern crate log;\n #[cfg(test)] extern crate native;\n-#[cfg(test)] extern crate debug;\n \n use core::prelude::*;\n "}, {"sha": "ca7ce2a8b7153ec0d8bbb142915fb505f0a9c221", "filename": "src/librlibc/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrlibc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrlibc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrlibc%2Flib.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -39,7 +39,6 @@\n \n #[cfg(test)] extern crate native;\n #[cfg(test)] extern crate test;\n-#[cfg(test)] extern crate debug;\n \n #[cfg(test)] #[phase(plugin, link)] extern crate std;\n "}, {"sha": "75171af741110e191a2e0b6fbf6422d877fa684a", "filename": "src/librustc/driver/pretty.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrustc%2Fdriver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrustc%2Fdriver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fpretty.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -518,7 +518,7 @@ pub fn pretty_print_input(sess: Session,\n                 }\n                 None => {\n                     let message = format!(\"--pretty=flowgraph needs \\\n-                                           block, fn, or method; got {:?}\",\n+                                           block, fn, or method; got {}\",\n                                           node);\n \n                     // point to what was found, if there's an\n@@ -542,7 +542,6 @@ fn print_flowgraph<W:io::Writer>(variants: Vec<borrowck_dot::Variant>,\n         blocks::BlockCode(block) => cfg::CFG::new(ty_cx, &*block),\n         blocks::FnLikeCode(fn_like) => cfg::CFG::new(ty_cx, &*fn_like.body()),\n     };\n-    debug!(\"cfg: {:?}\", cfg);\n \n     match code {\n         _ if variants.len() == 0 => {"}, {"sha": "eb78762906e24e68083f2c6f77ed3893f5402281", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -34,7 +34,6 @@ This API is completely unstable and subject to change.\n #![feature(rustc_diagnostic_macros)]\n \n extern crate arena;\n-extern crate debug;\n extern crate flate;\n extern crate getopts;\n extern crate graphviz;"}, {"sha": "b7bd97e021965432e8f17b664a325dd25ae950bc", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -226,13 +226,13 @@ pub fn get_field_type(tcx: &ty::ctxt, class_id: ast::DefId,\n     let class_doc = expect(tcx.sess.diagnostic(),\n                            decoder::maybe_find_item(class_id.node, all_items),\n                            || {\n-        (format!(\"get_field_type: class ID {:?} not found\",\n+        (format!(\"get_field_type: class ID {} not found\",\n                  class_id)).to_string()\n     });\n     let the_field = expect(tcx.sess.diagnostic(),\n         decoder::maybe_find_item(def.node, class_doc),\n         || {\n-            (format!(\"get_field_type: in class {:?}, field ID {:?} not found\",\n+            (format!(\"get_field_type: in class {}, field ID {} not found\",\n                     class_id,\n                     def)).to_string()\n         });"}, {"sha": "b9135e974c5d7963c98b2456d0c9103d7892631c", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -256,7 +256,7 @@ fn encode_symbol(ecx: &EncodeContext,\n     rbml_w.start_tag(tag_items_data_item_symbol);\n     match ecx.item_symbols.borrow().find(&id) {\n         Some(x) => {\n-            debug!(\"encode_symbol(id={:?}, str={})\", id, *x);\n+            debug!(\"encode_symbol(id={}, str={})\", id, *x);\n             rbml_w.writer.write(x.as_bytes());\n         }\n         None => {\n@@ -308,7 +308,7 @@ fn encode_enum_variant_info(ecx: &EncodeContext,\n                             id: NodeId,\n                             variants: &[P<Variant>],\n                             index: &mut Vec<entry<i64>>) {\n-    debug!(\"encode_enum_variant_info(id={:?})\", id);\n+    debug!(\"encode_enum_variant_info(id={})\", id);\n \n     let mut disr_val = 0;\n     let mut i = 0;\n@@ -592,7 +592,7 @@ fn encode_info_for_mod(ecx: &EncodeContext,\n             ItemImpl(..) => {\n                 let (ident, did) = (item.ident, item.id);\n                 debug!(\"(encoding info for module) ... encoding impl {} \\\n-                        ({:?}/{:?})\",\n+                        ({}/{})\",\n                         token::get_ident(ident),\n                         did, ecx.tcx.map.node_to_string(did));\n \n@@ -853,7 +853,7 @@ fn encode_info_for_method(ecx: &EncodeContext,\n                           parent_id: NodeId,\n                           ast_item_opt: Option<&ImplItem>) {\n \n-    debug!(\"encode_info_for_method: {:?} {}\", m.def_id,\n+    debug!(\"encode_info_for_method: {} {}\", m.def_id,\n            token::get_ident(m.ident));\n     rbml_w.start_tag(tag_items_data_item);\n "}, {"sha": "34aa9310ef236e6f2ead31fa0536b121f8ad5d4f", "filename": "src/librustc/metadata/filesearch.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -39,7 +39,7 @@ impl<'a> FileSearch<'a> {\n         let mut visited_dirs = HashSet::new();\n         let mut found = false;\n \n-        debug!(\"filesearch: searching additional lib search paths [{:?}]\",\n+        debug!(\"filesearch: searching additional lib search paths [{}]\",\n                self.addl_lib_search_paths.borrow().len());\n         for path in self.addl_lib_search_paths.borrow().iter() {\n             match f(path) {\n@@ -66,7 +66,7 @@ impl<'a> FileSearch<'a> {\n             for path in rustpath.iter() {\n                 let tlib_path = make_rustpkg_lib_path(\n                     self.sysroot, path, self.triple);\n-                debug!(\"is {} in visited_dirs? {:?}\", tlib_path.display(),\n+                debug!(\"is {} in visited_dirs? {}\", tlib_path.display(),\n                         visited_dirs.contains_equiv(&tlib_path.as_vec().to_vec()));\n \n                 if !visited_dirs.contains_equiv(&tlib_path.as_vec()) {"}, {"sha": "c8d56c61d2b9ae7310e32d8339f609c5c99e1e85", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -43,6 +43,7 @@ use syntax::parse::token;\n // def-id will depend on where it originated from.  Therefore, the conversion\n // function is given an indicator of the source of the def-id.  See\n // astencode.rs for more information.\n+#[deriving(Show)]\n pub enum DefIdSource {\n     // Identifies a struct, trait, enum, etc.\n     NominalType,\n@@ -390,7 +391,7 @@ fn parse_ty(st: &mut PState, conv: conv_did) -> ty::t {\n       }\n       'p' => {\n         let did = parse_def(st, TypeParameter, |x,y| conv(x,y));\n-        debug!(\"parsed ty_param: did={:?}\", did);\n+        debug!(\"parsed ty_param: did={}\", did);\n         let index = parse_uint(st);\n         assert_eq!(next(st), '|');\n         let space = parse_param_space(st);\n@@ -603,12 +604,12 @@ pub fn parse_def_id(buf: &[u8]) -> ast::DefId {\n \n     let crate_num = match uint::parse_bytes(crate_part, 10u) {\n        Some(cn) => cn as ast::CrateNum,\n-       None => fail!(\"internal error: parse_def_id: crate number expected, found {:?}\",\n+       None => fail!(\"internal error: parse_def_id: crate number expected, found {}\",\n                      crate_part)\n     };\n     let def_num = match uint::parse_bytes(def_part, 10u) {\n        Some(dn) => dn as ast::NodeId,\n-       None => fail!(\"internal error: parse_def_id: id expected, found {:?}\",\n+       None => fail!(\"internal error: parse_def_id: id expected, found {}\",\n                      def_part)\n     };\n     ast::DefId { krate: crate_num, node: def_num }"}, {"sha": "ec693679b1539d0704cb88a931bc305fc278fb6a", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -1807,7 +1807,7 @@ impl<'a> rbml_decoder_decoder_helpers for reader::Decoder<'a> {\n             NominalType | TypeWithId | RegionParameter => dcx.tr_def_id(did),\n             TypeParameter => dcx.tr_intern_def_id(did)\n         };\n-        debug!(\"convert_def_id(source={:?}, did={:?})={:?}\", source, did, r);\n+        debug!(\"convert_def_id(source={}, did={})={}\", source, did, r);\n         return r;\n     }\n }\n@@ -1841,7 +1841,7 @@ fn decode_side_tables(dcx: &DecodeContext,\n                     }\n                     c::tag_table_node_type => {\n                         let ty = val_dsr.read_ty(dcx);\n-                        debug!(\"inserting ty for node {:?}: {}\",\n+                        debug!(\"inserting ty for node {}: {}\",\n                                id, ty_to_string(dcx.tcx, ty));\n                         dcx.tcx.node_types.borrow_mut().insert(id as uint, ty);\n                     }"}, {"sha": "4eba46b469c7d921c74b2cda50d3ca7d682ca999", "filename": "src/librustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -119,7 +119,7 @@ impl<'a, 'tcx> euv::Delegate for CheckLoanCtxt<'a, 'tcx> {\n               loan_cause: euv::LoanCause)\n     {\n         debug!(\"borrow(borrow_id={}, cmt={}, loan_region={}, \\\n-               bk={}, loan_cause={:?})\",\n+               bk={}, loan_cause={})\",\n                borrow_id, cmt.repr(self.tcx()), loan_region,\n                bk, loan_cause);\n \n@@ -185,7 +185,7 @@ pub fn check_loans<'a, 'b, 'c, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n                                      all_loans: &[Loan],\n                                      decl: &ast::FnDecl,\n                                      body: &ast::Block) {\n-    debug!(\"check_loans(body id={:?})\", body.id);\n+    debug!(\"check_loans(body id={})\", body.id);\n \n     let mut clcx = CheckLoanCtxt {\n         bccx: bccx,\n@@ -336,10 +336,10 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n         //! issued when we enter `scope_id` (for example, we do not\n         //! permit two `&mut` borrows of the same variable).\n \n-        debug!(\"check_for_conflicting_loans(scope_id={:?})\", scope_id);\n+        debug!(\"check_for_conflicting_loans(scope_id={})\", scope_id);\n \n         let new_loan_indices = self.loans_generated_by(scope_id);\n-        debug!(\"new_loan_indices = {:?}\", new_loan_indices);\n+        debug!(\"new_loan_indices = {}\", new_loan_indices);\n \n         self.each_issued_loan(scope_id, |issued_loan| {\n             for &new_loan_index in new_loan_indices.iter() {\n@@ -651,7 +651,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                                        use_path: &LoanPath,\n                                        borrow_kind: ty::BorrowKind)\n                                        -> UseError {\n-        debug!(\"analyze_restrictions_on_use(expr_id={:?}, use_path={})\",\n+        debug!(\"analyze_restrictions_on_use(expr_id={}, use_path={})\",\n                self.tcx().map.node_to_string(expr_id),\n                use_path.repr(self.tcx()));\n \n@@ -679,7 +679,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n          * is using a moved/uninitialized value\n          */\n \n-        debug!(\"check_if_path_is_moved(id={:?}, use_kind={:?}, lp={})\",\n+        debug!(\"check_if_path_is_moved(id={}, use_kind={}, lp={})\",\n                id, use_kind, lp.repr(self.bccx.tcx));\n         let base_lp = owned_ptr_base_path_rc(lp);\n         self.move_data.each_move_of(id, &base_lp, |the_move, moved_lp| {"}, {"sha": "d28baf48ddcdf5825043068a26a56dad2e0be9a8", "filename": "src/librustc/middle/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -112,7 +112,7 @@ impl<'a, 'tcx> euv::Delegate for GatherLoanCtxt<'a, 'tcx> {\n               loan_cause: euv::LoanCause)\n     {\n         debug!(\"borrow(borrow_id={}, cmt={}, loan_region={}, \\\n-               bk={}, loan_cause={:?})\",\n+               bk={}, loan_cause={})\",\n                borrow_id, cmt.repr(self.tcx()), loan_region,\n                bk, loan_cause);\n \n@@ -218,8 +218,8 @@ impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {\n          * dynamically that they are not freed.\n          */\n \n-        debug!(\"guarantee_valid(borrow_id={:?}, cmt={}, \\\n-                req_mutbl={:?}, loan_region={:?})\",\n+        debug!(\"guarantee_valid(borrow_id={}, cmt={}, \\\n+                req_mutbl={}, loan_region={})\",\n                borrow_id,\n                cmt.repr(self.tcx()),\n                req_kind,\n@@ -257,7 +257,7 @@ impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {\n             self.bccx, borrow_span, cause,\n             cmt.clone(), loan_region);\n \n-        debug!(\"guarantee_valid(): restrictions={:?}\", restr);\n+        debug!(\"guarantee_valid(): restrictions={}\", restr);\n \n         // Create the loan record (if needed).\n         let loan = match restr {\n@@ -289,17 +289,17 @@ impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {\n                     ty::ReInfer(..) => {\n                         self.tcx().sess.span_bug(\n                             cmt.span,\n-                            format!(\"invalid borrow lifetime: {:?}\",\n+                            format!(\"invalid borrow lifetime: {}\",\n                                     loan_region).as_slice());\n                     }\n                 };\n-                debug!(\"loan_scope = {:?}\", loan_scope);\n+                debug!(\"loan_scope = {}\", loan_scope);\n \n                 let gen_scope = self.compute_gen_scope(borrow_id, loan_scope);\n-                debug!(\"gen_scope = {:?}\", gen_scope);\n+                debug!(\"gen_scope = {}\", gen_scope);\n \n                 let kill_scope = self.compute_kill_scope(loan_scope, &*loan_path);\n-                debug!(\"kill_scope = {:?}\", kill_scope);\n+                debug!(\"kill_scope = {}\", kill_scope);\n \n                 if req_kind == ty::MutBorrow {\n                     self.mark_loan_path_as_mutated(&*loan_path);\n@@ -318,7 +318,7 @@ impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {\n             }\n         };\n \n-        debug!(\"guarantee_valid(borrow_id={:?}), loan={}\",\n+        debug!(\"guarantee_valid(borrow_id={}), loan={}\",\n                borrow_id, loan.repr(self.tcx()));\n \n         // let loan_path = loan.loan_path;"}, {"sha": "bf1b4b7e476ecea82537a2b1d4c0a855052fa2e7", "filename": "src/librustc/middle/borrowck/gather_loans/restrictions.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -21,6 +21,7 @@ use util::ppaux::Repr;\n \n use std::rc::Rc;\n \n+#[deriving(Show)]\n pub enum RestrictionResult {\n     Safe,\n     SafeIf(Rc<LoanPath>, Vec<Rc<LoanPath>>)"}, {"sha": "ec09e9e72d7ba24be834dce797a7fe0d013c7886", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -264,14 +264,14 @@ impl Loan {\n     }\n }\n \n-#[deriving(PartialEq, Eq, Hash)]\n+#[deriving(PartialEq, Eq, Hash, Show)]\n pub enum LoanPath {\n     LpVar(ast::NodeId),               // `x` in doc.rs\n     LpUpvar(ty::UpvarId),             // `x` captured by-value into closure\n     LpExtend(Rc<LoanPath>, mc::MutabilityCategory, LoanPathElem)\n }\n \n-#[deriving(PartialEq, Eq, Hash)]\n+#[deriving(PartialEq, Eq, Hash, Show)]\n pub enum LoanPathElem {\n     LpDeref(mc::PointerKind),    // `*LV` in doc.rs\n     LpInterior(mc::InteriorKind) // `LV.f` in doc.rs\n@@ -421,6 +421,7 @@ pub enum AliasableViolationKind {\n     BorrowViolation(euv::LoanCause)\n }\n \n+#[deriving(Show)]\n pub enum MovedValueUseKind {\n     MovedInUse,\n     MovedInCapture,\n@@ -530,8 +531,8 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                         (ty::expr_ty_adjusted(self.tcx, &*expr), expr.span)\n                     }\n                     r => {\n-                        self.tcx.sess.bug(format!(\"MoveExpr({:?}) maps to \\\n-                                                   {:?}, not Expr\",\n+                        self.tcx.sess.bug(format!(\"MoveExpr({}) maps to \\\n+                                                   {}, not Expr\",\n                                                   the_move.id,\n                                                   r).as_slice())\n                     }\n@@ -566,8 +567,8 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                         (ty::expr_ty_adjusted(self.tcx, &*expr), expr.span)\n                     }\n                     r => {\n-                        self.tcx.sess.bug(format!(\"Captured({:?}) maps to \\\n-                                                   {:?}, not Expr\",\n+                        self.tcx.sess.bug(format!(\"Captured({}) maps to \\\n+                                                   {}, not Expr\",\n                                                   the_move.id,\n                                                   r).as_slice())\n                     }\n@@ -892,7 +893,7 @@ impl DataFlowOperator for LoanDataFlowOperator {\n \n impl Repr for Loan {\n     fn repr(&self, tcx: &ty::ctxt) -> String {\n-        format!(\"Loan_{:?}({}, {:?}, {:?}-{:?}, {})\",\n+        format!(\"Loan_{}({}, {}, {}-{}, {})\",\n                  self.index,\n                  self.loan_path.repr(tcx),\n                  self.kind,"}, {"sha": "4c2ee9fe551c4fbd14ba2053da6505d83a78719d", "filename": "src/librustc/middle/borrowck/move_data.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -68,7 +68,7 @@ pub struct FlowedMoveData<'a, 'tcx: 'a> {\n }\n \n /// Index into `MoveData.paths`, used like a pointer\n-#[deriving(PartialEq)]\n+#[deriving(PartialEq, Show)]\n pub struct MovePathIndex(uint);\n \n impl MovePathIndex {\n@@ -120,7 +120,7 @@ pub struct MovePath {\n     pub next_sibling: MovePathIndex,\n }\n \n-#[deriving(PartialEq)]\n+#[deriving(PartialEq, Show)]\n pub enum MoveKind {\n     Declared,   // When declared, variables start out \"moved\".\n     MoveExpr,   // Expression or binding that moves a variable\n@@ -284,7 +284,7 @@ impl MoveData {\n             }\n         };\n \n-        debug!(\"move_path(lp={}, index={:?})\",\n+        debug!(\"move_path(lp={}, index={})\",\n                lp.repr(tcx),\n                index);\n \n@@ -341,7 +341,7 @@ impl MoveData {\n          * location `id` with kind `kind`.\n          */\n \n-        debug!(\"add_move(lp={}, id={:?}, kind={:?})\",\n+        debug!(\"add_move(lp={}, id={}, kind={})\",\n                lp.repr(tcx),\n                id,\n                kind);\n@@ -372,7 +372,7 @@ impl MoveData {\n          * location `id` with the given `span`.\n          */\n \n-        debug!(\"add_assignment(lp={}, assign_id={:?}, assignee_id={:?}\",\n+        debug!(\"add_assignment(lp={}, assign_id={}, assignee_id={}\",\n                lp.repr(tcx), assign_id, assignee_id);\n \n         let path_index = self.move_path(tcx, lp.clone());\n@@ -391,12 +391,12 @@ impl MoveData {\n         };\n \n         if self.is_var_path(path_index) {\n-            debug!(\"add_assignment[var](lp={}, assignment={}, path_index={:?})\",\n+            debug!(\"add_assignment[var](lp={}, assignment={}, path_index={})\",\n                    lp.repr(tcx), self.var_assignments.borrow().len(), path_index);\n \n             self.var_assignments.borrow_mut().push(assignment);\n         } else {\n-            debug!(\"add_assignment[path](lp={}, path_index={:?})\",\n+            debug!(\"add_assignment[path](lp={}, path_index={})\",\n                    lp.repr(tcx), path_index);\n \n             self.path_assignments.borrow_mut().push(assignment);"}, {"sha": "fa5a6a2e54aad80c022bd1a9eeb3fc5c0b13cba1", "filename": "src/librustc/middle/cfg/construct.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -483,12 +483,12 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                 let inputs = inline_asm.inputs.iter();\n                 let outputs = inline_asm.outputs.iter();\n                 let post_inputs = self.exprs(inputs.map(|a| {\n-                    debug!(\"cfg::construct InlineAsm id:{} input:{:?}\", expr.id, a);\n+                    debug!(\"cfg::construct InlineAsm id:{} input:{}\", expr.id, a);\n                     let &(_, ref expr) = a;\n                     &**expr\n                 }), pred);\n                 let post_outputs = self.exprs(outputs.map(|a| {\n-                    debug!(\"cfg::construct InlineAsm id:{} output:{:?}\", expr.id, a);\n+                    debug!(\"cfg::construct InlineAsm id:{} output:{}\", expr.id, a);\n                     let &(_, ref expr, _) = a;\n                     &**expr\n                 }), post_inputs);\n@@ -616,14 +616,14 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                         }\n                         self.tcx.sess.span_bug(\n                             expr.span,\n-                            format!(\"no loop scope for id {:?}\",\n+                            format!(\"no loop scope for id {}\",\n                                     loop_id).as_slice());\n                     }\n \n                     r => {\n                         self.tcx.sess.span_bug(\n                             expr.span,\n-                            format!(\"bad entry `{:?}` in def_map for label\",\n+                            format!(\"bad entry `{}` in def_map for label\",\n                                     r).as_slice());\n                     }\n                 }"}, {"sha": "d6b9bbded4ff89e7050b85770ee1e1ad56302523", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -145,7 +145,7 @@ fn check_expr(v: &mut CheckCrateVisitor, e: &Expr) -> bool {\n                 Some(&DefStruct(_)) => { }\n \n                 Some(&def) => {\n-                    debug!(\"(checking const) found bad def: {:?}\", def);\n+                    debug!(\"(checking const) found bad def: {}\", def);\n                     span_err!(v.tcx.sess, e.span, E0014,\n                               \"paths in constants may only refer to constants \\\n                                or functions\");"}, {"sha": "abccc7623a75925fcb1acbe2fe19fcef148cffec", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -987,7 +987,7 @@ fn check_legality_of_move_bindings(cx: &MatchCheckCtxt,\n                         cx.tcx.sess.span_bug(\n                             p.span,\n                             format!(\"binding pattern {} is not an \\\n-                                     identifier: {:?}\",\n+                                     identifier: {}\",\n                                     p.id,\n                                     p.node).as_slice());\n                     }"}, {"sha": "cd7c4b15494a997ed05470e87e274278ba05359c", "filename": "src/librustc/middle/check_rvalues.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrustc%2Fmiddle%2Fcheck_rvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrustc%2Fmiddle%2Fcheck_rvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_rvalues.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -51,7 +51,7 @@ impl<'a, 'tcx> euv::Delegate for RvalueContext<'a, 'tcx> {\n                span: Span,\n                cmt: mc::cmt,\n                _: euv::ConsumeMode) {\n-        debug!(\"consume; cmt: {:?}; type: {}\", *cmt, ty_to_string(self.tcx, cmt.ty));\n+        debug!(\"consume; cmt: {}; type: {}\", *cmt, ty_to_string(self.tcx, cmt.ty));\n         if !ty::type_is_sized(self.tcx, cmt.ty) {\n             span_err!(self.tcx.sess, span, E0161,\n                 \"cannot move a value of type {0}: the size of {0} cannot be statically determined\","}, {"sha": "a8b8eb2e3394dbe64b67f46733971051dcb890b7", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -193,8 +193,8 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n         let words_per_id = (bits_per_id + uint::BITS - 1) / uint::BITS;\n         let num_nodes = cfg.graph.all_nodes().len();\n \n-        debug!(\"DataFlowContext::new(analysis_name: {:s}, id_range={:?}, \\\n-                                     bits_per_id={:?}, words_per_id={:?}) \\\n+        debug!(\"DataFlowContext::new(analysis_name: {:s}, id_range={}, \\\n+                                     bits_per_id={}, words_per_id={}) \\\n                                      num_nodes: {}\",\n                analysis_name, id_range, bits_per_id, words_per_id,\n                num_nodes);\n@@ -222,7 +222,7 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n \n     pub fn add_gen(&mut self, id: ast::NodeId, bit: uint) {\n         //! Indicates that `id` generates `bit`\n-        debug!(\"{:s} add_gen(id={:?}, bit={:?})\",\n+        debug!(\"{:s} add_gen(id={}, bit={})\",\n                self.analysis_name, id, bit);\n         assert!(self.nodeid_to_index.contains_key(&id));\n         assert!(self.bits_per_id > 0);\n@@ -235,7 +235,7 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n \n     pub fn add_kill(&mut self, id: ast::NodeId, bit: uint) {\n         //! Indicates that `id` kills `bit`\n-        debug!(\"{:s} add_kill(id={:?}, bit={:?})\",\n+        debug!(\"{:s} add_kill(id={}, bit={})\",\n                self.analysis_name, id, bit);\n         assert!(self.nodeid_to_index.contains_key(&id));\n         assert!(self.bits_per_id > 0);\n@@ -336,7 +336,7 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n         let cfgidx = to_cfgidx_or_die(id, &self.nodeid_to_index);\n         let (start, end) = self.compute_id_range(cfgidx);\n         let gens = self.gens.slice(start, end);\n-        debug!(\"{:s} each_gen_bit(id={:?}, gens={})\",\n+        debug!(\"{:s} each_gen_bit(id={}, gens={})\",\n                self.analysis_name, id, bits_to_string(gens));\n         self.each_bit(gens, f)\n     }\n@@ -408,7 +408,7 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n                     }\n                     None => {\n                         debug!(\"{:s} add_kills_from_flow_exits flow_exit={} \\\n-                                no cfg_idx for exiting_scope={:?}\",\n+                                no cfg_idx for exiting_scope={}\",\n                                self.analysis_name, flow_exit, node_id);\n                     }\n                 }\n@@ -529,7 +529,7 @@ impl<'a, 'b, 'tcx, O:DataFlowOperator> PropagationContext<'a, 'b, 'tcx, O> {\n             bitwise(on_entry, pred_bits, &self.dfcx.oper)\n         };\n         if changed {\n-            debug!(\"{:s} changed entry set for {:?} to {}\",\n+            debug!(\"{:s} changed entry set for {} to {}\",\n                    self.dfcx.analysis_name, cfgidx,\n                    bits_to_string(self.dfcx.on_entry.slice(start, end)));\n             self.changed = true;"}, {"sha": "bde868cdf6d07ea2022bffc04618b05e506022da", "filename": "src/librustc/middle/effect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrustc%2Fmiddle%2Feffect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrustc%2Fmiddle%2Feffect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Feffect.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -55,7 +55,7 @@ impl<'a, 'tcx> EffectCheckVisitor<'a, 'tcx> {\n             }\n             UnsafeBlock(block_id) => {\n                 // OK, but record this.\n-                debug!(\"effect: recording unsafe block as used: {:?}\", block_id);\n+                debug!(\"effect: recording unsafe block as used: {}\", block_id);\n                 self.tcx.used_unsafe.borrow_mut().insert(block_id);\n             }\n             UnsafeFn => {}"}, {"sha": "65633cfb34cd7f0d31ddc2b996e9616607448a36", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -73,7 +73,7 @@ pub trait Delegate {\n               mode: MutateMode);\n }\n \n-#[deriving(PartialEq)]\n+#[deriving(PartialEq, Show)]\n pub enum LoanCause {\n     ClosureCapture(Span),\n     AddrOf,\n@@ -85,7 +85,7 @@ pub enum LoanCause {\n     MatchDiscriminant\n }\n \n-#[deriving(PartialEq,Show)]\n+#[deriving(PartialEq, Show)]\n pub enum ConsumeMode {\n     Copy,                // reference to x where x has a type that copies\n     Move(MoveReason),    // reference to x where x has a type that moves\n@@ -625,7 +625,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,TYPER> {\n          * meaning either copied or moved depending on its type.\n          */\n \n-        debug!(\"walk_block(blk.id={:?})\", blk.id);\n+        debug!(\"walk_block(blk.id={})\", blk.id);\n \n         for stmt in blk.stmts.iter() {\n             self.walk_stmt(&**stmt);"}, {"sha": "463eaa40ae03e30f8f1ac1fd31ad58f8421873d2", "filename": "src/librustc/middle/graph.rs", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrustc%2Fmiddle%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrustc%2Fmiddle%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fgraph.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -36,6 +36,7 @@ be indexed by the direction (see the type `Direction`).\n \n #![allow(dead_code)] // still WIP\n \n+use std::fmt::{Formatter, FormatError, Show};\n use std::uint;\n \n pub struct Graph<N,E> {\n@@ -55,12 +56,20 @@ pub struct Edge<E> {\n     pub data: E,\n }\n \n+impl<E: Show> Show for Edge<E> {\n+    fn fmt(&self, f: &mut Formatter) -> Result<(), FormatError> {\n+        write!(f, \"Edge {{ next_edge: [{}, {}], source: {}, target: {}, data: {} }}\",\n+               self.next_edge[0], self.next_edge[1], self.source,\n+               self.target, self.data)\n+    }\n+}\n+\n #[deriving(Clone, PartialEq, Show)]\n pub struct NodeIndex(pub uint);\n #[allow(non_uppercase_statics)]\n pub const InvalidNodeIndex: NodeIndex = NodeIndex(uint::MAX);\n \n-#[deriving(PartialEq)]\n+#[deriving(PartialEq, Show)]\n pub struct EdgeIndex(pub uint);\n #[allow(non_uppercase_statics)]\n pub const InvalidEdgeIndex: EdgeIndex = EdgeIndex(uint::MAX);\n@@ -307,6 +316,7 @@ impl<E> Edge<E> {\n #[cfg(test)]\n mod test {\n     use middle::graph::*;\n+    use std::fmt::Show;\n \n     type TestNode = Node<&'static str>;\n     type TestEdge = Edge<&'static str>;\n@@ -361,7 +371,7 @@ mod test {\n         });\n     }\n \n-    fn test_adjacent_edges<N:PartialEq,E:PartialEq>(graph: &Graph<N,E>,\n+    fn test_adjacent_edges<N:PartialEq+Show,E:PartialEq+Show>(graph: &Graph<N,E>,\n                                       start_index: NodeIndex,\n                                       start_data: N,\n                                       expected_incoming: &[(E,N)],\n@@ -372,7 +382,7 @@ mod test {\n         graph.each_incoming_edge(start_index, |edge_index, edge| {\n             assert!(graph.edge_data(edge_index) == &edge.data);\n             assert!(counter < expected_incoming.len());\n-            debug!(\"counter={:?} expected={:?} edge_index={:?} edge={:?}\",\n+            debug!(\"counter={} expected={} edge_index={} edge={}\",\n                    counter, expected_incoming[counter], edge_index, edge);\n             match expected_incoming[counter] {\n                 (ref e, ref n) => {\n@@ -390,7 +400,7 @@ mod test {\n         graph.each_outgoing_edge(start_index, |edge_index, edge| {\n             assert!(graph.edge_data(edge_index) == &edge.data);\n             assert!(counter < expected_outgoing.len());\n-            debug!(\"counter={:?} expected={:?} edge_index={:?} edge={:?}\",\n+            debug!(\"counter={} expected={} edge_index={} edge={}\",\n                    counter, expected_outgoing[counter], edge_index, edge);\n             match expected_outgoing[counter] {\n                 (ref e, ref n) => {"}, {"sha": "68411549c3cefc1a91782b97b71089a7b5871940", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -284,7 +284,6 @@ lets_do_this! {\n     StartFnLangItem,                 \"start\",                   start_fn;\n \n     TyDescStructLangItem,            \"ty_desc\",                 ty_desc;\n-    TyVisitorTraitLangItem,          \"ty_visitor\",              ty_visitor;\n     OpaqueStructLangItem,            \"opaque\",                  opaque;\n \n     TypeIdLangItem,                  \"type_id\",                 type_id;"}, {"sha": "490e49d051ee58addee73a8e4b87546a665bafff", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -154,7 +154,7 @@ impl Clone for LiveNode {\n     }\n }\n \n-#[deriving(PartialEq)]\n+#[deriving(PartialEq, Show)]\n enum LiveNodeKind {\n     FreeVarNode(Span),\n     ExprNode(Span),\n@@ -240,11 +240,13 @@ struct CaptureInfo {\n     var_nid: NodeId\n }\n \n+#[deriving(Show)]\n struct LocalInfo {\n     id: NodeId,\n     ident: Ident\n }\n \n+#[deriving(Show)]\n enum VarKind {\n     Arg(NodeId, Ident),\n     Local(LocalInfo),\n@@ -307,7 +309,7 @@ impl<'a, 'tcx> IrMaps<'a, 'tcx> {\n             ImplicitRet => {}\n         }\n \n-        debug!(\"{} is {:?}\", v.to_string(), vk);\n+        debug!(\"{} is {}\", v.to_string(), vk);\n \n         v\n     }\n@@ -424,7 +426,7 @@ fn visit_local(ir: &mut IrMaps, local: &ast::Local) {\n fn visit_arm(ir: &mut IrMaps, arm: &Arm) {\n     for pat in arm.pats.iter() {\n         pat_util::pat_bindings(&ir.tcx.def_map, &**pat, |bm, p_id, sp, path1| {\n-            debug!(\"adding local variable {} from match with bm {:?}\",\n+            debug!(\"adding local variable {} from match with bm {}\",\n                    p_id, bm);\n             let name = path1.node;\n             ir.add_live_node_for_node(p_id, VarDefNode(sp));\n@@ -442,7 +444,7 @@ fn visit_expr(ir: &mut IrMaps, expr: &Expr) {\n       // live nodes required for uses or definitions of variables:\n       ExprPath(_) => {\n         let def = ir.tcx.def_map.borrow().get_copy(&expr.id);\n-        debug!(\"expr {}: path that leads to {:?}\", expr.id, def);\n+        debug!(\"expr {}: path that leads to {}\", expr.id, def);\n         match def {\n             DefLocal(..) => ir.add_live_node_for_node(expr.id, ExprNode(expr.span)),\n             _ => {}\n@@ -489,7 +491,7 @@ fn visit_expr(ir: &mut IrMaps, expr: &Expr) {\n       }\n       ExprForLoop(ref pat, _, _, _) => {\n         pat_util::pat_bindings(&ir.tcx.def_map, &**pat, |bm, p_id, sp, path1| {\n-            debug!(\"adding local variable {} from for loop with bm {:?}\",\n+            debug!(\"adding local variable {} from for loop with bm {}\",\n                    p_id, bm);\n             let name = path1.node;\n             ir.add_live_node_for_node(p_id, VarDefNode(sp));\n@@ -733,7 +735,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         let mut wr = io::MemWriter::new();\n         {\n             let wr = &mut wr as &mut io::Writer;\n-            write!(wr, \"[ln({}) of kind {:?} reads\", ln.get(), self.ir.lnk(ln));\n+            write!(wr, \"[ln({}) of kind {} reads\", ln.get(), self.ir.lnk(ln));\n             self.write_vars(wr, ln, |idx| self.users.get(idx).reader);\n             write!(wr, \"  writes\");\n             self.write_vars(wr, ln, |idx| self.users.get(idx).writer);"}, {"sha": "c5993dcb39de876696052578e560c7b2727397fa", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -78,7 +78,7 @@ use syntax::parse::token;\n use std::cell::RefCell;\n use std::rc::Rc;\n \n-#[deriving(Clone, PartialEq)]\n+#[deriving(Clone, PartialEq, Show)]\n pub enum categorization {\n     cat_rvalue(ty::Region),            // temporary val, argument is its scope\n     cat_static_item,\n@@ -94,7 +94,7 @@ pub enum categorization {\n     // (*1) downcast is only required if the enum has more than one variant\n }\n \n-#[deriving(Clone, PartialEq)]\n+#[deriving(Clone, PartialEq, Show)]\n pub enum CopiedUpvarKind {\n     Boxed(ast::Onceness),\n     Unboxed(ty::UnboxedClosureKind)\n@@ -111,15 +111,15 @@ impl CopiedUpvarKind {\n     }\n }\n \n-#[deriving(Clone, PartialEq)]\n+#[deriving(Clone, PartialEq, Show)]\n pub struct CopiedUpvar {\n     pub upvar_id: ast::NodeId,\n     pub kind: CopiedUpvarKind,\n     pub capturing_proc: ast::NodeId,\n }\n \n // different kinds of pointers:\n-#[deriving(Clone, PartialEq, Eq, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Hash, Show)]\n pub enum PointerKind {\n     OwnedPtr,\n     BorrowedPtr(ty::BorrowKind, ty::Region),\n@@ -129,19 +129,19 @@ pub enum PointerKind {\n \n // We use the term \"interior\" to mean \"something reachable from the\n // base without a pointer dereference\", e.g. a field\n-#[deriving(Clone, PartialEq, Eq, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Hash, Show)]\n pub enum InteriorKind {\n     InteriorField(FieldName),\n     InteriorElement(ElementKind),\n }\n \n-#[deriving(Clone, PartialEq, Eq, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Hash, Show)]\n pub enum FieldName {\n     NamedField(ast::Name),\n     PositionalField(uint)\n }\n \n-#[deriving(Clone, PartialEq, Eq, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Hash, Show)]\n pub enum ElementKind {\n     VecElement,\n     OtherElement,\n@@ -168,7 +168,7 @@ pub enum MutabilityCategory {\n // dereference, but its type is the type *before* the dereference\n // (`@T`). So use `cmt.ty` to find the type of the value in a consistent\n // fashion. For more details, see the method `cat_pattern`\n-#[deriving(Clone, PartialEq)]\n+#[deriving(Clone, PartialEq, Show)]\n pub struct cmt_ {\n     pub id: ast::NodeId,          // id of expr/pat producing this value\n     pub span: Span,                // span of same expr/pat\n@@ -542,7 +542,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                    expr_ty: ty::t,\n                    def: def::Def)\n                    -> McResult<cmt> {\n-        debug!(\"cat_def: id={} expr={} def={:?}\",\n+        debug!(\"cat_def: id={} expr={} def={}\",\n                id, expr_ty.repr(self.tcx()), def);\n \n         match def {\n@@ -781,7 +781,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n         };\n         let method_ty = self.typer.node_method_ty(method_call);\n \n-        debug!(\"cat_deref: method_call={:?} method_ty={}\",\n+        debug!(\"cat_deref: method_call={} method_ty={}\",\n             method_call, method_ty.map(|ty| ty.repr(self.tcx())));\n \n         let base_cmt = match method_ty {\n@@ -1352,7 +1352,7 @@ impl cmt_ {\n \n impl Repr for cmt_ {\n     fn repr(&self, tcx: &ty::ctxt) -> String {\n-        format!(\"{{{} id:{} m:{:?} ty:{}}}\",\n+        format!(\"{{{} id:{} m:{} ty:{}}}\",\n                 self.cat.repr(tcx),\n                 self.id,\n                 self.mutbl,\n@@ -1368,7 +1368,7 @@ impl Repr for categorization {\n             cat_copied_upvar(..) |\n             cat_local(..) |\n             cat_upvar(..) => {\n-                format!(\"{:?}\", *self)\n+                format!(\"{}\", *self)\n             }\n             cat_deref(ref cmt, derefs, ptr) => {\n                 format!(\"{}-{}{}->\", cmt.cat.repr(tcx), ptr_sigil(ptr), derefs)\n@@ -1405,7 +1405,7 @@ impl Repr for InteriorKind {\n             InteriorField(NamedField(fld)) => {\n                 token::get_name(fld).get().to_string()\n             }\n-            InteriorField(PositionalField(i)) => format!(\"#{:?}\", i),\n+            InteriorField(PositionalField(i)) => format!(\"#{}\", i),\n             InteriorElement(_) => \"[]\".to_string(),\n         }\n     }"}, {"sha": "6e430760e368ff347a04d2f10950403d1c026e21", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -347,7 +347,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EmbargoVisitor<'a, 'tcx> {\n         // This code is here instead of in visit_item so that the\n         // crate module gets processed as well.\n         if self.prev_exported {\n-            assert!(self.exp_map2.contains_key(&id), \"wut {:?}\", id);\n+            assert!(self.exp_map2.contains_key(&id), \"wut {}\", id);\n             for export in self.exp_map2.get(&id).iter() {\n                 if is_local(export.def_id) {\n                     self.reexports.insert(export.def_id.node);\n@@ -394,28 +394,28 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n     fn def_privacy(&self, did: ast::DefId) -> PrivacyResult {\n         if !is_local(did) {\n             if self.external_exports.contains(&did) {\n-                debug!(\"privacy - {:?} was externally exported\", did);\n+                debug!(\"privacy - {} was externally exported\", did);\n                 return Allowable;\n             }\n-            debug!(\"privacy - is {:?} a public method\", did);\n+            debug!(\"privacy - is {} a public method\", did);\n \n             return match self.tcx.impl_or_trait_items.borrow().find(&did) {\n                 Some(&ty::MethodTraitItem(ref meth)) => {\n-                    debug!(\"privacy - well at least it's a method: {:?}\",\n+                    debug!(\"privacy - well at least it's a method: {}\",\n                            *meth);\n                     match meth.container {\n                         ty::TraitContainer(id) => {\n-                            debug!(\"privacy - recursing on trait {:?}\", id);\n+                            debug!(\"privacy - recursing on trait {}\", id);\n                             self.def_privacy(id)\n                         }\n                         ty::ImplContainer(id) => {\n                             match ty::impl_trait_ref(self.tcx, id) {\n                                 Some(t) => {\n-                                    debug!(\"privacy - impl of trait {:?}\", id);\n+                                    debug!(\"privacy - impl of trait {}\", id);\n                                     self.def_privacy(t.def_id)\n                                 }\n                                 None => {\n-                                    debug!(\"privacy - found a method {:?}\",\n+                                    debug!(\"privacy - found a method {}\",\n                                             meth.vis);\n                                     if meth.vis == ast::Public {\n                                         Allowable\n@@ -430,17 +430,17 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n                 Some(&ty::TypeTraitItem(ref typedef)) => {\n                     match typedef.container {\n                         ty::TraitContainer(id) => {\n-                            debug!(\"privacy - recursing on trait {:?}\", id);\n+                            debug!(\"privacy - recursing on trait {}\", id);\n                             self.def_privacy(id)\n                         }\n                         ty::ImplContainer(id) => {\n                             match ty::impl_trait_ref(self.tcx, id) {\n                                 Some(t) => {\n-                                    debug!(\"privacy - impl of trait {:?}\", id);\n+                                    debug!(\"privacy - impl of trait {}\", id);\n                                     self.def_privacy(t.def_id)\n                                 }\n                                 None => {\n-                                    debug!(\"privacy - found a typedef {:?}\",\n+                                    debug!(\"privacy - found a typedef {}\",\n                                             typedef.vis);\n                                     if typedef.vis == ast::Public {\n                                         Allowable\n@@ -551,7 +551,7 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n         // members, so that's why we test the parent, and not the did itself.\n         let mut cur = self.curitem;\n         loop {\n-            debug!(\"privacy - questioning {}, {:?}\", self.nodestr(cur), cur);\n+            debug!(\"privacy - questioning {}, {}\", self.nodestr(cur), cur);\n             match cur {\n                 // If the relevant parent is in our history, then we're allowed\n                 // to look inside any of our ancestor's immediate private items,"}, {"sha": "cf48e1899d18ef8cc369310616d74c66e1346da1", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -113,7 +113,7 @@ impl RegionMaps {\n             None => {}\n         }\n \n-        debug!(\"relate_free_regions(sub={:?}, sup={:?})\", sub, sup);\n+        debug!(\"relate_free_regions(sub={}, sup={})\", sub, sup);\n         self.free_region_map.borrow_mut().insert(sub, vec!(sup));\n     }\n \n@@ -211,7 +211,7 @@ impl RegionMaps {\n         //! Returns the lifetime of the variable `id`.\n \n         let scope = ty::ReScope(self.var_scope(id));\n-        debug!(\"var_region({}) = {:?}\", id, scope);\n+        debug!(\"var_region({}) = {}\", id, scope);\n         scope\n     }\n \n@@ -270,7 +270,7 @@ impl RegionMaps {\n          * duplicated with the code in infer.rs.\n          */\n \n-        debug!(\"is_subregion_of(sub_region={:?}, super_region={:?})\",\n+        debug!(\"is_subregion_of(sub_region={}, super_region={})\",\n                sub_region, super_region);\n \n         sub_region == super_region || {\n@@ -802,7 +802,7 @@ fn resolve_fn(visitor: &mut RegionResolutionVisitor,\n               sp: Span,\n               id: ast::NodeId) {\n     debug!(\"region::resolve_fn(id={}, \\\n-                               span={:?}, \\\n+                               span={}, \\\n                                body.id={}, \\\n                                cx.parent={})\",\n            id,"}, {"sha": "0aff56ba3cfc5ac0c09992c820313986baab50cb", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 27, "deletions": 25, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -94,6 +94,7 @@ pub type ExternalExports = DefIdSet;\n // FIXME: dox\n pub type LastPrivateMap = NodeMap<LastPrivate>;\n \n+#[deriving(Show)]\n pub enum LastPrivate {\n     LastMod(PrivateDep),\n     // `use` directives (imports) can refer to two separate definitions in the\n@@ -107,13 +108,14 @@ pub enum LastPrivate {\n                pub type_used: ImportUse},\n }\n \n+#[deriving(Show)]\n pub enum PrivateDep {\n     AllPublic,\n     DependsOn(DefId),\n }\n \n // How an import is used.\n-#[deriving(PartialEq)]\n+#[deriving(PartialEq, Show)]\n pub enum ImportUse {\n     Unused,       // The import is not used.\n     Used,         // The import is used.\n@@ -135,7 +137,7 @@ enum PatternBindingMode {\n     ArgumentIrrefutableMode,\n }\n \n-#[deriving(PartialEq, Eq, Hash)]\n+#[deriving(PartialEq, Eq, Hash, Show)]\n enum Namespace {\n     TypeNS,\n     ValueNS\n@@ -576,7 +578,7 @@ struct TypeNsDef {\n }\n \n // Records a possibly-private value definition.\n-#[deriving(Clone)]\n+#[deriving(Clone, Show)]\n struct ValueNsDef {\n     is_public: bool, // see note in ImportResolution about how to use this\n     def: Def,\n@@ -1761,7 +1763,7 @@ impl<'a> Resolver<'a> {\n                            ident: Ident,\n                            new_parent: ReducedGraphParent) {\n         debug!(\"(building reduced graph for \\\n-                external crate) building external def, priv {:?}\",\n+                external crate) building external def, priv {}\",\n                vis);\n         let is_public = vis == ast::Public;\n         let is_exported = is_public && match new_parent {\n@@ -1900,13 +1902,13 @@ impl<'a> Resolver<'a> {\n           }\n           DefMethod(..) => {\n               debug!(\"(building reduced graph for external crate) \\\n-                      ignoring {:?}\", def);\n+                      ignoring {}\", def);\n               // Ignored; handled elsewhere.\n           }\n           DefLocal(..) | DefPrimTy(..) | DefTyParam(..) |\n           DefUse(..) | DefUpvar(..) | DefRegion(..) |\n           DefTyParamBinder(..) | DefLabel(..) | DefSelfTy(..) => {\n-            fail!(\"didn't expect `{:?}`\", def);\n+            fail!(\"didn't expect `{}`\", def);\n           }\n         }\n     }\n@@ -2420,7 +2422,7 @@ impl<'a> Resolver<'a> {\n                              lp: LastPrivate)\n                                  -> ResolveResult<()> {\n         debug!(\"(resolving single import) resolving `{}` = `{}::{}` from \\\n-                `{}` id {}, last private {:?}\",\n+                `{}` id {}, last private {}\",\n                token::get_ident(target),\n                self.module_to_string(&*containing_module),\n                token::get_ident(source),\n@@ -2522,7 +2524,7 @@ impl<'a> Resolver<'a> {\n                                     shadowable: _\n                                 }) => {\n                                     debug!(\"(resolving single import) found \\\n-                                            import in ns {:?}\", namespace);\n+                                            import in ns {}\", namespace);\n                                     let id = import_resolution.id(namespace);\n                                     // track used imports and extern crates as well\n                                     this.used_imports.insert((id, namespace));\n@@ -2596,7 +2598,7 @@ impl<'a> Resolver<'a> {\n \n         match value_result {\n             BoundResult(ref target_module, ref name_bindings) => {\n-                debug!(\"(resolving single import) found value target: {:?}\",\n+                debug!(\"(resolving single import) found value target: {}\",\n                        { name_bindings.value_def.borrow().clone().unwrap().def });\n                 self.check_for_conflicting_import(\n                     &import_resolution.value_target,\n@@ -2619,7 +2621,7 @@ impl<'a> Resolver<'a> {\n         }\n         match type_result {\n             BoundResult(ref target_module, ref name_bindings) => {\n-                debug!(\"(resolving single import) found type target: {:?}\",\n+                debug!(\"(resolving single import) found type target: {}\",\n                        { name_bindings.type_def.borrow().clone().unwrap().type_def });\n                 self.check_for_conflicting_import(\n                     &import_resolution.type_target,\n@@ -2724,7 +2726,7 @@ impl<'a> Resolver<'a> {\n                                                   .borrow();\n         for (ident, target_import_resolution) in import_resolutions.iter() {\n             debug!(\"(resolving glob import) writing module resolution \\\n-                    {:?} into `{}`\",\n+                    {} into `{}`\",\n                    target_import_resolution.type_target.is_none(),\n                    self.module_to_string(module_));\n \n@@ -3305,7 +3307,7 @@ impl<'a> Resolver<'a> {\n                                      namespace: Namespace)\n                                     -> ResolveResult<(Target, bool)> {\n         debug!(\"(resolving item in lexical scope) resolving `{}` in \\\n-                namespace {:?} in `{}`\",\n+                namespace {} in `{}`\",\n                token::get_ident(name),\n                namespace,\n                self.module_to_string(&*module_));\n@@ -3339,7 +3341,7 @@ impl<'a> Resolver<'a> {\n                     None => {\n                         // Not found; continue.\n                         debug!(\"(resolving item in lexical scope) found \\\n-                                import resolution, but not in namespace {:?}\",\n+                                import resolution, but not in namespace {}\",\n                                namespace);\n                     }\n                     Some(target) => {\n@@ -3620,7 +3622,7 @@ impl<'a> Resolver<'a> {\n                 match import_resolution.target_for_namespace(namespace) {\n                     None => {\n                         debug!(\"(resolving name in module) name found, \\\n-                                but not in namespace {:?}\",\n+                                but not in namespace {}\",\n                                namespace);\n                     }\n                     Some(target) => {\n@@ -3780,15 +3782,15 @@ impl<'a> Resolver<'a> {\n         match namebindings.def_for_namespace(ns) {\n             Some(d) => {\n                 let name = token::get_name(name);\n-                debug!(\"(computing exports) YES: export '{}' => {:?}\",\n+                debug!(\"(computing exports) YES: export '{}' => {}\",\n                        name, d.def_id());\n                 exports2.push(Export2 {\n                     name: name.get().to_string(),\n                     def_id: d.def_id()\n                 });\n             }\n             d_opt => {\n-                debug!(\"(computing exports) NO: {:?}\", d_opt);\n+                debug!(\"(computing exports) NO: {}\", d_opt);\n             }\n         }\n     }\n@@ -4447,7 +4449,7 @@ impl<'a> Resolver<'a> {\n             Some(def) => {\n                 match def {\n                     (DefTrait(_), _) => {\n-                        debug!(\"(resolving trait) found trait def: {:?}\", def);\n+                        debug!(\"(resolving trait) found trait def: {}\", def);\n                         self.record_def(trait_reference.ref_id, def);\n                     }\n                     (def, _) => {\n@@ -4840,7 +4842,7 @@ impl<'a> Resolver<'a> {\n                         match self.resolve_path(ty.id, path, TypeNS, true) {\n                             Some(def) => {\n                                 debug!(\"(resolving type) resolved `{}` to \\\n-                                        type {:?}\",\n+                                        type {}\",\n                                        token::get_ident(path.segments\n                                                             .last().unwrap()\n                                                             .identifier),\n@@ -5124,7 +5126,7 @@ impl<'a> Resolver<'a> {\n                         }\n                         result => {\n                             debug!(\"(resolving pattern) didn't find struct \\\n-                                    def: {:?}\", result);\n+                                    def: {}\", result);\n                             let msg = format!(\"`{}` does not name a structure\",\n                                               self.path_idents_to_string(path));\n                             self.resolve_error(path.span, msg.as_slice());\n@@ -5148,7 +5150,7 @@ impl<'a> Resolver<'a> {\n                                                  ValueNS) {\n             Success((target, _)) => {\n                 debug!(\"(resolve bare identifier pattern) succeeded in \\\n-                         finding {} at {:?}\",\n+                         finding {} at {}\",\n                         token::get_ident(name),\n                         target.bindings.value_def.borrow());\n                 match *target.bindings.value_def.borrow() {\n@@ -5489,7 +5491,7 @@ impl<'a> Resolver<'a> {\n         match search_result {\n             Some(DlDef(def)) => {\n                 debug!(\"(resolving path in local ribs) resolved `{}` to \\\n-                        local: {:?}\",\n+                        local: {}\",\n                        token::get_ident(ident),\n                        def);\n                 return Some(def);\n@@ -5840,7 +5842,7 @@ impl<'a> Resolver<'a> {\n                     Some(definition) => self.record_def(expr.id, definition),\n                     result => {\n                         debug!(\"(resolving expression) didn't find struct \\\n-                                def: {:?}\", result);\n+                                def: {}\", result);\n                         let msg = format!(\"`{}` does not name a structure\",\n                                           self.path_idents_to_string(path));\n                         self.resolve_error(path.span, msg.as_slice());\n@@ -6026,7 +6028,7 @@ impl<'a> Resolver<'a> {\n     }\n \n     fn record_def(&mut self, node_id: NodeId, (def, lp): (Def, LastPrivate)) {\n-        debug!(\"(recording def) recording {:?} for {:?}, last private {:?}\",\n+        debug!(\"(recording def) recording {} for {}, last private {}\",\n                 def, node_id, lp);\n         assert!(match lp {LastImport{..} => false, _ => true},\n                 \"Import should only be used for `use` directives\");\n@@ -6038,8 +6040,8 @@ impl<'a> Resolver<'a> {\n             // the same conclusion! - nmatsakis\n             Occupied(entry) => if def != *entry.get() {\n                 self.session\n-                    .bug(format!(\"node_id {:?} resolved first to {:?} and \\\n-                                  then {:?}\",\n+                    .bug(format!(\"node_id {} resolved first to {} and \\\n+                                  then {}\",\n                                  node_id,\n                                  *entry.get(),\n                                  def).as_slice());"}, {"sha": "6f517f1f166b9a4be37e441e946cb5ef106c0088", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -57,6 +57,7 @@ struct LifetimeContext<'a> {\n     scope: Scope<'a>\n }\n \n+#[deriving(Show)]\n enum ScopeChain<'a> {\n     /// EarlyScope(i, ['a, 'b, ...], s) extends s with early-bound\n     /// lifetimes, assigning indexes 'a => i, 'b => i+1, ... etc.\n@@ -118,10 +119,10 @@ impl<'a, 'v> Visitor<'v> for LifetimeContext<'a> {\n         };\n \n         self.with(|_, f| f(EarlyScope(subst::TypeSpace, lifetimes, &ROOT_SCOPE)), |v| {\n-            debug!(\"entering scope {:?}\", v.scope);\n+            debug!(\"entering scope {}\", v.scope);\n             v.check_lifetime_defs(lifetimes);\n             visit::walk_item(v, item);\n-            debug!(\"exiting scope {:?}\", v.scope);\n+            debug!(\"exiting scope {}\", v.scope);\n         });\n     }\n \n@@ -268,7 +269,7 @@ impl<'a> LifetimeContext<'a> {\n \n         let referenced_idents = early_bound_lifetime_names(generics);\n         debug!(\"pushing fn scope id={} due to fn item/method\\\n-               referenced_idents={:?}\",\n+               referenced_idents={}\",\n                n,\n                referenced_idents.iter().map(lifetime_show).collect::<Vec<token::InternedString>>());\n         let lifetimes = &generics.lifetimes;\n@@ -439,7 +440,7 @@ impl<'a> LifetimeContext<'a> {\n                                probably a bug in syntax::fold\");\n         }\n \n-        debug!(\"lifetime_ref={} id={} resolved to {:?}\",\n+        debug!(\"lifetime_ref={} id={} resolved to {}\",\n                 lifetime_to_string(lifetime_ref),\n                 lifetime_ref.id,\n                 def);"}, {"sha": "9dfde7ec08415ab337f40b78edf4318153dd1752", "filename": "src/librustc/middle/save/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrustc%2Fmiddle%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrustc%2Fmiddle%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsave%2Fmod.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -246,7 +246,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n             def::DefUse(_) |\n             def::DefMethod(..) |\n             def::DefPrimTy(_) => {\n-                self.sess.span_bug(span, format!(\"lookup_def_kind for unexpected item: {:?}\",\n+                self.sess.span_bug(span, format!(\"lookup_def_kind for unexpected item: {}\",\n                                                  def).as_slice());\n             },\n         }\n@@ -313,7 +313,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                 },\n                 _ => {\n                     self.sess.span_bug(method.span,\n-                                       format!(\"Container {} for method {} is not a node item {:?}\",\n+                                       format!(\"Container {} for method {} is not a node item {}\",\n                                                impl_id.node,\n                                                method.id,\n                                                self.analysis.ty_cx.map.get(impl_id.node)\n@@ -1415,7 +1415,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n                 // FIXME(nrc) what is this doing here?\n                 def::DefStatic(_, _) => {}\n                 def::DefConst(..) => {}\n-                _ => error!(\"unexpected definition kind when processing collected paths: {:?}\",\n+                _ => error!(\"unexpected definition kind when processing collected paths: {}\",\n                             *def)\n             }\n         }"}, {"sha": "c31a3730a7c36969b834367cc078bb084cbdd234", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -226,6 +226,7 @@ use syntax::codemap::Span;\n use syntax::fold::Folder;\n use syntax::ptr::P;\n \n+#[deriving(Show)]\n struct ConstantExpr<'a>(&'a ast::Expr);\n \n impl<'a> ConstantExpr<'a> {\n@@ -240,6 +241,7 @@ impl<'a> ConstantExpr<'a> {\n }\n \n // An option identifying a branch (either a literal, an enum variant or a range)\n+#[deriving(Show)]\n enum Opt<'a> {\n     ConstantValue(ConstantExpr<'a>),\n     ConstantRange(ConstantExpr<'a>, ConstantExpr<'a>),\n@@ -519,7 +521,7 @@ fn enter_opt<'a, 'p, 'blk, 'tcx>(\n              variant_size: uint,\n              val: ValueRef)\n              -> Vec<Match<'a, 'p, 'blk, 'tcx>> {\n-    debug!(\"enter_opt(bcx={}, m={}, opt={:?}, col={}, val={})\",\n+    debug!(\"enter_opt(bcx={}, m={}, opt={}, col={}, val={})\",\n            bcx.to_str(),\n            m.repr(bcx.tcx()),\n            *opt,\n@@ -863,7 +865,7 @@ fn insert_lllocals<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n             _ => {}\n         }\n \n-        debug!(\"binding {:?} to {}\",\n+        debug!(\"binding {} to {}\",\n                binding_info.id,\n                bcx.val_to_string(llval));\n         bcx.fcx.lllocals.borrow_mut().insert(binding_info.id, datum);\n@@ -1048,7 +1050,7 @@ fn compile_submatch_continue<'a, 'p, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n \n     // Decide what kind of branch we need\n     let opts = get_branches(bcx, m, col);\n-    debug!(\"options={:?}\", opts);\n+    debug!(\"options={}\", opts);\n     let mut kind = NoBranch;\n     let mut test_val = val;\n     debug!(\"test_val={}\", bcx.val_to_string(test_val));"}, {"sha": "2f06f16ace1311cefea3e752e579e4bf4a8a07a9", "filename": "src/librustc/middle/trans/adt.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -74,7 +74,7 @@ type Hint = attr::ReprAttr;\n \n \n /// Representations.\n-#[deriving(Eq, PartialEq)]\n+#[deriving(Eq, PartialEq, Show)]\n pub enum Repr {\n     /// C-like enums; basically an int.\n     CEnum(IntType, Disr, Disr), // discriminant range (signedness based on the IntType)\n@@ -127,7 +127,7 @@ pub enum Repr {\n }\n \n /// For structs, and struct-like parts of anything fancier.\n-#[deriving(Eq, PartialEq)]\n+#[deriving(Eq, PartialEq, Show)]\n pub struct Struct {\n     // If the struct is DST, then the size and alignment do not take into\n     // account the unsized fields of the struct.\n@@ -156,7 +156,7 @@ pub fn represent_type(cx: &CrateContext, t: ty::t) -> Rc<Repr> {\n     }\n \n     let repr = Rc::new(represent_type_uncached(cx, t));\n-    debug!(\"Represented as: {:?}\", repr)\n+    debug!(\"Represented as: {}\", repr)\n     cx.adt_reprs().borrow_mut().insert(t, repr.clone());\n     repr\n }\n@@ -371,6 +371,7 @@ fn mk_struct(cx: &CrateContext, tys: &[ty::t], packed: bool) -> Struct {\n     }\n }\n \n+#[deriving(Show)]\n struct IntBounds {\n     slo: i64,\n     shi: i64,\n@@ -387,7 +388,7 @@ fn mk_cenum(cx: &CrateContext, hint: Hint, bounds: &IntBounds) -> Repr {\n }\n \n fn range_to_inttype(cx: &CrateContext, hint: Hint, bounds: &IntBounds) -> IntType {\n-    debug!(\"range_to_inttype: {:?} {:?}\", hint, bounds);\n+    debug!(\"range_to_inttype: {} {}\", hint, bounds);\n     // Lists of sizes to try.  u64 is always allowed as a fallback.\n     #[allow(non_uppercase_statics)]\n     static choose_shortest: &'static[IntType] = &[\n@@ -440,7 +441,7 @@ pub fn ll_inttype(cx: &CrateContext, ity: IntType) -> Type {\n }\n \n fn bounds_usable(cx: &CrateContext, ity: IntType, bounds: &IntBounds) -> bool {\n-    debug!(\"bounds_usable: {:?} {:?}\", ity, bounds);\n+    debug!(\"bounds_usable: {} {}\", ity, bounds);\n     match ity {\n         attr::SignedInt(_) => {\n             let lllo = C_integral(ll_inttype(cx, ity), bounds.slo as u64, true);\n@@ -538,7 +539,7 @@ fn generic_type_of(cx: &CrateContext,\n                                  Type::array(&Type::i64(cx), align_units),\n                 a if a.count_ones() == 1 => Type::array(&Type::vector(&Type::i32(cx), a / 4),\n                                                               align_units),\n-                _ => fail!(\"unsupported enum alignment: {:?}\", align)\n+                _ => fail!(\"unsupported enum alignment: {}\", align)\n             };\n             assert_eq!(machine::llalign_of_min(cx, pad_ty) as u64, align);\n             assert_eq!(align % discr_size, 0);"}, {"sha": "f4586fca52fd6abd9cdbe95cf0d8b25d20f69ee3", "filename": "src/librustc/middle/trans/asm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -101,7 +101,7 @@ pub fn trans_inline_asm<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, ia: &ast::InlineAsm)\n         constraints.push_str(clobbers.as_slice());\n     }\n \n-    debug!(\"Asm Constraints: {:?}\", constraints.as_slice());\n+    debug!(\"Asm Constraints: {}\", constraints.as_slice());\n \n     let num_outputs = outputs.len();\n "}, {"sha": "c780969034444d6cd89cc0bacd5763de88da591e", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 3, "deletions": 21, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -1088,7 +1088,7 @@ pub fn ignore_lhs(_bcx: Block, local: &ast::Local) -> bool {\n \n pub fn init_local<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, local: &ast::Local)\n                               -> Block<'blk, 'tcx> {\n-    debug!(\"init_local(bcx={}, local.id={:?})\", bcx.to_str(), local.id);\n+    debug!(\"init_local(bcx={}, local.id={})\", bcx.to_str(), local.id);\n     let _indenter = indenter();\n     let _icx = push_ctxt(\"init_local\");\n     _match::store_local(bcx, local)\n@@ -2468,24 +2468,6 @@ pub fn get_fn_llvm_attributes(ccx: &CrateContext, fn_ty: ty::t)\n                      .arg(idx, llvm::DereferenceableAttribute(llsz));\n             }\n \n-            // The visit glue deals only with opaque pointers so we don't\n-            // actually know the concrete type of Self thus we don't know how\n-            // many bytes to mark as dereferenceable so instead we just mark\n-            // it as nonnull which still holds true\n-            ty::ty_rptr(b, ty::mt { ty: it, mutbl }) if match ty::get(it).sty {\n-                ty::ty_param(_) => true, _ => false\n-            } && mutbl == ast::MutMutable => {\n-                attrs.arg(idx, llvm::NoAliasAttribute)\n-                     .arg(idx, llvm::NonNullAttribute);\n-\n-                match b {\n-                    ReLateBound(_, BrAnon(_)) => {\n-                        attrs.arg(idx, llvm::NoCaptureAttribute);\n-                    }\n-                    _ => {}\n-                }\n-            }\n-\n             // `&mut` pointer parameters never alias other parameters, or mutable global data\n             //\n             // `&T` where `T` contains no `UnsafeCell<U>` is immutable, and can be marked as both\n@@ -2672,7 +2654,7 @@ fn contains_null(s: &str) -> bool {\n }\n \n pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n-    debug!(\"get_item_val(id=`{:?}`)\", id);\n+    debug!(\"get_item_val(id=`{}`)\", id);\n \n     match ccx.item_vals().borrow().find_copy(&id) {\n         Some(v) => return v,\n@@ -2857,7 +2839,7 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n         }\n \n         ref variant => {\n-            ccx.sess().bug(format!(\"get_item_val(): unexpected variant: {:?}\",\n+            ccx.sess().bug(format!(\"get_item_val(): unexpected variant: {}\",\n                                    variant).as_slice())\n         }\n     };"}, {"sha": "dbc668a04bac9798a7459de86c957420d8ad8dae", "filename": "src/librustc/middle/trans/builder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -795,11 +795,11 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                          else          { llvm::False };\n \n         let argtys = inputs.iter().map(|v| {\n-            debug!(\"Asm Input Type: {:?}\", self.ccx.tn().val_to_string(*v));\n+            debug!(\"Asm Input Type: {}\", self.ccx.tn().val_to_string(*v));\n             val_ty(*v)\n         }).collect::<Vec<_>>();\n \n-        debug!(\"Asm Output Type: {:?}\", self.ccx.tn().type_to_string(output));\n+        debug!(\"Asm Output Type: {}\", self.ccx.tn().type_to_string(output));\n         let fty = Type::func(argtys.as_slice(), &output);\n         unsafe {\n             let v = llvm::LLVMInlineAsm("}, {"sha": "f607dfdd17f49b3881938f620fbac7664e74005a", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -209,7 +209,7 @@ fn trans<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, expr: &ast::Expr)\n             def::DefSelfTy(..) => {\n                 bcx.tcx().sess.span_bug(\n                     ref_expr.span,\n-                    format!(\"cannot translate def {:?} \\\n+                    format!(\"cannot translate def {} \\\n                              to a callable thing!\", def).as_slice());\n             }\n         }\n@@ -226,7 +226,7 @@ pub fn trans_fn_ref(bcx: Block, def_id: ast::DefId, node: ExprOrMethodCall) -> V\n     let _icx = push_ctxt(\"trans_fn_ref\");\n \n     let substs = node_id_substs(bcx, node);\n-    debug!(\"trans_fn_ref(def_id={}, node={:?}, substs={})\",\n+    debug!(\"trans_fn_ref(def_id={}, node={}, substs={})\",\n            def_id.repr(bcx.tcx()),\n            node,\n            substs.repr(bcx.tcx()));\n@@ -398,7 +398,7 @@ pub fn trans_fn_ref_with_substs(\n     let ccx = bcx.ccx();\n     let tcx = bcx.tcx();\n \n-    debug!(\"trans_fn_ref_with_substs(bcx={}, def_id={}, node={:?}, \\\n+    debug!(\"trans_fn_ref_with_substs(bcx={}, def_id={}, node={}, \\\n             substs={})\",\n            bcx.to_str(),\n            def_id.repr(tcx),"}, {"sha": "9edca215aef8df1773a75d878f2f7c84e39a5240", "filename": "src/librustc/middle/trans/cleanup.rs", "status": "modified", "additions": 33, "deletions": 13, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcleanup.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -23,6 +23,7 @@ use middle::trans::debuginfo;\n use middle::trans::glue;\n use middle::trans::type_::Type;\n use middle::ty;\n+use std::fmt;\n use syntax::ast;\n use util::ppaux::Repr;\n \n@@ -45,6 +46,7 @@ pub struct CleanupScope<'blk, 'tcx: 'blk> {\n     cached_landing_pad: Option<BasicBlockRef>,\n }\n \n+#[deriving(Show)]\n pub struct CustomScopeIndex {\n     index: uint\n }\n@@ -59,7 +61,23 @@ pub enum CleanupScopeKind<'blk, 'tcx: 'blk> {\n     LoopScopeKind(ast::NodeId, [Block<'blk, 'tcx>, ..EXIT_MAX])\n }\n \n-#[deriving(PartialEq)]\n+impl<'blk, 'tcx: 'blk> fmt::Show for CleanupScopeKind<'blk, 'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> Result<(), fmt::FormatError> {\n+        match *self {\n+            CustomScopeKind => write!(f, \"CustomScopeKind\"),\n+            AstScopeKind(nid) => write!(f, \"AstScopeKind({})\", nid),\n+            LoopScopeKind(nid, ref blks) => {\n+                try!(write!(f, \"LoopScopeKind({}, [\", nid));\n+                for blk in blks.iter() {\n+                    try!(write!(f, \"{:p}, \", blk));\n+                }\n+                write!(f, \"])\")\n+            }\n+        }\n+    }\n+}\n+\n+#[deriving(PartialEq, Show)]\n pub enum EarlyExitLabel {\n     UnwindExit,\n     ReturnExit,\n@@ -83,6 +101,7 @@ pub trait Cleanup {\n \n pub type CleanupObj = Box<Cleanup+'static>;\n \n+#[deriving(Show)]\n pub enum ScopeId {\n     AstScope(ast::NodeId),\n     CustomScope(CustomScopeIndex)\n@@ -222,7 +241,7 @@ impl<'blk, 'tcx> CleanupMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx> {\n          * cleanups for normal exit.\n          */\n \n-        debug!(\"pop_and_trans_custom_cleanup_scope({:?})\", custom_scope);\n+        debug!(\"pop_and_trans_custom_cleanup_scope({})\", custom_scope);\n         assert!(self.is_valid_to_pop_custom_scope(custom_scope));\n \n         let scope = self.pop_scope();\n@@ -273,7 +292,7 @@ impl<'blk, 'tcx> CleanupMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx> {\n             ptr: val,\n         };\n \n-        debug!(\"schedule_lifetime_end({:?}, val={})\",\n+        debug!(\"schedule_lifetime_end({}, val={})\",\n                cleanup_scope,\n                self.ccx.tn().val_to_string(val));\n \n@@ -298,7 +317,7 @@ impl<'blk, 'tcx> CleanupMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx> {\n             zero: false\n         };\n \n-        debug!(\"schedule_drop_mem({:?}, val={}, ty={})\",\n+        debug!(\"schedule_drop_mem({}, val={}, ty={})\",\n                cleanup_scope,\n                self.ccx.tn().val_to_string(val),\n                ty.repr(self.ccx.tcx()));\n@@ -324,7 +343,7 @@ impl<'blk, 'tcx> CleanupMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx> {\n             zero: true\n         };\n \n-        debug!(\"schedule_drop_and_zero_mem({:?}, val={}, ty={}, zero={})\",\n+        debug!(\"schedule_drop_and_zero_mem({}, val={}, ty={}, zero={})\",\n                cleanup_scope,\n                self.ccx.tn().val_to_string(val),\n                ty.repr(self.ccx.tcx()),\n@@ -350,7 +369,7 @@ impl<'blk, 'tcx> CleanupMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx> {\n             zero: false\n         };\n \n-        debug!(\"schedule_drop_immediate({:?}, val={}, ty={})\",\n+        debug!(\"schedule_drop_immediate({}, val={}, ty={})\",\n                cleanup_scope,\n                self.ccx.tn().val_to_string(val),\n                ty.repr(self.ccx.tcx()));\n@@ -370,7 +389,7 @@ impl<'blk, 'tcx> CleanupMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx> {\n \n         let drop = box FreeValue { ptr: val, heap: heap, content_ty: content_ty };\n \n-        debug!(\"schedule_free_value({:?}, val={}, heap={:?})\",\n+        debug!(\"schedule_free_value({}, val={}, heap={})\",\n                cleanup_scope,\n                self.ccx.tn().val_to_string(val),\n                heap);\n@@ -391,7 +410,7 @@ impl<'blk, 'tcx> CleanupMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx> {\n \n         let drop = box FreeSlice { ptr: val, size: size, align: align, heap: heap };\n \n-        debug!(\"schedule_free_slice({:?}, val={}, heap={:?})\",\n+        debug!(\"schedule_free_slice({}, val={}, heap={})\",\n                cleanup_scope,\n                self.ccx.tn().val_to_string(val),\n                heap);\n@@ -417,7 +436,7 @@ impl<'blk, 'tcx> CleanupMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx> {\n          * in the topmost scope, which must be a temporary scope.\n          */\n \n-        debug!(\"schedule_clean_in_ast_scope(cleanup_scope={:?})\",\n+        debug!(\"schedule_clean_in_ast_scope(cleanup_scope={})\",\n                cleanup_scope);\n \n         for scope in self.scopes.borrow_mut().iter_mut().rev() {\n@@ -598,7 +617,7 @@ impl<'blk, 'tcx> CleanupHelperMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx\n          * perform all cleanups and finally branch to the `break_blk`.\n          */\n \n-        debug!(\"trans_cleanups_to_exit_scope label={:?} scopes={}\",\n+        debug!(\"trans_cleanups_to_exit_scope label={} scopes={}\",\n                label, self.scopes_len());\n \n         let orig_scopes_len = self.scopes_len();\n@@ -634,7 +653,7 @@ impl<'blk, 'tcx> CleanupHelperMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx\n \n                     LoopExit(id, _) => {\n                         self.ccx.sess().bug(format!(\n-                                \"cannot exit from scope {:?}, \\\n+                                \"cannot exit from scope {}, \\\n                                 not in scope\", id).as_slice());\n                     }\n                 }\n@@ -968,6 +987,7 @@ impl Cleanup for DropValue {\n     }\n }\n \n+#[deriving(Show)]\n pub enum Heap {\n     HeapExchange\n }\n@@ -1072,7 +1092,7 @@ pub fn temporary_scope(tcx: &ty::ctxt,\n     match tcx.region_maps.temporary_scope(id) {\n         Some(scope) => {\n             let r = AstScope(scope);\n-            debug!(\"temporary_scope({}) = {:?}\", id, r);\n+            debug!(\"temporary_scope({}) = {}\", id, r);\n             r\n         }\n         None => {\n@@ -1086,7 +1106,7 @@ pub fn var_scope(tcx: &ty::ctxt,\n                  id: ast::NodeId)\n                  -> ScopeId {\n     let r = AstScope(tcx.region_maps.var_scope(id));\n-    debug!(\"var_scope({}) = {:?}\", id, r);\n+    debug!(\"var_scope({}) = {}\", id, r);\n     r\n }\n "}, {"sha": "8f877f981c8d920f19866ea16f88dde23ab9890e", "filename": "src/librustc/middle/trans/closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -550,7 +550,7 @@ pub fn get_wrapper_for_bare_fn(ccx: &CrateContext,\n         _ => {\n             ccx.sess().bug(format!(\"get_wrapper_for_bare_fn: \\\n                                     expected a statically resolved fn, got \\\n-                                    {:?}\",\n+                                    {}\",\n                                     def).as_slice());\n         }\n     };"}, {"sha": "a681a750f0b439b86562551d32eb387043884d80", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -130,7 +130,6 @@ pub struct tydesc_info {\n     pub size: ValueRef,\n     pub align: ValueRef,\n     pub name: ValueRef,\n-    pub visit_glue: Cell<Option<ValueRef>>,\n }\n \n /*\n@@ -468,7 +467,7 @@ impl<'blk, 'tcx> BlockS<'blk, 'tcx> {\n             Some(v) => v.clone(),\n             None => {\n                 self.tcx().sess.bug(format!(\n-                    \"no def associated with node id {:?}\", nid).as_slice());\n+                    \"no def associated with node id {}\", nid).as_slice());\n             }\n         }\n     }\n@@ -704,7 +703,7 @@ pub fn const_get_elt(cx: &CrateContext, v: ValueRef, us: &[c_uint])\n     unsafe {\n         let r = llvm::LLVMConstExtractValue(v, us.as_ptr(), us.len() as c_uint);\n \n-        debug!(\"const_get_elt(v={}, us={:?}, r={})\",\n+        debug!(\"const_get_elt(v={}, us={}, r={})\",\n                cx.tn().val_to_string(v), us, cx.tn().val_to_string(r));\n \n         return r;\n@@ -865,7 +864,7 @@ pub fn fulfill_obligation(ccx: &CrateContext,\n }\n \n // Key used to lookup values supplied for type parameters in an expr.\n-#[deriving(PartialEq)]\n+#[deriving(PartialEq, Show)]\n pub enum ExprOrMethodCall {\n     // Type parameters for a path like `None::<int>`\n     ExprId(ast::NodeId),\n@@ -891,7 +890,7 @@ pub fn node_id_substs(bcx: Block,\n \n     if substs.types.any(|t| ty::type_needs_infer(*t)) {\n         bcx.sess().bug(\n-            format!(\"type parameters for node {:?} include inference types: \\\n+            format!(\"type parameters for node {} include inference types: \\\n                      {}\",\n                     node,\n                     substs.repr(bcx.tcx())).as_slice());"}, {"sha": "d83c46be14ab8aa8820498dd94e14d7f0ea3e6e0", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -210,7 +210,7 @@ pub fn const_expr(cx: &CrateContext, e: &ast::Expr) -> (ValueRef, ty::t) {\n                 ty::AdjustAddEnv(store) => {\n                     cx.sess()\n                       .span_bug(e.span,\n-                                format!(\"unexpected static function: {:?}\",\n+                                format!(\"unexpected static function: {}\",\n                                         store).as_slice())\n                 }\n                 ty::AdjustDerefRef(ref adj) => {\n@@ -279,7 +279,7 @@ pub fn const_expr(cx: &CrateContext, e: &ast::Expr) -> (ValueRef, ty::t) {\n                                     cx.sess()\n                                       .span_bug(e.span,\n                                                 format!(\"unimplemented const \\\n-                                                         autoref {:?}\",\n+                                                         autoref {}\",\n                                                         autoref).as_slice())\n                                 }\n                             }"}, {"sha": "67ae93e25c6dab94ce055c0add911fc0821d88e3", "filename": "src/librustc/middle/trans/context.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -72,7 +72,6 @@ pub struct SharedCrateContext<'tcx> {\n \n     available_monomorphizations: RefCell<HashSet<String>>,\n     available_drop_glues: RefCell<HashMap<ty::t, String>>,\n-    available_visit_glues: RefCell<HashMap<ty::t, String>>,\n }\n \n /// The local portion of a `CrateContext`.  There is one `LocalCrateContext`\n@@ -275,7 +274,6 @@ impl<'tcx> SharedCrateContext<'tcx> {\n             },\n             available_monomorphizations: RefCell::new(HashSet::new()),\n             available_drop_glues: RefCell::new(HashMap::new()),\n-            available_visit_glues: RefCell::new(HashMap::new()),\n         };\n \n         for i in range(0, local_count) {\n@@ -682,10 +680,6 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         &self.shared.available_drop_glues\n     }\n \n-    pub fn available_visit_glues<'a>(&'a self) -> &'a RefCell<HashMap<ty::t, String>> {\n-        &self.shared.available_visit_glues\n-    }\n-\n     pub fn int_type(&self) -> Type {\n         self.local.int_type\n     }"}, {"sha": "fe9f832e44a186914fe862326174e39bb2544570", "filename": "src/librustc/middle/trans/controlflow.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -138,7 +138,7 @@ pub fn trans_if<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                             els: Option<&ast::Expr>,\n                             dest: expr::Dest)\n                             -> Block<'blk, 'tcx> {\n-    debug!(\"trans_if(bcx={}, if_id={}, cond={}, thn={:?}, dest={})\",\n+    debug!(\"trans_if(bcx={}, if_id={}, cond={}, thn={}, dest={})\",\n            bcx.to_str(), if_id, bcx.expr_to_string(cond), thn.id,\n            dest.to_string(bcx.ccx()));\n     let _icx = push_ctxt(\"trans_if\");\n@@ -429,7 +429,7 @@ pub fn trans_break_cont<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             match bcx.tcx().def_map.borrow().find(&expr_id) {\n                 Some(&def::DefLabel(loop_id)) => loop_id,\n                 ref r => {\n-                    bcx.tcx().sess.bug(format!(\"{:?} in def-map for label\",\n+                    bcx.tcx().sess.bug(format!(\"{} in def-map for label\",\n                                                r).as_slice())\n                 }\n             }"}, {"sha": "ea6d9e1dd8c48a61a93ae7618934948e66aa5cd9", "filename": "src/librustc/middle/trans/datum.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -25,6 +25,7 @@ use middle::trans::type_of;\n use middle::ty;\n use util::ppaux::{ty_to_string};\n \n+use std::fmt;\n use syntax::ast;\n \n /**\n@@ -51,6 +52,7 @@ pub struct DatumBlock<'blk, 'tcx: 'blk, K> {\n     pub datum: Datum<K>,\n }\n \n+#[deriving(Show)]\n pub enum Expr {\n     /// a fresh value that was produced and which has no cleanup yet\n     /// because it has not yet \"landed\" into its permanent home\n@@ -62,9 +64,10 @@ pub enum Expr {\n     LvalueExpr,\n }\n \n-#[deriving(Clone)]\n+#[deriving(Clone, Show)]\n pub struct Lvalue;\n \n+#[deriving(Show)]\n pub struct Rvalue {\n     pub mode: RvalueMode\n }\n@@ -80,7 +83,7 @@ impl Drop for Rvalue {\n     fn drop(&mut self) { }\n }\n \n-#[deriving(PartialEq, Eq, Hash)]\n+#[deriving(PartialEq, Eq, Hash, Show)]\n pub enum RvalueMode {\n     /// `val` is a pointer to the actual value (and thus has type *T)\n     ByRef,\n@@ -539,7 +542,7 @@ impl Datum<Lvalue> {\n /**\n  * Generic methods applicable to any sort of datum.\n  */\n-impl<K:KindOps> Datum<K> {\n+impl<K: KindOps + fmt::Show> Datum<K> {\n     pub fn new(val: ValueRef, ty: ty::t, kind: K) -> Datum<K> {\n         Datum { val: val, ty: ty, kind: kind }\n     }\n@@ -615,7 +618,7 @@ impl<K:KindOps> Datum<K> {\n \n     #[allow(dead_code)] // useful for debugging\n     pub fn to_string(&self, ccx: &CrateContext) -> String {\n-        format!(\"Datum({}, {}, {:?})\",\n+        format!(\"Datum({}, {}, {})\",\n                 ccx.tn().val_to_string(self.val),\n                 ty_to_string(ccx.tcx(), self.ty),\n                 self.kind)\n@@ -658,7 +661,7 @@ impl<'blk, 'tcx, K> DatumBlock<'blk, 'tcx, K> {\n     }\n }\n \n-impl<'blk, 'tcx, K:KindOps> DatumBlock<'blk, 'tcx, K> {\n+impl<'blk, 'tcx, K: KindOps + fmt::Show> DatumBlock<'blk, 'tcx, K> {\n     pub fn to_expr_datumblock(self) -> DatumBlock<'blk, 'tcx, Expr> {\n         DatumBlock::new(self.bcx, self.datum.to_expr_datum())\n     }"}, {"sha": "4e3eaf26f42e8993bfb163cc5ded32cb70cc02c8", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -468,7 +468,7 @@ impl TypeMap {\n                                                         &mut unique_type_id);\n             },\n             _ => {\n-                cx.sess().bug(format!(\"get_unique_type_id_of_type() - unexpected type: {}, {:?}\",\n+                cx.sess().bug(format!(\"get_unique_type_id_of_type() - unexpected type: {}, {}\",\n                                       ppaux::ty_to_string(cx.tcx(), type_).as_slice(),\n                                       ty::get(type_).sty).as_slice())\n             }\n@@ -783,14 +783,14 @@ pub fn create_global_var_metadata(cx: &CrateContext,\n                                 format!(\"debuginfo::\\\n                                          create_global_var_metadata() -\n                                          Captured var-id refers to \\\n-                                         unexpected ast_item variant: {:?}\",\n+                                         unexpected ast_item variant: {}\",\n                                         var_item).as_slice())\n                 }\n             }\n         },\n         _ => cx.sess().bug(format!(\"debuginfo::create_global_var_metadata() \\\n                                     - Captured var-id refers to unexpected \\\n-                                    ast_map variant: {:?}\",\n+                                    ast_map variant: {}\",\n                                    var_item).as_slice())\n     };\n \n@@ -846,7 +846,7 @@ pub fn create_local_var_metadata(bcx: Block, local: &ast::Local) {\n             Some(datum) => datum,\n             None => {\n                 bcx.sess().span_bug(span,\n-                    format!(\"no entry in lllocals table for {:?}\",\n+                    format!(\"no entry in lllocals table for {}\",\n                             node_id).as_slice());\n             }\n         };\n@@ -896,7 +896,7 @@ pub fn create_captured_var_metadata(bcx: Block,\n                                 format!(\n                                 \"debuginfo::create_captured_var_metadata() - \\\n                                  Captured var-id refers to unexpected \\\n-                                 ast_map variant: {:?}\",\n+                                 ast_map variant: {}\",\n                                  ast_item).as_slice());\n                 }\n             }\n@@ -906,7 +906,7 @@ pub fn create_captured_var_metadata(bcx: Block,\n               .span_bug(span,\n                         format!(\"debuginfo::create_captured_var_metadata() - \\\n                                  Captured var-id refers to unexpected \\\n-                                 ast_map variant: {:?}\",\n+                                 ast_map variant: {}\",\n                                 ast_item).as_slice());\n         }\n     };\n@@ -1009,7 +1009,7 @@ pub fn create_argument_metadata(bcx: Block, arg: &ast::Arg) {\n             Some(v) => v,\n             None => {\n                 bcx.sess().span_bug(span,\n-                    format!(\"no entry in lllocals table for {:?}\",\n+                    format!(\"no entry in lllocals table for {}\",\n                             node_id).as_slice());\n             }\n         };\n@@ -1250,7 +1250,7 @@ pub fn create_function_debug_context(cx: &CrateContext,\n                 _ => {\n                     cx.sess()\n                       .bug(format!(\"create_function_debug_context: \\\n-                                    unexpected sort of node: {:?}\",\n+                                    unexpected sort of node: {}\",\n                                     fnitem).as_slice())\n                 }\n             }\n@@ -1261,7 +1261,7 @@ pub fn create_function_debug_context(cx: &CrateContext,\n             return FunctionDebugContext { repr: FunctionWithoutDebugInfo };\n         }\n         _ => cx.sess().bug(format!(\"create_function_debug_context: \\\n-                                    unexpected sort of node: {:?}\",\n+                                    unexpected sort of node: {}\",\n                                    fnitem).as_slice())\n     };\n \n@@ -1542,7 +1542,7 @@ fn compile_unit_metadata(cx: &CrateContext) {\n         }\n     };\n \n-    debug!(\"compile_unit_metadata: {:?}\", compile_unit_name);\n+    debug!(\"compile_unit_metadata: {}\", compile_unit_name);\n     let producer = format!(\"rustc version {}\",\n                            (option_env!(\"CFG_VERSION\")).expect(\"CFG_VERSION\"));\n \n@@ -1703,15 +1703,15 @@ fn scope_metadata(fcx: &FunctionContext,\n             let node = fcx.ccx.tcx().map.get(node_id);\n \n             fcx.ccx.sess().span_bug(error_reporting_span,\n-                format!(\"debuginfo: Could not find scope info for node {:?}\",\n+                format!(\"debuginfo: Could not find scope info for node {}\",\n                         node).as_slice());\n         }\n     }\n }\n \n fn basic_type_metadata(cx: &CrateContext, t: ty::t) -> DIType {\n \n-    debug!(\"basic_type_metadata: {:?}\", ty::get(t));\n+    debug!(\"basic_type_metadata: {}\", ty::get(t));\n \n     let (name, encoding) = match ty::get(t).sty {\n         ty::ty_nil => (\"()\".to_string(), DW_ATE_unsigned),\n@@ -2855,7 +2855,7 @@ fn type_metadata(cx: &CrateContext,\n         }\n     };\n \n-    debug!(\"type_metadata: {:?}\", ty::get(t));\n+    debug!(\"type_metadata: {}\", ty::get(t));\n \n     let sty = &ty::get(t).sty;\n     let MetadataCreationResult { metadata, already_stored_in_typemap } = match *sty {\n@@ -2937,7 +2937,7 @@ fn type_metadata(cx: &CrateContext,\n                                    usage_site_span).finalize(cx)\n         }\n         _ => {\n-            cx.sess().bug(format!(\"debuginfo: unexpected type in type_metadata: {:?}\",\n+            cx.sess().bug(format!(\"debuginfo: unexpected type in type_metadata: {}\",\n                                   sty).as_slice())\n         }\n     };\n@@ -3991,7 +3991,7 @@ fn namespace_for_item(cx: &CrateContext, def_id: ast::DefId) -> Rc<NamespaceTree\n             Some(node) => node,\n             None => {\n                 cx.sess().bug(format!(\"debuginfo::namespace_for_item(): \\\n-                                       path too short for {:?}\",\n+                                       path too short for {}\",\n                                       def_id).as_slice());\n             }\n         }"}, {"sha": "bcbc9fff834da2eb5dabe4401da8b843faea295e", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -666,7 +666,7 @@ fn trans_datum_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             bcx.tcx().sess.span_bug(\n                 expr.span,\n                 format!(\"trans_rvalue_datum_unadjusted reached \\\n-                         fall-through case: {:?}\",\n+                         fall-through case: {}\",\n                         expr.node).as_slice());\n         }\n     }\n@@ -982,7 +982,7 @@ fn trans_rvalue_stmt_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             bcx.tcx().sess.span_bug(\n                 expr.span,\n                 format!(\"trans_rvalue_stmt_unadjusted reached \\\n-                         fall-through case: {:?}\",\n+                         fall-through case: {}\",\n                         expr.node).as_slice());\n         }\n     }\n@@ -1128,7 +1128,7 @@ fn trans_rvalue_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             bcx.tcx().sess.span_bug(\n                 expr.span,\n                 format!(\"trans_rvalue_dps_unadjusted reached fall-through \\\n-                         case: {:?}\",\n+                         case: {}\",\n                         expr.node).as_slice());\n         }\n     }\n@@ -1176,7 +1176,7 @@ fn trans_def_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         }\n         _ => {\n             bcx.tcx().sess.span_bug(ref_expr.span, format!(\n-                \"Non-DPS def {:?} referened by {}\",\n+                \"Non-DPS def {} referened by {}\",\n                 def, bcx.node_id_to_string(ref_expr.id)).as_slice());\n         }\n     }\n@@ -1200,7 +1200,7 @@ fn trans_def_fn_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         }\n         _ => {\n             bcx.tcx().sess.span_bug(ref_expr.span, format!(\n-                    \"trans_def_fn_unadjusted invoked on: {:?} for {}\",\n+                    \"trans_def_fn_unadjusted invoked on: {} for {}\",\n                     def,\n                     ref_expr.repr(bcx.tcx())).as_slice());\n         }\n@@ -1228,7 +1228,7 @@ pub fn trans_local_var<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 Some(&val) => Datum::new(val, local_ty, Lvalue),\n                 None => {\n                     bcx.sess().bug(format!(\n-                        \"trans_local_var: no llval for upvar {:?} found\",\n+                        \"trans_local_var: no llval for upvar {} found\",\n                         nid).as_slice());\n                 }\n             }\n@@ -1238,17 +1238,17 @@ pub fn trans_local_var<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 Some(&v) => v,\n                 None => {\n                     bcx.sess().bug(format!(\n-                        \"trans_local_var: no datum for local/arg {:?} found\",\n+                        \"trans_local_var: no datum for local/arg {} found\",\n                         nid).as_slice());\n                 }\n             };\n-            debug!(\"take_local(nid={:?}, v={}, ty={})\",\n+            debug!(\"take_local(nid={}, v={}, ty={})\",\n                    nid, bcx.val_to_string(datum.val), bcx.ty_to_string(datum.ty));\n             datum\n         }\n         _ => {\n             bcx.sess().unimpl(format!(\n-                \"unsupported def type in trans_local_var: {:?}\",\n+                \"unsupported def type in trans_local_var: {}\",\n                 def).as_slice());\n         }\n     }\n@@ -1869,7 +1869,7 @@ fn float_cast(bcx: Block,\n     } else { llsrc };\n }\n \n-#[deriving(PartialEq)]\n+#[deriving(PartialEq, Show)]\n pub enum cast_kind {\n     cast_pointer,\n     cast_integral,\n@@ -1981,7 +1981,7 @@ fn trans_imm_cast<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 cast_float => SIToFP(bcx, lldiscrim_a, ll_t_out),\n                 _ => {\n                     ccx.sess().bug(format!(\"translating unsupported cast: \\\n-                                            {} ({:?}) -> {} ({:?})\",\n+                                            {} ({}) -> {} ({})\",\n                                             t_in.repr(bcx.tcx()),\n                                             k_in,\n                                             t_out.repr(bcx.tcx()),\n@@ -1990,7 +1990,7 @@ fn trans_imm_cast<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             }\n         }\n         _ => ccx.sess().bug(format!(\"translating unsupported cast: \\\n-                                    {} ({:?}) -> {} ({:?})\",\n+                                    {} ({}) -> {} ({})\",\n                                     t_in.repr(bcx.tcx()),\n                                     k_in,\n                                     t_out.repr(bcx.tcx()),"}, {"sha": "cc28b8032087f004b09e0c54d6019a9265add49d", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -474,7 +474,7 @@ pub fn trans_native_call<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             let llforeign_align = machine::llalign_of_min(ccx, llforeign_ret_ty);\n             let llrust_align = machine::llalign_of_min(ccx, llrust_ret_ty);\n             let llalign = cmp::min(llforeign_align, llrust_align);\n-            debug!(\"llrust_size={:?}\", llrust_size);\n+            debug!(\"llrust_size={}\", llrust_size);\n             base::call_memcpy(bcx, llretptr_i8, llscratch_i8,\n                               C_uint(ccx, llrust_size as uint), llalign as u32);\n         }\n@@ -576,7 +576,7 @@ pub fn register_rust_fn_with_foreign_abi(ccx: &CrateContext,\n     };\n     let llfn = base::register_fn_llvmty(ccx, sp, sym, node_id, cconv, llfn_ty);\n     add_argument_attributes(&tys, llfn);\n-    debug!(\"register_rust_fn_with_foreign_abi(node_id={:?}, llfn_ty={}, llfn={})\",\n+    debug!(\"register_rust_fn_with_foreign_abi(node_id={}, llfn_ty={}, llfn={})\",\n            node_id, ccx.tn().type_to_string(llfn_ty), ccx.tn().val_to_string(llfn));\n     llfn\n }"}, {"sha": "f0b0d9d33e53ef4b99b313ccd58bd9ef032e511f", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 0, "deletions": 84, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -31,7 +31,6 @@ use middle::trans::datum;\n use middle::trans::debuginfo;\n use middle::trans::expr;\n use middle::trans::machine::*;\n-use middle::trans::reflect;\n use middle::trans::tvec;\n use middle::trans::type_::Type;\n use middle::trans::type_of::{type_of, sizing_type_of, align_of};\n@@ -41,7 +40,6 @@ use util::ppaux;\n \n use arena::TypedArena;\n use std::c_str::ToCStr;\n-use std::cell::Cell;\n use libc::c_uint;\n use syntax::ast;\n use syntax::parse::token;\n@@ -186,71 +184,6 @@ pub fn get_drop_glue(ccx: &CrateContext, t: ty::t) -> ValueRef {\n     glue\n }\n \n-pub fn lazily_emit_visit_glue(ccx: &CrateContext, ti: &tydesc_info) -> ValueRef {\n-    let _icx = push_ctxt(\"lazily_emit_visit_glue\");\n-\n-    let llfnty = Type::glue_fn(ccx, type_of(ccx, ti.ty).ptr_to());\n-\n-    match ti.visit_glue.get() {\n-        Some(visit_glue) => visit_glue,\n-        None => {\n-            debug!(\"+++ lazily_emit_tydesc_glue VISIT {}\", ppaux::ty_to_string(ccx.tcx(), ti.ty));\n-\n-            let (glue_fn, new_sym) = match ccx.available_visit_glues().borrow().find(&ti.ty) {\n-                Some(old_sym) => {\n-                    let glue_fn = decl_cdecl_fn(ccx, old_sym.as_slice(), llfnty, ty::mk_nil());\n-                    (glue_fn, None)\n-                },\n-                None => {\n-                    let (sym, glue_fn) = declare_generic_glue(ccx, ti.ty, llfnty, \"visit\");\n-                    (glue_fn, Some(sym))\n-                },\n-            };\n-\n-            ti.visit_glue.set(Some(glue_fn));\n-\n-            match new_sym {\n-                Some(sym) => {\n-                    ccx.available_visit_glues().borrow_mut().insert(ti.ty, sym);\n-                    make_generic_glue(ccx, ti.ty, glue_fn, make_visit_glue, \"visit\");\n-                },\n-                None => {},\n-            }\n-\n-            debug!(\"--- lazily_emit_tydesc_glue VISIT {}\", ppaux::ty_to_string(ccx.tcx(), ti.ty));\n-            glue_fn\n-        }\n-    }\n-}\n-\n-// See [Note-arg-mode]\n-pub fn call_visit_glue(bcx: Block, v: ValueRef, tydesc: ValueRef) {\n-    let _icx = push_ctxt(\"call_visit_glue\");\n-\n-    // Select the glue function to call from the tydesc\n-    let llfn = Load(bcx, GEPi(bcx, tydesc, [0u, abi::tydesc_field_visit_glue]));\n-    let llrawptr = PointerCast(bcx, v, Type::i8p(bcx.ccx()));\n-\n-    Call(bcx, llfn, [llrawptr], None);\n-}\n-\n-fn make_visit_glue<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, v: ValueRef, t: ty::t)\n-                               -> Block<'blk, 'tcx> {\n-    let _icx = push_ctxt(\"make_visit_glue\");\n-    let mut bcx = bcx;\n-    let (visitor_trait, object_ty) = match ty::visitor_object_ty(bcx.tcx(),\n-                                                                 ty::ReStatic,\n-                                                                 ty::ReStatic) {\n-        Ok(pair) => pair,\n-        Err(s) => {\n-            bcx.tcx().sess.fatal(s.as_slice());\n-        }\n-    };\n-    let v = PointerCast(bcx, v, type_of(bcx.ccx(), object_ty).ptr_to());\n-    bcx = reflect::emit_calls_to_trait_visit_ty(bcx, t, v, visitor_trait.def_id);\n-    bcx\n-}\n-\n fn trans_struct_drop_flag<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                                       t: ty::t,\n                                       v0: ValueRef,\n@@ -577,7 +510,6 @@ pub fn declare_tydesc(ccx: &CrateContext, t: ty::t) -> tydesc_info {\n         size: llsize,\n         align: llalign,\n         name: ty_name,\n-        visit_glue: Cell::new(None),\n     }\n }\n \n@@ -643,27 +575,11 @@ pub fn emit_tydescs(ccx: &CrateContext) {\n             llvm::LLVMConstPointerCast(get_drop_glue(ccx, ti.ty), glue_fn_ty.to_ref())\n         };\n         ccx.stats().n_real_glues.set(ccx.stats().n_real_glues.get() + 1);\n-        let visit_glue =\n-            match ti.visit_glue.get() {\n-              None => {\n-                  ccx.stats().n_null_glues.set(ccx.stats().n_null_glues.get() +\n-                                             1u);\n-                  C_null(glue_fn_ty)\n-              }\n-              Some(v) => {\n-                unsafe {\n-                    ccx.stats().n_real_glues.set(ccx.stats().n_real_glues.get() +\n-                                               1);\n-                    llvm::LLVMConstPointerCast(v, glue_fn_ty.to_ref())\n-                }\n-              }\n-            };\n \n         let tydesc = C_named_struct(ccx.tydesc_type(),\n                                     [ti.size, // size\n                                      ti.align, // align\n                                      drop_glue, // drop_glue\n-                                     visit_glue, // visit_glue\n                                      ti.name]); // name\n \n         unsafe {"}, {"sha": "cf47bbd2a526ec91c4a6d45cf49fec173808161f", "filename": "src/librustc/middle/trans/intrinsic.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -269,7 +269,6 @@ pub fn trans_intrinsic_call<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>, node: ast::N\n         (_, \"get_tydesc\") => {\n             let tp_ty = *substs.types.get(FnSpace, 0);\n             let static_ti = get_tydesc(ccx, tp_ty);\n-            glue::lazily_emit_visit_glue(ccx, &*static_ti);\n \n             // FIXME (#3730): ideally this shouldn't need a cast,\n             // but there's a circularity between translating rust types to llvm\n@@ -307,13 +306,6 @@ pub fn trans_intrinsic_call<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>, node: ast::N\n             let tp_ty = *substs.types.get(FnSpace, 0);\n             C_bool(ccx, ty::type_contents(ccx.tcx(), tp_ty).owns_managed())\n         }\n-        (_, \"visit_tydesc\") => {\n-            let td = *llargs.get(0);\n-            let visitor = *llargs.get(1);\n-            let td = PointerCast(bcx, td, ccx.tydesc_type().ptr_to());\n-            glue::call_visit_glue(bcx, visitor, td);\n-            C_nil(ccx)\n-        }\n         (_, \"offset\") => {\n             let ptr = *llargs.get(0);\n             let offset = *llargs.get(1);"}, {"sha": "0b3f1c9840c4ad2b193eda0a01f5ac78cb284b1a", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -60,7 +60,7 @@ pub fn trans_impl(ccx: &CrateContext,\n     let _icx = push_ctxt(\"meth::trans_impl\");\n     let tcx = ccx.tcx();\n \n-    debug!(\"trans_impl(name={}, id={:?})\", name.repr(tcx), id);\n+    debug!(\"trans_impl(name={}, id={})\", name.repr(tcx), id);\n \n     // Both here and below with generic methods, be sure to recurse and look for\n     // items that we need to translate.\n@@ -174,8 +174,8 @@ pub fn trans_static_method_callee(bcx: Block,\n     let _icx = push_ctxt(\"meth::trans_static_method_callee\");\n     let ccx = bcx.ccx();\n \n-    debug!(\"trans_static_method_callee(method_id={:?}, trait_id={}, \\\n-            expr_id={:?})\",\n+    debug!(\"trans_static_method_callee(method_id={}, trait_id={}, \\\n+            expr_id={})\",\n            method_id,\n            ty::item_path_str(bcx.tcx(), trait_id),\n            expr_id);"}, {"sha": "fe7697447acda8a897a3f7af36cc0e92c80672df", "filename": "src/librustc/middle/trans/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmod.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -36,7 +36,6 @@ pub mod cabi_arm;\n pub mod cabi_mips;\n pub mod foreign;\n pub mod intrinsic;\n-pub mod reflect;\n pub mod debuginfo;\n pub mod machine;\n pub mod adt;"}, {"sha": "258d12e631f2fb1a8f741b4d86c56df542476bb9", "filename": "src/librustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -38,7 +38,7 @@ pub fn monomorphic_fn(ccx: &CrateContext,\n     debug!(\"monomorphic_fn(\\\n             fn_id={}, \\\n             real_substs={}, \\\n-            ref_id={:?})\",\n+            ref_id={})\",\n            fn_id.repr(ccx.tcx()),\n            real_substs.repr(ccx.tcx()),\n            ref_id);\n@@ -70,7 +70,7 @@ pub fn monomorphic_fn(ccx: &CrateContext,\n     debug!(\"monomorphic_fn(\\\n             fn_id={}, \\\n             psubsts={}, \\\n-            hash_id={:?})\",\n+            hash_id={})\",\n            fn_id.repr(ccx.tcx()),\n            psubsts.repr(ccx.tcx()),\n            hash_id);\n@@ -82,7 +82,7 @@ pub fn monomorphic_fn(ccx: &CrateContext,\n         ccx.sess(),\n         ccx.tcx().map.find(fn_id.node),\n         || {\n-            format!(\"while monomorphizing {:?}, couldn't find it in \\\n+            format!(\"while monomorphizing {}, couldn't find it in \\\n                      the item map (may have attempted to monomorphize \\\n                      an item defined in a different crate?)\",\n                     fn_id)\n@@ -247,7 +247,7 @@ pub fn monomorphic_fn(ccx: &CrateContext,\n                     d\n                 }\n                 _ => {\n-                    ccx.sess().bug(format!(\"can't monomorphize a {:?}\",\n+                    ccx.sess().bug(format!(\"can't monomorphize a {}\",\n                                            map_node).as_slice())\n                 }\n             }\n@@ -273,7 +273,7 @@ pub fn monomorphic_fn(ccx: &CrateContext,\n         ast_map::NodeBlock(..) |\n         ast_map::NodePat(..) |\n         ast_map::NodeLocal(..) => {\n-            ccx.sess().bug(format!(\"can't monomorphize a {:?}\",\n+            ccx.sess().bug(format!(\"can't monomorphize a {}\",\n                                    map_node).as_slice())\n         }\n     };\n@@ -284,7 +284,7 @@ pub fn monomorphic_fn(ccx: &CrateContext,\n     (lldecl, true)\n }\n \n-#[deriving(PartialEq, Eq, Hash)]\n+#[deriving(PartialEq, Eq, Hash, Show)]\n pub struct MonoId {\n     pub def: ast::DefId,\n     pub params: subst::VecPerParamSpace<ty::t>"}, {"sha": "ebdd2eb6354b11ce75d434c95e7c536dce4c2a80", "filename": "src/librustc/middle/trans/reflect.rs", "status": "removed", "additions": 0, "deletions": 460, "changes": 460, "blob_url": "https://github.com/rust-lang/rust/blob/b6e0d3a5bf4c88650a22f605f822e02c6b163580/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6e0d3a5bf4c88650a22f605f822e02c6b163580/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=b6e0d3a5bf4c88650a22f605f822e02c6b163580", "patch": "@@ -1,460 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use back::link::mangle_internal_name_by_path_and_seq;\n-use llvm::{ValueRef, get_param};\n-use middle::trans::adt;\n-use middle::trans::base::*;\n-use middle::trans::build::*;\n-use middle::trans::callee::ArgVals;\n-use middle::trans::callee;\n-use middle::trans::common::*;\n-use middle::trans::datum::*;\n-use middle::trans::glue;\n-use middle::trans::machine;\n-use middle::trans::meth;\n-use middle::trans::type_::Type;\n-use middle::trans::type_of::*;\n-use middle::ty;\n-use util::ppaux::ty_to_string;\n-\n-use arena::TypedArena;\n-use libc::c_uint;\n-use syntax::ast::DefId;\n-use syntax::ast;\n-use syntax::ast_map;\n-use syntax::parse::token::{InternedString, special_idents};\n-use syntax::parse::token;\n-\n-pub struct Reflector<'a, 'blk, 'tcx: 'blk> {\n-    visitor_val: ValueRef,\n-    visitor_items: &'a [ty::ImplOrTraitItem],\n-    final_bcx: Block<'blk, 'tcx>,\n-    tydesc_ty: Type,\n-    bcx: Block<'blk, 'tcx>\n-}\n-\n-impl<'a, 'blk, 'tcx> Reflector<'a, 'blk, 'tcx> {\n-    pub fn c_uint(&mut self, u: uint) -> ValueRef {\n-        C_uint(self.bcx.ccx(), u)\n-    }\n-\n-    pub fn c_bool(&mut self, b: bool) -> ValueRef {\n-        C_bool(self.bcx.ccx(), b)\n-    }\n-\n-    pub fn c_slice(&mut self, s: InternedString) -> ValueRef {\n-        // We're careful to not use first class aggregates here because that\n-        // will kick us off fast isel. (Issue #4352.)\n-        let bcx = self.bcx;\n-        let str_ty = ty::mk_str_slice(bcx.tcx(), ty::ReStatic, ast::MutImmutable);\n-        let scratch = rvalue_scratch_datum(bcx, str_ty, \"\");\n-        let len = C_uint(bcx.ccx(), s.get().len());\n-        let c_str = PointerCast(bcx, C_cstr(bcx.ccx(), s, false), Type::i8p(bcx.ccx()));\n-        Store(bcx, c_str, GEPi(bcx, scratch.val, [ 0, 0 ]));\n-        Store(bcx, len, GEPi(bcx, scratch.val, [ 0, 1 ]));\n-        scratch.val\n-    }\n-\n-    pub fn c_size_and_align(&mut self, t: ty::t) -> Vec<ValueRef> {\n-        let tr = type_of(self.bcx.ccx(), t);\n-        let s = machine::llsize_of_real(self.bcx.ccx(), tr);\n-        let a = align_of(self.bcx.ccx(), t);\n-        return vec!(self.c_uint(s as uint),\n-             self.c_uint(a as uint));\n-    }\n-\n-    pub fn c_tydesc(&mut self, t: ty::t) -> ValueRef {\n-        let bcx = self.bcx;\n-        let static_ti = get_tydesc(bcx.ccx(), t);\n-        glue::lazily_emit_visit_glue(bcx.ccx(), &*static_ti);\n-        PointerCast(bcx, static_ti.tydesc, self.tydesc_ty.ptr_to())\n-    }\n-\n-    pub fn c_mt(&mut self, mt: &ty::mt) -> Vec<ValueRef> {\n-        vec!(self.c_uint(mt.mutbl as uint),\n-          self.c_tydesc(mt.ty))\n-    }\n-\n-    pub fn visit(&mut self, ty_name: &str, args: &[ValueRef]) {\n-        let fcx = self.bcx.fcx;\n-        let tcx = self.bcx.tcx();\n-        let mth_idx = ty::impl_or_trait_item_idx(token::str_to_ident(format!(\n-                        \"visit_{}\", ty_name).as_slice()),\n-                                     self.visitor_items.as_slice()).expect(\n-                format!(\"couldn't find visit method for {}\", ty_name).as_slice());\n-        let method = match self.visitor_items[mth_idx] {\n-            ty::MethodTraitItem(ref method) => (*method).clone(),\n-            ty::TypeTraitItem(_) => return,\n-        };\n-        let mth_ty = ty::mk_bare_fn(tcx, method.fty.clone());\n-        debug!(\"Emit call visit method: visit_{}: {}\", ty_name, ty_to_string(tcx, mth_ty));\n-        let v = self.visitor_val;\n-        debug!(\"passing {} args:\", args.len());\n-        let mut bcx = self.bcx;\n-        for (i, a) in args.iter().enumerate() {\n-            debug!(\"arg {}: {}\", i, bcx.val_to_string(*a));\n-        }\n-        let result = unpack_result!(bcx, callee::trans_call_inner(\n-            self.bcx, None, mth_ty,\n-            |bcx, _| meth::trans_trait_callee_from_llval(bcx,\n-                                                         mth_ty,\n-                                                         mth_idx,\n-                                                         v),\n-            ArgVals(args), None));\n-        let next_bcx = fcx.new_temp_block(\"next\");\n-        CondBr(bcx, result, next_bcx.llbb, self.final_bcx.llbb);\n-        self.bcx = next_bcx\n-    }\n-\n-    pub fn bracketed(&mut self,\n-                     bracket_name: &str,\n-                     extra: &[ValueRef],\n-                     inner: |&mut Reflector|) {\n-        self.visit(format!(\"enter_{}\", bracket_name).as_slice(), extra);\n-        inner(self);\n-        self.visit(format!(\"leave_{}\", bracket_name).as_slice(), extra);\n-    }\n-\n-    pub fn leaf(&mut self, name: &str) {\n-        self.visit(name, []);\n-    }\n-\n-    fn visit_closure_ty(&mut self, fty: &ty::ClosureTy, is_unboxed: bool) {\n-        let pureval = ast_fn_style_constant(fty.fn_style);\n-        let sigilval = match fty.store {\n-            ty::UniqTraitStore => 2u,\n-            ty::RegionTraitStore(..) => 4u,\n-        };\n-        let retval = if ty::type_is_bot(fty.sig.output) {0u} else {1u};\n-        let extra = vec!(self.c_uint(pureval),\n-                         self.c_uint(sigilval),\n-                         self.c_uint(fty.sig.inputs.len()),\n-                         self.c_uint(retval));\n-        self.visit(\"enter_fn\", extra.as_slice());\n-        self.visit_sig(retval, &fty.sig, is_unboxed);\n-        self.visit(\"leave_fn\", extra.as_slice());\n-    }\n-\n-    // Entrypoint\n-    pub fn visit_ty(&mut self, t: ty::t) {\n-        let bcx = self.bcx;\n-        let tcx = bcx.tcx();\n-        debug!(\"reflect::visit_ty {}\", ty_to_string(bcx.tcx(), t));\n-\n-        match ty::get(t).sty {\n-          ty::ty_bot => self.leaf(\"bot\"),\n-          ty::ty_nil => self.leaf(\"nil\"),\n-          ty::ty_bool => self.leaf(\"bool\"),\n-          ty::ty_char => self.leaf(\"char\"),\n-          ty::ty_int(ast::TyI) => self.leaf(\"int\"),\n-          ty::ty_int(ast::TyI8) => self.leaf(\"i8\"),\n-          ty::ty_int(ast::TyI16) => self.leaf(\"i16\"),\n-          ty::ty_int(ast::TyI32) => self.leaf(\"i32\"),\n-          ty::ty_int(ast::TyI64) => self.leaf(\"i64\"),\n-          ty::ty_uint(ast::TyU) => self.leaf(\"uint\"),\n-          ty::ty_uint(ast::TyU8) => self.leaf(\"u8\"),\n-          ty::ty_uint(ast::TyU16) => self.leaf(\"u16\"),\n-          ty::ty_uint(ast::TyU32) => self.leaf(\"u32\"),\n-          ty::ty_uint(ast::TyU64) => self.leaf(\"u64\"),\n-          ty::ty_float(ast::TyF32) => self.leaf(\"f32\"),\n-          ty::ty_float(ast::TyF64) => self.leaf(\"f64\"),\n-\n-          ty::ty_open(_) | ty::ty_str | ty::ty_vec(_, None) | ty::ty_trait(..) => {\n-              // Unfortunately we can't do anything here because at runtime we\n-              // pass around the value by pointer (*u8). But unsized pointers are\n-              // fat and so we can't just cast them to *u8 and back. So we have\n-              // to work with the pointer directly (see ty_ptr/ty_rptr/ty_uniq).\n-              fail!(\"Can't reflect unsized type\")\n-          }\n-          // FIXME(15049) Reflection for unsized structs.\n-          ty::ty_struct(..) if !ty::type_is_sized(bcx.tcx(), t) => {\n-              fail!(\"Can't reflect unsized type\")\n-          }\n-\n-          // Should rename to vec_*.\n-          ty::ty_vec(ty, Some(sz)) => {\n-              let mut extra = (vec!(self.c_uint(sz))).append(self.c_size_and_align(t).as_slice());\n-              extra.push(self.c_tydesc(ty));\n-              self.visit(\"evec_fixed\", extra.as_slice())\n-          }\n-          ty::ty_ptr(ref mt) => {\n-              match ty::get(mt.ty).sty {\n-                  ty::ty_vec(ty, None) => {\n-                      let extra = self.c_mt(&ty::mt{ty: ty, mutbl: mt.mutbl});\n-                      self.visit(\"evec_slice\", extra.as_slice())\n-                  }\n-                  ty::ty_str => self.visit(\"estr_slice\", &[]),\n-                  ty::ty_trait(..) => {\n-                      let extra = [\n-                          self.c_slice(token::intern_and_get_ident(\n-                                  ty_to_string(tcx, t).as_slice()))\n-                      ];\n-                      self.visit(\"trait\", extra);\n-                  }\n-                  _ => {\n-                      let extra = self.c_mt(mt);\n-                      self.visit(\"ptr\", extra.as_slice())\n-                  }\n-              }\n-          }\n-          ty::ty_uniq(typ) => {\n-              match ty::get(typ).sty {\n-                  ty::ty_trait(..) => {\n-                      let extra = [\n-                          self.c_slice(token::intern_and_get_ident(\n-                                  ty_to_string(tcx, t).as_slice()))\n-                      ];\n-                      self.visit(\"trait\", extra);\n-                  }\n-                  // FIXME(15049) allow reflection of Box<[T]>. You'll need to\n-                  // restore visit_evec_uniq.\n-                  ty::ty_vec(_, None) => {\n-                      fail!(\"Box<[T]> theoretically doesn't exist, so don't try to reflect it\")\n-                  }\n-                  ty::ty_str => fail!(\"Can't reflect Box<str> which shouldn't be used anyway\"),\n-                  _ => {\n-                      let extra = self.c_mt(&ty::mt {\n-                          ty: typ,\n-                          mutbl: ast::MutImmutable,\n-                      });\n-                      self.visit(\"uniq\", extra.as_slice())\n-                  }\n-              }\n-          }\n-          ty::ty_rptr(_, ref mt) => {\n-              match ty::get(mt.ty).sty {\n-                  ty::ty_vec(ty, None) => {\n-                      let extra = self.c_mt(&ty::mt{ty: ty, mutbl: mt.mutbl});\n-                      self.visit(\"evec_slice\", extra.as_slice())\n-                  }\n-                  ty::ty_str => self.visit(\"estr_slice\", &[]),\n-                  ty::ty_trait(..) => {\n-                      let extra = [\n-                          self.c_slice(token::intern_and_get_ident(\n-                                  ty_to_string(tcx, t).as_slice()))\n-                      ];\n-                      self.visit(\"trait\", extra);\n-                  }\n-                  _ => {\n-                      let extra = self.c_mt(mt);\n-                      self.visit(\"rptr\", extra.as_slice())\n-                  }\n-              }\n-          }\n-\n-          ty::ty_tup(ref tys) => {\n-              let extra = (vec!(self.c_uint(tys.len())))\n-                          .append(self.c_size_and_align(t).as_slice());\n-              self.bracketed(\"tup\", extra.as_slice(), |this| {\n-                  for (i, t) in tys.iter().enumerate() {\n-                      let extra = vec!(this.c_uint(i), this.c_tydesc(*t));\n-                      this.visit(\"tup_field\", extra.as_slice());\n-                  }\n-              })\n-          }\n-\n-          // FIXME (#2594): fetch constants out of intrinsic\n-          // FIXME (#4809): visitor should break out bare fns from other fns\n-          ty::ty_closure(box ref fty) => {\n-              self.visit_closure_ty(fty, false);\n-          }\n-\n-          // FIXME (#2594): fetch constants out of intrinsic:: for the\n-          // numbers.\n-          ty::ty_bare_fn(ref fty) => {\n-            let pureval = ast_fn_style_constant(fty.fn_style);\n-            let sigilval = 0u;\n-            let retval = if ty::type_is_bot(fty.sig.output) {0u} else {1u};\n-            let extra = vec!(self.c_uint(pureval),\n-                          self.c_uint(sigilval),\n-                          self.c_uint(fty.sig.inputs.len()),\n-                          self.c_uint(retval));\n-            self.visit(\"enter_fn\", extra.as_slice());\n-            self.visit_sig(retval, &fty.sig, false);\n-            self.visit(\"leave_fn\", extra.as_slice());\n-          }\n-\n-          ty::ty_struct(did, ref substs) => {\n-              let fields = ty::struct_fields(tcx, did, substs);\n-              let mut named_fields = false;\n-              if !fields.is_empty() {\n-                  named_fields = fields.get(0).ident.name !=\n-                      special_idents::unnamed_field.name;\n-              }\n-\n-              // This and the type_is_sized check on individual field types are\n-              // because we cannot reflect unsized types (see note above). We\n-              // just pretend the unsized field does not exist and print nothing.\n-              // This is sub-optimal.\n-              let len = fields.len();\n-\n-              let extra = (vec!(\n-                  self.c_slice(\n-                      token::intern_and_get_ident(ty_to_string(tcx,\n-                                                            t).as_slice())),\n-                  self.c_bool(named_fields),\n-                  self.c_uint(len)\n-              )).append(self.c_size_and_align(t).as_slice());\n-              self.bracketed(\"class\", extra.as_slice(), |this| {\n-                  for (i, field) in fields.iter().enumerate() {\n-                      let extra = (vec!(\n-                        this.c_uint(i),\n-                        this.c_slice(token::get_ident(field.ident)),\n-                        this.c_bool(named_fields)\n-                      )).append(this.c_mt(&field.mt).as_slice());\n-                      this.visit(\"class_field\", extra.as_slice());\n-                  }\n-              })\n-          }\n-\n-          // FIXME (#2595): visiting all the variants in turn is probably\n-          // not ideal. It'll work but will get costly on big enums. Maybe\n-          // let the visitor tell us if it wants to visit only a particular\n-          // variant?\n-          ty::ty_enum(did, ref substs) => {\n-            let ccx = bcx.ccx();\n-            let repr = adt::represent_type(bcx.ccx(), t);\n-            let variants = ty::substd_enum_variants(ccx.tcx(), did, substs);\n-            let llptrty = type_of(ccx, t).ptr_to();\n-            let opaquety = ty::get_opaque_ty(ccx.tcx()).unwrap();\n-            let opaqueptrty = ty::mk_ptr(ccx.tcx(), ty::mt { ty: opaquety,\n-                                                           mutbl: ast::MutImmutable });\n-\n-            let make_get_disr = || {\n-                let sym = mangle_internal_name_by_path_and_seq(\n-                    ast_map::Values([].iter()).chain(None), \"get_disr\");\n-\n-                let fn_ty = ty::mk_ctor_fn(ccx.tcx(), ast::DUMMY_NODE_ID,\n-                                           [opaqueptrty], ty::mk_u64());\n-                let llfdecl = decl_internal_rust_fn(ccx,\n-                                                    fn_ty,\n-                                                    sym.as_slice());\n-                let arena = TypedArena::new();\n-                let empty_param_substs = param_substs::empty();\n-                let fcx = new_fn_ctxt(ccx, llfdecl, ast::DUMMY_NODE_ID, false,\n-                                      ty::mk_u64(), &empty_param_substs,\n-                                      None, &arena);\n-                let bcx = init_function(&fcx, false, ty::mk_u64());\n-\n-                // we know the return type of llfdecl is an int here, so\n-                // no need for a special check to see if the return type\n-                // is immediate.\n-                let arg = get_param(llfdecl, fcx.arg_pos(0u) as c_uint);\n-                let arg = BitCast(bcx, arg, llptrty);\n-                let ret = adt::trans_get_discr(bcx, &*repr, arg, Some(Type::i64(ccx)));\n-                assert!(!fcx.needs_ret_allocas);\n-                let ret_slot = fcx.get_ret_slot(bcx, ty::mk_u64(), \"ret_slot\");\n-                Store(bcx, ret, ret_slot);\n-                match fcx.llreturn.get() {\n-                    Some(llreturn) => Br(bcx, llreturn),\n-                    None => {}\n-                };\n-                finish_fn(&fcx, bcx, ty::mk_u64());\n-                llfdecl\n-            };\n-\n-            let enum_args = (vec!(self.c_uint(variants.len()), make_get_disr()))\n-                            .append(self.c_size_and_align(t).as_slice());\n-            self.bracketed(\"enum\", enum_args.as_slice(), |this| {\n-                for (i, v) in variants.iter().enumerate() {\n-                    let name = token::get_ident(v.name);\n-                    let variant_args = [this.c_uint(i),\n-                                         C_u64(ccx, v.disr_val),\n-                                         this.c_uint(v.args.len()),\n-                                         this.c_slice(name)];\n-                    this.bracketed(\"enum_variant\",\n-                                   variant_args,\n-                                   |this| {\n-                        for (j, a) in v.args.iter().enumerate() {\n-                            let bcx = this.bcx;\n-                            let null = C_null(llptrty);\n-                            let ptr = adt::trans_field_ptr(bcx, &*repr, null, v.disr_val, j);\n-                            let offset = p2i(ccx, ptr);\n-                            let field_args = [this.c_uint(j),\n-                                               offset,\n-                                               this.c_tydesc(*a)];\n-                            this.visit(\"enum_variant_field\",\n-                                       field_args);\n-                        }\n-                    })\n-                }\n-            })\n-          }\n-\n-          // Miscellaneous extra types\n-          ty::ty_infer(_) => self.leaf(\"infer\"),\n-          ty::ty_err => self.leaf(\"err\"),\n-          ty::ty_unboxed_closure(ref def_id, _) => {\n-              let closure_map = tcx.unboxed_closures.borrow();\n-              let fty = &closure_map.find(def_id).unwrap().closure_type;\n-              self.visit_closure_ty(fty, true);\n-          }\n-          ty::ty_param(ref p) => {\n-              let extra = vec!(self.c_uint(p.idx));\n-              self.visit(\"param\", extra.as_slice())\n-          }\n-        }\n-    }\n-\n-    pub fn visit_sig(&mut self, retval: uint, sig: &ty::FnSig, is_unboxed: bool) {\n-        let args = if is_unboxed {\n-            match ty::get(sig.inputs[0]).sty {\n-                ty::ty_tup(ref contents) => contents.iter(),\n-                ty::ty_nil => [].iter(),\n-                _ => unreachable!()\n-            }\n-        } else {\n-            sig.inputs.iter()\n-        };\n-\n-        for (i, arg) in args.enumerate() {\n-            let modeval = 5u;   // \"by copy\"\n-            let extra = vec!(self.c_uint(i),\n-                         self.c_uint(modeval),\n-                         self.c_tydesc(*arg));\n-            self.visit(\"fn_input\", extra.as_slice());\n-        }\n-        let extra = vec!(self.c_uint(retval),\n-                      self.c_bool(sig.variadic),\n-                      self.c_tydesc(sig.output));\n-        self.visit(\"fn_output\", extra.as_slice());\n-    }\n-}\n-\n-// Emit a sequence of calls to visit_ty::visit_foo\n-pub fn emit_calls_to_trait_visit_ty<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                                t: ty::t,\n-                                                visitor_val: ValueRef,\n-                                                visitor_trait_id: DefId)\n-                                                -> Block<'blk, 'tcx> {\n-    let fcx = bcx.fcx;\n-    let final_bcx = fcx.new_temp_block(\"final\");\n-    let tydesc_ty = ty::get_tydesc_ty(bcx.tcx()).unwrap();\n-    let tydesc_ty = type_of(bcx.ccx(), tydesc_ty);\n-    let visitor_items = ty::trait_items(bcx.tcx(), visitor_trait_id);\n-    let mut r = Reflector {\n-        visitor_val: visitor_val,\n-        visitor_items: visitor_items.as_slice(),\n-        final_bcx: final_bcx,\n-        tydesc_ty: tydesc_ty,\n-        bcx: bcx\n-    };\n-    r.visit_ty(t);\n-    Br(r.bcx, final_bcx.llbb);\n-    return final_bcx;\n-}\n-\n-pub fn ast_fn_style_constant(fn_style: ast::FnStyle) -> uint {\n-    match fn_style {\n-        ast::UnsafeFn => 1u,\n-        ast::NormalFn => 2u,\n-    }\n-}"}, {"sha": "a404d9d221ec1f6ce5c34cd1956a15b9cabb300e", "filename": "src/librustc/middle/trans/tvec.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -118,7 +118,7 @@ pub fn trans_fixed_vstore<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     // to store the array of the suitable size, so all we have to do is\n     // generate the content.\n \n-    debug!(\"trans_fixed_vstore(expr={}, dest={:?})\",\n+    debug!(\"trans_fixed_vstore(expr={}, dest={})\",\n            bcx.expr_to_string(expr), dest.to_string(bcx.ccx()));\n \n     let vt = vec_types_from_expr(bcx, expr);\n@@ -175,7 +175,7 @@ pub fn trans_slice_vec<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     // Handle the &[...] case:\n     let vt = vec_types_from_expr(bcx, content_expr);\n     let count = elements_required(bcx, content_expr);\n-    debug!(\"    vt={}, count={:?}\", vt.to_string(ccx), count);\n+    debug!(\"    vt={}, count={}\", vt.to_string(ccx), count);\n     let llcount = C_uint(ccx, count);\n \n     let fixed_ty = ty::mk_vec(bcx.tcx(),\n@@ -249,7 +249,7 @@ pub fn write_content<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let fcx = bcx.fcx;\n     let mut bcx = bcx;\n \n-    debug!(\"write_content(vt={}, dest={}, vstore_expr={:?})\",\n+    debug!(\"write_content(vt={}, dest={}, vstore_expr={})\",\n            vt.to_string(bcx.ccx()),\n            dest.to_string(bcx.ccx()),\n            bcx.expr_to_string(vstore_expr));\n@@ -291,7 +291,7 @@ pub fn write_content<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                     let temp_scope = fcx.push_custom_cleanup_scope();\n                     for (i, element) in elements.iter().enumerate() {\n                         let lleltptr = GEPi(bcx, lldest, [i]);\n-                        debug!(\"writing index {:?} with lleltptr={:?}\",\n+                        debug!(\"writing index {} with lleltptr={}\",\n                                i, bcx.val_to_string(lleltptr));\n                         bcx = expr::trans_into(bcx, &**element,\n                                                SaveIn(lleltptr));"}, {"sha": "6acbde3b2adc95ad7088d9a10cae731a62b484e9", "filename": "src/librustc/middle/trans/type_.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -197,7 +197,6 @@ impl Type {\n         let elems = [int_ty,     // size\n                      int_ty,     // align\n                      glue_fn_ty, // drop\n-                     glue_fn_ty, // visit\n                      str_slice_ty]; // name\n         tydesc.set_struct_body(elems, false);\n "}, {"sha": "e723d5af89cc4a0ca5a2e331dcae9338d57d3992", "filename": "src/librustc/middle/trans/type_of.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -253,7 +253,7 @@ pub fn type_of(cx: &CrateContext, t: ty::t) -> Type {\n         None => ()\n     }\n \n-    debug!(\"type_of {} {:?}\", t.repr(cx.tcx()), ty::get(t).sty);\n+    debug!(\"type_of {} {}\", t.repr(cx.tcx()), ty::get(t).sty);\n \n     // Replace any typedef'd types with their equivalent non-typedef\n     // type. This ensures that all LLVM nominal types that contain\n@@ -264,7 +264,7 @@ pub fn type_of(cx: &CrateContext, t: ty::t) -> Type {\n \n     if t != t_norm {\n         let llty = type_of(cx, t_norm);\n-        debug!(\"--> normalized {} {:?} to {} {:?} llty={}\",\n+        debug!(\"--> normalized {} {} to {} {} llty={}\",\n                 t.repr(cx.tcx()),\n                 t,\n                 t_norm.repr(cx.tcx()),\n@@ -378,7 +378,7 @@ pub fn type_of(cx: &CrateContext, t: ty::t) -> Type {\n       ty::ty_err(..) => cx.sess().bug(\"type_of with ty_err\"),\n     };\n \n-    debug!(\"--> mapped t={} {:?} to llty={}\",\n+    debug!(\"--> mapped t={} {} to llty={}\",\n             t.repr(cx.tcx()),\n             t,\n             cx.tn().type_to_string(llty));"}, {"sha": "b84bfe9522446632a61e4a25cde9e3e34e9580e5", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 26, "deletions": 54, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -18,8 +18,7 @@ use middle::const_eval;\n use middle::def;\n use middle::dependency_format;\n use middle::lang_items::{FnTraitLangItem, FnMutTraitLangItem};\n-use middle::lang_items::{FnOnceTraitLangItem, OpaqueStructLangItem};\n-use middle::lang_items::{TyDescStructLangItem, TyVisitorTraitLangItem};\n+use middle::lang_items::{FnOnceTraitLangItem, TyDescStructLangItem};\n use middle::mem_categorization as mc;\n use middle::resolve;\n use middle::resolve_lifetime;\n@@ -70,7 +69,7 @@ pub struct field {\n     pub mt: mt\n }\n \n-#[deriving(Clone)]\n+#[deriving(Clone, Show)]\n pub enum ImplOrTraitItemContainer {\n     TraitContainer(ast::DefId),\n     ImplContainer(ast::DefId),\n@@ -138,7 +137,7 @@ impl ImplOrTraitItemId {\n     }\n }\n \n-#[deriving(Clone)]\n+#[deriving(Clone, Show)]\n pub struct Method {\n     pub ident: ast::Ident,\n     pub generics: ty::Generics,\n@@ -268,13 +267,13 @@ pub enum Variance {\n     Bivariant,      // T<A> <: T<B>            -- e.g., unused type parameter\n }\n \n-#[deriving(Clone)]\n+#[deriving(Clone, Show)]\n pub enum AutoAdjustment {\n     AdjustAddEnv(ty::TraitStore),\n     AdjustDerefRef(AutoDerefRef)\n }\n \n-#[deriving(Clone, PartialEq)]\n+#[deriving(Clone, PartialEq, Show)]\n pub enum UnsizeKind {\n     // [T, ..n] -> [T], the uint field is n.\n     UnsizeLength(uint),\n@@ -284,13 +283,13 @@ pub enum UnsizeKind {\n     UnsizeVtable(TyTrait, /* the self type of the trait */ ty::t)\n }\n \n-#[deriving(Clone)]\n+#[deriving(Clone, Show)]\n pub struct AutoDerefRef {\n     pub autoderefs: uint,\n     pub autoref: Option<AutoRef>\n }\n \n-#[deriving(Clone, PartialEq)]\n+#[deriving(Clone, PartialEq, Show)]\n pub enum AutoRef {\n     /// Convert from T to &T\n     /// The third field allows us to wrap other AutoRef adjustments.\n@@ -726,7 +725,7 @@ pub enum Region {\n  * the original var id (that is, the root variable that is referenced\n  * by the upvar) and the id of the closure expression.\n  */\n-#[deriving(Clone, PartialEq, Eq, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Hash, Show)]\n pub struct UpvarId {\n     pub var_id: ast::NodeId,\n     pub closure_expr_id: ast::NodeId,\n@@ -827,7 +826,7 @@ pub enum BorrowKind {\n  *   the closure, so sometimes it is necessary for them to be larger\n  *   than the closure lifetime itself.\n  */\n-#[deriving(PartialEq, Clone, Encodable, Decodable)]\n+#[deriving(PartialEq, Clone, Encodable, Decodable, Show)]\n pub struct UpvarBorrow {\n     pub kind: BorrowKind,\n     pub region: ty::Region,\n@@ -1434,7 +1433,7 @@ pub struct UnboxedClosure {\n     pub kind: UnboxedClosureKind,\n }\n \n-#[deriving(Clone, PartialEq, Eq)]\n+#[deriving(Clone, PartialEq, Eq, Show)]\n pub enum UnboxedClosureKind {\n     FnUnboxedClosureKind,\n     FnMutUnboxedClosureKind,\n@@ -3133,7 +3132,7 @@ pub fn fn_is_variadic(fty: t) -> bool {\n         ty_bare_fn(ref f) => f.sig.variadic,\n         ty_closure(ref f) => f.sig.variadic,\n         ref s => {\n-            fail!(\"fn_is_variadic() called on non-fn type: {:?}\", s)\n+            fail!(\"fn_is_variadic() called on non-fn type: {}\", s)\n         }\n     }\n }\n@@ -3143,7 +3142,7 @@ pub fn ty_fn_sig(fty: t) -> FnSig {\n         ty_bare_fn(ref f) => f.sig.clone(),\n         ty_closure(ref f) => f.sig.clone(),\n         ref s => {\n-            fail!(\"ty_fn_sig() called on non-fn type: {:?}\", s)\n+            fail!(\"ty_fn_sig() called on non-fn type: {}\", s)\n         }\n     }\n }\n@@ -3163,7 +3162,7 @@ pub fn ty_fn_args(fty: t) -> Vec<t> {\n         ty_bare_fn(ref f) => f.sig.inputs.clone(),\n         ty_closure(ref f) => f.sig.inputs.clone(),\n         ref s => {\n-            fail!(\"ty_fn_args() called on non-fn type: {:?}\", s)\n+            fail!(\"ty_fn_args() called on non-fn type: {}\", s)\n         }\n     }\n }\n@@ -3177,7 +3176,7 @@ pub fn ty_closure_store(fty: t) -> TraitStore {\n             UniqTraitStore\n         }\n         ref s => {\n-            fail!(\"ty_closure_store() called on non-closure type: {:?}\", s)\n+            fail!(\"ty_closure_store() called on non-closure type: {}\", s)\n         }\n     }\n }\n@@ -3187,7 +3186,7 @@ pub fn ty_fn_ret(fty: t) -> t {\n         ty_bare_fn(ref f) => f.sig.output,\n         ty_closure(ref f) => f.sig.output,\n         ref s => {\n-            fail!(\"ty_fn_ret() called on non-fn type: {:?}\", s)\n+            fail!(\"ty_fn_ret() called on non-fn type: {}\", s)\n         }\n     }\n }\n@@ -3208,7 +3207,7 @@ pub fn ty_region(tcx: &ctxt,\n         ref s => {\n             tcx.sess.span_bug(\n                 span,\n-                format!(\"ty_region() invoked on an inappropriate ty: {:?}\",\n+                format!(\"ty_region() invoked on an inappropriate ty: {}\",\n                         s).as_slice());\n         }\n     }\n@@ -3272,7 +3271,7 @@ pub fn expr_span(cx: &ctxt, id: NodeId) -> Span {\n             e.span\n         }\n         Some(f) => {\n-            cx.sess.bug(format!(\"Node id {} is not an expr: {:?}\",\n+            cx.sess.bug(format!(\"Node id {} is not an expr: {}\",\n                                 id,\n                                 f).as_slice());\n         }\n@@ -3292,14 +3291,14 @@ pub fn local_var_name_str(cx: &ctxt, id: NodeId) -> InternedString {\n                 }\n                 _ => {\n                     cx.sess.bug(\n-                        format!(\"Variable id {} maps to {:?}, not local\",\n+                        format!(\"Variable id {} maps to {}, not local\",\n                                 id,\n                                 pat).as_slice());\n                 }\n             }\n         }\n         r => {\n-            cx.sess.bug(format!(\"Variable id {} maps to {:?}, not local\",\n+            cx.sess.bug(format!(\"Variable id {} maps to {}, not local\",\n                                 id,\n                                 r).as_slice());\n         }\n@@ -3343,7 +3342,7 @@ pub fn adjust_ty(cx: &ctxt,\n                         ref b => {\n                             cx.sess.bug(\n                                 format!(\"add_env adjustment on non-bare-fn: \\\n-                                         {:?}\",\n+                                         {}\",\n                                         b).as_slice());\n                         }\n                     }\n@@ -3456,7 +3455,7 @@ pub fn resolve_expr(tcx: &ctxt, expr: &ast::Expr) -> def::Def {\n         Some(&def) => def,\n         None => {\n             tcx.sess.span_bug(expr.span, format!(\n-                \"no def-map entry for expr {:?}\", expr.id).as_slice());\n+                \"no def-map entry for expr {}\", expr.id).as_slice());\n         }\n     }\n }\n@@ -3547,7 +3546,7 @@ pub fn expr_kind(tcx: &ctxt, expr: &ast::Expr) -> ExprKind {\n                 def => {\n                     tcx.sess.span_bug(\n                         expr.span,\n-                        format!(\"uncategorized def for expr {:?}: {:?}\",\n+                        format!(\"uncategorized def for expr {}: {}\",\n                                 expr.id,\n                                 def).as_slice());\n                 }\n@@ -3671,7 +3670,7 @@ pub fn field_idx_strict(tcx: &ctxt, name: ast::Name, fields: &[field])\n     let mut i = 0u;\n     for f in fields.iter() { if f.ident.name == name { return i; } i += 1u; }\n     tcx.sess.bug(format!(\n-        \"no field named `{}` found in the list of fields `{:?}`\",\n+        \"no field named `{}` found in the list of fields `{}`\",\n         token::get_name(name),\n         fields.iter()\n               .map(|f| token::get_ident(f.ident).get().to_string())\n@@ -3965,7 +3964,7 @@ fn lookup_locally_or_in_crate_store<V:Clone>(\n     }\n \n     if def_id.krate == ast::LOCAL_CRATE {\n-        fail!(\"No def'n found for {:?} in tcx.{}\", def_id, descr);\n+        fail!(\"No def'n found for {} in tcx.{}\", def_id, descr);\n     }\n     let v = load_external();\n     map.insert(def_id, v.clone());\n@@ -4083,7 +4082,7 @@ pub fn trait_item_def_ids(cx: &ctxt, id: ast::DefId)\n pub fn impl_trait_ref(cx: &ctxt, id: ast::DefId) -> Option<Rc<TraitRef>> {\n     memoized(&cx.impl_trait_cache, id, |id: ast::DefId| {\n         if id.krate == ast::LOCAL_CRATE {\n-            debug!(\"(impl_trait_ref) searching for trait impl {:?}\", id);\n+            debug!(\"(impl_trait_ref) searching for trait impl {}\", id);\n             match cx.map.find(id.node) {\n                 Some(ast_map::NodeItem(item)) => {\n                     match item.node {\n@@ -4821,33 +4820,6 @@ pub fn get_tydesc_ty(tcx: &ctxt) -> Result<t, String> {\n     })\n }\n \n-pub fn get_opaque_ty(tcx: &ctxt) -> Result<t, String> {\n-    tcx.lang_items.require(OpaqueStructLangItem).map(|opaque_lang_item| {\n-        tcx.intrinsic_defs.borrow().find_copy(&opaque_lang_item)\n-            .expect(\"Failed to resolve Opaque\")\n-    })\n-}\n-\n-pub fn visitor_object_ty(tcx: &ctxt,\n-                         ptr_region: ty::Region,\n-                         trait_region: ty::Region)\n-                         -> Result<(Rc<TraitRef>, t), String>\n-{\n-    let trait_lang_item = match tcx.lang_items.require(TyVisitorTraitLangItem) {\n-        Ok(id) => id,\n-        Err(s) => { return Err(s); }\n-    };\n-    let substs = Substs::empty();\n-    let trait_ref = Rc::new(TraitRef { def_id: trait_lang_item, substs: substs });\n-    Ok((trait_ref.clone(),\n-        mk_rptr(tcx, ptr_region,\n-                mt {mutbl: ast::MutMutable,\n-                    ty: mk_trait(tcx,\n-                                 trait_ref.def_id,\n-                                 trait_ref.substs.clone(),\n-                                 ty::region_existential_bound(trait_region))})))\n-}\n-\n pub fn item_variances(tcx: &ctxt, item_id: ast::DefId) -> Rc<ItemVariances> {\n     lookup_locally_or_in_crate_store(\n         \"item_variance_map\", item_id, &mut *tcx.item_variance_map.borrow_mut(),\n@@ -5418,7 +5390,7 @@ impl<'tcx> mc::Typer<'tcx> for ty::ctxt<'tcx> {\n }\n \n /// The category of explicit self.\n-#[deriving(Clone, Eq, PartialEq)]\n+#[deriving(Clone, Eq, PartialEq, Show)]\n pub enum ExplicitSelfCategory {\n     StaticExplicitSelfCategory,\n     ByValueExplicitSelfCategory,"}, {"sha": "0e9d255adf9daf1ba8be33a359398b328104fad0", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -961,7 +961,7 @@ pub fn ast_ty_to_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n                     _ => {\n                         tcx.sess.span_fatal(ast_ty.span,\n                                             format!(\"found value name used \\\n-                                                     as a type: {:?}\",\n+                                                     as a type: {}\",\n                                                     a_def).as_slice());\n                     }\n                 }"}, {"sha": "9463bafc9d277b70d21ad9e95905a73cb6e265a0", "filename": "src/librustc/middle/typeck/check/_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -442,8 +442,8 @@ pub fn check_pat(pcx: &pat_ctxt, pat: &ast::Pat, expected: ty::t) {\n             fcx.infcx().resolve_type_vars_if_possible(fcx.expr_ty(&**begin));\n         let e_ty =\n             fcx.infcx().resolve_type_vars_if_possible(fcx.expr_ty(&**end));\n-        debug!(\"pat_range beginning type: {:?}\", b_ty);\n-        debug!(\"pat_range ending type: {:?}\", e_ty);\n+        debug!(\"pat_range beginning type: {}\", b_ty);\n+        debug!(\"pat_range ending type: {}\", e_ty);\n         if !require_same_types(\n             tcx, Some(fcx.infcx()), false, pat.span, b_ty, e_ty,\n             || \"mismatched types in range\".to_string())"}, {"sha": "c2e7be2781fd6d073af52be163149e14f5ae10f9", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -643,7 +643,7 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n                                            rcvr_ty: ty::t,\n                                            restrict_to: Option<DefId>,\n                                            param_ty: ParamTy) {\n-        debug!(\"push_inherent_candidates_from_param(param_ty={:?})\",\n+        debug!(\"push_inherent_candidates_from_param(param_ty={})\",\n                param_ty);\n         self.push_inherent_candidates_from_bounds(\n             rcvr_ty,\n@@ -754,7 +754,7 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n                     }\n                 }\n                 None => {\n-                    debug!(\"trait doesn't contain method: {:?}\",\n+                    debug!(\"trait doesn't contain method: {}\",\n                         bound_trait_ref.def_id);\n                     // check next trait or bound\n                 }\n@@ -873,7 +873,7 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n             None => None,\n             Some(method) => {\n                 debug!(\"(searching for autoderef'd method) writing \\\n-                       adjustment {:?} for {}\", adjustment, self.ty_to_string(self_ty));\n+                       adjustment {} for {}\", adjustment, self.ty_to_string(self_ty));\n                 match adjustment {\n                     Some((self_expr_id, adj)) => {\n                         self.fcx.write_adjustment(self_expr_id, self.span, adj);\n@@ -1759,7 +1759,7 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n impl Repr for Candidate {\n     fn repr(&self, tcx: &ty::ctxt) -> String {\n         format!(\"Candidate(rcvr_ty={}, rcvr_substs={}, method_ty={}, \\\n-                 origin={:?})\",\n+                 origin={})\",\n                 self.rcvr_match_condition.repr(tcx),\n                 self.rcvr_substs.repr(tcx),\n                 self.method_ty.repr(tcx),"}, {"sha": "be622bd685501018343cd8d4f2f46f549a62daa7", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 4, "deletions": 23, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -1563,7 +1563,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             None => {\n                 self.tcx().sess.span_bug(\n                     span,\n-                    format!(\"no type for local variable {:?}\",\n+                    format!(\"no type for local variable {}\",\n                             nid).as_slice());\n             }\n         }\n@@ -1622,7 +1622,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             node_id: ast::NodeId,\n                             span: Span,\n                             adj: ty::AutoAdjustment) {\n-        debug!(\"write_adjustment(node_id={:?}, adj={:?})\", node_id, adj);\n+        debug!(\"write_adjustment(node_id={}, adj={})\", node_id, adj);\n \n         // Careful: adjustments can imply trait obligations if we are\n         // casting from a concrete type to an object type. I think\n@@ -1673,7 +1673,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     fn register_unsize_obligations(&self,\n                                    span: Span,\n                                    unsize: &ty::UnsizeKind) {\n-        debug!(\"register_unsize_obligations: unsize={:?}\", unsize);\n+        debug!(\"register_unsize_obligations: unsize={}\", unsize);\n \n         match *unsize {\n             ty::UnsizeLength(..) => {}\n@@ -2551,7 +2551,7 @@ fn check_argument_types<'a>(fcx: &FnCtxt,\n         err_args(supplied_arg_count)\n     };\n \n-    debug!(\"check_argument_types: formal_tys={:?}\",\n+    debug!(\"check_argument_types: formal_tys={}\",\n            formal_tys.iter().map(|t| fcx.infcx().ty_to_string(*t)).collect::<Vec<String>>());\n \n     // Check the arguments.\n@@ -5578,25 +5578,6 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &ast::ForeignItem) {\n                     }\n                 }\n             },\n-            \"visit_tydesc\" => {\n-              let tydesc_ty = match ty::get_tydesc_ty(ccx.tcx) {\n-                  Ok(t) => t,\n-                  Err(s) => { tcx.sess.span_fatal(it.span, s.as_slice()); }\n-              };\n-              let region0 = ty::ReLateBound(it.id, ty::BrAnon(0));\n-              let region1 = ty::ReLateBound(it.id, ty::BrAnon(1));\n-              let visitor_object_ty =\n-                    match ty::visitor_object_ty(tcx, region0, region1) {\n-                        Ok((_, vot)) => vot,\n-                        Err(s) => { tcx.sess.span_fatal(it.span, s.as_slice()); }\n-                    };\n-\n-              let td_ptr = ty::mk_ptr(ccx.tcx, ty::mt {\n-                  ty: tydesc_ty,\n-                  mutbl: ast::MutImmutable\n-              });\n-              (0, vec!( td_ptr, visitor_object_ty ), ty::mk_nil())\n-            }\n             \"offset\" => {\n               (1,\n                vec!("}, {"sha": "b810ea3d94de613d17dd276126ef85173bbe8d3d", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -239,7 +239,7 @@ fn region_of_def(fcx: &FnCtxt, def: def::Def) -> ty::Region {\n             }\n         }\n         _ => {\n-            tcx.sess.bug(format!(\"unexpected def in region_of_def: {:?}\",\n+            tcx.sess.bug(format!(\"unexpected def in region_of_def: {}\",\n                                  def).as_slice())\n         }\n     }\n@@ -560,7 +560,7 @@ fn constrain_bindings_in_pat(pat: &ast::Pat, rcx: &mut Rcx) {\n }\n \n fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n-    debug!(\"regionck::visit_expr(e={}, repeating_scope={:?})\",\n+    debug!(\"regionck::visit_expr(e={}, repeating_scope={})\",\n            expr.repr(rcx.fcx.tcx()), rcx.repeating_scope);\n \n     // No matter what, the type of each expression must outlive the\n@@ -575,7 +575,7 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n \n     // Check any autoderefs or autorefs that appear.\n     for &adjustment in rcx.fcx.inh.adjustments.borrow().find(&expr.id).iter() {\n-        debug!(\"adjustment={:?}\", adjustment);\n+        debug!(\"adjustment={}\", adjustment);\n         match *adjustment {\n             ty::AdjustDerefRef(ty::AutoDerefRef {autoderefs, autoref: ref opt_autoref}) => {\n                 let expr_ty = rcx.resolve_node_type(expr.id);\n@@ -978,7 +978,7 @@ fn check_expr_fn_block(rcx: &mut Rcx,\n         debug!(\"constrain_free_variables({}, {})\",\n                region_bound.repr(tcx), expr.repr(tcx));\n         for freevar in freevars.iter() {\n-            debug!(\"freevar def is {:?}\", freevar.def);\n+            debug!(\"freevar def is {}\", freevar.def);\n \n             // Identify the variable being closed over and its node-id.\n             let def = freevar.def;\n@@ -1116,7 +1116,7 @@ fn constrain_call<'a, I: Iterator<&'a ast::Expr>>(rcx: &mut Rcx,\n     let tcx = rcx.fcx.tcx();\n     debug!(\"constrain_call(call_expr={}, \\\n             receiver={}, \\\n-            implicitly_ref_args={:?})\",\n+            implicitly_ref_args={})\",\n             call_expr.repr(tcx),\n             receiver.repr(tcx),\n             implicitly_ref_args);\n@@ -1171,7 +1171,7 @@ fn constrain_autoderefs(rcx: &mut Rcx,\n      */\n     let r_deref_expr = ty::ReScope(deref_expr.id);\n     for i in range(0u, derefs) {\n-        debug!(\"constrain_autoderefs(deref_expr=?, derefd_ty={}, derefs={:?}/{:?}\",\n+        debug!(\"constrain_autoderefs(deref_expr=?, derefd_ty={}, derefs={}/{}\",\n                rcx.fcx.infcx().ty_to_string(derefd_ty),\n                i, derefs);\n \n@@ -1280,7 +1280,7 @@ fn type_of_node_must_outlive(\n                            rcx.fcx.inh.adjustments.borrow().find(&id),\n                            |method_call| rcx.resolve_method_type(method_call));\n     debug!(\"constrain_regions_in_type_of_node(\\\n-            ty={}, ty0={}, id={}, minimum_lifetime={:?})\",\n+            ty={}, ty0={}, id={}, minimum_lifetime={})\",\n            ty_to_string(tcx, ty), ty_to_string(tcx, ty0),\n            id, minimum_lifetime);\n     type_must_outlive(rcx, origin, ty, minimum_lifetime);\n@@ -1381,7 +1381,7 @@ fn link_autoref(rcx: &Rcx,\n      * to lifetimes in the value being autoref'd.\n      */\n \n-    debug!(\"link_autoref(autoref={:?})\", autoref);\n+    debug!(\"link_autoref(autoref={})\", autoref);\n     let mc = mc::MemCategorizationContext::new(rcx);\n     let expr_cmt = ignore_err!(mc.cat_expr_autoderefd(expr, autoderefs));\n     debug!(\"expr_cmt={}\", expr_cmt.repr(rcx.tcx()));\n@@ -1779,7 +1779,7 @@ fn link_upvar_borrow_kind_for_nested_closures(rcx: &mut Rcx,\n      * this function.\n      */\n \n-    debug!(\"link_upvar_borrow_kind: inner_upvar_id={:?} outer_upvar_id={:?}\",\n+    debug!(\"link_upvar_borrow_kind: inner_upvar_id={} outer_upvar_id={}\",\n            inner_upvar_id, outer_upvar_id);\n \n     let mut upvar_borrow_map = rcx.fcx.inh.upvar_borrow_map.borrow_mut();\n@@ -1795,7 +1795,7 @@ fn link_upvar_borrow_kind_for_nested_closures(rcx: &mut Rcx,\n fn adjust_upvar_borrow_kind_for_loan(upvar_id: ty::UpvarId,\n                                      upvar_borrow: &mut ty::UpvarBorrow,\n                                      kind: ty::BorrowKind) {\n-    debug!(\"adjust_upvar_borrow_kind_for_loan: upvar_id={:?} kind={:?} -> {:?}\",\n+    debug!(\"adjust_upvar_borrow_kind_for_loan: upvar_id={} kind={} -> {}\",\n            upvar_id, upvar_borrow.kind, kind);\n \n     adjust_upvar_borrow_kind(upvar_id, upvar_borrow, kind)\n@@ -1812,7 +1812,7 @@ fn adjust_upvar_borrow_kind(upvar_id: ty::UpvarId,\n      * is required by some particular use.\n      */\n \n-    debug!(\"adjust_upvar_borrow_kind: id={:?} kind=({:?} -> {:?})\",\n+    debug!(\"adjust_upvar_borrow_kind: id={} kind=({} -> {})\",\n            upvar_id, upvar_borrow.kind, kind);\n \n     match (upvar_borrow.kind, kind) {"}, {"sha": "56dec61d4102e054a2c596659527199c2fdb87a8", "filename": "src/librustc/middle/typeck/check/writeback.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -306,7 +306,7 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n                         })\n                     }\n                 };\n-                debug!(\"Adjustments for node {}: {:?}\", id, resolved_adjustment);\n+                debug!(\"Adjustments for node {}: {}\", id, resolved_adjustment);\n                 self.tcx().adjustments.borrow_mut().insert(\n                     id, resolved_adjustment);\n             }\n@@ -319,7 +319,7 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n         // Resolve any method map entry\n         match self.fcx.inh.method_map.borrow_mut().pop(&method_call) {\n             Some(method) => {\n-                debug!(\"writeback::resolve_method_map_entry(call={:?}, entry={})\",\n+                debug!(\"writeback::resolve_method_map_entry(call={}, entry={})\",\n                        method_call,\n                        method.repr(self.tcx()));\n                 let new_method = MethodCallee {"}, {"sha": "eef466ceebb9f35be39dd9c8ccf39fe99d025fa3", "filename": "src/librustc/middle/typeck/coherence/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence%2Fmod.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -86,7 +86,7 @@ fn get_base_type(inference_context: &InferCtxt,\n         ty_str(..) | ty_vec(..) | ty_bare_fn(..) | ty_closure(..) | ty_tup(..) |\n         ty_infer(..) | ty_param(..) | ty_err | ty_open(..) | ty_uniq(_) |\n         ty_ptr(_) | ty_rptr(_, _) => {\n-            debug!(\"(getting base type) no base type; found {:?}\",\n+            debug!(\"(getting base type) no base type; found {}\",\n                    get(original_type).sty);\n             None\n         }\n@@ -245,7 +245,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n             trait_ref: &ty::TraitRef,\n             all_impl_items: &mut Vec<ImplOrTraitItemId>) {\n         let tcx = self.crate_context.tcx;\n-        debug!(\"instantiate_default_methods(impl_id={:?}, trait_ref={})\",\n+        debug!(\"instantiate_default_methods(impl_id={}, trait_ref={})\",\n                impl_id, trait_ref.repr(tcx));\n \n         let impl_poly_type = ty::lookup_item_type(tcx, impl_id);\n@@ -256,7 +256,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n             let new_id = tcx.sess.next_node_id();\n             let new_did = local_def(new_id);\n \n-            debug!(\"new_did={:?} trait_method={}\", new_did, trait_method.repr(tcx));\n+            debug!(\"new_did={} trait_method={}\", new_did, trait_method.repr(tcx));\n \n             // Create substitutions for the various trait parameters.\n             let new_method_ty ="}, {"sha": "8e4948bbea98016feb1b10b8fee5624027f7a372", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -171,7 +171,7 @@ impl<'a, 'tcx> AstConv<'tcx> for CrateCtxt<'a, 'tcx> {\n             }\n             x => {\n                 self.tcx.sess.bug(format!(\"unexpected sort of node \\\n-                                           in get_item_ty(): {:?}\",\n+                                           in get_item_ty(): {}\",\n                                           x).as_slice());\n             }\n         }\n@@ -1421,7 +1421,7 @@ pub fn trait_def_of_item(ccx: &CrateCtxt, it: &ast::Item) -> Rc<ty::TraitDef> {\n         ref s => {\n             tcx.sess.span_bug(\n                 it.span,\n-                format!(\"trait_def_of_item invoked on {:?}\", s).as_slice());\n+                format!(\"trait_def_of_item invoked on {}\", s).as_slice());\n         }\n     };\n "}, {"sha": "9f88bec7f42257e98d64d350bc2b8dad6558d504", "filename": "src/librustc/middle/typeck/infer/coercion.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -231,7 +231,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                 self.get_ref().infcx.tcx.sess.span_bug(\n                     self.get_ref().trace.origin.span(),\n                     format!(\"failed to resolve even without \\\n-                             any force options: {:?}\", e).as_slice());\n+                             any force options: {}\", e).as_slice());\n             }\n         }\n     }\n@@ -243,7 +243,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                                    b: ty::t,\n                                    mutbl_b: ast::Mutability)\n                                    -> CoerceResult {\n-        debug!(\"coerce_borrowed_pointer(a={}, sty_a={:?}, b={})\",\n+        debug!(\"coerce_borrowed_pointer(a={}, sty_a={}, b={})\",\n                a.repr(self.get_ref().infcx.tcx), sty_a,\n                b.repr(self.get_ref().infcx.tcx));\n \n@@ -283,7 +283,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                                   b: ty::t,\n                                   mutbl_b: ast::Mutability)\n                                   -> CoerceResult {\n-        debug!(\"coerce_unsized_with_borrow(a={}, sty_a={:?}, b={})\",\n+        debug!(\"coerce_unsized_with_borrow(a={}, sty_a={}, b={})\",\n                a.repr(self.get_ref().infcx.tcx), sty_a,\n                b.repr(self.get_ref().infcx.tcx));\n \n@@ -314,7 +314,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                       sty_a: &ty::sty,\n                       b: ty::t)\n                       -> CoerceResult {\n-        debug!(\"coerce_unsized(a={}, sty_a={:?}, b={})\",\n+        debug!(\"coerce_unsized(a={}, sty_a={}, b={})\",\n                a.repr(self.get_ref().infcx.tcx), sty_a,\n                b.repr(self.get_ref().infcx.tcx));\n \n@@ -342,7 +342,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                                                  ty::mt{ty: ty, mutbl: mt_b.mutbl});\n                             try!(self.get_ref().infcx.try(|| sub.tys(ty, b)));\n                             debug!(\"Success, coerced with AutoDerefRef(1, \\\n-                                    AutoPtr(AutoUnsize({:?})))\", kind);\n+                                    AutoPtr(AutoUnsize({})))\", kind);\n                             Ok(Some(AdjustDerefRef(AutoDerefRef {\n                                 autoderefs: 1,\n                                 autoref: Some(ty::AutoPtr(r_borrow, mt_b.mutbl,\n@@ -365,7 +365,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                                                  ty::mt{ty: ty, mutbl: mt_b.mutbl});\n                             try!(self.get_ref().infcx.try(|| sub.tys(ty, b)));\n                             debug!(\"Success, coerced with AutoDerefRef(1, \\\n-                                    AutoPtr(AutoUnsize({:?})))\", kind);\n+                                    AutoPtr(AutoUnsize({})))\", kind);\n                             Ok(Some(AdjustDerefRef(AutoDerefRef {\n                                 autoderefs: 1,\n                                 autoref: Some(ty::AutoUnsafe(mt_b.mutbl,\n@@ -383,7 +383,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                             let ty = ty::mk_uniq(self.get_ref().infcx.tcx, ty);\n                             try!(self.get_ref().infcx.try(|| sub.tys(ty, b)));\n                             debug!(\"Success, coerced with AutoDerefRef(1, \\\n-                                    AutoUnsizeUniq({:?}))\", kind);\n+                                    AutoUnsizeUniq({}))\", kind);\n                             Ok(Some(AdjustDerefRef(AutoDerefRef {\n                                 autoderefs: 1,\n                                 autoref: Some(ty::AutoUnsizeUniq(kind))\n@@ -405,7 +405,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                  sty_a: &ty::sty,\n                  ty_b: ty::t)\n                  -> Option<(ty::t, ty::UnsizeKind)> {\n-        debug!(\"unsize_ty(sty_a={:?}, ty_b={})\", sty_a, ty_b.repr(self.get_ref().infcx.tcx));\n+        debug!(\"unsize_ty(sty_a={}, ty_b={})\", sty_a, ty_b.repr(self.get_ref().infcx.tcx));\n \n         let tcx = self.get_ref().infcx.tcx;\n \n@@ -485,7 +485,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n     {\n         let tcx = self.get_ref().infcx.tcx;\n \n-        debug!(\"coerce_borrowed_object(a={}, sty_a={:?}, b={}, b_mutbl={})\",\n+        debug!(\"coerce_borrowed_object(a={}, sty_a={}, b={}, b_mutbl={})\",\n                a.repr(tcx), sty_a,\n                b.repr(tcx), b_mutbl);\n \n@@ -505,7 +505,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n     {\n         let tcx = self.get_ref().infcx.tcx;\n \n-        debug!(\"coerce_unsafe_object(a={}, sty_a={:?}, b={}, b_mutbl={})\",\n+        debug!(\"coerce_unsafe_object(a={}, sty_a={}, b={}, b_mutbl={})\",\n                a.repr(tcx), sty_a,\n                b.repr(tcx), b_mutbl);\n \n@@ -557,7 +557,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                               sty_a: &ty::sty,\n                               b: ty::t)\n                               -> CoerceResult {\n-        debug!(\"coerce_borrowed_fn(a={}, sty_a={:?}, b={})\",\n+        debug!(\"coerce_borrowed_fn(a={}, sty_a={}, b={})\",\n                a.repr(self.get_ref().infcx.tcx), sty_a,\n                b.repr(self.get_ref().infcx.tcx));\n \n@@ -610,7 +610,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                              b: ty::t,\n                              mutbl_b: ast::Mutability)\n                              -> CoerceResult {\n-        debug!(\"coerce_unsafe_ptr(a={}, sty_a={:?}, b={})\",\n+        debug!(\"coerce_unsafe_ptr(a={}, sty_a={}, b={})\",\n                a.repr(self.get_ref().infcx.tcx), sty_a,\n                b.repr(self.get_ref().infcx.tcx));\n "}, {"sha": "8ae0b603e487185abe183895e288b074be30c3ec", "filename": "src/librustc/middle/typeck/infer/combine.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -390,7 +390,7 @@ pub fn super_tys<'tcx, C: Combine<'tcx>>(this: &C, a: ty::t, b: ty::t) -> cres<t\n     let tcx = this.infcx().tcx;\n     let a_sty = &ty::get(a).sty;\n     let b_sty = &ty::get(b).sty;\n-    debug!(\"super_tys: a_sty={:?} b_sty={:?}\", a_sty, b_sty);\n+    debug!(\"super_tys: a_sty={} b_sty={}\", a_sty, b_sty);\n     return match (a_sty, b_sty) {\n       // The \"subtype\" ought to be handling cases involving bot or var:\n       (&ty::ty_bot, _) |\n@@ -470,7 +470,7 @@ pub fn super_tys<'tcx, C: Combine<'tcx>>(this: &C, a: ty::t, b: ty::t) -> cres<t\n       (&ty::ty_trait(ref a_),\n        &ty::ty_trait(ref b_))\n       if a_.def_id == b_.def_id => {\n-          debug!(\"Trying to match traits {:?} and {:?}\", a, b);\n+          debug!(\"Trying to match traits {} and {}\", a, b);\n           let substs = try!(this.substs(a_.def_id, &a_.substs, &b_.substs));\n           let bounds = try!(this.existential_bounds(a_.bounds, b_.bounds));\n           Ok(ty::mk_trait(tcx,"}, {"sha": "2ab585f5ae9988b78fef4d20b3b0589098ce6052", "filename": "src/librustc/middle/typeck/infer/error_reporting.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -268,7 +268,7 @@ impl<'a, 'tcx> ErrorReporting for InferCtxt<'a, 'tcx> {\n                 }\n             }\n             let pe = ProcessedErrors(var_origins, trace_origins, same_regions);\n-            debug!(\"errors processed: {:?}\", pe);\n+            debug!(\"errors processed: {}\", pe);\n             processed_errors.push(pe);\n         }\n         return processed_errors;\n@@ -297,7 +297,7 @@ impl<'a, 'tcx> ErrorReporting for InferCtxt<'a, 'tcx> {\n                                      sub: Region,\n                                      sup: Region)\n                                      -> Option<FreeRegionsFromSameFn> {\n-            debug!(\"free_regions_from_same_fn(sub={:?}, sup={:?})\", sub, sup);\n+            debug!(\"free_regions_from_same_fn(sub={}, sup={})\", sub, sup);\n             let (scope_id, fr1, fr2) = match (sub, sup) {\n                 (ReFree(fr1), ReFree(fr2)) => {\n                     if fr1.scope_id != fr2.scope_id {"}, {"sha": "83ca67f33bc31a7a7e5a47a4af97138619b622f9", "filename": "src/librustc/middle/typeck/infer/glb.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -109,7 +109,7 @@ impl<'f, 'tcx> Combine<'tcx> for Glb<'f, 'tcx> {\n     }\n \n     fn regions(&self, a: ty::Region, b: ty::Region) -> cres<ty::Region> {\n-        debug!(\"{}.regions({:?}, {:?})\",\n+        debug!(\"{}.regions({}, {})\",\n                self.tag(),\n                a.repr(self.fields.infcx.tcx),\n                b.repr(self.fields.infcx.tcx));\n@@ -130,7 +130,7 @@ impl<'f, 'tcx> Combine<'tcx> for Glb<'f, 'tcx> {\n         // Note: this is a subtle algorithm.  For a full explanation,\n         // please see the large comment in `region_inference.rs`.\n \n-        debug!(\"{}.fn_sigs({:?}, {:?})\",\n+        debug!(\"{}.fn_sigs({}, {})\",\n                self.tag(), a.repr(self.fields.infcx.tcx), b.repr(self.fields.infcx.tcx));\n         let _indenter = indenter();\n \n@@ -254,7 +254,7 @@ impl<'f, 'tcx> Combine<'tcx> for Glb<'f, 'tcx> {\n             }\n             this.fields.infcx.tcx.sess.span_bug(\n                 this.fields.trace.origin.span(),\n-                format!(\"could not find original bound region for {:?}\",\n+                format!(\"could not find original bound region for {}\",\n                         r).as_slice())\n         }\n "}, {"sha": "24642d5213892ddb1a563f383d7278d1bf9fc18d", "filename": "src/librustc/middle/typeck/infer/lattice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -123,7 +123,7 @@ pub fn var_ids<'tcx, T: Combine<'tcx>>(this: &T,\n             r => {\n                 this.infcx().tcx.sess.span_bug(\n                     this.trace().origin.span(),\n-                    format!(\"found non-region-vid: {:?}\", r).as_slice());\n+                    format!(\"found non-region-vid: {}\", r).as_slice());\n             }\n         }).collect()\n }"}, {"sha": "f2d9203f8437b11bdf6a6a44be34e1556a20879a", "filename": "src/librustc/middle/typeck/infer/lub.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -157,7 +157,7 @@ impl<'f, 'tcx> Combine<'tcx> for Lub<'f, 'tcx> {\n             // Regions that pre-dated the LUB computation stay as they are.\n             if !is_var_in_set(new_vars, r0) {\n                 assert!(!r0.is_bound());\n-                debug!(\"generalize_region(r0={:?}): not new variable\", r0);\n+                debug!(\"generalize_region(r0={}): not new variable\", r0);\n                 return r0;\n             }\n \n@@ -167,8 +167,8 @@ impl<'f, 'tcx> Combine<'tcx> for Lub<'f, 'tcx> {\n             // *related* to regions that pre-date the LUB computation\n             // stay as they are.\n             if !tainted.iter().all(|r| is_var_in_set(new_vars, *r)) {\n-                debug!(\"generalize_region(r0={:?}): \\\n-                        non-new-variables found in {:?}\",\n+                debug!(\"generalize_region(r0={}): \\\n+                        non-new-variables found in {}\",\n                        r0, tainted);\n                 assert!(!r0.is_bound());\n                 return r0;\n@@ -181,16 +181,16 @@ impl<'f, 'tcx> Combine<'tcx> for Lub<'f, 'tcx> {\n             // with.\n             for (a_br, a_r) in a_map.iter() {\n                 if tainted.iter().any(|x| x == a_r) {\n-                    debug!(\"generalize_region(r0={:?}): \\\n-                            replacing with {:?}, tainted={:?}\",\n+                    debug!(\"generalize_region(r0={}): \\\n+                            replacing with {}, tainted={}\",\n                            r0, *a_br, tainted);\n                     return ty::ReLateBound(new_scope, *a_br);\n                 }\n             }\n \n             this.fields.infcx.tcx.sess.span_bug(\n                 this.fields.trace.origin.span(),\n-                format!(\"region {:?} is not associated with \\\n+                format!(\"region {} is not associated with \\\n                          any bound region from A!\",\n                         r0).as_slice())\n         }"}, {"sha": "7c455b85707b8fe812fe061257c4e2d1870360f7", "filename": "src/librustc/middle/typeck/infer/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -95,7 +95,7 @@ pub struct InferCtxt<'a, 'tcx: 'a> {\n /// Why did we require that the two types be related?\n ///\n /// See `error_reporting.rs` for more details\n-#[deriving(Clone)]\n+#[deriving(Clone, Show)]\n pub enum TypeOrigin {\n     // Not yet categorized in a better way\n     Misc(Span),\n@@ -127,7 +127,7 @@ pub enum TypeOrigin {\n }\n \n /// See `error_reporting.rs` for more details\n-#[deriving(Clone)]\n+#[deriving(Clone, Show)]\n pub enum ValuePairs {\n     Types(ty::expected_found<ty::t>),\n     TraitRefs(ty::expected_found<Rc<ty::TraitRef>>),\n@@ -137,7 +137,7 @@ pub enum ValuePairs {\n /// encounter an error or subtyping constraint.\n ///\n /// See `error_reporting.rs` for more details.\n-#[deriving(Clone)]\n+#[deriving(Clone, Show)]\n pub struct TypeTrace {\n     origin: TypeOrigin,\n     values: ValuePairs,\n@@ -146,7 +146,7 @@ pub struct TypeTrace {\n /// The origin of a `r1 <= r2` constraint.\n ///\n /// See `error_reporting.rs` for more details\n-#[deriving(Clone)]\n+#[deriving(Clone, Show)]\n pub enum SubregionOrigin {\n     // Arose from a subtyping relation\n     Subtype(TypeTrace),\n@@ -224,7 +224,7 @@ pub enum SubregionOrigin {\n /// Reasons to create a region inference variable\n ///\n /// See `error_reporting.rs` for more details\n-#[deriving(Clone)]\n+#[deriving(Clone, Show)]\n pub enum RegionVariableOrigin {\n     // Region variables created for ill-categorized reasons,\n     // mostly indicates places in need of refactoring\n@@ -887,7 +887,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                                                 expected_ty: Option<ty::t>,\n                                                 actual_ty: String,\n                                                 err: Option<&ty::type_err>) {\n-        debug!(\"hi! expected_ty = {:?}, actual_ty = {}\", expected_ty, actual_ty);\n+        debug!(\"hi! expected_ty = {}, actual_ty = {}\", expected_ty, actual_ty);\n \n         let error_str = err.map_or(\"\".to_string(), |t_err| {\n             format!(\" ({})\", ty::type_err_to_str(self.tcx, t_err))\n@@ -965,7 +965,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             replace_late_bound_regions_in_fn_sig(self.tcx, fsig, |br| {\n                 let rvar = self.next_region_var(\n                     BoundRegionInFnType(trace.origin.span(), br));\n-                debug!(\"Bound region {} maps to {:?}\",\n+                debug!(\"Bound region {} maps to {}\",\n                        bound_region_to_string(self.tcx, \"\", false, br),\n                        rvar);\n                 rvar\n@@ -1120,7 +1120,7 @@ impl Repr for SubregionOrigin {\n             }\n             Reborrow(a) => format!(\"Reborrow({})\", a.repr(tcx)),\n             ReborrowUpvar(a, b) => {\n-                format!(\"ReborrowUpvar({},{:?})\", a.repr(tcx), b)\n+                format!(\"ReborrowUpvar({},{})\", a.repr(tcx), b)\n             }\n             ReferenceOutlivesReferent(_, a) => {\n                 format!(\"ReferenceOutlivesReferent({})\", a.repr(tcx))"}, {"sha": "504550f0d40d2fc5b80efe1ea7755d7f2aaaaa19", "filename": "src/librustc/middle/typeck/infer/region_inference/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -81,7 +81,7 @@ pub enum CombineMapType {\n     Lub, Glb\n }\n \n-#[deriving(Clone)]\n+#[deriving(Clone, Show)]\n pub enum RegionResolutionError {\n     /// `ConcreteFailure(o, a, b)`:\n     ///\n@@ -133,7 +133,7 @@ pub enum RegionResolutionError {\n /// ```\n /// would report an error because we expect 'a and 'b to match, and so we group\n /// 'a and 'b together inside a SameRegions struct\n-#[deriving(Clone)]\n+#[deriving(Clone, Show)]\n pub struct SameRegions {\n     pub scope_id: ast::NodeId,\n     pub regions: Vec<BoundRegion>"}, {"sha": "158fda802ff002e79a4d550607ea7e16a71cf576", "filename": "src/librustc/middle/typeck/infer/sub.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -200,7 +200,7 @@ impl<'f, 'tcx> Combine<'tcx> for Sub<'f, 'tcx> {\n         let (skol_map, b_sig) = {\n             replace_late_bound_regions_in_fn_sig(self.fields.infcx.tcx, b, |br| {\n                 let skol = self.fields.infcx.region_vars.new_skolemized(br);\n-                debug!(\"Bound region {} skolemized to {:?}\",\n+                debug!(\"Bound region {} skolemized to {}\",\n                        bound_region_to_string(self.fields.infcx.tcx, \"\", false, br),\n                        skol);\n                 skol"}, {"sha": "baa4f6d013bd24fe437f284e633559d5374ff425", "filename": "src/librustc/middle/typeck/infer/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -315,7 +315,7 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n     pub fn make_lub_ty(&self, t1: ty::t, t2: ty::t) -> ty::t {\n         match self.lub().tys(t1, t2) {\n             Ok(t) => t,\n-            Err(ref e) => fail!(\"unexpected error computing LUB: {:?}\",\n+            Err(ref e) => fail!(\"unexpected error computing LUB: {}\",\n                                 ty::type_err_to_str(self.infcx.tcx, e))\n         }\n     }\n@@ -341,7 +341,7 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n                self.ty_to_string(t_glb));\n         match self.glb().tys(t1, t2) {\n             Err(e) => {\n-                fail!(\"unexpected error computing LUB: {:?}\", e)\n+                fail!(\"unexpected error computing LUB: {}\", e)\n             }\n             Ok(t) => {\n                 self.assert_eq(t, t_glb);"}, {"sha": "5a23d54c9720b60766dbe0e6d00c4bec7b258097", "filename": "src/librustc/middle/typeck/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -87,13 +87,13 @@ pub mod collect;\n pub mod coherence;\n pub mod variance;\n \n-#[deriving(Clone, Encodable, Decodable, PartialEq, PartialOrd)]\n+#[deriving(Clone, Encodable, Decodable, PartialEq, PartialOrd, Show)]\n pub struct param_index {\n     pub space: subst::ParamSpace,\n     pub index: uint\n }\n \n-#[deriving(Clone)]\n+#[deriving(Clone, Show)]\n pub enum MethodOrigin {\n     // fully statically resolved method\n     MethodStatic(ast::DefId),\n@@ -111,7 +111,7 @@ pub enum MethodOrigin {\n \n // details for a method invoked with a receiver whose type is a type parameter\n // with a bounded trait.\n-#[deriving(Clone)]\n+#[deriving(Clone, Show)]\n pub struct MethodParam {\n     // the precise trait reference that occurs as a bound -- this may\n     // be a supertrait of what the user actually typed.\n@@ -122,7 +122,7 @@ pub struct MethodParam {\n }\n \n // details for a method invoked with a receiver whose type is an object\n-#[deriving(Clone)]\n+#[deriving(Clone, Show)]\n pub struct MethodObject {\n     // the (super)trait containing the method to be invoked\n     pub trait_ref: Rc<ty::TraitRef>,\n@@ -249,15 +249,15 @@ impl Repr for vtable_origin {\n     fn repr(&self, tcx: &ty::ctxt) -> String {\n         match *self {\n             vtable_static(def_id, ref tys, ref vtable_res) => {\n-                format!(\"vtable_static({:?}:{}, {}, {})\",\n+                format!(\"vtable_static({}:{}, {}, {})\",\n                         def_id,\n                         ty::item_path_str(tcx, def_id),\n                         tys.repr(tcx),\n                         vtable_res.repr(tcx))\n             }\n \n             vtable_param(x, y) => {\n-                format!(\"vtable_param({:?}, {:?})\", x, y)\n+                format!(\"vtable_param({}, {})\", x, y)\n             }\n \n             vtable_unboxed_closure(def_id) => {"}, {"sha": "dd6e087b6727a04d9253698357ec3c459fbdcda5", "filename": "src/librustc/middle/typeck/variance.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -232,6 +232,7 @@ pub fn infer_variance(tcx: &ty::ctxt) {\n \n type VarianceTermPtr<'a> = &'a VarianceTerm<'a>;\n \n+#[deriving(Show)]\n struct InferredIndex(uint);\n \n enum VarianceTerm<'a> {\n@@ -325,10 +326,10 @@ impl<'a, 'tcx> TermsContext<'a, 'tcx> {\n         assert!(newly_added);\n \n         debug!(\"add_inferred(item_id={}, \\\n-                kind={:?}, \\\n+                kind={}, \\\n                 index={}, \\\n                 param_id={},\n-                inf_index={:?})\",\n+                inf_index={})\",\n                 item_id, kind, index, param_id, inf_index);\n     }\n \n@@ -852,7 +853,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                                    region_param_defs: &[ty::RegionParameterDef],\n                                    substs: &subst::Substs,\n                                    variance: VarianceTermPtr<'a>) {\n-        debug!(\"add_constraints_from_substs(def_id={:?})\", def_id);\n+        debug!(\"add_constraints_from_substs(def_id={})\", def_id);\n \n         for p in type_param_defs.iter() {\n             let variance_decl ="}, {"sha": "082dde978d8e7068d66745f9f71532a5573aba54", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -13,6 +13,7 @@\n use std::cell::RefCell;\n use std::collections::HashMap;\n use std::hash::{Hash, Hasher};\n+use std::fmt::Show;\n use syntax::ast;\n use syntax::visit;\n use syntax::visit::Visitor;\n@@ -36,12 +37,12 @@ pub fn time<T, U>(do_it: bool, what: &str, u: U, f: |U| -> T) -> T {\n     rv\n }\n \n-pub fn indent<R>(op: || -> R) -> R {\n+pub fn indent<R: Show>(op: || -> R) -> R {\n     // Use in conjunction with the log post-processor like `src/etc/indenter`\n     // to make debug output more readable.\n     debug!(\">>\");\n     let r = op();\n-    debug!(\"<< (Result = {:?})\", r);\n+    debug!(\"<< (Result = {})\", r);\n     r\n }\n "}, {"sha": "404864cec04e4968a45a64b2e8203907d938e730", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -154,7 +154,7 @@ pub fn explain_region_and_span(cx: &ctxt, region: ty::Region)\n       // I believe these cases should not occur (except when debugging,\n       // perhaps)\n       ty::ReInfer(_) | ty::ReLateBound(..) => {\n-        (format!(\"lifetime {:?}\", region), None)\n+        (format!(\"lifetime {}\", region), None)\n       }\n     };\n \n@@ -599,7 +599,7 @@ impl<T:UserString> UserString for Vec<T> {\n \n impl Repr for def::Def {\n     fn repr(&self, _tcx: &ctxt) -> String {\n-        format!(\"{:?}\", *self)\n+        format!(\"{}\", *self)\n     }\n }\n \n@@ -843,14 +843,14 @@ impl Repr for ast::DefId {\n                 Some(ast_map::NodeVariant(..)) |\n                 Some(ast_map::NodeStructCtor(..)) => {\n                     return format!(\n-                                \"{:?}:{}\",\n+                                \"{}:{}\",\n                                 *self,\n                                 ty::item_path_str(tcx, *self))\n                 }\n                 _ => {}\n             }\n         }\n-        return format!(\"{:?}\", *self)\n+        return format!(\"{}\", *self)\n     }\n }\n \n@@ -922,19 +922,19 @@ impl Repr for ast::Ident {\n \n impl Repr for ast::ExplicitSelf_ {\n     fn repr(&self, _tcx: &ctxt) -> String {\n-        format!(\"{:?}\", *self)\n+        format!(\"{}\", *self)\n     }\n }\n \n impl Repr for ast::Visibility {\n     fn repr(&self, _tcx: &ctxt) -> String {\n-        format!(\"{:?}\", *self)\n+        format!(\"{}\", *self)\n     }\n }\n \n impl Repr for ty::BareFnTy {\n     fn repr(&self, tcx: &ctxt) -> String {\n-        format!(\"BareFnTy {{fn_style: {:?}, abi: {}, sig: {}}}\",\n+        format!(\"BareFnTy {{fn_style: {}, abi: {}, sig: {}}}\",\n                 self.fn_style,\n                 self.abi.to_string(),\n                 self.sig.repr(tcx))\n@@ -985,7 +985,7 @@ impl Repr for typeck::MethodParam {\n \n impl Repr for typeck::MethodObject {\n     fn repr(&self, tcx: &ctxt) -> String {\n-        format!(\"MethodObject({},{:?},{:?})\",\n+        format!(\"MethodObject({},{},{})\",\n                 self.trait_ref.repr(tcx),\n                 self.method_num,\n                 self.real_index)\n@@ -1000,7 +1000,7 @@ impl Repr for ty::TraitStore {\n \n impl Repr for ty::BuiltinBound {\n     fn repr(&self, _tcx: &ctxt) -> String {\n-        format!(\"{:?}\", *self)\n+        format!(\"{}\", *self)\n     }\n }\n \n@@ -1118,13 +1118,13 @@ impl Repr for ty::UpvarId {\n \n impl Repr for ast::Mutability {\n     fn repr(&self, _tcx: &ctxt) -> String {\n-        format!(\"{:?}\", *self)\n+        format!(\"{}\", *self)\n     }\n }\n \n impl Repr for ty::BorrowKind {\n     fn repr(&self, _tcx: &ctxt) -> String {\n-        format!(\"{:?}\", *self)\n+        format!(\"{}\", *self)\n     }\n }\n \n@@ -1162,25 +1162,25 @@ impl Repr for ty::TyVid {\n \n impl Repr for ty::IntVarValue {\n     fn repr(&self, _tcx: &ctxt) -> String {\n-        format!(\"{:?}\", *self)\n+        format!(\"{}\", *self)\n     }\n }\n \n impl Repr for ast::IntTy {\n     fn repr(&self, _tcx: &ctxt) -> String {\n-        format!(\"{:?}\", *self)\n+        format!(\"{}\", *self)\n     }\n }\n \n impl Repr for ast::UintTy {\n     fn repr(&self, _tcx: &ctxt) -> String {\n-        format!(\"{:?}\", *self)\n+        format!(\"{}\", *self)\n     }\n }\n \n impl Repr for ast::FloatTy {\n     fn repr(&self, _tcx: &ctxt) -> String {\n-        format!(\"{:?}\", *self)\n+        format!(\"{}\", *self)\n     }\n }\n "}, {"sha": "aa07b9a5034c7b99f355de1cbe0f64fc79dd9217", "filename": "src/librustc_back/abi.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrustc_back%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrustc_back%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Fabi.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -14,8 +14,6 @@ pub const box_field_refcnt: uint = 0u;\n pub const box_field_drop_glue: uint = 1u;\n pub const box_field_body: uint = 4u;\n \n-pub const tydesc_field_visit_glue: uint = 3u;\n-\n // The two halves of a closure: code and environment.\n pub const fn_field_code: uint = 0u;\n pub const fn_field_box: uint = 1u;"}, {"sha": "102ba5820fe2fd01279b1146d6a9d92bab9b3d66", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -1251,7 +1251,7 @@ impl Clean<Type> for ast::Ty {\n             TyBareFn(ref barefn) => BareFunction(box barefn.clean(cx)),\n             TyParen(ref ty) => ty.clean(cx),\n             TyBot => Bottom,\n-            ref x => fail!(\"Unimplemented type {:?}\", x),\n+            ref x => fail!(\"Unimplemented type {}\", x),\n         }\n     }\n }\n@@ -1575,7 +1575,7 @@ impl Clean<VariantKind> for ast::VariantKind {\n     }\n }\n \n-#[deriving(Clone, Encodable, Decodable)]\n+#[deriving(Clone, Encodable, Decodable, Show)]\n pub struct Span {\n     pub filename: String,\n     pub loline: uint,\n@@ -1714,7 +1714,7 @@ impl Clean<BareFunctionDecl> for ast::BareFnTy {\n     }\n }\n \n-#[deriving(Clone, Encodable, Decodable)]\n+#[deriving(Clone, Encodable, Decodable, Show)]\n pub struct Static {\n     pub type_: Type,\n     pub mutability: Mutability,\n@@ -1726,7 +1726,7 @@ pub struct Static {\n \n impl Clean<Item> for doctree::Static {\n     fn clean(&self, cx: &DocContext) -> Item {\n-        debug!(\"claning static {}: {:?}\", self.name.clean(cx), self);\n+        debug!(\"claning static {}: {}\", self.name.clean(cx), self);\n         Item {\n             name: Some(self.name.clean(cx)),\n             attrs: self.attrs.clean(cx),\n@@ -2004,7 +2004,7 @@ trait ToSource {\n \n impl ToSource for syntax::codemap::Span {\n     fn to_src(&self, cx: &DocContext) -> String {\n-        debug!(\"converting span {:?} to snippet\", self.clean(cx));\n+        debug!(\"converting span {} to snippet\", self.clean(cx));\n         let sn = match cx.sess().codemap().span_to_snippet(*self) {\n             Some(x) => x.to_string(),\n             None    => \"\".to_string()\n@@ -2017,7 +2017,7 @@ impl ToSource for syntax::codemap::Span {\n fn lit_to_string(lit: &ast::Lit) -> String {\n     match lit.node {\n         ast::LitStr(ref st, _) => st.get().to_string(),\n-        ast::LitBinary(ref data) => format!(\"{:?}\", data.as_slice()),\n+        ast::LitBinary(ref data) => format!(\"{}\", data),\n         ast::LitByte(b) => {\n             let mut res = String::from_str(\"b'\");\n             (b as char).escape_default(|c| {\n@@ -2037,7 +2037,7 @@ fn lit_to_string(lit: &ast::Lit) -> String {\n \n fn name_from_pat(p: &ast::Pat) -> String {\n     use syntax::ast::*;\n-    debug!(\"Trying to get a name from pattern: {:?}\", p);\n+    debug!(\"Trying to get a name from pattern: {}\", p);\n \n     match p.node {\n         PatWild(PatWildSingle) => \"_\".to_string(),\n@@ -2082,7 +2082,7 @@ fn resolve_type(cx: &DocContext, path: Path,\n         // If we're extracting tests, this return value doesn't matter.\n         None => return Primitive(Bool),\n     };\n-    debug!(\"searching for {:?} in defmap\", id);\n+    debug!(\"searching for {} in defmap\", id);\n     let def = match tcx.def_map.borrow().find(&id) {\n         Some(&k) => k,\n         None => fail!(\"unresolved id not in defmap\")"}, {"sha": "c5c9aae89e476558fe9f56a2a8233eaeaf40fce6", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -135,7 +135,7 @@ pub fn run_core(libs: Vec<Path>, cfgs: Vec<String>, externs: Externs,\n         inlined: RefCell::new(Some(HashSet::new())),\n         populated_crate_impls: RefCell::new(HashSet::new()),\n     };\n-    debug!(\"crate: {:?}\", ctxt.krate);\n+    debug!(\"crate: {}\", ctxt.krate);\n \n     let analysis = CrateAnalysis {\n         exported_items: exported_items,"}, {"sha": "7509f96f9167507923d45ee68d8ae5ae9d3cae62", "filename": "src/librustdoc/doctree.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrustdoc%2Fdoctree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrustdoc%2Fdoctree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoctree.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -141,6 +141,7 @@ pub struct Typedef {\n     pub stab: Option<attr::Stability>,\n }\n \n+#[deriving(Show)]\n pub struct Static {\n     pub type_: P<ast::Ty>,\n     pub mutability: ast::Mutability,"}, {"sha": "b4bf1668d941fb6b0dd9f4fc5888750f0b65d54e", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -1042,7 +1042,7 @@ impl Context {\n     /// sure it always points to the top (relatively)\n     fn recurse<T>(&mut self, s: String, f: |&mut Context| -> T) -> T {\n         if s.len() == 0 {\n-            fail!(\"what {:?}\", self);\n+            fail!(\"Unexpected empty destination: {}\", self.current);\n         }\n         let prev = self.dst.clone();\n         self.dst.push(s.as_slice());\n@@ -1491,7 +1491,7 @@ fn item_module(w: &mut fmt::Formatter, cx: &Context,\n \n     indices.sort_by(|&i1, &i2| cmp(&items[i1], &items[i2], i1, i2));\n \n-    debug!(\"{:?}\", indices);\n+    debug!(\"{}\", indices);\n     let mut curty = None;\n     for &idx in indices.iter() {\n         let myitem = &items[idx];"}, {"sha": "ad79faebd45c5635d33ba3a7f4b4385ee90e203c", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -19,7 +19,6 @@\n #![feature(globs, struct_variant, macro_rules, phase, slicing_syntax)]\n \n extern crate arena;\n-extern crate debug;\n extern crate getopts;\n extern crate libc;\n extern crate rustc;\n@@ -334,7 +333,7 @@ fn rust_input(cratefile: &str, externs: core::Externs, matches: &getopts::Matche\n     let (mut krate, analysis) = std::task::try(proc() {\n         let cr = cr;\n         core::run_core(libs, cfgs, externs, &cr, triple)\n-    }).map_err(|boxed_any|format!(\"{:?}\", boxed_any)).unwrap();\n+    }).map_err(|_| \"rustc failed\").unwrap();\n     info!(\"finished with rustc\");\n     analysiskey.replace(Some(analysis));\n \n@@ -481,7 +480,7 @@ fn json_output(krate: clean::Crate, res: Vec<plugins::PluginJson> ,\n     };\n     let crate_json = match json::from_str(crate_json_str.as_slice()) {\n         Ok(j) => j,\n-        Err(e) => fail!(\"Rust generated JSON is invalid: {:?}\", e)\n+        Err(e) => fail!(\"Rust generated JSON is invalid: {}\", e)\n     };\n \n     json.insert(\"crate\".to_string(), crate_json);"}, {"sha": "8e377037a9713e42db97f5aab17e0bff32456ca4", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -264,7 +264,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n \n     pub fn visit_item(&mut self, item: &ast::Item,\n                       renamed: Option<ast::Ident>, om: &mut Module) {\n-        debug!(\"Visiting item {:?}\", item);\n+        debug!(\"Visiting item {}\", item);\n         let name = renamed.unwrap_or(item.ident);\n         match item.node {\n             ast::ItemMod(ref m) => {"}, {"sha": "a08bc6976025dc16dbdaf384ded57813b27ffdeb", "filename": "src/librustrt/rtio.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrustrt%2Frtio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibrustrt%2Frtio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Frtio.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -356,6 +356,7 @@ pub trait PausableIdleCallback {\n \n pub trait RtioSignal {}\n \n+#[deriving(Show)]\n pub struct IoError {\n     pub code: uint,\n     pub extra: uint,"}, {"sha": "ed8ff821f5cad67ffb9fe8cf8d4676de555b1019", "filename": "src/libstd/dynamic_lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibstd%2Fdynamic_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibstd%2Fdynamic_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fdynamic_lib.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -183,7 +183,7 @@ mod test {\n         let expected_result = 1.0;\n         let result = cosine(argument);\n         if result != expected_result {\n-            fail!(\"cos({:?}) != {:?} but equaled {:?} instead\", argument,\n+            fail!(\"cos({}) != {} but equaled {} instead\", argument,\n                    expected_result, result)\n         }\n     }"}, {"sha": "27451c91f3f5e18f93378f20e4f2165b9dd0af2a", "filename": "src/libstd/fmt.rs", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibstd%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibstd%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffmt.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -36,12 +36,11 @@ format arguments directly while performing minimal allocations.\n Some examples of the `format!` extension are:\n \n ```rust\n-# extern crate debug;\n # fn main() {\n format!(\"Hello\");                  // => \"Hello\"\n format!(\"Hello, {:s}!\", \"world\");  // => \"Hello, world!\"\n format!(\"The number is {:d}\", 1i); // => \"The number is 1\"\n-format!(\"{:?}\", (3i, 4i));         // => \"(3, 4)\"\n+format!(\"{}\", (3i, 4i));           // => \"(3, 4)\"\n format!(\"{value}\", value=4i);      // => \"4\"\n format!(\"{} {}\", 1i, 2i);          // => \"1 2\"\n # }\n@@ -94,11 +93,10 @@ identifier '=' expression\n For example, the following `format!` expressions all use named argument:\n \n ```rust\n-# extern crate debug;\n # fn main() {\n format!(\"{argument}\", argument = \"test\");        // => \"test\"\n format!(\"{name} {}\", 1i, name = 2i);             // => \"2 1\"\n-format!(\"{a:s} {c:d} {b:?}\", a=\"a\", b=(), c=3i); // => \"a 3 ()\"\n+format!(\"{a:s} {c:d} {b}\", a=\"a\", b=(), c=3i); // => \"a 3 ()\"\n # }\n ```\n \n@@ -154,11 +152,6 @@ The current mapping of types to traits is:\n * `f` \u21d2 `Float`\n * `e` \u21d2 `LowerExp`\n * `E` \u21d2 `UpperExp`\n-* `?` \u21d2 `Poly`\n-\n-> **Note**: The `Poly` formatting trait is provided by [libdebug](../../debug/)\n-> and is an experimental implementation that should not be relied upon. In order\n-> to use the `?` modifier, the libdebug crate must be linked against.\n \n What this means is that any type of argument which implements the\n `std::fmt::Binary` trait can then be formatted with `{:t}`. Implementations are"}, {"sha": "8632fc63e52f87d79865dfe8c01cee79a51d691c", "filename": "src/libstd/io/fs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibstd%2Fio%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibstd%2Fio%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ffs.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -963,7 +963,7 @@ mod test {\n \n     macro_rules! error( ($e:expr, $s:expr) => (\n         match $e {\n-            Ok(val) => fail!(\"Should have been an error, was {:?}\", val),\n+            Ok(val) => fail!(\"Unexpected success. Should've been: {}\", $s),\n             Err(ref err) => assert!(err.to_string().as_slice().contains($s.as_slice()),\n                                     format!(\"`{}` did not contain `{}`\", err, $s))\n         }"}, {"sha": "e0cf761fdbd7e7bde3bd436796b1e77a7b47346c", "filename": "src/libstd/io/net/pipe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibstd%2Fio%2Fnet%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibstd%2Fio%2Fnet%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Fpipe.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -340,7 +340,7 @@ mod tests {\n                         assert!(e.kind == BrokenPipe ||\n                                 e.kind == NotConnected ||\n                                 e.kind == ConnectionReset,\n-                                \"unknown error {:?}\", e);\n+                                \"unknown error {}\", e);\n                         break;\n                     }\n                 }"}, {"sha": "82c8d8071b34bbaf009f68dd58e448035f6e8dae", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -118,7 +118,6 @@\n #![reexport_test_harness_main = \"test_main\"]\n \n #[cfg(test)] extern crate green;\n-#[cfg(test)] extern crate debug;\n #[cfg(test)] #[phase(plugin, link)] extern crate log;\n \n extern crate alloc;"}, {"sha": "e758dec6bff9485a2aadf63d2b3449247d166619", "filename": "src/libstd/os.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -1975,7 +1975,7 @@ mod tests {\n         let path = os::self_exe_name();\n         assert!(path.is_some());\n         let path = path.unwrap();\n-        debug!(\"{:?}\", path.clone());\n+        debug!(\"{}\", path.display());\n \n         // Hard to test this function\n         assert!(path.is_absolute());\n@@ -1986,7 +1986,7 @@ mod tests {\n         let path = os::self_exe_path();\n         assert!(path.is_some());\n         let path = path.unwrap();\n-        debug!(\"{:?}\", path.clone());\n+        debug!(\"{}\", path.display());\n \n         // Hard to test this function\n         assert!(path.is_absolute());\n@@ -1999,7 +1999,7 @@ mod tests {\n         assert!(e.len() > 0u);\n         for p in e.iter() {\n             let (n, v) = (*p).clone();\n-            debug!(\"{:?}\", n.clone());\n+            debug!(\"{}\", n);\n             let v2 = getenv(n.as_slice());\n             // MingW seems to set some funky environment variables like\n             // \"=C:=C:\\MinGW\\msys\\1.0\\bin\" and \"!::=::\\\" that are returned\n@@ -2037,8 +2037,8 @@ mod tests {\n         let cwd = getcwd();\n         debug!(\"Current working directory: {}\", cwd.display());\n \n-        debug!(\"{:?}\", make_absolute(&Path::new(\"test-path\")));\n-        debug!(\"{:?}\", make_absolute(&Path::new(\"/usr/bin\")));\n+        debug!(\"{}\", make_absolute(&Path::new(\"test-path\")).display());\n+        debug!(\"{}\", make_absolute(&Path::new(\"/usr/bin\")).display());\n     }\n \n     #[test]"}, {"sha": "69b6dd76676168a3bf4a3b1787b1e4b658190fbb", "filename": "src/libstd/path/posix.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibstd%2Fpath%2Fposix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibstd%2Fpath%2Fposix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fposix.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -986,19 +986,19 @@ mod tests {\n                         let path = $path;\n                         let filename = $filename;\n                         assert!(path.filename_str() == filename,\n-                                \"{}.filename_str(): Expected `{:?}`, found {:?}\",\n+                                \"{}.filename_str(): Expected `{}`, found {}\",\n                                 path.as_str().unwrap(), filename, path.filename_str());\n                         let dirname = $dirname;\n                         assert!(path.dirname_str() == dirname,\n-                                \"`{}`.dirname_str(): Expected `{:?}`, found `{:?}`\",\n+                                \"`{}`.dirname_str(): Expected `{}`, found `{}`\",\n                                 path.as_str().unwrap(), dirname, path.dirname_str());\n                         let filestem = $filestem;\n                         assert!(path.filestem_str() == filestem,\n-                                \"`{}`.filestem_str(): Expected `{:?}`, found `{:?}`\",\n+                                \"`{}`.filestem_str(): Expected `{}`, found `{}`\",\n                                 path.as_str().unwrap(), filestem, path.filestem_str());\n                         let ext = $ext;\n                         assert!(path.extension_str() == mem::transmute(ext),\n-                                \"`{}`.extension_str(): Expected `{:?}`, found `{:?}`\",\n+                                \"`{}`.extension_str(): Expected `{}`, found `{}`\",\n                                 path.as_str().unwrap(), ext, path.extension_str());\n                     }\n                 }\n@@ -1200,11 +1200,11 @@ mod tests {\n                     let comps = path.components().collect::<Vec<&[u8]>>();\n                     let exp: &[&str] = $exp;\n                     let exps = exp.iter().map(|x| x.as_bytes()).collect::<Vec<&[u8]>>();\n-                    assert!(comps == exps, \"components: Expected {:?}, found {:?}\",\n+                    assert!(comps == exps, \"components: Expected {}, found {}\",\n                             comps, exps);\n                     let comps = path.components().rev().collect::<Vec<&[u8]>>();\n                     let exps = exps.into_iter().rev().collect::<Vec<&[u8]>>();\n-                    assert!(comps == exps, \"rev_components: Expected {:?}, found {:?}\",\n+                    assert!(comps == exps, \"rev_components: Expected {}, found {}\",\n                             comps, exps);\n                 }\n             );"}, {"sha": "4456cf96094285dd89297676e0b2638f856e7e23", "filename": "src/libstd/path/windows.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibstd%2Fpath%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibstd%2Fpath%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fwindows.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -996,7 +996,7 @@ pub fn is_sep_byte_verbatim(u: &u8) -> bool {\n }\n \n /// Prefix types for Path\n-#[deriving(PartialEq, Clone)]\n+#[deriving(PartialEq, Clone, Show)]\n pub enum PathPrefix {\n     /// Prefix `\\\\?\\`, uint is the length of the following component\n     VerbatimPrefix(uint),\n@@ -1172,7 +1172,7 @@ mod tests {\n                     let exp = $exp;\n                     let res = parse_prefix(path);\n                     assert!(res == exp,\n-                            \"parse_prefix(\\\"{}\\\"): expected {:?}, found {:?}\", path, exp, res);\n+                            \"parse_prefix(\\\"{}\\\"): expected {}, found {}\", path, exp, res);\n                 }\n             )\n         )\n@@ -1904,19 +1904,19 @@ mod tests {\n                         let path = $path;\n                         let filename = $filename;\n                         assert!(path.filename_str() == filename,\n-                                \"`{}`.filename_str(): Expected `{:?}`, found `{:?}`\",\n+                                \"`{}`.filename_str(): Expected `{}`, found `{}`\",\n                                 path.as_str().unwrap(), filename, path.filename_str());\n                         let dirname = $dirname;\n                         assert!(path.dirname_str() == dirname,\n-                                \"`{}`.dirname_str(): Expected `{:?}`, found `{:?}`\",\n+                                \"`{}`.dirname_str(): Expected `{}`, found `{}`\",\n                                 path.as_str().unwrap(), dirname, path.dirname_str());\n                         let filestem = $filestem;\n                         assert!(path.filestem_str() == filestem,\n-                                \"`{}`.filestem_str(): Expected `{:?}`, found `{:?}`\",\n+                                \"`{}`.filestem_str(): Expected `{}`, found `{}`\",\n                                 path.as_str().unwrap(), filestem, path.filestem_str());\n                         let ext = $ext;\n                         assert!(path.extension_str() == mem::transmute(ext),\n-                                \"`{}`.extension_str(): Expected `{:?}`, found `{:?}`\",\n+                                \"`{}`.extension_str(): Expected `{}`, found `{}`\",\n                                 path.as_str().unwrap(), ext, path.extension_str());\n                     }\n                 }\n@@ -1974,16 +1974,16 @@ mod tests {\n                     let path = Path::new($path);\n                     let (abs, vol, cwd, rel) = ($abs, $vol, $cwd, $rel);\n                     let b = path.is_absolute();\n-                    assert!(b == abs, \"Path '{}'.is_absolute(): expected {:?}, found {:?}\",\n+                    assert!(b == abs, \"Path '{}'.is_absolute(): expected {}, found {}\",\n                             path.as_str().unwrap(), abs, b);\n                     let b = is_vol_relative(&path);\n-                    assert!(b == vol, \"is_vol_relative('{}'): expected {:?}, found {:?}\",\n+                    assert!(b == vol, \"is_vol_relative('{}'): expected {}, found {}\",\n                             path.as_str().unwrap(), vol, b);\n                     let b = is_cwd_relative(&path);\n-                    assert!(b == cwd, \"is_cwd_relative('{}'): expected {:?}, found {:?}\",\n+                    assert!(b == cwd, \"is_cwd_relative('{}'): expected {}, found {}\",\n                             path.as_str().unwrap(), cwd, b);\n                     let b = path.is_relative();\n-                    assert!(b == rel, \"Path '{}'.is_relativf(): expected {:?}, found {:?}\",\n+                    assert!(b == rel, \"Path '{}'.is_relativf(): expected {}, found {}\",\n                             path.as_str().unwrap(), rel, b);\n                 }\n             )\n@@ -2016,7 +2016,7 @@ mod tests {\n                     let exp = $exp;\n                     let res = path.is_ancestor_of(&dest);\n                     assert!(res == exp,\n-                            \"`{}`.is_ancestor_of(`{}`): Expected {:?}, found {:?}\",\n+                            \"`{}`.is_ancestor_of(`{}`): Expected {}, found {}\",\n                             path.as_str().unwrap(), dest.as_str().unwrap(), exp, res);\n                 }\n             )\n@@ -2151,7 +2151,7 @@ mod tests {\n                     let res = path.path_relative_from(&other);\n                     let exp = $exp;\n                     assert!(res.as_ref().and_then(|x| x.as_str()) == exp,\n-                            \"`{}`.path_relative_from(`{}`): Expected {:?}, got {:?}\",\n+                            \"`{}`.path_relative_from(`{}`): Expected {}, got {}\",\n                             path.as_str().unwrap(), other.as_str().unwrap(), exp,\n                             res.as_ref().and_then(|x| x.as_str()));\n                 }"}, {"sha": "df63d161eec35bc77b1dc5516ee9ba569ddb29fa", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -81,7 +81,7 @@ impl PartialEq for Ident {\n             // one example and its non-hygienic counterpart would be:\n             //      syntax::parse::token::mtwt_token_eq\n             //      syntax::ext::tt::macro_parser::token_name_eq\n-            fail!(\"not allowed to compare these idents: {:?}, {:?}. \\\n+            fail!(\"not allowed to compare these idents: {}, {}. \\\n                    Probably related to issue \\\\#6993\", self, other);\n         }\n     }"}, {"sha": "fb5373cee00403c84babe4c7138fba7112a548df", "filename": "src/libsyntax/ast_map/mod.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibsyntax%2Fast_map%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibsyntax%2Fast_map%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map%2Fmod.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -96,6 +96,7 @@ pub fn path_to_string<PI: Iterator<PathElem>>(mut path: PI) -> String {\n     }).to_string()\n }\n \n+#[deriving(Show)]\n pub enum Node<'ast> {\n     NodeItem(&'ast Item),\n     NodeForeignItem(&'ast ForeignItem),\n@@ -387,7 +388,7 @@ impl<'ast> Map<'ast> {\n                                 PathName(ident.name)\n                             }\n                             MethMac(_) => {\n-                                fail!(\"no path elem for {:?}\", node)\n+                                fail!(\"no path elem for {}\", node)\n                             }\n                         }\n                     }\n@@ -401,13 +402,13 @@ impl<'ast> Map<'ast> {\n                         MethDecl(ident, _, _, _, _, _, _, _) => {\n                             PathName(ident.name)\n                         }\n-                        MethMac(_) => fail!(\"no path elem for {:?}\", node),\n+                        MethMac(_) => fail!(\"no path elem for {}\", node),\n                     }\n                 }\n                 TypeTraitItem(ref m) => PathName(m.ident.name),\n             },\n             NodeVariant(v) => PathName(v.node.name.name),\n-            _ => fail!(\"no path elem for {:?}\", node)\n+            _ => fail!(\"no path elem for {}\", node)\n         }\n     }\n "}, {"sha": "726aceb5819b6640aaa81c131815013a94ca9eed", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -308,7 +308,7 @@ pub fn empty_generics() -> Generics {\n // ______________________________________________________________________\n // Enumerating the IDs which appear in an AST\n \n-#[deriving(Encodable, Decodable)]\n+#[deriving(Encodable, Decodable, Show)]\n pub struct IdRange {\n     pub min: NodeId,\n     pub max: NodeId,"}, {"sha": "c792d4b99eefbcc524bb640fbf21afec66bab4c2", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -1700,11 +1700,11 @@ foo_module!()\n         }).enumerate() {\n             if mtwt::resolve(v.segments.get(0).identifier) != resolved_binding {\n                 println!(\"uh oh, xx binding didn't match xx varref:\");\n-                println!(\"this is xx varref \\\\# {:?}\",idx);\n-                println!(\"binding: {:?}\",cxbind);\n-                println!(\"resolves to: {:?}\",resolved_binding);\n-                println!(\"varref: {:?}\",v.segments.get(0).identifier);\n-                println!(\"resolves to: {:?}\",\n+                println!(\"this is xx varref \\\\# {}\", idx);\n+                println!(\"binding: {}\", cxbind);\n+                println!(\"resolves to: {}\", resolved_binding);\n+                println!(\"varref: {}\", v.segments.get(0).identifier);\n+                println!(\"resolves to: {}\",\n                          mtwt::resolve(v.segments.get(0).identifier));\n                 mtwt::with_sctable(|x| mtwt::display_sctable(x));\n             }"}, {"sha": "07f0ca85f3560a020ba2ba95fdba69996fc20cf4", "filename": "src/libsyntax/ext/format.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibsyntax%2Fext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibsyntax%2Fext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fformat.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -668,7 +668,6 @@ impl<'a, 'b> Context<'a, 'b> {\n             Known(ref tyname) => {\n                 match tyname.as_slice() {\n                     \"\"  => (\"std\", \"secret_show\"),\n-                    \"?\" => (\"debug\", \"secret_poly\"),\n                     \"b\" => (\"std\", \"secret_bool\"),\n                     \"c\" => (\"std\", \"secret_char\"),\n                     \"d\" | \"i\" => (\"std\", \"secret_signed\"),"}, {"sha": "523299abce141eabbd9d73856b4e349b52ee5405", "filename": "src/libsyntax/ext/mtwt.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibsyntax%2Fext%2Fmtwt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibsyntax%2Fext%2Fmtwt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fmtwt.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -38,7 +38,7 @@ pub struct SCTable {\n     rename_memo: RefCell<HashMap<(SyntaxContext,Ident,Name),SyntaxContext>>,\n }\n \n-#[deriving(PartialEq, Encodable, Decodable, Hash)]\n+#[deriving(PartialEq, Encodable, Decodable, Hash, Show)]\n pub enum SyntaxContext_ {\n     EmptyCtxt,\n     Mark (Mrk,SyntaxContext),\n@@ -129,7 +129,7 @@ fn new_sctable_internal() -> SCTable {\n pub fn display_sctable(table: &SCTable) {\n     error!(\"SC table:\");\n     for (idx,val) in table.table.borrow().iter().enumerate() {\n-        error!(\"{:4u} : {:?}\",idx,val);\n+        error!(\"{:4u} : {}\",idx,val);\n     }\n }\n "}, {"sha": "2eb3b398da81548afcc05c2639599c7d96f183f8", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -1389,7 +1389,7 @@ mod test {\n                 let a_val = $a;\n                 let b_val = $b;\n                 if !(pred_val(a_val.as_slice(),b_val.as_slice())) {\n-                    fail!(\"expected args satisfying {}, got {:?} and {:?}\",\n+                    fail!(\"expected args satisfying {}, got {} and {}\",\n                           $predname, a_val, b_val);\n                 }\n             }"}, {"sha": "8c2652e5699ff81102b35a1db26d4033e2cff628", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -30,7 +30,6 @@\n \n extern crate arena;\n extern crate fmt_macros;\n-extern crate debug;\n #[phase(plugin, link)] extern crate log;\n extern crate serialize;\n extern crate term;"}, {"sha": "17dd546ad59d1d46d1f067b56ff78d4f17834767", "filename": "src/libsyntax/parse/attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibsyntax%2Fparse%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibsyntax%2Fparse%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fattr.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -63,7 +63,7 @@ impl<'a> ParserAttr for Parser<'a> {\n     /// If permit_inner is true, then a leading `!` indicates an inner\n     /// attribute\n     fn parse_attribute(&mut self, permit_inner: bool) -> ast::Attribute {\n-        debug!(\"parse_attributes: permit_inner={:?} self.token={:?}\",\n+        debug!(\"parse_attributes: permit_inner={} self.token={}\",\n                permit_inner, self.token);\n         let (span, value, mut style) = match self.token {\n             token::POUND => {"}, {"sha": "c4a8775a0128278f99ee064a0615f05e38729277", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -823,19 +823,19 @@ mod test {\n                                 }\n                             },\n                             _ => {\n-                                error!(\"failing value 3: {:?}\",first_set);\n+                                error!(\"failing value 3: {}\",first_set);\n                                 assert_eq!(\"wrong 3\",\"correct\")\n                             }\n                         }\n                     },\n                     _ => {\n-                        error!(\"failing value 2: {:?}\",delim_elts);\n+                        error!(\"failing value 2: {}\",delim_elts);\n                         assert_eq!(\"wrong\",\"correct\");\n                     }\n                 }\n             },\n             _ => {\n-                error!(\"failing value: {:?}\",tts);\n+                error!(\"failing value: {}\",tts);\n                 assert_eq!(\"wrong 1\",\"correct\");\n             }\n         }"}, {"sha": "7e77283cca77850f281e1cb1fab5adfefaccbca2", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -492,7 +492,7 @@ impl<'a> Parser<'a> {\n     /// followed by some token from the set edible + inedible.  Recover\n     /// from anticipated input errors, discarding erroneous characters.\n     pub fn commit_expr(&mut self, e: &Expr, edible: &[token::Token], inedible: &[token::Token]) {\n-        debug!(\"commit_expr {:?}\", e);\n+        debug!(\"commit_expr {}\", e);\n         match e.node {\n             ExprPath(..) => {\n                 // might be unit-struct construction; check for recoverableinput error.\n@@ -1535,7 +1535,7 @@ impl<'a> Parser<'a> {\n             // TYPE TO BE INFERRED\n             TyInfer\n         } else {\n-            let msg = format!(\"expected type, found token {:?}\", self.token);\n+            let msg = format!(\"expected type, found token {}\", self.token);\n             self.fatal(msg.as_slice());\n         };\n \n@@ -1591,7 +1591,7 @@ impl<'a> Parser<'a> {\n     /// identifier names.\n     pub fn parse_arg_general(&mut self, require_name: bool) -> Arg {\n         let pat = if require_name || self.is_named_argument() {\n-            debug!(\"parse_arg_general parse_pat (require_name:{:?})\",\n+            debug!(\"parse_arg_general parse_pat (require_name:{})\",\n                    require_name);\n             let pat = self.parse_pat();\n \n@@ -1882,7 +1882,7 @@ impl<'a> Parser<'a> {\n                 token::BINOP(token::SHR) => { return res; }\n                 _ => {\n                     let msg = format!(\"expected `,` or `>` after lifetime \\\n-                                      name, got: {:?}\",\n+                                      name, got: {}\",\n                                       self.token);\n                     self.fatal(msg.as_slice());\n                 }\n@@ -4711,7 +4711,7 @@ impl<'a> Parser<'a> {\n                 attrs = attrs_remaining.clone().append(attrs.as_slice());\n                 first = false;\n             }\n-            debug!(\"parse_mod_items: parse_item_or_view_item(attrs={:?})\",\n+            debug!(\"parse_mod_items: parse_item_or_view_item(attrs={})\",\n                    attrs);\n             match self.parse_item_or_view_item(attrs,\n                                                true /* macros allowed */) {"}, {"sha": "ee06c3f6caa347d0844529cfd9f0f8a6114d0d8f", "filename": "src/libtime/lib.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibtime%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Flibtime%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtime%2Flib.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -22,7 +22,6 @@\n        html_playground_url = \"http://play.rust-lang.org/\")]\n #![feature(phase)]\n \n-#[cfg(test)] extern crate debug;\n #[cfg(test)] #[phase(plugin, link)] extern crate log;\n \n extern crate serialize;\n@@ -1184,13 +1183,13 @@ mod tests {\n         static SOME_FUTURE_DATE: i64 = 1577836800i64; // 2020-01-01T00:00:00Z\n \n         let tv1 = get_time();\n-        debug!(\"tv1={:?} sec + {:?} nsec\", tv1.sec as uint, tv1.nsec as uint);\n+        debug!(\"tv1={} sec + {} nsec\", tv1.sec as uint, tv1.nsec as uint);\n \n         assert!(tv1.sec > SOME_RECENT_DATE);\n         assert!(tv1.nsec < 1000000000i32);\n \n         let tv2 = get_time();\n-        debug!(\"tv2={:?} sec + {:?} nsec\", tv2.sec as uint, tv2.nsec as uint);\n+        debug!(\"tv2={} sec + {} nsec\", tv2.sec as uint, tv2.nsec as uint);\n \n         assert!(tv2.sec >= tv1.sec);\n         assert!(tv2.sec < SOME_FUTURE_DATE);\n@@ -1207,12 +1206,12 @@ mod tests {\n \n         let ns0 = precise_time_ns();\n         let ns1 = precise_time_ns();\n-        debug!(\"ns0={:?} ns\", ns0);\n-        debug!(\"ns1={:?} ns\", ns1);\n+        debug!(\"ns0={} ns\", ns0);\n+        debug!(\"ns1={} ns\", ns1);\n         assert!(ns1 >= ns0);\n \n         let ns2 = precise_time_ns();\n-        debug!(\"ns2={:?} ns\", ns2);\n+        debug!(\"ns2={} ns\", ns2);\n         assert!(ns2 >= ns1);\n     }\n \n@@ -1241,7 +1240,7 @@ mod tests {\n         let time = Timespec::new(1234567890, 54321);\n         let local = at(time);\n \n-        debug!(\"time_at: {:?}\", local);\n+        debug!(\"time_at: {}\", local);\n \n         assert_eq!(local.tm_sec, 30_i32);\n         assert_eq!(local.tm_min, 31_i32);\n@@ -1446,7 +1445,7 @@ mod tests {\n         let utc   = at_utc(time);\n         let local = at(time);\n \n-        debug!(\"test_ctime: {:?} {:?}\", utc.asctime(), local.asctime());\n+        debug!(\"test_ctime: {} {}\", utc.asctime(), local.asctime());\n \n         assert_eq!(utc.asctime(), \"Fri Feb 13 23:31:30 2009\".to_string());\n         assert_eq!(local.asctime(), \"Fri Feb 13 15:31:30 2009\".to_string());\n@@ -1459,7 +1458,7 @@ mod tests {\n         let utc   = at_utc(time);\n         let local = at(time);\n \n-        debug!(\"test_ctime: {:?} {:?}\", utc.ctime(), local.ctime());\n+        debug!(\"test_ctime: {} {}\", utc.ctime(), local.ctime());\n \n         assert_eq!(utc.ctime(), \"Fri Feb 13 15:31:30 2009\".to_string());\n         assert_eq!(local.ctime(), \"Fri Feb 13 15:31:30 2009\".to_string());"}, {"sha": "1a579dd1b0e2d0924f6bbc6e8d53104dfdf03c12", "filename": "src/test/auxiliary/extern_calling_convention.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Fauxiliary%2Fextern_calling_convention.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Fauxiliary%2Fextern_calling_convention.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fextern_calling_convention.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -11,8 +11,6 @@\n // Make sure Rust generates the correct calling convention for extern\n // functions.\n \n-extern crate debug;\n-\n #[inline(never)]\n #[cfg(target_arch = \"x86_64\")]\n pub extern \"win64\" fn foo(a: int, b: int, c: int, d: int) {\n@@ -21,7 +19,7 @@ pub extern \"win64\" fn foo(a: int, b: int, c: int, d: int) {\n     assert!(c == 3);\n     assert!(d == 4);\n \n-    println!(\"a: {:?}, b: {:?}, c: {:?}, d: {:?}\",\n+    println!(\"a: {}, b: {}, c: {}, d: {}\",\n              a, b, c, d)\n }\n \n@@ -33,6 +31,6 @@ pub extern fn foo(a: int, b: int, c: int, d: int) {\n     assert!(c == 3);\n     assert!(d == 4);\n \n-    println!(\"a: {:?}, b: {:?}, c: {:?}, d: {:?}\",\n+    println!(\"a: {}, b: {}, c: {}, d: {}\",\n              a, b, c, d)\n }"}, {"sha": "6bc5b677a2730ac62c650641affe6ce3ba01403a", "filename": "src/test/auxiliary/logging_right_crate.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Fauxiliary%2Flogging_right_crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Fauxiliary%2Flogging_right_crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Flogging_right_crate.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -10,9 +10,8 @@\n \n #![feature(phase)]\n #[phase(plugin, link)] extern crate log;\n-extern crate debug;\n \n pub fn foo<T>() {\n     fn death() -> int { fail!() }\n-    debug!(\"{:?}\", (||{ death() })());\n+    debug!(\"{}\", (||{ death() })());\n }"}, {"sha": "34479f296bb8723ffe8322f63cd286ef9cd1f303", "filename": "src/test/bench/msgsend-pipes-shared.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -19,7 +19,6 @@\n // version.\n \n extern crate time;\n-extern crate debug;\n \n use std::comm;\n use std::os;\n@@ -41,7 +40,7 @@ fn server(requests: &Receiver<request>, responses: &Sender<uint>) {\n         match requests.recv_opt() {\n           Ok(get_count) => { responses.send(count.clone()); }\n           Ok(bytes(b)) => {\n-            //println!(\"server: received {:?} bytes\", b);\n+            //println!(\"server: received {} bytes\", b);\n             count += b;\n           }\n           Err(..) => { done = true; }\n@@ -65,10 +64,10 @@ fn run(args: &[String]) {\n         let to_child = to_child.clone();\n         worker_results.push(task::try_future(proc() {\n             for _ in range(0u, size / workers) {\n-                //println!(\"worker {:?}: sending {:?} bytes\", i, num_bytes);\n+                //println!(\"worker {}: sending {} bytes\", i, num_bytes);\n                 to_child.send(bytes(num_bytes));\n             }\n-            //println!(\"worker {:?} exiting\", i);\n+            //println!(\"worker {} exiting\", i);\n         }));\n     }\n     task::spawn(proc() {\n@@ -85,8 +84,8 @@ fn run(args: &[String]) {\n     let result = from_child.recv();\n     let end = time::precise_time_s();\n     let elapsed = end - start;\n-    print!(\"Count is {:?}\\n\", result);\n-    print!(\"Test took {:?} seconds\\n\", elapsed);\n+    print!(\"Count is {}\\n\", result);\n+    print!(\"Test took {} seconds\\n\", elapsed);\n     let thruput = ((size / workers * workers) as f64) / (elapsed as f64);\n     print!(\"Throughput={} per sec\\n\", thruput);\n     assert_eq!(result, num_bytes * size);"}, {"sha": "7a06b43ba2d63f5afd17c0aa9335d7d64a6c9916", "filename": "src/test/bench/msgsend-pipes.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -15,7 +15,6 @@\n // I *think* it's the same, more or less.\n \n extern crate time;\n-extern crate debug;\n \n use std::os;\n use std::task;\n@@ -36,7 +35,7 @@ fn server(requests: &Receiver<request>, responses: &Sender<uint>) {\n         match requests.recv_opt() {\n           Ok(get_count) => { responses.send(count.clone()); }\n           Ok(bytes(b)) => {\n-            //println!(\"server: received {:?} bytes\", b);\n+            //println!(\"server: received {} bytes\", b);\n             count += b;\n           }\n           Err(..) => { done = true; }\n@@ -59,10 +58,10 @@ fn run(args: &[String]) {\n         let (to_child, from_parent) = channel();\n         worker_results.push(task::try_future(proc() {\n             for _ in range(0u, size / workers) {\n-                //println!(\"worker {:?}: sending {:?} bytes\", i, num_bytes);\n+                //println!(\"worker {}: sending {} bytes\", i, num_bytes);\n                 to_child.send(bytes(num_bytes));\n             }\n-            //println!(\"worker {:?} exiting\", i);\n+            //println!(\"worker {} exiting\", i);\n         }));\n         from_parent\n     } else {\n@@ -71,10 +70,10 @@ fn run(args: &[String]) {\n             let to_child = to_child.clone();\n             worker_results.push(task::try_future(proc() {\n                 for _ in range(0u, size / workers) {\n-                    //println!(\"worker {:?}: sending {:?} bytes\", i, num_bytes);\n+                    //println!(\"worker {}: sending {} bytes\", i, num_bytes);\n                     to_child.send(bytes(num_bytes));\n                 }\n-                //println!(\"worker {:?} exiting\", i);\n+                //println!(\"worker {} exiting\", i);\n             }));\n         }\n         from_parent\n@@ -93,8 +92,8 @@ fn run(args: &[String]) {\n     let result = from_child.recv();\n     let end = time::precise_time_s();\n     let elapsed = end - start;\n-    print!(\"Count is {:?}\\n\", result);\n-    print!(\"Test took {:?} seconds\\n\", elapsed);\n+    print!(\"Count is {}\\n\", result);\n+    print!(\"Test took {} seconds\\n\", elapsed);\n     let thruput = ((size / workers * workers) as f64) / (elapsed as f64);\n     print!(\"Throughput={} per sec\\n\", thruput);\n     assert_eq!(result, num_bytes * size);\n@@ -110,6 +109,6 @@ fn main() {\n         args.clone().into_iter().map(|x| x.to_string()).collect()\n     };\n \n-    println!(\"{:?}\", args);\n+    println!(\"{}\", args);\n     run(args.as_slice());\n }"}, {"sha": "c495e597ca6d034a2e26f48511e2fc5ef4b74408", "filename": "src/test/bench/std-smallintmap.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Fbench%2Fstd-smallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Fbench%2Fstd-smallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fstd-smallintmap.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -12,7 +12,6 @@\n \n extern crate collections;\n extern crate time;\n-extern crate debug;\n \n use std::collections::SmallIntMap;\n use std::os;\n@@ -59,8 +58,8 @@ fn main() {\n \n     let maxf = max as f64;\n \n-    println!(\"insert(): {:?} seconds\\n\", checkf);\n+    println!(\"insert(): {} seconds\\n\", checkf);\n     println!(\"        : {} op/sec\\n\", maxf/checkf);\n-    println!(\"get()   : {:?} seconds\\n\", appendf);\n+    println!(\"get()   : {} seconds\\n\", appendf);\n     println!(\"        : {} op/sec\\n\", maxf/appendf);\n }"}, {"sha": "76af956a26fff7a9a908163d5c578fa49b8fc908", "filename": "src/test/compile-fail/block-coerce-no.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Fcompile-fail%2Fblock-coerce-no.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Fcompile-fail%2Fblock-coerce-no.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fblock-coerce-no.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -11,8 +11,6 @@\n // Make sure that fn-to-block coercion isn't incorrectly lifted over\n // other tycons.\n \n-extern crate debug;\n-\n fn coerce(b: ||) -> extern fn() {\n     fn lol(f: extern fn(v: ||) -> extern fn(),\n            g: ||) -> extern fn() { return f(g); }\n@@ -23,6 +21,6 @@ fn coerce(b: ||) -> extern fn() {\n \n fn main() {\n     let i = 8i;\n-    let f = coerce(|| println!(\"{:?}\", i) );\n+    let f = coerce(|| println!(\"{}\", i) );\n     f();\n }"}, {"sha": "10c63965a7bbb78c04d642b6403f99a8376978d4", "filename": "src/test/compile-fail/borrowck-borrowed-uniq-rvalue-2.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Fcompile-fail%2Fborrowck-borrowed-uniq-rvalue-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Fcompile-fail%2Fborrowck-borrowed-uniq-rvalue-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-borrowed-uniq-rvalue-2.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -10,8 +10,6 @@\n \n #![feature(unsafe_destructor)]\n \n-extern crate debug;\n-\n struct defer<'a> {\n     x: &'a [&'a str],\n }\n@@ -20,7 +18,7 @@ struct defer<'a> {\n impl<'a> Drop for defer<'a> {\n     fn drop(&mut self) {\n         unsafe {\n-            println!(\"{:?}\", self.x);\n+            println!(\"{}\", self.x);\n         }\n     }\n }"}, {"sha": "e6d59062af2077251473c0809745b9d3ce2fc184", "filename": "src/test/compile-fail/borrowck-if-with-else.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Fcompile-fail%2Fborrowck-if-with-else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Fcompile-fail%2Fborrowck-if-with-else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-if-with-else.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -8,9 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-extern crate debug;\n-\n-fn foo(x: int) { println!(\"{:?}\", x); }\n+fn foo(x: int) { println!(\"{}\", x); }\n \n fn main() {\n     let x: int;"}, {"sha": "07e2ff084664dcfc11d8a8abc97baf0341e165ca", "filename": "src/test/compile-fail/borrowck-init-in-fn-expr.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Fcompile-fail%2Fborrowck-init-in-fn-expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Fcompile-fail%2Fborrowck-init-in-fn-expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-init-in-fn-expr.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -8,12 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-extern crate debug;\n-\n fn main() {\n     let f: || -> int = || {\n         let i: int;\n         i //~ ERROR use of possibly uninitialized variable: `i`\n     };\n-    println!(\"{:?}\", f());\n+    println!(\"{}\", f());\n }"}, {"sha": "8d94b553f11e403c2eca02db278ad7991eecc134", "filename": "src/test/compile-fail/borrowck-move-out-of-vec-tail.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Fcompile-fail%2Fborrowck-move-out-of-vec-tail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Fcompile-fail%2Fborrowck-move-out-of-vec-tail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-move-out-of-vec-tail.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -10,9 +10,7 @@\n \n // Test that we do not permit moves from &[] matched by a vec pattern.\n \n-extern crate debug;\n-\n-#[deriving(Clone)]\n+#[deriving(Clone, Show)]\n struct Foo {\n     string: String\n }\n@@ -37,7 +35,7 @@ pub fn main() {\n                 }\n             }\n             let z = tail[0].clone();\n-            println!(\"{:?}\", z);\n+            println!(\"{}\", z);\n         }\n         _ => {\n             unreachable!();"}, {"sha": "0c0377e74112c6c26eb294881b112c9cf54b7b35", "filename": "src/test/compile-fail/borrowck-mut-addr-of-imm-var.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Fcompile-fail%2Fborrowck-mut-addr-of-imm-var.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Fcompile-fail%2Fborrowck-mut-addr-of-imm-var.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-mut-addr-of-imm-var.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -8,11 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-extern crate debug;\n-\n fn main() {\n     let x: int = 3;\n     let y: &mut int = &mut x; //~ ERROR cannot borrow\n     *y = 5;\n-    println!(\"{:?}\", *y);\n+    println!(\"{}\", *y);\n }"}, {"sha": "67537464a3348d3b15c8a21b9f3f2322c69a7a81", "filename": "src/test/compile-fail/copy-a-resource.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Fcompile-fail%2Fcopy-a-resource.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Fcompile-fail%2Fcopy-a-resource.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcopy-a-resource.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -8,8 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-extern crate debug;\n-\n+#[deriving(Show)]\n struct foo {\n   i: int,\n }\n@@ -28,5 +27,5 @@ fn main() {\n     let x = foo(10);\n     let _y = x.clone();\n     //~^ ERROR does not implement any method in scope\n-    println!(\"{:?}\", x);\n+    println!(\"{}\", x);\n }"}, {"sha": "89beb9a31601b510e3a8e7123cf32bce64a1d12a", "filename": "src/test/compile-fail/if-without-else-result.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Fcompile-fail%2Fif-without-else-result.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Fcompile-fail%2Fif-without-else-result.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fif-without-else-result.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -8,10 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-extern crate debug;\n-\n fn main() {\n     let a = if true { true };\n //~^ ERROR if may be missing an else clause: expected `()`, found `bool` (expected (), found bool)\n-    println!(\"{:?}\", a);\n+    println!(\"{}\", a);\n }"}, {"sha": "01683d001ac1651b387315c1e5bf4dcc7f32752c", "filename": "src/test/compile-fail/issue-1476.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Fcompile-fail%2Fissue-1476.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Fcompile-fail%2Fissue-1476.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-1476.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-extern crate debug;\n-\n fn main() {\n-    println!(\"{:?}\", x); //~ ERROR unresolved name `x`.\n+    println!(\"{}\", x); //~ ERROR unresolved name `x`.\n }"}, {"sha": "14096ca7bca18e275a8ec47ba9e13e38ba818e1b", "filename": "src/test/compile-fail/issue-2281-part1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Fcompile-fail%2Fissue-2281-part1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Fcompile-fail%2Fissue-2281-part1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2281-part1.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -10,4 +10,4 @@\n \n // error-pattern: unresolved name `foobar`.\n \n-fn main() { println!(\"{:?}\", foobar); }\n+fn main() { println!(\"{}\", foobar); }"}, {"sha": "b6820a1d8e4240d7a15bcffab9e61f3d09282c03", "filename": "src/test/compile-fail/issue-2823.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Fcompile-fail%2Fissue-2823.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Fcompile-fail%2Fissue-2823.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2823.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -8,15 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-extern crate debug;\n-\n struct C {\n     x: int,\n }\n \n impl Drop for C {\n     fn drop(&mut self) {\n-        println!(\"dropping: {:?}\", self.x);\n+        println!(\"dropping: {}\", self.x);\n     }\n }\n "}, {"sha": "049c6130d2d8af9d62dd07e2512157cfe852c20a", "filename": "src/test/compile-fail/issue-3038.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Fcompile-fail%2Fissue-3038.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Fcompile-fail%2Fissue-3038.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3038.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-extern crate debug;\n-\n enum f { g(int, int) }\n \n enum h { i(j, k) }\n@@ -21,13 +19,13 @@ fn main()\n {\n \n     let _z = match g(1, 2) {\n-      g(x, x) => { println!(\"{:?}\", x + x); }\n+      g(x, x) => { println!(\"{}\", x + x); }\n       //~^ ERROR identifier `x` is bound more than once in the same pattern\n     };\n \n     let _z = match i(l(1, 2), m(3, 4)) {\n       i(l(x, _), m(_, x))  //~ ERROR identifier `x` is bound more than once in the same pattern\n-        => { println!(\"{:?}\", x + x); }\n+        => { println!(\"{}\", x + x); }\n     };\n \n     let _z = match (1, 2) {"}, {"sha": "2e0006bb1fe64d50c10b4fecff183478281df127", "filename": "src/test/compile-fail/issue-3521.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Fcompile-fail%2Fissue-3521.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Fcompile-fail%2Fissue-3521.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3521.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -8,14 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-extern crate debug;\n-\n fn main() {\n     let foo = 100;\n \n+    #[deriving(Show)]\n     enum Stuff {\n         Bar = foo //~ ERROR attempt to use a non-constant value in a constant\n     }\n \n-    println!(\"{:?}\", Bar);\n+    println!(\"{}\", Bar);\n }"}, {"sha": "5082c3102dd81451e94f7c01759c218591628d83", "filename": "src/test/compile-fail/issue-5062.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Fcompile-fail%2Fissue-5062.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Fcompile-fail%2Fissue-5062.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-5062.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -8,7 +8,5 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-extern crate debug;\n-\n-fn main() { format!(\"{:?}\", None); }\n+fn main() { format!(\"{}\", None); }\n     //~^ ERROR type annotations required"}, {"sha": "07c1686a7acd2409c2b8bfea5d79aa61563e3355", "filename": "src/test/compile-fail/issue-6458-2.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Fcompile-fail%2Fissue-6458-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Fcompile-fail%2Fissue-6458-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-6458-2.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -8,10 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-extern crate debug;\n-\n fn main() {\n     // Unconstrained type:\n-    format!(\"{:?}\", None);\n+    format!(\"{}\", None);\n     //~^ ERROR type annotations required\n }"}, {"sha": "6466310eb4d2e133b681961478cc29941c38cd6e", "filename": "src/test/compile-fail/liveness-closure-require-ret.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Fcompile-fail%2Fliveness-closure-require-ret.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Fcompile-fail%2Fliveness-closure-require-ret.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-closure-require-ret.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -8,7 +8,5 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-extern crate debug;\n-\n fn force(f: || -> int) -> int { f() }\n-fn main() { println!(\"{:?}\", force(|| {})); } //~ ERROR mismatched types\n+fn main() { println!(\"{}\", force(|| {})); } //~ ERROR mismatched types"}, {"sha": "127a68bd339e69f2c3c33a6f3fb5258f2ab9701c", "filename": "src/test/compile-fail/liveness-move-in-loop.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Fcompile-fail%2Fliveness-move-in-loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Fcompile-fail%2Fliveness-move-in-loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-move-in-loop.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -8,13 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-extern crate debug;\n-\n fn main() {\n     let y: Box<int> = box 42;\n     let mut x: Box<int>;\n     loop {\n-        println!(\"{:?}\", y);\n+        println!(\"{}\", y);\n         loop {\n             loop {\n                 loop {"}, {"sha": "2cebe3f573bd9b8b68c817a615d5fb9b6c70832a", "filename": "src/test/compile-fail/liveness-move-in-while.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Fcompile-fail%2Fliveness-move-in-while.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Fcompile-fail%2Fliveness-move-in-while.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-move-in-while.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -8,13 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-extern crate debug;\n-\n fn main() {\n     let y: Box<int> = box 42;\n     let mut x: Box<int>;\n     loop {\n-        println!(\"{:?}\", y); //~ ERROR use of moved value: `y`\n+        println!(\"{}\", y); //~ ERROR use of moved value: `y`\n         while true { while true { while true { x = y; x.clone(); } } }\n         //~^ ERROR use of moved value: `y`\n     }"}, {"sha": "a988254141a757cfae0ba6eaf12f91633d23474c", "filename": "src/test/compile-fail/liveness-use-after-move.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Fcompile-fail%2Fliveness-use-after-move.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Fcompile-fail%2Fliveness-use-after-move.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-use-after-move.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -8,11 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-extern crate debug;\n-\n fn main() {\n     let x = box 5i;\n     let y = x;\n-    println!(\"{:?}\", *x); //~ ERROR use of moved value: `*x`\n+    println!(\"{}\", *x); //~ ERROR use of moved value: `*x`\n     y.clone();\n }"}, {"sha": "54d0b2d00c776c8f308585a8f3b407477afcccdb", "filename": "src/test/compile-fail/liveness-use-after-send.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Fcompile-fail%2Fliveness-use-after-send.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Fcompile-fail%2Fliveness-use-after-send.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-use-after-send.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -8,21 +8,20 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-extern crate debug;\n-\n-fn send<T:Send>(ch: _chan<T>, data: T) {\n-    println!(\"{:?}\", ch);\n-    println!(\"{:?}\", data);\n+fn send<T:Send + std::fmt::Show>(ch: _chan<T>, data: T) {\n+    println!(\"{}\", ch);\n+    println!(\"{}\", data);\n     fail!();\n }\n \n+#[deriving(Show)]\n struct _chan<T>(int);\n \n // Tests that \"log(debug, message);\" is flagged as using\n // message after the send deinitializes it\n fn test00_start(ch: _chan<Box<int>>, message: Box<int>, _count: Box<int>) {\n     send(ch, message);\n-    println!(\"{:?}\", message); //~ ERROR use of moved value: `message`\n+    println!(\"{}\", message); //~ ERROR use of moved value: `message`\n }\n \n fn main() { fail!(); }"}, {"sha": "de44a005fc33ad599c66f92421b86a550a23a0e5", "filename": "src/test/compile-fail/match-join.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Fcompile-fail%2Fmatch-join.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Fcompile-fail%2Fmatch-join.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmatch-join.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -11,13 +11,11 @@\n // a good test that we merge paths correctly in the presence of a\n // variable that's used before it's declared\n \n-extern crate debug;\n-\n fn my_fail() -> ! { fail!(); }\n \n fn main() {\n     match true { false => { my_fail(); } true => { } }\n \n-    println!(\"{:?}\", x); //~ ERROR unresolved name `x`.\n+    println!(\"{}\", x); //~ ERROR unresolved name `x`.\n     let x: int;\n }"}, {"sha": "85723936997195388780ca2b80b02e78989f27cb", "filename": "src/test/compile-fail/moves-based-on-type-access-to-field.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-access-to-field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-access-to-field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-access-to-field.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -11,8 +11,6 @@\n // Tests that if you move from `x.f` or `x[0]`, `x` is inaccessible.\n // Also tests that we give a more specific error message.\n \n-extern crate debug;\n-\n struct Foo { f: String, y: int }\n fn consume(_s: String) {}\n fn touch<A>(_a: &A) {}"}, {"sha": "ff5ad2c5e193604a0cc2ecdfef7ebb503c673cbd", "filename": "src/test/compile-fail/moves-based-on-type-no-recursive-stack-closure.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-no-recursive-stack-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-no-recursive-stack-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-no-recursive-stack-closure.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -12,8 +12,6 @@\n // bound must be noncopyable. For details see\n // http://smallcultfollowing.com/babysteps/blog/2013/04/30/the-case-of-the-recurring-closure/\n \n-extern crate debug;\n-\n struct R<'a> {\n     // This struct is needed to create the\n     // otherwise infinite type of a fn that\n@@ -31,7 +29,7 @@ fn innocent_looking_victim() {\n                 Some(ref msg) => {\n                     (f.c)(f, true);\n                     //~^ ERROR: cannot borrow `*f` as mutable because\n-                    println!(\"{:?}\", msg);\n+                    println!(\"{}\", msg);\n                 },\n                 None => fail!(\"oops\"),\n             }"}, {"sha": "bf762eaa80f5a7a13a904b53b6499761dfb15e64", "filename": "src/test/compile-fail/noncopyable-class.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Fcompile-fail%2Fnoncopyable-class.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Fcompile-fail%2Fnoncopyable-class.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnoncopyable-class.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -11,8 +11,7 @@\n // Test that a class with a non-copyable field can't be\n // copied\n \n-extern crate debug;\n-\n+#[deriving(Show)]\n struct bar {\n   x: int,\n }\n@@ -27,6 +26,7 @@ fn bar(x:int) -> bar {\n     }\n }\n \n+#[deriving(Show)]\n struct foo {\n   i: int,\n   j: bar,\n@@ -42,5 +42,5 @@ fn foo(i:int) -> foo {\n fn main() {\n     let x = foo(10);\n     let _y = x.clone(); //~ ERROR does not implement any method in scope\n-    println!(\"{:?}\", x);\n+    println!(\"{}\", x);\n }"}, {"sha": "346661e3c1f52818b27eff8597dfb19c4d218950", "filename": "src/test/compile-fail/nonscalar-cast.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Fcompile-fail%2Fnonscalar-cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Fcompile-fail%2Fnonscalar-cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnonscalar-cast.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -10,12 +10,11 @@\n \n // error-pattern:non-scalar cast\n \n-extern crate debug;\n-\n+#[deriving(Show)]\n struct foo {\n-    x:int\n+    x: int\n }\n \n fn main() {\n-    println!(\"{:?}\", foo{ x: 1 } as int);\n+    println!(\"{}\", foo{ x: 1 } as int);\n }"}, {"sha": "d699f69864e38474df7ca2373f5a03e976536f4a", "filename": "src/test/compile-fail/packed-struct-generic-transmute.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Fcompile-fail%2Fpacked-struct-generic-transmute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Fcompile-fail%2Fpacked-struct-generic-transmute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fpacked-struct-generic-transmute.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -15,7 +15,7 @@\n \n // error-pattern: transmute called on types with different size\n \n-extern crate debug;\n+#![feature(slicing_syntax)]\n \n use std::mem;\n \n@@ -34,6 +34,6 @@ fn main() {\n     let foo = Foo { bar: [1u8, 2, 3, 4, 5], baz: 10i32 };\n     unsafe {\n         let oof: Oof<[u8, .. 5], i32> = mem::transmute(foo);\n-        println!(\"{:?}\", oof);\n+        println!(\"{} {}\", oof.rab[], oof.zab);\n     }\n }"}, {"sha": "9c8e8193319de2259564a17052956614a5fbecb8", "filename": "src/test/compile-fail/packed-struct-transmute.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Fcompile-fail%2Fpacked-struct-transmute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Fcompile-fail%2Fpacked-struct-transmute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fpacked-struct-transmute.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -15,8 +15,6 @@\n \n // error-pattern: transmute called on types with different size\n \n-extern crate debug;\n-\n use std::mem;\n \n #[repr(packed)]\n@@ -25,6 +23,7 @@ struct Foo {\n     baz: uint\n }\n \n+#[deriving(Show)]\n struct Oof {\n     rab: u8,\n     zab: uint\n@@ -34,6 +33,6 @@ fn main() {\n     let foo = Foo { bar: 1, baz: 10 };\n     unsafe {\n         let oof: Oof = mem::transmute(foo);\n-        println!(\"{:?}\", oof);\n+        println!(\"{}\", oof);\n     }\n }"}, {"sha": "efb98a74538f2e6a3409f19db909d55f56100387", "filename": "src/test/compile-fail/pattern-tyvar.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Fcompile-fail%2Fpattern-tyvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Fcompile-fail%2Fpattern-tyvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fpattern-tyvar.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -10,14 +10,12 @@\n \n // error-pattern: mismatched types\n \n-extern crate debug;\n-\n enum bar { t1((), Option<Vec<int> >), t2, }\n \n fn foo(t: bar) {\n     match t {\n       t1(_, Some::<int>(x)) => {\n-        println!(\"{:?}\", x);\n+        println!(\"{}\", x);\n       }\n       _ => { fail!(); }\n     }"}, {"sha": "424ffed989b3ce6b9aaccf7d98db5ebcdc5280bf", "filename": "src/test/compile-fail/str-idx.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Fcompile-fail%2Fstr-idx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Fcompile-fail%2Fstr-idx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstr-idx.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-extern crate debug;\n-\n pub fn main() {\n     let s: &str = \"hello\";\n     let c: u8 = s[4]; //~ ERROR cannot index a value of type `&str`"}, {"sha": "c812b0d96a23ddb459f48bb5cc70e6012e0e8ff0", "filename": "src/test/compile-fail/unique-pinned-nocopy.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Fcompile-fail%2Funique-pinned-nocopy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Fcompile-fail%2Funique-pinned-nocopy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funique-pinned-nocopy.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -8,8 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-extern crate debug;\n-\n+#[deriving(Show)]\n struct r {\n   b: bool,\n }\n@@ -21,5 +20,5 @@ impl Drop for r {\n fn main() {\n     let i = box r { b: true };\n     let _j = i.clone(); //~ ERROR not implemented\n-    println!(\"{:?}\", i);\n+    println!(\"{}\", i);\n }"}, {"sha": "205c912f5a098cf449992bb189c623db3e328864", "filename": "src/test/compile-fail/unsupported-cast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Fcompile-fail%2Funsupported-cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Fcompile-fail%2Funsupported-cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsupported-cast.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -14,5 +14,5 @@\n extern crate libc;\n \n fn main() {\n-  println!(\"{:?}\", 1.0 as *libc::FILE); // Can't cast float to foreign.\n+  println!(\"{}\", 1.0 as *libc::FILE); // Can't cast float to foreign.\n }"}, {"sha": "6098b97c79a947a8f2e9a01a5de8623bdeceb30a", "filename": "src/test/run-fail/result-get-fail.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Frun-fail%2Fresult-get-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Frun-fail%2Fresult-get-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fresult-get-fail.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -10,10 +10,8 @@\n \n // error-pattern:called `Result::unwrap()` on an `Err` value\n \n-extern crate debug;\n-\n use std::result;\n \n fn main() {\n-    println!(\"{:?}\", result::Err::<int,String>(\"kitty\".to_string()).unwrap());\n+    println!(\"{}\", result::Err::<int,String>(\"kitty\".to_string()).unwrap());\n }"}, {"sha": "ecc1a6a495c1114122af126a0d76d0795ce17816", "filename": "src/test/run-pass/alignment-gep-tup-like-1.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Frun-pass%2Falignment-gep-tup-like-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Frun-pass%2Falignment-gep-tup-like-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falignment-gep-tup-like-1.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-extern crate debug;\n-\n struct pair<A,B> {\n     a: A, b: B\n }\n@@ -38,7 +36,7 @@ fn f<A:Clone + 'static>(a: A, b: u16) -> Box<Invokable<A>+'static> {\n \n pub fn main() {\n     let (a, b) = f(22_u64, 44u16).f();\n-    println!(\"a={:?} b={:?}\", a, b);\n+    println!(\"a={} b={}\", a, b);\n     assert_eq!(a, 22u64);\n     assert_eq!(b, 44u16);\n }"}, {"sha": "6195c259414b50a2bcbf55327728b5a987fb11e9", "filename": "src/test/run-pass/auto-instantiate.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Frun-pass%2Fauto-instantiate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Frun-pass%2Fauto-instantiate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauto-instantiate.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -8,14 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-extern crate debug;\n-\n+#[deriving(Show)]\n struct Pair<T, U> { a: T, b: U }\n struct Triple { x: int, y: int, z: int }\n \n fn f<T,U>(x: T, y: U) -> Pair<T, U> { return Pair {a: x, b: y}; }\n \n pub fn main() {\n-    println!(\"{:?}\", f(Triple {x: 3, y: 4, z: 5}, 4i).a.x);\n-    println!(\"{:?}\", f(5i, 6i).a);\n+    println!(\"{}\", f(Triple {x: 3, y: 4, z: 5}, 4i).a.x);\n+    println!(\"{}\", f(5i, 6i).a);\n }"}, {"sha": "4b81654a1d0a2195f54e43b12161ce2cbb0d07e2", "filename": "src/test/run-pass/block-arg.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Frun-pass%2Fblock-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Frun-pass%2Fblock-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-arg.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-extern crate debug;\n-\n fn inty(fun: proc(int) -> int) -> int {\n     fun(100)\n }\n@@ -24,7 +22,7 @@ pub fn main() {\n \n     // Statement form does not require parentheses:\n     for i in v.iter() {\n-        println!(\"{:?}\", *i);\n+        println!(\"{}\", *i);\n     }\n \n }"}, {"sha": "ce20c3024d6fb7e2d186fdf4197fc6a094cda62d", "filename": "src/test/run-pass/block-iter-1.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Frun-pass%2Fblock-iter-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Frun-pass%2Fblock-iter-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-iter-1.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-extern crate debug;\n-\n fn iter_vec<T>(v: Vec<T> , f: |&T|) { for x in v.iter() { f(x); } }\n \n pub fn main() {\n@@ -20,6 +18,6 @@ pub fn main() {\n             odds += 1;\n         }\n     });\n-    println!(\"{:?}\", odds);\n+    println!(\"{}\", odds);\n     assert_eq!(odds, 4);\n }"}, {"sha": "7bb9d0ddf99af1aa93237eb1296f04fa36d612b5", "filename": "src/test/run-pass/block-iter-2.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Frun-pass%2Fblock-iter-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Frun-pass%2Fblock-iter-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-iter-2.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-extern crate debug;\n-\n fn iter_vec<T>(v: Vec<T> , f: |&T|) { for x in v.iter() { f(x); } }\n \n pub fn main() {\n@@ -20,6 +18,6 @@ pub fn main() {\n             sum += *i * *j;\n         });\n     });\n-    println!(\"{:?}\", sum);\n+    println!(\"{}\", sum);\n     assert_eq!(sum, 225);\n }"}, {"sha": "867fdd531e95f6f683a6a2beae3fc159ccc52e6f", "filename": "src/test/run-pass/borrowck-mut-uniq.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Frun-pass%2Fborrowck-mut-uniq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Frun-pass%2Fborrowck-mut-uniq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-mut-uniq.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -8,10 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-extern crate debug;\n-\n use std::mem::swap;\n \n+#[deriving(Show)]\n struct Ints {sum: Box<int>, values: Vec<int> }\n \n fn add_int(x: &mut Ints, v: int) {\n@@ -37,5 +36,5 @@ pub fn main() {\n         true\n     });\n \n-    println!(\"ints={:?}\", ints);\n+    println!(\"ints={}\", ints);\n }"}, {"sha": "375767c8f5157c820312cf0fb811b8449eeabb5e", "filename": "src/test/run-pass/close-over-big-then-small-data.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Frun-pass%2Fclose-over-big-then-small-data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Frun-pass%2Fclose-over-big-then-small-data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclose-over-big-then-small-data.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -12,8 +12,6 @@\n // storing closure data (as we used to do), the u64 would\n // overwrite the u16.\n \n-extern crate debug;\n-\n struct Pair<A,B> {\n     a: A, b: B\n }\n@@ -42,7 +40,7 @@ fn f<A:Clone + 'static>(a: A, b: u16) -> Box<Invokable<A>+'static> {\n \n pub fn main() {\n     let (a, b) = f(22_u64, 44u16).f();\n-    println!(\"a={:?} b={:?}\", a, b);\n+    println!(\"a={} b={}\", a, b);\n     assert_eq!(a, 22u64);\n     assert_eq!(b, 44u16);\n }"}, {"sha": "18cc92f335dff8099b57f996915cd2e86e7a72c2", "filename": "src/test/run-pass/comm.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Frun-pass%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Frun-pass%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcomm.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -8,16 +8,14 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-extern crate debug;\n-\n use std::task;\n \n pub fn main() {\n     let (tx, rx) = channel();\n     let _t = task::spawn(proc() { child(&tx) });\n     let y = rx.recv();\n     println!(\"received\");\n-    println!(\"{:?}\", y);\n+    println!(\"{}\", y);\n     assert_eq!(y, 10);\n }\n "}, {"sha": "29d329d46a05a748a664c5c1e4241d0c6753af29", "filename": "src/test/run-pass/conditional-debug-macro-off.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Frun-pass%2Fconditional-debug-macro-off.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Frun-pass%2Fconditional-debug-macro-off.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconditional-debug-macro-off.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -14,9 +14,8 @@\n #![feature(phase)]\n #[phase(plugin, link)]\n extern crate log;\n-extern crate debug;\n \n pub fn main() {\n     // only fails if println! evaluates its argument.\n-    debug!(\"{:?}\", { if true { fail!() } });\n+    debug!(\"{}\", { if true { fail!() } });\n }"}, {"sha": "9d09740f3b45e85620b78d9c5b84e2b4c1ad1c8e", "filename": "src/test/run-pass/conditional-debug-macro-on.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Frun-pass%2Fconditional-debug-macro-on.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Frun-pass%2Fconditional-debug-macro-on.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconditional-debug-macro-on.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -10,12 +10,10 @@\n \n // exec-env:RUST_LOG=conditional-debug-macro-on=4\n \n-extern crate debug;\n-\n pub fn main() {\n     // exits early if println! evaluates its arguments, otherwise it\n     // will hit the fail.\n-    println!(\"{:?}\", { if true { return; } });\n+    println!(\"{}\", { if true { return; } });\n \n     fail!();\n }"}, {"sha": "49b244a162b0c28bee40c28a77ba2c57939a1bf3", "filename": "src/test/run-pass/const-fields-and-indexing.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Frun-pass%2Fconst-fields-and-indexing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Frun-pass%2Fconst-fields-and-indexing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-fields-and-indexing.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-extern crate debug;\n-\n const x : [int, ..4] = [1,2,3,4];\n static p : int = x[2];\n const y : &'static [int] = &[1,2,3,4];\n@@ -27,9 +25,9 @@ const k : K = K {a: 10, b: 20, c: D {d: 30, e: 40}};\n static m : int = k.c.e;\n \n pub fn main() {\n-    println!(\"{:?}\", p);\n-    println!(\"{:?}\", q);\n-    println!(\"{:?}\", t);\n+    println!(\"{}\", p);\n+    println!(\"{}\", q);\n+    println!(\"{}\", t);\n     assert_eq!(p, 3);\n     assert_eq!(q, 3);\n     assert_eq!(t, 20);"}, {"sha": "c61f26e0bb6b337a6d1ea71453d460dda48981fe", "filename": "src/test/run-pass/const-vecs-and-slices.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Frun-pass%2Fconst-vecs-and-slices.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Frun-pass%2Fconst-vecs-and-slices.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-vecs-and-slices.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -8,18 +8,16 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-extern crate debug;\n-\n static x : [int, ..4] = [1,2,3,4];\n static y : &'static [int] = &[1,2,3,4];\n static z : &'static [int, ..4] = &[1,2,3,4];\n static zz : &'static [int] = [1,2,3,4];\n \n pub fn main() {\n-    println!(\"{:?}\", x[1]);\n-    println!(\"{:?}\", y[1]);\n-    println!(\"{:?}\", z[1]);\n-    println!(\"{:?}\", zz[1]);\n+    println!(\"{}\", x[1]);\n+    println!(\"{}\", y[1]);\n+    println!(\"{}\", z[1]);\n+    println!(\"{}\", zz[1]);\n     assert_eq!(x[1], 2);\n     assert_eq!(x[3], 4);\n     assert_eq!(x[3], y[3]);"}, {"sha": "2028ebf64c217afd68e71edeaa0a015d23183188", "filename": "src/test/run-pass/dst-struct-reflect.rs", "status": "removed", "additions": 0, "deletions": 61, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/b6e0d3a5bf4c88650a22f605f822e02c6b163580/src%2Ftest%2Frun-pass%2Fdst-struct-reflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6e0d3a5bf4c88650a22f605f822e02c6b163580/src%2Ftest%2Frun-pass%2Fdst-struct-reflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdst-struct-reflect.rs?ref=b6e0d3a5bf4c88650a22f605f822e02c6b163580", "patch": "@@ -1,61 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// FIXME(15049) Re-enable this test.\n-// ignore-test\n-// Test that structs with unsized fields work with {:?} reflection.\n-\n-extern crate debug;\n-\n-struct Fat<Sized? T> {\n-    f1: int,\n-    f2: &'static str,\n-    ptr: T\n-}\n-\n-// x is a fat pointer\n-fn reflect(x: &Fat<[int]>, cmp: &str) {\n-    // Don't test this result because reflecting unsized fields is undefined for now.\n-    let _s = format!(\"{:?}\", x);\n-    let s = format!(\"{:?}\", &x.ptr);\n-    assert!(s == cmp.to_string())\n-\n-    println!(\"{:?}\", x);\n-    println!(\"{:?}\", &x.ptr);\n-}\n-\n-fn reflect_0(x: &Fat<[int]>) {\n-    let _s = format!(\"{:?}\", x.ptr[0]);\n-    println!(\"{:?}\", x.ptr[0]);\n-}\n-\n-pub fn main() {\n-    // With a vec of ints.\n-    let f1 = Fat { f1: 5, f2: \"some str\", ptr: [1, 2, 3] };\n-    reflect(&f1, \"&[1, 2, 3]\");\n-    reflect_0(&f1);\n-    let f2 = &f1;\n-    reflect(f2, \"&[1, 2, 3]\");\n-    reflect_0(f2);\n-    let f3: &Fat<[int]> = f2;\n-    reflect(f3, \"&[1, 2, 3]\");\n-    reflect_0(f3);\n-    let f4: &Fat<[int]> = &f1;\n-    reflect(f4, \"&[1, 2, 3]\");\n-    reflect_0(f4);\n-    let f5: &Fat<[int]> = &Fat { f1: 5, f2: \"some str\", ptr: [1, 2, 3] };\n-    reflect(f5, \"&[1, 2, 3]\");\n-    reflect_0(f5);\n-\n-    // Zero size vec.\n-    let f5: &Fat<[int]> = &Fat { f1: 5, f2: \"some str\", ptr: [] };\n-    reflect(f5, \"&[]\");\n-}\n-"}, {"sha": "e079916814082918f7cefb4a56e407c1540ee24a", "filename": "src/test/run-pass/enum-discrim-width-stuff.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Frun-pass%2Fenum-discrim-width-stuff.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Frun-pass%2Fenum-discrim-width-stuff.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fenum-discrim-width-stuff.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -10,12 +10,11 @@\n \n #![feature(macro_rules)]\n \n-extern crate debug;\n-\n macro_rules! check {\n     ($m:ident, $t:ty, $v:expr) => {{\n         mod $m {\n             use std::mem::size_of;\n+            #[deriving(Show)]\n             enum E {\n                 V = $v,\n                 A = 0\n@@ -25,8 +24,8 @@ macro_rules! check {\n                 assert_eq!(size_of::<E>(), size_of::<$t>());\n                 assert_eq!(V as $t, $v as $t);\n                 assert_eq!(C as $t, $v as $t);\n-                assert_eq!(format!(\"{:?}\", V), \"V\".to_string());\n-                assert_eq!(format!(\"{:?}\", C), \"V\".to_string());\n+                assert_eq!(format!(\"{}\", V), \"V\".to_string());\n+                assert_eq!(format!(\"{}\", C), \"V\".to_string());\n             }\n         }\n         $m::check();"}, {"sha": "ab6576b9b427d9921c25a5d1dabcc2f05c66865a", "filename": "src/test/run-pass/evec-slice.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Frun-pass%2Fevec-slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Frun-pass%2Fevec-slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fevec-slice.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -10,8 +10,6 @@\n \n #![allow(dead_assignment)]\n \n-extern crate debug;\n-\n pub fn main() {\n     let x : &[int] = &[1,2,3,4,5];\n     let mut z : &[int] = &[1,2,3,4,5];\n@@ -24,15 +22,15 @@ pub fn main() {\n     let c : &[int] = &[2,2,2,2,3];\n     let cc : &[int] = &[2,2,2,2,2,2];\n \n-    println!(\"{:?}\", a);\n+    println!(\"{}\", a);\n \n     assert!(a < b);\n     assert!(a <= b);\n     assert!(a != b);\n     assert!(b >= a);\n     assert!(b > a);\n \n-    println!(\"{:?}\", b);\n+    println!(\"{}\", b);\n \n     assert!(b < c);\n     assert!(b <= c);\n@@ -46,13 +44,13 @@ pub fn main() {\n     assert!(c >= a);\n     assert!(c > a);\n \n-    println!(\"{:?}\", c);\n+    println!(\"{}\", c);\n \n     assert!(a < cc);\n     assert!(a <= cc);\n     assert!(a != cc);\n     assert!(cc >= a);\n     assert!(cc > a);\n \n-    println!(\"{:?}\", cc);\n+    println!(\"{}\", cc);\n }"}, {"sha": "3b7c5083bb48ef1a42e820d111b6db91882f2288", "filename": "src/test/run-pass/fixed_length_vec_glue.rs", "status": "removed", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/b6e0d3a5bf4c88650a22f605f822e02c6b163580/src%2Ftest%2Frun-pass%2Ffixed_length_vec_glue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6e0d3a5bf4c88650a22f605f822e02c6b163580/src%2Ftest%2Frun-pass%2Ffixed_length_vec_glue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffixed_length_vec_glue.rs?ref=b6e0d3a5bf4c88650a22f605f822e02c6b163580", "patch": "@@ -1,22 +0,0 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-extern crate debug;\n-\n-use debug::repr;\n-\n-struct Struc { a: u8, b: [int, ..3], c: int }\n-\n-pub fn main() {\n-    let arr = [1,2,3];\n-    let struc = Struc {a: 13u8, b: arr, c: 42};\n-    let s = repr::repr_to_string(&struc);\n-    assert_eq!(s, \"Struc{a: 13u8, b: [1, 2, 3], c: 42}\".to_string());\n-}"}, {"sha": "22d54162c430c9a17422a8b07d8150745f53ce4a", "filename": "src/test/run-pass/float.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Frun-pass%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Frun-pass%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffloat.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -8,11 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-extern crate debug;\n-\n pub fn main() {\n     let pi = 3.1415927f64;\n-    println!(\"{:?}\", -pi * (pi + 2.0 / pi) - pi * 5.0);\n+    println!(\"{}\", -pi * (pi + 2.0 / pi) - pi * 5.0);\n     if pi == 5.0 || pi < 10.0 || pi <= 2.0 || pi != 22.0 / 7.0 || pi >= 10.0\n            || pi > 1.0 {\n         println!(\"yes\");"}, {"sha": "2122759b3d3ee963224146f00e00c264e0745fed", "filename": "src/test/run-pass/format-ref-cell.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Frun-pass%2Fformat-ref-cell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Frun-pass%2Fformat-ref-cell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fformat-ref-cell.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -8,13 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-extern crate debug;\n-\n use std::cell::RefCell;\n \n pub fn main() {\n     let name = RefCell::new(\"rust\");\n     let what = RefCell::new(\"rocks\");\n-    let msg = format!(\"{name:?} {:?}\", &*what.borrow(), name=&*name.borrow());\n-    assert_eq!(msg, \"&\\\"rust\\\" &\\\"rocks\\\"\".to_string());\n+    let msg = format!(\"{name} {}\", &*what.borrow(), name=&*name.borrow());\n+    assert_eq!(msg, \"rust rocks\".to_string());\n }"}, {"sha": "a8d0c7d44fd2b2ebab636e9f1a903049c22cc038", "filename": "src/test/run-pass/functional-struct-upd.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Frun-pass%2Ffunctional-struct-upd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Frun-pass%2Ffunctional-struct-upd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffunctional-struct-upd.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -8,8 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-extern crate debug;\n-\n+#[deriving(Show)]\n struct Foo {\n     x: int,\n     y: int\n@@ -18,5 +17,5 @@ struct Foo {\n pub fn main() {\n     let a = Foo { x: 1, y: 2 };\n     let c = Foo { x: 4, .. a};\n-    println!(\"{:?}\", c);\n+    println!(\"{}\", c);\n }"}, {"sha": "8b5dfb6cf75a0223ec9e2de66f9821fe45199e23", "filename": "src/test/run-pass/generic-alias-unique.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Frun-pass%2Fgeneric-alias-unique.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Frun-pass%2Fgeneric-alias-unique.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-alias-unique.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -8,13 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-extern crate debug;\n-\n fn id<T:Send>(t: T) -> T { return t; }\n \n pub fn main() {\n     let expected = box 100i;\n     let actual = id::<Box<int>>(expected.clone());\n-    println!(\"{:?}\", *actual);\n+    println!(\"{}\", *actual);\n     assert_eq!(*expected, *actual);\n }"}, {"sha": "177455515dd71a6cccb5cadc388d473940f1ffbe", "filename": "src/test/run-pass/generic-derived-type.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Frun-pass%2Fgeneric-derived-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Frun-pass%2Fgeneric-derived-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-derived-type.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-extern crate debug;\n-\n fn g<X>(x: X) -> X { return x; }\n \n #[deriving(Clone)]\n@@ -25,8 +23,8 @@ fn f<T:Clone>(t: T) -> Pair<T> {\n \n pub fn main() {\n     let b = f::<int>(10);\n-    println!(\"{:?}\" ,b.a);\n-    println!(\"{:?}\", b.b);\n+    println!(\"{}\" ,b.a);\n+    println!(\"{}\", b.b);\n     assert_eq!(b.a, 10);\n     assert_eq!(b.b, 10);\n }"}, {"sha": "e1a8ad7c20ab0acc923271486a1a6c255b464f21", "filename": "src/test/run-pass/generic-fn-unique.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Frun-pass%2Fgeneric-fn-unique.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Frun-pass%2Fgeneric-fn-unique.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-fn-unique.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-extern crate debug;\n-\n fn f<T>(x: Box<T>) -> Box<T> { return x; }\n \n-pub fn main() { let x = f(box 3i); println!(\"{:?}\", *x); }\n+pub fn main() { let x = f(box 3i); println!(\"{}\", *x); }"}, {"sha": "26b9afcea8f3e9aa67c441c13686a2d59cec622a", "filename": "src/test/run-pass/generic-tag-values.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Frun-pass%2Fgeneric-tag-values.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Frun-pass%2Fgeneric-tag-values.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-tag-values.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -8,20 +8,18 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-extern crate debug;\n-\n enum noption<T> { some(T), }\n \n struct Pair { x: int, y: int }\n \n pub fn main() {\n     let nop: noption<int> = some::<int>(5);\n-    match nop { some::<int>(n) => { println!(\"{:?}\", n); assert!((n == 5)); } }\n+    match nop { some::<int>(n) => { println!(\"{}\", n); assert!((n == 5)); } }\n     let nop2: noption<Pair> = some(Pair{x: 17, y: 42});\n     match nop2 {\n       some(t) => {\n-        println!(\"{:?}\", t.x);\n-        println!(\"{:?}\", t.y);\n+        println!(\"{}\", t.x);\n+        println!(\"{}\", t.y);\n         assert_eq!(t.x, 17);\n         assert_eq!(t.y, 42);\n       }"}, {"sha": "dc9a90f7025e3405f91993dfc2b9f7724300b40c", "filename": "src/test/run-pass/generic-tup.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Frun-pass%2Fgeneric-tup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Frun-pass%2Fgeneric-tup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-tup.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -8,12 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-extern crate debug;\n-\n fn get_third<T>(t: (T, T, T)) -> T { let (_, _, x) = t; return x; }\n \n pub fn main() {\n-    println!(\"{:?}\", get_third((1i, 2i, 3i)));\n+    println!(\"{}\", get_third((1i, 2i, 3i)));\n     assert_eq!(get_third((1i, 2i, 3i)), 3);\n     assert_eq!(get_third((5u8, 6u8, 7u8)), 7u8);\n }"}, {"sha": "afa4b7a1ad0be5a747de69a0ee2e6076f843fb86", "filename": "src/test/run-pass/getopts_ref.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Frun-pass%2Fgetopts_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Frun-pass%2Fgetopts_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgetopts_ref.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n extern crate getopts;\n-extern crate debug;\n \n use getopts::{optopt, getopts};\n "}, {"sha": "8ff89ae2cde2667f14d0ca9db17be555430b191c", "filename": "src/test/run-pass/hashmap-memory.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -11,7 +11,6 @@\n \n \n extern crate collections;\n-extern crate debug;\n \n /**\n    A somewhat reduced test case to expose some Valgrind issues.\n@@ -56,7 +55,7 @@ mod map_reduce {\n             ctrl.send(find_reducer(Vec::from_slice(key.as_bytes()), tx));\n             println!(\"receiving\");\n             let c = rx.recv();\n-            println!(\"{:?}\", c);\n+            println!(\"{}\", c);\n             im.insert(key, c);\n         }\n "}, {"sha": "bfe3e9beddc54c4a33718376c9a7d447a0a9f1dc", "filename": "src/test/run-pass/if-bot.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Frun-pass%2Fif-bot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Frun-pass%2Fif-bot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fif-bot.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -8,9 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-extern crate debug;\n-\n pub fn main() {\n     let i: int = if false { fail!() } else { 5 };\n-    println!(\"{:?}\", i);\n+    println!(\"{}\", i);\n }"}, {"sha": "b384d7c55835234d5bf587b647a315a5f29cb20d", "filename": "src/test/run-pass/ifmt.rs", "status": "modified", "additions": 3, "deletions": 10, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Frun-pass%2Fifmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Frun-pass%2Fifmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fifmt.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -15,8 +15,6 @@\n #![deny(warnings)]\n #![allow(unused_must_use)]\n \n-extern crate debug;\n-\n use std::fmt;\n use std::io::MemWriter;\n use std::io;\n@@ -45,11 +43,6 @@ impl fmt::Show for C {\n macro_rules! t(($a:expr, $b:expr) => { assert_eq!($a.as_slice(), $b) })\n \n pub fn main() {\n-    // Make sure there's a poly formatter that takes anything\n-    t!(format!(\"{:?}\", 1i), \"1\");\n-    t!(format!(\"{:?}\", A), \"A\");\n-    t!(format!(\"{:?}\", ()), \"()\");\n-\n     // Various edge cases without formats\n     t!(format!(\"\"), \"\");\n     t!(format!(\"hello\"), \"hello\");\n@@ -148,8 +141,8 @@ pub fn main() {\n \n     // make sure that format! doesn't move out of local variables\n     let a = box 3i;\n-    format!(\"{:?}\", a);\n-    format!(\"{:?}\", a);\n+    format!(\"{}\", a);\n+    format!(\"{}\", a);\n \n     // make sure that format! doesn't cause spurious unused-unsafe warnings when\n     // it's inside of an outer unsafe block\n@@ -186,7 +179,7 @@ fn test_write() {\n // can do with them just yet (to test the output)\n fn test_print() {\n     print!(\"hi\");\n-    print!(\"{:?}\", vec!(0u8));\n+    print!(\"{}\", vec!(0u8));\n     println!(\"hello\");\n     println!(\"this is a {}\", \"test\");\n     println!(\"{foo}\", foo=\"bar\");"}, {"sha": "3470b54ccbbbc333d31ba6d34cedd855bd40a95f", "filename": "src/test/run-pass/import.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Frun-pass%2Fimport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Frun-pass%2Fimport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fimport.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -8,10 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-extern crate debug;\n-\n mod foo {\n-    pub fn x(y: int) { println!(\"{:?}\", y); }\n+    pub fn x(y: int) { println!(\"{}\", y); }\n }\n \n mod bar {"}, {"sha": "ac7a55ee405882a28f187369e362a24db5832736", "filename": "src/test/run-pass/issue-13434.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Frun-pass%2Fissue-13434.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Frun-pass%2Fissue-13434.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-13434.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -8,8 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-extern crate debug;\n-\n+#[deriving(Show)]\n struct MyStruct;\n \n trait Repro {\n@@ -27,5 +26,5 @@ fn do_stuff<R: Repro>(r: R) -> String {\n }\n \n pub fn main() {\n-  assert_eq!(\"MyStruct\".to_string(), do_stuff(|s: MyStruct| format!(\"{:?}\", s)));\n+  assert_eq!(\"MyStruct\".to_string(), do_stuff(|s: MyStruct| format!(\"{}\", s)));\n }"}, {"sha": "e69738d4caab979fea1ba4954cd0c0b7f92b2243", "filename": "src/test/run-pass/issue-1696.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Frun-pass%2Fissue-1696.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Frun-pass%2Fissue-1696.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-1696.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -9,12 +9,11 @@\n // except according to those terms.\n \n extern crate collections;\n-extern crate debug;\n \n use std::collections::HashMap;\n \n pub fn main() {\n     let mut m = HashMap::new();\n     m.insert(b\"foo\".to_vec(), b\"bar\".to_vec());\n-    println!(\"{:?}\", m);\n+    println!(\"{}\", m);\n }"}, {"sha": "ec0cb488c685bf517876437c2e0f78e2754fa35e", "filename": "src/test/run-pass/issue-17737.rs", "status": "removed", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/b6e0d3a5bf4c88650a22f605f822e02c6b163580/src%2Ftest%2Frun-pass%2Fissue-17737.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6e0d3a5bf4c88650a22f605f822e02c6b163580/src%2Ftest%2Frun-pass%2Fissue-17737.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-17737.rs?ref=b6e0d3a5bf4c88650a22f605f822e02c6b163580", "patch": "@@ -1,24 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#![feature(unboxed_closures)]\n-\n-// Test generating type visitor glue for unboxed closures\n-\n-extern crate debug;\n-\n-fn main() {\n-    let expected = \"fn(); fn(uint, uint) -> uint; fn() -> !\";\n-    let result = format!(\"{:?}; {:?}; {:?}\",\n-                         |:| {},\n-                         |&: x: uint, y: uint| { x + y },\n-                         |&mut:| -> ! { fail!() });\n-    assert_eq!(expected, result.as_slice());\n-}"}, {"sha": "98e6e05134320e63f0173dda197867c45690f8ed", "filename": "src/test/run-pass/issue-2216.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Frun-pass%2Fissue-2216.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Frun-pass%2Fissue-2216.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2216.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-extern crate debug;\n-\n pub fn main() {\n     let mut x = 0i;\n \n@@ -29,6 +27,6 @@ pub fn main() {\n         break;\n     }\n \n-    println!(\"{:?}\", x);\n+    println!(\"{}\", x);\n     assert_eq!(x, 42);\n }"}, {"sha": "32fefac52ebeb978a5ffd2631978bf92c7cb8195", "filename": "src/test/run-pass/issue-2804-2.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Frun-pass%2Fissue-2804-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Frun-pass%2Fissue-2804-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2804-2.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -13,12 +13,11 @@\n // clobber the previous node ID in a macro expr\n \n extern crate collections;\n-extern crate debug;\n \n use std::collections::HashMap;\n \n fn add_interfaces(managed_ip: String, device: HashMap<String, int>)  {\n-     println!(\"{}, {:?}\", managed_ip, device.get(&\"interfaces\".to_string()));\n+     println!(\"{}, {}\", managed_ip, device.get(&\"interfaces\".to_string()));\n }\n \n pub fn main() {}"}, {"sha": "7228f12c030a121637f87cc9a4e0643006f471a5", "filename": "src/test/run-pass/issue-2804.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Frun-pass%2Fissue-2804.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Frun-pass%2Fissue-2804.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2804.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -11,7 +11,6 @@\n \n extern crate collections;\n extern crate serialize;\n-extern crate debug;\n \n use std::collections::HashMap;\n use serialize::json;\n@@ -29,7 +28,7 @@ fn lookup(table: json::JsonObject, key: String, default: String) -> String\n             s.to_string()\n         }\n         option::Some(value) => {\n-            println!(\"{} was expected to be a string but is a {:?}\", key, value);\n+            println!(\"{} was expected to be a string but is a {}\", key, value);\n             default\n         }\n         option::None => {\n@@ -50,7 +49,7 @@ fn add_interface(_store: int, managed_ip: String, data: json::Json) -> (String,\n             (label, bool_value(false))\n         }\n         _ => {\n-            println!(\"Expected dict for {} interfaces, found {:?}\", managed_ip, data);\n+            println!(\"Expected dict for {} interfaces, found {}\", managed_ip, data);\n             (\"gnos:missing-interface\".to_string(), bool_value(true))\n         }\n     }\n@@ -68,7 +67,7 @@ fn add_interfaces(store: int, managed_ip: String, device: HashMap<String, json::\n         }\n         _ =>\n         {\n-            println!(\"Expected list for {} interfaces, found {:?}\", managed_ip,\n+            println!(\"Expected list for {} interfaces, found {}\", managed_ip,\n                    device.get(&\"interfaces\".to_string()));\n             Vec::new()\n         }"}, {"sha": "01bfdddd285704acaee60f69c38793296588a0bc", "filename": "src/test/run-pass/issue-2904.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Frun-pass%2Fissue-2904.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Frun-pass%2Fissue-2904.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2904.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -10,8 +10,6 @@\n // except according to those terms.\n \n \n-extern crate debug;\n-\n /// Map representation\n \n use std::io;\n@@ -54,7 +52,7 @@ fn square_from_char(c: char) -> square {\n       '.'  => { earth }\n       ' '  => { empty }\n       _ => {\n-        println!(\"invalid square: {:?}\", c);\n+        println!(\"invalid square: {}\", c);\n         fail!()\n       }\n     }"}, {"sha": "86913c0e8d4fd4b3938bf8f54d8ec7f52530dbe9", "filename": "src/test/run-pass/issue-3109.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Frun-pass%2Fissue-3109.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Frun-pass%2Fissue-3109.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3109.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-extern crate debug;\n-\n pub fn main() {\n-    println!(\"{:?}\", (\"hi there!\", \"you\"));\n+    println!(\"{}\", (\"hi there!\", \"you\"));\n }"}, {"sha": "f32564e8b750365e30a0a2a33888385df5dd35d6", "filename": "src/test/run-pass/issue-3794.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Frun-pass%2Fissue-3794.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Frun-pass%2Fissue-3794.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3794.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -8,19 +8,18 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-extern crate debug;\n-\n trait T {\n     fn print(&self);\n }\n \n+#[deriving(Show)]\n struct S {\n     s: int,\n }\n \n impl T for S {\n     fn print(&self) {\n-        println!(\"{:?}\", self);\n+        println!(\"{}\", self);\n     }\n }\n "}, {"sha": "d8c08f8ac321487967b097190bd5d245921e356f", "filename": "src/test/run-pass/issue-4241.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Frun-pass%2Fissue-4241.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Frun-pass%2Fissue-4241.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-4241.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -119,7 +119,7 @@ fn query2(cmd: ~[String]) -> Result {\n   let _cmd = cmd_to_string(cmd);\n     io::with_str_reader(\"$3\\r\\nXXX\\r\\n\".to_string())(|sb| {\n     let res = parse_response(@sb as @io::Reader);\n-    println!(\"{:?}\", res);\n+    println!(\"{}\", res);\n     res\n     });\n }"}, {"sha": "04b1cbf577db95a1776c1d6f9aef73e5c7196844", "filename": "src/test/run-pass/issue-4252.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Frun-pass%2Fissue-4252.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Frun-pass%2Fissue-4252.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-4252.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -10,29 +10,29 @@\n \n #![feature(unsafe_destructor)]\n \n-extern crate debug;\n-\n trait X {\n-    fn call<T>(&self, x: &T);\n-    fn default_method<T>(&self, x: &T) {\n-        println!(\"X::default_method {:?} {:?}\", self, x);\n+    fn call<T: std::fmt::Show>(&self, x: &T);\n+    fn default_method<T: std::fmt::Show>(&self, x: &T) {\n+        println!(\"X::default_method {}\", x);\n     }\n }\n \n+#[deriving(Show)]\n struct Y(int);\n \n+#[deriving(Show)]\n struct Z<T> {\n     x: T\n }\n \n impl X for Y {\n-    fn call<T>(&self, x: &T) {\n-        println!(\"X::call {:?} {:?}\", self, x);\n+    fn call<T: std::fmt::Show>(&self, x: &T) {\n+        println!(\"X::call {} {}\", self, x);\n     }\n }\n \n #[unsafe_destructor]\n-impl<T: X> Drop for Z<T> {\n+impl<T: X + std::fmt::Show> Drop for Z<T> {\n     fn drop(&mut self) {\n         // These statements used to cause an ICE.\n         self.x.call(self);"}, {"sha": "73bf375923a74061175250eb79d5cb2ce76cc593", "filename": "src/test/run-pass/issue-5688.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Frun-pass%2Fissue-5688.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Frun-pass%2Fissue-5688.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-5688.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -17,12 +17,10 @@ with the representation of [int, ..n] and [int] somehow, or at least\n failed to typecheck correctly.\n */\n \n-extern crate debug;\n-\n struct X { vec: &'static [int] }\n static V: &'static [X] = &[X { vec: &[1, 2, 3] }];\n pub fn main() {\n     for &v in V.iter() {\n-        println!(\"{:?}\", v.vec);\n+        println!(\"{}\", v.vec);\n     }\n }"}, {"sha": "65ee062a0396078f4b38fecaedb89138bb9c94bd", "filename": "src/test/run-pass/issue-6344-let.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Frun-pass%2Fissue-6344-let.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Frun-pass%2Fissue-6344-let.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-6344-let.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-extern crate debug;\n-\n struct A { x: uint }\n \n impl Drop for A {\n@@ -20,5 +18,5 @@ pub fn main() {\n     let a = A { x: 0 };\n \n     let A { x: ref x } = a;\n-    println!(\"{:?}\", x)\n+    println!(\"{}\", x)\n }"}, {"sha": "ee99ec957b5a6c4a62632a4112e82aec23411b22", "filename": "src/test/run-pass/issue-6344-match.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Frun-pass%2Fissue-6344-match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Frun-pass%2Fissue-6344-match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-6344-match.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-extern crate debug;\n-\n struct A { x: uint }\n \n impl Drop for A {\n@@ -21,7 +19,7 @@ pub fn main() {\n \n     match a {\n         A { x : ref x } => {\n-            println!(\"{:?}\", x)\n+            println!(\"{}\", x)\n         }\n     }\n }"}, {"sha": "73697b2bdb88927d6d16af90f533cad220159b26", "filename": "src/test/run-pass/issue-7563.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Frun-pass%2Fissue-7563.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Frun-pass%2Fissue-7563.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-7563.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -8,13 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-extern crate debug;\n-\n trait IDummy {\n     fn do_nothing(&self);\n }\n \n+#[deriving(Show)]\n struct A { a: int }\n+#[deriving(Show)]\n struct B<'a> { b: int, pa: &'a A }\n \n     impl IDummy for A {\n@@ -31,7 +31,6 @@ pub fn main() {\n     let sa = A { a: 100 };\n     let sb = B { b: 200, pa: &sa };\n \n-    println!(\"sa is {:?}\", sa);\n-    println!(\"sb is {:?}\", sb);\n-    println!(\"sb.pa is {:?}\", sb.get_pa());\n+    println!(\"sa is {}\", sa);\n+    println!(\"sb is {}\", sb);\n }"}, {"sha": "305f984f98efbffac47982b6bbeb15052de1754d", "filename": "src/test/run-pass/issue-8898.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Frun-pass%2Fissue-8898.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Frun-pass%2Fissue-8898.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-8898.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -10,10 +10,8 @@\n \n #![feature(slicing_syntax)]\n \n-extern crate debug;\n-\n-fn assert_repr_eq<T>(obj : T, expected : String) {\n-    assert_eq!(expected, format!(\"{:?}\", obj));\n+fn assert_repr_eq<T: std::fmt::Show>(obj : T, expected : String) {\n+    assert_eq!(expected, format!(\"{}\", obj));\n }\n \n pub fn main() {\n@@ -22,9 +20,9 @@ pub fn main() {\n     let x  = [(), ()];\n     let slice = x[0..1];\n \n-    assert_repr_eq(abc, \"[1, 2, 3]\".to_string());\n-    assert_repr_eq(tf, \"[true, false]\".to_string());\n-    assert_repr_eq(x, \"[(), ()]\".to_string());\n-    assert_repr_eq(slice, \"&[()]\".to_string());\n-    assert_repr_eq(&x, \"&[(), ()]\".to_string());\n+    assert_repr_eq(abc[], \"[1, 2, 3]\".to_string());\n+    assert_repr_eq(tf[], \"[true, false]\".to_string());\n+    assert_repr_eq(x[], \"[(), ()]\".to_string());\n+    assert_repr_eq(slice, \"[()]\".to_string());\n+    assert_repr_eq(x[], \"[(), ()]\".to_string());\n }"}, {"sha": "1f385b2fb1589861a030333a97a6887bdb6768d9", "filename": "src/test/run-pass/issue-9737.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Frun-pass%2Fissue-9737.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Frun-pass%2Fissue-9737.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-9737.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -12,7 +12,7 @@\n \n #![feature(macro_rules)]\n \n-macro_rules! f((v: $x:expr) => ( println!(\"{:?}\", $x) ))\n+macro_rules! f((v: $x:expr) => ( println!(\"{}\", $x) ))\n \n fn main () {\n     let v = 5;"}, {"sha": "6d5624e2b588004a379797216a33e1a92dbc18fc", "filename": "src/test/run-pass/last-use-is-capture.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Frun-pass%2Flast-use-is-capture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Frun-pass%2Flast-use-is-capture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flast-use-is-capture.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -10,13 +10,11 @@\n \n // Make sure #1399 stays fixed\n \n-extern crate debug;\n-\n struct A { a: Box<int> }\n \n pub fn main() {\n     fn invoke(f: ||) { f(); }\n     let k = box 22i;\n     let _u = A {a: k.clone()};\n-    invoke(|| println!(\"{:?}\", k.clone()) )\n+    invoke(|| println!(\"{}\", k.clone()) )\n }"}, {"sha": "043961ce59969b27cbad34a31d80116d237b7d02", "filename": "src/test/run-pass/lazy-and-or.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Frun-pass%2Flazy-and-or.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Frun-pass%2Flazy-and-or.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flazy-and-or.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -8,15 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-extern crate debug;\n-\n fn incr(x: &mut int) -> bool { *x += 1; assert!((false)); return false; }\n \n pub fn main() {\n     let x = 1i == 2 || 3i == 3;\n     assert!((x));\n     let mut y: int = 10;\n-    println!(\"{:?}\", x || incr(&mut y));\n+    println!(\"{}\", x || incr(&mut y));\n     assert_eq!(y, 10);\n     if true && x { assert!((true)); } else { assert!((false)); }\n }"}, {"sha": "f527ad77a9273d3112e43e76557b3950752a8a63", "filename": "src/test/run-pass/linear-for-loop.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Frun-pass%2Flinear-for-loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Frun-pass%2Flinear-for-loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flinear-for-loop.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -10,13 +10,11 @@\n \n // no-pretty-expanded FIXME #15189\n \n-extern crate debug;\n-\n pub fn main() {\n     let x = vec!(1i, 2i, 3i);\n     let mut y = 0i;\n-    for i in x.iter() { println!(\"{:?}\", *i); y += *i; }\n-    println!(\"{:?}\", y);\n+    for i in x.iter() { println!(\"{}\", *i); y += *i; }\n+    println!(\"{}\", y);\n     assert_eq!(y, 6);\n     let s = \"hello there\".to_string();\n     let mut i: int = 0;\n@@ -29,8 +27,8 @@ pub fn main() {\n         // ...\n \n         i += 1;\n-        println!(\"{:?}\", i);\n-        println!(\"{:?}\", c);\n+        println!(\"{}\", i);\n+        println!(\"{}\", c);\n     }\n     assert_eq!(i, 11);\n }"}, {"sha": "3d8eaeea618d02f10d35e595d6fa80a47e4e9421", "filename": "src/test/run-pass/log-knows-the-names-of-variants-in-std.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Frun-pass%2Flog-knows-the-names-of-variants-in-std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Frun-pass%2Flog-knows-the-names-of-variants-in-std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flog-knows-the-names-of-variants-in-std.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -8,28 +8,26 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-extern crate debug;\n-\n-#[deriving(Clone)]\n+#[deriving(Clone, Show)]\n enum foo {\n   a(uint),\n   b(String),\n }\n \n-fn check_log<T>(exp: String, v: T) {\n-    assert_eq!(exp, format!(\"{:?}\", v));\n+fn check_log<T: std::fmt::Show>(exp: String, v: T) {\n+    assert_eq!(exp, format!(\"{}\", v));\n }\n \n pub fn main() {\n     let mut x = Some(a(22u));\n-    let exp = \"Some(a(22u))\".to_string();\n-    let act = format!(\"{:?}\", x);\n+    let exp = \"Some(a(22))\".to_string();\n+    let act = format!(\"{}\", x);\n     assert_eq!(act, exp);\n     check_log(exp, x);\n \n     x = None;\n     let exp = \"None\".to_string();\n-    let act = format!(\"{:?}\", x);\n+    let act = format!(\"{}\", x);\n     assert_eq!(act, exp);\n     check_log(exp, x);\n }"}, {"sha": "8445f3e3160034c69d837bb69d8fe766c8f43eda", "filename": "src/test/run-pass/log-knows-the-names-of-variants.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Frun-pass%2Flog-knows-the-names-of-variants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Frun-pass%2Flog-knows-the-names-of-variants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flog-knows-the-names-of-variants.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -8,20 +8,20 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-extern crate debug;\n-\n+#[deriving(Show)]\n enum foo {\n   a(uint),\n   b(String),\n   c,\n }\n \n+#[deriving(Show)]\n enum bar {\n   d, e, f\n }\n \n pub fn main() {\n-    assert_eq!(\"a(22u)\".to_string(), format!(\"{:?}\", a(22u)));\n-    assert_eq!(\"c\".to_string(), format!(\"{:?}\", c));\n-    assert_eq!(\"d\".to_string(), format!(\"{:?}\", d));\n+    assert_eq!(\"a(22)\".to_string(), format!(\"{}\", a(22u)));\n+    assert_eq!(\"c\".to_string(), format!(\"{}\", c));\n+    assert_eq!(\"d\".to_string(), format!(\"{}\", d));\n }"}, {"sha": "cf733fe48932a5377418b3206232b65fb91770f5", "filename": "src/test/run-pass/log-poly.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Frun-pass%2Flog-poly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Frun-pass%2Flog-poly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flog-poly.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -8,15 +8,14 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-extern crate debug;\n-\n+#[deriving(Show)]\n enum Numbers {\n     Three\n }\n \n pub fn main() {\n     println!(\"{}\", 1i);\n     println!(\"{}\", 2.0f64);\n-    println!(\"{:?}\", Three);\n-    println!(\"{:?}\", vec!(4i));\n+    println!(\"{}\", Three);\n+    println!(\"{}\", vec!(4i));\n }"}, {"sha": "5c834a06a74dbf4cfbca3c7ceb20549303527767", "filename": "src/test/run-pass/match-unique-bind.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Frun-pass%2Fmatch-unique-bind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Frun-pass%2Fmatch-unique-bind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmatch-unique-bind.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -8,12 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-extern crate debug;\n-\n pub fn main() {\n     match box 100i {\n       box x => {\n-        println!(\"{:?}\", x);\n+        println!(\"{}\", x);\n         assert_eq!(x, 100);\n       }\n     }"}, {"sha": "fa28025afa077b3b0fa6cf9a80bff8b76dfde34e", "filename": "src/test/run-pass/nested-matchs.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Frun-pass%2Fnested-matchs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Frun-pass%2Fnested-matchs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnested-matchs.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -8,16 +8,14 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-extern crate debug;\n-\n fn baz() -> ! { fail!(); }\n \n fn foo() {\n     match Some::<int>(5) {\n       Some::<int>(_x) => {\n         let mut bar;\n         match None::<int> { None::<int> => { bar = 5i; } _ => { baz(); } }\n-        println!(\"{:?}\", bar);\n+        println!(\"{}\", bar);\n       }\n       None::<int> => { println!(\"hello\"); }\n     }"}, {"sha": "4cd8e65e5002de19edf4a5750766f17e39fca22d", "filename": "src/test/run-pass/over-constrained-vregs.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Frun-pass%2Fover-constrained-vregs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Frun-pass%2Fover-constrained-vregs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fover-constrained-vregs.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -8,14 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-extern crate debug;\n-\n // Regression test for issue #152.\n pub fn main() {\n     let mut b: uint = 1u;\n     while b <= 32u {\n         0u << b;\n         b <<= 1u;\n-        println!(\"{:?}\", b);\n+        println!(\"{}\", b);\n     }\n }"}, {"sha": "d047f02fe2f6585c5d96c134d09c60a0ec463953", "filename": "src/test/run-pass/overload-index-operator.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Frun-pass%2Foverload-index-operator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Frun-pass%2Foverload-index-operator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Foverload-index-operator.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -11,8 +11,6 @@\n // Test overloading of the `[]` operator.  In particular test that it\n // takes its argument *by reference*.\n \n-extern crate debug;\n-\n use std::ops::Index;\n \n struct AssociationList<K,V> {\n@@ -30,14 +28,14 @@ impl<K,V> AssociationList<K,V> {\n     }\n }\n \n-impl<K:PartialEq,V:Clone> Index<K,V> for AssociationList<K,V> {\n+impl<K: PartialEq + std::fmt::Show, V:Clone> Index<K,V> for AssociationList<K,V> {\n     fn index<'a>(&'a self, index: &K) -> &'a V {\n         for pair in self.pairs.iter() {\n             if pair.key == *index {\n                 return &pair.value\n             }\n         }\n-        fail!(\"No value found for key: {:?}\", index);\n+        fail!(\"No value found for key: {}\", index);\n     }\n }\n "}, {"sha": "ce8c5df07401214b01f950c9890fed5d21be28b6", "filename": "src/test/run-pass/rec-align-u32.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Frun-pass%2Frec-align-u32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Frun-pass%2Frec-align-u32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frec-align-u32.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -12,8 +12,6 @@\n \n #![feature(intrinsics)]\n \n-extern crate debug;\n-\n use std::mem;\n \n mod rusti {\n@@ -24,12 +22,14 @@ mod rusti {\n }\n \n // This is the type with the questionable alignment\n+#[deriving(Show)]\n struct Inner {\n     c64: u32\n }\n \n // This is the type that contains the type with the\n // questionable alignment, for testing\n+#[deriving(Show)]\n struct Outer {\n     c8: u8,\n     t: Inner\n@@ -53,10 +53,10 @@ pub fn main() {\n         let x = Outer {c8: 22u8, t: Inner {c64: 44u32}};\n \n         // Send it through the shape code\n-        let y = format!(\"{:?}\", x);\n+        let y = format!(\"{}\", x);\n \n-        println!(\"align inner = {:?}\", rusti::min_align_of::<Inner>());\n-        println!(\"size outer = {:?}\", mem::size_of::<Outer>());\n+        println!(\"align inner = {}\", rusti::min_align_of::<Inner>());\n+        println!(\"size outer = {}\", mem::size_of::<Outer>());\n         println!(\"y = {}\", y);\n \n         // per clang/gcc the alignment of `inner` is 4 on x86.\n@@ -66,6 +66,6 @@ pub fn main() {\n         // because `inner`s alignment was 4.\n         assert_eq!(mem::size_of::<Outer>(), m::size());\n \n-        assert_eq!(y, \"Outer{c8: 22u8, t: Inner{c64: 44u32}}\".to_string());\n+        assert_eq!(y, \"Outer { c8: 22, t: Inner { c64: 44 } }\".to_string());\n     }\n }"}, {"sha": "c0c7f4c99be7358ec4ac94ee823b5cd330088feb", "filename": "src/test/run-pass/rec-align-u64.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Frun-pass%2Frec-align-u64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Frun-pass%2Frec-align-u64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frec-align-u64.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -12,8 +12,6 @@\n \n #![feature(intrinsics)]\n \n-extern crate debug;\n-\n use std::mem;\n \n mod rusti {\n@@ -24,12 +22,14 @@ mod rusti {\n }\n \n // This is the type with the questionable alignment\n+#[deriving(Show)]\n struct Inner {\n     c64: u64\n }\n \n // This is the type that contains the type with the\n // questionable alignment, for testing\n+#[deriving(Show)]\n struct Outer {\n     c8: u8,\n     t: Inner\n@@ -82,8 +82,7 @@ pub fn main() {\n     unsafe {\n         let x = Outer {c8: 22u8, t: Inner {c64: 44u64}};\n \n-        // Send it through the shape code\n-        let y = format!(\"{:?}\", x);\n+        let y = format!(\"{}\", x);\n \n         println!(\"align inner = {}\", rusti::min_align_of::<Inner>());\n         println!(\"size outer = {}\", mem::size_of::<Outer>());\n@@ -96,6 +95,6 @@ pub fn main() {\n         // because `Inner`s alignment was 4.\n         assert_eq!(mem::size_of::<Outer>(), m::m::size());\n \n-        assert_eq!(y, \"Outer{c8: 22u8, t: Inner{c64: 44u64}}\".to_string());\n+        assert_eq!(y, \"Outer { c8: 22, t: Inner { c64: 44 } }\".to_string());\n     }\n }"}, {"sha": "5de34dc2df5dfda40f0791fd26924b1076ef8f43", "filename": "src/test/run-pass/reflect-visit-type.rs", "status": "removed", "additions": 0, "deletions": 147, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/b6e0d3a5bf4c88650a22f605f822e02c6b163580/src%2Ftest%2Frun-pass%2Freflect-visit-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6e0d3a5bf4c88650a22f605f822e02c6b163580/src%2Ftest%2Frun-pass%2Freflect-visit-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Freflect-visit-type.rs?ref=b6e0d3a5bf4c88650a22f605f822e02c6b163580", "patch": "@@ -1,147 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-\n-use std::intrinsics::{TyDesc, get_tydesc, visit_tydesc, TyVisitor, Disr, Opaque};\n-\n-struct MyVisitor {\n-    types: Vec<String> ,\n-}\n-\n-impl TyVisitor for MyVisitor {\n-    fn visit_bot(&mut self) -> bool {\n-        self.types.push(\"bot\".to_string());\n-        println!(\"visited bot type\");\n-        true\n-    }\n-    fn visit_nil(&mut self) -> bool {\n-        self.types.push(\"nil\".to_string());\n-        println!(\"visited nil type\");\n-        true\n-    }\n-    fn visit_bool(&mut self) -> bool {\n-        self.types.push(\"bool\".to_string());\n-        println!(\"visited bool type\");\n-        true\n-    }\n-    fn visit_int(&mut self) -> bool {\n-        self.types.push(\"int\".to_string());\n-        println!(\"visited int type\");\n-        true\n-    }\n-    fn visit_i8(&mut self) -> bool {\n-        self.types.push(\"i8\".to_string());\n-        println!(\"visited i8 type\");\n-        true\n-    }\n-    fn visit_i16(&mut self) -> bool {\n-        self.types.push(\"i16\".to_string());\n-        println!(\"visited i16 type\");\n-        true\n-    }\n-    fn visit_i32(&mut self) -> bool { true }\n-    fn visit_i64(&mut self) -> bool { true }\n-\n-    fn visit_uint(&mut self) -> bool { true }\n-    fn visit_u8(&mut self) -> bool { true }\n-    fn visit_u16(&mut self) -> bool { true }\n-    fn visit_u32(&mut self) -> bool { true }\n-    fn visit_u64(&mut self) -> bool { true }\n-\n-    fn visit_f32(&mut self) -> bool { true }\n-    fn visit_f64(&mut self) -> bool { true }\n-\n-    fn visit_char(&mut self) -> bool { true }\n-\n-    fn visit_estr_slice(&mut self) -> bool { true }\n-\n-    fn visit_box(&mut self, _mtbl: uint, _inner: *const TyDesc) -> bool { true }\n-    fn visit_uniq(&mut self, _mtbl: uint, _inner: *const TyDesc) -> bool { true }\n-    fn visit_ptr(&mut self, _mtbl: uint, _inner: *const TyDesc) -> bool { true }\n-    fn visit_rptr(&mut self, _mtbl: uint, _inner: *const TyDesc) -> bool { true }\n-\n-    fn visit_evec_slice(&mut self, _mtbl: uint, _inner: *const TyDesc) -> bool { true }\n-    fn visit_evec_fixed(&mut self, _n: uint, _sz: uint, _align: uint,\n-                        _inner: *const TyDesc) -> bool { true }\n-\n-    fn visit_enter_rec(&mut self, _n_fields: uint,\n-                       _sz: uint, _align: uint) -> bool { true }\n-    fn visit_rec_field(&mut self, _i: uint, _name: &str,\n-                       _mtbl: uint, _inner: *const TyDesc) -> bool { true }\n-    fn visit_leave_rec(&mut self, _n_fields: uint,\n-                       _sz: uint, _align: uint) -> bool { true }\n-\n-    fn visit_enter_class(&mut self, _name: &str, _named_fields: bool, _n_fields: uint,\n-                         _sz: uint, _align: uint) -> bool { true }\n-    fn visit_class_field(&mut self, _i: uint, _name: &str, _named: bool,\n-                         _mtbl: uint, _inner: *const TyDesc) -> bool { true }\n-    fn visit_leave_class(&mut self, _name: &str, _named_fields: bool, _n_fields: uint,\n-                         _sz: uint, _align: uint) -> bool { true }\n-\n-    fn visit_enter_tup(&mut self, _n_fields: uint,\n-                       _sz: uint, _align: uint) -> bool { true }\n-    fn visit_tup_field(&mut self, _i: uint, _inner: *const TyDesc) -> bool { true }\n-    fn visit_leave_tup(&mut self, _n_fields: uint,\n-                       _sz: uint, _align: uint) -> bool { true }\n-\n-    fn visit_enter_enum(&mut self, _n_variants: uint,\n-                        _get_disr: unsafe extern fn(ptr: *const Opaque) -> Disr,\n-                        _sz: uint, _align: uint) -> bool { true }\n-    fn visit_enter_enum_variant(&mut self,\n-                                _variant: uint,\n-                                _disr_val: Disr,\n-                                _n_fields: uint,\n-                                _name: &str) -> bool { true }\n-    fn visit_enum_variant_field(&mut self, _i: uint, _offset: uint, _inner: *const TyDesc)\n-        -> bool { true }\n-    fn visit_leave_enum_variant(&mut self,\n-                                _variant: uint,\n-                                _disr_val: Disr,\n-                                _n_fields: uint,\n-                                _name: &str) -> bool { true }\n-    fn visit_leave_enum(&mut self,\n-                        _n_variants: uint,\n-                        _get_disr: unsafe extern fn(ptr: *const Opaque) -> Disr,\n-                        _sz: uint, _align: uint) -> bool { true }\n-\n-    fn visit_enter_fn(&mut self, _purity: uint, _proto: uint,\n-                      _n_inputs: uint, _retstyle: uint) -> bool { true }\n-    fn visit_fn_input(&mut self, _i: uint, _mode: uint, _inner: *const TyDesc) -> bool { true }\n-    fn visit_fn_output(&mut self, _retstyle: uint, _variadic: bool, _inner: *const TyDesc)\n-        -> bool { true }\n-    fn visit_leave_fn(&mut self, _purity: uint, _proto: uint,\n-                      _n_inputs: uint, _retstyle: uint) -> bool { true }\n-\n-\n-    fn visit_trait(&mut self, _name: &str) -> bool { true }\n-    fn visit_param(&mut self, _i: uint) -> bool { true }\n-    fn visit_self(&mut self) -> bool { true }\n-}\n-\n-fn visit_ty<T>(v: &mut MyVisitor) {\n-    unsafe { visit_tydesc(get_tydesc::<T>(), v as &mut TyVisitor) }\n-}\n-\n-pub fn main() {\n-    let mut v = MyVisitor {types: Vec::new()};\n-\n-    visit_ty::<bool>(&mut v);\n-    visit_ty::<int>(&mut v);\n-    visit_ty::<i8>(&mut v);\n-    visit_ty::<i16>(&mut v);\n-\n-    for s in v.types.iter() {\n-        println!(\"type: {}\", (*s).clone());\n-    }\n-\n-    let vec_types: Vec<String> = v.types.clone().into_iter().collect();\n-    assert_eq!(vec_types, vec!(\"bool\".to_string(), \"int\".to_string(),\n-                               \"i8\".to_string(), \"i16\".to_string()));\n-}"}, {"sha": "b30b3cfa47695f6049ce054486881086d3919a66", "filename": "src/test/run-pass/regions-self-impls.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Frun-pass%2Fregions-self-impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Frun-pass%2Fregions-self-impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-self-impls.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-extern crate debug;\n-\n struct Clam<'a> {\n     chowder: &'a int\n }\n@@ -24,6 +22,6 @@ impl<'a> get_chowder<'a> for Clam<'a> {\n \n pub fn main() {\n     let clam = Clam { chowder: &3 };\n-    println!(\"{:?}\", *clam.get_chowder());\n+    println!(\"{}\", *clam.get_chowder());\n     clam.get_chowder();\n }"}, {"sha": "987392c70e3cb062e5970cf8e054b88640386bdf", "filename": "src/test/run-pass/regions-self-in-enums.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Frun-pass%2Fregions-self-in-enums.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Frun-pass%2Fregions-self-in-enums.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-self-in-enums.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-extern crate debug;\n-\n enum int_wrapper<'a> {\n     int_wrapper_ctor(&'a int)\n }\n@@ -21,5 +19,5 @@ pub fn main() {\n     match y {\n         int_wrapper_ctor(zz) => { z = zz; }\n     }\n-    println!(\"{:?}\", *z);\n+    println!(\"{}\", *z);\n }"}, {"sha": "d540605180a4eea87041576a2ee7ff6659b8e66f", "filename": "src/test/run-pass/regions-simple.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Frun-pass%2Fregions-simple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Frun-pass%2Fregions-simple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-simple.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -8,11 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-extern crate debug;\n-\n pub fn main() {\n     let mut x: int = 3;\n     let y: &mut int = &mut x;\n     *y = 5;\n-    println!(\"{:?}\", *y);\n+    println!(\"{}\", *y);\n }"}, {"sha": "9c369c0d770c6a5a3142db4d6ee43f1ae9feebcc", "filename": "src/test/run-pass/repeated-vector-syntax.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Frun-pass%2Frepeated-vector-syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Frun-pass%2Frepeated-vector-syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frepeated-vector-syntax.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -8,13 +8,16 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n-extern crate debug;\n+#![feature(slicing_syntax)]\n \n pub fn main() {\n     let x = [ [true], ..512 ];\n     let y = [ 0i, ..1 ];\n \n-    println!(\"{:?}\", x);\n-    println!(\"{:?}\", y);\n+    print!(\"[\");\n+    for xi in x.iter() {\n+        print!(\"{}, \", (*xi)[]);\n+    }\n+    println!(\"]\");\n+    println!(\"{}\", y[]);\n }"}, {"sha": "9f553cd2a0061f5917342f8f3fcade808fc46ad7", "filename": "src/test/run-pass/shadow.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Frun-pass%2Fshadow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Frun-pass%2Fshadow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fshadow.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-extern crate debug;\n-\n fn foo(c: Vec<int> ) {\n     let a: int = 5;\n     let mut b: Vec<int> = Vec::new();\n@@ -18,7 +16,7 @@ fn foo(c: Vec<int> ) {\n     match none::<int> {\n         some::<int>(_) => {\n             for _i in c.iter() {\n-                println!(\"{:?}\", a);\n+                println!(\"{}\", a);\n                 let a = 17i;\n                 b.push(a);\n             }"}, {"sha": "52fa8e1132e2fec927ad732a52c3ae37a0f1fe94", "filename": "src/test/run-pass/signal-exit-status.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Frun-pass%2Fsignal-exit-status.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Frun-pass%2Fsignal-exit-status.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsignal-exit-status.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -10,8 +10,6 @@\n \n // ignore-windows\n \n-extern crate debug;\n-\n use std::os;\n use std::io::process::{Command, ExitSignal, ExitStatus};\n \n@@ -27,7 +25,7 @@ pub fn main() {\n         match status {\n             ExitSignal(_) if cfg!(unix) => {},\n             ExitStatus(0xC0000028) if cfg!(windows) => {},\n-            _ => fail!(\"invalid termination (was not signalled): {:?}\", status)\n+            _ => fail!(\"invalid termination (was not signalled): {}\", status)\n         }\n     }\n }"}, {"sha": "1078359dc145e18d32f7ead14a4df7fa26a557b0", "filename": "src/test/run-pass/size-and-align.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Frun-pass%2Fsize-and-align.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Frun-pass%2Fsize-and-align.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsize-and-align.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -8,15 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-extern crate debug;\n-\n enum clam<T> { a(T, int), b, }\n \n fn uhoh<T>(v: Vec<clam<T>> ) {\n     match *v.get(1) {\n       a::<T>(ref _t, ref u) => {\n           println!(\"incorrect\");\n-          println!(\"{:?}\", u);\n+          println!(\"{}\", u);\n           fail!();\n       }\n       b::<T> => { println!(\"correct\"); }"}, {"sha": "69d574152fae5f490012a79753ff109265969e90", "filename": "src/test/run-pass/small-enums-with-fields.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Frun-pass%2Fsmall-enums-with-fields.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Frun-pass%2Fsmall-enums-with-fields.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsmall-enums-with-fields.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -10,8 +10,6 @@\n \n #![feature(macro_rules)]\n \n-extern crate debug;\n-\n use std::mem::size_of;\n \n #[deriving(PartialEq, Show)]\n@@ -24,23 +22,23 @@ macro_rules! check {\n             static S: $t = $e;\n             let v: $t = $e;\n             assert_eq!(S, v);\n-            assert_eq!(format!(\"{:?}\", v).as_slice(), $s);\n-            assert_eq!(format!(\"{:?}\", S).as_slice(), $s);\n+            assert_eq!(format!(\"{}\", v).as_slice(), $s);\n+            assert_eq!(format!(\"{}\", S).as_slice(), $s);\n         });*\n     }}\n }\n \n pub fn main() {\n     check!(Option<u8>, 2,\n            None, \"None\",\n-           Some(129u8), \"Some(129u8)\");\n+           Some(129u8), \"Some(129)\");\n     check!(Option<i16>, 4,\n            None, \"None\",\n-           Some(-20000i16), \"Some(-20000i16)\");\n+           Some(-20000i16), \"Some(-20000)\");\n     check!(Either<u8, i8>, 2,\n-           Left(132u8), \"Left(132u8)\",\n-           Right(-32i8), \"Right(-32i8)\");\n+           Left(132u8), \"Left(132)\",\n+           Right(-32i8), \"Right(-32)\");\n     check!(Either<u8, i16>, 4,\n-           Left(132u8), \"Left(132u8)\",\n-           Right(-20000i16), \"Right(-20000i16)\");\n+           Left(132u8), \"Left(132)\",\n+           Right(-20000i16), \"Right(-20000)\");\n }"}, {"sha": "dba3fe325fa7d3aece802ea0eafe1ee8d742b828", "filename": "src/test/run-pass/spawn-fn.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Frun-pass%2Fspawn-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Frun-pass%2Fspawn-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fspawn-fn.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -8,13 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-extern crate debug;\n-\n use std::task;\n \n fn x(s: String, n: int) {\n-    println!(\"{:?}\", s);\n-    println!(\"{:?}\", n);\n+    println!(\"{}\", s);\n+    println!(\"{}\", n);\n }\n \n pub fn main() {"}, {"sha": "10317c1dd022329dda1703be46546c82416855e6", "filename": "src/test/run-pass/tag-align-shape.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Frun-pass%2Ftag-align-shape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Frun-pass%2Ftag-align-shape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftag-align-shape.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -8,20 +8,20 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-extern crate debug;\n-\n+#[deriving(Show)]\n enum a_tag {\n     a_tag_var(u64)\n }\n \n+#[deriving(Show)]\n struct t_rec {\n     c8: u8,\n     t: a_tag\n }\n \n pub fn main() {\n     let x = t_rec {c8: 22u8, t: a_tag_var(44u64)};\n-    let y = format!(\"{:?}\", x);\n+    let y = format!(\"{}\", x);\n     println!(\"y = {}\", y);\n-    assert_eq!(y, \"t_rec{c8: 22u8, t: a_tag_var(44u64)}\".to_string());\n+    assert_eq!(y, \"t_rec { c8: 22, t: a_tag_var(44) }\".to_string());\n }"}, {"sha": "75345555554c67e053df77ad38175224186c5a14", "filename": "src/test/run-pass/tag-disr-val-shape.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Frun-pass%2Ftag-disr-val-shape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Frun-pass%2Ftag-disr-val-shape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftag-disr-val-shape.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -8,8 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-extern crate debug;\n-\n+#[deriving(Show)]\n enum color {\n     red = 0xff0000,\n     green = 0x00ff00,\n@@ -19,9 +18,9 @@ enum color {\n }\n \n pub fn main() {\n-    let act = format!(\"{:?}\", red);\n+    let act = format!(\"{}\", red);\n     println!(\"{}\", act);\n     assert_eq!(\"red\".to_string(), act);\n-    assert_eq!(\"green\".to_string(), format!(\"{:?}\", green));\n-    assert_eq!(\"white\".to_string(), format!(\"{:?}\", white));\n+    assert_eq!(\"green\".to_string(), format!(\"{}\", green));\n+    assert_eq!(\"white\".to_string(), format!(\"{}\", white));\n }"}, {"sha": "6f03f385a83e4a638db87806b3a33355ace5f9ae", "filename": "src/test/run-pass/tail-cps.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Frun-pass%2Ftail-cps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Frun-pass%2Ftail-cps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftail-cps.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -8,20 +8,18 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-extern crate debug;\n-\n fn checktrue(rs: bool) -> bool { assert!((rs)); return true; }\n \n pub fn main() { let k = checktrue; evenk(42, k); oddk(45, k); }\n \n fn evenk(n: int, k: fn(bool) -> bool) -> bool {\n     println!(\"evenk\");\n-    println!(\"{:?}\", n);\n+    println!(\"{}\", n);\n     if n == 0 { return k(true); } else { return oddk(n - 1, k); }\n }\n \n fn oddk(n: int, k: fn(bool) -> bool) -> bool {\n     println!(\"oddk\");\n-    println!(\"{:?}\", n);\n+    println!(\"{}\", n);\n     if n == 0 { return k(false); } else { return evenk(n - 1, k); }\n }"}, {"sha": "583840ede5f3e4281f26412da91fc1f8bebba39c", "filename": "src/test/run-pass/task-comm-3.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Frun-pass%2Ftask-comm-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Frun-pass%2Ftask-comm-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-3.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -10,8 +10,6 @@\n \n // no-pretty-expanded FIXME #15189\n \n-extern crate debug;\n-\n use std::task;\n \n pub fn main() { println!(\"===== WITHOUT THREADS =====\"); test00(); }\n@@ -65,7 +63,7 @@ fn test00() {\n     for r in results.iter_mut() { r.get_ref(); }\n \n     println!(\"Completed: Final number is: \");\n-    println!(\"{:?}\", sum);\n+    println!(\"{}\", sum);\n     // assert (sum == (((number_of_tasks * (number_of_tasks - 1)) / 2) *\n     //       number_of_messages));\n     assert_eq!(sum, 480);"}, {"sha": "cc71ccdfa1960762e295e19bd7ca7f911643a140", "filename": "src/test/run-pass/task-comm-9.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Frun-pass%2Ftask-comm-9.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Frun-pass%2Ftask-comm-9.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-9.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-extern crate debug;\n-\n use std::task;\n \n pub fn main() { test00(); }\n@@ -32,7 +30,7 @@ fn test00() {\n     let mut i: int = 0;\n     while i < number_of_messages {\n         sum += rx.recv();\n-        println!(\"{:?}\", r);\n+        println!(\"{}\", r);\n         i += 1;\n     }\n "}, {"sha": "91c07c259a2d8b60d8f0da09267053192f84da47", "filename": "src/test/run-pass/tcp-stress.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Frun-pass%2Ftcp-stress.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Frun-pass%2Ftcp-stress.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftcp-stress.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -16,7 +16,6 @@\n #[phase(plugin, link)]\n extern crate log;\n extern crate libc;\n-extern crate debug;\n \n use std::io::net::tcp::{TcpListener, TcpStream};\n use std::io::{Acceptor, Listener};\n@@ -41,7 +40,7 @@ fn main() {\n             let mut stream = match acceptor.accept() {\n                 Ok(stream) => stream,\n                 Err(error) => {\n-                    debug!(\"accept failed: {:?}\", error);\n+                    debug!(\"accept failed: {}\", error);\n                     continue;\n                 }\n             };\n@@ -64,7 +63,7 @@ fn main() {\n                     let mut buf = [0];\n                     stream.read(buf);\n                 },\n-                Err(e) => debug!(\"{:?}\", e)\n+                Err(e) => debug!(\"{}\", e)\n             }\n             tx.send(());\n         });"}, {"sha": "eceafa40265f92828865b3d98ae9973841c0f9e0", "filename": "src/test/run-pass/tempfile.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Frun-pass%2Ftempfile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Frun-pass%2Ftempfile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftempfile.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -18,8 +18,6 @@\n // they're in a different location than before. Hence, these tests are all run\n // serially here.\n \n-extern crate debug;\n-\n use std::io::fs::PathExtensions;\n use std::io::{fs, TempDir};\n use std::io;\n@@ -126,7 +124,7 @@ fn test_rm_tempdir_close() {\n fn recursive_mkdir_rel() {\n     let path = Path::new(\"frob\");\n     let cwd = os::getcwd();\n-    println!(\"recursive_mkdir_rel: Making: {} in cwd {} [{:?}]\", path.display(),\n+    println!(\"recursive_mkdir_rel: Making: {} in cwd {} [{}]\", path.display(),\n            cwd.display(), path.exists());\n     fs::mkdir_recursive(&path, io::USER_RWX);\n     assert!(path.is_dir());\n@@ -144,7 +142,7 @@ fn recursive_mkdir_dot() {\n fn recursive_mkdir_rel_2() {\n     let path = Path::new(\"./frob/baz\");\n     let cwd = os::getcwd();\n-    println!(\"recursive_mkdir_rel_2: Making: {} in cwd {} [{:?}]\", path.display(),\n+    println!(\"recursive_mkdir_rel_2: Making: {} in cwd {} [{}]\", path.display(),\n            cwd.display(), path.exists());\n     fs::mkdir_recursive(&path, io::USER_RWX);\n     assert!(path.is_dir());"}, {"sha": "464ab1352281e566726107214a856a1322911046", "filename": "src/test/run-pass/trivial-message.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Frun-pass%2Ftrivial-message.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Frun-pass%2Ftrivial-message.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrivial-message.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-extern crate debug;\n-\n /*\n   This is about the simplest program that can successfully send a\n   message.\n@@ -19,5 +17,5 @@ pub fn main() {\n     let (tx, rx) = channel();\n     tx.send(42i);\n     let r = rx.recv();\n-    println!(\"{:?}\", r);\n+    println!(\"{}\", r);\n }"}, {"sha": "af8b203d9518e147ee6def9d016004f9448c4484", "filename": "src/test/run-pass/tuple-struct-construct.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Frun-pass%2Ftuple-struct-construct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Frun-pass%2Ftuple-struct-construct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftuple-struct-construct.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -8,11 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-extern crate debug;\n-\n+#[deriving(Show)]\n struct Foo(int, int);\n \n pub fn main() {\n     let x = Foo(1, 2);\n-    println!(\"{:?}\", x);\n+    println!(\"{}\", x);\n }"}, {"sha": "b1d351ef7b4318743bfcfab88fda6171e0bcbeb8", "filename": "src/test/run-pass/unique-in-tag.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Frun-pass%2Funique-in-tag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Frun-pass%2Funique-in-tag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funique-in-tag.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -8,15 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-extern crate debug;\n-\n fn test1() {\n     enum bar { u(Box<int>), w(int), }\n \n     let x = u(box 10);\n     assert!(match x {\n       u(a) => {\n-        println!(\"{:?}\", a);\n+        println!(\"{}\", a);\n         *a\n       }\n       _ => { 66 }"}, {"sha": "bae87230ba052f5c6b6c9c5998bd28b03659e23e", "filename": "src/test/run-pass/unique-log.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Frun-pass%2Funique-log.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Frun-pass%2Funique-log.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funique-log.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -8,9 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-extern crate debug;\n-\n pub fn main() {\n     let i = box 100i;\n-    println!(\"{:?}\", i);\n+    println!(\"{}\", i);\n }"}, {"sha": "f031f7790852278ccb2886baf872c0c37bf84817", "filename": "src/test/run-pass/unique-pat-3.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Frun-pass%2Funique-pat-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Frun-pass%2Funique-pat-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funique-pat-3.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -8,14 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-extern crate debug;\n-\n enum bar { u(Box<int>), w(int), }\n \n pub fn main() {\n     assert!(match u(box 10) {\n       u(a) => {\n-        println!(\"{:?}\", a);\n+        println!(\"{}\", a);\n         *a\n       }\n       _ => { 66 }"}, {"sha": "2fe8f4bdf011ae70aab7a2890c8b2a997faa3b0f", "filename": "src/test/run-pass/vec-dst.rs", "status": "modified", "additions": 0, "deletions": 68, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Frun-pass%2Fvec-dst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b979739713f54eb9315ed5f88b8f06d43d0bbb5/src%2Ftest%2Frun-pass%2Fvec-dst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvec-dst.rs?ref=8b979739713f54eb9315ed5f88b8f06d43d0bbb5", "patch": "@@ -8,73 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-extern crate debug;\n-\n-fn reflect() {\n-    // Tests for reflective printing.\n-    // Also tests drop glue.\n-    let x = [1, 2, 3, 4];\n-    let x2 = [(), (), ()];\n-    let e1: [uint, ..0] = [];\n-    let e2: [&'static str, ..0] = [];\n-    let e3: [(), ..0] = [];\n-    assert!(format!(\"{:?}\", x) == \"[1u, 2u, 3u, 4u]\".to_string());\n-    assert!(format!(\"{:?}\", x2) == \"[(), (), ()]\".to_string());\n-    assert!(format!(\"{:?}\", e1) == \"[]\".to_string());\n-    assert!(format!(\"{:?}\", e2) == \"[]\".to_string());\n-    assert!(format!(\"{:?}\", e3) == \"[]\".to_string());\n-\n-    let rx: &[uint, ..4] = &x;\n-    let rx2: &[(), ..3] = &x2;\n-    let re1: &[uint, ..0] = &e1;\n-    let re2: &[&'static str, ..0] = &e2;\n-    let re3: &[(), ..0] = &e3;\n-    assert!(format!(\"{:?}\", rx) == \"&[1u, 2u, 3u, 4u]\".to_string());\n-    assert!(format!(\"{:?}\", rx2) == \"&[(), (), ()]\".to_string());\n-    assert!(format!(\"{:?}\", re1) == \"&[]\".to_string());\n-    assert!(format!(\"{:?}\", re2) == \"&[]\".to_string());\n-    assert!(format!(\"{:?}\", re3) == \"&[]\".to_string());\n-\n-    let rx: &[uint] = &x;\n-    let rx2: &[()] = &x2;\n-    let re1: &[uint] = &e1;\n-    let re2: &[&'static str] = &e2;\n-    let re3: &[()] = &e3;\n-    assert!(format!(\"{:?}\", rx) == \"&[1u, 2u, 3u, 4u]\".to_string());\n-    assert!(format!(\"{:?}\", rx2) == \"&[(), (), ()]\".to_string());\n-    assert!(format!(\"{:?}\", re1) == \"&[]\".to_string());\n-    assert!(format!(\"{:?}\", re2) == \"&[]\".to_string());\n-    assert!(format!(\"{:?}\", re3) == \"&[]\".to_string());\n-\n-    // FIXME(15049) These should all work some day.\n-    /*let rx: Box<[uint, ..4]> = box x;\n-    let rx2: Box<[(), ..3]> = box x2;\n-    let re1: Box<[uint, ..0]> = box e1;\n-    let re2: Box<[&'static str, ..0]> = box e2;\n-    let re3: Box<[(), ..0]> = box e3;\n-    assert!(format!(\"{:?}\", rx) == \"box [1u, 2u, 3u, 4u]\".to_string());\n-    assert!(format!(\"{:?}\", rx2) == \"box [(), (), ()]\".to_string());\n-    assert!(format!(\"{:?}\", re1) == \"box []\".to_string());\n-    assert!(format!(\"{:?}\", re2) == \"box []\".to_string());\n-    assert!(format!(\"{:?}\", re3) == \"box []\".to_string());\n-\n-    let x = [1, 2, 3, 4];\n-    let x2 = [(), (), ()];\n-    let e1: [uint, ..0] = [];\n-    let e2: [&'static str, ..0] = [];\n-    let e3: [(), ..0] = [];\n-    let rx: Box<[uint]> = box x;\n-    let rx2: Box<[()]> = box x2;\n-    let re1: Box<[uint]> = box e1;\n-    let re2: Box<[&'static str]> = box e2;\n-    let re3: Box<[()]> = box e3;\n-    assert!(format!(\"{:?}\", rx) == \"box [1u, 2u, 3u, 4u]\".to_string());\n-    assert!(format!(\"{:?}\", rx2) == \"box [(), (), ()]\".to_string());\n-    assert!(format!(\"{:?}\", re1) == \"box []\".to_string());\n-    assert!(format!(\"{:?}\", re2) == \"box []\".to_string());\n-    assert!(format!(\"{:?}\", re3) == \"box []\".to_string());*/\n-}\n-\n fn sub_expr() {\n     // Test for a &[T] => &&[T] coercion in sub-expression position\n     // (surpisingly, this can cause errors which are not caused by either of:\n@@ -109,7 +42,6 @@ fn index() {\n }\n \n pub fn main() {\n-    reflect();\n     sub_expr();\n     index();\n }"}]}