{"sha": "8022e6ad6f951d86ce8f24335053fcaaeb7b296b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgwMjJlNmFkNmY5NTFkODZjZThmMjQzMzUwNTNmY2FhZWI3YjI5NmI=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-06-16T09:21:29Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-06-16T09:21:29Z"}, "message": "Merge #9297\n\n9297: internal: add fn to minicore r=matklad a=matklad\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "88eefd90d8cca113dfe2758def3fb3266ce56a68", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/88eefd90d8cca113dfe2758def3fb3266ce56a68"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8022e6ad6f951d86ce8f24335053fcaaeb7b296b", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgycKZCRBK7hj4Ov3rIwAAOG0IAI1O0oGRYydFi0/syaKgbIey\ne3G7D8wGcSJaJh5TmPBB3vG9QgQykzr3spVy9VeUUi9vk/V0wpJjNsy/ql/Ecj0U\n+T5XedV2e/VP5w9YAD0Zx+4KnogrkWGAmslmcEkBa/9/cpFYXfCmNZoBuIFVCMjW\nnMycG94+8sR6MEDu781SnXr6rfS+hrptMCdr/W/pAmDGmFwk6JJDrb3wn7YcmuRJ\nHWF7sVN7v8txoo3y+WY7U8FB2thbQdKdoghTMpjrKXHJf2xE3lYyfdaT8XASoz7U\nDtJvtrLbYrzqkTnR3RcJQ3ShX9Ac/Eu5vuJUP+t8s9DhbS7hY71NUev7IUKsptI=\n=3Prl\n-----END PGP SIGNATURE-----\n", "payload": "tree 88eefd90d8cca113dfe2758def3fb3266ce56a68\nparent 2980fd430dbe30d5d8fd28091a8c47b3ffd4008f\nparent 8a4d9bb80a484193dc24c474af30d0d0e091963b\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1623835289 +0000\ncommitter GitHub <noreply@github.com> 1623835289 +0000\n\nMerge #9297\n\n9297: internal: add fn to minicore r=matklad a=matklad\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8022e6ad6f951d86ce8f24335053fcaaeb7b296b", "html_url": "https://github.com/rust-lang/rust/commit/8022e6ad6f951d86ce8f24335053fcaaeb7b296b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8022e6ad6f951d86ce8f24335053fcaaeb7b296b/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2980fd430dbe30d5d8fd28091a8c47b3ffd4008f", "url": "https://api.github.com/repos/rust-lang/rust/commits/2980fd430dbe30d5d8fd28091a8c47b3ffd4008f", "html_url": "https://github.com/rust-lang/rust/commit/2980fd430dbe30d5d8fd28091a8c47b3ffd4008f"}, {"sha": "8a4d9bb80a484193dc24c474af30d0d0e091963b", "url": "https://api.github.com/repos/rust-lang/rust/commits/8a4d9bb80a484193dc24c474af30d0d0e091963b", "html_url": "https://github.com/rust-lang/rust/commit/8a4d9bb80a484193dc24c474af30d0d0e091963b"}], "stats": {"total": 652, "additions": 307, "deletions": 345}, "files": [{"sha": "5adbe9c45e586017c677d89269ff76c6aa09afb7", "filename": "crates/hir_ty/src/tests/patterns.rs", "status": "modified", "additions": 36, "deletions": 40, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/8022e6ad6f951d86ce8f24335053fcaaeb7b296b/crates%2Fhir_ty%2Fsrc%2Ftests%2Fpatterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8022e6ad6f951d86ce8f24335053fcaaeb7b296b/crates%2Fhir_ty%2Fsrc%2Ftests%2Fpatterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftests%2Fpatterns.rs?ref=8022e6ad6f951d86ce8f24335053fcaaeb7b296b", "patch": "@@ -571,48 +571,44 @@ fn main() {\n fn match_ergonomics_in_closure_params() {\n     check_infer(\n         r#\"\n-        #[lang = \"fn_once\"]\n-        trait FnOnce<Args> {\n-            type Output;\n-        }\n-\n-        fn foo<T, U, F: FnOnce(T) -> U>(t: T, f: F) -> U { loop {} }\n+//- minicore: fn\n+fn foo<T, U, F: FnOnce(T) -> U>(t: T, f: F) -> U { loop {} }\n \n-        fn test() {\n-            foo(&(1, \"a\"), |&(x, y)| x); // normal, no match ergonomics\n-            foo(&(1, \"a\"), |(x, y)| x);\n-        }\n-        \"#,\n+fn test() {\n+    foo(&(1, \"a\"), |&(x, y)| x); // normal, no match ergonomics\n+    foo(&(1, \"a\"), |(x, y)| x);\n+}\n+\"#,\n         expect![[r#\"\n-            93..94 't': T\n-            99..100 'f': F\n-            110..121 '{ loop {} }': U\n-            112..119 'loop {}': !\n-            117..119 '{}': ()\n-            133..232 '{     ... x); }': ()\n-            139..142 'foo': fn foo<&(i32, &str), i32, |&(i32, &str)| -> i32>(&(i32, &str), |&(i32, &str)| -> i32) -> i32\n-            139..166 'foo(&(...y)| x)': i32\n-            143..152 '&(1, \"a\")': &(i32, &str)\n-            144..152 '(1, \"a\")': (i32, &str)\n-            145..146 '1': i32\n-            148..151 '\"a\"': &str\n-            154..165 '|&(x, y)| x': |&(i32, &str)| -> i32\n-            155..162 '&(x, y)': &(i32, &str)\n-            156..162 '(x, y)': (i32, &str)\n-            157..158 'x': i32\n-            160..161 'y': &str\n-            164..165 'x': i32\n-            203..206 'foo': fn foo<&(i32, &str), &i32, |&(i32, &str)| -> &i32>(&(i32, &str), |&(i32, &str)| -> &i32) -> &i32\n-            203..229 'foo(&(...y)| x)': &i32\n-            207..216 '&(1, \"a\")': &(i32, &str)\n-            208..216 '(1, \"a\")': (i32, &str)\n-            209..210 '1': i32\n-            212..215 '\"a\"': &str\n-            218..228 '|(x, y)| x': |&(i32, &str)| -> &i32\n-            219..225 '(x, y)': (i32, &str)\n-            220..221 'x': &i32\n-            223..224 'y': &&str\n-            227..228 'x': &i32\n+            32..33 't': T\n+            38..39 'f': F\n+            49..60 '{ loop {} }': U\n+            51..58 'loop {}': !\n+            56..58 '{}': ()\n+            72..171 '{     ... x); }': ()\n+            78..81 'foo': fn foo<&(i32, &str), i32, |&(i32, &str)| -> i32>(&(i32, &str), |&(i32, &str)| -> i32) -> i32\n+            78..105 'foo(&(...y)| x)': i32\n+            82..91 '&(1, \"a\")': &(i32, &str)\n+            83..91 '(1, \"a\")': (i32, &str)\n+            84..85 '1': i32\n+            87..90 '\"a\"': &str\n+            93..104 '|&(x, y)| x': |&(i32, &str)| -> i32\n+            94..101 '&(x, y)': &(i32, &str)\n+            95..101 '(x, y)': (i32, &str)\n+            96..97 'x': i32\n+            99..100 'y': &str\n+            103..104 'x': i32\n+            142..145 'foo': fn foo<&(i32, &str), &i32, |&(i32, &str)| -> &i32>(&(i32, &str), |&(i32, &str)| -> &i32) -> &i32\n+            142..168 'foo(&(...y)| x)': &i32\n+            146..155 '&(1, \"a\")': &(i32, &str)\n+            147..155 '(1, \"a\")': (i32, &str)\n+            148..149 '1': i32\n+            151..154 '\"a\"': &str\n+            157..167 '|(x, y)| x': |&(i32, &str)| -> &i32\n+            158..164 '(x, y)': (i32, &str)\n+            159..160 'x': &i32\n+            162..163 'y': &&str\n+            166..167 'x': &i32\n         \"#]],\n     );\n }"}, {"sha": "1edec1615fd65a9bc044cdb2c2caad7b7b1a3521", "filename": "crates/hir_ty/src/tests/regression.rs", "status": "modified", "additions": 30, "deletions": 34, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/8022e6ad6f951d86ce8f24335053fcaaeb7b296b/crates%2Fhir_ty%2Fsrc%2Ftests%2Fregression.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8022e6ad6f951d86ce8f24335053fcaaeb7b296b/crates%2Fhir_ty%2Fsrc%2Ftests%2Fregression.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftests%2Fregression.rs?ref=8022e6ad6f951d86ce8f24335053fcaaeb7b296b", "patch": "@@ -884,41 +884,37 @@ fn issue_4966() {\n fn issue_6628() {\n     check_infer(\n         r#\"\n-        #[lang = \"fn_once\"]\n-        pub trait FnOnce<Args> {\n-            type Output;\n-        }\n-\n-        struct S<T>();\n-        impl<T> S<T> {\n-            fn f(&self, _t: T) {}\n-            fn g<F: FnOnce(&T)>(&self, _f: F) {}\n-        }\n-        fn main() {\n-            let s = S();\n-            s.g(|_x| {});\n-            s.f(10);\n-        }\n-        \"#,\n+//- minicore: fn\n+struct S<T>();\n+impl<T> S<T> {\n+    fn f(&self, _t: T) {}\n+    fn g<F: FnOnce(&T)>(&self, _f: F) {}\n+}\n+fn main() {\n+    let s = S();\n+    s.g(|_x| {});\n+    s.f(10);\n+}\n+\"#,\n         expect![[r#\"\n-            105..109 'self': &S<T>\n-            111..113 '_t': T\n-            118..120 '{}': ()\n-            146..150 'self': &S<T>\n-            152..154 '_f': F\n-            159..161 '{}': ()\n-            174..225 '{     ...10); }': ()\n-            184..185 's': S<i32>\n-            188..189 'S': S<i32>() -> S<i32>\n-            188..191 'S()': S<i32>\n-            197..198 's': S<i32>\n-            197..209 's.g(|_x| {})': ()\n-            201..208 '|_x| {}': |&i32| -> ()\n-            202..204 '_x': &i32\n-            206..208 '{}': ()\n-            215..216 's': S<i32>\n-            215..222 's.f(10)': ()\n-            219..221 '10': i32\n+            40..44 'self': &S<T>\n+            46..48 '_t': T\n+            53..55 '{}': ()\n+            81..85 'self': &S<T>\n+            87..89 '_f': F\n+            94..96 '{}': ()\n+            109..160 '{     ...10); }': ()\n+            119..120 's': S<i32>\n+            123..124 'S': S<i32>() -> S<i32>\n+            123..126 'S()': S<i32>\n+            132..133 's': S<i32>\n+            132..144 's.g(|_x| {})': ()\n+            136..143 '|_x| {}': |&i32| -> ()\n+            137..139 '_x': &i32\n+            141..143 '{}': ()\n+            150..151 's': S<i32>\n+            150..157 's.f(10)': ()\n+            154..156 '10': i32\n         \"#]],\n     );\n }"}, {"sha": "065cca74f7e3813e240a4a2b4e297ec7e22ea1c7", "filename": "crates/hir_ty/src/tests/traits.rs", "status": "modified", "additions": 162, "deletions": 230, "changes": 392, "blob_url": "https://github.com/rust-lang/rust/blob/8022e6ad6f951d86ce8f24335053fcaaeb7b296b/crates%2Fhir_ty%2Fsrc%2Ftests%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8022e6ad6f951d86ce8f24335053fcaaeb7b296b/crates%2Fhir_ty%2Fsrc%2Ftests%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftests%2Ftraits.rs?ref=8022e6ad6f951d86ce8f24335053fcaaeb7b296b", "patch": "@@ -1846,11 +1846,7 @@ fn test() {\n fn closure_1() {\n     check_infer_with_mismatches(\n         r#\"\n-#[lang = \"fn_once\"]\n-trait FnOnce<Args> {\n-    type Output;\n-}\n-\n+//- minicore: fn\n enum Option<T> { Some(T), None }\n impl<T> Option<T> {\n     fn map<U, F: FnOnce(T) -> U>(self, f: F) -> Option<U> { loop {} }\n@@ -1863,34 +1859,34 @@ fn test() {\n     let y: Option<i64> = x.map(|_v| 1);\n }\"#,\n         expect![[r#\"\n-            147..151 'self': Option<T>\n-            153..154 'f': F\n-            172..183 '{ loop {} }': Option<U>\n-            174..181 'loop {}': !\n-            179..181 '{}': ()\n-            197..316 '{     ... 1); }': ()\n-            207..208 'x': Option<u32>\n-            211..223 'Option::Some': Some<u32>(u32) -> Option<u32>\n-            211..229 'Option...(1u32)': Option<u32>\n-            224..228 '1u32': u32\n-            235..236 'x': Option<u32>\n-            235..251 'x.map(...v + 1)': Option<u32>\n-            241..250 '|v| v + 1': |u32| -> u32\n-            242..243 'v': u32\n-            245..246 'v': u32\n-            245..250 'v + 1': u32\n-            249..250 '1': u32\n-            257..258 'x': Option<u32>\n-            257..273 'x.map(... 1u64)': Option<u64>\n-            263..272 '|_v| 1u64': |u32| -> u64\n-            264..266 '_v': u32\n-            268..272 '1u64': u64\n-            283..284 'y': Option<i64>\n-            300..301 'x': Option<u32>\n-            300..313 'x.map(|_v| 1)': Option<i64>\n-            306..312 '|_v| 1': |u32| -> i64\n-            307..309 '_v': u32\n-            311..312 '1': i64\n+            86..90 'self': Option<T>\n+            92..93 'f': F\n+            111..122 '{ loop {} }': Option<U>\n+            113..120 'loop {}': !\n+            118..120 '{}': ()\n+            136..255 '{     ... 1); }': ()\n+            146..147 'x': Option<u32>\n+            150..162 'Option::Some': Some<u32>(u32) -> Option<u32>\n+            150..168 'Option...(1u32)': Option<u32>\n+            163..167 '1u32': u32\n+            174..175 'x': Option<u32>\n+            174..190 'x.map(...v + 1)': Option<u32>\n+            180..189 '|v| v + 1': |u32| -> u32\n+            181..182 'v': u32\n+            184..185 'v': u32\n+            184..189 'v + 1': u32\n+            188..189 '1': u32\n+            196..197 'x': Option<u32>\n+            196..212 'x.map(... 1u64)': Option<u64>\n+            202..211 '|_v| 1u64': |u32| -> u64\n+            203..205 '_v': u32\n+            207..211 '1u64': u64\n+            222..223 'y': Option<i64>\n+            239..240 'x': Option<u32>\n+            239..252 'x.map(|_v| 1)': Option<i64>\n+            245..251 '|_v| 1': |u32| -> i64\n+            246..248 '_v': u32\n+            250..251 '1': i64\n         \"#]],\n     );\n }\n@@ -1964,11 +1960,7 @@ fn test<F: FnOnce(u32) -> u64>(f: F) {\n fn closure_as_argument_inference_order() {\n     check_infer_with_mismatches(\n         r#\"\n-#[lang = \"fn_once\"]\n-trait FnOnce<Args> {\n-    type Output;\n-}\n-\n+//- minicore: fn\n fn foo1<T, U, F: FnOnce(T) -> U>(x: T, f: F) -> U { loop {} }\n fn foo2<T, U, F: FnOnce(T) -> U>(f: F, x: T) -> U { loop {} }\n \n@@ -1987,62 +1979,62 @@ fn test() {\n     let x4 = S.foo2(|s| s.method(), S);\n }\"#,\n         expect![[r#\"\n-            94..95 'x': T\n-            100..101 'f': F\n-            111..122 '{ loop {} }': U\n-            113..120 'loop {}': !\n-            118..120 '{}': ()\n-            156..157 'f': F\n-            162..163 'x': T\n-            173..184 '{ loop {} }': U\n-            175..182 'loop {}': !\n-            180..182 '{}': ()\n-            219..223 'self': S\n-            271..275 'self': S\n-            277..278 'x': T\n-            283..284 'f': F\n-            294..305 '{ loop {} }': U\n-            296..303 'loop {}': !\n-            301..303 '{}': ()\n-            343..347 'self': S\n-            349..350 'f': F\n-            355..356 'x': T\n-            366..377 '{ loop {} }': U\n-            368..375 'loop {}': !\n-            373..375 '{}': ()\n-            391..550 '{     ... S); }': ()\n-            401..403 'x1': u64\n-            406..410 'foo1': fn foo1<S, u64, |S| -> u64>(S, |S| -> u64) -> u64\n-            406..429 'foo1(S...hod())': u64\n-            411..412 'S': S\n-            414..428 '|s| s.method()': |S| -> u64\n-            415..416 's': S\n-            418..419 's': S\n-            418..428 's.method()': u64\n-            439..441 'x2': u64\n-            444..448 'foo2': fn foo2<S, u64, |S| -> u64>(|S| -> u64, S) -> u64\n-            444..467 'foo2(|...(), S)': u64\n-            449..463 '|s| s.method()': |S| -> u64\n-            450..451 's': S\n-            453..454 's': S\n-            453..463 's.method()': u64\n-            465..466 'S': S\n-            477..479 'x3': u64\n-            482..483 'S': S\n-            482..507 'S.foo1...hod())': u64\n-            489..490 'S': S\n-            492..506 '|s| s.method()': |S| -> u64\n-            493..494 's': S\n-            496..497 's': S\n-            496..506 's.method()': u64\n-            517..519 'x4': u64\n-            522..523 'S': S\n-            522..547 'S.foo2...(), S)': u64\n-            529..543 '|s| s.method()': |S| -> u64\n-            530..531 's': S\n-            533..534 's': S\n-            533..543 's.method()': u64\n-            545..546 'S': S\n+            33..34 'x': T\n+            39..40 'f': F\n+            50..61 '{ loop {} }': U\n+            52..59 'loop {}': !\n+            57..59 '{}': ()\n+            95..96 'f': F\n+            101..102 'x': T\n+            112..123 '{ loop {} }': U\n+            114..121 'loop {}': !\n+            119..121 '{}': ()\n+            158..162 'self': S\n+            210..214 'self': S\n+            216..217 'x': T\n+            222..223 'f': F\n+            233..244 '{ loop {} }': U\n+            235..242 'loop {}': !\n+            240..242 '{}': ()\n+            282..286 'self': S\n+            288..289 'f': F\n+            294..295 'x': T\n+            305..316 '{ loop {} }': U\n+            307..314 'loop {}': !\n+            312..314 '{}': ()\n+            330..489 '{     ... S); }': ()\n+            340..342 'x1': u64\n+            345..349 'foo1': fn foo1<S, u64, |S| -> u64>(S, |S| -> u64) -> u64\n+            345..368 'foo1(S...hod())': u64\n+            350..351 'S': S\n+            353..367 '|s| s.method()': |S| -> u64\n+            354..355 's': S\n+            357..358 's': S\n+            357..367 's.method()': u64\n+            378..380 'x2': u64\n+            383..387 'foo2': fn foo2<S, u64, |S| -> u64>(|S| -> u64, S) -> u64\n+            383..406 'foo2(|...(), S)': u64\n+            388..402 '|s| s.method()': |S| -> u64\n+            389..390 's': S\n+            392..393 's': S\n+            392..402 's.method()': u64\n+            404..405 'S': S\n+            416..418 'x3': u64\n+            421..422 'S': S\n+            421..446 'S.foo1...hod())': u64\n+            428..429 'S': S\n+            431..445 '|s| s.method()': |S| -> u64\n+            432..433 's': S\n+            435..436 's': S\n+            435..445 's.method()': u64\n+            456..458 'x4': u64\n+            461..462 'S': S\n+            461..486 'S.foo2...(), S)': u64\n+            468..482 '|s| s.method()': |S| -> u64\n+            469..470 's': S\n+            472..473 's': S\n+            472..482 's.method()': u64\n+            484..485 'S': S\n         \"#]],\n     );\n }\n@@ -2051,11 +2043,7 @@ fn test() {\n fn fn_item_fn_trait() {\n     check_types(\n         r#\"\n-#[lang = \"fn_once\"]\n-trait FnOnce<Args> {\n-    type Output;\n-}\n-\n+//- minicore: fn\n struct S;\n \n fn foo() -> S {}\n@@ -2494,12 +2482,7 @@ fn test() -> impl Trait<i32> {\n fn assoc_types_from_bounds() {\n     check_infer(\n         r#\"\n-//- /main.rs\n-#[lang = \"fn_once\"]\n-trait FnOnce<Args> {\n-    type Output;\n-}\n-\n+//- minicore: fn\n trait T {\n     type O;\n }\n@@ -2518,15 +2501,15 @@ fn main() {\n     f::<(), _>(|z| { z; });\n }\"#,\n         expect![[r#\"\n-            133..135 '_v': F\n-            178..181 '{ }': ()\n-            193..224 '{     ... }); }': ()\n-            199..209 'f::<(), _>': fn f<(), |&()| -> ()>(|&()| -> ())\n-            199..221 'f::<()... z; })': ()\n-            210..220 '|z| { z; }': |&()| -> ()\n-            211..212 'z': &()\n-            214..220 '{ z; }': ()\n-            216..217 'z': &()\n+            72..74 '_v': F\n+            117..120 '{ }': ()\n+            132..163 '{     ... }); }': ()\n+            138..148 'f::<(), _>': fn f<(), |&()| -> ()>(|&()| -> ())\n+            138..160 'f::<()... z; })': ()\n+            149..159 '|z| { z; }': |&()| -> ()\n+            150..151 'z': &()\n+            153..159 '{ z; }': ()\n+            155..156 'z': &()\n         \"#]],\n     );\n }\n@@ -2599,17 +2582,7 @@ fn test() {\n fn iterator_chain() {\n     check_infer_with_mismatches(\n         r#\"\n-//- /main.rs\n-#[lang = \"fn_once\"]\n-trait FnOnce<Args> {\n-    type Output;\n-}\n-#[lang = \"fn_mut\"]\n-trait FnMut<Args>: FnOnce<Args> { }\n-\n-enum Option<T> { Some(T), None }\n-use Option::*;\n-\n+//- minicore: fn, option\n pub trait Iterator {\n     type Item;\n \n@@ -2669,46 +2642,46 @@ fn main() {\n     .for_each(|y| { y; });\n }\"#,\n         expect![[r#\"\n-            226..230 'self': Self\n-            232..233 'f': F\n-            317..328 '{ loop {} }': FilterMap<Self, F>\n-            319..326 'loop {}': !\n-            324..326 '{}': ()\n-            349..353 'self': Self\n-            355..356 'f': F\n-            405..416 '{ loop {} }': ()\n-            407..414 'loop {}': !\n-            412..414 '{}': ()\n-            525..529 'self': Self\n-            854..858 'self': I\n-            865..885 '{     ...     }': I\n-            875..879 'self': I\n-            944..955 '{ loop {} }': Vec<T>\n-            946..953 'loop {}': !\n-            951..953 '{}': ()\n-            1142..1269 '{     ... }); }': ()\n-            1148..1163 'Vec::<i32>::new': fn new<i32>() -> Vec<i32>\n-            1148..1165 'Vec::<...:new()': Vec<i32>\n-            1148..1177 'Vec::<...iter()': IntoIter<i32>\n-            1148..1240 'Vec::<...one })': FilterMap<IntoIter<i32>, |i32| -> Option<u32>>\n-            1148..1266 'Vec::<... y; })': ()\n-            1194..1239 '|x| if...None }': |i32| -> Option<u32>\n-            1195..1196 'x': i32\n-            1198..1239 'if x >...None }': Option<u32>\n-            1201..1202 'x': i32\n-            1201..1206 'x > 0': bool\n-            1205..1206 '0': i32\n-            1207..1225 '{ Some...u32) }': Option<u32>\n-            1209..1213 'Some': Some<u32>(u32) -> Option<u32>\n-            1209..1223 'Some(x as u32)': Option<u32>\n-            1214..1215 'x': i32\n-            1214..1222 'x as u32': u32\n-            1231..1239 '{ None }': Option<u32>\n-            1233..1237 'None': Option<u32>\n-            1255..1265 '|y| { y; }': |u32| -> ()\n-            1256..1257 'y': u32\n-            1259..1265 '{ y; }': ()\n-            1261..1262 'y': u32\n+            61..65 'self': Self\n+            67..68 'f': F\n+            152..163 '{ loop {} }': FilterMap<Self, F>\n+            154..161 'loop {}': !\n+            159..161 '{}': ()\n+            184..188 'self': Self\n+            190..191 'f': F\n+            240..251 '{ loop {} }': ()\n+            242..249 'loop {}': !\n+            247..249 '{}': ()\n+            360..364 'self': Self\n+            689..693 'self': I\n+            700..720 '{     ...     }': I\n+            710..714 'self': I\n+            779..790 '{ loop {} }': Vec<T>\n+            781..788 'loop {}': !\n+            786..788 '{}': ()\n+            977..1104 '{     ... }); }': ()\n+            983..998 'Vec::<i32>::new': fn new<i32>() -> Vec<i32>\n+            983..1000 'Vec::<...:new()': Vec<i32>\n+            983..1012 'Vec::<...iter()': IntoIter<i32>\n+            983..1075 'Vec::<...one })': FilterMap<IntoIter<i32>, |i32| -> Option<u32>>\n+            983..1101 'Vec::<... y; })': ()\n+            1029..1074 '|x| if...None }': |i32| -> Option<u32>\n+            1030..1031 'x': i32\n+            1033..1074 'if x >...None }': Option<u32>\n+            1036..1037 'x': i32\n+            1036..1041 'x > 0': bool\n+            1040..1041 '0': i32\n+            1042..1060 '{ Some...u32) }': Option<u32>\n+            1044..1048 'Some': Some<u32>(u32) -> Option<u32>\n+            1044..1058 'Some(x as u32)': Option<u32>\n+            1049..1050 'x': i32\n+            1049..1057 'x as u32': u32\n+            1066..1074 '{ None }': Option<u32>\n+            1068..1072 'None': Option<u32>\n+            1090..1100 '|y| { y; }': |u32| -> ()\n+            1091..1092 'y': u32\n+            1094..1100 '{ y; }': ()\n+            1096..1097 'y': u32\n         \"#]],\n     );\n }\n@@ -2995,45 +2968,23 @@ fn foo() {\n fn infer_fn_trait_arg() {\n     check_infer_with_mismatches(\n         r#\"\n-        //- /lib.rs deps:std\n-\n-        #[lang = \"fn_once\"]\n-        pub trait FnOnce<Args> {\n-            type Output;\n-\n-            extern \"rust-call\" fn call_once(&self, args: Args) -> Self::Output;\n-        }\n-\n-        #[lang = \"fn\"]\n-        pub trait Fn<Args>:FnOnce<Args> {\n-            extern \"rust-call\" fn call(&self, args: Args) -> Self::Output;\n-        }\n-\n-        enum Option<T> {\n-            None,\n-            Some(T)\n-        }\n-\n-        fn foo<F, T>(f: F) -> T\n-        where\n-            F: Fn(Option<i32>) -> T,\n-        {\n-            let s = None;\n-            f(s)\n-        }\n-        \"#,\n+//- minicore: fn, option\n+fn foo<F, T>(f: F) -> T\n+where\n+    F: Fn(Option<i32>) -> T,\n+{\n+    let s = None;\n+    f(s)\n+}\n+\"#,\n         expect![[r#\"\n-            101..105 'self': &Self\n-            107..111 'args': Args\n-            220..224 'self': &Self\n-            226..230 'args': Args\n-            313..314 'f': F\n-            359..389 '{     ...f(s) }': T\n-            369..370 's': Option<i32>\n-            373..377 'None': Option<i32>\n-            383..384 'f': F\n-            383..387 'f(s)': T\n-            385..386 's': Option<i32>\n+            13..14 'f': F\n+            59..89 '{     ...f(s) }': T\n+            69..70 's': Option<i32>\n+            73..77 'None': Option<i32>\n+            83..84 'f': F\n+            83..87 'f(s)': T\n+            85..86 's': Option<i32>\n         \"#]],\n     );\n }\n@@ -3112,17 +3063,7 @@ fn foo() {\n fn infer_dyn_fn_output() {\n     check_types(\n         r#\"\n-#[lang = \"fn_once\"]\n-pub trait FnOnce<Args> {\n-    type Output;\n-    extern \"rust-call\" fn call_once(self, args: Args) -> Self::Output;\n-}\n-\n-#[lang = \"fn\"]\n-pub trait Fn<Args>: FnOnce<Args> {\n-    extern \"rust-call\" fn call(&self, args: Args) -> Self::Output;\n-}\n-\n+//- minicore: fn\n fn foo() {\n     let f: &dyn Fn() -> i32;\n     f();\n@@ -3135,12 +3076,7 @@ fn foo() {\n fn infer_dyn_fn_once_output() {\n     check_types(\n         r#\"\n-#[lang = \"fn_once\"]\n-pub trait FnOnce<Args> {\n-    type Output;\n-    extern \"rust-call\" fn call_once(self, args: Args) -> Self::Output;\n-}\n-\n+//- minicore: fn\n fn foo() {\n     let f: dyn FnOnce() -> i32;\n     f();\n@@ -3575,20 +3511,16 @@ fn main() {\n fn fn_returning_unit() {\n     check_infer_with_mismatches(\n         r#\"\n-#[lang = \"fn_once\"]\n-trait FnOnce<Args> {\n-    type Output;\n-}\n-\n+//- minicore: fn\n fn test<F: FnOnce()>(f: F) {\n     let _: () = f();\n }\"#,\n         expect![[r#\"\n-            82..83 'f': F\n-            88..112 '{     ...f(); }': ()\n-            98..99 '_': ()\n-            106..107 'f': F\n-            106..109 'f()': ()\n+            21..22 'f': F\n+            27..51 '{     ...f(); }': ()\n+            37..38 '_': ()\n+            45..46 'f': F\n+            45..48 'f()': ()\n         \"#]],\n     );\n }"}, {"sha": "529cf5f33051ef040247614acb62c575405a7576", "filename": "crates/ide/src/hover.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8022e6ad6f951d86ce8f24335053fcaaeb7b296b/crates%2Fide%2Fsrc%2Fhover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8022e6ad6f951d86ce8f24335053fcaaeb7b296b/crates%2Fide%2Fsrc%2Fhover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fhover.rs?ref=8022e6ad6f951d86ce8f24335053fcaaeb7b296b", "patch": "@@ -3016,8 +3016,8 @@ fn foo() {\n                                     file_id: FileId(\n                                         1,\n                                     ),\n-                                    full_range: 244..426,\n-                                    focus_range: 283..289,\n+                                    full_range: 245..427,\n+                                    focus_range: 284..290,\n                                     name: \"Future\",\n                                     kind: Trait,\n                                     description: \"pub trait Future\","}, {"sha": "fac83b650ec7c6811c905f3cfc7e695d1267f2de", "filename": "crates/ide_completion/src/render.rs", "status": "modified", "additions": 6, "deletions": 16, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/8022e6ad6f951d86ce8f24335053fcaaeb7b296b/crates%2Fide_completion%2Fsrc%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8022e6ad6f951d86ce8f24335053fcaaeb7b296b/crates%2Fide_completion%2Fsrc%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Frender.rs?ref=8022e6ad6f951d86ce8f24335053fcaaeb7b296b", "patch": "@@ -1191,29 +1191,19 @@ fn main() {\n     fn suggest_deref_mut() {\n         check_relevance(\n             r#\"\n-#[lang = \"deref\"]\n-trait Deref {\n-    type Target;\n-    fn deref(&self) -> &Self::Target;\n-}\n-\n-#[lang = \"deref_mut\"]\n-pub trait DerefMut: Deref {\n-    fn deref_mut(&mut self) -> &mut Self::Target;\n-}\n-\n+//- minicore: deref_mut\n struct S;\n struct T(S);\n \n-impl Deref for T {\n+impl core::ops::Deref for T {\n     type Target = S;\n \n     fn deref(&self) -> &Self::Target {\n         &self.0\n     }\n }\n \n-impl DerefMut for T {\n+impl core::ops::DerefMut for T {\n     fn deref_mut(&mut self) -> &mut Self::Target {\n         &mut self.0\n     }\n@@ -1232,12 +1222,12 @@ fn main() {\n                 lc m [local]\n                 lc t [local]\n                 lc &mut t [type+local]\n-                tt DerefMut []\n-                tt Deref []\n-                fn foo(\u2026) []\n                 st T []\n                 st S []\n                 fn main() []\n+                fn foo(\u2026) []\n+                md core []\n+                tt Sized []\n             \"#]],\n         )\n     }"}, {"sha": "005a5c092ae6fa4048a3d7141e1dea79f64f4c69", "filename": "crates/test_utils/src/fixture.rs", "status": "modified", "additions": 38, "deletions": 20, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/8022e6ad6f951d86ce8f24335053fcaaeb7b296b/crates%2Ftest_utils%2Fsrc%2Ffixture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8022e6ad6f951d86ce8f24335053fcaaeb7b296b/crates%2Ftest_utils%2Fsrc%2Ffixture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftest_utils%2Fsrc%2Ffixture.rs?ref=8022e6ad6f951d86ce8f24335053fcaaeb7b296b", "patch": "@@ -129,8 +129,18 @@ impl Fixture {\n             if line.starts_with(\"//-\") {\n                 let meta = Fixture::parse_meta_line(line);\n                 res.push(meta)\n-            } else if let Some(entry) = res.last_mut() {\n-                entry.text.push_str(line);\n+            } else {\n+                if line.starts_with(\"// \")\n+                    && line.contains(\":\")\n+                    && !line.contains(\"::\")\n+                    && line.chars().all(|it| !it.is_uppercase())\n+                {\n+                    panic!(\"looks like invalid metadata line: {:?}\", line)\n+                }\n+\n+                if let Some(entry) = res.last_mut() {\n+                    entry.text.push_str(line);\n+                }\n             }\n         }\n \n@@ -154,7 +164,9 @@ impl Fixture {\n         let mut env = FxHashMap::default();\n         let mut introduce_new_source_root = false;\n         for component in components[1..].iter() {\n-            let (key, value) = component.split_once(':').unwrap();\n+            let (key, value) = component\n+                .split_once(':')\n+                .unwrap_or_else(|| panic!(\"invalid meta line: {:?}\", meta));\n             match key {\n                 \"crate\" => krate = Some(value.to_string()),\n                 \"deps\" => deps = value.split(',').map(|it| it.to_string()).collect(),\n@@ -276,46 +288,52 @@ impl MiniCore {\n             }\n         }\n \n-        let mut curr_region = \"\";\n+        let mut active_regions = Vec::new();\n         let mut seen_regions = Vec::new();\n         for line in lines {\n             let trimmed = line.trim();\n             if let Some(region) = trimmed.strip_prefix(\"// region:\") {\n-                assert_eq!(curr_region, \"\");\n-                curr_region = region;\n+                active_regions.push(region);\n                 continue;\n             }\n             if let Some(region) = trimmed.strip_prefix(\"// endregion:\") {\n-                assert_eq!(curr_region, region);\n-                curr_region = \"\";\n+                let prev = active_regions.pop().unwrap();\n+                assert_eq!(prev, region);\n                 continue;\n             }\n-            seen_regions.push(curr_region);\n \n-            let mut flag = curr_region;\n+            let mut line_region = false;\n             if let Some(idx) = trimmed.find(\"// :\") {\n-                flag = &trimmed[idx + \"// :\".len()..];\n+                line_region = true;\n+                active_regions.push(&trimmed[idx + \"// :\".len()..]);\n             }\n \n-            let skip = if flag == \"\" {\n-                false\n-            } else {\n-                assert!(!flag.starts_with(' '), \"region marker starts with a space: {:?}\", flag);\n-                self.assert_valid_flag(flag);\n-                !self.has_flag(flag)\n-            };\n+            let mut keep = true;\n+            for &region in &active_regions {\n+                assert!(\n+                    !region.starts_with(' '),\n+                    \"region marker starts with a space: {:?}\",\n+                    region\n+                );\n+                self.assert_valid_flag(region);\n+                seen_regions.push(region);\n+                keep &= self.has_flag(region);\n+            }\n \n-            if !skip {\n+            if keep {\n                 buf.push_str(line)\n             }\n+            if line_region {\n+                active_regions.pop().unwrap();\n+            }\n         }\n \n         for flag in &self.valid_flags {\n             if !seen_regions.iter().any(|it| it == flag) {\n                 panic!(\"unused minicore flag: {:?}\", flag);\n             }\n         }\n-\n+        format!(\"{}\", buf);\n         buf\n     }\n }"}, {"sha": "e04ca58d28568d48f08be4353aabd5af821b0361", "filename": "crates/test_utils/src/minicore.rs", "status": "modified", "additions": 33, "deletions": 3, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/8022e6ad6f951d86ce8f24335053fcaaeb7b296b/crates%2Ftest_utils%2Fsrc%2Fminicore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8022e6ad6f951d86ce8f24335053fcaaeb7b296b/crates%2Ftest_utils%2Fsrc%2Fminicore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftest_utils%2Fsrc%2Fminicore.rs?ref=8022e6ad6f951d86ce8f24335053fcaaeb7b296b", "patch": "@@ -9,11 +9,13 @@\n //!\n //! Available flags:\n //!     sized:\n+//!     unsize: sized\n+//!     coerce_unsized: unsize\n //!     slice:\n //!     range:\n-//!     unsize: sized\n //!     deref: sized\n-//!     coerce_unsized: unsize\n+//!     deref_mut: deref\n+//!     fn:\n //!     pin:\n //!     future: pin\n //!     option:\n@@ -64,9 +66,16 @@ pub mod ops {\n             type Target: ?Sized;\n             fn deref(&self) -> &Self::Target;\n         }\n+        // region:deref_mut\n+        #[lang = \"deref_mut\"]\n+        pub trait DerefMut: Deref {\n+            fn deref_mut(&mut self) -> &mut Self::Target;\n+        }\n+        // endregion:deref_mut\n     }\n     pub use self::deref::Deref;\n-    // endregion:deref\n+    pub use self::deref::DerefMut; //:deref_mut\n+                                   // endregion:deref\n \n     // region:range\n     mod range {\n@@ -104,6 +113,26 @@ pub mod ops {\n     pub use self::range::{Range, RangeFrom, RangeFull, RangeTo};\n     pub use self::range::{RangeInclusive, RangeToInclusive};\n     // endregion:range\n+\n+    // region:fn\n+    mod function {\n+        #[lang = \"fn\"]\n+        #[fundamental]\n+        pub trait Fn<Args>: FnMut<Args> {}\n+\n+        #[lang = \"fn_mut\"]\n+        #[fundamental]\n+        pub trait FnMut<Args>: FnOnce<Args> {}\n+\n+        #[lang = \"fn_once\"]\n+        #[fundamental]\n+        pub trait FnOnce<Args> {\n+            #[lang = \"fn_once_output\"]\n+            type Output;\n+        }\n+    }\n+    pub use self::function::{Fn, FnMut, FnOnce};\n+    // endregion:fn\n }\n \n // region:slice\n@@ -181,6 +210,7 @@ pub mod prelude {\n     pub mod v1 {\n         pub use crate::{\n             marker::Sized,                      // :sized\n+            ops::{Fn, FnMut, FnOnce},           // :fn\n             option::Option::{self, None, Some}, // :option\n             result::Result::{self, Err, Ok},    // :result\n         };"}]}