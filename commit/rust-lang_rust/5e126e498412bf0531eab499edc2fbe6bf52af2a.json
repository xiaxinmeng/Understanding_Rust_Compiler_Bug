{"sha": "5e126e498412bf0531eab499edc2fbe6bf52af2a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVlMTI2ZTQ5ODQxMmJmMDUzMWVhYjQ5OWVkYzJmYmU2YmY1MmFmMmE=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-08-18T21:38:19Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-08-18T21:38:19Z"}, "message": "implement transitive relation type that can compute transitive\nclosures, upper bounds, and other fun things", "tree": {"sha": "bcf56073dc8f123f2da976f8b006e74a78fa397d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bcf56073dc8f123f2da976f8b006e74a78fa397d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5e126e498412bf0531eab499edc2fbe6bf52af2a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5e126e498412bf0531eab499edc2fbe6bf52af2a", "html_url": "https://github.com/rust-lang/rust/commit/5e126e498412bf0531eab499edc2fbe6bf52af2a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5e126e498412bf0531eab499edc2fbe6bf52af2a/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4756d4a635ff98334030775783835fccf7e4b4c9", "url": "https://api.github.com/repos/rust-lang/rust/commits/4756d4a635ff98334030775783835fccf7e4b4c9", "html_url": "https://github.com/rust-lang/rust/commit/4756d4a635ff98334030775783835fccf7e4b4c9"}], "stats": {"total": 464, "additions": 464, "deletions": 0}, "files": [{"sha": "78edae76253a927f99d331b4af1b72261719d80f", "filename": "src/librustc_data_structures/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5e126e498412bf0531eab499edc2fbe6bf52af2a/src%2Flibrustc_data_structures%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e126e498412bf0531eab499edc2fbe6bf52af2a/src%2Flibrustc_data_structures%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Flib.rs?ref=5e126e498412bf0531eab499edc2fbe6bf52af2a", "patch": "@@ -37,6 +37,7 @@ pub mod bitvec;\n pub mod graph;\n pub mod ivar;\n pub mod snapshot_vec;\n+pub mod transitive_relation;\n pub mod unify;\n \n // See comments in src/librustc/lib.rs"}, {"sha": "384e94fcc5eb5c3c5bf4196e8bb7555c5d4b094e", "filename": "src/librustc_data_structures/transitive_relation.rs", "status": "added", "additions": 463, "deletions": 0, "changes": 463, "blob_url": "https://github.com/rust-lang/rust/blob/5e126e498412bf0531eab499edc2fbe6bf52af2a/src%2Flibrustc_data_structures%2Ftransitive_relation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e126e498412bf0531eab499edc2fbe6bf52af2a/src%2Flibrustc_data_structures%2Ftransitive_relation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Ftransitive_relation.rs?ref=5e126e498412bf0531eab499edc2fbe6bf52af2a", "patch": "@@ -0,0 +1,463 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use bitvec::BitMatrix;\n+use std::cell::RefCell;\n+use std::fmt::Debug;\n+use std::mem;\n+\n+#[derive(Clone)]\n+pub struct TransitiveRelation<T:Debug+PartialEq> {\n+    // List of elements. This is used to map from a T to a usize.  We\n+    // expect domain to be small so just use a linear list versus a\n+    // hashmap or something.\n+    elements: Vec<T>,\n+\n+    // List of base edges in the graph. Require to compute transitive\n+    // closure.\n+    edges: Vec<Edge>,\n+\n+    // This is a cached transitive closure derived from the edges.\n+    // Currently, we build it lazilly and just throw out any existing\n+    // copy whenever a new edge is added. (The RefCell is to permit\n+    // the lazy computation.) This is kind of silly, except for the\n+    // fact its size is tied to `self.elements.len()`, so I wanted to\n+    // wait before building it up to avoid reallocating as new edges\n+    // are added with new elements. Perhaps better would be to ask the\n+    // user for a batch of edges to minimize this effect, but I\n+    // already wrote the code this way. :P -nmatsakis\n+    closure: RefCell<Option<BitMatrix>>\n+}\n+\n+#[derive(Clone, PartialEq, PartialOrd)]\n+struct Index(usize);\n+\n+#[derive(Clone, PartialEq)]\n+struct Edge {\n+    source: Index,\n+    target: Index,\n+}\n+\n+impl<T:Debug+PartialEq> TransitiveRelation<T> {\n+    pub fn new() -> TransitiveRelation<T> {\n+        TransitiveRelation { elements: vec![],\n+                             edges: vec![],\n+                             closure: RefCell::new(None) }\n+    }\n+\n+    fn index(&self, a: &T) -> Option<Index> {\n+        self.elements.iter().position(|e| *e == *a).map(Index)\n+    }\n+\n+    fn add_index(&mut self, a: T) -> Index {\n+        match self.index(&a) {\n+            Some(i) => i,\n+            None => {\n+                self.elements.push(a);\n+                Index(self.elements.len() - 1)\n+            }\n+        }\n+    }\n+\n+    /// Indicate that `a < b` (where `<` is this relation)\n+    pub fn add(&mut self, a: T, b: T) {\n+        let a = self.add_index(a);\n+        let b = self.add_index(b);\n+        let edge = Edge { source: a, target: b };\n+        if !self.edges.contains(&edge) {\n+            self.edges.push(edge);\n+        }\n+\n+        // clear cached closure, if any\n+        *self.closure.borrow_mut() = None;\n+    }\n+\n+    /// Check whether `a < target` (transitively)\n+    pub fn contains(&self, a: &T, b: &T) -> bool {\n+        match (self.index(a), self.index(b)) {\n+            (Some(a), Some(b)) =>\n+                self.take_closure(|closure| closure.contains(a.0, b.0)),\n+            (None, _) | (_, None) =>\n+                false,\n+        }\n+    }\n+\n+    /// Picks what I am referring to as the \"best\" upper-bound for `a`\n+    /// and `b`. This is usually the least upper bound, but in cases where\n+    /// there is no single least upper bound, it is the \"mutual immediate postdominator\",\n+    /// if you imagine a graph where `a < b` means `a -> b`.\n+    ///\n+    /// This function is needed because region inference currently\n+    /// requires that we produce a single \"UB\", and there is no best\n+    /// choice for the LUB. Rather than pick arbitrarily, I pick a\n+    /// less good, but predictable choice. This should help ensure\n+    /// that region inference yields predictable results (though it\n+    /// itself is not fully sufficient).\n+    ///\n+    /// Examples are probably clearer than any prose I could write\n+    /// (there are corresponding tests below, btw):\n+    ///\n+    /// ```\n+    /// // returns Some(x), which is also LUB\n+    /// a -> a1 -> x\n+    ///            ^\n+    ///            |\n+    /// b -> b1 ---+\n+    ///\n+    /// // returns Some(x), which is not LUB (there is none)\n+    /// a -> a1 -> x\n+    ///   \\/       ^\n+    ///   /\\       |\n+    /// b -> b1 ---+\n+    ///\n+    /// // returns None\n+    /// a -> a1\n+    /// b -> b1\n+    /// ```\n+    pub fn best_upper_bound(&self, a: &T, b: &T) -> Option<&T> {\n+        let mut mubs = self.minimal_upper_bounds(a, b);\n+        loop {\n+            match mubs.len() {\n+                0 => return None,\n+                1 => return Some(mubs[0]),\n+                _ => {\n+                    let m = mubs.pop().unwrap();\n+                    let n = mubs.pop().unwrap();\n+                    mubs.extend(self.minimal_upper_bounds(n, m));\n+                }\n+            }\n+        }\n+    }\n+\n+    /// Returns the set of bounds `X` such that:\n+    ///\n+    /// - `a < X` and `b < X`\n+    /// - there is no `Y` such that `a < Y` and `Y < X`\n+    ///\n+    /// Note that this set can, in principle, have any size.\n+    pub fn minimal_upper_bounds(&self, a: &T, b: &T) -> Vec<&T> {\n+        let (mut a, mut b) = match (self.index(a), self.index(b)) {\n+            (Some(a), Some(b)) => (a, b),\n+            (None, _) | (_, None) => { return vec![]; }\n+        };\n+\n+        // in some cases, there are some arbitrary choices to be made;\n+        // it doesn't really matter what we pick, as long as we pick\n+        // the same thing consistently when queried, so ensure that\n+        // (a, b) are in a consistent relative order\n+        if a > b {\n+            mem::swap(&mut a, &mut b);\n+        }\n+\n+        let lub_indices = self.take_closure(|closure| {\n+            // Easy case is when either a < b or b < a:\n+            if closure.contains(a.0, b.0) {\n+                return vec![b.0];\n+            }\n+            if closure.contains(b.0, a.0) {\n+                return vec![a.0];\n+            }\n+\n+            // Otherwise, the tricky part is that there may be some c\n+            // where a < c and b < c. In fact, there may be many such\n+            // values. So here is what we do:\n+            //\n+            // 1. Find the vector `[X | a < X && b < X]` of all values\n+            //    `X` where `a < X` and `b < X`.  In terms of the\n+            //    graph, this means all values reachable from both `a`\n+            //    and `b`. Note that this vector is also a set, but we\n+            //    use the term vector because the order matters\n+            //    to the steps below.\n+            //    - This vector contains upper bounds, but they are\n+            //      not minimal upper bounds. So you may have e.g.\n+            //      `[a, b, tcx, x]` where `a < tcx` and `b < tcx` and\n+            //      `x < a` and `x < b`. This could be reduced to\n+            //      just `[x]`.\n+            // 2. Pare down the vector using `pare_down`. This will\n+            //    remove elements from the vector that can be reached\n+            //    by an earlier element.\n+            //    - In the example above, this would convert\n+            //      `[a, b, tcx, x]` to `[a, b, x]`. Note that `x`\n+            //      remains because `x < a` but not `a < x.`\n+            // 3. Reverse the vector and repeat the pare down process.\n+            //    - In the example above, we would reverse to\n+            //      `[x, b, a]` and then pare down to `[x]`.\n+            // 4. Reverse once more just so that we yield a vector in\n+            //    increasing order of index. Maybe this is silly.\n+            //\n+            // I believe this algorithm yields a minimal set. The\n+            // argument is that, after step 2, we know that no element\n+            // can reach its successors (in the vector, not the graph).\n+            // After step 3, we know that no element can reach any of\n+            // its predecesssors (because of step 2) nor successors\n+            // (because we just called `pare_down`)\n+\n+            let mut candidates = closure.intersection(a.0, b.0); // (1)\n+            pare_down(&mut candidates, closure); // (2)\n+            candidates.reverse(); // (3a)\n+            pare_down(&mut candidates, closure); // (3b)\n+            candidates.reverse(); // (4)\n+            candidates\n+        });\n+\n+        lub_indices.into_iter()\n+                   .map(|i| &self.elements[i])\n+                   .collect()\n+    }\n+\n+    fn take_closure<OP,R>(&self, op: OP) -> R\n+        where OP: FnOnce(&BitMatrix) -> R\n+    {\n+        let mut closure_cell = self.closure.borrow_mut();\n+        let mut closure = closure_cell.take();\n+        if closure.is_none() {\n+            closure = Some(self.compute_closure());\n+        }\n+        let result = op(closure.as_ref().unwrap());\n+        *closure_cell = closure;\n+        result\n+    }\n+\n+    fn compute_closure(&self) -> BitMatrix {\n+        let mut matrix = BitMatrix::new(self.elements.len());\n+        let mut changed = true;\n+        while changed {\n+            changed = false;\n+            for edge in self.edges.iter() {\n+                // add an edge from S -> T\n+                changed |= matrix.add(edge.source.0, edge.target.0);\n+\n+                // add all outgoing edges from T into S\n+                changed |= matrix.merge(edge.target.0, edge.source.0);\n+            }\n+        }\n+        matrix\n+    }\n+}\n+\n+/// Pare down is used as a step in the LUB computation. It edits the\n+/// candidates array in place by removing any element j for which\n+/// there exists an earlier element i<j such that i -> j. That is,\n+/// after you run `pare_down`, you know that for all elements that\n+/// remain in candidates, they cannot reach any of the elements that\n+/// come after them.\n+///\n+/// Examples follow. Assume that a -> b -> c and x -> y -> z.\n+///\n+/// - Input: `[a, b, x]`. Output: `[a, x]`.\n+/// - Input: `[b, a, x]`. Output: `[b, a, x]`.\n+/// - Input: `[a, x, b, y]`. Output: `[a, x]`.\n+fn pare_down(candidates: &mut Vec<usize>, closure: &BitMatrix) {\n+    let mut i = 0;\n+    while i < candidates.len() {\n+        let candidate = candidates[i];\n+        i += 1;\n+\n+        let mut j = i;\n+        while j < candidates.len() {\n+            if closure.contains(candidate, candidates[j]) {\n+                // if i can reach j, then we can remove j\n+                println!(\"pare_down: candidates[{:?}]={:?} candidates[{:?}] = {:?}\",\n+                         i-1, candidate, j, candidates[j]);\n+                candidates.swap_remove(j);\n+            } else {\n+                j += 1;\n+            }\n+        }\n+    }\n+}\n+\n+#[test]\n+fn test_one_step() {\n+    let mut relation = TransitiveRelation::new();\n+    relation.add(\"a\", \"b\");\n+    relation.add(\"a\", \"c\");\n+    assert!(relation.contains(&\"a\", &\"c\"));\n+    assert!(relation.contains(&\"a\", &\"b\"));\n+    assert!(!relation.contains(&\"b\", &\"a\"));\n+    assert!(!relation.contains(&\"a\", &\"d\"));\n+}\n+\n+#[test]\n+fn test_many_steps() {\n+    let mut relation = TransitiveRelation::new();\n+    relation.add(\"a\", \"b\");\n+    relation.add(\"a\", \"c\");\n+    relation.add(\"a\", \"f\");\n+\n+    relation.add(\"b\", \"c\");\n+    relation.add(\"b\", \"d\");\n+    relation.add(\"b\", \"e\");\n+\n+    relation.add(\"e\", \"g\");\n+\n+    assert!(relation.contains(&\"a\", &\"b\"));\n+    assert!(relation.contains(&\"a\", &\"c\"));\n+    assert!(relation.contains(&\"a\", &\"d\"));\n+    assert!(relation.contains(&\"a\", &\"e\"));\n+    assert!(relation.contains(&\"a\", &\"f\"));\n+    assert!(relation.contains(&\"a\", &\"g\"));\n+\n+    assert!(relation.contains(&\"b\", &\"g\"));\n+\n+    assert!(!relation.contains(&\"a\", &\"x\"));\n+    assert!(!relation.contains(&\"b\", &\"f\"));\n+}\n+\n+#[test]\n+fn mubs_triange() {\n+    let mut relation = TransitiveRelation::new();\n+    relation.add(\"a\", \"tcx\");\n+    relation.add(\"b\", \"tcx\");\n+    assert_eq!(relation.minimal_upper_bounds(&\"a\", &\"b\"), vec![&\"tcx\"]);\n+}\n+\n+#[test]\n+fn mubs_best_choice1() {\n+    // 0 -> 1 <- 3\n+    // |    ^    |\n+    // |    |    |\n+    // +--> 2 <--+\n+    //\n+    // mubs(0,3) = [1]\n+\n+    // This tests a particular state in the algorithm, in which we\n+    // need the second pare down call to get the right result (after\n+    // intersection, we have [1, 2], but 2 -> 1).\n+\n+    let mut relation = TransitiveRelation::new();\n+    relation.add(\"0\", \"1\");\n+    relation.add(\"0\", \"2\");\n+\n+    relation.add(\"2\", \"1\");\n+\n+    relation.add(\"3\", \"1\");\n+    relation.add(\"3\", \"2\");\n+\n+    assert_eq!(relation.minimal_upper_bounds(&\"0\", &\"3\"), vec![&\"2\"]);\n+}\n+\n+#[test]\n+fn mubs_best_choice2() {\n+    // 0 -> 1 <- 3\n+    // |    |    |\n+    // |    v    |\n+    // +--> 2 <--+\n+    //\n+    // mubs(0,3) = [2]\n+\n+    // Like the precedecing test, but in this case intersection is [2,\n+    // 1], and hence we rely on the first pare down call.\n+\n+    let mut relation = TransitiveRelation::new();\n+    relation.add(\"0\", \"1\");\n+    relation.add(\"0\", \"2\");\n+\n+    relation.add(\"1\", \"2\");\n+\n+    relation.add(\"3\", \"1\");\n+    relation.add(\"3\", \"2\");\n+\n+    assert_eq!(relation.minimal_upper_bounds(&\"0\", &\"3\"), vec![&\"1\"]);\n+}\n+\n+#[test]\n+fn mubs_no_best_choice() {\n+    // in this case, the intersection yields [1, 2],\n+    // and we need the first \"pare down\" call to narrow\n+    // this down to [2]\n+    let mut relation = TransitiveRelation::new();\n+    relation.add(\"0\", \"1\");\n+    relation.add(\"0\", \"2\");\n+\n+    relation.add(\"3\", \"1\");\n+    relation.add(\"3\", \"2\");\n+\n+    assert_eq!(relation.minimal_upper_bounds(&\"0\", &\"3\"), vec![&\"1\", &\"2\"]);\n+}\n+\n+#[test]\n+fn mubs_best_choice_scc() {\n+    let mut relation = TransitiveRelation::new();\n+    relation.add(\"0\", \"1\");\n+    relation.add(\"0\", \"2\");\n+\n+    relation.add(\"1\", \"2\");\n+    relation.add(\"2\", \"1\");\n+\n+    relation.add(\"3\", \"1\");\n+    relation.add(\"3\", \"2\");\n+\n+    assert_eq!(relation.minimal_upper_bounds(&\"0\", &\"3\"), vec![&\"1\"]);\n+}\n+\n+#[test]\n+fn bub_crisscross() {\n+    // a -> a1 -> x\n+    //   \\/       ^\n+    //   /\\       |\n+    // b -> b1 ---+\n+\n+    let mut relation = TransitiveRelation::new();\n+    relation.add(\"a\",  \"a1\");\n+    relation.add(\"a\",  \"b1\");\n+    relation.add(\"b\",  \"a1\");\n+    relation.add(\"b\",  \"b1\");\n+    relation.add(\"a1\", \"x\");\n+    relation.add(\"b1\", \"x\");\n+\n+    assert_eq!(relation.minimal_upper_bounds(&\"a\", &\"b\"), vec![&\"a1\", &\"b1\"]);\n+    assert_eq!(relation.best_upper_bound(&\"a\", &\"b\"), Some(&\"x\"));\n+}\n+\n+#[test]\n+fn bub_crisscross_more() {\n+    // a -> a1 -> a2 -> a3 -> x\n+    //   \\/    \\/             ^\n+    //   /\\    /\\             |\n+    // b -> b1 -> b2 ---------+\n+\n+    let mut relation = TransitiveRelation::new();\n+    relation.add(\"a\",  \"a1\");\n+    relation.add(\"a\",  \"b1\");\n+    relation.add(\"b\",  \"a1\");\n+    relation.add(\"b\",  \"b1\");\n+\n+    relation.add(\"a1\",  \"a2\");\n+    relation.add(\"a1\",  \"b2\");\n+    relation.add(\"b1\",  \"a2\");\n+    relation.add(\"b1\",  \"b2\");\n+\n+    relation.add(\"a2\", \"a3\");\n+\n+    relation.add(\"a3\", \"x\");\n+    relation.add(\"b2\", \"x\");\n+\n+    assert_eq!(relation.minimal_upper_bounds(&\"a\", &\"b\"), vec![&\"a1\", &\"b1\"]);\n+    assert_eq!(relation.minimal_upper_bounds(&\"a1\", &\"b1\"), vec![&\"a2\", &\"b2\"]);\n+    assert_eq!(relation.best_upper_bound(&\"a\", &\"b\"), Some(&\"x\"));\n+}\n+\n+#[test]\n+fn bub_lub() {\n+    // a -> a1 -> x\n+    //            ^\n+    //            |\n+    // b -> b1 ---+\n+\n+    let mut relation = TransitiveRelation::new();\n+    relation.add(\"a\",  \"a1\");\n+    relation.add(\"b\",  \"b1\");\n+    relation.add(\"a1\", \"x\");\n+    relation.add(\"b1\", \"x\");\n+\n+    assert_eq!(relation.minimal_upper_bounds(&\"a\", &\"b\"), vec![&\"x\"]);\n+    assert_eq!(relation.best_upper_bound(&\"a\", &\"b\"), Some(&\"x\"));\n+}"}]}