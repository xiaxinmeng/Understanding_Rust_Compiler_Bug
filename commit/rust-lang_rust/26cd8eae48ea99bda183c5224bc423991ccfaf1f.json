{"sha": "26cd8eae48ea99bda183c5224bc423991ccfaf1f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI2Y2Q4ZWFlNDhlYTk5YmRhMTgzYzUyMjRiYzQyMzk5MWNjZmFmMWY=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-01-06T23:49:15Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-01-06T23:49:15Z"}, "message": "rollup merge of #20563: cmr/macro-input-future-proofing", "tree": {"sha": "26492380aa79b1b1f70acb2a624e30ca097374df", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/26492380aa79b1b1f70acb2a624e30ca097374df"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/26cd8eae48ea99bda183c5224bc423991ccfaf1f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/26cd8eae48ea99bda183c5224bc423991ccfaf1f", "html_url": "https://github.com/rust-lang/rust/commit/26cd8eae48ea99bda183c5224bc423991ccfaf1f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/26cd8eae48ea99bda183c5224bc423991ccfaf1f/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "34a63d336419e80d3afec16c730d1ad5fa11dc73", "url": "https://api.github.com/repos/rust-lang/rust/commits/34a63d336419e80d3afec16c730d1ad5fa11dc73", "html_url": "https://github.com/rust-lang/rust/commit/34a63d336419e80d3afec16c730d1ad5fa11dc73"}, {"sha": "e9cbdd866d1c9c01e9affaf6875e37e58a073758", "url": "https://api.github.com/repos/rust-lang/rust/commits/e9cbdd866d1c9c01e9affaf6875e37e58a073758", "html_url": "https://github.com/rust-lang/rust/commit/e9cbdd866d1c9c01e9affaf6875e37e58a073758"}], "stats": {"total": 629, "additions": 423, "deletions": 206}, "files": [{"sha": "9cb4d154de7b22a910619c5f45b3bfb3ccdc6918", "filename": "src/doc/guide-macros.md", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/26cd8eae48ea99bda183c5224bc423991ccfaf1f/src%2Fdoc%2Fguide-macros.md", "raw_url": "https://github.com/rust-lang/rust/raw/26cd8eae48ea99bda183c5224bc423991ccfaf1f/src%2Fdoc%2Fguide-macros.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-macros.md?ref=26cd8eae48ea99bda183c5224bc423991ccfaf1f", "patch": "@@ -161,7 +161,7 @@ instead of `*` to mean \"at least one\".\n # let input_1 = T::SpecialA(0);\n # let input_2 = T::SpecialA(0);\n macro_rules! early_return {\n-    ($inp:expr, [ $($sp:path)|+ ]) => (\n+    ($inp:expr, [ $($sp:path),+ ]) => (\n         match $inp {\n             $(\n                 $sp(x) => { return x; }\n@@ -171,7 +171,7 @@ macro_rules! early_return {\n     )\n }\n // ...\n-early_return!(input_1, [T::SpecialA|T::SpecialC|T::SpecialD]);\n+early_return!(input_1, [T::SpecialA,T::SpecialC,T::SpecialD]);\n // ...\n early_return!(input_2, [T::SpecialB]);\n # return 0;\n@@ -245,7 +245,7 @@ can solve the problem:\n ~~~~\n macro_rules! biased_match {\n     // special case: `let (x) = ...` is illegal, so use `let x = ...` instead\n-    ( ($e:expr) ~ ($p:pat) else $err:stmt ;\n+    ( ($e:expr) -> ($p:pat) else $err:stmt ;\n       binds $bind_res:ident\n     ) => (\n         let $bind_res = match $e {\n@@ -254,7 +254,7 @@ macro_rules! biased_match {\n         };\n     );\n     // more than one name; use a tuple\n-    ( ($e:expr) ~ ($p:pat) else $err:stmt ;\n+    ( ($e:expr) -> ($p:pat) else $err:stmt ;\n       binds $( $bind_res:ident ),*\n     ) => (\n         let ( $( $bind_res ),* ) = match $e {\n@@ -268,9 +268,9 @@ macro_rules! biased_match {\n # struct T2 { body: T3 }\n # enum T3 { Good2(uint), Bad2}\n # fn f(x: T1) -> uint {\n-biased_match!((x)       ~ (T1::Good1(g1, val)) else { return 0 };\n+biased_match!((x)       -> (T1::Good1(g1, val)) else { return 0 };\n               binds g1, val );\n-biased_match!((g1.body) ~ (T3::Good2(result) )\n+biased_match!((g1.body) -> (T3::Good2(result) )\n                   else { panic!(\"Didn't get good_2\") };\n               binds result );\n // complicated stuff goes here\n@@ -286,7 +286,7 @@ pattern we want is clear:\n ~~~~\n # fn main() {}\n # macro_rules! b {\n-    ( $( ($e:expr) ~ ($p:pat) else $err:stmt ; )*\n+    ( $( ($e:expr) -> ($p:pat) else $err:stmt ; )*\n       binds $( $bind_res:ident ),*\n     )\n # => (0) }\n@@ -317,8 +317,8 @@ input patterns:\n ~~~~\n # fn main() {}\n # macro_rules! b {\n-    (    ($e     :expr) ~ ($p     :pat) else $err     :stmt ;\n-      $( ($e_rest:expr) ~ ($p_rest:pat) else $err_rest:stmt ; )*\n+    (    ($e     :expr) -> ($p     :pat) else $err     :stmt ;\n+      $( ($e_rest:expr) -> ($p_rest:pat) else $err_rest:stmt ; )*\n       binds  $( $bind_res:ident ),*\n     )\n # => (0) }\n@@ -333,14 +333,14 @@ piece of syntax (the `let`) which we only want to transcribe once.\n \n macro_rules! biased_match_rec {\n     // Handle the first layer\n-    (   ($e     :expr) ~ ($p     :pat) else $err     :stmt ;\n-     $( ($e_rest:expr) ~ ($p_rest:pat) else $err_rest:stmt ; )*\n+    (   ($e     :expr) -> ($p     :pat) else $err     :stmt ;\n+     $( ($e_rest:expr) -> ($p_rest:pat) else $err_rest:stmt ; )*\n      binds $( $bind_res:ident ),*\n     ) => (\n         match $e {\n             $p => {\n                 // Recursively handle the next layer\n-                biased_match_rec!($( ($e_rest) ~ ($p_rest) else $err_rest ; )*\n+                biased_match_rec!($( ($e_rest) -> ($p_rest) else $err_rest ; )*\n                                   binds $( $bind_res ),*\n                 )\n             }\n@@ -354,20 +354,20 @@ macro_rules! biased_match_rec {\n // Wrap the whole thing in a `let`.\n macro_rules! biased_match {\n     // special case: `let (x) = ...` is illegal, so use `let x = ...` instead\n-    ( $( ($e:expr) ~ ($p:pat) else $err:stmt ; )*\n+    ( $( ($e:expr) -> ($p:pat) else $err:stmt ; )*\n       binds $bind_res:ident\n     ) => (\n         let $bind_res = biased_match_rec!(\n-            $( ($e) ~ ($p) else $err ; )*\n+            $( ($e) -> ($p) else $err ; )*\n             binds $bind_res\n         );\n     );\n     // more than one name: use a tuple\n-    ( $( ($e:expr) ~ ($p:pat) else $err:stmt ; )*\n+    ( $( ($e:expr) -> ($p:pat) else $err:stmt ; )*\n       binds  $( $bind_res:ident ),*\n     ) => (\n         let ( $( $bind_res ),* ) = biased_match_rec!(\n-            $( ($e) ~ ($p) else $err ; )*\n+            $( ($e) -> ($p) else $err ; )*\n             binds $( $bind_res ),*\n         );\n     )\n@@ -379,8 +379,8 @@ macro_rules! biased_match {\n # enum T3 { Good2(uint), Bad2}\n # fn f(x: T1) -> uint {\n biased_match!(\n-    (x)       ~ (T1::Good1(g1, val)) else { return 0 };\n-    (g1.body) ~ (T3::Good2(result) ) else { panic!(\"Didn't get Good2\") };\n+    (x)       -> (T1::Good1(g1, val)) else { return 0 };\n+    (g1.body) -> (T3::Good2(result) ) else { panic!(\"Didn't get Good2\") };\n     binds val, result );\n // complicated stuff goes here\n return result + val;"}, {"sha": "00bfe56a622112b9004b6a684c6517588ef691ba", "filename": "src/libcore/macros.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/26cd8eae48ea99bda183c5224bc423991ccfaf1f/src%2Flibcore%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26cd8eae48ea99bda183c5224bc423991ccfaf1f/src%2Flibcore%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros.rs?ref=26cd8eae48ea99bda183c5224bc423991ccfaf1f", "patch": "@@ -179,9 +179,12 @@ macro_rules! write {\n #[macro_export]\n #[stable]\n macro_rules! writeln {\n-    ($dst:expr, $fmt:expr $($arg:tt)*) => (\n-        write!($dst, concat!($fmt, \"\\n\") $($arg)*)\n-    )\n+    ($dst:expr, $fmt:expr) => (\n+        write!($dst, concat!($fmt, \"\\n\"))\n+    );\n+    ($dst:expr, $fmt:expr, $($arg:expr),*) => (\n+        write!($dst, concat!($fmt, \"\\n\"), $($arg,)*)\n+    );\n }\n \n /// A utility macro for indicating unreachable code."}, {"sha": "3f8ce000e214cffde43574336ce829fde9e47ec7", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/26cd8eae48ea99bda183c5224bc423991ccfaf1f/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26cd8eae48ea99bda183c5224bc423991ccfaf1f/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=26cd8eae48ea99bda183c5224bc423991ccfaf1f", "patch": "@@ -35,17 +35,16 @@ use slice::{self, SliceExt};\n use uint;\n \n macro_rules! delegate_iter {\n-    (exact $te:ty in $ti:ty) => {\n-        delegate_iter!{$te in $ti}\n-        #[stable]\n+    (exact $te:ty : $ti:ty) => {\n+        delegate_iter!{$te : $ti}\n         impl<'a> ExactSizeIterator for $ti {\n             #[inline]\n             fn len(&self) -> uint {\n                 self.0.len()\n             }\n         }\n     };\n-    ($te:ty in $ti:ty) => {\n+    ($te:ty : $ti:ty) => {\n         #[stable]\n         impl<'a> Iterator for $ti {\n             type Item = $te;\n@@ -67,7 +66,7 @@ macro_rules! delegate_iter {\n             }\n         }\n     };\n-    (pattern $te:ty in $ti:ty) => {\n+    (pattern $te:ty : $ti:ty) => {\n         #[stable]\n         impl<'a, P: CharEq> Iterator for $ti {\n             type Item = $te;\n@@ -89,7 +88,7 @@ macro_rules! delegate_iter {\n             }\n         }\n     };\n-    (pattern forward $te:ty in $ti:ty) => {\n+    (pattern forward $te:ty : $ti:ty) => {\n         #[stable]\n         impl<'a, P: CharEq> Iterator for $ti {\n             type Item = $te;\n@@ -415,7 +414,7 @@ impl<'a> DoubleEndedIterator for CharIndices<'a> {\n #[stable]\n #[derive(Clone)]\n pub struct Bytes<'a>(Map<&'a u8, u8, slice::Iter<'a, u8>, BytesDeref>);\n-delegate_iter!{exact u8 in Bytes<'a>}\n+delegate_iter!{exact u8 : Bytes<'a>}\n \n /// A temporary fn new type that ensures that the `Bytes` iterator\n /// is cloneable.\n@@ -1172,25 +1171,25 @@ impl<'a, S: ?Sized> Str for &'a S where S: Str {\n #[derive(Clone)]\n #[stable]\n pub struct Split<'a, P>(CharSplits<'a, P>);\n-delegate_iter!{pattern &'a str in Split<'a, P>}\n+delegate_iter!{pattern &'a str : Split<'a, P>}\n \n /// Return type of `StrExt::split_terminator`\n #[derive(Clone)]\n #[unstable = \"might get removed in favour of a constructor method on Split\"]\n pub struct SplitTerminator<'a, P>(CharSplits<'a, P>);\n-delegate_iter!{pattern &'a str in SplitTerminator<'a, P>}\n+delegate_iter!{pattern &'a str : SplitTerminator<'a, P>}\n \n /// Return type of `StrExt::splitn`\n #[derive(Clone)]\n #[stable]\n pub struct SplitN<'a, P>(CharSplitsN<'a, P>);\n-delegate_iter!{pattern forward &'a str in SplitN<'a, P>}\n+delegate_iter!{pattern forward &'a str : SplitN<'a, P>}\n \n /// Return type of `StrExt::rsplitn`\n #[derive(Clone)]\n #[stable]\n pub struct RSplitN<'a, P>(CharSplitsN<'a, P>);\n-delegate_iter!{pattern forward &'a str in RSplitN<'a, P>}\n+delegate_iter!{pattern forward &'a str : RSplitN<'a, P>}\n \n /// Methods for string slices\n #[allow(missing_docs)]"}, {"sha": "35fb34eafb4d02a8a6312a21873652dfc315d3a6", "filename": "src/librustc_trans/trans/context.rs", "status": "modified", "additions": 110, "deletions": 110, "changes": 220, "blob_url": "https://github.com/rust-lang/rust/blob/26cd8eae48ea99bda183c5224bc423991ccfaf1f/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26cd8eae48ea99bda183c5224bc423991ccfaf1f/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs?ref=26cd8eae48ea99bda183c5224bc423991ccfaf1f", "patch": "@@ -737,7 +737,7 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n \n fn declare_intrinsic(ccx: &CrateContext, key: & &'static str) -> Option<ValueRef> {\n     macro_rules! ifn {\n-        ($name:expr fn() -> $ret:expr) => (\n+        ($name:expr, fn() -> $ret:expr) => (\n             if *key == $name {\n                 let f = base::decl_cdecl_fn(\n                     ccx, $name, Type::func(&[], &$ret),\n@@ -746,7 +746,7 @@ fn declare_intrinsic(ccx: &CrateContext, key: & &'static str) -> Option<ValueRef\n                 return Some(f);\n             }\n         );\n-        ($name:expr fn($($arg:expr),*) -> $ret:expr) => (\n+        ($name:expr, fn($($arg:expr),*) -> $ret:expr) => (\n             if *key == $name {\n                 let f = base::decl_cdecl_fn(ccx, $name,\n                                   Type::func(&[$($arg),*], &$ret), ty::mk_nil(ccx.tcx()));\n@@ -769,111 +769,111 @@ fn declare_intrinsic(ccx: &CrateContext, key: & &'static str) -> Option<ValueRef\n     let t_f32 = Type::f32(ccx);\n     let t_f64 = Type::f64(ccx);\n \n-    ifn!(\"llvm.memcpy.p0i8.p0i8.i32\" fn(i8p, i8p, t_i32, t_i32, i1) -> void);\n-    ifn!(\"llvm.memcpy.p0i8.p0i8.i64\" fn(i8p, i8p, t_i64, t_i32, i1) -> void);\n-    ifn!(\"llvm.memmove.p0i8.p0i8.i32\" fn(i8p, i8p, t_i32, t_i32, i1) -> void);\n-    ifn!(\"llvm.memmove.p0i8.p0i8.i64\" fn(i8p, i8p, t_i64, t_i32, i1) -> void);\n-    ifn!(\"llvm.memset.p0i8.i32\" fn(i8p, t_i8, t_i32, t_i32, i1) -> void);\n-    ifn!(\"llvm.memset.p0i8.i64\" fn(i8p, t_i8, t_i64, t_i32, i1) -> void);\n-\n-    ifn!(\"llvm.trap\" fn() -> void);\n-    ifn!(\"llvm.debugtrap\" fn() -> void);\n-    ifn!(\"llvm.frameaddress\" fn(t_i32) -> i8p);\n-\n-    ifn!(\"llvm.powi.f32\" fn(t_f32, t_i32) -> t_f32);\n-    ifn!(\"llvm.powi.f64\" fn(t_f64, t_i32) -> t_f64);\n-    ifn!(\"llvm.pow.f32\" fn(t_f32, t_f32) -> t_f32);\n-    ifn!(\"llvm.pow.f64\" fn(t_f64, t_f64) -> t_f64);\n-\n-    ifn!(\"llvm.sqrt.f32\" fn(t_f32) -> t_f32);\n-    ifn!(\"llvm.sqrt.f64\" fn(t_f64) -> t_f64);\n-    ifn!(\"llvm.sin.f32\" fn(t_f32) -> t_f32);\n-    ifn!(\"llvm.sin.f64\" fn(t_f64) -> t_f64);\n-    ifn!(\"llvm.cos.f32\" fn(t_f32) -> t_f32);\n-    ifn!(\"llvm.cos.f64\" fn(t_f64) -> t_f64);\n-    ifn!(\"llvm.exp.f32\" fn(t_f32) -> t_f32);\n-    ifn!(\"llvm.exp.f64\" fn(t_f64) -> t_f64);\n-    ifn!(\"llvm.exp2.f32\" fn(t_f32) -> t_f32);\n-    ifn!(\"llvm.exp2.f64\" fn(t_f64) -> t_f64);\n-    ifn!(\"llvm.log.f32\" fn(t_f32) -> t_f32);\n-    ifn!(\"llvm.log.f64\" fn(t_f64) -> t_f64);\n-    ifn!(\"llvm.log10.f32\" fn(t_f32) -> t_f32);\n-    ifn!(\"llvm.log10.f64\" fn(t_f64) -> t_f64);\n-    ifn!(\"llvm.log2.f32\" fn(t_f32) -> t_f32);\n-    ifn!(\"llvm.log2.f64\" fn(t_f64) -> t_f64);\n-\n-    ifn!(\"llvm.fma.f32\" fn(t_f32, t_f32, t_f32) -> t_f32);\n-    ifn!(\"llvm.fma.f64\" fn(t_f64, t_f64, t_f64) -> t_f64);\n-\n-    ifn!(\"llvm.fabs.f32\" fn(t_f32) -> t_f32);\n-    ifn!(\"llvm.fabs.f64\" fn(t_f64) -> t_f64);\n-\n-    ifn!(\"llvm.floor.f32\" fn(t_f32) -> t_f32);\n-    ifn!(\"llvm.floor.f64\" fn(t_f64) -> t_f64);\n-    ifn!(\"llvm.ceil.f32\" fn(t_f32) -> t_f32);\n-    ifn!(\"llvm.ceil.f64\" fn(t_f64) -> t_f64);\n-    ifn!(\"llvm.trunc.f32\" fn(t_f32) -> t_f32);\n-    ifn!(\"llvm.trunc.f64\" fn(t_f64) -> t_f64);\n-\n-    ifn!(\"llvm.rint.f32\" fn(t_f32) -> t_f32);\n-    ifn!(\"llvm.rint.f64\" fn(t_f64) -> t_f64);\n-    ifn!(\"llvm.nearbyint.f32\" fn(t_f32) -> t_f32);\n-    ifn!(\"llvm.nearbyint.f64\" fn(t_f64) -> t_f64);\n-\n-    ifn!(\"llvm.ctpop.i8\" fn(t_i8) -> t_i8);\n-    ifn!(\"llvm.ctpop.i16\" fn(t_i16) -> t_i16);\n-    ifn!(\"llvm.ctpop.i32\" fn(t_i32) -> t_i32);\n-    ifn!(\"llvm.ctpop.i64\" fn(t_i64) -> t_i64);\n-\n-    ifn!(\"llvm.ctlz.i8\" fn(t_i8 , i1) -> t_i8);\n-    ifn!(\"llvm.ctlz.i16\" fn(t_i16, i1) -> t_i16);\n-    ifn!(\"llvm.ctlz.i32\" fn(t_i32, i1) -> t_i32);\n-    ifn!(\"llvm.ctlz.i64\" fn(t_i64, i1) -> t_i64);\n-\n-    ifn!(\"llvm.cttz.i8\" fn(t_i8 , i1) -> t_i8);\n-    ifn!(\"llvm.cttz.i16\" fn(t_i16, i1) -> t_i16);\n-    ifn!(\"llvm.cttz.i32\" fn(t_i32, i1) -> t_i32);\n-    ifn!(\"llvm.cttz.i64\" fn(t_i64, i1) -> t_i64);\n-\n-    ifn!(\"llvm.bswap.i16\" fn(t_i16) -> t_i16);\n-    ifn!(\"llvm.bswap.i32\" fn(t_i32) -> t_i32);\n-    ifn!(\"llvm.bswap.i64\" fn(t_i64) -> t_i64);\n-\n-    ifn!(\"llvm.sadd.with.overflow.i8\" fn(t_i8, t_i8) -> mk_struct!{t_i8, i1});\n-    ifn!(\"llvm.sadd.with.overflow.i16\" fn(t_i16, t_i16) -> mk_struct!{t_i16, i1});\n-    ifn!(\"llvm.sadd.with.overflow.i32\" fn(t_i32, t_i32) -> mk_struct!{t_i32, i1});\n-    ifn!(\"llvm.sadd.with.overflow.i64\" fn(t_i64, t_i64) -> mk_struct!{t_i64, i1});\n-\n-    ifn!(\"llvm.uadd.with.overflow.i8\" fn(t_i8, t_i8) -> mk_struct!{t_i8, i1});\n-    ifn!(\"llvm.uadd.with.overflow.i16\" fn(t_i16, t_i16) -> mk_struct!{t_i16, i1});\n-    ifn!(\"llvm.uadd.with.overflow.i32\" fn(t_i32, t_i32) -> mk_struct!{t_i32, i1});\n-    ifn!(\"llvm.uadd.with.overflow.i64\" fn(t_i64, t_i64) -> mk_struct!{t_i64, i1});\n-\n-    ifn!(\"llvm.ssub.with.overflow.i8\" fn(t_i8, t_i8) -> mk_struct!{t_i8, i1});\n-    ifn!(\"llvm.ssub.with.overflow.i16\" fn(t_i16, t_i16) -> mk_struct!{t_i16, i1});\n-    ifn!(\"llvm.ssub.with.overflow.i32\" fn(t_i32, t_i32) -> mk_struct!{t_i32, i1});\n-    ifn!(\"llvm.ssub.with.overflow.i64\" fn(t_i64, t_i64) -> mk_struct!{t_i64, i1});\n-\n-    ifn!(\"llvm.usub.with.overflow.i8\" fn(t_i8, t_i8) -> mk_struct!{t_i8, i1});\n-    ifn!(\"llvm.usub.with.overflow.i16\" fn(t_i16, t_i16) -> mk_struct!{t_i16, i1});\n-    ifn!(\"llvm.usub.with.overflow.i32\" fn(t_i32, t_i32) -> mk_struct!{t_i32, i1});\n-    ifn!(\"llvm.usub.with.overflow.i64\" fn(t_i64, t_i64) -> mk_struct!{t_i64, i1});\n-\n-    ifn!(\"llvm.smul.with.overflow.i8\" fn(t_i8, t_i8) -> mk_struct!{t_i8, i1});\n-    ifn!(\"llvm.smul.with.overflow.i16\" fn(t_i16, t_i16) -> mk_struct!{t_i16, i1});\n-    ifn!(\"llvm.smul.with.overflow.i32\" fn(t_i32, t_i32) -> mk_struct!{t_i32, i1});\n-    ifn!(\"llvm.smul.with.overflow.i64\" fn(t_i64, t_i64) -> mk_struct!{t_i64, i1});\n-\n-    ifn!(\"llvm.umul.with.overflow.i8\" fn(t_i8, t_i8) -> mk_struct!{t_i8, i1});\n-    ifn!(\"llvm.umul.with.overflow.i16\" fn(t_i16, t_i16) -> mk_struct!{t_i16, i1});\n-    ifn!(\"llvm.umul.with.overflow.i32\" fn(t_i32, t_i32) -> mk_struct!{t_i32, i1});\n-    ifn!(\"llvm.umul.with.overflow.i64\" fn(t_i64, t_i64) -> mk_struct!{t_i64, i1});\n-\n-    ifn!(\"llvm.lifetime.start\" fn(t_i64,i8p) -> void);\n-    ifn!(\"llvm.lifetime.end\" fn(t_i64, i8p) -> void);\n-\n-    ifn!(\"llvm.expect.i1\" fn(i1, i1) -> i1);\n-    ifn!(\"llvm.assume\" fn(i1) -> void);\n+    ifn!(\"llvm.memcpy.p0i8.p0i8.i32\", fn(i8p, i8p, t_i32, t_i32, i1) -> void);\n+    ifn!(\"llvm.memcpy.p0i8.p0i8.i64\", fn(i8p, i8p, t_i64, t_i32, i1) -> void);\n+    ifn!(\"llvm.memmove.p0i8.p0i8.i32\", fn(i8p, i8p, t_i32, t_i32, i1) -> void);\n+    ifn!(\"llvm.memmove.p0i8.p0i8.i64\", fn(i8p, i8p, t_i64, t_i32, i1) -> void);\n+    ifn!(\"llvm.memset.p0i8.i32\", fn(i8p, t_i8, t_i32, t_i32, i1) -> void);\n+    ifn!(\"llvm.memset.p0i8.i64\", fn(i8p, t_i8, t_i64, t_i32, i1) -> void);\n+\n+    ifn!(\"llvm.trap\", fn() -> void);\n+    ifn!(\"llvm.debugtrap\", fn() -> void);\n+    ifn!(\"llvm.frameaddress\", fn(t_i32) -> i8p);\n+\n+    ifn!(\"llvm.powi.f32\", fn(t_f32, t_i32) -> t_f32);\n+    ifn!(\"llvm.powi.f64\", fn(t_f64, t_i32) -> t_f64);\n+    ifn!(\"llvm.pow.f32\", fn(t_f32, t_f32) -> t_f32);\n+    ifn!(\"llvm.pow.f64\", fn(t_f64, t_f64) -> t_f64);\n+\n+    ifn!(\"llvm.sqrt.f32\", fn(t_f32) -> t_f32);\n+    ifn!(\"llvm.sqrt.f64\", fn(t_f64) -> t_f64);\n+    ifn!(\"llvm.sin.f32\", fn(t_f32) -> t_f32);\n+    ifn!(\"llvm.sin.f64\", fn(t_f64) -> t_f64);\n+    ifn!(\"llvm.cos.f32\", fn(t_f32) -> t_f32);\n+    ifn!(\"llvm.cos.f64\", fn(t_f64) -> t_f64);\n+    ifn!(\"llvm.exp.f32\", fn(t_f32) -> t_f32);\n+    ifn!(\"llvm.exp.f64\", fn(t_f64) -> t_f64);\n+    ifn!(\"llvm.exp2.f32\", fn(t_f32) -> t_f32);\n+    ifn!(\"llvm.exp2.f64\", fn(t_f64) -> t_f64);\n+    ifn!(\"llvm.log.f32\", fn(t_f32) -> t_f32);\n+    ifn!(\"llvm.log.f64\", fn(t_f64) -> t_f64);\n+    ifn!(\"llvm.log10.f32\", fn(t_f32) -> t_f32);\n+    ifn!(\"llvm.log10.f64\", fn(t_f64) -> t_f64);\n+    ifn!(\"llvm.log2.f32\", fn(t_f32) -> t_f32);\n+    ifn!(\"llvm.log2.f64\", fn(t_f64) -> t_f64);\n+\n+    ifn!(\"llvm.fma.f32\", fn(t_f32, t_f32, t_f32) -> t_f32);\n+    ifn!(\"llvm.fma.f64\", fn(t_f64, t_f64, t_f64) -> t_f64);\n+\n+    ifn!(\"llvm.fabs.f32\", fn(t_f32) -> t_f32);\n+    ifn!(\"llvm.fabs.f64\", fn(t_f64) -> t_f64);\n+\n+    ifn!(\"llvm.floor.f32\", fn(t_f32) -> t_f32);\n+    ifn!(\"llvm.floor.f64\", fn(t_f64) -> t_f64);\n+    ifn!(\"llvm.ceil.f32\", fn(t_f32) -> t_f32);\n+    ifn!(\"llvm.ceil.f64\", fn(t_f64) -> t_f64);\n+    ifn!(\"llvm.trunc.f32\", fn(t_f32) -> t_f32);\n+    ifn!(\"llvm.trunc.f64\", fn(t_f64) -> t_f64);\n+\n+    ifn!(\"llvm.rint.f32\", fn(t_f32) -> t_f32);\n+    ifn!(\"llvm.rint.f64\", fn(t_f64) -> t_f64);\n+    ifn!(\"llvm.nearbyint.f32\", fn(t_f32) -> t_f32);\n+    ifn!(\"llvm.nearbyint.f64\", fn(t_f64) -> t_f64);\n+\n+    ifn!(\"llvm.ctpop.i8\", fn(t_i8) -> t_i8);\n+    ifn!(\"llvm.ctpop.i16\", fn(t_i16) -> t_i16);\n+    ifn!(\"llvm.ctpop.i32\", fn(t_i32) -> t_i32);\n+    ifn!(\"llvm.ctpop.i64\", fn(t_i64) -> t_i64);\n+\n+    ifn!(\"llvm.ctlz.i8\", fn(t_i8 , i1) -> t_i8);\n+    ifn!(\"llvm.ctlz.i16\", fn(t_i16, i1) -> t_i16);\n+    ifn!(\"llvm.ctlz.i32\", fn(t_i32, i1) -> t_i32);\n+    ifn!(\"llvm.ctlz.i64\", fn(t_i64, i1) -> t_i64);\n+\n+    ifn!(\"llvm.cttz.i8\", fn(t_i8 , i1) -> t_i8);\n+    ifn!(\"llvm.cttz.i16\", fn(t_i16, i1) -> t_i16);\n+    ifn!(\"llvm.cttz.i32\", fn(t_i32, i1) -> t_i32);\n+    ifn!(\"llvm.cttz.i64\", fn(t_i64, i1) -> t_i64);\n+\n+    ifn!(\"llvm.bswap.i16\", fn(t_i16) -> t_i16);\n+    ifn!(\"llvm.bswap.i32\", fn(t_i32) -> t_i32);\n+    ifn!(\"llvm.bswap.i64\", fn(t_i64) -> t_i64);\n+\n+    ifn!(\"llvm.sadd.with.overflow.i8\", fn(t_i8, t_i8) -> mk_struct!{t_i8, i1});\n+    ifn!(\"llvm.sadd.with.overflow.i16\", fn(t_i16, t_i16) -> mk_struct!{t_i16, i1});\n+    ifn!(\"llvm.sadd.with.overflow.i32\", fn(t_i32, t_i32) -> mk_struct!{t_i32, i1});\n+    ifn!(\"llvm.sadd.with.overflow.i64\", fn(t_i64, t_i64) -> mk_struct!{t_i64, i1});\n+\n+    ifn!(\"llvm.uadd.with.overflow.i8\", fn(t_i8, t_i8) -> mk_struct!{t_i8, i1});\n+    ifn!(\"llvm.uadd.with.overflow.i16\", fn(t_i16, t_i16) -> mk_struct!{t_i16, i1});\n+    ifn!(\"llvm.uadd.with.overflow.i32\", fn(t_i32, t_i32) -> mk_struct!{t_i32, i1});\n+    ifn!(\"llvm.uadd.with.overflow.i64\", fn(t_i64, t_i64) -> mk_struct!{t_i64, i1});\n+\n+    ifn!(\"llvm.ssub.with.overflow.i8\", fn(t_i8, t_i8) -> mk_struct!{t_i8, i1});\n+    ifn!(\"llvm.ssub.with.overflow.i16\", fn(t_i16, t_i16) -> mk_struct!{t_i16, i1});\n+    ifn!(\"llvm.ssub.with.overflow.i32\", fn(t_i32, t_i32) -> mk_struct!{t_i32, i1});\n+    ifn!(\"llvm.ssub.with.overflow.i64\", fn(t_i64, t_i64) -> mk_struct!{t_i64, i1});\n+\n+    ifn!(\"llvm.usub.with.overflow.i8\", fn(t_i8, t_i8) -> mk_struct!{t_i8, i1});\n+    ifn!(\"llvm.usub.with.overflow.i16\", fn(t_i16, t_i16) -> mk_struct!{t_i16, i1});\n+    ifn!(\"llvm.usub.with.overflow.i32\", fn(t_i32, t_i32) -> mk_struct!{t_i32, i1});\n+    ifn!(\"llvm.usub.with.overflow.i64\", fn(t_i64, t_i64) -> mk_struct!{t_i64, i1});\n+\n+    ifn!(\"llvm.smul.with.overflow.i8\", fn(t_i8, t_i8) -> mk_struct!{t_i8, i1});\n+    ifn!(\"llvm.smul.with.overflow.i16\", fn(t_i16, t_i16) -> mk_struct!{t_i16, i1});\n+    ifn!(\"llvm.smul.with.overflow.i32\", fn(t_i32, t_i32) -> mk_struct!{t_i32, i1});\n+    ifn!(\"llvm.smul.with.overflow.i64\", fn(t_i64, t_i64) -> mk_struct!{t_i64, i1});\n+\n+    ifn!(\"llvm.umul.with.overflow.i8\", fn(t_i8, t_i8) -> mk_struct!{t_i8, i1});\n+    ifn!(\"llvm.umul.with.overflow.i16\", fn(t_i16, t_i16) -> mk_struct!{t_i16, i1});\n+    ifn!(\"llvm.umul.with.overflow.i32\", fn(t_i32, t_i32) -> mk_struct!{t_i32, i1});\n+    ifn!(\"llvm.umul.with.overflow.i64\", fn(t_i64, t_i64) -> mk_struct!{t_i64, i1});\n+\n+    ifn!(\"llvm.lifetime.start\", fn(t_i64,i8p) -> void);\n+    ifn!(\"llvm.lifetime.end\", fn(t_i64, i8p) -> void);\n+\n+    ifn!(\"llvm.expect.i1\", fn(i1, i1) -> i1);\n+    ifn!(\"llvm.assume\", fn(i1) -> void);\n \n     // Some intrinsics were introduced in later versions of LLVM, but they have\n     // fallbacks in libc or libm and such. Currently, all of these intrinsics\n@@ -882,7 +882,7 @@ fn declare_intrinsic(ccx: &CrateContext, key: & &'static str) -> Option<ValueRef\n         ($name:expr, $cname:ident ($($arg:expr),*) -> $ret:expr) => (\n             if unsafe { llvm::LLVMVersionMinor() >= 4 } {\n                 // The `if key == $name` is already in ifn!\n-                ifn!($name fn($($arg),*) -> $ret);\n+                ifn!($name, fn($($arg),*) -> $ret);\n             } else if *key == $name {\n                 let f = base::decl_cdecl_fn(ccx, stringify!($cname),\n                                       Type::func(&[$($arg),*], &$ret),\n@@ -900,8 +900,8 @@ fn declare_intrinsic(ccx: &CrateContext, key: & &'static str) -> Option<ValueRef\n \n \n     if ccx.sess().opts.debuginfo != NoDebugInfo {\n-        ifn!(\"llvm.dbg.declare\" fn(Type::metadata(ccx), Type::metadata(ccx)) -> void);\n-        ifn!(\"llvm.dbg.value\" fn(Type::metadata(ccx), t_i64, Type::metadata(ccx)) -> void);\n+        ifn!(\"llvm.dbg.declare\", fn(Type::metadata(ccx), Type::metadata(ccx)) -> void);\n+        ifn!(\"llvm.dbg.value\", fn(Type::metadata(ccx), t_i64, Type::metadata(ccx)) -> void);\n     }\n     return None;\n }"}, {"sha": "6a04565312ddac447ad5ed4da1c8a967be667ec1", "filename": "src/libserialize/serialize.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/26cd8eae48ea99bda183c5224bc423991ccfaf1f/src%2Flibserialize%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26cd8eae48ea99bda183c5224bc423991ccfaf1f/src%2Flibserialize%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fserialize.rs?ref=26cd8eae48ea99bda183c5224bc423991ccfaf1f", "patch": "@@ -499,7 +499,7 @@ macro_rules! peel {\n /// Evaluates to the number of identifiers passed to it, for example: `count_idents!(a, b, c) == 3\n macro_rules! count_idents {\n     () => { 0u };\n-    ($_i:ident $(, $rest:ident)*) => { 1 + count_idents!($($rest),*) }\n+    ($_i:ident, $($rest:ident),*) => { 1 + count_idents!($($rest),*) }\n }\n \n macro_rules! tuple {"}, {"sha": "1e3ab6d34dab9daecb05e14357c99ce7413e7a6b", "filename": "src/libstd/rt/macros.rs", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/26cd8eae48ea99bda183c5224bc423991ccfaf1f/src%2Flibstd%2Frt%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26cd8eae48ea99bda183c5224bc423991ccfaf1f/src%2Flibstd%2Frt%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmacros.rs?ref=26cd8eae48ea99bda183c5224bc423991ccfaf1f", "patch": "@@ -14,16 +14,24 @@\n //! they aren't defined anywhere outside of the `rt` module.\n \n macro_rules! rterrln {\n-    ($fmt:expr $($arg:tt)*) => ( {\n-        ::rt::util::dumb_print(format_args!(concat!($fmt, \"\\n\") $($arg)*))\n+    ($fmt:expr) => ( {\n+        ::rt::util::dumb_print(format_args!(concat!($fmt, \"\\n\")))\n+    } );\n+    ($fmt:expr, $($arg:expr),*) => ( {\n+        ::rt::util::dumb_print(format_args!(concat!($fmt, \"\\n\"), $($arg)*))\n     } )\n }\n \n // Some basic logging. Enabled by passing `--cfg rtdebug` to the libstd build.\n macro_rules! rtdebug {\n-    ($($arg:tt)*) => ( {\n+    ($arg:expr) => ( {\n         if cfg!(rtdebug) {\n-            rterrln!($($arg)*)\n+            rterrln!($arg)\n+        }\n+    } );\n+    ($str:expr, $($arg:expr),*) => ( {\n+        if cfg!(rtdebug) {\n+            rterrln!($str, $($arg)*)\n         }\n     })\n }"}, {"sha": "be44aa99f49d764aca3b65f8dc8baa2d375081da", "filename": "src/libstd/sys/common/backtrace.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/26cd8eae48ea99bda183c5224bc423991ccfaf1f/src%2Flibstd%2Fsys%2Fcommon%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26cd8eae48ea99bda183c5224bc423991ccfaf1f/src%2Flibstd%2Fsys%2Fcommon%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fbacktrace.rs?ref=26cd8eae48ea99bda183c5224bc423991ccfaf1f", "patch": "@@ -88,7 +88,7 @@ pub fn demangle(writer: &mut Writer, s: &str) -> IoResult<()> {\n             while rest.len() > 0 {\n                 if rest.starts_with(\"$\") {\n                     macro_rules! demangle {\n-                        ($($pat:expr => $demangled:expr),*) => ({\n+                        ($($pat:expr, => $demangled:expr),*) => ({\n                             $(if rest.starts_with($pat) {\n                                 try!(writer.write_str($demangled));\n                                 rest = rest.slice_from($pat.len());\n@@ -103,22 +103,22 @@ pub fn demangle(writer: &mut Writer, s: &str) -> IoResult<()> {\n \n                     // see src/librustc/back/link.rs for these mappings\n                     demangle! (\n-                        \"$SP$\" => \"@\",\n-                        \"$UP$\" => \"Box\",\n-                        \"$RP$\" => \"*\",\n-                        \"$BP$\" => \"&\",\n-                        \"$LT$\" => \"<\",\n-                        \"$GT$\" => \">\",\n-                        \"$LP$\" => \"(\",\n-                        \"$RP$\" => \")\",\n-                        \"$C$\"  => \",\",\n+                        \"$SP$\", => \"@\",\n+                        \"$UP$\", => \"Box\",\n+                        \"$RP$\", => \"*\",\n+                        \"$BP$\", => \"&\",\n+                        \"$LT$\", => \"<\",\n+                        \"$GT$\", => \">\",\n+                        \"$LP$\", => \"(\",\n+                        \"$RP$\", => \")\",\n+                        \"$C$\", => \",\",\n \n                         // in theory we can demangle any Unicode code point, but\n                         // for simplicity we just catch the common ones.\n-                        \"$u{20}\" => \" \",\n-                        \"$u{27}\" => \"'\",\n-                        \"$u{5b}\" => \"[\",\n-                        \"$u{5d}\" => \"]\"\n+                        \"$u{20}\", => \" \",\n+                        \"$u{27}\", => \"'\",\n+                        \"$u{5b}\", => \"[\",\n+                        \"$u{5d}\", => \"]\"\n                     )\n                 } else {\n                     let idx = match rest.find('$') {"}, {"sha": "95240cd7a8723703b1b8b50ea3c6b9dbd88096b4", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 185, "deletions": 8, "changes": 193, "blob_url": "https://github.com/rust-lang/rust/blob/26cd8eae48ea99bda183c5224bc423991ccfaf1f/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26cd8eae48ea99bda183c5224bc423991ccfaf1f/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=26cd8eae48ea99bda183c5224bc423991ccfaf1f", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use ast::{Ident, TtDelimited, TtSequence, TtToken};\n+use ast::{TokenTree, TtDelimited, TtSequence, TtToken};\n use ast;\n use codemap::{Span, DUMMY_SP};\n use ext::base::{ExtCtxt, MacResult, SyntaxExtension};\n@@ -19,8 +19,8 @@ use ext::tt::macro_parser::{parse, parse_or_else};\n use parse::lexer::{new_tt_reader, new_tt_reader_with_doc_flag};\n use parse::parser::Parser;\n use parse::attr::ParserAttr;\n-use parse::token::{special_idents, gensym_ident};\n-use parse::token::{MatchNt, NtTT};\n+use parse::token::{special_idents, gensym_ident, NtTT, Token};\n+use parse::token::Token::*;\n use parse::token;\n use print;\n use ptr::P;\n@@ -109,8 +109,8 @@ impl<'a> MacResult for ParserAnyMacro<'a> {\n }\n \n struct MacroRulesMacroExpander {\n-    name: Ident,\n-    imported_from: Option<Ident>,\n+    name: ast::Ident,\n+    imported_from: Option<ast::Ident>,\n     lhses: Vec<Rc<NamedMatch>>,\n     rhses: Vec<Rc<NamedMatch>>,\n }\n@@ -134,8 +134,8 @@ impl TTMacroExpander for MacroRulesMacroExpander {\n /// Given `lhses` and `rhses`, this is the new macro we create\n fn generic_extension<'cx>(cx: &'cx ExtCtxt,\n                           sp: Span,\n-                          name: Ident,\n-                          imported_from: Option<Ident>,\n+                          name: ast::Ident,\n+                          imported_from: Option<ast::Ident>,\n                           arg: &[ast::TokenTree],\n                           lhses: &[Rc<NamedMatch>],\n                           rhses: &[Rc<NamedMatch>])\n@@ -261,6 +261,10 @@ pub fn compile<'cx>(cx: &'cx mut ExtCtxt,\n         _ => cx.span_bug(def.span, \"wrong-structured lhs\")\n     };\n \n+    for lhs in lhses.iter() {\n+        check_lhs_nt_follows(cx, &**lhs, def.span);\n+    }\n+\n     let rhses = match *argument_map[rhs_nm] {\n         MatchedSeq(ref s, _) => /* FIXME (#2543) */ (*s).clone(),\n         _ => cx.span_bug(def.span, \"wrong-structured rhs\")\n@@ -275,3 +279,176 @@ pub fn compile<'cx>(cx: &'cx mut ExtCtxt,\n \n     NormalTT(exp, Some(def.span))\n }\n+\n+fn check_lhs_nt_follows(cx: &mut ExtCtxt, lhs: &NamedMatch, sp: Span) {\n+    // lhs is going to be like MatchedNonterminal(NtTT(TtDelimited(...))), where\n+    // the entire lhs is those tts.\n+    // if ever we get box/deref patterns, this could turn into an `if let\n+    // &MatchedNonterminal(NtTT(box TtDelimited(...))) = lhs`\n+    let matcher = match lhs {\n+        &MatchedNonterminal(NtTT(ref inner)) => match &**inner {\n+            &TtDelimited(_, ref tts) => tts.tts[],\n+            _ => cx.span_bug(sp, \"wrong-structured lhs for follow check\")\n+        },\n+        _ => cx.span_bug(sp, \"wrong-structured lhs for follow check\")\n+    };\n+\n+    check_matcher(cx, matcher.iter(), &Eof);\n+    // we don't abort on errors on rejection, the driver will do that for us\n+    // after parsing/expansion. we can report every error in every macro this way.\n+}\n+\n+// returns the last token that was checked, for TtSequence. this gets used later on.\n+fn check_matcher<'a, I>(cx: &mut ExtCtxt, matcher: I, follow: &Token)\n+-> Option<(Span, Token)> where I: Iterator<Item=&'a TokenTree> {\n+    use print::pprust::token_to_string;\n+\n+    let mut last = None;\n+\n+    // 2. For each token T in M:\n+    let mut tokens = matcher.peekable();\n+    while let Some(token) = tokens.next() {\n+        last = match *token {\n+            TtToken(sp, MatchNt(ref name, ref frag_spec, _, _)) => {\n+                // ii. If T is a simple NT, look ahead to the next token T' in\n+                // M.\n+                let next_token = match tokens.peek() {\n+                    // If T' closes a complex NT, replace T' with F\n+                    Some(&&TtToken(_, CloseDelim(_))) => follow.clone(),\n+                    Some(&&TtToken(_, ref tok)) => tok.clone(),\n+                    Some(&&TtSequence(sp, _)) => {\n+                        cx.span_err(sp, format!(\"`${0}:{1}` is followed by a sequence \\\n+                                                 repetition, which is not allowed for `{1}` \\\n+                                                 fragments\", name.as_str(), frag_spec.as_str())[]);\n+                        Eof\n+                    },\n+                    // die next iteration\n+                    Some(&&TtDelimited(_, ref delim)) => delim.close_token(),\n+                    // else, we're at the end of the macro or sequence\n+                    None => follow.clone()\n+                };\n+\n+                let tok = if let TtToken(_, ref tok) = *token { tok } else { unreachable!() };\n+                // If T' is in the set FOLLOW(NT), continue. Else, reject.\n+                match &next_token {\n+                    &Eof => return Some((sp, tok.clone())),\n+                    _ if is_in_follow(cx, &next_token, frag_spec.as_str()) => continue,\n+                    next => {\n+                        cx.span_err(sp, format!(\"`${0}:{1}` is followed by `{2}`, which \\\n+                                                 is not allowed for `{1}` fragments\",\n+                                                 name.as_str(), frag_spec.as_str(),\n+                                                 token_to_string(next))[]);\n+                        continue\n+                    },\n+                }\n+            },\n+            TtSequence(sp, ref seq) => {\n+                // iii. Else, T is a complex NT.\n+                match seq.separator {\n+                    // If T has the form $(...)U+ or $(...)U* for some token U,\n+                    // run the algorithm on the contents with F set to U. If it\n+                    // accepts, continue, else, reject.\n+                    Some(ref u) => {\n+                        let last = check_matcher(cx, seq.tts.iter(), u);\n+                        match last {\n+                            // Since the delimiter isn't required after the last repetition, make\n+                            // sure that the *next* token is sane. This doesn't actually compute\n+                            // the FIRST of the rest of the matcher yet, it only considers single\n+                            // tokens and simple NTs. This is imprecise, but conservatively\n+                            // correct.\n+                            Some((span, tok)) => {\n+                                let fol = match tokens.peek() {\n+                                    Some(&&TtToken(_, ref tok)) => tok.clone(),\n+                                    Some(&&TtDelimited(_, ref delim)) => delim.close_token(),\n+                                    Some(_) => {\n+                                        cx.span_err(sp, \"sequence repetition followed by \\\n+                                                another sequence repetition, which is not allowed\");\n+                                        Eof\n+                                    },\n+                                    None => Eof\n+                                };\n+                                check_matcher(cx, Some(&TtToken(span, tok.clone())).into_iter(),\n+                                              &fol)\n+                            },\n+                            None => last,\n+                        }\n+                    },\n+                    // If T has the form $(...)+ or $(...)*, run the algorithm on the contents with\n+                    // F set to the token following the sequence. If it accepts, continue, else,\n+                    // reject.\n+                    None => {\n+                        let fol = match tokens.peek() {\n+                            Some(&&TtToken(_, ref tok)) => tok.clone(),\n+                            Some(&&TtDelimited(_, ref delim)) => delim.close_token(),\n+                            Some(_) => {\n+                                cx.span_err(sp, \"sequence repetition followed by another \\\n+                                             sequence repetition, which is not allowed\");\n+                                Eof\n+                            },\n+                            None => Eof\n+                        };\n+                        check_matcher(cx, seq.tts.iter(), &fol)\n+                    }\n+                }\n+            },\n+            TtToken(..) => {\n+                // i. If T is not an NT, continue.\n+                continue\n+            },\n+            TtDelimited(_, ref tts) => {\n+                // if we don't pass in that close delimiter, we'll incorrectly consider the matcher\n+                // `{ $foo:ty }` as having a follow that isn't `RBrace`\n+                check_matcher(cx, tts.tts.iter(), &tts.close_token())\n+            }\n+        }\n+    }\n+    last\n+}\n+\n+fn is_in_follow(cx: &ExtCtxt, tok: &Token, frag: &str) -> bool {\n+    if let &CloseDelim(_) = tok {\n+        return true;\n+    }\n+\n+    match frag {\n+        \"item\" => {\n+            // since items *must* be followed by either a `;` or a `}`, we can\n+            // accept anything after them\n+            true\n+        },\n+        \"block\" => {\n+            // anything can follow block, the braces provide a easy boundary to\n+            // maintain\n+            true\n+        },\n+        \"stmt\" | \"expr\"  => {\n+            match *tok {\n+                FatArrow | Comma | Semi => true,\n+                _ => false\n+            }\n+        },\n+        \"pat\" => {\n+            match *tok {\n+                FatArrow | Comma | Eq => true,\n+                _ => false\n+            }\n+        },\n+        \"path\" | \"ty\" => {\n+            match *tok {\n+                Comma | FatArrow | Colon | Eq | Gt => true,\n+                Ident(i, _) if i.as_str() == \"as\" => true,\n+                _ => false\n+            }\n+        },\n+        \"ident\" => {\n+            // being a single token, idents are harmless\n+            true\n+        },\n+        \"meta\" | \"tt\" => {\n+            // being either a single token or a delimited sequence, tt is\n+            // harmless\n+            true\n+        },\n+        _ => cx.bug(format!(\"unrecognized builtin nonterminal {}\", frag)[]),\n+    }\n+}"}, {"sha": "013bce1755b353d5c8424c1d88983156aca7d8e7", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/26cd8eae48ea99bda183c5224bc423991ccfaf1f/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26cd8eae48ea99bda183c5224bc423991ccfaf1f/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=26cd8eae48ea99bda183c5224bc423991ccfaf1f", "patch": "@@ -392,6 +392,7 @@ impl fmt::Show for Nonterminal {\n     }\n }\n \n+\n // Get the first \"argument\"\n macro_rules! first {\n     ( $first:expr, $( $remainder:expr, )* ) => ( $first )"}, {"sha": "15f6d88fd8998da324e6d34fd415ec4d6bdedc3b", "filename": "src/test/compile-fail/macro-input-future-proofing.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/26cd8eae48ea99bda183c5224bc423991ccfaf1f/src%2Ftest%2Fcompile-fail%2Fmacro-input-future-proofing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26cd8eae48ea99bda183c5224bc423991ccfaf1f/src%2Ftest%2Fcompile-fail%2Fmacro-input-future-proofing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmacro-input-future-proofing.rs?ref=26cd8eae48ea99bda183c5224bc423991ccfaf1f", "patch": "@@ -0,0 +1,30 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+macro_rules! errors_everywhere {\n+    ($ty:ty <) => (); //~ ERROR `$ty:ty` is followed by `<`, which is not allowed for `ty`\n+    ($ty:ty < foo ,) => (); //~ ERROR `$ty:ty` is followed by `<`, which is not allowed for `ty`\n+    ($ty:ty , ) => ();\n+    ( ( $ty:ty ) ) => ();\n+    ( { $ty:ty } ) => ();\n+    ( [ $ty:ty ] ) => ();\n+    ($bl:block < ) => ();\n+    ($pa:pat >) => (); //~ ERROR `$pa:pat` is followed by `>`, which is not allowed for `pat`\n+    ($pa:pat , ) => ();\n+    ($pa:pat | ) => (); //~ ERROR `$pa:pat` is followed by `|`\n+    ($pa:pat $pb:pat $ty:ty ,) => ();\n+    //~^ ERROR `$pa:pat` is followed by `$pb:pat`, which is not allowed\n+    //~^^ ERROR `$pb:pat` is followed by `$ty:ty`, which is not allowed\n+    ($($ty:ty)* -) => (); //~ ERROR `$ty:ty` is followed by `-`\n+    ($($a:ty, $b:ty)* -) => (); //~ ERROR `$b:ty` is followed by `-`\n+    ($($ty:ty)-+) => (); //~ ERROR `$ty:ty` is followed by `-`, which is not allowed for `ty`\n+}\n+\n+fn main() { }"}, {"sha": "28b346c9ed4d0532e240902677419fa09dbd8375", "filename": "src/test/run-pass/const-polymorphic-paths.rs", "status": "modified", "additions": 25, "deletions": 26, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/26cd8eae48ea99bda183c5224bc423991ccfaf1f/src%2Ftest%2Frun-pass%2Fconst-polymorphic-paths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26cd8eae48ea99bda183c5224bc423991ccfaf1f/src%2Ftest%2Frun-pass%2Fconst-polymorphic-paths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-polymorphic-paths.rs?ref=26cd8eae48ea99bda183c5224bc423991ccfaf1f", "patch": "@@ -29,7 +29,7 @@ fn odd(x: uint) -> bool { x % 2 == 1 }\n fn dummy_rng() -> DummyRng { DummyRng::new_unseeded() }\n \n macro_rules! tests {\n-    ($($expr:expr: $ty:ty /($($test:expr),*);)+) => (pub fn main() {$({\n+    ($($expr:expr, $ty:ty, ($($test:expr),*);)+) => (pub fn main() {$({\n         const C: $ty = $expr;\n         static S: $ty = $expr;\n         assert!(eq(C($($test),*), $expr($($test),*)));\n@@ -40,45 +40,44 @@ macro_rules! tests {\n \n tests! {\n     // Free function.\n-    id: fn(int) -> int /(5);\n-    id::<int>: fn(int) -> int /(5);\n+    id, fn(int) -> int, (5);\n+    id::<int>, fn(int) -> int, (5);\n \n     // Enum variant constructor.\n-    Some: fn(int) -> Option<int> /(5);\n-    Some::<int>: fn(int) -> Option<int> /(5);\n+    Some, fn(int) -> Option<int>, (5);\n+    Some::<int>, fn(int) -> Option<int>, (5);\n \n     // Tuple struct constructor.\n-    Newt: fn(int) -> Newt<int> /(5);\n-    Newt::<int>: fn(int) -> Newt<int> /(5);\n+    Newt, fn(int) -> Newt<int>, (5);\n+    Newt::<int>, fn(int) -> Newt<int>, (5);\n \n     // Inherent static methods.\n-    Vec::new: fn() -> Vec<()> /();\n-    Vec::<()>::new: fn() -> Vec<()> /();\n-    Vec::with_capacity: fn(uint) -> Vec<()> /(5);\n-    Vec::<()>::with_capacity: fn(uint) -> Vec<()> /(5);\n-    Bitv::from_fn: fn(uint, fn(uint) -> bool) -> Bitv /(5, odd);\n-    Bitv::from_fn::<fn(uint) -> bool>: fn(uint, fn(uint) -> bool) -> Bitv /(5, odd);\n+    Vec::new, fn() -> Vec<()>, ();\n+    Vec::<()>::new, fn() -> Vec<()>, ();\n+    Vec::with_capacity, fn(uint) -> Vec<()>, (5);\n+    Vec::<()>::with_capacity, fn(uint) -> Vec<()>, (5);\n+    Bitv::from_fn, fn(uint, fn(uint) -> bool) -> Bitv, (5, odd);\n+    Bitv::from_fn::<fn(uint) -> bool>, fn(uint, fn(uint) -> bool) -> Bitv, (5, odd);\n \n     // Inherent non-static method.\n-    Vec::map_in_place: fn(Vec<u8>, fn(u8) -> i8) -> Vec<i8>\n-        /(vec![b'f', b'o', b'o'], u8_as_i8);\n-    Vec::map_in_place::<i8, fn(u8) -> i8>: fn(Vec<u8>, fn(u8) -> i8) -> Vec<i8>\n-        /(vec![b'f', b'o', b'o'], u8_as_i8);\n+    Vec::map_in_place, fn(Vec<u8>, fn(u8) -> i8) -> Vec<i8>, (vec![b'f', b'o', b'o'], u8_as_i8);\n+    Vec::map_in_place::<i8, fn(u8) -> i8>, fn(Vec<u8>, fn(u8) -> i8) -> Vec<i8>,\n+        (vec![b'f', b'o', b'o'], u8_as_i8);\n     // FIXME these break with \"type parameter might not appear here pointing at `<u8>`.\n     // Vec::<u8>::map_in_place: fn(Vec<u8>, fn(u8) -> i8) -> Vec<i8>\n-    //     /(vec![b'f', b'o', b'o'], u8_as_i8);\n+    //    , (vec![b'f', b'o', b'o'], u8_as_i8);\n     // Vec::<u8>::map_in_place::<i8, fn(u8) -> i8>: fn(Vec<u8>, fn(u8) -> i8) -> Vec<i8>\n-    //     /(vec![b'f', b'o', b'o'], u8_as_i8);\n+    //    , (vec![b'f', b'o', b'o'], u8_as_i8);\n \n     // Trait static methods.\n     // FIXME qualified path expressions aka UFCS i.e. <T as Trait>::method.\n-    Default::default: fn() -> int /();\n-    Rand::rand: fn(&mut DummyRng) -> int /(&mut dummy_rng());\n-    Rand::rand::<DummyRng>: fn(&mut DummyRng) -> int /(&mut dummy_rng());\n+    Default::default, fn() -> int, ();\n+    Rand::rand, fn(&mut DummyRng) -> int, (&mut dummy_rng());\n+    Rand::rand::<DummyRng>, fn(&mut DummyRng) -> int, (&mut dummy_rng());\n \n     // Trait non-static methods.\n-    Clone::clone: fn(&int) -> int /(&5);\n-    FromIterator::from_iter: fn(OptionIter<int>) -> Vec<int> /(Some(5).into_iter());\n-    FromIterator::from_iter::<OptionIter<int>>: fn(OptionIter<int>) -> Vec<int>\n-        /(Some(5).into_iter());\n+    Clone::clone, fn(&int) -> int, (&5);\n+    FromIterator::from_iter, fn(OptionIter<int>) -> Vec<int>, (Some(5).into_iter());\n+    FromIterator::from_iter::<OptionIter<int>>, fn(OptionIter<int>) -> Vec<int>\n+       , (Some(5).into_iter());\n }"}, {"sha": "0293c4e36ac59c09f89f47ba8c92d51e1e0a74e1", "filename": "src/test/run-pass/nullable-pointer-iotareduction.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/26cd8eae48ea99bda183c5224bc423991ccfaf1f/src%2Ftest%2Frun-pass%2Fnullable-pointer-iotareduction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26cd8eae48ea99bda183c5224bc423991ccfaf1f/src%2Ftest%2Frun-pass%2Fnullable-pointer-iotareduction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnullable-pointer-iotareduction.rs?ref=26cd8eae48ea99bda183c5224bc423991ccfaf1f", "patch": "@@ -35,10 +35,10 @@ impl<T> E<T> {\n }\n \n macro_rules! check_option {\n-    ($e:expr: $T:ty) => {{\n-        check_option!($e: $T, |ptr| assert!(*ptr == $e));\n+    ($e:expr, $T:ty) => {{\n+        check_option!($e, $T, |ptr| assert!(*ptr == $e));\n     }};\n-    ($e:expr: $T:ty, |$v:ident| $chk:expr) => {{\n+    ($e:expr, $T:ty, |$v:ident| $chk:expr) => {{\n         assert!(option::Option::None::<$T>.is_none());\n         let e = $e;\n         let s_ = option::Option::Some::<$T>(e);\n@@ -48,10 +48,10 @@ macro_rules! check_option {\n }\n \n macro_rules! check_fancy {\n-    ($e:expr: $T:ty) => {{\n-        check_fancy!($e: $T, |ptr| assert!(*ptr == $e));\n+    ($e:expr, $T:ty) => {{\n+        check_fancy!($e, $T, |ptr| assert!(*ptr == $e));\n     }};\n-    ($e:expr: $T:ty, |$v:ident| $chk:expr) => {{\n+    ($e:expr, $T:ty, |$v:ident| $chk:expr) => {{\n         assert!(E::Nothing::<$T>((), ((), ()), [23i8; 0]).is_none());\n         let e = $e;\n         let t_ = E::Thing::<$T>(23, e);\n@@ -71,12 +71,12 @@ macro_rules! check_type {\n }\n \n pub fn main() {\n-    check_type!(&17: &int);\n-    check_type!(box 18: Box<int>);\n-    check_type!(\"foo\".to_string(): String);\n-    check_type!(vec!(20, 22): Vec<int> );\n+    check_type!(&17, &int);\n+    check_type!(box 18, Box<int>);\n+    check_type!(\"foo\".to_string(), String);\n+    check_type!(vec!(20, 22), Vec<int> );\n     let mint: uint = unsafe { mem::transmute(main) };\n-    check_type!(main: fn(), |pthing| {\n+    check_type!(main, fn(), |pthing| {\n         assert!(mint == unsafe { mem::transmute(*pthing) })\n     });\n }"}]}