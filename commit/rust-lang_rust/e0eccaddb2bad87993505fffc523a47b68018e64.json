{"sha": "e0eccaddb2bad87993505fffc523a47b68018e64", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUwZWNjYWRkYjJiYWQ4Nzk5MzUwNWZmZmM1MjNhNDdiNjgwMThlNjQ=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-04-23T00:00:46Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-04-23T00:00:46Z"}, "message": "rustc: Thread the type store through everything that needs to access type structures", "tree": {"sha": "9cbc2786de5bf19b959c22c5b4606a3d2809c90e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9cbc2786de5bf19b959c22c5b4606a3d2809c90e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e0eccaddb2bad87993505fffc523a47b68018e64", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e0eccaddb2bad87993505fffc523a47b68018e64", "html_url": "https://github.com/rust-lang/rust/commit/e0eccaddb2bad87993505fffc523a47b68018e64", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e0eccaddb2bad87993505fffc523a47b68018e64/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3d62c9adf35e8685f131be50afbcc711bb43cf60", "url": "https://api.github.com/repos/rust-lang/rust/commits/3d62c9adf35e8685f131be50afbcc711bb43cf60", "html_url": "https://github.com/rust-lang/rust/commit/3d62c9adf35e8685f131be50afbcc711bb43cf60"}], "stats": {"total": 795, "additions": 412, "deletions": 383}, "files": [{"sha": "99dbf6ad2f887a5723674df01dda54ccada0154e", "filename": "src/comp/front/creader.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0eccaddb2bad87993505fffc523a47b68018e64/src%2Fcomp%2Ffront%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0eccaddb2bad87993505fffc523a47b68018e64/src%2Fcomp%2Ffront%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fcreader.rs?ref=e0eccaddb2bad87993505fffc523a47b68018e64", "patch": "@@ -546,7 +546,7 @@ fn get_tag_variants(session.session sess,\n         auto item = find_item(did._1, items);\n         auto ctor_ty = item_type(item, external_crate_id, tystore);\n         let vec[ty.t] arg_tys = vec();\n-        alt (ty.struct(ctor_ty)) {\n+        alt (ty.struct(tystore, ctor_ty)) {\n             case (ty.ty_fn(_, ?args, _)) {\n                 for (ty.arg a in args) {\n                     arg_tys += vec(a.ty);"}, {"sha": "bc4bce12892798a6ed65df773e8c96eda07b7d9a", "filename": "src/comp/middle/metadata.rs", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/e0eccaddb2bad87993505fffc523a47b68018e64/src%2Fcomp%2Fmiddle%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0eccaddb2bad87993505fffc523a47b68018e64/src%2Fcomp%2Fmiddle%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fmetadata.rs?ref=e0eccaddb2bad87993505fffc523a47b68018e64", "patch": "@@ -52,11 +52,12 @@ const uint tag_index_table = 0x15u;\n mod Encode {\n \n     type ctxt = rec(\n-        fn(ast.def_id) -> str ds    // Callback to translate defs to strs.\n+        fn(ast.def_id) -> str ds,   // Callback to translate defs to strs.\n+        @ty.type_store tystore      // The type store.\n     );\n \n     fn ty_str(@ctxt cx, ty.t t) -> str {\n-        ret sty_str(cx, ty.struct(t));\n+        ret sty_str(cx, ty.struct(cx.tystore, t));\n     }\n \n     fn mt_str(@ctxt cx, &ty.mt mt) -> str {\n@@ -332,11 +333,11 @@ fn encode_variant_id(&ebml.writer ebml_w, ast.def_id vid) {\n     ebml.end_tag(ebml_w);\n }\n \n-fn encode_type(&ebml.writer ebml_w, ty.t typ) {\n+fn encode_type(@trans.crate_ctxt cx, &ebml.writer ebml_w, ty.t typ) {\n     ebml.start_tag(ebml_w, tag_items_data_item_type);\n \n     auto f = def_to_str;\n-    auto ty_str_ctxt = @rec(ds=f);\n+    auto ty_str_ctxt = @rec(ds=f, tystore=cx.tystore);\n     ebml_w.writer.write(_str.bytes(Encode.ty_str(ty_str_ctxt, typ)));\n \n     ebml.end_tag(ebml_w);\n@@ -379,7 +380,7 @@ fn encode_tag_variant_info(@trans.crate_ctxt cx, &ebml.writer ebml_w,\n         encode_def_id(ebml_w, variant.node.id);\n         encode_kind(ebml_w, 'v' as u8);\n         encode_tag_id(ebml_w, did);\n-        encode_type(ebml_w, trans.node_ann_type(cx, variant.node.ann));\n+        encode_type(cx, ebml_w, trans.node_ann_type(cx, variant.node.ann));\n         if (_vec.len[ast.variant_arg](variant.node.args) > 0u) {\n             encode_symbol(cx, ebml_w, variant.node.id);\n         }\n@@ -396,7 +397,7 @@ fn encode_info_for_item(@trans.crate_ctxt cx, &ebml.writer ebml_w,\n             ebml.start_tag(ebml_w, tag_items_data_item);\n             encode_def_id(ebml_w, did);\n             encode_kind(ebml_w, 'c' as u8);\n-            encode_type(ebml_w, trans.node_ann_type(cx, ann));\n+            encode_type(cx, ebml_w, trans.node_ann_type(cx, ann));\n             encode_symbol(cx, ebml_w, did);\n             ebml.end_tag(ebml_w);\n         }\n@@ -405,7 +406,7 @@ fn encode_info_for_item(@trans.crate_ctxt cx, &ebml.writer ebml_w,\n             encode_def_id(ebml_w, did);\n             encode_kind(ebml_w, 'f' as u8);\n             encode_type_param_count(ebml_w, tps);\n-            encode_type(ebml_w, trans.node_ann_type(cx, ann));\n+            encode_type(cx, ebml_w, trans.node_ann_type(cx, ann));\n             encode_symbol(cx, ebml_w, did);\n             ebml.end_tag(ebml_w);\n         }\n@@ -426,15 +427,15 @@ fn encode_info_for_item(@trans.crate_ctxt cx, &ebml.writer ebml_w,\n             encode_def_id(ebml_w, did);\n             encode_kind(ebml_w, 'y' as u8);\n             encode_type_param_count(ebml_w, tps);\n-            encode_type(ebml_w, trans.node_ann_type(cx, ann));\n+            encode_type(cx, ebml_w, trans.node_ann_type(cx, ann));\n             ebml.end_tag(ebml_w);\n         }\n         case (ast.item_tag(?id, ?variants, ?tps, ?did, ?ann)) {\n             ebml.start_tag(ebml_w, tag_items_data_item);\n             encode_def_id(ebml_w, did);\n             encode_kind(ebml_w, 't' as u8);\n             encode_type_param_count(ebml_w, tps);\n-            encode_type(ebml_w, trans.node_ann_type(cx, ann));\n+            encode_type(cx, ebml_w, trans.node_ann_type(cx, ann));\n             for (ast.variant v in variants) {\n                 encode_variant_id(ebml_w, v.node.id);\n             }\n@@ -448,15 +449,15 @@ fn encode_info_for_item(@trans.crate_ctxt cx, &ebml.writer ebml_w,\n             encode_kind(ebml_w, 'o' as u8);\n             encode_type_param_count(ebml_w, tps);\n             auto fn_ty = trans.node_ann_type(cx, ann);\n-            encode_type(ebml_w, fn_ty);\n+            encode_type(cx, ebml_w, fn_ty);\n             encode_symbol(cx, ebml_w, odid.ctor);\n             ebml.end_tag(ebml_w);\n \n             ebml.start_tag(ebml_w, tag_items_data_item);\n             encode_def_id(ebml_w, odid.ty);\n             encode_kind(ebml_w, 'y' as u8);\n             encode_type_param_count(ebml_w, tps);\n-            encode_type(ebml_w, ty.ty_fn_ret(fn_ty));\n+            encode_type(cx, ebml_w, ty.ty_fn_ret(cx.tystore, fn_ty));\n             ebml.end_tag(ebml_w);\n         }\n     }\n@@ -469,13 +470,13 @@ fn encode_info_for_native_item(@trans.crate_ctxt cx, &ebml.writer ebml_w,\n         case (ast.native_item_ty(_, ?did)) {\n             encode_def_id(ebml_w, did);\n             encode_kind(ebml_w, 'T' as u8);\n-            encode_type(ebml_w, ty.mk_native(cx.tystore));\n+            encode_type(cx, ebml_w, ty.mk_native(cx.tystore));\n         }\n         case (ast.native_item_fn(_, _, _, ?tps, ?did, ?ann)) {\n             encode_def_id(ebml_w, did);\n             encode_kind(ebml_w, 'F' as u8);\n             encode_type_param_count(ebml_w, tps);\n-            encode_type(ebml_w, trans.node_ann_type(cx, ann));\n+            encode_type(cx, ebml_w, trans.node_ann_type(cx, ann));\n             encode_symbol(cx, ebml_w, did);\n         }\n     }"}, {"sha": "cf16d3172833225ce1c8cafc128833246073d6c5", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 186, "deletions": 168, "changes": 354, "blob_url": "https://github.com/rust-lang/rust/blob/e0eccaddb2bad87993505fffc523a47b68018e64/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0eccaddb2bad87993505fffc523a47b68018e64/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=e0eccaddb2bad87993505fffc523a47b68018e64", "patch": "@@ -185,7 +185,7 @@ fn mangle_name_by_type(@crate_ctxt ccx, vec[str] path, ty.t t) -> str {\n     ccx.sha.reset();\n \n     auto f = metadata.def_to_str;\n-    auto cx = @rec(ds=f);\n+    auto cx = @rec(ds=f, tystore=ccx.tystore);\n     ccx.sha.input_str(metadata.Encode.ty_str(cx, t));\n \n     ret sep() + \"rust\" + sep()\n@@ -558,9 +558,9 @@ fn T_opaque_obj_ptr(type_names tn) -> TypeRef {\n //\n // TODO: Enforce via a predicate.\n fn type_of(@crate_ctxt cx, ty.t t) -> TypeRef {\n-    if (ty.type_has_dynamic_size(t)) {\n+    if (ty.type_has_dynamic_size(cx.tystore, t)) {\n         log_err \"type_of() called on a type with dynamic size: \" +\n-            ty.ty_to_str(t);\n+            ty.ty_to_str(cx.tystore, t);\n         fail;\n     }\n \n@@ -570,7 +570,7 @@ fn type_of(@crate_ctxt cx, ty.t t) -> TypeRef {\n fn type_of_explicit_args(@crate_ctxt cx, vec[ty.arg] inputs) -> vec[TypeRef] {\n     let vec[TypeRef] atys = vec();\n     for (ty.arg arg in inputs) {\n-        if (ty.type_has_dynamic_size(arg.ty)) {\n+        if (ty.type_has_dynamic_size(cx.tystore, arg.ty)) {\n             check (arg.mode == ast.alias);\n             atys += vec(T_typaram_ptr(cx.tn));\n         } else {\n@@ -605,7 +605,7 @@ fn type_of_fn_full(@crate_ctxt cx,\n     let vec[TypeRef] atys = vec();\n \n     // Arg 0: Output pointer.\n-    if (ty.type_has_dynamic_size(output)) {\n+    if (ty.type_has_dynamic_size(cx.tystore, output)) {\n         atys += vec(T_typaram_ptr(cx.tn));\n     } else {\n         atys += vec(T_ptr(type_of_inner(cx, output)));\n@@ -686,7 +686,7 @@ fn type_of_inner(@crate_ctxt cx, ty.t t) -> TypeRef {\n \n     let TypeRef llty = 0 as TypeRef;\n \n-    alt (ty.struct(t)) {\n+    alt (ty.struct(cx.tystore, t)) {\n         case (ty.ty_native) { llty = T_ptr(T_i8()); }\n         case (ty.ty_nil) { llty = T_nil(); }\n         case (ty.ty_bool) { llty = T_bool(); }\n@@ -710,7 +710,7 @@ fn type_of_inner(@crate_ctxt cx, ty.t t) -> TypeRef {\n         case (ty.ty_char) { llty = T_char(); }\n         case (ty.ty_str) { llty = T_ptr(T_str()); }\n         case (ty.ty_tag(_, _)) {\n-            if (ty.type_has_dynamic_size(t)) {\n+            if (ty.type_has_dynamic_size(cx.tystore, t)) {\n                 llty = T_opaque_tag(cx.tn);\n             } else {\n                 auto size = static_size_of_tag(cx, t);\n@@ -786,13 +786,14 @@ fn type_of_inner(@crate_ctxt cx, ty.t t) -> TypeRef {\n     }\n \n     check (llty as int != 0);\n-    llvm.LLVMAddTypeName(cx.llmod, _str.buf(ty.ty_to_str(t)), llty);\n+    llvm.LLVMAddTypeName(cx.llmod, _str.buf(ty.ty_to_str(cx.tystore, t)),\n+                         llty);\n     cx.lltypes.insert(t, llty);\n     ret llty;\n }\n \n fn type_of_arg(@local_ctxt cx, &ty.arg arg) -> TypeRef {\n-    alt (ty.struct(arg.ty)) {\n+    alt (ty.struct(cx.ccx.tystore, arg.ty)) {\n         case (ty.ty_param(_)) {\n             if (arg.mode == ast.alias) {\n                 ret T_typaram_ptr(cx.ccx.tn);\n@@ -814,7 +815,7 @@ fn type_of_arg(@local_ctxt cx, &ty.arg arg) -> TypeRef {\n \n fn type_of_ty_param_count_and_ty(@local_ctxt lcx,\n                                  ty.ty_param_count_and_ty tpt) -> TypeRef {\n-    alt (ty.struct(tpt._1)) {\n+    alt (ty.struct(lcx.ccx.tystore, tpt._1)) {\n         case (ty.ty_fn(?proto, ?inputs, ?output)) {\n             auto llfnty = type_of_fn(lcx.ccx, proto, inputs, output, tpt._0);\n             ret T_fn_pair(lcx.ccx.tn, llfnty);\n@@ -1123,14 +1124,14 @@ fn llalign_of(TypeRef t) -> ValueRef {\n }\n \n fn size_of(@block_ctxt cx, ty.t t) -> result {\n-    if (!ty.type_has_dynamic_size(t)) {\n+    if (!ty.type_has_dynamic_size(cx.fcx.lcx.ccx.tystore, t)) {\n         ret res(cx, llsize_of(type_of(cx.fcx.lcx.ccx, t)));\n     }\n     ret dynamic_size_of(cx, t);\n }\n \n fn align_of(@block_ctxt cx, ty.t t) -> result {\n-    if (!ty.type_has_dynamic_size(t)) {\n+    if (!ty.type_has_dynamic_size(cx.fcx.lcx.ccx.tystore, t)) {\n         ret res(cx, llalign_of(type_of(cx.fcx.lcx.ccx, t)));\n     }\n     ret dynamic_align_of(cx, t);\n@@ -1151,7 +1152,7 @@ fn array_alloca(@block_ctxt cx, TypeRef t, ValueRef n) -> ValueRef {\n // types.\n fn simplify_type(@crate_ctxt ccx, ty.t typ) -> ty.t {\n     fn simplifier(@crate_ctxt ccx, ty.t typ) -> ty.t {\n-        alt (ty.struct(typ)) {\n+        alt (ty.struct(ccx.tystore, typ)) {\n             case (ty.ty_box(_)) {\n                 ret ty.mk_imm_box(ccx.tystore, ty.mk_nil(ccx.tystore));\n             }\n@@ -1164,7 +1165,7 @@ fn simplify_type(@crate_ctxt ccx, ty.t typ) -> ty.t {\n \n // Computes the size of the data part of a non-dynamically-sized tag.\n fn static_size_of_tag(@crate_ctxt cx, ty.t t) -> uint {\n-    if (ty.type_has_dynamic_size(t)) {\n+    if (ty.type_has_dynamic_size(cx.tystore, t)) {\n         log_err \"dynamically sized type passed to static_size_of_tag()\";\n         fail;\n     }\n@@ -1175,7 +1176,7 @@ fn static_size_of_tag(@crate_ctxt cx, ty.t t) -> uint {\n \n     auto tid;\n     let vec[ty.t] subtys;\n-    alt (ty.struct(t)) {\n+    alt (ty.struct(cx.tystore, t)) {\n         case (ty.ty_tag(?tid_, ?subtys_)) {\n             tid = tid_;\n             subtys = subtys_;\n@@ -1235,7 +1236,7 @@ fn dynamic_size_of(@block_ctxt cx, ty.t t) -> result {\n         ret res(bcx, off);\n     }\n \n-    alt (ty.struct(t)) {\n+    alt (ty.struct(cx.fcx.lcx.ccx.tystore, t)) {\n         case (ty.ty_param(?p)) {\n             auto szptr = field_of_tydesc(cx, t, abi.tydesc_field_size);\n             ret res(szptr.bcx, szptr.bcx.build.Load(szptr.val));\n@@ -1290,7 +1291,7 @@ fn dynamic_size_of(@block_ctxt cx, ty.t t) -> result {\n }\n \n fn dynamic_align_of(@block_ctxt cx, ty.t t) -> result {\n-    alt (ty.struct(t)) {\n+    alt (ty.struct(cx.fcx.lcx.ccx.tystore, t)) {\n         case (ty.ty_param(?p)) {\n             auto aptr = field_of_tydesc(cx, t, abi.tydesc_field_align);\n             ret res(aptr.bcx, aptr.bcx.build.Load(aptr.val));\n@@ -1330,11 +1331,11 @@ fn dynamic_align_of(@block_ctxt cx, ty.t t) -> result {\n fn GEP_tup_like(@block_ctxt cx, ty.t t,\n                 ValueRef base, vec[int] ixs) -> result {\n \n-    check (ty.type_is_tup_like(t));\n+    check (ty.type_is_tup_like(cx.fcx.lcx.ccx.tystore, t));\n \n     // It might be a static-known type. Handle this.\n \n-    if (! ty.type_has_dynamic_size(t)) {\n+    if (! ty.type_has_dynamic_size(cx.fcx.lcx.ccx.tystore, t)) {\n         let vec[ValueRef] v = vec();\n         for (int i in ixs) {\n             v += vec(C_int(i));\n@@ -1359,7 +1360,7 @@ fn GEP_tup_like(@block_ctxt cx, ty.t t,\n     // elements of the type and splitting the Xth off. Return the prefix as\n     // well as the innermost Xth type.\n \n-    fn split_type(ty.t t, vec[int] ixs, uint n)\n+    fn split_type(@crate_ctxt ccx, ty.t t, vec[int] ixs, uint n)\n         -> rec(vec[ty.t] prefix, ty.t target) {\n \n         let uint len = _vec.len[int](ixs);\n@@ -1375,7 +1376,7 @@ fn GEP_tup_like(@block_ctxt cx, ty.t t,\n             // *single* structure, the first index (in GEP-ese) should just be\n             // 0, to yield the pointee.\n             check (ixs.(n) == 0);\n-            ret split_type(t, ixs, n+1u);\n+            ret split_type(ccx, t, ixs, n+1u);\n         }\n \n         check (n < len);\n@@ -1384,11 +1385,12 @@ fn GEP_tup_like(@block_ctxt cx, ty.t t,\n         let vec[ty.t] prefix = vec();\n         let int i = 0;\n         while (i < ix) {\n-            _vec.push[ty.t](prefix, ty.get_element_type(t, i as uint));\n+            _vec.push[ty.t](prefix,\n+                            ty.get_element_type(ccx.tystore, t, i as uint));\n             i += 1 ;\n         }\n \n-        auto selected = ty.get_element_type(t, i as uint);\n+        auto selected = ty.get_element_type(ccx.tystore, t, i as uint);\n \n         if (n == len-1u) {\n             // We are at the innermost index.\n@@ -1398,7 +1400,7 @@ fn GEP_tup_like(@block_ctxt cx, ty.t t,\n             // Not the innermost index; call self recursively to dig deeper.\n             // Once we get an inner result, append it current prefix and\n             // return to caller.\n-            auto inner = split_type(selected, ixs, n+1u);\n+            auto inner = split_type(ccx, selected, ixs, n+1u);\n             prefix += inner.prefix;\n             ret rec(prefix=prefix with inner);\n         }\n@@ -1408,15 +1410,15 @@ fn GEP_tup_like(@block_ctxt cx, ty.t t,\n     // the tuple parens are associative so it doesn't matter that we've\n     // flattened the incoming structure.\n \n-    auto s = split_type(t, ixs, 0u);\n+    auto s = split_type(cx.fcx.lcx.ccx, t, ixs, 0u);\n     auto prefix_ty = ty.mk_imm_tup(cx.fcx.lcx.ccx.tystore, s.prefix);\n     auto bcx = cx;\n     auto sz = size_of(bcx, prefix_ty);\n     bcx = sz.bcx;\n     auto raw = bcx.build.PointerCast(base, T_ptr(T_i8()));\n     auto bumped = bcx.build.GEP(raw, vec(sz.val));\n \n-    if (ty.type_has_dynamic_size(s.target)) {\n+    if (ty.type_has_dynamic_size(cx.fcx.lcx.ccx.tystore, s.target)) {\n         ret res(bcx, bumped);\n     }\n \n@@ -1460,7 +1462,7 @@ fn GEP_tag(@block_ctxt cx,\n     // Cast the blob pointer to the appropriate type, if we need to (i.e. if\n     // the blob pointer isn't dynamically sized).\n     let ValueRef llunionptr;\n-    if (!ty.type_has_dynamic_size(tup_ty)) {\n+    if (!ty.type_has_dynamic_size(cx.fcx.lcx.ccx.tystore, tup_ty)) {\n         auto llty = type_of(cx.fcx.lcx.ccx, tup_ty);\n         llunionptr = cx.build.TruncOrBitCast(llblobptr, T_ptr(llty));\n     } else {\n@@ -1472,7 +1474,7 @@ fn GEP_tag(@block_ctxt cx,\n \n     // Cast the result to the appropriate type, if necessary.\n     auto val;\n-    if (!ty.type_has_dynamic_size(elem_ty)) {\n+    if (!ty.type_has_dynamic_size(cx.fcx.lcx.ccx.tystore, elem_ty)) {\n         auto llelemty = type_of(rslt.bcx.fcx.lcx.ccx, elem_ty);\n         val = rslt.bcx.build.PointerCast(rslt.val, T_ptr(llelemty));\n     } else {\n@@ -1529,7 +1531,7 @@ fn linearize_ty_params(@block_ctxt cx, ty.t t) ->\n                   mutable vec[uint] defs);\n \n     fn linearizer(@rr r, ty.t t) {\n-        alt(ty.struct(t)) {\n+        alt(ty.struct(r.cx.fcx.lcx.ccx.tystore, t)) {\n             case (ty.ty_param(?pid)) {\n                 let bool seen = false;\n                 for (uint d in r.defs) {\n@@ -1552,22 +1554,22 @@ fn linearize_ty_params(@block_ctxt cx, ty.t t) ->\n                   mutable defs = param_defs);\n \n     auto f = bind linearizer(x, _);\n-    ty.walk_ty(f, t);\n+    ty.walk_ty(cx.fcx.lcx.ccx.tystore, f, t);\n \n     ret tup(x.defs, x.vals);\n }\n \n fn get_tydesc(&@block_ctxt cx, ty.t t) -> result {\n     // Is the supplied type a type param? If so, return the passed-in tydesc.\n-    alt (ty.type_param(t)) {\n+    alt (ty.type_param(cx.fcx.lcx.ccx.tystore, t)) {\n         case (some[uint](?id)) { ret res(cx, cx.fcx.lltydescs.(id)); }\n         case (none[uint])      { /* fall through */ }\n     }\n \n     // Does it contain a type param? If so, generate a derived tydesc.\n-    let uint n_params = ty.count_ty_params(t);\n+    let uint n_params = ty.count_ty_params(cx.fcx.lcx.ccx.tystore, t);\n \n-    if (ty.count_ty_params(t) > 0u) {\n+    if (ty.count_ty_params(cx.fcx.lcx.ccx.tystore, t) > 0u) {\n         auto tys = linearize_ty_params(cx, t);\n \n         check (n_params == _vec.len[uint](tys._0));\n@@ -1633,7 +1635,7 @@ fn declare_tydesc(@local_ctxt cx, ty.t t) {\n \n     auto llsize;\n     auto llalign;\n-    if (!ty.type_has_dynamic_size(t)) {\n+    if (!ty.type_has_dynamic_size(ccx.tystore, t)) {\n         auto llty = type_of(ccx, t);\n         llsize = llsize_of(llty);\n         llalign = llalign_of(llty);\n@@ -1646,7 +1648,8 @@ fn declare_tydesc(@local_ctxt cx, ty.t t) {\n \n     auto glue_fn_ty = T_ptr(T_glue_fn(ccx.tn));\n \n-    auto name = sanitize(ccx.names.next(\"tydesc_\" + ty.ty_to_str(t)));\n+    auto name = sanitize(ccx.names.next(\"tydesc_\" +\n+        ty.ty_to_str(cx.ccx.tystore, t)));\n     auto gvar = llvm.LLVMAddGlobal(ccx.llmod, T_tydesc(ccx.tn),\n                                    _str.buf(name));\n     auto tydesc = C_struct(vec(C_null(T_ptr(T_ptr(T_tydesc(ccx.tn)))),\n@@ -1719,7 +1722,7 @@ fn make_generic_glue(@local_ctxt cx,\n     // passed by value.\n \n     auto llty;\n-    if (ty.type_has_dynamic_size(t)) {\n+    if (ty.type_has_dynamic_size(cx.ccx.tystore, t)) {\n         llty = T_ptr(T_i8());\n     } else {\n         llty = T_ptr(type_of(cx.ccx, t));\n@@ -1766,10 +1769,10 @@ fn make_generic_glue(@local_ctxt cx,\n fn make_take_glue(@block_ctxt cx, ValueRef v, ty.t t) {\n     // NB: v is an *alias* of type t here, not a direct value.\n     auto bcx;\n-    if (ty.type_is_boxed(t)) {\n+    if (ty.type_is_boxed(cx.fcx.lcx.ccx.tystore, t)) {\n         bcx = incr_refcnt_of_boxed(cx, cx.build.Load(v)).bcx;\n \n-    } else if (ty.type_is_structural(t)) {\n+    } else if (ty.type_is_structural(cx.fcx.lcx.ccx.tystore, t)) {\n         bcx = iter_structural_ty(cx, v, t,\n                                  bind take_ty(_, _, _)).bcx;\n     } else {\n@@ -1800,7 +1803,7 @@ fn incr_refcnt_of_boxed(@block_ctxt cx, ValueRef box_ptr) -> result {\n fn make_drop_glue(@block_ctxt cx, ValueRef v0, ty.t t) {\n     // NB: v0 is an *alias* of type t here, not a direct value.\n     auto rslt;\n-    alt (ty.struct(t)) {\n+    alt (ty.struct(cx.fcx.lcx.ccx.tystore, t)) {\n         case (ty.ty_str) {\n             auto v = cx.build.Load(v0);\n             rslt = decr_refcnt_and_if_zero\n@@ -1941,13 +1944,13 @@ fn make_drop_glue(@block_ctxt cx, ValueRef v0, ty.t t) {\n         }\n \n         case (_) {\n-            if (ty.type_is_structural(t)) {\n+            if (ty.type_is_structural(cx.fcx.lcx.ccx.tystore, t)) {\n                 rslt = iter_structural_ty(cx, v0, t,\n                                           bind drop_ty(_, _, _));\n \n-            } else if (ty.type_is_scalar(t) ||\n-                       ty.type_is_native(t) ||\n-                       ty.type_is_nil(t)) {\n+            } else if (ty.type_is_scalar(cx.fcx.lcx.ccx.tystore, t) ||\n+                       ty.type_is_native(cx.fcx.lcx.ccx.tystore, t) ||\n+                       ty.type_is_nil(cx.fcx.lcx.ccx.tystore, t)) {\n                 rslt = res(cx, C_nil());\n             }\n         }\n@@ -2009,19 +2012,19 @@ fn make_cmp_glue(@block_ctxt cx,\n     auto lhs = load_if_immediate(cx, lhs0, t);\n     auto rhs = load_if_immediate(cx, rhs0, t);\n \n-    if (ty.type_is_scalar(t)) {\n+    if (ty.type_is_scalar(cx.fcx.lcx.ccx.tystore, t)) {\n         make_scalar_cmp_glue(cx, lhs, rhs, t, llop);\n \n-    } else if (ty.type_is_box(t)) {\n+    } else if (ty.type_is_box(cx.fcx.lcx.ccx.tystore, t)) {\n         lhs = cx.build.GEP(lhs, vec(C_int(0), C_int(abi.box_rc_field_body)));\n         rhs = cx.build.GEP(rhs, vec(C_int(0), C_int(abi.box_rc_field_body)));\n         auto rslt = call_cmp_glue(cx, lhs, rhs, t, llop);\n \n         rslt.bcx.build.Store(rslt.val, cx.fcx.llretptr);\n         rslt.bcx.build.RetVoid();\n \n-    } else if (ty.type_is_structural(t)\n-               || ty.type_is_sequence(t)) {\n+    } else if (ty.type_is_structural(cx.fcx.lcx.ccx.tystore, t)\n+               || ty.type_is_sequence(cx.fcx.lcx.ccx.tystore, t)) {\n \n         auto scx = new_sub_block_ctxt(cx, \"structural compare start\");\n         auto next = new_sub_block_ctxt(cx, \"structural compare end\");\n@@ -2055,7 +2058,7 @@ fn make_cmp_glue(@block_ctxt cx,\n         llvm.LLVMSetValueName(flag, _str.buf(\"flag\"));\n \n         auto r;\n-        if (ty.type_is_sequence(t)) {\n+        if (ty.type_is_sequence(cx.fcx.lcx.ccx.tystore, t)) {\n \n             // If we hit == all the way through the minimum-shared-length\n             // section, default to judging the relative sequence lengths.\n@@ -2094,7 +2097,8 @@ fn make_cmp_glue(@block_ctxt cx,\n                 // be i8, because the data part of a vector always has type\n                 // i8[]. So we need to cast it to the proper type.\n \n-                if (!ty.type_has_dynamic_size(t)) {\n+                if (!ty.type_has_dynamic_size(last_cx.fcx.lcx.ccx.tystore,\n+                                              t)) {\n                     auto llelemty = T_ptr(type_of(last_cx.fcx.lcx.ccx, t));\n                     av = cx.build.PointerCast(av, llelemty);\n                     bv = cx.build.PointerCast(bv, llelemty);\n@@ -2116,7 +2120,7 @@ fn make_cmp_glue(@block_ctxt cx,\n             ret res(cnt_cx, C_nil());\n         }\n \n-        if (ty.type_is_structural(t)) {\n+        if (ty.type_is_structural(cx.fcx.lcx.ccx.tystore, t)) {\n             r = iter_structural_ty_full(r.bcx, lhs, rhs, t,\n                                         bind inner(next, false, flag, llop,\n                                                    _, _, _, _));\n@@ -2143,31 +2147,34 @@ fn make_cmp_glue(@block_ctxt cx,\n     } else {\n         // FIXME: compare obj, fn by pointer?\n         trans_fail(cx, none[common.span],\n-                   \"attempt to compare values of type \" + ty.ty_to_str(t));\n+                   \"attempt to compare values of type \" +\n+                   ty.ty_to_str(cx.fcx.lcx.ccx.tystore, t));\n     }\n }\n \n // A helper function to create scalar comparison glue.\n fn make_scalar_cmp_glue(@block_ctxt cx, ValueRef lhs, ValueRef rhs, ty.t t,\n                         ValueRef llop) {\n-    if (ty.type_is_fp(t)) {\n+    if (ty.type_is_fp(cx.fcx.lcx.ccx.tystore, t)) {\n         make_fp_cmp_glue(cx, lhs, rhs, t, llop);\n         ret;\n     }\n \n-    if (ty.type_is_integral(t) || ty.type_is_bool(t)) {\n+    if (ty.type_is_integral(cx.fcx.lcx.ccx.tystore, t) ||\n+            ty.type_is_bool(cx.fcx.lcx.ccx.tystore, t)) {\n         make_integral_cmp_glue(cx, lhs, rhs, t, llop);\n         ret;\n     }\n \n-    if (ty.type_is_nil(t)) {\n+    if (ty.type_is_nil(cx.fcx.lcx.ccx.tystore, t)) {\n         cx.build.Store(C_bool(true), cx.fcx.llretptr);\n         cx.build.RetVoid();\n         ret;\n     }\n \n     trans_fail(cx, none[common.span],\n-               \"attempt to compare values of type \" + ty.ty_to_str(t));\n+               \"attempt to compare values of type \" +\n+               ty.ty_to_str(cx.fcx.lcx.ccx.tystore, t));\n }\n \n // A helper function to create floating point comparison glue.\n@@ -2246,8 +2253,8 @@ fn compare_integral_values(@block_ctxt cx, ValueRef lhs, ValueRef rhs,\n // A helper function to create integral comparison glue.\n fn make_integral_cmp_glue(@block_ctxt cx, ValueRef lhs, ValueRef rhs,\n                           ty.t intype, ValueRef llop) {\n-    auto r = compare_integral_values(cx, lhs, rhs, ty.type_is_signed(intype),\n-                                     llop);\n+    auto r = compare_integral_values(cx, lhs, rhs,\n+        ty.type_is_signed(cx.fcx.lcx.ccx.tystore, intype), llop);\n     r.bcx.build.Store(r.val, r.bcx.fcx.llretptr);\n     r.bcx.build.RetVoid();\n }\n@@ -2271,7 +2278,7 @@ fn tag_variants(@crate_ctxt cx, ast.def_id id) -> vec[variant_info] {\n                 auto ctor_ty = node_ann_type(cx, variant.node.ann);\n                 let vec[ty.t] arg_tys = vec();\n                 if (_vec.len[ast.variant_arg](variant.node.args) > 0u) {\n-                    for (ty.arg a in ty.ty_fn_args(ctor_ty)) {\n+                    for (ty.arg a in ty.ty_fn_args(cx.tystore, ctor_ty)) {\n                         arg_tys += vec(a.ty);\n                     }\n                 }\n@@ -2356,7 +2363,7 @@ fn iter_structural_ty_full(@block_ctxt cx,\n         ret res(next_cx, r.val);\n     }\n \n-    alt (ty.struct(t)) {\n+    alt (ty.struct(cx.fcx.lcx.ccx.tystore, t)) {\n         case (ty.ty_tup(?args)) {\n             let int i = 0;\n             for (ty.mt arg in args) {\n@@ -2430,7 +2437,7 @@ fn iter_structural_ty_full(@block_ctxt cx,\n                 if (_vec.len[ty.t](variant.args) > 0u) {\n                     // N-ary variant.\n                     auto fn_ty = variant.ctor_ty;\n-                    alt (ty.struct(fn_ty)) {\n+                    alt (ty.struct(bcx.fcx.lcx.ccx.tystore, fn_ty)) {\n                         case (ty.ty_fn(_, ?args, _)) {\n                             auto j = 0;\n                             for (ty.arg a in args) {\n@@ -2570,7 +2577,7 @@ fn iter_sequence_inner(@block_ctxt cx,\n                   ValueRef dst,\n                   ValueRef src) -> result {\n         auto llptrty;\n-        if (!ty.type_has_dynamic_size(elt_ty)) {\n+        if (!ty.type_has_dynamic_size(cx.fcx.lcx.ccx.tystore, elt_ty)) {\n             auto llty = type_of(cx.fcx.lcx.ccx, elt_ty);\n             llptrty = T_ptr(llty);\n         } else {\n@@ -2605,7 +2612,7 @@ fn iter_sequence(@block_ctxt cx,\n                                           C_int(abi.vec_elt_fill)));\n \n         auto llunit_ty;\n-        if (ty.type_has_dynamic_size(elt_ty)) {\n+        if (ty.type_has_dynamic_size(cx.fcx.lcx.ccx.tystore, elt_ty)) {\n             llunit_ty = T_i8();\n         } else {\n             llunit_ty = type_of(cx.fcx.lcx.ccx, elt_ty);\n@@ -2626,7 +2633,7 @@ fn iter_sequence(@block_ctxt cx,\n         ret iter_sequence_inner(cx, p0, p1, elt_ty, f);\n     }\n \n-    alt (ty.struct(t)) {\n+    alt (ty.struct(cx.fcx.lcx.ccx.tystore, t)) {\n         case (ty.ty_vec(?elt)) {\n             ret iter_sequence_body(cx, v, elt.ty, f, false);\n         }\n@@ -2701,7 +2708,7 @@ fn call_cmp_glue(@block_ctxt cx, ValueRef lhs, ValueRef rhs, ty.t t,\n }\n \n fn take_ty(@block_ctxt cx, ValueRef v, ty.t t) -> result {\n-    if (!ty.type_is_scalar(t)) {\n+    if (!ty.type_is_scalar(cx.fcx.lcx.ccx.tystore, t)) {\n         call_tydesc_glue(cx, v, t, abi.tydesc_field_take_glue);\n     }\n     ret res(cx, C_nil());\n@@ -2723,7 +2730,7 @@ fn drop_ty(@block_ctxt cx,\n            ValueRef v,\n            ty.t t) -> result {\n \n-    if (!ty.type_is_scalar(t)) {\n+    if (!ty.type_is_scalar(cx.fcx.lcx.ccx.tystore, t)) {\n         call_tydesc_glue(cx, v, t, abi.tydesc_field_drop_glue);\n     }\n     ret res(cx, C_nil());\n@@ -2753,7 +2760,7 @@ fn memcpy_ty(@block_ctxt cx,\n              ValueRef dst,\n              ValueRef src,\n              ty.t t) -> result {\n-    if (ty.type_has_dynamic_size(t)) {\n+    if (ty.type_has_dynamic_size(cx.fcx.lcx.ccx.tystore, t)) {\n         auto llszptr = field_of_tydesc(cx, t, abi.tydesc_field_size);\n         auto llsz = llszptr.bcx.build.Load(llszptr.val);\n         ret call_memcpy(llszptr.bcx, dst, src, llsz);\n@@ -2773,21 +2780,22 @@ fn copy_ty(@block_ctxt cx,\n            ValueRef dst,\n            ValueRef src,\n            ty.t t) -> result {\n-    if (ty.type_is_scalar(t) || ty.type_is_native(t)) {\n+    if (ty.type_is_scalar(cx.fcx.lcx.ccx.tystore, t) ||\n+            ty.type_is_native(cx.fcx.lcx.ccx.tystore, t)) {\n         ret res(cx, cx.build.Store(src, dst));\n \n-    } else if (ty.type_is_nil(t)) {\n+    } else if (ty.type_is_nil(cx.fcx.lcx.ccx.tystore, t)) {\n         ret res(cx, C_nil());\n \n-    } else if (ty.type_is_boxed(t)) {\n+    } else if (ty.type_is_boxed(cx.fcx.lcx.ccx.tystore, t)) {\n         auto r = take_ty(cx, src, t);\n         if (action == DROP_EXISTING) {\n             r = drop_ty(r.bcx, r.bcx.build.Load(dst), t);\n         }\n         ret res(r.bcx, r.bcx.build.Store(src, dst));\n \n-    } else if (ty.type_is_structural(t) ||\n-               ty.type_has_dynamic_size(t)) {\n+    } else if (ty.type_is_structural(cx.fcx.lcx.ccx.tystore, t) ||\n+               ty.type_has_dynamic_size(cx.fcx.lcx.ccx.tystore, t)) {\n         auto r = take_ty(cx, src, t);\n         if (action == DROP_EXISTING) {\n             r = drop_ty(r.bcx, dst, t);\n@@ -2796,7 +2804,7 @@ fn copy_ty(@block_ctxt cx,\n     }\n \n     cx.fcx.lcx.ccx.sess.bug(\"unexpected type in trans.copy_ty: \" +\n-                        ty.ty_to_str(t));\n+                        ty.ty_to_str(cx.fcx.lcx.ccx.tystore, t));\n     fail;\n }\n \n@@ -2853,7 +2861,7 @@ fn trans_lit(@crate_ctxt cx, &ast.lit lit, &ast.ann ann) -> ValueRef {\n }\n \n fn target_type(@crate_ctxt cx, ty.t t) -> ty.t {\n-    alt (ty.struct(t)) {\n+    alt (ty.struct(cx.tystore, t)) {\n         case (ty.ty_int) {\n             auto struct_ty = ty.mk_mach(cx.tystore,\n                                         cx.sess.get_targ_cfg().int_type);\n@@ -2917,7 +2925,7 @@ fn trans_unary(@block_ctxt cx, ast.unop op,\n         case (ast.neg) {\n             sub = autoderef(sub.bcx, sub.val,\n                             ty.expr_ty(cx.fcx.lcx.ccx.tystore, e));\n-            if(ty.struct(e_ty) == ty.ty_float) {\n+            if(ty.struct(cx.fcx.lcx.ccx.tystore, e_ty) == ty.ty_float) {\n                 ret res(sub.bcx, sub.bcx.build.FNeg(sub.val));\n             }\n             else {\n@@ -2944,7 +2952,7 @@ fn trans_unary(@block_ctxt cx, ast.unop op,\n             // Cast the body type to the type of the value. This is needed to\n             // make tags work, since tags have a different LLVM type depending\n             // on whether they're boxed or not.\n-            if (!ty.type_has_dynamic_size(e_ty)) {\n+            if (!ty.type_has_dynamic_size(cx.fcx.lcx.ccx.tystore, e_ty)) {\n                 auto llety = T_ptr(type_of(sub.bcx.fcx.lcx.ccx, e_ty));\n                 body = sub.bcx.build.PointerCast(body, llety);\n             }\n@@ -2974,7 +2982,7 @@ fn trans_compare(@block_ctxt cx0, ast.binop op, ty.t t0,\n     auto rhs = rhs_r.val;\n     cx = rhs_r.bcx;\n \n-    auto t = autoderefed_ty(t0);\n+    auto t = autoderefed_ty(cx.fcx.lcx.ccx, t0);\n \n     // Determine the operation we need.\n     // FIXME: Use or-patterns when we have them.\n@@ -3008,7 +3016,7 @@ fn trans_vec_append(@block_ctxt cx, ty.t t,\n     auto elt_ty = ty.sequence_element_type(cx.fcx.lcx.ccx.tystore, t);\n \n     auto skip_null = C_bool(false);\n-    alt (ty.struct(t)) {\n+    alt (ty.struct(cx.fcx.lcx.ccx.tystore, t)) {\n         case (ty.ty_str) { skip_null = C_bool(true); }\n         case (_) { }\n     }\n@@ -3048,7 +3056,7 @@ fn trans_eager_binop(@block_ctxt cx, ast.binop op, ty.t intype,\n                      ValueRef lhs, ValueRef rhs) -> result {\n \n     auto is_float = false;\n-    alt (ty.struct(intype)) {\n+    alt (ty.struct(cx.fcx.lcx.ccx.tystore, intype)) {\n         case (ty.ty_float) {\n             is_float = true;\n         }\n@@ -3059,7 +3067,7 @@ fn trans_eager_binop(@block_ctxt cx, ast.binop op, ty.t intype,\n \n     alt (op) {\n         case (ast.add) {\n-            if (ty.type_is_sequence(intype)) {\n+            if (ty.type_is_sequence(cx.fcx.lcx.ccx.tystore, intype)) {\n                 ret trans_vec_add(cx, intype, lhs, rhs);\n             }\n             if (is_float) {\n@@ -3091,7 +3099,7 @@ fn trans_eager_binop(@block_ctxt cx, ast.binop op, ty.t intype,\n             if (is_float) {\n                 ret res(cx, cx.build.FDiv(lhs, rhs));\n             }\n-            if (ty.type_is_signed(intype)) {\n+            if (ty.type_is_signed(cx.fcx.lcx.ccx.tystore, intype)) {\n                 ret res(cx, cx.build.SDiv(lhs, rhs));\n             } else {\n                 ret res(cx, cx.build.UDiv(lhs, rhs));\n@@ -3101,7 +3109,7 @@ fn trans_eager_binop(@block_ctxt cx, ast.binop op, ty.t intype,\n             if (is_float) {\n                 ret res(cx, cx.build.FRem(lhs, rhs));\n             }\n-            if (ty.type_is_signed(intype)) {\n+            if (ty.type_is_signed(cx.fcx.lcx.ccx.tystore, intype)) {\n                 ret res(cx, cx.build.SRem(lhs, rhs));\n             } else {\n                 ret res(cx, cx.build.URem(lhs, rhs));\n@@ -3126,7 +3134,7 @@ fn autoderef(@block_ctxt cx, ValueRef v, ty.t t) -> result {\n     let ty.t t1 = t;\n \n     while (true) {\n-        alt (ty.struct(t1)) {\n+        alt (ty.struct(cx.fcx.lcx.ccx.tystore, t1)) {\n             case (ty.ty_box(?mt)) {\n                 auto body = cx.build.GEP(v1,\n                                          vec(C_int(0),\n@@ -3137,7 +3145,8 @@ fn autoderef(@block_ctxt cx, ValueRef v, ty.t t) -> result {\n                 // to cast this pointer, since statically-sized tag types have\n                 // different types depending on whether they're behind a box\n                 // or not.\n-                if (!ty.type_has_dynamic_size(mt.ty)) {\n+                if (!ty.type_has_dynamic_size(cx.fcx.lcx.ccx.tystore,\n+                                              mt.ty)) {\n                     auto llty = type_of(cx.fcx.lcx.ccx, mt.ty);\n                     v1 = cx.build.PointerCast(body, T_ptr(llty));\n                 } else {\n@@ -3153,11 +3162,11 @@ fn autoderef(@block_ctxt cx, ValueRef v, ty.t t) -> result {\n     }\n }\n \n-fn autoderefed_ty(ty.t t) -> ty.t {\n+fn autoderefed_ty(@crate_ctxt ccx, ty.t t) -> ty.t {\n     let ty.t t1 = t;\n \n     while (true) {\n-        alt (ty.struct(t1)) {\n+        alt (ty.struct(ccx.tystore, t1)) {\n             case (ty.ty_box(?mt)) {\n                 t1 = mt.ty;\n             }\n@@ -3227,8 +3236,7 @@ fn trans_binary(@block_ctxt cx, ast.binop op,\n             auto rhty = ty.expr_ty(cx.fcx.lcx.ccx.tystore, b);\n             rhs = autoderef(rhs.bcx, rhs.val, rhty);\n             ret trans_eager_binop(rhs.bcx, op,\n-                                  autoderefed_ty(lhty),\n-                                  lhs.val, rhs.val);\n+                autoderefed_ty(cx.fcx.lcx.ccx, lhty), lhs.val, rhs.val);\n         }\n     }\n     fail;\n@@ -3303,11 +3311,11 @@ fn trans_if(@block_ctxt cx, @ast.expr cond,\n             // if expression can have a non-nil type.\n             // FIXME: This isn't quite right, particularly re: dynamic types\n             auto expr_ty = ty.expr_ty(cx.fcx.lcx.ccx.tystore, elexpr);\n-            if (ty.type_has_dynamic_size(expr_ty)) {\n+            if (ty.type_has_dynamic_size(cx.fcx.lcx.ccx.tystore, expr_ty)) {\n                 expr_llty = T_typaram_ptr(cx.fcx.lcx.ccx.tn);\n             } else {\n                 expr_llty = type_of(else_res.bcx.fcx.lcx.ccx, expr_ty);\n-                if (ty.type_is_structural(expr_ty)) {\n+                if (ty.type_is_structural(cx.fcx.lcx.ccx.tystore, expr_ty)) {\n                     expr_llty = T_ptr(expr_llty);\n                 }\n             }\n@@ -3832,11 +3840,11 @@ fn trans_alt(@block_ctxt cx, @ast.expr expr,\n     // FIXME: This isn't quite right, particularly re: dynamic types\n     auto expr_ty = ty.ann_to_type(ann);\n     auto expr_llty;\n-    if (ty.type_has_dynamic_size(expr_ty)) {\n+    if (ty.type_has_dynamic_size(cx.fcx.lcx.ccx.tystore, expr_ty)) {\n         expr_llty = T_typaram_ptr(cx.fcx.lcx.ccx.tn);\n     } else {\n         expr_llty = type_of(cx.fcx.lcx.ccx, expr_ty);\n-        if (ty.type_is_structural(expr_ty)) {\n+        if (ty.type_is_structural(cx.fcx.lcx.ccx.tystore, expr_ty)) {\n             expr_llty = T_ptr(expr_llty);\n         }\n     }\n@@ -3993,7 +4001,7 @@ fn trans_path(@block_ctxt cx, &ast.path p, &option.t[ast.def] dopt,\n                     auto v_tyt = ty.lookup_item_type(cx.fcx.lcx.ccx.sess,\n                         cx.fcx.lcx.ccx.tystore,\n                         cx.fcx.lcx.ccx.type_cache, vid);\n-                    alt (ty.struct(v_tyt._1)) {\n+                    alt (ty.struct(cx.fcx.lcx.ccx.tystore, v_tyt._1)) {\n                         case (ty.ty_fn(_, _, _)) {\n                             // N-ary variant.\n                             ret lval_generic_fn(cx, v_tyt, vid, ann);\n@@ -4009,7 +4017,8 @@ fn trans_path(@block_ctxt cx, &ast.path p, &option.t[ast.def] dopt,\n                             auto lltagblob = alloc_result.val;\n \n                             auto lltagty;\n-                            if (ty.type_has_dynamic_size(tag_ty)) {\n+                            if (ty.type_has_dynamic_size(\n+                                    cx.fcx.lcx.ccx.tystore, tag_ty)) {\n                                 lltagty = T_opaque_tag(cx.fcx.lcx.ccx.tn);\n                             } else {\n                                 lltagty = type_of(cx.fcx.lcx.ccx, tag_ty);\n@@ -4053,9 +4062,9 @@ fn trans_field(@block_ctxt cx, &ast.span sp, ValueRef v, ty.t t0,\n                &ast.ident field, &ast.ann ann) -> lval_result {\n \n     auto r = autoderef(cx, v, t0);\n-    auto t = autoderefed_ty(t0);\n+    auto t = autoderefed_ty(cx.fcx.lcx.ccx, t0);\n \n-    alt (ty.struct(t)) {\n+    alt (ty.struct(cx.fcx.lcx.ccx.tystore, t)) {\n         case (ty.ty_tup(_)) {\n             let uint ix = ty.field_num(cx.fcx.lcx.ccx.sess, sp, field);\n             auto v = GEP_tup_like(r.bcx, t, r.val, vec(0, ix as int));\n@@ -4134,7 +4143,7 @@ fn trans_index(@block_ctxt cx, &ast.span sp, @ast.expr base,\n \n     auto body = next_cx.build.GEP(v, vec(C_int(0), C_int(abi.vec_elt_data)));\n     auto elt;\n-    if (ty.type_has_dynamic_size(unit_ty)) {\n+    if (ty.type_has_dynamic_size(cx.fcx.lcx.ccx.tystore, unit_ty)) {\n         body = next_cx.build.PointerCast(body, T_ptr(T_array(T_i8(), 0u)));\n         elt = next_cx.build.GEP(body, vec(C_int(0), scaled_ix));\n     } else {\n@@ -4201,15 +4210,16 @@ fn trans_cast(@block_ctxt cx, @ast.expr e, &ast.ann ann) -> result {\n     auto llsrctype = val_ty(e_res.val);\n     auto t = node_ann_type(cx.fcx.lcx.ccx, ann);\n     auto lldsttype = type_of(cx.fcx.lcx.ccx, t);\n-    if (!ty.type_is_fp(t)) {\n+    if (!ty.type_is_fp(cx.fcx.lcx.ccx.tystore, t)) {\n         // TODO: native-to-native casts\n-        if (ty.type_is_native(ty.expr_ty(cx.fcx.lcx.ccx.tystore, e))) {\n+        if (ty.type_is_native(cx.fcx.lcx.ccx.tystore,\n+                              ty.expr_ty(cx.fcx.lcx.ccx.tystore, e))) {\n             e_res.val = e_res.bcx.build.PtrToInt(e_res.val, lldsttype);\n-        } else if (ty.type_is_native(t)) {\n+        } else if (ty.type_is_native(cx.fcx.lcx.ccx.tystore, t)) {\n             e_res.val = e_res.bcx.build.IntToPtr(e_res.val, lldsttype);\n         } else if (llvm.LLVMGetIntTypeWidth(lldsttype) >\n             llvm.LLVMGetIntTypeWidth(llsrctype)) {\n-            if (ty.type_is_signed(t)) {\n+            if (ty.type_is_signed(cx.fcx.lcx.ccx.tystore, t)) {\n                 // Widening signed cast.\n                 e_res.val =\n                     e_res.bcx.build.SExtOrBitCast(e_res.val,\n@@ -4265,11 +4275,11 @@ fn trans_bind_thunk(@local_ctxt cx,\n                                              C_int(abi.fn_field_box)));\n     lltargetclosure = bcx.build.Load(lltargetclosure);\n \n-    auto outgoing_ret_ty = ty.ty_fn_ret(outgoing_fty);\n-    auto outgoing_args = ty.ty_fn_args(outgoing_fty);\n+    auto outgoing_ret_ty = ty.ty_fn_ret(cx.ccx.tystore, outgoing_fty);\n+    auto outgoing_args = ty.ty_fn_args(cx.ccx.tystore, outgoing_fty);\n \n     auto llretptr = fcx.llretptr;\n-    if (ty.type_has_dynamic_size(outgoing_ret_ty)) {\n+    if (ty.type_has_dynamic_size(cx.ccx.tystore, outgoing_ret_ty)) {\n         llretptr = bcx.build.PointerCast(llretptr, T_typaram_ptr(cx.ccx.tn));\n     }\n \n@@ -4318,7 +4328,8 @@ fn trans_bind_thunk(@local_ctxt cx,\n \n                 if (out_arg.mode == ast.val) {\n                     val = bcx.build.Load(val);\n-                } else if (ty.count_ty_params(out_arg.ty) > 0u) {\n+                } else if (ty.count_ty_params(cx.ccx.tystore,\n+                                              out_arg.ty) > 0u) {\n                     check (out_arg.mode == ast.alias);\n                     val = bcx.build.PointerCast(val, llout_arg_ty);\n                 }\n@@ -4331,7 +4342,7 @@ fn trans_bind_thunk(@local_ctxt cx,\n             case (none[@ast.expr]) {\n                 let ValueRef passed_arg = llvm.LLVMGetParam(llthunk, a);\n \n-                if (ty.count_ty_params(out_arg.ty) > 0u) {\n+                if (ty.count_ty_params(cx.ccx.tystore, out_arg.ty) > 0u) {\n                     check (out_arg.mode == ast.alias);\n                     passed_arg = bcx.build.PointerCast(passed_arg,\n                                                        llout_arg_ty);\n@@ -4353,7 +4364,8 @@ fn trans_bind_thunk(@local_ctxt cx,\n     // Cast the outgoing function to the appropriate type (see the comments in\n     // trans_bind below for why this is necessary).\n     auto lltargetty = type_of_fn(bcx.fcx.lcx.ccx,\n-                                 ty.ty_fn_proto(outgoing_fty),\n+                                 ty.ty_fn_proto(bcx.fcx.lcx.ccx.tystore,\n+                                                outgoing_fty),\n                                  outgoing_args,\n                                  outgoing_ret_ty,\n                                  ty_param_count);\n@@ -4476,10 +4488,10 @@ fn trans_bind(@block_ctxt cx, @ast.expr f,\n             // function has, which type_of() doesn't, as only we know which\n             // item the function refers to.\n             auto llfnty = type_of_fn(bcx.fcx.lcx.ccx,\n-                                     ty.ty_fn_proto(outgoing_fty),\n-                                     ty.ty_fn_args(outgoing_fty),\n-                                     ty.ty_fn_ret(outgoing_fty),\n-                                     ty_param_count);\n+                ty.ty_fn_proto(bcx.fcx.lcx.ccx.tystore, outgoing_fty),\n+                ty.ty_fn_args(bcx.fcx.lcx.ccx.tystore, outgoing_fty),\n+                ty.ty_fn_ret(bcx.fcx.lcx.ccx.tystore, outgoing_fty),\n+                ty_param_count);\n             auto llclosurety = T_ptr(T_fn_pair(bcx.fcx.lcx.ccx.tn, llfnty));\n \n             // Store thunk-target.\n@@ -4574,31 +4586,31 @@ fn trans_args(@block_ctxt cx,\n               ty.t fn_ty)\n     -> tup(@block_ctxt, vec[ValueRef], ValueRef) {\n \n-    let vec[ty.arg] args = ty.ty_fn_args(fn_ty);\n+    let vec[ty.arg] args = ty.ty_fn_args(cx.fcx.lcx.ccx.tystore, fn_ty);\n     let vec[ValueRef] llargs = vec();\n     let vec[ValueRef] lltydescs = vec();\n     let @block_ctxt bcx = cx;\n \n \n     // Arg 0: Output pointer.\n-    auto retty = ty.ty_fn_ret(fn_ty);\n+    auto retty = ty.ty_fn_ret(cx.fcx.lcx.ccx.tystore, fn_ty);\n     auto llretslot_res = alloc_ty(bcx, retty);\n     bcx = llretslot_res.bcx;\n     auto llretslot = llretslot_res.val;\n \n     alt (gen) {\n         case (some[generic_info](?g)) {\n             lltydescs = g.tydescs;\n-            args = ty.ty_fn_args(g.item_type);\n-            retty = ty.ty_fn_ret(g.item_type);\n+            args = ty.ty_fn_args(cx.fcx.lcx.ccx.tystore, g.item_type);\n+            retty = ty.ty_fn_ret(cx.fcx.lcx.ccx.tystore, g.item_type);\n         }\n         case (_) {\n         }\n     }\n-    if (ty.type_has_dynamic_size(retty)) {\n+    if (ty.type_has_dynamic_size(cx.fcx.lcx.ccx.tystore, retty)) {\n         llargs += vec(bcx.build.PointerCast\n                       (llretslot, T_typaram_ptr(cx.fcx.lcx.ccx.tn)));\n-    } else if (ty.count_ty_params(retty) != 0u) {\n+    } else if (ty.count_ty_params(cx.fcx.lcx.ccx.tystore, retty) != 0u) {\n         // It's possible that the callee has some generic-ness somewhere in\n         // its return value -- say a method signature within an obj or a fn\n         // type deep in a structure -- which the caller has a concrete view\n@@ -4651,7 +4663,8 @@ fn trans_args(@block_ctxt cx,\n         auto mode = args.(i).mode;\n \n         auto val;\n-        if (ty.type_is_structural(ty.expr_ty(cx.fcx.lcx.ccx.tystore, e))) {\n+        if (ty.type_is_structural(cx.fcx.lcx.ccx.tystore,\n+                                  ty.expr_ty(cx.fcx.lcx.ccx.tystore, e))) {\n             auto re = trans_expr(bcx, e);\n             val = re.val;\n             bcx = re.bcx;\n@@ -4661,7 +4674,8 @@ fn trans_args(@block_ctxt cx,\n                 lv = trans_lval(bcx, e);\n             } else {\n                 auto r = trans_expr(bcx, e);\n-                if (type_is_immediate(ty.expr_ty(cx.fcx.lcx.ccx.tystore,\n+                if (type_is_immediate(cx.fcx.lcx.ccx,\n+                                      ty.expr_ty(cx.fcx.lcx.ccx.tystore,\n                                                  e))) {\n                     lv = lval_val(r.bcx, r.val);\n                 } else {\n@@ -4684,12 +4698,12 @@ fn trans_args(@block_ctxt cx,\n             bcx = re.bcx;\n         }\n \n-        if (ty.count_ty_params(args.(i).ty) > 0u) {\n+        if (ty.count_ty_params(cx.fcx.lcx.ccx.tystore, args.(i).ty) > 0u) {\n             auto lldestty = arg_tys.(i);\n             if (mode == ast.val) {\n                 // FIXME: we'd prefer to use &&, but rustboot doesn't like it\n-                if (ty.type_is_structural(ty.expr_ty(cx.fcx.lcx.ccx.tystore,\n-                                                     e))) {\n+                if (ty.type_is_structural(cx.fcx.lcx.ccx.tystore,\n+                        ty.expr_ty(cx.fcx.lcx.ccx.tystore, e))) {\n                     lldestty = T_ptr(lldestty);\n                 }\n             }\n@@ -4699,8 +4713,8 @@ fn trans_args(@block_ctxt cx,\n \n         if (mode == ast.val) {\n             // FIXME: we'd prefer to use &&, but rustboot doesn't like it\n-            if (ty.type_is_structural(ty.expr_ty(cx.fcx.lcx.ccx.tystore,\n-                                                 e))) {\n+            if (ty.type_is_structural(cx.fcx.lcx.ccx.tystore,\n+                    ty.expr_ty(cx.fcx.lcx.ccx.tystore, e))) {\n                 // Until here we've been treating structures by pointer;\n                 // we are now passing it as an arg, so need to load it.\n                 val = bcx.build.Load(val);\n@@ -4783,7 +4797,7 @@ fn trans_call(@block_ctxt cx, @ast.expr f,\n     bcx.build.FastCall(faddr, llargs);\n     auto retval = C_nil();\n \n-    if (!ty.type_is_nil(ret_ty)) {\n+    if (!ty.type_is_nil(cx.fcx.lcx.ccx.tystore, ret_ty)) {\n         retval = load_if_immediate(bcx, llretslot, ret_ty);\n         // Retval doesn't correspond to anything really tangible in the frame,\n         // but it's a ref all the same, so we put a note here to drop it when\n@@ -4823,7 +4837,7 @@ fn trans_vec(@block_ctxt cx, vec[@ast.expr] args,\n              &ast.ann ann) -> result {\n     auto t = node_ann_type(cx.fcx.lcx.ccx, ann);\n     auto unit_ty = t;\n-    alt (ty.struct(t)) {\n+    alt (ty.struct(cx.fcx.lcx.ccx.tystore, t)) {\n         case (ty.ty_vec(?mt)) {\n             unit_ty = mt.ty;\n         }\n@@ -4875,7 +4889,7 @@ fn trans_vec(@block_ctxt cx, vec[@ast.expr] args,\n         // (5) \"src_res\" is derived from \"unit_ty\", which is not behind a box.\n \n         auto dst_val;\n-        if (!ty.type_has_dynamic_size(unit_ty)) {\n+        if (!ty.type_has_dynamic_size(cx.fcx.lcx.ccx.tystore, unit_ty)) {\n             auto llunit_ty = type_of(cx.fcx.lcx.ccx, unit_ty);\n             dst_val = bcx.build.PointerCast(dst_res.val, T_ptr(llunit_ty));\n         } else {\n@@ -4917,7 +4931,7 @@ fn trans_rec(@block_ctxt cx, vec[ast.field] fields,\n     }\n \n     let vec[ty.field] ty_fields = vec();\n-    alt (ty.struct(t)) {\n+    alt (ty.struct(cx.fcx.lcx.ccx.tystore, t)) {\n         case (ty.ty_rec(?flds)) { ty_fields = flds; }\n     }\n \n@@ -5120,8 +5134,10 @@ fn trans_expr(@block_ctxt cx, @ast.expr e) -> result {\n // pointer (or need one), perform load/store operations based on the\n // immediate-ness of the type.\n \n-fn type_is_immediate(ty.t t) -> bool {\n-    ret ty.type_is_scalar(t) || ty.type_is_boxed(t) || ty.type_is_native(t);\n+fn type_is_immediate(@crate_ctxt ccx, ty.t t) -> bool {\n+    ret ty.type_is_scalar(ccx.tystore, t) ||\n+        ty.type_is_boxed(ccx.tystore, t) ||\n+        ty.type_is_native(ccx.tystore, t);\n }\n \n fn do_spill(@block_ctxt cx, ValueRef v) -> ValueRef {\n@@ -5132,14 +5148,14 @@ fn do_spill(@block_ctxt cx, ValueRef v) -> ValueRef {\n }\n \n fn spill_if_immediate(@block_ctxt cx, ValueRef v, ty.t t) -> ValueRef {\n-    if (type_is_immediate(t)) {\n+    if (type_is_immediate(cx.fcx.lcx.ccx, t)) {\n         ret do_spill(cx, v);\n     }\n     ret v;\n }\n \n fn load_if_immediate(@block_ctxt cx, ValueRef v, ty.t t) -> ValueRef {\n-    if (type_is_immediate(t)) {\n+    if (type_is_immediate(cx.fcx.lcx.ccx, t)) {\n         ret cx.build.Load(v);\n     }\n     ret v;\n@@ -5170,10 +5186,10 @@ fn trans_log(int lvl, @block_ctxt cx, @ast.expr e) -> result {\n     auto sub = trans_expr(log_cx, e);\n     auto e_ty = ty.expr_ty(cx.fcx.lcx.ccx.tystore, e);\n \n-    if (ty.type_is_fp(e_ty)) {\n+    if (ty.type_is_fp(cx.fcx.lcx.ccx.tystore, e_ty)) {\n         let TypeRef tr;\n         let bool is32bit = false;\n-        alt (ty.struct(e_ty)) {\n+        alt (ty.struct(cx.fcx.lcx.ccx.tystore, e_ty)) {\n             case (ty.ty_machine(util.common.ty_f32)) {\n                 tr = T_f32();\n                 is32bit = true;\n@@ -5199,7 +5215,7 @@ fn trans_log(int lvl, @block_ctxt cx, @ast.expr e) -> result {\n             uval.bcx.build.Br(after_cx.llbb);\n         }\n     } else {\n-        alt (ty.struct(e_ty)) {\n+        alt (ty.struct(cx.fcx.lcx.ccx.tystore, e_ty)) {\n             case (ty.ty_str) {\n                 auto v = vp2i(sub.bcx, sub.val);\n                 trans_upcall(sub.bcx,\n@@ -5284,8 +5300,8 @@ fn trans_put(@block_ctxt cx, &option.t[@ast.expr] e) -> result {\n \n             auto llarg = r.val;\n             bcx = r.bcx;\n-            if (ty.type_is_structural(ty.expr_ty(cx.fcx.lcx.ccx.tystore,\n-                                                 x))) {\n+            if (ty.type_is_structural(cx.fcx.lcx.ccx.tystore,\n+                    ty.expr_ty(cx.fcx.lcx.ccx.tystore, x))) {\n                 // Until here we've been treating structures by pointer; we\n                 // are now passing it as an arg, so need to load it.\n                 llarg = bcx.build.Load(llarg);\n@@ -5385,7 +5401,7 @@ fn trans_port(@block_ctxt cx, ast.ann ann) -> result {\n \n     auto t = node_ann_type(cx.fcx.lcx.ccx, ann);\n     auto unit_ty;\n-    alt (ty.struct(t)) {\n+    alt (ty.struct(cx.fcx.lcx.ccx.tystore, t)) {\n         case (ty.ty_port(?t)) {\n             unit_ty = t;\n         }\n@@ -5440,7 +5456,7 @@ fn trans_send(@block_ctxt cx, @ast.expr lhs, @ast.expr rhs,\n \n     auto chan_ty = node_ann_type(cx.fcx.lcx.ccx, ann);\n     auto unit_ty;\n-    alt (ty.struct(chan_ty)) {\n+    alt (ty.struct(cx.fcx.lcx.ccx.tystore, chan_ty)) {\n         case (ty.ty_chan(?t)) {\n             unit_ty = t;\n         }\n@@ -5532,7 +5548,7 @@ fn init_local(@block_ctxt cx, @ast.local local) -> result {\n \n fn zero_alloca(@block_ctxt cx, ValueRef llptr, ty.t t) -> result {\n     auto bcx = cx;\n-    if (ty.type_has_dynamic_size(t)) {\n+    if (ty.type_has_dynamic_size(cx.fcx.lcx.ccx.tystore, t)) {\n         auto llsz = size_of(bcx, t);\n         bcx = call_bzero(llsz.bcx, llptr, llsz.val).bcx;\n     } else {\n@@ -5665,7 +5681,7 @@ fn llallocas_block_ctxt(@fn_ctxt fcx) -> @block_ctxt {\n \n fn alloc_ty(@block_ctxt cx, ty.t t) -> result {\n     auto val = C_int(0);\n-    if (ty.type_has_dynamic_size(t)) {\n+    if (ty.type_has_dynamic_size(cx.fcx.lcx.ccx.tystore, t)) {\n \n         // NB: we have to run this particular 'size_of' in a\n         // block_ctxt built on the llallocas block for the fn,\n@@ -5721,7 +5737,7 @@ fn trans_block(@block_ctxt cx, &ast.block b) -> result {\n                 ret r;\n             } else {\n                 auto r_ty = ty.expr_ty(cx.fcx.lcx.ccx.tystore, e);\n-                if (!ty.type_is_nil(r_ty)) {\n+                if (!ty.type_is_nil(cx.fcx.lcx.ccx.tystore, r_ty)) {\n                     // The value resulting from the block gets copied into an\n                     // alloca created in an outer scope and its refcount\n                     // bumped so that it can escape this block. This means\n@@ -5917,17 +5933,17 @@ fn is_terminated(@block_ctxt cx) -> bool {\n     ret llvm.LLVMIsATerminatorInst(inst) as int != 0;\n }\n \n-fn arg_tys_of_fn(ast.ann ann) -> vec[ty.arg] {\n-    alt (ty.struct(ty.ann_to_type(ann))) {\n+fn arg_tys_of_fn(@crate_ctxt ccx, ast.ann ann) -> vec[ty.arg] {\n+    alt (ty.struct(ccx.tystore, ty.ann_to_type(ann))) {\n         case (ty.ty_fn(_, ?arg_tys, _)) {\n             ret arg_tys;\n         }\n     }\n     fail;\n }\n \n-fn ret_ty_of_fn_ty(ty.t t) -> ty.t {\n-    alt (ty.struct(t)) {\n+fn ret_ty_of_fn_ty(@crate_ctxt ccx, ty.t t) -> ty.t {\n+    alt (ty.struct(ccx.tystore, t)) {\n         case (ty.ty_fn(_, _, ?ret_ty)) {\n             ret ret_ty;\n         }\n@@ -5936,8 +5952,8 @@ fn ret_ty_of_fn_ty(ty.t t) -> ty.t {\n }\n \n \n-fn ret_ty_of_fn(ast.ann ann) -> ty.t {\n-    ret ret_ty_of_fn_ty(ty.ann_to_type(ann));\n+fn ret_ty_of_fn(@crate_ctxt ccx, ast.ann ann) -> ty.t {\n+    ret ret_ty_of_fn_ty(ccx, ty.ann_to_type(ann));\n }\n \n fn populate_fn_ctxt_from_llself(@fn_ctxt fcx, self_vt llself) {\n@@ -5978,7 +5994,7 @@ fn populate_fn_ctxt_from_llself(@fn_ctxt fcx, self_vt llself) {\n     // If we can (i.e. the type is statically sized), then cast the resulting\n     // fields pointer to the appropriate LLVM type. If not, just leave it as\n     // i8 *.\n-    if (!ty.type_has_dynamic_size(fields_tup_ty)) {\n+    if (!ty.type_has_dynamic_size(fcx.lcx.ccx.tystore, fields_tup_ty)) {\n         auto llfields_ty = type_of(fcx.lcx.ccx, fields_tup_ty);\n         obj_fields = vi2p(bcx, obj_fields, T_ptr(llfields_ty));\n     } else {\n@@ -6017,7 +6033,7 @@ fn trans_fn(@local_ctxt cx, &ast._fn f, ast.def_id fid,\n \n     auto fcx = new_fn_ctxt(cx, llfndecl);\n     create_llargs_for_fn_args(fcx, f.proto,\n-                              ty_self, ret_ty_of_fn(ann),\n+                              ty_self, ret_ty_of_fn(cx.ccx, ann),\n                               f.decl.inputs, ty_params);\n \n     copy_any_self_to_alloca(fcx, ty_self);\n@@ -6030,7 +6046,7 @@ fn trans_fn(@local_ctxt cx, &ast._fn f, ast.def_id fid,\n         }\n     }\n \n-    copy_args_to_allocas(fcx, f.decl.inputs, arg_tys_of_fn(ann));\n+    copy_args_to_allocas(fcx, f.decl.inputs, arg_tys_of_fn(fcx.lcx.ccx, ann));\n \n     auto bcx = new_top_block_ctxt(fcx);\n     auto lltop = bcx.llbb;\n@@ -6063,7 +6079,7 @@ fn trans_vtbl(@local_ctxt cx,\n     for (@ast.method m in meths) {\n \n         auto llfnty = T_nil();\n-        alt (ty.struct(node_ann_type(cx.ccx, m.node.ann))) {\n+        alt (ty.struct(cx.ccx.tystore, node_ann_type(cx.ccx, m.node.ann))) {\n             case (ty.ty_fn(?proto, ?inputs, ?output)) {\n                 llfnty = type_of_fn_full(cx.ccx, proto,\n                                          some[TypeRef](llself_ty),\n@@ -6102,7 +6118,7 @@ fn trans_dtor(@local_ctxt cx,\n               &@ast.method dtor) -> ValueRef {\n \n     auto llfnty = T_nil();\n-    alt (ty.struct(node_ann_type(cx.ccx, dtor.node.ann))) {\n+    alt (ty.struct(cx.ccx.tystore, node_ann_type(cx.ccx, dtor.node.ann))) {\n         case (ty.ty_fn(?proto, ?inputs, ?output)) {\n             llfnty = type_of_fn_full(cx.ccx, proto,\n                                      some[TypeRef](llself_ty),\n@@ -6141,16 +6157,16 @@ fn trans_obj(@local_ctxt cx, &ast._obj ob, ast.def_id oid,\n     auto fcx = new_fn_ctxt(cx, llctor_decl);\n     create_llargs_for_fn_args(fcx, ast.proto_fn,\n                               none[tup(TypeRef, ty.t)], \n-                              ret_ty_of_fn(ann),\n+                              ret_ty_of_fn(cx.ccx, ann),\n                               fn_args, ty_params);\n \n-    let vec[ty.arg] arg_tys = arg_tys_of_fn(ann);\n+    let vec[ty.arg] arg_tys = arg_tys_of_fn(cx.ccx, ann);\n     copy_args_to_allocas(fcx, fn_args, arg_tys);\n \n     auto bcx = new_top_block_ctxt(fcx);\n     auto lltop = bcx.llbb;\n \n-    auto self_ty = ret_ty_of_fn(ann);\n+    auto self_ty = ret_ty_of_fn(cx.ccx, ann);\n     auto llself_ty = type_of(ccx, self_ty);\n     auto pair = bcx.fcx.llretptr;\n     auto vtbl = trans_vtbl(cx, llself_ty, self_ty, ob, ty_params);\n@@ -6284,7 +6300,7 @@ fn trans_tag_variant(@local_ctxt cx, ast.def_id tag_id,\n \n     create_llargs_for_fn_args(fcx, ast.proto_fn,\n                               none[tup(TypeRef, ty.t)], \n-                              ret_ty_of_fn(variant.node.ann),\n+                              ret_ty_of_fn(cx.ccx, variant.node.ann),\n                               fn_args, ty_params);\n \n     let vec[ty.t] ty_param_substs = vec();\n@@ -6294,7 +6310,7 @@ fn trans_tag_variant(@local_ctxt cx, ast.def_id tag_id,\n         i += 1u;\n     }\n \n-    auto arg_tys = arg_tys_of_fn(variant.node.ann);\n+    auto arg_tys = arg_tys_of_fn(cx.ccx, variant.node.ann);\n     copy_args_to_allocas(fcx, fn_args, arg_tys);\n \n     auto bcx = new_top_block_ctxt(fcx);\n@@ -6326,8 +6342,8 @@ fn trans_tag_variant(@local_ctxt cx, ast.def_id tag_id,\n \n         auto arg_ty = arg_tys.(i).ty;\n         auto llargval;\n-        if (ty.type_is_structural(arg_ty) ||\n-                ty.type_has_dynamic_size(arg_ty)) {\n+        if (ty.type_is_structural(cx.ccx.tystore, arg_ty) ||\n+                ty.type_has_dynamic_size(cx.ccx.tystore, arg_ty)) {\n             llargval = llargptr;\n         } else {\n             llargval = bcx.build.Load(llargptr);\n@@ -6426,7 +6442,7 @@ fn decl_fn_and_pair(@crate_ctxt ccx,\n \n     auto llfty;\n     auto llpairty;\n-    alt (ty.struct(node_ann_type(ccx, ann))) {\n+    alt (ty.struct(ccx.tystore, node_ann_type(ccx, ann))) {\n         case (ty.ty_fn(?proto, ?inputs, ?output)) {\n             llfty = type_of_fn(ccx, proto, inputs, output,\n                                _vec.len[ast.ty_param](ty_params));\n@@ -6485,7 +6501,7 @@ fn native_fn_ty_param_count(@crate_ctxt cx, &ast.def_id id) -> uint {\n \n fn native_fn_wrapper_type(@crate_ctxt cx, uint ty_param_count, ty.t x)\n         -> TypeRef {\n-    alt (ty.struct(x)) {\n+    alt (ty.struct(cx.tystore, x)) {\n         case (ty.ty_native_fn(?abi, ?args, ?out)) {\n             ret type_of_fn(cx, ast.proto_fn, args, out, ty_param_count);\n         }\n@@ -6522,9 +6538,10 @@ fn decl_native_fn_and_pair(@crate_ctxt ccx,\n     auto item = ccx.native_items.get(id);\n     auto fn_type = node_ann_type(ccx, ann);  // NB: has no type params\n \n-    auto abi = ty.ty_fn_abi(fn_type);\n-    auto llfnty = type_of_native_fn(ccx, abi, ty.ty_fn_args(fn_type),\n-                                    ty.ty_fn_ret(fn_type), num_ty_param);\n+    auto abi = ty.ty_fn_abi(ccx.tystore, fn_type);\n+    auto llfnty = type_of_native_fn(ccx, abi,\n+        ty.ty_fn_args(ccx.tystore, fn_type),\n+        ty.ty_fn_ret(ccx.tystore, fn_type), num_ty_param);\n \n     let vec[ValueRef] call_args = vec();\n     auto arg_n = 3u;\n@@ -6555,7 +6572,7 @@ fn decl_native_fn_and_pair(@crate_ctxt ccx,\n                 &mutable vec[ValueRef] args,\n                 ValueRef v,\n                 ty.t t) {\n-        if (ty.type_is_integral(t)) {\n+        if (ty.type_is_integral(cx.fcx.lcx.ccx.tystore, t)) {\n             auto lldsttype = T_int();\n             auto llsrctype = type_of(cx.fcx.lcx.ccx, t);\n             if (llvm.LLVMGetIntTypeWidth(lldsttype) >\n@@ -6564,7 +6581,7 @@ fn decl_native_fn_and_pair(@crate_ctxt ccx,\n             } else {\n                 args += vec(cx.build.TruncOrBitCast(v, T_int()));\n             }\n-        } else if (ty.type_is_fp(t)) {\n+        } else if (ty.type_is_fp(cx.fcx.lcx.ccx.tystore, t)) {\n             args += vec(cx.build.FPToSI(v, T_int()));\n         } else {\n             args += vec(vp2i(cx, v));\n@@ -6573,7 +6590,7 @@ fn decl_native_fn_and_pair(@crate_ctxt ccx,\n \n     auto r;\n     auto rptr;\n-    auto args = ty.ty_fn_args(fn_type);\n+    auto args = ty.ty_fn_args(ccx.tystore, fn_type);\n     if (abi == ast.native_abi_llvm) {\n         let vec[ValueRef] call_args = vec();\n         let vec[TypeRef] call_arg_tys = vec();\n@@ -6585,7 +6602,8 @@ fn decl_native_fn_and_pair(@crate_ctxt ccx,\n             i += 1u;\n         }\n         auto llnativefnty = T_fn(call_arg_tys,\n-                                 type_of(ccx, ty.ty_fn_ret(fn_type)));\n+                                 type_of(ccx,\n+                                         ty.ty_fn_ret(ccx.tystore, fn_type)));\n         auto llnativefn = get_extern_fn(ccx.externs, ccx.llmod, name,\n                                         lib.llvm.LLVMCCallConv, llnativefnty);\n         r = bcx.build.Call(llnativefn, call_args);"}, {"sha": "86a0db1f7bc815a080c1debe1a31aebfca066d82", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 151, "deletions": 147, "changes": 298, "blob_url": "https://github.com/rust-lang/rust/blob/e0eccaddb2bad87993505fffc523a47b68018e64/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0eccaddb2bad87993505fffc523a47b68018e64/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=e0eccaddb2bad87993505fffc523a47b68018e64", "patch": "@@ -215,10 +215,10 @@ fn mk_native(@type_store ts) -> t        { ret gen_ty(ts, ty_native); }\n \n \n // Returns the one-level-deep type structure of the given type.\n-fn struct(t typ) -> sty { ret typ.struct; }\n+fn struct(@type_store tystore, t typ) -> sty { ret typ.struct; }\n \n // Returns the canonical name of the given type.\n-fn cname(t typ) -> option.t[str] { ret typ.cname; }\n+fn cname(@type_store tystore, t typ) -> option.t[str] { ret typ.cname; }\n \n \n // Stringification\n@@ -234,23 +234,25 @@ fn path_to_str(&ast.path pth) -> str {\n     ret result;\n }\n \n-fn ty_to_str(&t typ) -> str {\n+fn ty_to_str(@type_store ts, &t typ) -> str {\n \n-    fn fn_input_to_str(&rec(ast.mode mode, t ty) input) -> str {\n+    fn fn_input_to_str(@type_store tystore,\n+                       &rec(ast.mode mode, t ty) input) -> str {\n         auto s;\n         if (mode_is_alias(input.mode)) {\n             s = \"&\";\n         } else {\n             s = \"\";\n         }\n \n-        ret s + ty_to_str(input.ty);\n+        ret s + ty_to_str(tystore, input.ty);\n     }\n \n-    fn fn_to_str(ast.proto proto,\n+    fn fn_to_str(@type_store tystore,\n+                 ast.proto proto,\n                  option.t[ast.ident] ident,\n                  vec[arg] inputs, t output) -> str {\n-            auto f = fn_input_to_str;\n+            auto f = bind fn_input_to_str(tystore, _);\n \n             auto s;\n             alt (proto) {\n@@ -274,57 +276,57 @@ fn ty_to_str(&t typ) -> str {\n             s += _str.connect(_vec.map[arg,str](f, inputs), \", \");\n             s += \")\";\n \n-            if (struct(output) != ty_nil) {\n-                s += \" -> \" + ty_to_str(output);\n+            if (struct(tystore, output) != ty_nil) {\n+                s += \" -> \" + ty_to_str(tystore, output);\n             }\n             ret s;\n     }\n \n-    fn method_to_str(&method m) -> str {\n-        ret fn_to_str(m.proto, some[ast.ident](m.ident),\n+    fn method_to_str(@type_store tystore, &method m) -> str {\n+        ret fn_to_str(tystore, m.proto, some[ast.ident](m.ident),\n                       m.inputs, m.output) + \";\";\n     }\n \n-    fn field_to_str(&field f) -> str {\n-        ret mt_to_str(f.mt) + \" \" + f.ident;\n+    fn field_to_str(@type_store tystore, &field f) -> str {\n+        ret mt_to_str(tystore, f.mt) + \" \" + f.ident;\n     }\n \n-    fn mt_to_str(&mt m) -> str {\n+    fn mt_to_str(@type_store tystore, &mt m) -> str {\n         auto mstr;\n         alt (m.mut) {\n             case (ast.mut)       { mstr = \"mutable \"; }\n             case (ast.imm)       { mstr = \"\";         }\n             case (ast.maybe_mut) { mstr = \"mutable? \"; }\n         }\n \n-        ret mstr + ty_to_str(m.ty);\n+        ret mstr + ty_to_str(tystore, m.ty);\n     }\n \n     auto s = \"\";\n-    alt (struct(typ)) {\n-        case (ty_native)       { s += \"native\";                     }\n-        case (ty_nil)          { s += \"()\";                         }\n-        case (ty_bool)         { s += \"bool\";                       }\n-        case (ty_int)          { s += \"int\";                        }\n-        case (ty_float)        { s += \"float\";                      }\n-        case (ty_uint)         { s += \"uint\";                       }\n-        case (ty_machine(?tm)) { s += common.ty_mach_to_str(tm);    }\n-        case (ty_char)         { s += \"char\";                       }\n-        case (ty_str)          { s += \"str\";                        }\n-        case (ty_box(?tm))     { s += \"@\" + mt_to_str(tm);          }\n-        case (ty_vec(?tm))     { s += \"vec[\" + mt_to_str(tm) + \"]\"; }\n-        case (ty_port(?t))     { s += \"port[\" + ty_to_str(t) + \"]\"; }\n-        case (ty_chan(?t))     { s += \"chan[\" + ty_to_str(t) + \"]\"; }\n-        case (ty_type)         { s += \"type\";                       }\n+    alt (struct(ts, typ)) {\n+        case (ty_native)       { s += \"native\";                         }\n+        case (ty_nil)          { s += \"()\";                             }\n+        case (ty_bool)         { s += \"bool\";                           }\n+        case (ty_int)          { s += \"int\";                            }\n+        case (ty_float)        { s += \"float\";                          }\n+        case (ty_uint)         { s += \"uint\";                           }\n+        case (ty_machine(?tm)) { s += common.ty_mach_to_str(tm);        }\n+        case (ty_char)         { s += \"char\";                           }\n+        case (ty_str)          { s += \"str\";                            }\n+        case (ty_box(?tm))     { s += \"@\" + mt_to_str(ts, tm);          }\n+        case (ty_vec(?tm))     { s += \"vec[\" + mt_to_str(ts, tm) + \"]\"; }\n+        case (ty_port(?t))     { s += \"port[\" + ty_to_str(ts, t) + \"]\"; }\n+        case (ty_chan(?t))     { s += \"chan[\" + ty_to_str(ts, t) + \"]\"; }\n+        case (ty_type)         { s += \"type\";                           }\n \n         case (ty_tup(?elems)) {\n-            auto f = mt_to_str;\n+            auto f = bind mt_to_str(ts, _);\n             auto strs = _vec.map[mt,str](f, elems);\n             s += \"tup(\" + _str.connect(strs, \",\") + \")\";\n         }\n \n         case (ty_rec(?elems)) {\n-            auto f = field_to_str;\n+            auto f = bind field_to_str(ts, _);\n             auto strs = _vec.map[field,str](f, elems);\n             s += \"rec(\" + _str.connect(strs, \",\") + \")\";\n         }\n@@ -334,27 +336,27 @@ fn ty_to_str(&t typ) -> str {\n             s += \"<tag#\" + util.common.istr(id._0) + \":\" +\n                 util.common.istr(id._1) + \">\";\n             if (_vec.len[t](tps) > 0u) {\n-                auto f = ty_to_str;\n+                auto f = bind ty_to_str(ts, _);\n                 auto strs = _vec.map[t,str](f, tps);\n                 s += \"[\" + _str.connect(strs, \",\") + \"]\";\n             }\n         }\n \n         case (ty_fn(?proto, ?inputs, ?output)) {\n-            s += fn_to_str(proto, none[ast.ident], inputs, output);\n+            s += fn_to_str(ts, proto, none[ast.ident], inputs, output);\n         }\n \n         case (ty_native_fn(_, ?inputs, ?output)) {\n-            s += fn_to_str(ast.proto_fn, none[ast.ident], inputs, output);\n+            s += fn_to_str(ts, ast.proto_fn, none[ast.ident], inputs, output);\n         }\n \n         case (ty_obj(?meths)) {\n-            alt (cname(typ)) {\n+            alt (cname(ts, typ)) {\n                 case (some[str](?cs)) {\n                     s += cs;\n                 }\n                 case (_) {\n-                    auto f = method_to_str;\n+                    auto f = bind method_to_str(ts, _);\n                     auto m = _vec.map[method,str](f, meths);\n                     s += \"obj {\\n\\t\" + _str.connect(m, \"\\n\\t\") + \"\\n}\";\n                 }\n@@ -386,8 +388,8 @@ fn ty_to_str(&t typ) -> str {\n \n type ty_walk = fn(t);\n \n-fn walk_ty(ty_walk walker, t ty) {\n-    alt (struct(ty)) {\n+fn walk_ty(@type_store tystore, ty_walk walker, t ty) {\n+    alt (struct(tystore, ty)) {\n         case (ty_nil)           { /* no-op */ }\n         case (ty_bool)          { /* no-op */ }\n         case (ty_int)           { /* no-op */ }\n@@ -398,44 +400,44 @@ fn walk_ty(ty_walk walker, t ty) {\n         case (ty_str)           { /* no-op */ }\n         case (ty_type)          { /* no-op */ }\n         case (ty_native)        { /* no-op */ }\n-        case (ty_box(?tm))      { walk_ty(walker, tm.ty); }\n-        case (ty_vec(?tm))      { walk_ty(walker, tm.ty); }\n-        case (ty_port(?subty))  { walk_ty(walker, subty); }\n-        case (ty_chan(?subty))  { walk_ty(walker, subty); }\n+        case (ty_box(?tm))      { walk_ty(tystore, walker, tm.ty); }\n+        case (ty_vec(?tm))      { walk_ty(tystore, walker, tm.ty); }\n+        case (ty_port(?subty))  { walk_ty(tystore, walker, subty); }\n+        case (ty_chan(?subty))  { walk_ty(tystore, walker, subty); }\n         case (ty_tag(?tid, ?subtys)) {\n             for (t subty in subtys) {\n-                walk_ty(walker, subty);\n+                walk_ty(tystore, walker, subty);\n             }\n         }\n         case (ty_tup(?mts)) {\n             for (mt tm in mts) {\n-                walk_ty(walker, tm.ty);\n+                walk_ty(tystore, walker, tm.ty);\n             }\n         }\n         case (ty_rec(?fields)) {\n             for (field fl in fields) {\n-                walk_ty(walker, fl.mt.ty);\n+                walk_ty(tystore, walker, fl.mt.ty);\n             }\n         }\n         case (ty_fn(?proto, ?args, ?ret_ty)) {\n             for (arg a in args) {\n-                walk_ty(walker, a.ty);\n+                walk_ty(tystore, walker, a.ty);\n             }\n-            walk_ty(walker, ret_ty);\n+            walk_ty(tystore, walker, ret_ty);\n         }\n         case (ty_native_fn(?abi, ?args, ?ret_ty)) {\n             for (arg a in args) {\n-                walk_ty(walker, a.ty);\n+                walk_ty(tystore, walker, a.ty);\n             }\n-            walk_ty(walker, ret_ty);\n+            walk_ty(tystore, walker, ret_ty);\n         }\n         case (ty_obj(?methods)) {\n             let vec[method] new_methods = vec();\n             for (method m in methods) {\n                 for (arg a in m.inputs) {\n-                    walk_ty(walker, a.ty);\n+                    walk_ty(tystore, walker, a.ty);\n                 }\n-                walk_ty(walker, m.output);\n+                walk_ty(tystore, walker, m.output);\n             }\n         }\n         case (ty_var(_))         { /* no-op */ }\n@@ -451,7 +453,7 @@ type ty_fold = fn(t) -> t;\n \n fn fold_ty(@type_store tystore, ty_fold fld, t ty_0) -> t {\n     auto ty = ty_0;\n-    alt (struct(ty)) {\n+    alt (struct(tystore, ty)) {\n         case (ty_nil)           { /* no-op */ }\n         case (ty_bool)          { /* no-op */ }\n         case (ty_int)           { /* no-op */ }\n@@ -552,13 +554,13 @@ fn fold_ty(@type_store tystore, ty_fold fld, t ty_0) -> t {\n // Type utilities\n \n fn rename(@type_store tystore, t typ, str new_cname) -> t {\n-    ret gen_ty_full(tystore, struct(typ), some[str](new_cname));\n+    ret gen_ty_full(tystore, struct(tystore, typ), some[str](new_cname));\n }\n \n // Returns a type with the structural part taken from `struct_ty` and the\n // canonical name from `cname_ty`.\n fn copy_cname(@type_store tystore, t struct_ty, t cname_ty) -> t {\n-    ret gen_ty_full(tystore, struct(struct_ty), cname_ty.cname);\n+    ret gen_ty_full(tystore, struct(tystore, struct_ty), cname_ty.cname);\n }\n \n // FIXME: remove me when == works on these tags.\n@@ -570,24 +572,24 @@ fn mode_is_alias(ast.mode m) -> bool {\n     fail;\n }\n \n-fn type_is_nil(t ty) -> bool {\n-    alt (struct(ty)) {\n+fn type_is_nil(@type_store tystore, t ty) -> bool {\n+    alt (struct(tystore, ty)) {\n         case (ty_nil) { ret true; }\n         case (_) { ret false; }\n     }\n     fail;\n }\n \n-fn type_is_bool(t ty) -> bool {\n-    alt (struct(ty)) {\n+fn type_is_bool(@type_store tystore, t ty) -> bool {\n+    alt (struct(tystore, ty)) {\n         case (ty_bool) { ret true; }\n         case (_) { ret false; }\n     }\n }\n \n \n-fn type_is_structural(t ty) -> bool {\n-    alt (struct(ty)) {\n+fn type_is_structural(@type_store tystore, t ty) -> bool {\n+    alt (struct(tystore, ty)) {\n         case (ty_tup(_))    { ret true; }\n         case (ty_rec(_))    { ret true; }\n         case (ty_tag(_,_))  { ret true; }\n@@ -598,8 +600,8 @@ fn type_is_structural(t ty) -> bool {\n     fail;\n }\n \n-fn type_is_sequence(t ty) -> bool {\n-    alt (struct(ty)) {\n+fn type_is_sequence(@type_store tystore, t ty) -> bool {\n+    alt (struct(tystore, ty)) {\n         case (ty_str)    { ret true; }\n         case (ty_vec(_))    { ret true; }\n         case (_)            { ret false; }\n@@ -608,16 +610,16 @@ fn type_is_sequence(t ty) -> bool {\n }\n \n fn sequence_element_type(@type_store tystore, t ty) -> t {\n-    alt (struct(ty)) {\n+    alt (struct(tystore, ty)) {\n         case (ty_str)      { ret mk_mach(tystore, common.ty_u8); }\n         case (ty_vec(?mt)) { ret mt.ty; }\n     }\n     fail;\n }\n \n \n-fn type_is_tup_like(t ty) -> bool {\n-    alt (struct(ty)) {\n+fn type_is_tup_like(@type_store tystore, t ty) -> bool {\n+    alt (struct(tystore, ty)) {\n         case (ty_box(_))    { ret true; }\n         case (ty_tup(_))    { ret true; }\n         case (ty_rec(_))    { ret true; }\n@@ -627,9 +629,9 @@ fn type_is_tup_like(t ty) -> bool {\n     fail;\n }\n \n-fn get_element_type(t ty, uint i) -> t {\n-    check (type_is_tup_like(ty));\n-    alt (struct(ty)) {\n+fn get_element_type(@type_store tystore, t ty, uint i) -> t {\n+    check (type_is_tup_like(tystore, ty));\n+    alt (struct(tystore, ty)) {\n         case (ty_tup(?mts)) {\n             ret mts.(i).ty;\n         }\n@@ -640,16 +642,16 @@ fn get_element_type(t ty, uint i) -> t {\n     fail;\n }\n \n-fn type_is_box(t ty) -> bool {\n-    alt (struct(ty)) {\n+fn type_is_box(@type_store tystore, t ty) -> bool {\n+    alt (struct(tystore, ty)) {\n         case (ty_box(_)) { ret true; }\n         case (_) { ret false; }\n     }\n     fail;\n }\n \n-fn type_is_boxed(t ty) -> bool {\n-    alt (struct(ty)) {\n+fn type_is_boxed(@type_store tystore, t ty) -> bool {\n+    alt (struct(tystore, ty)) {\n         case (ty_str) { ret true; }\n         case (ty_vec(_)) { ret true; }\n         case (ty_box(_)) { ret true; }\n@@ -660,8 +662,8 @@ fn type_is_boxed(t ty) -> bool {\n     fail;\n }\n \n-fn type_is_scalar(t ty) -> bool {\n-    alt (struct(ty)) {\n+fn type_is_scalar(@type_store tystore, t ty) -> bool {\n+    alt (struct(tystore, ty)) {\n         case (ty_nil) { ret true; }\n         case (ty_bool) { ret true; }\n         case (ty_int) { ret true; }\n@@ -678,34 +680,36 @@ fn type_is_scalar(t ty) -> bool {\n \n // FIXME: should we just return true for native types in\n // type_is_scalar?\n-fn type_is_native(t ty) -> bool {\n-    alt (struct(ty)) {\n+fn type_is_native(@type_store tystore, t ty) -> bool {\n+    alt (struct(tystore, ty)) {\n         case (ty_native) { ret true; }\n         case (_) { ret false; }\n     }\n     fail;\n }\n \n-fn type_has_dynamic_size(t ty) -> bool {\n-    alt (struct(ty)) {\n+fn type_has_dynamic_size(@type_store tystore, t ty) -> bool {\n+    alt (struct(tystore, ty)) {\n         case (ty_tup(?mts)) {\n             auto i = 0u;\n             while (i < _vec.len[mt](mts)) {\n-                if (type_has_dynamic_size(mts.(i).ty)) { ret true; }\n+                if (type_has_dynamic_size(tystore, mts.(i).ty)) { ret true; }\n                 i += 1u;\n             }\n         }\n         case (ty_rec(?fields)) {\n             auto i = 0u;\n             while (i < _vec.len[field](fields)) {\n-                if (type_has_dynamic_size(fields.(i).mt.ty)) { ret true; }\n+                if (type_has_dynamic_size(tystore, fields.(i).mt.ty)) {\n+                    ret true;\n+                }\n                 i += 1u;\n             }\n         }\n         case (ty_tag(_, ?subtys)) {\n             auto i = 0u;\n             while (i < _vec.len[t](subtys)) {\n-                if (type_has_dynamic_size(subtys.(i))) { ret true; }\n+                if (type_has_dynamic_size(tystore, subtys.(i))) { ret true; }\n                 i += 1u;\n             }\n         }\n@@ -715,8 +719,8 @@ fn type_has_dynamic_size(t ty) -> bool {\n     ret false;\n }\n \n-fn type_is_integral(t ty) -> bool {\n-    alt (struct(ty)) {\n+fn type_is_integral(@type_store tystore, t ty) -> bool {\n+    alt (struct(tystore, ty)) {\n         case (ty_int) { ret true; }\n         case (ty_uint) { ret true; }\n         case (ty_machine(?m)) {\n@@ -739,8 +743,8 @@ fn type_is_integral(t ty) -> bool {\n     fail;\n }\n \n-fn type_is_fp(t ty) -> bool {\n-    alt (struct(ty)) {\n+fn type_is_fp(@type_store tystore, t ty) -> bool {\n+    alt (struct(tystore, ty)) {\n         case (ty_machine(?tm)) {\n             alt (tm) {\n                 case (common.ty_f32) { ret true; }\n@@ -756,8 +760,8 @@ fn type_is_fp(t ty) -> bool {\n     fail;\n }\n \n-fn type_is_signed(t ty) -> bool {\n-    alt (struct(ty)) {\n+fn type_is_signed(@type_store tystore, t ty) -> bool {\n+    alt (struct(tystore, ty)) {\n         case (ty_int) { ret true; }\n         case (ty_machine(?tm)) {\n             alt (tm) {\n@@ -773,8 +777,8 @@ fn type_is_signed(t ty) -> bool {\n     fail;\n }\n \n-fn type_param(t ty) -> option.t[uint] {\n-    alt (struct(ty)) {\n+fn type_param(@type_store tystore, t ty) -> option.t[uint] {\n+    alt (struct(tystore, ty)) {\n         case (ty_param(?id)) { ret some[uint](id); }\n         case (_)             { /* fall through */  }\n     }\n@@ -1217,15 +1221,15 @@ fn eq_ty_full(&t a, &t b) -> bool {\n     }\n \n     // Check canonical names.\n-    alt (cname(a)) {\n+    alt (a.cname) {\n         case (none[str]) {\n-            alt (cname(b)) {\n+            alt (b.cname) {\n                 case (none[str]) { /* ok */ }\n                 case (_) { ret false; }\n             }\n         }\n         case (some[str](?s_a)) {\n-            alt (cname(b)) {\n+            alt (b.cname) {\n                 case (some[str](?s_b)) {\n                     if (!_str.eq(s_a, s_b)) { ret false; }\n                 }\n@@ -1235,7 +1239,7 @@ fn eq_ty_full(&t a, &t b) -> bool {\n     }\n \n     // Check structures.\n-    ret equal_type_structures(struct(a), struct(b));\n+    ret equal_type_structures(a.struct, b.struct);\n }\n \n // This is the equality function the public should use. It works as long as\n@@ -1300,9 +1304,9 @@ fn triv_ann(t typ) -> ast.ann {\n }\n \n // Returns the number of distinct type parameters in the given type.\n-fn count_ty_params(t ty) -> uint {\n-    fn counter(@mutable vec[uint] param_indices, t ty) {\n-        alt (struct(ty)) {\n+fn count_ty_params(@type_store tystore, t ty) -> uint {\n+    fn counter(@type_store tystore, @mutable vec[uint] param_indices, t ty) {\n+        alt (struct(tystore, ty)) {\n             case (ty_param(?param_idx)) {\n                 auto seen = false;\n                 for (uint other_param_idx in *param_indices) {\n@@ -1320,59 +1324,59 @@ fn count_ty_params(t ty) -> uint {\n \n     let vec[uint] v = vec();    // FIXME: typechecker botch\n     let @mutable vec[uint] param_indices = @mutable v;\n-    auto f = bind counter(param_indices, _);\n-    walk_ty(f, ty);\n+    auto f = bind counter(tystore, param_indices, _);\n+    walk_ty(tystore, f, ty);\n     ret _vec.len[uint](*param_indices);\n }\n \n-fn type_contains_vars(t typ) -> bool {\n-    fn checker(@mutable bool flag, t typ) {\n-        alt (struct(typ)) {\n+fn type_contains_vars(@type_store tystore, t typ) -> bool {\n+    fn checker(@type_store tystore, @mutable bool flag, t typ) {\n+        alt (struct(tystore, typ)) {\n             case (ty_var(_)) { *flag = true; }\n             case (_) { /* fall through */ }\n         }\n     }\n \n     let @mutable bool flag = @mutable false;\n-    auto f = bind checker(flag, _);\n-    walk_ty(f, typ);\n+    auto f = bind checker(tystore, flag, _);\n+    walk_ty(tystore, f, typ);\n     ret *flag;\n }\n \n // Type accessors for substructures of types\n \n-fn ty_fn_args(t fty) -> vec[arg] {\n-    alt (struct(fty)) {\n+fn ty_fn_args(@type_store tystore, t fty) -> vec[arg] {\n+    alt (struct(tystore, fty)) {\n         case (ty.ty_fn(_, ?a, _)) { ret a; }\n         case (ty.ty_native_fn(_, ?a, _)) { ret a; }\n     }\n     fail;\n }\n \n-fn ty_fn_proto(t fty) -> ast.proto {\n-    alt (struct(fty)) {\n+fn ty_fn_proto(@type_store tystore, t fty) -> ast.proto {\n+    alt (struct(tystore, fty)) {\n         case (ty.ty_fn(?p, _, _)) { ret p; }\n     }\n     fail;\n }\n \n-fn ty_fn_abi(t fty) -> ast.native_abi {\n-    alt (struct(fty)) {\n+fn ty_fn_abi(@type_store tystore, t fty) -> ast.native_abi {\n+    alt (struct(tystore, fty)) {\n         case (ty.ty_native_fn(?a, _, _)) { ret a; }\n     }\n     fail;\n }\n \n-fn ty_fn_ret(t fty) -> t {\n-    alt (struct(fty)) {\n+fn ty_fn_ret(@type_store tystore, t fty) -> t {\n+    alt (struct(tystore, fty)) {\n         case (ty.ty_fn(_, _, ?r)) { ret r; }\n         case (ty.ty_native_fn(_, _, ?r)) { ret r; }\n     }\n     fail;\n }\n \n-fn is_fn_ty(t fty) -> bool {\n-    alt (struct(fty)) {\n+fn is_fn_ty(@type_store tystore, t fty) -> bool {\n+    alt (struct(tystore, fty)) {\n         case (ty.ty_fn(_, _, _)) { ret true; }\n         case (ty.ty_native_fn(_, _, _)) { ret true; }\n         case (_) { ret false; }\n@@ -1684,8 +1688,8 @@ mod Unify {\n     // something we'll probably need to develop over time.\n \n     // Simple structural type comparison.\n-    fn struct_cmp(t expected, t actual) -> result {\n-        if (struct(expected) == struct(actual)) {\n+    fn struct_cmp(@ctxt cx, t expected, t actual) -> result {\n+        if (struct(cx.tystore, expected) == struct(cx.tystore, actual)) {\n             ret ures_ok(expected);\n         }\n \n@@ -1850,7 +1854,7 @@ mod Unify {\n                           a_meth.inputs, a_meth.output);\n         alt (r) {\n             case (ures_ok(?tfn)) {\n-                alt (struct(tfn)) {\n+                alt (struct(cx.tystore, tfn)) {\n                     case (ty_fn(?proto, ?ins, ?out)) {\n                         result_meths += vec(rec(inputs = ins,\n                                                 output = out\n@@ -1890,12 +1894,12 @@ mod Unify {\n         // Fast path.\n         if (eq_ty(expected, actual)) { ret ures_ok(expected); }\n \n-        alt (struct(actual)) {\n+        alt (struct(cx.tystore, actual)) {\n             // If the RHS is a variable type, then just do the appropriate\n             // binding.\n             case (ty.ty_var(?actual_id)) {\n                 auto actual_n = get_or_create_set(cx, actual_id);\n-                alt (struct(expected)) {\n+                alt (struct(cx.tystore, expected)) {\n                     case (ty.ty_var(?expected_id)) {\n                         auto expected_n = get_or_create_set(cx, expected_id);\n                         UFind.union(cx.sets, expected_n, actual_n);\n@@ -1931,7 +1935,7 @@ mod Unify {\n                 ret ures_ok(result_ty);\n             }\n             case (ty.ty_bound_param(?actual_id)) {\n-                alt (struct(expected)) {\n+                alt (struct(cx.tystore, expected)) {\n                     case (ty.ty_local(_)) {\n                         log_err \"TODO: bound param unifying with local\";\n                         fail;\n@@ -1945,21 +1949,21 @@ mod Unify {\n             case (_) { /* empty */ }\n         }\n \n-        alt (struct(expected)) {\n-            case (ty.ty_nil)        { ret struct_cmp(expected, actual); }\n-            case (ty.ty_bool)       { ret struct_cmp(expected, actual); }\n-            case (ty.ty_int)        { ret struct_cmp(expected, actual); }\n-            case (ty.ty_uint)       { ret struct_cmp(expected, actual); }\n-            case (ty.ty_machine(_)) { ret struct_cmp(expected, actual); }\n-            case (ty.ty_float)      { ret struct_cmp(expected, actual); }\n-            case (ty.ty_char)       { ret struct_cmp(expected, actual); }\n-            case (ty.ty_str)        { ret struct_cmp(expected, actual); }\n-            case (ty.ty_type)       { ret struct_cmp(expected, actual); }\n-            case (ty.ty_native)     { ret struct_cmp(expected, actual); }\n-            case (ty.ty_param(_))   { ret struct_cmp(expected, actual); }\n+        alt (struct(cx.tystore, expected)) {\n+            case (ty.ty_nil)        { ret struct_cmp(cx, expected, actual); }\n+            case (ty.ty_bool)       { ret struct_cmp(cx, expected, actual); }\n+            case (ty.ty_int)        { ret struct_cmp(cx, expected, actual); }\n+            case (ty.ty_uint)       { ret struct_cmp(cx, expected, actual); }\n+            case (ty.ty_machine(_)) { ret struct_cmp(cx, expected, actual); }\n+            case (ty.ty_float)      { ret struct_cmp(cx, expected, actual); }\n+            case (ty.ty_char)       { ret struct_cmp(cx, expected, actual); }\n+            case (ty.ty_str)        { ret struct_cmp(cx, expected, actual); }\n+            case (ty.ty_type)       { ret struct_cmp(cx, expected, actual); }\n+            case (ty.ty_native)     { ret struct_cmp(cx, expected, actual); }\n+            case (ty.ty_param(_))   { ret struct_cmp(cx, expected, actual); }\n \n             case (ty.ty_tag(?expected_id, ?expected_tps)) {\n-                alt (struct(actual)) {\n+                alt (struct(cx.tystore, actual)) {\n                     case (ty.ty_tag(?actual_id, ?actual_tps)) {\n                         if (expected_id._0 != actual_id._0 ||\n                                 expected_id._1 != actual_id._1) {\n@@ -2001,7 +2005,7 @@ mod Unify {\n             }\n \n             case (ty.ty_box(?expected_mt)) {\n-                alt (struct(actual)) {\n+                alt (struct(cx.tystore, actual)) {\n                     case (ty.ty_box(?actual_mt)) {\n                         auto mut;\n                         alt (unify_mut(expected_mt.mut, actual_mt.mut)) {\n@@ -2033,7 +2037,7 @@ mod Unify {\n             }\n \n             case (ty.ty_vec(?expected_mt)) {\n-                alt (struct(actual)) {\n+                alt (struct(cx.tystore, actual)) {\n                     case (ty.ty_vec(?actual_mt)) {\n                         auto mut;\n                         alt (unify_mut(expected_mt.mut, actual_mt.mut)) {\n@@ -2065,7 +2069,7 @@ mod Unify {\n             }\n \n             case (ty.ty_port(?expected_sub)) {\n-                alt (struct(actual)) {\n+                alt (struct(cx.tystore, actual)) {\n                     case (ty.ty_port(?actual_sub)) {\n                         auto result = unify_step(cx,\n                                                  expected_sub,\n@@ -2087,7 +2091,7 @@ mod Unify {\n             }\n \n             case (ty.ty_chan(?expected_sub)) {\n-                alt (struct(actual)) {\n+                alt (struct(cx.tystore, actual)) {\n                     case (ty.ty_chan(?actual_sub)) {\n                         auto result = unify_step(cx,\n                                                  expected_sub,\n@@ -2109,7 +2113,7 @@ mod Unify {\n             }\n \n             case (ty.ty_tup(?expected_elems)) {\n-                alt (struct(actual)) {\n+                alt (struct(cx.tystore, actual)) {\n                     case (ty.ty_tup(?actual_elems)) {\n                         auto expected_len = _vec.len[ty.mt](expected_elems);\n                         auto actual_len = _vec.len[ty.mt](actual_elems);\n@@ -2163,7 +2167,7 @@ mod Unify {\n             }\n \n             case (ty.ty_rec(?expected_fields)) {\n-                alt (struct(actual)) {\n+                alt (struct(cx.tystore, actual)) {\n                     case (ty.ty_rec(?actual_fields)) {\n                         auto expected_len = _vec.len[field](expected_fields);\n                         auto actual_len = _vec.len[field](actual_fields);\n@@ -2227,7 +2231,7 @@ mod Unify {\n             }\n \n             case (ty.ty_fn(?ep, ?expected_inputs, ?expected_output)) {\n-                alt (struct(actual)) {\n+                alt (struct(cx.tystore, actual)) {\n                     case (ty.ty_fn(?ap, ?actual_inputs, ?actual_output)) {\n                         ret unify_fn(cx, ep, ap,\n                                      expected, actual,\n@@ -2243,7 +2247,7 @@ mod Unify {\n \n             case (ty.ty_native_fn(?e_abi, ?expected_inputs,\n                                   ?expected_output)) {\n-                alt (struct(actual)) {\n+                alt (struct(cx.tystore, actual)) {\n                     case (ty.ty_native_fn(?a_abi, ?actual_inputs,\n                                           ?actual_output)) {\n                         ret unify_native_fn(cx, e_abi, a_abi,\n@@ -2258,7 +2262,7 @@ mod Unify {\n             }\n \n             case (ty.ty_obj(?expected_meths)) {\n-                alt (struct(actual)) {\n+                alt (struct(cx.tystore, actual)) {\n                     case (ty.ty_obj(?actual_meths)) {\n                         ret unify_obj(cx, expected, actual,\n                                       expected_meths, actual_meths);\n@@ -2311,7 +2315,7 @@ mod Unify {\n     // Performs type binding substitution.\n     fn substitute(@ctxt cx, vec[t] set_types, t typ) -> t {\n         fn substituter(@ctxt cx, vec[t] types, t typ) -> t {\n-            alt (struct(typ)) {\n+            alt (struct(cx.tystore, typ)) {\n                 case (ty_var(?id)) {\n                     alt (cx.var_ids.find(id)) {\n                         case (some[uint](?n)) {\n@@ -2443,23 +2447,23 @@ fn type_err_to_str(&ty.type_err err) -> str {\n fn substitute_type_params(@type_store tystore,\n                           vec[t] bindings,\n                           t typ) -> t {\n-    fn replacer(vec[t] bindings, t typ) -> t {\n-        alt (struct(typ)) {\n+    fn replacer(@type_store tystore, vec[t] bindings, t typ) -> t {\n+        alt (struct(tystore, typ)) {\n             case (ty_bound_param(?param_index)) {\n                 ret bindings.(param_index);\n             }\n             case (_) { ret typ; }\n         }\n     }\n \n-    auto f = bind replacer(bindings, _);\n+    auto f = bind replacer(tystore, bindings, _);\n     ret fold_ty(tystore, f, typ);\n }\n \n // Converts type parameters in a type to bound type parameters.\n fn bind_params_in_type(@type_store tystore, t typ) -> t {\n     fn binder(@type_store tystore, t typ) -> t {\n-        alt (struct(typ)) {\n+        alt (struct(tystore, typ)) {\n             case (ty_bound_param(?index)) {\n                 log_err \"bind_params_in_type() called on type that already \" +\n                     \"has bound params in it\";"}, {"sha": "f86e2c4f95c5359587859e4c8c531ce58a50893c", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 60, "deletions": 54, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/e0eccaddb2bad87993505fffc523a47b68018e64/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0eccaddb2bad87993505fffc523a47b68018e64/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=e0eccaddb2bad87993505fffc523a47b68018e64", "patch": "@@ -81,7 +81,7 @@ fn substitute_ty_params(&@crate_ctxt ccx,\n                         vec[ty.t] supplied,\n                         &span sp) -> ty.t {\n     fn substituter(@crate_ctxt ccx, vec[ty.t] supplied, ty.t typ) -> ty.t {\n-        alt (struct(typ)) {\n+        alt (struct(ccx.tystore, typ)) {\n             case (ty.ty_bound_param(?pid)) { ret supplied.(pid); }\n             case (_) { ret typ; }\n         }\n@@ -686,10 +686,10 @@ mod Collect {\n         ret @fold.respan[ast.native_item_](sp, item);\n     }\n \n-    fn get_ctor_obj_methods(ty.t t) -> vec[method] {\n-        alt (struct(t)) {\n+    fn get_ctor_obj_methods(&@env e, ty.t t) -> vec[method] {\n+        alt (struct(e.cx.tystore, t)) {\n             case (ty.ty_fn(_,_,?tobj)) {\n-                alt (struct(tobj)) {\n+                alt (struct(e.cx.tystore, tobj)) {\n                     case (ty.ty_obj(?tm)) {\n                         ret tm;\n                     }\n@@ -712,7 +712,7 @@ mod Collect {\n                     ast.obj_def_ids odid, ast.ann a) -> @ast.item {\n         check (e.cx.type_cache.contains_key(odid.ctor));\n         auto t = e.cx.type_cache.get(odid.ctor)._1;\n-        let vec[method] meth_tys = get_ctor_obj_methods(t);\n+        let vec[method] meth_tys = get_ctor_obj_methods(e, t);\n         let vec[@ast.method] methods = vec();\n         let vec[ast.obj_field] fields = vec();\n \n@@ -853,7 +853,8 @@ mod Unify {\n                 alt (fcx.locals.find(id)) {\n                     case (none[ty.t]) { ret none[ty.t]; }\n                     case (some[ty.t](?existing_type)) {\n-                        if (ty.type_contains_vars(existing_type)) {\n+                        if (ty.type_contains_vars(fcx.ccx.tystore,\n+                                                  existing_type)) {\n                             // Not fully resolved yet. The writeback phase\n                             // will mop up.\n                             ret none[ty.t];\n@@ -921,10 +922,10 @@ tag autoderef_kind {\n     NO_AUTODEREF;\n }\n \n-fn strip_boxes(ty.t t) -> ty.t {\n+fn strip_boxes(@ty.type_store tystore, ty.t t) -> ty.t {\n     auto t1 = t;\n     while (true) {\n-        alt (struct(t1)) {\n+        alt (struct(tystore, t1)) {\n             case (ty.ty_box(?inner)) { t1 = inner.ty; }\n             case (_) { ret t1; }\n         }\n@@ -942,11 +943,11 @@ fn add_boxes(@crate_ctxt ccx, uint n, ty.t t) -> ty.t {\n }\n \n \n-fn count_boxes(ty.t t) -> uint {\n+fn count_boxes(@ty.type_store tystore, ty.t t) -> uint {\n     auto n = 0u;\n     auto t1 = t;\n     while (true) {\n-        alt (struct(t1)) {\n+        alt (struct(tystore, t1)) {\n             case (ty.ty_box(?inner)) { n += 1u; t1 = inner.ty; }\n             case (_) { ret n; }\n         }\n@@ -984,9 +985,9 @@ mod Demand {\n         auto implicit_boxes = 0u;\n \n         if (adk == AUTODEREF_OK) {\n-            expected_1 = strip_boxes(expected_1);\n-            actual_1 = strip_boxes(actual_1);\n-            implicit_boxes = count_boxes(actual);\n+            expected_1 = strip_boxes(fcx.ccx.tystore, expected_1);\n+            actual_1 = strip_boxes(fcx.ccx.tystore, actual_1);\n+            implicit_boxes = count_boxes(fcx.ccx.tystore, actual);\n         }\n \n         let vec[mutable ty.t] ty_param_substs =\n@@ -1010,9 +1011,9 @@ mod Demand {\n \n             case (ures_err(?err, ?expected, ?actual)) {\n                 fcx.ccx.sess.span_err(sp, \"mismatched types: expected \"\n-                                      + ty_to_str(expected) + \" but found \"\n-                                      + ty_to_str(actual) + \" (\" +\n-                                      ty.type_err_to_str(err) + \")\");\n+                    + ty_to_str(fcx.ccx.tystore, expected) + \" but found \"\n+                    + ty_to_str(fcx.ccx.tystore, actual) + \" (\"\n+                    + ty.type_err_to_str(err) + \")\");\n \n                 // TODO: In the future, try returning \"expected\", reporting\n                 // the error, and continue.\n@@ -1040,7 +1041,7 @@ fn variant_arg_types(@crate_ctxt ccx, &span sp, ast.def_id vid,\n \n     auto tpt = ty.lookup_item_type(ccx.sess, ccx.tystore, ccx.type_cache,\n                                    vid);\n-    alt (struct(tpt._1)) {\n+    alt (struct(ccx.tystore, tpt._1)) {\n         case (ty.ty_fn(_, ?ins, _)) {\n             // N-ary variant.\n             for (ty.arg arg in ins) {\n@@ -1109,7 +1110,7 @@ mod Pushdown {\n                 // Take the variant's type parameters out of the expected\n                 // type.\n                 auto tag_tps;\n-                alt (struct(expected)) {\n+                alt (struct(fcx.ccx.tystore, expected)) {\n                     case (ty.ty_tag(_, ?tps)) { tag_tps = tps; }\n                     case (_) {\n                         log_err \"tag pattern type not actually a tag?!\";\n@@ -1159,7 +1160,7 @@ mod Pushdown {\n                 auto t = Demand.simple(fcx, e.span, expected,\n                                        ann_to_type(ann));\n                 let vec[@ast.expr] es_1 = vec();\n-                alt (struct(t)) {\n+                alt (struct(fcx.ccx.tystore, t)) {\n                     case (ty.ty_vec(?mt)) {\n                         for (@ast.expr e_0 in es_0) {\n                             es_1 += vec(pushdown_expr(fcx, mt.ty, e_0));\n@@ -1176,7 +1177,7 @@ mod Pushdown {\n                 auto t = Demand.simple(fcx, e.span, expected,\n                                        ann_to_type(ann));\n                 let vec[ast.elt] elts_1 = vec();\n-                alt (struct(t)) {\n+                alt (struct(fcx.ccx.tystore, t)) {\n                     case (ty.ty_tup(?mts)) {\n                         auto i = 0u;\n                         for (ast.elt elt_0 in es_0) {\n@@ -1200,7 +1201,7 @@ mod Pushdown {\n                 auto t = Demand.simple(fcx, e.span, expected,\n                                        ann_to_type(ann));\n                 let vec[ast.field] fields_1 = vec();\n-                alt (struct(t)) {\n+                alt (struct(fcx.ccx.tystore, t)) {\n                     case (ty.ty_rec(?field_mts)) {\n                         alt (base_0) {\n                             case (none[@ast.expr]) {\n@@ -1413,7 +1414,7 @@ mod Pushdown {\n                 auto t = Demand.simple(fcx, e.span, expected,\n                                        ann_to_type(ann));\n                 let @ast.expr es_1;\n-                alt (struct(t)) {\n+                alt (struct(fcx.ccx.tystore, t)) {\n                     case (ty.ty_chan(?subty)) {\n                         auto pt = ty.mk_port(fcx.ccx.tystore, subty);\n                         es_1 = pushdown_expr(fcx, pt, es);\n@@ -1515,7 +1516,7 @@ fn writeback_local(&option.t[@fn_ctxt] env, &span sp, @ast.local local)\n fn resolve_local_types_in_annotation(&option.t[@fn_ctxt] env, ast.ann ann)\n         -> ast.ann {\n     fn resolver(@fn_ctxt fcx, ty.t typ) -> ty.t {\n-        alt (struct(typ)) {\n+        alt (struct(fcx.ccx.tystore, typ)) {\n             case (ty.ty_local(?lid)) { ret fcx.locals.get(lid); }\n             case (_)                 { ret typ; }\n         }\n@@ -1604,7 +1605,7 @@ fn check_pat(&@fn_ctxt fcx, @ast.pat pat) -> @ast.pat {\n                                            fcx.ccx.type_cache, vdef._0);\n             auto ann = instantiate_path(fcx, p, tpt, pat.span);\n \n-            alt (struct(t)) {\n+            alt (struct(fcx.ccx.tystore, t)) {\n                 // N-ary variants have function types.\n                 case (ty.ty_fn(_, ?args, ?tag_ty)) {\n                     auto arg_len = _vec.len[arg](args);\n@@ -1692,7 +1693,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n \n         auto rt_0 = next_ty_var(fcx.ccx);\n         auto t_0;\n-        alt (struct(expr_ty(fcx.ccx.tystore, f_0))) {\n+        alt (struct(fcx.ccx.tystore, expr_ty(fcx.ccx.tystore, f_0))) {\n             case (ty.ty_fn(?proto, _, _))   {\n                 t_0 = ty.mk_fn(fcx.ccx.tystore, proto, arg_tys_0, rt_0);\n             }\n@@ -1774,7 +1775,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n                                             expr_ty(fcx.ccx.tystore, lhs_1),\n                                             rhs_0, AUTODEREF_OK);\n \n-            auto t = strip_boxes(lhs_t0);\n+            auto t = strip_boxes(fcx.ccx.tystore, lhs_t0);\n             alt (binop) {\n                 case (ast.eq) { t = ty.mk_bool(fcx.ccx.tystore); }\n                 case (ast.lt) { t = ty.mk_bool(fcx.ccx.tystore); }\n@@ -1801,19 +1802,19 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n                                        rec(ty=oper_t, mut=mut));\n                 }\n                 case (ast.deref) {\n-                    alt (struct(oper_t)) {\n+                    alt (struct(fcx.ccx.tystore, oper_t)) {\n                         case (ty.ty_box(?inner)) {\n                             oper_t = inner.ty;\n                         }\n                         case (_) {\n                             fcx.ccx.sess.span_err\n                                 (expr.span,\n                                  \"dereferencing non-box type: \"\n-                                 + ty_to_str(oper_t));\n+                                 + ty_to_str(fcx.ccx.tystore, oper_t));\n                         }\n                     }\n                 }\n-                case (_) { oper_t = strip_boxes(oper_t); }\n+                case (_) { oper_t = strip_boxes(fcx.ccx.tystore, oper_t); }\n             }\n \n             auto ann = triv_ann(oper_t);\n@@ -1971,7 +1972,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n             auto chan_t = ty.mk_chan(fcx.ccx.tystore, rhs_t);\n             auto lhs_1 = Pushdown.pushdown_expr(fcx, chan_t, lhs_0);\n             auto item_t;\n-            alt (struct(expr_ty(fcx.ccx.tystore, lhs_1))) {\n+            alt (struct(fcx.ccx.tystore, expr_ty(fcx.ccx.tystore, lhs_1))) {\n                 case (ty.ty_chan(?it)) {\n                     item_t = it;\n                 }\n@@ -1994,7 +1995,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n             auto port_t = ty.mk_port(fcx.ccx.tystore, lhs_t1);\n             auto rhs_1 = Pushdown.pushdown_expr(fcx, port_t, rhs_0);\n             auto item_t;\n-            alt (struct(expr_ty(fcx.ccx.tystore, rhs_0))) {\n+            alt (struct(fcx.ccx.tystore, expr_ty(fcx.ccx.tystore, rhs_0))) {\n                 case (ty.ty_port(?it)) {\n                     item_t = it;\n                 }\n@@ -2164,7 +2165,8 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n             auto proto_1;\n             let vec[ty.arg] arg_tys_1 = vec();\n             auto rt_1;\n-            alt (struct(expr_ty(fcx.ccx.tystore, result._0))) {\n+            alt (struct(fcx.ccx.tystore,\n+                        expr_ty(fcx.ccx.tystore, result._0))) {\n                 case (ty.ty_fn(?proto, ?arg_tys, ?rt)) {\n                     proto_1 = proto;\n                     rt_1 = rt;\n@@ -2202,7 +2204,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n \n             // Pull the return type out of the type of the function.\n             auto rt_1 = ty.mk_nil(fcx.ccx.tystore);  // FIXME: typestate botch\n-            alt (struct(expr_ty(fcx.ccx.tystore, f_1))) {\n+            alt (struct(fcx.ccx.tystore, expr_ty(fcx.ccx.tystore, f_1))) {\n                 case (ty.ty_fn(_,_,?rt))    { rt_1 = rt; }\n                 case (ty.ty_native_fn(_, _, ?rt))    { rt_1 = rt; }\n                 case (_) {\n@@ -2234,7 +2236,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n             // Grab this method's type out of the current object type\n \n             // this_obj_ty is an ty.t\n-            alt (struct(this_obj_ty)) {\n+            alt (struct(fcx.ccx.tystore, this_obj_ty)) {\n                 case (ty.ty_obj(?methods)) {\n                     for (ty.method method in methods) {\n                         if (method.ident == id) {\n@@ -2258,9 +2260,9 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n             auto args_1 = result._1;\n \n             // Check the return type\n-            alt (struct(expr_ty(fcx.ccx.tystore, f_1))) {\n+            alt (struct(fcx.ccx.tystore, expr_ty(fcx.ccx.tystore, f_1))) {\n                 case (ty.ty_fn(_,_,?rt)) {\n-                    alt (struct(rt)) {\n+                    alt (struct(fcx.ccx.tystore, rt)) {\n                         case (ty.ty_nil) {\n                             // This is acceptable\n                         }\n@@ -2286,12 +2288,14 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n             auto e_1 = check_expr(fcx, e);\n             auto t_1 = ast_ty_to_ty_crate(fcx.ccx, t);\n             // FIXME: there are more forms of cast to support, eventually.\n-            if (! (type_is_scalar(expr_ty(fcx.ccx.tystore, e_1)) &&\n-                   type_is_scalar(t_1))) {\n+            if (! (type_is_scalar(fcx.ccx.tystore,\n+                                  expr_ty(fcx.ccx.tystore, e_1)) &&\n+                   type_is_scalar(fcx.ccx.tystore, t_1))) {\n                 fcx.ccx.sess.span_err(expr.span,\n                     \"non-scalar cast: \" +\n-                    ty_to_str(expr_ty(fcx.ccx.tystore, e_1)) + \" as \" +\n-                    ty_to_str(t_1));\n+                    ty_to_str(fcx.ccx.tystore,\n+                              expr_ty(fcx.ccx.tystore, e_1)) + \" as \" +\n+                    ty_to_str(fcx.ccx.tystore, t_1));\n             }\n \n             auto ann = triv_ann(t_1);\n@@ -2374,7 +2378,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n \n                     let vec[field] base_fields = vec();\n \n-                    alt (struct(bexpr_t)) {\n+                    alt (struct(fcx.ccx.tystore, bexpr_t)) {\n                         case (ty.ty_rec(?flds)) {\n                             base_fields = flds;\n                         }\n@@ -2412,8 +2416,9 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n \n         case (ast.expr_field(?base, ?field, _)) {\n             auto base_1 = check_expr(fcx, base);\n-            auto base_t = strip_boxes(expr_ty(fcx.ccx.tystore, base_1));\n-            alt (struct(base_t)) {\n+            auto base_t = strip_boxes(fcx.ccx.tystore,\n+                                      expr_ty(fcx.ccx.tystore, base_1));\n+            alt (struct(fcx.ccx.tystore, base_t)) {\n                 case (ty.ty_tup(?args)) {\n                     let uint ix = ty.field_num(fcx.ccx.sess,\n                                                expr.span, field);\n@@ -2462,25 +2467,26 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n                 case (_) {\n                     fcx.ccx.sess.span_unimpl(expr.span,\n                         \"base type for expr_field in typeck.check_expr: \" +\n-                        ty_to_str(base_t));\n+                        ty_to_str(fcx.ccx.tystore, base_t));\n                 }\n             }\n         }\n \n         case (ast.expr_index(?base, ?idx, _)) {\n             auto base_1 = check_expr(fcx, base);\n-            auto base_t = strip_boxes(expr_ty(fcx.ccx.tystore, base_1));\n+            auto base_t = strip_boxes(fcx.ccx.tystore,\n+                                      expr_ty(fcx.ccx.tystore, base_1));\n \n             auto idx_1 = check_expr(fcx, idx);\n             auto idx_t = expr_ty(fcx.ccx.tystore, idx_1);\n \n-            alt (struct(base_t)) {\n+            alt (struct(fcx.ccx.tystore, base_t)) {\n                 case (ty.ty_vec(?mt)) {\n-                    if (! type_is_integral(idx_t)) {\n+                    if (! type_is_integral(fcx.ccx.tystore, idx_t)) {\n                         fcx.ccx.sess.span_err\n                             (idx.span,\n                              \"non-integral type of vec index: \"\n-                             + ty_to_str(idx_t));\n+                             + ty_to_str(fcx.ccx.tystore, idx_t));\n                     }\n                     auto ann = triv_ann(mt.ty);\n                     ret @fold.respan[ast.expr_](expr.span,\n@@ -2489,11 +2495,11 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n                                                                ann));\n                 }\n                 case (ty.ty_str) {\n-                    if (! type_is_integral(idx_t)) {\n+                    if (! type_is_integral(fcx.ccx.tystore, idx_t)) {\n                         fcx.ccx.sess.span_err\n                             (idx.span,\n                              \"non-integral type of str index: \"\n-                             + ty_to_str(idx_t));\n+                             + ty_to_str(fcx.ccx.tystore, idx_t));\n                     }\n                     auto ann = triv_ann(ty.mk_mach(fcx.ccx.tystore,\n                                                    common.ty_u8));\n@@ -2506,7 +2512,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n                     fcx.ccx.sess.span_err\n                         (expr.span,\n                          \"vector-indexing bad type: \"\n-                         + ty_to_str(base_t));\n+                         + ty_to_str(fcx.ccx.tystore, base_t));\n                 }\n             }\n         }\n@@ -2521,7 +2527,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n         case (ast.expr_chan(?x, _)) {\n             auto expr_1 = check_expr(fcx, x);\n             auto port_t = expr_ty(fcx.ccx.tystore, expr_1);\n-            alt (struct(port_t)) {\n+            alt (struct(fcx.ccx.tystore, port_t)) {\n                 case (ty.ty_port(?subtype)) {\n                     auto ct = ty.mk_chan(fcx.ccx.tystore, subtype);\n                     auto ann = triv_ann(ct);\n@@ -2530,8 +2536,8 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n                 }\n                 case (_) {\n                     fcx.ccx.sess.span_err(expr.span,\n-                                          \"bad port type: \"\n-                                          + ty_to_str(port_t));\n+                        \"bad port type: \" + ty_to_str(fcx.ccx.tystore,\n+                                                      port_t));\n                 }\n             }\n         }"}]}