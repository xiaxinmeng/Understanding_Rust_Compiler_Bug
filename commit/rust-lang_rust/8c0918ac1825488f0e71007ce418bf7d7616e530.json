{"sha": "8c0918ac1825488f0e71007ce418bf7d7616e530", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhjMDkxOGFjMTgyNTQ4OGYwZTcxMDA3Y2U0MThiZjdkNzYxNmU1MzA=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-09-26T20:13:08Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-09-26T20:13:08Z"}, "message": "Construct records and tuples in-place\n\nIssue #667\n\nNow, {a: {b: 10, c: 20}, d: @30} will simply write the values in the right\nplaces, rather than creating intermediary records and then memmoving them.\nCuts about a megabyte off the unoptimized compiler size.", "tree": {"sha": "088ad46694e29f3b45eaa149c968f17aca31ae97", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/088ad46694e29f3b45eaa149c968f17aca31ae97"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8c0918ac1825488f0e71007ce418bf7d7616e530", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8c0918ac1825488f0e71007ce418bf7d7616e530", "html_url": "https://github.com/rust-lang/rust/commit/8c0918ac1825488f0e71007ce418bf7d7616e530", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8c0918ac1825488f0e71007ce418bf7d7616e530/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5837975f95e8431e08ccdd9016b7c0feb0664cc0", "url": "https://api.github.com/repos/rust-lang/rust/commits/5837975f95e8431e08ccdd9016b7c0feb0664cc0", "html_url": "https://github.com/rust-lang/rust/commit/5837975f95e8431e08ccdd9016b7c0feb0664cc0"}], "stats": {"total": 111, "additions": 53, "deletions": 58}, "files": [{"sha": "85675e91577b9c54305ab7bc979e5462f8dcf12b", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 48, "deletions": 58, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/8c0918ac1825488f0e71007ce418bf7d7616e530/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c0918ac1825488f0e71007ce418bf7d7616e530/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=8c0918ac1825488f0e71007ce418bf7d7616e530", "patch": "@@ -4002,32 +4002,30 @@ fn trans_landing_pad(bcx: @block_ctxt,\n fn trans_tup(bcx: @block_ctxt, elts: [@ast::expr], id: ast::node_id,\n              dest: dest) -> @block_ctxt {\n     let t = node_id_type(bcx.fcx.lcx.ccx, id);\n-    let dst = alt dest { save_in(addr) { addr } };\n-\n-    // Like trans_rec, we'll collect the fields of the tuple then build it, so\n-    // that if we fail in between we don't have to deal with cleaning up a\n-    // partial tuple\n-    let tupfields = [], i = 0;\n+    let temp_cleanups = [], i = 0;\n     for e in elts {\n-        let e_ty = ty::expr_ty(bcx_tcx(bcx), e);\n-        let src = trans_lval(bcx, e);\n-        let dst_res = GEP_tup_like_1(src.bcx, t, dst, [0, i]);\n-        bcx = dst_res.bcx;\n-        tupfields += [(dst_res.val, src, e_ty)];\n+        alt dest {\n+          save_in(addr) {\n+            let dst = GEP_tup_like_1(bcx, t, addr, [0, i]);\n+            let e_ty = ty::expr_ty(bcx_tcx(bcx), e);\n+            bcx = trans_expr_save_in(dst.bcx, e, dst.val);\n+            add_clean_temp_mem(bcx, dst.val, e_ty);\n+            temp_cleanups += [dst.val];\n+          }\n+          ignore. {\n+            bcx = trans_expr_dps(bcx, e, ignore);\n+          }\n+        }\n         i += 1;\n     }\n-    // Fill in the tuple fields\n-    for (dst, src, t) in tupfields {\n-        bcx = move_val_if_temp(bcx, INIT, dst, src, t);\n-    }\n+    for cleanup in temp_cleanups { revoke_clean(bcx, cleanup); }\n     ret bcx;\n }\n \n fn trans_rec(bcx: @block_ctxt, fields: [ast::field],\n              base: option::t<@ast::expr>, id: ast::node_id,\n              dest: dest) -> @block_ctxt {\n     let t = node_id_type(bcx_ccx(bcx), id);\n-    let dst = alt dest { save_in(addr) { addr } };\n \n     let base_val = alt base {\n       some(bexp) {\n@@ -4038,58 +4036,50 @@ fn trans_rec(bcx: @block_ctxt, fields: [ast::field],\n       none. { C_nil() }\n     };\n \n-    tag fieldsrc {\n-        provided(lval_result);\n-        inherited(ValueRef);\n-    }\n-    type fieldval = {\n-        dst: ValueRef,\n-        src: fieldsrc,\n-        ty: ty::t\n-    };\n-\n     let ty_fields = alt ty::struct(bcx_tcx(bcx), t) { ty::ty_rec(f) { f } };\n-    let fieldvals = [], i = 0;\n-    // We build the record in two stages so that we don't have to clean up a\n-    // partial record if we fail: first collect all the values, then construct\n-    // the record.\n+    let temp_cleanups = [], i = 0;\n     for tf in ty_fields {\n-        let {bcx: a_bcx, val: addr} = GEP_tup_like_1(bcx, t, dst, [0, i]);\n-        bcx = a_bcx;\n-        // FIXME make this happen in a single pass, again, somehow make the\n-        // dps helpers tie the cleanups together in the right way (we do not\n-        // want to create intermediates for these and then move them again)\n-        fn test(n: str, f: ast::field) -> bool { str::eq(f.node.ident, n) }\n+        let fdest = alt dest {\n+          save_in(addr) {\n+            let gep = GEP_tup_like_1(bcx, t, addr, [0, i]);\n+            bcx = gep.bcx;\n+            some(gep.val)\n+          }\n+          ignore. { none }\n+        };\n         // FIXME make this {|f| str::eq(f.node.ident, tf.ident)} again when\n         // bug #913 is fixed\n-        let s = alt vec::find(bind test(tf.ident, _), fields) {\n-            some(f) {\n-                let lv = trans_lval(bcx, f.node.expr);\n-                bcx = lv.bcx;\n-                provided(lv)\n+        fn test(n: str, f: ast::field) -> bool { str::eq(f.node.ident, n) }\n+        alt vec::find(bind test(tf.ident, _), fields) {\n+          some(f) {\n+            alt fdest {\n+              some(x) { bcx = trans_expr_save_in(bcx, f.node.expr, x); }\n+              none. { bcx = trans_expr_dps(bcx, f.node.expr, ignore); }\n             }\n-            none. {\n-                let src_res = GEP_tup_like_1(bcx, t, base_val, [0, i]);\n-                bcx = src_res.bcx;\n-                inherited(src_res.val)\n+          }\n+          none. {\n+            alt fdest {\n+              some(addr) {\n+                let gep = GEP_tup_like_1(bcx, t, base_val, [0, i]);\n+                let val = load_if_immediate(gep.bcx, gep.val, tf.mt.ty);\n+                bcx = copy_val(gep.bcx, INIT, addr, val, tf.mt.ty);\n+              }\n+              none. {}\n             }\n-        };\n-        fieldvals += [{dst: addr, src: s, ty: tf.mt.ty}];\n-        i += 1;\n-    }\n-    // Now build the record\n-    for fieldval in fieldvals {\n-        alt fieldval.src {\n-          provided(lv) {\n-            bcx = move_val_if_temp(bcx, INIT, fieldval.dst,\n-                                   lv, fieldval.ty);\n           }\n-          inherited(val) {\n-            let val = load_if_immediate(bcx, val, fieldval.ty);\n-            bcx = copy_val(bcx, INIT, fieldval.dst, val, fieldval.ty);\n+        }\n+        alt fdest {\n+          some(addr) {\n+            add_clean_temp_mem(bcx, addr, tf.mt.ty);\n+            temp_cleanups += [addr];\n           }\n+          none. {}\n         }\n+        i += 1;\n     }\n+    // Now revoke the cleanups as we pass responsibility for the data\n+    // structure on to the caller\n+    for cleanup in temp_cleanups { revoke_clean(bcx, cleanup); }\n     ret bcx;\n }\n "}, {"sha": "d46bcf08ac381ce12b451e091f0ec9a59124749d", "filename": "src/comp/middle/trans_common.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8c0918ac1825488f0e71007ce418bf7d7616e530/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c0918ac1825488f0e71007ce418bf7d7616e530/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_common.rs?ref=8c0918ac1825488f0e71007ce418bf7d7616e530", "patch": "@@ -283,6 +283,11 @@ fn add_clean_temp(cx: @block_ctxt, val: ValueRef, ty: ty::t) {\n         [clean_temp(val, bind spill_and_drop(_, val, ty))];\n     scope_cx.lpad_dirty = true;\n }\n+fn add_clean_temp_mem(cx: @block_ctxt, val: ValueRef, ty: ty::t) {\n+    let scope_cx = find_scope_cx(cx);\n+    scope_cx.cleanups += [clean_temp(val, bind drop_ty(_, val, ty))];\n+    scope_cx.lpad_dirty = true;\n+}\n \n // Note that this only works for temporaries. We should, at some point, move\n // to a system where we can also cancel the cleanup on local variables, but"}]}