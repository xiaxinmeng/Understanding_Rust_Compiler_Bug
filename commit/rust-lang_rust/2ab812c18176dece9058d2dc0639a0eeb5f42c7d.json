{"sha": "2ab812c18176dece9058d2dc0639a0eeb5f42c7d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJhYjgxMmMxODE3NmRlY2U5MDU4ZDJkYzA2MzlhMGVlYjVmNDJjN2Q=", "commit": {"author": {"name": "Paul Dicker", "email": "pitdicker@gmail.com", "date": "2019-10-23T07:30:35Z"}, "committer": {"name": "Paul Dicker", "email": "pitdicker@gmail.com", "date": "2019-10-23T10:09:53Z"}, "message": "Rename state to state_and_queue", "tree": {"sha": "04dd2052434facd4be7bf895040537d4000913e1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/04dd2052434facd4be7bf895040537d4000913e1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2ab812c18176dece9058d2dc0639a0eeb5f42c7d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2ab812c18176dece9058d2dc0639a0eeb5f42c7d", "html_url": "https://github.com/rust-lang/rust/commit/2ab812c18176dece9058d2dc0639a0eeb5f42c7d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2ab812c18176dece9058d2dc0639a0eeb5f42c7d/comments", "author": {"login": "pitdicker", "id": 6255050, "node_id": "MDQ6VXNlcjYyNTUwNTA=", "avatar_url": "https://avatars.githubusercontent.com/u/6255050?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pitdicker", "html_url": "https://github.com/pitdicker", "followers_url": "https://api.github.com/users/pitdicker/followers", "following_url": "https://api.github.com/users/pitdicker/following{/other_user}", "gists_url": "https://api.github.com/users/pitdicker/gists{/gist_id}", "starred_url": "https://api.github.com/users/pitdicker/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pitdicker/subscriptions", "organizations_url": "https://api.github.com/users/pitdicker/orgs", "repos_url": "https://api.github.com/users/pitdicker/repos", "events_url": "https://api.github.com/users/pitdicker/events{/privacy}", "received_events_url": "https://api.github.com/users/pitdicker/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pitdicker", "id": 6255050, "node_id": "MDQ6VXNlcjYyNTUwNTA=", "avatar_url": "https://avatars.githubusercontent.com/u/6255050?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pitdicker", "html_url": "https://github.com/pitdicker", "followers_url": "https://api.github.com/users/pitdicker/followers", "following_url": "https://api.github.com/users/pitdicker/following{/other_user}", "gists_url": "https://api.github.com/users/pitdicker/gists{/gist_id}", "starred_url": "https://api.github.com/users/pitdicker/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pitdicker/subscriptions", "organizations_url": "https://api.github.com/users/pitdicker/orgs", "repos_url": "https://api.github.com/users/pitdicker/repos", "events_url": "https://api.github.com/users/pitdicker/events{/privacy}", "received_events_url": "https://api.github.com/users/pitdicker/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "57bfb8096295150c06559da10adc5629e445a4ac", "url": "https://api.github.com/repos/rust-lang/rust/commits/57bfb8096295150c06559da10adc5629e445a4ac", "html_url": "https://github.com/rust-lang/rust/commit/57bfb8096295150c06559da10adc5629e445a4ac"}], "stats": {"total": 57, "additions": 29, "deletions": 28}, "files": [{"sha": "277ea954c56263d872c636ba3c0e109d11606f59", "filename": "src/libstd/sync/once.rs", "status": "modified", "additions": 29, "deletions": 28, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/2ab812c18176dece9058d2dc0639a0eeb5f42c7d/src%2Flibstd%2Fsync%2Fonce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ab812c18176dece9058d2dc0639a0eeb5f42c7d/src%2Flibstd%2Fsync%2Fonce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fonce.rs?ref=2ab812c18176dece9058d2dc0639a0eeb5f42c7d", "patch": "@@ -78,9 +78,9 @@ use crate::thread::{self, Thread};\n /// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Once {\n-    // This `state` word is actually an encoded version of just a pointer to a\n-    // `Waiter`, so we add the `PhantomData` appropriately.\n-    state: AtomicUsize,\n+    // `state_and_queue` is actually an a pointer to a `Waiter` with extra state\n+    // bits, so we add the `PhantomData` appropriately.\n+    state_and_queue: AtomicUsize,\n     _marker: marker::PhantomData<*mut Waiter>,\n }\n \n@@ -121,8 +121,8 @@ pub struct OnceState {\n )]\n pub const ONCE_INIT: Once = Once::new();\n \n-// Four states that a Once can be in, encoded into the lower bits of `state` in\n-// the Once structure.\n+// Four states that a Once can be in, encoded into the lower bits of\n+// `state_and_queue` in the Once structure.\n const INCOMPLETE: usize = 0x0;\n const POISONED: usize = 0x1;\n const RUNNING: usize = 0x2;\n@@ -151,7 +151,7 @@ impl Once {\n     #[stable(feature = \"once_new\", since = \"1.2.0\")]\n     pub const fn new() -> Once {\n         Once {\n-            state: AtomicUsize::new(INCOMPLETE),\n+            state_and_queue: AtomicUsize::new(INCOMPLETE),\n             _marker: marker::PhantomData,\n         }\n     }\n@@ -330,7 +330,7 @@ impl Once {\n         // operations visible to us, and, this being a fast path, weaker\n         // ordering helps with performance. This `Acquire` synchronizes with\n         // `SeqCst` operations on the slow path.\n-        self.state.load(Ordering::Acquire) == COMPLETE\n+        self.state_and_queue.load(Ordering::Acquire) == COMPLETE\n     }\n \n     // This is a non-generic function to reduce the monomorphization cost of\n@@ -352,10 +352,10 @@ impl Once {\n         // This cold path uses SeqCst consistently because the\n         // performance difference really does not matter there, and\n         // SeqCst minimizes the chances of something going wrong.\n-        let mut state = self.state.load(Ordering::SeqCst);\n+        let mut state_and_queue = self.state_and_queue.load(Ordering::SeqCst);\n \n         'outer: loop {\n-            match state {\n+            match state_and_queue {\n                 // If we're complete, then there's nothing to do, we just\n                 // jettison out as we shouldn't run the closure.\n                 COMPLETE => return,\n@@ -372,10 +372,11 @@ impl Once {\n                 // bits).\n                 POISONED |\n                 INCOMPLETE => {\n-                    let old = self.state.compare_and_swap(state, RUNNING,\n-                                                          Ordering::SeqCst);\n-                    if old != state {\n-                        state = old;\n+                    let old = self.state_and_queue.compare_and_swap(state_and_queue,\n+                                                                    RUNNING,\n+                                                                    Ordering::SeqCst);\n+                    if old != state_and_queue {\n+                        state_and_queue = old;\n                         continue\n                     }\n \n@@ -388,7 +389,7 @@ impl Once {\n                         panicked: true,\n                         me: self,\n                     };\n-                    init(state == POISONED);\n+                    init(state_and_queue == POISONED);\n                     complete.panicked = false;\n                     return\n                 }\n@@ -399,7 +400,7 @@ impl Once {\n                 // head of the list and bail out if we ever see a state that's\n                 // not RUNNING.\n                 _ => {\n-                    assert!(state & STATE_MASK == RUNNING);\n+                    assert!(state_and_queue & STATE_MASK == RUNNING);\n                     let mut node = Waiter {\n                         thread: Some(thread::current()),\n                         signaled: AtomicBool::new(false),\n@@ -408,13 +409,13 @@ impl Once {\n                     let me = &mut node as *mut Waiter as usize;\n                     assert!(me & STATE_MASK == 0);\n \n-                    while state & STATE_MASK == RUNNING {\n-                        node.next = (state & !STATE_MASK) as *mut Waiter;\n-                        let old = self.state.compare_and_swap(state,\n-                                                              me | RUNNING,\n-                                                              Ordering::SeqCst);\n-                        if old != state {\n-                            state = old;\n+                    while state_and_queue & STATE_MASK == RUNNING {\n+                        node.next = (state_and_queue & !STATE_MASK) as *mut Waiter;\n+                        let old = self.state_and_queue.compare_and_swap(state_and_queue,\n+                                                                        me | RUNNING,\n+                                                                        Ordering::SeqCst);\n+                        if old != state_and_queue {\n+                            state_and_queue = old;\n                             continue\n                         }\n \n@@ -424,7 +425,7 @@ impl Once {\n                         while !node.signaled.load(Ordering::SeqCst) {\n                             thread::park();\n                         }\n-                        state = self.state.load(Ordering::SeqCst);\n+                        state_and_queue = self.state_and_queue.load(Ordering::SeqCst);\n                         continue 'outer\n                     }\n                 }\n@@ -444,19 +445,19 @@ impl Drop for Finish<'_> {\n     fn drop(&mut self) {\n         // Swap out our state with however we finished. We should only ever see\n         // an old state which was RUNNING.\n-        let queue = if self.panicked {\n-            self.me.state.swap(POISONED, Ordering::SeqCst)\n+        let state_and_queue = if self.panicked {\n+            self.me.state_and_queue.swap(POISONED, Ordering::SeqCst)\n         } else {\n-            self.me.state.swap(COMPLETE, Ordering::SeqCst)\n+            self.me.state_and_queue.swap(COMPLETE, Ordering::SeqCst)\n         };\n-        assert_eq!(queue & STATE_MASK, RUNNING);\n+        assert_eq!(state_and_queue & STATE_MASK, RUNNING);\n \n         // Decode the RUNNING to a list of waiters, then walk that entire list\n         // and wake them up. Note that it is crucial that after we store `true`\n         // in the node it can be free'd! As a result we load the `thread` to\n         // signal ahead of time and then unpark it after the store.\n         unsafe {\n-            let mut queue = (queue & !STATE_MASK) as *mut Waiter;\n+            let mut queue = (state_and_queue & !STATE_MASK) as *mut Waiter;\n             while !queue.is_null() {\n                 let next = (*queue).next;\n                 let thread = (*queue).thread.take().unwrap();"}]}