{"sha": "2727a8e1c06f27169be6a414623880f118551dbd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI3MjdhOGUxYzA2ZjI3MTY5YmU2YTQxNDYyMzg4MGYxMTg1NTFkYmQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-09-04T00:00:09Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-09-04T00:00:09Z"}, "message": "Auto merge of #27984 - arielb1:misc-assemble-improvements, r=nikomatsakis\n\nthis resolves type-variables early in assemble_candidates and\r\nbails out quickly if the self type is an inference variable (which would\r\nfail anyway because of `assemble_candidates_from_projected_tys`).\r\n\r\nIn both these cases, `assemble_candidates_from_impls` would try to go\r\nover all impls and match them, leading to O(`n*m`) performance. Fixing this\r\nimproves rustc type-checking performance by 10%. As type-checking is only\r\nis 5% of compilation, this doesn't impact bootstrap times, but *does*\r\nimprove type-error-detection time which is nice.\r\n\r\nCrates that have many dependencies and contain significant amounts of\r\ngeneric functions could see a bigger perf boost. As a microbenchmark,\r\nthe crate generated by\r\n\r\n```\r\necho '#![feature(rustc_private)]'\r\necho 'extern crate rustc_driver;'\r\nfor i in {1..1000}; do cat << _EOF_\r\n    pub fn foo$i<T>() {\r\n        let mut v = Vec::new();\r\n        let _w = v.clone();\r\n        v.push(\"\");\r\n    }\r\n_EOF_\r\ndone\r\n```\r\n\r\nsees performance improve from 7.2 to 1.4 seconds. I imagine many crates\r\nwould fall somewhere in-between.\r\n\r\nr? @nikomatsakis", "tree": {"sha": "1208acd7fe832855a113377321c2d350600a0d65", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1208acd7fe832855a113377321c2d350600a0d65"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2727a8e1c06f27169be6a414623880f118551dbd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2727a8e1c06f27169be6a414623880f118551dbd", "html_url": "https://github.com/rust-lang/rust/commit/2727a8e1c06f27169be6a414623880f118551dbd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2727a8e1c06f27169be6a414623880f118551dbd/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1b908be9a0d7aaf8f18854db1ffef7b8df10dfeb", "url": "https://api.github.com/repos/rust-lang/rust/commits/1b908be9a0d7aaf8f18854db1ffef7b8df10dfeb", "html_url": "https://github.com/rust-lang/rust/commit/1b908be9a0d7aaf8f18854db1ffef7b8df10dfeb"}, {"sha": "ab86bf53eb2fb9289c7ce811d1615eff2c529e34", "url": "https://api.github.com/repos/rust-lang/rust/commits/ab86bf53eb2fb9289c7ce811d1615eff2c529e34", "html_url": "https://github.com/rust-lang/rust/commit/ab86bf53eb2fb9289c7ce811d1615eff2c529e34"}], "stats": {"total": 67, "additions": 36, "deletions": 31}, "files": [{"sha": "ccdb271d43f852c7710fec3a8d44e3ef31cc69c4", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 36, "deletions": 31, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/2727a8e1c06f27169be6a414623880f118551dbd/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2727a8e1c06f27169be6a414623880f118551dbd/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=2727a8e1c06f27169be6a414623880f118551dbd", "patch": "@@ -186,7 +186,7 @@ pub enum MethodMatchedData {\n /// that we can have both a projection candidate and a where-clause candidate\n /// for the same obligation. In that case either would do (except that\n /// different \"leaps of logic\" would occur if inference variables are\n-/// present), and we just pick the projection. This is, for example,\n+/// present), and we just pick the where-clause. This is, for example,\n /// required for associated types to work in default impls, as the bounds\n /// are visible both as projection bounds and as where-clauses from the\n /// parameter environment.\n@@ -916,6 +916,24 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                                -> Result<SelectionCandidateSet<'tcx>, SelectionError<'tcx>>\n     {\n         let TraitObligationStack { obligation, .. } = *stack;\n+        let ref obligation = Obligation {\n+            cause: obligation.cause.clone(),\n+            recursion_depth: obligation.recursion_depth,\n+            predicate: self.infcx().resolve_type_vars_if_possible(&obligation.predicate)\n+        };\n+\n+        if obligation.predicate.skip_binder().self_ty().is_ty_var() {\n+            // FIXME(#20297): Self is a type variable (e.g. `_: AsRef<str>`).\n+            //\n+            // This is somewhat problematic, as the current scheme can't really\n+            // handle it turning to be a projection. This does end up as truly\n+            // ambiguous in most cases anyway.\n+            //\n+            // Until this is fixed, take the fast path out - this also improves\n+            // performance by preventing assemble_candidates_from_impls from\n+            // matching every impl for this trait.\n+            return Ok(SelectionCandidateSet { vec: vec![], ambiguous: true });\n+        }\n \n         let mut candidates = SelectionCandidateSet {\n             vec: Vec::new(),\n@@ -936,13 +954,15 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n                 // For other types, we'll use the builtin rules.\n                 try!(self.assemble_builtin_bound_candidates(ty::BoundCopy,\n-                                                            stack,\n+                                                            obligation,\n                                                             &mut candidates));\n             }\n             Some(bound @ ty::BoundSized) => {\n                 // Sized is never implementable by end-users, it is\n                 // always automatically computed.\n-                try!(self.assemble_builtin_bound_candidates(bound, stack, &mut candidates));\n+                try!(self.assemble_builtin_bound_candidates(bound,\n+                                                            obligation,\n+                                                            &mut candidates));\n             }\n \n             None if self.tcx().lang_items.unsize_trait() ==\n@@ -975,29 +995,17 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                                               obligation: &TraitObligation<'tcx>,\n                                               candidates: &mut SelectionCandidateSet<'tcx>)\n     {\n-        let poly_trait_predicate =\n-            self.infcx().resolve_type_vars_if_possible(&obligation.predicate);\n-\n-        debug!(\"assemble_candidates_for_projected_tys({:?},{:?})\",\n-               obligation,\n-               poly_trait_predicate);\n+        debug!(\"assemble_candidates_for_projected_tys({:?})\", obligation);\n \n         // FIXME(#20297) -- just examining the self-type is very simplistic\n \n         // before we go into the whole skolemization thing, just\n         // quickly check if the self-type is a projection at all.\n-        let trait_def_id = match poly_trait_predicate.0.trait_ref.self_ty().sty {\n+        let trait_def_id = match obligation.predicate.0.trait_ref.self_ty().sty {\n             ty::TyProjection(ref data) => data.trait_ref.def_id,\n             ty::TyInfer(ty::TyVar(_)) => {\n-                // If the self-type is an inference variable, then it MAY wind up\n-                // being a projected type, so induce an ambiguity.\n-                //\n-                // FIXME(#20297) -- being strict about this can cause\n-                // inference failures with BorrowFrom, which is\n-                // unfortunate. Can we do better here?\n-                debug!(\"assemble_candidates_for_projected_tys: ambiguous self-type\");\n-                candidates.ambiguous = true;\n-                return;\n+                self.tcx().sess.span_bug(obligation.cause.span,\n+                    \"Self=_ should have been handled by assemble_candidates\");\n             }\n             _ => { return; }\n         };\n@@ -1165,7 +1173,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // ok to skip binder because the substs on closure types never\n         // touch bound regions, they just capture the in-scope\n         // type/region parameters\n-        let self_ty = self.infcx.shallow_resolve(*obligation.self_ty().skip_binder());\n+        let self_ty = *obligation.self_ty().skip_binder();\n         let (closure_def_id, substs) = match self_ty.sty {\n             ty::TyClosure(id, ref substs) => (id, substs),\n             ty::TyInfer(ty::TyVar(_)) => {\n@@ -1209,7 +1217,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         }\n \n         // ok to skip binder because what we are inspecting doesn't involve bound regions\n-        let self_ty = self.infcx.shallow_resolve(*obligation.self_ty().skip_binder());\n+        let self_ty = *obligation.self_ty().skip_binder();\n         match self_ty.sty {\n             ty::TyInfer(ty::TyVar(_)) => {\n                 debug!(\"assemble_fn_pointer_candidates: ambiguous self-type\");\n@@ -1266,7 +1274,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                                               -> Result<(), SelectionError<'tcx>>\n     {\n         // OK to skip binder here because the tests we do below do not involve bound regions\n-        let self_ty = self.infcx.shallow_resolve(*obligation.self_ty().skip_binder());\n+        let self_ty = *obligation.self_ty().skip_binder();\n         debug!(\"assemble_candidates_from_default_impls(self_ty={:?})\", self_ty);\n \n         let def_id = obligation.predicate.def_id();\n@@ -1322,7 +1330,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                                           candidates: &mut SelectionCandidateSet<'tcx>)\n     {\n         debug!(\"assemble_candidates_from_object_ty(self_ty={:?})\",\n-               self.infcx.shallow_resolve(*obligation.self_ty().skip_binder()));\n+               obligation.self_ty().skip_binder());\n \n         // Object-safety candidates are only applicable to object-safe\n         // traits. Including this check is useful because it helps\n@@ -1337,10 +1345,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         }\n \n         self.infcx.commit_if_ok(|snapshot| {\n-            let bound_self_ty =\n-                self.infcx.resolve_type_vars_if_possible(&obligation.self_ty());\n             let (self_ty, _) =\n-                self.infcx().skolemize_late_bound_regions(&bound_self_ty, snapshot);\n+                self.infcx().skolemize_late_bound_regions(&obligation.self_ty(), snapshot);\n             let poly_trait_ref = match self_ty.sty {\n                 ty::TyTrait(ref data) => {\n                     match self.tcx().lang_items.to_builtin_kind(obligation.predicate.def_id()) {\n@@ -1414,15 +1420,14 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         //     T: Trait\n         // so it seems ok if we (conservatively) fail to accept that `Unsize`\n         // obligation above. Should be possible to extend this in the future.\n-        let self_ty = match self.tcx().no_late_bound_regions(&obligation.self_ty()) {\n+        let source = match self.tcx().no_late_bound_regions(&obligation.self_ty()) {\n             Some(t) => t,\n             None => {\n                 // Don't add any candidates if there are bound regions.\n                 return;\n             }\n         };\n-        let source = self.infcx.shallow_resolve(self_ty);\n-        let target = self.infcx.shallow_resolve(obligation.predicate.0.input_types()[0]);\n+        let target = obligation.predicate.0.input_types()[0];\n \n         debug!(\"assemble_candidates_for_unsizing(source={:?}, target={:?})\",\n                source, target);\n@@ -1577,11 +1582,11 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n     fn assemble_builtin_bound_candidates<'o>(&mut self,\n                                              bound: ty::BuiltinBound,\n-                                             stack: &TraitObligationStack<'o, 'tcx>,\n+                                             obligation: &TraitObligation<'tcx>,\n                                              candidates: &mut SelectionCandidateSet<'tcx>)\n                                              -> Result<(),SelectionError<'tcx>>\n     {\n-        match self.builtin_bound(bound, stack.obligation) {\n+        match self.builtin_bound(bound, obligation) {\n             Ok(If(..)) => {\n                 debug!(\"builtin_bound: bound={:?}\",\n                        bound);"}]}