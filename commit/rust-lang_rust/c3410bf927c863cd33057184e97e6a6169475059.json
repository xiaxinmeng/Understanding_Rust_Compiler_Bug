{"sha": "c3410bf927c863cd33057184e97e6a6169475059", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMzNDEwYmY5MjdjODYzY2QzMzA1NzE4NGU5N2U2YTYxNjk0NzUwNTk=", "commit": {"author": {"name": "Lindsey Kuper", "email": "lkuper@mozilla.com", "date": "2011-05-21T00:41:36Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-05-21T00:59:56Z"}, "message": "More work on anonymous objects.", "tree": {"sha": "194208276f037bac16162bca9a8659feeed577d9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/194208276f037bac16162bca9a8659feeed577d9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c3410bf927c863cd33057184e97e6a6169475059", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c3410bf927c863cd33057184e97e6a6169475059", "html_url": "https://github.com/rust-lang/rust/commit/c3410bf927c863cd33057184e97e6a6169475059", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c3410bf927c863cd33057184e97e6a6169475059/comments", "author": {"login": "lkuper", "id": 535218, "node_id": "MDQ6VXNlcjUzNTIxOA==", "avatar_url": "https://avatars.githubusercontent.com/u/535218?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lkuper", "html_url": "https://github.com/lkuper", "followers_url": "https://api.github.com/users/lkuper/followers", "following_url": "https://api.github.com/users/lkuper/following{/other_user}", "gists_url": "https://api.github.com/users/lkuper/gists{/gist_id}", "starred_url": "https://api.github.com/users/lkuper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lkuper/subscriptions", "organizations_url": "https://api.github.com/users/lkuper/orgs", "repos_url": "https://api.github.com/users/lkuper/repos", "events_url": "https://api.github.com/users/lkuper/events{/privacy}", "received_events_url": "https://api.github.com/users/lkuper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c8d488b337b3f61d6336cc798aa74a4642bc204d", "url": "https://api.github.com/repos/rust-lang/rust/commits/c8d488b337b3f61d6336cc798aa74a4642bc204d", "html_url": "https://github.com/rust-lang/rust/commit/c8d488b337b3f61d6336cc798aa74a4642bc204d"}], "stats": {"total": 309, "additions": 281, "deletions": 28}, "files": [{"sha": "54f800c1667d18c6529b309b1b17cbef98ac5efa", "filename": "src/comp/back/abi.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c3410bf927c863cd33057184e97e6a6169475059/src%2Fcomp%2Fback%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3410bf927c863cd33057184e97e6a6169475059/src%2Fcomp%2Fback%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Fabi.rs?ref=c3410bf927c863cd33057184e97e6a6169475059", "patch": "@@ -55,6 +55,8 @@ const int obj_field_box = 1;\n const int obj_body_elt_tydesc = 0;\n const int obj_body_elt_typarams = 1;\n const int obj_body_elt_fields = 2;\n+const int obj_body_elt_with_obj = 3; /* The base object to which an anonymous\n+                                      * object is attached */\n \n const int fn_field_code = 0;\n const int fn_field_box = 1;"}, {"sha": "0653e45d26893b1e9fe79ee8db7e0f9edbc4617f", "filename": "src/comp/front/ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c3410bf927c863cd33057184e97e6a6169475059/src%2Fcomp%2Ffront%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3410bf927c863cd33057184e97e6a6169475059/src%2Fcomp%2Ffront%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fast.rs?ref=c3410bf927c863cd33057184e97e6a6169475059", "patch": "@@ -379,7 +379,7 @@ type anon_obj = rec(\n     option::t[vec[obj_field]] fields,\n     vec[@method] methods,\n     // with_obj: the original object being extended, if it exists.\n-    option::t[ident] with_obj);\n+    option::t[@expr] with_obj);\n \n type _mod = rec(vec[@view_item] view_items,\n                 vec[@item] items);"}, {"sha": "8bd02aea74b6bb6b852134ce51733877fcda37f0", "filename": "src/comp/front/parser.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c3410bf927c863cd33057184e97e6a6169475059/src%2Fcomp%2Ffront%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3410bf927c863cd33057184e97e6a6169475059/src%2Fcomp%2Ffront%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fparser.rs?ref=c3410bf927c863cd33057184e97e6a6169475059", "patch": "@@ -820,13 +820,13 @@ fn parse_bottom_expr(&parser p) -> @ast::expr {\n         }\n \n         let vec[@ast::method] meths = [];\n-        let option::t[ast::ident] with_obj = none[ast::ident];\n+        let option::t[@ast::expr] with_obj = none[@ast::expr];\n \n         expect(p, token::LBRACE);\n \n         while (p.peek() != token::RBRACE) {\n             if (eat_word(p, \"with\")) {\n-                with_obj = some[ast::ident](parse_ident(p));\n+                with_obj = some[@ast::expr](parse_expr(p));\n             } else {\n                 vec::push[@ast::method](meths,\n                                          parse_method(p));"}, {"sha": "1173c11729e0ce86969d026113c2c7b1fa5de968", "filename": "src/comp/middle/fold.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c3410bf927c863cd33057184e97e6a6169475059/src%2Fcomp%2Fmiddle%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3410bf927c863cd33057184e97e6a6169475059/src%2Fcomp%2Fmiddle%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ffold.rs?ref=c3410bf927c863cd33057184e97e6a6169475059", "patch": "@@ -336,7 +336,7 @@ type ast_fold[ENV] =\n      (fn(&ENV e,\n          &option::t[vec[ast::obj_field]] fields,\n          &vec[@ast::method] methods,\n-         &option::t[ident] with_obj) \n+         &option::t[@ast::expr] with_obj) \n       -> ast::anon_obj)                           fold_anon_obj,\n \n      // Env updates.\n@@ -1001,11 +1001,11 @@ fn fold_anon_obj[ENV](&ENV env, &ast_fold[ENV] fld, &ast::anon_obj ob)\n     }\n \n     // with_obj\n-    let option::t[ast::ident] with_obj = none[ast::ident];\n+    let option::t[@ast::expr] with_obj = none[@ast::expr];\n     alt (ob.with_obj) {\n-        case (none[ast::ident]) { }\n-        case (some[ast::ident](?i)) {\n-            with_obj = some[ast::ident](i);\n+        case (none[@ast::expr]) { }\n+        case (some[@ast::expr](?e)) {\n+            with_obj = some[@ast::expr](fold_expr(env, fld, e));\n         }\n     }\n \n@@ -1665,7 +1665,8 @@ fn identity_fold_obj[ENV](&ENV e,\n fn identity_fold_anon_obj[ENV](&ENV e,\n                                &option::t[vec[ast::obj_field]] fields,\n                                &vec[@ast::method] methods,\n-                               &option::t[ident] with_obj) -> ast::anon_obj {\n+                               &option::t[@ast::expr] with_obj) \n+    -> ast::anon_obj {\n     ret rec(fields=fields, methods=methods, with_obj=with_obj);\n }\n "}, {"sha": "4f9dd2f9a341d8965991c7562505f26eb061af30", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 77, "deletions": 1, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/c3410bf927c863cd33057184e97e6a6169475059/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3410bf927c863cd33057184e97e6a6169475059/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=c3410bf927c863cd33057184e97e6a6169475059", "patch": "@@ -4576,7 +4576,8 @@ fn trans_lval(&@block_ctxt cx, &@ast::expr e) -> lval_result {\n         }\n         case (_) {\n             cx.fcx.lcx.ccx.sess.span_unimpl(e.span,\n-                                            \"expr variant in trans_lval\");\n+                                            \"expr variant in trans_lval: \" \n+                                            + util::common::expr_to_str(e));\n         }\n     }\n     fail;\n@@ -5547,6 +5548,10 @@ fn trans_expr(&@block_ctxt cx, &@ast::expr e) -> result {\n             ret trans_spawn(cx, dom, name, func, args, ann);\n         }\n \n+        case (ast::expr_anon_obj(?anon_obj, ?tps, ?odid, ?ann)) {\n+            ret trans_anon_obj(cx, e.span, anon_obj, tps, odid, ann);\n+        }\n+\n         case (_) {\n             // The expression is an lvalue. Fall through.\n         }\n@@ -6111,6 +6116,77 @@ fn recv_val(&@block_ctxt cx, ValueRef lhs, &@ast::expr rhs,\n     ret res(bcx, lhs);\n }\n \n+\n+/*\n+\n+  Suppose we create an anonymous object my_b from a regular object a:\n+\n+        obj a() {\n+            fn foo() -> int {\n+                ret 2;\n+            }\n+            fn bar() -> int {\n+                ret self.foo();\n+            }\n+        }\n+\n+       auto my_a = a();\n+       auto my_b = obj { fn baz() -> int { ret self.foo() } with my_a };\n+\n+  Here we're extending the my_a object with an additional method baz, creating\n+  an object my_b. Since it's an object, my_b is a pair of a vtable pointer and\n+  a body pointer:\n+\n+  my_b: [vtbl* | body*]\n+\n+  my_b's vtable has entries for foo, bar, and baz, whereas my_a's vtable has\n+  only foo and bar. my_b's 3-entry vtable consists of two forwarding functions\n+  and one real method.\n+\n+  my_b's body just contains the pair a: [ a_vtable | a_body ], wrapped up with\n+  any additional fields that my_b added. None were added, so my_b is just the\n+  wrapped inner object.\n+\n+*/\n+fn trans_anon_obj(&@block_ctxt cx, &ast::span sp,\n+                  &ast::anon_obj anon_obj, \n+                  &vec[ast::ty_param] ty_params,\n+                  &ast::obj_def_ids oid,\n+                  &ast::ann ann) -> result {\n+\n+    let option::t[result] with_obj_val = none[result];\n+    alt (anon_obj.with_obj) {\n+        case (none[@ast::expr]) { }\n+        case (some[@ast::expr](?e)) {\n+            // Translating with_obj returns a pointer to a 2-word value.  We\n+            // want to allocate space for this value in our outer object, then\n+            // copy it into the outer object.\n+            with_obj_val = some[result](trans_expr(cx, e));\n+        }\n+    }\n+\n+    // For the anon obj's additional fields, if any exist, translate object\n+    // constructor arguments to function arguments.\n+    let option::t[vec[ast::obj_field]] addtl_fields \n+        = none[vec[ast::obj_field]];\n+    let vec[ast::arg] addtl_fn_args = [];\n+\n+    alt (anon_obj.fields) {\n+        case (none[vec[ast::obj_field]]) { }\n+        case (some[vec[ast::obj_field]](?fields)) {\n+            for (ast::obj_field f in fields) {\n+                addtl_fn_args += [rec(mode=ast::alias, ty=f.ty, \n+                                      ident=f.ident, id=f.id)];\n+            }\n+        }\n+    }\n+\n+    // TODO: everything else.\n+\n+    cx.fcx.lcx.ccx.sess.unimpl(\"support for anonymous objects\");\n+    fail;\n+}\n+\n fn init_local(&@block_ctxt cx, &@ast::local local) -> result {\n \n     // Make a note to drop this slot on the way out."}, {"sha": "308c99ac62056ef764f88c501da8f280c0c4222a", "filename": "src/comp/middle/tstate/pre_post_conditions.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c3410bf927c863cd33057184e97e6a6169475059/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3410bf927c863cd33057184e97e6a6169475059/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs?ref=c3410bf927c863cd33057184e97e6a6169475059", "patch": "@@ -132,6 +132,7 @@ import front::ast::expr_assert;\n import front::ast::expr_cast;\n import front::ast::expr_for;\n import front::ast::expr_for_each;\n+import front::ast::expr_anon_obj;\n import front::ast::stmt_decl;\n import front::ast::stmt_expr;\n import front::ast::block;\n@@ -556,6 +557,17 @@ fn find_pre_post_expr(&fn_ctxt fcx, @expr e) -> () {\n             find_pre_post_expr(fcx, expanded);\n             copy_pre_post(fcx.ccx, a, expanded);\n         }\n+        case (expr_anon_obj(?anon_obj, _, _, ?a)) {\n+            alt (anon_obj.with_obj) {\n+                case (some[@expr](?ex)) {\n+                    find_pre_post_expr(fcx, ex);\n+                    copy_pre_post(fcx.ccx, a, ex);\n+                }\n+                case (none[@expr]) {\n+                    clear_pp(expr_pp(fcx.ccx, e));\n+                }\n+            }\n+        }\n     }\n }\n "}, {"sha": "ef1e86275ce6f3cb9688dff0db468a0d90e370be", "filename": "src/comp/middle/tstate/states.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c3410bf927c863cd33057184e97e6a6169475059/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3410bf927c863cd33057184e97e6a6169475059/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs?ref=c3410bf927c863cd33057184e97e6a6169475059", "patch": "@@ -143,6 +143,7 @@ import front::ast::expr_assert;\n import front::ast::expr_cast;\n import front::ast::expr_for;\n import front::ast::expr_for_each;\n+import front::ast::expr_anon_obj;\n import front::ast::stmt_decl;\n import front::ast::stmt_expr;\n import front::ast::block;\n@@ -578,6 +579,20 @@ fn find_pre_post_state_expr(&fn_ctxt fcx, &prestate pres, @expr e) -> bool {\n     case (expr_self_method(_, ?a)) {\n         ret pure_exp(fcx.ccx, a, pres);\n     }\n+    case (expr_anon_obj(?anon_obj, _, _,?a)) {\n+        alt (anon_obj.with_obj) {\n+            case (some[@expr](?e)) {\n+                changed = find_pre_post_state_expr(fcx, pres, e);\n+                changed = extend_prestate_ann(fcx.ccx, a, pres) || changed;\n+                changed = extend_poststate_ann(fcx.ccx, a,\n+                            expr_poststate(fcx.ccx, e)) || changed;\n+                ret changed;\n+            }\n+            case (none[@expr]) {\n+                ret pure_exp(fcx.ccx, a, pres);\n+            }\n+        }\n+    }\n   }\n }\n "}, {"sha": "cb95a5e6f01c23cecb2dcfa723b7e75d412a252a", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 101, "deletions": 15, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/c3410bf927c863cd33057184e97e6a6169475059/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3410bf927c863cd33057184e97e6a6169475059/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=c3410bf927c863cd33057184e97e6a6169475059", "patch": "@@ -502,13 +502,13 @@ mod collect {\n         ret tpt;\n     }\n \n-    fn ty_of_arg(@ctxt cx, &ast::arg a) -> arg {\n+    fn ty_of_arg(@ctxt cx, &ast::arg a) -> ty::arg {\n         auto ty_mode = ast_mode_to_mode(a.mode);\n         auto f = bind getter(cx, _);\n         ret rec(mode=ty_mode, ty=ast_ty_to_ty(cx.tcx, f, a.ty));\n     }\n \n-    fn ty_of_method(@ctxt cx, &@ast::method m) -> method {\n+    fn ty_of_method(@ctxt cx, &@ast::method m) -> ty::method {\n         auto get = bind getter(cx, _);\n         auto convert = bind ast_ty_to_ty(cx.tcx, get, _);\n         auto f = bind ty_of_arg(cx, _);\n@@ -694,10 +694,10 @@ mod collect {\n \n         ret result;\n     }\n-\n-    fn get_obj_method_types(&@ctxt cx, &ast::_obj object) -> vec[method] {\n+    \n+    fn get_obj_method_types(&@ctxt cx, &ast::_obj object) -> vec[ty::method] {\n         ret vec::map[@ast::method,method](bind ty_of_method(cx, _),\n-                                           object.methods);\n+                                          object.methods);\n     }\n \n     fn collect(ty::item_table id_to_ty_item, &@ast::item i) {\n@@ -1485,6 +1485,14 @@ mod Pushdown {\n                 write::ty_only_fixup(scx, ann.id, t);\n             }\n \n+            case (ast::expr_anon_obj(?anon_obj, ?tps, ?odid, ?ann)) {\n+                // NB: Not sure if this is correct, but not worrying too much\n+                // about it since pushdown is going away anyway.\n+                auto t = Demand::autoderef(scx, e.span, expected,\n+                    ann_to_type(scx.fcx.ccx.tcx.node_types, ann), adk);\n+                write::ty_only_fixup(scx, ann.id, t);\n+            }\n+\n             case (_) {\n                 scx.fcx.ccx.tcx.sess.span_unimpl(e.span,\n                     #fmt(\"type unification for expression variant: %s\",\n@@ -1771,14 +1779,13 @@ fn require_pure_function(@crate_ctxt ccx, &ast::def_id d_id, &span sp) -> () {\n }\n \n fn check_expr(&@stmt_ctxt scx, &@ast::expr expr) {\n-    //fcx.ccx.tcx.sess.span_warn(expr.span, \"typechecking expr \" +\n-    //                       util::common::expr_to_str(expr));\n+    // scx.fcx.ccx.tcx.sess.span_warn(expr.span, \"typechecking expr \" +\n+    //                                util::common::expr_to_str(expr));\n \n     // A generic function to factor out common logic from call and bind\n     // expressions.\n     fn check_call_or_bind(&@stmt_ctxt scx, &@ast::expr f,\n                           &vec[option::t[@ast::expr]] args) {\n-\n         // Check the function.\n         check_expr(scx, f);\n \n@@ -2297,10 +2304,20 @@ fn check_expr(&@stmt_ctxt scx, &@ast::expr expr) {\n             auto t = ty::mk_nil(scx.fcx.ccx.tcx);\n             let ty::t this_obj_ty;\n \n-            auto oinfo_opt = get_obj_info(scx.fcx.ccx);\n-            auto this_obj_id = option::get[obj_info](oinfo_opt).this_obj;\n-            this_obj_ty = ty::lookup_item_type(scx.fcx.ccx.tcx,\n-                                               this_obj_id)._1;\n+            let option::t[obj_info] this_obj_info = get_obj_info(scx.fcx.ccx);\n+\n+            alt (this_obj_info) {\n+                // If we're inside a current object, grab its type.\n+                case (some[obj_info](?obj_info)) {\n+                    // FIXME: In the case of anonymous objects with methods\n+                    // containing self-calls, this lookup fails because\n+                    // obj_info.this_obj is not in the type cache\n+                    this_obj_ty = ty::lookup_item_type(scx.fcx.ccx.tcx, \n+                                                       obj_info.this_obj)._1;\n+                }\n+\n+                case (none[obj_info]) { fail; }\n+            }\n \n             // Grab this method's type out of the current object type.\n             alt (struct(scx.fcx.ccx.tcx, this_obj_ty)) {\n@@ -2474,7 +2491,7 @@ fn check_expr(&@stmt_ctxt scx, &@ast::expr expr) {\n                 case (ty::ty_rec(?fields)) {\n                     let uint ix = ty::field_idx(scx.fcx.ccx.tcx.sess,\n                                                 expr.span, field, fields);\n-                    if (ix >= vec::len[typeck::field](fields)) {\n+                    if (ix >= vec::len[ty::field](fields)) {\n                         scx.fcx.ccx.tcx.sess.span_err(expr.span,\n                                               \"bad index on record\");\n                     }\n@@ -2484,7 +2501,8 @@ fn check_expr(&@stmt_ctxt scx, &@ast::expr expr) {\n                 case (ty::ty_obj(?methods)) {\n                     let uint ix = ty::method_idx(scx.fcx.ccx.tcx.sess,\n                                                  expr.span, field, methods);\n-                    if (ix >= vec::len[typeck::method](methods)) {\n+\n+                    if (ix >= vec::len[ty::method](methods)) {\n                         scx.fcx.ccx.tcx.sess.span_err(expr.span,\n                                                   \"bad index on obj\");\n                     }\n@@ -2560,6 +2578,75 @@ fn check_expr(&@stmt_ctxt scx, &@ast::expr expr) {\n             }\n         }\n \n+        case (ast::expr_anon_obj(?anon_obj, ?tps, ?obj_def_ids, ?a)) {\n+            // TODO: We probably need to do more work here to be able to\n+            // handle additional methods that use 'self'\n+\n+            // We're entering an object, so gather up the info we need.\n+            let vec[ast::obj_field] fields = [];\n+            alt (anon_obj.fields) {\n+                case (none[vec[ast::obj_field]]) { }\n+                case (some[vec[ast::obj_field]](?v)) { fields = v; }\n+            }\n+            let ast::def_id di = obj_def_ids.ty;\n+\n+            vec::push[obj_info](scx.fcx.ccx.obj_infos,\n+                                rec(obj_fields=fields, this_obj=di));\n+\n+            // Typecheck 'with_obj', if it exists.\n+            let option::t[@ast::expr] with_obj = none[@ast::expr];\n+            alt (anon_obj.with_obj) {\n+                case (none[@ast::expr]) { }\n+                case (some[@ast::expr](?e)) {\n+                    // This had better have object type.  TOOD: report an\n+                    // error if the user is trying to extend a non-object\n+                    // with_obj.\n+                    check_expr(scx, e);\n+                }\n+            }\n+\n+            // Typecheck the methods.\n+            for (@ast::method method in anon_obj.methods) {\n+                check_method(scx.fcx.ccx, method);\n+            }\n+\n+            auto t = next_ty_var(scx);\n+\n+\n+            // FIXME: These next three functions are largely ripped off from\n+            // similar ones in collect::.  Is there a better way to do this?\n+\n+            fn ty_of_arg(@crate_ctxt ccx, &ast::arg a) -> ty::arg {\n+                auto ty_mode = ast_mode_to_mode(a.mode);\n+                ret rec(mode=ty_mode, ty=ast_ty_to_ty_crate(ccx, a.ty));\n+            }\n+\n+            fn ty_of_method(@crate_ctxt ccx, &@ast::method m) -> ty::method {\n+                auto convert = bind ast_ty_to_ty_crate(ccx, _);\n+                auto f = bind ty_of_arg(ccx, _);\n+                auto inputs = vec::map[ast::arg,arg](f,\n+                                                     m.node.meth.decl.inputs);\n+                auto output = convert(m.node.meth.decl.output);\n+                ret rec(proto=m.node.meth.proto, ident=m.node.ident,\n+                        inputs=inputs, output=output, cf=m.node.meth.decl.cf);\n+            }\n+\n+            fn get_anon_obj_method_types(@crate_ctxt ccx,\n+                                         &ast::anon_obj anon_obj)\n+                -> vec[ty::method] {\n+                ret vec::map[@ast::method,method](bind ty_of_method(ccx, _),\n+                                                  anon_obj.methods);\n+            }\n+\n+            auto methods = get_anon_obj_method_types(scx.fcx.ccx, anon_obj);\n+            auto ot = ty::mk_obj(scx.fcx.ccx.tcx,\n+                                 ty::sort_methods(methods));\n+            write::ty_only_fixup(scx, a.id, ot);\n+\n+            // Now remove the info from the stack.\n+            vec::pop[obj_info](scx.fcx.ccx.obj_infos);\n+        }\n+\n         case (_) {\n             scx.fcx.ccx.tcx.sess.unimpl(\"expr type in typeck::check_expr\");\n         }\n@@ -2757,7 +2844,6 @@ fn check_item(@crate_ctxt ccx, &@ast::item it) {\n     }\n }\n \n-\n // Utilities for the unification cache\n \n fn hash_unify_cache_entry(&unify_cache_entry uce) -> uint {"}, {"sha": "3580df7e3f97d89ab1117181e0e53c7a2f35fb47", "filename": "src/comp/middle/walk.rs", "status": "modified", "additions": 33, "deletions": 1, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/c3410bf927c863cd33057184e97e6a6169475059/src%2Fcomp%2Fmiddle%2Fwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3410bf927c863cd33057184e97e6a6169475059/src%2Fcomp%2Fmiddle%2Fwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fwalk.rs?ref=c3410bf927c863cd33057184e97e6a6169475059", "patch": "@@ -444,7 +444,39 @@ fn walk_expr(&ast_visitor v, @ast::expr e) {\n             walk_expr(v, x);\n         }\n \n-        case (ast::expr_anon_obj(_,_,_,_)) { }\n+        case (ast::expr_anon_obj(?anon_obj,_,_,_)) { \n+\n+            // Fields\n+            let option::t[vec[ast::obj_field]] fields \n+                = none[vec[ast::obj_field]];\n+\n+            alt (anon_obj.fields) {\n+                case (none[vec[ast::obj_field]]) { }\n+                case (some[vec[ast::obj_field]](?fields)) {\n+                    for (ast::obj_field f in fields) {\n+                        walk_ty(v, f.ty);\n+                    }\n+                }\n+            }\n+\n+            // with_obj\n+            let option::t[@ast::expr] with_obj = none[@ast::expr];\n+            alt (anon_obj.with_obj) {\n+                case (none[@ast::expr]) { }\n+                case (some[@ast::expr](?e)) {\n+                    walk_expr(v, e);\n+                }\n+            }\n+\n+            // Methods\n+            for (@ast::method m in anon_obj.methods) {\n+                v.visit_method_pre(m);\n+                walk_fn(v, m.node.meth, m.node.ident, \n+                        m.node.id, m.node.ann);\n+                v.visit_method_post(m);\n+\n+            }\n+        }\n     }\n     v.visit_expr_post(e);\n }"}, {"sha": "0f825c33934c64eb9cb691624f29944abf90d3c3", "filename": "src/comp/pretty/pprust.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c3410bf927c863cd33057184e97e6a6169475059/src%2Fcomp%2Fpretty%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3410bf927c863cd33057184e97e6a6169475059/src%2Fcomp%2Fpretty%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fpretty%2Fpprust.rs?ref=c3410bf927c863cd33057184e97e6a6169475059", "patch": "@@ -712,8 +712,8 @@ fn print_expr(ps s, &@ast::expr expr) {\n         }\n \n         case (ast::expr_anon_obj(_,_,_,_)) {\n-            wrd(s.s, \"obj\");\n-            // TODO\n+            wrd(s.s, \"anon obj\");\n+            // TODO: nicer pretty-printing of anon objs\n         }\n     }\n "}, {"sha": "135d12d243cf27fb07672107d1f9b1ca4df39af4", "filename": "src/test/run-pass/simple-anon-objs.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/c3410bf927c863cd33057184e97e6a6169475059/src%2Ftest%2Frun-pass%2Fsimple-anon-objs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3410bf927c863cd33057184e97e6a6169475059/src%2Ftest%2Frun-pass%2Fsimple-anon-objs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsimple-anon-objs.rs?ref=c3410bf927c863cd33057184e97e6a6169475059", "patch": "@@ -0,0 +1,29 @@\n+// xfail-stage0\n+// xfail-stage1\n+use std;\n+\n+fn main() {\n+\n+    obj a() {\n+        fn foo() -> int {\n+            ret 2;\n+        }\n+    }\n+\n+    auto my_a = a();\n+\n+    // Extending an object with a new method\n+    auto my_b = obj { \n+        fn bar() -> int { \n+            ret 3;\n+        } \n+        with my_a \n+    };\n+\n+    assert my_a.foo() == 2;\n+\n+    // FIXME: these raise a runtime error\n+    //assert my_b.foo() == 2;\n+    assert my_b.bar() == 3;\n+\n+}"}]}