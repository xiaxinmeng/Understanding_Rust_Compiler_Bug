{"sha": "ef119d704d87a05435ea97ef4161529142313a9b", "node_id": "C_kwDOAAsO6NoAKGVmMTE5ZDcwNGQ4N2EwNTQzNWVhOTdlZjQxNjE1MjkxNDIzMTNhOWI", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-01-24T08:05:37Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-01-24T08:05:37Z"}, "message": "Auto merge of #93028 - compiler-errors:const_drop_bounds, r=fee1-dead\n\nCheck `const Drop` impls considering `~const` Bounds\n\n This PR adds logic to trait selection to account for `~const` bounds in custom `impl const Drop` for types, elaborates the `const Drop` check in `rustc_const_eval` to check those bounds, and steals some drop linting fixes from #92922, thanks `@DrMeepster.`\n\nr? `@fee1-dead` `@oli-obk` <sup>(edit: guess I can't request review from two people, lol)</sup>\nsince each of you wrote and reviewed #88558, respectively.\n\nSince the logic here is more complicated than what existed, it's possible that this is a perf regression. But it works correctly with tests, and that makes me happy.\n\nFixes #92881", "tree": {"sha": "79f04c5b12b95c3b6bab52e108640bf8d131e12b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/79f04c5b12b95c3b6bab52e108640bf8d131e12b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ef119d704d87a05435ea97ef4161529142313a9b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ef119d704d87a05435ea97ef4161529142313a9b", "html_url": "https://github.com/rust-lang/rust/commit/ef119d704d87a05435ea97ef4161529142313a9b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ef119d704d87a05435ea97ef4161529142313a9b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "42313dd29b3edb0ab453a0d43d12876ec7e48ce0", "url": "https://api.github.com/repos/rust-lang/rust/commits/42313dd29b3edb0ab453a0d43d12876ec7e48ce0", "html_url": "https://github.com/rust-lang/rust/commit/42313dd29b3edb0ab453a0d43d12876ec7e48ce0"}, {"sha": "b7e443397471062e5681ecefb6638577cefb9571", "url": "https://api.github.com/repos/rust-lang/rust/commits/b7e443397471062e5681ecefb6638577cefb9571", "html_url": "https://github.com/rust-lang/rust/commit/b7e443397471062e5681ecefb6638577cefb9571"}], "stats": {"total": 616, "additions": 378, "deletions": 238}, "files": [{"sha": "91610b15eb9998d022dea2fd34fb886a564c7a21", "filename": "compiler/rustc_const_eval/src/transform/check_consts/qualifs.rs", "status": "modified", "additions": 39, "deletions": 21, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/ef119d704d87a05435ea97ef4161529142313a9b/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef119d704d87a05435ea97ef4161529142313a9b/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fqualifs.rs?ref=ef119d704d87a05435ea97ef4161529142313a9b", "patch": "@@ -4,11 +4,12 @@\n \n use rustc_errors::ErrorReported;\n use rustc_infer::infer::TyCtxtInferExt;\n+use rustc_infer::traits::TraitEngine;\n use rustc_middle::mir::*;\n use rustc_middle::ty::{self, subst::SubstsRef, AdtDef, Ty};\n use rustc_span::DUMMY_SP;\n use rustc_trait_selection::traits::{\n-    self, ImplSource, Obligation, ObligationCause, SelectionContext,\n+    self, FulfillmentContext, ImplSource, Obligation, ObligationCause, SelectionContext,\n };\n \n use super::ConstCx;\n@@ -145,44 +146,61 @@ impl Qualif for NeedsNonConstDrop {\n         qualifs.needs_non_const_drop\n     }\n \n-    fn in_any_value_of_ty<'tcx>(cx: &ConstCx<'_, 'tcx>, mut ty: Ty<'tcx>) -> bool {\n-        // Avoid selecting for simple cases.\n-        match ty::util::needs_drop_components(ty, &cx.tcx.data_layout).as_deref() {\n-            Ok([]) => return false,\n-            Err(ty::util::AlwaysRequiresDrop) => return true,\n-            // If we've got a single component, select with that\n-            // to increase the chance that we hit the selection cache.\n-            Ok([t]) => ty = t,\n-            Ok([..]) => {}\n+    fn in_any_value_of_ty<'tcx>(cx: &ConstCx<'_, 'tcx>, ty: Ty<'tcx>) -> bool {\n+        // Avoid selecting for simple cases, such as builtin types.\n+        if ty::util::is_trivially_const_drop(ty) {\n+            return false;\n         }\n \n         let Some(drop_trait) = cx.tcx.lang_items().drop_trait() else {\n             // there is no way to define a type that needs non-const drop\n             // without having the lang item present.\n             return false;\n         };\n-        let trait_ref =\n-            ty::TraitRef { def_id: drop_trait, substs: cx.tcx.mk_substs_trait(ty, &[]) };\n+\n         let obligation = Obligation::new(\n             ObligationCause::dummy(),\n             cx.param_env,\n             ty::Binder::dummy(ty::TraitPredicate {\n-                trait_ref,\n+                trait_ref: ty::TraitRef {\n+                    def_id: drop_trait,\n+                    substs: cx.tcx.mk_substs_trait(ty, &[]),\n+                },\n                 constness: ty::BoundConstness::ConstIfConst,\n                 polarity: ty::ImplPolarity::Positive,\n             }),\n         );\n \n-        let implsrc = cx.tcx.infer_ctxt().enter(|infcx| {\n+        cx.tcx.infer_ctxt().enter(|infcx| {\n             let mut selcx = SelectionContext::new(&infcx);\n-            selcx.select(&obligation)\n-        });\n-        !matches!(\n-            implsrc,\n-            Ok(Some(\n+            let Some(impl_src) = selcx.select(&obligation).ok().flatten() else {\n+                // If we couldn't select a const drop candidate, then it's bad\n+                return true;\n+            };\n+\n+            if !matches!(\n+                impl_src,\n                 ImplSource::ConstDrop(_) | ImplSource::Param(_, ty::BoundConstness::ConstIfConst)\n-            ))\n-        )\n+            ) {\n+                // If our const drop candidate is not ConstDrop or implied by the param env,\n+                // then it's bad\n+                return true;\n+            }\n+\n+            if impl_src.borrow_nested_obligations().is_empty() {\n+                return false;\n+            }\n+\n+            // If we successfully found one, then select all of the predicates\n+            // implied by our const drop impl.\n+            let mut fcx = FulfillmentContext::new();\n+            for nested in impl_src.nested_obligations() {\n+                fcx.register_predicate_obligation(&infcx, nested);\n+            }\n+\n+            // If we had any errors, then it's bad\n+            !fcx.select_all_or_error(&infcx).is_empty()\n+        })\n     }\n \n     fn in_adt_inherently<'tcx>("}, {"sha": "b7ccfac8063d7742a8f45742583c94a97b3f69b2", "filename": "compiler/rustc_middle/src/traits/mod.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ef119d704d87a05435ea97ef4161529142313a9b/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef119d704d87a05435ea97ef4161529142313a9b/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs?ref=ef119d704d87a05435ea97ef4161529142313a9b", "patch": "@@ -566,7 +566,7 @@ pub enum ImplSource<'tcx, N> {\n     TraitAlias(ImplSourceTraitAliasData<'tcx, N>),\n \n     /// ImplSource for a `const Drop` implementation.\n-    ConstDrop(ImplSourceConstDropData),\n+    ConstDrop(ImplSourceConstDropData<N>),\n }\n \n impl<'tcx, N> ImplSource<'tcx, N> {\n@@ -581,10 +581,10 @@ impl<'tcx, N> ImplSource<'tcx, N> {\n             ImplSource::Object(d) => d.nested,\n             ImplSource::FnPointer(d) => d.nested,\n             ImplSource::DiscriminantKind(ImplSourceDiscriminantKindData)\n-            | ImplSource::Pointee(ImplSourcePointeeData)\n-            | ImplSource::ConstDrop(ImplSourceConstDropData) => Vec::new(),\n+            | ImplSource::Pointee(ImplSourcePointeeData) => Vec::new(),\n             ImplSource::TraitAlias(d) => d.nested,\n             ImplSource::TraitUpcasting(d) => d.nested,\n+            ImplSource::ConstDrop(i) => i.nested,\n         }\n     }\n \n@@ -599,10 +599,10 @@ impl<'tcx, N> ImplSource<'tcx, N> {\n             ImplSource::Object(d) => &d.nested,\n             ImplSource::FnPointer(d) => &d.nested,\n             ImplSource::DiscriminantKind(ImplSourceDiscriminantKindData)\n-            | ImplSource::Pointee(ImplSourcePointeeData)\n-            | ImplSource::ConstDrop(ImplSourceConstDropData) => &[],\n+            | ImplSource::Pointee(ImplSourcePointeeData) => &[],\n             ImplSource::TraitAlias(d) => &d.nested,\n             ImplSource::TraitUpcasting(d) => &d.nested,\n+            ImplSource::ConstDrop(i) => &i.nested,\n         }\n     }\n \n@@ -661,9 +661,9 @@ impl<'tcx, N> ImplSource<'tcx, N> {\n                     nested: d.nested.into_iter().map(f).collect(),\n                 })\n             }\n-            ImplSource::ConstDrop(ImplSourceConstDropData) => {\n-                ImplSource::ConstDrop(ImplSourceConstDropData)\n-            }\n+            ImplSource::ConstDrop(i) => ImplSource::ConstDrop(ImplSourceConstDropData {\n+                nested: i.nested.into_iter().map(f).collect(),\n+            }),\n         }\n     }\n }\n@@ -755,8 +755,10 @@ pub struct ImplSourceDiscriminantKindData;\n #[derive(Clone, Debug, PartialEq, Eq, TyEncodable, TyDecodable, HashStable)]\n pub struct ImplSourcePointeeData;\n \n-#[derive(Clone, Debug, PartialEq, Eq, TyEncodable, TyDecodable, HashStable)]\n-pub struct ImplSourceConstDropData;\n+#[derive(Clone, PartialEq, Eq, TyEncodable, TyDecodable, HashStable, TypeFoldable, Lift)]\n+pub struct ImplSourceConstDropData<N> {\n+    pub nested: Vec<N>,\n+}\n \n #[derive(Clone, PartialEq, Eq, TyEncodable, TyDecodable, HashStable, TypeFoldable, Lift)]\n pub struct ImplSourceTraitAliasData<'tcx, N> {"}, {"sha": "e18f04d92eec49d500a198f817dcab666a743611", "filename": "compiler/rustc_middle/src/traits/select.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ef119d704d87a05435ea97ef4161529142313a9b/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef119d704d87a05435ea97ef4161529142313a9b/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fselect.rs?ref=ef119d704d87a05435ea97ef4161529142313a9b", "patch": "@@ -146,8 +146,8 @@ pub enum SelectionCandidate<'tcx> {\n \n     BuiltinUnsizeCandidate,\n \n-    /// Implementation of `const Drop`.\n-    ConstDropCandidate,\n+    /// Implementation of `const Drop`, optionally from a custom `impl const Drop`.\n+    ConstDropCandidate(Option<DefId>),\n }\n \n /// The result of trait evaluation. The order is important"}, {"sha": "6ce9f5eea349125d8b0423cc6486f6c454e97281", "filename": "compiler/rustc_middle/src/traits/structural_impls.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ef119d704d87a05435ea97ef4161529142313a9b/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef119d704d87a05435ea97ef4161529142313a9b/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fstructural_impls.rs?ref=ef119d704d87a05435ea97ef4161529142313a9b", "patch": "@@ -120,12 +120,17 @@ impl<'tcx, N: fmt::Debug> fmt::Debug for traits::ImplSourceTraitAliasData<'tcx,\n     }\n }\n \n+impl<N: fmt::Debug> fmt::Debug for traits::ImplSourceConstDropData<N> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"ImplSourceConstDropData(nested={:?})\", self.nested)\n+    }\n+}\n+\n ///////////////////////////////////////////////////////////////////////////\n // Lift implementations\n \n TrivialTypeFoldableAndLiftImpls! {\n     super::IfExpressionCause,\n     super::ImplSourceDiscriminantKindData,\n     super::ImplSourcePointeeData,\n-    super::ImplSourceConstDropData,\n }"}, {"sha": "96c27d649e4d1ee9e5170771af50e24ed169cb90", "filename": "compiler/rustc_middle/src/ty/util.rs", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/ef119d704d87a05435ea97ef4161529142313a9b/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef119d704d87a05435ea97ef4161529142313a9b/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs?ref=ef119d704d87a05435ea97ef4161529142313a9b", "patch": "@@ -1041,6 +1041,42 @@ pub fn needs_drop_components<'tcx>(\n     }\n }\n \n+pub fn is_trivially_const_drop<'tcx>(ty: Ty<'tcx>) -> bool {\n+    match *ty.kind() {\n+        ty::Bool\n+        | ty::Char\n+        | ty::Int(_)\n+        | ty::Uint(_)\n+        | ty::Float(_)\n+        | ty::Infer(ty::IntVar(_))\n+        | ty::Infer(ty::FloatVar(_))\n+        | ty::Str\n+        | ty::RawPtr(_)\n+        | ty::Ref(..)\n+        | ty::FnDef(..)\n+        | ty::FnPtr(_)\n+        | ty::Never\n+        | ty::Foreign(_) => true,\n+\n+        ty::Opaque(..)\n+        | ty::Dynamic(..)\n+        | ty::Error(_)\n+        | ty::Bound(..)\n+        | ty::Param(_)\n+        | ty::Placeholder(_)\n+        | ty::Projection(_)\n+        | ty::Infer(_) => false,\n+\n+        // Not trivial because they have components, and instead of looking inside,\n+        // we'll just perform trait selection.\n+        ty::Closure(..) | ty::Generator(..) | ty::GeneratorWitness(_) | ty::Adt(..) => false,\n+\n+        ty::Array(ty, _) | ty::Slice(ty) => is_trivially_const_drop(ty),\n+\n+        ty::Tuple(tys) => tys.iter().all(|ty| is_trivially_const_drop(ty.expect_ty())),\n+    }\n+}\n+\n // Does the equivalent of\n // ```\n // let v = self.iter().map(|p| p.fold_with(folder)).collect::<SmallVec<[_; 8]>>();"}, {"sha": "0099fba92004245912974c0974b5ac2002dc51c6", "filename": "compiler/rustc_trait_selection/src/traits/select/candidate_assembly.rs", "status": "modified", "additions": 62, "deletions": 130, "changes": 192, "blob_url": "https://github.com/rust-lang/rust/blob/ef119d704d87a05435ea97ef4161529142313a9b/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef119d704d87a05435ea97ef4161529142313a9b/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs?ref=ef119d704d87a05435ea97ef4161529142313a9b", "patch": "@@ -307,13 +307,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             } else if lang_items.drop_trait() == Some(def_id)\n                 && obligation.predicate.skip_binder().constness == ty::BoundConstness::ConstIfConst\n             {\n-                if obligation.param_env.constness() == hir::Constness::Const {\n-                    self.assemble_const_drop_candidates(obligation, stack, &mut candidates)?;\n-                } else {\n-                    debug!(\"passing ~const Drop bound; in non-const context\");\n-                    // `~const Drop` when we are not in a const context has no effect.\n-                    candidates.vec.push(ConstDropCandidate)\n-                }\n+                self.assemble_const_drop_candidates(obligation, &mut candidates);\n             } else {\n                 if lang_items.clone_trait() == Some(def_id) {\n                     // Same builtin conditions as `Copy`, i.e., every type which has builtin support\n@@ -918,139 +912,77 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         }\n     }\n \n-    fn assemble_const_drop_candidates<'a>(\n+    fn assemble_const_drop_candidates(\n         &mut self,\n         obligation: &TraitObligation<'tcx>,\n-        obligation_stack: &TraitObligationStack<'a, 'tcx>,\n         candidates: &mut SelectionCandidateSet<'tcx>,\n-    ) -> Result<(), SelectionError<'tcx>> {\n-        let mut stack: Vec<(Ty<'tcx>, usize)> = vec![(obligation.self_ty().skip_binder(), 0)];\n-\n-        while let Some((ty, depth)) = stack.pop() {\n-            let mut noreturn = false;\n-\n-            self.check_recursion_depth(depth, obligation)?;\n-            let mut new_candidates = SelectionCandidateSet { vec: Vec::new(), ambiguous: false };\n-            let mut copy_obligation =\n-                obligation.with(obligation.predicate.rebind(ty::TraitPredicate {\n-                    trait_ref: ty::TraitRef {\n-                        def_id: self.tcx().require_lang_item(hir::LangItem::Copy, None),\n-                        substs: self.tcx().mk_substs_trait(ty, &[]),\n-                    },\n-                    constness: ty::BoundConstness::NotConst,\n-                    polarity: ty::ImplPolarity::Positive,\n-                }));\n-            copy_obligation.recursion_depth = depth + 1;\n-            self.assemble_candidates_from_impls(&copy_obligation, &mut new_candidates);\n-            let copy_conditions = self.copy_clone_conditions(&copy_obligation);\n-            self.assemble_builtin_bound_candidates(copy_conditions, &mut new_candidates);\n-            let copy_stack = self.push_stack(obligation_stack.list(), &copy_obligation);\n-            self.assemble_candidates_from_caller_bounds(&copy_stack, &mut new_candidates)?;\n-\n-            let const_drop_obligation =\n-                obligation.with(obligation.predicate.rebind(ty::TraitPredicate {\n-                    trait_ref: ty::TraitRef {\n-                        def_id: self.tcx().require_lang_item(hir::LangItem::Drop, None),\n-                        substs: self.tcx().mk_substs_trait(ty, &[]),\n-                    },\n-                    constness: ty::BoundConstness::ConstIfConst,\n-                    polarity: ty::ImplPolarity::Positive,\n-                }));\n-\n-            let const_drop_stack = self.push_stack(obligation_stack.list(), &const_drop_obligation);\n-            self.assemble_candidates_from_caller_bounds(&const_drop_stack, &mut new_candidates)?;\n-\n-            if !new_candidates.vec.is_empty() {\n-                noreturn = true;\n-            }\n-            debug!(?new_candidates.vec, \"assemble_const_drop_candidates\");\n-\n-            match ty.kind() {\n-                ty::Int(_)\n-                | ty::Uint(_)\n-                | ty::Float(_)\n-                | ty::Infer(ty::IntVar(_))\n-                | ty::Infer(ty::FloatVar(_))\n-                | ty::FnPtr(_)\n-                | ty::Never\n-                | ty::Ref(..)\n-                | ty::FnDef(..)\n-                | ty::RawPtr(_)\n-                | ty::Bool\n-                | ty::Char\n-                | ty::Str\n-                | ty::Foreign(_) => {} // Do nothing. These types satisfy `const Drop`.\n-\n-                ty::Adt(def, subst) => {\n-                    let mut set = SelectionCandidateSet { vec: Vec::new(), ambiguous: false };\n-                    self.assemble_candidates_from_impls(\n-                        &obligation.with(obligation.predicate.map_bound(|mut pred| {\n-                            pred.trait_ref.substs = self.tcx().mk_substs_trait(ty, &[]);\n-                            pred\n-                        })),\n-                        &mut set,\n-                    );\n-                    stack.extend(def.all_fields().map(|f| (f.ty(self.tcx(), subst), depth + 1)));\n-\n-                    debug!(?set.vec, \"assemble_const_drop_candidates - ty::Adt\");\n-                    if set.vec.into_iter().any(|candidate| {\n-                        if let SelectionCandidate::ImplCandidate(did) = candidate {\n-                            matches!(self.tcx().impl_constness(did), hir::Constness::NotConst)\n-                        } else {\n-                            false\n-                        }\n-                    }) {\n-                        if !noreturn {\n-                            // has non-const Drop\n-                            return Ok(());\n-                        }\n-                        debug!(\"not returning\");\n-                    }\n-                }\n-\n-                ty::Array(ty, _) => stack.push((ty, depth + 1)),\n-\n-                ty::Tuple(_) => stack.extend(ty.tuple_fields().map(|t| (t, depth + 1))),\n+    ) {\n+        // If the predicate is `~const Drop` in a non-const environment, we don't actually need\n+        // to check anything. We'll short-circuit checking any obligations in confirmation, too.\n+        if obligation.param_env.constness() == hir::Constness::NotConst {\n+            candidates.vec.push(ConstDropCandidate(None));\n+            return;\n+        }\n \n-                ty::Closure(_, substs) => {\n-                    let substs = substs.as_closure();\n-                    let ty = self.infcx.shallow_resolve(substs.tupled_upvars_ty());\n-                    stack.push((ty, depth + 1));\n-                }\n+        let self_ty = self.infcx().shallow_resolve(obligation.self_ty());\n+        match self_ty.skip_binder().kind() {\n+            ty::Opaque(..)\n+            | ty::Dynamic(..)\n+            | ty::Error(_)\n+            | ty::Bound(..)\n+            | ty::Param(_)\n+            | ty::Placeholder(_)\n+            | ty::Projection(_) => {\n+                // We don't know if these are `~const Drop`, at least\n+                // not structurally... so don't push a candidate.\n+            }\n \n-                ty::Generator(_, substs, _) => {\n-                    let substs = substs.as_generator();\n-                    let ty = self.infcx.shallow_resolve(substs.tupled_upvars_ty());\n+            ty::Bool\n+            | ty::Char\n+            | ty::Int(_)\n+            | ty::Uint(_)\n+            | ty::Float(_)\n+            | ty::Infer(ty::IntVar(_))\n+            | ty::Infer(ty::FloatVar(_))\n+            | ty::Str\n+            | ty::RawPtr(_)\n+            | ty::Ref(..)\n+            | ty::FnDef(..)\n+            | ty::FnPtr(_)\n+            | ty::Never\n+            | ty::Foreign(_)\n+            | ty::Array(..)\n+            | ty::Slice(_)\n+            | ty::Closure(..)\n+            | ty::Generator(..)\n+            | ty::Tuple(_)\n+            | ty::GeneratorWitness(_) => {\n+                // These are built-in, and cannot have a custom `impl const Drop`.\n+                candidates.vec.push(ConstDropCandidate(None));\n+            }\n \n-                    stack.push((ty, depth + 1));\n-                    stack.push((substs.witness(), depth + 1));\n-                }\n+            ty::Adt(..) => {\n+                // Find a custom `impl Drop` impl, if it exists\n+                let relevant_impl = self.tcx().find_map_relevant_impl(\n+                    obligation.predicate.def_id(),\n+                    obligation.predicate.skip_binder().trait_ref.self_ty(),\n+                    Some,\n+                );\n \n-                ty::GeneratorWitness(tys) => stack.extend(\n-                    self.tcx().erase_late_bound_regions(*tys).iter().map(|t| (t, depth + 1)),\n-                ),\n-\n-                ty::Slice(ty) => stack.push((ty, depth + 1)),\n-\n-                ty::Opaque(..)\n-                | ty::Dynamic(..)\n-                | ty::Error(_)\n-                | ty::Bound(..)\n-                | ty::Infer(_)\n-                | ty::Placeholder(_)\n-                | ty::Projection(..)\n-                | ty::Param(..) => {\n-                    if !noreturn {\n-                        return Ok(());\n+                if let Some(impl_def_id) = relevant_impl {\n+                    // Check that `impl Drop` is actually const, if there is a custom impl\n+                    if self.tcx().impl_constness(impl_def_id) == hir::Constness::Const {\n+                        candidates.vec.push(ConstDropCandidate(Some(impl_def_id)));\n                     }\n-                    debug!(\"not returning\");\n+                } else {\n+                    // Otherwise check the ADT like a built-in type (structurally)\n+                    candidates.vec.push(ConstDropCandidate(None));\n                 }\n             }\n-            debug!(?stack, \"assemble_const_drop_candidates - in loop\");\n-        }\n-        // all types have passed.\n-        candidates.vec.push(ConstDropCandidate);\n \n-        Ok(())\n+            ty::Infer(_) => {\n+                candidates.ambiguous = true;\n+            }\n+        }\n     }\n }"}, {"sha": "3b6a4afafcfd14935252611b8e70f538f903cda0", "filename": "compiler/rustc_trait_selection/src/traits/select/confirmation.rs", "status": "modified", "additions": 128, "deletions": 2, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/ef119d704d87a05435ea97ef4161529142313a9b/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef119d704d87a05435ea97ef4161529142313a9b/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs?ref=ef119d704d87a05435ea97ef4161529142313a9b", "patch": "@@ -80,7 +80,6 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 param_env: obligation.param_env.without_const(),\n                 ..*obligation\n             };\n-\n             obligation = &new_obligation;\n         }\n \n@@ -159,7 +158,10 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 Ok(ImplSource::TraitUpcasting(data))\n             }\n \n-            ConstDropCandidate => Ok(ImplSource::ConstDrop(ImplSourceConstDropData)),\n+            ConstDropCandidate(def_id) => {\n+                let data = self.confirm_const_drop_candidate(obligation, def_id)?;\n+                Ok(ImplSource::ConstDrop(data))\n+            }\n         }\n     }\n \n@@ -1087,4 +1089,128 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         Ok(ImplSourceBuiltinData { nested })\n     }\n+\n+    fn confirm_const_drop_candidate(\n+        &mut self,\n+        obligation: &TraitObligation<'tcx>,\n+        impl_def_id: Option<DefId>,\n+    ) -> Result<ImplSourceConstDropData<PredicateObligation<'tcx>>, SelectionError<'tcx>> {\n+        // `~const Drop` in a non-const environment is always trivially true, since our type is `Drop`\n+        if obligation.param_env.constness() == Constness::NotConst {\n+            return Ok(ImplSourceConstDropData { nested: vec![] });\n+        }\n+\n+        let tcx = self.tcx();\n+        let self_ty = self.infcx.shallow_resolve(obligation.self_ty());\n+\n+        let mut nested = vec![];\n+        let cause = obligation.derived_cause(BuiltinDerivedObligation);\n+\n+        // If we have a custom `impl const Drop`, then\n+        // first check it like a regular impl candidate\n+        if let Some(impl_def_id) = impl_def_id {\n+            nested.extend(self.confirm_impl_candidate(obligation, impl_def_id).nested);\n+        }\n+\n+        // We want to confirm the ADT's fields if we have an ADT\n+        let mut stack = match *self_ty.skip_binder().kind() {\n+            ty::Adt(def, substs) => def.all_fields().map(|f| f.ty(tcx, substs)).collect(),\n+            _ => vec![self_ty.skip_binder()],\n+        };\n+\n+        while let Some(nested_ty) = stack.pop() {\n+            match *nested_ty.kind() {\n+                // We know these types are trivially drop\n+                ty::Bool\n+                | ty::Char\n+                | ty::Int(_)\n+                | ty::Uint(_)\n+                | ty::Float(_)\n+                | ty::Infer(ty::IntVar(_))\n+                | ty::Infer(ty::FloatVar(_))\n+                | ty::Str\n+                | ty::RawPtr(_)\n+                | ty::Ref(..)\n+                | ty::FnDef(..)\n+                | ty::FnPtr(_)\n+                | ty::Never\n+                | ty::Foreign(_) => {}\n+\n+                // These types are built-in, so we can fast-track by registering\n+                // nested predicates for their constituient type(s)\n+                ty::Array(ty, _) | ty::Slice(ty) => {\n+                    stack.push(ty);\n+                }\n+                ty::Tuple(tys) => {\n+                    stack.extend(tys.iter().map(|ty| ty.expect_ty()));\n+                }\n+                ty::Closure(_, substs) => {\n+                    stack.push(substs.as_closure().tupled_upvars_ty());\n+                }\n+                ty::Generator(_, substs, _) => {\n+                    let generator = substs.as_generator();\n+                    stack.extend([generator.tupled_upvars_ty(), generator.witness()]);\n+                }\n+                ty::GeneratorWitness(tys) => {\n+                    stack.extend(tcx.erase_late_bound_regions(tys).to_vec());\n+                }\n+\n+                // If we have a projection type, make sure to normalize it so we replace it\n+                // with a fresh infer variable\n+                ty::Projection(..) => {\n+                    self.infcx.commit_unconditionally(|_| {\n+                        let predicate = normalize_with_depth_to(\n+                            self,\n+                            obligation.param_env,\n+                            cause.clone(),\n+                            obligation.recursion_depth + 1,\n+                            self_ty\n+                                .rebind(ty::TraitPredicate {\n+                                    trait_ref: ty::TraitRef {\n+                                        def_id: self.tcx().require_lang_item(LangItem::Drop, None),\n+                                        substs: self.tcx().mk_substs_trait(nested_ty, &[]),\n+                                    },\n+                                    constness: ty::BoundConstness::ConstIfConst,\n+                                    polarity: ty::ImplPolarity::Positive,\n+                                })\n+                                .to_predicate(tcx),\n+                            &mut nested,\n+                        );\n+\n+                        nested.push(Obligation::with_depth(\n+                            cause.clone(),\n+                            obligation.recursion_depth + 1,\n+                            obligation.param_env,\n+                            predicate,\n+                        ));\n+                    });\n+                }\n+\n+                // If we have any other type (e.g. an ADT), just register a nested obligation\n+                // since it's either not `const Drop` (and we raise an error during selection),\n+                // or it's an ADT (and we need to check for a custom impl during selection)\n+                _ => {\n+                    let predicate = self_ty\n+                        .rebind(ty::TraitPredicate {\n+                            trait_ref: ty::TraitRef {\n+                                def_id: self.tcx().require_lang_item(LangItem::Drop, None),\n+                                substs: self.tcx().mk_substs_trait(nested_ty, &[]),\n+                            },\n+                            constness: ty::BoundConstness::ConstIfConst,\n+                            polarity: ty::ImplPolarity::Positive,\n+                        })\n+                        .to_predicate(tcx);\n+\n+                    nested.push(Obligation::with_depth(\n+                        cause.clone(),\n+                        obligation.recursion_depth + 1,\n+                        obligation.param_env,\n+                        predicate,\n+                    ));\n+                }\n+            }\n+        }\n+\n+        Ok(ImplSourceConstDropData { nested })\n+    }\n }"}, {"sha": "558ecd393b614319bdadc26cd0c64f001a46b2fb", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ef119d704d87a05435ea97ef4161529142313a9b/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef119d704d87a05435ea97ef4161529142313a9b/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=ef119d704d87a05435ea97ef4161529142313a9b", "patch": "@@ -1153,7 +1153,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     GeneratorCandidate => {}\n                     // FnDef where the function is const\n                     FnPointerCandidate { is_const: true } => {}\n-                    ConstDropCandidate => {}\n+                    ConstDropCandidate(_) => {}\n                     _ => {\n                         // reject all other types of candidates\n                         continue;\n@@ -1537,7 +1537,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         };\n \n         // (*) Prefer `BuiltinCandidate { has_nested: false }`, `PointeeCandidate`,\n-        // and `DiscriminantKindCandidate` to anything else.\n+        // `DiscriminantKindCandidate`, and `ConstDropCandidate` to anything else.\n         //\n         // This is a fix for #53123 and prevents winnowing from accidentally extending the\n         // lifetime of a variable.\n@@ -1554,15 +1554,15 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 BuiltinCandidate { has_nested: false }\n                 | DiscriminantKindCandidate\n                 | PointeeCandidate\n-                | ConstDropCandidate,\n+                | ConstDropCandidate(_),\n                 _,\n             ) => true,\n             (\n                 _,\n                 BuiltinCandidate { has_nested: false }\n                 | DiscriminantKindCandidate\n                 | PointeeCandidate\n-                | ConstDropCandidate,\n+                | ConstDropCandidate(_),\n             ) => false,\n \n             (ParamCandidate(other), ParamCandidate(victim)) => {"}, {"sha": "89866c20b61d6ee1b17d0adc5aa3eefcb3ec95c2", "filename": "compiler/rustc_typeck/src/check/dropck.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ef119d704d87a05435ea97ef4161529142313a9b/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef119d704d87a05435ea97ef4161529142313a9b/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdropck.rs?ref=ef119d704d87a05435ea97ef4161529142313a9b", "patch": "@@ -229,7 +229,13 @@ fn ensure_drop_predicates_are_implied_by_item_defn<'tcx>(\n             let p = p.kind();\n             match (predicate.skip_binder(), p.skip_binder()) {\n                 (ty::PredicateKind::Trait(a), ty::PredicateKind::Trait(b)) => {\n-                    relator.relate(predicate.rebind(a), p.rebind(b)).is_ok()\n+                    // Since struct predicates cannot have ~const, project the impl predicate\n+                    // onto one that ignores the constness. This is equivalent to saying that\n+                    // we match a `Trait` bound on the struct with a `Trait` or `~const Trait`\n+                    // in the impl.\n+                    let non_const_a =\n+                        ty::TraitPredicate { constness: ty::BoundConstness::NotConst, ..a };\n+                    relator.relate(predicate.rebind(non_const_a), p.rebind(b)).is_ok()\n                 }\n                 (ty::PredicateKind::Projection(a), ty::PredicateKind::Projection(b)) => {\n                     relator.relate(predicate.rebind(a), p.rebind(b)).is_ok()"}, {"sha": "721636e074371e3d2c1798ba0ab2820ff5e0ff84", "filename": "src/test/ui/rfc-2632-const-trait-impl/const-drop-fail.precise.stderr", "status": "modified", "additions": 25, "deletions": 32, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/ef119d704d87a05435ea97ef4161529142313a9b/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-drop-fail.precise.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ef119d704d87a05435ea97ef4161529142313a9b/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-drop-fail.precise.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-drop-fail.precise.stderr?ref=ef119d704d87a05435ea97ef4161529142313a9b", "patch": "@@ -1,13 +1,5 @@\n-error: `~const` is not allowed here\n-  --> $DIR/const-drop-fail.rs:27:35\n-   |\n-LL | struct ConstDropImplWithBounds<T: ~const A>(PhantomData<T>);\n-   |                                   ^^^^^^^^\n-   |\n-   = note: only allowed on bounds on traits' associated types and functions, const fns, const impls and its associated functions\n-\n error[E0277]: the trait bound `NonTrivialDrop: Drop` is not satisfied\n-  --> $DIR/const-drop-fail.rs:45:5\n+  --> $DIR/const-drop-fail.rs:44:5\n    |\n LL |         const _: () = check($exp);\n    |                       ----- required by a bound introduced by this call\n@@ -16,50 +8,51 @@ LL |     NonTrivialDrop,\n    |     ^^^^^^^^^^^^^^ the trait `Drop` is not implemented for `NonTrivialDrop`\n    |\n note: required by a bound in `check`\n-  --> $DIR/const-drop-fail.rs:36:19\n+  --> $DIR/const-drop-fail.rs:35:19\n    |\n LL | const fn check<T: ~const Drop>(_: T) {}\n    |                   ^^^^^^^^^^^ required by this bound in `check`\n \n-error[E0277]: the trait bound `ConstImplWithDropGlue: Drop` is not satisfied\n-  --> $DIR/const-drop-fail.rs:47:5\n+error[E0277]: the trait bound `NonTrivialDrop: Drop` is not satisfied in `ConstImplWithDropGlue`\n+  --> $DIR/const-drop-fail.rs:46:5\n    |\n LL |         const _: () = check($exp);\n    |                       ----- required by a bound introduced by this call\n ...\n LL |     ConstImplWithDropGlue(NonTrivialDrop),\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Drop` is not implemented for `ConstImplWithDropGlue`\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ within `ConstImplWithDropGlue`, the trait `Drop` is not implemented for `NonTrivialDrop`\n    |\n+note: required because it appears within the type `ConstImplWithDropGlue`\n+  --> $DIR/const-drop-fail.rs:17:8\n+   |\n+LL | struct ConstImplWithDropGlue(NonTrivialDrop);\n+   |        ^^^^^^^^^^^^^^^^^^^^^\n note: required by a bound in `check`\n-  --> $DIR/const-drop-fail.rs:36:19\n+  --> $DIR/const-drop-fail.rs:35:19\n    |\n LL | const fn check<T: ~const Drop>(_: T) {}\n    |                   ^^^^^^^^^^^ required by this bound in `check`\n \n error[E0277]: the trait bound `NonTrivialDrop: A` is not satisfied\n-  --> $DIR/const-drop-fail.rs:49:5\n-   |\n-LL |     ConstDropImplWithBounds::<NonTrivialDrop>(PhantomData),\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `A` is not implemented for `NonTrivialDrop`\n-   |\n-note: required by a bound in `ConstDropImplWithBounds`\n-  --> $DIR/const-drop-fail.rs:27:35\n-   |\n-LL | struct ConstDropImplWithBounds<T: ~const A>(PhantomData<T>);\n-   |                                   ^^^^^^^^ required by this bound in `ConstDropImplWithBounds`\n-\n-error[E0277]: the trait bound `NonTrivialDrop: A` is not satisfied\n-  --> $DIR/const-drop-fail.rs:49:5\n+  --> $DIR/const-drop-fail.rs:48:5\n    |\n+LL |         const _: () = check($exp);\n+   |                       ----- required by a bound introduced by this call\n+...\n LL |     ConstDropImplWithBounds::<NonTrivialDrop>(PhantomData),\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `A` is not implemented for `NonTrivialDrop`\n    |\n-note: required by a bound in `ConstDropImplWithBounds`\n-  --> $DIR/const-drop-fail.rs:27:35\n+note: required because of the requirements on the impl of `Drop` for `ConstDropImplWithBounds<NonTrivialDrop>`\n+  --> $DIR/const-drop-fail.rs:29:25\n    |\n-LL | struct ConstDropImplWithBounds<T: ~const A>(PhantomData<T>);\n-   |                                   ^^^^^^^^ required by this bound in `ConstDropImplWithBounds`\n+LL | impl<T: ~const A> const Drop for ConstDropImplWithBounds<T> {\n+   |                         ^^^^     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+note: required by a bound in `check`\n+  --> $DIR/const-drop-fail.rs:35:19\n+   |\n+LL | const fn check<T: ~const Drop>(_: T) {}\n+   |                   ^^^^^^^^^^^ required by this bound in `check`\n \n-error: aborting due to 5 previous errors\n+error: aborting due to 3 previous errors\n \n For more information about this error, try `rustc --explain E0277`."}, {"sha": "4622723c1891e7da872d12cb091b82ce4f82b612", "filename": "src/test/ui/rfc-2632-const-trait-impl/const-drop-fail.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ef119d704d87a05435ea97ef4161529142313a9b/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-drop-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef119d704d87a05435ea97ef4161529142313a9b/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-drop-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-drop-fail.rs?ref=ef119d704d87a05435ea97ef4161529142313a9b", "patch": "@@ -24,8 +24,7 @@ trait A { fn a() { println!(\"A\"); } }\n \n impl A for NonTrivialDrop {}\n \n-struct ConstDropImplWithBounds<T: ~const A>(PhantomData<T>);\n-//~^ ERROR `~const` is not allowed\n+struct ConstDropImplWithBounds<T: A>(PhantomData<T>);\n \n impl<T: ~const A> const Drop for ConstDropImplWithBounds<T> {\n     fn drop(&mut self) {\n@@ -48,7 +47,6 @@ check_all! {\n     //~^ ERROR the trait bound\n     ConstDropImplWithBounds::<NonTrivialDrop>(PhantomData),\n     //~^ ERROR the trait bound\n-    //~| ERROR the trait bound\n }\n \n fn main() {}"}, {"sha": "721636e074371e3d2c1798ba0ab2820ff5e0ff84", "filename": "src/test/ui/rfc-2632-const-trait-impl/const-drop-fail.stock.stderr", "status": "modified", "additions": 25, "deletions": 32, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/ef119d704d87a05435ea97ef4161529142313a9b/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-drop-fail.stock.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ef119d704d87a05435ea97ef4161529142313a9b/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-drop-fail.stock.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-drop-fail.stock.stderr?ref=ef119d704d87a05435ea97ef4161529142313a9b", "patch": "@@ -1,13 +1,5 @@\n-error: `~const` is not allowed here\n-  --> $DIR/const-drop-fail.rs:27:35\n-   |\n-LL | struct ConstDropImplWithBounds<T: ~const A>(PhantomData<T>);\n-   |                                   ^^^^^^^^\n-   |\n-   = note: only allowed on bounds on traits' associated types and functions, const fns, const impls and its associated functions\n-\n error[E0277]: the trait bound `NonTrivialDrop: Drop` is not satisfied\n-  --> $DIR/const-drop-fail.rs:45:5\n+  --> $DIR/const-drop-fail.rs:44:5\n    |\n LL |         const _: () = check($exp);\n    |                       ----- required by a bound introduced by this call\n@@ -16,50 +8,51 @@ LL |     NonTrivialDrop,\n    |     ^^^^^^^^^^^^^^ the trait `Drop` is not implemented for `NonTrivialDrop`\n    |\n note: required by a bound in `check`\n-  --> $DIR/const-drop-fail.rs:36:19\n+  --> $DIR/const-drop-fail.rs:35:19\n    |\n LL | const fn check<T: ~const Drop>(_: T) {}\n    |                   ^^^^^^^^^^^ required by this bound in `check`\n \n-error[E0277]: the trait bound `ConstImplWithDropGlue: Drop` is not satisfied\n-  --> $DIR/const-drop-fail.rs:47:5\n+error[E0277]: the trait bound `NonTrivialDrop: Drop` is not satisfied in `ConstImplWithDropGlue`\n+  --> $DIR/const-drop-fail.rs:46:5\n    |\n LL |         const _: () = check($exp);\n    |                       ----- required by a bound introduced by this call\n ...\n LL |     ConstImplWithDropGlue(NonTrivialDrop),\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Drop` is not implemented for `ConstImplWithDropGlue`\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ within `ConstImplWithDropGlue`, the trait `Drop` is not implemented for `NonTrivialDrop`\n    |\n+note: required because it appears within the type `ConstImplWithDropGlue`\n+  --> $DIR/const-drop-fail.rs:17:8\n+   |\n+LL | struct ConstImplWithDropGlue(NonTrivialDrop);\n+   |        ^^^^^^^^^^^^^^^^^^^^^\n note: required by a bound in `check`\n-  --> $DIR/const-drop-fail.rs:36:19\n+  --> $DIR/const-drop-fail.rs:35:19\n    |\n LL | const fn check<T: ~const Drop>(_: T) {}\n    |                   ^^^^^^^^^^^ required by this bound in `check`\n \n error[E0277]: the trait bound `NonTrivialDrop: A` is not satisfied\n-  --> $DIR/const-drop-fail.rs:49:5\n-   |\n-LL |     ConstDropImplWithBounds::<NonTrivialDrop>(PhantomData),\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `A` is not implemented for `NonTrivialDrop`\n-   |\n-note: required by a bound in `ConstDropImplWithBounds`\n-  --> $DIR/const-drop-fail.rs:27:35\n-   |\n-LL | struct ConstDropImplWithBounds<T: ~const A>(PhantomData<T>);\n-   |                                   ^^^^^^^^ required by this bound in `ConstDropImplWithBounds`\n-\n-error[E0277]: the trait bound `NonTrivialDrop: A` is not satisfied\n-  --> $DIR/const-drop-fail.rs:49:5\n+  --> $DIR/const-drop-fail.rs:48:5\n    |\n+LL |         const _: () = check($exp);\n+   |                       ----- required by a bound introduced by this call\n+...\n LL |     ConstDropImplWithBounds::<NonTrivialDrop>(PhantomData),\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `A` is not implemented for `NonTrivialDrop`\n    |\n-note: required by a bound in `ConstDropImplWithBounds`\n-  --> $DIR/const-drop-fail.rs:27:35\n+note: required because of the requirements on the impl of `Drop` for `ConstDropImplWithBounds<NonTrivialDrop>`\n+  --> $DIR/const-drop-fail.rs:29:25\n    |\n-LL | struct ConstDropImplWithBounds<T: ~const A>(PhantomData<T>);\n-   |                                   ^^^^^^^^ required by this bound in `ConstDropImplWithBounds`\n+LL | impl<T: ~const A> const Drop for ConstDropImplWithBounds<T> {\n+   |                         ^^^^     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+note: required by a bound in `check`\n+  --> $DIR/const-drop-fail.rs:35:19\n+   |\n+LL | const fn check<T: ~const Drop>(_: T) {}\n+   |                   ^^^^^^^^^^^ required by this bound in `check`\n \n-error: aborting due to 5 previous errors\n+error: aborting due to 3 previous errors\n \n For more information about this error, try `rustc --explain E0277`."}, {"sha": "13363c506d54e573dbaed08a99f8604f85e680e6", "filename": "src/test/ui/rfc-2632-const-trait-impl/const-drop.rs", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/ef119d704d87a05435ea97ef4161529142313a9b/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef119d704d87a05435ea97ef4161529142313a9b/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-drop.rs?ref=ef119d704d87a05435ea97ef4161529142313a9b", "patch": "@@ -3,6 +3,7 @@\n #![feature(const_trait_impl)]\n #![feature(const_fn_trait_bound)]\n #![feature(const_mut_refs)]\n+#![feature(never_type)]\n #![cfg_attr(precise, feature(const_precise_live_drops))]\n \n struct S<'a>(&'a mut u8);\n@@ -45,6 +46,33 @@ mod t {\n \n     pub struct HasConstDrop(pub ConstDrop);\n     pub struct TrivialFields(pub u8, pub i8, pub usize, pub isize);\n+\n+    pub trait SomeTrait {\n+        fn foo();\n+    }\n+    impl const SomeTrait for () {\n+        fn foo() {}\n+    }\n+    // non-const impl\n+    impl SomeTrait for i32 {\n+        fn foo() {}\n+    }\n+\n+    pub struct ConstDropWithBound<T: SomeTrait>(pub core::marker::PhantomData<T>);\n+\n+    impl<T: ~const SomeTrait> const Drop for ConstDropWithBound<T> {\n+        fn drop(&mut self) {\n+            T::foo();\n+        }\n+    }\n+\n+    pub struct ConstDropWithNonconstBound<T: SomeTrait>(pub core::marker::PhantomData<T>);\n+\n+    impl<T: SomeTrait> const Drop for ConstDropWithNonconstBound<T> {\n+        fn drop(&mut self) {\n+            // Note: we DON'T use the `T: SomeTrait` bound\n+        }\n+    }\n }\n \n use t::*;\n@@ -61,6 +89,9 @@ implements_const_drop! {\n     TrivialFields(1, 2, 3, 4),\n     &1,\n     &1 as *const i32,\n+    ConstDropWithBound::<()>,\n+    ConstDropWithNonconstBound::<i32>,\n+    Result::<i32, !>::Ok(1),\n }\n \n fn main() {"}]}