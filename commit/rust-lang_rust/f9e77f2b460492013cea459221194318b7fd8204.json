{"sha": "f9e77f2b460492013cea459221194318b7fd8204", "node_id": "C_kwDOAAsO6NoAKGY5ZTc3ZjJiNDYwNDkyMDEzY2VhNDU5MjIxMTk0MzE4YjdmZDgyMDQ", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-12-08T14:58:48Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-12-08T14:58:48Z"}, "message": "Auto merge of #91604 - nikic:section-flags, r=nagisa\n\nUse object crate for .rustc metadata generation\n\nWe already use the object crate for generating uncompressed .rmeta\nmetadata object files. This switches the generation of compressed\n.rustc object files to use the object crate as well. These have\nslightly different requirements in that .rmeta should be completely\nexcluded from any final compilation artifacts, while .rustc should\nbe part of shared objects, but not loaded into memory.\n\nThe primary motivation for this change is #90326: In LLVM 14, the\ncurrent way of setting section flags (and in particular, preventing\nthe setting of SHF_ALLOC) will no longer work. There are other ways\nwe could work around this, but switching to the object crate seems\nlike the most elegant, as we already use it for .rmeta, and as it\nmakes this independent of the codegen backend. In particular, we\ndon't need separate handling in codegen_llvm and codegen_gcc.\ncodegen_cranelift should be able to reuse the implementation as\nwell, though I have omitted that here, as it is not based on\ncodegen_ssa.\n\nThis change mostly extracts the existing code for .rmeta handling\nto allow using it for .rustc as well, and adjusts the codegen\ninfrastructure to handle the metadata object file separately: We\nno longer create a backend-specific module for it, and directly\nproduce the compiled module instead.\n\nThis does not `fix` #90326 by itself yet, as .llvmbc will need to be\nhandled separately.\n\nr? `@nagisa`", "tree": {"sha": "12df681da376ff2e6901a66c7a67596c3789d03f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/12df681da376ff2e6901a66c7a67596c3789d03f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f9e77f2b460492013cea459221194318b7fd8204", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f9e77f2b460492013cea459221194318b7fd8204", "html_url": "https://github.com/rust-lang/rust/commit/f9e77f2b460492013cea459221194318b7fd8204", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f9e77f2b460492013cea459221194318b7fd8204/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4459e720bee5a741b962cfcd6f0593b32dc19009", "url": "https://api.github.com/repos/rust-lang/rust/commits/4459e720bee5a741b962cfcd6f0593b32dc19009", "html_url": "https://github.com/rust-lang/rust/commit/4459e720bee5a741b962cfcd6f0593b32dc19009"}, {"sha": "9488cacc52a851833be51c3f9d1555e9f9c9f586", "url": "https://api.github.com/repos/rust-lang/rust/commits/9488cacc52a851833be51c3f9d1555e9f9c9f586", "html_url": "https://github.com/rust-lang/rust/commit/9488cacc52a851833be51c3f9d1555e9f9c9f586"}], "stats": {"total": 534, "additions": 246, "deletions": 288}, "files": [{"sha": "87c9823903a8c986590cc613ad2ea80d900666ff", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f9e77f2b460492013cea459221194318b7fd8204/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/f9e77f2b460492013cea459221194318b7fd8204/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=f9e77f2b460492013cea459221194318b7fd8204", "patch": "@@ -3714,7 +3714,6 @@ dependencies = [\n  \"rustc_span\",\n  \"rustc_target\",\n  \"smallvec\",\n- \"snap\",\n  \"tracing\",\n ]\n \n@@ -3749,6 +3748,7 @@ dependencies = [\n  \"rustc_symbol_mangling\",\n  \"rustc_target\",\n  \"smallvec\",\n+ \"snap\",\n  \"tempfile\",\n  \"tracing\",\n ]"}, {"sha": "dee70bf75369d6aa59bcce209cdc597731a068c8", "filename": "compiler/rustc_codegen_gcc/src/base.rs", "status": "modified", "additions": 0, "deletions": 39, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/f9e77f2b460492013cea459221194318b7fd8204/compiler%2Frustc_codegen_gcc%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9e77f2b460492013cea459221194318b7fd8204/compiler%2Frustc_codegen_gcc%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fbase.rs?ref=f9e77f2b460492013cea459221194318b7fd8204", "patch": "@@ -7,14 +7,12 @@ use gccjit::{\n     GlobalKind,\n };\n use rustc_middle::dep_graph;\n-use rustc_middle::middle::exported_symbols;\n use rustc_middle::ty::TyCtxt;\n use rustc_middle::mir::mono::Linkage;\n use rustc_codegen_ssa::{ModuleCodegen, ModuleKind};\n use rustc_codegen_ssa::base::maybe_create_entry_wrapper;\n use rustc_codegen_ssa::mono_item::MonoItemExt;\n use rustc_codegen_ssa::traits::DebugInfoMethods;\n-use rustc_metadata::EncodedMetadata;\n use rustc_session::config::DebugInfo;\n use rustc_span::Symbol;\n \n@@ -132,40 +130,3 @@ pub fn compile_codegen_unit<'tcx>(tcx: TyCtxt<'tcx>, cgu_name: Symbol) -> (Modul\n \n     (module, cost)\n }\n-\n-pub fn write_compressed_metadata<'tcx>(tcx: TyCtxt<'tcx>, metadata: &EncodedMetadata, gcc_module: &mut GccContext) {\n-    use snap::write::FrameEncoder;\n-    use std::io::Write;\n-\n-    // Historical note:\n-    //\n-    // When using link.exe it was seen that the section name `.note.rustc`\n-    // was getting shortened to `.note.ru`, and according to the PE and COFF\n-    // specification:\n-    //\n-    // > Executable images do not use a string table and do not support\n-    // > section names longer than 8 characters\n-    //\n-    // https://docs.microsoft.com/en-us/windows/win32/debug/pe-format\n-    //\n-    // As a result, we choose a slightly shorter name! As to why\n-    // `.note.rustc` works on MinGW, see\n-    // https://github.com/llvm/llvm-project/blob/llvmorg-12.0.0/lld/COFF/Writer.cpp#L1190-L1197\n-    let section_name = if tcx.sess.target.is_like_osx { \"__DATA,.rustc\" } else { \".rustc\" };\n-\n-    let context = &gcc_module.context;\n-    let mut compressed = rustc_metadata::METADATA_HEADER.to_vec();\n-    FrameEncoder::new(&mut compressed).write_all(&metadata.raw_data()).unwrap();\n-\n-    let name = exported_symbols::metadata_symbol_name(tcx);\n-    let typ = context.new_array_type(None, context.new_type::<u8>(), compressed.len() as i32);\n-    let global = context.new_global(None, GlobalKind::Exported, typ, name);\n-    global.global_set_initializer(&compressed);\n-    global.set_link_section(section_name);\n-\n-    // Also generate a .section directive to force no\n-    // flags, at least for ELF outputs, so that the\n-    // metadata doesn't get loaded into memory.\n-    let directive = format!(\".section {}\", section_name);\n-    context.add_top_level_asm(None, &directive);\n-}"}, {"sha": "a549bcbd931069fd1d06d6591043e0a2cc008396", "filename": "compiler/rustc_codegen_gcc/src/lib.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f9e77f2b460492013cea459221194318b7fd8204/compiler%2Frustc_codegen_gcc%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9e77f2b460492013cea459221194318b7fd8204/compiler%2Frustc_codegen_gcc%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Flib.rs?ref=f9e77f2b460492013cea459221194318b7fd8204", "patch": "@@ -22,7 +22,6 @@ extern crate rustc_session;\n extern crate rustc_span;\n extern crate rustc_symbol_mangling;\n extern crate rustc_target;\n-extern crate snap;\n \n // This prevents duplicating functions and statics that are already part of the host rustc process.\n #[allow(unused_extern_crates)]\n@@ -128,10 +127,6 @@ impl ExtraBackendMethods for GccCodegenBackend {\n         }\n     }\n \n-    fn write_compressed_metadata<'tcx>(&self, tcx: TyCtxt<'tcx>, metadata: &EncodedMetadata, gcc_module: &mut Self::Module) {\n-        base::write_compressed_metadata(tcx, metadata, gcc_module)\n-    }\n-\n     fn codegen_allocator<'tcx>(&self, tcx: TyCtxt<'tcx>, mods: &mut Self::Module, module_name: &str, kind: AllocatorKind, has_alloc_error_handler: bool) {\n         unsafe { allocator::codegen(tcx, mods, module_name, kind, has_alloc_error_handler) }\n     }"}, {"sha": "f77b0bc8cc9a2fa41a9b8f21abe831a992185536", "filename": "compiler/rustc_codegen_llvm/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f9e77f2b460492013cea459221194318b7fd8204/compiler%2Frustc_codegen_llvm%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/f9e77f2b460492013cea459221194318b7fd8204/compiler%2Frustc_codegen_llvm%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2FCargo.toml?ref=f9e77f2b460492013cea459221194318b7fd8204", "patch": "@@ -12,7 +12,6 @@ bitflags = \"1.0\"\n cstr = \"0.2\"\n libc = \"0.2\"\n measureme = \"10.0.0\"\n-snap = \"1\"\n tracing = \"0.1\"\n rustc_middle = { path = \"../rustc_middle\" }\n rustc-demangle = \"0.1.21\""}, {"sha": "7a3e11e32bc1a3438d73ceb7b4e41d14b86bedde", "filename": "compiler/rustc_codegen_llvm/src/base.rs", "status": "modified", "additions": 1, "deletions": 52, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/f9e77f2b460492013cea459221194318b7fd8204/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9e77f2b460492013cea459221194318b7fd8204/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbase.rs?ref=f9e77f2b460492013cea459221194318b7fd8204", "patch": "@@ -9,13 +9,12 @@\n //!   int)` and `rec(x=int, y=int, z=int)` will have the same [`llvm::Type`].\n //!\n //! [`Ty`]: rustc_middle::ty::Ty\n-//! [`val_ty`]: common::val_ty\n+//! [`val_ty`]: crate::common::val_ty\n \n use super::ModuleLlvm;\n \n use crate::attributes;\n use crate::builder::Builder;\n-use crate::common;\n use crate::context::CodegenCx;\n use crate::llvm;\n use crate::value::Value;\n@@ -25,66 +24,16 @@ use rustc_codegen_ssa::mono_item::MonoItemExt;\n use rustc_codegen_ssa::traits::*;\n use rustc_codegen_ssa::{ModuleCodegen, ModuleKind};\n use rustc_data_structures::small_c_str::SmallCStr;\n-use rustc_metadata::EncodedMetadata;\n use rustc_middle::dep_graph;\n use rustc_middle::middle::codegen_fn_attrs::CodegenFnAttrs;\n-use rustc_middle::middle::exported_symbols;\n use rustc_middle::mir::mono::{Linkage, Visibility};\n use rustc_middle::ty::TyCtxt;\n use rustc_session::config::DebugInfo;\n use rustc_span::symbol::Symbol;\n use rustc_target::spec::SanitizerSet;\n \n-use std::ffi::CString;\n use std::time::Instant;\n \n-pub fn write_compressed_metadata<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    metadata: &EncodedMetadata,\n-    llvm_module: &mut ModuleLlvm,\n-) {\n-    use snap::write::FrameEncoder;\n-    use std::io::Write;\n-\n-    // Historical note:\n-    //\n-    // When using link.exe it was seen that the section name `.note.rustc`\n-    // was getting shortened to `.note.ru`, and according to the PE and COFF\n-    // specification:\n-    //\n-    // > Executable images do not use a string table and do not support\n-    // > section names longer than 8\u00a0characters\n-    //\n-    // https://docs.microsoft.com/en-us/windows/win32/debug/pe-format\n-    //\n-    // As a result, we choose a slightly shorter name! As to why\n-    // `.note.rustc` works on MinGW, see\n-    // https://github.com/llvm/llvm-project/blob/llvmorg-12.0.0/lld/COFF/Writer.cpp#L1190-L1197\n-    let section_name = if tcx.sess.target.is_like_osx { \"__DATA,.rustc\" } else { \".rustc\" };\n-\n-    let (metadata_llcx, metadata_llmod) = (&*llvm_module.llcx, llvm_module.llmod());\n-    let mut compressed = rustc_metadata::METADATA_HEADER.to_vec();\n-    FrameEncoder::new(&mut compressed).write_all(metadata.raw_data()).unwrap();\n-\n-    let llmeta = common::bytes_in_context(metadata_llcx, &compressed);\n-    let llconst = common::struct_in_context(metadata_llcx, &[llmeta], false);\n-    let name = exported_symbols::metadata_symbol_name(tcx);\n-    let buf = CString::new(name).unwrap();\n-    let llglobal =\n-        unsafe { llvm::LLVMAddGlobal(metadata_llmod, common::val_ty(llconst), buf.as_ptr()) };\n-    unsafe {\n-        llvm::LLVMSetInitializer(llglobal, llconst);\n-        let name = SmallCStr::new(section_name);\n-        llvm::LLVMSetSection(llglobal, name.as_ptr());\n-\n-        // Also generate a .section directive to force no\n-        // flags, at least for ELF outputs, so that the\n-        // metadata doesn't get loaded into memory.\n-        let directive = format!(\".section {}\", section_name);\n-        llvm::LLVMSetModuleInlineAsm2(metadata_llmod, directive.as_ptr().cast(), directive.len())\n-    }\n-}\n-\n pub struct ValueIter<'ll> {\n     cur: Option<&'ll Value>,\n     step: unsafe extern \"C\" fn(&'ll Value) -> Option<&'ll Value>,"}, {"sha": "62c17e6a10f17a3f39f57fbbcc3260569efa595a", "filename": "compiler/rustc_codegen_llvm/src/lib.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f9e77f2b460492013cea459221194318b7fd8204/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9e77f2b460492013cea459221194318b7fd8204/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs?ref=f9e77f2b460492013cea459221194318b7fd8204", "patch": "@@ -102,14 +102,6 @@ impl ExtraBackendMethods for LlvmCodegenBackend {\n         ModuleLlvm::new_metadata(tcx, mod_name)\n     }\n \n-    fn write_compressed_metadata<'tcx>(\n-        &self,\n-        tcx: TyCtxt<'tcx>,\n-        metadata: &EncodedMetadata,\n-        llvm_module: &mut ModuleLlvm,\n-    ) {\n-        base::write_compressed_metadata(tcx, metadata, llvm_module)\n-    }\n     fn codegen_allocator<'tcx>(\n         &self,\n         tcx: TyCtxt<'tcx>,"}, {"sha": "18dbcd8e52da8798d935dc515a3e00de41c52c80", "filename": "compiler/rustc_codegen_ssa/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f9e77f2b460492013cea459221194318b7fd8204/compiler%2Frustc_codegen_ssa%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/f9e77f2b460492013cea459221194318b7fd8204/compiler%2Frustc_codegen_ssa%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2FCargo.toml?ref=f9e77f2b460492013cea459221194318b7fd8204", "patch": "@@ -15,6 +15,7 @@ libc = \"0.2.50\"\n jobserver = \"0.1.22\"\n tempfile = \"3.2\"\n pathdiff = \"0.2.0\"\n+snap = \"1\"\n smallvec = { version = \"1.6.1\", features = [\"union\", \"may_dangle\"] }\n regex = \"1.4\"\n "}, {"sha": "bf45810de7708d0fc99d87213eef6ad58a60adb0", "filename": "compiler/rustc_codegen_ssa/src/back/link.rs", "status": "modified", "additions": 2, "deletions": 135, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/f9e77f2b460492013cea459221194318b7fd8204/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9e77f2b460492013cea459221194318b7fd8204/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs?ref=f9e77f2b460492013cea459221194318b7fd8204", "patch": "@@ -14,24 +14,21 @@ use rustc_session::utils::NativeLibKind;\n /// need out of the shared crate context before we get rid of it.\n use rustc_session::{filesearch, Session};\n use rustc_span::symbol::Symbol;\n-use rustc_target::abi::Endian;\n use rustc_target::spec::crt_objects::{CrtObjects, CrtObjectsFallback};\n use rustc_target::spec::{LinkOutputKind, LinkerFlavor, LldFlavor, SplitDebuginfo};\n use rustc_target::spec::{PanicStrategy, RelocModel, RelroLevel, SanitizerSet, Target};\n \n use super::archive::{find_library, ArchiveBuilder};\n use super::command::Command;\n use super::linker::{self, Linker};\n+use super::metadata::create_rmeta_file;\n use super::rpath::{self, RPathConfig};\n use crate::{\n     looks_like_rust_object_file, CodegenResults, CompiledModule, CrateInfo, NativeLib,\n     METADATA_FILENAME,\n };\n \n use cc::windows_registry;\n-use object::elf;\n-use object::write::Object;\n-use object::{Architecture, BinaryFormat, Endianness, FileFlags, SectionFlags, SectionKind};\n use regex::Regex;\n use tempfile::Builder as TempFileBuilder;\n \n@@ -339,7 +336,7 @@ fn link_rlib<'a, B: ArchiveBuilder<'a>>(\n             // metadata in rlib files is wrapped in a \"dummy\" object file for\n             // the target platform so the rlib can be processed entirely by\n             // normal linkers for the platform.\n-            let metadata = create_metadata_file(sess, codegen_results.metadata.raw_data());\n+            let metadata = create_rmeta_file(sess, codegen_results.metadata.raw_data());\n             ab.add_file(&emit_metadata(sess, &metadata, tmpdir));\n \n             // After adding all files to the archive, we need to update the\n@@ -358,136 +355,6 @@ fn link_rlib<'a, B: ArchiveBuilder<'a>>(\n         }\n     }\n     return Ok(ab);\n-\n-    // For rlibs we \"pack\" rustc metadata into a dummy object file. When rustc\n-    // creates a dylib crate type it will pass `--whole-archive` (or the\n-    // platform equivalent) to include all object files from an rlib into the\n-    // final dylib itself. This causes linkers to iterate and try to include all\n-    // files located in an archive, so if metadata is stored in an archive then\n-    // it needs to be of a form that the linker will be able to process.\n-    //\n-    // Note, though, that we don't actually want this metadata to show up in any\n-    // final output of the compiler. Instead this is purely for rustc's own\n-    // metadata tracking purposes.\n-    //\n-    // With the above in mind, each \"flavor\" of object format gets special\n-    // handling here depending on the target:\n-    //\n-    // * MachO - macos-like targets will insert the metadata into a section that\n-    //   is sort of fake dwarf debug info. Inspecting the source of the macos\n-    //   linker this causes these sections to be skipped automatically because\n-    //   it's not in an allowlist of otherwise well known dwarf section names to\n-    //   go into the final artifact.\n-    //\n-    // * WebAssembly - we actually don't have any container format for this\n-    //   target. WebAssembly doesn't support the `dylib` crate type anyway so\n-    //   there's no need for us to support this at this time. Consequently the\n-    //   metadata bytes are simply stored as-is into an rlib.\n-    //\n-    // * COFF - Windows-like targets create an object with a section that has\n-    //   the `IMAGE_SCN_LNK_REMOVE` flag set which ensures that if the linker\n-    //   ever sees the section it doesn't process it and it's removed.\n-    //\n-    // * ELF - All other targets are similar to Windows in that there's a\n-    //   `SHF_EXCLUDE` flag we can set on sections in an object file to get\n-    //   automatically removed from the final output.\n-    //\n-    // Note that this metdata format is kept in sync with\n-    // `rustc_codegen_ssa/src/back/metadata.rs`.\n-    fn create_metadata_file(sess: &Session, metadata: &[u8]) -> Vec<u8> {\n-        let endianness = match sess.target.options.endian {\n-            Endian::Little => Endianness::Little,\n-            Endian::Big => Endianness::Big,\n-        };\n-        let architecture = match &sess.target.arch[..] {\n-            \"arm\" => Architecture::Arm,\n-            \"aarch64\" => Architecture::Aarch64,\n-            \"x86\" => Architecture::I386,\n-            \"s390x\" => Architecture::S390x,\n-            \"mips\" => Architecture::Mips,\n-            \"mips64\" => Architecture::Mips64,\n-            \"x86_64\" => {\n-                if sess.target.pointer_width == 32 {\n-                    Architecture::X86_64_X32\n-                } else {\n-                    Architecture::X86_64\n-                }\n-            }\n-            \"powerpc\" => Architecture::PowerPc,\n-            \"powerpc64\" => Architecture::PowerPc64,\n-            \"riscv32\" => Architecture::Riscv32,\n-            \"riscv64\" => Architecture::Riscv64,\n-            \"sparc64\" => Architecture::Sparc64,\n-\n-            // This is used to handle all \"other\" targets. This includes targets\n-            // in two categories:\n-            //\n-            // * Some targets don't have support in the `object` crate just yet\n-            //   to write an object file. These targets are likely to get filled\n-            //   out over time.\n-            //\n-            // * Targets like WebAssembly don't support dylibs, so the purpose\n-            //   of putting metadata in object files, to support linking rlibs\n-            //   into dylibs, is moot.\n-            //\n-            // In both of these cases it means that linking into dylibs will\n-            // not be supported by rustc. This doesn't matter for targets like\n-            // WebAssembly and for targets not supported by the `object` crate\n-            // yet it means that work will need to be done in the `object` crate\n-            // to add a case above.\n-            _ => return metadata.to_vec(),\n-        };\n-\n-        if sess.target.is_like_osx {\n-            let mut file = Object::new(BinaryFormat::MachO, architecture, endianness);\n-\n-            let section =\n-                file.add_section(b\"__DWARF\".to_vec(), b\".rmeta\".to_vec(), SectionKind::Debug);\n-            file.append_section_data(section, metadata, 1);\n-            file.write().unwrap()\n-        } else if sess.target.is_like_windows {\n-            const IMAGE_SCN_LNK_REMOVE: u32 = 0;\n-            let mut file = Object::new(BinaryFormat::Coff, architecture, endianness);\n-\n-            let section = file.add_section(Vec::new(), b\".rmeta\".to_vec(), SectionKind::Debug);\n-            file.section_mut(section).flags =\n-                SectionFlags::Coff { characteristics: IMAGE_SCN_LNK_REMOVE };\n-            file.append_section_data(section, metadata, 1);\n-            file.write().unwrap()\n-        } else {\n-            const SHF_EXCLUDE: u64 = 0x80000000;\n-            let mut file = Object::new(BinaryFormat::Elf, architecture, endianness);\n-\n-            match &sess.target.arch[..] {\n-                // copied from `mipsel-linux-gnu-gcc foo.c -c` and\n-                // inspecting the resulting `e_flags` field.\n-                \"mips\" => {\n-                    let e_flags = elf::EF_MIPS_ARCH_32R2 | elf::EF_MIPS_CPIC | elf::EF_MIPS_PIC;\n-                    file.flags = FileFlags::Elf { e_flags };\n-                }\n-                // copied from `mips64el-linux-gnuabi64-gcc foo.c -c`\n-                \"mips64\" => {\n-                    let e_flags = elf::EF_MIPS_ARCH_64R2 | elf::EF_MIPS_CPIC | elf::EF_MIPS_PIC;\n-                    file.flags = FileFlags::Elf { e_flags };\n-                }\n-\n-                // copied from `riscv64-linux-gnu-gcc foo.c -c`, note though\n-                // that the `+d` target feature represents whether the double\n-                // float abi is enabled.\n-                \"riscv64\" if sess.target.options.features.contains(\"+d\") => {\n-                    let e_flags = elf::EF_RISCV_RVC | elf::EF_RISCV_FLOAT_ABI_DOUBLE;\n-                    file.flags = FileFlags::Elf { e_flags };\n-                }\n-\n-                _ => {}\n-            }\n-\n-            let section = file.add_section(Vec::new(), b\".rmeta\".to_vec(), SectionKind::Debug);\n-            file.section_mut(section).flags = SectionFlags::Elf { sh_flags: SHF_EXCLUDE };\n-            file.append_section_data(section, metadata, 1);\n-            file.write().unwrap()\n-        }\n-    }\n }\n \n /// Extract all symbols defined in raw-dylib libraries, collated by library name."}, {"sha": "1df5540e3b840c40a1ccf1310b27b0aad3e3d08b", "filename": "compiler/rustc_codegen_ssa/src/back/metadata.rs", "status": "modified", "additions": 196, "deletions": 1, "changes": 197, "blob_url": "https://github.com/rust-lang/rust/blob/f9e77f2b460492013cea459221194318b7fd8204/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9e77f2b460492013cea459221194318b7fd8204/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fmetadata.rs?ref=f9e77f2b460492013cea459221194318b7fd8204", "patch": "@@ -1,14 +1,25 @@\n //! Reading of the rustc metadata for rlibs and dylibs\n \n use std::fs::File;\n+use std::io::Write;\n use std::path::Path;\n \n-use object::{Object, ObjectSection};\n+use object::write::{self, StandardSegment, Symbol, SymbolSection};\n+use object::{\n+    elf, Architecture, BinaryFormat, Endianness, FileFlags, Object, ObjectSection, SectionFlags,\n+    SectionKind, SymbolFlags, SymbolKind, SymbolScope,\n+};\n+\n+use snap::write::FrameEncoder;\n+\n use rustc_data_structures::memmap::Mmap;\n use rustc_data_structures::owning_ref::OwningRef;\n use rustc_data_structures::rustc_erase_owner;\n use rustc_data_structures::sync::MetadataRef;\n+use rustc_metadata::EncodedMetadata;\n use rustc_session::cstore::MetadataLoader;\n+use rustc_session::Session;\n+use rustc_target::abi::Endian;\n use rustc_target::spec::Target;\n \n use crate::METADATA_FILENAME;\n@@ -83,3 +94,187 @@ fn search_for_metadata<'a>(\n         .data()\n         .map_err(|e| format!(\"failed to read {} section in '{}': {}\", section, path.display(), e))\n }\n+\n+fn create_object_file(sess: &Session) -> Option<write::Object> {\n+    let endianness = match sess.target.options.endian {\n+        Endian::Little => Endianness::Little,\n+        Endian::Big => Endianness::Big,\n+    };\n+    let architecture = match &sess.target.arch[..] {\n+        \"arm\" => Architecture::Arm,\n+        \"aarch64\" => Architecture::Aarch64,\n+        \"x86\" => Architecture::I386,\n+        \"s390x\" => Architecture::S390x,\n+        \"mips\" => Architecture::Mips,\n+        \"mips64\" => Architecture::Mips64,\n+        \"x86_64\" => {\n+            if sess.target.pointer_width == 32 {\n+                Architecture::X86_64_X32\n+            } else {\n+                Architecture::X86_64\n+            }\n+        }\n+        \"powerpc\" => Architecture::PowerPc,\n+        \"powerpc64\" => Architecture::PowerPc64,\n+        \"riscv32\" => Architecture::Riscv32,\n+        \"riscv64\" => Architecture::Riscv64,\n+        \"sparc64\" => Architecture::Sparc64,\n+        // Unsupported architecture.\n+        _ => return None,\n+    };\n+    let binary_format = if sess.target.is_like_osx {\n+        BinaryFormat::MachO\n+    } else if sess.target.is_like_windows {\n+        BinaryFormat::Coff\n+    } else {\n+        BinaryFormat::Elf\n+    };\n+\n+    let mut file = write::Object::new(binary_format, architecture, endianness);\n+    match architecture {\n+        Architecture::Mips => {\n+            // copied from `mipsel-linux-gnu-gcc foo.c -c` and\n+            // inspecting the resulting `e_flags` field.\n+            let e_flags = elf::EF_MIPS_ARCH_32R2 | elf::EF_MIPS_CPIC | elf::EF_MIPS_PIC;\n+            file.flags = FileFlags::Elf { e_flags };\n+        }\n+        Architecture::Mips64 => {\n+            // copied from `mips64el-linux-gnuabi64-gcc foo.c -c`\n+            let e_flags = elf::EF_MIPS_ARCH_64R2 | elf::EF_MIPS_CPIC | elf::EF_MIPS_PIC;\n+            file.flags = FileFlags::Elf { e_flags };\n+        }\n+        Architecture::Riscv64 if sess.target.options.features.contains(\"+d\") => {\n+            // copied from `riscv64-linux-gnu-gcc foo.c -c`, note though\n+            // that the `+d` target feature represents whether the double\n+            // float abi is enabled.\n+            let e_flags = elf::EF_RISCV_RVC | elf::EF_RISCV_FLOAT_ABI_DOUBLE;\n+            file.flags = FileFlags::Elf { e_flags };\n+        }\n+        _ => {}\n+    };\n+    Some(file)\n+}\n+\n+// For rlibs we \"pack\" rustc metadata into a dummy object file. When rustc\n+// creates a dylib crate type it will pass `--whole-archive` (or the\n+// platform equivalent) to include all object files from an rlib into the\n+// final dylib itself. This causes linkers to iterate and try to include all\n+// files located in an archive, so if metadata is stored in an archive then\n+// it needs to be of a form that the linker will be able to process.\n+//\n+// Note, though, that we don't actually want this metadata to show up in any\n+// final output of the compiler. Instead this is purely for rustc's own\n+// metadata tracking purposes.\n+//\n+// With the above in mind, each \"flavor\" of object format gets special\n+// handling here depending on the target:\n+//\n+// * MachO - macos-like targets will insert the metadata into a section that\n+//   is sort of fake dwarf debug info. Inspecting the source of the macos\n+//   linker this causes these sections to be skipped automatically because\n+//   it's not in an allowlist of otherwise well known dwarf section names to\n+//   go into the final artifact.\n+//\n+// * WebAssembly - we actually don't have any container format for this\n+//   target. WebAssembly doesn't support the `dylib` crate type anyway so\n+//   there's no need for us to support this at this time. Consequently the\n+//   metadata bytes are simply stored as-is into an rlib.\n+//\n+// * COFF - Windows-like targets create an object with a section that has\n+//   the `IMAGE_SCN_LNK_REMOVE` flag set which ensures that if the linker\n+//   ever sees the section it doesn't process it and it's removed.\n+//\n+// * ELF - All other targets are similar to Windows in that there's a\n+//   `SHF_EXCLUDE` flag we can set on sections in an object file to get\n+//   automatically removed from the final output.\n+pub fn create_rmeta_file(sess: &Session, metadata: &[u8]) -> Vec<u8> {\n+    let mut file = if let Some(file) = create_object_file(sess) {\n+        file\n+    } else {\n+        // This is used to handle all \"other\" targets. This includes targets\n+        // in two categories:\n+        //\n+        // * Some targets don't have support in the `object` crate just yet\n+        //   to write an object file. These targets are likely to get filled\n+        //   out over time.\n+        //\n+        // * Targets like WebAssembly don't support dylibs, so the purpose\n+        //   of putting metadata in object files, to support linking rlibs\n+        //   into dylibs, is moot.\n+        //\n+        // In both of these cases it means that linking into dylibs will\n+        // not be supported by rustc. This doesn't matter for targets like\n+        // WebAssembly and for targets not supported by the `object` crate\n+        // yet it means that work will need to be done in the `object` crate\n+        // to add a case above.\n+        return metadata.to_vec();\n+    };\n+    let section = file.add_section(\n+        file.segment_name(StandardSegment::Debug).to_vec(),\n+        b\".rmeta\".to_vec(),\n+        SectionKind::Debug,\n+    );\n+    match file.format() {\n+        BinaryFormat::Coff => {\n+            const IMAGE_SCN_LNK_REMOVE: u32 = 0;\n+            file.section_mut(section).flags =\n+                SectionFlags::Coff { characteristics: IMAGE_SCN_LNK_REMOVE };\n+        }\n+        BinaryFormat::Elf => {\n+            const SHF_EXCLUDE: u64 = 0x80000000;\n+            file.section_mut(section).flags = SectionFlags::Elf { sh_flags: SHF_EXCLUDE };\n+        }\n+        _ => {}\n+    };\n+    file.append_section_data(section, metadata, 1);\n+    file.write().unwrap()\n+}\n+\n+// Historical note:\n+//\n+// When using link.exe it was seen that the section name `.note.rustc`\n+// was getting shortened to `.note.ru`, and according to the PE and COFF\n+// specification:\n+//\n+// > Executable images do not use a string table and do not support\n+// > section names longer than 8\u00a0characters\n+//\n+// https://docs.microsoft.com/en-us/windows/win32/debug/pe-format\n+//\n+// As a result, we choose a slightly shorter name! As to why\n+// `.note.rustc` works on MinGW, see\n+// https://github.com/llvm/llvm-project/blob/llvmorg-12.0.0/lld/COFF/Writer.cpp#L1190-L1197\n+pub fn create_compressed_metadata_file(\n+    sess: &Session,\n+    metadata: &EncodedMetadata,\n+    symbol_name: &str,\n+) -> Vec<u8> {\n+    let mut compressed = rustc_metadata::METADATA_HEADER.to_vec();\n+    FrameEncoder::new(&mut compressed).write_all(metadata.raw_data()).unwrap();\n+    let mut file = if let Some(file) = create_object_file(sess) {\n+        file\n+    } else {\n+        return compressed.to_vec();\n+    };\n+    let section = file.add_section(\n+        file.segment_name(StandardSegment::Data).to_vec(),\n+        b\".rustc\".to_vec(),\n+        SectionKind::Data,\n+    );\n+    let offset = file.append_section_data(section, &compressed, 1);\n+\n+    // For MachO and probably PE this is necessary to prevent the linker from throwing away the\n+    // .rustc section. For ELF this isn't necessary, but it also doesn't harm.\n+    file.add_symbol(Symbol {\n+        name: symbol_name.as_bytes().to_vec(),\n+        value: offset,\n+        size: compressed.len() as u64,\n+        kind: SymbolKind::Data,\n+        scope: SymbolScope::Dynamic,\n+        weak: false,\n+        section: SymbolSection::Section(section),\n+        flags: SymbolFlags::None,\n+    });\n+\n+    file.write().unwrap()\n+}"}, {"sha": "2d6904af207d15c1468b8e8d0904495bc0f4f9b8", "filename": "compiler/rustc_codegen_ssa/src/back/write.rs", "status": "modified", "additions": 5, "deletions": 14, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/f9e77f2b460492013cea459221194318b7fd8204/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9e77f2b460492013cea459221194318b7fd8204/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs?ref=f9e77f2b460492013cea459221194318b7fd8204", "patch": "@@ -397,7 +397,6 @@ fn generate_lto_work<B: ExtraBackendMethods>(\n \n pub struct CompiledModules {\n     pub modules: Vec<CompiledModule>,\n-    pub metadata_module: Option<CompiledModule>,\n     pub allocator_module: Option<CompiledModule>,\n }\n \n@@ -425,6 +424,7 @@ pub fn start_async_codegen<B: ExtraBackendMethods>(\n     tcx: TyCtxt<'_>,\n     target_cpu: String,\n     metadata: EncodedMetadata,\n+    metadata_module: Option<CompiledModule>,\n     total_cgus: usize,\n ) -> OngoingCodegen<B> {\n     let (coordinator_send, coordinator_receive) = channel();\n@@ -464,6 +464,7 @@ pub fn start_async_codegen<B: ExtraBackendMethods>(\n     OngoingCodegen {\n         backend,\n         metadata,\n+        metadata_module,\n         crate_info,\n \n         coordinator_send,\n@@ -640,12 +641,6 @@ fn produce_final_output_artifacts(\n         }\n \n         if !user_wants_bitcode {\n-            if let Some(ref metadata_module) = compiled_modules.metadata_module {\n-                if let Some(ref path) = metadata_module.bytecode {\n-                    ensure_removed(sess.diagnostic(), &path);\n-                }\n-            }\n-\n             if let Some(ref allocator_module) = compiled_modules.allocator_module {\n                 if let Some(ref path) = allocator_module.bytecode {\n                     ensure_removed(sess.diagnostic(), path);\n@@ -1216,7 +1211,6 @@ fn start_executing_work<B: ExtraBackendMethods>(\n         // This is where we collect codegen units that have gone all the way\n         // through codegen and LLVM.\n         let mut compiled_modules = vec![];\n-        let mut compiled_metadata_module = None;\n         let mut compiled_allocator_module = None;\n         let mut needs_link = Vec::new();\n         let mut needs_fat_lto = Vec::new();\n@@ -1475,14 +1469,11 @@ fn start_executing_work<B: ExtraBackendMethods>(\n                         ModuleKind::Regular => {\n                             compiled_modules.push(compiled_module);\n                         }\n-                        ModuleKind::Metadata => {\n-                            assert!(compiled_metadata_module.is_none());\n-                            compiled_metadata_module = Some(compiled_module);\n-                        }\n                         ModuleKind::Allocator => {\n                             assert!(compiled_allocator_module.is_none());\n                             compiled_allocator_module = Some(compiled_module);\n                         }\n+                        ModuleKind::Metadata => bug!(\"Should be handled separately\"),\n                     }\n                 }\n                 Message::NeedsLink { module, worker_id } => {\n@@ -1539,7 +1530,6 @@ fn start_executing_work<B: ExtraBackendMethods>(\n \n         Ok(CompiledModules {\n             modules: compiled_modules,\n-            metadata_module: compiled_metadata_module,\n             allocator_module: compiled_allocator_module,\n         })\n     });\n@@ -1800,6 +1790,7 @@ impl SharedEmitterMain {\n pub struct OngoingCodegen<B: ExtraBackendMethods> {\n     pub backend: B,\n     pub metadata: EncodedMetadata,\n+    pub metadata_module: Option<CompiledModule>,\n     pub crate_info: CrateInfo,\n     pub coordinator_send: Sender<Box<dyn Any + Send>>,\n     pub codegen_worker_receive: Receiver<Message<B>>,\n@@ -1846,7 +1837,7 @@ impl<B: ExtraBackendMethods> OngoingCodegen<B> {\n \n                 modules: compiled_modules.modules,\n                 allocator_module: compiled_modules.allocator_module,\n-                metadata_module: compiled_modules.metadata_module,\n+                metadata_module: self.metadata_module,\n             },\n             work_products,\n         )"}, {"sha": "d82aa6915452b42c5d20d6995273667ad78ffa27", "filename": "compiler/rustc_codegen_ssa/src/base.rs", "status": "modified", "additions": 40, "deletions": 26, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/f9e77f2b460492013cea459221194318b7fd8204/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9e77f2b460492013cea459221194318b7fd8204/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs?ref=f9e77f2b460492013cea459221194318b7fd8204", "patch": "@@ -1,3 +1,4 @@\n+use crate::back::metadata::create_compressed_metadata_file;\n use crate::back::write::{\n     compute_per_cgu_lto_type, start_async_codegen, submit_codegened_module_to_llvm,\n     submit_post_lto_module_to_llvm, submit_pre_lto_module_to_llvm, ComputedLtoType, OngoingCodegen,\n@@ -8,7 +9,7 @@ use crate::mir;\n use crate::mir::operand::OperandValue;\n use crate::mir::place::PlaceRef;\n use crate::traits::*;\n-use crate::{CachedModuleCodegen, CrateInfo, MemFlags, ModuleCodegen, ModuleKind};\n+use crate::{CachedModuleCodegen, CompiledModule, CrateInfo, MemFlags, ModuleCodegen, ModuleKind};\n \n use rustc_attr as attr;\n use rustc_data_structures::fx::FxHashMap;\n@@ -20,13 +21,14 @@ use rustc_hir::lang_items::LangItem;\n use rustc_index::vec::Idx;\n use rustc_metadata::EncodedMetadata;\n use rustc_middle::middle::codegen_fn_attrs::CodegenFnAttrs;\n+use rustc_middle::middle::exported_symbols;\n use rustc_middle::middle::lang_items;\n use rustc_middle::mir::mono::{CodegenUnit, CodegenUnitNameBuilder, MonoItem};\n use rustc_middle::ty::layout::{HasTyCtxt, LayoutOf, TyAndLayout};\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::{self, Instance, Ty, TyCtxt};\n use rustc_session::cgu_reuse_tracker::CguReuse;\n-use rustc_session::config::{self, EntryFnType};\n+use rustc_session::config::{self, EntryFnType, OutputType};\n use rustc_session::Session;\n use rustc_span::symbol::sym;\n use rustc_target::abi::{Align, VariantIdx};\n@@ -491,7 +493,7 @@ pub fn codegen_crate<B: ExtraBackendMethods>(\n ) -> OngoingCodegen<B> {\n     // Skip crate items and just output metadata in -Z no-codegen mode.\n     if tcx.sess.opts.debugging_opts.no_codegen || !tcx.sess.opts.output_types.should_codegen() {\n-        let ongoing_codegen = start_async_codegen(backend, tcx, target_cpu, metadata, 1);\n+        let ongoing_codegen = start_async_codegen(backend, tcx, target_cpu, metadata, None, 1);\n \n         ongoing_codegen.codegen_finished(tcx);\n \n@@ -517,8 +519,41 @@ pub fn codegen_crate<B: ExtraBackendMethods>(\n         }\n     }\n \n-    let ongoing_codegen =\n-        start_async_codegen(backend.clone(), tcx, target_cpu, metadata, codegen_units.len());\n+    let metadata_module = if need_metadata_module {\n+        // Emit compressed metadata object.\n+        let metadata_cgu_name =\n+            cgu_name_builder.build_cgu_name(LOCAL_CRATE, &[\"crate\"], Some(\"metadata\")).to_string();\n+        tcx.sess.time(\"write_compressed_metadata\", || {\n+            let file_name =\n+                tcx.output_filenames(()).temp_path(OutputType::Metadata, Some(&metadata_cgu_name));\n+            let data = create_compressed_metadata_file(\n+                tcx.sess,\n+                &metadata,\n+                &exported_symbols::metadata_symbol_name(tcx),\n+            );\n+            if let Err(err) = std::fs::write(&file_name, data) {\n+                tcx.sess.fatal(&format!(\"error writing metadata object file: {}\", err));\n+            }\n+            Some(CompiledModule {\n+                name: metadata_cgu_name,\n+                kind: ModuleKind::Metadata,\n+                object: Some(file_name),\n+                dwarf_object: None,\n+                bytecode: None,\n+            })\n+        })\n+    } else {\n+        None\n+    };\n+\n+    let ongoing_codegen = start_async_codegen(\n+        backend.clone(),\n+        tcx,\n+        target_cpu,\n+        metadata,\n+        metadata_module,\n+        codegen_units.len(),\n+    );\n     let ongoing_codegen = AbortCodegenOnDrop::<B>(Some(ongoing_codegen));\n \n     // Codegen an allocator shim, if necessary.\n@@ -558,27 +593,6 @@ pub fn codegen_crate<B: ExtraBackendMethods>(\n         ongoing_codegen.submit_pre_codegened_module_to_llvm(tcx, allocator_module);\n     }\n \n-    if need_metadata_module {\n-        // Codegen the encoded metadata.\n-        let metadata_cgu_name =\n-            cgu_name_builder.build_cgu_name(LOCAL_CRATE, &[\"crate\"], Some(\"metadata\")).to_string();\n-        let mut metadata_llvm_module = backend.new_metadata(tcx, &metadata_cgu_name);\n-        tcx.sess.time(\"write_compressed_metadata\", || {\n-            backend.write_compressed_metadata(\n-                tcx,\n-                &ongoing_codegen.metadata,\n-                &mut metadata_llvm_module,\n-            );\n-        });\n-\n-        let metadata_module = ModuleCodegen {\n-            name: metadata_cgu_name,\n-            module_llvm: metadata_llvm_module,\n-            kind: ModuleKind::Metadata,\n-        };\n-        ongoing_codegen.submit_pre_codegened_module_to_llvm(tcx, metadata_module);\n-    }\n-\n     // For better throughput during parallel processing by LLVM, we used to sort\n     // CGUs largest to smallest. This would lead to better thread utilization\n     // by, for example, preventing a large CGU from being processed last and"}, {"sha": "707561f5ebd0f0fed0ce88fa4ad5e9b46d799a55", "filename": "compiler/rustc_codegen_ssa/src/traits/backend.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f9e77f2b460492013cea459221194318b7fd8204/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fbackend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9e77f2b460492013cea459221194318b7fd8204/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fbackend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fbackend.rs?ref=f9e77f2b460492013cea459221194318b7fd8204", "patch": "@@ -114,12 +114,6 @@ pub trait CodegenBackend {\n \n pub trait ExtraBackendMethods: CodegenBackend + WriteBackendMethods + Sized + Send + Sync {\n     fn new_metadata(&self, sess: TyCtxt<'_>, mod_name: &str) -> Self::Module;\n-    fn write_compressed_metadata<'tcx>(\n-        &self,\n-        tcx: TyCtxt<'tcx>,\n-        metadata: &EncodedMetadata,\n-        llvm_module: &mut Self::Module,\n-    );\n     fn codegen_allocator<'tcx>(\n         &self,\n         tcx: TyCtxt<'tcx>,"}]}