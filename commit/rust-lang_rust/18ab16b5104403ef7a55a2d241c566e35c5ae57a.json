{"sha": "18ab16b5104403ef7a55a2d241c566e35c5ae57a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE4YWIxNmI1MTA0NDAzZWY3YTU1YTJkMjQxYzU2NmUzNWM1YWU1N2E=", "commit": {"author": {"name": "Simon Sapin", "email": "simon.sapin@exyr.org", "date": "2018-04-10T14:36:23Z"}, "committer": {"name": "Simon Sapin", "email": "simon.sapin@exyr.org", "date": "2018-04-21T07:47:37Z"}, "message": "Move intrinsics-based float methods out of libcore into libstd\n\nAffected methods are `abs`, `signum`, and `powi`.\nCC https://github.com/rust-lang/rust/issues/32110#issuecomment-379503183", "tree": {"sha": "7f2f5f8a80067698befb742e0f99720a0fd1fa29", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7f2f5f8a80067698befb742e0f99720a0fd1fa29"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/18ab16b5104403ef7a55a2d241c566e35c5ae57a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/18ab16b5104403ef7a55a2d241c566e35c5ae57a", "html_url": "https://github.com/rust-lang/rust/commit/18ab16b5104403ef7a55a2d241c566e35c5ae57a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/18ab16b5104403ef7a55a2d241c566e35c5ae57a/comments", "author": {"login": "SimonSapin", "id": 291359, "node_id": "MDQ6VXNlcjI5MTM1OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/291359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimonSapin", "html_url": "https://github.com/SimonSapin", "followers_url": "https://api.github.com/users/SimonSapin/followers", "following_url": "https://api.github.com/users/SimonSapin/following{/other_user}", "gists_url": "https://api.github.com/users/SimonSapin/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimonSapin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimonSapin/subscriptions", "organizations_url": "https://api.github.com/users/SimonSapin/orgs", "repos_url": "https://api.github.com/users/SimonSapin/repos", "events_url": "https://api.github.com/users/SimonSapin/events{/privacy}", "received_events_url": "https://api.github.com/users/SimonSapin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "SimonSapin", "id": 291359, "node_id": "MDQ6VXNlcjI5MTM1OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/291359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimonSapin", "html_url": "https://github.com/SimonSapin", "followers_url": "https://api.github.com/users/SimonSapin/followers", "following_url": "https://api.github.com/users/SimonSapin/following{/other_user}", "gists_url": "https://api.github.com/users/SimonSapin/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimonSapin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimonSapin/subscriptions", "organizations_url": "https://api.github.com/users/SimonSapin/orgs", "repos_url": "https://api.github.com/users/SimonSapin/repos", "events_url": "https://api.github.com/users/SimonSapin/events{/privacy}", "received_events_url": "https://api.github.com/users/SimonSapin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8a374f2827a222322a631e313cd8fd8d9ba34932", "url": "https://api.github.com/repos/rust-lang/rust/commits/8a374f2827a222322a631e313cd8fd8d9ba34932", "html_url": "https://github.com/rust-lang/rust/commit/8a374f2827a222322a631e313cd8fd8d9ba34932"}], "stats": {"total": 158, "additions": 54, "deletions": 104}, "files": [{"sha": "8d5f6f601daf8a3c0eebc46cadc9124c7219700c", "filename": "src/libcore/num/f32.rs", "status": "modified", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/18ab16b5104403ef7a55a2d241c566e35c5ae57a/src%2Flibcore%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18ab16b5104403ef7a55a2d241c566e35c5ae57a/src%2Flibcore%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff32.rs?ref=18ab16b5104403ef7a55a2d241c566e35c5ae57a", "patch": "@@ -17,7 +17,6 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n-use intrinsics;\n use mem;\n use num::Float;\n #[cfg(not(stage0))] use num::FpCategory;\n@@ -189,27 +188,6 @@ impl Float for f32 {\n         }\n     }\n \n-    /// Computes the absolute value of `self`. Returns `Float::nan()` if the\n-    /// number is `Float::nan()`.\n-    #[inline]\n-    fn abs(self) -> f32 {\n-        unsafe { intrinsics::fabsf32(self) }\n-    }\n-\n-    /// Returns a number that represents the sign of `self`.\n-    ///\n-    /// - `1.0` if the number is positive, `+0.0` or `Float::infinity()`\n-    /// - `-1.0` if the number is negative, `-0.0` or `Float::neg_infinity()`\n-    /// - `Float::nan()` if the number is `Float::nan()`\n-    #[inline]\n-    fn signum(self) -> f32 {\n-        if self.is_nan() {\n-            NAN\n-        } else {\n-            unsafe { intrinsics::copysignf32(1.0, self) }\n-        }\n-    }\n-\n     /// Returns `true` if and only if `self` has a positive sign, including `+0.0`, `NaN`s with\n     /// positive sign bit and positive infinity.\n     #[inline]\n@@ -232,11 +210,6 @@ impl Float for f32 {\n         1.0 / self\n     }\n \n-    #[inline]\n-    fn powi(self, n: i32) -> f32 {\n-        unsafe { intrinsics::powif32(self, n) }\n-    }\n-\n     /// Converts to degrees, assuming the number is in radians.\n     #[inline]\n     fn to_degrees(self) -> f32 {"}, {"sha": "08b869734d49627099a649553567dd660159b4ca", "filename": "src/libcore/num/f64.rs", "status": "modified", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/18ab16b5104403ef7a55a2d241c566e35c5ae57a/src%2Flibcore%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18ab16b5104403ef7a55a2d241c566e35c5ae57a/src%2Flibcore%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff64.rs?ref=18ab16b5104403ef7a55a2d241c566e35c5ae57a", "patch": "@@ -17,7 +17,6 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n-use intrinsics;\n use mem;\n use num::Float;\n #[cfg(not(stage0))] use num::FpCategory;\n@@ -189,27 +188,6 @@ impl Float for f64 {\n         }\n     }\n \n-    /// Computes the absolute value of `self`. Returns `Float::nan()` if the\n-    /// number is `Float::nan()`.\n-    #[inline]\n-    fn abs(self) -> f64 {\n-        unsafe { intrinsics::fabsf64(self) }\n-    }\n-\n-    /// Returns a number that represents the sign of `self`.\n-    ///\n-    /// - `1.0` if the number is positive, `+0.0` or `Float::infinity()`\n-    /// - `-1.0` if the number is negative, `-0.0` or `Float::neg_infinity()`\n-    /// - `Float::nan()` if the number is `Float::nan()`\n-    #[inline]\n-    fn signum(self) -> f64 {\n-        if self.is_nan() {\n-            NAN\n-        } else {\n-            unsafe { intrinsics::copysignf64(1.0, self) }\n-        }\n-    }\n-\n     /// Returns `true` if and only if `self` has a positive sign, including `+0.0`, `NaN`s with\n     /// positive sign bit and positive infinity.\n     #[inline]\n@@ -230,11 +208,6 @@ impl Float for f64 {\n         1.0 / self\n     }\n \n-    #[inline]\n-    fn powi(self, n: i32) -> f64 {\n-        unsafe { intrinsics::powif64(self, n) }\n-    }\n-\n     /// Converts to degrees, assuming the number is in radians.\n     #[inline]\n     fn to_degrees(self) -> f64 {"}, {"sha": "55fad62d8710c3bb3b0aaad7203a061c7257c5ee", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/18ab16b5104403ef7a55a2d241c566e35c5ae57a/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18ab16b5104403ef7a55a2d241c566e35c5ae57a/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=18ab16b5104403ef7a55a2d241c566e35c5ae57a", "patch": "@@ -4125,18 +4125,6 @@ pub trait Float: Sized {\n     #[stable(feature = \"core\", since = \"1.6.0\")]\n     fn classify(self) -> FpCategory;\n \n-    /// Computes the absolute value of `self`. Returns `Float::nan()` if the\n-    /// number is `Float::nan()`.\n-    #[stable(feature = \"core\", since = \"1.6.0\")]\n-    fn abs(self) -> Self;\n-    /// Returns a number that represents the sign of `self`.\n-    ///\n-    /// - `1.0` if the number is positive, `+0.0` or `Float::infinity()`\n-    /// - `-1.0` if the number is negative, `-0.0` or `Float::neg_infinity()`\n-    /// - `Float::nan()` if the number is `Float::nan()`\n-    #[stable(feature = \"core\", since = \"1.6.0\")]\n-    fn signum(self) -> Self;\n-\n     /// Returns `true` if `self` is positive, including `+0.0` and\n     /// `Float::infinity()`.\n     #[stable(feature = \"core\", since = \"1.6.0\")]\n@@ -4150,12 +4138,6 @@ pub trait Float: Sized {\n     #[stable(feature = \"core\", since = \"1.6.0\")]\n     fn recip(self) -> Self;\n \n-    /// Raise a number to an integer power.\n-    ///\n-    /// Using this function is generally faster than using `powf`\n-    #[stable(feature = \"core\", since = \"1.6.0\")]\n-    fn powi(self, n: i32) -> Self;\n-\n     /// Convert radians to degrees.\n     #[stable(feature = \"deg_rad_conversions\", since=\"1.7.0\")]\n     fn to_degrees(self) -> Self;"}, {"sha": "e3f7ff5cb3f74406c4bf809adf29e31716e63e28", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/18ab16b5104403ef7a55a2d241c566e35c5ae57a/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18ab16b5104403ef7a55a2d241c566e35c5ae57a/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=18ab16b5104403ef7a55a2d241c566e35c5ae57a", "patch": "@@ -4526,23 +4526,23 @@ but the type of the numeric value or binding could not be identified.\n The error happens on numeric literals:\n \n ```compile_fail,E0689\n-2.0.powi(2);\n+2.0.recip();\n ```\n \n and on numeric bindings without an identified concrete type:\n \n ```compile_fail,E0689\n let x = 2.0;\n-x.powi(2);  // same error as above\n+x.recip();  // same error as above\n ```\n \n Because of this, you must give the numeric literal or binding a type:\n \n ```\n-let _ = 2.0_f32.powi(2);\n+let _ = 2.0_f32.recip();\n let x: f32 = 2.0;\n-let _ = x.powi(2);\n-let _ = (2.0 as f32).powi(2);\n+let _ = x.recip();\n+let _ = (2.0 as f32).recip();\n ```\n \"##,\n "}, {"sha": "26644c769575c9bde37dd88e9af0a9077e2f54a9", "filename": "src/libstd/f32.rs", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/18ab16b5104403ef7a55a2d241c566e35c5ae57a/src%2Flibstd%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18ab16b5104403ef7a55a2d241c566e35c5ae57a/src%2Flibstd%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ff32.rs?ref=18ab16b5104403ef7a55a2d241c566e35c5ae57a", "patch": "@@ -19,6 +19,7 @@\n #![allow(missing_docs)]\n \n #[cfg(not(test))]\n+#[cfg(stage0)]\n use core::num::Float;\n #[cfg(not(test))]\n use intrinsics;\n@@ -163,7 +164,9 @@ impl f32 {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn abs(self) -> f32 { Float::abs(self) }\n+    pub fn abs(self) -> f32 {\n+        unsafe { intrinsics::fabsf32(self) }\n+    }\n \n     /// Returns a number that represents the sign of `self`.\n     ///\n@@ -183,7 +186,13 @@ impl f32 {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn signum(self) -> f32 { Float::signum(self) }\n+    pub fn signum(self) -> f32 {\n+        if self.is_nan() {\n+            NAN\n+        } else {\n+            unsafe { intrinsics::copysignf32(1.0, self) }\n+        }\n+    }\n \n     /// Fused multiply-add. Computes `(self * a) + b` with only one rounding\n     /// error. This produces a more accurate result with better performance than\n@@ -272,7 +281,9 @@ impl f32 {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn powi(self, n: i32) -> f32 { Float::powi(self, n) }\n+    pub fn powi(self, n: i32) -> f32 {\n+        unsafe { intrinsics::powif32(self, n) }\n+    }\n \n     /// Raises a number to a floating point power.\n     ///"}, {"sha": "a7e63f59b1c67369e8bb1b1009bc950c813b95d7", "filename": "src/libstd/f64.rs", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/18ab16b5104403ef7a55a2d241c566e35c5ae57a/src%2Flibstd%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18ab16b5104403ef7a55a2d241c566e35c5ae57a/src%2Flibstd%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ff64.rs?ref=18ab16b5104403ef7a55a2d241c566e35c5ae57a", "patch": "@@ -19,6 +19,7 @@\n #![allow(missing_docs)]\n \n #[cfg(not(test))]\n+#[cfg(stage0)]\n use core::num::Float;\n #[cfg(not(test))]\n use intrinsics;\n@@ -141,7 +142,9 @@ impl f64 {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn abs(self) -> f64 { Float::abs(self) }\n+    pub fn abs(self) -> f64 {\n+        unsafe { intrinsics::fabsf64(self) }\n+    }\n \n     /// Returns a number that represents the sign of `self`.\n     ///\n@@ -161,7 +164,13 @@ impl f64 {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn signum(self) -> f64 { Float::signum(self) }\n+    pub fn signum(self) -> f64 {\n+        if self.is_nan() {\n+            NAN\n+        } else {\n+            unsafe { intrinsics::copysignf64(1.0, self) }\n+        }\n+    }\n \n     /// Fused multiply-add. Computes `(self * a) + b` with only one rounding\n     /// error. This produces a more accurate result with better performance than\n@@ -245,7 +254,9 @@ impl f64 {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn powi(self, n: i32) -> f64 { Float::powi(self, n) }\n+    pub fn powi(self, n: i32) -> f64 {\n+        unsafe { intrinsics::powif64(self, n) }\n+    }\n \n     /// Raises a number to a floating point power.\n     ///"}, {"sha": "090ff817eb0f2cf89321767645756f61836cd6ab", "filename": "src/test/ui/macros/macro-backtrace-invalid-internals.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/18ab16b5104403ef7a55a2d241c566e35c5ae57a/src%2Ftest%2Fui%2Fmacros%2Fmacro-backtrace-invalid-internals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18ab16b5104403ef7a55a2d241c566e35c5ae57a/src%2Ftest%2Fui%2Fmacros%2Fmacro-backtrace-invalid-internals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fmacro-backtrace-invalid-internals.rs?ref=18ab16b5104403ef7a55a2d241c566e35c5ae57a", "patch": "@@ -48,13 +48,13 @@ macro_rules! fake_anon_field_expr {\n \n macro_rules! real_method_stmt {\n      () => {\n-          2.0.powi(2) //~ ERROR can't call method `powi` on ambiguous numeric type `{float}`\n+          2.0.recip() //~ ERROR can't call method `recip` on ambiguous numeric type `{float}`\n      }\n }\n \n macro_rules! real_method_expr {\n      () => {\n-          2.0.powi(2) //~ ERROR can't call method `powi` on ambiguous numeric type `{float}`\n+          2.0.recip() //~ ERROR can't call method `recip` on ambiguous numeric type `{float}`\n      }\n }\n "}, {"sha": "284960d2f6e154135b7fa33dcd5cce1b5a221b5c", "filename": "src/test/ui/macros/macro-backtrace-invalid-internals.stderr", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/18ab16b5104403ef7a55a2d241c566e35c5ae57a/src%2Ftest%2Fui%2Fmacros%2Fmacro-backtrace-invalid-internals.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/18ab16b5104403ef7a55a2d241c566e35c5ae57a/src%2Ftest%2Fui%2Fmacros%2Fmacro-backtrace-invalid-internals.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fmacro-backtrace-invalid-internals.stderr?ref=18ab16b5104403ef7a55a2d241c566e35c5ae57a", "patch": "@@ -25,17 +25,17 @@ LL |           (1).0 //~ ERROR doesn't have fields\n LL |     fake_anon_field_stmt!();\n    |     ------------------------ in this macro invocation\n \n-error[E0689]: can't call method `powi` on ambiguous numeric type `{float}`\n+error[E0689]: can't call method `recip` on ambiguous numeric type `{float}`\n   --> $DIR/macro-backtrace-invalid-internals.rs:51:15\n    |\n-LL |           2.0.powi(2) //~ ERROR can't call method `powi` on ambiguous numeric type `{float}`\n-   |               ^^^^\n+LL |           2.0.recip() //~ ERROR can't call method `recip` on ambiguous numeric type `{float}`\n+   |               ^^^^^\n ...\n LL |     real_method_stmt!();\n    |     -------------------- in this macro invocation\n help: you must specify a concrete type for this numeric value, like `f32`\n    |\n-LL |           2.0_f32.powi(2) //~ ERROR can't call method `powi` on ambiguous numeric type `{float}`\n+LL |           2.0_f32.recip() //~ ERROR can't call method `recip` on ambiguous numeric type `{float}`\n    |           ^^^^^^^\n \n error[E0599]: no method named `fake` found for type `{integer}` in the current scope\n@@ -65,17 +65,17 @@ LL |           (1).0 //~ ERROR doesn't have fields\n LL |     let _ = fake_anon_field_expr!();\n    |             ----------------------- in this macro invocation\n \n-error[E0689]: can't call method `powi` on ambiguous numeric type `{float}`\n+error[E0689]: can't call method `recip` on ambiguous numeric type `{float}`\n   --> $DIR/macro-backtrace-invalid-internals.rs:57:15\n    |\n-LL |           2.0.powi(2) //~ ERROR can't call method `powi` on ambiguous numeric type `{float}`\n-   |               ^^^^\n+LL |           2.0.recip() //~ ERROR can't call method `recip` on ambiguous numeric type `{float}`\n+   |               ^^^^^\n ...\n LL |     let _ = real_method_expr!();\n    |             ------------------- in this macro invocation\n help: you must specify a concrete type for this numeric value, like `f32`\n    |\n-LL |           2.0_f32.powi(2) //~ ERROR can't call method `powi` on ambiguous numeric type `{float}`\n+LL |           2.0_f32.recip() //~ ERROR can't call method `recip` on ambiguous numeric type `{float}`\n    |           ^^^^^^^\n \n error: aborting due to 8 previous errors"}, {"sha": "2e452f9671f380fd21b3b9e073359a80579c1ba4", "filename": "src/test/ui/suggestions/method-on-ambiguous-numeric-type.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/18ab16b5104403ef7a55a2d241c566e35c5ae57a/src%2Ftest%2Fui%2Fsuggestions%2Fmethod-on-ambiguous-numeric-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18ab16b5104403ef7a55a2d241c566e35c5ae57a/src%2Ftest%2Fui%2Fsuggestions%2Fmethod-on-ambiguous-numeric-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fmethod-on-ambiguous-numeric-type.rs?ref=18ab16b5104403ef7a55a2d241c566e35c5ae57a", "patch": "@@ -9,10 +9,10 @@\n // except according to those terms.\n \n fn main() {\n-    let x = 2.0.powi(2);\n-    //~^ ERROR can't call method `powi` on ambiguous numeric type `{float}`\n+    let x = 2.0.recip();\n+    //~^ ERROR can't call method `recip` on ambiguous numeric type `{float}`\n     let y = 2.0;\n-    let x = y.powi(2);\n-    //~^ ERROR can't call method `powi` on ambiguous numeric type `{float}`\n+    let x = y.recip();\n+    //~^ ERROR can't call method `recip` on ambiguous numeric type `{float}`\n     println!(\"{:?}\", x);\n }"}, {"sha": "477b4c3821d51bc2f9aa5cc982a677a3919d59ee", "filename": "src/test/ui/suggestions/method-on-ambiguous-numeric-type.stderr", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/18ab16b5104403ef7a55a2d241c566e35c5ae57a/src%2Ftest%2Fui%2Fsuggestions%2Fmethod-on-ambiguous-numeric-type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/18ab16b5104403ef7a55a2d241c566e35c5ae57a/src%2Ftest%2Fui%2Fsuggestions%2Fmethod-on-ambiguous-numeric-type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fmethod-on-ambiguous-numeric-type.stderr?ref=18ab16b5104403ef7a55a2d241c566e35c5ae57a", "patch": "@@ -1,18 +1,18 @@\n-error[E0689]: can't call method `powi` on ambiguous numeric type `{float}`\n+error[E0689]: can't call method `recip` on ambiguous numeric type `{float}`\n   --> $DIR/method-on-ambiguous-numeric-type.rs:12:17\n    |\n-LL |     let x = 2.0.powi(2);\n-   |                 ^^^^\n+LL |     let x = 2.0.recip();\n+   |                 ^^^^^\n help: you must specify a concrete type for this numeric value, like `f32`\n    |\n-LL |     let x = 2.0_f32.powi(2);\n+LL |     let x = 2.0_f32.recip();\n    |             ^^^^^^^\n \n-error[E0689]: can't call method `powi` on ambiguous numeric type `{float}`\n+error[E0689]: can't call method `recip` on ambiguous numeric type `{float}`\n   --> $DIR/method-on-ambiguous-numeric-type.rs:15:15\n    |\n-LL |     let x = y.powi(2);\n-   |               ^^^^\n+LL |     let x = y.recip();\n+   |               ^^^^^\n help: you must specify a type for this binding, like `f32`\n    |\n LL |     let y: f32 = 2.0;"}]}