{"sha": "5638847ae30773dfd36dbeb57c8293a854f5075a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU2Mzg4NDdhZTMwNzczZGZkMzZkYmViNTdjODI5M2E4NTRmNTA3NWE=", "commit": {"author": {"name": "Simonas Kazlauskas", "email": "git@kazlauskas.me", "date": "2016-02-02T20:50:26Z"}, "committer": {"name": "Simonas Kazlauskas", "email": "git@kazlauskas.me", "date": "2016-02-04T13:56:05Z"}, "message": "Address nits on build/scope.rs", "tree": {"sha": "86962b15d8b37766413ef377c777e89c978cedb7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/86962b15d8b37766413ef377c777e89c978cedb7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5638847ae30773dfd36dbeb57c8293a854f5075a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5638847ae30773dfd36dbeb57c8293a854f5075a", "html_url": "https://github.com/rust-lang/rust/commit/5638847ae30773dfd36dbeb57c8293a854f5075a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5638847ae30773dfd36dbeb57c8293a854f5075a/comments", "author": {"login": "nagisa", "id": 679122, "node_id": "MDQ6VXNlcjY3OTEyMg==", "avatar_url": "https://avatars.githubusercontent.com/u/679122?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nagisa", "html_url": "https://github.com/nagisa", "followers_url": "https://api.github.com/users/nagisa/followers", "following_url": "https://api.github.com/users/nagisa/following{/other_user}", "gists_url": "https://api.github.com/users/nagisa/gists{/gist_id}", "starred_url": "https://api.github.com/users/nagisa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nagisa/subscriptions", "organizations_url": "https://api.github.com/users/nagisa/orgs", "repos_url": "https://api.github.com/users/nagisa/repos", "events_url": "https://api.github.com/users/nagisa/events{/privacy}", "received_events_url": "https://api.github.com/users/nagisa/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nagisa", "id": 679122, "node_id": "MDQ6VXNlcjY3OTEyMg==", "avatar_url": "https://avatars.githubusercontent.com/u/679122?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nagisa", "html_url": "https://github.com/nagisa", "followers_url": "https://api.github.com/users/nagisa/followers", "following_url": "https://api.github.com/users/nagisa/following{/other_user}", "gists_url": "https://api.github.com/users/nagisa/gists{/gist_id}", "starred_url": "https://api.github.com/users/nagisa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nagisa/subscriptions", "organizations_url": "https://api.github.com/users/nagisa/orgs", "repos_url": "https://api.github.com/users/nagisa/repos", "events_url": "https://api.github.com/users/nagisa/events{/privacy}", "received_events_url": "https://api.github.com/users/nagisa/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ebf6341d1dfe57a7ad6f7f87501b018ffe24bba8", "url": "https://api.github.com/repos/rust-lang/rust/commits/ebf6341d1dfe57a7ad6f7f87501b018ffe24bba8", "html_url": "https://github.com/rust-lang/rust/commit/ebf6341d1dfe57a7ad6f7f87501b018ffe24bba8"}], "stats": {"total": 242, "additions": 141, "deletions": 101}, "files": [{"sha": "27654127a6c24c6ac89abdf732bfed2a8ce31f26", "filename": "src/librustc_mir/build/scope.rs", "status": "modified", "additions": 141, "deletions": 101, "changes": 242, "blob_url": "https://github.com/rust-lang/rust/blob/5638847ae30773dfd36dbeb57c8293a854f5075a/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5638847ae30773dfd36dbeb57c8293a854f5075a/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fscope.rs?ref=5638847ae30773dfd36dbeb57c8293a854f5075a", "patch": "@@ -101,11 +101,18 @@ pub struct Scope<'tcx> {\n     // A scope may only have one associated free, because:\n     // 1. We require a `free` to only be scheduled in the scope of `EXPR` in `box EXPR`;\n     // 2. It only makes sense to have it translated into the diverge-path.\n+    //\n+    // This kind of drop will be run *after* all the regular drops scheduled onto this scope,\n+    // because drops may have dependencies on the allocated memory.\n+    //\n+    // This is expected to go away once `box EXPR` becomes a sugar for placement protocol and gets\n+    // desugared in some earlier stage.\n     free: Option<FreeData<'tcx>>,\n }\n \n struct DropData<'tcx> {\n     value: Lvalue<'tcx>,\n+    // NB: per-drop \u201ccache\u201d is necessary for the build_scope_drops function below.\n     /// The cached block for the cleanups-on-diverge path. This block contains code to run the\n     /// current drop and all the preceding drops (i.e. those having lower index in Drop\u2019s\n     /// Scope drop array)\n@@ -137,28 +144,30 @@ pub struct LoopScope {\n }\n \n impl<'tcx> Scope<'tcx> {\n-    /// Invalidate cached blocks in the scope. Should always be run for all inner scopes when a\n-    /// drop is pushed into some scope enclosing a larger extent of code.\n-    fn invalidate_cache(&mut self, only_free: bool) {\n+    /// Invalidate all the cached blocks in the scope.\n+    ///\n+    /// Should always be run for all inner scopes when a drop is pushed into some scope enclosing a\n+    /// larger extent of code.\n+    fn invalidate_cache(&mut self) {\n+        for dropdata in &mut self.drops {\n+            dropdata.cached_block = None;\n+        }\n         if let Some(ref mut freedata) = self.free {\n             freedata.cached_block = None;\n         }\n-        if !only_free {\n-            for dropdata in &mut self.drops {\n-                dropdata.cached_block = None;\n-            }\n-        }\n     }\n \n     /// Returns the cached block for this scope.\n     ///\n     /// Precondition: the caches must be fully filled (i.e. diverge_cleanup is called) in order for\n     /// this method to work correctly.\n     fn cached_block(&self) -> Option<BasicBlock> {\n-        if let Some(ref free_data) = self.free {\n-            free_data.cached_block\n+        if let Some(data) = self.drops.last() {\n+            Some(data.cached_block.expect(\"drop cache is not filled\"))\n+        } else if let Some(ref data) = self.free {\n+            Some(data.cached_block.expect(\"free cache is not filled\"))\n         } else {\n-            self.drops.last().iter().flat_map(|dd| dd.cached_block).next()\n+            None\n         }\n     }\n }\n@@ -297,18 +306,17 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n         }\n         for scope in self.scopes.iter_mut().rev() {\n             if scope.extent == extent {\n-                // We only invalidate cached block of free here; all other drops\u2019 cached blocks to\n-                // not become invalid (this drop will branch into them).\n-                scope.invalidate_cache(true);\n+                // No need to invalidate any caches here. The just-scheduled drop will branch into\n+                // the drop that comes before it in the vector.\n                 scope.drops.push(DropData {\n                     value: lvalue.clone(),\n                     cached_block: None\n                 });\n                 return;\n             } else {\n                 // We must invalidate all the cached_blocks leading up to the scope we\u2019re\n-                // looking for, because all of the blocks in the chain become incorrect.\n-                scope.invalidate_cache(false)\n+                // looking for, because all of the blocks in the chain will become incorrect.\n+                scope.invalidate_cache()\n             }\n         }\n         self.hir.span_bug(span,\n@@ -328,6 +336,9 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n         for scope in self.scopes.iter_mut().rev() {\n             if scope.extent == extent {\n                 assert!(scope.free.is_none(), \"scope already has a scheduled free!\");\n+                // We also must invalidate the caches in the scope for which the free is scheduled\n+                // because the drops must branch into the free we schedule here.\n+                scope.invalidate_cache();\n                 scope.free = Some(FreeData {\n                     span: span,\n                     value: value.clone(),\n@@ -337,9 +348,9 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                 return;\n             } else {\n                 // We must invalidate all the cached_blocks leading up to the scope we\u2019re looking\n-                // for, because otherwise some/most of the blocks in the chain might become\n+                // for, because otherwise some/most of the blocks in the chain will become\n                 // incorrect.\n-                scope.invalidate_cache(false);\n+                scope.invalidate_cache();\n             }\n         }\n         self.hir.span_bug(span,\n@@ -357,95 +368,20 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n         if self.scopes.is_empty() {\n             return None;\n         }\n-\n-        let unit_tmp = self.get_unit_temp();\n-        let Builder { ref mut scopes, ref mut cfg, ref mut hir, .. } = *self;\n-\n-        let tcx = hir.tcx();\n+        let unit_temp = self.get_unit_temp();\n+        let Builder { ref mut hir, ref mut cfg, ref mut scopes, .. } = *self;\n         let mut next_block = None;\n \n         // Given an array of scopes, we generate these from the outermost scope to the innermost\n         // one. Thus for array [S0, S1, S2] with corresponding cleanup blocks [B0, B1, B2], we will\n         // generate B0 <- B1 <- B2 in left-to-right order. Control flow of the generated blocks\n         // always ends up at a block with the Resume terminator.\n-        //\n-        // Similarly to the scopes, we translate drops so:\n-        // * Scheduled free drop is executed first;\n-        // * Drops are executed after the free drop in the decreasing order (decreasing as\n-        // from higher index in drops array to lower index);\n-        //\n-        // NB: We do the building backwards here. We will first produce a block containing the\n-        // Resume terminator (which is executed last for any given chain of cleanups) and then go\n-        // on building the drops from the outermost one to the innermost one. Similar note applies\n-        // to the drops within the scope too.\n-        {\n-        let iter = scopes.iter_mut().filter(|s| !s.drops.is_empty() || s.free.is_some());\n-        for scope in iter {\n-            // Try using the cached free drop if any\u2026\n-            if let Some(FreeData { cached_block: Some(cached_block), .. }) = scope.free {\n-                next_block = Some(cached_block);\n-                continue;\n-            }\n-            // otherwise look for the cached regular drop (fast path)\u2026\n-            if let Some(&DropData { cached_block: Some(cached_block), .. }) = scope.drops.last() {\n-                next_block = Some(cached_block);\n-                continue;\n-            }\n-            // otherwise build the blocks\u2026\n-            for drop_data in scope.drops.iter_mut() {\n-                // skipping them if they\u2019re already built\u2026\n-                if let Some(cached_block) = drop_data.cached_block {\n-                    next_block = Some(cached_block);\n-                    continue;\n-                }\n-                let block = cfg.start_new_cleanup_block();\n-                let target = next_block.unwrap_or_else(|| {\n-                    let b = cfg.start_new_cleanup_block();\n-                    cfg.terminate(b, Terminator::Resume);\n-                    b\n-                });\n-                cfg.terminate(block, Terminator::Drop {\n-                    value: drop_data.value.clone(),\n-                    target: target,\n-                    unwind: None\n-                });\n-                drop_data.cached_block = Some(block);\n-                next_block = Some(block);\n-            }\n-\n-            if let Some(ref mut free_data) = scope.free {\n-                // The free was not cached yet. It must be translated the last and will be executed\n-                // first.\n-                let free_func = tcx.lang_items.box_free_fn()\n-                                   .expect(\"box_free language item is missing\");\n-                let substs = tcx.mk_substs(Substs::new(\n-                    VecPerParamSpace::new(vec![], vec![], vec![free_data.item_ty]),\n-                    VecPerParamSpace::new(vec![], vec![], vec![])\n-                ));\n-                let block = cfg.start_new_cleanup_block();\n-                let target = next_block.unwrap_or_else(|| {\n-                    let b = cfg.start_new_cleanup_block();\n-                    cfg.terminate(b, Terminator::Resume);\n-                    b\n-                });\n-                cfg.terminate(block, Terminator::Call {\n-                    func: Operand::Constant(Constant {\n-                        span: free_data.span,\n-                        ty: tcx.lookup_item_type(free_func).ty.subst(tcx, substs),\n-                        literal: Literal::Item {\n-                            def_id: free_func,\n-                            kind: ItemKind::Function,\n-                            substs: substs\n-                        }\n-                    }),\n-                    args: vec![Operand::Consume(free_data.value.clone())],\n-                    destination: Some((unit_tmp.clone(), target)),\n-                    cleanup: None\n-                });\n-                free_data.cached_block = Some(block);\n-                next_block = Some(block);\n-            }\n-        }\n+        for scope in scopes.iter_mut().filter(|s| !s.drops.is_empty() || s.free.is_some()) {\n+            next_block = Some(build_diverge_scope(hir.tcx(),\n+                                                  cfg,\n+                                                  unit_temp.clone(),\n+                                                  scope,\n+                                                  next_block));\n         }\n         scopes.iter().rev().flat_map(|x| x.cached_block()).next()\n     }\n@@ -462,6 +398,7 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n         next_target.unit()\n     }\n \n+\n     // Panicking\n     // =========\n     // FIXME: should be moved into their own module\n@@ -596,3 +533,106 @@ fn build_scope_drops<'tcx>(mut block: BasicBlock,\n     }\n     block.unit()\n }\n+\n+fn build_diverge_scope<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                             cfg: &mut CFG<'tcx>,\n+                             unit_temp: Lvalue<'tcx>,\n+                             scope: &mut Scope<'tcx>,\n+                             target: Option<BasicBlock>)\n+                             -> BasicBlock {\n+    debug_assert!(!scope.drops.is_empty() || scope.free.is_some());\n+\n+    // First, we build the drops, iterating the drops array in reverse. We do that so that as soon\n+    // as we find a `cached_block`, we know that we\u2019re finished and don\u2019t need to do anything else.\n+    let mut previous = None;\n+    let mut last_drop_block = None;\n+    for drop_data in scope.drops.iter_mut().rev() {\n+        if let Some(cached_block) = drop_data.cached_block {\n+            if let Some((previous_block, previous_value)) = previous {\n+                cfg.terminate(previous_block, Terminator::Drop {\n+                    value: previous_value,\n+                    target: cached_block,\n+                    unwind: None\n+                });\n+                return last_drop_block.unwrap();\n+            } else {\n+                return cached_block;\n+            }\n+        } else {\n+            let block = cfg.start_new_cleanup_block();\n+            drop_data.cached_block = Some(block);\n+            if let Some((previous_block, previous_value)) = previous {\n+                cfg.terminate(previous_block, Terminator::Drop {\n+                    value: previous_value,\n+                    target: block,\n+                    unwind: None\n+                });\n+            } else {\n+                last_drop_block = Some(block);\n+            }\n+            previous = Some((block, drop_data.value.clone()));\n+        }\n+    }\n+\n+    // Prepare the end target for this chain.\n+    let mut target = target.unwrap_or_else(||{\n+        let b = cfg.start_new_cleanup_block();\n+        cfg.terminate(b, Terminator::Resume);\n+        b\n+    });\n+\n+    // Then, build the free branching into the prepared target.\n+    if let Some(ref mut free_data) = scope.free {\n+        target = if let Some(cached_block) = free_data.cached_block {\n+            cached_block\n+        } else {\n+            let t = build_free(tcx, cfg, unit_temp, free_data, target);\n+            free_data.cached_block = Some(t);\n+            t\n+        }\n+    };\n+\n+    if let Some((previous_block, previous_value)) = previous {\n+        // Finally, branch into that just-built `target` from the `previous_block`.\n+        cfg.terminate(previous_block, Terminator::Drop {\n+            value: previous_value,\n+            target: target,\n+            unwind: None\n+        });\n+        last_drop_block.unwrap()\n+    } else {\n+        // If `previous.is_none()`, there were no drops in this scope \u2013 we return the\n+        // target.\n+        target\n+    }\n+}\n+\n+fn build_free<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                    cfg: &mut CFG<'tcx>,\n+                    unit_temp: Lvalue<'tcx>,\n+                    data: &FreeData<'tcx>,\n+                    target: BasicBlock)\n+                    -> BasicBlock {\n+    let free_func = tcx.lang_items.box_free_fn()\n+                       .expect(\"box_free language item is missing\");\n+    let substs = tcx.mk_substs(Substs::new(\n+        VecPerParamSpace::new(vec![], vec![], vec![data.item_ty]),\n+        VecPerParamSpace::new(vec![], vec![], vec![])\n+    ));\n+    let block = cfg.start_new_cleanup_block();\n+    cfg.terminate(block, Terminator::Call {\n+        func: Operand::Constant(Constant {\n+            span: data.span,\n+            ty: tcx.lookup_item_type(free_func).ty.subst(tcx, substs),\n+            literal: Literal::Item {\n+                def_id: free_func,\n+                kind: ItemKind::Function,\n+                substs: substs\n+            }\n+        }),\n+        args: vec![Operand::Consume(data.value.clone())],\n+        destination: Some((unit_temp, target)),\n+        cleanup: None\n+    });\n+    block\n+}"}]}