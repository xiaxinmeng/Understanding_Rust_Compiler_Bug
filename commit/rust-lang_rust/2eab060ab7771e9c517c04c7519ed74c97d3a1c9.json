{"sha": "2eab060ab7771e9c517c04c7519ed74c97d3a1c9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJlYWIwNjBhYjc3NzFlOWM1MTdjMDRjNzUxOWVkNzRjOTdkM2ExYzk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-08-05T17:52:28Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-08-05T17:52:28Z"}, "message": "Auto merge of #5859 - ebroto:5765_manual_async_fn_fp, r=yaahc\n\nmanual_async_fn: take input lifetimes into account\n\nThe anonymous future returned from an `async fn` captures all input\nlifetimes. This was not being taken into account.\n\nSee https://github.com/rust-lang/rfcs/blob/master/text/2394-async_await.md#lifetime-capture-in-the-anonymous-future\n\nchangelog: Take input lifetimes into account in [`manual_async_fn`].\n\nFixes #5765", "tree": {"sha": "f73c7aff44ef0e58e7c8cd8eed6349e3936fb099", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f73c7aff44ef0e58e7c8cd8eed6349e3936fb099"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2eab060ab7771e9c517c04c7519ed74c97d3a1c9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2eab060ab7771e9c517c04c7519ed74c97d3a1c9", "html_url": "https://github.com/rust-lang/rust/commit/2eab060ab7771e9c517c04c7519ed74c97d3a1c9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2eab060ab7771e9c517c04c7519ed74c97d3a1c9/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3d7e3fdffd380d0d98f63e878b3ef9948b9452ca", "url": "https://api.github.com/repos/rust-lang/rust/commits/3d7e3fdffd380d0d98f63e878b3ef9948b9452ca", "html_url": "https://github.com/rust-lang/rust/commit/3d7e3fdffd380d0d98f63e878b3ef9948b9452ca"}, {"sha": "e336fe80d2f991a170b98190683039035b53c6ba", "url": "https://api.github.com/repos/rust-lang/rust/commits/e336fe80d2f991a170b98190683039035b53c6ba", "html_url": "https://github.com/rust-lang/rust/commit/e336fe80d2f991a170b98190683039035b53c6ba"}], "stats": {"total": 186, "additions": 146, "deletions": 40}, "files": [{"sha": "864d1ea87f57572d45fa9e8f7dfcc5063fd5b1d8", "filename": "clippy_lints/src/manual_async_fn.rs", "status": "modified", "additions": 52, "deletions": 11, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/2eab060ab7771e9c517c04c7519ed74c97d3a1c9/clippy_lints%2Fsrc%2Fmanual_async_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2eab060ab7771e9c517c04c7519ed74c97d3a1c9/clippy_lints%2Fsrc%2Fmanual_async_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmanual_async_fn.rs?ref=2eab060ab7771e9c517c04c7519ed74c97d3a1c9", "patch": "@@ -4,8 +4,8 @@ use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::intravisit::FnKind;\n use rustc_hir::{\n-    AsyncGeneratorKind, Block, Body, Expr, ExprKind, FnDecl, FnRetTy, GeneratorKind, GenericBound, HirId, IsAsync,\n-    ItemKind, TraitRef, Ty, TyKind, TypeBindingKind,\n+    AsyncGeneratorKind, Block, Body, Expr, ExprKind, FnDecl, FnRetTy, GeneratorKind, GenericArg, GenericBound, HirId,\n+    IsAsync, ItemKind, LifetimeName, TraitRef, Ty, TyKind, TypeBindingKind,\n };\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n@@ -27,8 +27,6 @@ declare_clippy_lint! {\n     /// ```\n     /// Use instead:\n     /// ```rust\n-    /// use std::future::Future;\n-    ///\n     /// async fn foo() -> i32 { 42 }\n     /// ```\n     pub MANUAL_ASYNC_FN,\n@@ -53,8 +51,9 @@ impl<'tcx> LateLintPass<'tcx> for ManualAsyncFn {\n             if let IsAsync::NotAsync = header.asyncness;\n             // Check that this function returns `impl Future`\n             if let FnRetTy::Return(ret_ty) = decl.output;\n-            if let Some(trait_ref) = future_trait_ref(cx, ret_ty);\n+            if let Some((trait_ref, output_lifetimes)) = future_trait_ref(cx, ret_ty);\n             if let Some(output) = future_output_ty(trait_ref);\n+            if captures_all_lifetimes(decl.inputs, &output_lifetimes);\n             // Check that the body of the function consists of one async block\n             if let ExprKind::Block(block, _) = body.value.kind;\n             if block.stmts.is_empty();\n@@ -97,16 +96,35 @@ impl<'tcx> LateLintPass<'tcx> for ManualAsyncFn {\n     }\n }\n \n-fn future_trait_ref<'tcx>(cx: &LateContext<'tcx>, ty: &'tcx Ty<'tcx>) -> Option<&'tcx TraitRef<'tcx>> {\n+fn future_trait_ref<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    ty: &'tcx Ty<'tcx>,\n+) -> Option<(&'tcx TraitRef<'tcx>, Vec<LifetimeName>)> {\n     if_chain! {\n-        if let TyKind::OpaqueDef(item_id, _) = ty.kind;\n+        if let TyKind::OpaqueDef(item_id, bounds) = ty.kind;\n         let item = cx.tcx.hir().item(item_id.id);\n         if let ItemKind::OpaqueTy(opaque) = &item.kind;\n-        if opaque.bounds.len() == 1;\n-        if let GenericBound::Trait(poly, _) = &opaque.bounds[0];\n-        if poly.trait_ref.trait_def_id() == cx.tcx.lang_items().future_trait();\n+        if let Some(trait_ref) = opaque.bounds.iter().find_map(|bound| {\n+            if let GenericBound::Trait(poly, _) = bound {\n+                Some(&poly.trait_ref)\n+            } else {\n+                None\n+            }\n+        });\n+        if trait_ref.trait_def_id() == cx.tcx.lang_items().future_trait();\n         then {\n-            return Some(&poly.trait_ref);\n+            let output_lifetimes = bounds\n+                .iter()\n+                .filter_map(|bound| {\n+                    if let GenericArg::Lifetime(lt) = bound {\n+                        Some(lt.name)\n+                    } else {\n+                        None\n+                    }\n+                })\n+                .collect();\n+\n+            return Some((trait_ref, output_lifetimes));\n         }\n     }\n \n@@ -129,6 +147,29 @@ fn future_output_ty<'tcx>(trait_ref: &'tcx TraitRef<'tcx>) -> Option<&'tcx Ty<'t\n     None\n }\n \n+fn captures_all_lifetimes(inputs: &[Ty<'_>], output_lifetimes: &[LifetimeName]) -> bool {\n+    let input_lifetimes: Vec<LifetimeName> = inputs\n+        .iter()\n+        .filter_map(|ty| {\n+            if let TyKind::Rptr(lt, _) = ty.kind {\n+                Some(lt.name)\n+            } else {\n+                None\n+            }\n+        })\n+        .collect();\n+\n+    // The lint should trigger in one of these cases:\n+    // - There are no input lifetimes\n+    // - There's only one output lifetime bound using `+ '_`\n+    // - All input lifetimes are explicitly bound to the output\n+    input_lifetimes.is_empty()\n+        || (output_lifetimes.len() == 1 && matches!(output_lifetimes[0], LifetimeName::Underscore))\n+        || input_lifetimes\n+            .iter()\n+            .all(|in_lt| output_lifetimes.iter().any(|out_lt| in_lt == out_lt))\n+}\n+\n fn desugared_async_block<'tcx>(cx: &LateContext<'tcx>, block: &'tcx Block<'tcx>) -> Option<&'tcx Body<'tcx>> {\n     if_chain! {\n         if let Some(block_expr) = block.expr;"}, {"sha": "0458950edee1c9660d41a4e15a974038f3949eac", "filename": "tests/ui/await_holding_lock.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2eab060ab7771e9c517c04c7519ed74c97d3a1c9/tests%2Fui%2Fawait_holding_lock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2eab060ab7771e9c517c04c7519ed74c97d3a1c9/tests%2Fui%2Fawait_holding_lock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fawait_holding_lock.rs?ref=2eab060ab7771e9c517c04c7519ed74c97d3a1c9", "patch": "@@ -47,6 +47,7 @@ async fn not_good(x: &Mutex<u32>) -> u32 {\n     first + second + third\n }\n \n+#[allow(clippy::manual_async_fn)]\n fn block_bad(x: &Mutex<u32>) -> impl std::future::Future<Output = u32> + '_ {\n     async move {\n         let guard = x.lock().unwrap();"}, {"sha": "21bf49d16f04877d862ff702ef527575cd537d2f", "filename": "tests/ui/await_holding_lock.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2eab060ab7771e9c517c04c7519ed74c97d3a1c9/tests%2Fui%2Fawait_holding_lock.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2eab060ab7771e9c517c04c7519ed74c97d3a1c9/tests%2Fui%2Fawait_holding_lock.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fawait_holding_lock.stderr?ref=2eab060ab7771e9c517c04c7519ed74c97d3a1c9", "patch": "@@ -46,13 +46,13 @@ LL | |     };\n    | |_____^\n \n error: this MutexGuard is held across an 'await' point. Consider using an async-aware Mutex type or ensuring the MutexGuard is dropped before calling await.\n-  --> $DIR/await_holding_lock.rs:52:13\n+  --> $DIR/await_holding_lock.rs:53:13\n    |\n LL |         let guard = x.lock().unwrap();\n    |             ^^^^^\n    |\n note: these are all the await points this lock is held through\n-  --> $DIR/await_holding_lock.rs:52:9\n+  --> $DIR/await_holding_lock.rs:53:9\n    |\n LL | /         let guard = x.lock().unwrap();\n LL | |         baz().await"}, {"sha": "4f551690c4370ab3b7f2428237f3a0d5e3548180", "filename": "tests/ui/manual_async_fn.fixed", "status": "modified", "additions": 36, "deletions": 4, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/2eab060ab7771e9c517c04c7519ed74c97d3a1c9/tests%2Fui%2Fmanual_async_fn.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/2eab060ab7771e9c517c04c7519ed74c97d3a1c9/tests%2Fui%2Fmanual_async_fn.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_async_fn.fixed?ref=2eab060ab7771e9c517c04c7519ed74c97d3a1c9", "patch": "@@ -43,10 +43,6 @@ impl S {\n         42\n     }\n \n-    async fn meth_fut(&self) -> i32 { 42 }\n-\n-    async fn empty_fut(&self)  {}\n-\n     // should be ignored\n     fn not_fut(&self) -> i32 {\n         42\n@@ -64,4 +60,40 @@ impl S {\n     }\n }\n \n+// Tests related to lifetime capture\n+\n+async fn elided(_: &i32) -> i32 { 42 }\n+\n+// should be ignored\n+fn elided_not_bound(_: &i32) -> impl Future<Output = i32> {\n+    async { 42 }\n+}\n+\n+async fn explicit<'a, 'b>(_: &'a i32, _: &'b i32) -> i32 { 42 }\n+\n+// should be ignored\n+#[allow(clippy::needless_lifetimes)]\n+fn explicit_not_bound<'a, 'b>(_: &'a i32, _: &'b i32) -> impl Future<Output = i32> {\n+    async { 42 }\n+}\n+\n+// should be ignored\n+mod issue_5765 {\n+    use std::future::Future;\n+\n+    struct A;\n+    impl A {\n+        fn f(&self) -> impl Future<Output = ()> {\n+            async {}\n+        }\n+    }\n+\n+    fn test() {\n+        let _future = {\n+            let a = A;\n+            a.f()\n+        };\n+    }\n+}\n+\n fn main() {}"}, {"sha": "6ed60309947a81b27f5e2a2b7a559cdbbacf9b7e", "filename": "tests/ui/manual_async_fn.rs", "status": "modified", "additions": 40, "deletions": 8, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/2eab060ab7771e9c517c04c7519ed74c97d3a1c9/tests%2Fui%2Fmanual_async_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2eab060ab7771e9c517c04c7519ed74c97d3a1c9/tests%2Fui%2Fmanual_async_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_async_fn.rs?ref=2eab060ab7771e9c517c04c7519ed74c97d3a1c9", "patch": "@@ -51,14 +51,6 @@ impl S {\n         }\n     }\n \n-    fn meth_fut(&self) -> impl Future<Output = i32> {\n-        async { 42 }\n-    }\n-\n-    fn empty_fut(&self) -> impl Future<Output = ()> {\n-        async {}\n-    }\n-\n     // should be ignored\n     fn not_fut(&self) -> i32 {\n         42\n@@ -76,4 +68,44 @@ impl S {\n     }\n }\n \n+// Tests related to lifetime capture\n+\n+fn elided(_: &i32) -> impl Future<Output = i32> + '_ {\n+    async { 42 }\n+}\n+\n+// should be ignored\n+fn elided_not_bound(_: &i32) -> impl Future<Output = i32> {\n+    async { 42 }\n+}\n+\n+fn explicit<'a, 'b>(_: &'a i32, _: &'b i32) -> impl Future<Output = i32> + 'a + 'b {\n+    async { 42 }\n+}\n+\n+// should be ignored\n+#[allow(clippy::needless_lifetimes)]\n+fn explicit_not_bound<'a, 'b>(_: &'a i32, _: &'b i32) -> impl Future<Output = i32> {\n+    async { 42 }\n+}\n+\n+// should be ignored\n+mod issue_5765 {\n+    use std::future::Future;\n+\n+    struct A;\n+    impl A {\n+        fn f(&self) -> impl Future<Output = ()> {\n+            async {}\n+        }\n+    }\n+\n+    fn test() {\n+        let _future = {\n+            let a = A;\n+            a.f()\n+        };\n+    }\n+}\n+\n fn main() {}"}, {"sha": "ccd828674276ba48cf9c6ba2a0f357edaecc5331", "filename": "tests/ui/manual_async_fn.stderr", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/2eab060ab7771e9c517c04c7519ed74c97d3a1c9/tests%2Fui%2Fmanual_async_fn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2eab060ab7771e9c517c04c7519ed74c97d3a1c9/tests%2Fui%2Fmanual_async_fn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_async_fn.stderr?ref=2eab060ab7771e9c517c04c7519ed74c97d3a1c9", "patch": "@@ -65,34 +65,34 @@ LL |             let c = 21;\n  ...\n \n error: this function can be simplified using the `async fn` syntax\n-  --> $DIR/manual_async_fn.rs:54:5\n+  --> $DIR/manual_async_fn.rs:73:1\n    |\n-LL |     fn meth_fut(&self) -> impl Future<Output = i32> {\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | fn elided(_: &i32) -> impl Future<Output = i32> + '_ {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n help: make the function `async` and return the output of the future directly\n    |\n-LL |     async fn meth_fut(&self) -> i32 {\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | async fn elided(_: &i32) -> i32 {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n help: move the body of the async block to the enclosing function\n    |\n-LL |     fn meth_fut(&self) -> impl Future<Output = i32> { 42 }\n-   |                                                     ^^^^^^\n+LL | fn elided(_: &i32) -> impl Future<Output = i32> + '_ { 42 }\n+   |                                                      ^^^^^^\n \n error: this function can be simplified using the `async fn` syntax\n-  --> $DIR/manual_async_fn.rs:58:5\n+  --> $DIR/manual_async_fn.rs:82:1\n    |\n-LL |     fn empty_fut(&self) -> impl Future<Output = ()> {\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | fn explicit<'a, 'b>(_: &'a i32, _: &'b i32) -> impl Future<Output = i32> + 'a + 'b {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-help: make the function `async` and remove the return type\n+help: make the function `async` and return the output of the future directly\n    |\n-LL |     async fn empty_fut(&self)  {\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | async fn explicit<'a, 'b>(_: &'a i32, _: &'b i32) -> i32 {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n help: move the body of the async block to the enclosing function\n    |\n-LL |     fn empty_fut(&self) -> impl Future<Output = ()> {}\n-   |                                                     ^^\n+LL | fn explicit<'a, 'b>(_: &'a i32, _: &'b i32) -> impl Future<Output = i32> + 'a + 'b { 42 }\n+   |                                                                                    ^^^^^^\n \n error: aborting due to 6 previous errors\n "}]}