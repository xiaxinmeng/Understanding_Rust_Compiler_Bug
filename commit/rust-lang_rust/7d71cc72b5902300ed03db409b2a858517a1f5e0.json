{"sha": "7d71cc72b5902300ed03db409b2a858517a1f5e0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdkNzFjYzcyYjU5MDIzMDBlZDAzZGI0MDliMmE4NTg1MTdhMWY1ZTA=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-03-03T17:22:52Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-03-03T17:22:52Z"}, "message": "Refactor reference search a bit", "tree": {"sha": "8cc0425d7b25c5da3f6a633a3addfb38640c5002", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8cc0425d7b25c5da3f6a633a3addfb38640c5002"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7d71cc72b5902300ed03db409b2a858517a1f5e0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7d71cc72b5902300ed03db409b2a858517a1f5e0", "html_url": "https://github.com/rust-lang/rust/commit/7d71cc72b5902300ed03db409b2a858517a1f5e0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7d71cc72b5902300ed03db409b2a858517a1f5e0/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "674770ef0473cf938d734f54bcf33524d9fdf5f8", "url": "https://api.github.com/repos/rust-lang/rust/commits/674770ef0473cf938d734f54bcf33524d9fdf5f8", "html_url": "https://github.com/rust-lang/rust/commit/674770ef0473cf938d734f54bcf33524d9fdf5f8"}], "stats": {"total": 101, "additions": 74, "deletions": 27}, "files": [{"sha": "2944926e6b12fbaa85966ebb47e4a513507eaddc", "filename": "crates/ra_hir/src/code_model.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7d71cc72b5902300ed03db409b2a858517a1f5e0/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d71cc72b5902300ed03db409b2a858517a1f5e0/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model.rs?ref=7d71cc72b5902300ed03db409b2a858517a1f5e0", "patch": "@@ -27,7 +27,7 @@ use hir_ty::{\n use ra_db::{CrateId, Edition, FileId};\n use ra_prof::profile;\n use ra_syntax::{\n-    ast::{self, AttrsOwner},\n+    ast::{self, AttrsOwner, NameOwner},\n     AstNode,\n };\n use rustc_hash::FxHashSet;\n@@ -603,6 +603,10 @@ impl Static {\n     pub fn krate(self, db: &impl DefDatabase) -> Option<Crate> {\n         Some(self.module(db).krate())\n     }\n+\n+    pub fn name(self, db: &impl HirDatabase) -> Option<Name> {\n+        db.static_data(self.id).name.clone()\n+    }\n }\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n@@ -674,6 +678,11 @@ impl MacroDef {\n         let module_id = db.crate_def_map(krate).root;\n         Some(Module::new(Crate { id: krate }, module_id))\n     }\n+\n+    /// XXX: this parses the file\n+    pub fn name(self, db: &impl HirDatabase) -> Option<Name> {\n+        self.source(db).value.name().map(|it| it.as_name())\n+    }\n }\n \n /// Invariant: `inner.as_assoc_item(db).is_some()`\n@@ -783,6 +792,7 @@ pub struct Local {\n }\n \n impl Local {\n+    // FIXME: why is this an option? It shouldn't be?\n     pub fn name(self, db: &impl HirDatabase) -> Option<Name> {\n         let body = db.body(self.parent.into());\n         match &body[self.pat_id] {"}, {"sha": "c9c9c6483b472deb4a5385bfb854fd948a3683be", "filename": "crates/ra_ide/src/references.rs", "status": "modified", "additions": 36, "deletions": 25, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/7d71cc72b5902300ed03db409b2a858517a1f5e0/crates%2Fra_ide%2Fsrc%2Freferences.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d71cc72b5902300ed03db409b2a858517a1f5e0/crates%2Fra_ide%2Fsrc%2Freferences.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Freferences.rs?ref=7d71cc72b5902300ed03db409b2a858517a1f5e0", "patch": "@@ -125,9 +125,29 @@ pub(crate) fn find_all_refs(\n             (find_node_at_offset::<ast::Name>(&syntax, position.offset), ReferenceKind::Other)\n         };\n \n-    let RangeInfo { range, info: (name, def) } = find_name(&sema, &syntax, position, opt_name)?;\n-    let declaration = def.try_to_nav(db)?;\n+    let RangeInfo { range, info: def } = find_name(&sema, &syntax, position, opt_name)?;\n \n+    let references = find_refs_to_def(db, &def, search_scope)\n+        .into_iter()\n+        .filter(|r| search_kind == ReferenceKind::Other || search_kind == r.kind)\n+        .collect();\n+\n+    let decl_range = def.try_to_nav(db)?.range();\n+\n+    let declaration = Declaration {\n+        nav: def.try_to_nav(db)?,\n+        kind: ReferenceKind::Other,\n+        access: decl_access(&def, &syntax, decl_range),\n+    };\n+\n+    Some(RangeInfo::new(range, ReferenceSearchResult { declaration, references }))\n+}\n+\n+pub(crate) fn find_refs_to_def(\n+    db: &RootDatabase,\n+    def: &NameDefinition,\n+    search_scope: Option<SearchScope>,\n+) -> Vec<Reference> {\n     let search_scope = {\n         let base = SearchScope::for_def(&def, db);\n         match search_scope {\n@@ -136,42 +156,34 @@ pub(crate) fn find_all_refs(\n         }\n     };\n \n-    let decl_range = declaration.range();\n-\n-    let declaration = Declaration {\n-        nav: declaration,\n-        kind: ReferenceKind::Other,\n-        access: decl_access(&def, &name, &syntax, decl_range),\n+    let name = match def.name(db) {\n+        None => return Vec::new(),\n+        Some(it) => it.to_string(),\n     };\n \n-    let references = process_definition(db, def, name, search_scope)\n-        .into_iter()\n-        .filter(|r| search_kind == ReferenceKind::Other || search_kind == r.kind)\n-        .collect();\n-\n-    Some(RangeInfo::new(range, ReferenceSearchResult { declaration, references }))\n+    process_definition(db, def, name, search_scope)\n }\n \n fn find_name(\n     sema: &Semantics<RootDatabase>,\n     syntax: &SyntaxNode,\n     position: FilePosition,\n     opt_name: Option<ast::Name>,\n-) -> Option<RangeInfo<(String, NameDefinition)>> {\n+) -> Option<RangeInfo<NameDefinition>> {\n     if let Some(name) = opt_name {\n         let def = classify_name(sema, &name)?.definition();\n         let range = name.syntax().text_range();\n-        return Some(RangeInfo::new(range, (name.text().to_string(), def)));\n+        return Some(RangeInfo::new(range, def));\n     }\n     let name_ref = find_node_at_offset::<ast::NameRef>(&syntax, position.offset)?;\n     let def = classify_name_ref(sema, &name_ref)?.definition();\n     let range = name_ref.syntax().text_range();\n-    Some(RangeInfo::new(range, (name_ref.text().to_string(), def)))\n+    Some(RangeInfo::new(range, def))\n }\n \n fn process_definition(\n     db: &RootDatabase,\n-    def: NameDefinition,\n+    def: &NameDefinition,\n     name: String,\n     scope: SearchScope,\n ) -> Vec<Reference> {\n@@ -217,7 +229,7 @@ fn process_definition(\n \n             if let Some(d) = classify_name_ref(&sema, &name_ref) {\n                 let d = d.definition();\n-                if d == def {\n+                if &d == def {\n                     let kind =\n                         if is_record_lit_name_ref(&name_ref) || is_call_expr_name_ref(&name_ref) {\n                             ReferenceKind::StructLiteral\n@@ -240,7 +252,6 @@ fn process_definition(\n \n fn decl_access(\n     def: &NameDefinition,\n-    name: &str,\n     syntax: &SyntaxNode,\n     range: TextRange,\n ) -> Option<ReferenceAccess> {\n@@ -253,7 +264,7 @@ fn decl_access(\n     if stmt.initializer().is_some() {\n         let pat = stmt.pat()?;\n         if let ast::Pat::BindPat(it) = pat {\n-            if it.name()?.text().as_str() == name {\n+            if it.is_mutable() {\n                 return Some(ReferenceAccess::Write);\n             }\n         }\n@@ -463,7 +474,7 @@ mod tests {\n         let refs = get_all_refs(code);\n         check_result(\n             refs,\n-            \"spam BIND_PAT FileId(1) [44; 48) Other Write\",\n+            \"spam BIND_PAT FileId(1) [44; 48) Other\",\n             &[\"FileId(1) [71; 75) Other Read\", \"FileId(1) [78; 82) Other Read\"],\n         );\n     }\n@@ -709,15 +720,15 @@ mod tests {\n     fn test_basic_highlight_read_write() {\n         let code = r#\"\n         fn foo() {\n-            let i<|> = 0;\n+            let mut i<|> = 0;\n             i = i + 1;\n         }\"#;\n \n         let refs = get_all_refs(code);\n         check_result(\n             refs,\n-            \"i BIND_PAT FileId(1) [36; 37) Other Write\",\n-            &[\"FileId(1) [55; 56) Other Write\", \"FileId(1) [59; 60) Other Read\"],\n+            \"i BIND_PAT FileId(1) [40; 41) Other Write\",\n+            &[\"FileId(1) [59; 60) Other Write\", \"FileId(1) [63; 64) Other Read\"],\n         );\n     }\n "}, {"sha": "8a5161dfe1881e949fa8721cc5bcdd884ed39b37", "filename": "crates/ra_ide_db/src/defs.rs", "status": "modified", "additions": 27, "deletions": 1, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/7d71cc72b5902300ed03db409b2a858517a1f5e0/crates%2Fra_ide_db%2Fsrc%2Fdefs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d71cc72b5902300ed03db409b2a858517a1f5e0/crates%2Fra_ide_db%2Fsrc%2Fdefs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_db%2Fsrc%2Fdefs.rs?ref=7d71cc72b5902300ed03db409b2a858517a1f5e0", "patch": "@@ -6,7 +6,7 @@\n // FIXME: this badly needs rename/rewrite (matklad, 2020-02-06).\n \n use hir::{\n-    Adt, FieldSource, HasSource, ImplDef, Local, MacroDef, Module, ModuleDef, Semantics,\n+    Adt, FieldSource, HasSource, ImplDef, Local, MacroDef, Module, ModuleDef, Name, Semantics,\n     StructField, TypeParam,\n };\n use ra_prof::profile;\n@@ -66,6 +66,32 @@ impl NameDefinition {\n             NameDefinition::TypeParam(_) => None,\n         }\n     }\n+\n+    pub fn name(&self, db: &RootDatabase) -> Option<Name> {\n+        let name = match self {\n+            NameDefinition::Macro(it) => it.name(db)?,\n+            NameDefinition::StructField(it) => it.name(db),\n+            NameDefinition::ModuleDef(def) => match def {\n+                hir::ModuleDef::Module(it) => it.name(db)?,\n+                hir::ModuleDef::Function(it) => it.name(db),\n+                hir::ModuleDef::Adt(def) => match def {\n+                    hir::Adt::Struct(it) => it.name(db),\n+                    hir::Adt::Union(it) => it.name(db),\n+                    hir::Adt::Enum(it) => it.name(db),\n+                },\n+                hir::ModuleDef::EnumVariant(it) => it.name(db),\n+                hir::ModuleDef::Const(it) => it.name(db)?,\n+                hir::ModuleDef::Static(it) => it.name(db)?,\n+                hir::ModuleDef::Trait(it) => it.name(db),\n+                hir::ModuleDef::TypeAlias(it) => it.name(db),\n+                hir::ModuleDef::BuiltinType(_) => return None,\n+            },\n+            NameDefinition::SelfType(_) => return None,\n+            NameDefinition::Local(it) => it.name(db)?,\n+            NameDefinition::TypeParam(it) => it.name(db),\n+        };\n+        Some(name)\n+    }\n }\n \n pub enum NameClass {"}]}