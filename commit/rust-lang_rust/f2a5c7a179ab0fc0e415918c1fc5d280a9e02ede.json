{"sha": "f2a5c7a179ab0fc0e415918c1fc5d280a9e02ede", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYyYTVjN2ExNzlhYjBmYzBlNDE1OTE4YzFmYzVkMjgwYTllMDJlZGU=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-03-27T20:22:56Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-03-31T21:32:18Z"}, "message": "rustc: Switch struct fields to private by default\n\nThis commit switches privacy's checking of fields to have *all* fields be\nprivate by default. This does not yet change tuple structs, this only affects\nstructs with named fields. The fallout of this change will follow shortly.\n\nRFC: 0004-private-fields\n\ncc #8122\nCloses #11809", "tree": {"sha": "65bed782901a02890114af7dd64bddecded0af30", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/65bed782901a02890114af7dd64bddecded0af30"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f2a5c7a179ab0fc0e415918c1fc5d280a9e02ede", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f2a5c7a179ab0fc0e415918c1fc5d280a9e02ede", "html_url": "https://github.com/rust-lang/rust/commit/f2a5c7a179ab0fc0e415918c1fc5d280a9e02ede", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f2a5c7a179ab0fc0e415918c1fc5d280a9e02ede/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a7e057d402a345f547e67a326871621472d04035", "url": "https://api.github.com/repos/rust-lang/rust/commits/a7e057d402a345f547e67a326871621472d04035", "html_url": "https://github.com/rust-lang/rust/commit/a7e057d402a345f547e67a326871621472d04035"}], "stats": {"total": 97, "additions": 20, "deletions": 77}, "files": [{"sha": "85717837336e72a0ef419770710d5fb6d99a4074", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f2a5c7a179ab0fc0e415918c1fc5d280a9e02ede/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2a5c7a179ab0fc0e415918c1fc5d280a9e02ede/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=f2a5c7a179ab0fc0e415918c1fc5d280a9e02ede", "patch": "@@ -1506,7 +1506,7 @@ fn check_missing_doc_ty_method(cx: &Context, tm: &ast::TypeMethod) {\n \n fn check_missing_doc_struct_field(cx: &Context, sf: &ast::StructField) {\n     match sf.node.kind {\n-        ast::NamedField(_, vis) if vis != ast::Private =>\n+        ast::NamedField(_, vis) if vis == ast::Public =>\n             check_missing_doc_attrs(cx,\n                                     Some(cx.cur_struct_def_id),\n                                     sf.node.attrs.as_slice(),"}, {"sha": "e5644dbd246f4bb87f1cfb469f08327ed9f36db5", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 19, "deletions": 76, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/f2a5c7a179ab0fc0e415918c1fc5d280a9e02ede/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2a5c7a179ab0fc0e415918c1fc5d280a9e02ede/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=f2a5c7a179ab0fc0e415918c1fc5d280a9e02ede", "patch": "@@ -14,7 +14,6 @@\n \n use std::mem::replace;\n \n-use metadata::csearch;\n use middle::lint;\n use middle::resolve;\n use middle::ty;\n@@ -562,53 +561,10 @@ impl<'a> PrivacyVisitor<'a> {\n \n     // Checks that a field is in scope.\n     // FIXME #6993: change type (and name) from Ident to Name\n-    fn check_field(&mut self, span: Span, id: ast::DefId, ident: ast::Ident,\n-                   enum_id: Option<ast::DefId>) {\n-        let fields = ty::lookup_struct_fields(self.tcx, id);\n-        let struct_vis = if is_local(id) {\n-            match self.tcx.map.get(id.node) {\n-                ast_map::NodeItem(ref it) => it.vis,\n-                ast_map::NodeVariant(ref v) => {\n-                    if v.node.vis == ast::Inherited {\n-                        let parent = self.tcx.map.get_parent(id.node);\n-                        self.tcx.map.expect_item(parent).vis\n-                    } else {\n-                        v.node.vis\n-                    }\n-                }\n-                _ => {\n-                    self.tcx.sess.span_bug(span,\n-                                           format!(\"not an item or variant def\"));\n-                }\n-            }\n-        } else {\n-            let cstore = &self.tcx.sess.cstore;\n-            match enum_id {\n-                Some(enum_id) => {\n-                    let v = csearch::get_enum_variants(self.tcx, enum_id);\n-                    match v.iter().find(|v| v.id == id) {\n-                        Some(variant) => {\n-                            if variant.vis == ast::Inherited {\n-                                csearch::get_item_visibility(cstore, enum_id)\n-                            } else {\n-                                variant.vis\n-                            }\n-                        }\n-                        None => {\n-                            self.tcx.sess.span_bug(span, \"no xcrate variant\");\n-                        }\n-                    }\n-                }\n-                None => csearch::get_item_visibility(cstore, id)\n-            }\n-        };\n-\n-        for field in fields.iter() {\n+    fn check_field(&mut self, span: Span, id: ast::DefId, ident: ast::Ident) {\n+        for field in ty::lookup_struct_fields(self.tcx, id).iter() {\n             if field.name != ident.name { continue; }\n-            // public structs have public fields by default, and private structs\n-            // have private fields by default.\n-            if struct_vis == ast::Public && field.vis != ast::Private { break }\n-            if struct_vis != ast::Public && field.vis == ast::Public { break }\n+            if field.vis == ast::Public { break }\n             if !is_local(field.id) ||\n                !self.private_accessible(field.id.node) {\n                 self.tcx.sess.span_err(span,\n@@ -770,7 +726,7 @@ impl<'a> Visitor<()> for PrivacyVisitor<'a> {\n                 match ty::get(ty::expr_ty_adjusted(self.tcx, base,\n                                                    &*self.method_map.borrow())).sty {\n                     ty::ty_struct(id, _) => {\n-                        self.check_field(expr.span, id, ident, None);\n+                        self.check_field(expr.span, id, ident);\n                     }\n                     _ => {}\n                 }\n@@ -793,17 +749,15 @@ impl<'a> Visitor<()> for PrivacyVisitor<'a> {\n                 match ty::get(ty::expr_ty(self.tcx, expr)).sty {\n                     ty::ty_struct(id, _) => {\n                         for field in (*fields).iter() {\n-                            self.check_field(expr.span, id, field.ident.node,\n-                                             None);\n+                            self.check_field(expr.span, id, field.ident.node);\n                         }\n                     }\n                     ty::ty_enum(_, _) => {\n                         match self.tcx.def_map.borrow().get_copy(&expr.id) {\n-                            ast::DefVariant(enum_id, variant_id, _) => {\n+                            ast::DefVariant(_, variant_id, _) => {\n                                 for field in fields.iter() {\n                                     self.check_field(expr.span, variant_id,\n-                                                     field.ident.node,\n-                                                     Some(enum_id));\n+                                                     field.ident.node);\n                                 }\n                             }\n                             _ => self.tcx.sess.span_bug(expr.span,\n@@ -867,16 +821,15 @@ impl<'a> Visitor<()> for PrivacyVisitor<'a> {\n                 match ty::get(ty::pat_ty(self.tcx, pattern)).sty {\n                     ty::ty_struct(id, _) => {\n                         for field in fields.iter() {\n-                            self.check_field(pattern.span, id, field.ident,\n-                                             None);\n+                            self.check_field(pattern.span, id, field.ident);\n                         }\n                     }\n                     ty::ty_enum(_, _) => {\n                         match self.tcx.def_map.borrow().find(&pattern.id) {\n-                            Some(&ast::DefVariant(enum_id, variant_id, _)) => {\n+                            Some(&ast::DefVariant(_, variant_id, _)) => {\n                                 for field in fields.iter() {\n                                     self.check_field(pattern.span, variant_id,\n-                                                     field.ident, Some(enum_id));\n+                                                     field.ident);\n                                 }\n                             }\n                             _ => self.tcx.sess.span_bug(pattern.span,\n@@ -992,16 +945,10 @@ impl<'a> SanePrivacyVisitor<'a> {\n                 }\n             }\n         };\n-        let check_struct = |def: &@ast::StructDef,\n-                            vis: ast::Visibility,\n-                            parent_vis: Option<ast::Visibility>| {\n-            let public_def = match vis {\n-                ast::Public => true,\n-                ast::Inherited | ast::Private => parent_vis == Some(ast::Public),\n-            };\n+        let check_struct = |def: &@ast::StructDef| {\n             for f in def.fields.iter() {\n-               match f.node.kind {\n-                    ast::NamedField(_, ast::Private) if !public_def => {\n+                match f.node.kind {\n+                    ast::NamedField(_, ast::Private) => {\n                         tcx.sess.span_err(f.span, \"unnecessary `priv` \\\n                                                    visibility\");\n                     }\n@@ -1058,15 +1005,13 @@ impl<'a> SanePrivacyVisitor<'a> {\n                     }\n \n                     match v.node.kind {\n-                        ast::StructVariantKind(ref s) => {\n-                            check_struct(s, v.node.vis, Some(item.vis));\n-                        }\n+                        ast::StructVariantKind(ref s) => check_struct(s),\n                         ast::TupleVariantKind(..) => {}\n                     }\n                 }\n             }\n \n-            ast::ItemStruct(ref def, _) => check_struct(def, item.vis, None),\n+            ast::ItemStruct(ref def, _) => check_struct(def),\n \n             ast::ItemTrait(_, _, ref methods) => {\n                 for m in methods.iter() {\n@@ -1372,12 +1317,10 @@ impl<'a> Visitor<()> for VisiblePrivateTypesVisitor<'a> {\n \n     fn visit_struct_field(&mut self, s: &ast::StructField, _: ()) {\n         match s.node.kind {\n-            // the only way to get here is by being inside a public\n-            // struct/enum variant, so the only way to have a private\n-            // field is with an explicit `priv`.\n-            ast::NamedField(_, ast::Private) => {}\n-\n-            _ => visit::walk_struct_field(self, s, ())\n+            ast::NamedField(_, ast::Public)  => {\n+                visit::walk_struct_field(self, s, ());\n+            }\n+            _ => {}\n         }\n     }\n "}]}