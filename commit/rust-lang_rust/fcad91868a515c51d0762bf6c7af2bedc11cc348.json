{"sha": "fcad91868a515c51d0762bf6c7af2bedc11cc348", "node_id": "C_kwDOAAsO6NoAKGZjYWQ5MTg2OGE1MTVjNTFkMDc2MmJmNmM3YWYyYmVkYzExY2MzNDg", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-23T22:41:48Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-23T22:41:48Z"}, "message": "Auto merge of #99652 - GuillaumeGomez:rollup-38v0x7y, r=GuillaumeGomez\n\nRollup of 6 pull requests\n\nSuccessful merges:\n\n - #99298 (Make `ui-fulldeps/gated-plugins` and `ui-fulldeps/multiple-plugins` tests stage 2 only)\n - #99396 (Add some additional double-adjustment regression tests)\n - #99449 (Do not resolve associated const when there is no provided value)\n - #99595 (Mark atomics as unsupported on thumbv6m)\n - #99627 (Lock stdout once when listing tests)\n - #99638 (Remove Clean trait implementation for hir::Ty and middle::Ty)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "682cb7ebef5a5f140298da02fa295e9e90707c37", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/682cb7ebef5a5f140298da02fa295e9e90707c37"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fcad91868a515c51d0762bf6c7af2bedc11cc348", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fcad91868a515c51d0762bf6c7af2bedc11cc348", "html_url": "https://github.com/rust-lang/rust/commit/fcad91868a515c51d0762bf6c7af2bedc11cc348", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fcad91868a515c51d0762bf6c7af2bedc11cc348/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "93ffde6f04d3d24327a4e17a2a2bf4f63c246235", "url": "https://api.github.com/repos/rust-lang/rust/commits/93ffde6f04d3d24327a4e17a2a2bf4f63c246235", "html_url": "https://github.com/rust-lang/rust/commit/93ffde6f04d3d24327a4e17a2a2bf4f63c246235"}, {"sha": "d87a13fe0de0c0fae61c289a249f8556d3243b5a", "url": "https://api.github.com/repos/rust-lang/rust/commits/d87a13fe0de0c0fae61c289a249f8556d3243b5a", "html_url": "https://github.com/rust-lang/rust/commit/d87a13fe0de0c0fae61c289a249f8556d3243b5a"}], "stats": {"total": 443, "additions": 258, "deletions": 185}, "files": [{"sha": "dffa19ae55c04bbd5dca8252e30b575782ffa113", "filename": "compiler/rustc_target/src/spec/thumbv6m_none_eabi.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fcad91868a515c51d0762bf6c7af2bedc11cc348/compiler%2Frustc_target%2Fsrc%2Fspec%2Fthumbv6m_none_eabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fcad91868a515c51d0762bf6c7af2bedc11cc348/compiler%2Frustc_target%2Fsrc%2Fspec%2Fthumbv6m_none_eabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fthumbv6m_none_eabi.rs?ref=fcad91868a515c51d0762bf6c7af2bedc11cc348", "patch": "@@ -14,8 +14,9 @@ pub fn target() -> Target {\n             // The ARMv6-M architecture doesn't support unaligned loads/stores so we disable them\n             // with +strict-align.\n             features: \"+strict-align\".into(),\n-            // There are no atomic CAS instructions available in the instruction set of the ARMv6-M\n+            // There are no atomic instructions available in the instruction set of the ARMv6-M\n             // architecture\n+            max_atomic_width: Some(0),\n             atomic_cas: false,\n             ..super::thumb_base::opts()\n         },"}, {"sha": "decbf0133114f23ce21f3f72ab796f69bcddf176", "filename": "compiler/rustc_trait_selection/src/traits/const_evaluatable.rs", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/fcad91868a515c51d0762bf6c7af2bedc11cc348/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fcad91868a515c51d0762bf6c7af2bedc11cc348/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs?ref=fcad91868a515c51d0762bf6c7af2bedc11cc348", "patch": "@@ -185,14 +185,20 @@ pub fn is_const_evaluatable<'cx, 'tcx>(\n         }\n         let concrete = infcx.const_eval_resolve(param_env, uv.expand(), Some(span));\n         match concrete {\n-            Err(ErrorHandled::TooGeneric) => Err(if !uv.has_infer_types_or_consts() {\n+            Err(ErrorHandled::TooGeneric) => Err(if uv.has_infer_types_or_consts() {\n+                NotConstEvaluatable::MentionsInfer\n+            } else if uv.has_param_types_or_consts() {\n                 infcx\n                     .tcx\n                     .sess\n                     .delay_span_bug(span, &format!(\"unexpected `TooGeneric` for {:?}\", uv));\n                 NotConstEvaluatable::MentionsParam\n             } else {\n-                NotConstEvaluatable::MentionsInfer\n+                let guar = infcx.tcx.sess.delay_span_bug(\n+                    span,\n+                    format!(\"Missing value for constant, but no error reported?\"),\n+                );\n+                NotConstEvaluatable::Error(guar)\n             }),\n             Err(ErrorHandled::Linted) => {\n                 let reported = infcx\n@@ -240,8 +246,11 @@ pub fn is_const_evaluatable<'cx, 'tcx>(\n \n             Err(ErrorHandled::TooGeneric) => Err(if uv.has_infer_types_or_consts() {\n                 NotConstEvaluatable::MentionsInfer\n-                } else {\n+                } else if uv.has_param_types_or_consts() {\n                 NotConstEvaluatable::MentionsParam\n+            } else {\n+                let guar = infcx.tcx.sess.delay_span_bug(span, format!(\"Missing value for constant, but no error reported?\"));\n+                NotConstEvaluatable::Error(guar)\n             }),\n             Err(ErrorHandled::Linted) => {\n                 let reported ="}, {"sha": "979e997f2449162aa01878f507c8ce73aed1c8b8", "filename": "compiler/rustc_ty_utils/src/instance.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fcad91868a515c51d0762bf6c7af2bedc11cc348/compiler%2Frustc_ty_utils%2Fsrc%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fcad91868a515c51d0762bf6c7af2bedc11cc348/compiler%2Frustc_ty_utils%2Fsrc%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Finstance.rs?ref=fcad91868a515c51d0762bf6c7af2bedc11cc348", "patch": "@@ -280,6 +280,11 @@ fn resolve_associated_item<'tcx>(\n                 return Ok(None);\n             }\n \n+            // If the item does not have a value, then we cannot return an instance.\n+            if !leaf_def.item.defaultness.has_value() {\n+                return Ok(None);\n+            }\n+\n             let substs = tcx.erase_regions(substs);\n \n             // Check if we just resolved an associated `const` declaration from"}, {"sha": "e9dda98966de3f638044ed1d9e80d1f28aa22253", "filename": "library/test/src/console.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fcad91868a515c51d0762bf6c7af2bedc11cc348/library%2Ftest%2Fsrc%2Fconsole.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fcad91868a515c51d0762bf6c7af2bedc11cc348/library%2Ftest%2Fsrc%2Fconsole.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Ftest%2Fsrc%2Fconsole.rs?ref=fcad91868a515c51d0762bf6c7af2bedc11cc348", "patch": "@@ -137,7 +137,7 @@ impl ConsoleTestState {\n // List the tests to console, and optionally to logfile. Filters are honored.\n pub fn list_tests_console(opts: &TestOpts, tests: Vec<TestDescAndFn>) -> io::Result<()> {\n     let mut output = match term::stdout() {\n-        None => OutputLocation::Raw(io::stdout()),\n+        None => OutputLocation::Raw(io::stdout().lock()),\n         Some(t) => OutputLocation::Pretty(t),\n     };\n "}, {"sha": "c43fd1ad24173ecec40c04761352794aeb858686", "filename": "src/librustdoc/clean/auto_trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fcad91868a515c51d0762bf6c7af2bedc11cc348/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fcad91868a515c51d0762bf6c7af2bedc11cc348/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs?ref=fcad91868a515c51d0762bf6c7af2bedc11cc348", "patch": "@@ -121,7 +121,7 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n                 unsafety: hir::Unsafety::Normal,\n                 generics: new_generics,\n                 trait_: Some(trait_ref.clean(self.cx)),\n-                for_: ty.clean(self.cx),\n+                for_: clean_middle_ty(ty, self.cx, None),\n                 items: Vec::new(),\n                 polarity,\n                 kind: ImplKind::Auto,"}, {"sha": "c64c5895079be91547c30d15cc7368baf83f35ba", "filename": "src/librustdoc/clean/blanket_impl.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fcad91868a515c51d0762bf6c7af2bedc11cc348/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fcad91868a515c51d0762bf6c7af2bedc11cc348/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs?ref=fcad91868a515c51d0762bf6c7af2bedc11cc348", "patch": "@@ -116,14 +116,14 @@ impl<'a, 'tcx> BlanketImplFinder<'a, 'tcx> {\n                             // FIXME(eddyb) compute both `trait_` and `for_` from\n                             // the post-inference `trait_ref`, as it's more accurate.\n                             trait_: Some(trait_ref.0.clean(cx)),\n-                            for_: ty.0.clean(cx),\n+                            for_: clean_middle_ty(ty.0, cx, None),\n                             items: cx.tcx\n                                 .associated_items(impl_def_id)\n                                 .in_definition_order()\n                                 .map(|x| x.clean(cx))\n                                 .collect::<Vec<_>>(),\n                             polarity: ty::ImplPolarity::Positive,\n-                            kind: ImplKind::Blanket(Box::new(trait_ref.0.self_ty().clean(cx))),\n+                            kind: ImplKind::Blanket(Box::new(clean_middle_ty(trait_ref.0.self_ty(), cx, None))),\n                         })),\n                         cfg: None,\n                     });"}, {"sha": "7a4ec889ac75730514c8ed647fc4206b9cba39c4", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/fcad91868a515c51d0762bf6c7af2bedc11cc348/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fcad91868a515c51d0762bf6c7af2bedc11cc348/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=fcad91868a515c51d0762bf6c7af2bedc11cc348", "patch": "@@ -16,8 +16,8 @@ use rustc_span::hygiene::MacroKind;\n use rustc_span::symbol::{kw, sym, Symbol};\n \n use crate::clean::{\n-    self, clean_fn_decl_from_did_and_sig, clean_ty_generics, utils, Attributes, AttributesExt,\n-    Clean, ImplKind, ItemId, Type, Visibility,\n+    self, clean_fn_decl_from_did_and_sig, clean_middle_ty, clean_ty, clean_ty_generics, utils,\n+    Attributes, AttributesExt, Clean, ImplKind, ItemId, Type, Visibility,\n };\n use crate::core::DocContext;\n use crate::formats::item_type::ItemType;\n@@ -261,7 +261,7 @@ fn build_union(cx: &mut DocContext<'_>, did: DefId) -> clean::Union {\n \n fn build_type_alias(cx: &mut DocContext<'_>, did: DefId) -> clean::Typedef {\n     let predicates = cx.tcx.explicit_predicates_of(did);\n-    let type_ = cx.tcx.type_of(did).clean(cx);\n+    let type_ = clean_middle_ty(cx.tcx.type_of(did), cx, Some(did));\n \n     clean::Typedef {\n         type_,\n@@ -357,8 +357,8 @@ pub(crate) fn build_impl(\n     };\n \n     let for_ = match &impl_item {\n-        Some(impl_) => impl_.self_ty.clean(cx),\n-        None => tcx.type_of(did).clean(cx),\n+        Some(impl_) => clean_ty(impl_.self_ty, cx),\n+        None => clean_middle_ty(tcx.type_of(did), cx, Some(did)),\n     };\n \n     // Only inline impl if the implementing type is\n@@ -577,14 +577,14 @@ pub(crate) fn print_inlined_const(tcx: TyCtxt<'_>, did: DefId) -> String {\n \n fn build_const(cx: &mut DocContext<'_>, def_id: DefId) -> clean::Constant {\n     clean::Constant {\n-        type_: cx.tcx.type_of(def_id).clean(cx),\n+        type_: clean_middle_ty(cx.tcx.type_of(def_id), cx, Some(def_id)),\n         kind: clean::ConstantKind::Extern { def_id },\n     }\n }\n \n fn build_static(cx: &mut DocContext<'_>, did: DefId, mutable: bool) -> clean::Static {\n     clean::Static {\n-        type_: cx.tcx.type_of(did).clean(cx),\n+        type_: clean_middle_ty(cx.tcx.type_of(did), cx, Some(did)),\n         mutability: if mutable { Mutability::Mut } else { Mutability::Not },\n         expr: None,\n     }"}, {"sha": "6160783f652f120ec82f0b481303e0dce48dcc56", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 138, "deletions": 122, "changes": 260, "blob_url": "https://github.com/rust-lang/rust/blob/fcad91868a515c51d0762bf6c7af2bedc11cc348/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fcad91868a515c51d0762bf6c7af2bedc11cc348/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=fcad91868a515c51d0762bf6c7af2bedc11cc348", "patch": "@@ -239,11 +239,9 @@ impl<'tcx> Clean<'tcx, Lifetime> for hir::Lifetime {\n \n impl<'tcx> Clean<'tcx, Constant> for hir::ConstArg {\n     fn clean(&self, cx: &mut DocContext<'tcx>) -> Constant {\n+        let def_id = cx.tcx.hir().body_owner_def_id(self.value.body).to_def_id();\n         Constant {\n-            type_: cx\n-                .tcx\n-                .type_of(cx.tcx.hir().body_owner_def_id(self.value.body).to_def_id())\n-                .clean(cx),\n+            type_: clean_middle_ty(cx.tcx.type_of(def_id), cx, Some(def_id)),\n             kind: ConstantKind::Anonymous { body: self.value.body },\n         }\n     }\n@@ -297,7 +295,7 @@ impl<'tcx> Clean<'tcx, Option<WherePredicate>> for hir::WherePredicate<'tcx> {\n                     })\n                     .collect();\n                 WherePredicate::BoundPredicate {\n-                    ty: wbp.bounded_ty.clean(cx),\n+                    ty: clean_ty(wbp.bounded_ty, cx),\n                     bounds: wbp.bounds.iter().filter_map(|x| x.clean(cx)).collect(),\n                     bound_params,\n                 }\n@@ -309,8 +307,8 @@ impl<'tcx> Clean<'tcx, Option<WherePredicate>> for hir::WherePredicate<'tcx> {\n             },\n \n             hir::WherePredicate::EqPredicate(ref wrp) => WherePredicate::EqPredicate {\n-                lhs: wrp.lhs_ty.clean(cx),\n-                rhs: wrp.rhs_ty.clean(cx).into(),\n+                lhs: clean_ty(wrp.lhs_ty, cx),\n+                rhs: clean_ty(wrp.rhs_ty, cx).into(),\n             },\n         })\n     }\n@@ -348,7 +346,7 @@ impl<'tcx> Clean<'tcx, Option<WherePredicate>> for ty::PolyTraitPredicate<'tcx>\n \n         let poly_trait_ref = self.map_bound(|pred| pred.trait_ref);\n         Some(WherePredicate::BoundPredicate {\n-            ty: poly_trait_ref.skip_binder().self_ty().clean(cx),\n+            ty: clean_middle_ty(poly_trait_ref.skip_binder().self_ty(), cx, None),\n             bounds: vec![poly_trait_ref.clean(cx)],\n             bound_params: Vec::new(),\n         })\n@@ -383,7 +381,7 @@ impl<'tcx> Clean<'tcx, Option<WherePredicate>>\n         }\n \n         Some(WherePredicate::BoundPredicate {\n-            ty: ty.clean(cx),\n+            ty: clean_middle_ty(*ty, cx, None),\n             bounds: vec![GenericBound::Outlives(lt.clean(cx).expect(\"failed to clean lifetimes\"))],\n             bound_params: Vec::new(),\n         })\n@@ -393,7 +391,7 @@ impl<'tcx> Clean<'tcx, Option<WherePredicate>>\n impl<'tcx> Clean<'tcx, Term> for ty::Term<'tcx> {\n     fn clean(&self, cx: &mut DocContext<'tcx>) -> Term {\n         match self {\n-            ty::Term::Ty(ty) => Term::Type(ty.clean(cx)),\n+            ty::Term::Ty(ty) => Term::Type(clean_middle_ty(*ty, cx, None)),\n             ty::Term::Const(c) => Term::Constant(c.clean(cx)),\n         }\n     }\n@@ -402,7 +400,7 @@ impl<'tcx> Clean<'tcx, Term> for ty::Term<'tcx> {\n impl<'tcx> Clean<'tcx, Term> for hir::Term<'tcx> {\n     fn clean(&self, cx: &mut DocContext<'tcx>) -> Term {\n         match self {\n-            hir::Term::Ty(ty) => Term::Type(ty.clean(cx)),\n+            hir::Term::Ty(ty) => Term::Type(clean_ty(ty, cx)),\n             hir::Term::Const(c) => {\n                 let def_id = cx.tcx.hir().local_def_id(c.hir_id);\n                 Term::Constant(ty::Const::from_anon_const(cx.tcx, def_id).clean(cx))\n@@ -425,7 +423,7 @@ fn clean_projection<'tcx>(\n ) -> Type {\n     let lifted = ty.lift_to_tcx(cx.tcx).unwrap();\n     let trait_ = lifted.trait_ref(cx.tcx).clean(cx);\n-    let self_type = ty.self_ty().clean(cx);\n+    let self_type = clean_middle_ty(ty.self_ty(), cx, None);\n     let self_def_id = if let Some(def_id) = def_id {\n         cx.tcx.opt_parent(def_id).or(Some(def_id))\n     } else {\n@@ -476,7 +474,7 @@ impl<'tcx> Clean<'tcx, GenericParamDef> for ty::GenericParamDef {\n             }\n             ty::GenericParamDefKind::Type { has_default, synthetic, .. } => {\n                 let default = if has_default {\n-                    Some(clean_ty(cx.tcx.type_of(self.def_id), cx, Some(self.def_id)))\n+                    Some(clean_middle_ty(cx.tcx.type_of(self.def_id), cx, Some(self.def_id)))\n                 } else {\n                     None\n                 };\n@@ -494,7 +492,11 @@ impl<'tcx> Clean<'tcx, GenericParamDef> for ty::GenericParamDef {\n                 self.name,\n                 GenericParamDefKind::Const {\n                     did: self.def_id,\n-                    ty: Box::new(cx.tcx.type_of(self.def_id).clean(cx)),\n+                    ty: Box::new(clean_middle_ty(\n+                        cx.tcx.type_of(self.def_id),\n+                        cx,\n+                        Some(self.def_id),\n+                    )),\n                     default: match has_default {\n                         true => Some(Box::new(cx.tcx.const_param_default(self.def_id).to_string())),\n                         false => None,\n@@ -546,7 +548,7 @@ fn clean_generic_param<'tcx>(\n                 GenericParamDefKind::Type {\n                     did: did.to_def_id(),\n                     bounds,\n-                    default: default.map(|t| t.clean(cx)).map(Box::new),\n+                    default: default.map(|t| clean_ty(t, cx)).map(Box::new),\n                     synthetic,\n                 },\n             )\n@@ -555,7 +557,7 @@ fn clean_generic_param<'tcx>(\n             param.name.ident().name,\n             GenericParamDefKind::Const {\n                 did: did.to_def_id(),\n-                ty: Box::new(ty.clean(cx)),\n+                ty: Box::new(clean_ty(ty, cx)),\n                 default: default.map(|ct| {\n                     let def_id = cx.tcx.hir().local_def_id(ct.hir_id);\n                     Box::new(ty::Const::from_anon_const(cx.tcx, def_id).to_string())\n@@ -752,7 +754,7 @@ fn clean_ty_generics<'tcx>(\n         if let crate::core::ImplTraitParam::ParamIndex(idx) = param {\n             if let Some(proj) = impl_trait_proj.remove(&idx) {\n                 for (trait_did, name, rhs) in proj {\n-                    let rhs = rhs.clean(cx);\n+                    let rhs = clean_middle_ty(rhs, cx, None);\n                     simplify::merge_bounds(cx, &mut bounds, trait_did, name, &Term::Type(rhs));\n                 }\n             }\n@@ -926,7 +928,7 @@ fn clean_args_from_types_and_names<'tcx>(\n                 if name.is_empty() {\n                     name = kw::Underscore;\n                 }\n-                Argument { name, type_: ty.clean(cx), is_const: false }\n+                Argument { name, type_: clean_ty(ty, cx), is_const: false }\n             })\n             .collect(),\n     }\n@@ -945,7 +947,7 @@ fn clean_args_from_types_and_body_id<'tcx>(\n             .enumerate()\n             .map(|(i, ty)| Argument {\n                 name: name_from_pat(body.params[i].pat),\n-                type_: ty.clean(cx),\n+                type_: clean_ty(ty, cx),\n                 is_const: false,\n             })\n             .collect(),\n@@ -969,7 +971,7 @@ fn clean_fn_decl_from_did_and_sig<'tcx>(\n \n     // We assume all empty tuples are default return type. This theoretically can discard `-> ()`,\n     // but shouldn't change any code meaning.\n-    let output = match sig.skip_binder().output().clean(cx) {\n+    let output = match clean_middle_ty(sig.skip_binder().output(), cx, None) {\n         Type::Tuple(inner) if inner.is_empty() => DefaultReturn,\n         ty => Return(ty),\n     };\n@@ -983,7 +985,7 @@ fn clean_fn_decl_from_did_and_sig<'tcx>(\n                 .inputs()\n                 .iter()\n                 .map(|t| Argument {\n-                    type_: t.clean(cx),\n+                    type_: clean_middle_ty(*t, cx, None),\n                     name: names.next().map_or(kw::Empty, |i| i.name),\n                     is_const: false,\n                 })\n@@ -995,7 +997,7 @@ fn clean_fn_decl_from_did_and_sig<'tcx>(\n impl<'tcx> Clean<'tcx, FnRetTy> for hir::FnRetTy<'tcx> {\n     fn clean(&self, cx: &mut DocContext<'tcx>) -> FnRetTy {\n         match *self {\n-            Self::Return(typ) => Return(typ.clean(cx)),\n+            Self::Return(typ) => Return(clean_ty(typ, cx)),\n             Self::DefaultReturn(..) => DefaultReturn,\n         }\n     }\n@@ -1038,10 +1040,10 @@ impl<'tcx> Clean<'tcx, Item> for hir::TraitItem<'tcx> {\n         cx.with_param_env(local_did, |cx| {\n             let inner = match self.kind {\n                 hir::TraitItemKind::Const(ty, Some(default)) => AssocConstItem(\n-                    ty.clean(cx),\n+                    clean_ty(ty, cx),\n                     ConstantKind::Local { def_id: local_did, body: default },\n                 ),\n-                hir::TraitItemKind::Const(ty, None) => TyAssocConstItem(ty.clean(cx)),\n+                hir::TraitItemKind::Const(ty, None) => TyAssocConstItem(clean_ty(ty, cx)),\n                 hir::TraitItemKind::Fn(ref sig, hir::TraitFn::Provided(body)) => {\n                     let m = clean_function(cx, sig, self.generics, body);\n                     MethodItem(m, None)\n@@ -1059,9 +1061,13 @@ impl<'tcx> Clean<'tcx, Item> for hir::TraitItem<'tcx> {\n                 hir::TraitItemKind::Type(bounds, Some(default)) => {\n                     let generics = enter_impl_trait(cx, |cx| self.generics.clean(cx));\n                     let bounds = bounds.iter().filter_map(|x| x.clean(cx)).collect();\n-                    let item_type = hir_ty_to_ty(cx.tcx, default).clean(cx);\n+                    let item_type = clean_middle_ty(hir_ty_to_ty(cx.tcx, default), cx, None);\n                     AssocTypeItem(\n-                        Typedef { type_: default.clean(cx), generics, item_type: Some(item_type) },\n+                        Typedef {\n+                            type_: clean_ty(default, cx),\n+                            generics,\n+                            item_type: Some(item_type),\n+                        },\n                         bounds,\n                     )\n                 }\n@@ -1086,17 +1092,17 @@ impl<'tcx> Clean<'tcx, Item> for hir::ImplItem<'tcx> {\n             let inner = match self.kind {\n                 hir::ImplItemKind::Const(ty, expr) => {\n                     let default = ConstantKind::Local { def_id: local_did, body: expr };\n-                    AssocConstItem(ty.clean(cx), default)\n+                    AssocConstItem(clean_ty(ty, cx), default)\n                 }\n                 hir::ImplItemKind::Fn(ref sig, body) => {\n                     let m = clean_function(cx, sig, self.generics, body);\n                     let defaultness = cx.tcx.associated_item(self.def_id).defaultness;\n                     MethodItem(m, Some(defaultness))\n                 }\n                 hir::ImplItemKind::TyAlias(hir_ty) => {\n-                    let type_ = hir_ty.clean(cx);\n+                    let type_ = clean_ty(hir_ty, cx);\n                     let generics = self.generics.clean(cx);\n-                    let item_type = hir_ty_to_ty(cx.tcx, hir_ty).clean(cx);\n+                    let item_type = clean_middle_ty(hir_ty_to_ty(cx.tcx, hir_ty), cx, None);\n                     AssocTypeItem(\n                         Typedef { type_, generics, item_type: Some(item_type) },\n                         Vec::new(),\n@@ -1125,7 +1131,7 @@ impl<'tcx> Clean<'tcx, Item> for ty::AssocItem {\n         let tcx = cx.tcx;\n         let kind = match self.kind {\n             ty::AssocKind::Const => {\n-                let ty = tcx.type_of(self.def_id).clean(cx);\n+                let ty = clean_middle_ty(tcx.type_of(self.def_id), cx, Some(self.def_id));\n \n                 let provided = match self.container {\n                     ty::ImplContainer(_) => true,\n@@ -1272,7 +1278,11 @@ impl<'tcx> Clean<'tcx, Item> for ty::AssocItem {\n                     if self.defaultness.has_value() {\n                         AssocTypeItem(\n                             Typedef {\n-                                type_: tcx.type_of(self.def_id).clean(cx),\n+                                type_: clean_middle_ty(\n+                                    tcx.type_of(self.def_id),\n+                                    cx,\n+                                    Some(self.def_id),\n+                                ),\n                                 generics,\n                                 // FIXME: should we obtain the Type from HIR and pass it on here?\n                                 item_type: None,\n@@ -1286,7 +1296,7 @@ impl<'tcx> Clean<'tcx, Item> for ty::AssocItem {\n                     // FIXME: when could this happen? Associated items in inherent impls?\n                     AssocTypeItem(\n                         Typedef {\n-                            type_: tcx.type_of(self.def_id).clean(cx),\n+                            type_: clean_middle_ty(tcx.type_of(self.def_id), cx, Some(self.def_id)),\n                             generics: Generics { params: Vec::new(), where_predicates: Vec::new() },\n                             item_type: None,\n                         },\n@@ -1337,7 +1347,7 @@ fn clean_qpath<'tcx>(hir_ty: &hir::Ty<'tcx>, cx: &mut DocContext<'tcx>) -> Type\n             // Try to normalize `<X as Y>::T` to a type\n             let ty = hir_ty_to_ty(cx.tcx, hir_ty);\n             if let Some(normalized_value) = normalize(cx, ty) {\n-                return normalized_value.clean(cx);\n+                return clean_middle_ty(normalized_value, cx, None);\n             }\n \n             let trait_segments = &p.segments[..p.segments.len() - 1];\n@@ -1348,7 +1358,7 @@ fn clean_qpath<'tcx>(hir_ty: &hir::Ty<'tcx>, cx: &mut DocContext<'tcx>) -> Type\n             };\n             register_res(cx, trait_.res);\n             let self_def_id = DefId::local(qself.hir_id.owner.local_def_index);\n-            let self_type = qself.clean(cx);\n+            let self_type = clean_ty(qself, cx);\n             let should_show_cast = compute_should_show_cast(Some(self_def_id), &trait_, &self_type);\n             Type::QPath {\n                 assoc: Box::new(p.segments.last().expect(\"segments were empty\").clean(cx)),\n@@ -1368,7 +1378,7 @@ fn clean_qpath<'tcx>(hir_ty: &hir::Ty<'tcx>, cx: &mut DocContext<'tcx>) -> Type\n             let trait_ = hir::Path { span, res, segments: &[] }.clean(cx);\n             register_res(cx, trait_.res);\n             let self_def_id = res.opt_def_id();\n-            let self_type = qself.clean(cx);\n+            let self_type = clean_ty(qself, cx);\n             let should_show_cast = compute_should_show_cast(self_def_id, &trait_, &self_type);\n             Type::QPath {\n                 assoc: Box::new(segment.clean(cx)),\n@@ -1435,9 +1445,12 @@ fn maybe_expand_private_type_alias<'tcx>(\n                     _ => None,\n                 });\n                 if let Some(ty) = type_ {\n-                    substs.insert(ty_param_def_id.to_def_id(), SubstParam::Type(ty.clean(cx)));\n+                    substs.insert(ty_param_def_id.to_def_id(), SubstParam::Type(clean_ty(ty, cx)));\n                 } else if let Some(default) = *default {\n-                    substs.insert(ty_param_def_id.to_def_id(), SubstParam::Type(default.clean(cx)));\n+                    substs.insert(\n+                        ty_param_def_id.to_def_id(),\n+                        SubstParam::Type(clean_ty(default, cx)),\n+                    );\n                 }\n                 indices.types += 1;\n             }\n@@ -1464,70 +1477,68 @@ fn maybe_expand_private_type_alias<'tcx>(\n         }\n     }\n \n-    Some(cx.enter_alias(substs, |cx| ty.clean(cx)))\n+    Some(cx.enter_alias(substs, |cx| clean_ty(ty, cx)))\n }\n \n-impl<'tcx> Clean<'tcx, Type> for hir::Ty<'tcx> {\n-    fn clean(&self, cx: &mut DocContext<'tcx>) -> Type {\n-        use rustc_hir::*;\n-\n-        match self.kind {\n-            TyKind::Never => Primitive(PrimitiveType::Never),\n-            TyKind::Ptr(ref m) => RawPointer(m.mutbl, Box::new(m.ty.clean(cx))),\n-            TyKind::Rptr(ref l, ref m) => {\n-                // There are two times a `Fresh` lifetime can be created:\n-                // 1. For `&'_ x`, written by the user. This corresponds to `lower_lifetime` in `rustc_ast_lowering`.\n-                // 2. For `&x` as a parameter to an `async fn`. This corresponds to `elided_ref_lifetime in `rustc_ast_lowering`.\n-                //    See #59286 for more information.\n-                // Ideally we would only hide the `'_` for case 2., but I don't know a way to distinguish it.\n-                // Turning `fn f(&'_ self)` into `fn f(&self)` isn't the worst thing in the world, though;\n-                // there's no case where it could cause the function to fail to compile.\n-                let elided =\n-                    l.is_elided() || matches!(l.name, LifetimeName::Param(_, ParamName::Fresh));\n-                let lifetime = if elided { None } else { Some(l.clean(cx)) };\n-                BorrowedRef { lifetime, mutability: m.mutbl, type_: Box::new(m.ty.clean(cx)) }\n-            }\n-            TyKind::Slice(ty) => Slice(Box::new(ty.clean(cx))),\n-            TyKind::Array(ty, ref length) => {\n-                let length = match length {\n-                    hir::ArrayLen::Infer(_, _) => \"_\".to_string(),\n-                    hir::ArrayLen::Body(anon_const) => {\n-                        let def_id = cx.tcx.hir().local_def_id(anon_const.hir_id);\n-                        // NOTE(min_const_generics): We can't use `const_eval_poly` for constants\n-                        // as we currently do not supply the parent generics to anonymous constants\n-                        // but do allow `ConstKind::Param`.\n-                        //\n-                        // `const_eval_poly` tries to to first substitute generic parameters which\n-                        // results in an ICE while manually constructing the constant and using `eval`\n-                        // does nothing for `ConstKind::Param`.\n-                        let ct = ty::Const::from_anon_const(cx.tcx, def_id);\n-                        let param_env = cx.tcx.param_env(def_id);\n-                        print_const(cx, ct.eval(cx.tcx, param_env))\n-                    }\n-                };\n+pub(crate) fn clean_ty<'tcx>(ty: &hir::Ty<'tcx>, cx: &mut DocContext<'tcx>) -> Type {\n+    use rustc_hir::*;\n \n-                Array(Box::new(ty.clean(cx)), length)\n-            }\n-            TyKind::Tup(tys) => Tuple(tys.iter().map(|x| x.clean(cx)).collect()),\n-            TyKind::OpaqueDef(item_id, _) => {\n-                let item = cx.tcx.hir().item(item_id);\n-                if let hir::ItemKind::OpaqueTy(ref ty) = item.kind {\n-                    ImplTrait(ty.bounds.iter().filter_map(|x| x.clean(cx)).collect())\n-                } else {\n-                    unreachable!()\n+    match ty.kind {\n+        TyKind::Never => Primitive(PrimitiveType::Never),\n+        TyKind::Ptr(ref m) => RawPointer(m.mutbl, Box::new(clean_ty(m.ty, cx))),\n+        TyKind::Rptr(ref l, ref m) => {\n+            // There are two times a `Fresh` lifetime can be created:\n+            // 1. For `&'_ x`, written by the user. This corresponds to `lower_lifetime` in `rustc_ast_lowering`.\n+            // 2. For `&x` as a parameter to an `async fn`. This corresponds to `elided_ref_lifetime in `rustc_ast_lowering`.\n+            //    See #59286 for more information.\n+            // Ideally we would only hide the `'_` for case 2., but I don't know a way to distinguish it.\n+            // Turning `fn f(&'_ self)` into `fn f(&self)` isn't the worst thing in the world, though;\n+            // there's no case where it could cause the function to fail to compile.\n+            let elided =\n+                l.is_elided() || matches!(l.name, LifetimeName::Param(_, ParamName::Fresh));\n+            let lifetime = if elided { None } else { Some(l.clean(cx)) };\n+            BorrowedRef { lifetime, mutability: m.mutbl, type_: Box::new(clean_ty(m.ty, cx)) }\n+        }\n+        TyKind::Slice(ty) => Slice(Box::new(clean_ty(ty, cx))),\n+        TyKind::Array(ty, ref length) => {\n+            let length = match length {\n+                hir::ArrayLen::Infer(_, _) => \"_\".to_string(),\n+                hir::ArrayLen::Body(anon_const) => {\n+                    let def_id = cx.tcx.hir().local_def_id(anon_const.hir_id);\n+                    // NOTE(min_const_generics): We can't use `const_eval_poly` for constants\n+                    // as we currently do not supply the parent generics to anonymous constants\n+                    // but do allow `ConstKind::Param`.\n+                    //\n+                    // `const_eval_poly` tries to to first substitute generic parameters which\n+                    // results in an ICE while manually constructing the constant and using `eval`\n+                    // does nothing for `ConstKind::Param`.\n+                    let ct = ty::Const::from_anon_const(cx.tcx, def_id);\n+                    let param_env = cx.tcx.param_env(def_id);\n+                    print_const(cx, ct.eval(cx.tcx, param_env))\n                 }\n+            };\n+\n+            Array(Box::new(clean_ty(ty, cx)), length)\n+        }\n+        TyKind::Tup(tys) => Tuple(tys.iter().map(|ty| clean_ty(ty, cx)).collect()),\n+        TyKind::OpaqueDef(item_id, _) => {\n+            let item = cx.tcx.hir().item(item_id);\n+            if let hir::ItemKind::OpaqueTy(ref ty) = item.kind {\n+                ImplTrait(ty.bounds.iter().filter_map(|x| x.clean(cx)).collect())\n+            } else {\n+                unreachable!()\n             }\n-            TyKind::Path(_) => clean_qpath(self, cx),\n-            TyKind::TraitObject(bounds, ref lifetime, _) => {\n-                let bounds = bounds.iter().map(|bound| bound.clean(cx)).collect();\n-                let lifetime = if !lifetime.is_elided() { Some(lifetime.clean(cx)) } else { None };\n-                DynTrait(bounds, lifetime)\n-            }\n-            TyKind::BareFn(barefn) => BareFunction(Box::new(barefn.clean(cx))),\n-            // Rustdoc handles `TyKind::Err`s by turning them into `Type::Infer`s.\n-            TyKind::Infer | TyKind::Err => Infer,\n-            TyKind::Typeof(..) => panic!(\"unimplemented type {:?}\", self.kind),\n         }\n+        TyKind::Path(_) => clean_qpath(ty, cx),\n+        TyKind::TraitObject(bounds, ref lifetime, _) => {\n+            let bounds = bounds.iter().map(|bound| bound.clean(cx)).collect();\n+            let lifetime = if !lifetime.is_elided() { Some(lifetime.clean(cx)) } else { None };\n+            DynTrait(bounds, lifetime)\n+        }\n+        TyKind::BareFn(barefn) => BareFunction(Box::new(barefn.clean(cx))),\n+        // Rustdoc handles `TyKind::Err`s by turning them into `Type::Infer`s.\n+        TyKind::Infer | TyKind::Err => Infer,\n+        TyKind::Typeof(..) => panic!(\"unimplemented type {:?}\", ty.kind),\n     }\n }\n \n@@ -1562,7 +1573,11 @@ fn normalize<'tcx>(cx: &mut DocContext<'tcx>, ty: Ty<'_>) -> Option<Ty<'tcx>> {\n     }\n }\n \n-fn clean_ty<'tcx>(this: Ty<'tcx>, cx: &mut DocContext<'tcx>, def_id: Option<DefId>) -> Type {\n+pub(crate) fn clean_middle_ty<'tcx>(\n+    this: Ty<'tcx>,\n+    cx: &mut DocContext<'tcx>,\n+    def_id: Option<DefId>,\n+) -> Type {\n     trace!(\"cleaning type: {:?}\", this);\n     let ty = normalize(cx, this).unwrap_or(this);\n     match *ty.kind() {\n@@ -1573,17 +1588,19 @@ fn clean_ty<'tcx>(this: Ty<'tcx>, cx: &mut DocContext<'tcx>, def_id: Option<DefI\n         ty::Uint(uint_ty) => Primitive(uint_ty.into()),\n         ty::Float(float_ty) => Primitive(float_ty.into()),\n         ty::Str => Primitive(PrimitiveType::Str),\n-        ty::Slice(ty) => Slice(Box::new(ty.clean(cx))),\n+        ty::Slice(ty) => Slice(Box::new(clean_middle_ty(ty, cx, None))),\n         ty::Array(ty, n) => {\n             let mut n = cx.tcx.lift(n).expect(\"array lift failed\");\n             n = n.eval(cx.tcx, ty::ParamEnv::reveal_all());\n             let n = print_const(cx, n);\n-            Array(Box::new(ty.clean(cx)), n)\n-        }\n-        ty::RawPtr(mt) => RawPointer(mt.mutbl, Box::new(mt.ty.clean(cx))),\n-        ty::Ref(r, ty, mutbl) => {\n-            BorrowedRef { lifetime: r.clean(cx), mutability: mutbl, type_: Box::new(ty.clean(cx)) }\n+            Array(Box::new(clean_middle_ty(ty, cx, None)), n)\n         }\n+        ty::RawPtr(mt) => RawPointer(mt.mutbl, Box::new(clean_middle_ty(mt.ty, cx, None))),\n+        ty::Ref(r, ty, mutbl) => BorrowedRef {\n+            lifetime: r.clean(cx),\n+            mutability: mutbl,\n+            type_: Box::new(clean_middle_ty(ty, cx, None)),\n+        },\n         ty::FnDef(..) | ty::FnPtr(_) => {\n             let ty = cx.tcx.lift(this).expect(\"FnPtr lift failed\");\n             let sig = ty.fn_sig(cx.tcx);\n@@ -1660,7 +1677,7 @@ fn clean_ty<'tcx>(this: Ty<'tcx>, cx: &mut DocContext<'tcx>, def_id: Option<DefI\n \n             DynTrait(bounds, lifetime)\n         }\n-        ty::Tuple(t) => Tuple(t.iter().map(|t| t.clean(cx)).collect()),\n+        ty::Tuple(t) => Tuple(t.iter().map(|t| clean_middle_ty(t, cx, None)).collect()),\n \n         ty::Projection(ref data) => clean_projection(*data, cx, def_id),\n \n@@ -1747,17 +1764,11 @@ fn clean_ty<'tcx>(this: Ty<'tcx>, cx: &mut DocContext<'tcx>, def_id: Option<DefI\n     }\n }\n \n-impl<'tcx> Clean<'tcx, Type> for Ty<'tcx> {\n-    fn clean(&self, cx: &mut DocContext<'tcx>) -> Type {\n-        clean_ty(*self, cx, None)\n-    }\n-}\n-\n impl<'tcx> Clean<'tcx, Constant> for ty::Const<'tcx> {\n     fn clean(&self, cx: &mut DocContext<'tcx>) -> Constant {\n         // FIXME: instead of storing the stringified expression, store `self` directly instead.\n         Constant {\n-            type_: self.ty().clean(cx),\n+            type_: clean_middle_ty(self.ty(), cx, None),\n             kind: ConstantKind::TyConst { expr: self.to_string() },\n         }\n     }\n@@ -1766,13 +1777,18 @@ impl<'tcx> Clean<'tcx, Constant> for ty::Const<'tcx> {\n impl<'tcx> Clean<'tcx, Item> for hir::FieldDef<'tcx> {\n     fn clean(&self, cx: &mut DocContext<'tcx>) -> Item {\n         let def_id = cx.tcx.hir().local_def_id(self.hir_id).to_def_id();\n-        clean_field(def_id, self.ident.name, self.ty.clean(cx), cx)\n+        clean_field(def_id, self.ident.name, clean_ty(self.ty, cx), cx)\n     }\n }\n \n impl<'tcx> Clean<'tcx, Item> for ty::FieldDef {\n     fn clean(&self, cx: &mut DocContext<'tcx>) -> Item {\n-        clean_field(self.did, self.name, cx.tcx.type_of(self.did).clean(cx), cx)\n+        clean_field(\n+            self.did,\n+            self.name,\n+            clean_middle_ty(cx.tcx.type_of(self.did), cx, Some(self.did)),\n+            cx,\n+        )\n     }\n }\n \n@@ -1863,10 +1879,10 @@ impl<'tcx> Clean<'tcx, Path> for hir::Path<'tcx> {\n impl<'tcx> Clean<'tcx, GenericArgs> for hir::GenericArgs<'tcx> {\n     fn clean(&self, cx: &mut DocContext<'tcx>) -> GenericArgs {\n         if self.parenthesized {\n-            let output = self.bindings[0].ty().clean(cx);\n+            let output = clean_ty(self.bindings[0].ty(), cx);\n             let output =\n                 if output != Type::Tuple(Vec::new()) { Some(Box::new(output)) } else { None };\n-            let inputs = self.inputs().iter().map(|x| x.clean(cx)).collect::<Vec<_>>().into();\n+            let inputs = self.inputs().iter().map(|x| clean_ty(x, cx)).collect::<Vec<_>>().into();\n             GenericArgs::Parenthesized { inputs, output }\n         } else {\n             let args = self\n@@ -1877,7 +1893,7 @@ impl<'tcx> Clean<'tcx, GenericArgs> for hir::GenericArgs<'tcx> {\n                         GenericArg::Lifetime(lt.clean(cx))\n                     }\n                     hir::GenericArg::Lifetime(_) => GenericArg::Lifetime(Lifetime::elided()),\n-                    hir::GenericArg::Type(ty) => GenericArg::Type(ty.clean(cx)),\n+                    hir::GenericArg::Type(ty) => GenericArg::Type(clean_ty(ty, cx)),\n                     hir::GenericArg::Const(ct) => GenericArg::Const(Box::new(ct.clean(cx))),\n                     hir::GenericArg::Infer(_inf) => GenericArg::Infer,\n                 })\n@@ -1925,19 +1941,19 @@ fn clean_maybe_renamed_item<'tcx>(\n     cx.with_param_env(def_id, |cx| {\n         let kind = match item.kind {\n             ItemKind::Static(ty, mutability, body_id) => {\n-                StaticItem(Static { type_: ty.clean(cx), mutability, expr: Some(body_id) })\n+                StaticItem(Static { type_: clean_ty(ty, cx), mutability, expr: Some(body_id) })\n             }\n             ItemKind::Const(ty, body_id) => ConstantItem(Constant {\n-                type_: ty.clean(cx),\n+                type_: clean_ty(ty, cx),\n                 kind: ConstantKind::Local { body: body_id, def_id },\n             }),\n             ItemKind::OpaqueTy(ref ty) => OpaqueTyItem(OpaqueTy {\n                 bounds: ty.bounds.iter().filter_map(|x| x.clean(cx)).collect(),\n                 generics: ty.generics.clean(cx),\n             }),\n             ItemKind::TyAlias(hir_ty, generics) => {\n-                let rustdoc_ty = hir_ty.clean(cx);\n-                let ty = hir_ty_to_ty(cx.tcx, hir_ty).clean(cx);\n+                let rustdoc_ty = clean_ty(hir_ty, cx);\n+                let ty = clean_middle_ty(hir_ty_to_ty(cx.tcx, hir_ty), cx, None);\n                 TypedefItem(Typedef {\n                     type_: rustdoc_ty,\n                     generics: generics.clean(cx),\n@@ -2023,9 +2039,9 @@ fn clean_impl<'tcx>(\n         build_deref_target_impls(cx, &items, &mut ret);\n     }\n \n-    let for_ = impl_.self_ty.clean(cx);\n+    let for_ = clean_ty(impl_.self_ty, cx);\n     let type_alias = for_.def_id(&cx.cache).and_then(|did| match tcx.def_kind(did) {\n-        DefKind::TyAlias => Some(tcx.type_of(did).clean(cx)),\n+        DefKind::TyAlias => Some(clean_middle_ty(tcx.type_of(did), cx, Some(did))),\n         _ => None,\n     });\n     let mut make_item = |trait_: Option<Path>, for_: Type, items: Vec<Item>| {\n@@ -2234,7 +2250,7 @@ fn clean_maybe_renamed_foreign_item<'tcx>(\n                 ForeignFunctionItem(Function { decl, generics })\n             }\n             hir::ForeignItemKind::Static(ty, mutability) => {\n-                ForeignStaticItem(Static { type_: ty.clean(cx), mutability, expr: None })\n+                ForeignStaticItem(Static { type_: clean_ty(ty, cx), mutability, expr: None })\n             }\n             hir::ForeignItemKind::Type => ForeignTypeItem,\n         };"}, {"sha": "00d62b374845526cb92bf13f1eee68fee006a2a5", "filename": "src/librustdoc/clean/utils.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fcad91868a515c51d0762bf6c7af2bedc11cc348/src%2Flibrustdoc%2Fclean%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fcad91868a515c51d0762bf6c7af2bedc11cc348/src%2Flibrustdoc%2Fclean%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Futils.rs?ref=fcad91868a515c51d0762bf6c7af2bedc11cc348", "patch": "@@ -2,8 +2,9 @@ use crate::clean::auto_trait::AutoTraitFinder;\n use crate::clean::blanket_impl::BlanketImplFinder;\n use crate::clean::render_macro_matchers::render_macro_matcher;\n use crate::clean::{\n-    inline, Clean, Crate, ExternalCrate, Generic, GenericArg, GenericArgs, ImportSource, Item,\n-    ItemKind, Lifetime, Path, PathSegment, Primitive, PrimitiveType, Type, TypeBinding, Visibility,\n+    clean_middle_ty, inline, Clean, Crate, ExternalCrate, Generic, GenericArg, GenericArgs,\n+    ImportSource, Item, ItemKind, Lifetime, Path, PathSegment, Primitive, PrimitiveType, Type,\n+    TypeBinding, Visibility,\n };\n use crate::core::DocContext;\n use crate::formats::item_type::ItemType;\n@@ -91,7 +92,7 @@ pub(crate) fn substs_to_args<'tcx>(\n             skip_first = false;\n             None\n         }\n-        GenericArgKind::Type(ty) => Some(GenericArg::Type(ty.clean(cx))),\n+        GenericArgKind::Type(ty) => Some(GenericArg::Type(clean_middle_ty(ty, cx, None))),\n         GenericArgKind::Const(ct) => Some(GenericArg::Const(Box::new(ct.clean(cx)))),\n     }));\n     ret_val\n@@ -110,7 +111,7 @@ fn external_generic_args<'tcx>(\n         let inputs =\n             // The trait's first substitution is the one after self, if there is one.\n             match substs.iter().nth(if has_self { 1 } else { 0 }).unwrap().expect_ty().kind() {\n-                ty::Tuple(tys) => tys.iter().map(|t| t.clean(cx)).collect::<Vec<_>>().into(),\n+                ty::Tuple(tys) => tys.iter().map(|t| clean_middle_ty(t, cx, None)).collect::<Vec<_>>().into(),\n                 _ => return GenericArgs::AngleBracketed { args: args.into(), bindings: bindings.into() },\n             };\n         let output = None;"}, {"sha": "85eaf53364315580d6005d214943b254435c0947", "filename": "src/test/ui-fulldeps/gated-plugin.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fcad91868a515c51d0762bf6c7af2bedc11cc348/src%2Ftest%2Fui-fulldeps%2Fgated-plugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fcad91868a515c51d0762bf6c7af2bedc11cc348/src%2Ftest%2Fui-fulldeps%2Fgated-plugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fgated-plugin.rs?ref=fcad91868a515c51d0762bf6c7af2bedc11cc348", "patch": "@@ -1,4 +1,5 @@\n // aux-build:empty-plugin.rs\n+// ignore-stage1\n \n #![plugin(empty_plugin)]\n //~^ ERROR compiler plugins are deprecated"}, {"sha": "f48f1eab60b9563735abc90bc114e609d578c4e9", "filename": "src/test/ui-fulldeps/gated-plugin.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fcad91868a515c51d0762bf6c7af2bedc11cc348/src%2Ftest%2Fui-fulldeps%2Fgated-plugin.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fcad91868a515c51d0762bf6c7af2bedc11cc348/src%2Ftest%2Fui-fulldeps%2Fgated-plugin.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fgated-plugin.stderr?ref=fcad91868a515c51d0762bf6c7af2bedc11cc348", "patch": "@@ -1,5 +1,5 @@\n error[E0658]: compiler plugins are deprecated\n-  --> $DIR/gated-plugin.rs:3:1\n+  --> $DIR/gated-plugin.rs:4:1\n    |\n LL | #![plugin(empty_plugin)]\n    | ^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -8,7 +8,7 @@ LL | #![plugin(empty_plugin)]\n    = help: add `#![feature(plugin)]` to the crate attributes to enable\n \n warning: use of deprecated attribute `plugin`: compiler plugins are deprecated. See https://github.com/rust-lang/rust/pull/64675\n-  --> $DIR/gated-plugin.rs:3:1\n+  --> $DIR/gated-plugin.rs:4:1\n    |\n LL | #![plugin(empty_plugin)]\n    | ^^^^^^^^^^^^^^^^^^^^^^^^ help: may be removed in a future compiler version"}, {"sha": "9af3ebd570ccaca1049a1e58010ed8439860e258", "filename": "src/test/ui-fulldeps/multiple-plugins.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fcad91868a515c51d0762bf6c7af2bedc11cc348/src%2Ftest%2Fui-fulldeps%2Fmultiple-plugins.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fcad91868a515c51d0762bf6c7af2bedc11cc348/src%2Ftest%2Fui-fulldeps%2Fmultiple-plugins.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fmultiple-plugins.rs?ref=fcad91868a515c51d0762bf6c7af2bedc11cc348", "patch": "@@ -1,6 +1,7 @@\n // run-pass\n // aux-build:multiple-plugins-1.rs\n // aux-build:multiple-plugins-2.rs\n+// ignore-stage1\n \n // Check that the plugin registrar of multiple plugins doesn't conflict\n "}, {"sha": "878ffabfc7fc2c14e919b8afdba057e7c8cd0167", "filename": "src/test/ui-fulldeps/multiple-plugins.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fcad91868a515c51d0762bf6c7af2bedc11cc348/src%2Ftest%2Fui-fulldeps%2Fmultiple-plugins.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fcad91868a515c51d0762bf6c7af2bedc11cc348/src%2Ftest%2Fui-fulldeps%2Fmultiple-plugins.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fmultiple-plugins.stderr?ref=fcad91868a515c51d0762bf6c7af2bedc11cc348", "patch": "@@ -1,13 +1,13 @@\n warning: use of deprecated attribute `plugin`: compiler plugins are deprecated. See https://github.com/rust-lang/rust/pull/64675\n-  --> $DIR/multiple-plugins.rs:8:1\n+  --> $DIR/multiple-plugins.rs:9:1\n    |\n LL | #![plugin(multiple_plugins_1)]\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: may be removed in a future compiler version\n    |\n    = note: `#[warn(deprecated)]` on by default\n \n warning: use of deprecated attribute `plugin`: compiler plugins are deprecated. See https://github.com/rust-lang/rust/pull/64675\n-  --> $DIR/multiple-plugins.rs:9:1\n+  --> $DIR/multiple-plugins.rs:10:1\n    |\n LL | #![plugin(multiple_plugins_2)]\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: may be removed in a future compiler version"}, {"sha": "c2618a96716a5672fcfb0adbdcd443a12e6c6a00", "filename": "src/test/ui/argument-suggestions/issue-98894.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fcad91868a515c51d0762bf6c7af2bedc11cc348/src%2Ftest%2Fui%2Fargument-suggestions%2Fissue-98894.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fcad91868a515c51d0762bf6c7af2bedc11cc348/src%2Ftest%2Fui%2Fargument-suggestions%2Fissue-98894.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fargument-suggestions%2Fissue-98894.rs?ref=fcad91868a515c51d0762bf6c7af2bedc11cc348", "patch": "@@ -0,0 +1,4 @@\n+fn main() {\n+    (|_, ()| ())(if true {} else {return;});\n+    //~^ ERROR this function takes 2 arguments but 1 argument was supplied\n+}"}, {"sha": "0c8b94901e16f4967b790c04ef2310dff26694a4", "filename": "src/test/ui/argument-suggestions/issue-98894.stderr", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/fcad91868a515c51d0762bf6c7af2bedc11cc348/src%2Ftest%2Fui%2Fargument-suggestions%2Fissue-98894.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fcad91868a515c51d0762bf6c7af2bedc11cc348/src%2Ftest%2Fui%2Fargument-suggestions%2Fissue-98894.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fargument-suggestions%2Fissue-98894.stderr?ref=fcad91868a515c51d0762bf6c7af2bedc11cc348", "patch": "@@ -0,0 +1,19 @@\n+error[E0057]: this function takes 2 arguments but 1 argument was supplied\n+  --> $DIR/issue-98894.rs:2:5\n+   |\n+LL |     (|_, ()| ())(if true {} else {return;});\n+   |     ^^^^^^^^^^^^--------------------------- an argument of type `()` is missing\n+   |\n+note: closure defined here\n+  --> $DIR/issue-98894.rs:2:6\n+   |\n+LL |     (|_, ()| ())(if true {} else {return;});\n+   |      ^^^^^^^\n+help: provide the argument\n+   |\n+LL |     (|_, ()| ())(if true {} else {return;}, ());\n+   |     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0057`."}, {"sha": "c55f495d69862a6537e5db3ff3f0e6e3092638fa", "filename": "src/test/ui/argument-suggestions/issue-98897.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fcad91868a515c51d0762bf6c7af2bedc11cc348/src%2Ftest%2Fui%2Fargument-suggestions%2Fissue-98897.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fcad91868a515c51d0762bf6c7af2bedc11cc348/src%2Ftest%2Fui%2Fargument-suggestions%2Fissue-98897.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fargument-suggestions%2Fissue-98897.rs?ref=fcad91868a515c51d0762bf6c7af2bedc11cc348", "patch": "@@ -0,0 +1,4 @@\n+fn main() {\n+    (|_, ()| ())([return, ()]);\n+    //~^ ERROR this function takes 2 arguments but 1 argument was supplied\n+}"}, {"sha": "8f0d98d09e89e1e68b96401d3d2a99358e39a5e4", "filename": "src/test/ui/argument-suggestions/issue-98897.stderr", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/fcad91868a515c51d0762bf6c7af2bedc11cc348/src%2Ftest%2Fui%2Fargument-suggestions%2Fissue-98897.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fcad91868a515c51d0762bf6c7af2bedc11cc348/src%2Ftest%2Fui%2Fargument-suggestions%2Fissue-98897.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fargument-suggestions%2Fissue-98897.stderr?ref=fcad91868a515c51d0762bf6c7af2bedc11cc348", "patch": "@@ -0,0 +1,19 @@\n+error[E0057]: this function takes 2 arguments but 1 argument was supplied\n+  --> $DIR/issue-98897.rs:2:5\n+   |\n+LL |     (|_, ()| ())([return, ()]);\n+   |     ^^^^^^^^^^^^-------------- an argument of type `()` is missing\n+   |\n+note: closure defined here\n+  --> $DIR/issue-98897.rs:2:6\n+   |\n+LL |     (|_, ()| ())([return, ()]);\n+   |      ^^^^^^^\n+help: provide the argument\n+   |\n+LL |     (|_, ()| ())([return, ()], ());\n+   |     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0057`."}, {"sha": "b024decd4e11c47febab19e1329e0d033d41e05a", "filename": "src/test/ui/const-generics/issues/issue-86530.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fcad91868a515c51d0762bf6c7af2bedc11cc348/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-86530.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fcad91868a515c51d0762bf6c7af2bedc11cc348/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-86530.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-86530.rs?ref=fcad91868a515c51d0762bf6c7af2bedc11cc348", "patch": "@@ -15,7 +15,6 @@ where\n fn unit_literals() {\n     z(\" \");\n     //~^ ERROR: the trait bound `&str: X` is not satisfied\n-    //~| ERROR: unconstrained generic constant\n }\n \n fn main() {}"}, {"sha": "c63857b2314e9422f5fe31f8f78409df45b212a2", "filename": "src/test/ui/const-generics/issues/issue-86530.stderr", "status": "modified", "additions": 1, "deletions": 17, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/fcad91868a515c51d0762bf6c7af2bedc11cc348/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-86530.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fcad91868a515c51d0762bf6c7af2bedc11cc348/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-86530.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-86530.stderr?ref=fcad91868a515c51d0762bf6c7af2bedc11cc348", "patch": "@@ -15,22 +15,6 @@ LL | where\n LL |     T: X,\n    |        ^ required by this bound in `z`\n \n-error: unconstrained generic constant\n-  --> $DIR/issue-86530.rs:16:5\n-   |\n-LL |     z(\" \");\n-   |     ^\n-   |\n-   = help: try adding a `where` bound using this expression: `where [(); T::Y]:`\n-note: required by a bound in `z`\n-  --> $DIR/issue-86530.rs:11:10\n-   |\n-LL | fn z<T>(t: T)\n-   |    - required by a bound in this\n-...\n-LL |     [(); T::Y]: ,\n-   |          ^^^^ required by this bound in `z`\n-\n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n \n For more information about this error, try `rustc --explain E0277`."}, {"sha": "fc8666bbcdb79c1862463b271400f2935c0c0f74", "filename": "src/test/ui/const-generics/issues/issue-98629.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/fcad91868a515c51d0762bf6c7af2bedc11cc348/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-98629.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fcad91868a515c51d0762bf6c7af2bedc11cc348/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-98629.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-98629.rs?ref=fcad91868a515c51d0762bf6c7af2bedc11cc348", "patch": "@@ -0,0 +1,15 @@\n+#![feature(const_trait_impl)]\n+\n+trait Trait {\n+    const N: usize;\n+}\n+\n+impl const Trait for i32 {}\n+//~^ ERROR not all trait items implemented, missing: `N`\n+\n+fn f()\n+where\n+    [(); <i32 as Trait>::N]:,\n+{}\n+\n+fn main() {}"}, {"sha": "53570220882c34a68f17015a74dc92beb7abc085", "filename": "src/test/ui/const-generics/issues/issue-98629.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fcad91868a515c51d0762bf6c7af2bedc11cc348/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-98629.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fcad91868a515c51d0762bf6c7af2bedc11cc348/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-98629.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-98629.stderr?ref=fcad91868a515c51d0762bf6c7af2bedc11cc348", "patch": "@@ -0,0 +1,12 @@\n+error[E0046]: not all trait items implemented, missing: `N`\n+  --> $DIR/issue-98629.rs:7:1\n+   |\n+LL |     const N: usize;\n+   |     -------------- `N` from trait\n+...\n+LL | impl const Trait for i32 {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^ missing `N` in implementation\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0046`."}, {"sha": "966d76d148af3f69d901198d4955d3b4654d769a", "filename": "src/test/ui/issues/issue-77919.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fcad91868a515c51d0762bf6c7af2bedc11cc348/src%2Ftest%2Fui%2Fissues%2Fissue-77919.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fcad91868a515c51d0762bf6c7af2bedc11cc348/src%2Ftest%2Fui%2Fissues%2Fissue-77919.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-77919.rs?ref=fcad91868a515c51d0762bf6c7af2bedc11cc348", "patch": "@@ -1,6 +1,5 @@\n fn main() {\n     [1; <Multiply<Five, Five>>::VAL];\n-    //~^ ERROR: constant expression depends on a generic parameter\n }\n trait TypeVal<T> {\n     const VAL: T;"}, {"sha": "ca256847b1f3bb9589f82a5d9371395e83e5bb8b", "filename": "src/test/ui/issues/issue-77919.stderr", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/fcad91868a515c51d0762bf6c7af2bedc11cc348/src%2Ftest%2Fui%2Fissues%2Fissue-77919.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fcad91868a515c51d0762bf6c7af2bedc11cc348/src%2Ftest%2Fui%2Fissues%2Fissue-77919.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-77919.stderr?ref=fcad91868a515c51d0762bf6c7af2bedc11cc348", "patch": "@@ -1,5 +1,5 @@\n error[E0412]: cannot find type `PhantomData` in this scope\n-  --> $DIR/issue-77919.rs:10:9\n+  --> $DIR/issue-77919.rs:9:9\n    |\n LL |     _n: PhantomData,\n    |         ^^^^^^^^^^^ not found in this scope\n@@ -10,31 +10,23 @@ LL | use std::marker::PhantomData;\n    |\n \n error[E0412]: cannot find type `VAL` in this scope\n-  --> $DIR/issue-77919.rs:12:63\n+  --> $DIR/issue-77919.rs:11:63\n    |\n LL | impl<N, M> TypeVal<usize> for Multiply<N, M> where N: TypeVal<VAL> {}\n    |          -                                                    ^^^ not found in this scope\n    |          |\n    |          help: you might be missing a type parameter: `, VAL`\n \n error[E0046]: not all trait items implemented, missing: `VAL`\n-  --> $DIR/issue-77919.rs:12:1\n+  --> $DIR/issue-77919.rs:11:1\n    |\n LL |     const VAL: T;\n    |     ------------ `VAL` from trait\n ...\n LL | impl<N, M> TypeVal<usize> for Multiply<N, M> where N: TypeVal<VAL> {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `VAL` in implementation\n \n-error: constant expression depends on a generic parameter\n-  --> $DIR/issue-77919.rs:2:9\n-   |\n-LL |     [1; <Multiply<Five, Five>>::VAL];\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: this may fail depending on what value the parameter takes\n-\n-error: aborting due to 4 previous errors\n+error: aborting due to 3 previous errors\n \n Some errors have detailed explanations: E0046, E0412.\n For more information about an error, try `rustc --explain E0046`."}, {"sha": "638e4a5484932d3585c593c489fda1e5b4e89beb", "filename": "src/tools/clippy/tests/ui/crashes/ice-6252.stderr", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fcad91868a515c51d0762bf6c7af2bedc11cc348/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcrashes%2Fice-6252.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fcad91868a515c51d0762bf6c7af2bedc11cc348/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcrashes%2Fice-6252.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcrashes%2Fice-6252.stderr?ref=fcad91868a515c51d0762bf6c7af2bedc11cc348", "patch": "@@ -30,15 +30,7 @@ LL |     const VAL: T;\n LL | impl<N, M> TypeVal<usize> for Multiply<N, M> where N: TypeVal<VAL> {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `VAL` in implementation\n \n-error: constant expression depends on a generic parameter\n-  --> $DIR/ice-6252.rs:13:9\n-   |\n-LL |     [1; <Multiply<Five, Five>>::VAL];\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: this may fail depending on what value the parameter takes\n-\n-error: aborting due to 4 previous errors\n+error: aborting due to 3 previous errors\n \n Some errors have detailed explanations: E0046, E0412.\n For more information about an error, try `rustc --explain E0046`."}]}