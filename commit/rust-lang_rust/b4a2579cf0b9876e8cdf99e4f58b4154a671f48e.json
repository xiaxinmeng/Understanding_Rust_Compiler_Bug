{"sha": "b4a2579cf0b9876e8cdf99e4f58b4154a671f48e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI0YTI1NzljZjBiOTg3NmU4Y2RmOTllNGY1OGI0MTU0YTY3MWY0OGU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-01-22T07:55:13Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-01-22T07:55:13Z"}, "message": "Auto merge of #31072 - arielb1:method-callee-cleanup, r=michaelwoerister\n\nThe old code was terribly ugly and was duplicated in several places.\n\nr? @michaelwoerister", "tree": {"sha": "49aa1025657e9ba6ac05654efe9e6845274c41bb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/49aa1025657e9ba6ac05654efe9e6845274c41bb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b4a2579cf0b9876e8cdf99e4f58b4154a671f48e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b4a2579cf0b9876e8cdf99e4f58b4154a671f48e", "html_url": "https://github.com/rust-lang/rust/commit/b4a2579cf0b9876e8cdf99e4f58b4154a671f48e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b4a2579cf0b9876e8cdf99e4f58b4154a671f48e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "00ee90f0f091916c3a4d42c48ccd71186186ffae", "url": "https://api.github.com/repos/rust-lang/rust/commits/00ee90f0f091916c3a4d42c48ccd71186186ffae", "html_url": "https://github.com/rust-lang/rust/commit/00ee90f0f091916c3a4d42c48ccd71186186ffae"}, {"sha": "0a01d0b7323a690f3b084ea5ce3c5ec4d5e0b3a3", "url": "https://api.github.com/repos/rust-lang/rust/commits/0a01d0b7323a690f3b084ea5ce3c5ec4d5e0b3a3", "html_url": "https://github.com/rust-lang/rust/commit/0a01d0b7323a690f3b084ea5ce3c5ec4d5e0b3a3"}], "stats": {"total": 263, "additions": 76, "deletions": 187}, "files": [{"sha": "ef011067cd077c36f0784d4b3118db504aafc0cf", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 5, "deletions": 14, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/b4a2579cf0b9876e8cdf99e4f58b4154a671f48e/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4a2579cf0b9876e8cdf99e4f58b4154a671f48e/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=b4a2579cf0b9876e8cdf99e4f58b4154a671f48e", "patch": "@@ -1233,20 +1233,11 @@ fn resolve_trait_associated_const<'a, 'tcx: 'a>(tcx: &'a ty::ctxt<'tcx>,\n                                                 rcvr_substs: subst::Substs<'tcx>)\n                                                 -> Option<&'tcx Expr>\n {\n-    let subst::SeparateVecsPerParamSpace {\n-        types: rcvr_type,\n-        selfs: rcvr_self,\n-        fns: _,\n-    } = rcvr_substs.types.split();\n-    let trait_substs =\n-        subst::Substs::erased(subst::VecPerParamSpace::new(rcvr_type,\n-                                                           rcvr_self,\n-                                                           Vec::new()));\n-    let trait_substs = tcx.mk_substs(trait_substs);\n-    debug!(\"resolve_trait_associated_const: trait_substs={:?}\",\n-           trait_substs);\n-    let trait_ref = ty::Binder(ty::TraitRef { def_id: trait_id,\n-                                              substs: trait_substs });\n+    let trait_ref = ty::Binder(\n+        rcvr_substs.erase_regions().to_trait_ref(tcx, trait_id)\n+    );\n+    debug!(\"resolve_trait_associated_const: trait_ref={:?}\",\n+           trait_ref);\n \n     tcx.populate_implementations_for_trait_if_necessary(trait_ref.def_id());\n     let infcx = infer::new_infer_ctxt(tcx, &tcx.tables, None);"}, {"sha": "ddc817ffc023e0ee5c40c8436367334f6ff9cba9", "filename": "src/librustc/middle/subst.rs", "status": "modified", "additions": 30, "deletions": 11, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/b4a2579cf0b9876e8cdf99e4f58b4154a671f48e/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4a2579cf0b9876e8cdf99e4f58b4154a671f48e/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsubst.rs?ref=b4a2579cf0b9876e8cdf99e4f58b4154a671f48e", "patch": "@@ -14,6 +14,7 @@ pub use self::ParamSpace::*;\n pub use self::RegionSubsts::*;\n \n use middle::cstore;\n+use middle::def_id::DefId;\n use middle::ty::{self, Ty};\n use middle::ty::fold::{TypeFoldable, TypeFolder};\n \n@@ -142,16 +143,34 @@ impl<'tcx> Substs<'tcx> {\n                        -> Substs<'tcx>\n     {\n         let Substs { types, regions } = self;\n-        let types = types.with_vec(FnSpace, m_types);\n-        let regions = regions.map(|r| r.with_vec(FnSpace, m_regions));\n+        let types = types.with_slice(FnSpace, &m_types);\n+        let regions = regions.map(|r| r.with_slice(FnSpace, &m_regions));\n         Substs { types: types, regions: regions }\n     }\n \n-    pub fn method_to_trait(self) -> Substs<'tcx> {\n-        let Substs { mut types, regions } = self;\n+    pub fn with_method_from(self,\n+                            meth_substs: &Substs<'tcx>)\n+                            -> Substs<'tcx>\n+    {\n+        let Substs { types, regions } = self;\n+        let types = types.with_slice(FnSpace, meth_substs.types.get_slice(FnSpace));\n+        let regions = regions.map(|r| {\n+            r.with_slice(FnSpace, meth_substs.regions().get_slice(FnSpace))\n+        });\n+        Substs { types: types, regions: regions }\n+    }\n+\n+    /// Creates a trait-ref out of this substs, ignoring the FnSpace substs\n+    pub fn to_trait_ref(&self, tcx: &ty::ctxt<'tcx>, trait_id: DefId)\n+                        -> ty::TraitRef<'tcx> {\n+        let Substs { mut types, regions } = self.clone();\n         types.truncate(FnSpace, 0);\n         let regions = regions.map(|mut r| { r.truncate(FnSpace, 0); r });\n-        Substs { types: types, regions: regions }\n+\n+        ty::TraitRef {\n+            def_id: trait_id,\n+            substs: tcx.mk_substs(Substs { types: types, regions: regions })\n+        }\n     }\n }\n \n@@ -290,10 +309,6 @@ impl<T> VecPerParamSpace<T> {\n         }\n     }\n \n-    pub fn params_from_type(types: Vec<T>) -> VecPerParamSpace<T> {\n-        VecPerParamSpace::empty().with_vec(TypeSpace, types)\n-    }\n-\n     /// `t` is the type space.\n     /// `s` is the self space.\n     /// `f` is the fn space.\n@@ -483,11 +498,15 @@ impl<T> VecPerParamSpace<T> {\n         }\n     }\n \n-    pub fn with_vec(mut self, space: ParamSpace, vec: Vec<T>)\n+    pub fn with_slice(mut self, space: ParamSpace, slice: &[T])\n                     -> VecPerParamSpace<T>\n+        where T: Clone\n     {\n         assert!(self.is_empty_in(space));\n-        self.replace(space, vec);\n+        for t in slice {\n+            self.push(space, t.clone());\n+        }\n+\n         self\n     }\n }"}, {"sha": "8cfd27843aee238e135ad022a198c7bf33751633", "filename": "src/librustc/middle/ty/util.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b4a2579cf0b9876e8cdf99e4f58b4154a671f48e/src%2Flibrustc%2Fmiddle%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4a2579cf0b9876e8cdf99e4f58b4154a671f48e/src%2Flibrustc%2Fmiddle%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Futil.rs?ref=b4a2579cf0b9876e8cdf99e4f58b4154a671f48e", "patch": "@@ -604,7 +604,6 @@ pub struct ImplMethod<'tcx> {\n }\n \n impl<'tcx> ty::ctxt<'tcx> {\n-    #[inline(never)] // is this perfy enough?\n     pub fn get_impl_method(&self,\n                            impl_def_id: DefId,\n                            substs: Substs<'tcx>,"}, {"sha": "9e3ca70e5e42d701c8aa287d46f8081fe064b4fa", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b4a2579cf0b9876e8cdf99e4f58b4154a671f48e/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4a2579cf0b9876e8cdf99e4f58b4154a671f48e/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=b4a2579cf0b9876e8cdf99e4f58b4154a671f48e", "patch": "@@ -855,9 +855,7 @@ impl LateLintPass for UnconditionalRecursion {\n                 // A trait method, from any number of possible sources.\n                 // Attempt to select a concrete impl before checking.\n                 ty::TraitContainer(trait_def_id) => {\n-                    let trait_substs = callee_substs.clone().method_to_trait();\n-                    let trait_substs = tcx.mk_substs(trait_substs);\n-                    let trait_ref = ty::TraitRef::new(trait_def_id, trait_substs);\n+                    let trait_ref = callee_substs.to_trait_ref(tcx, trait_def_id);\n                     let trait_ref = ty::Binder(trait_ref);\n                     let span = tcx.map.span(expr_id);\n                     let obligation ="}, {"sha": "ed47e529d4906a24f93322932141e3eb4d2035b3", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b4a2579cf0b9876e8cdf99e4f58b4154a671f48e/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4a2579cf0b9876e8cdf99e4f58b4154a671f48e/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=b4a2579cf0b9876e8cdf99e4f58b4154a671f48e", "patch": "@@ -1049,9 +1049,9 @@ pub enum ExprOrMethodCall {\n }\n \n pub fn node_id_substs<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                            node: ExprOrMethodCall,\n-                            param_substs: &subst::Substs<'tcx>)\n-                            -> subst::Substs<'tcx> {\n+                                node: ExprOrMethodCall,\n+                                param_substs: &subst::Substs<'tcx>)\n+                                -> subst::Substs<'tcx> {\n     let tcx = ccx.tcx();\n \n     let substs = match node {\n@@ -1064,13 +1064,13 @@ pub fn node_id_substs<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     };\n \n     if substs.types.needs_infer() {\n-            tcx.sess.bug(&format!(\"type parameters for node {:?} include inference types: {:?}\",\n-                                 node, substs));\n-        }\n+        tcx.sess.bug(&format!(\"type parameters for node {:?} include inference types: {:?}\",\n+                              node, substs));\n+    }\n \n-        monomorphize::apply_param_substs(tcx,\n-                                         param_substs,\n-                                         &substs.erase_regions())\n+    monomorphize::apply_param_substs(tcx,\n+                                     param_substs,\n+                                     &substs.erase_regions())\n }\n \n pub fn langcall(bcx: Block,"}, {"sha": "4695595d16f306c1edf2de543b61a494792a5f9f", "filename": "src/librustc_trans/trans/meth.rs", "status": "modified", "additions": 13, "deletions": 116, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/b4a2579cf0b9876e8cdf99e4f58b4154a671f48e/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4a2579cf0b9876e8cdf99e4f58b4154a671f48e/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs?ref=b4a2579cf0b9876e8cdf99e4f58b4154a671f48e", "patch": "@@ -14,7 +14,6 @@ use llvm::{ValueRef, get_params};\n use middle::def_id::DefId;\n use middle::infer;\n use middle::subst::{Subst, Substs};\n-use middle::subst::VecPerParamSpace;\n use middle::subst;\n use middle::traits;\n use trans::base::*;\n@@ -34,7 +33,7 @@ use trans::machine;\n use trans::monomorphize;\n use trans::type_::Type;\n use trans::type_of::*;\n-use middle::ty::{self, Ty, TypeFoldable};\n+use middle::ty::{self, Ty};\n use middle::ty::MethodCall;\n \n use syntax::ast;\n@@ -117,20 +116,15 @@ pub fn trans_method_callee<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         }\n \n         ty::TraitContainer(trait_def_id) => {\n-            let trait_substs = method.substs.clone().method_to_trait();\n-            let trait_substs = bcx.tcx().mk_substs(trait_substs);\n-            let trait_ref = ty::TraitRef::new(trait_def_id, trait_substs);\n-\n+            let trait_ref = method.substs.to_trait_ref(bcx.tcx(), trait_def_id);\n             let trait_ref = ty::Binder(bcx.monomorphize(&trait_ref));\n             let span = bcx.tcx().map.span(method_call.expr_id);\n             debug!(\"method_call={:?} trait_ref={:?} trait_ref id={:?} substs={:?}\",\n                    method_call,\n                    trait_ref,\n                    trait_ref.0.def_id,\n                    trait_ref.0.substs);\n-            let origin = fulfill_obligation(bcx.ccx(),\n-                                            span,\n-                                            trait_ref.clone());\n+            let origin = fulfill_obligation(bcx.ccx(), span, trait_ref);\n             debug!(\"origin = {:?}\", origin);\n             trans_monomorphized_callee(bcx,\n                                        method_call,\n@@ -169,44 +163,9 @@ pub fn trans_static_method_callee<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     // type parameters that belong to the trait but also some that\n     // belong to the method:\n     let rcvr_substs = node_id_substs(ccx, ExprId(expr_id), param_substs);\n-    let subst::SeparateVecsPerParamSpace {\n-        types: rcvr_type,\n-        selfs: rcvr_self,\n-        fns: rcvr_method\n-    } = rcvr_substs.types.split();\n-\n-    // Lookup the precise impl being called. To do that, we need to\n-    // create a trait reference identifying the self type and other\n-    // input type parameters. To create that trait reference, we have\n-    // to pick apart the type parameters to identify just those that\n-    // pertain to the trait. This is easiest to explain by example:\n-    //\n-    //     trait Convert {\n-    //         fn from<U:Foo>(n: U) -> Option<Self>;\n-    //     }\n-    //     ...\n-    //     let f = <Vec<i32> as Convert>::from::<String>(...)\n-    //\n-    // Here, in this call, which I've written with explicit UFCS\n-    // notation, the set of type parameters will be:\n-    //\n-    //     rcvr_type: [] <-- nothing declared on the trait itself\n-    //     rcvr_self: [Vec<i32>] <-- the self type\n-    //     rcvr_method: [String] <-- method type parameter\n-    //\n-    // So we create a trait reference using the first two,\n-    // basically corresponding to `<Vec<i32> as Convert>`.\n-    // The remaining type parameters (`rcvr_method`) will be used below.\n-    let trait_substs =\n-        Substs::erased(VecPerParamSpace::new(rcvr_type,\n-                                             rcvr_self,\n-                                             Vec::new()));\n-    let trait_substs = tcx.mk_substs(trait_substs);\n-    debug!(\"trait_substs={:?}\", trait_substs);\n-    let trait_ref = ty::Binder(ty::TraitRef::new(trait_id, trait_substs));\n-    let vtbl = fulfill_obligation(ccx,\n-                                  DUMMY_SP,\n-                                  trait_ref);\n+    debug!(\"rcvr_substs={:?}\", rcvr_substs);\n+    let trait_ref = ty::Binder(rcvr_substs.to_trait_ref(tcx, trait_id));\n+    let vtbl = fulfill_obligation(ccx, DUMMY_SP, trait_ref);\n \n     // Now that we know which impl is being used, we can dispatch to\n     // the actual function:\n@@ -216,33 +175,7 @@ pub fn trans_static_method_callee<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n             substs: impl_substs,\n             nested: _ }) =>\n         {\n-            assert!(!impl_substs.types.needs_infer());\n-\n-            // Create the substitutions that are in scope. This combines\n-            // the type parameters from the impl with those declared earlier.\n-            // To see what I mean, consider a possible impl:\n-            //\n-            //    impl<T> Convert for Vec<T> {\n-            //        fn from<U:Foo>(n: U) { ... }\n-            //    }\n-            //\n-            // Recall that we matched `<Vec<i32> as Convert>`. Trait\n-            // resolution will have given us a substitution\n-            // containing `impl_substs=[[T=i32],[],[]]` (the type\n-            // parameters defined on the impl). We combine\n-            // that with the `rcvr_method` from before, which tells us\n-            // the type parameters from the *method*, to yield\n-            // `callee_substs=[[T=i32],[],[U=String]]`.\n-            let subst::SeparateVecsPerParamSpace {\n-                types: impl_type,\n-                selfs: impl_self,\n-                fns: _\n-            } = impl_substs.types.split();\n-            let callee_substs =\n-                Substs::erased(VecPerParamSpace::new(impl_type,\n-                                                     impl_self,\n-                                                     rcvr_method));\n-\n+            let callee_substs = impl_substs.with_method_from(&rcvr_substs);\n             let mth = tcx.get_impl_method(impl_did, callee_substs, mname);\n             trans_fn_ref_with_substs(ccx, mth.method.def_id, ExprId(expr_id),\n                                      param_substs,\n@@ -256,6 +189,7 @@ pub fn trans_static_method_callee<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                               idx)\n         }\n         _ => {\n+            // FIXME(#20847): handle at least VtableFnPointer\n             tcx.sess.bug(&format!(\"static call to invalid vtable: {:?}\",\n                                  vtbl));\n         }\n@@ -285,11 +219,11 @@ fn trans_monomorphized_callee<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             };\n             // create a concatenated set of substitutions which includes\n             // those from the impl and those from the method:\n-            let callee_substs =\n-                combine_impl_and_methods_tps(\n-                    bcx, MethodCallKey(method_call), vtable_impl.substs);\n-\n-            let mth = bcx.tcx().get_impl_method(impl_did, callee_substs, mname);\n+            let meth_substs = node_id_substs(ccx,\n+                                             MethodCallKey(method_call),\n+                                             bcx.fcx.param_substs);\n+            let impl_substs = vtable_impl.substs.with_method_from(&meth_substs);\n+            let mth = bcx.tcx().get_impl_method(impl_did, impl_substs, mname);\n             // translate the function\n             let datum = trans_fn_ref_with_substs(bcx.ccx(),\n                                                  mth.method.def_id,\n@@ -346,43 +280,6 @@ fn trans_monomorphized_callee<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     }\n }\n \n- /// Creates a concatenated set of substitutions which includes those from the impl and those from\n- /// the method.  This are some subtle complications here.  Statically, we have a list of type\n- /// parameters like `[T0, T1, T2, M1, M2, M3]` where `Tn` are type parameters that appear on the\n- /// receiver.  For example, if the receiver is a method parameter `A` with a bound like\n- /// `trait<B,C,D>` then `Tn` would be `[B,C,D]`.\n- ///\n- /// The weird part is that the type `A` might now be bound to any other type, such as `foo<X>`.\n- /// In that case, the vector we want is: `[X, M1, M2, M3]`.  Therefore, what we do now is to slice\n- /// off the method type parameters and append them to the type parameters from the type that the\n- /// receiver is mapped to.\n-fn combine_impl_and_methods_tps<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                            node: ExprOrMethodCall,\n-                                            rcvr_substs: subst::Substs<'tcx>)\n-                                            -> subst::Substs<'tcx>\n-{\n-    let ccx = bcx.ccx();\n-\n-    let node_substs = node_id_substs(ccx, node, bcx.fcx.param_substs);\n-\n-    debug!(\"rcvr_substs={:?}\", rcvr_substs);\n-    debug!(\"node_substs={:?}\", node_substs);\n-\n-    // Break apart the type parameters from the node and type\n-    // parameters from the receiver.\n-    let node_method = node_substs.types.split().fns;\n-    let subst::SeparateVecsPerParamSpace {\n-        types: rcvr_type,\n-        selfs: rcvr_self,\n-        fns: rcvr_method\n-    } = rcvr_substs.types.clone().split();\n-    assert!(rcvr_method.is_empty());\n-    subst::Substs {\n-        regions: subst::ErasedRegions,\n-        types: subst::VecPerParamSpace::new(rcvr_type, rcvr_self, node_method)\n-    }\n-}\n-\n /// Create a method callee where the method is coming from a trait object (e.g., Box<Trait> type).\n /// In this case, we must pull the fn pointer out of the vtable that is packaged up with the\n /// object. Objects are represented as a pair, so we first evaluate the self expression and then"}, {"sha": "e433776bef2933fad64f460501b9067c6203b6a8", "filename": "src/librustc_trans/trans/mir/did.rs", "status": "modified", "additions": 17, "deletions": 32, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/b4a2579cf0b9876e8cdf99e4f58b4154a671f48e/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fdid.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4a2579cf0b9876e8cdf99e4f58b4154a671f48e/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fdid.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fdid.rs?ref=b4a2579cf0b9876e8cdf99e4f58b4154a671f48e", "patch": "@@ -16,7 +16,6 @@ use rustc::middle::ty::{self, Ty, TypeFoldable};\n use rustc::middle::subst::Substs;\n use rustc::middle::const_eval;\n use rustc::middle::def_id::DefId;\n-use rustc::middle::subst;\n use rustc::middle::traits;\n use rustc::mir::repr::ItemKind;\n use trans::common::{Block, fulfill_obligation};\n@@ -46,7 +45,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n             ItemKind::Function => self.trans_fn_ref(bcx, ty, substs, did),\n             ItemKind::Method => match bcx.tcx().impl_or_trait_item(did).container() {\n                 ty::ImplContainer(_) => self.trans_fn_ref(bcx, ty, substs, did),\n-                ty::TraitContainer(tdid) => self.trans_static_method(bcx, ty, did, tdid, substs)\n+                ty::TraitContainer(tdid) => self.trans_trait_method(bcx, ty, did, tdid, substs)\n             },\n             ItemKind::Constant => {\n                 let did = inline::maybe_instantiate_inline(bcx.ccx(), did);\n@@ -98,16 +97,16 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n         }\n     }\n \n-    /// Translates references to static methods.\n+    /// Translates references to trait methods.\n     ///\n     /// This is an adaptation of meth::trans_static_method_callee\n-    pub fn trans_static_method(&mut self,\n-                               bcx: Block<'bcx, 'tcx>,\n-                               ty: Ty<'tcx>,\n-                               method_id: DefId,\n-                               trait_id: DefId,\n-                               substs: &'tcx Substs<'tcx>)\n-                               -> OperandRef<'tcx> {\n+    pub fn trans_trait_method(&mut self,\n+                              bcx: Block<'bcx, 'tcx>,\n+                              ty: Ty<'tcx>,\n+                              method_id: DefId,\n+                              trait_id: DefId,\n+                              substs: &'tcx Substs<'tcx>)\n+                              -> OperandRef<'tcx> {\n         debug!(\"trans_static_method(ty={:?}, method={}, trait={}, substs={:?})\",\n                 ty,\n                 bcx.tcx().item_path_str(method_id),\n@@ -116,34 +115,20 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n \n         let ccx = bcx.ccx();\n         let tcx = bcx.tcx();\n-        let subst::SeparateVecsPerParamSpace {\n-            types: rcvr_type,\n-            selfs: rcvr_self,\n-            fns: rcvr_method\n-        } = substs.clone().types.split();\n-        let trait_substs = Substs::erased(\n-            subst::VecPerParamSpace::new(rcvr_type, rcvr_self, Vec::new())\n-        );\n-        let trait_substs = tcx.mk_substs(trait_substs);\n-        let trait_ref = ty::Binder(ty::TraitRef::new(trait_id, trait_substs));\n+        let trait_ref = ty::Binder(substs.to_trait_ref(tcx, trait_id));\n         let vtbl = fulfill_obligation(ccx, DUMMY_SP, trait_ref);\n         match vtbl {\n-            traits::VtableImpl(traits::VtableImplData { impl_def_id, substs: imp_substs, .. }) => {\n-                assert!(!imp_substs.types.needs_infer());\n+            traits::VtableImpl(traits::VtableImplData {\n+                impl_def_id, substs: impl_substs, ..\n+            }) => {\n+                assert!(!impl_substs.types.needs_infer());\n \n                 let mname = tcx.item_name(method_id);\n \n-                let subst::SeparateVecsPerParamSpace {\n-                    types: impl_type,\n-                    selfs: impl_self,\n-                    fns: _\n-                } = imp_substs.types.split();\n-                let callee_substs = Substs::erased(\n-                    subst::VecPerParamSpace::new(impl_type, impl_self, rcvr_method)\n-                );\n+                let callee_substs = impl_substs.with_method_from(substs);\n                 let mth = tcx.get_impl_method(impl_def_id, callee_substs, mname);\n-                let mthsubsts = tcx.mk_substs(mth.substs);\n-                self.trans_fn_ref(bcx, ty, mthsubsts, mth.method.def_id)\n+                let mth_substs = tcx.mk_substs(mth.substs);\n+                self.trans_fn_ref(bcx, ty, mth_substs, mth.method.def_id)\n             },\n             traits::VtableClosure(data) => {\n                 let trait_closure_kind = bcx.tcx().lang_items.fn_trait_kind(trait_id).unwrap();"}, {"sha": "1d8f6f005cddc362610c7f7fdcaf746605c054e1", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b4a2579cf0b9876e8cdf99e4f58b4154a671f48e/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4a2579cf0b9876e8cdf99e4f58b4154a671f48e/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=b4a2579cf0b9876e8cdf99e4f58b4154a671f48e", "patch": "@@ -332,7 +332,7 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n                     .generics.regions.get_slice(subst::FnSpace));\n \n         let subst::Substs { types, regions } = substs;\n-        let regions = regions.map(|r| r.with_vec(subst::FnSpace, method_regions));\n+        let regions = regions.map(|r| r.with_slice(subst::FnSpace, &method_regions));\n         let mut final_substs = subst::Substs { types: types, regions: regions };\n \n         if num_supplied_types == 0 {"}]}