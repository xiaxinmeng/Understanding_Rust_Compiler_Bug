{"sha": "1ce3e820dcb3ca90dec6d3b008e14531c54afc06", "node_id": "C_kwDOAAsO6NoAKDFjZTNlODIwZGNiM2NhOTBkZWM2ZDNiMDA4ZTE0NTMxYzU0YWZjMDY", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2023-01-11T21:39:05Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2023-01-11T21:39:05Z"}, "message": "feat: Make unlinked_file diagnostic quickfixes work for inline modules", "tree": {"sha": "72ea7191bcca33b349f727e7fad9651625f0914f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/72ea7191bcca33b349f727e7fad9651625f0914f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1ce3e820dcb3ca90dec6d3b008e14531c54afc06", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1ce3e820dcb3ca90dec6d3b008e14531c54afc06", "html_url": "https://github.com/rust-lang/rust/commit/1ce3e820dcb3ca90dec6d3b008e14531c54afc06", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1ce3e820dcb3ca90dec6d3b008e14531c54afc06/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bb4e272d8a05c5b6a000808c5c84d722d582603d", "url": "https://api.github.com/repos/rust-lang/rust/commits/bb4e272d8a05c5b6a000808c5c84d722d582603d", "html_url": "https://github.com/rust-lang/rust/commit/bb4e272d8a05c5b6a000808c5c84d722d582603d"}], "stats": {"total": 244, "additions": 202, "deletions": 42}, "files": [{"sha": "b879eec4cc8d7156413acc25fbbfc9db98c59a07", "filename": "crates/hir-expand/src/lib.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1ce3e820dcb3ca90dec6d3b008e14531c54afc06/crates%2Fhir-expand%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ce3e820dcb3ca90dec6d3b008e14531c54afc06/crates%2Fhir-expand%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-expand%2Fsrc%2Flib.rs?ref=1ce3e820dcb3ca90dec6d3b008e14531c54afc06", "patch": "@@ -356,6 +356,14 @@ impl HirFileId {\n         }\n     }\n \n+    #[inline]\n+    pub fn file_id(self) -> Option<FileId> {\n+        match self.0 & Self::MACRO_FILE_TAG_MASK {\n+            0 => Some(FileId(self.0)),\n+            _ => None,\n+        }\n+    }\n+\n     fn repr(self) -> HirFileIdRepr {\n         match self.0 & Self::MACRO_FILE_TAG_MASK {\n             0 => HirFileIdRepr::FileId(FileId(self.0)),"}, {"sha": "4bb3789d69d078e4a3d53d3b32dfe6b988dbf4e6", "filename": "crates/ide-diagnostics/src/handlers/unlinked_file.rs", "status": "modified", "additions": 178, "deletions": 41, "changes": 219, "blob_url": "https://github.com/rust-lang/rust/blob/1ce3e820dcb3ca90dec6d3b008e14531c54afc06/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Funlinked_file.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ce3e820dcb3ca90dec6d3b008e14531c54afc06/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Funlinked_file.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Funlinked_file.rs?ref=1ce3e820dcb3ca90dec6d3b008e14531c54afc06", "patch": "@@ -1,6 +1,8 @@\n //! Diagnostic emitted for files that aren't part of any crate.\n \n-use hir::db::DefDatabase;\n+use std::iter;\n+\n+use hir::{db::DefDatabase, InFile, ModuleSource};\n use ide_db::{\n     base_db::{FileId, FileLoader, SourceDatabase, SourceDatabaseExt},\n     source_change::SourceChange,\n@@ -42,45 +44,106 @@ fn fixes(ctx: &DiagnosticsContext<'_>, file_id: FileId) -> Option<Vec<Assist>> {\n \n     let source_root = ctx.sema.db.source_root(ctx.sema.db.file_source_root(file_id));\n     let our_path = source_root.path_for_file(&file_id)?;\n-    let (mut module_name, _) = our_path.name_and_extension()?;\n-\n-    // Candidates to look for:\n-    // - `mod.rs`, `main.rs` and `lib.rs` in the same folder\n-    // - `$dir.rs` in the parent folder, where `$dir` is the directory containing `self.file_id`\n     let parent = our_path.parent()?;\n-    let paths = {\n-        let parent = if module_name == \"mod\" {\n-            // for mod.rs we need to actually look up one higher\n-            // and take the parent as our to be module name\n-            let (name, _) = parent.name_and_extension()?;\n-            module_name = name;\n-            parent.parent()?\n-        } else {\n-            parent\n-        };\n-        let mut paths =\n-            vec![parent.join(\"mod.rs\")?, parent.join(\"lib.rs\")?, parent.join(\"main.rs\")?];\n-\n-        // `submod/bla.rs` -> `submod.rs`\n-        let parent_mod = (|| {\n-            let (name, _) = parent.name_and_extension()?;\n-            parent.parent()?.join(&format!(\"{name}.rs\"))\n-        })();\n-        paths.extend(parent_mod);\n-        paths\n+    let (module_name, _) = our_path.name_and_extension()?;\n+    let (parent, module_name) = if module_name == \"mod\" {\n+        // for mod.rs we need to actually look up one higher\n+        // and take the parent as our to be module name\n+        let (name, _) = parent.name_and_extension()?;\n+        (parent.parent()?, name.to_owned())\n+    } else {\n+        (parent, module_name.to_owned())\n     };\n \n-    for &parent_id in paths.iter().filter_map(|path| source_root.file_for_path(path)) {\n+    // check crate roots, i.e. main.rs, lib.rs, ...\n+    'outer: for &krate in &*ctx.sema.db.relevant_crates(file_id) {\n+        let crate_def_map = ctx.sema.db.crate_def_map(krate);\n+        if let Some(root_file_id) = crate_def_map[crate_def_map.root()].origin.file_id() {\n+            if let Some(path) = source_root.path_for_file(&root_file_id) {\n+                let parent2 = path.parent()?;\n+                if let Some(rel) = parent.strip_prefix(&parent2) {\n+                    let mut current = &crate_def_map[crate_def_map.root()];\n+                    for ele in rel.as_ref().components() {\n+                        let seg = match ele {\n+                            std::path::Component::Normal(seg) => seg.to_str()?,\n+                            std::path::Component::RootDir => continue,\n+                            // shouldn't occur\n+                            _ => continue 'outer,\n+                        };\n+                        match current.children.iter().find(|(name, _)| name.to_smol_str() == seg) {\n+                            Some((_, child)) => {\n+                                current = &crate_def_map[*child];\n+                            }\n+                            None => continue 'outer,\n+                        }\n+                    }\n+                    let InFile { file_id: parent_file_id, value: source } =\n+                        current.definition_source(ctx.sema.db);\n+                    if let Some(parent_file_id) = parent_file_id.file_id() {\n+                        return make_fixes(\n+                            ctx.sema.db,\n+                            parent_file_id,\n+                            source,\n+                            &module_name,\n+                            file_id,\n+                        );\n+                    }\n+                }\n+            }\n+        }\n+    }\n+    // build all parent paths of the form `../module_name/mod.rs` and `../module_name.rs`\n+    let paths = iter::successors(Some(parent.clone()), |prev| prev.parent()).filter_map(|path| {\n+        let parent = path.parent()?;\n+        let (name, _) = path.name_and_extension()?;\n+        Some(([parent.join(&format!(\"{name}.rs\"))?, path.join(\"mod.rs\")?], name.to_owned()))\n+    });\n+    let mut stack = vec![];\n+    if let Some(&parent_id) = paths\n+        .inspect(|(_, name)| stack.push(name.clone()))\n+        .find_map(|(paths, _)| paths.into_iter().find_map(|path| source_root.file_for_path(&path)))\n+    {\n+        stack.pop();\n         for &krate in ctx.sema.db.relevant_crates(parent_id).iter() {\n             let crate_def_map = ctx.sema.db.crate_def_map(krate);\n-            for (_, module) in crate_def_map.modules() {\n-                if module.origin.is_inline() {\n-                    // We don't handle inline `mod parent {}`s, they use different paths.\n-                    continue;\n-                }\n-\n+            'outer: for (_, module) in crate_def_map.modules() {\n                 if module.origin.file_id() == Some(parent_id) {\n-                    return make_fixes(ctx.sema.db, parent_id, module_name, file_id);\n+                    if module.origin.is_inline() {\n+                        continue;\n+                    }\n+                    if stack.is_empty() {\n+                        return make_fixes(\n+                            ctx.sema.db,\n+                            parent_id,\n+                            module.definition_source(ctx.sema.db).value,\n+                            &module_name,\n+                            file_id,\n+                        );\n+                    } else {\n+                        let mut current = module;\n+                        for s in stack.iter().rev() {\n+                            match module.children.iter().find(|(name, _)| name.to_smol_str() == s) {\n+                                Some((_, child)) => {\n+                                    current = &crate_def_map[*child];\n+                                }\n+                                None => break 'outer,\n+                            }\n+                        }\n+                        let InFile { file_id: parent_file_id, value: source } =\n+                            current.definition_source(ctx.sema.db);\n+                        if let Some(parent_file_id) = parent_file_id.file_id() {\n+                            if current.origin.is_inline() {\n+                                return make_fixes(\n+                                    ctx.sema.db,\n+                                    parent_file_id,\n+                                    source,\n+                                    &module_name,\n+                                    file_id,\n+                                );\n+                            }\n+                        }\n+                        break;\n+                    }\n                 }\n             }\n         }\n@@ -92,6 +155,7 @@ fn fixes(ctx: &DiagnosticsContext<'_>, file_id: FileId) -> Option<Vec<Assist>> {\n fn make_fixes(\n     db: &RootDatabase,\n     parent_file_id: FileId,\n+    source: ModuleSource,\n     new_mod_name: &str,\n     added_file_id: FileId,\n ) -> Option<Vec<Assist>> {\n@@ -102,14 +166,18 @@ fn make_fixes(\n     let mod_decl = format!(\"mod {new_mod_name};\");\n     let pub_mod_decl = format!(\"pub mod {new_mod_name};\");\n \n-    let ast: ast::SourceFile = db.parse(parent_file_id).tree();\n-\n     let mut mod_decl_builder = TextEdit::builder();\n     let mut pub_mod_decl_builder = TextEdit::builder();\n \n+    let mut items = match &source {\n+        ModuleSource::SourceFile(it) => it.items(),\n+        ModuleSource::Module(it) => it.item_list()?.items(),\n+        ModuleSource::BlockExpr(_) => return None,\n+    };\n+\n     // If there's an existing `mod m;` statement matching the new one, don't emit a fix (it's\n     // probably `#[cfg]`d out).\n-    for item in ast.items() {\n+    for item in items.clone() {\n         if let ast::Item::Module(m) = item {\n             if let Some(name) = m.name() {\n                 if m.item_list().is_none() && name.to_string() == new_mod_name {\n@@ -121,7 +189,7 @@ fn make_fixes(\n     }\n \n     // If there are existing `mod m;` items, append after them (after the first group of them, rather).\n-    match ast.items().skip_while(|item| !is_outline_mod(item)).take_while(is_outline_mod).last() {\n+    match items.clone().skip_while(|item| !is_outline_mod(item)).take_while(is_outline_mod).last() {\n         Some(last) => {\n             cov_mark::hit!(unlinked_file_append_to_existing_mods);\n             let offset = last.syntax().text_range().end();\n@@ -130,7 +198,7 @@ fn make_fixes(\n         }\n         None => {\n             // Prepend before the first item in the file.\n-            match ast.items().next() {\n+            match items.next() {\n                 Some(item) => {\n                     cov_mark::hit!(unlinked_file_prepend_before_first_item);\n                     let offset = item.syntax().text_range().start();\n@@ -140,7 +208,13 @@ fn make_fixes(\n                 None => {\n                     // No items in the file, so just append at the end.\n                     cov_mark::hit!(unlinked_file_empty_file);\n-                    let offset = ast.syntax().text_range().end();\n+                    let offset = match &source {\n+                        ModuleSource::SourceFile(it) => it.syntax().text_range().end(),\n+                        ModuleSource::Module(it) => {\n+                            it.item_list()?.r_curly_token()?.text_range().start()\n+                        }\n+                        ModuleSource::BlockExpr(_) => return None,\n+                    };\n                     mod_decl_builder.insert(offset, format!(\"{mod_decl}\\n\"));\n                     pub_mod_decl_builder.insert(offset, format!(\"{pub_mod_decl}\\n\"));\n                 }\n@@ -167,7 +241,6 @@ fn make_fixes(\n \n #[cfg(test)]\n mod tests {\n-\n     use crate::tests::{check_diagnostics, check_fix, check_fixes, check_no_fix};\n \n     #[test]\n@@ -330,6 +403,70 @@ $0\n mod foo;\n \n //- /foo.rs\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn unlinked_file_insert_into_inline_simple() {\n+        check_fix(\n+            r#\"\n+//- /main.rs\n+mod bar;\n+//- /bar.rs\n+mod foo {\n+\n+}\n+//- /bar/foo/baz.rs\n+$0\n+\"#,\n+            r#\"\n+mod foo {\n+\n+mod baz;\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn unlinked_file_insert_into_inline_simple_modrs() {\n+        check_fix(\n+            r#\"\n+//- /main.rs\n+mod bar;\n+//- /bar.rs\n+mod baz {\n+\n+}\n+//- /bar/baz/foo/mod.rs\n+$0\n+\"#,\n+            r#\"\n+mod baz {\n+\n+mod foo;\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn unlinked_file_insert_into_inline_simple_modrs_main() {\n+        check_fix(\n+            r#\"\n+//- /main.rs\n+mod bar {\n+\n+}\n+//- /bar/foo/mod.rs\n+$0\n+\"#,\n+            r#\"\n+mod bar {\n+\n+mod foo;\n+}\n \"#,\n         );\n     }"}, {"sha": "38501a8ba5a3418c4160e903156a885dc2f1efc7", "filename": "crates/vfs/src/vfs_path.rs", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/1ce3e820dcb3ca90dec6d3b008e14531c54afc06/crates%2Fvfs%2Fsrc%2Fvfs_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ce3e820dcb3ca90dec6d3b008e14531c54afc06/crates%2Fvfs%2Fsrc%2Fvfs_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fvfs%2Fsrc%2Fvfs_path.rs?ref=1ce3e820dcb3ca90dec6d3b008e14531c54afc06", "patch": "@@ -1,7 +1,7 @@\n //! Abstract-ish representation of paths for VFS.\n use std::fmt;\n \n-use paths::{AbsPath, AbsPathBuf};\n+use paths::{AbsPath, AbsPathBuf, RelPath};\n \n /// Path in [`Vfs`].\n ///\n@@ -84,6 +84,14 @@ impl VfsPath {\n         }\n     }\n \n+    pub fn strip_prefix(&self, other: &VfsPath) -> Option<&RelPath> {\n+        match (&self.0, &other.0) {\n+            (VfsPathRepr::PathBuf(lhs), VfsPathRepr::PathBuf(rhs)) => lhs.strip_prefix(rhs),\n+            (VfsPathRepr::VirtualPath(lhs), VfsPathRepr::VirtualPath(rhs)) => lhs.strip_prefix(rhs),\n+            (VfsPathRepr::PathBuf(_) | VfsPathRepr::VirtualPath(_), _) => None,\n+        }\n+    }\n+\n     /// Returns the `VfsPath` without its final component, if there is one.\n     ///\n     /// Returns [`None`] if the path is a root or prefix.\n@@ -320,6 +328,13 @@ impl VirtualPath {\n         self.0.starts_with(&other.0)\n     }\n \n+    fn strip_prefix(&self, base: &VirtualPath) -> Option<&RelPath> {\n+        <_ as AsRef<std::path::Path>>::as_ref(&self.0)\n+            .strip_prefix(&base.0)\n+            .ok()\n+            .map(RelPath::new_unchecked)\n+    }\n+\n     /// Remove the last component of `self`.\n     ///\n     /// This will find the last `'/'` in `self`, and remove everything after it,"}]}