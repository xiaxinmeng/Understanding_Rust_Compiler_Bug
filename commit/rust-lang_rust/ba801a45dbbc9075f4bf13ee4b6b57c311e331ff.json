{"sha": "ba801a45dbbc9075f4bf13ee4b6b57c311e331ff", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJhODAxYTQ1ZGJiYzkwNzVmNGJmMTNlZTRiNmI1N2MzMTFlMzMxZmY=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-05-09T10:24:30Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-05-09T11:19:23Z"}, "message": "make Miri work in rustc bootstrap stage 0", "tree": {"sha": "cff9e396311e78a494877b5d95f957572963045e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cff9e396311e78a494877b5d95f957572963045e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ba801a45dbbc9075f4bf13ee4b6b57c311e331ff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ba801a45dbbc9075f4bf13ee4b6b57c311e331ff", "html_url": "https://github.com/rust-lang/rust/commit/ba801a45dbbc9075f4bf13ee4b6b57c311e331ff", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ba801a45dbbc9075f4bf13ee4b6b57c311e331ff/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4eaf05c4ec1172203362637e743bbbf31e6a0be6", "url": "https://api.github.com/repos/rust-lang/rust/commits/4eaf05c4ec1172203362637e743bbbf31e6a0be6", "html_url": "https://github.com/rust-lang/rust/commit/4eaf05c4ec1172203362637e743bbbf31e6a0be6"}], "stats": {"total": 62, "additions": 45, "deletions": 17}, "files": [{"sha": "1dd4a91e822fdf50d84a16463383cba9a98a6bc5", "filename": "README.md", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ba801a45dbbc9075f4bf13ee4b6b57c311e331ff/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/ba801a45dbbc9075f4bf13ee4b6b57c311e331ff/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=ba801a45dbbc9075f4bf13ee4b6b57c311e331ff", "patch": "@@ -222,6 +222,13 @@ Moreover, Miri recognizes some environment variables:\n * `MIRI_TEST_FLAGS` (recognized by the test suite) defines extra flags to be\n   passed to Miri.\n \n+The following environment variables are internal, but used to communicate between\n+different Miri binaries, and as such worht documenting:\n+\n+* `MIRI_BE_RUSTC` when set to any value tells the Miri driver to actually not\n+  interpret the code but compile it like rustc would. This is useful to be sure\n+  that the compiled `rlib`s are compatible with Miri.\n+\n ## Contributing and getting help\n \n If you want to contribute to Miri, great!  Please check out our"}, {"sha": "a1f502ab262fb7807c32e3fd36fef4a73ccb1ef4", "filename": "src/bin/cargo-miri.rs", "status": "modified", "additions": 32, "deletions": 17, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/ba801a45dbbc9075f4bf13ee4b6b57c311e331ff/src%2Fbin%2Fcargo-miri.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba801a45dbbc9075f4bf13ee4b6b57c311e331ff/src%2Fbin%2Fcargo-miri.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Fcargo-miri.rs?ref=ba801a45dbbc9075f4bf13ee4b6b57c311e331ff", "patch": "@@ -86,11 +86,15 @@ fn get_arg_flag_value(name: &str) -> Option<String> {\n     }\n }\n \n-/// Returns a command for the right `miri` binary.\n-fn miri() -> Command {\n+/// Returns the path to the `miri` binary\n+fn find_miri() -> PathBuf {\n     let mut path = std::env::current_exe().expect(\"current executable path invalid\");\n     path.set_file_name(\"miri\");\n-    Command::new(path)\n+    path\n+}\n+\n+fn miri() -> Command {\n+    Command::new(find_miri())\n }\n \n fn cargo() -> Command {\n@@ -322,7 +326,8 @@ fn setup(subcommand: MiriCommand) {\n         show_error(format!(\"Given Rust source directory `{}` does not exist.\", rust_src.display()));\n     }\n \n-    // Next, we need our own libstd. We will do this work in whatever is a good cache dir for this platform.\n+    // Next, we need our own libstd. Prepare a xargo project for that purpose.\n+    // We will do this work in whatever is a good cache dir for this platform.\n     let dirs = directories::ProjectDirs::from(\"org\", \"rust-lang\", \"miri\").unwrap();\n     let dir = dirs.cache_dir();\n     if !dir.exists() {\n@@ -360,20 +365,31 @@ path = \"lib.rs\"\n         )\n         .unwrap();\n     File::create(dir.join(\"lib.rs\")).unwrap();\n-    // Prepare xargo invocation.\n+\n+    // Determine architectures.\n+    // We always need to set a target so rustc bootstrap can tell apart host from target crates.\n+    let host = rustc_version::version_meta().unwrap().host;\n     let target = get_arg_flag_value(\"--target\");\n-    let print_sysroot = subcommand == MiriCommand::Setup\n-        && has_arg_flag(\"--print-sysroot\"); // whether we just print the sysroot path\n+    let target = target.as_ref().unwrap_or(&host);\n+    // Now invoke xargo.\n     let mut command = xargo_check();\n     command.arg(\"build\").arg(\"-q\");\n+    command.arg(\"--target\").arg(target);\n     command.current_dir(&dir);\n-    command.env(\"RUSTFLAGS\", miri::miri_default_args().join(\" \"));\n     command.env(\"XARGO_HOME\", &dir);\n     command.env(\"XARGO_RUST_SRC\", &rust_src);\n-    // Handle target flag.\n-    if let Some(target) = &target {\n-        command.arg(\"--target\").arg(target);\n+    // Use Miri as rustc to build a libstd compatible with us (and use the right flags).\n+    // However, when we are running in bootstrap, we cannot just overwrite `RUSTC`,\n+    // because we still need bootstrap to distinguish between host and target crates.\n+    // In that case we overwrite `RUSTC_REAL` instead which determines the rustc used\n+    // for target crates.\n+    if env::var_os(\"RUSTC_STAGE\").is_some() {\n+        command.env(\"RUSTC_REAL\", find_miri());\n+    } else {\n+        command.env(\"RUSTC\", find_miri());\n     }\n+    command.env(\"MIRI_BE_RUSTC\", \"1\");\n+    command.env(\"RUSTFLAGS\", miri::miri_default_args().join(\" \"));\n     // Finally run it!\n     if command.status().expect(\"failed to run xargo\").success().not() {\n         show_error(format!(\"Failed to run xargo\"));\n@@ -382,12 +398,11 @@ path = \"lib.rs\"\n     // That should be it! But we need to figure out where xargo built stuff.\n     // Unfortunately, it puts things into a different directory when the\n     // architecture matches the host.\n-    let is_host = match &target {\n-        None => true,\n-        Some(target) => target == &rustc_version::version_meta().unwrap().host,\n-    };\n-    let sysroot = if is_host { dir.join(\"HOST\") } else { PathBuf::from(dir) };\n+    let sysroot = if target == &host { dir.join(\"HOST\") } else { PathBuf::from(dir) };\n     std::env::set_var(\"MIRI_SYSROOT\", &sysroot); // pass the env var to the processes we spawn, which will turn it into \"--sysroot\" flags\n+    // Figure out what to print.\n+    let print_sysroot = subcommand == MiriCommand::Setup\n+        && has_arg_flag(\"--print-sysroot\"); // whether we just print the sysroot path\n     if print_sysroot {\n         // Print just the sysroot and nothing else; this way we do not need any escaping.\n         println!(\"{}\", sysroot.display());\n@@ -476,7 +491,7 @@ fn in_cargo_miri() {\n \n         // Set `RUSTC_WRAPPER` to ourselves.  Cargo will prepend that binary to its usual invocation,\n         // i.e., the first argument is `rustc` -- which is what we use in `main` to distinguish\n-        // the two codepaths.\n+        // the two codepaths. (That extra argument is why we prefer this over setting `RUSTC`.)\n         let path = std::env::current_exe().expect(\"current executable path invalid\");\n         cmd.env(\"RUSTC_WRAPPER\", path);\n         if verbose {"}, {"sha": "1e382a5a9bea2c5204d69a16b639728c28591121", "filename": "src/bin/miri.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ba801a45dbbc9075f4bf13ee4b6b57c311e331ff/src%2Fbin%2Fmiri.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba801a45dbbc9075f4bf13ee4b6b57c311e331ff/src%2Fbin%2Fmiri.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Fmiri.rs?ref=ba801a45dbbc9075f4bf13ee4b6b57c311e331ff", "patch": "@@ -124,6 +124,12 @@ fn compile_time_sysroot() -> Option<String> {\n }\n \n fn main() {\n+    // If the environment asks us to actually be rustc, then do that.\n+    if env::var_os(\"MIRI_BE_RUSTC\").is_some() {\n+        eprintln!(\"miri-as-rustc called with args: {:?}\", env::args());\n+        return rustc_driver::main();\n+    }\n+\n     init_early_loggers();\n \n     // Parse our arguments and split them across `rustc` and `miri`."}]}