{"sha": "cd9ecdf467d8e06a68400785b3dac83d561449ee", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNkOWVjZGY0NjdkOGUwNmE2ODQwMDc4NWIzZGFjODNkNTYxNDQ5ZWU=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-08-25T12:57:26Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-08-25T12:58:22Z"}, "message": "Remove monomorphisation from doclinks resolving code", "tree": {"sha": "6d56154056e70bf7f10c5efe83bb53f580361800", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6d56154056e70bf7f10c5efe83bb53f580361800"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cd9ecdf467d8e06a68400785b3dac83d561449ee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cd9ecdf467d8e06a68400785b3dac83d561449ee", "html_url": "https://github.com/rust-lang/rust/commit/cd9ecdf467d8e06a68400785b3dac83d561449ee", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cd9ecdf467d8e06a68400785b3dac83d561449ee/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2441e8eaaffb839fe6d6307f5163e66b88877419", "url": "https://api.github.com/repos/rust-lang/rust/commits/2441e8eaaffb839fe6d6307f5163e66b88877419", "html_url": "https://github.com/rust-lang/rust/commit/2441e8eaaffb839fe6d6307f5163e66b88877419"}], "stats": {"total": 77, "additions": 43, "deletions": 34}, "files": [{"sha": "e5a539cb8d66e537ac1675604b1d308310e83e2d", "filename": "crates/hir/src/attrs.rs", "status": "modified", "additions": 21, "deletions": 20, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/cd9ecdf467d8e06a68400785b3dac83d561449ee/crates%2Fhir%2Fsrc%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd9ecdf467d8e06a68400785b3dac83d561449ee/crates%2Fhir%2Fsrc%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fattrs.rs?ref=cd9ecdf467d8e06a68400785b3dac83d561449ee", "patch": "@@ -1,7 +1,6 @@\n //! Attributes & documentation for hir types.\n use hir_def::{\n     attr::Attrs,\n-    db::DefDatabase,\n     docs::Documentation,\n     resolver::{HasResolver, Resolver},\n     AdtId, AttrDefId, FunctionId, GenericDefId, ModuleId, StaticId, TraitId, VariantId,\n@@ -62,18 +61,20 @@ macro_rules! impl_has_attrs_adt {\n impl_has_attrs_adt![Struct, Union, Enum];\n \n impl Resolvable for ModuleDef {\n-    fn resolver<D: DefDatabase + HirDatabase>(&self, db: &D) -> Option<Resolver> {\n+    fn resolver(&self, db: &dyn HirDatabase) -> Option<Resolver> {\n         Some(match self {\n-            ModuleDef::Module(m) => ModuleId::from(m.clone()).resolver(db),\n-            ModuleDef::Function(f) => FunctionId::from(f.clone()).resolver(db),\n-            ModuleDef::Adt(adt) => AdtId::from(adt.clone()).resolver(db),\n+            ModuleDef::Module(m) => ModuleId::from(m.clone()).resolver(db.upcast()),\n+            ModuleDef::Function(f) => FunctionId::from(f.clone()).resolver(db.upcast()),\n+            ModuleDef::Adt(adt) => AdtId::from(adt.clone()).resolver(db.upcast()),\n             ModuleDef::EnumVariant(ev) => {\n-                GenericDefId::from(GenericDef::from(ev.clone())).resolver(db)\n+                GenericDefId::from(GenericDef::from(ev.clone())).resolver(db.upcast())\n             }\n-            ModuleDef::Const(c) => GenericDefId::from(GenericDef::from(c.clone())).resolver(db),\n-            ModuleDef::Static(s) => StaticId::from(s.clone()).resolver(db),\n-            ModuleDef::Trait(t) => TraitId::from(t.clone()).resolver(db),\n-            ModuleDef::TypeAlias(t) => ModuleId::from(t.module(db)).resolver(db),\n+            ModuleDef::Const(c) => {\n+                GenericDefId::from(GenericDef::from(c.clone())).resolver(db.upcast())\n+            }\n+            ModuleDef::Static(s) => StaticId::from(s.clone()).resolver(db.upcast()),\n+            ModuleDef::Trait(t) => TraitId::from(t.clone()).resolver(db.upcast()),\n+            ModuleDef::TypeAlias(t) => ModuleId::from(t.module(db)).resolver(db.upcast()),\n             // FIXME: This should be a resolver relative to `std/core`\n             ModuleDef::BuiltinType(_t) => None?,\n         })\n@@ -85,8 +86,8 @@ impl Resolvable for ModuleDef {\n }\n \n impl Resolvable for TypeParam {\n-    fn resolver<D: DefDatabase + HirDatabase>(&self, db: &D) -> Option<Resolver> {\n-        Some(ModuleId::from(self.module(db)).resolver(db))\n+    fn resolver(&self, db: &dyn HirDatabase) -> Option<Resolver> {\n+        Some(ModuleId::from(self.module(db)).resolver(db.upcast()))\n     }\n \n     fn try_into_module_def(self) -> Option<ModuleDef> {\n@@ -95,8 +96,8 @@ impl Resolvable for TypeParam {\n }\n \n impl Resolvable for MacroDef {\n-    fn resolver<D: DefDatabase + HirDatabase>(&self, db: &D) -> Option<Resolver> {\n-        Some(ModuleId::from(self.module(db)?).resolver(db))\n+    fn resolver(&self, db: &dyn HirDatabase) -> Option<Resolver> {\n+        Some(ModuleId::from(self.module(db)?).resolver(db.upcast()))\n     }\n \n     fn try_into_module_def(self) -> Option<ModuleDef> {\n@@ -105,8 +106,8 @@ impl Resolvable for MacroDef {\n }\n \n impl Resolvable for Field {\n-    fn resolver<D: DefDatabase + HirDatabase>(&self, db: &D) -> Option<Resolver> {\n-        Some(VariantId::from(self.parent_def(db)).resolver(db))\n+    fn resolver(&self, db: &dyn HirDatabase) -> Option<Resolver> {\n+        Some(VariantId::from(self.parent_def(db)).resolver(db.upcast()))\n     }\n \n     fn try_into_module_def(self) -> Option<ModuleDef> {\n@@ -115,8 +116,8 @@ impl Resolvable for Field {\n }\n \n impl Resolvable for ImplDef {\n-    fn resolver<D: DefDatabase + HirDatabase>(&self, db: &D) -> Option<Resolver> {\n-        Some(ModuleId::from(self.module(db)).resolver(db))\n+    fn resolver(&self, db: &dyn HirDatabase) -> Option<Resolver> {\n+        Some(ModuleId::from(self.module(db)).resolver(db.upcast()))\n     }\n \n     fn try_into_module_def(self) -> Option<ModuleDef> {\n@@ -125,8 +126,8 @@ impl Resolvable for ImplDef {\n }\n \n impl Resolvable for Local {\n-    fn resolver<D: DefDatabase + HirDatabase>(&self, db: &D) -> Option<Resolver> {\n-        Some(ModuleId::from(self.module(db)).resolver(db))\n+    fn resolver(&self, db: &dyn HirDatabase) -> Option<Resolver> {\n+        Some(ModuleId::from(self.module(db)).resolver(db.upcast()))\n     }\n \n     fn try_into_module_def(self) -> Option<ModuleDef> {"}, {"sha": "ddaffbec25547229aedbacf3451cfc98fb41e787", "filename": "crates/hir/src/doc_links.rs", "status": "modified", "additions": 22, "deletions": 14, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/cd9ecdf467d8e06a68400785b3dac83d561449ee/crates%2Fhir%2Fsrc%2Fdoc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd9ecdf467d8e06a68400785b3dac83d561449ee/crates%2Fhir%2Fsrc%2Fdoc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fdoc_links.rs?ref=cd9ecdf467d8e06a68400785b3dac83d561449ee", "patch": "@@ -2,32 +2,43 @@\n \n use std::iter::once;\n \n-use hir_def::{db::DefDatabase, resolver::Resolver};\n+use hir_def::resolver::Resolver;\n use itertools::Itertools;\n use syntax::ast::Path;\n use url::Url;\n \n use crate::{db::HirDatabase, Adt, AsName, Crate, Hygiene, ItemInNs, ModPath, ModuleDef};\n \n-pub fn resolve_doc_link<T: Resolvable + Clone, D: DefDatabase + HirDatabase>(\n-    db: &D,\n+pub fn resolve_doc_link<T: Resolvable + Clone>(\n+    db: &dyn HirDatabase,\n     definition: &T,\n     link_text: &str,\n     link_target: &str,\n ) -> Option<(String, String)> {\n-    try_resolve_intra(db, definition, link_text, &link_target).or_else(|| {\n-        let definition = definition.clone().try_into_module_def()?;\n-        try_resolve_path(db, &definition, &link_target)\n+    let resolver = definition.resolver(db)?;\n+    let module_def = definition.clone().try_into_module_def();\n+    resolve_doc_link_impl(db, &resolver, module_def, link_text, link_target)\n+}\n+\n+fn resolve_doc_link_impl(\n+    db: &dyn HirDatabase,\n+    resolver: &Resolver,\n+    module_def: Option<ModuleDef>,\n+    link_text: &str,\n+    link_target: &str,\n+) -> Option<(String, String)> {\n+    try_resolve_intra(db, &resolver, link_text, &link_target).or_else(|| {\n+        try_resolve_path(db, &module_def?, &link_target)\n             .map(|target| (target, link_text.to_string()))\n     })\n }\n \n /// Try to resolve path to local documentation via intra-doc-links (i.e. `super::gateway::Shard`).\n ///\n /// See [RFC1946](https://github.com/rust-lang/rfcs/blob/master/text/1946-intra-rustdoc-links.md).\n-fn try_resolve_intra<T: Resolvable, D: DefDatabase + HirDatabase>(\n-    db: &D,\n-    definition: &T,\n+fn try_resolve_intra(\n+    db: &dyn HirDatabase,\n+    resolver: &Resolver,\n     link_text: &str,\n     link_target: &str,\n ) -> Option<(String, String)> {\n@@ -41,10 +52,7 @@ fn try_resolve_intra<T: Resolvable, D: DefDatabase + HirDatabase>(\n     let path = Path::parse(doclink.path).ok()?;\n     let modpath = ModPath::from_src(path, &Hygiene::new_unhygienic()).unwrap();\n \n-    // Resolve it relative to symbol's location (according to the RFC this should consider small scopes)\n-    let resolver = definition.resolver(db)?;\n-\n-    let resolved = resolver.resolve_module_path_in_items(db, &modpath);\n+    let resolved = resolver.resolve_module_path_in_items(db.upcast(), &modpath);\n     let (defid, namespace) = match doclink.namespace {\n         // FIXME: .or(resolved.macros)\n         None => resolved\n@@ -225,6 +233,6 @@ impl Namespace {\n \n /// Sealed trait used solely for the generic bound on [`resolve_doc_link`].\n pub trait Resolvable {\n-    fn resolver<D: DefDatabase + HirDatabase>(&self, db: &D) -> Option<Resolver>;\n+    fn resolver(&self, db: &dyn HirDatabase) -> Option<Resolver>;\n     fn try_into_module_def(self) -> Option<ModuleDef>;\n }"}]}