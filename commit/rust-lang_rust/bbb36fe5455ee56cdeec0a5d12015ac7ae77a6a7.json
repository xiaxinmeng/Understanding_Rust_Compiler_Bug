{"sha": "bbb36fe5455ee56cdeec0a5d12015ac7ae77a6a7", "node_id": "C_kwDOAAsO6NoAKGJiYjM2ZmU1NDU1ZWU1NmNkZWVjMGE1ZDEyMDE1YWM3YWU3N2E2YTc", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-01-15T08:59:55Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-01-15T08:59:55Z"}, "message": "Auto merge of #105851 - dtolnay:peekmutleak, r=Mark-Simulacrum\n\nLeak amplification for peek_mut() to ensure BinaryHeap's invariant is always met\n\nIn the libs-api team's discussion around #104210, some of the team had hesitations around exposing malformed BinaryHeaps of an element type whose Ord and Drop impls are trusted, and which does not contain interior mutability.\n\nFor example in the context of this kind of code:\n\n```rust\nuse std::collections::BinaryHeap;\nuse std::ops::Range;\nuse std::slice;\n\nfn main() {\n    let slice = &mut ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'];\n    let cut_points = BinaryHeap::from(vec![4, 2, 7]);\n    println!(\"{:?}\", chop(slice, cut_points));\n}\n\n// This is a souped up slice::split_at_mut to split in arbitrary many places.\n//\n// usize's Ord impl is trusted, so 1 single bounds check guarantees all those\n// output slices are non-overlapping and in-bounds\nfn chop<T>(slice: &mut [T], mut cut_points: BinaryHeap<usize>) -> Vec<&mut [T]> {\n    let mut vec = Vec::with_capacity(cut_points.len() + 1);\n    let max = match cut_points.pop() {\n        Some(max) => max,\n        None => {\n            vec.push(slice);\n            return vec;\n        }\n    };\n\n    assert!(max <= slice.len());\n\n    let len = slice.len();\n    let ptr: *mut T = slice.as_mut_ptr();\n    let get_unchecked_mut = unsafe {\n        |range: Range<usize>| &mut *slice::from_raw_parts_mut(ptr.add(range.start), range.len())\n    };\n\n    vec.push(get_unchecked_mut(max..len));\n    let mut end = max;\n    while let Some(start) = cut_points.pop() {\n        vec.push(get_unchecked_mut(start..end));\n        end = start;\n    }\n    vec.push(get_unchecked_mut(0..end));\n    vec\n}\n```\n\n```console\n[['7', '8', '9'], ['4', '5', '6'], ['2', '3'], ['0', '1']]\n```\n\nIn the current BinaryHeap API, `peek_mut()` is the only thing that makes the above function unsound.\n\n```rust\nlet slice = &mut ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'];\nlet mut cut_points = BinaryHeap::from(vec![4, 2, 7]);\n{\n    let mut max = cut_points.peek_mut().unwrap();\n    *max = 0;\n    std::mem::forget(max);\n}\nprintln!(\"{:?}\", chop(slice, cut_points));\n```\n\n```console\n[['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'], [], ['2', '3'], ['0', '1']]\n```\n\nOr worse:\n\n```rust\nlet slice = &mut ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'];\nlet mut cut_points = BinaryHeap::from(vec![100, 100]);\n{\n    let mut max = cut_points.peek_mut().unwrap();\n    *max = 0;\n    std::mem::forget(max);\n}\nprintln!(\"{:?}\", chop(slice, cut_points));\n```\n\n```console\n[['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'], [], ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '\\u{1}', '\\0', '?', '\u7ffe', '?', '\u7ffe', '\\0', '\\0', '?', '\u7ffe', '?', '\u7ffe', '?', '\u557f', '?', '\u557f', '?', '\u557f', '?', '\u557f', '?', '\u557f', '?', '\u7ffe', '\\0', '\\0', '\ud952\udf10', '\u557f', '\\u{5}', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\u{8}', '\\0', '`@',` '\\0', '\\u{1}', '\\0', '?', '\u7ffe', '?', '\u7ffe', '?', '\u7ffe', '\nthread 'main' panicked at 'index out of bounds: the len is 33 but the index is 33', library/core/src/unicode/unicode_data.rs:319:9\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n```\n\n---\n\nThis PR makes `peek_mut()` use leak amplification (https://doc.rust-lang.org/1.66.0/nomicon/leaking.html#drain) to preserve the heap's invariant even in the situation that `PeekMut` gets leaked.\n\nI'll also follow up in the tracking issue of unstable `drain_sorted()` (#59278) and `retain()` (#71503).", "tree": {"sha": "0754bbca2e0aaa8db17b267917cd6dce50e131a2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0754bbca2e0aaa8db17b267917cd6dce50e131a2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bbb36fe5455ee56cdeec0a5d12015ac7ae77a6a7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bbb36fe5455ee56cdeec0a5d12015ac7ae77a6a7", "html_url": "https://github.com/rust-lang/rust/commit/bbb36fe5455ee56cdeec0a5d12015ac7ae77a6a7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bbb36fe5455ee56cdeec0a5d12015ac7ae77a6a7/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "754f6d4a8cf1963a3446b20b20fd10f42df1ee41", "url": "https://api.github.com/repos/rust-lang/rust/commits/754f6d4a8cf1963a3446b20b20fd10f42df1ee41", "html_url": "https://github.com/rust-lang/rust/commit/754f6d4a8cf1963a3446b20b20fd10f42df1ee41"}, {"sha": "23501703fb444a083155e8aa0b280d36be84c676", "url": "https://api.github.com/repos/rust-lang/rust/commits/23501703fb444a083155e8aa0b280d36be84c676", "html_url": "https://github.com/rust-lang/rust/commit/23501703fb444a083155e8aa0b280d36be84c676"}], "stats": {"total": 85, "additions": 75, "deletions": 10}, "files": [{"sha": "0b73b1af4eb35abad64b5d6c812293d1a6ad18b1", "filename": "library/alloc/src/collections/binary_heap/mod.rs", "status": "modified", "additions": 55, "deletions": 10, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/bbb36fe5455ee56cdeec0a5d12015ac7ae77a6a7/library%2Falloc%2Fsrc%2Fcollections%2Fbinary_heap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbb36fe5455ee56cdeec0a5d12015ac7ae77a6a7/library%2Falloc%2Fsrc%2Fcollections%2Fbinary_heap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbinary_heap%2Fmod.rs?ref=bbb36fe5455ee56cdeec0a5d12015ac7ae77a6a7", "patch": "@@ -146,6 +146,7 @@\n use core::fmt;\n use core::iter::{FromIterator, FusedIterator, InPlaceIterable, SourceIter, TrustedLen};\n use core::mem::{self, swap, ManuallyDrop};\n+use core::num::NonZeroUsize;\n use core::ops::{Deref, DerefMut};\n use core::ptr;\n \n@@ -165,12 +166,20 @@ mod tests;\n /// It is a logic error for an item to be modified in such a way that the\n /// item's ordering relative to any other item, as determined by the [`Ord`]\n /// trait, changes while it is in the heap. This is normally only possible\n-/// through [`Cell`], [`RefCell`], global state, I/O, or unsafe code. The\n+/// through interior mutability, global state, I/O, or unsafe code. The\n /// behavior resulting from such a logic error is not specified, but will\n /// be encapsulated to the `BinaryHeap` that observed the logic error and not\n /// result in undefined behavior. This could include panics, incorrect results,\n /// aborts, memory leaks, and non-termination.\n ///\n+/// As long as no elements change their relative order while being in the heap\n+/// as described above, the API of `BinaryHeap` guarantees that the heap\n+/// invariant remains intact i.e. its methods all behave as documented. For\n+/// example if a method is documented as iterating in sorted order, that's\n+/// guaranteed to work as long as elements in the heap have not changed order,\n+/// even in the presence of closures getting unwinded out of, iterators getting\n+/// leaked, and similar foolishness.\n+///\n /// # Examples\n ///\n /// ```\n@@ -279,7 +288,9 @@ pub struct BinaryHeap<T> {\n #[stable(feature = \"binary_heap_peek_mut\", since = \"1.12.0\")]\n pub struct PeekMut<'a, T: 'a + Ord> {\n     heap: &'a mut BinaryHeap<T>,\n-    sift: bool,\n+    // If a set_len + sift_down are required, this is Some. If a &mut T has not\n+    // yet been exposed to peek_mut()'s caller, it's None.\n+    original_len: Option<NonZeroUsize>,\n }\n \n #[stable(feature = \"collection_debug\", since = \"1.17.0\")]\n@@ -292,7 +303,14 @@ impl<T: Ord + fmt::Debug> fmt::Debug for PeekMut<'_, T> {\n #[stable(feature = \"binary_heap_peek_mut\", since = \"1.12.0\")]\n impl<T: Ord> Drop for PeekMut<'_, T> {\n     fn drop(&mut self) {\n-        if self.sift {\n+        if let Some(original_len) = self.original_len {\n+            // SAFETY: That's how many elements were in the Vec at the time of\n+            // the PeekMut::deref_mut call, and therefore also at the time of\n+            // the BinaryHeap::peek_mut call. Since the PeekMut did not end up\n+            // getting leaked, we are now undoing the leak amplification that\n+            // the DerefMut prepared for.\n+            unsafe { self.heap.data.set_len(original_len.get()) };\n+\n             // SAFETY: PeekMut is only instantiated for non-empty heaps.\n             unsafe { self.heap.sift_down(0) };\n         }\n@@ -313,7 +331,26 @@ impl<T: Ord> Deref for PeekMut<'_, T> {\n impl<T: Ord> DerefMut for PeekMut<'_, T> {\n     fn deref_mut(&mut self) -> &mut T {\n         debug_assert!(!self.heap.is_empty());\n-        self.sift = true;\n+\n+        let len = self.heap.len();\n+        if len > 1 {\n+            // Here we preemptively leak all the rest of the underlying vector\n+            // after the currently max element. If the caller mutates the &mut T\n+            // we're about to give them, and then leaks the PeekMut, all these\n+            // elements will remain leaked. If they don't leak the PeekMut, then\n+            // either Drop or PeekMut::pop will un-leak the vector elements.\n+            //\n+            // This is technique is described throughout several other places in\n+            // the standard library as \"leak amplification\".\n+            unsafe {\n+                // SAFETY: len > 1 so len != 0.\n+                self.original_len = Some(NonZeroUsize::new_unchecked(len));\n+                // SAFETY: len > 1 so all this does for now is leak elements,\n+                // which is safe.\n+                self.heap.data.set_len(1);\n+            }\n+        }\n+\n         // SAFE: PeekMut is only instantiated for non-empty heaps\n         unsafe { self.heap.data.get_unchecked_mut(0) }\n     }\n@@ -323,9 +360,16 @@ impl<'a, T: Ord> PeekMut<'a, T> {\n     /// Removes the peeked value from the heap and returns it.\n     #[stable(feature = \"binary_heap_peek_mut_pop\", since = \"1.18.0\")]\n     pub fn pop(mut this: PeekMut<'a, T>) -> T {\n-        let value = this.heap.pop().unwrap();\n-        this.sift = false;\n-        value\n+        if let Some(original_len) = this.original_len.take() {\n+            // SAFETY: This is how many elements were in the Vec at the time of\n+            // the BinaryHeap::peek_mut call.\n+            unsafe { this.heap.data.set_len(original_len.get()) };\n+\n+            // Unlike in Drop, here we don't also need to do a sift_down even if\n+            // the caller could've mutated the element. It is removed from the\n+            // heap on the next line and pop() is not sensitive to its value.\n+        }\n+        this.heap.pop().unwrap()\n     }\n }\n \n@@ -398,8 +442,9 @@ impl<T: Ord> BinaryHeap<T> {\n     /// Returns a mutable reference to the greatest item in the binary heap, or\n     /// `None` if it is empty.\n     ///\n-    /// Note: If the `PeekMut` value is leaked, the heap may be in an\n-    /// inconsistent state.\n+    /// Note: If the `PeekMut` value is leaked, some heap elements might get\n+    /// leaked along with it, but the remaining elements will remain a valid\n+    /// heap.\n     ///\n     /// # Examples\n     ///\n@@ -426,7 +471,7 @@ impl<T: Ord> BinaryHeap<T> {\n     /// otherwise it's *O*(1).\n     #[stable(feature = \"binary_heap_peek_mut\", since = \"1.12.0\")]\n     pub fn peek_mut(&mut self) -> Option<PeekMut<'_, T>> {\n-        if self.is_empty() { None } else { Some(PeekMut { heap: self, sift: false }) }\n+        if self.is_empty() { None } else { Some(PeekMut { heap: self, original_len: None }) }\n     }\n \n     /// Removes the greatest item from the binary heap and returns it, or `None` if it"}, {"sha": "ffbb6c80ac01847999294b6dee8af0b81fa0dc4f", "filename": "library/alloc/src/collections/binary_heap/tests.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/bbb36fe5455ee56cdeec0a5d12015ac7ae77a6a7/library%2Falloc%2Fsrc%2Fcollections%2Fbinary_heap%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbb36fe5455ee56cdeec0a5d12015ac7ae77a6a7/library%2Falloc%2Fsrc%2Fcollections%2Fbinary_heap%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbinary_heap%2Ftests.rs?ref=bbb36fe5455ee56cdeec0a5d12015ac7ae77a6a7", "patch": "@@ -1,6 +1,7 @@\n use super::*;\n use crate::boxed::Box;\n use crate::testing::crash_test::{CrashTestDummy, Panic};\n+use core::mem;\n use std::iter::TrustedLen;\n use std::panic::{catch_unwind, AssertUnwindSafe};\n \n@@ -146,6 +147,24 @@ fn test_peek_mut() {\n     assert_eq!(heap.peek(), Some(&9));\n }\n \n+#[test]\n+fn test_peek_mut_leek() {\n+    let data = vec![4, 2, 7];\n+    let mut heap = BinaryHeap::from(data);\n+    let mut max = heap.peek_mut().unwrap();\n+    *max = -1;\n+\n+    // The PeekMut object's Drop impl would have been responsible for moving the\n+    // -1 out of the max position of the BinaryHeap, but we don't run it.\n+    mem::forget(max);\n+\n+    // Absent some mitigation like leak amplification, the -1 would incorrectly\n+    // end up in the last position of the returned Vec, with the rest of the\n+    // heap's original contents in front of it in sorted order.\n+    let sorted_vec = heap.into_sorted_vec();\n+    assert!(sorted_vec.is_sorted(), \"{:?}\", sorted_vec);\n+}\n+\n #[test]\n fn test_peek_mut_pop() {\n     let data = vec![2, 4, 6, 2, 1, 8, 10, 3, 5, 7, 0, 9, 1];"}, {"sha": "afc3a3dc6a8c6bb646b725f281052558f61e7844", "filename": "library/alloc/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bbb36fe5455ee56cdeec0a5d12015ac7ae77a6a7/library%2Falloc%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbb36fe5455ee56cdeec0a5d12015ac7ae77a6a7/library%2Falloc%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Flib.rs?ref=bbb36fe5455ee56cdeec0a5d12015ac7ae77a6a7", "patch": "@@ -125,6 +125,7 @@\n #![feature(hasher_prefixfree_extras)]\n #![feature(inline_const)]\n #![feature(inplace_iteration)]\n+#![cfg_attr(test, feature(is_sorted))]\n #![feature(iter_advance_by)]\n #![feature(iter_next_chunk)]\n #![feature(iter_repeat_n)]"}]}