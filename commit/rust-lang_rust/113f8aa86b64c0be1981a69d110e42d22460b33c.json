{"sha": "113f8aa86b64c0be1981a69d110e42d22460b33c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjExM2Y4YWE4NmI2NGMwYmUxOTgxYTY5ZDExMGU0MmQyMjQ2MGIzM2M=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2014-12-23T03:23:11Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2014-12-30T00:06:25Z"}, "message": "Rebasing and reviewer changes", "tree": {"sha": "3736614e84499fcde1623619b6e1336f2b2221d6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3736614e84499fcde1623619b6e1336f2b2221d6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/113f8aa86b64c0be1981a69d110e42d22460b33c", "comment_count": 7, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/113f8aa86b64c0be1981a69d110e42d22460b33c", "html_url": "https://github.com/rust-lang/rust/commit/113f8aa86b64c0be1981a69d110e42d22460b33c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/113f8aa86b64c0be1981a69d110e42d22460b33c/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3bf405682df4dfb55b969640b811b317fa55447d", "url": "https://api.github.com/repos/rust-lang/rust/commits/3bf405682df4dfb55b969640b811b317fa55447d", "html_url": "https://github.com/rust-lang/rust/commit/3bf405682df4dfb55b969640b811b317fa55447d"}], "stats": {"total": 91, "additions": 47, "deletions": 44}, "files": [{"sha": "df8e08f07a32150f4390a8fb914a01dd029629b3", "filename": "src/libcollections/ring_buf.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/113f8aa86b64c0be1981a69d110e42d22460b33c/src%2Flibcollections%2Fring_buf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/113f8aa86b64c0be1981a69d110e42d22460b33c/src%2Flibcollections%2Fring_buf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fring_buf.rs?ref=113f8aa86b64c0be1981a69d110e42d22460b33c", "patch": "@@ -453,7 +453,7 @@ impl<T> RingBuf<T> {\n \n             if contiguous {\n                 let (empty, buf) = buf.split_at_mut(0);\n-                (buf[mut tail..head], empty)\n+                (buf.slice_mut(tail, head), empty)\n             } else {\n                 let (mid, right) = buf.split_at_mut(tail);\n                 let (left, _) = mid.split_at_mut(head);"}, {"sha": "7dd0649e4837df827b145a76995d5372949f3790", "filename": "src/libgraphviz/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/113f8aa86b64c0be1981a69d110e42d22460b33c/src%2Flibgraphviz%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/113f8aa86b64c0be1981a69d110e42d22460b33c/src%2Flibgraphviz%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2Flib.rs?ref=113f8aa86b64c0be1981a69d110e42d22460b33c", "patch": "@@ -735,7 +735,7 @@ mod tests {\n     fn test_input(g: LabelledGraph) -> IoResult<String> {\n         let mut writer = Vec::new();\n         render(&g, &mut writer).unwrap();\n-        (&mut writer[]).read_to_string()\n+        (&mut writer.as_slice()).read_to_string()\n     }\n \n     // All of the tests use raw-strings as the format for the expected outputs,\n@@ -847,7 +847,7 @@ r#\"digraph hasse_diagram {\n                  edge(1, 3, \";\"),    edge(2, 3, \";\"   )));\n \n         render(&g, &mut writer).unwrap();\n-        let r = (&mut writer[]).read_to_string();\n+        let r = (&mut writer.as_slice()).read_to_string();\n \n         assert_eq!(r.unwrap(),\n r#\"digraph syntax_tree {"}, {"sha": "5d3134b9629b2a416402dd51e52d22fa1e32b4fe", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/113f8aa86b64c0be1981a69d110e42d22460b33c/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/113f8aa86b64c0be1981a69d110e42d22460b33c/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=113f8aa86b64c0be1981a69d110e42d22460b33c", "patch": "@@ -519,8 +519,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                                                                 ret_ty), 1, true)\n                         }\n                         None => {\n-                            let base_cmt = if_ok!(self.cat_expr(&**base));\n-                            self.cat_index(expr, base_cmt)\n+                            self.cat_index(expr, self.cat_expr(&**base))\n                         }\n                     }\n                 }"}, {"sha": "f49769ba0d9c630dd6a43df8e863c152bf835a2c", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/113f8aa86b64c0be1981a69d110e42d22460b33c/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/113f8aa86b64c0be1981a69d110e42d22460b33c/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=113f8aa86b64c0be1981a69d110e42d22460b33c", "patch": "@@ -1074,18 +1074,18 @@ fn trans_rvalue_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             let (did, fields, ty_params) = match (start, end) {\n                 (&Some(ref start), &Some(ref end)) => {\n                     // Desugar to Range\n-                    let fields = vec!(make_field(\"start\", start.clone()),\n-                                      make_field(\"end\", end.clone()));\n+                    let fields = vec![make_field(\"start\", start.clone()),\n+                                      make_field(\"end\", end.clone())];\n                     (tcx.lang_items.range_struct(), fields, vec![node_id_type(bcx, start.id)])\n                 }\n                 (&Some(ref start), &None) => {\n                     // Desugar to RangeFrom\n-                    let fields = vec!(make_field(\"start\", start.clone()));\n+                    let fields = vec![make_field(\"start\", start.clone())];\n                     (tcx.lang_items.range_from_struct(), fields, vec![node_id_type(bcx, start.id)])\n                 }\n                 (&None, &Some(ref end)) => {\n                     // Desugar to RangeTo\n-                    let fields = vec!(make_field(\"end\", end.clone()));\n+                    let fields = vec![make_field(\"end\", end.clone())];\n                     (tcx.lang_items.range_to_struct(), fields, vec![node_id_type(bcx, end.id)])\n                 }\n                 _ => {"}, {"sha": "fb23ad8e340cee03941b3242336e7ea7e9d9302c", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 38, "deletions": 34, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/113f8aa86b64c0be1981a69d110e42d22460b33c/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/113f8aa86b64c0be1981a69d110e42d22460b33c/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=113f8aa86b64c0be1981a69d110e42d22460b33c", "patch": "@@ -4183,9 +4183,6 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                   // A slice, rather than an index. Special cased for now (KILLME).\n                   let base_t = structurally_resolved_type(fcx, expr.span, base_t);\n \n-                  if lvalue_pref == PreferMutLvalue {\n-                    println!(\"mutable lvalue_pref\");\n-                  }\n                   let result =\n                       autoderef_for_index(fcx, &**base, base_t, lvalue_pref, |adj_ty, adj| {\n                           try_overloaded_slice_step(fcx,\n@@ -4299,42 +4296,49 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n           // bounds because right the range structs do not have any. If we add\n           // some bounds, then we'll need to check `t_start` against them here.\n \n-          let range_type = if idx_type == Some(ty::mk_err()) {\n-            ty::mk_err()\n-          } else if idx_type.is_none() {\n-            // Neither start nor end => FullRange\n-            if let Some(did) = tcx.lang_items.full_range_struct() {\n-                let substs = Substs::new_type(vec![], vec![]);\n-                ty::mk_struct(tcx, did, substs)\n-            } else {\n+          let range_type = match idx_type {\n+            Some(idx_type) if ty::type_is_error(idx_type) => {\n                 ty::mk_err()\n             }\n-          } else {\n-            // Find the did from the appropriate lang item.\n-            let did = match (start, end) {\n-                (&Some(_), &Some(_)) => tcx.lang_items.range_struct(),\n-                (&Some(_), &None) => tcx.lang_items.range_from_struct(),\n-                (&None, &Some(_)) => tcx.lang_items.range_to_struct(),\n-                (&None, &None) => {\n-                    tcx.sess.span_bug(expr.span,\"full range should be dealt with above\")\n-                }\n-            };\n+            Some(idx_type) => {\n+                // Find the did from the appropriate lang item.\n+                let did = match (start, end) {\n+                    (&Some(_), &Some(_)) => tcx.lang_items.range_struct(),\n+                    (&Some(_), &None) => tcx.lang_items.range_from_struct(),\n+                    (&None, &Some(_)) => tcx.lang_items.range_to_struct(),\n+                    (&None, &None) => {\n+                        tcx.sess.span_bug(expr.span, \"full range should be dealt with above\")\n+                    }\n+                };\n \n-            if let Some(did) = did {\n-                let polytype = ty::lookup_item_type(tcx, did);\n-                let substs = Substs::new_type(vec![idx_type.unwrap()], vec![]);\n-                let bounds = polytype.generics.to_bounds(tcx, &substs);\n-                fcx.add_obligations_for_parameters(\n-                    traits::ObligationCause::new(expr.span,\n-                                                 fcx.body_id,\n-                                                 traits::ItemObligation(did)),\n-                    &bounds);\n-\n-                ty::mk_struct(tcx, did, tcx.mk_substs(substs))\n-            } else {\n-                ty::mk_err()\n+                if let Some(did) = did {\n+                    let polytype = ty::lookup_item_type(tcx, did);\n+                    let substs = Substs::new_type(vec![idx_type], vec![]);\n+                    let bounds = polytype.generics.to_bounds(tcx, &substs);\n+                    fcx.add_obligations_for_parameters(\n+                        traits::ObligationCause::new(expr.span,\n+                                                     fcx.body_id,\n+                                                     traits::ItemObligation(did)),\n+                        &bounds);\n+\n+                    ty::mk_struct(tcx, did, tcx.mk_substs(substs))\n+                } else {\n+                    tcx.sess.span_err(expr.span, \"No lang item for range syntax\");\n+                    ty::mk_err()\n+                }\n+            }\n+            None => {\n+                // Neither start nor end => FullRange\n+                if let Some(did) = tcx.lang_items.full_range_struct() {\n+                    let substs = Substs::new_type(vec![], vec![]);\n+                    ty::mk_struct(tcx, did, tcx.mk_substs(substs))\n+                } else {\n+                    tcx.sess.span_err(expr.span, \"No lang item for range syntax\");\n+                    ty::mk_err()\n+                }\n             }\n           };\n+\n           fcx.write_ty(id, range_type);\n        }\n "}, {"sha": "398728bb51652f68af32d3ce2db9aa41dd5ffa30", "filename": "src/libunicode/u_str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/113f8aa86b64c0be1981a69d110e42d22460b33c/src%2Flibunicode%2Fu_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/113f8aa86b64c0be1981a69d110e42d22460b33c/src%2Flibunicode%2Fu_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunicode%2Fu_str.rs?ref=113f8aa86b64c0be1981a69d110e42d22460b33c", "patch": "@@ -521,7 +521,7 @@ impl<I> Iterator<u16> for Utf16Encoder<I> where I: Iterator<char> {\n \n         let mut buf = [0u16, ..2];\n         self.chars.next().map(|ch| {\n-            let n = ch.encode_utf16(buf[mut]).unwrap_or(0);\n+            let n = ch.encode_utf16(buf.as_mut_slice()).unwrap_or(0);\n             if n == 2 { self.extra = buf[1]; }\n             buf[0]\n         })"}]}