{"sha": "98958bcaf403354dff0a390db0206e2e03336180", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk4OTU4YmNhZjQwMzM1NGRmZjBhMzkwZGIwMjA2ZTJlMDMzMzYxODA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-11-05T10:21:38Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-11-05T10:21:38Z"}, "message": "auto merge of #18546 : bkoropoff/rust/unboxed-closures-cross-crate, r=nick29581\n\nThis fixes some metadata/AST encoding problems that lead to ICEs.  The way this is currently handled will need revisiting if abstract return types are added, as unboxed closure types from extern crates could show up without being inlined into the local crate.\r\n\r\nCloses #16790 (I think this was fixed earlier by accident and just needed a test case)\r\nCloses #18378\r\nCloses #18543\r\n\r\nr? @pcwalton", "tree": {"sha": "cf7b625ce7ebb79be0cc7a492a8a0941d69b3c36", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cf7b625ce7ebb79be0cc7a492a8a0941d69b3c36"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/98958bcaf403354dff0a390db0206e2e03336180", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/98958bcaf403354dff0a390db0206e2e03336180", "html_url": "https://github.com/rust-lang/rust/commit/98958bcaf403354dff0a390db0206e2e03336180", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/98958bcaf403354dff0a390db0206e2e03336180/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eca8f11315cb3cd9836e6d8501a07fbb137f5e88", "url": "https://api.github.com/repos/rust-lang/rust/commits/eca8f11315cb3cd9836e6d8501a07fbb137f5e88", "html_url": "https://github.com/rust-lang/rust/commit/eca8f11315cb3cd9836e6d8501a07fbb137f5e88"}, {"sha": "bfa5320527b838e1b735a2999acbe1f55b034205", "url": "https://api.github.com/repos/rust-lang/rust/commits/bfa5320527b838e1b735a2999acbe1f55b034205", "html_url": "https://github.com/rust-lang/rust/commit/bfa5320527b838e1b735a2999acbe1f55b034205"}], "stats": {"total": 131, "additions": 94, "deletions": 37}, "files": [{"sha": "b9660dbd46629c0871c7b7509643c258fe1c807b", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/98958bcaf403354dff0a390db0206e2e03336180/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98958bcaf403354dff0a390db0206e2e03336180/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=98958bcaf403354dff0a390db0206e2e03336180", "patch": "@@ -55,6 +55,9 @@ pub enum DefIdSource {\n \n     // Identifies a region parameter (`fn foo<'X>() { ... }`).\n     RegionParameter,\n+\n+    // Identifies an unboxed closure\n+    UnboxedClosureSource\n }\n pub type conv_did<'a> =\n     |source: DefIdSource, ast::DefId|: 'a -> ast::DefId;\n@@ -464,7 +467,7 @@ fn parse_ty(st: &mut PState, conv: conv_did) -> ty::t {\n       }\n       'k' => {\n           assert_eq!(next(st), '[');\n-          let did = parse_def(st, NominalType, |x,y| conv(x,y));\n+          let did = parse_def(st, UnboxedClosureSource, |x,y| conv(x,y));\n           let region = parse_region(st, |x,y| conv(x,y));\n           let substs = parse_substs(st, |x,y| conv(x,y));\n           assert_eq!(next(st), ']');"}, {"sha": "5410417ec3f5c48aeaeaf27d2fc0816261897a2f", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/98958bcaf403354dff0a390db0206e2e03336180/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98958bcaf403354dff0a390db0206e2e03336180/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=98958bcaf403354dff0a390db0206e2e03336180", "patch": "@@ -21,7 +21,7 @@ use metadata::encoder as e;\n use middle::region;\n use metadata::tydecode;\n use metadata::tydecode::{DefIdSource, NominalType, TypeWithId, TypeParameter};\n-use metadata::tydecode::{RegionParameter};\n+use metadata::tydecode::{RegionParameter, UnboxedClosureSource};\n use metadata::tyencode;\n use middle::mem_categorization::Typer;\n use middle::subst;\n@@ -1728,12 +1728,14 @@ impl<'a> rbml_decoder_decoder_helpers for reader::Decoder<'a> {\n             \"FnMutUnboxedClosureKind\",\n             \"FnOnceUnboxedClosureKind\"\n         ];\n-        let kind = self.read_enum_variant(variants, |_, i| {\n-            Ok(match i {\n-                0 => ty::FnUnboxedClosureKind,\n-                1 => ty::FnMutUnboxedClosureKind,\n-                2 => ty::FnOnceUnboxedClosureKind,\n-                _ => panic!(\"bad enum variant for ty::UnboxedClosureKind\"),\n+        let kind = self.read_enum(\"UnboxedClosureKind\", |this| {\n+            this.read_enum_variant(variants, |_, i| {\n+                Ok(match i {\n+                    0 => ty::FnUnboxedClosureKind,\n+                    1 => ty::FnMutUnboxedClosureKind,\n+                    2 => ty::FnOnceUnboxedClosureKind,\n+                    _ => panic!(\"bad enum variant for ty::UnboxedClosureKind\"),\n+                })\n             })\n         }).unwrap();\n         ty::UnboxedClosure {\n@@ -1771,13 +1773,17 @@ impl<'a> rbml_decoder_decoder_helpers for reader::Decoder<'a> {\n          * case. We translate them with `tr_def_id()` which will map\n          * the crate numbers back to the original source crate.\n          *\n+         * Unboxed closures are cloned along with the function being\n+         * inlined, and all side tables use interned node IDs, so we\n+         * translate their def IDs accordingly.\n+         *\n          * It'd be really nice to refactor the type repr to not include\n          * def-ids so that all these distinctions were unnecessary.\n          */\n \n         let r = match source {\n             NominalType | TypeWithId | RegionParameter => dcx.tr_def_id(did),\n-            TypeParameter => dcx.tr_intern_def_id(did)\n+            TypeParameter | UnboxedClosureSource => dcx.tr_intern_def_id(did)\n         };\n         debug!(\"convert_def_id(source={}, did={})={}\", source, did, r);\n         return r;"}, {"sha": "bdb9ef8e71042d3afe5962fcc0101072bbbab5b0", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 30, "deletions": 28, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/98958bcaf403354dff0a390db0206e2e03336180/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98958bcaf403354dff0a390db0206e2e03336180/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=98958bcaf403354dff0a390db0206e2e03336180", "patch": "@@ -4625,35 +4625,37 @@ pub struct UnboxedClosureUpvar {\n // Returns a list of `UnboxedClosureUpvar`s for each upvar.\n pub fn unboxed_closure_upvars(tcx: &ctxt, closure_id: ast::DefId, substs: &Substs)\n                               -> Vec<UnboxedClosureUpvar> {\n-    if closure_id.krate == ast::LOCAL_CRATE {\n-        let capture_mode = tcx.capture_modes.borrow().get_copy(&closure_id.node);\n-        match tcx.freevars.borrow().find(&closure_id.node) {\n-            None => vec![],\n-            Some(ref freevars) => {\n-                freevars.iter().map(|freevar| {\n-                    let freevar_def_id = freevar.def.def_id();\n-                    let freevar_ty = node_id_to_type(tcx, freevar_def_id.node);\n-                    let mut freevar_ty = freevar_ty.subst(tcx, substs);\n-                    if capture_mode == ast::CaptureByRef {\n-                        let borrow = tcx.upvar_borrow_map.borrow().get_copy(&ty::UpvarId {\n-                            var_id: freevar_def_id.node,\n-                            closure_expr_id: closure_id.node\n-                        });\n-                        freevar_ty = mk_rptr(tcx, borrow.region, ty::mt {\n-                            ty: freevar_ty,\n-                            mutbl: borrow.kind.to_mutbl_lossy()\n-                        });\n-                    }\n-                    UnboxedClosureUpvar {\n-                        def: freevar.def,\n-                        span: freevar.span,\n-                        ty: freevar_ty\n-                    }\n-                }).collect()\n-            }\n+    // Presently an unboxed closure type cannot \"escape\" out of a\n+    // function, so we will only encounter ones that originated in the\n+    // local crate or were inlined into it along with some function.\n+    // This may change if abstract return types of some sort are\n+    // implemented.\n+    assert!(closure_id.krate == ast::LOCAL_CRATE);\n+    let capture_mode = tcx.capture_modes.borrow().get_copy(&closure_id.node);\n+    match tcx.freevars.borrow().find(&closure_id.node) {\n+        None => vec![],\n+        Some(ref freevars) => {\n+            freevars.iter().map(|freevar| {\n+                let freevar_def_id = freevar.def.def_id();\n+                let freevar_ty = node_id_to_type(tcx, freevar_def_id.node);\n+                let mut freevar_ty = freevar_ty.subst(tcx, substs);\n+                if capture_mode == ast::CaptureByRef {\n+                    let borrow = tcx.upvar_borrow_map.borrow().get_copy(&ty::UpvarId {\n+                        var_id: freevar_def_id.node,\n+                        closure_expr_id: closure_id.node\n+                    });\n+                    freevar_ty = mk_rptr(tcx, borrow.region, ty::mt {\n+                        ty: freevar_ty,\n+                        mutbl: borrow.kind.to_mutbl_lossy()\n+                    });\n+                }\n+                UnboxedClosureUpvar {\n+                    def: freevar.def,\n+                    span: freevar.span,\n+                    ty: freevar_ty\n+                }\n+            }).collect()\n         }\n-    } else {\n-        tcx.sess.bug(\"unimplemented cross-crate closure upvars\")\n     }\n }\n "}, {"sha": "d04829bb808c5718f1822e1e1aeeb6ef5e9c6eb0", "filename": "src/test/auxiliary/unboxed-closures-cross-crate.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/98958bcaf403354dff0a390db0206e2e03336180/src%2Ftest%2Fauxiliary%2Funboxed-closures-cross-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98958bcaf403354dff0a390db0206e2e03336180/src%2Ftest%2Fauxiliary%2Funboxed-closures-cross-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Funboxed-closures-cross-crate.rs?ref=98958bcaf403354dff0a390db0206e2e03336180", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(unboxed_closures, overloaded_calls)]\n+\n+#[inline]\n+pub fn has_closures() -> uint {\n+    let x = 1u;\n+    let mut f = move |&mut:| x;\n+    let y = 1u;\n+    let g = |:| y;\n+    f() + g()\n+}\n+\n+pub fn has_generic_closures<T: Add<T,T> + Copy>(x: T, y: T) -> T {\n+    let mut f = move |&mut:| x;\n+    let g = |:| y;\n+    f() + g()\n+}"}, {"sha": "3babaa2b7e550e3a809d49da19e0a8df2a8f3922", "filename": "src/test/run-pass/unboxed-closures-cross-crate.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/98958bcaf403354dff0a390db0206e2e03336180/src%2Ftest%2Frun-pass%2Funboxed-closures-cross-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98958bcaf403354dff0a390db0206e2e03336180/src%2Ftest%2Frun-pass%2Funboxed-closures-cross-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funboxed-closures-cross-crate.rs?ref=98958bcaf403354dff0a390db0206e2e03336180", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that unboxed closures work with cross-crate inlining\n+// Acts as a regression test for #16790, #18378 and #18543\n+\n+// aux-build:unboxed-closures-cross-crate.rs\n+extern crate \"unboxed-closures-cross-crate\" as ubcc;\n+\n+fn main() {\n+    assert_eq!(ubcc::has_closures(), 2u);\n+    assert_eq!(ubcc::has_generic_closures(2u, 3u), 5u);\n+}"}]}