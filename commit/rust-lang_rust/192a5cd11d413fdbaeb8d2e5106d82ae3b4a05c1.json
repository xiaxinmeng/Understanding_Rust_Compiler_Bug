{"sha": "192a5cd11d413fdbaeb8d2e5106d82ae3b4a05c1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE5MmE1Y2QxMWQ0MTNmZGJhZWI4ZDJlNTEwNmQ4MmFlM2I0YTA1YzE=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-03-20T09:17:12Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-03-20T09:17:12Z"}, "message": "better user docs", "tree": {"sha": "df4c52f32169b09b00d0b5af2b8338fd7dd213d7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/df4c52f32169b09b00d0b5af2b8338fd7dd213d7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/192a5cd11d413fdbaeb8d2e5106d82ae3b4a05c1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/192a5cd11d413fdbaeb8d2e5106d82ae3b4a05c1", "html_url": "https://github.com/rust-lang/rust/commit/192a5cd11d413fdbaeb8d2e5106d82ae3b4a05c1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/192a5cd11d413fdbaeb8d2e5106d82ae3b4a05c1/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "206bbe9c93f3fd33922c9e00cfb263b980a79ca2", "url": "https://api.github.com/repos/rust-lang/rust/commits/206bbe9c93f3fd33922c9e00cfb263b980a79ca2", "html_url": "https://github.com/rust-lang/rust/commit/206bbe9c93f3fd33922c9e00cfb263b980a79ca2"}], "stats": {"total": 416, "additions": 210, "deletions": 206}, "files": [{"sha": "b25e152d0a08c070e2ff170e0df069740b927896", "filename": "docs/user/README.md", "status": "modified", "additions": 42, "deletions": 206, "changes": 248, "blob_url": "https://github.com/rust-lang/rust/blob/192a5cd11d413fdbaeb8d2e5106d82ae3b4a05c1/docs%2Fuser%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/192a5cd11d413fdbaeb8d2e5106d82ae3b4a05c1/docs%2Fuser%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/docs%2Fuser%2FREADME.md?ref=192a5cd11d413fdbaeb8d2e5106d82ae3b4a05c1", "patch": "@@ -1,3 +1,22 @@\n+The main interface to rust-analyzer is the\n+[LSP](https://microsoft.github.io/language-server-protocol/) implementation. To\n+install lsp server, use `cargo install-lsp`, which is a shorthand for `cargo\n+install --package ra_lsp_server`. The binary is named `ra_lsp_server`, you\n+should be able to use it with any LSP-compatible editor. We use custom\n+extensions to LSP, so special client-side support is required to take full\n+advantage of rust-analyzer. This repository contains support code for VS Code\n+and Emacs.\n+\n+Rust Analyzer needs sources of rust standard library to work, so you might need\n+to execute\n+\n+```\n+$ rustup component add rust-src\n+```\n+\n+See [./features.md] document for a list of features that are available.\n+\n+## VS Code\n \n Prerequisites:\n \n@@ -15,227 +34,44 @@ following commands:\n $ git clone https://github.com/rust-analyzer/rust-analyzer.git --depth 1\n $ cd rust-analyzer\n $ cargo install-code\n-\n-# for stdlib support\n-$ rustup component add rust-src\n ```\n \n This will run `cargo install --package ra_lsp_server` to install the server\n binary into `~/.cargo/bin`, and then will build and install plugin from\n `editors/code`. See\n-[this](https://github.com/rust-analyzer/rust-analyzer/blob/0199572a3d06ff66eeae85a2d2c9762996f0d2d8/crates/tools/src/main.rs#L150)\n+[this](https://github.com/rust-analyzer/rust-analyzer/blob/69ee5c9c5ef212f7911028c9ddf581559e6565c3/crates/tools/src/main.rs#L37-L56)\n for details. The installation is expected to *just work*, if it doesn't, report\n bugs!\n \n It's better to remove existing Rust plugins to avoid interference.\n \n-## Rust Analyzer Specific Features\n-\n-These features are implemented as extensions to the language server protocol.\n-They are more experimental in nature and work only with VS Code.\n-\n-### Syntax highlighting\n-\n-It overrides built-in highlighting, and works only with a specific theme\n-(zenburn). `rust-analyzer.highlightingOn` setting can be used to disable it.\n-\n-### Go to symbol in workspace <kbd>ctrl+t</kbd>\n-\n-It mostly works on top of the built-in LSP functionality, however `#` and `*`\n-symbols can be used to narrow down the search. Specifically,\n-\n-- `#Foo` searches for `Foo` type in the current workspace\n-- `#foo#` searches for `foo` function in the current workspace\n-- `#Foo*` searches for `Foo` type among dependencies, excluding `stdlib`\n-- `#foo#*` searches for `foo` function among dependencies.\n-\n-That is, `#` switches from \"types\" to all symbols, `*` switches from the current\n-workspace to dependencies.\n-\n-### Commands <kbd>ctrl+shift+p</kbd>\n-\n-#### Show Rust Syntax Tree\n-\n-Shows the parse tree of the current file. It exists mostly for debugging\n-rust-analyzer itself.\n-\n-#### Extend Selection\n-\n-Extends the current selection to the encompassing syntactic construct\n-(expression, statement, item, module, etc). It works with multiple cursors. Do\n-bind this command to a key, its super-useful! Expected to be upstreamed to LSP soonish:\n-https://github.com/Microsoft/language-server-protocol/issues/613\n-\n-#### Matching Brace\n-\n-If the cursor is on any brace (`<>(){}[]`) which is a part of a brace-pair,\n-moves cursor to the matching brace. It uses the actual parser to determine\n-braces, so it won't confuse generics with comparisons.\n-\n-#### Parent Module\n-\n-Navigates to the parent module of the current module.\n-\n-#### Join Lines\n-\n-Join selected lines into one, smartly fixing up whitespace and trailing commas.\n-\n-#### Run\n-\n-Shows popup suggesting to run a test/benchmark/binary **at the current cursor\n-location**. Super useful for repeatedly running just a single test. Do bind this\n-to a shortcut!\n-\n-\n-### On Typing Assists\n-\n-Some features trigger on typing certain characters:\n-\n-- typing `let =` tries to smartly add `;` if `=` is followed by an existing expression.\n-- Enter inside comments automatically inserts `///`\n-- typing `.` in a chain method call auto-indents\n+Beyond basic LSP features, there are some extension commands which you can\n+invoke via <kbd>Ctrl+Shift+P</kbd> or bind to a shortcut. See [./features.md]\n+for details.\n \n+### Settings\n \n-### Code Actions (Assists)\n+* `rust-analyzer.highlightingOn`: enables experimental syntax highlighting\n+* `rust-analyzer.showWorkspaceLoadedNotification`: to ease troubleshooting, a\n+  notification is shown by default when a workspace is loaded\n+* `rust-analyzer.enableEnhancedTyping`: by default, rust-analyzer intercepts\n+  `Enter` key to make it easier to continue comments\n+* `rust-analyzer.raLspServerPath`: path to `ra_lsp_server` executable\n+* `rust-analyzer.enableCargoWatchOnStartup`: prompt to install & enable `cargo\n+  watch` for live error highlighting (note, this **does not** use rust-analyzer)\n+* `rust-analyzer.trace.server`: enables internal logging\n \n-These are triggered in a particular context via light bulb. We use custom code on\n-the VS Code side to be able to position cursor.\n \n+## Emacs\n \n-- Flip `,`\n-\n-```rust\n-// before:\n-fn foo(x: usize,<|> dim: (usize, usize))\n-// after:\n-fn foo(dim: (usize, usize), x: usize)\n-```\n-\n-- Add `#[derive]`\n-\n-```rust\n-// before:\n-struct Foo {\n-    <|>x: i32\n-}\n-// after:\n-#[derive(<|>)]\n-struct Foo {\n-    x: i32\n-}\n-```\n-\n-- Add `impl`\n-\n-```rust\n-// before:\n-struct Foo<'a, T: Debug> {\n-    <|>t: T\n-}\n-// after:\n-struct Foo<'a, T: Debug> {\n-    t: T\n-}\n-\n-impl<'a, T: Debug> Foo<'a, T> {\n-    <|>\n-}\n-```\n-\n-- Change visibility\n-\n-```rust\n-// before:\n-fn<|> foo() {}\n-\n-// after\n-pub(crate) fn foo() {}\n-```\n-\n-- Introduce variable:\n-\n-```rust\n-// before:\n-fn foo() {\n-    foo(<|>1 + 1<|>);\n-}\n-\n-// after:\n-fn foo() {\n-    let var_name = 1 + 1;\n-    foo(var_name);\n-}\n-```\n-\n-- Replace if-let with match:\n-\n-```rust\n-// before:\n-impl VariantData {\n-    pub fn is_struct(&self) -> bool {\n-        if <|>let VariantData::Struct(..) = *self {\n-            true\n-        } else {\n-            false\n-        }\n-    }\n-}\n-\n-// after:\n-impl VariantData {\n-    pub fn is_struct(&self) -> bool {\n-        <|>match *self {\n-            VariantData::Struct(..) => true,\n-            _ => false,\n-        }\n-    }\n-}\n-```\n-\n-- Split import\n-\n-```rust\n-// before:\n-use algo:<|>:visitor::{Visitor, visit};\n-//after:\n-use algo::{<|>visitor::{Visitor, visit}};\n-```\n-\n-## LSP features\n-\n-* **Go to definition**: works correctly for local variables and some paths,\n-  falls back to heuristic name matching for other things for the time being.\n-\n-* **Completion**: completes paths, including dependencies and standard library.\n-  Does not handle glob imports and macros. Completes fields and inherent\n-  methods.\n-\n-* **Outline** <kbd>alt+shift+o</kbd>\n-\n-* **Signature Info**\n-\n-* **Format document**. Formats the current file with rustfmt. Rustfmt must be\n-  installed separately with `rustup component add rustfmt`.\n-\n-* **Hover** shows types of expressions and docstings\n-\n-* **Rename** works for local variables\n-\n-* **Code Lens** for running tests\n-\n-* **Folding**\n-\n-* **Diagnostics**\n-  - missing module for `mod foo;` with a fix to create `foo.rs`.\n-  - struct field shorthand\n-  - unnecessary braces in use item\n+Prerequisites:\n \n+`emacs-lsp`, `dash` and `ht` packages.\n \n-## Performance\n+Installation:\n \n-Rust Analyzer is expected to be pretty fast. Specifically, the initial analysis\n-of the project (i.e, when you first invoke completion or symbols) typically\n-takes dozen of seconds at most. After that, everything is supposed to be more or\n-less instant. However currently all analysis results are kept in memory, so\n-memory usage is pretty high. Working with `rust-lang/rust` repo, for example,\n-needs about 5 gigabytes of ram.\n+* add\n+[ra-emacs-lsp.el](https://github.com/rust-analyzer/rust-analyzer/blob/69ee5c9c5ef212f7911028c9ddf581559e6565c3/editors/emacs/ra-emacs-lsp.el)\n+to load path and require it in `init.el`\n+* run `lsp` in a rust buffer\n+* (Optionally) bind commands like `join-lines` or `extend-selection` to keys"}, {"sha": "5df606aee0303e3721ee4f75932ae93597b80ddf", "filename": "docs/user/features.md", "status": "added", "additions": 168, "deletions": 0, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/192a5cd11d413fdbaeb8d2e5106d82ae3b4a05c1/docs%2Fuser%2Ffeatures.md", "raw_url": "https://github.com/rust-lang/rust/raw/192a5cd11d413fdbaeb8d2e5106d82ae3b4a05c1/docs%2Fuser%2Ffeatures.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/docs%2Fuser%2Ffeatures.md?ref=192a5cd11d413fdbaeb8d2e5106d82ae3b4a05c1", "patch": "@@ -0,0 +1,168 @@\n+This documents is an index of features that rust-analyzer language server provides.\n+\n+### Go to symbol in workspace <kbd>ctrl+t</kbd>\n+\n+It mostly works on top of the built-in LSP functionality, however `#` and `*`\n+symbols can be used to narrow down the search. Specifically,\n+\n+- `#Foo` searches for `Foo` type in the current workspace\n+- `#foo#` searches for `foo` function in the current workspace\n+- `#Foo*` searches for `Foo` type among dependencies, excluding `stdlib`\n+- `#foo#*` searches for `foo` function among dependencies.\n+\n+That is, `#` switches from \"types\" to all symbols, `*` switches from the current\n+workspace to dependencies.\n+\n+### Commands <kbd>ctrl+shift+p</kbd>\n+\n+#### Show Rust Syntax Tree\n+\n+Shows the parse tree of the current file. It exists mostly for debugging\n+rust-analyzer itself.\n+\n+#### Extend Selection\n+\n+Extends the current selection to the encompassing syntactic construct\n+(expression, statement, item, module, etc). It works with multiple cursors. Do\n+bind this command to a key, its super-useful! Expected to be upstreamed to LSP soonish:\n+https://github.com/Microsoft/language-server-protocol/issues/613\n+\n+#### Matching Brace\n+\n+If the cursor is on any brace (`<>(){}[]`) which is a part of a brace-pair,\n+moves cursor to the matching brace. It uses the actual parser to determine\n+braces, so it won't confuse generics with comparisons.\n+\n+#### Parent Module\n+\n+Navigates to the parent module of the current module.\n+\n+#### Join Lines\n+\n+Join selected lines into one, smartly fixing up whitespace and trailing commas.\n+\n+#### Run\n+\n+Shows popup suggesting to run a test/benchmark/binary **at the current cursor\n+location**. Super useful for repeatedly running just a single test. Do bind this\n+to a shortcut!\n+\n+\n+### On Typing Assists\n+\n+Some features trigger on typing certain characters:\n+\n+- typing `let =` tries to smartly add `;` if `=` is followed by an existing expression.\n+- Enter inside comments automatically inserts `///`\n+- typing `.` in a chain method call auto-indents\n+\n+\n+\n+\n+\n+### Code Actions (Assists)\n+\n+These are triggered in a particular context via light bulb. We use custom code on\n+the VS Code side to be able to position cursor.\n+\n+\n+- Flip `,`\n+\n+```rust\n+// before:\n+fn foo(x: usize,<|> dim: (usize, usize))\n+// after:\n+fn foo(dim: (usize, usize), x: usize)\n+```\n+\n+- Add `#[derive]`\n+\n+```rust\n+// before:\n+struct Foo {\n+    <|>x: i32\n+}\n+// after:\n+#[derive(<|>)]\n+struct Foo {\n+    x: i32\n+}\n+```\n+\n+- Add `impl`\n+\n+```rust\n+// before:\n+struct Foo<'a, T: Debug> {\n+    <|>t: T\n+}\n+// after:\n+struct Foo<'a, T: Debug> {\n+    t: T\n+}\n+\n+impl<'a, T: Debug> Foo<'a, T> {\n+    <|>\n+}\n+```\n+\n+- Change visibility\n+\n+```rust\n+// before:\n+fn<|> foo() {}\n+\n+// after\n+pub(crate) fn foo() {}\n+```\n+\n+- Introduce variable:\n+\n+```rust\n+// before:\n+fn foo() {\n+    foo(<|>1 + 1<|>);\n+}\n+\n+// after:\n+fn foo() {\n+    let var_name = 1 + 1;\n+    foo(var_name);\n+}\n+```\n+\n+- Replace if-let with match:\n+\n+```rust\n+// before:\n+impl VariantData {\n+    pub fn is_struct(&self) -> bool {\n+        if <|>let VariantData::Struct(..) = *self {\n+            true\n+        } else {\n+            false\n+        }\n+    }\n+}\n+\n+// after:\n+impl VariantData {\n+    pub fn is_struct(&self) -> bool {\n+        <|>match *self {\n+            VariantData::Struct(..) => true,\n+            _ => false,\n+        }\n+    }\n+}\n+```\n+\n+- Split import\n+\n+```rust\n+// before:\n+use algo:<|>:visitor::{Visitor, visit};\n+//after:\n+use algo::{<|>visitor::{Visitor, visit}};\n+```\n+\n+"}]}