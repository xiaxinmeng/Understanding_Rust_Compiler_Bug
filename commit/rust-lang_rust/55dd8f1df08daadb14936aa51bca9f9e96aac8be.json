{"sha": "55dd8f1df08daadb14936aa51bca9f9e96aac8be", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU1ZGQ4ZjFkZjA4ZGFhZGIxNDkzNmFhNTFiY2E5ZjllOTZhYWM4YmU=", "commit": {"author": {"name": "Nick Cameron", "email": "nrc@ncameron.org", "date": "2018-04-12T04:40:06Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-04-12T04:40:06Z"}, "message": "Merge pull request #2603 from topecongiro/merge-nested-imports\n\nMerge imports", "tree": {"sha": "419354b21b14f1f765d631352e6af1f620728e5f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/419354b21b14f1f765d631352e6af1f620728e5f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/55dd8f1df08daadb14936aa51bca9f9e96aac8be", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJazuMmCRBK7hj4Ov3rIwAAdHIIAHwdOlQanYjnVu970NONZfmP\nXRYzBFc9NHqbE/o7XJ3xfpf6zOzyoRTOVX31yYOA65dCe9r8UKO1tBg34puQRn0J\nKHy5Hn5gMobNQSzDuMo7shqVIzrdY4Lml7DD10Mpok1OX7eS4s6g2emWhXnjEv6o\nQzI3oDzcX6YY+A+j0K8CQ9xZTTosMfui7xvOBOxFjvqIDpVtdE3paQ4q9aQKaA+a\nKzIbYYB37glDUm/s1ygnlydekTQR5vNyZklNE+duMhNOiTkNzduHD8avigtWxgIG\nN2ho2kwOXl8eZ0Np6PU64F3r9BOpjYfM7W045KInKkRazJGjijJMS29c5hxKo6w=\n=5M/L\n-----END PGP SIGNATURE-----\n", "payload": "tree 419354b21b14f1f765d631352e6af1f620728e5f\nparent ba5b4fa51649bab7637193d3deaee892d3ca7163\nparent 8820a59bd55d51ab4d30d7f215eb1993cae5aeaa\nauthor Nick Cameron <nrc@ncameron.org> 1523508006 +1200\ncommitter GitHub <noreply@github.com> 1523508006 +1200\n\nMerge pull request #2603 from topecongiro/merge-nested-imports\n\nMerge imports"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/55dd8f1df08daadb14936aa51bca9f9e96aac8be", "html_url": "https://github.com/rust-lang/rust/commit/55dd8f1df08daadb14936aa51bca9f9e96aac8be", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/55dd8f1df08daadb14936aa51bca9f9e96aac8be/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ba5b4fa51649bab7637193d3deaee892d3ca7163", "url": "https://api.github.com/repos/rust-lang/rust/commits/ba5b4fa51649bab7637193d3deaee892d3ca7163", "html_url": "https://github.com/rust-lang/rust/commit/ba5b4fa51649bab7637193d3deaee892d3ca7163"}, {"sha": "8820a59bd55d51ab4d30d7f215eb1993cae5aeaa", "url": "https://api.github.com/repos/rust-lang/rust/commits/8820a59bd55d51ab4d30d7f215eb1993cae5aeaa", "html_url": "https://github.com/rust-lang/rust/commit/8820a59bd55d51ab4d30d7f215eb1993cae5aeaa"}], "stats": {"total": 386, "additions": 369, "deletions": 17}, "files": [{"sha": "09d9f57d6b2082071145b3d5279bc6a64cc23f0f", "filename": "Configurations.md", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/55dd8f1df08daadb14936aa51bca9f9e96aac8be/Configurations.md", "raw_url": "https://github.com/rust-lang/rust/raw/55dd8f1df08daadb14936aa51bca9f9e96aac8be/Configurations.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Configurations.md?ref=55dd8f1df08daadb14936aa51bca9f9e96aac8be", "patch": "@@ -1084,6 +1084,28 @@ use foo::{aaa,\n           fff};\n ```\n \n+## `merge_imports`\n+\n+Merge multiple imports into a single nested import.\n+\n+- **Default value**: `false`\n+- **Possible values**: `true`, `false`\n+- **Stable**: No\n+\n+#### `false` (default):\n+\n+```rust\n+use foo::{a, c, d};\n+use foo::{b, g};\n+use foo::{e, f};\n+```\n+\n+#### `true`:\n+\n+```rust\n+use foo::{a, b, c, d, e, f, g};\n+```\n+\n \n ## `match_block_trailing_comma`\n "}, {"sha": "8cc55ebac4b9ca4e153223cb57249b80afb2e154", "filename": "src/config/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/55dd8f1df08daadb14936aa51bca9f9e96aac8be/src%2Fconfig%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55dd8f1df08daadb14936aa51bca9f9e96aac8be/src%2Fconfig%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconfig%2Fmod.rs?ref=55dd8f1df08daadb14936aa51bca9f9e96aac8be", "patch": "@@ -66,6 +66,7 @@ create_config! {\n     // Imports\n     imports_indent: IndentStyle, IndentStyle::Visual, false, \"Indent of imports\";\n     imports_layout: ListTactic, ListTactic::Mixed, false, \"Item layout inside a import block\";\n+    merge_imports: bool, false, false, \"Merge imports\";\n \n     // Ordering\n     reorder_imports: bool, true, false, \"Reorder import and extern crate statements alphabetically\";"}, {"sha": "85ea119af95c9a5d06990c9ec3493592a4ddf626", "filename": "src/imports.rs", "status": "modified", "additions": 270, "deletions": 7, "changes": 277, "blob_url": "https://github.com/rust-lang/rust/blob/55dd8f1df08daadb14936aa51bca9f9e96aac8be/src%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55dd8f1df08daadb14936aa51bca9f9e96aac8be/src%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fimports.rs?ref=55dd8f1df08daadb14936aa51bca9f9e96aac8be", "patch": "@@ -12,7 +12,7 @@ use std::cmp::Ordering;\n \n use config::lists::*;\n use syntax::ast::{self, UseTreeKind};\n-use syntax::codemap::{BytePos, Span};\n+use syntax::codemap::{self, BytePos, Span, DUMMY_SP};\n \n use codemap::SpanUtils;\n use config::IndentStyle;\n@@ -24,6 +24,7 @@ use utils::mk_sp;\n use visitor::FmtVisitor;\n \n use std::borrow::Cow;\n+use std::fmt;\n \n /// Returns a name imported by a `use` declaration. e.g. returns `Ordering`\n /// for `std::cmp::Ordering` and `self` for `std::cmp::self`.\n@@ -89,7 +90,7 @@ impl<'a> FmtVisitor<'a> {\n // sorting.\n \n // FIXME we do a lot of allocation to make our own representation.\n-#[derive(Debug, Clone, Eq, PartialEq)]\n+#[derive(Clone, Eq, PartialEq)]\n pub enum UseSegment {\n     Ident(String, Option<String>),\n     Slf(Option<String>),\n@@ -98,12 +99,12 @@ pub enum UseSegment {\n     List(Vec<UseTree>),\n }\n \n-#[derive(Debug, Clone)]\n+#[derive(Clone)]\n pub struct UseTree {\n     pub path: Vec<UseSegment>,\n     pub span: Span,\n     // Comment information within nested use tree.\n-    list_item: Option<ListItem>,\n+    pub list_item: Option<ListItem>,\n     // Additional fields for top level use items.\n     // Should we have another struct for top-level use items rather than reusing this?\n     visibility: Option<ast::Visibility>,\n@@ -143,6 +144,78 @@ impl UseSegment {\n     }\n }\n \n+pub fn merge_use_trees(use_trees: Vec<UseTree>) -> Vec<UseTree> {\n+    let mut result = Vec::with_capacity(use_trees.len());\n+    for use_tree in use_trees {\n+        if use_tree.has_comment() || use_tree.attrs.is_some() {\n+            result.push(use_tree);\n+            continue;\n+        }\n+\n+        for flattened in use_tree.flatten() {\n+            merge_use_trees_inner(&mut result, flattened);\n+        }\n+    }\n+    result\n+}\n+\n+fn merge_use_trees_inner(trees: &mut Vec<UseTree>, use_tree: UseTree) {\n+    for tree in trees.iter_mut() {\n+        if tree.share_prefix(&use_tree) {\n+            tree.merge(use_tree);\n+            return;\n+        }\n+    }\n+\n+    trees.push(use_tree);\n+}\n+\n+impl fmt::Debug for UseTree {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::Display::fmt(self, f)\n+    }\n+}\n+\n+impl fmt::Debug for UseSegment {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::Display::fmt(self, f)\n+    }\n+}\n+\n+impl fmt::Display for UseSegment {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        match *self {\n+            UseSegment::Glob => write!(f, \"*\"),\n+            UseSegment::Ident(ref s, _) => write!(f, \"{}\", s),\n+            UseSegment::Slf(..) => write!(f, \"self\"),\n+            UseSegment::Super(..) => write!(f, \"super\"),\n+            UseSegment::List(ref list) => {\n+                write!(f, \"{{\")?;\n+                for (i, item) in list.iter().enumerate() {\n+                    let is_last = i == list.len() - 1;\n+                    write!(f, \"{}\", item)?;\n+                    if !is_last {\n+                        write!(f, \", \")?;\n+                    }\n+                }\n+                write!(f, \"}}\")\n+            }\n+        }\n+    }\n+}\n+impl fmt::Display for UseTree {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        for (i, segment) in self.path.iter().enumerate() {\n+            let is_last = i == self.path.len() - 1;\n+            write!(f, \"{}\", segment)?;\n+            if !is_last {\n+                write!(f, \"::\")?;\n+            }\n+        }\n+        write!(f, \"\")\n+    }\n+}\n+\n impl UseTree {\n     // Rewrite use tree with `use ` and a trailing `;`.\n     pub fn rewrite_top_level(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n@@ -168,6 +241,21 @@ impl UseTree {\n         Some(result)\n     }\n \n+    // FIXME: Use correct span?\n+    // The given span is essentially incorrect, since we are reconstructing\n+    // use statements. This should not be a problem, though, since we have\n+    // already tried to extract comment and observed that there are no comment\n+    // around the given use item, and the span will not be used afterward.\n+    fn from_path(path: Vec<UseSegment>, span: Span) -> UseTree {\n+        UseTree {\n+            path,\n+            span,\n+            list_item: None,\n+            visibility: None,\n+            attrs: None,\n+        }\n+    }\n+\n     pub fn from_ast_with_normalization(\n         context: &RewriteContext,\n         item: &ast::Item,\n@@ -358,6 +446,124 @@ impl UseTree {\n         self.path.push(last);\n         self\n     }\n+\n+    fn has_comment(&self) -> bool {\n+        self.list_item.as_ref().map_or(false, ListItem::has_comment)\n+    }\n+\n+    fn same_visibility(&self, other: &UseTree) -> bool {\n+        match (&self.visibility, &other.visibility) {\n+            (\n+                Some(codemap::Spanned {\n+                    node: ast::VisibilityKind::Inherited,\n+                    ..\n+                }),\n+                None,\n+            )\n+            | (\n+                None,\n+                Some(codemap::Spanned {\n+                    node: ast::VisibilityKind::Inherited,\n+                    ..\n+                }),\n+            )\n+            | (None, None) => true,\n+            (\n+                Some(codemap::Spanned { node: lnode, .. }),\n+                Some(codemap::Spanned { node: rnode, .. }),\n+            ) => lnode == rnode,\n+            _ => false,\n+        }\n+    }\n+\n+    fn share_prefix(&self, other: &UseTree) -> bool {\n+        if self.path.is_empty() || other.path.is_empty() || self.attrs.is_some()\n+            || !self.same_visibility(other)\n+        {\n+            false\n+        } else {\n+            self.path[0] == other.path[0]\n+        }\n+    }\n+\n+    fn flatten(self) -> Vec<UseTree> {\n+        if self.path.is_empty() {\n+            return vec![self];\n+        }\n+        match self.path.clone().last().unwrap() {\n+            UseSegment::List(list) => {\n+                let prefix = &self.path[..self.path.len() - 1];\n+                let mut result = vec![];\n+                for nested_use_tree in list.into_iter() {\n+                    for mut flattend in nested_use_tree.clone().flatten().iter_mut() {\n+                        let mut new_path = prefix.to_vec();\n+                        new_path.append(&mut flattend.path);\n+                        result.push(UseTree {\n+                            path: new_path,\n+                            span: self.span,\n+                            list_item: None,\n+                            visibility: self.visibility.clone(),\n+                            attrs: None,\n+                        });\n+                    }\n+                }\n+\n+                result\n+            }\n+            _ => vec![self],\n+        }\n+    }\n+\n+    fn merge(&mut self, other: UseTree) {\n+        let mut new_path = vec![];\n+        for (mut a, b) in self.path\n+            .clone()\n+            .iter_mut()\n+            .zip(other.path.clone().into_iter())\n+        {\n+            if *a == b {\n+                new_path.push(b);\n+            } else {\n+                break;\n+            }\n+        }\n+        if let Some(merged) = merge_rest(&self.path, &other.path, new_path.len()) {\n+            new_path.push(merged);\n+            self.span = self.span.to(other.span);\n+        }\n+        self.path = new_path;\n+    }\n+}\n+\n+fn merge_rest(a: &[UseSegment], b: &[UseSegment], len: usize) -> Option<UseSegment> {\n+    let a_rest = &a[len..];\n+    let b_rest = &b[len..];\n+    if a_rest.is_empty() && b_rest.is_empty() {\n+        return None;\n+    }\n+    if a_rest.is_empty() {\n+        return Some(UseSegment::List(vec![\n+            UseTree::from_path(vec![UseSegment::Slf(None)], DUMMY_SP),\n+            UseTree::from_path(b_rest.to_vec(), DUMMY_SP),\n+        ]));\n+    }\n+    if b_rest.is_empty() {\n+        return Some(UseSegment::List(vec![\n+            UseTree::from_path(vec![UseSegment::Slf(None)], DUMMY_SP),\n+            UseTree::from_path(a_rest.to_vec(), DUMMY_SP),\n+        ]));\n+    }\n+    if let UseSegment::List(mut list) = a_rest[0].clone() {\n+        merge_use_trees_inner(&mut list, UseTree::from_path(b_rest.to_vec(), DUMMY_SP));\n+        list.sort();\n+        return Some(UseSegment::List(list.clone()));\n+    }\n+    let mut list = vec![\n+        UseTree::from_path(a_rest.to_vec(), DUMMY_SP),\n+        UseTree::from_path(b_rest.to_vec(), DUMMY_SP),\n+    ];\n+    list.sort();\n+    Some(UseSegment::List(list))\n }\n \n impl PartialOrd for UseSegment {\n@@ -459,9 +665,12 @@ fn rewrite_nested_use_tree(\n         IndentStyle::Visual => shape.visual_indent(0),\n     };\n     for use_tree in use_tree_list {\n-        let mut list_item = use_tree.list_item.clone()?;\n-        list_item.item = use_tree.rewrite(context, nested_shape);\n-        list_items.push(list_item);\n+        if let Some(mut list_item) = use_tree.list_item.clone() {\n+            list_item.item = use_tree.rewrite(context, nested_shape);\n+            list_items.push(list_item);\n+        } else {\n+            list_items.push(ListItem::from_str(use_tree.rewrite(context, nested_shape)?));\n+        }\n     }\n     let (tactic, remaining_width) = if use_tree_list.iter().any(|use_segment| {\n         use_segment\n@@ -682,6 +891,60 @@ mod test {\n         parser.parse_in_list()\n     }\n \n+    macro parse_use_trees($($s:expr),* $(,)*) {\n+        vec![\n+            $(parse_use_tree($s),)*\n+        ]\n+    }\n+\n+    #[test]\n+    fn test_use_tree_merge() {\n+        macro test_merge([$($input:expr),* $(,)*], [$($output:expr),* $(,)*]) {\n+            assert_eq!(\n+                merge_use_trees(parse_use_trees!($($input,)*)),\n+                parse_use_trees!($($output,)*),\n+            );\n+        }\n+\n+        test_merge!([\"a::b::{c, d}\", \"a::b::{e, f}\"], [\"a::b::{c, d, e, f}\"]);\n+        test_merge!([\"a::b::c\", \"a::b\"], [\"a::b::{self, c}\"]);\n+        test_merge!([\"a::b\", \"a::b\"], [\"a::b\"]);\n+        test_merge!([\"a\", \"a::b\", \"a::b::c\"], [\"a::{self, b::{self, c}}\"]);\n+        test_merge!(\n+            [\"a::{b::{self, c}, d::e}\", \"a::d::f\"],\n+            [\"a::{b::{self, c}, d::{e, f}}\"]\n+        );\n+        test_merge!(\n+            [\"a::d::f\", \"a::{b::{self, c}, d::e}\"],\n+            [\"a::{b::{self, c}, d::{e, f}}\"]\n+        );\n+        test_merge!(\n+            [\"a::{c, d, b}\", \"a::{d, e, b, a, f}\", \"a::{f, g, c}\"],\n+            [\"a::{a, b, c, d, e, f, g}\"]\n+        );\n+    }\n+\n+    #[test]\n+    fn test_use_tree_flatten() {\n+        assert_eq!(\n+            parse_use_tree(\"a::b::{c, d, e, f}\").flatten(),\n+            parse_use_trees!(\"a::b::c\", \"a::b::d\", \"a::b::e\", \"a::b::f\",)\n+        );\n+\n+        assert_eq!(\n+            parse_use_tree(\"a::b::{c::{d, e, f}, g, h::{i, j, k}}\").flatten(),\n+            parse_use_trees![\n+                \"a::b::c::d\",\n+                \"a::b::c::e\",\n+                \"a::b::c::f\",\n+                \"a::b::g\",\n+                \"a::b::h::i\",\n+                \"a::b::h::j\",\n+                \"a::b::h::k\",\n+            ]\n+        );\n+    }\n+\n     #[test]\n     fn test_use_tree_normalize() {\n         assert_eq!(parse_use_tree(\"a::self\").normalize(), parse_use_tree(\"a\"));"}, {"sha": "8b75e68f6f5d9ef27b7274074a27fadf35609f5e", "filename": "src/lists.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/55dd8f1df08daadb14936aa51bca9f9e96aac8be/src%2Flists.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55dd8f1df08daadb14936aa51bca9f9e96aac8be/src%2Flists.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flists.rs?ref=55dd8f1df08daadb14936aa51bca9f9e96aac8be", "patch": "@@ -80,6 +80,16 @@ pub struct ListItem {\n }\n \n impl ListItem {\n+    pub fn empty() -> ListItem {\n+        ListItem {\n+            pre_comment: None,\n+            pre_comment_style: ListItemCommentStyle::None,\n+            item: None,\n+            post_comment: None,\n+            new_lines: false,\n+        }\n+    }\n+\n     pub fn inner_as_ref(&self) -> &str {\n         self.item.as_ref().map_or(\"\", |s| s)\n     }"}, {"sha": "fb1716379b1c57f12cd4b3859e4d7024a9af1dbd", "filename": "src/reorder.rs", "status": "modified", "additions": 22, "deletions": 10, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/55dd8f1df08daadb14936aa51bca9f9e96aac8be/src%2Freorder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55dd8f1df08daadb14936aa51bca9f9e96aac8be/src%2Freorder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Freorder.rs?ref=55dd8f1df08daadb14936aa51bca9f9e96aac8be", "patch": "@@ -22,7 +22,7 @@ use syntax::{ast, attr, codemap::Span};\n use attr::filter_inline_attrs;\n use codemap::LineRangeUtils;\n use comment::combine_strs_with_missing_comments;\n-use imports::UseTree;\n+use imports::{merge_use_trees, UseTree};\n use items::{is_mod_decl, rewrite_extern_crate, rewrite_mod};\n use lists::{itemize_list, write_list, ListFormatting, ListItem};\n use rewrite::{Rewrite, RewriteContext};\n@@ -117,29 +117,41 @@ fn rewrite_reorderable_items(\n     match reorderable_items[0].node {\n         // FIXME: Remove duplicated code.\n         ast::ItemKind::Use(..) => {\n-            let normalized_items: Vec<_> = reorderable_items\n+            let mut normalized_items: Vec<_> = reorderable_items\n                 .iter()\n                 .filter_map(|item| UseTree::from_ast_with_normalization(context, item))\n                 .collect();\n-\n-            // 4 = \"use \", 1 = \";\"\n-            let nested_shape = shape.offset_left(4)?.sub_width(1)?;\n+            let cloned = normalized_items.clone();\n+            // Add comments before merging.\n             let list_items = itemize_list(\n                 context.snippet_provider,\n-                normalized_items.iter(),\n+                cloned.iter(),\n                 \"\",\n                 \";\",\n                 |item| item.span.lo(),\n                 |item| item.span.hi(),\n-                |item| item.rewrite_top_level(context, nested_shape),\n+                |_item| Some(\"\".to_owned()),\n                 span.lo(),\n                 span.hi(),\n                 false,\n             );\n+            for (item, list_item) in normalized_items.iter_mut().zip(list_items) {\n+                item.list_item = Some(list_item.clone());\n+            }\n+            if context.config.merge_imports() {\n+                normalized_items = merge_use_trees(normalized_items);\n+            }\n+            normalized_items.sort();\n \n-            let mut item_pair_vec: Vec<_> = list_items.zip(&normalized_items).collect();\n-            item_pair_vec.sort_by(|a, b| a.1.cmp(b.1));\n-            let item_vec: Vec<_> = item_pair_vec.into_iter().map(|pair| pair.0).collect();\n+            // 4 = \"use \", 1 = \";\"\n+            let nested_shape = shape.offset_left(4)?.sub_width(1)?;\n+            let item_vec: Vec<_> = normalized_items\n+                .into_iter()\n+                .map(|use_tree| ListItem {\n+                    item: use_tree.rewrite_top_level(context, nested_shape),\n+                    ..use_tree.list_item.unwrap_or_else(|| ListItem::empty())\n+                })\n+                .collect();\n \n             wrap_reorderable_items(context, &item_vec, nested_shape)\n         }"}, {"sha": "8033e8d806180d8c37a46fd31484fe2783cb9c17", "filename": "tests/source/merge_imports.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/55dd8f1df08daadb14936aa51bca9f9e96aac8be/tests%2Fsource%2Fmerge_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55dd8f1df08daadb14936aa51bca9f9e96aac8be/tests%2Fsource%2Fmerge_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fmerge_imports.rs?ref=55dd8f1df08daadb14936aa51bca9f9e96aac8be", "patch": "@@ -0,0 +1,26 @@\n+// rustfmt-merge_imports: true\n+// rustfmt-reorder_imports: true\n+// rustfmt-reorder_imported_names: true\n+\n+use a::{c,d,b};\n+use a::{d, e, b, a, f};\n+use a::{f, g, c};\n+\n+#[doc(hidden)]\n+use a::b;\n+use a::c;\n+use a::d;\n+\n+use a::{c, d, e};\n+#[doc(hidden)]\n+use a::b;\n+use a::d;\n+\n+pub use foo::bar;\n+use foo::{a, b, c};\n+pub use foo::foobar;\n+\n+use a::{b::{c::*}};\n+use a::{b::{c::{}}};\n+use a::{b::{c::d}};\n+use a::{b::{c::{xxx, yyy, zzz}}};"}, {"sha": "9ce6ef7ee7ab6c9bc3ed36ee7b7b331239fc25a3", "filename": "tests/target/merge_imports.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/55dd8f1df08daadb14936aa51bca9f9e96aac8be/tests%2Ftarget%2Fmerge_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55dd8f1df08daadb14936aa51bca9f9e96aac8be/tests%2Ftarget%2Fmerge_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fmerge_imports.rs?ref=55dd8f1df08daadb14936aa51bca9f9e96aac8be", "patch": "@@ -0,0 +1,18 @@\n+// rustfmt-merge_imports: true\n+// rustfmt-reorder_imports: true\n+// rustfmt-reorder_imported_names: true\n+\n+use a::{a, b, c, d, e, f, g};\n+\n+#[doc(hidden)]\n+use a::b;\n+use a::{c, d};\n+\n+#[doc(hidden)]\n+use a::b;\n+use a::{c, d, e};\n+\n+use foo::{a, b, c};\n+pub use foo::{bar, foobar};\n+\n+use a::b::c::{d, xxx, yyy, zzz, *};"}]}