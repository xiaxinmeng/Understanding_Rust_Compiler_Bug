{"sha": "d58c0a75978e068af8b01ab578b743c52635e1f4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ1OGMwYTc1OTc4ZTA2OGFmOGIwMWFiNTc4Yjc0M2M1MjYzNWUxZjQ=", "commit": {"author": {"name": "GuillaumeGomez", "email": "guillaume1.gomez@gmail.com", "date": "2015-02-02T23:23:08Z"}, "committer": {"name": "GuillaumeGomez", "email": "guillaume1.gomez@gmail.com", "date": "2015-02-06T10:59:10Z"}, "message": "Replace the get method by the deref one on InternedString", "tree": {"sha": "2764c6584e8c3f9851fe65a686f07739db7e062d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2764c6584e8c3f9851fe65a686f07739db7e062d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d58c0a75978e068af8b01ab578b743c52635e1f4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d58c0a75978e068af8b01ab578b743c52635e1f4", "html_url": "https://github.com/rust-lang/rust/commit/d58c0a75978e068af8b01ab578b743c52635e1f4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d58c0a75978e068af8b01ab578b743c52635e1f4/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "966e6c0c370317f06aa85248c17c7081d9736d99", "url": "https://api.github.com/repos/rust-lang/rust/commits/966e6c0c370317f06aa85248c17c7081d9736d99", "html_url": "https://github.com/rust-lang/rust/commit/966e6c0c370317f06aa85248c17c7081d9736d99"}], "stats": {"total": 227, "additions": 123, "deletions": 104}, "files": [{"sha": "4c2d09562af3bd62ffb51be24d57de3f05b6d3a8", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d58c0a75978e068af8b01ab578b743c52635e1f4/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d58c0a75978e068af8b01ab578b743c52635e1f4/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=d58c0a75978e068af8b01ab578b743c52635e1f4", "patch": "@@ -68,6 +68,7 @@ use std::fmt::Show;\n use std::num::Int;\n use std::rc::Rc;\n use serialize::{Encodable, Decodable, Encoder, Decoder};\n+use std::ops::Deref;\n \n // FIXME #6993: in librustc, uses of \"ident\" should be replaced\n // by just \"Name\".\n@@ -112,13 +113,13 @@ impl fmt::Display for Ident {\n impl fmt::Debug for Name {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         let Name(nm) = *self;\n-        write!(f, \"{:?}({})\", token::get_name(*self).get(), nm)\n+        write!(f, \"{:?}({})\", token::get_name(*self).deref(), nm)\n     }\n }\n \n impl fmt::Display for Name {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::Display::fmt(token::get_name(*self).get(), f)\n+        fmt::Display::fmt(token::get_name(*self).deref(), f)\n     }\n }\n \n@@ -174,7 +175,7 @@ impl Name {\n     pub fn as_str<'a>(&'a self) -> &'a str {\n         unsafe {\n             // FIXME #12938: can't use copy_lifetime since &str isn't a &T\n-            ::std::mem::transmute::<&str,&str>(token::get_name(*self).get())\n+            ::std::mem::transmute::<&str,&str>(token::get_name(*self).deref())\n         }\n     }\n \n@@ -193,7 +194,7 @@ pub type Mrk = u32;\n \n impl Encodable for Ident {\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n-        s.emit_str(token::get_ident(*self).get())\n+        s.emit_str(token::get_ident(*self).deref())\n     }\n }\n "}, {"sha": "3129f80cb5fac3b11d4ce34f9fda2572112844ab", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d58c0a75978e068af8b01ab578b743c52635e1f4/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d58c0a75978e068af8b01ab578b743c52635e1f4/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=d58c0a75978e068af8b01ab578b743c52635e1f4", "patch": "@@ -23,11 +23,12 @@ use visit;\n \n use std::cmp;\n use std::u32;\n+use std::ops::Deref;\n \n pub fn path_name_i(idents: &[Ident]) -> String {\n     // FIXME: Bad copies (#2543 -- same for everything else that says \"bad\")\n     idents.iter().map(|i| {\n-        token::get_ident(*i).get().to_string()\n+        token::get_ident(*i).deref().to_string()\n     }).collect::<Vec<String>>().connect(\"::\")\n }\n "}, {"sha": "48d35d4ad138ec58888550fb77c486fc4551f53d", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/d58c0a75978e068af8b01ab578b743c52635e1f4/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d58c0a75978e068af8b01ab578b743c52635e1f4/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=d58c0a75978e068af8b01ab578b743c52635e1f4", "patch": "@@ -29,6 +29,7 @@ use std::cell::{RefCell, Cell};\n use std::collections::BitvSet;\n use std::collections::HashSet;\n use std::fmt;\n+use std::ops::Deref;\n \n thread_local! { static USED_ATTRS: RefCell<BitvSet> = RefCell::new(BitvSet::new()) }\n \n@@ -44,7 +45,7 @@ pub fn is_used(attr: &Attribute) -> bool {\n \n pub trait AttrMetaMethods {\n     fn check_name(&self, name: &str) -> bool {\n-        name == self.name().get()\n+        name == self.name().deref()\n     }\n \n     /// Retrieve the name of the meta item, e.g. `foo` in `#[foo]`,\n@@ -62,7 +63,7 @@ pub trait AttrMetaMethods {\n \n impl AttrMetaMethods for Attribute {\n     fn check_name(&self, name: &str) -> bool {\n-        let matches = name == self.name().get();\n+        let matches = name == self.name().deref();\n         if matches {\n             mark_used(self);\n         }\n@@ -142,7 +143,7 @@ impl AttributeMethods for Attribute {\n             let meta = mk_name_value_item_str(\n                 InternedString::new(\"doc\"),\n                 token::intern_and_get_ident(&strip_doc_comment_decoration(\n-                        comment.get())[]));\n+                        comment.deref())[]));\n             if self.node.style == ast::AttrOuter {\n                 f(&mk_attr_outer(self.node.id, meta))\n             } else {\n@@ -209,7 +210,7 @@ pub fn mk_attr_outer(id: AttrId, item: P<MetaItem>) -> Attribute {\n pub fn mk_sugared_doc_attr(id: AttrId, text: InternedString, lo: BytePos,\n                            hi: BytePos)\n                            -> Attribute {\n-    let style = doc_comment_style(text.get());\n+    let style = doc_comment_style(text.deref());\n     let lit = spanned(lo, hi, ast::LitStr(text, ast::CookedStr));\n     let attr = Attribute_ {\n         id: id,\n@@ -326,11 +327,11 @@ pub fn requests_inline(attrs: &[Attribute]) -> bool {\n /// Tests if a cfg-pattern matches the cfg set\n pub fn cfg_matches(diagnostic: &SpanHandler, cfgs: &[P<MetaItem>], cfg: &ast::MetaItem) -> bool {\n     match cfg.node {\n-        ast::MetaList(ref pred, ref mis) if pred.get() == \"any\" =>\n+        ast::MetaList(ref pred, ref mis) if pred.deref() == \"any\" =>\n             mis.iter().any(|mi| cfg_matches(diagnostic, cfgs, &**mi)),\n-        ast::MetaList(ref pred, ref mis) if pred.get() == \"all\" =>\n+        ast::MetaList(ref pred, ref mis) if pred.deref() == \"all\" =>\n             mis.iter().all(|mi| cfg_matches(diagnostic, cfgs, &**mi)),\n-        ast::MetaList(ref pred, ref mis) if pred.get() == \"not\" => {\n+        ast::MetaList(ref pred, ref mis) if pred.deref() == \"not\" => {\n             if mis.len() != 1 {\n                 diagnostic.span_err(cfg.span, \"expected 1 cfg-pattern\");\n                 return false;\n@@ -382,7 +383,7 @@ fn find_stability_generic<'a,\n \n     'outer: for attr in attrs {\n         let tag = attr.name();\n-        let tag = tag.get();\n+        let tag = tag.deref();\n         if tag != \"deprecated\" && tag != \"unstable\" && tag != \"stable\" {\n             continue // not a stability level\n         }\n@@ -394,8 +395,8 @@ fn find_stability_generic<'a,\n                 let mut feature = None;\n                 let mut since = None;\n                 let mut reason = None;\n-                for meta in metas {\n-                    if meta.name().get() == \"feature\" {\n+                for meta in metas.iter() {\n+                    if meta.name() == \"feature\" {\n                         match meta.value_str() {\n                             Some(v) => feature = Some(v),\n                             None => {\n@@ -404,7 +405,7 @@ fn find_stability_generic<'a,\n                             }\n                         }\n                     }\n-                    if meta.name().get() == \"since\" {\n+                    if meta.name().deref() == \"since\" {\n                         match meta.value_str() {\n                             Some(v) => since = Some(v),\n                             None => {\n@@ -413,7 +414,7 @@ fn find_stability_generic<'a,\n                             }\n                         }\n                     }\n-                    if meta.name().get() == \"reason\" {\n+                    if meta.name().deref() == \"reason\" {\n                         match meta.value_str() {\n                             Some(v) => reason = Some(v),\n                             None => {\n@@ -521,11 +522,11 @@ pub fn find_repr_attrs(diagnostic: &SpanHandler, attr: &Attribute) -> Vec<ReprAt\n             for item in items {\n                 match item.node {\n                     ast::MetaWord(ref word) => {\n-                        let hint = match word.get() {\n+                        let hint = match word.deref() {\n                             // Can't use \"extern\" because it's not a lexical identifier.\n                             \"C\" => Some(ReprExtern),\n                             \"packed\" => Some(ReprPacked),\n-                            _ => match int_type_of_word(word.get()) {\n+                            _ => match int_type_of_word(word.deref()) {\n                                 Some(ity) => Some(ReprInt(item.span, ity)),\n                                 None => {\n                                     // Not a word we recognize"}, {"sha": "6917daacaf2faa8403b9ee13b517d1bce512fe55", "filename": "src/libsyntax/diagnostics/plugin.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d58c0a75978e068af8b01ab578b743c52635e1f4/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d58c0a75978e068af8b01ab578b743c52635e1f4/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs?ref=d58c0a75978e068af8b01ab578b743c52635e1f4", "patch": "@@ -10,6 +10,8 @@\n \n use std::cell::RefCell;\n use std::collections::BTreeMap;\n+use std::ops::Deref;\n+\n use ast;\n use ast::{Ident, Name, TokenTree};\n use codemap::Span;\n@@ -57,7 +59,7 @@ pub fn expand_diagnostic_used<'cx>(ecx: &'cx mut ExtCtxt,\n         match diagnostics.insert(code.name, span) {\n             Some(previous_span) => {\n                 ecx.span_warn(span, &format!(\n-                    \"diagnostic code {} already used\", token::get_ident(code).get()\n+                    \"diagnostic code {} already used\", token::get_ident(code).deref()\n                 )[]);\n                 ecx.span_note(previous_span, \"previous invocation\");\n             },\n@@ -68,7 +70,7 @@ pub fn expand_diagnostic_used<'cx>(ecx: &'cx mut ExtCtxt,\n     with_registered_diagnostics(|diagnostics| {\n         if !diagnostics.contains_key(&code.name) {\n             ecx.span_err(span, &format!(\n-                \"used diagnostic code {} not registered\", token::get_ident(code).get()\n+                \"used diagnostic code {} not registered\", token::get_ident(code).deref()\n             )[]);\n         }\n     });\n@@ -93,12 +95,12 @@ pub fn expand_register_diagnostic<'cx>(ecx: &'cx mut ExtCtxt,\n     with_registered_diagnostics(|diagnostics| {\n         if diagnostics.insert(code.name, description).is_some() {\n             ecx.span_err(span, &format!(\n-                \"diagnostic code {} already registered\", token::get_ident(*code).get()\n+                \"diagnostic code {} already registered\", token::get_ident(*code).deref()\n             )[]);\n         }\n     });\n     let sym = Ident::new(token::gensym(&(\n-        \"__register_diagnostic_\".to_string() + token::get_ident(*code).get()\n+        \"__register_diagnostic_\".to_string() + token::get_ident(*code).deref()\n     )[]));\n     MacItems::new(vec![quote_item!(ecx, mod $sym {}).unwrap()].into_iter())\n }"}, {"sha": "8a12557e477680ad84853d61cbc920dc5d6c890d", "filename": "src/libsyntax/ext/asm.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d58c0a75978e068af8b01ab578b743c52635e1f4/src%2Flibsyntax%2Fext%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d58c0a75978e068af8b01ab578b743c52635e1f4/src%2Flibsyntax%2Fext%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fasm.rs?ref=d58c0a75978e068af8b01ab578b743c52635e1f4", "patch": "@@ -22,6 +22,8 @@ use parse::token::InternedString;\n use parse::token;\n use ptr::P;\n \n+use std::ops::Deref;\n+\n enum State {\n     Asm,\n     Outputs,\n@@ -102,7 +104,7 @@ pub fn expand_asm<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n                     // It's the opposite of '=&' which means that the memory\n                     // cannot be shared with any other operand (usually when\n                     // a register is clobbered early.)\n-                    let output = match constraint.get().slice_shift_char() {\n+                    let output = match constraint.deref().slice_shift_char() {\n                         Some(('=', _)) => None,\n                         Some(('+', operand)) => {\n                             Some(token::intern_and_get_ident(&format!(\n@@ -129,9 +131,9 @@ pub fn expand_asm<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n \n                     let (constraint, _str_style) = p.parse_str();\n \n-                    if constraint.get().starts_with(\"=\") {\n+                    if constraint.deref().starts_with(\"=\") {\n                         cx.span_err(p.last_span, \"input operand constraint contains '='\");\n-                    } else if constraint.get().starts_with(\"+\") {\n+                    } else if constraint.deref().starts_with(\"+\") {\n                         cx.span_err(p.last_span, \"input operand constraint contains '+'\");\n                     }\n \n@@ -213,7 +215,7 @@ pub fn expand_asm<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n     MacExpr::new(P(ast::Expr {\n         id: ast::DUMMY_NODE_ID,\n         node: ast::ExprInlineAsm(ast::InlineAsm {\n-            asm: token::intern_and_get_ident(asm.get()),\n+            asm: token::intern_and_get_ident(asm.deref()),\n             asm_str_style: asm_str_style.unwrap(),\n             outputs: outputs,\n             inputs: inputs,"}, {"sha": "21f00f0934d6cb90faee30fad5275fa71b8be95d", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d58c0a75978e068af8b01ab578b743c52635e1f4/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d58c0a75978e068af8b01ab578b743c52635e1f4/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=d58c0a75978e068af8b01ab578b743c52635e1f4", "patch": "@@ -28,6 +28,7 @@ use fold::Folder;\n \n use std::collections::HashMap;\n use std::rc::Rc;\n+use std::ops::Deref;\n \n pub trait ItemDecorator {\n     fn expand(&self,\n@@ -790,7 +791,7 @@ pub fn get_single_str_from_tts(cx: &mut ExtCtxt,\n         cx.span_err(sp, &format!(\"{} takes 1 argument\", name)[]);\n     }\n     expr_to_string(cx, ret, \"argument must be a string literal\").map(|(s, _)| {\n-        s.get().to_string()\n+        s.deref().to_string()\n     })\n }\n "}, {"sha": "18373219aa1d4081595925da27cd042a59e5d208", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d58c0a75978e068af8b01ab578b743c52635e1f4/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d58c0a75978e068af8b01ab578b743c52635e1f4/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=d58c0a75978e068af8b01ab578b743c52635e1f4", "patch": "@@ -21,6 +21,7 @@ use parse::token::InternedString;\n use parse::token;\n use ptr::P;\n \n+use std::ops::Deref;\n \n // Transitional reexports so qquote can find the paths it is looking for\n mod syntax {\n@@ -576,7 +577,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n     fn expr_field_access(&self, sp: Span, expr: P<ast::Expr>, ident: ast::Ident) -> P<ast::Expr> {\n         let field_name = token::get_ident(ident);\n         let field_span = Span {\n-            lo: sp.lo - Pos::from_usize(field_name.get().len()),\n+            lo: sp.lo - Pos::from_usize(field_name.deref().len()),\n             hi: sp.hi,\n             expn_id: sp.expn_id,\n         };"}, {"sha": "9dbc097be275f0173567115c3cfda310ce7eeacc", "filename": "src/libsyntax/ext/concat.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d58c0a75978e068af8b01ab578b743c52635e1f4/src%2Flibsyntax%2Fext%2Fconcat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d58c0a75978e068af8b01ab578b743c52635e1f4/src%2Flibsyntax%2Fext%2Fconcat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fconcat.rs?ref=d58c0a75978e068af8b01ab578b743c52635e1f4", "patch": "@@ -15,6 +15,7 @@ use ext::build::AstBuilder;\n use parse::token;\n \n use std::string::String;\n+use std::ops::Deref;\n \n pub fn expand_syntax_ext(cx: &mut base::ExtCtxt,\n                          sp: codemap::Span,\n@@ -32,7 +33,7 @@ pub fn expand_syntax_ext(cx: &mut base::ExtCtxt,\n                     ast::LitStr(ref s, _) |\n                     ast::LitFloat(ref s, _) |\n                     ast::LitFloatUnsuffixed(ref s) => {\n-                        accumulator.push_str(s.get());\n+                        accumulator.push_str(s.deref());\n                     }\n                     ast::LitChar(c) => {\n                         accumulator.push(c);"}, {"sha": "feadaaf29c48a880170d6748a33f4064c332a599", "filename": "src/libsyntax/ext/concat_idents.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d58c0a75978e068af8b01ab578b743c52635e1f4/src%2Flibsyntax%2Fext%2Fconcat_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d58c0a75978e068af8b01ab578b743c52635e1f4/src%2Flibsyntax%2Fext%2Fconcat_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fconcat_idents.rs?ref=d58c0a75978e068af8b01ab578b743c52635e1f4", "patch": "@@ -16,6 +16,8 @@ use parse::token;\n use parse::token::{str_to_ident};\n use ptr::P;\n \n+use std::ops::Deref;\n+\n pub fn expand_syntax_ext<'cx>(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n                               -> Box<base::MacResult+'cx> {\n     let mut res_str = String::new();\n@@ -31,7 +33,7 @@ pub fn expand_syntax_ext<'cx>(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree]\n         } else {\n             match *e {\n                 ast::TtToken(_, token::Ident(ident, _)) => {\n-                    res_str.push_str(token::get_ident(ident).get())\n+                    res_str.push_str(token::get_ident(ident).deref())\n                 },\n                 _ => {\n                     cx.span_err(sp, \"concat_idents! requires ident args.\");"}, {"sha": "dcef20a9931d4124ce46264b6e9faee8d9e784ce", "filename": "src/libsyntax/ext/deriving/bounds.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d58c0a75978e068af8b01ab578b743c52635e1f4/src%2Flibsyntax%2Fext%2Fderiving%2Fbounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d58c0a75978e068af8b01ab578b743c52635e1f4/src%2Flibsyntax%2Fext%2Fderiving%2Fbounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fbounds.rs?ref=d58c0a75978e068af8b01ab578b743c52635e1f4", "patch": "@@ -15,6 +15,8 @@ use ext::deriving::generic::*;\n use ext::deriving::generic::ty::*;\n use ptr::P;\n \n+use std::ops::Deref;\n+\n pub fn expand_deriving_bound<F>(cx: &mut ExtCtxt,\n                                 span: Span,\n                                 mitem: &MetaItem,\n@@ -24,7 +26,7 @@ pub fn expand_deriving_bound<F>(cx: &mut ExtCtxt,\n {\n     let name = match mitem.node {\n         MetaWord(ref tname) => {\n-            match tname.get() {\n+            match tname.deref() {\n                 \"Copy\" => \"Copy\",\n                 \"Send\" | \"Sync\" => {\n                     return cx.span_err(span,"}, {"sha": "4a67ebc190f49ee83f0e06378fe8ee2b20e79e26", "filename": "src/libsyntax/ext/deriving/generic/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d58c0a75978e068af8b01ab578b743c52635e1f4/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d58c0a75978e068af8b01ab578b743c52635e1f4/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs?ref=d58c0a75978e068af8b01ab578b743c52635e1f4", "patch": "@@ -189,6 +189,7 @@ use self::StructType::*;\n \n use std::cell::RefCell;\n use std::vec;\n+use std::ops::Deref;\n \n use abi::Abi;\n use abi;\n@@ -363,7 +364,7 @@ impl<'a> TraitDef<'a> {\n         // generated implementations are linted\n         let mut attrs = newitem.attrs.clone();\n         attrs.extend(item.attrs.iter().filter(|a| {\n-            match a.name().get() {\n+            match a.name().deref() {\n                 \"allow\" | \"warn\" | \"deny\" | \"forbid\" => true,\n                 _ => false,\n             }"}, {"sha": "dd093f3ac2c055a29e937fc79b680bd554b25bd0", "filename": "src/libsyntax/ext/deriving/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d58c0a75978e068af8b01ab578b743c52635e1f4/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d58c0a75978e068af8b01ab578b743c52635e1f4/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs?ref=d58c0a75978e068af8b01ab578b743c52635e1f4", "patch": "@@ -18,6 +18,8 @@ use ext::base::ExtCtxt;\n use codemap::Span;\n use ptr::P;\n \n+use std::ops::Deref;\n+\n pub mod bounds;\n pub mod clone;\n pub mod encodable;\n@@ -74,7 +76,7 @@ pub fn expand_meta_derive(cx: &mut ExtCtxt,\n                                                    |i| push(i)))\n                         }\n \n-                        match tname.get() {\n+                        match tname.deref() {\n                             \"Clone\" => expand!(clone::expand_deriving_clone),\n \n                             \"Hash\" => expand!(hash::expand_deriving_hash),"}, {"sha": "b315b1bfe18dc019ce8a6a4dd6e4d827e574ce68", "filename": "src/libsyntax/ext/deriving/show.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d58c0a75978e068af8b01ab578b743c52635e1f4/src%2Flibsyntax%2Fext%2Fderiving%2Fshow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d58c0a75978e068af8b01ab578b743c52635e1f4/src%2Flibsyntax%2Fext%2Fderiving%2Fshow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fshow.rs?ref=d58c0a75978e068af8b01ab578b743c52635e1f4", "patch": "@@ -20,6 +20,7 @@ use parse::token;\n use ptr::P;\n \n use std::collections::HashMap;\n+use std::ops::Deref;\n \n pub fn expand_deriving_show<F>(cx: &mut ExtCtxt,\n                                span: Span,\n@@ -72,7 +73,7 @@ fn show_substructure(cx: &mut ExtCtxt, span: Span,\n         }\n     };\n \n-    let mut format_string = String::from_str(token::get_ident(name).get());\n+    let mut format_string = String::from_str(token::get_ident(name).deref());\n     // the internal fields we're actually formatting\n     let mut exprs = Vec::new();\n \n@@ -107,7 +108,7 @@ fn show_substructure(cx: &mut ExtCtxt, span: Span,\n \n                     let name = token::get_ident(field.name.unwrap());\n                     format_string.push_str(\" \");\n-                    format_string.push_str(name.get());\n+                    format_string.push_str(name.deref());\n                     format_string.push_str(\": {:?}\");\n \n                     exprs.push(field.self_.clone());"}, {"sha": "cd7fbb4fa73af6a418938903ba4c72609bdb94be", "filename": "src/libsyntax/ext/env.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d58c0a75978e068af8b01ab578b743c52635e1f4/src%2Flibsyntax%2Fext%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d58c0a75978e068af8b01ab578b743c52635e1f4/src%2Flibsyntax%2Fext%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fenv.rs?ref=d58c0a75978e068af8b01ab578b743c52635e1f4", "patch": "@@ -22,6 +22,8 @@ use ext::build::AstBuilder;\n use parse::token;\n \n use std::env;\n+use std::os;\n+use std::ops::Deref;\n \n pub fn expand_option_env<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n                               -> Box<base::MacResult+'cx> {\n@@ -101,9 +103,9 @@ pub fn expand_env<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n         }\n     }\n \n-    let e = match env::var_string(var.get()) {\n-        Err(..) => {\n-            cx.span_err(sp, msg.get());\n+    let e = match os::getenv(var.deref()) {\n+        None => {\n+            cx.span_err(sp, msg.deref());\n             cx.expr_usize(sp, 0)\n         }\n         Ok(s) => cx.expr_str(sp, token::intern_and_get_ident(&s[]))"}, {"sha": "2439c34804673c83c943414190290563531dcdac", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 23, "deletions": 21, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/d58c0a75978e068af8b01ab578b743c52635e1f4/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d58c0a75978e068af8b01ab578b743c52635e1f4/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=d58c0a75978e068af8b01ab578b743c52635e1f4", "patch": "@@ -32,6 +32,8 @@ use util::small_vector::SmallVector;\n use visit;\n use visit::Visitor;\n \n+use std::ops::Deref;\n+\n pub fn expand_type(t: P<ast::Ty>,\n                    fld: &mut MacroExpander,\n                    impl_ty: Option<P<ast::Ty>>)\n@@ -375,7 +377,7 @@ fn expand_mac_invoc<T, F, G>(mac: ast::Mac, span: codemap::Span,\n                     fld.cx.span_err(\n                         pth.span,\n                         &format!(\"macro undefined: '{}!'\",\n-                                extnamestr.get())[]);\n+                                extnamestr.deref())[]);\n \n                     // let compilation continue\n                     None\n@@ -385,7 +387,7 @@ fn expand_mac_invoc<T, F, G>(mac: ast::Mac, span: codemap::Span,\n                         fld.cx.bt_push(ExpnInfo {\n                                 call_site: span,\n                                 callee: NameAndSpan {\n-                                    name: extnamestr.get().to_string(),\n+                                    name: extnamestr.deref().to_string(),\n                                     format: MacroBang,\n                                     span: exp_span,\n                                 },\n@@ -411,7 +413,7 @@ fn expand_mac_invoc<T, F, G>(mac: ast::Mac, span: codemap::Span,\n                                 fld.cx.span_err(\n                                     pth.span,\n                                     &format!(\"non-expression macro in expression position: {}\",\n-                                            &extnamestr.get()[]\n+                                            &extnamestr.deref()[]\n                                             )[]);\n                                 return None;\n                             }\n@@ -422,7 +424,7 @@ fn expand_mac_invoc<T, F, G>(mac: ast::Mac, span: codemap::Span,\n                         fld.cx.span_err(\n                             pth.span,\n                             &format!(\"'{}' is not a tt-style macro\",\n-                                    extnamestr.get())[]);\n+                                    extnamestr.deref())[]);\n                         None\n                     }\n                 }\n@@ -506,14 +508,14 @@ fn expand_item_modifiers(mut it: P<ast::Item>, fld: &mut MacroExpander)\n     for attr in &modifiers {\n         let mname = attr.name();\n \n-        match fld.cx.syntax_env.find(&intern(mname.get())) {\n+        match fld.cx.syntax_env.find(&intern(mname.deref())) {\n             Some(rc) => match *rc {\n                 Modifier(ref mac) => {\n                     attr::mark_used(attr);\n                     fld.cx.bt_push(ExpnInfo {\n                         call_site: attr.span,\n                         callee: NameAndSpan {\n-                            name: mname.get().to_string(),\n+                            name: mname.deref().to_string(),\n                             format: MacroAttribute,\n                             span: None,\n                         }\n@@ -613,7 +615,7 @@ pub fn expand_item_mac(it: P<ast::Item>,\n                     fld.cx.bt_push(ExpnInfo {\n                         call_site: it.span,\n                         callee: NameAndSpan {\n-                            name: extnamestr.get().to_string(),\n+                            name: extnamestr.deref().to_string(),\n                             format: MacroBang,\n                             span: span\n                         }\n@@ -626,13 +628,13 @@ pub fn expand_item_mac(it: P<ast::Item>,\n                     if it.ident.name == parse::token::special_idents::invalid.name {\n                         fld.cx.span_err(path_span,\n                                         &format!(\"macro {}! expects an ident argument\",\n-                                                extnamestr.get())[]);\n+                                                extnamestr.deref())[]);\n                         return SmallVector::zero();\n                     }\n                     fld.cx.bt_push(ExpnInfo {\n                         call_site: it.span,\n                         callee: NameAndSpan {\n-                            name: extnamestr.get().to_string(),\n+                            name: extnamestr.deref().to_string(),\n                             format: MacroBang,\n                             span: span\n                         }\n@@ -651,7 +653,7 @@ pub fn expand_item_mac(it: P<ast::Item>,\n                     fld.cx.bt_push(ExpnInfo {\n                         call_site: it.span,\n                         callee: NameAndSpan {\n-                            name: extnamestr.get().to_string(),\n+                            name: extnamestr.deref().to_string(),\n                             format: MacroBang,\n                             span: None,\n                         }\n@@ -677,7 +679,7 @@ pub fn expand_item_mac(it: P<ast::Item>,\n                 _ => {\n                     fld.cx.span_err(it.span,\n                                     &format!(\"{}! is not legal in item position\",\n-                                            extnamestr.get())[]);\n+                                            extnamestr.deref())[]);\n                     return SmallVector::zero();\n                 }\n             }\n@@ -696,7 +698,7 @@ pub fn expand_item_mac(it: P<ast::Item>,\n         None => {\n             fld.cx.span_err(path_span,\n                             &format!(\"non-item macro in item position: {}\",\n-                                    extnamestr.get())[]);\n+                                    extnamestr.deref())[]);\n             return SmallVector::zero();\n         }\n     };\n@@ -950,7 +952,7 @@ fn expand_pat(p: P<ast::Pat>, fld: &mut MacroExpander) -> P<ast::Pat> {\n                     fld.cx.bt_push(ExpnInfo {\n                         call_site: span,\n                         callee: NameAndSpan {\n-                            name: extnamestr.get().to_string(),\n+                            name: extnamestr.deref().to_string(),\n                             format: MacroBang,\n                             span: tt_span\n                         }\n@@ -968,7 +970,7 @@ fn expand_pat(p: P<ast::Pat>, fld: &mut MacroExpander) -> P<ast::Pat> {\n                                 pth.span,\n                                 &format!(\n                                     \"non-pattern macro in pattern position: {}\",\n-                                    extnamestr.get()\n+                                    extnamestr.deref()\n                                     )[]\n                             );\n                             return DummyResult::raw_pat(span);\n@@ -981,7 +983,7 @@ fn expand_pat(p: P<ast::Pat>, fld: &mut MacroExpander) -> P<ast::Pat> {\n                 _ => {\n                     fld.cx.span_err(span,\n                                     &format!(\"{}! is not legal in pattern position\",\n-                                            extnamestr.get())[]);\n+                                            extnamestr.deref())[]);\n                     return DummyResult::raw_pat(span);\n                 }\n             }\n@@ -1065,7 +1067,7 @@ fn expand_annotatable(a: Annotatable,\n     for attr in a.attrs() {\n         let mname = attr.name();\n \n-        match fld.cx.syntax_env.find(&intern(mname.get())) {\n+        match fld.cx.syntax_env.find(&intern(mname.deref())) {\n             Some(rc) => match *rc {\n                 Decorator(ref dec) => {\n                     let it = match a {\n@@ -1079,7 +1081,7 @@ fn expand_annotatable(a: Annotatable,\n                     fld.cx.bt_push(ExpnInfo {\n                         call_site: attr.span,\n                         callee: NameAndSpan {\n-                            name: mname.get().to_string(),\n+                            name: mname.deref().to_string(),\n                             format: MacroAttribute,\n                             span: None\n                         }\n@@ -1180,7 +1182,7 @@ fn modifiers(attrs: &Vec<ast::Attribute>,\n              fld: &MacroExpander)\n              -> (Vec<ast::Attribute>, Vec<ast::Attribute>) {\n     attrs.iter().cloned().partition(|attr| {\n-        match fld.cx.syntax_env.find(&intern(attr.name().get())) {\n+        match fld.cx.syntax_env.find(&intern(attr.name().deref())) {\n             Some(rc) => match *rc {\n                 Modifier(_) => true,\n                 _ => false\n@@ -1195,7 +1197,7 @@ fn multi_modifiers(attrs: &[ast::Attribute],\n                    fld: &MacroExpander)\n                    -> (Vec<ast::Attribute>, Vec<ast::Attribute>) {\n     attrs.iter().cloned().partition(|attr| {\n-        match fld.cx.syntax_env.find(&intern(attr.name().get())) {\n+        match fld.cx.syntax_env.find(&intern(attr.name().deref())) {\n             Some(rc) => match *rc {\n                 MultiModifier(_) => true,\n                 _ => false\n@@ -1220,14 +1222,14 @@ fn expand_item_multi_modifier(mut it: Annotatable,\n     for attr in &modifiers {\n         let mname = attr.name();\n \n-        match fld.cx.syntax_env.find(&intern(mname.get())) {\n+        match fld.cx.syntax_env.find(&intern(mname.deref())) {\n             Some(rc) => match *rc {\n                 MultiModifier(ref mac) => {\n                     attr::mark_used(attr);\n                     fld.cx.bt_push(ExpnInfo {\n                         call_site: attr.span,\n                         callee: NameAndSpan {\n-                            name: mname.get().to_string(),\n+                            name: mname.deref().to_string(),\n                             format: MacroAttribute,\n                             span: None,\n                         }"}, {"sha": "5df5e1babd1db6f8d58463a24a04f2004f1291a8", "filename": "src/libsyntax/ext/format.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d58c0a75978e068af8b01ab578b743c52635e1f4/src%2Flibsyntax%2Fext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d58c0a75978e068af8b01ab578b743c52635e1f4/src%2Flibsyntax%2Fext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fformat.rs?ref=d58c0a75978e068af8b01ab578b743c52635e1f4", "patch": "@@ -23,6 +23,7 @@ use ptr::P;\n \n use std::collections::HashMap;\n use std::iter::repeat;\n+use std::ops::Deref;\n \n #[derive(PartialEq)]\n enum ArgumentType {\n@@ -118,7 +119,7 @@ fn parse_args(ecx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n                 }\n             };\n             let interned_name = token::get_ident(ident);\n-            let name = interned_name.get();\n+            let name = interned_name.deref();\n             p.expect(&token::Eq);\n             let e = p.parse_expr();\n             match names.get(name) {\n@@ -672,7 +673,7 @@ pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt, sp: Span,\n         None => return DummyResult::raw_expr(sp)\n     };\n \n-    let mut parser = parse::Parser::new(fmt.get());\n+    let mut parser = parse::Parser::new(fmt.deref());\n     loop {\n         match parser.next() {\n             Some(piece) => {"}, {"sha": "b3c686abcf6f36856f4b0a0aec741d169baa6da5", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d58c0a75978e068af8b01ab578b743c52635e1f4/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d58c0a75978e068af8b01ab578b743c52635e1f4/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=d58c0a75978e068af8b01ab578b743c52635e1f4", "patch": "@@ -25,6 +25,8 @@ use ptr::P;\n ///  as antiquotes (splices).\n \n pub mod rt {\n+    use std::ops::Deref;\n+\n     use ast;\n     use codemap::Spanned;\n     use ext::base::ExtCtxt;\n@@ -161,7 +163,7 @@ pub mod rt {\n \n     impl ToSource for ast::Ident {\n         fn to_source(&self) -> String {\n-            token::get_ident(*self).get().to_string()\n+            token::get_ident(*self).deref().to_string()\n         }\n     }\n "}, {"sha": "0458a56d05051c456ba2087dc05183fb59e0be75", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d58c0a75978e068af8b01ab578b743c52635e1f4/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d58c0a75978e068af8b01ab578b743c52635e1f4/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=d58c0a75978e068af8b01ab578b743c52635e1f4", "patch": "@@ -22,6 +22,7 @@ use util::small_vector::SmallVector;\n \n use std::old_io::File;\n use std::rc::Rc;\n+use std::ops::Deref;\n \n // These macros all relate to the file system; they either return\n // the column/row/filename of the expression, or they include\n@@ -73,7 +74,7 @@ pub fn expand_mod(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n     base::check_zero_tts(cx, sp, tts, \"module_path!\");\n     let string = cx.mod_path()\n                    .iter()\n-                   .map(|x| token::get_ident(*x).get().to_string())\n+                   .map(|x| token::get_ident(*x).deref().to_string())\n                    .collect::<Vec<String>>()\n                    .connect(\"::\");\n     base::MacExpr::new(cx.expr_str("}, {"sha": "da233c79ea4c983b6c3e58fafb4e691b2bcca241", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d58c0a75978e068af8b01ab578b743c52635e1f4/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d58c0a75978e068af8b01ab578b743c52635e1f4/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=d58c0a75978e068af8b01ab578b743c52635e1f4", "patch": "@@ -99,6 +99,7 @@ use std::mem;\n use std::rc::Rc;\n use std::collections::HashMap;\n use std::collections::hash_map::Entry::{Vacant, Occupied};\n+use std::ops::Deref;\n \n // To avoid costly uniqueness checks, we require that `MatchSeq` always has\n // a nonempty body.\n@@ -229,7 +230,7 @@ pub fn nameize(p_s: &ParseSess, ms: &[TokenTree], res: &[Rc<NamedMatch>])\n                         p_s.span_diagnostic\n                            .span_fatal(sp,\n                                        &format!(\"duplicated bind name: {}\",\n-                                               string.get())[])\n+                                               string.deref())[])\n                     }\n                 }\n             }\n@@ -487,8 +488,8 @@ pub fn parse(sess: &ParseSess,\n                     let name_string = token::get_ident(name);\n                     let match_cur = ei.match_cur;\n                     (&mut ei.matches[match_cur]).push(Rc::new(MatchedNonterminal(\n-                        parse_nt(&mut rust_parser, span, name_string.get()))));\n-                    ei.idx += 1;\n+                        parse_nt(&mut rust_parser, span, name_string.deref()))));\n+                    ei.idx += 1us;\n                     ei.match_cur += 1;\n                   }\n                   _ => panic!()"}, {"sha": "7447c00402417e72be1d297d564a698e08176732", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d58c0a75978e068af8b01ab578b743c52635e1f4/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d58c0a75978e068af8b01ab578b743c52635e1f4/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=d58c0a75978e068af8b01ab578b743c52635e1f4", "patch": "@@ -36,6 +36,7 @@ use parse::token::{self, InternedString};\n \n use std::slice;\n use std::ascii::AsciiExt;\n+use std::ops::Deref;\n \n // If you change this list without updating src/doc/reference.md, @cmr will be sad\n // Don't ever remove anything from this list; set them to 'Removed'.\n@@ -251,7 +252,7 @@ impl<'a> PostExpansionVisitor<'a> {\n \n impl<'a, 'v> Visitor<'v> for PostExpansionVisitor<'a> {\n     fn visit_name(&mut self, sp: Span, name: ast::Name) {\n-        if !token::get_name(name).get().is_ascii() {\n+        if !token::get_name(name).deref().is_ascii() {\n             self.gate_feature(\"non_ascii_idents\", sp,\n                               \"non-ascii idents are not fully supported.\");\n         }\n@@ -378,7 +379,7 @@ impl<'a, 'v> Visitor<'v> for PostExpansionVisitor<'a> {\n \n         let links_to_llvm = match attr::first_attr_value_str_by_name(&i.attrs,\n                                                                      \"link_name\") {\n-            Some(val) => val.get().starts_with(\"llvm.\"),\n+            Some(val) => val.deref().starts_with(\"llvm.\"),\n             _ => false\n         };\n         if links_to_llvm {"}, {"sha": "3ff51f99307acb466949b2da1f7b19344a3070c5", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d58c0a75978e068af8b01ab578b743c52635e1f4/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d58c0a75978e068af8b01ab578b743c52635e1f4/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=d58c0a75978e068af8b01ab578b743c52635e1f4", "patch": "@@ -84,6 +84,7 @@ use std::mem;\n use std::num::Float;\n use std::rc::Rc;\n use std::slice;\n+use std::ops::Deref;\n \n bitflags! {\n     flags Restrictions: u8 {\n@@ -5133,7 +5134,7 @@ impl<'a> Parser<'a> {\n                 outer_attrs, \"path\") {\n             Some(d) => (dir_path.join(d), true),\n             None => {\n-                let mod_name = mod_string.get().to_string();\n+                let mod_name = mod_string.deref().to_string();\n                 let default_path_str = format!(\"{}.rs\", mod_name);\n                 let secondary_path_str = format!(\"{}/mod.rs\", mod_name);\n                 let default_path = dir_path.join(&default_path_str[]);\n@@ -5145,7 +5146,7 @@ impl<'a> Parser<'a> {\n                     self.span_err(id_sp,\n                                   \"cannot declare a new module at this location\");\n                     let this_module = match self.mod_path_stack.last() {\n-                        Some(name) => name.get().to_string(),\n+                        Some(name) => name.deref().to_string(),\n                         None => self.root_module_name.as_ref().unwrap().clone(),\n                     };\n                     self.span_note(id_sp,\n@@ -5191,7 +5192,7 @@ impl<'a> Parser<'a> {\n         };\n \n         self.eval_src_mod_from_path(file_path, owns_directory,\n-                                    mod_string.get().to_string(), id_sp)\n+                                    mod_string.deref().to_string(), id_sp)\n     }\n \n     fn eval_src_mod_from_path(&mut self,"}, {"sha": "755ccfb00943246f6a7d241d50234c413512b46f", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 1, "deletions": 14, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d58c0a75978e068af8b01ab578b743c52635e1f4/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d58c0a75978e068af8b01ab578b743c52635e1f4/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=d58c0a75978e068af8b01ab578b743c52635e1f4", "patch": "@@ -625,19 +625,6 @@ impl InternedString {\n             string: string,\n         }\n     }\n-\n-    #[inline]\n-    #[deprecated = \"use as_slice() instead\"]\n-    pub fn get<'a>(&'a self) -> &'a str {\n-        &self.string[]\n-    }\n-}\n-\n-impl Str for InternedString {\n-    #[inline]\n-    fn as_slice<'a>(&'a self) -> &'a str {\n-        &self.string[]\n-    }\n }\n \n impl Deref for InternedString {\n@@ -652,7 +639,7 @@ impl BytesContainer for InternedString {\n         // of `BytesContainer`, which is itself a workaround for the lack of\n         // DST.\n         unsafe {\n-            let this = self.get();\n+            let this = self.deref();\n             mem::transmute::<&[u8],&[u8]>(this.container_as_bytes())\n         }\n     }"}, {"sha": "455e50430421a57f837bab3ab2119444955b0241", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 17, "deletions": 16, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/d58c0a75978e068af8b01ab578b743c52635e1f4/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d58c0a75978e068af8b01ab578b743c52635e1f4/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=d58c0a75978e068af8b01ab578b743c52635e1f4", "patch": "@@ -30,6 +30,7 @@ use ptr::P;\n use std::{ascii, mem};\n use std::old_io::{self, IoResult};\n use std::iter;\n+use std::ops::Deref;\n \n pub enum AnnNode<'a> {\n     NodeIdent(&'a ast::Ident),\n@@ -258,7 +259,7 @@ pub fn token_to_string(tok: &Token) -> String {\n         }\n \n         /* Name components */\n-        token::Ident(s, _)          => token::get_ident(s).get().to_string(),\n+        token::Ident(s, _)          => token::get_ident(s).deref().to_string(),\n         token::Lifetime(s)          => format!(\"{}\", token::get_ident(s)),\n         token::Underscore           => \"_\".to_string(),\n \n@@ -798,7 +799,7 @@ impl<'a> State<'a> {\n                 try!(self.head(&visibility_qualified(item.vis,\n                                                      \"extern crate\")[]));\n                 if let Some((ref p, style)) = *optional_path {\n-                    try!(self.print_string(p.get(), style));\n+                    try!(self.print_string(p.deref(), style));\n                     try!(space(&mut self.s));\n                     try!(word(&mut self.s, \"as\"));\n                     try!(space(&mut self.s));\n@@ -1313,7 +1314,7 @@ impl<'a> State<'a> {\n         try!(self.hardbreak_if_not_bol());\n         try!(self.maybe_print_comment(attr.span.lo));\n         if attr.node.is_sugared_doc {\n-            word(&mut self.s, attr.value_str().unwrap().get())\n+            word(&mut self.s, attr.value_str().unwrap().deref())\n         } else {\n             match attr.node.style {\n                 ast::AttrInner => try!(word(&mut self.s, \"#![\")),\n@@ -1847,17 +1848,17 @@ impl<'a> State<'a> {\n             ast::ExprInlineAsm(ref a) => {\n                 try!(word(&mut self.s, \"asm!\"));\n                 try!(self.popen());\n-                try!(self.print_string(a.asm.get(), a.asm_str_style));\n+                try!(self.print_string(a.asm.deref(), a.asm_str_style));\n                 try!(self.word_space(\":\"));\n \n                 try!(self.commasep(Inconsistent, &a.outputs[],\n                                    |s, &(ref co, ref o, is_rw)| {\n-                    match co.get().slice_shift_char() {\n+                    match co.deref().slice_shift_char() {\n                         Some(('=', operand)) if is_rw => {\n                             try!(s.print_string(&format!(\"+{}\", operand)[],\n                                                 ast::CookedStr))\n                         }\n-                        _ => try!(s.print_string(co.get(), ast::CookedStr))\n+                        _ => try!(s.print_string(co.deref(), ast::CookedStr))\n                     }\n                     try!(s.popen());\n                     try!(s.print_expr(&**o));\n@@ -1869,7 +1870,7 @@ impl<'a> State<'a> {\n \n                 try!(self.commasep(Inconsistent, &a.inputs[],\n                                    |s, &(ref co, ref o)| {\n-                    try!(s.print_string(co.get(), ast::CookedStr));\n+                    try!(s.print_string(co.deref(), ast::CookedStr));\n                     try!(s.popen());\n                     try!(s.print_expr(&**o));\n                     try!(s.pclose());\n@@ -1880,7 +1881,7 @@ impl<'a> State<'a> {\n \n                 try!(self.commasep(Inconsistent, &a.clobbers[],\n                                    |s, co| {\n-                    try!(s.print_string(co.get(), ast::CookedStr));\n+                    try!(s.print_string(co.deref(), ast::CookedStr));\n                     Ok(())\n                 }));\n \n@@ -1954,7 +1955,7 @@ impl<'a> State<'a> {\n             let encoded = ident.encode_with_hygiene();\n             try!(word(&mut self.s, &encoded[]))\n         } else {\n-            try!(word(&mut self.s, token::get_ident(ident).get()))\n+            try!(word(&mut self.s, token::get_ident(ident).deref()))\n         }\n         self.ann.post(self, NodeIdent(&ident))\n     }\n@@ -1964,7 +1965,7 @@ impl<'a> State<'a> {\n     }\n \n     pub fn print_name(&mut self, name: ast::Name) -> IoResult<()> {\n-        try!(word(&mut self.s, token::get_name(name).get()));\n+        try!(word(&mut self.s, token::get_name(name).deref()));\n         self.ann.post(self, NodeName(&name))\n     }\n \n@@ -2532,15 +2533,15 @@ impl<'a> State<'a> {\n         try!(self.ibox(indent_unit));\n         match item.node {\n             ast::MetaWord(ref name) => {\n-                try!(word(&mut self.s, name.get()));\n+                try!(word(&mut self.s, name.deref()));\n             }\n             ast::MetaNameValue(ref name, ref value) => {\n-                try!(self.word_space(name.get()));\n+                try!(self.word_space(name.deref()));\n                 try!(self.word_space(\"=\"));\n                 try!(self.print_literal(value));\n             }\n             ast::MetaList(ref name, ref items) => {\n-                try!(word(&mut self.s, name.get()));\n+                try!(word(&mut self.s, name.deref()));\n                 try!(self.popen());\n                 try!(self.commasep(Consistent,\n                                    &items[],\n@@ -2731,7 +2732,7 @@ impl<'a> State<'a> {\n             _ => ()\n         }\n         match lit.node {\n-            ast::LitStr(ref st, style) => self.print_string(st.get(), style),\n+            ast::LitStr(ref st, style) => self.print_string(st.deref(), style),\n             ast::LitByte(byte) => {\n                 let mut res = String::from_str(\"b'\");\n                 ascii::escape_default(byte, |c| res.push(c as char));\n@@ -2772,10 +2773,10 @@ impl<'a> State<'a> {\n                 word(&mut self.s,\n                      &format!(\n                          \"{}{}\",\n-                         f.get(),\n+                         f.deref(),\n                          &ast_util::float_ty_to_string(t)[])[])\n             }\n-            ast::LitFloatUnsuffixed(ref f) => word(&mut self.s, f.get()),\n+            ast::LitFloatUnsuffixed(ref f) => word(&mut self.s, f.deref()),\n             ast::LitBool(val) => {\n                 if val { word(&mut self.s, \"true\") } else { word(&mut self.s, \"false\") }\n             }"}, {"sha": "14f8dc5aa3d32d10f5e209dca25c0e77a32ffc9a", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d58c0a75978e068af8b01ab578b743c52635e1f4/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d58c0a75978e068af8b01ab578b743c52635e1f4/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=d58c0a75978e068af8b01ab578b743c52635e1f4", "patch": "@@ -37,6 +37,8 @@ use {ast, ast_util};\n use ptr::P;\n use util::small_vector::SmallVector;\n \n+use std::ops::Deref;\n+\n enum ShouldFail {\n     No,\n     Yes(Option<InternedString>),\n@@ -512,7 +514,7 @@ fn mk_test_module(cx: &mut TestCtxt) -> (P<ast::Item>, Option<P<ast::Item>>) {\n     });\n     let reexport = cx.reexport_test_harness_main.as_ref().map(|s| {\n         // building `use <ident> = __test::main`\n-        let reexport_ident = token::str_to_ident(s.get());\n+        let reexport_ident = token::str_to_ident(s.deref());\n \n         let use_path =\n             nospan(ast::ViewPathSimple(reexport_ident,\n@@ -575,7 +577,7 @@ fn mk_tests(cx: &TestCtxt) -> P<ast::Item> {\n \n fn is_test_crate(krate: &ast::Crate) -> bool {\n     match attr::find_crate_name(&krate.attrs[]) {\n-        Some(ref s) if \"test\" == &s.get()[] => true,\n+        Some(ref s) if \"test\" == &s.deref()[] => true,\n         _ => false\n     }\n }"}]}