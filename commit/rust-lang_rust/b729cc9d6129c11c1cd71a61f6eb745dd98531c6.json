{"sha": "b729cc9d6129c11c1cd71a61f6eb745dd98531c6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI3MjljYzlkNjEyOWMxMWMxY2Q3MWE2MWY2ZWI3NDVkZDk4NTMxYzY=", "commit": {"author": {"name": "Oli Scherer", "email": "github35764891676564198441@oli-obk.de", "date": "2021-03-02T12:21:10Z"}, "committer": {"name": "Oli Scherer", "email": "github35764891676564198441@oli-obk.de", "date": "2021-03-12T12:23:50Z"}, "message": "Pull out ConstValue relating into its own function", "tree": {"sha": "37c3f045abc96b5f8c77a342a1ba66e58a341cfd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/37c3f045abc96b5f8c77a342a1ba66e58a341cfd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b729cc9d6129c11c1cd71a61f6eb745dd98531c6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b729cc9d6129c11c1cd71a61f6eb745dd98531c6", "html_url": "https://github.com/rust-lang/rust/commit/b729cc9d6129c11c1cd71a61f6eb745dd98531c6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b729cc9d6129c11c1cd71a61f6eb745dd98531c6/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5e8a89b2e5a036688d12eb6da4a1b97cadb6949f", "url": "https://api.github.com/repos/rust-lang/rust/commits/5e8a89b2e5a036688d12eb6da4a1b97cadb6949f", "html_url": "https://github.com/rust-lang/rust/commit/5e8a89b2e5a036688d12eb6da4a1b97cadb6949f"}], "stats": {"total": 97, "additions": 51, "deletions": 46}, "files": [{"sha": "436ca4c0578cb7c4a83768be19ed8d82f4e5a748", "filename": "compiler/rustc_middle/src/ty/relate.rs", "status": "modified", "additions": 51, "deletions": 46, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/b729cc9d6129c11c1cd71a61f6eb745dd98531c6/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b729cc9d6129c11c1cd71a61f6eb745dd98531c6/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs?ref=b729cc9d6129c11c1cd71a61f6eb745dd98531c6", "patch": "@@ -524,52 +524,7 @@ pub fn super_relate_consts<R: TypeRelation<'tcx>>(\n         (ty::ConstKind::Param(a_p), ty::ConstKind::Param(b_p)) => a_p.index == b_p.index,\n         (ty::ConstKind::Placeholder(p1), ty::ConstKind::Placeholder(p2)) => p1 == p2,\n         (ty::ConstKind::Value(a_val), ty::ConstKind::Value(b_val)) => {\n-            match (a_val, b_val) {\n-                (\n-                    ConstValue::Scalar(Scalar::Int(a_val)),\n-                    ConstValue::Scalar(Scalar::Int(b_val)),\n-                ) => a_val == b_val,\n-                (\n-                    ConstValue::Scalar(Scalar::Ptr(a_val)),\n-                    ConstValue::Scalar(Scalar::Ptr(b_val)),\n-                ) => {\n-                    a_val == b_val\n-                        || match (\n-                            tcx.global_alloc(a_val.alloc_id),\n-                            tcx.global_alloc(b_val.alloc_id),\n-                        ) {\n-                            (\n-                                GlobalAlloc::Function(a_instance),\n-                                GlobalAlloc::Function(b_instance),\n-                            ) => a_instance == b_instance,\n-                            _ => false,\n-                        }\n-                }\n-\n-                (ConstValue::Slice { .. }, ConstValue::Slice { .. }) => {\n-                    get_slice_bytes(&tcx, a_val) == get_slice_bytes(&tcx, b_val)\n-                }\n-\n-                (ConstValue::ByRef { .. }, ConstValue::ByRef { .. }) => {\n-                    let a_destructured = tcx.destructure_const(relation.param_env().and(a));\n-                    let b_destructured = tcx.destructure_const(relation.param_env().and(b));\n-\n-                    // Both the variant and each field have to be equal.\n-                    if a_destructured.variant == b_destructured.variant {\n-                        for (a_field, b_field) in\n-                            a_destructured.fields.iter().zip(b_destructured.fields.iter())\n-                        {\n-                            relation.consts(a_field, b_field)?;\n-                        }\n-\n-                        true\n-                    } else {\n-                        false\n-                    }\n-                }\n-\n-                _ => false,\n-            }\n+            check_const_value_eq(relation, a_val, b_val, a, b)?\n         }\n \n         (\n@@ -598,6 +553,56 @@ pub fn super_relate_consts<R: TypeRelation<'tcx>>(\n     if is_match { Ok(a) } else { Err(TypeError::ConstMismatch(expected_found(relation, a, b))) }\n }\n \n+fn check_const_value_eq<R: TypeRelation<'tcx>>(\n+    relation: &mut R,\n+    a_val: ConstValue<'tcx>,\n+    b_val: ConstValue<'tcx>,\n+    // FIXME(oli-obk): these arguments should go away with valtrees\n+    a: &'tcx ty::Const<'tcx>,\n+    b: &'tcx ty::Const<'tcx>,\n+    // FIXME(oli-obk): this should just be `bool` with valtrees\n+) -> RelateResult<'tcx, bool> {\n+    let tcx = relation.tcx();\n+    Ok(match (a_val, b_val) {\n+        (ConstValue::Scalar(Scalar::Int(a_val)), ConstValue::Scalar(Scalar::Int(b_val))) => {\n+            a_val == b_val\n+        }\n+        (ConstValue::Scalar(Scalar::Ptr(a_val)), ConstValue::Scalar(Scalar::Ptr(b_val))) => {\n+            a_val == b_val\n+                || match (tcx.global_alloc(a_val.alloc_id), tcx.global_alloc(b_val.alloc_id)) {\n+                    (GlobalAlloc::Function(a_instance), GlobalAlloc::Function(b_instance)) => {\n+                        a_instance == b_instance\n+                    }\n+                    _ => false,\n+                }\n+        }\n+\n+        (ConstValue::Slice { .. }, ConstValue::Slice { .. }) => {\n+            get_slice_bytes(&tcx, a_val) == get_slice_bytes(&tcx, b_val)\n+        }\n+\n+        (ConstValue::ByRef { .. }, ConstValue::ByRef { .. }) => {\n+            let a_destructured = tcx.destructure_const(relation.param_env().and(a));\n+            let b_destructured = tcx.destructure_const(relation.param_env().and(b));\n+\n+            // Both the variant and each field have to be equal.\n+            if a_destructured.variant == b_destructured.variant {\n+                for (a_field, b_field) in\n+                    a_destructured.fields.iter().zip(b_destructured.fields.iter())\n+                {\n+                    relation.consts(a_field, b_field)?;\n+                }\n+\n+                true\n+            } else {\n+                false\n+            }\n+        }\n+\n+        _ => false,\n+    })\n+}\n+\n impl<'tcx> Relate<'tcx> for &'tcx ty::List<ty::Binder<ty::ExistentialPredicate<'tcx>>> {\n     fn relate<R: TypeRelation<'tcx>>(\n         relation: &mut R,"}]}