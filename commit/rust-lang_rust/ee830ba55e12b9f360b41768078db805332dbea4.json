{"sha": "ee830ba55e12b9f360b41768078db805332dbea4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVlODMwYmE1NWUxMmI5ZjM2MGI0MTc2ODA3OGRiODA1MzMyZGJlYTQ=", "commit": {"author": {"name": "mcarton", "email": "cartonmartin+git@gmail.com", "date": "2016-02-09T15:45:47Z"}, "committer": {"name": "mcarton", "email": "cartonmartin+git@gmail.com", "date": "2016-02-12T13:30:26Z"}, "message": "Extend IF_SAME_THEN_ELSE to ifs sequences", "tree": {"sha": "77c21f3fa3f3ba6b818e0657417c8878c0dfbff3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/77c21f3fa3f3ba6b818e0657417c8878c0dfbff3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ee830ba55e12b9f360b41768078db805332dbea4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ee830ba55e12b9f360b41768078db805332dbea4", "html_url": "https://github.com/rust-lang/rust/commit/ee830ba55e12b9f360b41768078db805332dbea4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ee830ba55e12b9f360b41768078db805332dbea4/comments", "author": {"login": "mcarton", "id": 3751788, "node_id": "MDQ6VXNlcjM3NTE3ODg=", "avatar_url": "https://avatars.githubusercontent.com/u/3751788?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mcarton", "html_url": "https://github.com/mcarton", "followers_url": "https://api.github.com/users/mcarton/followers", "following_url": "https://api.github.com/users/mcarton/following{/other_user}", "gists_url": "https://api.github.com/users/mcarton/gists{/gist_id}", "starred_url": "https://api.github.com/users/mcarton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mcarton/subscriptions", "organizations_url": "https://api.github.com/users/mcarton/orgs", "repos_url": "https://api.github.com/users/mcarton/repos", "events_url": "https://api.github.com/users/mcarton/events{/privacy}", "received_events_url": "https://api.github.com/users/mcarton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mcarton", "id": 3751788, "node_id": "MDQ6VXNlcjM3NTE3ODg=", "avatar_url": "https://avatars.githubusercontent.com/u/3751788?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mcarton", "html_url": "https://github.com/mcarton", "followers_url": "https://api.github.com/users/mcarton/followers", "following_url": "https://api.github.com/users/mcarton/following{/other_user}", "gists_url": "https://api.github.com/users/mcarton/gists{/gist_id}", "starred_url": "https://api.github.com/users/mcarton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mcarton/subscriptions", "organizations_url": "https://api.github.com/users/mcarton/orgs", "repos_url": "https://api.github.com/users/mcarton/repos", "events_url": "https://api.github.com/users/mcarton/events{/privacy}", "received_events_url": "https://api.github.com/users/mcarton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "88beb351940e888932b30c555c273f18a0254aff", "url": "https://api.github.com/repos/rust-lang/rust/commits/88beb351940e888932b30c555c273f18a0254aff", "html_url": "https://github.com/rust-lang/rust/commit/88beb351940e888932b30c555c273f18a0254aff"}], "stats": {"total": 101, "additions": 67, "deletions": 34}, "files": [{"sha": "5f7e7a2a6432a5c8198f251be7a596f697274e63", "filename": "src/copies.rs", "status": "modified", "additions": 32, "deletions": 18, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/ee830ba55e12b9f360b41768078db805332dbea4/src%2Fcopies.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee830ba55e12b9f360b41768078db805332dbea4/src%2Fcopies.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcopies.rs?ref=ee830ba55e12b9f360b41768078db805332dbea4", "patch": "@@ -3,7 +3,7 @@ use rustc_front::hir::*;\n use std::collections::HashMap;\n use std::collections::hash_map::Entry;\n use utils::{SpanlessEq, SpanlessHash};\n-use utils::{get_parent_expr, in_macro, span_lint, span_note_and_lint};\n+use utils::{get_parent_expr, in_macro, span_note_and_lint};\n \n /// **What it does:** This lint checks for consecutive `ifs` with the same condition. This lint is\n /// `Warn` by default.\n@@ -56,26 +56,40 @@ impl LateLintPass for CopyAndPaste {\n             }\n \n             let (conds, blocks) = if_sequence(expr);\n-            lint_same_then_else(cx, expr);\n+            lint_same_then_else(cx, &blocks);\n             lint_same_cond(cx, &conds);\n         }\n     }\n }\n \n /// Implementation of `IF_SAME_THEN_ELSE`.\n-fn lint_same_then_else(cx: &LateContext, expr: &Expr) {\n-    if let ExprIf(_, ref then_block, Some(ref else_expr)) = expr.node {\n-        if let ExprBlock(ref else_block) = else_expr.node {\n-            if SpanlessEq::new(cx).eq_block(&then_block, &else_block) {\n-                span_lint(cx, IF_SAME_THEN_ELSE, expr.span, \"this if has the same then and else blocks\");\n-            }\n-        }\n+fn lint_same_then_else(cx: &LateContext, blocks: &[&Block]) {\n+    let hash = |block| -> u64 {\n+        let mut h = SpanlessHash::new(cx);\n+        h.hash_block(block);\n+        h.finish()\n+    };\n+    let eq = |lhs, rhs| -> bool {\n+        SpanlessEq::new(cx).eq_block(lhs, rhs)\n+    };\n+\n+    if let Some((i, j)) = search_same(blocks, hash, eq) {\n+        span_note_and_lint(cx, IF_SAME_THEN_ELSE, j.span, \"this if has identical blocks\", i.span, \"same as this\");\n     }\n }\n \n /// Implementation of `IFS_SAME_COND`.\n fn lint_same_cond(cx: &LateContext, conds: &[&Expr]) {\n-    if let Some((i, j)) = search_same(cx, conds) {\n+    let hash = |expr| -> u64 {\n+        let mut h = SpanlessHash::new(cx);\n+        h.hash_expr(expr);\n+        h.finish()\n+    };\n+    let eq = |lhs, rhs| -> bool {\n+        SpanlessEq::new(cx).ignore_fn().eq_expr(lhs, rhs)\n+    };\n+\n+    if let Some((i, j)) = search_same(conds, hash, eq) {\n         span_note_and_lint(cx, IFS_SAME_COND, j.span, \"this if has the same condition as a previous if\", i.span, \"same as this\");\n     }\n }\n@@ -109,13 +123,17 @@ fn if_sequence(mut expr: &Expr) -> (Vec<&Expr>, Vec<&Block>) {\n     (conds, blocks)\n }\n \n-fn search_same<'a>(cx: &LateContext, exprs: &[&'a Expr]) -> Option<(&'a Expr, &'a Expr)> {\n+fn search_same<'a, T, Hash, Eq>(exprs: &[&'a T],\n+                                hash: Hash,\n+                                eq: Eq) -> Option<(&'a T, &'a T)>\n+where Hash: Fn(&'a T) -> u64,\n+      Eq: Fn(&'a T, &'a T) -> bool {\n     // common cases\n     if exprs.len() < 2 {\n         return None;\n     }\n     else if exprs.len() == 2 {\n-        return if SpanlessEq::new(cx).ignore_fn().eq_expr(&exprs[0], &exprs[1]) {\n+        return if eq(&exprs[0], &exprs[1]) {\n             Some((&exprs[0], &exprs[1]))\n         }\n         else {\n@@ -126,14 +144,10 @@ fn search_same<'a>(cx: &LateContext, exprs: &[&'a Expr]) -> Option<(&'a Expr, &'\n     let mut map : HashMap<_, Vec<&'a _>> = HashMap::with_capacity(exprs.len());\n \n     for &expr in exprs {\n-        let mut h = SpanlessHash::new(cx);\n-        h.hash_expr(expr);\n-        let h = h.finish();\n-\n-        match map.entry(h) {\n+        match map.entry(hash(expr)) {\n             Entry::Occupied(o) => {\n                 for o in o.get() {\n-                    if SpanlessEq::new(cx).ignore_fn().eq_expr(o, expr) {\n+                    if eq(o, expr) {\n                         return Some((o, expr))\n                     }\n                 }"}, {"sha": "c982510b3c363285d00ccb113714a5641e4bb89d", "filename": "src/utils/hir.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ee830ba55e12b9f360b41768078db805332dbea4/src%2Futils%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee830ba55e12b9f360b41768078db805332dbea4/src%2Futils%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils%2Fhir.rs?ref=ee830ba55e12b9f360b41768078db805332dbea4", "patch": "@@ -246,6 +246,10 @@ fn over<X, F>(left: &[X], right: &[X], mut eq_fn: F) -> bool\n }\n \n \n+/// Type used to hash an ast element. This is different from the `Hash` trait on ast types as this\n+/// trait would consider IDs and spans.\n+///\n+/// All expressions kind are hashed, but some might have a weaker hash.\n pub struct SpanlessHash<'a, 'tcx: 'a> {\n     /// Context used to evaluate constant expressions.\n     cx: &'a LateContext<'a, 'tcx>,"}, {"sha": "f465141248afc5777145390ac906218bcdf71288", "filename": "tests/compile-fail/copies.rs", "status": "modified", "additions": 31, "deletions": 16, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/ee830ba55e12b9f360b41768078db805332dbea4/tests%2Fcompile-fail%2Fcopies.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee830ba55e12b9f360b41768078db805332dbea4/tests%2Fcompile-fail%2Fcopies.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fcopies.rs?ref=ee830ba55e12b9f360b41768078db805332dbea4", "patch": "@@ -5,16 +5,15 @@\n #![allow(let_and_return)]\n #![allow(needless_return)]\n #![allow(unused_variables)]\n-#![deny(if_same_then_else)]\n-#![deny(ifs_same_cond)]\n \n fn foo() -> bool { unimplemented!() }\n \n+#[deny(if_same_then_else)]\n fn if_same_then_else() -> &'static str {\n-    if true { //~ERROR this if has the same then and else blocks\n+    if true {\n         foo();\n     }\n-    else {\n+    else { //~ERROR this if has identical blocks\n         foo();\n     }\n \n@@ -26,11 +25,11 @@ fn if_same_then_else() -> &'static str {\n         foo();\n     }\n \n-    let _ = if true { //~ERROR this if has the same then and else blocks\n+    let _ = if true {\n         foo();\n         42\n     }\n-    else {\n+    else { //~ERROR this if has identical blocks\n         foo();\n         42\n     };\n@@ -39,14 +38,14 @@ fn if_same_then_else() -> &'static str {\n         foo();\n     }\n \n-    let _ = if true { //~ERROR this if has the same then and else blocks\n+    let _ = if true {\n         42\n     }\n-    else {\n+    else { //~ERROR this if has identical blocks\n         42\n     };\n \n-    if true { //~ERROR this if has the same then and else blocks\n+    if true {\n         let bar = if true {\n             42\n         }\n@@ -57,7 +56,7 @@ fn if_same_then_else() -> &'static str {\n         while foo() { break; }\n         bar + 1;\n     }\n-    else {\n+    else { //~ERROR this if has identical blocks\n         let bar = if true {\n             42\n         }\n@@ -69,15 +68,18 @@ fn if_same_then_else() -> &'static str {\n         bar + 1;\n     }\n \n-    if true { //~ERROR this if has the same then and else blocks\n+    if true {\n         match 42 {\n             42 => (),\n             a if a > 0 => (),\n             10...15 => (),\n             _ => (),\n         }\n     }\n-    else {\n+    else if false {\n+        foo();\n+    }\n+    else if foo() { //~ERROR this if has identical blocks\n         match 42 {\n             42 => (),\n             a if a > 0 => (),\n@@ -86,23 +88,36 @@ fn if_same_then_else() -> &'static str {\n         }\n     }\n \n-    if true { //~ERROR this if has the same then and else blocks\n+    if true {\n+        if let Some(a) = Some(42) {}\n+    }\n+    else { //~ERROR this if has identical blocks\n+        if let Some(a) = Some(42) {}\n+    }\n+\n+    if true {\n         if let Some(a) = Some(42) {}\n     }\n     else {\n-        if let Some(a) = Some(42) {}\n+        if let Some(a) = Some(43) {}\n     }\n \n-    if true { //~ERROR this if has the same then and else blocks\n+    if true {\n         let foo = \"\";\n         return &foo[0..];\n     }\n-    else {\n+    else if false {\n+        let foo = \"bar\";\n+        return &foo[0..];\n+    }\n+    else { //~ERROR this if has identical blocks\n         let foo = \"\";\n         return &foo[0..];\n     }\n }\n \n+#[deny(ifs_same_cond)]\n+#[allow(if_same_then_else)] // all empty blocks\n fn ifs_same_cond() {\n     let a = 0;\n     let b = false;"}]}