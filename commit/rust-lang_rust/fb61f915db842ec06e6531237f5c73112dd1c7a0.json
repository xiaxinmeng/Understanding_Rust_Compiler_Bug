{"sha": "fb61f915db842ec06e6531237f5c73112dd1c7a0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZiNjFmOTE1ZGI4NDJlYzA2ZTY1MzEyMzdmNWM3MzExMmRkMWM3YTA=", "commit": {"author": {"name": "Simon BD", "email": "simon@server", "date": "2012-10-25T00:15:11Z"}, "committer": {"name": "Simon BD", "email": "simon@server", "date": "2012-10-25T00:15:11Z"}, "message": "Add copy bound to sort", "tree": {"sha": "f94f5857977cfa1c43e97c7efa80b748ac899460", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f94f5857977cfa1c43e97c7efa80b748ac899460"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fb61f915db842ec06e6531237f5c73112dd1c7a0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fb61f915db842ec06e6531237f5c73112dd1c7a0", "html_url": "https://github.com/rust-lang/rust/commit/fb61f915db842ec06e6531237f5c73112dd1c7a0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fb61f915db842ec06e6531237f5c73112dd1c7a0/comments", "author": {"login": "14427", "id": 2423611, "node_id": "MDQ6VXNlcjI0MjM2MTE=", "avatar_url": "https://avatars.githubusercontent.com/u/2423611?v=4", "gravatar_id": "", "url": "https://api.github.com/users/14427", "html_url": "https://github.com/14427", "followers_url": "https://api.github.com/users/14427/followers", "following_url": "https://api.github.com/users/14427/following{/other_user}", "gists_url": "https://api.github.com/users/14427/gists{/gist_id}", "starred_url": "https://api.github.com/users/14427/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/14427/subscriptions", "organizations_url": "https://api.github.com/users/14427/orgs", "repos_url": "https://api.github.com/users/14427/repos", "events_url": "https://api.github.com/users/14427/events{/privacy}", "received_events_url": "https://api.github.com/users/14427/received_events", "type": "User", "site_admin": false}, "committer": {"login": "14427", "id": 2423611, "node_id": "MDQ6VXNlcjI0MjM2MTE=", "avatar_url": "https://avatars.githubusercontent.com/u/2423611?v=4", "gravatar_id": "", "url": "https://api.github.com/users/14427", "html_url": "https://github.com/14427", "followers_url": "https://api.github.com/users/14427/followers", "following_url": "https://api.github.com/users/14427/following{/other_user}", "gists_url": "https://api.github.com/users/14427/gists{/gist_id}", "starred_url": "https://api.github.com/users/14427/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/14427/subscriptions", "organizations_url": "https://api.github.com/users/14427/orgs", "repos_url": "https://api.github.com/users/14427/repos", "events_url": "https://api.github.com/users/14427/events{/privacy}", "received_events_url": "https://api.github.com/users/14427/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e0a9d41b04f16b7771315dcbfcb4e1fa4c347c33", "url": "https://api.github.com/repos/rust-lang/rust/commits/e0a9d41b04f16b7771315dcbfcb4e1fa4c347c33", "html_url": "https://github.com/rust-lang/rust/commit/e0a9d41b04f16b7771315dcbfcb4e1fa4c347c33"}], "stats": {"total": 156, "additions": 52, "deletions": 104}, "files": [{"sha": "24086057393073120b3a3b19b5b503cab7019919", "filename": "src/libstd/sort.rs", "status": "modified", "additions": 52, "deletions": 104, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/fb61f915db842ec06e6531237f5c73112dd1c7a0/src%2Flibstd%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb61f915db842ec06e6531237f5c73112dd1c7a0/src%2Flibstd%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsort.rs?ref=fb61f915db842ec06e6531237f5c73112dd1c7a0", "patch": "@@ -166,7 +166,7 @@ const MIN_MERGE: uint = 64;\n const MIN_GALLOP: uint = 7;\n const INITIAL_TMP_STORAGE: uint = 128;\n \n-pub fn tim_sort<T: Ord>(array: &[mut T]) {\n+pub fn tim_sort<T: Copy Ord>(array: &[mut T]) {\n     let size = array.len();\n     if size < 2 {\n         return;\n@@ -210,7 +210,7 @@ pub fn tim_sort<T: Ord>(array: &[mut T]) {\n fn reverse_slice<T>(v: &[mut T], start: uint, end:uint) {\n     let mut i = start;\n     while i < end / 2 {\n-        v[i] <-> v[end - i - 1];\n+        util::swap(&mut v[i], &mut v[end - i - 1]);\n         i += 1;\n     }\n }\n@@ -226,7 +226,7 @@ pure fn min_run_length(n: uint) -> uint {\n     return n + r;\n }\n \n-fn count_run_ascending<T: Ord>(array: &[mut T]) -> uint {\n+fn count_run_ascending<T: Copy Ord>(array: &[mut T]) -> uint {\n     let size = array.len();\n     assert size > 0;\n     if size == 1 { return 1; }\n@@ -246,7 +246,7 @@ fn count_run_ascending<T: Ord>(array: &[mut T]) -> uint {\n     return run;\n }\n \n-pure fn gallop_left<T: Ord>(key: &const T, array: &[const T],\n+pure fn gallop_left<T: Copy Ord>(key: &const T, array: &[const T],\n                             hint: uint) -> uint {\n     let size = array.len();\n     assert size != 0 && hint < size;\n@@ -295,7 +295,7 @@ pure fn gallop_left<T: Ord>(key: &const T, array: &[const T],\n     return ofs;\n }\n \n-pure fn gallop_right<T: Ord>(key: &const T, array: &[const T],\n+pure fn gallop_right<T: Copy Ord>(key: &const T, array: &[const T],\n                             hint: uint) -> uint {\n     let size = array.len();\n     assert size != 0 && hint < size;\n@@ -353,15 +353,15 @@ struct RunState {\n \n struct MergeState<T> {\n     mut min_gallop: uint,\n-    mut tmp: ~[T],\n+    //mut tmp: ~[T],\n     mut last_hi: bool,\n     mut last_bsort: bool,\n     mut mergePt: uint,\n     mut tmpPt: uint,\n     mut array: &[mut T],\n     runs: DVec<RunState>,\n \n-    drop {\n+    /*drop {\n         unsafe {\n             let size = self.tmp.len();\n             // Move tmp back into invalid part of array\n@@ -376,15 +376,15 @@ struct MergeState<T> {\n             }\n             vec::raw::set_len(&mut self.tmp, 0);\n         }\n-    }\n+    }*/\n }\n \n fn MergeState<T>() -> MergeState<T> {\n-    let mut tmp = ~[];\n-    vec::reserve(&mut tmp, INITIAL_TMP_STORAGE);\n+    //let mut tmp = ~[];\n+    //vec::reserve(&mut tmp, INITIAL_TMP_STORAGE);\n     MergeState {\n         min_gallop: MIN_GALLOP,\n-        tmp: move tmp,\n+        //tmp: move tmp,\n         last_hi: false,\n         last_bsort: false,\n         mergePt: 0,\n@@ -394,7 +394,7 @@ fn MergeState<T>() -> MergeState<T> {\n     }\n }\n \n-impl<T: Ord> MergeState<T> {\n+impl<T: Copy Ord> MergeState<T> {\n     fn binarysort(&self, array: &[mut T], start: uint) {\n         let size = array.len();\n         let mut start = start;\n@@ -403,19 +403,16 @@ impl<T: Ord> MergeState<T> {\n         if start == 0 { start += 1; }\n \n         self.last_bsort = true;\n-        unsafe { vec::raw::set_len(&mut self.tmp, 1); };\n \n         while start < size {\n-            unsafe {\n-                move_vec(self.tmp, 0, array, start, 1);\n-            }\n+            let pivot = array[start];\n             let mut left = 0;\n             let mut right = start;\n             assert left <= right;\n \n             while left < right {\n                 let mid = (left + right) >> 1;\n-                if self.tmp[0] < array[mid] {\n+                if pivot < array[mid] {\n                     right = mid;\n                 } else {\n                     left = mid+1;\n@@ -424,14 +421,10 @@ impl<T: Ord> MergeState<T> {\n             assert left == right;\n             let mut n = start-left;\n \n-            unsafe {\n-                move_vec(array, left+1, array, left, n);\n-            }\n-            array[left] <-> self.tmp[0];\n+            copy_vec(array, left+1, array, left, n);\n+            array[left] = move pivot;\n             start += 1;\n         }\n-        // Forget the boxed element\n-        unsafe { vec::raw::set_len(&mut self.tmp, 0); }\n         self.last_bsort = false;\n     }\n \n@@ -488,13 +481,9 @@ impl<T: Ord> MergeState<T> {\n                 base2: uint, len2: uint) {\n         assert len1 != 0 && len2 != 0 && base1+len1 == base2;\n \n-        vec::reserve(&mut self.tmp, len1);\n+        //vec::reserve(&mut self.tmp, len1);\n         self.last_hi = false;\n-\n-        unsafe {\n-            vec::raw::set_len(&mut self.tmp, len1);\n-            move_vec(self.tmp, 0, array, base1, len1);\n-        }\n+        let tmp = vec::to_mut(vec::slice(array, base1, base1+len1));\n         self.tmpPt = 0;\n         self.mergePt = base1;\n \n@@ -509,18 +498,12 @@ impl<T: Ord> MergeState<T> {\n         self.mergePt += 1;\n \n         if len2 == 0 {\n-            unsafe {\n-                move_vec(array, dest, self.tmp, 0, len1);\n-                vec::raw::set_len(&mut self.tmp, 0); // Forget the elements\n-            }\n+            copy_vec(array, dest, tmp, 0, len1);\n             return;\n         }\n         if len1 == 1 {\n-            unsafe {\n-                move_vec(array, dest, array, c2, len2);\n-                array[dest+len2] <-> self.tmp[c1];\n-                vec::raw::set_len(&mut self.tmp, 0); // Forget the element\n-            }\n+            copy_vec(array, dest, array, c2, len2);\n+            array[dest+len2] <-> tmp[c1];\n             return;\n         }\n \n@@ -532,7 +515,7 @@ impl<T: Ord> MergeState<T> {\n \n             loop {\n                 assert len1 > 1 && len2 != 0;\n-                if array[c2] < self.tmp[c1] {\n+                if array[c2] < tmp[c1] {\n                     array[dest] <-> array[c2];\n                     dest += 1; c2 += 1; len2 -= 1;\n                     self.mergePt += 1;\n@@ -541,7 +524,7 @@ impl<T: Ord> MergeState<T> {\n                         break_outer = true;\n                     }\n                 } else {\n-                    array[dest] <-> self.tmp[c1];\n+                    array[dest] <-> tmp[c1];\n                     dest += 1; c1 += 1; len1 -= 1;\n                     self.mergePt += 1;\n                     self.tmpPt += 1;\n@@ -560,13 +543,11 @@ impl<T: Ord> MergeState<T> {\n             loop {\n                 assert len1 > 1 && len2 != 0;\n \n-                //let tmp_view = vec::const_view(self.tmp, c1, c1+len1);\n+                //let tmp_view = vec::const_view(tmp, c1, c1+len1);\n                 count1 = gallop_right(&const array[c2],\n-                    vec::const_view(self.tmp, c1, c1+len1), 0);\n+                    vec::const_view(tmp, c1, c1+len1), 0);\n                 if count1 != 0 {\n-                    unsafe {\n-                        move_vec(array, dest, self.tmp, c1, count1);\n-                    }\n+                    copy_vec(array, dest, tmp, c1, count1);\n                     dest += count1; c1 += count1; len1 -= count1;\n                     self.mergePt += count1; self.tmpPt += count1;\n                     if len1 <= 1 { break_outer = true; break; }\n@@ -577,16 +558,14 @@ impl<T: Ord> MergeState<T> {\n                 if len2 == 0 { break_outer = true; break; }\n \n                 let tmp_view = vec::const_view(array, c2, c2+len2);\n-                count2 = gallop_left(&const self.tmp[c1], tmp_view, 0);\n+                count2 = gallop_left(&const tmp[c1], tmp_view, 0);\n                 if count2 != 0 {\n-                    unsafe {\n-                        move_vec(array, dest, array, c2, count2);\n-                    }\n+                    copy_vec(array, dest, array, c2, count2);\n                     dest += count2; c2 += count2; len2 -= count2;\n                     self.mergePt += count2;\n                     if len2 == 0 { break_outer = true; break; }\n                 }\n-                array[dest] <-> self.tmp[c1];\n+                array[dest] <-> tmp[c1];\n                 dest += 1; c1 += 1; len1 -= 1;\n                 self.mergePt += 1; self.tmpPt += 1;\n                 if len1 == 1 { break_outer = true; break; }\n@@ -603,34 +582,25 @@ impl<T: Ord> MergeState<T> {\n \n         if len1 == 1 {\n             assert len2 > 0;\n-            unsafe {\n-                move_vec(array, dest, array, c2, len2);\n-            }\n-            array[dest+len2] <-> self.tmp[c1];\n+            copy_vec(array, dest, array, c2, len2);\n+            array[dest+len2] <-> tmp[c1];\n         } else if len1 == 0 {\n             fail ~\"Comparison violates its contract!\";\n         } else {\n             assert len2 == 0;\n             assert len1 > 1;\n-            unsafe {\n-                move_vec(array, dest, self.tmp, c1, len1);\n-            }\n+            copy_vec(array, dest, tmp, c1, len1);\n         }\n         self.tmpPt = 0;\n-        unsafe { vec::raw::set_len(&mut self.tmp, 0); }\n     }\n \n     fn merge_hi(&self, array: &[mut T], base1: uint, len1: uint,\n                 base2: uint, len2: uint) {\n         assert len1 != 1 && len2 != 0 && base1 + len1 == base2;\n \n-        vec::reserve(&mut self.tmp, len2);\n         self.last_hi = true;\n \n-        unsafe {\n-            vec::raw::set_len(&mut self.tmp, len2);\n-            move_vec(self.tmp, 0, array, base2, len2);\n-        }\n+        let tmp = vec::to_mut(vec::slice(array, base2, base2+len2));\n \n         let mut c1 = base1 + len1 - 1;\n         let mut c2 = len2 - 1;\n@@ -645,20 +615,14 @@ impl<T: Ord> MergeState<T> {\n         dest -= 1; c1 -= 1; len1 -= 1;\n \n         if len1 == 0 {\n-            unsafe {\n-                move_vec(array, dest-(len2-1), self.tmp, 0, len2);\n-                vec::raw::set_len(&mut self.tmp, 0); // Forget the elements\n-            }\n+            copy_vec(array, dest-(len2-1), tmp, 0, len2);\n             return;\n         }\n         if len2 == 1 {\n             dest -= len1;\n             c1 -= len1;\n-            unsafe {\n-                move_vec(array, dest+1, array, c1+1, len1);\n-                array[dest] <-> self.tmp[c2];\n-                vec::raw::set_len(&mut self.tmp, 0); // Forget the element\n-            }\n+            copy_vec(array, dest+1, array, c1+1, len1);\n+            array[dest] <-> tmp[c2];\n             return;\n         }\n \n@@ -670,7 +634,7 @@ impl<T: Ord> MergeState<T> {\n \n             loop {\n                 assert len1 != 0 && len2 > 1;\n-                if self.tmp[c2] < array[c1] {\n+                if tmp[c2] < array[c1] {\n                     array[dest] <-> array[c1];\n                     dest -= 1; c1 -= 1; len1 -= 1;\n                     self.mergePt -= 1;\n@@ -679,7 +643,7 @@ impl<T: Ord> MergeState<T> {\n                         break_outer = true;\n                     }\n                 } else {\n-                    array[dest] <-> self.tmp[c2];\n+                    array[dest] <-> tmp[c2];\n                     dest -= 1; c2 -= 1; len2 -= 1;\n                     self.mergePt -= 1; self.tmpPt -= 1;\n                     count2 += 1; count1 = 0;\n@@ -699,31 +663,27 @@ impl<T: Ord> MergeState<T> {\n \n                 let tmp_view = vec::mut_view(array, base1, base1+len1);\n                 count1 = len1 - gallop_right(\n-                    &const self.tmp[c2], tmp_view, len1-1);\n+                    &const tmp[c2], tmp_view, len1-1);\n \n                 if count1 != 0 {\n                     dest -= count1; c1 -= count1; len1 -= count1;\n                     self.mergePt -= count1;\n-                    unsafe {\n-                        move_vec(array, dest+1, array, c1+1, count1);\n-                    }\n+                    copy_vec(array, dest+1, array, c1+1, count1);\n                     if len1 == 0 { break_outer = true; break; }\n                 }\n \n-                array[dest] <-> self.tmp[c2];\n+                array[dest] <-> tmp[c2];\n                 dest -= 1; c2 -= 1; len2 -= 1;\n                 self.mergePt -= 1; self.tmpPt -= 1;\n                 if len2 == 1 { break_outer = true; break; }\n \n-                //let tmp_view = vec::mut_view(self.tmp, 0, len2);\n+                //let tmp_view = vec::mut_view(tmp, 0, len2);\n                 let count2 = len2 - gallop_left(&const array[c1],\n-                            vec::mut_view(self.tmp, 0, len2), len2-1);\n+                            vec::mut_view(tmp, 0, len2), len2-1);\n                 if count2 != 0 {\n                     dest -= count2; c2 -= count2; len2 -= count2;\n                     self.mergePt -= count2; self.tmpPt -= count2;\n-                    unsafe {\n-                        move_vec(array, dest+1, self.tmp, c2+1, count2);\n-                    }\n+                    copy_vec(array, dest+1, tmp, c2+1, count2);\n                     if len2 <= 1 { break_outer = true; break; }\n                 }\n                 array[dest] <-> array[c1];\n@@ -746,21 +706,16 @@ impl<T: Ord> MergeState<T> {\n             assert len1 > 0;\n             dest -= len1;\n             c1 -= len1;\n-            unsafe {\n-                move_vec(array, dest+1, array, c1+1, len1);\n-            }\n-            array[dest] <-> self.tmp[c2];\n+            copy_vec(array, dest+1, array, c1+1, len1);\n+            array[dest] <-> tmp[c2];\n         } else if len2 == 0 {\n             fail ~\"Comparison violates its contract!\";\n         } else {\n             assert len1 == 0;\n             assert len2 != 0;\n-            unsafe {\n-                move_vec(array, dest-(len2-1), self.tmp, 0, len2);\n-            }\n+            copy_vec(array, dest-(len2-1), tmp, 0, len2);\n         }\n         self.tmpPt = 0;\n-        unsafe { vec::raw::set_len(&mut self.tmp, 0); }\n     }\n \n     fn merge_collapse(&self, array: &[mut T]) {\n@@ -796,21 +751,14 @@ impl<T: Ord> MergeState<T> {\n     }\n }\n \n-// Moves elements to from dest to from\n-// Unsafe as it makes the from parameter invalid between s2 and s2+len\n #[inline(always)]\n-unsafe fn move_vec<T>(dest: &[mut T], s1: uint,\n+fn copy_vec<T: Copy>(dest: &[mut T], s1: uint,\n                     from: &[const T], s2: uint, len: uint) {\n     assert s1+len <= dest.len() && s2+len <= from.len();\n-\n-    do vec::as_mut_buf(dest) |p, _len| {\n-        let destPtr = ptr::mut_offset(p, s1);\n-\n-        do vec::as_const_buf(from) |p, _len| {\n-            let fromPtr = ptr::const_offset(p, s2);\n-\n-            ptr::memmove(destPtr, fromPtr, len);\n-        }\n+    \n+    let slice = vec::slice(from, s2, s2+len);\n+    for slice.eachi |i, v| {\n+        dest[s1+i] = *v;\n     }\n }\n "}]}