{"sha": "8e79fc72cb51246c397c2776fcede5401dcd3859", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhlNzlmYzcyY2I1MTI0NmMzOTdjMjc3NmZjZWRlNTQwMWRjZDM4NTk=", "commit": {"author": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2017-07-03T15:25:03Z"}, "committer": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2017-08-16T13:52:45Z"}, "message": "Move borrowck error msg construction to module in `rustc_mir` (for later reuse by mir borrowck).\n\npost-rebase: Do not put \"(Ast)\" suffix in error msg unless passed `-Z borrowck-mir`.\n(But unconditionally include \"(Mir)\" suffix for mir-borrowck errors.)", "tree": {"sha": "0dd83e4ef057eb9623748bb610a8d8b3f1c30fbf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0dd83e4ef057eb9623748bb610a8d8b3f1c30fbf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8e79fc72cb51246c397c2776fcede5401dcd3859", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8e79fc72cb51246c397c2776fcede5401dcd3859", "html_url": "https://github.com/rust-lang/rust/commit/8e79fc72cb51246c397c2776fcede5401dcd3859", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8e79fc72cb51246c397c2776fcede5401dcd3859/comments", "author": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4fc3765c5477f98cfdf325475b2b01c6c094ed2d", "url": "https://api.github.com/repos/rust-lang/rust/commits/4fc3765c5477f98cfdf325475b2b01c6c094ed2d", "html_url": "https://github.com/rust-lang/rust/commit/4fc3765c5477f98cfdf325475b2b01c6c094ed2d"}], "stats": {"total": 1399, "additions": 800, "deletions": 599}, "files": [{"sha": "b5db5ce36133f33978aad38301c783b63ff8bbab", "filename": "src/Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8e79fc72cb51246c397c2776fcede5401dcd3859/src%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/8e79fc72cb51246c397c2776fcede5401dcd3859/src%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.lock?ref=8e79fc72cb51246c397c2776fcede5401dcd3859", "patch": "@@ -1452,6 +1452,7 @@ dependencies = [\n  \"rustc_const_eval 0.0.0\",\n  \"rustc_const_math 0.0.0\",\n  \"rustc_data_structures 0.0.0\",\n+ \"rustc_errors 0.0.0\",\n  \"syntax 0.0.0\",\n  \"syntax_pos 0.0.0\",\n ]"}, {"sha": "4058f3198afb4f52e8430c63fa07abf037324338", "filename": "src/librustc_borrowck/borrowck/check_loans.rs", "status": "modified", "additions": 22, "deletions": 37, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/8e79fc72cb51246c397c2776fcede5401dcd3859/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e79fc72cb51246c397c2776fcede5401dcd3859/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=8e79fc72cb51246c397c2776fcede5401dcd3859", "patch": "@@ -29,6 +29,7 @@ use rustc::ty::{self, TyCtxt};\n use syntax::ast;\n use syntax_pos::Span;\n use rustc::hir;\n+use rustc_mir::util::borrowck_errors::{BorrowckErrors, Origin};\n \n use std::rc::Rc;\n \n@@ -465,10 +466,8 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n \n             let mut err = match (new_loan.kind, old_loan.kind) {\n                 (ty::MutBorrow, ty::MutBorrow) => {\n-                    let mut err = struct_span_err!(self.bccx, new_loan.span, E0499,\n-                                                      \"cannot borrow `{}`{} as mutable \\\n-                                                      more than once at a time\",\n-                                                      nl, new_loan_msg);\n+                    let mut err = self.bccx.cannot_mutably_borrow_multiply(\n+                        new_loan.span, &nl, &new_loan_msg, Origin::Ast);\n \n                     if new_loan.span == old_loan.span {\n                         // Both borrows are happening in the same place\n@@ -496,10 +495,8 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                 }\n \n                 (ty::UniqueImmBorrow, ty::UniqueImmBorrow) => {\n-                    let mut err = struct_span_err!(self.bccx, new_loan.span, E0524,\n-                                     \"two closures require unique access to `{}` \\\n-                                      at the same time\",\n-                                     nl);\n+                    let mut err = self.bccx.cannot_uniquely_borrow_by_two_closures(\n+                        new_loan.span, &nl, Origin::Ast);\n                     err.span_label(\n                             old_loan.span,\n                             \"first closure is constructed here\");\n@@ -513,10 +510,8 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                 }\n \n                 (ty::UniqueImmBorrow, _) => {\n-                    let mut err = struct_span_err!(self.bccx, new_loan.span, E0500,\n-                                                   \"closure requires unique access to `{}` \\\n-                                                   but {} is already borrowed{}\",\n-                                                   nl, ol_pronoun, old_loan_msg);\n+                    let mut err = self.bccx.cannot_uniquely_borrow_by_one_closure(\n+                        new_loan.span, &nl, &ol_pronoun, &old_loan_msg, Origin::Ast);\n                     err.span_label(\n                             new_loan.span,\n                             format!(\"closure construction occurs here{}\", new_loan_msg));\n@@ -530,10 +525,9 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                 }\n \n                 (_, ty::UniqueImmBorrow) => {\n-                    let mut err = struct_span_err!(self.bccx, new_loan.span, E0501,\n-                                                   \"cannot borrow `{}`{} as {} because \\\n-                                                   previous closure requires unique access\",\n-                                                   nl, new_loan_msg, new_loan.kind.to_user_str());\n+                    let new_loan_str = &new_loan.kind.to_user_str();\n+                    let mut err = self.bccx.cannot_reborrow_already_uniquely_borrowed(\n+                        new_loan.span, &nl, &new_loan_msg, new_loan_str, Origin::Ast);\n                     err.span_label(\n                             new_loan.span,\n                             format!(\"borrow occurs here{}\", new_loan_msg));\n@@ -547,15 +541,10 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                 }\n \n                 (..) => {\n-                    let mut err = struct_span_err!(self.bccx, new_loan.span, E0502,\n-                                                   \"cannot borrow `{}`{} as {} because \\\n-                                                   {} is also borrowed as {}{}\",\n-                                                   nl,\n-                                                   new_loan_msg,\n-                                                   new_loan.kind.to_user_str(),\n-                                                   ol_pronoun,\n-                                                   old_loan.kind.to_user_str(),\n-                                                   old_loan_msg);\n+                    let mut err = self.bccx.cannot_reborrow_already_borrowed(\n+                        new_loan.span,\n+                        &nl, &new_loan_msg, &new_loan.kind.to_user_str(),\n+                        &ol_pronoun, &old_loan.kind.to_user_str(), &old_loan_msg, Origin::Ast);\n                     err.span_label(\n                             new_loan.span,\n                             format!(\"{} borrow occurs here{}\",\n@@ -645,9 +634,8 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n         match self.analyze_restrictions_on_use(id, copy_path, ty::ImmBorrow) {\n             UseOk => { }\n             UseWhileBorrowed(loan_path, loan_span) => {\n-                struct_span_err!(self.bccx, span, E0503,\n-                                 \"cannot use `{}` because it was mutably borrowed\",\n-                                 &self.bccx.loan_path_to_string(copy_path))\n+                let desc = self.bccx.loan_path_to_string(copy_path);\n+                self.bccx.cannot_use_when_mutably_borrowed(span, &desc, Origin::Ast)\n                     .span_label(loan_span,\n                                format!(\"borrow of `{}` occurs here\",\n                                        &self.bccx.loan_path_to_string(&loan_path))\n@@ -673,9 +661,8 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n             UseWhileBorrowed(loan_path, loan_span) => {\n                 let mut err = match move_kind {\n                     move_data::Captured => {\n-                        let mut err = struct_span_err!(self.bccx, span, E0504,\n-                                         \"cannot move `{}` into closure because it is borrowed\",\n-                                         &self.bccx.loan_path_to_string(move_path));\n+                        let mut err = self.bccx.cannot_move_into_closure(\n+                            span, &self.bccx.loan_path_to_string(move_path), Origin::Ast);\n                         err.span_label(\n                             loan_span,\n                             format!(\"borrow of `{}` occurs here\",\n@@ -690,9 +677,8 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                     move_data::Declared |\n                     move_data::MoveExpr |\n                     move_data::MovePat => {\n-                        let mut err = struct_span_err!(self.bccx, span, E0505,\n-                                         \"cannot move out of `{}` because it is borrowed\",\n-                                         &self.bccx.loan_path_to_string(move_path));\n+                        let desc = self.bccx.loan_path_to_string(move_path);\n+                        let mut err = self.bccx.cannot_move_when_borrowed(span, &desc, Origin::Ast);\n                         err.span_label(\n                             loan_span,\n                             format!(\"borrow of `{}` occurs here\",\n@@ -874,9 +860,8 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                                    span: Span,\n                                    loan_path: &LoanPath<'tcx>,\n                                    loan: &Loan) {\n-        struct_span_err!(self.bccx, span, E0506,\n-                         \"cannot assign to `{}` because it is borrowed\",\n-                         self.bccx.loan_path_to_string(loan_path))\n+        self.bccx.cannot_assign_to_borrowed(\n+            span, &self.bccx.loan_path_to_string(loan_path), Origin::Ast)\n             .span_label(loan.span,\n                        format!(\"borrow of `{}` occurs here\",\n                                self.bccx.loan_path_to_string(loan_path)))"}, {"sha": "8c79534d209ef8549dffb4c120cc6fc8e6785ad8", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 31, "deletions": 12, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/8e79fc72cb51246c397c2776fcede5401dcd3859/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e79fc72cb51246c397c2776fcede5401dcd3859/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=8e79fc72cb51246c397c2776fcede5401dcd3859", "patch": "@@ -37,6 +37,8 @@ use rustc::middle::free_region::RegionRelations;\n use rustc::ty::{self, TyCtxt};\n use rustc::ty::maps::Providers;\n \n+use rustc_mir::util::borrowck_errors::{BorrowckErrors, Origin};\n+\n use std::fmt;\n use std::rc::Rc;\n use std::hash::{Hash, Hasher};\n@@ -218,6 +220,25 @@ pub struct BorrowckCtxt<'a, 'tcx: 'a> {\n     owner_def_id: DefId,\n }\n \n+impl<'b, 'tcx: 'b> BorrowckErrors for BorrowckCtxt<'b, 'tcx> {\n+    fn struct_span_err_with_code<'a, S: Into<MultiSpan>>(&'a self,\n+                                                         sp: S,\n+                                                         msg: &str,\n+                                                         code: &str)\n+                                                         -> DiagnosticBuilder<'a>\n+    {\n+        self.tcx.sess.struct_span_err_with_code(sp, msg, code)\n+    }\n+\n+    fn struct_span_err<'a, S: Into<MultiSpan>>(&'a self,\n+                                               sp: S,\n+                                               msg: &str)\n+                                               -> DiagnosticBuilder<'a>\n+    {\n+        self.tcx.sess.struct_span_err(sp, msg)\n+    }\n+}\n+\n ///////////////////////////////////////////////////////////////////////////\n // Loans and loan paths\n \n@@ -549,14 +570,13 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n             move_data::Declared => {\n                 // If this is an uninitialized variable, just emit a simple warning\n                 // and return.\n-                struct_span_err!(\n-                    self.tcx.sess, use_span, E0381,\n-                    \"{} of possibly uninitialized variable: `{}`\",\n-                    verb,\n-                    self.loan_path_to_string(lp))\n-                .span_label(use_span, format!(\"use of possibly uninitialized `{}`\",\n-                    self.loan_path_to_string(lp)))\n-                .emit();\n+                self.cannot_act_on_uninitialized_variable(use_span,\n+                                                          verb,\n+                                                          &self.loan_path_to_string(lp),\n+                                                          Origin::Ast)\n+                    .span_label(use_span, format!(\"use of possibly uninitialized `{}`\",\n+                                                  self.loan_path_to_string(lp)))\n+                    .emit();\n                 return;\n             }\n             _ => {\n@@ -683,10 +703,9 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                                                 lp: &LoanPath<'tcx>,\n                                                 assign:\n                                                 &move_data::Assignment) {\n-        let mut err = struct_span_err!(\n-            self.tcx.sess, span, E0384,\n-            \"re-assignment of immutable variable `{}`\",\n-            self.loan_path_to_string(lp));\n+        let mut err = self.cannot_reassign_immutable(span,\n+                                                     &self.loan_path_to_string(lp),\n+                                                     Origin::Ast);\n         err.span_label(span, \"re-assignment of immutable variable\");\n         if span != assign.span {\n             err.span_label(assign.span, format!(\"first assignment to `{}`\","}, {"sha": "1f1fc4cc65fbe8e3f3bdf04e9d8e0c9660c9d466", "filename": "src/librustc_borrowck/diagnostics.rs", "status": "modified", "additions": 0, "deletions": 550, "changes": 550, "blob_url": "https://github.com/rust-lang/rust/blob/8e79fc72cb51246c397c2776fcede5401dcd3859/src%2Flibrustc_borrowck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e79fc72cb51246c397c2776fcede5401dcd3859/src%2Flibrustc_borrowck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fdiagnostics.rs?ref=8e79fc72cb51246c397c2776fcede5401dcd3859", "patch": "@@ -63,27 +63,6 @@ Now that the closure has its own copy of the data, there's no need to worry\n about safety.\n \"##,\n \n-E0381: r##\"\n-It is not allowed to use or capture an uninitialized variable. For example:\n-\n-```compile_fail,E0381\n-fn main() {\n-    let x: i32;\n-    let y = x; // error, use of possibly uninitialized variable\n-}\n-```\n-\n-To fix this, ensure that any declared variables are initialized before being\n-used. Example:\n-\n-```\n-fn main() {\n-    let x: i32 = 0;\n-    let y = x; // ok!\n-}\n-```\n-\"##,\n-\n E0382: r##\"\n This error occurs when an attempt is made to use a variable after its contents\n have been moved elsewhere. For example:\n@@ -182,28 +161,6 @@ x = Foo { a: 2 };\n ```\n \"##,\n \n-E0384: r##\"\n-This error occurs when an attempt is made to reassign an immutable variable.\n-For example:\n-\n-```compile_fail,E0384\n-fn main() {\n-    let x = 3;\n-    x = 5; // error, reassignment of immutable variable\n-}\n-```\n-\n-By default, variables in Rust are immutable. To fix this error, add the keyword\n-`mut` after the keyword `let` when declaring the variable. For example:\n-\n-```\n-fn main() {\n-    let mut x = 3;\n-    x = 5;\n-}\n-```\n-\"##,\n-\n /*E0386: r##\"\n This error occurs when an attempt is made to mutate the target of a mutable\n reference stored inside an immutable container.\n@@ -360,512 +317,6 @@ fn main() {\n ```\n \"##,\n \n-E0499: r##\"\n-A variable was borrowed as mutable more than once. Erroneous code example:\n-\n-```compile_fail,E0499\n-let mut i = 0;\n-let mut x = &mut i;\n-let mut a = &mut i;\n-// error: cannot borrow `i` as mutable more than once at a time\n-```\n-\n-Please note that in rust, you can either have many immutable references, or one\n-mutable reference. Take a look at\n-https://doc.rust-lang.org/book/first-edition/references-and-borrowing.html\n-for more information. Example:\n-\n-\n-```\n-let mut i = 0;\n-let mut x = &mut i; // ok!\n-\n-// or:\n-let mut i = 0;\n-let a = &i; // ok!\n-let b = &i; // still ok!\n-let c = &i; // still ok!\n-```\n-\"##,\n-\n-E0500: r##\"\n-A borrowed variable was used in another closure. Example of erroneous code:\n-\n-```compile_fail\n-fn you_know_nothing(jon_snow: &mut i32) {\n-    let nights_watch = || {\n-        *jon_snow = 2;\n-    };\n-    let starks = || {\n-        *jon_snow = 3; // error: closure requires unique access to `jon_snow`\n-                       //        but it is already borrowed\n-    };\n-}\n-```\n-\n-In here, `jon_snow` is already borrowed by the `nights_watch` closure, so it\n-cannot be borrowed by the `starks` closure at the same time. To fix this issue,\n-you can put the closure in its own scope:\n-\n-```\n-fn you_know_nothing(jon_snow: &mut i32) {\n-    {\n-        let nights_watch = || {\n-            *jon_snow = 2;\n-        };\n-    } // At this point, `jon_snow` is free.\n-    let starks = || {\n-        *jon_snow = 3;\n-    };\n-}\n-```\n-\n-Or, if the type implements the `Clone` trait, you can clone it between\n-closures:\n-\n-```\n-fn you_know_nothing(jon_snow: &mut i32) {\n-    let mut jon_copy = jon_snow.clone();\n-    let nights_watch = || {\n-        jon_copy = 2;\n-    };\n-    let starks = || {\n-        *jon_snow = 3;\n-    };\n-}\n-```\n-\"##,\n-\n-E0501: r##\"\n-This error indicates that a mutable variable is being used while it is still\n-captured by a closure. Because the closure has borrowed the variable, it is not\n-available for use until the closure goes out of scope.\n-\n-Note that a capture will either move or borrow a variable, but in this\n-situation, the closure is borrowing the variable. Take a look at\n-http://rustbyexample.com/fn/closures/capture.html for more information about\n-capturing.\n-\n-Example of erroneous code:\n-\n-```compile_fail,E0501\n-fn inside_closure(x: &mut i32) {\n-    // Actions which require unique access\n-}\n-\n-fn outside_closure(x: &mut i32) {\n-    // Actions which require unique access\n-}\n-\n-fn foo(a: &mut i32) {\n-    let bar = || {\n-        inside_closure(a)\n-    };\n-    outside_closure(a); // error: cannot borrow `*a` as mutable because previous\n-                        //        closure requires unique access.\n-}\n-```\n-\n-To fix this error, you can place the closure in its own scope:\n-\n-```\n-fn inside_closure(x: &mut i32) {}\n-fn outside_closure(x: &mut i32) {}\n-\n-fn foo(a: &mut i32) {\n-    {\n-        let bar = || {\n-            inside_closure(a)\n-        };\n-    } // borrow on `a` ends.\n-    outside_closure(a); // ok!\n-}\n-```\n-\n-Or you can pass the variable as a parameter to the closure:\n-\n-```\n-fn inside_closure(x: &mut i32) {}\n-fn outside_closure(x: &mut i32) {}\n-\n-fn foo(a: &mut i32) {\n-    let bar = |s: &mut i32| {\n-        inside_closure(s)\n-    };\n-    outside_closure(a);\n-    bar(a);\n-}\n-```\n-\n-It may be possible to define the closure later:\n-\n-```\n-fn inside_closure(x: &mut i32) {}\n-fn outside_closure(x: &mut i32) {}\n-\n-fn foo(a: &mut i32) {\n-    outside_closure(a);\n-    let bar = || {\n-        inside_closure(a)\n-    };\n-}\n-```\n-\"##,\n-\n-E0502: r##\"\n-This error indicates that you are trying to borrow a variable as mutable when it\n-has already been borrowed as immutable.\n-\n-Example of erroneous code:\n-\n-```compile_fail,E0502\n-fn bar(x: &mut i32) {}\n-fn foo(a: &mut i32) {\n-    let ref y = a; // a is borrowed as immutable.\n-    bar(a); // error: cannot borrow `*a` as mutable because `a` is also borrowed\n-            //        as immutable\n-}\n-```\n-\n-To fix this error, ensure that you don't have any other references to the\n-variable before trying to access it mutably:\n-\n-```\n-fn bar(x: &mut i32) {}\n-fn foo(a: &mut i32) {\n-    bar(a);\n-    let ref y = a; // ok!\n-}\n-```\n-\n-For more information on the rust ownership system, take a look at\n-https://doc.rust-lang.org/book/first-edition/references-and-borrowing.html.\n-\"##,\n-\n-E0503: r##\"\n-A value was used after it was mutably borrowed.\n-\n-Example of erroneous code:\n-\n-```compile_fail,E0503\n-fn main() {\n-    let mut value = 3;\n-    // Create a mutable borrow of `value`. This borrow\n-    // lives until the end of this function.\n-    let _borrow = &mut value;\n-    let _sum = value + 1; // error: cannot use `value` because\n-                          //        it was mutably borrowed\n-}\n-```\n-\n-In this example, `value` is mutably borrowed by `borrow` and cannot be\n-used to calculate `sum`. This is not possible because this would violate\n-Rust's mutability rules.\n-\n-You can fix this error by limiting the scope of the borrow:\n-\n-```\n-fn main() {\n-    let mut value = 3;\n-    // By creating a new block, you can limit the scope\n-    // of the reference.\n-    {\n-        let _borrow = &mut value; // Use `_borrow` inside this block.\n-    }\n-    // The block has ended and with it the borrow.\n-    // You can now use `value` again.\n-    let _sum = value + 1;\n-}\n-```\n-\n-Or by cloning `value` before borrowing it:\n-\n-```\n-fn main() {\n-    let mut value = 3;\n-    // We clone `value`, creating a copy.\n-    let value_cloned = value.clone();\n-    // The mutable borrow is a reference to `value` and\n-    // not to `value_cloned`...\n-    let _borrow = &mut value;\n-    // ... which means we can still use `value_cloned`,\n-    let _sum = value_cloned + 1;\n-    // even though the borrow only ends here.\n-}\n-```\n-\n-You can find more information about borrowing in the rust-book:\n-http://doc.rust-lang.org/book/first-edition/references-and-borrowing.html\n-\"##,\n-\n-E0504: r##\"\n-This error occurs when an attempt is made to move a borrowed variable into a\n-closure.\n-\n-Example of erroneous code:\n-\n-```compile_fail,E0504\n-struct FancyNum {\n-    num: u8,\n-}\n-\n-fn main() {\n-    let fancy_num = FancyNum { num: 5 };\n-    let fancy_ref = &fancy_num;\n-\n-    let x = move || {\n-        println!(\"child function: {}\", fancy_num.num);\n-        // error: cannot move `fancy_num` into closure because it is borrowed\n-    };\n-\n-    x();\n-    println!(\"main function: {}\", fancy_ref.num);\n-}\n-```\n-\n-Here, `fancy_num` is borrowed by `fancy_ref` and so cannot be moved into\n-the closure `x`. There is no way to move a value into a closure while it is\n-borrowed, as that would invalidate the borrow.\n-\n-If the closure can't outlive the value being moved, try using a reference\n-rather than moving:\n-\n-```\n-struct FancyNum {\n-    num: u8,\n-}\n-\n-fn main() {\n-    let fancy_num = FancyNum { num: 5 };\n-    let fancy_ref = &fancy_num;\n-\n-    let x = move || {\n-        // fancy_ref is usable here because it doesn't move `fancy_num`\n-        println!(\"child function: {}\", fancy_ref.num);\n-    };\n-\n-    x();\n-\n-    println!(\"main function: {}\", fancy_num.num);\n-}\n-```\n-\n-If the value has to be borrowed and then moved, try limiting the lifetime of\n-the borrow using a scoped block:\n-\n-```\n-struct FancyNum {\n-    num: u8,\n-}\n-\n-fn main() {\n-    let fancy_num = FancyNum { num: 5 };\n-\n-    {\n-        let fancy_ref = &fancy_num;\n-        println!(\"main function: {}\", fancy_ref.num);\n-        // `fancy_ref` goes out of scope here\n-    }\n-\n-    let x = move || {\n-        // `fancy_num` can be moved now (no more references exist)\n-        println!(\"child function: {}\", fancy_num.num);\n-    };\n-\n-    x();\n-}\n-```\n-\n-If the lifetime of a reference isn't enough, such as in the case of threading,\n-consider using an `Arc` to create a reference-counted value:\n-\n-```\n-use std::sync::Arc;\n-use std::thread;\n-\n-struct FancyNum {\n-    num: u8,\n-}\n-\n-fn main() {\n-    let fancy_ref1 = Arc::new(FancyNum { num: 5 });\n-    let fancy_ref2 = fancy_ref1.clone();\n-\n-    let x = thread::spawn(move || {\n-        // `fancy_ref1` can be moved and has a `'static` lifetime\n-        println!(\"child thread: {}\", fancy_ref1.num);\n-    });\n-\n-    x.join().expect(\"child thread should finish\");\n-    println!(\"main thread: {}\", fancy_ref2.num);\n-}\n-```\n-\"##,\n-\n-E0505: r##\"\n-A value was moved out while it was still borrowed.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0505\n-struct Value {}\n-\n-fn eat(val: Value) {}\n-\n-fn main() {\n-    let x = Value{};\n-    {\n-        let _ref_to_val: &Value = &x;\n-        eat(x);\n-    }\n-}\n-```\n-\n-Here, the function `eat` takes the ownership of `x`. However,\n-`x` cannot be moved because it was borrowed to `_ref_to_val`.\n-To fix that you can do few different things:\n-\n-* Try to avoid moving the variable.\n-* Release borrow before move.\n-* Implement the `Copy` trait on the type.\n-\n-Examples:\n-\n-```\n-struct Value {}\n-\n-fn eat(val: &Value) {}\n-\n-fn main() {\n-    let x = Value{};\n-    {\n-        let _ref_to_val: &Value = &x;\n-        eat(&x); // pass by reference, if it's possible\n-    }\n-}\n-```\n-\n-Or:\n-\n-```\n-struct Value {}\n-\n-fn eat(val: Value) {}\n-\n-fn main() {\n-    let x = Value{};\n-    {\n-        let _ref_to_val: &Value = &x;\n-    }\n-    eat(x); // release borrow and then move it.\n-}\n-```\n-\n-Or:\n-\n-```\n-#[derive(Clone, Copy)] // implement Copy trait\n-struct Value {}\n-\n-fn eat(val: Value) {}\n-\n-fn main() {\n-    let x = Value{};\n-    {\n-        let _ref_to_val: &Value = &x;\n-        eat(x); // it will be copied here.\n-    }\n-}\n-```\n-\n-You can find more information about borrowing in the rust-book:\n-http://doc.rust-lang.org/book/first-edition/references-and-borrowing.html\n-\"##,\n-\n-E0506: r##\"\n-This error occurs when an attempt is made to assign to a borrowed value.\n-\n-Example of erroneous code:\n-\n-```compile_fail,E0506\n-struct FancyNum {\n-    num: u8,\n-}\n-\n-fn main() {\n-    let mut fancy_num = FancyNum { num: 5 };\n-    let fancy_ref = &fancy_num;\n-    fancy_num = FancyNum { num: 6 };\n-    // error: cannot assign to `fancy_num` because it is borrowed\n-\n-    println!(\"Num: {}, Ref: {}\", fancy_num.num, fancy_ref.num);\n-}\n-```\n-\n-Because `fancy_ref` still holds a reference to `fancy_num`, `fancy_num` can't\n-be assigned to a new value as it would invalidate the reference.\n-\n-Alternatively, we can move out of `fancy_num` into a second `fancy_num`:\n-\n-```\n-struct FancyNum {\n-    num: u8,\n-}\n-\n-fn main() {\n-    let mut fancy_num = FancyNum { num: 5 };\n-    let moved_num = fancy_num;\n-    fancy_num = FancyNum { num: 6 };\n-\n-    println!(\"Num: {}, Moved num: {}\", fancy_num.num, moved_num.num);\n-}\n-```\n-\n-If the value has to be borrowed, try limiting the lifetime of the borrow using\n-a scoped block:\n-\n-```\n-struct FancyNum {\n-    num: u8,\n-}\n-\n-fn main() {\n-    let mut fancy_num = FancyNum { num: 5 };\n-\n-    {\n-        let fancy_ref = &fancy_num;\n-        println!(\"Ref: {}\", fancy_ref.num);\n-    }\n-\n-    // Works because `fancy_ref` is no longer in scope\n-    fancy_num = FancyNum { num: 6 };\n-    println!(\"Num: {}\", fancy_num.num);\n-}\n-```\n-\n-Or by moving the reference into a function:\n-\n-```\n-struct FancyNum {\n-    num: u8,\n-}\n-\n-fn main() {\n-    let mut fancy_num = FancyNum { num: 5 };\n-\n-    print_fancy_ref(&fancy_num);\n-\n-    // Works because function borrow has ended\n-    fancy_num = FancyNum { num: 6 };\n-    println!(\"Num: {}\", fancy_num.num);\n-}\n-\n-fn print_fancy_ref(fancy_ref: &FancyNum){\n-    println!(\"Ref: {}\", fancy_ref.num);\n-}\n-```\n-\"##,\n-\n E0507: r##\"\n You tried to move out of a value which was borrowed. Erroneous code example:\n \n@@ -1205,7 +656,6 @@ x.x = Some(&y);\n \n register_diagnostics! {\n //    E0385, // {} in an aliasable location\n-    E0524, // two closures require unique access to `..` at the same time\n     E0594, // cannot assign to {}\n     E0598, // lifetime of {} is too short to guarantee its contents can be...\n }"}, {"sha": "49e626c540082869d2b45f330c3badb0227adb4a", "filename": "src/librustc_mir/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8e79fc72cb51246c397c2776fcede5401dcd3859/src%2Flibrustc_mir%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/8e79fc72cb51246c397c2776fcede5401dcd3859/src%2Flibrustc_mir%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2FCargo.toml?ref=8e79fc72cb51246c397c2776fcede5401dcd3859", "patch": "@@ -15,6 +15,7 @@ rustc = { path = \"../librustc\" }\n rustc_const_eval = { path = \"../librustc_const_eval\" }\n rustc_const_math = { path = \"../librustc_const_math\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n+rustc_errors = { path = \"../librustc_errors\" }\n rustc_bitflags = { path = \"../librustc_bitflags\" }\n syntax = { path = \"../libsyntax\" }\n syntax_pos = { path = \"../libsyntax_pos\" }"}, {"sha": "83a8ce34c692884b7c3c10f4e1906693f405a5a6", "filename": "src/librustc_mir/diagnostics.rs", "status": "modified", "additions": 551, "deletions": 0, "changes": 551, "blob_url": "https://github.com/rust-lang/rust/blob/8e79fc72cb51246c397c2776fcede5401dcd3859/src%2Flibrustc_mir%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e79fc72cb51246c397c2776fcede5401dcd3859/src%2Flibrustc_mir%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdiagnostics.rs?ref=8e79fc72cb51246c397c2776fcede5401dcd3859", "patch": "@@ -195,6 +195,50 @@ instead of using a `const fn`, or refactoring the code to a functional style to\n avoid mutation if possible.\n \"##,\n \n+E0381: r##\"\n+It is not allowed to use or capture an uninitialized variable. For example:\n+\n+```compile_fail,E0381\n+fn main() {\n+    let x: i32;\n+    let y = x; // error, use of possibly uninitialized variable\n+}\n+```\n+\n+To fix this, ensure that any declared variables are initialized before being\n+used. Example:\n+\n+```\n+fn main() {\n+    let x: i32 = 0;\n+    let y = x; // ok!\n+}\n+```\n+\"##,\n+\n+E0384: r##\"\n+This error occurs when an attempt is made to reassign an immutable variable.\n+For example:\n+\n+```compile_fail,E0384\n+fn main() {\n+    let x = 3;\n+    x = 5; // error, reassignment of immutable variable\n+}\n+```\n+\n+By default, variables in Rust are immutable. To fix this error, add the keyword\n+`mut` after the keyword `let` when declaring the variable. For example:\n+\n+```\n+fn main() {\n+    let mut x = 3;\n+    x = 5;\n+}\n+```\n+\"##,\n+\n+\n E0394: r##\"\n A static was referred to by value by another static.\n \n@@ -438,9 +482,516 @@ static A : &'static u32 = &S.a; // ok!\n ```\n \"##,\n \n+E0499: r##\"\n+A variable was borrowed as mutable more than once. Erroneous code example:\n+\n+```compile_fail,E0499\n+let mut i = 0;\n+let mut x = &mut i;\n+let mut a = &mut i;\n+// error: cannot borrow `i` as mutable more than once at a time\n+```\n+\n+Please note that in rust, you can either have many immutable references, or one\n+mutable reference. Take a look at\n+https://doc.rust-lang.org/stable/book/references-and-borrowing.html for more\n+information. Example:\n+\n+\n+```\n+let mut i = 0;\n+let mut x = &mut i; // ok!\n+\n+// or:\n+let mut i = 0;\n+let a = &i; // ok!\n+let b = &i; // still ok!\n+let c = &i; // still ok!\n+```\n+\"##,\n+\n+E0500: r##\"\n+A borrowed variable was used in another closure. Example of erroneous code:\n+\n+```compile_fail\n+fn you_know_nothing(jon_snow: &mut i32) {\n+    let nights_watch = || {\n+        *jon_snow = 2;\n+    };\n+    let starks = || {\n+        *jon_snow = 3; // error: closure requires unique access to `jon_snow`\n+                       //        but it is already borrowed\n+    };\n+}\n+```\n+\n+In here, `jon_snow` is already borrowed by the `nights_watch` closure, so it\n+cannot be borrowed by the `starks` closure at the same time. To fix this issue,\n+you can put the closure in its own scope:\n+\n+```\n+fn you_know_nothing(jon_snow: &mut i32) {\n+    {\n+        let nights_watch = || {\n+            *jon_snow = 2;\n+        };\n+    } // At this point, `jon_snow` is free.\n+    let starks = || {\n+        *jon_snow = 3;\n+    };\n+}\n+```\n+\n+Or, if the type implements the `Clone` trait, you can clone it between\n+closures:\n+\n+```\n+fn you_know_nothing(jon_snow: &mut i32) {\n+    let mut jon_copy = jon_snow.clone();\n+    let nights_watch = || {\n+        jon_copy = 2;\n+    };\n+    let starks = || {\n+        *jon_snow = 3;\n+    };\n+}\n+```\n+\"##,\n+\n+E0501: r##\"\n+This error indicates that a mutable variable is being used while it is still\n+captured by a closure. Because the closure has borrowed the variable, it is not\n+available for use until the closure goes out of scope.\n+\n+Note that a capture will either move or borrow a variable, but in this\n+situation, the closure is borrowing the variable. Take a look at\n+http://rustbyexample.com/fn/closures/capture.html for more information about\n+capturing.\n+\n+Example of erroneous code:\n+\n+```compile_fail,E0501\n+fn inside_closure(x: &mut i32) {\n+    // Actions which require unique access\n+}\n+\n+fn outside_closure(x: &mut i32) {\n+    // Actions which require unique access\n+}\n+\n+fn foo(a: &mut i32) {\n+    let bar = || {\n+        inside_closure(a)\n+    };\n+    outside_closure(a); // error: cannot borrow `*a` as mutable because previous\n+                        //        closure requires unique access.\n+}\n+```\n+\n+To fix this error, you can place the closure in its own scope:\n+\n+```\n+fn inside_closure(x: &mut i32) {}\n+fn outside_closure(x: &mut i32) {}\n+\n+fn foo(a: &mut i32) {\n+    {\n+        let bar = || {\n+            inside_closure(a)\n+        };\n+    } // borrow on `a` ends.\n+    outside_closure(a); // ok!\n+}\n+```\n+\n+Or you can pass the variable as a parameter to the closure:\n+\n+```\n+fn inside_closure(x: &mut i32) {}\n+fn outside_closure(x: &mut i32) {}\n+\n+fn foo(a: &mut i32) {\n+    let bar = |s: &mut i32| {\n+        inside_closure(s)\n+    };\n+    outside_closure(a);\n+    bar(a);\n+}\n+```\n+\n+It may be possible to define the closure later:\n+\n+```\n+fn inside_closure(x: &mut i32) {}\n+fn outside_closure(x: &mut i32) {}\n+\n+fn foo(a: &mut i32) {\n+    outside_closure(a);\n+    let bar = || {\n+        inside_closure(a)\n+    };\n+}\n+```\n+\"##,\n+\n+E0502: r##\"\n+This error indicates that you are trying to borrow a variable as mutable when it\n+has already been borrowed as immutable.\n+\n+Example of erroneous code:\n+\n+```compile_fail,E0502\n+fn bar(x: &mut i32) {}\n+fn foo(a: &mut i32) {\n+    let ref y = a; // a is borrowed as immutable.\n+    bar(a); // error: cannot borrow `*a` as mutable because `a` is also borrowed\n+            //        as immutable\n+}\n+```\n+\n+To fix this error, ensure that you don't have any other references to the\n+variable before trying to access it mutably:\n+\n+```\n+fn bar(x: &mut i32) {}\n+fn foo(a: &mut i32) {\n+    bar(a);\n+    let ref y = a; // ok!\n+}\n+```\n+\n+For more information on the rust ownership system, take a look at\n+https://doc.rust-lang.org/stable/book/references-and-borrowing.html.\n+\"##,\n+\n+E0503: r##\"\n+A value was used after it was mutably borrowed.\n+\n+Example of erroneous code:\n+\n+```compile_fail,E0503\n+fn main() {\n+    let mut value = 3;\n+    // Create a mutable borrow of `value`. This borrow\n+    // lives until the end of this function.\n+    let _borrow = &mut value;\n+    let _sum = value + 1; // error: cannot use `value` because\n+                          //        it was mutably borrowed\n+}\n+```\n+\n+In this example, `value` is mutably borrowed by `borrow` and cannot be\n+used to calculate `sum`. This is not possible because this would violate\n+Rust's mutability rules.\n+\n+You can fix this error by limiting the scope of the borrow:\n+\n+```\n+fn main() {\n+    let mut value = 3;\n+    // By creating a new block, you can limit the scope\n+    // of the reference.\n+    {\n+        let _borrow = &mut value; // Use `_borrow` inside this block.\n+    }\n+    // The block has ended and with it the borrow.\n+    // You can now use `value` again.\n+    let _sum = value + 1;\n+}\n+```\n+\n+Or by cloning `value` before borrowing it:\n+\n+```\n+fn main() {\n+    let mut value = 3;\n+    // We clone `value`, creating a copy.\n+    let value_cloned = value.clone();\n+    // The mutable borrow is a reference to `value` and\n+    // not to `value_cloned`...\n+    let _borrow = &mut value;\n+    // ... which means we can still use `value_cloned`,\n+    let _sum = value_cloned + 1;\n+    // even though the borrow only ends here.\n+}\n+```\n+\n+You can find more information about borrowing in the rust-book:\n+http://doc.rust-lang.org/stable/book/references-and-borrowing.html\n+\"##,\n+\n+E0504: r##\"\n+This error occurs when an attempt is made to move a borrowed variable into a\n+closure.\n+\n+Example of erroneous code:\n+\n+```compile_fail,E0504\n+struct FancyNum {\n+    num: u8,\n+}\n+\n+fn main() {\n+    let fancy_num = FancyNum { num: 5 };\n+    let fancy_ref = &fancy_num;\n+\n+    let x = move || {\n+        println!(\"child function: {}\", fancy_num.num);\n+        // error: cannot move `fancy_num` into closure because it is borrowed\n+    };\n+\n+    x();\n+    println!(\"main function: {}\", fancy_ref.num);\n+}\n+```\n+\n+Here, `fancy_num` is borrowed by `fancy_ref` and so cannot be moved into\n+the closure `x`. There is no way to move a value into a closure while it is\n+borrowed, as that would invalidate the borrow.\n+\n+If the closure can't outlive the value being moved, try using a reference\n+rather than moving:\n+\n+```\n+struct FancyNum {\n+    num: u8,\n+}\n+\n+fn main() {\n+    let fancy_num = FancyNum { num: 5 };\n+    let fancy_ref = &fancy_num;\n+\n+    let x = move || {\n+        // fancy_ref is usable here because it doesn't move `fancy_num`\n+        println!(\"child function: {}\", fancy_ref.num);\n+    };\n+\n+    x();\n+\n+    println!(\"main function: {}\", fancy_num.num);\n+}\n+```\n+\n+If the value has to be borrowed and then moved, try limiting the lifetime of\n+the borrow using a scoped block:\n+\n+```\n+struct FancyNum {\n+    num: u8,\n+}\n+\n+fn main() {\n+    let fancy_num = FancyNum { num: 5 };\n+\n+    {\n+        let fancy_ref = &fancy_num;\n+        println!(\"main function: {}\", fancy_ref.num);\n+        // `fancy_ref` goes out of scope here\n+    }\n+\n+    let x = move || {\n+        // `fancy_num` can be moved now (no more references exist)\n+        println!(\"child function: {}\", fancy_num.num);\n+    };\n+\n+    x();\n+}\n+```\n+\n+If the lifetime of a reference isn't enough, such as in the case of threading,\n+consider using an `Arc` to create a reference-counted value:\n+\n+```\n+use std::sync::Arc;\n+use std::thread;\n+\n+struct FancyNum {\n+    num: u8,\n+}\n+\n+fn main() {\n+    let fancy_ref1 = Arc::new(FancyNum { num: 5 });\n+    let fancy_ref2 = fancy_ref1.clone();\n+\n+    let x = thread::spawn(move || {\n+        // `fancy_ref1` can be moved and has a `'static` lifetime\n+        println!(\"child thread: {}\", fancy_ref1.num);\n+    });\n+\n+    x.join().expect(\"child thread should finish\");\n+    println!(\"main thread: {}\", fancy_ref2.num);\n+}\n+```\n+\"##,\n+\n+E0505: r##\"\n+A value was moved out while it was still borrowed.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0505\n+struct Value {}\n+\n+fn eat(val: Value) {}\n+\n+fn main() {\n+    let x = Value{};\n+    {\n+        let _ref_to_val: &Value = &x;\n+        eat(x);\n+    }\n+}\n+```\n+\n+Here, the function `eat` takes the ownership of `x`. However,\n+`x` cannot be moved because it was borrowed to `_ref_to_val`.\n+To fix that you can do few different things:\n+\n+* Try to avoid moving the variable.\n+* Release borrow before move.\n+* Implement the `Copy` trait on the type.\n+\n+Examples:\n+\n+```\n+struct Value {}\n+\n+fn eat(val: &Value) {}\n+\n+fn main() {\n+    let x = Value{};\n+    {\n+        let _ref_to_val: &Value = &x;\n+        eat(&x); // pass by reference, if it's possible\n+    }\n+}\n+```\n+\n+Or:\n+\n+```\n+struct Value {}\n+\n+fn eat(val: Value) {}\n+\n+fn main() {\n+    let x = Value{};\n+    {\n+        let _ref_to_val: &Value = &x;\n+    }\n+    eat(x); // release borrow and then move it.\n+}\n+```\n+\n+Or:\n+\n+```\n+#[derive(Clone, Copy)] // implement Copy trait\n+struct Value {}\n+\n+fn eat(val: Value) {}\n+\n+fn main() {\n+    let x = Value{};\n+    {\n+        let _ref_to_val: &Value = &x;\n+        eat(x); // it will be copied here.\n+    }\n+}\n+```\n+\n+You can find more information about borrowing in the rust-book:\n+http://doc.rust-lang.org/stable/book/references-and-borrowing.html\n+\"##,\n+\n+E0506: r##\"\n+This error occurs when an attempt is made to assign to a borrowed value.\n+\n+Example of erroneous code:\n+\n+```compile_fail,E0506\n+struct FancyNum {\n+    num: u8,\n+}\n+\n+fn main() {\n+    let mut fancy_num = FancyNum { num: 5 };\n+    let fancy_ref = &fancy_num;\n+    fancy_num = FancyNum { num: 6 };\n+    // error: cannot assign to `fancy_num` because it is borrowed\n+\n+    println!(\"Num: {}, Ref: {}\", fancy_num.num, fancy_ref.num);\n+}\n+```\n+\n+Because `fancy_ref` still holds a reference to `fancy_num`, `fancy_num` can't\n+be assigned to a new value as it would invalidate the reference.\n+\n+Alternatively, we can move out of `fancy_num` into a second `fancy_num`:\n+\n+```\n+struct FancyNum {\n+    num: u8,\n+}\n+\n+fn main() {\n+    let mut fancy_num = FancyNum { num: 5 };\n+    let moved_num = fancy_num;\n+    fancy_num = FancyNum { num: 6 };\n+\n+    println!(\"Num: {}, Moved num: {}\", fancy_num.num, moved_num.num);\n+}\n+```\n+\n+If the value has to be borrowed, try limiting the lifetime of the borrow using\n+a scoped block:\n+\n+```\n+struct FancyNum {\n+    num: u8,\n+}\n+\n+fn main() {\n+    let mut fancy_num = FancyNum { num: 5 };\n+\n+    {\n+        let fancy_ref = &fancy_num;\n+        println!(\"Ref: {}\", fancy_ref.num);\n+    }\n+\n+    // Works because `fancy_ref` is no longer in scope\n+    fancy_num = FancyNum { num: 6 };\n+    println!(\"Num: {}\", fancy_num.num);\n+}\n+```\n+\n+Or by moving the reference into a function:\n+\n+```\n+struct FancyNum {\n+    num: u8,\n+}\n+\n+fn main() {\n+    let mut fancy_num = FancyNum { num: 5 };\n+\n+    print_fancy_ref(&fancy_num);\n+\n+    // Works because function borrow has ended\n+    fancy_num = FancyNum { num: 6 };\n+    println!(\"Num: {}\", fancy_num.num);\n+}\n+\n+fn print_fancy_ref(fancy_ref: &FancyNum){\n+    println!(\"Ref: {}\", fancy_ref.num);\n+}\n+```\n+\"##,\n+\n }\n \n register_diagnostics! {\n+    E0524, // two closures require unique access to `..` at the same time\n     E0526, // shuffle indices are not constant\n     E0625, // thread-local statics cannot be accessed at compile-time\n }"}, {"sha": "143ad784171a098b5e3fcf738d53b0f6f441bd7a", "filename": "src/librustc_mir/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8e79fc72cb51246c397c2776fcede5401dcd3859/src%2Flibrustc_mir%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e79fc72cb51246c397c2776fcede5401dcd3859/src%2Flibrustc_mir%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Flib.rs?ref=8e79fc72cb51246c397c2776fcede5401dcd3859", "patch": "@@ -32,6 +32,7 @@ extern crate graphviz as dot;\n #[macro_use]\n extern crate rustc;\n extern crate rustc_data_structures;\n+extern crate rustc_errors;\n #[macro_use]\n #[no_link]\n extern crate rustc_bitflags;"}, {"sha": "9de3072658660acea829ffc4547864b3e750e821", "filename": "src/librustc_mir/util/borrowck_errors.rs", "status": "added", "additions": 192, "deletions": 0, "changes": 192, "blob_url": "https://github.com/rust-lang/rust/blob/8e79fc72cb51246c397c2776fcede5401dcd3859/src%2Flibrustc_mir%2Futil%2Fborrowck_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e79fc72cb51246c397c2776fcede5401dcd3859/src%2Flibrustc_mir%2Futil%2Fborrowck_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fborrowck_errors.rs?ref=8e79fc72cb51246c397c2776fcede5401dcd3859", "patch": "@@ -0,0 +1,192 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use rustc::ty::{self, TyCtxt};\n+use rustc_errors::DiagnosticBuilder;\n+use syntax_pos::{MultiSpan, Span};\n+\n+use std::fmt;\n+\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+pub enum Origin { Ast, Mir }\n+\n+impl fmt::Display for Origin {\n+    fn fmt(&self, w: &mut fmt::Formatter) -> fmt::Result {\n+        match *self {\n+            Origin::Mir => write!(w, \" (Mir)\"),\n+            Origin::Ast => ty::tls::with_opt(|opt_tcx| {\n+                // If user passed `-Z borrowck-mir`, then include an\n+                // AST origin as part of the error report\n+                if let Some(tcx) = opt_tcx {\n+                    if tcx.sess.opts.debugging_opts.borrowck_mir {\n+                        return write!(w, \" (Ast)\");\n+                    }\n+                }\n+                // otherwise, do not include the origin (i.e., print\n+                // nothing at all)\n+                Ok(())\n+            }),\n+        }\n+    }\n+}\n+\n+pub trait BorrowckErrors {\n+    fn struct_span_err_with_code<'a, S: Into<MultiSpan>>(&'a self,\n+                                                         sp: S,\n+                                                         msg: &str,\n+                                                         code: &str)\n+                                                         -> DiagnosticBuilder<'a>;\n+\n+    fn struct_span_err<'a, S: Into<MultiSpan>>(&'a self,\n+                                               sp: S,\n+                                               msg: &str)\n+                                               -> DiagnosticBuilder<'a>;\n+\n+    fn cannot_move_when_borrowed(&self, span: Span, desc: &str, o: Origin)\n+                                 -> DiagnosticBuilder\n+    {\n+        struct_span_err!(self, span, E0505,\n+                         \"cannot move out of `{}` because it is borrowed{OGN}\",\n+                         desc, OGN=o)\n+    }\n+\n+    fn cannot_use_when_mutably_borrowed(&self, span: Span, desc: &str, o: Origin)\n+                                        -> DiagnosticBuilder\n+    {\n+        struct_span_err!(self, span, E0503,\n+                         \"cannot use `{}` because it was mutably borrowed{OGN}\",\n+                         desc, OGN=o)\n+    }\n+\n+    fn cannot_act_on_uninitialized_variable(&self,\n+                                            span: Span,\n+                                            verb: &str,\n+                                            desc: &str,\n+                                            o: Origin)\n+                                            -> DiagnosticBuilder\n+    {\n+        struct_span_err!(self, span, E0381,\n+                         \"{} of possibly uninitialized variable: `{}`{OGN}\",\n+                         verb, desc, OGN=o)\n+    }\n+\n+    fn cannot_mutably_borrow_multiply(&self,\n+                                      span: Span,\n+                                      desc: &str,\n+                                      opt_via: &str,\n+                                      o: Origin)\n+                                      -> DiagnosticBuilder\n+    {\n+        struct_span_err!(self, span, E0499,\n+                         \"cannot borrow `{}`{} as mutable more than once at a time{OGN}\",\n+                         desc, opt_via, OGN=o)\n+    }\n+\n+    fn cannot_uniquely_borrow_by_two_closures(&self, span: Span, desc: &str, o: Origin)\n+                                              -> DiagnosticBuilder\n+    {\n+        struct_span_err!(self, span, E0524,\n+                         \"two closures require unique access to `{}` at the same time{OGN}\",\n+                         desc, OGN=o)\n+    }\n+\n+    fn cannot_uniquely_borrow_by_one_closure(&self,\n+                                             span: Span,\n+                                             desc_new: &str,\n+                                             noun_old: &str,\n+                                             msg_old: &str,\n+                                             o: Origin)\n+                                             -> DiagnosticBuilder\n+    {\n+        struct_span_err!(self, span, E0500,\n+                         \"closure requires unique access to `{}` but {} is already borrowed{}{OGN}\",\n+                         desc_new, noun_old, msg_old, OGN=o)\n+    }\n+\n+    fn cannot_reborrow_already_uniquely_borrowed(&self,\n+                                                 span: Span,\n+                                                 desc_new: &str,\n+                                                 msg_new: &str,\n+                                                 kind_new: &str,\n+                                                 o: Origin)\n+                                                 -> DiagnosticBuilder\n+    {\n+        struct_span_err!(self, span, E0501,\n+                         \"cannot borrow `{}`{} as {} because previous closure \\\n+                          requires unique access{OGN}\",\n+                         desc_new, msg_new, kind_new, OGN=o)\n+    }\n+\n+    fn cannot_reborrow_already_borrowed(&self,\n+                                        span: Span,\n+                                        desc_new: &str,\n+                                        msg_new: &str,\n+                                        kind_new: &str,\n+                                        noun_old: &str,\n+                                        kind_old: &str,\n+                                        msg_old: &str,\n+                                        o: Origin)\n+                                        -> DiagnosticBuilder\n+    {\n+        struct_span_err!(self, span, E0502,\n+                         \"cannot borrow `{}`{} as {} because {} is also borrowed as {}{}{OGN}\",\n+                         desc_new, msg_new, kind_new, noun_old, kind_old, msg_old, OGN=o)\n+    }\n+\n+    fn cannot_assign_to_borrowed(&self, span: Span, desc: &str, o: Origin)\n+                                 -> DiagnosticBuilder\n+    {\n+        struct_span_err!(self, span, E0506,\n+                         \"cannot assign to `{}` because it is borrowed{OGN}\",\n+                         desc, OGN=o)\n+    }\n+\n+    fn cannot_move_into_closure(&self, span: Span, desc: &str, o: Origin)\n+                                -> DiagnosticBuilder\n+    {\n+        struct_span_err!(self, span, E0504,\n+                         \"cannot move `{}` into closure because it is borrowed{OGN}\",\n+                         desc, OGN=o)\n+    }\n+\n+    fn cannot_reassign_immutable(&self, span: Span, desc: &str, o: Origin)\n+                                 -> DiagnosticBuilder\n+    {\n+        struct_span_err!(self, span, E0384,\n+                         \"re-assignment of immutable variable `{}`{OGN}\",\n+                         desc, OGN=o)\n+    }\n+\n+    fn cannot_assign_static(&self, span: Span, desc: &str, o: Origin)\n+                            -> DiagnosticBuilder\n+    {\n+        self.struct_span_err(span, &format!(\"cannot assign to immutable static item {}{OGN}\",\n+                                            desc, OGN=o))\n+    }\n+}\n+\n+impl<'b, 'tcx, 'gcx> BorrowckErrors for TyCtxt<'b, 'tcx, 'gcx> {\n+    fn struct_span_err_with_code<'a, S: Into<MultiSpan>>(&'a self,\n+                                                         sp: S,\n+                                                         msg: &str,\n+                                                         code: &str)\n+                                                         -> DiagnosticBuilder<'a>\n+    {\n+        self.sess.struct_span_err_with_code(sp, msg, code)\n+    }\n+\n+    fn struct_span_err<'a, S: Into<MultiSpan>>(&'a self,\n+                                               sp: S,\n+                                               msg: &str)\n+                                               -> DiagnosticBuilder<'a>\n+    {\n+        self.sess.struct_span_err(sp, msg)\n+    }\n+}"}, {"sha": "f0d837e1362d1eea7deb2e723d89d0c262ec8d8d", "filename": "src/librustc_mir/util/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8e79fc72cb51246c397c2776fcede5401dcd3859/src%2Flibrustc_mir%2Futil%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e79fc72cb51246c397c2776fcede5401dcd3859/src%2Flibrustc_mir%2Futil%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fmod.rs?ref=8e79fc72cb51246c397c2776fcede5401dcd3859", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+pub mod borrowck_errors;\n pub mod elaborate_drops;\n pub mod def_use;\n pub mod patch;"}]}