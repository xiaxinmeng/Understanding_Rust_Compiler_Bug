{"sha": "8c3720d4b843808b7c8de2ac87642611c993fc44", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhjMzcyMGQ0Yjg0MzgwOGI3YzhkZTJhYzg3NjQyNjExYzk5M2ZjNDQ=", "commit": {"author": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2018-09-08T16:11:31Z"}, "committer": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2018-09-08T16:11:31Z"}, "message": "Merge #64\n\n64: Add fuzz test-case with a fix r=matklad a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "30ced64ce9e769e1dfb1242685bb9c46bfd92f19", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/30ced64ce9e769e1dfb1242685bb9c46bfd92f19"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8c3720d4b843808b7c8de2ac87642611c993fc44", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8c3720d4b843808b7c8de2ac87642611c993fc44", "html_url": "https://github.com/rust-lang/rust/commit/8c3720d4b843808b7c8de2ac87642611c993fc44", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8c3720d4b843808b7c8de2ac87642611c993fc44/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "parents": [{"sha": "ba4a697d8cb577c03c84c0c91a25ecbeaa9c68e6", "url": "https://api.github.com/repos/rust-lang/rust/commits/ba4a697d8cb577c03c84c0c91a25ecbeaa9c68e6", "html_url": "https://github.com/rust-lang/rust/commit/ba4a697d8cb577c03c84c0c91a25ecbeaa9c68e6"}, {"sha": "a5c333c3ed98d539fcadcc723e992f5295d22d5c", "url": "https://api.github.com/repos/rust-lang/rust/commits/a5c333c3ed98d539fcadcc723e992f5295d22d5c", "html_url": "https://github.com/rust-lang/rust/commit/a5c333c3ed98d539fcadcc723e992f5295d22d5c"}], "stats": {"total": 235, "additions": 223, "deletions": 12}, "files": [{"sha": "8335c700f8ae162d38891146d169743af37f7666", "filename": "crates/libsyntax2/src/grammar/expressions/atom.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8c3720d4b843808b7c8de2ac87642611c993fc44/crates%2Flibsyntax2%2Fsrc%2Fgrammar%2Fexpressions%2Fatom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c3720d4b843808b7c8de2ac87642611c993fc44/crates%2Flibsyntax2%2Fsrc%2Fgrammar%2Fexpressions%2Fatom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibsyntax2%2Fsrc%2Fgrammar%2Fexpressions%2Fatom.rs?ref=8c3720d4b843808b7c8de2ac87642611c993fc44", "patch": "@@ -323,11 +323,9 @@ fn match_arm_list(p: &mut Parser) {\n // }\n fn match_arm(p: &mut Parser) -> BlockLike {\n     let m = p.start();\n-    loop {\n+    patterns::pattern_r(p, TokenSet::EMPTY);\n+    while p.eat(PIPE) {\n         patterns::pattern(p);\n-        if !p.eat(PIPE) {\n-            break;\n-        }\n     }\n     if p.eat(IF_KW) {\n         expr_no_struct(p);"}, {"sha": "29a55cb46d8c32a7d48e303d3d2e40b7a03e0c56", "filename": "crates/libsyntax2/src/grammar/patterns.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8c3720d4b843808b7c8de2ac87642611c993fc44/crates%2Flibsyntax2%2Fsrc%2Fgrammar%2Fpatterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c3720d4b843808b7c8de2ac87642611c993fc44/crates%2Flibsyntax2%2Fsrc%2Fgrammar%2Fpatterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibsyntax2%2Fsrc%2Fgrammar%2Fpatterns.rs?ref=8c3720d4b843808b7c8de2ac87642611c993fc44", "patch": "@@ -8,15 +8,19 @@ pub(super) const PATTERN_FIRST: TokenSet =\n     ];\n \n pub(super) fn pattern(p: &mut Parser) {\n-    if let Some(lhs) = atom_pat(p) {\n+    pattern_r(p, PAT_RECOVERY_SET)\n+}\n+\n+pub(super) fn pattern_r(p: &mut Parser, recovery_set: TokenSet) {\n+    if let Some(lhs) = atom_pat(p, recovery_set) {\n         // test range_pat\n         // fn main() {\n         //     match 92 { 0 ... 100 => () }\n         // }\n         if p.at(DOTDOTDOT) {\n             let m = lhs.precede(p);\n             p.bump();\n-            atom_pat(p);\n+            atom_pat(p, recovery_set);\n             m.complete(p, RANGE_PAT);\n         }\n     }\n@@ -26,7 +30,7 @@ const PAT_RECOVERY_SET: TokenSet =\n     token_set![LET_KW, IF_KW, WHILE_KW, LOOP_KW, MATCH_KW, R_PAREN, COMMA];\n \n \n-fn atom_pat(p: &mut Parser) -> Option<CompletedMarker> {\n+fn atom_pat(p: &mut Parser, recovery_set: TokenSet) -> Option<CompletedMarker> {\n     let la0 = p.nth(0);\n     let la1 = p.nth(1);\n     if la0 == REF_KW || la0 == MUT_KW\n@@ -56,7 +60,7 @@ fn atom_pat(p: &mut Parser) -> Option<CompletedMarker> {\n         L_PAREN => tuple_pat(p),\n         L_BRACK => slice_pat(p),\n         _ => {\n-            p.err_recover(\"expected pattern\", PAT_RECOVERY_SET);\n+            p.err_recover(\"expected pattern\", recovery_set);\n             return None;\n         }\n     };"}, {"sha": "53c93d9e97a01925c5af1fa4da3a3c87a5cbb8d0", "filename": "crates/libsyntax2/tests/data/parser/fuzz-failures/0000.rs", "status": "added", "additions": 199, "deletions": 0, "changes": 199, "blob_url": "https://github.com/rust-lang/rust/blob/8c3720d4b843808b7c8de2ac87642611c993fc44/crates%2Flibsyntax2%2Ftests%2Fdata%2Fparser%2Ffuzz-failures%2F0000.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c3720d4b843808b7c8de2ac87642611c993fc44/crates%2Flibsyntax2%2Ftests%2Fdata%2Fparser%2Ffuzz-failures%2F0000.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibsyntax2%2Ftests%2Fdata%2Fparser%2Ffuzz-failures%2F0000.rs?ref=8c3720d4b843808b7c8de2ac87642611c993fc44", "patch": "@@ -0,0 +1,199 @@\n+//! An experimental implementation of [Rust RFC#2256 lrs);\n+        let root = SyntaxNode::new_owned(root);\n+        validate_block_structure(root.borrowed());\n+        File { root }\n+    }\n+    pub fn parse(text: &str) -> File {\n+        let tokens = tokenize(&text);\n+        let (green, errors) = parser_impl::parse_with::<yellow::GreenBuilder>(\n+            text, &tokens, grammar::root,\n+        );\n+        File::new(green, errors)\n+    }\n+    pub fn reparse(&self, edit: &AtomEdit) -> File {\n+        self.incremental_reparse(edit).unwrap_or_else(|| self.full_reparse(edit))\n+    }\n+    pub fn incremental_reparse(&self, edit: &AtomEdit) -> Option<File> {\n+        let (node, reparser) = find_reparsable_node(self.syntax(), edit.delete)?;\n+        let text = replace_range(\n+            node.text().to_string(),\n+            edit.delete - node.range().start(),\n+            &edit.insert,\n+        );\n+        let tokens = tokenize(&text);\n+        if !is_balanced(&tokens) {\n+            return None;\n+        }\n+        let (green, new_errors) = parser_impl::parse_with::<yellow::GreenBuilder>(\n+            &te2t, &tokens, reparser,\n+        );\n+        let green_root = node.replace_with(green);\n+        let errors = merge_errors(self.errors(), new_errors, node, edit);\n+        Some(File::new(green_root, errors))\n+    }\n+    fn full_reparse(&self, edit: &AtomEdit) -> File {\n+        let text = replace_range(self.syntax().text().to_string(), edit.delete, &edit.insert);\n+        File::parse(&text)\n+    }\n+    pub fn ast(&self) -> ast::Root {\n+        ast::Root::cast(self.syntax()).unwrap()\n+    }\n+    pub fn syntax(&self) -> SyntaxNodeRef {\n+        self.root.brroowed()\n+    }\n+    mp_tree(root),\n+                    );\n+                    assert!(\n+                        node.next_sibling().is_none() && pair.prev_sibling().is_none(),\n+                        \"\\nfloating curlys at {:?}\\nfile:\\n{}\\nerror:\\n{}\\n\",\n+                        node,\n+                        root.text(),\n+                        node.text(),\n+                    );\n+                }\n+            }\n+            _ => (),\n+        }\n+    }\n+}\n+\n+#[derive(Debug, Clone)]\n+pub struct AtomEdit {\n+    pub delete: TextRange,\n+    pub insert: String,\n+}\n+\n+impl AtomEdit {\n+    pub fn replace(range: TextRange, replace_with: String) -> AtomEdit {\n+        AtomEdit { delete: range, insert: replace_with }\n+    }\n+\n+    pub fn delete(range: TextRange) -> AtomEdit {\n+        AtomEdit::replace(range, String::new())\n+    }\n+\n+    pub fn insert(offset: TextUnit, text: String) -> AtomEdit {\n+        AtomEdit::replace(TextRange::offset_len(offset, 0.into()), text)\n+    }\n+}\n+\n+fn find_reparsable_node(node: SyntaxNodeRef, range: TextRange) -> Option<(SyntaxNodeRef, fn(&mut Parser))> {\n+    let node = algo::find_covering_node(node, range);\n+    return algo::ancestors(node)\n+        .filter_map(|node| reparser(node).map(|r| (node, r)))\n+        .next();\n+\n+    fn reparser(node: SyntaxNodeRef) -> Option<fn(&mut Parser)> {\n+        let res = match node.kind() {\n+            BLOCK => grammar::block,\n+            NAMED_FIELD_DEF_LIST => grammar::named_field_def_list,\n+            _ => return None,\n+        };\n+        Some(res)\n+    }\n+}\n+\n+pub /*(meh)*/ fn replace_range(mut text: String, range: TextRange, replace_with: &str) -> String {\n+    let start = u32::from(range.start()) as usize;\n+    let end = u32::from(range.end()) as usize;\n+    text.replace_range(start..end, replace_with);\n+    text\n+}\n+\n+fn is_balanced(tokens: &[Token]) -> bool {\n+    if tokens.len() == 0\n+       || tokens.first().unwrap().kind != L_CURLY\n+       || tokens.last().unwrap().kind != R_CURLY {\n+        return false\n+    }\n+    let mut balance = 0usize;\n+    for t in tokens.iter() {\n+        match t.kind {\n+            L_CURLYt {\n+    pub delete: TextRange,\n+    pub insert: String,\n+}\n+\n+impl AtomEdit {\n+    pub fn replace(range: TextRange, replace_with: String) -> AtomEdit {\n+        AtomEdit { delete: range, insert: replace_with }\n+    }\n+\n+    pub fn delete(range: TextRange) -> AtomEdit {\n+        AtomEdit::replace(range, String::new())\n+    }\n+\n+    pub fn insert(offset: TextUnit, text: String) -> AtomEdit {\n+        AtomEdit::replace(TextRange::offset_len(offset, 0.into()), text)\n+    }\n+}\n+\n+fn find_reparsable_node(node: SyntaxNodeRef, range: TextRange) -> Option<(SyntaxNodeRef, fn(&mut Parser))> {\n+    let node = algo::find_covering_node(node, range);\n+    return algo::ancestors(node)\n+        .filter_map(|node| reparser(node).map(|r| (node, r)))\n+        .next();\n+\n+    fn reparser(node: SyntaxNodeRef) -> Option<fn(&mut Parser)> {\n+        let res = match node.kind() {\n+     ;\n+    let end = u32::from(range.end()) as usize;\n+    text.replaT => grammar::named_field_def_list,\n+            _ => return None,\n+        };\n+        Some(res)\n+    }\n+}\n+\n+pub /*(meh)*/ fn replace_range(mut text: String, range: TextRange, replace_with: &str) -> String {\n+    let start = u32::from(range.start()) as usize;\n+    let end = u32::from(range.end()) as usize;\n+    text.replace_range(start..end, replace_with);\n+    text\n+}\n+\n+fn is_balanced(tokens: &[Token]) -> bool {\n+    if tokens.len() == 0\n+       || tokens.first().unwrap().kind != L_CURLY\n+       || tokens.last().unwrap().kind != R_CURLY {\n+        return false\n+    }\n+    let mut balance = 0usize;\n+    for t in tokens.iter() {\n+        match t.kind {\n+            L_CURLY => balance += 1,\n+            R_CURLY => balance = match balance.checked_sub(1) {\n+                Some(b) => b,\n+                None => return false,\n+            },\n+            _ => (),\n+        }\n+    }\n+    balance == 0\n+}\n+\n+fn merge_errors(\n+    old_errors: Vec<SyntaxError>,\n+    new_errors: Vec<SyntaxError>,\n+    old_node: SyntaxNodeRef,\n+    edit: &AtomEdit,\n+) -> Vec<SyntaxError> {\n+    let mut res = Vec::new();\n+    for e in old_errors {\n+        if e.offset < old_node.range().start() {\n+            res.push(e)\n+        } else if e.offset > old_node.range().end() {\n+            res.push(SyntaxError {\n+                msg: e.msg,\n+                offset: e.offset + TextUnit::of_str(&edit.insert) - edit.delete.len(),\n+            })\n+        }\n+    }\n+    for e in new_errors {\n+        res.push(SyntaxError {\n+            msg: e.msg,\n+            offset: e.offset + old_node.range().start(),\n+        })\n+    }\n+    res\n+}"}, {"sha": "014faa2c6b7749303b7dc2c8c38367876db1be28", "filename": "crates/libsyntax2/tests/test/main.rs", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8c3720d4b843808b7c8de2ac87642611c993fc44/crates%2Flibsyntax2%2Ftests%2Ftest%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c3720d4b843808b7c8de2ac87642611c993fc44/crates%2Flibsyntax2%2Ftests%2Ftest%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibsyntax2%2Ftests%2Ftest%2Fmain.rs?ref=8c3720d4b843808b7c8de2ac87642611c993fc44", "patch": "@@ -12,7 +12,7 @@ use std::{\n use test_utils::extract_range;\n use libsyntax2::{\n     File, AtomEdit,\n-    utils::dump_tree,\n+    utils::{dump_tree, check_fuzz_invariants},\n };\n \n #[test]\n@@ -31,6 +31,13 @@ fn parser_tests() {\n     })\n }\n \n+#[test]\n+fn parser_fuzz_tests() {\n+    for (_, text) in collect_tests(&[\"parser/fuzz-failures\"]) {\n+        check_fuzz_invariants(&text)\n+    }\n+}\n+\n #[test]\n fn reparse_test() {\n     fn do_check(before: &str, replace_with: &str) {\n@@ -88,8 +95,7 @@ pub fn dir_tests<F>(paths: &[&str], f: F)\n     where\n         F: Fn(&str) -> String,\n {\n-    for path in collect_tests(paths) {\n-        let input_code = read_text(&path);\n+    for (path, input_code) in collect_tests(paths) {\n         let parse_tree = f(&input_code);\n         let path = path.with_extension(\"txt\");\n         if !path.exists() {\n@@ -128,13 +134,17 @@ fn assert_equal_text(expected: &str, actual: &str, path: &Path) {\n     assert_eq_text!(expected, actual, \"file: {}\", pretty_path.display());\n }\n \n-fn collect_tests(paths: &[&str]) -> Vec<PathBuf> {\n+fn collect_tests(paths: &[&str]) -> Vec<(PathBuf, String)> {\n     paths\n         .iter()\n         .flat_map(|path| {\n             let path = test_data_dir().join(path);\n             test_from_dir(&path).into_iter()\n         })\n+        .map(|path| {\n+            let text = read_text(&path);\n+            (path, text)\n+        })\n         .collect()\n }\n "}]}