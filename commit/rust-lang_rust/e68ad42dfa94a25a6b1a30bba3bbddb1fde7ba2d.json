{"sha": "e68ad42dfa94a25a6b1a30bba3bbddb1fde7ba2d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU2OGFkNDJkZmE5NGEyNWE2YjFhMzBiYmEzYmJkZGIxZmRlN2JhMmQ=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2016-11-20T01:11:20Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2016-11-23T23:40:56Z"}, "message": "rustdoc: sidestep the main pipeline for test collection.", "tree": {"sha": "b09f711a0db4a968527464911387df6423d9423a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b09f711a0db4a968527464911387df6423d9423a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e68ad42dfa94a25a6b1a30bba3bbddb1fde7ba2d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e68ad42dfa94a25a6b1a30bba3bbddb1fde7ba2d", "html_url": "https://github.com/rust-lang/rust/commit/e68ad42dfa94a25a6b1a30bba3bbddb1fde7ba2d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e68ad42dfa94a25a6b1a30bba3bbddb1fde7ba2d/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "12c5f8cb75b0320f4ba9557417e5e554ffe2001b", "url": "https://api.github.com/repos/rust-lang/rust/commits/12c5f8cb75b0320f4ba9557417e5e554ffe2001b", "html_url": "https://github.com/rust-lang/rust/commit/12c5f8cb75b0320f4ba9557417e5e554ffe2001b"}], "stats": {"total": 173, "additions": 93, "deletions": 80}, "files": [{"sha": "9f29319430dd5f4688444904fa55295170f32ed8", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 93, "deletions": 80, "changes": 173, "blob_url": "https://github.com/rust-lang/rust/blob/e68ad42dfa94a25a6b1a30bba3bbddb1fde7ba2d/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e68ad42dfa94a25a6b1a30bba3bbddb1fde7ba2d/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=e68ad42dfa94a25a6b1a30bba3bbddb1fde7ba2d", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::cell::Cell;\n use std::env;\n use std::ffi::OsString;\n use std::io::prelude::*;\n@@ -23,7 +22,8 @@ use std::sync::{Arc, Mutex};\n use testing;\n use rustc_lint;\n use rustc::dep_graph::DepGraph;\n-use rustc::hir::map as hir_map;\n+use rustc::hir;\n+use rustc::hir::intravisit;\n use rustc::session::{self, config};\n use rustc::session::config::{OutputType, OutputTypes, Externs};\n use rustc::session::search_paths::{SearchPaths, PathKind};\n@@ -33,18 +33,15 @@ use rustc_driver::{driver, Compilation};\n use rustc_driver::driver::phase_2_configure_and_expand;\n use rustc_metadata::cstore::CStore;\n use rustc_resolve::MakeGlobMap;\n+use rustc_trans::back::link;\n+use syntax::ast;\n use syntax::codemap::CodeMap;\n use syntax::feature_gate::UnstableFeatures;\n use errors;\n use errors::emitter::ColorConfig;\n \n-use core;\n-use clean;\n-use clean::Clean;\n-use fold::DocFolder;\n+use clean::Attributes;\n use html::markdown;\n-use passes;\n-use visit_ast::RustdocVisitor;\n \n #[derive(Clone, Default)]\n pub struct TestOptions {\n@@ -87,48 +84,36 @@ pub fn run(input: &str,\n         config::build_configuration(&sess, config::parse_cfgspecs(cfgs.clone()));\n \n     let krate = panictry!(driver::phase_1_parse_input(&sess, &input));\n-    let driver::ExpansionResult { defs, mut hir_forest, analysis, .. } = {\n+    let driver::ExpansionResult { defs, mut hir_forest, .. } = {\n         phase_2_configure_and_expand(\n             &sess, &cstore, krate, None, \"rustdoc-test\", None, MakeGlobMap::No, |_| Ok(())\n         ).expect(\"phase_2_configure_and_expand aborted in rustdoc!\")\n     };\n \n-    let dep_graph = DepGraph::new(false);\n+    let crate_name = crate_name.unwrap_or_else(|| {\n+        link::find_crate_name(None, &hir_forest.krate().attrs, &input)\n+    });\n     let opts = scrape_test_config(hir_forest.krate());\n-    let _ignore = dep_graph.in_ignore();\n-    let map = hir_map::map_crate(&mut hir_forest, defs);\n-\n-    let ctx = core::DocContext {\n-        map: &map,\n-        maybe_typed: core::NotTyped(&sess),\n-        input: input,\n-        populated_all_crate_impls: Cell::new(false),\n-        external_traits: Default::default(),\n-        deref_trait_did: Cell::new(None),\n-        deref_mut_trait_did: Cell::new(None),\n-        access_levels: Default::default(),\n-        renderinfo: Default::default(),\n-        ty_substs: Default::default(),\n-        lt_substs: Default::default(),\n-        export_map: analysis.export_map,\n-    };\n-\n-    let mut v = RustdocVisitor::new(&ctx);\n-    v.visit(ctx.map.krate());\n-    let mut krate = v.clean(&ctx);\n-    if let Some(name) = crate_name {\n-        krate.name = name;\n-    }\n-    let krate = passes::collapse_docs(krate);\n-    let krate = passes::unindent_comments(krate);\n-\n-    let mut collector = Collector::new(krate.name.to_string(),\n+    let mut collector = Collector::new(crate_name,\n                                        cfgs,\n                                        libs,\n                                        externs,\n                                        false,\n                                        opts);\n-    collector.fold_crate(krate);\n+\n+    {\n+        let dep_graph = DepGraph::new(false);\n+        let _ignore = dep_graph.in_ignore();\n+        let map = hir::map::map_crate(&mut hir_forest, defs);\n+        let krate = map.krate();\n+        let mut hir_collector = HirCollector {\n+            collector: &mut collector,\n+            map: &map\n+        };\n+        hir_collector.visit_testable(\"\".to_string(), &krate.attrs, |this| {\n+            intravisit::walk_crate(this, krate);\n+        });\n+    }\n \n     test_args.insert(0, \"rustdoctest\".to_string());\n \n@@ -472,56 +457,84 @@ impl Collector {\n     }\n }\n \n-impl DocFolder for Collector {\n-    fn fold_item(&mut self, item: clean::Item) -> Option<clean::Item> {\n-        let current_name = match item.name {\n-            Some(ref name) if !name.is_empty() => Some(name.clone()),\n-            _ => typename_if_impl(&item)\n-        };\n+struct HirCollector<'a, 'hir: 'a> {\n+    collector: &'a mut Collector,\n+    map: &'a hir::map::Map<'hir>\n+}\n \n-        let pushed = current_name.map(|name| self.names.push(name)).is_some();\n+impl<'a, 'hir> HirCollector<'a, 'hir> {\n+    fn visit_testable<F: FnOnce(&mut Self)>(&mut self,\n+                                            name: String,\n+                                            attrs: &[ast::Attribute],\n+                                            nested: F) {\n+        let has_name = !name.is_empty();\n+        if has_name {\n+            self.collector.names.push(name);\n+        }\n \n-        if let Some(doc) = item.doc_value() {\n-            self.cnt = 0;\n-            markdown::find_testable_code(doc, &mut *self);\n+        let mut attrs = Attributes::from_ast(attrs);\n+        attrs.collapse_doc_comments();\n+        attrs.unindent_doc_comments();\n+        if let Some(doc) = attrs.doc_value() {\n+            self.collector.cnt = 0;\n+            markdown::find_testable_code(doc, self.collector);\n         }\n \n-        let ret = self.fold_item_recur(item);\n-        if pushed {\n-            self.names.pop();\n+        nested(self);\n+\n+        if has_name {\n+            self.collector.names.pop();\n         }\n+    }\n+}\n+\n+impl<'a, 'hir> intravisit::Visitor<'hir> for HirCollector<'a, 'hir> {\n+    fn nested_visit_map(&mut self) -> Option<&hir::map::Map<'hir>> {\n+        Some(self.map)\n+    }\n+\n+    fn visit_item(&mut self, item: &'hir hir::Item) {\n+        let name = if let hir::ItemImpl(.., ref ty, _) = item.node {\n+            hir::print::ty_to_string(ty)\n+        } else {\n+            item.name.to_string()\n+        };\n \n-        return ret;\n+        self.visit_testable(name, &item.attrs, |this| {\n+            intravisit::walk_item(this, item);\n+        });\n+    }\n \n-        // FIXME: it would be better to not have the escaped version in the first place\n-        fn unescape_for_testname(mut s: String) -> String {\n-            // for refs `&foo`\n-            if s.contains(\"&amp;\") {\n-                s = s.replace(\"&amp;\", \"&\");\n+    fn visit_trait_item(&mut self, item: &'hir hir::TraitItem) {\n+        self.visit_testable(item.name.to_string(), &item.attrs, |this| {\n+            intravisit::walk_trait_item(this, item);\n+        });\n+    }\n \n-                // `::&'a mut Foo::` looks weird, let's make it `::<&'a mut Foo>`::\n-                if let Some('&') = s.chars().nth(0) {\n-                    s = format!(\"<{}>\", s);\n-                }\n-            }\n+    fn visit_impl_item(&mut self, item: &'hir hir::ImplItem) {\n+        self.visit_testable(item.name.to_string(), &item.attrs, |this| {\n+            intravisit::walk_impl_item(this, item);\n+        });\n+    }\n \n-            // either `<..>` or `->`\n-            if s.contains(\"&gt;\") {\n-                s.replace(\"&gt;\", \">\")\n-                 .replace(\"&lt;\", \"<\")\n-            } else {\n-                s\n-            }\n-        }\n+    fn visit_foreign_item(&mut self, item: &'hir hir::ForeignItem) {\n+        self.visit_testable(item.name.to_string(), &item.attrs, |this| {\n+            intravisit::walk_foreign_item(this, item);\n+        });\n+    }\n \n-        fn typename_if_impl(item: &clean::Item) -> Option<String> {\n-            if let clean::ItemEnum::ImplItem(ref impl_) = item.inner {\n-                let path = impl_.for_.to_string();\n-                let unescaped_path = unescape_for_testname(path);\n-                Some(unescaped_path)\n-            } else {\n-                None\n-            }\n-        }\n+    fn visit_variant(&mut self,\n+                     v: &'hir hir::Variant,\n+                     g: &'hir hir::Generics,\n+                     item_id: ast::NodeId) {\n+        self.visit_testable(v.node.name.to_string(), &v.node.attrs, |this| {\n+            intravisit::walk_variant(this, v, g, item_id);\n+        });\n+    }\n+\n+    fn visit_struct_field(&mut self, f: &'hir hir::StructField) {\n+        self.visit_testable(f.name.to_string(), &f.attrs, |this| {\n+            intravisit::walk_struct_field(this, f);\n+        });\n     }\n }"}]}