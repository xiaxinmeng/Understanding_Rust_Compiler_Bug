{"sha": "ab9b8441468aed505f83a2ddf74454f9cdfeab33", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFiOWI4NDQxNDY4YWVkNTA1ZjgzYTJkZGY3NDQ1NGY5Y2RmZWFiMzM=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-03-16T09:50:38Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-03-25T18:07:19Z"}, "message": "track the extern-crate def-id rather than path\n\nWe used to track, for each crate, a path that led to the extern-crate\nthat imported it. Instead of that, track the def-id of the extern crate,\nalong with a bit more information, and derive the path on the fly.", "tree": {"sha": "394e51e1cd844943a88d9c0b20a9a7fab1e5fa61", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/394e51e1cd844943a88d9c0b20a9a7fab1e5fa61"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ab9b8441468aed505f83a2ddf74454f9cdfeab33", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ab9b8441468aed505f83a2ddf74454f9cdfeab33", "html_url": "https://github.com/rust-lang/rust/commit/ab9b8441468aed505f83a2ddf74454f9cdfeab33", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ab9b8441468aed505f83a2ddf74454f9cdfeab33/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6056c5fbedb3681f9fe5efa5f9befe7ff2f91e73", "url": "https://api.github.com/repos/rust-lang/rust/commits/6056c5fbedb3681f9fe5efa5f9befe7ff2f91e73", "html_url": "https://github.com/rust-lang/rust/commit/6056c5fbedb3681f9fe5efa5f9befe7ff2f91e73"}], "stats": {"total": 240, "additions": 141, "deletions": 99}, "files": [{"sha": "7cad9b10f85ec2a16d44f1c56646112de8d86707", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 29, "deletions": 4, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/ab9b8441468aed505f83a2ddf74454f9cdfeab33/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab9b8441468aed505f83a2ddf74454f9cdfeab33/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=ab9b8441468aed505f83a2ddf74454f9cdfeab33", "patch": "@@ -127,6 +127,27 @@ pub enum FoundAst<'ast> {\n     NotFound,\n }\n \n+#[derive(Copy, Clone, Debug)]\n+pub struct ExternCrate {\n+    /// def_id of an `extern crate` in the current crate that caused\n+    /// this crate to be loaded; note that there could be multiple\n+    /// such ids\n+    pub def_id: DefId,\n+\n+    /// span of the extern crate that caused this to be loaded\n+    pub span: Span,\n+\n+    /// If true, then this crate is the crate named by the extern\n+    /// crate referenced above. If false, then this crate is a dep\n+    /// of the crate.\n+    pub direct: bool,\n+\n+    /// Number of links to reach the extern crate `def_id`\n+    /// declaration; used to select the extern crate with the shortest\n+    /// path\n+    pub path_len: usize,\n+}\n+\n /// A store of Rust crates, through with their metadata\n /// can be accessed.\n ///\n@@ -147,7 +168,7 @@ pub trait CrateStore<'tcx> : Any {\n     fn repr_attrs(&self, def: DefId) -> Vec<attr::ReprAttr>;\n     fn item_type(&self, tcx: &TyCtxt<'tcx>, def: DefId)\n                  -> ty::TypeScheme<'tcx>;\n-    fn item_path(&self, def: DefId) -> Vec<hir_map::PathElem>;\n+    fn relative_item_path(&self, def: DefId) -> Vec<hir_map::PathElem>;\n     fn extern_item_path(&self, def: DefId) -> Vec<hir_map::PathElem>;\n     fn item_name(&self, def: DefId) -> ast::Name;\n     fn item_predicates(&self, tcx: &TyCtxt<'tcx>, def: DefId)\n@@ -203,6 +224,7 @@ pub trait CrateStore<'tcx> : Any {\n     fn is_staged_api(&self, cnum: ast::CrateNum) -> bool;\n     fn is_explicitly_linked(&self, cnum: ast::CrateNum) -> bool;\n     fn is_allocator(&self, cnum: ast::CrateNum) -> bool;\n+    fn extern_crate(&self, cnum: ast::CrateNum) -> Option<ExternCrate>;\n     fn crate_attrs(&self, cnum: ast::CrateNum) -> Vec<ast::Attribute>;\n     /// The name of the crate as it is referred to in source code of the current\n     /// crate.\n@@ -218,7 +240,8 @@ pub trait CrateStore<'tcx> : Any {\n     fn reachable_ids(&self, cnum: ast::CrateNum) -> Vec<DefId>;\n \n     // resolve\n-    fn def_path(&self, def: DefId) -> hir_map::DefPath;\n+    fn def_key(&self, def: DefId) -> hir_map::DefKey;\n+    fn relative_def_path(&self, def: DefId) -> hir_map::DefPath;\n     fn variant_kind(&self, def_id: DefId) -> Option<VariantKind>;\n     fn struct_ctor_def_id(&self, struct_def_id: DefId) -> Option<DefId>;\n     fn tuple_struct_definition_if_ctor(&self, did: DefId) -> Option<DefId>;\n@@ -323,7 +346,7 @@ impl<'tcx> CrateStore<'tcx> for DummyCrateStore {\n     fn repr_attrs(&self, def: DefId) -> Vec<attr::ReprAttr> { unimplemented!() }\n     fn item_type(&self, tcx: &TyCtxt<'tcx>, def: DefId)\n                  -> ty::TypeScheme<'tcx> { unimplemented!() }\n-    fn item_path(&self, def: DefId) -> Vec<hir_map::PathElem> { unimplemented!() }\n+    fn relative_item_path(&self, def: DefId) -> Vec<hir_map::PathElem> { unimplemented!() }\n     fn extern_item_path(&self, def: DefId) -> Vec<hir_map::PathElem> { unimplemented!() }\n     fn item_name(&self, def: DefId) -> ast::Name { unimplemented!() }\n     fn item_predicates(&self, tcx: &TyCtxt<'tcx>, def: DefId)\n@@ -386,6 +409,7 @@ impl<'tcx> CrateStore<'tcx> for DummyCrateStore {\n     fn is_staged_api(&self, cnum: ast::CrateNum) -> bool { unimplemented!() }\n     fn is_explicitly_linked(&self, cnum: ast::CrateNum) -> bool { unimplemented!() }\n     fn is_allocator(&self, cnum: ast::CrateNum) -> bool { unimplemented!() }\n+    fn extern_crate(&self, cnum: ast::CrateNum) -> Option<ExternCrate> { unimplemented!() }\n     fn crate_attrs(&self, cnum: ast::CrateNum) -> Vec<ast::Attribute>\n         { unimplemented!() }\n     fn crate_name(&self, cnum: ast::CrateNum) -> InternedString { unimplemented!() }\n@@ -404,7 +428,8 @@ impl<'tcx> CrateStore<'tcx> for DummyCrateStore {\n     fn reachable_ids(&self, cnum: ast::CrateNum) -> Vec<DefId> { unimplemented!() }\n \n     // resolve\n-    fn def_path(&self, def: DefId) -> hir_map::DefPath { unimplemented!() }\n+    fn def_key(&self, def: DefId) -> hir_map::DefKey { unimplemented!() }\n+    fn relative_def_path(&self, def: DefId) -> hir_map::DefPath { unimplemented!() }\n     fn variant_kind(&self, def_id: DefId) -> Option<VariantKind> { unimplemented!() }\n     fn struct_ctor_def_id(&self, struct_def_id: DefId) -> Option<DefId>\n         { unimplemented!() }"}, {"sha": "61e591e2fcea63645f64775805c24e4882b80b6b", "filename": "src/librustc/middle/ty/mod.rs", "status": "modified", "additions": 25, "deletions": 2, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/ab9b8441468aed505f83a2ddf74454f9cdfeab33/src%2Flibrustc%2Fmiddle%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab9b8441468aed505f83a2ddf74454f9cdfeab33/src%2Flibrustc%2Fmiddle%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Fmod.rs?ref=ab9b8441468aed505f83a2ddf74454f9cdfeab33", "patch": "@@ -2222,11 +2222,14 @@ impl<'tcx> TyCtxt<'tcx> {\n         self.with_path(id, |path| ast_map::path_to_string(path))\n     }\n \n+    /// Returns the `DefPath` of an item. Note that if `id` is not\n+    /// local to this crate -- or is inlined into this crate -- the\n+    /// result will be a non-local `DefPath`.\n     pub fn def_path(&self, id: DefId) -> ast_map::DefPath {\n         if id.is_local() {\n             self.map.def_path(id)\n         } else {\n-            self.sess.cstore.def_path(id)\n+            self.sess.cstore.relative_def_path(id)\n         }\n     }\n \n@@ -2236,7 +2239,27 @@ impl<'tcx> TyCtxt<'tcx> {\n         if let Some(id) = self.map.as_local_node_id(id) {\n             self.map.with_path(id, f)\n         } else {\n-            f(self.sess.cstore.item_path(id).iter().cloned().chain(LinkedPath::empty()))\n+            let mut path: Vec<_>;\n+            if let Some(extern_crate) = self.sess.cstore.extern_crate(id.krate) {\n+                if !extern_crate.direct {\n+                    // this comes from some crate that we don't have a direct\n+                    // path to; we'll settle for just prepending the name of\n+                    // the crate.\n+                    path = self.sess.cstore.extern_item_path(id)\n+                } else {\n+                    // start with the path to the extern crate, then\n+                    // add the relative path to the actual item\n+                    fn collector(elems: ast_map::PathElems) -> Vec<ast_map::PathElem> {\n+                        elems.collect()\n+                    }\n+                    path = self.with_path(extern_crate.def_id, collector);\n+                    path.extend(self.sess.cstore.relative_item_path(id));\n+                }\n+            } else {\n+                // if this was injected, just make a path with name of crate\n+                path = self.sess.cstore.extern_item_path(id);\n+            }\n+            f(path.iter().cloned().chain(LinkedPath::empty()))\n         }\n     }\n "}, {"sha": "4fe10aea2e0fb3bdaa4b950409897731e262a61a", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 59, "deletions": 27, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/ab9b8441468aed505f83a2ddf74454f9cdfeab33/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab9b8441468aed505f83a2ddf74454f9cdfeab33/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=ab9b8441468aed505f83a2ddf74454f9cdfeab33", "patch": "@@ -21,7 +21,7 @@ use rustc::back::svh::Svh;\n use rustc::dep_graph::DepNode;\n use rustc::session::{config, Session};\n use rustc::session::search_paths::PathKind;\n-use rustc::middle::cstore::{CrateStore, validate_crate_name};\n+use rustc::middle::cstore::{CrateStore, validate_crate_name, ExternCrate};\n use rustc::util::nodemap::FnvHashMap;\n use rustc::front::map as hir_map;\n \n@@ -38,7 +38,6 @@ use syntax::attr;\n use syntax::attr::AttrMetaMethods;\n use syntax::errors::FatalError;\n use syntax::parse::token::InternedString;\n-use syntax::util::small_vector::SmallVector;\n use rustc_front::intravisit::Visitor;\n use rustc_front::hir;\n use log;\n@@ -344,15 +343,13 @@ impl<'a> CrateReader<'a> {\n \n         let cmeta = Rc::new(cstore::crate_metadata {\n             name: name.to_string(),\n-            local_path: RefCell::new(SmallVector::zero()),\n-            local_def_path: RefCell::new(vec![]),\n+            extern_crate: Cell::new(None),\n             index: decoder::load_index(metadata.as_slice()),\n             xref_index: decoder::load_xrefs(metadata.as_slice()),\n             data: metadata,\n             cnum_map: RefCell::new(cnum_map),\n             cnum: cnum,\n             codemap_import_info: RefCell::new(vec![]),\n-            span: span,\n             staged_api: staged_api,\n             explicitly_linked: Cell::new(explicitly_linked),\n         });\n@@ -386,8 +383,7 @@ impl<'a> CrateReader<'a> {\n                      span: Span,\n                      kind: PathKind,\n                      explicitly_linked: bool)\n-                         -> (ast::CrateNum, Rc<cstore::crate_metadata>,\n-                             cstore::CrateSource) {\n+                     -> (ast::CrateNum, Rc<cstore::crate_metadata>, cstore::CrateSource) {\n         enum LookupResult {\n             Previous(ast::CrateNum),\n             Loaded(loader::Library),\n@@ -444,23 +440,54 @@ impl<'a> CrateReader<'a> {\n         }\n     }\n \n+    fn update_extern_crate(&mut self,\n+                           cnum: ast::CrateNum,\n+                           mut extern_crate: ExternCrate)\n+    {\n+        let cmeta = self.cstore.get_crate_data(cnum);\n+        let old_extern_crate = cmeta.extern_crate.get();\n+\n+        // Prefer:\n+        // - something over nothing (tuple.0);\n+        // - direct extern crate to indirect (tuple.1);\n+        // - shorter paths to longer (tuple.2).\n+        let new_rank = (true, extern_crate.direct, !extern_crate.path_len);\n+        let old_rank = match old_extern_crate {\n+            None => (false, false, !0),\n+            Some(ref c) => (true, c.direct, !c.path_len),\n+        };\n+\n+        if old_rank >= new_rank {\n+            return; // no change needed\n+        }\n+\n+        cmeta.extern_crate.set(Some(extern_crate));\n+\n+        // Propagate the extern crate info to dependencies.\n+        extern_crate.direct = false;\n+        for &dep_cnum in cmeta.cnum_map.borrow().values() {\n+            self.update_extern_crate(dep_cnum, extern_crate);\n+        }\n+    }\n+\n     // Go through the crate metadata and load any crates that it references\n     fn resolve_crate_deps(&mut self,\n                           root: &Option<CratePaths>,\n-                          cdata: &[u8], span : Span)\n-                       -> cstore::cnum_map {\n+                          cdata: &[u8],\n+                          span : Span)\n+                          -> cstore::cnum_map {\n         debug!(\"resolving deps of external crate\");\n         // The map from crate numbers in the crate we're resolving to local crate\n         // numbers\n         decoder::get_crate_deps(cdata).iter().map(|dep| {\n             debug!(\"resolving dep crate {} hash: `{}`\", dep.name, dep.hash);\n             let (local_cnum, _, _) = self.resolve_crate(root,\n-                                                   &dep.name,\n-                                                   &dep.name,\n-                                                   Some(&dep.hash),\n-                                                   span,\n-                                                   PathKind::Dependency,\n-                                                   dep.explicitly_linked);\n+                                                        &dep.name,\n+                                                        &dep.name,\n+                                                        Some(&dep.hash),\n+                                                        span,\n+                                                        PathKind::Dependency,\n+                                                        dep.explicitly_linked);\n             (dep.cnum, local_cnum)\n         }).collect()\n     }\n@@ -802,19 +829,24 @@ impl<'a, 'b> LocalCrateReader<'a, 'b> {\n \n                 match self.creader.extract_crate_info_hir(i) {\n                     Some(info) => {\n-                        let (cnum, cmeta, _) = self.creader.resolve_crate(&None,\n-                                                              &info.ident,\n-                                                              &info.name,\n-                                                              None,\n-                                                              i.span,\n-                                                              PathKind::Crate,\n-                                                              true);\n+                        let (cnum, _, _) = self.creader.resolve_crate(&None,\n+                                                                          &info.ident,\n+                                                                          &info.name,\n+                                                                          None,\n+                                                                          i.span,\n+                                                                          PathKind::Crate,\n+                                                                          true);\n                         let def_id = self.ast_map.local_def_id(i.id);\n-                        let def_path = self.ast_map.def_path(def_id);\n-                        cmeta.update_local_def_path(def_path);\n-                        self.ast_map.with_path(i.id, |path| {\n-                            cmeta.update_local_path(path)\n-                        });\n+\n+                        let len = self.ast_map.def_path(def_id).data.len();\n+\n+                        self.creader.update_extern_crate(cnum,\n+                                                         ExternCrate {\n+                                                             def_id: def_id,\n+                                                             span: i.span,\n+                                                             direct: true,\n+                                                             path_len: len,\n+                                                         });\n                         self.cstore.add_extern_mod_stmt_cnum(info.id, cnum);\n                     }\n                     None => ()"}, {"sha": "25cc2f91753a3f407af74473ab1f65690c345a8f", "filename": "src/librustc_metadata/csearch.rs", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/ab9b8441468aed505f83a2ddf74454f9cdfeab33/src%2Flibrustc_metadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab9b8441468aed505f83a2ddf74454f9cdfeab33/src%2Flibrustc_metadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcsearch.rs?ref=ab9b8441468aed505f83a2ddf74454f9cdfeab33", "patch": "@@ -13,7 +13,7 @@ use decoder;\n use encoder;\n use loader;\n \n-use middle::cstore::{CrateStore, CrateSource, ChildItem, FoundAst};\n+use middle::cstore::{CrateStore, CrateSource, ChildItem, ExternCrate, FoundAst};\n use middle::cstore::{NativeLibraryKind, LinkMeta, LinkagePreference};\n use middle::def;\n use middle::lang_items;\n@@ -128,16 +128,9 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         decoder::get_method_arg_names(&cdata, did.index)\n     }\n \n-    fn item_path(&self, def: DefId) -> Vec<hir_map::PathElem> {\n+    fn relative_item_path(&self, def: DefId) -> Vec<hir_map::PathElem> {\n         let cdata = self.get_crate_data(def.krate);\n-        let path = decoder::get_item_path(&cdata, def.index);\n-\n-        cdata.with_local_path(|cpath| {\n-            let mut r = Vec::with_capacity(cpath.len() + path.len());\n-            r.extend_from_slice(cpath);\n-            r.extend_from_slice(&path);\n-            r\n-        })\n+        decoder::get_item_path(&cdata, def.index)\n     }\n \n     fn extern_item_path(&self, def: DefId) -> Vec<hir_map::PathElem> {\n@@ -344,6 +337,11 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         token::intern_and_get_ident(&self.get_crate_data(cnum).name())\n     }\n \n+    fn extern_crate(&self, cnum: ast::CrateNum) -> Option<ExternCrate>\n+    {\n+        self.get_crate_data(cnum).extern_crate.get()\n+    }\n+\n     fn crate_hash(&self, cnum: ast::CrateNum) -> Svh\n     {\n         let cdata = self.get_crate_data(cnum);\n@@ -383,12 +381,17 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         decoder::get_reachable_ids(&cdata)\n     }\n \n-    fn def_path(&self, def: DefId) -> hir_map::DefPath\n-    {\n+    /// Returns the `DefKey` for a given `DefId`. This indicates the\n+    /// parent `DefId` as well as some idea of what kind of data the\n+    /// `DefId` refers to.\n+    fn def_key(&self, def: DefId) -> hir_map::DefKey {\n+        let cdata = self.get_crate_data(def.krate);\n+        decoder::def_key(&cdata, def.index)\n+    }\n+\n+    fn relative_def_path(&self, def: DefId) -> hir_map::DefPath {\n         let cdata = self.get_crate_data(def.krate);\n-        let path = decoder::def_path(&cdata, def.index);\n-        let local_path = cdata.local_def_path();\n-        local_path.into_iter().chain(path).collect()\n+        decoder::def_path(&cdata, def.index)\n     }\n \n     fn variant_kind(&self, def_id: DefId) -> Option<VariantKind> {"}, {"sha": "f092ee3919826a0b79eaf693f946e4304276a85a", "filename": "src/librustc_metadata/cstore.rs", "status": "modified", "additions": 7, "deletions": 50, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/ab9b8441468aed505f83a2ddf74454f9cdfeab33/src%2Flibrustc_metadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab9b8441468aed505f83a2ddf74454f9cdfeab33/src%2Flibrustc_metadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore.rs?ref=ab9b8441468aed505f83a2ddf74454f9cdfeab33", "patch": "@@ -21,7 +21,7 @@ use index;\n use loader;\n \n use rustc::back::svh::Svh;\n-use rustc::front::map as ast_map;\n+use rustc::middle::cstore::{ExternCrate};\n use rustc::util::nodemap::{FnvHashMap, NodeMap, NodeSet};\n \n use std::cell::{RefCell, Ref, Cell};\n@@ -31,9 +31,7 @@ use flate::Bytes;\n use syntax::ast;\n use syntax::attr;\n use syntax::codemap;\n-use syntax::parse::token;\n use syntax::parse::token::IdentInterner;\n-use syntax::util::small_vector::SmallVector;\n \n pub use middle::cstore::{NativeLibraryKind, LinkagePreference};\n pub use middle::cstore::{NativeStatic, NativeFramework, NativeUnknown};\n@@ -63,13 +61,16 @@ pub struct ImportedFileMap {\n \n pub struct crate_metadata {\n     pub name: String,\n-    pub local_path: RefCell<SmallVector<ast_map::PathElem>>,\n-    pub local_def_path: RefCell<ast_map::DefPath>,\n+\n+    /// Information about the extern crate that caused this crate to\n+    /// be loaded. If this is `None`, then the crate was injected\n+    /// (e.g., by the allocator)\n+    pub extern_crate: Cell<Option<ExternCrate>>,\n+\n     pub data: MetadataBlob,\n     pub cnum_map: RefCell<cnum_map>,\n     pub cnum: ast::CrateNum,\n     pub codemap_import_info: RefCell<Vec<ImportedFileMap>>,\n-    pub span: codemap::Span,\n     pub staged_api: bool,\n \n     pub index: index::Index,\n@@ -268,50 +269,6 @@ impl crate_metadata {\n         }\n     }\n \n-    pub fn with_local_path<T, F>(&self, f: F) -> T\n-        where F: Fn(&[ast_map::PathElem]) -> T\n-    {\n-        let cpath = self.local_path.borrow();\n-        if cpath.is_empty() {\n-            let name = ast_map::PathMod(token::intern(&self.name));\n-            f(&[name])\n-        } else {\n-            f(cpath.as_slice())\n-        }\n-    }\n-\n-    pub fn update_local_path<'a, 'b>(&self, candidate: ast_map::PathElems<'a, 'b>) {\n-        let mut cpath = self.local_path.borrow_mut();\n-        let cap = cpath.len();\n-        match cap {\n-            0 => *cpath = candidate.collect(),\n-            1 => (),\n-            _ => {\n-                let candidate: SmallVector<_> = candidate.collect();\n-                if candidate.len() < cap {\n-                    *cpath = candidate;\n-                }\n-            },\n-        }\n-    }\n-\n-    pub fn local_def_path(&self) -> ast_map::DefPath {\n-        let local_def_path = self.local_def_path.borrow();\n-        if local_def_path.is_empty() {\n-            let name = ast_map::DefPathData::DetachedCrate(token::intern(&self.name));\n-            vec![ast_map::DisambiguatedDefPathData { data: name, disambiguator: 0 }]\n-        } else {\n-            local_def_path.clone()\n-        }\n-    }\n-\n-    pub fn update_local_def_path(&self, candidate: ast_map::DefPath) {\n-        let mut local_def_path = self.local_def_path.borrow_mut();\n-        if local_def_path.is_empty() || candidate.len() < local_def_path.len() {\n-            *local_def_path = candidate;\n-        }\n-    }\n-\n     pub fn is_allocator(&self) -> bool {\n         let attrs = decoder::get_crate_attributes(self.data());\n         attr::contains_name(&attrs, \"allocator\")"}, {"sha": "561248fc703f3fc01b55860ecb38851560efd01b", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ab9b8441468aed505f83a2ddf74454f9cdfeab33/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab9b8441468aed505f83a2ddf74454f9cdfeab33/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=ab9b8441468aed505f83a2ddf74454f9cdfeab33", "patch": "@@ -1763,7 +1763,9 @@ pub fn closure_ty<'tcx>(cdata: Cmd, closure_id: DefIndex, tcx: &TyCtxt<'tcx>)\n         .parse_closure_ty()\n }\n \n-fn def_key(item_doc: rbml::Doc) -> hir_map::DefKey {\n+pub fn def_key(cdata: Cmd, id: DefIndex) -> hir_map::DefKey {\n+    debug!(\"def_key: id={:?}\", id);\n+    let item_doc = cdata.lookup_item(id);\n     match reader::maybe_get_doc(item_doc, tag_def_key) {\n         Some(def_key_doc) => {\n             let mut decoder = reader::Decoder::new(def_key_doc);"}]}