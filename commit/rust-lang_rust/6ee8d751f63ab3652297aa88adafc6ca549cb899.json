{"sha": "6ee8d751f63ab3652297aa88adafc6ca549cb899", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZlZThkNzUxZjYzYWIzNjUyMjk3YWE4OGFkYWZjNmNhNTQ5Y2I4OTk=", "commit": {"author": {"name": "Matthias Seiffert", "email": "matthias-seiffert@hotmail.de", "date": "2019-10-07T20:08:00Z"}, "committer": {"name": "Matthias Seiffert", "email": "matthias-seiffert@hotmail.de", "date": "2019-10-07T20:08:00Z"}, "message": "Reduce duplication", "tree": {"sha": "1eba79c4bb5340b64cce621db7c4f2e308e43310", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1eba79c4bb5340b64cce621db7c4f2e308e43310"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6ee8d751f63ab3652297aa88adafc6ca549cb899", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6ee8d751f63ab3652297aa88adafc6ca549cb899", "html_url": "https://github.com/rust-lang/rust/commit/6ee8d751f63ab3652297aa88adafc6ca549cb899", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6ee8d751f63ab3652297aa88adafc6ca549cb899/comments", "author": {"login": "Lythenas", "id": 32217236, "node_id": "MDQ6VXNlcjMyMjE3MjM2", "avatar_url": "https://avatars.githubusercontent.com/u/32217236?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Lythenas", "html_url": "https://github.com/Lythenas", "followers_url": "https://api.github.com/users/Lythenas/followers", "following_url": "https://api.github.com/users/Lythenas/following{/other_user}", "gists_url": "https://api.github.com/users/Lythenas/gists{/gist_id}", "starred_url": "https://api.github.com/users/Lythenas/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Lythenas/subscriptions", "organizations_url": "https://api.github.com/users/Lythenas/orgs", "repos_url": "https://api.github.com/users/Lythenas/repos", "events_url": "https://api.github.com/users/Lythenas/events{/privacy}", "received_events_url": "https://api.github.com/users/Lythenas/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Lythenas", "id": 32217236, "node_id": "MDQ6VXNlcjMyMjE3MjM2", "avatar_url": "https://avatars.githubusercontent.com/u/32217236?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Lythenas", "html_url": "https://github.com/Lythenas", "followers_url": "https://api.github.com/users/Lythenas/followers", "following_url": "https://api.github.com/users/Lythenas/following{/other_user}", "gists_url": "https://api.github.com/users/Lythenas/gists{/gist_id}", "starred_url": "https://api.github.com/users/Lythenas/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Lythenas/subscriptions", "organizations_url": "https://api.github.com/users/Lythenas/orgs", "repos_url": "https://api.github.com/users/Lythenas/repos", "events_url": "https://api.github.com/users/Lythenas/events{/privacy}", "received_events_url": "https://api.github.com/users/Lythenas/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "22f057972f6b8ae3b6df47c70ba1d610c13f4218", "url": "https://api.github.com/repos/rust-lang/rust/commits/22f057972f6b8ae3b6df47c70ba1d610c13f4218", "html_url": "https://github.com/rust-lang/rust/commit/22f057972f6b8ae3b6df47c70ba1d610c13f4218"}], "stats": {"total": 123, "additions": 59, "deletions": 64}, "files": [{"sha": "3f84f322500f1498ceac1e2bd6bafa8969e791a4", "filename": "clippy_lints/src/assertions_on_constants.rs", "status": "modified", "additions": 59, "deletions": 64, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/6ee8d751f63ab3652297aa88adafc6ca549cb899/clippy_lints%2Fsrc%2Fassertions_on_constants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ee8d751f63ab3652297aa88adafc6ca549cb899/clippy_lints%2Fsrc%2Fassertions_on_constants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fassertions_on_constants.rs?ref=6ee8d751f63ab3652297aa88adafc6ca549cb899", "patch": "@@ -1,12 +1,11 @@\n use crate::consts::{constant, Constant};\n use crate::utils::paths;\n-use crate::utils::{is_direct_expn_of, is_expn_of, match_def_path, span_help_and_lint, snippet};\n+use crate::utils::{is_direct_expn_of, is_expn_of, match_def_path, snippet_opt, span_help_and_lint};\n use if_chain::if_chain;\n use rustc::hir::*;\n use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use rustc::{declare_lint_pass, declare_tool_lint};\n use syntax::ast::LitKind;\n-use std::borrow::Cow;\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for `assert!(true)` and `assert!(false)` calls.\n@@ -34,72 +33,68 @@ declare_lint_pass!(AssertionsOnConstants => [ASSERTIONS_ON_CONSTANTS]);\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for AssertionsOnConstants {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr) {\n-        let lint_assert_cb = |is_debug_assert: bool| {\n-            if let ExprKind::Unary(_, ref lit) = e.kind {\n-                if let Some((Constant::Bool(is_true), _)) = constant(cx, cx.tables, lit) {\n-                    if is_true {\n-                        span_help_and_lint(\n-                            cx,\n-                            ASSERTIONS_ON_CONSTANTS,\n-                            e.span,\n-                            \"`assert!(true)` will be optimized out by the compiler\",\n-                            \"remove it\",\n-                        );\n-                    } else if !is_debug_assert {\n-                        span_help_and_lint(\n-                            cx,\n-                            ASSERTIONS_ON_CONSTANTS,\n-                            e.span,\n-                            \"`assert!(false)` should probably be replaced\",\n-                            \"use `panic!()` or `unreachable!()`\",\n-                        );\n-                    }\n-                }\n-            }\n+        let lint_true = || {\n+            span_help_and_lint(\n+                cx,\n+                ASSERTIONS_ON_CONSTANTS,\n+                e.span,\n+                \"`assert!(true)` will be optimized out by the compiler\",\n+                \"remove it\",\n+            );\n+        };\n+        let lint_false_without_message = || {\n+            span_help_and_lint(\n+                cx,\n+                ASSERTIONS_ON_CONSTANTS,\n+                e.span,\n+                \"`assert!(false)` should probably be replaced\",\n+                \"use `panic!()` or `unreachable!()`\",\n+            );\n         };\n+        let lint_false_with_message = |panic_message: String| {\n+            span_help_and_lint(\n+                cx,\n+                ASSERTIONS_ON_CONSTANTS,\n+                e.span,\n+                &format!(\"`assert!(false, {})` should probably be replaced\", panic_message),\n+                &format!(\"use `panic!({})` or `unreachable!({})`\", panic_message, panic_message),\n+            )\n+        };\n+\n         if let Some(debug_assert_span) = is_expn_of(e.span, \"debug_assert\") {\n             if debug_assert_span.from_expansion() {\n                 return;\n             }\n-            lint_assert_cb(true);\n+            if_chain! {\n+                if let ExprKind::Unary(_, ref lit) = e.kind;\n+                if let Some((Constant::Bool(is_true), _)) = constant(cx, cx.tables, lit);\n+                if is_true;\n+                then {\n+                    lint_true();\n+                }\n+            };\n         } else if let Some(assert_span) = is_direct_expn_of(e.span, \"assert\") {\n             if assert_span.from_expansion() {\n                 return;\n             }\n-            if let Some((panic_message, is_true)) = assert_with_message(&cx, e) {\n-                if is_true {\n-                    span_help_and_lint(\n-                        cx,\n-                        ASSERTIONS_ON_CONSTANTS,\n-                        e.span,\n-                        \"`assert!(true)` will be optimized out by the compiler\",\n-                        \"remove it\",\n-                    );\n-                } else if panic_message.is_empty() || panic_message.starts_with(\"\\\"assertion failed: \") {\n-                    span_help_and_lint(\n-                        cx,\n-                        ASSERTIONS_ON_CONSTANTS,\n-                        e.span,\n-                        \"`assert!(false)` should probably be replaced\",\n-                        \"use `panic!()` or `unreachable!()`\",\n-                    );\n-                } else {\n-                    span_help_and_lint(\n-                        cx,\n-                        ASSERTIONS_ON_CONSTANTS,\n-                        e.span,\n-                        &format!(\"`assert!(false, {})` should probably be replaced\", panic_message,),\n-                        &format!(\n-                            \"use `panic!({})` or `unreachable!({})`\",\n-                            panic_message, panic_message,\n-                        ),\n-                    );\n-                }\n+            if let Some(assert_match) = match_assert_with_message(&cx, e) {\n+                match assert_match {\n+                    // matched assert but not message\n+                    AssertKind::WithoutMessage(false) => lint_false_without_message(),\n+                    AssertKind::WithoutMessage(true) | AssertKind::WithMessage(_, true) => lint_true(),\n+                    AssertKind::WithMessage(panic_message, false) => lint_false_with_message(panic_message),\n+                };\n             }\n         }\n     }\n }\n \n+/// Result of calling `match_assert_with_message`.\n+enum AssertKind {\n+    WithMessage(String, bool),\n+    WithoutMessage(bool),\n+}\n+\n /// Check if the expression matches\n ///\n /// ```rust,ignore\n@@ -113,13 +108,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for AssertionsOnConstants {\n /// };\n /// ```\n ///\n-/// where `message` is a string literal and `c` is a constant bool.\n-///\n-/// TODO extend this to match anything as message not just string literals\n-///\n-/// Returns the `message` argument of `begin_panic` and the value of `c` which is the\n-/// first argument of `assert!`.\n-fn assert_with_message<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) -> Option<(Cow<'a, str>, bool)> {\n+/// where `message` is any expression and `c` is a constant bool.\n+fn match_assert_with_message<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) -> Option<AssertKind> {\n     if_chain! {\n         if let ExprKind::Match(ref expr, ref arms, _) = expr.kind;\n         // matches { let _t = expr; _t }\n@@ -140,12 +130,17 @@ fn assert_with_message<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) -\n         // function call\n         if let Some(args) = match_function_call(cx, begin_panic_call, &paths::BEGIN_PANIC);\n         if args.len() == 2;\n-        // bind the second argument of the `assert!` macro\n-        let panic_message_arg = snippet(cx, args[0].span, \"..\");\n+        // bind the second argument of the `assert!` macro if it exists\n+        if let panic_message = snippet_opt(cx, args[0].span);\n         // second argument of begin_panic is irrelevant\n         // as is the second match arm\n         then {\n-            return Some((panic_message_arg, is_true));\n+            // an empty message occurs when it was generated by the macro\n+            // (and not passed by the user)\n+            return panic_message\n+                .filter(|msg| !msg.is_empty())\n+                .map(|msg| AssertKind::WithMessage(msg, is_true))\n+                .or(Some(AssertKind::WithoutMessage(is_true)));\n         }\n     }\n     None"}]}