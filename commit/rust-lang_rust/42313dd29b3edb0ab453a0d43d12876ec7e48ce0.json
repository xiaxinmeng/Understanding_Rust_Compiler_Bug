{"sha": "42313dd29b3edb0ab453a0d43d12876ec7e48ce0", "node_id": "C_kwDOAAsO6NoAKDQyMzEzZGQyOWIzZWRiMGFiNDUzYTBkNDNkMTI4NzZlYzdlNDhjZTA", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-01-23T23:09:23Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-01-23T23:09:23Z"}, "message": "Auto merge of #93245 - matthiaskrgr:rollup-djsi6jr, r=matthiaskrgr\n\nRollup of 8 pull requests\n\nSuccessful merges:\n\n - #91526 (rustc_lint: Some early linting refactorings)\n - #92555 (Implement RFC 3151: Scoped threads.)\n - #93213 (Fix `let_chains` and `if_let_guard` feature flags)\n - #93219 (Add preliminary support for inline assembly for msp430.)\n - #93226 (Normalize field access types during borrowck)\n - #93227 (Liberate late bound regions when collecting GAT substs in wfcheck)\n - #93229 (Remove DiagnosticBuilder.quiet)\n - #93234 (rustc_mir_itertools: Avoid needless `collect` with itertools)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "94efb537a260c94c6fcd5f45d2583dc8cad8e719", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/94efb537a260c94c6fcd5f45d2583dc8cad8e719"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/42313dd29b3edb0ab453a0d43d12876ec7e48ce0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/42313dd29b3edb0ab453a0d43d12876ec7e48ce0", "html_url": "https://github.com/rust-lang/rust/commit/42313dd29b3edb0ab453a0d43d12876ec7e48ce0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/42313dd29b3edb0ab453a0d43d12876ec7e48ce0/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "84322efad553c7a79c80189f2d1b9197c1aa005f", "url": "https://api.github.com/repos/rust-lang/rust/commits/84322efad553c7a79c80189f2d1b9197c1aa005f", "html_url": "https://github.com/rust-lang/rust/commit/84322efad553c7a79c80189f2d1b9197c1aa005f"}, {"sha": "eea833f5f1d0de940c0759cc365cef7624a732df", "url": "https://api.github.com/repos/rust-lang/rust/commits/eea833f5f1d0de940c0759cc365cef7624a732df", "html_url": "https://github.com/rust-lang/rust/commit/eea833f5f1d0de940c0759cc365cef7624a732df"}], "stats": {"total": 1466, "additions": 1136, "deletions": 330}, "files": [{"sha": "73103643e3e16f2253edb83e036f440c25aa8930", "filename": "compiler/rustc_borrowck/src/type_check/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/42313dd29b3edb0ab453a0d43d12876ec7e48ce0/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42313dd29b3edb0ab453a0d43d12876ec7e48ce0/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs?ref=42313dd29b3edb0ab453a0d43d12876ec7e48ce0", "patch": "@@ -758,6 +758,7 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n             },\n             ProjectionElem::Field(field, fty) => {\n                 let fty = self.sanitize_type(place, fty);\n+                let fty = self.cx.normalize(fty, location);\n                 match self.field_ty(place, base, field, location) {\n                     Ok(ty) => {\n                         let ty = self.cx.normalize(ty, location);"}, {"sha": "8a74c4c07e0cf2ba331aec30a9839942b7ce0d99", "filename": "compiler/rustc_codegen_gcc/src/asm.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/42313dd29b3edb0ab453a0d43d12876ec7e48ce0/compiler%2Frustc_codegen_gcc%2Fsrc%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42313dd29b3edb0ab453a0d43d12876ec7e48ce0/compiler%2Frustc_codegen_gcc%2Fsrc%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fasm.rs?ref=42313dd29b3edb0ab453a0d43d12876ec7e48ce0", "patch": "@@ -560,6 +560,7 @@ fn reg_to_gcc(reg: InlineAsmRegOrRegClass) -> ConstraintOrRegister {\n             InlineAsmRegClass::Hexagon(HexagonInlineAsmRegClass::reg) => unimplemented!(),\n             InlineAsmRegClass::Mips(MipsInlineAsmRegClass::reg) => unimplemented!(),\n             InlineAsmRegClass::Mips(MipsInlineAsmRegClass::freg) => unimplemented!(),\n+            InlineAsmRegClass::Msp430(_) => unimplemented!(),\n             InlineAsmRegClass::Nvptx(NvptxInlineAsmRegClass::reg16) => unimplemented!(),\n             InlineAsmRegClass::Nvptx(NvptxInlineAsmRegClass::reg32) => unimplemented!(),\n             InlineAsmRegClass::Nvptx(NvptxInlineAsmRegClass::reg64) => unimplemented!(),\n@@ -622,6 +623,7 @@ fn dummy_output_type<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, reg: InlineAsmRegCl\n         InlineAsmRegClass::Hexagon(HexagonInlineAsmRegClass::reg) => cx.type_i32(),\n         InlineAsmRegClass::Mips(MipsInlineAsmRegClass::reg) => cx.type_i32(),\n         InlineAsmRegClass::Mips(MipsInlineAsmRegClass::freg) => cx.type_f32(),\n+        InlineAsmRegClass::Msp430(_) => unimplemented!(),\n         InlineAsmRegClass::Nvptx(NvptxInlineAsmRegClass::reg16) => cx.type_i16(),\n         InlineAsmRegClass::Nvptx(NvptxInlineAsmRegClass::reg32) => cx.type_i32(),\n         InlineAsmRegClass::Nvptx(NvptxInlineAsmRegClass::reg64) => cx.type_i64(),\n@@ -729,6 +731,7 @@ fn modifier_to_gcc(arch: InlineAsmArch, reg: InlineAsmRegClass, modifier: Option\n         InlineAsmRegClass::Bpf(_) => unimplemented!(),\n         InlineAsmRegClass::Hexagon(_) => unimplemented!(),\n         InlineAsmRegClass::Mips(_) => unimplemented!(),\n+        InlineAsmRegClass::Msp430(_) => unimplemented!(),\n         InlineAsmRegClass::Nvptx(_) => unimplemented!(),\n         InlineAsmRegClass::PowerPC(_) => unimplemented!(),\n         InlineAsmRegClass::RiscV(RiscVInlineAsmRegClass::reg)"}, {"sha": "e22bec249513d1c13d5bdb98672c10def01c2ec5", "filename": "compiler/rustc_codegen_llvm/src/asm.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/42313dd29b3edb0ab453a0d43d12876ec7e48ce0/compiler%2Frustc_codegen_llvm%2Fsrc%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42313dd29b3edb0ab453a0d43d12876ec7e48ce0/compiler%2Frustc_codegen_llvm%2Fsrc%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fasm.rs?ref=42313dd29b3edb0ab453a0d43d12876ec7e48ce0", "patch": "@@ -232,6 +232,9 @@ impl<'ll, 'tcx> AsmBuilderMethods<'tcx> for Builder<'_, 'll, 'tcx> {\n                 InlineAsmArch::SpirV => {}\n                 InlineAsmArch::Wasm32 | InlineAsmArch::Wasm64 => {}\n                 InlineAsmArch::Bpf => {}\n+                InlineAsmArch::Msp430 => {\n+                    constraints.push(\"~{sr}\".to_string());\n+                }\n             }\n         }\n         if !options.contains(InlineAsmOptions::NOMEM) {\n@@ -580,6 +583,7 @@ fn reg_to_llvm(reg: InlineAsmRegOrRegClass, layout: Option<&TyAndLayout<'_>>) ->\n             InlineAsmRegClass::Avr(AvrInlineAsmRegClass::reg_ptr) => \"e\",\n             InlineAsmRegClass::S390x(S390xInlineAsmRegClass::reg) => \"r\",\n             InlineAsmRegClass::S390x(S390xInlineAsmRegClass::freg) => \"f\",\n+            InlineAsmRegClass::Msp430(Msp430InlineAsmRegClass::reg) => \"r\",\n             InlineAsmRegClass::SpirV(SpirVInlineAsmRegClass::reg) => {\n                 bug!(\"LLVM backend does not support SPIR-V\")\n             }\n@@ -666,6 +670,7 @@ fn modifier_to_llvm(\n         },\n         InlineAsmRegClass::Avr(_) => None,\n         InlineAsmRegClass::S390x(_) => None,\n+        InlineAsmRegClass::Msp430(_) => None,\n         InlineAsmRegClass::SpirV(SpirVInlineAsmRegClass::reg) => {\n             bug!(\"LLVM backend does not support SPIR-V\")\n         }\n@@ -734,6 +739,7 @@ fn dummy_output_type<'ll>(cx: &CodegenCx<'ll, '_>, reg: InlineAsmRegClass) -> &'\n         InlineAsmRegClass::Avr(AvrInlineAsmRegClass::reg_ptr) => cx.type_i16(),\n         InlineAsmRegClass::S390x(S390xInlineAsmRegClass::reg) => cx.type_i32(),\n         InlineAsmRegClass::S390x(S390xInlineAsmRegClass::freg) => cx.type_f64(),\n+        InlineAsmRegClass::Msp430(Msp430InlineAsmRegClass::reg) => cx.type_i16(),\n         InlineAsmRegClass::SpirV(SpirVInlineAsmRegClass::reg) => {\n             bug!(\"LLVM backend does not support SPIR-V\")\n         }"}, {"sha": "16e9b265d69d57490dd9b2ca78dd1efbc248a15c", "filename": "compiler/rustc_errors/src/lib.rs", "status": "modified", "additions": 1, "deletions": 16, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/42313dd29b3edb0ab453a0d43d12876ec7e48ce0/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42313dd29b3edb0ab453a0d43d12876ec7e48ce0/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Flib.rs?ref=42313dd29b3edb0ab453a0d43d12876ec7e48ce0", "patch": "@@ -445,9 +445,6 @@ struct HandlerInner {\n     deduplicated_warn_count: usize,\n \n     future_breakage_diagnostics: Vec<Diagnostic>,\n-\n-    /// If set to `true`, no warning or error will be emitted.\n-    quiet: bool,\n }\n \n /// A key denoting where from a diagnostic was stashed.\n@@ -563,19 +560,10 @@ impl Handler {\n                 emitted_diagnostics: Default::default(),\n                 stashed_diagnostics: Default::default(),\n                 future_breakage_diagnostics: Vec::new(),\n-                quiet: false,\n             }),\n         }\n     }\n \n-    pub fn with_disabled_diagnostic<T, F: FnOnce() -> T>(&self, f: F) -> T {\n-        let prev = self.inner.borrow_mut().quiet;\n-        self.inner.borrow_mut().quiet = true;\n-        let ret = f();\n-        self.inner.borrow_mut().quiet = prev;\n-        ret\n-    }\n-\n     // This is here to not allow mutation of flags;\n     // as of this writing it's only used in tests in librustc_middle.\n     pub fn can_emit_warnings(&self) -> bool {\n@@ -946,7 +934,7 @@ impl HandlerInner {\n     }\n \n     fn emit_diagnostic(&mut self, diagnostic: &Diagnostic) {\n-        if diagnostic.cancelled() || self.quiet {\n+        if diagnostic.cancelled() {\n             return;\n         }\n \n@@ -1170,9 +1158,6 @@ impl HandlerInner {\n     }\n \n     fn delay_as_bug(&mut self, diagnostic: Diagnostic) {\n-        if self.quiet {\n-            return;\n-        }\n         if self.flags.report_delayed_bugs {\n             self.emit_diagnostic(&diagnostic);\n         }"}, {"sha": "258320aeb636ad5403e4bb7ec4963fcfa005b249", "filename": "compiler/rustc_expand/src/base.rs", "status": "modified", "additions": 22, "deletions": 10, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/42313dd29b3edb0ab453a0d43d12876ec7e48ce0/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42313dd29b3edb0ab453a0d43d12876ec7e48ce0/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fbase.rs?ref=42313dd29b3edb0ab453a0d43d12876ec7e48ce0", "patch": "@@ -8,7 +8,7 @@ use rustc_ast::tokenstream::{CanSynthesizeMissingTokens, TokenStream};\n use rustc_ast::visit::{AssocCtxt, Visitor};\n use rustc_ast::{self as ast, AstLike, Attribute, Item, NodeId, PatKind};\n use rustc_attr::{self as attr, Deprecation, Stability};\n-use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::sync::{self, Lrc};\n use rustc_errors::{Applicability, DiagnosticBuilder, ErrorReported};\n use rustc_lint_defs::builtin::PROC_MACRO_BACK_COMPAT;\n@@ -920,8 +920,25 @@ pub trait ResolverExpand {\n     /// we generated proc macros harnesses, so that we can map\n     /// HIR proc macros items back to their harness items.\n     fn declare_proc_macro(&mut self, id: NodeId);\n+\n+    /// Tools registered with `#![register_tool]` and used by tool attributes and lints.\n+    fn registered_tools(&self) -> &FxHashSet<Ident>;\n }\n \n+pub trait LintStoreExpand {\n+    fn pre_expansion_lint(\n+        &self,\n+        sess: &Session,\n+        registered_tools: &FxHashSet<Ident>,\n+        node_id: NodeId,\n+        attrs: &[Attribute],\n+        items: &[P<Item>],\n+        name: &str,\n+    );\n+}\n+\n+type LintStoreExpandDyn<'a> = Option<&'a (dyn LintStoreExpand + 'a)>;\n+\n #[derive(Clone, Default)]\n pub struct ModuleData {\n     /// Path to the module starting from the crate name, like `my_crate::foo::bar`.\n@@ -956,9 +973,6 @@ pub struct ExpansionData {\n     pub is_trailing_mac: bool,\n }\n \n-type OnExternModLoaded<'a> =\n-    Option<&'a dyn Fn(Ident, Vec<Attribute>, Vec<P<Item>>, Span) -> (Vec<Attribute>, Vec<P<Item>>)>;\n-\n /// One of these is made during expansion and incrementally updated as we go;\n /// when a macro expansion occurs, the resulting nodes have the `backtrace()\n /// -> expn_data` of their expansion context stored into their span.\n@@ -973,10 +987,8 @@ pub struct ExtCtxt<'a> {\n     /// (or during eager expansion, but that's a hack).\n     pub force_mode: bool,\n     pub expansions: FxHashMap<Span, Vec<String>>,\n-    /// Called directly after having parsed an external `mod foo;` in expansion.\n-    ///\n-    /// `Ident` is the module name.\n-    pub(super) extern_mod_loaded: OnExternModLoaded<'a>,\n+    /// Used for running pre-expansion lints on freshly loaded modules.\n+    pub(super) lint_store: LintStoreExpandDyn<'a>,\n     /// When we 'expand' an inert attribute, we leave it\n     /// in the AST, but insert it here so that we know\n     /// not to expand it again.\n@@ -988,14 +1000,14 @@ impl<'a> ExtCtxt<'a> {\n         sess: &'a Session,\n         ecfg: expand::ExpansionConfig<'a>,\n         resolver: &'a mut dyn ResolverExpand,\n-        extern_mod_loaded: OnExternModLoaded<'a>,\n+        lint_store: LintStoreExpandDyn<'a>,\n     ) -> ExtCtxt<'a> {\n         ExtCtxt {\n             sess,\n             ecfg,\n             reduced_recursion_limit: None,\n             resolver,\n-            extern_mod_loaded,\n+            lint_store,\n             root_path: PathBuf::new(),\n             current_expansion: ExpansionData {\n                 id: LocalExpnId::ROOT,"}, {"sha": "9a4daa6d7500a57565fd4dd94316a4f6c7c0b675", "filename": "compiler/rustc_expand/src/expand.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/42313dd29b3edb0ab453a0d43d12876ec7e48ce0/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42313dd29b3edb0ab453a0d43d12876ec7e48ce0/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs?ref=42313dd29b3edb0ab453a0d43d12876ec7e48ce0", "patch": "@@ -1097,7 +1097,7 @@ impl InvocationCollectorNode for P<ast::Item> {\n             ModKind::Unloaded => {\n                 // We have an outline `mod foo;` so we need to parse the file.\n                 let old_attrs_len = attrs.len();\n-                let ParsedExternalMod { mut items, inner_span, file_path, dir_path, dir_ownership } =\n+                let ParsedExternalMod { items, inner_span, file_path, dir_path, dir_ownership } =\n                     parse_external_mod(\n                         &ecx.sess,\n                         ident,\n@@ -1107,8 +1107,15 @@ impl InvocationCollectorNode for P<ast::Item> {\n                         &mut attrs,\n                     );\n \n-                if let Some(extern_mod_loaded) = ecx.extern_mod_loaded {\n-                    (attrs, items) = extern_mod_loaded(ident, attrs, items, inner_span);\n+                if let Some(lint_store) = ecx.lint_store {\n+                    lint_store.pre_expansion_lint(\n+                        ecx.sess,\n+                        ecx.resolver.registered_tools(),\n+                        ecx.current_expansion.lint_node_id,\n+                        &attrs,\n+                        &items,\n+                        ident.name.as_str(),\n+                    );\n                 }\n \n                 *mod_kind = ModKind::Loaded(items, Inline::No, inner_span);"}, {"sha": "be31eb89f1b92b67a4a9bcaf1dcb5349c6343f43", "filename": "compiler/rustc_interface/src/passes.rs", "status": "modified", "additions": 40, "deletions": 27, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/42313dd29b3edb0ab453a0d43d12876ec7e48ce0/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42313dd29b3edb0ab453a0d43d12876ec7e48ce0/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs?ref=42313dd29b3edb0ab453a0d43d12876ec7e48ce0", "patch": "@@ -3,24 +3,24 @@ use crate::proc_macro_decls;\n use crate::util;\n \n use rustc_ast::mut_visit::MutVisitor;\n-use rustc_ast::{self as ast, visit, DUMMY_NODE_ID};\n+use rustc_ast::{self as ast, visit};\n use rustc_borrowck as mir_borrowck;\n use rustc_codegen_ssa::back::link::emit_metadata;\n use rustc_codegen_ssa::traits::CodegenBackend;\n use rustc_data_structures::parallel;\n use rustc_data_structures::sync::{Lrc, OnceCell, WorkerLocal};\n use rustc_data_structures::temp_dir::MaybeTempDir;\n use rustc_errors::{Applicability, ErrorReported, PResult};\n-use rustc_expand::base::ExtCtxt;\n+use rustc_expand::base::{ExtCtxt, LintStoreExpand, ResolverExpand};\n use rustc_hir::def_id::{StableCrateId, LOCAL_CRATE};\n use rustc_hir::Crate;\n-use rustc_lint::LintStore;\n+use rustc_lint::{EarlyCheckNode, LintStore};\n use rustc_metadata::creader::CStore;\n use rustc_metadata::{encode_metadata, EncodedMetadata};\n use rustc_middle::arena::Arena;\n use rustc_middle::dep_graph::DepGraph;\n use rustc_middle::ty::query::{ExternProviders, Providers};\n-use rustc_middle::ty::{self, GlobalCtxt, ResolverOutputs, TyCtxt};\n+use rustc_middle::ty::{self, GlobalCtxt, RegisteredTools, ResolverOutputs, TyCtxt};\n use rustc_mir_build as mir_build;\n use rustc_parse::{parse_crate_from_file, parse_crate_from_source_str, validate_attr};\n use rustc_passes::{self, hir_stats, layout_test};\n@@ -34,7 +34,7 @@ use rustc_session::lint;\n use rustc_session::output::{filename_for_input, filename_for_metadata};\n use rustc_session::search_paths::PathKind;\n use rustc_session::{Limit, Session};\n-use rustc_span::symbol::{sym, Ident, Symbol};\n+use rustc_span::symbol::{sym, Symbol};\n use rustc_span::{FileName, MultiSpan};\n use rustc_trait_selection::traits;\n use rustc_typeck as typeck;\n@@ -233,26 +233,43 @@ pub fn register_plugins<'a>(\n     Ok((krate, lint_store))\n }\n \n-fn pre_expansion_lint(\n+fn pre_expansion_lint<'a>(\n     sess: &Session,\n     lint_store: &LintStore,\n-    krate: &ast::Crate,\n-    crate_attrs: &[ast::Attribute],\n-    crate_name: &str,\n+    registered_tools: &RegisteredTools,\n+    check_node: impl EarlyCheckNode<'a>,\n+    node_name: &str,\n ) {\n-    sess.prof.generic_activity_with_arg(\"pre_AST_expansion_lint_checks\", crate_name).run(|| {\n-        rustc_lint::check_ast_crate(\n+    sess.prof.generic_activity_with_arg(\"pre_AST_expansion_lint_checks\", node_name).run(|| {\n+        rustc_lint::check_ast_node(\n             sess,\n-            lint_store,\n-            krate,\n-            crate_attrs,\n             true,\n+            lint_store,\n+            registered_tools,\n             None,\n             rustc_lint::BuiltinCombinedPreExpansionLintPass::new(),\n+            check_node,\n         );\n     });\n }\n \n+// Cannot implement directly for `LintStore` due to trait coherence.\n+struct LintStoreExpandImpl<'a>(&'a LintStore);\n+\n+impl LintStoreExpand for LintStoreExpandImpl<'_> {\n+    fn pre_expansion_lint(\n+        &self,\n+        sess: &Session,\n+        registered_tools: &RegisteredTools,\n+        node_id: ast::NodeId,\n+        attrs: &[ast::Attribute],\n+        items: &[rustc_ast::ptr::P<ast::Item>],\n+        name: &str,\n+    ) {\n+        pre_expansion_lint(sess, self.0, registered_tools, (node_id, attrs, items), name);\n+    }\n+}\n+\n /// Runs the \"early phases\" of the compiler: initial `cfg` processing, loading compiler plugins,\n /// syntax expansion, secondary `cfg` expansion, synthesis of a test\n /// harness if one is to be provided, injection of a dependency on the\n@@ -265,7 +282,7 @@ pub fn configure_and_expand(\n     resolver: &mut Resolver<'_>,\n ) -> Result<ast::Crate> {\n     tracing::trace!(\"configure_and_expand\");\n-    pre_expansion_lint(sess, lint_store, &krate, &krate.attrs, crate_name);\n+    pre_expansion_lint(sess, lint_store, resolver.registered_tools(), &krate, crate_name);\n     rustc_builtin_macros::register_builtin_macros(resolver);\n \n     krate = sess.time(\"crate_injection\", || {\n@@ -321,13 +338,8 @@ pub fn configure_and_expand(\n             ..rustc_expand::expand::ExpansionConfig::default(crate_name.to_string())\n         };\n \n-        let crate_attrs = krate.attrs.clone();\n-        let extern_mod_loaded = |ident: Ident, attrs, items, span| {\n-            let krate = ast::Crate { attrs, items, span, id: DUMMY_NODE_ID, is_placeholder: false };\n-            pre_expansion_lint(sess, lint_store, &krate, &crate_attrs, ident.name.as_str());\n-            (krate.attrs, krate.items)\n-        };\n-        let mut ecx = ExtCtxt::new(sess, cfg, resolver, Some(&extern_mod_loaded));\n+        let lint_store = LintStoreExpandImpl(lint_store);\n+        let mut ecx = ExtCtxt::new(sess, cfg, resolver, Some(&lint_store));\n \n         // Expand macros now!\n         let krate = sess.time(\"expand_crate\", || ecx.monotonic_expander().expand_crate(krate));\n@@ -499,14 +511,15 @@ pub fn lower_to_hir<'res, 'tcx>(\n     );\n \n     sess.time(\"early_lint_checks\", || {\n-        rustc_lint::check_ast_crate(\n+        let lint_buffer = Some(std::mem::take(resolver.lint_buffer()));\n+        rustc_lint::check_ast_node(\n             sess,\n-            lint_store,\n-            &krate,\n-            &krate.attrs,\n             false,\n-            Some(std::mem::take(resolver.lint_buffer())),\n+            lint_store,\n+            resolver.registered_tools(),\n+            lint_buffer,\n             rustc_lint::BuiltinCombinedEarlyLintPass::new(),\n+            &*krate,\n         )\n     });\n "}, {"sha": "24d295ee9fbf68f4383b6291b2dd9cc049d617b4", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/42313dd29b3edb0ab453a0d43d12876ec7e48ce0/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42313dd29b3edb0ab453a0d43d12876ec7e48ce0/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=42313dd29b3edb0ab453a0d43d12876ec7e48ce0", "patch": "@@ -912,7 +912,7 @@ declare_lint_pass!(\n \n impl EarlyLintPass for AnonymousParameters {\n     fn check_trait_item(&mut self, cx: &EarlyContext<'_>, it: &ast::AssocItem) {\n-        if cx.sess.edition() != Edition::Edition2015 {\n+        if cx.sess().edition() != Edition::Edition2015 {\n             // This is a hard error in future editions; avoid linting and erroring\n             return;\n         }\n@@ -921,7 +921,7 @@ impl EarlyLintPass for AnonymousParameters {\n                 if let ast::PatKind::Ident(_, ident, None) = arg.pat.kind {\n                     if ident.name == kw::Empty {\n                         cx.struct_span_lint(ANONYMOUS_PARAMETERS, arg.pat.span, |lint| {\n-                            let ty_snip = cx.sess.source_map().span_to_snippet(arg.ty.span);\n+                            let ty_snip = cx.sess().source_map().span_to_snippet(arg.ty.span);\n \n                             let (ty_snip, appl) = if let Ok(ref snip) = ty_snip {\n                                 (snip.as_str(), Applicability::MachineApplicable)\n@@ -1775,7 +1775,7 @@ impl EarlyLintPass for EllipsisInclusiveRangePatterns {\n                 };\n                 if join.edition() >= Edition::Edition2021 {\n                     let mut err =\n-                        rustc_errors::struct_span_err!(cx.sess, pat.span, E0783, \"{}\", msg,);\n+                        rustc_errors::struct_span_err!(cx.sess(), pat.span, E0783, \"{}\", msg,);\n                     err.span_suggestion(\n                         pat.span,\n                         suggestion,\n@@ -1799,7 +1799,7 @@ impl EarlyLintPass for EllipsisInclusiveRangePatterns {\n                 let replace = \"..=\".to_owned();\n                 if join.edition() >= Edition::Edition2021 {\n                     let mut err =\n-                        rustc_errors::struct_span_err!(cx.sess, pat.span, E0783, \"{}\", msg,);\n+                        rustc_errors::struct_span_err!(cx.sess(), pat.span, E0783, \"{}\", msg,);\n                     err.span_suggestion_short(\n                         join,\n                         suggestion,\n@@ -1983,7 +1983,7 @@ impl KeywordIdents {\n         UnderMacro(under_macro): UnderMacro,\n         ident: Ident,\n     ) {\n-        let next_edition = match cx.sess.edition() {\n+        let next_edition = match cx.sess().edition() {\n             Edition::Edition2015 => {\n                 match ident.name {\n                     kw::Async | kw::Await | kw::Try => Edition::Edition2018,\n@@ -2011,7 +2011,7 @@ impl KeywordIdents {\n         };\n \n         // Don't lint `r#foo`.\n-        if cx.sess.parse_sess.raw_identifier_spans.borrow().contains(&ident.span) {\n+        if cx.sess().parse_sess.raw_identifier_spans.borrow().contains(&ident.span) {\n             return;\n         }\n \n@@ -2379,7 +2379,7 @@ declare_lint_pass!(\n \n impl EarlyLintPass for IncompleteFeatures {\n     fn check_crate(&mut self, cx: &EarlyContext<'_>, _: &ast::Crate) {\n-        let features = cx.sess.features_untracked();\n+        let features = cx.sess().features_untracked();\n         features\n             .declared_lang_features\n             .iter()"}, {"sha": "35c0abd73ba86a708d5540802d1cdc75afffe49b", "filename": "compiler/rustc_lint/src/context.rs", "status": "modified", "additions": 25, "deletions": 32, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/42313dd29b3edb0ab453a0d43d12876ec7e48ce0/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42313dd29b3edb0ab453a0d43d12876ec7e48ce0/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs?ref=42313dd29b3edb0ab453a0d43d12876ec7e48ce0", "patch": "@@ -16,10 +16,9 @@\n \n use self::TargetLint::*;\n \n-use crate::levels::{is_known_lint_tool, LintLevelsBuilder};\n+use crate::levels::LintLevelsBuilder;\n use crate::passes::{EarlyLintPassObject, LateLintPassObject};\n-use ast::util::unicode::TEXT_FLOW_CONTROL_CHARS;\n-use rustc_ast as ast;\n+use rustc_ast::util::unicode::TEXT_FLOW_CONTROL_CHARS;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sync;\n use rustc_errors::{struct_span_err, Applicability, SuggestionStyle};\n@@ -32,13 +31,14 @@ use rustc_middle::middle::privacy::AccessLevels;\n use rustc_middle::middle::stability;\n use rustc_middle::ty::layout::{LayoutError, LayoutOfHelpers, TyAndLayout};\n use rustc_middle::ty::print::with_no_trimmed_paths;\n-use rustc_middle::ty::{self, print::Printer, subst::GenericArg, Ty, TyCtxt};\n+use rustc_middle::ty::{self, print::Printer, subst::GenericArg, RegisteredTools, Ty, TyCtxt};\n use rustc_serialize::json::Json;\n use rustc_session::lint::{BuiltinLintDiagnostics, ExternDepSpec};\n use rustc_session::lint::{FutureIncompatibleInfo, Level, Lint, LintBuffer, LintId};\n use rustc_session::Session;\n use rustc_span::lev_distance::find_best_match_for_name;\n-use rustc_span::{symbol::Symbol, BytePos, MultiSpan, Span, DUMMY_SP};\n+use rustc_span::symbol::{sym, Ident, Symbol};\n+use rustc_span::{BytePos, MultiSpan, Span, DUMMY_SP};\n use rustc_target::abi;\n use tracing::debug;\n \n@@ -313,7 +313,7 @@ impl LintStore {\n         sess: &Session,\n         lint_name: &str,\n         level: Level,\n-        crate_attrs: &[ast::Attribute],\n+        registered_tools: &RegisteredTools,\n     ) {\n         let (tool_name, lint_name_only) = parse_lint_and_tool_name(lint_name);\n         if lint_name_only == crate::WARNINGS.name_lower() && level == Level::ForceWarn {\n@@ -326,7 +326,7 @@ impl LintStore {\n             )\n             .emit();\n         }\n-        let db = match self.check_lint_name(sess, lint_name_only, tool_name, crate_attrs) {\n+        let db = match self.check_lint_name(lint_name_only, tool_name, registered_tools) {\n             CheckLintNameResult::Ok(_) => None,\n             CheckLintNameResult::Warning(ref msg, _) => Some(sess.struct_warn(msg)),\n             CheckLintNameResult::NoLint(suggestion) => {\n@@ -397,13 +397,16 @@ impl LintStore {\n     /// printing duplicate warnings.\n     pub fn check_lint_name(\n         &self,\n-        sess: &Session,\n         lint_name: &str,\n         tool_name: Option<Symbol>,\n-        crate_attrs: &[ast::Attribute],\n+        registered_tools: &RegisteredTools,\n     ) -> CheckLintNameResult<'_> {\n         if let Some(tool_name) = tool_name {\n-            if !is_known_lint_tool(tool_name, sess, crate_attrs) {\n+            // FIXME: rustc and rustdoc are considered tools for lints, but not for attributes.\n+            if tool_name != sym::rustc\n+                && tool_name != sym::rustdoc\n+                && !registered_tools.contains(&Ident::with_dummy_span(tool_name))\n+            {\n                 return CheckLintNameResult::NoTool;\n             }\n         }\n@@ -553,20 +556,9 @@ pub struct LateContext<'tcx> {\n     pub only_module: bool,\n }\n \n-/// Context for lint checking of the AST, after expansion, before lowering to\n-/// HIR.\n+/// Context for lint checking of the AST, after expansion, before lowering to HIR.\n pub struct EarlyContext<'a> {\n-    /// Type context we're checking in.\n-    pub sess: &'a Session,\n-\n-    /// The crate being checked.\n-    pub krate: &'a ast::Crate,\n-\n     pub builder: LintLevelsBuilder<'a>,\n-\n-    /// The store of registered lints and the lint levels.\n-    pub lint_store: &'a LintStore,\n-\n     pub buffered: LintBuffer,\n }\n \n@@ -801,19 +793,20 @@ pub trait LintContext: Sized {\n }\n \n impl<'a> EarlyContext<'a> {\n-    pub fn new(\n+    pub(crate) fn new(\n         sess: &'a Session,\n+        warn_about_weird_lints: bool,\n         lint_store: &'a LintStore,\n-        krate: &'a ast::Crate,\n-        crate_attrs: &'a [ast::Attribute],\n+        registered_tools: &'a RegisteredTools,\n         buffered: LintBuffer,\n-        warn_about_weird_lints: bool,\n     ) -> EarlyContext<'a> {\n         EarlyContext {\n-            sess,\n-            krate,\n-            lint_store,\n-            builder: LintLevelsBuilder::new(sess, warn_about_weird_lints, lint_store, crate_attrs),\n+            builder: LintLevelsBuilder::new(\n+                sess,\n+                warn_about_weird_lints,\n+                lint_store,\n+                registered_tools,\n+            ),\n             buffered,\n         }\n     }\n@@ -851,11 +844,11 @@ impl LintContext for EarlyContext<'_> {\n \n     /// Gets the overall compiler `Session` object.\n     fn sess(&self) -> &Session {\n-        &self.sess\n+        &self.builder.sess()\n     }\n \n     fn lints(&self) -> &LintStore {\n-        &*self.lint_store\n+        self.builder.lint_store()\n     }\n \n     fn lookup<S: Into<MultiSpan>>("}, {"sha": "1b2c88867d49dbe2822ff83ad1af5d59ea240b22", "filename": "compiler/rustc_lint/src/early.rs", "status": "modified", "additions": 85, "deletions": 42, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/42313dd29b3edb0ab453a0d43d12876ec7e48ce0/compiler%2Frustc_lint%2Fsrc%2Fearly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42313dd29b3edb0ab453a0d43d12876ec7e48ce0/compiler%2Frustc_lint%2Fsrc%2Fearly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fearly.rs?ref=42313dd29b3edb0ab453a0d43d12876ec7e48ce0", "patch": "@@ -16,9 +16,11 @@\n \n use crate::context::{EarlyContext, LintContext, LintStore};\n use crate::passes::{EarlyLintPass, EarlyLintPassObject};\n-use rustc_ast as ast;\n-use rustc_ast::visit as ast_visit;\n+use rustc_ast::ptr::P;\n+use rustc_ast::visit::{self as ast_visit, Visitor};\n use rustc_ast::AstLike;\n+use rustc_ast::{self as ast, walk_list};\n+use rustc_middle::ty::RegisteredTools;\n use rustc_session::lint::{BufferedEarlyLint, LintBuffer, LintPass};\n use rustc_session::Session;\n use rustc_span::symbol::Ident;\n@@ -31,7 +33,7 @@ macro_rules! run_early_pass { ($cx:expr, $f:ident, $($args:expr),*) => ({\n     $cx.pass.$f(&$cx.context, $($args),*);\n }) }\n \n-struct EarlyContextAndPass<'a, T: EarlyLintPass> {\n+pub struct EarlyContextAndPass<'a, T: EarlyLintPass> {\n     context: EarlyContext<'a>,\n     pass: T,\n }\n@@ -57,7 +59,7 @@ impl<'a, T: EarlyLintPass> EarlyContextAndPass<'a, T> {\n         F: FnOnce(&mut Self),\n     {\n         let is_crate_node = id == ast::CRATE_NODE_ID;\n-        let push = self.context.builder.push(attrs, &self.context.lint_store, is_crate_node);\n+        let push = self.context.builder.push(attrs, is_crate_node);\n         self.check_id(id);\n         self.enter_attrs(attrs);\n         f(self);\n@@ -325,88 +327,129 @@ macro_rules! early_lint_pass_impl {\n \n crate::early_lint_methods!(early_lint_pass_impl, []);\n \n-fn early_lint_crate<T: EarlyLintPass>(\n+/// Early lints work on different nodes - either on the crate root, or on freshly loaded modules.\n+/// This trait generalizes over those nodes.\n+pub trait EarlyCheckNode<'a>: Copy {\n+    fn id(self) -> ast::NodeId;\n+    fn attrs<'b>(self) -> &'b [ast::Attribute]\n+    where\n+        'a: 'b;\n+    fn check<'b>(self, cx: &mut EarlyContextAndPass<'b, impl EarlyLintPass>)\n+    where\n+        'a: 'b;\n+}\n+\n+impl<'a> EarlyCheckNode<'a> for &'a ast::Crate {\n+    fn id(self) -> ast::NodeId {\n+        ast::CRATE_NODE_ID\n+    }\n+    fn attrs<'b>(self) -> &'b [ast::Attribute]\n+    where\n+        'a: 'b,\n+    {\n+        &self.attrs\n+    }\n+    fn check<'b>(self, cx: &mut EarlyContextAndPass<'b, impl EarlyLintPass>)\n+    where\n+        'a: 'b,\n+    {\n+        run_early_pass!(cx, check_crate, self);\n+        ast_visit::walk_crate(cx, self);\n+        run_early_pass!(cx, check_crate_post, self);\n+    }\n+}\n+\n+impl<'a> EarlyCheckNode<'a> for (ast::NodeId, &'a [ast::Attribute], &'a [P<ast::Item>]) {\n+    fn id(self) -> ast::NodeId {\n+        self.0\n+    }\n+    fn attrs<'b>(self) -> &'b [ast::Attribute]\n+    where\n+        'a: 'b,\n+    {\n+        self.1\n+    }\n+    fn check<'b>(self, cx: &mut EarlyContextAndPass<'b, impl EarlyLintPass>)\n+    where\n+        'a: 'b,\n+    {\n+        walk_list!(cx, visit_attribute, self.1);\n+        walk_list!(cx, visit_item, self.2);\n+    }\n+}\n+\n+fn early_lint_node<'a>(\n     sess: &Session,\n+    warn_about_weird_lints: bool,\n     lint_store: &LintStore,\n-    krate: &ast::Crate,\n-    crate_attrs: &[ast::Attribute],\n-    pass: T,\n+    registered_tools: &RegisteredTools,\n     buffered: LintBuffer,\n-    warn_about_weird_lints: bool,\n+    pass: impl EarlyLintPass,\n+    check_node: impl EarlyCheckNode<'a>,\n ) -> LintBuffer {\n     let mut cx = EarlyContextAndPass {\n         context: EarlyContext::new(\n             sess,\n+            warn_about_weird_lints,\n             lint_store,\n-            krate,\n-            crate_attrs,\n+            registered_tools,\n             buffered,\n-            warn_about_weird_lints,\n         ),\n         pass,\n     };\n \n-    // Visit the whole crate.\n-    cx.with_lint_attrs(ast::CRATE_NODE_ID, &krate.attrs, |cx| {\n-        // since the root module isn't visited as an item (because it isn't an\n-        // item), warn for it here.\n-        run_early_pass!(cx, check_crate, krate);\n-\n-        ast_visit::walk_crate(cx, krate);\n-\n-        run_early_pass!(cx, check_crate_post, krate);\n-    });\n+    cx.with_lint_attrs(check_node.id(), check_node.attrs(), |cx| check_node.check(cx));\n     cx.context.buffered\n }\n \n-pub fn check_ast_crate<T: EarlyLintPass>(\n+pub fn check_ast_node<'a>(\n     sess: &Session,\n-    lint_store: &LintStore,\n-    krate: &ast::Crate,\n-    crate_attrs: &[ast::Attribute],\n     pre_expansion: bool,\n+    lint_store: &LintStore,\n+    registered_tools: &RegisteredTools,\n     lint_buffer: Option<LintBuffer>,\n-    builtin_lints: T,\n+    builtin_lints: impl EarlyLintPass,\n+    check_node: impl EarlyCheckNode<'a>,\n ) {\n     let passes =\n         if pre_expansion { &lint_store.pre_expansion_passes } else { &lint_store.early_passes };\n     let mut passes: Vec<_> = passes.iter().map(|p| (p)()).collect();\n     let mut buffered = lint_buffer.unwrap_or_default();\n \n     if !sess.opts.debugging_opts.no_interleave_lints {\n-        buffered = early_lint_crate(\n+        buffered = early_lint_node(\n             sess,\n+            pre_expansion,\n             lint_store,\n-            krate,\n-            crate_attrs,\n-            builtin_lints,\n+            registered_tools,\n             buffered,\n-            pre_expansion,\n+            builtin_lints,\n+            check_node,\n         );\n \n         if !passes.is_empty() {\n-            buffered = early_lint_crate(\n+            buffered = early_lint_node(\n                 sess,\n+                false,\n                 lint_store,\n-                krate,\n-                crate_attrs,\n-                EarlyLintPassObjects { lints: &mut passes[..] },\n+                registered_tools,\n                 buffered,\n-                false,\n+                EarlyLintPassObjects { lints: &mut passes[..] },\n+                check_node,\n             );\n         }\n     } else {\n         for (i, pass) in passes.iter_mut().enumerate() {\n             buffered =\n                 sess.prof.extra_verbose_generic_activity(\"run_lint\", pass.name()).run(|| {\n-                    early_lint_crate(\n+                    early_lint_node(\n                         sess,\n+                        pre_expansion && i == 0,\n                         lint_store,\n-                        krate,\n-                        crate_attrs,\n-                        EarlyLintPassObjects { lints: slice::from_mut(pass) },\n+                        registered_tools,\n                         buffered,\n-                        pre_expansion && i == 0,\n+                        EarlyLintPassObjects { lints: slice::from_mut(pass) },\n+                        check_node,\n                     )\n                 });\n         }"}, {"sha": "8afbd462c146ba2378701ab918c95bc2067d8bf9", "filename": "compiler/rustc_lint/src/levels.rs", "status": "modified", "additions": 26, "deletions": 37, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/42313dd29b3edb0ab453a0d43d12876ec7e48ce0/compiler%2Frustc_lint%2Fsrc%2Flevels.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42313dd29b3edb0ab453a0d43d12876ec7e48ce0/compiler%2Frustc_lint%2Fsrc%2Flevels.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flevels.rs?ref=42313dd29b3edb0ab453a0d43d12876ec7e48ce0", "patch": "@@ -5,7 +5,7 @@ use rustc_ast_pretty::pprust;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_errors::{struct_span_err, Applicability, DiagnosticBuilder};\n use rustc_hir as hir;\n-use rustc_hir::{intravisit, HirId, CRATE_HIR_ID};\n+use rustc_hir::{intravisit, HirId};\n use rustc_middle::hir::nested_filter;\n use rustc_middle::lint::LevelAndSource;\n use rustc_middle::lint::LintDiagnosticBuilder;\n@@ -14,7 +14,7 @@ use rustc_middle::lint::{\n     COMMAND_LINE,\n };\n use rustc_middle::ty::query::Providers;\n-use rustc_middle::ty::TyCtxt;\n+use rustc_middle::ty::{RegisteredTools, TyCtxt};\n use rustc_session::lint::{\n     builtin::{self, FORBIDDEN_LINT_GROUPS},\n     Level, Lint, LintId,\n@@ -27,14 +27,14 @@ use tracing::debug;\n \n fn lint_levels(tcx: TyCtxt<'_>, (): ()) -> LintLevelMap {\n     let store = unerased_lint_store(tcx);\n-    let crate_attrs = tcx.hir().attrs(CRATE_HIR_ID);\n-    let levels = LintLevelsBuilder::new(tcx.sess, false, &store, crate_attrs);\n-    let mut builder = LintLevelMapBuilder { levels, tcx, store };\n+    let levels =\n+        LintLevelsBuilder::new(tcx.sess, false, &store, &tcx.resolutions(()).registered_tools);\n+    let mut builder = LintLevelMapBuilder { levels, tcx };\n     let krate = tcx.hir().krate();\n \n     builder.levels.id_to_set.reserve(krate.owners.len() + 1);\n \n-    let push = builder.levels.push(tcx.hir().attrs(hir::CRATE_HIR_ID), &store, true);\n+    let push = builder.levels.push(tcx.hir().attrs(hir::CRATE_HIR_ID), true);\n     builder.levels.register_id(hir::CRATE_HIR_ID);\n     tcx.hir().walk_toplevel_module(&mut builder);\n     builder.levels.pop(push);\n@@ -49,7 +49,7 @@ pub struct LintLevelsBuilder<'s> {\n     cur: LintStackIndex,\n     warn_about_weird_lints: bool,\n     store: &'s LintStore,\n-    crate_attrs: &'s [ast::Attribute],\n+    registered_tools: &'s RegisteredTools,\n }\n \n pub struct BuilderPush {\n@@ -62,7 +62,7 @@ impl<'s> LintLevelsBuilder<'s> {\n         sess: &'s Session,\n         warn_about_weird_lints: bool,\n         store: &'s LintStore,\n-        crate_attrs: &'s [ast::Attribute],\n+        registered_tools: &'s RegisteredTools,\n     ) -> Self {\n         let mut builder = LintLevelsBuilder {\n             sess,\n@@ -71,19 +71,27 @@ impl<'s> LintLevelsBuilder<'s> {\n             id_to_set: Default::default(),\n             warn_about_weird_lints,\n             store,\n-            crate_attrs,\n+            registered_tools,\n         };\n         builder.process_command_line(sess, store);\n         assert_eq!(builder.sets.list.len(), 1);\n         builder\n     }\n \n+    pub(crate) fn sess(&self) -> &Session {\n+        self.sess\n+    }\n+\n+    pub(crate) fn lint_store(&self) -> &LintStore {\n+        self.store\n+    }\n+\n     fn process_command_line(&mut self, sess: &Session, store: &LintStore) {\n         let mut specs = FxHashMap::default();\n         self.sets.lint_cap = sess.opts.lint_cap.unwrap_or(Level::Forbid);\n \n         for &(ref lint_name, level) in &sess.opts.lint_opts {\n-            store.check_lint_name_cmdline(sess, &lint_name, level, self.crate_attrs);\n+            store.check_lint_name_cmdline(sess, &lint_name, level, self.registered_tools);\n             let orig_level = level;\n             let lint_flag_val = Symbol::intern(lint_name);\n \n@@ -217,12 +225,7 @@ impl<'s> LintLevelsBuilder<'s> {\n     ///   `#[allow]`\n     ///\n     /// Don't forget to call `pop`!\n-    pub(crate) fn push(\n-        &mut self,\n-        attrs: &[ast::Attribute],\n-        store: &LintStore,\n-        is_crate_node: bool,\n-    ) -> BuilderPush {\n+    pub(crate) fn push(&mut self, attrs: &[ast::Attribute], is_crate_node: bool) -> BuilderPush {\n         let mut specs = FxHashMap::default();\n         let sess = self.sess;\n         let bad_attr = |span| struct_span_err!(sess, span, E0452, \"malformed lint attribute input\");\n@@ -310,7 +313,8 @@ impl<'s> LintLevelsBuilder<'s> {\n                 };\n                 let tool_name = tool_ident.map(|ident| ident.name);\n                 let name = pprust::path_to_string(&meta_item.path);\n-                let lint_result = store.check_lint_name(sess, &name, tool_name, self.crate_attrs);\n+                let lint_result =\n+                    self.store.check_lint_name(&name, tool_name, self.registered_tools);\n                 match &lint_result {\n                     CheckLintNameResult::Ok(ids) => {\n                         let src = LintLevelSource::Node(\n@@ -459,7 +463,7 @@ impl<'s> LintLevelsBuilder<'s> {\n                     // Ignore any errors or warnings that happen because the new name is inaccurate\n                     // NOTE: `new_name` already includes the tool name, so we don't have to add it again.\n                     if let CheckLintNameResult::Ok(ids) =\n-                        store.check_lint_name(sess, &new_name, None, self.crate_attrs)\n+                        self.store.check_lint_name(&new_name, None, self.registered_tools)\n                     {\n                         let src = LintLevelSource::Node(Symbol::intern(&new_name), sp, reason);\n                         for &id in ids {\n@@ -562,34 +566,19 @@ impl<'s> LintLevelsBuilder<'s> {\n     }\n }\n \n-pub fn is_known_lint_tool(m_item: Symbol, sess: &Session, attrs: &[ast::Attribute]) -> bool {\n-    if [sym::clippy, sym::rustc, sym::rustdoc].contains(&m_item) {\n-        return true;\n-    }\n-    // Look for registered tools\n-    // NOTE: does no error handling; error handling is done by rustc_resolve.\n-    sess.filter_by_name(attrs, sym::register_tool)\n-        .filter_map(|attr| attr.meta_item_list())\n-        .flatten()\n-        .filter_map(|nested_meta| nested_meta.ident())\n-        .map(|ident| ident.name)\n-        .any(|name| name == m_item)\n-}\n-\n-struct LintLevelMapBuilder<'a, 'tcx> {\n+struct LintLevelMapBuilder<'tcx> {\n     levels: LintLevelsBuilder<'tcx>,\n     tcx: TyCtxt<'tcx>,\n-    store: &'a LintStore,\n }\n \n-impl LintLevelMapBuilder<'_, '_> {\n+impl LintLevelMapBuilder<'_> {\n     fn with_lint_attrs<F>(&mut self, id: hir::HirId, f: F)\n     where\n         F: FnOnce(&mut Self),\n     {\n         let is_crate_hir = id == hir::CRATE_HIR_ID;\n         let attrs = self.tcx.hir().attrs(id);\n-        let push = self.levels.push(attrs, self.store, is_crate_hir);\n+        let push = self.levels.push(attrs, is_crate_hir);\n         if push.changed {\n             self.levels.register_id(id);\n         }\n@@ -598,7 +587,7 @@ impl LintLevelMapBuilder<'_, '_> {\n     }\n }\n \n-impl<'tcx> intravisit::Visitor<'tcx> for LintLevelMapBuilder<'_, 'tcx> {\n+impl<'tcx> intravisit::Visitor<'tcx> for LintLevelMapBuilder<'tcx> {\n     type NestedFilter = nested_filter::All;\n \n     fn nested_visit_map(&mut self) -> Self::Map {"}, {"sha": "a87f2b2768d6754252e06743507346d9b21f9f3f", "filename": "compiler/rustc_lint/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/42313dd29b3edb0ab453a0d43d12876ec7e48ce0/compiler%2Frustc_lint%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42313dd29b3edb0ab453a0d43d12876ec7e48ce0/compiler%2Frustc_lint%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flib.rs?ref=42313dd29b3edb0ab453a0d43d12876ec7e48ce0", "patch": "@@ -96,7 +96,7 @@ use unused::*;\n pub use builtin::SoftLints;\n pub use context::{CheckLintNameResult, FindLintError, LintStore};\n pub use context::{EarlyContext, LateContext, LintContext};\n-pub use early::check_ast_crate;\n+pub use early::{check_ast_node, EarlyCheckNode};\n pub use late::check_crate;\n pub use passes::{EarlyLintPass, LateLintPass};\n pub use rustc_session::lint::Level::{self, *};"}, {"sha": "2dd6dbd67a8d2ef1bd94514f0dee539e198e0b7e", "filename": "compiler/rustc_lint/src/non_ascii_idents.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/42313dd29b3edb0ab453a0d43d12876ec7e48ce0/compiler%2Frustc_lint%2Fsrc%2Fnon_ascii_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42313dd29b3edb0ab453a0d43d12876ec7e48ce0/compiler%2Frustc_lint%2Fsrc%2Fnon_ascii_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fnon_ascii_idents.rs?ref=42313dd29b3edb0ab453a0d43d12876ec7e48ce0", "patch": "@@ -166,7 +166,7 @@ impl EarlyLintPass for NonAsciiIdents {\n         }\n \n         let mut has_non_ascii_idents = false;\n-        let symbols = cx.sess.parse_sess.symbol_gallery.symbols.lock();\n+        let symbols = cx.sess().parse_sess.symbol_gallery.symbols.lock();\n \n         // Sort by `Span` so that error messages make sense with respect to the\n         // order of identifier locations in the code."}, {"sha": "f73388c675ee2a25dcc178ffe013976a6daa534d", "filename": "compiler/rustc_lint/src/nonstandard_style.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/42313dd29b3edb0ab453a0d43d12876ec7e48ce0/compiler%2Frustc_lint%2Fsrc%2Fnonstandard_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42313dd29b3edb0ab453a0d43d12876ec7e48ce0/compiler%2Frustc_lint%2Fsrc%2Fnonstandard_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fnonstandard_style.rs?ref=42313dd29b3edb0ab453a0d43d12876ec7e48ce0", "patch": "@@ -164,7 +164,7 @@ impl EarlyLintPass for NonCamelCaseTypes {\n         let has_repr_c = it\n             .attrs\n             .iter()\n-            .any(|attr| attr::find_repr_attrs(&cx.sess, attr).contains(&attr::ReprC));\n+            .any(|attr| attr::find_repr_attrs(cx.sess(), attr).contains(&attr::ReprC));\n \n         if has_repr_c {\n             return;"}, {"sha": "64c00c353ca1b0ef9fda89fca6de0684c475385f", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/42313dd29b3edb0ab453a0d43d12876ec7e48ce0/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42313dd29b3edb0ab453a0d43d12876ec7e48ce0/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=42313dd29b3edb0ab453a0d43d12876ec7e48ce0", "patch": "@@ -119,6 +119,8 @@ mod sty;\n \n // Data types\n \n+pub type RegisteredTools = FxHashSet<Ident>;\n+\n #[derive(Debug)]\n pub struct ResolverOutputs {\n     pub definitions: rustc_hir::definitions::Definitions,\n@@ -141,6 +143,7 @@ pub struct ResolverOutputs {\n     /// Mapping from ident span to path span for paths that don't exist as written, but that\n     /// exist under `std`. For example, wrote `str::from_utf8` instead of `std::str::from_utf8`.\n     pub confused_type_with_std_module: FxHashMap<Span, Span>,\n+    pub registered_tools: RegisteredTools,\n }\n \n #[derive(Clone, Copy, Debug)]"}, {"sha": "ce8b187a744436d4138db17cb6cc7d2270800bbe", "filename": "compiler/rustc_mir_transform/src/coverage/debug.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/42313dd29b3edb0ab453a0d43d12876ec7e48ce0/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fdebug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42313dd29b3edb0ab453a0d43d12876ec7e48ce0/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fdebug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fdebug.rs?ref=42313dd29b3edb0ab453a0d43d12876ec7e48ce0", "patch": "@@ -111,6 +111,7 @@\n use super::graph::{BasicCoverageBlock, BasicCoverageBlockData, CoverageGraph};\n use super::spans::CoverageSpan;\n \n+use itertools::Itertools;\n use rustc_middle::mir::create_dump_file;\n use rustc_middle::mir::generic_graphviz::GraphvizWriter;\n use rustc_middle::mir::spanview::{self, SpanViewable};\n@@ -739,7 +740,6 @@ pub(super) fn dump_coverage_graphviz<'tcx>(\n                         )\n                     }\n                 })\n-                .collect::<Vec<_>>()\n                 .join(\"\\n  \")\n         ));\n     }\n@@ -768,7 +768,6 @@ fn bcb_to_string_sections<'tcx>(\n                 .map(|expression| {\n                     format!(\"Intermediate {}\", debug_counters.format_counter(expression))\n                 })\n-                .collect::<Vec<_>>()\n                 .join(\"\\n\"),\n         );\n     }\n@@ -783,7 +782,6 @@ fn bcb_to_string_sections<'tcx>(\n                         covspan.format(tcx, mir_body)\n                     )\n                 })\n-                .collect::<Vec<_>>()\n                 .join(\"\\n\"),\n         );\n     }\n@@ -793,7 +791,6 @@ fn bcb_to_string_sections<'tcx>(\n             dependency_counters\n                 .iter()\n                 .map(|counter| debug_counters.format_counter(counter))\n-                .collect::<Vec<_>>()\n                 .join(\"  \\n\"),\n         ));\n     }"}, {"sha": "57862b6628d2310819005e408cd8f79bfd073eb8", "filename": "compiler/rustc_mir_transform/src/coverage/graph.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/42313dd29b3edb0ab453a0d43d12876ec7e48ce0/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42313dd29b3edb0ab453a0d43d12876ec7e48ce0/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fgraph.rs?ref=42313dd29b3edb0ab453a0d43d12876ec7e48ce0", "patch": "@@ -1,5 +1,6 @@\n use super::Error;\n \n+use itertools::Itertools;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::graph::dominators::{self, Dominators};\n use rustc_data_structures::graph::{self, GraphSuccessors, WithNumNodes, WithStartNode};\n@@ -422,14 +423,7 @@ impl BasicCoverageBlockData {\n     }\n \n     pub fn id(&self) -> String {\n-        format!(\n-            \"@{}\",\n-            self.basic_blocks\n-                .iter()\n-                .map(|bb| bb.index().to_string())\n-                .collect::<Vec<_>>()\n-                .join(ID_SEPARATOR)\n-        )\n+        format!(\"@{}\", self.basic_blocks.iter().map(|bb| bb.index().to_string()).join(ID_SEPARATOR))\n     }\n }\n "}, {"sha": "237cb1e11053afe041235e394b0de35e04b5afcb", "filename": "compiler/rustc_mir_transform/src/coverage/spans.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/42313dd29b3edb0ab453a0d43d12876ec7e48ce0/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fspans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42313dd29b3edb0ab453a0d43d12876ec7e48ce0/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fspans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fspans.rs?ref=42313dd29b3edb0ab453a0d43d12876ec7e48ce0", "patch": "@@ -1,6 +1,7 @@\n use super::debug::term_type;\n use super::graph::{BasicCoverageBlock, BasicCoverageBlockData, CoverageGraph, START_BCB};\n \n+use itertools::Itertools;\n use rustc_data_structures::graph::WithNumNodes;\n use rustc_middle::mir::spanview::source_range_no_file;\n use rustc_middle::mir::{\n@@ -169,11 +170,7 @@ impl CoverageSpan {\n             CoverageStatement::Statement(bb, _, index) => (bb, index),\n             CoverageStatement::Terminator(bb, _) => (bb, usize::MAX),\n         });\n-        sorted_coverage_statements\n-            .iter()\n-            .map(|covstmt| covstmt.format(tcx, mir_body))\n-            .collect::<Vec<_>>()\n-            .join(\"\\n\")\n+        sorted_coverage_statements.iter().map(|covstmt| covstmt.format(tcx, mir_body)).join(\"\\n\")\n     }\n \n     /// If the span is part of a macro, returns the macro name symbol."}, {"sha": "62ea2538ff0d8ce8d4346320e911220ddb7410ce", "filename": "compiler/rustc_mir_transform/src/coverage/tests.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/42313dd29b3edb0ab453a0d43d12876ec7e48ce0/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42313dd29b3edb0ab453a0d43d12876ec7e48ce0/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Ftests.rs?ref=42313dd29b3edb0ab453a0d43d12876ec7e48ce0", "patch": "@@ -31,6 +31,7 @@ use super::spans;\n \n use coverage_test_macros::let_bcb;\n \n+use itertools::Itertools;\n use rustc_data_structures::graph::WithNumNodes;\n use rustc_data_structures::graph::WithSuccessors;\n use rustc_index::vec::{Idx, IndexVec};\n@@ -232,11 +233,9 @@ fn print_mir_graphviz(name: &str, mir_body: &Body<'_>) {\n                         mir_body\n                             .successors(bb)\n                             .map(|successor| { format!(\"    {:?} -> {:?};\", bb, successor) })\n-                            .collect::<Vec<_>>()\n                             .join(\"\\n\")\n                     )\n                 })\n-                .collect::<Vec<_>>()\n                 .join(\"\\n\")\n         );\n     }\n@@ -262,11 +261,9 @@ fn print_coverage_graphviz(\n                         basic_coverage_blocks\n                             .successors(bcb)\n                             .map(|successor| { format!(\"    {:?} -> {:?};\", bcb, successor) })\n-                            .collect::<Vec<_>>()\n                             .join(\"\\n\")\n                     )\n                 })\n-                .collect::<Vec<_>>()\n                 .join(\"\\n\")\n         );\n     }"}, {"sha": "450e0c31e982b9d7a64dcd464203c1289af5bbf5", "filename": "compiler/rustc_mir_transform/src/function_item_references.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/42313dd29b3edb0ab453a0d43d12876ec7e48ce0/compiler%2Frustc_mir_transform%2Fsrc%2Ffunction_item_references.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42313dd29b3edb0ab453a0d43d12876ec7e48ce0/compiler%2Frustc_mir_transform%2Fsrc%2Ffunction_item_references.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Ffunction_item_references.rs?ref=42313dd29b3edb0ab453a0d43d12876ec7e48ce0", "patch": "@@ -1,3 +1,4 @@\n+use itertools::Itertools;\n use rustc_errors::Applicability;\n use rustc_hir::def_id::DefId;\n use rustc_middle::mir::visit::Visitor;\n@@ -197,7 +198,7 @@ impl<'tcx> FunctionItemRefChecker<'_, 'tcx> {\n         let ident = self.tcx.item_name(fn_id).to_ident_string();\n         let ty_params = fn_substs.types().map(|ty| format!(\"{}\", ty));\n         let const_params = fn_substs.consts().map(|c| format!(\"{}\", c));\n-        let params = ty_params.chain(const_params).collect::<Vec<String>>().join(\", \");\n+        let params = ty_params.chain(const_params).join(\", \");\n         let num_args = fn_sig.inputs().map_bound(|inputs| inputs.len()).skip_binder();\n         let variadic = if fn_sig.c_variadic() { \", ...\" } else { \"\" };\n         let ret = if fn_sig.output().skip_binder().is_unit() { \"\" } else { \" -> _\" };"}, {"sha": "26284728ff2c62cc5616e08648b0d4af5fbca233", "filename": "compiler/rustc_parse/src/parser/expr.rs", "status": "modified", "additions": 17, "deletions": 3, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/42313dd29b3edb0ab453a0d43d12876ec7e48ce0/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42313dd29b3edb0ab453a0d43d12876ec7e48ce0/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs?ref=42313dd29b3edb0ab453a0d43d12876ec7e48ce0", "patch": "@@ -2383,16 +2383,30 @@ impl<'a> Parser<'a> {\n     }\n \n     pub(super) fn parse_arm(&mut self) -> PResult<'a, Arm> {\n+        fn check_let_expr(expr: &Expr) -> (bool, bool) {\n+            match expr.kind {\n+                ExprKind::Binary(_, ref lhs, ref rhs) => {\n+                    let lhs_rslt = check_let_expr(lhs);\n+                    let rhs_rslt = check_let_expr(rhs);\n+                    (lhs_rslt.0 || rhs_rslt.0, false)\n+                }\n+                ExprKind::Let(..) => (true, true),\n+                _ => (false, true),\n+            }\n+        }\n         let attrs = self.parse_outer_attributes()?;\n         self.collect_tokens_trailing_token(attrs, ForceCollect::No, |this, attrs| {\n             let lo = this.token.span;\n             let pat = this.parse_pat_allow_top_alt(None, RecoverComma::Yes, RecoverColon::Yes)?;\n             let guard = if this.eat_keyword(kw::If) {\n                 let if_span = this.prev_token.span;\n                 let cond = this.parse_expr()?;\n-                if let ExprKind::Let(..) = cond.kind {\n-                    // Remove the last feature gating of a `let` expression since it's stable.\n-                    this.sess.gated_spans.ungate_last(sym::let_chains, cond.span);\n+                let (has_let_expr, does_not_have_bin_op) = check_let_expr(&cond);\n+                if has_let_expr {\n+                    if does_not_have_bin_op {\n+                        // Remove the last feature gating of a `let` expression since it's stable.\n+                        this.sess.gated_spans.ungate_last(sym::let_chains, cond.span);\n+                    }\n                     let span = if_span.to(cond.span);\n                     this.sess.gated_spans.gate(sym::if_let_guard, span);\n                 }"}, {"sha": "f6625ac021b30e0cfdfad796f86e1fa829fa37e4", "filename": "compiler/rustc_resolve/src/lib.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/42313dd29b3edb0ab453a0d43d12876ec7e48ce0/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42313dd29b3edb0ab453a0d43d12876ec7e48ce0/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flib.rs?ref=42313dd29b3edb0ab453a0d43d12876ec7e48ce0", "patch": "@@ -53,7 +53,7 @@ use rustc_middle::metadata::ModChild;\n use rustc_middle::middle::privacy::AccessLevels;\n use rustc_middle::span_bug;\n use rustc_middle::ty::query::Providers;\n-use rustc_middle::ty::{self, DefIdTree, MainDefinition, ResolverOutputs};\n+use rustc_middle::ty::{self, DefIdTree, MainDefinition, RegisteredTools, ResolverOutputs};\n use rustc_query_system::ich::StableHashingContext;\n use rustc_session::cstore::{CrateStore, MetadataLoaderDyn};\n use rustc_session::lint;\n@@ -989,7 +989,7 @@ pub struct Resolver<'a> {\n     macro_names: FxHashSet<Ident>,\n     builtin_macros: FxHashMap<Symbol, BuiltinMacroState>,\n     registered_attrs: FxHashSet<Ident>,\n-    registered_tools: FxHashSet<Ident>,\n+    registered_tools: RegisteredTools,\n     macro_use_prelude: FxHashMap<Symbol, &'a NameBinding<'a>>,\n     all_macros: FxHashMap<Symbol, Res>,\n     macro_map: FxHashMap<DefId, Lrc<SyntaxExtension>>,\n@@ -1487,6 +1487,7 @@ impl<'a> Resolver<'a> {\n             trait_impls: self.trait_impls,\n             proc_macros,\n             confused_type_with_std_module,\n+            registered_tools: self.registered_tools,\n         }\n     }\n \n@@ -1511,6 +1512,7 @@ impl<'a> Resolver<'a> {\n             trait_impls: self.trait_impls.clone(),\n             proc_macros,\n             confused_type_with_std_module: self.confused_type_with_std_module.clone(),\n+            registered_tools: self.registered_tools.clone(),\n         }\n     }\n "}, {"sha": "82807e2d0a2c55b281e18ec85de513299f2fd682", "filename": "compiler/rustc_resolve/src/macros.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/42313dd29b3edb0ab453a0d43d12876ec7e48ce0/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42313dd29b3edb0ab453a0d43d12876ec7e48ce0/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs?ref=42313dd29b3edb0ab453a0d43d12876ec7e48ce0", "patch": "@@ -23,7 +23,7 @@ use rustc_hir::def::{self, DefKind, NonMacroAttrKind};\n use rustc_hir::def_id::{CrateNum, LocalDefId};\n use rustc_hir::PrimTy;\n use rustc_middle::middle::stability;\n-use rustc_middle::ty;\n+use rustc_middle::ty::{self, RegisteredTools};\n use rustc_session::lint::builtin::{LEGACY_DERIVE_HELPERS, PROC_MACRO_DERIVE_RESOLUTION_FALLBACK};\n use rustc_session::lint::builtin::{SOFT_UNSTABLE, UNUSED_MACROS};\n use rustc_session::lint::BuiltinLintDiagnostics;\n@@ -447,6 +447,10 @@ impl<'a> ResolverExpand for Resolver<'a> {\n     fn declare_proc_macro(&mut self, id: NodeId) {\n         self.proc_macros.push(id)\n     }\n+\n+    fn registered_tools(&self) -> &RegisteredTools {\n+        &self.registered_tools\n+    }\n }\n \n impl<'a> Resolver<'a> {"}, {"sha": "9bcdd7f3da6b3c729c58934964d9b4180b6166a0", "filename": "compiler/rustc_session/src/session.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/42313dd29b3edb0ab453a0d43d12876ec7e48ce0/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42313dd29b3edb0ab453a0d43d12876ec7e48ce0/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fsession.rs?ref=42313dd29b3edb0ab453a0d43d12876ec7e48ce0", "patch": "@@ -476,10 +476,6 @@ impl Session {\n         &self.parse_sess.span_diagnostic\n     }\n \n-    pub fn with_disabled_diagnostic<T, F: FnOnce() -> T>(&self, f: F) -> T {\n-        self.parse_sess.span_diagnostic.with_disabled_diagnostic(f)\n-    }\n-\n     /// Analogous to calling methods on the given `DiagnosticBuilder`, but\n     /// deduplicates on lint ID, span (if any), and message for this `Session`\n     fn diag_once<'a, 'b>("}, {"sha": "8046267a59da6ca8d5c3471de366b8f4db5eecb1", "filename": "compiler/rustc_target/src/asm/mod.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/42313dd29b3edb0ab453a0d43d12876ec7e48ce0/compiler%2Frustc_target%2Fsrc%2Fasm%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42313dd29b3edb0ab453a0d43d12876ec7e48ce0/compiler%2Frustc_target%2Fsrc%2Fasm%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fasm%2Fmod.rs?ref=42313dd29b3edb0ab453a0d43d12876ec7e48ce0", "patch": "@@ -152,6 +152,7 @@ mod avr;\n mod bpf;\n mod hexagon;\n mod mips;\n+mod msp430;\n mod nvptx;\n mod powerpc;\n mod riscv;\n@@ -166,6 +167,7 @@ pub use avr::{AvrInlineAsmReg, AvrInlineAsmRegClass};\n pub use bpf::{BpfInlineAsmReg, BpfInlineAsmRegClass};\n pub use hexagon::{HexagonInlineAsmReg, HexagonInlineAsmRegClass};\n pub use mips::{MipsInlineAsmReg, MipsInlineAsmRegClass};\n+pub use msp430::{Msp430InlineAsmReg, Msp430InlineAsmRegClass};\n pub use nvptx::{NvptxInlineAsmReg, NvptxInlineAsmRegClass};\n pub use powerpc::{PowerPCInlineAsmReg, PowerPCInlineAsmRegClass};\n pub use riscv::{RiscVInlineAsmReg, RiscVInlineAsmRegClass};\n@@ -194,6 +196,7 @@ pub enum InlineAsmArch {\n     Wasm64,\n     Bpf,\n     Avr,\n+    Msp430,\n }\n \n impl FromStr for InlineAsmArch {\n@@ -219,6 +222,7 @@ impl FromStr for InlineAsmArch {\n             \"wasm64\" => Ok(Self::Wasm64),\n             \"bpf\" => Ok(Self::Bpf),\n             \"avr\" => Ok(Self::Avr),\n+            \"msp430\" => Ok(Self::Msp430),\n             _ => Err(()),\n         }\n     }\n@@ -250,6 +254,7 @@ pub enum InlineAsmReg {\n     Wasm(WasmInlineAsmReg),\n     Bpf(BpfInlineAsmReg),\n     Avr(AvrInlineAsmReg),\n+    Msp430(Msp430InlineAsmReg),\n     // Placeholder for invalid register constraints for the current target\n     Err,\n }\n@@ -267,6 +272,7 @@ impl InlineAsmReg {\n             Self::S390x(r) => r.name(),\n             Self::Bpf(r) => r.name(),\n             Self::Avr(r) => r.name(),\n+            Self::Msp430(r) => r.name(),\n             Self::Err => \"<reg>\",\n         }\n     }\n@@ -283,6 +289,7 @@ impl InlineAsmReg {\n             Self::S390x(r) => InlineAsmRegClass::S390x(r.reg_class()),\n             Self::Bpf(r) => InlineAsmRegClass::Bpf(r.reg_class()),\n             Self::Avr(r) => InlineAsmRegClass::Avr(r.reg_class()),\n+            Self::Msp430(r) => InlineAsmRegClass::Msp430(r.reg_class()),\n             Self::Err => InlineAsmRegClass::Err,\n         }\n     }\n@@ -336,6 +343,9 @@ impl InlineAsmReg {\n             InlineAsmArch::Avr => {\n                 Self::Avr(AvrInlineAsmReg::parse(arch, target_features, target, name)?)\n             }\n+            InlineAsmArch::Msp430 => {\n+                Self::Msp430(Msp430InlineAsmReg::parse(arch, target_features, target, name)?)\n+            }\n         })\n     }\n \n@@ -358,6 +368,7 @@ impl InlineAsmReg {\n             Self::S390x(r) => r.emit(out, arch, modifier),\n             Self::Bpf(r) => r.emit(out, arch, modifier),\n             Self::Avr(r) => r.emit(out, arch, modifier),\n+            Self::Msp430(r) => r.emit(out, arch, modifier),\n             Self::Err => unreachable!(\"Use of InlineAsmReg::Err\"),\n         }\n     }\n@@ -374,6 +385,7 @@ impl InlineAsmReg {\n             Self::S390x(_) => cb(self),\n             Self::Bpf(r) => r.overlapping_regs(|r| cb(Self::Bpf(r))),\n             Self::Avr(r) => r.overlapping_regs(|r| cb(Self::Avr(r))),\n+            Self::Msp430(_) => cb(self),\n             Self::Err => unreachable!(\"Use of InlineAsmReg::Err\"),\n         }\n     }\n@@ -405,6 +417,7 @@ pub enum InlineAsmRegClass {\n     Wasm(WasmInlineAsmRegClass),\n     Bpf(BpfInlineAsmRegClass),\n     Avr(AvrInlineAsmRegClass),\n+    Msp430(Msp430InlineAsmRegClass),\n     // Placeholder for invalid register constraints for the current target\n     Err,\n }\n@@ -425,6 +438,7 @@ impl InlineAsmRegClass {\n             Self::Wasm(r) => r.name(),\n             Self::Bpf(r) => r.name(),\n             Self::Avr(r) => r.name(),\n+            Self::Msp430(r) => r.name(),\n             Self::Err => rustc_span::symbol::sym::reg,\n         }\n     }\n@@ -447,6 +461,7 @@ impl InlineAsmRegClass {\n             Self::Wasm(r) => r.suggest_class(arch, ty).map(InlineAsmRegClass::Wasm),\n             Self::Bpf(r) => r.suggest_class(arch, ty).map(InlineAsmRegClass::Bpf),\n             Self::Avr(r) => r.suggest_class(arch, ty).map(InlineAsmRegClass::Avr),\n+            Self::Msp430(r) => r.suggest_class(arch, ty).map(InlineAsmRegClass::Msp430),\n             Self::Err => unreachable!(\"Use of InlineAsmRegClass::Err\"),\n         }\n     }\n@@ -476,6 +491,7 @@ impl InlineAsmRegClass {\n             Self::Wasm(r) => r.suggest_modifier(arch, ty),\n             Self::Bpf(r) => r.suggest_modifier(arch, ty),\n             Self::Avr(r) => r.suggest_modifier(arch, ty),\n+            Self::Msp430(r) => r.suggest_modifier(arch, ty),\n             Self::Err => unreachable!(\"Use of InlineAsmRegClass::Err\"),\n         }\n     }\n@@ -501,6 +517,7 @@ impl InlineAsmRegClass {\n             Self::Wasm(r) => r.default_modifier(arch),\n             Self::Bpf(r) => r.default_modifier(arch),\n             Self::Avr(r) => r.default_modifier(arch),\n+            Self::Msp430(r) => r.default_modifier(arch),\n             Self::Err => unreachable!(\"Use of InlineAsmRegClass::Err\"),\n         }\n     }\n@@ -525,6 +542,7 @@ impl InlineAsmRegClass {\n             Self::Wasm(r) => r.supported_types(arch),\n             Self::Bpf(r) => r.supported_types(arch),\n             Self::Avr(r) => r.supported_types(arch),\n+            Self::Msp430(r) => r.supported_types(arch),\n             Self::Err => unreachable!(\"Use of InlineAsmRegClass::Err\"),\n         }\n     }\n@@ -554,6 +572,7 @@ impl InlineAsmRegClass {\n             }\n             InlineAsmArch::Bpf => Self::Bpf(BpfInlineAsmRegClass::parse(arch, name)?),\n             InlineAsmArch::Avr => Self::Avr(AvrInlineAsmRegClass::parse(arch, name)?),\n+            InlineAsmArch::Msp430 => Self::Msp430(Msp430InlineAsmRegClass::parse(arch, name)?),\n         })\n     }\n \n@@ -574,6 +593,7 @@ impl InlineAsmRegClass {\n             Self::Wasm(r) => r.valid_modifiers(arch),\n             Self::Bpf(r) => r.valid_modifiers(arch),\n             Self::Avr(r) => r.valid_modifiers(arch),\n+            Self::Msp430(r) => r.valid_modifiers(arch),\n             Self::Err => unreachable!(\"Use of InlineAsmRegClass::Err\"),\n         }\n     }\n@@ -764,6 +784,11 @@ pub fn allocatable_registers(\n             avr::fill_reg_map(arch, target_features, target, &mut map);\n             map\n         }\n+        InlineAsmArch::Msp430 => {\n+            let mut map = msp430::regclass_map();\n+            msp430::fill_reg_map(arch, target_features, target, &mut map);\n+            map\n+        }\n     }\n }\n "}, {"sha": "a27d6390a72e861a29fa20ccc0b24d69332ad3d7", "filename": "compiler/rustc_target/src/asm/msp430.rs", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/42313dd29b3edb0ab453a0d43d12876ec7e48ce0/compiler%2Frustc_target%2Fsrc%2Fasm%2Fmsp430.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42313dd29b3edb0ab453a0d43d12876ec7e48ce0/compiler%2Frustc_target%2Fsrc%2Fasm%2Fmsp430.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fasm%2Fmsp430.rs?ref=42313dd29b3edb0ab453a0d43d12876ec7e48ce0", "patch": "@@ -0,0 +1,81 @@\n+use super::{InlineAsmArch, InlineAsmType};\n+use rustc_macros::HashStable_Generic;\n+use rustc_span::Symbol;\n+use std::fmt;\n+\n+def_reg_class! {\n+    Msp430 Msp430InlineAsmRegClass {\n+        reg,\n+    }\n+}\n+\n+impl Msp430InlineAsmRegClass {\n+    pub fn valid_modifiers(self, _arch: super::InlineAsmArch) -> &'static [char] {\n+        &[]\n+    }\n+\n+    pub fn suggest_class(self, _arch: InlineAsmArch, _ty: InlineAsmType) -> Option<Self> {\n+        None\n+    }\n+\n+    pub fn suggest_modifier(\n+        self,\n+        _arch: InlineAsmArch,\n+        _ty: InlineAsmType,\n+    ) -> Option<(char, &'static str)> {\n+        None\n+    }\n+\n+    pub fn default_modifier(self, _arch: InlineAsmArch) -> Option<(char, &'static str)> {\n+        None\n+    }\n+\n+    pub fn supported_types(\n+        self,\n+        arch: InlineAsmArch,\n+    ) -> &'static [(InlineAsmType, Option<Symbol>)] {\n+        match (self, arch) {\n+            (Self::reg, _) => types! { _: I8, I16; },\n+        }\n+    }\n+}\n+\n+// The reserved registers are taken from:\n+// https://github.com/llvm/llvm-project/blob/36cb29cbbe1b22dcd298ad65e1fabe899b7d7249/llvm/lib/Target/MSP430/MSP430RegisterInfo.cpp#L73.\n+def_regs! {\n+    Msp430 Msp430InlineAsmReg Msp430InlineAsmRegClass {\n+        r5: reg = [\"r5\"],\n+        r6: reg = [\"r6\"],\n+        r7: reg = [\"r7\"],\n+        r8: reg = [\"r8\"],\n+        r9: reg = [\"r9\"],\n+        r10: reg = [\"r10\"],\n+        r11: reg = [\"r11\"],\n+        r12: reg = [\"r12\"],\n+        r13: reg = [\"r13\"],\n+        r14: reg = [\"r14\"],\n+        r15: reg = [\"r15\"],\n+\n+        #error = [\"r0\", \"pc\"] =>\n+            \"the program counter cannot be used as an operand for inline asm\",\n+        #error = [\"r1\", \"sp\"] =>\n+            \"the stack pointer cannot be used as an operand for inline asm\",\n+        #error = [\"r2\", \"sr\"] =>\n+            \"the status register cannot be used as an operand for inline asm\",\n+        #error = [\"r3\", \"cg\"] =>\n+            \"the constant generator cannot be used as an operand for inline asm\",\n+        #error = [\"r4\", \"fp\"] =>\n+            \"the frame pointer cannot be used as an operand for inline asm\",\n+    }\n+}\n+\n+impl Msp430InlineAsmReg {\n+    pub fn emit(\n+        self,\n+        out: &mut dyn fmt::Write,\n+        _arch: InlineAsmArch,\n+        _modifier: Option<char>,\n+    ) -> fmt::Result {\n+        out.write_str(self.name())\n+    }\n+}"}, {"sha": "aa1a521d53274e94e71914acd02d0ad7daa888c5", "filename": "compiler/rustc_typeck/src/check/wfcheck.rs", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/42313dd29b3edb0ab453a0d43d12876ec7e48ce0/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42313dd29b3edb0ab453a0d43d12876ec7e48ce0/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=42313dd29b3edb0ab453a0d43d12876ec7e48ce0", "patch": "@@ -312,7 +312,7 @@ fn check_gat_where_clauses(\n         // of  the function signature. In our example, the GAT in the return\n         // type is `<Self as LendingIterator>::Item<'a>`, so 'a and Self are arguments.\n         let (regions, types) =\n-            GATSubstCollector::visit(trait_item.def_id.to_def_id(), sig.output());\n+            GATSubstCollector::visit(tcx, trait_item.def_id.to_def_id(), sig.output());\n \n         // If both regions and types are empty, then this GAT isn't in the\n         // return type, and we shouldn't try to do clause analysis\n@@ -602,6 +602,7 @@ fn resolve_regions_with_wf_tys<'tcx>(\n /// the two vectors, `regions` and `types` (depending on their kind). For each\n /// parameter `Pi` also track the index `i`.\n struct GATSubstCollector<'tcx> {\n+    tcx: TyCtxt<'tcx>,\n     gat: DefId,\n     // Which region appears and which parameter index its subsituted for\n     regions: FxHashSet<(ty::Region<'tcx>, usize)>,\n@@ -611,11 +612,16 @@ struct GATSubstCollector<'tcx> {\n \n impl<'tcx> GATSubstCollector<'tcx> {\n     fn visit<T: TypeFoldable<'tcx>>(\n+        tcx: TyCtxt<'tcx>,\n         gat: DefId,\n         t: T,\n     ) -> (FxHashSet<(ty::Region<'tcx>, usize)>, FxHashSet<(Ty<'tcx>, usize)>) {\n-        let mut visitor =\n-            GATSubstCollector { gat, regions: FxHashSet::default(), types: FxHashSet::default() };\n+        let mut visitor = GATSubstCollector {\n+            tcx,\n+            gat,\n+            regions: FxHashSet::default(),\n+            types: FxHashSet::default(),\n+        };\n         t.visit_with(&mut visitor);\n         (visitor.regions, visitor.types)\n     }\n@@ -624,6 +630,13 @@ impl<'tcx> GATSubstCollector<'tcx> {\n impl<'tcx> TypeVisitor<'tcx> for GATSubstCollector<'tcx> {\n     type BreakTy = !;\n \n+    fn visit_binder<T: TypeFoldable<'tcx>>(\n+        &mut self,\n+        t: &ty::Binder<'tcx, T>,\n+    ) -> ControlFlow<Self::BreakTy> {\n+        self.tcx.liberate_late_bound_regions(self.gat, t.clone()).visit_with(self)\n+    }\n+\n     fn visit_ty(&mut self, t: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n         match t.kind() {\n             ty::Projection(p) if p.item_def_id == self.gat => {"}, {"sha": "f8d790c37852c3b792847cabcda6b6f26ec1841b", "filename": "library/std/src/thread/mod.rs", "status": "modified", "additions": 66, "deletions": 27, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/42313dd29b3edb0ab453a0d43d12876ec7e48ce0/library%2Fstd%2Fsrc%2Fthread%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42313dd29b3edb0ab453a0d43d12876ec7e48ce0/library%2Fstd%2Fsrc%2Fthread%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fthread%2Fmod.rs?ref=42313dd29b3edb0ab453a0d43d12876ec7e48ce0", "patch": "@@ -180,6 +180,12 @@ use crate::time::Duration;\n #[macro_use]\n mod local;\n \n+#[unstable(feature = \"scoped_threads\", issue = \"93203\")]\n+mod scoped;\n+\n+#[unstable(feature = \"scoped_threads\", issue = \"93203\")]\n+pub use scoped::{scope, Scope, ScopedJoinHandle};\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use self::local::{AccessError, LocalKey};\n \n@@ -446,6 +452,20 @@ impl Builder {\n         F: FnOnce() -> T,\n         F: Send + 'a,\n         T: Send + 'a,\n+    {\n+        Ok(JoinHandle(unsafe { self.spawn_unchecked_(f, None) }?))\n+    }\n+\n+    unsafe fn spawn_unchecked_<'a, 'scope, F, T>(\n+        self,\n+        f: F,\n+        scope_data: Option<&'scope scoped::ScopeData>,\n+    ) -> io::Result<JoinInner<'scope, T>>\n+    where\n+        F: FnOnce() -> T,\n+        F: Send + 'a,\n+        T: Send + 'a,\n+        'scope: 'a,\n     {\n         let Builder { name, stack_size } = self;\n \n@@ -456,7 +476,8 @@ impl Builder {\n         }));\n         let their_thread = my_thread.clone();\n \n-        let my_packet: Arc<UnsafeCell<Option<Result<T>>>> = Arc::new(UnsafeCell::new(None));\n+        let my_packet: Arc<Packet<'scope, T>> =\n+            Arc::new(Packet { scope: scope_data, result: UnsafeCell::new(None) });\n         let their_packet = my_packet.clone();\n \n         let output_capture = crate::io::set_output_capture(None);\n@@ -480,10 +501,14 @@ impl Builder {\n             // closure (it is an Arc<...>) and `my_packet` will be stored in the\n             // same `JoinInner` as this closure meaning the mutation will be\n             // safe (not modify it and affect a value far away).\n-            unsafe { *their_packet.get() = Some(try_result) };\n+            unsafe { *their_packet.result.get() = Some(try_result) };\n         };\n \n-        Ok(JoinHandle(JoinInner {\n+        if let Some(scope_data) = scope_data {\n+            scope_data.increment_num_running_threads();\n+        }\n+\n+        Ok(JoinInner {\n             // SAFETY:\n             //\n             // `imp::Thread::new` takes a closure with a `'static` lifetime, since it's passed\n@@ -506,8 +531,8 @@ impl Builder {\n                 )?\n             },\n             thread: my_thread,\n-            packet: Packet(my_packet),\n-        }))\n+            packet: my_packet,\n+        })\n     }\n }\n \n@@ -1242,34 +1267,48 @@ impl fmt::Debug for Thread {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub type Result<T> = crate::result::Result<T, Box<dyn Any + Send + 'static>>;\n \n-// This packet is used to communicate the return value between the spawned thread\n-// and the rest of the program. Memory is shared through the `Arc` within and there's\n-// no need for a mutex here because synchronization happens with `join()` (the\n-// caller will never read this packet until the thread has exited).\n+// This packet is used to communicate the return value between the spawned\n+// thread and the rest of the program. It is shared through an `Arc` and\n+// there's no need for a mutex here because synchronization happens with `join()`\n+// (the caller will never read this packet until the thread has exited).\n //\n-// This packet itself is then stored into a `JoinInner` which in turns is placed\n-// in `JoinHandle` and `JoinGuard`. Due to the usage of `UnsafeCell` we need to\n-// manually worry about impls like Send and Sync. The type `T` should\n-// already always be Send (otherwise the thread could not have been created) and\n-// this type is inherently Sync because no methods take &self. Regardless,\n-// however, we add inheriting impls for Send/Sync to this type to ensure it's\n-// Send/Sync and that future modifications will still appropriately classify it.\n-struct Packet<T>(Arc<UnsafeCell<Option<Result<T>>>>);\n-\n-unsafe impl<T: Send> Send for Packet<T> {}\n-unsafe impl<T: Sync> Sync for Packet<T> {}\n+// An Arc to the packet is stored into a `JoinInner` which in turns is placed\n+// in `JoinHandle`.\n+struct Packet<'scope, T> {\n+    scope: Option<&'scope scoped::ScopeData>,\n+    result: UnsafeCell<Option<Result<T>>>,\n+}\n+\n+// Due to the usage of `UnsafeCell` we need to manually implement Sync.\n+// The type `T` should already always be Send (otherwise the thread could not\n+// have been created) and the Packet is Sync because all access to the\n+// `UnsafeCell` synchronized (by the `join()` boundary), and `ScopeData` is Sync.\n+unsafe impl<'scope, T: Sync> Sync for Packet<'scope, T> {}\n+\n+impl<'scope, T> Drop for Packet<'scope, T> {\n+    fn drop(&mut self) {\n+        // Book-keeping so the scope knows when it's done.\n+        if let Some(scope) = self.scope {\n+            // If this packet was for a thread that ran in a scope, the thread\n+            // panicked, and nobody consumed the panic payload, we make sure\n+            // the scope function will panic.\n+            let unhandled_panic = matches!(self.result.get_mut(), Some(Err(_)));\n+            scope.decrement_num_running_threads(unhandled_panic);\n+        }\n+    }\n+}\n \n /// Inner representation for JoinHandle\n-struct JoinInner<T> {\n+struct JoinInner<'scope, T> {\n     native: imp::Thread,\n     thread: Thread,\n-    packet: Packet<T>,\n+    packet: Arc<Packet<'scope, T>>,\n }\n \n-impl<T> JoinInner<T> {\n+impl<'scope, T> JoinInner<'scope, T> {\n     fn join(mut self) -> Result<T> {\n         self.native.join();\n-        Arc::get_mut(&mut self.packet.0).unwrap().get_mut().take().unwrap()\n+        Arc::get_mut(&mut self.packet).unwrap().result.get_mut().take().unwrap()\n     }\n }\n \n@@ -1336,7 +1375,7 @@ impl<T> JoinInner<T> {\n /// [`thread::Builder::spawn`]: Builder::spawn\n /// [`thread::spawn`]: spawn\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct JoinHandle<T>(JoinInner<T>);\n+pub struct JoinHandle<T>(JoinInner<'static, T>);\n \n #[stable(feature = \"joinhandle_impl_send_sync\", since = \"1.29.0\")]\n unsafe impl<T> Send for JoinHandle<T> {}\n@@ -1404,13 +1443,13 @@ impl<T> JoinHandle<T> {\n         self.0.join()\n     }\n \n-    /// Checks if the the associated thread is still running its main function.\n+    /// Checks if the associated thread is still running its main function.\n     ///\n     /// This might return `false` for a brief moment after the thread's main\n     /// function has returned, but before the thread itself has stopped running.\n     #[unstable(feature = \"thread_is_running\", issue = \"90470\")]\n     pub fn is_running(&self) -> bool {\n-        Arc::strong_count(&self.0.packet.0) > 1\n+        Arc::strong_count(&self.0.packet) > 1\n     }\n }\n "}, {"sha": "9dd7c15fc592236e1c66337ba2223d757ad56dac", "filename": "library/std/src/thread/scoped.rs", "status": "added", "additions": 316, "deletions": 0, "changes": 316, "blob_url": "https://github.com/rust-lang/rust/blob/42313dd29b3edb0ab453a0d43d12876ec7e48ce0/library%2Fstd%2Fsrc%2Fthread%2Fscoped.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42313dd29b3edb0ab453a0d43d12876ec7e48ce0/library%2Fstd%2Fsrc%2Fthread%2Fscoped.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fthread%2Fscoped.rs?ref=42313dd29b3edb0ab453a0d43d12876ec7e48ce0", "patch": "@@ -0,0 +1,316 @@\n+use super::{current, park, Builder, JoinInner, Result, Thread};\n+use crate::fmt;\n+use crate::io;\n+use crate::marker::PhantomData;\n+use crate::panic::{catch_unwind, resume_unwind, AssertUnwindSafe};\n+use crate::sync::atomic::{AtomicBool, AtomicUsize, Ordering};\n+use crate::sync::Arc;\n+\n+/// A scope to spawn scoped threads in.\n+///\n+/// See [`scope`] for details.\n+pub struct Scope<'env> {\n+    data: ScopeData,\n+    /// Invariance over 'env, to make sure 'env cannot shrink,\n+    /// which is necessary for soundness.\n+    ///\n+    /// Without invariance, this would compile fine but be unsound:\n+    ///\n+    /// ```compile_fail\n+    /// #![feature(scoped_threads)]\n+    ///\n+    /// std::thread::scope(|s| {\n+    ///     s.spawn(|s| {\n+    ///         let a = String::from(\"abcd\");\n+    ///         s.spawn(|_| println!(\"{:?}\", a)); // might run after `a` is dropped\n+    ///     });\n+    /// });\n+    /// ```\n+    env: PhantomData<&'env mut &'env ()>,\n+}\n+\n+/// An owned permission to join on a scoped thread (block on its termination).\n+///\n+/// See [`Scope::spawn`] for details.\n+pub struct ScopedJoinHandle<'scope, T>(JoinInner<'scope, T>);\n+\n+pub(super) struct ScopeData {\n+    num_running_threads: AtomicUsize,\n+    a_thread_panicked: AtomicBool,\n+    main_thread: Thread,\n+}\n+\n+impl ScopeData {\n+    pub(super) fn increment_num_running_threads(&self) {\n+        // We check for 'overflow' with usize::MAX / 2, to make sure there's no\n+        // chance it overflows to 0, which would result in unsoundness.\n+        if self.num_running_threads.fetch_add(1, Ordering::Relaxed) > usize::MAX / 2 {\n+            // This can only reasonably happen by mem::forget()'ing many many ScopedJoinHandles.\n+            self.decrement_num_running_threads(false);\n+            panic!(\"too many running threads in thread scope\");\n+        }\n+    }\n+    pub(super) fn decrement_num_running_threads(&self, panic: bool) {\n+        if panic {\n+            self.a_thread_panicked.store(true, Ordering::Relaxed);\n+        }\n+        if self.num_running_threads.fetch_sub(1, Ordering::Release) == 1 {\n+            self.main_thread.unpark();\n+        }\n+    }\n+}\n+\n+/// Create a scope for spawning scoped threads.\n+///\n+/// The function passed to `scope` will be provided a [`Scope`] object,\n+/// through which scoped threads can be [spawned][`Scope::spawn`].\n+///\n+/// Unlike non-scoped threads, scoped threads can borrow non-`'static` data,\n+/// as the scope guarantees all threads will be joined at the end of the scope.\n+///\n+/// All threads spawned within the scope that haven't been manually joined\n+/// will be automatically joined before this function returns.\n+///\n+/// # Panics\n+///\n+/// If any of the automatically joined threads panicked, this function will panic.\n+///\n+/// If you want to handle panics from spawned threads,\n+/// [`join`][ScopedJoinHandle::join] them before the end of the scope.\n+///\n+/// # Example\n+///\n+/// ```\n+/// #![feature(scoped_threads)]\n+/// use std::thread;\n+///\n+/// let mut a = vec![1, 2, 3];\n+/// let mut x = 0;\n+///\n+/// thread::scope(|s| {\n+///     s.spawn(|_| {\n+///         println!(\"hello from the first scoped thread\");\n+///         // We can borrow `a` here.\n+///         dbg!(&a);\n+///     });\n+///     s.spawn(|_| {\n+///         println!(\"hello from the second scoped thread\");\n+///         // We can even mutably borrow `x` here,\n+///         // because no other threads are using it.\n+///         x += a[0] + a[2];\n+///     });\n+///     println!(\"hello from the main thread\");\n+/// });\n+///\n+/// // After the scope, we can modify and access our variables again:\n+/// a.push(4);\n+/// assert_eq!(x, a.len());\n+/// ```\n+#[track_caller]\n+pub fn scope<'env, F, T>(f: F) -> T\n+where\n+    F: FnOnce(&Scope<'env>) -> T,\n+{\n+    let scope = Scope {\n+        data: ScopeData {\n+            num_running_threads: AtomicUsize::new(0),\n+            main_thread: current(),\n+            a_thread_panicked: AtomicBool::new(false),\n+        },\n+        env: PhantomData,\n+    };\n+\n+    // Run `f`, but catch panics so we can make sure to wait for all the threads to join.\n+    let result = catch_unwind(AssertUnwindSafe(|| f(&scope)));\n+\n+    // Wait until all the threads are finished.\n+    while scope.data.num_running_threads.load(Ordering::Acquire) != 0 {\n+        park();\n+    }\n+\n+    // Throw any panic from `f`, or the return value of `f` if no thread panicked.\n+    match result {\n+        Err(e) => resume_unwind(e),\n+        Ok(_) if scope.data.a_thread_panicked.load(Ordering::Relaxed) => {\n+            panic!(\"a scoped thread panicked\")\n+        }\n+        Ok(result) => result,\n+    }\n+}\n+\n+impl<'env> Scope<'env> {\n+    /// Spawns a new thread within a scope, returning a [`ScopedJoinHandle`] for it.\n+    ///\n+    /// Unlike non-scoped threads, threads spawned with this function may\n+    /// borrow non-`'static` data from the outside the scope. See [`scope`] for\n+    /// details.\n+    ///\n+    /// The join handle provides a [`join`] method that can be used to join the spawned\n+    /// thread. If the spawned thread panics, [`join`] will return an [`Err`] containing\n+    /// the panic payload.\n+    ///\n+    /// If the join handle is dropped, the spawned thread will implicitly joined at the\n+    /// end of the scope. In that case, if the spawned thread panics, [`scope`] will\n+    /// panic after all threads are joined.\n+    ///\n+    /// This call will create a thread using default parameters of [`Builder`].\n+    /// If you want to specify the stack size or the name of the thread, use\n+    /// [`Builder::spawn_scoped`] instead.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if the OS fails to create a thread; use [`Builder::spawn_scoped`]\n+    /// to recover from such errors.\n+    ///\n+    /// [`join`]: ScopedJoinHandle::join\n+    pub fn spawn<'scope, F, T>(&'scope self, f: F) -> ScopedJoinHandle<'scope, T>\n+    where\n+        F: FnOnce(&Scope<'env>) -> T + Send + 'env,\n+        T: Send + 'env,\n+    {\n+        Builder::new().spawn_scoped(self, f).expect(\"failed to spawn thread\")\n+    }\n+}\n+\n+impl Builder {\n+    /// Spawns a new scoped thread using the settings set through this `Builder`.\n+    ///\n+    /// Unlike [`Scope::spawn`], this method yields an [`io::Result`] to\n+    /// capture any failure to create the thread at the OS level.\n+    ///\n+    /// [`io::Result`]: crate::io::Result\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if a thread name was set and it contained null bytes.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// #![feature(scoped_threads)]\n+    /// use std::thread;\n+    ///\n+    /// let mut a = vec![1, 2, 3];\n+    /// let mut x = 0;\n+    ///\n+    /// thread::scope(|s| {\n+    ///     thread::Builder::new()\n+    ///         .name(\"first\".to_string())\n+    ///         .spawn_scoped(s, |_|\n+    ///     {\n+    ///         println!(\"hello from the {:?} scoped thread\", thread::current().name());\n+    ///         // We can borrow `a` here.\n+    ///         dbg!(&a);\n+    ///     })\n+    ///     .unwrap();\n+    ///     thread::Builder::new()\n+    ///         .name(\"second\".to_string())\n+    ///         .spawn_scoped(s, |_|\n+    ///     {\n+    ///         println!(\"hello from the {:?} scoped thread\", thread::current().name());\n+    ///         // We can even mutably borrow `x` here,\n+    ///         // because no other threads are using it.\n+    ///         x += a[0] + a[2];\n+    ///     })\n+    ///     .unwrap();\n+    ///     println!(\"hello from the main thread\");\n+    /// });\n+    ///\n+    /// // After the scope, we can modify and access our variables again:\n+    /// a.push(4);\n+    /// assert_eq!(x, a.len());\n+    /// ```\n+    pub fn spawn_scoped<'scope, 'env, F, T>(\n+        self,\n+        scope: &'scope Scope<'env>,\n+        f: F,\n+    ) -> io::Result<ScopedJoinHandle<'scope, T>>\n+    where\n+        F: FnOnce(&Scope<'env>) -> T + Send + 'env,\n+        T: Send + 'env,\n+    {\n+        Ok(ScopedJoinHandle(unsafe { self.spawn_unchecked_(|| f(scope), Some(&scope.data)) }?))\n+    }\n+}\n+\n+impl<'scope, T> ScopedJoinHandle<'scope, T> {\n+    /// Extracts a handle to the underlying thread.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(scoped_threads)]\n+    /// #![feature(thread_is_running)]\n+    ///\n+    /// use std::thread;\n+    ///\n+    /// thread::scope(|s| {\n+    ///     let t = s.spawn(|_| {\n+    ///         println!(\"hello\");\n+    ///     });\n+    ///     println!(\"thread id: {:?}\", t.thread().id());\n+    /// });\n+    /// ```\n+    #[must_use]\n+    pub fn thread(&self) -> &Thread {\n+        &self.0.thread\n+    }\n+\n+    /// Waits for the associated thread to finish.\n+    ///\n+    /// This function will return immediately if the associated thread has already finished.\n+    ///\n+    /// In terms of [atomic memory orderings], the completion of the associated\n+    /// thread synchronizes with this function returning.\n+    /// In other words, all operations performed by that thread\n+    /// [happen before](https://doc.rust-lang.org/nomicon/atomics.html#data-accesses)\n+    /// all operations that happen after `join` returns.\n+    ///\n+    /// If the associated thread panics, [`Err`] is returned with the panic payload.\n+    ///\n+    /// [atomic memory orderings]: crate::sync::atomic\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(scoped_threads)]\n+    /// #![feature(thread_is_running)]\n+    ///\n+    /// use std::thread;\n+    ///\n+    /// thread::scope(|s| {\n+    ///     let t = s.spawn(|_| {\n+    ///         panic!(\"oh no\");\n+    ///     });\n+    ///     assert!(t.join().is_err());\n+    /// });\n+    /// ```\n+    pub fn join(self) -> Result<T> {\n+        self.0.join()\n+    }\n+\n+    /// Checks if the associated thread is still running its main function.\n+    ///\n+    /// This might return `false` for a brief moment after the thread's main\n+    /// function has returned, but before the thread itself has stopped running.\n+    #[unstable(feature = \"thread_is_running\", issue = \"90470\")]\n+    pub fn is_running(&self) -> bool {\n+        Arc::strong_count(&self.0.packet) > 1\n+    }\n+}\n+\n+impl<'env> fmt::Debug for Scope<'env> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_struct(\"Scope\")\n+            .field(\"num_running_threads\", &self.data.num_running_threads.load(Ordering::Relaxed))\n+            .field(\"a_thread_panicked\", &self.data.a_thread_panicked.load(Ordering::Relaxed))\n+            .field(\"main_thread\", &self.data.main_thread)\n+            .finish_non_exhaustive()\n+    }\n+}\n+\n+impl<'scope, T> fmt::Debug for ScopedJoinHandle<'scope, T> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_struct(\"ScopedJoinHandle\").finish_non_exhaustive()\n+    }\n+}"}, {"sha": "37fd67447c1340867ca51fd03e7facf0da993153", "filename": "src/doc/unstable-book/src/language-features/asm-experimental-arch.md", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/42313dd29b3edb0ab453a0d43d12876ec7e48ce0/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fasm-experimental-arch.md", "raw_url": "https://github.com/rust-lang/rust/raw/42313dd29b3edb0ab453a0d43d12876ec7e48ce0/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fasm-experimental-arch.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fasm-experimental-arch.md?ref=42313dd29b3edb0ab453a0d43d12876ec7e48ce0", "patch": "@@ -15,6 +15,7 @@ This feature tracks `asm!` and `global_asm!` support for the following architect\n - BPF\n - SPIR-V\n - AVR\n+- MSP430\n \n ## Register classes\n \n@@ -39,6 +40,7 @@ This feature tracks `asm!` and `global_asm!` support for the following architect\n | AVR          | `reg_pair`     | `r3r2` .. `r25r24`, `X`, `Z`       | `r`                  |\n | AVR          | `reg_iw`       | `r25r24`, `X`, `Z`                 | `w`                  |\n | AVR          | `reg_ptr`      | `X`, `Z`                           | `e`                  |\n+| MSP430       | `reg`          | `r[0-15]`                          | `r`                  |\n \n > **Notes**:\n > - NVPTX doesn't have a fixed register set, so named registers are not supported.\n@@ -67,6 +69,7 @@ This feature tracks `asm!` and `global_asm!` support for the following architect\n | BPF          | `wreg`                          | `alu32`        | `i8` `i16` `i32`                        |\n | AVR          | `reg`, `reg_upper`              | None           | `i8`                                    |\n | AVR          | `reg_pair`, `reg_iw`, `reg_ptr` | None           | `i16`                                   |\n+| MSP430       | `reg`                           | None           | `i8`, `i16`                             |\n \n ## Register aliases\n \n@@ -80,13 +83,22 @@ This feature tracks `asm!` and `global_asm!` support for the following architect\n | AVR          | `XL`          | `r26`     |\n | AVR          | `ZH`          | `r31`     |\n | AVR          | `ZL`          | `r30`     |\n+| MSP430       | `r0`          | `pc`      |\n+| MSP430       | `r1`          | `sp`      |\n+| MSP430       | `r2`          | `sr`      |\n+| MSP430       | `r3`          | `cg`      |\n+| MSP430       | `r4`          | `fp`      |\n+\n+> **Notes**:\n+> - TI does not mandate a frame pointer for MSP430, but toolchains are allowed\n+    to use one; LLVM uses `r4`.\n \n ## Unsupported registers\n \n | Architecture | Unsupported register                    | Reason                                                                                                                                                                              |\n | ------------ | --------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n | All          | `sp`                                    | The stack pointer must be restored to its original value at the end of an asm code block.                                                                                           |\n-| All          | `fr` (Hexagon), `$fp` (MIPS), `Y` (AVR) | The frame pointer cannot be used as an input or output.                                                                                                                             |\n+| All          | `fr` (Hexagon), `$fp` (MIPS), `Y` (AVR), `r4` (MSP430) | The frame pointer cannot be used as an input or output.                                                                                                                             |\n | All          | `r19` (Hexagon)                         | This is used internally by LLVM as a \"base pointer\" for functions with complex stack frames.                                                                                        |\n | MIPS         | `$0` or `$zero`                         | This is a constant zero register which can't be modified.                                                                                                                           |\n | MIPS         | `$1` or `$at`                           | Reserved for assembler.                                                                                                                                                             |\n@@ -95,6 +107,7 @@ This feature tracks `asm!` and `global_asm!` support for the following architect\n | MIPS         | `$ra`                                   | Return address cannot be used as inputs or outputs.                                                                                                                                 |\n | Hexagon      | `lr`                                    | This is the link register which cannot be used as an input or output.                                                                                                               |\n | AVR          | `r0`, `r1`, `r1r0`                      | Due to an issue in LLVM, the `r0` and `r1` registers cannot be used as inputs or outputs.  If modified, they must be restored to their original values before the end of the block. |\n+|MSP430        | `r0`, `r2`, `r3`                        | These are the program counter, status register, and constant generator respectively. Neither the status register nor constant generator can be written to.                          |\n \n ## Template modifiers\n \n@@ -115,3 +128,5 @@ This feature tracks `asm!` and `global_asm!` support for the following architect\n These flags registers must be restored upon exiting the asm block if the `preserves_flags` option is set:\n - AVR\n   - The status register `SREG`.\n+- MSP430\n+  - The status register `r2`."}, {"sha": "731e18b1eec2cf20dce6538a62ba831a6396dd46", "filename": "src/librustdoc/html/render/span_map.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/42313dd29b3edb0ab453a0d43d12876ec7e48ce0/src%2Flibrustdoc%2Fhtml%2Frender%2Fspan_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42313dd29b3edb0ab453a0d43d12876ec7e48ce0/src%2Flibrustdoc%2Fhtml%2Frender%2Fspan_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fspan_map.rs?ref=42313dd29b3edb0ab453a0d43d12876ec7e48ce0", "patch": "@@ -134,11 +134,13 @@ impl<'tcx> Visitor<'tcx> for SpanMapVisitor<'tcx> {\n             if let Some(hir_id) = segment.hir_id {\n                 let hir = self.tcx.hir();\n                 let body_id = hir.enclosing_body_owner(hir_id);\n-                let typeck_results = self.tcx.sess.with_disabled_diagnostic(|| {\n-                    self.tcx.typeck_body(\n-                        hir.maybe_body_owned_by(body_id).expect(\"a body which isn't a body\"),\n-                    )\n-                });\n+                // FIXME: this is showing error messages for parts of the code that are not\n+                // compiled (because of cfg)!\n+                //\n+                // See discussion in https://github.com/rust-lang/rust/issues/69426#issuecomment-1019412352\n+                let typeck_results = self.tcx.typeck_body(\n+                    hir.maybe_body_owned_by(body_id).expect(\"a body which isn't a body\"),\n+                );\n                 if let Some(def_id) = typeck_results.type_dependent_def_id(expr.hir_id) {\n                     self.matches.insert(\n                         segment.ident.span,"}, {"sha": "6cfb86e276e2306bd93fd8a344b19edc9c25f544", "filename": "src/test/assembly/asm/msp430-types.rs", "status": "added", "additions": 158, "deletions": 0, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/42313dd29b3edb0ab453a0d43d12876ec7e48ce0/src%2Ftest%2Fassembly%2Fasm%2Fmsp430-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42313dd29b3edb0ab453a0d43d12876ec7e48ce0/src%2Ftest%2Fassembly%2Fasm%2Fmsp430-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fassembly%2Fasm%2Fmsp430-types.rs?ref=42313dd29b3edb0ab453a0d43d12876ec7e48ce0", "patch": "@@ -0,0 +1,158 @@\n+// min-llvm-version: 13.0\n+// assembly-output: emit-asm\n+// compile-flags: --target msp430-none-elf\n+// needs-llvm-components: msp430\n+\n+#![feature(no_core, lang_items, rustc_attrs, asm_sym, asm_experimental_arch, asm_const)]\n+#![crate_type = \"rlib\"]\n+#![no_core]\n+#![allow(non_camel_case_types)]\n+\n+#[rustc_builtin_macro]\n+macro_rules! asm {\n+    () => {};\n+}\n+#[rustc_builtin_macro]\n+macro_rules! concat {\n+    () => {};\n+}\n+\n+#[lang = \"sized\"]\n+trait Sized {}\n+#[lang = \"copy\"]\n+trait Copy {}\n+\n+type ptr = *const i16;\n+\n+impl Copy for i8 {}\n+impl Copy for i16 {}\n+impl Copy for i32 {}\n+impl Copy for i64 {}\n+impl Copy for ptr {}\n+\n+macro_rules! check {\n+    ($func:ident $ty:ident $class:ident) => {\n+        #[no_mangle]\n+        pub unsafe fn $func(x: $ty) -> $ty {\n+            let y;\n+            asm!(\"mov {}, {}\", lateout($class) y, in($class) x);\n+            y\n+        }\n+    };\n+}\n+\n+macro_rules! checkb {\n+    ($func:ident $ty:ident $class:ident) => {\n+        #[no_mangle]\n+        pub unsafe fn $func(x: $ty) -> $ty {\n+            let y;\n+            asm!(\"mov.b {}, {}\", lateout($class) y, in($class) x);\n+            y\n+        }\n+    };\n+}\n+\n+macro_rules! check_reg {\n+    ($func:ident $ty:ident $reg:tt) => {\n+        #[no_mangle]\n+        pub unsafe fn $func(x: $ty) -> $ty {\n+            let y;\n+            asm!(concat!(\"mov \", $reg, \", \", $reg), lateout($reg) y, in($reg) x);\n+            y\n+        }\n+    };\n+}\n+\n+macro_rules! check_regb {\n+    ($func:ident $ty:ident $reg:tt) => {\n+        #[no_mangle]\n+        pub unsafe fn $func(x: $ty) -> $ty {\n+            let y;\n+            asm!(concat!(\"mov.b \", $reg, \", \", $reg), lateout($reg) y, in($reg) x);\n+            y\n+        }\n+    };\n+}\n+\n+extern \"C\" {\n+    fn extern_func();\n+    static extern_static: i8;\n+}\n+\n+// CHECK-LABEL: sym_fn\n+// CHECK: ;APP\n+// CHECK: call extern_func\n+// CHECK: ;NO_APP\n+#[no_mangle]\n+pub unsafe fn sym_fn() {\n+    asm!(\"call {}\", sym extern_func);\n+}\n+\n+// CHECK-LABEL: sym_static\n+// CHECK: ;APP\n+// CHECK: mov.b extern_static, r{{[0-9]+}}\n+// CHECK: ;NO_APP\n+#[no_mangle]\n+pub unsafe fn sym_static() -> i8 {\n+    let y;\n+    asm!(\"mov.b {1}, {0}\", lateout(reg) y, sym extern_static);\n+    y\n+}\n+\n+// CHECK-LABEL: add_const:\n+// CHECK: ;APP\n+// CHECK: add.b #5, r{{[0-9]+}}\n+// CHECK: ;NO_APP\n+#[no_mangle]\n+pub unsafe fn add_const() -> i8 {\n+    let y;\n+    asm!(\"add.b #{number}, {}\", out(reg) y, number = const 5);\n+    y\n+}\n+\n+// CHECK-LABEL: mov_postincrement:\n+// CHECK: ;APP\n+// CHECK: mov @r5+, r{{[0-9]+}}\n+// CHECK: ;NO_APP\n+#[no_mangle]\n+pub unsafe fn mov_postincrement(mut x: *const i16) -> (i16, *const i16) {\n+    let y;\n+    asm!(\"mov @r5+, {0}\", out(reg) y, inlateout(\"r5\") x);\n+    (y, x)\n+}\n+\n+// CHECK-LABEL: reg_i8:\n+// CHECK: ;APP\n+// CHECK: mov r{{[0-9]+}}, r{{[0-9]+}}\n+// CHECK: ;NO_APP\n+check!(reg_i8 i8 reg);\n+\n+// CHECK-LABEL: reg_i16:\n+// CHECK: ;APP\n+// CHECK: mov r{{[0-9]+}}, r{{[0-9]+}}\n+// CHECK: ;NO_APP\n+check!(reg_i16 i16 reg);\n+\n+// CHECK-LABEL: reg_i8b:\n+// CHECK: ;APP\n+// CHECK: mov.b r{{[0-9]+}}, r{{[0-9]+}}\n+// CHECK: ;NO_APP\n+checkb!(reg_i8b i8 reg);\n+\n+// CHECK-LABEL: r5_i8:\n+// CHECK: ;APP\n+// CHECK: mov r5, r5\n+// CHECK: ;NO_APP\n+check_reg!(r5_i8 i8 \"r5\");\n+\n+// CHECK-LABEL: r5_i16:\n+// CHECK: ;APP\n+// CHECK: mov r5, r5\n+// CHECK: ;NO_APP\n+check_reg!(r5_i16 i16 \"r5\");\n+\n+// CHECK-LABEL: r5_i8b:\n+// CHECK: ;APP\n+// CHECK: mov.b r5, r5\n+// CHECK: ;NO_APP\n+check_regb!(r5_i8b i8 \"r5\");"}, {"sha": "95c090ff4e9065a0b819c632c82426d418328594", "filename": "src/test/ui/generic-associated-types/issue-92954.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/42313dd29b3edb0ab453a0d43d12876ec7e48ce0/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-92954.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42313dd29b3edb0ab453a0d43d12876ec7e48ce0/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-92954.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-92954.rs?ref=42313dd29b3edb0ab453a0d43d12876ec7e48ce0", "patch": "@@ -0,0 +1,10 @@\n+// check-pass\n+\n+#![feature(generic_associated_types)]\n+\n+pub trait Foo {\n+    type Assoc<'c>;\n+    fn function() -> for<'x> fn(Self::Assoc<'x>);\n+}\n+\n+fn main() {}"}, {"sha": "39ca77d13db99b848f63b90ba730752c44180feb", "filename": "src/test/ui/generic-associated-types/issue-93141.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/42313dd29b3edb0ab453a0d43d12876ec7e48ce0/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-93141.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42313dd29b3edb0ab453a0d43d12876ec7e48ce0/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-93141.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-93141.rs?ref=42313dd29b3edb0ab453a0d43d12876ec7e48ce0", "patch": "@@ -0,0 +1,25 @@\n+// check-pass\n+\n+#![feature(generic_associated_types)]\n+\n+pub trait Fooey: Sized {\n+    type Context<'c> where Self: 'c;\n+}\n+\n+pub struct Handle<E: Fooey>(Option<Box<dyn for<'c> Fn(&mut E::Context<'c>)>>);\n+\n+fn tuple<T>() -> (Option<T>,) { (Option::None,) }\n+\n+pub struct FooImpl {}\n+impl Fooey for FooImpl {\n+    type Context<'c> = &'c ();\n+}\n+\n+impl FooImpl {\n+    pub fn fail1() -> Handle<Self> {\n+        let (tx,) = tuple();\n+        Handle(tx)\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "4a36515b9912820fd9a60c7d875071d15b7500ce", "filename": "src/test/ui/rfc-2294-if-let-guard/feature-gate.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/42313dd29b3edb0ab453a0d43d12876ec7e48ce0/src%2Ftest%2Fui%2Frfc-2294-if-let-guard%2Ffeature-gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42313dd29b3edb0ab453a0d43d12876ec7e48ce0/src%2Ftest%2Fui%2Frfc-2294-if-let-guard%2Ffeature-gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2294-if-let-guard%2Ffeature-gate.rs?ref=42313dd29b3edb0ab453a0d43d12876ec7e48ce0", "patch": "@@ -14,10 +14,12 @@ fn _if_let_guard() {\n         //~^ ERROR `let` expressions in this position are unstable\n \n         () if true && let 0 = 1 => {}\n-        //~^ ERROR `let` expressions in this position are unstable\n+        //~^ ERROR `if let` guards are experimental\n+        //~| ERROR `let` expressions in this position are unstable\n \n         () if let 0 = 1 && true => {}\n-        //~^ ERROR `let` expressions in this position are unstable\n+        //~^ ERROR `if let` guards are experimental\n+        //~| ERROR `let` expressions in this position are unstable\n \n         () if (let 0 = 1) && true => {}\n         //~^ ERROR `let` expressions in this position are unstable\n@@ -30,14 +32,17 @@ fn _if_let_guard() {\n         //~| ERROR `let` expressions in this position are unstable\n \n         () if let 0 = 1 && let 1 = 2 && (let 2 = 3 && let 3 = 4 && let 4 = 5) => {}\n-        //~^ ERROR `let` expressions in this position are unstable\n+        //~^ ERROR `if let` guards are experimental\n+        //~| ERROR `let` expressions in this position are unstable\n         //~| ERROR `let` expressions in this position are unstable\n         //~| ERROR `let` expressions in this position are unstable\n         //~| ERROR `let` expressions in this position are unstable\n         //~| ERROR `let` expressions in this position are unstable\n \n         () if let Range { start: _, end: _ } = (true..true) && false => {}\n-        //~^ ERROR `let` expressions in this position are unstable\n+        //~^ ERROR `if let` guards are experimental\n+        //~| ERROR `let` expressions in this position are unstable\n+\n         _ => {}\n     }\n }"}, {"sha": "8d93fb87f7ad19ba6c3b7a60e9310d2cbc3b2a91", "filename": "src/test/ui/rfc-2294-if-let-guard/feature-gate.stderr", "status": "modified", "additions": 56, "deletions": 16, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/42313dd29b3edb0ab453a0d43d12876ec7e48ce0/src%2Ftest%2Fui%2Frfc-2294-if-let-guard%2Ffeature-gate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/42313dd29b3edb0ab453a0d43d12876ec7e48ce0/src%2Ftest%2Fui%2Frfc-2294-if-let-guard%2Ffeature-gate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2294-if-let-guard%2Ffeature-gate.stderr?ref=42313dd29b3edb0ab453a0d43d12876ec7e48ce0", "patch": "@@ -1,5 +1,5 @@\n error: no rules expected the token `let`\n-  --> $DIR/feature-gate.rs:64:15\n+  --> $DIR/feature-gate.rs:69:15\n    |\n LL |     macro_rules! use_expr {\n    |     --------------------- when calling this macro\n@@ -18,7 +18,47 @@ LL |         () if let 0 = 1 => {}\n    = help: you can write `if matches!(<expr>, <pattern>)` instead of `if let <pattern> = <expr>`\n \n error[E0658]: `if let` guards are experimental\n-  --> $DIR/feature-gate.rs:60:12\n+  --> $DIR/feature-gate.rs:16:12\n+   |\n+LL |         () if true && let 0 = 1 => {}\n+   |            ^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: see issue #51114 <https://github.com/rust-lang/rust/issues/51114> for more information\n+   = help: add `#![feature(if_let_guard)]` to the crate attributes to enable\n+   = help: you can write `if matches!(<expr>, <pattern>)` instead of `if let <pattern> = <expr>`\n+\n+error[E0658]: `if let` guards are experimental\n+  --> $DIR/feature-gate.rs:20:12\n+   |\n+LL |         () if let 0 = 1 && true => {}\n+   |            ^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: see issue #51114 <https://github.com/rust-lang/rust/issues/51114> for more information\n+   = help: add `#![feature(if_let_guard)]` to the crate attributes to enable\n+   = help: you can write `if matches!(<expr>, <pattern>)` instead of `if let <pattern> = <expr>`\n+\n+error[E0658]: `if let` guards are experimental\n+  --> $DIR/feature-gate.rs:34:12\n+   |\n+LL |         () if let 0 = 1 && let 1 = 2 && (let 2 = 3 && let 3 = 4 && let 4 = 5) => {}\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: see issue #51114 <https://github.com/rust-lang/rust/issues/51114> for more information\n+   = help: add `#![feature(if_let_guard)]` to the crate attributes to enable\n+   = help: you can write `if matches!(<expr>, <pattern>)` instead of `if let <pattern> = <expr>`\n+\n+error[E0658]: `if let` guards are experimental\n+  --> $DIR/feature-gate.rs:42:12\n+   |\n+LL |         () if let Range { start: _, end: _ } = (true..true) && false => {}\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: see issue #51114 <https://github.com/rust-lang/rust/issues/51114> for more information\n+   = help: add `#![feature(if_let_guard)]` to the crate attributes to enable\n+   = help: you can write `if matches!(<expr>, <pattern>)` instead of `if let <pattern> = <expr>`\n+\n+error[E0658]: `if let` guards are experimental\n+  --> $DIR/feature-gate.rs:65:12\n    |\n LL |         () if let 0 = 1 => {}\n    |            ^^^^^^^^^^^^\n@@ -55,7 +95,7 @@ LL |         () if true && let 0 = 1 => {}\n    = help: add `#![feature(let_chains)]` to the crate attributes to enable\n \n error[E0658]: `let` expressions in this position are unstable\n-  --> $DIR/feature-gate.rs:19:15\n+  --> $DIR/feature-gate.rs:20:15\n    |\n LL |         () if let 0 = 1 && true => {}\n    |               ^^^^^^^^^\n@@ -64,7 +104,7 @@ LL |         () if let 0 = 1 && true => {}\n    = help: add `#![feature(let_chains)]` to the crate attributes to enable\n \n error[E0658]: `let` expressions in this position are unstable\n-  --> $DIR/feature-gate.rs:22:16\n+  --> $DIR/feature-gate.rs:24:16\n    |\n LL |         () if (let 0 = 1) && true => {}\n    |                ^^^^^^^^^\n@@ -73,7 +113,7 @@ LL |         () if (let 0 = 1) && true => {}\n    = help: add `#![feature(let_chains)]` to the crate attributes to enable\n \n error[E0658]: `let` expressions in this position are unstable\n-  --> $DIR/feature-gate.rs:25:24\n+  --> $DIR/feature-gate.rs:27:24\n    |\n LL |         () if true && (let 0 = 1) => {}\n    |                        ^^^^^^^^^\n@@ -82,7 +122,7 @@ LL |         () if true && (let 0 = 1) => {}\n    = help: add `#![feature(let_chains)]` to the crate attributes to enable\n \n error[E0658]: `let` expressions in this position are unstable\n-  --> $DIR/feature-gate.rs:28:16\n+  --> $DIR/feature-gate.rs:30:16\n    |\n LL |         () if (let 0 = 1) && (let 0 = 1) => {}\n    |                ^^^^^^^^^\n@@ -91,7 +131,7 @@ LL |         () if (let 0 = 1) && (let 0 = 1) => {}\n    = help: add `#![feature(let_chains)]` to the crate attributes to enable\n \n error[E0658]: `let` expressions in this position are unstable\n-  --> $DIR/feature-gate.rs:28:31\n+  --> $DIR/feature-gate.rs:30:31\n    |\n LL |         () if (let 0 = 1) && (let 0 = 1) => {}\n    |                               ^^^^^^^^^\n@@ -100,7 +140,7 @@ LL |         () if (let 0 = 1) && (let 0 = 1) => {}\n    = help: add `#![feature(let_chains)]` to the crate attributes to enable\n \n error[E0658]: `let` expressions in this position are unstable\n-  --> $DIR/feature-gate.rs:32:15\n+  --> $DIR/feature-gate.rs:34:15\n    |\n LL |         () if let 0 = 1 && let 1 = 2 && (let 2 = 3 && let 3 = 4 && let 4 = 5) => {}\n    |               ^^^^^^^^^\n@@ -109,7 +149,7 @@ LL |         () if let 0 = 1 && let 1 = 2 && (let 2 = 3 && let 3 = 4 && let 4 =\n    = help: add `#![feature(let_chains)]` to the crate attributes to enable\n \n error[E0658]: `let` expressions in this position are unstable\n-  --> $DIR/feature-gate.rs:32:28\n+  --> $DIR/feature-gate.rs:34:28\n    |\n LL |         () if let 0 = 1 && let 1 = 2 && (let 2 = 3 && let 3 = 4 && let 4 = 5) => {}\n    |                            ^^^^^^^^^\n@@ -118,7 +158,7 @@ LL |         () if let 0 = 1 && let 1 = 2 && (let 2 = 3 && let 3 = 4 && let 4 =\n    = help: add `#![feature(let_chains)]` to the crate attributes to enable\n \n error[E0658]: `let` expressions in this position are unstable\n-  --> $DIR/feature-gate.rs:32:42\n+  --> $DIR/feature-gate.rs:34:42\n    |\n LL |         () if let 0 = 1 && let 1 = 2 && (let 2 = 3 && let 3 = 4 && let 4 = 5) => {}\n    |                                          ^^^^^^^^^\n@@ -127,7 +167,7 @@ LL |         () if let 0 = 1 && let 1 = 2 && (let 2 = 3 && let 3 = 4 && let 4 =\n    = help: add `#![feature(let_chains)]` to the crate attributes to enable\n \n error[E0658]: `let` expressions in this position are unstable\n-  --> $DIR/feature-gate.rs:32:55\n+  --> $DIR/feature-gate.rs:34:55\n    |\n LL |         () if let 0 = 1 && let 1 = 2 && (let 2 = 3 && let 3 = 4 && let 4 = 5) => {}\n    |                                                       ^^^^^^^^^\n@@ -136,7 +176,7 @@ LL |         () if let 0 = 1 && let 1 = 2 && (let 2 = 3 && let 3 = 4 && let 4 =\n    = help: add `#![feature(let_chains)]` to the crate attributes to enable\n \n error[E0658]: `let` expressions in this position are unstable\n-  --> $DIR/feature-gate.rs:32:68\n+  --> $DIR/feature-gate.rs:34:68\n    |\n LL |         () if let 0 = 1 && let 1 = 2 && (let 2 = 3 && let 3 = 4 && let 4 = 5) => {}\n    |                                                                    ^^^^^^^^^\n@@ -145,7 +185,7 @@ LL |         () if let 0 = 1 && let 1 = 2 && (let 2 = 3 && let 3 = 4 && let 4 =\n    = help: add `#![feature(let_chains)]` to the crate attributes to enable\n \n error[E0658]: `let` expressions in this position are unstable\n-  --> $DIR/feature-gate.rs:39:15\n+  --> $DIR/feature-gate.rs:42:15\n    |\n LL |         () if let Range { start: _, end: _ } = (true..true) && false => {}\n    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -154,7 +194,7 @@ LL |         () if let Range { start: _, end: _ } = (true..true) && false => {}\n    = help: add `#![feature(let_chains)]` to the crate attributes to enable\n \n error[E0658]: `let` expressions in this position are unstable\n-  --> $DIR/feature-gate.rs:54:16\n+  --> $DIR/feature-gate.rs:59:16\n    |\n LL |     use_expr!((let 0 = 1 && 0 == 0));\n    |                ^^^^^^^^^\n@@ -163,14 +203,14 @@ LL |     use_expr!((let 0 = 1 && 0 == 0));\n    = help: add `#![feature(let_chains)]` to the crate attributes to enable\n \n error[E0658]: `let` expressions in this position are unstable\n-  --> $DIR/feature-gate.rs:56:16\n+  --> $DIR/feature-gate.rs:61:16\n    |\n LL |     use_expr!((let 0 = 1));\n    |                ^^^^^^^^^\n    |\n    = note: see issue #53667 <https://github.com/rust-lang/rust/issues/53667> for more information\n    = help: add `#![feature(let_chains)]` to the crate attributes to enable\n \n-error: aborting due to 19 previous errors\n+error: aborting due to 23 previous errors\n \n For more information about this error, try `rustc --explain E0658`."}, {"sha": "f90b9ab0d40f03c9823583dc785d1e78f56749c8", "filename": "src/test/ui/rfc-2497-if-let-chains/issue-93150.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/42313dd29b3edb0ab453a0d43d12876ec7e48ce0/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fissue-93150.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42313dd29b3edb0ab453a0d43d12876ec7e48ce0/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fissue-93150.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fissue-93150.rs?ref=42313dd29b3edb0ab453a0d43d12876ec7e48ce0", "patch": "@@ -0,0 +1,8 @@\n+fn main() {\n+    match true {\n+        _ if let true = true && true => {}\n+        //~^ ERROR `if let` guards are\n+        //~| ERROR `let` expressions in this\n+        _ => {}\n+    }\n+}"}, {"sha": "b25f299a2190f939eb8bddcef3fa4e15d9eedd24", "filename": "src/test/ui/rfc-2497-if-let-chains/issue-93150.stderr", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/42313dd29b3edb0ab453a0d43d12876ec7e48ce0/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fissue-93150.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/42313dd29b3edb0ab453a0d43d12876ec7e48ce0/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fissue-93150.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fissue-93150.stderr?ref=42313dd29b3edb0ab453a0d43d12876ec7e48ce0", "patch": "@@ -0,0 +1,22 @@\n+error[E0658]: `if let` guards are experimental\n+  --> $DIR/issue-93150.rs:3:11\n+   |\n+LL |         _ if let true = true && true => {}\n+   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: see issue #51114 <https://github.com/rust-lang/rust/issues/51114> for more information\n+   = help: add `#![feature(if_let_guard)]` to the crate attributes to enable\n+   = help: you can write `if matches!(<expr>, <pattern>)` instead of `if let <pattern> = <expr>`\n+\n+error[E0658]: `let` expressions in this position are unstable\n+  --> $DIR/issue-93150.rs:3:14\n+   |\n+LL |         _ if let true = true && true => {}\n+   |              ^^^^^^^^^^^^^^^\n+   |\n+   = note: see issue #53667 <https://github.com/rust-lang/rust/issues/53667> for more information\n+   = help: add `#![feature(let_chains)]` to the crate attributes to enable\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0658`."}, {"sha": "e109ee0009ee0f624e725acad27ca90dbfc36995", "filename": "src/tools/clippy/clippy_lints/src/approx_const.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/42313dd29b3edb0ab453a0d43d12876ec7e48ce0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fapprox_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42313dd29b3edb0ab453a0d43d12876ec7e48ce0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fapprox_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fapprox_const.rs?ref=42313dd29b3edb0ab453a0d43d12876ec7e48ce0", "patch": "@@ -2,7 +2,7 @@ use clippy_utils::diagnostics::span_lint_and_help;\n use clippy_utils::{meets_msrv, msrvs};\n use rustc_ast::ast::{FloatTy, LitFloatType, LitKind};\n use rustc_hir::{Expr, ExprKind};\n-use rustc_lint::{LateContext, LateLintPass, LintContext};\n+use rustc_lint::{LateContext, LateLintPass};\n use rustc_semver::RustcVersion;\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::symbol;"}, {"sha": "88b91d589074d85e300c79979bab0d89269e1b6a", "filename": "src/tools/clippy/clippy_lints/src/as_conversions.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/42313dd29b3edb0ab453a0d43d12876ec7e48ce0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fas_conversions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42313dd29b3edb0ab453a0d43d12876ec7e48ce0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fas_conversions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fas_conversions.rs?ref=42313dd29b3edb0ab453a0d43d12876ec7e48ce0", "patch": "@@ -1,6 +1,6 @@\n use clippy_utils::diagnostics::span_lint_and_help;\n use rustc_ast::ast::{Expr, ExprKind};\n-use rustc_lint::{EarlyContext, EarlyLintPass};\n+use rustc_lint::{EarlyContext, EarlyLintPass, LintContext};\n use rustc_middle::lint::in_external_macro;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n \n@@ -48,7 +48,7 @@ declare_lint_pass!(AsConversions => [AS_CONVERSIONS]);\n \n impl EarlyLintPass for AsConversions {\n     fn check_expr(&mut self, cx: &EarlyContext<'_>, expr: &Expr) {\n-        if in_external_macro(cx.sess, expr.span) {\n+        if in_external_macro(cx.sess(), expr.span) {\n             return;\n         }\n "}, {"sha": "0c27c3f9255f28585175bf42c52833860a1d5760", "filename": "src/tools/clippy/clippy_lints/src/disallowed_script_idents.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/42313dd29b3edb0ab453a0d43d12876ec7e48ce0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdisallowed_script_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42313dd29b3edb0ab453a0d43d12876ec7e48ce0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdisallowed_script_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdisallowed_script_idents.rs?ref=42313dd29b3edb0ab453a0d43d12876ec7e48ce0", "patch": "@@ -1,7 +1,7 @@\n use clippy_utils::diagnostics::span_lint;\n use rustc_ast::ast;\n use rustc_data_structures::fx::FxHashSet;\n-use rustc_lint::{EarlyContext, EarlyLintPass, Level};\n+use rustc_lint::{EarlyContext, EarlyLintPass, Level, LintContext};\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n use unicode_script::{Script, UnicodeScript};\n \n@@ -72,7 +72,7 @@ impl EarlyLintPass for DisallowedScriptIdents {\n             return;\n         }\n \n-        let symbols = cx.sess.parse_sess.symbol_gallery.symbols.lock();\n+        let symbols = cx.sess().parse_sess.symbol_gallery.symbols.lock();\n         // Sort by `Span` so that error messages make sense with respect to the\n         // order of identifier locations in the code.\n         let mut symbols: Vec<_> = symbols.iter().collect();"}, {"sha": "0b9f54231c59bc8566e06b8599ec04e9242893ac", "filename": "src/tools/clippy/clippy_lints/src/else_if_without_else.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/42313dd29b3edb0ab453a0d43d12876ec7e48ce0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Felse_if_without_else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42313dd29b3edb0ab453a0d43d12876ec7e48ce0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Felse_if_without_else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Felse_if_without_else.rs?ref=42313dd29b3edb0ab453a0d43d12876ec7e48ce0", "patch": "@@ -2,7 +2,7 @@\n \n use clippy_utils::diagnostics::span_lint_and_help;\n use rustc_ast::ast::{Expr, ExprKind};\n-use rustc_lint::{EarlyContext, EarlyLintPass};\n+use rustc_lint::{EarlyContext, EarlyLintPass, LintContext};\n use rustc_middle::lint::in_external_macro;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n \n@@ -50,7 +50,7 @@ declare_lint_pass!(ElseIfWithoutElse => [ELSE_IF_WITHOUT_ELSE]);\n \n impl EarlyLintPass for ElseIfWithoutElse {\n     fn check_expr(&mut self, cx: &EarlyContext<'_>, mut item: &Expr) {\n-        if in_external_macro(cx.sess, item.span) {\n+        if in_external_macro(cx.sess(), item.span) {\n             return;\n         }\n "}, {"sha": "ae18f8081bcc870d2b90f8a6e0f27a16f68176c5", "filename": "src/tools/clippy/clippy_lints/src/formatting.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/42313dd29b3edb0ab453a0d43d12876ec7e48ce0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fformatting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42313dd29b3edb0ab453a0d43d12876ec7e48ce0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fformatting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fformatting.rs?ref=42313dd29b3edb0ab453a0d43d12876ec7e48ce0", "patch": "@@ -3,7 +3,7 @@ use clippy_utils::differing_macro_contexts;\n use clippy_utils::source::snippet_opt;\n use if_chain::if_chain;\n use rustc_ast::ast::{BinOpKind, Block, Expr, ExprKind, StmtKind, UnOp};\n-use rustc_lint::{EarlyContext, EarlyLintPass};\n+use rustc_lint::{EarlyContext, EarlyLintPass, LintContext};\n use rustc_middle::lint::in_external_macro;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::source_map::Span;\n@@ -207,7 +207,7 @@ fn check_else(cx: &EarlyContext<'_>, expr: &Expr) {\n         if let ExprKind::If(_, then, Some(else_)) = &expr.kind;\n         if is_block(else_) || is_if(else_);\n         if !differing_macro_contexts(then.span, else_.span);\n-        if !then.span.from_expansion() && !in_external_macro(cx.sess, expr.span);\n+        if !then.span.from_expansion() && !in_external_macro(cx.sess(), expr.span);\n \n         // workaround for rust-lang/rust#43081\n         if expr.span.lo().0 != 0 && expr.span.hi().0 != 0;\n@@ -259,7 +259,7 @@ fn has_unary_equivalent(bin_op: BinOpKind) -> bool {\n }\n \n fn indentation(cx: &EarlyContext<'_>, span: Span) -> usize {\n-    cx.sess.source_map().lookup_char_pos(span.lo()).col.0\n+    cx.sess().source_map().lookup_char_pos(span.lo()).col.0\n }\n \n /// Implementation of the `POSSIBLE_MISSING_COMMA` lint for array"}, {"sha": "c2f52605151ed2e0f750a050695d57c87efe6122", "filename": "src/tools/clippy/clippy_lints/src/from_over_into.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/42313dd29b3edb0ab453a0d43d12876ec7e48ce0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffrom_over_into.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42313dd29b3edb0ab453a0d43d12876ec7e48ce0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffrom_over_into.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffrom_over_into.rs?ref=42313dd29b3edb0ab453a0d43d12876ec7e48ce0", "patch": "@@ -2,7 +2,7 @@ use clippy_utils::diagnostics::span_lint_and_help;\n use clippy_utils::{meets_msrv, msrvs};\n use if_chain::if_chain;\n use rustc_hir as hir;\n-use rustc_lint::{LateContext, LateLintPass, LintContext};\n+use rustc_lint::{LateContext, LateLintPass};\n use rustc_semver::RustcVersion;\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::symbol::sym;"}, {"sha": "667652106987a6bff185c95d32c0334f2ed1c90e", "filename": "src/tools/clippy/clippy_lints/src/index_refutable_slice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/42313dd29b3edb0ab453a0d43d12876ec7e48ce0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Findex_refutable_slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42313dd29b3edb0ab453a0d43d12876ec7e48ce0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Findex_refutable_slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Findex_refutable_slice.rs?ref=42313dd29b3edb0ab453a0d43d12876ec7e48ce0", "patch": "@@ -8,7 +8,7 @@ use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n use rustc_hir::intravisit::{self, Visitor};\n-use rustc_lint::{LateContext, LateLintPass, LintContext};\n+use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::hir::nested_filter;\n use rustc_middle::ty;\n use rustc_semver::RustcVersion;"}, {"sha": "cdefe627efdaad877d2c95150a8ddc6ad036f984", "filename": "src/tools/clippy/clippy_lints/src/items_after_statements.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/42313dd29b3edb0ab453a0d43d12876ec7e48ce0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fitems_after_statements.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42313dd29b3edb0ab453a0d43d12876ec7e48ce0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fitems_after_statements.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fitems_after_statements.rs?ref=42313dd29b3edb0ab453a0d43d12876ec7e48ce0", "patch": "@@ -2,7 +2,7 @@\n \n use clippy_utils::diagnostics::span_lint;\n use rustc_ast::ast::{Block, ItemKind, StmtKind};\n-use rustc_lint::{EarlyContext, EarlyLintPass};\n+use rustc_lint::{EarlyContext, EarlyLintPass, LintContext};\n use rustc_middle::lint::in_external_macro;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n \n@@ -55,7 +55,7 @@ declare_lint_pass!(ItemsAfterStatements => [ITEMS_AFTER_STATEMENTS]);\n \n impl EarlyLintPass for ItemsAfterStatements {\n     fn check_block(&mut self, cx: &EarlyContext<'_>, item: &Block) {\n-        if in_external_macro(cx.sess, item.span) {\n+        if in_external_macro(cx.sess(), item.span) {\n             return;\n         }\n \n@@ -69,7 +69,7 @@ impl EarlyLintPass for ItemsAfterStatements {\n         // lint on all further items\n         for stmt in stmts {\n             if let StmtKind::Item(ref it) = *stmt {\n-                if in_external_macro(cx.sess, it.span) {\n+                if in_external_macro(cx.sess(), it.span) {\n                     return;\n                 }\n                 if let ItemKind::MacroDef(..) = it.kind {"}, {"sha": "b7430f49229ae6e673a98fd596f717b3324418c0", "filename": "src/tools/clippy/clippy_lints/src/literal_representation.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/42313dd29b3edb0ab453a0d43d12876ec7e48ce0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fliteral_representation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42313dd29b3edb0ab453a0d43d12876ec7e48ce0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fliteral_representation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fliteral_representation.rs?ref=42313dd29b3edb0ab453a0d43d12876ec7e48ce0", "patch": "@@ -7,7 +7,7 @@ use clippy_utils::source::snippet_opt;\n use if_chain::if_chain;\n use rustc_ast::ast::{Expr, ExprKind, Lit, LitKind};\n use rustc_errors::Applicability;\n-use rustc_lint::{EarlyContext, EarlyLintPass};\n+use rustc_lint::{EarlyContext, EarlyLintPass, LintContext};\n use rustc_middle::lint::in_external_macro;\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n use std::iter;\n@@ -225,7 +225,7 @@ impl_lint_pass!(LiteralDigitGrouping => [\n \n impl EarlyLintPass for LiteralDigitGrouping {\n     fn check_expr(&mut self, cx: &EarlyContext<'_>, expr: &Expr) {\n-        if in_external_macro(cx.sess, expr.span) {\n+        if in_external_macro(cx.sess(), expr.span) {\n             return;\n         }\n \n@@ -418,7 +418,7 @@ impl_lint_pass!(DecimalLiteralRepresentation => [DECIMAL_LITERAL_REPRESENTATION]\n \n impl EarlyLintPass for DecimalLiteralRepresentation {\n     fn check_expr(&mut self, cx: &EarlyContext<'_>, expr: &Expr) {\n-        if in_external_macro(cx.sess, expr.span) {\n+        if in_external_macro(cx.sess(), expr.span) {\n             return;\n         }\n "}, {"sha": "33d1bb2985f43fdcd4dcd525abf8d0fb16082c78", "filename": "src/tools/clippy/clippy_lints/src/manual_non_exhaustive.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/42313dd29b3edb0ab453a0d43d12876ec7e48ce0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_non_exhaustive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42313dd29b3edb0ab453a0d43d12876ec7e48ce0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_non_exhaustive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_non_exhaustive.rs?ref=42313dd29b3edb0ab453a0d43d12876ec7e48ce0", "patch": "@@ -5,7 +5,7 @@ use clippy_utils::{meets_msrv, msrvs};\n use if_chain::if_chain;\n use rustc_ast::ast::{FieldDef, Item, ItemKind, Variant, VariantData, VisibilityKind};\n use rustc_errors::Applicability;\n-use rustc_lint::{EarlyContext, EarlyLintPass};\n+use rustc_lint::{EarlyContext, EarlyLintPass, LintContext};\n use rustc_semver::RustcVersion;\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::{sym, Span};\n@@ -116,7 +116,7 @@ fn check_manual_non_exhaustive_enum(cx: &EarlyContext<'_>, item: &Item, variants\n                 |diag| {\n                     if_chain! {\n                         if !item.attrs.iter().any(|attr| attr.has_name(sym::non_exhaustive));\n-                        let header_span = cx.sess.source_map().span_until_char(item.span, '{');\n+                        let header_span = cx.sess().source_map().span_until_char(item.span, '{');\n                         if let Some(snippet) = snippet_opt(cx, header_span);\n                         then {\n                             diag.span_suggestion(\n@@ -149,7 +149,7 @@ fn check_manual_non_exhaustive_struct(cx: &EarlyContext<'_>, item: &Item, data:\n             VariantData::Unit(_) => unreachable!(\"`VariantData::Unit` is already handled above\"),\n         };\n \n-        cx.sess.source_map().span_until_char(item.span, delimiter)\n+        cx.sess().source_map().span_until_char(item.span, delimiter)\n     }\n \n     let fields = data.fields();"}, {"sha": "aacabf303a7025dd6f7c841ee9acb1589ecb495f", "filename": "src/tools/clippy/clippy_lints/src/manual_strip.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/42313dd29b3edb0ab453a0d43d12876ec7e48ce0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_strip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42313dd29b3edb0ab453a0d43d12876ec7e48ce0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_strip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_strip.rs?ref=42313dd29b3edb0ab453a0d43d12876ec7e48ce0", "patch": "@@ -9,7 +9,7 @@ use rustc_hir::def::Res;\n use rustc_hir::intravisit::{walk_expr, Visitor};\n use rustc_hir::BinOpKind;\n use rustc_hir::{BorrowKind, Expr, ExprKind};\n-use rustc_lint::{LateContext, LateLintPass, LintContext};\n+use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::ty;\n use rustc_semver::RustcVersion;\n use rustc_session::{declare_tool_lint, impl_lint_pass};"}, {"sha": "dfb450c8848adcd4aa4b7fca2663e15a5c088810", "filename": "src/tools/clippy/clippy_lints/src/matches.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/42313dd29b3edb0ab453a0d43d12876ec7e48ce0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42313dd29b3edb0ab453a0d43d12876ec7e48ce0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches.rs?ref=42313dd29b3edb0ab453a0d43d12876ec7e48ce0", "patch": "@@ -25,7 +25,7 @@ use rustc_hir::{\n     Mutability, Node, Pat, PatKind, PathSegment, QPath, RangeEnd, TyKind,\n };\n use rustc_hir::{HirIdMap, HirIdSet};\n-use rustc_lint::{LateContext, LateLintPass, LintContext};\n+use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::ty::{self, Ty, TyS, VariantDef};\n use rustc_semver::RustcVersion;\n use rustc_session::{declare_tool_lint, impl_lint_pass};"}, {"sha": "a184806d021bcfcf86617c9fff35eaba84cff16a", "filename": "src/tools/clippy/clippy_lints/src/mem_replace.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/42313dd29b3edb0ab453a0d43d12876ec7e48ce0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmem_replace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42313dd29b3edb0ab453a0d43d12876ec7e48ce0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmem_replace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmem_replace.rs?ref=42313dd29b3edb0ab453a0d43d12876ec7e48ce0", "patch": "@@ -6,7 +6,7 @@ use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::LangItem::OptionNone;\n use rustc_hir::{BorrowKind, Expr, ExprKind, Mutability, QPath};\n-use rustc_lint::{LateContext, LateLintPass, LintContext};\n+use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::lint::in_external_macro;\n use rustc_semver::RustcVersion;\n use rustc_session::{declare_tool_lint, impl_lint_pass};"}, {"sha": "d955fad7d41a2fb12295dc352f901dfa19c883bf", "filename": "src/tools/clippy/clippy_lints/src/misc_early/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/42313dd29b3edb0ab453a0d43d12876ec7e48ce0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmisc_early%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42313dd29b3edb0ab453a0d43d12876ec7e48ce0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmisc_early%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmisc_early%2Fmod.rs?ref=42313dd29b3edb0ab453a0d43d12876ec7e48ce0", "patch": "@@ -12,7 +12,7 @@ use clippy_utils::source::snippet_opt;\n use rustc_ast::ast::{Expr, ExprKind, Generics, Lit, LitFloatType, LitIntType, LitKind, NodeId, Pat, PatKind};\n use rustc_ast::visit::FnKind;\n use rustc_data_structures::fx::FxHashMap;\n-use rustc_lint::{EarlyContext, EarlyLintPass};\n+use rustc_lint::{EarlyContext, EarlyLintPass, LintContext};\n use rustc_middle::lint::in_external_macro;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::source_map::Span;\n@@ -342,7 +342,7 @@ impl EarlyLintPass for MiscEarlyLints {\n     }\n \n     fn check_expr(&mut self, cx: &EarlyContext<'_>, expr: &Expr) {\n-        if in_external_macro(cx.sess, expr.span) {\n+        if in_external_macro(cx.sess(), expr.span) {\n             return;\n         }\n "}, {"sha": "bad9e0be82e61e026a25b715d2b20e50d18c960a", "filename": "src/tools/clippy/clippy_lints/src/missing_const_for_fn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/42313dd29b3edb0ab453a0d43d12876ec7e48ce0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_const_for_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42313dd29b3edb0ab453a0d43d12876ec7e48ce0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_const_for_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_const_for_fn.rs?ref=42313dd29b3edb0ab453a0d43d12876ec7e48ce0", "patch": "@@ -5,7 +5,7 @@ use clippy_utils::{fn_has_unsatisfiable_preds, is_entrypoint_fn, meets_msrv, msr\n use rustc_hir as hir;\n use rustc_hir::intravisit::FnKind;\n use rustc_hir::{Body, Constness, FnDecl, GenericParamKind, HirId};\n-use rustc_lint::{LateContext, LateLintPass, LintContext};\n+use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::lint::in_external_macro;\n use rustc_semver::RustcVersion;\n use rustc_session::{declare_tool_lint, impl_lint_pass};"}, {"sha": "b8dfe996880661e118ec06aa357a4606a4d1815b", "filename": "src/tools/clippy/clippy_lints/src/module_style.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/42313dd29b3edb0ab453a0d43d12876ec7e48ce0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmodule_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42313dd29b3edb0ab453a0d43d12876ec7e48ce0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmodule_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmodule_style.rs?ref=42313dd29b3edb0ab453a0d43d12876ec7e48ce0", "patch": "@@ -80,9 +80,9 @@ impl EarlyLintPass for ModStyle {\n             return;\n         }\n \n-        let files = cx.sess.source_map().files();\n+        let files = cx.sess().source_map().files();\n \n-        let trim_to_src = if let RealFileName::LocalPath(p) = &cx.sess.opts.working_dir {\n+        let trim_to_src = if let RealFileName::LocalPath(p) = &cx.sess().opts.working_dir {\n             p.to_string_lossy()\n         } else {\n             return;"}, {"sha": "0d0c88b02c78b6d5adabe7ed4a6b8bc41b599507", "filename": "src/tools/clippy/clippy_lints/src/non_expressive_names.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/42313dd29b3edb0ab453a0d43d12876ec7e48ce0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_expressive_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42313dd29b3edb0ab453a0d43d12876ec7e48ce0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_expressive_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_expressive_names.rs?ref=42313dd29b3edb0ab453a0d43d12876ec7e48ce0", "patch": "@@ -3,7 +3,7 @@ use rustc_ast::ast::{\n     self, Arm, AssocItem, AssocItemKind, Attribute, Block, FnDecl, Item, ItemKind, Local, Pat, PatKind,\n };\n use rustc_ast::visit::{walk_block, walk_expr, walk_pat, Visitor};\n-use rustc_lint::{EarlyContext, EarlyLintPass};\n+use rustc_lint::{EarlyContext, EarlyLintPass, LintContext};\n use rustc_middle::lint::in_external_macro;\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::source_map::Span;\n@@ -356,7 +356,7 @@ impl<'a, 'tcx> Visitor<'tcx> for SimilarNamesLocalVisitor<'a, 'tcx> {\n \n impl EarlyLintPass for NonExpressiveNames {\n     fn check_item(&mut self, cx: &EarlyContext<'_>, item: &Item) {\n-        if in_external_macro(cx.sess, item.span) {\n+        if in_external_macro(cx.sess(), item.span) {\n             return;\n         }\n \n@@ -371,7 +371,7 @@ impl EarlyLintPass for NonExpressiveNames {\n     }\n \n     fn check_impl_item(&mut self, cx: &EarlyContext<'_>, item: &AssocItem) {\n-        if in_external_macro(cx.sess, item.span) {\n+        if in_external_macro(cx.sess(), item.span) {\n             return;\n         }\n "}, {"sha": "d81481ade044d255d843fab0262669ca48c19ea1", "filename": "src/tools/clippy/clippy_lints/src/octal_escapes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/42313dd29b3edb0ab453a0d43d12876ec7e48ce0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foctal_escapes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42313dd29b3edb0ab453a0d43d12876ec7e48ce0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foctal_escapes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foctal_escapes.rs?ref=42313dd29b3edb0ab453a0d43d12876ec7e48ce0", "patch": "@@ -2,7 +2,7 @@ use clippy_utils::diagnostics::span_lint_and_then;\n use rustc_ast::ast::{Expr, ExprKind};\n use rustc_ast::token::{Lit, LitKind};\n use rustc_errors::Applicability;\n-use rustc_lint::{EarlyContext, EarlyLintPass};\n+use rustc_lint::{EarlyContext, EarlyLintPass, LintContext};\n use rustc_middle::lint::in_external_macro;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::Span;\n@@ -51,7 +51,7 @@ declare_lint_pass!(OctalEscapes => [OCTAL_ESCAPES]);\n \n impl EarlyLintPass for OctalEscapes {\n     fn check_expr(&mut self, cx: &EarlyContext<'_>, expr: &Expr) {\n-        if in_external_macro(cx.sess, expr.span) {\n+        if in_external_macro(cx.sess(), expr.span) {\n             return;\n         }\n "}, {"sha": "027ab70014fc0c2ca51ced2aa25f329cfcb87028", "filename": "src/tools/clippy/clippy_lints/src/ranges.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/42313dd29b3edb0ab453a0d43d12876ec7e48ce0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Franges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42313dd29b3edb0ab453a0d43d12876ec7e48ce0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Franges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Franges.rs?ref=42313dd29b3edb0ab453a0d43d12876ec7e48ce0", "patch": "@@ -8,7 +8,7 @@ use if_chain::if_chain;\n use rustc_ast::ast::RangeLimits;\n use rustc_errors::Applicability;\n use rustc_hir::{BinOpKind, Expr, ExprKind, PathSegment, QPath};\n-use rustc_lint::{LateContext, LateLintPass, LintContext};\n+use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::ty;\n use rustc_semver::RustcVersion;\n use rustc_session::{declare_tool_lint, impl_lint_pass};"}, {"sha": "5a25008e95e5bceae5bc16f9311c8b9bc87b78f4", "filename": "src/tools/clippy/clippy_lints/src/redundant_closure_call.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/42313dd29b3edb0ab453a0d43d12876ec7e48ce0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fredundant_closure_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42313dd29b3edb0ab453a0d43d12876ec7e48ce0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fredundant_closure_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fredundant_closure_call.rs?ref=42313dd29b3edb0ab453a0d43d12876ec7e48ce0", "patch": "@@ -8,7 +8,7 @@ use rustc_errors::Applicability;\n use rustc_hir as hir;\n use rustc_hir::intravisit as hir_visit;\n use rustc_hir::intravisit::Visitor as HirVisitor;\n-use rustc_lint::{EarlyContext, EarlyLintPass, LateContext, LateLintPass};\n+use rustc_lint::{EarlyContext, EarlyLintPass, LateContext, LateLintPass, LintContext};\n use rustc_middle::hir::nested_filter;\n use rustc_middle::lint::in_external_macro;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n@@ -62,7 +62,7 @@ impl<'ast> ast_visit::Visitor<'ast> for ReturnVisitor {\n \n impl EarlyLintPass for RedundantClosureCall {\n     fn check_expr(&mut self, cx: &EarlyContext<'_>, expr: &ast::Expr) {\n-        if in_external_macro(cx.sess, expr.span) {\n+        if in_external_macro(cx.sess(), expr.span) {\n             return;\n         }\n         if_chain! {"}, {"sha": "73088ce1a87e74effa4a4b256e2e2f13b27c5993", "filename": "src/tools/clippy/clippy_lints/src/redundant_else.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/42313dd29b3edb0ab453a0d43d12876ec7e48ce0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fredundant_else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42313dd29b3edb0ab453a0d43d12876ec7e48ce0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fredundant_else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fredundant_else.rs?ref=42313dd29b3edb0ab453a0d43d12876ec7e48ce0", "patch": "@@ -1,7 +1,7 @@\n use clippy_utils::diagnostics::span_lint_and_help;\n use rustc_ast::ast::{Block, Expr, ExprKind, Stmt, StmtKind};\n use rustc_ast::visit::{walk_expr, Visitor};\n-use rustc_lint::{EarlyContext, EarlyLintPass};\n+use rustc_lint::{EarlyContext, EarlyLintPass, LintContext};\n use rustc_middle::lint::in_external_macro;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n \n@@ -46,7 +46,7 @@ declare_lint_pass!(RedundantElse => [REDUNDANT_ELSE]);\n \n impl EarlyLintPass for RedundantElse {\n     fn check_stmt(&mut self, cx: &EarlyContext<'_>, stmt: &Stmt) {\n-        if in_external_macro(cx.sess, stmt.span) {\n+        if in_external_macro(cx.sess(), stmt.span) {\n             return;\n         }\n         // Only look at expressions that are a whole statement"}, {"sha": "40a62fd6d20133382f1cfc40d4b12d7658f0c02c", "filename": "src/tools/clippy/clippy_lints/src/redundant_field_names.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/42313dd29b3edb0ab453a0d43d12876ec7e48ce0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fredundant_field_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42313dd29b3edb0ab453a0d43d12876ec7e48ce0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fredundant_field_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fredundant_field_names.rs?ref=42313dd29b3edb0ab453a0d43d12876ec7e48ce0", "patch": "@@ -2,7 +2,7 @@ use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::{meets_msrv, msrvs};\n use rustc_ast::ast::{Expr, ExprKind};\n use rustc_errors::Applicability;\n-use rustc_lint::{EarlyContext, EarlyLintPass};\n+use rustc_lint::{EarlyContext, EarlyLintPass, LintContext};\n use rustc_middle::lint::in_external_macro;\n use rustc_semver::RustcVersion;\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n@@ -55,7 +55,7 @@ impl EarlyLintPass for RedundantFieldNames {\n             return;\n         }\n \n-        if in_external_macro(cx.sess, expr.span) {\n+        if in_external_macro(cx.sess(), expr.span) {\n             return;\n         }\n         if let ExprKind::Struct(ref se) = expr.kind {"}, {"sha": "aa306a630c467fea479790e580ba57389298da36", "filename": "src/tools/clippy/clippy_lints/src/single_char_lifetime_names.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/42313dd29b3edb0ab453a0d43d12876ec7e48ce0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fsingle_char_lifetime_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42313dd29b3edb0ab453a0d43d12876ec7e48ce0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fsingle_char_lifetime_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fsingle_char_lifetime_names.rs?ref=42313dd29b3edb0ab453a0d43d12876ec7e48ce0", "patch": "@@ -1,6 +1,6 @@\n use clippy_utils::diagnostics::span_lint_and_help;\n use rustc_ast::ast::{GenericParam, GenericParamKind};\n-use rustc_lint::{EarlyContext, EarlyLintPass};\n+use rustc_lint::{EarlyContext, EarlyLintPass, LintContext};\n use rustc_middle::lint::in_external_macro;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n \n@@ -43,7 +43,7 @@ declare_lint_pass!(SingleCharLifetimeNames => [SINGLE_CHAR_LIFETIME_NAMES]);\n \n impl EarlyLintPass for SingleCharLifetimeNames {\n     fn check_generic_param(&mut self, ctx: &EarlyContext<'_>, param: &GenericParam) {\n-        if in_external_macro(ctx.sess, param.ident.span) {\n+        if in_external_macro(ctx.sess(), param.ident.span) {\n             return;\n         }\n "}, {"sha": "961cdb317e76cd0abd0c26a240567533869f72c5", "filename": "src/tools/clippy/clippy_lints/src/single_component_path_imports.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/42313dd29b3edb0ab453a0d43d12876ec7e48ce0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fsingle_component_path_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42313dd29b3edb0ab453a0d43d12876ec7e48ce0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fsingle_component_path_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fsingle_component_path_imports.rs?ref=42313dd29b3edb0ab453a0d43d12876ec7e48ce0", "patch": "@@ -1,7 +1,7 @@\n use clippy_utils::diagnostics::{span_lint_and_help, span_lint_and_sugg};\n use rustc_ast::{ptr::P, Crate, Item, ItemKind, MacroDef, ModKind, UseTreeKind, VisibilityKind};\n use rustc_errors::Applicability;\n-use rustc_lint::{EarlyContext, EarlyLintPass};\n+use rustc_lint::{EarlyContext, EarlyLintPass, LintContext};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::{edition::Edition, symbol::kw, Span, Symbol};\n \n@@ -37,7 +37,7 @@ declare_lint_pass!(SingleComponentPathImports => [SINGLE_COMPONENT_PATH_IMPORTS]\n \n impl EarlyLintPass for SingleComponentPathImports {\n     fn check_crate(&mut self, cx: &EarlyContext<'_>, krate: &Crate) {\n-        if cx.sess.opts.edition < Edition::Edition2018 {\n+        if cx.sess().opts.edition < Edition::Edition2018 {\n             return;\n         }\n         check_mod(cx, &krate.items);"}, {"sha": "be20282b3b88c53547571a7ec2f2a28443e3ab14", "filename": "src/tools/clippy/clippy_lints/src/use_self.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/42313dd29b3edb0ab453a0d43d12876ec7e48ce0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fuse_self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42313dd29b3edb0ab453a0d43d12876ec7e48ce0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fuse_self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fuse_self.rs?ref=42313dd29b3edb0ab453a0d43d12876ec7e48ce0", "patch": "@@ -11,7 +11,7 @@ use rustc_hir::{\n     intravisit::{walk_inf, walk_ty, Visitor},\n     Expr, ExprKind, FnRetTy, FnSig, GenericArg, HirId, Impl, ImplItemKind, Item, ItemKind, Path, QPath, TyKind,\n };\n-use rustc_lint::{LateContext, LateLintPass, LintContext};\n+use rustc_lint::{LateContext, LateLintPass};\n use rustc_semver::RustcVersion;\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::Span;"}, {"sha": "512c39389c1bd8fbf8d68b12bceda8563e541e31", "filename": "src/tools/clippy/clippy_lints/src/utils/internal_lints/metadata_collector.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/42313dd29b3edb0ab453a0d43d12876ec7e48ce0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fmetadata_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42313dd29b3edb0ab453a0d43d12876ec7e48ce0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fmetadata_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fmetadata_collector.rs?ref=42313dd29b3edb0ab453a0d43d12876ec7e48ce0", "patch": "@@ -580,7 +580,7 @@ fn get_lint_group_and_level_or_lint(\n ) -> Option<(String, &'static str)> {\n     let result = cx\n         .lint_store\n-        .check_lint_name(cx.sess(), lint_name, Some(sym::clippy), &[]);\n+        .check_lint_name(lint_name, Some(sym::clippy), &[]);\n     if let CheckLintNameResult::Tool(Ok(lint_lst)) = result {\n         if let Some(group) = get_lint_group(cx, lint_lst[0]) {\n             if EXCLUDED_LINT_GROUPS.contains(&group.as_str()) {"}, {"sha": "b0044695ea8a88388da9a655e3336873c4252a8f", "filename": "src/tools/clippy/clippy_lints/src/write.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/42313dd29b3edb0ab453a0d43d12876ec7e48ce0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42313dd29b3edb0ab453a0d43d12876ec7e48ce0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fwrite.rs?ref=42313dd29b3edb0ab453a0d43d12876ec7e48ce0", "patch": "@@ -9,7 +9,7 @@ use rustc_ast::token::{self, LitKind};\n use rustc_ast::tokenstream::TokenStream;\n use rustc_errors::Applicability;\n use rustc_lexer::unescape::{self, EscapeError};\n-use rustc_lint::{EarlyContext, EarlyLintPass};\n+use rustc_lint::{EarlyContext, EarlyLintPass, LintContext};\n use rustc_parse::parser;\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::symbol::{kw, Symbol};\n@@ -290,7 +290,7 @@ impl EarlyLintPass for Write {\n     fn check_mac(&mut self, cx: &EarlyContext<'_>, mac: &MacCall) {\n         fn is_build_script(cx: &EarlyContext<'_>) -> bool {\n             // Cargo sets the crate name for build scripts to `build_script_build`\n-            cx.sess\n+            cx.sess()\n                 .opts\n                 .crate_name\n                 .as_ref()\n@@ -529,7 +529,7 @@ impl Write {\n     /// ```\n     #[allow(clippy::too_many_lines)]\n     fn check_tts<'a>(&self, cx: &EarlyContext<'a>, tts: TokenStream, is_write: bool) -> (Option<StrLit>, Option<Expr>) {\n-        let mut parser = parser::Parser::new(&cx.sess.parse_sess, tts, false, None);\n+        let mut parser = parser::Parser::new(&cx.sess().parse_sess, tts, false, None);\n         let expr = if is_write {\n             match parser\n                 .parse_expr()"}, {"sha": "9233903e98a0068c6ee1d1170101da2f22f12053", "filename": "src/tools/clippy/clippy_utils/src/lib.rs", "status": "modified", "additions": 5, "deletions": 15, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/42313dd29b3edb0ab453a0d43d12876ec7e48ce0/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42313dd29b3edb0ab453a0d43d12876ec7e48ce0/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Flib.rs?ref=42313dd29b3edb0ab453a0d43d12876ec7e48ce0", "patch": "@@ -117,25 +117,15 @@ pub fn meets_msrv(msrv: Option<&RustcVersion>, lint_msrv: &RustcVersion) -> bool\n \n #[macro_export]\n macro_rules! extract_msrv_attr {\n-    (LateContext) => {\n-        extract_msrv_attr!(@LateContext, ());\n-    };\n-    (EarlyContext) => {\n-        extract_msrv_attr!(@EarlyContext);\n-    };\n-    (@$context:ident$(, $call:tt)?) => {\n+    ($context:ident) => {\n         fn enter_lint_attrs(&mut self, cx: &rustc_lint::$context<'_>, attrs: &[rustc_ast::ast::Attribute]) {\n-            use $crate::get_unique_inner_attr;\n-            match get_unique_inner_attr(cx.sess$($call)?, attrs, \"msrv\") {\n+            let sess = rustc_lint::LintContext::sess(cx);\n+            match $crate::get_unique_inner_attr(sess, attrs, \"msrv\") {\n                 Some(msrv_attr) => {\n                     if let Some(msrv) = msrv_attr.value_str() {\n-                        self.msrv = $crate::parse_msrv(\n-                            &msrv.to_string(),\n-                            Some(cx.sess$($call)?),\n-                            Some(msrv_attr.span),\n-                        );\n+                        self.msrv = $crate::parse_msrv(&msrv.to_string(), Some(sess), Some(msrv_attr.span));\n                     } else {\n-                        cx.sess$($call)?.span_err(msrv_attr.span, \"bad clippy attribute\");\n+                        sess.span_err(msrv_attr.span, \"bad clippy attribute\");\n                     }\n                 },\n                 _ => (),"}]}