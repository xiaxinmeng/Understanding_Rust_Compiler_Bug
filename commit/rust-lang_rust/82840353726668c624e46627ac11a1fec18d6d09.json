{"sha": "82840353726668c624e46627ac11a1fec18d6d09", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgyODQwMzUzNzI2NjY4YzYyNGU0NjYyN2FjMTFhMWZlYzE4ZDZkMDk=", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2019-11-30T14:08:22Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2019-12-26T22:38:46Z"}, "message": "Fallout in other crates.", "tree": {"sha": "6354a61dbbda6151e0fbc704b32db5da00cfc816", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6354a61dbbda6151e0fbc704b32db5da00cfc816"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/82840353726668c624e46627ac11a1fec18d6d09", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/82840353726668c624e46627ac11a1fec18d6d09", "html_url": "https://github.com/rust-lang/rust/commit/82840353726668c624e46627ac11a1fec18d6d09", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/82840353726668c624e46627ac11a1fec18d6d09/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "58b908d09c846b9112fc6a178f832ff84486f8ee", "url": "https://api.github.com/repos/rust-lang/rust/commits/58b908d09c846b9112fc6a178f832ff84486f8ee", "html_url": "https://github.com/rust-lang/rust/commit/58b908d09c846b9112fc6a178f832ff84486f8ee"}], "stats": {"total": 904, "additions": 491, "deletions": 413}, "files": [{"sha": "481ca43aa793af528fd0413f54c9e88ab04ea58d", "filename": "src/librustc_lint/array_into_iter.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/82840353726668c624e46627ac11a1fec18d6d09/src%2Flibrustc_lint%2Farray_into_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82840353726668c624e46627ac11a1fec18d6d09/src%2Flibrustc_lint%2Farray_into_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Farray_into_iter.rs?ref=82840353726668c624e46627ac11a1fec18d6d09", "patch": "@@ -25,7 +25,7 @@ declare_lint_pass!(\n );\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ArrayIntoIter {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr) {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr<'tcx>) {\n         // We only care about method call expressions.\n         if let hir::ExprKind::MethodCall(call, span, args) = &expr.kind {\n             if call.ident.name != sym::into_iter {"}, {"sha": "2d9e960716f4ea73351b317e40c8957fa5a88c0a", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/82840353726668c624e46627ac11a1fec18d6d09/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82840353726668c624e46627ac11a1fec18d6d09/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=82840353726668c624e46627ac11a1fec18d6d09", "patch": "@@ -142,7 +142,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for BoxPointers {\n         }\n     }\n \n-    fn check_expr(&mut self, cx: &LateContext<'_, '_>, e: &hir::Expr) {\n+    fn check_expr(&mut self, cx: &LateContext<'_, '_>, e: &hir::Expr<'_>) {\n         let ty = cx.tables.node_type(e.hir_id);\n         self.check_heap_type(cx, e.span, ty);\n     }\n@@ -157,8 +157,8 @@ declare_lint! {\n declare_lint_pass!(NonShorthandFieldPatterns => [NON_SHORTHAND_FIELD_PATTERNS]);\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonShorthandFieldPatterns {\n-    fn check_pat(&mut self, cx: &LateContext<'_, '_>, pat: &hir::Pat) {\n-        if let PatKind::Struct(ref qpath, ref field_pats, _) = pat.kind {\n+    fn check_pat(&mut self, cx: &LateContext<'_, '_>, pat: &hir::Pat<'_>) {\n+        if let PatKind::Struct(ref qpath, field_pats, _) = pat.kind {\n             let variant = cx\n                 .tables\n                 .pat_ty(pat)\n@@ -901,7 +901,7 @@ declare_lint! {\n declare_lint_pass!(MutableTransmutes => [MUTABLE_TRANSMUTES]);\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MutableTransmutes {\n-    fn check_expr(&mut self, cx: &LateContext<'_, '_>, expr: &hir::Expr) {\n+    fn check_expr(&mut self, cx: &LateContext<'_, '_>, expr: &hir::Expr<'_>) {\n         use rustc_target::spec::abi::Abi::RustIntrinsic;\n \n         let msg = \"mutating transmuted &mut T from &T may cause undefined behavior, \\\n@@ -917,7 +917,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MutableTransmutes {\n \n         fn get_transmute_from_to<'a, 'tcx>(\n             cx: &LateContext<'a, 'tcx>,\n-            expr: &hir::Expr,\n+            expr: &hir::Expr<'_>,\n         ) -> Option<(Ty<'tcx>, Ty<'tcx>)> {\n             let def = if let hir::ExprKind::Path(ref qpath) = expr.kind {\n                 cx.tables.qpath_res(qpath, expr.hir_id)\n@@ -1840,7 +1840,7 @@ declare_lint! {\n declare_lint_pass!(InvalidValue => [INVALID_VALUE]);\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for InvalidValue {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &hir::Expr) {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &hir::Expr<'_>) {\n         #[derive(Debug, Copy, Clone, PartialEq)]\n         enum InitKind {\n             Zeroed,\n@@ -1852,7 +1852,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for InvalidValue {\n         type InitError = (String, Option<Span>);\n \n         /// Test if this constant is all-0.\n-        fn is_zero(expr: &hir::Expr) -> bool {\n+        fn is_zero(expr: &hir::Expr<'_>) -> bool {\n             use hir::ExprKind::*;\n             use syntax::ast::LitKind::*;\n             match &expr.kind {\n@@ -1869,7 +1869,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for InvalidValue {\n         }\n \n         /// Determine if this expression is a \"dangerous initialization\".\n-        fn is_dangerous_init(cx: &LateContext<'_, '_>, expr: &hir::Expr) -> Option<InitKind> {\n+        fn is_dangerous_init(cx: &LateContext<'_, '_>, expr: &hir::Expr<'_>) -> Option<InitKind> {\n             // `transmute` is inside an anonymous module (the `extern` block?);\n             // `Invalid` represents the empty string and matches that.\n             // FIXME(#66075): use diagnostic items.  Somehow, that does not seem to work"}, {"sha": "2752be9a6de9903ff515865d8c80f330b782dc24", "filename": "src/librustc_lint/nonstandard_style.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/82840353726668c624e46627ac11a1fec18d6d09/src%2Flibrustc_lint%2Fnonstandard_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82840353726668c624e46627ac11a1fec18d6d09/src%2Flibrustc_lint%2Fnonstandard_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fnonstandard_style.rs?ref=82840353726668c624e46627ac11a1fec18d6d09", "patch": "@@ -344,7 +344,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonSnakeCase {\n         }\n     }\n \n-    fn check_pat(&mut self, cx: &LateContext<'_, '_>, p: &hir::Pat) {\n+    fn check_pat(&mut self, cx: &LateContext<'_, '_>, p: &hir::Pat<'_>) {\n         if let &PatKind::Binding(_, _, ident, _) = &p.kind {\n             self.check_snake_case(cx, \"variable\", &ident);\n         }\n@@ -410,7 +410,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonUpperCaseGlobals {\n         }\n     }\n \n-    fn check_pat(&mut self, cx: &LateContext<'_, '_>, p: &hir::Pat) {\n+    fn check_pat(&mut self, cx: &LateContext<'_, '_>, p: &hir::Pat<'_>) {\n         // Lint for constants that look like binding identifiers (#7526)\n         if let PatKind::Path(hir::QPath::Resolved(None, ref path)) = p.kind {\n             if let Res::Def(DefKind::Const, _) = path.res {"}, {"sha": "ba2087d2f2620a34db5e5875e62fdbea3cda59dd", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/82840353726668c624e46627ac11a1fec18d6d09/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82840353726668c624e46627ac11a1fec18d6d09/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=82840353726668c624e46627ac11a1fec18d6d09", "patch": "@@ -65,8 +65,8 @@ fn lint_overflowing_range_endpoint<'a, 'tcx>(\n     lit: &hir::Lit,\n     lit_val: u128,\n     max: u128,\n-    expr: &'tcx hir::Expr,\n-    parent_expr: &'tcx hir::Expr,\n+    expr: &'tcx hir::Expr<'tcx>,\n+    parent_expr: &'tcx hir::Expr<'tcx>,\n     ty: &str,\n ) -> bool {\n     // We only want to handle exclusive (`..`) ranges,\n@@ -150,7 +150,7 @@ fn get_bin_hex_repr(cx: &LateContext<'_, '_>, lit: &hir::Lit) -> Option<String>\n \n fn report_bin_hex_error(\n     cx: &LateContext<'_, '_>,\n-    expr: &hir::Expr,\n+    expr: &hir::Expr<'_>,\n     ty: attr::IntType,\n     repr_str: String,\n     val: u128,\n@@ -244,7 +244,7 @@ fn get_type_suggestion(t: Ty<'_>, val: u128, negative: bool) -> Option<&'static\n fn lint_int_literal<'a, 'tcx>(\n     cx: &LateContext<'a, 'tcx>,\n     type_limits: &TypeLimits,\n-    e: &'tcx hir::Expr,\n+    e: &'tcx hir::Expr<'tcx>,\n     lit: &hir::Lit,\n     t: ast::IntTy,\n     v: u128,\n@@ -284,7 +284,7 @@ fn lint_int_literal<'a, 'tcx>(\n \n fn lint_uint_literal<'a, 'tcx>(\n     cx: &LateContext<'a, 'tcx>,\n-    e: &'tcx hir::Expr,\n+    e: &'tcx hir::Expr<'tcx>,\n     lit: &hir::Lit,\n     t: ast::UintTy,\n ) {\n@@ -342,7 +342,7 @@ fn lint_uint_literal<'a, 'tcx>(\n fn lint_literal<'a, 'tcx>(\n     cx: &LateContext<'a, 'tcx>,\n     type_limits: &TypeLimits,\n-    e: &'tcx hir::Expr,\n+    e: &'tcx hir::Expr<'tcx>,\n     lit: &hir::Lit,\n ) {\n     match cx.tables.node_type(e.hir_id).kind {\n@@ -377,7 +377,7 @@ fn lint_literal<'a, 'tcx>(\n }\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx hir::Expr) {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx hir::Expr<'tcx>) {\n         match e.kind {\n             hir::ExprKind::Unary(hir::UnNeg, ref expr) => {\n                 // propagate negation, if the negation itself isn't negated\n@@ -425,8 +425,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n         fn check_limits(\n             cx: &LateContext<'_, '_>,\n             binop: hir::BinOp,\n-            l: &hir::Expr,\n-            r: &hir::Expr,\n+            l: &hir::Expr<'_>,\n+            r: &hir::Expr<'_>,\n         ) -> bool {\n             let (lit, expr, swap) = match (&l.kind, &r.kind) {\n                 (&hir::ExprKind::Lit(_), _) => (l, r, true),"}, {"sha": "5edb81c1e518d1c977aca971bae2d39083c19e47", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/82840353726668c624e46627ac11a1fec18d6d09/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82840353726668c624e46627ac11a1fec18d6d09/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=82840353726668c624e46627ac11a1fec18d6d09", "patch": "@@ -37,7 +37,7 @@ declare_lint! {\n declare_lint_pass!(UnusedResults => [UNUSED_MUST_USE, UNUSED_RESULTS]);\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedResults {\n-    fn check_stmt(&mut self, cx: &LateContext<'_, '_>, s: &hir::Stmt) {\n+    fn check_stmt(&mut self, cx: &LateContext<'_, '_>, s: &hir::Stmt<'_>) {\n         let expr = match s.kind {\n             hir::StmtKind::Semi(ref expr) => &**expr,\n             _ => return,\n@@ -123,7 +123,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedResults {\n         fn check_must_use_ty<'tcx>(\n             cx: &LateContext<'_, 'tcx>,\n             ty: Ty<'tcx>,\n-            expr: &hir::Expr,\n+            expr: &hir::Expr<'_>,\n             span: Span,\n             descr_pre: &str,\n             descr_post: &str,\n@@ -245,7 +245,7 @@ declare_lint! {\n declare_lint_pass!(PathStatements => [PATH_STATEMENTS]);\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for PathStatements {\n-    fn check_stmt(&mut self, cx: &LateContext<'_, '_>, s: &hir::Stmt) {\n+    fn check_stmt(&mut self, cx: &LateContext<'_, '_>, s: &hir::Stmt<'_>) {\n         if let hir::StmtKind::Semi(ref expr) = s.kind {\n             if let hir::ExprKind::Path(_) = expr.kind {\n                 cx.span_lint(PATH_STATEMENTS, s.span, \"path statement with no effect\");\n@@ -637,7 +637,7 @@ declare_lint! {\n declare_lint_pass!(UnusedAllocation => [UNUSED_ALLOCATION]);\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedAllocation {\n-    fn check_expr(&mut self, cx: &LateContext<'_, '_>, e: &hir::Expr) {\n+    fn check_expr(&mut self, cx: &LateContext<'_, '_>, e: &hir::Expr<'_>) {\n         match e.kind {\n             hir::ExprKind::Box(_) => {}\n             _ => return,"}, {"sha": "84d5d529adf76e20ffe4609671a816decab7b7ba", "filename": "src/librustc_metadata/rmeta/encoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/82840353726668c624e46627ac11a1fec18d6d09/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82840353726668c624e46627ac11a1fec18d6d09/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs?ref=82840353726668c624e46627ac11a1fec18d6d09", "patch": "@@ -1524,7 +1524,7 @@ impl Visitor<'tcx> for EncodeContext<'tcx> {\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n         NestedVisitorMap::OnlyBodies(&self.tcx.hir())\n     }\n-    fn visit_expr(&mut self, ex: &'tcx hir::Expr) {\n+    fn visit_expr(&mut self, ex: &'tcx hir::Expr<'tcx>) {\n         intravisit::walk_expr(self, ex);\n         self.encode_info_for_expr(ex);\n     }\n@@ -1587,7 +1587,7 @@ impl EncodeContext<'tcx> {\n         }\n     }\n \n-    fn encode_info_for_expr(&mut self, expr: &hir::Expr) {\n+    fn encode_info_for_expr(&mut self, expr: &hir::Expr<'_>) {\n         match expr.kind {\n             hir::ExprKind::Closure(..) => {\n                 let def_id = self.tcx.hir().local_def_id(expr.hir_id);"}, {"sha": "da8bb6adf84a9b1772ceb2751e9305d7ef7f2b2a", "filename": "src/librustc_mir/build/block.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/82840353726668c624e46627ac11a1fec18d6d09/src%2Flibrustc_mir%2Fbuild%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82840353726668c624e46627ac11a1fec18d6d09/src%2Flibrustc_mir%2Fbuild%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fblock.rs?ref=82840353726668c624e46627ac11a1fec18d6d09", "patch": "@@ -11,7 +11,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         &mut self,\n         destination: &Place<'tcx>,\n         block: BasicBlock,\n-        ast_block: &'tcx hir::Block,\n+        ast_block: &'tcx hir::Block<'tcx>,\n         source_info: SourceInfo,\n     ) -> BlockAnd<()> {\n         let Block {"}, {"sha": "f459ca8dbbaf504aa8ab998489f2ca68380b122d", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/82840353726668c624e46627ac11a1fec18d6d09/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82840353726668c624e46627ac11a1fec18d6d09/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=82840353726668c624e46627ac11a1fec18d6d09", "patch": "@@ -29,8 +29,10 @@ pub fn mir_build(tcx: TyCtxt<'_>, def_id: DefId) -> BodyAndCache<'_> {\n \n     // Figure out what primary body this item has.\n     let (body_id, return_ty_span) = match tcx.hir().get(id) {\n-        Node::Expr(hir::Expr { kind: hir::ExprKind::Closure(_, decl, body_id, _, _), .. })\n-        | Node::Item(hir::Item {\n+        Node::Expr(hir::Expr { kind: hir::ExprKind::Closure(_, decl, body_id, _, _), .. }) => {\n+            (*body_id, decl.output.span())\n+        }\n+        Node::Item(hir::Item {\n             kind: hir::ItemKind::Fn(hir::FnSig { decl, .. }, _, body_id),\n             ..\n         })\n@@ -529,7 +531,12 @@ fn should_abort_on_panic(tcx: TyCtxt<'_>, fn_def_id: DefId, _abi: Abi) -> bool {\n ///////////////////////////////////////////////////////////////////////////\n /// the main entry point for building MIR for a function\n \n-struct ArgInfo<'tcx>(Ty<'tcx>, Option<Span>, Option<&'tcx hir::Param>, Option<ImplicitSelfKind>);\n+struct ArgInfo<'tcx>(\n+    Ty<'tcx>,\n+    Option<Span>,\n+    Option<&'tcx hir::Param<'tcx>>,\n+    Option<ImplicitSelfKind>,\n+);\n \n fn construct_fn<'a, 'tcx, A>(\n     hir: Cx<'a, 'tcx>,\n@@ -738,7 +745,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         fn_def_id: DefId,\n         arguments: &[ArgInfo<'tcx>],\n         argument_scope: region::Scope,\n-        ast_body: &'tcx hir::Expr,\n+        ast_body: &'tcx hir::Expr<'tcx>,\n     ) -> BlockAnd<()> {\n         // Allocate locals for the function arguments\n         for &ArgInfo(ty, _, arg_opt, _) in arguments.iter() {"}, {"sha": "14f6c3945304dee89f12eff3821ff5c42ccf2fc4", "filename": "src/librustc_mir/hair/cx/block.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/82840353726668c624e46627ac11a1fec18d6d09/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82840353726668c624e46627ac11a1fec18d6d09/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs?ref=82840353726668c624e46627ac11a1fec18d6d09", "patch": "@@ -8,7 +8,7 @@ use rustc::ty;\n \n use rustc_index::vec::Idx;\n \n-impl<'tcx> Mirror<'tcx> for &'tcx hir::Block {\n+impl<'tcx> Mirror<'tcx> for &'tcx hir::Block<'tcx> {\n     type Output = Block<'tcx>;\n \n     fn make_mirror(self, cx: &mut Cx<'_, 'tcx>) -> Block<'tcx> {\n@@ -37,7 +37,7 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Block {\n fn mirror_stmts<'a, 'tcx>(\n     cx: &mut Cx<'a, 'tcx>,\n     block_id: hir::ItemLocalId,\n-    stmts: &'tcx [hir::Stmt],\n+    stmts: &'tcx [hir::Stmt<'tcx>],\n ) -> Vec<StmtRef<'tcx>> {\n     let mut result = vec![];\n     for (index, stmt) in stmts.iter().enumerate() {\n@@ -101,7 +101,10 @@ fn mirror_stmts<'a, 'tcx>(\n     return result;\n }\n \n-pub fn to_expr_ref<'a, 'tcx>(cx: &mut Cx<'a, 'tcx>, block: &'tcx hir::Block) -> ExprRef<'tcx> {\n+pub fn to_expr_ref<'a, 'tcx>(\n+    cx: &mut Cx<'a, 'tcx>,\n+    block: &'tcx hir::Block<'tcx>,\n+) -> ExprRef<'tcx> {\n     let block_ty = cx.tables().node_type(block.hir_id);\n     let temp_lifetime = cx.region_scope_tree.temporary_scope(block.hir_id.local_id);\n     let expr = Expr {"}, {"sha": "124b788fe8dd2152ebfe15b43fcb59e5255b54b6", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/82840353726668c624e46627ac11a1fec18d6d09/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82840353726668c624e46627ac11a1fec18d6d09/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=82840353726668c624e46627ac11a1fec18d6d09", "patch": "@@ -14,7 +14,7 @@ use rustc::ty::{self, AdtKind, Ty};\n use rustc_index::vec::Idx;\n use syntax_pos::Span;\n \n-impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n+impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr<'tcx> {\n     type Output = Expr<'tcx>;\n \n     fn make_mirror(self, cx: &mut Cx<'_, 'tcx>) -> Expr<'tcx> {\n@@ -65,7 +65,7 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n \n fn apply_adjustment<'a, 'tcx>(\n     cx: &mut Cx<'a, 'tcx>,\n-    hir_expr: &'tcx hir::Expr,\n+    hir_expr: &'tcx hir::Expr<'tcx>,\n     mut expr: Expr<'tcx>,\n     adjustment: &Adjustment<'tcx>,\n ) -> Expr<'tcx> {\n@@ -129,7 +129,10 @@ fn apply_adjustment<'a, 'tcx>(\n     Expr { temp_lifetime, ty: adjustment.target, span, kind }\n }\n \n-fn make_mirror_unadjusted<'a, 'tcx>(cx: &mut Cx<'a, 'tcx>, expr: &'tcx hir::Expr) -> Expr<'tcx> {\n+fn make_mirror_unadjusted<'a, 'tcx>(\n+    cx: &mut Cx<'a, 'tcx>,\n+    expr: &'tcx hir::Expr<'tcx>,\n+) -> Expr<'tcx> {\n     let expr_ty = cx.tables().expr_ty(expr);\n     let temp_lifetime = cx.region_scope_tree.temporary_scope(expr.hir_id.local_id);\n \n@@ -608,7 +611,7 @@ fn user_substs_applied_to_res(\n \n fn method_callee<'a, 'tcx>(\n     cx: &mut Cx<'a, 'tcx>,\n-    expr: &hir::Expr,\n+    expr: &hir::Expr<'_>,\n     span: Span,\n     overloaded_callee: Option<(DefId, SubstsRef<'tcx>)>,\n ) -> Expr<'tcx> {\n@@ -662,7 +665,7 @@ impl ToBorrowKind for hir::Mutability {\n     }\n }\n \n-fn convert_arm<'tcx>(cx: &mut Cx<'_, 'tcx>, arm: &'tcx hir::Arm) -> Arm<'tcx> {\n+fn convert_arm<'tcx>(cx: &mut Cx<'_, 'tcx>, arm: &'tcx hir::Arm<'tcx>) -> Arm<'tcx> {\n     Arm {\n         pattern: cx.pattern_from_hir(&arm.pat),\n         guard: match arm.guard {\n@@ -678,7 +681,7 @@ fn convert_arm<'tcx>(cx: &mut Cx<'_, 'tcx>, arm: &'tcx hir::Arm) -> Arm<'tcx> {\n \n fn convert_path_expr<'a, 'tcx>(\n     cx: &mut Cx<'a, 'tcx>,\n-    expr: &'tcx hir::Expr,\n+    expr: &'tcx hir::Expr<'tcx>,\n     res: Res,\n ) -> ExprKind<'tcx> {\n     let substs = cx.tables().node_substs(expr.hir_id);\n@@ -771,7 +774,7 @@ fn convert_path_expr<'a, 'tcx>(\n \n fn convert_var(\n     cx: &mut Cx<'_, 'tcx>,\n-    expr: &'tcx hir::Expr,\n+    expr: &'tcx hir::Expr<'tcx>,\n     var_hir_id: hir::HirId,\n ) -> ExprKind<'tcx> {\n     let upvar_index = cx\n@@ -914,7 +917,7 @@ fn bin_op(op: hir::BinOpKind) -> BinOp {\n \n fn overloaded_operator<'a, 'tcx>(\n     cx: &mut Cx<'a, 'tcx>,\n-    expr: &'tcx hir::Expr,\n+    expr: &'tcx hir::Expr<'tcx>,\n     args: Vec<ExprRef<'tcx>>,\n ) -> ExprKind<'tcx> {\n     let fun = method_callee(cx, expr, expr.span, None);\n@@ -923,7 +926,7 @@ fn overloaded_operator<'a, 'tcx>(\n \n fn overloaded_place<'a, 'tcx>(\n     cx: &mut Cx<'a, 'tcx>,\n-    expr: &'tcx hir::Expr,\n+    expr: &'tcx hir::Expr<'tcx>,\n     place_ty: Ty<'tcx>,\n     overloaded_callee: Option<(DefId, SubstsRef<'tcx>)>,\n     args: Vec<ExprRef<'tcx>>,\n@@ -963,7 +966,7 @@ fn overloaded_place<'a, 'tcx>(\n \n fn capture_upvar<'tcx>(\n     cx: &mut Cx<'_, 'tcx>,\n-    closure_expr: &'tcx hir::Expr,\n+    closure_expr: &'tcx hir::Expr<'tcx>,\n     var_hir_id: hir::HirId,\n     upvar_ty: Ty<'tcx>,\n ) -> ExprRef<'tcx> {\n@@ -1002,7 +1005,7 @@ fn capture_upvar<'tcx>(\n /// Converts a list of named fields (i.e., for struct-like struct/enum ADTs) into FieldExprRef.\n fn field_refs<'a, 'tcx>(\n     cx: &mut Cx<'a, 'tcx>,\n-    fields: &'tcx [hir::Field],\n+    fields: &'tcx [hir::Field<'tcx>],\n ) -> Vec<FieldExprRef<'tcx>> {\n     fields\n         .iter()"}, {"sha": "5c3baaa6ddcd78dac30ef8635030e941348c8f3f", "filename": "src/librustc_mir/hair/cx/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/82840353726668c624e46627ac11a1fec18d6d09/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82840353726668c624e46627ac11a1fec18d6d09/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs?ref=82840353726668c624e46627ac11a1fec18d6d09", "patch": "@@ -151,7 +151,7 @@ impl<'a, 'tcx> Cx<'a, 'tcx> {\n         }\n     }\n \n-    pub fn pattern_from_hir(&mut self, p: &hir::Pat) -> Pat<'tcx> {\n+    pub fn pattern_from_hir(&mut self, p: &hir::Pat<'_>) -> Pat<'tcx> {\n         let p = match self.tcx.hir().get(p.hir_id) {\n             Node::Pat(p) | Node::Binding(p) => p,\n             node => bug!(\"pattern became {:?}\", node),"}, {"sha": "e40e21e76c3760b46f576db07adfd63b0af13e4e", "filename": "src/librustc_mir/hair/cx/to_ref.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/82840353726668c624e46627ac11a1fec18d6d09/src%2Flibrustc_mir%2Fhair%2Fcx%2Fto_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82840353726668c624e46627ac11a1fec18d6d09/src%2Flibrustc_mir%2Fhair%2Fcx%2Fto_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fto_ref.rs?ref=82840353726668c624e46627ac11a1fec18d6d09", "patch": "@@ -1,22 +1,21 @@\n use crate::hair::*;\n \n use rustc::hir;\n-use rustc::hir::ptr::P;\n \n pub trait ToRef {\n     type Output;\n     fn to_ref(self) -> Self::Output;\n }\n \n-impl<'tcx> ToRef for &'tcx hir::Expr {\n+impl<'tcx> ToRef for &'tcx hir::Expr<'tcx> {\n     type Output = ExprRef<'tcx>;\n \n     fn to_ref(self) -> ExprRef<'tcx> {\n         ExprRef::Hair(self)\n     }\n }\n \n-impl<'tcx> ToRef for &'tcx P<hir::Expr> {\n+impl<'tcx> ToRef for &'tcx &'tcx hir::Expr<'tcx> {\n     type Output = ExprRef<'tcx>;\n \n     fn to_ref(self) -> ExprRef<'tcx> {\n@@ -54,7 +53,7 @@ where\n     }\n }\n \n-impl<'tcx, T, U> ToRef for &'tcx P<[T]>\n+impl<'tcx, T, U> ToRef for &'tcx [T]\n where\n     &'tcx T: ToRef<Output = U>,\n {"}, {"sha": "8973c19d58f633d3324aa47600c6357014c24af5", "filename": "src/librustc_mir/hair/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/82840353726668c624e46627ac11a1fec18d6d09/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82840353726668c624e46627ac11a1fec18d6d09/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fmod.rs?ref=82840353726668c624e46627ac11a1fec18d6d09", "patch": "@@ -184,7 +184,7 @@ pub enum ExprKind<'tcx> {\n         arms: Vec<Arm<'tcx>>,\n     },\n     Block {\n-        body: &'tcx hir::Block,\n+        body: &'tcx hir::Block<'tcx>,\n     },\n     Assign {\n         lhs: ExprRef<'tcx>,\n@@ -289,7 +289,7 @@ pub enum ExprKind<'tcx> {\n \n #[derive(Clone, Debug)]\n pub enum ExprRef<'tcx> {\n-    Hair(&'tcx hir::Expr),\n+    Hair(&'tcx hir::Expr<'tcx>),\n     Mirror(Box<Expr<'tcx>>),\n }\n "}, {"sha": "47f2b480850d6adb36b1a05f09f427e34e52a86a", "filename": "src/librustc_mir/hair/pattern/check_match.rs", "status": "modified", "additions": 24, "deletions": 14, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/82840353726668c624e46627ac11a1fec18d6d09/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82840353726668c624e46627ac11a1fec18d6d09/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs?ref=82840353726668c624e46627ac11a1fec18d6d09", "patch": "@@ -53,15 +53,15 @@ impl<'tcx> Visitor<'tcx> for MatchVisitor<'_, 'tcx> {\n         NestedVisitorMap::None\n     }\n \n-    fn visit_expr(&mut self, ex: &'tcx hir::Expr) {\n+    fn visit_expr(&mut self, ex: &'tcx hir::Expr<'tcx>) {\n         intravisit::walk_expr(self, ex);\n \n         if let hir::ExprKind::Match(ref scrut, ref arms, source) = ex.kind {\n             self.check_match(scrut, arms, source);\n         }\n     }\n \n-    fn visit_local(&mut self, loc: &'tcx hir::Local) {\n+    fn visit_local(&mut self, loc: &'tcx hir::Local<'tcx>) {\n         intravisit::walk_local(self, loc);\n \n         let (msg, sp) = match loc.source {\n@@ -121,15 +121,20 @@ impl PatCtxt<'_, '_> {\n }\n \n impl<'tcx> MatchVisitor<'_, 'tcx> {\n-    fn check_patterns(&mut self, has_guard: bool, pat: &Pat) {\n+    fn check_patterns(&mut self, has_guard: bool, pat: &Pat<'_>) {\n         check_legality_of_move_bindings(self, has_guard, pat);\n         check_borrow_conflicts_in_at_patterns(self, pat);\n         if !self.tcx.features().bindings_after_at {\n             check_legality_of_bindings_in_at_patterns(self, pat);\n         }\n     }\n \n-    fn check_match(&mut self, scrut: &hir::Expr, arms: &'tcx [hir::Arm], source: hir::MatchSource) {\n+    fn check_match(\n+        &mut self,\n+        scrut: &hir::Expr<'_>,\n+        arms: &'tcx [hir::Arm<'tcx>],\n+        source: hir::MatchSource,\n+    ) {\n         for arm in arms {\n             // First, check legality of move bindings.\n             self.check_patterns(arm.guard.is_some(), &arm.pat);\n@@ -178,7 +183,7 @@ impl<'tcx> MatchVisitor<'_, 'tcx> {\n         })\n     }\n \n-    fn check_irrefutable(&self, pat: &'tcx Pat, origin: &str, sp: Option<Span>) {\n+    fn check_irrefutable(&self, pat: &'tcx Pat<'tcx>, origin: &str, sp: Option<Span>) {\n         let module = self.tcx.hir().get_module_parent(pat.hir_id);\n         MatchCheckCtxt::create_and_enter(self.tcx, self.param_env, module, |ref mut cx| {\n             let mut patcx =\n@@ -246,7 +251,12 @@ impl<'tcx> MatchVisitor<'_, 'tcx> {\n \n /// A path pattern was interpreted as a constant, not a new variable.\n /// This caused an irrefutable match failure in e.g. `let`.\n-fn const_not_var(err: &mut DiagnosticBuilder<'_>, tcx: TyCtxt<'_>, pat: &Pat, path: &hir::Path) {\n+fn const_not_var(\n+    err: &mut DiagnosticBuilder<'_>,\n+    tcx: TyCtxt<'_>,\n+    pat: &Pat<'_>,\n+    path: &hir::Path,\n+) {\n     let descr = path.res.descr();\n     err.span_label(\n         pat.span,\n@@ -268,7 +278,7 @@ fn const_not_var(err: &mut DiagnosticBuilder<'_>, tcx: TyCtxt<'_>, pat: &Pat, pa\n     }\n }\n \n-fn check_for_bindings_named_same_as_variants(cx: &MatchVisitor<'_, '_>, pat: &Pat) {\n+fn check_for_bindings_named_same_as_variants(cx: &MatchVisitor<'_, '_>, pat: &Pat<'_>) {\n     pat.walk_always(|p| {\n         if let hir::PatKind::Binding(_, _, ident, None) = p.kind {\n             if let Some(ty::BindByValue(hir::Mutability::Not)) =\n@@ -307,7 +317,7 @@ fn check_for_bindings_named_same_as_variants(cx: &MatchVisitor<'_, '_>, pat: &Pa\n }\n \n /// Checks for common cases of \"catchall\" patterns that may not be intended as such.\n-fn pat_is_catchall(pat: &Pat) -> bool {\n+fn pat_is_catchall(pat: &Pat<'_>) -> bool {\n     match pat.kind {\n         hir::PatKind::Binding(.., None) => true,\n         hir::PatKind::Binding(.., Some(ref s)) => pat_is_catchall(s),\n@@ -320,7 +330,7 @@ fn pat_is_catchall(pat: &Pat) -> bool {\n /// Check for unreachable patterns.\n fn check_arms<'p, 'tcx>(\n     cx: &mut MatchCheckCtxt<'p, 'tcx>,\n-    arms: &[(&'p super::Pat<'tcx>, &hir::Pat, bool)],\n+    arms: &[(&'p super::Pat<'tcx>, &hir::Pat<'_>, bool)],\n     source: hir::MatchSource,\n ) -> Matrix<'p, 'tcx> {\n     let mut seen = Matrix::empty();\n@@ -575,7 +585,7 @@ fn maybe_point_at_variant(ty: Ty<'_>, patterns: &[super::Pat<'_>]) -> Vec<Span>\n }\n \n /// Check the legality of legality of by-move bindings.\n-fn check_legality_of_move_bindings(cx: &mut MatchVisitor<'_, '_>, has_guard: bool, pat: &Pat) {\n+fn check_legality_of_move_bindings(cx: &mut MatchVisitor<'_, '_>, has_guard: bool, pat: &Pat<'_>) {\n     let sess = cx.tcx.sess;\n     let tables = cx.tables;\n \n@@ -589,7 +599,7 @@ fn check_legality_of_move_bindings(cx: &mut MatchVisitor<'_, '_>, has_guard: boo\n \n     // Find bad by-move spans:\n     let by_move_spans = &mut Vec::new();\n-    let mut check_move = |p: &Pat, sub: Option<&Pat>| {\n+    let mut check_move = |p: &Pat<'_>, sub: Option<&Pat<'_>>| {\n         // Check legality of moving out of the enum.\n         //\n         // `x @ Foo(..)` is legal, but `x @ Foo(y)` isn't.\n@@ -638,7 +648,7 @@ fn check_legality_of_move_bindings(cx: &mut MatchVisitor<'_, '_>, has_guard: boo\n /// - `ref mut x @ Some(ref mut y)`.\n ///\n /// This analysis is *not* subsumed by NLL.\n-fn check_borrow_conflicts_in_at_patterns(cx: &MatchVisitor<'_, '_>, pat: &Pat) {\n+fn check_borrow_conflicts_in_at_patterns(cx: &MatchVisitor<'_, '_>, pat: &Pat<'_>) {\n     let tab = cx.tables;\n     let sess = cx.tcx.sess;\n     // Get the mutability of `p` if it's by-ref.\n@@ -709,7 +719,7 @@ fn check_borrow_conflicts_in_at_patterns(cx: &MatchVisitor<'_, '_>, pat: &Pat) {\n \n /// Forbids bindings in `@` patterns. This used to be is necessary for memory safety,\n /// because of the way rvalues were handled in the borrow check. (See issue #14587.)\n-fn check_legality_of_bindings_in_at_patterns(cx: &MatchVisitor<'_, '_>, pat: &Pat) {\n+fn check_legality_of_bindings_in_at_patterns(cx: &MatchVisitor<'_, '_>, pat: &Pat<'_>) {\n     AtBindingPatternVisitor { cx, bindings_allowed: true }.visit_pat(pat);\n \n     struct AtBindingPatternVisitor<'a, 'b, 'tcx> {\n@@ -722,7 +732,7 @@ fn check_legality_of_bindings_in_at_patterns(cx: &MatchVisitor<'_, '_>, pat: &Pa\n             NestedVisitorMap::None\n         }\n \n-        fn visit_pat(&mut self, pat: &Pat) {\n+        fn visit_pat(&mut self, pat: &Pat<'_>) {\n             match pat.kind {\n                 hir::PatKind::Binding(.., ref subpat) => {\n                     if !self.bindings_allowed {"}, {"sha": "bf0de7e9ef0b15512a3cd64a3235418208f07a00", "filename": "src/librustc_mir/hair/pattern/mod.rs", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/82840353726668c624e46627ac11a1fec18d6d09/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82840353726668c624e46627ac11a1fec18d6d09/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs?ref=82840353726668c624e46627ac11a1fec18d6d09", "patch": "@@ -11,7 +11,6 @@ use crate::hair::util::UserAnnotatedTyHelpers;\n \n use rustc::hir::def::{CtorKind, CtorOf, DefKind, Res};\n use rustc::hir::pat_util::EnumerateAndAdjustIterator;\n-use rustc::hir::ptr::P;\n use rustc::hir::{self, RangeEnd};\n use rustc::mir::interpret::{get_slice_bytes, sign_extend, ConstValue, ErrorHandled};\n use rustc::mir::UserTypeProjection;\n@@ -356,7 +355,7 @@ impl<'a, 'tcx> Pat<'tcx> {\n         tcx: TyCtxt<'tcx>,\n         param_env_and_substs: ty::ParamEnvAnd<'tcx, SubstsRef<'tcx>>,\n         tables: &'a ty::TypeckTables<'tcx>,\n-        pat: &'tcx hir::Pat,\n+        pat: &'tcx hir::Pat<'tcx>,\n     ) -> Self {\n         let mut pcx = PatCtxt::new(tcx, param_env_and_substs, tables);\n         let result = pcx.lower_pattern(pat);\n@@ -390,7 +389,7 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n         self\n     }\n \n-    pub fn lower_pattern(&mut self, pat: &'tcx hir::Pat) -> Pat<'tcx> {\n+    pub fn lower_pattern(&mut self, pat: &'tcx hir::Pat<'tcx>) -> Pat<'tcx> {\n         // When implicit dereferences have been inserted in this pattern, the unadjusted lowered\n         // pattern has the type that results *after* dereferencing. For example, in this code:\n         //\n@@ -426,7 +425,7 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n \n     fn lower_range_expr(\n         &mut self,\n-        expr: &'tcx hir::Expr,\n+        expr: &'tcx hir::Expr<'tcx>,\n     ) -> (PatKind<'tcx>, Option<Ascription<'tcx>>) {\n         match self.lower_lit(expr) {\n             PatKind::AscribeUserType {\n@@ -437,7 +436,7 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n         }\n     }\n \n-    fn lower_pattern_unadjusted(&mut self, pat: &'tcx hir::Pat) -> Pat<'tcx> {\n+    fn lower_pattern_unadjusted(&mut self, pat: &'tcx hir::Pat<'tcx>) -> Pat<'tcx> {\n         let mut ty = self.tables.node_type(pat.hir_id);\n \n         if let ty::Error = ty.kind {\n@@ -616,7 +615,7 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n \n     fn lower_tuple_subpats(\n         &mut self,\n-        pats: &'tcx [P<hir::Pat>],\n+        pats: &'tcx [&'tcx hir::Pat<'tcx>],\n         expected_len: usize,\n         gap_pos: Option<usize>,\n     ) -> Vec<FieldPat<'tcx>> {\n@@ -629,21 +628,21 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n             .collect()\n     }\n \n-    fn lower_patterns(&mut self, pats: &'tcx [P<hir::Pat>]) -> Vec<Pat<'tcx>> {\n+    fn lower_patterns(&mut self, pats: &'tcx [&'tcx hir::Pat<'tcx>]) -> Vec<Pat<'tcx>> {\n         pats.iter().map(|p| self.lower_pattern(p)).collect()\n     }\n \n-    fn lower_opt_pattern(&mut self, pat: &'tcx Option<P<hir::Pat>>) -> Option<Pat<'tcx>> {\n+    fn lower_opt_pattern(&mut self, pat: &'tcx Option<&'tcx hir::Pat<'tcx>>) -> Option<Pat<'tcx>> {\n         pat.as_ref().map(|p| self.lower_pattern(p))\n     }\n \n     fn slice_or_array_pattern(\n         &mut self,\n         span: Span,\n         ty: Ty<'tcx>,\n-        prefix: &'tcx [P<hir::Pat>],\n-        slice: &'tcx Option<P<hir::Pat>>,\n-        suffix: &'tcx [P<hir::Pat>],\n+        prefix: &'tcx [&'tcx hir::Pat<'tcx>],\n+        slice: &'tcx Option<&'tcx hir::Pat<'tcx>>,\n+        suffix: &'tcx [&'tcx hir::Pat<'tcx>],\n     ) -> PatKind<'tcx> {\n         let prefix = self.lower_patterns(prefix);\n         let slice = self.lower_opt_pattern(slice);\n@@ -795,7 +794,7 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n     /// The special case for negation exists to allow things like `-128_i8`\n     /// which would overflow if we tried to evaluate `128_i8` and then negate\n     /// afterwards.\n-    fn lower_lit(&mut self, expr: &'tcx hir::Expr) -> PatKind<'tcx> {\n+    fn lower_lit(&mut self, expr: &'tcx hir::Expr<'tcx>) -> PatKind<'tcx> {\n         match expr.kind {\n             hir::ExprKind::Lit(ref lit) => {\n                 let ty = self.tables.expr_ty(expr);"}, {"sha": "8b8f1b6f670ef69def9222cb478cec0c02b7d2b1", "filename": "src/librustc_mir/transform/check_unsafety.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/82840353726668c624e46627ac11a1fec18d6d09/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82840353726668c624e46627ac11a1fec18d6d09/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs?ref=82840353726668c624e46627ac11a1fec18d6d09", "patch": "@@ -479,7 +479,7 @@ impl<'a, 'tcx> hir::intravisit::Visitor<'tcx> for UnusedUnsafeVisitor<'a> {\n         hir::intravisit::NestedVisitorMap::None\n     }\n \n-    fn visit_block(&mut self, block: &'tcx hir::Block) {\n+    fn visit_block(&mut self, block: &'tcx hir::Block<'tcx>) {\n         hir::intravisit::walk_block(self, block);\n \n         if let hir::UnsafeBlock(hir::UserProvided) = block.rules {"}, {"sha": "fbfe2135012959e9975ccbd3b481007711a9dc09", "filename": "src/librustc_passes/check_const.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/82840353726668c624e46627ac11a1fec18d6d09/src%2Flibrustc_passes%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82840353726668c624e46627ac11a1fec18d6d09/src%2Flibrustc_passes%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fcheck_const.rs?ref=82840353726668c624e46627ac11a1fec18d6d09", "patch": "@@ -214,7 +214,7 @@ impl<'tcx> Visitor<'tcx> for CheckConstVisitor<'tcx> {\n         self.recurse_into(kind, |this| hir::intravisit::walk_body(this, body));\n     }\n \n-    fn visit_pat(&mut self, p: &'tcx hir::Pat) {\n+    fn visit_pat(&mut self, p: &'tcx hir::Pat<'tcx>) {\n         if self.const_kind.is_some() {\n             if let hir::PatKind::Or { .. } = p.kind {\n                 self.const_check_violated(NonConstExpr::OrPattern, p.span);\n@@ -223,7 +223,7 @@ impl<'tcx> Visitor<'tcx> for CheckConstVisitor<'tcx> {\n         hir::intravisit::walk_pat(self, p)\n     }\n \n-    fn visit_expr(&mut self, e: &'tcx hir::Expr) {\n+    fn visit_expr(&mut self, e: &'tcx hir::Expr<'tcx>) {\n         match &e.kind {\n             // Skip the following checks if we are not currently in a const context.\n             _ if self.const_kind.is_none() => {}"}, {"sha": "a13c9aff70a229e9ae622370d5185d977ccca8e2", "filename": "src/librustc_passes/dead.rs", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/82840353726668c624e46627ac11a1fec18d6d09/src%2Flibrustc_passes%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82840353726668c624e46627ac11a1fec18d6d09/src%2Flibrustc_passes%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fdead.rs?ref=82840353726668c624e46627ac11a1fec18d6d09", "patch": "@@ -115,7 +115,7 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n         }\n     }\n \n-    fn handle_field_access(&mut self, lhs: &hir::Expr, hir_id: hir::HirId) {\n+    fn handle_field_access(&mut self, lhs: &hir::Expr<'_>, hir_id: hir::HirId) {\n         match self.tables.expr_ty_adjusted(lhs).kind {\n             ty::Adt(def, _) => {\n                 let index = self.tcx.field_index(hir_id, self.tables);\n@@ -126,7 +126,12 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n         }\n     }\n \n-    fn handle_field_pattern_match(&mut self, lhs: &hir::Pat, res: Res, pats: &[hir::FieldPat]) {\n+    fn handle_field_pattern_match(\n+        &mut self,\n+        lhs: &hir::Pat<'_>,\n+        res: Res,\n+        pats: &[hir::FieldPat<'_>],\n+    ) {\n         let variant = match self.tables.node_type(lhs.hir_id).kind {\n             ty::Adt(adt, _) => adt.variant_of_res(res),\n             _ => span_bug!(lhs.span, \"non-ADT in struct pattern\"),\n@@ -197,7 +202,7 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n         self.inherited_pub_visibility = had_inherited_pub_visibility;\n     }\n \n-    fn mark_as_used_if_union(&mut self, adt: &ty::AdtDef, fields: &hir::HirVec<hir::Field>) {\n+    fn mark_as_used_if_union(&mut self, adt: &ty::AdtDef, fields: &[hir::Field<'_>]) {\n         if adt.is_union() && adt.non_enum_variant().fields.len() > 1 && adt.did.is_local() {\n             for field in fields {\n                 let index = self.tcx.field_index(field.hir_id, self.tables);\n@@ -239,7 +244,7 @@ impl<'a, 'tcx> Visitor<'tcx> for MarkSymbolVisitor<'a, 'tcx> {\n         intravisit::walk_struct_def(self, def);\n     }\n \n-    fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n+    fn visit_expr(&mut self, expr: &'tcx hir::Expr<'tcx>) {\n         match expr.kind {\n             hir::ExprKind::Path(ref qpath @ hir::QPath::TypeRelative(..)) => {\n                 let res = self.tables.qpath_res(qpath, expr.hir_id);\n@@ -262,7 +267,7 @@ impl<'a, 'tcx> Visitor<'tcx> for MarkSymbolVisitor<'a, 'tcx> {\n         intravisit::walk_expr(self, expr);\n     }\n \n-    fn visit_arm(&mut self, arm: &'tcx hir::Arm) {\n+    fn visit_arm(&mut self, arm: &'tcx hir::Arm<'tcx>) {\n         // Inside the body, ignore constructions of variants\n         // necessary for the pattern to match. Those construction sites\n         // can't be reached unless the variant is constructed elsewhere.\n@@ -272,7 +277,7 @@ impl<'a, 'tcx> Visitor<'tcx> for MarkSymbolVisitor<'a, 'tcx> {\n         self.ignore_variant_stack.truncate(len);\n     }\n \n-    fn visit_pat(&mut self, pat: &'tcx hir::Pat) {\n+    fn visit_pat(&mut self, pat: &'tcx hir::Pat<'tcx>) {\n         match pat.kind {\n             PatKind::Struct(ref path, ref fields, _) => {\n                 let res = self.tables.qpath_res(path, pat.hir_id);"}, {"sha": "5ec1d458a96dbb0ed554c93e7dd422445e4ad85a", "filename": "src/librustc_passes/hir_stats.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/82840353726668c624e46627ac11a1fec18d6d09/src%2Flibrustc_passes%2Fhir_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82840353726668c624e46627ac11a1fec18d6d09/src%2Flibrustc_passes%2Fhir_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fhir_stats.rs?ref=82840353726668c624e46627ac11a1fec18d6d09", "patch": "@@ -86,7 +86,7 @@ impl<'k> StatCollector<'k> {\n }\n \n impl<'v> hir_visit::Visitor<'v> for StatCollector<'v> {\n-    fn visit_param(&mut self, param: &'v hir::Param) {\n+    fn visit_param(&mut self, param: &'v hir::Param<'v>) {\n         self.record(\"Param\", Id::Node(param.hir_id), param);\n         hir_visit::walk_param(self, param)\n     }\n@@ -130,32 +130,32 @@ impl<'v> hir_visit::Visitor<'v> for StatCollector<'v> {\n         hir_visit::walk_foreign_item(self, i)\n     }\n \n-    fn visit_local(&mut self, l: &'v hir::Local) {\n+    fn visit_local(&mut self, l: &'v hir::Local<'v>) {\n         self.record(\"Local\", Id::Node(l.hir_id), l);\n         hir_visit::walk_local(self, l)\n     }\n \n-    fn visit_block(&mut self, b: &'v hir::Block) {\n+    fn visit_block(&mut self, b: &'v hir::Block<'v>) {\n         self.record(\"Block\", Id::Node(b.hir_id), b);\n         hir_visit::walk_block(self, b)\n     }\n \n-    fn visit_stmt(&mut self, s: &'v hir::Stmt) {\n+    fn visit_stmt(&mut self, s: &'v hir::Stmt<'v>) {\n         self.record(\"Stmt\", Id::Node(s.hir_id), s);\n         hir_visit::walk_stmt(self, s)\n     }\n \n-    fn visit_arm(&mut self, a: &'v hir::Arm) {\n+    fn visit_arm(&mut self, a: &'v hir::Arm<'v>) {\n         self.record(\"Arm\", Id::Node(a.hir_id), a);\n         hir_visit::walk_arm(self, a)\n     }\n \n-    fn visit_pat(&mut self, p: &'v hir::Pat) {\n+    fn visit_pat(&mut self, p: &'v hir::Pat<'v>) {\n         self.record(\"Pat\", Id::Node(p.hir_id), p);\n         hir_visit::walk_pat(self, p)\n     }\n \n-    fn visit_expr(&mut self, ex: &'v hir::Expr) {\n+    fn visit_expr(&mut self, ex: &'v hir::Expr<'v>) {\n         self.record(\"Expr\", Id::Node(ex.hir_id), ex);\n         hir_visit::walk_expr(self, ex)\n     }"}, {"sha": "92903e95a0dc4ed6aee90f7770ad004819567a43", "filename": "src/librustc_passes/intrinsicck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/82840353726668c624e46627ac11a1fec18d6d09/src%2Flibrustc_passes%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82840353726668c624e46627ac11a1fec18d6d09/src%2Flibrustc_passes%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fintrinsicck.rs?ref=82840353726668c624e46627ac11a1fec18d6d09", "patch": "@@ -142,7 +142,7 @@ impl Visitor<'tcx> for ExprVisitor<'tcx> {\n         NestedVisitorMap::None\n     }\n \n-    fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n+    fn visit_expr(&mut self, expr: &'tcx hir::Expr<'tcx>) {\n         let res = if let hir::ExprKind::Path(ref qpath) = expr.kind {\n             self.tables.qpath_res(qpath, expr.hir_id)\n         } else {"}, {"sha": "ea4479ef5ce7c67916cd6b53ce5751a9eb0602d8", "filename": "src/librustc_passes/liveness.rs", "status": "modified", "additions": 34, "deletions": 31, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/82840353726668c624e46627ac11a1fec18d6d09/src%2Flibrustc_passes%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82840353726668c624e46627ac11a1fec18d6d09/src%2Flibrustc_passes%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fliveness.rs?ref=82840353726668c624e46627ac11a1fec18d6d09", "patch": "@@ -100,7 +100,6 @@ use rustc::hir;\n use rustc::hir::def::*;\n use rustc::hir::def_id::DefId;\n use rustc::hir::intravisit::{self, FnKind, NestedVisitorMap, Visitor};\n-use rustc::hir::ptr::P;\n use rustc::hir::Node;\n use rustc::hir::{Expr, HirId};\n use rustc::lint;\n@@ -171,13 +170,13 @@ impl<'tcx> Visitor<'tcx> for IrMaps<'tcx> {\n         visit_fn(self, fk, fd, b, s, id);\n     }\n \n-    fn visit_local(&mut self, l: &'tcx hir::Local) {\n+    fn visit_local(&mut self, l: &'tcx hir::Local<'tcx>) {\n         visit_local(self, l);\n     }\n-    fn visit_expr(&mut self, ex: &'tcx Expr) {\n+    fn visit_expr(&mut self, ex: &'tcx Expr<'tcx>) {\n         visit_expr(self, ex);\n     }\n-    fn visit_arm(&mut self, a: &'tcx hir::Arm) {\n+    fn visit_arm(&mut self, a: &'tcx hir::Arm<'tcx>) {\n         visit_arm(self, a);\n     }\n }\n@@ -406,7 +405,7 @@ fn visit_fn<'tcx>(\n     lsets.warn_about_unused_args(body, entry_ln);\n }\n \n-fn add_from_pat(ir: &mut IrMaps<'_>, pat: &P<hir::Pat>) {\n+fn add_from_pat(ir: &mut IrMaps<'_>, pat: &hir::Pat<'_>) {\n     // For struct patterns, take note of which fields used shorthand\n     // (`x` rather than `x: x`).\n     let mut shorthand_field_ids = HirIdSet::default();\n@@ -447,17 +446,17 @@ fn add_from_pat(ir: &mut IrMaps<'_>, pat: &P<hir::Pat>) {\n     });\n }\n \n-fn visit_local<'tcx>(ir: &mut IrMaps<'tcx>, local: &'tcx hir::Local) {\n+fn visit_local<'tcx>(ir: &mut IrMaps<'tcx>, local: &'tcx hir::Local<'tcx>) {\n     add_from_pat(ir, &local.pat);\n     intravisit::walk_local(ir, local);\n }\n \n-fn visit_arm<'tcx>(ir: &mut IrMaps<'tcx>, arm: &'tcx hir::Arm) {\n+fn visit_arm<'tcx>(ir: &mut IrMaps<'tcx>, arm: &'tcx hir::Arm<'tcx>) {\n     add_from_pat(ir, &arm.pat);\n     intravisit::walk_arm(ir, arm);\n }\n \n-fn visit_expr<'tcx>(ir: &mut IrMaps<'tcx>, expr: &'tcx Expr) {\n+fn visit_expr<'tcx>(ir: &mut IrMaps<'tcx>, expr: &'tcx Expr<'tcx>) {\n     match expr.kind {\n         // live nodes required for uses or definitions of variables:\n         hir::ExprKind::Path(hir::QPath::Resolved(_, ref path)) => {\n@@ -714,7 +713,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         self.ir.variable(hir_id, span)\n     }\n \n-    fn define_bindings_in_pat(&mut self, pat: &hir::Pat, mut succ: LiveNode) -> LiveNode {\n+    fn define_bindings_in_pat(&mut self, pat: &hir::Pat<'_>, mut succ: LiveNode) -> LiveNode {\n         // In an or-pattern, only consider the first pattern; any later patterns\n         // must have the same bindings, and we also consider the first pattern\n         // to be the \"authoritative\" set of ids.\n@@ -891,7 +890,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         self.rwu_table.assign_unpacked(idx, rwu);\n     }\n \n-    fn compute(&mut self, body: &hir::Expr) -> LiveNode {\n+    fn compute(&mut self, body: &hir::Expr<'_>) -> LiveNode {\n         debug!(\n             \"compute: using id for body, {}\",\n             self.ir.tcx.hir().hir_to_pretty_string(body.hir_id)\n@@ -920,15 +919,15 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         entry_ln\n     }\n \n-    fn propagate_through_block(&mut self, blk: &hir::Block, succ: LiveNode) -> LiveNode {\n+    fn propagate_through_block(&mut self, blk: &hir::Block<'_>, succ: LiveNode) -> LiveNode {\n         if blk.targeted_by_break {\n             self.break_ln.insert(blk.hir_id, succ);\n         }\n         let succ = self.propagate_through_opt_expr(blk.expr.as_ref().map(|e| &**e), succ);\n         blk.stmts.iter().rev().fold(succ, |succ, stmt| self.propagate_through_stmt(stmt, succ))\n     }\n \n-    fn propagate_through_stmt(&mut self, stmt: &hir::Stmt, succ: LiveNode) -> LiveNode {\n+    fn propagate_through_stmt(&mut self, stmt: &hir::Stmt<'_>, succ: LiveNode) -> LiveNode {\n         match stmt.kind {\n             hir::StmtKind::Local(ref local) => {\n                 // Note: we mark the variable as defined regardless of whether\n@@ -955,15 +954,19 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         }\n     }\n \n-    fn propagate_through_exprs(&mut self, exprs: &[Expr], succ: LiveNode) -> LiveNode {\n+    fn propagate_through_exprs(&mut self, exprs: &[Expr<'_>], succ: LiveNode) -> LiveNode {\n         exprs.iter().rev().fold(succ, |succ, expr| self.propagate_through_expr(&expr, succ))\n     }\n \n-    fn propagate_through_opt_expr(&mut self, opt_expr: Option<&Expr>, succ: LiveNode) -> LiveNode {\n+    fn propagate_through_opt_expr(\n+        &mut self,\n+        opt_expr: Option<&Expr<'_>>,\n+        succ: LiveNode,\n+    ) -> LiveNode {\n         opt_expr.map_or(succ, |expr| self.propagate_through_expr(expr, succ))\n     }\n \n-    fn propagate_through_expr(&mut self, expr: &Expr, succ: LiveNode) -> LiveNode {\n+    fn propagate_through_expr(&mut self, expr: &Expr<'_>, succ: LiveNode) -> LiveNode {\n         debug!(\"propagate_through_expr: {}\", self.ir.tcx.hir().hir_to_pretty_string(expr.hir_id));\n \n         match expr.kind {\n@@ -1001,7 +1004,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             // at the label ident\n             hir::ExprKind::Loop(ref blk, _, _) => self.propagate_through_loop(expr, &blk, succ),\n \n-            hir::ExprKind::Match(ref e, ref arms, _) => {\n+            hir::ExprKind::Match(ref e, arms, _) => {\n                 //\n                 //      (e)\n                 //       |\n@@ -1023,7 +1026,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                     let body_succ = self.propagate_through_expr(&arm.body, succ);\n \n                     let guard_succ = self.propagate_through_opt_expr(\n-                        arm.guard.as_ref().map(|hir::Guard::If(e)| &**e),\n+                        arm.guard.as_ref().map(|hir::Guard::If(e)| *e),\n                         body_succ,\n                     );\n                     let arm_succ = self.define_bindings_in_pat(&arm.pat, guard_succ);\n@@ -1162,8 +1165,8 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n             hir::ExprKind::InlineAsm(ref asm) => {\n                 let ia = &asm.inner;\n-                let outputs = &asm.outputs_exprs;\n-                let inputs = &asm.inputs_exprs;\n+                let outputs = asm.outputs_exprs;\n+                let inputs = asm.inputs_exprs;\n                 let succ = ia.outputs.iter().zip(outputs).rev().fold(succ, |succ, (o, output)| {\n                     // see comment on places\n                     // in propagate_through_place_components()\n@@ -1190,7 +1193,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         }\n     }\n \n-    fn propagate_through_place_components(&mut self, expr: &Expr, succ: LiveNode) -> LiveNode {\n+    fn propagate_through_place_components(&mut self, expr: &Expr<'_>, succ: LiveNode) -> LiveNode {\n         // # Places\n         //\n         // In general, the full flow graph structure for an\n@@ -1248,7 +1251,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n     }\n \n     // see comment on propagate_through_place()\n-    fn write_place(&mut self, expr: &Expr, succ: LiveNode, acc: u32) -> LiveNode {\n+    fn write_place(&mut self, expr: &Expr<'_>, succ: LiveNode, acc: u32) -> LiveNode {\n         match expr.kind {\n             hir::ExprKind::Path(hir::QPath::Resolved(_, ref path)) => {\n                 self.access_path(expr.hir_id, path, succ, acc)\n@@ -1301,8 +1304,8 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n     fn propagate_through_loop(\n         &mut self,\n-        expr: &Expr,\n-        body: &hir::Block,\n+        expr: &Expr<'_>,\n+        body: &hir::Block<'_>,\n         succ: LiveNode,\n     ) -> LiveNode {\n         /*\n@@ -1351,7 +1354,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Liveness<'a, 'tcx> {\n         NestedVisitorMap::None\n     }\n \n-    fn visit_local(&mut self, local: &'tcx hir::Local) {\n+    fn visit_local(&mut self, local: &'tcx hir::Local<'tcx>) {\n         self.check_unused_vars_in_pat(&local.pat, None, |spans, hir_id, ln, var| {\n             if local.init.is_some() {\n                 self.warn_about_dead_assign(spans, hir_id, ln, var);\n@@ -1361,17 +1364,17 @@ impl<'a, 'tcx> Visitor<'tcx> for Liveness<'a, 'tcx> {\n         intravisit::walk_local(self, local);\n     }\n \n-    fn visit_expr(&mut self, ex: &'tcx Expr) {\n+    fn visit_expr(&mut self, ex: &'tcx Expr<'tcx>) {\n         check_expr(self, ex);\n     }\n \n-    fn visit_arm(&mut self, arm: &'tcx hir::Arm) {\n+    fn visit_arm(&mut self, arm: &'tcx hir::Arm<'tcx>) {\n         self.check_unused_vars_in_pat(&arm.pat, None, |_, _, _, _| {});\n         intravisit::walk_arm(self, arm);\n     }\n }\n \n-fn check_expr<'tcx>(this: &mut Liveness<'_, 'tcx>, expr: &'tcx Expr) {\n+fn check_expr<'tcx>(this: &mut Liveness<'_, 'tcx>, expr: &'tcx Expr<'tcx>) {\n     match expr.kind {\n         hir::ExprKind::Assign(ref l, ..) => {\n             this.check_place(&l);\n@@ -1384,12 +1387,12 @@ fn check_expr<'tcx>(this: &mut Liveness<'_, 'tcx>, expr: &'tcx Expr) {\n         }\n \n         hir::ExprKind::InlineAsm(ref asm) => {\n-            for input in &asm.inputs_exprs {\n+            for input in asm.inputs_exprs {\n                 this.visit_expr(input);\n             }\n \n             // Output operands must be places\n-            for (o, output) in asm.inner.outputs.iter().zip(&asm.outputs_exprs) {\n+            for (o, output) in asm.inner.outputs.iter().zip(asm.outputs_exprs) {\n                 if !o.is_indirect {\n                     this.check_place(output);\n                 }\n@@ -1430,7 +1433,7 @@ fn check_expr<'tcx>(this: &mut Liveness<'_, 'tcx>, expr: &'tcx Expr) {\n }\n \n impl<'tcx> Liveness<'_, 'tcx> {\n-    fn check_place(&mut self, expr: &'tcx Expr) {\n+    fn check_place(&mut self, expr: &'tcx Expr<'tcx>) {\n         match expr.kind {\n             hir::ExprKind::Path(hir::QPath::Resolved(_, ref path)) => {\n                 if let Res::Local(var_hid) = path.res {\n@@ -1471,7 +1474,7 @@ impl<'tcx> Liveness<'_, 'tcx> {\n \n     fn check_unused_vars_in_pat(\n         &self,\n-        pat: &hir::Pat,\n+        pat: &hir::Pat<'_>,\n         entry_ln: Option<LiveNode>,\n         on_used_on_entry: impl Fn(Vec<Span>, HirId, LiveNode, Variable),\n     ) {"}, {"sha": "463e6899c4f743f4ab2ab5ec820c95fd420f000d", "filename": "src/librustc_passes/loops.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/82840353726668c624e46627ac11a1fec18d6d09/src%2Flibrustc_passes%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82840353726668c624e46627ac11a1fec18d6d09/src%2Flibrustc_passes%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Floops.rs?ref=82840353726668c624e46627ac11a1fec18d6d09", "patch": "@@ -52,7 +52,7 @@ impl<'a, 'hir> Visitor<'hir> for CheckLoopVisitor<'a, 'hir> {\n         self.with_context(AnonConst, |v| intravisit::walk_anon_const(v, c));\n     }\n \n-    fn visit_expr(&mut self, e: &'hir hir::Expr) {\n+    fn visit_expr(&mut self, e: &'hir hir::Expr<'hir>) {\n         match e.kind {\n             hir::ExprKind::Loop(ref b, _, source) => {\n                 self.with_context(Loop(source), |v| v.visit_block(&b));"}, {"sha": "a72b3b74cbbe400b45549f86482e8df8ce04769b", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/82840353726668c624e46627ac11a1fec18d6d09/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82840353726668c624e46627ac11a1fec18d6d09/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=82840353726668c624e46627ac11a1fec18d6d09", "patch": "@@ -883,7 +883,7 @@ impl Visitor<'tcx> for EmbargoVisitor<'tcx> {\n         self.prev_level = orig_level;\n     }\n \n-    fn visit_block(&mut self, b: &'tcx hir::Block) {\n+    fn visit_block(&mut self, b: &'tcx hir::Block<'tcx>) {\n         // Blocks can have public items, for example impls, but they always\n         // start as completely private regardless of publicity of a function,\n         // constant, type, field, etc., in which this block resides.\n@@ -1080,9 +1080,9 @@ impl<'a, 'tcx> Visitor<'tcx> for NamePrivacyVisitor<'a, 'tcx> {\n         self.tables = orig_tables;\n     }\n \n-    fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n+    fn visit_expr(&mut self, expr: &'tcx hir::Expr<'tcx>) {\n         match expr.kind {\n-            hir::ExprKind::Struct(ref qpath, ref fields, ref base) => {\n+            hir::ExprKind::Struct(ref qpath, fields, ref base) => {\n                 let res = self.tables.qpath_res(qpath, expr.hir_id);\n                 let adt = self.tables.expr_ty(expr).ty_adt_def().unwrap();\n                 let variant = adt.variant_of_res(res);\n@@ -1114,9 +1114,9 @@ impl<'a, 'tcx> Visitor<'tcx> for NamePrivacyVisitor<'a, 'tcx> {\n         intravisit::walk_expr(self, expr);\n     }\n \n-    fn visit_pat(&mut self, pat: &'tcx hir::Pat) {\n+    fn visit_pat(&mut self, pat: &'tcx hir::Pat<'tcx>) {\n         match pat.kind {\n-            PatKind::Struct(ref qpath, ref fields, _) => {\n+            PatKind::Struct(ref qpath, fields, _) => {\n                 let res = self.tables.qpath_res(qpath, pat.hir_id);\n                 let adt = self.tables.pat_ty(pat).ty_adt_def().unwrap();\n                 let variant = adt.variant_of_res(res);\n@@ -1245,7 +1245,7 @@ impl<'a, 'tcx> Visitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n     }\n \n     // Check types of expressions\n-    fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n+    fn visit_expr(&mut self, expr: &'tcx hir::Expr<'tcx>) {\n         if self.check_expr_pat_type(expr.hir_id, expr.span) {\n             // Do not check nested expressions if the error already happened.\n             return;\n@@ -1313,7 +1313,7 @@ impl<'a, 'tcx> Visitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n     }\n \n     // Check types of patterns.\n-    fn visit_pat(&mut self, pattern: &'tcx hir::Pat) {\n+    fn visit_pat(&mut self, pattern: &'tcx hir::Pat<'tcx>) {\n         if self.check_expr_pat_type(pattern.hir_id, pattern.span) {\n             // Do not check nested patterns if the error already happened.\n             return;\n@@ -1322,7 +1322,7 @@ impl<'a, 'tcx> Visitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n         intravisit::walk_pat(self, pattern);\n     }\n \n-    fn visit_local(&mut self, local: &'tcx hir::Local) {\n+    fn visit_local(&mut self, local: &'tcx hir::Local<'tcx>) {\n         if let Some(ref init) = local.init {\n             if self.check_expr_pat_type(init.hir_id, init.span) {\n                 // Do not report duplicate errors for `let x = y`.\n@@ -1459,7 +1459,7 @@ impl<'a, 'b, 'tcx, 'v> Visitor<'v> for ObsoleteCheckTypeForPrivatenessVisitor<'a\n     }\n \n     // Don't want to recurse into `[, .. expr]`.\n-    fn visit_expr(&mut self, _: &hir::Expr) {}\n+    fn visit_expr(&mut self, _: &hir::Expr<'_>) {}\n }\n \n impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n@@ -1708,8 +1708,8 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n     // expression/block context can't possibly contain exported things.\n     // (Making them no-ops stops us from traversing the whole AST without\n     // having to be super careful about our `walk_...` calls above.)\n-    fn visit_block(&mut self, _: &'tcx hir::Block) {}\n-    fn visit_expr(&mut self, _: &'tcx hir::Expr) {}\n+    fn visit_block(&mut self, _: &'tcx hir::Block<'tcx>) {}\n+    fn visit_expr(&mut self, _: &'tcx hir::Expr<'tcx>) {}\n }\n \n ///////////////////////////////////////////////////////////////////////////////"}, {"sha": "8e0f5d17b9fb8652c2d13dbdc968c6f84c60d599", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/82840353726668c624e46627ac11a1fec18d6d09/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82840353726668c624e46627ac11a1fec18d6d09/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=82840353726668c624e46627ac11a1fec18d6d09", "patch": "@@ -2648,7 +2648,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n     }\n \n     /// Returns the `DefId` of the constant parameter that the provided expression is a path to.\n-    pub fn const_param_def_id(&self, expr: &hir::Expr) -> Option<DefId> {\n+    pub fn const_param_def_id(&self, expr: &hir::Expr<'_>) -> Option<DefId> {\n         // Unwrap a block, so that e.g. `{ P }` is recognised as a parameter. Const arguments\n         // currently have to be wrapped in curly brackets, so it's necessary to special-case.\n         let expr = match &expr.kind {"}, {"sha": "0d7ddd0fc48197b02334e9c9ea52e369271493f8", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 14, "deletions": 10, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/82840353726668c624e46627ac11a1fec18d6d09/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82840353726668c624e46627ac11a1fec18d6d09/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=82840353726668c624e46627ac11a1fec18d6d09", "patch": "@@ -10,9 +10,9 @@ use syntax_pos::Span;\n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub fn check_match(\n         &self,\n-        expr: &'tcx hir::Expr,\n-        discrim: &'tcx hir::Expr,\n-        arms: &'tcx [hir::Arm],\n+        expr: &'tcx hir::Expr<'tcx>,\n+        discrim: &'tcx hir::Expr<'tcx>,\n+        arms: &'tcx [hir::Arm<'tcx>],\n         expected: Expectation<'tcx>,\n         match_src: hir::MatchSource,\n     ) -> Ty<'tcx> {\n@@ -194,7 +194,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     /// When the previously checked expression (the scrutinee) diverges,\n     /// warn the user about the match arms being unreachable.\n-    fn warn_arms_when_scrutinee_diverges(&self, arms: &'tcx [hir::Arm], source: hir::MatchSource) {\n+    fn warn_arms_when_scrutinee_diverges(\n+        &self,\n+        arms: &'tcx [hir::Arm<'tcx>],\n+        source: hir::MatchSource,\n+    ) {\n         if self.diverges.get().is_always() {\n             use hir::MatchSource::*;\n             let msg = match source {\n@@ -214,8 +218,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     fn if_fallback_coercion(\n         &self,\n         span: Span,\n-        then_expr: &'tcx hir::Expr,\n-        coercion: &mut CoerceMany<'tcx, '_, rustc::hir::Arm>,\n+        then_expr: &'tcx hir::Expr<'tcx>,\n+        coercion: &mut CoerceMany<'tcx, '_, rustc::hir::Arm<'tcx>>,\n     ) -> bool {\n         // If this `if` expr is the parent's function return expr,\n         // the cause of the type coercion is the return type, point at it. (#25228)\n@@ -277,8 +281,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     fn if_cause(\n         &self,\n         span: Span,\n-        then_expr: &'tcx hir::Expr,\n-        else_expr: &'tcx hir::Expr,\n+        then_expr: &'tcx hir::Expr<'tcx>,\n+        else_expr: &'tcx hir::Expr<'tcx>,\n         then_ty: Ty<'tcx>,\n         else_ty: Ty<'tcx>,\n     ) -> ObligationCause<'tcx> {\n@@ -386,8 +390,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     fn demand_discriminant_type(\n         &self,\n-        arms: &'tcx [hir::Arm],\n-        discrim: &'tcx hir::Expr,\n+        arms: &'tcx [hir::Arm<'tcx>],\n+        discrim: &'tcx hir::Expr<'tcx>,\n     ) -> Ty<'tcx> {\n         // Not entirely obvious: if matches may create ref bindings, we want to\n         // use the *precise* type of the discriminant, *not* some supertype, as"}, {"sha": "116f5ffc2513d3725442b76cc991c4893d6bb64b", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/82840353726668c624e46627ac11a1fec18d6d09/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82840353726668c624e46627ac11a1fec18d6d09/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=82840353726668c624e46627ac11a1fec18d6d09", "patch": "@@ -39,9 +39,9 @@ enum CallStep<'tcx> {\n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub fn check_call(\n         &self,\n-        call_expr: &'tcx hir::Expr,\n-        callee_expr: &'tcx hir::Expr,\n-        arg_exprs: &'tcx [hir::Expr],\n+        call_expr: &'tcx hir::Expr<'tcx>,\n+        callee_expr: &'tcx hir::Expr<'tcx>,\n+        arg_exprs: &'tcx [hir::Expr<'tcx>],\n         expected: Expectation<'tcx>,\n     ) -> Ty<'tcx> {\n         let original_callee_ty = self.check_expr(callee_expr);\n@@ -81,9 +81,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     fn try_overloaded_call_step(\n         &self,\n-        call_expr: &'tcx hir::Expr,\n-        callee_expr: &'tcx hir::Expr,\n-        arg_exprs: &'tcx [hir::Expr],\n+        call_expr: &'tcx hir::Expr<'tcx>,\n+        callee_expr: &'tcx hir::Expr<'tcx>,\n+        arg_exprs: &'tcx [hir::Expr<'tcx>],\n         autoderef: &Autoderef<'a, 'tcx>,\n     ) -> Option<CallStep<'tcx>> {\n         let adjusted_ty = autoderef.unambiguous_final_ty(self);\n@@ -166,9 +166,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     fn try_overloaded_call_traits(\n         &self,\n-        call_expr: &hir::Expr,\n+        call_expr: &hir::Expr<'_>,\n         adjusted_ty: Ty<'tcx>,\n-        opt_arg_exprs: Option<&'tcx [hir::Expr]>,\n+        opt_arg_exprs: Option<&'tcx [hir::Expr<'tcx>]>,\n     ) -> Option<(Option<Adjustment<'tcx>>, MethodCallee<'tcx>)> {\n         // Try the options that are least restrictive on the caller first.\n         for &(opt_trait_def_id, method_name, borrow) in &[\n@@ -230,7 +230,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         &self,\n         err: &mut DiagnosticBuilder<'a>,\n         hir_id: hir::HirId,\n-        callee_node: &hir::ExprKind,\n+        callee_node: &hir::ExprKind<'_>,\n         callee_span: Span,\n     ) {\n         let hir_id = self.tcx.hir().get_parent_node(hir_id);\n@@ -253,9 +253,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     fn confirm_builtin_call(\n         &self,\n-        call_expr: &'tcx hir::Expr,\n+        call_expr: &'tcx hir::Expr<'tcx>,\n         callee_ty: Ty<'tcx>,\n-        arg_exprs: &'tcx [hir::Expr],\n+        arg_exprs: &'tcx [hir::Expr<'tcx>],\n         expected: Expectation<'tcx>,\n     ) -> Ty<'tcx> {\n         let (fn_sig, def_span) = match callee_ty.kind {\n@@ -403,8 +403,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     fn confirm_deferred_closure_call(\n         &self,\n-        call_expr: &'tcx hir::Expr,\n-        arg_exprs: &'tcx [hir::Expr],\n+        call_expr: &'tcx hir::Expr<'tcx>,\n+        arg_exprs: &'tcx [hir::Expr<'tcx>],\n         expected: Expectation<'tcx>,\n         fn_sig: ty::FnSig<'tcx>,\n     ) -> Ty<'tcx> {\n@@ -436,8 +436,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     fn confirm_overloaded_call(\n         &self,\n-        call_expr: &'tcx hir::Expr,\n-        arg_exprs: &'tcx [hir::Expr],\n+        call_expr: &'tcx hir::Expr<'tcx>,\n+        arg_exprs: &'tcx [hir::Expr<'tcx>],\n         expected: Expectation<'tcx>,\n         method_callee: MethodCallee<'tcx>,\n     ) -> Ty<'tcx> {\n@@ -457,8 +457,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n #[derive(Debug)]\n pub struct DeferredCallResolution<'tcx> {\n-    call_expr: &'tcx hir::Expr,\n-    callee_expr: &'tcx hir::Expr,\n+    call_expr: &'tcx hir::Expr<'tcx>,\n+    callee_expr: &'tcx hir::Expr<'tcx>,\n     adjusted_ty: Ty<'tcx>,\n     adjustments: Vec<Adjustment<'tcx>>,\n     fn_sig: ty::FnSig<'tcx>,"}, {"sha": "f82bb1a751ff836116e9474ec89e64dc2228385b", "filename": "src/librustc_typeck/check/cast.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/82840353726668c624e46627ac11a1fec18d6d09/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82840353726668c624e46627ac11a1fec18d6d09/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs?ref=82840353726668c624e46627ac11a1fec18d6d09", "patch": "@@ -51,7 +51,7 @@ use rustc_error_codes::*;\n /// Reifies a cast check to be checked once we have full type information for\n /// a function context.\n pub struct CastCheck<'tcx> {\n-    expr: &'tcx hir::Expr,\n+    expr: &'tcx hir::Expr<'tcx>,\n     expr_ty: Ty<'tcx>,\n     cast_ty: Ty<'tcx>,\n     cast_span: Span,\n@@ -193,7 +193,7 @@ fn make_invalid_casting_error<'a, 'tcx>(\n impl<'a, 'tcx> CastCheck<'tcx> {\n     pub fn new(\n         fcx: &FnCtxt<'a, 'tcx>,\n-        expr: &'tcx hir::Expr,\n+        expr: &'tcx hir::Expr<'tcx>,\n         expr_ty: Ty<'tcx>,\n         cast_ty: Ty<'tcx>,\n         cast_span: Span,"}, {"sha": "feb904ee71caed2323226753044fa5164107a0a0", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/82840353726668c624e46627ac11a1fec18d6d09/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82840353726668c624e46627ac11a1fec18d6d09/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=82840353726668c624e46627ac11a1fec18d6d09", "patch": "@@ -35,7 +35,7 @@ struct ClosureSignatures<'tcx> {\n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub fn check_expr_closure(\n         &self,\n-        expr: &hir::Expr,\n+        expr: &hir::Expr<'_>,\n         _capture: hir::CaptureBy,\n         decl: &'tcx hir::FnDecl,\n         body_id: hir::BodyId,\n@@ -57,7 +57,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     fn check_closure(\n         &self,\n-        expr: &hir::Expr,\n+        expr: &hir::Expr<'_>,\n         opt_kind: Option<ty::ClosureKind>,\n         decl: &'tcx hir::FnDecl,\n         body: &'tcx hir::Body<'tcx>,"}, {"sha": "1df6a495343a30641ddcdc09b178af17d292d23d", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/82840353726668c624e46627ac11a1fec18d6d09/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82840353726668c624e46627ac11a1fec18d6d09/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=82840353726668c624e46627ac11a1fec18d6d09", "patch": "@@ -805,7 +805,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// The expressions *must not* have any pre-existing adjustments.\n     pub fn try_coerce(\n         &self,\n-        expr: &hir::Expr,\n+        expr: &hir::Expr<'_>,\n         expr_ty: Ty<'tcx>,\n         target: Ty<'tcx>,\n         allow_two_phase: AllowTwoPhase,\n@@ -844,7 +844,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         cause: &ObligationCause<'tcx>,\n         exprs: &[E],\n         prev_ty: Ty<'tcx>,\n-        new: &hir::Expr,\n+        new: &hir::Expr<'_>,\n         new_ty: Ty<'tcx>,\n     ) -> RelateResult<'tcx, Ty<'tcx>>\n     where\n@@ -1020,10 +1020,10 @@ pub struct CoerceMany<'tcx, 'exprs, E: AsCoercionSite> {\n \n /// The type of a `CoerceMany` that is storing up the expressions into\n /// a buffer. We use this in `check/mod.rs` for things like `break`.\n-pub type DynamicCoerceMany<'tcx> = CoerceMany<'tcx, 'tcx, P<hir::Expr>>;\n+pub type DynamicCoerceMany<'tcx> = CoerceMany<'tcx, 'tcx, &'tcx hir::Expr<'tcx>>;\n \n enum Expressions<'tcx, 'exprs, E: AsCoercionSite> {\n-    Dynamic(Vec<&'tcx hir::Expr>),\n+    Dynamic(Vec<&'tcx hir::Expr<'tcx>>),\n     UpFront(&'exprs [E]),\n }\n \n@@ -1077,7 +1077,7 @@ impl<'tcx, 'exprs, E: AsCoercionSite> CoerceMany<'tcx, 'exprs, E> {\n         &mut self,\n         fcx: &FnCtxt<'a, 'tcx>,\n         cause: &ObligationCause<'tcx>,\n-        expression: &'tcx hir::Expr,\n+        expression: &'tcx hir::Expr<'tcx>,\n         expression_ty: Ty<'tcx>,\n     ) {\n         self.coerce_inner(fcx, cause, Some(expression), expression_ty, None, false)\n@@ -1119,7 +1119,7 @@ impl<'tcx, 'exprs, E: AsCoercionSite> CoerceMany<'tcx, 'exprs, E> {\n         &mut self,\n         fcx: &FnCtxt<'a, 'tcx>,\n         cause: &ObligationCause<'tcx>,\n-        expression: Option<&'tcx hir::Expr>,\n+        expression: Option<&'tcx hir::Expr<'tcx>>,\n         mut expression_ty: Ty<'tcx>,\n         augment_error: Option<&mut dyn FnMut(&mut DiagnosticBuilder<'_>)>,\n         label_expression_as_expected: bool,\n@@ -1298,7 +1298,7 @@ impl<'tcx, 'exprs, E: AsCoercionSite> CoerceMany<'tcx, 'exprs, E> {\n         ty_err: TypeError<'tcx>,\n         fcx: &FnCtxt<'a, 'tcx>,\n         id: hir::HirId,\n-        expression: Option<(&'tcx hir::Expr, hir::HirId)>,\n+        expression: Option<(&'tcx hir::Expr<'tcx>, hir::HirId)>,\n     ) -> DiagnosticBuilder<'a> {\n         let mut err = fcx.report_mismatched_types(cause, expected, found, ty_err);\n \n@@ -1368,17 +1368,17 @@ impl<'tcx, 'exprs, E: AsCoercionSite> CoerceMany<'tcx, 'exprs, E> {\n /// Something that can be converted into an expression to which we can\n /// apply a coercion.\n pub trait AsCoercionSite {\n-    fn as_coercion_site(&self) -> &hir::Expr;\n+    fn as_coercion_site(&self) -> &hir::Expr<'_>;\n }\n \n-impl AsCoercionSite for hir::Expr {\n-    fn as_coercion_site(&self) -> &hir::Expr {\n+impl AsCoercionSite for hir::Expr<'_> {\n+    fn as_coercion_site(&self) -> &hir::Expr<'_> {\n         self\n     }\n }\n \n-impl AsCoercionSite for P<hir::Expr> {\n-    fn as_coercion_site(&self) -> &hir::Expr {\n+impl AsCoercionSite for P<hir::Expr<'_>> {\n+    fn as_coercion_site(&self) -> &hir::Expr<'_> {\n         self\n     }\n }\n@@ -1387,19 +1387,19 @@ impl<'a, T> AsCoercionSite for &'a T\n where\n     T: AsCoercionSite,\n {\n-    fn as_coercion_site(&self) -> &hir::Expr {\n+    fn as_coercion_site(&self) -> &hir::Expr<'_> {\n         (**self).as_coercion_site()\n     }\n }\n \n impl AsCoercionSite for ! {\n-    fn as_coercion_site(&self) -> &hir::Expr {\n+    fn as_coercion_site(&self) -> &hir::Expr<'_> {\n         unreachable!()\n     }\n }\n \n-impl AsCoercionSite for hir::Arm {\n-    fn as_coercion_site(&self) -> &hir::Expr {\n+impl AsCoercionSite for hir::Arm<'_> {\n+    fn as_coercion_site(&self) -> &hir::Expr<'_> {\n         &self.body\n     }\n }"}, {"sha": "68f2943e9e1d25c1fd0b0562147434a6d7c5da29", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 16, "deletions": 12, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/82840353726668c624e46627ac11a1fec18d6d09/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82840353726668c624e46627ac11a1fec18d6d09/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=82840353726668c624e46627ac11a1fec18d6d09", "patch": "@@ -16,7 +16,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub fn emit_coerce_suggestions(\n         &self,\n         err: &mut DiagnosticBuilder<'_>,\n-        expr: &hir::Expr,\n+        expr: &hir::Expr<'_>,\n         expr_ty: Ty<'tcx>,\n         expected: Ty<'tcx>,\n     ) {\n@@ -110,7 +110,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     pub fn demand_coerce(\n         &self,\n-        expr: &hir::Expr,\n+        expr: &hir::Expr<'_>,\n         checked_ty: Ty<'tcx>,\n         expected: Ty<'tcx>,\n         allow_two_phase: AllowTwoPhase,\n@@ -129,7 +129,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     // diverges flag is currently \"always\".\n     pub fn demand_coerce_diag(\n         &self,\n-        expr: &hir::Expr,\n+        expr: &hir::Expr<'_>,\n         checked_ty: Ty<'tcx>,\n         expected: Ty<'tcx>,\n         allow_two_phase: AllowTwoPhase,\n@@ -157,7 +157,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         (expected, Some(err))\n     }\n \n-    fn annotate_expected_due_to_let_ty(&self, err: &mut DiagnosticBuilder<'_>, expr: &hir::Expr) {\n+    fn annotate_expected_due_to_let_ty(\n+        &self,\n+        err: &mut DiagnosticBuilder<'_>,\n+        expr: &hir::Expr<'_>,\n+    ) {\n         let parent = self.tcx.hir().get_parent_node(expr.hir_id);\n         if let Some(hir::Node::Local(hir::Local { ty: Some(ty), init: Some(init), .. })) =\n             self.tcx.hir().find(parent)\n@@ -170,7 +174,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     }\n \n     /// Returns whether the expected type is `bool` and the expression is `x = y`.\n-    pub fn is_assign_to_bool(&self, expr: &hir::Expr, expected: Ty<'tcx>) -> bool {\n+    pub fn is_assign_to_bool(&self, expr: &hir::Expr<'_>, expected: Ty<'tcx>) -> bool {\n         if let hir::ExprKind::Assign(..) = expr.kind {\n             return expected == self.tcx.types.bool;\n         }\n@@ -182,7 +186,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     fn suggest_compatible_variants(\n         &self,\n         err: &mut DiagnosticBuilder<'_>,\n-        expr: &hir::Expr,\n+        expr: &hir::Expr<'_>,\n         expected: Ty<'tcx>,\n         expr_ty: Ty<'tcx>,\n     ) {\n@@ -282,7 +286,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// ```\n     /// opt.map(|param| { takes_ref(param) });\n     /// ```\n-    fn can_use_as_ref(&self, expr: &hir::Expr) -> Option<(Span, &'static str, String)> {\n+    fn can_use_as_ref(&self, expr: &hir::Expr<'_>) -> Option<(Span, &'static str, String)> {\n         let path = match expr.kind {\n             hir::ExprKind::Path(hir::QPath::Resolved(_, ref path)) => path,\n             _ => return None,\n@@ -352,7 +356,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             if let Node::Expr(hir::Expr { kind: hir::ExprKind::Struct(_, fields, ..), .. }) = parent\n             {\n                 if let Ok(src) = cm.span_to_snippet(sp) {\n-                    for field in fields {\n+                    for field in *fields {\n                         if field.ident.as_str() == src && field.is_shorthand {\n                             return true;\n                         }\n@@ -381,7 +385,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// `&mut`!\".\n     pub fn check_ref(\n         &self,\n-        expr: &hir::Expr,\n+        expr: &hir::Expr<'_>,\n         checked_ty: Ty<'tcx>,\n         expected: Ty<'tcx>,\n     ) -> Option<(Span, &'static str, String)> {\n@@ -605,7 +609,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub fn check_for_cast(\n         &self,\n         err: &mut DiagnosticBuilder<'_>,\n-        expr: &hir::Expr,\n+        expr: &hir::Expr<'_>,\n         checked_ty: Ty<'tcx>,\n         expected_ty: Ty<'tcx>,\n     ) -> bool {\n@@ -635,7 +639,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         })) = self.tcx.hir().find(self.tcx.hir().get_parent_node(expr.hir_id))\n         {\n             // `expr` is a literal field for a struct, only suggest if appropriate\n-            for field in fields {\n+            for field in *fields {\n                 if field.expr.hir_id == expr.hir_id && field.is_shorthand {\n                     // This is a field literal\n                     prefix = format!(\"{}: \", field.ident);\n@@ -728,7 +732,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 expected_ty,\n                 if needs_paren { \")\" } else { \"\" },\n             );\n-            let literal_is_ty_suffixed = |expr: &hir::Expr| {\n+            let literal_is_ty_suffixed = |expr: &hir::Expr<'_>| {\n                 if let hir::ExprKind::Lit(lit) = &expr.kind {\n                     lit.node.is_suffixed()\n                 } else {"}, {"sha": "4da4ce7680bf54f0d25cb5e932d0634d9a33c60f", "filename": "src/librustc_typeck/check/expr.rs", "status": "modified", "additions": 68, "deletions": 65, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/82840353726668c624e46627ac11a1fec18d6d09/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82840353726668c624e46627ac11a1fec18d6d09/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs?ref=82840353726668c624e46627ac11a1fec18d6d09", "patch": "@@ -21,7 +21,6 @@ use errors::{pluralize, Applicability, DiagnosticBuilder, DiagnosticId};\n use rustc::hir;\n use rustc::hir::def::{CtorKind, DefKind, Res};\n use rustc::hir::def_id::DefId;\n-use rustc::hir::ptr::P;\n use rustc::hir::{ExprKind, QPath};\n use rustc::infer;\n use rustc::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n@@ -43,14 +42,14 @@ use rustc_error_codes::*;\n use std::fmt::Display;\n \n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n-    fn check_expr_eq_type(&self, expr: &'tcx hir::Expr, expected: Ty<'tcx>) {\n+    fn check_expr_eq_type(&self, expr: &'tcx hir::Expr<'tcx>, expected: Ty<'tcx>) {\n         let ty = self.check_expr_with_hint(expr, expected);\n         self.demand_eqtype(expr.span, expected, ty);\n     }\n \n     pub fn check_expr_has_type_or_error(\n         &self,\n-        expr: &'tcx hir::Expr,\n+        expr: &'tcx hir::Expr<'tcx>,\n         expected: Ty<'tcx>,\n         extend_err: impl Fn(&mut DiagnosticBuilder<'_>),\n     ) -> Ty<'tcx> {\n@@ -59,7 +58,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     fn check_expr_meets_expectation_or_error(\n         &self,\n-        expr: &'tcx hir::Expr,\n+        expr: &'tcx hir::Expr<'tcx>,\n         expected: Expectation<'tcx>,\n         extend_err: impl Fn(&mut DiagnosticBuilder<'_>),\n     ) -> Ty<'tcx> {\n@@ -96,7 +95,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     pub(super) fn check_expr_coercable_to_type(\n         &self,\n-        expr: &'tcx hir::Expr,\n+        expr: &'tcx hir::Expr<'tcx>,\n         expected: Ty<'tcx>,\n     ) -> Ty<'tcx> {\n         let ty = self.check_expr_with_hint(expr, expected);\n@@ -106,25 +105,29 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     pub(super) fn check_expr_with_hint(\n         &self,\n-        expr: &'tcx hir::Expr,\n+        expr: &'tcx hir::Expr<'tcx>,\n         expected: Ty<'tcx>,\n     ) -> Ty<'tcx> {\n         self.check_expr_with_expectation(expr, ExpectHasType(expected))\n     }\n \n     pub(super) fn check_expr_with_expectation(\n         &self,\n-        expr: &'tcx hir::Expr,\n+        expr: &'tcx hir::Expr<'tcx>,\n         expected: Expectation<'tcx>,\n     ) -> Ty<'tcx> {\n         self.check_expr_with_expectation_and_needs(expr, expected, Needs::None)\n     }\n \n-    pub(super) fn check_expr(&self, expr: &'tcx hir::Expr) -> Ty<'tcx> {\n+    pub(super) fn check_expr(&self, expr: &'tcx hir::Expr<'tcx>) -> Ty<'tcx> {\n         self.check_expr_with_expectation(expr, NoExpectation)\n     }\n \n-    pub(super) fn check_expr_with_needs(&self, expr: &'tcx hir::Expr, needs: Needs) -> Ty<'tcx> {\n+    pub(super) fn check_expr_with_needs(\n+        &self,\n+        expr: &'tcx hir::Expr<'tcx>,\n+        needs: Needs,\n+    ) -> Ty<'tcx> {\n         self.check_expr_with_expectation_and_needs(expr, NoExpectation, needs)\n     }\n \n@@ -140,7 +143,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// that when err needs to be handled differently.\n     fn check_expr_with_expectation_and_needs(\n         &self,\n-        expr: &'tcx hir::Expr,\n+        expr: &'tcx hir::Expr<'tcx>,\n         expected: Expectation<'tcx>,\n         needs: Needs,\n     ) -> Ty<'tcx> {\n@@ -208,7 +211,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     fn check_expr_kind(\n         &self,\n-        expr: &'tcx hir::Expr,\n+        expr: &'tcx hir::Expr<'tcx>,\n         expected: Expectation<'tcx>,\n         needs: Needs,\n     ) -> Ty<'tcx> {\n@@ -274,7 +277,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 self.check_expr_repeat(element, count, expected, expr)\n             }\n             ExprKind::Tup(ref elts) => self.check_expr_tuple(elts, expected, expr),\n-            ExprKind::Struct(ref qpath, ref fields, ref base_expr) => {\n+            ExprKind::Struct(ref qpath, fields, ref base_expr) => {\n                 self.check_expr_struct(expr, expected, qpath, fields, base_expr)\n             }\n             ExprKind::Field(ref base, field) => self.check_field(expr, needs, &base, field),\n@@ -284,7 +287,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n-    fn check_expr_box(&self, expr: &'tcx hir::Expr, expected: Expectation<'tcx>) -> Ty<'tcx> {\n+    fn check_expr_box(&self, expr: &'tcx hir::Expr<'tcx>, expected: Expectation<'tcx>) -> Ty<'tcx> {\n         let expected_inner = expected.to_option(self).map_or(NoExpectation, |ty| match ty.kind {\n             ty::Adt(def, _) if def.is_box() => Expectation::rvalue_hint(self, ty.boxed_ty()),\n             _ => NoExpectation,\n@@ -296,10 +299,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     fn check_expr_unary(\n         &self,\n         unop: hir::UnOp,\n-        oprnd: &'tcx hir::Expr,\n+        oprnd: &'tcx hir::Expr<'tcx>,\n         expected: Expectation<'tcx>,\n         needs: Needs,\n-        expr: &'tcx hir::Expr,\n+        expr: &'tcx hir::Expr<'tcx>,\n     ) -> Ty<'tcx> {\n         let tcx = self.tcx;\n         let expected_inner = match unop {\n@@ -382,9 +385,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         &self,\n         kind: hir::BorrowKind,\n         mutbl: hir::Mutability,\n-        oprnd: &'tcx hir::Expr,\n+        oprnd: &'tcx hir::Expr<'tcx>,\n         expected: Expectation<'tcx>,\n-        expr: &'tcx hir::Expr,\n+        expr: &'tcx hir::Expr<'tcx>,\n     ) -> Ty<'tcx> {\n         let hint = expected.only_has_type(self).map_or(NoExpectation, |ty| {\n             match ty.kind {\n@@ -437,7 +440,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// * Contains a dereference\n     /// Note that the adjustments for the children of `expr` should already\n     /// have been resolved.\n-    fn check_named_place_expr(&self, oprnd: &'tcx hir::Expr) {\n+    fn check_named_place_expr(&self, oprnd: &'tcx hir::Expr<'tcx>) {\n         let is_named = oprnd.is_place_expr(|base| {\n             // Allow raw borrows if there are any deref adjustments.\n             //\n@@ -466,7 +469,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n-    fn check_expr_path(&self, qpath: &hir::QPath, expr: &'tcx hir::Expr) -> Ty<'tcx> {\n+    fn check_expr_path(&self, qpath: &hir::QPath, expr: &'tcx hir::Expr<'tcx>) -> Ty<'tcx> {\n         let tcx = self.tcx;\n         let (res, opt_ty, segs) = self.resolve_ty_and_res_ufcs(qpath, expr.hir_id, expr.span);\n         let ty = match res {\n@@ -538,8 +541,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     fn check_expr_break(\n         &self,\n         destination: hir::Destination,\n-        expr_opt: Option<&'tcx hir::Expr>,\n-        expr: &'tcx hir::Expr,\n+        expr_opt: Option<&'tcx hir::Expr<'tcx>>,\n+        expr: &'tcx hir::Expr<'tcx>,\n     ) -> Ty<'tcx> {\n         let tcx = self.tcx;\n         if let Ok(target_id) = destination.target_id {\n@@ -669,8 +672,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     fn check_expr_return(\n         &self,\n-        expr_opt: Option<&'tcx hir::Expr>,\n-        expr: &'tcx hir::Expr,\n+        expr_opt: Option<&'tcx hir::Expr<'tcx>>,\n+        expr: &'tcx hir::Expr<'tcx>,\n     ) -> Ty<'tcx> {\n         if self.ret_coercion.is_none() {\n             struct_span_err!(\n@@ -710,7 +713,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         self.tcx.types.never\n     }\n \n-    pub(super) fn check_return_expr(&self, return_expr: &'tcx hir::Expr) {\n+    pub(super) fn check_return_expr(&self, return_expr: &'tcx hir::Expr<'tcx>) {\n         let ret_coercion = self.ret_coercion.as_ref().unwrap_or_else(|| {\n             span_bug!(return_expr.span, \"check_return_expr called outside fn body\")\n         });\n@@ -725,7 +728,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         );\n     }\n \n-    fn is_destructuring_place_expr(&self, expr: &'tcx hir::Expr) -> bool {\n+    fn is_destructuring_place_expr(&self, expr: &'tcx hir::Expr<'tcx>) -> bool {\n         match &expr.kind {\n             ExprKind::Array(comps) | ExprKind::Tup(comps) => {\n                 comps.iter().all(|e| self.is_destructuring_place_expr(e))\n@@ -740,7 +743,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     pub(crate) fn check_lhs_assignable(\n         &self,\n-        lhs: &'tcx hir::Expr,\n+        lhs: &'tcx hir::Expr<'tcx>,\n         err_code: &'static str,\n         expr_span: &Span,\n     ) {\n@@ -763,10 +766,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// The expected type is `()` and is passsed to the function for the purposes of diagnostics.\n     fn check_expr_assign(\n         &self,\n-        expr: &'tcx hir::Expr,\n+        expr: &'tcx hir::Expr<'tcx>,\n         expected: Expectation<'tcx>,\n-        lhs: &'tcx hir::Expr,\n-        rhs: &'tcx hir::Expr,\n+        lhs: &'tcx hir::Expr<'tcx>,\n+        rhs: &'tcx hir::Expr<'tcx>,\n         span: &Span,\n     ) -> Ty<'tcx> {\n         let lhs_ty = self.check_expr_with_needs(&lhs, Needs::MutPlace);\n@@ -804,10 +807,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     fn check_expr_loop(\n         &self,\n-        body: &'tcx hir::Block,\n+        body: &'tcx hir::Block<'tcx>,\n         source: hir::LoopSource,\n         expected: Expectation<'tcx>,\n-        expr: &'tcx hir::Expr,\n+        expr: &'tcx hir::Expr<'tcx>,\n     ) -> Ty<'tcx> {\n         let coerce = match source {\n             // you can only use break with a value from a normal `loop { }`\n@@ -849,10 +852,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// Checks a method call.\n     fn check_method_call(\n         &self,\n-        expr: &'tcx hir::Expr,\n+        expr: &'tcx hir::Expr<'tcx>,\n         segment: &hir::PathSegment,\n         span: Span,\n-        args: &'tcx [hir::Expr],\n+        args: &'tcx [hir::Expr<'tcx>],\n         expected: Expectation<'tcx>,\n         needs: Needs,\n     ) -> Ty<'tcx> {\n@@ -892,7 +895,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         &self,\n         segment: &hir::PathSegment,\n         span: Span,\n-        args: &'tcx [hir::Expr],\n+        args: &'tcx [hir::Expr<'tcx>],\n         rcvr_t: Ty<'tcx>,\n         error: MethodError<'tcx>,\n     ) {\n@@ -937,9 +940,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     fn check_expr_cast(\n         &self,\n-        e: &'tcx hir::Expr,\n+        e: &'tcx hir::Expr<'tcx>,\n         t: &'tcx hir::Ty,\n-        expr: &'tcx hir::Expr,\n+        expr: &'tcx hir::Expr<'tcx>,\n     ) -> Ty<'tcx> {\n         // Find the type of `e`. Supply hints based on the type we are casting to,\n         // if appropriate.\n@@ -966,9 +969,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     fn check_expr_array(\n         &self,\n-        args: &'tcx [hir::Expr],\n+        args: &'tcx [hir::Expr<'tcx>],\n         expected: Expectation<'tcx>,\n-        expr: &'tcx hir::Expr,\n+        expr: &'tcx hir::Expr<'tcx>,\n     ) -> Ty<'tcx> {\n         let uty = expected.to_option(self).and_then(|uty| match uty.kind {\n             ty::Array(ty, _) | ty::Slice(ty) => Some(ty),\n@@ -1001,10 +1004,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     fn check_expr_repeat(\n         &self,\n-        element: &'tcx hir::Expr,\n+        element: &'tcx hir::Expr<'tcx>,\n         count: &'tcx hir::AnonConst,\n         expected: Expectation<'tcx>,\n-        _expr: &'tcx hir::Expr,\n+        _expr: &'tcx hir::Expr<'tcx>,\n     ) -> Ty<'tcx> {\n         let tcx = self.tcx;\n         let count_def_id = tcx.hir().local_def_id(count.hir_id);\n@@ -1048,9 +1051,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     fn check_expr_tuple(\n         &self,\n-        elts: &'tcx [hir::Expr],\n+        elts: &'tcx [hir::Expr<'tcx>],\n         expected: Expectation<'tcx>,\n-        expr: &'tcx hir::Expr,\n+        expr: &'tcx hir::Expr<'tcx>,\n     ) -> Ty<'tcx> {\n         let flds = expected.only_has_type(self).and_then(|ty| {\n             let ty = self.resolve_vars_with_obligations(ty);\n@@ -1082,11 +1085,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     fn check_expr_struct(\n         &self,\n-        expr: &hir::Expr,\n+        expr: &hir::Expr<'_>,\n         expected: Expectation<'tcx>,\n         qpath: &QPath,\n-        fields: &'tcx [hir::Field],\n-        base_expr: &'tcx Option<P<hir::Expr>>,\n+        fields: &'tcx [hir::Field<'tcx>],\n+        base_expr: &'tcx Option<&'tcx hir::Expr<'tcx>>,\n     ) -> Ty<'tcx> {\n         // Find the relevant variant\n         let (variant, adt_ty) = if let Some(variant_ty) = self.check_struct_path(qpath, expr.hir_id)\n@@ -1170,7 +1173,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         expr_id: hir::HirId,\n         span: Span,\n         variant: &'tcx ty::VariantDef,\n-        ast_fields: &'tcx [hir::Field],\n+        ast_fields: &'tcx [hir::Field<'tcx>],\n         check_completeness: bool,\n     ) -> bool {\n         let tcx = self.tcx;\n@@ -1288,8 +1291,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     fn check_struct_fields_on_error(\n         &self,\n-        fields: &'tcx [hir::Field],\n-        base_expr: &'tcx Option<P<hir::Expr>>,\n+        fields: &'tcx [hir::Field<'tcx>],\n+        base_expr: &'tcx Option<&'tcx hir::Expr<'tcx>>,\n     ) {\n         for field in fields {\n             self.check_expr(&field.expr);\n@@ -1303,8 +1306,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         &self,\n         ty: Ty<'tcx>,\n         variant: &'tcx ty::VariantDef,\n-        field: &hir::Field,\n-        skip_fields: &[hir::Field],\n+        field: &hir::Field<'_>,\n+        skip_fields: &[hir::Field<'_>],\n         kind_name: &str,\n         ty_span: Span,\n     ) {\n@@ -1441,9 +1444,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     // Check field access expressions\n     fn check_field(\n         &self,\n-        expr: &'tcx hir::Expr,\n+        expr: &'tcx hir::Expr<'tcx>,\n         needs: Needs,\n-        base: &'tcx hir::Expr,\n+        base: &'tcx hir::Expr<'tcx>,\n         field: ast::Ident,\n     ) -> Ty<'tcx> {\n         let expr_t = self.check_expr_with_needs(base, needs);\n@@ -1522,8 +1525,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     fn ban_nonexisting_field(\n         &self,\n         field: ast::Ident,\n-        base: &'tcx hir::Expr,\n-        expr: &'tcx hir::Expr,\n+        base: &'tcx hir::Expr<'tcx>,\n+        expr: &'tcx hir::Expr<'tcx>,\n         expr_t: Ty<'tcx>,\n     ) {\n         let mut err = self.no_such_field_err(field.span, field, expr_t);\n@@ -1557,7 +1560,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     fn ban_private_field_access(\n         &self,\n-        expr: &hir::Expr,\n+        expr: &hir::Expr<'_>,\n         expr_t: Ty<'tcx>,\n         field: ast::Ident,\n         base_did: DefId,\n@@ -1590,7 +1593,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         err.emit();\n     }\n \n-    fn ban_take_value_of_method(&self, expr: &hir::Expr, expr_t: Ty<'tcx>, field: ast::Ident) {\n+    fn ban_take_value_of_method(&self, expr: &hir::Expr<'_>, expr_t: Ty<'tcx>, field: ast::Ident) {\n         let mut err = type_error_struct!(\n             self.tcx().sess,\n             field.span,\n@@ -1664,8 +1667,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     fn maybe_suggest_array_indexing(\n         &self,\n         err: &mut DiagnosticBuilder<'_>,\n-        expr: &hir::Expr,\n-        base: &hir::Expr,\n+        expr: &hir::Expr<'_>,\n+        base: &hir::Expr<'_>,\n         field: ast::Ident,\n         len: &ty::Const<'tcx>,\n     ) {\n@@ -1692,8 +1695,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     fn suggest_first_deref_field(\n         &self,\n         err: &mut DiagnosticBuilder<'_>,\n-        expr: &hir::Expr,\n-        base: &hir::Expr,\n+        expr: &hir::Expr<'_>,\n+        base: &hir::Expr<'_>,\n         field: ast::Ident,\n     ) {\n         let base = self\n@@ -1726,10 +1729,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     fn check_expr_index(\n         &self,\n-        base: &'tcx hir::Expr,\n-        idx: &'tcx hir::Expr,\n+        base: &'tcx hir::Expr<'tcx>,\n+        idx: &'tcx hir::Expr<'tcx>,\n         needs: Needs,\n-        expr: &'tcx hir::Expr,\n+        expr: &'tcx hir::Expr<'tcx>,\n     ) -> Ty<'tcx> {\n         let base_t = self.check_expr_with_needs(&base, needs);\n         let idx_t = self.check_expr(&idx);\n@@ -1790,8 +1793,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     fn check_expr_yield(\n         &self,\n-        value: &'tcx hir::Expr,\n-        expr: &'tcx hir::Expr,\n+        value: &'tcx hir::Expr<'tcx>,\n+        expr: &'tcx hir::Expr<'tcx>,\n         src: &'tcx hir::YieldSource,\n     ) -> Ty<'tcx> {\n         match self.yield_ty {"}, {"sha": "3069f1b1d77d40444ed6fa4bff80e2459ed7b819", "filename": "src/librustc_typeck/check/generator_interior.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/82840353726668c624e46627ac11a1fec18d6d09/src%2Flibrustc_typeck%2Fcheck%2Fgenerator_interior.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82840353726668c624e46627ac11a1fec18d6d09/src%2Flibrustc_typeck%2Fcheck%2Fgenerator_interior.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fgenerator_interior.rs?ref=82840353726668c624e46627ac11a1fec18d6d09", "patch": "@@ -27,7 +27,7 @@ impl<'a, 'tcx> InteriorVisitor<'a, 'tcx> {\n         &mut self,\n         ty: Ty<'tcx>,\n         scope: Option<region::Scope>,\n-        expr: Option<&'tcx Expr>,\n+        expr: Option<&'tcx Expr<'tcx>>,\n         source_span: Span,\n     ) {\n         use syntax_pos::DUMMY_SP;\n@@ -196,7 +196,7 @@ impl<'a, 'tcx> Visitor<'tcx> for InteriorVisitor<'a, 'tcx> {\n         NestedVisitorMap::None\n     }\n \n-    fn visit_pat(&mut self, pat: &'tcx Pat) {\n+    fn visit_pat(&mut self, pat: &'tcx Pat<'tcx>) {\n         intravisit::walk_pat(self, pat);\n \n         self.expr_count += 1;\n@@ -208,7 +208,7 @@ impl<'a, 'tcx> Visitor<'tcx> for InteriorVisitor<'a, 'tcx> {\n         }\n     }\n \n-    fn visit_expr(&mut self, expr: &'tcx Expr) {\n+    fn visit_expr(&mut self, expr: &'tcx Expr<'tcx>) {\n         let scope = self.region_scope_tree.temporary_scope(expr.hir_id.local_id);\n \n         match &expr.kind {\n@@ -227,7 +227,7 @@ impl<'a, 'tcx> Visitor<'tcx> for InteriorVisitor<'a, 'tcx> {\n                             self.expr_count += 1;\n \n                             // Record the rest of the call expression normally.\n-                            for arg in args {\n+                            for arg in *args {\n                                 self.visit_expr(arg);\n                             }\n                         }"}, {"sha": "98645b3463ef79ae358ea96925fb64a2926336ad", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/82840353726668c624e46627ac11a1fec18d6d09/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82840353726668c624e46627ac11a1fec18d6d09/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=82840353726668c624e46627ac11a1fec18d6d09", "patch": "@@ -19,8 +19,8 @@ use std::ops::Deref;\n struct ConfirmContext<'a, 'tcx> {\n     fcx: &'a FnCtxt<'a, 'tcx>,\n     span: Span,\n-    self_expr: &'tcx hir::Expr,\n-    call_expr: &'tcx hir::Expr,\n+    self_expr: &'tcx hir::Expr<'tcx>,\n+    call_expr: &'tcx hir::Expr<'tcx>,\n }\n \n impl<'a, 'tcx> Deref for ConfirmContext<'a, 'tcx> {\n@@ -39,8 +39,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub fn confirm_method(\n         &self,\n         span: Span,\n-        self_expr: &'tcx hir::Expr,\n-        call_expr: &'tcx hir::Expr,\n+        self_expr: &'tcx hir::Expr<'tcx>,\n+        call_expr: &'tcx hir::Expr<'tcx>,\n         unadjusted_self_ty: Ty<'tcx>,\n         pick: probe::Pick<'tcx>,\n         segment: &hir::PathSegment,\n@@ -59,8 +59,8 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n     fn new(\n         fcx: &'a FnCtxt<'a, 'tcx>,\n         span: Span,\n-        self_expr: &'tcx hir::Expr,\n-        call_expr: &'tcx hir::Expr,\n+        self_expr: &'tcx hir::Expr<'tcx>,\n+        call_expr: &'tcx hir::Expr<'tcx>,\n     ) -> ConfirmContext<'a, 'tcx> {\n         ConfirmContext { fcx, span, self_expr, call_expr }\n     }\n@@ -482,8 +482,8 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n     fn convert_place_op_to_mutable(\n         &self,\n         op: PlaceOp,\n-        expr: &hir::Expr,\n-        base_expr: &hir::Expr,\n+        expr: &hir::Expr<'_>,\n+        base_expr: &hir::Expr<'_>,\n         arg_tys: &[Ty<'tcx>],\n     ) {\n         debug!(\"convert_place_op_to_mutable({:?}, {:?}, {:?}, {:?})\", op, expr, base_expr, arg_tys);"}, {"sha": "41fd8d46346fd9a937af2f241b63752050ac0eaa", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/82840353726668c624e46627ac11a1fec18d6d09/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82840353726668c624e46627ac11a1fec18d6d09/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=82840353726668c624e46627ac11a1fec18d6d09", "patch": "@@ -180,8 +180,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         self_ty: Ty<'tcx>,\n         segment: &hir::PathSegment,\n         span: Span,\n-        call_expr: &'tcx hir::Expr,\n-        self_expr: &'tcx hir::Expr,\n+        call_expr: &'tcx hir::Expr<'tcx>,\n+        self_expr: &'tcx hir::Expr<'tcx>,\n     ) -> Result<MethodCallee<'tcx>, MethodError<'tcx>> {\n         debug!(\n             \"lookup(method_name={}, self_ty={:?}, call_expr={:?}, self_expr={:?})\",\n@@ -260,7 +260,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         span: Span,\n         method_name: ast::Ident,\n         self_ty: Ty<'tcx>,\n-        call_expr: &'tcx hir::Expr,\n+        call_expr: &'tcx hir::Expr<'tcx>,\n         scope: ProbeScope,\n     ) -> probe::PickResult<'tcx> {\n         let mode = probe::Mode::MethodCall;"}, {"sha": "f19e8c9ab1c78218e973833b572b9d8bd64bbd55", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/82840353726668c624e46627ac11a1fec18d6d09/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82840353726668c624e46627ac11a1fec18d6d09/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=82840353726668c624e46627ac11a1fec18d6d09", "patch": "@@ -72,7 +72,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         item_name: ast::Ident,\n         source: SelfSource<'b>,\n         error: MethodError<'tcx>,\n-        args: Option<&'tcx [hir::Expr]>,\n+        args: Option<&'tcx [hir::Expr<'tcx>]>,\n     ) -> Option<DiagnosticBuilder<'_>> {\n         let orig_span = span;\n         let mut span = span;\n@@ -954,7 +954,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n #[derive(Copy, Clone)]\n pub enum SelfSource<'a> {\n     QPath(&'a hir::Ty),\n-    MethodCall(&'a hir::Expr /* rcvr */),\n+    MethodCall(&'a hir::Expr<'a> /* rcvr */),\n }\n \n #[derive(Copy, Clone)]\n@@ -1131,7 +1131,7 @@ impl hir::intravisit::Visitor<'tcx> for UsePlacementFinder<'tcx> {\n \n fn print_disambiguation_help(\n     item_name: ast::Ident,\n-    args: Option<&'tcx [hir::Expr]>,\n+    args: Option<&'tcx [hir::Expr<'tcx>]>,\n     err: &mut DiagnosticBuilder<'_>,\n     trait_name: String,\n     rcvr_ty: Ty<'_>,"}, {"sha": "f8e494a6ccdd655e158284248008e579c30b1774", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 42, "deletions": 34, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/82840353726668c624e46627ac11a1fec18d6d09/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82840353726668c624e46627ac11a1fec18d6d09/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=82840353726668c624e46627ac11a1fec18d6d09", "patch": "@@ -95,7 +95,6 @@ use rustc::hir::def::{CtorOf, DefKind, Res};\n use rustc::hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n use rustc::hir::intravisit::{self, NestedVisitorMap, Visitor};\n use rustc::hir::itemlikevisit::ItemLikeVisitor;\n-use rustc::hir::ptr::P;\n use rustc::hir::{self, ExprKind, GenericArg, ItemKind, Node, PatKind, QPath};\n use rustc::infer::canonical::{Canonical, OriginalQueryValues, QueryResponse};\n use rustc::infer::error_reporting::TypeAnnotationNeeded::E0282;\n@@ -390,7 +389,7 @@ impl UnsafetyState {\n         UnsafetyState { def, unsafety, unsafe_push_count: 0, from_fn: true }\n     }\n \n-    pub fn recurse(&mut self, blk: &hir::Block) -> UnsafetyState {\n+    pub fn recurse(&mut self, blk: &hir::Block<'_>) -> UnsafetyState {\n         match self.unsafety {\n             // If this unsafe, then if the outer function was already marked as\n             // unsafe we shouldn't attribute the unsafe'ness to the block. This\n@@ -1136,7 +1135,7 @@ impl<'a, 'tcx> Visitor<'tcx> for GatherLocalsVisitor<'a, 'tcx> {\n     }\n \n     // Add explicitly-declared locals.\n-    fn visit_local(&mut self, local: &'tcx hir::Local) {\n+    fn visit_local(&mut self, local: &'tcx hir::Local<'tcx>) {\n         let local_ty = match local.ty {\n             Some(ref ty) => {\n                 let o_ty = self.fcx.to_ty(&ty);\n@@ -1174,7 +1173,7 @@ impl<'a, 'tcx> Visitor<'tcx> for GatherLocalsVisitor<'a, 'tcx> {\n     }\n \n     // Add pattern bindings.\n-    fn visit_pat(&mut self, p: &'tcx hir::Pat) {\n+    fn visit_pat(&mut self, p: &'tcx hir::Pat<'tcx>) {\n         if let PatKind::Binding(_, _, ident, _) = p.kind {\n             let var_ty = self.assign(p.span, p.hir_id, None);\n \n@@ -2934,7 +2933,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n-    pub fn apply_adjustments(&self, expr: &hir::Expr, adj: Vec<Adjustment<'tcx>>) {\n+    pub fn apply_adjustments(&self, expr: &hir::Expr<'_>, adj: Vec<Adjustment<'tcx>>) {\n         debug!(\"apply_adjustments(expr={:?}, adj={:?})\", expr, adj);\n \n         if adj.is_empty() {\n@@ -3181,7 +3180,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     }\n \n     /// Registers obligations that all types appearing in `substs` are well-formed.\n-    pub fn add_wf_bounds(&self, substs: SubstsRef<'tcx>, expr: &hir::Expr) {\n+    pub fn add_wf_bounds(&self, substs: SubstsRef<'tcx>, expr: &hir::Expr<'_>) {\n         for ty in substs.types() {\n             if !ty.references_error() {\n                 self.register_wf_obligation(ty, expr.span, traits::MiscObligation);\n@@ -3362,8 +3361,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     fn lookup_indexing(\n         &self,\n-        expr: &hir::Expr,\n-        base_expr: &'tcx hir::Expr,\n+        expr: &hir::Expr<'_>,\n+        base_expr: &'tcx hir::Expr<'tcx>,\n         base_ty: Ty<'tcx>,\n         idx_ty: Ty<'tcx>,\n         needs: Needs,\n@@ -3388,8 +3387,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// is implemented by `lookup_indexing`.\n     fn try_index_step(\n         &self,\n-        expr: &hir::Expr,\n-        base_expr: &hir::Expr,\n+        expr: &hir::Expr<'_>,\n+        base_expr: &hir::Expr<'_>,\n         autoderef: &Autoderef<'a, 'tcx>,\n         needs: Needs,\n         index_ty: Ty<'tcx>,\n@@ -3513,9 +3512,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     fn check_method_argument_types(\n         &self,\n         sp: Span,\n-        expr: &'tcx hir::Expr,\n+        expr: &'tcx hir::Expr<'tcx>,\n         method: Result<MethodCallee<'tcx>, ()>,\n-        args_no_rcvr: &'tcx [hir::Expr],\n+        args_no_rcvr: &'tcx [hir::Expr<'tcx>],\n         tuple_arguments: TupleArgumentsFlag,\n         expected: Expectation<'tcx>,\n     ) -> Ty<'tcx> {\n@@ -3641,10 +3640,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     fn check_argument_types(\n         &self,\n         sp: Span,\n-        expr: &'tcx hir::Expr,\n+        expr: &'tcx hir::Expr<'tcx>,\n         fn_inputs: &[Ty<'tcx>],\n         expected_arg_tys: &[Ty<'tcx>],\n-        args: &'tcx [hir::Expr],\n+        args: &'tcx [hir::Expr<'tcx>],\n         c_variadic: bool,\n         tuple_arguments: TupleArgumentsFlag,\n         def_span: Option<Span>,\n@@ -3897,7 +3896,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         errors: &mut Vec<traits::FulfillmentError<'_>>,\n         final_arg_types: &[(usize, Ty<'tcx>, Ty<'tcx>)],\n         call_sp: Span,\n-        args: &'tcx [hir::Expr],\n+        args: &'tcx [hir::Expr<'tcx>],\n     ) {\n         // We *do not* do this for desugared call spans to keep good diagnostics when involving\n         // the `?` operator.\n@@ -3951,7 +3950,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     fn point_at_type_arg_instead_of_call_if_possible(\n         &self,\n         errors: &mut Vec<traits::FulfillmentError<'_>>,\n-        call_expr: &'tcx hir::Expr,\n+        call_expr: &'tcx hir::Expr<'tcx>,\n     ) {\n         if let hir::ExprKind::Call(path, _) = &call_expr.kind {\n             if let hir::ExprKind::Path(qpath) = &path.kind {\n@@ -4248,8 +4247,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     pub fn check_decl_initializer(\n         &self,\n-        local: &'tcx hir::Local,\n-        init: &'tcx hir::Expr,\n+        local: &'tcx hir::Local<'tcx>,\n+        init: &'tcx hir::Expr<'tcx>,\n     ) -> Ty<'tcx> {\n         // FIXME(tschottdorf): `contains_explicit_ref_binding()` must be removed\n         // for #42640 (default match binding modes).\n@@ -4275,7 +4274,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n-    pub fn check_decl_local(&self, local: &'tcx hir::Local) {\n+    pub fn check_decl_local(&self, local: &'tcx hir::Local<'tcx>) {\n         let t = self.local_ty(local.span, local.hir_id).decl_ty;\n         self.write_ty(local.hir_id, t);\n \n@@ -4289,7 +4288,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         self.overwrite_local_ty_if_err(local, t, pat_ty);\n     }\n \n-    fn overwrite_local_ty_if_err(&self, local: &'tcx hir::Local, decl_ty: Ty<'tcx>, ty: Ty<'tcx>) {\n+    fn overwrite_local_ty_if_err(\n+        &self,\n+        local: &'tcx hir::Local<'tcx>,\n+        decl_ty: Ty<'tcx>,\n+        ty: Ty<'tcx>,\n+    ) {\n         if ty.references_error() {\n             // Override the types everywhere with `types.err` to avoid knock down errors.\n             self.write_ty(local.hir_id, ty);\n@@ -4309,7 +4313,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         );\n     }\n \n-    pub fn check_stmt(&self, stmt: &'tcx hir::Stmt) {\n+    pub fn check_stmt(&self, stmt: &'tcx hir::Stmt<'tcx>) {\n         // Don't do all the complex logic below for `DeclItem`.\n         match stmt.kind {\n             hir::StmtKind::Item(..) => return,\n@@ -4347,7 +4351,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         self.has_errors.set(self.has_errors.get() | old_has_errors);\n     }\n \n-    pub fn check_block_no_value(&self, blk: &'tcx hir::Block) {\n+    pub fn check_block_no_value(&self, blk: &'tcx hir::Block<'tcx>) {\n         let unit = self.tcx.mk_unit();\n         let ty = self.check_block_with_expected(blk, ExpectHasType(unit));\n \n@@ -4365,7 +4369,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// if false { return 0i32; } else { 1u32 }\n     /// //                               ^^^^ point at this instead of the whole `if` expression\n     /// ```\n-    fn get_expr_coercion_span(&self, expr: &hir::Expr) -> syntax_pos::Span {\n+    fn get_expr_coercion_span(&self, expr: &hir::Expr<'_>) -> syntax_pos::Span {\n         if let hir::ExprKind::Match(_, arms, _) = &expr.kind {\n             let arm_spans: Vec<Span> = arms\n                 .iter()\n@@ -4396,7 +4400,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     fn check_block_with_expected(\n         &self,\n-        blk: &'tcx hir::Block,\n+        blk: &'tcx hir::Block<'tcx>,\n         expected: Expectation<'tcx>,\n     ) -> Ty<'tcx> {\n         let prev = {\n@@ -4426,7 +4430,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let coerce = if blk.targeted_by_break {\n             CoerceMany::new(coerce_to_ty)\n         } else {\n-            let tail_expr: &[P<hir::Expr>] = match tail_expr {\n+            let tail_expr: &[&hir::Expr<'_>] = match tail_expr {\n                 Some(e) => slice::from_ref(e),\n                 None => &[],\n             };\n@@ -4437,7 +4441,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let ctxt = BreakableCtxt { coerce: Some(coerce), may_break: false };\n \n         let (ctxt, ()) = self.with_breakable_ctxt(blk.hir_id, ctxt, || {\n-            for s in &blk.stmts {\n+            for s in blk.stmts {\n                 self.check_stmt(s);\n             }\n \n@@ -4588,7 +4592,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub fn suggest_mismatched_types_on_tail(\n         &self,\n         err: &mut DiagnosticBuilder<'_>,\n-        expr: &'tcx hir::Expr,\n+        expr: &'tcx hir::Expr<'tcx>,\n         expected: Ty<'tcx>,\n         found: Ty<'tcx>,\n         cause_span: Span,\n@@ -4613,7 +4617,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     fn suggest_fn_call(\n         &self,\n         err: &mut DiagnosticBuilder<'_>,\n-        expr: &hir::Expr,\n+        expr: &hir::Expr<'_>,\n         expected: Ty<'tcx>,\n         found: Ty<'tcx>,\n     ) -> bool {\n@@ -4756,7 +4760,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub fn suggest_ref_or_into(\n         &self,\n         err: &mut DiagnosticBuilder<'_>,\n-        expr: &hir::Expr,\n+        expr: &hir::Expr<'_>,\n         expected: Ty<'tcx>,\n         found: Ty<'tcx>,\n     ) {\n@@ -4819,7 +4823,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     fn suggest_boxing_when_appropriate(\n         &self,\n         err: &mut DiagnosticBuilder<'_>,\n-        expr: &hir::Expr,\n+        expr: &hir::Expr<'_>,\n         expected: Ty<'tcx>,\n         found: Ty<'tcx>,\n     ) {\n@@ -4864,7 +4868,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     fn suggest_missing_semicolon(\n         &self,\n         err: &mut DiagnosticBuilder<'_>,\n-        expression: &'tcx hir::Expr,\n+        expression: &'tcx hir::Expr<'tcx>,\n         expected: Ty<'tcx>,\n         cause_span: Span,\n     ) {\n@@ -4970,7 +4974,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     fn suggest_missing_await(\n         &self,\n         err: &mut DiagnosticBuilder<'_>,\n-        expr: &hir::Expr,\n+        expr: &hir::Expr<'_>,\n         expected: Ty<'tcx>,\n         found: Ty<'tcx>,\n     ) {\n@@ -5033,7 +5037,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// with `expected_ty`. If so, it suggests removing the semicolon.\n     fn consider_hint_about_removing_semicolon(\n         &self,\n-        blk: &'tcx hir::Block,\n+        blk: &'tcx hir::Block<'tcx>,\n         expected_ty: Ty<'tcx>,\n         err: &mut DiagnosticBuilder<'_>,\n     ) {\n@@ -5047,7 +5051,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n-    fn could_remove_semicolon(&self, blk: &'tcx hir::Block, expected_ty: Ty<'tcx>) -> Option<Span> {\n+    fn could_remove_semicolon(\n+        &self,\n+        blk: &'tcx hir::Block<'tcx>,\n+        expected_ty: Ty<'tcx>,\n+    ) -> Option<Span> {\n         // Be helpful when the user wrote `{... expr;}` and\n         // taking the `;` off is enough to fix the error.\n         let last_stmt = blk.stmts.last()?;"}, {"sha": "873a9b86fd60fac4cd8019d4bdec2a42748548b3", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/82840353726668c624e46627ac11a1fec18d6d09/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82840353726668c624e46627ac11a1fec18d6d09/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=82840353726668c624e46627ac11a1fec18d6d09", "patch": "@@ -17,10 +17,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// Checks a `a <op>= b`\n     pub fn check_binop_assign(\n         &self,\n-        expr: &'tcx hir::Expr,\n+        expr: &'tcx hir::Expr<'tcx>,\n         op: hir::BinOp,\n-        lhs: &'tcx hir::Expr,\n-        rhs: &'tcx hir::Expr,\n+        lhs: &'tcx hir::Expr<'tcx>,\n+        rhs: &'tcx hir::Expr<'tcx>,\n     ) -> Ty<'tcx> {\n         let (lhs_ty, rhs_ty, return_ty) =\n             self.check_overloaded_binop(expr, lhs, rhs, op, IsAssign::Yes);\n@@ -41,10 +41,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// Checks a potentially overloaded binary operator.\n     pub fn check_binop(\n         &self,\n-        expr: &'tcx hir::Expr,\n+        expr: &'tcx hir::Expr<'tcx>,\n         op: hir::BinOp,\n-        lhs_expr: &'tcx hir::Expr,\n-        rhs_expr: &'tcx hir::Expr,\n+        lhs_expr: &'tcx hir::Expr<'tcx>,\n+        rhs_expr: &'tcx hir::Expr<'tcx>,\n     ) -> Ty<'tcx> {\n         let tcx = self.tcx;\n \n@@ -100,9 +100,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     fn enforce_builtin_binop_types(\n         &self,\n-        lhs_expr: &'tcx hir::Expr,\n+        lhs_expr: &'tcx hir::Expr<'tcx>,\n         lhs_ty: Ty<'tcx>,\n-        rhs_expr: &'tcx hir::Expr,\n+        rhs_expr: &'tcx hir::Expr<'tcx>,\n         rhs_ty: Ty<'tcx>,\n         op: hir::BinOp,\n     ) -> Ty<'tcx> {\n@@ -137,9 +137,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     fn check_overloaded_binop(\n         &self,\n-        expr: &'tcx hir::Expr,\n-        lhs_expr: &'tcx hir::Expr,\n-        rhs_expr: &'tcx hir::Expr,\n+        expr: &'tcx hir::Expr<'tcx>,\n+        lhs_expr: &'tcx hir::Expr<'tcx>,\n+        rhs_expr: &'tcx hir::Expr<'tcx>,\n         op: hir::BinOp,\n         is_assign: IsAssign,\n     ) -> (Ty<'tcx>, Ty<'tcx>, Ty<'tcx>) {\n@@ -561,8 +561,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// to print the normal \"implementation of `std::ops::Add` might be missing\" note\n     fn check_str_addition(\n         &self,\n-        lhs_expr: &'tcx hir::Expr,\n-        rhs_expr: &'tcx hir::Expr,\n+        lhs_expr: &'tcx hir::Expr<'tcx>,\n+        rhs_expr: &'tcx hir::Expr<'tcx>,\n         lhs_ty: Ty<'tcx>,\n         rhs_ty: Ty<'tcx>,\n         err: &mut errors::DiagnosticBuilder<'_>,\n@@ -659,7 +659,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     pub fn check_user_unop(\n         &self,\n-        ex: &'tcx hir::Expr,\n+        ex: &'tcx hir::Expr<'tcx>,\n         operand_ty: Ty<'tcx>,\n         op: hir::UnOp,\n     ) -> Ty<'tcx> {"}, {"sha": "3fb6d5227f77b8a2f7ec369e7af0a65e625bcaa6", "filename": "src/librustc_typeck/check/pat.rs", "status": "modified", "additions": 44, "deletions": 32, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/82840353726668c624e46627ac11a1fec18d6d09/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82840353726668c624e46627ac11a1fec18d6d09/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs?ref=82840353726668c624e46627ac11a1fec18d6d09", "patch": "@@ -3,7 +3,6 @@ use crate::util::nodemap::FxHashMap;\n use errors::{pluralize, Applicability, DiagnosticBuilder};\n use rustc::hir::def::{CtorKind, DefKind, Res};\n use rustc::hir::pat_util::EnumerateAndAdjustIterator;\n-use rustc::hir::ptr::P;\n use rustc::hir::{self, HirId, Pat, PatKind};\n use rustc::infer;\n use rustc::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n@@ -31,7 +30,12 @@ You can read more about trait objects in the Trait Objects section of the Refere\n https://doc.rust-lang.org/reference/types.html#trait-objects\";\n \n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n-    pub fn check_pat_top(&self, pat: &'tcx Pat, expected: Ty<'tcx>, discrim_span: Option<Span>) {\n+    pub fn check_pat_top(\n+        &self,\n+        pat: &'tcx Pat<'tcx>,\n+        expected: Ty<'tcx>,\n+        discrim_span: Option<Span>,\n+    ) {\n         let def_bm = BindingMode::BindByValue(hir::Mutability::Not);\n         self.check_pat(pat, expected, def_bm, discrim_span);\n     }\n@@ -54,7 +58,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// ```\n     fn check_pat(\n         &self,\n-        pat: &'tcx Pat,\n+        pat: &'tcx Pat<'tcx>,\n         expected: Ty<'tcx>,\n         def_bm: BindingMode,\n         discrim_span: Option<Span>,\n@@ -97,13 +101,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 self.check_pat_struct(pat, qpath, fields, *etc, expected, def_bm, discrim_span)\n             }\n             PatKind::Or(pats) => {\n-                for pat in pats {\n+                for pat in *pats {\n                     self.check_pat(pat, expected, def_bm, discrim_span);\n                 }\n                 expected\n             }\n             PatKind::Tuple(elements, ddpos) => {\n-                self.check_pat_tuple(pat.span, elements, *ddpos, expected, def_bm, discrim_span)\n+                self.check_pat_tuple(pat.span, *elements, *ddpos, expected, def_bm, discrim_span)\n             }\n             PatKind::Box(inner) => {\n                 self.check_pat_box(pat.span, inner, expected, def_bm, discrim_span)\n@@ -113,7 +117,15 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             }\n             PatKind::Slice(before, slice, after) => {\n                 let slice = slice.as_deref();\n-                self.check_pat_slice(pat.span, before, slice, after, expected, def_bm, discrim_span)\n+                self.check_pat_slice(\n+                    pat.span,\n+                    *before,\n+                    slice,\n+                    *after,\n+                    expected,\n+                    def_bm,\n+                    discrim_span,\n+                )\n             }\n         };\n \n@@ -173,7 +185,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// as well as the pattern form we are currently checking.\n     fn calc_default_binding_mode(\n         &self,\n-        pat: &'tcx Pat,\n+        pat: &'tcx Pat<'tcx>,\n         expected: Ty<'tcx>,\n         def_bm: BindingMode,\n         is_non_ref_pat: bool,\n@@ -203,7 +215,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     /// Is the pattern a \"non reference pattern\"?\n     /// When the pattern is a path pattern, `opt_path_res` must be `Some(res)`.\n-    fn is_non_ref_pat(&self, pat: &'tcx Pat, opt_path_res: Option<Res>) -> bool {\n+    fn is_non_ref_pat(&self, pat: &'tcx Pat<'tcx>, opt_path_res: Option<Res>) -> bool {\n         match pat.kind {\n             PatKind::Struct(..)\n             | PatKind::TupleStruct(..)\n@@ -242,7 +254,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// The adjustments vector, if non-empty is stored in a table.\n     fn peel_off_references(\n         &self,\n-        pat: &'tcx Pat,\n+        pat: &'tcx Pat<'tcx>,\n         expected: Ty<'tcx>,\n         mut def_bm: BindingMode,\n     ) -> (Ty<'tcx>, BindingMode) {\n@@ -288,7 +300,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     fn check_pat_lit(\n         &self,\n         span: Span,\n-        lt: &hir::Expr,\n+        lt: &hir::Expr<'tcx>,\n         expected: Ty<'tcx>,\n         discrim_span: Option<Span>,\n     ) -> Ty<'tcx> {\n@@ -341,8 +353,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     fn check_pat_range(\n         &self,\n         span: Span,\n-        begin: &'tcx hir::Expr,\n-        end: &'tcx hir::Expr,\n+        begin: &'tcx hir::Expr<'tcx>,\n+        end: &'tcx hir::Expr<'tcx>,\n         expected: Ty<'tcx>,\n         discrim_span: Option<Span>,\n     ) -> Option<Ty<'tcx>> {\n@@ -422,10 +434,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     fn check_pat_ident(\n         &self,\n-        pat: &Pat,\n+        pat: &Pat<'_>,\n         ba: hir::BindingAnnotation,\n         var_id: HirId,\n-        sub: Option<&'tcx Pat>,\n+        sub: Option<&'tcx Pat<'tcx>>,\n         expected: Ty<'tcx>,\n         def_bm: BindingMode,\n         discrim_span: Option<Span>,\n@@ -477,8 +489,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     fn borrow_pat_suggestion(\n         &self,\n         err: &mut DiagnosticBuilder<'_>,\n-        pat: &Pat,\n-        inner: &Pat,\n+        pat: &Pat<'_>,\n+        inner: &Pat<'_>,\n         expected: Ty<'tcx>,\n     ) {\n         let tcx = self.tcx;\n@@ -513,7 +525,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n-    pub fn check_dereferenceable(&self, span: Span, expected: Ty<'tcx>, inner: &Pat) -> bool {\n+    pub fn check_dereferenceable(&self, span: Span, expected: Ty<'tcx>, inner: &Pat<'_>) -> bool {\n         if let PatKind::Binding(..) = inner.kind {\n             if let Some(mt) = self.shallow_resolve(expected).builtin_deref(true) {\n                 if let ty::Dynamic(..) = mt.ty.kind {\n@@ -541,9 +553,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     fn check_pat_struct(\n         &self,\n-        pat: &'tcx Pat,\n+        pat: &'tcx Pat<'tcx>,\n         qpath: &hir::QPath,\n-        fields: &'tcx [hir::FieldPat],\n+        fields: &'tcx [hir::FieldPat<'tcx>],\n         etc: bool,\n         expected: Ty<'tcx>,\n         def_bm: BindingMode,\n@@ -574,7 +586,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     fn check_pat_path(\n         &self,\n-        pat: &Pat,\n+        pat: &Pat<'_>,\n         path_resolution: (Res, Option<Ty<'tcx>>, &'b [hir::PathSegment]),\n         qpath: &hir::QPath,\n         expected: Ty<'tcx>,\n@@ -609,9 +621,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     fn check_pat_tuple_struct(\n         &self,\n-        pat: &Pat,\n+        pat: &Pat<'_>,\n         qpath: &hir::QPath,\n-        subpats: &'tcx [P<Pat>],\n+        subpats: &'tcx [&'tcx Pat<'tcx>],\n         ddpos: Option<usize>,\n         expected: Ty<'tcx>,\n         def_bm: BindingMode,\n@@ -713,7 +725,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         pat_span: Span,\n         res: Res,\n         qpath: &hir::QPath,\n-        subpats: &'tcx [P<Pat>],\n+        subpats: &'tcx [&'tcx Pat<'tcx>],\n         fields: &'tcx [ty::FieldDef],\n         expected: Ty<'tcx>,\n         had_err: bool,\n@@ -795,7 +807,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     fn check_pat_tuple(\n         &self,\n         span: Span,\n-        elements: &'tcx [P<Pat>],\n+        elements: &'tcx [&'tcx Pat<'tcx>],\n         ddpos: Option<usize>,\n         expected: Ty<'tcx>,\n         def_bm: BindingMode,\n@@ -843,7 +855,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         pat_id: HirId,\n         span: Span,\n         variant: &'tcx ty::VariantDef,\n-        fields: &'tcx [hir::FieldPat],\n+        fields: &'tcx [hir::FieldPat<'tcx>],\n         etc: bool,\n         def_bm: BindingMode,\n     ) -> bool {\n@@ -1069,7 +1081,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     fn check_pat_box(\n         &self,\n         span: Span,\n-        inner: &'tcx Pat,\n+        inner: &'tcx Pat<'tcx>,\n         expected: Ty<'tcx>,\n         def_bm: BindingMode,\n         discrim_span: Option<Span>,\n@@ -1094,8 +1106,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     fn check_pat_ref(\n         &self,\n-        pat: &Pat,\n-        inner: &'tcx Pat,\n+        pat: &Pat<'_>,\n+        inner: &'tcx Pat<'tcx>,\n         mutbl: hir::Mutability,\n         expected: Ty<'tcx>,\n         def_bm: BindingMode,\n@@ -1158,9 +1170,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     fn check_pat_slice(\n         &self,\n         span: Span,\n-        before: &'tcx [P<Pat>],\n-        slice: Option<&'tcx Pat>,\n-        after: &'tcx [P<Pat>],\n+        before: &'tcx [&'tcx Pat<'tcx>],\n+        slice: Option<&'tcx Pat<'tcx>>,\n+        after: &'tcx [&'tcx Pat<'tcx>],\n         expected: Ty<'tcx>,\n         def_bm: BindingMode,\n         discrim_span: Option<Span>,\n@@ -1208,7 +1220,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     fn check_array_pat_len(\n         &self,\n         span: Span,\n-        slice: Option<&'tcx Pat>,\n+        slice: Option<&'tcx Pat<'tcx>>,\n         len: &ty::Const<'tcx>,\n         min_len: u64,\n     ) -> Option<u64> {"}, {"sha": "1ce7748badbf1760e7c5738460d794d30a146c23", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 27, "deletions": 22, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/82840353726668c624e46627ac11a1fec18d6d09/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82840353726668c624e46627ac11a1fec18d6d09/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=82840353726668c624e46627ac11a1fec18d6d09", "patch": "@@ -269,7 +269,7 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n     }\n \n     /// Try to resolve the type for the given node.\n-    pub fn resolve_expr_type_adjusted(&mut self, expr: &hir::Expr) -> Ty<'tcx> {\n+    pub fn resolve_expr_type_adjusted(&mut self, expr: &hir::Expr<'_>) -> Ty<'tcx> {\n         let ty = self.tables.borrow().expr_ty_adjusted(expr);\n         self.resolve_type(ty)\n     }\n@@ -367,7 +367,7 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n         );\n     }\n \n-    fn constrain_bindings_in_pat(&mut self, pat: &hir::Pat) {\n+    fn constrain_bindings_in_pat(&mut self, pat: &hir::Pat<'_>) {\n         debug!(\"regionck::visit_pat(pat={:?})\", pat);\n         pat.each_binding(|_, hir_id, span, _| {\n             // If we have a variable that contains region'd data, that\n@@ -453,20 +453,20 @@ impl<'a, 'tcx> Visitor<'tcx> for RegionCtxt<'a, 'tcx> {\n \n     //visit_pat: visit_pat, // (..) see above\n \n-    fn visit_arm(&mut self, arm: &'tcx hir::Arm) {\n+    fn visit_arm(&mut self, arm: &'tcx hir::Arm<'tcx>) {\n         // see above\n         self.constrain_bindings_in_pat(&arm.pat);\n         intravisit::walk_arm(self, arm);\n     }\n \n-    fn visit_local(&mut self, l: &'tcx hir::Local) {\n+    fn visit_local(&mut self, l: &'tcx hir::Local<'tcx>) {\n         // see above\n         self.constrain_bindings_in_pat(&l.pat);\n         self.link_local(l);\n         intravisit::walk_local(self, l);\n     }\n \n-    fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n+    fn visit_expr(&mut self, expr: &'tcx hir::Expr<'tcx>) {\n         debug!(\"regionck::visit_expr(e={:?}, repeating_scope={:?})\", expr, self.repeating_scope);\n \n         // No matter what, the type of each expression must outlive the\n@@ -580,7 +580,7 @@ impl<'a, 'tcx> Visitor<'tcx> for RegionCtxt<'a, 'tcx> {\n             hir::ExprKind::Unary(hir::UnDeref, ref base) => {\n                 // For *a, the lifetime of a must enclose the deref\n                 if is_method_call {\n-                    self.constrain_call(expr, Some(base), None::<hir::Expr>.iter());\n+                    self.constrain_call(expr, Some(base), None::<hir::Expr<'_>>.iter());\n                 }\n                 // For overloaded derefs, base_ty is the input to `Deref::deref`,\n                 // but it's a reference type uing the same region as the output.\n@@ -594,7 +594,7 @@ impl<'a, 'tcx> Visitor<'tcx> for RegionCtxt<'a, 'tcx> {\n \n             hir::ExprKind::Unary(_, ref lhs) if is_method_call => {\n                 // As above.\n-                self.constrain_call(expr, Some(&lhs), None::<hir::Expr>.iter());\n+                self.constrain_call(expr, Some(&lhs), None::<hir::Expr<'_>>.iter());\n \n                 intravisit::walk_expr(self, expr);\n             }\n@@ -670,7 +670,7 @@ impl<'a, 'tcx> Visitor<'tcx> for RegionCtxt<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n-    fn constrain_cast(&mut self, cast_expr: &hir::Expr, source_expr: &hir::Expr) {\n+    fn constrain_cast(&mut self, cast_expr: &hir::Expr<'_>, source_expr: &hir::Expr<'_>) {\n         debug!(\"constrain_cast(cast_expr={:?}, source_expr={:?})\", cast_expr, source_expr);\n \n         let source_ty = self.resolve_node_type(source_expr.hir_id);\n@@ -679,7 +679,7 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n         self.walk_cast(cast_expr, source_ty, target_ty);\n     }\n \n-    fn walk_cast(&mut self, cast_expr: &hir::Expr, from_ty: Ty<'tcx>, to_ty: Ty<'tcx>) {\n+    fn walk_cast(&mut self, cast_expr: &hir::Expr<'_>, from_ty: Ty<'tcx>, to_ty: Ty<'tcx>) {\n         debug!(\"walk_cast(from_ty={:?}, to_ty={:?})\", from_ty, to_ty);\n         match (&from_ty.kind, &to_ty.kind) {\n             /*From:*/\n@@ -707,13 +707,13 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n         }\n     }\n \n-    fn check_expr_fn_block(&mut self, expr: &'tcx hir::Expr, body_id: hir::BodyId) {\n+    fn check_expr_fn_block(&mut self, expr: &'tcx hir::Expr<'tcx>, body_id: hir::BodyId) {\n         let repeating_scope = self.set_repeating_scope(body_id.hir_id);\n         intravisit::walk_expr(self, expr);\n         self.set_repeating_scope(repeating_scope);\n     }\n \n-    fn constrain_callee(&mut self, callee_expr: &hir::Expr) {\n+    fn constrain_callee(&mut self, callee_expr: &hir::Expr<'_>) {\n         let callee_ty = self.resolve_node_type(callee_expr.hir_id);\n         match callee_ty.kind {\n             ty::FnDef(..) | ty::FnPtr(_) => {}\n@@ -729,10 +729,10 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n         }\n     }\n \n-    fn constrain_call<'b, I: Iterator<Item = &'b hir::Expr>>(\n+    fn constrain_call<'b, I: Iterator<Item = &'b hir::Expr<'b>>>(\n         &mut self,\n-        call_expr: &hir::Expr,\n-        receiver: Option<&hir::Expr>,\n+        call_expr: &hir::Expr<'_>,\n+        receiver: Option<&hir::Expr<'_>>,\n         arg_exprs: I,\n     ) {\n         //! Invoked on every call site (i.e., normal calls, method calls,\n@@ -786,7 +786,7 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n \n     /// Invoked on any adjustments that occur. Checks that if this is a region pointer being\n     /// dereferenced, the lifetime of the pointer includes the deref expr.\n-    fn constrain_adjustments(&mut self, expr: &hir::Expr) -> mc::McResult<mc::Place<'tcx>> {\n+    fn constrain_adjustments(&mut self, expr: &hir::Expr<'_>) -> mc::McResult<mc::Place<'tcx>> {\n         debug!(\"constrain_adjustments(expr={:?})\", expr);\n \n         let mut cmt = self.with_mc(|mc| mc.cat_expr_unadjusted(expr))?;\n@@ -880,7 +880,7 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n \n     /// Invoked on any index expression that occurs. Checks that if this is a slice\n     /// being indexed, the lifetime of the pointer includes the deref expr.\n-    fn constrain_index(&mut self, index_expr: &hir::Expr, indexed_ty: Ty<'tcx>) {\n+    fn constrain_index(&mut self, index_expr: &hir::Expr<'_>, indexed_ty: Ty<'tcx>) {\n         debug!(\"constrain_index(index_expr=?, indexed_ty={}\", self.ty_to_string(indexed_ty));\n \n         let r_index_expr = ty::ReScope(region::Scope {\n@@ -952,7 +952,12 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n \n     /// Computes the guarantor for an expression `&base` and then ensures that the lifetime of the\n     /// resulting pointer is linked to the lifetime of its guarantor (if any).\n-    fn link_addr_of(&mut self, expr: &hir::Expr, mutability: hir::Mutability, base: &hir::Expr) {\n+    fn link_addr_of(\n+        &mut self,\n+        expr: &hir::Expr<'_>,\n+        mutability: hir::Mutability,\n+        base: &hir::Expr<'_>,\n+    ) {\n         debug!(\"link_addr_of(expr={:?}, base={:?})\", expr, base);\n \n         let cmt = ignore_err!(self.with_mc(|mc| mc.cat_expr(base)));\n@@ -965,7 +970,7 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n     /// Computes the guarantors for any ref bindings in a `let` and\n     /// then ensures that the lifetime of the resulting pointer is\n     /// linked to the lifetime of the initialization expression.\n-    fn link_local(&self, local: &hir::Local) {\n+    fn link_local(&self, local: &hir::Local<'_>) {\n         debug!(\"regionck::for_local()\");\n         let init_expr = match local.init {\n             None => {\n@@ -980,7 +985,7 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n     /// Computes the guarantors for any ref bindings in a match and\n     /// then ensures that the lifetime of the resulting pointer is\n     /// linked to the lifetime of its guarantor (if any).\n-    fn link_match(&self, discr: &hir::Expr, arms: &[hir::Arm]) {\n+    fn link_match(&self, discr: &hir::Expr<'_>, arms: &[hir::Arm<'_>]) {\n         debug!(\"regionck::for_match()\");\n         let discr_cmt = ignore_err!(self.with_mc(|mc| mc.cat_expr(discr)));\n         debug!(\"discr_cmt={:?}\", discr_cmt);\n@@ -992,7 +997,7 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n     /// Computes the guarantors for any ref bindings in a match and\n     /// then ensures that the lifetime of the resulting pointer is\n     /// linked to the lifetime of its guarantor (if any).\n-    fn link_fn_params(&self, params: &[hir::Param]) {\n+    fn link_fn_params(&self, params: &[hir::Param<'_>]) {\n         for param in params {\n             let param_ty = self.node_ty(param.hir_id);\n             let param_cmt =\n@@ -1004,7 +1009,7 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n \n     /// Link lifetimes of any ref bindings in `root_pat` to the pointers found\n     /// in the discriminant, if needed.\n-    fn link_pattern(&self, discr_cmt: mc::Place<'tcx>, root_pat: &hir::Pat) {\n+    fn link_pattern(&self, discr_cmt: mc::Place<'tcx>, root_pat: &hir::Pat<'_>) {\n         debug!(\"link_pattern(discr_cmt={:?}, root_pat={:?})\", discr_cmt, root_pat);\n         ignore_err!(self.with_mc(|mc| {\n             mc.cat_pattern(discr_cmt, root_pat, |sub_cmt, hir::Pat { kind, span, hir_id }| {\n@@ -1024,7 +1029,7 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n     /// autoref'd.\n     fn link_autoref(\n         &self,\n-        expr: &hir::Expr,\n+        expr: &hir::Expr<'_>,\n         expr_cmt: &mc::Place<'tcx>,\n         autoref: &adjustment::AutoBorrow<'tcx>,\n     ) {"}, {"sha": "bdccced42c4b34c4e33a6c1b36befe5d63a73667", "filename": "src/librustc_typeck/check/upvar.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/82840353726668c624e46627ac11a1fec18d6d09/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82840353726668c624e46627ac11a1fec18d6d09/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs?ref=82840353726668c624e46627ac11a1fec18d6d09", "patch": "@@ -63,7 +63,7 @@ impl<'a, 'tcx> Visitor<'tcx> for InferBorrowKindVisitor<'a, 'tcx> {\n         NestedVisitorMap::None\n     }\n \n-    fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n+    fn visit_expr(&mut self, expr: &'tcx hir::Expr<'tcx>) {\n         if let hir::ExprKind::Closure(cc, _, body_id, _, _) = expr.kind {\n             let body = self.fcx.tcx.hir().body(body_id);\n             self.visit_body(body);"}, {"sha": "ca9a4763ed0a44c33468dda1a6deead769b0b119", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/82840353726668c624e46627ac11a1fec18d6d09/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82840353726668c624e46627ac11a1fec18d6d09/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=82840353726668c624e46627ac11a1fec18d6d09", "patch": "@@ -132,7 +132,7 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n     // as potentially overloaded. But then, during writeback, if\n     // we observe that something like `a+b` is (known to be)\n     // operating on scalars, we clear the overload.\n-    fn fix_scalar_builtin_expr(&mut self, e: &hir::Expr) {\n+    fn fix_scalar_builtin_expr(&mut self, e: &hir::Expr<'_>) {\n         match e.kind {\n             hir::ExprKind::Unary(hir::UnNeg, ref inner)\n             | hir::ExprKind::Unary(hir::UnNot, ref inner) => {\n@@ -181,7 +181,7 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n     // Here, correct cases where an indexing expression can be simplified\n     // to use builtin indexing because the index type is known to be\n     // usize-ish\n-    fn fix_index_builtin_expr(&mut self, e: &hir::Expr) {\n+    fn fix_index_builtin_expr(&mut self, e: &hir::Expr<'_>) {\n         if let hir::ExprKind::Index(ref base, ref index) = e.kind {\n             let mut tables = self.fcx.tables.borrow_mut();\n \n@@ -247,7 +247,7 @@ impl<'cx, 'tcx> Visitor<'tcx> for WritebackCx<'cx, 'tcx> {\n         NestedVisitorMap::None\n     }\n \n-    fn visit_expr(&mut self, e: &'tcx hir::Expr) {\n+    fn visit_expr(&mut self, e: &'tcx hir::Expr<'tcx>) {\n         self.fix_scalar_builtin_expr(e);\n         self.fix_index_builtin_expr(e);\n \n@@ -262,7 +262,7 @@ impl<'cx, 'tcx> Visitor<'tcx> for WritebackCx<'cx, 'tcx> {\n \n                 self.visit_body(body);\n             }\n-            hir::ExprKind::Struct(_, ref fields, _) => {\n+            hir::ExprKind::Struct(_, fields, _) => {\n                 for field in fields {\n                     self.visit_field_id(field.hir_id);\n                 }\n@@ -276,20 +276,20 @@ impl<'cx, 'tcx> Visitor<'tcx> for WritebackCx<'cx, 'tcx> {\n         intravisit::walk_expr(self, e);\n     }\n \n-    fn visit_block(&mut self, b: &'tcx hir::Block) {\n+    fn visit_block(&mut self, b: &'tcx hir::Block<'tcx>) {\n         self.visit_node_id(b.span, b.hir_id);\n         intravisit::walk_block(self, b);\n     }\n \n-    fn visit_pat(&mut self, p: &'tcx hir::Pat) {\n+    fn visit_pat(&mut self, p: &'tcx hir::Pat<'tcx>) {\n         match p.kind {\n             hir::PatKind::Binding(..) => {\n                 let tables = self.fcx.tables.borrow();\n                 if let Some(bm) = tables.extract_binding_mode(self.tcx().sess, p.hir_id, p.span) {\n                     self.tables.pat_binding_modes_mut().insert(p.hir_id, bm);\n                 }\n             }\n-            hir::PatKind::Struct(_, ref fields, _) => {\n+            hir::PatKind::Struct(_, fields, _) => {\n                 for field in fields {\n                     self.visit_field_id(field.hir_id);\n                 }\n@@ -303,7 +303,7 @@ impl<'cx, 'tcx> Visitor<'tcx> for WritebackCx<'cx, 'tcx> {\n         intravisit::walk_pat(self, p);\n     }\n \n-    fn visit_local(&mut self, l: &'tcx hir::Local) {\n+    fn visit_local(&mut self, l: &'tcx hir::Local<'tcx>) {\n         intravisit::walk_local(self, l);\n         let var_ty = self.fcx.local_ty(l.span, l.hir_id).decl_ty;\n         let var_ty = self.resolve(&var_ty, &l.span);"}, {"sha": "01f11f669f75b7c03f8df21efe7cee14fcdcc7fc", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/82840353726668c624e46627ac11a1fec18d6d09/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82840353726668c624e46627ac11a1fec18d6d09/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=82840353726668c624e46627ac11a1fec18d6d09", "patch": "@@ -134,7 +134,7 @@ impl Visitor<'tcx> for CollectItemTypesVisitor<'tcx> {\n         intravisit::walk_generics(self, generics);\n     }\n \n-    fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n+    fn visit_expr(&mut self, expr: &'tcx hir::Expr<'tcx>) {\n         if let hir::ExprKind::Closure(..) = expr.kind {\n             let def_id = self.tcx.hir().local_def_id(expr.hir_id);\n             self.tcx.generics_of(def_id);"}, {"sha": "b1467d508dcec0b14bba7dece8018a1b883a80f4", "filename": "src/librustc_typeck/expr_use_visitor.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/82840353726668c624e46627ac11a1fec18d6d09/src%2Flibrustc_typeck%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82840353726668c624e46627ac11a1fec18d6d09/src%2Flibrustc_typeck%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fexpr_use_visitor.rs?ref=82840353726668c624e46627ac11a1fec18d6d09", "patch": "@@ -10,7 +10,6 @@ pub use mc::{Place, PlaceBase, Projection};\n \n use rustc::hir::def::Res;\n use rustc::hir::def_id::DefId;\n-use rustc::hir::ptr::P;\n use rustc::hir::{self, PatKind};\n use rustc::infer::InferCtxt;\n use rustc::ty::{self, adjustment, TyCtxt};"}, {"sha": "4f5b55e4cd64e989b3be1f31988970c0263dd08b", "filename": "src/librustc_typeck/mem_categorization.rs", "status": "modified", "additions": 33, "deletions": 19, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/82840353726668c624e46627ac11a1fec18d6d09/src%2Flibrustc_typeck%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82840353726668c624e46627ac11a1fec18d6d09/src%2Flibrustc_typeck%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fmem_categorization.rs?ref=82840353726668c624e46627ac11a1fec18d6d09", "patch": "@@ -117,7 +117,7 @@ crate trait HirNode {\n     fn span(&self) -> Span;\n }\n \n-impl HirNode for hir::Expr {\n+impl HirNode for hir::Expr<'_> {\n     fn hir_id(&self) -> hir::HirId {\n         self.hir_id\n     }\n@@ -126,7 +126,7 @@ impl HirNode for hir::Expr {\n     }\n }\n \n-impl HirNode for hir::Pat {\n+impl HirNode for hir::Pat<'_> {\n     fn hir_id(&self) -> hir::HirId {\n         self.hir_id\n     }\n@@ -213,11 +213,11 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n         self.resolve_type_vars_or_error(hir_id, self.tables.node_type_opt(hir_id))\n     }\n \n-    fn expr_ty(&self, expr: &hir::Expr) -> McResult<Ty<'tcx>> {\n+    fn expr_ty(&self, expr: &hir::Expr<'_>) -> McResult<Ty<'tcx>> {\n         self.resolve_type_vars_or_error(expr.hir_id, self.tables.expr_ty_opt(expr))\n     }\n \n-    crate fn expr_ty_adjusted(&self, expr: &hir::Expr) -> McResult<Ty<'tcx>> {\n+    crate fn expr_ty_adjusted(&self, expr: &hir::Expr<'_>) -> McResult<Ty<'tcx>> {\n         self.resolve_type_vars_or_error(expr.hir_id, self.tables.expr_ty_adjusted_opt(expr))\n     }\n \n@@ -231,7 +231,7 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n     ///   implicit deref patterns attached (e.g., it is really\n     ///   `&Some(x)`). In that case, we return the \"outermost\" type\n     ///   (e.g., `&Option<T>).\n-    crate fn pat_ty_adjusted(&self, pat: &hir::Pat) -> McResult<Ty<'tcx>> {\n+    crate fn pat_ty_adjusted(&self, pat: &hir::Pat<'_>) -> McResult<Ty<'tcx>> {\n         // Check for implicit `&` types wrapping the pattern; note\n         // that these are never attached to binding patterns, so\n         // actually this is somewhat \"disjoint\" from the code below\n@@ -247,7 +247,7 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n     }\n \n     /// Like `pat_ty`, but ignores implicit `&` patterns.\n-    fn pat_ty_unadjusted(&self, pat: &hir::Pat) -> McResult<Ty<'tcx>> {\n+    fn pat_ty_unadjusted(&self, pat: &hir::Pat<'_>) -> McResult<Ty<'tcx>> {\n         let base_ty = self.node_ty(pat.hir_id)?;\n         debug!(\"pat_ty(pat={:?}) base_ty={:?}\", pat, base_ty);\n \n@@ -280,12 +280,12 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n         Ok(ret_ty)\n     }\n \n-    crate fn cat_expr(&self, expr: &hir::Expr) -> McResult<Place<'tcx>> {\n+    crate fn cat_expr(&self, expr: &hir::Expr<'_>) -> McResult<Place<'tcx>> {\n         // This recursion helper avoids going through *too many*\n         // adjustments, since *only* non-overloaded deref recurses.\n         fn helper<'a, 'tcx>(\n             mc: &MemCategorizationContext<'a, 'tcx>,\n-            expr: &hir::Expr,\n+            expr: &hir::Expr<'_>,\n             adjustments: &[adjustment::Adjustment<'tcx>],\n         ) -> McResult<Place<'tcx>> {\n             match adjustments.split_last() {\n@@ -301,7 +301,7 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n \n     crate fn cat_expr_adjusted(\n         &self,\n-        expr: &hir::Expr,\n+        expr: &hir::Expr<'_>,\n         previous: Place<'tcx>,\n         adjustment: &adjustment::Adjustment<'tcx>,\n     ) -> McResult<Place<'tcx>> {\n@@ -310,7 +310,7 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n \n     fn cat_expr_adjusted_with<F>(\n         &self,\n-        expr: &hir::Expr,\n+        expr: &hir::Expr<'_>,\n         previous: F,\n         adjustment: &adjustment::Adjustment<'tcx>,\n     ) -> McResult<Place<'tcx>>\n@@ -342,7 +342,7 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n         }\n     }\n \n-    crate fn cat_expr_unadjusted(&self, expr: &hir::Expr) -> McResult<Place<'tcx>> {\n+    crate fn cat_expr_unadjusted(&self, expr: &hir::Expr<'_>) -> McResult<Place<'tcx>> {\n         debug!(\"cat_expr: id={} expr={:?}\", expr.hir_id, expr);\n \n         let expr_ty = self.expr_ty(expr)?;\n@@ -513,7 +513,11 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n         ret\n     }\n \n-    fn cat_overloaded_place(&self, expr: &hir::Expr, base: &hir::Expr) -> McResult<Place<'tcx>> {\n+    fn cat_overloaded_place(\n+        &self,\n+        expr: &hir::Expr<'_>,\n+        base: &hir::Expr<'_>,\n+    ) -> McResult<Place<'tcx>> {\n         debug!(\"cat_overloaded_place(expr={:?}, base={:?})\", expr, base);\n \n         // Reconstruct the output assuming it's a reference with the\n@@ -557,17 +561,27 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n         Ok(ret)\n     }\n \n-    crate fn cat_pattern<F>(&self, place: Place<'tcx>, pat: &hir::Pat, mut op: F) -> McResult<()>\n+    crate fn cat_pattern<F>(\n+        &self,\n+        place: Place<'tcx>,\n+        pat: &hir::Pat<'_>,\n+        mut op: F,\n+    ) -> McResult<()>\n     where\n-        F: FnMut(&Place<'tcx>, &hir::Pat),\n+        F: FnMut(&Place<'tcx>, &hir::Pat<'_>),\n     {\n         self.cat_pattern_(place, pat, &mut op)\n     }\n \n     // FIXME(#19596) This is a workaround, but there should be a better way to do this\n-    fn cat_pattern_<F>(&self, mut place: Place<'tcx>, pat: &hir::Pat, op: &mut F) -> McResult<()>\n+    fn cat_pattern_<F>(\n+        &self,\n+        mut place: Place<'tcx>,\n+        pat: &hir::Pat<'_>,\n+        op: &mut F,\n+    ) -> McResult<()>\n     where\n-        F: FnMut(&Place<'tcx>, &hir::Pat),\n+        F: FnMut(&Place<'tcx>, &hir::Pat<'_>),\n     {\n         // Here, `place` is the `Place` being matched and pat is the pattern it\n         // is being matched against.\n@@ -638,7 +652,7 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n                 }\n             }\n \n-            PatKind::Struct(_, ref field_pats, _) => {\n+            PatKind::Struct(_, field_pats, _) => {\n                 // S { f1: p1, ..., fN: pN }\n                 for fp in field_pats {\n                     let field_ty = self.pat_ty_adjusted(&fp.pat)?;\n@@ -647,7 +661,7 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n                 }\n             }\n \n-            PatKind::Or(ref pats) => {\n+            PatKind::Or(pats) => {\n                 for pat in pats {\n                     self.cat_pattern_(place.clone(), &pat, op)?;\n                 }\n@@ -665,7 +679,7 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n                 self.cat_pattern_(subplace, &subpat, op)?;\n             }\n \n-            PatKind::Slice(ref before, ref slice, ref after) => {\n+            PatKind::Slice(before, ref slice, after) => {\n                 let element_ty = match place.ty.builtin_index() {\n                     Some(ty) => ty,\n                     None => {"}]}