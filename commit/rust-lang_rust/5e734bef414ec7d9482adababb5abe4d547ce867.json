{"sha": "5e734bef414ec7d9482adababb5abe4d547ce867", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVlNzM0YmVmNDE0ZWM3ZDk0ODJhZGFiYWJiNWFiZTRkNTQ3Y2U4Njc=", "commit": {"author": {"name": "Nadrieril", "email": "nadrieril@gmail.com", "date": "2019-09-23T14:07:23Z"}, "committer": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2019-11-01T17:22:32Z"}, "message": "Remove some redundancy", "tree": {"sha": "8c633623cff0e4d8ac1be8c929405f9599f8c811", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8c633623cff0e4d8ac1be8c929405f9599f8c811"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5e734bef414ec7d9482adababb5abe4d547ce867", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5e734bef414ec7d9482adababb5abe4d547ce867", "html_url": "https://github.com/rust-lang/rust/commit/5e734bef414ec7d9482adababb5abe4d547ce867", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5e734bef414ec7d9482adababb5abe4d547ce867/comments", "author": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "23ca38ed958d4ef3416a77a76f773897e433117b", "url": "https://api.github.com/repos/rust-lang/rust/commits/23ca38ed958d4ef3416a77a76f773897e433117b", "html_url": "https://github.com/rust-lang/rust/commit/23ca38ed958d4ef3416a77a76f773897e433117b"}], "stats": {"total": 92, "additions": 52, "deletions": 40}, "files": [{"sha": "fb4dba2db5cf1f79bade7f8c1effc05e85620dfb", "filename": "src/librustc_mir/hair/pattern/_match.rs", "status": "modified", "additions": 52, "deletions": 40, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/5e734bef414ec7d9482adababb5abe4d547ce867/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e734bef414ec7d9482adababb5abe4d547ce867/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs?ref=5e734bef414ec7d9482adababb5abe4d547ce867", "patch": "@@ -239,6 +239,7 @@ use rustc::ty::{self, Const, Ty, TyCtxt, TypeFoldable};\n use rustc::lint;\n use rustc::mir::interpret::{truncate, AllocId, ConstValue, Pointer, Scalar};\n use rustc::mir::Field;\n+use rustc::util::captures::Captures;\n use rustc::util::common::ErrorReported;\n \n use syntax::attr::{SignedInt, UnsignedInt};\n@@ -427,6 +428,11 @@ impl<'p, 'tcx> Matrix<'p, 'tcx> {\n         self.0.push(row)\n     }\n \n+    /// Iterate over the first component of each row\n+    fn heads<'a>(&'a self) -> impl Iterator<Item = &'a Pat<'tcx>> + Captures<'p> {\n+        self.0.iter().map(|r| r.head())\n+    }\n+\n     /// This computes `D(self)`. See top of the file for explanations.\n     fn specialize_wildcard(&self) -> Self {\n         self.0.iter().filter_map(|r| r.specialize_wildcard()).collect()\n@@ -635,6 +641,39 @@ impl<'tcx> Constructor<'tcx> {\n             _ => bug!(\"bad constructor being displayed: `{:?}\", self),\n         }\n     }\n+\n+    fn wildcard_subpatterns<'a>(\n+        &self,\n+        cx: &MatchCheckCtxt<'a, 'tcx>,\n+        ty: Ty<'tcx>,\n+    ) -> Vec<Pat<'tcx>> {\n+        constructor_sub_pattern_tys(cx, self, ty)\n+            .into_iter()\n+            .map(|ty| Pat { ty, span: DUMMY_SP, kind: box PatKind::Wild })\n+            .collect()\n+    }\n+\n+    /// This computes the arity of a constructor. The arity of a constructor\n+    /// is how many subpattern patterns of that constructor should be expanded to.\n+    ///\n+    /// For instance, a tuple pattern `(_, 42, Some([]))` has the arity of 3.\n+    /// A struct pattern's arity is the number of fields it contains, etc.\n+    fn arity<'a>(&self, cx: &MatchCheckCtxt<'a, 'tcx>, ty: Ty<'tcx>) -> u64 {\n+        debug!(\"Constructor::arity({:#?}, {:?})\", self, ty);\n+        match ty.kind {\n+            ty::Tuple(ref fs) => fs.len() as u64,\n+            ty::Slice(..) | ty::Array(..) => match *self {\n+                Slice(length) => length,\n+                ConstantValue(..) => 0,\n+                _ => bug!(\"bad slice pattern {:?} {:?}\", self, ty),\n+            },\n+            ty::Ref(..) => 1,\n+            ty::Adt(adt, _) => {\n+                adt.variants[self.variant_index_for_adt(cx, adt)].fields.len() as u64\n+            }\n+            _ => 0,\n+        }\n+    }\n }\n \n #[derive(Clone, Debug)]\n@@ -713,12 +752,7 @@ impl<'tcx> Witness<'tcx> {\n         ctor: &Constructor<'tcx>,\n         ty: Ty<'tcx>,\n     ) -> Self {\n-        let sub_pattern_tys = constructor_sub_pattern_tys(cx, ctor, ty);\n-        self.0.extend(sub_pattern_tys.into_iter().map(|ty| Pat {\n-            ty,\n-            span: DUMMY_SP,\n-            kind: box PatKind::Wild,\n-        }));\n+        self.0.extend(ctor.wildcard_subpatterns(cx, ty));\n         self.apply_constructor(cx, ctor, ty)\n     }\n \n@@ -741,7 +775,7 @@ impl<'tcx> Witness<'tcx> {\n         ctor: &Constructor<'tcx>,\n         ty: Ty<'tcx>,\n     ) -> Self {\n-        let arity = constructor_arity(cx, ctor, ty);\n+        let arity = ctor.arity(cx, ty);\n         let pat = {\n             let len = self.0.len() as u64;\n             let mut pats = self.0.drain((len - arity) as usize..).rev();\n@@ -1347,9 +1381,9 @@ pub fn is_useful<'p, 'a, 'tcx>(\n \n     assert!(rows.iter().all(|r| r.len() == v.len()));\n \n-    let (ty, span) = rows\n-        .iter()\n-        .map(|r| (r.head().ty, r.head().span))\n+    let (ty, span) = matrix\n+        .heads()\n+        .map(|r| (r.ty, r.span))\n         .find(|(ty, _)| !ty.references_error())\n         .unwrap_or((v.head().ty, v.head().span));\n     let pcx = PatCtxt {\n@@ -1373,7 +1407,7 @@ pub fn is_useful<'p, 'a, 'tcx>(\n         // introducing uninhabited patterns for inaccessible fields. We\n         // need to figure out how to model that.\n         ty,\n-        max_slice_length: max_slice_length(cx, rows.iter().map(|r| r.head()).chain(Some(v.head()))),\n+        max_slice_length: max_slice_length(cx, matrix.heads().chain(Some(v.head()))),\n         span,\n     };\n \n@@ -1397,10 +1431,8 @@ pub fn is_useful<'p, 'a, 'tcx>(\n     } else {\n         debug!(\"is_useful - expanding wildcard\");\n \n-        let used_ctors: Vec<Constructor<'_>> = rows\n-            .iter()\n-            .flat_map(|row| pat_constructors(cx, row.head(), pcx).unwrap_or(vec![]))\n-            .collect();\n+        let used_ctors: Vec<Constructor<'_>> =\n+            matrix.heads().flat_map(|p| pat_constructors(cx, p, pcx).unwrap_or(vec![])).collect();\n         debug!(\"used_ctors = {:#?}\", used_ctors);\n         // `all_ctors` are all the constructors for the given type, which\n         // should all be represented (or caught with the wild pattern `_`).\n@@ -1572,9 +1604,8 @@ fn is_useful_specialized<'p, 'a, 'tcx>(\n     hir_id: HirId,\n ) -> Usefulness<'tcx> {\n     debug!(\"is_useful_specialized({:#?}, {:#?}, {:?})\", v, ctor, lty);\n-    let sub_pat_tys = constructor_sub_pattern_tys(cx, &ctor, lty);\n-    let wild_patterns_owned: Vec<_> =\n-        sub_pat_tys.iter().map(|ty| Pat { ty, span: DUMMY_SP, kind: box PatKind::Wild }).collect();\n+\n+    let wild_patterns_owned = ctor.wildcard_subpatterns(cx, lty);\n     let wild_patterns: Vec<_> = wild_patterns_owned.iter().collect();\n     let matrix = matrix.specialize_constructor(cx, &ctor, &wild_patterns);\n     match v.specialize_constructor(cx, &ctor, &wild_patterns) {\n@@ -1637,26 +1668,6 @@ fn pat_constructors<'tcx>(\n     }\n }\n \n-/// This computes the arity of a constructor. The arity of a constructor\n-/// is how many subpattern patterns of that constructor should be expanded to.\n-///\n-/// For instance, a tuple pattern `(_, 42, Some([]))` has the arity of 3.\n-/// A struct pattern's arity is the number of fields it contains, etc.\n-fn constructor_arity(cx: &MatchCheckCtxt<'a, 'tcx>, ctor: &Constructor<'tcx>, ty: Ty<'tcx>) -> u64 {\n-    debug!(\"constructor_arity({:#?}, {:?})\", ctor, ty);\n-    match ty.kind {\n-        ty::Tuple(ref fs) => fs.len() as u64,\n-        ty::Slice(..) | ty::Array(..) => match *ctor {\n-            Slice(length) => length,\n-            ConstantValue(..) => 0,\n-            _ => bug!(\"bad slice pattern {:?} {:?}\", ctor, ty),\n-        },\n-        ty::Ref(..) => 1,\n-        ty::Adt(adt, _) => adt.variants[ctor.variant_index_for_adt(cx, adt)].fields.len() as u64,\n-        _ => 0,\n-    }\n-}\n-\n /// This computes the types of the sub patterns that a constructor should be\n /// expanded to.\n ///\n@@ -1833,7 +1844,7 @@ fn split_grouped_constructors<'p, 'tcx>(\n     tcx: TyCtxt<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     ctors: Vec<Constructor<'tcx>>,\n-    &Matrix(ref m): &Matrix<'p, 'tcx>,\n+    matrix: &Matrix<'p, 'tcx>,\n     ty: Ty<'tcx>,\n     span: Span,\n     hir_id: Option<HirId>,\n@@ -1875,7 +1886,8 @@ fn split_grouped_constructors<'p, 'tcx>(\n                 let mut overlaps = vec![];\n                 // `borders` is the set of borders between equivalence classes: each equivalence\n                 // class lies between 2 borders.\n-                let row_borders = m\n+                let row_borders = matrix\n+                    .0\n                     .iter()\n                     .flat_map(|row| {\n                         IntRange::from_pat(tcx, param_env, row.head()).map(|r| (r, row.len()))"}]}