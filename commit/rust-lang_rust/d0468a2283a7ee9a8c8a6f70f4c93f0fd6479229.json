{"sha": "d0468a2283a7ee9a8c8a6f70f4c93f0fd6479229", "node_id": "C_kwDOAAsO6NoAKGQwNDY4YTIyODNhN2VlOWE4YzhhNmY3MGY0YzkzZjBmZDY0NzkyMjk", "commit": {"author": {"name": "AndyJado", "email": "101876416+AndyJado@users.noreply.github.com", "date": "2023-02-10T08:58:32Z"}, "committer": {"name": "AndyJado", "email": "101876416+AndyJado@users.noreply.github.com", "date": "2023-04-13T01:43:46Z"}, "message": "rm var_span_label to var_subdiag & eager subdiag", "tree": {"sha": "486c791e07eaa71c4c69fa49935a5f6b9f78f80a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/486c791e07eaa71c4c69fa49935a5f6b9f78f80a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d0468a2283a7ee9a8c8a6f70f4c93f0fd6479229", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d0468a2283a7ee9a8c8a6f70f4c93f0fd6479229", "html_url": "https://github.com/rust-lang/rust/commit/d0468a2283a7ee9a8c8a6f70f4c93f0fd6479229", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d0468a2283a7ee9a8c8a6f70f4c93f0fd6479229/comments", "author": {"login": "AndyJado", "id": 101876416, "node_id": "U_kgDOBhKCwA", "avatar_url": "https://avatars.githubusercontent.com/u/101876416?v=4", "gravatar_id": "", "url": "https://api.github.com/users/AndyJado", "html_url": "https://github.com/AndyJado", "followers_url": "https://api.github.com/users/AndyJado/followers", "following_url": "https://api.github.com/users/AndyJado/following{/other_user}", "gists_url": "https://api.github.com/users/AndyJado/gists{/gist_id}", "starred_url": "https://api.github.com/users/AndyJado/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/AndyJado/subscriptions", "organizations_url": "https://api.github.com/users/AndyJado/orgs", "repos_url": "https://api.github.com/users/AndyJado/repos", "events_url": "https://api.github.com/users/AndyJado/events{/privacy}", "received_events_url": "https://api.github.com/users/AndyJado/received_events", "type": "User", "site_admin": false}, "committer": {"login": "AndyJado", "id": 101876416, "node_id": "U_kgDOBhKCwA", "avatar_url": "https://avatars.githubusercontent.com/u/101876416?v=4", "gravatar_id": "", "url": "https://api.github.com/users/AndyJado", "html_url": "https://github.com/AndyJado", "followers_url": "https://api.github.com/users/AndyJado/followers", "following_url": "https://api.github.com/users/AndyJado/following{/other_user}", "gists_url": "https://api.github.com/users/AndyJado/gists{/gist_id}", "starred_url": "https://api.github.com/users/AndyJado/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/AndyJado/subscriptions", "organizations_url": "https://api.github.com/users/AndyJado/orgs", "repos_url": "https://api.github.com/users/AndyJado/repos", "events_url": "https://api.github.com/users/AndyJado/events{/privacy}", "received_events_url": "https://api.github.com/users/AndyJado/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9693b178fcebe3cc27129b7bc1237ee5eb706af8", "url": "https://api.github.com/repos/rust-lang/rust/commits/9693b178fcebe3cc27129b7bc1237ee5eb706af8", "html_url": "https://github.com/rust-lang/rust/commit/9693b178fcebe3cc27129b7bc1237ee5eb706af8"}], "stats": {"total": 969, "additions": 729, "deletions": 240}, "files": [{"sha": "8f4e0c171d047023997bb6786ce2f352ec907646", "filename": "compiler/rustc_borrowck/src/diagnostics/conflict_errors.rs", "status": "modified", "additions": 119, "deletions": 69, "changes": 188, "blob_url": "https://github.com/rust-lang/rust/blob/d0468a2283a7ee9a8c8a6f70f4c93f0fd6479229/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0468a2283a7ee9a8c8a6f70f4c93f0fd6479229/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs?ref=d0468a2283a7ee9a8c8a6f70f4c93f0fd6479229", "patch": "@@ -30,8 +30,8 @@ use crate::borrow_set::TwoPhaseActivation;\n use crate::borrowck_errors;\n \n use crate::diagnostics::conflict_errors::StorageDeadOrDrop::LocalStorageDead;\n-use crate::diagnostics::find_all_local_uses;\n use crate::diagnostics::mutability_errors::mut_borrow_of_mutable_ref;\n+use crate::diagnostics::{find_all_local_uses, CapturedMessageOpt};\n use crate::{\n     borrow_set::BorrowData, diagnostics::Instance, prefixes::IsPrefixOf,\n     InitializationRequiringAction, MirBorrowckCtxt, PrefixSet, WriteKind,\n@@ -183,13 +183,9 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 let move_spans = self.move_spans(moved_place.as_ref(), move_out.source);\n                 let move_span = move_spans.args_or_use();\n \n-                let move_msg = if move_spans.for_closure() { \" into closure\" } else { \"\" };\n+                let is_move_msg = move_spans.for_closure();\n \n-                let loop_message = if location == move_out.source || move_site.traversed_back_edge {\n-                    \", in previous iteration of loop\"\n-                } else {\n-                    \"\"\n-                };\n+                let is_loop_message = location == move_out.source || move_site.traversed_back_edge;\n \n                 if location == move_out.source {\n                     is_loop_move = true;\n@@ -206,17 +202,21 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                         );\n                     }\n \n+                    let msg_opt = CapturedMessageOpt {\n+                        is_partial_move,\n+                        is_loop_message,\n+                        is_move_msg,\n+                        is_loop_move,\n+                        maybe_reinitialized_locations_is_empty: maybe_reinitialized_locations\n+                            .is_empty(),\n+                    };\n                     self.explain_captures(\n                         &mut err,\n                         span,\n                         move_span,\n                         move_spans,\n                         *moved_place,\n-                        partially_str,\n-                        loop_message,\n-                        move_msg,\n-                        is_loop_move,\n-                        maybe_reinitialized_locations.is_empty(),\n+                        msg_opt,\n                     );\n                 }\n                 seen_spans.insert(move_span);\n@@ -282,12 +282,21 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             }\n \n             if needs_note {\n-                let span = if let Some(local) = place.as_local() {\n-                    Some(self.body.local_decls[local].source_info.span)\n+                if let Some(local) = place.as_local() {\n+                    let span = self.body.local_decls[local].source_info.span;\n+                    err.subdiagnostic(crate::session_diagnostics::TypeNoCopy::Label {\n+                        is_partial_move,\n+                        ty,\n+                        place: &note_msg,\n+                        span,\n+                    });\n                 } else {\n-                    None\n+                    err.subdiagnostic(crate::session_diagnostics::TypeNoCopy::Note {\n+                        is_partial_move,\n+                        ty,\n+                        place: &note_msg,\n+                    });\n                 };\n-                self.note_type_does_not_implement_copy(&mut err, &note_msg, ty, span, partial_str);\n             }\n \n             if let UseSpans::FnSelfUse {\n@@ -827,11 +836,13 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n \n         borrow_spans.var_path_only_subdiag(&mut err, crate::InitializationRequiringAction::Borrow);\n \n-        move_spans.var_span_label(\n-            &mut err,\n-            format!(\"move occurs due to use{}\", move_spans.describe()),\n-            \"moved\",\n-        );\n+        move_spans.var_subdiag(None, &mut err, None, |kind, var_span| {\n+            use crate::session_diagnostics::CaptureVarCause::*;\n+            match kind {\n+                Some(_) => MoveUseInGenerator { var_span },\n+                None => MoveUseInClosure { var_span },\n+            }\n+        });\n \n         self.explain_why_borrow_contains_point(location, borrow, None)\n             .add_explanation_to_diagnostic(\n@@ -868,13 +879,15 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             borrow_span,\n             &self.describe_any_place(borrow.borrowed_place.as_ref()),\n         );\n-        borrow_spans.var_subdiag(&mut err, Some(borrow.kind), |kind, var_span| {\n+        borrow_spans.var_subdiag(None, &mut err, Some(borrow.kind), |kind, var_span| {\n             use crate::session_diagnostics::CaptureVarCause::*;\n             let place = &borrow.borrowed_place;\n             let desc_place = self.describe_any_place(place.as_ref());\n             match kind {\n-                Some(_) => BorrowUsePlaceGenerator { place: desc_place, var_span },\n-                None => BorrowUsePlaceClosure { place: desc_place, var_span },\n+                Some(_) => {\n+                    BorrowUsePlaceGenerator { place: desc_place, var_span, is_single_var: true }\n+                }\n+                None => BorrowUsePlaceClosure { place: desc_place, var_span, is_single_var: true },\n             }\n         });\n \n@@ -988,16 +1001,26 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                         immutable_section_description,\n                         \"mutably borrow\",\n                     );\n-                    borrow_spans.var_span_label(\n+                    borrow_spans.var_subdiag(\n+                        None,\n                         &mut err,\n-                        format!(\n-                            \"borrow occurs due to use of {}{}\",\n-                            desc_place,\n-                            borrow_spans.describe(),\n-                        ),\n-                        \"immutable\",\n+                        Some(BorrowKind::Unique),\n+                        |kind, var_span| {\n+                            use crate::session_diagnostics::CaptureVarCause::*;\n+                            match kind {\n+                                Some(_) => BorrowUsePlaceGenerator {\n+                                    place: desc_place,\n+                                    var_span,\n+                                    is_single_var: true,\n+                                },\n+                                None => BorrowUsePlaceClosure {\n+                                    place: desc_place,\n+                                    var_span,\n+                                    is_single_var: true,\n+                                },\n+                            }\n+                        },\n                     );\n-\n                     return err;\n                 } else {\n                     first_borrow_desc = \"immutable \";\n@@ -1070,32 +1093,48 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         };\n \n         if issued_spans == borrow_spans {\n-            borrow_spans.var_span_label(\n-                &mut err,\n-                format!(\"borrows occur due to use of {}{}\", desc_place, borrow_spans.describe(),),\n-                gen_borrow_kind.describe_mutability(),\n-            );\n+            borrow_spans.var_subdiag(None, &mut err, Some(gen_borrow_kind), |kind, var_span| {\n+                use crate::session_diagnostics::CaptureVarCause::*;\n+                match kind {\n+                    Some(_) => BorrowUsePlaceGenerator {\n+                        place: desc_place,\n+                        var_span,\n+                        is_single_var: false,\n+                    },\n+                    None => {\n+                        BorrowUsePlaceClosure { place: desc_place, var_span, is_single_var: false }\n+                    }\n+                }\n+            });\n         } else {\n-            let borrow_place = &issued_borrow.borrowed_place;\n-            let borrow_place_desc = self.describe_any_place(borrow_place.as_ref());\n-            issued_spans.var_span_label(\n+            issued_spans.var_subdiag(\n+                Some(&self.infcx.tcx.sess.parse_sess.span_diagnostic),\n                 &mut err,\n-                format!(\n-                    \"first borrow occurs due to use of {}{}\",\n-                    borrow_place_desc,\n-                    issued_spans.describe(),\n-                ),\n-                issued_borrow.kind.describe_mutability(),\n+                Some(issued_borrow.kind),\n+                |kind, var_span| {\n+                    use crate::session_diagnostics::CaptureVarCause::*;\n+                    let borrow_place = &issued_borrow.borrowed_place;\n+                    let borrow_place_desc = self.describe_any_place(borrow_place.as_ref());\n+                    match kind {\n+                        Some(_) => {\n+                            FirstBorrowUsePlaceGenerator { place: borrow_place_desc, var_span }\n+                        }\n+                        None => FirstBorrowUsePlaceClosure { place: borrow_place_desc, var_span },\n+                    }\n+                },\n             );\n \n-            borrow_spans.var_span_label(\n+            borrow_spans.var_subdiag(\n+                Some(&self.infcx.tcx.sess.parse_sess.span_diagnostic),\n                 &mut err,\n-                format!(\n-                    \"second borrow occurs due to use of {}{}\",\n-                    desc_place,\n-                    borrow_spans.describe(),\n-                ),\n-                gen_borrow_kind.describe_mutability(),\n+                Some(gen_borrow_kind),\n+                |kind, var_span| {\n+                    use crate::session_diagnostics::CaptureVarCause::*;\n+                    match kind {\n+                        Some(_) => SecondBorrowUsePlaceGenerator { place: desc_place, var_span },\n+                        None => SecondBorrowUsePlaceClosure { place: desc_place, var_span },\n+                    }\n+                },\n             );\n         }\n \n@@ -1731,9 +1770,12 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             err.span_label(borrow_span, \"borrowed value does not live long enough\");\n             err.span_label(drop_span, format!(\"`{}` dropped here while still borrowed\", name));\n \n-            let within = if borrow_spans.for_generator() { \" by generator\" } else { \"\" };\n-\n-            borrow_spans.args_span_label(&mut err, format!(\"value captured here{}\", within));\n+            borrow_spans.args_subdiag(&mut err, |args_span| {\n+                crate::session_diagnostics::CaptureArgLabel::Capture {\n+                    is_within: borrow_spans.for_generator(),\n+                    args_span,\n+                }\n+            });\n \n             explanation.add_explanation_to_diagnostic(\n                 self.infcx.tcx,\n@@ -1947,9 +1989,12 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             None,\n         );\n \n-        let within = if borrow_spans.for_generator() { \" by generator\" } else { \"\" };\n-\n-        borrow_spans.args_span_label(&mut err, format!(\"value captured here{}\", within));\n+        borrow_spans.args_subdiag(&mut err, |args_span| {\n+            crate::session_diagnostics::CaptureArgLabel::Capture {\n+                is_within: borrow_spans.for_generator(),\n+                args_span,\n+            }\n+        });\n \n         err\n     }\n@@ -2382,11 +2427,14 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     section,\n                     \"assign\",\n                 );\n-                loan_spans.var_span_label(\n-                    &mut err,\n-                    format!(\"borrow occurs due to use{}\", loan_spans.describe()),\n-                    loan.kind.describe_mutability(),\n-                );\n+\n+                loan_spans.var_subdiag(None, &mut err, Some(loan.kind), |kind, var_span| {\n+                    use crate::session_diagnostics::CaptureVarCause::*;\n+                    match kind {\n+                        Some(_) => BorrowUseInGenerator { var_span },\n+                        None => BorrowUseInClosure { var_span },\n+                    }\n+                });\n \n                 self.buffer_error(err);\n \n@@ -2396,11 +2444,13 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n \n         let mut err = self.cannot_assign_to_borrowed(span, loan_span, &descr_place);\n \n-        loan_spans.var_span_label(\n-            &mut err,\n-            format!(\"borrow occurs due to use{}\", loan_spans.describe()),\n-            loan.kind.describe_mutability(),\n-        );\n+        loan_spans.var_subdiag(None, &mut err, Some(loan.kind), |kind, var_span| {\n+            use crate::session_diagnostics::CaptureVarCause::*;\n+            match kind {\n+                Some(_) => BorrowUseInGenerator { var_span },\n+                None => BorrowUseInClosure { var_span },\n+            }\n+        });\n \n         self.explain_why_borrow_contains_point(location, loan, None).add_explanation_to_diagnostic(\n             self.infcx.tcx,"}, {"sha": "6a8755f8ad521d5434718d7233cc9ebfafb0e928", "filename": "compiler/rustc_borrowck/src/diagnostics/mod.rs", "status": "modified", "additions": 103, "deletions": 143, "changes": 246, "blob_url": "https://github.com/rust-lang/rust/blob/d0468a2283a7ee9a8c8a6f70f4c93f0fd6479229/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0468a2283a7ee9a8c8a6f70f4c93f0fd6479229/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs?ref=d0468a2283a7ee9a8c8a6f70f4c93f0fd6479229", "patch": "@@ -1,5 +1,9 @@\n //! Borrow checker diagnostics.\n \n+use crate::session_diagnostics::{\n+    CaptureArgLabel, CaptureReasonLabel, CaptureReasonNote, CaptureReasonSuggest, CaptureVarCause,\n+    CaptureVarKind, CaptureVarPathUseCause, OnClosureNote,\n+};\n use itertools::Itertools;\n use rustc_const_eval::util::{call_kind, CallDesugaringKind};\n use rustc_errors::{Applicability, Diagnostic};\n@@ -117,13 +121,15 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     if let ty::Closure(did, _) = self.body.local_decls[closure].ty.kind() {\n                         let did = did.expect_local();\n                         if let Some((span, hir_place)) = self.infcx.tcx.closure_kind_origin(did) {\n-                            diag.span_note(\n-                                *span,\n-                                &format!(\n-                                    \"closure cannot be invoked more than once because it moves the \\\n-                                    variable `{}` out of its environment\",\n-                                    ty::place_to_string_for_capture(self.infcx.tcx, hir_place)\n-                                ),\n+                            diag.eager_subdiagnostic(\n+                                &self.infcx.tcx.sess.parse_sess.span_diagnostic,\n+                                OnClosureNote::InvokedTwice {\n+                                    place_name: &ty::place_to_string_for_capture(\n+                                        self.infcx.tcx,\n+                                        hir_place,\n+                                    ),\n+                                    span: *span,\n+                                },\n                             );\n                             return true;\n                         }\n@@ -137,13 +143,12 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             if let ty::Closure(did, _) = self.body.local_decls[target].ty.kind() {\n                 let did = did.expect_local();\n                 if let Some((span, hir_place)) = self.infcx.tcx.closure_kind_origin(did) {\n-                    diag.span_note(\n-                        *span,\n-                        &format!(\n-                            \"closure cannot be moved more than once as it is not `Copy` due to \\\n-                             moving the variable `{}` out of its environment\",\n-                            ty::place_to_string_for_capture(self.infcx.tcx, hir_place)\n-                        ),\n+                    diag.eager_subdiagnostic(\n+                        &self.infcx.tcx.sess.parse_sess.span_diagnostic,\n+                        OnClosureNote::MovedTwice {\n+                            place_name: &ty::place_to_string_for_capture(self.infcx.tcx, hir_place),\n+                            span: *span,\n+                        },\n                     );\n                     return true;\n                 }\n@@ -380,25 +385,6 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         }\n     }\n \n-    /// Add a note that a type does not implement `Copy`\n-    pub(super) fn note_type_does_not_implement_copy(\n-        &self,\n-        err: &mut Diagnostic,\n-        place_desc: &str,\n-        ty: Ty<'tcx>,\n-        span: Option<Span>,\n-        move_prefix: &str,\n-    ) {\n-        let message = format!(\n-            \"{move_prefix}move occurs because {place_desc} has type `{ty}`, which does not implement the `Copy` trait\",\n-        );\n-        if let Some(span) = span {\n-            err.span_label(span, message);\n-        } else {\n-            err.note(&message);\n-        }\n-    }\n-\n     pub(super) fn borrowed_content_source(\n         &self,\n         deref_base: PlaceRef<'tcx>,\n@@ -582,9 +568,13 @@ impl UseSpans<'_> {\n     }\n \n     /// Add a span label to the arguments of the closure, if it exists.\n-    pub(super) fn args_span_label(self, err: &mut Diagnostic, message: impl Into<String>) {\n+    pub(super) fn args_subdiag(\n+        self,\n+        err: &mut Diagnostic,\n+        f: impl FnOnce(Span) -> CaptureArgLabel,\n+    ) {\n         if let UseSpans::ClosureUse { args_span, .. } = self {\n-            err.span_label(args_span, message);\n+            err.subdiagnostic(f(args_span));\n         }\n     }\n \n@@ -595,8 +585,8 @@ impl UseSpans<'_> {\n         err: &mut Diagnostic,\n         action: crate::InitializationRequiringAction,\n     ) {\n-        use crate::session_diagnostics::CaptureVarPathUseCause::*;\n         use crate::InitializationRequiringAction::*;\n+        use CaptureVarPathUseCause::*;\n         if let UseSpans::ClosureUse { generator_kind, path_span, .. } = self {\n             match generator_kind {\n                 Some(_) => {\n@@ -619,52 +609,36 @@ impl UseSpans<'_> {\n         }\n     }\n \n-    /// Add a span label to the use of the captured variable, if it exists.\n-    pub(super) fn var_span_label(\n-        self,\n-        err: &mut Diagnostic,\n-        message: impl Into<String>,\n-        kind_desc: impl Into<String>,\n-    ) {\n-        if let UseSpans::ClosureUse { capture_kind_span, path_span, .. } = self {\n-            if capture_kind_span == path_span {\n-                err.span_label(capture_kind_span, message);\n-            } else {\n-                let capture_kind_label =\n-                    format!(\"capture is {} because of use here\", kind_desc.into());\n-                let path_label = message;\n-                err.span_label(capture_kind_span, capture_kind_label);\n-                err.span_label(path_span, path_label);\n-            }\n-        }\n-    }\n-\n     /// Add a subdiagnostic to the use of the captured variable, if it exists.\n     pub(super) fn var_subdiag(\n         self,\n+        handler: Option<&rustc_errors::Handler>,\n         err: &mut Diagnostic,\n         kind: Option<rustc_middle::mir::BorrowKind>,\n-        f: impl Fn(Option<GeneratorKind>, Span) -> crate::session_diagnostics::CaptureVarCause,\n+        f: impl FnOnce(Option<GeneratorKind>, Span) -> CaptureVarCause,\n     ) {\n-        use crate::session_diagnostics::CaptureVarKind::*;\n         if let UseSpans::ClosureUse { generator_kind, capture_kind_span, path_span, .. } = self {\n             if capture_kind_span != path_span {\n                 err.subdiagnostic(match kind {\n                     Some(kd) => match kd {\n                         rustc_middle::mir::BorrowKind::Shared\n                         | rustc_middle::mir::BorrowKind::Shallow\n                         | rustc_middle::mir::BorrowKind::Unique => {\n-                            Immute { kind_span: capture_kind_span }\n+                            CaptureVarKind::Immut { kind_span: capture_kind_span }\n                         }\n \n                         rustc_middle::mir::BorrowKind::Mut { .. } => {\n-                            Mut { kind_span: capture_kind_span }\n+                            CaptureVarKind::Mut { kind_span: capture_kind_span }\n                         }\n                     },\n-                    None => Move { kind_span: capture_kind_span },\n+                    None => CaptureVarKind::Move { kind_span: capture_kind_span },\n                 });\n             };\n-            err.subdiagnostic(f(generator_kind, path_span));\n+            let diag = f(generator_kind, path_span);\n+            match handler {\n+                Some(hd) => err.eager_subdiagnostic(hd, diag),\n+                None => err.subdiagnostic(diag),\n+            };\n         }\n     }\n \n@@ -684,20 +658,6 @@ impl UseSpans<'_> {\n         }\n     }\n \n-    /// Describe the span associated with a use of a place.\n-    pub(super) fn describe(&self) -> &str {\n-        match *self {\n-            UseSpans::ClosureUse { generator_kind, .. } => {\n-                if generator_kind.is_some() {\n-                    \" in generator\"\n-                } else {\n-                    \" in closure\"\n-                }\n-            }\n-            _ => \"\",\n-        }\n-    }\n-\n     pub(super) fn or_else<F>(self, if_other: F) -> Self\n     where\n         F: FnOnce() -> Self,\n@@ -788,6 +748,15 @@ impl<'tcx> BorrowedContentSource<'tcx> {\n     }\n }\n \n+///helper struct for explain_captures()\n+struct CapturedMessageOpt {\n+    is_partial_move: bool,\n+    is_loop_message: bool,\n+    is_move_msg: bool,\n+    is_loop_move: bool,\n+    maybe_reinitialized_locations_is_empty: bool,\n+}\n+\n impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     /// Finds the spans associated to a move or copy of move_place at location.\n     pub(super) fn move_spans(\n@@ -1027,12 +996,15 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         move_span: Span,\n         move_spans: UseSpans<'tcx>,\n         moved_place: Place<'tcx>,\n-        partially_str: &str,\n-        loop_message: &str,\n-        move_msg: &str,\n-        is_loop_move: bool,\n-        maybe_reinitialized_locations_is_empty: bool,\n+        msg_opt: CapturedMessageOpt,\n     ) {\n+        let CapturedMessageOpt {\n+            is_partial_move: is_partial,\n+            is_loop_message,\n+            is_move_msg,\n+            is_loop_move,\n+            maybe_reinitialized_locations_is_empty,\n+        } = msg_opt;\n         if let UseSpans::FnSelfUse { var_span, fn_call_span, fn_span, kind } = move_spans {\n             let place_name = self\n                 .describe_place(moved_place.as_ref())\n@@ -1042,30 +1014,26 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 CallKind::FnCall { fn_trait_id, .. }\n                     if Some(fn_trait_id) == self.infcx.tcx.lang_items().fn_once_trait() =>\n                 {\n-                    err.span_label(\n+                    err.subdiagnostic(CaptureReasonLabel::Call {\n                         fn_call_span,\n-                        &format!(\n-                            \"{place_name} {partially_str}moved due to this call{loop_message}\",\n-                        ),\n-                    );\n-                    err.span_note(\n-                        var_span,\n-                        \"this value implements `FnOnce`, which causes it to be moved when called\",\n-                    );\n+                        place_name: &place_name,\n+                        is_partial,\n+                        is_loop_message,\n+                    });\n+                    err.subdiagnostic(CaptureReasonNote::FnOnceMoveInCall { var_span });\n                 }\n                 CallKind::Operator { self_arg, .. } => {\n                     let self_arg = self_arg.unwrap();\n-                    err.span_label(\n+                    err.subdiagnostic(CaptureReasonLabel::OperatorUse {\n                         fn_call_span,\n-                        &format!(\n-                            \"{place_name} {partially_str}moved due to usage in operator{loop_message}\",\n-                        ),\n-                    );\n+                        place_name: &place_name,\n+                        is_partial,\n+                        is_loop_message,\n+                    });\n                     if self.fn_self_span_reported.insert(fn_span) {\n-                        err.span_note(\n-                            self_arg.span,\n-                            \"calling this operator moves the left-hand side\",\n-                        );\n+                        err.subdiagnostic(CaptureReasonNote::LhsMoveByOperator {\n+                            span: self_arg.span,\n+                        });\n                     }\n                 }\n                 CallKind::Normal { self_arg, desugaring, method_did, method_substs } => {\n@@ -1086,23 +1054,18 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                             _ => false,\n                         };\n                         if suggest {\n-                            err.span_suggestion_verbose(\n-                                move_span.shrink_to_lo(),\n-                                &format!(\n-                                    \"consider iterating over a slice of the `{ty}`'s content to \\\n-                                     avoid moving into the `for` loop\",\n-                                ),\n-                                \"&\",\n-                                Applicability::MaybeIncorrect,\n-                            );\n+                            err.subdiagnostic(CaptureReasonSuggest::IterateSlice {\n+                                ty,\n+                                span: move_span.shrink_to_lo(),\n+                            });\n                         }\n \n-                        err.span_label(\n+                        err.subdiagnostic(CaptureReasonLabel::ImplicitCall {\n                             fn_call_span,\n-                            &format!(\n-                                \"{place_name} {partially_str}moved due to this implicit call to `.into_iter()`{loop_message}\",\n-                            ),\n-                        );\n+                            place_name: &place_name,\n+                            is_partial,\n+                            is_loop_message,\n+                        });\n                         // If the moved place was a `&mut` ref, then we can\n                         // suggest to reborrow it where it was moved, so it\n                         // will still be valid by the time we get to the usage.\n@@ -1125,13 +1088,12 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                             }\n                         }\n                     } else {\n-                        err.span_label(\n+                        err.subdiagnostic(CaptureReasonLabel::MethodCall {\n                             fn_call_span,\n-                            &format!(\n-                                \"{place_name} {partially_str}moved due to this method call{loop_message}\",\n-                            ),\n-                        );\n-\n+                            place_name: &place_name,\n+                            is_partial,\n+                            is_loop_message,\n+                        });\n                         let infcx = tcx.infer_ctxt().build();\n                         // Erase and shadow everything that could be passed to the new infcx.\n                         let ty = tcx.erase_regions(moved_place.ty(self.body, tcx).ty);\n@@ -1147,12 +1109,11 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                             )\n                             && infcx.can_eq(self.param_env, ty, self_ty)\n                         {\n-                            err.span_suggestion_verbose(\n-                                fn_call_span.shrink_to_lo(),\n-                                \"consider reborrowing the `Pin` instead of moving it\",\n-                                \"as_mut().\".to_string(),\n-                                Applicability::MaybeIncorrect,\n-                            );\n+                            err.eager_subdiagnostic(\n+                                &self.infcx.tcx.sess.parse_sess.span_diagnostic,\n+                                CaptureReasonSuggest::FreshReborrow {\n+                                    span: fn_call_span.shrink_to_lo(),\n+                                });\n                         }\n                         if let Some(clone_trait) = tcx.lang_items().clone_trait()\n                             && let trait_ref = tcx.mk_trait_ref(clone_trait, [ty])\n@@ -1177,10 +1138,11 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     // error messages.\n                     if span != DUMMY_SP && self.fn_self_span_reported.insert(self_arg.span) {\n                         let func = tcx.def_path_str(method_did);\n-                        err.span_note(\n-                            self_arg.span,\n-                            &format!(\"`{func}` takes ownership of the receiver `self`, which moves {place_name}\")\n-                        );\n+                        err.subdiagnostic(CaptureReasonNote::FuncTakeSelf {\n+                            func,\n+                            place_name,\n+                            span: self_arg.span,\n+                        });\n                     }\n                     let parent_did = tcx.parent(method_did);\n                     let parent_self_ty =\n@@ -1194,30 +1156,28 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                         matches!(tcx.get_diagnostic_name(def_id), Some(sym::Option | sym::Result))\n                     });\n                     if is_option_or_result && maybe_reinitialized_locations_is_empty {\n-                        err.span_label(\n-                            var_span,\n-                            \"help: consider calling `.as_ref()` or `.as_mut()` to borrow the type's contents\",\n-                        );\n+                        err.subdiagnostic(CaptureReasonLabel::BorrowContent { var_span });\n                     }\n                 }\n                 // Other desugarings takes &self, which cannot cause a move\n                 _ => {}\n             }\n         } else {\n-            if move_span != span || !loop_message.is_empty() {\n-                err.span_label(\n+            if move_span != span || is_loop_message {\n+                err.subdiagnostic(CaptureReasonLabel::MovedHere {\n                     move_span,\n-                    format!(\"value {partially_str}moved{move_msg} here{loop_message}\"),\n-                );\n+                    is_partial,\n+                    is_move_msg,\n+                    is_loop_message,\n+                });\n             }\n             // If the move error occurs due to a loop, don't show\n             // another message for the same span\n-            if loop_message.is_empty() {\n-                move_spans.var_span_label(\n-                    err,\n-                    format!(\"variable {partially_str}moved due to use{}\", move_spans.describe()),\n-                    \"moved\",\n-                );\n+            if !is_loop_message {\n+                move_spans.var_subdiag(None, err, None, |kind, var_span| match kind {\n+                    Some(_) => CaptureVarCause::PartialMoveUseInGenerator { var_span, is_partial },\n+                    None => CaptureVarCause::PartialMoveUseInClosure { var_span, is_partial },\n+                })\n             }\n         }\n     }"}, {"sha": "67af96a71e30d715a83115a26155241d4cf5d0ab", "filename": "compiler/rustc_borrowck/src/diagnostics/move_errors.rs", "status": "modified", "additions": 34, "deletions": 19, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/d0468a2283a7ee9a8c8a6f70f4c93f0fd6479229/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmove_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0468a2283a7ee9a8c8a6f70f4c93f0fd6479229/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmove_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmove_errors.rs?ref=d0468a2283a7ee9a8c8a6f70f4c93f0fd6479229", "patch": "@@ -6,6 +6,7 @@ use rustc_mir_dataflow::move_paths::{\n };\n use rustc_span::{BytePos, Span};\n \n+use crate::diagnostics::CapturedMessageOpt;\n use crate::diagnostics::{DescribePlaceOpt, UseSpans};\n use crate::prefixes::PrefixSet;\n use crate::MirBorrowckCtxt;\n@@ -397,10 +398,15 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                 }\n             }\n         };\n+        let msg_opt = CapturedMessageOpt {\n+            is_partial_move: false,\n+            is_loop_message: false,\n+            is_move_msg: false,\n+            is_loop_move: false,\n+            maybe_reinitialized_locations_is_empty: true,\n+        };\n         if let Some(use_spans) = use_spans {\n-            self.explain_captures(\n-                &mut err, span, span, use_spans, move_place, \"\", \"\", \"\", false, true,\n-            );\n+            self.explain_captures(&mut err, span, span, use_spans, move_place, msg_opt);\n         }\n         err\n     }\n@@ -416,13 +422,12 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                         None => \"value\".to_string(),\n                     };\n \n-                    self.note_type_does_not_implement_copy(\n-                        err,\n-                        &place_desc,\n-                        place_ty,\n-                        Some(span),\n-                        \"\",\n-                    );\n+                    err.subdiagnostic(crate::session_diagnostics::TypeNoCopy::Label {\n+                        is_partial_move: false,\n+                        ty: place_ty,\n+                        place: &place_desc,\n+                        span,\n+                    });\n                 } else {\n                     binds_to.sort();\n                     binds_to.dedup();\n@@ -444,9 +449,19 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                     Some(desc) => format!(\"`{desc}`\"),\n                     None => \"value\".to_string(),\n                 };\n-                self.note_type_does_not_implement_copy(err, &place_desc, place_ty, Some(span), \"\");\n+                err.subdiagnostic(crate::session_diagnostics::TypeNoCopy::Label {\n+                    is_partial_move: false,\n+                    ty: place_ty,\n+                    place: &place_desc,\n+                    span,\n+                });\n \n-                use_spans.args_span_label(err, format!(\"{place_desc} is moved here\"));\n+                use_spans.args_subdiag(err, |args_span| {\n+                    crate::session_diagnostics::CaptureArgLabel::MoveOutPlace {\n+                        place: place_desc,\n+                        args_span,\n+                    }\n+                });\n             }\n         }\n     }\n@@ -534,13 +549,13 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             }\n \n             if binds_to.len() == 1 {\n-                self.note_type_does_not_implement_copy(\n-                    err,\n-                    &format!(\"`{}`\", self.local_names[*local].unwrap()),\n-                    bind_to.ty,\n-                    Some(binding_span),\n-                    \"\",\n-                );\n+                let place_desc = &format!(\"`{}`\", self.local_names[*local].unwrap());\n+                err.subdiagnostic(crate::session_diagnostics::TypeNoCopy::Label {\n+                    is_partial_move: false,\n+                    ty: bind_to.ty,\n+                    place: &place_desc,\n+                    span: binding_span,\n+                });\n             }\n         }\n "}, {"sha": "aa5c10de62ce5d9dfa09f97e9d18b7941353c7a0", "filename": "compiler/rustc_borrowck/src/diagnostics/mutability_errors.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d0468a2283a7ee9a8c8a6f70f4c93f0fd6479229/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0468a2283a7ee9a8c8a6f70f4c93f0fd6479229/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs?ref=d0468a2283a7ee9a8c8a6f70f4c93f0fd6479229", "patch": "@@ -231,14 +231,18 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                     }\n                 }\n                 if suggest {\n-                    borrow_spans.var_span_label(\n-                        &mut err,\n-                        format!(\n-                            \"mutable borrow occurs due to use of {} in closure\",\n-                            self.describe_any_place(access_place.as_ref()),\n-                        ),\n-                        \"mutable\",\n-                    );\n+                    borrow_spans.var_subdiag(\n+                    None,\n+                    &mut err,\n+                    Some(mir::BorrowKind::Mut { allow_two_phase_borrow: false }),\n+                    |_kind, var_span| {\n+                        let place = self.describe_any_place(access_place.as_ref());\n+                        crate::session_diagnostics::CaptureVarCause::MutableBorrowUsePlaceClosure {\n+                            place,\n+                            var_span,\n+                        }\n+                    },\n+                );\n                 }\n                 borrow_span\n             }"}, {"sha": "bb95101845f3e0eead5e28c24224b18ba3b4e3d6", "filename": "compiler/rustc_borrowck/src/session_diagnostics.rs", "status": "modified", "additions": 206, "deletions": 1, "changes": 207, "blob_url": "https://github.com/rust-lang/rust/blob/d0468a2283a7ee9a8c8a6f70f4c93f0fd6479229/compiler%2Frustc_borrowck%2Fsrc%2Fsession_diagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0468a2283a7ee9a8c8a6f70f4c93f0fd6479229/compiler%2Frustc_borrowck%2Fsrc%2Fsession_diagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fsession_diagnostics.rs?ref=d0468a2283a7ee9a8c8a6f70f4c93f0fd6479229", "patch": "@@ -184,7 +184,7 @@ pub(crate) enum CaptureVarPathUseCause {\n #[derive(Subdiagnostic)]\n pub(crate) enum CaptureVarKind {\n     #[label(borrowck_capture_immute)]\n-    Immute {\n+    Immut {\n         #[primary_span]\n         kind_span: Span,\n     },\n@@ -204,16 +204,80 @@ pub(crate) enum CaptureVarKind {\n pub(crate) enum CaptureVarCause {\n     #[label(borrowck_var_borrow_by_use_place_in_generator)]\n     BorrowUsePlaceGenerator {\n+        is_single_var: bool,\n         place: String,\n         #[primary_span]\n         var_span: Span,\n     },\n     #[label(borrowck_var_borrow_by_use_place_in_closure)]\n     BorrowUsePlaceClosure {\n+        is_single_var: bool,\n         place: String,\n         #[primary_span]\n         var_span: Span,\n     },\n+    #[label(borrowck_var_borrow_by_use_in_generator)]\n+    BorrowUseInGenerator {\n+        #[primary_span]\n+        var_span: Span,\n+    },\n+    #[label(borrowck_var_borrow_by_use_in_closure)]\n+    BorrowUseInClosure {\n+        #[primary_span]\n+        var_span: Span,\n+    },\n+    #[label(borrowck_var_move_by_use_in_generator)]\n+    MoveUseInGenerator {\n+        #[primary_span]\n+        var_span: Span,\n+    },\n+    #[label(borrowck_var_move_by_use_in_closure)]\n+    MoveUseInClosure {\n+        #[primary_span]\n+        var_span: Span,\n+    },\n+    #[label(borrowck_var_first_borrow_by_use_place_in_generator)]\n+    FirstBorrowUsePlaceGenerator {\n+        place: String,\n+        #[primary_span]\n+        var_span: Span,\n+    },\n+    #[label(borrowck_var_first_borrow_by_use_place_in_closure)]\n+    FirstBorrowUsePlaceClosure {\n+        place: String,\n+        #[primary_span]\n+        var_span: Span,\n+    },\n+    #[label(borrowck_var_second_borrow_by_use_place_in_generator)]\n+    SecondBorrowUsePlaceGenerator {\n+        place: String,\n+        #[primary_span]\n+        var_span: Span,\n+    },\n+    #[label(borrowck_var_second_borrow_by_use_place_in_closure)]\n+    SecondBorrowUsePlaceClosure {\n+        place: String,\n+        #[primary_span]\n+        var_span: Span,\n+    },\n+    #[label(borrowck_var_mutable_borrow_by_use_place_in_closure)]\n+    MutableBorrowUsePlaceClosure {\n+        place: String,\n+        #[primary_span]\n+        var_span: Span,\n+    },\n+    #[label(borrowck_partial_var_move_by_use_in_generator)]\n+    PartialMoveUseInGenerator {\n+        #[primary_span]\n+        var_span: Span,\n+        is_partial: bool,\n+    },\n+    #[label(borrowck_partial_var_move_by_use_in_closure)]\n+    PartialMoveUseInClosure {\n+        #[primary_span]\n+        var_span: Span,\n+        is_partial: bool,\n+    },\n }\n \n #[derive(Diagnostic)]\n@@ -239,3 +303,144 @@ pub(crate) struct NonGenericOpaqueTypeParam<'a, 'tcx> {\n     #[label]\n     pub param_span: Span,\n }\n+\n+#[derive(Subdiagnostic)]\n+pub(crate) enum CaptureReasonLabel<'a> {\n+    #[label(borrowck_moved_due_to_call)]\n+    Call {\n+        #[primary_span]\n+        fn_call_span: Span,\n+        place_name: &'a str,\n+        is_partial: bool,\n+        is_loop_message: bool,\n+    },\n+    #[label(borrowck_moved_due_to_usage_in_operator)]\n+    OperatorUse {\n+        #[primary_span]\n+        fn_call_span: Span,\n+        place_name: &'a str,\n+        is_partial: bool,\n+        is_loop_message: bool,\n+    },\n+    #[label(borrowck_moved_due_to_implicit_into_iter_call)]\n+    ImplicitCall {\n+        #[primary_span]\n+        fn_call_span: Span,\n+        place_name: &'a str,\n+        is_partial: bool,\n+        is_loop_message: bool,\n+    },\n+    #[label(borrowck_moved_due_to_method_call)]\n+    MethodCall {\n+        #[primary_span]\n+        fn_call_span: Span,\n+        place_name: &'a str,\n+        is_partial: bool,\n+        is_loop_message: bool,\n+    },\n+    #[label(borrowck_value_moved_here)]\n+    MovedHere {\n+        #[primary_span]\n+        move_span: Span,\n+        is_partial: bool,\n+        is_move_msg: bool,\n+        is_loop_message: bool,\n+    },\n+    #[label(borrowck_consider_borrow_type_contents)]\n+    BorrowContent {\n+        #[primary_span]\n+        var_span: Span,\n+    },\n+}\n+\n+#[derive(Subdiagnostic)]\n+pub(crate) enum CaptureReasonNote {\n+    #[note(borrowck_moved_a_fn_once_in_call)]\n+    FnOnceMoveInCall {\n+        #[primary_span]\n+        var_span: Span,\n+    },\n+    #[note(borrowck_calling_operator_moves_lhs)]\n+    LhsMoveByOperator {\n+        #[primary_span]\n+        span: Span,\n+    },\n+    #[note(borrowck_func_take_self_moved_place)]\n+    FuncTakeSelf {\n+        func: String,\n+        place_name: String,\n+        #[primary_span]\n+        span: Span,\n+    },\n+}\n+\n+#[derive(Subdiagnostic)]\n+pub(crate) enum CaptureReasonSuggest<'tcx> {\n+    #[suggestion(\n+        borrowck_suggest_iterate_over_slice,\n+        applicability = \"maybe-incorrect\",\n+        code = \"&\",\n+        style = \"verbose\"\n+    )]\n+    IterateSlice {\n+        ty: Ty<'tcx>,\n+        #[primary_span]\n+        span: Span,\n+    },\n+    #[suggestion(\n+        borrowck_suggest_create_freash_reborrow,\n+        applicability = \"maybe-incorrect\",\n+        code = \"as_mut().\",\n+        style = \"verbose\"\n+    )]\n+    FreshReborrow {\n+        #[primary_span]\n+        span: Span,\n+    },\n+}\n+\n+#[derive(Subdiagnostic)]\n+pub(crate) enum CaptureArgLabel {\n+    #[label(borrowck_value_capture_here)]\n+    Capture {\n+        is_within: bool,\n+        #[primary_span]\n+        args_span: Span,\n+    },\n+    #[label(borrowck_move_out_place_here)]\n+    MoveOutPlace {\n+        place: String,\n+        #[primary_span]\n+        args_span: Span,\n+    },\n+}\n+\n+#[derive(Subdiagnostic)]\n+pub(crate) enum OnClosureNote<'a> {\n+    #[note(borrowck_closure_invoked_twice)]\n+    InvokedTwice {\n+        place_name: &'a str,\n+        #[primary_span]\n+        span: Span,\n+    },\n+    #[note(borrowck_closure_moved_twice)]\n+    MovedTwice {\n+        place_name: &'a str,\n+        #[primary_span]\n+        span: Span,\n+    },\n+}\n+\n+#[derive(Subdiagnostic)]\n+pub(crate) enum TypeNoCopy<'a, 'tcx> {\n+    #[label(borrowck_ty_no_impl_copy)]\n+    Label {\n+        is_partial_move: bool,\n+        ty: Ty<'tcx>,\n+        place: &'a str,\n+        #[primary_span]\n+        span: Span,\n+    },\n+    #[note(borrowck_ty_no_impl_copy)]\n+    Note { is_partial_move: bool, ty: Ty<'tcx>, place: &'a str },\n+}"}, {"sha": "5072841db57ef8a03be91870ef241f7df7f792d3", "filename": "compiler/rustc_error_messages/locales/en-US/borrowck.ftl", "status": "added", "additions": 255, "deletions": 0, "changes": 255, "blob_url": "https://github.com/rust-lang/rust/blob/d0468a2283a7ee9a8c8a6f70f4c93f0fd6479229/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fborrowck.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/d0468a2283a7ee9a8c8a6f70f4c93f0fd6479229/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fborrowck.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fborrowck.ftl?ref=d0468a2283a7ee9a8c8a6f70f4c93f0fd6479229", "patch": "@@ -0,0 +1,255 @@\n+borrowck_move_unsized =\n+    cannot move a value of type `{$ty}`\n+    .label = the size of `{$ty}` cannot be statically determined\n+\n+borrowck_higher_ranked_lifetime_error =\n+    higher-ranked lifetime error\n+\n+borrowck_could_not_prove =\n+    could not prove `{$predicate}`\n+\n+borrowck_could_not_normalize =\n+    could not normalize `{$value}`\n+\n+borrowck_higher_ranked_subtype_error =\n+    higher-ranked subtype error\n+\n+borrowck_generic_does_not_live_long_enough =\n+    `{$kind}` does not live long enough\n+\n+borrowck_move_borrowed =\n+    cannot move out of `{$desc}` beacause it is borrowed\n+\n+borrowck_var_does_not_need_mut =\n+    variable does not need to be mutable\n+    .suggestion = remove this `mut`\n+\n+borrowck_var_cannot_escape_closure =\n+    captured variable cannot escape `FnMut` closure body\n+    .note = `FnMut` closures only have access to their captured variables while they are executing...\n+    .cannot_escape = ...therefore, they cannot allow references to captured variables to escape\n+\n+borrowck_var_here_defined = variable defined here\n+\n+borrowck_var_here_captured = variable captured here\n+\n+borrowck_closure_inferred_mut = inferred to be a `FnMut` closure\n+\n+borrowck_returned_closure_escaped =\n+    returns a closure that contains a reference to a captured variable, which then escapes the closure body\n+\n+borrowck_returned_async_block_escaped =\n+    returns an `async` block that contains a reference to a captured variable, which then escapes the closure body\n+\n+borrowck_returned_ref_escaped =\n+    returns a reference to a captured variable which escapes the closure body\n+\n+borrowck_lifetime_constraints_error =\n+    lifetime may not live long enough\n+\n+borrowck_returned_lifetime_wrong =\n+    {$mir_def_name} was supposed to return data with lifetime `{$outlived_fr_name}` but it is returning data with lifetime `{$fr_name}`\n+\n+borrowck_returned_lifetime_short =\n+    {$category_desc}requires that `{$free_region_name}` must outlive `{$outlived_fr_name}`\n+\n+borrowck_used_impl_require_static =\n+    the used `impl` has a `'static` requirement\n+\n+borrowck_borrow_due_to_use_generator =\n+    borrow occurs due to use in generator\n+\n+borrowck_use_due_to_use_generator =\n+    use occurs due to use in generator\n+\n+borrowck_assign_due_to_use_generator =\n+    assign occurs due to use in generator\n+\n+borrowck_assign_part_due_to_use_generator =\n+    assign to part occurs due to use in generator\n+\n+borrowck_borrow_due_to_use_closure =\n+    borrow occurs due to use in closure\n+\n+borrowck_use_due_to_use_closure =\n+    use occurs due to use in closure\n+\n+borrowck_assign_due_to_use_closure =\n+    assign occurs due to use in closure\n+\n+borrowck_assign_part_due_to_use_closure =\n+    assign to part occurs due to use in closure\n+\n+borrowck_capture_immute =\n+    capture is immutable because of use here\n+\n+borrowck_capture_mut =\n+    capture is mutable because of use here\n+\n+borrowck_capture_move =\n+    capture is moved because of use here\n+\n+borrowck_var_borrow_by_use_place_in_generator =\n+    {$is_single_var ->\n+        *[true] borrow occurs\n+        [false] borrows occur\n+    } due to use of {$place} in generator\n+\n+borrowck_var_borrow_by_use_place_in_closure =\n+    {$is_single_var ->\n+        *[true] borrow occurs\n+        [false] borrows occur\n+    } due to use of {$place} in closure\n+\n+borrowck_var_borrow_by_use_in_generator =\n+    borrow occurs due to use in generator\n+\n+borrowck_var_borrow_by_use_in_closure =\n+    borrow occurs due to use in closure\n+\n+borrowck_var_move_by_use_place_in_generator =\n+    move occurs due to use of {$place} in generator\n+\n+borrowck_var_move_by_use_place_in_closure =\n+    move occurs due to use of {$place} in closure\n+\n+borrowck_var_move_by_use_in_generator =\n+    move occurs due to use in generator\n+\n+borrowck_var_move_by_use_in_closure =\n+    move occurs due to use in closure\n+\n+borrowck_partial_var_move_by_use_in_generator =\n+    variable {$is_partial ->\n+        [true] partially moved\n+        *[false] moved\n+    } due to use in generator\n+\n+borrowck_partial_var_move_by_use_in_closure =\n+    variable {$is_partial ->\n+        [true] partially moved\n+        *[false] moved\n+    } due to use in closure\n+\n+borrowck_var_first_borrow_by_use_place_in_generator =\n+    first borrow occurs due to use of {$place} in generator\n+\n+borrowck_var_first_borrow_by_use_place_in_closure =\n+    first borrow occurs due to use of {$place} in closure\n+\n+borrowck_var_second_borrow_by_use_place_in_generator =\n+    second borrow occurs due to use of {$place} in generator\n+\n+borrowck_var_second_borrow_by_use_place_in_closure =\n+    second borrow occurs due to use of {$place} in closure\n+\n+borrowck_var_mutable_borrow_by_use_place_in_closure =\n+    mutable borrow occurs due to use of {$place} in closure\n+\n+borrowck_cannot_move_when_borrowed =\n+    cannot move out of {$place ->\n+        [value] value\n+        *[other] {$place}\n+    } because it is borrowed\n+    .label = borrow of {$borrow_place ->\n+        [value] value\n+        *[other] {$borrow_place}\n+    } occurs here\n+    .move_label = move out of {$value_place ->\n+        [value] value\n+        *[other] {$value_place}\n+    } occurs here\n+\n+borrowck_opaque_type_non_generic_param =\n+    expected generic {$kind} parameter, found `{$ty}`\n+    .label = {STREQ($ty, \"'static\") ->\n+        [true] cannot use static lifetime; use a bound lifetime instead or remove the lifetime parameter from the opaque type\n+        *[other] this generic parameter must be used with a generic {$kind} parameter\n+    }\n+\n+borrowck_moved_due_to_call =\n+    {$place_name} {$is_partial ->\n+        [true] partially moved\n+        *[false] moved\n+    } due to this {$is_loop_message ->\n+        [true] call, in previous iteration of loop\n+        *[false] call\n+    }\n+\n+borrowck_moved_due_to_usage_in_operator =\n+    {$place_name} {$is_partial ->\n+        [true] partially moved\n+        *[false] moved\n+    } due to usage in {$is_loop_message ->\n+        [true] operator, in previous iteration of loop\n+        *[false] operator\n+    }\n+\n+borrowck_moved_due_to_implicit_into_iter_call =\n+    {$place_name} {$is_partial ->\n+        [true] partially moved\n+        *[false] moved\n+    } due to this implicit call to {$is_loop_message ->\n+        [true] `.into_iter()`, in previous iteration of loop\n+        *[false] `.into_iter()`\n+    }\n+\n+borrowck_moved_due_to_method_call =\n+    {$place_name} {$is_partial ->\n+        [true] partially moved\n+        *[false] moved\n+    } due to this method {$is_loop_message ->\n+        [true] call, in previous iteration of loop\n+        *[false] call\n+    }\n+\n+borrowck_value_moved_here =\n+    value {$is_partial ->\n+        [true] partially moved\n+        *[false] moved\n+    } {$is_move_msg ->\n+        [true] into closure here\n+        *[false] here\n+    }{$is_loop_message ->\n+        [true] , in previous iteration of loop\n+        *[false] {\"\"}\n+    }\n+\n+borrowck_consider_borrow_type_contents =\n+    help: consider calling `.as_ref()` or `.as_mut()` to borrow the type's contents\n+\n+borrowck_moved_a_fn_once_in_call =\n+    this value implements `FnOnce`, which causes it to be moved when called\n+\n+borrowck_calling_operator_moves_lhs =\n+    calling this operator moves the left-hand side\n+\n+borrowck_func_take_self_moved_place =\n+    `{$func}` takes ownership of the receiver `self`, which moves {$place_name}\n+\n+borrowck_suggest_iterate_over_slice =\n+    consider iterating over a slice of the `{$ty}`'s content to avoid moving into the `for` loop\n+\n+borrowck_suggest_create_freash_reborrow =\n+    consider reborrowing the `Pin` instead of moving it\n+\n+borrowck_value_capture_here =\n+    value captured {$is_within ->\n+        [true] here by generator\n+        *[false] here\n+    }\n+\n+borrowck_move_out_place_here =\n+    {$place} is moved here\n+\n+borrowck_closure_invoked_twice =\n+    closure cannot be invoked more than once because it moves the variable `{$place_name}` out of its environment\n+\n+borrowck_closure_moved_twice =\n+    closure cannot be moved more than once as it is not `Copy` due to moving the variable `{$place_name}` out of its environment\n+\n+borrowck_ty_no_impl_copy =\n+    {$is_partial_move ->\n+        [true] partial move\n+        *[false] move\n+    } occurs because {$place} has type `{$ty}`, which does not implement the `Copy` trait"}]}