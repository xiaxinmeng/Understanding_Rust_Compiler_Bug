{"sha": "d822110d3b5625b9dc80ccc442e06fc3cc851d76", "node_id": "C_kwDOAAsO6NoAKGQ4MjIxMTBkM2I1NjI1YjlkYzgwY2NjNDQyZTA2ZmMzY2M4NTFkNzY", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-12-01T13:21:51Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-12-01T13:21:51Z"}, "message": "Auto merge of #10010 - flip1995:rustup, r=flip1995\n\nRustup\n\nr? `@ghost`\n\nchangelog: none", "tree": {"sha": "b6516bc9c6c1d00562fcc334fd0ef7ab1cfd4538", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b6516bc9c6c1d00562fcc334fd0ef7ab1cfd4538"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d822110d3b5625b9dc80ccc442e06fc3cc851d76", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d822110d3b5625b9dc80ccc442e06fc3cc851d76", "html_url": "https://github.com/rust-lang/rust/commit/d822110d3b5625b9dc80ccc442e06fc3cc851d76", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d822110d3b5625b9dc80ccc442e06fc3cc851d76/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "641ced4eb96d07fba2284fa258ccb987f7afc8a1", "url": "https://api.github.com/repos/rust-lang/rust/commits/641ced4eb96d07fba2284fa258ccb987f7afc8a1", "html_url": "https://github.com/rust-lang/rust/commit/641ced4eb96d07fba2284fa258ccb987f7afc8a1"}, {"sha": "4063712bf45fcb600d23dcaea4540d95311aaa29", "url": "https://api.github.com/repos/rust-lang/rust/commits/4063712bf45fcb600d23dcaea4540d95311aaa29", "html_url": "https://github.com/rust-lang/rust/commit/4063712bf45fcb600d23dcaea4540d95311aaa29"}], "stats": {"total": 449, "additions": 230, "deletions": 219}, "files": [{"sha": "c7c53bc69d0b858982c6d2254e8ca0d01786446f", "filename": "clippy_dev/src/setup/git_hook.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d822110d3b5625b9dc80ccc442e06fc3cc851d76/clippy_dev%2Fsrc%2Fsetup%2Fgit_hook.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d822110d3b5625b9dc80ccc442e06fc3cc851d76/clippy_dev%2Fsrc%2Fsetup%2Fgit_hook.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_dev%2Fsrc%2Fsetup%2Fgit_hook.rs?ref=d822110d3b5625b9dc80ccc442e06fc3cc851d76", "patch": "@@ -6,7 +6,7 @@ use super::verify_inside_clippy_dir;\n /// Rusts setup uses `git rev-parse --git-common-dir` to get the root directory of the repo.\n /// I've decided against this for the sake of simplicity and to make sure that it doesn't install\n /// the hook if `clippy_dev` would be used in the rust tree. The hook also references this tool\n-/// for formatting and should therefor only be used in a normal clone of clippy\n+/// for formatting and should therefore only be used in a normal clone of clippy\n const REPO_GIT_DIR: &str = \".git\";\n const HOOK_SOURCE_FILE: &str = \"util/etc/pre-commit.sh\";\n const HOOK_TARGET_FILE: &str = \".git/hooks/pre-commit\";"}, {"sha": "0710ac0bb0a72468bb8144351560972dcf53a55a", "filename": "clippy_lints/src/attrs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d822110d3b5625b9dc80ccc442e06fc3cc851d76/clippy_lints%2Fsrc%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d822110d3b5625b9dc80ccc442e06fc3cc851d76/clippy_lints%2Fsrc%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fattrs.rs?ref=d822110d3b5625b9dc80ccc442e06fc3cc851d76", "patch": "@@ -5,7 +5,7 @@ use clippy_utils::macros::{is_panic, macro_backtrace};\n use clippy_utils::msrvs::{self, Msrv};\n use clippy_utils::source::{first_line_of_span, is_present_in_source, snippet_opt, without_block_comments};\n use if_chain::if_chain;\n-use rustc_ast::{AttrKind, AttrStyle, Attribute, Lit, LitKind, MetaItemKind, NestedMetaItem};\n+use rustc_ast::{AttrKind, AttrStyle, Attribute, LitKind, MetaItemKind, MetaItemLit, NestedMetaItem};\n use rustc_errors::Applicability;\n use rustc_hir::{\n     Block, Expr, ExprKind, ImplItem, ImplItemKind, Item, ItemKind, StmtKind, TraitFn, TraitItem, TraitItemKind,\n@@ -574,7 +574,7 @@ fn check_attrs(cx: &LateContext<'_>, span: Span, name: Symbol, attrs: &[Attribut\n     }\n }\n \n-fn check_semver(cx: &LateContext<'_>, span: Span, lit: &Lit) {\n+fn check_semver(cx: &LateContext<'_>, span: Span, lit: &MetaItemLit) {\n     if let LitKind::Str(is, _) = lit.kind {\n         if Version::parse(is.as_str()).is_ok() {\n             return;"}, {"sha": "82d368bb8bc2c1e127d74f8c07530e152c2ba84c", "filename": "clippy_lints/src/bool_assert_comparison.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d822110d3b5625b9dc80ccc442e06fc3cc851d76/clippy_lints%2Fsrc%2Fbool_assert_comparison.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d822110d3b5625b9dc80ccc442e06fc3cc851d76/clippy_lints%2Fsrc%2Fbool_assert_comparison.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fbool_assert_comparison.rs?ref=d822110d3b5625b9dc80ccc442e06fc3cc851d76", "patch": "@@ -59,7 +59,7 @@ fn is_impl_not_trait_with_bool_out(cx: &LateContext<'_>, e: &Expr<'_>) -> bool {\n             )\n         })\n         .map_or(false, |assoc_item| {\n-            let proj = cx.tcx.mk_projection(assoc_item.def_id, cx.tcx.mk_substs_trait(ty, &[]));\n+            let proj = cx.tcx.mk_projection(assoc_item.def_id, cx.tcx.mk_substs_trait(ty, []));\n             let nty = cx.tcx.normalize_erasing_regions(cx.param_env, proj);\n \n             nty.is_bool()"}, {"sha": "a6376484914ba11dad3b13e0ef9fe649a9f8493c", "filename": "clippy_lints/src/casts/cast_possible_truncation.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d822110d3b5625b9dc80ccc442e06fc3cc851d76/clippy_lints%2Fsrc%2Fcasts%2Fcast_possible_truncation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d822110d3b5625b9dc80ccc442e06fc3cc851d76/clippy_lints%2Fsrc%2Fcasts%2Fcast_possible_truncation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcasts%2Fcast_possible_truncation.rs?ref=d822110d3b5625b9dc80ccc442e06fc3cc851d76", "patch": "@@ -2,12 +2,11 @@ use clippy_utils::consts::{constant, Constant};\n use clippy_utils::diagnostics::span_lint;\n use clippy_utils::expr_or_init;\n use clippy_utils::ty::{get_discriminant_value, is_isize_or_usize};\n-use rustc_ast::ast;\n-use rustc_attr::IntType;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::{BinOpKind, Expr, ExprKind};\n use rustc_lint::LateContext;\n use rustc_middle::ty::{self, FloatTy, Ty};\n+use rustc_target::abi::IntegerType;\n \n use super::{utils, CAST_ENUM_TRUNCATION, CAST_POSSIBLE_TRUNCATION};\n \n@@ -119,12 +118,7 @@ pub(super) fn check(cx: &LateContext<'_>, expr: &Expr<'_>, cast_expr: &Expr<'_>,\n             };\n             let to_nbits = utils::int_ty_to_nbits(cast_to, cx.tcx);\n \n-            let cast_from_ptr_size = def.repr().int.map_or(true, |ty| {\n-                matches!(\n-                    ty,\n-                    IntType::SignedInt(ast::IntTy::Isize) | IntType::UnsignedInt(ast::UintTy::Usize)\n-                )\n-            });\n+            let cast_from_ptr_size = def.repr().int.map_or(true, |ty| matches!(ty, IntegerType::Pointer(_),));\n             let suffix = match (cast_from_ptr_size, is_isize_or_usize(cast_to)) {\n                 (false, false) if from_nbits > to_nbits => \"\",\n                 (true, false) if from_nbits > to_nbits => \"\","}, {"sha": "b2fe0386f945dd82f8531f7643a6e5c06869f75f", "filename": "clippy_lints/src/crate_in_macro_def.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d822110d3b5625b9dc80ccc442e06fc3cc851d76/clippy_lints%2Fsrc%2Fcrate_in_macro_def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d822110d3b5625b9dc80ccc442e06fc3cc851d76/clippy_lints%2Fsrc%2Fcrate_in_macro_def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcrate_in_macro_def.rs?ref=d822110d3b5625b9dc80ccc442e06fc3cc851d76", "patch": "@@ -55,7 +55,7 @@ impl EarlyLintPass for CrateInMacroDef {\n         if_chain! {\n             if item.attrs.iter().any(is_macro_export);\n             if let ItemKind::MacroDef(macro_def) = &item.kind;\n-            let tts = macro_def.body.inner_tokens();\n+            let tts = macro_def.body.tokens.clone();\n             if let Some(span) = contains_unhygienic_crate_reference(&tts);\n             then {\n                 span_lint_and_sugg("}, {"sha": "38329659e02b76108ed46d071dd49f38c2a04650", "filename": "clippy_lints/src/dereference.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/d822110d3b5625b9dc80ccc442e06fc3cc851d76/clippy_lints%2Fsrc%2Fdereference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d822110d3b5625b9dc80ccc442e06fc3cc851d76/clippy_lints%2Fsrc%2Fdereference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdereference.rs?ref=d822110d3b5625b9dc80ccc442e06fc3cc851d76", "patch": "@@ -26,7 +26,7 @@ use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::mir::{Rvalue, StatementKind};\n use rustc_middle::ty::adjustment::{Adjust, Adjustment, AutoBorrow, AutoBorrowMutability};\n use rustc_middle::ty::{\n-    self, Binder, BoundVariableKind, EarlyBinder, FnSig, GenericArgKind, List, ParamTy, PredicateKind,\n+    self, Binder, BoundVariableKind, Clause, EarlyBinder, FnSig, GenericArgKind, List, ParamTy, PredicateKind,\n     ProjectionPredicate, Ty, TyCtxt, TypeVisitable, TypeckResults,\n };\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n@@ -855,14 +855,10 @@ fn walk_parents<'tcx>(\n                         } else if let Some(trait_id) = cx.tcx.trait_of_item(id)\n                             && let arg_ty = cx.tcx.erase_regions(cx.typeck_results().expr_ty_adjusted(e))\n                             && let ty::Ref(_, sub_ty, _) = *arg_ty.kind()\n-                            && let subs = match cx\n+                            && let subs = cx\n                                 .typeck_results()\n-                                .node_substs_opt(parent.hir_id)\n-                                .and_then(|subs| subs.get(1..))\n-                            {\n-                                Some(subs) => cx.tcx.mk_substs(subs.iter().copied()),\n-                                None => cx.tcx.mk_substs(std::iter::empty::<ty::subst::GenericArg<'_>>()),\n-                            } && let impl_ty = if cx.tcx.fn_sig(id).skip_binder().inputs()[0].is_ref() {\n+                                .node_substs_opt(parent.hir_id).map(|subs| &subs[1..]).unwrap_or_default()\n+                            && let impl_ty = if cx.tcx.fn_sig(id).skip_binder().inputs()[0].is_ref() {\n                                 // Trait methods taking `&self`\n                                 sub_ty\n                             } else {\n@@ -871,7 +867,11 @@ fn walk_parents<'tcx>(\n                             } && impl_ty.is_ref()\n                             && let infcx = cx.tcx.infer_ctxt().build()\n                             && infcx\n-                                .type_implements_trait(trait_id, impl_ty, subs, cx.param_env)\n+                                .type_implements_trait(\n+                                    trait_id,\n+                                    [impl_ty.into()].into_iter().chain(subs.iter().copied()),\n+                                    cx.param_env,\n+                                )\n                                 .must_apply_modulo_regions()\n                         {\n                             return Some(Position::MethodReceiverRefImpl)\n@@ -1106,7 +1106,7 @@ fn needless_borrow_impl_arg_position<'tcx>(\n     let projection_predicates = predicates\n         .iter()\n         .filter_map(|predicate| {\n-            if let PredicateKind::Projection(projection_predicate) = predicate.kind().skip_binder() {\n+            if let PredicateKind::Clause(Clause::Projection(projection_predicate)) = predicate.kind().skip_binder() {\n                 Some(projection_predicate)\n             } else {\n                 None\n@@ -1120,7 +1120,7 @@ fn needless_borrow_impl_arg_position<'tcx>(\n     if predicates\n         .iter()\n         .filter_map(|predicate| {\n-            if let PredicateKind::Trait(trait_predicate) = predicate.kind().skip_binder()\n+            if let PredicateKind::Clause(Clause::Trait(trait_predicate)) = predicate.kind().skip_binder()\n                 && trait_predicate.trait_ref.self_ty() == param_ty.to_ty(cx.tcx)\n             {\n                 Some(trait_predicate.trait_ref.def_id)\n@@ -1182,7 +1182,7 @@ fn needless_borrow_impl_arg_position<'tcx>(\n         }\n \n         predicates.iter().all(|predicate| {\n-            if let PredicateKind::Trait(trait_predicate) = predicate.kind().skip_binder()\n+            if let PredicateKind::Clause(Clause::Trait(trait_predicate)) = predicate.kind().skip_binder()\n                 && cx.tcx.is_diagnostic_item(sym::IntoIterator, trait_predicate.trait_ref.def_id)\n                 && let ty::Param(param_ty) = trait_predicate.self_ty().kind()\n                 && let GenericArgKind::Type(ty) = substs_with_referent_ty[param_ty.index as usize].unpack()\n@@ -1333,7 +1333,7 @@ fn replace_types<'tcx>(\n                     let item_def_id = projection_predicate.projection_ty.item_def_id;\n                     let assoc_item = cx.tcx.associated_item(item_def_id);\n                     let projection = cx.tcx\n-                        .mk_projection(assoc_item.def_id, cx.tcx.mk_substs_trait(new_ty, &[]));\n+                        .mk_projection(assoc_item.def_id, cx.tcx.mk_substs_trait(new_ty, []));\n \n                     if let Ok(projected_ty) = cx.tcx.try_normalize_erasing_regions(cx.param_env, projection)\n                         && substs[term_param_ty.index as usize] != ty::GenericArg::from(projected_ty)"}, {"sha": "9e596ca8157eb93b58fc827d6c4d3eda261a116c", "filename": "clippy_lints/src/derive.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d822110d3b5625b9dc80ccc442e06fc3cc851d76/clippy_lints%2Fsrc%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d822110d3b5625b9dc80ccc442e06fc3cc851d76/clippy_lints%2Fsrc%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fderive.rs?ref=d822110d3b5625b9dc80ccc442e06fc3cc851d76", "patch": "@@ -14,8 +14,8 @@ use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::hir::nested_filter;\n use rustc_middle::traits::Reveal;\n use rustc_middle::ty::{\n-    self, Binder, BoundConstness, GenericParamDefKind, ImplPolarity, ParamEnv, PredicateKind, TraitPredicate, TraitRef,\n-    Ty, TyCtxt,\n+    self, Binder, BoundConstness, Clause, GenericParamDefKind, ImplPolarity, ParamEnv, PredicateKind, TraitPredicate,\n+    TraitRef, Ty, TyCtxt,\n };\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::source_map::Span;\n@@ -466,12 +466,12 @@ fn check_partial_eq_without_eq<'tcx>(cx: &LateContext<'tcx>, span: Span, trait_r\n         if let Some(def_id) = trait_ref.trait_def_id();\n         if cx.tcx.is_diagnostic_item(sym::PartialEq, def_id);\n         let param_env = param_env_for_derived_eq(cx.tcx, adt.did(), eq_trait_def_id);\n-        if !implements_trait_with_env(cx.tcx, param_env, ty, eq_trait_def_id, &[]);\n+        if !implements_trait_with_env(cx.tcx, param_env, ty, eq_trait_def_id, []);\n         // If all of our fields implement `Eq`, we can implement `Eq` too\n         if adt\n             .all_fields()\n             .map(|f| f.ty(cx.tcx, substs))\n-            .all(|ty| implements_trait_with_env(cx.tcx, param_env, ty, eq_trait_def_id, &[]));\n+            .all(|ty| implements_trait_with_env(cx.tcx, param_env, ty, eq_trait_def_id, []));\n         then {\n             span_lint_and_sugg(\n                 cx,\n@@ -499,7 +499,7 @@ fn param_env_for_derived_eq(tcx: TyCtxt<'_>, did: DefId, eq_trait_id: DefId) ->\n \n     let ty_predicates = tcx.predicates_of(did).predicates;\n     for (p, _) in ty_predicates {\n-        if let PredicateKind::Trait(p) = p.kind().skip_binder()\n+        if let PredicateKind::Clause(Clause::Trait(p)) = p.kind().skip_binder()\n             && p.trait_ref.def_id == eq_trait_id\n             && let ty::Param(self_ty) = p.trait_ref.self_ty().kind()\n             && p.constness == BoundConstness::NotConst\n@@ -512,14 +512,14 @@ fn param_env_for_derived_eq(tcx: TyCtxt<'_>, did: DefId, eq_trait_id: DefId) ->\n     ParamEnv::new(\n         tcx.mk_predicates(ty_predicates.iter().map(|&(p, _)| p).chain(\n             params.iter().filter(|&&(_, needs_eq)| needs_eq).map(|&(param, _)| {\n-                tcx.mk_predicate(Binder::dummy(PredicateKind::Trait(TraitPredicate {\n+                tcx.mk_predicate(Binder::dummy(PredicateKind::Clause(Clause::Trait(TraitPredicate {\n                     trait_ref: TraitRef::new(\n                         eq_trait_id,\n                         tcx.mk_substs(std::iter::once(tcx.mk_param_from_def(param))),\n                     ),\n                     constness: BoundConstness::NotConst,\n                     polarity: ImplPolarity::Positive,\n-                })))\n+                }))))\n             }),\n         )),\n         Reveal::UserFacing,"}, {"sha": "cdc23a4d22739ef79ebc7993a88ea902de69e617", "filename": "clippy_lints/src/doc.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d822110d3b5625b9dc80ccc442e06fc3cc851d76/clippy_lints%2Fsrc%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d822110d3b5625b9dc80ccc442e06fc3cc851d76/clippy_lints%2Fsrc%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdoc.rs?ref=d822110d3b5625b9dc80ccc442e06fc3cc851d76", "patch": "@@ -427,9 +427,7 @@ fn lint_for_missing_headers(\n                 let body = cx.tcx.hir().body(body_id);\n                 let ret_ty = typeck.expr_ty(body.value);\n                 if implements_trait(cx, ret_ty, future, &[]);\n-                if let ty::Opaque(_, subs) = ret_ty.kind();\n-                if let Some(gen) = subs.types().next();\n-                if let ty::Generator(_, subs, _) = gen.kind();\n+                if let ty::Generator(_, subs, _) = ret_ty.kind();\n                 if is_type_diagnostic_item(cx, subs.as_generator().return_ty(), sym::Result);\n                 then {\n                     span_lint("}, {"sha": "3543910c3b55b470cb58db75a3e8c94cad7c0e5f", "filename": "clippy_lints/src/eta_reduction.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d822110d3b5625b9dc80ccc442e06fc3cc851d76/clippy_lints%2Fsrc%2Feta_reduction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d822110d3b5625b9dc80ccc442e06fc3cc851d76/clippy_lints%2Fsrc%2Feta_reduction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Feta_reduction.rs?ref=d822110d3b5625b9dc80ccc442e06fc3cc851d76", "patch": "@@ -119,11 +119,18 @@ impl<'tcx> LateLintPass<'tcx> for EtaReduction {\n             let callee_ty_unadjusted = cx.typeck_results().expr_ty(callee).peel_refs();\n             if !is_type_diagnostic_item(cx, callee_ty_unadjusted, sym::Arc);\n             if !is_type_diagnostic_item(cx, callee_ty_unadjusted, sym::Rc);\n+            if let ty::Closure(_, substs) = *closure_ty.kind();\n             then {\n                 span_lint_and_then(cx, REDUNDANT_CLOSURE, expr.span, \"redundant closure\", |diag| {\n                     if let Some(mut snippet) = snippet_opt(cx, callee.span) {\n                         if let Some(fn_mut_id) = cx.tcx.lang_items().fn_mut_trait()\n-                            && implements_trait(cx, callee_ty.peel_refs(), fn_mut_id, &[])\n+                            && let args = cx.tcx.erase_late_bound_regions(substs.as_closure().sig()).inputs()\n+                            && implements_trait(\n+                                   cx,\n+                                   callee_ty.peel_refs(),\n+                                   fn_mut_id,\n+                                   &args.iter().copied().map(Into::into).collect::<Vec<_>>(),\n+                               )\n                             && path_to_local(callee).map_or(false, |l| local_used_after_expr(cx, l, expr))\n                         {\n                                 // Mutable closure is used after current expr; we cannot consume it."}, {"sha": "61934a9142633003f805f421ea4f9855451e76f3", "filename": "clippy_lints/src/future_not_send.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d822110d3b5625b9dc80ccc442e06fc3cc851d76/clippy_lints%2Fsrc%2Ffuture_not_send.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d822110d3b5625b9dc80ccc442e06fc3cc851d76/clippy_lints%2Fsrc%2Ffuture_not_send.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffuture_not_send.rs?ref=d822110d3b5625b9dc80ccc442e06fc3cc851d76", "patch": "@@ -4,7 +4,7 @@ use rustc_hir::intravisit::FnKind;\n use rustc_hir::{Body, FnDecl, HirId};\n use rustc_infer::infer::TyCtxtInferExt;\n use rustc_lint::{LateContext, LateLintPass};\n-use rustc_middle::ty::{EarlyBinder, Opaque, PredicateKind::Trait};\n+use rustc_middle::ty::{Clause, EarlyBinder, Opaque, PredicateKind};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::{sym, Span};\n use rustc_trait_selection::traits::error_reporting::suggestions::TypeErrCtxtExt;\n@@ -91,7 +91,9 @@ impl<'tcx> LateLintPass<'tcx> for FutureNotSend {\n                                 infcx\n                                     .err_ctxt()\n                                     .maybe_note_obligation_cause_for_async_await(db, &obligation);\n-                                if let Trait(trait_pred) = obligation.predicate.kind().skip_binder() {\n+                                if let PredicateKind::Clause(Clause::Trait(trait_pred)) =\n+                                    obligation.predicate.kind().skip_binder()\n+                                {\n                                     db.note(&format!(\n                                         \"`{}` doesn't implement `{}`\",\n                                         trait_pred.self_ty(),"}, {"sha": "7b17d8a156d5af6ddb3b9417b7990e65d2a3d5ee", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d822110d3b5625b9dc80ccc442e06fc3cc851d76/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d822110d3b5625b9dc80ccc442e06fc3cc851d76/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=d822110d3b5625b9dc80ccc442e06fc3cc851d76", "patch": "@@ -26,7 +26,6 @@\n extern crate rustc_arena;\n extern crate rustc_ast;\n extern crate rustc_ast_pretty;\n-extern crate rustc_attr;\n extern crate rustc_data_structures;\n extern crate rustc_driver;\n extern crate rustc_errors;"}, {"sha": "7cf1a6b8084a613b9053e2c1fe18bd2498f590d8", "filename": "clippy_lints/src/lifetimes.rs", "status": "modified", "additions": 17, "deletions": 19, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/d822110d3b5625b9dc80ccc442e06fc3cc851d76/clippy_lints%2Fsrc%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d822110d3b5625b9dc80ccc442e06fc3cc851d76/clippy_lints%2Fsrc%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flifetimes.rs?ref=d822110d3b5625b9dc80ccc442e06fc3cc851d76", "patch": "@@ -10,8 +10,8 @@ use rustc_hir::lang_items;\n use rustc_hir::FnRetTy::Return;\n use rustc_hir::{\n     BareFnTy, BodyId, FnDecl, GenericArg, GenericBound, GenericParam, GenericParamKind, Generics, Impl, ImplItem,\n-    ImplItemKind, Item, ItemKind, Lifetime, LifetimeName, ParamName, PolyTraitRef, PredicateOrigin, TraitFn, TraitItem,\n-    TraitItemKind, Ty, TyKind, WherePredicate,\n+    ImplItemKind, Item, ItemKind, Lifetime, LifetimeName, LifetimeParamKind, PolyTraitRef, PredicateOrigin, TraitFn,\n+    TraitItem, TraitItemKind, Ty, TyKind, WherePredicate,\n };\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::hir::nested_filter as middle_nested_filter;\n@@ -180,7 +180,7 @@ fn check_fn_inner<'tcx>(\n                             _ => None,\n                         });\n                         for bound in lifetimes {\n-                            if bound.name != LifetimeName::Static && !bound.is_elided() {\n+                            if !bound.is_static() && !bound.is_elided() {\n                                 return;\n                             }\n                         }\n@@ -414,17 +414,13 @@ impl<'a, 'tcx> RefVisitor<'a, 'tcx> {\n \n     fn record(&mut self, lifetime: &Option<Lifetime>) {\n         if let Some(ref lt) = *lifetime {\n-            if lt.name == LifetimeName::Static {\n+            if lt.is_static() {\n                 self.lts.push(RefLt::Static);\n-            } else if let LifetimeName::Param(_, ParamName::Fresh) = lt.name {\n+            } else if lt.is_anonymous() {\n                 // Fresh lifetimes generated should be ignored.\n                 self.lts.push(RefLt::Unnamed);\n-            } else if lt.is_elided() {\n-                self.lts.push(RefLt::Unnamed);\n-            } else if let LifetimeName::Param(def_id, _) = lt.name {\n+            } else if let LifetimeName::Param(def_id) = lt.res {\n                 self.lts.push(RefLt::Named(def_id));\n-            } else {\n-                self.lts.push(RefLt::Unnamed);\n             }\n         } else {\n             self.lts.push(RefLt::Unnamed);\n@@ -472,7 +468,7 @@ impl<'a, 'tcx> Visitor<'tcx> for RefVisitor<'a, 'tcx> {\n                 walk_item(self, item);\n                 self.lts.truncate(len);\n                 self.lts.extend(bounds.iter().filter_map(|bound| match bound {\n-                    GenericArg::Lifetime(l) => Some(if let LifetimeName::Param(def_id, _) = l.name {\n+                    GenericArg::Lifetime(l) => Some(if let LifetimeName::Param(def_id) = l.res {\n                         RefLt::Named(def_id)\n                     } else {\n                         RefLt::Unnamed\n@@ -498,10 +494,8 @@ impl<'a, 'tcx> Visitor<'tcx> for RefVisitor<'a, 'tcx> {\n     }\n \n     fn visit_generic_arg(&mut self, generic_arg: &'tcx GenericArg<'tcx>) {\n-        if let GenericArg::Lifetime(l) = generic_arg\n-            && let LifetimeName::Param(def_id, _) = l.name\n-        {\n-            self.lifetime_generic_arg_spans.entry(def_id).or_insert(l.span);\n+        if let GenericArg::Lifetime(l) = generic_arg && let LifetimeName::Param(def_id) = l.res {\n+            self.lifetime_generic_arg_spans.entry(def_id).or_insert(l.ident.span);\n         }\n         walk_generic_arg(self, generic_arg);\n     }\n@@ -570,7 +564,7 @@ where\n \n     // for lifetimes as parameters of generics\n     fn visit_lifetime(&mut self, lifetime: &'tcx Lifetime) {\n-        self.map.remove(&lifetime.name.ident().name);\n+        self.map.remove(&lifetime.ident.name);\n     }\n \n     fn visit_generic_param(&mut self, param: &'tcx GenericParam<'_>) {\n@@ -594,7 +588,9 @@ fn report_extra_lifetimes<'tcx>(cx: &LateContext<'tcx>, func: &'tcx FnDecl<'_>,\n         .params\n         .iter()\n         .filter_map(|par| match par.kind {\n-            GenericParamKind::Lifetime { .. } => Some((par.name.ident().name, par.span)),\n+            GenericParamKind::Lifetime {\n+                kind: LifetimeParamKind::Explicit,\n+            } => Some((par.name.ident().name, par.span)),\n             _ => None,\n         })\n         .collect();\n@@ -619,7 +615,9 @@ fn report_extra_impl_lifetimes<'tcx>(cx: &LateContext<'tcx>, impl_: &'tcx Impl<'\n         .params\n         .iter()\n         .filter_map(|par| match par.kind {\n-            GenericParamKind::Lifetime { .. } => Some((par.name.ident().name, par.span)),\n+            GenericParamKind::Lifetime {\n+                kind: LifetimeParamKind::Explicit,\n+            } => Some((par.name.ident().name, par.span)),\n             _ => None,\n         })\n         .collect();\n@@ -646,7 +644,7 @@ struct BodyLifetimeChecker {\n impl<'tcx> Visitor<'tcx> for BodyLifetimeChecker {\n     // for lifetimes as parameters of generics\n     fn visit_lifetime(&mut self, lifetime: &'tcx Lifetime) {\n-        if lifetime.name.ident().name != kw::UnderscoreLifetime && lifetime.name.ident().name != kw::StaticLifetime {\n+        if !lifetime.is_anonymous() && lifetime.ident.name != kw::StaticLifetime {\n             self.lifetimes_used_in_body = true;\n         }\n     }"}, {"sha": "075ecbe7eded37340c1b36db85654ea7996588dc", "filename": "clippy_lints/src/manual_async_fn.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d822110d3b5625b9dc80ccc442e06fc3cc851d76/clippy_lints%2Fsrc%2Fmanual_async_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d822110d3b5625b9dc80ccc442e06fc3cc851d76/clippy_lints%2Fsrc%2Fmanual_async_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmanual_async_fn.rs?ref=d822110d3b5625b9dc80ccc442e06fc3cc851d76", "patch": "@@ -118,7 +118,7 @@ fn future_trait_ref<'tcx>(\n                 .iter()\n                 .filter_map(|bound| {\n                     if let GenericArg::Lifetime(lt) = bound {\n-                        Some(lt.name)\n+                        Some(lt.res)\n                     } else {\n                         None\n                     }\n@@ -153,7 +153,7 @@ fn captures_all_lifetimes(inputs: &[Ty<'_>], output_lifetimes: &[LifetimeName])\n         .iter()\n         .filter_map(|ty| {\n             if let TyKind::Rptr(lt, _) = ty.kind {\n-                Some(lt.name)\n+                Some(lt.res)\n             } else {\n                 None\n             }\n@@ -177,7 +177,7 @@ fn desugared_async_block<'tcx>(cx: &LateContext<'tcx>, block: &'tcx Block<'tcx>)\n         if let Some(args) = cx\n             .tcx\n             .lang_items()\n-            .from_generator_fn()\n+            .identity_future_fn()\n             .and_then(|def_id| match_function_call_with_def_id(cx, block_expr, def_id));\n         if args.len() == 1;\n         if let Expr {"}, {"sha": "7f8d124838cb8be5a64b48f6c0c0f1febeca8ff4", "filename": "clippy_lints/src/matches/match_wild_enum.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d822110d3b5625b9dc80ccc442e06fc3cc851d76/clippy_lints%2Fsrc%2Fmatches%2Fmatch_wild_enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d822110d3b5625b9dc80ccc442e06fc3cc851d76/clippy_lints%2Fsrc%2Fmatches%2Fmatch_wild_enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fmatch_wild_enum.rs?ref=d822110d3b5625b9dc80ccc442e06fc3cc851d76", "patch": "@@ -65,14 +65,14 @@ pub(crate) fn check(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>]) {\n                         _ => return,\n                     };\n                     if arm.guard.is_none() {\n-                        missing_variants.retain(|e| e.ctor_def_id != Some(id));\n+                        missing_variants.retain(|e| e.ctor_def_id() != Some(id));\n                     }\n                     path\n                 },\n                 PatKind::TupleStruct(path, patterns, ..) => {\n                     if let Some(id) = cx.qpath_res(path, pat.hir_id).opt_def_id() {\n                         if arm.guard.is_none() && patterns.iter().all(|p| !is_refutable(cx, p)) {\n-                            missing_variants.retain(|e| e.ctor_def_id != Some(id));\n+                            missing_variants.retain(|e| e.ctor_def_id() != Some(id));\n                         }\n                     }\n                     path\n@@ -122,11 +122,11 @@ pub(crate) fn check(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>]) {\n                 s\n             },\n             variant.name,\n-            match variant.ctor_kind {\n-                CtorKind::Fn if variant.fields.len() == 1 => \"(_)\",\n-                CtorKind::Fn => \"(..)\",\n-                CtorKind::Const => \"\",\n-                CtorKind::Fictive => \"{ .. }\",\n+            match variant.ctor_kind() {\n+                Some(CtorKind::Fn) if variant.fields.len() == 1 => \"(_)\",\n+                Some(CtorKind::Fn) => \"(..)\",\n+                Some(CtorKind::Const) => \"\",\n+                None => \"{ .. }\",\n             }\n         )\n     };"}, {"sha": "704c34c32bf743b39842571202e1114e5b28a750", "filename": "clippy_lints/src/matches/try_err.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d822110d3b5625b9dc80ccc442e06fc3cc851d76/clippy_lints%2Fsrc%2Fmatches%2Ftry_err.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d822110d3b5625b9dc80ccc442e06fc3cc851d76/clippy_lints%2Fsrc%2Fmatches%2Ftry_err.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Ftry_err.rs?ref=d822110d3b5625b9dc80ccc442e06fc3cc851d76", "patch": "@@ -1,7 +1,7 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::source::snippet_with_applicability;\n use clippy_utils::ty::is_type_diagnostic_item;\n-use clippy_utils::{get_parent_expr, is_res_lang_ctor, match_def_path, path_res, paths};\n+use clippy_utils::{get_parent_expr, is_res_lang_ctor, path_res};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::LangItem::ResultErr;\n@@ -107,7 +107,7 @@ fn result_error_type<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> Option<Ty<'t\n fn poll_result_error_type<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> Option<Ty<'tcx>> {\n     if_chain! {\n         if let ty::Adt(def, subst) = ty.kind();\n-        if match_def_path(cx, def.did(), &paths::POLL);\n+        if cx.tcx.lang_items().get(LangItem::Poll) == Some(def.did());\n         let ready_ty = subst.type_at(0);\n \n         if let ty::Adt(ready_def, ready_subst) = ready_ty.kind();\n@@ -124,7 +124,7 @@ fn poll_result_error_type<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> Option<\n fn poll_option_result_error_type<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> Option<Ty<'tcx>> {\n     if_chain! {\n         if let ty::Adt(def, subst) = ty.kind();\n-        if match_def_path(cx, def.did(), &paths::POLL);\n+        if cx.tcx.lang_items().get(LangItem::Poll) == Some(def.did());\n         let ready_ty = subst.type_at(0);\n \n         if let ty::Adt(ready_def, ready_subst) = ready_ty.kind();"}, {"sha": "b4210d875104bbe9f473fdbd430d67d28a45095c", "filename": "clippy_lints/src/methods/iter_overeager_cloned.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d822110d3b5625b9dc80ccc442e06fc3cc851d76/clippy_lints%2Fsrc%2Fmethods%2Fiter_overeager_cloned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d822110d3b5625b9dc80ccc442e06fc3cc851d76/clippy_lints%2Fsrc%2Fmethods%2Fiter_overeager_cloned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fiter_overeager_cloned.rs?ref=d822110d3b5625b9dc80ccc442e06fc3cc851d76", "patch": "@@ -1,6 +1,6 @@\n use clippy_utils::diagnostics::span_lint_and_then;\n use clippy_utils::source::snippet_opt;\n-use clippy_utils::ty::{get_associated_type, implements_trait, is_copy};\n+use clippy_utils::ty::{implements_trait, is_copy};\n use rustc_errors::Applicability;\n use rustc_hir::Expr;\n use rustc_lint::LateContext;\n@@ -25,7 +25,7 @@ pub(super) fn check<'tcx>(\n         && let Some(method_id) = typeck.type_dependent_def_id(cloned_call.hir_id)\n         && cx.tcx.trait_of_item(method_id) == Some(iter_id)\n         && let cloned_recv_ty = typeck.expr_ty_adjusted(cloned_recv)\n-        && let Some(iter_assoc_ty) = get_associated_type(cx, cloned_recv_ty, iter_id, \"Item\")\n+        && let Some(iter_assoc_ty) = cx.get_associated_type(cloned_recv_ty, iter_id, \"Item\")\n         && matches!(*iter_assoc_ty.kind(), ty::Ref(_, ty, _) if !is_copy(cx, ty))\n     {\n         if needs_into_iter"}, {"sha": "52a4ff7d1ae4f09aa23e2172f2a89e2bc26f894c", "filename": "clippy_lints/src/methods/unnecessary_iter_cloned.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d822110d3b5625b9dc80ccc442e06fc3cc851d76/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_iter_cloned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d822110d3b5625b9dc80ccc442e06fc3cc851d76/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_iter_cloned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_iter_cloned.rs?ref=d822110d3b5625b9dc80ccc442e06fc3cc851d76", "patch": "@@ -2,7 +2,7 @@ use super::utils::clone_or_copy_needed;\n use clippy_utils::diagnostics::span_lint_and_then;\n use clippy_utils::higher::ForLoop;\n use clippy_utils::source::snippet_opt;\n-use clippy_utils::ty::{get_associated_type, get_iterator_item_ty, implements_trait};\n+use clippy_utils::ty::{get_iterator_item_ty, implements_trait};\n use clippy_utils::{fn_def_id, get_parent_expr};\n use rustc_errors::Applicability;\n use rustc_hir::{def_id::DefId, Expr, ExprKind};\n@@ -54,7 +54,7 @@ pub fn check_for_loop_iter(\n                 if let Some(into_iterator_trait_id) = cx.tcx.get_diagnostic_item(sym::IntoIterator);\n                 let collection_ty = cx.typeck_results().expr_ty(collection);\n                 if implements_trait(cx, collection_ty, into_iterator_trait_id, &[]);\n-                if let Some(into_iter_item_ty) = get_associated_type(cx, collection_ty, into_iterator_trait_id, \"Item\");\n+                if let Some(into_iter_item_ty) = cx.get_associated_type(collection_ty, into_iterator_trait_id, \"Item\");\n \n                 if iter_item_ty == into_iter_item_ty;\n                 if let Some(collection_snippet) = snippet_opt(cx, collection.span);"}, {"sha": "17b0507682ae905b9e7fb438f76eef3022d317b8", "filename": "clippy_lints/src/methods/unnecessary_to_owned.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/d822110d3b5625b9dc80ccc442e06fc3cc851d76/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_to_owned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d822110d3b5625b9dc80ccc442e06fc3cc851d76/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_to_owned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_to_owned.rs?ref=d822110d3b5625b9dc80ccc442e06fc3cc851d76", "patch": "@@ -3,7 +3,7 @@ use super::unnecessary_iter_cloned::{self, is_into_iter};\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::msrvs::{self, Msrv};\n use clippy_utils::source::snippet_opt;\n-use clippy_utils::ty::{get_associated_type, get_iterator_item_ty, implements_trait, is_copy, peel_mid_ty_refs};\n+use clippy_utils::ty::{get_iterator_item_ty, implements_trait, is_copy, peel_mid_ty_refs};\n use clippy_utils::visitors::find_all_ret_expressions;\n use clippy_utils::{fn_def_id, get_parent_expr, is_diag_item_method, is_diag_trait_item, return_ty};\n use rustc_errors::Applicability;\n@@ -14,8 +14,7 @@ use rustc_lint::LateContext;\n use rustc_middle::mir::Mutability;\n use rustc_middle::ty::adjustment::{Adjust, Adjustment, OverloadedDeref};\n use rustc_middle::ty::subst::{GenericArg, GenericArgKind, SubstsRef};\n-use rustc_middle::ty::EarlyBinder;\n-use rustc_middle::ty::{self, ParamTy, PredicateKind, ProjectionPredicate, TraitPredicate, Ty};\n+use rustc_middle::ty::{self, Clause, EarlyBinder, ParamTy, PredicateKind, ProjectionPredicate, TraitPredicate, Ty};\n use rustc_span::{sym, Symbol};\n use rustc_trait_selection::traits::{query::evaluate_obligation::InferCtxtExt as _, Obligation, ObligationCause};\n \n@@ -144,7 +143,7 @@ fn check_addr_of_expr(\n             if_chain! {\n                 if let Some(deref_trait_id) = cx.tcx.get_diagnostic_item(sym::Deref);\n                 if implements_trait(cx, receiver_ty, deref_trait_id, &[]);\n-                if get_associated_type(cx, receiver_ty, deref_trait_id, \"Target\") == Some(target_ty);\n+                if cx.get_associated_type(receiver_ty, deref_trait_id, \"Target\") == Some(target_ty);\n                 then {\n                     if n_receiver_refs > 0 {\n                         span_lint_and_sugg(\n@@ -346,12 +345,12 @@ fn get_input_traits_and_projections<'tcx>(\n     let mut projection_predicates = Vec::new();\n     for predicate in cx.tcx.param_env(callee_def_id).caller_bounds() {\n         match predicate.kind().skip_binder() {\n-            PredicateKind::Trait(trait_predicate) => {\n+            PredicateKind::Clause(Clause::Trait(trait_predicate)) => {\n                 if trait_predicate.trait_ref.self_ty() == input {\n                     trait_predicates.push(trait_predicate);\n                 }\n             },\n-            PredicateKind::Projection(projection_predicate) => {\n+            PredicateKind::Clause(Clause::Projection(projection_predicate)) => {\n                 if projection_predicate.projection_ty.self_ty() == input {\n                     projection_predicates.push(projection_predicate);\n                 }\n@@ -408,10 +407,12 @@ fn can_change_type<'a>(cx: &LateContext<'a>, mut expr: &'a Expr<'a>, mut ty: Ty<\n \n                         let mut trait_predicates = cx.tcx.param_env(callee_def_id)\n                             .caller_bounds().iter().filter(|predicate| {\n-                            if let PredicateKind::Trait(trait_predicate) =  predicate.kind().skip_binder()\n-                                && trait_predicate.trait_ref.self_ty() == *param_ty {\n-                                    true\n-                                } else {\n+                            if let PredicateKind::Clause(Clause::Trait(trait_predicate))\n+                                    = predicate.kind().skip_binder()\n+                                && trait_predicate.trait_ref.self_ty() == *param_ty\n+                            {\n+                                true\n+                            } else {\n                                 false\n                             }\n                         });\n@@ -483,7 +484,7 @@ fn is_cow_into_owned(cx: &LateContext<'_>, method_name: Symbol, method_def_id: D\n }\n \n /// Returns true if the named method is `ToString::to_string` and it's called on a type that\n-/// is string-like i.e. implements `AsRef<str>` or `Deref<str>`.\n+/// is string-like i.e. implements `AsRef<str>` or `Deref<Target = str>`.\n fn is_to_string_on_string_like<'a>(\n     cx: &LateContext<'_>,\n     call_expr: &'a Expr<'a>,\n@@ -499,7 +500,7 @@ fn is_to_string_on_string_like<'a>(\n         && let GenericArgKind::Type(ty) = generic_arg.unpack()\n         && let Some(deref_trait_id) = cx.tcx.get_diagnostic_item(sym::Deref)\n         && let Some(as_ref_trait_id) = cx.tcx.get_diagnostic_item(sym::AsRef)\n-        && (implements_trait(cx, ty, deref_trait_id, &[cx.tcx.types.str_.into()]) ||\n+        && (cx.get_associated_type(ty, deref_trait_id, \"Target\") == Some(cx.tcx.types.str_) ||\n             implements_trait(cx, ty, as_ref_trait_id, &[cx.tcx.types.str_.into()])) {\n             true\n         } else {"}, {"sha": "2f0b7ce16e51b77541bdee6927dea53c98bdb18e", "filename": "clippy_lints/src/needless_pass_by_value.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d822110d3b5625b9dc80ccc442e06fc3cc851d76/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d822110d3b5625b9dc80ccc442e06fc3cc851d76/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs?ref=d822110d3b5625b9dc80ccc442e06fc3cc851d76", "patch": "@@ -1,7 +1,9 @@\n use clippy_utils::diagnostics::{multispan_sugg, span_lint_and_then};\n use clippy_utils::ptr::get_spans;\n use clippy_utils::source::{snippet, snippet_opt};\n-use clippy_utils::ty::{implements_trait, is_copy, is_type_diagnostic_item, is_type_lang_item};\n+use clippy_utils::ty::{\n+    implements_trait, implements_trait_with_env, is_copy, is_type_diagnostic_item, is_type_lang_item,\n+};\n use clippy_utils::{get_trait_def_id, is_self, paths};\n use if_chain::if_chain;\n use rustc_ast::ast::Attribute;\n@@ -124,7 +126,9 @@ impl<'tcx> LateLintPass<'tcx> for NeedlessPassByValue {\n             .filter_map(|obligation| {\n                 // Note that we do not want to deal with qualified predicates here.\n                 match obligation.predicate.kind().no_bound_vars() {\n-                    Some(ty::PredicateKind::Trait(pred)) if pred.def_id() != sized_trait => Some(pred),\n+                    Some(ty::PredicateKind::Clause(ty::Clause::Trait(pred))) if pred.def_id() != sized_trait => {\n+                        Some(pred)\n+                    },\n                     _ => None,\n                 }\n             })\n@@ -185,7 +189,7 @@ impl<'tcx> LateLintPass<'tcx> for NeedlessPassByValue {\n                 if !ty.is_mutable_ptr();\n                 if !is_copy(cx, ty);\n                 if ty.is_sized(cx.tcx, cx.param_env);\n-                if !allowed_traits.iter().any(|&t| implements_trait(cx, ty, t, &[]));\n+                if !allowed_traits.iter().any(|&t| implements_trait_with_env(cx.tcx, cx.param_env, ty, t, [None]));\n                 if !implements_borrow_trait;\n                 if !all_borrowable_trait;\n "}, {"sha": "a022fc156fca214cd70c60a41124684a21125bca", "filename": "clippy_lints/src/neg_cmp_op_on_partial_ord.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d822110d3b5625b9dc80ccc442e06fc3cc851d76/clippy_lints%2Fsrc%2Fneg_cmp_op_on_partial_ord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d822110d3b5625b9dc80ccc442e06fc3cc851d76/clippy_lints%2Fsrc%2Fneg_cmp_op_on_partial_ord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneg_cmp_op_on_partial_ord.rs?ref=d822110d3b5625b9dc80ccc442e06fc3cc851d76", "patch": "@@ -65,7 +65,7 @@ impl<'tcx> LateLintPass<'tcx> for NoNegCompOpForPartialOrd {\n \n                 let implements_partial_ord = {\n                     if let Some(id) = cx.tcx.lang_items().partial_ord_trait() {\n-                        implements_trait(cx, ty, id, &[])\n+                        implements_trait(cx, ty, id, &[ty.into()])\n                     } else {\n                         return;\n                     }"}, {"sha": "e395ff54cb15a00f0693e6f8007f9d4ab1585aab", "filename": "clippy_lints/src/ptr.rs", "status": "modified", "additions": 15, "deletions": 20, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/d822110d3b5625b9dc80ccc442e06fc3cc851d76/clippy_lints%2Fsrc%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d822110d3b5625b9dc80ccc442e06fc3cc851d76/clippy_lints%2Fsrc%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fptr.rs?ref=d822110d3b5625b9dc80ccc442e06fc3cc851d76", "patch": "@@ -12,14 +12,14 @@ use rustc_hir::hir_id::HirIdMap;\n use rustc_hir::intravisit::{walk_expr, Visitor};\n use rustc_hir::{\n     self as hir, AnonConst, BinOpKind, BindingAnnotation, Body, Expr, ExprKind, FnRetTy, FnSig, GenericArg,\n-    ImplItemKind, ItemKind, Lifetime, LifetimeName, Mutability, Node, Param, ParamName, PatKind, QPath, TraitFn,\n-    TraitItem, TraitItemKind, TyKind, Unsafety,\n+    ImplItemKind, ItemKind, Lifetime, Mutability, Node, Param, PatKind, QPath, TraitFn, TraitItem, TraitItemKind,\n+    TyKind, Unsafety,\n };\n use rustc_infer::infer::TyCtxtInferExt;\n use rustc_infer::traits::{Obligation, ObligationCause};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::hir::nested_filter;\n-use rustc_middle::ty::{self, Binder, ExistentialPredicate, List, PredicateKind, Ty};\n+use rustc_middle::ty::{self, Binder, Clause, ExistentialPredicate, List, PredicateKind, Ty};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::source_map::Span;\n use rustc_span::sym;\n@@ -343,21 +343,16 @@ impl PtrArg<'_> {\n }\n \n struct RefPrefix {\n-    lt: LifetimeName,\n+    lt: Lifetime,\n     mutability: Mutability,\n }\n impl fmt::Display for RefPrefix {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         use fmt::Write;\n         f.write_char('&')?;\n-        match self.lt {\n-            LifetimeName::Param(_, ParamName::Plain(name)) => {\n-                name.fmt(f)?;\n-                f.write_char(' ')?;\n-            },\n-            LifetimeName::Infer => f.write_str(\"'_ \")?,\n-            LifetimeName::Static => f.write_str(\"'static \")?,\n-            _ => (),\n+        if !self.lt.is_anonymous() {\n+            self.lt.ident.fmt(f)?;\n+            f.write_char(' ')?;\n         }\n         f.write_str(self.mutability.prefix_str())\n     }\n@@ -495,7 +490,7 @@ fn check_fn_args<'cx, 'tcx: 'cx>(\n                         ty_name: name.ident.name,\n                         method_renames,\n                         ref_prefix: RefPrefix {\n-                            lt: lt.name,\n+                            lt: *lt,\n                             mutability,\n                         },\n                         deref_ty,\n@@ -687,24 +682,24 @@ fn check_ptr_arg_usage<'tcx>(cx: &LateContext<'tcx>, body: &'tcx Body<'_>, args:\n fn matches_preds<'tcx>(\n     cx: &LateContext<'tcx>,\n     ty: Ty<'tcx>,\n-    preds: &'tcx [Binder<'tcx, ExistentialPredicate<'tcx>>],\n+    preds: &'tcx [ty::PolyExistentialPredicate<'tcx>],\n ) -> bool {\n     let infcx = cx.tcx.infer_ctxt().build();\n     preds.iter().all(|&p| match cx.tcx.erase_late_bound_regions(p) {\n         ExistentialPredicate::Trait(p) => infcx\n-            .type_implements_trait(p.def_id, ty, p.substs, cx.param_env)\n+            .type_implements_trait(p.def_id, [ty.into()].into_iter().chain(p.substs.iter()), cx.param_env)\n             .must_apply_modulo_regions(),\n         ExistentialPredicate::Projection(p) => infcx.predicate_must_hold_modulo_regions(&Obligation::new(\n             cx.tcx,\n             ObligationCause::dummy(),\n             cx.param_env,\n-            cx.tcx.mk_predicate(Binder::bind_with_vars(\n-                PredicateKind::Projection(p.with_self_ty(cx.tcx, ty)),\n-                List::empty(),\n-            )),\n+            cx.tcx\n+                .mk_predicate(Binder::dummy(PredicateKind::Clause(Clause::Projection(\n+                    p.with_self_ty(cx.tcx, ty),\n+                )))),\n         )),\n         ExistentialPredicate::AutoTrait(p) => infcx\n-            .type_implements_trait(p, ty, List::empty(), cx.param_env)\n+            .type_implements_trait(p, [ty], cx.param_env)\n             .must_apply_modulo_regions(),\n     })\n }"}, {"sha": "e111c7d22915186b12a00f803f5a6960ce690938", "filename": "clippy_lints/src/suspicious_operation_groupings.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d822110d3b5625b9dc80ccc442e06fc3cc851d76/clippy_lints%2Fsrc%2Fsuspicious_operation_groupings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d822110d3b5625b9dc80ccc442e06fc3cc851d76/clippy_lints%2Fsrc%2Fsuspicious_operation_groupings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fsuspicious_operation_groupings.rs?ref=d822110d3b5625b9dc80ccc442e06fc3cc851d76", "patch": "@@ -582,7 +582,7 @@ fn ident_difference_expr_with_base_location(\n         | (Block(_, _), Block(_, _))\n         | (Closure(_), Closure(_))\n         | (Match(_, _), Match(_, _))\n-        | (Loop(_, _), Loop(_, _))\n+        | (Loop(_, _, _), Loop(_, _, _))\n         | (ForLoop(_, _, _, _), ForLoop(_, _, _, _))\n         | (While(_, _, _), While(_, _, _))\n         | (If(_, _, _), If(_, _, _))"}, {"sha": "65dfe7637ea99e0c5b05b5dbaeadcba6cad73c76", "filename": "clippy_lints/src/types/borrowed_box.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d822110d3b5625b9dc80ccc442e06fc3cc851d76/clippy_lints%2Fsrc%2Ftypes%2Fborrowed_box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d822110d3b5625b9dc80ccc442e06fc3cc851d76/clippy_lints%2Fsrc%2Ftypes%2Fborrowed_box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes%2Fborrowed_box.rs?ref=d822110d3b5625b9dc80ccc442e06fc3cc851d76", "patch": "@@ -31,10 +31,10 @@ pub(super) fn check(cx: &LateContext<'_>, hir_ty: &hir::Ty<'_>, lt: &Lifetime, m\n                         return false;\n                     }\n \n-                    let ltopt = if lt.name.is_anonymous() {\n+                    let ltopt = if lt.is_anonymous() {\n                         String::new()\n                     } else {\n-                        format!(\"{} \", lt.name.ident().as_str())\n+                        format!(\"{} \", lt.ident.as_str())\n                     };\n \n                     if mut_ty.mutbl == Mutability::Mut {"}, {"sha": "a138a4baa9b319eb5334709f8ff6089316cb6b9d", "filename": "clippy_lints/src/unit_return_expecting_ord.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d822110d3b5625b9dc80ccc442e06fc3cc851d76/clippy_lints%2Fsrc%2Funit_return_expecting_ord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d822110d3b5625b9dc80ccc442e06fc3cc851d76/clippy_lints%2Fsrc%2Funit_return_expecting_ord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funit_return_expecting_ord.rs?ref=d822110d3b5625b9dc80ccc442e06fc3cc851d76", "patch": "@@ -4,7 +4,7 @@ use rustc_hir::def_id::DefId;\n use rustc_hir::{Closure, Expr, ExprKind, StmtKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::ty;\n-use rustc_middle::ty::{GenericPredicates, PredicateKind, ProjectionPredicate, TraitPredicate};\n+use rustc_middle::ty::{Clause, GenericPredicates, PredicateKind, ProjectionPredicate, TraitPredicate};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::{sym, BytePos, Span};\n \n@@ -45,7 +45,7 @@ fn get_trait_predicates_for_trait_id<'tcx>(\n     let mut preds = Vec::new();\n     for (pred, _) in generics.predicates {\n         if_chain! {\n-            if let PredicateKind::Trait(poly_trait_pred) = pred.kind().skip_binder();\n+            if let PredicateKind::Clause(Clause::Trait(poly_trait_pred)) = pred.kind().skip_binder();\n             let trait_pred = cx.tcx.erase_late_bound_regions(pred.kind().rebind(poly_trait_pred));\n             if let Some(trait_def_id) = trait_id;\n             if trait_def_id == trait_pred.trait_ref.def_id;\n@@ -63,7 +63,7 @@ fn get_projection_pred<'tcx>(\n     trait_pred: TraitPredicate<'tcx>,\n ) -> Option<ProjectionPredicate<'tcx>> {\n     generics.predicates.iter().find_map(|(proj_pred, _)| {\n-        if let ty::PredicateKind::Projection(pred) = proj_pred.kind().skip_binder() {\n+        if let ty::PredicateKind::Clause(Clause::Projection(pred)) = proj_pred.kind().skip_binder() {\n             let projection_pred = cx.tcx.erase_late_bound_regions(proj_pred.kind().rebind(pred));\n             if projection_pred.projection_ty.substs == trait_pred.trait_ref.substs {\n                 return Some(projection_pred);"}, {"sha": "393988dbad384c5584f7db19f511995d70ce39b6", "filename": "clippy_lints/src/utils/internal_lints/unnecessary_def_path.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d822110d3b5625b9dc80ccc442e06fc3cc851d76/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Funnecessary_def_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d822110d3b5625b9dc80ccc442e06fc3cc851d76/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Funnecessary_def_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Funnecessary_def_path.rs?ref=d822110d3b5625b9dc80ccc442e06fc3cc851d76", "patch": "@@ -133,11 +133,11 @@ impl UnnecessaryDefPath {\n                 let has_ctor = match cx.tcx.def_kind(def_id) {\n                     DefKind::Struct => {\n                         let variant = cx.tcx.adt_def(def_id).non_enum_variant();\n-                        variant.ctor_def_id.is_some() && variant.fields.iter().all(|f| f.vis.is_public())\n+                        variant.ctor.is_some() && variant.fields.iter().all(|f| f.vis.is_public())\n                     },\n                     DefKind::Variant => {\n                         let variant = cx.tcx.adt_def(cx.tcx.parent(def_id)).variant_with_id(def_id);\n-                        variant.ctor_def_id.is_some() && variant.fields.iter().all(|f| f.vis.is_public())\n+                        variant.ctor.is_some() && variant.fields.iter().all(|f| f.vis.is_public())\n                     },\n                     _ => false,\n                 };"}, {"sha": "6bcf0bbd7eb75f8ef50e8ea81b390d2e610be8cb", "filename": "clippy_utils/src/ast_utils.rs", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d822110d3b5625b9dc80ccc442e06fc3cc851d76/clippy_utils%2Fsrc%2Fast_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d822110d3b5625b9dc80ccc442e06fc3cc851d76/clippy_utils%2Fsrc%2Fast_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fast_utils.rs?ref=d822110d3b5625b9dc80ccc442e06fc3cc851d76", "patch": "@@ -171,7 +171,7 @@ pub fn eq_expr(l: &Expr, r: &Expr) -> bool {\n         (ForLoop(lp, li, lt, ll), ForLoop(rp, ri, rt, rl)) => {\n             eq_label(ll, rl) && eq_pat(lp, rp) && eq_expr(li, ri) && eq_block(lt, rt)\n         },\n-        (Loop(lt, ll), Loop(rt, rl)) => eq_label(ll, rl) && eq_block(lt, rt),\n+        (Loop(lt, ll, _), Loop(rt, rl, _)) => eq_label(ll, rl) && eq_block(lt, rt),\n         (Block(lb, ll), Block(rb, rl)) => eq_label(ll, rl) && eq_block(lb, rb),\n         (TryBlock(l), TryBlock(r)) => eq_block(l, r),\n         (Yield(l), Yield(r)) | (Ret(l), Ret(r)) => eq_expr_opt(l, r),\n@@ -396,7 +396,7 @@ pub fn eq_item_kind(l: &ItemKind, r: &ItemKind) -> bool {\n                 && over(li, ri, |l, r| eq_item(l, r, eq_assoc_item_kind))\n         },\n         (MacCall(l), MacCall(r)) => eq_mac_call(l, r),\n-        (MacroDef(l), MacroDef(r)) => l.macro_rules == r.macro_rules && eq_mac_args(&l.body, &r.body),\n+        (MacroDef(l), MacroDef(r)) => l.macro_rules == r.macro_rules && eq_delim_args(&l.body, &r.body),\n         _ => false,\n     }\n }\n@@ -717,26 +717,30 @@ pub fn eq_assoc_constraint(l: &AssocConstraint, r: &AssocConstraint) -> bool {\n }\n \n pub fn eq_mac_call(l: &MacCall, r: &MacCall) -> bool {\n-    eq_path(&l.path, &r.path) && eq_mac_args(&l.args, &r.args)\n+    eq_path(&l.path, &r.path) && eq_delim_args(&l.args, &r.args)\n }\n \n pub fn eq_attr(l: &Attribute, r: &Attribute) -> bool {\n     use AttrKind::*;\n     l.style == r.style\n         && match (&l.kind, &r.kind) {\n             (DocComment(l1, l2), DocComment(r1, r2)) => l1 == r1 && l2 == r2,\n-            (Normal(l), Normal(r)) => eq_path(&l.item.path, &r.item.path) && eq_mac_args(&l.item.args, &r.item.args),\n+            (Normal(l), Normal(r)) => eq_path(&l.item.path, &r.item.path) && eq_attr_args(&l.item.args, &r.item.args),\n             _ => false,\n         }\n }\n \n-pub fn eq_mac_args(l: &MacArgs, r: &MacArgs) -> bool {\n-    use MacArgs::*;\n+pub fn eq_attr_args(l: &AttrArgs, r: &AttrArgs) -> bool {\n+    use AttrArgs::*;\n     match (l, r) {\n         (Empty, Empty) => true,\n-        (Delimited(_, ld, lts), Delimited(_, rd, rts)) => ld == rd && lts.eq_unspanned(rts),\n-        (Eq(_, MacArgsEq::Ast(le)), Eq(_, MacArgsEq::Ast(re))) => eq_expr(le, re),\n-        (Eq(_, MacArgsEq::Hir(ll)), Eq(_, MacArgsEq::Hir(rl))) => ll.kind == rl.kind,\n+        (Delimited(la), Delimited(ra)) => eq_delim_args(la, ra),\n+        (Eq(_, AttrArgsEq::Ast(le)), Eq(_, AttrArgsEq::Ast(re))) => eq_expr(le, re),\n+        (Eq(_, AttrArgsEq::Hir(ll)), Eq(_, AttrArgsEq::Hir(rl))) => ll.kind == rl.kind,\n         _ => false,\n     }\n }\n+\n+pub fn eq_delim_args(l: &DelimArgs, r: &DelimArgs) -> bool {\n+    l.delim == r.delim && l.tokens.eq_unspanned(&r.tokens)\n+}"}, {"sha": "96711936968b5d4ddd1f3f7fb0f3c52d33a69e9f", "filename": "clippy_utils/src/eager_or_lazy.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d822110d3b5625b9dc80ccc442e06fc3cc851d76/clippy_utils%2Fsrc%2Feager_or_lazy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d822110d3b5625b9dc80ccc442e06fc3cc851d76/clippy_utils%2Fsrc%2Feager_or_lazy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Feager_or_lazy.rs?ref=d822110d3b5625b9dc80ccc442e06fc3cc851d76", "patch": "@@ -73,7 +73,7 @@ fn fn_eagerness(cx: &LateContext<'_>, fn_id: DefId, name: Symbol, have_one_arg:\n             .flat_map(|v| v.fields.iter())\n             .any(|x| matches!(cx.tcx.type_of(x.did).peel_refs().kind(), ty::Param(_)))\n             && all_predicates_of(cx.tcx, fn_id).all(|(pred, _)| match pred.kind().skip_binder() {\n-                PredicateKind::Trait(pred) => cx.tcx.trait_def(pred.trait_ref.def_id).is_marker,\n+                PredicateKind::Clause(ty::Clause::Trait(pred)) => cx.tcx.trait_def(pred.trait_ref.def_id).is_marker,\n                 _ => true,\n             })\n             && subs.types().all(|x| matches!(x.peel_refs().kind(), ty::Param(_)))"}, {"sha": "07fb6af91ba042f8a6372abb74171233ea891eb3", "filename": "clippy_utils/src/hir_utils.rs", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d822110d3b5625b9dc80ccc442e06fc3cc851d76/clippy_utils%2Fsrc%2Fhir_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d822110d3b5625b9dc80ccc442e06fc3cc851d76/clippy_utils%2Fsrc%2Fhir_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fhir_utils.rs?ref=d822110d3b5625b9dc80ccc442e06fc3cc851d76", "patch": "@@ -7,7 +7,7 @@ use rustc_hir::def::Res;\n use rustc_hir::HirIdMap;\n use rustc_hir::{\n     ArrayLen, BinOpKind, BindingAnnotation, Block, BodyId, Closure, Expr, ExprField, ExprKind, FnRetTy, GenericArg,\n-    GenericArgs, Guard, HirId, InlineAsmOperand, Let, Lifetime, LifetimeName, ParamName, Pat, PatField, PatKind, Path,\n+    GenericArgs, Guard, HirId, InlineAsmOperand, Let, Lifetime, LifetimeName, Pat, PatField, PatKind, Path,\n     PathSegment, PrimTy, QPath, Stmt, StmtKind, Ty, TyKind, TypeBinding,\n };\n use rustc_lexer::{tokenize, TokenKind};\n@@ -113,7 +113,7 @@ impl HirEqInterExpr<'_, '_, '_> {\n                     }\n                 }\n \n-                // eq_pat adds the HirIds to the locals map. We therefor call it last to make sure that\n+                // eq_pat adds the HirIds to the locals map. We therefore call it last to make sure that\n                 // these only get added if the init and type is equal.\n                 both(&l.init, &r.init, |l, r| self.eq_expr(l, r))\n                     && both(&l.ty, &r.ty, |l, r| self.eq_ty(l, r))\n@@ -337,7 +337,7 @@ impl HirEqInterExpr<'_, '_, '_> {\n     }\n \n     fn eq_lifetime(left: &Lifetime, right: &Lifetime) -> bool {\n-        left.name == right.name\n+        left.res == right.res\n     }\n \n     fn eq_pat_field(&mut self, left: &PatField<'_>, right: &PatField<'_>) -> bool {\n@@ -925,16 +925,10 @@ impl<'a, 'tcx> SpanlessHash<'a, 'tcx> {\n     }\n \n     pub fn hash_lifetime(&mut self, lifetime: &Lifetime) {\n-        std::mem::discriminant(&lifetime.name).hash(&mut self.s);\n-        if let LifetimeName::Param(param_id, ref name) = lifetime.name {\n-            std::mem::discriminant(name).hash(&mut self.s);\n+        lifetime.ident.name.hash(&mut self.s);\n+        std::mem::discriminant(&lifetime.res).hash(&mut self.s);\n+        if let LifetimeName::Param(param_id) = lifetime.res {\n             param_id.hash(&mut self.s);\n-            match name {\n-                ParamName::Plain(ref ident) => {\n-                    ident.name.hash(&mut self.s);\n-                },\n-                ParamName::Fresh | ParamName::Error => {},\n-            }\n         }\n     }\n "}, {"sha": "6417f0f3c71348bb6761918cb08c7c373e7b9bc6", "filename": "clippy_utils/src/paths.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d822110d3b5625b9dc80ccc442e06fc3cc851d76/clippy_utils%2Fsrc%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d822110d3b5625b9dc80ccc442e06fc3cc851d76/clippy_utils%2Fsrc%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fpaths.rs?ref=d822110d3b5625b9dc80ccc442e06fc3cc851d76", "patch": "@@ -74,7 +74,6 @@ pub const PEEKABLE: [&str; 5] = [\"core\", \"iter\", \"adapters\", \"peekable\", \"Peekab\n pub const PERMISSIONS: [&str; 3] = [\"std\", \"fs\", \"Permissions\"];\n #[cfg_attr(not(unix), allow(clippy::invalid_paths))]\n pub const PERMISSIONS_FROM_MODE: [&str; 6] = [\"std\", \"os\", \"unix\", \"fs\", \"PermissionsExt\", \"from_mode\"];\n-pub const POLL: [&str; 4] = [\"core\", \"task\", \"poll\", \"Poll\"];\n pub const PTR_COPY: [&str; 3] = [\"core\", \"intrinsics\", \"copy\"];\n pub const PTR_COPY_NONOVERLAPPING: [&str; 3] = [\"core\", \"intrinsics\", \"copy_nonoverlapping\"];\n pub const PTR_EQ: [&str; 3] = [\"core\", \"ptr\", \"eq\"];"}, {"sha": "480e8e55cf39cc8c66b0edf209a7f609c0071ccb", "filename": "clippy_utils/src/qualify_min_const_fn.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d822110d3b5625b9dc80ccc442e06fc3cc851d76/clippy_utils%2Fsrc%2Fqualify_min_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d822110d3b5625b9dc80ccc442e06fc3cc851d76/clippy_utils%2Fsrc%2Fqualify_min_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fqualify_min_const_fn.rs?ref=d822110d3b5625b9dc80ccc442e06fc3cc851d76", "patch": "@@ -26,18 +26,21 @@ pub fn is_min_const_fn<'tcx>(tcx: TyCtxt<'tcx>, body: &Body<'tcx>, msrv: &Msrv)\n         let predicates = tcx.predicates_of(current);\n         for (predicate, _) in predicates.predicates {\n             match predicate.kind().skip_binder() {\n-                ty::PredicateKind::RegionOutlives(_)\n-                | ty::PredicateKind::TypeOutlives(_)\n+                ty::PredicateKind::Clause(\n+                    ty::Clause::RegionOutlives(_)\n+                    | ty::Clause::TypeOutlives(_)\n+                    | ty::Clause::Projection(_)\n+                    | ty::Clause::Trait(..),\n+                )\n                 | ty::PredicateKind::WellFormed(_)\n-                | ty::PredicateKind::Projection(_)\n                 | ty::PredicateKind::ConstEvaluatable(..)\n                 | ty::PredicateKind::ConstEquate(..)\n-                | ty::PredicateKind::Trait(..)\n                 | ty::PredicateKind::TypeWellFormedFromEnv(..) => continue,\n                 ty::PredicateKind::ObjectSafe(_) => panic!(\"object safe predicate on function: {predicate:#?}\"),\n                 ty::PredicateKind::ClosureKind(..) => panic!(\"closure kind predicate on function: {predicate:#?}\"),\n                 ty::PredicateKind::Subtype(_) => panic!(\"subtype predicate on function: {predicate:#?}\"),\n                 ty::PredicateKind::Coerce(_) => panic!(\"coerce predicate on function: {predicate:#?}\"),\n+                ty::PredicateKind::Ambiguous => panic!(\"ambiguous predicate on function: {predicate:#?}\"),\n             }\n         }\n         match predicates.parent {"}, {"sha": "bfb2d472a393cf0525955de8f38dce24e0f270b2", "filename": "clippy_utils/src/ty.rs", "status": "modified", "additions": 44, "deletions": 42, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/d822110d3b5625b9dc80ccc442e06fc3cc851d76/clippy_utils%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d822110d3b5625b9dc80ccc442e06fc3cc851d76/clippy_utils%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fty.rs?ref=d822110d3b5625b9dc80ccc442e06fc3cc851d76", "patch": "@@ -9,20 +9,23 @@ use rustc_hir as hir;\n use rustc_hir::def::{CtorKind, CtorOf, DefKind, Res};\n use rustc_hir::def_id::DefId;\n use rustc_hir::{Expr, FnDecl, LangItem, TyKind, Unsafety};\n-use rustc_infer::infer::TyCtxtInferExt;\n+use rustc_infer::infer::{\n+    type_variable::{TypeVariableOrigin, TypeVariableOriginKind},\n+    TyCtxtInferExt,\n+};\n use rustc_lint::LateContext;\n use rustc_middle::mir::interpret::{ConstValue, Scalar};\n use rustc_middle::ty::{\n-    self, AdtDef, AssocKind, Binder, BoundRegion, DefIdTree, FnSig, GenericParamDefKind, IntTy, List, ParamEnv,\n-    Predicate, PredicateKind, ProjectionTy, Region, RegionKind, SubstsRef, Ty, TyCtxt, TypeSuperVisitable,\n-    TypeVisitable, TypeVisitor, UintTy, VariantDef, VariantDiscr,\n+    self, AdtDef, AssocKind, Binder, BoundRegion, DefIdTree, FnSig, IntTy, List, ParamEnv, Predicate, PredicateKind,\n+    ProjectionTy, Region, RegionKind, SubstsRef, Ty, TyCtxt, TypeSuperVisitable, TypeVisitable, TypeVisitor, UintTy,\n+    VariantDef, VariantDiscr,\n };\n use rustc_middle::ty::{GenericArg, GenericArgKind};\n use rustc_span::symbol::Ident;\n-use rustc_span::{sym, Span, Symbol};\n+use rustc_span::{sym, Span, Symbol, DUMMY_SP};\n use rustc_target::abi::{Size, VariantIdx};\n use rustc_trait_selection::infer::InferCtxtExt;\n-use rustc_trait_selection::traits::query::normalize::AtExt;\n+use rustc_trait_selection::traits::query::normalize::QueryNormalizeExt;\n use std::iter;\n \n use crate::{match_def_path, path_res, paths};\n@@ -81,7 +84,7 @@ pub fn contains_ty_adt_constructor_opaque<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'\n                     match predicate.kind().skip_binder() {\n                         // For `impl Trait<U>`, it will register a predicate of `T: Trait<U>`, so we go through\n                         // and check substituions to find `U`.\n-                        ty::PredicateKind::Trait(trait_predicate) => {\n+                        ty::PredicateKind::Clause(ty::Clause::Trait(trait_predicate)) => {\n                             if trait_predicate\n                                 .trait_ref\n                                 .substs\n@@ -94,7 +97,7 @@ pub fn contains_ty_adt_constructor_opaque<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'\n                         },\n                         // For `impl Trait<Assoc=U>`, it will register a predicate of `<T as Trait>::Assoc = U`,\n                         // so we check the term for `U`.\n-                        ty::PredicateKind::Projection(projection_predicate) => {\n+                        ty::PredicateKind::Clause(ty::Clause::Projection(projection_predicate)) => {\n                             if let ty::TermKind::Ty(ty) = projection_predicate.term.unpack() {\n                                 if contains_ty_adt_constructor_opaque(cx, ty, needle) {\n                                     return true;\n@@ -117,24 +120,7 @@ pub fn contains_ty_adt_constructor_opaque<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'\n pub fn get_iterator_item_ty<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> Option<Ty<'tcx>> {\n     cx.tcx\n         .get_diagnostic_item(sym::Iterator)\n-        .and_then(|iter_did| get_associated_type(cx, ty, iter_did, \"Item\"))\n-}\n-\n-/// Returns the associated type `name` for `ty` as an implementation of `trait_id`.\n-/// Do not invoke without first verifying that the type implements the trait.\n-pub fn get_associated_type<'tcx>(\n-    cx: &LateContext<'tcx>,\n-    ty: Ty<'tcx>,\n-    trait_id: DefId,\n-    name: &str,\n-) -> Option<Ty<'tcx>> {\n-    cx.tcx\n-        .associated_items(trait_id)\n-        .find_by_name_and_kind(cx.tcx, Ident::from_str(name), ty::AssocKind::Type, trait_id)\n-        .and_then(|assoc| {\n-            let proj = cx.tcx.mk_projection(assoc.def_id, cx.tcx.mk_substs_trait(ty, &[]));\n-            cx.tcx.try_normalize_erasing_regions(cx.param_env, proj).ok()\n-        })\n+        .and_then(|iter_did| cx.get_associated_type(ty, iter_did, \"Item\"))\n }\n \n /// Get the diagnostic name of a type, e.g. `sym::HashMap`. To check if a type\n@@ -206,7 +192,13 @@ pub fn implements_trait<'tcx>(\n     trait_id: DefId,\n     ty_params: &[GenericArg<'tcx>],\n ) -> bool {\n-    implements_trait_with_env(cx.tcx, cx.param_env, ty, trait_id, ty_params)\n+    implements_trait_with_env(\n+        cx.tcx,\n+        cx.param_env,\n+        ty,\n+        trait_id,\n+        ty_params.iter().map(|&arg| Some(arg)),\n+    )\n }\n \n /// Same as `implements_trait` but allows using a `ParamEnv` different from the lint context.\n@@ -215,7 +207,7 @@ pub fn implements_trait_with_env<'tcx>(\n     param_env: ParamEnv<'tcx>,\n     ty: Ty<'tcx>,\n     trait_id: DefId,\n-    ty_params: &[GenericArg<'tcx>],\n+    ty_params: impl IntoIterator<Item = Option<GenericArg<'tcx>>>,\n ) -> bool {\n     // Clippy shouldn't have infer types\n     assert!(!ty.needs_infer());\n@@ -224,10 +216,18 @@ pub fn implements_trait_with_env<'tcx>(\n     if ty.has_escaping_bound_vars() {\n         return false;\n     }\n-    let ty_params = tcx.mk_substs(ty_params.iter());\n     let infcx = tcx.infer_ctxt().build();\n+    let orig = TypeVariableOrigin {\n+        kind: TypeVariableOriginKind::MiscVariable,\n+        span: DUMMY_SP,\n+    };\n+    let ty_params = tcx.mk_substs(\n+        ty_params\n+            .into_iter()\n+            .map(|arg| arg.unwrap_or_else(|| infcx.next_ty_var(orig).into())),\n+    );\n     infcx\n-        .type_implements_trait(trait_id, ty, ty_params, param_env)\n+        .type_implements_trait(trait_id, [ty.into()].into_iter().chain(ty_params), param_env)\n         .must_apply_modulo_regions()\n }\n \n@@ -252,7 +252,7 @@ pub fn is_must_use_ty<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> bool {\n         ty::Tuple(substs) => substs.iter().any(|ty| is_must_use_ty(cx, ty)),\n         ty::Opaque(def_id, _) => {\n             for (predicate, _) in cx.tcx.explicit_item_bounds(*def_id) {\n-                if let ty::PredicateKind::Trait(trait_predicate) = predicate.kind().skip_binder() {\n+                if let ty::PredicateKind::Clause(ty::Clause::Trait(trait_predicate)) = predicate.kind().skip_binder() {\n                     if cx.tcx.has_attr(trait_predicate.trait_ref.def_id, sym::must_use) {\n                         return true;\n                     }\n@@ -296,7 +296,7 @@ fn is_normalizable_helper<'tcx>(\n     cache.insert(ty, false);\n     let infcx = cx.tcx.infer_ctxt().build();\n     let cause = rustc_middle::traits::ObligationCause::dummy();\n-    let result = if infcx.at(&cause, param_env).normalize(ty).is_ok() {\n+    let result = if infcx.at(&cause, param_env).query_normalize(ty).is_ok() {\n         match ty.kind() {\n             ty::Adt(def, substs) => def.variants().iter().all(|variant| {\n                 variant\n@@ -671,7 +671,7 @@ fn sig_from_bounds<'tcx>(\n \n     for pred in predicates {\n         match pred.kind().skip_binder() {\n-            PredicateKind::Trait(p)\n+            PredicateKind::Clause(ty::Clause::Trait(p))\n                 if (lang_items.fn_trait() == Some(p.def_id())\n                     || lang_items.fn_mut_trait() == Some(p.def_id())\n                     || lang_items.fn_once_trait() == Some(p.def_id()))\n@@ -684,7 +684,7 @@ fn sig_from_bounds<'tcx>(\n                 }\n                 inputs = Some(i);\n             },\n-            PredicateKind::Projection(p)\n+            PredicateKind::Clause(ty::Clause::Projection(p))\n                 if Some(p.projection_ty.item_def_id) == lang_items.fn_once_output()\n                     && p.projection_ty.self_ty() == ty =>\n             {\n@@ -712,7 +712,7 @@ fn sig_for_projection<'tcx>(cx: &LateContext<'tcx>, ty: ProjectionTy<'tcx>) -> O\n         .subst_iter_copied(cx.tcx, ty.substs)\n     {\n         match pred.kind().skip_binder() {\n-            PredicateKind::Trait(p)\n+            PredicateKind::Clause(ty::Clause::Trait(p))\n                 if (lang_items.fn_trait() == Some(p.def_id())\n                     || lang_items.fn_mut_trait() == Some(p.def_id())\n                     || lang_items.fn_once_trait() == Some(p.def_id())) =>\n@@ -725,7 +725,9 @@ fn sig_for_projection<'tcx>(cx: &LateContext<'tcx>, ty: ProjectionTy<'tcx>) -> O\n                 }\n                 inputs = Some(i);\n             },\n-            PredicateKind::Projection(p) if Some(p.projection_ty.item_def_id) == lang_items.fn_once_output() => {\n+            PredicateKind::Clause(ty::Clause::Projection(p))\n+                if Some(p.projection_ty.item_def_id) == lang_items.fn_once_output() =>\n+            {\n                 if output.is_some() {\n                     // Multiple different fn trait impls. Is this even allowed?\n                     return None;\n@@ -900,7 +902,7 @@ pub fn ty_is_fn_once_param<'tcx>(tcx: TyCtxt<'_>, ty: Ty<'tcx>, predicates: &'tc\n     predicates\n         .iter()\n         .try_fold(false, |found, p| {\n-            if let PredicateKind::Trait(p) = p.kind().skip_binder()\n+            if let PredicateKind::Clause(ty::Clause::Trait(p)) = p.kind().skip_binder()\n             && let ty::Param(self_ty) = p.trait_ref.self_ty().kind()\n             && ty.index == self_ty.index\n         {\n@@ -1010,7 +1012,7 @@ pub fn make_projection<'tcx>(\n                     the given arguments are: `{substs:#?}`\",\n                 assoc_item.def_id,\n                 substs.len(),\n-                params.map(GenericParamDefKind::descr).collect::<Vec<_>>(),\n+                params.map(ty::GenericParamDefKind::descr).collect::<Vec<_>>(),\n             );\n \n             if let Some((idx, (param, arg))) = params\n@@ -1020,9 +1022,9 @@ pub fn make_projection<'tcx>(\n                 .find(|(_, (param, arg))| {\n                     !matches!(\n                         (param, arg),\n-                        (GenericParamDefKind::Lifetime, GenericArgKind::Lifetime(_))\n-                            | (GenericParamDefKind::Type { .. }, GenericArgKind::Type(_))\n-                            | (GenericParamDefKind::Const { .. }, GenericArgKind::Const(_))\n+                        (ty::GenericParamDefKind::Lifetime, GenericArgKind::Lifetime(_))\n+                            | (ty::GenericParamDefKind::Type { .. }, GenericArgKind::Type(_))\n+                            | (ty::GenericParamDefKind::Const { .. }, GenericArgKind::Const(_))\n                     )\n                 })\n             {\n@@ -1032,7 +1034,7 @@ pub fn make_projection<'tcx>(\n                         note: the expected parameters are {:#?}\\n\\\n                         the given arguments are {substs:#?}\",\n                     param.descr(),\n-                    params.map(GenericParamDefKind::descr).collect::<Vec<_>>()\n+                    params.map(ty::GenericParamDefKind::descr).collect::<Vec<_>>()\n                 );\n             }\n         }"}, {"sha": "082570f1fe5d87a1924f3503a02ce5fcf6931b4e", "filename": "declare_clippy_lint/Cargo.toml", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d822110d3b5625b9dc80ccc442e06fc3cc851d76/declare_clippy_lint%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/d822110d3b5625b9dc80ccc442e06fc3cc851d76/declare_clippy_lint%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/declare_clippy_lint%2FCargo.toml?ref=d822110d3b5625b9dc80ccc442e06fc3cc851d76", "patch": "@@ -11,3 +11,6 @@ proc-macro = true\n itertools = \"0.10.1\"\n quote = \"1.0.21\"\n syn = \"1.0.100\"\n+\n+[features]\n+deny-warnings = []"}, {"sha": "26210556d6526a7235fb840fdd5a30142e9cfaa2", "filename": "declare_clippy_lint/src/lib.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d822110d3b5625b9dc80ccc442e06fc3cc851d76/declare_clippy_lint%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d822110d3b5625b9dc80ccc442e06fc3cc851d76/declare_clippy_lint%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/declare_clippy_lint%2Fsrc%2Flib.rs?ref=d822110d3b5625b9dc80ccc442e06fc3cc851d76", "patch": "@@ -1,5 +1,7 @@\n #![feature(let_chains)]\n #![cfg_attr(feature = \"deny-warnings\", deny(warnings))]\n+// warn on lints, that are included in `rust-lang/rust`s bootstrap\n+#![warn(rust_2018_idioms, unused_lifetimes)]\n \n use proc_macro::TokenStream;\n use quote::{format_ident, quote};\n@@ -29,7 +31,7 @@ struct ClippyLint {\n }\n \n impl Parse for ClippyLint {\n-    fn parse(input: ParseStream) -> Result<Self> {\n+    fn parse(input: ParseStream<'_>) -> Result<Self> {\n         let attrs = input.call(Attribute::parse_outer)?;\n \n         let mut in_code = false;"}, {"sha": "19fee38db46e642eb18f600b1a3b7d8b6e8a814f", "filename": "rust-toolchain", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d822110d3b5625b9dc80ccc442e06fc3cc851d76/rust-toolchain", "raw_url": "https://github.com/rust-lang/rust/raw/d822110d3b5625b9dc80ccc442e06fc3cc851d76/rust-toolchain", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rust-toolchain?ref=d822110d3b5625b9dc80ccc442e06fc3cc851d76", "patch": "@@ -1,3 +1,3 @@\n [toolchain]\n-channel = \"nightly-2022-11-21\"\n+channel = \"nightly-2022-12-01\"\n components = [\"cargo\", \"llvm-tools\", \"rust-src\", \"rust-std\", \"rustc\", \"rustc-dev\", \"rustfmt\"]"}, {"sha": "9ec4df8e651b1bf3f7756656f8548f5c2ec8e9c0", "filename": "src/driver.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d822110d3b5625b9dc80ccc442e06fc3cc851d76/src%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d822110d3b5625b9dc80ccc442e06fc3cc851d76/src%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdriver.rs?ref=d822110d3b5625b9dc80ccc442e06fc3cc851d76", "patch": "@@ -1,6 +1,7 @@\n #![feature(rustc_private)]\n #![feature(let_chains)]\n #![feature(once_cell)]\n+#![feature(lint_reasons)]\n #![cfg_attr(feature = \"deny-warnings\", deny(warnings))]\n // warn on lints, that are included in `rust-lang/rust`s bootstrap\n #![warn(rust_2018_idioms, unused_lifetimes)]\n@@ -90,11 +91,16 @@ fn track_files(parse_sess: &mut ParseSess, conf_path_string: Option<String>) {\n \n     // During development track the `clippy-driver` executable so that cargo will re-run clippy whenever\n     // it is rebuilt\n-    if cfg!(debug_assertions)\n-        && let Ok(current_exe) = env::current_exe()\n-        && let Some(current_exe) = current_exe.to_str()\n-    {\n-        file_depinfo.insert(Symbol::intern(current_exe));\n+    #[expect(\n+        clippy::collapsible_if,\n+        reason = \"Due to a bug in let_chains this if statement can't be collapsed\"\n+    )]\n+    if cfg!(debug_assertions) {\n+        if let Ok(current_exe) = env::current_exe()\n+            && let Some(current_exe) = current_exe.to_str()\n+        {\n+            file_depinfo.insert(Symbol::intern(current_exe));\n+        }\n     }\n }\n "}, {"sha": "2a240cc249b0c768f084dab5b6f220ae53a59399", "filename": "tests/ui-internal/unnecessary_def_path_hardcoded_path.stderr", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d822110d3b5625b9dc80ccc442e06fc3cc851d76/tests%2Fui-internal%2Funnecessary_def_path_hardcoded_path.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d822110d3b5625b9dc80ccc442e06fc3cc851d76/tests%2Fui-internal%2Funnecessary_def_path_hardcoded_path.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-internal%2Funnecessary_def_path_hardcoded_path.stderr?ref=d822110d3b5625b9dc80ccc442e06fc3cc851d76", "patch": "@@ -1,19 +1,11 @@\n-error: hardcoded path to a language item\n-  --> $DIR/unnecessary_def_path_hardcoded_path.rs:11:40\n-   |\n-LL |     const DEREF_MUT_TRAIT: [&str; 4] = [\"core\", \"ops\", \"deref\", \"DerefMut\"];\n-   |                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = help: convert all references to use `LangItem::DerefMut`\n-   = note: `-D clippy::unnecessary-def-path` implied by `-D warnings`\n-\n error: hardcoded path to a diagnostic item\n   --> $DIR/unnecessary_def_path_hardcoded_path.rs:10:36\n    |\n LL |     const DEREF_TRAIT: [&str; 4] = [\"core\", \"ops\", \"deref\", \"Deref\"];\n    |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: convert all references to use `sym::Deref`\n+   = note: `-D clippy::unnecessary-def-path` implied by `-D warnings`\n \n error: hardcoded path to a diagnostic item\n   --> $DIR/unnecessary_def_path_hardcoded_path.rs:12:43\n@@ -23,5 +15,13 @@ LL |     const DEREF_TRAIT_METHOD: [&str; 5] = [\"core\", \"ops\", \"deref\", \"Deref\",\n    |\n    = help: convert all references to use `sym::deref_method`\n \n+error: hardcoded path to a language item\n+  --> $DIR/unnecessary_def_path_hardcoded_path.rs:11:40\n+   |\n+LL |     const DEREF_MUT_TRAIT: [&str; 4] = [\"core\", \"ops\", \"deref\", \"DerefMut\"];\n+   |                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: convert all references to use `LangItem::DerefMut`\n+\n error: aborting due to 3 previous errors\n "}, {"sha": "92ba3592967803c41235fd84b4a418528a3bf376", "filename": "tests/ui/async_yields_async.stderr", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d822110d3b5625b9dc80ccc442e06fc3cc851d76/tests%2Fui%2Fasync_yields_async.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d822110d3b5625b9dc80ccc442e06fc3cc851d76/tests%2Fui%2Fasync_yields_async.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fasync_yields_async.stderr?ref=d822110d3b5625b9dc80ccc442e06fc3cc851d76", "patch": "@@ -2,14 +2,14 @@ error: an async construct yields a type which is itself awaitable\n   --> $DIR/async_yields_async.rs:39:9\n    |\n LL |        let _h = async {\n-   |   ____________________-\n-LL |  |         async {\n-   |  |_________^\n+   |  _____________________-\n+LL | |          async {\n+   | | _________^\n LL | ||             3\n LL | ||         }\n    | ||_________^ awaitable value not awaited\n-LL |  |     };\n-   |  |_____- outer async construct\n+LL | |      };\n+   | |______- outer async construct\n    |\n    = note: `-D clippy::async-yields-async` implied by `-D warnings`\n help: consider awaiting this value\n@@ -36,14 +36,14 @@ error: an async construct yields a type which is itself awaitable\n   --> $DIR/async_yields_async.rs:50:9\n    |\n LL |        let _j = async || {\n-   |   _______________________-\n-LL |  |         async {\n-   |  |_________^\n+   |  ________________________-\n+LL | |          async {\n+   | | _________^\n LL | ||             3\n LL | ||         }\n    | ||_________^ awaitable value not awaited\n-LL |  |     };\n-   |  |_____- outer async construct\n+LL | |      };\n+   | |______- outer async construct\n    |\n help: consider awaiting this value\n    |"}, {"sha": "c6acf24c21ecf73cd57470a72d0f1a82a3c602a6", "filename": "tests/ui/author/blocks.stdout", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d822110d3b5625b9dc80ccc442e06fc3cc851d76/tests%2Fui%2Fauthor%2Fblocks.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/d822110d3b5625b9dc80ccc442e06fc3cc851d76/tests%2Fui%2Fauthor%2Fblocks.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fauthor%2Fblocks.stdout?ref=d822110d3b5625b9dc80ccc442e06fc3cc851d76", "patch": "@@ -45,7 +45,7 @@ if let ExprKind::Closure(CaptureBy::Value, fn_decl, body_id, _, None) = expr.kin\n     && expr1 = &cx.tcx.hir().body(body_id).value\n     && let ExprKind::Call(func, args) = expr1.kind\n     && let ExprKind::Path(ref qpath) = func.kind\n-    && matches!(qpath, QPath::LangItem(LangItem::FromGenerator, _))\n+    && matches!(qpath, QPath::LangItem(LangItem::IdentityFuture, _))\n     && args.len() == 1\n     && let ExprKind::Closure(CaptureBy::Value, fn_decl1, body_id1, _, Some(Movability::Static)) = args[0].kind\n     && let FnRetTy::DefaultReturn(_) = fn_decl1.output"}, {"sha": "2e1eb8eb18066796e2eb95c7aa1671ddda5a0e89", "filename": "tests/ui/result_map_unit_fn_unfixable.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d822110d3b5625b9dc80ccc442e06fc3cc851d76/tests%2Fui%2Fresult_map_unit_fn_unfixable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d822110d3b5625b9dc80ccc442e06fc3cc851d76/tests%2Fui%2Fresult_map_unit_fn_unfixable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fresult_map_unit_fn_unfixable.stderr?ref=d822110d3b5625b9dc80ccc442e06fc3cc851d76", "patch": "@@ -20,14 +20,14 @@ error: called `map(f)` on an `Result` value where `f` is a closure that returns\n   --> $DIR/result_map_unit_fn_unfixable.rs:29:5\n    |\n LL |        x.field.map(|value| {\n-   |   _____^\n-   |  |_____|\n+   |  ______^\n+   | | _____|\n    | ||\n LL | ||         do_nothing(value);\n LL | ||         do_nothing(value)\n LL | ||     });\n    | ||______^- help: try this: `if let Ok(value) = x.field { ... }`\n-   | |_______|\n+   |  |______|\n    | \n \n error: called `map(f)` on an `Result` value where `f` is a closure that returns the unit type `()`"}]}