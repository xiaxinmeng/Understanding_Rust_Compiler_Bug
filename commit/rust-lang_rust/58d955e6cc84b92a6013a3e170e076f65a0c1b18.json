{"sha": "58d955e6cc84b92a6013a3e170e076f65a0c1b18", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU4ZDk1NWU2Y2M4NGI5MmE2MDEzYTNlMTcwZTA3NmY2NWEwYzFiMTg=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2020-04-30T12:07:53Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-04-30T12:07:53Z"}, "message": "Rollup merge of #71540 - ldm0:ref2ptr, r=oli-obk\n\nSuggest deref when coercing `ty::Ref` to `ty::RawPtr`\n\nFixes #32122\n\nCurrently we do autoderef when casting `ty::Ref` ->`ty::Ref`, but we don't autoderef when casting `ty::Ref` -> `ty::RawPtr`. This PR make the compiler suggests deref when coercing `ty::Ref` to `ty::RawPtr`", "tree": {"sha": "311eed86e28394afb831c12b9943f32f602f7076", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/311eed86e28394afb831c12b9943f32f602f7076"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/58d955e6cc84b92a6013a3e170e076f65a0c1b18", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJeqr+aCRBK7hj4Ov3rIwAAdHIIABZgnhMfVzll3RZEteUGZeZz\n2iCupgjojUP5fM21cNQvHIv55TAWouEeCBapfVf9ycO7IlBfifgeK31kJAJbF/X+\n/dvlEzI8fgHFsg7X4z8shL+25I/KltsOQREOHCkXayPEG95AkRi5VqB6+jY9Mo5w\nWMskv6RfmqVc8fkzFyjD7/CkLHtbvoMju7AklcxyRX9x7BlHbo5z2VBETjyjrMgR\nf+GFyHnfLFlI2mvVGx9IIeAsrIuGAbCtfB63hjw+bq4HoRCybjo2CLMELtzwHDtU\nwvRfWVlBNGG6ZGwTrGknlBse/P9U+e5k+oDMHYZZEjrLZEegIFR3oxtRynx1HUU=\n=Ekxl\n-----END PGP SIGNATURE-----\n", "payload": "tree 311eed86e28394afb831c12b9943f32f602f7076\nparent 4e6772b52bc9832bb47bedba61abdcfb4ba0128e\nparent a9858791134253d004971664fd7e9bd9b0983723\nauthor Dylan DPC <dylan.dpc@gmail.com> 1588248473 +0200\ncommitter GitHub <noreply@github.com> 1588248473 +0200\n\nRollup merge of #71540 - ldm0:ref2ptr, r=oli-obk\n\nSuggest deref when coercing `ty::Ref` to `ty::RawPtr`\n\nFixes #32122\n\nCurrently we do autoderef when casting `ty::Ref` ->`ty::Ref`, but we don't autoderef when casting `ty::Ref` -> `ty::RawPtr`. This PR make the compiler suggests deref when coercing `ty::Ref` to `ty::RawPtr`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/58d955e6cc84b92a6013a3e170e076f65a0c1b18", "html_url": "https://github.com/rust-lang/rust/commit/58d955e6cc84b92a6013a3e170e076f65a0c1b18", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/58d955e6cc84b92a6013a3e170e076f65a0c1b18/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4e6772b52bc9832bb47bedba61abdcfb4ba0128e", "url": "https://api.github.com/repos/rust-lang/rust/commits/4e6772b52bc9832bb47bedba61abdcfb4ba0128e", "html_url": "https://github.com/rust-lang/rust/commit/4e6772b52bc9832bb47bedba61abdcfb4ba0128e"}, {"sha": "a9858791134253d004971664fd7e9bd9b0983723", "url": "https://api.github.com/repos/rust-lang/rust/commits/a9858791134253d004971664fd7e9bd9b0983723", "html_url": "https://github.com/rust-lang/rust/commit/a9858791134253d004971664fd7e9bd9b0983723"}], "stats": {"total": 174, "additions": 166, "deletions": 8}, "files": [{"sha": "5d1a1a164855df6f84e4adea0204e4aa01d34d08", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/58d955e6cc84b92a6013a3e170e076f65a0c1b18/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58d955e6cc84b92a6013a3e170e076f65a0c1b18/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=58d955e6cc84b92a6013a3e170e076f65a0c1b18", "patch": "@@ -74,7 +74,7 @@ use rustc_trait_selection::traits::{self, ObligationCause, ObligationCauseCode};\n use smallvec::{smallvec, SmallVec};\n use std::ops::Deref;\n \n-struct Coerce<'a, 'tcx> {\n+pub struct Coerce<'a, 'tcx> {\n     fcx: &'a FnCtxt<'a, 'tcx>,\n     cause: ObligationCause<'tcx>,\n     use_lub: bool,\n@@ -124,15 +124,15 @@ fn success<'tcx>(\n }\n \n impl<'f, 'tcx> Coerce<'f, 'tcx> {\n-    fn new(\n+    pub fn new(\n         fcx: &'f FnCtxt<'f, 'tcx>,\n         cause: ObligationCause<'tcx>,\n         allow_two_phase: AllowTwoPhase,\n     ) -> Self {\n         Coerce { fcx, cause, allow_two_phase, use_lub: false }\n     }\n \n-    fn unify(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> InferResult<'tcx, Ty<'tcx>> {\n+    pub fn unify(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> InferResult<'tcx, Ty<'tcx>> {\n         self.commit_if_ok(|_| {\n             if self.use_lub {\n                 self.at(&self.cause, self.fcx.param_env).lub(b, a)\n@@ -771,10 +771,10 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n             ty::RawPtr(mt) => (false, mt),\n             _ => return self.unify_and(a, b, identity),\n         };\n+        coerce_mutbls(mt_a.mutbl, mutbl_b)?;\n \n         // Check that the types which they point at are compatible.\n         let a_unsafe = self.tcx.mk_ptr(ty::TypeAndMut { mutbl: mutbl_b, ty: mt_a.ty });\n-        coerce_mutbls(mt_a.mutbl, mutbl_b)?;\n         // Although references and unsafe ptrs have the same\n         // representation, we still register an Adjust::DerefRef so that\n         // regionck knows that the region for `a` must be valid here."}, {"sha": "65ef9cad874486033ce86a28d7ff484f3d15471a", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 38, "deletions": 2, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/58d955e6cc84b92a6013a3e170e076f65a0c1b18/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58d955e6cc84b92a6013a3e170e076f65a0c1b18/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=58d955e6cc84b92a6013a3e170e076f65a0c1b18", "patch": "@@ -1,3 +1,4 @@\n+use crate::check::coercion::Coerce;\n use crate::check::FnCtxt;\n use rustc_infer::infer::InferOk;\n use rustc_trait_selection::infer::InferCtxtExt as _;\n@@ -8,8 +9,9 @@ use rustc_ast::util::parser::PREC_POSTFIX;\n use rustc_errors::{Applicability, DiagnosticBuilder};\n use rustc_hir as hir;\n use rustc_hir::{is_range_literal, Node};\n+use rustc_middle::traits::ObligationCauseCode;\n use rustc_middle::ty::adjustment::AllowTwoPhase;\n-use rustc_middle::ty::{self, AssocItem, Ty};\n+use rustc_middle::ty::{self, AssocItem, Ty, TypeAndMut};\n use rustc_span::symbol::sym;\n use rustc_span::Span;\n \n@@ -25,7 +27,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     ) {\n         self.annotate_expected_due_to_let_ty(err, expr);\n         self.suggest_compatible_variants(err, expr, expected, expr_ty);\n-        self.suggest_ref_or_into(err, expr, expected, expr_ty);\n+        self.suggest_deref_ref_or_into(err, expr, expected, expr_ty);\n         if self.suggest_calling_boxed_future_when_appropriate(err, expr, expected, expr_ty) {\n             return;\n         }\n@@ -539,6 +541,40 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     return Some((sp, \"consider removing the borrow\", code));\n                 }\n             }\n+            (\n+                _,\n+                &ty::RawPtr(TypeAndMut { ty: _, mutbl: hir::Mutability::Not }),\n+                &ty::Ref(_, _, hir::Mutability::Not),\n+            ) => {\n+                let cause = self.cause(rustc_span::DUMMY_SP, ObligationCauseCode::ExprAssignable);\n+                // We don't ever need two-phase here since we throw out the result of the coercion\n+                let coerce = Coerce::new(self, cause, AllowTwoPhase::No);\n+\n+                if let Some(steps) =\n+                    coerce.autoderef(sp, checked_ty).skip(1).find_map(|(referent_ty, steps)| {\n+                        coerce\n+                            .unify(\n+                                coerce.tcx.mk_ptr(ty::TypeAndMut {\n+                                    mutbl: hir::Mutability::Not,\n+                                    ty: referent_ty,\n+                                }),\n+                                expected,\n+                            )\n+                            .ok()\n+                            .map(|_| steps)\n+                    })\n+                {\n+                    // The pointer type implements `Copy` trait so the suggestion is always valid.\n+                    if let Ok(code) = sm.span_to_snippet(sp) {\n+                        if code.starts_with('&') {\n+                            let derefs = \"*\".repeat(steps - 1);\n+                            let message = \"consider dereferencing the reference\";\n+                            let suggestion = format!(\"&{}{}\", derefs, code[1..].to_string());\n+                            return Some((sp, message, suggestion));\n+                        }\n+                    }\n+                }\n+            }\n             _ if sp == expr.span && !is_macro => {\n                 // Check for `Deref` implementations by constructing a predicate to\n                 // prove: `<T as Deref>::Output == U`"}, {"sha": "92ddfbff824cdc2559c0c4a891fe00e11cdfa4cd", "filename": "src/librustc_typeck/check/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/58d955e6cc84b92a6013a3e170e076f65a0c1b18/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58d955e6cc84b92a6013a3e170e076f65a0c1b18/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs?ref=58d955e6cc84b92a6013a3e170e076f65a0c1b18", "patch": "@@ -86,7 +86,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         if let Some(mut err) = self.demand_suptype_diag(expr.span, expected_ty, ty) {\n             let expr = expr.peel_drop_temps();\n-            self.suggest_ref_or_into(&mut err, expr, expected_ty, ty);\n+            self.suggest_deref_ref_or_into(&mut err, expr, expected_ty, ty);\n             extend_err(&mut err);\n             // Error possibly reported in `check_assign` so avoid emitting error again.\n             err.emit_unless(self.is_assign_to_bool(expr, expected_ty));"}, {"sha": "adbab3d4cb620c1543af1bee8dabb76d42e8235e", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/58d955e6cc84b92a6013a3e170e076f65a0c1b18/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58d955e6cc84b92a6013a3e170e076f65a0c1b18/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=58d955e6cc84b92a6013a3e170e076f65a0c1b18", "patch": "@@ -5029,7 +5029,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         false\n     }\n \n-    pub fn suggest_ref_or_into(\n+    pub fn suggest_deref_ref_or_into(\n         &self,\n         err: &mut DiagnosticBuilder<'_>,\n         expr: &hir::Expr<'_>,"}, {"sha": "4fc5f64ff9a4500c389738659413d7dca1012c0f", "filename": "src/test/ui/issues/issue-32122-1.fixed", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/58d955e6cc84b92a6013a3e170e076f65a0c1b18/src%2Ftest%2Fui%2Fissues%2Fissue-32122-1.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/58d955e6cc84b92a6013a3e170e076f65a0c1b18/src%2Ftest%2Fui%2Fissues%2Fissue-32122-1.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-32122-1.fixed?ref=58d955e6cc84b92a6013a3e170e076f65a0c1b18", "patch": "@@ -0,0 +1,17 @@\n+// run-rustfix\n+use std::ops::Deref;\n+\n+struct Foo(u8);\n+\n+impl Deref for Foo {\n+    type Target = u8;\n+    fn deref(&self) -> &Self::Target {\n+        &self.0\n+    }\n+}\n+\n+fn main() {\n+    let a = Foo(0);\n+    // Should suggest `&*` when coercing &ty to *const ty\n+    let _: *const u8 = &*a; //~ ERROR mismatched types\n+}"}, {"sha": "3c4859f07a2e7cc92e96b80732d4534b6901d760", "filename": "src/test/ui/issues/issue-32122-1.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/58d955e6cc84b92a6013a3e170e076f65a0c1b18/src%2Ftest%2Fui%2Fissues%2Fissue-32122-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58d955e6cc84b92a6013a3e170e076f65a0c1b18/src%2Ftest%2Fui%2Fissues%2Fissue-32122-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-32122-1.rs?ref=58d955e6cc84b92a6013a3e170e076f65a0c1b18", "patch": "@@ -0,0 +1,17 @@\n+// run-rustfix\n+use std::ops::Deref;\n+\n+struct Foo(u8);\n+\n+impl Deref for Foo {\n+    type Target = u8;\n+    fn deref(&self) -> &Self::Target {\n+        &self.0\n+    }\n+}\n+\n+fn main() {\n+    let a = Foo(0);\n+    // Should suggest `&*` when coercing &ty to *const ty\n+    let _: *const u8 = &a; //~ ERROR mismatched types\n+}"}, {"sha": "313de275c53ee625a74c0bec0ec01390d98414d2", "filename": "src/test/ui/issues/issue-32122-1.stderr", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/58d955e6cc84b92a6013a3e170e076f65a0c1b18/src%2Ftest%2Fui%2Fissues%2Fissue-32122-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/58d955e6cc84b92a6013a3e170e076f65a0c1b18/src%2Ftest%2Fui%2Fissues%2Fissue-32122-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-32122-1.stderr?ref=58d955e6cc84b92a6013a3e170e076f65a0c1b18", "patch": "@@ -0,0 +1,16 @@\n+error[E0308]: mismatched types\n+  --> $DIR/issue-32122-1.rs:16:24\n+   |\n+LL |     let _: *const u8 = &a;\n+   |            ---------   ^^\n+   |            |           |\n+   |            |           expected `u8`, found struct `Foo`\n+   |            |           help: consider dereferencing the reference: `&*a`\n+   |            expected due to this\n+   |\n+   = note: expected raw pointer `*const u8`\n+                found reference `&Foo`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "cee0e59297657dcd37b55295abad0cf2274373bc", "filename": "src/test/ui/issues/issue-32122-2.fixed", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/58d955e6cc84b92a6013a3e170e076f65a0c1b18/src%2Ftest%2Fui%2Fissues%2Fissue-32122-2.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/58d955e6cc84b92a6013a3e170e076f65a0c1b18/src%2Ftest%2Fui%2Fissues%2Fissue-32122-2.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-32122-2.fixed?ref=58d955e6cc84b92a6013a3e170e076f65a0c1b18", "patch": "@@ -0,0 +1,28 @@\n+// run-rustfix\n+use std::ops::Deref;\n+struct Bar(u8);\n+struct Foo(Bar);\n+struct Emm(Foo);\n+impl Deref for Bar{\n+    type Target = u8;\n+    fn deref(&self) -> &Self::Target {\n+        &self.0\n+    }\n+}\n+impl Deref for Foo {\n+    type Target = Bar;\n+    fn deref(&self) -> &Self::Target {\n+        &self.0\n+    }\n+}\n+impl Deref for Emm {\n+    type Target = Foo;\n+    fn deref(&self) -> &Self::Target {\n+        &self.0\n+    }\n+}\n+fn main() {\n+    let a = Emm(Foo(Bar(0)));\n+    // Should suggest `&***` even when deref is pretty deep\n+    let _: *const u8 = &***a; //~ ERROR mismatched types\n+}"}, {"sha": "39e9df4224e74a4beb436769e07d00107ef90062", "filename": "src/test/ui/issues/issue-32122-2.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/58d955e6cc84b92a6013a3e170e076f65a0c1b18/src%2Ftest%2Fui%2Fissues%2Fissue-32122-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58d955e6cc84b92a6013a3e170e076f65a0c1b18/src%2Ftest%2Fui%2Fissues%2Fissue-32122-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-32122-2.rs?ref=58d955e6cc84b92a6013a3e170e076f65a0c1b18", "patch": "@@ -0,0 +1,28 @@\n+// run-rustfix\n+use std::ops::Deref;\n+struct Bar(u8);\n+struct Foo(Bar);\n+struct Emm(Foo);\n+impl Deref for Bar{\n+    type Target = u8;\n+    fn deref(&self) -> &Self::Target {\n+        &self.0\n+    }\n+}\n+impl Deref for Foo {\n+    type Target = Bar;\n+    fn deref(&self) -> &Self::Target {\n+        &self.0\n+    }\n+}\n+impl Deref for Emm {\n+    type Target = Foo;\n+    fn deref(&self) -> &Self::Target {\n+        &self.0\n+    }\n+}\n+fn main() {\n+    let a = Emm(Foo(Bar(0)));\n+    // Should suggest `&***` even when deref is pretty deep\n+    let _: *const u8 = &a; //~ ERROR mismatched types\n+}"}, {"sha": "959a49507e4f510006710e42bd038bbf602269ed", "filename": "src/test/ui/issues/issue-32122-2.stderr", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/58d955e6cc84b92a6013a3e170e076f65a0c1b18/src%2Ftest%2Fui%2Fissues%2Fissue-32122-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/58d955e6cc84b92a6013a3e170e076f65a0c1b18/src%2Ftest%2Fui%2Fissues%2Fissue-32122-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-32122-2.stderr?ref=58d955e6cc84b92a6013a3e170e076f65a0c1b18", "patch": "@@ -0,0 +1,16 @@\n+error[E0308]: mismatched types\n+  --> $DIR/issue-32122-2.rs:27:24\n+   |\n+LL |     let _: *const u8 = &a;\n+   |            ---------   ^^\n+   |            |           |\n+   |            |           expected `u8`, found struct `Emm`\n+   |            |           help: consider dereferencing the reference: `&***a`\n+   |            expected due to this\n+   |\n+   = note: expected raw pointer `*const u8`\n+                found reference `&Emm`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0308`."}]}