{"sha": "70f7d5842f29d4900f24420b030f144d21f3c5fc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcwZjdkNTg0MmYyOWQ0OTAwZjI0NDIwYjAzMGYxNDRkMjFmM2M1ZmM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-01-29T10:51:07Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-01-29T10:51:07Z"}, "message": "Auto merge of #47766 - spastorino:inference-dirty-list, r=nikomatsakis\n\nMake region inference use a dirty list\n\nr? @nikomatsakis", "tree": {"sha": "5a1af75480d6e3a189c1a8f5a374842849917fd6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5a1af75480d6e3a189c1a8f5a374842849917fd6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/70f7d5842f29d4900f24420b030f144d21f3c5fc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/70f7d5842f29d4900f24420b030f144d21f3c5fc", "html_url": "https://github.com/rust-lang/rust/commit/70f7d5842f29d4900f24420b030f144d21f3c5fc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/70f7d5842f29d4900f24420b030f144d21f3c5fc/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "679f30e1aac510082b0fd3a2b5465321753aa7d1", "url": "https://api.github.com/repos/rust-lang/rust/commits/679f30e1aac510082b0fd3a2b5465321753aa7d1", "html_url": "https://github.com/rust-lang/rust/commit/679f30e1aac510082b0fd3a2b5465321753aa7d1"}, {"sha": "205eba83e2373c81ed136997a0af004630853e10", "url": "https://api.github.com/repos/rust-lang/rust/commits/205eba83e2373c81ed136997a0af004630853e10", "html_url": "https://github.com/rust-lang/rust/commit/205eba83e2373c81ed136997a0af004630853e10"}], "stats": {"total": 88, "additions": 64, "deletions": 24}, "files": [{"sha": "80cdb0e441790fac9971f6668e3135b25af6b9f6", "filename": "src/librustc_data_structures/bitvec.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/70f7d5842f29d4900f24420b030f144d21f3c5fc/src%2Flibrustc_data_structures%2Fbitvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70f7d5842f29d4900f24420b030f144d21f3c5fc/src%2Flibrustc_data_structures%2Fbitvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fbitvec.rs?ref=70f7d5842f29d4900f24420b030f144d21f3c5fc", "patch": "@@ -51,6 +51,17 @@ impl BitVector {\n         new_value != value\n     }\n \n+    /// Returns true if the bit has changed.\n+    #[inline]\n+    pub fn remove(&mut self, bit: usize) -> bool {\n+        let (word, mask) = word_mask(bit);\n+        let data = &mut self.data[word];\n+        let value = *data;\n+        let new_value = value & !mask;\n+        *data = new_value;\n+        new_value != value\n+    }\n+\n     #[inline]\n     pub fn insert_all(&mut self, all: &BitVector) -> bool {\n         assert!(self.data.len() == all.data.len());"}, {"sha": "9a338947f4772272a21f9dd6f62dd9d2d6401e5f", "filename": "src/librustc_mir/borrow_check/nll/region_infer/mod.rs", "status": "modified", "additions": 53, "deletions": 24, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/70f7d5842f29d4900f24420b030f144d21f3c5fc/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70f7d5842f29d4900f24420b030f144d21f3c5fc/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs?ref=70f7d5842f29d4900f24420b030f144d21f3c5fc", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use std::collections::HashMap;\n+\n use super::universal_regions::UniversalRegions;\n use rustc::hir::def_id::DefId;\n use rustc::infer::InferCtxt;\n@@ -22,6 +24,7 @@ use rustc::mir::{ClosureOutlivesRequirement, ClosureOutlivesSubject, ClosureRegi\n use rustc::traits::ObligationCause;\n use rustc::ty::{self, RegionVid, Ty, TypeFoldable};\n use rustc::util::common::ErrorReported;\n+use rustc_data_structures::bitvec::BitVector;\n use rustc_data_structures::indexed_vec::IndexVec;\n use rustc_errors::DiagnosticBuilder;\n use std::fmt;\n@@ -452,8 +455,6 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// satisfied. Note that some values may grow **too** large to be\n     /// feasible, but we check this later.\n     fn propagate_constraints(&mut self, mir: &Mir<'tcx>) {\n-        let mut changed = true;\n-\n         debug!(\"propagate_constraints()\");\n         debug!(\"propagate_constraints: constraints={:#?}\", {\n             let mut constraints: Vec<_> = self.constraints.iter().collect();\n@@ -465,37 +466,65 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         // constraints we have accumulated.\n         let mut inferred_values = self.liveness_constraints.clone();\n \n-        while changed {\n-            changed = false;\n-            debug!(\"propagate_constraints: --------------------\");\n-            for constraint in &self.constraints {\n-                debug!(\"propagate_constraints: constraint={:?}\", constraint);\n-\n-                // Grow the value as needed to accommodate the\n-                // outlives constraint.\n-                let Ok(made_changes) = self.dfs(\n-                    mir,\n-                    CopyFromSourceToTarget {\n-                        source_region: constraint.sub,\n-                        target_region: constraint.sup,\n-                        inferred_values: &mut inferred_values,\n-                        constraint_point: constraint.point,\n-                        constraint_span: constraint.span,\n-                    },\n-                );\n+        let dependency_map = self.build_dependency_map();\n+\n+        // Constraints that may need to be repropagated (initially all):\n+        let mut dirty_list: Vec<_> = (0..self.constraints.len()).collect();\n+\n+        // Set to 0 for each constraint that is on the dirty list:\n+        let mut clean_bit_vec = BitVector::new(dirty_list.len());\n+\n+        debug!(\"propagate_constraints: --------------------\");\n+        while let Some(constraint_idx) = dirty_list.pop() {\n+            clean_bit_vec.insert(constraint_idx);\n+\n+            let constraint = &self.constraints[constraint_idx];\n+            debug!(\"propagate_constraints: constraint={:?}\", constraint);\n \n-                if made_changes {\n-                    debug!(\"propagate_constraints:   sub={:?}\", constraint.sub);\n-                    debug!(\"propagate_constraints:   sup={:?}\", constraint.sup);\n-                    changed = true;\n+            // Grow the value as needed to accommodate the\n+            // outlives constraint.\n+            let Ok(made_changes) = self.dfs(\n+                mir,\n+                CopyFromSourceToTarget {\n+                    source_region: constraint.sub,\n+                    target_region: constraint.sup,\n+                    inferred_values: &mut inferred_values,\n+                    constraint_point: constraint.point,\n+                    constraint_span: constraint.span,\n+                },\n+            );\n+\n+            if made_changes {\n+                debug!(\"propagate_constraints:   sub={:?}\", constraint.sub);\n+                debug!(\"propagate_constraints:   sup={:?}\", constraint.sup);\n+\n+                for &dep_idx in dependency_map.get(&constraint.sup).unwrap_or(&vec![]) {\n+                    if clean_bit_vec.remove(dep_idx) {\n+                        dirty_list.push(dep_idx);\n+                    }\n                 }\n             }\n+\n             debug!(\"\\n\");\n         }\n \n         self.inferred_values = Some(inferred_values);\n     }\n \n+    /// Builds up a map from each region variable X to a vector with the\n+    /// indices of constraints that need to be re-evaluated when X changes.\n+    /// These are constraints like Y: X @ P -- so if X changed, we may\n+    /// need to grow Y.\n+    fn build_dependency_map(&self) -> HashMap<RegionVid, Vec<usize>> {\n+        let mut map = HashMap::new();\n+\n+        for (idx, constraint) in self.constraints.iter().enumerate() {\n+            map.entry(constraint.sub).or_insert(Vec::new()).push(idx);\n+        }\n+\n+        map\n+    }\n+\n     /// Once regions have been propagated, this method is used to see\n     /// whether the \"type tests\" produced by typeck were satisfied;\n     /// type tests encode type-outlives relationships like `T:"}]}