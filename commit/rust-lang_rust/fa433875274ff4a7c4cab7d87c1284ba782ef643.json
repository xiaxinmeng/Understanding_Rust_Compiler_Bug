{"sha": "fa433875274ff4a7c4cab7d87c1284ba782ef643", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZhNDMzODc1Mjc0ZmY0YTdjNGNhYjdkODdjMTI4NGJhNzgyZWY2NDM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-05-13T06:43:05Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-05-13T06:43:05Z"}, "message": "Auto merge of #24619 - nrc:rc-coerce, r=nikomatsakis\n\nr? @nikomatsakis (note a few TODOs left in the code where I wasn't sure about stuff).", "tree": {"sha": "d8e0dada660d0606983ad1f3efc4761f4b515489", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d8e0dada660d0606983ad1f3efc4761f4b515489"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fa433875274ff4a7c4cab7d87c1284ba782ef643", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fa433875274ff4a7c4cab7d87c1284ba782ef643", "html_url": "https://github.com/rust-lang/rust/commit/fa433875274ff4a7c4cab7d87c1284ba782ef643", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fa433875274ff4a7c4cab7d87c1284ba782ef643/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "30a42faa1c42ce5988241d3af993921246954b1a", "url": "https://api.github.com/repos/rust-lang/rust/commits/30a42faa1c42ce5988241d3af993921246954b1a", "html_url": "https://github.com/rust-lang/rust/commit/30a42faa1c42ce5988241d3af993921246954b1a"}, {"sha": "b799cd83cc797b580be2d1492e6ae014848636ee", "url": "https://api.github.com/repos/rust-lang/rust/commits/b799cd83cc797b580be2d1492e6ae014848636ee", "html_url": "https://github.com/rust-lang/rust/commit/b799cd83cc797b580be2d1492e6ae014848636ee"}], "stats": {"total": 2278, "additions": 1669, "deletions": 609}, "files": [{"sha": "35732dacd44f9aee58808895ae0a47daa42ce199", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fa433875274ff4a7c4cab7d87c1284ba782ef643/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa433875274ff4a7c4cab7d87c1284ba782ef643/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=fa433875274ff4a7c4cab7d87c1284ba782ef643", "patch": "@@ -62,6 +62,11 @@ use core::ops::{Deref, DerefMut};\n use core::ptr::{Unique};\n use core::raw::{TraitObject};\n \n+#[cfg(not(stage0))]\n+use core::marker::Unsize;\n+#[cfg(not(stage0))]\n+use core::ops::CoerceUnsized;\n+\n /// A value that represents the heap. This is the default place that the `box`\n /// keyword allocates into when no place is supplied.\n ///\n@@ -390,3 +395,6 @@ impl<'a,A,R> FnOnce<A> for Box<FnBox<A,Output=R>+Send+'a> {\n         self.call_box(args)\n     }\n }\n+\n+#[cfg(not(stage0))]\n+impl<T: ?Sized+Unsize<U>, U: ?Sized> CoerceUnsized<Box<U>> for Box<T> {}"}, {"sha": "f2b83fdeefa3a8a0f2a8a143acc2886c9aaa3277", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 380, "deletions": 7, "changes": 387, "blob_url": "https://github.com/rust-lang/rust/blob/fa433875274ff4a7c4cab7d87c1284ba782ef643/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa433875274ff4a7c4cab7d87c1284ba782ef643/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=fa433875274ff4a7c4cab7d87c1284ba782ef643", "patch": "@@ -159,7 +159,7 @@ use core::cmp::{PartialEq, PartialOrd, Eq, Ord, Ordering};\n use core::default::Default;\n use core::fmt;\n use core::hash::{Hasher, Hash};\n-use core::marker;\n+use core::marker::{self, Sized};\n use core::mem::{self, min_align_of, size_of, forget};\n use core::nonzero::NonZero;\n use core::ops::{Deref, Drop};\n@@ -170,29 +170,67 @@ use core::result::Result;\n use core::result::Result::{Ok, Err};\n use core::intrinsics::assume;\n \n+#[cfg(not(stage0))]\n+use core::intrinsics::drop_in_place;\n+#[cfg(not(stage0))]\n+use core::marker::Unsize;\n+#[cfg(not(stage0))]\n+use core::mem::{min_align_of_val, size_of_val};\n+#[cfg(not(stage0))]\n+use core::ops::CoerceUnsized;\n+\n use heap::deallocate;\n \n+#[cfg(stage0)]\n struct RcBox<T> {\n+    strong: Cell<usize>,\n+    weak: Cell<usize>,\n     value: T,\n+}\n+\n+#[cfg(not(stage0))]\n+struct RcBox<T: ?Sized> {\n     strong: Cell<usize>,\n-    weak: Cell<usize>\n+    weak: Cell<usize>,\n+    value: T,\n }\n \n+\n /// A reference-counted pointer type over an immutable value.\n ///\n /// See the [module level documentation](./index.html) for more details.\n+#[cfg(stage0)]\n #[unsafe_no_drop_flag]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Rc<T> {\n     // FIXME #12808: strange names to try to avoid interfering with field\n     // accesses of the contained type via Deref\n     _ptr: NonZero<*mut RcBox<T>>,\n }\n+#[cfg(not(stage0))]\n+#[unsafe_no_drop_flag]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct Rc<T: ?Sized> {\n+    // FIXME #12808: strange names to try to avoid interfering with field\n+    // accesses of the contained type via Deref\n+    _ptr: NonZero<*mut RcBox<T>>,\n+}\n \n+#[cfg(stage0)]\n impl<T> !marker::Send for Rc<T> {}\n \n+#[cfg(not(stage0))]\n+impl<T: ?Sized> !marker::Send for Rc<T> {}\n+\n+#[cfg(stage0)]\n impl<T> !marker::Sync for Rc<T> {}\n \n+#[cfg(not(stage0))]\n+impl<T: ?Sized> !marker::Sync for Rc<T> {}\n+\n+#[cfg(not(stage0))]\n+impl<T: ?Sized+Unsize<U>, U: ?Sized> CoerceUnsized<Rc<U>> for Rc<T> {}\n+\n impl<T> Rc<T> {\n     /// Constructs a new `Rc<T>`.\n     ///\n@@ -212,14 +250,39 @@ impl<T> Rc<T> {\n                 // the allocation while the strong destructor is running, even\n                 // if the weak pointer is stored inside the strong one.\n                 _ptr: NonZero::new(boxed::into_raw(box RcBox {\n-                    value: value,\n                     strong: Cell::new(1),\n-                    weak: Cell::new(1)\n+                    weak: Cell::new(1),\n+                    value: value\n                 })),\n             }\n         }\n     }\n+}\n \n+#[cfg(not(stage0))]\n+impl<T: ?Sized> Rc<T> {\n+    /// Downgrades the `Rc<T>` to a `Weak<T>` reference.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// # #![feature(alloc)]\n+    /// use std::rc::Rc;\n+    ///\n+    /// let five = Rc::new(5);\n+    ///\n+    /// let weak_five = five.downgrade();\n+    /// ```\n+    #[unstable(feature = \"alloc\",\n+               reason = \"Weak pointers may not belong in this module\")]\n+    pub fn downgrade(&self) -> Weak<T> {\n+        self.inc_weak();\n+        Weak { _ptr: self._ptr }\n+    }\n+}\n+\n+#[cfg(stage0)]\n+impl<T> Rc<T> {\n     /// Downgrades the `Rc<T>` to a `Weak<T>` reference.\n     ///\n     /// # Examples\n@@ -241,14 +304,24 @@ impl<T> Rc<T> {\n }\n \n /// Get the number of weak references to this value.\n+#[cfg(stage0)]\n #[inline]\n #[unstable(feature = \"alloc\")]\n pub fn weak_count<T>(this: &Rc<T>) -> usize { this.weak() - 1 }\n+#[cfg(not(stage0))]\n+#[inline]\n+#[unstable(feature = \"alloc\")]\n+pub fn weak_count<T: ?Sized>(this: &Rc<T>) -> usize { this.weak() - 1 }\n \n /// Get the number of strong references to this value.\n+#[cfg(stage0)]\n #[inline]\n #[unstable(feature = \"alloc\")]\n pub fn strong_count<T>(this: &Rc<T>) -> usize { this.strong() }\n+#[cfg(not(stage0))]\n+#[inline]\n+#[unstable(feature = \"alloc\")]\n+pub fn strong_count<T: ?Sized>(this: &Rc<T>) -> usize { this.strong() }\n \n /// Returns true if there are no other `Rc` or `Weak<T>` values that share the\n /// same inner value.\n@@ -365,6 +438,7 @@ impl<T: Clone> Rc<T> {\n     }\n }\n \n+#[cfg(stage0)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Deref for Rc<T> {\n     type Target = T;\n@@ -374,7 +448,18 @@ impl<T> Deref for Rc<T> {\n         &self.inner().value\n     }\n }\n+#[cfg(not(stage0))]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T: ?Sized> Deref for Rc<T> {\n+    type Target = T;\n+\n+    #[inline(always)]\n+    fn deref(&self) -> &T {\n+        &self.inner().value\n+    }\n+}\n \n+#[cfg(stage0)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Drop for Rc<T> {\n     /// Drops the `Rc<T>`.\n@@ -425,6 +510,61 @@ impl<T> Drop for Rc<T> {\n     }\n }\n \n+#[cfg(not(stage0))]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T: ?Sized> Drop for Rc<T> {\n+    /// Drops the `Rc<T>`.\n+    ///\n+    /// This will decrement the strong reference count. If the strong reference\n+    /// count becomes zero and the only other references are `Weak<T>` ones,\n+    /// `drop`s the inner value.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// # #![feature(alloc)]\n+    /// use std::rc::Rc;\n+    ///\n+    /// {\n+    ///     let five = Rc::new(5);\n+    ///\n+    ///     // stuff\n+    ///\n+    ///     drop(five); // explicit drop\n+    /// }\n+    /// {\n+    ///     let five = Rc::new(5);\n+    ///\n+    ///     // stuff\n+    ///\n+    /// } // implicit drop\n+    /// ```\n+    fn drop(&mut self) {\n+        unsafe {\n+            let ptr = *self._ptr;\n+            if !(*(&ptr as *const _ as *const *const ())).is_null() &&\n+               ptr as usize != mem::POST_DROP_USIZE {\n+                self.dec_strong();\n+                if self.strong() == 0 {\n+                    // destroy the contained object\n+                    drop_in_place(&mut (*ptr).value);\n+\n+                    // remove the implicit \"strong weak\" pointer now that we've\n+                    // destroyed the contents.\n+                    self.dec_weak();\n+\n+                    if self.weak() == 0 {\n+                        deallocate(ptr as *mut u8,\n+                                   size_of_val(&*ptr),\n+                                   min_align_of_val(&*ptr))\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+#[cfg(stage0)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Clone for Rc<T> {\n \n@@ -449,6 +589,31 @@ impl<T> Clone for Rc<T> {\n         Rc { _ptr: self._ptr }\n     }\n }\n+#[cfg(not(stage0))]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T: ?Sized> Clone for Rc<T> {\n+\n+    /// Makes a clone of the `Rc<T>`.\n+    ///\n+    /// When you clone an `Rc<T>`, it will create another pointer to the data and\n+    /// increase the strong reference counter.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// # #![feature(alloc)]\n+    /// use std::rc::Rc;\n+    ///\n+    /// let five = Rc::new(5);\n+    ///\n+    /// five.clone();\n+    /// ```\n+    #[inline]\n+    fn clone(&self) -> Rc<T> {\n+        self.inc_strong();\n+        Rc { _ptr: self._ptr }\n+    }\n+}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Default> Default for Rc<T> {\n@@ -610,27 +775,50 @@ impl<T: Ord> Ord for Rc<T> {\n     fn cmp(&self, other: &Rc<T>) -> Ordering { (**self).cmp(&**other) }\n }\n \n-// FIXME (#18248) Make `T` `Sized?`\n+#[cfg(stage0)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Hash> Hash for Rc<T> {\n     fn hash<H: Hasher>(&self, state: &mut H) {\n         (**self).hash(state);\n     }\n }\n+#[cfg(not(stage0))]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T: ?Sized+Hash> Hash for Rc<T> {\n+    fn hash<H: Hasher>(&self, state: &mut H) {\n+        (**self).hash(state);\n+    }\n+}\n \n+#[cfg(stage0)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: fmt::Display> fmt::Display for Rc<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         fmt::Display::fmt(&**self, f)\n     }\n }\n+#[cfg(not(stage0))]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T: ?Sized+fmt::Display> fmt::Display for Rc<T> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::Display::fmt(&**self, f)\n+    }\n+}\n \n+#[cfg(stage0)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: fmt::Debug> fmt::Debug for Rc<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         fmt::Debug::fmt(&**self, f)\n     }\n }\n+#[cfg(not(stage0))]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T: ?Sized+fmt::Debug> fmt::Debug for Rc<T> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::Debug::fmt(&**self, f)\n+    }\n+}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> fmt::Pointer for Rc<T> {\n@@ -645,6 +833,7 @@ impl<T> fmt::Pointer for Rc<T> {\n /// dropped.\n ///\n /// See the [module level documentation](./index.html) for more.\n+#[cfg(stage0)]\n #[unsafe_no_drop_flag]\n #[unstable(feature = \"alloc\",\n            reason = \"Weak pointers may not belong in this module.\")]\n@@ -653,12 +842,28 @@ pub struct Weak<T> {\n     // field accesses of the contained type via Deref\n     _ptr: NonZero<*mut RcBox<T>>,\n }\n+#[cfg(not(stage0))]\n+#[unsafe_no_drop_flag]\n+#[unstable(feature = \"alloc\",\n+           reason = \"Weak pointers may not belong in this module.\")]\n+pub struct Weak<T: ?Sized> {\n+    // FIXME #12808: strange names to try to avoid interfering with\n+    // field accesses of the contained type via Deref\n+    _ptr: NonZero<*mut RcBox<T>>,\n+}\n \n+#[cfg(stage0)]\n impl<T> !marker::Send for Weak<T> {}\n+#[cfg(not(stage0))]\n+impl<T: ?Sized> !marker::Send for Weak<T> {}\n \n+#[cfg(stage0)]\n impl<T> !marker::Sync for Weak<T> {}\n+#[cfg(not(stage0))]\n+impl<T: ?Sized> !marker::Sync for Weak<T> {}\n \n \n+#[cfg(stage0)]\n #[unstable(feature = \"alloc\",\n            reason = \"Weak pointers may not belong in this module.\")]\n impl<T> Weak<T> {\n@@ -691,7 +896,41 @@ impl<T> Weak<T> {\n         }\n     }\n }\n+#[cfg(not(stage0))]\n+#[unstable(feature = \"alloc\",\n+           reason = \"Weak pointers may not belong in this module.\")]\n+impl<T: ?Sized> Weak<T> {\n \n+    /// Upgrades a weak reference to a strong reference.\n+    ///\n+    /// Upgrades the `Weak<T>` reference to an `Rc<T>`, if possible.\n+    ///\n+    /// Returns `None` if there were no strong references and the data was\n+    /// destroyed.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// # #![feature(alloc)]\n+    /// use std::rc::Rc;\n+    ///\n+    /// let five = Rc::new(5);\n+    ///\n+    /// let weak_five = five.downgrade();\n+    ///\n+    /// let strong_five: Option<Rc<_>> = weak_five.upgrade();\n+    /// ```\n+    pub fn upgrade(&self) -> Option<Rc<T>> {\n+        if self.strong() == 0 {\n+            None\n+        } else {\n+            self.inc_strong();\n+            Some(Rc { _ptr: self._ptr })\n+        }\n+    }\n+}\n+\n+#[cfg(stage0)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Drop for Weak<T> {\n     /// Drops the `Weak<T>`.\n@@ -736,6 +975,53 @@ impl<T> Drop for Weak<T> {\n     }\n }\n \n+#[cfg(not(stage0))]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T: ?Sized> Drop for Weak<T> {\n+    /// Drops the `Weak<T>`.\n+    ///\n+    /// This will decrement the weak reference count.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// # #![feature(alloc)]\n+    /// use std::rc::Rc;\n+    ///\n+    /// {\n+    ///     let five = Rc::new(5);\n+    ///     let weak_five = five.downgrade();\n+    ///\n+    ///     // stuff\n+    ///\n+    ///     drop(weak_five); // explicit drop\n+    /// }\n+    /// {\n+    ///     let five = Rc::new(5);\n+    ///     let weak_five = five.downgrade();\n+    ///\n+    ///     // stuff\n+    ///\n+    /// } // implicit drop\n+    /// ```\n+    fn drop(&mut self) {\n+        unsafe {\n+            let ptr = *self._ptr;\n+            if !(*(&ptr as *const _ as *const *const ())).is_null() &&\n+               ptr as usize != mem::POST_DROP_USIZE {\n+                self.dec_weak();\n+                // the weak count starts at 1, and will only go to zero if all\n+                // the strong pointers have disappeared.\n+                if self.weak() == 0 {\n+                    deallocate(ptr as *mut u8, size_of_val(&*ptr),\n+                               min_align_of_val(&*ptr))\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+#[cfg(stage0)]\n #[unstable(feature = \"alloc\",\n            reason = \"Weak pointers may not belong in this module.\")]\n impl<T> Clone for Weak<T> {\n@@ -760,14 +1046,48 @@ impl<T> Clone for Weak<T> {\n         Weak { _ptr: self._ptr }\n     }\n }\n+#[cfg(not(stage0))]\n+#[unstable(feature = \"alloc\",\n+           reason = \"Weak pointers may not belong in this module.\")]\n+impl<T: ?Sized> Clone for Weak<T> {\n+\n+    /// Makes a clone of the `Weak<T>`.\n+    ///\n+    /// This increases the weak reference count.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// # #![feature(alloc)]\n+    /// use std::rc::Rc;\n+    ///\n+    /// let weak_five = Rc::new(5).downgrade();\n+    ///\n+    /// weak_five.clone();\n+    /// ```\n+    #[inline]\n+    fn clone(&self) -> Weak<T> {\n+        self.inc_weak();\n+        Weak { _ptr: self._ptr }\n+    }\n+}\n \n+#[cfg(stage0)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: fmt::Debug> fmt::Debug for Weak<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"(Weak)\")\n     }\n }\n+#[cfg(not(stage0))]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T: ?Sized+fmt::Debug> fmt::Debug for Weak<T> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"(Weak)\")\n+    }\n+}\n \n+#[cfg(stage0)]\n #[doc(hidden)]\n trait RcBoxPtr<T> {\n     fn inner(&self) -> &RcBox<T>;\n@@ -790,7 +1110,31 @@ trait RcBoxPtr<T> {\n     #[inline]\n     fn dec_weak(&self) { self.inner().weak.set(self.weak() - 1); }\n }\n+#[cfg(not(stage0))]\n+#[doc(hidden)]\n+trait RcBoxPtr<T: ?Sized> {\n+    fn inner(&self) -> &RcBox<T>;\n+\n+    #[inline]\n+    fn strong(&self) -> usize { self.inner().strong.get() }\n+\n+    #[inline]\n+    fn inc_strong(&self) { self.inner().strong.set(self.strong() + 1); }\n+\n+    #[inline]\n+    fn dec_strong(&self) { self.inner().strong.set(self.strong() - 1); }\n+\n+    #[inline]\n+    fn weak(&self) -> usize { self.inner().weak.get() }\n+\n+    #[inline]\n+    fn inc_weak(&self) { self.inner().weak.set(self.weak() + 1); }\n+\n+    #[inline]\n+    fn dec_weak(&self) { self.inner().weak.set(self.weak() - 1); }\n+}\n \n+#[cfg(stage0)]\n impl<T> RcBoxPtr<T> for Rc<T> {\n     #[inline(always)]\n     fn inner(&self) -> &RcBox<T> {\n@@ -799,12 +1143,27 @@ impl<T> RcBoxPtr<T> for Rc<T> {\n             // the contract anyway.\n             // This allows the null check to be elided in the destructor if we\n             // manipulated the reference count in the same function.\n-            assume(!self._ptr.is_null());\n+            assume(!(*(&self._ptr as *const _ as *const *const ())).is_null());\n+            &(**self._ptr)\n+        }\n+    }\n+}\n+#[cfg(not(stage0))]\n+impl<T: ?Sized> RcBoxPtr<T> for Rc<T> {\n+    #[inline(always)]\n+    fn inner(&self) -> &RcBox<T> {\n+        unsafe {\n+            // Safe to assume this here, as if it weren't true, we'd be breaking\n+            // the contract anyway.\n+            // This allows the null check to be elided in the destructor if we\n+            // manipulated the reference count in the same function.\n+            assume(!(*(&self._ptr as *const _ as *const *const ())).is_null());\n             &(**self._ptr)\n         }\n     }\n }\n \n+#[cfg(stage0)]\n impl<T> RcBoxPtr<T> for Weak<T> {\n     #[inline(always)]\n     fn inner(&self) -> &RcBox<T> {\n@@ -813,7 +1172,21 @@ impl<T> RcBoxPtr<T> for Weak<T> {\n             // the contract anyway.\n             // This allows the null check to be elided in the destructor if we\n             // manipulated the reference count in the same function.\n-            assume(!self._ptr.is_null());\n+            assume(!(*(&self._ptr as *const _ as *const *const ())).is_null());\n+            &(**self._ptr)\n+        }\n+    }\n+}\n+#[cfg(not(stage0))]\n+impl<T: ?Sized> RcBoxPtr<T> for Weak<T> {\n+    #[inline(always)]\n+    fn inner(&self) -> &RcBox<T> {\n+        unsafe {\n+            // Safe to assume this here, as if it weren't true, we'd be breaking\n+            // the contract anyway.\n+            // This allows the null check to be elided in the destructor if we\n+            // manipulated the reference count in the same function.\n+            assume(!(*(&self._ptr as *const _ as *const *const ())).is_null());\n             &(**self._ptr)\n         }\n     }"}, {"sha": "45a8012210417842edf6adb231defb94ebcb4410", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fa433875274ff4a7c4cab7d87c1284ba782ef643/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa433875274ff4a7c4cab7d87c1284ba782ef643/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=fa433875274ff4a7c4cab7d87c1284ba782ef643", "patch": "@@ -707,5 +707,4 @@ impl<T: ?Sized> UnsafeCell<T> {\n         #![allow(trivial_casts)]\n         &self.value as *const T as *mut T\n     }\n-\n }"}, {"sha": "d94b8884112d66e35a113aeec90d5c619844edcc", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fa433875274ff4a7c4cab7d87c1284ba782ef643/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa433875274ff4a7c4cab7d87c1284ba782ef643/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=fa433875274ff4a7c4cab7d87c1284ba782ef643", "patch": "@@ -193,6 +193,13 @@ extern \"rust-intrinsic\" {\n     pub fn min_align_of<T>() -> usize;\n     pub fn pref_align_of<T>() -> usize;\n \n+    #[cfg(not(stage0))]\n+    pub fn size_of_val<T: ?Sized>(_: &T) -> usize;\n+    #[cfg(not(stage0))]\n+    pub fn min_align_of_val<T: ?Sized>(_: &T) -> usize;\n+    #[cfg(not(stage0))]\n+    pub fn drop_in_place<T: ?Sized>(_: *mut T);\n+\n     /// Gets a static string slice containing the name of a type.\n     pub fn type_name<T: ?Sized>() -> &'static str;\n "}, {"sha": "5909c5cc30e510dce250e58a7a01f0fa2d965ab4", "filename": "src/libcore/marker.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fa433875274ff4a7c4cab7d87c1284ba782ef643/src%2Flibcore%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa433875274ff4a7c4cab7d87c1284ba782ef643/src%2Flibcore%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmarker.rs?ref=fa433875274ff4a7c4cab7d87c1284ba782ef643", "patch": "@@ -53,6 +53,14 @@ pub trait Sized {\n     // Empty.\n }\n \n+/// Types that can be \"unsized\" to a dynamically sized type.\n+#[unstable(feature = \"core\")]\n+#[cfg(not(stage0))]\n+#[lang=\"unsize\"]\n+pub trait Unsize<T> {\n+    // Empty.\n+}\n+\n /// Types that can be copied by simply copying bits (i.e. `memcpy`).\n ///\n /// By default, variable bindings have 'move semantics.' In other"}, {"sha": "173b73fdb0924366c269f8d2b31df974f44d9b5c", "filename": "src/libcore/mem.rs", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/fa433875274ff4a7c4cab7d87c1284ba782ef643/src%2Flibcore%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa433875274ff4a7c4cab7d87c1284ba782ef643/src%2Flibcore%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem.rs?ref=fa433875274ff4a7c4cab7d87c1284ba782ef643", "patch": "@@ -86,6 +86,22 @@ pub fn size_of<T>() -> usize {\n     unsafe { intrinsics::size_of::<T>() }\n }\n \n+/// Returns the size of the type that `val` points to in bytes.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use std::mem;\n+///\n+/// assert_eq!(4, mem::size_of_val(&5i32));\n+/// ```\n+#[cfg(not(stage0))]\n+#[inline]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub fn size_of_val<T: ?Sized>(val: &T) -> usize {\n+    unsafe { intrinsics::size_of_val(val) }\n+}\n+\n /// Returns the size of the type that `_val` points to in bytes.\n ///\n /// # Examples\n@@ -95,6 +111,7 @@ pub fn size_of<T>() -> usize {\n ///\n /// assert_eq!(4, mem::size_of_val(&5i32));\n /// ```\n+#[cfg(stage0)]\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn size_of_val<T>(_val: &T) -> usize {\n@@ -118,6 +135,22 @@ pub fn min_align_of<T>() -> usize {\n     unsafe { intrinsics::min_align_of::<T>() }\n }\n \n+/// Returns the ABI-required minimum alignment of the type of the value that `val` points to\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use std::mem;\n+///\n+/// assert_eq!(4, mem::min_align_of_val(&5i32));\n+/// ```\n+#[cfg(not(stage0))]\n+#[inline]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub fn min_align_of_val<T: ?Sized>(val: &T) -> usize {\n+    unsafe { intrinsics::min_align_of_val(val) }\n+}\n+\n /// Returns the ABI-required minimum alignment of the type of the value that `_val` points to\n ///\n /// # Examples\n@@ -127,6 +160,7 @@ pub fn min_align_of<T>() -> usize {\n ///\n /// assert_eq!(4, mem::min_align_of_val(&5i32));\n /// ```\n+#[cfg(stage0)]\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn min_align_of_val<T>(_val: &T) -> usize {"}, {"sha": "59819fd500d1d25235ae95a1306c9a8504f60132", "filename": "src/libcore/nonzero.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fa433875274ff4a7c4cab7d87c1284ba782ef643/src%2Flibcore%2Fnonzero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa433875274ff4a7c4cab7d87c1284ba782ef643/src%2Flibcore%2Fnonzero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnonzero.rs?ref=fa433875274ff4a7c4cab7d87c1284ba782ef643", "patch": "@@ -12,6 +12,8 @@\n \n use marker::Sized;\n use ops::Deref;\n+#[cfg(not(stage0))]\n+use ops::CoerceUnsized;\n \n /// Unsafe trait to indicate what types are usable with the NonZero struct\n pub unsafe trait Zeroable {}\n@@ -54,3 +56,6 @@ impl<T: Zeroable> Deref for NonZero<T> {\n         inner\n     }\n }\n+\n+#[cfg(not(stage0))]\n+impl<T: Zeroable+CoerceUnsized<U>, U: Zeroable> CoerceUnsized<NonZero<U>> for NonZero<T> {}"}, {"sha": "f16614cfd092d41df7269fc7f6a6cbcaf4a7ab26", "filename": "src/libcore/ops.rs", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/fa433875274ff4a7c4cab7d87c1284ba782ef643/src%2Flibcore%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa433875274ff4a7c4cab7d87c1284ba782ef643/src%2Flibcore%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops.rs?ref=fa433875274ff4a7c4cab7d87c1284ba782ef643", "patch": "@@ -70,6 +70,9 @@\n use marker::Sized;\n use fmt;\n \n+#[cfg(not(stage0))]\n+use marker::Unsize;\n+\n /// The `Drop` trait is used to run some code when a value goes out of scope. This\n /// is sometimes called a 'destructor'.\n ///\n@@ -1207,3 +1210,43 @@ mod impls {\n         }\n     }\n }\n+\n+/// Trait that indicates that this is a pointer or a wrapper for one,\n+/// where unsizing can be performed on the pointee.\n+#[unstable(feature = \"core\")]\n+#[cfg(not(stage0))]\n+#[lang=\"coerce_unsized\"]\n+pub trait CoerceUnsized<T> {\n+    // Empty.\n+}\n+\n+// &mut T -> &mut U\n+#[cfg(not(stage0))]\n+impl<'a, T: ?Sized+Unsize<U>, U: ?Sized> CoerceUnsized<&'a mut U> for &'a mut T {}\n+// &mut T -> &U\n+#[cfg(not(stage0))]\n+impl<'a, 'b: 'a, T: ?Sized+Unsize<U>, U: ?Sized> CoerceUnsized<&'a U> for &'b mut T {}\n+// &mut T -> *mut U\n+#[cfg(not(stage0))]\n+impl<'a, T: ?Sized+Unsize<U>, U: ?Sized> CoerceUnsized<*mut U> for &'a mut T {}\n+// &mut T -> *const U\n+#[cfg(not(stage0))]\n+impl<'a, T: ?Sized+Unsize<U>, U: ?Sized> CoerceUnsized<*const U> for &'a mut T {}\n+\n+// &T -> &U\n+#[cfg(not(stage0))]\n+impl<'a, 'b: 'a, T: ?Sized+Unsize<U>, U: ?Sized> CoerceUnsized<&'a U> for &'b T {}\n+// &T -> *const U\n+#[cfg(not(stage0))]\n+impl<'a, T: ?Sized+Unsize<U>, U: ?Sized> CoerceUnsized<*const U> for &'a T {}\n+\n+// *mut T -> *mut U\n+#[cfg(not(stage0))]\n+impl<T: ?Sized+Unsize<U>, U: ?Sized> CoerceUnsized<*mut U> for *mut T {}\n+// *mut T -> *const U\n+#[cfg(not(stage0))]\n+impl<T: ?Sized+Unsize<U>, U: ?Sized> CoerceUnsized<*const U> for *mut T {}\n+\n+// *const T -> *const U\n+#[cfg(not(stage0))]\n+impl<T: ?Sized+Unsize<U>, U: ?Sized> CoerceUnsized<*const U> for *const T {}"}, {"sha": "f02312b8641e118f7ec3d7b20cb228067732690c", "filename": "src/libcoretest/cell.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/fa433875274ff4a7c4cab7d87c1284ba782ef643/src%2Flibcoretest%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa433875274ff4a7c4cab7d87c1284ba782ef643/src%2Flibcoretest%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fcell.rs?ref=fa433875274ff4a7c4cab7d87c1284ba782ef643", "patch": "@@ -172,14 +172,15 @@ fn unsafe_cell_unsized() {\n     assert_eq!(unsafe { &mut *cell.get() }, comp);\n }\n \n-#[test]\n-fn refcell_unsized() {\n-    let cell: &RefCell<[i32]> = &RefCell::new([1, 2, 3]);\n-    {\n-        let b = &mut *cell.borrow_mut();\n-        b[0] = 4;\n-        b[2] = 5;\n-    }\n-    let comp: &mut [i32] = &mut [4, 2, 5];\n-    assert_eq!(&*cell.borrow(), comp);\n-}\n+// FIXME(#25351) needs deeply nested coercions of DST structs.\n+// #[test]\n+// fn refcell_unsized() {\n+//     let cell: &RefCell<[i32]> = &RefCell::new([1, 2, 3]);\n+//     {\n+//         let b = &mut *cell.borrow_mut();\n+//         b[0] = 4;\n+//         b[2] = 5;\n+//     }\n+//     let comp: &mut [i32] = &mut [4, 2, 5];\n+//     assert_eq!(&*cell.borrow(), comp);\n+// }"}, {"sha": "bb50d5110cb60c4b0ff8e976a89b6e693fa0279e", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fa433875274ff4a7c4cab7d87c1284ba782ef643/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa433875274ff4a7c4cab7d87c1284ba782ef643/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=fa433875274ff4a7c4cab7d87c1284ba782ef643", "patch": "@@ -807,6 +807,7 @@ register_diagnostics! {\n     E0017,\n     E0019,\n     E0022,\n+    E0038,\n     E0109,\n     E0110,\n     E0134,"}, {"sha": "f410626714f4805752e5579368e504a90ece5d4b", "filename": "src/librustc/metadata/common.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa433875274ff4a7c4cab7d87c1284ba782ef643/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa433875274ff4a7c4cab7d87c1284ba782ef643/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcommon.rs?ref=fa433875274ff4a7c4cab7d87c1284ba782ef643", "patch": "@@ -259,3 +259,5 @@ pub const tag_codemap_filemap: usize = 0xa2;\n pub const tag_item_super_predicates: usize = 0xa3;\n \n pub const tag_defaulted_trait: usize = 0xa4;\n+\n+pub const tag_impl_coerce_unsized_kind: usize = 0xa5;"}, {"sha": "8a35c0120049024a49f105571b21c78d8026948d", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fa433875274ff4a7c4cab7d87c1284ba782ef643/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa433875274ff4a7c4cab7d87c1284ba782ef643/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=fa433875274ff4a7c4cab7d87c1284ba782ef643", "patch": "@@ -279,6 +279,14 @@ pub fn get_impl_polarity<'tcx>(tcx: &ty::ctxt<'tcx>,\n     decoder::get_impl_polarity(&*cdata, def.node)\n }\n \n+pub fn get_custom_coerce_unsized_kind<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                                            def: ast::DefId)\n+                                            -> Option<ty::CustomCoerceUnsized> {\n+    let cstore = &tcx.sess.cstore;\n+    let cdata = cstore.get_crate_data(def.krate);\n+    decoder::get_custom_coerce_unsized_kind(&*cdata, def.node)\n+}\n+\n // Given a def_id for an impl, return the trait it implements,\n // if there is one.\n pub fn get_impl_trait<'tcx>(tcx: &ty::ctxt<'tcx>,"}, {"sha": "2f2a5d31c9f77aaf25087c681d255061bbd3acbf", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fa433875274ff4a7c4cab7d87c1284ba782ef643/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa433875274ff4a7c4cab7d87c1284ba782ef643/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=fa433875274ff4a7c4cab7d87c1284ba782ef643", "patch": "@@ -489,6 +489,16 @@ pub fn get_impl_polarity<'tcx>(cdata: Cmd,\n     }\n }\n \n+pub fn get_custom_coerce_unsized_kind<'tcx>(cdata: Cmd,\n+                                            id: ast::NodeId)\n+                                            -> Option<ty::CustomCoerceUnsized> {\n+    let item_doc = lookup_item(id, cdata.data());\n+    reader::maybe_get_doc(item_doc, tag_impl_coerce_unsized_kind).map(|kind_doc| {\n+        let mut decoder = reader::Decoder::new(kind_doc);\n+        Decodable::decode(&mut decoder).unwrap()\n+    })\n+}\n+\n pub fn get_impl_trait<'tcx>(cdata: Cmd,\n                             id: ast::NodeId,\n                             tcx: &ty::ctxt<'tcx>)"}, {"sha": "86f33257e09036101239e8f0920348268612043c", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fa433875274ff4a7c4cab7d87c1284ba782ef643/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa433875274ff4a7c4cab7d87c1284ba782ef643/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=fa433875274ff4a7c4cab7d87c1284ba782ef643", "patch": "@@ -1219,6 +1219,16 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_attributes(rbml_w, &item.attrs);\n         encode_unsafety(rbml_w, unsafety);\n         encode_polarity(rbml_w, polarity);\n+\n+        match tcx.custom_coerce_unsized_kinds.borrow().get(&local_def(item.id)) {\n+            Some(&kind) => {\n+                rbml_w.start_tag(tag_impl_coerce_unsized_kind);\n+                kind.encode(rbml_w);\n+                rbml_w.end_tag();\n+            }\n+            None => {}\n+        }\n+\n         match ty.node {\n             ast::TyPath(None, ref path) if path.segments.len() == 1 => {\n                 let name = path.segments.last().unwrap().identifier.name;"}, {"sha": "7366ad9453498df06de1420ce02609040bcb3fb2", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fa433875274ff4a7c4cab7d87c1284ba782ef643/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa433875274ff4a7c4cab7d87c1284ba782ef643/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=fa433875274ff4a7c4cab7d87c1284ba782ef643", "patch": "@@ -890,10 +890,6 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n             }\n         };\n \n-        debug!(\"walk_autoref: expr.id={} cmt_base={}\",\n-               expr.id,\n-               cmt_base.repr(self.tcx()));\n-\n         match *autoref {\n             ty::AutoPtr(r, m) => {\n                 self.delegate.borrow(expr.id,"}, {"sha": "273cd6b4f85b4b29dee9d68e38bf08dc166a6527", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fa433875274ff4a7c4cab7d87c1284ba782ef643/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa433875274ff4a7c4cab7d87c1284ba782ef643/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=fa433875274ff4a7c4cab7d87c1284ba782ef643", "patch": "@@ -261,11 +261,14 @@ lets_do_this! {\n \n     SendTraitLangItem,               \"send\",                    send_trait;\n     SizedTraitLangItem,              \"sized\",                   sized_trait;\n+    UnsizeTraitLangItem,             \"unsize\",                  unsize_trait;\n     CopyTraitLangItem,               \"copy\",                    copy_trait;\n     SyncTraitLangItem,               \"sync\",                    sync_trait;\n \n     DropTraitLangItem,               \"drop\",                    drop_trait;\n \n+    CoerceUnsizedTraitLangItem,      \"coerce_unsized\",          coerce_unsized_trait;\n+\n     AddTraitLangItem,                \"add\",                     add_trait;\n     SubTraitLangItem,                \"sub\",                     sub_trait;\n     MulTraitLangItem,                \"mul\",                     mul_trait;"}, {"sha": "2b82987480d6ea70ad5dbc3ef7fac4153a22000e", "filename": "src/librustc/middle/traits/error_reporting.rs", "status": "modified", "additions": 52, "deletions": 4, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/fa433875274ff4a7c4cab7d87c1284ba782ef643/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa433875274ff4a7c4cab7d87c1284ba782ef643/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs?ref=fa433875274ff4a7c4cab7d87c1284ba782ef643", "patch": "@@ -15,8 +15,12 @@ use super::{\n     Obligation,\n     ObligationCauseCode,\n     OutputTypeParameterMismatch,\n+    TraitNotObjectSafe,\n     PredicateObligation,\n     SelectionError,\n+    ObjectSafetyViolation,\n+    MethodViolationCode,\n+    object_safety_violations,\n };\n \n use fmt_macros::{Parser, Piece, Position};\n@@ -252,6 +256,54 @@ pub fn report_selection_error<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n                     note_obligation_cause(infcx, obligation);\n             }\n         }\n+\n+        TraitNotObjectSafe(did) => {\n+            span_err!(infcx.tcx.sess, obligation.cause.span, E0038,\n+                \"cannot convert to a trait object because trait `{}` is not object-safe\",\n+                ty::item_path_str(infcx.tcx, did));\n+\n+            for violation in object_safety_violations(infcx.tcx, did) {\n+                match violation {\n+                    ObjectSafetyViolation::SizedSelf => {\n+                        infcx.tcx.sess.span_note(\n+                            obligation.cause.span,\n+                            \"the trait cannot require that `Self : Sized`\");\n+                    }\n+\n+                    ObjectSafetyViolation::SupertraitSelf => {\n+                        infcx.tcx.sess.span_note(\n+                            obligation.cause.span,\n+                            \"the trait cannot use `Self` as a type parameter \\\n+                            in the supertrait listing\");\n+                    }\n+\n+                    ObjectSafetyViolation::Method(method,\n+                            MethodViolationCode::StaticMethod) => {\n+                        infcx.tcx.sess.span_note(\n+                            obligation.cause.span,\n+                            &format!(\"method `{}` has no receiver\",\n+                                    method.name.user_string(infcx.tcx)));\n+                    }\n+\n+                    ObjectSafetyViolation::Method(method,\n+                            MethodViolationCode::ReferencesSelf) => {\n+                        infcx.tcx.sess.span_note(\n+                            obligation.cause.span,\n+                            &format!(\"method `{}` references the `Self` type \\\n+                                    in its arguments or return type\",\n+                                    method.name.user_string(infcx.tcx)));\n+                    }\n+\n+                    ObjectSafetyViolation::Method(method,\n+                            MethodViolationCode::Generic) => {\n+                        infcx.tcx.sess.span_note(\n+                            obligation.cause.span,\n+                            &format!(\"method `{}` has generic type parameters\",\n+                                    method.name.user_string(infcx.tcx)));\n+                    }\n+                }\n+            }\n+        }\n     }\n }\n \n@@ -403,10 +455,6 @@ fn note_obligation_cause_code<'a, 'tcx, T>(infcx: &InferCtxt<'a, 'tcx>,\n                        \"only the last field of a struct or enum variant \\\n                        may have a dynamically sized type\")\n         }\n-        ObligationCauseCode::ObjectSized => {\n-            span_note!(tcx.sess, cause_span,\n-                       \"only sized types can be made into objects\");\n-        }\n         ObligationCauseCode::SharedStatic => {\n             span_note!(tcx.sess, cause_span,\n                        \"shared static variables must have a type that implements `Sync`\");"}, {"sha": "fe61bb5e4ea6f7b0841bf978abd26ba4e6904ccf", "filename": "src/librustc/middle/traits/mod.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fa433875274ff4a7c4cab7d87c1284ba782ef643/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa433875274ff4a7c4cab7d87c1284ba782ef643/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs?ref=fa433875274ff4a7c4cab7d87c1284ba782ef643", "patch": "@@ -28,6 +28,7 @@ use util::ppaux::Repr;\n \n pub use self::error_reporting::report_fulfillment_errors;\n pub use self::error_reporting::report_overflow_error;\n+pub use self::error_reporting::report_selection_error;\n pub use self::error_reporting::suggest_new_overflow_limit;\n pub use self::coherence::orphan_check;\n pub use self::coherence::overlapping_impls;\n@@ -48,6 +49,7 @@ pub use self::select::{MethodMatchedData}; // intentionally don't export variant\n pub use self::util::elaborate_predicates;\n pub use self::util::get_vtable_index_of_object_method;\n pub use self::util::trait_ref_for_builtin_bound;\n+pub use self::util::predicate_for_trait_def;\n pub use self::util::supertraits;\n pub use self::util::Supertraits;\n pub use self::util::supertrait_def_ids;\n@@ -121,9 +123,6 @@ pub enum ObligationCauseCode<'tcx> {\n     // Types of fields (other than the last) in a struct must be sized.\n     FieldSized,\n \n-    // Only Sized types can be made into objects\n-    ObjectSized,\n-\n     // static items must have `Sync` type\n     SharedStatic,\n \n@@ -159,6 +158,7 @@ pub enum SelectionError<'tcx> {\n     OutputTypeParameterMismatch(ty::PolyTraitRef<'tcx>,\n                                 ty::PolyTraitRef<'tcx>,\n                                 ty::type_err<'tcx>),\n+    TraitNotObjectSafe(ast::DefId),\n }\n \n pub struct FulfillmentError<'tcx> {\n@@ -536,7 +536,9 @@ impl<'tcx, N> Vtable<'tcx, N> {\n         }\n     }\n \n-    pub fn map_nested<M, F>(&self, op: F) -> Vtable<'tcx, M> where F: FnMut(&N) -> M {\n+    pub fn map_nested<M, F>(&self, op: F) -> Vtable<'tcx, M> where\n+        F: FnMut(&N) -> M,\n+    {\n         match *self {\n             VtableImpl(ref i) => VtableImpl(i.map_nested(op)),\n             VtableDefaultImpl(ref t) => VtableDefaultImpl(t.map_nested(op)),"}, {"sha": "cb889b76eacf6c0f368a6e68fb216ca21015048e", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 258, "deletions": 7, "changes": 265, "blob_url": "https://github.com/rust-lang/rust/blob/fa433875274ff4a7c4cab7d87c1284ba782ef643/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa433875274ff4a7c4cab7d87c1284ba782ef643/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=fa433875274ff4a7c4cab7d87c1284ba782ef643", "patch": "@@ -25,6 +25,8 @@ use super::{PredicateObligation, TraitObligation, ObligationCause};\n use super::report_overflow_error;\n use super::{ObligationCauseCode, BuiltinDerivedObligation, ImplDerivedObligation};\n use super::{SelectionError, Unimplemented, OutputTypeParameterMismatch};\n+use super::{ObjectCastObligation, Obligation};\n+use super::TraitNotObjectSafe;\n use super::Selection;\n use super::SelectionResult;\n use super::{VtableBuiltin, VtableImpl, VtableParam, VtableClosure,\n@@ -35,7 +37,7 @@ use super::util;\n \n use middle::fast_reject;\n use middle::subst::{Subst, Substs, TypeSpace, VecPerParamSpace};\n-use middle::ty::{self, RegionEscape, ToPolyTraitRef, Ty};\n+use middle::ty::{self, AsPredicate, RegionEscape, ToPolyTraitRef, Ty};\n use middle::infer;\n use middle::infer::{InferCtxt, TypeFreshener};\n use middle::ty_fold::TypeFoldable;\n@@ -207,6 +209,8 @@ enum SelectionCandidate<'tcx> {\n \n     BuiltinObjectCandidate,\n \n+    BuiltinUnsizeCandidate,\n+\n     ErrorCandidate,\n }\n \n@@ -904,6 +908,11 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 try!(self.assemble_builtin_bound_candidates(bound, stack, &mut candidates));\n             }\n \n+            None if self.tcx().lang_items.unsize_trait() ==\n+                    Some(obligation.predicate.def_id()) => {\n+                self.assemble_candidates_for_unsizing(obligation, &mut candidates);\n+            }\n+\n             Some(ty::BoundSend) |\n             Some(ty::BoundSync) |\n             None => {\n@@ -1356,6 +1365,84 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         }).unwrap();\n     }\n \n+    /// Search for unsizing that might apply to `obligation`.\n+    fn assemble_candidates_for_unsizing(&mut self,\n+                                        obligation: &TraitObligation<'tcx>,\n+                                        candidates: &mut SelectionCandidateSet<'tcx>) {\n+        // We currently never consider higher-ranked obligations e.g.\n+        // `for<'a> &'a T: Unsize<Trait+'a>` to be implemented. This is not\n+        // because they are a priori invalid, and we could potentially add support\n+        // for them later, it's just that there isn't really a strong need for it.\n+        // A `T: Unsize<U>` obligation is always used as part of a `T: CoerceUnsize<U>`\n+        // impl, and those are generally applied to concrete types.\n+        //\n+        // That said, one might try to write a fn with a where clause like\n+        //     for<'a> Foo<'a, T>: Unsize<Foo<'a, Trait>>\n+        // where the `'a` is kind of orthogonal to the relevant part of the `Unsize`.\n+        // Still, you'd be more likely to write that where clause as\n+        //     T: Trait\n+        // so it seems ok if we (conservatively) fail to accept that `Unsize`\n+        // obligation above. Should be possible to extend this in the future.\n+        let self_ty = match ty::no_late_bound_regions(self.tcx(), &obligation.self_ty()) {\n+            Some(t) => t,\n+            None => {\n+                // Don't add any candidates if there are bound regions.\n+                return;\n+            }\n+        };\n+        let source = self.infcx.shallow_resolve(self_ty);\n+        let target = self.infcx.shallow_resolve(obligation.predicate.0.input_types()[0]);\n+\n+        debug!(\"assemble_candidates_for_unsizing(source={}, target={})\",\n+               source.repr(self.tcx()), target.repr(self.tcx()));\n+\n+        let may_apply = match (&source.sty, &target.sty) {\n+            // Trait+Kx+'a -> Trait+Ky+'b (upcasts).\n+            (&ty::ty_trait(ref data_a), &ty::ty_trait(ref data_b)) => {\n+                // Upcasts permit two things:\n+                //\n+                // 1. Dropping builtin bounds, e.g. `Foo+Send` to `Foo`\n+                // 2. Tightening the region bound, e.g. `Foo+'a` to `Foo+'b` if `'a : 'b`\n+                //\n+                // Note that neither of these changes requires any\n+                // change at runtime.  Eventually this will be\n+                // generalized.\n+                //\n+                // We always upcast when we can because of reason\n+                // #2 (region bounds).\n+                data_a.principal.def_id() == data_a.principal.def_id() &&\n+                data_a.bounds.builtin_bounds.is_superset(&data_b.bounds.builtin_bounds)\n+            }\n+\n+            // T -> Trait.\n+            (_, &ty::ty_trait(_)) => true,\n+\n+            // Ambiguous handling is below T -> Trait, because inference\n+            // variables can still implement Unsize<Trait> and nested\n+            // obligations will have the final say (likely deferred).\n+            (&ty::ty_infer(ty::TyVar(_)), _) |\n+            (_, &ty::ty_infer(ty::TyVar(_))) => {\n+                debug!(\"assemble_candidates_for_unsizing: ambiguous\");\n+                candidates.ambiguous = true;\n+                false\n+            }\n+\n+            // [T; n] -> [T].\n+            (&ty::ty_vec(_, Some(_)), &ty::ty_vec(_, None)) => true,\n+\n+            // Struct<T> -> Struct<U>.\n+            (&ty::ty_struct(def_id_a, _), &ty::ty_struct(def_id_b, _)) => {\n+                def_id_a == def_id_b\n+            }\n+\n+            _ => false\n+        };\n+\n+        if may_apply {\n+            candidates.vec.push(BuiltinUnsizeCandidate);\n+        }\n+    }\n+\n     ///////////////////////////////////////////////////////////////////////////\n     // WINNOW\n     //\n@@ -1427,6 +1514,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 &ClosureCandidate(..) |\n                 &FnPointerCandidate(..) |\n                 &BuiltinObjectCandidate(..) |\n+                &BuiltinUnsizeCandidate(..) |\n                 &DefaultImplObjectCandidate(..) |\n                 &BuiltinCandidate(..) => {\n                     // We have a where-clause so don't go around looking\n@@ -1855,11 +1943,12 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                                                   obligation.recursion_depth + 1,\n                                                   &skol_ty);\n                 let skol_obligation =\n-                    try!(util::predicate_for_trait_def(self.tcx(),\n-                                                       derived_cause.clone(),\n-                                                       trait_def_id,\n-                                                       obligation.recursion_depth + 1,\n-                                                       normalized_ty));\n+                    util::predicate_for_trait_def(self.tcx(),\n+                                                  derived_cause.clone(),\n+                                                  trait_def_id,\n+                                                  obligation.recursion_depth + 1,\n+                                                  normalized_ty,\n+                                                  vec![]);\n                 obligations.push(skol_obligation);\n                 Ok(self.infcx().plug_leaks(skol_map, snapshot, &obligations))\n             })\n@@ -1949,6 +2038,11 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 self.confirm_projection_candidate(obligation);\n                 Ok(VtableParam(Vec::new()))\n             }\n+\n+            BuiltinUnsizeCandidate => {\n+                let data = try!(self.confirm_builtin_unsize_candidate(obligation));\n+                Ok(VtableBuiltin(data))\n+            }\n         }\n     }\n \n@@ -2322,6 +2416,161 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         }\n     }\n \n+    fn confirm_builtin_unsize_candidate(&mut self,\n+                                        obligation: &TraitObligation<'tcx>,)\n+                                        -> Result<VtableBuiltinData<PredicateObligation<'tcx>>,\n+                                                  SelectionError<'tcx>> {\n+        let tcx = self.tcx();\n+\n+        // assemble_candidates_for_unsizing should ensure there are no late bound\n+        // regions here. See the comment there for more details.\n+        let source = self.infcx.shallow_resolve(\n+            ty::no_late_bound_regions(tcx, &obligation.self_ty()).unwrap());\n+        let target = self.infcx.shallow_resolve(obligation.predicate.0.input_types()[0]);\n+\n+        debug!(\"confirm_builtin_unsize_candidate(source={}, target={})\",\n+               source.repr(tcx), target.repr(tcx));\n+\n+        let mut nested = vec![];\n+        match (&source.sty, &target.sty) {\n+            // Trait+Kx+'a -> Trait+Ky+'b (upcasts).\n+            (&ty::ty_trait(ref data_a), &ty::ty_trait(ref data_b)) => {\n+                // See assemble_candidates_for_unsizing for more info.\n+                let bounds = ty::ExistentialBounds {\n+                    region_bound: data_b.bounds.region_bound,\n+                    builtin_bounds: data_b.bounds.builtin_bounds,\n+                    projection_bounds: data_a.bounds.projection_bounds.clone(),\n+                };\n+\n+                let new_trait = ty::mk_trait(tcx, data_a.principal.clone(), bounds);\n+                let origin = infer::Misc(obligation.cause.span);\n+                if self.infcx.sub_types(false, origin, new_trait, target).is_err() {\n+                    return Err(Unimplemented);\n+                }\n+\n+                // Register one obligation for 'a: 'b.\n+                let cause = ObligationCause::new(obligation.cause.span,\n+                                                 obligation.cause.body_id,\n+                                                 ObjectCastObligation(target));\n+                let outlives = ty::OutlivesPredicate(data_a.bounds.region_bound,\n+                                                     data_b.bounds.region_bound);\n+                nested.push(Obligation::with_depth(cause,\n+                                                   obligation.recursion_depth + 1,\n+                                                   ty::Binder(outlives).as_predicate()));\n+            }\n+\n+            // T -> Trait.\n+            (_, &ty::ty_trait(ref data)) => {\n+                let object_did = data.principal_def_id();\n+                if !object_safety::is_object_safe(tcx, object_did) {\n+                    return Err(TraitNotObjectSafe(object_did));\n+                }\n+\n+                let cause = ObligationCause::new(obligation.cause.span,\n+                                                 obligation.cause.body_id,\n+                                                 ObjectCastObligation(target));\n+                let mut push = |predicate| {\n+                    nested.push(Obligation::with_depth(cause.clone(),\n+                                                       obligation.recursion_depth + 1,\n+                                                       predicate));\n+                };\n+\n+                // Create the obligation for casting from T to Trait.\n+                push(data.principal_trait_ref_with_self_ty(tcx, source).as_predicate());\n+\n+                // We can only make objects from sized types.\n+                let mut builtin_bounds = data.bounds.builtin_bounds;\n+                builtin_bounds.insert(ty::BoundSized);\n+\n+                // Create additional obligations for all the various builtin\n+                // bounds attached to the object cast. (In other words, if the\n+                // object type is Foo+Send, this would create an obligation\n+                // for the Send check.)\n+                for bound in &builtin_bounds {\n+                    if let Ok(tr) = util::trait_ref_for_builtin_bound(tcx, bound, source) {\n+                        push(tr.as_predicate());\n+                    } else {\n+                        return Err(Unimplemented);\n+                    }\n+                }\n+\n+                // Create obligations for the projection predicates.\n+                for bound in data.projection_bounds_with_self_ty(tcx, source) {\n+                    push(bound.as_predicate());\n+                }\n+\n+                // If the type is `Foo+'a`, ensures that the type\n+                // being cast to `Foo+'a` outlives `'a`:\n+                let outlives = ty::OutlivesPredicate(source,\n+                                                     data.bounds.region_bound);\n+                push(ty::Binder(outlives).as_predicate());\n+            }\n+\n+            // [T; n] -> [T].\n+            (&ty::ty_vec(a, Some(_)), &ty::ty_vec(b, None)) => {\n+                let origin = infer::Misc(obligation.cause.span);\n+                if self.infcx.sub_types(false, origin, a, b).is_err() {\n+                    return Err(Unimplemented);\n+                }\n+            }\n+\n+            // Struct<T> -> Struct<U>.\n+            (&ty::ty_struct(def_id, substs_a), &ty::ty_struct(_, substs_b)) => {\n+                let fields = ty::lookup_struct_fields(tcx, def_id).iter().map(|f| {\n+                    ty::lookup_field_type_unsubstituted(tcx, def_id, f.id)\n+                }).collect::<Vec<_>>();\n+\n+                // FIXME(#25351) The last field of the structure has to exist and be a\n+                // type parameter (for now, to avoid tracking edge cases).\n+                let i = if let Some(&ty::ty_param(p)) = fields.last().map(|ty| &ty.sty) {\n+                    assert!(p.space == TypeSpace);\n+                    p.idx as usize\n+                } else {\n+                    return Err(Unimplemented);\n+                };\n+\n+                // Replace the type parameter chosen for unsizing with\n+                // ty_err and ensure it does not affect any other fields.\n+                // This could be checked after type collection for any struct\n+                // with a potentially unsized trailing field.\n+                let mut new_substs = substs_a.clone();\n+                new_substs.types.get_mut_slice(TypeSpace)[i] = tcx.types.err;\n+                for &ty in fields.init() {\n+                    if ty::type_is_error(ty.subst(tcx, &new_substs)) {\n+                        return Err(Unimplemented);\n+                    }\n+                }\n+\n+                // Extract T and U from Struct<T> and Struct<U>.\n+                let inner_source = *substs_a.types.get(TypeSpace, i);\n+                let inner_target = *substs_b.types.get(TypeSpace, i);\n+\n+                // Check that all the source structure with the unsized\n+                // type parameter is a subtype of the target.\n+                new_substs.types.get_mut_slice(TypeSpace)[i] = inner_target;\n+                let new_struct = ty::mk_struct(tcx, def_id, tcx.mk_substs(new_substs));\n+                let origin = infer::Misc(obligation.cause.span);\n+                if self.infcx.sub_types(false, origin, new_struct, target).is_err() {\n+                    return Err(Unimplemented);\n+                }\n+\n+                // Construct the nested T: Unsize<U> predicate.\n+                nested.push(util::predicate_for_trait_def(tcx,\n+                    obligation.cause.clone(),\n+                    obligation.predicate.def_id(),\n+                    obligation.recursion_depth + 1,\n+                    inner_source,\n+                    vec![inner_target]));\n+            }\n+\n+            _ => unreachable!()\n+        };\n+\n+        Ok(VtableBuiltinData {\n+            nested: VecPerParamSpace::new(nested, vec![], vec![])\n+        })\n+    }\n+\n     ///////////////////////////////////////////////////////////////////////////\n     // Matching\n     //\n@@ -2683,6 +2932,7 @@ impl<'tcx> Repr<'tcx> for SelectionCandidate<'tcx> {\n             ErrorCandidate => format!(\"ErrorCandidate\"),\n             BuiltinCandidate(b) => format!(\"BuiltinCandidate({:?})\", b),\n             BuiltinObjectCandidate => format!(\"BuiltinObjectCandidate\"),\n+            BuiltinUnsizeCandidate => format!(\"BuiltinUnsizeCandidate\"),\n             ParamCandidate(ref a) => format!(\"ParamCandidate({})\", a.repr(tcx)),\n             ImplCandidate(a) => format!(\"ImplCandidate({})\", a.repr(tcx)),\n             DefaultImplCandidate(t) => format!(\"DefaultImplCandidate({:?})\", t),\n@@ -2756,7 +3006,8 @@ impl<'tcx> EvaluationResult<'tcx> {\n         match *self {\n             EvaluatedToOk |\n             EvaluatedToAmbig |\n-            EvaluatedToErr(OutputTypeParameterMismatch(..)) =>\n+            EvaluatedToErr(OutputTypeParameterMismatch(..)) |\n+            EvaluatedToErr(TraitNotObjectSafe(_)) =>\n                 true,\n \n             EvaluatedToErr(Unimplemented) =>"}, {"sha": "f30f8560b9fe1627185e3a318c4993e1c0477a2f", "filename": "src/librustc/middle/traits/util.rs", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/fa433875274ff4a7c4cab7d87c1284ba782ef643/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa433875274ff4a7c4cab7d87c1284ba782ef643/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs?ref=fa433875274ff4a7c4cab7d87c1284ba782ef643", "patch": "@@ -356,26 +356,27 @@ pub fn predicate_for_trait_ref<'tcx>(\n     cause: ObligationCause<'tcx>,\n     trait_ref: ty::TraitRef<'tcx>,\n     recursion_depth: usize)\n-    -> Result<PredicateObligation<'tcx>, ErrorReported>\n+    -> PredicateObligation<'tcx>\n {\n-    Ok(Obligation {\n+    Obligation {\n         cause: cause,\n         recursion_depth: recursion_depth,\n         predicate: trait_ref.as_predicate(),\n-    })\n+    }\n }\n \n pub fn predicate_for_trait_def<'tcx>(\n     tcx: &ty::ctxt<'tcx>,\n     cause: ObligationCause<'tcx>,\n     trait_def_id: ast::DefId,\n     recursion_depth: usize,\n-    param_ty: Ty<'tcx>)\n-    -> Result<PredicateObligation<'tcx>, ErrorReported>\n+    param_ty: Ty<'tcx>,\n+    ty_params: Vec<Ty<'tcx>>)\n+    -> PredicateObligation<'tcx>\n {\n     let trait_ref = ty::TraitRef {\n         def_id: trait_def_id,\n-        substs: tcx.mk_substs(Substs::empty().with_self_ty(param_ty))\n+        substs: tcx.mk_substs(Substs::new_trait(ty_params, vec![], param_ty))\n     };\n     predicate_for_trait_ref(cause, trait_ref, recursion_depth)\n }\n@@ -389,7 +390,7 @@ pub fn predicate_for_builtin_bound<'tcx>(\n     -> Result<PredicateObligation<'tcx>, ErrorReported>\n {\n     let trait_ref = try!(trait_ref_for_builtin_bound(tcx, builtin_bound, param_ty));\n-    predicate_for_trait_ref(cause, trait_ref, recursion_depth)\n+    Ok(predicate_for_trait_ref(cause, trait_ref, recursion_depth))\n }\n \n /// Cast a trait reference into a reference to one of its super\n@@ -561,6 +562,10 @@ impl<'tcx> Repr<'tcx> for super::SelectionError<'tcx> {\n                         a.repr(tcx),\n                         b.repr(tcx),\n                         c.repr(tcx)),\n+\n+            super::TraitNotObjectSafe(ref tr) =>\n+                format!(\"TraitNotObjectSafe({})\",\n+                        tr.repr(tcx))\n         }\n     }\n }"}, {"sha": "9054cd654732d7ef33603e8e0453d6fcfcde3aaa", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 47, "deletions": 10, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/fa433875274ff4a7c4cab7d87c1284ba782ef643/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa433875274ff4a7c4cab7d87c1284ba782ef643/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=fa433875274ff4a7c4cab7d87c1284ba782ef643", "patch": "@@ -404,6 +404,12 @@ pub enum AutoRef<'tcx> {\n     AutoUnsafe(ast::Mutability),\n }\n \n+#[derive(Clone, Copy, RustcEncodable, RustcDecodable, Debug)]\n+pub enum CustomCoerceUnsized {\n+    /// Records the index of the field being coerced.\n+    Struct(usize)\n+}\n+\n #[derive(Clone, Copy, RustcEncodable, RustcDecodable, PartialEq, PartialOrd, Debug)]\n pub struct param_index {\n     pub space: subst::ParamSpace,\n@@ -818,6 +824,9 @@ pub struct ctxt<'tcx> {\n \n     /// Maps Expr NodeId's to their constant qualification.\n     pub const_qualif_map: RefCell<NodeMap<check_const::ConstQualif>>,\n+\n+    /// Caches CoerceUnsized kinds for impls on custom types.\n+    pub custom_coerce_unsized_kinds: RefCell<DefIdMap<CustomCoerceUnsized>>,\n }\n \n impl<'tcx> ctxt<'tcx> {\n@@ -2809,6 +2818,7 @@ pub fn mk_ctxt<'tcx>(s: Session,\n         type_impls_copy_cache: RefCell::new(HashMap::new()),\n         type_impls_sized_cache: RefCell::new(HashMap::new()),\n         const_qualif_map: RefCell::new(NodeMap()),\n+        custom_coerce_unsized_kinds: RefCell::new(DefIdMap()),\n    }\n }\n \n@@ -4410,7 +4420,7 @@ pub fn deref<'tcx>(ty: Ty<'tcx>, explicit: bool) -> Option<mt<'tcx>> {\n pub fn type_content<'tcx>(ty: Ty<'tcx>) -> Ty<'tcx> {\n     match ty.sty {\n         ty_uniq(ty) => ty,\n-        ty_rptr(_, mt) |ty_ptr(mt) => mt.ty,\n+        ty_rptr(_, mt) | ty_ptr(mt) => mt.ty,\n         _ => ty\n     }\n }\n@@ -5351,6 +5361,26 @@ pub fn trait_impl_polarity<'tcx>(cx: &ctxt<'tcx>, id: ast::DefId)\n      }\n }\n \n+pub fn custom_coerce_unsized_kind<'tcx>(cx: &ctxt<'tcx>, did: ast::DefId)\n+                                        -> CustomCoerceUnsized {\n+    memoized(&cx.custom_coerce_unsized_kinds, did, |did: DefId| {\n+        let (kind, src) = if did.krate != ast::LOCAL_CRATE {\n+            (csearch::get_custom_coerce_unsized_kind(cx, did), \"external\")\n+        } else {\n+            (None, \"local\")\n+        };\n+\n+        match kind {\n+            Some(kind) => kind,\n+            None => {\n+                cx.sess.bug(&format!(\"custom_coerce_unsized_kind: \\\n+                                      {} impl `{}` is missing its kind\",\n+                                     src, item_path_str(cx, did)));\n+            }\n+        }\n+    })\n+}\n+\n pub fn impl_or_trait_item<'tcx>(cx: &ctxt<'tcx>, id: ast::DefId)\n                                 -> ImplOrTraitItem<'tcx> {\n     lookup_locally_or_in_crate_store(\"impl_or_trait_items\",\n@@ -5576,8 +5606,7 @@ impl DtorKind {\n     }\n }\n \n-/* If struct_id names a struct with a dtor, return Some(the dtor's id).\n-   Otherwise return none. */\n+/* If struct_id names a struct with a dtor. */\n pub fn ty_dtor(cx: &ctxt, struct_id: DefId) -> DtorKind {\n     match cx.destructor_for_type.borrow().get(&struct_id) {\n         Some(&method_def_id) => {\n@@ -6012,20 +6041,28 @@ pub fn lookup_repr_hints(tcx: &ctxt, did: DefId) -> Rc<Vec<attr::ReprAttr>> {\n     })\n }\n \n+// Look up a field ID, whether or not it's local\n+pub fn lookup_field_type_unsubstituted<'tcx>(tcx: &ctxt<'tcx>,\n+                                             struct_id: DefId,\n+                                             id: DefId)\n+                                             -> Ty<'tcx> {\n+    if id.krate == ast::LOCAL_CRATE {\n+        node_id_to_type(tcx, id.node)\n+    } else {\n+        let mut tcache = tcx.tcache.borrow_mut();\n+        tcache.entry(id).or_insert_with(|| csearch::get_field_type(tcx, struct_id, id)).ty\n+    }\n+}\n+\n+\n // Look up a field ID, whether or not it's local\n // Takes a list of type substs in case the struct is generic\n pub fn lookup_field_type<'tcx>(tcx: &ctxt<'tcx>,\n                                struct_id: DefId,\n                                id: DefId,\n                                substs: &Substs<'tcx>)\n                                -> Ty<'tcx> {\n-    let ty = if id.krate == ast::LOCAL_CRATE {\n-        node_id_to_type(tcx, id.node)\n-    } else {\n-        let mut tcache = tcx.tcache.borrow_mut();\n-        tcache.entry(id).or_insert_with(|| csearch::get_field_type(tcx, struct_id, id)).ty\n-    };\n-    ty.subst(tcx, substs)\n+    lookup_field_type_unsubstituted(tcx, struct_id, id).subst(tcx, substs)\n }\n \n // Look up the list of field names and IDs for a given struct."}, {"sha": "17c9fa248180c01ddd8dd3b57db8ebd8dac6154e", "filename": "src/librustc_trans/trans/adt.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/fa433875274ff4a7c4cab7d87c1284ba782ef643/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa433875274ff4a7c4cab7d87c1284ba782ef643/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fadt.rs?ref=fa433875274ff4a7c4cab7d87c1284ba782ef643", "patch": "@@ -141,7 +141,8 @@ pub fn represent_node<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n /// Decides how to represent a given type.\n pub fn represent_type<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n-                                t: Ty<'tcx>) -> Rc<Repr<'tcx>> {\n+                                t: Ty<'tcx>)\n+                                -> Rc<Repr<'tcx>> {\n     debug!(\"Representing: {}\", ty_to_string(cx.tcx(), t));\n     match cx.adt_reprs().borrow().get(&t) {\n         Some(repr) => return repr.clone(),\n@@ -216,7 +217,9 @@ fn represent_type_uncached<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             }).collect::<Vec<_>>();\n             let packed = ty::lookup_packed(cx.tcx(), def_id);\n             let dtor = ty::ty_dtor(cx.tcx(), def_id).has_drop_flag();\n-            if dtor { ftys.push(cx.tcx().dtor_type()); }\n+            if dtor {\n+                ftys.push(cx.tcx().dtor_type());\n+            }\n \n             Univariant(mk_struct(cx, &ftys[..], packed, t), dtor_to_init_u8(dtor))\n         }\n@@ -517,8 +520,7 @@ fn mk_struct<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                        -> Struct<'tcx> {\n     let sized = tys.iter().all(|&ty| type_is_sized(cx.tcx(), ty));\n     let lltys : Vec<Type> = if sized {\n-        tys.iter()\n-           .map(|&ty| type_of::sizing_type_of(cx, ty)).collect()\n+        tys.iter().map(|&ty| type_of::sizing_type_of(cx, ty)).collect()\n     } else {\n         tys.iter().filter(|&ty| type_is_sized(cx.tcx(), *ty))\n            .map(|&ty| type_of::sizing_type_of(cx, ty)).collect()\n@@ -1060,7 +1062,9 @@ pub fn fold_variants<'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n }\n \n /// Access the struct drop flag, if present.\n-pub fn trans_drop_flag_ptr<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>, r: &Repr<'tcx>, val: ValueRef)\n+pub fn trans_drop_flag_ptr<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n+                                       r: &Repr<'tcx>,\n+                                       val: ValueRef)\n                                        -> datum::DatumBlock<'blk, 'tcx, datum::Expr>\n {\n     let tcx = bcx.tcx();"}, {"sha": "ab86cd7cdde5996a7db24362341e8cde6818a2f2", "filename": "src/librustc_trans/trans/debuginfo/metadata.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fa433875274ff4a7c4cab7d87c1284ba782ef643/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa433875274ff4a7c4cab7d87c1284ba782ef643/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs?ref=fa433875274ff4a7c4cab7d87c1284ba782ef643", "patch": "@@ -1058,6 +1058,7 @@ impl MetadataCreationResult {\n     }\n }\n \n+#[derive(Debug)]\n enum MemberOffset {\n     FixedMemberOffset { bytes: usize },\n     // For ComputedMemberOffset, the offset is read from the llvm type definition.\n@@ -1066,6 +1067,7 @@ enum MemberOffset {\n \n // Description of a type member, which can either be a regular field (as in\n // structs or tuples) or an enum variant.\n+#[derive(Debug)]\n struct MemberDescription {\n     name: String,\n     llvm_type: Type,\n@@ -1163,13 +1165,13 @@ fn prepare_struct_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                      span: Span)\n                                      -> RecursiveTypeDescription<'tcx> {\n     let struct_name = compute_debuginfo_type_name(cx, struct_type, false);\n-    let struct_llvm_type = type_of::type_of(cx, struct_type);\n+    let struct_llvm_type = type_of::in_memory_type_of(cx, struct_type);\n \n     let (containing_scope, _) = get_namespace_and_span_for_item(cx, def_id);\n \n     let struct_metadata_stub = create_struct_stub(cx,\n                                                   struct_llvm_type,\n-                                                  &struct_name[..],\n+                                                  &struct_name,\n                                                   unique_type_id,\n                                                   containing_scope);\n \n@@ -1299,7 +1301,7 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n                         set_members_of_composite_type(cx,\n                                                       variant_type_metadata,\n                                                       variant_llvm_type,\n-                                                      &member_descriptions[..]);\n+                                                      &member_descriptions);\n                         MemberDescription {\n                             name: \"\".to_string(),\n                             llvm_type: variant_llvm_type,"}, {"sha": "270aacfe143df2ac3846dc06ddca4ab9d5957bb5", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 154, "deletions": 63, "changes": 217, "blob_url": "https://github.com/rust-lang/rust/blob/fa433875274ff4a7c4cab7d87c1284ba782ef643/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa433875274ff4a7c4cab7d87c1284ba782ef643/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=fa433875274ff4a7c4cab7d87c1284ba782ef643", "patch": "@@ -56,8 +56,10 @@ use back::abi;\n use llvm::{self, ValueRef};\n use middle::check_const;\n use middle::def;\n+use middle::lang_items::CoerceUnsizedTraitLangItem;\n use middle::mem_categorization::Typer;\n-use middle::subst::{self, Substs};\n+use middle::subst::{Substs, VecPerParamSpace};\n+use middle::traits;\n use trans::{_match, adt, asm, base, callee, closure, consts, controlflow};\n use trans::base::*;\n use trans::build::*;\n@@ -304,7 +306,7 @@ pub fn unsized_info<'ccx, 'tcx>(ccx: &CrateContext<'ccx, 'tcx>,\n                                 source: Ty<'tcx>,\n                                 target: Ty<'tcx>,\n                                 old_info: Option<ValueRef>,\n-                                param_substs: &'tcx subst::Substs<'tcx>)\n+                                param_substs: &'tcx Substs<'tcx>)\n                                 -> ValueRef {\n     let (source, target) = ty::struct_lockstep_tails(ccx.tcx(), source, target);\n     match (&source.sty, &target.sty) {\n@@ -390,81 +392,161 @@ fn apply_adjustments<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             // (You might think there is a more elegant way to do this than a\n             // skip_reborrows bool, but then you remember that the borrow checker exists).\n             if skip_reborrows == 0 && adj.autoref.is_some() {\n-                datum = unpack_datum!(bcx, apply_autoref(bcx, expr, datum));\n+                if !type_is_sized(bcx.tcx(), datum.ty) {\n+                    // Arrange cleanup\n+                    let lval = unpack_datum!(bcx,\n+                        datum.to_lvalue_datum(bcx, \"ref_fat_ptr\", expr.id));\n+                    datum = unpack_datum!(bcx, ref_fat_ptr(bcx, lval));\n+                } else {\n+                    datum = unpack_datum!(bcx, auto_ref(bcx, datum, expr));\n+                }\n             }\n \n             if let Some(target) = adj.unsize {\n-                datum = unpack_datum!(bcx, unsize_pointer(bcx, datum,\n-                                                          bcx.monomorphize(&target)));\n+                // We do not arrange cleanup ourselves; if we already are an\n+                // L-value, then cleanup will have already been scheduled (and\n+                // the `datum.to_rvalue_datum` call below will emit code to zero\n+                // the drop flag when moving out of the L-value). If we are an\n+                // R-value, then we do not need to schedule cleanup.\n+                let source_datum = unpack_datum!(bcx,\n+                    datum.to_rvalue_datum(bcx, \"__coerce_source\"));\n+\n+                let target = bcx.monomorphize(&target);\n+                let llty = type_of::type_of(bcx.ccx(), target);\n+\n+                // HACK(eddyb) get around issues with lifetime intrinsics.\n+                let scratch = alloca_no_lifetime(bcx, llty, \"__coerce_target\");\n+                let target_datum = Datum::new(scratch, target,\n+                                              Rvalue::new(ByRef));\n+                bcx = coerce_unsized(bcx, expr.span, source_datum, target_datum);\n+                datum = Datum::new(scratch, target,\n+                                   RvalueExpr(Rvalue::new(ByRef)));\n             }\n         }\n     }\n     debug!(\"after adjustments, datum={}\", datum.to_string(bcx.ccx()));\n-    return DatumBlock::new(bcx, datum);\n+    DatumBlock::new(bcx, datum)\n+}\n \n-    fn apply_autoref<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                 expr: &ast::Expr,\n-                                 datum: Datum<'tcx, Expr>)\n-                                 -> DatumBlock<'blk, 'tcx, Expr> {\n-        let mut bcx = bcx;\n+fn coerce_unsized<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                              span: codemap::Span,\n+                              source: Datum<'tcx, Rvalue>,\n+                              target: Datum<'tcx, Rvalue>)\n+                              -> Block<'blk, 'tcx> {\n+    let mut bcx = bcx;\n+    debug!(\"coerce_unsized({} -> {})\",\n+           source.to_string(bcx.ccx()),\n+           target.to_string(bcx.ccx()));\n+\n+    match (&source.ty.sty, &target.ty.sty) {\n+        (&ty::ty_uniq(a), &ty::ty_uniq(b)) |\n+        (&ty::ty_rptr(_, ty::mt { ty: a, .. }), &ty::ty_rptr(_, ty::mt { ty: b, .. })) |\n+        (&ty::ty_rptr(_, ty::mt { ty: a, .. }), &ty::ty_ptr(ty::mt { ty: b, .. })) |\n+        (&ty::ty_ptr(ty::mt { ty: a, .. }), &ty::ty_ptr(ty::mt { ty: b, .. })) => {\n+            let (inner_source, inner_target) = (a, b);\n+\n+            let (base, old_info) = if !type_is_sized(bcx.tcx(), inner_source) {\n+                // Normally, the source is a thin pointer and we are\n+                // adding extra info to make a fat pointer. The exception\n+                // is when we are upcasting an existing object fat pointer\n+                // to use a different vtable. In that case, we want to\n+                // load out the original data pointer so we can repackage\n+                // it.\n+                (Load(bcx, get_dataptr(bcx, source.val)),\n+                Some(Load(bcx, get_len(bcx, source.val))))\n+            } else {\n+                let val = if source.kind.is_by_ref() {\n+                    load_ty(bcx, source.val, source.ty)\n+                } else {\n+                    source.val\n+                };\n+                (val, None)\n+            };\n \n-        if !type_is_sized(bcx.tcx(), datum.ty) {\n-            // Arrange cleanup\n-            let lval = unpack_datum!(bcx,\n-                datum.to_lvalue_datum(bcx, \"ref_fat_ptr\", expr.id));\n-            ref_fat_ptr(bcx, lval)\n-        } else {\n-            auto_ref(bcx, datum, expr)\n+            let info = unsized_info(bcx.ccx(), inner_source, inner_target,\n+                                    old_info, bcx.fcx.param_substs);\n+\n+            // Compute the base pointer. This doesn't change the pointer value,\n+            // but merely its type.\n+            let ptr_ty = type_of::in_memory_type_of(bcx.ccx(), inner_target).ptr_to();\n+            let base = PointerCast(bcx, base, ptr_ty);\n+\n+            Store(bcx, base, get_dataptr(bcx, target.val));\n+            Store(bcx, info, get_len(bcx, target.val));\n         }\n-    }\n \n-    fn unsize_pointer<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                  datum: Datum<'tcx, Expr>,\n-                                  target: Ty<'tcx>)\n-                                  -> DatumBlock<'blk, 'tcx, Expr> {\n-        let mut bcx = bcx;\n-        let unsized_ty = ty::deref(target, true)\n-            .expect(\"expr::unsize got non-pointer target type\").ty;\n-        debug!(\"unsize_lvalue(unsized_ty={})\", unsized_ty.repr(bcx.tcx()));\n-\n-        // We do not arrange cleanup ourselves; if we already are an\n-        // L-value, then cleanup will have already been scheduled (and\n-        // the `datum.to_rvalue_datum` call below will emit code to zero\n-        // the drop flag when moving out of the L-value). If we are an\n-        // R-value, then we do not need to schedule cleanup.\n-        let datum = unpack_datum!(bcx, datum.to_rvalue_datum(bcx, \"__unsize_ref\"));\n-\n-        let pointee_ty = ty::deref(datum.ty, true)\n-            .expect(\"expr::unsize got non-pointer datum type\").ty;\n-        let (base, old_info) = if !type_is_sized(bcx.tcx(), pointee_ty) {\n-            // Normally, the source is a thin pointer and we are\n-            // adding extra info to make a fat pointer. The exception\n-            // is when we are upcasting an existing object fat pointer\n-            // to use a different vtable. In that case, we want to\n-            // load out the original data pointer so we can repackage\n-            // it.\n-            (Load(bcx, get_dataptr(bcx, datum.val)),\n-             Some(Load(bcx, get_len(bcx, datum.val))))\n-        } else {\n-            (datum.val, None)\n-        };\n+        // This can be extended to enums and tuples in the future.\n+        // (&ty::ty_enum(def_id_a, _), &ty::ty_enum(def_id_b, _)) |\n+        (&ty::ty_struct(def_id_a, _), &ty::ty_struct(def_id_b, _)) => {\n+            assert_eq!(def_id_a, def_id_b);\n+\n+            // The target is already by-ref because it's to be written to.\n+            let source = unpack_datum!(bcx, source.to_ref_datum(bcx));\n+            assert!(target.kind.is_by_ref());\n \n-        let info = unsized_info(bcx.ccx(), pointee_ty, unsized_ty,\n-                                old_info, bcx.fcx.param_substs);\n+            let trait_substs = Substs::erased(VecPerParamSpace::new(vec![target.ty],\n+                                                                    vec![source.ty],\n+                                                                    Vec::new()));\n+            let trait_ref = ty::Binder(ty::TraitRef {\n+                def_id: langcall(bcx, Some(span), \"coercion\",\n+                                 CoerceUnsizedTraitLangItem),\n+                substs: bcx.tcx().mk_substs(trait_substs)\n+            });\n \n-        // Compute the base pointer. This doesn't change the pointer value,\n-        // but merely its type.\n-        let ptr_ty = type_of::in_memory_type_of(bcx.ccx(), unsized_ty).ptr_to();\n-        let base = PointerCast(bcx, base, ptr_ty);\n+            let kind = match fulfill_obligation(bcx.ccx(), span, trait_ref) {\n+                traits::VtableImpl(traits::VtableImplData { impl_def_id, .. }) => {\n+                    ty::custom_coerce_unsized_kind(bcx.tcx(), impl_def_id)\n+                }\n+                vtable => {\n+                    bcx.sess().span_bug(span, &format!(\"invalid CoerceUnsized vtable: {}\",\n+                                                       vtable.repr(bcx.tcx())));\n+                }\n+            };\n \n-        let llty = type_of::type_of(bcx.ccx(), target);\n-        // HACK(eddyb) get around issues with lifetime intrinsics.\n-        let scratch = alloca_no_lifetime(bcx, llty, \"__fat_ptr\");\n-        Store(bcx, base, get_dataptr(bcx, scratch));\n-        Store(bcx, info, get_len(bcx, scratch));\n+            let repr_source = adt::represent_type(bcx.ccx(), source.ty);\n+            let src_fields = match &*repr_source {\n+                &adt::Repr::Univariant(ref s, _) => &s.fields,\n+                _ => bcx.sess().span_bug(span,\n+                                         &format!(\"Non univariant struct? (repr_source: {:?})\",\n+                                                  repr_source)),\n+            };\n+            let repr_target = adt::represent_type(bcx.ccx(), target.ty);\n+            let target_fields = match &*repr_target {\n+                &adt::Repr::Univariant(ref s, _) => &s.fields,\n+                _ => bcx.sess().span_bug(span,\n+                                         &format!(\"Non univariant struct? (repr_target: {:?})\",\n+                                                  repr_target)),\n+            };\n \n-        DatumBlock::new(bcx, Datum::new(scratch, target, RvalueExpr(Rvalue::new(ByRef))))\n+            let coerce_index = match kind {\n+                ty::CustomCoerceUnsized::Struct(i) => i\n+            };\n+            assert!(coerce_index < src_fields.len() && src_fields.len() == target_fields.len());\n+\n+            let iter = src_fields.iter().zip(target_fields.iter()).enumerate();\n+            for (i, (src_ty, target_ty)) in iter {\n+                let ll_source = adt::trans_field_ptr(bcx, &repr_source, source.val, 0, i);\n+                let ll_target = adt::trans_field_ptr(bcx, &repr_target, target.val, 0, i);\n+\n+                // If this is the field we need to coerce, recurse on it.\n+                if i == coerce_index {\n+                    coerce_unsized(bcx, span,\n+                                   Datum::new(ll_source, src_ty,\n+                                              Rvalue::new(ByRef)),\n+                                   Datum::new(ll_target, target_ty,\n+                                              Rvalue::new(ByRef)));\n+                } else {\n+                    // Otherwise, simply copy the data from the source.\n+                    assert_eq!(src_ty, target_ty);\n+                    memcpy_ty(bcx, ll_target, ll_source, src_ty);\n+                }\n+            }\n+        }\n+        _ => bcx.sess().bug(&format!(\"coerce_unsized: invalid coercion {} -> {}\",\n+                                     source.ty.repr(bcx.tcx()),\n+                                     target.ty.repr(bcx.tcx())))\n     }\n+    bcx\n }\n \n /// Translates an expression in \"lvalue\" mode -- meaning that it returns a reference to the memory\n@@ -1178,7 +1260,7 @@ fn trans_def_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n pub fn trans_def_fn_unadjusted<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                          ref_expr: &ast::Expr,\n                                          def: def::Def,\n-                                         param_substs: &'tcx subst::Substs<'tcx>)\n+                                         param_substs: &'tcx Substs<'tcx>)\n                                          -> Datum<'tcx, Rvalue> {\n     let _icx = push_ctxt(\"trans_def_datum_unadjusted\");\n \n@@ -1937,6 +2019,7 @@ fn float_cast(bcx: Block,\n #[derive(Copy, Clone, PartialEq, Debug)]\n pub enum cast_kind {\n     cast_pointer,\n+    cast_fat_ptr,\n     cast_integral,\n     cast_float,\n     cast_enum,\n@@ -1951,7 +2034,7 @@ pub fn cast_type_kind<'tcx>(tcx: &ty::ctxt<'tcx>, t: Ty<'tcx>) -> cast_kind {\n             if type_is_sized(tcx, mt.ty) {\n                 cast_pointer\n             } else {\n-                cast_other\n+                cast_fat_ptr\n             }\n         }\n         ty::ty_bare_fn(..) => cast_pointer,\n@@ -2027,10 +2110,18 @@ fn trans_imm_cast<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             let llexpr = datum.to_llscalarish(bcx);\n             PtrToInt(bcx, llexpr, ll_t_out)\n         }\n+        (cast_fat_ptr, cast_integral) => {\n+            let data_ptr = Load(bcx, get_dataptr(bcx, datum.val));\n+            PtrToInt(bcx, data_ptr, ll_t_out)\n+        }\n         (cast_pointer, cast_pointer) => {\n             let llexpr = datum.to_llscalarish(bcx);\n             PointerCast(bcx, llexpr, ll_t_out)\n         }\n+        (cast_fat_ptr, cast_pointer) => {\n+            let data_ptr = Load(bcx, get_dataptr(bcx, datum.val));\n+            PointerCast(bcx, data_ptr, ll_t_out)\n+        }\n         (cast_enum, cast_integral) |\n         (cast_enum, cast_float) => {\n             let mut bcx = bcx;"}, {"sha": "264957d36513b9ecd19b8fc485b4e5486d036200", "filename": "src/librustc_trans/trans/glue.rs", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/fa433875274ff4a7c4cab7d87c1284ba782ef643/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa433875274ff4a7c4cab7d87c1284ba782ef643/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fglue.rs?ref=fa433875274ff4a7c4cab7d87c1284ba782ef643", "patch": "@@ -278,18 +278,14 @@ fn get_drop_glue_core<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n fn trans_struct_drop_flag<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                                       t: Ty<'tcx>,\n-                                      v0: ValueRef,\n+                                      struct_data: ValueRef,\n                                       dtor_did: ast::DefId,\n                                       class_did: ast::DefId,\n                                       substs: &subst::Substs<'tcx>)\n                                       -> Block<'blk, 'tcx> {\n+    assert!(type_is_sized(bcx.tcx(), t), \"Precondition: caller must ensure t is sized\");\n+\n     let repr = adt::represent_type(bcx.ccx(), t);\n-    let struct_data = if type_is_sized(bcx.tcx(), t) {\n-        v0\n-    } else {\n-        let llval = GEPi(bcx, v0, &[0, abi::FAT_PTR_ADDR]);\n-        Load(bcx, llval)\n-    };\n     let drop_flag = unpack_datum!(bcx, adt::trans_drop_flag_ptr(bcx, &*repr, struct_data));\n     let loaded = load_ty(bcx, drop_flag.val, bcx.tcx().dtor_type());\n     let drop_flag_llty = type_of(bcx.fcx.ccx, bcx.tcx().dtor_type());\n@@ -313,9 +309,8 @@ fn trans_struct_drop_flag<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n \n     let drop_flag_dtor_needed = ICmp(bcx, llvm::IntEQ, loaded, init_val, DebugLoc::None);\n     with_cond(bcx, drop_flag_dtor_needed, |cx| {\n-        trans_struct_drop(cx, t, v0, dtor_did, class_did, substs)\n+        trans_struct_drop(cx, t, struct_data, dtor_did, class_did, substs)\n     })\n-\n }\n \n pub fn get_res_dtor<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n@@ -392,8 +387,8 @@ fn trans_struct_drop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     bcx.fcx.pop_and_trans_custom_cleanup_scope(bcx, contents_scope)\n }\n \n-fn size_and_align_of_dst<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, t: Ty<'tcx>, info: ValueRef)\n-                                     -> (ValueRef, ValueRef) {\n+pub fn size_and_align_of_dst<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, t: Ty<'tcx>, info: ValueRef)\n+                                         -> (ValueRef, ValueRef) {\n     debug!(\"calculate size of DST: {}; with lost info: {}\",\n            bcx.ty_to_string(t), bcx.val_to_string(info));\n     if type_is_sized(bcx.tcx(), t) {"}, {"sha": "951d30c4fb8db3fab13d3c25fcd958f5addee67d", "filename": "src/librustc_trans/trans/intrinsic.rs", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/fa433875274ff4a7c4cab7d87c1284ba782ef643/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa433875274ff4a7c4cab7d87c1284ba782ef643/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs?ref=fa433875274ff4a7c4cab7d87c1284ba782ef643", "patch": "@@ -326,10 +326,31 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n             let lltp_ty = type_of::type_of(ccx, tp_ty);\n             C_uint(ccx, machine::llsize_of_alloc(ccx, lltp_ty))\n         }\n+        (_, \"size_of_val\") => {\n+            let tp_ty = *substs.types.get(FnSpace, 0);\n+            if !type_is_sized(tcx, tp_ty) {\n+                let info = Load(bcx, expr::get_len(bcx, llargs[0]));\n+                let (llsize, _) = glue::size_and_align_of_dst(bcx, tp_ty, info);\n+                llsize\n+            } else {\n+                let lltp_ty = type_of::type_of(ccx, tp_ty);\n+                C_uint(ccx, machine::llsize_of_alloc(ccx, lltp_ty))\n+            }\n+        }\n         (_, \"min_align_of\") => {\n             let tp_ty = *substs.types.get(FnSpace, 0);\n             C_uint(ccx, type_of::align_of(ccx, tp_ty))\n         }\n+        (_, \"min_align_of_val\") => {\n+            let tp_ty = *substs.types.get(FnSpace, 0);\n+            if !type_is_sized(tcx, tp_ty) {\n+                let info = Load(bcx, expr::get_len(bcx, llargs[0]));\n+                let (_, llalign) = glue::size_and_align_of_dst(bcx, tp_ty, info);\n+                llalign\n+            } else {\n+                C_uint(ccx, type_of::align_of(ccx, tp_ty))\n+            }\n+        }\n         (_, \"pref_align_of\") => {\n             let tp_ty = *substs.types.get(FnSpace, 0);\n             let lltp_ty = type_of::type_of(ccx, tp_ty);\n@@ -351,6 +372,11 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n             bcx = src.store_to(bcx, llargs[0]);\n             C_nil(ccx)\n         }\n+        (_, \"drop_in_place\") => {\n+            let tp_ty = *substs.types.get(FnSpace, 0);\n+            glue::drop_ty(bcx, llargs[0], tp_ty, call_debug_location);\n+            C_nil(ccx)\n+        }\n         (_, \"type_name\") => {\n             let tp_ty = *substs.types.get(FnSpace, 0);\n             let ty_name = token::intern_and_get_ident(&ty_to_string(ccx.tcx(), tp_ty));"}, {"sha": "39bc547a1a764d40cb42123b2df0c522efead0cf", "filename": "src/librustc_trans/trans/machine.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fa433875274ff4a7c4cab7d87c1284ba782ef643/src%2Flibrustc_trans%2Ftrans%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa433875274ff4a7c4cab7d87c1284ba782ef643/src%2Flibrustc_trans%2Ftrans%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmachine.rs?ref=fa433875274ff4a7c4cab7d87c1284ba782ef643", "patch": "@@ -101,7 +101,8 @@ pub fn llalign_of_min(cx: &CrateContext, ty: Type) -> llalign {\n \n pub fn llelement_offset(cx: &CrateContext, struct_ty: Type, element: usize) -> u64 {\n     unsafe {\n-        return llvm::LLVMOffsetOfElement(cx.td().lltd, struct_ty.to_ref(),\n+        return llvm::LLVMOffsetOfElement(cx.td().lltd,\n+                                         struct_ty.to_ref(),\n                                          element as u32);\n     }\n }"}, {"sha": "bc6159c0cff3003f9ca791a346ed76d7505f5de9", "filename": "src/librustc_typeck/check/cast.rs", "status": "modified", "additions": 34, "deletions": 30, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/fa433875274ff4a7c4cab7d87c1284ba782ef643/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa433875274ff4a7c4cab7d87c1284ba782ef643/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs?ref=fa433875274ff4a7c4cab7d87c1284ba782ef643", "patch": "@@ -60,28 +60,29 @@ pub fn check_cast<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>, cast: &CastCheck<'tcx>) {\n     let e = &cast.expr;\n     let t_e = structurally_resolved_type(fcx, span, cast.expr_ty);\n     let t_1 = structurally_resolved_type(fcx, span, cast.cast_ty);\n+    let tcx = fcx.tcx();\n \n     // Check for trivial casts.\n     if !ty::type_has_ty_infer(t_1) {\n         if let Ok(()) = coercion::mk_assignty(fcx, e, t_e, t_1) {\n             if ty::type_is_numeric(t_1) && ty::type_is_numeric(t_e) {\n-                fcx.tcx().sess.add_lint(lint::builtin::TRIVIAL_NUMERIC_CASTS,\n-                                        e.id,\n-                                        span,\n-                                        format!(\"trivial numeric cast: `{}` as `{}`. Cast can be \\\n-                                                 replaced by coercion, this might require type \\\n-                                                 ascription or a temporary variable\",\n-                                                fcx.infcx().ty_to_string(t_e),\n-                                                fcx.infcx().ty_to_string(t_1)));\n+                tcx.sess.add_lint(lint::builtin::TRIVIAL_NUMERIC_CASTS,\n+                                  e.id,\n+                                  span,\n+                                  format!(\"trivial numeric cast: `{}` as `{}`. Cast can be \\\n+                                           replaced by coercion, this might require type \\\n+                                           ascription or a temporary variable\",\n+                                          fcx.infcx().ty_to_string(t_e),\n+                                          fcx.infcx().ty_to_string(t_1)));\n             } else {\n-                fcx.tcx().sess.add_lint(lint::builtin::TRIVIAL_CASTS,\n-                                        e.id,\n-                                        span,\n-                                        format!(\"trivial cast: `{}` as `{}`. Cast can be \\\n-                                                 replaced by coercion, this might require type \\\n-                                                 ascription or a temporary variable\",\n-                                                fcx.infcx().ty_to_string(t_e),\n-                                                fcx.infcx().ty_to_string(t_1)));\n+                tcx.sess.add_lint(lint::builtin::TRIVIAL_CASTS,\n+                                  e.id,\n+                                  span,\n+                                  format!(\"trivial cast: `{}` as `{}`. Cast can be \\\n+                                           replaced by coercion, this might require type \\\n+                                           ascription or a temporary variable\",\n+                                          fcx.infcx().ty_to_string(t_e),\n+                                          fcx.infcx().ty_to_string(t_1)));\n             }\n             return;\n         }\n@@ -91,14 +92,15 @@ pub fn check_cast<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>, cast: &CastCheck<'tcx>) {\n     let t_e_is_scalar = ty::type_is_scalar(t_e);\n     let t_e_is_integral = ty::type_is_integral(t_e);\n     let t_e_is_float = ty::type_is_floating_point(t_e);\n-    let t_e_is_c_enum = ty::type_is_c_like_enum(fcx.tcx(), t_e);\n+    let t_e_is_c_enum = ty::type_is_c_like_enum(tcx, t_e);\n \n     let t_1_is_scalar = ty::type_is_scalar(t_1);\n     let t_1_is_integral = ty::type_is_integral(t_1);\n     let t_1_is_char = ty::type_is_char(t_1);\n     let t_1_is_bare_fn = ty::type_is_bare_fn(t_1);\n     let t_1_is_float = ty::type_is_floating_point(t_1);\n-    let t_1_is_c_enum = ty::type_is_c_like_enum(fcx.tcx(), t_1);\n+    let t_1_is_c_enum = ty::type_is_c_like_enum(tcx, t_1);\n+    let t1_is_fat_ptr = fcx.type_is_fat_ptr(t_1, span);\n \n     // casts to scalars other than `char` and `bare fn` are trivial\n     let t_1_is_trivial = t_1_is_scalar && !t_1_is_char && !t_1_is_bare_fn;\n@@ -113,7 +115,7 @@ pub fn check_cast<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>, cast: &CastCheck<'tcx>) {\n             }, t_e, None);\n         }\n     } else if t_1.sty == ty::ty_bool {\n-        span_err!(fcx.tcx().sess, span, E0054,\n+        span_err!(tcx.sess, span, E0054,\n                   \"cannot cast as `bool`, compare with zero instead\");\n     } else if t_e_is_float && (t_1_is_scalar || t_1_is_c_enum) &&\n         !(t_1_is_integral || t_1_is_float) {\n@@ -170,18 +172,20 @@ pub fn check_cast<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>, cast: &CastCheck<'tcx>) {\n                 demand::coerce(fcx, e.span, t_1, &e);\n             }\n         }\n-    } else if fcx.type_is_fat_ptr(t_e, span) != fcx.type_is_fat_ptr(t_1, span) {\n-        fcx.type_error_message(span, |actual| {\n-            format!(\"illegal cast; cast to or from fat pointer: `{}` as `{}` \\\n-                     involving incompatible type.\",\n-                    actual, fcx.infcx().ty_to_string(t_1))\n-        }, t_e, None);\n+    } else if t1_is_fat_ptr {\n+        // FIXME This should be allowed where the lefthandside is also a fat\n+        // pointer and is the same kind of fat pointer, i.e., array to array,\n+        // trait object to trait object. That is a bit looser than the current\n+        // rquirement that they are pointers to the same type.\n+        if !(fcx.type_is_fat_ptr(t_e, span) &&\n+             ty::deref(t_1, true).unwrap().ty == ty::deref(t_e, true).unwrap().ty) {\n+            fcx.type_error_message(span, |actual| {\n+                format!(\"cast to fat pointer: `{}` as `{}`\",\n+                        actual,\n+                        fcx.infcx().ty_to_string(t_1))\n+            }, t_e, None);\n+        }\n     } else if !(t_e_is_scalar && t_1_is_trivial) {\n-        /*\n-        If more type combinations should be supported than are\n-        supported here, then file an enhancement issue and\n-        record the issue number in this comment.\n-        */\n         fcx.type_error_message(span, |actual| {\n             format!(\"non-scalar cast: `{}` as `{}`\",\n                     actual,"}, {"sha": "dd63a512ae39305f20e4fc8f362fb44a74bfa8d2", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 94, "deletions": 174, "changes": 268, "blob_url": "https://github.com/rust-lang/rust/blob/fa433875274ff4a7c4cab7d87c1284ba782ef643/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa433875274ff4a7c4cab7d87c1284ba782ef643/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=fa433875274ff4a7c4cab7d87c1284ba782ef643", "patch": "@@ -61,25 +61,24 @@\n //! we may want to adjust precisely when coercions occur.\n \n use check::{autoderef, FnCtxt, NoPreference, PreferMutLvalue, UnresolvedTypeAction};\n-use check::vtable;\n \n use middle::infer::{self, Coercion};\n-use middle::subst;\n-use middle::traits;\n+use middle::traits::{self, ObligationCause};\n+use middle::traits::{predicate_for_trait_def, report_selection_error};\n use middle::ty::{AutoDerefRef, AdjustDerefRef};\n use middle::ty::{self, mt, Ty};\n use middle::ty_relate::RelateResult;\n use util::common::indent;\n-use util::ppaux;\n use util::ppaux::Repr;\n \n-use std::cell::Cell;\n+use std::cell::RefCell;\n+use std::collections::VecDeque;\n use syntax::ast;\n \n struct Coerce<'a, 'tcx: 'a> {\n     fcx: &'a FnCtxt<'a, 'tcx>,\n     origin: infer::TypeOrigin,\n-    unsizing_obligation: Cell<Option<Ty<'tcx>>>\n+    unsizing_obligations: RefCell<Vec<traits::PredicateObligation<'tcx>>>,\n }\n \n type CoerceResult<'tcx> = RelateResult<'tcx, Option<ty::AutoAdjustment<'tcx>>>;\n@@ -94,15 +93,6 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n         Ok(None) // No coercion required.\n     }\n \n-    fn outlives(&self,\n-                origin: infer::SubregionOrigin<'tcx>,\n-                a: ty::Region,\n-                b: ty::Region)\n-                -> RelateResult<'tcx, ()> {\n-        infer::mk_subr(self.fcx.infcx(), origin, b, a);\n-        Ok(())\n-    }\n-\n     fn unpack_actual_value<T, F>(&self, a: Ty<'tcx>, f: F) -> T where\n         F: FnOnce(Ty<'tcx>) -> T,\n     {\n@@ -248,51 +238,100 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n     // or &mut [T, ..n] -> &mut [T]\n     // or &Concrete -> &Trait, etc.\n     fn coerce_unsized(&self,\n-                      a: Ty<'tcx>,\n-                      b: Ty<'tcx>)\n+                      source: Ty<'tcx>,\n+                      target: Ty<'tcx>)\n                       -> CoerceResult<'tcx> {\n-        debug!(\"coerce_unsized(a={}, b={})\",\n-               a.repr(self.tcx()),\n-               b.repr(self.tcx()));\n+        debug!(\"coerce_unsized(source={}, target={})\",\n+               source.repr(self.tcx()),\n+               target.repr(self.tcx()));\n+\n+        let traits = (self.tcx().lang_items.unsize_trait(),\n+                      self.tcx().lang_items.coerce_unsized_trait());\n+        let (unsize_did, coerce_unsized_did) = if let (Some(u), Some(cu)) = traits {\n+            (u, cu)\n+        } else {\n+            debug!(\"Missing Unsize or CoerceUnsized traits\");\n+            return Err(ty::terr_mismatch);\n+        };\n \n         // Note, we want to avoid unnecessary unsizing. We don't want to coerce to\n         // a DST unless we have to. This currently comes out in the wash since\n         // we can't unify [T] with U. But to properly support DST, we need to allow\n-        // that, at which point we will need extra checks on b here.\n+        // that, at which point we will need extra checks on the target here.\n \n-        let (reborrow, target) = match (&a.sty, &b.sty) {\n+        // Handle reborrows before selecting `Source: CoerceUnsized<Target>`.\n+        let (source, reborrow) = match (&source.sty, &target.sty) {\n             (&ty::ty_rptr(_, mt_a), &ty::ty_rptr(_, mt_b)) => {\n-                if let Some(target) = self.unsize_ty(mt_a.ty, mt_b.ty) {\n-                    try!(coerce_mutbls(mt_a.mutbl, mt_b.mutbl));\n-\n-                    let coercion = Coercion(self.origin.span());\n-                    let r_borrow = self.fcx.infcx().next_region_var(coercion);\n-                    let region = self.tcx().mk_region(r_borrow);\n-                    (Some(ty::AutoPtr(region, mt_b.mutbl)), target)\n-                } else {\n-                    return Err(ty::terr_mismatch);\n-                }\n+                try!(coerce_mutbls(mt_a.mutbl, mt_b.mutbl));\n+\n+                let coercion = Coercion(self.origin.span());\n+                let r_borrow = self.fcx.infcx().next_region_var(coercion);\n+                let region = self.tcx().mk_region(r_borrow);\n+                (mt_a.ty, Some(ty::AutoPtr(region, mt_b.mutbl)))\n             }\n             (&ty::ty_rptr(_, mt_a), &ty::ty_ptr(mt_b)) => {\n-                if let Some(target) = self.unsize_ty(mt_a.ty, mt_b.ty) {\n-                    try!(coerce_mutbls(mt_a.mutbl, mt_b.mutbl));\n-                    (Some(ty::AutoUnsafe(mt_b.mutbl)), target)\n-                } else {\n-                    return Err(ty::terr_mismatch);\n-                }\n+                try!(coerce_mutbls(mt_a.mutbl, mt_b.mutbl));\n+                (mt_a.ty, Some(ty::AutoUnsafe(mt_b.mutbl)))\n             }\n-            (&ty::ty_uniq(t_a), &ty::ty_uniq(t_b)) => {\n-                if let Some(target) = self.unsize_ty(t_a, t_b) {\n-                    (None, ty::mk_uniq(self.tcx(), target))\n-                } else {\n+            _ => (source, None)\n+        };\n+        let source = ty::adjust_ty_for_autoref(self.tcx(), source, reborrow);\n+\n+        let mut selcx = traits::SelectionContext::new(self.fcx.infcx(), self.fcx);\n+\n+        // Use a FIFO queue for this custom fulfillment procedure.\n+        let mut queue = VecDeque::new();\n+        let mut leftover_predicates = vec![];\n+\n+        // Create an obligation for `Source: CoerceUnsized<Target>`.\n+        let cause = ObligationCause::misc(self.origin.span(), self.fcx.body_id);\n+        queue.push_back(predicate_for_trait_def(self.tcx(),\n+                                                cause,\n+                                                coerce_unsized_did,\n+                                                0,\n+                                                source,\n+                                                vec![target]));\n+\n+        // Keep resolving `CoerceUnsized` and `Unsize` predicates to avoid\n+        // emitting a coercion in cases like `Foo<$1>` -> `Foo<$2>`, where\n+        // inference might unify those two inner type variables later.\n+        let traits = [coerce_unsized_did, unsize_did];\n+        while let Some(obligation) = queue.pop_front() {\n+            debug!(\"coerce_unsized resolve step: {}\", obligation.repr(self.tcx()));\n+            let trait_ref =  match obligation.predicate {\n+                ty::Predicate::Trait(ref tr) if traits.contains(&tr.def_id()) => {\n+                    tr.clone()\n+                }\n+                _ => {\n+                    leftover_predicates.push(obligation);\n+                    continue;\n+                }\n+            };\n+            match selcx.select(&obligation.with(trait_ref)) {\n+                // Uncertain or unimplemented.\n+                Ok(None) | Err(traits::Unimplemented) => {\n+                    debug!(\"coerce_unsized: early return - can't prove obligation\");\n                     return Err(ty::terr_mismatch);\n                 }\n+\n+                // Object safety violations or miscellaneous.\n+                Err(err) => {\n+                    report_selection_error(self.fcx.infcx(), &obligation, &err);\n+                    // Treat this like an obligation and follow through\n+                    // with the unsizing - the lack of a coercion should\n+                    // be silent, as it causes a type mismatch later.\n+                }\n+\n+                Ok(Some(vtable)) => {\n+                    vtable.map_move_nested(|o| queue.push_back(o));\n+                }\n             }\n-            _ => return Err(ty::terr_mismatch)\n-        };\n+        }\n+\n+        let mut obligations = self.unsizing_obligations.borrow_mut();\n+        assert!(obligations.is_empty());\n+        *obligations = leftover_predicates;\n \n-        let target = ty::adjust_ty_for_autoref(self.tcx(), target, reborrow);\n-        try!(self.subtype(target, b));\n         let adjustment = AutoDerefRef {\n             autoderefs: if reborrow.is_some() { 1 } else { 0 },\n             autoref: reborrow,\n@@ -302,108 +341,6 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n         Ok(Some(AdjustDerefRef(adjustment)))\n     }\n \n-    // Takes a type and returns an unsized version.\n-    // E.g., `[T, ..n]` -> `[T]`.\n-    fn unsize_ty(&self,\n-                 ty_a: Ty<'tcx>,\n-                 ty_b: Ty<'tcx>)\n-                 -> Option<Ty<'tcx>> {\n-        let tcx = self.tcx();\n-\n-        self.unpack_actual_value(ty_a, |a| self.unpack_actual_value(ty_b, |b| {\n-            debug!(\"unsize_ty(a={}, b={})\", a.repr(self.tcx()), b.repr(self.tcx()));\n-            match (&a.sty, &b.sty) {\n-                (&ty::ty_vec(t_a, Some(_)), &ty::ty_vec(_, None)) => {\n-                    Some(ty::mk_vec(tcx, t_a, None))\n-                }\n-                (&ty::ty_trait(ref data_a), &ty::ty_trait(ref data_b)) => {\n-                    // Upcasts permit two things:\n-                    //\n-                    // 1. Dropping builtin bounds, e.g. `Foo+Send` to `Foo`\n-                    // 2. Tightening the region bound, e.g. `Foo+'a` to `Foo+'b` if `'a : 'b`\n-                    //\n-                    // Note that neither of these changes requires any\n-                    // change at runtime.  Eventually this will be\n-                    // generalized.\n-                    //\n-                    // We always upcast when we can because of reason\n-                    // #2 (region bounds).\n-                    if data_a.bounds.builtin_bounds.is_superset(&data_b.bounds.builtin_bounds) {\n-                        // construct a type `a1` which is a version of\n-                        // `a` using the upcast bounds from `b`\n-                        let bounds_a1 = ty::ExistentialBounds {\n-                            // From type b\n-                            region_bound: data_b.bounds.region_bound,\n-                            builtin_bounds: data_b.bounds.builtin_bounds,\n-\n-                            // From type a\n-                            projection_bounds: data_a.bounds.projection_bounds.clone(),\n-                        };\n-                        let ty_a1 = ty::mk_trait(tcx, data_a.principal.clone(), bounds_a1);\n-\n-                        // relate `a1` to `b`\n-                        let result = self.fcx.infcx().commit_if_ok(|_| {\n-                            // it's ok to upcast from Foo+'a to Foo+'b so long as 'a : 'b\n-                            try!(self.outlives(infer::RelateObjectBound(self.origin.span()),\n-                                               data_a.bounds.region_bound,\n-                                               data_b.bounds.region_bound));\n-                            self.subtype(ty_a1, ty_b)\n-                        });\n-\n-                        // if that was successful, we have a coercion\n-                        match result {\n-                            Ok(_) => Some(ty_b),\n-                            Err(_) => None,\n-                        }\n-                    } else {\n-                        None\n-                    }\n-                }\n-                (_, &ty::ty_trait(_)) => {\n-                    assert!(self.unsizing_obligation.get().is_none());\n-                    self.unsizing_obligation.set(Some(a));\n-                    Some(ty_b)\n-                }\n-                (&ty::ty_struct(did_a, substs_a), &ty::ty_struct(did_b, substs_b))\n-                  if did_a == did_b => {\n-                    debug!(\"unsizing a struct\");\n-                    // Try unsizing each type param in turn to see if we end up with ty_b.\n-                    let ty_substs_a = substs_a.types.get_slice(subst::TypeSpace);\n-                    let ty_substs_b = substs_b.types.get_slice(subst::TypeSpace);\n-                    assert!(ty_substs_a.len() == ty_substs_b.len());\n-\n-                    let tps = ty_substs_a.iter().zip(ty_substs_b.iter()).enumerate();\n-                    for (i, (tp_a, tp_b)) in tps {\n-                        if self.subtype(*tp_a, *tp_b).is_ok() {\n-                            continue;\n-                        }\n-                        if let Some(new_tp) = self.unsize_ty(tp_a, tp_b) {\n-                            // Check that the whole types match.\n-                            let mut new_substs = substs_a.clone();\n-                            new_substs.types.get_mut_slice(subst::TypeSpace)[i] = new_tp;\n-                            let ty = ty::mk_struct(tcx, did_a, tcx.mk_substs(new_substs));\n-                            if self.subtype(ty, ty_b).is_err() {\n-                                debug!(\"Unsized type parameter '{}', but still \\\n-                                        could not match types {} and {}\",\n-                                        ppaux::ty_to_string(tcx, tp_a),\n-                                        ppaux::ty_to_string(tcx, ty),\n-                                        ppaux::ty_to_string(tcx, ty_b));\n-                                // We can only unsize a single type parameter, so\n-                                // if we unsize one and it doesn't give us the\n-                                // type we want, then we won't succeed later.\n-                                break;\n-                            }\n-\n-                            return Some(ty);\n-                        }\n-                    }\n-                    None\n-                }\n-                _ => None\n-            }\n-        }))\n-    }\n-\n     fn coerce_from_fn_pointer(&self,\n                            a: Ty<'tcx>,\n                            fn_ty_a: &'tcx ty::BareFnTy<'tcx>,\n@@ -496,41 +433,24 @@ pub fn mk_assignty<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                              b: Ty<'tcx>)\n                              -> RelateResult<'tcx, ()> {\n     debug!(\"mk_assignty({} -> {})\", a.repr(fcx.tcx()), b.repr(fcx.tcx()));\n-    let (adjustment, unsizing_obligation) = try!(indent(|| {\n+    let mut unsizing_obligations = vec![];\n+    let adjustment = try!(indent(|| {\n         fcx.infcx().commit_if_ok(|_| {\n             let coerce = Coerce {\n                 fcx: fcx,\n                 origin: infer::ExprAssignable(expr.span),\n-                unsizing_obligation: Cell::new(None)\n+                unsizing_obligations: RefCell::new(vec![])\n             };\n-            Ok((try!(coerce.coerce(expr, a, b)),\n-                coerce.unsizing_obligation.get()))\n+            let adjustment = try!(coerce.coerce(expr, a, b));\n+            unsizing_obligations = coerce.unsizing_obligations.into_inner();\n+            Ok(adjustment)\n         })\n     }));\n \n     if let Some(AdjustDerefRef(auto)) = adjustment {\n-        if let (Some(source), Some(target)) = (unsizing_obligation, auto.unsize) {\n-            let target = ty::deref(target, true)\n-                            .expect(\"coercion: unsizing got non-pointer target type\").ty;\n-            let target = ty::struct_tail(fcx.tcx(), target);\n-            if let ty::ty_trait(ref ty_trait) = target.sty {\n-                vtable::check_object_safety(fcx.tcx(), ty_trait, expr.span);\n-\n-                // If the type is `Foo+'a`, ensures that the type\n-                // being cast to `Foo+'a` implements `Foo`:\n-                vtable::register_object_cast_obligations(fcx,\n-                                                         expr.span,\n-                                                         ty_trait,\n-                                                         source);\n-\n-                // If the type is `Foo+'a`, ensures that the type\n-                // being cast to `Foo+'a` outlives `'a`:\n-                let cause = traits::ObligationCause {\n-                    span: expr.span,\n-                    body_id: fcx.body_id,\n-                    code: traits::ObjectCastObligation(source)\n-                };\n-                fcx.register_region_obligation(source, ty_trait.bounds.region_bound, cause);\n+        if auto.unsize.is_some() {\n+            for obligation in unsizing_obligations {\n+                fcx.register_predicate(obligation);\n             }\n         }\n     }"}, {"sha": "fb2ad444005c3d7225e20ff2d609bf6738a3feb5", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fa433875274ff4a7c4cab7d87c1284ba782ef643/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa433875274ff4a7c4cab7d87c1284ba782ef643/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=fa433875274ff4a7c4cab7d87c1284ba782ef643", "patch": "@@ -12,8 +12,6 @@\n \n use astconv::AstConv;\n use check::FnCtxt;\n-use check::vtable;\n-use check::vtable::select_new_fcx_obligations;\n use middle::def;\n use middle::privacy::{AllPublic, DependsOn, LastPrivate, LastMod};\n use middle::subst;\n@@ -233,7 +231,7 @@ pub fn lookup_in_trait_adjusted<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     // FIXME(#18653) -- Try to resolve obligations, giving us more\n     // typing information, which can sometimes be needed to avoid\n     // pathological region inference failures.\n-    vtable::select_new_fcx_obligations(fcx);\n+    fcx.select_new_obligations();\n \n     // Insert any adjustments needed (always an autoref of some mutability).\n     match self_expr {"}, {"sha": "554f3d4b5a0c7dad1be1e0ac98fdc0ff088d4f91", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 73, "deletions": 13, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/fa433875274ff4a7c4cab7d87c1284ba782ef643/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa433875274ff4a7c4cab7d87c1284ba782ef643/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=fa433875274ff4a7c4cab7d87c1284ba782ef643", "patch": "@@ -93,7 +93,7 @@ use middle::pat_util::{self, pat_id_map};\n use middle::privacy::{AllPublic, LastMod};\n use middle::region::{self, CodeExtent};\n use middle::subst::{self, Subst, Substs, VecPerParamSpace, ParamSpace, TypeSpace};\n-use middle::traits;\n+use middle::traits::{self, report_fulfillment_errors};\n use middle::ty::{FnSig, GenericPredicates, TypeScheme};\n use middle::ty::{Disr, ParamTy, ParameterEnvironment};\n use middle::ty::{self, HasProjectionTypes, RegionEscape, ToPolyTraitRef, Ty};\n@@ -129,7 +129,6 @@ use syntax::visit::{self, Visitor};\n mod assoc;\n pub mod dropck;\n pub mod _match;\n-pub mod vtable;\n pub mod writeback;\n pub mod regionck;\n pub mod coercion;\n@@ -525,9 +524,9 @@ fn check_bare_fn<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n             let fcx = check_fn(ccx, fn_ty.unsafety, fn_id, &fn_sig,\n                                decl, fn_id, body, &inh);\n \n-            vtable::select_all_fcx_obligations_and_apply_defaults(&fcx);\n+            fcx.select_all_obligations_and_apply_defaults();\n             upvar::closure_analyze_fn(&fcx, fn_id, decl, body);\n-            vtable::select_all_fcx_obligations_or_error(&fcx);\n+            fcx.select_all_obligations_or_error();\n             fcx.check_casts();\n             regionck::regionck_fn(&fcx, fn_id, fn_span, decl, body);\n             writeback::resolve_type_vars_in_fn(&fcx, decl, body);\n@@ -1290,7 +1289,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n \n         // If not, try resolving any new fcx obligations that have cropped up.\n-        vtable::select_new_fcx_obligations(self);\n+        self.select_new_obligations();\n         ty = self.infcx().resolve_type_vars_if_possible(&ty);\n         if !ty::type_has_ty_infer(ty) {\n             debug!(\"resolve_type_vars_if_possible: ty={}\", ty.repr(self.tcx()));\n@@ -1301,7 +1300,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // possible. This can help substantially when there are\n         // indirect dependencies that don't seem worth tracking\n         // precisely.\n-        vtable::select_fcx_obligations_where_possible(self);\n+        self.select_obligations_where_possible();\n         ty = self.infcx().resolve_type_vars_if_possible(&ty);\n \n         debug!(\"resolve_type_vars_if_possible: ty={}\", ty.repr(self.tcx()));\n@@ -1817,6 +1816,57 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         deferred_cast_checks.clear();\n     }\n+\n+    fn select_all_obligations_and_apply_defaults(&self) {\n+        debug!(\"select_all_obligations_and_apply_defaults\");\n+\n+        self.select_obligations_where_possible();\n+        self.default_type_parameters();\n+        self.select_obligations_where_possible();\n+    }\n+\n+    fn select_all_obligations_or_error(&self) {\n+        debug!(\"select_all_obligations_or_error\");\n+\n+        // upvar inference should have ensured that all deferred call\n+        // resolutions are handled by now.\n+        assert!(self.inh.deferred_call_resolutions.borrow().is_empty());\n+\n+        self.select_all_obligations_and_apply_defaults();\n+        let mut fulfillment_cx = self.inh.fulfillment_cx.borrow_mut();\n+        match fulfillment_cx.select_all_or_error(self.infcx(), self) {\n+            Ok(()) => { }\n+            Err(errors) => { report_fulfillment_errors(self.infcx(), &errors); }\n+        }\n+    }\n+\n+    /// Select as many obligations as we can at present.\n+    fn select_obligations_where_possible(&self) {\n+        match\n+            self.inh.fulfillment_cx\n+            .borrow_mut()\n+            .select_where_possible(self.infcx(), self)\n+        {\n+            Ok(()) => { }\n+            Err(errors) => { report_fulfillment_errors(self.infcx(), &errors); }\n+        }\n+    }\n+\n+    /// Try to select any fcx obligation that we haven't tried yet, in an effort\n+    /// to improve inference. You could just call\n+    /// `select_obligations_where_possible` except that it leads to repeated\n+    /// work.\n+    fn select_new_obligations(&self) {\n+        match\n+            self.inh.fulfillment_cx\n+            .borrow_mut()\n+            .select_new_obligations(self.infcx(), self)\n+        {\n+            Ok(()) => { }\n+            Err(errors) => { report_fulfillment_errors(self.infcx(), &errors); }\n+        }\n+    }\n+\n }\n \n impl<'a, 'tcx> RegionScope for FnCtxt<'a, 'tcx> {\n@@ -1880,11 +1930,7 @@ pub fn autoderef<'a, 'tcx, T, F>(fcx: &FnCtxt<'a, 'tcx>,\n     for autoderefs in 0..fcx.tcx().sess.recursion_limit.get() {\n         let resolved_t = match unresolved_type_action {\n             UnresolvedTypeAction::Error => {\n-                let resolved_t = structurally_resolved_type(fcx, sp, t);\n-                if ty::type_is_error(resolved_t) {\n-                    return (resolved_t, autoderefs, None);\n-                }\n-                resolved_t\n+                structurally_resolved_type(fcx, sp, t)\n             }\n             UnresolvedTypeAction::Ignore => {\n                 // We can continue even when the type cannot be resolved\n@@ -1894,6 +1940,9 @@ pub fn autoderef<'a, 'tcx, T, F>(fcx: &FnCtxt<'a, 'tcx>,\n                 fcx.resolve_type_vars_if_possible(t)\n             }\n         };\n+        if ty::type_is_error(resolved_t) {\n+            return (resolved_t, autoderefs, None);\n+        }\n \n         match should_stop(resolved_t, autoderefs) {\n             Some(x) => return (resolved_t, autoderefs, Some(x)),\n@@ -2263,7 +2312,7 @@ fn check_argument_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         // an \"opportunistic\" vtable resolution of any trait bounds on\n         // the call. This helps coercions.\n         if check_blocks {\n-            vtable::select_new_fcx_obligations(fcx);\n+            fcx.select_new_obligations();\n         }\n \n         // For variadic functions, we don't have a declared type for all of\n@@ -4059,7 +4108,7 @@ fn check_const_with_ty<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n \n     check_expr_with_hint(fcx, e, declty);\n     demand::coerce(fcx, e.span, declty, e);\n-    vtable::select_all_fcx_obligations_or_error(fcx);\n+    fcx.select_all_obligations_or_error();\n     fcx.check_casts();\n     regionck::regionck_expr(fcx, e);\n     writeback::resolve_type_vars_in_expr(fcx, e);\n@@ -4928,6 +4977,14 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &ast::ForeignItem) {\n             \"breakpoint\" => (0, Vec::new(), ty::mk_nil(tcx)),\n             \"size_of\" |\n             \"pref_align_of\" | \"min_align_of\" => (1, Vec::new(), ccx.tcx.types.usize),\n+            \"size_of_val\" |  \"min_align_of_val\" => {\n+                (1, vec![\n+                    ty::mk_imm_rptr(tcx,\n+                                    tcx.mk_region(ty::ReLateBound(ty::DebruijnIndex::new(1),\n+                                                                  ty::BrAnon(0))),\n+                                    param(ccx, 0))\n+                 ], ccx.tcx.types.usize)\n+            }\n             \"init\" | \"init_dropped\" => (1, Vec::new(), param(ccx, 0)),\n             \"uninit\" => (1, Vec::new(), param(ccx, 0)),\n             \"forget\" => (1, vec!( param(ccx, 0) ), ty::mk_nil(tcx)),\n@@ -4943,6 +5000,9 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &ast::ForeignItem) {\n                   ),\n                ty::mk_nil(tcx))\n             }\n+            \"drop_in_place\" => {\n+                (1, vec![ty::mk_mut_ptr(tcx, param(ccx, 0))], ty::mk_nil(tcx))\n+            }\n             \"needs_drop\" => (1, Vec::new(), ccx.tcx.types.bool),\n \n             \"type_name\" => (1, Vec::new(), ty::mk_str_slice(tcx, tcx.mk_region(ty::ReStatic),"}, {"sha": "090d111b62b898dde6acc1007c92c4ca647fddae", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fa433875274ff4a7c4cab7d87c1284ba782ef643/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa433875274ff4a7c4cab7d87c1284ba782ef643/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=fa433875274ff4a7c4cab7d87c1284ba782ef643", "patch": "@@ -85,7 +85,6 @@\n use astconv::AstConv;\n use check::dropck;\n use check::FnCtxt;\n-use check::vtable;\n use middle::free_region::FreeRegionMap;\n use middle::implicator;\n use middle::mem_categorization as mc;\n@@ -312,7 +311,7 @@ impl<'a, 'tcx> Rcx<'a, 'tcx> {\n         // region checking can introduce new pending obligations\n         // which, when processed, might generate new region\n         // obligations. So make sure we process those.\n-        vtable::select_all_fcx_obligations_or_error(self.fcx);\n+        self.fcx.select_all_obligations_or_error();\n \n         // Make a copy of the region obligations vec because we'll need\n         // to be able to borrow the fulfillment-cx below when projecting."}, {"sha": "a9094fce57c61e24f4c42a468d7dac9fa0ebd02f", "filename": "src/librustc_typeck/check/vtable.rs", "status": "removed", "additions": 0, "deletions": 186, "changes": 186, "blob_url": "https://github.com/rust-lang/rust/blob/30a42faa1c42ce5988241d3af993921246954b1a/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30a42faa1c42ce5988241d3af993921246954b1a/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs?ref=30a42faa1c42ce5988241d3af993921246954b1a", "patch": "@@ -1,186 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use check::FnCtxt;\n-use middle::traits::{self, ObjectSafetyViolation, MethodViolationCode};\n-use middle::traits::{Obligation, ObligationCause};\n-use middle::traits::report_fulfillment_errors;\n-use middle::ty::{self, Ty, AsPredicate};\n-use syntax::codemap::Span;\n-use util::ppaux::{Repr, UserString};\n-\n-\n-// Check that a trait is 'object-safe'. This should be checked whenever a trait object\n-// is created (by casting or coercion, etc.). A trait is object-safe if all its\n-// methods are object-safe. A trait method is object-safe if it does not take\n-// self by value, has no type parameters and does not use the `Self` type, except\n-// in self position.\n-pub fn check_object_safety<'tcx>(tcx: &ty::ctxt<'tcx>,\n-                                 object_trait: &ty::TyTrait<'tcx>,\n-                                 span: Span)\n-{\n-    let trait_def_id = object_trait.principal_def_id();\n-\n-    if traits::is_object_safe(tcx, trait_def_id) {\n-        return;\n-    }\n-\n-    span_err!(tcx.sess, span, E0038,\n-              \"cannot convert to a trait object because trait `{}` is not object-safe\",\n-              ty::item_path_str(tcx, trait_def_id));\n-\n-    let violations = traits::object_safety_violations(tcx, trait_def_id);\n-    for violation in violations {\n-        match violation {\n-            ObjectSafetyViolation::SizedSelf => {\n-                tcx.sess.span_note(\n-                    span,\n-                    \"the trait cannot require that `Self : Sized`\");\n-            }\n-\n-            ObjectSafetyViolation::SupertraitSelf => {\n-                tcx.sess.span_note(\n-                    span,\n-                    \"the trait cannot use `Self` as a type parameter \\\n-                     in the supertrait listing\");\n-            }\n-\n-            ObjectSafetyViolation::Method(method, MethodViolationCode::StaticMethod) => {\n-                tcx.sess.span_note(\n-                    span,\n-                    &format!(\"method `{}` has no receiver\",\n-                             method.name.user_string(tcx)));\n-            }\n-\n-            ObjectSafetyViolation::Method(method, MethodViolationCode::ReferencesSelf) => {\n-                tcx.sess.span_note(\n-                    span,\n-                    &format!(\"method `{}` references the `Self` type \\\n-                              in its arguments or return type\",\n-                             method.name.user_string(tcx)));\n-            }\n-\n-            ObjectSafetyViolation::Method(method, MethodViolationCode::Generic) => {\n-                tcx.sess.span_note(\n-                    span,\n-                    &format!(\"method `{}` has generic type parameters\",\n-                             method.name.user_string(tcx)));\n-            }\n-        }\n-    }\n-}\n-\n-pub fn register_object_cast_obligations<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n-                                                  span: Span,\n-                                                  object_trait: &ty::TyTrait<'tcx>,\n-                                                  referent_ty: Ty<'tcx>)\n-                                                  -> ty::PolyTraitRef<'tcx>\n-{\n-    // We can only make objects from sized types.\n-    fcx.register_builtin_bound(\n-        referent_ty,\n-        ty::BoundSized,\n-        traits::ObligationCause::new(span, fcx.body_id, traits::ObjectSized));\n-\n-    // This is just for better error reporting. Kinda goofy. The object type stuff\n-    // needs some refactoring so there is a more convenient type to pass around.\n-    let object_trait_ty =\n-        ty::mk_trait(fcx.tcx(),\n-                     object_trait.principal.clone(),\n-                     object_trait.bounds.clone());\n-\n-    debug!(\"register_object_cast_obligations: referent_ty={} object_trait_ty={}\",\n-           referent_ty.repr(fcx.tcx()),\n-           object_trait_ty.repr(fcx.tcx()));\n-\n-    let cause = ObligationCause::new(span,\n-                                     fcx.body_id,\n-                                     traits::ObjectCastObligation(object_trait_ty));\n-\n-    // Create the obligation for casting from T to Trait.\n-    let object_trait_ref =\n-        object_trait.principal_trait_ref_with_self_ty(fcx.tcx(), referent_ty);\n-    let object_obligation =\n-        Obligation::new(cause.clone(), object_trait_ref.as_predicate());\n-    fcx.register_predicate(object_obligation);\n-\n-    // Create additional obligations for all the various builtin\n-    // bounds attached to the object cast. (In other words, if the\n-    // object type is Foo+Send, this would create an obligation\n-    // for the Send check.)\n-    for builtin_bound in &object_trait.bounds.builtin_bounds {\n-        fcx.register_builtin_bound(\n-            referent_ty,\n-            builtin_bound,\n-            cause.clone());\n-    }\n-\n-    // Create obligations for the projection predicates.\n-    let projection_bounds =\n-        object_trait.projection_bounds_with_self_ty(fcx.tcx(), referent_ty);\n-    for projection_bound in &projection_bounds {\n-        let projection_obligation =\n-            Obligation::new(cause.clone(), projection_bound.as_predicate());\n-        fcx.register_predicate(projection_obligation);\n-    }\n-\n-    object_trait_ref\n-}\n-\n-pub fn select_all_fcx_obligations_and_apply_defaults(fcx: &FnCtxt) {\n-    debug!(\"select_all_fcx_obligations_and_apply_defaults\");\n-\n-    select_fcx_obligations_where_possible(fcx);\n-    fcx.default_type_parameters();\n-    select_fcx_obligations_where_possible(fcx);\n-}\n-\n-pub fn select_all_fcx_obligations_or_error(fcx: &FnCtxt) {\n-    debug!(\"select_all_fcx_obligations_or_error\");\n-\n-    // upvar inference should have ensured that all deferred call\n-    // resolutions are handled by now.\n-    assert!(fcx.inh.deferred_call_resolutions.borrow().is_empty());\n-\n-    select_all_fcx_obligations_and_apply_defaults(fcx);\n-    let mut fulfillment_cx = fcx.inh.fulfillment_cx.borrow_mut();\n-    let r = fulfillment_cx.select_all_or_error(fcx.infcx(), fcx);\n-    match r {\n-        Ok(()) => { }\n-        Err(errors) => { report_fulfillment_errors(fcx.infcx(), &errors); }\n-    }\n-}\n-\n-/// Select as many obligations as we can at present.\n-pub fn select_fcx_obligations_where_possible(fcx: &FnCtxt)\n-{\n-    match\n-        fcx.inh.fulfillment_cx\n-        .borrow_mut()\n-        .select_where_possible(fcx.infcx(), fcx)\n-    {\n-        Ok(()) => { }\n-        Err(errors) => { report_fulfillment_errors(fcx.infcx(), &errors); }\n-    }\n-}\n-\n-/// Try to select any fcx obligation that we haven't tried yet, in an effort to improve inference.\n-/// You could just call `select_fcx_obligations_where_possible` except that it leads to repeated\n-/// work.\n-pub fn select_new_fcx_obligations(fcx: &FnCtxt) {\n-    match\n-        fcx.inh.fulfillment_cx\n-        .borrow_mut()\n-        .select_new_obligations(fcx.infcx(), fcx)\n-    {\n-        Ok(()) => { }\n-        Err(errors) => { report_fulfillment_errors(fcx.infcx(), &errors); }\n-    }\n-}"}, {"sha": "79736c08f37967bb4a6cdf09d09b0362129c371f", "filename": "src/librustc_typeck/check/wf.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fa433875274ff4a7c4cab7d87c1284ba782ef643/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa433875274ff4a7c4cab7d87c1284ba782ef643/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs?ref=fa433875274ff4a7c4cab7d87c1284ba782ef643", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use astconv::AstConv;\n-use check::{FnCtxt, Inherited, blank_fn_ctxt, vtable, regionck};\n+use check::{FnCtxt, Inherited, blank_fn_ctxt, regionck};\n use constrained_type_params::{identify_constrained_type_params, Parameter};\n use CrateCtxt;\n use middle::region;\n@@ -151,7 +151,7 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n         let inh = Inherited::new(ccx.tcx, param_env);\n         let fcx = blank_fn_ctxt(ccx, &inh, ty::FnConverging(type_scheme.ty), item.id);\n         f(self, &fcx);\n-        vtable::select_all_fcx_obligations_or_error(&fcx);\n+        fcx.select_all_obligations_or_error();\n         regionck::regionck_item(&fcx, item);\n     }\n "}, {"sha": "58ad8ce86280d4f1aca04cea56bfa409dc1b9e09", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 159, "deletions": 2, "changes": 161, "blob_url": "https://github.com/rust-lang/rust/blob/fa433875274ff4a7c4cab7d87c1284ba782ef643/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa433875274ff4a7c4cab7d87c1284ba782ef643/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=fa433875274ff4a7c4cab7d87c1284ba782ef643", "patch": "@@ -16,7 +16,9 @@\n // mappings. That mapping code resides here.\n \n \n+use middle::lang_items::UnsizeTraitLangItem;\n use middle::subst::{self, Subst};\n+use middle::traits;\n use middle::ty::RegionEscape;\n use middle::ty::{ImplContainer, ImplOrTraitItemId, ConstTraitItemId};\n use middle::ty::{MethodTraitItemId, TypeTraitItemId, ParameterEnvironment};\n@@ -27,9 +29,9 @@ use middle::ty::{ty_str, ty_vec, ty_float, ty_infer, ty_int};\n use middle::ty::{ty_uint, ty_closure, ty_uniq, ty_bare_fn};\n use middle::ty::ty_projection;\n use middle::ty;\n+use middle::free_region::FreeRegionMap;\n use CrateCtxt;\n-use middle::infer::InferCtxt;\n-use middle::infer::new_infer_ctxt;\n+use middle::infer::{self, InferCtxt, new_infer_ctxt};\n use std::cell::RefCell;\n use std::rc::Rc;\n use syntax::ast::{Crate, DefId};\n@@ -133,6 +135,10 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n \n         // Check to make sure implementations of `Copy` are legal.\n         self.check_implementations_of_copy();\n+\n+        // Check to make sure implementations of `CoerceUnsized` are legal\n+        // and collect the necessary information from them.\n+        self.check_implementations_of_coerce_unsized();\n     }\n \n     fn check_implementation(&self, item: &Item, opt_trait: Option<&TraitRef>) {\n@@ -419,6 +425,157 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n             }\n         });\n     }\n+\n+    /// Process implementations of the built-in trait `CoerceUnsized`.\n+    fn check_implementations_of_coerce_unsized(&self) {\n+        let tcx = self.crate_context.tcx;\n+        let coerce_unsized_trait = match tcx.lang_items.coerce_unsized_trait() {\n+            Some(id) => id,\n+            None => return,\n+        };\n+        let unsize_trait = match tcx.lang_items.require(UnsizeTraitLangItem) {\n+            Ok(id) => id,\n+            Err(err) => {\n+                tcx.sess.fatal(&format!(\"`CoerceUnsized` implementation {}\", err));\n+            }\n+        };\n+\n+        let trait_def = ty::lookup_trait_def(tcx, coerce_unsized_trait);\n+\n+        trait_def.for_each_impl(tcx, |impl_did| {\n+            debug!(\"check_implementations_of_coerce_unsized: impl_did={}\",\n+                   impl_did.repr(tcx));\n+\n+            if impl_did.krate != ast::LOCAL_CRATE {\n+                debug!(\"check_implementations_of_coerce_unsized(): impl not \\\n+                        in this crate\");\n+                return;\n+            }\n+\n+            let source = ty::lookup_item_type(tcx, impl_did).ty;\n+            let trait_ref = ty::impl_id_to_trait_ref(self.crate_context.tcx,\n+                                                     impl_did.node);\n+            let target = *trait_ref.substs.types.get(subst::TypeSpace, 0);\n+            debug!(\"check_implementations_of_coerce_unsized: {} -> {} (bound)\",\n+                   source.repr(tcx), target.repr(tcx));\n+\n+            let span = tcx.map.span(impl_did.node);\n+            let param_env = ParameterEnvironment::for_item(tcx, impl_did.node);\n+            let source = source.subst(tcx, &param_env.free_substs);\n+            let target = target.subst(tcx, &param_env.free_substs);\n+            assert!(!source.has_escaping_regions());\n+\n+            debug!(\"check_implementations_of_coerce_unsized: {} -> {} (free)\",\n+                   source.repr(tcx), target.repr(tcx));\n+\n+            let infcx = new_infer_ctxt(tcx);\n+\n+            let check_mutbl = |mt_a: ty::mt<'tcx>, mt_b: ty::mt<'tcx>,\n+                               mk_ptr: &Fn(Ty<'tcx>) -> Ty<'tcx>| {\n+                if (mt_a.mutbl, mt_b.mutbl) == (ast::MutImmutable, ast::MutMutable) {\n+                    infcx.report_mismatched_types(span, mk_ptr(mt_b.ty),\n+                                                  target, &ty::terr_mutability);\n+                }\n+                (mt_a.ty, mt_b.ty, unsize_trait, None)\n+            };\n+            let (source, target, trait_def_id, kind) = match (&source.sty, &target.sty) {\n+                (&ty::ty_uniq(a), &ty::ty_uniq(b)) => (a, b, unsize_trait, None),\n+\n+                (&ty::ty_rptr(r_a, mt_a), &ty::ty_rptr(r_b, mt_b)) => {\n+                    infer::mk_subr(&infcx, infer::RelateObjectBound(span), *r_b, *r_a);\n+                    check_mutbl(mt_a, mt_b, &|ty| ty::mk_imm_rptr(tcx, r_b, ty))\n+                }\n+\n+                (&ty::ty_rptr(_, mt_a), &ty::ty_ptr(mt_b)) |\n+                (&ty::ty_ptr(mt_a), &ty::ty_ptr(mt_b)) => {\n+                    check_mutbl(mt_a, mt_b, &|ty| ty::mk_imm_ptr(tcx, ty))\n+                }\n+\n+                (&ty::ty_struct(def_id_a, substs_a), &ty::ty_struct(def_id_b, substs_b)) => {\n+                    if def_id_a != def_id_b {\n+                        let source_path = ty::item_path_str(tcx, def_id_a);\n+                        let target_path = ty::item_path_str(tcx, def_id_b);\n+                        span_err!(tcx.sess, span, E0377,\n+                                  \"the trait `CoerceUnsized` may only be implemented \\\n+                                   for a coercion between structures with the same \\\n+                                   definition; expected {}, found {}\",\n+                                  source_path, target_path);\n+                        return;\n+                    }\n+\n+                    let origin = infer::Misc(span);\n+                    let fields = ty::lookup_struct_fields(tcx, def_id_a);\n+                    let diff_fields = fields.iter().enumerate().filter_map(|(i, f)| {\n+                        let ty = ty::lookup_field_type_unsubstituted(tcx, def_id_a, f.id);\n+                        let (a, b) = (ty.subst(tcx, substs_a), ty.subst(tcx, substs_b));\n+                        if infcx.sub_types(false, origin, b, a).is_ok() {\n+                            None\n+                        } else {\n+                            Some((i, a, b))\n+                        }\n+                    }).collect::<Vec<_>>();\n+\n+                    if diff_fields.is_empty() {\n+                        span_err!(tcx.sess, span, E0374,\n+                                  \"the trait `CoerceUnsized` may only be implemented \\\n+                                   for a coercion between structures with one field \\\n+                                   being coerced, none found\");\n+                        return;\n+                    } else if diff_fields.len() > 1 {\n+                        span_err!(tcx.sess, span, E0375,\n+                                  \"the trait `CoerceUnsized` may only be implemented \\\n+                                   for a coercion between structures with one field \\\n+                                   being coerced, but {} fields need coercions: {}\",\n+                                   diff_fields.len(), diff_fields.iter().map(|&(i, a, b)| {\n+                                        let name = fields[i].name;\n+                                        format!(\"{} ({} to {})\",\n+                                                if name == token::special_names::unnamed_field {\n+                                                    i.to_string()\n+                                                } else {\n+                                                    token::get_name(name).to_string()\n+                                                },\n+                                                a.repr(tcx),\n+                                                b.repr(tcx))\n+                                   }).collect::<Vec<_>>().connect(\", \"));\n+                        return;\n+                    }\n+\n+                    let (i, a, b) = diff_fields[0];\n+                    let kind = ty::CustomCoerceUnsized::Struct(i);\n+                    (a, b, coerce_unsized_trait, Some(kind))\n+                }\n+\n+                _ => {\n+                    span_err!(tcx.sess, span, E0376,\n+                              \"the trait `CoerceUnsized` may only be implemented \\\n+                               for a coercion between structures\");\n+                    return;\n+                }\n+            };\n+\n+            let mut fulfill_cx = traits::FulfillmentContext::new();\n+\n+            // Register an obligation for `A: Trait<B>`.\n+            let cause = traits::ObligationCause::misc(span, impl_did.node);\n+            let predicate = traits::predicate_for_trait_def(tcx, cause, trait_def_id,\n+                                                            0, source, vec![target]);\n+            fulfill_cx.register_predicate_obligation(&infcx, predicate);\n+\n+            // Check that all transitive obligations are satisfied.\n+            if let Err(errors) = fulfill_cx.select_all_or_error(&infcx, &param_env) {\n+                traits::report_fulfillment_errors(&infcx, &errors);\n+            }\n+\n+            // Finally, resolve all regions.\n+            let mut free_regions = FreeRegionMap::new();\n+            free_regions.relate_free_regions_from_predicates(tcx, &param_env.caller_bounds);\n+            infcx.resolve_regions_and_report_errors(&free_regions, impl_did.node);\n+\n+            if let Some(kind) = kind {\n+                tcx.custom_coerce_unsized_kinds.borrow_mut().insert(impl_did, kind);\n+            }\n+        });\n+    }\n }\n \n fn enforce_trait_manually_implementable(tcx: &ty::ctxt, sp: Span, trait_def_id: ast::DefId) {"}, {"sha": "4c9fe6492e9ca530430ea1884d5b5532b781e087", "filename": "src/librustc_typeck/coherence/orphan.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fa433875274ff4a7c4cab7d87c1284ba782ef643/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa433875274ff4a7c4cab7d87c1284ba782ef643/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs?ref=fa433875274ff4a7c4cab7d87c1284ba782ef643", "patch": "@@ -316,12 +316,17 @@ impl<'cx, 'tcx> OrphanChecker<'cx, 'tcx> {\n                     }\n                 }\n \n-                // Disallow *all* explicit impls of `Sized` for now.\n+                // Disallow *all* explicit impls of `Sized` and `Unsize` for now.\n                 if Some(trait_def_id) == self.tcx.lang_items.sized_trait() {\n                     span_err!(self.tcx.sess, item.span, E0322,\n                               \"explicit impls for the `Sized` trait are not permitted\");\n                     return;\n                 }\n+                if Some(trait_def_id) == self.tcx.lang_items.unsize_trait() {\n+                    span_err!(self.tcx.sess, item.span, E0328,\n+                              \"explicit impls for the `Unsize` trait are not permitted\");\n+                    return;\n+                }\n             }\n             ast::ItemDefaultImpl(..) => {\n                 // \"Trait\" impl"}, {"sha": "8375061aa095b36e3993f50a50bd0abc29431d2f", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/fa433875274ff4a7c4cab7d87c1284ba782ef643/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa433875274ff4a7c4cab7d87c1284ba782ef643/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=fa433875274ff4a7c4cab7d87c1284ba782ef643", "patch": "@@ -309,7 +309,6 @@ register_diagnostics! {\n     E0034, // multiple applicable methods in scope\n     E0035, // does not take type parameters\n     E0036, // incorrect number of type parameters given for this method\n-    E0038, // cannot convert to a trait object because trait is not object-safe\n     E0040, // explicit use of destructor method\n     E0044, // foreign items may not have type parameters\n     E0045, // variadic function must have C calling convention\n@@ -445,10 +444,20 @@ register_diagnostics! {\n     E0325, // implemented an associated type when another trait item expected\n     E0326, // associated const implemented with different type from trait\n     E0327, // referred to method instead of constant in match pattern\n+    E0328, // cannot implement Unsize explicitly\n     E0366, // dropck forbid specialization to concrete type or region\n     E0367, // dropck forbid specialization to predicate not in struct/enum\n     E0368, // binary operation `<op>=` cannot be applied to types\n     E0369, // binary operation `<op>` cannot be applied to types\n     E0371, // impl Trait for Trait is illegal\n-    E0372  // impl Trait for Trait where Trait is not object safe\n+    E0372, // impl Trait for Trait where Trait is not object safe\n+    E0374, // the trait `CoerceUnsized` may only be implemented for a coercion\n+           // between structures with one field being coerced, none found\n+    E0375, // the trait `CoerceUnsized` may only be implemented for a coercion\n+           // between structures with one field being coerced, but multiple\n+           // fields need coercions\n+    E0376, // the trait `CoerceUnsized` may only be implemented for a coercion\n+           // between structures\n+    E0377  // the trait `CoerceUnsized` may only be implemented for a coercion\n+           // between structures with the same definition\n }"}, {"sha": "f9ed7c863d126c1adcaff76026772abbf5fcb730", "filename": "src/libstd/sync/mutex.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/fa433875274ff4a7c4cab7d87c1284ba782ef643/src%2Flibstd%2Fsync%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa433875274ff4a7c4cab7d87c1284ba782ef643/src%2Flibstd%2Fsync%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmutex.rs?ref=fa433875274ff4a7c4cab7d87c1284ba782ef643", "patch": "@@ -531,15 +531,16 @@ mod tests {\n         assert_eq!(*lock, 2);\n     }\n \n-    #[test]\n-    fn test_mutex_unsized() {\n-        let mutex: &Mutex<[i32]> = &Mutex::new([1, 2, 3]);\n-        {\n-            let b = &mut *mutex.lock().unwrap();\n-            b[0] = 4;\n-            b[2] = 5;\n-        }\n-        let comp: &[i32] = &[4, 2, 5];\n-        assert_eq!(&*mutex.lock().unwrap(), comp);\n-    }\n+    // FIXME(#25351) needs deeply nested coercions of DST structs.\n+    // #[test]\n+    // fn test_mutex_unsized() {\n+    //     let mutex: &Mutex<[i32]> = &Mutex::new([1, 2, 3]);\n+    //     {\n+    //         let b = &mut *mutex.lock().unwrap();\n+    //         b[0] = 4;\n+    //         b[2] = 5;\n+    //     }\n+    //     let comp: &[i32] = &[4, 2, 5];\n+    //     assert_eq!(&*mutex.lock().unwrap(), comp);\n+    // }\n }"}, {"sha": "36f6fbf3b72d53438d3878b035d2021a3b159e16", "filename": "src/libstd/sync/rwlock.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/fa433875274ff4a7c4cab7d87c1284ba782ef643/src%2Flibstd%2Fsync%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa433875274ff4a7c4cab7d87c1284ba782ef643/src%2Flibstd%2Fsync%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Frwlock.rs?ref=fa433875274ff4a7c4cab7d87c1284ba782ef643", "patch": "@@ -573,17 +573,18 @@ mod tests {\n         assert_eq!(*lock, 2);\n     }\n \n-    #[test]\n-    fn test_rwlock_unsized() {\n-        let rw: &RwLock<[i32]> = &RwLock::new([1, 2, 3]);\n-        {\n-            let b = &mut *rw.write().unwrap();\n-            b[0] = 4;\n-            b[2] = 5;\n-        }\n-        let comp: &[i32] = &[4, 2, 5];\n-        assert_eq!(&*rw.read().unwrap(), comp);\n-    }\n+    // FIXME(#25351) needs deeply nested coercions of DST structs.\n+    // #[test]\n+    // fn test_rwlock_unsized() {\n+    //     let rw: &RwLock<[i32]> = &RwLock::new([1, 2, 3]);\n+    //     {\n+    //         let b = &mut *rw.write().unwrap();\n+    //         b[0] = 4;\n+    //         b[2] = 5;\n+    //     }\n+    //     let comp: &[i32] = &[4, 2, 5];\n+    //     assert_eq!(&*rw.read().unwrap(), comp);\n+    // }\n \n     #[test]\n     fn test_rwlock_try_write() {"}, {"sha": "3f455e148a09be30fb0919dfd00f1279f3b0491e", "filename": "src/test/compile-fail/destructure-trait-ref.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa433875274ff4a7c4cab7d87c1284ba782ef643/src%2Ftest%2Fcompile-fail%2Fdestructure-trait-ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa433875274ff4a7c4cab7d87c1284ba782ef643/src%2Ftest%2Fcompile-fail%2Fdestructure-trait-ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdestructure-trait-ref.rs?ref=fa433875274ff4a7c4cab7d87c1284ba782ef643", "patch": "@@ -35,7 +35,7 @@ fn main() {\n     // n == m\n     let &x = &1 as &T;      //~ ERROR type `&T` cannot be dereferenced\n     let &&x = &(&1 as &T);  //~ ERROR type `&T` cannot be dereferenced\n-    let box x = box 1 as Box<T>; //~ ERROR type `Box<T>` cannot be dereferenced\n+    let box x = box 1 as Box<T>; //~ ERROR the trait `core::marker::Sized` is not implemented\n \n     // n > m\n     let &&x = &1 as &T;"}, {"sha": "b7a07e487994d41cce8463c2929ce00298bf7ced", "filename": "src/test/compile-fail/dst-bad-coercions.rs", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/fa433875274ff4a7c4cab7d87c1284ba782ef643/src%2Ftest%2Fcompile-fail%2Fdst-bad-coercions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa433875274ff4a7c4cab7d87c1284ba782ef643/src%2Ftest%2Fcompile-fail%2Fdst-bad-coercions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdst-bad-coercions.rs?ref=fa433875274ff4a7c4cab7d87c1284ba782ef643", "patch": "@@ -33,18 +33,4 @@ pub fn main() {\n     let x: &mut T = &S; //~ ERROR mismatched types\n     let x: *mut T = &S; //~ ERROR mismatched types\n     let x: *mut S = &S; //~ ERROR mismatched types\n-\n-    // The below four sets of tests test that we cannot implicitly deref a *-ptr\n-    // during a coercion.\n-    let x: *const S = &S;\n-    let y: *const T = x;  //~ ERROR mismatched types\n-\n-    let x: *mut S = &mut S;\n-    let y: *mut T = x;  //~ ERROR mismatched types\n-\n-    let x: *const Foo<S> = &Foo {f: S};\n-    let y: *const Foo<T> = x;  //~ ERROR mismatched types\n-\n-    let x: *mut Foo<S> = &mut Foo {f: S};\n-    let y: *mut Foo<T> = x;  //~ ERROR mismatched types\n }"}, {"sha": "2099424b05c281c1941d52ba8fe97ad10ae9299c", "filename": "src/test/compile-fail/fat-ptr-cast.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/fa433875274ff4a7c4cab7d87c1284ba782ef643/src%2Ftest%2Fcompile-fail%2Ffat-ptr-cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa433875274ff4a7c4cab7d87c1284ba782ef643/src%2Ftest%2Fcompile-fail%2Ffat-ptr-cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffat-ptr-cast.rs?ref=fa433875274ff4a7c4cab7d87c1284ba782ef643", "patch": "@@ -15,17 +15,13 @@ pub trait Trait {}\n fn main() {\n     let a: &[i32] = &[1, 2, 3];\n     let b: Box<[i32]> = Box::new([1, 2, 3]);\n-    let p = a as *const [i32];\n-    let q = a.as_ptr();\n \n-    a as usize; //~ ERROR illegal cast\n-    b as usize; //~ ERROR illegal cast\n-    p as usize; //~ ERROR illegal cast\n+    a as usize; //~ ERROR non-scalar cast\n+    b as usize; //~ ERROR non-scalar cast\n \n-    // #22955\n-    q as *const [i32]; //~ ERROR illegal cast\n+    let a: usize = 42;\n+    a as *const [i32]; //~ ERROR cast to fat pointer: `usize` as `*const [i32]`\n \n-    // #21397\n-    let t: *mut (Trait + 'static) = 0 as *mut _; //~ ERROR illegal cast\n-    let mut fail: *const str = 0 as *const str; //~ ERROR illegal cast\n+    let a: *const u8 = &42;\n+    a as *const [u8]; //~ ERROR cast to fat pointer: `*const u8` as `*const [u8]`\n }"}, {"sha": "7b84ba0343a33adccd780b05e0155d0a1c363359", "filename": "src/test/compile-fail/issue-19692.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa433875274ff4a7c4cab7d87c1284ba782ef643/src%2Ftest%2Fcompile-fail%2Fissue-19692.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa433875274ff4a7c4cab7d87c1284ba782ef643/src%2Ftest%2Fcompile-fail%2Fissue-19692.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-19692.rs?ref=fa433875274ff4a7c4cab7d87c1284ba782ef643", "patch": "@@ -12,7 +12,7 @@ struct Homura;\n \n fn akemi(homura: Homura) {\n     let Some(ref madoka) = Some(homura.kaname()); //~ ERROR does not implement any method\n-    madoka.clone();\n+    madoka.clone(); //~ ERROR the type of this value must be known in this context\n }\n \n fn main() { }"}, {"sha": "42fd856ad8784ee54766dd517208a7c8b2512362", "filename": "src/test/compile-fail/issue-20261.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fa433875274ff4a7c4cab7d87c1284ba782ef643/src%2Ftest%2Fcompile-fail%2Fissue-20261.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa433875274ff4a7c4cab7d87c1284ba782ef643/src%2Ftest%2Fcompile-fail%2Fissue-20261.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-20261.rs?ref=fa433875274ff4a7c4cab7d87c1284ba782ef643", "patch": "@@ -12,6 +12,5 @@ fn main() {\n     for (ref i,) in [].iter() { //~ ERROR: type mismatch resolving\n         i.clone();\n         //~^ ERROR: the type of this value must be known in this context\n-        //~| ERROR: reached the recursion limit while auto-dereferencing\n     }\n }"}, {"sha": "8b258180e830fb25822bf79b6ea70c5c6cda922f", "filename": "src/test/compile-fail/issue-22034.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fa433875274ff4a7c4cab7d87c1284ba782ef643/src%2Ftest%2Fcompile-fail%2Fissue-22034.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa433875274ff4a7c4cab7d87c1284ba782ef643/src%2Ftest%2Fcompile-fail%2Fissue-22034.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-22034.rs?ref=fa433875274ff4a7c4cab7d87c1284ba782ef643", "patch": "@@ -14,6 +14,7 @@ fn main() {\n     let ptr: *mut () = 0 as *mut _;\n     let _: &mut Fn() = unsafe {\n         &mut *(ptr as *mut Fn())\n-        //~^ ERROR illegal cast\n+        //~^ ERROR the trait `core::ops::Fn<()>` is not implemented\n+        //~| ERROR the trait `core::ops::FnOnce<()>` is not implemented\n     };\n }"}, {"sha": "1fdc87357143a6cbe55958a6634492dcacf06d8e", "filename": "src/test/compile-fail/issue-22289.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa433875274ff4a7c4cab7d87c1284ba782ef643/src%2Ftest%2Fcompile-fail%2Fissue-22289.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa433875274ff4a7c4cab7d87c1284ba782ef643/src%2Ftest%2Fcompile-fail%2Fissue-22289.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-22289.rs?ref=fa433875274ff4a7c4cab7d87c1284ba782ef643", "patch": "@@ -9,5 +9,5 @@\n // except according to those terms.\n \n fn main() {\n-    0 as &std::any::Any; //~ ERROR illegal cast\n+    0 as &std::any::Any; //~ ERROR cast to fat pointer: `i32` as `&core::any::Any`\n }"}, {"sha": "75ee0bdc9c7aed27de547fc41f3b50fbcb3a10be", "filename": "src/test/compile-fail/object-lifetime-default-elision.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa433875274ff4a7c4cab7d87c1284ba782ef643/src%2Ftest%2Fcompile-fail%2Fobject-lifetime-default-elision.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa433875274ff4a7c4cab7d87c1284ba782ef643/src%2Ftest%2Fcompile-fail%2Fobject-lifetime-default-elision.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fobject-lifetime-default-elision.rs?ref=fa433875274ff4a7c4cab7d87c1284ba782ef643", "patch": "@@ -81,7 +81,7 @@ fn load3<'a,'b>(ss: &'a SomeTrait) -> &'b SomeTrait {\n     // which fails to type check.\n \n     ss\n-        //~^ ERROR lifetime of the source pointer does not outlive lifetime bound\n+        //~^ ERROR lifetime bound not satisfied\n         //~| ERROR cannot infer\n }\n "}, {"sha": "dd94dfe1e0823463701bafc0f68dba06963dc831", "filename": "src/test/compile-fail/object-lifetime-default-from-box-error.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fa433875274ff4a7c4cab7d87c1284ba782ef643/src%2Ftest%2Fcompile-fail%2Fobject-lifetime-default-from-box-error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa433875274ff4a7c4cab7d87c1284ba782ef643/src%2Ftest%2Fcompile-fail%2Fobject-lifetime-default-from-box-error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fobject-lifetime-default-from-box-error.rs?ref=fa433875274ff4a7c4cab7d87c1284ba782ef643", "patch": "@@ -25,7 +25,7 @@ fn load(ss: &mut SomeStruct) -> Box<SomeTrait> {\n     // `Box<SomeTrait>` defaults to a `'static` bound, so this return\n     // is illegal.\n \n-    ss.r //~ ERROR lifetime of the source pointer does not outlive lifetime bound\n+    ss.r //~ ERROR lifetime bound not satisfied\n }\n \n fn store(ss: &mut SomeStruct, b: Box<SomeTrait>) {\n@@ -38,7 +38,7 @@ fn store(ss: &mut SomeStruct, b: Box<SomeTrait>) {\n fn store1<'b>(ss: &mut SomeStruct, b: Box<SomeTrait+'b>) {\n     // Here we override the lifetimes explicitly, and so naturally we get an error.\n \n-    ss.r = b; //~ ERROR lifetime of the source pointer does not outlive lifetime bound\n+    ss.r = b; //~ ERROR lifetime bound not satisfied\n }\n \n fn main() {"}, {"sha": "c5cf43e355d5aae777bef840103e56e29cf40c33", "filename": "src/test/compile-fail/regions-close-over-type-parameter-multiple.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa433875274ff4a7c4cab7d87c1284ba782ef643/src%2Ftest%2Fcompile-fail%2Fregions-close-over-type-parameter-multiple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa433875274ff4a7c4cab7d87c1284ba782ef643/src%2Ftest%2Fcompile-fail%2Fregions-close-over-type-parameter-multiple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-close-over-type-parameter-multiple.rs?ref=fa433875274ff4a7c4cab7d87c1284ba782ef643", "patch": "@@ -27,7 +27,7 @@ fn make_object_good2<'a,'b,A:SomeTrait+'a+'b>(v: A) -> Box<SomeTrait+'b> {\n \n fn make_object_bad<'a,'b,'c,A:SomeTrait+'a+'b>(v: A) -> Box<SomeTrait+'c> {\n     // A outlives 'a AND 'b...but not 'c.\n-    box v as Box<SomeTrait+'a> //~ ERROR lifetime of the source pointer does not outlive\n+    box v as Box<SomeTrait+'a> //~ ERROR lifetime bound not satisfied\n }\n \n fn main() {"}, {"sha": "b4e527972e4765b6339e457ed769e6ab1e844301", "filename": "src/test/compile-fail/regions-trait-object-subtyping.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa433875274ff4a7c4cab7d87c1284ba782ef643/src%2Ftest%2Fcompile-fail%2Fregions-trait-object-subtyping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa433875274ff4a7c4cab7d87c1284ba782ef643/src%2Ftest%2Fcompile-fail%2Fregions-trait-object-subtyping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-trait-object-subtyping.rs?ref=fa433875274ff4a7c4cab7d87c1284ba782ef643", "patch": "@@ -22,7 +22,7 @@ fn foo2<'a:'b,'b>(x: &'b mut (Dummy+'a)) -> &'b mut (Dummy+'b) {\n \n fn foo3<'a,'b>(x: &'a mut Dummy) -> &'b mut Dummy {\n     // Without knowing 'a:'b, we can't coerce\n-    x //~ ERROR lifetime of the source pointer does not outlive\n+    x //~ ERROR lifetime bound not satisfied\n      //~^ ERROR cannot infer\n }\n "}, {"sha": "aa28ae00e2772e4ffff21518b8f9cbe023bfad7d", "filename": "src/test/run-pass/dst-coerce-custom.rs", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/fa433875274ff4a7c4cab7d87c1284ba782ef643/src%2Ftest%2Frun-pass%2Fdst-coerce-custom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa433875274ff4a7c4cab7d87c1284ba782ef643/src%2Ftest%2Frun-pass%2Fdst-coerce-custom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdst-coerce-custom.rs?ref=fa433875274ff4a7c4cab7d87c1284ba782ef643", "patch": "@@ -0,0 +1,52 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test a very simple custom DST coercion.\n+\n+#![feature(core)]\n+\n+use std::ops::CoerceUnsized;\n+use std::marker::Unsize;\n+\n+struct Bar<T: ?Sized> {\n+    x: *const T,\n+}\n+\n+impl<T: ?Sized+Unsize<U>, U: ?Sized> CoerceUnsized<Bar<U>> for Bar<T> {}\n+\n+trait Baz {\n+    fn get(&self) -> i32;\n+}\n+\n+impl Baz for i32 {\n+    fn get(&self) -> i32 {\n+        *self\n+    }\n+}\n+\n+fn main() {\n+    // Arrays.\n+    let a: Bar<[i32; 3]> = Bar { x: &[1, 2, 3] };\n+    // This is the actual coercion.\n+    let b: Bar<[i32]> = a;\n+\n+    unsafe {\n+        assert_eq!((*b.x)[0], 1);\n+        assert_eq!((*b.x)[1], 2);\n+        assert_eq!((*b.x)[2], 3);\n+    }\n+\n+    // Trait objects.\n+    let a: Bar<i32> = Bar { x: &42 };\n+    let b: Bar<Baz> = a;\n+    unsafe {\n+        assert_eq!((*b.x).get(), 42);\n+    }\n+}"}, {"sha": "32e7a6279c858a197970d9c7b6310094d25bf796", "filename": "src/test/run-pass/dst-coerce-rc.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/fa433875274ff4a7c4cab7d87c1284ba782ef643/src%2Ftest%2Frun-pass%2Fdst-coerce-rc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa433875274ff4a7c4cab7d87c1284ba782ef643/src%2Ftest%2Frun-pass%2Fdst-coerce-rc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdst-coerce-rc.rs?ref=fa433875274ff4a7c4cab7d87c1284ba782ef643", "patch": "@@ -0,0 +1,39 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test a very simple custom DST coercion.\n+\n+#![feature(core)]\n+\n+use std::rc::Rc;\n+\n+trait Baz {\n+    fn get(&self) -> i32;\n+}\n+\n+impl Baz for i32 {\n+    fn get(&self) -> i32 {\n+        *self\n+    }\n+}\n+\n+fn main() {\n+    let a: Rc<[i32; 3]> = Rc::new([1, 2, 3]);\n+    let b: Rc<[i32]> = a;\n+    assert_eq!(b[0], 1);\n+    assert_eq!(b[1], 2);\n+    assert_eq!(b[2], 3);\n+\n+    let a: Rc<i32> = Rc::new(42);\n+    let b: Rc<Baz> = a.clone();\n+    assert_eq!(b.get(), 42);\n+\n+    let _c = b.clone();\n+}"}, {"sha": "b7513da99c806eb26372abe6a77c6d1ae1e419f0", "filename": "src/test/run-pass/fat-ptr-cast.rs", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/fa433875274ff4a7c4cab7d87c1284ba782ef643/src%2Ftest%2Frun-pass%2Ffat-ptr-cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa433875274ff4a7c4cab7d87c1284ba782ef643/src%2Ftest%2Frun-pass%2Ffat-ptr-cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffat-ptr-cast.rs?ref=fa433875274ff4a7c4cab7d87c1284ba782ef643", "patch": "@@ -0,0 +1,49 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(core)]\n+\n+use std::mem;\n+use std::raw;\n+\n+trait Foo {\n+    fn foo(&self) {}\n+}\n+\n+struct Bar;\n+\n+impl Foo for Bar {}\n+\n+fn main() {\n+    // Test we can turn a fat pointer to array back into a thin pointer.\n+    let a: *const [i32] = &[1, 2, 3];\n+    let b = a as *const [i32; 2];\n+    unsafe {\n+        assert!(*b == [1, 2]);\n+    }\n+\n+    // Test conversion to an address (usize).\n+    let a: *const [i32; 3] = &[1, 2, 3];\n+    let b: *const [i32] = a;\n+    assert!(a as usize == b as usize);\n+\n+    // And conversion to a void pointer/address for trait objects too.\n+    let a: *mut Foo = &mut Bar;\n+    let b = a as *mut ();\n+    let c = a as usize;\n+\n+    let d = unsafe {\n+        let r: raw::TraitObject = mem::transmute(a);\n+        r.data\n+    };\n+\n+    assert!(b == d);\n+    assert!(c == d as usize);\n+}"}]}