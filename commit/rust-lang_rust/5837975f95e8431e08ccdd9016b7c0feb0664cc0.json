{"sha": "5837975f95e8431e08ccdd9016b7c0feb0664cc0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU4Mzc5NzVmOTVlODQzMWUwOGNjZGQ5MDE2YjdjMGZlYjA2NjRjYzA=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-09-26T11:21:47Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-09-26T19:34:10Z"}, "message": "Convert more expression types to use DPS\n\nexpr_rec, expr_tup, most of the exprs that don't return anything. Make\ntrans_ret almost trivial by using destination adaptors (trans_save_in,\ntrans_by_ref).\n\nIssue #667", "tree": {"sha": "6441db700bfb0e93f6b51bfa1929de8e09d03229", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6441db700bfb0e93f6b51bfa1929de8e09d03229"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5837975f95e8431e08ccdd9016b7c0feb0664cc0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5837975f95e8431e08ccdd9016b7c0feb0664cc0", "html_url": "https://github.com/rust-lang/rust/commit/5837975f95e8431e08ccdd9016b7c0feb0664cc0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5837975f95e8431e08ccdd9016b7c0feb0664cc0/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "345b5a47bdf4f3ebdcc61c9f3f49a86cf357d025", "url": "https://api.github.com/repos/rust-lang/rust/commits/345b5a47bdf4f3ebdcc61c9f3f49a86cf357d025", "html_url": "https://github.com/rust-lang/rust/commit/345b5a47bdf4f3ebdcc61c9f3f49a86cf357d025"}], "stats": {"total": 421, "additions": 218, "deletions": 203}, "files": [{"sha": "27ac7372d42dfa7c73ce9236c3fe6928671dc4a7", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 218, "deletions": 203, "changes": 421, "blob_url": "https://github.com/rust-lang/rust/blob/5837975f95e8431e08ccdd9016b7c0feb0664cc0/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5837975f95e8431e08ccdd9016b7c0feb0664cc0/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=5837975f95e8431e08ccdd9016b7c0feb0664cc0", "patch": "@@ -668,6 +668,14 @@ fn bump_ptr(bcx: @block_ctxt, t: ty::t, base: ValueRef, sz: ValueRef) ->\n     } else { bumped }\n }\n \n+// GEP_tup_like is a pain to use if you always have to precede it with a\n+// check.\n+fn GEP_tup_like_1(cx: @block_ctxt, t: ty::t, base: ValueRef, ixs: [int])\n+    -> result {\n+    check type_is_tup_like(cx, t);\n+    ret GEP_tup_like(cx, t, base, ixs);\n+}\n+\n // Replacement for the LLVM 'GEP' instruction when field-indexing into a\n // tuple-like structure (tup, rec) with a static index. This one is driven off\n // ty::struct and knows what to do when it runs into a ty_param stuck in the\n@@ -1514,11 +1522,14 @@ fn compare_scalar_types(cx: @block_ctxt, lhs: ValueRef, rhs: ValueRef,\n         }\n       }\n       ty::ty_type. {\n-        ret trans_fail(cx, none, \"attempt to compare values of type type\");\n+        ret rslt(trans_fail(cx, none,\n+                            \"attempt to compare values of type type\"),\n+                 C_nil());\n       }\n       ty::ty_native(_) {\n-        ret trans_fail(cx, none::<span>,\n-                   \"attempt to compare values of type native\");\n+        let cx = trans_fail(cx, none::<span>,\n+                            \"attempt to compare values of type native\");\n+        ret rslt(cx, C_nil());\n       }\n       _ {\n         // Should never get here, because t is scalar.\n@@ -3988,60 +3999,44 @@ fn trans_landing_pad(bcx: @block_ctxt,\n     ret bcx.llbb;\n }\n \n-fn trans_tup(cx: @block_ctxt, elts: [@ast::expr], id: ast::node_id) ->\n-   result {\n-    let bcx = cx;\n+fn trans_tup(bcx: @block_ctxt, elts: [@ast::expr], id: ast::node_id,\n+             dest: dest) -> @block_ctxt {\n     let t = node_id_type(bcx.fcx.lcx.ccx, id);\n-    let tup_res = alloc_ty(bcx, t);\n-    let tup_val = tup_res.val;\n-    bcx = tup_res.bcx;\n+    let dst = alt dest { save_in(addr) { addr } };\n \n     // Like trans_rec, we'll collect the fields of the tuple then build it, so\n     // that if we fail in between we don't have to deal with cleaning up a\n     // partial tuple\n-    let tupfields: [(ValueRef, lval_result, ty::t)] = [];\n-    let i: int = 0;\n+    let tupfields = [], i = 0;\n     for e in elts {\n-        let e_ty = ty::expr_ty(cx.fcx.lcx.ccx.tcx, e);\n+        let e_ty = ty::expr_ty(bcx_tcx(bcx), e);\n         let src = trans_lval(bcx, e);\n-        bcx = src.bcx;\n-        // FIXME: constraint on argument?\n-        check type_is_tup_like(bcx, t);\n-        let dst_res = GEP_tup_like(bcx, t, tup_val, [0, i]);\n-        tupfields += [(dst_res.val, src, e_ty)];\n+        let dst_res = GEP_tup_like_1(src.bcx, t, dst, [0, i]);\n         bcx = dst_res.bcx;\n+        tupfields += [(dst_res.val, src, e_ty)];\n         i += 1;\n     }\n-\n     // Fill in the tuple fields\n     for (dst, src, t) in tupfields {\n         bcx = move_val_if_temp(bcx, INIT, dst, src, t);\n     }\n-\n-    // Only register the cleanups after the tuple is built\n-    add_clean_temp(cx, tup_val, t);\n-    ret rslt(bcx, tup_val);\n+    ret bcx;\n }\n \n-fn trans_rec(cx: @block_ctxt, fields: [ast::field],\n-             base: option::t<@ast::expr>, id: ast::node_id) -> result {\n-    let bcx = cx;\n+fn trans_rec(bcx: @block_ctxt, fields: [ast::field],\n+             base: option::t<@ast::expr>, id: ast::node_id,\n+             dest: dest) -> @block_ctxt {\n     let t = node_id_type(bcx_ccx(bcx), id);\n-    let rec_res = alloc_ty(bcx, t);\n-    let rec_val = rec_res.val;\n-    bcx = rec_res.bcx;\n-    let i: int = 0;\n-    let base_val = C_nil();\n-    alt base {\n-      none. { }\n+    let dst = alt dest { save_in(addr) { addr } };\n+\n+    let base_val = alt base {\n       some(bexp) {\n         let base_res = trans_expr(bcx, bexp);\n         bcx = base_res.bcx;\n-        base_val = base_res.val;\n+        base_res.val\n       }\n-    }\n-    let ty_fields: [ty::field] = [];\n-    alt ty::struct(bcx_tcx(cx), t) { ty::ty_rec(flds) { ty_fields = flds; } }\n+      none. { C_nil() }\n+    };\n \n     tag fieldsrc {\n         provided(lval_result);\n@@ -4052,45 +4047,36 @@ fn trans_rec(cx: @block_ctxt, fields: [ast::field],\n         src: fieldsrc,\n         ty: ty::t\n     };\n-    let fieldvals: [fieldval] = [];\n \n+    let ty_fields = alt ty::struct(bcx_tcx(bcx), t) { ty::ty_rec(f) { f } };\n+    let fieldvals = [], i = 0;\n     // We build the record in two stages so that we don't have to clean up a\n     // partial record if we fail: first collect all the values, then construct\n     // the record.\n-    for tf: ty::field in ty_fields {\n-        let e_ty = tf.mt.ty;\n-        // FIXME: constraint on argument?\n-        check type_is_tup_like(bcx, t);\n-        let dst_res = GEP_tup_like(bcx, t, rec_val, [0, i]);\n-        bcx = dst_res.bcx;\n-        let expr_provided = false;\n-        for f: ast::field in fields {\n-            if str::eq(f.node.ident, tf.ident) {\n-                expr_provided = true;\n+    for tf in ty_fields {\n+        let {bcx: a_bcx, val: addr} = GEP_tup_like_1(bcx, t, dst, [0, i]);\n+        bcx = a_bcx;\n+        // FIXME make this happen in a single pass, again, somehow make the\n+        // dps helpers tie the cleanups together in the right way (we do not\n+        // want to create intermediates for these and then move them again)\n+        fn test(n: str, f: ast::field) -> bool { str::eq(f.node.ident, n) }\n+        // FIXME make this {|f| str::eq(f.node.ident, tf.ident)} again when\n+        // bug #913 is fixed\n+        let s = alt vec::find(bind test(tf.ident, _), fields) {\n+            some(f) {\n                 let lv = trans_lval(bcx, f.node.expr);\n                 bcx = lv.bcx;\n-                fieldvals += [{\n-                    dst: dst_res.val,\n-                    src: provided(lv),\n-                    ty: e_ty\n-                }];\n-                break;\n+                provided(lv)\n             }\n-        }\n-        if !expr_provided {\n-            // FIXME: constraint on argument?\n-            check type_is_tup_like(bcx, t);\n-            let src_res = GEP_tup_like(bcx, t, base_val, [0, i]);\n-            bcx = src_res.bcx;\n-            fieldvals += [{\n-                dst: dst_res.val,\n-                src: inherited(src_res.val),\n-                ty: e_ty\n-            }];\n-        }\n+            none. {\n+                let src_res = GEP_tup_like_1(bcx, t, base_val, [0, i]);\n+                bcx = src_res.bcx;\n+                inherited(src_res.val)\n+            }\n+        };\n+        fieldvals += [{dst: addr, src: s, ty: tf.mt.ty}];\n         i += 1;\n     }\n-\n     // Now build the record\n     for fieldval in fieldvals {\n         alt fieldval.src {\n@@ -4104,9 +4090,7 @@ fn trans_rec(cx: @block_ctxt, fields: [ast::field],\n           }\n         }\n     }\n-\n-    add_clean_temp(cx, rec_val, t);\n-    ret rslt(bcx, rec_val);\n+    ret bcx;\n }\n \n fn trans_expr(cx: @block_ctxt, e: @ast::expr) -> result {\n@@ -4247,46 +4231,6 @@ fn trans_expr(cx: @block_ctxt, e: @ast::expr) -> result {\n       ast::expr_bind(f, args) { ret trans_bind(cx, f, args, e.id); }\n       ast::expr_cast(val, _) { ret trans_cast(cx, val, e.id); }\n       ast::expr_vec(args, _) { ret tvec::trans_vec(cx, args, e.id); }\n-      ast::expr_rec(args, base) { ret trans_rec(cx, args, base, e.id); }\n-      ast::expr_tup(args) { ret trans_tup(cx, args, e.id); }\n-      ast::expr_mac(_) { ret bcx_ccx(cx).sess.bug(\"unexpanded macro\"); }\n-      ast::expr_fail(expr) { ret trans_fail_expr(cx, some(e.span), expr); }\n-      ast::expr_log(lvl, a) { ret trans_log(lvl, cx, a); }\n-      ast::expr_assert(a) { ret trans_check_expr(cx, a, \"Assertion\"); }\n-      ast::expr_check(ast::checked., a) {\n-        ret trans_check_expr(cx, a, \"Predicate\");\n-      }\n-      ast::expr_check(ast::unchecked., a) {\n-        /* Claims are turned on and off by a global variable\n-           that the RTS sets. This case generates code to\n-           check the value of that variable, doing nothing\n-           if it's set to false and acting like a check\n-           otherwise. */\n-        let c =\n-            get_extern_const(bcx_ccx(cx).externs, bcx_ccx(cx).llmod,\n-                             \"check_claims\", T_bool());\n-        let cond = Load(cx, c);\n-\n-        let then_cx = new_scope_block_ctxt(cx, \"claim_then\");\n-        let check_res = trans_check_expr(then_cx, a, \"Claim\");\n-        let else_cx = new_scope_block_ctxt(cx, \"else\");\n-        let els = rslt(else_cx, C_nil());\n-\n-        CondBr(cx, cond, then_cx.llbb, else_cx.llbb);\n-        ret rslt(join_branches(cx, [check_res, els]), C_nil());\n-      }\n-      ast::expr_break. { ret trans_break(e.span, cx); }\n-      ast::expr_cont. { ret trans_cont(e.span, cx); }\n-      ast::expr_ret(ex) { ret trans_ret(cx, ex); }\n-      ast::expr_put(ex) { ret trans_put(cx, ex); }\n-      ast::expr_be(ex) {\n-        // Ideally, the expr_be tag would have a precondition\n-        // that is_call_expr(ex) -- but we don't support that\n-        // yet\n-        // FIXME\n-        check (ast_util::is_call_expr(ex));\n-        ret trans_be(cx, ex);\n-      }\n       ast::expr_anon_obj(anon_obj) {\n         ret trans_anon_obj(cx, e.span, anon_obj, e.id);\n       }\n@@ -4309,6 +4253,33 @@ fn trans_expr(cx: @block_ctxt, e: @ast::expr) -> result {\n     }\n }\n \n+// FIXME add support for INIT/DROP_EXISTING\n+fn trans_expr_save_in(bcx: @block_ctxt, e: @ast::expr, dest: ValueRef)\n+    -> @block_ctxt {\n+    let tcx = bcx_tcx(bcx), t = ty::expr_ty(tcx, e);\n+    if ty::type_is_bot(tcx, t) || ty::type_is_nil(tcx, t) {\n+        ret trans_expr_dps(bcx, e, ignore);\n+    } else if type_is_immediate(bcx_ccx(bcx), t) {\n+        let cell = empty_dest_cell();\n+        bcx = trans_expr_dps(bcx, e, by_val(cell));\n+        Store(bcx, *cell, dest);\n+        ret bcx;\n+    } else {\n+        ret trans_expr_dps(bcx, e, save_in(dest));\n+    }\n+}\n+\n+fn trans_expr_by_ref(bcx: @block_ctxt, e: @ast::expr) -> result {\n+    let cell = empty_dest_cell();\n+    bcx = trans_expr_dps(bcx, e, by_ref(cell));\n+    ret rslt(bcx, *cell);\n+}\n+\n+// Invariants:\n+// - things returning nil get dest=ignore\n+// - any lvalue expr may be given dest=by_ref\n+// - exprs returning an immediate get by_val (or by_ref when lval)\n+// - exprs returning non-immediates get save_in (or by_ref when lval)\n fn trans_expr_dps(bcx: @block_ctxt, e: @ast::expr, dest: dest)\n     -> @block_ctxt {\n     alt e.node {\n@@ -4330,19 +4301,92 @@ fn trans_expr_dps(bcx: @block_ctxt, e: @ast::expr, dest: dest)\n         if sub_cx.unreachable { Unreachable(next_cx); }\n         ret next_cx;\n       }\n+      ast::expr_rec(args, base) {\n+        ret trans_rec(bcx, args, base, e.id, dest);\n+      }\n+      ast::expr_tup(args) { ret trans_tup(bcx, args, e.id, dest); }\n+      ast::expr_break. {\n+        assert dest == ignore;\n+        ret trans_break(e.span, bcx);\n+      }\n+      ast::expr_cont. {\n+        assert dest == ignore;\n+        ret trans_cont(e.span, bcx);\n+      }\n+      ast::expr_ret(ex) {\n+        assert dest == ignore;\n+        ret trans_ret(bcx, ex);\n+      }\n+      ast::expr_be(ex) {\n+        // Ideally, the expr_be tag would have a precondition\n+        // that is_call_expr(ex) -- but we don't support that\n+        // yet\n+        // FIXME\n+        check (ast_util::is_call_expr(ex));\n+        ret trans_be(bcx, ex);\n+      }\n+      ast::expr_put(ex) {\n+        assert dest == ignore;\n+        ret trans_put(bcx, ex);\n+      }\n+      ast::expr_fail(expr) {\n+        assert dest == ignore;\n+        ret trans_fail_expr(bcx, some(e.span), expr);\n+      }\n+      ast::expr_log(lvl, a) {\n+        assert dest == ignore;\n+        ret trans_log(lvl, bcx, a);\n+      }\n+      ast::expr_assert(a) {\n+        assert dest == ignore;\n+        ret trans_check_expr(bcx, a, \"Assertion\");\n+      }\n+      ast::expr_check(ast::checked., a) {\n+        assert dest == ignore;\n+        ret trans_check_expr(bcx, a, \"Predicate\");\n+      }\n+      ast::expr_check(ast::unchecked., a) {\n+        assert dest == ignore;\n+        /* Claims are turned on and off by a global variable\n+           that the RTS sets. This case generates code to\n+           check the value of that variable, doing nothing\n+           if it's set to false and acting like a check\n+           otherwise. */\n+        let c =\n+            get_extern_const(bcx_ccx(bcx).externs, bcx_ccx(bcx).llmod,\n+                             \"check_claims\", T_bool());\n+        let cond = Load(bcx, c);\n+\n+        let then_cx = new_scope_block_ctxt(bcx, \"claim_then\");\n+        let check_cx = trans_check_expr(then_cx, a, \"Claim\");\n+        let else_cx = new_scope_block_ctxt(bcx, \"else\");\n+\n+        CondBr(bcx, cond, then_cx.llbb, else_cx.llbb);\n+        ret join_branches(bcx, [rslt(check_cx, C_nil()),\n+                                rslt(else_cx, C_nil())]);\n+      }\n+\n+      ast::expr_mac(_) { ret bcx_ccx(bcx).sess.bug(\"unexpanded macro\"); }\n       // Convert back from result to DPS\n       _ {\n         let lv = trans_lval(bcx, e);\n         let {bcx, val, is_mem} = lv;\n         let ty = ty::expr_ty(bcx_tcx(bcx), e);\n         alt dest {\n           by_val(cell) {\n-            if is_mem {\n+            if !is_mem {\n+                revoke_clean(bcx, val);\n+                *cell = val;\n+            } else if ty::type_is_unique(bcx_tcx(bcx), ty) {\n+                // Do a song and a dance to work around the fact that take_ty\n+                // for unique boxes overwrites the pointer.\n+                let oldval = Load(bcx, val);\n                 bcx = take_ty(bcx, val, ty);\n                 *cell = Load(bcx, val);\n+                Store(bcx, oldval, val);\n             } else {\n-                revoke_clean(bcx, val);\n-                *cell = val;\n+                bcx = take_ty(bcx, val, ty);\n+                *cell = Load(bcx, val);\n             }\n           }\n           by_ref(cell) {\n@@ -4402,28 +4446,24 @@ fn load_if_immediate(cx: @block_ctxt, v: ValueRef, t: ty::t) -> ValueRef {\n     ret v;\n }\n \n-fn trans_log(lvl: int, cx: @block_ctxt, e: @ast::expr) -> result {\n+fn trans_log(lvl: int, cx: @block_ctxt, e: @ast::expr) -> @block_ctxt {\n     let lcx = cx.fcx.lcx;\n     let modname = str::connect(lcx.module_path, \"::\");\n-    let global;\n-    if lcx.ccx.module_data.contains_key(modname) {\n-        global = lcx.ccx.module_data.get(modname);\n+    let global = if lcx.ccx.module_data.contains_key(modname) {\n+        lcx.ccx.module_data.get(modname)\n     } else {\n-        let s =\n-            link::mangle_internal_name_by_path_and_seq(lcx.ccx,\n-                                                       lcx.module_path,\n-                                                       \"loglevel\");\n-        global =\n-            str::as_buf(s,\n-                        {|buf|\n-                            llvm::LLVMAddGlobal(lcx.ccx.llmod, T_int(), buf)\n-                        });\n+        let s = link::mangle_internal_name_by_path_and_seq(\n+            lcx.ccx, lcx.module_path, \"loglevel\");\n+        let global = str::as_buf(s, {|buf|\n+            llvm::LLVMAddGlobal(lcx.ccx.llmod, T_int(), buf)\n+        });\n         llvm::LLVMSetGlobalConstant(global, False);\n         llvm::LLVMSetInitializer(global, C_null(T_int()));\n         llvm::LLVMSetLinkage(global,\n                              lib::llvm::LLVMInternalLinkage as llvm::Linkage);\n         lcx.ccx.module_data.insert(modname, global);\n-    }\n+        global\n+    };\n     let log_cx = new_scope_block_ctxt(cx, \"log\");\n     let after_cx = new_sub_block_ctxt(cx, \"after\");\n     let load = Load(cx, global);\n@@ -4442,30 +4482,28 @@ fn trans_log(lvl: int, cx: @block_ctxt, e: @ast::expr) -> result {\n     r = spill_if_immediate(log_bcx, sub.val, e_ty);\n     log_bcx = r.bcx;\n     let llvalptr = r.val;\n-\n     let llval_i8 = PointerCast(log_bcx, llvalptr, T_ptr(T_i8()));\n \n     Call(log_bcx, bcx_ccx(log_bcx).upcalls.log_type,\n          [log_bcx.fcx.lltaskptr, lltydesc, llval_i8, C_int(lvl)]);\n \n     log_bcx = trans_block_cleanups(log_bcx, log_cx);\n     Br(log_bcx, after_cx.llbb);\n-    ret rslt(after_cx, C_nil());\n+    ret after_cx;\n }\n \n-fn trans_check_expr(cx: @block_ctxt, e: @ast::expr, s: str) -> result {\n+fn trans_check_expr(cx: @block_ctxt, e: @ast::expr, s: str) -> @block_ctxt {\n     let cond_res = trans_expr(cx, e);\n     let expr_str = s + \" \" + expr_to_str(e) + \" failed\";\n     let fail_cx = new_sub_block_ctxt(cx, \"fail\");\n     trans_fail(fail_cx, some::<span>(e.span), expr_str);\n     let next_cx = new_sub_block_ctxt(cx, \"next\");\n     CondBr(cond_res.bcx, cond_res.val, next_cx.llbb, fail_cx.llbb);\n-    ret rslt(next_cx, C_nil());\n+    ret next_cx;\n }\n \n-fn trans_fail_expr(cx: @block_ctxt, sp_opt: option::t<span>,\n-                   fail_expr: option::t<@ast::expr>) -> result {\n-    let bcx = cx;\n+fn trans_fail_expr(bcx: @block_ctxt, sp_opt: option::t<span>,\n+                   fail_expr: option::t<@ast::expr>) -> @block_ctxt {\n     alt fail_expr {\n       some(expr) {\n         let tcx = bcx_tcx(bcx);\n@@ -4474,51 +4512,49 @@ fn trans_fail_expr(cx: @block_ctxt, sp_opt: option::t<span>,\n         bcx = expr_res.bcx;\n \n         if ty::type_is_str(tcx, e_ty) {\n-            let data =\n-                tvec::get_dataptr(bcx, expr_res.val,\n-                                  type_of_or_i8(bcx,\n-                                                ty::mk_mach(tcx,\n-                                                            ast::ty_u8)));\n+            let data = tvec::get_dataptr(\n+                bcx, expr_res.val, type_of_or_i8(\n+                    bcx, ty::mk_mach(tcx, ast::ty_u8)));\n             ret trans_fail_value(bcx, sp_opt, data);\n         } else if bcx.unreachable {\n-            ret rslt(bcx, C_nil());\n+            ret bcx;\n         } else {\n-            bcx_ccx(cx).sess.span_bug(expr.span,\n-                                      \"fail called with unsupported type \" +\n-                                          ty_to_str(tcx, e_ty));\n+            bcx_ccx(bcx).sess.span_bug(\n+                expr.span, \"fail called with unsupported type \" +\n+                ty_to_str(tcx, e_ty));\n         }\n       }\n       _ { ret trans_fail(bcx, sp_opt, \"explicit failure\"); }\n     }\n }\n \n-fn trans_fail(cx: @block_ctxt, sp_opt: option::t<span>, fail_str: str) ->\n-   result {\n-    let V_fail_str = C_cstr(bcx_ccx(cx), fail_str);\n-    ret trans_fail_value(cx, sp_opt, V_fail_str);\n+fn trans_fail(bcx: @block_ctxt, sp_opt: option::t<span>, fail_str: str) ->\n+    @block_ctxt {\n+    let V_fail_str = C_cstr(bcx_ccx(bcx), fail_str);\n+    ret trans_fail_value(bcx, sp_opt, V_fail_str);\n }\n \n-fn trans_fail_value(cx: @block_ctxt, sp_opt: option::t<span>,\n-                    V_fail_str: ValueRef) -> result {\n+fn trans_fail_value(bcx: @block_ctxt, sp_opt: option::t<span>,\n+                    V_fail_str: ValueRef) -> @block_ctxt {\n     let V_filename;\n     let V_line;\n     alt sp_opt {\n       some(sp) {\n-        let loc = bcx_ccx(cx).sess.lookup_pos(sp.lo);\n-        V_filename = C_cstr(bcx_ccx(cx), loc.filename);\n+        let loc = bcx_ccx(bcx).sess.lookup_pos(sp.lo);\n+        V_filename = C_cstr(bcx_ccx(bcx), loc.filename);\n         V_line = loc.line as int;\n       }\n-      none. { V_filename = C_cstr(bcx_ccx(cx), \"<runtime>\"); V_line = 0; }\n+      none. { V_filename = C_cstr(bcx_ccx(bcx), \"<runtime>\"); V_line = 0; }\n     }\n-    let V_str = PointerCast(cx, V_fail_str, T_ptr(T_i8()));\n-    V_filename = PointerCast(cx, V_filename, T_ptr(T_i8()));\n-    let args = [cx.fcx.lltaskptr, V_str, V_filename, C_int(V_line)];\n-    let cx = invoke(cx, bcx_ccx(cx).upcalls._fail, args);\n-    Unreachable(cx);\n-    ret rslt(cx, C_nil());\n+    let V_str = PointerCast(bcx, V_fail_str, T_ptr(T_i8()));\n+    V_filename = PointerCast(bcx, V_filename, T_ptr(T_i8()));\n+    let args = [bcx.fcx.lltaskptr, V_str, V_filename, C_int(V_line)];\n+    let bcx = invoke(bcx, bcx_ccx(bcx).upcalls._fail, args);\n+    Unreachable(bcx);\n+    ret bcx;\n }\n \n-fn trans_put(in_cx: @block_ctxt, e: option::t<@ast::expr>) -> result {\n+fn trans_put(in_cx: @block_ctxt, e: option::t<@ast::expr>) -> @block_ctxt {\n     let cx = new_scope_block_ctxt(in_cx, \"put\");\n     Br(in_cx, cx.llbb);\n     let llcallee = C_nil();\n@@ -4556,14 +4592,13 @@ fn trans_put(in_cx: @block_ctxt, e: option::t<@ast::expr>) -> result {\n     let next_cx = new_sub_block_ctxt(in_cx, \"next\");\n     if bcx.unreachable { Unreachable(next_cx); }\n     Br(bcx, next_cx.llbb);\n-    ret rslt(next_cx, C_nil());\n+    ret next_cx;\n }\n \n-fn trans_break_cont(sp: span, cx: @block_ctxt, to_end: bool) -> result {\n-    let bcx = cx;\n+fn trans_break_cont(sp: span, bcx: @block_ctxt, to_end: bool)\n+    -> @block_ctxt {\n     // Locate closest loop block, outputting cleanup as we go.\n-\n-    let cleanup_cx = cx;\n+    let cleanup_cx = bcx;\n     while true {\n         bcx = trans_block_cleanups(bcx, cleanup_cx);\n         alt copy cleanup_cx.kind {\n@@ -4577,70 +4612,49 @@ fn trans_break_cont(sp: span, cx: @block_ctxt, to_end: bool) -> result {\n                 }\n             }\n             Unreachable(bcx);\n-            ret rslt(bcx, C_nil());\n+            ret bcx;\n           }\n           _ {\n             alt cleanup_cx.parent {\n               parent_some(cx) { cleanup_cx = cx; }\n               parent_none. {\n-                bcx_ccx(cx).sess.span_fatal(sp,\n-                                            if to_end {\n-                                                \"Break\"\n-                                            } else { \"Cont\" } +\n-                                                \" outside a loop\");\n+                bcx_ccx(bcx).sess.span_fatal\n+                    (sp, if to_end { \"Break\" } else { \"Cont\" } +\n+                     \" outside a loop\");\n               }\n             }\n           }\n         }\n     }\n     // If we get here without returning, it's a bug\n-\n-    bcx_ccx(cx).sess.bug(\"in trans::trans_break_cont()\");\n+    bcx_ccx(bcx).sess.bug(\"in trans::trans_break_cont()\");\n }\n \n-fn trans_break(sp: span, cx: @block_ctxt) -> result {\n+fn trans_break(sp: span, cx: @block_ctxt) -> @block_ctxt {\n     ret trans_break_cont(sp, cx, true);\n }\n \n-fn trans_cont(sp: span, cx: @block_ctxt) -> result {\n+fn trans_cont(sp: span, cx: @block_ctxt) -> @block_ctxt {\n     ret trans_break_cont(sp, cx, false);\n }\n \n-fn trans_ret(cx: @block_ctxt, e: option::t<@ast::expr>) -> result {\n-    let bcx = cx;\n+fn trans_ret(bcx: @block_ctxt, e: option::t<@ast::expr>) -> @block_ctxt {\n+    let cleanup_cx = bcx;\n     alt e {\n       some(x) {\n-        let t = ty::expr_ty(bcx_tcx(cx), x);\n-        let lv = trans_lval(cx, x);\n-        bcx = lv.bcx;\n-        if ty::type_is_nil(bcx_tcx(cx), t) {\n-            // Don't write nil\n-        } else if ast_util::ret_by_ref(cx.fcx.ret_style) {\n-            assert lv.is_mem;\n-            Store(bcx, lv.val, cx.fcx.llretptr);\n+        if ast_util::ret_by_ref(bcx.fcx.ret_style) {\n+            let {bcx: cx, val} = trans_expr_by_ref(bcx, x);\n+            Store(cx, val, bcx.fcx.llretptr);\n+            bcx = cx;\n         } else {\n-            let is_local = alt x.node {\n-              ast::expr_path(p) {\n-                alt bcx_tcx(bcx).def_map.get(x.id) {\n-                  ast::def_local(_, _) { true }\n-                  _ { false }\n-                }\n-              }\n-              _ { false }\n-            };\n-            if is_local {\n-                bcx = move_val(bcx, INIT, cx.fcx.llretptr, lv, t);\n-            } else {\n-                bcx = move_val_if_temp(bcx, INIT, cx.fcx.llretptr, lv, t);\n-            }\n+            bcx = trans_expr_save_in(bcx, x, bcx.fcx.llretptr);\n         }\n       }\n       _ {}\n     }\n     // run all cleanups and back out.\n \n     let more_cleanups: bool = true;\n-    let cleanup_cx = cx;\n     while more_cleanups {\n         bcx = trans_block_cleanups(bcx, cleanup_cx);\n         alt cleanup_cx.parent {\n@@ -4650,18 +4664,16 @@ fn trans_ret(cx: @block_ctxt, e: option::t<@ast::expr>) -> result {\n     }\n     build_return(bcx);\n     Unreachable(bcx);\n-    ret rslt(bcx, C_nil());\n+    ret bcx;\n }\n \n fn build_return(bcx: @block_ctxt) { Br(bcx, bcx_fcx(bcx).llreturn); }\n \n // fn trans_be(cx: &@block_ctxt, e: &@ast::expr) -> result {\n fn trans_be(cx: @block_ctxt, e: @ast::expr) : ast_util::is_call_expr(e) ->\n-   result {\n-\n+   @block_ctxt {\n     // FIXME: Turn this into a real tail call once\n     // calling convention issues are settled\n-\n     ret trans_ret(cx, some(e));\n }\n \n@@ -4999,7 +5011,10 @@ fn trans_block_dps(bcx: @block_ctxt, b: ast::blk, dest: dest)\n         bcx = trans_stmt(bcx, *s);\n     }\n     alt b.node.expr {\n-      some(e) { bcx = trans_expr_dps(bcx, e, dest); }\n+      some(e) {\n+        let bt = ty::type_is_bot(bcx_tcx(bcx), ty::expr_ty(bcx_tcx(bcx), e));\n+        bcx = trans_expr_dps(bcx, e, bt ? ignore : dest);\n+      }\n       _ { assert dest == ignore || bcx.unreachable; }\n     }\n     ret trans_block_cleanups(bcx, find_scope_cx(bcx));"}]}