{"sha": "10a583ce1ac28a8cbf34b0f4274285f33bdfce29", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEwYTU4M2NlMWFjMjhhOGNiZjM0YjBmNDI3NDI4NWYzM2JkZmNlMjk=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-08-07T07:11:34Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-09-24T16:57:25Z"}, "message": "Correctly encode item visibility in metadata\n\nThis fixes private statics and functions from being usable cross-crates, along\nwith some bad privacy error messages. This is a reopening of #8365 with all the\nprivacy checks in privacy.rs instead of resolve.rs (where they should be\nanyway).\n\nThese maps of exported items will hopefully get used for generating\ndocumentation by rustdoc\n\nCloses #8592", "tree": {"sha": "8b507517ab2025b6a711faac1d1665646774ca8c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8b507517ab2025b6a711faac1d1665646774ca8c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/10a583ce1ac28a8cbf34b0f4274285f33bdfce29", "comment_count": 4, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/10a583ce1ac28a8cbf34b0f4274285f33bdfce29", "html_url": "https://github.com/rust-lang/rust/commit/10a583ce1ac28a8cbf34b0f4274285f33bdfce29", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/10a583ce1ac28a8cbf34b0f4274285f33bdfce29/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "753547963340cb973210ad2df5590c29bf46ddf1", "url": "https://api.github.com/repos/rust-lang/rust/commits/753547963340cb973210ad2df5590c29bf46ddf1", "html_url": "https://github.com/rust-lang/rust/commit/753547963340cb973210ad2df5590c29bf46ddf1"}], "stats": {"total": 655, "additions": 494, "deletions": 161}, "files": [{"sha": "28a067a782bc400976ef038c36da70bac94fcee8", "filename": "src/libextra/arc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/10a583ce1ac28a8cbf34b0f4274285f33bdfce29/src%2Flibextra%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10a583ce1ac28a8cbf34b0f4274285f33bdfce29/src%2Flibextra%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Farc.rs?ref=10a583ce1ac28a8cbf34b0f4274285f33bdfce29", "patch": "@@ -162,7 +162,7 @@ struct MutexArcInner<T> { priv lock: Mutex, priv failed: bool, priv data: T }\n \n /// An Arc with mutable data protected by a blocking mutex.\n #[no_freeze]\n-struct MutexArc<T> { priv x: UnsafeArc<MutexArcInner<T>> }\n+pub struct MutexArc<T> { priv x: UnsafeArc<MutexArcInner<T>> }\n \n \n impl<T:Send> Clone for MutexArc<T> {\n@@ -343,7 +343,7 @@ struct RWArcInner<T> { priv lock: RWLock, priv failed: bool, priv data: T }\n  * Unlike mutex_arcs, rw_arcs are safe, because they cannot be nested.\n  */\n #[no_freeze]\n-struct RWArc<T> {\n+pub struct RWArc<T> {\n     priv x: UnsafeArc<RWArcInner<T>>,\n }\n "}, {"sha": "e24fe3eb8c25e6608cbb415bbaaba1e70141e48e", "filename": "src/libextra/workcache.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/10a583ce1ac28a8cbf34b0f4274285f33bdfce29/src%2Flibextra%2Fworkcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10a583ce1ac28a8cbf34b0f4274285f33bdfce29/src%2Flibextra%2Fworkcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fworkcache.rs?ref=10a583ce1ac28a8cbf34b0f4274285f33bdfce29", "patch": "@@ -127,7 +127,7 @@ impl WorkMap {\n     }\n }\n \n-struct Database {\n+pub struct Database {\n     db_filename: Path,\n     db_cache: TreeMap<~str, ~str>,\n     db_dirty: bool\n@@ -207,7 +207,7 @@ impl Drop for Database {\n     }\n }\n \n-struct Logger {\n+pub struct Logger {\n     // FIXME #4432: Fill in\n     a: ()\n }\n@@ -223,10 +223,10 @@ impl Logger {\n     }\n }\n \n-type FreshnessMap = TreeMap<~str,extern fn(&str,&str)->bool>;\n+pub type FreshnessMap = TreeMap<~str,extern fn(&str,&str)->bool>;\n \n #[deriving(Clone)]\n-struct Context {\n+pub struct Context {\n     db: RWArc<Database>,\n     logger: RWArc<Logger>,\n     cfg: Arc<json::Object>,\n@@ -239,13 +239,13 @@ struct Context {\n     freshness: Arc<FreshnessMap>\n }\n \n-struct Prep<'self> {\n+pub struct Prep<'self> {\n     ctxt: &'self Context,\n     fn_name: &'self str,\n     declared_inputs: WorkMap,\n }\n \n-struct Exec {\n+pub struct Exec {\n     discovered_inputs: WorkMap,\n     discovered_outputs: WorkMap\n }"}, {"sha": "5518dde0ee979921b337062769b7c7d1b06aa916", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/10a583ce1ac28a8cbf34b0f4274285f33bdfce29/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10a583ce1ac28a8cbf34b0f4274285f33bdfce29/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=10a583ce1ac28a8cbf34b0f4274285f33bdfce29", "patch": "@@ -197,6 +197,7 @@ pub fn phase_2_configure_and_expand(sess: Session,\n \n pub struct CrateAnalysis {\n     exp_map2: middle::resolve::ExportMap2,\n+    exported_items: @middle::privacy::ExportedItems,\n     ty_cx: ty::ctxt,\n     maps: astencode::Maps,\n     reachable: @mut HashSet<ast::NodeId>\n@@ -258,8 +259,9 @@ pub fn phase_3_run_analysis_passes(sess: Session,\n          middle::check_const::check_crate(sess, crate, ast_map, def_map,\n                                           method_map, ty_cx));\n \n-    time(time_passes, ~\"privacy checking\", ||\n-         middle::privacy::check_crate(ty_cx, &method_map, crate));\n+    let exported_items =\n+        time(time_passes, ~\"privacy checking\", ||\n+             middle::privacy::check_crate(ty_cx, &method_map, &exp_map2, crate));\n \n     time(time_passes, ~\"effect checking\", ||\n          middle::effect::check_crate(ty_cx, method_map, crate));\n@@ -301,6 +303,7 @@ pub fn phase_3_run_analysis_passes(sess: Session,\n \n     CrateAnalysis {\n         exp_map2: exp_map2,\n+        exported_items: @exported_items,\n         ty_cx: ty_cx,\n         maps: astencode::Maps {\n             root_map: root_map,"}, {"sha": "841142ee62fe8a069183f2e660c303b37e4dfa26", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/10a583ce1ac28a8cbf34b0f4274285f33bdfce29/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10a583ce1ac28a8cbf34b0f4274285f33bdfce29/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=10a583ce1ac28a8cbf34b0f4274285f33bdfce29", "patch": "@@ -27,7 +27,8 @@ use syntax::diagnostic::expect;\n pub struct StaticMethodInfo {\n     ident: ast::Ident,\n     def_id: ast::DefId,\n-    purity: ast::purity\n+    purity: ast::purity,\n+    vis: ast::visibility,\n }\n \n pub fn get_symbol(cstore: @mut cstore::CStore, def: ast::DefId) -> ~str {\n@@ -52,7 +53,8 @@ pub fn each_lang_item(cstore: @mut cstore::CStore,\n /// Iterates over each child of the given item.\n pub fn each_child_of_item(cstore: @mut cstore::CStore,\n                           def_id: ast::DefId,\n-                          callback: &fn(decoder::DefLike, ast::Ident)) {\n+                          callback: &fn(decoder::DefLike, ast::Ident,\n+                                        ast::visibility)) {\n     let crate_data = cstore::get_crate_data(cstore, def_id.crate);\n     let get_crate_data: decoder::GetCrateDataCb = |cnum| {\n         cstore::get_crate_data(cstore, cnum)\n@@ -68,7 +70,8 @@ pub fn each_child_of_item(cstore: @mut cstore::CStore,\n pub fn each_top_level_item_of_crate(cstore: @mut cstore::CStore,\n                                     cnum: ast::CrateNum,\n                                     callback: &fn(decoder::DefLike,\n-                                                  ast::Ident)) {\n+                                                  ast::Ident,\n+                                                  ast::visibility)) {\n     let crate_data = cstore::get_crate_data(cstore, cnum);\n     let get_crate_data: decoder::GetCrateDataCb = |cnum| {\n         cstore::get_crate_data(cstore, cnum)"}, {"sha": "fe7309d4467fa8eae3b067c446f086502a20c0ec", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 26, "deletions": 17, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/10a583ce1ac28a8cbf34b0f4274285f33bdfce29/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10a583ce1ac28a8cbf34b0f4274285f33bdfce29/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=10a583ce1ac28a8cbf34b0f4274285f33bdfce29", "patch": "@@ -96,7 +96,7 @@ fn find_item(item_id: int, items: ebml::Doc) -> ebml::Doc {\n \n // Looks up an item in the given metadata and returns an ebml doc pointing\n // to the item data.\n-fn lookup_item(item_id: int, data: @~[u8]) -> ebml::Doc {\n+pub fn lookup_item(item_id: int, data: @~[u8]) -> ebml::Doc {\n     let items = reader::get_doc(reader::Doc(data), tag_items);\n     find_item(item_id, items)\n }\n@@ -291,7 +291,7 @@ fn enum_variant_ids(item: ebml::Doc, cdata: Cmd) -> ~[ast::DefId] {\n     return ids;\n }\n \n-fn item_path(item_doc: ebml::Doc) -> ast_map::path {\n+pub fn item_path(item_doc: ebml::Doc) -> ast_map::path {\n     let path_doc = reader::get_doc(item_doc, tag_path);\n \n     let len_doc = reader::get_doc(path_doc, tag_path_len);\n@@ -332,7 +332,7 @@ fn item_name(intr: @ident_interner, item: ebml::Doc) -> ast::Ident {\n     }\n }\n \n-fn item_to_def_like(item: ebml::Doc, did: ast::DefId, cnum: ast::CrateNum)\n+pub fn item_to_def_like(item: ebml::Doc, did: ast::DefId, cnum: ast::CrateNum)\n     -> DefLike {\n     let fam = item_family(item);\n     match fam {\n@@ -491,7 +491,7 @@ pub enum DefLike {\n     DlField\n }\n \n-fn def_like_to_def(def_like: DefLike) -> ast::Def {\n+pub fn def_like_to_def(def_like: DefLike) -> ast::Def {\n     match def_like {\n         DlDef(def) => return def,\n         DlImpl(*) => fail!(\"found impl in def_like_to_def\"),\n@@ -544,7 +544,8 @@ impl<'self> EachItemContext<'self> {\n     fn process_item_and_pop_name(&mut self,\n                                  doc: ebml::Doc,\n                                  def_id: ast::DefId,\n-                                 old_len: uint)\n+                                 old_len: uint,\n+                                 vis: ast::visibility)\n                                  -> bool {\n         let def_like = item_to_def_like(doc, def_id, self.cdata.cnum);\n         match def_like {\n@@ -563,8 +564,6 @@ impl<'self> EachItemContext<'self> {\n             }\n         }\n \n-        let vis = item_visibility(doc);\n-\n         let mut continue = (self.callback)(*self.path_builder, def_like, vis);\n \n         let family = item_family(doc);\n@@ -653,9 +652,12 @@ impl<'self> EachItemContext<'self> {\n                         self.push_name(token::ident_to_str(&child_name));\n \n                     // Process this item.\n+\n+                    let vis = item_visibility(child_item_doc);\n                     continue = self.process_item_and_pop_name(child_item_doc,\n                                                               child_def_id,\n-                                                              old_len);\n+                                                              old_len,\n+                                                              vis);\n                 }\n             }\n             continue\n@@ -701,12 +703,13 @@ impl<'self> EachItemContext<'self> {\n \n             // Get the item.\n             match maybe_find_item(def_id.node, other_crates_items) {\n-                None => {}\n+                None => { self.pop_name(old_len); }\n                 Some(reexported_item_doc) => {\n                     continue = self.process_item_and_pop_name(\n                         reexported_item_doc,\n                         def_id,\n-                        old_len);\n+                        old_len,\n+                        ast::public);\n                 }\n             }\n \n@@ -721,7 +724,8 @@ fn each_child_of_item_or_crate(intr: @ident_interner,\n                                cdata: Cmd,\n                                item_doc: ebml::Doc,\n                                get_crate_data: GetCrateDataCb,\n-                               callback: &fn(DefLike, ast::Ident)) {\n+                               callback: &fn(DefLike, ast::Ident,\n+                                             ast::visibility)) {\n     // Iterate over all children.\n     let _ = do reader::tagged_docs(item_doc, tag_mod_child) |child_info_doc| {\n         let child_def_id = reader::with_doc_data(child_info_doc,\n@@ -746,7 +750,8 @@ fn each_child_of_item_or_crate(intr: @ident_interner,\n                 let def_like = item_to_def_like(child_item_doc,\n                                                 child_def_id,\n                                                 cdata.cnum);\n-                callback(def_like, child_name);\n+                let visibility = item_visibility(child_item_doc);\n+                callback(def_like, child_name, visibility);\n \n             }\n         }\n@@ -788,7 +793,8 @@ fn each_child_of_item_or_crate(intr: @ident_interner,\n                                                          impl_method_def_id,\n                                                          cdata.cnum);\n                                     callback(static_method_def_like,\n-                                             static_method_name);\n+                                             static_method_name,\n+                                             item_visibility(impl_method_doc));\n                                 }\n                                 _ => {}\n                             }\n@@ -831,7 +837,8 @@ fn each_child_of_item_or_crate(intr: @ident_interner,\n                 let def_like = item_to_def_like(child_item_doc,\n                                                 child_def_id,\n                                                 cdata.cnum);\n-                callback(def_like, token::str_to_ident(name));\n+                callback(def_like, token::str_to_ident(name),\n+                         item_visibility(child_item_doc));\n             }\n         }\n \n@@ -844,7 +851,7 @@ pub fn each_child_of_item(intr: @ident_interner,\n                           cdata: Cmd,\n                           id: ast::NodeId,\n                           get_crate_data: GetCrateDataCb,\n-                          callback: &fn(DefLike, ast::Ident)) {\n+                          callback: &fn(DefLike, ast::Ident, ast::visibility)) {\n     // Find the item.\n     let root_doc = reader::Doc(cdata.data);\n     let items = reader::get_doc(root_doc, tag_items);\n@@ -864,7 +871,8 @@ pub fn each_child_of_item(intr: @ident_interner,\n pub fn each_top_level_item_of_crate(intr: @ident_interner,\n                                     cdata: Cmd,\n                                     get_crate_data: GetCrateDataCb,\n-                                    callback: &fn(DefLike, ast::Ident)) {\n+                                    callback: &fn(DefLike, ast::Ident,\n+                                                  ast::visibility)) {\n     let root_doc = reader::Doc(cdata.data);\n     let misc_info_doc = reader::get_doc(root_doc, tag_misc_info);\n     let crate_items_doc = reader::get_doc(misc_info_doc,\n@@ -1161,7 +1169,8 @@ pub fn get_static_methods_if_impl(intr: @ident_interner,\n                 static_impl_methods.push(StaticMethodInfo {\n                     ident: item_name(intr, impl_method_doc),\n                     def_id: item_def_id(impl_method_doc, cdata),\n-                    purity: purity\n+                    purity: purity,\n+                    vis: item_visibility(impl_method_doc),\n                 });\n             }\n             _ => {}"}, {"sha": "de60927f2a29d09fcda18b960adbbe342297cb71", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 19, "deletions": 4, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/10a583ce1ac28a8cbf34b0f4274285f33bdfce29/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10a583ce1ac28a8cbf34b0f4274285f33bdfce29/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=10a583ce1ac28a8cbf34b0f4274285f33bdfce29", "patch": "@@ -16,9 +16,9 @@ use metadata::cstore;\n use metadata::decoder;\n use metadata::tyencode;\n use middle::ty::{node_id_to_type, lookup_item_type};\n+use middle::astencode;\n use middle::ty;\n use middle::typeck;\n-use middle::astencode;\n use middle;\n \n use std::hashmap::{HashMap, HashSet};\n@@ -58,6 +58,7 @@ pub struct EncodeParams<'self> {\n     diag: @mut span_handler,\n     tcx: ty::ctxt,\n     reexports2: middle::resolve::ExportMap2,\n+    exported_items: @middle::privacy::ExportedItems,\n     item_symbols: &'self HashMap<ast::NodeId, ~str>,\n     discrim_symbols: &'self HashMap<ast::NodeId, @str>,\n     non_inlineable_statics: &'self HashSet<ast::NodeId>,\n@@ -88,6 +89,7 @@ pub struct EncodeContext<'self> {\n     tcx: ty::ctxt,\n     stats: @mut Stats,\n     reexports2: middle::resolve::ExportMap2,\n+    exported_items: @middle::privacy::ExportedItems,\n     item_symbols: &'self HashMap<ast::NodeId, ~str>,\n     discrim_symbols: &'self HashMap<ast::NodeId, @str>,\n     non_inlineable_statics: &'self HashSet<ast::NodeId>,\n@@ -881,7 +883,8 @@ fn encode_info_for_item(ecx: &EncodeContext,\n                         ebml_w: &mut writer::Encoder,\n                         item: @item,\n                         index: @mut ~[entry<i64>],\n-                        path: &[ast_map::path_elt]) {\n+                        path: &[ast_map::path_elt],\n+                        vis: ast::visibility) {\n     let tcx = ecx.tcx;\n \n     fn add_to_index_(item: @item, ebml_w: &writer::Encoder,\n@@ -912,6 +915,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         if !ecx.non_inlineable_statics.contains(&item.id) {\n             (ecx.encode_inlined_item)(ecx, ebml_w, path, ii_item(item));\n         }\n+        encode_visibility(ebml_w, vis);\n         ebml_w.end_tag();\n       }\n       item_fn(_, purity, _, ref generics, _) => {\n@@ -929,6 +933,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         } else {\n             encode_symbol(ecx, ebml_w, item.id);\n         }\n+        encode_visibility(ebml_w, vis);\n         ebml_w.end_tag();\n       }\n       item_mod(ref m) => {\n@@ -955,7 +960,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n             ebml_w.wr_str(def_to_str(local_def(foreign_item.id)));\n             ebml_w.end_tag();\n         }\n-\n+        encode_visibility(ebml_w, vis);\n         ebml_w.end_tag();\n       }\n       item_ty(*) => {\n@@ -967,6 +972,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_name(ecx, ebml_w, item.ident);\n         encode_path(ecx, ebml_w, path, ast_map::path_name(item.ident));\n         encode_region_param(ecx, ebml_w, item);\n+        encode_visibility(ebml_w, vis);\n         ebml_w.end_tag();\n       }\n       item_enum(ref enum_definition, ref generics) => {\n@@ -987,6 +993,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         // Encode inherent implementations for this enumeration.\n         encode_inherent_implementations(ecx, ebml_w, def_id);\n \n+        encode_visibility(ebml_w, vis);\n         ebml_w.end_tag();\n \n         encode_enum_variant_info(ecx,\n@@ -1018,6 +1025,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_attributes(ebml_w, item.attrs);\n         encode_path(ecx, ebml_w, path, ast_map::path_name(item.ident));\n         encode_region_param(ecx, ebml_w, item);\n+        encode_visibility(ebml_w, vis);\n \n         /* Encode def_ids for each field and method\n          for methods, write all the stuff get_trait_method\n@@ -1264,7 +1272,12 @@ fn my_visit_item(i:@item, items: ast_map::map, ebml_w:&writer::Encoder,\n             let mut ebml_w = ebml_w.clone();\n             // See above\n             let ecx : &EncodeContext = unsafe { cast::transmute(ecx_ptr) };\n-            encode_info_for_item(ecx, &mut ebml_w, i, index, *pt);\n+            let vis = if ecx.exported_items.contains(&i.id) {\n+                ast::public\n+            } else {\n+                ast::inherited\n+            };\n+            encode_info_for_item(ecx, &mut ebml_w, i, index, *pt, vis);\n         }\n         _ => fail!(\"bad item\")\n     }\n@@ -1727,6 +1740,7 @@ pub fn encode_metadata(parms: EncodeParams, crate: &Crate) -> ~[u8] {\n         diag,\n         tcx,\n         reexports2,\n+        exported_items,\n         discrim_symbols,\n         cstore,\n         encode_inlined_item,\n@@ -1742,6 +1756,7 @@ pub fn encode_metadata(parms: EncodeParams, crate: &Crate) -> ~[u8] {\n         tcx: tcx,\n         stats: stats,\n         reexports2: reexports2,\n+        exported_items: exported_items,\n         item_symbols: item_symbols,\n         discrim_symbols: discrim_symbols,\n         non_inlineable_statics: non_inlineable_statics,"}, {"sha": "c719146c99995fcd0da3201ee1df7b24de01dab3", "filename": "src/librustc/metadata/filesearch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10a583ce1ac28a8cbf34b0f4274285f33bdfce29/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10a583ce1ac28a8cbf34b0f4274285f33bdfce29/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs?ref=10a583ce1ac28a8cbf34b0f4274285f33bdfce29", "patch": "@@ -150,7 +150,7 @@ fn make_rustpkg_target_lib_path(dir: &Path,\n     dir.push_rel(&Path(libdir()).push(target_triple.to_owned()))\n }\n \n-fn get_or_default_sysroot() -> Path {\n+pub fn get_or_default_sysroot() -> Path {\n     match os::self_exe_path() {\n       option::Some(ref p) => (*p).pop(),\n       option::None => fail!(\"can't determine value for sysroot\")"}, {"sha": "3c60bd67362f7213302a883f013867a7c6c09cd8", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 144, "deletions": 46, "changes": 190, "blob_url": "https://github.com/rust-lang/rust/blob/10a583ce1ac28a8cbf34b0f4274285f33bdfce29/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10a583ce1ac28a8cbf34b0f4274285f33bdfce29/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=10a583ce1ac28a8cbf34b0f4274285f33bdfce29", "patch": "@@ -9,9 +9,13 @@\n // except according to those terms.\n \n //! A pass that checks to make sure private fields and methods aren't used\n-//! outside their scopes.\n+//! outside their scopes. This pass will also generate a set of exported items\n+//! which are available for use externally when compiled as a library.\n+\n+use std::hashmap::HashSet;\n \n use metadata::csearch;\n+use middle::resolve::ExportMap2;\n use middle::ty::{ty_struct, ty_enum};\n use middle::ty;\n use middle::typeck::{method_map, method_origin, method_param};\n@@ -37,9 +41,23 @@ use syntax::visit;\n use syntax::visit::Visitor;\n use syntax::ast::{_mod,Expr,item,Block,Pat};\n \n+// This set is a set of all item nodes which can be used by external crates if\n+// we're building a library. The necessary qualifications for this are that all\n+// items leading down to the current item (excluding an `impl`) must be `pub`.\n+pub type ExportedItems = HashSet<NodeId>;\n+\n+type Context<'self> = (&'self method_map, &'self ExportMap2);\n+\n struct PrivacyVisitor {\n     tcx: ty::ctxt,\n     privileged_items: @mut ~[NodeId],\n+\n+    // A set of all items which are re-exported to be used across crates\n+    exported_items: ExportedItems,\n+\n+    // A flag as to whether the current path is public all the way down to the\n+    // current point or not\n+    path_all_public: bool,\n }\n \n impl PrivacyVisitor {\n@@ -265,15 +283,20 @@ impl PrivacyVisitor {\n                                                      .last()\n                                                      .identifier)));\n                     }\n-                } else if csearch::get_item_visibility(self.tcx.sess.cstore,\n-                                                       def_id) != public {\n-                    self.tcx.sess.span_err(span,\n-                                      fmt!(\"function `%s` is private\",\n-                                           token::ident_to_str(\n-                                                &path.segments\n-                                                     .last()\n-                                                     .identifier)));\n+                //} else if csearch::get_item_visibility(self.tcx.sess.cstore,\n+                //                                       def_id) != public {\n+                //    self.tcx.sess.span_err(span,\n+                //                      fmt!(\"function `%s` is private\",\n+                //                           token::ident_to_str(\n+                //                                &path.segments\n+                //                                     .last()\n+                //                                     .identifier)));\n                 }\n+                // If this is a function from a non-local crate, then the\n+                // privacy check is enforced during resolve. All public items\n+                // will be tagged as such in the crate metadata and then usage\n+                // of the private items will be blocked during resolve. Hence,\n+                // if this isn't from the local crate, nothing to check.\n             }\n             _ => {}\n         }\n@@ -341,31 +364,78 @@ impl PrivacyVisitor {\n     }\n }\n \n-impl<'self> Visitor<&'self method_map> for PrivacyVisitor {\n+impl<'self> Visitor<Context<'self>> for PrivacyVisitor {\n \n-    fn visit_mod<'mm>(&mut self, the_module:&_mod, _:Span, _:NodeId,\n-                      method_map:&'mm method_map) {\n+    fn visit_mod(&mut self, the_module:&_mod, _:Span, _:NodeId,\n+                 cx: Context<'self>) {\n \n             let n_added = self.add_privileged_items(the_module.items);\n \n-            visit::walk_mod(self, the_module, method_map);\n+            visit::walk_mod(self, the_module, cx);\n \n             do n_added.times {\n                 ignore(self.privileged_items.pop());\n             }\n     }\n \n-    fn visit_item<'mm>(&mut self, item:@item, method_map:&'mm method_map) {\n+    fn visit_item(&mut self, item:@item, cx: Context<'self>) {\n+\n+        // Do not check privacy inside items with the resolve_unexported\n+        // attribute. This is used for the test runner.\n+        if attr::contains_name(item.attrs, \"!resolve_unexported\") {\n+            return;\n+        }\n+\n+        // Disallow unnecessary visibility qualifiers\n+        check_sane_privacy(self.tcx, item);\n \n-            // Do not check privacy inside items with the resolve_unexported\n-            // attribute. This is used for the test runner.\n-            if !attr::contains_name(item.attrs, \"!resolve_unexported\") {\n-                check_sane_privacy(self.tcx, item);\n-                visit::walk_item(self, item, method_map);\n+        // Keep track of whether this item is available for export or not.\n+        let orig_all_pub = self.path_all_public;\n+        match item.node {\n+            // impls/extern blocks do not break the \"public chain\" because they\n+            // cannot have visibility qualifiers on them anyway\n+            ast::item_impl(*) | ast::item_foreign_mod(*) => {}\n+\n+            // Private by default, hence we only retain the \"public chain\" if\n+            // `pub` is explicitly listed.\n+            _ => {\n+                self.path_all_public = orig_all_pub && item.vis == ast::public;\n+            }\n+        }\n+        debug2!(\"public path at {}: {}\", item.id, self.path_all_public);\n+\n+        if self.path_all_public {\n+            debug2!(\"all the way public {}\", item.id);\n+            self.exported_items.insert(item.id);\n+\n+            // All re-exported items in a module which is public should also be\n+            // public (in terms of how they should get encoded)\n+            match item.node {\n+                ast::item_mod(*) => {\n+                    let (_, exp_map2) = cx;\n+                    match exp_map2.find(&item.id) {\n+                        Some(exports) => {\n+                            for export in exports.iter() {\n+                                if export.reexport && is_local(export.def_id) {\n+                                    debug2!(\"found reexported {:?}\", export);\n+                                    let id = export.def_id.node;\n+                                    self.exported_items.insert(id);\n+                                }\n+                            }\n+                        }\n+                        None => {}\n+                    }\n+                }\n+                _ => {}\n             }\n+        }\n+\n+        visit::walk_item(self, item, cx);\n+\n+        self.path_all_public = orig_all_pub;\n     }\n \n-    fn visit_block<'mm>(&mut self, block:&Block, method_map:&'mm method_map) {\n+    fn visit_block(&mut self, block:&Block, cx: Context<'self>) {\n \n             // Gather up all the privileged items.\n             let mut n_added = 0;\n@@ -383,16 +453,16 @@ impl<'self> Visitor<&'self method_map> for PrivacyVisitor {\n                 }\n             }\n \n-            visit::walk_block(self, block, method_map);\n+            visit::walk_block(self, block, cx);\n \n             do n_added.times {\n                 ignore(self.privileged_items.pop());\n             }\n \n     }\n \n-    fn visit_expr<'mm>(&mut self, expr:@Expr, method_map:&'mm method_map) {\n-\n+    fn visit_expr(&mut self, expr:@Expr, cx: Context<'self>) {\n+        let (method_map, _) = cx;\n             match expr.node {\n                 ExprField(base, ident, _) => {\n                     // Method calls are now a special syntactic form,\n@@ -499,11 +569,11 @@ impl<'self> Visitor<&'self method_map> for PrivacyVisitor {\n                 _ => {}\n             }\n \n-            visit::walk_expr(self, expr, method_map);\n+            visit::walk_expr(self, expr, cx);\n \n     }\n \n-    fn visit_pat<'mm>(&mut self, pattern:@Pat, method_map:&'mm method_map) {\n+    fn visit_pat(&mut self, pattern:@Pat, cx: Context<'self>) {\n \n             match pattern.node {\n                 PatStruct(_, ref fields, _) => {\n@@ -550,38 +620,70 @@ impl<'self> Visitor<&'self method_map> for PrivacyVisitor {\n                 _ => {}\n             }\n \n-            visit::walk_pat(self, pattern, method_map);\n+            visit::walk_pat(self, pattern, cx);\n     }\n }\n \n-pub fn check_crate<'mm>(tcx: ty::ctxt,\n-                        method_map: &'mm method_map,\n-                        crate: &ast::Crate) {\n+pub fn check_crate(tcx: ty::ctxt,\n+                   method_map: &method_map,\n+                   exp_map2: &ExportMap2,\n+                   crate: &ast::Crate) -> ExportedItems {\n     let privileged_items = @mut ~[];\n \n     let mut visitor = PrivacyVisitor {\n         tcx: tcx,\n         privileged_items: privileged_items,\n+        exported_items: HashSet::new(),\n+        path_all_public: true, // start out as public\n     };\n-    visit::walk_crate(&mut visitor, crate, method_map);\n+    visit::walk_crate(&mut visitor, crate, (method_map, exp_map2));\n+    return visitor.exported_items;\n }\n \n /// Validates all of the visibility qualifers placed on the item given. This\n /// ensures that there are no extraneous qualifiers that don't actually do\n /// anything. In theory these qualifiers wouldn't parse, but that may happen\n /// later on down the road...\n fn check_sane_privacy(tcx: ty::ctxt, item: @ast::item) {\n+    let check_inherited = |sp: Span, vis: ast::visibility, note: &str| {\n+        if vis != ast::inherited {\n+            tcx.sess.span_err(sp, \"unnecessary visibility qualifier\");\n+            if note.len() > 0 {\n+                tcx.sess.span_note(sp, note);\n+            }\n+        }\n+    };\n+    let check_not_priv = |sp: Span, vis: ast::visibility, note: &str| {\n+        if vis == ast::private {\n+            tcx.sess.span_err(sp, \"unnecessary `priv` qualifier\");\n+            if note.len() > 0 {\n+                tcx.sess.span_note(sp, note);\n+            }\n+        }\n+    };\n     match item.node {\n         // implementations of traits don't need visibility qualifiers because\n         // that's controlled by having the trait in scope.\n         ast::item_impl(_, Some(*), _, ref methods) => {\n+            check_inherited(item.span, item.vis,\n+                            \"visibility qualifiers have no effect on trait impls\");\n             for m in methods.iter() {\n-                match m.vis {\n-                    ast::private | ast::public => {\n-                        tcx.sess.span_err(m.span, \"unnecessary visibility\")\n-                    }\n-                    ast::inherited => {}\n-                }\n+                check_inherited(m.span, m.vis, \"\");\n+            }\n+        }\n+\n+        ast::item_impl(_, _, _, ref methods) => {\n+            check_inherited(item.span, item.vis,\n+                            \"place qualifiers on individual methods instead\");\n+            for i in methods.iter() {\n+                check_not_priv(i.span, i.vis, \"functions are private by default\");\n+            }\n+        }\n+        ast::item_foreign_mod(ref fm) => {\n+            check_inherited(item.span, item.vis,\n+                            \"place qualifiers on individual functions instead\");\n+            for i in fm.items.iter() {\n+                check_not_priv(i.span, i.vis, \"functions are private by default\");\n             }\n         }\n \n@@ -624,22 +726,18 @@ fn check_sane_privacy(tcx: ty::ctxt, item: @ast::item) {\n             for m in methods.iter() {\n                 match *m {\n                     ast::provided(ref m) => {\n-                        match m.vis {\n-                            ast::private | ast::public => {\n-                                tcx.sess.span_err(m.span, \"unnecessary \\\n-                                                           visibility\");\n-                            }\n-                            ast::inherited => {}\n-                        }\n+                        check_inherited(m.span, m.vis,\n+                                        \"unnecessary visibility\");\n                     }\n-                    // this is warned about in the parser\n                     ast::required(*) => {}\n                 }\n             }\n         }\n \n-        ast::item_impl(*) | ast::item_static(*) | ast::item_foreign_mod(*) |\n+        ast::item_static(*) |\n         ast::item_fn(*) | ast::item_mod(*) | ast::item_ty(*) |\n-        ast::item_mac(*) => {}\n+        ast::item_mac(*) => {\n+            check_not_priv(item.span, item.vis, \"items are private by default\");\n+        }\n     }\n }"}, {"sha": "320baf3318164c5bfeb3113762fb8615fe82b344", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 19, "deletions": 11, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/10a583ce1ac28a8cbf34b0f4274285f33bdfce29/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10a583ce1ac28a8cbf34b0f4274285f33bdfce29/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=10a583ce1ac28a8cbf34b0f4274285f33bdfce29", "patch": "@@ -1661,6 +1661,9 @@ impl Resolver {\n                            ident: Ident,\n                            new_parent: ReducedGraphParent) {\n         let privacy = visibility_to_privacy(visibility);\n+        debug!(\"(building reduced graph for \\\n+                external crate) building external def, priv %?\",\n+               privacy);\n         match def {\n           DefMod(def_id) | DefForeignMod(def_id) | DefStruct(def_id) |\n           DefTy(def_id) => {\n@@ -1788,7 +1791,8 @@ impl Resolver {\n     fn build_reduced_graph_for_external_crate_def(@mut self,\n                                                   root: @mut Module,\n                                                   def_like: DefLike,\n-                                                  ident: Ident) {\n+                                                  ident: Ident,\n+                                                  visibility: visibility) {\n         match def_like {\n             DlDef(def) => {\n                 // Add the new child item, if necessary.\n@@ -1798,11 +1802,12 @@ impl Resolver {\n                         // eagerly.\n                         do csearch::each_child_of_item(self.session.cstore,\n                                                        def_id)\n-                                |def_like, child_ident| {\n+                                |def_like, child_ident, vis| {\n                             self.build_reduced_graph_for_external_crate_def(\n                                 root,\n                                 def_like,\n-                                child_ident)\n+                                child_ident,\n+                                vis)\n                         }\n                     }\n                     _ => {\n@@ -1813,7 +1818,7 @@ impl Resolver {\n                                            dummy_sp());\n \n                         self.handle_external_def(def,\n-                                                 public,\n+                                                 visibility,\n                                                  child_name_bindings,\n                                                  self.session.str_of(ident),\n                                                  ident,\n@@ -1897,10 +1902,11 @@ impl Resolver {\n                                     let def = DefFn(\n                                         static_method_info.def_id,\n                                         static_method_info.purity);\n+\n+                                    let p = visibility_to_privacy(\n+                                        static_method_info.vis);\n                                     method_name_bindings.define_value(\n-                                        Public,\n-                                        def,\n-                                        dummy_sp());\n+                                        p, def, dummy_sp());\n                                 }\n                             }\n \n@@ -1931,12 +1937,13 @@ impl Resolver {\n         };\n \n         do csearch::each_child_of_item(self.session.cstore, def_id)\n-                |def_like, child_ident| {\n+                |def_like, child_ident, visibility| {\n             debug!(\"(populating external module) ... found ident: %s\",\n                    token::ident_to_str(&child_ident));\n             self.build_reduced_graph_for_external_crate_def(module,\n                                                             def_like,\n-                                                            child_ident)\n+                                                            child_ident,\n+                                                            visibility)\n         }\n         module.populated = true\n     }\n@@ -1956,10 +1963,11 @@ impl Resolver {\n                                                   root: @mut Module) {\n         do csearch::each_top_level_item_of_crate(self.session.cstore,\n                                                  root.def_id.unwrap().crate)\n-                |def_like, ident| {\n+                |def_like, ident, visibility| {\n             self.build_reduced_graph_for_external_crate_def(root,\n                                                             def_like,\n-                                                            ident)\n+                                                            ident,\n+                                                            visibility)\n         }\n     }\n "}, {"sha": "f9527e6935ccc8e571fbb95f97128e063045a21a", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10a583ce1ac28a8cbf34b0f4274285f33bdfce29/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10a583ce1ac28a8cbf34b0f4274285f33bdfce29/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=10a583ce1ac28a8cbf34b0f4274285f33bdfce29", "patch": "@@ -3008,6 +3008,7 @@ pub fn crate_ctxt_to_encode_parms<'r>(cx: &'r CrateContext, ie: encoder::encode_\n             diag: diag,\n             tcx: cx.tcx,\n             reexports2: cx.exp_map2,\n+            exported_items: cx.exported_items,\n             item_symbols: item_symbols,\n             discrim_symbols: discrim_symbols,\n             non_inlineable_statics: &cx.non_inlineable_statics,\n@@ -3101,6 +3102,7 @@ pub fn trans_crate(sess: session::Session,\n                                      llmod_id,\n                                      analysis.ty_cx,\n                                      analysis.exp_map2,\n+                                     analysis.exported_items,\n                                      analysis.maps,\n                                      symbol_hasher,\n                                      link_meta,"}, {"sha": "134db45be43cb328ca80cee04c3f08828d63309c", "filename": "src/librustc/middle/trans/context.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/10a583ce1ac28a8cbf34b0f4274285f33bdfce29/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10a583ce1ac28a8cbf34b0f4274285f33bdfce29/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs?ref=10a583ce1ac28a8cbf34b0f4274285f33bdfce29", "patch": "@@ -16,6 +16,7 @@ use lib::llvm::{llvm, TargetData, TypeNames};\n use lib::llvm::mk_target_data;\n use metadata::common::LinkMeta;\n use middle::astencode;\n+use middle::privacy;\n use middle::resolve;\n use middle::trans::adt;\n use middle::trans::base;\n@@ -49,6 +50,7 @@ pub struct CrateContext {\n      intrinsics: HashMap<&'static str, ValueRef>,\n      item_vals: HashMap<ast::NodeId, ValueRef>,\n      exp_map2: resolve::ExportMap2,\n+     exported_items: @privacy::ExportedItems,\n      reachable: @mut HashSet<ast::NodeId>,\n      item_symbols: HashMap<ast::NodeId, ~str>,\n      link_meta: LinkMeta,\n@@ -127,6 +129,7 @@ impl CrateContext {\n                name: &str,\n                tcx: ty::ctxt,\n                emap2: resolve::ExportMap2,\n+               exported_items: @privacy::ExportedItems,\n                maps: astencode::Maps,\n                symbol_hasher: hash::State,\n                link_meta: LinkMeta,\n@@ -187,6 +190,7 @@ impl CrateContext {\n                   intrinsics: intrinsics,\n                   item_vals: HashMap::new(),\n                   exp_map2: emap2,\n+                  exported_items: exported_items,\n                   reachable: reachable,\n                   item_symbols: HashMap::new(),\n                   link_meta: link_meta,"}, {"sha": "5111682f6d061e0bed20ab9b33038e0cb5f7b627", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10a583ce1ac28a8cbf34b0f4274285f33bdfce29/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10a583ce1ac28a8cbf34b0f4274285f33bdfce29/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=10a583ce1ac28a8cbf34b0f4274285f33bdfce29", "patch": "@@ -702,7 +702,7 @@ impl AstBuilder for @ExtCtxt {\n                     attrs: attrs,\n                     id: ast::DUMMY_NODE_ID,\n                     node: node,\n-                    vis: ast::public,\n+                    vis: ast::inherited,\n                     span: span }\n     }\n "}, {"sha": "fe2aa05584d13335961bf1b6d1f97fed4acc423d", "filename": "src/libsyntax/parse/obsolete.rs", "status": "modified", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/10a583ce1ac28a8cbf34b0f4274285f33bdfce29/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10a583ce1ac28a8cbf34b0f4274285f33bdfce29/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fobsolete.rs?ref=10a583ce1ac28a8cbf34b0f4274285f33bdfce29", "patch": "@@ -44,7 +44,6 @@ pub enum ObsoleteSyntax {\n     ObsoleteImplSyntax,\n     ObsoleteMutOwnedPointer,\n     ObsoleteMutVector,\n-    ObsoleteImplVisibility,\n     ObsoleteRecordType,\n     ObsoleteRecordPattern,\n     ObsoletePostFnTySigil,\n@@ -60,9 +59,7 @@ pub enum ObsoleteSyntax {\n     ObsoleteNamedExternModule,\n     ObsoleteMultipleLocalDecl,\n     ObsoleteMutWithMultipleBindings,\n-    ObsoleteExternVisibility,\n     ObsoleteUnsafeExternFn,\n-    ObsoletePrivVisibility,\n     ObsoleteTraitFuncVisibility,\n     ObsoleteConstPointer,\n }\n@@ -161,11 +158,6 @@ impl ParserObsoleteMethods for Parser {\n                  in a mutable location, like a mutable local variable or an \\\n                  `@mut` box\"\n             ),\n-            ObsoleteImplVisibility => (\n-                \"visibility-qualified implementation\",\n-                \"`pub` or `priv` goes on individual functions; remove the \\\n-                 `pub` or `priv`\"\n-            ),\n             ObsoleteRecordType => (\n                 \"structural record type\",\n                 \"use a structure instead\"\n@@ -233,20 +225,11 @@ impl ParserObsoleteMethods for Parser {\n                 \"use multiple local declarations instead of e.g. `let mut \\\n                  (x, y) = ...`.\"\n             ),\n-            ObsoleteExternVisibility => (\n-                \"`pub extern` or `priv extern`\",\n-                \"place the `pub` or `priv` on the individual external items \\\n-                 instead\"\n-            ),\n             ObsoleteUnsafeExternFn => (\n                 \"unsafe external function\",\n                 \"external functions are always unsafe; remove the `unsafe` \\\n                  keyword\"\n             ),\n-            ObsoletePrivVisibility => (\n-                \"`priv` not necessary\",\n-                \"an item without a visibility qualifier is private by default\"\n-            ),\n             ObsoleteTraitFuncVisibility => (\n                 \"visibility not necessary\",\n                 \"trait functions inherit the visibility of the trait itself\""}, {"sha": "c0dcafa8fb2c1a2c349f1a4331754ff38f0cabfa", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 8, "deletions": 31, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/10a583ce1ac28a8cbf34b0f4274285f33bdfce29/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10a583ce1ac28a8cbf34b0f4274285f33bdfce29/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=10a583ce1ac28a8cbf34b0f4274285f33bdfce29", "patch": "@@ -922,7 +922,7 @@ impl Parser {\n             let attrs = p.parse_outer_attributes();\n             let lo = p.span.lo;\n \n-            let vis = p.parse_non_priv_visibility();\n+            let vis = p.parse_visibility();\n             let pur = p.parse_fn_purity();\n             // NB: at the moment, trait methods are public by default; this\n             // could change.\n@@ -3753,7 +3753,7 @@ impl Parser {\n         let attrs = self.parse_outer_attributes();\n         let lo = self.span.lo;\n \n-        let visa = self.parse_non_priv_visibility();\n+        let visa = self.parse_visibility();\n         let pur = self.parse_fn_purity();\n         let ident = self.parse_ident();\n         let generics = self.parse_generics();\n@@ -3801,7 +3801,7 @@ impl Parser {\n     // Parses two variants (with the region/type params always optional):\n     //    impl<T> Foo { ... }\n     //    impl<T> ToStr for ~[T] { ... }\n-    fn parse_item_impl(&self, visibility: ast::visibility) -> item_info {\n+    fn parse_item_impl(&self) -> item_info {\n         // First, parse type parameters if necessary.\n         let generics = self.parse_generics();\n \n@@ -3846,11 +3846,6 @@ impl Parser {\n             None\n         };\n \n-        // Do not allow visibility to be specified.\n-        if visibility != ast::inherited {\n-            self.obsolete(*self.span, ObsoleteImplVisibility);\n-        }\n-\n         let mut meths = ~[];\n         if !self.eat(&token::SEMI) {\n             self.expect(&token::LBRACE);\n@@ -4012,18 +4007,6 @@ impl Parser {\n         else { inherited }\n     }\n \n-    // parse visibility, but emits an obsolete error if it's private\n-    fn parse_non_priv_visibility(&self) -> visibility {\n-        match self.parse_visibility() {\n-            public => public,\n-            inherited => inherited,\n-            private => {\n-                self.obsolete(*self.last_span, ObsoletePrivVisibility);\n-                inherited\n-            }\n-        }\n-    }\n-\n     fn parse_staticness(&self) -> bool {\n         if self.eat_keyword(keywords::Static) {\n             self.obsolete(*self.last_span, ObsoleteStaticMethod);\n@@ -4216,7 +4199,7 @@ impl Parser {\n     // parse a function declaration from a foreign module\n     fn parse_item_foreign_fn(&self,  attrs: ~[Attribute]) -> @foreign_item {\n         let lo = self.span.lo;\n-        let vis = self.parse_non_priv_visibility();\n+        let vis = self.parse_visibility();\n \n         // Parse obsolete purity.\n         let purity = self.parse_fn_purity();\n@@ -4352,11 +4335,6 @@ impl Parser {\n                 self.obsolete(*self.last_span, ObsoleteNamedExternModule);\n             }\n \n-            // Do not allow visibility to be specified.\n-            if visibility != ast::inherited {\n-                self.obsolete(*self.last_span, ObsoleteExternVisibility);\n-            }\n-\n             let abis = opt_abis.unwrap_or(AbiSet::C());\n \n             let (inner, next) = self.parse_inner_attrs_and_next();\n@@ -4367,7 +4345,7 @@ impl Parser {\n                                           self.last_span.hi,\n                                           ident,\n                                           item_foreign_mod(m),\n-                                          public,\n+                                          visibility,\n                                           maybe_append(attrs, Some(inner))));\n         }\n \n@@ -4614,7 +4592,7 @@ impl Parser {\n \n         let lo = self.span.lo;\n \n-        let visibility = self.parse_non_priv_visibility();\n+        let visibility = self.parse_visibility();\n \n         // must be a view item:\n         if self.eat_keyword(keywords::Use) {\n@@ -4722,8 +4700,7 @@ impl Parser {\n         }\n         if self.eat_keyword(keywords::Impl) {\n             // IMPL ITEM\n-            let (ident, item_, extra_attrs) =\n-                self.parse_item_impl(visibility);\n+            let (ident, item_, extra_attrs) = self.parse_item_impl();\n             return iovi_item(self.mk_item(lo, self.last_span.hi, ident, item_,\n                                           visibility,\n                                           maybe_append(attrs, extra_attrs)));\n@@ -4746,7 +4723,7 @@ impl Parser {\n         maybe_whole!(iovi self, nt_item);\n         let lo = self.span.lo;\n \n-        let visibility = self.parse_non_priv_visibility();\n+        let visibility = self.parse_visibility();\n \n         if (self.is_keyword(keywords::Const) || self.is_keyword(keywords::Static)) {\n             // FOREIGN CONST ITEM"}, {"sha": "ea14229cc48a7520683d3871a3652581f86776ae", "filename": "src/test/auxiliary/issue2378a.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10a583ce1ac28a8cbf34b0f4274285f33bdfce29/src%2Ftest%2Fauxiliary%2Fissue2378a.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10a583ce1ac28a8cbf34b0f4274285f33bdfce29/src%2Ftest%2Fauxiliary%2Fissue2378a.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue2378a.rs?ref=10a583ce1ac28a8cbf34b0f4274285f33bdfce29", "patch": "@@ -11,7 +11,7 @@\n #[link (name = \"issue2378a\")];\n #[crate_type = \"lib\"];\n \n-enum maybe<T> { just(T), nothing }\n+pub enum maybe<T> { just(T), nothing }\n \n impl <T:Clone> Index<uint,T> for maybe<T> {\n     fn index(&self, _idx: &uint) -> T {"}, {"sha": "71c0bab138f46ec2437d2740306487c18789cac9", "filename": "src/test/auxiliary/issue2378b.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10a583ce1ac28a8cbf34b0f4274285f33bdfce29/src%2Ftest%2Fauxiliary%2Fissue2378b.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10a583ce1ac28a8cbf34b0f4274285f33bdfce29/src%2Ftest%2Fauxiliary%2Fissue2378b.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue2378b.rs?ref=10a583ce1ac28a8cbf34b0f4274285f33bdfce29", "patch": "@@ -15,7 +15,7 @@ extern mod issue2378a;\n \n use issue2378a::maybe;\n \n-struct two_maybes<T> {a: maybe<T>, b: maybe<T>}\n+pub struct two_maybes<T> {a: maybe<T>, b: maybe<T>}\n \n impl<T:Clone> Index<uint,(T,T)> for two_maybes<T> {\n     fn index(&self, idx: &uint) -> (T, T) {"}, {"sha": "96bae65639073de25c00b22890712223a740fd74", "filename": "src/test/auxiliary/nested_item.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10a583ce1ac28a8cbf34b0f4274285f33bdfce29/src%2Ftest%2Fauxiliary%2Fnested_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10a583ce1ac28a8cbf34b0f4274285f33bdfce29/src%2Ftest%2Fauxiliary%2Fnested_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fnested_item.rs?ref=10a583ce1ac28a8cbf34b0f4274285f33bdfce29", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n // original problem\n-fn foo<T>() -> int {\n+pub fn foo<T>() -> int {\n     {\n         static foo: int = 2;\n         foo"}, {"sha": "150de8d314d8f769d9ed1de9675f6eea98d73d1a", "filename": "src/test/auxiliary/packed.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10a583ce1ac28a8cbf34b0f4274285f33bdfce29/src%2Ftest%2Fauxiliary%2Fpacked.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10a583ce1ac28a8cbf34b0f4274285f33bdfce29/src%2Ftest%2Fauxiliary%2Fpacked.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fpacked.rs?ref=10a583ce1ac28a8cbf34b0f4274285f33bdfce29", "patch": "@@ -1,5 +1,5 @@\n #[packed]\n-struct S {\n+pub struct S {\n     a: u8,\n     b: u32\n }"}, {"sha": "d46ccf299e822550294f2008ba1e6fcff3cd7dff", "filename": "src/test/auxiliary/static_priv_by_default.rs", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/10a583ce1ac28a8cbf34b0f4274285f33bdfce29/src%2Ftest%2Fauxiliary%2Fstatic_priv_by_default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10a583ce1ac28a8cbf34b0f4274285f33bdfce29/src%2Ftest%2Fauxiliary%2Fstatic_priv_by_default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fstatic_priv_by_default.rs?ref=10a583ce1ac28a8cbf34b0f4274285f33bdfce29", "patch": "@@ -0,0 +1,57 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[crate_type = \"lib\"];\n+#[no_std];\n+\n+static private: int = 0;\n+pub static public: int = 0;\n+\n+pub struct A(());\n+\n+impl A {\n+    fn foo() {}\n+}\n+\n+mod foo {\n+    pub static a: int = 0;\n+    pub fn b() {}\n+    pub struct c;\n+    pub enum d {}\n+\n+    pub struct A(());\n+\n+    impl A {\n+        fn foo() {}\n+    }\n+\n+    // these are public so the parent can reexport them.\n+    pub static reexported_a: int = 0;\n+    pub fn reexported_b() {}\n+    pub struct reexported_c;\n+    pub enum reexported_d {}\n+}\n+\n+pub mod bar {\n+    pub use e = foo::reexported_a;\n+    pub use f = foo::reexported_b;\n+    pub use g = foo::reexported_c;\n+    pub use h = foo::reexported_d;\n+}\n+\n+pub static a: int = 0;\n+pub fn b() {}\n+pub struct c;\n+pub enum d {}\n+\n+static i: int = 0;\n+fn j() {}\n+struct k;\n+enum l {}"}, {"sha": "872f3b1010e2af2673e69b7c4b6e393e7058b1e3", "filename": "src/test/compile-fail/obsolete-syntax.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/10a583ce1ac28a8cbf34b0f4274285f33bdfce29/src%2Ftest%2Fcompile-fail%2Fobsolete-syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10a583ce1ac28a8cbf34b0f4274285f33bdfce29/src%2Ftest%2Fcompile-fail%2Fobsolete-syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fobsolete-syntax.rs?ref=10a583ce1ac28a8cbf34b0f4274285f33bdfce29", "patch": "@@ -54,9 +54,9 @@ extern mod obsolete_name {\n     fn bar();\n }\n \n-pub extern {\n-    //~^ ERROR obsolete syntax: `pub extern`\n-    pub fn bar();\n+trait A {\n+    pub fn foo(); //~ ERROR: visibility not necessary\n+    pub fn bar(); //~ ERROR: visibility not necessary\n }\n \n fn main() { }"}, {"sha": "db649ed0cc60632cbbbe59f49b624ed56b3d5b43", "filename": "src/test/compile-fail/priv-in-bad-locations.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/10a583ce1ac28a8cbf34b0f4274285f33bdfce29/src%2Ftest%2Fcompile-fail%2Fpriv-in-bad-locations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10a583ce1ac28a8cbf34b0f4274285f33bdfce29/src%2Ftest%2Fcompile-fail%2Fpriv-in-bad-locations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fpriv-in-bad-locations.rs?ref=10a583ce1ac28a8cbf34b0f4274285f33bdfce29", "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub extern {\n+    //~^ ERROR unnecessary visibility\n+    pub fn bar();\n+}\n+\n+trait A {\n+    fn foo() {}\n+}\n+\n+struct B;\n+\n+pub impl B {} //~ ERROR: unnecessary visibility\n+\n+pub impl A for B { //~ ERROR: unnecessary visibility\n+    pub fn foo() {} //~ ERROR: unnecessary visibility\n+}\n+\n+pub fn main() {}"}, {"sha": "59d7e23855c18dd7a4b09408bfb06ab89b13b639", "filename": "src/test/compile-fail/static-priv-by-default.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/10a583ce1ac28a8cbf34b0f4274285f33bdfce29/src%2Ftest%2Fcompile-fail%2Fstatic-priv-by-default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10a583ce1ac28a8cbf34b0f4274285f33bdfce29/src%2Ftest%2Fcompile-fail%2Fstatic-priv-by-default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstatic-priv-by-default.rs?ref=10a583ce1ac28a8cbf34b0f4274285f33bdfce29", "patch": "@@ -0,0 +1,39 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:static_priv_by_default.rs\n+\n+#[no_std];\n+\n+extern mod static_priv_by_default;\n+\n+mod child {\n+    pub mod childs_child {\n+        static private: int = 0;\n+        pub static public: int = 0;\n+    }\n+}\n+\n+fn foo(_: int) {}\n+\n+fn full_ref() {\n+    foo(static_priv_by_default::private); //~ ERROR: unresolved name\n+    foo(static_priv_by_default::public);\n+    foo(child::childs_child::private); //~ ERROR: unresolved name\n+    foo(child::childs_child::public);\n+}\n+\n+fn medium_ref() {\n+    use child::childs_child;\n+    foo(childs_child::private); //~ ERROR: unresolved name\n+    foo(childs_child::public);\n+}\n+\n+fn main() {}"}, {"sha": "28a17cf5e1c5ce214e0dc61ea6943d6bdd2927cd", "filename": "src/test/compile-fail/static-priv-by-default2.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/10a583ce1ac28a8cbf34b0f4274285f33bdfce29/src%2Ftest%2Fcompile-fail%2Fstatic-priv-by-default2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10a583ce1ac28a8cbf34b0f4274285f33bdfce29/src%2Ftest%2Fcompile-fail%2Fstatic-priv-by-default2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstatic-priv-by-default2.rs?ref=10a583ce1ac28a8cbf34b0f4274285f33bdfce29", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:static_priv_by_default.rs\n+\n+extern mod static_priv_by_default;\n+\n+mod child {\n+    pub mod childs_child {\n+        static private: int = 0;\n+        pub static public: int = 0;\n+    }\n+}\n+\n+fn main() {\n+    use static_priv_by_default::private; //~ ERROR: unresolved import\n+    //~^ ERROR: failed to resolve\n+    use static_priv_by_default::public;\n+    use child::childs_child::private; //~ ERROR: unresolved import\n+    //~^ ERROR: failed to resolve\n+    use child::childs_child::public;\n+}"}, {"sha": "29c87e77ac02b309d156d2e5b7c7b62f8edf7337", "filename": "src/test/compile-fail/useless-priv2.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/10a583ce1ac28a8cbf34b0f4274285f33bdfce29/src%2Ftest%2Fcompile-fail%2Fuseless-priv2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10a583ce1ac28a8cbf34b0f4274285f33bdfce29/src%2Ftest%2Fcompile-fail%2Fuseless-priv2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fuseless-priv2.rs?ref=10a583ce1ac28a8cbf34b0f4274285f33bdfce29", "patch": "@@ -12,8 +12,3 @@ pub trait E {\n     pub fn foo();               //~ ERROR: obsolete syntax\n }\n trait F { pub fn foo(); }       //~ ERROR: obsolete syntax\n-\n-struct B;\n-impl E for B {\n-    priv fn foo() {}             //~ ERROR: obsolete syntax\n-}"}, {"sha": "b4a999766b541c4aa35aa1375e114aeb19c7fca9", "filename": "src/test/compile-fail/xc-private-method.rs", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/10a583ce1ac28a8cbf34b0f4274285f33bdfce29/src%2Ftest%2Fcompile-fail%2Fxc-private-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10a583ce1ac28a8cbf34b0f4274285f33bdfce29/src%2Ftest%2Fcompile-fail%2Fxc-private-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fxc-private-method.rs?ref=10a583ce1ac28a8cbf34b0f4274285f33bdfce29", "patch": "@@ -1,16 +1,22 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n // xfail-fast\n // aux-build:xc_private_method_lib.rs\n \n extern mod xc_private_method_lib;\n \n fn main() {\n-    // normal method on struct\n-    let _ = xc_private_method_lib::Struct{ x: 10 }.meth_struct();  //~ ERROR method `meth_struct` is private\n-    // static method on struct\n-    let _ = xc_private_method_lib::Struct::static_meth_struct();  //~ ERROR method `static_meth_struct` is private\n+    let _ = xc_private_method_lib::Struct::static_meth_struct();\n+    //~^ ERROR: unresolved name\n \n-    // normal method on enum\n-    let _ = xc_private_method_lib::Variant1(20).meth_enum();  //~ ERROR method `meth_enum` is private\n-    // static method on enum\n-    let _ = xc_private_method_lib::Enum::static_meth_enum();  //~ ERROR method `static_meth_enum` is private\n+    let _ = xc_private_method_lib::Enum::static_meth_enum();\n+    //~^ ERROR: unresolved name\n }"}, {"sha": "c2eaa9287f495ba26ef8323c75d63ba89d83398f", "filename": "src/test/compile-fail/xc-private-method2.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/10a583ce1ac28a8cbf34b0f4274285f33bdfce29/src%2Ftest%2Fcompile-fail%2Fxc-private-method2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10a583ce1ac28a8cbf34b0f4274285f33bdfce29/src%2Ftest%2Fcompile-fail%2Fxc-private-method2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fxc-private-method2.rs?ref=10a583ce1ac28a8cbf34b0f4274285f33bdfce29", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// xfail-fast\n+// aux-build:xc_private_method_lib.rs\n+\n+extern mod xc_private_method_lib;\n+\n+fn main() {\n+    let _ = xc_private_method_lib::Struct{ x: 10 }.meth_struct();  //~ ERROR method `meth_struct` is private\n+\n+    let _ = xc_private_method_lib::Variant1(20).meth_enum();  //~ ERROR method `meth_enum` is private\n+}"}, {"sha": "38649981f939ca38cd0e59ab76626d90ac45b1f6", "filename": "src/test/compile-fail/xcrate-private-by-default.rs", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/10a583ce1ac28a8cbf34b0f4274285f33bdfce29/src%2Ftest%2Fcompile-fail%2Fxcrate-private-by-default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10a583ce1ac28a8cbf34b0f4274285f33bdfce29/src%2Ftest%2Fcompile-fail%2Fxcrate-private-by-default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fxcrate-private-by-default.rs?ref=10a583ce1ac28a8cbf34b0f4274285f33bdfce29", "patch": "@@ -0,0 +1,57 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:static_priv_by_default.rs\n+\n+#[allow(unused_imports)];\n+#[no_std];\n+\n+extern mod static_priv_by_default;\n+\n+fn foo<T>() {}\n+\n+#[start]\n+fn main(_: int, _: **u8, _: *u8) -> int {\n+    // Actual public items should be public\n+    static_priv_by_default::a;\n+    static_priv_by_default::b;\n+    static_priv_by_default::c;\n+    foo::<static_priv_by_default::d>();\n+\n+    // publicly re-exported items should be available\n+    static_priv_by_default::bar::e;\n+    static_priv_by_default::bar::f;\n+    static_priv_by_default::bar::g;\n+    foo::<static_priv_by_default::bar::h>();\n+\n+    // private items at the top should be inaccessible\n+    static_priv_by_default::i;\n+    //~^ ERROR: unresolved name\n+    static_priv_by_default::j;\n+    //~^ ERROR: unresolved name\n+    static_priv_by_default::k;\n+    //~^ ERROR: unresolved name\n+    foo::<static_priv_by_default::l>();\n+    //~^ ERROR: use of undeclared type name\n+    //~^^ ERROR: use of undeclared type name\n+\n+    // public items in a private mod should be inaccessible\n+    static_priv_by_default::foo::a;\n+    //~^ ERROR: unresolved name\n+    static_priv_by_default::foo::b;\n+    //~^ ERROR: unresolved name\n+    static_priv_by_default::foo::c;\n+    //~^ ERROR: unresolved name\n+    foo::<static_priv_by_default::foo::d>();\n+    //~^ ERROR: use of undeclared type name\n+    //~^^ ERROR: use of undeclared type name\n+\n+    3\n+}"}]}